<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ru" datatype="htmlbody" original="rust">
    <body>
      <group id="rust">
        <trans-unit id="4a1a063010e523349572dfe2f3d4599fdbf7faf0" translate="yes" xml:space="preserve">
          <source>The vector will not allocate until elements are pushed onto it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0be7c75604b320ccdf03b29c2cf5dc9816b16f93" translate="yes" xml:space="preserve">
          <source>The version of &lt;a href=&quot;http://www.unicode.org/&quot;&gt;Unicode&lt;/a&gt; that the Unicode parts of &lt;code&gt;char&lt;/code&gt; and &lt;code&gt;str&lt;/code&gt; methods are based on.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2e7d7937a98ae8b5db75096586d34257981a3b35" translate="yes" xml:space="preserve">
          <source>The version of the call operator that takes a by-value receiver.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="98bb0c84eb64933810db44150740704106b58e5b" translate="yes" xml:space="preserve">
          <source>The version of the call operator that takes a mutable receiver.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a10ea779af62c4002732377426c5466fd9b100f8" translate="yes" xml:space="preserve">
          <source>The version of the call operator that takes an immutable receiver.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="69df36660018fe57f4bfd6fa17c4ad5d9397540f" translate="yes" xml:space="preserve">
          <source>The volatile intrinsics provide operations intended to act on I/O memory, which are guaranteed to not be reordered by the compiler across other volatile intrinsics. See the LLVM documentation on [&lt;a href=&quot;http://llvm.org/docs/LangRef.html#volatile-memory-accesses&quot;&gt;volatile&lt;/a&gt;].</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3879e8ab569a056c97968189092bda667116aee8" translate="yes" xml:space="preserve">
          <source>The volatile parameter is set to &lt;code&gt;true&lt;/code&gt;, so it will not be optimized out unless size is equal to zero.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="545e192087f2dee8a1244b50285f56354faded13" translate="yes" xml:space="preserve">
          <source>The warning suggests that we use &lt;code&gt;_i&lt;/code&gt; as a name instead: the underscore indicates that we intend for this variable to be unused. We can automatically apply that suggestion using the &lt;code&gt;rustfix&lt;/code&gt; tool by running the command &lt;code&gt;cargo fix&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="71e5980a6bfd716abaaef858ffaa58512cff6b9e" translate="yes" xml:space="preserve">
          <source>The warning we get is this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="01d3cf24ed7ac31e045df84ed43b543301d5071c" translate="yes" xml:space="preserve">
          <source>The way in which you need to specify lifetime parameters depends on what your function is doing. For example, if we changed the implementation of the &lt;code&gt;longest&lt;/code&gt; function to always return the first parameter rather than the longest string slice, we wouldn&amp;rsquo;t need to specify a lifetime on the &lt;code&gt;y&lt;/code&gt; parameter. The following code will compile:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5b549318fc3f4ca028012969aeab8043ad858528" translate="yes" xml:space="preserve">
          <source>The way privacy works in Rust is that all items (functions, methods, structs, enums, modules, and constants) are private by default. Items in a parent module can&amp;rsquo;t use the private items inside child modules, but items in child modules can use the items in their ancestor modules. The reason is that child modules wrap and hide their implementation details, but the child modules can see the context in which they&amp;rsquo;re defined. To continue with the restaurant metaphor, think of the privacy rules as being like the back office of a restaurant: what goes on in there is private to restaurant customers, but office managers can see and do everything in the restaurant in which they operate.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c954766baf952dffb19514bc82ccc04508ad4747" translate="yes" xml:space="preserve">
          <source>The way to define helper attributes is to put an &lt;code&gt;attributes&lt;/code&gt; key in the &lt;code&gt;proc_macro_derive&lt;/code&gt; macro with a comma separated list of identifiers that are the names of the helper attributes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b4ad5969b00a7de4e50dcfbec4f420300a121d22" translate="yes" xml:space="preserve">
          <source>The way to demonstrate this behavior is by running the program with &lt;code&gt;&amp;gt;&lt;/code&gt; and the filename, &lt;em&gt;output.txt&lt;/em&gt;, that we want to redirect the standard output stream to. We won&amp;rsquo;t pass any arguments, which should cause an error:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4860fccc5b2b1b15ffbccd4a99af016a4e435d30" translate="yes" xml:space="preserve">
          <source>The wildcard pattern is always irrefutable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6ed876d97357afb4218b62acc26e1fb7fcb7f367" translate="yes" xml:space="preserve">
          <source>The workspace has one &lt;em&gt;target&lt;/em&gt; directory at the top level for the compiled artifacts to be placed into; the &lt;code&gt;adder&lt;/code&gt; crate doesn&amp;rsquo;t have its own &lt;em&gt;target&lt;/em&gt; directory. Even if we were to run &lt;code&gt;cargo build&lt;/code&gt; from inside the &lt;em&gt;adder&lt;/em&gt; directory, the compiled artifacts would still end up in &lt;em&gt;add/target&lt;/em&gt; rather than &lt;em&gt;add/adder/target&lt;/em&gt;. Cargo structures the &lt;em&gt;target&lt;/em&gt; directory in a workspace like this because the crates in a workspace are meant to depend on each other. If each crate had its own &lt;em&gt;target&lt;/em&gt; directory, each crate would have to recompile each of the other crates in the workspace to have the artifacts in its own &lt;em&gt;target&lt;/em&gt; directory. By sharing one &lt;em&gt;target&lt;/em&gt; directory, the crates can avoid unnecessary rebuilding.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="99d51b0abe084f304807f0bb44acfa16e7f4af5a" translate="yes" xml:space="preserve">
          <source>The worst case cost of &lt;code&gt;pop&lt;/code&gt; on a heap containing &lt;em&gt;n&lt;/em&gt; elements is O(log n).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="238b65c05553bd00df49cce92fea6a1b783b67b3" translate="yes" xml:space="preserve">
          <source>The worst case cost of a &lt;em&gt;single&lt;/em&gt; call to &lt;code&gt;push&lt;/code&gt; is O(n). The worst case occurs when capacity is exhausted and needs a resize. The resize cost has been amortized in the previous figures.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9abd2f24e6d1b46930e8a99311ffd002b596e31a" translate="yes" xml:space="preserve">
          <source>The writing portion of the &lt;a href=&quot;struct.tcpstream&quot;&gt;&lt;code&gt;TcpStream&lt;/code&gt;&lt;/a&gt; should be shut down.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4a689baec3acd327f6907f5ce5547d1d13e010a8" translate="yes" xml:space="preserve">
          <source>Their definition should always match the ABI defined in &lt;code&gt;rustc::back::abi&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="534bcf9b4ee06ae0b390b746db849c9e3d0f83df" translate="yes" xml:space="preserve">
          <source>Then create a new directory, &lt;em&gt;src/bin&lt;/em&gt;, and move the binary crate rooted in &lt;em&gt;src/main.rs&lt;/em&gt; into &lt;em&gt;src/bin/main.rs&lt;/em&gt;. Doing so will make the library crate the primary crate in the &lt;em&gt;hello&lt;/em&gt; directory; we can still run the binary in &lt;em&gt;src/bin/main.rs&lt;/em&gt; using &lt;code&gt;cargo run&lt;/code&gt;. After moving the &lt;em&gt;main.rs&lt;/em&gt; file, edit it to bring the library crate in and bring &lt;code&gt;ThreadPool&lt;/code&gt; into scope by adding the following code to the top of &lt;em&gt;src/bin/main.rs&lt;/em&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="848cf8d4f1542ccd5c9500b227f162479dfe2c8c" translate="yes" xml:space="preserve">
          <source>Then generate a new library crate named &lt;code&gt;add-one&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="02ec96ae1b226ff410efb69c0d4d60e58a7042ce" translate="yes" xml:space="preserve">
          <source>Then implementing the &lt;code&gt;OutlinePrint&lt;/code&gt; trait on &lt;code&gt;Point&lt;/code&gt; will compile successfully, and we can call &lt;code&gt;outline_print&lt;/code&gt; on a &lt;code&gt;Point&lt;/code&gt; instance to display it within an outline of asterisks.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3aac37973a618f0b45f35c262a8297327ce65a0e" translate="yes" xml:space="preserve">
          <source>Then install the language server support in your particular IDE; you&amp;rsquo;ll gain abilities such as autocompletion, jump to definition, and inline errors.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="636019afbd1be275dc1f855f27602c31a7743704" translate="yes" xml:space="preserve">
          <source>Then run &lt;code&gt;cargo test&lt;/code&gt; again. The output now shows &lt;code&gt;exploration&lt;/code&gt; instead of &lt;code&gt;it_works&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7eae4a5123d629fb5914cfbce2d33e244889b442" translate="yes" xml:space="preserve">
          <source>Then the compiler applies the first rule, which specifies that each parameter gets its own lifetime. We&amp;rsquo;ll call it &lt;code&gt;'a&lt;/code&gt; as usual, so now the signature is this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fe1bb69db1725d721fdb3af05034044cb61cb940" translate="yes" xml:space="preserve">
          <source>Then we add five new lines at the bottom that use the &lt;code&gt;Ordering&lt;/code&gt; type. The &lt;code&gt;cmp&lt;/code&gt; method compares two values and can be called on anything that can be compared. It takes a reference to whatever you want to compare with: here it&amp;rsquo;s comparing the &lt;code&gt;guess&lt;/code&gt; to the &lt;code&gt;secret_number&lt;/code&gt;. Then it returns a variant of the &lt;code&gt;Ordering&lt;/code&gt; enum we brought into scope with the &lt;code&gt;use&lt;/code&gt; statement. We use a &lt;a href=&quot;ch06-02-match&quot;&gt;&lt;code&gt;match&lt;/code&gt;&lt;/a&gt; expression to decide what to do next based on which variant of &lt;code&gt;Ordering&lt;/code&gt; was returned from the call to &lt;code&gt;cmp&lt;/code&gt; with the values in &lt;code&gt;guess&lt;/code&gt; and &lt;code&gt;secret_number&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="42504942265ee7c7c73ee70d30a7653d906cc136" translate="yes" xml:space="preserve">
          <source>Then we create a &lt;em&gt;src/front_of_house&lt;/em&gt; directory and a file &lt;em&gt;src/front_of_house/hosting.rs&lt;/em&gt; to contain the definitions made in the &lt;code&gt;hosting&lt;/code&gt; module:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8c054131a62b68de933e0bf587b858ee6793392b" translate="yes" xml:space="preserve">
          <source>Then we create a new &lt;code&gt;String&lt;/code&gt; in variable &lt;code&gt;s&lt;/code&gt; and call the &lt;code&gt;read_to_string&lt;/code&gt; method on the file handle in &lt;code&gt;f&lt;/code&gt; to read the contents of the file into &lt;code&gt;s&lt;/code&gt;. The &lt;code&gt;read_to_string&lt;/code&gt; method also returns a &lt;code&gt;Result&lt;/code&gt; because it might fail, even though &lt;code&gt;File::open&lt;/code&gt; succeeded. So we need another &lt;code&gt;match&lt;/code&gt; to handle that &lt;code&gt;Result&lt;/code&gt;: if &lt;code&gt;read_to_string&lt;/code&gt; succeeds, then our function has succeeded, and we return the username from the file that&amp;rsquo;s now in &lt;code&gt;s&lt;/code&gt; wrapped in an &lt;code&gt;Ok&lt;/code&gt;. If &lt;code&gt;read_to_string&lt;/code&gt; fails, we return the error value in the same way that we returned the error value in the &lt;code&gt;match&lt;/code&gt; that handled the return value of &lt;code&gt;File::open&lt;/code&gt;. However, we don&amp;rsquo;t need to explicitly say &lt;code&gt;return&lt;/code&gt;, because this is the last expression in the function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="deae9012508053fe94f96907583eae7e4c8a687f" translate="yes" xml:space="preserve">
          <source>Then we implement an associated function named &lt;code&gt;new&lt;/code&gt; on &lt;code&gt;Guess&lt;/code&gt; that creates instances of &lt;code&gt;Guess&lt;/code&gt; values. The &lt;code&gt;new&lt;/code&gt; function is defined to have one parameter named &lt;code&gt;value&lt;/code&gt; of type &lt;code&gt;i32&lt;/code&gt; and to return a &lt;code&gt;Guess&lt;/code&gt;. The code in the body of the &lt;code&gt;new&lt;/code&gt; function tests &lt;code&gt;value&lt;/code&gt; to make sure it&amp;rsquo;s between 1 and 100. If &lt;code&gt;value&lt;/code&gt; doesn&amp;rsquo;t pass this test, we make a &lt;code&gt;panic!&lt;/code&gt; call, which will alert the programmer who is writing the calling code that they have a bug they need to fix, because creating a &lt;code&gt;Guess&lt;/code&gt; with a &lt;code&gt;value&lt;/code&gt; outside this range would violate the contract that &lt;code&gt;Guess::new&lt;/code&gt; is relying on. The conditions in which &lt;code&gt;Guess::new&lt;/code&gt; might panic should be discussed in its public-facing API documentation; we&amp;rsquo;ll cover documentation conventions indicating the possibility of a &lt;code&gt;panic!&lt;/code&gt; in the API documentation that you create in Chapter 14. If &lt;code&gt;value&lt;/code&gt; does pass the test, we create a new &lt;code&gt;Guess&lt;/code&gt; with its &lt;code&gt;value&lt;/code&gt; field set to the &lt;code&gt;value&lt;/code&gt; parameter and return the &lt;code&gt;Guess&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="06b6b70a87228a4df8ed0e498c6c809f243dabd9" translate="yes" xml:space="preserve">
          <source>Then we return two mutable slices in a tuple: one from the start of the original slice to the &lt;code&gt;mid&lt;/code&gt; index and another from &lt;code&gt;mid&lt;/code&gt; to the end of the slice.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="884190657324310c04e2504f5fc0e76845d895ae" translate="yes" xml:space="preserve">
          <source>Then you must define an implementation for &lt;code&gt;cmp()&lt;/code&gt;. You may find it useful to use &lt;code&gt;cmp()&lt;/code&gt; on your type's fields.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0d177ce772cf21906084a9438690b47406434422" translate="yes" xml:space="preserve">
          <source>Then you&amp;rsquo;ll learn how to use &lt;em&gt;traits&lt;/em&gt; to define behavior in a generic way. You can combine traits with generic types to constrain a generic type to only those types that have a particular behavior, as opposed to just any type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ddeec83a6e1ebd77d0b40c2a12564ec960334a02" translate="yes" xml:space="preserve">
          <source>Then, for each candidate type &lt;code&gt;T&lt;/code&gt;, search for a &lt;a href=&quot;../visibility-and-privacy&quot;&gt;visible&lt;/a&gt; method with a receiver of that type in the following places:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c7f32ff9ae959e326529e5b742ae1c333e7b2254" translate="yes" xml:space="preserve">
          <source>Then, in your new &lt;em&gt;variables&lt;/em&gt; directory, open &lt;em&gt;src/main.rs&lt;/em&gt; and replace its code with the following code that won&amp;rsquo;t compile just yet:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cbbc8078ba28a9ecb4224d46afd42558773fa640" translate="yes" xml:space="preserve">
          <source>Then, to bring &lt;code&gt;rand&lt;/code&gt; definitions into the scope of our package, we added a &lt;code&gt;use&lt;/code&gt; line starting with the name of the package, &lt;code&gt;rand&lt;/code&gt;, and listed the items we wanted to bring into scope. Recall that in the &lt;a href=&quot;ch02-00-guessing-game-tutorial#generating-a-random-number&quot;&gt;&amp;ldquo;Generating a Random Number&amp;rdquo;&lt;/a&gt; section in Chapter 2, we brought the &lt;code&gt;Rng&lt;/code&gt; trait into scope and called the &lt;code&gt;rand::thread_rng&lt;/code&gt; function:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ea0671790854fadbc007a7d3ab3c99a7a0c53f74" translate="yes" xml:space="preserve">
          <source>Theoretically, this code should compile. Unfortunately, the Rust compiler isn&amp;rsquo;t perfect yet, and we get this error:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7bb0fb711ce84d52df9718e0b2a2ec2dabc6a07f" translate="yes" xml:space="preserve">
          <source>There are a couple of solutions for this.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="530488aa6f064fc1ecb7dc7a5a0bf4b2dc63964c" translate="yes" xml:space="preserve">
          <source>There are a few things that &lt;code&gt;transmute&lt;/code&gt; is really useful for.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e38257a0874550d292627aecb2605763613ccaf1" translate="yes" xml:space="preserve">
          <source>There are a handful of shortcuts provided to make writing constructors more convenient, most common of which is the Field Init shorthand. When there is a variable and a field of the same name, the assignment can be simplified from &lt;code&gt;field: field&lt;/code&gt; into simply &lt;code&gt;field&lt;/code&gt;. The following example of a hypothetical constructor demonstrates this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="63a966968ec2346aede6a0d18395aa406c237072" translate="yes" xml:space="preserve">
          <source>There are a number of &lt;a href=&quot;#functions-1&quot;&gt;functions&lt;/a&gt; that offer access to various features. For example, we can use three of these functions to copy everything from standard input to standard output:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1f79d0ffb253cf5d15cccef1c760f3edf4c3cd7b" translate="yes" xml:space="preserve">
          <source>There are a number of &lt;code&gt;debug_*&lt;/code&gt; methods on &lt;a href=&quot;struct.formatter&quot;&gt;&lt;code&gt;Formatter&lt;/code&gt;&lt;/a&gt; to help you with manual implementations, such as &lt;a href=&quot;struct.formatter#method.debug_struct&quot;&gt;&lt;code&gt;debug_struct&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="087920b8740a66ec282180bff3885f708e5bb842" translate="yes" xml:space="preserve">
          <source>There are a number of related macros in the &lt;a href=&quot;../macro.format&quot;&gt;&lt;code&gt;format!&lt;/code&gt;&lt;/a&gt; family. The ones that are currently implemented are:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="28043d56de08a63f7e30e165bfcf6d512b961039" translate="yes" xml:space="preserve">
          <source>There are also some platform-specific ABI strings:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cb600a231699778e7c442e8d1b0c5af1c6ce3e98" translate="yes" xml:space="preserve">
          <source>There are conflicting trait implementations for the same type. Example of erroneous code:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c7d32d1dc6c93776049af2c0d8da18ad1a5c107b" translate="yes" xml:space="preserve">
          <source>There are insufficient permissions to access the current directory.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c57d9d7a8463095f936949e3bd422fd7ce763db3" translate="yes" xml:space="preserve">
          <source>There are multiple trade-offs to consider in addition to the prevention of bugs. For example, in cases where you&amp;rsquo;re using large data structures, mutating an instance in place may be faster than copying and returning newly allocated instances. With smaller data structures, creating new instances and writing in a more functional programming style may be easier to think through, so lower performance might be a worthwhile penalty for gaining that clarity.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d53022046c1585c76ce2c3d1de0757bc5d58a5d7" translate="yes" xml:space="preserve">
          <source>There are multiple ways to create a new &lt;a href=&quot;struct.string&quot;&gt;&lt;code&gt;String&lt;/code&gt;&lt;/a&gt; from a string literal:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b89e39f486cb11ae236a0c1ba092d84b1be61d5a" translate="yes" xml:space="preserve">
          <source>There are multiple ways we could change how our web server works to avoid having more requests back up behind a slow request; the one we&amp;rsquo;ll implement is a thread pool.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cbbb8fb2683dd85eb0ca22283c9bb44fdd37598e" translate="yes" xml:space="preserve">
          <source>There are no function calls, macros, or even &lt;code&gt;let&lt;/code&gt; statements in the &lt;code&gt;five&lt;/code&gt; function&amp;mdash;just the number &lt;code&gt;5&lt;/code&gt; by itself. That&amp;rsquo;s a perfectly valid function in Rust. Note that the function&amp;rsquo;s return type is specified too, as &lt;code&gt;-&amp;gt; i32&lt;/code&gt;. Try running this code; the output should look like this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e3048305fc74fc67f0b28e1af09fa647633b200c" translate="yes" xml:space="preserve">
          <source>There are no generic type parameters.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6dc334d98456ba931a1cb0e3e3cebe2b287fda18" translate="yes" xml:space="preserve">
          <source>There are no guarantees of data layout made by this representation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a86100f636fbb472fb5b1863356f0448a9ae85a5" translate="yes" xml:space="preserve">
          <source>There are no guarantees whatsover that offsetting the pointer will not overflow or go beyond the allocation that the pointer points into. It is up to the caller to ensure that the returned offset is correct in all terms other than alignment.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="19e4b768de5872c5fc351b9acc570966e33874d6" translate="yes" xml:space="preserve">
          <source>There are several functions and structs in this module that have a counterpart ending in &lt;code&gt;os&lt;/code&gt;. Those ending in &lt;code&gt;os&lt;/code&gt; will return an &lt;a href=&quot;../ffi/struct.osstring&quot;&gt;&lt;code&gt;OsString&lt;/code&gt;&lt;/a&gt; and those without will be returning a &lt;a href=&quot;../string/struct.string&quot;&gt;&lt;code&gt;String&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="171ee597fab4c6d0bdea510dd3f56d6a9c12c0b6" translate="yes" xml:space="preserve">
          <source>There are several implementations of common traits for slices. Some examples include:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0f5d6b4dc4e0f0d18f10b896c43b04863d873b17" translate="yes" xml:space="preserve">
          <source>There are several kinds of items:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5ab16cf7d574dfc1dbe1b281f7a85326a916ba94" translate="yes" xml:space="preserve">
          <source>There are several structs that are useful for slices, such as &lt;a href=&quot;struct.iter&quot;&gt;&lt;code&gt;Iter&lt;/code&gt;&lt;/a&gt;, which represents iteration over a slice.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="567ae72d32f4d2be3989eaf8a9904e62f889b537" translate="yes" xml:space="preserve">
          <source>There are six &lt;code&gt;char&lt;/code&gt; values here, but the fourth and sixth are not letters: they&amp;rsquo;re diacritics that don&amp;rsquo;t make sense on their own. Finally, if we look at them as grapheme clusters, we&amp;rsquo;d get what a person would call the four letters that make up the Hindi word:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6ce75e9d71dbebf75ae807b3a16056d1528fd37b" translate="yes" xml:space="preserve">
          <source>There are some known bugs that trigger this message.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="926439ef5401fe133e30f193394b46730a6ce040" translate="yes" xml:space="preserve">
          <source>There are some strange edge cases with &lt;code&gt;macro_rules!&lt;/code&gt;. In the future, Rust will have a second kind of declarative macro that will work in a similar fashion but fix some of these edge cases. After that update, &lt;code&gt;macro_rules!&lt;/code&gt; will be effectively deprecated. With this in mind, as well as the fact that most Rust programmers will &lt;em&gt;use&lt;/em&gt; macros more than &lt;em&gt;write&lt;/em&gt; macros, we won&amp;rsquo;t discuss &lt;code&gt;macro_rules!&lt;/code&gt; any further. To learn more about how to write macros, consult the online documentation or other resources, such as &lt;a href=&quot;https://danielkeep.github.io/tlborm/book/index.html&quot;&gt;&amp;ldquo;The Little Book of Rust Macros&amp;rdquo;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="720348f040959c3669acec057ca2d47ad7fb3d69" translate="yes" xml:space="preserve">
          <source>There are three ABI strings which are cross-platform, and which all compilers are guaranteed to support:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0142bb3f41cab04708310e3fe823a323c32ee0b3" translate="yes" xml:space="preserve">
          <source>There are three common methods which can create iterators from a collection:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="987579e087a6ff5bbf6e70931c97c8842a5d0e0c" translate="yes" xml:space="preserve">
          <source>There are three possible ways to specify the desired &lt;code&gt;precision&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3a65e426e444ff8c29bebad4488c8514ade91574" translate="yes" xml:space="preserve">
          <source>There are three ways to use the inline attribute:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="481486972e8a90ddff463b54cf1c4f208b0477e6" translate="yes" xml:space="preserve">
          <source>There are two input lifetimes, so Rust applies the first lifetime elision rule and gives both &lt;code&gt;&amp;amp;self&lt;/code&gt; and &lt;code&gt;announcement&lt;/code&gt; their own lifetimes. Then, because one of the parameters is &lt;code&gt;&amp;amp;self&lt;/code&gt;, the return type gets the lifetime of &lt;code&gt;&amp;amp;self&lt;/code&gt;, and all lifetimes have been accounted for.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c1575bd4949a087cd0961e57e825f5b7d2464821" translate="yes" xml:space="preserve">
          <source>There are two main ways to read this document.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="86663982f114c71c4b638d9b0fa35d92d8fc55c4" translate="yes" xml:space="preserve">
          <source>There are two options that would work instead. The first would be to change the line &lt;code&gt;example_func(&amp;amp;example_string);&lt;/code&gt; to &lt;code&gt;example_func(example_string.as_str());&lt;/code&gt;, using the method &lt;a href=&quot;struct.string#method.as_str&quot;&gt;&lt;code&gt;as_str()&lt;/code&gt;&lt;/a&gt; to explicitly extract the string slice containing the string. The second way changes &lt;code&gt;example_func(&amp;amp;example_string);&lt;/code&gt; to &lt;code&gt;example_func(&amp;amp;*example_string);&lt;/code&gt;. In this case we are dereferencing a &lt;code&gt;String&lt;/code&gt; to a &lt;a href=&quot;../primitive.str&quot;&gt;&lt;code&gt;str&lt;/code&gt;&lt;/a&gt;, then referencing the &lt;a href=&quot;../primitive.str&quot;&gt;&lt;code&gt;str&lt;/code&gt;&lt;/a&gt; back to &lt;a href=&quot;../primitive.str&quot;&gt;&lt;code&gt;&amp;amp;str&lt;/code&gt;&lt;/a&gt;. The second way is more idiomatic, however both work to do the conversion explicitly rather than relying on the implicit conversion.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="022a56e5687a1a83c185eae56c2be99a7be6379c" translate="yes" xml:space="preserve">
          <source>There are two options to work around this issue. The first is simply to rename one of the types. Alternatively, one can specify the intended type using the following syntax:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7601f9a3aa302729abcf51730ab0dacad11e1f7d" translate="yes" xml:space="preserve">
          <source>There are two possible solutions:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3f08d38f311f1d8aebf1cc8c4c04305ba58884d5" translate="yes" xml:space="preserve">
          <source>There are two syntactic forms for creating an array:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="86a631e5c1cd817983c93f98903db4ea59d68db2" translate="yes" xml:space="preserve">
          <source>There are two types of implementations:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fa155718008a683c96cef5cc6a71a54ea03f305c" translate="yes" xml:space="preserve">
          <source>There are two ways to define new macros:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9880ebdf9a583de2d652297bd89e0b5ff4d36ffb" translate="yes" xml:space="preserve">
          <source>There are two ways to implement &lt;code&gt;Copy&lt;/code&gt; on your type. The simplest is to use &lt;code&gt;derive&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dc647999e3aa70d53b9f18def550d41889259047" translate="yes" xml:space="preserve">
          <source>There are various restrictions on transmuting between types in Rust; for example types being transmuted must have the same size. To apply all these restrictions, the compiler must know the exact types that may be transmuted. When type parameters are involved, this cannot always be done.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0019607d06d61b11d32e87172ee0ea679ebbb977" translate="yes" xml:space="preserve">
          <source>There are various rules:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0d6ed4037ecbcc5953e35640da903ed6a8a40981" translate="yes" xml:space="preserve">
          <source>There can only be one owner at a time.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f4471e590e73989497aca327361dde4b0c93c59c" translate="yes" xml:space="preserve">
          <source>There is a difference between what the &lt;code&gt;match&lt;/code&gt; expression from Listing 9-6 and the &lt;code&gt;?&lt;/code&gt; operator do: error values that have the &lt;code&gt;?&lt;/code&gt; operator called on them go through the &lt;code&gt;from&lt;/code&gt; function, defined in the &lt;code&gt;From&lt;/code&gt; trait in the standard library, which is used to convert errors from one type into another. When the &lt;code&gt;?&lt;/code&gt; operator calls the &lt;code&gt;from&lt;/code&gt; function, the error type received is converted into the error type defined in the return type of the current function. This is useful when a function returns one error type to represent all the ways a function might fail, even if parts might fail for many different reasons. As long as each error type implements the &lt;code&gt;from&lt;/code&gt; function to define how to convert itself to the returned error type, the &lt;code&gt;?&lt;/code&gt; operator takes care of the conversion automatically.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6b478d4cf3daf7fb5af886fd070b460cffb3f99a" translate="yes" xml:space="preserve">
          <source>There is a large variety of prefix types, see &lt;a href=&quot;enum.prefix&quot;&gt;&lt;code&gt;Prefix&lt;/code&gt;&lt;/a&gt;'s documentation for more.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9b02d233f669a1e206e4e2c20ce1d2df695bab4c" translate="yes" xml:space="preserve">
          <source>There is a natural point at which we can return the memory our &lt;code&gt;String&lt;/code&gt; needs to the operating system: when &lt;code&gt;s&lt;/code&gt; goes out of scope. When a variable goes out of scope, Rust calls a special function for us. This function is called &lt;code&gt;drop&lt;/code&gt;, and it&amp;rsquo;s where the author of &lt;code&gt;String&lt;/code&gt; can put the code to return the memory. Rust calls &lt;code&gt;drop&lt;/code&gt; automatically at the closing curly bracket.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f99c36775b0b7e1c59faa2f7b94f6fd5d85206bb" translate="yes" xml:space="preserve">
          <source>There is a small difference between the two: the &lt;code&gt;derive&lt;/code&gt; strategy will also place a &lt;code&gt;Copy&lt;/code&gt; bound on type parameters, which isn't always desired.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ba88e1e16f5f4f6fd310c5a8bb2e8dd5b7b7dc78" translate="yes" xml:space="preserve">
          <source>There is currently a known issue (see &lt;a href=&quot;https://github.com/rust-lang/rust/issues/39364&quot;&gt;&lt;code&gt;#39364&lt;/code&gt;&lt;/a&gt;) that causes &lt;code&gt;recv_timeout&lt;/code&gt; to panic unexpectedly with the following example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ac69e37cd6f18587422e7c6b701f3aed59b4a925" translate="yes" xml:space="preserve">
          <source>There is currently no supported way to create a raw pointer or reference to a field of a struct inside &lt;code&gt;MaybeUninit&amp;lt;Struct&amp;gt;&lt;/code&gt;. That means it is not possible to create a struct by calling &lt;code&gt;MaybeUninit::uninit::&amp;lt;Struct&amp;gt;()&lt;/code&gt; and then writing to its fields.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="06e1ced9251455647a44280e8880c2f024531277" translate="yes" xml:space="preserve">
          <source>There is no consensus in the programming community about what features a language must have to be considered object oriented. Rust is influenced by many programming paradigms, including OOP; for example, we explored the features that came from functional programming in Chapter 13. Arguably, OOP languages share certain common characteristics, namely objects, encapsulation, and inheritance. Let&amp;rsquo;s look at what each of those characteristics means and whether Rust supports it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3940029042247daa011ed3a6db287dfc70d15650" translate="yes" xml:space="preserve">
          <source>There is no guarantee that an all-zero byte-pattern represents a valid value of some type &lt;code&gt;T&lt;/code&gt;. For example, the all-zero byte-pattern is not a valid value for reference types (&lt;code&gt;&amp;amp;T&lt;/code&gt; and &lt;code&gt;&amp;amp;mut T&lt;/code&gt;). Using &lt;code&gt;zeroed&lt;/code&gt; on such types causes immediate &lt;a href=&quot;../../reference/behavior-considered-undefined&quot;&gt;undefined behavior&lt;/a&gt; because &lt;a href=&quot;union.maybeuninit#initialization-invariant&quot;&gt;the Rust compiler assumes&lt;/a&gt; that there always is a valid value in a variable it considers initialized.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="77cd938f61b73cdc8199024bd862cf47becca43c" translate="yes" xml:space="preserve">
          <source>There is no guarantee that the memory pointed to by &lt;code&gt;ptr&lt;/code&gt; contains a valid nul terminator byte at the end of the string.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="37d385330ea581c420be55585ac9b53b42ed4426" translate="yes" xml:space="preserve">
          <source>There is no guarantee to the validity of &lt;code&gt;ptr&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="96d59d760142fd31188eb3940b02911fcbc69887" translate="yes" xml:space="preserve">
          <source>There is no implementation of &lt;a href=&quot;https://doc.rust-lang.org/core/ops/trait.Drop.html&quot;&gt;&lt;code&gt;Drop&lt;/code&gt;&lt;/a&gt; for child processes, so if you do not ensure the &lt;code&gt;Child&lt;/code&gt; has exited then it will continue to run, even after the &lt;code&gt;Child&lt;/code&gt; handle to the child process has gone out of scope.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f7865277b670de1ac383b78686d6c6c3ef225ff1" translate="yes" xml:space="preserve">
          <source>There is no implicit capture of the containing function's generic parameters, parameters, and local variables. For example, &lt;code&gt;inner&lt;/code&gt; may not access &lt;code&gt;outer_var&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="98bc5a98bb823e7a07123a40b084c3311e58d239" translate="yes" xml:space="preserve">
          <source>There is no meaningful value to associate with your keys.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e47f071471a1ed59d24ce5598360fe16b663897e" translate="yes" xml:space="preserve">
          <source>There is no syntax that directly refers to a function item type, but the compiler will display the type as something like &lt;code&gt;fn(u32) -&amp;gt; i32 {fn_name}&lt;/code&gt; in error messages.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6352ff90262f746d2ceb9b5382b99f239203c508" translate="yes" xml:space="preserve">
          <source>There is no way to express the &lt;code&gt;if x &amp;lt; 5&lt;/code&gt; condition within a pattern, so the match guard gives us the ability to express this logic.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f04c5e1cecb9254e859f18bc80c9ad5ecd03b1f1" translate="yes" xml:space="preserve">
          <source>There is no way to refer to all trait objects generically, so the only way to create values of this type is with functions like &lt;a href=&quot;../intrinsics/fn.transmute&quot;&gt;&lt;code&gt;std::mem::transmute&lt;/code&gt;&lt;/a&gt;. Similarly, the only way to create a true trait object from a &lt;code&gt;TraitObject&lt;/code&gt; value is with &lt;code&gt;transmute&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e9f689cb8e372a1fb3e4dbcf70bbf33a833163e2" translate="yes" xml:space="preserve">
          <source>There is no wrong way to read this book: if you want to skip ahead, go for it! You might have to jump back to earlier chapters if you experience any confusion. But do whatever works for you.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f89524ca0c10b9d4f1257c768a5b98aab1c4ca9b" translate="yes" xml:space="preserve">
          <source>There is one more similarity between enums and structs: just as we&amp;rsquo;re able to define methods on structs using &lt;code&gt;impl&lt;/code&gt;, we&amp;rsquo;re also able to define methods on enums. Here&amp;rsquo;s a method named &lt;code&gt;call&lt;/code&gt; that we could define on our &lt;code&gt;Message&lt;/code&gt; enum:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="602b0e48a3f43914053d4b199337461ae231047f" translate="yes" xml:space="preserve">
          <source>There is usually no need to create a &lt;code&gt;Thread&lt;/code&gt; struct yourself, one should instead use a function like &lt;code&gt;spawn&lt;/code&gt; to create new threads, see the docs of &lt;a href=&quot;struct.builder&quot;&gt;&lt;code&gt;Builder&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;fn.spawn&quot;&gt;&lt;code&gt;spawn&lt;/code&gt;&lt;/a&gt; for more details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f5aa017ba54ffa17080a39771f2c83f220593384" translate="yes" xml:space="preserve">
          <source>There will be an error about &lt;code&gt;bool&lt;/code&gt; not implementing &lt;code&gt;Index&amp;lt;u8&amp;gt;&lt;/code&gt;, followed by a note saying &quot;the type &lt;code&gt;bool&lt;/code&gt; cannot be indexed by &lt;code&gt;u8&lt;/code&gt;&quot;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7649fb68743c30fa670731965f40aa4090d73b82" translate="yes" xml:space="preserve">
          <source>There&amp;rsquo;s a lot more to say about &lt;a href=&quot;http://doc.crates.io&quot;&gt;Cargo&lt;/a&gt; and &lt;a href=&quot;http://doc.crates.io/crates-io.html&quot;&gt;its ecosystem&lt;/a&gt; which we&amp;rsquo;ll discuss in Chapter 14, but for now, that&amp;rsquo;s all you need to know. Cargo makes it very easy to reuse libraries, so Rustaceans are able to write smaller projects that are assembled from a number of packages.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2bf65550ac389c6cc7469a24526e0ae8bf661af9" translate="yes" xml:space="preserve">
          <source>There&amp;rsquo;s a tendency among many Rustaceans to avoid using &lt;code&gt;clone&lt;/code&gt; to fix ownership problems because of its runtime cost. In &lt;a href=&quot;ch13-00-functional-features&quot;&gt;Chapter 13&lt;/a&gt;, you&amp;rsquo;ll learn how to use more efficient methods in this type of situation. But for now, it&amp;rsquo;s okay to copy a few strings to continue making progress because you&amp;rsquo;ll make these copies only once and your filename and query string are very small. It&amp;rsquo;s better to have a working program that&amp;rsquo;s a bit inefficient than to try to hyperoptimize code on your first pass. As you become more experienced with Rust, it&amp;rsquo;ll be easier to start with the most efficient solution, but for now, it&amp;rsquo;s perfectly acceptable to call &lt;code&gt;clone&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="66fb5ab158cd4be714eaa0eeb00d2ccbb6eb7bd5" translate="yes" xml:space="preserve">
          <source>There&amp;rsquo;s another advantage to using an enum rather than a struct: each variant can have different types and amounts of associated data. Version four type IP addresses will always have four numeric components that will have values between 0 and 255. If we wanted to store &lt;code&gt;V4&lt;/code&gt; addresses as four &lt;code&gt;u8&lt;/code&gt; values but still express &lt;code&gt;V6&lt;/code&gt; addresses as one &lt;code&gt;String&lt;/code&gt; value, we wouldn&amp;rsquo;t be able to with a struct. Enums handle this case with ease:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a401bf0a884425f212fc0c2849df8bdacf839a70" translate="yes" xml:space="preserve">
          <source>There&amp;rsquo;s another solution to the problem of bringing two types of the same name into the same scope with &lt;code&gt;use&lt;/code&gt;: after the path, we can specify &lt;code&gt;as&lt;/code&gt; and a new local name, or alias, for the type. Listing 7-16 shows another way to write the code in Listing 7-15 by renaming one of the two &lt;code&gt;Result&lt;/code&gt; types using &lt;code&gt;as&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="04733e00c121b49528c905aab2fa6e90d06dc6c3" translate="yes" xml:space="preserve">
          <source>There&amp;rsquo;s another wrinkle we haven&amp;rsquo;t talked about yet. This code using integers, part of which was shown in Listing 4-2, works and is valid:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6058c5e16c87f1a91c60dc38f9f510ce010e9805" translate="yes" xml:space="preserve">
          <source>There&amp;rsquo;s debate within the testing community about whether or not private functions should be tested directly, and other languages make it difficult or impossible to test private functions. Regardless of which testing ideology you adhere to, Rust&amp;rsquo;s privacy rules do allow you to test private functions. Consider the code in Listing 11-12 with the private function &lt;code&gt;internal_adder&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="908f1205edb5e08b15769591fe9ecf304d371a0b" translate="yes" xml:space="preserve">
          <source>There&amp;rsquo;s no mechanism being used to synchronize access to the data.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8e1fa626ffc94c26aaee1b60bc06a3539eef3bfd" translate="yes" xml:space="preserve">
          <source>There&amp;rsquo;s no reason to separate these methods into multiple &lt;code&gt;impl&lt;/code&gt; blocks here, but this is valid syntax. We&amp;rsquo;ll see a case in which multiple &lt;code&gt;impl&lt;/code&gt; blocks are useful in Chapter 10, where we discuss generic types and traits.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="68d4631903746cfba7c6e6864ab36c77a56f918c" translate="yes" xml:space="preserve">
          <source>There&amp;rsquo;s no strong reason behind this idiom: it&amp;rsquo;s just the convention that has emerged, and folks have gotten used to reading and writing Rust code this way.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c6cc13f913f5af22a31d9a866ef0ab4e915bc64e" translate="yes" xml:space="preserve">
          <source>There&amp;rsquo;s not a good way to encode this information in the types you use.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="42ede15289d883de11e0a80cc68d82337478321c" translate="yes" xml:space="preserve">
          <source>There&amp;rsquo;s one more catch with this release model: unstable features. Rust uses a technique called &amp;ldquo;feature flags&amp;rdquo; to determine what features are enabled in a given release. If a new feature is under active development, it lands on &lt;code&gt;master&lt;/code&gt;, and therefore, in nightly, but behind a &lt;em&gt;feature flag&lt;/em&gt;. If you, as a user, wish to try out the work-in-progress feature, you can, but you must be using a nightly release of Rust and annotate your source code with the appropriate flag to opt in.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="daaeaab720a0d66e562ebf5f2bea02ac0a5abbb2" translate="yes" xml:space="preserve">
          <source>There&amp;rsquo;s one more situation involving &lt;code&gt;pub&lt;/code&gt; that we haven&amp;rsquo;t covered, and that is our last module system feature: the &lt;code&gt;use&lt;/code&gt; keyword. We&amp;rsquo;ll cover &lt;code&gt;use&lt;/code&gt; by itself first, and then we&amp;rsquo;ll show how to combine &lt;code&gt;pub&lt;/code&gt; and &lt;code&gt;use&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5e8c77371d51b56070c8afcedaaaf9336a342d93" translate="yes" xml:space="preserve">
          <source>There&amp;rsquo;s one other aspect of &lt;code&gt;match&lt;/code&gt; we need to discuss. Consider this version of our &lt;code&gt;plus_one&lt;/code&gt; function that has a bug and won&amp;rsquo;t compile:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3cab02a3373b42bd604f431d95c5d649fedd71e0" translate="yes" xml:space="preserve">
          <source>There's a trait in the standard library for converting something into an iterator: &lt;a href=&quot;trait.intoiterator&quot;&gt;&lt;code&gt;IntoIterator&lt;/code&gt;&lt;/a&gt;. This trait has one method, &lt;a href=&quot;trait.intoiterator#tymethod.into_iter&quot;&gt;&lt;code&gt;into_iter&lt;/code&gt;&lt;/a&gt;, which converts the thing implementing &lt;a href=&quot;trait.intoiterator&quot;&gt;&lt;code&gt;IntoIterator&lt;/code&gt;&lt;/a&gt; into an iterator. Let's take a look at that &lt;code&gt;for&lt;/code&gt; loop again, and what the compiler converts it into:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="126dd99b7c8920c551aa5435d3f5f50326fcb2aa" translate="yes" xml:space="preserve">
          <source>There's no easy fix for this, generally code will need to be refactored so that you no longer need to derive from &lt;code&gt;Super&amp;lt;Self&amp;gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="488dc2b946582ce5502bb699e0ad78fcce8b394c" translate="yes" xml:space="preserve">
          <source>There's one more subtle bit here: the standard library contains an interesting implementation of &lt;a href=&quot;trait.intoiterator&quot;&gt;&lt;code&gt;IntoIterator&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="943a55d68bc8d1a8af15546966743386da3f91a8" translate="yes" xml:space="preserve">
          <source>Therefore, Rust&amp;rsquo;s type system and trait bounds ensure that you can never accidentally send an &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; value across threads unsafely. When we tried to do this in Listing 16-14, we got the error &lt;code&gt;the trait Send is not implemented for Rc&amp;lt;Mutex&amp;lt;i32&amp;gt;&amp;gt;&lt;/code&gt;. When we switched to &lt;code&gt;Arc&amp;lt;T&amp;gt;&lt;/code&gt;, which is &lt;code&gt;Send&lt;/code&gt;, the code compiled.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a965d0af2f94e5f3318be18d630d6ce398f8ad8c" translate="yes" xml:space="preserve">
          <source>Therefore, pinning also comes with a &lt;code&gt;drop&lt;/code&gt;-related guarantee.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f3da5db36b6a5c8b63c646979b9f9638e2ffed72" translate="yes" xml:space="preserve">
          <source>These abstractions can be built out of lower-level primitives. For efficiency, the sync objects in the standard library are usually implemented with help from the operating system's kernel, which is able to reschedule the threads while they are blocked on acquiring a lock.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0b4543381c3d34027ca13b9d929f743b5e4c9c39" translate="yes" xml:space="preserve">
          <source>These also point to memory owned by some other value. A mutable reference type is written &lt;code&gt;&amp;amp;mut type&lt;/code&gt; or &lt;code&gt;&amp;amp;'a mut type&lt;/code&gt;. A mutable reference (that hasn't been borrowed) is the only way to access the value it points to, so is not &lt;code&gt;Copy&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1edbd620f4ea3fb93fdd0d7dd71adad12120dfa7" translate="yes" xml:space="preserve">
          <source>These ampersands are &lt;em&gt;references&lt;/em&gt;, and they allow you to refer to some value without taking ownership of it. Figure 4-5 shows a diagram.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3f42eae85e77f8aae9c5335f688c216fd7101df0" translate="yes" xml:space="preserve">
          <source>These are fairly high-level and quick break-downs of when each collection should be considered. Detailed discussions of strengths and weaknesses of individual collections can be found on their own documentation pages.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="69b2114a065741874c57309ba27c70784c7ddedd" translate="yes" xml:space="preserve">
          <source>These are the last two unary operators. This table summarizes the behavior of them on primitive types and which traits are used to overload these operators for other types. Remember that signed integers are always represented using two's complement. The operands of all of these operators are evaluated in &lt;a href=&quot;../expressions#place-expressions-and-value-expressions&quot;&gt;value expression context&lt;/a&gt; so are moved or copied.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b6db5a380dbbbf8a2cd7b3c9d1a9637a5d119ab4" translate="yes" xml:space="preserve">
          <source>These attributes do not work on typedefs, since typedefs are just aliases.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="45e9c8e478d7d23050c1bb7760888996d75acd57" translate="yes" xml:space="preserve">
          <source>These axioms, along with careful use of &lt;a href=&quot;../primitive.pointer#method.offset&quot;&gt;&lt;code&gt;offset&lt;/code&gt;&lt;/a&gt; for pointer arithmetic, are enough to correctly implement many useful things in unsafe code. Stronger guarantees will be provided eventually, as the &lt;a href=&quot;https://doc.rust-lang.org/nomicon/aliasing.html&quot;&gt;aliasing&lt;/a&gt; rules are being determined. For more information, see the &lt;a href=&quot;../../book/ch19-01-unsafe-rust#dereferencing-a-raw-pointer&quot;&gt;book&lt;/a&gt; as well as the section in the reference devoted to &lt;a href=&quot;../../reference/behavior-considered-undefined&quot;&gt;undefined behavior&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7913b3c72a22fc6b243e0539a47297d89428aedf" translate="yes" xml:space="preserve">
          <source>These can all be interpreted as flags for a particular formatter.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0e39a0bd16ba8ecfd732cbb117c3248fda60a735" translate="yes" xml:space="preserve">
          <source>These can be fixed by declaring lifetime parameters:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d454f3116d0aed2fb7a537cae1b229f52b361113" translate="yes" xml:space="preserve">
          <source>These channels come in two flavors:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c31b94922e5b65f02fef2f529b0b7e4859486143" translate="yes" xml:space="preserve">
          <source>These components describe the shape of the data we&amp;rsquo;re working with, which we then match against values to determine whether our program has the correct data to continue running a particular piece of code.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="01d073371ba3433dace28c44e03a57f2a2d8dbcd" translate="yes" xml:space="preserve">
          <source>These default object lifetime bounds are used instead of the lifetime parameter elision rules defined above when the lifetime bound is omitted entirely. If &lt;code&gt;'_&lt;/code&gt; is used as the lifetime bound then the bound follows the usual elision rules.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3cb556ed4e688a43a755806e0180a1ae20f4245d" translate="yes" xml:space="preserve">
          <source>These enumerations can be cast to integer types with the &lt;code&gt;as&lt;/code&gt; operator by a &lt;a href=&quot;../expressions/operator-expr#semantics&quot;&gt;numeric cast&lt;/a&gt;. The enumeration can optionally specify which integer each discriminant gets by following the variant name with &lt;code&gt;=&lt;/code&gt; followed by a &lt;a href=&quot;../const_eval#constant-expressions&quot;&gt;constant expression&lt;/a&gt;. If the first variant in the declaration is unspecified, then it is set to zero. For every other unspecified discriminant, it is set to one higher than the previous variant in the declaration.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="56f44a74054755cd230d668bfd5dc0a8f5aa2ac0" translate="yes" xml:space="preserve">
          <source>These keywords aren't used yet, but they are reserved for future use. They have the same restrictions as strict keywords. The reasoning behind this is to make current programs forward compatible with future versions of Rust by forbidding them to use these keywords.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f2eab53396d35c8dd4df2e3ab58dfee415a7015e" translate="yes" xml:space="preserve">
          <source>These keywords can only be used in their correct contexts. They cannot be used as the names of:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aec421e6db4795c07bbf5e8ae6411e119af0b089" translate="yes" xml:space="preserve">
          <source>These keywords have special meaning only in certain contexts. For example, it is possible to declare a variable or method with the name &lt;code&gt;union&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="24355b40ed9274fe2bce5ed7512a65c55ffdfb11" translate="yes" xml:space="preserve">
          <source>These lines define a function in Rust. The &lt;code&gt;main&lt;/code&gt; function is special: it is always the first code that runs in every executable Rust program. The first line declares a function named &lt;code&gt;main&lt;/code&gt; that has no parameters and returns nothing. If there were parameters, they would go inside the parentheses, &lt;code&gt;()&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="78ee21b3b578a8828b900a4d7bb5e92af7fdfb9f" translate="yes" xml:space="preserve">
          <source>These lines show Cargo only updates the build with your tiny change to the &lt;em&gt;src/main.rs&lt;/em&gt; file. Your dependencies haven&amp;rsquo;t changed, so Cargo knows it can reuse what it has already downloaded and compiled for those. It just rebuilds your part of the code.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c77584f3dda90ac8527f5ef32d9ad1f6daeca4c8" translate="yes" xml:space="preserve">
          <source>These macros are defined by a &lt;a href=&quot;visibility-and-privacy&quot;&gt;public&lt;/a&gt;&lt;a href=&quot;items/functions&quot;&gt;function&lt;/a&gt; with the &lt;code&gt;proc_macro&lt;/code&gt;&lt;a href=&quot;attributes&quot;&gt;attribute&lt;/a&gt; and a signature of &lt;code&gt;(TokenStream) -&amp;gt; TokenStream&lt;/code&gt;. The input &lt;a href=&quot;https://doc.rust-lang.org/proc_macro/struct.TokenStream.html&quot;&gt;&lt;code&gt;TokenStream&lt;/code&gt;&lt;/a&gt; is what is inside the delimiters of the macro invocation and the output &lt;a href=&quot;https://doc.rust-lang.org/proc_macro/struct.TokenStream.html&quot;&gt;&lt;code&gt;TokenStream&lt;/code&gt;&lt;/a&gt; replaces the entire macro invocation. It may contain an arbitrary number of &lt;a href=&quot;items&quot;&gt;items&lt;/a&gt;. These macros cannot expand to syntax that defines new &lt;code&gt;macro_rules&lt;/code&gt; style macros.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="254739acb173823a2863a1c41d3ebb09cfa13aeb" translate="yes" xml:space="preserve">
          <source>These macros are only invokable in &lt;a href=&quot;items/modules&quot;&gt;modules&lt;/a&gt;. They cannot even be invoked to create &lt;a href=&quot;statements#item-declarations&quot;&gt;item declaration statements&lt;/a&gt;. Furthermore, they must either be invoked with curly braces and no semicolon or a different delimiter followed by a semicolon. For example, &lt;code&gt;make_answer&lt;/code&gt; from the previous example can be invoked as &lt;code&gt;make_answer!{}&lt;/code&gt;, &lt;code&gt;make_answer!();&lt;/code&gt; or &lt;code&gt;make_answer![];&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5391198458bfd8d81a447bc30f66734e6f03394d" translate="yes" xml:space="preserve">
          <source>These markers can be combined, so &lt;code&gt;unsafe extern &quot;stdcall&quot; fn()&lt;/code&gt; is a valid type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8c3ea3ec32e230deeef1943701b442105e65b661" translate="yes" xml:space="preserve">
          <source>These operators cannot be overloaded.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3fc236a778b843e2aeed416fa4b2cc9e1a08823c" translate="yes" xml:space="preserve">
          <source>These point to memory &lt;em&gt;owned by some other value&lt;/em&gt;. When a shared reference to a value is created it prevents direct mutation of the value. &lt;a href=&quot;../interior-mutability&quot;&gt;Interior mutability&lt;/a&gt; provides an exception for this in certain circumstances. As the name suggests, any number of shared references to a value may exist. A shared reference type is written &lt;code&gt;&amp;amp;type&lt;/code&gt;, or &lt;code&gt;&amp;amp;'a type&lt;/code&gt; when you need to specify an explicit lifetime. Copying a reference is a &quot;shallow&quot; operation: it involves only copying the pointer itself, that is, pointers are &lt;code&gt;Copy&lt;/code&gt;. Releasing a reference has no effect on the value it points to, but referencing of a &lt;a href=&quot;../expressions#temporary-lifetimes&quot;&gt;temporary value&lt;/a&gt; will keep it alive during the scope of the reference itself.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e5e8141a80455494c8061b88eb7d52c5630351cf" translate="yes" xml:space="preserve">
          <source>These profile names might be familiar from the output of your builds:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1ad28c50cb4ab16e536724b4f61aca4d7477f454" translate="yes" xml:space="preserve">
          <source>These safety checks can be relaxed for a section of the code by wrapping the unsafe instructions with an &lt;code&gt;unsafe&lt;/code&gt; block. For instance:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7c9be14b653ccb0fc4412a262bd32a7bb0662862" translate="yes" xml:space="preserve">
          <source>These traits, along with &lt;a href=&quot;../../../ffi/struct.osstring&quot;&gt;&lt;code&gt;OsString&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../../../ffi/struct.osstr&quot;&gt;&lt;code&gt;OsStr&lt;/code&gt;&lt;/a&gt;, work in conjunction so that it is possible to &lt;strong&gt;round-trip&lt;/strong&gt; strings from Windows and back, with no loss of data, even if the strings are ill-formed UTF-16.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0cc726c49519e90aab3de25bfe65c626d294217a" translate="yes" xml:space="preserve">
          <source>These two cases are surprisingly powerful for creating module hierarchies exposing public APIs while hiding internal implementation details. To help explain, here's a few use cases and what they would entail:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8ac19292e9dd15d2d45f1f79b996a19bf6206f30" translate="yes" xml:space="preserve">
          <source>These two examples illustrate the problem:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dca9d4b1de7c5a2be4c4d5727e7917fd8aab654c" translate="yes" xml:space="preserve">
          <source>These two formatting traits have distinct purposes:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6f982f08c4e46524b8318daa35d1f6508b56f9c5" translate="yes" xml:space="preserve">
          <source>These two terms are often used interchangeably, and what they are attempting to convey is the answer to the question &quot;Can this item be used at this location?&quot;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="327e657798ef3a0fe98594c42be8998daff24b69" translate="yes" xml:space="preserve">
          <source>These types provide access to the underlying data through references to the type of that data. They are said to be &amp;lsquo;borrowed as&amp;rsquo; that type. For instance, a &lt;a href=&quot;../boxed/struct.box&quot;&gt;&lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt; can be borrowed as &lt;code&gt;T&lt;/code&gt; while a &lt;a href=&quot;../string/struct.string&quot;&gt;&lt;code&gt;String&lt;/code&gt;&lt;/a&gt; can be borrowed as &lt;code&gt;str&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a24b18110788da060d08a87d6e0370b2f3f11b2d" translate="yes" xml:space="preserve">
          <source>These will always be ORed with &lt;code&gt;CREATE_UNICODE_ENVIRONMENT&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4d9283345c9b012905e98bac4c4ff6bf77874d49" translate="yes" xml:space="preserve">
          <source>They are &lt;code&gt;'static&lt;/code&gt; because they're stored directly in the final binary, and so will be valid for the &lt;code&gt;'static&lt;/code&gt; duration.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="86b3fa967e9ddc952d15703cad09add6ed0fe12c" translate="yes" xml:space="preserve">
          <source>They are never allowed before:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a91c6bc4d714ec79e34b3b499dac181a1c8a5b61" translate="yes" xml:space="preserve">
          <source>They are written as &lt;code&gt;impl&lt;/code&gt; followed by a set of trait bounds.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d6f10b3f0570fbded7ab662d2bff2e38078266a6" translate="yes" xml:space="preserve">
          <source>They can be used as targets of transmutes in unsafe code for manipulating the raw representations directly.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3eb09871747750e3ee06b75fa9a63f7cfbbd1d29" translate="yes" xml:space="preserve">
          <source>Thin pointers are &quot;simple&quot; pointers: they are purely a reference to a memory address.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4d4a58caf1c3fd49804715c525d371aaf6cc87c9" translate="yes" xml:space="preserve">
          <source>Things can get a little tricky once you start intermingling the two types of positional specifiers. The &quot;next argument&quot; specifier can be thought of as an iterator over the argument. Each time a &quot;next argument&quot; specifier is seen, the iterator advances. This leads to behavior like this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9af9ddcb5af382b3006b61fbf3f41b42b2b57797" translate="yes" xml:space="preserve">
          <source>Think of a &lt;code&gt;match&lt;/code&gt; expression as being like a coin-sorting machine: coins slide down a track with variously sized holes along it, and each coin falls through the first hole it encounters that it fits into. In the same way, values go through each pattern in a &lt;code&gt;match&lt;/code&gt;, and at the first pattern the value &amp;ldquo;fits,&amp;rdquo; the value falls into the associated code block to be used during execution.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1fdd8b4a97ce68f59e33b3f6b509748be1aa6f2f" translate="yes" xml:space="preserve">
          <source>Think of being seated at a restaurant. When you enter, you state the number of people in your group, and the staff finds an empty table that fits everyone and leads you there. If someone in your group comes late, they can ask where you&amp;rsquo;ve been seated to find you.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0748eff7f6f3425a675a552a35d84af9fe1be56c" translate="yes" xml:space="preserve">
          <source>Thinking about the relationships another way, a parent node should own its children: if a parent node is dropped, its child nodes should be dropped as well. However, a child should not own its parent: if we drop a child node, the parent should still exist. This is a case for weak references!</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="399cffdf26999603bae93a3715241addff90c419" translate="yes" xml:space="preserve">
          <source>Thinking in Terms of Lifetimes</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7407b5aadd0d88118f5b7bf8fb59e7e1d6d93882" translate="yes" xml:space="preserve">
          <source>Third, the &lt;code&gt;run&lt;/code&gt; function now returns an &lt;code&gt;Ok&lt;/code&gt; value in the success case. We&amp;rsquo;ve declared the &lt;code&gt;run&lt;/code&gt; function&amp;rsquo;s success type as &lt;code&gt;()&lt;/code&gt; in the signature, which means we need to wrap the unit type value in the &lt;code&gt;Ok&lt;/code&gt; value. This &lt;code&gt;Ok(())&lt;/code&gt; syntax might look a bit strange at first, but using &lt;code&gt;()&lt;/code&gt; like this is the idiomatic way to indicate that we&amp;rsquo;re calling &lt;code&gt;run&lt;/code&gt; for its side effects only; it doesn&amp;rsquo;t return a value we need.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5ed975d1877254eff4f647cec29b338bbca64ef4" translate="yes" xml:space="preserve">
          <source>Third, the standard library defines &lt;a href=&quot;prelude/index&quot;&gt;The Rust Prelude&lt;/a&gt;, a small collection of items - mostly traits - that are imported into every module of every crate. The traits in the prelude are pervasive, making the prelude documentation a good entry point to learning about the library.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2c016402b0d7abec88d04b55dd5a8f4c018ceb4a" translate="yes" xml:space="preserve">
          <source>Third, you see the &lt;code&gt;&quot;Hello, world!&quot;&lt;/code&gt; string. We pass this string as an argument to &lt;code&gt;println!&lt;/code&gt;, and the string is printed to the screen.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="756c69ab3ae5844d50aa9add76723030b90c2e84" translate="yes" xml:space="preserve">
          <source>This &lt;a href=&quot;../io/type.result&quot;&gt;&lt;code&gt;io::Result&lt;/code&gt;&lt;/a&gt; will be an &lt;a href=&quot;../result/enum.result#variant.Err&quot;&gt;&lt;code&gt;Err&lt;/code&gt;&lt;/a&gt; if there's some sort of intermittent IO error during iteration.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="45e5b6731a2eea68db70299dc76799ac1e3d8403" translate="yes" xml:space="preserve">
          <source>This &lt;a href=&quot;fn.sync_channel&quot;&gt;&lt;code&gt;sync_channel&lt;/code&gt;&lt;/a&gt;'s receiving half has disconnected, so the data could not be sent. The data is returned back to the callee in this case.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e029dc532e12308a313b095f5b88bb0b2db85884" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;#[route]&lt;/code&gt; attribute would be defined by the framework as a procedural macro. The signature of the macro definition function would look like this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dc8fa4acf3fa662b100c7f01811572d66ca46b05" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;Message&lt;/code&gt; enum will either be a &lt;code&gt;NewJob&lt;/code&gt; variant that holds the &lt;code&gt;Job&lt;/code&gt; the thread should run, or it will be a &lt;code&gt;Terminate&lt;/code&gt; variant that will cause the thread to exit its loop and stop.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="df201a49abc9a95b4b9db82dff3855ec3856b74c" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;enum&lt;/code&gt; is constructed from the &lt;a href=&quot;struct.btreemap#method.entry&quot;&gt;&lt;code&gt;entry&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;struct.btreemap&quot;&gt;&lt;code&gt;BTreeMap&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="78b77c0bae34af9fbe0dd6db2b8a03354e7c6a07" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;enum&lt;/code&gt; is constructed from the &lt;a href=&quot;struct.hashmap#method.entry&quot;&gt;&lt;code&gt;entry&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;struct.hashmap&quot;&gt;&lt;code&gt;HashMap&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e49b2cde36d96ef41241461160aaa7f39ffe4733" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;enum&lt;/code&gt; is constructed through the &lt;a href=&quot;struct.hashmap#method.raw_entry_mut&quot;&gt;&lt;code&gt;raw_entry_mut&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;struct.hashmap&quot;&gt;&lt;code&gt;HashMap&lt;/code&gt;&lt;/a&gt;, then calling one of the methods of that &lt;a href=&quot;struct.rawentrybuildermut&quot;&gt;&lt;code&gt;RawEntryBuilderMut&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="484cddb60aced3f0fd2c66d36c2d02b11434898c" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;enum&lt;/code&gt; is created by iterating over &lt;a href=&quot;struct.components&quot;&gt;&lt;code&gt;Components&lt;/code&gt;&lt;/a&gt;, which in turn is created by the &lt;a href=&quot;struct.path#method.components&quot;&gt;&lt;code&gt;components&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;struct.path&quot;&gt;&lt;code&gt;Path&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="94a9ddcdadd6c80893c9aa067a5c5342d16c5ca8" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;enum&lt;/code&gt; is slightly awkward: it will never actually exist. This error is part of the type signature of the implementation of &lt;a href=&quot;../str/trait.fromstr&quot;&gt;&lt;code&gt;FromStr&lt;/code&gt;&lt;/a&gt; on &lt;a href=&quot;struct.string&quot;&gt;&lt;code&gt;String&lt;/code&gt;&lt;/a&gt;. The return type of &lt;a href=&quot;../str/trait.fromstr#tymethod.from_str&quot;&gt;&lt;code&gt;from_str&lt;/code&gt;&lt;/a&gt;, requires that an error be defined, but, given that a &lt;a href=&quot;struct.string&quot;&gt;&lt;code&gt;String&lt;/code&gt;&lt;/a&gt; can always be made into a new &lt;a href=&quot;struct.string&quot;&gt;&lt;code&gt;String&lt;/code&gt;&lt;/a&gt; without error, this type will never actually be returned. As such, it is only here to satisfy said signature, and is useless otherwise.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7bafcd26f5f930140b3a1e3e5a967a8f857b2aca" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;enum&lt;/code&gt; is used as the return type for &lt;a href=&quot;../primitive.f32#method.classify&quot;&gt;&lt;code&gt;f32::classify&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../primitive.f64#method.classify&quot;&gt;&lt;code&gt;f64::classify&lt;/code&gt;&lt;/a&gt;. See their documentation for more.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="779a09142baa1b4c0c25a858cbd603a82e00fb14" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;new&lt;/code&gt; function creates a new, empty string. You&amp;rsquo;ll find a &lt;code&gt;new&lt;/code&gt; function on many types, because it&amp;rsquo;s a common name for a function that makes a new value of some kind.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="04527249225c0957b4a2dad0cb713b606320b989" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;struct&lt;/code&gt; is created by the &lt;a href=&quot;../primitive.char#method.escape_debug&quot;&gt;&lt;code&gt;escape_debug&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;../primitive.char&quot;&gt;&lt;code&gt;char&lt;/code&gt;&lt;/a&gt;. See its documentation for more.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="db12edeeb870acc98aa06b33b39a8bb3d306d517" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;struct&lt;/code&gt; is created by the &lt;a href=&quot;../primitive.char#method.escape_default&quot;&gt;&lt;code&gt;escape_default&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;../primitive.char&quot;&gt;&lt;code&gt;char&lt;/code&gt;&lt;/a&gt;. See its documentation for more.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cc81870e647a4c66d45285572c3d1fa6c0473baa" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;struct&lt;/code&gt; is created by the &lt;a href=&quot;../primitive.char#method.escape_unicode&quot;&gt;&lt;code&gt;escape_unicode&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;../primitive.char&quot;&gt;&lt;code&gt;char&lt;/code&gt;&lt;/a&gt;. See its documentation for more.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1fe84815a63364d86bf9311c9ac78e8bdb20701b" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;struct&lt;/code&gt; is created by the &lt;a href=&quot;../primitive.char#method.to_lowercase&quot;&gt;&lt;code&gt;to_lowercase&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;../primitive.char&quot;&gt;&lt;code&gt;char&lt;/code&gt;&lt;/a&gt;. See its documentation for more.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="27eb64d64fc617e07c6f09849f8a1efd113c9e7c" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;struct&lt;/code&gt; is created by the &lt;a href=&quot;../primitive.char#method.to_uppercase&quot;&gt;&lt;code&gt;to_uppercase&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;../primitive.char&quot;&gt;&lt;code&gt;char&lt;/code&gt;&lt;/a&gt;. See its documentation for more.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="df020e51f3f4500bc1f8be7714b7e55fb7923be6" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;struct&lt;/code&gt; is created by the &lt;a href=&quot;enum.option#method.into_iter&quot;&gt;&lt;code&gt;Option::into_iter&lt;/code&gt;&lt;/a&gt; function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ed85839c71b9b41d697c086ba092e08ee354cb7a" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;struct&lt;/code&gt; is created by the &lt;a href=&quot;enum.option#method.iter&quot;&gt;&lt;code&gt;Option::iter&lt;/code&gt;&lt;/a&gt; function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f832fbc0a1897989e972bccbdf14ab8c06df2a8b" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;struct&lt;/code&gt; is created by the &lt;a href=&quot;enum.option#method.iter_mut&quot;&gt;&lt;code&gt;Option::iter_mut&lt;/code&gt;&lt;/a&gt; function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f3c09e42d5e7d0d1aee87da5c6a31ae546137c1a" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;struct&lt;/code&gt; is created by the &lt;a href=&quot;fn.empty&quot;&gt;&lt;code&gt;empty&lt;/code&gt;&lt;/a&gt; function. See its documentation for more.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="583b1959fdeeb9dda8ffebe215f3e85158c8bc2e" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;struct&lt;/code&gt; is created by the &lt;a href=&quot;fn.escape_default&quot;&gt;&lt;code&gt;escape_default&lt;/code&gt;&lt;/a&gt; function. See its documentation for more.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="be7c13071482b2c3923f2e736bd014b0019bfa3c" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;struct&lt;/code&gt; is created by the &lt;a href=&quot;fn.from_fn&quot;&gt;&lt;code&gt;iter::from_fn&lt;/code&gt;&lt;/a&gt; function. See its documentation for more.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b2d0d0c848c068f0195f43a41a604e9ed15435ea" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;struct&lt;/code&gt; is created by the &lt;a href=&quot;fn.once&quot;&gt;&lt;code&gt;once&lt;/code&gt;&lt;/a&gt; function. See its documentation for more.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="582110272ac53674cd7341259d0b80e92c531007" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;struct&lt;/code&gt; is created by the &lt;a href=&quot;fn.once_with&quot;&gt;&lt;code&gt;once_with&lt;/code&gt;&lt;/a&gt; function. See its documentation for more.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f750c0f224dd89d4b261959a2e6c2e0e53f46764" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;struct&lt;/code&gt; is created by the &lt;a href=&quot;fn.repeat&quot;&gt;&lt;code&gt;repeat&lt;/code&gt;&lt;/a&gt; function. See its documentation for more.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="937c3c66fd7a919cfaca746517ec0915d37c92b5" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;struct&lt;/code&gt; is created by the &lt;a href=&quot;fn.repeat_with&quot;&gt;&lt;code&gt;repeat_with&lt;/code&gt;&lt;/a&gt; function. See its documentation for more.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aab81d3f94443c5e362d592846bb5f615688f696" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;struct&lt;/code&gt; is created by the &lt;a href=&quot;fn.spawn&quot;&gt;&lt;code&gt;thread::spawn&lt;/code&gt;&lt;/a&gt; function and the &lt;a href=&quot;struct.builder#method.spawn&quot;&gt;&lt;code&gt;thread::Builder::spawn&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2bba3b7b1d3ddee116465f88074412d173b46ad3" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;struct&lt;/code&gt; is created by the &lt;a href=&quot;fn.successors&quot;&gt;&lt;code&gt;successors&lt;/code&gt;&lt;/a&gt; function. See its documentation for more.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="750025df63cee4f9476b600e410c271d4dc26282" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;struct&lt;/code&gt; is created by the &lt;a href=&quot;struct.binaryheap#method.drain&quot;&gt;&lt;code&gt;drain&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;struct.binaryheap&quot;&gt;&lt;code&gt;BinaryHeap&lt;/code&gt;&lt;/a&gt;. See its documentation for more.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e18a9e9bb705ac20d27c1b54b01a06909af9f5aa" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;struct&lt;/code&gt; is created by the &lt;a href=&quot;struct.binaryheap#method.into_iter&quot;&gt;&lt;code&gt;into_iter&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;struct.binaryheap&quot;&gt;&lt;code&gt;BinaryHeap&lt;/code&gt;&lt;/a&gt; (provided by the &lt;code&gt;IntoIterator&lt;/code&gt; trait). See its documentation for more.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="41506355b29f22e9b8811a8d2b60d92fed5ea6d5" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;struct&lt;/code&gt; is created by the &lt;a href=&quot;struct.binaryheap#method.iter&quot;&gt;&lt;code&gt;iter&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;struct.binaryheap&quot;&gt;&lt;code&gt;BinaryHeap&lt;/code&gt;&lt;/a&gt;. See its documentation for more.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e9675a6cb1b893dbb78e5cb9089bf79a6f234027" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;struct&lt;/code&gt; is created by the &lt;a href=&quot;struct.binaryheap#method.peek_mut&quot;&gt;&lt;code&gt;peek_mut&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;struct.binaryheap&quot;&gt;&lt;code&gt;BinaryHeap&lt;/code&gt;&lt;/a&gt;. See its documentation for more.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a3e0e69a8fe926bff3713eb4f60caf8069defb24" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;struct&lt;/code&gt; is created by the &lt;a href=&quot;struct.btreemap#method.into_iter&quot;&gt;&lt;code&gt;into_iter&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;struct.btreemap&quot;&gt;&lt;code&gt;BTreeMap&lt;/code&gt;&lt;/a&gt; (provided by the &lt;code&gt;IntoIterator&lt;/code&gt; trait). See its documentation for more.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="514e5b56a0002147cc9f7ac8a43433a6a65225d9" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;struct&lt;/code&gt; is created by the &lt;a href=&quot;struct.btreemap#method.iter&quot;&gt;&lt;code&gt;iter&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;struct.btreemap&quot;&gt;&lt;code&gt;BTreeMap&lt;/code&gt;&lt;/a&gt;. See its documentation for more.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f716d42a3e459fcee9b6f36db5dc5c8168d480b5" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;struct&lt;/code&gt; is created by the &lt;a href=&quot;struct.btreemap#method.iter_mut&quot;&gt;&lt;code&gt;iter_mut&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;struct.btreemap&quot;&gt;&lt;code&gt;BTreeMap&lt;/code&gt;&lt;/a&gt;. See its documentation for more.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1f4535b44687ead67d4ff87d0edaec473f93f580" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;struct&lt;/code&gt; is created by the &lt;a href=&quot;struct.btreemap#method.keys&quot;&gt;&lt;code&gt;keys&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;struct.btreemap&quot;&gt;&lt;code&gt;BTreeMap&lt;/code&gt;&lt;/a&gt;. See its documentation for more.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d31858adce6dfcdec67ca057f391304b96efe373" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;struct&lt;/code&gt; is created by the &lt;a href=&quot;struct.btreemap#method.range&quot;&gt;&lt;code&gt;range&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;struct.btreemap&quot;&gt;&lt;code&gt;BTreeMap&lt;/code&gt;&lt;/a&gt;. See its documentation for more.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="beff4242dfe6af7e412bdc0cbf43b9ab3e974e59" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;struct&lt;/code&gt; is created by the &lt;a href=&quot;struct.btreemap#method.range_mut&quot;&gt;&lt;code&gt;range_mut&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;struct.btreemap&quot;&gt;&lt;code&gt;BTreeMap&lt;/code&gt;&lt;/a&gt;. See its documentation for more.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="61ccad7bbc2caef64224c9df6c46da6d30f71236" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;struct&lt;/code&gt; is created by the &lt;a href=&quot;struct.btreemap#method.values&quot;&gt;&lt;code&gt;values&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;struct.btreemap&quot;&gt;&lt;code&gt;BTreeMap&lt;/code&gt;&lt;/a&gt;. See its documentation for more.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="32f656567e75b1c61207668fdcd4fee681fb158f" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;struct&lt;/code&gt; is created by the &lt;a href=&quot;struct.btreemap#method.values_mut&quot;&gt;&lt;code&gt;values_mut&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;struct.btreemap&quot;&gt;&lt;code&gt;BTreeMap&lt;/code&gt;&lt;/a&gt;. See its documentation for more.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="954c25018729177ec5a7cd425af966f38ad45de9" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;struct&lt;/code&gt; is created by the &lt;a href=&quot;struct.btreeset#method.difference&quot;&gt;&lt;code&gt;difference&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;struct.btreeset&quot;&gt;&lt;code&gt;BTreeSet&lt;/code&gt;&lt;/a&gt;. See its documentation for more.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="311036e0ac34eb0ce755d849d1ee9dcf0da2fa6d" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;struct&lt;/code&gt; is created by the &lt;a href=&quot;struct.btreeset#method.intersection&quot;&gt;&lt;code&gt;intersection&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;struct.btreeset&quot;&gt;&lt;code&gt;BTreeSet&lt;/code&gt;&lt;/a&gt;. See its documentation for more.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cd64d67da228b8471603fbb0b2df44241b404edf" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;struct&lt;/code&gt; is created by the &lt;a href=&quot;struct.btreeset#method.into_iter&quot;&gt;&lt;code&gt;into_iter&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;struct.btreeset&quot;&gt;&lt;code&gt;BTreeSet&lt;/code&gt;&lt;/a&gt; (provided by the &lt;code&gt;IntoIterator&lt;/code&gt; trait). See its documentation for more.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b2d51f3eed3f11c0fe92a56c05aa30ba63101b5b" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;struct&lt;/code&gt; is created by the &lt;a href=&quot;struct.btreeset#method.iter&quot;&gt;&lt;code&gt;iter&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;struct.btreeset&quot;&gt;&lt;code&gt;BTreeSet&lt;/code&gt;&lt;/a&gt;. See its documentation for more.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4952396a08a80db78884e7472ef4fcdc98f30b89" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;struct&lt;/code&gt; is created by the &lt;a href=&quot;struct.btreeset#method.range&quot;&gt;&lt;code&gt;range&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;struct.btreeset&quot;&gt;&lt;code&gt;BTreeSet&lt;/code&gt;&lt;/a&gt;. See its documentation for more.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="03065ec43e94189db8db5b6c22bcd04c4d9e3d5f" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;struct&lt;/code&gt; is created by the &lt;a href=&quot;struct.btreeset#method.symmetric_difference&quot;&gt;&lt;code&gt;symmetric_difference&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;struct.btreeset&quot;&gt;&lt;code&gt;BTreeSet&lt;/code&gt;&lt;/a&gt;. See its documentation for more.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="06c95a89e54823ffe6dff81406fba47c36a4dc6c" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;struct&lt;/code&gt; is created by the &lt;a href=&quot;struct.btreeset#method.union&quot;&gt;&lt;code&gt;union&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;struct.btreeset&quot;&gt;&lt;code&gt;BTreeSet&lt;/code&gt;&lt;/a&gt;. See its documentation for more.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="512853e49000d203253875f2ca8249d15ea7353e" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;struct&lt;/code&gt; is created by the &lt;a href=&quot;struct.cstring#method.into_string&quot;&gt;&lt;code&gt;into_string&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;struct.cstring&quot;&gt;&lt;code&gt;CString&lt;/code&gt;&lt;/a&gt;. See its documentation for more.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="faa8b1395fad10dcbfc423094256b61e6d205866" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;struct&lt;/code&gt; is created by the &lt;a href=&quot;struct.hashmap#method.drain&quot;&gt;&lt;code&gt;drain&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;struct.hashmap&quot;&gt;&lt;code&gt;HashMap&lt;/code&gt;&lt;/a&gt;. See its documentation for more.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0800ef408d255e0937c01c82d43d77be20d45343" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;struct&lt;/code&gt; is created by the &lt;a href=&quot;struct.hashmap#method.into_iter&quot;&gt;&lt;code&gt;into_iter&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;struct.hashmap&quot;&gt;&lt;code&gt;HashMap&lt;/code&gt;&lt;/a&gt; (provided by the &lt;code&gt;IntoIterator&lt;/code&gt; trait). See its documentation for more.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0608e2c033c0bbc3bd28c971540c2b970498e946" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;struct&lt;/code&gt; is created by the &lt;a href=&quot;struct.hashmap#method.iter&quot;&gt;&lt;code&gt;iter&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;struct.hashmap&quot;&gt;&lt;code&gt;HashMap&lt;/code&gt;&lt;/a&gt;. See its documentation for more.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0d3d57080a3c9ea2da73c2cffa1d26e9e4a02705" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;struct&lt;/code&gt; is created by the &lt;a href=&quot;struct.hashmap#method.iter_mut&quot;&gt;&lt;code&gt;iter_mut&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;struct.hashmap&quot;&gt;&lt;code&gt;HashMap&lt;/code&gt;&lt;/a&gt;. See its documentation for more.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="24475378883de5203105dba62856d4abf99e3544" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;struct&lt;/code&gt; is created by the &lt;a href=&quot;struct.hashmap#method.keys&quot;&gt;&lt;code&gt;keys&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;struct.hashmap&quot;&gt;&lt;code&gt;HashMap&lt;/code&gt;&lt;/a&gt;. See its documentation for more.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9d0295f8ffe26eaa9c9d5777a9c742f561e9829a" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;struct&lt;/code&gt; is created by the &lt;a href=&quot;struct.hashmap#method.values&quot;&gt;&lt;code&gt;values&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;struct.hashmap&quot;&gt;&lt;code&gt;HashMap&lt;/code&gt;&lt;/a&gt;. See its documentation for more.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="29c5ae45f57800a030c9d11a0a477ba58c24833e" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;struct&lt;/code&gt; is created by the &lt;a href=&quot;struct.hashmap#method.values_mut&quot;&gt;&lt;code&gt;values_mut&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;struct.hashmap&quot;&gt;&lt;code&gt;HashMap&lt;/code&gt;&lt;/a&gt;. See its documentation for more.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7513d477a389bb5cb5a430e327122b1af796c3fd" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;struct&lt;/code&gt; is created by the &lt;a href=&quot;struct.hashset#method.difference&quot;&gt;&lt;code&gt;difference&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;struct.hashset&quot;&gt;&lt;code&gt;HashSet&lt;/code&gt;&lt;/a&gt;. See its documentation for more.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="86301ec13deb5075922cbd995e23feac257a9d81" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;struct&lt;/code&gt; is created by the &lt;a href=&quot;struct.hashset#method.drain&quot;&gt;&lt;code&gt;drain&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;struct.hashset&quot;&gt;&lt;code&gt;HashSet&lt;/code&gt;&lt;/a&gt;. See its documentation for more.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3ebb8dfa5cf525c05fe6f08d21ee543480482796" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;struct&lt;/code&gt; is created by the &lt;a href=&quot;struct.hashset#method.intersection&quot;&gt;&lt;code&gt;intersection&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;struct.hashset&quot;&gt;&lt;code&gt;HashSet&lt;/code&gt;&lt;/a&gt;. See its documentation for more.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b4fe9a5189ce4199be4828187c5779ad99c77194" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;struct&lt;/code&gt; is created by the &lt;a href=&quot;struct.hashset#method.into_iter&quot;&gt;&lt;code&gt;into_iter&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;struct.hashset&quot;&gt;&lt;code&gt;HashSet&lt;/code&gt;&lt;/a&gt; (provided by the &lt;code&gt;IntoIterator&lt;/code&gt; trait). See its documentation for more.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d0c83c37cc0812ff3b4a5b7bded4f379cae37eda" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;struct&lt;/code&gt; is created by the &lt;a href=&quot;struct.hashset#method.iter&quot;&gt;&lt;code&gt;iter&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;struct.hashset&quot;&gt;&lt;code&gt;HashSet&lt;/code&gt;&lt;/a&gt;. See its documentation for more.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2eb620627c49c8366b81c168c1e2da24ad0ba352" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;struct&lt;/code&gt; is created by the &lt;a href=&quot;struct.hashset#method.symmetric_difference&quot;&gt;&lt;code&gt;symmetric_difference&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;struct.hashset&quot;&gt;&lt;code&gt;HashSet&lt;/code&gt;&lt;/a&gt;. See its documentation for more.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="150f20ec4e603307925c0aee02dfd449f9a510cf" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;struct&lt;/code&gt; is created by the &lt;a href=&quot;struct.hashset#method.union&quot;&gt;&lt;code&gt;union&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;struct.hashset&quot;&gt;&lt;code&gt;HashSet&lt;/code&gt;&lt;/a&gt;. See its documentation for more.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2d89966c70887a327798b302de57b322446d731d" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;struct&lt;/code&gt; is created by the &lt;a href=&quot;struct.linkedlist#method.into_iter&quot;&gt;&lt;code&gt;into_iter&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;struct.linkedlist&quot;&gt;&lt;code&gt;LinkedList&lt;/code&gt;&lt;/a&gt; (provided by the &lt;code&gt;IntoIterator&lt;/code&gt; trait). See its documentation for more.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="58115891c3a0ac7312c6ea2a52ac61968cc4906c" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;struct&lt;/code&gt; is created by the &lt;a href=&quot;struct.linkedlist#method.iter&quot;&gt;&lt;code&gt;iter&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;struct.linkedlist&quot;&gt;&lt;code&gt;LinkedList&lt;/code&gt;&lt;/a&gt;. See its documentation for more.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f0659eea6bed999fa3680d324080162cd5e8a132" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;struct&lt;/code&gt; is created by the &lt;a href=&quot;struct.linkedlist#method.iter_mut&quot;&gt;&lt;code&gt;iter_mut&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;struct.linkedlist&quot;&gt;&lt;code&gt;LinkedList&lt;/code&gt;&lt;/a&gt;. See its documentation for more.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0aae0dd86db056d40eff085617d4cf75e5ca4cd1" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;struct&lt;/code&gt; is created by the &lt;a href=&quot;struct.path#method.ancestors&quot;&gt;&lt;code&gt;ancestors&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;struct.path&quot;&gt;&lt;code&gt;Path&lt;/code&gt;&lt;/a&gt;. See its documentation for more.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="678416258ee794f65fdd4a1cd12a337537c5938c" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;struct&lt;/code&gt; is created by the &lt;a href=&quot;struct.path#method.components&quot;&gt;&lt;code&gt;components&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;struct.path&quot;&gt;&lt;code&gt;Path&lt;/code&gt;&lt;/a&gt;. See its documentation for more.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f7998e185f302bc549a882f13518743e61ee46ed" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;struct&lt;/code&gt; is created by the &lt;a href=&quot;struct.path#method.iter&quot;&gt;&lt;code&gt;iter&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;struct.path&quot;&gt;&lt;code&gt;Path&lt;/code&gt;&lt;/a&gt;. See its documentation for more.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2cd612b3807ec02a5c6d66e1f1c48af60492df83" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;struct&lt;/code&gt; is created by the &lt;a href=&quot;struct.path#method.strip_prefix&quot;&gt;&lt;code&gt;strip_prefix&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;struct.path&quot;&gt;&lt;code&gt;Path&lt;/code&gt;&lt;/a&gt;. See its documentation for more.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1b5816e88e64a2f2821568b7180ce9b608c65d11" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;struct&lt;/code&gt; is created by the &lt;a href=&quot;struct.tcplistener#method.incoming&quot;&gt;&lt;code&gt;incoming&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;struct.tcplistener&quot;&gt;&lt;code&gt;TcpListener&lt;/code&gt;&lt;/a&gt;. See its documentation for more.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1f4d8367fad76ae04d5e19a5385a27f59c0aaf13" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;struct&lt;/code&gt; is created by the &lt;a href=&quot;struct.vec#method.drain&quot;&gt;&lt;code&gt;drain&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;struct.vec&quot;&gt;&lt;code&gt;Vec&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5f3bc5ceaa1713a6dc6144c9424b5691a097a496" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;struct&lt;/code&gt; is created by the &lt;a href=&quot;struct.vecdeque#method.drain&quot;&gt;&lt;code&gt;drain&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;struct.vecdeque&quot;&gt;&lt;code&gt;VecDeque&lt;/code&gt;&lt;/a&gt;. See its documentation for more.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b345fb68ea41cbf5a17dfb308f9d1a6e9820cc06" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;struct&lt;/code&gt; is created by the &lt;a href=&quot;struct.vecdeque#method.into_iter&quot;&gt;&lt;code&gt;into_iter&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;struct.vecdeque&quot;&gt;&lt;code&gt;VecDeque&lt;/code&gt;&lt;/a&gt; (provided by the &lt;code&gt;IntoIterator&lt;/code&gt; trait). See its documentation for more.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5c15922d5946c2fdadf8c55e5b28d91817f56274" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;struct&lt;/code&gt; is created by the &lt;a href=&quot;struct.vecdeque#method.iter&quot;&gt;&lt;code&gt;iter&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;struct.vecdeque&quot;&gt;&lt;code&gt;VecDeque&lt;/code&gt;&lt;/a&gt;. See its documentation for more.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6dcf16ee1a7554354a5a44529cc2c194dcf3a513" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;struct&lt;/code&gt; is created by the &lt;a href=&quot;struct.vecdeque#method.iter_mut&quot;&gt;&lt;code&gt;iter_mut&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;struct.vecdeque&quot;&gt;&lt;code&gt;VecDeque&lt;/code&gt;&lt;/a&gt;. See its documentation for more.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c378dde9d0a6525bd047bdf905231180a99f3491" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;struct&lt;/code&gt; is created by the &lt;a href=&quot;trait.iterator#method.chain&quot;&gt;&lt;code&gt;chain&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;trait.iterator&quot;&gt;&lt;code&gt;Iterator&lt;/code&gt;&lt;/a&gt;. See its documentation for more.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b7e65fcf3ce565260fcf0013397e867c30f8522f" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;struct&lt;/code&gt; is created by the &lt;a href=&quot;trait.iterator#method.cloned&quot;&gt;&lt;code&gt;cloned&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;trait.iterator&quot;&gt;&lt;code&gt;Iterator&lt;/code&gt;&lt;/a&gt;. See its documentation for more.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f5b898ca8f830f2683dbb470bc2669fdcc151557" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;struct&lt;/code&gt; is created by the &lt;a href=&quot;trait.iterator#method.copied&quot;&gt;&lt;code&gt;copied&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;trait.iterator&quot;&gt;&lt;code&gt;Iterator&lt;/code&gt;&lt;/a&gt;. See its documentation for more.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6792715370c3a92e84d28374f5832cff5986bd03" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;struct&lt;/code&gt; is created by the &lt;a href=&quot;trait.iterator#method.cycle&quot;&gt;&lt;code&gt;cycle&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;trait.iterator&quot;&gt;&lt;code&gt;Iterator&lt;/code&gt;&lt;/a&gt;. See its documentation for more.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eef34875ae92021a31b6bedf0e5ef3ef03a55346" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;struct&lt;/code&gt; is created by the &lt;a href=&quot;trait.iterator#method.enumerate&quot;&gt;&lt;code&gt;enumerate&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;trait.iterator&quot;&gt;&lt;code&gt;Iterator&lt;/code&gt;&lt;/a&gt;. See its documentation for more.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9fb0d2f619194cb6fd2c5912cd0ab4f8aa1436b0" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;struct&lt;/code&gt; is created by the &lt;a href=&quot;trait.iterator#method.filter&quot;&gt;&lt;code&gt;filter&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;trait.iterator&quot;&gt;&lt;code&gt;Iterator&lt;/code&gt;&lt;/a&gt;. See its documentation for more.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7b10e5f9bf83042ee3e1d8a41324ee574deb204c" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;struct&lt;/code&gt; is created by the &lt;a href=&quot;trait.iterator#method.filter_map&quot;&gt;&lt;code&gt;filter_map&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;trait.iterator&quot;&gt;&lt;code&gt;Iterator&lt;/code&gt;&lt;/a&gt;. See its documentation for more.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e8efe5c2b3a46412d14b079c4efde7503ec17047" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;struct&lt;/code&gt; is created by the &lt;a href=&quot;trait.iterator#method.flat_map&quot;&gt;&lt;code&gt;flat_map&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;trait.iterator&quot;&gt;&lt;code&gt;Iterator&lt;/code&gt;&lt;/a&gt;. See its documentation for more.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="06ac94503cae6df0f4ea2938d28112afa01fe8f9" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;struct&lt;/code&gt; is created by the &lt;a href=&quot;trait.iterator#method.flatten&quot;&gt;&lt;code&gt;flatten&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;trait.iterator&quot;&gt;&lt;code&gt;Iterator&lt;/code&gt;&lt;/a&gt;. See its documentation for more.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b8c0c8898fdf0a69bb894be3b262576aa94693ed" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;struct&lt;/code&gt; is created by the &lt;a href=&quot;trait.iterator#method.fuse&quot;&gt;&lt;code&gt;fuse&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;trait.iterator&quot;&gt;&lt;code&gt;Iterator&lt;/code&gt;&lt;/a&gt;. See its documentation for more.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="16538eabad39936ba061176498ea306e212f6f92" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;struct&lt;/code&gt; is created by the &lt;a href=&quot;trait.iterator#method.inspect&quot;&gt;&lt;code&gt;inspect&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;trait.iterator&quot;&gt;&lt;code&gt;Iterator&lt;/code&gt;&lt;/a&gt;. See its documentation for more.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a0b5389b001bb0bbe98e28bcb36e5aebd8a66723" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;struct&lt;/code&gt; is created by the &lt;a href=&quot;trait.iterator#method.map&quot;&gt;&lt;code&gt;map&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;trait.iterator&quot;&gt;&lt;code&gt;Iterator&lt;/code&gt;&lt;/a&gt;. See its documentation for more.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2a63b8c96bdf4e631228dfff76c51a72895aa1c2" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;struct&lt;/code&gt; is created by the &lt;a href=&quot;trait.iterator#method.peekable&quot;&gt;&lt;code&gt;peekable&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;trait.iterator&quot;&gt;&lt;code&gt;Iterator&lt;/code&gt;&lt;/a&gt;. See its documentation for more.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="77b9d3dc967cfc65e7923a1d25d998d0359bf8da" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;struct&lt;/code&gt; is created by the &lt;a href=&quot;trait.iterator#method.rev&quot;&gt;&lt;code&gt;rev&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;trait.iterator&quot;&gt;&lt;code&gt;Iterator&lt;/code&gt;&lt;/a&gt;. See its documentation for more.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0c534d67b85da417a0620daeb199532327c51e03" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;struct&lt;/code&gt; is created by the &lt;a href=&quot;trait.iterator#method.scan&quot;&gt;&lt;code&gt;scan&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;trait.iterator&quot;&gt;&lt;code&gt;Iterator&lt;/code&gt;&lt;/a&gt;. See its documentation for more.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d55ea7e68cc78050a3929f56a9674ef3cbe9031c" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;struct&lt;/code&gt; is created by the &lt;a href=&quot;trait.iterator#method.skip&quot;&gt;&lt;code&gt;skip&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;trait.iterator&quot;&gt;&lt;code&gt;Iterator&lt;/code&gt;&lt;/a&gt;. See its documentation for more.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="752b3b9ee442b1ede4f01e7280612ee155b893b6" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;struct&lt;/code&gt; is created by the &lt;a href=&quot;trait.iterator#method.skip_while&quot;&gt;&lt;code&gt;skip_while&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;trait.iterator&quot;&gt;&lt;code&gt;Iterator&lt;/code&gt;&lt;/a&gt;. See its documentation for more.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e4194d8e81f0d479a0971b522dc10170de8177ce" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;struct&lt;/code&gt; is created by the &lt;a href=&quot;trait.iterator#method.step_by&quot;&gt;&lt;code&gt;step_by&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;trait.iterator&quot;&gt;&lt;code&gt;Iterator&lt;/code&gt;&lt;/a&gt;. See its documentation for more.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ae2f32a2383fa23779c3295dfc6285ad6be64c98" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;struct&lt;/code&gt; is created by the &lt;a href=&quot;trait.iterator#method.take&quot;&gt;&lt;code&gt;take&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;trait.iterator&quot;&gt;&lt;code&gt;Iterator&lt;/code&gt;&lt;/a&gt;. See its documentation for more.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="431a8793b970c81fcc0ab5b7d979a63311ac642a" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;struct&lt;/code&gt; is created by the &lt;a href=&quot;trait.iterator#method.take_while&quot;&gt;&lt;code&gt;take_while&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;trait.iterator&quot;&gt;&lt;code&gt;Iterator&lt;/code&gt;&lt;/a&gt;. See its documentation for more.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f6420f53e024dcbfd568efb25b94839f7a579e39" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;struct&lt;/code&gt; is created by the &lt;a href=&quot;trait.iterator#method.zip&quot;&gt;&lt;code&gt;zip&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;trait.iterator&quot;&gt;&lt;code&gt;Iterator&lt;/code&gt;&lt;/a&gt;. See its documentation for more.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8be96a57f8e063c35aa0cfee79161d9fbe1f4027" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;struct&lt;/code&gt; is created by the &lt;code&gt;into_iter&lt;/code&gt; method on &lt;a href=&quot;struct.vec&quot;&gt;&lt;code&gt;Vec&lt;/code&gt;&lt;/a&gt; (provided by the &lt;a href=&quot;../iter/trait.intoiterator&quot;&gt;&lt;code&gt;IntoIterator&lt;/code&gt;&lt;/a&gt; trait).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="75da1f33c5a1b29ca9ce3084de81aca63a2c8c06" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;struct&lt;/code&gt; is used to represent the exit status of a child process. Child processes are created via the &lt;a href=&quot;struct.command&quot;&gt;&lt;code&gt;Command&lt;/code&gt;&lt;/a&gt; struct and their exit status is exposed through the &lt;a href=&quot;struct.command#method.status&quot;&gt;&lt;code&gt;status&lt;/code&gt;&lt;/a&gt; method, or the &lt;a href=&quot;struct.child#method.wait&quot;&gt;&lt;code&gt;wait&lt;/code&gt;&lt;/a&gt; method of a &lt;a href=&quot;struct.child&quot;&gt;&lt;code&gt;Child&lt;/code&gt;&lt;/a&gt; process.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5f5bb1decbaa26846cd44955c2f8ab7127199a37" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;use&lt;/code&gt; statement brings all public items defined in &lt;code&gt;std::collections&lt;/code&gt; into the current scope. Be careful when using the glob operator! Glob can make it harder to tell what names are in scope and where a name used in your program was defined.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="caecafb5a4fb0937d47c4a448338d709acd25fe7" translate="yes" xml:space="preserve">
          <source>This &lt;strong&gt;channel&lt;/strong&gt; is currently empty, but the &lt;strong&gt;Sender&lt;/strong&gt;(s) have not yet disconnected, so data may yet become available.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8266d9d9a47bf63d7284fb3019e831be816c08a4" translate="yes" xml:space="preserve">
          <source>This Greek letter convention is usually just employed when the presence of a sequence is a technical detail; in particular, when we wish to &lt;em&gt;emphasize&lt;/em&gt; that we are operating on a sequence of token-trees, we will use the notation &quot;tt ...&quot; for the sequence, not a Greek letter.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6b20bc4e00b7823d1d79ae42b369f4aec802629c" translate="yes" xml:space="preserve">
          <source>This allows a program to terminate immediately and provide feedback to the caller of the program. &lt;code&gt;panic!&lt;/code&gt; should be used when a program reaches an unrecoverable state.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8257259a712f5169c7b4c3c0a8b238e35c31bcfe" translate="yes" xml:space="preserve">
          <source>This allows creating a custom iterator with any behavior without using the more verbose syntax of creating a dedicated type and implementing the &lt;code&gt;Iterator&lt;/code&gt; trait for it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="df65a862360a6e0bd203ebc75d215550a55a7ec8" translate="yes" xml:space="preserve">
          <source>This allows the value to be dropped again.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e583956f9df46a2ff992eeadbf1d346839209a48" translate="yes" xml:space="preserve">
          <source>This allows writing a projection that creates a &lt;code&gt;Pin&amp;lt;&amp;amp;mut Field&amp;gt;&lt;/code&gt;, thus witnessing that the field is pinned:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d056f20cad4a501761c404be3055779184b1614f" translate="yes" xml:space="preserve">
          <source>This also in turn requires the annotation &lt;code&gt;T: 'a&lt;/code&gt;, indicating that any references in &lt;code&gt;T&lt;/code&gt; are valid over the lifetime &lt;code&gt;'a&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="60e1ada09db527973a7bebfb74dc7b9bbc576185" translate="yes" xml:space="preserve">
          <source>This also means that all resources such as file descriptors and memory-mapped regions got duplicated. It is your responsibility to make sure that the closure does not violate library invariants by making invalid use of these duplicates.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c5dab5f83abd965944fb4f235779eceb37146b12" translate="yes" xml:space="preserve">
          <source>This and &lt;a href=&quot;../macro.println&quot;&gt;&lt;code&gt;println!&lt;/code&gt;&lt;/a&gt; emit their output to stdout. Similarly to the &lt;a href=&quot;../macro.write&quot;&gt;&lt;code&gt;write!&lt;/code&gt;&lt;/a&gt; macro, the goal of these macros is to avoid intermediate allocations when printing output. Example usage is:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="acaf201fd6cc02b279b5987151a707c144a7e5c9" translate="yes" xml:space="preserve">
          <source>This and &lt;a href=&quot;../macro.writeln&quot;&gt;&lt;code&gt;writeln!&lt;/code&gt;&lt;/a&gt; are two macros which are used to emit the format string to a specified stream. This is used to prevent intermediate allocations of format strings and instead directly write the output. Under the hood, this function is actually invoking the &lt;a href=&quot;../io/trait.write#method.write_fmt&quot;&gt;&lt;code&gt;write_fmt&lt;/code&gt;&lt;/a&gt; function defined on the &lt;a href=&quot;../io/trait.write&quot;&gt;&lt;code&gt;std::io::Write&lt;/code&gt;&lt;/a&gt; trait. Example usage is:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7dd14a6dd33e863c7c3a9afcbc1b94db44474940" translate="yes" xml:space="preserve">
          <source>This appendix contains a glossary of Rust&amp;rsquo;s syntax, including operators and other symbols that appear by themselves or in the context of paths, generics, trait bounds, macros, attributes, comments, tuples, and brackets.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="98f7d37c50386fc1a7bc45c602df60e2a6b2f88d" translate="yes" xml:space="preserve">
          <source>This appendix is about how Rust is made and how that affects you as a Rust developer.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cf4d5070c48104546a550c9a051a5f05bc584068" translate="yes" xml:space="preserve">
          <source>This associated type corresponds to the &lt;code&gt;yield&lt;/code&gt; expression and the values which are allowed to be returned each time a generator yields. For example an iterator-as-a-generator would likely have this type as &lt;code&gt;T&lt;/code&gt;, the type being iterated over.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fe55ae487fde4fa4dff7b2d6d6cdbe76cfbf6518" translate="yes" xml:space="preserve">
          <source>This attribute allows configuring the choice of global allocator. You can use this to implement a completely custom global allocator to route all default allocation requests to a custom object.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ef26e5c3cab23c11bb733ef68934315ad78b85fb" translate="yes" xml:space="preserve">
          <source>This avoids reallocating where possible, but the conditions for that are strict, and subject to change, and so shouldn't be relied upon unless the &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; came from &lt;code&gt;From&amp;lt;VecDeque&amp;lt;T&amp;gt;&amp;gt;&lt;/code&gt; and hasn't been reallocated.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c09355cbc8b51304e7c4f53224a50044b1a70814" translate="yes" xml:space="preserve">
          <source>This book also does not serve as a reference to the &lt;a href=&quot;../std/index&quot;&gt;standard library&lt;/a&gt; included in the language distribution. Those libraries are documented separately by extracting documentation attributes from their source code. Many of the features that one might expect to be language features are library features in Rust, so what you're looking for may be there, not here.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8e20080fb8e1699ed580bf1c766151d2b69a59c9" translate="yes" xml:space="preserve">
          <source>This book also only serves as a reference to what is available in stable Rust. For unstable features being worked on, see the &lt;a href=&quot;https://doc.rust-lang.org/nightly/unstable-book/index.html&quot;&gt;Unstable Book&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="32b7e021bdc132a2756c978c8a1d27d9e8d25d04" translate="yes" xml:space="preserve">
          <source>This book assumes that you&amp;rsquo;ve written code in another programming language but doesn&amp;rsquo;t make any assumptions about which one. We&amp;rsquo;ve tried to make the material broadly accessible to those from a wide variety of programming backgrounds. We don&amp;rsquo;t spend a lot of time talking about what programming &lt;em&gt;is&lt;/em&gt; or how to think about it. If you&amp;rsquo;re entirely new to programming, you would be better served by reading a book that specifically provides an introduction to programming.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fb8d9819998123cf06ddd8f5a1ff9953b5c7298e" translate="yes" xml:space="preserve">
          <source>This book does not assume you are reading this book sequentially. Each chapter generally can be read standalone, but will cross-link to other chapters for facets of the language they refer to, but do not discuss.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="74d346bfc5c0837e4df013dba9f47fd4b57ffe9b" translate="yes" xml:space="preserve">
          <source>This book does not serve as an introduction to the language. Background familiarity with the language is assumed. A separate &lt;a href=&quot;../index&quot;&gt;book&lt;/a&gt; is available to help acquire such background familiarity.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4589512ba2ae3140ba2d5cf22da84c708acf0a3c" translate="yes" xml:space="preserve">
          <source>This book fully embraces the potential of Rust to empower its users. It&amp;rsquo;s a friendly and approachable text intended to help you level up not just your knowledge of Rust, but also your reach and confidence as a programmer in general. So dive in, get ready to learn&amp;mdash;and welcome to the Rust community!</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5eac84b162d067e7c7224575575cec18251ae81c" translate="yes" xml:space="preserve">
          <source>This book is the primary reference for the Rust programming language. It provides three kinds of material:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4dac54ff1b6d498bb0e5ad5ca44a29d6b2c3c87b" translate="yes" xml:space="preserve">
          <source>This book only contains information about stable features, as in-progress features are still changing, and surely they&amp;rsquo;ll be different between when this book was written and when they get enabled in stable builds. You can find documentation for nightly-only features online.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9b40452b3457baf6eb9c9eb4c95b596dc78a3493" translate="yes" xml:space="preserve">
          <source>This broken invariant is then later observed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="626674212943f16d78b9c64b216d4813683d4bcd" translate="yes" xml:space="preserve">
          <source>This buffer is always stored on the heap.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="533f834501c9981cf01926064551726140f691d1" translate="yes" xml:space="preserve">
          <source>This builder also supports platform-specific options.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="828127de31395e4a312b7fc3b3384b3f2a31aa51" translate="yes" xml:space="preserve">
          <source>This builder exposes the ability to configure how a &lt;a href=&quot;struct.file&quot;&gt;&lt;code&gt;File&lt;/code&gt;&lt;/a&gt; is opened and what operations are permitted on the open file. The &lt;a href=&quot;struct.file#method.open&quot;&gt;&lt;code&gt;File::open&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;struct.file#method.create&quot;&gt;&lt;code&gt;File::create&lt;/code&gt;&lt;/a&gt; methods are aliases for commonly used options using this builder.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e3a75e262b3ddd48064e08eaf81396d4af4ef1e5" translate="yes" xml:space="preserve">
          <source>This call borrows &lt;code&gt;Cell&lt;/code&gt; mutably (at compile-time) which guarantees that we possess the only reference.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5a4e17ce4bfa3ac12c6fb727cdafac307c2e7b00" translate="yes" xml:space="preserve">
          <source>This call borrows &lt;code&gt;RefCell&lt;/code&gt; mutably (at compile-time) so there is no need for dynamic checks.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bafb9cba9c70e76a1a3bb46e83a3fb5e4a1e4a73" translate="yes" xml:space="preserve">
          <source>This can also be thought of as the fallible form of &lt;a href=&quot;#method.for_each&quot;&gt;&lt;code&gt;for_each()&lt;/code&gt;&lt;/a&gt; or as the stateless version of &lt;a href=&quot;#method.try_fold&quot;&gt;&lt;code&gt;try_fold()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dc5e7768aa508543b82b361f251df561c08e6d32" translate="yes" xml:space="preserve">
          <source>This can also be used in multithreaded applications, in order to send a message to other threads warning that a thread has panicked (e.g., for monitoring purposes).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="115ef26a79f6ceeca6376e7547342f4fb025dc8d" translate="yes" xml:space="preserve">
          <source>This can be cast to a pointer of any kind. Ensure that the access is unique (no active references, mutable or not) when casting to &lt;code&gt;&amp;amp;mut T&lt;/code&gt;, and ensure that there are no mutations or mutable aliases going on when casting to &lt;code&gt;&amp;amp;T&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="214edc09ead3c27edfef862878240910ed92a93e" translate="yes" xml:space="preserve">
          <source>This can be constructed by the &lt;a href=&quot;struct.formatter#method.debug_list&quot;&gt;&lt;code&gt;Formatter::debug_list&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c7514961910752b90460d88f227b5817215d7f6e" translate="yes" xml:space="preserve">
          <source>This can be constructed by the &lt;a href=&quot;struct.formatter#method.debug_map&quot;&gt;&lt;code&gt;Formatter::debug_map&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="db45b1697100bb4357e93b4848fb22d93091bccd" translate="yes" xml:space="preserve">
          <source>This can be constructed by the &lt;a href=&quot;struct.formatter#method.debug_set&quot;&gt;&lt;code&gt;Formatter::debug_set&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="efbf03337e671dc0f2d75f1c2d72ed7746b99e34" translate="yes" xml:space="preserve">
          <source>This can be constructed by the &lt;a href=&quot;struct.formatter#method.debug_struct&quot;&gt;&lt;code&gt;Formatter::debug_struct&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="daed88198496b5861ca72aa01db8f1e07a7a1fbc" translate="yes" xml:space="preserve">
          <source>This can be constructed by the &lt;a href=&quot;struct.formatter#method.debug_tuple&quot;&gt;&lt;code&gt;Formatter::debug_tuple&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2479ae89d6780ca289ef37404c0461658bc53872" translate="yes" xml:space="preserve">
          <source>This can be used to compare &lt;code&gt;&amp;amp;T&lt;/code&gt; references (which coerce to &lt;code&gt;*const T&lt;/code&gt; implicitly) by their address rather than comparing the values they point to (which is what the &lt;code&gt;PartialEq for &amp;amp;T&lt;/code&gt; implementation does).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b3720c96ba6b1476408a923be1876044bc567298" translate="yes" xml:space="preserve">
          <source>This can be used to compare enums that carry data, while disregarding the actual data:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="27925db5758baea8a7b4ada29852f78f4d3d7a94" translate="yes" xml:space="preserve">
          <source>This can be used to handle errors that would otherwise only be caught when the &lt;code&gt;File&lt;/code&gt; is closed. Dropping a file will ignore errors in synchronizing this in-memory data.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9856559b29a29e0f25c3e61f2c093f50c7905e19" translate="yes" xml:space="preserve">
          <source>This can be used to hash a &lt;code&gt;&amp;amp;T&lt;/code&gt; reference (which coerces to &lt;code&gt;*const T&lt;/code&gt; implicitly) by its address rather than the value it points to (which is what the &lt;code&gt;Hash for &amp;amp;T&lt;/code&gt; implementation does).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="13a7b507773148ef054095424c9d9ac4d8251d3e" translate="yes" xml:space="preserve">
          <source>This can be used to safely get a strong reference (by calling &lt;a href=&quot;struct.weak#method.upgrade&quot;&gt;&lt;code&gt;upgrade&lt;/code&gt;&lt;/a&gt; later) or to deallocate the weak count by dropping the &lt;code&gt;Weak&amp;lt;T&amp;gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fb4c5fc4f14344c508855aa0c67808589d2ea5df" translate="yes" xml:space="preserve">
          <source>This can be useful if you are prototyping and are just looking to have your code type-check, or if you're implementing a trait that requires multiple methods, and you're only planning on using one of them.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="13e97c3892555defded3caf3fd786d6a9bf7c197" translate="yes" xml:space="preserve">
          <source>This can be useful if you are prototyping and are just looking to have your code typecheck. &lt;code&gt;todo!&lt;/code&gt; works exactly like &lt;code&gt;unimplemented!&lt;/code&gt;. The only difference between the two macros is the name.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b8075fc432fec0682f4342dc70f37276a8d8a19f" translate="yes" xml:space="preserve">
          <source>This can never cause a problem in safe code because implementing a type that relies on pinning requires unsafe code, but be aware that deciding to make use of pinning in your type (for example by implementing some operation on &lt;code&gt;Pin&amp;lt;&amp;amp;Self&amp;gt;&lt;/code&gt; or &lt;code&gt;Pin&amp;lt;&amp;amp;mut Self&amp;gt;&lt;/code&gt;) has consequences for your &lt;code&gt;Drop&lt;/code&gt; implementation as well: if an element of your type could have been pinned, you must treat Drop as implicitly taking &lt;code&gt;Pin&amp;lt;&amp;amp;mut Self&amp;gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cadc6079abb6a4bbc592c234ce0da222e1a2fdc1" translate="yes" xml:space="preserve">
          <source>This change unifies all the calls to &lt;code&gt;simulated_expensive_calculation&lt;/code&gt; and solves the problem of the first &lt;code&gt;if&lt;/code&gt; block unnecessarily calling the function twice. Unfortunately, we&amp;rsquo;re now calling this function and waiting for the result in all cases, which includes the inner &lt;code&gt;if&lt;/code&gt; block that doesn&amp;rsquo;t use the result value at all.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d160910b055fc36b0155788ef2b0b90383b734d2" translate="yes" xml:space="preserve">
          <source>This channel has an internal buffer on which messages will be queued. &lt;code&gt;bound&lt;/code&gt; specifies the buffer size. When the internal buffer becomes full, future sends will &lt;em&gt;block&lt;/em&gt; waiting for the buffer to open up. Note that a buffer size of 0 is valid, in which case this becomes &quot;rendezvous channel&quot; where each &lt;a href=&quot;struct.syncsender#method.send&quot;&gt;&lt;code&gt;send&lt;/code&gt;&lt;/a&gt; will not return until a &lt;a href=&quot;struct.receiver#method.recv&quot;&gt;&lt;code&gt;recv&lt;/code&gt;&lt;/a&gt; is paired with it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fb1d7eb08fcc70de9ba8181af70c6fc4dce88829" translate="yes" xml:space="preserve">
          <source>This chapter covered how to use smart pointers to make different guarantees and trade-offs from those Rust makes by default with regular references. The &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; type has a known size and points to data allocated on the heap. The &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; type keeps track of the number of references to data on the heap so that data can have multiple owners. The &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt; type with its interior mutability gives us a type that we can use when we need an immutable type but need to change an inner value of that type; it also enforces the borrowing rules at runtime instead of at compile time.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d76b58ff9e32a83f32bdf3cb1438b47bc33ded06" translate="yes" xml:space="preserve">
          <source>This chapter covers concepts that appear in almost every programming language and how they work in Rust. Many programming languages have much in common at their core. None of the concepts presented in this chapter are unique to Rust, but we&amp;rsquo;ll discuss them in the context of Rust and explain the conventions around using these concepts.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="29ea0fbfb2601396e36f35e6ef2ff2eccf09482a" translate="yes" xml:space="preserve">
          <source>This chapter is a recap of the many skills you&amp;rsquo;ve learned so far and an exploration of a few more standard library features. We&amp;rsquo;ll build a command line tool that interacts with file and command line input/output to practice some of the Rust concepts you now have under your belt.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ba9d120769583a2b06ff5bcafb1b013c4c1c420a" translate="yes" xml:space="preserve">
          <source>This chapter is a reference on all things related to patterns. We&amp;rsquo;ll cover the valid places to use patterns, the difference between refutable and irrefutable patterns, and the different kinds of pattern syntax that you might see. By the end of the chapter, you&amp;rsquo;ll know how to use patterns to express many concepts in a clear way.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4ca695707d3d924a4c7520a559258f62a52be801" translate="yes" xml:space="preserve">
          <source>This chapter recapped some of the major concepts you&amp;rsquo;ve learned so far and covered how to perform common I/O operations in Rust. By using command line arguments, files, environment variables, and the &lt;code&gt;eprintln!&lt;/code&gt; macro for printing errors, you&amp;rsquo;re now prepared to write command line applications. By using the concepts in previous chapters, your code will be well organized, store data effectively in the appropriate data structures, handle errors nicely, and be well tested.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4f14f23451903925edc1325ae4f6812d472301ab" translate="yes" xml:space="preserve">
          <source>This closure will be run in the context of the child process after a &lt;code&gt;fork&lt;/code&gt;. This primarily means that any modifications made to memory on behalf of this closure will &lt;strong&gt;not&lt;/strong&gt; be visible to the parent process. This is often a very constrained environment where normal operations like &lt;code&gt;malloc&lt;/code&gt; or acquiring a mutex are not guaranteed to work (due to other threads perhaps still running when the &lt;code&gt;fork&lt;/code&gt; was run).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="22a1461b442324db65b2ce2aa52db0c09471bd28" translate="yes" xml:space="preserve">
          <source>This code also sets &lt;code&gt;s&lt;/code&gt; to &lt;code&gt;tic-tac-toe&lt;/code&gt;. The &lt;code&gt;format!&lt;/code&gt; macro works in the same way as &lt;code&gt;println!&lt;/code&gt;, but instead of printing the output to the screen, it returns a &lt;code&gt;String&lt;/code&gt; with the contents. The version of the code using &lt;code&gt;format!&lt;/code&gt; is much easier to read and doesn&amp;rsquo;t take ownership of any of its parameters.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d361c400527932085f404cf9d818fa511cfc4bc4" translate="yes" xml:space="preserve">
          <source>This code block contains unsafe code.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8be923288a70fe6e854b5bc75a5a5f3ea2e87376" translate="yes" xml:space="preserve">
          <source>This code compiles and runs but doesn&amp;rsquo;t result in the desired threading behavior: a slow request will still cause other requests to wait to be processed. The reason is somewhat subtle: the &lt;code&gt;Mutex&lt;/code&gt; struct has no public &lt;code&gt;unlock&lt;/code&gt; method because the ownership of the lock is based on the lifetime of the &lt;code&gt;MutexGuard&amp;lt;T&amp;gt;&lt;/code&gt; within the &lt;code&gt;LockResult&amp;lt;MutexGuard&amp;lt;T&amp;gt;&amp;gt;&lt;/code&gt; that the &lt;code&gt;lock&lt;/code&gt; method returns. At compile time, the borrow checker can then enforce the rule that a resource guarded by a &lt;code&gt;Mutex&lt;/code&gt; cannot be accessed unless we hold the lock. But this implementation can also result in the lock being held longer than intended if we don&amp;rsquo;t think carefully about the lifetime of the &lt;code&gt;MutexGuard&amp;lt;T&amp;gt;&lt;/code&gt;. Because the values in the &lt;code&gt;while&lt;/code&gt; expression remain in scope for the duration of the block, the lock remains held for the duration of the call to &lt;code&gt;job.call_box()&lt;/code&gt;, meaning other workers cannot receive jobs.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a9ddcc8d0db1cdd5bd0507394434501db1a0bedf" translate="yes" xml:space="preserve">
          <source>This code contains a lot of information, so let&amp;rsquo;s go over it line by line. To obtain user input and then print the result as output, we need to bring the &lt;code&gt;io&lt;/code&gt; (input/output) library into scope. The &lt;code&gt;io&lt;/code&gt; library comes from the standard library (which is known as &lt;code&gt;std&lt;/code&gt;):</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a2cf7c9b3ea591cd958e0136c121e6bf9f333d13" translate="yes" xml:space="preserve">
          <source>This code creates a string containing &lt;code&gt;initial contents&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="37eb73353618177bcb3ef1d909b78d97976287b7" translate="yes" xml:space="preserve">
          <source>This code creates the variables &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; that match the values of the &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; fields of the &lt;code&gt;p&lt;/code&gt; struct. This example shows that the names of the variables in the pattern don&amp;rsquo;t have to match the field names of the struct. But it&amp;rsquo;s common to want the variable names to match the field names to make it easier to remember which variables came from which fields.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4c6b27e7fab9563bf2abcf70ff023ebf232f1887" translate="yes" xml:space="preserve">
          <source>This code creates the variables &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; that match the &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; fields of the &lt;code&gt;p&lt;/code&gt; variable. The outcome is that the variables &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; contain the values from the &lt;code&gt;p&lt;/code&gt; struct.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="519fd3df45d223b502667d31300a65c73f22de3a" translate="yes" xml:space="preserve">
          <source>This code does not compile!</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a8563da8c7fd875eb235c5cf17bc917dd4b6aba0" translate="yes" xml:space="preserve">
          <source>This code does not produce the desired behavior.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0426964d440764948892b9452f7b1a751866e79c" translate="yes" xml:space="preserve">
          <source>This code illustrates that you can put any kind of data inside an enum variant: strings, numeric types, or structs, for example. You can even include another enum! Also, standard library types are often not much more complicated than what you might come up with.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="23d4be6e177cb0763cfd5315e376249487e60755" translate="yes" xml:space="preserve">
          <source>This code is a bit messy, but it&amp;rsquo;s good enough for simulation purposes. We created a second request &lt;code&gt;sleep&lt;/code&gt;, whose data our server recognizes. We added an &lt;code&gt;else if&lt;/code&gt; after the &lt;code&gt;if&lt;/code&gt; block to check for the request to &lt;em&gt;/sleep&lt;/em&gt;. When that request is received, the server will sleep for 5 seconds before rendering the successful HTML page.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9400019c8ed3d0b61a4a67558c972e785c9498d4" translate="yes" xml:space="preserve">
          <source>This code is a bit nicer, isn&amp;rsquo;t it?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a9d573288ab51576cf8efa92e3fc2409e71975a4" translate="yes" xml:space="preserve">
          <source>This code is for an animal shelter that wants to name all puppies Spot, which is implemented in the &lt;code&gt;baby_name&lt;/code&gt; associated function that is defined on &lt;code&gt;Dog&lt;/code&gt;. The &lt;code&gt;Dog&lt;/code&gt; type also implements the trait &lt;code&gt;Animal&lt;/code&gt;, which describes characteristics that all animals have. Baby dogs are called puppies, and that is expressed in the implementation of the &lt;code&gt;Animal&lt;/code&gt; trait on &lt;code&gt;Dog&lt;/code&gt; in the &lt;code&gt;baby_name&lt;/code&gt; function associated with the &lt;code&gt;Animal&lt;/code&gt; trait.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="28ab5f7e147cb2d4d661943464a31c7e543917cd" translate="yes" xml:space="preserve">
          <source>This code is much easier to read and write! Choosing a meaningful name for a type alias can help communicate your intent as well (&lt;em&gt;thunk&lt;/em&gt; is a word for code to be evaluated at a later time, so it&amp;rsquo;s an appropriate name for a closure that gets stored).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="49a0f8f422e51179065e97042cbf65579f27fccc" translate="yes" xml:space="preserve">
          <source>This code is not legal: it is not possible to specialize &lt;code&gt;Drop&lt;/code&gt; to a subset of implementations of a generic type. In order for this code to work, &lt;code&gt;MyStruct&lt;/code&gt; must also require that &lt;code&gt;T&lt;/code&gt; implements &lt;code&gt;Foo&lt;/code&gt;. Alternatively, another option is to wrap the generic type in another that specializes appropriately:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e6419e6d86ad5d4d771d701592b7c8059bf718cc" translate="yes" xml:space="preserve">
          <source>This code is not legal: it is not possible to specialize &lt;code&gt;Drop&lt;/code&gt; to a subset of implementations of a generic type. One workaround for this is to wrap the generic type, as shown below:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7561545f94912a4c2f636ef3be71bf5e25ba09fc" translate="yes" xml:space="preserve">
          <source>This code is printing a prompt stating what the game is and requesting input from the user.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7103520ca1aa03619df8713fc5365e846d9c5ad3" translate="yes" xml:space="preserve">
          <source>This code is read as &amp;ldquo;the function &lt;code&gt;bar&lt;/code&gt; returns never.&amp;rdquo; Functions that return never are called &lt;em&gt;diverging functions&lt;/em&gt;. We can&amp;rsquo;t create values of the type &lt;code&gt;!&lt;/code&gt; so &lt;code&gt;bar&lt;/code&gt; can never possibly return.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bcd0c3078c2294c0e6fda3c229de0e1561bef882" translate="yes" xml:space="preserve">
          <source>This code is similar to &lt;a href=&quot;ch09-03-to-panic-or-not-to-panic#creating-custom-types-for-validation&quot;&gt;the &lt;code&gt;Guess::new&lt;/code&gt; function we wrote in Listing 9-10&lt;/a&gt;, where we called &lt;code&gt;panic!&lt;/code&gt; when the &lt;code&gt;value&lt;/code&gt; argument was out of the range of valid values. Instead of checking for a range of values here, we&amp;rsquo;re checking that the length of &lt;code&gt;args&lt;/code&gt; is at least 3 and the rest of the function can operate under the assumption that this condition has been met. If &lt;code&gt;args&lt;/code&gt; has fewer than three items, this condition will be true, and we call the &lt;code&gt;panic!&lt;/code&gt; macro to end the program immediately.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7a83ac1e4ecf68353438d16df2a11f1d38c56035" translate="yes" xml:space="preserve">
          <source>This code is the automatically generated test module. The attribute &lt;code&gt;cfg&lt;/code&gt; stands for &lt;em&gt;configuration&lt;/em&gt; and tells Rust that the following item should only be included given a certain configuration option. In this case, the configuration option is &lt;code&gt;test&lt;/code&gt;, which is provided by Rust for compiling and running tests. By using the &lt;code&gt;cfg&lt;/code&gt; attribute, Cargo compiles our test code only if we actively run the tests with &lt;code&gt;cargo test&lt;/code&gt;. This includes any helper functions that might be within this module, in addition to the functions annotated with &lt;code&gt;#[test]&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fb14b558eed9a012f6129027202f61756e6e0b8d" translate="yes" xml:space="preserve">
          <source>This code lets us break complex types into their component parts so we can use the values we&amp;rsquo;re interested in separately.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bf80b97b3cceef068893acf5a419fa57178f1aed" translate="yes" xml:space="preserve">
          <source>This code means the type &lt;code&gt;Point&amp;lt;f32&amp;gt;&lt;/code&gt; will have a method named &lt;code&gt;distance_from_origin&lt;/code&gt; and other instances of &lt;code&gt;Point&amp;lt;T&amp;gt;&lt;/code&gt; where &lt;code&gt;T&lt;/code&gt; is not of type &lt;code&gt;f32&lt;/code&gt; will not have this method defined. The method measures how far our point is from the point at coordinates (0.0, 0.0) and uses mathematical operations that are available only for floating point types.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="edb9c9f6097f3c4e5bd16a047b4ef0c91c5eda3e" translate="yes" xml:space="preserve">
          <source>This code overrides the default setting of &lt;code&gt;0&lt;/code&gt;. Now when we run &lt;code&gt;cargo build&lt;/code&gt;, Cargo will use the defaults for the &lt;code&gt;dev&lt;/code&gt; profile plus our customization to &lt;code&gt;opt-level&lt;/code&gt;. Because we set &lt;code&gt;opt-level&lt;/code&gt; to &lt;code&gt;1&lt;/code&gt;, Cargo will apply more optimizations than the default, but not as many as in a release build.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cbd474aff68e6272a4d817ab514ba2ba338dc2b1" translate="yes" xml:space="preserve">
          <source>This code panics!</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1520d0fd722c3577359ba16db239ceb0ddeebd5f" translate="yes" xml:space="preserve">
          <source>This code prints &lt;code&gt;1 new tweet: (Read more from @horse_ebooks...)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6d78693e95ef2bffb056748f86ea7d4fd87f6784" translate="yes" xml:space="preserve">
          <source>This code prints &lt;code&gt;1 new tweet: horse_ebooks: of course, as you probably already know, people&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a4e90b820e3471ed9be465d87743c5461551a7f0" translate="yes" xml:space="preserve">
          <source>This code prints &lt;code&gt;Current location: (3, 5)&lt;/code&gt;. The values &lt;code&gt;&amp;amp;(3, 5)&lt;/code&gt; match the pattern &lt;code&gt;&amp;amp;(x, y)&lt;/code&gt;, so &lt;code&gt;x&lt;/code&gt; is the value &lt;code&gt;3&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; is the value &lt;code&gt;5&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fb3c413eeb04880ff8b53ff489dddef4151c97bb" translate="yes" xml:space="preserve">
          <source>This code prints &lt;code&gt;New article available! (Read more...)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4bdc1d17208e27666bda4fd318b994f6acf7818b" translate="yes" xml:space="preserve">
          <source>This code prints &lt;code&gt;The answer is: 12&lt;/code&gt;. We specify that the parameter &lt;code&gt;f&lt;/code&gt; in &lt;code&gt;do_twice&lt;/code&gt; is an &lt;code&gt;fn&lt;/code&gt; that takes one parameter of type &lt;code&gt;i32&lt;/code&gt; and returns an &lt;code&gt;i32&lt;/code&gt;. We can then call &lt;code&gt;f&lt;/code&gt; in the body of &lt;code&gt;do_twice&lt;/code&gt;. In &lt;code&gt;main&lt;/code&gt;, we can pass the function name &lt;code&gt;add_one&lt;/code&gt; as the first argument to &lt;code&gt;do_twice&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f51af940300a3743a5ab26b4b6248a93015d25fc" translate="yes" xml:space="preserve">
          <source>This code prints &lt;code&gt;one or two&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fa3fc2ca0fc1e2ca4079f6b9c2e26f148c6f028f" translate="yes" xml:space="preserve">
          <source>This code prints &lt;code&gt;one&lt;/code&gt; because the value in &lt;code&gt;x&lt;/code&gt; is 1. This syntax is useful when you want your code to take an action if it gets a particular concrete value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f76e20cf8d5177f5195a6770ae0f2388492d5a80" translate="yes" xml:space="preserve">
          <source>This code prints the following:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2da1adcf6ac7d40ff872dbb16e9f7a36210c0c52" translate="yes" xml:space="preserve">
          <source>This code should compile and produce the result we want when we use it with the &lt;code&gt;main&lt;/code&gt; function in Listing 10-20.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fc992e6806cb1bd5a9c534e91522711af45f4b36" translate="yes" xml:space="preserve">
          <source>This code should look generally familiar: a trait with one method and an associated type. The new part is &lt;code&gt;RHS=Self&lt;/code&gt;: this syntax is called &lt;em&gt;default type parameters&lt;/em&gt;. The &lt;code&gt;RHS&lt;/code&gt; generic type parameter (short for &amp;ldquo;right hand side&amp;rdquo;) defines the type of the &lt;code&gt;rhs&lt;/code&gt; parameter in the &lt;code&gt;add&lt;/code&gt; method. If we don&amp;rsquo;t specify a concrete type for &lt;code&gt;RHS&lt;/code&gt; when we implement the &lt;code&gt;Add&lt;/code&gt; trait, the type of &lt;code&gt;RHS&lt;/code&gt; will default to &lt;code&gt;Self&lt;/code&gt;, which will be the type we&amp;rsquo;re implementing &lt;code&gt;Add&lt;/code&gt; on.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9916bd76554811c91bac8fdab30ae1e7bf834537" translate="yes" xml:space="preserve">
          <source>This code still won&amp;rsquo;t work, but let&amp;rsquo;s check it again to get the next error that we need to address:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d27513508379ea6cd339c0bb4a46ef6e82c466b9" translate="yes" xml:space="preserve">
          <source>This code stores a list of integers in the variable &lt;code&gt;number_list&lt;/code&gt; and places the first number in the list in a variable named &lt;code&gt;largest&lt;/code&gt;. Then it iterates through all the numbers in the list, and if the current number is greater than the number stored in &lt;code&gt;largest&lt;/code&gt;, it replaces the number in that variable. However, if the current number is less than or equal to the largest number seen so far, the variable doesn&amp;rsquo;t change, and the code moves on to the next number in the list. After considering all the numbers in the list, &lt;code&gt;largest&lt;/code&gt; should hold the largest number, which in this case is 100.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="65e3fdd29c21c5766164366857eab04eba8f916b" translate="yes" xml:space="preserve">
          <source>This code will compile and will store the number of &lt;code&gt;Worker&lt;/code&gt; instances we specified as an argument to &lt;code&gt;ThreadPool::new&lt;/code&gt;. But we&amp;rsquo;re &lt;em&gt;still&lt;/em&gt; not processing the closure that we get in &lt;code&gt;execute&lt;/code&gt;. Let&amp;rsquo;s look at how to do that next.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="045fdd180c10e009660c1c81e0cc6eab5a5aa968" translate="yes" xml:space="preserve">
          <source>This code will compile just fine. For more about trait objects, refer to the section &lt;a href=&quot;ch17-02-trait-objects#using-trait-objects-that-allow-for-values-of-different-types&quot;&gt;&amp;ldquo;Using Trait Objects That Allow for Values of Different Types&amp;rdquo;&lt;/a&gt; in Chapter 17.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="457c8af0abaf5c3ca5e095102658cc6466fc1c3e" translate="yes" xml:space="preserve">
          <source>This code will compile without any errors. Note the &lt;code&gt;r#&lt;/code&gt; prefix on the function name in its definition as well as where the function is called in &lt;code&gt;main&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a4e6558f8bd1055ab8e1efd4008b36e362cb01bc" translate="yes" xml:space="preserve">
          <source>This code will completely ignore the value passed as the first argument, &lt;code&gt;3&lt;/code&gt;, and will print &lt;code&gt;This code only uses the y parameter: 4&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f597cb1c1231379b4a9ac9b16a64f6f09dac15f9" translate="yes" xml:space="preserve">
          <source>This code will now print &lt;code&gt;Default case, x = Some(5)&lt;/code&gt;. The pattern in the second match arm doesn&amp;rsquo;t introduce a new variable &lt;code&gt;y&lt;/code&gt; that would shadow the outer &lt;code&gt;y&lt;/code&gt;, meaning we can use the outer &lt;code&gt;y&lt;/code&gt; in the match guard. Instead of specifying the pattern as &lt;code&gt;Some(y)&lt;/code&gt;, which would have shadowed the outer &lt;code&gt;y&lt;/code&gt;, we specify &lt;code&gt;Some(n)&lt;/code&gt;. This creates a new variable &lt;code&gt;n&lt;/code&gt; that doesn&amp;rsquo;t shadow anything because there is no &lt;code&gt;n&lt;/code&gt; variable outside the &lt;code&gt;match&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1bcf93c595538a9e0c98606ec2aa75cae859981c" translate="yes" xml:space="preserve">
          <source>This code will print &lt;code&gt;Can't overwrite an existing customized value&lt;/code&gt; and then &lt;code&gt;setting is Some(5)&lt;/code&gt;. In the first match arm, we don&amp;rsquo;t need to match on or use the values inside either &lt;code&gt;Some&lt;/code&gt; variant, but we do need to test for the case when &lt;code&gt;setting_value&lt;/code&gt; and &lt;code&gt;new_setting_value&lt;/code&gt; are the &lt;code&gt;Some&lt;/code&gt; variant. In that case, we print why we&amp;rsquo;re not changing &lt;code&gt;setting_value&lt;/code&gt;, and it doesn&amp;rsquo;t get changed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="59fe6f0c2e0e4f24920973a91f227ffd825f4348" translate="yes" xml:space="preserve">
          <source>This code will print &lt;code&gt;Change the color to red 0, green 160, and blue 255&lt;/code&gt;. Try changing the value of &lt;code&gt;msg&lt;/code&gt; to see the code from the other arms run.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3c54f68158af593ed8370c89b1e792c808e333b9" translate="yes" xml:space="preserve">
          <source>This code will print &lt;code&gt;Hello, Macro! My name is Pancakes!&lt;/code&gt; when we&amp;rsquo;re done. The first step is to make a new library crate, like this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6ef0c24b1ac6e78f32662fb7a47aa078602f7661" translate="yes" xml:space="preserve">
          <source>This code will print &lt;code&gt;Some numbers: 2, 8, 32&lt;/code&gt;, and the values 4 and 16 will be ignored.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6e7f6cc166031d911beb7caaef0389c2805500c8" translate="yes" xml:space="preserve">
          <source>This code will print &lt;code&gt;{&quot;Blue&quot;: 25}&lt;/code&gt;. The original value of &lt;code&gt;10&lt;/code&gt; has been overwritten.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4c7854ef3442e5dc7384d2ebe52264fddb2a172b" translate="yes" xml:space="preserve">
          <source>This code will print &lt;code&gt;{&quot;world&quot;: 2, &quot;hello&quot;: 1, &quot;wonderful&quot;: 1}&lt;/code&gt;. The &lt;code&gt;or_insert&lt;/code&gt; method actually returns a mutable reference (&lt;code&gt;&amp;amp;mut V&lt;/code&gt;) to the value for this key. Here we store that mutable reference in the &lt;code&gt;count&lt;/code&gt; variable, so in order to assign to that value, we must first dereference &lt;code&gt;count&lt;/code&gt; using the asterisk (&lt;code&gt;*&lt;/code&gt;). The mutable reference goes out of scope at the end of the &lt;code&gt;for&lt;/code&gt; loop, so all of these changes are safe and allowed by the borrowing rules.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d2527fb52597f9416819ef1fc01a194d639282f6" translate="yes" xml:space="preserve">
          <source>This code will print each pair in an arbitrary order:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bacd4441a056463b6c76d4dcb3493a2106b165e0" translate="yes" xml:space="preserve">
          <source>This code will print the 18 bytes that make up this &lt;code&gt;String&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="df66479dcc3e1d9cca2a55caf3dadeea76d13542" translate="yes" xml:space="preserve">
          <source>This code will print the following:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6cf1c1dee0071b4d526326a9881c97e561ec0f1a" translate="yes" xml:space="preserve">
          <source>This code will result in the following error:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bd9279581006b04d3fb15d53d9a31240a9bda944" translate="yes" xml:space="preserve">
          <source>This code works just fine because we never bind &lt;code&gt;s&lt;/code&gt; to anything; it isn&amp;rsquo;t moved.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a72012f28327d683a9fda9d6b4835b6ec97dd74b" translate="yes" xml:space="preserve">
          <source>This code works the way the business wants it to now, but let&amp;rsquo;s say the data science team decides that we need to make some changes to the way we call the &lt;code&gt;simulated_expensive_calculation&lt;/code&gt; function in the future. To simplify the update when those changes happen, we want to refactor this code so it calls the &lt;code&gt;simulated_expensive_calculation&lt;/code&gt; function only once. We also want to cut the place where we&amp;rsquo;re currently unnecessarily calling the function twice without adding any other calls to that function in the process. That is, we don&amp;rsquo;t want to call it if the result isn&amp;rsquo;t needed, and we still want to call it only once.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="29594b80ae15e7f3a6760f8d699f1007a88ab197" translate="yes" xml:space="preserve">
          <source>This code would attempt to link with &lt;code&gt;libmy_c_library.so&lt;/code&gt; on unix-like systems and &lt;code&gt;my_c_library.dll&lt;/code&gt; on Windows at runtime, and panic if it can't find something to link to. Rust code could then use &lt;code&gt;my_c_function&lt;/code&gt; as if it were any other unsafe Rust function. Working with non-Rust languages and FFI is inherently unsafe, so wrappers are usually built around C APIs.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="94ac7a59ef0f9f139e040ad72861c14b2eb19308" translate="yes" xml:space="preserve">
          <source>This code would print &lt;code&gt;x = 5 and y = 10&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0be10b63965c309b87ed0545b477401b58dc21cb" translate="yes" xml:space="preserve">
          <source>This command creates an executable file in &lt;em&gt;target/debug/hello_cargo&lt;/em&gt; (or &lt;em&gt;target\debug\hello_cargo.exe&lt;/em&gt; on Windows) rather than in your current directory. You can run the executable with this command:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4dd02fcb167dbab5d0f3cc67c54c6c5da2a62c5e" translate="yes" xml:space="preserve">
          <source>This command gives you &lt;code&gt;rustfmt&lt;/code&gt; and &lt;code&gt;cargo-fmt&lt;/code&gt;, similar to how Rust gives you both &lt;code&gt;rustc&lt;/code&gt; and &lt;code&gt;cargo&lt;/code&gt;. To format any Cargo project, enter the following:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="616fc540cd704c55f34b7ddb4249c489ab431fea" translate="yes" xml:space="preserve">
          <source>This command ran all tests with &lt;code&gt;add&lt;/code&gt; in the name and filtered out the test named &lt;code&gt;one_hundred&lt;/code&gt;. Also note that the module in which a test appears becomes part of the test&amp;rsquo;s name, so we can run all the tests in a module by filtering on the module&amp;rsquo;s name.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8ea7582e38a836907de1d30ee5b58334fa20a196" translate="yes" xml:space="preserve">
          <source>This command runs only the tests in the &lt;em&gt;tests/integration_test.rs&lt;/em&gt; file.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0760093e6150870ee34facc6b7a5327edc5dc69d" translate="yes" xml:space="preserve">
          <source>This command will inform Cargo of your API token and store it locally in &lt;em&gt;~/.cargo/credentials&lt;/em&gt;. Note that this token is a &lt;em&gt;secret&lt;/em&gt;: do not share it with anyone else. If you do share it with anyone for any reason, you should revoke it and generate a new token on &lt;a href=&quot;https://crates.io/&quot;&gt;crates.io&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3f29dc82f5ad5c21f66ea4c65c4df005f9bfa118" translate="yes" xml:space="preserve">
          <source>This computes the integer &lt;code&gt;n&lt;/code&gt; such that &lt;code&gt;self = n * rhs + self.rem_euclid(rhs)&lt;/code&gt;, with &lt;code&gt;0 &amp;lt;= self.rem_euclid(rhs) &amp;lt; rhs&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="92466c99e75537fb86fdcb8b6177060d58e36e85" translate="yes" xml:space="preserve">
          <source>This computes the integer &lt;code&gt;n&lt;/code&gt; such that &lt;code&gt;self = n * rhs + self.rem_euclid(rhs)&lt;/code&gt;. In other words, the result is &lt;code&gt;self / rhs&lt;/code&gt; rounded to the integer &lt;code&gt;n&lt;/code&gt; such that &lt;code&gt;self &amp;gt;= n * rhs&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="30ff452f5fae3358ab149e5ae5cfa16c08f607d2" translate="yes" xml:space="preserve">
          <source>This concept&amp;mdash;of being concerned only with the messages a value responds to rather than the value&amp;rsquo;s concrete type&amp;mdash;is similar to the concept &lt;em&gt;duck typing&lt;/em&gt; in dynamically typed languages: if it walks like a duck and quacks like a duck, then it must be a duck! In the implementation of &lt;code&gt;run&lt;/code&gt; on &lt;code&gt;Screen&lt;/code&gt; in Listing 17-5, &lt;code&gt;run&lt;/code&gt; doesn&amp;rsquo;t need to know what the concrete type of each component is. It doesn&amp;rsquo;t check whether a component is an instance of a &lt;code&gt;Button&lt;/code&gt; or a &lt;code&gt;SelectBox&lt;/code&gt;, it just calls the &lt;code&gt;draw&lt;/code&gt; method on the component. By specifying &lt;code&gt;Box&amp;lt;dyn Draw&amp;gt;&lt;/code&gt; as the type of the values in the &lt;code&gt;components&lt;/code&gt; vector, we&amp;rsquo;ve defined &lt;code&gt;Screen&lt;/code&gt; to need values that we can call the &lt;code&gt;draw&lt;/code&gt; method on.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="918897f830b93edc22b990902ff69a6fc36b08cc" translate="yes" xml:space="preserve">
          <source>This conditional structure lets us support complex requirements. With the hardcoded values we have here, this example will print &lt;code&gt;Using purple as the background color&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3dcd38b0035fd15b13996ae1be8e3f24e8144a2a" translate="yes" xml:space="preserve">
          <source>This constant is defined to be &quot;1970-01-01 00:00:00 UTC&quot; on all systems with respect to the system clock. Using &lt;code&gt;duration_since&lt;/code&gt; on an existing &lt;a href=&quot;struct.systemtime&quot;&gt;&lt;code&gt;SystemTime&lt;/code&gt;&lt;/a&gt; instance can tell how far away from this point in time a measurement lies, and using &lt;code&gt;UNIX_EPOCH + duration&lt;/code&gt; can be used to create a &lt;a href=&quot;struct.systemtime&quot;&gt;&lt;code&gt;SystemTime&lt;/code&gt;&lt;/a&gt; instance to represent another fixed point in time.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b5d0e066df6c05d48b8ed4d894544fa1aeed7cdf" translate="yes" xml:space="preserve">
          <source>This constant is defined to be &quot;1970-01-01 00:00:00 UTC&quot; on all systems with respect to the system clock. Using &lt;code&gt;duration_since&lt;/code&gt; on an existing &lt;code&gt;SystemTime&lt;/code&gt; instance can tell how far away from this point in time a measurement lies, and using &lt;code&gt;UNIX_EPOCH + duration&lt;/code&gt; can be used to create a &lt;code&gt;SystemTime&lt;/code&gt; instance to represent another fixed point in time.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b2173ef48f94c265cfdd9db0c9cedd205cdc4005" translate="yes" xml:space="preserve">
          <source>This construct eliminates a lot of nesting that would be necessary if you used &lt;code&gt;loop&lt;/code&gt;, &lt;code&gt;if&lt;/code&gt;, &lt;code&gt;else&lt;/code&gt;, and &lt;code&gt;break&lt;/code&gt;, and it&amp;rsquo;s clearer. While a condition holds true, the code runs; otherwise, it exits the loop.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0f3921b041a98aaf2f8084439e4ed88136086a63" translate="yes" xml:space="preserve">
          <source>This construct is allowed because the first &lt;code&gt;spaces&lt;/code&gt; variable is a string type and the second &lt;code&gt;spaces&lt;/code&gt; variable, which is a brand-new variable that happens to have the same name as the first one, is a number type. Shadowing thus spares us from having to come up with different names, such as &lt;code&gt;spaces_str&lt;/code&gt; and &lt;code&gt;spaces_num&lt;/code&gt;; instead, we can reuse the simpler &lt;code&gt;spaces&lt;/code&gt; name. However, if we try to use &lt;code&gt;mut&lt;/code&gt; for this, as shown here, we&amp;rsquo;ll get a compile-time error:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2fc6477635d5d363ee444b003b473b1635177727" translate="yes" xml:space="preserve">
          <source>This constructor is unsafe because we cannot guarantee that the data pointed to by &lt;code&gt;pointer&lt;/code&gt; is pinned, meaning that the data will not be moved or its storage invalidated until it gets dropped. If the constructed &lt;code&gt;Pin&amp;lt;P&amp;gt;&lt;/code&gt; does not guarantee that the data &lt;code&gt;P&lt;/code&gt; points to is pinned, that is a violation of the API contract and may lead to undefined behavior in later (safe) operations.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ff43397602787e15a0f1ce39d92c367ec0e4e2ba" translate="yes" xml:space="preserve">
          <source>This constructor will panic if &lt;code&gt;secs&lt;/code&gt; is not finite, negative or overflows &lt;code&gt;Duration&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="62c6e72ea916575b1c7e9925b7cd6a1ec78f970b" translate="yes" xml:space="preserve">
          <source>This constructor will panic if the carry from the nanoseconds overflows the seconds counter.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6b22e102a899811cfc691dccd223a5bfd8615f73" translate="yes" xml:space="preserve">
          <source>This consumes the &lt;code&gt;String&lt;/code&gt; on the left-hand side and re-uses its buffer (growing it if necessary). This is done to avoid allocating a new &lt;code&gt;String&lt;/code&gt; and copying the entire contents on every operation, which would lead to &lt;code&gt;O(n^2)&lt;/code&gt; running time when building an &lt;code&gt;n&lt;/code&gt;-byte string by repeated concatenation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9c1a59da820eab802e08d64caefd05fd88b5910a" translate="yes" xml:space="preserve">
          <source>This consumes the &lt;code&gt;String&lt;/code&gt;, so we do not need to copy its contents.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bdf3d0a305b0dd41c0720025809f7bbdfc2e29a7" translate="yes" xml:space="preserve">
          <source>This conversion allocates a new error with a simple representation of error kind.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="680616b748f55e8f2a3a0b7bc442fa697101f3ab" translate="yes" xml:space="preserve">
          <source>This conversion allocates on the heap and performs a copy of &lt;code&gt;s&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9a31c836c91541651df449cd7fae82a0fb324fe3" translate="yes" xml:space="preserve">
          <source>This conversion allocates on the heap and performs a copy of &lt;code&gt;slice&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="191fbbeba587abac9c4a996c422eb2e1a86f8da6" translate="yes" xml:space="preserve">
          <source>This conversion creates a &lt;a href=&quot;../net/enum.socketaddr#variant.V4&quot;&gt;&lt;code&gt;SocketAddr::V4&lt;/code&gt;&lt;/a&gt; for a &lt;a href=&quot;../net/enum.ipaddr#variant.V4&quot;&gt;&lt;code&gt;IpAddr::V4&lt;/code&gt;&lt;/a&gt; and creates a &lt;a href=&quot;../net/enum.socketaddr#variant.V6&quot;&gt;&lt;code&gt;SocketAddr::V6&lt;/code&gt;&lt;/a&gt; for a &lt;a href=&quot;../net/enum.ipaddr#variant.V6&quot;&gt;&lt;code&gt;IpAddr::V6&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e3e202dba3c3f87c15f9baf72668c6b89f20fb13" translate="yes" xml:space="preserve">
          <source>This conversion creates a &lt;a href=&quot;enum.socketaddr#variant.V4&quot;&gt;&lt;code&gt;SocketAddr::V4&lt;/code&gt;&lt;/a&gt; for a &lt;a href=&quot;enum.ipaddr#variant.V4&quot;&gt;&lt;code&gt;IpAddr::V4&lt;/code&gt;&lt;/a&gt; and creates a &lt;a href=&quot;enum.socketaddr#variant.V6&quot;&gt;&lt;code&gt;SocketAddr::V6&lt;/code&gt;&lt;/a&gt; for a &lt;a href=&quot;enum.ipaddr#variant.V6&quot;&gt;&lt;code&gt;IpAddr::V6&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3b1a65936a10e1c346d064991eab656396fb2bba" translate="yes" xml:space="preserve">
          <source>This conversion currently should not allocate memory, but this behavior is not guaranteed on all platforms or in all future versions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e7f2cebd3b32b1fc620100acfba14583ac5721f8" translate="yes" xml:space="preserve">
          <source>This conversion does not allocate on the heap and happens in place.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ece3abafa7c5e7855afc6b2c712b92113a0c3cfa" translate="yes" xml:space="preserve">
          <source>This conversion does not allocate or copy memory.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eb0a6b0407963e31db76813c54686486ddeb6e67" translate="yes" xml:space="preserve">
          <source>This conversion may entail doing a check for UTF-8 validity.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a2f146b8b2fc9fbff68e3aacb1296a0b784db40b" translate="yes" xml:space="preserve">
          <source>This converts the weak pointer into a raw pointer, preserving the original weak count. It can be turned back into the &lt;code&gt;Weak&amp;lt;T&amp;gt;&lt;/code&gt; with &lt;a href=&quot;struct.weak#method.from_raw&quot;&gt;&lt;code&gt;from_raw&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0c699db8a5191d953bd2f9a766d34a17f9fc7bd1" translate="yes" xml:space="preserve">
          <source>This corresponds to the type returned from a generator either with a &lt;code&gt;return&lt;/code&gt; statement or implicitly as the last expression of a generator literal. For example futures would use this as &lt;code&gt;Result&amp;lt;T, E&amp;gt;&lt;/code&gt; as it represents a completed future.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4049b3c18034165d976b921c99656187a99b1c48" translate="yes" xml:space="preserve">
          <source>This could be called as &lt;code&gt;&amp;lt;Foo as Foo&amp;gt;::foo()&lt;/code&gt;, which would not be able to pick an implementation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="287539a4f23b39a26818b82e9ae17d404cfd326d" translate="yes" xml:space="preserve">
          <source>This could be caused by a typo. Did you misspell the macro's name?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="13b235947bdbb45d737ce6790102efc941982f83" translate="yes" xml:space="preserve">
          <source>This crate primarily contains a &lt;a href=&quot;https://doc.rust-lang.org/proc_macro/struct.TokenStream.html&quot;&gt;&lt;code&gt;TokenStream&lt;/code&gt;&lt;/a&gt; type. Procedural macros operate over &lt;em&gt;token streams&lt;/em&gt; instead of AST nodes, which is a far more stable interface over time for both the compiler and for procedural macros to target. A &lt;em&gt;token stream&lt;/em&gt; is roughly equivalent to &lt;code&gt;Vec&amp;lt;TokenTree&amp;gt;&lt;/code&gt; where a &lt;code&gt;TokenTree&lt;/code&gt; can roughly be thought of as lexical token. For example &lt;code&gt;foo&lt;/code&gt; is an &lt;code&gt;Ident&lt;/code&gt; token, &lt;code&gt;.&lt;/code&gt; is a &lt;code&gt;Punct&lt;/code&gt; token, and &lt;code&gt;1.2&lt;/code&gt; is a &lt;code&gt;Literal&lt;/code&gt; token. The &lt;code&gt;TokenStream&lt;/code&gt; type, unlike &lt;code&gt;Vec&amp;lt;TokenTree&amp;gt;&lt;/code&gt;, is cheap to clone.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cff1a339d3f6091f32453655f9ee1f32c7930920" translate="yes" xml:space="preserve">
          <source>This creates another pointer to the same inner value, increasing the strong reference count.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c793b99248db7ed16f6d7097d8baba33c4688bf2" translate="yes" xml:space="preserve">
          <source>This defines a trait with two methods. All values that have &lt;a href=&quot;implementations&quot;&gt;implementations&lt;/a&gt; of this trait while the trait is in scope can have their &lt;code&gt;draw&lt;/code&gt; and &lt;code&gt;bounding_box&lt;/code&gt; methods called.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1d48ec195193e5a8a6ddc6d7306e5931fc440ce0" translate="yes" xml:space="preserve">
          <source>This definition is similar to the custom derive macro&amp;rsquo;s signature: we receive the tokens that are inside the parentheses and return the code we wanted to generate.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7ec7ae52304bec8c18c92988cc904eba30640fe1" translate="yes" xml:space="preserve">
          <source>This definition should now make more sense to you. As you can see, &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt; is an enum that is generic over type &lt;code&gt;T&lt;/code&gt; and has two variants: &lt;code&gt;Some&lt;/code&gt;, which holds one value of type &lt;code&gt;T&lt;/code&gt;, and a &lt;code&gt;None&lt;/code&gt; variant that doesn&amp;rsquo;t hold any value. By using the &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt; enum, we can express the abstract concept of having an optional value, and because &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt; is generic, we can use this abstraction no matter what the type of the optional value is.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a1dc77bf501a21c3fcf8fcfdb984f36618d4b9d8" translate="yes" xml:space="preserve">
          <source>This demonstrates that we&amp;rsquo;re now using standard output for successful output and standard error for error output as appropriate.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0501267bf2be740a305fdf189b227a4c7486d27e" translate="yes" xml:space="preserve">
          <source>This distinction would also exist in an interpreter. Static checks like syntactic analysis, type checking, and lints should happen before the program is executed regardless of when it is executed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f074ad4712bf36f567466c2e78802eda538edf52" translate="yes" xml:space="preserve">
          <source>This documentation describes a number of methods and trait implementations on the &lt;code&gt;char&lt;/code&gt; type. For technical reasons, there is additional, separate documentation in &lt;a href=&quot;char/index&quot;&gt;the &lt;code&gt;std::char&lt;/code&gt; module&lt;/a&gt; as well.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="68839ac29f4116303cf30db2371868d96097990a" translate="yes" xml:space="preserve">
          <source>This does call the argument's implementation of &lt;a href=&quot;../ops/trait.drop&quot;&gt;&lt;code&gt;Drop&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cc3143ca0c8ed5c4ad51a7f5632b38d278a744be" translate="yes" xml:space="preserve">
          <source>This does not preserve ordering, but is O(1).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="302cbd1c584e8c39bda1206e23be2bed7460cc52" translate="yes" xml:space="preserve">
          <source>This does not take ownership of the original allocation and requires no resource management later, but you must not use the pointer after its lifetime.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7ec03adb1087f5abb7a8507c877e74407679b28c" translate="yes" xml:space="preserve">
          <source>This doesn't actually allocate if &lt;code&gt;T&lt;/code&gt; is zero-sized.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1a27813265527dd550d73a565f67475ec4a26516" translate="yes" xml:space="preserve">
          <source>This effectively does nothing for types which implement &lt;code&gt;Copy&lt;/code&gt;, e.g. integers. Such values are copied and &lt;em&gt;then&lt;/em&gt; moved into the function, so the value persists after this function call.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eb1f652575dd2244737e0203d7e6859c386e1f92" translate="yes" xml:space="preserve">
          <source>This enables some memory layout optimization. For example, &lt;code&gt;Option&amp;lt;NonZeroI128&amp;gt;&lt;/code&gt; is the same size as &lt;code&gt;i128&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f67f6cc0c2c10dc19997b3839443098a644f1d26" translate="yes" xml:space="preserve">
          <source>This enables some memory layout optimization. For example, &lt;code&gt;Option&amp;lt;NonZeroI16&amp;gt;&lt;/code&gt; is the same size as &lt;code&gt;i16&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="734061adf87b0795fad2886322ea47c0aec2f2ad" translate="yes" xml:space="preserve">
          <source>This enables some memory layout optimization. For example, &lt;code&gt;Option&amp;lt;NonZeroI32&amp;gt;&lt;/code&gt; is the same size as &lt;code&gt;i32&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="00340c6c435ce7c1fdb4cf194be81cf07905d3dd" translate="yes" xml:space="preserve">
          <source>This enables some memory layout optimization. For example, &lt;code&gt;Option&amp;lt;NonZeroI64&amp;gt;&lt;/code&gt; is the same size as &lt;code&gt;i64&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="278e3b6e04cd3eac83950c68db7f2e8e510eb775" translate="yes" xml:space="preserve">
          <source>This enables some memory layout optimization. For example, &lt;code&gt;Option&amp;lt;NonZeroI8&amp;gt;&lt;/code&gt; is the same size as &lt;code&gt;i8&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d6a41567af1e9968e9c90e92ec21b8804316cfe8" translate="yes" xml:space="preserve">
          <source>This enables some memory layout optimization. For example, &lt;code&gt;Option&amp;lt;NonZeroIsize&amp;gt;&lt;/code&gt; is the same size as &lt;code&gt;isize&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cf2e6ed40009c7af3e4c82c9a64e0f2f0797bce2" translate="yes" xml:space="preserve">
          <source>This enables some memory layout optimization. For example, &lt;code&gt;Option&amp;lt;NonZeroU128&amp;gt;&lt;/code&gt; is the same size as &lt;code&gt;u128&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="76da8b2ba60cec40f8f5e62e107f1dbcb755bbbb" translate="yes" xml:space="preserve">
          <source>This enables some memory layout optimization. For example, &lt;code&gt;Option&amp;lt;NonZeroU16&amp;gt;&lt;/code&gt; is the same size as &lt;code&gt;u16&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ccbf5b5bf97bc9198c28f18b82543d27c5b27285" translate="yes" xml:space="preserve">
          <source>This enables some memory layout optimization. For example, &lt;code&gt;Option&amp;lt;NonZeroU32&amp;gt;&lt;/code&gt; is the same size as &lt;code&gt;u32&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="538d2876995cecf5e64928ddfeb01ab1a800bbde" translate="yes" xml:space="preserve">
          <source>This enables some memory layout optimization. For example, &lt;code&gt;Option&amp;lt;NonZeroU64&amp;gt;&lt;/code&gt; is the same size as &lt;code&gt;u64&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d0129491a9c802e31402a256b2ed3248526999bd" translate="yes" xml:space="preserve">
          <source>This enables some memory layout optimization. For example, &lt;code&gt;Option&amp;lt;NonZeroU8&amp;gt;&lt;/code&gt; is the same size as &lt;code&gt;u8&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="444ef8a1b6149aa40edb45ac918d2fcc6dd0e6a5" translate="yes" xml:space="preserve">
          <source>This enables some memory layout optimization. For example, &lt;code&gt;Option&amp;lt;NonZeroUsize&amp;gt;&lt;/code&gt; is the same size as &lt;code&gt;usize&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="05b9c29faea2a683215e0b23ceda6c29cb84253c" translate="yes" xml:space="preserve">
          <source>This enum can contain either an &lt;a href=&quot;struct.ipv4addr&quot;&gt;&lt;code&gt;Ipv4Addr&lt;/code&gt;&lt;/a&gt; or an &lt;a href=&quot;struct.ipv6addr&quot;&gt;&lt;code&gt;Ipv6Addr&lt;/code&gt;&lt;/a&gt;, see their respective documentation for more details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="760b8f1ec007bba813777fc9f56dd941c92b8841" translate="yes" xml:space="preserve">
          <source>This enum has four variants with different types:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ced6caa3ad1703b55bcd5c2e59bf560b6691cb01" translate="yes" xml:space="preserve">
          <source>This enum has the same role as &lt;a href=&quot;../primitive.never&quot;&gt;the &lt;code&gt;!&lt;/code&gt; &amp;ldquo;never&amp;rdquo; type&lt;/a&gt;, which is unstable in this version of Rust. When &lt;code&gt;!&lt;/code&gt; is stabilized, we plan to make &lt;code&gt;Infallible&lt;/code&gt; a type alias to it:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6ee104c9c1676af30fcb1ff39c18e2ed9e455f59" translate="yes" xml:space="preserve">
          <source>This enum is returned from the &lt;code&gt;Generator::resume&lt;/code&gt; method and indicates the possible return values of a generator. Currently this corresponds to either a suspension point (&lt;code&gt;Yielded&lt;/code&gt;) or a termination point (&lt;code&gt;Complete&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1703fcf1fccea6643fefc20e49e4c80e84f95499" translate="yes" xml:space="preserve">
          <source>This enumeration is the list of possible errors that made &lt;a href=&quot;struct.receiver#method.recv_timeout&quot;&gt;&lt;code&gt;recv_timeout&lt;/code&gt;&lt;/a&gt; unable to return data when called. This can occur with both a &lt;a href=&quot;fn.channel&quot;&gt;&lt;code&gt;channel&lt;/code&gt;&lt;/a&gt; and a &lt;a href=&quot;fn.sync_channel&quot;&gt;&lt;code&gt;sync_channel&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cbe05c4f5a229c7e20d58b03f49460f0df3da02f" translate="yes" xml:space="preserve">
          <source>This enumeration is the list of the possible error outcomes for the &lt;a href=&quot;struct.syncsender#method.try_send&quot;&gt;&lt;code&gt;try_send&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6dc63139830daa8f080f2bf636d153d6ed98ad21" translate="yes" xml:space="preserve">
          <source>This enumeration is the list of the possible reasons that &lt;a href=&quot;struct.receiver#method.try_recv&quot;&gt;&lt;code&gt;try_recv&lt;/code&gt;&lt;/a&gt; could not return data when called. This can occur with both a &lt;a href=&quot;fn.channel&quot;&gt;&lt;code&gt;channel&lt;/code&gt;&lt;/a&gt; and a &lt;a href=&quot;fn.sync_channel&quot;&gt;&lt;code&gt;sync_channel&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c1093396faf4de8ad558d41dcf5187f56b3280a8" translate="yes" xml:space="preserve">
          <source>This error also frequently arises with iteration:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="94b9a993ad00befb67d90a954bbd93d2df863b1b" translate="yes" xml:space="preserve">
          <source>This error appears when the curly braces contain an identifier which doesn't match with any of the type parameters or the string &lt;code&gt;Self&lt;/code&gt;. This might happen if you misspelled a type parameter, or if you intended to use literal curly braces. If it is the latter, escape the curly braces with a second curly brace of the same type; e.g., a literal &lt;code&gt;{&lt;/code&gt; is &lt;code&gt;{{&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="584182c12fbcdc7236283566d4fe892f8514a84a" translate="yes" xml:space="preserve">
          <source>This error appears when the curly braces do not contain an identifier. Please add one of the same name as a type parameter. If you intended to use literal braces, use &lt;code&gt;{{&lt;/code&gt; and &lt;code&gt;}}&lt;/code&gt; to escape them.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0250b09263b0cf211b3144438a4935e1e43d799a" translate="yes" xml:space="preserve">
          <source>This error can be fixed by changing &lt;code&gt;demo&lt;/code&gt; so that the destructor does not run while the string-data is borrowed; for example by taking &lt;code&gt;S&lt;/code&gt; by reference:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cf00137495add2df4af51c96509efb72f8de11bd" translate="yes" xml:space="preserve">
          <source>This error can be fixed by creating a reference to the fields of a struct, enum, or tuple using the &lt;code&gt;ref&lt;/code&gt; keyword:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0dff7bc132443224671e948d9ffe4c7e1624395f" translate="yes" xml:space="preserve">
          <source>This error can be fixed by fully reinitializing the structure in question:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2f0e10eb9c6b47c452a0e1f4fb8a082452a2d703" translate="yes" xml:space="preserve">
          <source>This error code indicates a mismatch between the lifetimes appearing in the function signature (i.e., the parameter types and the return type) and the data-flow found in the function body.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="21caa47590bc7c04cd88dfba7269f8c13368e7a3" translate="yes" xml:space="preserve">
          <source>This error generally appears when two items with the same name are imported into a module. Here, the &lt;code&gt;foo&lt;/code&gt; functions are imported and reexported from the &lt;code&gt;collider&lt;/code&gt; module and therefore, when we're using &lt;code&gt;collider::foo()&lt;/code&gt;, both functions collide.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5926fa6825473ce8b14051d29bff524913459d93" translate="yes" xml:space="preserve">
          <source>This error indicates a violation of one of Rust's orphan rules for trait implementations. The rule concerns the use of type parameters in an implementation of a foreign trait (a trait defined in another crate), and states that type parameters must be &quot;covered&quot; by a local type. To understand what this means, it is perhaps easiest to consider a few examples.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="62c66f8f6d53d3993670c86c1f09308676282e5b" translate="yes" xml:space="preserve">
          <source>This error indicates a violation of one of Rust's orphan rules for trait implementations. The rule prohibits any implementation of a foreign trait (a trait defined in another crate) where</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="447a5e9fa4c8cf25c5cd5302f4311b3fbd33ec5e" translate="yes" xml:space="preserve">
          <source>This error indicates that a &lt;code&gt;#[lang = &quot;..&quot;]&lt;/code&gt; attribute was placed on the wrong type of item.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="04b6c6e07e059a0181ccbe377eeeabdfa436d081" translate="yes" xml:space="preserve">
          <source>This error indicates that a &lt;code&gt;#[non_exhaustive]&lt;/code&gt; attribute was incorrectly placed on something other than a struct or enum.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7022f431bbd32573cf9101aaa229f54136c6e815" translate="yes" xml:space="preserve">
          <source>This error indicates that a &lt;code&gt;#[repr(..)]&lt;/code&gt; attribute was placed on an unsupported item.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ca9d1588d95295137d9296e3cc73990ee881720a" translate="yes" xml:space="preserve">
          <source>This error indicates that a binary assignment operator like &lt;code&gt;+=&lt;/code&gt; or &lt;code&gt;^=&lt;/code&gt; was applied to a type that doesn't support it. For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="942586ad68f246da14ea422c40de5e3f0b9face6" translate="yes" xml:space="preserve">
          <source>This error indicates that a incorrect visibility restriction was specified.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0ed5220e5bb81a5a254920c1211412f9ef92a217" translate="yes" xml:space="preserve">
          <source>This error indicates that a lifetime is missing from a type. If it is an error inside a function signature, the problem may be with failing to adhere to the lifetime elision rules (see below).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="163c07e3082230bfd9dd310e7a36d455707b90b1" translate="yes" xml:space="preserve">
          <source>This error indicates that a mutable variable is being used while it is still captured by a closure. Because the closure has borrowed the variable, it is not available for use until the closure goes out of scope.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f276e617d109dc1e2831917bc3e9ec17e8a46ef1" translate="yes" xml:space="preserve">
          <source>This error indicates that a pattern for a struct fails to specify a sub-pattern for every one of the struct's fields. Ensure that each field from the struct's definition is mentioned in the pattern, or use &lt;code&gt;..&lt;/code&gt; to ignore unwanted fields.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cf2673db078cb233aef2cf4d975d04209851d888" translate="yes" xml:space="preserve">
          <source>This error indicates that a pointer to a trait type cannot be implicitly dereferenced by a pattern. Every trait defines a type, but because the size of trait implementors isn't fixed, this type has no compile-time size. Therefore, all accesses to trait types must be through pointers. If you encounter this error you should try to avoid dereferencing the pointer.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="828017bc333a648d7ba2ba05b6d8defb66538498" translate="yes" xml:space="preserve">
          <source>This error indicates that a struct pattern attempted to extract a non-existent field from a struct. Struct fields are identified by the name used before the colon &lt;code&gt;:&lt;/code&gt; so struct patterns should resemble the declaration of the struct type being matched.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8fe4ff510197fbaaaaa06c8b33b203c1e4dc7f1a" translate="yes" xml:space="preserve">
          <source>This error indicates that a temporary value is being dropped while a borrow is still in active use.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="29f636e2d8527491e9c968890f3142a6d2d79a49" translate="yes" xml:space="preserve">
          <source>This error indicates that a type or lifetime parameter has been declared but not actually used. Here is an example that demonstrates the error:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="021899c7481112f5b1115194dfebb6c6433d75e6" translate="yes" xml:space="preserve">
          <source>This error indicates that a variable usage inside an inner function is invalid because the variable comes from a dynamic environment. Inner functions do not have access to their containing environment.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ee2b7895f62fe245340d50c3f8c134d38d139ea0" translate="yes" xml:space="preserve">
          <source>This error indicates that an &lt;code&gt;#[inline(..)]&lt;/code&gt; attribute was incorrectly placed on something other than a function or method.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b354ce81cf352c1f70206a250c5709ec2f51795d" translate="yes" xml:space="preserve">
          <source>This error indicates that an attempted implementation of a trait method has the wrong number of function parameters.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e0c31ba5c6bda555cd8ea81a836bf176c496c77b" translate="yes" xml:space="preserve">
          <source>This error indicates that an attempted implementation of a trait method has the wrong number of type or const parameters.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b75e5fdc31d31d1c4e71b1b39da466c4c14335c3" translate="yes" xml:space="preserve">
          <source>This error indicates that an empty match expression is invalid because the type it is matching on is non-empty (there exist values of this type). In safe code it is impossible to create an instance of an empty type, so empty match expressions are almost never desired. This error is typically fixed by adding one or more cases to the match expression.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aa5d0ed3544dd02116d741311bf5dc31cbf1e877" translate="yes" xml:space="preserve">
          <source>This error indicates that during an attempt to build a struct or struct-like enum variant, one of the fields was not provided. Erroneous code example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3e8ed17cc79bcd070351fc2c779882f025c94d0d" translate="yes" xml:space="preserve">
          <source>This error indicates that during an attempt to build a struct or struct-like enum variant, one of the fields was specified more than once. Erroneous code example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="184a0c9f21c2159367397ab03b1af11810a4b7a9" translate="yes" xml:space="preserve">
          <source>This error indicates that next we need to create an associated function named &lt;code&gt;new&lt;/code&gt; for &lt;code&gt;ThreadPool&lt;/code&gt;. We also know that &lt;code&gt;new&lt;/code&gt; needs to have one parameter that can accept &lt;code&gt;4&lt;/code&gt; as an argument and should return a &lt;code&gt;ThreadPool&lt;/code&gt; instance. Let&amp;rsquo;s implement the simplest &lt;code&gt;new&lt;/code&gt; function that will have those characteristics:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2dad13e650883f25d2104ae52eca1fef407497bf" translate="yes" xml:space="preserve">
          <source>This error indicates that not enough type parameters were found in a type or trait.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ca21a72c98d3df2023442d374a3dadbb098c691b" translate="yes" xml:space="preserve">
          <source>This error indicates that some types or traits depend on each other and therefore cannot be constructed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="04671a501f0a2d188e9fcc11f1a02fbc634b9fe6" translate="yes" xml:space="preserve">
          <source>This error indicates that the bindings in a match arm would require a value to be moved into more than one location, thus violating unique ownership. Code like the following is invalid as it requires the entire &lt;code&gt;Option&amp;lt;String&amp;gt;&lt;/code&gt; to be moved into a variable called &lt;code&gt;op_string&lt;/code&gt; while simultaneously requiring the inner &lt;code&gt;String&lt;/code&gt; to be moved into a variable called &lt;code&gt;s&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e6ec80fb058ca19fb5e7892d541e007d08b04d8f" translate="yes" xml:space="preserve">
          <source>This error indicates that the compiler cannot guarantee a matching pattern for one or more possible inputs to a match expression. Guaranteed matches are required in order to assign values to match expressions, or alternatively, determine the flow of execution. Erroneous code example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="561856cda5e25152013aec070f3d54bab7aa1df8" translate="yes" xml:space="preserve">
          <source>This error indicates that the compiler found multiple functions with the &lt;code&gt;#[main]&lt;/code&gt; attribute. This is an error because there must be a unique entry point into a Rust program. Example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5bea3375dcc80f531e3766516bd9f6d7115c2ccf" translate="yes" xml:space="preserve">
          <source>This error indicates that the compiler found multiple functions with the &lt;code&gt;#[start]&lt;/code&gt; attribute. This is an error because there must be a unique entry point into a Rust program. Example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f36d8b8d1d8446198729b807cb2a4a2419af004e" translate="yes" xml:space="preserve">
          <source>This error indicates that the compiler was unable to sensibly evaluate an constant expression that had to be evaluated. Attempting to divide by 0 or causing integer overflow are two ways to induce this error. For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6a1e2255560b86b2d9499ff55662d827b519b332" translate="yes" xml:space="preserve">
          <source>This error indicates that the numeric value for the method being passed exists but the type of the numeric value or binding could not be identified.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="148347b598d68fa69c31f92c37c1da55d76c0063" translate="yes" xml:space="preserve">
          <source>This error indicates that the struct, enum or enum variant cannot be instantiated from outside of the defining crate as it has been marked as &lt;code&gt;non_exhaustive&lt;/code&gt; and as such more fields/variants may be added in future that could cause adverse side effects for this code.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fcad2c51ea5b37a57bae2601eed616fe3e726b2e" translate="yes" xml:space="preserve">
          <source>This error indicates that the struct, enum or enum variant must be matched non-exhaustively as it has been marked as &lt;code&gt;non_exhaustive&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="37c7a2a28ca533246457e808e16c999f3f050492" translate="yes" xml:space="preserve">
          <source>This error indicates that there is a mismatch between generic parameters and impl Trait parameters in a trait declaration versus its impl.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="51a28020fb3170ca33d27d23beb6ff4c2ae9ce5c" translate="yes" xml:space="preserve">
          <source>This error indicates that too many type parameters were found in a type or trait.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="52a40c02e70b32e434b6bbe135867f805601219b" translate="yes" xml:space="preserve">
          <source>This error indicates that type inference did not result in one unique possible type, and extra information is required. In most cases this can be provided by adding a type annotation. Sometimes you need to specify a generic type parameter manually.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4c3b94702358e1162bf8effa04b8b4b7e098714c" translate="yes" xml:space="preserve">
          <source>This error indicates that you are trying to borrow a variable as mutable when it has already been borrowed as immutable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5d266dd2a168d28b90102ea5f40d828bae3909b4" translate="yes" xml:space="preserve">
          <source>This error indicates the use of a loop keyword (&lt;code&gt;break&lt;/code&gt; or &lt;code&gt;continue&lt;/code&gt;) inside a closure but outside of any loop. Erroneous code example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a14d78d3da966b89fe122674705e062ddb4c4c41" translate="yes" xml:space="preserve">
          <source>This error indicates the use of a loop keyword (&lt;code&gt;break&lt;/code&gt; or &lt;code&gt;continue&lt;/code&gt;) outside of a loop. Without a loop to break out of or continue in, no sensible action can be taken. Erroneous code example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1b9e91e9541342a47e9d0b1ac521444fa8e68a88" translate="yes" xml:space="preserve">
          <source>This error is created by the &lt;a href=&quot;struct.cstr#method.from_bytes_with_nul&quot;&gt;&lt;code&gt;from_bytes_with_nul&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;struct.cstr&quot;&gt;&lt;code&gt;CStr&lt;/code&gt;&lt;/a&gt;. See its documentation for more.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7f88231c82f77383d008a182af5374b0e8d20578" translate="yes" xml:space="preserve">
          <source>This error is created by the &lt;a href=&quot;struct.cstring#method.new&quot;&gt;&lt;code&gt;new&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;struct.cstring&quot;&gt;&lt;code&gt;CString&lt;/code&gt;&lt;/a&gt;. See its documentation for more.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e66887716e5bc2fbc972f3ffc3450120cd6c7b7e" translate="yes" xml:space="preserve">
          <source>This error is fairly cryptic because the problem is fairly cryptic. To call a &lt;code&gt;FnOnce&lt;/code&gt; closure that is stored in a &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; (which is what our &lt;code&gt;Job&lt;/code&gt; type alias is), the closure needs to move itself &lt;em&gt;out&lt;/em&gt; of the &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; because the closure takes ownership of &lt;code&gt;self&lt;/code&gt; when we call it. In general, Rust doesn&amp;rsquo;t allow us to move a value out of a &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; because Rust doesn&amp;rsquo;t know how big the value inside the &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; will be: recall in Chapter 15 that we used &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; precisely because we had something of an unknown size that we wanted to store in a &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; to get a value of a known size.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ac1c7bfe67c403881a0d5e5220daf766f18ab15b" translate="yes" xml:space="preserve">
          <source>This error is used as the error type for the &lt;a href=&quot;../str/trait.fromstr&quot;&gt;&lt;code&gt;FromStr&lt;/code&gt;&lt;/a&gt; implementation for &lt;a href=&quot;../primitive.f32&quot;&gt;&lt;code&gt;f32&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../primitive.f64&quot;&gt;&lt;code&gt;f64&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a413bd30b0780353f6f0cb9ec7112a60510b4c1b" translate="yes" xml:space="preserve">
          <source>This error is used as the error type for the &lt;a href=&quot;../str/trait.fromstr&quot;&gt;&lt;code&gt;FromStr&lt;/code&gt;&lt;/a&gt; implementation for &lt;a href=&quot;enum.ipaddr&quot;&gt;&lt;code&gt;IpAddr&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;struct.ipv4addr&quot;&gt;&lt;code&gt;Ipv4Addr&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;struct.ipv6addr&quot;&gt;&lt;code&gt;Ipv6Addr&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;enum.socketaddr&quot;&gt;&lt;code&gt;SocketAddr&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;struct.socketaddrv4&quot;&gt;&lt;code&gt;SocketAddrV4&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;struct.socketaddrv6&quot;&gt;&lt;code&gt;SocketAddrV6&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dbd5a817ebd0158354fc9b6704f3a0f2b0fc517f" translate="yes" xml:space="preserve">
          <source>This error is used as the error type for the &lt;code&gt;from_str_radix()&lt;/code&gt; functions on the primitive integer types, such as &lt;a href=&quot;../primitive.i8#method.from_str_radix&quot;&gt;&lt;code&gt;i8::from_str_radix&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="022d759f57798a79780636ae9f03f6fedf32312c" translate="yes" xml:space="preserve">
          <source>This error lets us know that either we&amp;rsquo;re passing something to &lt;code&gt;Screen&lt;/code&gt; we didn&amp;rsquo;t mean to pass and we should pass a different type or we should implement &lt;code&gt;Draw&lt;/code&gt; on &lt;code&gt;String&lt;/code&gt; so that &lt;code&gt;Screen&lt;/code&gt; is able to call &lt;code&gt;draw&lt;/code&gt; on it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7089a49860a1eeefd308980067bc3b5e6f3e5841" translate="yes" xml:space="preserve">
          <source>This error lets you know that Rust has this constant defined more precisely and that your program would be more correct if you used the constant instead. You would then change your code to use the &lt;code&gt;PI&lt;/code&gt; constant. The following code doesn&amp;rsquo;t result in any errors or warnings from Clippy:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7527f99b3dbab9d3281da26cc0de240205ca3ed7" translate="yes" xml:space="preserve">
          <source>This error may also commonly be found when working with unsafe code. For example, when using raw pointers one may wish to specify the lifetime for which the pointed-at data is valid. An initial attempt (below) causes this error:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1e7204b5ea49e32896ab0ba12a29a6e3937bc0f3" translate="yes" xml:space="preserve">
          <source>This error means that an attempt was made to match a struct type enum variant as a non-struct type:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c1988ee636e2a4d68092372fb6c89de2473339d3" translate="yes" xml:space="preserve">
          <source>This error means that an incorrect number of generic arguments were provided:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="368e8d1bf22974707354d4d21e3f6ab34ed1757e" translate="yes" xml:space="preserve">
          <source>This error means you can&amp;rsquo;t use this trait as a trait object in this way. If you&amp;rsquo;re interested in more details on object safety, see &lt;a href=&quot;https://github.com/rust-lang/rfcs/blob/master/text/0255-object-safety.md&quot;&gt;Rust RFC 255&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="027a2fdf6a3f9948a9c92b0f1c99c26f859c6929" translate="yes" xml:space="preserve">
          <source>This error message refers to a feature we haven&amp;rsquo;t covered yet: lifetimes. We&amp;rsquo;ll discuss lifetimes in detail in Chapter 10. But, if you disregard the parts about lifetimes, the message does contain the key to why this code is a problem:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b934f7e266f094b4b999e8bf2f04c71dea6d6829" translate="yes" xml:space="preserve">
          <source>This error message states that we&amp;rsquo;re not allowed to explicitly call &lt;code&gt;drop&lt;/code&gt;. The error message uses the term &lt;em&gt;destructor&lt;/em&gt;, which is the general programming term for a function that cleans up an instance. A &lt;em&gt;destructor&lt;/em&gt; is analogous to a &lt;em&gt;constructor&lt;/em&gt;, which creates an instance. The &lt;code&gt;drop&lt;/code&gt; function in Rust is one particular destructor.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2c2b32b5586db42f3b0dff4da46b1782d86e698e" translate="yes" xml:space="preserve">
          <source>This error occurs because a borrow in a generator persists across a yield point.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1e6bf835d8f1dd37c8b25ebb4f51cc6621c79aa9" translate="yes" xml:space="preserve">
          <source>This error occurs because a borrow of a thread-local variable was made inside a function which outlived the lifetime of the function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="249f7bc8f6d82a80564f1c3f396aa42dbc6e451f" translate="yes" xml:space="preserve">
          <source>This error occurs because a value was dropped while it was still borrowed</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="074bebec9bc1d161aacdccb6e09fa091949d4c0d" translate="yes" xml:space="preserve">
          <source>This error occurs because you tried to mutably borrow a non-mutable variable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1c3db0f8ef7d737dfd4c2dc90ac02bc9a5c77f3f" translate="yes" xml:space="preserve">
          <source>This error occurs when a bound in an implementation of a trait does not match the bounds specified in the original trait. For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="093dfc68eae74dcc328a7c8a1a3d68f0b36d7fb4" translate="yes" xml:space="preserve">
          <source>This error occurs when a method is used on a type which doesn't implement it:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="da941b6947e460e43f6112767122feb782f16207" translate="yes" xml:space="preserve">
          <source>This error occurs when an &lt;code&gt;if&lt;/code&gt; expression without an &lt;code&gt;else&lt;/code&gt; block is used in a context where a type other than &lt;code&gt;()&lt;/code&gt; is expected, for example a &lt;code&gt;let&lt;/code&gt; expression:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d0370ddda8b1bb558216506bbbbafb414b273904" translate="yes" xml:space="preserve">
          <source>This error occurs when an attempt is made to assign to a borrowed value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="81568110c66c811e652efe84f4e84d35ccd0ca5f" translate="yes" xml:space="preserve">
          <source>This error occurs when an attempt is made to borrow state past the end of the lifetime of a type that implements the &lt;code&gt;Drop&lt;/code&gt; trait.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="552e357ec5f4118a4e87577f4bd866d88ddeba4b" translate="yes" xml:space="preserve">
          <source>This error occurs when an attempt is made to move a borrowed variable into a closure.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="08dbd4d1c622d91c2a3b2e7680f087d95c0c0ad4" translate="yes" xml:space="preserve">
          <source>This error occurs when an attempt is made to move out of a value whose type implements the &lt;code&gt;Drop&lt;/code&gt; trait.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b0cd32a89f254835e1067e05e21bdf36f5041728" translate="yes" xml:space="preserve">
          <source>This error occurs when an attempt is made to mutate or mutably reference data that a closure has captured immutably. Examples of this error are shown below:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e494d266acb1b46fd28c9cc0c8ca718e819da16c" translate="yes" xml:space="preserve">
          <source>This error occurs when an attempt is made to partially reinitialize a structure that is currently uninitialized.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8feee21757ea4763c54c8d19077d7ff7e0dd5208" translate="yes" xml:space="preserve">
          <source>This error occurs when an attempt is made to reassign an immutable variable. For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b105f193c377f1f9fe2f520a0094f3220a7d20d3" translate="yes" xml:space="preserve">
          <source>This error occurs when an attempt is made to use a variable after its contents have been moved elsewhere. For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="47a25aa9b1a97609269b45b233bf81af91519446" translate="yes" xml:space="preserve">
          <source>This error occurs when an attempt is made to use data captured by a closure, when that data may no longer exist. It's most commonly seen when attempting to return a closure:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fa2c4bec036eb23e59f4739f281ec16e241dd98a" translate="yes" xml:space="preserve">
          <source>This error occurs when the compiler doesn't have enough information to unambiguously choose an implementation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f68d6da4cba1c2fe73a0bdd6ed998a8c685d2f7a" translate="yes" xml:space="preserve">
          <source>This error occurs when the compiler is unable to unambiguously infer the return type of a function or method which is generic on return type, such as the &lt;code&gt;collect&lt;/code&gt; method for &lt;code&gt;Iterator&lt;/code&gt;s.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f8852702dc84baa326e19b865b76e83190126314" translate="yes" xml:space="preserve">
          <source>This error occurs when the compiler was unable to infer the concrete type of a variable. It can occur for several cases, the most common of which is a mismatch in the expected type that the compiler inferred for a variable's initializing expression, and the actual type explicitly assigned to the variable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="40572c6042150247d80f8e73ff85712050d543de" translate="yes" xml:space="preserve">
          <source>This error occurs when there was a recursive trait requirement that overflowed before it could be evaluated. Often this means that there is unbounded recursion in resolving some type bounds.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7b6569d564fb77649858b1d55f9d8b2a0efd5a34" translate="yes" xml:space="preserve">
          <source>This error occurs when you defined methods or associated functions with same name.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="31aab3dcb3c76822f5a50ebdbab3c624e3384795" translate="yes" xml:space="preserve">
          <source>This error points at a file we didn&amp;rsquo;t write, &lt;em&gt;libcore/slice/mod.rs&lt;/em&gt;. That&amp;rsquo;s the implementation of &lt;code&gt;slice&lt;/code&gt; in the Rust source code. The code that gets run when we use &lt;code&gt;[]&lt;/code&gt; on our vector &lt;code&gt;v&lt;/code&gt; is in &lt;em&gt;libcore/slice/mod.rs&lt;/em&gt;, and that is where the &lt;code&gt;panic!&lt;/code&gt; is actually happening.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="daff356f50087f066d8d7f295e45f7db503c47eb" translate="yes" xml:space="preserve">
          <source>This error points out that we&amp;rsquo;re only allowed to use the &lt;code&gt;?&lt;/code&gt; operator in a function that returns &lt;code&gt;Result&amp;lt;T, E&amp;gt;&lt;/code&gt;. When you&amp;rsquo;re writing code in a function that doesn&amp;rsquo;t return &lt;code&gt;Result&amp;lt;T, E&amp;gt;&lt;/code&gt;, and you want to use &lt;code&gt;?&lt;/code&gt; when you call other functions that return &lt;code&gt;Result&amp;lt;T, E&amp;gt;&lt;/code&gt;, you have two choices to fix this problem. One technique is to change the return type of your function to be &lt;code&gt;Result&amp;lt;T, E&amp;gt;&lt;/code&gt; if you have no restrictions preventing that. The other technique is to use a &lt;code&gt;match&lt;/code&gt; or one of the &lt;code&gt;Result&amp;lt;T, E&amp;gt;&lt;/code&gt; methods to handle the &lt;code&gt;Result&amp;lt;T, E&amp;gt;&lt;/code&gt; in whatever way is appropriate.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f5d927c97470a6bdf532b94621efe13e0092f99e" translate="yes" xml:space="preserve">
          <source>This error suggests that the expression arm corresponding to the noted pattern will never be reached as for all possible values of the expression being matched, one of the preceding patterns will match.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f4cd2a99a6de016ca859c1b751566814099aa1c3" translate="yes" xml:space="preserve">
          <source>This error type&amp;rsquo;s methods can be used to create functionality similar to &lt;code&gt;String::from_utf8_lossy&lt;/code&gt; without allocating heap memory:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fb422fab14fffbfe5c78207ee2ae02a65418bd40" translate="yes" xml:space="preserve">
          <source>This error usually happens when trying to pass in a value to an input inline assembly operand that is actually a pair of values. In particular, this can happen when trying to pass in a slice, for instance a &lt;code&gt;&amp;amp;str&lt;/code&gt;. In Rust, these values are represented internally as a pair of values, the pointer and its length. When passed as an input operand, this pair of values can not be coerced into a register and thus we must fail with an error.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="46906d1c89db9bd7d3aa62947de98893bb4109ab" translate="yes" xml:space="preserve">
          <source>This error was returned when attempting to write the internal buffer.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6f5335a8d7c6f37faeab381d52fe1092a252bd8d" translate="yes" xml:space="preserve">
          <source>This example also shows how to use &lt;code&gt;move&lt;/code&gt;, in order to give ownership of values to a thread.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="175716bea92c9d941f0898dc29c4ed209e64c353" translate="yes" xml:space="preserve">
          <source>This example builds a string, starting with an initial value and continuing with each element from the back until the front:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4d013525fa73f401dcf7648ce7d8e69f8100f085" translate="yes" xml:space="preserve">
          <source>This example creates a &lt;code&gt;Point&lt;/code&gt; struct that implements &lt;a href=&quot;trait.add&quot;&gt;&lt;code&gt;Add&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;trait.sub&quot;&gt;&lt;code&gt;Sub&lt;/code&gt;&lt;/a&gt;, and then demonstrates adding and subtracting two &lt;code&gt;Point&lt;/code&gt;s.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="612bd6352093018ae655e26b99b1150fb9f0d9dc" translate="yes" xml:space="preserve">
          <source>This example creates a &lt;code&gt;Point&lt;/code&gt; struct that implements the &lt;code&gt;AddAssign&lt;/code&gt; trait, and then demonstrates add-assigning to a mutable &lt;code&gt;Point&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="84b61046cfa323fa19b23ac20e12034ef787e01b" translate="yes" xml:space="preserve">
          <source>This example creates a &lt;code&gt;Point&lt;/code&gt; struct that implements the &lt;code&gt;SubAssign&lt;/code&gt; trait, and then demonstrates sub-assigning to a mutable &lt;code&gt;Point&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="979ade7fbba01641154de5a065a6e6890cf54db4" translate="yes" xml:space="preserve">
          <source>This example creates a function with two parameters, both of which are &lt;code&gt;i32&lt;/code&gt; types. The function then prints the values in both of its parameters. Note that function parameters don&amp;rsquo;t all need to be the same type, they just happen to be in this example.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="701db2e46c2038eecc101dd4ef0779ff5ad8d4cc" translate="yes" xml:space="preserve">
          <source>This example implements &lt;code&gt;Rem&lt;/code&gt; on a &lt;code&gt;SplitSlice&lt;/code&gt; object. After &lt;code&gt;Rem&lt;/code&gt; is implemented, one can use the &lt;code&gt;%&lt;/code&gt; operator to find out what the remaining elements of the slice would be after splitting it into equal slices of a given length.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3d81c01c409b8ce1936b460c9219c2266b9648d9" translate="yes" xml:space="preserve">
          <source>This example prints 3, 2, and then 1. The &lt;code&gt;pop&lt;/code&gt; method takes the last element out of the vector and returns &lt;code&gt;Some(value)&lt;/code&gt;. If the vector is empty, &lt;code&gt;pop&lt;/code&gt; returns &lt;code&gt;None&lt;/code&gt;. The &lt;code&gt;while&lt;/code&gt; loop continues running the code in its block as long as &lt;code&gt;pop&lt;/code&gt; returns &lt;code&gt;Some&lt;/code&gt;. When &lt;code&gt;pop&lt;/code&gt; returns &lt;code&gt;None&lt;/code&gt;, the loop stops. We can use &lt;code&gt;while let&lt;/code&gt; to pop every element off our stack.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="33bd3bf0b7b00466cfe4514bc631cc4d45b75356" translate="yes" xml:space="preserve">
          <source>This example shows an inner attribute on a function. The function will only be available while running tests.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="02dcd48945408a840f3079c83663da1b30b196c7" translate="yes" xml:space="preserve">
          <source>This example shows how one can use &lt;code&gt;allow&lt;/code&gt; and &lt;code&gt;warn&lt;/code&gt; to toggle a particular check on and off:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b51a82804a004969c18f750e315e49a925f322a3" translate="yes" xml:space="preserve">
          <source>This example shows how one can use &lt;code&gt;forbid&lt;/code&gt; to disallow uses of &lt;code&gt;allow&lt;/code&gt; for that lint check:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="20dcd5999998e80d936e0fa700c4a9a09932a423" translate="yes" xml:space="preserve">
          <source>This example shows how the compiler helps you find errors in your programs. Even though compiler errors can be frustrating, they only mean your program isn&amp;rsquo;t safely doing what you want it to do yet; they do &lt;em&gt;not&lt;/em&gt; mean that you&amp;rsquo;re not a good programmer! Experienced Rustaceans still get compiler errors.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2cb4570e4e31d810429621e0a69fd89abfdb2ea3" translate="yes" xml:space="preserve">
          <source>This example shows using a custom derive attribute to modify the meaning of a generic parameter.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e1b71afb4f7ccdfd339dd3d129a43084a3b35c6b" translate="yes" xml:space="preserve">
          <source>This example spawns a thread which will update the boolean value and then wait 100 milliseconds before notifying the condvar.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b7617cea2234e7524bc25112d50668635c06f962" translate="yes" xml:space="preserve">
          <source>This example will print &lt;code&gt;Found an id in range: 5&lt;/code&gt;. By specifying &lt;code&gt;id_variable @&lt;/code&gt; before the range &lt;code&gt;3...7&lt;/code&gt;, we&amp;rsquo;re capturing whatever value matched the range while also testing that the value matched the range pattern.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0792a7553f859fe5307a072fac84a140057b4ecf" translate="yes" xml:space="preserve">
          <source>This example will print &lt;code&gt;less than five: 4&lt;/code&gt;. When &lt;code&gt;num&lt;/code&gt; is compared to the pattern in the first arm, it matches, because &lt;code&gt;Some(4)&lt;/code&gt; matches &lt;code&gt;Some(x)&lt;/code&gt;. Then the match guard checks whether the value in &lt;code&gt;x&lt;/code&gt; is less than &lt;code&gt;5&lt;/code&gt;, and because it is, the first arm is selected.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="13f35b34cb9f0940df9ede968c0941933fe5a63e" translate="yes" xml:space="preserve">
          <source>This explicitly states that you expect the trait object &lt;code&gt;SomeTrait&lt;/code&gt; to contain references (with a maximum lifetime of &lt;code&gt;'a&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="55550702354f0f532a45a47534287ba31230892e" translate="yes" xml:space="preserve">
          <source>This expression:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d4d243a04a2e7c3baa5aaa70386526d20f9c61fb" translate="yes" xml:space="preserve">
          <source>This fails because &lt;code&gt;&amp;amp;mut T&lt;/code&gt; is not &lt;code&gt;Copy&lt;/code&gt;, even when &lt;code&gt;T&lt;/code&gt; is &lt;code&gt;Copy&lt;/code&gt; (this differs from the behavior for &lt;code&gt;&amp;amp;T&lt;/code&gt;, which is always &lt;code&gt;Copy&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="96a49ec58cf9d3de1eca61f7643ce5de9d8c4e5e" translate="yes" xml:space="preserve">
          <source>This fails because &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; does not implement &lt;code&gt;Copy&lt;/code&gt; for any &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="77c78e0cdd88af63c9805574659b7e0844c8f178" translate="yes" xml:space="preserve">
          <source>This fails to compile because &lt;code&gt;T&lt;/code&gt; does not appear in the trait or in the implementing type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0c5af671ad45076c8c92a16a6b71ec7dd6cf3c8d" translate="yes" xml:space="preserve">
          <source>This field contains the file system attribute information for a file or directory. For possible values and their descriptions, see &lt;a href=&quot;https://msdn.microsoft.com/en-us/library/windows/desktop/gg258117.aspx&quot;&gt;File Attribute Constants&lt;/a&gt; in the Windows Dev Center.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fed8ac050f10d4961483960b90a8bb5fa116bf7c" translate="yes" xml:space="preserve">
          <source>This field may not be available on all platforms, and will return an &lt;code&gt;Err&lt;/code&gt; on platforms where it is not available.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5368359fd79a3572b28925e44099327d749ce6f1" translate="yes" xml:space="preserve">
          <source>This file is in the &lt;a href=&quot;https://github.com/toml-lang/toml&quot;&gt;&lt;em&gt;TOML&lt;/em&gt;&lt;/a&gt; (&lt;em&gt;Tom&amp;rsquo;s Obvious, Minimal Language&lt;/em&gt;) format, which is Cargo&amp;rsquo;s configuration format.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f0537f20b3c4c0b16d4802ffcd175906f9816b83" translate="yes" xml:space="preserve">
          <source>This following example shows the stringified &lt;a href=&quot;https://doc.rust-lang.org/proc_macro/struct.TokenStream.html&quot;&gt;&lt;code&gt;TokenStream&lt;/code&gt;s&lt;/a&gt; that the attribute macros see. The output will show in the output of the compiler. The output is shown in the comments after the function prefixed with &quot;out:&quot;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a9c265b88652152ca2b28f53cb136d7ff3a25c8d" translate="yes" xml:space="preserve">
          <source>This function &lt;strong&gt;consumes ownership&lt;/strong&gt; of the specified file descriptor. The returned object will take responsibility for closing it when the object goes out of scope.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7770f6814daf86198289168c0cb8b4e0eaa39b97" translate="yes" xml:space="preserve">
          <source>This function &lt;strong&gt;transfers ownership&lt;/strong&gt; of the underlying file descriptor to the caller. Callers are then the unique owners of the file descriptor and must close the descriptor once it's no longer needed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9e16870fdc5324388fb513d47d710cb2a9d23e70" translate="yes" xml:space="preserve">
          <source>This function &lt;strong&gt;transfers ownership&lt;/strong&gt; of the underlying handle to the caller. Callers are then the unique owners of the handle and must close it once it's no longer needed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="90c9a08f16b0c10b615b5b0843cebfac39017e99" translate="yes" xml:space="preserve">
          <source>This function &lt;strong&gt;transfers ownership&lt;/strong&gt; of the underlying pthread_t to the caller. Callers are then the unique owners of the pthread_t and must either detach or join the pthread_t once it's no longer needed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="06669b18e93261495eb1fcf2252cb895da69c39a" translate="yes" xml:space="preserve">
          <source>This function &lt;strong&gt;transfers ownership&lt;/strong&gt; of the underlying socket to the caller. Callers are then the unique owners of the socket and must close it once it's no longer needed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3028ce76268abc4493b0febc5668a0c85baa5e06" translate="yes" xml:space="preserve">
          <source>This function accepts strings such as</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e1eb2ceefa3b664d9a9270981fa8cbdd469bffdd" translate="yes" xml:space="preserve">
          <source>This function can be used for control flow based on &lt;code&gt;Result&lt;/code&gt; values.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="069d719c6868f05d1ad9a84a0abe1540eb6a83ca" translate="yes" xml:space="preserve">
          <source>This function can be used for control flow based on result values.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1f2e8570607d30aa900e189937d7916fe8ed3230" translate="yes" xml:space="preserve">
          <source>This function can be used to compose the results of two functions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="890b1ba5d17963460809400c8357e2da154ed2a6" translate="yes" xml:space="preserve">
          <source>This function can be used to pass through a successful result while handling an error.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f898974fbfac52e97eb29d82afb416cf7dbf9a7a" translate="yes" xml:space="preserve">
          <source>This function can be used to unpack a successful result while handling an error.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="663e29d3010e4fe834fdfef457c75d87463c66ed" translate="yes" xml:space="preserve">
          <source>This function can be written in a much shorter way, but we&amp;rsquo;re going to start by doing a lot of it manually in order to explore error handling; at the end, we&amp;rsquo;ll show the shorter way. Let&amp;rsquo;s look at the return type of the function first: &lt;code&gt;Result&amp;lt;String, io::Error&amp;gt;&lt;/code&gt;. This means the function is returning a value of the type &lt;code&gt;Result&amp;lt;T, E&amp;gt;&lt;/code&gt; where the generic parameter &lt;code&gt;T&lt;/code&gt; has been filled in with the concrete type &lt;code&gt;String&lt;/code&gt; and the generic type &lt;code&gt;E&lt;/code&gt; has been filled in with the concrete type &lt;code&gt;io::Error&lt;/code&gt;. If this function succeeds without any problems, the code that calls this function will receive an &lt;code&gt;Ok&lt;/code&gt; value that holds a &lt;code&gt;String&lt;/code&gt;&amp;mdash;the username that this function read from the file. If this function encounters any problems, the code that calls this function will receive an &lt;code&gt;Err&lt;/code&gt; value that holds an instance of &lt;code&gt;io::Error&lt;/code&gt; that contains more information about what the problems were. We chose &lt;code&gt;io::Error&lt;/code&gt; as the return type of this function because that happens to be the type of the error value returned from both of the operations we&amp;rsquo;re calling in this function&amp;rsquo;s body that might fail: the &lt;code&gt;File::open&lt;/code&gt; function and the &lt;code&gt;read_to_string&lt;/code&gt; method.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cb45099429d3a43cd1fd9c5de5abe0335d7b7e9d" translate="yes" xml:space="preserve">
          <source>This function corresponds to &lt;a href=&quot;../mem/fn.replace&quot;&gt;&lt;code&gt;std::mem::replace&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bc55369db6754d8ec7579c34bfc5b97438f6a7f6" translate="yes" xml:space="preserve">
          <source>This function corresponds to &lt;a href=&quot;../mem/fn.swap&quot;&gt;&lt;code&gt;std::mem::swap&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ac167c5922dc46db61626cca7bc837d30e8e8d77" translate="yes" xml:space="preserve">
          <source>This function currently corresponds to &lt;code&gt;opendir&lt;/code&gt;, &lt;code&gt;lstat&lt;/code&gt;, &lt;code&gt;rm&lt;/code&gt; and &lt;code&gt;rmdir&lt;/code&gt; functions on Unix and the &lt;code&gt;FindFirstFile&lt;/code&gt;, &lt;code&gt;GetFileAttributesEx&lt;/code&gt;, &lt;code&gt;DeleteFile&lt;/code&gt;, and &lt;code&gt;RemoveDirectory&lt;/code&gt; functions on Windows. Note that, this &lt;a href=&quot;../io/index#platform-specific-behavior&quot;&gt;may change in the future&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bea785a55c87ae52504d49f8f95ea16d8aa3ce9e" translate="yes" xml:space="preserve">
          <source>This function currently corresponds to the &lt;code&gt;chmod&lt;/code&gt; function on Unix and the &lt;code&gt;SetFileAttributes&lt;/code&gt; function on Windows. Note that, this &lt;a href=&quot;../io/index#platform-specific-behavior&quot;&gt;may change in the future&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="04e383479b2228c3ffffa98975698e9dda256dbb" translate="yes" xml:space="preserve">
          <source>This function currently corresponds to the &lt;code&gt;fchmod&lt;/code&gt; function on Unix and the &lt;code&gt;SetFileInformationByHandle&lt;/code&gt; function on Windows. Note that, this &lt;a href=&quot;../io/index#platform-specific-behavior&quot;&gt;may change in the future&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0176ddcd073fa8b60d6460114db8d5951e367349" translate="yes" xml:space="preserve">
          <source>This function currently corresponds to the &lt;code&gt;link&lt;/code&gt; function on Unix and the &lt;code&gt;CreateHardLink&lt;/code&gt; function on Windows. Note that, this &lt;a href=&quot;../io/index#platform-specific-behavior&quot;&gt;may change in the future&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="01e2694d82da90e8f24cd10e750a58377e07410c" translate="yes" xml:space="preserve">
          <source>This function currently corresponds to the &lt;code&gt;lstat&lt;/code&gt; function on Unix and the &lt;code&gt;GetFileAttributesEx&lt;/code&gt; function on Windows. Note that, this &lt;a href=&quot;../io/index#platform-specific-behavior&quot;&gt;may change in the future&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3537e3f2c9af1f7a17489b68fe05b364816b75fc" translate="yes" xml:space="preserve">
          <source>This function currently corresponds to the &lt;code&gt;mkdir&lt;/code&gt; function on Unix and the &lt;code&gt;CreateDirectory&lt;/code&gt; function on Windows. Note that, this &lt;a href=&quot;../io/index#platform-specific-behavior&quot;&gt;may change in the future&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4ffbba2d718a3b3920d07fee5dfb64d2a84ce583" translate="yes" xml:space="preserve">
          <source>This function currently corresponds to the &lt;code&gt;open&lt;/code&gt; function in Unix with &lt;code&gt;O_RDONLY&lt;/code&gt; for &lt;code&gt;from&lt;/code&gt; and &lt;code&gt;O_WRONLY&lt;/code&gt;, &lt;code&gt;O_CREAT&lt;/code&gt;, and &lt;code&gt;O_TRUNC&lt;/code&gt; for &lt;code&gt;to&lt;/code&gt;. &lt;code&gt;O_CLOEXEC&lt;/code&gt; is set for returned file descriptors. On Windows, this function currently corresponds to &lt;code&gt;CopyFileEx&lt;/code&gt;. Alternate NTFS streams are copied but only the size of the main stream is returned by this function. On MacOS, this function corresponds to &lt;code&gt;fclonefileat&lt;/code&gt; and &lt;code&gt;fcopyfile&lt;/code&gt;. Note that, this &lt;a href=&quot;../io/index#platform-specific-behavior&quot;&gt;may change in the future&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="85bdcb1c22d0b90cfc515b44a49195abde2937e0" translate="yes" xml:space="preserve">
          <source>This function currently corresponds to the &lt;code&gt;opendir&lt;/code&gt; function on Unix and the &lt;code&gt;FindFirstFile&lt;/code&gt; function on Windows. Note that, this &lt;a href=&quot;../io/index#platform-specific-behavior&quot;&gt;may change in the future&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c6d0089b9c1b95a34e4ecb4a009ec095c9db172d" translate="yes" xml:space="preserve">
          <source>This function currently corresponds to the &lt;code&gt;readlink&lt;/code&gt; function on Unix and the &lt;code&gt;CreateFile&lt;/code&gt; function with &lt;code&gt;FILE_FLAG_OPEN_REPARSE_POINT&lt;/code&gt; and &lt;code&gt;FILE_FLAG_BACKUP_SEMANTICS&lt;/code&gt; flags on Windows. Note that, this &lt;a href=&quot;../io/index#platform-specific-behavior&quot;&gt;may change in the future&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="83d811fb4fcc08f1492a059a3536fbb7a2a90ca2" translate="yes" xml:space="preserve">
          <source>This function currently corresponds to the &lt;code&gt;realpath&lt;/code&gt; function on Unix and the &lt;code&gt;CreateFile&lt;/code&gt; and &lt;code&gt;GetFinalPathNameByHandle&lt;/code&gt; functions on Windows. Note that, this &lt;a href=&quot;../io/index#platform-specific-behavior&quot;&gt;may change in the future&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e8892007c2c9e02432f47cff4848a4e40ebbc10c" translate="yes" xml:space="preserve">
          <source>This function currently corresponds to the &lt;code&gt;rename&lt;/code&gt; function on Unix and the &lt;code&gt;MoveFileEx&lt;/code&gt; function with the &lt;code&gt;MOVEFILE_REPLACE_EXISTING&lt;/code&gt; flag on Windows.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8dd8f559f50531dc710476fe85e80e2f8d9753bd" translate="yes" xml:space="preserve">
          <source>This function currently corresponds to the &lt;code&gt;rmdir&lt;/code&gt; function on Unix and the &lt;code&gt;RemoveDirectory&lt;/code&gt; function on Windows. Note that, this &lt;a href=&quot;../io/index#platform-specific-behavior&quot;&gt;may change in the future&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b504889b373cb94fdb7ee56e28d937c2f36d6f0b" translate="yes" xml:space="preserve">
          <source>This function currently corresponds to the &lt;code&gt;stat&lt;/code&gt; function on Unix and the &lt;code&gt;GetFileAttributesEx&lt;/code&gt; function on Windows. Note that, this &lt;a href=&quot;../io/index#platform-specific-behavior&quot;&gt;may change in the future&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6672293739936665c26201ef3156432a0e98fd87" translate="yes" xml:space="preserve">
          <source>This function currently corresponds to the &lt;code&gt;unlink&lt;/code&gt; function on Unix and the &lt;code&gt;DeleteFile&lt;/code&gt; function on Windows. Note that, this &lt;a href=&quot;../io/index#platform-specific-behavior&quot;&gt;may change in the future&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c94bdac48da7a0fc40fd1e5a086497b625f64825" translate="yes" xml:space="preserve">
          <source>This function does &lt;strong&gt;not&lt;/strong&gt; follow symbolic links and it will simply remove the symbolic link itself.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="977a8c203f0461d37e9d1afc3c85702bdcf54979" translate="yes" xml:space="preserve">
          <source>This function does not block.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6f6f2506f47f0d38fd935eda8f1d3f32af31d36c" translate="yes" xml:space="preserve">
          <source>This function does not provide any guarantees about whether it blocks waiting for data, but if an object needs to block for a read but cannot it will typically signal this via an &lt;a href=&quot;../result/enum.result#variant.Err&quot;&gt;&lt;code&gt;Err&lt;/code&gt;&lt;/a&gt; return value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c9eb6fee31ded1ada354009451436d0884930106" translate="yes" xml:space="preserve">
          <source>This function does not provide any guarantees with respect to the ordering of whether contentious readers or writers will acquire the lock first.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4305826482cc10423eedc0c48122ffd5b51fb63b" translate="yes" xml:space="preserve">
          <source>This function doesn't create the file if it doesn't exist. Use the &lt;a href=&quot;#method.create&quot;&gt;&lt;code&gt;create&lt;/code&gt;&lt;/a&gt; method to do so.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c2ecd58992bf3950332fa012ed014d7ac0b8bc7f" translate="yes" xml:space="preserve">
          <source>This function first gets the total length of the slice. Then it asserts that the index given as a parameter is within the slice by checking whether it&amp;rsquo;s less than or equal to the length. The assertion means that if we pass an index that is greater than the index to split the slice at, the function will panic before it attempts to use that index.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="457e092a949142d636a9e03fab0c159238f5daa4" translate="yes" xml:space="preserve">
          <source>This function forwards calls to the &lt;a href=&quot;trait.globalalloc#method.alloc_zeroed&quot;&gt;&lt;code&gt;GlobalAlloc::alloc_zeroed&lt;/code&gt;&lt;/a&gt; method of the allocator registered with the &lt;code&gt;#[global_allocator]&lt;/code&gt; attribute if there is one, or the &lt;code&gt;std&lt;/code&gt; crate&amp;rsquo;s default.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dac6968f4833b95b4cfc0a37edb3317e41dafb8d" translate="yes" xml:space="preserve">
          <source>This function forwards calls to the &lt;a href=&quot;trait.globalalloc#method.realloc&quot;&gt;&lt;code&gt;GlobalAlloc::realloc&lt;/code&gt;&lt;/a&gt; method of the allocator registered with the &lt;code&gt;#[global_allocator]&lt;/code&gt; attribute if there is one, or the &lt;code&gt;std&lt;/code&gt; crate&amp;rsquo;s default.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0ee226de8b2847b4bcaa66f0141bab39ef9c2e4e" translate="yes" xml:space="preserve">
          <source>This function forwards calls to the &lt;a href=&quot;trait.globalalloc#tymethod.alloc&quot;&gt;&lt;code&gt;GlobalAlloc::alloc&lt;/code&gt;&lt;/a&gt; method of the allocator registered with the &lt;code&gt;#[global_allocator]&lt;/code&gt; attribute if there is one, or the &lt;code&gt;std&lt;/code&gt; crate&amp;rsquo;s default.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="43408a3e60cf657f5104a853eae37001a5663e2b" translate="yes" xml:space="preserve">
          <source>This function forwards calls to the &lt;a href=&quot;trait.globalalloc#tymethod.dealloc&quot;&gt;&lt;code&gt;GlobalAlloc::dealloc&lt;/code&gt;&lt;/a&gt; method of the allocator registered with the &lt;code&gt;#[global_allocator]&lt;/code&gt; attribute if there is one, or the &lt;code&gt;std&lt;/code&gt; crate&amp;rsquo;s default.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="438ebff47f84838c22c79fbc8bfdda182cd513dc" translate="yes" xml:space="preserve">
          <source>This function gets called when a &lt;a href=&quot;struct.rawwaker&quot;&gt;&lt;code&gt;RawWaker&lt;/code&gt;&lt;/a&gt; gets dropped.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="13819f0b7aa144e5ea6bcb9cc9f9a6808e198851" translate="yes" xml:space="preserve">
          <source>This function has the same error semantics as &lt;a href=&quot;#method.read_until&quot;&gt;&lt;code&gt;read_until&lt;/code&gt;&lt;/a&gt; and will also return an error if the read bytes are not valid UTF-8. If an I/O error is encountered then &lt;code&gt;buf&lt;/code&gt; may contain some bytes already read in the event that all data read so far was valid UTF-8.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="adea46a33368b546562d3adbbc93c24db07769c5" translate="yes" xml:space="preserve">
          <source>This function has the same safety guarantees as the &lt;a href=&quot;trait.iterator#method.size_hint&quot;&gt;&lt;code&gt;size_hint&lt;/code&gt;&lt;/a&gt; function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1b144c49949055dde44dc3050173804acf39c11f" translate="yes" xml:space="preserve">
          <source>This function internally uses the &lt;a href=&quot;#method.write_all&quot;&gt;&lt;code&gt;write_all&lt;/code&gt;&lt;/a&gt; method on this trait and hence will continuously write data so long as no errors are received. This also means that partial writes are not indicated in this signature.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1f9b7d260474b82b56786f2b96849de01b420191" translate="yes" xml:space="preserve">
          <source>This function is a lower-level call. It needs to be paired with the &lt;a href=&quot;#tymethod.consume&quot;&gt;&lt;code&gt;consume&lt;/code&gt;&lt;/a&gt; method to function properly. When calling this method, none of the contents will be &quot;read&quot; in the sense that later calling &lt;code&gt;read&lt;/code&gt; may return the same contents. As such, &lt;a href=&quot;#tymethod.consume&quot;&gt;&lt;code&gt;consume&lt;/code&gt;&lt;/a&gt; must be called with the number of bytes that are consumed from this buffer to ensure that the bytes are never returned twice.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1da3425b653a05b924f0c013401f366dcdf5aa2c" translate="yes" xml:space="preserve">
          <source>This function is a lower-level call. It needs to be paired with the &lt;a href=&quot;#tymethod.fill_buf&quot;&gt;&lt;code&gt;fill_buf&lt;/code&gt;&lt;/a&gt; method to function properly. This function does not perform any I/O, it simply informs this object that some amount of its buffer, returned from &lt;a href=&quot;#tymethod.fill_buf&quot;&gt;&lt;code&gt;fill_buf&lt;/code&gt;&lt;/a&gt;, has been consumed and should no longer be returned. As such, this function may do odd things if &lt;a href=&quot;#tymethod.fill_buf&quot;&gt;&lt;code&gt;fill_buf&lt;/code&gt;&lt;/a&gt; isn't called before calling it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="415a263593c43f00d8f5a632e9e771b274ca8329" translate="yes" xml:space="preserve">
          <source>This function is a no-op, and does not even read from &lt;code&gt;dummy&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="04e44698b394de41883f1cf69eb125285be21b0e" translate="yes" xml:space="preserve">
          <source>This function is also unsafe as the primitives currently returned have the contract that they are the sole owner of the file descriptor they are wrapping. Usage of this function could accidentally allow violating this contract which can cause memory unsafety in code that relies on it being true.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2844b634a91113f81bf8561b54a56d96807ba95f" translate="yes" xml:space="preserve">
          <source>This function is different than &lt;a href=&quot;../../thread/fn.yield_now&quot;&gt;&lt;code&gt;std::thread::yield_now&lt;/code&gt;&lt;/a&gt; which directly yields to the system's scheduler, whereas &lt;code&gt;spin_loop_hint&lt;/code&gt; only signals the processor that it is entering a busy-wait spin-loop without yielding control to the system's scheduler.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="98f804e178831934e2704907d9977fcb07b49649" translate="yes" xml:space="preserve">
          <source>This function is different than &lt;a href=&quot;../thread/fn.yield_now&quot;&gt;&lt;code&gt;std::thread::yield_now&lt;/code&gt;&lt;/a&gt; which directly yields to the system's scheduler, whereas &lt;code&gt;spin_loop&lt;/code&gt; only signals the processor that it is entering a busy-wait spin-loop without yielding control to the system's scheduler.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="467a74dd68a231eab8ded24aa170197676eb9466" translate="yes" xml:space="preserve">
          <source>This function is expected to be deprecated in favor of the &lt;code&gt;alloc&lt;/code&gt; method of the &lt;a href=&quot;struct.global&quot;&gt;&lt;code&gt;Global&lt;/code&gt;&lt;/a&gt; type when it and the &lt;a href=&quot;trait.alloc&quot;&gt;&lt;code&gt;Alloc&lt;/code&gt;&lt;/a&gt; trait become stable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6654c3116763d1cd428eebcad450e10896b561da" translate="yes" xml:space="preserve">
          <source>This function is expected to be deprecated in favor of the &lt;code&gt;alloc_zeroed&lt;/code&gt; method of the &lt;a href=&quot;struct.global&quot;&gt;&lt;code&gt;Global&lt;/code&gt;&lt;/a&gt; type when it and the &lt;a href=&quot;trait.alloc&quot;&gt;&lt;code&gt;Alloc&lt;/code&gt;&lt;/a&gt; trait become stable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0400d9b530af2cdc75200e564b1d3df4717e5b0d" translate="yes" xml:space="preserve">
          <source>This function is expected to be deprecated in favor of the &lt;code&gt;dealloc&lt;/code&gt; method of the &lt;a href=&quot;struct.global&quot;&gt;&lt;code&gt;Global&lt;/code&gt;&lt;/a&gt; type when it and the &lt;a href=&quot;trait.alloc&quot;&gt;&lt;code&gt;Alloc&lt;/code&gt;&lt;/a&gt; trait become stable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9c9fc6e063817eb54b121ff88e105f246093f7ff" translate="yes" xml:space="preserve">
          <source>This function is expected to be deprecated in favor of the &lt;code&gt;realloc&lt;/code&gt; method of the &lt;a href=&quot;struct.global&quot;&gt;&lt;code&gt;Global&lt;/code&gt;&lt;/a&gt; type when it and the &lt;a href=&quot;trait.alloc&quot;&gt;&lt;code&gt;Alloc&lt;/code&gt;&lt;/a&gt; trait become stable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5b11361fb076bd1f28fd827ccd142c64af2b467e" translate="yes" xml:space="preserve">
          <source>This function is just a shim intended to be removed when the &lt;code&gt;unsized_locals&lt;/code&gt; feature gets stabilized.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="177431c922c0d0a7a204582e17b86736e812c93b" translate="yes" xml:space="preserve">
          <source>This function is mainly useful for data that lives for the remainder of the program's life. Dropping the returned reference will cause a memory leak. If this is not acceptable, the reference should first be wrapped with the &lt;a href=&quot;struct.box#method.from_raw&quot;&gt;&lt;code&gt;Box::from_raw&lt;/code&gt;&lt;/a&gt; function producing a &lt;code&gt;Box&lt;/code&gt;. This &lt;code&gt;Box&lt;/code&gt; can then be dropped which will properly destroy &lt;code&gt;T&lt;/code&gt; and release the allocated memory.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="59cb1896e3dcd115f785bf2479cb4580b1b9722d" translate="yes" xml:space="preserve">
          <source>This function is not magic; it is literally defined as</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eeccb3e706f48a212133104a654e31843b7b7b92" translate="yes" xml:space="preserve">
          <source>This function is primarily used for optimization purposes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9a9053fe38824d2de0054cbaba771d8a6b62c54f" translate="yes" xml:space="preserve">
          <source>This function is semantically equivalent to &lt;a href=&quot;../mem/fn.replace&quot;&gt;&lt;code&gt;mem::replace&lt;/code&gt;&lt;/a&gt; except that it operates on raw pointers instead of references. When references are available, &lt;a href=&quot;../mem/fn.replace&quot;&gt;&lt;code&gt;mem::replace&lt;/code&gt;&lt;/a&gt; should be preferred.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7bc2ee69e11ff49cf8f44aa7be972ea956317ef2" translate="yes" xml:space="preserve">
          <source>This function is similar to &lt;a href=&quot;struct.file#method.sync_all&quot;&gt;&lt;code&gt;sync_all&lt;/code&gt;&lt;/a&gt;, except that it may not synchronize file metadata to the filesystem.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c9cbe9f2a91fb1ea199b620a6bb920ab34b40788" translate="yes" xml:space="preserve">
          <source>This function is similar to &lt;code&gt;wake&lt;/code&gt;, but must not consume the provided data pointer.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b2a62d49d2d0f2fe0fb6a0071ccf5e43d3885dc1" translate="yes" xml:space="preserve">
          <source>This function is the equivalent of &lt;a href=&quot;#method.to_bytes&quot;&gt;&lt;code&gt;to_bytes&lt;/code&gt;&lt;/a&gt; except that it will retain the trailing nul terminator instead of chopping it off.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bbca71aedd00db40d26ceff11e63bc8c656a9f3e" translate="yes" xml:space="preserve">
          <source>This function is the inverse of &lt;a href=&quot;#method.offset&quot;&gt;&lt;code&gt;offset&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="60af8a75ca29fd4b9524979a42c65b475dac17ca" translate="yes" xml:space="preserve">
          <source>This function is the inverse of &lt;a href=&quot;#method.offset-1&quot;&gt;&lt;code&gt;offset&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f4e91aa4b5730d86849f9ad126912325901a438a" translate="yes" xml:space="preserve">
          <source>This function is unsafe as it does not verify the preconditions from &lt;a href=&quot;#method.from_size_align&quot;&gt;&lt;code&gt;Layout::from_size_align&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c0adf1d1fbca05371274b33d836dbb8ba3b0da96" translate="yes" xml:space="preserve">
          <source>This function is unsafe as there is no guarantee that the given pointer is valid for &lt;code&gt;len&lt;/code&gt; elements, nor whether the lifetime inferred is a suitable lifetime for the returned slice.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ead8661237451bd45c2559207ff2f0d2dcefd5f7" translate="yes" xml:space="preserve">
          <source>This function is unsafe because improper use may lead to memory problems. For example, a double-free may occur if the function is called twice on the same raw pointer.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1f0606f18b84a9d14096f66fc981df0b42c6d0bf" translate="yes" xml:space="preserve">
          <source>This function is unsafe because it does not check that the bytes passed to it are valid UTF-8. If this constraint is violated, it may cause memory unsafety issues with future users of the &lt;code&gt;String&lt;/code&gt;, as the rest of the standard library assumes that &lt;code&gt;String&lt;/code&gt;s are valid UTF-8.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="36c2b1be1ffd545e988489f24fde5b599256ff94" translate="yes" xml:space="preserve">
          <source>This function is unsafe because it does not check that the bytes passed to it are valid UTF-8. If this constraint is violated, undefined behavior results, as the rest of Rust assumes that &lt;a href=&quot;../primitive.str&quot;&gt;&lt;code&gt;&amp;amp;str&lt;/code&gt;&lt;/a&gt;s are valid UTF-8.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d26d0eb0451d8006697165ba21e7f4a6d2affd96" translate="yes" xml:space="preserve">
          <source>This function is unsafe because undefined behavior can result if the caller does not ensure all of the following:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="42a04935e77664a45c1ca55344796f0f9622e5b5" translate="yes" xml:space="preserve">
          <source>This function is unsafe because undefined behavior can result if the caller does not ensure both:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b81cd2be550f8d99eeb1700fa914c58868e2867c" translate="yes" xml:space="preserve">
          <source>This function is unsafe because undefined behavior can result if the caller does not ensure that &lt;code&gt;layout&lt;/code&gt; has non-zero size.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="454ec0a5acadcaac0aa85170f5ed93cb46c13302" translate="yes" xml:space="preserve">
          <source>This function is unsafe for the same reasons as &lt;a href=&quot;fn.from_raw_parts&quot;&gt;&lt;code&gt;from_raw_parts&lt;/code&gt;&lt;/a&gt;, as well as not being able to provide a non-aliasing guarantee of the returned mutable slice. &lt;code&gt;data&lt;/code&gt; must be non-null and aligned even for zero-length slices as with &lt;a href=&quot;fn.from_raw_parts&quot;&gt;&lt;code&gt;from_raw_parts&lt;/code&gt;&lt;/a&gt;. The total size of the slice must be no larger than &lt;code&gt;isize::MAX&lt;/code&gt;&lt;strong&gt;bytes&lt;/strong&gt; in memory.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eecdc0e72496ca31779009b14276f9c964f0fc63" translate="yes" xml:space="preserve">
          <source>This function is unsafe for the same reasons that &lt;code&gt;alloc&lt;/code&gt; is.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f46ccfd28f902efc152ad3d0bc725d272999fa8f" translate="yes" xml:space="preserve">
          <source>This function is unsafe for the same reasons that &lt;code&gt;alloc&lt;/code&gt; is. However the allocated block of memory is guaranteed to be initialized.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c8935ef267a58bf14edf52661928291938f416d8" translate="yes" xml:space="preserve">
          <source>This function is unsafe for the same reasons that &lt;code&gt;realloc&lt;/code&gt; is.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="010c54d09909e31d21b794c4e10275c4b255b332" translate="yes" xml:space="preserve">
          <source>This function is unsafe, as it may construct invalid &lt;code&gt;char&lt;/code&gt; values.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="71a1e970e4af15e1e28b626518e246fe2beaa9ff" translate="yes" xml:space="preserve">
          <source>This function is unsafe. You must guarantee that the data you return will not move so long as the argument value does not move (for example, because it is one of the fields of that value), and also that you do not move out of the argument you receive to the interior function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="39a3dbf4634bdba5a0505dade8771f96ac64c22f" translate="yes" xml:space="preserve">
          <source>This function is unsafe. You must guarantee that you will continue to treat the pointer &lt;code&gt;P&lt;/code&gt; as pinned after you call this function, so that the invariants on the &lt;code&gt;Pin&lt;/code&gt; type can be upheld. If the code using the resulting &lt;code&gt;P&lt;/code&gt; does not continue to maintain the pinning invariants that is a violation of the API contract and may lead to undefined behavior in later (safe) operations.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6c0c82733953c468905548df35ad6822c84f6c7f" translate="yes" xml:space="preserve">
          <source>This function is unsafe. You must guarantee that you will never move the data out of the mutable reference you receive when you call this function, so that the invariants on the &lt;code&gt;Pin&lt;/code&gt; type can be upheld.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="94b97e70917e2ec0dff12c2bd6e40f05c9be7d64" translate="yes" xml:space="preserve">
          <source>This function is used to generically create I/O errors which do not originate from the OS itself. The &lt;code&gt;error&lt;/code&gt; argument is an arbitrary payload which will be contained in this &lt;code&gt;Error&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0bf849f4d8fe700d85a6260475a19ac69c25acf8" translate="yes" xml:space="preserve">
          <source>This function is very easy to write, thanks to &lt;code&gt;match&lt;/code&gt;, and will look like Listing 6-5.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="19c2bab36fa633ea4bf26b73afdd5bd0e16edc9a" translate="yes" xml:space="preserve">
          <source>This function is, in some sense, the opposite of &lt;a href=&quot;#method.zip&quot;&gt;&lt;code&gt;zip&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f705e261edec6d4798f68322cebb8b5768877e5d" translate="yes" xml:space="preserve">
          <source>This function may fail as the underlying system clock is susceptible to drift and updates (e.g., the system clock could go backwards), so this function may not always succeed. If successful, &lt;a href=&quot;../result/enum.result#variant.Ok&quot;&gt;&lt;code&gt;Ok&lt;/code&gt;&lt;/a&gt;&lt;code&gt;(&lt;/code&gt;&lt;a href=&quot;struct.duration&quot;&gt;&lt;code&gt;Duration&lt;/code&gt;&lt;/a&gt;&lt;code&gt;)&lt;/code&gt; is returned where the duration represents the amount of time elapsed from this time measurement to the current time.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a43d8a17e850a82c732c367bf89a844d3d96e4fe" translate="yes" xml:space="preserve">
          <source>This function may fail because measurements taken earlier are not guaranteed to always be before later measurements (due to anomalies such as the system clock being adjusted either forwards or backwards).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5904fd4e8b5ae82205f779a00c5c8f588077b44a" translate="yes" xml:space="preserve">
          <source>This function may panic if &lt;code&gt;key&lt;/code&gt; is empty, contains an ASCII equals sign &lt;code&gt;'='&lt;/code&gt; or the NUL character &lt;code&gt;'\0'&lt;/code&gt;, or when the value contains the NUL character.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9a0dc67c9d122eb74decfcdabf36a2e9b439b108" translate="yes" xml:space="preserve">
          <source>This function may panic if it is called after the &lt;code&gt;Complete&lt;/code&gt; variant has been returned previously. While generator literals in the language are guaranteed to panic on resuming after &lt;code&gt;Complete&lt;/code&gt;, this is not guaranteed for all implementations of the &lt;code&gt;Generator&lt;/code&gt; trait.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="22c11ebcd140410550c98ffdd0ada9fb8238ab32" translate="yes" xml:space="preserve">
          <source>This function may panic if the current time is earlier than this instant, which is something that can happen if an &lt;code&gt;Instant&lt;/code&gt; is produced synthetically.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8aed85a838914397cfff90a6f158e84b7b3b4829" translate="yes" xml:space="preserve">
          <source>This function may panic if the resulting point in time cannot be represented by the underlying data structure. See &lt;a href=&quot;../time/struct.instant#method.checked_add&quot;&gt;&lt;code&gt;checked_add&lt;/code&gt;&lt;/a&gt; for a version without panic.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="366269740ca74a1798b4e975775caf12fd1ce852" translate="yes" xml:space="preserve">
          <source>This function may panic if the resulting point in time cannot be represented by the underlying data structure. See &lt;a href=&quot;../time/struct.systemtime#method.checked_add&quot;&gt;&lt;code&gt;checked_add&lt;/code&gt;&lt;/a&gt; for a version without panic.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2f02bfc3fdf0149848c26b5693e3c3c2e193c842" translate="yes" xml:space="preserve">
          <source>This function may panic if the resulting point in time cannot be represented by the underlying data structure. See &lt;a href=&quot;struct.instant#method.checked_add&quot;&gt;&lt;code&gt;checked_add&lt;/code&gt;&lt;/a&gt; for a version without panic.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="df93ffa2c06e7d9c793296fff9096b1f4a09746a" translate="yes" xml:space="preserve">
          <source>This function may panic if the resulting point in time cannot be represented by the underlying data structure. See &lt;a href=&quot;struct.systemtime#method.checked_add&quot;&gt;&lt;code&gt;checked_add&lt;/code&gt;&lt;/a&gt; for a version without panic.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f047ee1947a40935115c87e9ff5da84ba7c716fb" translate="yes" xml:space="preserve">
          <source>This function may panic on some platforms if a thread attempts to join itself or otherwise may create a deadlock with joining threads.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2aa9c9fbe6e7d8e79dbcc09f82ff622cc49e7e8c" translate="yes" xml:space="preserve">
          <source>This function might panic if the iterator has more than &lt;a href=&quot;../usize/constant.max&quot;&gt;&lt;code&gt;usize::MAX&lt;/code&gt;&lt;/a&gt; elements.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d1fc6a40a80536289c51eca2e61adf3162489e6d" translate="yes" xml:space="preserve">
          <source>This function might panic if the iterator has more than &lt;code&gt;usize::MAX&lt;/code&gt; non-matching elements.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e85b3c94c6e63ddd25298570364b3a6122b73135" translate="yes" xml:space="preserve">
          <source>This function might panic when called if the lock is already held by the current thread.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b3552c30ec404d25019fce8d0e95a821dc885077" translate="yes" xml:space="preserve">
          <source>This function panics if &lt;code&gt;T&lt;/code&gt; is a Zero-Sized Type (&quot;ZST&quot;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="101814bfeeecf8436008ed4880368756ae5c8d29" translate="yes" xml:space="preserve">
          <source>This function panics if &lt;code&gt;T&lt;/code&gt; is a zero-sized type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9eaa9b63e5ef7b899f75363fe8681ac3e3da2fd4" translate="yes" xml:space="preserve">
          <source>This function panics if &lt;code&gt;radix&lt;/code&gt; is not in the range from 2 to 36.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f62c2a73ad1ab98a4ef40a980a80cd47e78cfc5e" translate="yes" xml:space="preserve">
          <source>This function reads as many bytes as necessary to completely fill the specified buffer &lt;code&gt;buf&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="32152f76d2e83d5c89836d9aa45ce33c14bc03d9" translate="yes" xml:space="preserve">
          <source>This function reads the value of &lt;code&gt;errno&lt;/code&gt; for the target platform (e.g. &lt;code&gt;GetLastError&lt;/code&gt; on Windows) and will return a corresponding instance of &lt;code&gt;Error&lt;/code&gt; for the error code.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="05ed95f7312c1878141bc36d8d210b9fa11581c5" translate="yes" xml:space="preserve">
          <source>This function returns a &lt;a href=&quot;../borrow/enum.cow&quot;&gt;&lt;code&gt;Cow&amp;lt;'a, str&amp;gt;&lt;/code&gt;&lt;/a&gt;. If our byte slice is invalid UTF-8, then we need to insert the replacement characters, which will change the size of the string, and hence, require a &lt;code&gt;String&lt;/code&gt;. But if it's already valid UTF-8, we don't need a new allocation. This return type allows us to handle both cases.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6f72ba6fb91e1ce3e00f9d70494a4d758f1ff97b" translate="yes" xml:space="preserve">
          <source>This function returns a new instance of &lt;code&gt;Read&lt;/code&gt; which will read at most &lt;code&gt;limit&lt;/code&gt; bytes, after which it will always return EOF (&lt;a href=&quot;../result/enum.result#variant.Ok&quot;&gt;&lt;code&gt;Ok(0)&lt;/code&gt;&lt;/a&gt;). Any read errors will not count towards the number of bytes read and future calls to &lt;a href=&quot;trait.read#tymethod.read&quot;&gt;&lt;code&gt;read()&lt;/code&gt;&lt;/a&gt; may succeed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ef0ad46bb886f62fbf2201ba9b9f859d8daf73a5" translate="yes" xml:space="preserve">
          <source>This function returns:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e286b47aa27a1649f35422e9cb038c26279f95e3" translate="yes" xml:space="preserve">
          <source>This function runs the destructor of the contained value and thus the wrapped value now represents uninitialized data. It is up to the user of this method to ensure the uninitialized data is not actually used.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e07f846f13b5b07afd4d29501d5ea48bcae4f64b" translate="yes" xml:space="preserve">
          <source>This function semantically moves out the contained value without preventing further usage. It is up to the user of this method to ensure that this container is not used again.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b73fe46d5d15372cef97957fc6bcb2aba3a35b19" translate="yes" xml:space="preserve">
          <source>This function specifies a new multicast group for this socket to join. The address must be a valid multicast address, and &lt;code&gt;interface&lt;/code&gt; is the address of the local interface with which the system should join the multicast group. If it's equal to &lt;code&gt;INADDR_ANY&lt;/code&gt; then an appropriate interface is chosen by the system.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1f12ea05478bb3baf501603f551862b3ebf72f88" translate="yes" xml:space="preserve">
          <source>This function specifies a new multicast group for this socket to join. The address must be a valid multicast address, and &lt;code&gt;interface&lt;/code&gt; is the index of the interface to join/leave (or 0 to indicate any interface).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="24119e41ff16fdb059a46c613efe17ad7fc57293" translate="yes" xml:space="preserve">
          <source>This function takes a string slice and emits it to the internal buffer after applying the relevant formatting flags specified. The flags recognized for generic strings are:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5aebd3cecb06bef11683a2b627652c498c3d60b0" translate="yes" xml:space="preserve">
          <source>This function will &lt;a href=&quot;../macro.panic&quot;&gt;&lt;code&gt;panic!&lt;/code&gt;&lt;/a&gt; if it is used with more than one mutex over time. Each condition variable is dynamically bound to exactly one mutex to ensure defined behavior across platforms. If this functionality is not desired, then unsafe primitives in &lt;code&gt;sys&lt;/code&gt; are provided.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="78327b333ccf6b689aaecb9ee26d119fa6c5777a" translate="yes" xml:space="preserve">
          <source>This function will &lt;code&gt;panic!()&lt;/code&gt; if the key currently has its destructor running, and it &lt;strong&gt;may&lt;/strong&gt; panic if the destructor has previously been run for this thread.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="de2e867f0f0c2461353251de2093fad37d9de75b" translate="yes" xml:space="preserve">
          <source>This function will &lt;em&gt;block&lt;/em&gt; until space in the internal buffer becomes available or a receiver is available to hand off the message to.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aa7ba2de98a6c309498a7c489e34ef4ae855d255" translate="yes" xml:space="preserve">
          <source>This function will &lt;strong&gt;consume ownership&lt;/strong&gt; of the handle given, passing responsibility for closing the handle to the returned object.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b6de52c208f12c4efe8542e2cc11b06fa42d2cf9" translate="yes" xml:space="preserve">
          <source>This function will &lt;strong&gt;consume ownership&lt;/strong&gt; of the socket provided and it will be closed when the returned object goes out of scope.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="34a9593fc439cb6bab67a9e273e42357e335b574" translate="yes" xml:space="preserve">
          <source>This function will &lt;strong&gt;overwrite&lt;/strong&gt; the contents of &lt;code&gt;to&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b50d15cbddd54c77fb77c9639aae5bb9352e901e" translate="yes" xml:space="preserve">
          <source>This function will always block the current thread if there is no data available and it's possible for more data to be sent. Once a message is sent to the corresponding &lt;a href=&quot;struct.sender&quot;&gt;&lt;code&gt;Sender&lt;/code&gt;&lt;/a&gt; (or &lt;a href=&quot;struct.syncsender&quot;&gt;&lt;code&gt;SyncSender&lt;/code&gt;&lt;/a&gt;), then this receiver will wake up and return that message.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2f7bc7c7785b26db5d2ba1d43d57ec9e10153387" translate="yes" xml:space="preserve">
          <source>This function will atomically unlock the mutex specified (represented by &lt;code&gt;guard&lt;/code&gt;) and block the current thread. This means that any calls to &lt;a href=&quot;#method.notify_one&quot;&gt;&lt;code&gt;notify_one&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#method.notify_all&quot;&gt;&lt;code&gt;notify_all&lt;/code&gt;&lt;/a&gt; which happen logically after the mutex is unlocked are candidates to wake this thread up. When this function call returns, the lock specified will have been re-acquired.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d633c453ad140c0449c1db8cbeeaa851bc2659b6" translate="yes" xml:space="preserve">
          <source>This function will attempt to ensure that all in-memory data reaches the filesystem before returning.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3cdc162bace3b7e0f3af0944a143fb84bab4d03d" translate="yes" xml:space="preserve">
          <source>This function will attempt to write the entire contents of &lt;code&gt;buf&lt;/code&gt;, but the entire write may not succeed, or the write may also generate an error. A call to &lt;code&gt;write&lt;/code&gt; represents &lt;em&gt;at most one&lt;/em&gt; attempt to write to any wrapped object.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d59143ff7e9860f113062c67363bd75c2092c35a" translate="yes" xml:space="preserve">
          <source>This function will be called when &lt;code&gt;wake&lt;/code&gt; is called on the &lt;a href=&quot;struct.waker&quot;&gt;&lt;code&gt;Waker&lt;/code&gt;&lt;/a&gt;. It must wake up the task associated with this &lt;a href=&quot;struct.rawwaker&quot;&gt;&lt;code&gt;RawWaker&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="12cb59dc2a2a1b37303ef992097df532faaa8b94" translate="yes" xml:space="preserve">
          <source>This function will be called when &lt;code&gt;wake_by_ref&lt;/code&gt; is called on the &lt;a href=&quot;struct.waker&quot;&gt;&lt;code&gt;Waker&lt;/code&gt;&lt;/a&gt;. It must wake up the task associated with this &lt;a href=&quot;struct.rawwaker&quot;&gt;&lt;code&gt;RawWaker&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="76c72888278b0a8cb4941353a709e0ecd237c2c8" translate="yes" xml:space="preserve">
          <source>This function will be called when the &lt;a href=&quot;struct.rawwaker&quot;&gt;&lt;code&gt;RawWaker&lt;/code&gt;&lt;/a&gt; gets cloned, e.g. when the &lt;a href=&quot;struct.waker&quot;&gt;&lt;code&gt;Waker&lt;/code&gt;&lt;/a&gt; in which the &lt;a href=&quot;struct.rawwaker&quot;&gt;&lt;code&gt;RawWaker&lt;/code&gt;&lt;/a&gt; is stored gets cloned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="83e27c1cac935244e1d8ce7e9b3bc5a49eb326cd" translate="yes" xml:space="preserve">
          <source>This function will block the calling thread until a new TCP connection is established. When established, the corresponding &lt;a href=&quot;struct.tcpstream&quot;&gt;&lt;code&gt;TcpStream&lt;/code&gt;&lt;/a&gt; and the remote peer's address will be returned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b771e75bfd99083821bb9279c74d5a51cd594b6a" translate="yes" xml:space="preserve">
          <source>This function will block the calling thread until a new Unix connection is established. When established, the corresponding &lt;a href=&quot;struct.unixstream&quot;&gt;&lt;code&gt;UnixStream&lt;/code&gt;&lt;/a&gt; and the remote peer's address will be returned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4d1cb142862a95e8531c0e6c5eeff4f29562add6" translate="yes" xml:space="preserve">
          <source>This function will block the local thread until it is available to acquire the mutex. Upon returning, the thread is the only thread with the lock held. An RAII guard is returned to allow scoped unlock of the lock. When the guard goes out of scope, the mutex will be unlocked.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e63b5a3d38dde4813e2c02e7906910d9bbecad76" translate="yes" xml:space="preserve">
          <source>This function will cast the provided &lt;code&gt;bytes&lt;/code&gt; to a &lt;code&gt;CStr&lt;/code&gt; wrapper after ensuring that the byte slice is nul-terminated and does not contain any interior nul bytes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8c3891c10a9a0ae62223a6915ab48a717d1803e4" translate="yes" xml:space="preserve">
          <source>This function will cast the provided &lt;code&gt;bytes&lt;/code&gt; to a &lt;code&gt;CStr&lt;/code&gt; wrapper without performing any sanity checks. The provided slice &lt;strong&gt;must&lt;/strong&gt; be nul-terminated and not contain any interior nul bytes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8f259ce0614bcf2d0063ac4400649f231860a760" translate="yes" xml:space="preserve">
          <source>This function will cause all pending and future I/O calls on the specified portions to immediately return with an appropriate value (see the documentation of &lt;a href=&quot;../../../net/enum.shutdown&quot;&gt;&lt;code&gt;Shutdown&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f2081c3bcdd573e767785b3929fff378af8293c8" translate="yes" xml:space="preserve">
          <source>This function will cause all pending and future I/O on the specified portions to return immediately with an appropriate value (see the documentation of &lt;a href=&quot;enum.shutdown&quot;&gt;&lt;code&gt;Shutdown&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e9782cf601eece8d5d886326b28d5030905f50d6" translate="yes" xml:space="preserve">
          <source>This function will consume the provided data and use the underlying bytes to construct a new string, ensuring that there is a trailing 0 byte. This trailing 0 byte will be appended by this function; the provided data should &lt;em&gt;not&lt;/em&gt; contain any 0 bytes in it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4a81f58ae0af06c0e29ed9547bff428e9a075df5" translate="yes" xml:space="preserve">
          <source>This function will continuously read data from &lt;code&gt;reader&lt;/code&gt; and then write it into &lt;code&gt;writer&lt;/code&gt; in a streaming fashion until &lt;code&gt;reader&lt;/code&gt; returns EOF.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="74b77ba5c4f9d07323cf0380138b2c4acac538aa" translate="yes" xml:space="preserve">
          <source>This function will correctly account for the flags provided as well as the minimum width. It will not take precision into account.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0e2de984561c8e2a215768e0c15afc535bb75bf0" translate="yes" xml:space="preserve">
          <source>This function will create a file if it does not exist, and will entirely replace its contents if it does.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f65976cf8345e044488976485c5a6e346af5a578" translate="yes" xml:space="preserve">
          <source>This function will create a file if it does not exist, and will truncate it if it does.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0e1b8893ba63c7e2758784f05b5644780ac55d15" translate="yes" xml:space="preserve">
          <source>This function will ignore all instances of &lt;a href=&quot;enum.errorkind#variant.Interrupted&quot;&gt;&lt;code&gt;ErrorKind::Interrupted&lt;/code&gt;&lt;/a&gt; and will otherwise return any errors returned by &lt;a href=&quot;#tymethod.fill_buf&quot;&gt;&lt;code&gt;fill_buf&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="326c8120454de566fb3a6866a530ebb7b6b992dc" translate="yes" xml:space="preserve">
          <source>This function will never panic, but it may return &lt;a href=&quot;../../result/enum.result#variant.Err&quot;&gt;&lt;code&gt;Err&lt;/code&gt;&lt;/a&gt; if the &lt;a href=&quot;struct.receiver&quot;&gt;&lt;code&gt;Receiver&lt;/code&gt;&lt;/a&gt; has disconnected and is no longer able to receive information.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9fc6b983aea89da54a39cad92dbfed108559d536" translate="yes" xml:space="preserve">
          <source>This function will never return and will immediately terminate the current process. The exit code is passed through to the underlying OS and will be available for consumption by another process.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c4fd0f129a9f8ea495fd3f5d41ad244c1f805fd1" translate="yes" xml:space="preserve">
          <source>This function will not block the calling thread and will only check to see if the child process has exited or not. If the child has exited then on Unix the process ID is reaped. This function is guaranteed to repeatedly return a successful exit status so long as the child has already exited.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="db8a9f6074ffbe2434b96b3349b436c824d317bf" translate="yes" xml:space="preserve">
          <source>This function will not return while other writers or other readers currently have access to the lock.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f40a0312ebfb2b0e54e13329e7ace227d51b5cf1" translate="yes" xml:space="preserve">
          <source>This function will not traverse symlinks if this entry points at a symlink.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c834f424a9053dbdf6234c9da264d70e8ba7b880" translate="yes" xml:space="preserve">
          <source>This function will panic if &lt;code&gt;earlier&lt;/code&gt; is later than &lt;code&gt;self&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="255f788a8373ceb0a89289a41ca323624e5b7999" translate="yes" xml:space="preserve">
          <source>This function will panic if &lt;code&gt;k&lt;/code&gt; is greater than the length of the slice. Note that &lt;code&gt;k == self.len()&lt;/code&gt; does &lt;em&gt;not&lt;/em&gt; panic and is a no-op rotation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="95270b721e4d05b72ba071aee1067eda4042613d" translate="yes" xml:space="preserve">
          <source>This function will panic if &lt;code&gt;mid&lt;/code&gt; is greater than the length of the slice. Note that &lt;code&gt;mid == self.len()&lt;/code&gt; does &lt;em&gt;not&lt;/em&gt; panic and is a no-op rotation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="46e96193daf65415936b126b06264ed8418f5b5e" translate="yes" xml:space="preserve">
          <source>This function will panic if &lt;code&gt;rhs&lt;/code&gt; is 0.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d72d270dceb6908b40e770de6a7cca4ee6d954fb" translate="yes" xml:space="preserve">
          <source>This function will panic if either range exceeds the end of the slice, or if the end of &lt;code&gt;src&lt;/code&gt; is before the start.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ffa5cde970751a9af3f3c95b9bc636f122bbdd4f" translate="yes" xml:space="preserve">
          <source>This function will panic if the capacity would overflow.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b80c161450352b3f264fa270e71aafac41ce5a3b" translate="yes" xml:space="preserve">
          <source>This function will panic if the two slices have different lengths.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f9a04d3eaea11b5bf70c2b1e292fe13090c46ff0" translate="yes" xml:space="preserve">
          <source>This function will read bytes from the underlying stream until the delimiter or EOF is found. Once found, all bytes up to, and including, the delimiter (if found) will be appended to &lt;code&gt;buf&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1dad503d6df9a455b05b17e9982a9b93c55eab53" translate="yes" xml:space="preserve">
          <source>This function will read bytes from the underlying stream until the newline delimiter (the 0xA byte) or EOF is found. Once found, all bytes up to, and including, the delimiter (if found) will be appended to &lt;code&gt;buf&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5509bdb3a49d4f3afca9be3c4e49fc0d8f43d023" translate="yes" xml:space="preserve">
          <source>This function will resume execution of the generator or start execution if it hasn't already. This call will return back into the generator's last suspension point, resuming execution from the latest &lt;code&gt;yield&lt;/code&gt;. The generator will continue executing until it either yields or returns, at which point this function will return.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="379fb0237a1103a33f0bdfcecfb22299eb043557" translate="yes" xml:space="preserve">
          <source>This function will return &lt;code&gt;Ok&lt;/code&gt; with the closure's result if the closure does not panic, and will return &lt;code&gt;Err(cause)&lt;/code&gt; if the closure panics. The &lt;code&gt;cause&lt;/code&gt; returned is the object with which panic was originally invoked.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d89140f93781fe909c3c1a3e0e29b63c7e369dd7" translate="yes" xml:space="preserve">
          <source>This function will return an I/O error if the underlying reader was read, but returned an error.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="53872c0f37fe2cee76394788d7b1f123503054e5" translate="yes" xml:space="preserve">
          <source>This function will return an error if &lt;code&gt;path&lt;/code&gt; does not already exist. Other errors may also be returned according to &lt;a href=&quot;struct.openoptions#method.open&quot;&gt;&lt;code&gt;OpenOptions::open&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="89c6971a5e8debeb3922f37bf3a67af3e6b7d708" translate="yes" xml:space="preserve">
          <source>This function will return an error if the RwLock is poisoned. An RwLock is poisoned whenever a writer panics while holding an exclusive lock. An error will be returned when the lock is acquired.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dd9f12f8f4834cac09e7d8702d9c30c5d7a3ff26" translate="yes" xml:space="preserve">
          <source>This function will return an error if the RwLock is poisoned. An RwLock is poisoned whenever a writer panics while holding an exclusive lock. An error will only be returned if the lock would have otherwise been acquired.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="853f4abcb0adc2f4d392d459e3d4bcbfc1ffde02" translate="yes" xml:space="preserve">
          <source>This function will return an error if the RwLock is poisoned. An RwLock is poisoned whenever a writer panics while holding an exclusive lock. The failure will occur immediately after the lock has been acquired.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="08332f9ce278762f6fd52afefe704489d0688f37" translate="yes" xml:space="preserve">
          <source>This function will return an error if the file is not opened for writing.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b6cdf441223c3eb9f4334399883d69c73ecd1bf4" translate="yes" xml:space="preserve">
          <source>This function will return an error if the mutex being waited on is poisoned when this thread re-acquires the lock. For more information, see information about &lt;a href=&quot;struct.mutex#poisoning&quot;&gt;poisoning&lt;/a&gt; on the &lt;a href=&quot;struct.mutex&quot;&gt;&lt;code&gt;Mutex&lt;/code&gt;&lt;/a&gt; type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="27a931587ff628dc51ea9585254e81a44150f056" translate="yes" xml:space="preserve">
          <source>This function will return an error if the supplied bytes contain an internal 0 byte. The &lt;a href=&quot;struct.nulerror&quot;&gt;&lt;code&gt;NulError&lt;/code&gt;&lt;/a&gt; returned will contain the bytes as well as the position of the nul byte.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dbf84289e9d9e4926b496bd897b3083ec6312b71" translate="yes" xml:space="preserve">
          <source>This function will return an error if the user lacks permission change attributes on the underlying file. It may also return an error in other os-specific unspecified cases.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6020fefae74dafb3cbf7677aedde54d28946007d" translate="yes" xml:space="preserve">
          <source>This function will return an error immediately if any call to &lt;code&gt;read&lt;/code&gt; or &lt;code&gt;write&lt;/code&gt; returns an error. All instances of &lt;code&gt;ErrorKind::Interrupted&lt;/code&gt; are handled by this function and the underlying operation is retried.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="789ed5daa8073ac179354d082eb69d8ff28cdee6" translate="yes" xml:space="preserve">
          <source>This function will return an error in the following situations, but is not limited to just these cases:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6c2926688126ed0bb4700cfc41330adcd34075d1" translate="yes" xml:space="preserve">
          <source>This function will return an error under a number of different circumstances. Some of these error conditions are listed here, together with their &lt;a href=&quot;../io/enum.errorkind&quot;&gt;&lt;code&gt;ErrorKind&lt;/code&gt;&lt;/a&gt;. The mapping to &lt;a href=&quot;../io/enum.errorkind&quot;&gt;&lt;code&gt;ErrorKind&lt;/code&gt;&lt;/a&gt;s is not part of the compatibility contract of the function, especially the &lt;code&gt;Other&lt;/code&gt; kind might change to more specific kinds in the future.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b6a8bd83b584fa0f13cb1bcd08f12c3e0060dff9" translate="yes" xml:space="preserve">
          <source>This function will return an instance of &lt;a href=&quot;struct.error&quot;&gt;&lt;code&gt;Error&lt;/code&gt;&lt;/a&gt; on error.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6fae4edeb2bc2b830762c223977c0f9e31e7f71d" translate="yes" xml:space="preserve">
          <source>This function will return any I/O error reported while formatting.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="82d9dcac7df30707ace2de701aba5471ae21281c" translate="yes" xml:space="preserve">
          <source>This function will return the first error of non-&lt;a href=&quot;../../../io/enum.errorkind#variant.Interrupted&quot;&gt;&lt;code&gt;ErrorKind::Interrupted&lt;/code&gt;&lt;/a&gt; kind that &lt;a href=&quot;#tymethod.write_at&quot;&gt;&lt;code&gt;write_at&lt;/code&gt;&lt;/a&gt; returns.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e505864f4a28d60809a69e771d2b212f82c7410c" translate="yes" xml:space="preserve">
          <source>This function will return the first error of non-&lt;a href=&quot;enum.errorkind#variant.Interrupted&quot;&gt;&lt;code&gt;ErrorKind::Interrupted&lt;/code&gt;&lt;/a&gt; kind that &lt;a href=&quot;#tymethod.write&quot;&gt;&lt;code&gt;write&lt;/code&gt;&lt;/a&gt; returns.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="749cf49b6adfac5a93f23dcbbade901579686611" translate="yes" xml:space="preserve">
          <source>This function will still &lt;code&gt;panic!()&lt;/code&gt; if the key is uninitialized and the key's initializer panics.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aa2dcaf81660e38d976b3c073799f64e35c409b8" translate="yes" xml:space="preserve">
          <source>This function will traverse symbolic links to query information about the destination file.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7a60f9a71c97e3c48d6ddbb61757095cfb7454e6" translate="yes" xml:space="preserve">
          <source>This function will traverse symbolic links to query information about the destination file. In case of broken symbolic links this will return &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2144ac018e241484dd88280c401709723264165b" translate="yes" xml:space="preserve">
          <source>This function will unsafely assume the pointer &lt;code&gt;src&lt;/code&gt; is valid for &lt;a href=&quot;fn.size_of&quot;&gt;&lt;code&gt;size_of::&amp;lt;U&amp;gt;&lt;/code&gt;&lt;/a&gt; bytes by transmuting &lt;code&gt;&amp;amp;T&lt;/code&gt; to &lt;code&gt;&amp;amp;U&lt;/code&gt; and then reading the &lt;code&gt;&amp;amp;U&lt;/code&gt;. It will also unsafely create a copy of the contained value instead of moving out of &lt;code&gt;src&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d5bb3f5f774e85331b120930c24070df4dbb7ef1" translate="yes" xml:space="preserve">
          <source>This function will wrap the provided &lt;code&gt;ptr&lt;/code&gt; with a &lt;code&gt;CStr&lt;/code&gt; wrapper, which allows inspection and interoperation of non-owned C strings. This method is unsafe for a number of reasons:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eb6de22f90abba9d8b2e22f07508357043cd45b1" translate="yes" xml:space="preserve">
          <source>This function will yield errors whenever &lt;a href=&quot;#method.read_until&quot;&gt;&lt;code&gt;read_until&lt;/code&gt;&lt;/a&gt; would have also yielded an error.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="761c3823fedfe961f64b60f5bbf8dadb1c015978" translate="yes" xml:space="preserve">
          <source>This function works on a best-effort basis, and may return false even when the &lt;code&gt;Waker&lt;/code&gt;s would awaken the same task. However, if this function returns &lt;code&gt;true&lt;/code&gt;, it is guaranteed that the &lt;code&gt;Waker&lt;/code&gt;s will awaken the same task.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7ae0840523d6333733f66bb75a006add83e1ec36" translate="yes" xml:space="preserve">
          <source>This function works similar to &lt;code&gt;Iterator::filter()&lt;/code&gt;. You can imagine the &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt; being an iterator over one or zero elements. &lt;code&gt;filter()&lt;/code&gt; lets you decide which elements to keep.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="113d936138ddc7ae4f63a1a50d8105ac5a7add0d" translate="yes" xml:space="preserve">
          <source>This function&amp;rsquo;s signature is less cluttered: the function name, parameter list, and return type are close together, similar to a function without lots of trait bounds.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="59db1f1ce2d556d00a44653625d9c4310aa82a71" translate="yes" xml:space="preserve">
          <source>This function, &lt;code&gt;first_word&lt;/code&gt;, has a &lt;code&gt;&amp;amp;String&lt;/code&gt; as a parameter. We don&amp;rsquo;t want ownership, so this is fine. But what should we return? We don&amp;rsquo;t really have a way to talk about &lt;em&gt;part&lt;/em&gt; of a string. However, we could return the index of the end of the word. Let&amp;rsquo;s try that, as shown in Listing 4-7.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c0b65dd63b8d87baa6cb2781b4c83fe9b710f211" translate="yes" xml:space="preserve">
          <source>This function, unlike &lt;code&gt;spawn&lt;/code&gt;, will &lt;strong&gt;not&lt;/strong&gt;&lt;code&gt;fork&lt;/code&gt; the process to create a new child. Like spawn, however, the default behavior for the stdio descriptors will be to inherited from the current process.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a7e07fc3dba284598652a13174e554562e5525f8" translate="yes" xml:space="preserve">
          <source>This handle encapsulates a &lt;a href=&quot;struct.rawwaker&quot;&gt;&lt;code&gt;RawWaker&lt;/code&gt;&lt;/a&gt; instance, which defines the executor-specific wakeup behavior.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d605d26d55dc2758f0b6de9e17a49a349f074534" translate="yes" xml:space="preserve">
          <source>This handle implements both the &lt;a href=&quot;trait.read&quot;&gt;&lt;code&gt;Read&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;trait.bufread&quot;&gt;&lt;code&gt;BufRead&lt;/code&gt;&lt;/a&gt; traits, and is constructed via the &lt;a href=&quot;struct.stdin#method.lock&quot;&gt;&lt;code&gt;Stdin::lock&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f7258bae2e88ec63ae3dd338b65d64451a9b331b" translate="yes" xml:space="preserve">
          <source>This handle implements the &lt;a href=&quot;trait.write&quot;&gt;&lt;code&gt;Write&lt;/code&gt;&lt;/a&gt; trait, and is constructed via the &lt;a href=&quot;struct.stdout#method.lock&quot;&gt;&lt;code&gt;Stdout::lock&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d288bcdc54960c2a1210bed705519ebb1c8b509b" translate="yes" xml:space="preserve">
          <source>This handle implements the &lt;code&gt;Read&lt;/code&gt; trait, but beware that concurrent reads of &lt;code&gt;Stdin&lt;/code&gt; must be executed with care.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="01441d3c1d26b75fb46c2c721477af0652ee7979" translate="yes" xml:space="preserve">
          <source>This handle implements the &lt;code&gt;Write&lt;/code&gt; trait and is constructed via the &lt;a href=&quot;struct.stderr#method.lock&quot;&gt;&lt;code&gt;Stderr::lock&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2708f4eb8582ea4d70309feff62a1d2748e13184" translate="yes" xml:space="preserve">
          <source>This handle is not buffered.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6c48d5f61a1b6b181a01656b1e94697dc7bb9249" translate="yes" xml:space="preserve">
          <source>This happens because the pointer returned by &lt;code&gt;as_ptr&lt;/code&gt; does not carry any lifetime information and the &lt;a href=&quot;struct.cstring&quot;&gt;&lt;code&gt;CString&lt;/code&gt;&lt;/a&gt; is deallocated immediately after the &lt;code&gt;CString::new(&quot;Hello&quot;).expect(&quot;CString::new failed&quot;).as_ptr()&lt;/code&gt; expression is evaluated. To fix the problem, bind the &lt;code&gt;CString&lt;/code&gt; to a local variable:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6047b82331195849fba72da79674452a117df64d" translate="yes" xml:space="preserve">
          <source>This happens when a trait has a method like the following:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="863bad715d4f6d1bd75efa3884a2cc5b250ca381" translate="yes" xml:space="preserve">
          <source>This has the same behavior as the &lt;a href=&quot;../string/struct.string#method.push_str&quot;&gt;&lt;code&gt;push_str&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6a3c452ab4ee63f33d895b0f991faaa23887feb8" translate="yes" xml:space="preserve">
          <source>This has the same behavior as the &lt;a href=&quot;struct.string#method.push_str&quot;&gt;&lt;code&gt;push_str&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b58a8c2add590746e5048b4f132cbbc19047500f" translate="yes" xml:space="preserve">
          <source>This has the same effect as &lt;a href=&quot;union.maybeuninit#method.zeroed&quot;&gt;&lt;code&gt;MaybeUninit::zeroed().assume_init()&lt;/code&gt;&lt;/a&gt;. It is useful for FFI sometimes, but should generally be avoided.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c7eb4340faf9e85d2da20b4776ce2bebbe29c12a" translate="yes" xml:space="preserve">
          <source>This has the same lifetime as the original slice, and so the iterator can continue to be used while this exists.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="65d35375dd8acb85bc9eba434584e8313fb0a245" translate="yes" xml:space="preserve">
          <source>This hasher is not guaranteed to be the same as all other &lt;code&gt;DefaultHasher&lt;/code&gt; instances, but is the same as all other &lt;code&gt;DefaultHasher&lt;/code&gt; instances created through &lt;code&gt;new&lt;/code&gt; or &lt;code&gt;default&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="90feee4915436dfe2be982f4c15a9da7834c5004" translate="yes" xml:space="preserve">
          <source>This implementation is specialized for slice iterators, where it uses &lt;a href=&quot;../primitive.slice#method.copy_from_slice&quot;&gt;&lt;code&gt;copy_from_slice&lt;/code&gt;&lt;/a&gt; to append the entire slice at once.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0b6b99c1c8632506c647afb83336adc1ee13b73f" translate="yes" xml:space="preserve">
          <source>This information corresponds to the &lt;code&gt;sin6_flowinfo&lt;/code&gt; field in C's &lt;code&gt;netinet/in.h&lt;/code&gt;, as specified in &lt;a href=&quot;https://tools.ietf.org/html/rfc2553#section-3.3&quot;&gt;IETF RFC 2553, Section 3.3&lt;/a&gt;. It combines information about the flow label and the traffic class as specified in &lt;a href=&quot;https://tools.ietf.org/html/rfc2460&quot;&gt;IETF RFC 2460&lt;/a&gt;, respectively &lt;a href=&quot;https://tools.ietf.org/html/rfc2460#section-6&quot;&gt;Section 6&lt;/a&gt; and &lt;a href=&quot;https://tools.ietf.org/html/rfc2460#section-7&quot;&gt;Section 7&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3af31b70c11ef4a3b608a04beaf7ba9284e068c3" translate="yes" xml:space="preserve">
          <source>This information corresponds to the &lt;code&gt;sin6_scope_id&lt;/code&gt; field in C's &lt;code&gt;netinet/in.h&lt;/code&gt;, as specified in &lt;a href=&quot;https://tools.ietf.org/html/rfc2553#section-3.3&quot;&gt;IETF RFC 2553, Section 3.3&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="63ed31757d724807cc9238c95c5432cd39c9735a" translate="yes" xml:space="preserve">
          <source>This instance may reach &lt;code&gt;EOF&lt;/code&gt; after reading fewer bytes than indicated by this method if the underlying &lt;a href=&quot;trait.read&quot;&gt;&lt;code&gt;Read&lt;/code&gt;&lt;/a&gt; instance reaches EOF.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1fa64cf4a4634521305dce783239fdfdeec13027" translate="yes" xml:space="preserve">
          <source>This is a &quot;helper marker trait&quot; used to provide impl blocks for the &lt;a href=&quot;trait.unwindsafe&quot;&gt;&lt;code&gt;UnwindSafe&lt;/code&gt;&lt;/a&gt; trait, for more information see that documentation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dca2a0780f1a583478627dae521a3cd19fa18332" translate="yes" xml:space="preserve">
          <source>This is a convenience function for using &lt;a href=&quot;struct.file#method.create&quot;&gt;&lt;code&gt;File::create&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../io/trait.write#method.write_all&quot;&gt;&lt;code&gt;write_all&lt;/code&gt;&lt;/a&gt; with fewer imports.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="187131cff0eb9e697908b49a26f702ec337c3799" translate="yes" xml:space="preserve">
          <source>This is a convenience function for using &lt;a href=&quot;struct.file#method.open&quot;&gt;&lt;code&gt;File::open&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../io/trait.read#method.read_to_end&quot;&gt;&lt;code&gt;read_to_end&lt;/code&gt;&lt;/a&gt; with fewer imports and without an intermediate variable. It pre-allocates a buffer based on the file size when available, so it is generally faster than reading into a vector created with &lt;code&gt;Vec::new()&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9c7392177420bfa03e5c328d086366669dabd90c" translate="yes" xml:space="preserve">
          <source>This is a convenience function for using &lt;a href=&quot;struct.file#method.open&quot;&gt;&lt;code&gt;File::open&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../io/trait.read#method.read_to_string&quot;&gt;&lt;code&gt;read_to_string&lt;/code&gt;&lt;/a&gt; with fewer imports and without an intermediate variable. It pre-allocates a buffer based on the file size when available, so it is generally faster than reading into a string created with &lt;code&gt;String::new()&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dac9be08ca6ab3c0d6956dc411e028285b59848d" translate="yes" xml:space="preserve">
          <source>This is a convenience function that coerces errors to false. If you want to check errors, call &lt;a href=&quot;../fs/fn.metadata&quot;&gt;fs::metadata&lt;/a&gt; and handle its Result. Then call &lt;a href=&quot;../fs/struct.metadata#method.is_dir&quot;&gt;fs::Metadata::is_dir&lt;/a&gt; if it was Ok.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="78d539aab76737f8cf396eefb6d1ce6f5b6f255b" translate="yes" xml:space="preserve">
          <source>This is a convenience function that coerces errors to false. If you want to check errors, call &lt;a href=&quot;../fs/fn.metadata&quot;&gt;fs::metadata&lt;/a&gt; and handle its Result. Then call &lt;a href=&quot;../fs/struct.metadata#method.is_file&quot;&gt;fs::Metadata::is_file&lt;/a&gt; if it was Ok.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="63bfc9edacf3bb27391de3d729c554b4c3c2df6a" translate="yes" xml:space="preserve">
          <source>This is a convenience function that coerces errors to false. If you want to check errors, call &lt;a href=&quot;../fs/fn.metadata&quot;&gt;fs::metadata&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="748753921bdcefd01924d5e43ae2dad4f042e3b3" translate="yes" xml:space="preserve">
          <source>This is a cost-free conversion.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="29fa7c971247c161eeccc64d10b730dfdf57cf6f" translate="yes" xml:space="preserve">
          <source>This is a curious macro which is used to safely pass around an opaque object describing the format string. This object does not require any heap allocations to create, and it only references information on the stack. Under the hood, all of the related macros are implemented in terms of this. First off, some example usage is:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a5cb34f6e2e869f23ba4b01f87c2789e85bd0de1" translate="yes" xml:space="preserve">
          <source>This is a generic method to go from &lt;code&gt;&amp;amp;Pin&amp;lt;Pointer&amp;lt;T&amp;gt;&amp;gt;&lt;/code&gt; to &lt;code&gt;Pin&amp;lt;&amp;amp;T&amp;gt;&lt;/code&gt;. It is safe because, as part of the contract of &lt;code&gt;Pin::new_unchecked&lt;/code&gt;, the pointee cannot move after &lt;code&gt;Pin&amp;lt;Pointer&amp;lt;T&amp;gt;&amp;gt;&lt;/code&gt; got created. &quot;Malicious&quot; implementations of &lt;code&gt;Pointer::Deref&lt;/code&gt; are likewise ruled out by the contract of &lt;code&gt;Pin::new_unchecked&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="56c4f5951c7828ae5ee50cc814a919ce365cfc61" translate="yes" xml:space="preserve">
          <source>This is a generic method to go from &lt;code&gt;&amp;amp;mut Pin&amp;lt;Pointer&amp;lt;T&amp;gt;&amp;gt;&lt;/code&gt; to &lt;code&gt;Pin&amp;lt;&amp;amp;mut T&amp;gt;&lt;/code&gt;. It is safe because, as part of the contract of &lt;code&gt;Pin::new_unchecked&lt;/code&gt;, the pointee cannot move after &lt;code&gt;Pin&amp;lt;Pointer&amp;lt;T&amp;gt;&amp;gt;&lt;/code&gt; got created. &quot;Malicious&quot; implementations of &lt;code&gt;Pointer::DerefMut&lt;/code&gt; are likewise ruled out by the contract of &lt;code&gt;Pin::new_unchecked&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="89763ee5b7958c417ffa6362fe62836bd12504df" translate="yes" xml:space="preserve">
          <source>This is a great time to build a more substantial program to get used to reading and writing Rust code. So, in Chapter 2, we&amp;rsquo;ll build a guessing game program. If you would rather start by learning how common programming concepts work in Rust, see Chapter 3 and then return to Chapter 2.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="88ca2eb8b4f8037d6f9bc35aac9a7c204a66255a" translate="yes" xml:space="preserve">
          <source>This is a larger example that implements &lt;a href=&quot;http://en.wikipedia.org/wiki/Dijkstra%27s_algorithm&quot;&gt;Dijkstra's algorithm&lt;/a&gt; to solve the &lt;a href=&quot;http://en.wikipedia.org/wiki/Shortest_path_problem&quot;&gt;shortest path problem&lt;/a&gt; on a &lt;a href=&quot;http://en.wikipedia.org/wiki/Directed_graph&quot;&gt;directed graph&lt;/a&gt;. It shows how to use &lt;a href=&quot;struct.binaryheap&quot;&gt;&lt;code&gt;BinaryHeap&lt;/code&gt;&lt;/a&gt; with custom types.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="26c511330b7bfd645fe1ae62ba92f808907b836b" translate="yes" xml:space="preserve">
          <source>This is a low-level operation that maintains none of the normal invariants of the type. Normally changing the length of a vector is done using one of the safe operations instead, such as &lt;a href=&quot;#method.truncate&quot;&gt;&lt;code&gt;truncate&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#method.resize&quot;&gt;&lt;code&gt;resize&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#method.extend-1&quot;&gt;&lt;code&gt;extend&lt;/code&gt;&lt;/a&gt;, or &lt;a href=&quot;#method.clear&quot;&gt;&lt;code&gt;clear&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e5a83358209b9d321dd626221b446c20e90a835f" translate="yes" xml:space="preserve">
          <source>This is a lower-level version of &lt;a href=&quot;enum.entry&quot;&gt;&lt;code&gt;Entry&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d779513c1e09f65a072541be686df3371c86d19d" translate="yes" xml:space="preserve">
          <source>This is a minimal HTML5 document with a heading and some text. To return this from the server when a request is received, we&amp;rsquo;ll modify &lt;code&gt;handle_connection&lt;/code&gt; as shown in Listing 20-5 to read the HTML file, add it to the response as a body, and send it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3a7bcaac4b774ad822d1d354cccc21a6015fca6e" translate="yes" xml:space="preserve">
          <source>This is a parameter for the &quot;minimum width&quot; that the format should take up. If the value's string does not fill up this many characters, then the padding specified by fill/alignment will be used to take up the required space.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b084ef158428b63f0e7eeac68dee8b3d095bdb3c" translate="yes" xml:space="preserve">
          <source>This is a situation in which interior mutability can help! We&amp;rsquo;ll store the &lt;code&gt;sent_messages&lt;/code&gt; within a &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt;, and then the &lt;code&gt;send&lt;/code&gt; message will be able to modify &lt;code&gt;sent_messages&lt;/code&gt; to store the messages we&amp;rsquo;ve seen. Listing 15-22 shows what that looks like:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e698a362ad50285269b0f450993154391ed3fb9c" translate="yes" xml:space="preserve">
          <source>This is a syntax error at the level of attribute declarations. The proper syntax for macro imports is the following:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7207d1f263b95ee330100ad60d168c6bbd00e341" translate="yes" xml:space="preserve">
          <source>This is a very simple case, of course. In more complex cases, we may wish to have more than one reference to the value that was borrowed -- in those cases, something like the &lt;code&gt;Rc&lt;/code&gt; or &lt;code&gt;Arc&lt;/code&gt; types may be useful.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="795aa426a1aadc3299f800d117f15424e179c91c" translate="yes" xml:space="preserve">
          <source>This is a wrapper around a kind of pointer which makes that pointer &quot;pin&quot; its value in place, preventing the value referenced by that pointer from being moved unless it implements &lt;a href=&quot;../marker/trait.unpin&quot;&gt;&lt;code&gt;Unpin&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="40cc1dd050d81853f1d6473844a8f5105ed4ba71" translate="yes" xml:space="preserve">
          <source>This is also available via &lt;a href=&quot;../convert/trait.from&quot;&gt;&lt;code&gt;From&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="69c7de76e4d6cac4ead699615a01132090109223" translate="yes" xml:space="preserve">
          <source>This is an &lt;code&gt;O(n)&lt;/code&gt; operation as it requires copying every element in the buffer.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7714852846e41026b7148ab604a67c761a44e811" translate="yes" xml:space="preserve">
          <source>This is an &lt;code&gt;O(n)&lt;/code&gt; operation, as it requires copying every element in the buffer.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e7773930b7607b5b74b44eb47accc2cfca7d33e4" translate="yes" xml:space="preserve">
          <source>This is an &lt;em&gt;unsized&lt;/em&gt; type, meaning that it must always be used behind a pointer like &lt;code&gt;&amp;amp;&lt;/code&gt; or &lt;a href=&quot;../boxed/struct.box&quot;&gt;&lt;code&gt;Box&lt;/code&gt;&lt;/a&gt;. For an owned version of this type, see &lt;a href=&quot;struct.pathbuf&quot;&gt;&lt;code&gt;PathBuf&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ae5b715f0a76526280a5abae050e91bd520680ba" translate="yes" xml:space="preserve">
          <source>This is an absolute path starting with &lt;code&gt;std&lt;/code&gt;, the name of the standard library crate.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fb3851cbc0fb3af560d20b0226cbd7a0adc72483" translate="yes" xml:space="preserve">
          <source>This is an alias to &lt;a href=&quot;../fs/fn.canonicalize&quot;&gt;&lt;code&gt;fs::canonicalize&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ccff757092656f4cd5645f893d07b3a2270144b9" translate="yes" xml:space="preserve">
          <source>This is an alias to &lt;a href=&quot;../fs/fn.metadata&quot;&gt;&lt;code&gt;fs::metadata&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fe9cf4a133a88b8bc470c4394f4eb8cf3b306e68" translate="yes" xml:space="preserve">
          <source>This is an alias to &lt;a href=&quot;../fs/fn.read_dir&quot;&gt;&lt;code&gt;fs::read_dir&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f461dafd60906d9babd38850b381951321bafa0a" translate="yes" xml:space="preserve">
          <source>This is an alias to &lt;a href=&quot;../fs/fn.read_link&quot;&gt;&lt;code&gt;fs::read_link&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8a772f821d093dc45f53501fe5deb3218dd74356" translate="yes" xml:space="preserve">
          <source>This is an alias to &lt;a href=&quot;../fs/fn.symlink_metadata&quot;&gt;&lt;code&gt;fs::symlink_metadata&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d34ac7564172d2ff8117857aff9df3320c42fae5" translate="yes" xml:space="preserve">
          <source>This is an associated function that needs to be used as &lt;code&gt;Ref::clone(...)&lt;/code&gt;. A &lt;code&gt;Clone&lt;/code&gt; implementation or a method would interfere with the widespread use of &lt;code&gt;r.borrow().clone()&lt;/code&gt; to clone the contents of a &lt;code&gt;RefCell&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f83e3e547dadb3f845f93bfeaf6231ee030e91c8" translate="yes" xml:space="preserve">
          <source>This is an associated function that needs to be used as &lt;code&gt;Ref::map(...)&lt;/code&gt;. A method would interfere with methods of the same name on the contents of a &lt;code&gt;RefCell&lt;/code&gt; used through &lt;code&gt;Deref&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2f18aedd0b02030c35b1012078adf973833d874e" translate="yes" xml:space="preserve">
          <source>This is an associated function that needs to be used as &lt;code&gt;Ref::map_split(...)&lt;/code&gt;. A method would interfere with methods of the same name on the contents of a &lt;code&gt;RefCell&lt;/code&gt; used through &lt;code&gt;Deref&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="14ab5139ea01a60d2224bebc358fd7f5a09aee7b" translate="yes" xml:space="preserve">
          <source>This is an associated function that needs to be used as &lt;code&gt;RefMut::map(...)&lt;/code&gt;. A method would interfere with methods of the same name on the contents of a &lt;code&gt;RefCell&lt;/code&gt; used through &lt;code&gt;Deref&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="202f23e551bc61ba34f51a486b60ddfce30150ab" translate="yes" xml:space="preserve">
          <source>This is an associated function that needs to be used as &lt;code&gt;RefMut::map_split(...)&lt;/code&gt;. A method would interfere with methods of the same name on the contents of a &lt;code&gt;RefCell&lt;/code&gt; used through &lt;code&gt;Deref&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fb3bd037be08bb82591900e7ddf468637a2b8c80" translate="yes" xml:space="preserve">
          <source>This is appropriate for initializing uninitialized memory, or overwriting memory that has previously been &lt;a href=&quot;fn.read&quot;&gt;&lt;code&gt;read&lt;/code&gt;&lt;/a&gt; from.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="856709efbf0ee049257184bc9760c0b3d18a43eb" translate="yes" xml:space="preserve">
          <source>This is appropriate for initializing uninitialized memory, or overwriting memory that has previously been read with &lt;a href=&quot;fn.read_unaligned&quot;&gt;&lt;code&gt;read_unaligned&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9049d14f9f0cb6f47694e4f8dd6256baa32e595c" translate="yes" xml:space="preserve">
          <source>This is based on &lt;code&gt;malloc&lt;/code&gt; on Unix platforms and &lt;code&gt;HeapAlloc&lt;/code&gt; on Windows, plus related functions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d9e17b1971fcc8ebac923ca9bdcdbe86fd7ccc27" translate="yes" xml:space="preserve">
          <source>This is because &lt;code&gt;AddAssign&lt;/code&gt; is not automatically implemented, so you need to manually implement it for your type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5c0cfc8e697e9e04f2ac8988522860bd36ed371a" translate="yes" xml:space="preserve">
          <source>This is because cell types do operations that are not thread-safe. Due to this, they don't implement Sync and thus can't be placed in statics.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="43247ccf0e7189f6826d62c195b63176c827f652" translate="yes" xml:space="preserve">
          <source>This is because of a type mismatch between the associated type of some trait (e.g., &lt;code&gt;T::Bar&lt;/code&gt;, where &lt;code&gt;T&lt;/code&gt; implements &lt;code&gt;trait Quux { type Bar; }&lt;/code&gt;) and another type &lt;code&gt;U&lt;/code&gt; that is required to be equal to &lt;code&gt;T::Bar&lt;/code&gt;, but is not. Examples follow.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a641717e833808f9f0bc4f5f362a54b6a1faff5b" translate="yes" xml:space="preserve">
          <source>This is borrow-generalized version of &lt;code&gt;Clone::clone_from&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="834216017331c86ca1e125eb990783c9079a99f6" translate="yes" xml:space="preserve">
          <source>This is called the &amp;ldquo;train model&amp;rdquo; because every six weeks, a release &amp;ldquo;leaves the station&amp;rdquo;, but still has to take a journey through the beta channel before it arrives as a stable release.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a9e339d64ba30c9973394f6282049233c7be4f71" translate="yes" xml:space="preserve">
          <source>This is catastrophic, it means we can first pin the content of the &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt; (using &lt;code&gt;RefCell::get_pin_mut&lt;/code&gt;) and then move that content using the mutable reference we got later.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="67913f9219472099fcca84773f5f227006ffbcce" translate="yes" xml:space="preserve">
          <source>This is commonly used to adapt a single value generator into a &lt;a href=&quot;trait.iterator#method.chain&quot;&gt;&lt;code&gt;chain&lt;/code&gt;&lt;/a&gt; of other kinds of iteration. Maybe you have an iterator that covers almost everything, but you need an extra special case. Maybe you have a function which works on iterators, but you only need to process one value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="764e0240ad7ec9a9585ed8305ceb8e8099f2723d" translate="yes" xml:space="preserve">
          <source>This is commonly used to adapt a single value into a &lt;a href=&quot;trait.iterator#method.chain&quot;&gt;&lt;code&gt;chain&lt;/code&gt;&lt;/a&gt; of other kinds of iteration. Maybe you have an iterator that covers almost everything, but you need an extra special case. Maybe you have a function which works on iterators, but you only need to process one value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f239b530d28c30ec1070f1658b16620a287e3251" translate="yes" xml:space="preserve">
          <source>This is correct (explicit):</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7d6342cfa6f9200a801992dcf925b5cee5be4a5b" translate="yes" xml:space="preserve">
          <source>This is currently identical to &lt;code&gt;transmute::&amp;lt;f32, u32&amp;gt;(self)&lt;/code&gt; on all platforms.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a48f92d085d1c5423be432a065e6504acd5a4a36" translate="yes" xml:space="preserve">
          <source>This is currently identical to &lt;code&gt;transmute::&amp;lt;f64, u64&amp;gt;(self)&lt;/code&gt; on all platforms.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="918c5990ef12f35794f26c0b83e42a5d2ef0c694" translate="yes" xml:space="preserve">
          <source>This is currently identical to &lt;code&gt;transmute::&amp;lt;u32, f32&amp;gt;(v)&lt;/code&gt; on all platforms. It turns out this is incredibly portable, for two reasons:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="00309d71e504692e129d008c7a1eff96961c44fc" translate="yes" xml:space="preserve">
          <source>This is currently identical to &lt;code&gt;transmute::&amp;lt;u64, f64&amp;gt;(v)&lt;/code&gt; on all platforms. It turns out this is incredibly portable, for two reasons:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="de7179edea4813efbd79fdfefd23f0fcc07d0700" translate="yes" xml:space="preserve">
          <source>This is defined in &lt;a href=&quot;https://tools.ietf.org/html/rfc5737&quot;&gt;IETF RFC 5737&lt;/a&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="59a6ad6e6ae513088e0c1bb8ed9888b474a9dbba" translate="yes" xml:space="preserve">
          <source>This is designed to be used in conjunction with &lt;a href=&quot;fn.catch_unwind&quot;&gt;&lt;code&gt;catch_unwind&lt;/code&gt;&lt;/a&gt; to, for example, carry a panic across a layer of C code.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5fdeff8202418046160b5ede029f4ae17e4cb706" translate="yes" xml:space="preserve">
          <source>This is different than the &lt;code&gt;C&lt;/code&gt; representation because a struct with the &lt;code&gt;C&lt;/code&gt; representation will always have the ABI of a &lt;code&gt;C&lt;/code&gt;&lt;code&gt;struct&lt;/code&gt; while, for example, a struct with the &lt;code&gt;transparent&lt;/code&gt; representation with a primitive field will have the ABI of the primitive field.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f40a48629593c80076df828df6524a31bbb5832c" translate="yes" xml:space="preserve">
          <source>This is done as if by the Euclidean division algorithm -- given &lt;code&gt;r = self.rem_euclid(rhs)&lt;/code&gt;, &lt;code&gt;self = rhs * self.div_euclid(rhs) + r&lt;/code&gt;, and &lt;code&gt;0 &amp;lt;= r &amp;lt; abs(rhs)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="261341fb7dbde0853cc1e229f30dada63a712ac0" translate="yes" xml:space="preserve">
          <source>This is enforced by the Rust compiler. However, there are situations where this rule is not flexible enough. Sometimes it is required to have multiple references to an object and yet mutate it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1a48a3285621637ef35ee331d4de4979ad866379" translate="yes" xml:space="preserve">
          <source>This is equivalent to &lt;code&gt;self.seek(SeekFrom::Current(0))&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ea3c08c47d3f2c239e1b0612d35fd093489ce76f" translate="yes" xml:space="preserve">
          <source>This is equivalent to &lt;code&gt;to_ascii_lowercase(a) == to_ascii_lowercase(b)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a97a7d1bcb8cd7cc77582edff43cedf5b5f9e7ec" translate="yes" xml:space="preserve">
          <source>This is equivalent to adding the result of &lt;code&gt;padding_needed_for&lt;/code&gt; to the layout's current size.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f6cc1d085b275d07a515f10b6c1293ccce68e246" translate="yes" xml:space="preserve">
          <source>This is equivalent to sending a SIGKILL on Unix platforms.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dbb80b753a6a285f62ca3be46d0ca7ebb71f7211" translate="yes" xml:space="preserve">
          <source>This is equivalent to using a &lt;a href=&quot;../../book/ch03-05-control-flow#looping-through-a-collection-with-for&quot;&gt;&lt;code&gt;for&lt;/code&gt;&lt;/a&gt; loop on the iterator, although &lt;code&gt;break&lt;/code&gt; and &lt;code&gt;continue&lt;/code&gt; are not possible from a closure. It's generally more idiomatic to use a &lt;code&gt;for&lt;/code&gt; loop, but &lt;code&gt;for_each&lt;/code&gt; may be more legible when processing items at the end of longer iterator chains. In some cases &lt;code&gt;for_each&lt;/code&gt; may also be faster than a loop, because it will use internal iteration on adaptors like &lt;code&gt;Chain&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0d5fc7a87669eb5a575d2a14569feb14339d998c" translate="yes" xml:space="preserve">
          <source>This is essentially the reversed version of &lt;a href=&quot;trait.iterator#method.nth&quot;&gt;&lt;code&gt;nth&lt;/code&gt;&lt;/a&gt;. Although like most indexing operations, the count starts from zero, so &lt;code&gt;nth_back(0)&lt;/code&gt; returns the first value fro the end, &lt;code&gt;nth_back(1)&lt;/code&gt; the second, and so on.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="da357ed847b3be924604524d54de90650dc840c5" translate="yes" xml:space="preserve">
          <source>This is exactly the kind of guarantee that the intrusive linked list from the previous section needs to function correctly.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bb45c58beba541079b29f983c2bd8c56db26b71e" translate="yes" xml:space="preserve">
          <source>This is exploited by the compiler for various optimizations, such as eliding run-time checks and optimizing &lt;code&gt;enum&lt;/code&gt; layout.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2800cba431c3f0317ff7290328c22feda7e8a245" translate="yes" xml:space="preserve">
          <source>This is fixed by declaring the impl block like this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7800b5b60ece10a2bb3977b34790a457f9ba1d9b" translate="yes" xml:space="preserve">
          <source>This is generally created by methods like &lt;a href=&quot;struct.mutex#method.lock&quot;&gt;&lt;code&gt;Mutex::lock&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;struct.rwlock#method.read&quot;&gt;&lt;code&gt;RwLock::read&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d04e3acde7f8ef92dfb6b7b52b3e3c3811cad1e0" translate="yes" xml:space="preserve">
          <source>This is generally not recommended, use with caution! For a safe alternative see &lt;a href=&quot;#method.get&quot;&gt;&lt;code&gt;get&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4bd5c92d6bc3bc69b3d544b464184377050cce05" translate="yes" xml:space="preserve">
          <source>This is generally not recommended, use with caution! For a safe alternative see &lt;a href=&quot;#method.get_mut&quot;&gt;&lt;code&gt;get_mut&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="60f2e569769a80d9853e1327c13dd3289346f0be" translate="yes" xml:space="preserve">
          <source>This is generally not recommended, use with caution! For a safe alternative see &lt;a href=&quot;primitive.str&quot;&gt;&lt;code&gt;str&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;ops/trait.index&quot;&gt;&lt;code&gt;Index&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5835397a3648f1790072b1697b1686de073dd8a5" translate="yes" xml:space="preserve">
          <source>This is highly unsafe, due to the number of invariants that aren't checked:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="75907ab0f8297b43f4704528d57293015e32b770" translate="yes" xml:space="preserve">
          <source>This is implemented as an intrinsic to avoid converting to and from an integer, since the conversion inhibits certain optimizations.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="11f5a22e0c8092b2e830a298d3f000dd528e1ac9" translate="yes" xml:space="preserve">
          <source>This is implemented as an intrinsic to avoid converting to and from an integer, since the conversion would throw away aliasing information.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0d148f9608c961194f7d8d82b9462e528bb48245" translate="yes" xml:space="preserve">
          <source>This is in contrast to the default behaviour of &lt;a href=&quot;../macro.panic&quot;&gt;&lt;code&gt;panic!&lt;/code&gt;&lt;/a&gt; which unwinds the current thread's stack and calls all destructors. When &lt;code&gt;panic=&quot;abort&quot;&lt;/code&gt; is set, either as an argument to &lt;code&gt;rustc&lt;/code&gt; or in a crate's Cargo.toml, &lt;a href=&quot;../macro.panic&quot;&gt;&lt;code&gt;panic!&lt;/code&gt;&lt;/a&gt; and &lt;code&gt;abort&lt;/code&gt; are similar. However, &lt;a href=&quot;../macro.panic&quot;&gt;&lt;code&gt;panic!&lt;/code&gt;&lt;/a&gt; will still call the &lt;a href=&quot;../panic/fn.set_hook&quot;&gt;panic hook&lt;/a&gt; while &lt;code&gt;abort&lt;/code&gt; will not.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="abc319fa8d54bb7f30ec3fbd3c75a33f269dda0d" translate="yes" xml:space="preserve">
          <source>This is intended for use cases that must synchronize content, but don't need the metadata on disk. The goal of this method is to reduce disk operations.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8a817bf3dc422e9202ff238105af54d744a0e12d" translate="yes" xml:space="preserve">
          <source>This is lossless: calling &lt;a href=&quot;trait.osstrext#tymethod.encode_wide&quot;&gt;&lt;code&gt;encode_wide&lt;/code&gt;&lt;/a&gt; on the resulting string will always return the original code units.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="628dc171fde34c2da2657493d9e0d1f50a03e413" translate="yes" xml:space="preserve">
          <source>This is lossless: calling &lt;a href=&quot;trait.osstringext#tymethod.from_wide&quot;&gt;&lt;code&gt;OsString::from_wide&lt;/code&gt;&lt;/a&gt; and then &lt;code&gt;encode_wide&lt;/code&gt; on the result will yield the original code units. Note that the encoding does not add a final null terminator.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0151e5762979bf36757d9fa68f187e7676c048da" translate="yes" xml:space="preserve">
          <source>This is more useful when combined with higher-level abstractions, like collecting to a &lt;code&gt;Result&amp;lt;(), E&amp;gt;&lt;/code&gt; where you only care about errors:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e2fe1510c25bad6c81eb0b6402e2bd1a4066b7f9" translate="yes" xml:space="preserve">
          <source>This is not currently supported: &lt;code&gt;v&lt;/code&gt; should be defined as &lt;code&gt;Vec&amp;lt;&amp;amp;str&amp;gt;&lt;/code&gt;. Parentheses are currently only used with generic types when defining parameters for &lt;code&gt;Fn&lt;/code&gt;-family traits.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="711ce4ce5401a3c09d45281217695490f1c55a87" translate="yes" xml:space="preserve">
          <source>This is often the correct thing to use when building data structures using raw pointers, but is ultimately more dangerous to use because of its additional properties. If you're not sure if you should use &lt;code&gt;NonNull&amp;lt;T&amp;gt;&lt;/code&gt;, just use &lt;code&gt;*mut T&lt;/code&gt;!</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fa820eea81b725c2fa4febe2a3901035a1fc9e49" translate="yes" xml:space="preserve">
          <source>This is one of the reasons Rust projects that provide a binary have a straightforward &lt;em&gt;src/main.rs&lt;/em&gt; file that calls logic that lives in the &lt;em&gt;src/lib.rs&lt;/em&gt; file. Using that structure, integration tests &lt;em&gt;can&lt;/em&gt; test the library crate with &lt;code&gt;use&lt;/code&gt; to make the important functionality available. If the important functionality works, the small amount of code in the &lt;em&gt;src/main.rs&lt;/em&gt; file will work as well, and that small amount of code doesn&amp;rsquo;t need to be tested.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="73e2aa9ae5cc887b643d8522a473733b99e09722" translate="yes" xml:space="preserve">
          <source>This is only available on unix platforms and must be imported in order to call the method. Windows platforms have a corresponding &lt;code&gt;AsRawHandle&lt;/code&gt; and &lt;code&gt;AsRawSocket&lt;/code&gt; set of traits.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b95758d57810f70a3e0dda910c113e0c41898398" translate="yes" xml:space="preserve">
          <source>This is only possible if the iterator has an end, so &lt;code&gt;rev()&lt;/code&gt; only works on &lt;a href=&quot;trait.doubleendediterator&quot;&gt;&lt;code&gt;DoubleEndedIterator&lt;/code&gt;&lt;/a&gt;s.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3a074412ade07f77d614925409e4080a4208783e" translate="yes" xml:space="preserve">
          <source>This is optimal if:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d34b82a0a85b619783fe065420d506ce185b6196" translate="yes" xml:space="preserve">
          <source>This is purely an optimization hint, and may be implemented conservatively: it may return &lt;code&gt;true&lt;/code&gt; for types that don't actually need to be dropped. As such always returning &lt;code&gt;true&lt;/code&gt; would be a valid implementation of this function. However if this function actually returns &lt;code&gt;false&lt;/code&gt;, then you can be certain dropping &lt;code&gt;T&lt;/code&gt; has no side effect.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5e7810a8956ac37cd206f449b307f75cea11f52b" translate="yes" xml:space="preserve">
          <source>This is returned in a Result by either the &lt;a href=&quot;struct.command#method.output&quot;&gt;&lt;code&gt;output&lt;/code&gt;&lt;/a&gt; method of a &lt;a href=&quot;struct.command&quot;&gt;&lt;code&gt;Command&lt;/code&gt;&lt;/a&gt;, or the &lt;a href=&quot;struct.child#method.wait_with_output&quot;&gt;&lt;code&gt;wait_with_output&lt;/code&gt;&lt;/a&gt; method of a &lt;a href=&quot;struct.child&quot;&gt;&lt;code&gt;Child&lt;/code&gt;&lt;/a&gt; process.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b6ad57d3243660eeae5c83dc6d6e37580997866e" translate="yes" xml:space="preserve">
          <source>This is safe because it is not possible to move out of a shared reference. It may seem like there is an issue here with interior mutability: in fact, it &lt;em&gt;is&lt;/em&gt; possible to move a &lt;code&gt;T&lt;/code&gt; out of a &lt;code&gt;&amp;amp;RefCell&amp;lt;T&amp;gt;&lt;/code&gt;. However, this is not a problem as long as there does not also exist a &lt;code&gt;Pin&amp;lt;&amp;amp;T&amp;gt;&lt;/code&gt; pointing to the same data, and &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt; does not let you create a pinned reference to its contents. See the discussion on &lt;a href=&quot;index#projections-and-structural-pinning&quot;&gt;&quot;pinning projections&quot;&lt;/a&gt; for further details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="559d85299736482aa3edc92867921c11931dac34" translate="yes" xml:space="preserve">
          <source>This is safe because passing &lt;code&gt;self&lt;/code&gt; by value guarantees that no other threads are concurrently accessing the atomic data.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fdcd86e75de03ac238cab2145da08762d1c1fa0e" translate="yes" xml:space="preserve">
          <source>This is safe because the mutable reference guarantees that no other threads are concurrently accessing the atomic data.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="62f1c9ceb59d3f4f94d3d3fedf2ebcb7110ae8d6" translate="yes" xml:space="preserve">
          <source>This is semantically equivalent to calling &lt;a href=&quot;../ptr/fn.read&quot;&gt;&lt;code&gt;ptr::read&lt;/code&gt;&lt;/a&gt; and discarding the result, but has the following advantages:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f8249e0d4f2746bf5b8aa8a678e0e1e5a321179d" translate="yes" xml:space="preserve">
          <source>This is semantically equivalent to calling &lt;a href=&quot;fn.read&quot;&gt;&lt;code&gt;ptr::read&lt;/code&gt;&lt;/a&gt; and discarding the result, but has the following advantages:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fb69e9b77c8f67d2dd23964f55732bc6174eb1f3" translate="yes" xml:space="preserve">
          <source>This is similar to &lt;a href=&quot;struct.mutex#poisoning&quot;&gt;poisoning with mutexes&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="323433898b799fb03eed09fdd2d727e9828c9a3d" translate="yes" xml:space="preserve">
          <source>This is similar to &lt;code&gt;wake&lt;/code&gt;, but may be slightly less efficient in the case where an owned &lt;code&gt;Waker&lt;/code&gt; is available. This method should be preferred to calling &lt;code&gt;waker.clone().wake()&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="67ff9ed313be1a208e09d5213c1e87906d1b8ae8" translate="yes" xml:space="preserve">
          <source>This is similar to taking a reference to the whole &lt;code&gt;String&lt;/code&gt; but with the extra &lt;code&gt;[0..5]&lt;/code&gt; bit. Rather than a reference to the entire &lt;code&gt;String&lt;/code&gt;, it&amp;rsquo;s a reference to a portion of the &lt;code&gt;String&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8e7a7ddaef0be30145306f6816d2b3ff35a14d32" translate="yes" xml:space="preserve">
          <source>This is similar to the second sub-error, but subtler. It happens in situations like the following:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7512abd4f4f8baf21d2fa3f6cea905e84ac77b34" translate="yes" xml:space="preserve">
          <source>This is simply a special - but common - case of the previous: hiding mutability for operations that appear to be immutable. The &lt;code&gt;clone&lt;/code&gt; method is expected to not change the source value, and is declared to take &lt;code&gt;&amp;amp;self&lt;/code&gt;, not &lt;code&gt;&amp;amp;mut self&lt;/code&gt;. Therefore, any mutation that happens in the &lt;code&gt;clone&lt;/code&gt; method must use cell types. For example, &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; maintains its reference counts within a &lt;code&gt;Cell&amp;lt;T&amp;gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="022f67943cd560f4bdb5afc8c97b7f6c6d3167eb" translate="yes" xml:space="preserve">
          <source>This is sometimes done as part of an FFI:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ce79f7fec51f65c567a6d4b960b891ab223ea0af" translate="yes" xml:space="preserve">
          <source>This is supported on Linux only.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5d02662201a60807bdb13970d8ae5dbd58d92a03" translate="yes" xml:space="preserve">
          <source>This is supported on Unix only.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fe81960399abac0748704c3a05349d9cd7f1ac2c" translate="yes" xml:space="preserve">
          <source>This is supported on Windows only.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7dbd409e3c209511b0279195cd6826fb5e1a2b3b" translate="yes" xml:space="preserve">
          <source>This is the &lt;code&gt;longest&lt;/code&gt; function from Listing 10-22 that returns the longer of two string slices. But now it has an extra parameter named &lt;code&gt;ann&lt;/code&gt; of the generic type &lt;code&gt;T&lt;/code&gt;, which can be filled in by any type that implements the &lt;code&gt;Display&lt;/code&gt; trait as specified by the &lt;code&gt;where&lt;/code&gt; clause. This extra parameter will be printed before the function compares the lengths of the string slices, which is why the &lt;code&gt;Display&lt;/code&gt; trait bound is necessary. Because lifetimes are a type of generic, the declarations of the lifetime parameter &lt;code&gt;'a&lt;/code&gt; and the generic type parameter &lt;code&gt;T&lt;/code&gt; go in the same list inside the angle brackets after the function name.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="771b5400b1697f2e03b3ff52d8994e98c72fb56e" translate="yes" xml:space="preserve">
          <source>This is the alignment used for struct fields. It may be smaller than the preferred alignment.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9ea5fa4cdf245151000dcd8208cd57fa7396ef40" translate="yes" xml:space="preserve">
          <source>This is the correct syntax:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="540ad0b8406b1727e0f455b9b013663295117df7" translate="yes" xml:space="preserve">
          <source>This is the difference between &lt;code&gt;1.0&lt;/code&gt; and the next largest representable number.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c620ac5f199d804600d9e6fa867d20d7e4f16f11" translate="yes" xml:space="preserve">
          <source>This is the first example of Rust&amp;rsquo;s safety principles in action. In many low-level languages, this kind of check is not done, and when you provide an incorrect index, invalid memory can be accessed. Rust protects you against this kind of error by immediately exiting instead of allowing the memory access and continuing. Chapter 9 discusses more of Rust&amp;rsquo;s error handling.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="96d082bf8459464d47b35442a1fa45813a325a53" translate="yes" xml:space="preserve">
          <source>This is the main iterator trait. For more about the concept of iterators generally, please see the &lt;a href=&quot;index&quot;&gt;module-level documentation&lt;/a&gt;. In particular, you may want to know how to &lt;a href=&quot;index#implementing-iterator&quot;&gt;implement &lt;code&gt;Iterator&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="289f1434eafb60316aca77ad31a00e3c0eb9323a" translate="yes" xml:space="preserve">
          <source>This is the non-panicking alternative to indexing the &lt;code&gt;str&lt;/code&gt;. Returns &lt;a href=&quot;option/enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt; whenever equivalent indexing operation would panic.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="759018d521d201d38bc076c0727a5d9a6e429fac" translate="yes" xml:space="preserve">
          <source>This is the non-panicking variant of &lt;a href=&quot;#method.borrow&quot;&gt;&lt;code&gt;borrow&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="70fed40b0a485aa104ed49c92498ff0b436cf03b" translate="yes" xml:space="preserve">
          <source>This is the non-panicking variant of &lt;a href=&quot;#method.borrow_mut&quot;&gt;&lt;code&gt;borrow_mut&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cce445e189c1252f0055062d54b89751ff0fb729" translate="yes" xml:space="preserve">
          <source>This is the reverse version of &lt;a href=&quot;trait.iterator#method.fold&quot;&gt;&lt;code&gt;fold()&lt;/code&gt;&lt;/a&gt;: it takes elements starting from the back of the iterator.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="53f33f9266690c3f1f82aab587ca29e140daa7ab" translate="yes" xml:space="preserve">
          <source>This is the reverse version of &lt;a href=&quot;trait.iterator#method.try_fold&quot;&gt;&lt;code&gt;try_fold()&lt;/code&gt;&lt;/a&gt;: it takes elements starting from the back of the iterator.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d46122a89a465fda704ceb8118ba4c1126be2832" translate="yes" xml:space="preserve">
          <source>This is the reverse version of [&lt;code&gt;try_fold()&lt;/code&gt;]: it takes elements starting from the back of the iterator. &lt;a href=&quot;../../iter/trait.doubleendediterator#method.try_rfold&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f495531f8eacf0a1680dc0219ed83707197faddd" translate="yes" xml:space="preserve">
          <source>This is the reverse version of [&lt;code&gt;try_fold()&lt;/code&gt;]: it takes elements starting from the back of the iterator. &lt;a href=&quot;../iter/trait.doubleendediterator#method.try_rfold&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0ec81940d41390cbbcb80997a4e3d957d2b9a317" translate="yes" xml:space="preserve">
          <source>This is the reverse version of [&lt;code&gt;try_fold()&lt;/code&gt;]: it takes elements starting from the back of the iterator. &lt;a href=&quot;iter/trait.doubleendediterator#method.try_rfold&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5ff3fa51ad38f312277040719826a7c977bbcd8a" translate="yes" xml:space="preserve">
          <source>This is the reverse version of [&lt;code&gt;try_fold()&lt;/code&gt;]: it takes elements starting from the back of the iterator. &lt;a href=&quot;trait.doubleendediterator#method.try_rfold&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="383e94e01b1343c9d6bcfb23e7f045e384d94336" translate="yes" xml:space="preserve">
          <source>This is the same as using the &lt;code&gt;==&lt;/code&gt; operator, but less generic: the arguments have to be &lt;code&gt;*const T&lt;/code&gt; raw pointers, not anything that implements &lt;code&gt;PartialEq&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="22b2f39cdef64a09df83167c24366e9e24591fdf" translate="yes" xml:space="preserve">
          <source>This is the unchecked alternative to indexing the &lt;code&gt;str&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="589a4243aa6d42e7fc5ac36f0baed5a47e1de444" translate="yes" xml:space="preserve">
          <source>This is used for object safety, to check that a method's receiver type can be dispatched on.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9aea807f1415223ad9d946b1ace7fbf6d55fe5aa" translate="yes" xml:space="preserve">
          <source>This is used when the programmer knows that the thread will have nothing to do for some time, and thus avoid wasting computing time.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5ce1e416198eb464ee0a2977f8013c35c0e89565" translate="yes" xml:space="preserve">
          <source>This is useful any time that the compiler can't determine that some code is unreachable. For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="85e4c5ffc08236fd25e25201dcbaaa8757900c78" translate="yes" xml:space="preserve">
          <source>This is useful for</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a885d8fe460e46c9230b0d468a457bef6acf54a6" translate="yes" xml:space="preserve">
          <source>This is useful for a flavor of &quot;optimistic check&quot; before deciding to block on a receiver.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="79e1d9086d9f417d98c9a3f1df01e78fe0db96d9" translate="yes" xml:space="preserve">
          <source>This is useful for initializing types which lazily allocate, like &lt;code&gt;Vec::new&lt;/code&gt; does.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="08ec962229a27774cdabf85bddcaa5d6f625b9ff" translate="yes" xml:space="preserve">
          <source>This is useful to allow applying iterator adaptors while still retaining ownership of the original iterator.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="63ccb84e9a4faa353cb290ddc5e855748a76c17b" translate="yes" xml:space="preserve">
          <source>This is useful when you are doing a type conversion that may trivially succeed but may also need special handling. For example, there is no way to convert an &lt;code&gt;i64&lt;/code&gt; into an &lt;code&gt;i32&lt;/code&gt; using the &lt;a href=&quot;trait.from&quot;&gt;&lt;code&gt;From&lt;/code&gt;&lt;/a&gt; trait, because an &lt;code&gt;i64&lt;/code&gt; may contain a value that an &lt;code&gt;i32&lt;/code&gt; cannot represent and so the conversion would lose data. This might be handled by truncating the &lt;code&gt;i64&lt;/code&gt; to an &lt;code&gt;i32&lt;/code&gt; (essentially giving the &lt;code&gt;i64&lt;/code&gt;'s value modulo &lt;code&gt;i32::MAX&lt;/code&gt;) or by simply returning &lt;code&gt;i32::MAX&lt;/code&gt;, or by some other method. The &lt;code&gt;From&lt;/code&gt; trait is intended for perfect conversions, so the &lt;code&gt;TryFrom&lt;/code&gt; trait informs the programmer when a type conversion could go bad and lets them decide how to handle it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="878335df341d736b2b477f7d269d41d041479a70" translate="yes" xml:space="preserve">
          <source>This is useful when you have an iterator of iterators or an iterator of things that can be turned into iterators and you want to remove one level of indirection.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bc06069272831e3fab63600d60da8286a4aa9faf" translate="yes" xml:space="preserve">
          <source>This is useful when you have an iterator over &lt;code&gt;&amp;amp;T&lt;/code&gt;, but you need an iterator over &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="28c350dd4bfc1f4f50a6db4a558fce8f481fa714" translate="yes" xml:space="preserve">
          <source>This is useful when you wish to output a formatted list of items as a part of your &lt;a href=&quot;trait.debug#tymethod.fmt&quot;&gt;&lt;code&gt;Debug::fmt&lt;/code&gt;&lt;/a&gt; implementation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="023c37d743c95a28f62cb66dc28c6981840e275e" translate="yes" xml:space="preserve">
          <source>This is useful when you wish to output a formatted map as a part of your &lt;a href=&quot;trait.debug#tymethod.fmt&quot;&gt;&lt;code&gt;Debug::fmt&lt;/code&gt;&lt;/a&gt; implementation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5a019c845f0ac55c26e73d5fc98b9e29c14a5266" translate="yes" xml:space="preserve">
          <source>This is useful when you wish to output a formatted set of items as a part of your &lt;a href=&quot;trait.debug#tymethod.fmt&quot;&gt;&lt;code&gt;Debug::fmt&lt;/code&gt;&lt;/a&gt; implementation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="742e4efaa0964cab1a9b13d64aa3f1ee505fbe93" translate="yes" xml:space="preserve">
          <source>This is useful when you wish to output a formatted struct as a part of your &lt;a href=&quot;trait.debug#tymethod.fmt&quot;&gt;&lt;code&gt;Debug::fmt&lt;/code&gt;&lt;/a&gt; implementation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7450774ae735743f9affac51ccc2935a02180916" translate="yes" xml:space="preserve">
          <source>This is useful when you wish to output a formatted tuple as a part of your &lt;a href=&quot;trait.debug#tymethod.fmt&quot;&gt;&lt;code&gt;Debug::fmt&lt;/code&gt;&lt;/a&gt; implementation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="678189b9778744d56a77a9ddbd180a89dff66dd0" translate="yes" xml:space="preserve">
          <source>This is usually not needed when writing safe code, as &lt;a href=&quot;../sync/struct.mutex&quot;&gt;&lt;code&gt;Mutex&lt;/code&gt;es&lt;/a&gt; already poison themselves when a thread panics while holding the lock.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="73513599023f5ddb254ee6ed0d00bccac264c338" translate="yes" xml:space="preserve">
          <source>This is usually the same as &lt;code&gt;size_of::&amp;lt;T&amp;gt;()&lt;/code&gt;. However, when &lt;code&gt;T&lt;/code&gt;&lt;em&gt;has&lt;/em&gt; no statically-known size, e.g., a slice &lt;a href=&quot;../primitive.slice&quot;&gt;&lt;code&gt;[T]&lt;/code&gt;&lt;/a&gt; or a &lt;a href=&quot;../../book/ch17-02-trait-objects&quot;&gt;trait object&lt;/a&gt;, then &lt;code&gt;size_of_val&lt;/code&gt; can be used to get the dynamically-known size.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8abe6d863c59136664f0a7528f19c0cd3ff2fed7" translate="yes" xml:space="preserve">
          <source>This isn&amp;rsquo;t the exact signature that&amp;rsquo;s in the standard library: in the standard library, &lt;code&gt;add&lt;/code&gt; is defined using generics. Here, we&amp;rsquo;re looking at the signature of &lt;code&gt;add&lt;/code&gt; with concrete types substituted for the generic ones, which is what happens when we call this method with &lt;code&gt;String&lt;/code&gt; values. We&amp;rsquo;ll discuss generics in Chapter 10. This signature gives us the clues we need to understand the tricky bits of the &lt;code&gt;+&lt;/code&gt; operator.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="677e3e0ad58a3857efcf5b71bd28f251f1ad71c2" translate="yes" xml:space="preserve">
          <source>This isn&amp;rsquo;t the last you&amp;rsquo;ll see of concurrency in this book: the project in Chapter 20 will use the concepts in this chapter in a more realistic situation than the smaller examples discussed here.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c724cabc6d2e28a46495b5e9f7308161c3ff4773" translate="yes" xml:space="preserve">
          <source>This isn't allowed, but using a trait to implement a method is a good solution. Example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ca75bc59c45502aa721dfcf6b2008b560ce93b8c" translate="yes" xml:space="preserve">
          <source>This issue also ties into the second problem: although &lt;code&gt;query&lt;/code&gt; and &lt;code&gt;filename&lt;/code&gt; are configuration variables to our program, variables like &lt;code&gt;contents&lt;/code&gt; are used to perform the program&amp;rsquo;s logic. The longer &lt;code&gt;main&lt;/code&gt; becomes, the more variables we&amp;rsquo;ll need to bring into scope; the more variables we have in scope, the harder it will be to keep track of the purpose of each. It&amp;rsquo;s best to group the configuration variables into one structure to make their purpose clear.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f6ff2f3673f7e2d10b1136073892f6a7e26909fe" translate="yes" xml:space="preserve">
          <source>This iterator is &lt;a href=&quot;../iter/trait.fusediterator&quot;&gt;fused&lt;/a&gt;, but the specific values of &lt;code&gt;start&lt;/code&gt; and &lt;code&gt;end&lt;/code&gt; after iteration has finished are &lt;strong&gt;unspecified&lt;/strong&gt; other than that &lt;a href=&quot;#method.is_empty&quot;&gt;&lt;code&gt;.is_empty()&lt;/code&gt;&lt;/a&gt; will return &lt;code&gt;true&lt;/code&gt; once no more values will be produced.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="22ff5b740b07569a5d9914bbdea6a0fe28474b82" translate="yes" xml:space="preserve">
          <source>This iterator is returned from the &lt;a href=&quot;fn.read_dir&quot;&gt;&lt;code&gt;read_dir&lt;/code&gt;&lt;/a&gt; function of this module and will yield instances of &lt;a href=&quot;../io/type.result&quot;&gt;&lt;code&gt;io::Result&lt;/code&gt;&lt;/a&gt;&lt;code&gt;&amp;lt;&lt;/code&gt;&lt;a href=&quot;struct.direntry&quot;&gt;&lt;code&gt;DirEntry&lt;/code&gt;&lt;/a&gt;&lt;code&gt;&amp;gt;&lt;/code&gt;. Through a &lt;a href=&quot;struct.direntry&quot;&gt;&lt;code&gt;DirEntry&lt;/code&gt;&lt;/a&gt; information like the entry's path and possibly other metadata can be learned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="039cfdd22f7232d788dc3924aaf58e6af89b9b42" translate="yes" xml:space="preserve">
          <source>This iterator will block whenever &lt;a href=&quot;../../iter/trait.iterator#tymethod.next&quot;&gt;&lt;code&gt;next&lt;/code&gt;&lt;/a&gt; is called, waiting for a new message, and &lt;a href=&quot;../../option/enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt; will be returned if the corresponding channel has hung up.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="47622e0905704752b067e8fb130b53a4d875da6d" translate="yes" xml:space="preserve">
          <source>This iterator will block whenever &lt;a href=&quot;../../iter/trait.iterator#tymethod.next&quot;&gt;&lt;code&gt;next&lt;/code&gt;&lt;/a&gt; is called, waiting for a new message, and &lt;a href=&quot;../../option/enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt; will be returned when the corresponding channel has hung up.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3d5f1a4f383a40c5608e98cdb7f233b0d0bd50b4" translate="yes" xml:space="preserve">
          <source>This iterator will never block the caller in order to wait for data to become available. Instead, it will return &lt;a href=&quot;../../option/enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2ded90014878b45a9d1013952a0eeccef1815fa3" translate="yes" xml:space="preserve">
          <source>This iterator yields mutable references to the slice's elements, so while the element type of the slice is &lt;code&gt;i32&lt;/code&gt;, the element type of the iterator is &lt;code&gt;&amp;amp;mut i32&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f11293328eb4e550149e3eb11d18b4b99dadeb4a" translate="yes" xml:space="preserve">
          <source>This key uses the fastest possible implementation available to it for the target platform. It is instantiated with the &lt;a href=&quot;../macro.thread_local&quot;&gt;&lt;code&gt;thread_local!&lt;/code&gt;&lt;/a&gt; macro and the primary method is the &lt;a href=&quot;struct.localkey#method.with&quot;&gt;&lt;code&gt;with&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8ba72c9f8d060c616c313ff46104db0834e023c2" translate="yes" xml:space="preserve">
          <source>This kind of reordering is handled transparently by the CPU.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="01e9e67a62e244fe3547a3a6a38b452018a02bd0" translate="yes" xml:space="preserve">
          <source>This kind of string &lt;em&gt;can&lt;/em&gt; be mutated:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a40000b09a25d1541d4b670c6d1a695e653d4397" translate="yes" xml:space="preserve">
          <source>This last example is different because it is not possible to use the suffix syntax with a floating point literal ending in a period. &lt;code&gt;2.f64&lt;/code&gt; would attempt to call a method named &lt;code&gt;f64&lt;/code&gt; on &lt;code&gt;2&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d48b41e91473a0fe92d3d1ed63ecf51de63aefff" translate="yes" xml:space="preserve">
          <source>This length is in bytes, not &lt;a href=&quot;../char/index&quot;&gt;&lt;code&gt;char&lt;/code&gt;&lt;/a&gt;s or graphemes. In other words, it may not be what a human considers the length of the string.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="903d848487fc64b3813a8038fcea8db3d845066a" translate="yes" xml:space="preserve">
          <source>This length is in bytes, not &lt;a href=&quot;char/index&quot;&gt;&lt;code&gt;char&lt;/code&gt;&lt;/a&gt;s or graphemes. In other words, it may not be what a human considers the length of the string.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2f8980a7dcbb36debff75ad398d722c2e476b435" translate="yes" xml:space="preserve">
          <source>This limitation may be removed in a future version of Rust.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="65d7d6e48995b9a8b70ff571d23a4947777c0d68" translate="yes" xml:space="preserve">
          <source>This limitation on the size &lt;code&gt;N&lt;/code&gt; exists because Rust does not yet support code that is generic over the size of an array type. &lt;code&gt;[Foo; 3]&lt;/code&gt; and &lt;code&gt;[Bar; 3]&lt;/code&gt; are instances of same generic type &lt;code&gt;[T; 3]&lt;/code&gt;, but &lt;code&gt;[Foo; 3]&lt;/code&gt; and &lt;code&gt;[Foo; 5]&lt;/code&gt; are entirely different types. As a stopgap, trait implementations are statically generated up to size 32.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="08204384af7f77c5b07543f234ee809fc102751e" translate="yes" xml:space="preserve">
          <source>This line brings &lt;code&gt;std::io&lt;/code&gt; and &lt;code&gt;std::io::Write&lt;/code&gt; into scope.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c84219e32c60c562866367e57dce5465f094cc72" translate="yes" xml:space="preserve">
          <source>This line creates a new empty string called &lt;code&gt;s&lt;/code&gt;, which we can then load data into. Often, we&amp;rsquo;ll have some initial data that we want to start the string with. For that, we use the &lt;code&gt;to_string&lt;/code&gt; method, which is available on any type that implements the &lt;code&gt;Display&lt;/code&gt; trait, as string literals do. Listing 8-12 shows two examples.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c6d1af215b1b045e01e47bacfa1ae42f66655d33" translate="yes" xml:space="preserve">
          <source>This line creates a new variable named &lt;code&gt;foo&lt;/code&gt; and binds it to the value of the &lt;code&gt;bar&lt;/code&gt; variable. In Rust, variables are immutable by default. We&amp;rsquo;ll be discussing this concept in detail in the &lt;a href=&quot;ch03-01-variables-and-mutability#variables-and-mutability&quot;&gt;&amp;ldquo;Variables and Mutability&amp;rdquo;&lt;/a&gt; section in Chapter 3. The following example shows how to use &lt;code&gt;mut&lt;/code&gt; before the variable name to make a variable mutable:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5d9eacc9407c12ec62c5abf0aec26e9081e77d6a" translate="yes" xml:space="preserve">
          <source>This line does all the work in this little program: it prints text to the screen. There are four important details to notice here. First, Rust style is to indent with four spaces, not a tab.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6bb12529672d4d91a104d1b5e1346fffbd28c07c" translate="yes" xml:space="preserve">
          <source>This line prints the string we saved the user&amp;rsquo;s input in. The set of curly brackets, &lt;code&gt;{}&lt;/code&gt;, is a placeholder: think of &lt;code&gt;{}&lt;/code&gt; as little crab pincers that hold a value in place. You can print more than one value using curly brackets: the first set of curly brackets holds the first value listed after the format string, the second set holds the second value, and so on. Printing multiple values in one call to &lt;code&gt;println!&lt;/code&gt; would look like this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="250f132a4cd3e14f1923c5e6c25a460649fabde4" translate="yes" xml:space="preserve">
          <source>This list is intended to grow over time and it is not recommended to exhaustively match against it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="308882c8bb15621452c72c71d1e862ba6ca42816" translate="yes" xml:space="preserve">
          <source>This longer form is equivalent to the example in the previous section but is more verbose. We place trait bounds with the declaration of the generic type parameter after a colon and inside angle brackets.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cc7e694b75fd14e7d2942129d96e2363378281a2" translate="yes" xml:space="preserve">
          <source>This looks very similar to the previous code, so we might assume that the way it works would be the same: that is, the second line would make a copy of the value in &lt;code&gt;s1&lt;/code&gt; and bind it to &lt;code&gt;s2&lt;/code&gt;. But this isn&amp;rsquo;t quite what happens.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e9c26f6e16b6bec90033e045df684b9983904c03" translate="yes" xml:space="preserve">
          <source>This macro accepts a format string, a list of arguments, and a 'writer'. Arguments will be formatted according to the specified format string and the result will be passed to the writer. The writer may be any value with a &lt;code&gt;write_fmt&lt;/code&gt; method; generally this comes from an implementation of either the &lt;a href=&quot;fmt/trait.write&quot;&gt;&lt;code&gt;std::fmt::Write&lt;/code&gt;&lt;/a&gt; or the &lt;a href=&quot;io/trait.write&quot;&gt;&lt;code&gt;std::io::Write&lt;/code&gt;&lt;/a&gt; trait. The macro returns whatever the &lt;code&gt;write_fmt&lt;/code&gt; method returns; commonly a &lt;a href=&quot;fmt/type.result&quot;&gt;&lt;code&gt;std::fmt::Result&lt;/code&gt;&lt;/a&gt;, or an &lt;a href=&quot;io/type.result&quot;&gt;&lt;code&gt;io::Result&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9104464c61f2440f3d22798d14bf9b51373598ab" translate="yes" xml:space="preserve">
          <source>This macro functions by taking a formatting string literal containing &lt;code&gt;{}&lt;/code&gt; for each additional argument passed. &lt;code&gt;format_args!&lt;/code&gt; prepares the additional parameters to ensure the output can be interpreted as a string and canonicalizes the arguments into a single type. Any value that implements the &lt;a href=&quot;fmt/trait.display&quot;&gt;&lt;code&gt;Display&lt;/code&gt;&lt;/a&gt; trait can be passed to &lt;code&gt;format_args!&lt;/code&gt;, as can any &lt;a href=&quot;fmt/trait.debug&quot;&gt;&lt;code&gt;Debug&lt;/code&gt;&lt;/a&gt; implementation be passed to a &lt;code&gt;{:?}&lt;/code&gt; within the formatting string.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c0f46ebdcffb6d5939dcac636e4ba0ac8074178d" translate="yes" xml:space="preserve">
          <source>This macro has a second form, where a custom panic message can be provided with or without arguments for formatting. See &lt;a href=&quot;fmt/index&quot;&gt;&lt;code&gt;std::fmt&lt;/code&gt;&lt;/a&gt; for syntax for this form.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4b5986245d717af402afebe47105d05cdf22c051" translate="yes" xml:space="preserve">
          <source>This macro is provided in the standard library and will detect at runtime whether the specified CPU feature is detected. This does &lt;strong&gt;not&lt;/strong&gt; resolve at compile time unless the specified feature is already enabled for the entire crate. Runtime detection currently relies mostly on the &lt;code&gt;cpuid&lt;/code&gt; instruction.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="80d199c9b2bbee396aca26a7f3417fd4e87ff814" translate="yes" xml:space="preserve">
          <source>This macro is the perfect way to assert conditions in example code and in tests. &lt;code&gt;panic!&lt;/code&gt; is closely tied with the &lt;code&gt;unwrap&lt;/code&gt; method of both &lt;a href=&quot;option/enum.option#method.unwrap&quot;&gt;&lt;code&gt;Option&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;result/enum.result#method.unwrap&quot;&gt;&lt;code&gt;Result&lt;/code&gt;&lt;/a&gt; enums. Both implementations call &lt;code&gt;panic!&lt;/code&gt; when they are set to None or Err variants.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cf0774da3df0d29e08106daf482fff334bcea403" translate="yes" xml:space="preserve">
          <source>This macro is used to inject panic into a Rust thread, causing the thread to panic entirely. Each thread's panic can be reaped as the &lt;code&gt;Box&amp;lt;Any&amp;gt;&lt;/code&gt; type, and the single-argument form of the &lt;code&gt;panic!&lt;/code&gt; macro will be the value which is transmitted.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e7802aaf0db102edbab92f402c03063ff3b73be4" translate="yes" xml:space="preserve">
          <source>This macro only takes one argument which is a string literal of the feature being tested for. The feature names supported are the lowercase versions of the ones defined by Intel in &lt;a href=&quot;https://software.intel.com/sites/landingpage/IntrinsicsGuide&quot;&gt;their documentation&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4bd8a54709ee381edf667e1b754c2dd4776028dd" translate="yes" xml:space="preserve">
          <source>This macro produces a value of type &lt;a href=&quot;fmt/struct.arguments&quot;&gt;&lt;code&gt;fmt::Arguments&lt;/code&gt;&lt;/a&gt;. This value can be passed to the macros within &lt;a href=&quot;fmt/index&quot;&gt;&lt;code&gt;std::fmt&lt;/code&gt;&lt;/a&gt; for performing useful redirection. All other formatting macros (&lt;a href=&quot;macro.format&quot;&gt;&lt;code&gt;format!&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;macro.write&quot;&gt;&lt;code&gt;write!&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;macro.println&quot;&gt;&lt;code&gt;println!&lt;/code&gt;&lt;/a&gt;, etc) are proxied through this one. &lt;code&gt;format_args!&lt;/code&gt;, unlike its derived macros, avoids heap allocations.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d49c196cc9f23d7594245f1cc87a1f518746592e" translate="yes" xml:space="preserve">
          <source>This macro should be used when a crate uses a conditional compilation strategy to provide better error messages for erroneous conditions. It's the compiler-level form of &lt;a href=&quot;macro.panic&quot;&gt;&lt;code&gt;panic!&lt;/code&gt;&lt;/a&gt;, which emits an error at &lt;em&gt;runtime&lt;/em&gt;, rather than during compilation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="68d15cf83524f34dd8d8be7a2a8e7bed6740e783" translate="yes" xml:space="preserve">
          <source>This macro supports the same names that &lt;code&gt;#[target_feature]&lt;/code&gt; supports. Unlike &lt;code&gt;#[target_feature]&lt;/code&gt;, however, this macro does not support names separated with a comma. Instead testing for multiple features must be done through separate macro invocations for now.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fefc6add454f34259443790785050840eebbeb57" translate="yes" xml:space="preserve">
          <source>This macro takes any number of comma-separated identifiers, and concatenates them all into one, yielding an expression which is a new identifier. Note that hygiene makes it such that this macro cannot capture local variables. Also, as a general rule, macros are only allowed in item, statement or expression position. That means while you may use this macro for referring to existing variables, functions or modules etc, you cannot define a new one with it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a79ce9bb3fa69012483f80e7a1a2541065700d68" translate="yes" xml:space="preserve">
          <source>This macro takes any number of comma-separated literals, yielding an expression of type &lt;code&gt;&amp;amp;'static str&lt;/code&gt; which represents all of the literals concatenated left-to-right.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="79fc3c2904becf8aa3c820c279472de0fe3a1f68" translate="yes" xml:space="preserve">
          <source>This macro will expand to the value of the named environment variable at compile time, yielding an expression of type &lt;code&gt;&amp;amp;'static str&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="95e973b1ebc33842358cee19e0dba22c8a81f994" translate="yes" xml:space="preserve">
          <source>This macro will yield an expression of type &lt;code&gt;&amp;amp;'static [u8; N]&lt;/code&gt; which is the contents of the file.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9cdb0bb59a3aefac2ea084695df47352b8cc7f18" translate="yes" xml:space="preserve">
          <source>This macro will yield an expression of type &lt;code&gt;&amp;amp;'static str&lt;/code&gt; which is the contents of the file.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8d3907f6b0e9a61a4bdb55de9a362a92915237c3" translate="yes" xml:space="preserve">
          <source>This macro will yield an expression of type &lt;code&gt;&amp;amp;'static str&lt;/code&gt; which is the stringification of all the tokens passed to the macro. No restrictions are placed on the syntax of the macro invocation itself.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="96f8e740156b1fe8242bb1857eb516b34c772e7e" translate="yes" xml:space="preserve">
          <source>This macro would parse the SQL statement inside it and check that it&amp;rsquo;s syntactically correct, which is much more complex processing than a &lt;code&gt;macro_rules!&lt;/code&gt; macro can do. The &lt;code&gt;sql!&lt;/code&gt; macro would be defined like this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f58f7dcc462ef7387fceff17b5cae04e3cbcbf04" translate="yes" xml:space="preserve">
          <source>This makes the trait implemented on all types in the scope. So if you try to implement it on another one after that, the implementations will conflict. Example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dafc2f14b4f56d8dc5d075ff34c826a36e387880" translate="yes" xml:space="preserve">
          <source>This may not actually increase the capacity:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="af903b6fc00acf0d280f6c29b1e0e8d3aeb94082" translate="yes" xml:space="preserve">
          <source>This may only be called by &lt;code&gt;Read&lt;/code&gt;ers which guarantee that they will not read from buffers passed to &lt;code&gt;Read&lt;/code&gt; methods, and that the return value of the method accurately reflects the number of bytes that have been written to the head of the buffer.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="14a8a7c42cf833272747226b7446d6fe81b3ec47" translate="yes" xml:space="preserve">
          <source>This may require additional type hints in the function body.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b07ba109060bf875c034ba50fdb9ffdabfec4929" translate="yes" xml:space="preserve">
          <source>This means that &lt;code&gt;&amp;lt;T: 'a + ?Sized&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;T: 'b + Sized&amp;gt;&lt;/code&gt; and &lt;code&gt;&amp;lt;T&amp;gt;&lt;/code&gt; are all permitted.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7a8c1c98c2b07fe7a77662bf8cf1e31aa75a3d05" translate="yes" xml:space="preserve">
          <source>This means that any external crate referencing &lt;code&gt;implementation::api::f&lt;/code&gt; would receive a privacy violation, while the path &lt;code&gt;api::f&lt;/code&gt; would be allowed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="be2e4dfa333e1a56bbed2f9ca40e5f02293eda70" translate="yes" xml:space="preserve">
          <source>This means that perhaps some of the preceding patterns are too general, this one is too specific or the ordering is incorrect.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3a6a30f5c049c4edc23b7fd66710a9051982b10a" translate="yes" xml:space="preserve">
          <source>This means that someone can specify such a function:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cb26a69e23fbbf1b07ba0d9979e852887a91fd3d" translate="yes" xml:space="preserve">
          <source>This means that the contents of the first string above &lt;em&gt;will&lt;/em&gt; fit into a &lt;code&gt;char&lt;/code&gt; while the contents of the second string &lt;em&gt;will not&lt;/em&gt;. Trying to create a &lt;code&gt;char&lt;/code&gt; literal with the contents of the second string gives an error:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f9131c9dc6b963db63fbff2769fe5ceda6bacdcc" translate="yes" xml:space="preserve">
          <source>This means that the operands don't have to be moved out of.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b2ca51239acb100a6dd5efb03e14c814a0a94286" translate="yes" xml:space="preserve">
          <source>This means that when &lt;code&gt;s&lt;/code&gt; reaches the end of &lt;code&gt;demo&lt;/code&gt;, its destructor gets exclusive access to its &lt;code&gt;&amp;amp;mut&lt;/code&gt;-borrowed string data. allowing another borrow of that string data (&lt;code&gt;p&lt;/code&gt;), to exist across the drop of &lt;code&gt;s&lt;/code&gt; would be a violation of the principle that &lt;code&gt;&amp;amp;mut&lt;/code&gt;-borrows have exclusive, unaliased access to their referenced data.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="382ebf724244bccd694c658a6e7769ce6b7c071d" translate="yes" xml:space="preserve">
          <source>This means, that in addition to &lt;code&gt;a == b&lt;/code&gt; and &lt;code&gt;a != b&lt;/code&gt; being strict inverses, the equality must be (for all &lt;code&gt;a&lt;/code&gt;, &lt;code&gt;b&lt;/code&gt; and &lt;code&gt;c&lt;/code&gt;):</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f2cb7c4ca14739fd7d110ae41517acd9e412a5c2" translate="yes" xml:space="preserve">
          <source>This method by itself is safe, but using it correctly requires extra care. Another thread can change the strong count at any time, including potentially between calling this method and acting on the result.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="949f62fcaa7fc2070951a1bf81357a1eb29cd126" translate="yes" xml:space="preserve">
          <source>This method by itself is safe, but using it correctly requires extra care. Another thread can change the weak count at any time, including potentially between calling this method and acting on the result.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3282baf6619178b04f6e093d59df95e6b50b4f0b" translate="yes" xml:space="preserve">
          <source>This method can be used for string data that is &lt;em&gt;terminated&lt;/em&gt;, rather than &lt;em&gt;separated&lt;/em&gt; by a pattern.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3369ccac8ace2a653ec652b1d0a5f9f1bd24f346" translate="yes" xml:space="preserve">
          <source>This method can be used to reverse a comparison:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9f13cbe122409bed70a7bfa8652dd2b252fa340b" translate="yes" xml:space="preserve">
          <source>This method can be useful for situations in which the vector is serving as a buffer for other code, particularly over FFI:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ce975c1398d44efbe8c10a5c85f55c0075a45068" translate="yes" xml:space="preserve">
          <source>This method can only succeed if the entire byte slice was successfully written, and this method will not return until all data has been written or an error occurs.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b1f7d3cdb0bfa41dd91aa3d1bf03416a16ee48f3" translate="yes" xml:space="preserve">
          <source>This method differs from &lt;a href=&quot;struct.syncsender#method.send&quot;&gt;&lt;code&gt;send&lt;/code&gt;&lt;/a&gt; by returning immediately if the channel's buffer is full or no receiver is waiting to acquire some data. Compared with &lt;a href=&quot;struct.syncsender#method.send&quot;&gt;&lt;code&gt;send&lt;/code&gt;&lt;/a&gt;, this function has two failure cases instead of one (one for disconnection, one for a full buffer).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="028002d34f3fafd7bc54cd77bcaa912497a3b074" translate="yes" xml:space="preserve">
          <source>This method does &lt;strong&gt;not&lt;/strong&gt; pass ownership of the raw file descriptor to the caller. The descriptor is only guaranteed to be valid while the original object has not yet been destroyed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5fd9fa51612a49edd496cd80117e23b29a509eb6" translate="yes" xml:space="preserve">
          <source>This method does &lt;strong&gt;not&lt;/strong&gt; return the length of the duration when represented by microseconds. The returned number always represents a fractional portion of a second (i.e., it is less than one million).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d3a3c1cf0cc150bd1c72971205d2190e708b8d2b" translate="yes" xml:space="preserve">
          <source>This method does &lt;strong&gt;not&lt;/strong&gt; return the length of the duration when represented by milliseconds. The returned number always represents a fractional portion of a second (i.e., it is less than one thousand).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e8135547d5a3a3a5006fe1cbd5d76d770ff2a7a9" translate="yes" xml:space="preserve">
          <source>This method does &lt;strong&gt;not&lt;/strong&gt; return the length of the duration when represented by nanoseconds. The returned number always represents a fractional portion of a second (i.e., it is less than one billion).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="16f6f5d172fff1f1f8e9b8bb728e19c58e51b4b5" translate="yes" xml:space="preserve">
          <source>This method doesn't produce a value, but the write may fail. It's crucial to handle the error case, and &lt;em&gt;not&lt;/em&gt; write something like this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="803e98a2b6e5f0d6a98c75881fdb55c1597f80f0" translate="yes" xml:space="preserve">
          <source>This method has a default implementation using &lt;code&gt;self.len()&lt;/code&gt;, so you don't need to implement it yourself.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="02fc3c4c098f9a864e6c45270c0a8ae6ffc408ef" translate="yes" xml:space="preserve">
          <source>This method has a default implementation, so you usually should not implement it directly. However, if you can provide a more efficient implementation, you can do so. See the &lt;a href=&quot;trait.exactsizeiterator&quot;&gt;trait-level&lt;/a&gt; docs for an example.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="89f3649aa28c1d3c90be74ebfb70d517cce77458" translate="yes" xml:space="preserve">
          <source>This method has no purpose when either input element &lt;code&gt;T&lt;/code&gt; or output element &lt;code&gt;U&lt;/code&gt; are zero-sized and will return the original slice without splitting anything.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="37d2a8db1a00abc88d21d10b6113bf279aaebd51" translate="yes" xml:space="preserve">
          <source>This method is called implicitly when the value goes out of scope, and cannot be called explicitly (this is compiler error &lt;a href=&quot;../../error-index#E0040&quot;&gt;E0040&lt;/a&gt;). However, the &lt;a href=&quot;../mem/fn.drop&quot;&gt;&lt;code&gt;std::mem::drop&lt;/code&gt;&lt;/a&gt; function in the prelude can be used to call the argument's &lt;code&gt;Drop&lt;/code&gt; implementation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0b2c9d3aaaa76ea8e330a8973b644085bc25e3bb" translate="yes" xml:space="preserve">
          <source>This method is carefully constructed to avoid allocation. It will consume the error, moving out the bytes, so that a copy of the bytes does not need to be made.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="84886aa1dad1934a5c9bdd981667f36e45fab018" translate="yes" xml:space="preserve">
          <source>This method is equivalent to &lt;a href=&quot;#method.new&quot;&gt;&lt;code&gt;new&lt;/code&gt;&lt;/a&gt; except that no runtime assertion is made that &lt;code&gt;v&lt;/code&gt; contains no 0 bytes, and it requires an actual byte vector, not anything that can be converted to one with Into.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0358b021b2254c197a04c16c02e67b7c9901af56" translate="yes" xml:space="preserve">
          <source>This method is essentially a &lt;code&gt;transmute&lt;/code&gt; with respect to the elements in the returned middle slice, so all the usual caveats pertaining to &lt;code&gt;transmute::&amp;lt;T, U&amp;gt;&lt;/code&gt; also apply here.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dd229ccab2f3fea46c41c098065dd891d877a2e6" translate="yes" xml:space="preserve">
          <source>This method is identical to &lt;a href=&quot;struct.builder#method.spawn&quot;&gt;&lt;code&gt;thread::Builder::spawn&lt;/code&gt;&lt;/a&gt;, except for the relaxed lifetime bounds, which render it unsafe. For a more complete documentation see &lt;a href=&quot;fn.spawn&quot;&gt;&lt;code&gt;thread::spawn&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0bc2506b00444cfc62462ac1af4908c0bbe44456" translate="yes" xml:space="preserve">
          <source>This method is implemented using up to three seek operations. If this method returns successfully, the seek position is unchanged (i.e. the position before calling this method is the same as afterwards). However, if this method returns an error, the seek position is unspecified.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f531cfc3a2c409d73bd0f5c2e2364c282b1a69bd" translate="yes" xml:space="preserve">
          <source>This method is primarily intended for moving out values in drop. Instead of using &lt;a href=&quot;#method.drop&quot;&gt;&lt;code&gt;ManuallyDrop::drop&lt;/code&gt;&lt;/a&gt; to manually drop the value, you can use this method to take the value and use it however desired. &lt;code&gt;Drop&lt;/code&gt; will be invoked on the returned value following normal end-of-scope rules.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="923fe0c4f9dba0ad8dc8e37a00ed66b6a9da0759" translate="yes" xml:space="preserve">
          <source>This method is primarily used to interface with the &lt;a href=&quot;../macro.format_args&quot;&gt;&lt;code&gt;format_args!&lt;/code&gt;&lt;/a&gt; macro, but it is rare that this should explicitly be called. The &lt;a href=&quot;../macro.write&quot;&gt;&lt;code&gt;write!&lt;/code&gt;&lt;/a&gt; macro should be favored to invoke this method instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="80fc60d5306ac7d19519f64033eaf35397e48023" translate="yes" xml:space="preserve">
          <source>This method is soft-deprecated. &lt;a href=&quot;../../error/trait.error#method.description&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7e4625fa8bf128959917fb79c2180bb0bb7de232" translate="yes" xml:space="preserve">
          <source>This method is soft-deprecated. &lt;a href=&quot;../error/trait.error#method.description&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6a9beb6c54e6c8b198cf2df220314195725bd7bb" translate="yes" xml:space="preserve">
          <source>This method is soft-deprecated. &lt;a href=&quot;error/trait.error#method.description&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5490d12dcf25f9008acb9584a8ddf0c95e1664f2" translate="yes" xml:space="preserve">
          <source>This method is stable and usable, but it should be unsafe. To fix that, it got deprecated in favor of the unsafe &lt;a href=&quot;#tymethod.pre_exec&quot;&gt;&lt;code&gt;pre_exec&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="881a668b22b8af1fbfcb4abff65037dd8a73fd44" translate="yes" xml:space="preserve">
          <source>This method is unsafe because a &lt;code&gt;Read&lt;/code&gt;er could otherwise return a non-zeroing &lt;code&gt;Initializer&lt;/code&gt; from another &lt;code&gt;Read&lt;/code&gt; type without an &lt;code&gt;unsafe&lt;/code&gt; block.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b649b72cfd66bc53cdd1236dc499f467fbbbfc65" translate="yes" xml:space="preserve">
          <source>This method requires &lt;a href=&quot;../clone/trait.clone&quot;&gt;&lt;code&gt;Clone&lt;/code&gt;&lt;/a&gt; to be able clone the passed value. If you need more flexibility (or want to rely on &lt;a href=&quot;../default/trait.default&quot;&gt;&lt;code&gt;Default&lt;/code&gt;&lt;/a&gt; instead of &lt;a href=&quot;../clone/trait.clone&quot;&gt;&lt;code&gt;Clone&lt;/code&gt;&lt;/a&gt;), use &lt;a href=&quot;#method.resize_with&quot;&gt;&lt;code&gt;resize_with&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b95f081db21ce8cf4e6f46e10880425784f2765c" translate="yes" xml:space="preserve">
          <source>This method returns &lt;a href=&quot;../primitive.bool&quot;&gt;&lt;code&gt;true&lt;/code&gt;&lt;/a&gt; for addresses in the range reserved by [RFC 4291 section 2.4], i.e. addresses with the following format:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="14217d50c79e4eb45c163835b69cd4e673a45e20" translate="yes" xml:space="preserve">
          <source>This method returns &lt;a href=&quot;../primitive.bool&quot;&gt;&lt;code&gt;true&lt;/code&gt;&lt;/a&gt; for site-local addresses as per &lt;a href=&quot;https://tools.ietf.org/html/rfc4291#section-2.5.7&quot;&gt;RFC 4291 section 2.5.7&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1fe438568aa64ab40ad3ae63a4e80c06e5f2d121" translate="yes" xml:space="preserve">
          <source>This method returns &lt;code&gt;true&lt;/code&gt; after iteration has finished:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="da8759d1633206733343524980d7a489afd16956" translate="yes" xml:space="preserve">
          <source>This method returns an &lt;code&gt;Ordering&lt;/code&gt; between &lt;code&gt;self&lt;/code&gt; and &lt;code&gt;other&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9f3bbc3554d60688630609ad13846c405e876fac" translate="yes" xml:space="preserve">
          <source>This method returns an &lt;code&gt;Ordering&lt;/code&gt; between &lt;code&gt;self&lt;/code&gt; and &lt;code&gt;other&lt;/code&gt;. &lt;a href=&quot;../../cmp/trait.ord#tymethod.cmp&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e875552f6e4025920ca5a71d7c281b1fbfaaa2a8" translate="yes" xml:space="preserve">
          <source>This method returns an &lt;code&gt;Ordering&lt;/code&gt; between &lt;code&gt;self&lt;/code&gt; and &lt;code&gt;other&lt;/code&gt;. &lt;a href=&quot;../cmp/trait.ord#tymethod.cmp&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="400399c6db28cb18bc3db2944eff105cd4fca3da" translate="yes" xml:space="preserve">
          <source>This method returns an &lt;code&gt;Ordering&lt;/code&gt; between &lt;code&gt;self&lt;/code&gt; and &lt;code&gt;other&lt;/code&gt;. &lt;a href=&quot;cmp/trait.ord#tymethod.cmp&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1a47b24f63b5fe410c6da12441f9c98d2fe17c15" translate="yes" xml:space="preserve">
          <source>This method returns an &lt;code&gt;Ordering&lt;/code&gt; between &lt;code&gt;self&lt;/code&gt; and &lt;code&gt;other&lt;/code&gt;. &lt;a href=&quot;trait.ord#tymethod.cmp&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c3cf087c16e29fe754de64f334036b96fe0b3931" translate="yes" xml:space="preserve">
          <source>This method returns an ordering between &lt;code&gt;self&lt;/code&gt; and &lt;code&gt;other&lt;/code&gt; values if one exists.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eb17b52a796e0693ad06487790fde93b26d1d781" translate="yes" xml:space="preserve">
          <source>This method returns an ordering between &lt;code&gt;self&lt;/code&gt; and &lt;code&gt;other&lt;/code&gt; values if one exists. &lt;a href=&quot;../../cmp/trait.partialord#tymethod.partial_cmp&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="39953b189e90eb45e12641b5213bac17fb6a067f" translate="yes" xml:space="preserve">
          <source>This method returns an ordering between &lt;code&gt;self&lt;/code&gt; and &lt;code&gt;other&lt;/code&gt; values if one exists. &lt;a href=&quot;../cmp/trait.partialord#tymethod.partial_cmp&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a426df736d2450e1483768eb842876560c3cb8d7" translate="yes" xml:space="preserve">
          <source>This method returns an ordering between &lt;code&gt;self&lt;/code&gt; and &lt;code&gt;other&lt;/code&gt; values if one exists. &lt;a href=&quot;cmp/trait.partialord#tymethod.partial_cmp&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d64233d3af8194ec0eefc11c727f80c62d14630a" translate="yes" xml:space="preserve">
          <source>This method returns an ordering between &lt;code&gt;self&lt;/code&gt; and &lt;code&gt;other&lt;/code&gt; values if one exists. &lt;a href=&quot;trait.partialord#tymethod.partial_cmp&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="edb583eeb291a512bd3d2447d1fbe080bc3b9dce" translate="yes" xml:space="preserve">
          <source>This method should generally not be invoked manually, but rather through the &lt;a href=&quot;../macro.write&quot;&gt;&lt;code&gt;write!&lt;/code&gt;&lt;/a&gt; macro itself.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d7174476c42e976c470e5d3d833837447fe7b624" translate="yes" xml:space="preserve">
          <source>This method splits the slice into three distinct slices: prefix, correctly aligned middle slice of a new type, and the suffix slice. The method does a best effort to make the middle slice the greatest length possible for a given type and input slice, but only your algorithm's performance should depend on that, not its correctness.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8000abb209a936f78ade63de708f2749dd5748c7" translate="yes" xml:space="preserve">
          <source>This method tests for &lt;code&gt;!=&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3639f2a22177e5f40d5314d575e638c54018960a" translate="yes" xml:space="preserve">
          <source>This method tests for &lt;code&gt;self&lt;/code&gt; and &lt;code&gt;other&lt;/code&gt; values to be equal, and is used by &lt;code&gt;==&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f00abfa17fbf62bab913260c77c4736307dd6b08" translate="yes" xml:space="preserve">
          <source>This method tests for &lt;code&gt;self&lt;/code&gt; and &lt;code&gt;other&lt;/code&gt; values to be equal, and is used by &lt;code&gt;==&lt;/code&gt;. &lt;a href=&quot;../../cmp/trait.partialeq#tymethod.eq&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c257c51217cc2c43c24273fbc2f10164037dd5b1" translate="yes" xml:space="preserve">
          <source>This method tests for &lt;code&gt;self&lt;/code&gt; and &lt;code&gt;other&lt;/code&gt; values to be equal, and is used by &lt;code&gt;==&lt;/code&gt;. &lt;a href=&quot;../cmp/trait.partialeq#tymethod.eq&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="34550195d18fa1542599bef9324d74efad99aeb1" translate="yes" xml:space="preserve">
          <source>This method tests for &lt;code&gt;self&lt;/code&gt; and &lt;code&gt;other&lt;/code&gt; values to be equal, and is used by &lt;code&gt;==&lt;/code&gt;. &lt;a href=&quot;cmp/trait.partialeq#tymethod.eq&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d32084f8ce776d9a529be0f1da6ec9ca22e44396" translate="yes" xml:space="preserve">
          <source>This method tests for &lt;code&gt;self&lt;/code&gt; and &lt;code&gt;other&lt;/code&gt; values to be equal, and is used by &lt;code&gt;==&lt;/code&gt;. &lt;a href=&quot;trait.partialeq#tymethod.eq&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9893b74b381c1707e88afd0a7ed6401e06b38424" translate="yes" xml:space="preserve">
          <source>This method tests greater than (for &lt;code&gt;self&lt;/code&gt; and &lt;code&gt;other&lt;/code&gt;) and is used by the &lt;code&gt;&amp;gt;&lt;/code&gt; operator.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9be75e39e05fc52a961a6f8a30bebafa3abc619e" translate="yes" xml:space="preserve">
          <source>This method tests greater than (for &lt;code&gt;self&lt;/code&gt; and &lt;code&gt;other&lt;/code&gt;) and is used by the &lt;code&gt;&amp;gt;&lt;/code&gt; operator. &lt;a href=&quot;../../cmp/trait.partialord#method.gt&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8b084733b90b43f4725bbd31294cb1f36404ce0a" translate="yes" xml:space="preserve">
          <source>This method tests greater than (for &lt;code&gt;self&lt;/code&gt; and &lt;code&gt;other&lt;/code&gt;) and is used by the &lt;code&gt;&amp;gt;&lt;/code&gt; operator. &lt;a href=&quot;../cmp/trait.partialord#method.gt&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="44184bc5bd845c73d3a6bdc521b7927b64cd5369" translate="yes" xml:space="preserve">
          <source>This method tests greater than (for &lt;code&gt;self&lt;/code&gt; and &lt;code&gt;other&lt;/code&gt;) and is used by the &lt;code&gt;&amp;gt;&lt;/code&gt; operator. &lt;a href=&quot;cmp/trait.partialord#method.gt&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8eec657a4246dd487288b986e3d57dfd9657b208" translate="yes" xml:space="preserve">
          <source>This method tests greater than (for &lt;code&gt;self&lt;/code&gt; and &lt;code&gt;other&lt;/code&gt;) and is used by the &lt;code&gt;&amp;gt;&lt;/code&gt; operator. &lt;a href=&quot;trait.partialord#method.gt&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0eabc442f100ec2b7e353c049aaaf4ca623d1f2c" translate="yes" xml:space="preserve">
          <source>This method tests greater than or equal to (for &lt;code&gt;self&lt;/code&gt; and &lt;code&gt;other&lt;/code&gt;) and is used by the &lt;code&gt;&amp;gt;=&lt;/code&gt; operator.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4194eb24934481036250e733ab18937ab48da677" translate="yes" xml:space="preserve">
          <source>This method tests greater than or equal to (for &lt;code&gt;self&lt;/code&gt; and &lt;code&gt;other&lt;/code&gt;) and is used by the &lt;code&gt;&amp;gt;=&lt;/code&gt; operator. &lt;a href=&quot;../../cmp/trait.partialord#method.ge&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="219eec29ea3645fe37ee0a3de43c26a2abe5b61f" translate="yes" xml:space="preserve">
          <source>This method tests greater than or equal to (for &lt;code&gt;self&lt;/code&gt; and &lt;code&gt;other&lt;/code&gt;) and is used by the &lt;code&gt;&amp;gt;=&lt;/code&gt; operator. &lt;a href=&quot;../cmp/trait.partialord#method.ge&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a7907168214aeaea1aa4db413b937e0f747bd41c" translate="yes" xml:space="preserve">
          <source>This method tests greater than or equal to (for &lt;code&gt;self&lt;/code&gt; and &lt;code&gt;other&lt;/code&gt;) and is used by the &lt;code&gt;&amp;gt;=&lt;/code&gt; operator. &lt;a href=&quot;cmp/trait.partialord#method.ge&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e579d59fed2657492555041f61545aa7206f59b6" translate="yes" xml:space="preserve">
          <source>This method tests greater than or equal to (for &lt;code&gt;self&lt;/code&gt; and &lt;code&gt;other&lt;/code&gt;) and is used by the &lt;code&gt;&amp;gt;=&lt;/code&gt; operator. &lt;a href=&quot;trait.partialord#method.ge&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c0e789163efc5086c683b5a1f62c9a3bb50e4538" translate="yes" xml:space="preserve">
          <source>This method tests less than (for &lt;code&gt;self&lt;/code&gt; and &lt;code&gt;other&lt;/code&gt;) and is used by the &lt;code&gt;&amp;lt;&lt;/code&gt; operator.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a9a38093c98e8f8478fc7a4cb9a47c1ad908df47" translate="yes" xml:space="preserve">
          <source>This method tests less than (for &lt;code&gt;self&lt;/code&gt; and &lt;code&gt;other&lt;/code&gt;) and is used by the &lt;code&gt;&amp;lt;&lt;/code&gt; operator. &lt;a href=&quot;../../cmp/trait.partialord#method.lt&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d167afca39913e71e4062a05ae7a9d99838896ab" translate="yes" xml:space="preserve">
          <source>This method tests less than (for &lt;code&gt;self&lt;/code&gt; and &lt;code&gt;other&lt;/code&gt;) and is used by the &lt;code&gt;&amp;lt;&lt;/code&gt; operator. &lt;a href=&quot;../cmp/trait.partialord#method.lt&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8ebc7cc22118ac04d1f984d545d5be0d85818a1e" translate="yes" xml:space="preserve">
          <source>This method tests less than (for &lt;code&gt;self&lt;/code&gt; and &lt;code&gt;other&lt;/code&gt;) and is used by the &lt;code&gt;&amp;lt;&lt;/code&gt; operator. &lt;a href=&quot;cmp/trait.partialord#method.lt&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="54945ad3f8cac4a154fb7b9e35518b30ae999d4d" translate="yes" xml:space="preserve">
          <source>This method tests less than (for &lt;code&gt;self&lt;/code&gt; and &lt;code&gt;other&lt;/code&gt;) and is used by the &lt;code&gt;&amp;lt;&lt;/code&gt; operator. &lt;a href=&quot;trait.partialord#method.lt&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d161a6ff3e691349ec054ac0d4002d49a30e7893" translate="yes" xml:space="preserve">
          <source>This method tests less than or equal to (for &lt;code&gt;self&lt;/code&gt; and &lt;code&gt;other&lt;/code&gt;) and is used by the &lt;code&gt;&amp;lt;=&lt;/code&gt; operator.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aadf89f483a504081f46ca5ef3749d0af43a4387" translate="yes" xml:space="preserve">
          <source>This method tests less than or equal to (for &lt;code&gt;self&lt;/code&gt; and &lt;code&gt;other&lt;/code&gt;) and is used by the &lt;code&gt;&amp;lt;=&lt;/code&gt; operator. &lt;a href=&quot;../../cmp/trait.partialord#method.le&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ddb1ab74197bbadea31b206cbb3f4c8f2c4d9f37" translate="yes" xml:space="preserve">
          <source>This method tests less than or equal to (for &lt;code&gt;self&lt;/code&gt; and &lt;code&gt;other&lt;/code&gt;) and is used by the &lt;code&gt;&amp;lt;=&lt;/code&gt; operator. &lt;a href=&quot;../cmp/trait.partialord#method.le&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="db00fc514ef8b2e5769c8d739b13605dcfb91f42" translate="yes" xml:space="preserve">
          <source>This method tests less than or equal to (for &lt;code&gt;self&lt;/code&gt; and &lt;code&gt;other&lt;/code&gt;) and is used by the &lt;code&gt;&amp;lt;=&lt;/code&gt; operator. &lt;a href=&quot;cmp/trait.partialord#method.le&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bca462ad1eb0c753d442b14b7fe002228f03d1ee" translate="yes" xml:space="preserve">
          <source>This method tests less than or equal to (for &lt;code&gt;self&lt;/code&gt; and &lt;code&gt;other&lt;/code&gt;) and is used by the &lt;code&gt;&amp;lt;=&lt;/code&gt; operator. &lt;a href=&quot;trait.partialord#method.le&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5f2ae443e73d5f88ef06a1d6b529c7d18527f78a" translate="yes" xml:space="preserve">
          <source>This method uses &lt;a href=&quot;../default/trait.default&quot;&gt;&lt;code&gt;Default&lt;/code&gt;&lt;/a&gt; to create new values on every push. If you'd rather &lt;a href=&quot;../clone/trait.clone&quot;&gt;&lt;code&gt;Clone&lt;/code&gt;&lt;/a&gt; a given value, use &lt;a href=&quot;#method.resize&quot;&gt;&lt;code&gt;resize&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a5ffc4fb20de54f6e75ded6f37d7e6542ba4dcb3" translate="yes" xml:space="preserve">
          <source>This method uses a closure to create new values on every push. If you'd rather &lt;a href=&quot;../clone/trait.clone&quot;&gt;&lt;code&gt;Clone&lt;/code&gt;&lt;/a&gt; a given value, use &lt;a href=&quot;#method.resize&quot;&gt;&lt;code&gt;resize&lt;/code&gt;&lt;/a&gt;. If you want to use the &lt;a href=&quot;../default/trait.default&quot;&gt;&lt;code&gt;Default&lt;/code&gt;&lt;/a&gt; trait to generate values, you can pass &lt;a href=&quot;../default/trait.default#tymethod.default&quot;&gt;&lt;code&gt;Default::default()&lt;/code&gt;&lt;/a&gt; as the second argument.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="57f44223f055f4bc85ef6eebc9a26838b98e07df" translate="yes" xml:space="preserve">
          <source>This method validates the format defined in the RFC and won't recognize the following addresses such as &lt;code&gt;fe80:0:0:1::&lt;/code&gt; or &lt;code&gt;fe81::&lt;/code&gt; as unicast link-local addresses for example. If you need a less strict validation use &lt;a href=&quot;struct.ipv6addr#method.is_unicast_link_local&quot;&gt;&lt;code&gt;is_unicast_link_local()&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="34a9aeb12096c73821e3d3f2146e3bcd68d312a7" translate="yes" xml:space="preserve">
          <source>This method will be deprecated in favor of the identically-named inherent methods on &lt;code&gt;u8&lt;/code&gt;, &lt;code&gt;char&lt;/code&gt;, &lt;code&gt;[u8]&lt;/code&gt; and &lt;code&gt;str&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dab63bf4ac92d7a8265610c22503839aea1e5938" translate="yes" xml:space="preserve">
          <source>This method will block the calling thread if another initialization routine is currently running.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4dcd7df93995d5669f9a19d9090b19b5d2473592" translate="yes" xml:space="preserve">
          <source>This method will continuously call &lt;a href=&quot;#tymethod.write&quot;&gt;&lt;code&gt;write&lt;/code&gt;&lt;/a&gt; until there is no more data to be written or an error of non-&lt;a href=&quot;enum.errorkind#variant.Interrupted&quot;&gt;&lt;code&gt;ErrorKind::Interrupted&lt;/code&gt;&lt;/a&gt; kind is returned. This method will not return until the entire buffer has been successfully written or such an error occurs. The first error that is not of &lt;a href=&quot;enum.errorkind#variant.Interrupted&quot;&gt;&lt;code&gt;ErrorKind::Interrupted&lt;/code&gt;&lt;/a&gt; kind generated from this method will be returned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0bf4855a0328106cbe0baa3671aad93298aa630b" translate="yes" xml:space="preserve">
          <source>This method will continuously call &lt;a href=&quot;#tymethod.write_at&quot;&gt;&lt;code&gt;write_at&lt;/code&gt;&lt;/a&gt; until there is no more data to be written or an error of non-&lt;a href=&quot;../../../io/enum.errorkind#variant.Interrupted&quot;&gt;&lt;code&gt;ErrorKind::Interrupted&lt;/code&gt;&lt;/a&gt; kind is returned. This method will not return until the entire buffer has been successfully written or such an error occurs. The first error that is not of &lt;a href=&quot;../../../io/enum.errorkind#variant.Interrupted&quot;&gt;&lt;code&gt;ErrorKind::Interrupted&lt;/code&gt;&lt;/a&gt; kind generated from this method will be returned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b531b20d0eb83c8a34e8a69001999cab52351ebf" translate="yes" xml:space="preserve">
          <source>This method will currently always return &lt;a href=&quot;../option/enum.option#variant.Some&quot;&gt;&lt;code&gt;Some&lt;/code&gt;&lt;/a&gt;, but this may change in future versions.</source>
          <target state="new"/>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
