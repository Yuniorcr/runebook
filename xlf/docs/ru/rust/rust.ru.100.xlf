<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ru" datatype="htmlbody" original="rust">
    <body>
      <group id="rust">
        <trans-unit id="800e827a6bd80027fcc168148b39b2bc4798dafa" translate="yes" xml:space="preserve">
          <source>TakeWhile::partial_cmp</source>
          <target state="translated">TakeWhile::partial_cmp</target>
        </trans-unit>
        <trans-unit id="756f2fd59afc727df9fab561f13734ed10cc1035" translate="yes" xml:space="preserve">
          <source>TakeWhile::partition</source>
          <target state="translated">TakeWhile::partition</target>
        </trans-unit>
        <trans-unit id="b3708fa6ef243ab03b8f0e01148054537baba7c2" translate="yes" xml:space="preserve">
          <source>TakeWhile::peekable</source>
          <target state="translated">TakeWhile::peekable</target>
        </trans-unit>
        <trans-unit id="3ddf00384fd53b19d286b7ce9f31e5c8e130add2" translate="yes" xml:space="preserve">
          <source>TakeWhile::position</source>
          <target state="translated">TakeWhile::position</target>
        </trans-unit>
        <trans-unit id="103103944a1d96c94fd7efea8dc3417e1dcec47e" translate="yes" xml:space="preserve">
          <source>TakeWhile::product</source>
          <target state="translated">TakeWhile::product</target>
        </trans-unit>
        <trans-unit id="9db7de0140db3938f59bf212e7c6b8c4ab1a5b22" translate="yes" xml:space="preserve">
          <source>TakeWhile::rev</source>
          <target state="translated">TakeWhile::rev</target>
        </trans-unit>
        <trans-unit id="aa7afa9cbae96b3a55ad383eb829e62995e9d3b0" translate="yes" xml:space="preserve">
          <source>TakeWhile::rposition</source>
          <target state="translated">TakeWhile::rposition</target>
        </trans-unit>
        <trans-unit id="aad375a583a0085240c857eb42a8dfb87e2e4e1c" translate="yes" xml:space="preserve">
          <source>TakeWhile::scan</source>
          <target state="translated">TakeWhile::scan</target>
        </trans-unit>
        <trans-unit id="cd86cfe53884486177c23f0ff823be46500dc9e1" translate="yes" xml:space="preserve">
          <source>TakeWhile::size_hint</source>
          <target state="translated">TakeWhile::size_hint</target>
        </trans-unit>
        <trans-unit id="5e176c9b3bf37b02aef10f7907a61a6ac9a47da8" translate="yes" xml:space="preserve">
          <source>TakeWhile::skip</source>
          <target state="translated">TakeWhile::skip</target>
        </trans-unit>
        <trans-unit id="64e54491abe005b30c8d866999d58ab787b271b2" translate="yes" xml:space="preserve">
          <source>TakeWhile::skip_while</source>
          <target state="translated">TakeWhile::skip_while</target>
        </trans-unit>
        <trans-unit id="ba9f9f10db1b73ab0c564edb9c28453e72ee8d7c" translate="yes" xml:space="preserve">
          <source>TakeWhile::step_by</source>
          <target state="translated">TakeWhile::step_by</target>
        </trans-unit>
        <trans-unit id="9d9273a97581b55606d39ff31ae4fc4bd97d0343" translate="yes" xml:space="preserve">
          <source>TakeWhile::sum</source>
          <target state="translated">TakeWhile::sum</target>
        </trans-unit>
        <trans-unit id="c679b6dec55380d66c68043added100d9b1e3e12" translate="yes" xml:space="preserve">
          <source>TakeWhile::take</source>
          <target state="translated">TakeWhile::take</target>
        </trans-unit>
        <trans-unit id="98bc022ab936f48f4c132862157a433b58b1ed1d" translate="yes" xml:space="preserve">
          <source>TakeWhile::take_while</source>
          <target state="translated">TakeWhile::take_while</target>
        </trans-unit>
        <trans-unit id="b57cfb71237e7ec5ab624251b87030d240a46226" translate="yes" xml:space="preserve">
          <source>TakeWhile::to_owned</source>
          <target state="translated">TakeWhile::to_owned</target>
        </trans-unit>
        <trans-unit id="37e399f48eff7903115e7d86661abdf8e05fd4b1" translate="yes" xml:space="preserve">
          <source>TakeWhile::try_fold</source>
          <target state="translated">TakeWhile::try_fold</target>
        </trans-unit>
        <trans-unit id="759bc51854e6a28a5380a5f6b7a415cd0f555f0f" translate="yes" xml:space="preserve">
          <source>TakeWhile::try_for_each</source>
          <target state="translated">TakeWhile::try_for_each</target>
        </trans-unit>
        <trans-unit id="7fb911b85cc860ff38f3b721f59503e01735b148" translate="yes" xml:space="preserve">
          <source>TakeWhile::try_from</source>
          <target state="translated">TakeWhile::try_from</target>
        </trans-unit>
        <trans-unit id="5de7c55a9b68a872ef23f0276b88d1c9ecf0fc8a" translate="yes" xml:space="preserve">
          <source>TakeWhile::try_into</source>
          <target state="translated">TakeWhile::try_into</target>
        </trans-unit>
        <trans-unit id="87c136784211d463521272370803a4f358f45d54" translate="yes" xml:space="preserve">
          <source>TakeWhile::type_id</source>
          <target state="translated">TakeWhile::type_id</target>
        </trans-unit>
        <trans-unit id="2c32f5c719493f4a777e4c32b66c95f758c27273" translate="yes" xml:space="preserve">
          <source>TakeWhile::unzip</source>
          <target state="translated">TakeWhile::unzip</target>
        </trans-unit>
        <trans-unit id="d4376e438d96018f64f5876aa47fe4d14ae53315" translate="yes" xml:space="preserve">
          <source>TakeWhile::zip</source>
          <target state="translated">TakeWhile::zip</target>
        </trans-unit>
        <trans-unit id="686ef3911209faeb469101adcbd7e6e7d810ef4c" translate="yes" xml:space="preserve">
          <source>Takes &lt;code&gt;*O*(min(k, len() - k))&lt;/code&gt; time and no extra space.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d5ef4edffae6c9317836493dc9e695ad35618a15" translate="yes" xml:space="preserve">
          <source>Takes &lt;code&gt;*O*(min(mid, len() - mid))&lt;/code&gt; time and no extra space.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c4a3fbbd6670f1404e88f845d8e70bb6e1310ad2" translate="yes" xml:space="preserve">
          <source>Takes &lt;code&gt;O(min(k, len() - k))&lt;/code&gt; time and no extra space.</source>
          <target state="translated">Занимает &lt;code&gt;O(min(k, len() - k))&lt;/code&gt; времени и без лишнего места.</target>
        </trans-unit>
        <trans-unit id="2675fff809feea07b6b8e81b85ffeea6cb2ff42a" translate="yes" xml:space="preserve">
          <source>Takes &lt;code&gt;O(min(mid, len() - mid))&lt;/code&gt; time and no extra space.</source>
          <target state="translated">Занимает &lt;code&gt;O(min(mid, len() - mid))&lt;/code&gt; времени и без лишнего места.</target>
        </trans-unit>
        <trans-unit id="cd9e4e1ce47cfbb22bdd9618d61401a9a4bbe1ab" translate="yes" xml:space="preserve">
          <source>Takes a closure and creates an iterator which calls that closure on each element.</source>
          <target state="translated">Берет закрытие и создает итератор,который называет это закрытие на каждом элементе.</target>
        </trans-unit>
        <trans-unit id="9d3b7aa7666b1bb97d700268dbfed96edd954290" translate="yes" xml:space="preserve">
          <source>Takes a closure and creates an iterator which calls that closure on each element. &lt;a href=&quot;../../../iter/trait.iterator#method.map&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">Принимает закрытие и создает итератор, который вызывает это закрытие для каждого элемента. &lt;a href=&quot;../../../iter/trait.iterator#method.map&quot;&gt;Читать далее&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="15197bb083d7273e4a694b7c5e032b5e1c0781f3" translate="yes" xml:space="preserve">
          <source>Takes a closure and creates an iterator which calls that closure on each element. &lt;a href=&quot;../../iter/trait.iterator#method.map&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">Принимает закрытие и создает итератор, который вызывает это закрытие для каждого элемента. &lt;a href=&quot;../../iter/trait.iterator#method.map&quot;&gt;Читать далее&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="4434c8dd599ef23b0c9ba44e32c1fa55b943ae82" translate="yes" xml:space="preserve">
          <source>Takes a closure and creates an iterator which calls that closure on each element. &lt;a href=&quot;../iter/trait.iterator#method.map&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">Принимает закрытие и создает итератор, который вызывает это закрытие для каждого элемента. &lt;a href=&quot;../iter/trait.iterator#method.map&quot;&gt;Читать далее&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="6257eea37e0de73bcadd8777f056a323db82c336" translate="yes" xml:space="preserve">
          <source>Takes a closure and creates an iterator which calls that closure on each element. &lt;a href=&quot;iter/trait.iterator#method.map&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">Принимает закрытие и создает итератор, который вызывает это закрытие для каждого элемента. &lt;a href=&quot;iter/trait.iterator#method.map&quot;&gt;Читать далее&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="b1ad1d9466847f0b48f38483a158304137e697a6" translate="yes" xml:space="preserve">
          <source>Takes a closure and creates an iterator which calls that closure on each element. &lt;a href=&quot;trait.iterator#method.map&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">Принимает закрытие и создает итератор, который вызывает это закрытие для каждого элемента. &lt;a href=&quot;trait.iterator#method.map&quot;&gt;Читать далее&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="b67dad0714b16a4867cfc86c2882827f4a196a85" translate="yes" xml:space="preserve">
          <source>Takes each element in the &lt;a href=&quot;../iter/trait.iterator&quot;&gt;&lt;code&gt;Iterator&lt;/code&gt;&lt;/a&gt;: if it is &lt;a href=&quot;enum.option#None.v&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt;, no further elements are taken, and the &lt;a href=&quot;enum.option#None.v&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt; is returned. Should no &lt;a href=&quot;enum.option#None.v&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt; occur, a container with the values of each &lt;a href=&quot;enum.option&quot;&gt;&lt;code&gt;Option&lt;/code&gt;&lt;/a&gt; is returned.</source>
          <target state="translated">Принимает каждый элемент в &lt;a href=&quot;../iter/trait.iterator&quot;&gt; &lt;code&gt;Iterator&lt;/code&gt; &lt;/a&gt; : если он равен &lt;a href=&quot;enum.option#None.v&quot;&gt; &lt;code&gt;None&lt;/code&gt; &lt;/a&gt; , никакие другие элементы не берутся, и возвращается &lt;a href=&quot;enum.option#None.v&quot;&gt; &lt;code&gt;None&lt;/code&gt; &lt;/a&gt; . Если нет &lt;a href=&quot;enum.option#None.v&quot;&gt; &lt;code&gt;None&lt;/code&gt; &lt;/a&gt; , возвращается контейнер со значениями каждого &lt;a href=&quot;enum.option&quot;&gt; &lt;code&gt;Option&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="c0d108a90f72b979216289a1535302bae686a314" translate="yes" xml:space="preserve">
          <source>Takes each element in the &lt;a href=&quot;../iter/trait.iterator&quot;&gt;&lt;code&gt;Iterator&lt;/code&gt;&lt;/a&gt;: if it is &lt;a href=&quot;enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt;, no further elements are taken, and the &lt;a href=&quot;enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt; is returned. Should no &lt;a href=&quot;enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt; occur, a container with the values of each &lt;a href=&quot;enum.option&quot;&gt;&lt;code&gt;Option&lt;/code&gt;&lt;/a&gt; is returned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6ae2387e48cfe171ba07e4b4b0225bc9c8162619" translate="yes" xml:space="preserve">
          <source>Takes each element in the &lt;a href=&quot;../iter/trait.iterator&quot;&gt;&lt;code&gt;Iterator&lt;/code&gt;&lt;/a&gt;: if it is a &lt;a href=&quot;enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt;, no further elements are taken, and the &lt;a href=&quot;enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt; is returned. Should no &lt;a href=&quot;enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt; occur, the product of all elements is returned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bbc47bd052a8b6d5124696117910cb85d1a433ca" translate="yes" xml:space="preserve">
          <source>Takes each element in the &lt;a href=&quot;../iter/trait.iterator&quot;&gt;&lt;code&gt;Iterator&lt;/code&gt;&lt;/a&gt;: if it is a &lt;a href=&quot;enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt;, no further elements are taken, and the &lt;a href=&quot;enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt; is returned. Should no &lt;a href=&quot;enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt; occur, the sum of all elements is returned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aa16ae10062698ed9b295ae08170d14623d7392d" translate="yes" xml:space="preserve">
          <source>Takes each element in the &lt;a href=&quot;../iter/trait.iterator&quot;&gt;&lt;code&gt;Iterator&lt;/code&gt;&lt;/a&gt;: if it is an &lt;a href=&quot;enum.result#variant.Err&quot;&gt;&lt;code&gt;Err&lt;/code&gt;&lt;/a&gt;, no further elements are taken, and the &lt;a href=&quot;enum.result#variant.Err&quot;&gt;&lt;code&gt;Err&lt;/code&gt;&lt;/a&gt; is returned. Should no &lt;a href=&quot;enum.result#variant.Err&quot;&gt;&lt;code&gt;Err&lt;/code&gt;&lt;/a&gt; occur, the product of all elements is returned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="36b254b78336a4f1d88a19a88b9cd87eebc4af74" translate="yes" xml:space="preserve">
          <source>Takes each element in the &lt;a href=&quot;../iter/trait.iterator&quot;&gt;&lt;code&gt;Iterator&lt;/code&gt;&lt;/a&gt;: if it is an &lt;a href=&quot;enum.result#variant.Err&quot;&gt;&lt;code&gt;Err&lt;/code&gt;&lt;/a&gt;, no further elements are taken, and the &lt;a href=&quot;enum.result#variant.Err&quot;&gt;&lt;code&gt;Err&lt;/code&gt;&lt;/a&gt; is returned. Should no &lt;a href=&quot;enum.result#variant.Err&quot;&gt;&lt;code&gt;Err&lt;/code&gt;&lt;/a&gt; occur, the sum of all elements is returned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7e929c2f84b980189b0ca395f9fd1ebf18d6a9b2" translate="yes" xml:space="preserve">
          <source>Takes each element in the &lt;a href=&quot;trait.iterator&quot;&gt;&lt;code&gt;Iterator&lt;/code&gt;&lt;/a&gt;: if it is &lt;a href=&quot;../option/enum.option#None.v&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt;, no further elements are taken, and the &lt;a href=&quot;../option/enum.option#None.v&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt; is returned. Should no &lt;a href=&quot;../option/enum.option#None.v&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt; occur, a container with the values of each &lt;a href=&quot;../option/enum.option&quot;&gt;&lt;code&gt;Option&lt;/code&gt;&lt;/a&gt; is returned.</source>
          <target state="translated">Принимает каждый элемент в &lt;a href=&quot;trait.iterator&quot;&gt; &lt;code&gt;Iterator&lt;/code&gt; &lt;/a&gt; : если он равен &lt;a href=&quot;../option/enum.option#None.v&quot;&gt; &lt;code&gt;None&lt;/code&gt; &lt;/a&gt; , никакие другие элементы не берутся, и возвращается &lt;a href=&quot;../option/enum.option#None.v&quot;&gt; &lt;code&gt;None&lt;/code&gt; &lt;/a&gt; . Если нет &lt;a href=&quot;../option/enum.option#None.v&quot;&gt; &lt;code&gt;None&lt;/code&gt; &lt;/a&gt; , возвращается контейнер со значениями каждого &lt;a href=&quot;../option/enum.option&quot;&gt; &lt;code&gt;Option&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="70a9e6b588aac0e816346721c7b37888db944102" translate="yes" xml:space="preserve">
          <source>Takes each element in the &lt;a href=&quot;trait.iterator&quot;&gt;&lt;code&gt;Iterator&lt;/code&gt;&lt;/a&gt;: if it is &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt;, no further elements are taken, and the &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt; is returned. Should no &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt; occur, a container with the values of each &lt;a href=&quot;../option/enum.option&quot;&gt;&lt;code&gt;Option&lt;/code&gt;&lt;/a&gt; is returned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f7590beabf441bb63691e8eea48b72c9c8f6a403" translate="yes" xml:space="preserve">
          <source>Takes each element in the &lt;a href=&quot;trait.iterator&quot;&gt;&lt;code&gt;Iterator&lt;/code&gt;&lt;/a&gt;: if it is a &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt;, no further elements are taken, and the &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt; is returned. Should no &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt; occur, the product of all elements is returned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ebc7f913ad909dfc000ef9eb96b0c827728188e0" translate="yes" xml:space="preserve">
          <source>Takes each element in the &lt;a href=&quot;trait.iterator&quot;&gt;&lt;code&gt;Iterator&lt;/code&gt;&lt;/a&gt;: if it is a &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt;, no further elements are taken, and the &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt; is returned. Should no &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt; occur, the sum of all elements is returned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ee1c7f91156f7afd567ca4e08a2abfd735e16c17" translate="yes" xml:space="preserve">
          <source>Takes each element in the &lt;a href=&quot;trait.iterator&quot;&gt;&lt;code&gt;Iterator&lt;/code&gt;&lt;/a&gt;: if it is an &lt;a href=&quot;../result/enum.result#variant.Err&quot;&gt;&lt;code&gt;Err&lt;/code&gt;&lt;/a&gt;, no further elements are taken, and the &lt;a href=&quot;../result/enum.result#variant.Err&quot;&gt;&lt;code&gt;Err&lt;/code&gt;&lt;/a&gt; is returned. Should no &lt;a href=&quot;../result/enum.result#variant.Err&quot;&gt;&lt;code&gt;Err&lt;/code&gt;&lt;/a&gt; occur, the product of all elements is returned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e3ccdebe9d4ccf3b0664327970602a14b42c1657" translate="yes" xml:space="preserve">
          <source>Takes each element in the &lt;a href=&quot;trait.iterator&quot;&gt;&lt;code&gt;Iterator&lt;/code&gt;&lt;/a&gt;: if it is an &lt;a href=&quot;../result/enum.result#variant.Err&quot;&gt;&lt;code&gt;Err&lt;/code&gt;&lt;/a&gt;, no further elements are taken, and the &lt;a href=&quot;../result/enum.result#variant.Err&quot;&gt;&lt;code&gt;Err&lt;/code&gt;&lt;/a&gt; is returned. Should no &lt;a href=&quot;../result/enum.result#variant.Err&quot;&gt;&lt;code&gt;Err&lt;/code&gt;&lt;/a&gt; occur, the sum of all elements is returned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b39228003dfd9a65d31657d9ccd88aa95394f718" translate="yes" xml:space="preserve">
          <source>Takes each element in the &lt;code&gt;Iterator&lt;/code&gt; and collects it into an &lt;code&gt;Arc&amp;lt;[T]&amp;gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f80659447eb965dd52f894d84ba633d8bce5db96" translate="yes" xml:space="preserve">
          <source>Takes each element in the &lt;code&gt;Iterator&lt;/code&gt; and collects it into an &lt;code&gt;Rc&amp;lt;[T]&amp;gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="217627f67f88406b5f9f17a93f1493e04a1a8227" translate="yes" xml:space="preserve">
          <source>Takes each element in the &lt;code&gt;Iterator&lt;/code&gt;: if it is a &lt;code&gt;None&lt;/code&gt;, no further elements are taken, and the &lt;code&gt;None&lt;/code&gt; is returned. Should no &lt;code&gt;None&lt;/code&gt; occur, the product of all elements is returned.</source>
          <target state="translated">Принимает каждый элемент в &lt;code&gt;Iterator&lt;/code&gt; : если это &lt;code&gt;None&lt;/code&gt; , никакие другие элементы не берутся и возвращается &lt;code&gt;None&lt;/code&gt; . Если нет &lt;code&gt;None&lt;/code&gt; , возвращается произведение всех элементов.</target>
        </trans-unit>
        <trans-unit id="e4aa0fd801953cd40a086ec1d2ff51bb44eb736e" translate="yes" xml:space="preserve">
          <source>Takes each element in the &lt;code&gt;Iterator&lt;/code&gt;: if it is a &lt;code&gt;None&lt;/code&gt;, no further elements are taken, and the &lt;code&gt;None&lt;/code&gt; is returned. Should no &lt;code&gt;None&lt;/code&gt; occur, the sum of all elements is returned.</source>
          <target state="translated">Принимает каждый элемент в &lt;code&gt;Iterator&lt;/code&gt; : если это &lt;code&gt;None&lt;/code&gt; , никакие другие элементы не берутся и возвращается &lt;code&gt;None&lt;/code&gt; . Если нет &lt;code&gt;None&lt;/code&gt; , возвращается сумма всех элементов.</target>
        </trans-unit>
        <trans-unit id="c1fb0a7041f8cb3602712be575a96b71a9c34edb" translate="yes" xml:space="preserve">
          <source>Takes each element in the &lt;code&gt;Iterator&lt;/code&gt;: if it is an &lt;code&gt;Err&lt;/code&gt;, no further elements are taken, and the &lt;code&gt;Err&lt;/code&gt; is returned. Should no &lt;code&gt;Err&lt;/code&gt; occur, a container with the values of each &lt;code&gt;Result&lt;/code&gt; is returned.</source>
          <target state="translated">Принимает каждый элемент в &lt;code&gt;Iterator&lt;/code&gt; : если это &lt;code&gt;Err&lt;/code&gt; , никакие другие элементы не берутся и возвращается &lt;code&gt;Err&lt;/code&gt; . Если &lt;code&gt;Err&lt;/code&gt; нет , возвращается контейнер со значениями каждого &lt;code&gt;Result&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="42c26fa2ecac3de7729494a9359458db2460cecc" translate="yes" xml:space="preserve">
          <source>Takes each element in the &lt;code&gt;Iterator&lt;/code&gt;: if it is an &lt;code&gt;Err&lt;/code&gt;, no further elements are taken, and the &lt;code&gt;Err&lt;/code&gt; is returned. Should no &lt;code&gt;Err&lt;/code&gt; occur, the product of all elements is returned.</source>
          <target state="translated">Принимает каждый элемент в &lt;code&gt;Iterator&lt;/code&gt; : если это &lt;code&gt;Err&lt;/code&gt; , никакие другие элементы не берутся и возвращается &lt;code&gt;Err&lt;/code&gt; . Если &lt;code&gt;Err&lt;/code&gt; возникает, возвращается произведение всех элементов.</target>
        </trans-unit>
        <trans-unit id="c82330496098a00243d3f411105f0f70776be883" translate="yes" xml:space="preserve">
          <source>Takes each element in the &lt;code&gt;Iterator&lt;/code&gt;: if it is an &lt;code&gt;Err&lt;/code&gt;, no further elements are taken, and the &lt;code&gt;Err&lt;/code&gt; is returned. Should no &lt;code&gt;Err&lt;/code&gt; occur, the sum of all elements is returned.</source>
          <target state="translated">Принимает каждый элемент в &lt;code&gt;Iterator&lt;/code&gt; : если это &lt;code&gt;Err&lt;/code&gt; , никакие другие элементы не берутся и возвращается &lt;code&gt;Err&lt;/code&gt; . Если &lt;code&gt;Err&lt;/code&gt; нет , возвращается сумма всех элементов.</target>
        </trans-unit>
        <trans-unit id="01d5fda76710ca0641abcbb3e4cbb1bb6e17f736" translate="yes" xml:space="preserve">
          <source>Takes each element, adds them together, and returns the result.</source>
          <target state="translated">Берет каждый элемент,складывает их вместе и возвращает результат.</target>
        </trans-unit>
        <trans-unit id="6776e27751852b377b68c46a8017d15dd715c595" translate="yes" xml:space="preserve">
          <source>Takes linear (in &lt;code&gt;self.len()&lt;/code&gt;) time.</source>
          <target state="translated">Занимает линейное (в &lt;code&gt;self.len()&lt;/code&gt; ) время.</target>
        </trans-unit>
        <trans-unit id="fdca1895a18c3a298f6533b4c2e334951c66b62c" translate="yes" xml:space="preserve">
          <source>Takes ownership and &quot;forgets&quot; about the value &lt;strong&gt;without running its destructor&lt;/strong&gt;.</source>
          <target state="translated">Принимает владение и &amp;laquo;забывает&amp;raquo; о значении &lt;strong&gt;без запуска его деструктора&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="b8fa769819072fbe610e5e9c85934d3a05171939" translate="yes" xml:space="preserve">
          <source>Takes the contained value out.</source>
          <target state="translated">Извлекает содержащееся в нем значение.</target>
        </trans-unit>
        <trans-unit id="4aec823974aa072f464dcb5cc764f9240e0f60dd" translate="yes" xml:space="preserve">
          <source>Takes the cubic root of a number.</source>
          <target state="translated">Берет кубический корень числа.</target>
        </trans-unit>
        <trans-unit id="f045194d706e7e41fabb862c8032ea26f5f950f2" translate="yes" xml:space="preserve">
          <source>Takes the reciprocal (inverse) of a number, &lt;code&gt;1/x&lt;/code&gt;.</source>
          <target state="translated">Принимает обратное (обратное) число &lt;code&gt;1/x&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6a48b57259f94b360feec04d91e3f646f9cba125" translate="yes" xml:space="preserve">
          <source>Takes the square root of a number.</source>
          <target state="translated">Получает квадратный корень числа.</target>
        </trans-unit>
        <trans-unit id="29583c6b4f13f8e1828da3f713db57dac29990e1" translate="yes" xml:space="preserve">
          <source>Takes the value from the &lt;code&gt;ManuallyDrop&amp;lt;T&amp;gt;&lt;/code&gt; container out.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bc799efc0b882851473c22ca2ca5ccf94ddabfe1" translate="yes" xml:space="preserve">
          <source>Takes the value of the cell, leaving &lt;code&gt;Default::default()&lt;/code&gt; in its place.</source>
          <target state="translated">Принимает значение ячейки, оставляя на его месте &lt;code&gt;Default::default()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="21859ca86840d9216ef1aca0008b5877f29f5e68" translate="yes" xml:space="preserve">
          <source>Takes the value of the entry out of the map, and returns it.</source>
          <target state="translated">Вынимает значение записи из карты и возвращает его.</target>
        </trans-unit>
        <trans-unit id="e353877ad2ec8473ab467885d9861796b98bdada" translate="yes" xml:space="preserve">
          <source>Takes the value out of the entry, and returns it.</source>
          <target state="translated">Вынимает значение из записи и возвращает его.</target>
        </trans-unit>
        <trans-unit id="761daab64ee172552a57dae50c6f8a92c4d9c366" translate="yes" xml:space="preserve">
          <source>Takes the value out of the option, leaving a &lt;a href=&quot;#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt; in its place.</source>
          <target state="translated">Убирает значение из опции, оставляя на ее месте &lt;a href=&quot;#variant.None&quot;&gt; &lt;code&gt;None&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="b7c52a2ee2d265275374b5c1f093b7a06a9428c4" translate="yes" xml:space="preserve">
          <source>Takes the value out of the option, leaving a &lt;a href=&quot;enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt; in its place.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ba923f497880c808c6be64ea728bee38b782b657" translate="yes" xml:space="preserve">
          <source>Takes the wrapped value, leaving &lt;code&gt;Default::default()&lt;/code&gt; in its place.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5f95b9cdf9802bc6e9feca2c7b307fe24034be8d" translate="yes" xml:space="preserve">
          <source>Takes two iterators and creates a new iterator over both in sequence.</source>
          <target state="translated">Берет два итератора и создает новый итератор над обоими в последовательности.</target>
        </trans-unit>
        <trans-unit id="787908ffef98464dc332707d755e2c4f129a3015" translate="yes" xml:space="preserve">
          <source>Takes two iterators and creates a new iterator over both in sequence. &lt;a href=&quot;../../../iter/trait.iterator#method.chain&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">Принимает два итератора и последовательно создает новый итератор для обоих. &lt;a href=&quot;../../../iter/trait.iterator#method.chain&quot;&gt;Читать далее&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="96c4c94db35b0a5de2fc876c74307d69f4d1f941" translate="yes" xml:space="preserve">
          <source>Takes two iterators and creates a new iterator over both in sequence. &lt;a href=&quot;../../iter/trait.iterator#method.chain&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">Принимает два итератора и последовательно создает новый итератор для обоих. &lt;a href=&quot;../../iter/trait.iterator#method.chain&quot;&gt;Читать далее&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="09c1398fa07d7872f8f96945eceb77ea195aaf9f" translate="yes" xml:space="preserve">
          <source>Takes two iterators and creates a new iterator over both in sequence. &lt;a href=&quot;../iter/trait.iterator#method.chain&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">Принимает два итератора и последовательно создает новый итератор для обоих. &lt;a href=&quot;../iter/trait.iterator#method.chain&quot;&gt;Читать далее&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="4e8033a8a0d88d9c00564885e5bd3facaba3011b" translate="yes" xml:space="preserve">
          <source>Takes two iterators and creates a new iterator over both in sequence. &lt;a href=&quot;iter/trait.iterator#method.chain&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">Принимает два итератора и последовательно создает новый итератор для обоих. &lt;a href=&quot;iter/trait.iterator#method.chain&quot;&gt;Читать далее&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="772b77fdfc8e9968126bb233f7891ef8441c5352" translate="yes" xml:space="preserve">
          <source>Takes two iterators and creates a new iterator over both in sequence. &lt;a href=&quot;trait.iterator#method.chain&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">Принимает два итератора и последовательно создает новый итератор для обоих. &lt;a href=&quot;trait.iterator#method.chain&quot;&gt;Читать далее&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="e48610b94d0c8b865914c76042a0dd63c8ace3fb" translate="yes" xml:space="preserve">
          <source>Taking a &lt;a href=&quot;trait.fn&quot;&gt;&lt;code&gt;Fn&lt;/code&gt;&lt;/a&gt; as a parameter:</source>
          <target state="translated">Принимая &lt;a href=&quot;trait.fn&quot;&gt; &lt;code&gt;Fn&lt;/code&gt; &lt;/a&gt; в качестве параметра:</target>
        </trans-unit>
        <trans-unit id="4f62d9e379567856d558f8df128e53e7eeda59a9" translate="yes" xml:space="preserve">
          <source>Taking a &lt;a href=&quot;trait.fnmut&quot;&gt;&lt;code&gt;FnMut&lt;/code&gt;&lt;/a&gt; as a parameter:</source>
          <target state="translated">Принимая &lt;a href=&quot;trait.fnmut&quot;&gt; &lt;code&gt;FnMut&lt;/code&gt; &lt;/a&gt; в качестве параметра:</target>
        </trans-unit>
        <trans-unit id="acf17a2c9691dbabd08f8be26e62792363680f2f" translate="yes" xml:space="preserve">
          <source>Taking a &lt;a href=&quot;trait.fnonce&quot;&gt;&lt;code&gt;FnOnce&lt;/code&gt;&lt;/a&gt; as a parameter:</source>
          <target state="translated">Принимая &lt;a href=&quot;trait.fnonce&quot;&gt; &lt;code&gt;FnOnce&lt;/code&gt; &lt;/a&gt; в качестве параметра:</target>
        </trans-unit>
        <trans-unit id="9b593af3c7f2108f31456b5ab2cb3574e71f3b6e" translate="yes" xml:space="preserve">
          <source>Taking ownership and then returning ownership with every function is a bit tedious. What if we want to let a function use a value but not take ownership? It&amp;rsquo;s quite annoying that anything we pass in also needs to be passed back if we want to use it again, in addition to any data resulting from the body of the function that we might want to return as well.</source>
          <target state="translated">Принятие права владения и последующее возвращение права собственности на каждую функцию немного утомительно. Что, если мы хотим разрешить функции использовать значение, но не владеть ею? Очень раздражает то, что все, что мы передаем, также необходимо передать обратно, если мы хотим использовать его снова, в дополнение к любым данным, полученным из тела функции, которые мы также можем захотеть вернуть.</target>
        </trans-unit>
        <trans-unit id="4aa5a6c5b61f9a1ca73ba483f7a4a44ead615a2c" translate="yes" xml:space="preserve">
          <source>Targets which do not support switching between linkage of the C runtime will ignore this flag. It's recommended to inspect the resulting binary to ensure that it's linked as you would expect after the compiler succeeds.</source>
          <target state="translated">Цели,не поддерживающие переключение между связями среды исполнения C,будут игнорировать этот флаг.Рекомендуется проверить результирующий двоичный файл,чтобы убедиться,что он компонован так,как вы ожидаете после успешной работы компилятора.</target>
        </trans-unit>
        <trans-unit id="9ad8024a2c7b1265fb5e22250fc7a31283cdbd36" translate="yes" xml:space="preserve">
          <source>TcpListener</source>
          <target state="translated">TcpListener</target>
        </trans-unit>
        <trans-unit id="ece7cdbc23c076f1d64f752343ef7aec8eec539f" translate="yes" xml:space="preserve">
          <source>TcpListener::accept</source>
          <target state="translated">TcpListener::accept</target>
        </trans-unit>
        <trans-unit id="a2a291bb7ab19718d31f7478d18104e4158a939c" translate="yes" xml:space="preserve">
          <source>TcpListener::as_raw_fd</source>
          <target state="translated">TcpListener::as_raw_fd</target>
        </trans-unit>
        <trans-unit id="49f5fe2427c190a7f8a472e06e6d569a7ff427c4" translate="yes" xml:space="preserve">
          <source>TcpListener::as_raw_socket</source>
          <target state="translated">TcpListener::as_raw_socket</target>
        </trans-unit>
        <trans-unit id="2e2338f796fa51dd367f2f2c91e316fe98afe3a0" translate="yes" xml:space="preserve">
          <source>TcpListener::bind</source>
          <target state="translated">TcpListener::bind</target>
        </trans-unit>
        <trans-unit id="bc75d22ad0ef01f38f6f564c0448b514f01f2b1e" translate="yes" xml:space="preserve">
          <source>TcpListener::borrow</source>
          <target state="translated">TcpListener::borrow</target>
        </trans-unit>
        <trans-unit id="b7bf89d05dc43863ce7b237f1c9339841b44d828" translate="yes" xml:space="preserve">
          <source>TcpListener::borrow_mut</source>
          <target state="translated">TcpListener::borrow_mut</target>
        </trans-unit>
        <trans-unit id="67148bab8cc6c3ad3159fa098deca2df5084c5bc" translate="yes" xml:space="preserve">
          <source>TcpListener::fmt</source>
          <target state="translated">TcpListener::fmt</target>
        </trans-unit>
        <trans-unit id="e2222d5e97ec906a2d58760a4b094c72e792239f" translate="yes" xml:space="preserve">
          <source>TcpListener::from</source>
          <target state="translated">TcpListener::from</target>
        </trans-unit>
        <trans-unit id="965dc7a632243e984a2b9e894788c6c21d7eb5d8" translate="yes" xml:space="preserve">
          <source>TcpListener::from_raw_fd</source>
          <target state="translated">TcpListener::from_raw_fd</target>
        </trans-unit>
        <trans-unit id="482dc849c70cec776e4f8a473271ccf0cb6cf277" translate="yes" xml:space="preserve">
          <source>TcpListener::from_raw_socket</source>
          <target state="translated">TcpListener::from_raw_socket</target>
        </trans-unit>
        <trans-unit id="1934b5e7d2fb2d8224b23b4ad0d2399a5cb3b873" translate="yes" xml:space="preserve">
          <source>TcpListener::incoming</source>
          <target state="translated">TcpListener::incoming</target>
        </trans-unit>
        <trans-unit id="428c642a4eaf5906beb8fe4edf0ac026bb70054c" translate="yes" xml:space="preserve">
          <source>TcpListener::into</source>
          <target state="translated">TcpListener::into</target>
        </trans-unit>
        <trans-unit id="ecf165a93c2c3a51f657446508db4792cbb31eef" translate="yes" xml:space="preserve">
          <source>TcpListener::into_raw_fd</source>
          <target state="translated">TcpListener::into_raw_fd</target>
        </trans-unit>
        <trans-unit id="171dba66a0881e83fbf754117718cae198277962" translate="yes" xml:space="preserve">
          <source>TcpListener::into_raw_socket</source>
          <target state="translated">TcpListener::into_raw_socket</target>
        </trans-unit>
        <trans-unit id="2275a3d2aa672ca4311b697b11d81ca54319cd4f" translate="yes" xml:space="preserve">
          <source>TcpListener::local_addr</source>
          <target state="translated">TcpListener::local_addr</target>
        </trans-unit>
        <trans-unit id="ec11714ec8bf6a942994646bb7ec40f6ec987004" translate="yes" xml:space="preserve">
          <source>TcpListener::only_v6</source>
          <target state="translated">TcpListener::only_v6</target>
        </trans-unit>
        <trans-unit id="8f9762884937dfa70d1e7429478f09a0cb47d310" translate="yes" xml:space="preserve">
          <source>TcpListener::set_nonblocking</source>
          <target state="translated">TcpListener::set_nonblocking</target>
        </trans-unit>
        <trans-unit id="226f648e250e40bcc471fd5a673bff010846e472" translate="yes" xml:space="preserve">
          <source>TcpListener::set_only_v6</source>
          <target state="translated">TcpListener::set_only_v6</target>
        </trans-unit>
        <trans-unit id="4715bf3aa73135001a12ace3fe29f1f7e2fa4701" translate="yes" xml:space="preserve">
          <source>TcpListener::set_ttl</source>
          <target state="translated">TcpListener::set_ttl</target>
        </trans-unit>
        <trans-unit id="52dd134154d36dce171d232dad1f997d4a86ef76" translate="yes" xml:space="preserve">
          <source>TcpListener::take_error</source>
          <target state="translated">TcpListener::take_error</target>
        </trans-unit>
        <trans-unit id="346a3319242ccfb5f2d382bc3687dc41f26c3692" translate="yes" xml:space="preserve">
          <source>TcpListener::try_clone</source>
          <target state="translated">TcpListener::try_clone</target>
        </trans-unit>
        <trans-unit id="8774def23dc815607fb5f6d621a655e6351d76ed" translate="yes" xml:space="preserve">
          <source>TcpListener::try_from</source>
          <target state="translated">TcpListener::try_from</target>
        </trans-unit>
        <trans-unit id="4d964782d52d7cadd1d535988a4c17142f01c956" translate="yes" xml:space="preserve">
          <source>TcpListener::try_into</source>
          <target state="translated">TcpListener::try_into</target>
        </trans-unit>
        <trans-unit id="720c95f141c0826fd5fca57448ce533672b87275" translate="yes" xml:space="preserve">
          <source>TcpListener::ttl</source>
          <target state="translated">TcpListener::ttl</target>
        </trans-unit>
        <trans-unit id="8b5ab82dcc35d3a2cd49204d3a4a7a3449b42f85" translate="yes" xml:space="preserve">
          <source>TcpListener::type_id</source>
          <target state="translated">TcpListener::type_id</target>
        </trans-unit>
        <trans-unit id="35342d32149945519f7e31daff4e30855fbeba49" translate="yes" xml:space="preserve">
          <source>TcpStream</source>
          <target state="translated">TcpStream</target>
        </trans-unit>
        <trans-unit id="9eafc6b129d5efa5c4b0a83e50a95e30344816f3" translate="yes" xml:space="preserve">
          <source>TcpStream::as_raw_fd</source>
          <target state="translated">TcpStream::as_raw_fd</target>
        </trans-unit>
        <trans-unit id="09ec2aef24015b31ab23113ac683d2f8346c1f39" translate="yes" xml:space="preserve">
          <source>TcpStream::as_raw_socket</source>
          <target state="translated">TcpStream::as_raw_socket</target>
        </trans-unit>
        <trans-unit id="12e762e3cfe2aa9d71a2a757abb3507e964d1881" translate="yes" xml:space="preserve">
          <source>TcpStream::borrow</source>
          <target state="translated">TcpStream::borrow</target>
        </trans-unit>
        <trans-unit id="d91a58f6ef21ac04bf7fb8b19bbc87b6dbe9fb4c" translate="yes" xml:space="preserve">
          <source>TcpStream::borrow_mut</source>
          <target state="translated">TcpStream::borrow_mut</target>
        </trans-unit>
        <trans-unit id="11f8dcda0e1ccab974f38cf496de4e39b14b25cb" translate="yes" xml:space="preserve">
          <source>TcpStream::by_ref</source>
          <target state="translated">TcpStream::by_ref</target>
        </trans-unit>
        <trans-unit id="bfbef109c2e4f33f2aedd0c714f14f49404d152c" translate="yes" xml:space="preserve">
          <source>TcpStream::bytes</source>
          <target state="translated">TcpStream::bytes</target>
        </trans-unit>
        <trans-unit id="e1fe899d60189a16135ede51a667e0fdef40fd00" translate="yes" xml:space="preserve">
          <source>TcpStream::chain</source>
          <target state="translated">TcpStream::chain</target>
        </trans-unit>
        <trans-unit id="9b075e5500b6c35efe89a7d4bf0762c653e6221c" translate="yes" xml:space="preserve">
          <source>TcpStream::connect</source>
          <target state="translated">TcpStream::connect</target>
        </trans-unit>
        <trans-unit id="7c9bc4cc7e00f6a9f012c5c2f74296bd08fb3cd9" translate="yes" xml:space="preserve">
          <source>TcpStream::connect_timeout</source>
          <target state="translated">TcpStream::connect_timeout</target>
        </trans-unit>
        <trans-unit id="7e82ba30a964300fd5401b21bdde38ef8892a264" translate="yes" xml:space="preserve">
          <source>TcpStream::flush</source>
          <target state="translated">TcpStream::flush</target>
        </trans-unit>
        <trans-unit id="5e2f83b6ef3a2fd9f5722070fe250aef910cb0f5" translate="yes" xml:space="preserve">
          <source>TcpStream::fmt</source>
          <target state="translated">TcpStream::fmt</target>
        </trans-unit>
        <trans-unit id="3a3304a1471ecd9e54075022592709e4164425d3" translate="yes" xml:space="preserve">
          <source>TcpStream::from</source>
          <target state="translated">TcpStream::from</target>
        </trans-unit>
        <trans-unit id="0c544151d800149c130a2b4e5fa0242d2c6c5fe2" translate="yes" xml:space="preserve">
          <source>TcpStream::from_raw_fd</source>
          <target state="translated">TcpStream::from_raw_fd</target>
        </trans-unit>
        <trans-unit id="f33ab52a5f61c4e532d24e2b9d448a864ab588ef" translate="yes" xml:space="preserve">
          <source>TcpStream::from_raw_socket</source>
          <target state="translated">TcpStream::from_raw_socket</target>
        </trans-unit>
        <trans-unit id="ac8cf31a8273795291384f9b9a189065f0e4ddda" translate="yes" xml:space="preserve">
          <source>TcpStream::initializer</source>
          <target state="translated">TcpStream::initializer</target>
        </trans-unit>
        <trans-unit id="bb02adb8fb5756c502d5d11c517f31b37848f5b3" translate="yes" xml:space="preserve">
          <source>TcpStream::into</source>
          <target state="translated">TcpStream::into</target>
        </trans-unit>
        <trans-unit id="8b62d5f9b1506a6417ce6b1e7abc2fe81f1a512b" translate="yes" xml:space="preserve">
          <source>TcpStream::into_raw_fd</source>
          <target state="translated">TcpStream::into_raw_fd</target>
        </trans-unit>
        <trans-unit id="2d62e49030fac395488f03a44bc65385d791c4a1" translate="yes" xml:space="preserve">
          <source>TcpStream::into_raw_socket</source>
          <target state="translated">TcpStream::into_raw_socket</target>
        </trans-unit>
        <trans-unit id="2f15c295f6cbee27e4704ba77400c3f9cdb74347" translate="yes" xml:space="preserve">
          <source>TcpStream::local_addr</source>
          <target state="translated">TcpStream::local_addr</target>
        </trans-unit>
        <trans-unit id="3e41769cd3c7bc5fe0ffd071decfac8538fce3c8" translate="yes" xml:space="preserve">
          <source>TcpStream::nodelay</source>
          <target state="translated">TcpStream::nodelay</target>
        </trans-unit>
        <trans-unit id="b1c4ef3a856c377290ba0effe22fa456b4c5d618" translate="yes" xml:space="preserve">
          <source>TcpStream::peek</source>
          <target state="translated">TcpStream::peek</target>
        </trans-unit>
        <trans-unit id="02b5be94fe4bd3a77f45294ce309a022defb0142" translate="yes" xml:space="preserve">
          <source>TcpStream::peer_addr</source>
          <target state="translated">TcpStream::peer_addr</target>
        </trans-unit>
        <trans-unit id="168308bcf15754b94b3cd0ff91dc84d727c89085" translate="yes" xml:space="preserve">
          <source>TcpStream::read</source>
          <target state="translated">TcpStream::read</target>
        </trans-unit>
        <trans-unit id="a51f803ec2bc3d6b94f3630947f31e7b2bee3ed5" translate="yes" xml:space="preserve">
          <source>TcpStream::read_exact</source>
          <target state="translated">TcpStream::read_exact</target>
        </trans-unit>
        <trans-unit id="cddced3b85b2ead651c93e97a2f622b9f49035db" translate="yes" xml:space="preserve">
          <source>TcpStream::read_timeout</source>
          <target state="translated">TcpStream::read_timeout</target>
        </trans-unit>
        <trans-unit id="1957796c8b2bd9a577cc9018f30d0a2d1c2fe241" translate="yes" xml:space="preserve">
          <source>TcpStream::read_to_end</source>
          <target state="translated">TcpStream::read_to_end</target>
        </trans-unit>
        <trans-unit id="9f494c5d56be921420520740cf0cbafa75a20b7b" translate="yes" xml:space="preserve">
          <source>TcpStream::read_to_string</source>
          <target state="translated">TcpStream::read_to_string</target>
        </trans-unit>
        <trans-unit id="c6fa288859680339e04670a33f1a14f57af1e652" translate="yes" xml:space="preserve">
          <source>TcpStream::read_vectored</source>
          <target state="translated">TcpStream::read_vectored</target>
        </trans-unit>
        <trans-unit id="e83138e7f219d526516674b5550a795c09cf97fa" translate="yes" xml:space="preserve">
          <source>TcpStream::set_nodelay</source>
          <target state="translated">TcpStream::set_nodelay</target>
        </trans-unit>
        <trans-unit id="6f3db10df76b321eadb9c9c65b440fd1e62d4157" translate="yes" xml:space="preserve">
          <source>TcpStream::set_nonblocking</source>
          <target state="translated">TcpStream::set_nonblocking</target>
        </trans-unit>
        <trans-unit id="0ef1754192987fd2a71c4d09d1363328c40af9e8" translate="yes" xml:space="preserve">
          <source>TcpStream::set_read_timeout</source>
          <target state="translated">TcpStream::set_read_timeout</target>
        </trans-unit>
        <trans-unit id="1c0d37734b35b5aaae88202ef8744780ebadf163" translate="yes" xml:space="preserve">
          <source>TcpStream::set_ttl</source>
          <target state="translated">TcpStream::set_ttl</target>
        </trans-unit>
        <trans-unit id="cf06a99e15825f5af0170343a971d82291a1bb70" translate="yes" xml:space="preserve">
          <source>TcpStream::set_write_timeout</source>
          <target state="translated">TcpStream::set_write_timeout</target>
        </trans-unit>
        <trans-unit id="de9f03e4aaf65b0dacf8a1a510098378140fbad7" translate="yes" xml:space="preserve">
          <source>TcpStream::shutdown</source>
          <target state="translated">TcpStream::shutdown</target>
        </trans-unit>
        <trans-unit id="f729ec43f0af2f4768020c3c186531540aa6fe75" translate="yes" xml:space="preserve">
          <source>TcpStream::take</source>
          <target state="translated">TcpStream::take</target>
        </trans-unit>
        <trans-unit id="07ca37092d4865ff34b3da8842e6f13eb4a33726" translate="yes" xml:space="preserve">
          <source>TcpStream::take_error</source>
          <target state="translated">TcpStream::take_error</target>
        </trans-unit>
        <trans-unit id="3f33672645be4d6e5bd0541f33a42009a106b1ad" translate="yes" xml:space="preserve">
          <source>TcpStream::try_clone</source>
          <target state="translated">TcpStream::try_clone</target>
        </trans-unit>
        <trans-unit id="0e120d19ada990068a0b20ff52db32daba2c74d5" translate="yes" xml:space="preserve">
          <source>TcpStream::try_from</source>
          <target state="translated">TcpStream::try_from</target>
        </trans-unit>
        <trans-unit id="0b039d724a73bfa4d009fb758a03fb779a56b987" translate="yes" xml:space="preserve">
          <source>TcpStream::try_into</source>
          <target state="translated">TcpStream::try_into</target>
        </trans-unit>
        <trans-unit id="833adb6a3443ef8c2bc774bcc30192c98f27094a" translate="yes" xml:space="preserve">
          <source>TcpStream::ttl</source>
          <target state="translated">TcpStream::ttl</target>
        </trans-unit>
        <trans-unit id="ad00f68ee2a21774a182c99f9b2a83cd6f6f89e9" translate="yes" xml:space="preserve">
          <source>TcpStream::type_id</source>
          <target state="translated">TcpStream::type_id</target>
        </trans-unit>
        <trans-unit id="accd5bacb0184a5ab554a0ca248574c5b5ddbbcb" translate="yes" xml:space="preserve">
          <source>TcpStream::write</source>
          <target state="translated">TcpStream::write</target>
        </trans-unit>
        <trans-unit id="0058eeee13c9051b5e0a752af3087b29d7b02d7b" translate="yes" xml:space="preserve">
          <source>TcpStream::write_all</source>
          <target state="translated">TcpStream::write_all</target>
        </trans-unit>
        <trans-unit id="cb06fd9c7d1d55fc4b3f3e15dc0163521ac1465b" translate="yes" xml:space="preserve">
          <source>TcpStream::write_fmt</source>
          <target state="translated">TcpStream::write_fmt</target>
        </trans-unit>
        <trans-unit id="a5e3f17e3264af59b558a0fdcba770ba3c28fa37" translate="yes" xml:space="preserve">
          <source>TcpStream::write_timeout</source>
          <target state="translated">TcpStream::write_timeout</target>
        </trans-unit>
        <trans-unit id="6e74581726f107bfc541797c5b9030282bc56e97" translate="yes" xml:space="preserve">
          <source>TcpStream::write_vectored</source>
          <target state="translated">TcpStream::write_vectored</target>
        </trans-unit>
        <trans-unit id="b6eac90e1928ad9ea4411f97ebcf59a5c7e10ed0" translate="yes" xml:space="preserve">
          <source>Teams of Developers</source>
          <target state="translated">Команды разработчиков</target>
        </trans-unit>
        <trans-unit id="260e040b381f220359095e13ffb45be2fbc63287" translate="yes" xml:space="preserve">
          <source>Tells LLVM that this point in the code is not reachable, enabling further optimizations.</source>
          <target state="translated">Сообщает LLVM,что этот пункт в коде недоступен,что позволяет провести дальнейшую оптимизацию.</target>
        </trans-unit>
        <trans-unit id="a946abf59c33631dd9c09fe026f5fda52ecefd51" translate="yes" xml:space="preserve">
          <source>Tells this buffer that &lt;code&gt;amt&lt;/code&gt; bytes have been consumed from the buffer, so they should no longer be returned in calls to &lt;code&gt;read&lt;/code&gt;.</source>
          <target state="translated">Сообщает этому буферу, что из буфера было израсходовано &lt;code&gt;amt&lt;/code&gt; байтов, поэтому они больше не должны возвращаться при вызовах &lt;code&gt;read&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="092a16374b222f88ad28cf25d43d7648234ed176" translate="yes" xml:space="preserve">
          <source>Tells this buffer that &lt;code&gt;amt&lt;/code&gt; bytes have been consumed from the buffer, so they should no longer be returned in calls to &lt;code&gt;read&lt;/code&gt;. &lt;a href=&quot;../io/trait.bufread#tymethod.consume&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">Сообщает этому буферу, что из буфера было израсходовано &lt;code&gt;amt&lt;/code&gt; байтов, поэтому они больше не должны возвращаться при вызовах &lt;code&gt;read&lt;/code&gt; . &lt;a href=&quot;../io/trait.bufread#tymethod.consume&quot;&gt;Читать далее&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="027be37242a148e84d0572e0cc986124d9c751bc" translate="yes" xml:space="preserve">
          <source>Tells this buffer that &lt;code&gt;amt&lt;/code&gt; bytes have been consumed from the buffer, so they should no longer be returned in calls to &lt;code&gt;read&lt;/code&gt;. &lt;a href=&quot;io/trait.bufread#tymethod.consume&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">Сообщает этому буферу, что из буфера было израсходовано &lt;code&gt;amt&lt;/code&gt; байтов, поэтому они больше не должны возвращаться при вызовах &lt;code&gt;read&lt;/code&gt; . &lt;a href=&quot;io/trait.bufread#tymethod.consume&quot;&gt;Читать далее&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="ea3b911565206879ae5d6cb4146bc834dfb6a7f3" translate="yes" xml:space="preserve">
          <source>Tells this buffer that &lt;code&gt;amt&lt;/code&gt; bytes have been consumed from the buffer, so they should no longer be returned in calls to &lt;code&gt;read&lt;/code&gt;. &lt;a href=&quot;trait.bufread#tymethod.consume&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">Сообщает этому буферу, что из буфера было израсходовано &lt;code&gt;amt&lt;/code&gt; байтов, поэтому они больше не должны возвращаться при вызовах &lt;code&gt;read&lt;/code&gt; . &lt;a href=&quot;trait.bufread#tymethod.consume&quot;&gt;Читать далее&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="68f4c5ea285ef679416734518ea1144f7f9f2cf1" translate="yes" xml:space="preserve">
          <source>Temporal quantification.</source>
          <target state="translated">Временное количественное определение.</target>
        </trans-unit>
        <trans-unit id="be80baca9006a4100bd6b71127149a07eb502503" translate="yes" xml:space="preserve">
          <source>Temporaries</source>
          <target state="translated">Temporaries</target>
        </trans-unit>
        <trans-unit id="b1380bff4b98c3f3b1a409ce860a8bd5d4ce8c7b" translate="yes" xml:space="preserve">
          <source>Temporaries are also created to hold the result of operands to an expression while the other operands are evaluated. The temporaries are associated to the scope of the expression with that operand. Since the temporaries are moved from once the expression is evaluated, dropping them has no effect unless one of the operands to an expression breaks out of the expression, returns, or panics.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6121a6beed14a5f45c5406020e211d50eaf732ff" translate="yes" xml:space="preserve">
          <source>Temporaries are not always dropped at the end of the enclosing statement. In simple cases where the &lt;code&gt;&amp;amp;&lt;/code&gt; expression is immediately stored into a variable, the compiler will automatically extend the lifetime of the temporary until the end of the enclosing block. Therefore, an alternative way to fix the original program is to write &lt;code&gt;let tmp = &amp;amp;foo()&lt;/code&gt; and not &lt;code&gt;let tmp = foo()&lt;/code&gt;:</source>
          <target state="translated">Временные файлы не всегда опускаются в конце заключительной инструкции. В простых случаях, когда выражение &lt;code&gt;&amp;amp;&lt;/code&gt; немедленно сохраняется в переменной, компилятор автоматически продлевает время жизни временного до конца включающего блока. Следовательно, альтернативный способ исправить исходную программу - написать &lt;code&gt;let tmp = &amp;amp;foo()&lt;/code&gt; а не &lt;code&gt;let tmp = foo()&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="ff4686225d8fb1e953162a00f63d6b94d5a386fd" translate="yes" xml:space="preserve">
          <source>Temporaries that are created in the final expression of a function body are dropped &lt;em&gt;after&lt;/em&gt; any named variables bound in the function body, as there is no smaller enclosing temporary scope.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aae8496ab0d5e20c300ea07a6c87645fbefee013" translate="yes" xml:space="preserve">
          <source>Temporary lifetime extension</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a237179150c9f45b00df9097591b1d7f10ef2038" translate="yes" xml:space="preserve">
          <source>Temporary lifetimes</source>
          <target state="translated">Временная жизнь</target>
        </trans-unit>
        <trans-unit id="ace2219c94d381961a79fb4617905c5cfbbacbf7" translate="yes" xml:space="preserve">
          <source>Temporary scopes</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dfc9ea018278b216d5b6d6db9b73a7c2a6e7a8c8" translate="yes" xml:space="preserve">
          <source>Terminates the current process with the specified exit code.</source>
          <target state="translated">Прекращает текущий процесс с указанным кодом выхода.</target>
        </trans-unit>
        <trans-unit id="4abcdd83ee3f3bce743cbed96b2ad9f965bea36e" translate="yes" xml:space="preserve">
          <source>Terminates the process in an abnormal fashion.</source>
          <target state="translated">Прекращает процесс аномальным образом.</target>
        </trans-unit>
        <trans-unit id="2ee85218866a19e0d9f6c52c176e4eaf9d0877b2" translate="yes" xml:space="preserve">
          <source>Termination</source>
          <target state="translated">Termination</target>
        </trans-unit>
        <trans-unit id="4d00170cd71cecfb46cdbb7ebdf05a4a02fee721" translate="yes" xml:space="preserve">
          <source>Termination::report</source>
          <target state="translated">Termination::report</target>
        </trans-unit>
        <trans-unit id="00f441aa04210533cf8168c3d0baeda960edac55" translate="yes" xml:space="preserve">
          <source>Terminator for various items and statements, &lt;a href=&quot;types/array&quot;&gt;Array types&lt;/a&gt;</source>
          <target state="translated">Терминатор для различных элементов и операторов, &lt;a href=&quot;types/array&quot;&gt;типы массивов&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="94aaabf5a007f6525e86dbe783c284fccc74a25c" translate="yes" xml:space="preserve">
          <source>Test Organization</source>
          <target state="translated">Тестовая организация</target>
        </trans-unit>
        <trans-unit id="0820b32b206b7352858e8903a838ed14319acdfd" translate="yes" xml:space="preserve">
          <source>Testing</source>
          <target state="translated">Testing</target>
        </trans-unit>
        <trans-unit id="da7894cbcc38e877e01ccb02e3c5e98f656c5624" translate="yes" xml:space="preserve">
          <source>Testing Equality with the &lt;code id=&quot;testing-equality-with-the-assert_eq-and-assert_ne-macros&quot;&gt;assert_eq!&lt;/code&gt; and &lt;code&gt;assert_ne!&lt;/code&gt; Macros</source>
          <target state="translated">Проверка равенства с помощью &lt;code id=&quot;testing-equality-with-the-assert_eq-and-assert_ne-macros&quot;&gt;assert_eq!&lt;/code&gt; и &lt;code&gt;assert_ne!&lt;/code&gt; Макросы</target>
        </trans-unit>
        <trans-unit id="117ea1d14f7b6fbe5fa90955d52644403f513522" translate="yes" xml:space="preserve">
          <source>Testing Private Functions</source>
          <target state="translated">Тестирование частных функций</target>
        </trans-unit>
        <trans-unit id="932c5d1d0f6f5178e61a3f6e97a669a7ad5fc25b" translate="yes" xml:space="preserve">
          <source>Testing attributes</source>
          <target state="translated">Тестирующие атрибуты</target>
        </trans-unit>
        <trans-unit id="6966e45073f574893b66ceb3ad6d45bb2ced06e0" translate="yes" xml:space="preserve">
          <source>Testing is a complex skill: although we can&amp;rsquo;t cover every detail about how to write good tests in one chapter, we&amp;rsquo;ll discuss the mechanics of Rust&amp;rsquo;s testing facilities. We&amp;rsquo;ll talk about the annotations and macros available to you when writing your tests, the default behavior and options provided for running your tests, and how to organize tests into unit tests and integration tests.</source>
          <target state="translated">Тестирование - это сложный навык: хотя мы не можем осветить все детали того, как писать хорошие тесты в одной главе, мы обсудим механику средств тестирования Rust. Мы поговорим об аннотациях и макросах, доступных вам при написании тестов, о поведении по умолчанию и параметрах, предоставляемых для запуска ваших тестов, и о том, как организовать тесты в модульные тесты и интеграционные тесты.</target>
        </trans-unit>
        <trans-unit id="f7c988b9b3e507c053615421186791199dc1b08e" translate="yes" xml:space="preserve">
          <source>Testing the First Part</source>
          <target state="translated">Тестирование первой части</target>
        </trans-unit>
        <trans-unit id="833858d67cb9edd86a232319e147507d73e766ab" translate="yes" xml:space="preserve">
          <source>Tests are Rust functions that verify that the non-test code is functioning in the expected manner. The bodies of test functions typically perform these three actions:</source>
          <target state="translated">Тесты-это функции Rust,которые проверяют,что нетестовый код функционирует ожидаемым образом.Корпуса тестовых функций,как правило,выполняют эти три действия:</target>
        </trans-unit>
        <trans-unit id="9557b92aa71fea3ff4e10ad5c651a01d327198f2" translate="yes" xml:space="preserve">
          <source>Tests if &lt;code&gt;person&lt;/code&gt; has the &lt;code&gt;car&lt;/code&gt; field filled with something.</source>
          <target state="translated">Тесты , если &lt;code&gt;person&lt;/code&gt; имеет &lt;code&gt;car&lt;/code&gt; поле , наполненное чем - то.</target>
        </trans-unit>
        <trans-unit id="21b62ab2004ca1232d413d8d665d134b12791482" translate="yes" xml:space="preserve">
          <source>Tests if any element of the iterator matches a predicate.</source>
          <target state="translated">Проверяет,совпадает ли какой-либо элемент итератора с предикатом.</target>
        </trans-unit>
        <trans-unit id="10d2dce236b59fb61d9321a2651527964d17f562" translate="yes" xml:space="preserve">
          <source>Tests if any element of the iterator matches a predicate. &lt;a href=&quot;../../../iter/trait.iterator#method.any&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">Проверяет, соответствует ли какой-либо элемент итератора предикату. &lt;a href=&quot;../../../iter/trait.iterator#method.any&quot;&gt;Читать далее&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="209ac04cb187d92f123ce6700c9444025e5580b3" translate="yes" xml:space="preserve">
          <source>Tests if any element of the iterator matches a predicate. &lt;a href=&quot;../../iter/trait.iterator#method.any&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">Проверяет, соответствует ли какой-либо элемент итератора предикату. &lt;a href=&quot;../../iter/trait.iterator#method.any&quot;&gt;Читать далее&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="80ec10f423a5beaec1ab62efd9e4031e5aaa4a11" translate="yes" xml:space="preserve">
          <source>Tests if any element of the iterator matches a predicate. &lt;a href=&quot;../iter/trait.iterator#method.any&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">Проверяет, соответствует ли какой-либо элемент итератора предикату. &lt;a href=&quot;../iter/trait.iterator#method.any&quot;&gt;Читать далее&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="760ae5105c89912ab7a036138a76c59ddfecc44b" translate="yes" xml:space="preserve">
          <source>Tests if any element of the iterator matches a predicate. &lt;a href=&quot;iter/trait.iterator#method.any&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">Проверяет, соответствует ли какой-либо элемент итератора предикату. &lt;a href=&quot;iter/trait.iterator#method.any&quot;&gt;Читать далее&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="df440409ef320551129c77bcadb79c6c4ba84e37" translate="yes" xml:space="preserve">
          <source>Tests if any element of the iterator matches a predicate. &lt;a href=&quot;trait.iterator#method.any&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">Проверяет, соответствует ли какой-либо элемент итератора предикату. &lt;a href=&quot;trait.iterator#method.any&quot;&gt;Читать далее&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="42f540ef5575b87eda1bc58cc8c893cf2e3e2964" translate="yes" xml:space="preserve">
          <source>Tests if every element of the iterator matches a predicate.</source>
          <target state="translated">Проверяет,соответствует ли каждый элемент итератора предикату.</target>
        </trans-unit>
        <trans-unit id="52e69927724e46dd631e47a69a4f2cdc74a668ca" translate="yes" xml:space="preserve">
          <source>Tests if every element of the iterator matches a predicate. &lt;a href=&quot;../../../iter/trait.iterator#method.all&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">Проверяет, соответствует ли каждый элемент итератора предикату. &lt;a href=&quot;../../../iter/trait.iterator#method.all&quot;&gt;Читать далее&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="c572c6f114e3b7b0e63531ab8e78116f0d5ac5de" translate="yes" xml:space="preserve">
          <source>Tests if every element of the iterator matches a predicate. &lt;a href=&quot;../../iter/trait.iterator#method.all&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">Проверяет, соответствует ли каждый элемент итератора предикату. &lt;a href=&quot;../../iter/trait.iterator#method.all&quot;&gt;Читать далее&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="a987e1ebbc5dd44d57ed09974bfdcc0f02c47b55" translate="yes" xml:space="preserve">
          <source>Tests if every element of the iterator matches a predicate. &lt;a href=&quot;../iter/trait.iterator#method.all&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">Проверяет, соответствует ли каждый элемент итератора предикату. &lt;a href=&quot;../iter/trait.iterator#method.all&quot;&gt;Читать далее&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="74b456b0054dd24ca1a515d72ae7f4e5367d4633" translate="yes" xml:space="preserve">
          <source>Tests if every element of the iterator matches a predicate. &lt;a href=&quot;iter/trait.iterator#method.all&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">Проверяет, соответствует ли каждый элемент итератора предикату. &lt;a href=&quot;iter/trait.iterator#method.all&quot;&gt;Читать далее&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="92be4e62f1c703e57b0a705c84b8aca1511558d2" translate="yes" xml:space="preserve">
          <source>Tests if every element of the iterator matches a predicate. &lt;a href=&quot;trait.iterator#method.all&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">Проверяет, соответствует ли каждый элемент итератора предикату. &lt;a href=&quot;trait.iterator#method.all&quot;&gt;Читать далее&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="6ebc400fe5bb7d000d0d73f12e63cdedd3140090" translate="yes" xml:space="preserve">
          <source>Tests if the person's &lt;code&gt;age&lt;/code&gt; field is between 13 and 19, and binds its value to the &lt;code&gt;person_age&lt;/code&gt; variable.</source>
          <target state="translated">Проверяет, находится ли поле &lt;code&gt;age&lt;/code&gt; человека от 13 до 19, и связывает его значение с переменной &lt;code&gt;person_age&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="13e062493861ff1e884762affb6f292d7aaa95d6" translate="yes" xml:space="preserve">
          <source>Tests that return &lt;code&gt;()&lt;/code&gt; pass as long as they terminate and do not panic. Tests that return a &lt;code&gt;Result&amp;lt;(), E&amp;gt;&lt;/code&gt; pass as long as they return &lt;code&gt;Ok(())&lt;/code&gt;. Tests that do not terminate neither pass nor fail.</source>
          <target state="translated">Тесты, которые возвращаются &lt;code&gt;()&lt;/code&gt; , проходят, пока они завершаются и не вызывают паники. Тесты, возвращающие &lt;code&gt;Result&amp;lt;(), E&amp;gt;&lt;/code&gt; проходят, если они возвращают &lt;code&gt;Ok(())&lt;/code&gt; . Непрерывные тесты не пройдены и не пройдены.</target>
        </trans-unit>
        <trans-unit id="240e8d8b35fd6dbae3889295d03396f4179097df" translate="yes" xml:space="preserve">
          <source>Tests that use &lt;code&gt;should_panic&lt;/code&gt; can be imprecise because they only indicate that the code has caused some panic. A &lt;code&gt;should_panic&lt;/code&gt; test would pass even if the test panics for a different reason from the one we were expecting to happen. To make &lt;code&gt;should_panic&lt;/code&gt; tests more precise, we can add an optional &lt;code&gt;expected&lt;/code&gt; parameter to the &lt;code&gt;should_panic&lt;/code&gt; attribute. The test harness will make sure that the failure message contains the provided text. For example, consider the modified code for &lt;code&gt;Guess&lt;/code&gt; in Listing 11-9 where the &lt;code&gt;new&lt;/code&gt; function panics with different messages depending on whether the value is too small or too large.</source>
          <target state="translated">Тесты, в которых используется &lt;code&gt;should_panic&lt;/code&gt; , могут быть неточными, потому что они указывают только на то, что код вызвал некоторую панику. Тест &lt;code&gt;should_panic&lt;/code&gt; пройдет, даже если тест выйдет из строя по причине, отличной от той, которую мы ожидали. Чтобы сделать тесты &lt;code&gt;should_panic&lt;/code&gt; более точными, мы можем добавить необязательный &lt;code&gt;expected&lt;/code&gt; параметр к &lt;code&gt;should_panic&lt;/code&gt; . Тестовый комплект должен убедиться, что сообщение об ошибке содержит указанный текст. Например, рассмотрим измененный код для &lt;code&gt;Guess&lt;/code&gt; в листинге 11-9, где &lt;code&gt;new&lt;/code&gt; функция запускает панику с разными сообщениями в зависимости от того, является ли значение слишком маленьким или слишком большим.</target>
        </trans-unit>
        <trans-unit id="6bb384831446531aa67968092446024f5dcdae5e" translate="yes" xml:space="preserve">
          <source>Tests whether this file type represents a directory. The result is mutually exclusive to the results of &lt;a href=&quot;struct.filetype#method.is_file&quot;&gt;&lt;code&gt;is_file&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;struct.filetype#method.is_symlink&quot;&gt;&lt;code&gt;is_symlink&lt;/code&gt;&lt;/a&gt;; only zero or one of these tests may pass.</source>
          <target state="translated">Проверяет, представляет ли этот тип файла каталог. Результат является взаимоисключающим с результатами &lt;a href=&quot;struct.filetype#method.is_file&quot;&gt; &lt;code&gt;is_file&lt;/code&gt; &lt;/a&gt; и &lt;a href=&quot;struct.filetype#method.is_symlink&quot;&gt; &lt;code&gt;is_symlink&lt;/code&gt; &lt;/a&gt; ; может пройти только ноль или один из этих тестов.</target>
        </trans-unit>
        <trans-unit id="47c7f108fa56b78dae837cfbc2c1b6e6d82a8892" translate="yes" xml:space="preserve">
          <source>Tests whether this file type represents a regular file. The result is mutually exclusive to the results of &lt;a href=&quot;struct.filetype#method.is_dir&quot;&gt;&lt;code&gt;is_dir&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;struct.filetype#method.is_symlink&quot;&gt;&lt;code&gt;is_symlink&lt;/code&gt;&lt;/a&gt;; only zero or one of these tests may pass.</source>
          <target state="translated">Проверяет, представляет ли этот тип файла обычный файл. Результат является взаимоисключающим с результатами &lt;a href=&quot;struct.filetype#method.is_dir&quot;&gt; &lt;code&gt;is_dir&lt;/code&gt; &lt;/a&gt; и &lt;a href=&quot;struct.filetype#method.is_symlink&quot;&gt; &lt;code&gt;is_symlink&lt;/code&gt; &lt;/a&gt; ; может пройти только ноль или один из этих тестов.</target>
        </trans-unit>
        <trans-unit id="8e2618283b789dcbc952fac3457682ad9646a29b" translate="yes" xml:space="preserve">
          <source>Tests whether this file type represents a symbolic link. The result is mutually exclusive to the results of &lt;a href=&quot;struct.filetype#method.is_dir&quot;&gt;&lt;code&gt;is_dir&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;struct.filetype#method.is_file&quot;&gt;&lt;code&gt;is_file&lt;/code&gt;&lt;/a&gt;; only zero or one of these tests may pass.</source>
          <target state="translated">Проверяет, представляет ли этот тип файла символическую ссылку. Результат является взаимоисключающим с результатами &lt;a href=&quot;struct.filetype#method.is_dir&quot;&gt; &lt;code&gt;is_dir&lt;/code&gt; &lt;/a&gt; и &lt;a href=&quot;struct.filetype#method.is_file&quot;&gt; &lt;code&gt;is_file&lt;/code&gt; &lt;/a&gt; ; может пройти только ноль или один из этих тестов.</target>
        </trans-unit>
        <trans-unit id="24e8ed91cce37f2bfddb7d0a6e1b5b5dd3e13c8b" translate="yes" xml:space="preserve">
          <source>Text directionality</source>
          <target state="translated">Направленность текста</target>
        </trans-unit>
        <trans-unit id="ece7c96ceb6b3c2888b8a50e4cc0084fdd3cc5ad" translate="yes" xml:space="preserve">
          <source>Textual Scope</source>
          <target state="translated">Текстовый охват</target>
        </trans-unit>
        <trans-unit id="f351ed281e01f153c5130339693bdde4a4318e5b" translate="yes" xml:space="preserve">
          <source>Textual representation</source>
          <target state="translated">текстовое представление</target>
        </trans-unit>
        <trans-unit id="50a53707975aa4e011ef0d8fc19d6a0815b5a0af" translate="yes" xml:space="preserve">
          <source>Textual scope is based largely on the order that things appear in source files, and works similarly to the scope of local variables declared with &lt;code&gt;let&lt;/code&gt; except it also applies at the module level. When &lt;code&gt;macro_rules!&lt;/code&gt; is used to define a macro, the macro enters the scope after the definition (note that it can still be used recursively, since names are looked up from the invocation site), up until its surrounding scope, typically a module, is closed. This can enter child modules and even span across multiple files:</source>
          <target state="translated">Текстовая область видимости в значительной степени основана на порядке, в котором элементы появляются в исходных файлах, и работает аналогично области локальных переменных, объявленных с помощью &lt;code&gt;let&lt;/code&gt; , за исключением того, что она также применяется на уровне модуля. Когда &lt;code&gt;macro_rules!&lt;/code&gt; используется для определения макроса, макрос входит в область действия после определения (обратите внимание, что он все еще может использоваться рекурсивно, поскольку имена ищутся с сайта вызова) до тех пор, пока его окружающая область, обычно это модуль, не будет закрыта. Это может входить в дочерние модули и даже охватывать несколько файлов:</target>
        </trans-unit>
        <trans-unit id="3250cb346f89521461c9526f4b4c9e22ab7dec1d" translate="yes" xml:space="preserve">
          <source>Textual types</source>
          <target state="translated">Текстовые типы</target>
        </trans-unit>
        <trans-unit id="43b22d6c26a5be334da039abbdd3a863691ba7f8" translate="yes" xml:space="preserve">
          <source>Thankfully, you won't need to worry about upholding this property when deriving both &lt;a href=&quot;../cmp/trait.eq&quot;&gt;&lt;code&gt;Eq&lt;/code&gt;&lt;/a&gt; and &lt;code&gt;Hash&lt;/code&gt; with &lt;code&gt;#[derive(PartialEq, Eq, Hash)]&lt;/code&gt;.</source>
          <target state="translated">К счастью, вам не нужно беспокоиться о сохранении этого свойства при выводе &lt;a href=&quot;../cmp/trait.eq&quot;&gt; &lt;code&gt;Eq&lt;/code&gt; &lt;/a&gt; и &lt;code&gt;Hash&lt;/code&gt; с помощью &lt;code&gt;#[derive(PartialEq, Eq, Hash)]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d87603b9cd3744161580179aa52163b0ef139449" translate="yes" xml:space="preserve">
          <source>Thanks to static lifetime elision, you usually don't have to explicitly use 'static:</source>
          <target state="translated">Благодаря статической элизии времени жизни,вам обычно не нужно явно использовать 'статическое':</target>
        </trans-unit>
        <trans-unit id="ccd80fa4141d21f8d736b44824bc5d805727e80f" translate="yes" xml:space="preserve">
          <source>Thanks to static lifetime elision, you usually don't have to explicitly use &lt;code&gt;'static&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9bdae0de8a5a5798d4caf783e96f237ed5528f2b" translate="yes" xml:space="preserve">
          <source>Thanks to this process, you can always check out the next build of Rust and verify for yourself that it&amp;rsquo;s easy to upgrade to: if a beta release doesn&amp;rsquo;t work as expected, you can report it to the team and get it fixed before the next stable release happens! Breakage in a beta release is relatively rare, but &lt;code&gt;rustc&lt;/code&gt; is still a piece of software, and bugs do exist.</source>
          <target state="translated">Благодаря этому процессу вы всегда можете проверить следующую сборку Rust и убедиться, что ее легко обновить: если бета-версия не работает должным образом, вы можете сообщить об этом команде и исправить ее до следующий стабильный релиз! Сбои в бета-версии относительно редки, но &lt;code&gt;rustc&lt;/code&gt; по-прежнему является частью программного обеспечения, и ошибки действительно существуют.</target>
        </trans-unit>
        <trans-unit id="93b38f3306b86b6513f0666ee48835c2b21219b2" translate="yes" xml:space="preserve">
          <source>That first part is done by us: when we call &lt;code&gt;String::from&lt;/code&gt;, its implementation requests the memory it needs. This is pretty much universal in programming languages.</source>
          <target state="translated">Эта первая часть сделана нами: когда мы вызываем &lt;code&gt;String::from&lt;/code&gt; , его реализация запрашивает необходимую память. Это довольно универсально для языков программирования.</target>
        </trans-unit>
        <trans-unit id="1348e5b21c821f227473000afcbce413f66d2f49" translate="yes" xml:space="preserve">
          <source>That is, for each element &lt;code&gt;a&lt;/code&gt; and its following element &lt;code&gt;b&lt;/code&gt;, &lt;code&gt;a &amp;lt;= b&lt;/code&gt; must hold. If the iterator yields exactly zero or one element, &lt;code&gt;true&lt;/code&gt; is returned.</source>
          <target state="translated">То есть, для каждого элемента &lt;code&gt;a&lt;/code&gt; и его следующего элемента &lt;code&gt;b&lt;/code&gt; , &lt;code&gt;a &amp;lt;= b&lt;/code&gt; должно выполняться. Если итератор возвращает ровно ноль или один элемент, возвращается &lt;code&gt;true&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="bf20cf0a5a4308c50df24aa720ae0a415bab9777" translate="yes" xml:space="preserve">
          <source>That is, for each element &lt;code&gt;a&lt;/code&gt; and its following element &lt;code&gt;b&lt;/code&gt;, &lt;code&gt;a &amp;lt;= b&lt;/code&gt; must hold. If the slice yields exactly zero or one element, &lt;code&gt;true&lt;/code&gt; is returned.</source>
          <target state="translated">То есть, для каждого элемента &lt;code&gt;a&lt;/code&gt; и его следующего элемента &lt;code&gt;b&lt;/code&gt; , &lt;code&gt;a &amp;lt;= b&lt;/code&gt; должно выполняться. Если срез дает ровно ноль или один элемент, возвращается &lt;code&gt;true&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6141d9d942518cd742366c4e9a373eaeca5ba99a" translate="yes" xml:space="preserve">
          <source>That number of bytes is always between 1 and 4, inclusive.</source>
          <target state="translated">Это количество байтов всегда находится между 1 и 4,включительно.</target>
        </trans-unit>
        <trans-unit id="5636ef2e6fa0c7ceabc2956a6a83de732290f283" translate="yes" xml:space="preserve">
          <source>That said, leaking resources such as memory or I/O objects is usually undesirable, so &lt;code&gt;forget&lt;/code&gt; is only recommended for specialized use cases like those shown below.</source>
          <target state="translated">Тем не менее, утечка ресурсов, таких как память или объекты ввода-вывода, обычно нежелательна, поэтому &lt;code&gt;forget&lt;/code&gt; рекомендуется только в особых случаях использования, подобных показанным ниже.</target>
        </trans-unit>
        <trans-unit id="bb0090f499faa8dbbaeb7f14d05f8e092483990d" translate="yes" xml:space="preserve">
          <source>That said, leaking resources such as memory or I/O objects is usually undesirable. The need comes up in some specialized use cases for FFI or unsafe code, but even then, &lt;a href=&quot;struct.manuallydrop&quot;&gt;&lt;code&gt;ManuallyDrop&lt;/code&gt;&lt;/a&gt; is typically preferred.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="44e204c683273a7064bf611cb21bf25b6a58ab5e" translate="yes" xml:space="preserve">
          <source>That said, the implementation should provide a correct estimation, because otherwise it would be a violation of the trait's protocol.</source>
          <target state="translated">При этом реализация должна давать правильную оценку,так как в противном случае это было бы нарушением протокола признака.</target>
        </trans-unit>
        <trans-unit id="7bf3790580feeb3b9968c1d5ee569f07fe6dc889" translate="yes" xml:space="preserve">
          <source>That said, there is no wrong way to read this book. Read it however you feel helps you best.</source>
          <target state="translated">Тем не менее,нет никакого неправильного способа прочитать эту книгу.Читайте ее,как бы вы ни чувствовали,что она вам поможет.</target>
        </trans-unit>
        <trans-unit id="947746e61ef4047bc2347841bf565d094e7bdec0" translate="yes" xml:space="preserve">
          <source>That solves our problem! With only &lt;code&gt;s2&lt;/code&gt; valid, when it goes out of scope, it alone will free the memory, and we&amp;rsquo;re done.</source>
          <target state="translated">Это решает нашу проблему! Если действителен только &lt;code&gt;s2&lt;/code&gt; , когда он выходит за рамки, он сам освобождает память, и мы закончили.</target>
        </trans-unit>
        <trans-unit id="9ce801650086879dbc3fc82fa6315949a2552c96" translate="yes" xml:space="preserve">
          <source>That was a bit of a whirlwind tour of unwind safety, but for more information about unwind safety and how it applies to Rust, see an &lt;a href=&quot;https://github.com/rust-lang/rfcs/blob/master/text/1236-stabilize-catch-panic.md&quot;&gt;associated RFC&lt;/a&gt;.</source>
          <target state="translated">Это было что-то вроде ураганного тура по безопасности размотки, но для получения дополнительной информации о безопасности размотки и ее применимости к Rust см. &lt;a href=&quot;https://github.com/rust-lang/rfcs/blob/master/text/1236-stabilize-catch-panic.md&quot;&gt;Соответствующий RFC&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="92b56514bc3604cf70d965940d81ed28035240b2" translate="yes" xml:space="preserve">
          <source>That&amp;rsquo;s 18 bytes and is how computers ultimately store this data. If we look at them as Unicode scalar values, which are what Rust&amp;rsquo;s &lt;code&gt;char&lt;/code&gt; type is, those bytes look like this:</source>
          <target state="translated">Это 18 байт, и именно так компьютеры в конечном итоге хранят эти данные. Если мы посмотрим на них как на скалярные значения Unicode, которые представляют собой тип &lt;code&gt;char&lt;/code&gt; в Rust , эти байты будут выглядеть так:</target>
        </trans-unit>
        <trans-unit id="9fac4c3e9f71b06878dbbb47f3ce2814227f227f" translate="yes" xml:space="preserve">
          <source>That&amp;rsquo;s a lot of &lt;code&gt;match&lt;/code&gt;! The &lt;code&gt;match&lt;/code&gt; expression is very useful but also very much a primitive. In Chapter 13, you&amp;rsquo;ll learn about closures; the &lt;code&gt;Result&amp;lt;T, E&amp;gt;&lt;/code&gt; type has many methods that accept a closure and are implemented using &lt;code&gt;match&lt;/code&gt; expressions. Using those methods will make your code more concise. A more seasoned Rustacean might write this code instead of Listing 9-5:</source>
          <target state="translated">Это много &lt;code&gt;match&lt;/code&gt; ! &lt;code&gt;match&lt;/code&gt; выражение очень полезное , но и очень примитивный. В главе 13 вы узнаете о замыканиях; &lt;code&gt;Result&amp;lt;T, E&amp;gt;&lt;/code&gt; типа имеет много методов , которые принимают укупорочные и реализуются с помощью &lt;code&gt;match&lt;/code&gt; выражения. Использование этих методов сделает ваш код более лаконичным. Более опытный Rustacean мог бы написать этот код вместо Листинга 9-5:</target>
        </trans-unit>
        <trans-unit id="ef238338d4e12acdba68729fda27f2648f9a373c" translate="yes" xml:space="preserve">
          <source>That&amp;rsquo;s a lot of output! The exact output you see might be different depending on your operating system and Rust version. In order to get backtraces with this information, debug symbols must be enabled. Debug symbols are enabled by default when using &lt;code&gt;cargo build&lt;/code&gt; or &lt;code&gt;cargo run&lt;/code&gt; without the &lt;code&gt;--release&lt;/code&gt; flag, as we have here.</source>
          <target state="translated">Это много! Точный вывод, который вы видите, может отличаться в зависимости от вашей операционной системы и версии Rust. Чтобы получить обратную трассировку с этой информацией, должны быть включены символы отладки. Символы отладки включены по умолчанию при использовании &lt;code&gt;cargo build&lt;/code&gt; или &lt;code&gt;cargo run&lt;/code&gt; без флага &lt;code&gt;--release&lt;/code&gt; , как здесь.</target>
        </trans-unit>
        <trans-unit id="1b9244a451d65d27f90f013b616e273e2c23a8a2" translate="yes" xml:space="preserve">
          <source>That's it! Let's dig into iterators.</source>
          <target state="translated">Вот так! Давайте покопаемся в итераторах.</target>
        </trans-unit>
        <trans-unit id="061168032f743f39ddf71cf9c7a9d9f5d6f181f3" translate="yes" xml:space="preserve">
          <source>The &quot;default&quot; usage of this type as a queue is to use &lt;a href=&quot;#method.push_back&quot;&gt;&lt;code&gt;push_back&lt;/code&gt;&lt;/a&gt; to add to the queue, and &lt;a href=&quot;#method.pop_front&quot;&gt;&lt;code&gt;pop_front&lt;/code&gt;&lt;/a&gt; to remove from the queue. &lt;a href=&quot;#method.extend&quot;&gt;&lt;code&gt;extend&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#method.append&quot;&gt;&lt;code&gt;append&lt;/code&gt;&lt;/a&gt; push onto the back in this manner, and iterating over &lt;code&gt;VecDeque&lt;/code&gt; goes front to back.</source>
          <target state="translated">&amp;laquo;По умолчанию&amp;raquo; использование этого типа в качестве очереди заключается в использовании &lt;a href=&quot;#method.push_back&quot;&gt; &lt;code&gt;push_back&lt;/code&gt; &lt;/a&gt; для добавления в очередь и &lt;a href=&quot;#method.pop_front&quot;&gt; &lt;code&gt;pop_front&lt;/code&gt; &lt;/a&gt; для удаления из очереди. &lt;a href=&quot;#method.extend&quot;&gt; &lt;code&gt;extend&lt;/code&gt; &lt;/a&gt; и &lt;a href=&quot;#method.append&quot;&gt; &lt;code&gt;append&lt;/code&gt; &lt;/a&gt; push на спину таким образом, и итерация по &lt;code&gt;VecDeque&lt;/code&gt; идет от начала до конца .</target>
        </trans-unit>
        <trans-unit id="e1996b7a38e8030e5ba09e25339c72996ff81148" translate="yes" xml:space="preserve">
          <source>The &quot;default&quot; usage of this type as a queue is to use &lt;a href=&quot;../struct.vecdeque#method.push_back&quot;&gt;&lt;code&gt;push_back&lt;/code&gt;&lt;/a&gt; to add to the queue, and &lt;a href=&quot;../struct.vecdeque#method.pop_front&quot;&gt;&lt;code&gt;pop_front&lt;/code&gt;&lt;/a&gt; to remove from the queue. &lt;a href=&quot;../struct.vecdeque#method.extend&quot;&gt;&lt;code&gt;extend&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../struct.vecdeque#method.append&quot;&gt;&lt;code&gt;append&lt;/code&gt;&lt;/a&gt; push onto the back in this manner, and iterating over &lt;code&gt;VecDeque&lt;/code&gt; goes front to back.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6e8660a906a07f3cb76ce3714efc3b35a643f54a" translate="yes" xml:space="preserve">
          <source>The &quot;default&quot; usage of this type as a queue is to use &lt;a href=&quot;struct.vecdeque#method.push_back&quot;&gt;&lt;code&gt;push_back&lt;/code&gt;&lt;/a&gt; to add to the queue, and &lt;a href=&quot;struct.vecdeque#method.pop_front&quot;&gt;&lt;code&gt;pop_front&lt;/code&gt;&lt;/a&gt; to remove from the queue. &lt;a href=&quot;struct.vecdeque#method.extend&quot;&gt;&lt;code&gt;extend&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;struct.vecdeque#method.append&quot;&gt;&lt;code&gt;append&lt;/code&gt;&lt;/a&gt; push onto the back in this manner, and iterating over &lt;code&gt;VecDeque&lt;/code&gt; goes front to back.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="01cb9e838bce9598fdfd4c3684f101808c1294f8" translate="yes" xml:space="preserve">
          <source>The &amp;ldquo;Advanced Lifetimes&amp;rdquo; section in Chapter 19 was removed because compiler improvements have made the constructs in that section even rarer.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="36f389fc23a4edc2c2a963efce47f9899bcc8519" translate="yes" xml:space="preserve">
          <source>The &amp;ldquo;Advanced Lifetimes&amp;rdquo; section of Chapter 19 was removed because compiler improvements have made the constructs in that section even rarer.</source>
          <target state="translated">Раздел &amp;laquo;Расширенное время жизни&amp;raquo; в главе 19 был удален, потому что улучшения компилятора сделали конструкции в этом разделе еще более редкими.</target>
        </trans-unit>
        <trans-unit id="f99557dc0a8fdf7a63f0792d647f548b4ff6f7ab" translate="yes" xml:space="preserve">
          <source>The 128-bit signed integer type.</source>
          <target state="translated">128-битный знаковый целочисленный тип.</target>
        </trans-unit>
        <trans-unit id="2ecb830f3b64176d279185c7c171382698dc346b" translate="yes" xml:space="preserve">
          <source>The 128-bit unsigned integer type.</source>
          <target state="translated">128-битный беззнаковый целочисленный тип.</target>
        </trans-unit>
        <trans-unit id="024e734140c83218cfd913643692a04c708db5ec" translate="yes" xml:space="preserve">
          <source>The 16-bit signed integer type.</source>
          <target state="translated">16-битный знаковый целочисленный тип.</target>
        </trans-unit>
        <trans-unit id="c45d15aa8a84f450baba97f342935672e6fa7c43" translate="yes" xml:space="preserve">
          <source>The 16-bit unsigned integer type.</source>
          <target state="translated">16-битный беззнаковый целочисленный тип.</target>
        </trans-unit>
        <trans-unit id="fca5433f25a52ee7287767b1930704d918391065" translate="yes" xml:space="preserve">
          <source>The 2015 edition does not allow use declarations to reference the &lt;a href=&quot;extern-crates#extern-prelude&quot;&gt;extern prelude&lt;/a&gt;. Thus &lt;a href=&quot;extern-crates&quot;&gt;&lt;code&gt;extern crate&lt;/code&gt;&lt;/a&gt; declarations are still required in 2015 to reference an external crate in a use declaration. Beginning with the 2018 edition, use declarations can specify an external crate dependency the same way &lt;code&gt;extern crate&lt;/code&gt; can.</source>
          <target state="translated">Издание 2015 года не позволяет использовать объявления использования для ссылки на &lt;a href=&quot;extern-crates#extern-prelude&quot;&gt;прелюдию extern&lt;/a&gt; . Таким образом, объявления &lt;a href=&quot;extern-crates&quot;&gt; &lt;code&gt;extern crate&lt;/code&gt; &lt;/a&gt; по-прежнему необходимы в 2015 году для ссылки на внешний ящик в объявлении использования. Начиная с 2018 года издания, декларации использование может указать внешний ящик зависимостей таким же образом &lt;code&gt;extern crate&lt;/code&gt; может.</target>
        </trans-unit>
        <trans-unit id="b6d857578ac6c78bfa58339fa5a83d29b7a47348" translate="yes" xml:space="preserve">
          <source>The 2018 Edition of the Rust language includes a number of improvements that make Rust more ergonomic and easier to learn. This iteration of the book contains a number of changes to reflect those improvements:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="26b6de1c048ad3b08c5d50eb1e62ebf661747fc3" translate="yes" xml:space="preserve">
          <source>The 2018 Edition of the Rust language includes a number of improvements that make Rust more ergonomic and easier to learn. This printing of the book contains a number of changes to reflect those improvements:</source>
          <target state="translated">Издание 2018 года,посвященное языку ржавчины,включает ряд улучшений,которые делают ржавчину более эргономичной и легкой для изучения.В этом издании книги содержится ряд изменений,отражающих эти улучшения:</target>
        </trans-unit>
        <trans-unit id="2c35b45536addab0f127b7ef2a73381bf5aab740" translate="yes" xml:space="preserve">
          <source>The 32-bit floating point type.</source>
          <target state="translated">32-битный тип с плавающей точкой.</target>
        </trans-unit>
        <trans-unit id="ede6acb001e744d94e80e43f20515bed53288286" translate="yes" xml:space="preserve">
          <source>The 32-bit signed integer type.</source>
          <target state="translated">32-битный знаковый целочисленный тип.</target>
        </trans-unit>
        <trans-unit id="a9e99a82ec2d26441031e5f8781a5ebb65a83e0e" translate="yes" xml:space="preserve">
          <source>The 32-bit unsigned integer type.</source>
          <target state="translated">32-битный беззнаковый целочисленный тип.</target>
        </trans-unit>
        <trans-unit id="13cb697c6b75c7757e9c51749eb9c614ddc9a70f" translate="yes" xml:space="preserve">
          <source>The 64-bit floating point type.</source>
          <target state="translated">64-битный тип с плавающей точкой.</target>
        </trans-unit>
        <trans-unit id="748e7d28f53e7a36937bb25af3f1a76e6a491ad6" translate="yes" xml:space="preserve">
          <source>The 64-bit signed integer type.</source>
          <target state="translated">64-битный знаковый целочисленный тип.</target>
        </trans-unit>
        <trans-unit id="25aeddd62dc36790a2166200538648d83779c0d0" translate="yes" xml:space="preserve">
          <source>The 64-bit unsigned integer type.</source>
          <target state="translated">64-битный целочисленный беззнаковый тип.</target>
        </trans-unit>
        <trans-unit id="0825a8c90a6add467ca53950b645a26af9033007" translate="yes" xml:space="preserve">
          <source>The 8-bit signed integer type.</source>
          <target state="translated">8-битный знаковый целочисленный тип.</target>
        </trans-unit>
        <trans-unit id="6d1f46b751b47e95357a0c40c6e78729c3531e1e" translate="yes" xml:space="preserve">
          <source>The 8-bit unsigned integer type.</source>
          <target state="translated">8-битный беззнаковый целочисленный тип.</target>
        </trans-unit>
        <trans-unit id="b568b58db2fe5b477d28998d21858de250eecb32" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#method.clone&quot;&gt;&lt;code&gt;Arc::clone(&amp;amp;from)&lt;/code&gt;&lt;/a&gt; syntax is the most idiomatic because it conveys more explicitly the meaning of the code. In the example above, this syntax makes it easier to see that this code is creating a new reference rather than copying the whole content of foo.</source>
          <target state="translated">&lt;a href=&quot;#method.clone&quot;&gt; &lt;code&gt;Arc::clone(&amp;amp;from)&lt;/code&gt; &lt;/a&gt; синтаксис наиболее идиоматических , поскольку она передает более явно значение кода. В приведенном выше примере этот синтаксис помогает увидеть, что этот код создает новую ссылку, а не копирует все содержимое foo.</target>
        </trans-unit>
        <trans-unit id="fd0354b8e891bd703f8ef8a8ce8547a17dc2e4cc" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#method.connect&quot;&gt;&lt;code&gt;connect&lt;/code&gt;&lt;/a&gt; method will connect the socket to a peer.</source>
          <target state="translated">Метод &lt;a href=&quot;#method.connect&quot;&gt; &lt;code&gt;connect&lt;/code&gt; &lt;/a&gt; подключит сокет к одноранговому узлу.</target>
        </trans-unit>
        <trans-unit id="de66ae551d77056e5d10cff2c3fd9dbcc9b63e6e" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#method.connect&quot;&gt;&lt;code&gt;connect&lt;/code&gt;&lt;/a&gt; method will connect this socket to a remote address. This method will fail if the socket is not connected.</source>
          <target state="translated">Метод &lt;a href=&quot;#method.connect&quot;&gt; &lt;code&gt;connect&lt;/code&gt; &lt;/a&gt; подключит этот сокет к удаленному адресу. Этот метод не сработает, если сокет не подключен.</target>
        </trans-unit>
        <trans-unit id="3822ea1855bf914e5a814986732fc459619fc61c" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#method.drain&quot;&gt;&lt;code&gt;drain&lt;/code&gt;&lt;/a&gt; method can emulate &lt;code&gt;truncate&lt;/code&gt;, but causes the excess elements to be returned instead of dropped.</source>
          <target state="translated">Метод &lt;a href=&quot;#method.drain&quot;&gt; &lt;code&gt;drain&lt;/code&gt; &lt;/a&gt; может имитировать &lt;code&gt;truncate&lt;/code&gt; , но заставляет возвращать лишние элементы, а не отбрасывать их.</target>
        </trans-unit>
        <trans-unit id="a9d6dbd0eeefdb718b7113fea8088d62bd58b0d7" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#method.len&quot;&gt;&lt;code&gt;len&lt;/code&gt;&lt;/a&gt; method has a default implementation, so you usually shouldn't implement it. However, you may be able to provide a more performant implementation than the default, so overriding it in this case makes sense.</source>
          <target state="translated">Метод &lt;a href=&quot;#method.len&quot;&gt; &lt;code&gt;len&lt;/code&gt; &lt;/a&gt; имеет реализацию по умолчанию, поэтому обычно вам не следует его реализовывать. Однако вы можете предоставить более производительную реализацию, чем стандартная, поэтому в данном случае имеет смысл переопределить ее.</target>
        </trans-unit>
        <trans-unit id="dade93dc3cf6b97db5474305c3207f7c692d153c" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#method.map&quot;&gt;&lt;code&gt;map&lt;/code&gt;&lt;/a&gt; adapter is very useful, but only when the closure argument produces values. If it produces an iterator instead, there's an extra layer of indirection. &lt;code&gt;flat_map()&lt;/code&gt; will remove this extra layer on its own.</source>
          <target state="translated">&lt;a href=&quot;#method.map&quot;&gt; &lt;code&gt;map&lt;/code&gt; &lt;/a&gt; адаптер очень полезно, но только тогда , когда укупорочное аргумент производит значения. Если вместо этого он создает итератор, возникает дополнительный уровень косвенности. &lt;code&gt;flat_map()&lt;/code&gt; удалит этот лишний слой самостоятельно.</target>
        </trans-unit>
        <trans-unit id="7a52c1262c15b7898ef7ba52e5c11aa28470cc03" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#method.new&quot;&gt;&lt;code&gt;new&lt;/code&gt;&lt;/a&gt; method will actually check that the provided &lt;code&gt;&amp;amp;[u8]&lt;/code&gt; does not have 0 bytes in the middle, and return an error if it finds one.</source>
          <target state="translated">&lt;a href=&quot;#method.new&quot;&gt; &lt;code&gt;new&lt;/code&gt; &lt;/a&gt; метод будет фактически проверить , что при условии &lt;code&gt;&amp;amp;[u8]&lt;/code&gt; не имеет 0 байт , в середине, и возвращает ошибку , если он находит.</target>
        </trans-unit>
        <trans-unit id="156348d96d775ff156fee076f0f98b0084e3469d" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#method.send&quot;&gt;&lt;code&gt;send&lt;/code&gt;&lt;/a&gt; method may be used to send data to the specified address. &lt;a href=&quot;#method.recv&quot;&gt;&lt;code&gt;recv&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#method.recv_from&quot;&gt;&lt;code&gt;recv_from&lt;/code&gt;&lt;/a&gt; will only receive data from that address.</source>
          <target state="translated">Метод &lt;a href=&quot;#method.send&quot;&gt; &lt;code&gt;send&lt;/code&gt; &lt;/a&gt; может использоваться для отправки данных на указанный адрес. &lt;a href=&quot;#method.recv&quot;&gt; &lt;code&gt;recv&lt;/code&gt; &lt;/a&gt; и &lt;a href=&quot;#method.recv_from&quot;&gt; &lt;code&gt;recv_from&lt;/code&gt; &lt;/a&gt; будут получать данные только с этого адреса.</target>
        </trans-unit>
        <trans-unit id="1ad11576c65e9334d7573beaf36142b4de74e09c" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#primitive-representations&quot;&gt;primitive representations&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ed6b3d78fe45feec8a5741e2a3ac93f1ed3a19d8" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#tymethod.flush&quot;&gt;&lt;code&gt;flush&lt;/code&gt;&lt;/a&gt; method is useful for adaptors and explicit buffers themselves for ensuring that all buffered data has been pushed out to the 'true sink'.</source>
          <target state="translated">Метод &lt;a href=&quot;#tymethod.flush&quot;&gt; &lt;code&gt;flush&lt;/code&gt; &lt;/a&gt; полезен для самих адаптеров и явных буферов, чтобы гарантировать, что все буферизованные данные были вытолкнуты в &amp;laquo;истинный приемник&amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="8a62cb575b08d38c732e1bba9328976a264fdb19" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#tymethod.write&quot;&gt;&lt;code&gt;write&lt;/code&gt;&lt;/a&gt; method will attempt to write some data into the object, returning how many bytes were successfully written.</source>
          <target state="translated">Метод &lt;a href=&quot;#tymethod.write&quot;&gt; &lt;code&gt;write&lt;/code&gt; &lt;/a&gt; попытается записать некоторые данные в объект, возвращая, сколько байтов было успешно записано.</target>
        </trans-unit>
        <trans-unit id="8fcdedc3c9e84c7fa96e2530650c1bc070bc790b" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;../expressions/block-expr#async-blocks&quot;&gt;&lt;code&gt;async move&lt;/code&gt; block&lt;/a&gt; in the body captures all function parameters, including those that are unused or bound to a &lt;code&gt;_&lt;/code&gt; pattern. This ensures that function parameters are dropped in the same order as they would be if the function were not async, except that the drop occurs when the returned future has been fully awaited.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c78f52a30365dea52628c4ade488db0345ffa3ac" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;../macro.eprint&quot;&gt;&lt;code&gt;eprint!&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../macro.eprintln&quot;&gt;&lt;code&gt;eprintln!&lt;/code&gt;&lt;/a&gt; macros are identical to &lt;a href=&quot;../macro.print&quot;&gt;&lt;code&gt;print!&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../macro.println&quot;&gt;&lt;code&gt;println!&lt;/code&gt;&lt;/a&gt;, respectively, except they emit their output to stderr.</source>
          <target state="translated">&lt;a href=&quot;../macro.eprint&quot;&gt; &lt;code&gt;eprint!&lt;/code&gt; &lt;/a&gt;и &lt;a href=&quot;../macro.eprintln&quot;&gt; &lt;code&gt;eprintln!&lt;/code&gt; &lt;/a&gt;макросы идентичны &lt;a href=&quot;../macro.print&quot;&gt; &lt;code&gt;print!&lt;/code&gt; &lt;/a&gt;и &lt;a href=&quot;../macro.println&quot;&gt; &lt;code&gt;println!&lt;/code&gt; &lt;/a&gt;соответственно, за исключением того, что они отправляют свой вывод в stderr.</target>
        </trans-unit>
        <trans-unit id="15b30e899910805c24344f039598ed4f0cfd76f0" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;../macro.format&quot;&gt;&lt;code&gt;format!&lt;/code&gt;&lt;/a&gt; macro is intended to be familiar to those coming from C's &lt;code&gt;printf&lt;/code&gt;/&lt;code&gt;fprintf&lt;/code&gt; functions or Python's &lt;code&gt;str.format&lt;/code&gt; function.</source>
          <target state="translated">&lt;a href=&quot;../macro.format&quot;&gt; &lt;code&gt;format!&lt;/code&gt; &lt;/a&gt;макрос предназначен быть знакомы с тем , исходя из языка C &lt;code&gt;printf&lt;/code&gt; / &lt;code&gt;fprintf&lt;/code&gt; функции или Пайтон &lt;code&gt;str.format&lt;/code&gt; функции.</target>
        </trans-unit>
        <trans-unit id="5d076b83cf0704732b7b9eb8c03c4bfbdeaffd03" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;../macro.format_args&quot;&gt;&lt;code&gt;format_args!&lt;/code&gt;&lt;/a&gt; macro will safely create an instance of this structure. The macro validates the format string at compile-time so usage of the &lt;a href=&quot;fn.write&quot;&gt;&lt;code&gt;write()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;fn.format&quot;&gt;&lt;code&gt;format()&lt;/code&gt;&lt;/a&gt; functions can be safely performed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1da9aedd3913426ccb3cbeae460a449f6f18fc2d" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;../macro.format_args&quot;&gt;&lt;code&gt;format_args!&lt;/code&gt;&lt;/a&gt; macro will safely create an instance of this structure. The macro validates the format string at compile-time so usage of the &lt;a href=&quot;fn.write&quot;&gt;&lt;code&gt;write&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;fn.format&quot;&gt;&lt;code&gt;format&lt;/code&gt;&lt;/a&gt; functions can be safely performed.</source>
          <target state="translated">В &lt;a href=&quot;../macro.format_args&quot;&gt; &lt;code&gt;format_args!&lt;/code&gt; &lt;/a&gt;макрос безопасно создаст экземпляр этой структуры. Макрос проверяет строку формата во время компиляции, поэтому использование функций &lt;a href=&quot;fn.write&quot;&gt; &lt;code&gt;write&lt;/code&gt; &lt;/a&gt; и &lt;a href=&quot;fn.format&quot;&gt; &lt;code&gt;format&lt;/code&gt; &lt;/a&gt; может быть безопасно выполнено.</target>
        </trans-unit>
        <trans-unit id="d6220f58fc37e6b8b0afc01735948c86469d85de" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;../macro.vec&quot;&gt;&lt;code&gt;vec!&lt;/code&gt;&lt;/a&gt; macro is provided to make initialization more convenient:</source>
          <target state="translated">&lt;a href=&quot;../macro.vec&quot;&gt; &lt;code&gt;vec!&lt;/code&gt; &lt;/a&gt;Для удобства инициализации предусмотрен макрос:</target>
        </trans-unit>
        <trans-unit id="d6015eed300b7de406449e79cfdc1aa2f387182e" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;../macros-by-example#the-macro_use-attribute&quot;&gt;&lt;code&gt;macro_use&lt;/code&gt; attribute&lt;/a&gt; works as usual and import the macro names into the macro-use prelude.</source>
          <target state="translated">&lt;a href=&quot;../macros-by-example#the-macro_use-attribute&quot;&gt; &lt;code&gt;macro_use&lt;/code&gt; атрибут&lt;/a&gt; работает как обычно и импортировать имена макросов в макро-использовании прелюдию.</target>
        </trans-unit>
        <trans-unit id="3ee79a0bb859db06f06e2ddc850e161230b3ef29" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;../marker/trait.send&quot;&gt;&lt;code&gt;Send&lt;/code&gt;&lt;/a&gt; constraint is because the closure will need to be passed &lt;em&gt;by value&lt;/em&gt; from the thread where it is spawned to the new thread. Its return value will need to be passed from the new thread to the thread where it is &lt;code&gt;join&lt;/code&gt;ed. As a reminder, the &lt;a href=&quot;../marker/trait.send&quot;&gt;&lt;code&gt;Send&lt;/code&gt;&lt;/a&gt; marker trait expresses that it is safe to be passed from thread to thread. &lt;a href=&quot;../marker/trait.sync&quot;&gt;&lt;code&gt;Sync&lt;/code&gt;&lt;/a&gt; expresses that it is safe to have a reference be passed from thread to thread.</source>
          <target state="translated">Ограничение &amp;laquo; &lt;a href=&quot;../marker/trait.send&quot;&gt; &lt;code&gt;Send&lt;/code&gt; &lt;/a&gt; возникает из-за того, что закрытие необходимо передать &lt;em&gt;по значению&lt;/em&gt; из потока, в котором оно порождается, в новый поток. Его возвращаемое значение необходимо будет передать из нового потока в поток, в котором он &lt;code&gt;join&lt;/code&gt; . Напоминаем, что свойство маркера &lt;a href=&quot;../marker/trait.send&quot;&gt; &lt;code&gt;Send&lt;/code&gt; &lt;/a&gt; выражает безопасность передачи от потока к потоку. &lt;a href=&quot;../marker/trait.sync&quot;&gt; &lt;code&gt;Sync&lt;/code&gt; &lt;/a&gt; означает, что передача ссылки из потока в поток безопасна.</target>
        </trans-unit>
        <trans-unit id="9c69caf5cbc6ae5668ac370ea6aa28c0348ce679" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;../paths&quot;&gt;path&lt;/a&gt; to an associated item is any path to the implementing type, followed by the associated item's identifier as the final path component.</source>
          <target state="translated">&lt;a href=&quot;../paths&quot;&gt;Путь&lt;/a&gt; к связанному элементу является любой путем к реализующему типу, за которым следует идентификатор ассоциированного элемента в качестве конечного компонента пути.</target>
        </trans-unit>
        <trans-unit id="1dedee4df1c883aa9e7db0132fc24154a02120fc" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;../pin/struct.pin&quot;&gt;&lt;code&gt;Pin&lt;/code&gt;&lt;/a&gt; type is used instead to prevent moves through the type system. Pointers &lt;code&gt;P&amp;lt;T&amp;gt;&lt;/code&gt; wrapped in the &lt;a href=&quot;../pin/struct.pin&quot;&gt;&lt;code&gt;Pin&amp;lt;P&amp;lt;T&amp;gt;&amp;gt;&lt;/code&gt;&lt;/a&gt; wrapper can't be moved out of. See the &lt;a href=&quot;../pin/index&quot;&gt;&lt;code&gt;pin&lt;/code&gt; module&lt;/a&gt; documentation for more information on pinning.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a4c6d762c492370e5bdcdefde3e4fc5cf31a9b6e" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;../reference/items/unions&quot;&gt;Rust equivalent of a C-style union&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;../reference/items/unions&quot;&gt;Ржавчина эквивалент союза С-стиль&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="86cbe7690d77cc63e21bdfee9a1e9528110648c5" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;../reference/types/trait-object&quot;&gt;Reference&lt;/a&gt; has more information about trait objects, their limitations and the differences between editions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fb6f479476a4a73b474dd9bb423ce981f3c3f329" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;../result/enum.result#variant.Ok&quot;&gt;&lt;code&gt;Ok&lt;/code&gt;&lt;/a&gt; variant of this result indicates that the primitive was not poisoned, and the &lt;code&gt;Guard&lt;/code&gt; is contained within. The &lt;a href=&quot;../result/enum.result#variant.Err&quot;&gt;&lt;code&gt;Err&lt;/code&gt;&lt;/a&gt; variant indicates that the primitive was poisoned. Note that the &lt;a href=&quot;../result/enum.result#variant.Err&quot;&gt;&lt;code&gt;Err&lt;/code&gt;&lt;/a&gt; variant &lt;em&gt;also&lt;/em&gt; carries the associated guard, and it can be acquired through the &lt;a href=&quot;struct.poisonerror#method.into_inner&quot;&gt;&lt;code&gt;into_inner&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">Вариант &lt;a href=&quot;../result/enum.result#variant.Ok&quot;&gt; &lt;code&gt;Ok&lt;/code&gt; &lt;/a&gt; этого результата указывает на то, что примитив не был отравлен и &lt;code&gt;Guard&lt;/code&gt; содержится внутри. Вариант &lt;a href=&quot;../result/enum.result#variant.Err&quot;&gt; &lt;code&gt;Err&lt;/code&gt; &lt;/a&gt; указывает на то, что примитив был отравлен. Обратите внимание, что вариант &lt;a href=&quot;../result/enum.result#variant.Err&quot;&gt; &lt;code&gt;Err&lt;/code&gt; &lt;/a&gt;&lt;em&gt; также&lt;/em&gt; несет соответствующую &lt;a href=&quot;struct.poisonerror#method.into_inner&quot;&gt; &lt;code&gt;into_inner&lt;/code&gt; &lt;/a&gt; , и ее можно получить с помощью метода into_inner .</target>
        </trans-unit>
        <trans-unit id="79df059e358a4241ab821f0fe6e918cdbba9f208" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;../std/clone/trait.clone&quot;&gt;&lt;code&gt;Clone&lt;/code&gt;&lt;/a&gt; trait is a supertrait of &lt;code&gt;Copy&lt;/code&gt;, so it also needs compiler generated implementations. It is implemented by the compiler for the following types:</source>
          <target state="translated">&lt;a href=&quot;../std/clone/trait.clone&quot;&gt; &lt;code&gt;Clone&lt;/code&gt; &lt;/a&gt; черты является supertrait из &lt;code&gt;Copy&lt;/code&gt; , поэтому он также нуждается в компиляторе реализации. Он реализован компилятором для следующих типов:</target>
        </trans-unit>
        <trans-unit id="90ba5aefe61d573b28b76d88a60eabe0413d5c63" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;../std/marker/trait.copy&quot;&gt;&lt;code&gt;Copy&lt;/code&gt;&lt;/a&gt; trait changes the semantics of a type implementing it. Values whose type implements &lt;code&gt;Copy&lt;/code&gt; are copied rather than moved upon assignment.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eeefbcb93aa9d7429fc3ba4a3a1ce956f75d5cfc" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;../std/marker/trait.copy&quot;&gt;&lt;code&gt;Copy&lt;/code&gt;&lt;/a&gt; trait changes the semantics of a type implementing it. Values whose type implements &lt;code&gt;Copy&lt;/code&gt; are copied rather than moved upon assignment. &lt;code&gt;Copy&lt;/code&gt; cannot be implemented for types which implement &lt;code&gt;Drop&lt;/code&gt;, or which have fields that are not &lt;code&gt;Copy&lt;/code&gt;. &lt;code&gt;Copy&lt;/code&gt; is implemented by the compiler for</source>
          <target state="translated">Свойство &lt;a href=&quot;../std/marker/trait.copy&quot;&gt; &lt;code&gt;Copy&lt;/code&gt; &lt;/a&gt; изменяет семантику реализующего его типа. Значения, тип которых реализует &lt;code&gt;Copy&lt;/code&gt; , копируются, а не перемещаются при назначении. &lt;code&gt;Copy&lt;/code&gt; не может быть реализовано для типов, которые реализуют &lt;code&gt;Drop&lt;/code&gt; или имеют поля, &lt;code&gt;Copy&lt;/code&gt; . &lt;code&gt;Copy&lt;/code&gt; осуществляется компилятором для</target>
        </trans-unit>
        <trans-unit id="0e14c3a80117b6ea49358dfdccbdf20f1c51a89c" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;../std/marker/trait.send&quot;&gt;&lt;code&gt;Send&lt;/code&gt;&lt;/a&gt; trait indicates that a value of this type is safe to send from one thread to another.</source>
          <target state="translated">&lt;a href=&quot;../std/marker/trait.send&quot;&gt; &lt;code&gt;Send&lt;/code&gt; &lt;/a&gt; признак указывает на то, что значение этого типа является безопасным для отправки из одного потока в другой.</target>
        </trans-unit>
        <trans-unit id="974ae2ba65e9e772d3c59ca8b9d11adff4f54e38" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;../std/marker/trait.send&quot;&gt;&lt;code&gt;Send&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../std/marker/trait.sync&quot;&gt;&lt;code&gt;Sync&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../std/marker/trait.unpin&quot;&gt;&lt;code&gt;Unpin&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../std/panic/trait.unwindsafe&quot;&gt;&lt;code&gt;UnwindSafe&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;../std/panic/trait.refunwindsafe&quot;&gt;&lt;code&gt;RefUnwindSafe&lt;/code&gt;&lt;/a&gt; traits are &lt;em&gt;auto traits&lt;/em&gt;. Auto traits have special properties.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7bd79bdd63f1cb15136ac63579db2daa51f56797" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;../std/marker/trait.send&quot;&gt;&lt;code&gt;Send&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../std/marker/trait.sync&quot;&gt;&lt;code&gt;Sync&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../std/panic/trait.unwindsafe&quot;&gt;&lt;code&gt;UnwindSafe&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../std/panic/trait.refunwindsafe&quot;&gt;&lt;code&gt;RefUnwindSafe&lt;/code&gt;&lt;/a&gt; traits are &lt;em&gt;auto traits&lt;/em&gt;. Auto traits have special properties.</source>
          <target state="translated">&lt;a href=&quot;../std/marker/trait.send&quot;&gt; &lt;code&gt;Send&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;../std/marker/trait.sync&quot;&gt; &lt;code&gt;Sync&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;../std/panic/trait.unwindsafe&quot;&gt; &lt;code&gt;UnwindSafe&lt;/code&gt; &lt;/a&gt; и &lt;a href=&quot;../std/panic/trait.refunwindsafe&quot;&gt; &lt;code&gt;RefUnwindSafe&lt;/code&gt; &lt;/a&gt; черта &lt;em&gt;авто черта&lt;/em&gt; . Авто черты имеют особые свойства.</target>
        </trans-unit>
        <trans-unit id="292a56639a943e7a95497bb0cf72fbedd7460764" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;../std/marker/trait.sized&quot;&gt;&lt;code&gt;Sized&lt;/code&gt;&lt;/a&gt; trait indicates that the size of this type is known at compile-time; that is, it's not a &lt;a href=&quot;dynamically-sized-types&quot;&gt;dynamically sized type&lt;/a&gt;. &lt;a href=&quot;types/parameters&quot;&gt;Type parameters&lt;/a&gt; are &lt;code&gt;Sized&lt;/code&gt; by default. &lt;code&gt;Sized&lt;/code&gt; is always implemented automatically by the compiler, not by &lt;a href=&quot;items/implementations&quot;&gt;implementation items&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;../std/marker/trait.sized&quot;&gt; &lt;code&gt;Sized&lt;/code&gt; &lt;/a&gt; черта указывает на то, что размер этого типа известен во время компиляции; то есть это не &lt;a href=&quot;dynamically-sized-types&quot;&gt;тип&lt;/a&gt; с динамическим размером . &lt;a href=&quot;types/parameters&quot;&gt;Параметры&lt;/a&gt; типа по умолчанию имеют &lt;code&gt;Sized&lt;/code&gt; . &lt;code&gt;Sized&lt;/code&gt; всегда реализуется автоматически компилятором, а не &lt;a href=&quot;items/implementations&quot;&gt;элементами реализации&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="bbed2a3ef9298a62094e0bee99c5f47d5609e39c" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;../std/marker/trait.sync&quot;&gt;&lt;code&gt;Sync&lt;/code&gt;&lt;/a&gt; trait indicates that a value of this type is safe to share between multiple threads. This trait must be implemented for all types used in immutable &lt;a href=&quot;items/static-items&quot;&gt;&lt;code&gt;static&lt;/code&gt; items&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;../std/marker/trait.sync&quot;&gt; &lt;code&gt;Sync&lt;/code&gt; &lt;/a&gt; черта указывает на то, что значение этого типа является безопасным для использования между несколькими потоками. Эта черта должна быть реализована для всех типов, используемых в неизменяемых &lt;a href=&quot;items/static-items&quot;&gt; &lt;code&gt;static&lt;/code&gt; элементах&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="0bd4f0026aa17cd077440ff412c90263cb35c5bd" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;../std/ops/trait.drop&quot;&gt;&lt;code&gt;Drop&lt;/code&gt;&lt;/a&gt; trait provides a &lt;a href=&quot;destructors&quot;&gt;destructor&lt;/a&gt;, to be run whenever a value of this type is to be destroyed.</source>
          <target state="translated">&lt;a href=&quot;../std/ops/trait.drop&quot;&gt; &lt;code&gt;Drop&lt;/code&gt; &lt;/a&gt; черта обеспечивает &lt;a href=&quot;destructors&quot;&gt;деструктор&lt;/a&gt; , для запуска всякий раз , когда значение этого типа должно быть уничтожено.</target>
        </trans-unit>
        <trans-unit id="767089bdc12afceff4b8eaec0f0a325f5d336e5b" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;../std/primitive.str#method.parse&quot;&gt;&lt;code&gt;parse&lt;/code&gt; method on strings&lt;/a&gt; parses a string into some kind of number. Because this method can parse a variety of number types, we need to tell Rust the exact number type we want by using &lt;code&gt;let guess: u32&lt;/code&gt;. The colon (&lt;code&gt;:&lt;/code&gt;) after &lt;code&gt;guess&lt;/code&gt; tells Rust we&amp;rsquo;ll annotate the variable&amp;rsquo;s type. Rust has a few built-in number types; the &lt;code&gt;u32&lt;/code&gt; seen here is an unsigned, 32-bit integer. It&amp;rsquo;s a good default choice for a small positive number. You&amp;rsquo;ll learn about other number types in Chapter 3. Additionally, the &lt;code&gt;u32&lt;/code&gt; annotation in this example program and the comparison with &lt;code&gt;secret_number&lt;/code&gt; means that Rust will infer that &lt;code&gt;secret_number&lt;/code&gt; should be a &lt;code&gt;u32&lt;/code&gt; as well. So now the comparison will be between two values of the same type!</source>
          <target state="translated">Метод &lt;a href=&quot;../std/primitive.str#method.parse&quot;&gt; &lt;code&gt;parse&lt;/code&gt; строк&lt;/a&gt; разбирает строку на какое-то число. Поскольку этот метод может анализировать различные &lt;code&gt;let guess: u32&lt;/code&gt; типы, нам нужно указать Rust точный числовой тип, который мы хотим, используя let guess: u32 . Двоеточие ( &lt;code&gt;:&lt;/code&gt; ) после того, как &lt;code&gt;guess&lt;/code&gt; говорит Rust мы аннотирование типа переменного. В Rust есть несколько встроенных числовых типов; &lt;code&gt;u32&lt;/code&gt; видел здесь без знака, 32-разрядное целое число. Это хороший выбор по умолчанию для небольшого положительного числа. Вы узнаете о других типах чисел в главе 3. Кроме того, аннотация &lt;code&gt;u32&lt;/code&gt; в этом примере программы и сравнение с &lt;code&gt;secret_number&lt;/code&gt; означает, что Rust определит, что &lt;code&gt;secret_number&lt;/code&gt; должен быть &lt;code&gt;u32&lt;/code&gt; тоже. Итак, теперь сравнение будет происходить между двумя значениями одного типа!</target>
        </trans-unit>
        <trans-unit id="c4baaa152505c4dd10d0a8afc8811ba9994e6d24" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;../str/pattern/index&quot;&gt;pattern&lt;/a&gt; can be a &lt;a href=&quot;../primitive.char&quot;&gt;&lt;code&gt;char&lt;/code&gt;&lt;/a&gt;, a slice of &lt;a href=&quot;../primitive.char&quot;&gt;&lt;code&gt;char&lt;/code&gt;&lt;/a&gt;s, or a function or closure that determines if a character matches.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1a13bea0cade14eaae143cc58b002085ddc4bf19" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;../str/pattern/index&quot;&gt;pattern&lt;/a&gt; can be a &lt;code&gt;&amp;amp;str&lt;/code&gt;, &lt;a href=&quot;../primitive.char&quot;&gt;&lt;code&gt;char&lt;/code&gt;&lt;/a&gt;, a slice of &lt;a href=&quot;../primitive.char&quot;&gt;&lt;code&gt;char&lt;/code&gt;&lt;/a&gt;s, or a function or closure that determines if a character matches.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ac19fe7126085cad17eb0b418fa395ae25fa16f2" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;../str/struct.utf8error&quot;&gt;&lt;code&gt;Utf8Error&lt;/code&gt;&lt;/a&gt; type provided by &lt;a href=&quot;../str/index&quot;&gt;&lt;code&gt;std::str&lt;/code&gt;&lt;/a&gt; represents an error that may occur when converting a slice of &lt;a href=&quot;../primitive.u8&quot;&gt;&lt;code&gt;u8&lt;/code&gt;&lt;/a&gt;s to a &lt;a href=&quot;../primitive.str&quot;&gt;&lt;code&gt;&amp;amp;str&lt;/code&gt;&lt;/a&gt;. In this sense, it's an analogue to &lt;code&gt;FromUtf8Error&lt;/code&gt;, and you can get one from a &lt;code&gt;FromUtf8Error&lt;/code&gt; through the &lt;a href=&quot;#method.utf8_error&quot;&gt;&lt;code&gt;utf8_error&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">Тип &lt;a href=&quot;../str/struct.utf8error&quot;&gt; &lt;code&gt;Utf8Error&lt;/code&gt; ,&lt;/a&gt; предоставляемый &lt;a href=&quot;../str/index&quot;&gt; &lt;code&gt;std::str&lt;/code&gt; &lt;/a&gt; представляет ошибку, которая может возникнуть при преобразовании фрагмента &lt;a href=&quot;../primitive.u8&quot;&gt; &lt;code&gt;u8&lt;/code&gt; &lt;/a&gt; s в &lt;a href=&quot;../primitive.str&quot;&gt; &lt;code&gt;&amp;amp;str&lt;/code&gt; &lt;/a&gt; . В этом смысле это аналог &lt;code&gt;FromUtf8Error&lt;/code&gt; , и вы можете получить его из &lt;code&gt;FromUtf8Error&lt;/code&gt; с &lt;a href=&quot;#method.utf8_error&quot;&gt; &lt;code&gt;utf8_error&lt;/code&gt; &lt;/a&gt; метода utf8_error .</target>
        </trans-unit>
        <trans-unit id="7fb67cacdd201c958a0c7d558837d2a8082fe699" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;../str/struct.utf8error&quot;&gt;&lt;code&gt;Utf8Error&lt;/code&gt;&lt;/a&gt; type provided by &lt;a href=&quot;../str/index&quot;&gt;&lt;code&gt;std::str&lt;/code&gt;&lt;/a&gt; represents an error that may occur when converting a slice of &lt;a href=&quot;../primitive.u8&quot;&gt;&lt;code&gt;u8&lt;/code&gt;&lt;/a&gt;s to a &lt;a href=&quot;../primitive.str&quot;&gt;&lt;code&gt;&amp;amp;str&lt;/code&gt;&lt;/a&gt;. In this sense, it's an analogue to &lt;code&gt;FromUtf8Error&lt;/code&gt;. See its documentation for more details on using it.</source>
          <target state="translated">Тип &lt;a href=&quot;../str/struct.utf8error&quot;&gt; &lt;code&gt;Utf8Error&lt;/code&gt; ,&lt;/a&gt; предоставляемый &lt;a href=&quot;../str/index&quot;&gt; &lt;code&gt;std::str&lt;/code&gt; &lt;/a&gt; представляет ошибку, которая может возникнуть при преобразовании фрагмента &lt;a href=&quot;../primitive.u8&quot;&gt; &lt;code&gt;u8&lt;/code&gt; &lt;/a&gt; s в &lt;a href=&quot;../primitive.str&quot;&gt; &lt;code&gt;&amp;amp;str&lt;/code&gt; &lt;/a&gt; . В этом смысле это аналог &lt;code&gt;FromUtf8Error&lt;/code&gt; . См. Его документацию для получения более подробной информации по его использованию.</target>
        </trans-unit>
        <trans-unit id="239e6c53cbac59da452aab2dc0d25e7124ea430b" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;../str/struct.utf8error&quot;&gt;&lt;code&gt;Utf8Error&lt;/code&gt;&lt;/a&gt; type provided by &lt;a href=&quot;https://doc.rust-lang.org/core/str/index.html&quot;&gt;&lt;code&gt;std::str&lt;/code&gt;&lt;/a&gt; represents an error that may occur when converting a slice of &lt;a href=&quot;../primitive.u8&quot;&gt;&lt;code&gt;u8&lt;/code&gt;&lt;/a&gt;s to a &lt;a href=&quot;../primitive.str&quot;&gt;&lt;code&gt;&amp;amp;str&lt;/code&gt;&lt;/a&gt;. In this sense, it's an analogue to &lt;code&gt;FromUtf8Error&lt;/code&gt;, and you can get one from a &lt;code&gt;FromUtf8Error&lt;/code&gt; through the &lt;a href=&quot;struct.fromutf8error#method.utf8_error&quot;&gt;&lt;code&gt;utf8_error&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4d50f09079feb56741d3701cde3c9928a1a6e9ce" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;../str/struct.utf8error&quot;&gt;&lt;code&gt;Utf8Error&lt;/code&gt;&lt;/a&gt; type provided by &lt;a href=&quot;https://doc.rust-lang.org/core/str/index.html&quot;&gt;&lt;code&gt;std::str&lt;/code&gt;&lt;/a&gt; represents an error that may occur when converting a slice of &lt;a href=&quot;../primitive.u8&quot;&gt;&lt;code&gt;u8&lt;/code&gt;&lt;/a&gt;s to a &lt;a href=&quot;../primitive.str&quot;&gt;&lt;code&gt;&amp;amp;str&lt;/code&gt;&lt;/a&gt;. In this sense, it's an analogue to &lt;code&gt;FromUtf8Error&lt;/code&gt;. See its documentation for more details on using it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ddda8120a353c19c1143b9fe623d73b4dcc57ac8" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;boxed/struct.box#method.into_raw&quot;&gt;&lt;code&gt;into_raw&lt;/code&gt;&lt;/a&gt; function consumes a box and returns the raw pointer. It doesn't destroy &lt;code&gt;T&lt;/code&gt; or deallocate any memory.</source>
          <target state="translated">Функция &lt;a href=&quot;boxed/struct.box#method.into_raw&quot;&gt; &lt;code&gt;into_raw&lt;/code&gt; &lt;/a&gt; использует блок и возвращает необработанный указатель. Он не разрушает &lt;code&gt;T&lt;/code&gt; и не освобождает память.</target>
        </trans-unit>
        <trans-unit id="f8812873ebf26389aa2891235cb5791e408b7568" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;collections/index&quot;&gt;&lt;code&gt;collections&lt;/code&gt;&lt;/a&gt; module defines maps, sets, linked lists and other typical collection types, including the common &lt;a href=&quot;collections/struct.hashmap&quot;&gt;&lt;code&gt;HashMap&amp;lt;K, V&amp;gt;&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Модуль &lt;a href=&quot;collections/index&quot;&gt; &lt;code&gt;collections&lt;/code&gt; &lt;/a&gt; определяет карты, наборы, связанные списки и другие типичные типы коллекций, включая общий &lt;a href=&quot;collections/struct.hashmap&quot;&gt; &lt;code&gt;HashMap&amp;lt;K, V&amp;gt;&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="a000df2416eeaceaee8b63bcc4f4d96683535efe" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;conditional-compilation#the-cfg-attribute&quot;&gt;&lt;code&gt;cfg&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;conditional-compilation#the-cfg_attr-attribute&quot;&gt;&lt;code&gt;cfg_attr&lt;/code&gt;&lt;/a&gt; attributes are active. The &lt;a href=&quot;attributes/testing#the-test-attribute&quot;&gt;&lt;code&gt;test&lt;/code&gt;&lt;/a&gt; attribute is inert when compiling for tests and active otherwise. &lt;a href=&quot;procedural-macros#attribute-macros&quot;&gt;Attribute macros&lt;/a&gt; are active. All other attributes are inert.</source>
          <target state="translated">В &lt;a href=&quot;conditional-compilation#the-cfg-attribute&quot;&gt; &lt;code&gt;cfg&lt;/code&gt; &lt;/a&gt; и &lt;a href=&quot;conditional-compilation#the-cfg_attr-attribute&quot;&gt; &lt;code&gt;cfg_attr&lt;/code&gt; &lt;/a&gt; атрибуты являются активными. &lt;a href=&quot;attributes/testing#the-test-attribute&quot;&gt; &lt;code&gt;test&lt;/code&gt; &lt;/a&gt; атрибут инертен при компиляции для испытаний и активных иначе. &lt;a href=&quot;procedural-macros#attribute-macros&quot;&gt;Макросы атрибутов&lt;/a&gt; активны. Все остальные атрибуты инертны.</target>
        </trans-unit>
        <trans-unit id="6870dee47d3fe5b85f2f338b73c3f7cce4094df6" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;expressions/operator-expr#the-dereference-operator&quot;&gt;dereference operator&lt;/a&gt; except for raw pointers.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b6a453b12ad8603a837d27104bf0cf09312a2b66" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;expressions/operator-expr#the-dereference-operator&quot;&gt;dereference operator&lt;/a&gt; for &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; produces a place which can be moved from. This means that the &lt;code&gt;*&lt;/code&gt; operator and the destructor of &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; are built-in to the language.</source>
          <target state="translated">Оператор &lt;a href=&quot;expressions/operator-expr#the-dereference-operator&quot;&gt;разыменования&lt;/a&gt; для &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; создает место, из которого можно переместиться. Это означает, что оператор &lt;code&gt;*&lt;/code&gt; и деструктор &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; встроены в язык.</target>
        </trans-unit>
        <trans-unit id="69b248ba9e2f044518c42fe197df63cfa4b2abff" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;expressions/operator-expr#the-dereference-operator&quot;&gt;dereference operator&lt;/a&gt;.</source>
          <target state="translated">Оператор &lt;a href=&quot;expressions/operator-expr#the-dereference-operator&quot;&gt;разыменования&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="ecbb9300a5b716ea6923d97c4a33bcc05beabca8" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;fn.current&quot;&gt;&lt;code&gt;thread::current&lt;/code&gt;&lt;/a&gt; function is available even for threads not spawned by the APIs of this module.</source>
          <target state="translated">Функция &lt;a href=&quot;fn.current&quot;&gt; &lt;code&gt;thread::current&lt;/code&gt; &lt;/a&gt; доступна даже для потоков, не порожденных API этого модуля.</target>
        </trans-unit>
        <trans-unit id="83c879af00d7b8c642fb06e560ce31570f391a07" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;fn.escape_default&quot;&gt;&lt;code&gt;escape_default&lt;/code&gt;&lt;/a&gt; function provides an iterator over the bytes of an escaped version of the character given.</source>
          <target state="translated">Функция &lt;a href=&quot;fn.escape_default&quot;&gt; &lt;code&gt;escape_default&lt;/code&gt; &lt;/a&gt; предоставляет итератор по байтам экранированной версии данного символа.</target>
        </trans-unit>
        <trans-unit id="04034ef7d1f4bac81675e414f3f0f4340588ab73" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;fn.park&quot;&gt;&lt;code&gt;thread::park&lt;/code&gt;&lt;/a&gt; function blocks the current thread unless or until the token is available for its thread handle, at which point it atomically consumes the token. It may also return &lt;em&gt;spuriously&lt;/em&gt;, without consuming the token. &lt;a href=&quot;fn.park_timeout&quot;&gt;&lt;code&gt;thread::park_timeout&lt;/code&gt;&lt;/a&gt; does the same, but allows specifying a maximum time to block the thread for.</source>
          <target state="translated">Функция &lt;a href=&quot;fn.park&quot;&gt; &lt;code&gt;thread::park&lt;/code&gt; &lt;/a&gt; блокирует текущий поток до тех пор, пока токен не станет доступным для его дескриптора потока, после чего он атомарно потребляет токен. Он также может возвращаться &lt;em&gt;ложно&lt;/em&gt; , не потребляя токен. &lt;a href=&quot;fn.park_timeout&quot;&gt; &lt;code&gt;thread::park_timeout&lt;/code&gt; &lt;/a&gt; делает то же самое, но позволяет указать максимальное время для блокировки потока.</target>
        </trans-unit>
        <trans-unit id="010183e81cf43fb24dc3ff708d62a66ab46d9a21" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;fn.spawn&quot;&gt;&lt;code&gt;thread::spawn&lt;/code&gt;&lt;/a&gt; free function uses a &lt;code&gt;Builder&lt;/code&gt; with default configuration and &lt;a href=&quot;../result/enum.result#method.unwrap&quot;&gt;&lt;code&gt;unwrap&lt;/code&gt;&lt;/a&gt;s its return value.</source>
          <target state="translated">Функция &lt;a href=&quot;fn.spawn&quot;&gt; &lt;code&gt;thread::spawn&lt;/code&gt; &lt;/a&gt; free использует &lt;code&gt;Builder&lt;/code&gt; с конфигурацией по умолчанию и &lt;a href=&quot;../result/enum.result#method.unwrap&quot;&gt; &lt;code&gt;unwrap&lt;/code&gt; &lt;/a&gt; его возвращаемое значение.</target>
        </trans-unit>
        <trans-unit id="29d01ae14bfbd0d95900d7de260d830e6b2aebdb" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;glossary#scrutinee&quot;&gt;scrutinee&lt;/a&gt; of a &lt;code&gt;match&lt;/code&gt; expression is not a temporary scope, so temporaries in the scrutinee can be dropped after the &lt;code&gt;match&lt;/code&gt; expression. For example, the temporary for &lt;code&gt;1&lt;/code&gt; in &lt;code&gt;match 1 { ref mut z =&amp;gt; z };&lt;/code&gt; lives until the end of the statement.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0d631316da22e8f49a59e622d46e415aca63cb44" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;glossary#scrutinee&quot;&gt;scrutinee&lt;/a&gt; of an &lt;a href=&quot;expressions/if-expr#if-let-expressions&quot;&gt;&lt;code&gt;if let&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;expressions/match-expr&quot;&gt;&lt;code&gt;match&lt;/code&gt;&lt;/a&gt;, or &lt;a href=&quot;expressions/loop-expr#predicate-pattern-loops&quot;&gt;&lt;code&gt;while let&lt;/code&gt;&lt;/a&gt; expression.</source>
          <target state="translated">&lt;a href=&quot;glossary#scrutinee&quot;&gt;Scrutinee&lt;/a&gt; из , &lt;a href=&quot;expressions/if-expr#if-let-expressions&quot;&gt; &lt;code&gt;if let&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;expressions/match-expr&quot;&gt; &lt;code&gt;match&lt;/code&gt; &lt;/a&gt; , или в &lt;a href=&quot;expressions/loop-expr#predicate-pattern-loops&quot;&gt; &lt;code&gt;while let&lt;/code&gt; &lt;/a&gt; выражение.</target>
        </trans-unit>
        <trans-unit id="f60d04280a375c73571ef4d8073dd6fd2b866e51" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://doc.rust-lang.org/nomicon/transmutes.html&quot;&gt;nomicon&lt;/a&gt; has additional documentation.</source>
          <target state="translated">У &lt;a href=&quot;https://doc.rust-lang.org/nomicon/transmutes.html&quot;&gt;номикона&lt;/a&gt; есть дополнительная документация.</target>
        </trans-unit>
        <trans-unit id="234fa73a8f6dcc88ca3eeed24db16797666a2694" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://github.com/rust-lang/rfcs/blob/master/text/1270-deprecation.md&quot;&gt;RFC&lt;/a&gt; contains motivations and more details.</source>
          <target state="translated">&lt;a href=&quot;https://github.com/rust-lang/rfcs/blob/master/text/1270-deprecation.md&quot;&gt;RFC&lt;/a&gt; содержит мотивации и более подробную информацию.</target>
        </trans-unit>
        <trans-unit id="b6a13e231d1887805079fed3345d62d70fa98ffc" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;modules#prelude-items&quot;&gt;&lt;code&gt;no_implicit_prelude&lt;/code&gt;&lt;/a&gt; attribute can be used on a module to disable prelude lookups within that module.</source>
          <target state="translated">&lt;a href=&quot;modules#prelude-items&quot;&gt; &lt;code&gt;no_implicit_prelude&lt;/code&gt; &lt;/a&gt; атрибут может быть использован на модуле для отключения прелюдии поиска в пределах этого модуля.</target>
        </trans-unit>
        <trans-unit id="2d090eed4aa4b11f0c7d0fffa892207e5f74b95a" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;option/index&quot;&gt;&lt;code&gt;option&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;result/index&quot;&gt;&lt;code&gt;result&lt;/code&gt;&lt;/a&gt; modules define optional and error-handling types, &lt;a href=&quot;option/enum.option&quot;&gt;&lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;result/enum.result&quot;&gt;&lt;code&gt;Result&amp;lt;T, E&amp;gt;&lt;/code&gt;&lt;/a&gt;. The &lt;a href=&quot;iter/index&quot;&gt;&lt;code&gt;iter&lt;/code&gt;&lt;/a&gt; module defines Rust's iterator trait, &lt;a href=&quot;iter/trait.iterator&quot;&gt;&lt;code&gt;Iterator&lt;/code&gt;&lt;/a&gt;, which works with the &lt;a href=&quot;../book/ch03-05-control-flow#looping-through-a-collection-with-for&quot;&gt;&lt;code&gt;for&lt;/code&gt;&lt;/a&gt; loop to access collections.</source>
          <target state="translated">В &lt;a href=&quot;option/index&quot;&gt; &lt;code&gt;option&lt;/code&gt; &lt;/a&gt; и &lt;a href=&quot;result/index&quot;&gt; &lt;code&gt;result&lt;/code&gt; &lt;/a&gt; модули определяют дополнительные и обработки ошибок типа, &lt;a href=&quot;option/enum.option&quot;&gt; &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt; &lt;/a&gt; и &lt;a href=&quot;result/enum.result&quot;&gt; &lt;code&gt;Result&amp;lt;T, E&amp;gt;&lt;/code&gt; &lt;/a&gt; . Модуль &lt;a href=&quot;iter/index&quot;&gt; &lt;code&gt;iter&lt;/code&gt; &lt;/a&gt; определяет черту итератора Rust, &lt;a href=&quot;iter/trait.iterator&quot;&gt; &lt;code&gt;Iterator&lt;/code&gt; &lt;/a&gt; , которая работает с циклом &lt;a href=&quot;../book/ch03-05-control-flow#looping-through-a-collection-with-for&quot;&gt; &lt;code&gt;for&lt;/code&gt; &lt;/a&gt; для доступа к коллекциям.</target>
        </trans-unit>
        <trans-unit id="a5d9a354e8b0f07a3115dc9b0844a83e58a8610e" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;str/pattern/index&quot;&gt;pattern&lt;/a&gt; can be a &lt;a href=&quot;primitive.char&quot;&gt;&lt;code&gt;char&lt;/code&gt;&lt;/a&gt;, a slice of &lt;a href=&quot;primitive.char&quot;&gt;&lt;code&gt;char&lt;/code&gt;&lt;/a&gt;s, or a function or closure that determines if a character matches.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d0a9260d9d3256bee11715c7bab554254f578e52" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;str/pattern/index&quot;&gt;pattern&lt;/a&gt; can be a &lt;code&gt;&amp;amp;str&lt;/code&gt;, &lt;a href=&quot;primitive.char&quot;&gt;&lt;code&gt;char&lt;/code&gt;&lt;/a&gt;, a slice of &lt;a href=&quot;primitive.char&quot;&gt;&lt;code&gt;char&lt;/code&gt;&lt;/a&gt;s, or a function or closure that determines if a character matches.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8bee548c1faeb9c0868a59d1b0359e0916d54967" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;struct.arc#method.downgrade&quot;&gt;&lt;code&gt;downgrade&lt;/code&gt;&lt;/a&gt; method can be used to create a non-owning &lt;a href=&quot;struct.weak&quot;&gt;&lt;code&gt;Weak&lt;/code&gt;&lt;/a&gt; pointer. A &lt;a href=&quot;struct.weak&quot;&gt;&lt;code&gt;Weak&lt;/code&gt;&lt;/a&gt; pointer can be &lt;a href=&quot;struct.weak#method.upgrade&quot;&gt;&lt;code&gt;upgrade&lt;/code&gt;&lt;/a&gt;d to an &lt;code&gt;Arc&lt;/code&gt;, but this will return &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt; if the value has already been dropped.</source>
          <target state="translated">Метод &lt;a href=&quot;struct.arc#method.downgrade&quot;&gt; &lt;code&gt;downgrade&lt;/code&gt; &lt;/a&gt; версию может использоваться для создания &lt;a href=&quot;struct.weak&quot;&gt; &lt;code&gt;Weak&lt;/code&gt; &lt;/a&gt; указателя, не являющегося владельцем . &lt;a href=&quot;struct.weak&quot;&gt; &lt;code&gt;Weak&lt;/code&gt; &lt;/a&gt; указатель может быть &lt;a href=&quot;struct.weak#method.upgrade&quot;&gt; &lt;code&gt;upgrade&lt;/code&gt; &lt;/a&gt; d к &lt;code&gt;Arc&lt;/code&gt; , но это не вернет &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt; &lt;code&gt;None&lt;/code&gt; &lt;/a&gt; , если значение уже уронили.</target>
        </trans-unit>
        <trans-unit id="74bc0ed50e554fb672c29105c76cd20026688a4b" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;struct.arc#method.downgrade&quot;&gt;&lt;code&gt;downgrade&lt;/code&gt;&lt;/a&gt; method can be used to create a non-owning &lt;a href=&quot;struct.weak&quot;&gt;&lt;code&gt;Weak&lt;/code&gt;&lt;/a&gt; pointer. A &lt;a href=&quot;struct.weak&quot;&gt;&lt;code&gt;Weak&lt;/code&gt;&lt;/a&gt; pointer can be &lt;a href=&quot;struct.weak#method.upgrade&quot;&gt;&lt;code&gt;upgrade&lt;/code&gt;&lt;/a&gt;d to an &lt;code&gt;Arc&lt;/code&gt;, but this will return &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt; if the value stored in the allocation has already been dropped. In other words, &lt;code&gt;Weak&lt;/code&gt; pointers do not keep the value inside the allocation alive; however, they &lt;em&gt;do&lt;/em&gt; keep the allocation (the backing store for the value) alive.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="94c3ecdf0be1261908d0f10ca942b75ee9286aef" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;struct.arguments&quot;&gt;&lt;code&gt;Arguments&lt;/code&gt;&lt;/a&gt; instance can be created with the &lt;a href=&quot;../macro.format_args&quot;&gt;&lt;code&gt;format_args!&lt;/code&gt;&lt;/a&gt; macro.</source>
          <target state="translated">&lt;a href=&quot;struct.arguments&quot;&gt; &lt;code&gt;Arguments&lt;/code&gt; &lt;/a&gt; экземпляр может быть создан с &lt;a href=&quot;../macro.format_args&quot;&gt; &lt;code&gt;format_args!&lt;/code&gt; &lt;/a&gt;макрос.</target>
        </trans-unit>
        <trans-unit id="fa75ef55ee98f7d19f2ace1042e87faf9ee8ae65" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;struct.bufwriter&quot;&gt;&lt;code&gt;BufWriter&lt;/code&gt;&lt;/a&gt; struct wraps a writer and buffers its output. But it only does this batched write when it goes out of scope, or when the internal buffer is full. Sometimes, you'd prefer to write each line as it's completed, rather than the entire buffer at once. Enter &lt;code&gt;LineWriter&lt;/code&gt;. It does exactly that.</source>
          <target state="translated">Структура &lt;a href=&quot;struct.bufwriter&quot;&gt; &lt;code&gt;BufWriter&lt;/code&gt; &lt;/a&gt; обертывает писатель и буферизует его вывод. Но пакетная запись выполняется только тогда, когда она выходит за пределы области видимости или когда внутренний буфер заполнен. Иногда вы предпочитаете записывать каждую строку по мере ее завершения, а не весь буфер сразу. Введите &lt;code&gt;LineWriter&lt;/code&gt; . Это именно так.</target>
        </trans-unit>
        <trans-unit id="a07405d582facf4ae9638d6c46ccf83d378ca9a4" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;struct.builder#method.spawn&quot;&gt;&lt;code&gt;spawn&lt;/code&gt;&lt;/a&gt; method will take ownership of the builder and create an &lt;a href=&quot;../io/type.result&quot;&gt;&lt;code&gt;io::Result&lt;/code&gt;&lt;/a&gt; to the thread handle with the given configuration.</source>
          <target state="translated">Метод &lt;a href=&quot;struct.builder#method.spawn&quot;&gt; &lt;code&gt;spawn&lt;/code&gt; &lt;/a&gt; возьмет на себя ответственность за построитель и создаст &lt;a href=&quot;../io/type.result&quot;&gt; &lt;code&gt;io::Result&lt;/code&gt; &lt;/a&gt; для дескриптора потока с заданной конфигурацией.</target>
        </trans-unit>
        <trans-unit id="8461a34249fb23d4197f5b2441105518f99e167b" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;struct.command&quot;&gt;&lt;code&gt;Command&lt;/code&gt;&lt;/a&gt; struct is used to configure and spawn processes:</source>
          <target state="translated">Структура &lt;a href=&quot;struct.command&quot;&gt; &lt;code&gt;Command&lt;/code&gt; &lt;/a&gt; используется для настройки и порождения процессов:</target>
        </trans-unit>
        <trans-unit id="c0f682c8845fc1182cef69275c8073a32be2d0f3" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;struct.command#method.stdout&quot;&gt;&lt;code&gt;stdout&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;struct.command#method.stdin&quot;&gt;&lt;code&gt;stdin&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;struct.command#method.stderr&quot;&gt;&lt;code&gt;stderr&lt;/code&gt;&lt;/a&gt; of a child process can be configured by passing an &lt;a href=&quot;struct.stdio&quot;&gt;&lt;code&gt;Stdio&lt;/code&gt;&lt;/a&gt; to the corresponding method on &lt;a href=&quot;struct.command&quot;&gt;&lt;code&gt;Command&lt;/code&gt;&lt;/a&gt;. Once spawned, they can be accessed from the &lt;a href=&quot;struct.child&quot;&gt;&lt;code&gt;Child&lt;/code&gt;&lt;/a&gt;. For example, piping output from one command into another command can be done like so:</source>
          <target state="translated">&lt;a href=&quot;struct.command#method.stdout&quot;&gt; &lt;code&gt;stdout&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;struct.command#method.stdin&quot;&gt; &lt;code&gt;stdin&lt;/code&gt; &lt;/a&gt; и &lt;a href=&quot;struct.command#method.stderr&quot;&gt; &lt;code&gt;stderr&lt;/code&gt; &lt;/a&gt; дочернего процесса могут быть сконфигурированы путем пропускания &lt;a href=&quot;struct.stdio&quot;&gt; &lt;code&gt;Stdio&lt;/code&gt; &lt;/a&gt; к соответствующему способу по &lt;a href=&quot;struct.command&quot;&gt; &lt;code&gt;Command&lt;/code&gt; &lt;/a&gt; . После создания к ним можно получить доступ из &lt;a href=&quot;struct.child&quot;&gt; &lt;code&gt;Child&lt;/code&gt; &lt;/a&gt; . Например, преобразование вывода одной команды в другую можно сделать так:</target>
        </trans-unit>
        <trans-unit id="f9ad904c74c4288c252921bb9ae74bd23e865305" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;struct.cstring#method.new&quot;&gt;&lt;code&gt;CString::new&lt;/code&gt;&lt;/a&gt; method will actually check that the provided &lt;code&gt;&amp;amp;[u8]&lt;/code&gt; does not have 0 bytes in the middle, and return an error if it finds one.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="979c5c1602643a6a3cebe7ffbfac71410fb43889" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;struct.joinhandle#method.join&quot;&gt;&lt;code&gt;join&lt;/code&gt;&lt;/a&gt; method returns a &lt;a href=&quot;type.result&quot;&gt;&lt;code&gt;thread::Result&lt;/code&gt;&lt;/a&gt; containing &lt;a href=&quot;../result/enum.result#variant.Ok&quot;&gt;&lt;code&gt;Ok&lt;/code&gt;&lt;/a&gt; of the final value produced by the child thread, or &lt;a href=&quot;../result/enum.result#variant.Err&quot;&gt;&lt;code&gt;Err&lt;/code&gt;&lt;/a&gt; of the value given to a call to &lt;a href=&quot;../macro.panic&quot;&gt;&lt;code&gt;panic!&lt;/code&gt;&lt;/a&gt; if the child panicked.</source>
          <target state="translated">Метод &lt;a href=&quot;struct.joinhandle#method.join&quot;&gt; &lt;code&gt;join&lt;/code&gt; &lt;/a&gt; возвращает &lt;a href=&quot;type.result&quot;&gt; &lt;code&gt;thread::Result&lt;/code&gt; &lt;/a&gt; содержащий &lt;a href=&quot;../result/enum.result#variant.Ok&quot;&gt; &lt;code&gt;Ok&lt;/code&gt; &lt;/a&gt; конечного значения, созданного дочерним потоком, или &lt;a href=&quot;../result/enum.result#variant.Err&quot;&gt; &lt;code&gt;Err&lt;/code&gt; &lt;/a&gt; значения, присвоенного вызову &lt;a href=&quot;../macro.panic&quot;&gt; &lt;code&gt;panic!&lt;/code&gt; &lt;/a&gt;если ребенок запаниковал.</target>
        </trans-unit>
        <trans-unit id="d70df5ac1306fbf7451739c8b7b5cbb316412dcd" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;struct.localkey#method.with&quot;&gt;&lt;code&gt;with&lt;/code&gt;&lt;/a&gt; method yields a reference to the contained value which cannot be sent across threads or escape the given closure.</source>
          <target state="translated">Метод &lt;a href=&quot;struct.localkey#method.with&quot;&gt; &lt;code&gt;with&lt;/code&gt; &lt;/a&gt; дает ссылку на содержащееся значение, которое нельзя передать по потокам или избежать данного закрытия.</target>
        </trans-unit>
        <trans-unit id="4cdf73c1055626ea58f2e6c5956631d7c37626c9" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;struct.rc#method.downgrade&quot;&gt;&lt;code&gt;downgrade&lt;/code&gt;&lt;/a&gt; method can be used to create a non-owning &lt;a href=&quot;struct.weak&quot;&gt;&lt;code&gt;Weak&lt;/code&gt;&lt;/a&gt; pointer. A &lt;a href=&quot;struct.weak&quot;&gt;&lt;code&gt;Weak&lt;/code&gt;&lt;/a&gt; pointer can be &lt;a href=&quot;struct.weak#method.upgrade&quot;&gt;&lt;code&gt;upgrade&lt;/code&gt;&lt;/a&gt;d to an &lt;a href=&quot;struct.rc&quot;&gt;&lt;code&gt;Rc&lt;/code&gt;&lt;/a&gt;, but this will return &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt; if the value has already been dropped.</source>
          <target state="translated">Метод &lt;a href=&quot;struct.rc#method.downgrade&quot;&gt; &lt;code&gt;downgrade&lt;/code&gt; &lt;/a&gt; версию может использоваться для создания &lt;a href=&quot;struct.weak&quot;&gt; &lt;code&gt;Weak&lt;/code&gt; &lt;/a&gt; указателя, не являющегося владельцем . &lt;a href=&quot;struct.weak&quot;&gt; &lt;code&gt;Weak&lt;/code&gt; &lt;/a&gt; указатель может быть &lt;a href=&quot;struct.weak#method.upgrade&quot;&gt; &lt;code&gt;upgrade&lt;/code&gt; &lt;/a&gt; d к &lt;a href=&quot;struct.rc&quot;&gt; &lt;code&gt;Rc&lt;/code&gt; &lt;/a&gt; , но это не вернет &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt; &lt;code&gt;None&lt;/code&gt; &lt;/a&gt; , если значение уже уронили.</target>
        </trans-unit>
        <trans-unit id="bcfdea4875bc006b185727ffa377cb6c800ff1eb" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;struct.rc#method.downgrade&quot;&gt;&lt;code&gt;downgrade&lt;/code&gt;&lt;/a&gt; method can be used to create a non-owning &lt;a href=&quot;struct.weak&quot;&gt;&lt;code&gt;Weak&lt;/code&gt;&lt;/a&gt; pointer. A &lt;a href=&quot;struct.weak&quot;&gt;&lt;code&gt;Weak&lt;/code&gt;&lt;/a&gt; pointer can be &lt;a href=&quot;struct.weak#method.upgrade&quot;&gt;&lt;code&gt;upgrade&lt;/code&gt;&lt;/a&gt;d to an &lt;a href=&quot;struct.rc&quot;&gt;&lt;code&gt;Rc&lt;/code&gt;&lt;/a&gt;, but this will return &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt; if the value stored in the allocation has already been dropped. In other words, &lt;code&gt;Weak&lt;/code&gt; pointers do not keep the value inside the allocation alive; however, they &lt;em&gt;do&lt;/em&gt; keep the allocation (the backing store for the inner value) alive.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="673675ebe57e0604b8f52dd76cd89f3cf84af682" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;struct.receiver#method.recv&quot;&gt;&lt;code&gt;recv&lt;/code&gt;&lt;/a&gt; operation can only fail if the sending half of a &lt;a href=&quot;fn.channel&quot;&gt;&lt;code&gt;channel&lt;/code&gt;&lt;/a&gt; (or &lt;a href=&quot;fn.sync_channel&quot;&gt;&lt;code&gt;sync_channel&lt;/code&gt;&lt;/a&gt;) is disconnected, implying that no further messages will ever be received.</source>
          <target state="translated">Операция &lt;a href=&quot;struct.receiver#method.recv&quot;&gt; &lt;code&gt;recv&lt;/code&gt; &lt;/a&gt; может потерпеть неудачу только в том случае, если отправляющая половина &lt;a href=&quot;fn.channel&quot;&gt; &lt;code&gt;channel&lt;/code&gt; &lt;/a&gt; (или &lt;a href=&quot;fn.sync_channel&quot;&gt; &lt;code&gt;sync_channel&lt;/code&gt; &lt;/a&gt; ) отключена, что означает, что никакие дальнейшие сообщения никогда не будут получены.</target>
        </trans-unit>
        <trans-unit id="2096b737ddfebc05d46f568e296a81f0a3d0197e" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;struct.sender&quot;&gt;&lt;code&gt;Sender&lt;/code&gt;&lt;/a&gt; can be cloned to &lt;a href=&quot;struct.sender#method.send&quot;&gt;&lt;code&gt;send&lt;/code&gt;&lt;/a&gt; to the same channel multiple times, but only one &lt;a href=&quot;struct.receiver&quot;&gt;&lt;code&gt;Receiver&lt;/code&gt;&lt;/a&gt; is supported.</source>
          <target state="translated">&lt;a href=&quot;struct.sender&quot;&gt; &lt;code&gt;Sender&lt;/code&gt; &lt;/a&gt; может быть клонирован &lt;a href=&quot;struct.sender#method.send&quot;&gt; &lt;code&gt;send&lt;/code&gt; &lt;/a&gt; на тот же канал несколько раз, но только один &lt;a href=&quot;struct.receiver&quot;&gt; &lt;code&gt;Receiver&lt;/code&gt; &lt;/a&gt; поддерживается.</target>
        </trans-unit>
        <trans-unit id="d38fd997ec90eab994427a1fbc1ca66e988ed96b" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;struct.syncsender&quot;&gt;&lt;code&gt;SyncSender&lt;/code&gt;&lt;/a&gt; can be cloned to &lt;a href=&quot;struct.syncsender#method.send&quot;&gt;&lt;code&gt;send&lt;/code&gt;&lt;/a&gt; to the same channel multiple times, but only one &lt;a href=&quot;struct.receiver&quot;&gt;&lt;code&gt;Receiver&lt;/code&gt;&lt;/a&gt; is supported.</source>
          <target state="translated">&lt;a href=&quot;struct.syncsender&quot;&gt; &lt;code&gt;SyncSender&lt;/code&gt; &lt;/a&gt; можно клонировать &lt;a href=&quot;struct.syncsender#method.send&quot;&gt; &lt;code&gt;send&lt;/code&gt; &lt;/a&gt; на тот же канал несколько раз, но только один &lt;a href=&quot;struct.receiver&quot;&gt; &lt;code&gt;Receiver&lt;/code&gt; &lt;/a&gt; поддерживается.</target>
        </trans-unit>
        <trans-unit id="7001293def1e95a9d6c40ad63bf180d03eb64fd9" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;struct.thread#method.unpark&quot;&gt;&lt;code&gt;unpark&lt;/code&gt;&lt;/a&gt; method on a &lt;a href=&quot;struct.thread&quot;&gt;&lt;code&gt;Thread&lt;/code&gt;&lt;/a&gt; atomically makes the token available if it wasn't already. Because the token is initially absent, &lt;a href=&quot;struct.thread#method.unpark&quot;&gt;&lt;code&gt;unpark&lt;/code&gt;&lt;/a&gt; followed by &lt;a href=&quot;fn.park&quot;&gt;&lt;code&gt;park&lt;/code&gt;&lt;/a&gt; will result in the second call returning immediately.</source>
          <target state="translated">Метод &lt;a href=&quot;struct.thread#method.unpark&quot;&gt; &lt;code&gt;unpark&lt;/code&gt; &lt;/a&gt; в &lt;a href=&quot;struct.thread&quot;&gt; &lt;code&gt;Thread&lt;/code&gt; &lt;/a&gt; атомарно делает токен доступным, если он еще не был. Поскольку маркер изначально отсутствует, &lt;a href=&quot;struct.thread#method.unpark&quot;&gt; &lt;code&gt;unpark&lt;/code&gt; ,&lt;/a&gt; за которым следует &lt;a href=&quot;fn.park&quot;&gt; &lt;code&gt;park&lt;/code&gt; ,&lt;/a&gt; приведет к немедленному возврату второго вызова.</target>
        </trans-unit>
        <trans-unit id="3b63b1ad0bef3b06d878599f3be015ecfe5404bc" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;struct.unixdatagram#method.connect&quot;&gt;&lt;code&gt;connect&lt;/code&gt;&lt;/a&gt; method will connect the socket to a peer.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1599d30320e03334b98613759c0cb03ef5b8af44" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;struct.unixdatagram#method.send&quot;&gt;&lt;code&gt;send&lt;/code&gt;&lt;/a&gt; method may be used to send data to the specified address. &lt;a href=&quot;struct.unixdatagram#method.recv&quot;&gt;&lt;code&gt;recv&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;struct.unixdatagram#method.recv_from&quot;&gt;&lt;code&gt;recv_from&lt;/code&gt;&lt;/a&gt; will only receive data from that address.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a53484ac76a42814fdd6d0152dc58d8216dd587e" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;struct.vec#method.drain&quot;&gt;&lt;code&gt;drain&lt;/code&gt;&lt;/a&gt; method can emulate &lt;code&gt;truncate&lt;/code&gt;, but causes the excess elements to be returned instead of dropped.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ea6d0b5a4d7abf2551cbce00a21d08c3b9b0ea9b" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;thread/index&quot;&gt;&lt;code&gt;thread&lt;/code&gt;&lt;/a&gt; module contains Rust's threading abstractions. &lt;a href=&quot;sync/index&quot;&gt;&lt;code&gt;sync&lt;/code&gt;&lt;/a&gt; contains further primitive shared memory types, including &lt;a href=&quot;sync/atomic/index&quot;&gt;&lt;code&gt;atomic&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;sync/mpsc/index&quot;&gt;&lt;code&gt;mpsc&lt;/code&gt;&lt;/a&gt;, which contains the channel types for message passing.</source>
          <target state="translated">Модуль &lt;a href=&quot;thread/index&quot;&gt; &lt;code&gt;thread&lt;/code&gt; &lt;/a&gt; содержит абстракции потоков Rust. &lt;a href=&quot;sync/index&quot;&gt; &lt;code&gt;sync&lt;/code&gt; &lt;/a&gt; содержит дополнительные примитивные типы разделяемой памяти, включая &lt;a href=&quot;sync/atomic/index&quot;&gt; &lt;code&gt;atomic&lt;/code&gt; &lt;/a&gt; и &lt;a href=&quot;sync/mpsc/index&quot;&gt; &lt;code&gt;mpsc&lt;/code&gt; &lt;/a&gt; , которая содержит типы каналов для передачи сообщений.</target>
        </trans-unit>
        <trans-unit id="49a461a4d2bf3262db6f2402e2172259bf56947f" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;trait.asciiext&quot;&gt;&lt;code&gt;AsciiExt&lt;/code&gt;&lt;/a&gt; trait provides methods that allow for character operations that only act on the ASCII subset and leave non-ASCII characters alone.</source>
          <target state="translated">&lt;a href=&quot;trait.asciiext&quot;&gt; &lt;code&gt;AsciiExt&lt;/code&gt; &lt;/a&gt; черта предоставляет методы, позволяющие для символьных операций , которые действуют только на ASCII подмножестве и оставить не-ASCII символов в одиночку.</target>
        </trans-unit>
        <trans-unit id="1a4c8cc0a085c3df1289a22cd8aaec879c0c1b9f" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;trait.doubleendediterator&quot;&gt;trait-level&lt;/a&gt; docs contain more details.</source>
          <target state="translated">Документы на &lt;a href=&quot;trait.doubleendediterator&quot;&gt;уровне характеристик&lt;/a&gt; содержат более подробную информацию.</target>
        </trans-unit>
        <trans-unit id="a9baa3ad4d7314655f1af4e53b409fbc088f4b8e" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;trait.error#method.source&quot;&gt;&lt;code&gt;source&lt;/code&gt;&lt;/a&gt; method is generally used when errors cross &quot;abstraction boundaries&quot;. If one module must report an error that is caused by an error from a lower-level module, it can allow access to that error via the &lt;a href=&quot;trait.error#method.source&quot;&gt;&lt;code&gt;source&lt;/code&gt;&lt;/a&gt; method. This makes it possible for the high-level module to provide its own errors while also revealing some of the implementation for debugging via &lt;a href=&quot;trait.error#method.source&quot;&gt;&lt;code&gt;source&lt;/code&gt;&lt;/a&gt; chains.</source>
          <target state="translated">&lt;a href=&quot;trait.error#method.source&quot;&gt; &lt;code&gt;source&lt;/code&gt; &lt;/a&gt; метод обычно используется , когда ошибки пересекают &amp;laquo;границы абстракции&amp;raquo;. Если один модуль должен сообщить об ошибке, вызванной ошибкой модуля нижнего уровня, он может разрешить доступ к этой ошибке с помощью &lt;a href=&quot;trait.error#method.source&quot;&gt; &lt;code&gt;source&lt;/code&gt; &lt;/a&gt; метода. Это позволяет высокоуровневому модулю предоставлять свои собственные ошибки, а также раскрывать некоторые реализации для отладки через &lt;a href=&quot;trait.error#method.source&quot;&gt; &lt;code&gt;source&lt;/code&gt; &lt;/a&gt; цепочки.</target>
        </trans-unit>
        <trans-unit id="3fb97ac2277aef1f78113f1e75546370dbbdba9b" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;trait.exactsizeiterator#method.len&quot;&gt;&lt;code&gt;len&lt;/code&gt;&lt;/a&gt; method has a default implementation, so you usually shouldn't implement it. However, you may be able to provide a more performant implementation than the default, so overriding it in this case makes sense.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e8960e05e681fd3c863585eb072cff67079ae758" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;trait.fn&quot;&gt;&lt;code&gt;Fn&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;trait.fnmut&quot;&gt;&lt;code&gt;FnMut&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;trait.fnonce&quot;&gt;&lt;code&gt;FnOnce&lt;/code&gt;&lt;/a&gt; traits are implemented by types that can be invoked like functions. Note that &lt;a href=&quot;trait.fn&quot;&gt;&lt;code&gt;Fn&lt;/code&gt;&lt;/a&gt; takes &lt;code&gt;&amp;amp;self&lt;/code&gt;, &lt;a href=&quot;trait.fnmut&quot;&gt;&lt;code&gt;FnMut&lt;/code&gt;&lt;/a&gt; takes &lt;code&gt;&amp;amp;mut self&lt;/code&gt; and &lt;a href=&quot;trait.fnonce&quot;&gt;&lt;code&gt;FnOnce&lt;/code&gt;&lt;/a&gt; takes &lt;code&gt;self&lt;/code&gt;. These correspond to the three kinds of methods that can be invoked on an instance: call-by-reference, call-by-mutable-reference, and call-by-value. The most common use of these traits is to act as bounds to higher-level functions that take functions or closures as arguments.</source>
          <target state="translated">В &lt;a href=&quot;trait.fn&quot;&gt; &lt;code&gt;Fn&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;trait.fnmut&quot;&gt; &lt;code&gt;FnMut&lt;/code&gt; &lt;/a&gt; и &lt;a href=&quot;trait.fnonce&quot;&gt; &lt;code&gt;FnOnce&lt;/code&gt; &lt;/a&gt; черты реализуются типов , которые могут быть вызваны как функции. Обратите внимание, что &lt;a href=&quot;trait.fn&quot;&gt; &lt;code&gt;Fn&lt;/code&gt; &lt;/a&gt; принимает &lt;code&gt;&amp;amp;self&lt;/code&gt; , &lt;a href=&quot;trait.fnmut&quot;&gt; &lt;code&gt;FnMut&lt;/code&gt; &lt;/a&gt; принимает &lt;code&gt;&amp;amp;mut self&lt;/code&gt; а &lt;a href=&quot;trait.fnonce&quot;&gt; &lt;code&gt;FnOnce&lt;/code&gt; &lt;/a&gt; берет &lt;code&gt;self&lt;/code&gt; . Они соответствуют трем типам методов, которые могут быть вызваны в экземпляре: вызов по ссылке, вызов по изменяемой ссылке и вызов по значению. Чаще всего эти черты используются в качестве границ для функций более высокого уровня, которые принимают функции или замыкания в качестве аргументов.</target>
        </trans-unit>
        <trans-unit id="c33bacd306c2aa86080fee643cadd9fa3a5a922c" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;trait.iterator#method.map&quot;&gt;&lt;code&gt;map&lt;/code&gt;&lt;/a&gt; adapter is very useful, but only when the closure argument produces values. If it produces an iterator instead, there's an extra layer of indirection. &lt;code&gt;flat_map()&lt;/code&gt; will remove this extra layer on its own.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="af84d72464a620d276e568d18222de12da4b2fde" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;trait.iterator#method.map&quot;&gt;&lt;code&gt;map&lt;/code&gt;&lt;/a&gt; iterator implements &lt;a href=&quot;trait.doubleendediterator&quot;&gt;&lt;code&gt;DoubleEndedIterator&lt;/code&gt;&lt;/a&gt;, meaning that you can also &lt;a href=&quot;trait.iterator#method.map&quot;&gt;&lt;code&gt;map&lt;/code&gt;&lt;/a&gt; backwards:</source>
          <target state="translated">&lt;a href=&quot;trait.iterator#method.map&quot;&gt; &lt;code&gt;map&lt;/code&gt; &lt;/a&gt; итераторы реализуют &lt;a href=&quot;trait.doubleendediterator&quot;&gt; &lt;code&gt;DoubleEndedIterator&lt;/code&gt; &lt;/a&gt; , а это означает , что вы можете также &lt;a href=&quot;trait.iterator#method.map&quot;&gt; &lt;code&gt;map&lt;/code&gt; &lt;/a&gt; в обратном направлении:</target>
        </trans-unit>
        <trans-unit id="a0672d71e250ee0ec8fcc8dfa66640aade0f2d7e" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;trait.tryfrom&quot;&gt;&lt;code&gt;TryFrom&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;trait.tryinto&quot;&gt;&lt;code&gt;TryInto&lt;/code&gt;&lt;/a&gt; traits behave like &lt;a href=&quot;trait.from&quot;&gt;&lt;code&gt;From&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;trait.into&quot;&gt;&lt;code&gt;Into&lt;/code&gt;&lt;/a&gt;, but should be implemented when the conversion can fail.</source>
          <target state="translated">В &lt;a href=&quot;trait.tryfrom&quot;&gt; &lt;code&gt;TryFrom&lt;/code&gt; &lt;/a&gt; и &lt;a href=&quot;trait.tryinto&quot;&gt; &lt;code&gt;TryInto&lt;/code&gt; &lt;/a&gt; черта ведет себя как &lt;a href=&quot;trait.from&quot;&gt; &lt;code&gt;From&lt;/code&gt; &lt;/a&gt; и &lt;a href=&quot;trait.into&quot;&gt; &lt;code&gt;Into&lt;/code&gt; &lt;/a&gt; , но должна быть реализована , когда преобразование может потерпеть неудачу.</target>
        </trans-unit>
        <trans-unit id="e376c9d77b7276078629a96e3397aaf50b87d100" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;trait.write#tymethod.flush&quot;&gt;&lt;code&gt;flush&lt;/code&gt;&lt;/a&gt; method is useful for adaptors and explicit buffers themselves for ensuring that all buffered data has been pushed out to the 'true sink'.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aaa424efe4823f7e6a6edaf5a49990756704380f" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;trait.write#tymethod.write&quot;&gt;&lt;code&gt;write&lt;/code&gt;&lt;/a&gt; method will attempt to write some data into the object, returning how many bytes were successfully written.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="75436aa22cb5f73032a0aa74018fe133c992dee0" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;type-layout#primitive-representations&quot;&gt;primitive representations&lt;/a&gt;</source>
          <target state="translated">Эти &lt;a href=&quot;type-layout#primitive-representations&quot;&gt;примитивные представления&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="76a754ff1ade7a85d17901c16d28f4fc1a0ec281" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;types/inferred&quot;&gt;inferred type&lt;/a&gt; which asks the compiler to determine the type.</source>
          <target state="translated">&lt;a href=&quot;types/inferred&quot;&gt;Выведенный тип&lt;/a&gt; , который задает компилятор для определения типа.</target>
        </trans-unit>
        <trans-unit id="bbc904b6676167d928a315d71b571002efe99186" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;types/never&quot;&gt;never&lt;/a&gt; type.</source>
          <target state="translated">Тип &lt;a href=&quot;types/never&quot;&gt;никогда&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="2be3f45b2596938280efdad2e1e3c487cd3dd502" translate="yes" xml:space="preserve">
          <source>The &lt;code id=&quot;the--operator-can-be-used-in-functions-that-return-result&quot;&gt;?&lt;/code&gt; Operator Can Be Used in Functions That Return &lt;code&gt;Result&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="86dac89caf1fb6bb25d3f0271f01c85dae090eff" translate="yes" xml:space="preserve">
          <source>The &lt;code id=&quot;the--operator-can-only-be-used-in-functions-that-return-result&quot;&gt;?&lt;/code&gt; Operator Can Only Be Used in Functions That Return &lt;code&gt;Result&lt;/code&gt;</source>
          <target state="translated">&lt;code id=&quot;the--operator-can-only-be-used-in-functions-that-return-result&quot;&gt;?&lt;/code&gt; Оператор может использоваться только в функциях, возвращающих &lt;code&gt;Result&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="bf416e54f0f3d3a2ee8340cdce3195c04f0662bc" translate="yes" xml:space="preserve">
          <source>The &lt;code id=&quot;the-_-placeholder&quot;&gt;_&lt;/code&gt; Placeholder</source>
          <target state="translated">&lt;code id=&quot;the-_-placeholder&quot;&gt;_&lt;/code&gt; Заполнитель</target>
        </trans-unit>
        <trans-unit id="7d36ad4c51a4dc937d643fbbbf54439f451168f2" translate="yes" xml:space="preserve">
          <source>The &lt;code id=&quot;the-args-function-and-invalid-unicode&quot;&gt;args&lt;/code&gt; Function and Invalid Unicode</source>
          <target state="translated">Функция &lt;code id=&quot;the-args-function-and-invalid-unicode&quot;&gt;args&lt;/code&gt; и недопустимый Unicode</target>
        </trans-unit>
        <trans-unit id="43afa187f9cf6582feca58fbbf7f12992daae6dc" translate="yes" xml:space="preserve">
          <source>The &lt;code id=&quot;the-automatically_derived-attribute&quot;&gt;automatically_derived&lt;/code&gt; attribute</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1ae32b9d596051c5f8a6c5be151de5b2bd58f3f8" translate="yes" xml:space="preserve">
          <source>The &lt;code id=&quot;the-c-representation&quot;&gt;C&lt;/code&gt; Representation</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bbe7f8f8cbbf771865519c2bb3d21bb5f521d891" translate="yes" xml:space="preserve">
          <source>The &lt;code id=&quot;the-cfg-attribute&quot;&gt;cfg&lt;/code&gt; attribute</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="572d131266eef7422234c8cd8f4bf975d532a1c7" translate="yes" xml:space="preserve">
          <source>The &lt;code id=&quot;the-cfg-macro&quot;&gt;cfg&lt;/code&gt; macro</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ff73ca7cbd9ceded9b08042dee3a7e44286d5879" translate="yes" xml:space="preserve">
          <source>The &lt;code id=&quot;the-cfg_attr-attribute&quot;&gt;cfg_attr&lt;/code&gt; attribute</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8ab454a301e64c91054b75436344fb463ed4e31a" translate="yes" xml:space="preserve">
          <source>The &lt;code id=&quot;the-cold-attribute&quot;&gt;cold&lt;/code&gt; attribute</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f3918f7c748b8a6de02591e90a158be55e179161" translate="yes" xml:space="preserve">
          <source>The &lt;code id=&quot;the-crate_name-attribute&quot;&gt;crate_name&lt;/code&gt; attribute</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="56779e684809e370ff842b9fd00e8e8533305b15" translate="yes" xml:space="preserve">
          <source>The &lt;code id=&quot;the-deprecated-attribute&quot;&gt;deprecated&lt;/code&gt; attribute</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d264c9c886b4e7e93efe14011caf84a4cb0f8edc" translate="yes" xml:space="preserve">
          <source>The &lt;code id=&quot;the-export_name-attribute&quot;&gt;export_name&lt;/code&gt; attribute</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="64953382ec25ebff3523c686f871b6cac0e50ffe" translate="yes" xml:space="preserve">
          <source>The &lt;code id=&quot;the-global_allocator-attribute&quot;&gt;global_allocator&lt;/code&gt; attribute</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="71beea8a8240cee1b864ee8a097da9cb395a0451" translate="yes" xml:space="preserve">
          <source>The &lt;code id=&quot;the-ignore-attribute&quot;&gt;ignore&lt;/code&gt; attribute</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d4e444fdfbdbbdaea724f409a0908c1ddaf47280" translate="yes" xml:space="preserve">
          <source>The &lt;code id=&quot;the-inline-attribute&quot;&gt;inline&lt;/code&gt; attribute</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="46f91b9733dfb285998974fd7a3ed63a6997485d" translate="yes" xml:space="preserve">
          <source>The &lt;code id=&quot;the-iterator-trait-and-the-next-method&quot;&gt;Iterator&lt;/code&gt; Trait and the &lt;code&gt;next&lt;/code&gt; Method</source>
          <target state="translated">&lt;code id=&quot;the-iterator-trait-and-the-next-method&quot;&gt;Iterator&lt;/code&gt; Тре и &lt;code&gt;next&lt;/code&gt; метод</target>
        </trans-unit>
        <trans-unit id="289229034807d95c3121d3bcf9cb7e25c1ac9ef2" translate="yes" xml:space="preserve">
          <source>The &lt;code id=&quot;the-link-attribute&quot;&gt;link&lt;/code&gt; attribute</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7cf19b8ac8c37c88b76bf5924f5303e2d1b3cbfc" translate="yes" xml:space="preserve">
          <source>The &lt;code id=&quot;the-link_name-attribute&quot;&gt;link_name&lt;/code&gt; attribute</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7fca57741dda84795b52faabc81edaee2bb29077" translate="yes" xml:space="preserve">
          <source>The &lt;code id=&quot;the-link_section-attribute&quot;&gt;link_section&lt;/code&gt; attribute</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7b8b70af9354cb75b7660a9b63a471bca4708883" translate="yes" xml:space="preserve">
          <source>The &lt;code id=&quot;the-macro_use-attribute&quot;&gt;macro_use&lt;/code&gt; attribute</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="479b4a692bc6c43f38d4737f51dec06b4e143a16" translate="yes" xml:space="preserve">
          <source>The &lt;code id=&quot;the-match-control-flow-operator&quot;&gt;match&lt;/code&gt; Control Flow Operator</source>
          <target state="translated">&lt;code id=&quot;the-match-control-flow-operator&quot;&gt;match&lt;/code&gt; Оператор Flow Control</target>
        </trans-unit>
        <trans-unit id="3764cbd865c70d966aece7af300dfa7f637fe423" translate="yes" xml:space="preserve">
          <source>The &lt;code id=&quot;the-must_use-attribute&quot;&gt;must_use&lt;/code&gt; attribute</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="32f1e16c1f0bc3e100253f9a6db177a6d4101ff1" translate="yes" xml:space="preserve">
          <source>The &lt;code id=&quot;the-no_builtins-attribute&quot;&gt;no_builtins&lt;/code&gt; attribute</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bc45c323650c2f34949e4b642c8e1bc1d4214794" translate="yes" xml:space="preserve">
          <source>The &lt;code id=&quot;the-no_link-attribute&quot;&gt;no_link&lt;/code&gt; attribute</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e12971ae998085805bad575f162d256452bcc1e0" translate="yes" xml:space="preserve">
          <source>The &lt;code id=&quot;the-no_main-attribute&quot;&gt;no_main&lt;/code&gt; attribute</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0f55be277b4754e64848202241f85fe626641b3d" translate="yes" xml:space="preserve">
          <source>The &lt;code id=&quot;the-no_mangle-attribute&quot;&gt;no_mangle&lt;/code&gt; attribute</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5417fc07a4925f25ebbeb5f618a1275243378ced" translate="yes" xml:space="preserve">
          <source>The &lt;code id=&quot;the-option-enum-and-its-advantages-over-null-values&quot;&gt;Option&lt;/code&gt; Enum and Its Advantages Over Null Values</source>
          <target state="translated">&lt;code id=&quot;the-option-enum-and-its-advantages-over-null-values&quot;&gt;Option&lt;/code&gt; Enum и его преимущества по сравнению с неопределенными значениями</target>
        </trans-unit>
        <trans-unit id="456d9c623e0db72560e9d4ff7d18d6a3d51bb4a0" translate="yes" xml:space="preserve">
          <source>The &lt;code id=&quot;the-panic_handler-attribute&quot;&gt;panic_handler&lt;/code&gt; attribute</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f6f2fa5a516f880089540c2827decd01d5a6e7d2" translate="yes" xml:space="preserve">
          <source>The &lt;code id=&quot;the-path-attribute&quot;&gt;path&lt;/code&gt; attribute</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="272c0059788508ea23a5913dedfc781999a4329c" translate="yes" xml:space="preserve">
          <source>The &lt;code id=&quot;the-proc_macro-crate&quot;&gt;proc_macro&lt;/code&gt; crate</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b1850ba5995c1ec62eca62cf6b54da74c57b2f08" translate="yes" xml:space="preserve">
          <source>The &lt;code id=&quot;the-recursion_limit-attribute&quot;&gt;recursion_limit&lt;/code&gt; attribute</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b7debe8457b97e78697481f2ab2a13b2dce10763" translate="yes" xml:space="preserve">
          <source>The &lt;code id=&quot;the-should_panic-attribute&quot;&gt;should_panic&lt;/code&gt; attribute</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="93213a38ad3b67a68894b916ca83c68efaaa5823" translate="yes" xml:space="preserve">
          <source>The &lt;code id=&quot;the-string-type&quot;&gt;String&lt;/code&gt; Type</source>
          <target state="translated">&lt;code id=&quot;the-string-type&quot;&gt;String&lt;/code&gt; Тип</target>
        </trans-unit>
        <trans-unit id="1fa123d3091c3f529b13b66733146b6cc074b9ee" translate="yes" xml:space="preserve">
          <source>The &lt;code id=&quot;the-target_feature-attribute&quot;&gt;target_feature&lt;/code&gt; attribute</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8ec1dda37a4f697fee6a707ed0b667ec2bc1a23e" translate="yes" xml:space="preserve">
          <source>The &lt;code id=&quot;the-test-attribute&quot;&gt;test&lt;/code&gt; attribute</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cf59ceebdbbaa090bce70ec65f673058503cd1c7" translate="yes" xml:space="preserve">
          <source>The &lt;code id=&quot;the-track_caller-attribute&quot;&gt;track_caller&lt;/code&gt; attribute</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3ad072e3ed2e5bdacb782947af3c6085d2383d5f" translate="yes" xml:space="preserve">
          <source>The &lt;code id=&quot;the-transparent-representation&quot;&gt;transparent&lt;/code&gt; Representation</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="222c253464f70dc2d46508fef9bded38b979180e" translate="yes" xml:space="preserve">
          <source>The &lt;code id=&quot;the-type_length_limit-attribute&quot;&gt;type_length_limit&lt;/code&gt; attribute</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b350e27ebb9ddb5535abd7bc5f0b158500f6c7ea" translate="yes" xml:space="preserve">
          <source>The &lt;code id=&quot;the-used-attribute&quot;&gt;used&lt;/code&gt; attribute</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d7b55666424bcbda4791627f5d3c1a25c9fd2797" translate="yes" xml:space="preserve">
          <source>The &lt;code id=&quot;the-windows_subsystem-attribute&quot;&gt;windows_subsystem&lt;/code&gt; attribute</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="844971eb58988950f234035bf3b738d18df15983" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;!&lt;/code&gt; type, also called &quot;never&quot;.</source>
          <target state="translated">&lt;code&gt;!&lt;/code&gt; тип, также называемый &amp;laquo;никогда&amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="1959101a4f878a742e6d622df58125da3c9ee8ba" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;#![feature]&lt;/code&gt; attribute specified an unknown feature.</source>
          <target state="translated">&lt;code&gt;#![feature]&lt;/code&gt; атрибут указан неизвестная особенность.</target>
        </trans-unit>
        <trans-unit id="6772d2ae0b060a250746d33cd174746c466f1400" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;#[cfg(test)]&lt;/code&gt; annotation on the tests module tells Rust to compile and run the test code only when you run &lt;code&gt;cargo test&lt;/code&gt;, not when you run &lt;code&gt;cargo build&lt;/code&gt;. This saves compile time when you only want to build the library and saves space in the resulting compiled artifact because the tests are not included. You&amp;rsquo;ll see that because integration tests go in a different directory, they don&amp;rsquo;t need the &lt;code&gt;#[cfg(test)]&lt;/code&gt; annotation. However, because unit tests go in the same files as the code, you&amp;rsquo;ll use &lt;code&gt;#[cfg(test)]&lt;/code&gt; to specify that they shouldn&amp;rsquo;t be included in the compiled result.</source>
          <target state="translated">&lt;code&gt;#[cfg(test)]&lt;/code&gt; аннотация на модуле тестов говорит Rust , чтобы скомпилировать и запустить тестовый код только при выполнении &lt;code&gt;cargo test&lt;/code&gt; , а не при запуске &lt;code&gt;cargo build&lt;/code&gt; . Это экономит время компиляции, когда вы хотите только построить библиотеку, и экономит место в результирующем скомпилированном артефакте, поскольку тесты не включены. Вы увидите, что, поскольку интеграционные тесты находятся в другом каталоге, аннотация &lt;code&gt;#[cfg(test)]&lt;/code&gt; им не нужна . Однако, поскольку модульные тесты находятся в тех же файлах, что и код, вы используете &lt;code&gt;#[cfg(test)]&lt;/code&gt; чтобы указать, что они не должны включаться в скомпилированный результат.</target>
        </trans-unit>
        <trans-unit id="519f31417527ab16777c33990a8b19270d90ed97" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;#[global_allocator]&lt;/code&gt; attribute</source>
          <target state="translated">&lt;code&gt;#[global_allocator]&lt;/code&gt; атрибут</target>
        </trans-unit>
        <trans-unit id="e73c0e75e8ab048b307c0488b5dbff0af69bd767" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;#[global_allocator]&lt;/code&gt; can only be used once in a crate or its recursive dependencies.</source>
          <target state="translated">&lt;code&gt;#[global_allocator]&lt;/code&gt; может быть использован только один раз в обрешетке или его рекурсивных зависимостей.</target>
        </trans-unit>
        <trans-unit id="672159bbb94aa0ec135859c99523eca0ebc397f9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;#[macro_export]&lt;/code&gt; annotation indicates that this macro should be made available whenever the crate in which the macro is defined is brought into scope. Without this annotation, the macro can&amp;rsquo;t be brought into scope.</source>
          <target state="translated">&lt;code&gt;#[macro_export]&lt;/code&gt; аннотации указывает на то, что этот макрос должен быть доступен всякий раз , когда щик , в котором определен макрос вводится в рамки. Без этой аннотации макрос не может быть включен в область видимости.</target>
        </trans-unit>
        <trans-unit id="859ec264725730980afa9483dd83d3f313613cc7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;#[repr(C)]&lt;/code&gt; attribute can only be placed on structs and enums.</source>
          <target state="translated">&lt;code&gt;#[repr(C)]&lt;/code&gt; атрибут может быть размещен только на перечислениях и структуры.</target>
        </trans-unit>
        <trans-unit id="20ce08781d178cc7ecc1d0ee2405f13954a27792" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;#[repr(packed)]&lt;/code&gt; and &lt;code&gt;#[repr(simd)]&lt;/code&gt; attributes only work on structs.</source>
          <target state="translated">&lt;code&gt;#[repr(packed)]&lt;/code&gt; и &lt;code&gt;#[repr(simd)]&lt;/code&gt; атрибуты работы только на структурах.</target>
        </trans-unit>
        <trans-unit id="37e64d7cdeff0fe84feb89e7cacb8aa07bcc4dd2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;#[repr(u8)]&lt;/code&gt;, &lt;code&gt;#[repr(i16)]&lt;/code&gt;, etc attributes only work on enums.</source>
          <target state="translated">&lt;code&gt;#[repr(u8)]&lt;/code&gt; , &lt;code&gt;#[repr(i16)]&lt;/code&gt; , и т.д. атрибуты работают только на перечислениях.</target>
        </trans-unit>
        <trans-unit id="c9b512964c382c5f5d5e0080e7203c876528ceb6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;#[rustc_on_unimplemented]&lt;/code&gt; attribute lets you specify a custom error message for when a particular trait isn't implemented on a type placed in a position that needs that trait. For example, when the following code is compiled:</source>
          <target state="translated">&lt;code&gt;#[rustc_on_unimplemented]&lt;/code&gt; атрибут позволяет указать сообщение об ошибке пользовательской для того, когда конкретная черта не реализована типа , помещенном в положении, потребность, черта. Например, при компиляции следующего кода:</target>
        </trans-unit>
        <trans-unit id="910d7829ddf09eb2fc4a2ff115280a7e351c19be" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;#[simd]&lt;/code&gt; attribute can only be applied to non empty tuple structs, because it doesn't make sense to try to use SIMD operations when there are no values to operate on.</source>
          <target state="translated">&lt;code&gt;#[simd]&lt;/code&gt; атрибут может быть применен только к не пустой кортеж структур, потому что это не имеет смысла пытаться использовать операции SIMD , когда есть значения не надо работать.</target>
        </trans-unit>
        <trans-unit id="20a3879322df478a4cc556128e471d1c66adae12" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;#[unwind]&lt;/code&gt; attribute should be used as follows:</source>
          <target state="translated">&lt;code&gt;#[unwind]&lt;/code&gt; атрибут должен использоваться следующим образом :</target>
        </trans-unit>
        <trans-unit id="98359d44655df527d34cb1e33db3c37a01e294d0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&amp;amp;&lt;/code&gt; (shared borrow) and &lt;code&gt;&amp;amp;mut&lt;/code&gt; (mutable borrow) operators are unary prefix operators. When applied to a &lt;a href=&quot;../expressions#place-expressions-and-value-expressions&quot;&gt;place expression&lt;/a&gt;, this expressions produces a reference (pointer) to the location that the value refers to. The memory location is also placed into a borrowed state for the duration of the reference. For a shared borrow (&lt;code&gt;&amp;amp;&lt;/code&gt;), this implies that the place may not be mutated, but it may be read or shared again. For a mutable borrow (&lt;code&gt;&amp;amp;mut&lt;/code&gt;), the place may not be accessed in any way until the borrow expires. &lt;code&gt;&amp;amp;mut&lt;/code&gt; evaluates its operand in a mutable place expression context. If the &lt;code&gt;&amp;amp;&lt;/code&gt; or &lt;code&gt;&amp;amp;mut&lt;/code&gt; operators are applied to a &lt;a href=&quot;../expressions#place-expressions-and-value-expressions&quot;&gt;value expression&lt;/a&gt;, then a &lt;a href=&quot;../expressions#temporaries&quot;&gt;temporary value&lt;/a&gt; is created.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6e0afa92240bade4867a8d2b0fc7bc387cff228f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&amp;amp;&lt;/code&gt; (shared borrow) and &lt;code&gt;&amp;amp;mut&lt;/code&gt; (mutable borrow) operators are unary prefix operators. When applied to a &lt;a href=&quot;../expressions#place-expressions-and-value-expressions&quot;&gt;place expression&lt;/a&gt;, this expressions produces a reference (pointer) to the location that the value refers to. The memory location is also placed into a borrowed state for the duration of the reference. For a shared borrow (&lt;code&gt;&amp;amp;&lt;/code&gt;), this implies that the place may not be mutated, but it may be read or shared again. For a mutable borrow (&lt;code&gt;&amp;amp;mut&lt;/code&gt;), the place may not be accessed in any way until the borrow expires. &lt;code&gt;&amp;amp;mut&lt;/code&gt; evaluates its operand in a mutable place expression context. If the &lt;code&gt;&amp;amp;&lt;/code&gt; or &lt;code&gt;&amp;amp;mut&lt;/code&gt; operators are applied to a &lt;a href=&quot;../expressions#place-expressions-and-value-expressions&quot;&gt;value expression&lt;/a&gt;, then a &lt;a href=&quot;../expressions#temporary-lifetimes&quot;&gt;temporary value&lt;/a&gt; is created.</source>
          <target state="translated">Операторы &lt;code&gt;&amp;amp;&lt;/code&gt; (общее заимствование) и &lt;code&gt;&amp;amp;mut&lt;/code&gt; (изменяемое заимствование) являются унарными префиксными операторами. При применении к &lt;a href=&quot;../expressions#place-expressions-and-value-expressions&quot;&gt;выражению места&lt;/a&gt; это выражение создает ссылку (указатель) на место, к которому относится значение. Ячейка памяти также переводится в заимствованное состояние на время обращения. Для общего заимствования ( &lt;code&gt;&amp;amp;&lt;/code&gt; ) это означает, что место не может быть изменено, но его можно прочитать или поделиться снова. Для изменяемого заимствования ( &lt;code&gt;&amp;amp;mut&lt;/code&gt; ) к этому месту нельзя получить доступ, пока не истечет срок заимствования. &lt;code&gt;&amp;amp;mut&lt;/code&gt; вычисляет свой операнд в контексте изменяемого выражения места. Если операторы &lt;code&gt;&amp;amp;&lt;/code&gt; или &lt;code&gt;&amp;amp;mut&lt;/code&gt; применяются к&lt;a href=&quot;../expressions#place-expressions-and-value-expressions&quot;&gt;значение выражения&lt;/a&gt; , то создается &lt;a href=&quot;../expressions#temporary-lifetimes&quot;&gt;временное значение&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="289f7ac6e65862e6021cefdfd8637885846add32" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&amp;amp;&lt;/code&gt; indicates that this argument is a &lt;em&gt;reference&lt;/em&gt;, which gives you a way to let multiple parts of your code access one piece of data without needing to copy that data into memory multiple times. References are a complex feature, and one of Rust&amp;rsquo;s major advantages is how safe and easy it is to use references. You don&amp;rsquo;t need to know a lot of those details to finish this program. For now, all you need to know is that like variables, references are immutable by default. Hence, you need to write &lt;code&gt;&amp;amp;mut guess&lt;/code&gt; rather than &lt;code&gt;&amp;amp;guess&lt;/code&gt; to make it mutable. (Chapter 4 will explain references more thoroughly.)</source>
          <target state="translated">&lt;code&gt;&amp;amp;&lt;/code&gt; указывает на то, что этот аргумент является &lt;em&gt;ссылкой&lt;/em&gt; , которая дает вам способ , чтобы несколько частей вашего кода доступа одной части данных без необходимости копировать эти данные в памяти несколько раз. Ссылки - это сложная функция, и одним из основных преимуществ Rust является то, насколько безопасно и легко использовать ссылки. Вам не нужно знать много этих деталей, чтобы закончить эту программу. На данный момент все, что вам нужно знать, это то, что, как и переменные, ссылки по умолчанию неизменяемы. Следовательно, вам нужно написать &lt;code&gt;&amp;amp;mut guess&lt;/code&gt; а не &lt;code&gt;&amp;amp;guess&lt;/code&gt; чтобы сделать его изменяемым. (В главе 4 ссылки будут объяснены более подробно.)</target>
        </trans-unit>
        <trans-unit id="0ba71ec6a87d61177d25877a820fc83d9405b11e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&amp;amp;s1&lt;/code&gt; syntax lets us create a reference that &lt;em&gt;refers&lt;/em&gt; to the value of &lt;code&gt;s1&lt;/code&gt; but does not own it. Because it does not own it, the value it points to will not be dropped when the reference goes out of scope.</source>
          <target state="translated">&lt;code&gt;&amp;amp;s1&lt;/code&gt; синтаксис позволяет нам создать ссылку , которая &lt;em&gt;ссылается&lt;/em&gt; на значение &lt;code&gt;s1&lt;/code&gt; , но не владеет. Поскольку он не принадлежит ему, значение, на которое он указывает, не будет удалено, когда ссылка выйдет за пределы области видимости.</target>
        </trans-unit>
        <trans-unit id="ac2092b7195c0e20492c6630d5e4fa162bb49bf5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&amp;amp;str&lt;/code&gt; type guarantees that its contents are UTF-8, and so we can compare the length it would take if each code point was represented as a &lt;code&gt;char&lt;/code&gt; vs in the &lt;code&gt;&amp;amp;str&lt;/code&gt; itself:</source>
          <target state="translated">Тип &lt;code&gt;&amp;amp;str&lt;/code&gt; гарантирует, что его содержимое является UTF-8, и поэтому мы можем сравнить длину, которую он занял бы, если бы каждая кодовая точка была представлена ​​как &lt;code&gt;char&lt;/code&gt; vs в самом &lt;code&gt;&amp;amp;str&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="9573f9c210e855e348b2b66cefde61b52fa3eea1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&amp;amp;str&lt;/code&gt; type is one of the two main string types, the other being &lt;code&gt;String&lt;/code&gt;. Unlike its &lt;code&gt;String&lt;/code&gt; counterpart, its contents are borrowed.</source>
          <target state="translated">Тип &lt;code&gt;&amp;amp;str&lt;/code&gt; - это один из двух основных строковых типов, второй - &lt;code&gt;String&lt;/code&gt; . В отличие от своего аналога &lt;code&gt;String&lt;/code&gt; , его содержимое заимствовано.</target>
        </trans-unit>
        <trans-unit id="9dd45416e37868ecd085972d08ce3b564e5e5995" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&amp;gt;&lt;/code&gt; syntax tells the shell to write the contents of standard output to &lt;em&gt;output.txt&lt;/em&gt; instead of the screen. We didn&amp;rsquo;t see the error message we were expecting printed to the screen, so that means it must have ended up in the file. This is what &lt;em&gt;output.txt&lt;/em&gt; contains:</source>
          <target state="translated">&lt;code&gt;&amp;gt;&lt;/code&gt; Синтаксис говорит оболочке , чтобы записать содержимое стандартного вывода в &lt;em&gt;output.txt&lt;/em&gt; вместо экрана. Мы не увидели ожидаемого сообщения об ошибке на экране, значит, оно должно было оказаться в файле. Вот что содержит &lt;em&gt;output.txt&lt;/em&gt; :</target>
        </trans-unit>
        <trans-unit id="b005addd17171fe396053ec0c62812c2c97cade4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&amp;lt;T&amp;gt;&lt;/code&gt; syntax is a feature of Rust we haven&amp;rsquo;t talked about yet. It&amp;rsquo;s a generic type parameter, and we&amp;rsquo;ll cover generics in more detail in Chapter 10. For now, all you need to know is that &lt;code&gt;&amp;lt;T&amp;gt;&lt;/code&gt; means the &lt;code&gt;Some&lt;/code&gt; variant of the &lt;code&gt;Option&lt;/code&gt; enum can hold one piece of data of any type. Here are some examples of using &lt;code&gt;Option&lt;/code&gt; values to hold number types and string types:</source>
          <target state="translated">&lt;code&gt;&amp;lt;T&amp;gt;&lt;/code&gt; синтаксис является особенностью Rust мы не говорили о том же. Это параметр универсального типа, и мы рассмотрим его более подробно в главе 10. На данный момент все, что вам нужно знать, это то, что &lt;code&gt;&amp;lt;T&amp;gt;&lt;/code&gt; означает, что вариант &lt;code&gt;Some&lt;/code&gt; из перечисления &lt;code&gt;Option&lt;/code&gt; может содержать один фрагмент данных любого типа. Вот несколько примеров использования значений &lt;code&gt;Option&lt;/code&gt; для хранения числовых и строковых типов:</target>
        </trans-unit>
        <trans-unit id="0e8f2a70b6f25c55e2febf941fcc1166aa49e75b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;'static&lt;/code&gt; constraint means that the closure and its return value must have a lifetime of the whole program execution. The reason for this is that threads can &lt;code&gt;detach&lt;/code&gt; and outlive the lifetime they have been created in. Indeed if the thread, and by extension its return value, can outlive their caller, we need to make sure that they will be valid afterwards, and since we &lt;em&gt;can't&lt;/em&gt; know when it will return we need to have them valid as long as possible, that is until the end of the program, hence the &lt;code&gt;'static&lt;/code&gt; lifetime.</source>
          <target state="translated">В &lt;code&gt;'static&lt;/code&gt; средствах ограничений , что закрытие и его возвращаемое значение должны иметь срок службы всего исполнения программы. Причина этого в том, что потоки могут &lt;code&gt;detach&lt;/code&gt; и переживать время жизни, в котором они были созданы. Действительно, если поток и, соответственно, его возвращаемое значение может пережить вызывающего, нам нужно убедиться, что они будут действительными впоследствии, и поскольку мы &lt;em&gt;не можем&lt;/em&gt; знать, когда он вернется, нам нужно, чтобы они действовали как можно дольше, то есть до конца программы, отсюда и &lt;code&gt;'static&lt;/code&gt; время жизни&amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="d507c32a06112cec989a75204d96602b968865dd" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;()&lt;/code&gt; type has exactly one value &lt;code&gt;()&lt;/code&gt;, and is used when there is no other meaningful value that could be returned. &lt;code&gt;()&lt;/code&gt; is most commonly seen implicitly: functions without a &lt;code&gt;-&amp;gt; ...&lt;/code&gt; implicitly have return type &lt;code&gt;()&lt;/code&gt;, that is, these are equivalent:</source>
          <target state="translated">Тип &lt;code&gt;()&lt;/code&gt; имеет ровно одно значение &lt;code&gt;()&lt;/code&gt; и используется, когда нет другого значимого значения, которое можно было бы вернуть. &lt;code&gt;()&lt;/code&gt; чаще всего встречается неявно: функции без &lt;code&gt;-&amp;gt; ...&lt;/code&gt; неявно имеют возвращаемый тип &lt;code&gt;()&lt;/code&gt; , то есть они эквивалентны:</target>
        </trans-unit>
        <trans-unit id="e3861dba93432d9d5236ce5338f7751eb3d446a6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;()&lt;/code&gt; type, also called &quot;unit&quot;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ad7f39bcbd9c29a0b11698eda466dd66f20fff6f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;()&lt;/code&gt; type, sometimes called &quot;unit&quot; or &quot;nil&quot;.</source>
          <target state="translated">Тип &lt;code&gt;()&lt;/code&gt; , иногда называемый &amp;laquo;единицей&amp;raquo; или &amp;laquo;ноль&amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="918cd095e0c314aaf612bef93955c593d22df666" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;(*m)&lt;/code&gt; dereferences the &lt;code&gt;MyBox&amp;lt;String&amp;gt;&lt;/code&gt; into a &lt;code&gt;String&lt;/code&gt;. Then the &lt;code&gt;&amp;amp;&lt;/code&gt; and &lt;code&gt;[..]&lt;/code&gt; take a string slice of the &lt;code&gt;String&lt;/code&gt; that is equal to the whole string to match the signature of &lt;code&gt;hello&lt;/code&gt;. The code without deref coercions is harder to read, write, and understand with all of these symbols involved. Deref coercion allows Rust to handle these conversions for us automatically.</source>
          <target state="translated">&lt;code&gt;(*m)&lt;/code&gt; разыменовывает &lt;code&gt;MyBox&amp;lt;String&amp;gt;&lt;/code&gt; в &lt;code&gt;String&lt;/code&gt; . Затем &lt;code&gt;&amp;amp;&lt;/code&gt; и &lt;code&gt;[..]&lt;/code&gt; берут отрезок &lt;code&gt;String&lt;/code&gt; который равен всей строке, чтобы соответствовать подписи &lt;code&gt;hello&lt;/code&gt; . Код без приведения deref сложнее читать, писать и понимать со всеми этими задействованными символами. Принуждение Deref позволяет Rust автоматически обрабатывать эти преобразования.</target>
        </trans-unit>
        <trans-unit id="dceab58b2710b9293ff102afe19580771458da84" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;*&lt;/code&gt; (dereference) operator is also a unary prefix operator. When applied to a &lt;a href=&quot;../types/pointer&quot;&gt;pointer&lt;/a&gt; it denotes the pointed-to location. If the expression is of type &lt;code&gt;&amp;amp;mut T&lt;/code&gt; and &lt;code&gt;*mut T&lt;/code&gt;, and is either a local variable, a (nested) field of a local variable or is a mutable &lt;a href=&quot;../expressions#place-expressions-and-value-expressions&quot;&gt;place expression&lt;/a&gt;, then the resulting memory location can be assigned to. Dereferencing a raw pointer requires &lt;code&gt;unsafe&lt;/code&gt;.</source>
          <target state="translated">Оператор &lt;code&gt;*&lt;/code&gt; (разыменование) также является унарным префиксным оператором. При применении к &lt;a href=&quot;../types/pointer&quot;&gt;указателю&lt;/a&gt; он обозначает указанное местоположение. Если выражение имеет тип &lt;code&gt;&amp;amp;mut T&lt;/code&gt; и &lt;code&gt;*mut T&lt;/code&gt; , и является либо локальной переменной, (вложенным) полем локальной переменной, либо изменяемым &lt;a href=&quot;../expressions#place-expressions-and-value-expressions&quot;&gt;выражением места&lt;/a&gt; , то результирующая ячейка памяти может быть назначена. Разыменование необработанного указателя требует &lt;code&gt;unsafe&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9081a0fc77deca2ae1677facd10e7e74970f88a4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;+&lt;/code&gt; syntax is also valid with trait bounds on generic types:</source>
          <target state="translated">&lt;code&gt;+&lt;/code&gt; Синтаксис также действует с ограничениями на признаке родовых типов:</target>
        </trans-unit>
        <trans-unit id="afa4c918a009f5cfb91d99e9fea97354edfccd19" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;+&lt;/code&gt; type operator was used in an ambiguous context.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cf7d56124b7814800cfa939450d0c6d38a399da8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;+&lt;/code&gt;, &lt;code&gt;-&lt;/code&gt;, &lt;code&gt;*&lt;/code&gt;, &lt;code&gt;/&lt;/code&gt;, &lt;code&gt;%&lt;/code&gt;, &lt;code&gt;&amp;amp;&lt;/code&gt;, &lt;code&gt;|&lt;/code&gt;, &lt;code&gt;^&lt;/code&gt;, &lt;code&gt;&amp;lt;&amp;lt;&lt;/code&gt;, and &lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt; operators may be composed with the &lt;code&gt;=&lt;/code&gt; operator. The expression &lt;code&gt;place_exp OP= value&lt;/code&gt; is equivalent to &lt;code&gt;place_expr = place_expr OP val&lt;/code&gt;. For example, &lt;code&gt;x = x + 1&lt;/code&gt; may be written as &lt;code&gt;x += 1&lt;/code&gt;. Any such expression always has the &lt;a href=&quot;../types/tuple&quot;&gt;&lt;code&gt;unit&lt;/code&gt; type&lt;/a&gt;. These operators can all be overloaded using the trait with the same name as for the normal operation followed by 'Assign', for example, &lt;code&gt;std::ops::AddAssign&lt;/code&gt; is used to overload &lt;code&gt;+=&lt;/code&gt;. As with &lt;code&gt;=&lt;/code&gt;, &lt;code&gt;place_expr&lt;/code&gt; must be a &lt;a href=&quot;../expressions#place-expressions-and-value-expressions&quot;&gt;place expression&lt;/a&gt;.</source>
          <target state="translated">Знаки &lt;code&gt;+&lt;/code&gt; , &lt;code&gt;-&lt;/code&gt; , &lt;code&gt;*&lt;/code&gt; , &lt;code&gt;/&lt;/code&gt; , &lt;code&gt;%&lt;/code&gt; , &lt;code&gt;&amp;amp;&lt;/code&gt; , &lt;code&gt;|&lt;/code&gt; Операторы , &lt;code&gt;^&lt;/code&gt; , &lt;code&gt;&amp;lt;&amp;lt;&lt;/code&gt; и &lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt; могут быть составлены с помощью оператора &lt;code&gt;=&lt;/code&gt; . Выражение &lt;code&gt;place_exp OP= value&lt;/code&gt; эквивалентно &lt;code&gt;place_expr = place_expr OP val&lt;/code&gt; . Например, &lt;code&gt;x = x + 1&lt;/code&gt; можно записать как &lt;code&gt;x += 1&lt;/code&gt; . Любое такое выражение всегда имеет &lt;a href=&quot;../types/tuple&quot;&gt; &lt;code&gt;unit&lt;/code&gt; тип&lt;/a&gt; . Все эти операторы могут быть перегружены с помощью признака с тем же именем, что и для обычной операции, за которой следует 'Assign', например &lt;code&gt;std::ops::AddAssign&lt;/code&gt; используется для перегрузки &lt;code&gt;+=&lt;/code&gt; . Как и в случае с &lt;code&gt;=&lt;/code&gt; , &lt;code&gt;place_expr&lt;/code&gt; должен быть &lt;a href=&quot;../expressions#place-expressions-and-value-expressions&quot;&gt;выражением места&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="a770a23638a823405304b5862ae9b043051acefe" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;-3&lt;/code&gt; is no longer there, because it was consumed in order to see if the iteration should stop, but wasn't placed back into the iterator.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8565fcc01087bd00c830a709f76c89a8bec0ee11" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;...&lt;/code&gt; syntax allows us to match to an inclusive range of values. In the following code, when a pattern matches any of the values within the range, that arm will execute:</source>
          <target state="translated">&lt;code&gt;...&lt;/code&gt; синтаксис позволяет нам соответствовать к инклюзивному диапазону значений. В следующем коде, когда шаблон соответствует любому из значений в диапазоне, эта рука будет выполняться:</target>
        </trans-unit>
        <trans-unit id="a4afeb6b704f2eeee4511dc907c8b58744889e53" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;...&lt;/code&gt; syntax is kept for backwards compatibility.</source>
          <target state="translated">&lt;code&gt;...&lt;/code&gt; синтаксис поддерживается для обратной совместимости.</target>
        </trans-unit>
        <trans-unit id="e2e1f03ffc70a6a254885658fe3c94afc796ca12" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;..&lt;/code&gt; and &lt;code&gt;..=&lt;/code&gt; operators will construct an object of one of the &lt;code&gt;std::ops::Range&lt;/code&gt; (or &lt;code&gt;core::ops::Range&lt;/code&gt;) variants, according to the following table:</source>
          <target state="translated">Операторы &lt;code&gt;..&lt;/code&gt; и &lt;code&gt;..=&lt;/code&gt; создают объект одного из вариантов &lt;code&gt;std::ops::Range&lt;/code&gt; (или &lt;code&gt;core::ops::Range&lt;/code&gt; ) в соответствии со следующей таблицей:</target>
        </trans-unit>
        <trans-unit id="92e96dedbdbf92f3e2e6464ed4a171437558a608" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;..&lt;/code&gt; syntax is a &lt;code&gt;RangeFull&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;..&lt;/code&gt; синтаксис является &lt;code&gt;RangeFull&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="e498b96e1f982900a97ac68d2121f886fa57f814" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;..=&lt;/code&gt; syntax allows us to match to an inclusive range of values. In the following code, when a pattern matches any of the values within the range, that arm will execute:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fc028c330bc0f9500e9f59b98e8ba94a546679b2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;..=end&lt;/code&gt; syntax is a &lt;code&gt;RangeToInclusive&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;..=end&lt;/code&gt; синтаксис является &lt;code&gt;RangeToInclusive&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="06bff2e76574f65224a2d8263399ed02a85a5a5f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;..end&lt;/code&gt; syntax is a &lt;code&gt;RangeTo&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;..end&lt;/code&gt; синтаксис является &lt;code&gt;RangeTo&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="e2942c55d614162c6590171ee52a6786d9039b19" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;0 measured&lt;/code&gt; statistic is for benchmark tests that measure performance. Benchmark tests are, as of this writing, only available in nightly Rust. See &lt;a href=&quot;https://doc.rust-lang.org/unstable-book/library-features/test.html&quot;&gt;the documentation about benchmark tests&lt;/a&gt; to learn more.</source>
          <target state="translated">&lt;code&gt;0 measured&lt;/code&gt; статистика для эталонных тестов , что производительность измерения. На момент написания этой статьи тесты производительности доступны только в ночном Rust. См. &lt;a href=&quot;https://doc.rust-lang.org/unstable-book/library-features/test.html&quot;&gt;Документацию о тестах производительности,&lt;/a&gt; чтобы узнать больше.</target>
        </trans-unit>
        <trans-unit id="79584c510d0bdac6b79741ca275d743c77143fc8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;3&lt;/code&gt; is no longer there, because it was consumed in order to see if the iteration should stop, but wasn't placed back into the iterator.</source>
          <target state="translated">Цифры &lt;code&gt;3&lt;/code&gt; больше нет, потому что она была использована, чтобы увидеть, следует ли остановить итерацию, но не была возвращена в итератор.</target>
        </trans-unit>
        <trans-unit id="e721998eb3ac8ff36164c3da054ad164e33f55c4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;5&lt;/code&gt; in &lt;code&gt;five&lt;/code&gt; is the function&amp;rsquo;s return value, which is why the return type is &lt;code&gt;i32&lt;/code&gt;. Let&amp;rsquo;s examine this in more detail. There are two important bits: first, the line &lt;code&gt;let x = five();&lt;/code&gt; shows that we&amp;rsquo;re using the return value of a function to initialize a variable. Because the function &lt;code&gt;five&lt;/code&gt; returns a &lt;code&gt;5&lt;/code&gt;, that line is the same as the following:</source>
          <target state="translated">&lt;code&gt;5&lt;/code&gt; в &lt;code&gt;five&lt;/code&gt; является возврат значения функции, поэтому тип возвращаемого значения &lt;code&gt;i32&lt;/code&gt; . Разберем это подробнее. Есть два важных бита: во-первых, строка &lt;code&gt;let x = five();&lt;/code&gt; показывает, что мы используем возвращаемое значение функции для инициализации переменной. Поскольку функция &lt;code&gt;five&lt;/code&gt; возвращает &lt;code&gt;5&lt;/code&gt; , эта строка такая же, как следующая:</target>
        </trans-unit>
        <trans-unit id="f64d85c43f38ffb1d9f69e7f8ec2961df3c8d6da" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;::&lt;/code&gt; syntax in the &lt;code&gt;::new&lt;/code&gt; line indicates that &lt;code&gt;new&lt;/code&gt; is an &lt;em&gt;associated function&lt;/em&gt; of the &lt;code&gt;String&lt;/code&gt; type. An associated function is implemented on a type, in this case &lt;code&gt;String&lt;/code&gt;, rather than on a particular instance of a &lt;code&gt;String&lt;/code&gt;. Some languages call this a &lt;em&gt;static method&lt;/em&gt;.</source>
          <target state="translated">&lt;code&gt;::&lt;/code&gt; синтаксическая &lt;code&gt;::new&lt;/code&gt; линии указывает на то, что &lt;code&gt;new&lt;/code&gt; является &lt;em&gt;присоединенная функция&lt;/em&gt; от &lt;code&gt;String&lt;/code&gt; типа. Связанная функция реализуется для типа, в данном случае &lt;code&gt;String&lt;/code&gt; , а не для конкретного экземпляра &lt;code&gt;String&lt;/code&gt; . В некоторых языках это называется &lt;em&gt;статическим методом&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="6c666ec2c7e67dbab00bbae26838dd52620a7c41" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;::&lt;/code&gt; token is required before the opening &lt;code&gt;&amp;lt;&lt;/code&gt; for generic arguments to avoid ambiguity with the less-than operator. This is colloquially known as &quot;turbofish&quot; syntax.</source>
          <target state="translated">&lt;code&gt;::&lt;/code&gt; лексема требуется до открытия &lt;code&gt;&amp;lt;&lt;/code&gt; для общих аргументов , чтобы избежать неоднозначности с менее чем оператором. Этот синтаксис в просторечии известен как &quot;турбофиш&quot;.</target>
        </trans-unit>
        <trans-unit id="973f4c6b5b84dfca6c5a6d4e2198053b9adfe1f2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;?&lt;/code&gt; operator can be used in functions that have a return type of &lt;code&gt;Result&lt;/code&gt;, because it is defined to work in the same way as the &lt;code&gt;match&lt;/code&gt; expression we defined in Listing 9-6. The part of the &lt;code&gt;match&lt;/code&gt; that requires a return type of &lt;code&gt;Result&lt;/code&gt; is &lt;code&gt;return Err(e)&lt;/code&gt;, so the return type of the function can be a &lt;code&gt;Result&lt;/code&gt; to be compatible with this &lt;code&gt;return&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0ec4c0c2491bd5a54898bf44aa756701f4e9b5fb" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;?&lt;/code&gt; operator can only be used in functions that have a return type of &lt;code&gt;Result&lt;/code&gt;, because it is defined to work in the same way as the &lt;code&gt;match&lt;/code&gt; expression we defined in Listing 9-6. The part of the &lt;code&gt;match&lt;/code&gt; that requires a return type of &lt;code&gt;Result&lt;/code&gt; is &lt;code&gt;return Err(e)&lt;/code&gt;, so the return type of the function must be a &lt;code&gt;Result&lt;/code&gt; to be compatible with this &lt;code&gt;return&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;?&lt;/code&gt; Оператор может быть использован только в функциях , которые имеют тип возвращаемого &lt;code&gt;Result&lt;/code&gt; , так как она определяется работать точно так же , как и &lt;code&gt;match&lt;/code&gt; выражения , которое мы определили в листинге 9-6. Часть &lt;code&gt;match&lt;/code&gt; которой требуется возвращаемый тип &lt;code&gt;Result&lt;/code&gt; , - это &lt;code&gt;return Err(e)&lt;/code&gt; , поэтому возвращаемый тип функции должен быть &lt;code&gt;Result&lt;/code&gt; , чтобы быть совместимым с этим &lt;code&gt;return&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="bd74ffef5a8c90c3fd4d6d76e29ea8086760c062" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;?&lt;/code&gt; operator eliminates a lot of boilerplate and makes this function&amp;rsquo;s implementation simpler. We could even shorten this code further by chaining method calls immediately after the &lt;code&gt;?&lt;/code&gt;, as shown in Listing 9-8.</source>
          <target state="translated">&lt;code&gt;?&lt;/code&gt; Оператор устраняет множество шаблонов и упрощает реализацию этой функции. Мы могли бы даже сократить этот код, связав вызовы методов сразу после &lt;code&gt;?&lt;/code&gt; , как показано в Листинге 9-8.</target>
        </trans-unit>
        <trans-unit id="69d45072228b4f483bc2426682521ed37346faf8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;?&lt;/code&gt; operator was added to replace &lt;code&gt;try!&lt;/code&gt; and should be used instead. Furthermore, &lt;code&gt;try&lt;/code&gt; is a reserved word in Rust 2018, so if you must use it, you will need to use the &lt;a href=&quot;https://doc.rust-lang.org/nightly/rust-by-example/compatibility/raw_identifiers.html&quot;&gt;raw-identifier syntax&lt;/a&gt;: &lt;code&gt;r#try&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;?&lt;/code&gt; Оператор был добавлен взамен &lt;code&gt;try!&lt;/code&gt; и следует использовать вместо этого. Кроме того, &lt;code&gt;try&lt;/code&gt; - зарезервированное слово в Rust 2018, поэтому, если вы должны его использовать, вам нужно будет использовать &lt;a href=&quot;https://doc.rust-lang.org/nightly/rust-by-example/compatibility/raw_identifiers.html&quot;&gt;синтаксис raw-идентификатора&lt;/a&gt; : &lt;code&gt;r#try&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c02b9d3c4349fb0a9b0da69a54ee8f956959e334" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;?&lt;/code&gt; placed after a &lt;code&gt;Result&lt;/code&gt; value is defined to work in almost the same way as the &lt;code&gt;match&lt;/code&gt; expressions we defined to handle the &lt;code&gt;Result&lt;/code&gt; values in Listing 9-6. If the value of the &lt;code&gt;Result&lt;/code&gt; is an &lt;code&gt;Ok&lt;/code&gt;, the value inside the &lt;code&gt;Ok&lt;/code&gt; will get returned from this expression, and the program will continue. If the value is an &lt;code&gt;Err&lt;/code&gt;, the &lt;code&gt;Err&lt;/code&gt; will be returned from the whole function as if we had used the &lt;code&gt;return&lt;/code&gt; keyword so the error value gets propagated to the calling code.</source>
          <target state="translated">&lt;code&gt;?&lt;/code&gt; помещается после &lt;code&gt;Result&lt;/code&gt; значения определяются работу почти таким же образом , как &lt;code&gt;match&lt;/code&gt; выражение , которое мы определили для обработки &lt;code&gt;Result&lt;/code&gt; значений в листинге 9-6. Если значением &lt;code&gt;Result&lt;/code&gt; является &lt;code&gt;Ok&lt;/code&gt; , значение внутри &lt;code&gt;Ok&lt;/code&gt; будет возвращено из этого выражения, и программа продолжится. Если значением является &lt;code&gt;Err&lt;/code&gt; , &lt;code&gt;Err&lt;/code&gt; будет возвращен из всей функции, как если бы мы использовали ключевое слово &lt;code&gt;return&lt;/code&gt; , чтобы значение ошибки было передано в вызывающий код.</target>
        </trans-unit>
        <trans-unit id="1dcf74da2de6e2e77e988e297d47588fe8eb0ad5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Alloc&lt;/code&gt; trait is an &lt;code&gt;unsafe&lt;/code&gt; trait for a number of reasons, and implementors must ensure that they adhere to these contracts:</source>
          <target state="translated">&lt;code&gt;Alloc&lt;/code&gt; черта является &lt;code&gt;unsafe&lt;/code&gt; чертой для целого ряда причин, и реализаторы должны гарантировать , что они придерживаются этих договоров:</target>
        </trans-unit>
        <trans-unit id="98e48446e54082f0c926a4f9b0d797094660f773" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;AllocErr&lt;/code&gt; error indicates an allocation failure that may be due to resource exhaustion or to something wrong when combining the given input arguments with this allocator.</source>
          <target state="translated">&lt;code&gt;AllocErr&lt;/code&gt; ошибка указывает на ошибки распределения , которые могут быть из - за истощения ресурсов или что - то неправильно при объединении заданных входных аргументов с этим распределителем.</target>
        </trans-unit>
        <trans-unit id="40c7890578f6b7272b5ec64894b3d7a1fbafa432" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;AllocError&lt;/code&gt; error indicates an allocation failure that may be due to resource exhaustion or to something wrong when combining the given input arguments with this allocator.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a15f84d510941143cdca2ea70c5b85337d8cfce7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Binary&lt;/code&gt; trait should format its output as a number in binary.</source>
          <target state="translated">&lt;code&gt;Binary&lt;/code&gt; черта должна форматировать свой выход как число в двоичной системе .</target>
        </trans-unit>
        <trans-unit id="379b6b1f35d3ee950871663ac9c0d0834cb49cc4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Box&amp;lt;...&amp;gt;&lt;/code&gt; ensures that the result is of known size, and the pin is required to keep it in the same place in memory.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a6e3077926ddb39580746ea9c9fb509f4ede0db3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; type is a smart pointer because it implements the &lt;code&gt;Deref&lt;/code&gt; trait, which allows &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; values to be treated like references. When a &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; value goes out of scope, the heap data that the box is pointing to is cleaned up as well because of the &lt;code&gt;Drop&lt;/code&gt; trait implementation. Let&amp;rsquo;s explore these two traits in more detail. These two traits will be even more important to the functionality provided by the other smart pointer types we&amp;rsquo;ll discuss in the rest of this chapter.</source>
          <target state="translated">Тип &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; является интеллектуальным указателем, поскольку он реализует &lt;code&gt;Deref&lt;/code&gt; , который позволяет обрабатывать значения &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; как ссылки. Когда значение &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; выходит за пределы области видимости, данные кучи, на которые указывает блок, также очищаются из-за реализации &lt;code&gt;Drop&lt;/code&gt; . Давайте рассмотрим эти две особенности более подробно. Эти две особенности будут еще более важны для функциональности, предоставляемой другими типами интеллектуальных указателей, которые мы обсудим в оставшейся части этой главы.</target>
        </trans-unit>
        <trans-unit id="66f94ad31e24eabd73aee0f8f7b4d3256d1ad7c2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; type is ultimately defined as a tuple struct with one element, so Listing 15-8 defines a &lt;code&gt;MyBox&amp;lt;T&amp;gt;&lt;/code&gt; type in the same way. We&amp;rsquo;ll also define a &lt;code&gt;new&lt;/code&gt; function to match the &lt;code&gt;new&lt;/code&gt; function defined on &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">Тип &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; в конечном итоге определяется как структура кортежа с одним элементом, поэтому в листинге 15-8 таким же образом определяется &lt;code&gt;MyBox&amp;lt;T&amp;gt;&lt;/code&gt; . Мы также определим &lt;code&gt;new&lt;/code&gt; функцию, соответствующую &lt;code&gt;new&lt;/code&gt; функции, определенной в &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="bf6505b6927d963f13c67732403dd5931ac1ed9c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Box&amp;lt;dyn Error&amp;gt;&lt;/code&gt; type is called a &lt;em&gt;trait object&lt;/em&gt;, which we&amp;rsquo;ll talk about in the &lt;a href=&quot;ch17-02-trait-objects#using-trait-objects-that-allow-for-values-of-different-types&quot;&gt;&amp;ldquo;Using Trait Objects that Allow for Values of Different Types&amp;rdquo;&lt;/a&gt; section in Chapter 17. For now, you can read &lt;code&gt;Box&amp;lt;dyn Error&amp;gt;&lt;/code&gt; to mean &amp;ldquo;any kind of error.&amp;rdquo; Using &lt;code&gt;?&lt;/code&gt; in a &lt;code&gt;main&lt;/code&gt; function with this return type is allowed.</source>
          <target state="translated">Тип &lt;code&gt;Box&amp;lt;dyn Error&amp;gt;&lt;/code&gt; называется &lt;em&gt;объектом признака&lt;/em&gt; , о котором мы поговорим в разделе &lt;a href=&quot;ch17-02-trait-objects#using-trait-objects-that-allow-for-values-of-different-types&quot;&gt;&amp;laquo;Использование объектов-признаков, допускающих значения разных типов&amp;raquo;&lt;/a&gt; в главе 17. На данный момент вы можете прочитать &lt;code&gt;Box&amp;lt;dyn Error&amp;gt;&lt;/code&gt; чтобы означает &amp;laquo;ошибка любого рода&amp;raquo;. Используя &lt;code&gt;?&lt;/code&gt; в &lt;code&gt;main&lt;/code&gt; функции с этим типом возврата разрешено.</target>
        </trans-unit>
        <trans-unit id="f421012dfbbefb54564368d8001a12741e0df3e2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Box&amp;lt;dyn Error&amp;gt;&lt;/code&gt; type is called a trait object, which we&amp;rsquo;ll talk about in the &lt;a href=&quot;ch17-02-trait-objects#using-trait-objects-that-allow-for-values-of-different-types&quot;&gt;&amp;ldquo;Using Trait Objects that Allow for Values of Different Types&amp;rdquo;&lt;/a&gt; section in Chapter 17. For now, you can read &lt;code&gt;Box&amp;lt;dyn Error&amp;gt;&lt;/code&gt; to mean &amp;ldquo;any kind of error.&amp;rdquo; Using &lt;code&gt;?&lt;/code&gt; in a &lt;code&gt;main&lt;/code&gt; function with this return type is allowed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7da298387c32437955972d3bd8b7791a6a295347" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;BufReader&amp;lt;R&amp;gt;&lt;/code&gt; struct adds buffering to any reader.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1691172593fd486c5eabaf315f65ace8dbf6dcde" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;BufReader&lt;/code&gt; struct adds buffering to any reader.</source>
          <target state="translated">Структура &lt;code&gt;BufReader&lt;/code&gt; добавляет буферизацию любому читателю.</target>
        </trans-unit>
        <trans-unit id="258a1854757eccfe175a683df1ba477ca28eb2bf" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;C&lt;/code&gt; Representation</source>
          <target state="translated">&lt;code&gt;C&lt;/code&gt; Представление</target>
        </trans-unit>
        <trans-unit id="13bde6b705c6f0c548e0105a8252725ac6ce4d78" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;C&lt;/code&gt; representation for items has a defined layout. With this layout, the size of items is also stable as long as all fields have a stable size.</source>
          <target state="translated">Представление &lt;code&gt;C&lt;/code&gt; для элементов имеет определенный макет. При таком макете размер элементов также остается стабильным, если все поля имеют стабильный размер.</target>
        </trans-unit>
        <trans-unit id="51da5ab6258546c0e07e79893a79989cd376412d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;C&lt;/code&gt; representation is designed for dual purposes. One purpose is for creating types that are interoperable with the C Language. The second purpose is to create types that you can soundly perform operations on that rely on data layout such as reinterpreting values as a different type.</source>
          <target state="translated">Представление &lt;code&gt;C&lt;/code&gt; предназначено для двойных целей. Одна из целей - создание типов, совместимых с языком C. Вторая цель - создать типы, с которыми можно эффективно выполнять операции, основанные на структуре данных, такие как переинтерпретация значений как другого типа.</target>
        </trans-unit>
        <trans-unit id="d3b29c11032bb6739237ad8f95e6e66861078b0e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Cacher::new&lt;/code&gt; function takes a generic parameter &lt;code&gt;T&lt;/code&gt;, which we&amp;rsquo;ve defined as having the same trait bound as the &lt;code&gt;Cacher&lt;/code&gt; struct. Then &lt;code&gt;Cacher::new&lt;/code&gt; returns a &lt;code&gt;Cacher&lt;/code&gt; instance that holds the closure specified in the &lt;code&gt;calculation&lt;/code&gt; field and a &lt;code&gt;None&lt;/code&gt; value in the &lt;code&gt;value&lt;/code&gt; field, because we haven&amp;rsquo;t executed the closure yet.</source>
          <target state="translated">Функция &lt;code&gt;Cacher::new&lt;/code&gt; принимает общий параметр &lt;code&gt;T&lt;/code&gt; , который, как мы определили, имеет ту же черту, что и структура &lt;code&gt;Cacher&lt;/code&gt; . Затем &lt;code&gt;Cacher::new&lt;/code&gt; возвращает экземпляр &lt;code&gt;Cacher&lt;/code&gt; , содержащий замыкание, указанное в поле &lt;code&gt;calculation&lt;/code&gt; и значение &lt;code&gt;None&lt;/code&gt; в поле &lt;code&gt;value&lt;/code&gt; , потому что мы еще не выполнили замыкание.</target>
        </trans-unit>
        <trans-unit id="b4813a8ce2e935eef24c8392e81d63c3906c4494" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Cacher&lt;/code&gt; struct has a &lt;code&gt;calculation&lt;/code&gt; field of the generic type &lt;code&gt;T&lt;/code&gt;. The trait bounds on &lt;code&gt;T&lt;/code&gt; specify that it&amp;rsquo;s a closure by using the &lt;code&gt;Fn&lt;/code&gt; trait. Any closure we want to store in the &lt;code&gt;calculation&lt;/code&gt; field must have one &lt;code&gt;u32&lt;/code&gt; parameter (specified within the parentheses after &lt;code&gt;Fn&lt;/code&gt;) and must return a &lt;code&gt;u32&lt;/code&gt; (specified after the &lt;code&gt;-&amp;gt;&lt;/code&gt;).</source>
          <target state="translated">&lt;code&gt;Cacher&lt;/code&gt; структура имеет &lt;code&gt;calculation&lt;/code&gt; поле универсального типа &lt;code&gt;T&lt;/code&gt; . Границы признака на &lt;code&gt;T&lt;/code&gt; указывают, что это замыкание с помощью признака &lt;code&gt;Fn&lt;/code&gt; . Любое замыкание, которое мы хотим сохранить в поле &lt;code&gt;calculation&lt;/code&gt; должно иметь один параметр &lt;code&gt;u32&lt;/code&gt; (указанный в скобках после &lt;code&gt;Fn&lt;/code&gt; ) и должен возвращать &lt;code&gt;u32&lt;/code&gt; (указанный после &lt;code&gt;-&amp;gt;&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="b2611487755ed0f487d8741cbb5ae43a528fa050" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;CannotReallocInPlace&lt;/code&gt; error is used when &lt;code&gt;grow_in_place&lt;/code&gt; or &lt;code&gt;shrink_in_place&lt;/code&gt; were unable to reuse the given memory block for a requested layout.</source>
          <target state="translated">&lt;code&gt;CannotReallocInPlace&lt;/code&gt; ошибка используется , когда &lt;code&gt;grow_in_place&lt;/code&gt; или &lt;code&gt;shrink_in_place&lt;/code&gt; были неспособны повторно использовать данный блок памяти для запрашиваемого макета.</target>
        </trans-unit>
        <trans-unit id="66ff318ae517f73cd3f13be64857852133418c2e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Clone&lt;/code&gt; trait allows you to explicitly create a deep copy of a value, and the duplication process might involve running arbitrary code and copying heap data. See the &lt;a href=&quot;ch04-01-what-is-ownership#ways-variables-and-data-interact-clone&quot;&gt;&amp;ldquo;Ways Variables and Data Interact: Clone&amp;rdquo;&lt;/a&gt; section in Chapter 4 for more information on &lt;code&gt;Clone&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Clone&lt;/code&gt; черта позволяет явным образом создать глубокую копию значения, и процесс дублирования может включать в себя работу произвольного кода и копирование кучи данных. Дополнительные сведения о &lt;code&gt;Clone&lt;/code&gt; см. В разделе &lt;a href=&quot;ch04-01-what-is-ownership#ways-variables-and-data-interact-clone&quot;&gt;&amp;laquo;Способы взаимодействия переменных и данных: клонирование&amp;raquo;&lt;/a&gt; в главе 4 .</target>
        </trans-unit>
        <trans-unit id="ad03569cf96b66590827b19ede2029d2fc0e960d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Clone&lt;/code&gt; trait for types that cannot be 'implicitly copied'.</source>
          <target state="translated">&lt;code&gt;Clone&lt;/code&gt; черта для типов , которые не могут быть 'неявно скопирован.</target>
        </trans-unit>
        <trans-unit id="18eff9d7482bec9f52eb9a085d95c11254b36933" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;CoerceUnsized&lt;/code&gt; trait takes a struct type. Make sure the type you are providing to &lt;code&gt;CoerceUnsized&lt;/code&gt; is a struct with only the last field containing an unsized type.</source>
          <target state="translated">&lt;code&gt;CoerceUnsized&lt;/code&gt; черта принимает тип структуры. Убедитесь, что тип, который вы предоставляете &lt;code&gt;CoerceUnsized&lt;/code&gt; , является структурой, только последнее поле которой содержит тип без размера.</target>
        </trans-unit>
        <trans-unit id="e548ae9701e88686017ab152887ae716380c763e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Config::new&lt;/code&gt; function definition</source>
          <target state="translated">В &lt;code&gt;Config::new&lt;/code&gt; определение функции</target>
        </trans-unit>
        <trans-unit id="501a0b9d21e10f396777e5d2959bafbe25f146ca" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Cons&lt;/code&gt; variant will need the size of an &lt;code&gt;i32&lt;/code&gt; plus the space to store the box&amp;rsquo;s pointer data. The &lt;code&gt;Nil&lt;/code&gt; variant stores no values, so it needs less space than the &lt;code&gt;Cons&lt;/code&gt; variant. We now know that any &lt;code&gt;List&lt;/code&gt; value will take up the size of an &lt;code&gt;i32&lt;/code&gt; plus the size of a box&amp;rsquo;s pointer data. By using a box, we&amp;rsquo;ve broken the infinite, recursive chain, so the compiler can figure out the size it needs to store a &lt;code&gt;List&lt;/code&gt; value. Figure 15-2 shows what the &lt;code&gt;Cons&lt;/code&gt; variant looks like now.</source>
          <target state="translated">Вариант &lt;code&gt;Cons&lt;/code&gt; потребует размер &lt;code&gt;i32&lt;/code&gt; плюс место для хранения данных указателя блока. Вариант &lt;code&gt;Nil&lt;/code&gt; не хранит значений, поэтому ему требуется меньше места, чем вариант &lt;code&gt;Cons&lt;/code&gt; . Теперь мы знаем, что любое значение &lt;code&gt;List&lt;/code&gt; будет занимать размер &lt;code&gt;i32&lt;/code&gt; плюс размер данных указателя блока. Используя блок, мы разорвали бесконечную рекурсивную цепочку, чтобы компилятор мог определить размер, который ему нужен для хранения значения &lt;code&gt;List&lt;/code&gt; . На рис. 15-2 показано, как сейчас выглядит вариант &lt;code&gt;Cons&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a626d0216123ae4ac45161a1bdf7e2c4de5ee23a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Cons&lt;/code&gt; variants own the data they hold, so when we create the &lt;code&gt;b&lt;/code&gt; list, &lt;code&gt;a&lt;/code&gt; is moved into &lt;code&gt;b&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; owns &lt;code&gt;a&lt;/code&gt;. Then, when we try to use &lt;code&gt;a&lt;/code&gt; again when creating &lt;code&gt;c&lt;/code&gt;, we&amp;rsquo;re not allowed to because &lt;code&gt;a&lt;/code&gt; has been moved.</source>
          <target state="translated">В &lt;code&gt;Cons&lt;/code&gt; варианты собственные данные они держат, поэтому , когда мы создаем &lt;code&gt;b&lt;/code&gt; список, перемещается в &lt;code&gt;b&lt;/code&gt; и &lt;code&gt;b&lt;/code&gt; принадлежат . Затем, когда мы снова пытаемся использовать &lt;code&gt;a&lt;/code&gt; при создании &lt;code&gt;c&lt;/code&gt; , нам не разрешено, потому что &lt;code&gt;a&lt;/code&gt; был перемещен. &lt;code&gt;a&lt;/code&gt; &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="0ddcf60586798598b647a102cf947282e0f109f6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Context&lt;/code&gt; of an asynchronous task.</source>
          <target state="translated">&lt;code&gt;Context&lt;/code&gt; асинхронной задачи.</target>
        </trans-unit>
        <trans-unit id="d2f260e119bb2a2221aaead7149c78bb8d75b87a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Copy&lt;/code&gt; trait allows you to duplicate a value by only copying bits stored on the stack; no arbitrary code is necessary. See the &lt;a href=&quot;ch04-01-what-is-ownership#stack-only-data-copy&quot;&gt;&amp;ldquo;Stack-Only Data: Copy&amp;rdquo;&lt;/a&gt; section in Chapter 4 for more information on &lt;code&gt;Copy&lt;/code&gt;.</source>
          <target state="translated">Характеристика &lt;code&gt;Copy&lt;/code&gt; позволяет дублировать значение, копируя только биты, хранящиеся в стеке; произвольный код не требуется. Дополнительные сведения о &lt;code&gt;Copy&lt;/code&gt; см. В разделе &lt;a href=&quot;ch04-01-what-is-ownership#stack-only-data-copy&quot;&gt;&amp;laquo;Данные только для стопки: копирование&amp;raquo;&lt;/a&gt; в главе 4 .</target>
        </trans-unit>
        <trans-unit id="6af89e2c9cf5d947b4b736850c9a97076811fab2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Copy&lt;/code&gt; trait doesn&amp;rsquo;t define any methods to prevent programmers from overloading those methods and violating the assumption that no arbitrary code is being run. That way, all programmers can assume that copying a value will be very fast.</source>
          <target state="translated">&lt;code&gt;Copy&lt;/code&gt; черта не определяет никаких методов для предотвращения программистов от перегрузки этих методов и нарушающим предположения , что никакого произвольного код не выполняющийся. Таким образом, все программисты могут предположить, что копирование значения будет очень быстрым.</target>
        </trans-unit>
        <trans-unit id="d9a9d9ddc02bc50daec8b0c1f2146daf65e918a8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Copy&lt;/code&gt; trait is implemented by default only on primitive types. If your type only contains primitive types, you'll be able to implement &lt;code&gt;Copy&lt;/code&gt; on it. Otherwise, it won't be possible.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8c62b63ef24786f929500cd4f0e354183f51728d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Copy&lt;/code&gt; trait is rarely required; types that implement &lt;code&gt;Copy&lt;/code&gt; have optimizations available, meaning you don&amp;rsquo;t have to call &lt;code&gt;clone&lt;/code&gt;, which makes the code more concise.</source>
          <target state="translated">&lt;code&gt;Copy&lt;/code&gt; черт редко требуется; Для типов, реализующих &lt;code&gt;Copy&lt;/code&gt; , доступна оптимизация, то есть вам не нужно вызывать &lt;code&gt;clone&lt;/code&gt; , что делает код более лаконичным.</target>
        </trans-unit>
        <trans-unit id="19e60de5e2cec4f66ffc273d83b18ba133a29961" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Copy&lt;/code&gt; trait was implemented on a type which contains a field that doesn't implement the &lt;code&gt;Copy&lt;/code&gt; trait.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5bc1853088c8596ec738b63d0b306b0f2a10680d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Copy&lt;/code&gt; trait was implemented on a type which is neither a struct nor an enum.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="23cc8d6ab49e3b2451486ee83ff4fdc2f0dab312" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Copy&lt;/code&gt; trait was implemented on a type with a &lt;code&gt;Drop&lt;/code&gt; implementation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7a2c2f0333db2747594fc8c5736d8f8e947ab10e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Counter&lt;/code&gt; struct has one field named &lt;code&gt;count&lt;/code&gt;. This field holds a &lt;code&gt;u32&lt;/code&gt; value that will keep track of where we are in the process of iterating from 1 to 5. The &lt;code&gt;count&lt;/code&gt; field is private because we want the implementation of &lt;code&gt;Counter&lt;/code&gt; to manage its value. The &lt;code&gt;new&lt;/code&gt; function enforces the behavior of always starting new instances with a value of 0 in the &lt;code&gt;count&lt;/code&gt; field.</source>
          <target state="translated">В структуре &lt;code&gt;Counter&lt;/code&gt; есть одно поле с именем &lt;code&gt;count&lt;/code&gt; . Это поле содержит значение &lt;code&gt;u32&lt;/code&gt; , которое будет отслеживать, где мы находимся в процессе итерации от 1 до 5. Поле &lt;code&gt;count&lt;/code&gt; является частным, потому что мы хотим, чтобы реализация &lt;code&gt;Counter&lt;/code&gt; управляла его значением. &lt;code&gt;new&lt;/code&gt; функция усиливает поведение всегда начиная новые экземпляры со значением 0 в &lt;code&gt;count&lt;/code&gt; поля.</target>
        </trans-unit>
        <trans-unit id="e402bbce82e84dd539cf1e138daa2856a0613786" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Debug&lt;/code&gt; trait allows you to print instances of a type for debugging purposes, so you and other programmers using your type can inspect an instance at a particular point in a program&amp;rsquo;s execution.</source>
          <target state="translated">Свойство &lt;code&gt;Debug&lt;/code&gt; позволяет печатать экземпляры типа для целей отладки, чтобы вы и другие программисты, использующие ваш тип, могли проверять экземпляр в определенной точке выполнения программы.</target>
        </trans-unit>
        <trans-unit id="853b42f22ba0be46a6e5cd03ba34756814292e76" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Debug&lt;/code&gt; trait enables debug formatting in format strings, which you indicate by adding &lt;code&gt;:?&lt;/code&gt; within &lt;code&gt;{}&lt;/code&gt; placeholders.</source>
          <target state="translated">Свойство &lt;code&gt;Debug&lt;/code&gt; включает форматирование отладки в строках формата, которые вы указываете, добавляя &lt;code&gt;:?&lt;/code&gt; в пределах &lt;code&gt;{}&lt;/code&gt; заполнителей.</target>
        </trans-unit>
        <trans-unit id="6967ae462b0a2a18036d993e8418edd4a969bd40" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Debug&lt;/code&gt; trait is required, for example, in use of the &lt;code&gt;assert_eq!&lt;/code&gt; macro. This macro prints the values of instances given as arguments if the equality assertion fails so programmers can see why the two instances weren&amp;rsquo;t equal.</source>
          <target state="translated">&lt;code&gt;Debug&lt;/code&gt; черта не требуется, например, при использовании &lt;code&gt;assert_eq!&lt;/code&gt; макрос. Этот макрос печатает значения экземпляров, заданных в качестве аргументов, если утверждение равенства не выполняется, чтобы программисты могли понять, почему два экземпляра не были равны.</target>
        </trans-unit>
        <trans-unit id="aba43f90e22e0dfd98100913cb543e02752ca675" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Default::default&lt;/code&gt; function is commonly used in combination with the struct update syntax discussed in the &lt;a href=&quot;ch05-01-defining-structs#creating-instances-from-other-instances-with-struct-update-syntax&quot;&gt;&amp;ldquo;Creating Instances From Other Instances With Struct Update Syntax&amp;rdquo;&lt;/a&gt; section in Chapter 5. You can customize a few fields of a struct and then set and use a default value for the rest of the fields by using &lt;code&gt;..Default::default()&lt;/code&gt;.</source>
          <target state="translated">Функция &lt;code&gt;Default::default&lt;/code&gt; обычно используется в сочетании с синтаксисом обновления структуры, обсуждаемым в разделе &lt;a href=&quot;ch05-01-defining-structs#creating-instances-from-other-instances-with-struct-update-syntax&quot;&gt;&amp;laquo;Создание экземпляров из других экземпляров с синтаксисом обновления структуры&amp;raquo;&lt;/a&gt; в главе 5. Вы можете настроить несколько полей структуры, а затем установить и использовать значение по умолчанию для остальных полей с помощью &lt;code&gt;..Default::default()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4f7be30b5dee7044de3817ca4c87b66ab54682e4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Default&lt;/code&gt; cannot be derived on an enum for the simple reason that the compiler doesn't know which value to pick by default whereas it can for a struct as long as all its fields implement the &lt;code&gt;Default&lt;/code&gt; trait as well.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="155c03f436324748d5a47629042098342e63a6ce" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Default&lt;/code&gt; trait allows you to create a default value for a type. Deriving &lt;code&gt;Default&lt;/code&gt; implements the &lt;code&gt;default&lt;/code&gt; function. The derived implementation of the &lt;code&gt;default&lt;/code&gt; function calls the &lt;code&gt;default&lt;/code&gt; function on each part of the type, meaning all fields or values in the type must also implement &lt;code&gt;Default&lt;/code&gt; to derive &lt;code&gt;Default&lt;/code&gt;.</source>
          <target state="translated">Свойство &lt;code&gt;Default&lt;/code&gt; позволяет вам создать значение по умолчанию для типа. Получение значения по &lt;code&gt;Default&lt;/code&gt; реализует функцию по &lt;code&gt;default&lt;/code&gt; . Производная реализация функции по &lt;code&gt;default&lt;/code&gt; вызывает функцию по &lt;code&gt;default&lt;/code&gt; для каждой части типа, то есть все поля или значения в типе также должны реализовывать &lt;code&gt;Default&lt;/code&gt; для получения &lt;code&gt;Default&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="417d240e17ea189069372338520fb02d077b097b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Default&lt;/code&gt; trait for types which may have meaningful default values.</source>
          <target state="translated">Характеристика &lt;code&gt;Default&lt;/code&gt; для типов, которые могут иметь значимые значения по умолчанию.</target>
        </trans-unit>
        <trans-unit id="e9ffe8630d56067e177ef382279c1fa4ad4f3ea3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Default&lt;/code&gt; trait is required when you use the method &lt;code&gt;unwrap_or_default&lt;/code&gt; on &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt; instances, for example. If the &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt; is &lt;code&gt;None&lt;/code&gt;, the method &lt;code&gt;unwrap_or_default&lt;/code&gt; will return the result of &lt;code&gt;Default::default&lt;/code&gt; for the type &lt;code&gt;T&lt;/code&gt; stored in the &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Default&lt;/code&gt; черта требуется при использовании метода &lt;code&gt;unwrap_or_default&lt;/code&gt; на &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt; экземпляры, например. Если &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt; - &lt;code&gt;None&lt;/code&gt; , метод &lt;code&gt;unwrap_or_default&lt;/code&gt; вернет результат &lt;code&gt;Default::default&lt;/code&gt; для типа &lt;code&gt;T&lt;/code&gt; , хранящегося в &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="faec1eafc86ec050669e657d677254ae1cc5eb09" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Default&lt;/code&gt; trait was derived on an enum.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3bac5d0a36fa049d2b9d797796c56dde34fe6945" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;DispatchFromDyn&lt;/code&gt; trait currently can only be implemented for builtin pointer types and structs that are newtype wrappers around them &amp;mdash; that is, the struct must have only one field (except for&lt;code&gt;PhantomData&lt;/code&gt;), and that field must itself implement &lt;code&gt;DispatchFromDyn&lt;/code&gt;.</source>
          <target state="translated">В настоящее время черта &lt;code&gt;DispatchFromDyn&lt;/code&gt; может быть реализована только для типов встроенных указателей и структур, которые являются оболочками newtype вокруг них, то есть структура должна иметь только одно поле (кроме &lt;code&gt;PhantomData&lt;/code&gt; ), и это поле должно само реализовывать &lt;code&gt;DispatchFromDyn&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f4511d27b8bd2f5f7b72a8b815a18a15df561075" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;DispatchFromDyn&lt;/code&gt; trait was implemented on something which is not a pointer or a newtype wrapper around a pointer.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b6986e696b5a0b081bb4012a05eb9e1b65dcc35b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;DraftPost&lt;/code&gt; struct has an &lt;code&gt;add_text&lt;/code&gt; method, so we can add text to &lt;code&gt;content&lt;/code&gt; as before, but note that &lt;code&gt;DraftPost&lt;/code&gt; does not have a &lt;code&gt;content&lt;/code&gt; method defined! So now the program ensures all posts start as draft posts, and draft posts don&amp;rsquo;t have their content available for display. Any attempt to get around these constraints will result in a compiler error.</source>
          <target state="translated">Структура &lt;code&gt;DraftPost&lt;/code&gt; имеет метод &lt;code&gt;add_text&lt;/code&gt; , поэтому мы можем добавлять текст к &lt;code&gt;content&lt;/code&gt; как и раньше, но обратите внимание, что &lt;code&gt;DraftPost&lt;/code&gt; не имеет определенного метода &lt;code&gt;content&lt;/code&gt; ! Итак, теперь программа гарантирует, что все сообщения начинаются как черновики сообщений, а содержимое черновиков сообщений не доступно для отображения. Любая попытка обойти эти ограничения приведет к ошибке компилятора.</target>
        </trans-unit>
        <trans-unit id="b1de117663cb2f27f8306ea33629038001aac2df" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Drop&lt;/code&gt; trait is included in the prelude, so we don&amp;rsquo;t need to bring it into scope. We implement the &lt;code&gt;Drop&lt;/code&gt; trait on &lt;code&gt;CustomSmartPointer&lt;/code&gt; and provide an implementation for the &lt;code&gt;drop&lt;/code&gt; method that calls &lt;code&gt;println!&lt;/code&gt;. The body of the &lt;code&gt;drop&lt;/code&gt; function is where you would place any logic that you wanted to run when an instance of your type goes out of scope. We&amp;rsquo;re printing some text here to demonstrate when Rust will call &lt;code&gt;drop&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Drop&lt;/code&gt; черта входит в прелюдии, поэтому нам не нужно , чтобы привести его в рамки. Мы реализуем &lt;code&gt;CustomSmartPointer&lt;/code&gt; &lt;code&gt;Drop&lt;/code&gt; на CustomSmartPointer и предоставляем реализацию для метода &lt;code&gt;drop&lt;/code&gt; , который вызывает &lt;code&gt;println!&lt;/code&gt; . Тело функции &lt;code&gt;drop&lt;/code&gt; - это место, где вы должны разместить любую логику, которую хотите запустить, когда экземпляр вашего типа выходит за пределы области видимости. Мы печатаем здесь текст, чтобы продемонстрировать, когда Rust вызовет &lt;code&gt;drop&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a67a7efec93a37792cb31993e146b2f7a5f7bc09" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Eq&lt;/code&gt; trait has no methods. Its purpose is to signal that for every value of the annotated type, the value is equal to itself. The &lt;code&gt;Eq&lt;/code&gt; trait can only be applied to types that also implement &lt;code&gt;PartialEq&lt;/code&gt;, although not all types that implement &lt;code&gt;PartialEq&lt;/code&gt; can implement &lt;code&gt;Eq&lt;/code&gt;. One example of this is floating point number types: the implementation of floating point numbers states that two instances of the not-a-number (&lt;code&gt;NaN&lt;/code&gt;) value are not equal to each other.</source>
          <target state="translated">У трейта &lt;code&gt;Eq&lt;/code&gt; нет методов. Его цель - сообщить, что для каждого значения аннотированного типа значение равно самому себе. Свойство &lt;code&gt;Eq&lt;/code&gt; можно применять только к типам, которые также реализуют &lt;code&gt;PartialEq&lt;/code&gt; , хотя не все типы, реализующие &lt;code&gt;PartialEq&lt;/code&gt; , могут реализовать &lt;code&gt;Eq&lt;/code&gt; . Одним из примеров этого являются типы чисел с плавающей запятой: реализация чисел с плавающей запятой заявляет, что два экземпляра значения не числа ( &lt;code&gt;NaN&lt;/code&gt; ) не равны друг другу.</target>
        </trans-unit>
        <trans-unit id="339e508d8f9f4467a3c3de396b4c7c19141c661f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;F&lt;/code&gt; type parameter also has the trait bound &lt;code&gt;Send&lt;/code&gt; and the lifetime bound &lt;code&gt;'static&lt;/code&gt;, which are useful in our situation: we need &lt;code&gt;Send&lt;/code&gt; to transfer the closure from one thread to another and &lt;code&gt;'static&lt;/code&gt; because we don&amp;rsquo;t know how long the thread will take to execute. Let&amp;rsquo;s create an &lt;code&gt;execute&lt;/code&gt; method on &lt;code&gt;ThreadPool&lt;/code&gt; that will take a generic parameter of type &lt;code&gt;F&lt;/code&gt; with these bounds:</source>
          <target state="translated">Параметр типа &lt;code&gt;F&lt;/code&gt; также имеет привязку признака &lt;code&gt;Send&lt;/code&gt; и привязку времени жизни &lt;code&gt;'static&lt;/code&gt; , которые полезны в нашей ситуации: нам нужно &lt;code&gt;Send&lt;/code&gt; закрытие из одного потока в другой и &lt;code&gt;'static&lt;/code&gt; потому что мы не знаем, как долго поток будет взять на исполнение. Давайте создадим метод &lt;code&gt;execute&lt;/code&gt; в &lt;code&gt;ThreadPool&lt;/code&gt; , который будет принимать универсальный параметр типа &lt;code&gt;F&lt;/code&gt; с этими границами:</target>
        </trans-unit>
        <trans-unit id="44f286163600e21778b5e8ddc538f3f66c2c5215" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;F&lt;/code&gt; type parameter is the one we&amp;rsquo;re concerned with here; the &lt;code&gt;T&lt;/code&gt; type parameter is related to the return value, and we&amp;rsquo;re not concerned with that. We can see that &lt;code&gt;spawn&lt;/code&gt; uses &lt;code&gt;FnOnce&lt;/code&gt; as the trait bound on &lt;code&gt;F&lt;/code&gt;. This is probably what we want as well, because we&amp;rsquo;ll eventually pass the argument we get in &lt;code&gt;execute&lt;/code&gt; to &lt;code&gt;spawn&lt;/code&gt;. We can be further confident that &lt;code&gt;FnOnce&lt;/code&gt; is the trait we want to use because the thread for running a request will only execute that request&amp;rsquo;s closure one time, which matches the &lt;code&gt;Once&lt;/code&gt; in &lt;code&gt;FnOnce&lt;/code&gt;.</source>
          <target state="translated">Здесь нас интересует параметр типа &lt;code&gt;F&lt;/code&gt; ; &lt;code&gt;T&lt;/code&gt; параметр типа связан с возвращаемым значением, и мы не связаны с этим. Мы можем видеть , что &lt;code&gt;spawn&lt;/code&gt; использует &lt;code&gt;FnOnce&lt;/code&gt; в качестве признака , связанного на &lt;code&gt;F&lt;/code&gt; . Вероятно, это то, что мы хотим, потому что в конечном итоге мы передадим аргумент, который мы получаем в &lt;code&gt;execute&lt;/code&gt; , для &lt;code&gt;spawn&lt;/code&gt; . Мы также можем быть уверены, что &lt;code&gt;FnOnce&lt;/code&gt; - это черта, которую мы хотим использовать, потому что поток для выполнения запроса будет выполнять закрытие этого запроса только один раз, что соответствует &lt;code&gt;Once&lt;/code&gt; in &lt;code&gt;FnOnce&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2cc0c55739bb91f91d10f706c9cab70e100723e2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Fn&lt;/code&gt; traits are provided by the standard library. All closures implement at least one of the traits: &lt;code&gt;Fn&lt;/code&gt;, &lt;code&gt;FnMut&lt;/code&gt;, or &lt;code&gt;FnOnce&lt;/code&gt;. We&amp;rsquo;ll discuss the difference between these traits in the &lt;a href=&quot;#capturing-the-environment-with-closures&quot;&gt;&amp;ldquo;Capturing the Environment with Closures&amp;rdquo;&lt;/a&gt; section; in this example, we can use the &lt;code&gt;Fn&lt;/code&gt; trait.</source>
          <target state="translated">В &lt;code&gt;Fn&lt;/code&gt; черты обеспечиваются стандартной библиотекой. Все замыкания реализуют по крайней мере одну из черт: &lt;code&gt;Fn&lt;/code&gt; , &lt;code&gt;FnMut&lt;/code&gt; или &lt;code&gt;FnOnce&lt;/code&gt; . Мы обсудим разницу между этими чертами в разделе &lt;a href=&quot;#capturing-the-environment-with-closures&quot;&gt;&amp;laquo;Захват среды с помощью замыканий&amp;raquo;&lt;/a&gt; ; в этом примере мы можем использовать черту &lt;code&gt;Fn&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="851722264534e1910cdc1ef4f424b4a4414f9688" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;From&lt;/code&gt; is also very useful when performing error handling. When constructing a function that is capable of failing, the return type will generally be of the form &lt;code&gt;Result&amp;lt;T, E&amp;gt;&lt;/code&gt;. The &lt;code&gt;From&lt;/code&gt; trait simplifies error handling by allowing a function to return a single error type that encapsulate multiple error types. See the &quot;Examples&quot; section and &lt;a href=&quot;../../book/ch09-00-error-handling&quot;&gt;the book&lt;/a&gt; for more details.</source>
          <target state="translated">&lt;code&gt;From&lt;/code&gt; также очень полезен при выполнении обработки ошибок. При создании функции, способной дать сбой, тип возвращаемого значения обычно имеет вид &lt;code&gt;Result&amp;lt;T, E&amp;gt;&lt;/code&gt; . &lt;code&gt;From&lt;/code&gt; черта упрощает обработку ошибок, позволяя функции возвращать один тип ошибки , который инкапсулирует несколько типов ошибок. См. Раздел &amp;laquo;Примеры&amp;raquo; и &lt;a href=&quot;../../book/ch09-00-error-handling&quot;&gt;книгу&lt;/a&gt; для более подробной информации.</target>
        </trans-unit>
        <trans-unit id="924c96483cec1214b829647e918270a4c12cbe49" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;GeneratorState&lt;/code&gt; enum returned from this function indicates what state the generator is in upon returning. If the &lt;code&gt;Yielded&lt;/code&gt; variant is returned then the generator has reached a suspension point and a value has been yielded out. Generators in this state are available for resumption at a later point.</source>
          <target state="translated">&lt;code&gt;GeneratorState&lt;/code&gt; перечисление вернулся из этой функции указывает на то, в каком состоянии генератор находится в по возвращении. Если &lt;code&gt;Yielded&lt;/code&gt; вариант &amp;laquo; Урожайный&amp;raquo;, то генератор достиг точки приостановки и значение было выдано. Генераторы в этом состоянии доступны для возобновления позже.</target>
        </trans-unit>
        <trans-unit id="93144a0b07feb0dfc814fce370a7ec1878fc8518" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;GlobalAlloc&lt;/code&gt; trait is an &lt;code&gt;unsafe&lt;/code&gt; trait for a number of reasons, and implementors must ensure that they adhere to these contracts:</source>
          <target state="translated">&lt;code&gt;GlobalAlloc&lt;/code&gt; черта является &lt;code&gt;unsafe&lt;/code&gt; чертой для целого ряда причин, и реализаторы должны гарантировать , что они придерживаются этих договоров:</target>
        </trans-unit>
        <trans-unit id="ac746bf118e800d6204d1b9be35a781fccfa8fc0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Hash&lt;/code&gt; trait allows you to take an instance of a type of arbitrary size and map that instance to a value of fixed size using a hash function. Deriving &lt;code&gt;Hash&lt;/code&gt; implements the &lt;code&gt;hash&lt;/code&gt; method. The derived implementation of the &lt;code&gt;hash&lt;/code&gt; method combines the result of calling &lt;code&gt;hash&lt;/code&gt; on each of the parts of the type, meaning all fields or values must also implement &lt;code&gt;Hash&lt;/code&gt; to derive &lt;code&gt;Hash&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Hash&lt;/code&gt; черта позволяет взять экземпляр типа произвольного размера и сопоставить этот экземпляр до значения фиксированного размера с использованием хэш - функции. Получение &lt;code&gt;Hash&lt;/code&gt; реализует &lt;code&gt;hash&lt;/code&gt; метод. Производная реализация метода &lt;code&gt;hash&lt;/code&gt; объединяет результат вызова &lt;code&gt;hash&lt;/code&gt; для каждой из частей типа, что означает, что все поля или значения также должны реализовывать &lt;code&gt;Hash&lt;/code&gt; для получения &lt;code&gt;Hash&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="cc2c322c74118357f702bcbb43acd3519194cb4e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Iterator&lt;/code&gt; trait has a number of different methods with default implementations provided by the standard library; you can find out about these methods by looking in the standard library API documentation for the &lt;code&gt;Iterator&lt;/code&gt; trait. Some of these methods call the &lt;code&gt;next&lt;/code&gt; method in their definition, which is why you&amp;rsquo;re required to implement the &lt;code&gt;next&lt;/code&gt; method when implementing the &lt;code&gt;Iterator&lt;/code&gt; trait.</source>
          <target state="translated">У &lt;code&gt;Iterator&lt;/code&gt; есть несколько различных методов, реализация которых по умолчанию предоставляется стандартной библиотекой; вы можете узнать об этих методах, просмотрев документацию API стандартной библиотеки для &lt;code&gt;Iterator&lt;/code&gt; . Некоторые из этих методов вызывают &lt;code&gt;next&lt;/code&gt; метод в своем определении, поэтому вам необходимо реализовать &lt;code&gt;next&lt;/code&gt; метод при реализации трейта &lt;code&gt;Iterator&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d7674b68a4f6af8a05d48508e05e8b51cf5d1646" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Iterator&lt;/code&gt; trait only requires implementors to define one method: the &lt;code&gt;next&lt;/code&gt; method, which returns one item of the iterator at a time wrapped in &lt;code&gt;Some&lt;/code&gt; and, when iteration is over, returns &lt;code&gt;None&lt;/code&gt;.</source>
          <target state="translated">Для &lt;code&gt;Iterator&lt;/code&gt; требуется, чтобы разработчики определяли только один метод: метод &lt;code&gt;next&lt;/code&gt; , который возвращает один элемент итератора за раз, заключенный в &lt;code&gt;Some&lt;/code&gt; , и, когда итерация завершена, возвращает &lt;code&gt;None&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f9025083930c31cf7871ed20937306b52f26761a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;LinkedList&lt;/code&gt; allows pushing and popping elements at either end in constant time.</source>
          <target state="translated">&lt;code&gt;LinkedList&lt;/code&gt; позволяет нажимать и выскакивают элементы на обоих концах в постоянное время.</target>
        </trans-unit>
        <trans-unit id="4baf38aed9bf1ffe36a931bbfb0cb77e6aa0a43b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;LowerExp&lt;/code&gt; trait should format its output in scientific notation with a lower-case &lt;code&gt;e&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;LowerExp&lt;/code&gt; черта должна форматировать свой вывод в научной нотации с строчным &lt;code&gt;e&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="dc66d9062a365376bc4e9ff4cb202550c7cc32a7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;LowerHex&lt;/code&gt; trait should format its output as a number in hexadecimal, with &lt;code&gt;a&lt;/code&gt; through &lt;code&gt;f&lt;/code&gt; in lower case.</source>
          <target state="translated">&lt;code&gt;LowerHex&lt;/code&gt; черта должна форматировать свой выход как число в шестнадцатеричной системе , с через &lt;code&gt;f&lt;/code&gt; в нижнем регистре. &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="3b321c2a56af633f328bf4b8ba254ce361d7a954" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Octal&lt;/code&gt; trait should format its output as a number in base-8.</source>
          <target state="translated">Свойство &lt;code&gt;Octal&lt;/code&gt; должно форматировать свой вывод как число с основанием 8.</target>
        </trans-unit>
        <trans-unit id="eb10a578affd8a62e12f3ef265b344e167e3dcf6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt; enum is so useful that it&amp;rsquo;s even included in the prelude; you don&amp;rsquo;t need to bring it into scope explicitly. In addition, so are its variants: you can use &lt;code&gt;Some&lt;/code&gt; and &lt;code&gt;None&lt;/code&gt; directly without the &lt;code&gt;Option::&lt;/code&gt; prefix. The &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt; enum is still just a regular enum, and &lt;code&gt;Some(T)&lt;/code&gt; and &lt;code&gt;None&lt;/code&gt; are still variants of type &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt; перечисление настолько полезно , что он даже включен в прелюдии; вам не нужно явно вводить его в область видимости. Кроме того, таковы его варианты: вы можете использовать &lt;code&gt;Some&lt;/code&gt; и &lt;code&gt;None&lt;/code&gt; напрямую без префикса &lt;code&gt;Option::&lt;/code&gt; . &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt; перечисление еще только регулярные перечисления, а &lt;code&gt;Some(T)&lt;/code&gt; и &lt;code&gt;None&lt;/code&gt; еще варианты типа &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="757a8b38147115f7267a95ffaa6fac00dcad6a55" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Option&lt;/code&gt; type. See &lt;a href=&quot;index&quot;&gt;the module level documentation&lt;/a&gt; for more.</source>
          <target state="translated">Тип &lt;code&gt;Option&lt;/code&gt; . Дополнительную информацию см. &lt;a href=&quot;index&quot;&gt;В документации уровня модуля&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="6ec87aec96d36200bb49beb7ba67c5c626bb7aad" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Ord&lt;/code&gt; trait allows you to know that for any two values of the annotated type, a valid ordering will exist. The &lt;code&gt;Ord&lt;/code&gt; trait implements the &lt;code&gt;cmp&lt;/code&gt; method, which returns an &lt;code&gt;Ordering&lt;/code&gt; rather than an &lt;code&gt;Option&amp;lt;Ordering&amp;gt;&lt;/code&gt; because a valid ordering will always be possible. You can only apply the &lt;code&gt;Ord&lt;/code&gt; trait to types that also implement &lt;code&gt;PartialOrd&lt;/code&gt; and &lt;code&gt;Eq&lt;/code&gt; (and &lt;code&gt;Eq&lt;/code&gt; requires &lt;code&gt;PartialEq&lt;/code&gt;). When derived on structs and enums, &lt;code&gt;cmp&lt;/code&gt; behaves the same way as the derived implementation for &lt;code&gt;partial_cmp&lt;/code&gt; does with &lt;code&gt;PartialOrd&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Ord&lt;/code&gt; черта позволяет знать , что для любых двух значений аннотированного типа, действующий порядок будет существовать. &lt;code&gt;Ord&lt;/code&gt; черта реализует &lt;code&gt;cmp&lt;/code&gt; метод, который возвращает &lt;code&gt;Ordering&lt;/code&gt; , а не &lt;code&gt;Option&amp;lt;Ordering&amp;gt;&lt;/code&gt; , так как действительный заказ всегда будет возможно. &lt;code&gt;PartialOrd&lt;/code&gt; &lt;code&gt;Ord&lt;/code&gt; можно применять только к типам, которые также реализуют PartialOrd и &lt;code&gt;Eq&lt;/code&gt; (а &lt;code&gt;Eq&lt;/code&gt; требует &lt;code&gt;PartialEq&lt;/code&gt; ). Будучи производным от структур и перечислений, &lt;code&gt;cmp&lt;/code&gt; ведет себя так же, как производная реализация для &lt;code&gt;partial_cmp&lt;/code&gt; с &lt;code&gt;PartialOrd&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="711a8eb9ad73721345ff8b7d5d49057eb05ba2c2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Orphan Check&lt;/code&gt; states that every trait implementation must meet either of the following conditions:</source>
          <target state="translated">В &lt;code&gt;Orphan Check&lt;/code&gt; состояния , что каждая реализация черты должна соответствовать одному из следующих условий:</target>
        </trans-unit>
        <trans-unit id="c00d178bf6b2317cc12ea4871792b476ee2d6ac7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;PartialEq&lt;/code&gt; trait allows you to compare instances of a type to check for equality and enables use of the &lt;code&gt;==&lt;/code&gt; and &lt;code&gt;!=&lt;/code&gt; operators.</source>
          <target state="translated">&lt;code&gt;PartialEq&lt;/code&gt; черта позволяет сравнивать экземпляры типа для проверки равенства и разрешает использование &lt;code&gt;==&lt;/code&gt; и &lt;code&gt;!=&lt;/code&gt; Операторов.</target>
        </trans-unit>
        <trans-unit id="43e89dc3eb492904f3da074b02b2cf97b105430c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;PartialEq&lt;/code&gt; trait is required, for example, with the use of the &lt;code&gt;assert_eq!&lt;/code&gt; macro, which needs to be able to compare two instances of a type for equality.</source>
          <target state="translated">&lt;code&gt;PartialEq&lt;/code&gt; черта требуется, например, с использованием &lt;code&gt;assert_eq!&lt;/code&gt; макрос, который должен иметь возможность сравнивать два экземпляра типа на равенство.</target>
        </trans-unit>
        <trans-unit id="a3b5763e3772b503d126748c966660daf7b02e86" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;PartialOrd&lt;/code&gt; trait allows you to compare instances of a type for sorting purposes. A type that implements &lt;code&gt;PartialOrd&lt;/code&gt; can be used with the &lt;code&gt;&amp;lt;&lt;/code&gt;, &lt;code&gt;&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;=&lt;/code&gt;, and &lt;code&gt;&amp;gt;=&lt;/code&gt; operators. You can only apply the &lt;code&gt;PartialOrd&lt;/code&gt; trait to types that also implement &lt;code&gt;PartialEq&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;PartialOrd&lt;/code&gt; черта позволяет сравнивать экземпляры типа для сортировки целей. Тип, реализующий &lt;code&gt;PartialOrd&lt;/code&gt; , можно использовать с операторами &lt;code&gt;&amp;lt;&lt;/code&gt; , &lt;code&gt;&amp;gt;&lt;/code&gt; , &lt;code&gt;&amp;lt;=&lt;/code&gt; и &lt;code&gt;&amp;gt;=&lt;/code&gt; . &lt;code&gt;PartialOrd&lt;/code&gt; можно применять только к типам, которые также реализуют &lt;code&gt;PartialEq&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d44604638bc3e14fe0790aae9645322a35831c38" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;PartialOrd&lt;/code&gt; trait is required, for example, for the &lt;code&gt;gen_range&lt;/code&gt; method from the &lt;code&gt;rand&lt;/code&gt; crate that generates a random value in the range specified by a low value and a high value.</source>
          <target state="translated">&lt;code&gt;PartialOrd&lt;/code&gt; черта не требуется, например, для &lt;code&gt;gen_range&lt;/code&gt; метода из &lt;code&gt;rand&lt;/code&gt; ящика , который генерирует случайное значение в диапазоне , заданный низкое значением и высокой стоимостью.</target>
        </trans-unit>
        <trans-unit id="aa9b33d349ddf99a4aba8a405103bf7fb4c6e253" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Pointer&lt;/code&gt; trait should format its output as a memory location. This is commonly presented as hexadecimal.</source>
          <target state="translated">Свойство &lt;code&gt;Pointer&lt;/code&gt; должно форматировать свой вывод как ячейку памяти. Обычно это представляется в шестнадцатеричном формате.</target>
        </trans-unit>
        <trans-unit id="ab8bbad2b08fc48ec0e5ed2730d22da62501a267" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Range&lt;/code&gt;&lt;code&gt;start..end&lt;/code&gt; contains all values with &lt;code&gt;x &amp;gt;= start&lt;/code&gt; and &lt;code&gt;x &amp;lt; end&lt;/code&gt;. It is empty unless &lt;code&gt;start &amp;lt; end&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Range&lt;/code&gt; &lt;code&gt;start..end&lt;/code&gt; содержит все значения с &lt;code&gt;x &amp;gt;= start&lt;/code&gt; и &lt;code&gt;x &amp;lt; end&lt;/code&gt; . Он пуст, если только &lt;code&gt;start &amp;lt; end&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b2aa0761be84214baf72bdc665e4aaa54d88ab96" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;RangeFrom&lt;/code&gt;&lt;code&gt;start..&lt;/code&gt; contains all values with &lt;code&gt;x &amp;gt;= start&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;RangeFrom&lt;/code&gt; &lt;code&gt;start..&lt;/code&gt; содержит все значения с &lt;code&gt;x &amp;gt;= start&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="73c149dd90366bce823890f694cf867f1bb0a225" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;RangeInclusive&lt;/code&gt;&lt;code&gt;start..=end&lt;/code&gt; contains all values with &lt;code&gt;x &amp;gt;= start&lt;/code&gt; and &lt;code&gt;x &amp;lt;= end&lt;/code&gt;. It is empty unless &lt;code&gt;start &amp;lt;= end&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;RangeInclusive&lt;/code&gt; &lt;code&gt;start..=end&lt;/code&gt; содержит все значения с &lt;code&gt;x &amp;gt;= start&lt;/code&gt; и &lt;code&gt;x &amp;lt;= end&lt;/code&gt; . Он пуст, если только &lt;code&gt;start &amp;lt;= end&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0cec61b7c44a745e689ab10fff029089cd54c5d0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;RangeTo&lt;/code&gt;&lt;code&gt;..end&lt;/code&gt; contains all values with &lt;code&gt;x &amp;lt; end&lt;/code&gt;. It cannot serve as an &lt;a href=&quot;../iter/trait.intoiterator&quot;&gt;&lt;code&gt;Iterator&lt;/code&gt;&lt;/a&gt; because it doesn't have a starting point.</source>
          <target state="translated">&lt;code&gt;RangeTo&lt;/code&gt; &lt;code&gt;..end&lt;/code&gt; содержит все значения с &lt;code&gt;x &amp;lt; end&lt;/code&gt; . Он не может служить &lt;a href=&quot;../iter/trait.intoiterator&quot;&gt; &lt;code&gt;Iterator&lt;/code&gt; &lt;/a&gt; потому что у него нет отправной точки.</target>
        </trans-unit>
        <trans-unit id="0de78a1c773797166ef937a052ccd5e9331c867f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;RangeTo&lt;/code&gt;&lt;code&gt;..end&lt;/code&gt; contains all values with &lt;code&gt;x &amp;lt; end&lt;/code&gt;. It cannot serve as an &lt;a href=&quot;../iter/trait.iterator&quot;&gt;&lt;code&gt;Iterator&lt;/code&gt;&lt;/a&gt; because it doesn't have a starting point.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8e2d4326e8450b1f620c09e80702de680708776b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;RangeToInclusive&lt;/code&gt;&lt;code&gt;..=end&lt;/code&gt; contains all values with &lt;code&gt;x &amp;lt;= end&lt;/code&gt;. It cannot serve as an &lt;a href=&quot;../iter/trait.intoiterator&quot;&gt;&lt;code&gt;Iterator&lt;/code&gt;&lt;/a&gt; because it doesn't have a starting point.</source>
          <target state="translated">&lt;code&gt;RangeToInclusive&lt;/code&gt; &lt;code&gt;..=end&lt;/code&gt; содержит все значения с &lt;code&gt;x &amp;lt;= end&lt;/code&gt; . Он не может служить &lt;a href=&quot;../iter/trait.intoiterator&quot;&gt; &lt;code&gt;Iterator&lt;/code&gt; &lt;/a&gt; потому что у него нет отправной точки.</target>
        </trans-unit>
        <trans-unit id="0729997e88bb0119e0af233dfbcdefc61396cf4d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;RangeToInclusive&lt;/code&gt;&lt;code&gt;..=end&lt;/code&gt; contains all values with &lt;code&gt;x &amp;lt;= end&lt;/code&gt;. It cannot serve as an &lt;a href=&quot;../iter/trait.iterator&quot;&gt;&lt;code&gt;Iterator&lt;/code&gt;&lt;/a&gt; because it doesn't have a starting point.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ebdc80637c460a3fe51040149db057ee546f653a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Rc::clone(&amp;amp;from)&lt;/code&gt; syntax is the most idiomatic because it conveys more explicitly the meaning of the code. In the example above, this syntax makes it easier to see that this code is creating a new reference rather than copying the whole content of foo.</source>
          <target state="translated">&lt;code&gt;Rc::clone(&amp;amp;from)&lt;/code&gt; синтаксис наиболее идиоматических , поскольку она передает более явно значение кода. В приведенном выше примере этот синтаксис помогает увидеть, что этот код создает новую ссылку, а не копирует все содержимое foo.</target>
        </trans-unit>
        <trans-unit id="d18566a4555f118c35b2f7296c41294a80e62f05" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Read&lt;/code&gt; trait allows for reading bytes from a source.</source>
          <target state="translated">&lt;code&gt;Read&lt;/code&gt; черта позволяет для чтения байтов из источника.</target>
        </trans-unit>
        <trans-unit id="167de79249a0cb690644cc2f30f26fd674ac84c4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt; keeps track of how many &lt;code&gt;Ref&amp;lt;T&amp;gt;&lt;/code&gt; and &lt;code&gt;RefMut&amp;lt;T&amp;gt;&lt;/code&gt; smart pointers are currently active. Every time we call &lt;code&gt;borrow&lt;/code&gt;, the &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt; increases its count of how many immutable borrows are active. When a &lt;code&gt;Ref&amp;lt;T&amp;gt;&lt;/code&gt; value goes out of scope, the count of immutable borrows goes down by one. Just like the compile-time borrowing rules, &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt; lets us have many immutable borrows or one mutable borrow at any point in time.</source>
          <target state="translated">&lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt; отслеживает , сколько &lt;code&gt;Ref&amp;lt;T&amp;gt;&lt;/code&gt; и &lt;code&gt;RefMut&amp;lt;T&amp;gt;&lt;/code&gt; смарт - указатели в настоящее время активны. Каждый раз, когда мы вызываем &lt;code&gt;borrow&lt;/code&gt; , &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt; увеличивает количество активных неизменяемых заимствований. Когда значение &lt;code&gt;Ref&amp;lt;T&amp;gt;&lt;/code&gt; выходит за пределы области видимости, количество неизменяемых заимствований уменьшается на единицу. Как и правила заимствования во время компиляции, &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt; позволяет нам иметь множество неизменяемых заимствований или одно изменяемое заимствование в любой момент времени.</target>
        </trans-unit>
        <trans-unit id="2e6771afd6b14e03fc38f6d16106ee1f97bd4cbd" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;RefCell&lt;/code&gt; is already immutably borrowed, so this cannot fail.</source>
          <target state="translated">&lt;code&gt;RefCell&lt;/code&gt; уже непреложно заимствованные, так что это не может потерпеть неудачу.</target>
        </trans-unit>
        <trans-unit id="c305974ea6149ae71e2c43fcd219e993594dd96e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;RefCell&lt;/code&gt; is already mutably borrowed, so this cannot fail.</source>
          <target state="translated">&lt;code&gt;RefCell&lt;/code&gt; уже mutably заимствованные, так что это не может потерпеть неудачу.</target>
        </trans-unit>
        <trans-unit id="52b1edfc20b8e3433cc429a2a34dab08626e2ce2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Result&amp;lt;..., Error&amp;gt;&lt;/code&gt; is repeated a lot. As such, &lt;code&gt;std::io&lt;/code&gt; has this type of alias declaration:</source>
          <target state="translated">&lt;code&gt;Result&amp;lt;..., Error&amp;gt;&lt;/code&gt; повторяется много. Таким образом, &lt;code&gt;std::io&lt;/code&gt; имеет такой тип объявления псевдонима:</target>
        </trans-unit>
        <trans-unit id="1e71572578c618ddeccc701e84d14574b4552896" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Result&lt;/code&gt; enum is generic over two types, &lt;code&gt;T&lt;/code&gt; and &lt;code&gt;E&lt;/code&gt;, and has two variants: &lt;code&gt;Ok&lt;/code&gt;, which holds a value of type &lt;code&gt;T&lt;/code&gt;, and &lt;code&gt;Err&lt;/code&gt;, which holds a value of type &lt;code&gt;E&lt;/code&gt;. This definition makes it convenient to use the &lt;code&gt;Result&lt;/code&gt; enum anywhere we have an operation that might succeed (return a value of some type &lt;code&gt;T&lt;/code&gt;) or fail (return an error of some type &lt;code&gt;E&lt;/code&gt;). In fact, this is what we used to open a file in Listing 9-3, where &lt;code&gt;T&lt;/code&gt; was filled in with the type &lt;code&gt;std::fs::File&lt;/code&gt; when the file was opened successfully and &lt;code&gt;E&lt;/code&gt; was filled in with the type &lt;code&gt;std::io::Error&lt;/code&gt; when there were problems opening the file.</source>
          <target state="translated">&lt;code&gt;Result&lt;/code&gt; перечисление является общим более двумя типов, &lt;code&gt;T&lt;/code&gt; и &lt;code&gt;E&lt;/code&gt; , и имеет два варианта: &lt;code&gt;Ok&lt;/code&gt; , который содержит значение типа &lt;code&gt;T&lt;/code&gt; , и &lt;code&gt;Err&lt;/code&gt; , который содержит значение типа &lt;code&gt;E&lt;/code&gt; . Это определение позволяет использовать перечисление &lt;code&gt;Result&lt;/code&gt; везде, где есть операция, которая может завершиться успешно (вернуть значение некоторого типа &lt;code&gt;T&lt;/code&gt; ) или потерпеть неудачу (вернуть ошибку некоторого типа &lt;code&gt;E&lt;/code&gt; ). Фактически, это то, что мы использовали для открытия файла в листинге 9-3, где &lt;code&gt;T&lt;/code&gt; был заполнен типом &lt;code&gt;std::fs::File&lt;/code&gt; когда файл был успешно открыт, а &lt;code&gt;E&lt;/code&gt; был заполнен типом &lt;code&gt;std::io::Error&lt;/code&gt; когда возникали проблемы с открытием файла.</target>
        </trans-unit>
        <trans-unit id="67d17ec2155cc71f4cbd159b4631b04d17855080" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Result&lt;/code&gt; types are &lt;a href=&quot;ch06-00-enums&quot;&gt;&lt;em&gt;enumerations&lt;/em&gt;&lt;/a&gt;, often referred to as &lt;em&gt;enums&lt;/em&gt;. An enumeration is a type that can have a fixed set of values, and those values are called the enum&amp;rsquo;s &lt;em&gt;variants&lt;/em&gt;. Chapter 6 will cover enums in more detail.</source>
          <target state="translated">В &lt;code&gt;Result&lt;/code&gt; типов &lt;a href=&quot;ch06-00-enums&quot;&gt;&lt;em&gt;перечисления&lt;/em&gt;&lt;/a&gt; , которые часто называют &lt;em&gt;перечислениями&lt;/em&gt; . Перечисление - это тип, который может иметь фиксированный набор значений, и эти значения называются &lt;em&gt;вариантами&lt;/em&gt; перечисления . В главе 6 перечисления рассматриваются более подробно.</target>
        </trans-unit>
        <trans-unit id="64d4c779a9a53da0609d26369514238e751f0a8e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Seek&lt;/code&gt; trait provides a cursor which can be moved within a stream of bytes.</source>
          <target state="translated">Свойство &lt;code&gt;Seek&lt;/code&gt; предоставляет курсор, который можно перемещать в потоке байтов.</target>
        </trans-unit>
        <trans-unit id="45132395a8da1a9af17f15db9b29d073d0c74c5d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Self&lt;/code&gt; keyword is an alias for the type we&amp;rsquo;re implementing the traits or methods on. Trait objects must be object safe because once you&amp;rsquo;ve used a trait object, Rust no longer knows the concrete type that&amp;rsquo;s implementing that trait. If a trait method returns the concrete &lt;code&gt;Self&lt;/code&gt; type, but a trait object forgets the exact type that &lt;code&gt;Self&lt;/code&gt; is, there is no way the method can use the original concrete type. The same is true of generic type parameters that are filled in with concrete type parameters when the trait is used: the concrete types become part of the type that implements the trait. When the type is forgotten through the use of a trait object, there is no way to know what types to fill in the generic type parameters with.</source>
          <target state="translated">&lt;code&gt;Self&lt;/code&gt; ключевое слово является псевдонимом типа мы реализующей черты или методы на. Объекты-черты должны быть объектно-безопасными, потому что после того, как вы использовали объект-черту, Rust больше не знает конкретный тип, реализующий эту черту. Если метод признака возвращает конкретный тип &lt;code&gt;Self&lt;/code&gt; , но объект признака забывает точный тип, которым является &lt;code&gt;Self&lt;/code&gt; , метод не может использовать исходный конкретный тип. То же самое верно для параметров универсального типа, которые заполняются параметрами конкретного типа при использовании признака: конкретные типы становятся частью типа, реализующего признак. Когда тип забывается из-за использования объекта-признака, невозможно узнать, какими типами заполнять параметры универсального типа.</target>
        </trans-unit>
        <trans-unit id="90a76b71efb75f391d26231783f81feb6c797a7f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Self&lt;/code&gt; keyword represents the current type, which explains why it can only be used inside an impl, trait, or type definition. It gives access to the associated items of a type:</source>
          <target state="translated">&lt;code&gt;Self&lt;/code&gt; ключевое слово представляет текущий тип, который объясняет , почему он может быть использован только внутри осущий, признак или определений типа. Он дает доступ к связанным элементам типа:</target>
        </trans-unit>
        <trans-unit id="a02332e854d71300403fa93482ff8605d97eadb6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Self&lt;/code&gt; keyword was used outside an impl, trait, or type definition.</source>
          <target state="translated">&lt;code&gt;Self&lt;/code&gt; ключевое слово использовалось за пределами осущ, признака или определения типа.</target>
        </trans-unit>
        <trans-unit id="6a3c6ecd1deb9539342b4b667c8f7da5207114d0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Self&lt;/code&gt; term can be replaced with the type being implemented.</source>
          <target state="translated">&lt;code&gt;Self&lt;/code&gt; термин может быть заменен на тип реализуется.</target>
        </trans-unit>
        <trans-unit id="268068ec98ee8d589f1d0d25a4fa87cb52fefae1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Self&lt;/code&gt; terminal in this grammar denotes a type resolving to the implementing type. This can also include the contextual type alias &lt;code&gt;Self&lt;/code&gt;, other type aliases, or associated type projections resolving to the implementing type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5d50619fe26b234beecf764a55ec164440b77b3f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Send&lt;/code&gt; marker trait indicates that ownership of the type implementing &lt;code&gt;Send&lt;/code&gt; can be transferred between threads. Almost every Rust type is &lt;code&gt;Send&lt;/code&gt;, but there are some exceptions, including &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt;: this cannot be &lt;code&gt;Send&lt;/code&gt; because if you cloned an &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; value and tried to transfer ownership of the clone to another thread, both threads might update the reference count at the same time. For this reason, &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; is implemented for use in single-threaded situations where you don&amp;rsquo;t want to pay the thread-safe performance penalty.</source>
          <target state="translated">Характеристика маркера &lt;code&gt;Send&lt;/code&gt; указывает, что владение типом, реализующим &lt;code&gt;Send&lt;/code&gt; может передаваться между потоками. Почти каждый тип Rust - это &lt;code&gt;Send&lt;/code&gt; , но есть некоторые исключения, в том числе &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; : это не может быть &lt;code&gt;Send&lt;/code&gt; , потому что если вы клонировали значение &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; и попытались передать право собственности на клон другому потоку, оба потока могут обновить количество ссылок одновременно. По этой причине &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; реализован для использования в однопоточных ситуациях, когда вы не хотите платить за поточно-безопасную производительность.</target>
        </trans-unit>
        <trans-unit id="da7504f8cf4ba12a9f166abe295fe49d0cc29f7f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Sized&lt;/code&gt; trait is a special trait built-in to the compiler for types with a constant size known at compile-time. This trait is automatically implemented for types as needed by the compiler, and it is currently disallowed to explicitly implement it for a type.</source>
          <target state="translated">&lt;code&gt;Sized&lt;/code&gt; черта является особой чертой , встроенной в компилятор для типов с постоянным размером , известным во время компиляции. Эта черта автоматически реализуется для типов по мере необходимости компилятора, и в настоящее время запрещено явно реализовывать ее для типа.</target>
        </trans-unit>
        <trans-unit id="faed9283b4f09789ea3439cf47c62be8b01765b4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Sized&lt;/code&gt; trait was implemented explicitly.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="57ed07b6ec3a8248f3dbedbfe819f564dab9a89c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Some(5)&lt;/code&gt; value doesn&amp;rsquo;t match the pattern &lt;code&gt;None&lt;/code&gt;, so we continue to the next arm.</source>
          <target state="translated">Значение &lt;code&gt;Some(5)&lt;/code&gt; не соответствует шаблону &lt;code&gt;None&lt;/code&gt; , поэтому мы переходим к следующей руке.</target>
        </trans-unit>
        <trans-unit id="5cf7d1bcd1b02d8684f384aeb150bd3c1fada36f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;State&lt;/code&gt; trait defines the behavior shared by different post states, and the &lt;code&gt;Draft&lt;/code&gt;, &lt;code&gt;PendingReview&lt;/code&gt;, and &lt;code&gt;Published&lt;/code&gt; states will all implement the &lt;code&gt;State&lt;/code&gt; trait. For now, the trait doesn&amp;rsquo;t have any methods, and we&amp;rsquo;ll start by defining just the &lt;code&gt;Draft&lt;/code&gt; state because that is the state we want a post to start in.</source>
          <target state="translated">&lt;code&gt;State&lt;/code&gt; черт определяет поведение совместно различными почтовые государствами, и &lt;code&gt;Draft&lt;/code&gt; , &lt;code&gt;PendingReview&lt;/code&gt; и &lt;code&gt;Published&lt;/code&gt; государства будут все реализовать &lt;code&gt;State&lt;/code&gt; черту. На данный момент у трейта нет никаких методов, и мы начнем с определения только состояния &lt;code&gt;Draft&lt;/code&gt; , потому что это состояние, в котором мы хотим, чтобы публикация начиналась.</target>
        </trans-unit>
        <trans-unit id="a99c80ac2ff235e2978574f670cbd4660bb61703" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;String&lt;/code&gt; type implements the &lt;code&gt;Clone&lt;/code&gt; trait, and when we call the &lt;code&gt;clone&lt;/code&gt; method on an instance of &lt;code&gt;String&lt;/code&gt; we get back an instance of &lt;code&gt;String&lt;/code&gt;. Similarly, if we call &lt;code&gt;clone&lt;/code&gt; on an instance of &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt;, we get back an instance of &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt;. The signature of &lt;code&gt;clone&lt;/code&gt; needs to know what type will stand in for &lt;code&gt;Self&lt;/code&gt;, because that&amp;rsquo;s the return type.</source>
          <target state="translated">Тип &lt;code&gt;String&lt;/code&gt; реализует черту &lt;code&gt;Clone&lt;/code&gt; , и когда мы вызываем метод &lt;code&gt;clone&lt;/code&gt; для экземпляра &lt;code&gt;String&lt;/code&gt; , мы получаем обратно экземпляр &lt;code&gt;String&lt;/code&gt; . Точно так же, если мы вызываем &lt;code&gt;clone&lt;/code&gt; для экземпляра &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; , мы возвращаем экземпляр &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; . Сигнатура &lt;code&gt;clone&lt;/code&gt; должна знать, какой тип будет заменять &lt;code&gt;Self&lt;/code&gt; , потому что это тип возвращаемого значения.</target>
        </trans-unit>
        <trans-unit id="ce3a0f98cdb5c97fe7ff53bab286ef96b0a0614f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;String&lt;/code&gt; type is the most common string type that has ownership over the contents of the string. It has a close relationship with its borrowed counterpart, the primitive &lt;a href=&quot;../primitive.str&quot;&gt;&lt;code&gt;str&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Тип &lt;code&gt;String&lt;/code&gt; является наиболее распространенным типом строки, который владеет содержимым строки. Он имеет тесную связь со своим заимствованным аналогом, примитивной &lt;a href=&quot;../primitive.str&quot;&gt; &lt;code&gt;str&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="75cb7ba1e6deab5f4a0c4ef1dddcb7ea6d8d2520" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;String&lt;/code&gt; type, which is provided by Rust&amp;rsquo;s standard library rather than coded into the core language, is a growable, mutable, owned, UTF-8 encoded string type. When Rustaceans refer to &amp;ldquo;strings&amp;rdquo; in Rust, they usually mean the &lt;code&gt;String&lt;/code&gt; and the string slice &lt;code&gt;&amp;amp;str&lt;/code&gt; types, not just one of those types. Although this section is largely about &lt;code&gt;String&lt;/code&gt;, both types are used heavily in Rust&amp;rsquo;s standard library, and both &lt;code&gt;String&lt;/code&gt; and string slices are UTF-8 encoded.</source>
          <target state="translated">Тип &lt;code&gt;String&lt;/code&gt; , который предоставляется стандартной библиотекой Rust, а не закодирован на базовом языке, является растущим, изменяемым, принадлежащим типом строки в кодировке UTF-8. Когда Rustaceans ссылаются на &amp;laquo;строки&amp;raquo; в Rust, они обычно имеют в виду типы &lt;code&gt;String&lt;/code&gt; и string slice &lt;code&gt;&amp;amp;str&lt;/code&gt; , а не только один из этих типов. Хотя этот раздел в основном посвящен &lt;code&gt;String&lt;/code&gt; , оба типа широко используются в стандартной библиотеке Rust, и как &lt;code&gt;String&lt;/code&gt; ,так и строковые срезы имеют кодировку UTF-8.</target>
        </trans-unit>
        <trans-unit id="e2f29f1c300ba36b21c6a01062d991f47ee83fd6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Sync&lt;/code&gt; and &lt;code&gt;Send&lt;/code&gt; traits, which extend Rust&amp;rsquo;s concurrency guarantees to user-defined types as well as types provided by the standard library</source>
          <target state="translated">В &lt;code&gt;Sync&lt;/code&gt; и &lt;code&gt;Send&lt;/code&gt; черты, которые расширяют параллелизм гарантии Ржавчина на определяемые пользователем типы, а также видов предоставляемых стандартной библиотеки</target>
        </trans-unit>
        <trans-unit id="546dfd59f5dde2a2d3bad5396a6d76cbe9696aee" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Sync&lt;/code&gt; marker trait indicates that it is safe for the type implementing &lt;code&gt;Sync&lt;/code&gt; to be referenced from multiple threads. In other words, any type &lt;code&gt;T&lt;/code&gt; is &lt;code&gt;Sync&lt;/code&gt; if &lt;code&gt;&amp;amp;T&lt;/code&gt; (a reference to &lt;code&gt;T&lt;/code&gt;) is &lt;code&gt;Send&lt;/code&gt;, meaning the reference can be sent safely to another thread. Similar to &lt;code&gt;Send&lt;/code&gt;, primitive types are &lt;code&gt;Sync&lt;/code&gt;, and types composed entirely of types that are &lt;code&gt;Sync&lt;/code&gt; are also &lt;code&gt;Sync&lt;/code&gt;.</source>
          <target state="translated">Характеристика &lt;code&gt;Sync&lt;/code&gt; marker указывает, что для типа, реализующего &lt;code&gt;Sync&lt;/code&gt; , можно безопасно ссылаться из нескольких потоков. Другими словами, любой тип &lt;code&gt;T&lt;/code&gt; - это &lt;code&gt;Sync&lt;/code&gt; , если &lt;code&gt;&amp;amp;T&lt;/code&gt; (ссылка на &lt;code&gt;T&lt;/code&gt; ) - это &lt;code&gt;Send&lt;/code&gt; , что означает, что ссылку можно безопасно отправить в другой поток. Подобно &lt;code&gt;Send&lt;/code&gt; , примитивные типы - это &lt;code&gt;Sync&lt;/code&gt; , а типы, полностью состоящие из типов, которые являются &lt;code&gt;Sync&lt;/code&gt; , также являются &lt;code&gt;Sync&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="646e9a46a3198e5aae6cea0647712ac157d7125f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;T&lt;/code&gt; and &lt;code&gt;E&lt;/code&gt; are generic type parameters: we&amp;rsquo;ll discuss generics in more detail in Chapter 10. What you need to know right now is that &lt;code&gt;T&lt;/code&gt; represents the type of the value that will be returned in a success case within the &lt;code&gt;Ok&lt;/code&gt; variant, and &lt;code&gt;E&lt;/code&gt; represents the type of the error that will be returned in a failure case within the &lt;code&gt;Err&lt;/code&gt; variant. Because &lt;code&gt;Result&lt;/code&gt; has these generic type parameters, we can use the &lt;code&gt;Result&lt;/code&gt; type and the functions that the standard library has defined on it in many different situations where the successful value and error value we want to return may differ.</source>
          <target state="translated">&lt;code&gt;T&lt;/code&gt; и &lt;code&gt;E&lt;/code&gt; являются общими параметрами типа: мы обсудим дженерик более подробно в главе 10. То , что вы должны знать , прямо сейчас, что &lt;code&gt;T&lt;/code&gt; представляет тип значения , которое будет возвращено в случае успеха в &lt;code&gt;Ok&lt;/code&gt; варианта, и &lt;code&gt;E&lt;/code&gt; представляет тип ошибки, которая будет возвращена в случае сбоя в варианте &lt;code&gt;Err&lt;/code&gt; . Поскольку &lt;code&gt;Result&lt;/code&gt; имеет эти параметры универсального типа, мы можем использовать тип &lt;code&gt;Result&lt;/code&gt; и функции, определенные для него стандартной библиотекой, во многих различных ситуациях, когда успешное значение и значение ошибки, которые мы хотим вернуть, могут отличаться.</target>
        </trans-unit>
        <trans-unit id="cb756122c49feafba4692e36792c9ec503818ac1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Thread&lt;/code&gt; type</source>
          <target state="translated">&lt;code&gt;Thread&lt;/code&gt; типа</target>
        </trans-unit>
        <trans-unit id="fadb7c71117e778367444a0d18f0442e8249124b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ThreadPool&lt;/code&gt; will create a channel and hold on to the sending side of the channel.</source>
          <target state="translated">&lt;code&gt;ThreadPool&lt;/code&gt; создаст канал и удерживать на передающей стороне канала.</target>
        </trans-unit>
        <trans-unit id="e48c39ae08cbb88aef00b305b9017512b2fc007b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;UnsafeCell&lt;/code&gt; API itself is technically very simple: &lt;a href=&quot;struct.unsafecell#method.get&quot;&gt;&lt;code&gt;.get()&lt;/code&gt;&lt;/a&gt; gives you a raw pointer &lt;code&gt;*mut T&lt;/code&gt; to its contents. It is up to &lt;em&gt;you&lt;/em&gt; as the abstraction designer to use that raw pointer correctly.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6a5cd0207b32d758dbbf9a6159c66155c77acce0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;UnsafeCell&lt;/code&gt; API itself is technically very simple: it gives you a raw pointer &lt;code&gt;*mut T&lt;/code&gt; to its contents. It is up to &lt;em&gt;you&lt;/em&gt; as the abstraction designer to use that raw pointer correctly.</source>
          <target state="translated">Сам API &lt;code&gt;UnsafeCell&lt;/code&gt; технически очень прост: он дает вам необработанный указатель &lt;code&gt;*mut T&lt;/code&gt; на его содержимое. Правильное использование этого необработанного указателя зависит от &lt;em&gt;вас&lt;/em&gt; как разработчика абстракции.</target>
        </trans-unit>
        <trans-unit id="0a41c6aadefabb63fa74ac6fccd4136ec47ca08f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;UpperExp&lt;/code&gt; trait should format its output in scientific notation with an upper-case &lt;code&gt;E&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;UpperExp&lt;/code&gt; черта должна форматировать свой выход в научной записи с прописной &lt;code&gt;E&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c532f0150ba601cb070b0fc006c6b873d809aeda" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;UpperHex&lt;/code&gt; trait should format its output as a number in hexadecimal, with &lt;code&gt;A&lt;/code&gt; through &lt;code&gt;F&lt;/code&gt; in upper case.</source>
          <target state="translated">Свойство &lt;code&gt;UpperHex&lt;/code&gt; должно форматировать свой вывод как шестнадцатеричное число с буквами от &lt;code&gt;A&lt;/code&gt; до &lt;code&gt;F&lt;/code&gt; в верхнем регистре.</target>
        </trans-unit>
        <trans-unit id="1692dc51a2dd0859a66b3a15d1e8df4859265ffa" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Vec&lt;/code&gt; type allows to access values by index, because it implements the &lt;a href=&quot;../ops/trait.index&quot;&gt;&lt;code&gt;Index&lt;/code&gt;&lt;/a&gt; trait. An example will be more explicit:</source>
          <target state="translated">Тип &lt;code&gt;Vec&lt;/code&gt; позволяет получить доступ к значениям по индексу, поскольку он реализует трейт &lt;a href=&quot;../ops/trait.index&quot;&gt; &lt;code&gt;Index&lt;/code&gt; &lt;/a&gt; . Пример будет более явным:</target>
        </trans-unit>
        <trans-unit id="fdf15f1d79f5be8a81ff6d7d469c446ffbe09215" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;_&lt;/code&gt; pattern will match any value. By putting it after our other arms, the &lt;code&gt;_&lt;/code&gt; will match all the possible cases that aren&amp;rsquo;t specified before it. The &lt;code&gt;()&lt;/code&gt; is just the unit value, so nothing will happen in the &lt;code&gt;_&lt;/code&gt; case. As a result, we can say that we want to do nothing for all the possible values that we don&amp;rsquo;t list before the &lt;code&gt;_&lt;/code&gt; placeholder.</source>
          <target state="translated">&lt;code&gt;_&lt;/code&gt; Шаблон будет соответствовать любому значению. Помещая его после других наших ответвлений, &lt;code&gt;_&lt;/code&gt; будет соответствовать всем возможным случаям, которые не указаны перед ним. &lt;code&gt;()&lt;/code&gt; Только стоимость единицы, так что ничего не произойдет в &lt;code&gt;_&lt;/code&gt; случае. В результате мы можем сказать, что мы не хотим ничего делать для всех возможных значений, которые мы не указываем перед заполнителем &lt;code&gt;_&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d4f623218e4e907b6db896a6ba8ba2e0737f6051" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;abort&lt;/code&gt; function terminates the process, so the destructor will not get run on the example below:</source>
          <target state="translated">Функция &lt;code&gt;abort&lt;/code&gt; завершает процесс, поэтому деструктор не запускается в приведенном ниже примере:</target>
        </trans-unit>
        <trans-unit id="1da31d2d7b88dbadae1ea02224cc02bf279c6b4e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;add&lt;/code&gt; method adds the &lt;code&gt;x&lt;/code&gt; values of two &lt;code&gt;Point&lt;/code&gt; instances and the &lt;code&gt;y&lt;/code&gt; values of two &lt;code&gt;Point&lt;/code&gt; instances to create a new &lt;code&gt;Point&lt;/code&gt;. The &lt;code&gt;Add&lt;/code&gt; trait has an associated type named &lt;code&gt;Output&lt;/code&gt; that determines the type returned from the &lt;code&gt;add&lt;/code&gt; method.</source>
          <target state="translated">Метод &lt;code&gt;add&lt;/code&gt; добавляет значения &lt;code&gt;x&lt;/code&gt; двух экземпляров &lt;code&gt;Point&lt;/code&gt; и значения &lt;code&gt;y&lt;/code&gt; двух экземпляров &lt;code&gt;Point&lt;/code&gt; для создания новой &lt;code&gt;Point&lt;/code&gt; . Свойство &lt;code&gt;Add&lt;/code&gt; имеет связанный тип с именем &lt;code&gt;Output&lt;/code&gt; , который определяет тип, возвращаемый методом &lt;code&gt;add&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6b4f66cfe4d8578da648c05ce2a1d295046eb19d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;add_text&lt;/code&gt; method takes a mutable reference to &lt;code&gt;self&lt;/code&gt;, because we&amp;rsquo;re changing the &lt;code&gt;Post&lt;/code&gt; instance that we&amp;rsquo;re calling &lt;code&gt;add_text&lt;/code&gt; on. We then call &lt;code&gt;push_str&lt;/code&gt; on the &lt;code&gt;String&lt;/code&gt; in &lt;code&gt;content&lt;/code&gt; and pass the &lt;code&gt;text&lt;/code&gt; argument to add to the saved &lt;code&gt;content&lt;/code&gt;. This behavior doesn&amp;rsquo;t depend on the state the post is in, so it&amp;rsquo;s not part of the state pattern. The &lt;code&gt;add_text&lt;/code&gt; method doesn&amp;rsquo;t interact with the &lt;code&gt;state&lt;/code&gt; field at all, but it is part of the behavior we want to support.</source>
          <target state="translated">Метод &lt;code&gt;add_text&lt;/code&gt; принимает изменяемую ссылку на &lt;code&gt;self&lt;/code&gt; , потому что мы меняем экземпляр &lt;code&gt;Post&lt;/code&gt; , для которого вызываем &lt;code&gt;add_text&lt;/code&gt; . Затем мы вызываем &lt;code&gt;push_str&lt;/code&gt; для &lt;code&gt;String&lt;/code&gt; в &lt;code&gt;content&lt;/code&gt; и передаем &lt;code&gt;text&lt;/code&gt; аргумент для добавления к сохраненному &lt;code&gt;content&lt;/code&gt; . Это поведение не зависит от состояния сообщения, поэтому оно не является частью шаблона состояния. Метод &lt;code&gt;add_text&lt;/code&gt; вообще не взаимодействует с полем &lt;code&gt;state&lt;/code&gt; , но это часть поведения, которое мы хотим поддерживать.</target>
        </trans-unit>
        <trans-unit id="2c3ad15ad6826ff34548cd3374a6a4eed3efc204" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;align&lt;/code&gt; and &lt;code&gt;packed&lt;/code&gt; modifiers can be used to respectively raise or lower the alignment of &lt;code&gt;struct&lt;/code&gt;s and &lt;code&gt;union&lt;/code&gt;s. &lt;code&gt;packed&lt;/code&gt; may also alter the padding between fields.</source>
          <target state="translated">&lt;code&gt;align&lt;/code&gt; и &lt;code&gt;packed&lt;/code&gt; модификаторы могут быть использованы , чтобы соответственно поднять или опустить выравнивание &lt;code&gt;struct&lt;/code&gt; с и &lt;code&gt;union&lt;/code&gt; с. &lt;code&gt;packed&lt;/code&gt; также может изменять заполнение между полями.</target>
        </trans-unit>
        <trans-unit id="0e0634e43790fec0970517f968c2cdaea9942a64" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;align&lt;/code&gt; and &lt;code&gt;packed&lt;/code&gt; modifiers cannot be applied on the same type and a &lt;code&gt;packed&lt;/code&gt; type cannot transitively contain another &lt;code&gt;align&lt;/code&gt;ed type. &lt;code&gt;align&lt;/code&gt; and &lt;code&gt;packed&lt;/code&gt; may only be applied to the &lt;a href=&quot;#the-default-representation&quot;&gt;default&lt;/a&gt; and &lt;a href=&quot;#the-c-representation&quot;&gt;&lt;code&gt;C&lt;/code&gt;&lt;/a&gt; representations.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ba365c1b081658cee386344e9e2a04962a51bb04" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;align&lt;/code&gt; and &lt;code&gt;packed&lt;/code&gt; modifiers cannot be applied on the same type and a &lt;code&gt;packed&lt;/code&gt; type cannot transitively contain another &lt;code&gt;align&lt;/code&gt;ed type. &lt;code&gt;align&lt;/code&gt; and &lt;code&gt;packed&lt;/code&gt; may only be applied to the &lt;a href=&quot;type-layout#the-default-representation&quot;&gt;default&lt;/a&gt; and &lt;a href=&quot;type-layout#the-c-representation&quot;&gt;&lt;code&gt;C&lt;/code&gt;&lt;/a&gt; representations.</source>
          <target state="translated">В &lt;code&gt;align&lt;/code&gt; и &lt;code&gt;packed&lt;/code&gt; модификаторы не могут быть применены на тот же тип и &lt;code&gt;packed&lt;/code&gt; тип не может содержать другой транзитивно &lt;code&gt;align&lt;/code&gt; типа изда. &lt;code&gt;align&lt;/code&gt; и &lt;code&gt;packed&lt;/code&gt; могут быть применены только к &lt;a href=&quot;type-layout#the-default-representation&quot;&gt;умолчанию&lt;/a&gt; и &lt;a href=&quot;type-layout#the-c-representation&quot;&gt; &lt;code&gt;C&lt;/code&gt; &lt;/a&gt; представлений.</target>
        </trans-unit>
        <trans-unit id="53e65577e1cfa4684ae0b49bee71e8da03a67fa1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;align&lt;/code&gt; modifier can also be applied on an &lt;code&gt;enum&lt;/code&gt;. When it is, the effect on the &lt;code&gt;enum&lt;/code&gt;'s alignment is the same as if the &lt;code&gt;enum&lt;/code&gt; was wrapped in a newtype &lt;code&gt;struct&lt;/code&gt; with the same &lt;code&gt;align&lt;/code&gt; modifier.</source>
          <target state="translated">&lt;code&gt;align&lt;/code&gt; модификатор также может быть применен на &lt;code&gt;enum&lt;/code&gt; . Когда это так, эффект на выравнивание &lt;code&gt;enum&lt;/code&gt; такой же, как если бы &lt;code&gt;enum&lt;/code&gt; было заключено в &lt;code&gt;struct&lt;/code&gt; newtype с тем же модификатором &lt;code&gt;align&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6ad8df46a380899eaf26791f29aae33e2b0b76bb" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;amt&lt;/code&gt; must be &lt;code&gt;&amp;lt;=&lt;/code&gt; the number of bytes in the buffer returned by &lt;a href=&quot;#tymethod.fill_buf&quot;&gt;&lt;code&gt;fill_buf&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;amt&lt;/code&gt; должен быть &lt;code&gt;&amp;lt;=&lt;/code&gt; число байтов в буфере , возвращаемый &lt;a href=&quot;#tymethod.fill_buf&quot;&gt; &lt;code&gt;fill_buf&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="6cdd430203e5d1bc8171135295b8e6a12c3f9ccb" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;amt&lt;/code&gt; must be &lt;code&gt;&amp;lt;=&lt;/code&gt; the number of bytes in the buffer returned by &lt;a href=&quot;trait.bufread#tymethod.fill_buf&quot;&gt;&lt;code&gt;fill_buf&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="45b714d09b6da61ea117e3601d5d1e5fd89a8774" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;approve&lt;/code&gt; method will be similar to the &lt;code&gt;request_review&lt;/code&gt; method: it will set &lt;code&gt;state&lt;/code&gt; to the value that the current state says it should have when that state is approved, as shown in Listing 17-16:</source>
          <target state="translated">Метод &lt;code&gt;approve&lt;/code&gt; будет аналогичен методу &lt;code&gt;request_review&lt;/code&gt; : он установит для &lt;code&gt;state&lt;/code&gt; значение, которое, согласно текущему состоянию, должно быть у него при утверждении этого состояния, как показано в листинге 17-16:</target>
        </trans-unit>
        <trans-unit id="0d99e2697c98f4ee00d53c8602d75f85424ebe1a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;area&lt;/code&gt; function accesses the &lt;code&gt;width&lt;/code&gt; and &lt;code&gt;height&lt;/code&gt; fields of the &lt;code&gt;Rectangle&lt;/code&gt; instance. Our function signature for &lt;code&gt;area&lt;/code&gt; now says exactly what we mean: calculate the area of &lt;code&gt;Rectangle&lt;/code&gt;, using its &lt;code&gt;width&lt;/code&gt; and &lt;code&gt;height&lt;/code&gt; fields. This conveys that the width and height are related to each other, and it gives descriptive names to the values rather than using the tuple index values of &lt;code&gt;0&lt;/code&gt; and &lt;code&gt;1&lt;/code&gt;. This is a win for clarity.</source>
          <target state="translated">Функция &lt;code&gt;area&lt;/code&gt; обращается к полям &lt;code&gt;width&lt;/code&gt; и &lt;code&gt;height&lt;/code&gt; экземпляра &lt;code&gt;Rectangle&lt;/code&gt; . Наша сигнатура функции для &lt;code&gt;area&lt;/code&gt; теперь говорит именно то, что мы имеем в виду: вычислить площадь &lt;code&gt;Rectangle&lt;/code&gt; , используя его поля &lt;code&gt;width&lt;/code&gt; и &lt;code&gt;height&lt;/code&gt; . Это означает, что ширина и высота связаны друг с другом, и дает описательные имена для значений вместо использования значений индекса кортежа &lt;code&gt;0&lt;/code&gt; и &lt;code&gt;1&lt;/code&gt; . Это выигрыш для ясности.</target>
        </trans-unit>
        <trans-unit id="f0f4d5c245d843fc107cb0d995f1cc0cbaafe380" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;area&lt;/code&gt; function is supposed to calculate the area of one rectangle, but the function we wrote has two parameters. The parameters are related, but that&amp;rsquo;s not expressed anywhere in our program. It would be more readable and more manageable to group width and height together. We&amp;rsquo;ve already discussed one way we might do that in &lt;a href=&quot;ch03-02-data-types#the-tuple-type&quot;&gt;&amp;ldquo;The Tuple Type&amp;rdquo;&lt;/a&gt; section of Chapter 3: by using tuples.</source>
          <target state="translated">Функция &lt;code&gt;area&lt;/code&gt; должна вычислять площадь одного прямоугольника, но написанная нами функция имеет два параметра. Параметры связаны, но это нигде в нашей программе не выражено. Было бы легче сгруппировать ширину и высоту вместе. Мы уже обсуждали один из способов сделать это в разделе &lt;a href=&quot;ch03-02-data-types#the-tuple-type&quot;&gt;&amp;laquo;Тип&lt;/a&gt; кортежа &amp;raquo; главы 3: с помощью кортежей.</target>
        </trans-unit>
        <trans-unit id="03663b761515431ad66c10f38033078682c6e595" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;art&lt;/code&gt; crate users can still see and use the internal structure from Listing 14-3 as demonstrated in Listing 14-4, or they can use the more convenient structure in Listing 14-5, as shown in Listing 14-6:</source>
          <target state="translated">Пользователи &lt;code&gt;art&lt;/code&gt; ящика могут по-прежнему видеть и использовать внутреннюю структуру из листинга 14-3, как показано в листинге 14-4, или они могут использовать более удобную структуру из листинга 14-5, как показано в листинге 14-6:</target>
        </trans-unit>
        <trans-unit id="e825da57c4a60047ea61533b7c1bd5bca8251591" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;as&lt;/code&gt; keyword can be used to change what the crate is referred to as in your project. If a crate name includes a dash, it is implicitly imported with the dashes replaced by underscores.</source>
          <target state="translated">&lt;code&gt;as&lt;/code&gt; можно использовать ключевое слово , чтобы изменить то , что обрешетка упоминается как в вашем проекте. Если имя ящика включает тире, оно неявно импортируется с заменой тире на подчеркивание.</target>
        </trans-unit>
        <trans-unit id="2dd2463e89570fe4f3bb6f6203a6c56b03267f94" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;assert!&lt;/code&gt; macro, provided by the standard library, is useful when you want to ensure that some condition in a test evaluates to &lt;code&gt;true&lt;/code&gt;. We give the &lt;code&gt;assert!&lt;/code&gt; macro an argument that evaluates to a Boolean. If the value is &lt;code&gt;true&lt;/code&gt;, &lt;code&gt;assert!&lt;/code&gt; does nothing and the test passes. If the value is &lt;code&gt;false&lt;/code&gt;, the &lt;code&gt;assert!&lt;/code&gt; macro calls the &lt;code&gt;panic!&lt;/code&gt; macro, which causes the test to fail. Using the &lt;code&gt;assert!&lt;/code&gt; macro helps us check that our code is functioning in the way we intend.</source>
          <target state="translated">Утверждение &lt;code&gt;assert!&lt;/code&gt; Макрос, предоставляемый стандартной библиотекой, полезен, когда вы хотите убедиться, что какое-то условие в тесте оценивается как &lt;code&gt;true&lt;/code&gt; . Даем &lt;code&gt;assert!&lt;/code&gt; макрос аргумент, вычисляемый как логическое. Если значение &lt;code&gt;true&lt;/code&gt; , &lt;code&gt;assert!&lt;/code&gt; ничего не делает, и тест проходит. Если значение равно &lt;code&gt;false&lt;/code&gt; , &lt;code&gt;assert!&lt;/code&gt; макрос вызывает &lt;code&gt;panic!&lt;/code&gt; макрос, который приводит к сбою теста. Используя &lt;code&gt;assert!&lt;/code&gt; макрос помогает нам проверить, работает ли наш код так, как мы предполагаем.</target>
        </trans-unit>
        <trans-unit id="95f1355f51c209910ea66191ec2fc57f92344bfc" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;assert_ne!&lt;/code&gt; macro will pass if the two values we give it are not equal and fail if they&amp;rsquo;re equal. This macro is most useful for cases when we&amp;rsquo;re not sure what a value &lt;em&gt;will&lt;/em&gt; be, but we know what the value definitely &lt;em&gt;won&amp;rsquo;t&lt;/em&gt; be if our code is functioning as we intend. For example, if we&amp;rsquo;re testing a function that is guaranteed to change its input in some way, but the way in which the input is changed depends on the day of the week that we run our tests, the best thing to assert might be that the output of the function is not equal to the input.</source>
          <target state="translated">&lt;code&gt;assert_ne!&lt;/code&gt; макрос будет проходить, если два значения, которые мы даем ему, не равны, и завершится ошибкой, если они равны. Этот макрос наиболее полезен в случаях, когда мы не уверены, какое значение &lt;em&gt;будет&lt;/em&gt; , но мы знаем, каким &lt;em&gt;будет&lt;/em&gt; значение определенно &lt;em&gt;,&lt;/em&gt; если наш код работает так, как мы предполагали. Например, если мы тестируем функцию, которая гарантированно изменяет свой ввод каким-либо образом, но способ изменения ввода зависит от дня недели, в который мы запускаем наши тесты, лучше всего утверждать, что что выход функции не равен входу.</target>
        </trans-unit>
        <trans-unit id="bf35e012d7004404479ddec49cb6abc4ee90bc1a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;bind&lt;/code&gt; function in this scenario works like the &lt;code&gt;new&lt;/code&gt; function in that it will return a new &lt;code&gt;TcpListener&lt;/code&gt; instance. The reason the function is called &lt;code&gt;bind&lt;/code&gt; is that in networking, connecting to a port to listen to is known as &amp;ldquo;binding to a port.&amp;rdquo;</source>
          <target state="translated">Функция &lt;code&gt;bind&lt;/code&gt; в этом сценарии работает так же, как &lt;code&gt;new&lt;/code&gt; функция, в том &lt;code&gt;TcpListener&lt;/code&gt; что она возвращает новый экземпляр TcpListener . Причина, по которой функция называется &lt;code&gt;bind&lt;/code&gt; , состоит в том, что в сети подключение к порту для прослушивания известно как &amp;laquo;привязка к порту&amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="3a9db4154e7cfc914c7af74a70f78787dc149e27" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;bind&lt;/code&gt; function returns a &lt;code&gt;Result&amp;lt;T, E&amp;gt;&lt;/code&gt;, which indicates that binding might fail. For example, connecting to port 80 requires administrator privileges (nonadministrators can listen only on ports higher than 1024), so if we tried to connect to port 80 without being an administrator, binding wouldn&amp;rsquo;t work. As another example, binding wouldn&amp;rsquo;t work if we ran two instances of our program and so had two programs listening to the same port. Because we&amp;rsquo;re writing a basic server just for learning purposes, we won&amp;rsquo;t worry about handling these kinds of errors; instead, we use &lt;code&gt;unwrap&lt;/code&gt; to stop the program if errors happen.</source>
          <target state="translated">Функция &lt;code&gt;bind&lt;/code&gt; возвращает &lt;code&gt;Result&amp;lt;T, E&amp;gt;&lt;/code&gt; , который указывает, что привязка может завершиться неудачно. Например, для подключения к порту 80 требуются права администратора (неадминистраторы могут прослушивать только порты выше 1024), поэтому, если мы попытаемся подключиться к порту 80, не будучи администратором, привязка не сработает. В качестве другого примера, привязка не будет работать, если мы запустили два экземпляра нашей программы и, следовательно, две программы будут прослушивать один и тот же порт. Поскольку мы пишем базовый сервер только для обучения, мы не будем беспокоиться об обработке таких ошибок; вместо этого мы используем &lt;code&gt;unwrap&lt;/code&gt; , чтобы остановить программу в случае возникновения ошибок.</target>
        </trans-unit>
        <trans-unit id="86e869ec27553a2645d530ee9b57e980ad085326" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;bool&lt;/code&gt; represents a value, which could only be either &lt;code&gt;true&lt;/code&gt; or &lt;code&gt;false&lt;/code&gt;. If you cast a &lt;code&gt;bool&lt;/code&gt; into an integer, &lt;code&gt;true&lt;/code&gt; will be 1 and &lt;code&gt;false&lt;/code&gt; will be 0.</source>
          <target state="translated">&lt;code&gt;bool&lt;/code&gt; представляет собой значение, которое может быть только либо &lt;code&gt;true&lt;/code&gt; или &lt;code&gt;false&lt;/code&gt; . Если вы приведете &lt;code&gt;bool&lt;/code&gt; к целому числу, &lt;code&gt;true&lt;/code&gt; будет 1, а &lt;code&gt;false&lt;/code&gt; будет 0.</target>
        </trans-unit>
        <trans-unit id="d4311662fb8a13303491e364af26bcbe8200bef8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;bool&lt;/code&gt; type is a datatype which can be either &lt;code&gt;true&lt;/code&gt; or &lt;code&gt;false&lt;/code&gt;. The boolean type uses one byte of memory. It is used in comparisons and bitwise operations like &lt;code&gt;&amp;amp;&lt;/code&gt;, &lt;code&gt;|&lt;/code&gt;, and &lt;code&gt;!&lt;/code&gt;.</source>
          <target state="translated">Тип &lt;code&gt;bool&lt;/code&gt; - это тип данных, который может иметь значение &lt;code&gt;true&lt;/code&gt; или &lt;code&gt;false&lt;/code&gt; . Логический тип использует один байт памяти. Он используется в сравнениях и побитовых операциях, таких как &lt;code&gt;&amp;amp;&lt;/code&gt; , &lt;code&gt;|&lt;/code&gt; , и &lt;code&gt;!&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="71b45beaeed4f4e8bb8cb42d1eee7255c7dfda23" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;break&lt;/code&gt; statement can take an argument (which will be the value of the loop expression if the &lt;code&gt;break&lt;/code&gt; statement is executed) in &lt;code&gt;loop&lt;/code&gt; loops, but not &lt;code&gt;for&lt;/code&gt;, &lt;code&gt;while&lt;/code&gt;, or &lt;code&gt;while let&lt;/code&gt; loops.</source>
          <target state="translated">Оператор &lt;code&gt;break&lt;/code&gt; может принимать аргумент (который будет значением выражения цикла, если оператор &lt;code&gt;break&lt;/code&gt; выполняется) в циклах &lt;code&gt;loop&lt;/code&gt; , но не в циклах &lt;code&gt;for&lt;/code&gt; , &lt;code&gt;while&lt;/code&gt; или &lt;code&gt;while let&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d4fc4821431bbe2f5d7ca950ef58b031fb001379" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;bytes&lt;/code&gt; method returns each raw byte, which might be appropriate for your domain:</source>
          <target state="translated">Метод &lt;code&gt;bytes&lt;/code&gt; возвращает каждый необработанный байт, который может быть подходящим для вашего домена:</target>
        </trans-unit>
        <trans-unit id="0c67d48bb9bf16df95a3dc50a92dbdfe313c2a09" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;can_hold&lt;/code&gt; method returns a Boolean, which means it&amp;rsquo;s a perfect use case for the &lt;code&gt;assert!&lt;/code&gt; macro. In Listing 11-6, we write a test that exercises the &lt;code&gt;can_hold&lt;/code&gt; method by creating a &lt;code&gt;Rectangle&lt;/code&gt; instance that has a width of 8 and a height of 7 and asserting that it can hold another &lt;code&gt;Rectangle&lt;/code&gt; instance that has a width of 5 and a height of 1.</source>
          <target state="translated">Метод &lt;code&gt;can_hold&lt;/code&gt; возвращает логическое значение, что означает, что это идеальный вариант использования &lt;code&gt;assert!&lt;/code&gt; макрос. В листинге 11-6 мы пишем тест, который &lt;code&gt;can_hold&lt;/code&gt; метод can_hold , создавая экземпляр &lt;code&gt;Rectangle&lt;/code&gt; с шириной 8 и высотой 7 и утверждая, что он может содержать другой экземпляр &lt;code&gt;Rectangle&lt;/code&gt; с шириной 5 и высотой 1.</target>
        </trans-unit>
        <trans-unit id="5a25b55443c783de850a8f716e7e98dd68745de2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;cargo install&lt;/code&gt; command allows you to install and use binary crates locally. This isn&amp;rsquo;t intended to replace system packages; it&amp;rsquo;s meant to be a convenient way for Rust developers to install tools that others have shared on &lt;a href=&quot;https://crates.io/&quot;&gt;crates.io&lt;/a&gt;. Note that you can only install packages that have binary targets. A &lt;em&gt;binary target&lt;/em&gt; is the runnable program that is created if the crate has a &lt;em&gt;src/main.rs&lt;/em&gt; file or another file specified as a binary, as opposed to a library target that isn&amp;rsquo;t runnable on its own but is suitable for including within other programs. Usually, crates have information in the &lt;em&gt;README&lt;/em&gt; file about whether a crate is a library, has a binary target, or both.</source>
          <target state="translated">Команда &lt;code&gt;cargo install&lt;/code&gt; позволяет устанавливать и использовать бинарные крейты локально. Это не предназначено для замены системных пакетов; Это должно быть удобным способом для разработчиков Rust устанавливать инструменты, которыми другие поделились на &lt;a href=&quot;https://crates.io/&quot;&gt;crates.io&lt;/a&gt; . Обратите внимание, что вы можете устанавливать только пакеты с двоичными целями. &lt;em&gt;Бинарная мишенью&lt;/em&gt; является исполняемой программой , которая создается , если клеть имеет &lt;em&gt;SRC / main.rs&lt;/em&gt; файл или другой файл , указанный в качестве двоичного файла, в отличии от целевой библиотеки , которая не является исполняемой самой по себе , но подходит для включения в других программы. Обычно ящики содержат информацию в файле &lt;em&gt;README&lt;/em&gt; о том, является ли ящик библиотекой, имеет двоичную цель или и то, и другое.</target>
        </trans-unit>
        <trans-unit id="2664dcbe5273c6722a5b153d876b9b792f2ada2f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;cargo test&lt;/code&gt; command runs all tests in our project, as shown in Listing 11-2.</source>
          <target state="translated">Команда &lt;code&gt;cargo test&lt;/code&gt; запускает все тесты в нашем проекте, как показано в листинге 11-2.</target>
        </trans-unit>
        <trans-unit id="375baaee400dee61b2707b887bd9af56fe2bc128" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;cfg&lt;/code&gt; attribute</source>
          <target state="translated">&lt;code&gt;cfg&lt;/code&gt; атрибут</target>
        </trans-unit>
        <trans-unit id="3c6c79dbe0366f164760e8fbd149ca95e0429eec" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;cfg&lt;/code&gt; attribute is allowed anywhere attributes are allowed.</source>
          <target state="translated">&lt;code&gt;cfg&lt;/code&gt; атрибут разрешен атрибуты нигде не допускаются.</target>
        </trans-unit>
        <trans-unit id="c1be4a466f7709a98c138b8664fae5693d56dd2b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;cfg&lt;/code&gt; attribute supports only three kinds of predicates:</source>
          <target state="translated">В &lt;code&gt;cfg&lt;/code&gt; атрибут поддерживает только три типа сказуемых:</target>
        </trans-unit>
        <trans-unit id="28422790bd7081a79bb025fb9d66e378219a525d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;cfg&lt;/code&gt; macro</source>
          <target state="translated">&lt;code&gt;cfg&lt;/code&gt; макро</target>
        </trans-unit>
        <trans-unit id="fde18a15c12045ccc5f862ad4d07ffff9bb790a4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;cfg&lt;/code&gt;&lt;a href=&quot;attributes&quot;&gt;attribute&lt;/a&gt; conditionally includes the thing it is attached to based on a configuration predicate.</source>
          <target state="translated">&lt;code&gt;cfg&lt;/code&gt; &lt;a href=&quot;attributes&quot;&gt;атрибут&lt;/a&gt; условно включает в себя вещь оно прикреплено к основано на конфигурации предиката.</target>
        </trans-unit>
        <trans-unit id="2223835f7d8034d74bbb5846af6ec97de49a67f5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;cfg_attr&lt;/code&gt; attribute</source>
          <target state="translated">&lt;code&gt;cfg_attr&lt;/code&gt; атрибут</target>
        </trans-unit>
        <trans-unit id="76546526e7489be649c0d74ada78ee80e5e85965" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;cfg_attr&lt;/code&gt; attribute is allowed anywhere attributes are allowed.</source>
          <target state="translated">&lt;code&gt;cfg_attr&lt;/code&gt; атрибут разрешен атрибуты нигде не допускаются.</target>
        </trans-unit>
        <trans-unit id="548a83f876de36acae9e81967a808fe451cf7938" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;cfg_attr&lt;/code&gt;&lt;a href=&quot;attributes&quot;&gt;attribute&lt;/a&gt; conditionally includes &lt;a href=&quot;attributes&quot;&gt;attributes&lt;/a&gt; based on a configuration predicate.</source>
          <target state="translated">&lt;code&gt;cfg_attr&lt;/code&gt; &lt;a href=&quot;attributes&quot;&gt;атрибут&lt;/a&gt; условно включает в себя &lt;a href=&quot;attributes&quot;&gt;атрибуты&lt;/a&gt; на основе конфигурации предиката.</target>
        </trans-unit>
        <trans-unit id="85a19bbf37eb56f0525c8c2436505adedd691250" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;char&lt;/code&gt; type represents a single character. More specifically, since 'character' isn't a well-defined concept in Unicode, &lt;code&gt;char&lt;/code&gt; is a '&lt;a href=&quot;http://www.unicode.org/glossary/#unicode_scalar_value&quot;&gt;Unicode scalar value&lt;/a&gt;', which is similar to, but not the same as, a '&lt;a href=&quot;http://www.unicode.org/glossary/#code_point&quot;&gt;Unicode code point&lt;/a&gt;'.</source>
          <target state="translated">Тип &lt;code&gt;char&lt;/code&gt; представляет собой один символ. Более конкретно, поскольку &amp;laquo;символ&amp;raquo; не является четко определенным понятием в Unicode, &lt;code&gt;char&lt;/code&gt; - это &amp;laquo; &lt;a href=&quot;http://www.unicode.org/glossary/#unicode_scalar_value&quot;&gt;скалярное значение Unicode&lt;/a&gt; &amp;raquo;, которое похоже на &amp;laquo; &lt;a href=&quot;http://www.unicode.org/glossary/#code_point&quot;&gt;кодовую точку Unicode&amp;raquo;&lt;/a&gt; , но не то же самое .</target>
        </trans-unit>
        <trans-unit id="b73bedd4705331ddde92b218ee42ae14fd783b1a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;cold&lt;/code&gt; and &lt;code&gt;inline&lt;/code&gt;&lt;a href=&quot;../attributes&quot;&gt;attributes&lt;/a&gt; give suggestions to generate code in a way that may be faster than what it would do without the hint. The attributes are only hints, and may be ignored.</source>
          <target state="translated">&lt;code&gt;cold&lt;/code&gt; и &lt;code&gt;inline&lt;/code&gt; &lt;a href=&quot;../attributes&quot;&gt;атрибуты&lt;/a&gt; дают предложения для генерации коды таким образом , что может быть быстрее , чем это было бы обойтись без намека. Атрибуты являются только подсказками, и их можно игнорировать.</target>
        </trans-unit>
        <trans-unit id="5e443e8933fc7022a9fff52a5391c70d8fc736a1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;cold&lt;/code&gt; attribute</source>
          <target state="translated">&lt;code&gt;cold&lt;/code&gt; атрибут</target>
        </trans-unit>
        <trans-unit id="f187d03d0870d5f7cf8d911158a2ad4bf8bfb1f1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;const&lt;/code&gt; keyword is also used in raw pointers in combination with &lt;code&gt;mut&lt;/code&gt;, as seen in &lt;code&gt;*const T&lt;/code&gt; and &lt;code&gt;*mut T&lt;/code&gt;. More about &lt;code&gt;const&lt;/code&gt; as used in raw pointers can be read at the Rust docs for the &lt;a href=&quot;primitive.pointer&quot;&gt;pointer primitive&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c647cbb39e778e9b3fee3b9f221a846f5e10198a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;const&lt;/code&gt; keyword is also used in raw pointers in combination with &lt;code&gt;mut&lt;/code&gt;, as seen in &lt;code&gt;*const T&lt;/code&gt; and &lt;code&gt;*mut T&lt;/code&gt;. More about that can be read at the &lt;a href=&quot;primitive.pointer&quot;&gt;pointer&lt;/a&gt; primitive part of the Rust docs.</source>
          <target state="translated">&lt;code&gt;const&lt;/code&gt; Ключевое слово также используется в сырых указателей в комбинации с &lt;code&gt;mut&lt;/code&gt; , как видно из &lt;code&gt;*const T&lt;/code&gt; и &lt;code&gt;*mut T&lt;/code&gt; . Подробнее об этом можно прочитать в части, посвященной &lt;a href=&quot;primitive.pointer&quot;&gt;указателям,&lt;/a&gt; в документации Rust.</target>
        </trans-unit>
        <trans-unit id="90ef70a34f1bf7aa0febc79627f67bbce0e1d9d3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;core&lt;/code&gt; crate is always added to the extern prelude. The &lt;code&gt;std&lt;/code&gt; crate is added as long as the &lt;a href=&quot;../crates-and-source-files#preludes-and-no_std&quot;&gt;&lt;code&gt;no_std&lt;/code&gt;&lt;/a&gt; attribute is not specified in the crate root.</source>
          <target state="translated">&lt;code&gt;core&lt;/code&gt; клеть всегда добавляется к экстерном прелюдии. &lt;code&gt;std&lt;/code&gt; обрешетка добавляют до тех пор , как &lt;a href=&quot;../crates-and-source-files#preludes-and-no_std&quot;&gt; &lt;code&gt;no_std&lt;/code&gt; &lt;/a&gt; атрибут не указан в корне клети.</target>
        </trans-unit>
        <trans-unit id="38acae0d6ab176e191a45e1f1b54faccd4c7f448" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;crate_name&lt;/code&gt; attribute</source>
          <target state="translated">&lt;code&gt;crate_name&lt;/code&gt; атрибут</target>
        </trans-unit>
        <trans-unit id="ef2c8badee302cb0baefa21db745a07eb79b3acf" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;data&lt;/code&gt; pointer can be used to store arbitrary data as required by the executor. This could be e.g. a type-erased pointer to an &lt;code&gt;Arc&lt;/code&gt; that is associated with the task. The value of this poiner will get passed to all functions that are part of the &lt;code&gt;vtable&lt;/code&gt; as the first parameter.</source>
          <target state="translated">&lt;code&gt;data&lt;/code&gt; указатель может быть использован для хранения произвольных данных в соответствии с требованиями исполнителя. Это может быть, например, стираемый указатель на &lt;code&gt;Arc&lt;/code&gt; , связанную с задачей. Значение этого указателя будет передано всем функциям, которые являются частью &lt;code&gt;vtable&lt;/code&gt; , в качестве первого параметра.</target>
        </trans-unit>
        <trans-unit id="9e90fa7bb07af3f80ba061dbc0af88db5a79ba76" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;data&lt;/code&gt; pointer can be used to store arbitrary data as required by the executor. This could be e.g. a type-erased pointer to an &lt;code&gt;Arc&lt;/code&gt; that is associated with the task. The value of this pointer will get passed to all functions that are part of the &lt;code&gt;vtable&lt;/code&gt; as the first parameter.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a7af61314557c2255ce30f13387bf574343b8476" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;dbg!(..)&lt;/code&gt; macro moves the input:</source>
          <target state="translated">&lt;code&gt;dbg!(..)&lt;/code&gt; Макрос перемещает вход:</target>
        </trans-unit>
        <trans-unit id="b7a4dd4c094bb75a82ed633489f0ec96c82a6296" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;dbg!&lt;/code&gt; macro works exactly the same in release builds. This is useful when debugging issues that only occur in release builds or when debugging in release mode is significantly faster.</source>
          <target state="translated">&lt;code&gt;dbg!&lt;/code&gt; макрос работает точно так же в сборках релизов. Это полезно при отладке проблем, которые возникают только в сборках выпуска, или когда отладка в режиме выпуска выполняется значительно быстрее.</target>
        </trans-unit>
        <trans-unit id="5a03c825d089a243f66f60fd9869adfb4b5c6857" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;deprecated&lt;/code&gt; attribute</source>
          <target state="translated">&lt;code&gt;deprecated&lt;/code&gt; атрибут</target>
        </trans-unit>
        <trans-unit id="8b0ffc1f78b8eb9694b4e7509ecdd919acc0c0cf" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;deprecated&lt;/code&gt; attribute can only be present &lt;strong&gt;once&lt;/strong&gt; on an item.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4c348bd3f38f8d7b286030ed2d1f972d4a02706b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;deprecated&lt;/code&gt; attribute has several forms:</source>
          <target state="translated">&lt;code&gt;deprecated&lt;/code&gt; атрибут имеет несколько форм:</target>
        </trans-unit>
        <trans-unit id="44c311ce3d12b2d5a8a0632c6cd020f999b4ee16" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;deprecated&lt;/code&gt; attribute may be applied to any &lt;a href=&quot;../items&quot;&gt;item&lt;/a&gt;, &lt;a href=&quot;../items/traits&quot;&gt;trait item&lt;/a&gt;, &lt;a href=&quot;../items/enumerations&quot;&gt;enum variant&lt;/a&gt;, &lt;a href=&quot;../items/structs&quot;&gt;struct field&lt;/a&gt;, &lt;a href=&quot;../items/external-blocks&quot;&gt;external block item&lt;/a&gt;, or &lt;a href=&quot;../macros-by-example&quot;&gt;macro definition&lt;/a&gt;. It cannot be applied to &lt;a href=&quot;../items/implementations#trait-implementations&quot;&gt;trait implementation items&lt;/a&gt;. When applied to an item containing other items, such as a &lt;a href=&quot;../items/modules&quot;&gt;module&lt;/a&gt; or &lt;a href=&quot;../items/implementations&quot;&gt;implementation&lt;/a&gt;, all child items inherit the deprecation attribute.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f1d23eb4050e4bb4bd6008dd3e0216cd81ba2cd1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;deprecated&lt;/code&gt; attribute may be applied to any &lt;a href=&quot;../items&quot;&gt;item&lt;/a&gt;, &lt;a href=&quot;../items/traits&quot;&gt;trait item&lt;/a&gt;, &lt;a href=&quot;../items/enumerations&quot;&gt;enum variant&lt;/a&gt;, &lt;a href=&quot;../items/structs&quot;&gt;struct field&lt;/a&gt;, or &lt;a href=&quot;../items/external-blocks&quot;&gt;external block item&lt;/a&gt;. It cannot be applied to &lt;a href=&quot;../items/implementations#trait-implementations&quot;&gt;trait implementation items&lt;/a&gt;. When applied to an item containing other items, such as a &lt;a href=&quot;../items/modules&quot;&gt;module&lt;/a&gt; or &lt;a href=&quot;../items/implementations&quot;&gt;implementation&lt;/a&gt;, all child items inherit the deprecation attribute.</source>
          <target state="translated">&lt;code&gt;deprecated&lt;/code&gt; атрибут может быть применен к любому &lt;a href=&quot;../items&quot;&gt;пункту&lt;/a&gt; , &lt;a href=&quot;../items/traits&quot;&gt;признак элемента&lt;/a&gt; , &lt;a href=&quot;../items/enumerations&quot;&gt;перечисление варианта&lt;/a&gt; , &lt;a href=&quot;../items/structs&quot;&gt;полю структуры&lt;/a&gt; или &lt;a href=&quot;../items/external-blocks&quot;&gt;внешнему элементу блока&lt;/a&gt; . Его нельзя применить к &lt;a href=&quot;../items/implementations#trait-implementations&quot;&gt;элементам реализации трейта&lt;/a&gt; . При применении к элементу, содержащему другие элементы, например &lt;a href=&quot;../items/modules&quot;&gt;модулю&lt;/a&gt; или &lt;a href=&quot;../items/implementations&quot;&gt;реализации&lt;/a&gt; , все дочерние элементы наследуют атрибут устаревания.</target>
        </trans-unit>
        <trans-unit id="6e7f4030e080734f98683be5c8344d101d0992db" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;dev&lt;/code&gt; and &lt;code&gt;release&lt;/code&gt; shown in this build output indicate that the compiler is using different profiles.</source>
          <target state="translated">&lt;code&gt;dev&lt;/code&gt; и &lt;code&gt;release&lt;/code&gt; показано на этом выходе сборки указывают на то , что компилятор использует различные профили.</target>
        </trans-unit>
        <trans-unit id="2bcbec4aff44a7472a393bc8eca9c7c00034401d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;drop&lt;/code&gt; method is called when &lt;code&gt;_x&lt;/code&gt; goes out of scope, and therefore &lt;code&gt;main&lt;/code&gt; prints &lt;code&gt;Dropping!&lt;/code&gt;.</source>
          <target state="translated">Метод &lt;code&gt;drop&lt;/code&gt; вызывается, когда &lt;code&gt;_x&lt;/code&gt; выходит за пределы области видимости, и поэтому &lt;code&gt;main&lt;/code&gt; печатает &lt;code&gt;Dropping!&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="aa3edbdb8ad85c4d37e55b2e809f2f18d6f4e045" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;dst&lt;/code&gt; path will be a directory symbolic link pointing to the &lt;code&gt;src&lt;/code&gt; path.</source>
          <target state="translated">Путь &lt;code&gt;dst&lt;/code&gt; будет символической ссылкой каталога, указывающей на путь &lt;code&gt;src&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f8ab040b8a001ca82f66534b2d20a3b8892fd2dc" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;dst&lt;/code&gt; path will be a file symbolic link pointing to the &lt;code&gt;src&lt;/code&gt; path.</source>
          <target state="translated">Путь &lt;code&gt;dst&lt;/code&gt; будет символической ссылкой файла, указывающей на путь &lt;code&gt;src&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f0ecd1a2ccd0de8765e1ce7cbb8fab53800f6ce6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;dst&lt;/code&gt; path will be a link pointing to the &lt;code&gt;src&lt;/code&gt; path. Note that systems often require these two paths to both be located on the same filesystem.</source>
          <target state="translated">Путь &lt;code&gt;dst&lt;/code&gt; будет ссылкой, указывающей на путь &lt;code&gt;src&lt;/code&gt; . Обратите внимание, что системы часто требуют, чтобы эти два пути находились в одной файловой системе.</target>
        </trans-unit>
        <trans-unit id="b0f3651131fc6e4c0e98108eb60e32485bb1899b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;dst&lt;/code&gt; path will be a symbolic link pointing to the &lt;code&gt;src&lt;/code&gt; path.</source>
          <target state="translated">Путь &lt;code&gt;dst&lt;/code&gt; будет символической ссылкой, указывающей на путь &lt;code&gt;src&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3c07e52fcb5c94a3c499bbc6e95804ccd5a8bfc6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;dst&lt;/code&gt; path will be a symbolic link pointing to the &lt;code&gt;src&lt;/code&gt; path. On Windows, this will be a file symlink, not a directory symlink; for this reason, the platform-specific &lt;a href=&quot;../os/unix/fs/fn.symlink&quot;&gt;&lt;code&gt;std::os::unix::fs::symlink&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../os/windows/fs/fn.symlink_file&quot;&gt;&lt;code&gt;std::os::windows::fs::symlink_file&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;../os/windows/fs/fn.symlink_dir&quot;&gt;&lt;code&gt;symlink_dir&lt;/code&gt;&lt;/a&gt; should be used instead to make the intent explicit.</source>
          <target state="translated">Путь &lt;code&gt;dst&lt;/code&gt; будет символической ссылкой, указывающей на путь &lt;code&gt;src&lt;/code&gt; . В Windows это будет символическая ссылка на файл, а не на каталог; по этой причине для &lt;a href=&quot;../os/windows/fs/fn.symlink_file&quot;&gt; &lt;code&gt;std::os::windows::fs::symlink_file&lt;/code&gt; &lt;/a&gt;&lt;a href=&quot;../os/windows/fs/fn.symlink_dir&quot;&gt; &lt;code&gt;symlink_dir&lt;/code&gt; &lt;/a&gt; следует использовать зависящие от платформы &lt;a href=&quot;../os/unix/fs/fn.symlink&quot;&gt; &lt;code&gt;std::os::unix::fs::symlink&lt;/code&gt; &lt;/a&gt; и std :: os :: windows :: fs :: symlink_file или symlink_dir .</target>
        </trans-unit>
        <trans-unit id="fce5aa6e4c6fe0d2a117a0ec0a2f7f52bfd2748e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;dyn&lt;/code&gt; keyword is used to highlight that calls to methods on the associated &lt;code&gt;Trait&lt;/code&gt; are dynamically dispatched. To use the trait this way, it must be 'object safe'.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f31eeeb70d8a71f4b93bd89156c38bf0e5709ff2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;edition&lt;/code&gt; key in &lt;em&gt;Cargo.toml&lt;/em&gt; indicates which edition the compiler should use for your code. If the key doesn&amp;rsquo;t exist, Rust uses &lt;code&gt;2015&lt;/code&gt; as the edition value for backward compatibility reasons.</source>
          <target state="translated">&lt;code&gt;edition&lt;/code&gt; ключ в &lt;em&gt;Cargo.toml&lt;/em&gt; указывает , какой выпуск компилятор должен использовать для вашего кода. Если ключ не существует, Rust использует &lt;code&gt;2015&lt;/code&gt; в качестве значения выпуска по причинам обратной совместимости.</target>
        </trans-unit>
        <trans-unit id="d4302d0f2edafc20c30c1bca4c608a973532a107" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;else&lt;/code&gt; block of an &lt;code&gt;if&lt;/code&gt; expression.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="25d57c60dcf697c3f5bb61f1ff343393baeeb72f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;entry&lt;/code&gt; API is intended to provide an efficient mechanism for manipulating the contents of a map conditionally on the presence of a key or not. The primary motivating use case for this is to provide efficient accumulator maps. For instance, if one wishes to maintain a count of the number of times each key has been seen, they will have to perform some conditional logic on whether this is the first time the key has been seen or not. Normally, this would require a &lt;code&gt;find&lt;/code&gt; followed by an &lt;code&gt;insert&lt;/code&gt;, effectively duplicating the search effort on each insertion.</source>
          <target state="translated">&lt;code&gt;entry&lt;/code&gt; API предназначен для обеспечения эффективного механизма для манипулирования содержимого карты условно на наличии ключа или нет. Основной мотивирующий вариант использования для этого - предоставление эффективных карт аккумуляторов. Например, если кто-то хочет вести подсчет количества раз, когда каждый ключ был замечен, он должен будет выполнить некоторую условную логику, определяющую, был ли это первый раз, когда ключ был замечен или нет. Обычно это требует &lt;code&gt;find&lt;/code&gt; за которым следует &lt;code&gt;insert&lt;/code&gt; , эффективно дублируя усилия поиска при каждой вставке.</target>
        </trans-unit>
        <trans-unit id="f625c5b9aa8efa15984a630e2609a8460845d869" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;enum&lt;/code&gt; type is analogous to a &lt;code&gt;data&lt;/code&gt; constructor declaration in ML, or a &lt;em&gt;pick ADT&lt;/em&gt; in Limbo.</source>
          <target state="translated">Тип &lt;code&gt;enum&lt;/code&gt; аналогичен объявлению конструктора &lt;code&gt;data&lt;/code&gt; в ML или &lt;em&gt;ADT выбора&lt;/em&gt; в Limbo.</target>
        </trans-unit>
        <trans-unit id="a4c06e2ed2dc5ac68975592625d2fc4a6fa31065" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;env::args&lt;/code&gt; function returns an iterator! Rather than collecting the iterator values into a vector and then passing a slice to &lt;code&gt;Config::new&lt;/code&gt;, now we&amp;rsquo;re passing ownership of the iterator returned from &lt;code&gt;env::args&lt;/code&gt; to &lt;code&gt;Config::new&lt;/code&gt; directly.</source>
          <target state="translated">Функция &lt;code&gt;env::args&lt;/code&gt; возвращает итератор! Вместо того, чтобы собирать значения итератора в вектор и затем передавать срез в &lt;code&gt;Config::new&lt;/code&gt; , теперь мы напрямую передаем право собственности на итератор, возвращенный из &lt;code&gt;env::args&lt;/code&gt; в &lt;code&gt;Config::new&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8c4edba08b3e0cbdebf585d9d18019162245f0c1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;execute&lt;/code&gt; method will send the job it wants to execute down the sending side of the channel.</source>
          <target state="translated">Метод &lt;code&gt;execute&lt;/code&gt; отправит задание, которое он хочет выполнить, по отправляющей стороне канала.</target>
        </trans-unit>
        <trans-unit id="f04efaa242b2b0657b1281616eed7892b34b84f3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;expensive_test&lt;/code&gt; function is listed as &lt;code&gt;ignored&lt;/code&gt;. If we want to run only the ignored tests, we can use &lt;code&gt;cargo test -- --ignored&lt;/code&gt;:</source>
          <target state="translated">Функция &lt;code&gt;expensive_test&lt;/code&gt; указана как &lt;code&gt;ignored&lt;/code&gt; . Если мы хотим запускать только игнорируемые тесты, мы можем использовать &lt;code&gt;cargo test -- --ignored&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="b3f7670e25e83de589c198657dfe09fdc1e175dc" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;export_name&lt;/code&gt; attribute</source>
          <target state="translated">&lt;code&gt;export_name&lt;/code&gt; атрибут</target>
        </trans-unit>
        <trans-unit id="71ce9eba53db805fddc2d08a297018a65234c4f3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;extern&lt;/code&gt; function qualifier allows providing function &lt;em&gt;definitions&lt;/em&gt; that can be called with a particular ABI:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="40efbff38e084ea29f3140f45238b8f3a1480902" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;extern&lt;/code&gt; keyword is used in two places in Rust. One is in conjunction with the &lt;a href=&quot;index&quot;&gt;&lt;code&gt;crate&lt;/code&gt;&lt;/a&gt; keyword to make your Rust code aware of other Rust crates in your project, i.e., &lt;code&gt;extern crate lazy_static;&lt;/code&gt;. The other use is in foreign function interfaces (FFI).</source>
          <target state="translated">&lt;code&gt;extern&lt;/code&gt; ключевое слово используется в двух местах в Русте. Один из них используется в сочетании с ключевым словом &lt;a href=&quot;index&quot;&gt; &lt;code&gt;crate&lt;/code&gt; ,&lt;/a&gt; чтобы ваш код Rust знал о других ящиках Rust в вашем проекте, то есть &lt;code&gt;extern crate lazy_static;&lt;/code&gt; . Другое использование - в интерфейсах внешних функций (FFI).</target>
        </trans-unit>
        <trans-unit id="80a6e01d93b27f65515594890e0091001ba7b217" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;feature&lt;/code&gt; attribute only accept a &quot;feature flag&quot; and can only be used on nightly. Example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="36584ecca666e59936c11f071bcfcb0da92fd4b7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;feature&lt;/code&gt; attribute was badly formed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="424a7adcc55a187f305df277831d5dda5afa7154" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ffi_const&lt;/code&gt; attribute can only be used on foreign function declarations which have no side effects except for their return value:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f9fac3c8fa0259e175ffb5e9aab803c7bd9140ac" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ffi_const&lt;/code&gt; attribute was used on something other than a foreign function declaration.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bfe6d270783e8b73023767bbcd8ed3a773bacf0d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ffi_pure&lt;/code&gt; attribute can only be used on foreign functions which do not have side effects or infinite loops:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="883b8dfd3c5fc179185e1d061b052f5f3e0fb52a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ffi_pure&lt;/code&gt; attribute was used on a non-foreign function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e96870e73ec5eb32cc1bdf8256711d63dccde7e0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;fix_incorrect_order&lt;/code&gt; function is in the &lt;code&gt;back_of_house&lt;/code&gt; module, so we can use &lt;code&gt;super&lt;/code&gt; to go to the parent module of &lt;code&gt;back_of_house&lt;/code&gt;, which in this case is &lt;code&gt;crate&lt;/code&gt;, the root. From there, we look for &lt;code&gt;serve_order&lt;/code&gt; and find it. Success! We think the &lt;code&gt;back_of_house&lt;/code&gt; module and the &lt;code&gt;serve_order&lt;/code&gt; function are likely to stay in the same relationship to each other and get moved together should we decide to reorganize the crate&amp;rsquo;s module tree. Therefore, we used &lt;code&gt;super&lt;/code&gt; so we&amp;rsquo;ll have fewer places to update code in the future if this code gets moved to a different module.</source>
          <target state="translated">Функция &lt;code&gt;fix_incorrect_order&lt;/code&gt; находится в модуле &lt;code&gt;back_of_house&lt;/code&gt; , поэтому мы можем использовать &lt;code&gt;super&lt;/code&gt; для перехода к родительскому модулю &lt;code&gt;back_of_house&lt;/code&gt; , которым в данном случае является &lt;code&gt;crate&lt;/code&gt; , корень. Оттуда мы ищем &lt;code&gt;serve_order&lt;/code&gt; и находим его. Успех! Мы считаем , что &lt;code&gt;back_of_house&lt;/code&gt; модуль и &lt;code&gt;serve_order&lt;/code&gt; функция, вероятно, останутся в том же отношении друг к другу и перемещаются вместе должны мы решили реорганизовать модуль дерева ящика в. Поэтому мы использовали &lt;code&gt;super&lt;/code&gt; , поэтому у нас будет меньше мест для обновления кода в будущем, если этот код будет перемещен в другой модуль.</target>
        </trans-unit>
        <trans-unit id="8941a23b194692ed51f3b950de07285880e660a7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;fn&lt;/code&gt; syntax declares a new function, the parentheses, &lt;code&gt;()&lt;/code&gt;, indicate there are no parameters, and the curly bracket, &lt;code&gt;{&lt;/code&gt;, starts the body of the function.</source>
          <target state="translated">&lt;code&gt;fn&lt;/code&gt; синтаксис объявляет новую функцию, круглые скобки, &lt;code&gt;()&lt;/code&gt; , указывать нет никаких параметров, и фигурные скобки, &lt;code&gt;{&lt;/code&gt; , начинается тело функции.</target>
        </trans-unit>
        <trans-unit id="2ec5406eba98b65177f08bb6b301125802a344f0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;for&lt;/code&gt; keyword is used in many syntactic locations:</source>
          <target state="translated">&lt;code&gt;for&lt;/code&gt; ключевого слова используются во многих синтаксических местах:</target>
        </trans-unit>
        <trans-unit id="f09d76fe1ac31bb0c6ea4013cf20271ea27e1d4e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;for&lt;/code&gt; loop variable is now named &lt;code&gt;_i&lt;/code&gt;, and the warning no longer appears.</source>
          <target state="translated">&lt;code&gt;for&lt;/code&gt; переменного цикла не теперь называется &lt;code&gt;_i&lt;/code&gt; , и больше не появляется предупреждение.</target>
        </trans-unit>
        <trans-unit id="05236db55a3c27bea79ddd94d4c11b4238339e3a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;forbid&lt;/code&gt; lint setting, like &lt;code&gt;deny&lt;/code&gt;, turns the corresponding compiler warning into a hard error. Unlike &lt;code&gt;deny&lt;/code&gt;, &lt;code&gt;forbid&lt;/code&gt; prevents itself from being overridden by inner attributes.</source>
          <target state="translated">Настройка &lt;code&gt;forbid&lt;/code&gt; lint, как и &lt;code&gt;deny&lt;/code&gt; , превращает соответствующее предупреждение компилятора в серьезную ошибку. В отличие от &lt;code&gt;deny&lt;/code&gt; , &lt;code&gt;forbid&lt;/code&gt; запрещает переопределение внутренними атрибутами.</target>
        </trans-unit>
        <trans-unit id="4235fdb48267c248121e84a51ecfc4901ad84de8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;format&lt;/code&gt; function takes an &lt;a href=&quot;struct.arguments&quot;&gt;&lt;code&gt;Arguments&lt;/code&gt;&lt;/a&gt; struct and returns the resulting formatted string.</source>
          <target state="translated">Функция &lt;code&gt;format&lt;/code&gt; принимает структуру &lt;a href=&quot;struct.arguments&quot;&gt; &lt;code&gt;Arguments&lt;/code&gt; &lt;/a&gt; и возвращает результирующую отформатированную строку.</target>
        </trans-unit>
        <trans-unit id="d0e2c1abc11834d5ec0f9413abedb6a8d1f2b1d6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;from&lt;/code&gt; file does not exist.</source>
          <target state="translated">&lt;code&gt;from&lt;/code&gt; файла не существует.</target>
        </trans-unit>
        <trans-unit id="0c95afec6a5645bced705f13162ada21e2af597c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;from&lt;/code&gt; path is not a file.</source>
          <target state="translated">Путь &lt;code&gt;from&lt;/code&gt; не является файлом.</target>
        </trans-unit>
        <trans-unit id="6acb8d35118f04b02cccbeee4ae943f064bc37b5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;global_allocator&lt;/code&gt; attribute</source>
          <target state="translated">&lt;code&gt;global_allocator&lt;/code&gt; атрибут</target>
        </trans-unit>
        <trans-unit id="ae2c6463795dadd5e649f9eb12f49008495df3a0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;hash_builder&lt;/code&gt; passed should implement the &lt;a href=&quot;../../hash/trait.buildhasher&quot;&gt;&lt;code&gt;BuildHasher&lt;/code&gt;&lt;/a&gt; trait for the HashMap to be useful, see its documentation for details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5b0ca98b2928cdd13f0ccd74c40e39e4e68ec9cc" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;hash_builder&lt;/code&gt; passed should implement the &lt;a href=&quot;../hash/trait.buildhasher&quot;&gt;&lt;code&gt;BuildHasher&lt;/code&gt;&lt;/a&gt; trait for the HashMap to be useful, see its documentation for details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c35c9498a5a0a48423b3c0138b12569234cd1c61" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;hello_macro_derive&lt;/code&gt; function first converts the &lt;code&gt;input&lt;/code&gt; from a &lt;code&gt;TokenStream&lt;/code&gt; to a data structure that we can then interpret and perform operations on. This is where &lt;code&gt;syn&lt;/code&gt; comes into play. The &lt;code&gt;parse&lt;/code&gt; function in &lt;code&gt;syn&lt;/code&gt; takes a &lt;code&gt;TokenStream&lt;/code&gt; and returns a &lt;code&gt;DeriveInput&lt;/code&gt; struct representing the parsed Rust code. Listing 19-32 shows the relevant parts of the &lt;code&gt;DeriveInput&lt;/code&gt; struct we get from parsing the &lt;code&gt;struct Pancakes;&lt;/code&gt; string:</source>
          <target state="translated">Функция &lt;code&gt;hello_macro_derive&lt;/code&gt; сначала преобразует &lt;code&gt;input&lt;/code&gt; из &lt;code&gt;TokenStream&lt;/code&gt; в структуру данных, которую мы затем можем интерпретировать и выполнять операции. Это где &lt;code&gt;syn&lt;/code&gt; входит в игру. &lt;code&gt;parse&lt;/code&gt; функция в &lt;code&gt;syn&lt;/code&gt; принимает &lt;code&gt;TokenStream&lt;/code&gt; и возвращает &lt;code&gt;DeriveInput&lt;/code&gt; структуры , представляющая проанализированный код ржавчины. В листинге 19-32 показаны соответствующие части структуры &lt;code&gt;DeriveInput&lt;/code&gt; ,которые мы получаем в результате синтаксического анализа &lt;code&gt;struct Pancakes;&lt;/code&gt; строка:</target>
        </trans-unit>
        <trans-unit id="004c835aa77c1c8e124a5716a58b7a6bffdd04f8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;hello_macro_derive&lt;/code&gt; function will be called when a user of our library specifies &lt;code&gt;#[derive(HelloMacro)]&lt;/code&gt; on a type. This is possible because we&amp;rsquo;ve annotated the &lt;code&gt;hello_macro_derive&lt;/code&gt; function here with &lt;code&gt;proc_macro_derive&lt;/code&gt; and specified the name, &lt;code&gt;HelloMacro&lt;/code&gt;, which matches our trait name; this is the convention most procedural macros follow.</source>
          <target state="translated">Функция &lt;code&gt;hello_macro_derive&lt;/code&gt; будет вызываться, когда пользователь нашей библиотеки указывает &lt;code&gt;#[derive(HelloMacro)]&lt;/code&gt; для типа. Это возможно, потому что мы аннотировали функцию &lt;code&gt;hello_macro_derive&lt;/code&gt; здесь с помощью &lt;code&gt;proc_macro_derive&lt;/code&gt; и указали имя &lt;code&gt;HelloMacro&lt;/code&gt; , которое соответствует нашему имени признака; это соглашение, которому следует большинство процедурных макросов.</target>
        </trans-unit>
        <trans-unit id="f6187e2c81223b9029c3a44a9c821bc39754afaa" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;if let&lt;/code&gt; syntax lets you combine &lt;code&gt;if&lt;/code&gt; and &lt;code&gt;let&lt;/code&gt; into a less verbose way to handle values that match one pattern while ignoring the rest. Consider the program in Listing 6-6 that matches on an &lt;code&gt;Option&amp;lt;u8&amp;gt;&lt;/code&gt; value but only wants to execute code if the value is 3.</source>
          <target state="translated">&lt;code&gt;if let&lt;/code&gt; синтаксис позволяет объединить , &lt;code&gt;if&lt;/code&gt; и &lt;code&gt;let&lt;/code&gt; в менее многословным способ значений дескрипторов , которые соответствуют одному шаблону, игнорируя все остальное. Рассмотрим программу в листинге 6-6, которая соответствует значению &lt;code&gt;Option&amp;lt;u8&amp;gt;&lt;/code&gt; но хочет выполнить код, только если значение равно 3.</target>
        </trans-unit>
        <trans-unit id="4dd0a50c18a24fd3e6c3d1653fdf8d2add1e5c54" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;if&lt;/code&gt; condition evaluates to a value of &lt;code&gt;3&lt;/code&gt; this time, and Rust throws an error:</source>
          <target state="translated">На этот &lt;code&gt;if&lt;/code&gt; условие if имеет значение &lt;code&gt;3&lt;/code&gt; , и Rust выдает ошибку:</target>
        </trans-unit>
        <trans-unit id="3b97788abf2717f652bd87cae2841d2689fe301c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;if&lt;/code&gt; expression checks whether our value is out of range, tells the user about the problem, and calls &lt;code&gt;continue&lt;/code&gt; to start the next iteration of the loop and ask for another guess. After the &lt;code&gt;if&lt;/code&gt; expression, we can proceed with the comparisons between &lt;code&gt;guess&lt;/code&gt; and the secret number knowing that &lt;code&gt;guess&lt;/code&gt; is between 1 and 100.</source>
          <target state="translated">В &lt;code&gt;if&lt;/code&gt; выражение проверяет , является ли наше значение вне диапазона, сообщает пользователю о проблеме, и призывает &lt;code&gt;continue&lt;/code&gt; , чтобы начать следующую итерацию цикла и попросить другого предположения. После выражения &lt;code&gt;if&lt;/code&gt; мы можем приступить к сравнению &lt;code&gt;guess&lt;/code&gt; и секретного числа, зная, что &lt;code&gt;guess&lt;/code&gt; находится между 1 и 100.</target>
        </trans-unit>
        <trans-unit id="21d4200f741c0e5d495167ba918e66c0fa127463" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;if&lt;/code&gt; keyword is used in one other place in Rust, namely as a part of pattern matching itself, allowing patterns such as &lt;code&gt;Some(x) if x &amp;gt; 200&lt;/code&gt; to be used.</source>
          <target state="translated">&lt;code&gt;if&lt;/code&gt; используется ключевое слово в одном другом месте в Русте, а именно в качестве части шаблону себя, позволяя модели , такие как &lt;code&gt;Some(x) if x &amp;gt; 200&lt;/code&gt; , который будет использоваться.</target>
        </trans-unit>
        <trans-unit id="60fa964e136b0f0fd7616e520f7abaf2ebfa7111" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ignore&lt;/code&gt; attribute</source>
          <target state="translated">&lt;code&gt;ignore&lt;/code&gt; атрибут</target>
        </trans-unit>
        <trans-unit id="1f363aa597e809eee39b1326a49009f8ed22190d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ignore&lt;/code&gt; attribute may optionally be written with the &lt;a href=&quot;../attributes#meta-item-attribute-syntax&quot;&gt;&lt;em&gt;MetaNameValueStr&lt;/em&gt;&lt;/a&gt; syntax to specify a reason why the test is ignored.</source>
          <target state="translated">&lt;code&gt;ignore&lt;/code&gt; атрибут необязательно может быть записан с &lt;a href=&quot;../attributes#meta-item-attribute-syntax&quot;&gt;&lt;em&gt;MetaNameValueStr&lt;/em&gt;&lt;/a&gt; синтаксиса , чтобы указать причину , почему тест игнорируется.</target>
        </trans-unit>
        <trans-unit id="db8fdc6685b8fc701d318f4f3dec52f0b9a4e868" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;impl Trait&lt;/code&gt; return type captures lifetime parameters that do not appear within the &lt;code&gt;impl Trait&lt;/code&gt; itself.</source>
          <target state="translated">В &lt;code&gt;impl Trait&lt;/code&gt; возвращаемые параметры захваты типа прижизненные , которые не появляются в &lt;code&gt;impl Trait&lt;/code&gt; сам.</target>
        </trans-unit>
        <trans-unit id="c9150ca2fdc92a2e0f4ccf4f986d692afa5493d6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;impl Trait&lt;/code&gt; syntax is convenient and makes for more concise code in simple cases. The trait bound syntax can express more complexity in other cases. For example, we can have two parameters that implement &lt;code&gt;Summary&lt;/code&gt;. Using the &lt;code&gt;impl Trait&lt;/code&gt; syntax looks like this:</source>
          <target state="translated">&lt;code&gt;impl Trait&lt;/code&gt; синтаксис удобен и делает для более краткого кода в простых случаях. Синтаксис с привязкой к признаку может выражать большую сложность в других случаях. Например, у нас может быть два параметра, реализующих &lt;code&gt;Summary&lt;/code&gt; . Использование синтаксиса &lt;code&gt;impl Trait&lt;/code&gt; выглядит так:</target>
        </trans-unit>
        <trans-unit id="778ea7a6b81f5bfa7d87e34cfb75fde414639934" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;impl Trait&lt;/code&gt; syntax works for straightforward cases but is actually syntax sugar for a longer form, which is called a &lt;em&gt;trait bound&lt;/em&gt;; it looks like this:</source>
          <target state="translated">&lt;code&gt;impl Trait&lt;/code&gt; синтаксис работает для простых случаев , но на самом деле синтаксис для более длинной формы, которая называется &lt;em&gt;признаком , связанный&lt;/em&gt; ; это выглядит так:</target>
        </trans-unit>
        <trans-unit id="2ffdcc0f4b373da2777f00eb0b778b9205836471" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;impl&lt;/code&gt; keyword is primarily used to define implementations on types. Inherent implementations are standalone, while trait implementations are used to implement traits for types, or other traits.</source>
          <target state="translated">&lt;code&gt;impl&lt;/code&gt; ключевое слово используется в основном для определения реализации по типам. Собственные реализации являются автономными, в то время как реализации трейтов используются для реализации трейтов для типов или других трейтов.</target>
        </trans-unit>
        <trans-unit id="49b529510ff41b8ce0e4f03d01af2d0795d82946" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;incoming&lt;/code&gt; method on &lt;code&gt;TcpListener&lt;/code&gt; returns an iterator that gives us a sequence of streams (more specifically, streams of type &lt;code&gt;TcpStream&lt;/code&gt;). A single &lt;em&gt;stream&lt;/em&gt; represents an open connection between the client and the server. A &lt;em&gt;connection&lt;/em&gt; is the name for the full request and response process in which a client connects to the server, the server generates a response, and the server closes the connection. As such, &lt;code&gt;TcpStream&lt;/code&gt; will read from itself to see what the client sent and then allow us to write our response to the stream. Overall, this &lt;code&gt;for&lt;/code&gt; loop will process each connection in turn and produce a series of streams for us to handle.</source>
          <target state="translated">&lt;code&gt;incoming&lt;/code&gt; метод на &lt;code&gt;TcpListener&lt;/code&gt; возвращает итератор , который дает нам последовательность потоков (более конкретно, потоки типа &lt;code&gt;TcpStream&lt;/code&gt; ). Один &lt;em&gt;поток&lt;/em&gt; представляет собой открытое соединение между клиентом и сервером. &lt;em&gt;Соединение&lt;/em&gt; является именем для полного запроса и ответ процесса , в котором клиент подключается к серверу, сервер генерирует ответ, и сервер закрывает соединение. Таким образом, &lt;code&gt;TcpStream&lt;/code&gt; будет читать из самого себя, чтобы увидеть, что отправил клиент, а затем позволяет нам записать наш ответ в поток. В целом, этот цикл &lt;code&gt;for&lt;/code&gt; будет обрабатывать каждое соединение по очереди и создавать серию потоков, которые мы будем обрабатывать.</target>
        </trans-unit>
        <trans-unit id="3ae3f99054fefa43fcfe679af5b3d84ea2c62ac1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;inline&lt;/code&gt; attribute</source>
          <target state="translated">&lt;code&gt;inline&lt;/code&gt; атрибут</target>
        </trans-unit>
        <trans-unit id="f0d784eef56974f3daef0d597995f18b5e5f8afb" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;inline&lt;/code&gt; attribute only supports two arguments:</source>
          <target state="translated">&lt;code&gt;inline&lt;/code&gt; атрибут поддерживает только два аргумента:</target>
        </trans-unit>
        <trans-unit id="bc1a141c850728d98b956fd0716ebc10f9ffb6e7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;inline&lt;/code&gt; attribute was malformed.</source>
          <target state="translated">&lt;code&gt;inline&lt;/code&gt; атрибут был неправильно сформирован.</target>
        </trans-unit>
        <trans-unit id="4788ad11ac891125e5295255c9d02cd7b36750e0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;isize&lt;/code&gt; type is a signed integer type with the same number of bits as the platform's pointer type. The theoretical upper bound on object and array size is the maximum &lt;code&gt;isize&lt;/code&gt; value. This ensures that &lt;code&gt;isize&lt;/code&gt; can be used to calculate differences between pointers into an object or array and can address every byte within an object along with one byte past the end.</source>
          <target state="translated">Тип &lt;code&gt;isize&lt;/code&gt; - это целочисленный тип со знаком с тем же количеством битов, что и тип указателя платформы. Теоретическая верхняя граница размера объекта и массива - это максимальное значение &lt;code&gt;isize&lt;/code&gt; . Это гарантирует, что &lt;code&gt;isize&lt;/code&gt; можно использовать для вычисления различий между указателями на объект или массив и может адресовать каждый байт в объекте вместе с одним байтом после конца.</target>
        </trans-unit>
        <trans-unit id="7d599bd6c4aa9e941662680b3c4cf55e952c7777" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;it_works&lt;/code&gt; function now has a return type, &lt;code&gt;Result&amp;lt;(), String&amp;gt;&lt;/code&gt;. In the body of the function, rather than calling the &lt;code&gt;assert_eq!&lt;/code&gt; macro, we return &lt;code&gt;Ok(())&lt;/code&gt; when the test passes and an &lt;code&gt;Err&lt;/code&gt; with a &lt;code&gt;String&lt;/code&gt; inside when the test fails.</source>
          <target state="translated">Функция &lt;code&gt;it_works&lt;/code&gt; теперь имеет возвращаемый тип &lt;code&gt;Result&amp;lt;(), String&amp;gt;&lt;/code&gt; . В теле функции вместо вызова &lt;code&gt;assert_eq!&lt;/code&gt; макрос, мы возвращаем &lt;code&gt;Ok(())&lt;/code&gt; когда тест проходит, и &lt;code&gt;Err&lt;/code&gt; со &lt;code&gt;String&lt;/code&gt; внутри, когда тест не проходит.</target>
        </trans-unit>
        <trans-unit id="d7cf351f8d0a069e43102c73f4dd09e2f7958bd2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;largest&lt;/code&gt; function has a parameter called &lt;code&gt;list&lt;/code&gt;, which represents any concrete slice of &lt;code&gt;i32&lt;/code&gt; values that we might pass into the function. As a result, when we call the function, the code runs on the specific values that we pass in.</source>
          <target state="translated">Самая &lt;code&gt;largest&lt;/code&gt; функция имеет параметр с именем &lt;code&gt;list&lt;/code&gt; , который представляет любой конкретный фрагмент значений &lt;code&gt;i32&lt;/code&gt; , который мы можем передать в функцию. В результате, когда мы вызываем функцию, код работает с конкретными значениями, которые мы передаем.</target>
        </trans-unit>
        <trans-unit id="29c272390da5b69d23c340bb06b514ca355b63f0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;largest_i32&lt;/code&gt; function is the one we extracted in Listing 10-3 that finds the largest &lt;code&gt;i32&lt;/code&gt; in a slice. The &lt;code&gt;largest_char&lt;/code&gt; function finds the largest &lt;code&gt;char&lt;/code&gt; in a slice. The function bodies have the same code, so let&amp;rsquo;s eliminate the duplication by introducing a generic type parameter in a single function.</source>
          <target state="translated">Самую &lt;code&gt;largest_i32&lt;/code&gt; функцию i32 мы извлекли в листинге 10-3, которая находит самый большой &lt;code&gt;i32&lt;/code&gt; в срезе. Функция &lt;code&gt;largest_char&lt;/code&gt; находит самый большой &lt;code&gt;char&lt;/code&gt; в срезе. Тела функций имеют один и тот же код, поэтому давайте устраним дублирование, введя параметр универсального типа в одну функцию.</target>
        </trans-unit>
        <trans-unit id="d1c6673a10646101d9e252f3f63c9d87dc9cd482" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;len&lt;/code&gt; argument is the number of &lt;strong&gt;elements&lt;/strong&gt;, not the number of bytes.</source>
          <target state="translated">&lt;code&gt;len&lt;/code&gt; аргумент число &lt;strong&gt;элементов&lt;/strong&gt; , а не число байтов.</target>
        </trans-unit>
        <trans-unit id="eabd24b648d02186aedafa8c6e64a26cd4789b21" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;let y = 6&lt;/code&gt; statement does not return a value, so there isn&amp;rsquo;t anything for &lt;code&gt;x&lt;/code&gt; to bind to. This is different from what happens in other languages, such as C and Ruby, where the assignment returns the value of the assignment. In those languages, you can write &lt;code&gt;x = y = 6&lt;/code&gt; and have both &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; have the value &lt;code&gt;6&lt;/code&gt;; that is not the case in Rust.</source>
          <target state="translated">Оператор &lt;code&gt;let y = 6&lt;/code&gt; не возвращает значения, поэтому &lt;code&gt;x&lt;/code&gt; не к чему привязываться. Это отличается от того, что происходит в других языках, таких как C и Ruby, где присваивание возвращает значение присваивания. На этих языках вы можете написать &lt;code&gt;x = y = 6&lt;/code&gt; и указать, что &lt;code&gt;x&lt;/code&gt; и &lt;code&gt;y&lt;/code&gt; имеют значение &lt;code&gt;6&lt;/code&gt; ; в Rust дело обстоит иначе.</target>
        </trans-unit>
        <trans-unit id="38e40fe06999fccdbadcd0aed2907afe5c6e93b4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;lines&lt;/code&gt; method returns an iterator. We&amp;rsquo;ll talk about iterators in depth in &lt;a href=&quot;ch13-02-iterators&quot;&gt;Chapter 13&lt;/a&gt;, but recall that you saw this way of using an iterator in &lt;a href=&quot;ch03-05-control-flow#looping-through-a-collection-with-for&quot;&gt;Listing 3-5&lt;/a&gt;, where we used a &lt;code&gt;for&lt;/code&gt; loop with an iterator to run some code on each item in a collection.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eb368f642161e00040244b9fcf42bf09c020466c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;lines&lt;/code&gt; method returns an iterator. We&amp;rsquo;ll talk about iterators in depth in [Chapter 13][ch13], but recall that you saw this way of using an iterator in &lt;a href=&quot;ch03-05-control-flow#looping-through-a-collection-with-for&quot;&gt;Listing 3-5&lt;/a&gt;, where we used a &lt;code&gt;for&lt;/code&gt; loop with an iterator to run some code on each item in a collection.</source>
          <target state="translated">Метод &lt;code&gt;lines&lt;/code&gt; возвращает итератор. Мы подробно поговорим об итераторах в [Глава 13] [ch13], но помните, что вы видели этот способ использования итератора в &lt;a href=&quot;ch03-05-control-flow#looping-through-a-collection-with-for&quot;&gt;листинге 3-5&lt;/a&gt; , где мы использовали цикл &lt;code&gt;for&lt;/code&gt; с итератором для выполнения некоторого кода для каждого элемента. в коллекции.</target>
        </trans-unit>
        <trans-unit id="eb1d841506acd030675c6922085c83e81e995a8f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;link&lt;/code&gt; attribute</source>
          <target state="translated">&lt;code&gt;link&lt;/code&gt; атрибут</target>
        </trans-unit>
        <trans-unit id="49ce3813b3cc29f6621eed5040dfcafe494f7af6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;link_name&lt;/code&gt; attribute</source>
          <target state="translated">&lt;code&gt;link_name&lt;/code&gt; атрибут</target>
        </trans-unit>
        <trans-unit id="affa85dfaaac9c19595e178102133ab86d473f6f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;link_name&lt;/code&gt; attribute may be specified on declarations inside an &lt;code&gt;extern&lt;/code&gt; block to indicate the symbol to import for the given function or static. It uses the &lt;a href=&quot;../attributes#meta-item-attribute-syntax&quot;&gt;&lt;em&gt;MetaNameValueStr&lt;/em&gt;&lt;/a&gt; syntax to specify the name of the symbol.</source>
          <target state="translated">&lt;code&gt;link_name&lt;/code&gt; атрибут может быть указан деклараций внутри &lt;code&gt;extern&lt;/code&gt; блока , чтобы указать символ для импорта для данной функции или статической. Он использует синтаксис &lt;a href=&quot;../attributes#meta-item-attribute-syntax&quot;&gt;&lt;em&gt;MetaNameValueStr&lt;/em&gt;&lt;/a&gt; для указания имени символа.</target>
        </trans-unit>
        <trans-unit id="76e0be66315f639652150dfe37a31422ede56b88" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;link_section&lt;/code&gt; attribute</source>
          <target state="translated">&lt;code&gt;link_section&lt;/code&gt; атрибут</target>
        </trans-unit>
        <trans-unit id="5d3ac97ce0e51b7500958397678a0747500d6a86" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;locality&lt;/code&gt; argument must be a constant integer and is a temporal locality specifier ranging from (0) - no locality, to (3) - extremely local keep in cache</source>
          <target state="translated">&lt;code&gt;locality&lt;/code&gt; аргумент должен быть постоянным целым числом и временная локальность спецификатор в пределах от (0) - нет населенного пункта, в (3) - исключительно локальные иметь в кэше</target>
        </trans-unit>
        <trans-unit id="08d3f68a2cf00952341cb92b2cabeabf4f7aad60" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;locality&lt;/code&gt; argument must be a constant integer and is a temporal locality specifier ranging from (0) - no locality, to (3) - extremely local keep in cache.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ef1c91d4a25bd321565ee99def8880c9e7e661ee" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;loop&lt;/code&gt; keyword creates an infinite loop. We&amp;rsquo;ll add that now to give users more chances at guessing the number:</source>
          <target state="translated">&lt;code&gt;loop&lt;/code&gt; ключевое слово создает бесконечный цикл. Мы добавим это сейчас, чтобы дать пользователям больше шансов угадать число:</target>
        </trans-unit>
        <trans-unit id="ebe9e1bcc2f0843b5208a2b5109915be71857732" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;loop&lt;/code&gt; keyword tells Rust to execute a block of code over and over again forever or until you explicitly tell it to stop.</source>
          <target state="translated">&lt;code&gt;loop&lt;/code&gt; ключевое слово говорит Rust, чтобы выполнить блок кода снова и снова навсегда или пока вы явно сказать ему , чтобы остановить.</target>
        </trans-unit>
        <trans-unit id="9910971bdcb643aec0b768364519db2f99d5aff4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;macro_use&lt;/code&gt; attribute</source>
          <target state="translated">&lt;code&gt;macro_use&lt;/code&gt; атрибут</target>
        </trans-unit>
        <trans-unit id="c25fb9655125d01a5a1e9d67f7f0780bc361281a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;main&lt;/code&gt; function here creates an instance of the &lt;code&gt;ImportantExcerpt&lt;/code&gt; struct that holds a reference to the first sentence of the &lt;code&gt;String&lt;/code&gt; owned by the variable &lt;code&gt;novel&lt;/code&gt;. The data in &lt;code&gt;novel&lt;/code&gt; exists before the &lt;code&gt;ImportantExcerpt&lt;/code&gt; instance is created. In addition, &lt;code&gt;novel&lt;/code&gt; doesn&amp;rsquo;t go out of scope until after the &lt;code&gt;ImportantExcerpt&lt;/code&gt; goes out of scope, so the reference in the &lt;code&gt;ImportantExcerpt&lt;/code&gt; instance is valid.</source>
          <target state="translated">Здесь &lt;code&gt;main&lt;/code&gt; функция создает экземпляр структуры &lt;code&gt;ImportantExcerpt&lt;/code&gt; , которая содержит ссылку на первое предложение &lt;code&gt;String&lt;/code&gt; принадлежащей переменной &lt;code&gt;novel&lt;/code&gt; . Данные в &lt;code&gt;novel&lt;/code&gt; существуют до создания экземпляра &lt;code&gt;ImportantExcerpt&lt;/code&gt; . Кроме того, &lt;code&gt;novel&lt;/code&gt; не выходит за пределы области действия до тех пор, пока не выходит за пределы области действия &lt;code&gt;ImportantExcerpt&lt;/code&gt; , поэтому ссылка в экземпляре &lt;code&gt;ImportantExcerpt&lt;/code&gt; действительна.</target>
        </trans-unit>
        <trans-unit id="db5fe1609c8c74f709a4f1880a24bb8f27550e1d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;main&lt;/code&gt; function is special, and there are restrictions on what its return type must be. One valid return type for main is &lt;code&gt;()&lt;/code&gt;, and conveniently, another valid return type is &lt;code&gt;Result&amp;lt;T, E&amp;gt;&lt;/code&gt;, as shown here:</source>
          <target state="translated">Функция &lt;code&gt;main&lt;/code&gt; особенная, и существуют ограничения на ее возвращаемый тип. Один допустимый тип возврата для main - &lt;code&gt;()&lt;/code&gt; , а другой допустимый тип возврата - &lt;code&gt;Result&amp;lt;T, E&amp;gt;&lt;/code&gt; , как показано здесь:</target>
        </trans-unit>
        <trans-unit id="df8be9695315286ea699a84bc57bf274e0dcbb5a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;main&lt;/code&gt; function prototype should never take arguments. Example:</source>
          <target state="translated">&lt;code&gt;main&lt;/code&gt; прототип функции не должен принимать аргументы. Пример:</target>
        </trans-unit>
        <trans-unit id="db6afd48cca2e467a026116d5334792843766266" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;main&lt;/code&gt; function was defined with generic parameters.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b77f7c754f9c38d3041a1e299a31ef7eeecfa144" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;main&lt;/code&gt; function was incorrectly declared.</source>
          <target state="translated">&lt;code&gt;main&lt;/code&gt; функция была неправильно объявлена.</target>
        </trans-unit>
        <trans-unit id="43e2fa6b27c55d262177050d71a4a20b71217bb8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;move&lt;/code&gt; closure is often used alongside &lt;code&gt;thread::spawn&lt;/code&gt; because it allows you to use data from one thread in another thread.</source>
          <target state="translated">&lt;code&gt;move&lt;/code&gt; закрытие часто используется вместе с &lt;code&gt;thread::spawn&lt;/code&gt; , потому что позволяет использовать данные из одного потока в другой нити.</target>
        </trans-unit>
        <trans-unit id="619f2d182d04cd2437b9280f0034a655e725227f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;mpsc::channel&lt;/code&gt; function returns a tuple, the first element of which is the sending end and the second element is the receiving end. The abbreviations &lt;code&gt;tx&lt;/code&gt; and &lt;code&gt;rx&lt;/code&gt; are traditionally used in many fields for &lt;em&gt;transmitter&lt;/em&gt; and &lt;em&gt;receiver&lt;/em&gt; respectively, so we name our variables as such to indicate each end. We&amp;rsquo;re using a &lt;code&gt;let&lt;/code&gt; statement with a pattern that destructures the tuples; we&amp;rsquo;ll discuss the use of patterns in &lt;code&gt;let&lt;/code&gt; statements and destructuring in Chapter 18. Using a &lt;code&gt;let&lt;/code&gt; statement this way is a convenient approach to extract the pieces of the tuple returned by &lt;code&gt;mpsc::channel&lt;/code&gt;.</source>
          <target state="translated">Функция &lt;code&gt;mpsc::channel&lt;/code&gt; возвращает кортеж, первый элемент которого является передающей стороной, а второй - принимающей стороной. Сокращения &lt;code&gt;tx&lt;/code&gt; и &lt;code&gt;rx&lt;/code&gt; традиционно используются во многих полях для &lt;em&gt;передатчика&lt;/em&gt; и &lt;em&gt;приемника&lt;/em&gt; соответственно, поэтому мы называем наши переменные как таковые, чтобы указать каждый конец. Мы используем оператор &lt;code&gt;let&lt;/code&gt; с шаблоном, который разрушает кортежи; мы обсудим использование шаблонов в операторах &lt;code&gt;let&lt;/code&gt; и деструктурирование в главе 18. Использование оператора &lt;code&gt;let&lt;/code&gt; таким образом является удобным подходом для извлечения частей кортежа, возвращаемого &lt;code&gt;mpsc::channel&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0a5adaf35abd6fb52abc875dfd1ff8ace4487057" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;must_use&lt;/code&gt; attribute</source>
          <target state="translated">&lt;code&gt;must_use&lt;/code&gt; атрибут</target>
        </trans-unit>
        <trans-unit id="4dc21fbdabdadeb25794ca5fcb0a8eb690cc55f3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;must_use&lt;/code&gt; attribute may include a message by using the &lt;a href=&quot;../attributes#meta-item-attribute-syntax&quot;&gt;&lt;em&gt;MetaNameValueStr&lt;/em&gt;&lt;/a&gt; syntax such as &lt;code&gt;#[must_use = &quot;example message&quot;]&lt;/code&gt;. The message will be given alongside the warning.</source>
          <target state="translated">&lt;code&gt;must_use&lt;/code&gt; атрибут может включать в себя сообщение, используя &lt;a href=&quot;../attributes#meta-item-attribute-syntax&quot;&gt;&lt;em&gt;MetaNameValueStr&lt;/em&gt;&lt;/a&gt; синтаксиса , такие как &lt;code&gt;#[must_use = &quot;example message&quot;]&lt;/code&gt; . Сообщение будет отображаться вместе с предупреждением.</target>
        </trans-unit>
        <trans-unit id="fa08dd7bde9ed9336c6bf68b835c76ace5a2b281" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;name&lt;/code&gt; key must be included if &lt;code&gt;kind&lt;/code&gt; is specified.</source>
          <target state="translated">&lt;code&gt;name&lt;/code&gt; ключ должен быть включен , если &lt;code&gt;kind&lt;/code&gt; указан.</target>
        </trans-unit>
        <trans-unit id="4f5d61c5238b80d1372117cdc9301f7c5a015909" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;no_builtins&lt;/code&gt; attribute</source>
          <target state="translated">&lt;code&gt;no_builtins&lt;/code&gt; атрибут</target>
        </trans-unit>
        <trans-unit id="0e25b9ca8aa17342df965438e7d8b3912387ac96" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;no_link&lt;/code&gt; attribute</source>
          <target state="translated">&lt;code&gt;no_link&lt;/code&gt; атрибут</target>
        </trans-unit>
        <trans-unit id="4c0b9a2602cdb8c2f59fe6476a9d0299ede88a3c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;no_main&lt;/code&gt; attribute</source>
          <target state="translated">&lt;code&gt;no_main&lt;/code&gt; атрибут</target>
        </trans-unit>
        <trans-unit id="63ed748c3f1f47aec501358b0494a62e8e33119a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;no_mangle&lt;/code&gt; attribute</source>
          <target state="translated">&lt;code&gt;no_mangle&lt;/code&gt; атрибут</target>
        </trans-unit>
        <trans-unit id="f6746e3c0ec6ce06b907e0392a7e5f26c1647e02" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;not&lt;/code&gt; cfg-predicate was malformed.</source>
          <target state="translated">&lt;code&gt;not&lt;/code&gt; CFG-предикат был неправильно сформирован.</target>
        </trans-unit>
        <trans-unit id="522f2fe5c8ca134ded384cd8e598baad904cbb06" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;not&lt;/code&gt; predicate expects one cfg-pattern. Example:</source>
          <target state="translated">&lt;code&gt;not&lt;/code&gt; предикатные ожидает один CFG-шаблон. Пример:</target>
        </trans-unit>
        <trans-unit id="b32d84af66b0734455999894598a8249aed66fbb" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;number&lt;/code&gt; variable will be bound to a value based on the outcome of the &lt;code&gt;if&lt;/code&gt; expression. Run this code to see what happens:</source>
          <target state="translated">&lt;code&gt;number&lt;/code&gt; переменная будет связана со значением , основанной на результатах , &lt;code&gt;if&lt;/code&gt; выражение. Запустите этот код, чтобы увидеть, что происходит:</target>
        </trans-unit>
        <trans-unit id="60fb1fa966c95caff6ec3f67558fb81ff746c1d4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;op_string_ref&lt;/code&gt; binding has type &lt;code&gt;&amp;amp;Option&amp;lt;&amp;amp;String&amp;gt;&lt;/code&gt; in both cases.</source>
          <target state="translated">&lt;code&gt;op_string_ref&lt;/code&gt; связывания имеет типа &lt;code&gt;&amp;amp;Option&amp;lt;&amp;amp;String&amp;gt;&lt;/code&gt; , в обеих случаях.</target>
        </trans-unit>
        <trans-unit id="2d0c9a8f467995322cb26a15b43a2ed10bd928bc" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;opt-level&lt;/code&gt; setting controls the number of optimizations Rust will apply to your code, with a range of 0 to 3. Applying more optimizations extends compiling time, so if you&amp;rsquo;re in development and compiling your code often, you&amp;rsquo;ll want faster compiling even if the resulting code runs slower. That is the reason the default &lt;code&gt;opt-level&lt;/code&gt; for &lt;code&gt;dev&lt;/code&gt; is &lt;code&gt;0&lt;/code&gt;. When you&amp;rsquo;re ready to release your code, it&amp;rsquo;s best to spend more time compiling. You&amp;rsquo;ll only compile in release mode once, but you&amp;rsquo;ll run the compiled program many times, so release mode trades longer compile time for code that runs faster. That is why the default &lt;code&gt;opt-level&lt;/code&gt; for the &lt;code&gt;release&lt;/code&gt; profile is &lt;code&gt;3&lt;/code&gt;.</source>
          <target state="translated">Параметр &lt;code&gt;opt-level&lt;/code&gt; управляет количеством оптимизаций, которые Rust применит к вашему коду, в диапазоне от 0 до 3. Применение большего количества оптимизаций увеличивает время компиляции, поэтому, если вы разрабатываете и часто компилируете свой код, вам нужно быстрее компиляция, даже если результирующий код работает медленнее. По этой причине &lt;code&gt;opt-level&lt;/code&gt; по умолчанию для &lt;code&gt;dev&lt;/code&gt; равен &lt;code&gt;0&lt;/code&gt; . Когда вы будете готовы выпустить свой код, лучше потратить больше времени на компиляцию. Вы скомпилируете в режиме выпуска только один раз, но вы будете запускать скомпилированную программу много раз, поэтому в режиме выпуска увеличивается время компиляции для кода, который выполняется быстрее. Вот почему &lt;code&gt;opt-level&lt;/code&gt; по умолчанию для профиля &lt;code&gt;release&lt;/code&gt; - &lt;code&gt;3&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6a0e04095b896f42634e32e5783ee8a2f1b36521" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;or_insert&lt;/code&gt; method on &lt;code&gt;Entry&lt;/code&gt; is defined to return a mutable reference to the value for the corresponding &lt;code&gt;Entry&lt;/code&gt; key if that key exists, and if not, inserts the parameter as the new value for this key and returns a mutable reference to the new value. This technique is much cleaner than writing the logic ourselves and, in addition, plays more nicely with the borrow checker.</source>
          <target state="translated">Метод &lt;code&gt;or_insert&lt;/code&gt; в &lt;code&gt;Entry&lt;/code&gt; определен для возврата изменяемой ссылки на значение для соответствующего ключа &lt;code&gt;Entry&lt;/code&gt; , если этот ключ существует, а если нет, вставляет параметр как новое значение для этого ключа и возвращает изменяемую ссылку на новое значение. Этот метод намного чище, чем написание логики самостоятельно, и, кроме того, лучше работает с программой проверки заимствований.</target>
        </trans-unit>
        <trans-unit id="6774c9469b6011fbcb32c16aad7d03e8b6f6c4d5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;panic_handler&lt;/code&gt; attribute</source>
          <target state="translated">&lt;code&gt;panic_handler&lt;/code&gt; атрибут</target>
        </trans-unit>
        <trans-unit id="a6291890b4261d452b074ebd1ea09861364cf569" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;path&lt;/code&gt; attribute</source>
          <target state="translated">&lt;code&gt;path&lt;/code&gt; атрибут</target>
        </trans-unit>
        <trans-unit id="eca9cdb5a96c8de323e434d012e339f61d08ae9a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;path&lt;/code&gt; points at a non-directory file.</source>
          <target state="translated">В &lt;code&gt;path&lt;/code&gt; указывает на файл , не являющийся каталогом.</target>
        </trans-unit>
        <trans-unit id="34ed0df01305ce0f75ec5fd43922003af97a525e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;poll&lt;/code&gt; function is not called repeatedly in a tight loop -- instead, it should only be called when the future indicates that it is ready to make progress (by calling &lt;code&gt;wake()&lt;/code&gt;). If you're familiar with the &lt;code&gt;poll(2)&lt;/code&gt; or &lt;code&gt;select(2)&lt;/code&gt; syscalls on Unix it's worth noting that futures typically do &lt;em&gt;not&lt;/em&gt; suffer the same problems of &quot;all wakeups must poll all events&quot;; they are more like &lt;code&gt;epoll(4)&lt;/code&gt;.</source>
          <target state="translated">Функция &lt;code&gt;poll&lt;/code&gt; не вызывается повторно в замкнутом цикле - вместо этого ее следует вызывать только тогда, когда будущее указывает, что она готова к прогрессу (путем вызова &lt;code&gt;wake()&lt;/code&gt; ). Если вы знакомы с системными вызовами &lt;code&gt;poll(2)&lt;/code&gt; или &lt;code&gt;select(2)&lt;/code&gt; в Unix, стоит отметить, что фьючерсы обычно &lt;em&gt;не&lt;/em&gt; страдают теми же проблемами, что &amp;laquo;все пробуждения должны опрашивать все события&amp;raquo;; они больше похожи на &lt;code&gt;epoll(4)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a4cdf57409266ff4ceaefa41a5aa6a9d06ca0f60" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;poll&lt;/code&gt; method</source>
          <target state="translated">&lt;code&gt;poll&lt;/code&gt; методом</target>
        </trans-unit>
        <trans-unit id="f69f8390bb6f3d4deb2545de4fdfa29877369556" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;prefetch&lt;/code&gt; intrinsic is a hint to the code generator to insert a prefetch instruction if supported; otherwise, it is a no-op. Prefetches have no effect on the behavior of the program but can change its performance characteristics.</source>
          <target state="translated">Внутренняя &lt;code&gt;prefetch&lt;/code&gt; является подсказкой генератору кода для вставки инструкции предварительной выборки, если она поддерживается; в противном случае это не работает. Предварительная выборка не влияет на поведение программы, но может изменить ее характеристики производительности.</target>
        </trans-unit>
        <trans-unit id="fa7fa9cd2241a28cad4fa12a2f135f7ef3c12daf" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;println!&lt;/code&gt; function is only capable of printing to standard output, so we have to use something else to print to standard error.</source>
          <target state="translated">&lt;code&gt;println!&lt;/code&gt; функция может печатать только на стандартный вывод, поэтому нам нужно использовать что-то еще, чтобы распечатать стандартную ошибку.</target>
        </trans-unit>
        <trans-unit id="f554c0d8cd003f0dac64077248339772aef74465" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;println!&lt;/code&gt; macro can do many kinds of formatting, and by default, the curly brackets tell &lt;code&gt;println!&lt;/code&gt; to use formatting known as &lt;code&gt;Display&lt;/code&gt;: output intended for direct end user consumption. The primitive types we&amp;rsquo;ve seen so far implement &lt;code&gt;Display&lt;/code&gt; by default, because there&amp;rsquo;s only one way you&amp;rsquo;d want to show a &lt;code&gt;1&lt;/code&gt; or any other primitive type to a user. But with structs, the way &lt;code&gt;println!&lt;/code&gt; should format the output is less clear because there are more display possibilities: Do you want commas or not? Do you want to print the curly brackets? Should all the fields be shown? Due to this ambiguity, Rust doesn&amp;rsquo;t try to guess what we want, and structs don&amp;rsquo;t have a provided implementation of &lt;code&gt;Display&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;println!&lt;/code&gt; макрос может выполнять множество видов форматирования, и по умолчанию фигурные скобки сообщают &lt;code&gt;println!&lt;/code&gt; использовать форматирование, известное как &lt;code&gt;Display&lt;/code&gt; : вывод, предназначенный для непосредственного использования конечным пользователем. Примитивные типы, которые мы видели до сих пор, по умолчанию реализуют &lt;code&gt;Display&lt;/code&gt; , потому что есть только один способ показать пользователю &lt;code&gt;1&lt;/code&gt; или любой другой примитивный тип. Но со структурами способ &lt;code&gt;println!&lt;/code&gt; следует форматировать вывод менее четким, потому что есть больше возможностей отображения: вы хотите запятые или нет? Хотите распечатать фигурные скобки? Должны ли быть показаны все поля? Из-за этой двусмысленности Rust не пытается угадать, что мы хотим, а у структур нет предоставленной реализации &lt;code&gt;Display&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="02931ec361bbc5f61952272ead50c2b1cc721cb3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;println!&lt;/code&gt; macro is only capable of printing to standard output, so we have to use something else to print to standard error.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="df3a7253c874e9c54aed370b97b0410e823ccbd2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;proc_macro&lt;/code&gt; crate</source>
          <target state="translated">&lt;code&gt;proc_macro&lt;/code&gt; клеть</target>
        </trans-unit>
        <trans-unit id="0ebc19fdeafa41e303e045832093f26b01f1011c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;pub&lt;/code&gt; keyword was used inside a function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a4aeb159d9e69df04b16b32d0a540b4e48d1c2ba" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;pub&lt;/code&gt; keyword was used inside a function. Erroneous code example:</source>
          <target state="translated">&lt;code&gt;pub&lt;/code&gt; ключевое слово используется внутри функции. Пример ошибочного кода:</target>
        </trans-unit>
        <trans-unit id="b670fe1e664ec6db0ea27f497b8f300d96565afa" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;pub&lt;/code&gt; keyword was used inside a public enum.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d36ebedc5c61f3368fb308364706ea53f77e634b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;pub&lt;/code&gt; keyword was used inside a public enum. Erroneous code example:</source>
          <target state="translated">&lt;code&gt;pub&lt;/code&gt; ключевое слово было использовано в публичном перечислении. Пример ошибочного кода:</target>
        </trans-unit>
        <trans-unit id="855c30613293c5803da1be19530bcff46d089f73" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;push&lt;/code&gt; method takes a single character as a parameter and adds it to the &lt;code&gt;String&lt;/code&gt;. Listing 8-17 shows code that adds the letter &lt;em&gt;l&lt;/em&gt; to a &lt;code&gt;String&lt;/code&gt; using the &lt;code&gt;push&lt;/code&gt; method.</source>
          <target state="translated">Метод &lt;code&gt;push&lt;/code&gt; принимает один символ в качестве параметра и добавляет его в &lt;code&gt;String&lt;/code&gt; . В листинге 8-17 показан код, который добавляет букву &lt;em&gt;l&lt;/em&gt; в &lt;code&gt;String&lt;/code&gt; с &lt;code&gt;push&lt;/code&gt; метода push .</target>
        </trans-unit>
        <trans-unit id="e7c0b086ee3b65e9ef7299c70cf8f6fd0c56999e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;quote!&lt;/code&gt; macro also provides some very cool templating mechanics: we can enter &lt;code&gt;#name&lt;/code&gt;, and &lt;code&gt;quote!&lt;/code&gt; will replace it with the value in the variable &lt;code&gt;name&lt;/code&gt;. You can even do some repetition similar to the way regular macros work. Check out &lt;a href=&quot;https://docs.rs/quote&quot;&gt;the &lt;code&gt;quote&lt;/code&gt; crate&amp;rsquo;s docs&lt;/a&gt; for a thorough introduction.</source>
          <target state="translated">&lt;code&gt;quote!&lt;/code&gt; макрос также предоставляет очень интересную механику создания шаблонов: мы можем ввести &lt;code&gt;#name&lt;/code&gt; и &lt;code&gt;quote!&lt;/code&gt; заменит его значение в переменной &lt;code&gt;name&lt;/code&gt; . Вы даже можете делать некоторые повторения, как в обычных макросах. Проверьте &lt;a href=&quot;https://docs.rs/quote&quot;&gt;в &lt;code&gt;quote&lt;/code&gt; документов Crate в&lt;/a&gt; течение полного введения.</target>
        </trans-unit>
        <trans-unit id="62ab310a7862369bfdb3998e805adaae0cd4f2e7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;quote!&lt;/code&gt; macro lets us define the Rust code that we want to return. The compiler expects something different to the direct result of the &lt;code&gt;quote!&lt;/code&gt; macro&amp;rsquo;s execution, so we need to convert it to a &lt;code&gt;TokenStream&lt;/code&gt;. We do this by calling the &lt;code&gt;into&lt;/code&gt; method, which consumes this intermediate representation and returns a value of the required &lt;code&gt;TokenStream&lt;/code&gt; type.</source>
          <target state="translated">&lt;code&gt;quote!&lt;/code&gt; макрос позволяет нам определить код Rust, который мы хотим вернуть. Компилятор ожидает чего-то отличного от прямого результата &lt;code&gt;quote!&lt;/code&gt; макроса, поэтому нам нужно преобразовать его в &lt;code&gt;TokenStream&lt;/code&gt; . Мы делаем это, вызывая метод &lt;code&gt;into&lt;/code&gt; , который использует это промежуточное представление и возвращает значение требуемого типа &lt;code&gt;TokenStream&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b83941e960f12671a681a1df28d6d59cb442a02e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;recursion_limit&lt;/code&gt; attribute</source>
          <target state="translated">&lt;code&gt;recursion_limit&lt;/code&gt; атрибут</target>
        </trans-unit>
        <trans-unit id="7fd3ec074e9dd99ae0db784fdf399ea43dd43516" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ref&lt;/code&gt; and/or &lt;code&gt;mut&lt;/code&gt;&lt;em&gt;IDENTIFIER&lt;/em&gt; syntax matches any value and binds it to a variable with the same name as the given field.</source>
          <target state="translated">&lt;code&gt;ref&lt;/code&gt; и / или &lt;code&gt;mut&lt;/code&gt; &lt;em&gt;ИДЕНТИФИКАТОР&lt;/em&gt; синтаксис соответствует любому значению и связывает его с переменной с тем же именем, что и данной области.</target>
        </trans-unit>
        <trans-unit id="a07e646920bfd0169ef8462620bb6bf857e50545" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;repeat()&lt;/code&gt; function repeats a single value over and over again.</source>
          <target state="translated">Функция &lt;code&gt;repeat()&lt;/code&gt; повторяет одно значение снова и снова.</target>
        </trans-unit>
        <trans-unit id="ca6b7fab269378f975039696a9d029f43743fe55" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;repeat_with()&lt;/code&gt; function calls the repeater over and over again.</source>
          <target state="translated">Функция &lt;code&gt;repeat_with()&lt;/code&gt; вызывает повторитель снова и снова.</target>
        </trans-unit>
        <trans-unit id="203b4d4e0f959a4e516770bf1c8acd411f9645d3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;request_review&lt;/code&gt; and &lt;code&gt;approve&lt;/code&gt; methods take ownership of &lt;code&gt;self&lt;/code&gt;, thus consuming the &lt;code&gt;DraftPost&lt;/code&gt; and &lt;code&gt;PendingReviewPost&lt;/code&gt; instances and transforming them into a &lt;code&gt;PendingReviewPost&lt;/code&gt; and a published &lt;code&gt;Post&lt;/code&gt;, respectively. This way, we won&amp;rsquo;t have any lingering &lt;code&gt;DraftPost&lt;/code&gt; instances after we&amp;rsquo;ve called &lt;code&gt;request_review&lt;/code&gt; on them, and so forth. The &lt;code&gt;PendingReviewPost&lt;/code&gt; struct doesn&amp;rsquo;t have a &lt;code&gt;content&lt;/code&gt; method defined on it, so attempting to read its content results in a compiler error, as with &lt;code&gt;DraftPost&lt;/code&gt;. Because the only way to get a published &lt;code&gt;Post&lt;/code&gt; instance that does have a &lt;code&gt;content&lt;/code&gt; method defined is to call the &lt;code&gt;approve&lt;/code&gt; method on a &lt;code&gt;PendingReviewPost&lt;/code&gt;, and the only way to get a &lt;code&gt;PendingReviewPost&lt;/code&gt; is to call the &lt;code&gt;request_review&lt;/code&gt; method on a &lt;code&gt;DraftPost&lt;/code&gt;, we&amp;rsquo;ve now encoded the blog post workflow into the type system.</source>
          <target state="translated">&lt;code&gt;request_review&lt;/code&gt; и &lt;code&gt;approve&lt;/code&gt; методы взять на себя ответственность &lt;code&gt;self&lt;/code&gt; , таким образом , потребляя &lt;code&gt;DraftPost&lt;/code&gt; и &lt;code&gt;PendingReviewPost&lt;/code&gt; экземпляры и преобразующие их в &lt;code&gt;PendingReviewPost&lt;/code&gt; и опубликованное &lt;code&gt;Post&lt;/code&gt; , соответственно. Таким образом, у нас не будет никаких &lt;code&gt;DraftPost&lt;/code&gt; экземпляров DraftPost после того, как мы вызовем для них &lt;code&gt;request_review&lt;/code&gt; и т. Д. Для структуры &lt;code&gt;PendingReviewPost&lt;/code&gt; не определен метод &lt;code&gt;content&lt;/code&gt; , поэтому попытка прочитать ее содержимое приводит к ошибке компилятора, как и в случае с &lt;code&gt;DraftPost&lt;/code&gt; . Потому что единственный способ получить опубликованный &lt;code&gt;Post&lt;/code&gt; Экземпляр, в котором определен метод &lt;code&gt;content&lt;/code&gt; - это вызвать метод &lt;code&gt;approve&lt;/code&gt; в &lt;code&gt;PendingReviewPost&lt;/code&gt; , а единственный способ получить &lt;code&gt;PendingReviewPost&lt;/code&gt; - вызвать метод &lt;code&gt;request_review&lt;/code&gt; в &lt;code&gt;DraftPost&lt;/code&gt; , теперь мы закодировали рабочий процесс публикации в блоге в систему типов.</target>
        </trans-unit>
        <trans-unit id="14e654a0e6edb832d7ec2e9f01e2cec2e8fc8293" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;request_review&lt;/code&gt; method on &lt;code&gt;Draft&lt;/code&gt; needs to return a new, boxed instance of a new &lt;code&gt;PendingReview&lt;/code&gt; struct, which represents the state when a post is waiting for a review. The &lt;code&gt;PendingReview&lt;/code&gt; struct also implements the &lt;code&gt;request_review&lt;/code&gt; method but doesn&amp;rsquo;t do any transformations. Rather, it returns itself, because when we request a review on a post already in the &lt;code&gt;PendingReview&lt;/code&gt; state, it should stay in the &lt;code&gt;PendingReview&lt;/code&gt; state.</source>
          <target state="translated">&lt;code&gt;request_review&lt;/code&gt; метод по &lt;code&gt;Draft&lt;/code&gt; должен вернуть новый коробочный экземпляр нового &lt;code&gt;PendingReview&lt;/code&gt; структуры, которая представляет собой состояние , когда пост ждет обзора. Структура &lt;code&gt;PendingReview&lt;/code&gt; также реализует метод &lt;code&gt;request_review&lt;/code&gt; , но не выполняет никаких преобразований. Скорее, он возвращается сам, потому что, когда мы запрашиваем рецензию на публикацию, уже &lt;code&gt;PendingReview&lt;/code&gt; состоянии PendingReview , она должна оставаться в состоянии &lt;code&gt;PendingReview&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e74e1506742074d3eac6be2b7d8e21235520da47" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;run&lt;/code&gt; command comes in handy when you need to rapidly iterate on a project, as we&amp;rsquo;ll do in this game, quickly testing each iteration before moving on to the next one.</source>
          <target state="translated">Команда &lt;code&gt;run&lt;/code&gt; пригодится, когда вам нужно быстро выполнить итерацию проекта, как мы это сделаем в этой игре, быстро тестируя каждую итерацию, прежде чем переходить к следующей.</target>
        </trans-unit>
        <trans-unit id="46e85b1a08cc19eee77379933feec0b53082268f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;run&lt;/code&gt; function definition</source>
          <target state="translated">Определение функции &lt;code&gt;run&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="5e5f409e03a8829700c6b7a5a46ab61b65379877" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;run&lt;/code&gt; function now contains all the remaining logic from &lt;code&gt;main&lt;/code&gt;, starting from reading the file. The &lt;code&gt;run&lt;/code&gt; function takes the &lt;code&gt;Config&lt;/code&gt; instance as an argument.</source>
          <target state="translated">Функция &lt;code&gt;run&lt;/code&gt; теперь содержит всю оставшуюся логику из &lt;code&gt;main&lt;/code&gt; , начиная с чтения файла. Функция &lt;code&gt;run&lt;/code&gt; принимает в качестве аргумента экземпляр &lt;code&gt;Config&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6fc1541b8f6585c0ffe5cd745827dfb79f574e45" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;rustfmt&lt;/code&gt; tool reformats your code according to the community code style. Many collaborative projects use &lt;code&gt;rustfmt&lt;/code&gt; to prevent arguments about which style to use when writing Rust: everyone formats their code using the tool.</source>
          <target state="translated">Инструмент &lt;code&gt;rustfmt&lt;/code&gt; переформатирует ваш код в соответствии со стилем кода сообщества. Многие совместные проекты используют &lt;code&gt;rustfmt&lt;/code&gt; для предотвращения споров о том, какой стиль использовать при написании Rust: каждый форматирует свой код с помощью этого инструмента.</target>
        </trans-unit>
        <trans-unit id="f41fbdae4087d677734daccb36bd68168ac22c54" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;same_bucket&lt;/code&gt; function is passed references to two elements from the slice and must determine if the elements compare equal. The elements are passed in opposite order from their order in the slice, so if &lt;code&gt;same_bucket(a, b)&lt;/code&gt; returns &lt;code&gt;true&lt;/code&gt;, &lt;code&gt;a&lt;/code&gt; is moved at the end of the slice.</source>
          <target state="translated">В функцию &lt;code&gt;same_bucket&lt;/code&gt; передаются ссылки на два элемента из среза, и она должна определять, равны ли элементы при сравнении. Элементы передаются в порядке, обратном их порядку в срезе, поэтому, если &lt;code&gt;same_bucket(a, b)&lt;/code&gt; возвращает &lt;code&gt;true&lt;/code&gt; , &lt;code&gt;a&lt;/code&gt; перемещается в конец среза.</target>
        </trans-unit>
        <trans-unit id="51106981f7e1a09193991d8a2ebd9672888c0e0a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;same_bucket&lt;/code&gt; function is passed references to two elements from the vector and must determine if the elements compare equal. The elements are passed in opposite order from their order in the slice, so if &lt;code&gt;same_bucket(a, b)&lt;/code&gt; returns &lt;code&gt;true&lt;/code&gt;, &lt;code&gt;a&lt;/code&gt; is removed.</source>
          <target state="translated">Функция &lt;code&gt;same_bucket&lt;/code&gt; передает ссылки на два элемента из вектора и должна определять, равны ли элементы при сравнении. Элементы передаются в порядке, противоположном их порядку в срезе, поэтому, если &lt;code&gt;same_bucket(a, b)&lt;/code&gt; возвращает &lt;code&gt;true&lt;/code&gt; , &lt;code&gt;a&lt;/code&gt; удаляется.</target>
        </trans-unit>
        <trans-unit id="a14ee345d1496dff6fbc5e218ae3b33c17f09dd5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;search_case_insensitive&lt;/code&gt; function, shown in Listing 12-21, will be almost the same as the &lt;code&gt;search&lt;/code&gt; function. The only difference is that we&amp;rsquo;ll lowercase the &lt;code&gt;query&lt;/code&gt; and each &lt;code&gt;line&lt;/code&gt; so whatever the case of the input arguments, they&amp;rsquo;ll be the same case when we check whether the line contains the query.</source>
          <target state="translated">Функция &lt;code&gt;search_case_insensitive&lt;/code&gt; , показанная в Листинге 12-21, будет почти такой же, как функция &lt;code&gt;search&lt;/code&gt; . Единственное отличие состоит в том, что мы будем строчными буквами &lt;code&gt;query&lt;/code&gt; и каждую &lt;code&gt;line&lt;/code&gt; так что независимо от случая входных аргументов, они будут одинаковыми, когда мы проверяем, содержит ли строка запрос.</target>
        </trans-unit>
        <trans-unit id="bbcc387564e51cca06178b88f2766991af78a4d0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;self&lt;/code&gt; crate may be imported which creates a binding to the current crate. In this case the &lt;code&gt;as&lt;/code&gt; clause must be used to specify the name to bind it to.</source>
          <target state="translated">&lt;code&gt;self&lt;/code&gt; обрешетка может быть импортирована , которая создает привязку к текущему обрешетке. В этом случае предложение &lt;code&gt;as&lt;/code&gt; должно использоваться для указания имени для его привязки.</target>
        </trans-unit>
        <trans-unit id="5df3512b09c8677b58f509f70a4092543dbb8630" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;self&lt;/code&gt; import appears more than once in the list.</source>
          <target state="translated">&lt;code&gt;self&lt;/code&gt; импорта появляется более одного раза в списке.</target>
        </trans-unit>
        <trans-unit id="776137337eaf5141c6cf75f1ef731869806d23fc" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;self&lt;/code&gt; keyword can only be used inside methods, which are associated functions (functions defined inside of a &lt;code&gt;trait&lt;/code&gt; or &lt;code&gt;impl&lt;/code&gt; block) that have a &lt;code&gt;self&lt;/code&gt; receiver as its first parameter, like &lt;code&gt;self&lt;/code&gt;, &lt;code&gt;&amp;amp;self&lt;/code&gt;, &lt;code&gt;&amp;amp;mut self&lt;/code&gt; or &lt;code&gt;self: &amp;amp;mut Pin&amp;lt;Self&amp;gt;&lt;/code&gt; (this last one is an example of an &lt;a href=&quot;https://github.com/rust-lang/rust/issues/44874&quot;&gt;&quot;abitrary &lt;code&gt;self&lt;/code&gt; type&quot;&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ca20974e52a0607307348bb19d0d894eb2389060" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;self&lt;/code&gt; keyword cannot appear alone as the last segment in a &lt;code&gt;use&lt;/code&gt; declaration.</source>
          <target state="translated">&lt;code&gt;self&lt;/code&gt; ключевое слово не может появляться в одиночку , как последний сегмент в &lt;code&gt;use&lt;/code&gt; декларации.</target>
        </trans-unit>
        <trans-unit id="3baa95a2b4735c8ad9eb06f47e895376f593ffa3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;self&lt;/code&gt; keyword was used in a static method.</source>
          <target state="translated">&lt;code&gt;self&lt;/code&gt; ключевое слово было использовано в методе статической.</target>
        </trans-unit>
        <trans-unit id="a9568dcdfe3a23be1dee117543923d717013ab13" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;self&lt;/code&gt; keyword was used inside of an associated function without a &quot;&lt;code&gt;self&lt;/code&gt; receiver&quot; parameter.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f67620c2fbc5330097742f848b2b9886ad0ef4ee" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;self&lt;/code&gt; parameter in a method has an invalid &quot;receiver type&quot;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="71e55d8484323ba680a4d79f359c6a8e4726809e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;sent_messages&lt;/code&gt; field is now of type &lt;code&gt;RefCell&amp;lt;Vec&amp;lt;String&amp;gt;&amp;gt;&lt;/code&gt; instead of &lt;code&gt;Vec&amp;lt;String&amp;gt;&lt;/code&gt;. In the &lt;code&gt;new&lt;/code&gt; function, we create a new &lt;code&gt;RefCell&amp;lt;Vec&amp;lt;String&amp;gt;&amp;gt;&lt;/code&gt; instance around the empty vector.</source>
          <target state="translated">Поле &lt;code&gt;sent_messages&lt;/code&gt; теперь имеет тип &lt;code&gt;RefCell&amp;lt;Vec&amp;lt;String&amp;gt;&amp;gt;&lt;/code&gt; вместо &lt;code&gt;Vec&amp;lt;String&amp;gt;&lt;/code&gt; . В &lt;code&gt;new&lt;/code&gt; функции мы создаем новый &lt;code&gt;RefCell&amp;lt;Vec&amp;lt;String&amp;gt;&amp;gt;&lt;/code&gt; вокруг пустого вектора.</target>
        </trans-unit>
        <trans-unit id="337c62942744e545dcf717c6319edbedc18f313b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;shoes_in_my_size&lt;/code&gt; function takes ownership of a vector of shoes and a shoe size as parameters. It returns a vector containing only shoes of the specified size.</source>
          <target state="translated">Функция &lt;code&gt;shoes_in_my_size&lt;/code&gt; принимает в качестве параметров вектор обуви и размер обуви. Он возвращает вектор, содержащий только туфли указанного размера.</target>
        </trans-unit>
        <trans-unit id="16a60caa064b42a78f27eb4d74ff02e2b3b32b36" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;should_panic&lt;/code&gt; attribute</source>
          <target state="translated">&lt;code&gt;should_panic&lt;/code&gt; атрибут</target>
        </trans-unit>
        <trans-unit id="639f1b128b2e8340c54ba2df925fcc505b0aa67b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;should_panic&lt;/code&gt; attribute may optionally take an input string that must appear within the panic message. If the string is not found in the message, then the test will fail. The string may be passed using the &lt;a href=&quot;../attributes#meta-item-attribute-syntax&quot;&gt;&lt;em&gt;MetaNameValueStr&lt;/em&gt;&lt;/a&gt; syntax or the &lt;a href=&quot;../attributes#meta-item-attribute-syntax&quot;&gt;&lt;em&gt;MetaListNameValueStr&lt;/em&gt;&lt;/a&gt; syntax with an &lt;code&gt;expected&lt;/code&gt; field.</source>
          <target state="translated">&lt;code&gt;should_panic&lt;/code&gt; атрибут может необязательно принимать входную строку , которая должна отображаться в сообщении паники. Если строка не найдена в сообщении, тест не пройден. Строку можно передать с использованием синтаксиса &lt;a href=&quot;../attributes#meta-item-attribute-syntax&quot;&gt;&lt;em&gt;MetaNameValueStr&lt;/em&gt;&lt;/a&gt; или синтаксиса &lt;a href=&quot;../attributes#meta-item-attribute-syntax&quot;&gt;&lt;em&gt;MetaListNameValueStr&lt;/em&gt;&lt;/a&gt; с &lt;code&gt;expected&lt;/code&gt; полем.</target>
        </trans-unit>
        <trans-unit id="47db49dacc0e9fe0c5ab4b84de0a525fbcc167ce" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;simd_shuffle&lt;/code&gt; function needs the length of the array passed as last parameter in its name. Example:</source>
          <target state="translated">Функция &lt;code&gt;simd_shuffle&lt;/code&gt; требует длины массива, переданного в качестве последнего параметра в ее имени. Пример:</target>
        </trans-unit>
        <trans-unit id="1728894948cd279e5a554b1af44ad631d3c73ca8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;spawn&lt;/code&gt; function returns a &lt;code&gt;JoinHandle&amp;lt;T&amp;gt;&lt;/code&gt;, where &lt;code&gt;T&lt;/code&gt; is the type that the closure returns. Let&amp;rsquo;s try using &lt;code&gt;JoinHandle&lt;/code&gt; too and see what happens. In our case, the closures we&amp;rsquo;re passing to the thread pool will handle the connection and not return anything, so &lt;code&gt;T&lt;/code&gt; will be the unit type &lt;code&gt;()&lt;/code&gt;.</source>
          <target state="translated">Функция &lt;code&gt;spawn&lt;/code&gt; возвращает &lt;code&gt;JoinHandle&amp;lt;T&amp;gt;&lt;/code&gt; , где &lt;code&gt;T&lt;/code&gt; - это тип, возвращаемый замыканием. Давайте также попробуем использовать &lt;code&gt;JoinHandle&lt;/code&gt; и посмотрим, что произойдет. В нашем случае замыкания, которые мы передаем пулу потоков, будут обрабатывать соединение и ничего не возвращать, поэтому &lt;code&gt;T&lt;/code&gt; будет типом модуля &lt;code&gt;()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="566807adf1a1b2e0676b75e750b724f0403f4cce" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;src&lt;/code&gt; path is not a file or doesn't exist.</source>
          <target state="translated">Путь к &lt;code&gt;src&lt;/code&gt; не является файлом или не существует.</target>
        </trans-unit>
        <trans-unit id="07635229348f3268d25fca1958c374b441ce892b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;start&lt;/code&gt; function was defined with a where clause.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a73480c4afd7847e00e31fe3aafec20a20c54b25" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;static&lt;/code&gt; keyword, on the other hand, guarantees a fixed location in memory. This does not always mean that the value is constant. For example, a global mutex can be declared &lt;code&gt;static&lt;/code&gt; as well.</source>
          <target state="translated">&lt;code&gt;static&lt;/code&gt; ключевое слово, с другой стороны, гарантирует фиксированное место в памяти. Это не всегда означает, что значение постоянное. Например, глобальный мьютекс также может быть объявлен &lt;code&gt;static&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d33afa111381148e1c91bd2523fbea89118180e9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;std::env&lt;/code&gt; module contains many more useful features for dealing with environment variables: check out its documentation to see what is available.</source>
          <target state="translated">Модуль &lt;code&gt;std::env&lt;/code&gt; содержит гораздо больше полезных функций для работы с переменными среды: ознакомьтесь с его документацией, чтобы узнать, что доступно.</target>
        </trans-unit>
        <trans-unit id="bcaf28a16adceb8447193d5235bef5d8bd3335ac" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;std::io&lt;/code&gt; module contains a number of common things you'll need when doing input and output. The most core part of this module is the &lt;a href=&quot;trait.read&quot;&gt;&lt;code&gt;Read&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;trait.write&quot;&gt;&lt;code&gt;Write&lt;/code&gt;&lt;/a&gt; traits, which provide the most general interface for reading and writing input and output.</source>
          <target state="translated">Модуль &lt;code&gt;std::io&lt;/code&gt; содержит ряд общих вещей, которые вам понадобятся при вводе и выводе. Самая основная часть этого модуля - &lt;a href=&quot;trait.read&quot;&gt; &lt;code&gt;Read&lt;/code&gt; &lt;/a&gt; и &lt;a href=&quot;trait.write&quot;&gt; &lt;code&gt;Write&lt;/code&gt; &lt;/a&gt; , которые обеспечивают наиболее общий интерфейс для чтения и записи ввода и вывода.</target>
        </trans-unit>
        <trans-unit id="4a54af6bd4d1bf95ed93c13cd61787ff3a49ae58" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;std::mem::drop&lt;/code&gt; function is different from the &lt;code&gt;drop&lt;/code&gt; method in the &lt;code&gt;Drop&lt;/code&gt; trait. We call it by passing the value we want to force to be dropped early as an argument. The function is in the prelude, so we can modify &lt;code&gt;main&lt;/code&gt; in Listing 15-15 to call the &lt;code&gt;drop&lt;/code&gt; function, as shown in Listing 15-16:</source>
          <target state="translated">Функция &lt;code&gt;std::mem::drop&lt;/code&gt; отличается от метода &lt;code&gt;drop&lt;/code&gt; в &lt;code&gt;Drop&lt;/code&gt; . Мы вызываем это, передавая значение, которое мы хотим принудительно отбросить в качестве аргумента. Функция находится в прелюдии, поэтому мы можем изменить &lt;code&gt;main&lt;/code&gt; в листинге 15-15, чтобы вызвать функцию &lt;code&gt;drop&lt;/code&gt; , как показано в листинге 15-16:</target>
        </trans-unit>
        <trans-unit id="964c58feb2d7a0e4b6c63c315388a37636bb2ffa" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;steps_between&lt;/code&gt; function provides a way to efficiently compare two &lt;code&gt;Step&lt;/code&gt; objects.</source>
          <target state="translated">Функция &lt;code&gt;steps_between&lt;/code&gt; позволяет эффективно сравнивать два объекта &lt;code&gt;Step&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3d6948e046aa3d769d70c7d7f5831db7b61d283e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;str&lt;/code&gt; type, also called a 'string slice', is the most primitive string type. It is usually seen in its borrowed form, &lt;code&gt;&amp;amp;str&lt;/code&gt;. It is also the type of string literals, &lt;code&gt;&amp;amp;'static str&lt;/code&gt;.</source>
          <target state="translated">Тип &lt;code&gt;str&lt;/code&gt; , также называемый &amp;laquo;строковым срезом&amp;raquo;, является наиболее примитивным строковым типом. Обычно встречается в заимствованной форме, &lt;code&gt;&amp;amp;str&lt;/code&gt; . Это также тип строковых литералов &lt;code&gt;&amp;amp;'static str&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4ea4c33d08beaf7c17c84c4930138d5a7a1f80fa" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;stringify!&lt;/code&gt; macro used here is built into Rust. It takes a Rust expression, such as &lt;code&gt;1 + 2&lt;/code&gt;, and at compile time turns the expression into a string literal, such as &lt;code&gt;&quot;1 + 2&quot;&lt;/code&gt;. This is different than &lt;code&gt;format!&lt;/code&gt; or &lt;code&gt;println!&lt;/code&gt;, macros which evaluate the expression and then turn the result into a &lt;code&gt;String&lt;/code&gt;. There is a possibility that the &lt;code&gt;#name&lt;/code&gt; input might be an expression to print literally, so we use &lt;code&gt;stringify!&lt;/code&gt;. Using &lt;code&gt;stringify!&lt;/code&gt; also saves an allocation by converting &lt;code&gt;#name&lt;/code&gt; to a string literal at compile time.</source>
          <target state="translated">&lt;code&gt;stringify!&lt;/code&gt; Используемый здесь макрос встроен в Rust. Он принимает выражение Rust, например &lt;code&gt;1 + 2&lt;/code&gt; , и во время компиляции превращает выражение в строковый литерал, например &lt;code&gt;&quot;1 + 2&quot;&lt;/code&gt; . Это отличается от &lt;code&gt;format!&lt;/code&gt; или &lt;code&gt;println!&lt;/code&gt; , макросы, которые оценивают выражение и затем преобразуют результат в &lt;code&gt;String&lt;/code&gt; . Существует вероятность того, что ввод &lt;code&gt;#name&lt;/code&gt; может быть выражением для печати буквально, поэтому мы используем &lt;code&gt;stringify!&lt;/code&gt; . Используя &lt;code&gt;stringify!&lt;/code&gt; также сохраняет выделение путем преобразования &lt;code&gt;#name&lt;/code&gt; в строковый литерал во время компиляции.</target>
        </trans-unit>
        <trans-unit id="5e2bbf89c9d53502f02966909193300b8b8e39a1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;syn&lt;/code&gt; crate parses Rust code from a string into a data structure that we can perform operations on. The &lt;code&gt;quote&lt;/code&gt; crate turns &lt;code&gt;syn&lt;/code&gt; data structures back into Rust code. These crates make it much simpler to parse any sort of Rust code we might want to handle: writing a full parser for Rust code is no simple task.</source>
          <target state="translated">&lt;code&gt;syn&lt;/code&gt; обрешетка разбирает Rust код из строки в структуру данных , которые мы можем выполнить операции. &lt;code&gt;quote&lt;/code&gt; Crate по очереди &lt;code&gt;syn&lt;/code&gt; структуры данных обратно в Rust код. Эти ящики значительно упрощают синтаксический анализ любого кода Rust, который мы можем захотеть обработать: написание полного парсера для кода Rust - непростая задача.</target>
        </trans-unit>
        <trans-unit id="4c2f6cfbefda1dc3521b2af3bf1923ea6ba12d89" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;take&lt;/code&gt; method is defined in the &lt;code&gt;Iterator&lt;/code&gt; trait and limits the iteration to the first two items at most. The &lt;code&gt;ThreadPool&lt;/code&gt; will go out of scope at the end of &lt;code&gt;main&lt;/code&gt;, and the &lt;code&gt;drop&lt;/code&gt; implementation will run.</source>
          <target state="translated">Метод &lt;code&gt;take&lt;/code&gt; определен в &lt;code&gt;Iterator&lt;/code&gt; и ограничивает итерацию максимум двумя первыми элементами. &lt;code&gt;ThreadPool&lt;/code&gt; будет выходить за рамки в конце &lt;code&gt;main&lt;/code&gt; , а &lt;code&gt;drop&lt;/code&gt; реализации будет работать.</target>
        </trans-unit>
        <trans-unit id="f4261b148ae0a22c8791698e09a2d9939e795de1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;target_feature&lt;/code&gt; attribute</source>
          <target state="translated">&lt;code&gt;target_feature&lt;/code&gt; атрибут</target>
        </trans-unit>
        <trans-unit id="0bfa2ee4e02addd4c71ab19bd1f7c85cc21dadfe" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;test&lt;/code&gt; attribute</source>
          <target state="translated">&lt;code&gt;test&lt;/code&gt; атрибут</target>
        </trans-unit>
        <trans-unit id="c6b28a9d1db605fca4af25fdaf7d2f63f3f4ff7d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;track_caller&lt;/code&gt; attribute may be applied to any function with &lt;a href=&quot;../items/external-blocks#abi&quot;&gt;&lt;code&gt;&quot;Rust&quot;&lt;/code&gt; ABI&lt;/a&gt; with the exception of the entry point &lt;code&gt;fn main&lt;/code&gt;. When applied to functions and methods in trait declarations, the attribute applies to all implementations. If the trait provides a default implementation with the attribute, then the attribute also applies to override implementations.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dbbce8f10ed8de46d53a88134091400a4cad8f24" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;transparent&lt;/code&gt; Representation</source>
          <target state="translated">&lt;code&gt;transparent&lt;/code&gt; Представление</target>
        </trans-unit>
        <trans-unit id="16cfac7d668a26094fafdea930dd55dadb7672de" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;transparent&lt;/code&gt; representation can only be used on &lt;code&gt;struct&lt;/code&gt;s that have a single non-zero sized field and any number of zero-sized fields, including &lt;a href=&quot;special-types-and-traits#phantomdatat&quot;&gt;&lt;code&gt;PhantomData&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;transparent&lt;/code&gt; представление может быть использовано только на &lt;code&gt;struct&lt;/code&gt; с , которые имеют одну ненулевого размер поля и любое количество нулевых размеров полеев, в том числе &lt;a href=&quot;special-types-and-traits#phantomdatat&quot;&gt; &lt;code&gt;PhantomData&amp;lt;T&amp;gt;&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="811b48cd1ea2c8f7773b17e401a6ef4a6664ee6e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;transparent&lt;/code&gt; representation can only be used on a &lt;a href=&quot;items/structs&quot;&gt;&lt;code&gt;struct&lt;/code&gt;&lt;/a&gt; or an &lt;a href=&quot;items/enumerations&quot;&gt;&lt;code&gt;enum&lt;/code&gt;&lt;/a&gt; with a single variant that has:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="01d7d7afaf943b9e9b10757db03a01818240c2c9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;try_recv&lt;/code&gt; method doesn&amp;rsquo;t block, but will instead return a &lt;code&gt;Result&amp;lt;T, E&amp;gt;&lt;/code&gt; immediately: an &lt;code&gt;Ok&lt;/code&gt; value holding a message if one is available and an &lt;code&gt;Err&lt;/code&gt; value if there aren&amp;rsquo;t any messages this time. Using &lt;code&gt;try_recv&lt;/code&gt; is useful if this thread has other work to do while waiting for messages: we could write a loop that calls &lt;code&gt;try_recv&lt;/code&gt; every so often, handles a message if one is available, and otherwise does other work for a little while until checking again.</source>
          <target state="translated">Метод &lt;code&gt;try_recv&lt;/code&gt; не блокируется, но вместо этого немедленно возвращает &lt;code&gt;Result&amp;lt;T, E&amp;gt;&lt;/code&gt; : значение &lt;code&gt;Ok&lt;/code&gt; , содержащее сообщение, если оно доступно, и значение &lt;code&gt;Err&lt;/code&gt; , если на этот раз сообщений нет. Использование &lt;code&gt;try_recv&lt;/code&gt; полезно, если у этого потока есть другая работа в ожидании сообщений: мы могли бы написать цикл, который время от времени вызывает &lt;code&gt;try_recv&lt;/code&gt; , обрабатывает сообщение, если оно доступно, и в противном случае некоторое время выполняет другую работу до повторной проверки.</target>
        </trans-unit>
        <trans-unit id="1c06a34327e19720b6fdb343c408e7c55dd84e16" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;type Target = T;&lt;/code&gt; syntax defines an associated type for the &lt;code&gt;Deref&lt;/code&gt; trait to use. Associated types are a slightly different way of declaring a generic parameter, but you don&amp;rsquo;t need to worry about them for now; we&amp;rsquo;ll cover them in more detail in Chapter 19.</source>
          <target state="translated">&lt;code&gt;type Target = T;&lt;/code&gt; синтаксис определяет связанный тип для использования &lt;code&gt;Deref&lt;/code&gt; . Связанные типы - это немного другой способ объявления универсального параметра, но вам пока не нужно о них беспокоиться; мы рассмотрим их более подробно в главе 19.</target>
        </trans-unit>
        <trans-unit id="ed8f6c9e0893fd91a5e6d611722172ed9ef6f6c2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;type_length_limit&lt;/code&gt; attribute</source>
          <target state="translated">&lt;code&gt;type_length_limit&lt;/code&gt; атрибут</target>
        </trans-unit>
        <trans-unit id="88b76f9ce33c0af8e240ed6b37ada9e83ea43da5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;typeof&lt;/code&gt; keyword is currently reserved but unimplemented.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7495ddf8e7dd908218ee8fe0115f879a8fb5ec94" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;typeof&lt;/code&gt; keyword is currently reserved but unimplemented. Erroneous code example:</source>
          <target state="translated">&lt;code&gt;typeof&lt;/code&gt; ключевое слово в настоящее время зарезервирован , но неосуществленными. Пример ошибочного кода:</target>
        </trans-unit>
        <trans-unit id="dd3cfc211f63708e7ec9409ea2198c30928717cb" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;unsafe&lt;/code&gt; keyword has two uses: to declare the existence of contracts the compiler can't check (&lt;code&gt;unsafe fn&lt;/code&gt; and &lt;code&gt;unsafe trait&lt;/code&gt;), and to declare that a programmer has checked that these contracts have been upheld (&lt;code&gt;unsafe {}&lt;/code&gt; and &lt;code&gt;unsafe impl&lt;/code&gt;, but also &lt;code&gt;unsafe fn&lt;/code&gt; -- see below). They are not mutually exclusive, as can be seen in &lt;code&gt;unsafe fn&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a346e1081bfa2911e1aa0fde6117ab4a081928a4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;unsafe&lt;/code&gt; qualifier indicates that the type's value is an &lt;a href=&quot;../unsafe-functions&quot;&gt;unsafe function&lt;/a&gt;, and the &lt;code&gt;extern&lt;/code&gt; qualifier indicates it is an &lt;a href=&quot;../items/functions#extern-function-qualifier&quot;&gt;extern function&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="994e471fd3da940319d1417edcfca60d6a3db828" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;unsafe&lt;/code&gt; qualifier indicates that the type's value is an &lt;a href=&quot;../unsafe-functions&quot;&gt;unsafe function&lt;/a&gt;, and the &lt;code&gt;extern&lt;/code&gt; qualifier indicates it is an &lt;a href=&quot;../items/functions#extern-functions&quot;&gt;extern function&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;unsafe&lt;/code&gt; классификатор указывает на то, что значение типа в является &lt;a href=&quot;../unsafe-functions&quot;&gt;небезопасным функцией&lt;/a&gt; , а &lt;code&gt;extern&lt;/code&gt; классификатор указывает , что это &lt;a href=&quot;../items/functions#extern-functions&quot;&gt;ехЬегп функция&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="78ba9e0cc65cc7840eaadd16f98f7cca440cd4f4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;unwind&lt;/code&gt; attribute was malformed.</source>
          <target state="translated">&lt;code&gt;unwind&lt;/code&gt; атрибут был неправильно сформирован.</target>
        </trans-unit>
        <trans-unit id="a60fd78a94b551f1746c4a391dd52899994edd99" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;used&lt;/code&gt; attribute</source>
          <target state="translated">&lt;code&gt;used&lt;/code&gt; атрибут</target>
        </trans-unit>
        <trans-unit id="762cbbe7d454d7148fa1b85ecdd6dd222c5646ce" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;usize&lt;/code&gt; type is an unsigned integer type with the same number of bits as the platform's pointer type. It can represent every memory address in the process.</source>
          <target state="translated">Тип &lt;code&gt;usize&lt;/code&gt; - это целочисленный тип без знака с тем же количеством битов, что и тип указателя платформы. Он может представлять каждый адрес памяти в процессе.</target>
        </trans-unit>
        <trans-unit id="ca7074c2679596c96e2d40f1a9e7060f1f83b71a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;value&lt;/code&gt; field is of type &lt;code&gt;Option&amp;lt;u32&amp;gt;&lt;/code&gt;. Before we execute the closure, &lt;code&gt;value&lt;/code&gt; will be &lt;code&gt;None&lt;/code&gt;. When code using a &lt;code&gt;Cacher&lt;/code&gt; asks for the &lt;em&gt;result&lt;/em&gt; of the closure, the &lt;code&gt;Cacher&lt;/code&gt; will execute the closure at that time and store the result within a &lt;code&gt;Some&lt;/code&gt; variant in the &lt;code&gt;value&lt;/code&gt; field. Then if the code asks for the result of the closure again, instead of executing the closure again, the &lt;code&gt;Cacher&lt;/code&gt; will return the result held in the &lt;code&gt;Some&lt;/code&gt; variant.</source>
          <target state="translated">Поле &lt;code&gt;value&lt;/code&gt; имеет тип &lt;code&gt;Option&amp;lt;u32&amp;gt;&lt;/code&gt; . Прежде чем мы выполним закрытие, &lt;code&gt;value&lt;/code&gt; будет &lt;code&gt;None&lt;/code&gt; . Когда код, использующий &lt;code&gt;Cacher&lt;/code&gt; , запрашивает &lt;em&gt;результат&lt;/em&gt; закрытия, &lt;code&gt;Cacher&lt;/code&gt; выполнит закрытие в это время и сохранит результат в варианте &lt;code&gt;Some&lt;/code&gt; в поле &lt;code&gt;value&lt;/code&gt; . Затем, если код снова запрашивает результат закрытия, вместо повторного выполнения закрытия &lt;code&gt;Cacher&lt;/code&gt; вернет результат, содержащийся в варианте &lt;code&gt;Some&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5defa2a7e24b93d29be444c6bce3655062b73aee" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;vtable&lt;/code&gt; customizes the behavior of a &lt;code&gt;Waker&lt;/code&gt; which gets created from a &lt;code&gt;RawWaker&lt;/code&gt;. For each operation on the &lt;code&gt;Waker&lt;/code&gt;, the associated function in the &lt;code&gt;vtable&lt;/code&gt; of the underlying &lt;code&gt;RawWaker&lt;/code&gt; will be called.</source>
          <target state="translated">Таблица &lt;code&gt;vtable&lt;/code&gt; настраивает поведение &lt;code&gt;Waker&lt;/code&gt; , созданного из &lt;code&gt;RawWaker&lt;/code&gt; . Для каждой операции на &lt;code&gt;Waker&lt;/code&gt; будет вызываться соответствующая функция в &lt;code&gt;RawWaker&lt;/code&gt; &lt;code&gt;vtable&lt;/code&gt; базового RawWaker .</target>
        </trans-unit>
        <trans-unit id="58deddf572f1c05716c0aff255109ee68c618f77" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;wasm_import_module&lt;/code&gt; key may be used to specify the &lt;a href=&quot;https://webassembly.github.io/spec/core/syntax/modules.html&quot;&gt;WebAssembly module&lt;/a&gt; name for the items within an &lt;code&gt;extern&lt;/code&gt; block when importing symbols from the host environment. The default module name is &lt;code&gt;env&lt;/code&gt; if &lt;code&gt;wasm_import_module&lt;/code&gt; is not specified.</source>
          <target state="translated">&lt;code&gt;wasm_import_module&lt;/code&gt; ключ может быть использован для определения &lt;a href=&quot;https://webassembly.github.io/spec/core/syntax/modules.html&quot;&gt;модуля WebAssembly&lt;/a&gt; имени для элементов внутри &lt;code&gt;extern&lt;/code&gt; блока при импорте символов из принимающей среды. Имя модуля по умолчанию - &lt;code&gt;env&lt;/code&gt; , если &lt;code&gt;wasm_import_module&lt;/code&gt; не указан.</target>
        </trans-unit>
        <trans-unit id="03b2e1ae71fdcbd9ffac8eca408ab8d4e8472f94" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;width&lt;/code&gt;, &lt;code&gt;height&lt;/code&gt;, and &lt;code&gt;label&lt;/code&gt; fields on &lt;code&gt;Button&lt;/code&gt; will differ from the fields on other components, such as a &lt;code&gt;TextField&lt;/code&gt; type, that might have those fields plus a &lt;code&gt;placeholder&lt;/code&gt; field instead. Each of the types we want to draw on the screen will implement the &lt;code&gt;Draw&lt;/code&gt; trait but will use different code in the &lt;code&gt;draw&lt;/code&gt; method to define how to draw that particular type, as &lt;code&gt;Button&lt;/code&gt; has here (without the actual GUI code, which is beyond the scope of this chapter). The &lt;code&gt;Button&lt;/code&gt; type, for instance, might have an additional &lt;code&gt;impl&lt;/code&gt; block containing methods related to what happens when a user clicks the button. These kinds of methods won&amp;rsquo;t apply to types like &lt;code&gt;TextField&lt;/code&gt;.</source>
          <target state="translated">В &lt;code&gt;width&lt;/code&gt; , &lt;code&gt;height&lt;/code&gt; и &lt;code&gt;label&lt;/code&gt; поля на &lt;code&gt;Button&lt;/code&gt; будет отличаться от полей на другие компоненты, такие как &lt;code&gt;TextField&lt;/code&gt; типа, которые могли бы иметь эти поля плюс &lt;code&gt;placeholder&lt;/code&gt; поля вместо. Каждый из типов, которые мы хотим нарисовать на экране, будет реализовывать черту &lt;code&gt;Draw&lt;/code&gt; , но будет использовать другой код в методе &lt;code&gt;draw&lt;/code&gt; чтобы определить, как рисовать этот конкретный тип, как здесь имеет &lt;code&gt;Button&lt;/code&gt; (без фактического кода GUI, который выходит за рамки этой главы). &lt;code&gt;Button&lt;/code&gt; типа, например, может иметь дополнительный &lt;code&gt;impl&lt;/code&gt; блок, содержащий методы, связанные с тем, что происходит, когда пользователь нажимает кнопку. Такие методы не применимы к таким типам, как &lt;code&gt;TextField&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="49fef96b0756f10c5fd5c7fedcccb9ee963b501d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;windows_subsystem&lt;/code&gt; attribute</source>
          <target state="translated">&lt;code&gt;windows_subsystem&lt;/code&gt; атрибут</target>
        </trans-unit>
        <trans-unit id="fe674a5495eedc22d7ae598194abec96fa238a33" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;write&lt;/code&gt; function takes an output stream, and an &lt;code&gt;Arguments&lt;/code&gt; struct that can be precompiled with the &lt;code&gt;format_args!&lt;/code&gt; macro.</source>
          <target state="translated">Функция &lt;code&gt;write&lt;/code&gt; принимает выходной поток и структуру &lt;code&gt;Arguments&lt;/code&gt; , которую можно предварительно скомпилировать с помощью &lt;code&gt;format_args!&lt;/code&gt; макрос.</target>
        </trans-unit>
        <trans-unit id="5644d7245fdec36266e15ee66f56202b01bc587d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;x&lt;/code&gt; part is a pattern! As we did with &lt;code&gt;let&lt;/code&gt;, we could match a tuple in a function&amp;rsquo;s arguments to the pattern. Listing 18-7 splits the values in a tuple as we pass it to a function.</source>
          <target state="translated">Часть &lt;code&gt;x&lt;/code&gt; - это узор! Как и с &lt;code&gt;let&lt;/code&gt; , мы можем сопоставить кортеж в аргументах функции с шаблоном. Листинг 18-7 разделяет значения в кортеже, когда мы передаем его функции.</target>
        </trans-unit>
        <trans-unit id="90c7cb6860c6df5927660a73f110e2f9166750a3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;x&lt;/code&gt; value is moved into the closure when the closure is defined, because we added the &lt;code&gt;move&lt;/code&gt; keyword. The closure then has ownership of &lt;code&gt;x&lt;/code&gt;, and &lt;code&gt;main&lt;/code&gt; isn&amp;rsquo;t allowed to use &lt;code&gt;x&lt;/code&gt; anymore in the &lt;code&gt;println!&lt;/code&gt; statement. Removing &lt;code&gt;println!&lt;/code&gt; will fix this example.</source>
          <target state="translated">Значение &lt;code&gt;x&lt;/code&gt; перемещается в замыкание, когда замыкание определяется, потому что мы добавили ключевое слово &lt;code&gt;move&lt;/code&gt; . В этом случае замыкание становится владельцем &lt;code&gt;x&lt;/code&gt; , и &lt;code&gt;main&lt;/code&gt; больше не может использовать &lt;code&gt;x&lt;/code&gt; в &lt;code&gt;println!&lt;/code&gt; заявление. Удаление &lt;code&gt;println!&lt;/code&gt; исправлю этот пример.</target>
        </trans-unit>
        <trans-unit id="693d3b957625a8e3df8f4384a832c7be5cfa15d0" translate="yes" xml:space="preserve">
          <source>The &lt;em id=&quot;the-tests-directory&quot;&gt;tests&lt;/em&gt; Directory</source>
          <target state="translated">&lt;em id=&quot;the-tests-directory&quot;&gt;Тесты&lt;/em&gt; каталог</target>
        </trans-unit>
        <trans-unit id="2382217293f35827ef839ef57a6e0636f3faa56f" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;&lt;code&gt;automatically_derived&lt;/code&gt; attribute&lt;/em&gt; is automatically added to &lt;a href=&quot;../items/implementations&quot;&gt;implementations&lt;/a&gt; created by the &lt;code&gt;derive&lt;/code&gt; attribute for built-in traits. It has no direct effect, but it may be used by tools and diagnostic lints to detect these automatically generated implementations.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7d372f8b0a676dc2ae354b920b56c31e1ed0230f" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;&lt;code&gt;cold&lt;/code&gt; &lt;a href=&quot;../attributes&quot;&gt;attribute&lt;/a&gt;&lt;/em&gt; suggests that the attributed function is unlikely to be called.</source>
          <target state="translated">&lt;em&gt; &lt;code&gt;cold&lt;/code&gt; &lt;a href=&quot;../attributes&quot;&gt;атрибут&lt;/a&gt;&lt;/em&gt; показывает , что приписывали функция вряд ли можно назвать.</target>
        </trans-unit>
        <trans-unit id="c8dd94fd6bb692bd54e04ee95744533de367bad8" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;&lt;code&gt;crate_name&lt;/code&gt; &lt;a href=&quot;attributes&quot;&gt;attribute&lt;/a&gt;&lt;/em&gt; may be applied at the crate level to specify the name of the crate with the &lt;a href=&quot;attributes#meta-item-attribute-syntax&quot;&gt;&lt;em&gt;MetaNameValueStr&lt;/em&gt;&lt;/a&gt; syntax.</source>
          <target state="translated">&lt;em&gt; &lt;code&gt;crate_name&lt;/code&gt; &lt;a href=&quot;attributes&quot;&gt;атрибут&lt;/a&gt;&lt;/em&gt; может быть применен на уровне клети , чтобы указать имя ящика с &lt;a href=&quot;attributes#meta-item-attribute-syntax&quot;&gt;&lt;em&gt;MetaNameValueStr&lt;/em&gt;&lt;/a&gt; синтаксисом.</target>
        </trans-unit>
        <trans-unit id="2db8e6439808a243c5fa24e648c2e0fab8ef4d83" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;&lt;code&gt;deprecated&lt;/code&gt; attribute&lt;/em&gt; marks an item as deprecated. &lt;code&gt;rustc&lt;/code&gt; will issue warnings on usage of &lt;code&gt;#[deprecated]&lt;/code&gt; items. &lt;code&gt;rustdoc&lt;/code&gt; will show item deprecation, including the &lt;code&gt;since&lt;/code&gt; version and &lt;code&gt;note&lt;/code&gt;, if available.</source>
          <target state="translated">В &lt;em&gt; &lt;code&gt;deprecated&lt;/code&gt; атрибутах&lt;/em&gt; метка элемент , как осуждаются. &lt;code&gt;rustc&lt;/code&gt; выдаст предупреждения об использовании &lt;code&gt;#[deprecated]&lt;/code&gt; элементов. &lt;code&gt;rustdoc&lt;/code&gt; покажет устаревшие элементы, включая версию &lt;code&gt;since&lt;/code&gt; и &lt;code&gt;note&lt;/code&gt; , если они доступны.</target>
        </trans-unit>
        <trans-unit id="fa15bab6a083f19d9ae9cd7eaa338e697eaf4832" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;&lt;code&gt;derive&lt;/code&gt; attribute&lt;/em&gt; allows new &lt;a href=&quot;../items&quot;&gt;items&lt;/a&gt; to be automatically generated for data structures. It uses the &lt;a href=&quot;../attributes#meta-item-attribute-syntax&quot;&gt;&lt;em&gt;MetaListPaths&lt;/em&gt;&lt;/a&gt; syntax to specify a list of traits to implement or paths to &lt;a href=&quot;../procedural-macros#derive-macros&quot;&gt;derive macros&lt;/a&gt; to process.</source>
          <target state="translated">&lt;em&gt; &lt;code&gt;derive&lt;/code&gt; атрибут&lt;/em&gt; позволяет использовать новые &lt;a href=&quot;../items&quot;&gt;элементы&lt;/a&gt; , которые будут автоматически генерироваться для структур данных. Он использует синтаксис &lt;a href=&quot;../attributes#meta-item-attribute-syntax&quot;&gt;&lt;em&gt;MetaListPaths,&lt;/em&gt;&lt;/a&gt; чтобы указать список признаков для реализации или путей для &lt;a href=&quot;../procedural-macros#derive-macros&quot;&gt;получения макросов&lt;/a&gt; для обработки.</target>
        </trans-unit>
        <trans-unit id="a97c3213ab817ab892d8f6e5c3157736e74b3b32" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;&lt;code&gt;export_name&lt;/code&gt; attribute&lt;/em&gt; specifies the name of the symbol that will be exported on a &lt;a href=&quot;items/functions&quot;&gt;function&lt;/a&gt; or &lt;a href=&quot;items/static-items&quot;&gt;static&lt;/a&gt;. It uses the &lt;a href=&quot;attributes#meta-item-attribute-syntax&quot;&gt;&lt;em&gt;MetaNameValueStr&lt;/em&gt;&lt;/a&gt; syntax to specify the symbol name.</source>
          <target state="translated">&lt;em&gt; &lt;code&gt;export_name&lt;/code&gt; атрибут&lt;/em&gt; определяет имя символа , который будет экспортироваться на &lt;a href=&quot;items/functions&quot;&gt;функцию&lt;/a&gt; или &lt;a href=&quot;items/static-items&quot;&gt;статическими&lt;/a&gt; . Он использует синтаксис &lt;a href=&quot;attributes#meta-item-attribute-syntax&quot;&gt;&lt;em&gt;MetaNameValueStr&lt;/em&gt;&lt;/a&gt; для указания имени символа.</target>
        </trans-unit>
        <trans-unit id="9d1fbcf19af41adeefc0b92335ae4b007c4dadfa" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;&lt;code&gt;global_allocator&lt;/code&gt; attribute&lt;/em&gt; is used on a &lt;a href=&quot;items/static-items&quot;&gt;static item&lt;/a&gt; implementing the &lt;a href=&quot;https://doc.rust-lang.org/alloc/alloc/trait.GlobalAlloc.html&quot;&gt;&lt;code&gt;GlobalAlloc&lt;/code&gt;&lt;/a&gt; trait to set the global allocator.</source>
          <target state="translated">&lt;em&gt; &lt;code&gt;global_allocator&lt;/code&gt; атрибут&lt;/em&gt; используются на &lt;a href=&quot;items/static-items&quot;&gt;статическом элементе&lt;/a&gt; , реализующий &lt;a href=&quot;https://doc.rust-lang.org/alloc/alloc/trait.GlobalAlloc.html&quot;&gt; &lt;code&gt;GlobalAlloc&lt;/code&gt; &lt;/a&gt; черт установить глобальный аллокатор.</target>
        </trans-unit>
        <trans-unit id="eb4af8649334dd85e9ba7979a0a444e3961c900a" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;&lt;code&gt;inline&lt;/code&gt; &lt;a href=&quot;../attributes&quot;&gt;attribute&lt;/a&gt;&lt;/em&gt; suggests that a copy of the attributed function should be placed in the caller, rather than generating code to call the function where it is defined.</source>
          <target state="translated">&lt;em&gt; &lt;code&gt;inline&lt;/code&gt; &lt;a href=&quot;../attributes&quot;&gt;атрибут&lt;/a&gt;&lt;/em&gt; предполагает , что копия приписываемой функции должны быть помещены в вызывающем, а не генерации кода для вызова функции , где она определена.</target>
        </trans-unit>
        <trans-unit id="1d9a7b1456b98dca1d8fed53edde3318db90e4c5" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;&lt;code&gt;link&lt;/code&gt; attribute&lt;/em&gt; specifies the name of a native library that the compiler should link with for the items within an &lt;code&gt;extern&lt;/code&gt; block. It uses the &lt;a href=&quot;../attributes#meta-item-attribute-syntax&quot;&gt;&lt;em&gt;MetaListNameValueStr&lt;/em&gt;&lt;/a&gt; syntax to specify its inputs. The &lt;code&gt;name&lt;/code&gt; key is the name of the native library to link. The &lt;code&gt;kind&lt;/code&gt; key is an optional value which specifies the kind of library with the following possible values:</source>
          <target state="translated">&lt;em&gt; &lt;code&gt;link&lt;/code&gt; атрибут&lt;/em&gt; определяет имя родной библиотеки , которую компилятор должен связать с для элементов внутри &lt;code&gt;extern&lt;/code&gt; блока. Он использует синтаксис &lt;a href=&quot;../attributes#meta-item-attribute-syntax&quot;&gt;&lt;em&gt;MetaListNameValueStr&lt;/em&gt;&lt;/a&gt; для указания своих входных данных. &lt;code&gt;name&lt;/code&gt; ключа имя родной библиотеки по ссылке. &lt;code&gt;kind&lt;/code&gt; ключ является необязательным значением , которое определяет тип библиотеки со следующими возможными значениями:</target>
        </trans-unit>
        <trans-unit id="6603167a8a5aa9df2deb989c68e33b760144ac17" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;&lt;code&gt;link_section&lt;/code&gt; attribute&lt;/em&gt; specifies the section of the object file that a &lt;a href=&quot;items/functions&quot;&gt;function&lt;/a&gt; or &lt;a href=&quot;items/static-items&quot;&gt;static&lt;/a&gt;'s content will be placed into. It uses the &lt;a href=&quot;attributes#meta-item-attribute-syntax&quot;&gt;&lt;em&gt;MetaNameValueStr&lt;/em&gt;&lt;/a&gt; syntax to specify the section name.</source>
          <target state="translated">&lt;em&gt; &lt;code&gt;link_section&lt;/code&gt; атрибут&lt;/em&gt; указывает раздел файла объекта о том , что &lt;a href=&quot;items/functions&quot;&gt;Function&lt;/a&gt; или &lt;a href=&quot;items/static-items&quot;&gt;STATIC&lt;/a&gt; &amp;laquo;сек контент будет помещен в. Он использует синтаксис &lt;a href=&quot;attributes#meta-item-attribute-syntax&quot;&gt;&lt;em&gt;MetaNameValueStr&lt;/em&gt;&lt;/a&gt; для указания имени раздела.</target>
        </trans-unit>
        <trans-unit id="806935dfacd2a07be8b57f073dcdf39509c2b1f7" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;&lt;code&gt;macro_use&lt;/code&gt; attribute&lt;/em&gt; has two purposes. First, it can be used to make a module's macro scope not end when the module is closed, by applying it to a module:</source>
          <target state="translated">&lt;em&gt; &lt;code&gt;macro_use&lt;/code&gt; атрибут&lt;/em&gt; имеет две цели. Во-первых, его можно использовать для того, чтобы область макроса модуля не заканчивалась, когда модуль закрывается, применив его к модулю:</target>
        </trans-unit>
        <trans-unit id="05f0042fe91a37001bd65ea0d74fd9143e55659c" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;&lt;code&gt;must_use&lt;/code&gt; attribute&lt;/em&gt; is used to issue a diagnostic warning when a value is not &quot;used&quot;. It can be applied to user-defined composite types (&lt;a href=&quot;../items/structs&quot;&gt;&lt;code&gt;struct&lt;/code&gt;s&lt;/a&gt;, &lt;a href=&quot;../items/enumerations&quot;&gt;&lt;code&gt;enum&lt;/code&gt;s&lt;/a&gt;, and &lt;a href=&quot;../items/unions&quot;&gt;&lt;code&gt;union&lt;/code&gt;s&lt;/a&gt;), &lt;a href=&quot;../items/functions&quot;&gt;functions&lt;/a&gt;, and &lt;a href=&quot;../items/traits&quot;&gt;traits&lt;/a&gt;.</source>
          <target state="translated">&lt;em&gt; &lt;code&gt;must_use&lt;/code&gt; атрибут&lt;/em&gt; используется для выдачи диагностического предупреждения , когда не будет &amp;laquo;использоваться&amp;raquo; значение. Его можно применять к определяемым пользователем составным типам ( &lt;a href=&quot;../items/structs&quot;&gt; &lt;code&gt;struct&lt;/code&gt; s&lt;/a&gt; , &lt;a href=&quot;../items/enumerations&quot;&gt; &lt;code&gt;enum&lt;/code&gt; s&lt;/a&gt; и &lt;a href=&quot;../items/unions&quot;&gt; &lt;code&gt;union&lt;/code&gt; s&lt;/a&gt; ), &lt;a href=&quot;../items/functions&quot;&gt;функциям&lt;/a&gt; и &lt;a href=&quot;../items/traits&quot;&gt;трейтам&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="df0d5b935c63e0d5d09ad34649237d79db006af9" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;&lt;code&gt;no_builtins&lt;/code&gt; &lt;a href=&quot;../attributes&quot;&gt;attribute&lt;/a&gt;&lt;/em&gt; may be applied at the crate level to disable optimizing certain code patterns to invocations of library functions that are assumed to exist.</source>
          <target state="translated">&lt;em&gt; &lt;code&gt;no_builtins&lt;/code&gt; &lt;a href=&quot;../attributes&quot;&gt;атрибут&lt;/a&gt;&lt;/em&gt; может быть применен на уровне клети , чтобы отключить оптимизации определенных шаблоны коды на вызовы библиотечных функций, которые предположительно существует.</target>
        </trans-unit>
        <trans-unit id="1c5fb5c17e1ae5e93c491f3ff3864f7cf3700a82" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;&lt;code&gt;no_link&lt;/code&gt; attribute&lt;/em&gt; may be specified on an &lt;code&gt;extern crate&lt;/code&gt; item to prevent linking the crate into the output. This is commonly used to load a crate to access only its macros.</source>
          <target state="translated">&lt;em&gt; &lt;code&gt;no_link&lt;/code&gt; атрибут&lt;/em&gt; может быть указан на &lt;code&gt;extern crate&lt;/code&gt; элемента для предотвращения связывания клети на выход. Обычно это используется для загрузки ящика, чтобы получить доступ только к его макросам.</target>
        </trans-unit>
        <trans-unit id="a894d89850015842793e60fc8f351c2309ee5ef4" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;&lt;code&gt;no_main&lt;/code&gt; &lt;a href=&quot;attributes&quot;&gt;attribute&lt;/a&gt;&lt;/em&gt; may be applied at the crate level to disable emitting the &lt;code&gt;main&lt;/code&gt; symbol for an executable binary. This is useful when some other object being linked to defines &lt;code&gt;main&lt;/code&gt;.</source>
          <target state="translated">&lt;em&gt; &lt;code&gt;no_main&lt;/code&gt; &lt;a href=&quot;attributes&quot;&gt;атрибут&lt;/a&gt;&lt;/em&gt; может быть применен на уровне клети , чтобы отключить излучающие &lt;code&gt;main&lt;/code&gt; символ для исполняемого двоичного файла. Это полезно, когда какой-либо другой объект, с которым связывается, определяет &lt;code&gt;main&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f3bcfb88f5c979d523b3f1a38c5f5b56a611b895" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;&lt;code&gt;no_mangle&lt;/code&gt; attribute&lt;/em&gt; may be used on any &lt;a href=&quot;items&quot;&gt;item&lt;/a&gt; to disable standard symbol name mangling. The symbol for the item will be the identifier of the item's name.</source>
          <target state="translated">&lt;em&gt; &lt;code&gt;no_mangle&lt;/code&gt; атрибут&lt;/em&gt; может быть использован на любой &lt;a href=&quot;items&quot;&gt;пункт&lt;/a&gt; , чтобы отключить стандартное имя символа коверкая. Символ предмета будет идентификатором названия предмета.</target>
        </trans-unit>
        <trans-unit id="53a982d72d2f0894ccb0ac1653ff149a9b51224c" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;&lt;code&gt;panic_handler&lt;/code&gt; attribute&lt;/em&gt; can only be applied to a function with signature &lt;code&gt;fn(&amp;amp;PanicInfo) -&amp;gt; !&lt;/code&gt;. The function marked with this &lt;a href=&quot;attributes&quot;&gt;attribute&lt;/a&gt; defines the behavior of panics. The &lt;a href=&quot;https://doc.rust-lang.org/core/panic/struct.PanicInfo.html&quot;&gt;&lt;code&gt;PanicInfo&lt;/code&gt;&lt;/a&gt; struct contains information about the location of the panic. There must be a single &lt;code&gt;panic_handler&lt;/code&gt; function in the dependency graph of a binary, dylib or cdylib crate.</source>
          <target state="translated">&lt;em&gt; &lt;code&gt;panic_handler&lt;/code&gt; атрибут&lt;/em&gt; может быть применен только к функции с подписью &lt;code&gt;fn(&amp;amp;PanicInfo) -&amp;gt; !&lt;/code&gt; . Функция, отмеченная этим &lt;a href=&quot;attributes&quot;&gt;атрибутом,&lt;/a&gt; определяет поведение паники. Структура &lt;a href=&quot;https://doc.rust-lang.org/core/panic/struct.PanicInfo.html&quot;&gt; &lt;code&gt;PanicInfo&lt;/code&gt; &lt;/a&gt; содержит информацию о местоположении паники. Там должна быть одной &lt;code&gt;panic_handler&lt;/code&gt; функция в графе зависимостей бинарной, dylib или cdylib клети.</target>
        </trans-unit>
        <trans-unit id="12cdf01a779d8c77135d5a609c4b4e6849f40d6f" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;&lt;code&gt;recursion_limit&lt;/code&gt; attribute&lt;/em&gt; may be applied at the &lt;a href=&quot;../crates-and-source-files&quot;&gt;crate&lt;/a&gt; level to set the maximum depth for potentially infinitely-recursive compile-time operations like macro expansion or auto-dereference. It uses the &lt;a href=&quot;../attributes#meta-item-attribute-syntax&quot;&gt;&lt;em&gt;MetaNameValueStr&lt;/em&gt;&lt;/a&gt; syntax to specify the recursion depth.</source>
          <target state="translated">&lt;em&gt; &lt;code&gt;recursion_limit&lt;/code&gt; атрибут&lt;/em&gt; может быть применен на &lt;a href=&quot;../crates-and-source-files&quot;&gt;клеть&lt;/a&gt; уровне , чтобы установить глубину максимум для потенциально бесконечно рекурсивных операций во время компиляции , как макроподстановкам или авто-разыменования. Он использует синтаксис &lt;a href=&quot;../attributes#meta-item-attribute-syntax&quot;&gt;&lt;em&gt;MetaNameValueStr&lt;/em&gt;&lt;/a&gt; для указания глубины рекурсии.</target>
        </trans-unit>
        <trans-unit id="a7c71f7f4ce5a08ecec5e3cb423add9b9986d9b2" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;&lt;code&gt;target_feature&lt;/code&gt; &lt;a href=&quot;../attributes&quot;&gt;attribute&lt;/a&gt;&lt;/em&gt; may be applied to an &lt;a href=&quot;../unsafe-functions&quot;&gt;unsafe function&lt;/a&gt; to enable code generation of that function for specific platform architecture features. It uses the &lt;a href=&quot;../attributes#meta-item-attribute-syntax&quot;&gt;&lt;em&gt;MetaListNameValueStr&lt;/em&gt;&lt;/a&gt; syntax with a single key of &lt;code&gt;enable&lt;/code&gt; whose value is a string of comma-separated feature names to enable.</source>
          <target state="translated">&lt;em&gt; &lt;code&gt;target_feature&lt;/code&gt; &lt;a href=&quot;../attributes&quot;&gt;атрибут&lt;/a&gt;&lt;/em&gt; может быть применен к &lt;a href=&quot;../unsafe-functions&quot;&gt;небезопасным функции&lt;/a&gt; , чтобы включить генерацию кода этой функции для конкретных особенностей архитектуры платформы. Он использует синтаксис &lt;a href=&quot;../attributes#meta-item-attribute-syntax&quot;&gt;&lt;em&gt;MetaListNameValueStr&lt;/em&gt;&lt;/a&gt; с одним ключом &lt;code&gt;enable&lt;/code&gt; , значение которого представляет собой строку имен функций, разделенных запятыми, для включения.</target>
        </trans-unit>
        <trans-unit id="3aa1c2ce8a0a269a928c5414e9b6749a40da4909" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;&lt;code&gt;test&lt;/code&gt; attribute&lt;/em&gt; marks a function to be executed as a test. These functions are only compiled when in test mode. Test functions must be free, monomorphic functions that take no arguments, and the return type must be one of the following:</source>
          <target state="translated">В &lt;em&gt; &lt;code&gt;test&lt;/code&gt; атрибутов&lt;/em&gt; метки функцию , которая будет выполнена в качестве теста. Эти функции компилируются только в тестовом режиме. Тестовые функции должны быть свободными, мономорфными функциями, не принимающими аргументов, а возвращаемый тип должен быть одним из следующих:</target>
        </trans-unit>
        <trans-unit id="8e32e2a7306abe757340b9bbe77da987dbdce7fd" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;&lt;code&gt;type_length_limit&lt;/code&gt; attribute&lt;/em&gt; limits the maximum number of type substitutions made when constructing a concrete type during monomorphization. It is applied at the &lt;a href=&quot;../crates-and-source-files&quot;&gt;crate&lt;/a&gt; level, and uses the &lt;a href=&quot;../attributes#meta-item-attribute-syntax&quot;&gt;&lt;em&gt;MetaNameValueStr&lt;/em&gt;&lt;/a&gt; syntax to set the limit based on the number of type substitutions.</source>
          <target state="translated">&lt;em&gt; &lt;code&gt;type_length_limit&lt;/code&gt; атрибут&lt;/em&gt; ограничивает максимальное число типа замен , сделанных при построении типа бетона во monomorphization. Он применяется на уровне &lt;a href=&quot;../crates-and-source-files&quot;&gt;ящика&lt;/a&gt; и использует синтаксис &lt;a href=&quot;../attributes#meta-item-attribute-syntax&quot;&gt;&lt;em&gt;MetaNameValueStr&lt;/em&gt;&lt;/a&gt; для установки ограничения на основе количества замен типов.</target>
        </trans-unit>
        <trans-unit id="6e74f839ef9f1efad1a8f9c7c9bbeff2f9cc5cae" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;&lt;code&gt;used&lt;/code&gt; attribute&lt;/em&gt; can only be applied to &lt;a href=&quot;items/static-items&quot;&gt;&lt;code&gt;static&lt;/code&gt; items&lt;/a&gt;. This &lt;a href=&quot;attributes&quot;&gt;attribute&lt;/a&gt; forces the compiler to keep the variable in the output object file (.o, .rlib, etc. excluding final binaries) even if the variable is not used, or referenced, by any other item in the crate. However, the linker is still free to remove such an item.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f9f3929d821839852e44df6684413a39c02b618f" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;&lt;code&gt;used&lt;/code&gt; attribute&lt;/em&gt; can only be applied to &lt;a href=&quot;items/static-items&quot;&gt;&lt;code&gt;static&lt;/code&gt; items&lt;/a&gt;. This &lt;a href=&quot;attributes&quot;&gt;attribute&lt;/a&gt; forces the compiler to keep the variable in the output object file (.o, .rlib, etc.) even if the variable is not used, or referenced, by any other item in the crate.</source>
          <target state="translated">&lt;em&gt; &lt;code&gt;used&lt;/code&gt; атрибут&lt;/em&gt; может быть применен только к &lt;a href=&quot;items/static-items&quot;&gt; &lt;code&gt;static&lt;/code&gt; пунктам&lt;/a&gt; . Этот &lt;a href=&quot;attributes&quot;&gt;атрибут&lt;/a&gt; заставляет компилятор сохранять переменную в выходном объектном файле (.o, .rlib и т. Д.), Даже если переменная не используется или не упоминается каким-либо другим элементом в корзине.</target>
        </trans-unit>
        <trans-unit id="cabd9dd1fe1f065b8657354c25edb014ad53f468" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;&lt;code&gt;windows_subsystem&lt;/code&gt; attribute&lt;/em&gt; may be applied at the crate level to set the &lt;a href=&quot;https://msdn.microsoft.com/en-us/library/fcc1zstk.aspx&quot;&gt;subsystem&lt;/a&gt; when linking on a Windows target. It uses the &lt;a href=&quot;attributes#meta-item-attribute-syntax&quot;&gt;&lt;em&gt;MetaNameValueStr&lt;/em&gt;&lt;/a&gt; syntax to specify the subsystem with a value of either &lt;code&gt;console&lt;/code&gt; or &lt;code&gt;windows&lt;/code&gt;. This attribute is ignored on non-Windows targets, and for non-&lt;code&gt;bin&lt;/code&gt;&lt;a href=&quot;linkage&quot;&gt;crate types&lt;/a&gt;.</source>
          <target state="translated">&lt;em&gt; &lt;code&gt;windows_subsystem&lt;/code&gt; атрибут&lt;/em&gt; может быть применен на уровне клети , чтобы установить &lt;a href=&quot;https://msdn.microsoft.com/en-us/library/fcc1zstk.aspx&quot;&gt;подсистему&lt;/a&gt; при условии ссылки на целевом Windows. Он использует синтаксис &lt;a href=&quot;attributes#meta-item-attribute-syntax&quot;&gt;&lt;em&gt;MetaNameValueStr,&lt;/em&gt;&lt;/a&gt; чтобы указать подсистему со значением &lt;code&gt;console&lt;/code&gt; или &lt;code&gt;windows&lt;/code&gt; . Этот атрибут игнорируется для целей, отличных от Windows, и для &lt;a href=&quot;linkage&quot;&gt;типов ящиков,&lt;/a&gt; отличных от &lt;code&gt;bin&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="637d9dddc1ad4617a0c58ddffc3922ae87e9baab" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;alignment&lt;/em&gt; of a value specifies what addresses are valid to store the value at. A value of alignment &lt;code&gt;n&lt;/code&gt; must only be stored at an address that is a multiple of n. For example, a value with an alignment of 2 must be stored at an even address, while a value with an alignment of 1 can be stored at any address. Alignment is measured in bytes, and must be at least 1, and always a power of 2. The alignment of a value can be checked with the &lt;a href=&quot;../std/mem/fn.align_of_val&quot;&gt;&lt;code&gt;align_of_val&lt;/code&gt;&lt;/a&gt; function.</source>
          <target state="translated">&lt;em&gt;Выравнивание&lt;/em&gt; стоимостного определяет , какие адреса являются действительными для хранения значения в. Значение выравнивания &lt;code&gt;n&lt;/code&gt; должно храниться только по адресу, кратному n. Например, значение с выравниванием 2 должно храниться по четному адресу, а значение с выравниванием 1 может храниться по любому адресу. Выравнивание измеряется в байтах и ​​должно быть не менее 1 и всегда должно быть степенью 2. Выравнивание значения можно проверить с &lt;a href=&quot;../std/mem/fn.align_of_val&quot;&gt; &lt;code&gt;align_of_val&lt;/code&gt; &lt;/a&gt; функции align_of_val .</target>
        </trans-unit>
        <trans-unit id="caa4287ee2eae29f4b7097731528e2f984499328" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;at&lt;/em&gt; operator (&lt;code&gt;@&lt;/code&gt;) lets us create a variable that holds a value at the same time we&amp;rsquo;re testing that value to see whether it matches a pattern. Listing 18-29 shows an example where we want to test that a &lt;code&gt;Message::Hello&lt;/code&gt;&lt;code&gt;id&lt;/code&gt; field is within the range &lt;code&gt;3...7&lt;/code&gt;. But we also want to bind the value to the variable &lt;code&gt;id_variable&lt;/code&gt; so we can use it in the code associated with the arm. We could name this variable &lt;code&gt;id&lt;/code&gt;, the same as the field, but for this example we&amp;rsquo;ll use a different name.</source>
          <target state="translated">Оператор &lt;em&gt;at&lt;/em&gt; ( &lt;code&gt;@&lt;/code&gt; ) позволяет нам создать переменную, которая содержит значение, в то же время, когда мы проверяем это значение, чтобы увидеть, соответствует ли оно шаблону. В листинге 18-29 показан пример, в котором мы хотим проверить, находится ли поле &lt;code&gt;Message::Hello&lt;/code&gt; &lt;code&gt;id&lt;/code&gt; в диапазоне &lt;code&gt;3...7&lt;/code&gt; . Но мы также хотим привязать значение к переменной &lt;code&gt;id_variable&lt;/code&gt; , чтобы мы могли использовать его в коде, связанном с рукой. Мы могли бы назвать эту переменную &lt;code&gt;id&lt;/code&gt; так же, как поле, но для этого примера мы будем использовать другое имя.</target>
        </trans-unit>
        <trans-unit id="6fe3095ea3510353b505863afd4ade90995e4e2e" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;at&lt;/em&gt; operator (&lt;code&gt;@&lt;/code&gt;) lets us create a variable that holds a value at the same time we&amp;rsquo;re testing that value to see whether it matches a pattern. Listing 18-29 shows an example where we want to test that a &lt;code&gt;Message::Hello&lt;/code&gt;&lt;code&gt;id&lt;/code&gt; field is within the range &lt;code&gt;3..=7&lt;/code&gt;. But we also want to bind the value to the variable &lt;code&gt;id_variable&lt;/code&gt; so we can use it in the code associated with the arm. We could name this variable &lt;code&gt;id&lt;/code&gt;, the same as the field, but for this example we&amp;rsquo;ll use a different name.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="491e011fde2c63e7287e5968a958f99a0e0608ea" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;backslash escape&lt;/em&gt; is the character &lt;code&gt;U+005C&lt;/code&gt; (&lt;code&gt;\&lt;/code&gt;) which must be escaped in order to denote its ASCII encoding &lt;code&gt;0x5C&lt;/code&gt;.</source>
          <target state="translated">&lt;em&gt;Побег обратный слэш&lt;/em&gt; является символ &lt;code&gt;U+005C&lt;/code&gt; ( &lt;code&gt;\&lt;/code&gt; ) , которые должны быть экранированы, чтобы обозначить его ASCII кодирующего &lt;code&gt;0x5C&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e78bebf05e1ce9e264a960c4a634448ed6a163c1" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;backslash escape&lt;/em&gt; is the character &lt;code&gt;U+005C&lt;/code&gt; (&lt;code&gt;\&lt;/code&gt;) which must be escaped in order to denote itself.</source>
          <target state="translated">&lt;em&gt;Побег обратный слэш&lt;/em&gt; является символ &lt;code&gt;U+005C&lt;/code&gt; ( &lt;code&gt;\&lt;/code&gt; ) , которые должны быть экранированы, чтобы обозначить себя.</target>
        </trans-unit>
        <trans-unit id="863e56925d2ff8675a4dd9c4a460d825a809b69e" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;heap&lt;/em&gt; is a general term that describes boxes. The lifetime of an allocation in the heap depends on the lifetime of the box values pointing to it. Since box values may themselves be passed in and out of frames, or stored in the heap, heap allocations may outlive the frame they are allocated within. An allocation in the heap is guaranteed to reside at a single location in the heap for the whole lifetime of the allocation - it will never be relocated as a result of moving a box value.</source>
          <target state="translated">&lt;em&gt;Куча&lt;/em&gt; представляет собой общий термин , который описывает коробки. Время жизни выделения в куче зависит от времени жизни значений поля, указывающих на него. Поскольку значения блоков могут сами передаваться в кадры и из них или сохраняться в куче, выделения в куче могут переживать кадр, в котором они размещены. Выделение в куче гарантированно будет находиться в одном месте в куче в течение всего времени существования выделения - оно никогда не будет перемещено в результате перемещения значения блока.</target>
        </trans-unit>
        <trans-unit id="21ffe4f08baa3ee5d8fcae0ac2b2640039bc170b" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;items&lt;/em&gt; of a program are those functions, modules and types that have their value calculated at compile-time and stored uniquely in the memory image of the rust process. Items are neither dynamically allocated nor freed.</source>
          <target state="translated">В &lt;em&gt;детали&lt;/em&gt; из программы являются теми функциями, модулями и типов , которые их стоимость , рассчитанных во время компиляции и находятся однозначно в образе памяти процесса ржавчины. Элементы не выделяются и не освобождаются динамически.</target>
        </trans-unit>
        <trans-unit id="7f297b31862071391a99da1af535c50f23bb4ea5" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;items&lt;/em&gt; of a program are those functions, modules, and types that have their value calculated at compile-time and stored uniquely in the memory image of the rust process. Items are neither dynamically allocated nor freed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="867bacda5c963969dd78331f878c031b22f73cbb" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;null escape&lt;/em&gt; is the character &lt;code&gt;U+0030&lt;/code&gt; (&lt;code&gt;0&lt;/code&gt;) and denotes the Unicode value &lt;code&gt;U+0000&lt;/code&gt; (NUL).</source>
          <target state="translated">&lt;em&gt;Побег нуля&lt;/em&gt; является символом &lt;code&gt;U+0030&lt;/code&gt; ( &lt;code&gt;0&lt;/code&gt; ) и обозначает значение Unicode &lt;code&gt;U+0000&lt;/code&gt; (NUL).</target>
        </trans-unit>
        <trans-unit id="c0460a3f4832868522908bad2876d5f8fef36d49" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;null escape&lt;/em&gt; is the character &lt;code&gt;U+0030&lt;/code&gt; (&lt;code&gt;0&lt;/code&gt;) and denotes the byte value &lt;code&gt;0x00&lt;/code&gt; (ASCII NUL).</source>
          <target state="translated">&lt;em&gt;Побег нуля&lt;/em&gt; является символом &lt;code&gt;U+0030&lt;/code&gt; ( &lt;code&gt;0&lt;/code&gt; ) и обозначает значение байта &lt;code&gt;0x00&lt;/code&gt; (ASCII NUL).</target>
        </trans-unit>
        <trans-unit id="b4b356718e399f8a05dc4012731a26a28084f252" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;prelude&lt;/em&gt; is the list of things that Rust automatically imports into every Rust program. It's kept as small as possible, and is focused on things, particularly traits, which are used in almost every single Rust program.</source>
          <target state="translated">&lt;em&gt;Прелюдия&lt;/em&gt; список вещей , которые Руст автоматически импортирует в каждую программу Rust. Он минимален, насколько это возможно, и сосредоточен на вещах, особенно на чертах, которые используются почти в каждой программе на Rust.</target>
        </trans-unit>
        <trans-unit id="c5fc79bf9688aa8e786959c2742e411818e5d89a" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;primitive representations&lt;/em&gt; are the representations with the same names as the primitive integer types. That is: &lt;code&gt;u8&lt;/code&gt;, &lt;code&gt;u16&lt;/code&gt;, &lt;code&gt;u32&lt;/code&gt;, &lt;code&gt;u64&lt;/code&gt;, &lt;code&gt;u128&lt;/code&gt;, &lt;code&gt;usize&lt;/code&gt;, &lt;code&gt;i8&lt;/code&gt;, &lt;code&gt;i16&lt;/code&gt;, &lt;code&gt;i32&lt;/code&gt;, &lt;code&gt;i64&lt;/code&gt;, &lt;code&gt;i128&lt;/code&gt;, and &lt;code&gt;isize&lt;/code&gt;.</source>
          <target state="translated">Эти &lt;em&gt;примитивные представления&lt;/em&gt; являются представления с теми же именами, что и примитивных целочисленных типов. То есть: &lt;code&gt;u8&lt;/code&gt; , &lt;code&gt;u16&lt;/code&gt; , &lt;code&gt;u32&lt;/code&gt; , &lt;code&gt;u64&lt;/code&gt; , &lt;code&gt;u128&lt;/code&gt; , &lt;code&gt;usize&lt;/code&gt; , &lt;code&gt;i8&lt;/code&gt; , &lt;code&gt;i16&lt;/code&gt; , &lt;code&gt;i32&lt;/code&gt; , &lt;code&gt;i64&lt;/code&gt; , &lt;code&gt;i128&lt;/code&gt; и &lt;code&gt;isize&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a3ce8f949608b1daede8105623fa327eab5c410b" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;rest pattern&lt;/em&gt; (the &lt;code&gt;..&lt;/code&gt; token) acts as a variable-length pattern which matches zero or more elements that haven't been matched already before and after. It may only be used in &lt;a href=&quot;#tuple-patterns&quot;&gt;tuple&lt;/a&gt;, &lt;a href=&quot;#tuple-struct-patterns&quot;&gt;tuple struct&lt;/a&gt;, and &lt;a href=&quot;#slice-patterns&quot;&gt;slice&lt;/a&gt; patterns, and may only appear once as one of the elements in those patterns. It is also allowed in an &lt;a href=&quot;#identifier-patterns&quot;&gt;identifier pattern&lt;/a&gt; for &lt;a href=&quot;#slice-patterns&quot;&gt;slice patterns&lt;/a&gt; only.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4971362f3b5f40470a74c81b64c44c61022c0ae5" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;size&lt;/em&gt; of a value is the offset in bytes between successive elements in an array with that item type including alignment padding. The size of a value is always a multiple of its alignment. The size of a value can be checked with the &lt;a href=&quot;../std/mem/fn.size_of_val&quot;&gt;&lt;code&gt;size_of_val&lt;/code&gt;&lt;/a&gt; function.</source>
          <target state="translated">&lt;em&gt;Размер&lt;/em&gt; от значения является смещение в байтах между последовательными элементами в массиве с этим типом элемента , включая выравнивание заполнения. Размер значения всегда кратен его выравниванию. Размер значения можно проверить с &lt;a href=&quot;../std/mem/fn.size_of_val&quot;&gt; &lt;code&gt;size_of_val&lt;/code&gt; &lt;/a&gt; функции size_of_val .</target>
        </trans-unit>
        <trans-unit id="608607007d0795edd59e30f51aeabc80ca46b5f6" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;state pattern&lt;/em&gt; is an object-oriented design pattern. The crux of the pattern is that a value has some internal state, which is represented by a set of &lt;em&gt;state objects&lt;/em&gt;, and the value&amp;rsquo;s behavior changes based on the internal state. The state objects share functionality: in Rust, of course, we use structs and traits rather than objects and inheritance. Each state object is responsible for its own behavior and for governing when it should change into another state. The value that holds a state object knows nothing about the different behavior of the states or when to transition between states.</source>
          <target state="translated">&lt;em&gt;Состояние модель&lt;/em&gt; является объектно-ориентированным шаблоном дизайна. Суть шаблона состоит в том, что значение имеет некоторое внутреннее состояние, которое представлено набором &lt;em&gt;объектов состояния&lt;/em&gt; , а поведение значения изменяется в зависимости от внутреннего состояния. Объекты состояния имеют общую функциональность: в Rust, конечно, мы используем структуры и черты, а не объекты и наследование. Каждый объект состояния отвечает за свое поведение и определяет, когда он должен перейти в другое состояние. Значение, содержащее объект состояния, ничего не знает о различном поведении состояний или о том, когда переходить между состояниями.</target>
        </trans-unit>
        <trans-unit id="ec835310b404eed2cb3a60731c66a0fc7069cf96" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;successor&lt;/em&gt; operation moves towards values that compare greater. The &lt;em&gt;predecessor&lt;/em&gt; operation moves towards values that compare lesser.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="71b31d9fd96bdd059ab3da8b882ee0c455f89891" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;temporary scope&lt;/em&gt; of an expression is the scope that is used for the temporary variable that holds the result of that expression when used in a &lt;a href=&quot;expressions#place-expressions-and-value-expressions&quot;&gt;place context&lt;/a&gt;, unless it is &lt;a href=&quot;destructors#constant-promotion&quot;&gt;promoted&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="50c8131f661492ad3eb04d5338d01ccf9f429562" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;wildcard pattern&lt;/em&gt; (an underscore symbol) matches any value. It is used to ignore values when they don't matter. Inside other patterns it matches a single data field (as opposed to the &lt;code&gt;..&lt;/code&gt; which matches the remaining fields). Unlike identifier patterns, it does not copy, move or borrow the value it matches.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2c707e6c38639fd82e39cc81120827bce74e177e" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;wildcard pattern&lt;/em&gt; matches any value. It is used to ignore values when they don't matter. Inside other patterns it matches a single data field (as opposed to the &lt;code&gt;..&lt;/code&gt; which matches the remaining fields). Unlike identifier patterns, it does not copy, move or borrow the value it matches.</source>
          <target state="translated">&lt;em&gt;Подстановочный шаблон&lt;/em&gt; соответствует любому значению. Он используется для игнорирования значений, когда они не имеют значения. Внутри других шаблонов он соответствует одному полю данных (в отличие от &lt;code&gt;..&lt;/code&gt; , который соответствует остальным полям). В отличие от шаблонов идентификаторов, он не копирует, не перемещает и не заимствует соответствующее значение.</target>
        </trans-unit>
        <trans-unit id="75f0595163c83b48141e476739787cd1006a8d33" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;channel&lt;/strong&gt;'s sending half has become disconnected, and there will never be any more data received on it.</source>
          <target state="translated">&lt;strong&gt;Канал&lt;/strong&gt; &amp;laquo;ы отправки половина отсоединены, и никогда не будет каких - либо дополнительных данных , полученных от него.</target>
        </trans-unit>
        <trans-unit id="7d020769b0b6d90680db8e09c6dc6e9b663dc909" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;compiler&lt;/strong&gt; reordering instructions: If the compiler can issue an instruction at an earlier point, it will try to do so. For example, it might hoist memory loads at the top of a code block, so that the CPU can start &lt;a href=&quot;https://en.wikipedia.org/wiki/Cache_prefetching&quot;&gt;prefetching&lt;/a&gt; the values from memory.</source>
          <target state="translated">&lt;strong&gt;Компилятор&lt;/strong&gt; переназначения инструкции: Если компилятор может выдать команду на более раннем этапе, он будет пытаться сделать это. Например, он может увеличить загрузку памяти в верхней части блока кода, чтобы ЦП мог начать &lt;a href=&quot;https://en.wikipedia.org/wiki/Cache_prefetching&quot;&gt;предварительную выборку&lt;/a&gt; значений из памяти.</target>
        </trans-unit>
        <trans-unit id="314b68cd7b660a21edb44d2117cd4a156ae245a5" translate="yes" xml:space="preserve">
          <source>The API documentation that &lt;code&gt;cargo doc&lt;/code&gt; generates for this crate will now list and link re-exports on the front page, as shown in Figure 14-4, making the &lt;code&gt;PrimaryColor&lt;/code&gt; and &lt;code&gt;SecondaryColor&lt;/code&gt; types and the &lt;code&gt;mix&lt;/code&gt; function easier to find.</source>
          <target state="translated">Документация API, которую создает документ &lt;code&gt;cargo doc&lt;/code&gt; для этого ящика, теперь будет содержать список реэкспортов и ссылки на них на главной странице, как показано на рис. 14-4, что &lt;code&gt;PrimaryColor&lt;/code&gt; типов PrimaryColor и &lt;code&gt;SecondaryColor&lt;/code&gt; и функции &lt;code&gt;mix&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="fe97d53a4341ff985473c7759453c7f0b6f51809" translate="yes" xml:space="preserve">
          <source>The API is typically used by acquiring a handle to the current thread, placing that handle in a shared data structure so that other threads can find it, and then &lt;code&gt;park&lt;/code&gt;ing in a loop. When some desired condition is met, another thread calls &lt;a href=&quot;struct.thread#method.unpark&quot;&gt;&lt;code&gt;unpark&lt;/code&gt;&lt;/a&gt; on the handle.</source>
          <target state="translated">API обычно используется путем получения дескриптора текущего потока, помещения этого дескриптора в общую структуру данных, чтобы другие потоки могли его найти, а затем &lt;code&gt;park&lt;/code&gt; в цикле. Когда некоторые желаемое условие выполняется, другой поток вызовов &lt;a href=&quot;struct.thread#method.unpark&quot;&gt; &lt;code&gt;unpark&lt;/code&gt; &lt;/a&gt; на ручке.</target>
        </trans-unit>
        <trans-unit id="bdef16eb0aad1c8443510daaf0eaf64f22da449f" translate="yes" xml:space="preserve">
          <source>The API of &lt;code id=&quot;the-api-of-mutext&quot;&gt;Mutex&amp;lt;T&amp;gt;&lt;/code&gt;</source>
          <target state="translated">API &lt;code id=&quot;the-api-of-mutext&quot;&gt;Mutex&amp;lt;T&amp;gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="da2fca5419425bb1dfeff3a19e5e6b522b71b9f7" translate="yes" xml:space="preserve">
          <source>The Anatomy of a Test Function</source>
          <target state="translated">Анатомия тестовой функции</target>
        </trans-unit>
        <trans-unit id="6ff9dd46af7ebe72f506f56aea2ffd15b7f82cfe" translate="yes" xml:space="preserve">
          <source>The Array Type</source>
          <target state="translated">Тип массива</target>
        </trans-unit>
        <trans-unit id="4c7fdb8a442bced7fcc6b743d86e4b178b1bc140" translate="yes" xml:space="preserve">
          <source>The Boolean Type</source>
          <target state="translated">Булевский тип</target>
        </trans-unit>
        <trans-unit id="7a47e0b8b6b1bfa40f74993b9ed02984c335782d" translate="yes" xml:space="preserve">
          <source>The Boolean type, &lt;code&gt;bool&lt;/code&gt;, with values &lt;code&gt;true&lt;/code&gt; and &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">Тип Boolean, &lt;code&gt;bool&lt;/code&gt; , со значениями &lt;code&gt;true&lt;/code&gt; и &lt;code&gt;false&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d554fe4c508301c7dd79586706f031038650a679" translate="yes" xml:space="preserve">
          <source>The Borrow Checker</source>
          <target state="translated">Проверка по кредиту</target>
        </trans-unit>
        <trans-unit id="706bc5bdd045092d3c34365727a87c607d4ff3a3" translate="yes" xml:space="preserve">
          <source>The C side must &lt;strong&gt;not&lt;/strong&gt; modify the length of the string (by writing a &lt;code&gt;NULL&lt;/code&gt; somewhere inside the string or removing the final one) before it makes it back into Rust using &lt;a href=&quot;struct.cstring#method.from_raw&quot;&gt;&lt;code&gt;CString::from_raw&lt;/code&gt;&lt;/a&gt;. See the safety section in &lt;a href=&quot;struct.cstring#method.from_raw&quot;&gt;&lt;code&gt;CString::from_raw&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="096fc2c3eb95fb5d0ee6aa092c0689c069929e6f" translate="yes" xml:space="preserve">
          <source>The C-main function only supports to return integers as return type. So, every type implementing the &lt;code&gt;Termination&lt;/code&gt; trait has to be converted to an integer.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="da6976366f57ccb20ad430117c89098f7fb1348a" translate="yes" xml:space="preserve">
          <source>The C-variadic type &lt;code&gt;...&lt;/code&gt; has been nested inside another type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="86641abf85c69d8c4f7c9c71c79144e3a2832005" translate="yes" xml:space="preserve">
          <source>The Character Type</source>
          <target state="translated">Тип персонажа</target>
        </trans-unit>
        <trans-unit id="35e39875eebfabcb5b0b8cd30288767fc0b6add8" translate="yes" xml:space="preserve">
          <source>The Clippy tool is a collection of lints to analyze your code so you can catch common mistakes and improve your Rust code.</source>
          <target state="translated">Инструмент Clippy представляет собой набор линков для анализа вашего кода,чтобы вы могли поймать распространенные ошибки и улучшить свой Rust код.</target>
        </trans-unit>
        <trans-unit id="bb08bad287d0caba2752b58d322b62f2942d38e6" translate="yes" xml:space="preserve">
          <source>The Default Representation</source>
          <target state="translated">Представительство по умолчанию</target>
        </trans-unit>
        <trans-unit id="f9e1a59444e395f067802b105261ac31a11eac66" translate="yes" xml:space="preserve">
          <source>The Difference Between Macros and Functions</source>
          <target state="translated">Разница между макросами и функциями...</target>
        </trans-unit>
        <trans-unit id="47f6987535ee435e225cb875fe024ba6f3b75e49" translate="yes" xml:space="preserve">
          <source>The Glob Operator</source>
          <target state="translated">Глобус-оператор</target>
        </trans-unit>
        <trans-unit id="a0a1aaf98c3bce57246183f1baadfe83da9b49cd" translate="yes" xml:space="preserve">
          <source>The HTML format is available online at &lt;a href=&quot;https://doc.rust-lang.org/stable/book/index.html&quot;&gt;https://doc.rust-lang.org/stable/book/&lt;/a&gt; and offline with installations of Rust made with &lt;code&gt;rustup&lt;/code&gt;; run &lt;code&gt;rustup docs --book&lt;/code&gt; to open.</source>
          <target state="translated">Формат HTML доступен онлайн по адресу &lt;a href=&quot;https://doc.rust-lang.org/stable/book/index.html&quot;&gt;https://doc.rust-lang.org/stable/book/&lt;/a&gt; и офлайн с установками Rust, сделанными с помощью &lt;code&gt;rustup&lt;/code&gt; ; запустите &lt;code&gt;rustup docs --book&lt;/code&gt; , чтобы открыть.</target>
        </trans-unit>
        <trans-unit id="00df77514c97d921fca4a972435309219a163a06" translate="yes" xml:space="preserve">
          <source>The I/O Prelude</source>
          <target state="translated">Прелюдия к вводу/выводу</target>
        </trans-unit>
        <trans-unit id="6979c051972c7d2da3658847fabbf6a31d84bdb5" translate="yes" xml:space="preserve">
          <source>The I/O operation's timeout expired, causing it to be canceled.</source>
          <target state="translated">Тайм-аут операции ввода-вывода истек,что привело к ее отмене.</target>
        </trans-unit>
        <trans-unit id="dc9c14a7eb4854c512e7ed69d5ba6a43f9c253aa" translate="yes" xml:space="preserve">
          <source>The IEEE 754-2008 &quot;binary32&quot; and &quot;binary64&quot; floating-point types are &lt;code&gt;f32&lt;/code&gt; and &lt;code&gt;f64&lt;/code&gt;, respectively.</source>
          <target state="translated">IEEE 754-2008 &amp;laquo;binary32&amp;raquo; и &amp;laquo;binary64&amp;raquo; типа с плавающей точкой &lt;code&gt;f32&lt;/code&gt; и &lt;code&gt;f64&lt;/code&gt; соответственно.</target>
        </trans-unit>
        <trans-unit id="a46bc695392f8c742f4e678a79ed2375790074cb" translate="yes" xml:space="preserve">
          <source>The Matcher Invariants</source>
          <target state="translated">Инварианты Мэтчера</target>
        </trans-unit>
        <trans-unit id="5eece4981b24083c68ecabd071b66fe17ba1ce62" translate="yes" xml:space="preserve">
          <source>The Never Type that Never Returns</source>
          <target state="translated">Тип &quot;Никогда&quot;,который никогда не возвращается</target>
        </trans-unit>
        <trans-unit id="41b8e7692f976fe91f0cb8053dcf33a7090a4f8c" translate="yes" xml:space="preserve">
          <source>The Pattern API provides a generic mechanism for using different pattern types when searching through a string.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ba8021c95f458659340856b34b5ce555bddda300" translate="yes" xml:space="preserve">
          <source>The RFC Process and Teams</source>
          <target state="translated">Процесс и команды КСФ</target>
        </trans-unit>
        <trans-unit id="667bd8e20b1ba8153f27c9ff6c220024562a73c6" translate="yes" xml:space="preserve">
          <source>The Rules of References</source>
          <target state="translated">Правила использования ссылок</target>
        </trans-unit>
        <trans-unit id="161ef3f14aee5229baf3e48cdbbdab5a784349b3" translate="yes" xml:space="preserve">
          <source>The Rust Language Server powers Integrated Development Environment (IDE) integration for code completion and inline error messages.</source>
          <target state="translated">Сервер Rust Language Server поддерживает интеграцию с интегрированной средой разработки (IDE)для завершения кода и сообщений об ошибках.</target>
        </trans-unit>
        <trans-unit id="efbadde43b4ea2876af269fef5bbeff660435dad" translate="yes" xml:space="preserve">
          <source>The Rust Prelude</source>
          <target state="translated">Прелюдия Ржавчины</target>
        </trans-unit>
        <trans-unit id="1e47c327d13b68cc315d8c0718500294854d4bd4" translate="yes" xml:space="preserve">
          <source>The Rust Prelude.</source>
          <target state="translated">Прелюдия Ржавчины.</target>
        </trans-unit>
        <trans-unit id="64d4853b323b63d9ca56f4771bf913212d9ace7a" translate="yes" xml:space="preserve">
          <source>The Rust Programming Language</source>
          <target state="translated">Язык программирования ржавчины</target>
        </trans-unit>
        <trans-unit id="0bb645ae646711df91105c5e5d03daf9c88ee91b" translate="yes" xml:space="preserve">
          <source>The Rust Standard Library</source>
          <target state="translated">Стандартная библиотека &quot;Ржавчина</target>
        </trans-unit>
        <trans-unit id="9c789ddc154274d796ddc2e963326017f63c2958" translate="yes" xml:space="preserve">
          <source>The Rust Standard Library is the foundation of portable Rust software, a set of minimal and battle-tested shared abstractions for the &lt;a href=&quot;https://crates.io&quot;&gt;broader Rust ecosystem&lt;/a&gt;. It offers core types, like &lt;a href=&quot;vec/index&quot;&gt;&lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;option/enum.option&quot;&gt;&lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt;, library-defined &lt;a href=&quot;#primitives&quot;&gt;operations on language primitives&lt;/a&gt;, &lt;a href=&quot;#macros&quot;&gt;standard macros&lt;/a&gt;, &lt;a href=&quot;io/index&quot;&gt;I/O&lt;/a&gt; and &lt;a href=&quot;thread/index&quot;&gt;multithreading&lt;/a&gt;, among &lt;a href=&quot;#what-is-in-the-standard-library-documentation&quot;&gt;many other things&lt;/a&gt;.</source>
          <target state="translated">Стандартная библиотека Rust - это основа портативного программного обеспечения Rust, набора минимальных и проверенных в боях общих абстракций для &lt;a href=&quot;https://crates.io&quot;&gt;более широкой экосистемы Rust&lt;/a&gt; . Он предлагает основные типы, такие как &lt;a href=&quot;vec/index&quot;&gt; &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; &lt;/a&gt; и &lt;a href=&quot;option/enum.option&quot;&gt; &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt; &lt;/a&gt; , определяемые библиотекой &lt;a href=&quot;#primitives&quot;&gt;операции с языковыми примитивами&lt;/a&gt; , &lt;a href=&quot;#macros&quot;&gt;стандартные макросы&lt;/a&gt; , &lt;a href=&quot;io/index&quot;&gt;ввод-вывод&lt;/a&gt; и &lt;a href=&quot;thread/index&quot;&gt;многопоточность&lt;/a&gt; , а также &lt;a href=&quot;#what-is-in-the-standard-library-documentation&quot;&gt;многое другое&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="4d3f2d23ee5d88e5e35ea9e8e79bcbc0fd6e3b11" translate="yes" xml:space="preserve">
          <source>The Rust Standard Library is the foundation of portable Rust software, a set of minimal and battle-tested shared abstractions for the &lt;a href=&quot;https://crates.io&quot;&gt;broader Rust ecosystem&lt;/a&gt;. It offers core types, like &lt;a href=&quot;vec/struct.vec&quot;&gt;&lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;option/enum.option&quot;&gt;&lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt;, library-defined &lt;a href=&quot;#primitives&quot;&gt;operations on language primitives&lt;/a&gt;, &lt;a href=&quot;#macros&quot;&gt;standard macros&lt;/a&gt;, &lt;a href=&quot;io/index&quot;&gt;I/O&lt;/a&gt; and &lt;a href=&quot;thread/index&quot;&gt;multithreading&lt;/a&gt;, among &lt;a href=&quot;#what-is-in-the-standard-library-documentation&quot;&gt;many other things&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5c3853d774e4956749b7c91653db336f2eec58d4" translate="yes" xml:space="preserve">
          <source>The Rust compiler does not consider the following behaviors &lt;em&gt;unsafe&lt;/em&gt;, though a programmer may (should) find them undesirable, unexpected, or erroneous.</source>
          <target state="translated">Компилятор Rust не считает следующее поведение &lt;em&gt;небезопасным&lt;/em&gt; , хотя программист может (должен) счесть их нежелательными, неожиданными или ошибочными.</target>
        </trans-unit>
        <trans-unit id="21b3dd0203ec587beb1963c1f4feb0c5c3e73b91" translate="yes" xml:space="preserve">
          <source>The Rust compiler has a &lt;em&gt;borrow checker&lt;/em&gt; that compares scopes to determine whether all borrows are valid. Listing 10-18 shows the same code as Listing 10-17 but with annotations showing the lifetimes of the variables.</source>
          <target state="translated">В компиляторе Rust есть средство &lt;em&gt;проверки заимствований,&lt;/em&gt; которое сравнивает объемы, чтобы определить, все ли заимствования действительны. В листинге 10-18 показан тот же код, что и в листинге 10-17, но с аннотациями, показывающими время жизни переменных.</target>
        </trans-unit>
        <trans-unit id="bac79421ac7e7f4a69670a43a87279fa1ea360c9" translate="yes" xml:space="preserve">
          <source>The Rust compiler is always invoked with a single source file as input, and always produces a single output crate. The processing of that source file may result in other source files being loaded as modules. Source files have the extension &lt;code&gt;.rs&lt;/code&gt;.</source>
          <target state="translated">Компилятор Rust всегда вызывается с одним исходным файлом в качестве ввода и всегда производит один выходной ящик. Обработка этого исходного файла может привести к загрузке других исходных файлов как модулей. Исходные файлы имеют расширение &lt;code&gt;.rs&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="edecdb50208b6b73bf12c25a96c41ebd3a559a66" translate="yes" xml:space="preserve">
          <source>The Rust language and compiler have a six-week release cycle, meaning users get a constant stream of new features. Other programming languages release larger changes less often; Rust releases smaller updates more frequently. After a while, all of these tiny changes add up. But from release to release, it can be difficult to look back and say, &amp;ldquo;Wow, between Rust 1.10 and Rust 1.31, Rust has changed a lot!&amp;rdquo;</source>
          <target state="translated">У языка и компилятора Rust шестинедельный цикл выпуска, что означает, что пользователи получают постоянный поток новых функций. Другие языки программирования реже выпускают более крупные изменения; Rust чаще выпускает небольшие обновления. Через некоторое время все эти крошечные изменения складываются. Но от выпуска к выпуску бывает трудно оглянуться назад и сказать: &amp;laquo;Ух ты, между Rust 1.10 и Rust 1.31 Rust сильно изменился!&amp;raquo;</target>
        </trans-unit>
        <trans-unit id="bb670b9e802863986c803bc2c279a2c3ad127d26" translate="yes" xml:space="preserve">
          <source>The Rust language has a set of &lt;em&gt;keywords&lt;/em&gt; that are reserved for use by the language only, much as in other languages. Keep in mind that you cannot use these words as names of variables or functions. Most of the keywords have special meanings, and you&amp;rsquo;ll be using them to do various tasks in your Rust programs; a few have no current functionality associated with them but have been reserved for functionality that might be added to Rust in the future. You can find a list of the keywords in &lt;a href=&quot;appendix-01-keywords&quot;&gt;Appendix A&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4db8a730c896d57ac8ae13218ced391891bc4c9e" translate="yes" xml:space="preserve">
          <source>The Rust language has a set of &lt;em&gt;keywords&lt;/em&gt; that are reserved for use by the language only, much as in other languages. Keep in mind that you cannot use these words as names of variables or functions. Most of the keywords have special meanings, and you&amp;rsquo;ll be using them to do various tasks in your Rust programs; a few have no current functionality associated with them but have been reserved for functionality that might be added to Rust in the future. You can find a list of the keywords in Appendix A.</source>
          <target state="translated">В языке Rust есть набор &lt;em&gt;ключевых слов&lt;/em&gt; , которые зарезервированы только для использования в этом языке, как и в других языках. Имейте в виду, что вы не можете использовать эти слова в качестве имен переменных или функций. Большинство ключевых слов имеют особое значение, и вы будете использовать их для выполнения различных задач в своих программах на Rust; некоторые из них не имеют связанных с ними текущих функций, но они зарезервированы для функций, которые могут быть добавлены в Rust в будущем. Вы можете найти список ключевых слов в Приложении A.</target>
        </trans-unit>
        <trans-unit id="5c421a36adf32e1316c136776ce05dd83536c6c8" translate="yes" xml:space="preserve">
          <source>The Rust language hopes to support many other users as well; those mentioned here are merely some of the biggest stakeholders. Overall, Rust&amp;rsquo;s greatest ambition is to eliminate the trade-offs that programmers have accepted for decades by providing safety &lt;em&gt;and&lt;/em&gt; productivity, speed &lt;em&gt;and&lt;/em&gt; ergonomics. Give Rust a try and see if its choices work for you.</source>
          <target state="translated">Язык Rust надеется поддержать и многих других пользователей; упомянутые здесь - лишь некоторые из крупнейших заинтересованных сторон. В целом, самая большая цель Rust - устранить компромиссы, на которые программисты шли десятилетиями, путем обеспечения безопасности &lt;em&gt;и&lt;/em&gt; производительности, скорости &lt;em&gt;и&lt;/em&gt; эргономики. Попробуйте Rust и посмотрите, работают ли его варианты для вас.</target>
        </trans-unit>
        <trans-unit id="596e2b7dbc791cd3cfc77236ae00a927665967e2" translate="yes" xml:space="preserve">
          <source>The Rust runtime</source>
          <target state="translated">Ржавчина</target>
        </trans-unit>
        <trans-unit id="6be65bd73ad861e62f3888e1cc3672c017c1636b" translate="yes" xml:space="preserve">
          <source>The Rust standard library provides channels for message passing and smart pointer types, such as &lt;code&gt;Mutex&amp;lt;T&amp;gt;&lt;/code&gt; and &lt;code&gt;Arc&amp;lt;T&amp;gt;&lt;/code&gt;, that are safe to use in concurrent contexts. The type system and the borrow checker ensure that the code using these solutions won&amp;rsquo;t end up with data races or invalid references. Once you get your code to compile, you can rest assured that it will happily run on multiple threads without the kinds of hard-to-track-down bugs common in other languages. Concurrent programming is no longer a concept to be afraid of: go forth and make your programs concurrent, fearlessly!</source>
          <target state="translated">Стандартная библиотека Rust предоставляет каналы для передачи сообщений и типы интеллектуальных указателей, такие как &lt;code&gt;Mutex&amp;lt;T&amp;gt;&lt;/code&gt; и &lt;code&gt;Arc&amp;lt;T&amp;gt;&lt;/code&gt; , которые можно безопасно использовать в параллельных контекстах. Система типов и средство проверки заимствований гарантируют, что код, использующий эти решения, не закончится гонкой данных или недопустимыми ссылками. После того, как вы скомпилируете свой код, вы можете быть уверены, что он будет успешно работать в нескольких потоках без сложных для отслеживания ошибок, характерных для других языков. Параллельное программирование больше не является концепцией, которой следует бояться: продолжайте и бесстрашно создавайте параллельные программы!</target>
        </trans-unit>
        <trans-unit id="ca0e948d58962dbdfe194b991ab15a2f509a074c" translate="yes" xml:space="preserve">
          <source>The Rust type system has some features that we&amp;rsquo;ve mentioned in this book but haven&amp;rsquo;t yet discussed. We&amp;rsquo;ll start by discussing newtypes in general as we examine why newtypes are useful as types. Then we&amp;rsquo;ll move on to type aliases, a feature similar to newtypes but with slightly different semantics. We&amp;rsquo;ll also discuss the &lt;code&gt;!&lt;/code&gt; type and dynamically sized types.</source>
          <target state="translated">Система типов Rust имеет некоторые особенности, которые мы упоминали в этой книге, но еще не обсуждали. Мы начнем с обсуждения новых типов в целом, поскольку мы исследуем, почему новые типы полезны как типы. Затем мы перейдем к псевдонимам типов - функции, аналогичной новым типам, но с немного другой семантикой. Мы также обсудим &lt;code&gt;!&lt;/code&gt; тип и типы с динамическим размером.</target>
        </trans-unit>
        <trans-unit id="1e24d83679bf4a662ce93151d4c79beb7bc3d976" translate="yes" xml:space="preserve">
          <source>The Slice Type</source>
          <target state="translated">Тип среза</target>
        </trans-unit>
        <trans-unit id="b60a9b411326be4b7b78e74a3c2736078d2cb936" translate="yes" xml:space="preserve">
          <source>The Stack and the Heap</source>
          <target state="translated">Штабель и куча</target>
        </trans-unit>
        <trans-unit id="ea9187c27f13ce2d0fda228c7804b1eacb2a7df4" translate="yes" xml:space="preserve">
          <source>The Static Lifetime</source>
          <target state="translated">Статическое время жизни</target>
        </trans-unit>
        <trans-unit id="dcc1bdcf64d9ba08b8c546b48a03373f9d896f1a" translate="yes" xml:space="preserve">
          <source>The Tests Module and &lt;code id=&quot;the-tests-module-and-cfgtest&quot;&gt;#[cfg(test)]&lt;/code&gt;</source>
          <target state="translated">Модуль &quot;Тесты&quot; и &lt;code id=&quot;the-tests-module-and-cfgtest&quot;&gt;#[cfg(test)]&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="43d375d205a43568d44e006351aba054a3a6df0e" translate="yes" xml:space="preserve">
          <source>The Trade-Offs of Using &lt;code id=&quot;the-trade-offs-of-using-clone&quot;&gt;clone&lt;/code&gt;</source>
          <target state="translated">Компромиссы использования &lt;code id=&quot;the-trade-offs-of-using-clone&quot;&gt;clone&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="874f680f597dff734725c0edb8d1cdbdc1c687fb" translate="yes" xml:space="preserve">
          <source>The Transmission Control Protocol is specified in &lt;a href=&quot;https://tools.ietf.org/html/rfc793&quot;&gt;IETF RFC 793&lt;/a&gt;.</source>
          <target state="translated">Протокол управления передачей указан в &lt;a href=&quot;https://tools.ietf.org/html/rfc793&quot;&gt;IETF RFC 793&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="6d2bc0207cf3386e89a8ff90f2a45c74d008dd6b" translate="yes" xml:space="preserve">
          <source>The Tuple Type</source>
          <target state="translated">Тип кортежа</target>
        </trans-unit>
        <trans-unit id="720acae72ae852d88680bc6199aaf2a3185402bd" translate="yes" xml:space="preserve">
          <source>The Unsize trait should not be implemented directly. All implementations of Unsize are provided automatically by the compiler.</source>
          <target state="translated">Непосредственная реализация характеристики &quot;Unsize&quot; не должна быть осуществлена.Все реализации Unsize предоставляются компилятором автоматически.</target>
        </trans-unit>
        <trans-unit id="9d8c2343fd3b49fd50014f949ed7698cf46aba4f" translate="yes" xml:space="preserve">
          <source>The ability to return a type that is only specified by the trait it implements is especially useful in the context of closures and iterators, which we cover in Chapter 13. Closures and iterators create types that only the compiler knows or types that are very long to specify. The &lt;code&gt;impl Trait&lt;/code&gt; syntax lets you concisely specify that a function returns some type that implements the &lt;code&gt;Iterator&lt;/code&gt; trait without needing to write out a very long type.</source>
          <target state="translated">Возможность возвращать тип, который определяется только реализуемым им признаком, особенно полезен в контексте замыканий и итераторов, которые мы рассмотрим в главе 13. Замыкания и итераторы создают типы, которые знает только компилятор, или типы, которые очень длинные. уточнить. &lt;code&gt;impl Trait&lt;/code&gt; синтаксис позволяет лаконично определить , что функция возвращает некоторый тип , который реализует &lt;code&gt;Iterator&lt;/code&gt; Trait без необходимости выписывать очень длинный тип.</target>
        </trans-unit>
        <trans-unit id="8344955111fdc074c9729e11010ee2eab0af03c1" translate="yes" xml:space="preserve">
          <source>The above example can be resolved by either reducing the number of lifetime bounds to one or by making the trait object lifetime explicit, like so:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cde40ac9fea8ec2f55d9ca0d422fc89008496087" translate="yes" xml:space="preserve">
          <source>The above indirection is the additional runtime cost of calling a function on a &lt;code&gt;dyn Trait&lt;/code&gt;. Methods called by dynamic dispatch generally cannot be inlined by the compiler.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="deb20b7d624d1708cb7603af7f7d5931910cd966" translate="yes" xml:space="preserve">
          <source>The above is &lt;em&gt;still&lt;/em&gt; an expression but it will always evaluate to &lt;code&gt;()&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ede9c72b891dfc1d92b0b9fffc4f21007f9ae902" translate="yes" xml:space="preserve">
          <source>The absolute value of &lt;code&gt;i128::MIN&lt;/code&gt; cannot be represented as an &lt;code&gt;i128&lt;/code&gt;, and attempting to calculate it will cause an overflow. This means that code in debug mode will trigger a panic on this case and optimized code will return &lt;code&gt;i128::MIN&lt;/code&gt; without a panic.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e4ff7b2880604f74445f905b71fdee96836fc628" translate="yes" xml:space="preserve">
          <source>The absolute value of &lt;code&gt;i128::min_value()&lt;/code&gt; cannot be represented as an &lt;code&gt;i128&lt;/code&gt;, and attempting to calculate it will cause an overflow. This means that code in debug mode will trigger a panic on this case and optimized code will return &lt;code&gt;i128::min_value()&lt;/code&gt; without a panic.</source>
          <target state="translated">Абсолютное значение &lt;code&gt;i128::min_value()&lt;/code&gt; не может быть представлено как &lt;code&gt;i128&lt;/code&gt; , и попытка его вычисления вызовет переполнение. Это означает, что код в режиме отладки вызовет панику в этом случае, а оптимизированный код вернет &lt;code&gt;i128::min_value()&lt;/code&gt; без паники.</target>
        </trans-unit>
        <trans-unit id="68e6f1c95dcf27a099d3d4e155f55896bf8faf93" translate="yes" xml:space="preserve">
          <source>The absolute value of &lt;code&gt;i16::MIN&lt;/code&gt; cannot be represented as an &lt;code&gt;i16&lt;/code&gt;, and attempting to calculate it will cause an overflow. This means that code in debug mode will trigger a panic on this case and optimized code will return &lt;code&gt;i16::MIN&lt;/code&gt; without a panic.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c6634b50eb0aa3afe906f4e13b4800cc26454c92" translate="yes" xml:space="preserve">
          <source>The absolute value of &lt;code&gt;i16::min_value()&lt;/code&gt; cannot be represented as an &lt;code&gt;i16&lt;/code&gt;, and attempting to calculate it will cause an overflow. This means that code in debug mode will trigger a panic on this case and optimized code will return &lt;code&gt;i16::min_value()&lt;/code&gt; without a panic.</source>
          <target state="translated">Абсолютное значение &lt;code&gt;i16::min_value()&lt;/code&gt; не может быть представлено как &lt;code&gt;i16&lt;/code&gt; , и попытка его вычисления вызовет переполнение. Это означает, что код в режиме отладки вызовет панику в этом случае, а оптимизированный код вернет &lt;code&gt;i16::min_value()&lt;/code&gt; без паники.</target>
        </trans-unit>
        <trans-unit id="37e2f0833c2e3fce2e0d86c6e578d1435f9c3b8f" translate="yes" xml:space="preserve">
          <source>The absolute value of &lt;code&gt;i32::MIN&lt;/code&gt; cannot be represented as an &lt;code&gt;i32&lt;/code&gt;, and attempting to calculate it will cause an overflow. This means that code in debug mode will trigger a panic on this case and optimized code will return &lt;code&gt;i32::MIN&lt;/code&gt; without a panic.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="91a991a9b7dce7a35eefa5dff81ee4a280a7e4f1" translate="yes" xml:space="preserve">
          <source>The absolute value of &lt;code&gt;i32::min_value()&lt;/code&gt; cannot be represented as an &lt;code&gt;i32&lt;/code&gt;, and attempting to calculate it will cause an overflow. This means that code in debug mode will trigger a panic on this case and optimized code will return &lt;code&gt;i32::min_value()&lt;/code&gt; without a panic.</source>
          <target state="translated">Абсолютное значение &lt;code&gt;i32::min_value()&lt;/code&gt; не может быть представлено как &lt;code&gt;i32&lt;/code&gt; , и попытка его вычисления вызовет переполнение. Это означает, что код в режиме отладки вызовет панику в этом случае, а оптимизированный код вернет &lt;code&gt;i32::min_value()&lt;/code&gt; без паники.</target>
        </trans-unit>
        <trans-unit id="2ddae722d1b9330d37bd61655516374aae130695" translate="yes" xml:space="preserve">
          <source>The absolute value of &lt;code&gt;i64::MIN&lt;/code&gt; cannot be represented as an &lt;code&gt;i64&lt;/code&gt;, and attempting to calculate it will cause an overflow. This means that code in debug mode will trigger a panic on this case and optimized code will return &lt;code&gt;i64::MIN&lt;/code&gt; without a panic.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4c50c4d71fa72eabc1e0818c0a858ae1903c1c3c" translate="yes" xml:space="preserve">
          <source>The absolute value of &lt;code&gt;i64::min_value()&lt;/code&gt; cannot be represented as an &lt;code&gt;i64&lt;/code&gt;, and attempting to calculate it will cause an overflow. This means that code in debug mode will trigger a panic on this case and optimized code will return &lt;code&gt;i64::min_value()&lt;/code&gt; without a panic.</source>
          <target state="translated">Абсолютное значение &lt;code&gt;i64::min_value()&lt;/code&gt; не может быть представлено как &lt;code&gt;i64&lt;/code&gt; , и попытка его вычисления вызовет переполнение. Это означает, что код в режиме отладки вызовет панику в этом случае, а оптимизированный код вернет &lt;code&gt;i64::min_value()&lt;/code&gt; без паники.</target>
        </trans-unit>
        <trans-unit id="94540f2ba32a8d4e2123f1b683b0ff15f6511fa8" translate="yes" xml:space="preserve">
          <source>The absolute value of &lt;code&gt;i8::MIN&lt;/code&gt; cannot be represented as an &lt;code&gt;i8&lt;/code&gt;, and attempting to calculate it will cause an overflow. This means that code in debug mode will trigger a panic on this case and optimized code will return &lt;code&gt;i8::MIN&lt;/code&gt; without a panic.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5adbbbaac9cedf98e39759b8920bdb3431d04107" translate="yes" xml:space="preserve">
          <source>The absolute value of &lt;code&gt;i8::min_value()&lt;/code&gt; cannot be represented as an &lt;code&gt;i8&lt;/code&gt;, and attempting to calculate it will cause an overflow. This means that code in debug mode will trigger a panic on this case and optimized code will return &lt;code&gt;i8::min_value()&lt;/code&gt; without a panic.</source>
          <target state="translated">Абсолютное значение &lt;code&gt;i8::min_value()&lt;/code&gt; не может быть представлено как &lt;code&gt;i8&lt;/code&gt; , и попытка его вычислить вызовет переполнение. Это означает, что код в режиме отладки вызовет панику в этом случае, а оптимизированный код вернет &lt;code&gt;i8::min_value()&lt;/code&gt; без паники.</target>
        </trans-unit>
        <trans-unit id="f3616827787c274826d0feb8bc695ca0f90e8398" translate="yes" xml:space="preserve">
          <source>The absolute value of &lt;code&gt;isize::MIN&lt;/code&gt; cannot be represented as an &lt;code&gt;isize&lt;/code&gt;, and attempting to calculate it will cause an overflow. This means that code in debug mode will trigger a panic on this case and optimized code will return &lt;code&gt;isize::MIN&lt;/code&gt; without a panic.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5fa62dd0a50bd4c5554cb57272ae5164c2e1f601" translate="yes" xml:space="preserve">
          <source>The absolute value of &lt;code&gt;isize::min_value()&lt;/code&gt; cannot be represented as an &lt;code&gt;isize&lt;/code&gt;, and attempting to calculate it will cause an overflow. This means that code in debug mode will trigger a panic on this case and optimized code will return &lt;code&gt;isize::min_value()&lt;/code&gt; without a panic.</source>
          <target state="translated">Абсолютное значение &lt;code&gt;isize::min_value()&lt;/code&gt; не может быть представлено как &lt;code&gt;isize&lt;/code&gt; , и попытка его вычисления вызовет переполнение. Это означает, что код в режиме отладки вызовет панику в этом случае, а оптимизированный код вернет &lt;code&gt;isize::min_value()&lt;/code&gt; без паники.</target>
        </trans-unit>
        <trans-unit id="409fd764bcabc3595ffe004849ff8f4e30564756" translate="yes" xml:space="preserve">
          <source>The actual desugaring is more complex:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="88133b615f1381b0a02c487a3edbc253bc8ee09f" translate="yes" xml:space="preserve">
          <source>The actual stack size may be greater than this value if the platform specifies a minimal stack size.</source>
          <target state="translated">Реальный размер стека может быть больше этого значения,если платформа задает минимальный размер стека.</target>
        </trans-unit>
        <trans-unit id="e09eb4195a6425d3d0a7b968cb406d8968af9926" translate="yes" xml:space="preserve">
          <source>The addition assignment operator &lt;code&gt;+=&lt;/code&gt;.</source>
          <target state="translated">Оператор присваивания сложения &lt;code&gt;+=&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="097ca9dd7ade97007d85b522a25e6d04cefa5c67" translate="yes" xml:space="preserve">
          <source>The addition operator &lt;code&gt;+&lt;/code&gt;.</source>
          <target state="translated">Оператор сложения &lt;code&gt;+&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="161b60a028315218a44d6ebb4a0a56ea64addb73" translate="yes" xml:space="preserve">
          <source>The address of temporary value was taken.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="67b3b3b11425c46c946b0ed067dfaec63ac739cb" translate="yes" xml:space="preserve">
          <source>The address type can be any implementor of &lt;a href=&quot;trait.tosocketaddrs&quot;&gt;&lt;code&gt;ToSocketAddrs&lt;/code&gt;&lt;/a&gt; trait. See its documentation for concrete examples.</source>
          <target state="translated">Тип адреса может быть любым, реализующим признак &lt;a href=&quot;trait.tosocketaddrs&quot;&gt; &lt;code&gt;ToSocketAddrs&lt;/code&gt; &lt;/a&gt; . См. Его документацию для конкретных примеров.</target>
        </trans-unit>
        <trans-unit id="554a0871d5bd274c4e9a4646e480108243a7e12e" translate="yes" xml:space="preserve">
          <source>The advantage of checking the borrowing rules at runtime instead is that certain memory-safe scenarios are then allowed, whereas they are disallowed by the compile-time checks. Static analysis, like the Rust compiler, is inherently conservative. Some properties of code are impossible to detect by analyzing the code: the most famous example is the Halting Problem, which is beyond the scope of this book but is an interesting topic to research.</source>
          <target state="translated">Преимущество проверки правил заимствования во время выполнения заключается в том,что в этом случае разрешены определенные сценарии с сохранением памяти,в то время как при проверке во время компиляции они запрещаются.Статический анализ,как и компилятор Rust,по своей сути консервативен.Некоторые свойства кода невозможно обнаружить с помощью анализа кода:самым известным примером является Halting Problem,которая выходит за рамки данной книги,но является интересной темой для исследования.</target>
        </trans-unit>
        <trans-unit id="cf97cfec24f32bdc09751ee8bbb19e7117656381" translate="yes" xml:space="preserve">
          <source>The advantage of using trait objects and Rust&amp;rsquo;s type system to write code similar to code using duck typing is that we never have to check whether a value implements a particular method at runtime or worry about getting errors if a value doesn&amp;rsquo;t implement a method but we call it anyway. Rust won&amp;rsquo;t compile our code if the values don&amp;rsquo;t implement the traits that the trait objects need.</source>
          <target state="translated">Преимущество использования типажных объектов и системы типов Rust для написания кода, аналогичного коду, использующего утиную типизацию, заключается в том, что нам никогда не нужно проверять, реализует ли значение определенный метод во время выполнения, или беспокоиться о получении ошибок, если значение не реализует метод, но мы все равно называем это. Rust не будет компилировать наш код, если значения не реализуют черты, которые необходимы объектам черт.</target>
        </trans-unit>
        <trans-unit id="1f36aabbacdf9ecb5c08c91a08fabb8510a201b8" translate="yes" xml:space="preserve">
          <source>The advantages of checking the borrowing rules at compile time are that errors will be caught sooner in the development process, and there is no impact on runtime performance because all the analysis is completed beforehand. For those reasons, checking the borrowing rules at compile time is the best choice in the majority of cases, which is why this is Rust&amp;rsquo;s default.</source>
          <target state="translated">Преимущества проверки правил заимствования во время компиляции заключаются в том, что ошибки будут обнаружены раньше в процессе разработки, и это не повлияет на производительность во время выполнения, поскольку весь анализ завершается заранее. По этим причинам проверка правил заимствования во время компиляции является лучшим выбором в большинстве случаев, поэтому Rust используется по умолчанию.</target>
        </trans-unit>
        <trans-unit id="802cd88adc867c6ed95af7c7632a5b9312da114b" translate="yes" xml:space="preserve">
          <source>The alignment is specified as an integer parameter in the form of &lt;code&gt;#[repr(align(x))]&lt;/code&gt; or &lt;code&gt;#[repr(packed(x))]&lt;/code&gt;. The alignment value must be a power of two from 1 up to 2&lt;sup&gt;29&lt;/sup&gt;. For &lt;code&gt;packed&lt;/code&gt;, if no value is given, as in &lt;code&gt;#[repr(packed)]&lt;/code&gt;, then the value is 1.</source>
          <target state="translated">Выравнивание указывается как целочисленный параметр в форме &lt;code&gt;#[repr(align(x))]&lt;/code&gt; или &lt;code&gt;#[repr(packed(x))]&lt;/code&gt; . Значение выравнивания должно быть степенью двойки от 1 до 2 &lt;sup&gt;29&lt;/sup&gt; . Для &lt;code&gt;packed&lt;/code&gt; , если значение не задано, как в &lt;code&gt;#[repr(packed)]&lt;/code&gt; , тогда значение равно 1.</target>
        </trans-unit>
        <trans-unit id="4210b5f1c3a4d7626a8282b8b0091e3127367f26" translate="yes" xml:space="preserve">
          <source>The alignment may be raised or lowered with the &lt;code&gt;align&lt;/code&gt; and &lt;code&gt;packed&lt;/code&gt; modifiers respectively. They alter the representation specified in the attribute. If no representation is specified, the default one is altered.</source>
          <target state="translated">Выравнивания могут быть повышены или понижены с &lt;code&gt;align&lt;/code&gt; и &lt;code&gt;packed&lt;/code&gt; модификаторами соответственно. Они изменяют представление, указанное в атрибуте. Если представление не указано, изменяется значение по умолчанию.</target>
        </trans-unit>
        <trans-unit id="0bbd4814e74e1731ea096a3e29eb0e49a6112a9b" translate="yes" xml:space="preserve">
          <source>The alignment modifiers</source>
          <target state="translated">Модификаторы выравнивания</target>
        </trans-unit>
        <trans-unit id="9a801ec59d9d78b1342286bf3c47cdf72d8754c9" translate="yes" xml:space="preserve">
          <source>The alignment of a value specifies what addresses values are preferred to start at. Always a power of two. References to a value must be aligned. &lt;a href=&quot;type-layout#size-and-alignment&quot;&gt;More&lt;/a&gt;.</source>
          <target state="translated">Выравнивание значения указывает, с каких адресов предпочтительно начинать значения. Всегда степень двойки. Ссылки на значение должны быть выровнены. &lt;a href=&quot;type-layout#size-and-alignment&quot;&gt;Больше&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="d7d8131883a9466d9495401638572f0f7002cb80" translate="yes" xml:space="preserve">
          <source>The alignment of the struct is the alignment of the most-aligned field in it.</source>
          <target state="translated">Выравнивание структуры-это выравнивание наиболее выровненного в ней поля.</target>
        </trans-unit>
        <trans-unit id="cb2d786ce814f96269971824a7ca8c85b85a4a91" translate="yes" xml:space="preserve">
          <source>The allocated block of memory may or may not be initialized.</source>
          <target state="translated">Выделенный блок памяти может быть инициализирован или не инициализирован.</target>
        </trans-unit>
        <trans-unit id="a853460caf9660ad50bba38269de71834329efaf" translate="yes" xml:space="preserve">
          <source>The allocation error hook is a global resource.</source>
          <target state="translated">Крючок ошибки распределения является глобальным ресурсом.</target>
        </trans-unit>
        <trans-unit id="dd622480c0a0d020ad0c83e155629929c531f8bd" translate="yes" xml:space="preserve">
          <source>The allocation error hook is invoked when an infallible memory allocation fails, before the runtime aborts. The default hook prints a message to standard error, but this behavior can be customized with the &lt;a href=&quot;fn.set_alloc_error_hook&quot;&gt;&lt;code&gt;set_alloc_error_hook&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;fn.take_alloc_error_hook&quot;&gt;&lt;code&gt;take_alloc_error_hook&lt;/code&gt;&lt;/a&gt; functions.</source>
          <target state="translated">Ловушка ошибки распределения вызывается при сбое безошибочного выделения памяти перед прерыванием среды выполнения. Хук по умолчанию выводит сообщение об ошибке, но это поведение можно настроить с помощью &lt;a href=&quot;fn.set_alloc_error_hook&quot;&gt; &lt;code&gt;set_alloc_error_hook&lt;/code&gt; &lt;/a&gt; и &lt;a href=&quot;fn.take_alloc_error_hook&quot;&gt; &lt;code&gt;take_alloc_error_hook&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="460b0be997a504bd93f9a5f2102be17a4fe4f237" translate="yes" xml:space="preserve">
          <source>The alternate flag, &lt;code&gt;#&lt;/code&gt;, adds a &lt;code&gt;0b&lt;/code&gt; in front of the output.</source>
          <target state="translated">Альтернативный флаг &lt;code&gt;#&lt;/code&gt; добавляет &lt;code&gt;0b&lt;/code&gt; перед выводом.</target>
        </trans-unit>
        <trans-unit id="b053ed1e6052a16bbf0f4a89d40e16ee9bf6a88d" translate="yes" xml:space="preserve">
          <source>The alternate flag, &lt;code&gt;#&lt;/code&gt;, adds a &lt;code&gt;0o&lt;/code&gt; in front of the output.</source>
          <target state="translated">Альтернативный флаг &lt;code&gt;#&lt;/code&gt; добавляет &lt;code&gt;0o&lt;/code&gt; перед выводом.</target>
        </trans-unit>
        <trans-unit id="1a67677d2b4895bdc1fb6847161bf39c61cb99f4" translate="yes" xml:space="preserve">
          <source>The alternate flag, &lt;code&gt;#&lt;/code&gt;, adds a &lt;code&gt;0x&lt;/code&gt; in front of the output.</source>
          <target state="translated">Альтернативный флаг &lt;code&gt;#&lt;/code&gt; добавляет &lt;code&gt;0x&lt;/code&gt; перед выводом.</target>
        </trans-unit>
        <trans-unit id="11ba8acfe40883baf3a25418d4023d5eeae6eb43" translate="yes" xml:space="preserve">
          <source>The answer to this problem is the &lt;em&gt;Cargo.lock&lt;/em&gt; file, which was created the first time you ran &lt;code&gt;cargo build&lt;/code&gt; and is now in your &lt;em&gt;guessing_game&lt;/em&gt; directory. When you build a project for the first time, Cargo figures out all the versions of the dependencies that fit the criteria and then writes them to the &lt;em&gt;Cargo.lock&lt;/em&gt; file. When you build your project in the future, Cargo will see that the &lt;em&gt;Cargo.lock&lt;/em&gt; file exists and use the versions specified there rather than doing all the work of figuring out versions again. This lets you have a reproducible build automatically. In other words, your project will remain at &lt;code&gt;0.3.14&lt;/code&gt; until you explicitly upgrade, thanks to the &lt;em&gt;Cargo.lock&lt;/em&gt; file.</source>
          <target state="translated">Ответ на этот вопрос является &lt;em&gt;Cargo.lock&lt;/em&gt; файл, который был создан в первый раз , вы выбежали &lt;code&gt;cargo build&lt;/code&gt; и сейчас в вашем &lt;em&gt;guessing_game&lt;/em&gt; каталоге. Когда вы создаете проект впервые, Cargo определяет все версии зависимостей, которые соответствуют критериям, и затем записывает их в файл &lt;em&gt;Cargo.lock&lt;/em&gt; . Когда вы &lt;em&gt;создадите&lt;/em&gt; свой проект в будущем, Cargo увидит, что файл &lt;em&gt;Cargo.lock&lt;/em&gt; существует, и будет использовать указанные в нем версии, а не выполнять всю работу по определению версий снова. Это позволяет автоматически получать воспроизводимую сборку. Другими словами, ваш проект останется на уровне &lt;code&gt;0.3.14&lt;/code&gt; до тех пор, пока вы явно не обновите его, благодаря &lt;em&gt;Cargo.lock.&lt;/em&gt; файл.</target>
        </trans-unit>
        <trans-unit id="8fb95ccc8cbb2b44a80d4d0a731ecb5bea70e713" translate="yes" xml:space="preserve">
          <source>The answer to this problem is the &lt;em&gt;Cargo.lock&lt;/em&gt; file, which was created the first time you ran &lt;code&gt;cargo build&lt;/code&gt; and is now in your &lt;em&gt;guessing_game&lt;/em&gt; directory. When you build a project for the first time, Cargo figures out all the versions of the dependencies that fit the criteria and then writes them to the &lt;em&gt;Cargo.lock&lt;/em&gt; file. When you build your project in the future, Cargo will see that the &lt;em&gt;Cargo.lock&lt;/em&gt; file exists and use the versions specified there rather than doing all the work of figuring out versions again. This lets you have a reproducible build automatically. In other words, your project will remain at &lt;code&gt;0.5.5&lt;/code&gt; until you explicitly upgrade, thanks to the &lt;em&gt;Cargo.lock&lt;/em&gt; file.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c50839f5b75ebf2449202c65bd78e83e2a04633c" translate="yes" xml:space="preserve">
          <source>The argument order should be changed to match the parameter declaration order, as in the following:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ff3b9111423732cd0796ed3af4340d1aeaddff87" translate="yes" xml:space="preserve">
          <source>The argument to the &lt;code&gt;llvm_asm&lt;/code&gt; macro is not well-formed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0d5e37bb48121061d7a9d1253e50cf299206b8ed" translate="yes" xml:space="preserve">
          <source>The argument, &lt;code&gt;mid&lt;/code&gt;, should be a byte offset from the start of the string. It must also be on the boundary of a UTF-8 code point.</source>
          <target state="translated">Аргумент &lt;code&gt;mid&lt;/code&gt; должен быть байтовым смещением от начала строки. Он также должен находиться на границе кодовой точки UTF-8.</target>
        </trans-unit>
        <trans-unit id="843c167795952476fd4949d773d09e67f37bae5c" translate="yes" xml:space="preserve">
          <source>The arguments will be formatted according to the specified format string into the output stream provided.</source>
          <target state="translated">Аргументы будут отформатированы в соответствии с заданной строкой форматирования в предоставляемом выходном потоке.</target>
        </trans-unit>
        <trans-unit id="47d8ae2e6d2ad4b4b9256e9f4136431f5f0ee17f" translate="yes" xml:space="preserve">
          <source>The array index expression can be implemented for types other than arrays and slices by implementing the &lt;a href=&quot;../../std/ops/trait.index&quot;&gt;Index&lt;/a&gt; and &lt;a href=&quot;../../std/ops/trait.indexmut&quot;&gt;IndexMut&lt;/a&gt; traits.</source>
          <target state="translated">Выражение индекса массива может быть реализовано для типов, отличных от массивов и срезов, путем реализации признаков &lt;a href=&quot;../../std/ops/trait.index&quot;&gt;Index&lt;/a&gt; и &lt;a href=&quot;../../std/ops/trait.indexmut&quot;&gt;IndexMut&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="43b42b264d53f00eb4d50d966bdebfe503d9e502" translate="yes" xml:space="preserve">
          <source>The array named &lt;code&gt;a&lt;/code&gt; will contain &lt;code&gt;5&lt;/code&gt; elements that will all be set to the value &lt;code&gt;3&lt;/code&gt; initially. This is the same as writing &lt;code&gt;let a = [3, 3, 3, 3, 3];&lt;/code&gt; but in a more concise way.</source>
          <target state="translated">Массив с именем &lt;code&gt;a&lt;/code&gt; будет содержать &lt;code&gt;5&lt;/code&gt; элементов, для которых изначально будет установлено значение &lt;code&gt;3&lt;/code&gt; . Это то же самое, что писать &lt;code&gt;let a = [3, 3, 3, 3, 3];&lt;/code&gt; но более кратко.</target>
        </trans-unit>
        <trans-unit id="bda6f38466d2f9f90243514e2e1d1d622e872f82" translate="yes" xml:space="preserve">
          <source>The associated error which can be returned from parsing.</source>
          <target state="translated">Связанная с этим ошибка,которая может быть возвращена при разборе.</target>
        </trans-unit>
        <trans-unit id="264397f1a1d81bc0bfb862d1058ae5d080545332" translate="yes" xml:space="preserve">
          <source>The associated type used was not defined in the trait.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="95b071fe52a22a379b9072dba9b8116f1e91d5e0" translate="yes" xml:space="preserve">
          <source>The assumed lifetime of references held by a &lt;a href=&quot;types/trait-object&quot;&gt;trait object&lt;/a&gt; is called its &lt;em&gt;default object lifetime bound&lt;/em&gt;. These were defined in &lt;a href=&quot;https://github.com/rust-lang/rfcs/blob/master/text/0599-default-object-bound.md&quot;&gt;RFC 599&lt;/a&gt; and amended in &lt;a href=&quot;https://github.com/rust-lang/rfcs/blob/master/text/1156-adjust-default-object-bounds.md&quot;&gt;RFC 1156&lt;/a&gt;.</source>
          <target state="translated">Предполагаемое время жизни ссылок, содержащихся в &lt;a href=&quot;types/trait-object&quot;&gt;объекте-признаке,&lt;/a&gt; называется &lt;em&gt;пределом времени существования объекта по умолчанию&lt;/em&gt; . Они были определены в &lt;a href=&quot;https://github.com/rust-lang/rfcs/blob/master/text/0599-default-object-bound.md&quot;&gt;RFC 599&lt;/a&gt; и изменены в &lt;a href=&quot;https://github.com/rust-lang/rfcs/blob/master/text/1156-adjust-default-object-bounds.md&quot;&gt;RFC 1156&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="4a633a670846190d4e317682018f539e771650d4" translate="yes" xml:space="preserve">
          <source>The atomic intrinsics provide common atomic operations on machine words, with multiple possible memory orderings. They obey the same semantics as C++11. See the LLVM documentation on [&lt;a href=&quot;http://llvm.org/docs/Atomics.html&quot;&gt;atomics&lt;/a&gt;].</source>
          <target state="translated">Атомарные встроенные функции обеспечивают общие атомарные операции над машинными словами с несколькими возможными порядками памяти. Они подчиняются той же семантике, что и C ++ 11. См. Документацию LLVM на [ &lt;a href=&quot;http://llvm.org/docs/Atomics.html&quot;&gt;атомикс&lt;/a&gt; ].</target>
        </trans-unit>
        <trans-unit id="4eacfc8c255cb1ef132a6a65b58c2019ebea9baf" translate="yes" xml:space="preserve">
          <source>The atomic types in this module may not be available on all platforms. The atomic types here are all widely available, however, and can generally be relied upon existing. Some notable exceptions are:</source>
          <target state="translated">Атомные типы в этом модуле могут быть доступны не на всех платформах.Тем не менее,все типы атомов здесь широко доступны,и в целом на них можно положиться.Существуют некоторые примечательные исключения:</target>
        </trans-unit>
        <trans-unit id="71cc0f45759d249e1ba21744ede7b9ef7445260e" translate="yes" xml:space="preserve">
          <source>The attribute consists of a path to the attribute, followed by an optional delimited token tree whose interpretation is defined by the attribute. Attributes other than macro attributes also allow the input to be an equals sign (&lt;code&gt;=&lt;/code&gt;) followed by a literal expression. See the &lt;a href=&quot;#meta-item-attribute-syntax&quot;&gt;meta item syntax&lt;/a&gt; below for more details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c5f89ad9ce66636388cf7509f930392e52eeb867" translate="yes" xml:space="preserve">
          <source>The attribute consists of a path to the attribute, followed by an optional delimited token tree whose interpretation is defined by the attribute. Attributes other than macro attributes also allow the input to be an equals sign (&lt;code&gt;=&lt;/code&gt;) followed by a literal expression. See the &lt;a href=&quot;attributes#meta-item-attribute-syntax&quot;&gt;meta item syntax&lt;/a&gt; below for more details.</source>
          <target state="translated">Атрибут состоит из пути к атрибуту, за которым следует необязательное дерево токенов с разделителями, интерпретация которого определяется атрибутом. Атрибуты, отличные от атрибутов макроса, также позволяют вводить знак равенства ( &lt;code&gt;=&lt;/code&gt; ), за которым следует буквальное выражение. Подробнее см. &lt;a href=&quot;attributes#meta-item-attribute-syntax&quot;&gt;Синтаксис мета-элемента&lt;/a&gt; ниже.</target>
        </trans-unit>
        <trans-unit id="b79be106b3314bbccaaacf6171952db704c5419b" translate="yes" xml:space="preserve">
          <source>The attribute is used on a &lt;code&gt;static&lt;/code&gt; item whose type implements the &lt;a href=&quot;https://doc.rust-lang.org/core/alloc/trait.GlobalAlloc.html&quot;&gt;&lt;code&gt;GlobalAlloc&lt;/code&gt;&lt;/a&gt; trait. This type can be provided by an external library:</source>
          <target state="translated">Атрибут используется в &lt;code&gt;static&lt;/code&gt; элементе, тип которого реализует &lt;a href=&quot;https://doc.rust-lang.org/core/alloc/trait.GlobalAlloc.html&quot;&gt; &lt;code&gt;GlobalAlloc&lt;/code&gt; &lt;/a&gt; . Этот тип может быть предоставлен внешней библиотекой:</target>
        </trans-unit>
        <trans-unit id="638938ad1b96ca367b1ad29ad316e67748e69b45" translate="yes" xml:space="preserve">
          <source>The attribute is used on a &lt;code&gt;static&lt;/code&gt; item whose type implements the &lt;a href=&quot;trait.globalalloc&quot;&gt;&lt;code&gt;GlobalAlloc&lt;/code&gt;&lt;/a&gt; trait. This type can be provided by an external library:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="07001b94d9ec08710a57474a9ab6a5a7c57ed031" translate="yes" xml:space="preserve">
          <source>The attributes that have meaning on a block expression are &lt;a href=&quot;../conditional-compilation&quot;&gt;&lt;code&gt;cfg&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../attributes/diagnostics#lint-check-attributes&quot;&gt;the lint check attributes&lt;/a&gt;.</source>
          <target state="translated">Атрибуты, которые имеют значение в выражении блока, - это &lt;a href=&quot;../conditional-compilation&quot;&gt; &lt;code&gt;cfg&lt;/code&gt; &lt;/a&gt; и &lt;a href=&quot;../attributes/diagnostics#lint-check-attributes&quot;&gt;атрибуты lint check&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="db84623389bc5fe968094b478ac6446a9f7cd32b" translate="yes" xml:space="preserve">
          <source>The attributes that have meaning on a function are &lt;a href=&quot;../conditional-compilation&quot;&gt;&lt;code&gt;cfg&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../attributes/diagnostics#the-deprecated-attribute&quot;&gt;&lt;code&gt;deprecated&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://doc.rust-lang.org/rustdoc/the-doc-attribute.html&quot;&gt;&lt;code&gt;doc&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../abi#the-export_name-attribute&quot;&gt;&lt;code&gt;export_name&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../abi#the-link_section-attribute&quot;&gt;&lt;code&gt;link_section&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../abi#the-no_mangle-attribute&quot;&gt;&lt;code&gt;no_mangle&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../attributes/diagnostics#lint-check-attributes&quot;&gt;the lint check attributes&lt;/a&gt;, &lt;a href=&quot;../attributes/diagnostics#the-must_use-attribute&quot;&gt;&lt;code&gt;must_use&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../procedural-macros&quot;&gt;the procedural macro attributes&lt;/a&gt;, &lt;a href=&quot;../attributes/testing&quot;&gt;the testing attributes&lt;/a&gt;, and &lt;a href=&quot;../attributes/codegen#optimization-hints&quot;&gt;the optimization hint attributes&lt;/a&gt;. Functions also accept attributes macros.</source>
          <target state="translated">Атрибуты , которые имеют смысл на функции являются &lt;a href=&quot;../conditional-compilation&quot;&gt; &lt;code&gt;cfg&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;../attributes/diagnostics#the-deprecated-attribute&quot;&gt; &lt;code&gt;deprecated&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;https://doc.rust-lang.org/rustdoc/the-doc-attribute.html&quot;&gt; &lt;code&gt;doc&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;../abi#the-export_name-attribute&quot;&gt; &lt;code&gt;export_name&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;../abi#the-link_section-attribute&quot;&gt; &lt;code&gt;link_section&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;../abi#the-no_mangle-attribute&quot;&gt; &lt;code&gt;no_mangle&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;../attributes/diagnostics#lint-check-attributes&quot;&gt;проверочные ворса атрибутов&lt;/a&gt; , &lt;a href=&quot;../attributes/diagnostics#the-must_use-attribute&quot;&gt; &lt;code&gt;must_use&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;../procedural-macros&quot;&gt;процедурные макро атрибутов&lt;/a&gt; , &lt;a href=&quot;../attributes/testing&quot;&gt;атрибуты тестирования&lt;/a&gt; , а также &lt;a href=&quot;../attributes/codegen#optimization-hints&quot;&gt;атрибуты оптимизации подсказки&lt;/a&gt; . Функции также принимают макросы атрибутов.</target>
        </trans-unit>
        <trans-unit id="622c3bad6ebce7dda9ab10b347056427bd42a746" translate="yes" xml:space="preserve">
          <source>The attributes that have meaning on a function are &lt;a href=&quot;../conditional-compilation#the-cfg-attribute&quot;&gt;&lt;code&gt;cfg&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../conditional-compilation#the-cfg_attr-attribute&quot;&gt;&lt;code&gt;cfg_attr&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../attributes/diagnostics#the-deprecated-attribute&quot;&gt;&lt;code&gt;deprecated&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://doc.rust-lang.org/rustdoc/the-doc-attribute.html&quot;&gt;&lt;code&gt;doc&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../abi#the-export_name-attribute&quot;&gt;&lt;code&gt;export_name&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../abi#the-link_section-attribute&quot;&gt;&lt;code&gt;link_section&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../abi#the-no_mangle-attribute&quot;&gt;&lt;code&gt;no_mangle&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../attributes/diagnostics#lint-check-attributes&quot;&gt;the lint check attributes&lt;/a&gt;, &lt;a href=&quot;../attributes/diagnostics#the-must_use-attribute&quot;&gt;&lt;code&gt;must_use&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../procedural-macros&quot;&gt;the procedural macro attributes&lt;/a&gt;, &lt;a href=&quot;../attributes/testing&quot;&gt;the testing attributes&lt;/a&gt;, and &lt;a href=&quot;../attributes/codegen#optimization-hints&quot;&gt;the optimization hint attributes&lt;/a&gt;. Functions also accept attributes macros.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a9286c2061446f78d1eb0dacb8ad2bed2198b3a3" translate="yes" xml:space="preserve">
          <source>The author of the code in Listing 14-4, which uses the &lt;code&gt;art&lt;/code&gt; crate, had to figure out that &lt;code&gt;PrimaryColor&lt;/code&gt; is in the &lt;code&gt;kinds&lt;/code&gt; module and &lt;code&gt;mix&lt;/code&gt; is in the &lt;code&gt;utils&lt;/code&gt; module. The module structure of the &lt;code&gt;art&lt;/code&gt; crate is more relevant to developers working on the &lt;code&gt;art&lt;/code&gt; crate than to developers using the &lt;code&gt;art&lt;/code&gt; crate. The internal structure that organizes parts of the crate into the &lt;code&gt;kinds&lt;/code&gt; module and the &lt;code&gt;utils&lt;/code&gt; module doesn&amp;rsquo;t contain any useful information for someone trying to understand how to use the &lt;code&gt;art&lt;/code&gt; crate. Instead, the &lt;code&gt;art&lt;/code&gt; crate&amp;rsquo;s module structure causes confusion because developers have to figure out where to look, and the structure is inconvenient because developers must specify the module names in the &lt;code&gt;use&lt;/code&gt; statements.</source>
          <target state="translated">Автор кода в листинге 14-4, который использует &lt;code&gt;art&lt;/code&gt; клеть, должен был выяснить , что &lt;code&gt;PrimaryColor&lt;/code&gt; находится в &lt;code&gt;kinds&lt;/code&gt; модуля и &lt;code&gt;mix&lt;/code&gt; находится в &lt;code&gt;utils&lt;/code&gt; модуле. Модульная структура &lt;code&gt;art&lt;/code&gt; ящика более актуальна для разработчиков, работающих над &lt;code&gt;art&lt;/code&gt; ящиком, чем для разработчиков, использующих &lt;code&gt;art&lt;/code&gt; ящик. Внутренняя структура, которая объединяет части ящика в модуль &lt;code&gt;kinds&lt;/code&gt; модуль &lt;code&gt;utils&lt;/code&gt; , не содержит никакой полезной информации для тех, кто пытается понять, как использовать ящик с &lt;code&gt;art&lt;/code&gt; . Вместо этого &lt;code&gt;art&lt;/code&gt; Структура модуля crate вызывает путаницу, потому что разработчики должны выяснить, где искать, а структура неудобна, потому что разработчики должны указывать имена модулей в операторах &lt;code&gt;use&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d8ebf8e3de6c2376fc1a32c2614c0e8023f7f60e" translate="yes" xml:space="preserve">
          <source>The author of this code probably wants &lt;code&gt;collect()&lt;/code&gt; to return a &lt;code&gt;Result&amp;lt;Vec&amp;lt;bool&amp;gt;, ()&amp;gt;&lt;/code&gt;, but the compiler can't be sure that there isn't another type &lt;code&gt;T&lt;/code&gt; implementing both &lt;code&gt;Try&lt;/code&gt; and &lt;code&gt;FromIterator&amp;lt;Result&amp;lt;bool, ()&amp;gt;&amp;gt;&lt;/code&gt; in scope such that &lt;code&gt;T::Ok == Vec&amp;lt;bool&amp;gt;&lt;/code&gt;. Hence, this code is ambiguous and an error is returned.</source>
          <target state="translated">Автор этого кода, вероятно, хочет, чтобы &lt;code&gt;collect()&lt;/code&gt; возвращал &lt;code&gt;Result&amp;lt;Vec&amp;lt;bool&amp;gt;, ()&amp;gt;&lt;/code&gt; , но компилятор не может быть уверен, что нет другого типа &lt;code&gt;T&lt;/code&gt; , реализующего как &lt;code&gt;Try&lt;/code&gt; ,так и &lt;code&gt;FromIterator&amp;lt;Result&amp;lt;bool, ()&amp;gt;&amp;gt;&lt;/code&gt; в такой области, что &lt;code&gt;T::Ok == Vec&amp;lt;bool&amp;gt;&lt;/code&gt; . Следовательно, этот код неоднозначен и возвращается ошибка.</target>
        </trans-unit>
        <trans-unit id="946c3c8468dffe1ee08b57091aa458b31b356f72" translate="yes" xml:space="preserve">
          <source>The automatically generated &quot;drop glue&quot; which recursively calls the destructors of the all fields of this value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="442e142fa9a496c6c2ff3a02ee78aa50e228d6e4" translate="yes" xml:space="preserve">
          <source>The bad state is not something that&amp;rsquo;s &lt;em&gt;expected&lt;/em&gt; to happen occasionally.</source>
          <target state="translated">Плохое состояние - это не то, &lt;em&gt;что&lt;/em&gt; случается время от времени.</target>
        </trans-unit>
        <trans-unit id="1030d03bed1910f08091eb456180338b656dc0aa" translate="yes" xml:space="preserve">
          <source>The base of a &lt;a href=&quot;expressions/struct-expr#functional-update-syntax&quot;&gt;functional update&lt;/a&gt; struct expression.</source>
          <target state="translated">Основа &lt;a href=&quot;expressions/struct-expr#functional-update-syntax&quot;&gt;функционального&lt;/a&gt; выражения структуры обновления .</target>
        </trans-unit>
        <trans-unit id="1da424ed8fd790e722f71cc50f820022f89f696b" translate="yes" xml:space="preserve">
          <source>The behavior of the returned &lt;code&gt;Waker&lt;/code&gt; is undefined if the contract defined in &lt;a href=&quot;struct.rawwaker&quot;&gt;&lt;code&gt;RawWaker&lt;/code&gt;&lt;/a&gt;'s and &lt;a href=&quot;struct.rawwakervtable&quot;&gt;&lt;code&gt;RawWakerVTable&lt;/code&gt;&lt;/a&gt;'s documentation is not upheld. Therefore this method is unsafe.</source>
          <target state="translated">Поведение возвращенного &lt;code&gt;Waker&lt;/code&gt; не определено, если контракт, определенный в документации &lt;a href=&quot;struct.rawwaker&quot;&gt; &lt;code&gt;RawWaker&lt;/code&gt; &lt;/a&gt; и &lt;a href=&quot;struct.rawwakervtable&quot;&gt; &lt;code&gt;RawWakerVTable&lt;/code&gt; ,&lt;/a&gt; не поддерживается. Поэтому этот метод небезопасен.</target>
        </trans-unit>
        <trans-unit id="c7f5bfcda53c0f0ccac4fbf04091f03de55bc719" translate="yes" xml:space="preserve">
          <source>The behavior of this method must be independent of the state of the &lt;code&gt;Read&lt;/code&gt;er - the method only takes &lt;code&gt;&amp;amp;self&lt;/code&gt; so that it can be used through trait objects.</source>
          <target state="translated">Поведение этого метода не должно зависеть от состояния объекта &lt;code&gt;Read&lt;/code&gt; - метод принимает только &lt;code&gt;&amp;amp;self&lt;/code&gt; чтобы его можно было использовать через объекты-типажи.</target>
        </trans-unit>
        <trans-unit id="92a385c5078364ae9300fa907e25a19462c00810" translate="yes" xml:space="preserve">
          <source>The benefit of having this restriction is that Rust can prevent data races at compile time. A &lt;em&gt;data race&lt;/em&gt; is similar to a race condition and happens when these three behaviors occur:</source>
          <target state="translated">Преимущество этого ограничения заключается в том, что Rust может предотвратить скачки данных во время компиляции. &lt;em&gt;Гонки данных&lt;/em&gt; похожа на состояние гонки и происходит , когда эти три модели поведения:</target>
        </trans-unit>
        <trans-unit id="94345eda8bccf9faca124acc23e9dfc7f68245ec" translate="yes" xml:space="preserve">
          <source>The bits that define the access mode are masked out with &lt;code&gt;O_ACCMODE&lt;/code&gt;, to ensure they do not interfere with the access mode set by Rusts options.</source>
          <target state="translated">Биты, определяющие режим доступа, маскируются с помощью &lt;code&gt;O_ACCMODE&lt;/code&gt; , чтобы гарантировать, что они не мешают режиму доступа, установленному параметрами Rusts.</target>
        </trans-unit>
        <trans-unit id="eaa8e0a3053148a58d441c5d948ef0afd09016e9" translate="yes" xml:space="preserve">
          <source>The bitwise AND assignment operator &lt;code&gt;&amp;amp;=&lt;/code&gt;.</source>
          <target state="translated">Оператор побитового присваивания AND &lt;code&gt;&amp;amp;=&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1dd8ef8a8d73fdf98095248d6c0b2047cb203cf0" translate="yes" xml:space="preserve">
          <source>The bitwise AND operator &lt;code&gt;&amp;amp;&lt;/code&gt;.</source>
          <target state="translated">Поразрядный оператор И &lt;code&gt;&amp;amp;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2bfdab4f43dd337afc8fc0552897bf0d88f4fb0e" translate="yes" xml:space="preserve">
          <source>The bitwise OR assignment operator &lt;code&gt;|=&lt;/code&gt;.</source>
          <target state="translated">Оператор присваивания поразрядное ИЛИ &lt;code&gt;|=&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a78ed80e19856e33ead5257328ef19e1b110eb08" translate="yes" xml:space="preserve">
          <source>The bitwise OR operator &lt;code&gt;|&lt;/code&gt;.</source>
          <target state="translated">Побитовый оператор ИЛИ &lt;code&gt;|&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="eafeed4a6ad02f43abd1d07f62b4dea554b3a79c" translate="yes" xml:space="preserve">
          <source>The bitwise XOR assignment operator &lt;code&gt;^=&lt;/code&gt;.</source>
          <target state="translated">Оператор присваивания побитового XOR &lt;code&gt;^=&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e805a1bbc089611af418b7bd9e638939dac553c5" translate="yes" xml:space="preserve">
          <source>The bitwise XOR operator &lt;code&gt;^&lt;/code&gt;.</source>
          <target state="translated">Побитовый оператор XOR &lt;code&gt;^&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="423b8775203e06b0ca354c4f4e97825a7d00a713" translate="yes" xml:space="preserve">
          <source>The block of a function is conceptually wrapped in a block that binds the argument patterns and then &lt;code&gt;return&lt;/code&gt;s the value of the function's block. This means that the tail expression of the block, if evaluated, ends up being returned to the caller. As usual, an explicit return expression within the body of the function will short-cut that implicit return, if reached.</source>
          <target state="translated">Блок функции концептуально заключен в блок, который связывает шаблоны аргументов и затем &lt;code&gt;return&lt;/code&gt; значение блока функции. Это означает, что заключительное выражение блока, если оно оценено, в конечном итоге возвращается вызывающей стороне. Как обычно, явное возвращаемое выражение в теле функции сокращает этот неявный возврат, если оно достигается.</target>
        </trans-unit>
        <trans-unit id="761ca0a326eb25085e5f1ebfbcef3b94f323b7c7" translate="yes" xml:space="preserve">
          <source>The block's size must fall in the range &lt;code&gt;[use_min, use_max]&lt;/code&gt;, where:</source>
          <target state="translated">Размер блока должен находиться в диапазоне &lt;code&gt;[use_min, use_max]&lt;/code&gt; , где:</target>
        </trans-unit>
        <trans-unit id="0d55dd5d42feb75840d81a2ee396cf125ff6a36f" translate="yes" xml:space="preserve">
          <source>The block's starting address must be aligned to &lt;code&gt;layout.align()&lt;/code&gt;.</source>
          <target state="translated">Начальный адрес блока должен быть выровнен с &lt;code&gt;layout.align()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6fb5efe10f486c51a18bce4f54350dd31c9d18ad" translate="yes" xml:space="preserve">
          <source>The bodies of the &lt;code&gt;if let&lt;/code&gt; and the &lt;code&gt;unwrap_or_else&lt;/code&gt; functions are the same in both cases: we print the error and exit.</source>
          <target state="translated">Тела функций &lt;code&gt;if let&lt;/code&gt; и &lt;code&gt;unwrap_or_else&lt;/code&gt; в обоих случаях одинаковы: мы печатаем ошибку и выходим.</target>
        </trans-unit>
        <trans-unit id="a084bd821dcd5af3bead7d20966da99b85c8d3d6" translate="yes" xml:space="preserve">
          <source>The body of a &lt;a href=&quot;expressions/if-expr#if-expressions&quot;&gt;&lt;code&gt;if&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;expressions/loop-expr#predicate-loops&quot;&gt;&lt;code&gt;while&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;expressions/loop-expr#infinite-loops&quot;&gt;&lt;code&gt;loop&lt;/code&gt;&lt;/a&gt; expression.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8d22837f9a0a24391528e1a0b3b2365c1d2579bc" translate="yes" xml:space="preserve">
          <source>The body of the function starts by calling the &lt;code&gt;File::open&lt;/code&gt; function. Then we handle the &lt;code&gt;Result&lt;/code&gt; value returned with a &lt;code&gt;match&lt;/code&gt; similar to the &lt;code&gt;match&lt;/code&gt; in Listing 9-4, only instead of calling &lt;code&gt;panic!&lt;/code&gt; in the &lt;code&gt;Err&lt;/code&gt; case, we return early from this function and pass the error value from &lt;code&gt;File::open&lt;/code&gt; back to the calling code as this function&amp;rsquo;s error value. If &lt;code&gt;File::open&lt;/code&gt; succeeds, we store the file handle in the variable &lt;code&gt;f&lt;/code&gt; and continue.</source>
          <target state="translated">Тело функции начинается с вызова функции &lt;code&gt;File::open&lt;/code&gt; . Затем мы обрабатываем возвращаемое значение &lt;code&gt;Result&lt;/code&gt; с &lt;code&gt;match&lt;/code&gt; аналогичным &lt;code&gt;match&lt;/code&gt; в листинге 9-4, только вместо вызова &lt;code&gt;panic!&lt;/code&gt; в случае &lt;code&gt;Err&lt;/code&gt; мы возвращаемся из этой функции раньше и передаем значение ошибки из &lt;code&gt;File::open&lt;/code&gt; обратно в вызывающий код в качестве значения ошибки этой функции. Если &lt;code&gt;File::open&lt;/code&gt; завершается успешно, мы сохраняем дескриптор файла в переменной &lt;code&gt;f&lt;/code&gt; и продолжаем.</target>
        </trans-unit>
        <trans-unit id="9ba4d0e4523a23a56b57272682f48b03a790c657" translate="yes" xml:space="preserve">
          <source>The body of the method would use &lt;code&gt;self&lt;/code&gt; to get the value that we called the method on. In this example, we&amp;rsquo;ve created a variable &lt;code&gt;m&lt;/code&gt; that has the value &lt;code&gt;Message::Write(String::from(&quot;hello&quot;))&lt;/code&gt;, and that is what &lt;code&gt;self&lt;/code&gt; will be in the body of the &lt;code&gt;call&lt;/code&gt; method when &lt;code&gt;m.call()&lt;/code&gt; runs.</source>
          <target state="translated">Тело метода будет использовать &lt;code&gt;self&lt;/code&gt; для получения значения, для которого мы вызвали метод. В этом примере мы создали переменную &lt;code&gt;m&lt;/code&gt; , которая имеет значение &lt;code&gt;Message::Write(String::from(&quot;hello&quot;))&lt;/code&gt; , и это то, чем &lt;code&gt;self&lt;/code&gt; будет в теле метода &lt;code&gt;call&lt;/code&gt; , когда &lt;code&gt;m.call()&lt;/code&gt; работает.</target>
        </trans-unit>
        <trans-unit id="9c00fd6128e2bdd1cc90bd415df84de85499f4fb" translate="yes" xml:space="preserve">
          <source>The book &lt;em&gt;Design Patterns: Elements of Reusable Object-Oriented Software&lt;/em&gt; by Erich Gamma, Richard Helm, Ralph Johnson, and John Vlissides (Addison-Wesley Professional, 1994) colloquially referred to as &lt;em&gt;The Gang of Four&lt;/em&gt; book, is a catalog of object-oriented design patterns. It defines OOP this way:</source>
          <target state="translated">Книга Эриха Гаммы, Ричарда Хелма, Ральфа Джонсона и Джона Влиссидеса &lt;em&gt;&quot;Шаблоны проектирования: элементы объектно-ориентированного программного обеспечения многократного использования&quot;&lt;/em&gt; (Addison-Wesley Professional, 1994), в просторечии именуемая книгой &quot; &lt;em&gt;Банда четырех&quot;&lt;/em&gt; , представляет собой каталог объектно-ориентированных программ. шаблоны проектирования. Он определяет ООП следующим образом:</target>
        </trans-unit>
        <trans-unit id="0ab81c05a8d6cbaec3e9dfb9c8caa2a16dab19bf" translate="yes" xml:space="preserve">
          <source>The boolean type.</source>
          <target state="translated">Булевого типа.</target>
        </trans-unit>
        <trans-unit id="06283747a377154700dbba912c9e77d60011a87e" translate="yes" xml:space="preserve">
          <source>The borrow lasts until the returned &lt;code&gt;Ref&lt;/code&gt; exits scope. Multiple immutable borrows can be taken out at the same time.</source>
          <target state="translated">Заимствование длится до тех пор, пока возвращенный &lt;code&gt;Ref&lt;/code&gt; не покинет область действия. Одновременно можно получить несколько неизменных займов.</target>
        </trans-unit>
        <trans-unit id="45376451530857b96a10ec4a5e20bb51cfc0ed12" translate="yes" xml:space="preserve">
          <source>The borrow lasts until the returned &lt;code&gt;RefMut&lt;/code&gt; or all &lt;code&gt;RefMut&lt;/code&gt;s derived from it exit scope. The value cannot be borrowed while this borrow is active.</source>
          <target state="translated">&lt;code&gt;RefMut&lt;/code&gt; длится до тех пор, пока возвращенный RefMut или все производные &lt;code&gt;RefMut&lt;/code&gt; не выйдут из области видимости. Стоимость не может быть заимствована, пока этот заем активен.</target>
        </trans-unit>
        <trans-unit id="f968733bf846dacfb002493e18e27a27864a5d95" translate="yes" xml:space="preserve">
          <source>The buffer is written out before returning the writer.</source>
          <target state="translated">Буфер переписывается перед возвращением записывающего устройства.</target>
        </trans-unit>
        <trans-unit id="8d2f5c9c4df44bd26200b02c526dd9675a0b62ea" translate="yes" xml:space="preserve">
          <source>The buffer specified was 0 bytes in length.</source>
          <target state="translated">Указанный буфер имел длину 0 байт.</target>
        </trans-unit>
        <trans-unit id="aac2e47b3535d051db39f7a14fa1dba18fc6a121" translate="yes" xml:space="preserve">
          <source>The built-in &lt;code&gt;cfg&lt;/code&gt; macro takes in a single configuration predicate and evaluates to the &lt;code&gt;true&lt;/code&gt; literal when the predicate is true and the &lt;code&gt;false&lt;/code&gt; literal when it is false.</source>
          <target state="translated">Встроенный макрос &lt;code&gt;cfg&lt;/code&gt; принимает один предикат конфигурации и вычисляет &lt;code&gt;true&lt;/code&gt; литерал, когда предикат истинен, и &lt;code&gt;false&lt;/code&gt; литерал, когда он ложен.</target>
        </trans-unit>
        <trans-unit id="87ae881f172e3eab463a1dba119d942ed8deaed7" translate="yes" xml:space="preserve">
          <source>The built-in attributes that have meaning on a function are &lt;a href=&quot;../conditional-compilation&quot;&gt;&lt;code&gt;cfg&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../attributes/diagnostics#the-deprecated-attribute&quot;&gt;&lt;code&gt;deprecated&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://doc.rust-lang.org/rustdoc/the-doc-attribute.html&quot;&gt;&lt;code&gt;doc&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../attributes/diagnostics#lint-check-attributes&quot;&gt;the lint check attributes&lt;/a&gt;, &lt;code&gt;path&lt;/code&gt;, and &lt;code&gt;no_implicit_prelude&lt;/code&gt;. Modules also accept macro attributes.</source>
          <target state="translated">Встроенные атрибуты, которые имеют значение для функции: &lt;a href=&quot;../conditional-compilation&quot;&gt; &lt;code&gt;cfg&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;../attributes/diagnostics#the-deprecated-attribute&quot;&gt; &lt;code&gt;deprecated&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;https://doc.rust-lang.org/rustdoc/the-doc-attribute.html&quot;&gt; &lt;code&gt;doc&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;../attributes/diagnostics#lint-check-attributes&quot;&gt;атрибуты lint check&lt;/a&gt; , &lt;code&gt;path&lt;/code&gt; и &lt;code&gt;no_implicit_prelude&lt;/code&gt; . Модули также принимают атрибуты макросов.</target>
        </trans-unit>
        <trans-unit id="0658caeac4e6cc6250807a10a1d1127da8f7b8cb" translate="yes" xml:space="preserve">
          <source>The built-in attributes that have meaning on a module are &lt;a href=&quot;../conditional-compilation&quot;&gt;&lt;code&gt;cfg&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../attributes/diagnostics#the-deprecated-attribute&quot;&gt;&lt;code&gt;deprecated&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://doc.rust-lang.org/rustdoc/the-doc-attribute.html&quot;&gt;&lt;code&gt;doc&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../attributes/diagnostics#lint-check-attributes&quot;&gt;the lint check attributes&lt;/a&gt;, &lt;code&gt;path&lt;/code&gt;, and &lt;code&gt;no_implicit_prelude&lt;/code&gt;. Modules also accept macro attributes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7917b1e20d5567c345241cec71cc654edebdd434" translate="yes" xml:space="preserve">
          <source>The built-in function traits are generic over a tuple of the function arguments. If one uses angle-bracket notation (&lt;code&gt;Fn&amp;lt;(T,), Output=U&amp;gt;&lt;/code&gt;) instead of parentheses (&lt;code&gt;Fn(T) -&amp;gt; U&lt;/code&gt;) to denote the function trait, the type parameter should be a tuple. Otherwise function call notation cannot be used and the trait will not be implemented by closures.</source>
          <target state="translated">Встроенные характеристики функции являются общими для кортежа аргументов функции. Если для обозначения признака функции используется угловая скобка ( &lt;code&gt;Fn&amp;lt;(T,), Output=U&amp;gt;&lt;/code&gt; ) вместо скобок ( &lt;code&gt;Fn(T) -&amp;gt; U&lt;/code&gt; ), параметр типа должен быть кортежем. В противном случае нельзя использовать нотацию вызова функции, и признак не будет реализован посредством замыканий.</target>
        </trans-unit>
        <trans-unit id="a9e1ef14ad9c5016cccb06e0dae0b41ca0441837" translate="yes" xml:space="preserve">
          <source>The c-main function only supports to return integers as return type. So, every type implementing the &lt;code&gt;Termination&lt;/code&gt; trait has to be converted to an integer.</source>
          <target state="translated">Функция c-main поддерживает только возвращение целых чисел в качестве возвращаемого типа. Таким образом, каждый тип, реализующий признак &lt;code&gt;Termination&lt;/code&gt; должен быть преобразован в целое число.</target>
        </trans-unit>
        <trans-unit id="98a1e057ef0866ad400391fbf23a2daa11b28012" translate="yes" xml:space="preserve">
          <source>The call to &lt;code&gt;lock&lt;/code&gt; would fail if another thread holding the lock panicked. In that case, no one would ever be able to get the lock, so we&amp;rsquo;ve chosen to &lt;code&gt;unwrap&lt;/code&gt; and have this thread panic if we&amp;rsquo;re in that situation.</source>
          <target state="translated">Вызов &lt;code&gt;lock&lt;/code&gt; завершится ошибкой, если другой поток, удерживающий блокировку, запаникует. В этом случае никто никогда не сможет получить блокировку, поэтому мы решили &lt;code&gt;unwrap&lt;/code&gt; и вызвать панику этого потока, если мы в такой ситуации.</target>
        </trans-unit>
        <trans-unit id="a399c55a0729e88865a33bb045bf002d26006429" translate="yes" xml:space="preserve">
          <source>The call to &lt;code&gt;panic!&lt;/code&gt; causes the error message contained in the last two lines. The first line shows our panic message and the place in our source code where the panic occurred: &lt;em&gt;src/main.rs:2:5&lt;/em&gt; indicates that it&amp;rsquo;s the second line, fifth character of our &lt;em&gt;src/main.rs&lt;/em&gt; file.</source>
          <target state="translated">Призыв к &lt;code&gt;panic!&lt;/code&gt; вызывает сообщение об ошибке, содержащееся в последних двух строках. Первая строка показывает наше сообщение о панике и место в нашем исходном коде, где возникла паника: &lt;em&gt;src / main.rs: 2: 5&lt;/em&gt; указывает, что это вторая строка, пятый символ нашего файла &lt;em&gt;src / main.rs.&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="76991560cfa9d5bcd0a2eea05c7ac9259a741680" translate="yes" xml:space="preserve">
          <source>The call to &lt;code&gt;parse&lt;/code&gt; could easily cause an error. If, for example, the string contained &lt;code&gt;A👍%&lt;/code&gt;, there would be no way to convert that to a number. Because it might fail, the &lt;code&gt;parse&lt;/code&gt; method returns a &lt;code&gt;Result&lt;/code&gt; type, much as the &lt;code&gt;read_line&lt;/code&gt; method does (discussed earlier in &lt;a href=&quot;#handling-potential-failure-with-the-result-type&quot;&gt;&amp;ldquo;Handling Potential Failure with the &lt;code&gt;Result&lt;/code&gt; Type&amp;rdquo;&lt;/a&gt;). We&amp;rsquo;ll treat this &lt;code&gt;Result&lt;/code&gt; the same way by using the &lt;code&gt;expect&lt;/code&gt; method again. If &lt;code&gt;parse&lt;/code&gt; returns an &lt;code&gt;Err&lt;/code&gt;&lt;code&gt;Result&lt;/code&gt; variant because it couldn&amp;rsquo;t create a number from the string, the &lt;code&gt;expect&lt;/code&gt; call will crash the game and print the message we give it. If &lt;code&gt;parse&lt;/code&gt; can successfully convert the string to a number, it will return the &lt;code&gt;Ok&lt;/code&gt; variant of &lt;code&gt;Result&lt;/code&gt;, and &lt;code&gt;expect&lt;/code&gt; will return the number that we want from the &lt;code&gt;Ok&lt;/code&gt; value.</source>
          <target state="translated">Вызов &lt;code&gt;parse&lt;/code&gt; легко может вызвать ошибку. Если, например, строка содержит &lt;code&gt;A👍%&lt;/code&gt; , преобразовать ее в число невозможно. Поскольку это может привести к сбою, метод &lt;code&gt;parse&lt;/code&gt; возвращает тип &lt;code&gt;Result&lt;/code&gt; , как и метод &lt;code&gt;read_line&lt;/code&gt; (который обсуждался ранее в разделе &lt;a href=&quot;#handling-potential-failure-with-the-result-type&quot;&gt;&amp;laquo;Обработка потенциального сбоя с помощью типа &lt;code&gt;Result&lt;/code&gt; &amp;raquo;&lt;/a&gt; ). Мы обработаем этот &lt;code&gt;Result&lt;/code&gt; таким же образом, снова используя метод &lt;code&gt;expect&lt;/code&gt; . Если &lt;code&gt;parse&lt;/code&gt; возвращает &lt;code&gt;Err&lt;/code&gt; &lt;code&gt;Result&lt;/code&gt; вариант , поскольку он не может создать ряд из строки, &lt;code&gt;expect&lt;/code&gt; call завершит игру и напечатает сообщение, которое мы ему дали. Если &lt;code&gt;parse&lt;/code&gt; может успешно преобразовать строку в число, он вернет вариант &lt;code&gt;Result&lt;/code&gt; &lt;code&gt;Ok&lt;/code&gt; , и &lt;code&gt;expect&lt;/code&gt; что вернет число, которое мы хотим из значения &lt;code&gt;Ok&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7b69e26d39a3f8839842ab3c559f82019ca9b310" translate="yes" xml:space="preserve">
          <source>The call to &lt;code&gt;recv&lt;/code&gt; blocks, so if there is no job yet, the current thread will wait until a job becomes available. The &lt;code&gt;Mutex&amp;lt;T&amp;gt;&lt;/code&gt; ensures that only one &lt;code&gt;Worker&lt;/code&gt; thread at a time is trying to request a job.</source>
          <target state="translated">Вызов &lt;code&gt;recv&lt;/code&gt; блокируется, поэтому, если задания еще нет, текущий поток будет ждать, пока задание не станет доступным. &lt;code&gt;Mutex&amp;lt;T&amp;gt;&lt;/code&gt; гарантирует , что только один &lt;code&gt;Worker&lt;/code&gt; поток одновременно пытается запросить работу.</target>
        </trans-unit>
        <trans-unit id="8993444f4968db6cec0c3f76e82220cf7def7574" translate="yes" xml:space="preserve">
          <source>The caller has to ensure that no references in the supplied thread closure or its return type can outlive the spawned thread's lifetime. This can be guaranteed in two ways:</source>
          <target state="translated">Звонящий должен удостовериться,что ни одна из ссылок в поставляемой резьбовой заглушке или в ее обратном типе не сможет пережить срок службы нерестовой резьбы.Это может быть гарантировано двумя способами:</target>
        </trans-unit>
        <trans-unit id="093036972d7bffcd0b16a57c6e2ba75deeb1dca1" translate="yes" xml:space="preserve">
          <source>The caller must also ensure that the memory the pointer (non-transitively) points to is never written to (except inside an &lt;code&gt;UnsafeCell&lt;/code&gt;) using this pointer or any pointer derived from it. If you need to mutate the contents of the slice, use &lt;a href=&quot;#method.as_mut_ptr&quot;&gt;&lt;code&gt;as_mut_ptr&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Вызывающая сторона также должна гарантировать, что память, на которую указывает указатель (непереходно), никогда не записывается (кроме как внутри &lt;code&gt;UnsafeCell&lt;/code&gt; ) с использованием этого указателя или любого указателя, производного от него. Если вам нужно изменить содержимое среза, используйте &lt;a href=&quot;#method.as_mut_ptr&quot;&gt; &lt;code&gt;as_mut_ptr&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="fbd8e378206e5ebe48537e21894c0d0196aa5c37" translate="yes" xml:space="preserve">
          <source>The caller must also ensure that the memory the pointer (non-transitively) points to is never written to (except inside an &lt;code&gt;UnsafeCell&lt;/code&gt;) using this pointer or any pointer derived from it. If you need to mutate the contents of the slice, use &lt;a href=&quot;struct.vec#method.as_mut_ptr&quot;&gt;&lt;code&gt;as_mut_ptr&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2daa4ea0adccac77e0ee2e5186b78bccb935a23d" translate="yes" xml:space="preserve">
          <source>The caller must ensure that the content of the slice is valid UTF-8 before the borrow ends and the underlying &lt;code&gt;str&lt;/code&gt; is used.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ac3ada34e0728cb1a740ac35a9a92bd4109e42c8" translate="yes" xml:space="preserve">
          <source>The caller must ensure that the returned pointer is never written to. If you need to mutate the contents of the string slice, use &lt;a href=&quot;#method.as_mut_ptr&quot;&gt;&lt;code&gt;as_mut_ptr&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Вызывающий должен гарантировать, что возвращаемый указатель никогда не записывается. Если вам нужно изменить содержимое строкового фрагмента, используйте &lt;a href=&quot;#method.as_mut_ptr&quot;&gt; &lt;code&gt;as_mut_ptr&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="0c95ecf028004da1510b460935745006e917bea1" translate="yes" xml:space="preserve">
          <source>The caller must ensure that the returned pointer is never written to. If you need to mutate the contents of the string slice, use &lt;a href=&quot;../primitive.str#method.as_mut_ptr&quot;&gt;&lt;code&gt;as_mut_ptr&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="de2dba4a5088d0450aaa1d7584230c3882b4aa0e" translate="yes" xml:space="preserve">
          <source>The caller must ensure that the returned pointer is never written to. If you need to mutate the contents of the string slice, use &lt;a href=&quot;primitive.str#method.as_mut_ptr&quot;&gt;&lt;code&gt;as_mut_ptr&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0392a3d2bc79f7cc36923d474ab5bb48f657c119" translate="yes" xml:space="preserve">
          <source>The caller must ensure that the slice outlives the pointer this function returns, or else it will end up pointing to garbage.</source>
          <target state="translated">Звонящий должен удостовериться,что ломтик пережит указатель,который возвращается этой функцией,иначе он укажет на мусор.</target>
        </trans-unit>
        <trans-unit id="bf480a8080607d02f4b53d9ea9e935964787c02b" translate="yes" xml:space="preserve">
          <source>The caller must ensure that the vector outlives the pointer this function returns, or else it will end up pointing to garbage. Modifying the vector may cause its buffer to be reallocated, which would also make any pointers to it invalid.</source>
          <target state="translated">Звонящий должен убедиться,что вектор пережит указатель,который возвращается этой функцией,иначе он укажет на мусор.Изменение вектора может привести к перераспределению его буфера,что также сделает любые указатели на него недействительными.</target>
        </trans-unit>
        <trans-unit id="09005f0066a1b73d30e33e09129bf20aee61c736" translate="yes" xml:space="preserve">
          <source>The calling thread will be blocked until there are no more writers which hold the lock. There may be other readers currently inside the lock when this method returns. This method does not provide any guarantees with respect to the ordering of whether contentious readers or writers will acquire the lock first.</source>
          <target state="translated">Вызовная нить будет заблокирована до тех пор,пока больше нет записывающих устройств,которые удерживают блокировку.Когда этот метод вернется,в блокировке могут быть и другие читатели.Этот метод не дает никаких гарантий в отношении того,что спорные читатели или записывающие устройства получат блокировку первыми.</target>
        </trans-unit>
        <trans-unit id="4c684d1da6df1a86528a2f3d33b0bb20fea3d352" translate="yes" xml:space="preserve">
          <source>The calls to &lt;code&gt;thread::sleep&lt;/code&gt; force a thread to stop its execution for a short duration, allowing a different thread to run. The threads will probably take turns, but that isn&amp;rsquo;t guaranteed: it depends on how your operating system schedules the threads. In this run, the main thread printed first, even though the print statement from the spawned thread appears first in the code. And even though we told the spawned thread to print until &lt;code&gt;i&lt;/code&gt; is 9, it only got to 5 before the main thread shut down.</source>
          <target state="translated">Вызовы &lt;code&gt;thread::sleep&lt;/code&gt; заставляют поток на короткое время останавливать свое выполнение, позволяя запускать другой поток. Потоки, вероятно, будут меняться, но это не гарантируется: это зависит от того, как ваша операционная система планирует потоки. В этом прогоне основной поток печатается первым, хотя оператор печати из порожденного потока появляется первым в коде. И хотя мы сказали порожденному потоку печатать до тех пор, пока &lt;code&gt;i&lt;/code&gt; не станет 9, он дошел только до 5, прежде чем основной поток завершился.</target>
        </trans-unit>
        <trans-unit id="c7560eebffb8ae3cdb259698d7be211bc4620b7e" translate="yes" xml:space="preserve">
          <source>The canonical ExitCode for successful termination on this platform.</source>
          <target state="translated">Канонический ExitCode для успешного завершения работы на этой платформе.</target>
        </trans-unit>
        <trans-unit id="8f6ef1b9ea50b970966541a96ea6f822d628893b" translate="yes" xml:space="preserve">
          <source>The canonical ExitCode for unsuccessful termination on this platform.</source>
          <target state="translated">Канонический ExitCode для неудачного завершения работы на этой платформе.</target>
        </trans-unit>
        <trans-unit id="edfe5292e463236ad7502b40af63d1dc3846bebd" translate="yes" xml:space="preserve">
          <source>The canonical path is only meaningful within a given crate. There is no global namespace across crates; an item's canonical path merely identifies it within the crate.</source>
          <target state="translated">Канонический путь имеет смысл только внутри данного ящика.В ящиках нет глобального пространства имён;канонический путь элемента лишь идентифицирует его внутри ящика.</target>
        </trans-unit>
        <trans-unit id="42b8d1ea1b4247711765802c026fc2d790b1362d" translate="yes" xml:space="preserve">
          <source>The canonical safe use of &lt;code&gt;mem::forget&lt;/code&gt; is to circumvent a value's destructor implemented by the &lt;code&gt;Drop&lt;/code&gt; trait. For example, this will leak a &lt;code&gt;File&lt;/code&gt;, i.e. reclaim the space taken by the variable but never close the underlying system resource:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1aa3ddcbed06fec001e59bb6f3f1f1da2ef18ef6" translate="yes" xml:space="preserve">
          <source>The capacity may be increased by more than &lt;code&gt;additional&lt;/code&gt; bytes if it chooses, to prevent frequent reallocations.</source>
          <target state="translated">Емкость может быть увеличена более чем на &lt;code&gt;additional&lt;/code&gt; байты, если это необходимо, чтобы предотвратить частое перераспределение.</target>
        </trans-unit>
        <trans-unit id="4e527152d8f3ca4ddc869842d5ee9ae2a46a82fb" translate="yes" xml:space="preserve">
          <source>The capacity of a vector is the amount of space allocated for any future elements that will be added onto the vector. This is not to be confused with the &lt;em&gt;length&lt;/em&gt; of a vector, which specifies the number of actual elements within the vector. If a vector's length exceeds its capacity, its capacity will automatically be increased, but its elements will have to be reallocated.</source>
          <target state="translated">Емкость вектора - это объем пространства, выделенного для любых будущих элементов, которые будут добавлены в вектор. Это не следует путать с &lt;em&gt;длиной&lt;/em&gt; вектора, которая определяет количество фактических элементов в векторе. Если длина вектора превышает его емкость, его емкость автоматически увеличивается, но его элементы придется перераспределить.</target>
        </trans-unit>
        <trans-unit id="a70fb21498dabd7b592b7614b4af0ad2efc52b05" translate="yes" xml:space="preserve">
          <source>The capacity will remain at least as large as both the length and the supplied value.</source>
          <target state="translated">Мощность останется,по меньшей мере,такой же,как и длина,и поставляемая величина.</target>
        </trans-unit>
        <trans-unit id="f2f4d42ff0e5eed287aac391d229f38ad7615e31" translate="yes" xml:space="preserve">
          <source>The captured values of a &lt;a href=&quot;types/closure&quot;&gt;closure&lt;/a&gt; are dropped in an unspecified order.</source>
          <target state="translated">Захваченные значения &lt;a href=&quot;types/closure&quot;&gt;замыкания&lt;/a&gt; отбрасываются в неопределенном порядке.</target>
        </trans-unit>
        <trans-unit id="138edd42fa740c68b92f8f2886d9a7cfd608a2f8" translate="yes" xml:space="preserve">
          <source>The changes we needed to make to &lt;code&gt;main&lt;/code&gt; to reassign &lt;code&gt;post&lt;/code&gt; mean that this implementation doesn&amp;rsquo;t quite follow the object-oriented state pattern anymore: the transformations between the states are no longer encapsulated entirely within the &lt;code&gt;Post&lt;/code&gt; implementation. However, our gain is that invalid states are now impossible because of the type system and the type checking that happens at compile time! This ensures that certain bugs, such as display of the content of an unpublished post, will be discovered before they make it to production.</source>
          <target state="translated">Изменения, которые нам нужно было внести в &lt;code&gt;main&lt;/code&gt; для переназначения &lt;code&gt;post&lt;/code&gt; означают, что эта реализация больше не полностью соответствует объектно-ориентированному шаблону состояний: преобразования между состояниями больше не инкапсулируются полностью в реализации &lt;code&gt;Post&lt;/code&gt; . Однако наше преимущество в том, что недопустимые состояния теперь невозможны из-за системы типов и проверки типов, которая происходит во время компиляции! Это гарантирует, что определенные ошибки, такие как отображение содержимого неопубликованного сообщения, будут обнаружены до того, как они попадут в рабочую среду.</target>
        </trans-unit>
        <trans-unit id="7c6978553f5d9c2a253b6007e164ab1e1253e787" translate="yes" xml:space="preserve">
          <source>The character represented by this escape</source>
          <target state="translated">Персонаж,представляющий этот побег</target>
        </trans-unit>
        <trans-unit id="444f11cad1e3ea489affb1093e4cfe00aec033b8" translate="yes" xml:space="preserve">
          <source>The character type, &lt;code&gt;char&lt;/code&gt;.</source>
          <target state="translated">Тип символа, &lt;code&gt;char&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a2ab8aadbe1c6203ddb8254dc62679ad2d0d6a50" translate="yes" xml:space="preserve">
          <source>The child inherits from the corresponding parent descriptor.</source>
          <target state="translated">Ребенок наследует от соответствующего родительского дескриптора.</target>
        </trans-unit>
        <trans-unit id="57f64da60a0aae4c7ca65b39d52634b157698777" translate="yes" xml:space="preserve">
          <source>The chunks are array references and do not overlap. If &lt;code&gt;N&lt;/code&gt; does not divide the length of the slice, then the last up to &lt;code&gt;N-1&lt;/code&gt; elements will be omitted and can be retrieved from the &lt;code&gt;remainder&lt;/code&gt; function of the iterator.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="15fa38fbe64a63fe95b52b94271d4ba554613043" translate="yes" xml:space="preserve">
          <source>The chunks are mutable array references and do not overlap. If &lt;code&gt;N&lt;/code&gt; does not divide the length of the slice, then the last up to &lt;code&gt;N-1&lt;/code&gt; elements will be omitted and can be retrieved from the &lt;code&gt;into_remainder&lt;/code&gt; function of the iterator.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="22f36eeee32622c7a505cef344bfce71a990d798" translate="yes" xml:space="preserve">
          <source>The chunks are mutable slices, and do not overlap. If &lt;code&gt;chunk_size&lt;/code&gt; does not divide the length of the slice, then the last chunk will not have length &lt;code&gt;chunk_size&lt;/code&gt;.</source>
          <target state="translated">Эти фрагменты являются изменяемыми фрагментами и не перекрываются. Если &lt;code&gt;chunk_size&lt;/code&gt; не делит длину среза, то последний чанк не будет иметь длину &lt;code&gt;chunk_size&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a56cc46096f73dcb9c3581ef24840c1b8a52d3e3" translate="yes" xml:space="preserve">
          <source>The chunks are mutable slices, and do not overlap. If &lt;code&gt;chunk_size&lt;/code&gt; does not divide the length of the slice, then the last up to &lt;code&gt;chunk_size-1&lt;/code&gt; elements will be omitted and can be retrieved from the &lt;code&gt;into_remainder&lt;/code&gt; function of the iterator.</source>
          <target state="translated">Эти фрагменты являются изменяемыми фрагментами и не перекрываются. Если &lt;code&gt;chunk_size&lt;/code&gt; не делит длину среза, то последние элементы вплоть до &lt;code&gt;chunk_size-1&lt;/code&gt; будут опущены и могут быть извлечены из функции &lt;code&gt;into_remainder&lt;/code&gt; итератора.</target>
        </trans-unit>
        <trans-unit id="b9b82e1f955649f5c987c92e4ad59440a3cb7655" translate="yes" xml:space="preserve">
          <source>The chunks are slices and do not overlap. If &lt;code&gt;chunk_size&lt;/code&gt; does not divide the length of the slice, then the last chunk will not have length &lt;code&gt;chunk_size&lt;/code&gt;.</source>
          <target state="translated">Куски представляют собой кусочки и не перекрываются. Если &lt;code&gt;chunk_size&lt;/code&gt; не делит длину среза, то последний чанк не будет иметь длину &lt;code&gt;chunk_size&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="93ee6025794c31565e33ecdc52225cb4e18501bf" translate="yes" xml:space="preserve">
          <source>The chunks are slices and do not overlap. If &lt;code&gt;chunk_size&lt;/code&gt; does not divide the length of the slice, then the last up to &lt;code&gt;chunk_size-1&lt;/code&gt; elements will be omitted and can be retrieved from the &lt;code&gt;remainder&lt;/code&gt; function of the iterator.</source>
          <target state="translated">Куски представляют собой кусочки и не перекрываются. Если &lt;code&gt;chunk_size&lt;/code&gt; не делит длину среза, то последние элементы вплоть до &lt;code&gt;chunk_size-1&lt;/code&gt; будут опущены и могут быть извлечены из функции &lt;code&gt;remainder&lt;/code&gt; итератора.</target>
        </trans-unit>
        <trans-unit id="5ab8cfd0030cc999866ad155de372dfc9a291653" translate="yes" xml:space="preserve">
          <source>The closure &lt;code&gt;f&lt;/code&gt; is yielded a &lt;a href=&quot;struct.oncestate&quot;&gt;&lt;code&gt;OnceState&lt;/code&gt;&lt;/a&gt; structure which can be used to query the poison status of the &lt;a href=&quot;struct.once&quot;&gt;&lt;code&gt;Once&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8464cb339a91ac7f9edf87e86826287afbdde678" translate="yes" xml:space="preserve">
          <source>The closure &lt;code&gt;f&lt;/code&gt; is yielded a &lt;a href=&quot;struct.oncestate&quot;&gt;&lt;code&gt;OnceState&lt;/code&gt;&lt;/a&gt; structure which can be used to query the poison status of the &lt;code&gt;Once&lt;/code&gt;.</source>
          <target state="translated">Замыкание &lt;code&gt;f&lt;/code&gt; дает структуру &lt;a href=&quot;struct.oncestate&quot;&gt; &lt;code&gt;OnceState&lt;/code&gt; ,&lt;/a&gt; которую можно использовать для запроса статуса яда &lt;code&gt;Once&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6122336d1e3dc25f0e6a48ca5c6617d72884ddeb" translate="yes" xml:space="preserve">
          <source>The closure &lt;code&gt;f&lt;/code&gt; will only be executed once if this is called concurrently amongst many threads. If that closure panics, however, then it will &lt;em&gt;poison&lt;/em&gt; this &lt;a href=&quot;struct.once&quot;&gt;&lt;code&gt;Once&lt;/code&gt;&lt;/a&gt; instance, causing all future invocations of &lt;code&gt;call_once&lt;/code&gt; to also panic.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1151c6060a40c30d933870c684e8f8c1c9ce7a79" translate="yes" xml:space="preserve">
          <source>The closure &lt;code&gt;f&lt;/code&gt; will only be executed once if this is called concurrently amongst many threads. If that closure panics, however, then it will &lt;em&gt;poison&lt;/em&gt; this &lt;code&gt;Once&lt;/code&gt; instance, causing all future invocations of &lt;code&gt;call_once&lt;/code&gt; to also panic.</source>
          <target state="translated">Замыкание &lt;code&gt;f&lt;/code&gt; будет выполнено только один раз, если оно вызывается одновременно из множества потоков. Однако, если это закрытие вызывает панику, оно &lt;em&gt;отравит&lt;/em&gt; этот экземпляр &lt;code&gt;Once&lt;/code&gt; , в результате чего все последующие вызовы &lt;code&gt;call_once&lt;/code&gt; также будут паниковать.</target>
        </trans-unit>
        <trans-unit id="9a9ae7f6f31f6430eeec94354c414e42d745c712" translate="yes" xml:space="preserve">
          <source>The closure can use captures and its environment to track state across iterations. Depending on how the iterator is used, this may require specifying the &lt;a href=&quot;../keyword.move&quot;&gt;&lt;code&gt;move&lt;/code&gt;&lt;/a&gt; keyword on the closure.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cbba645c0f92459c3e584dd2aad4e56b6422ddeb" translate="yes" xml:space="preserve">
          <source>The closure can use captures and its environment to track state across iterations. Depending on how the iterator is used, this may require specifying the &lt;code&gt;move&lt;/code&gt; keyword on the closure.</source>
          <target state="translated">Замыкание может использовать захваты и свою среду для отслеживания состояния в итерациях. В зависимости от того, как используется итератор, может потребоваться указать ключевое слово &lt;code&gt;move&lt;/code&gt; в закрытии.</target>
        </trans-unit>
        <trans-unit id="8e57e2087c6fad9eaa8a18bdb745b2ddd95bd84c" translate="yes" xml:space="preserve">
          <source>The closure captures the &lt;code&gt;shoe_size&lt;/code&gt; parameter from the environment and compares the value with each shoe&amp;rsquo;s size, keeping only shoes of the size specified. Finally, calling &lt;code&gt;collect&lt;/code&gt; gathers the values returned by the adapted iterator into a vector that&amp;rsquo;s returned by the function.</source>
          <target state="translated">Замыкание захватывает параметр &lt;code&gt;shoe_size&lt;/code&gt; из окружающей среды и сравнивает его значение с размером каждой обуви, оставляя только туфли указанного размера. Наконец, вызов &lt;code&gt;collect&lt;/code&gt; собирает значения, возвращаемые адаптированным итератором, в вектор, возвращаемый функцией.</target>
        </trans-unit>
        <trans-unit id="0112db2feb7312ad3c6512257c24783293514225" translate="yes" xml:space="preserve">
          <source>The closure definition comes after the &lt;code&gt;=&lt;/code&gt; to assign it to the variable &lt;code&gt;expensive_closure&lt;/code&gt;. To define a closure, we start with a pair of vertical pipes (&lt;code&gt;|&lt;/code&gt;), inside which we specify the parameters to the closure; this syntax was chosen because of its similarity to closure definitions in Smalltalk and Ruby. This closure has one parameter named &lt;code&gt;num&lt;/code&gt;: if we had more than one parameter, we would separate them with commas, like &lt;code&gt;|param1, param2|&lt;/code&gt;.</source>
          <target state="translated">Определение замыкания идет после &lt;code&gt;=&lt;/code&gt; , чтобы присвоить его переменной &lt;code&gt;expensive_closure&lt;/code&gt; . Чтобы определить замыкание, мы начинаем с пары вертикальных трубок ( &lt;code&gt;|&lt;/code&gt; ), внутри которых мы указываем параметры замыкания; этот синтаксис был выбран из-за его сходства с определениями замыкания в Smalltalk и Ruby. У этого замыкания есть один параметр с именем &lt;code&gt;num&lt;/code&gt; : если бы у нас было несколько параметров, мы бы разделяли их запятыми, например &lt;code&gt;|param1, param2|&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1b467eb6733245bc29dea650b68390c954774c96" translate="yes" xml:space="preserve">
          <source>The closure is allowed to return an I/O error whose OS error code will be communicated back to the parent and returned as an error from when the spawn was requested.</source>
          <target state="translated">Закрытие позволяет вернуть ошибку ввода/вывода,код ошибки операционной системы которой будет возвращен родителю и возвращен как ошибка,начиная с того момента,когда был запрошен нерест.</target>
        </trans-unit>
        <trans-unit id="2d07950c5510607459c97a1e9bf4b42e15a155b7" translate="yes" xml:space="preserve">
          <source>The closure must return &lt;code&gt;true&lt;/code&gt; or &lt;code&gt;false&lt;/code&gt;. &lt;code&gt;filter()&lt;/code&gt; creates an iterator which calls this closure on each element. If the closure returns &lt;code&gt;true&lt;/code&gt;, then the element is returned. If the closure returns &lt;code&gt;false&lt;/code&gt;, it will try again, and call the closure on the next element, seeing if it passes the test.</source>
          <target state="translated">Замыкание должно возвращать &lt;code&gt;true&lt;/code&gt; или &lt;code&gt;false&lt;/code&gt; . &lt;code&gt;filter()&lt;/code&gt; создает итератор, который вызывает это закрытие для каждого элемента. Если замыкание возвращает &lt;code&gt;true&lt;/code&gt; , то элемент возвращается. Если замыкание возвращает &lt;code&gt;false&lt;/code&gt; , он попытается еще раз и вызовет замыкание для следующего элемента, проверяя, проходит ли он проверку.</target>
        </trans-unit>
        <trans-unit id="0dfbb8ddc807c0ec7e308a6bcf0502df62203387" translate="yes" xml:space="preserve">
          <source>The closure must return an &lt;a href=&quot;../option/enum.option&quot;&gt;&lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt;. &lt;code&gt;filter_map&lt;/code&gt; creates an iterator which calls this closure on each element. If the closure returns &lt;a href=&quot;../option/enum.option#variant.Some&quot;&gt;&lt;code&gt;Some(element)&lt;/code&gt;&lt;/a&gt;, then that element is returned. If the closure returns &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt;, it will try again, and call the closure on the next element, seeing if it will return &lt;a href=&quot;../option/enum.option#variant.Some&quot;&gt;&lt;code&gt;Some&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Замыкание должно возвращать &lt;a href=&quot;../option/enum.option&quot;&gt; &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt; &lt;/a&gt; . &lt;code&gt;filter_map&lt;/code&gt; создает итератор, который вызывает это замыкание для каждого элемента. Если замыкание возвращает &lt;a href=&quot;../option/enum.option#variant.Some&quot;&gt; &lt;code&gt;Some(element)&lt;/code&gt; &lt;/a&gt; , то возвращается этот элемент. Если замыкание возвращает &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt; &lt;code&gt;None&lt;/code&gt; &lt;/a&gt; , оно попытается еще раз и вызовет замыкание для следующего элемента, чтобы посмотреть, вернет ли оно &lt;a href=&quot;../option/enum.option#variant.Some&quot;&gt; &lt;code&gt;Some&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="7a4c6af8980cc5834794f8ba584bb6cebd16567c" translate="yes" xml:space="preserve">
          <source>The closure provided is required to adhere to the &lt;a href=&quot;trait.unwindsafe&quot;&gt;&lt;code&gt;UnwindSafe&lt;/code&gt;&lt;/a&gt; trait to ensure that all captured variables are safe to cross this boundary. The purpose of this bound is to encode the concept of &lt;a href=&quot;https://github.com/rust-lang/rfcs/blob/master/text/1236-stabilize-catch-panic.md&quot;&gt;exception safety&lt;/a&gt; in the type system. Most usage of this function should not need to worry about this bound as programs are naturally unwind safe without &lt;code&gt;unsafe&lt;/code&gt; code. If it becomes a problem the &lt;a href=&quot;struct.assertunwindsafe&quot;&gt;&lt;code&gt;AssertUnwindSafe&lt;/code&gt;&lt;/a&gt; wrapper struct can be used to quickly assert that the usage here is indeed unwind safe.</source>
          <target state="translated">Предоставленное закрытие необходимо для соблюдения &lt;a href=&quot;trait.unwindsafe&quot;&gt; &lt;code&gt;UnwindSafe&lt;/code&gt; &lt;/a&gt; чтобы гарантировать, что все захваченные переменные могут безопасно пересечь эту границу. Цель этой привязки - закодировать концепцию &lt;a href=&quot;https://github.com/rust-lang/rfcs/blob/master/text/1236-stabilize-catch-panic.md&quot;&gt;безопасности исключений&lt;/a&gt; в системе типов. В большинстве случаев при использовании этой функции не следует беспокоиться об этом ограничении, поскольку программы, естественно, безопасны при раскручивании без &lt;code&gt;unsafe&lt;/code&gt; кода. Если это становится проблемой, можно использовать структуру оболочки &lt;a href=&quot;struct.assertunwindsafe&quot;&gt; &lt;code&gt;AssertUnwindSafe&lt;/code&gt; ,&lt;/a&gt; чтобы быстро утверждать, что использование здесь действительно безопасно.</target>
        </trans-unit>
        <trans-unit id="1db2515eb35827d3b48808ed11db89506d167098" translate="yes" xml:space="preserve">
          <source>The closure uses &lt;code&gt;v&lt;/code&gt;, so it will capture &lt;code&gt;v&lt;/code&gt; and make it part of the closure&amp;rsquo;s environment. Because &lt;code&gt;thread::spawn&lt;/code&gt; runs this closure in a new thread, we should be able to access &lt;code&gt;v&lt;/code&gt; inside that new thread. But when we compile this example, we get the following error:</source>
          <target state="translated">Замыкание использует &lt;code&gt;v&lt;/code&gt; , поэтому оно захватывает &lt;code&gt;v&lt;/code&gt; и делает его частью среды замыкания. Поскольку &lt;code&gt;thread::spawn&lt;/code&gt; запускает это закрытие в новом потоке, мы должны иметь доступ к &lt;code&gt;v&lt;/code&gt; внутри этого нового потока. Но когда мы компилируем этот пример, мы получаем следующую ошибку:</target>
        </trans-unit>
        <trans-unit id="d7aca11a6ac0f9ea5173acf1c9757981e77e687c" translate="yes" xml:space="preserve">
          <source>The code associated with each arm is an expression, and the resulting value of the expression in the matching arm is the value that gets returned for the entire &lt;code&gt;match&lt;/code&gt; expression.</source>
          <target state="translated">Код , связанный с каждым рычагом является выражением, и полученное значение выражения в согласующей руке этого значение , которое получает возвращается в течение всего &lt;code&gt;match&lt;/code&gt; выражения.</target>
        </trans-unit>
        <trans-unit id="86ec55efa28e5ccc120a1f5241fba708e750dd58" translate="yes" xml:space="preserve">
          <source>The code in Listing 13-17 doesn&amp;rsquo;t do anything; the closure we&amp;rsquo;ve specified never gets called. The warning reminds us why: iterator adaptors are lazy, and we need to consume the iterator here.</source>
          <target state="translated">Код в листинге 13-17 ничего не делает; указанное нами закрытие никогда не вызывается. Предупреждение напоминает нам, почему: адаптеры итератора ленивы, и здесь нам нужно использовать итератор.</target>
        </trans-unit>
        <trans-unit id="27595e3e42c890c6fdee5b82c7f1d2b1399713f0" translate="yes" xml:space="preserve">
          <source>The code in Listing 13-3 has multiple calls to the slow calculation function. The first &lt;code&gt;if&lt;/code&gt; block calls &lt;code&gt;simulated_expensive_calculation&lt;/code&gt; twice, the &lt;code&gt;if&lt;/code&gt; inside the outer &lt;code&gt;else&lt;/code&gt; doesn&amp;rsquo;t call it at all, and the code inside the second &lt;code&gt;else&lt;/code&gt; case calls it once.</source>
          <target state="translated">Код в листинге 13-3 содержит несколько вызовов функции медленных вычислений. Первый блок &lt;code&gt;if&lt;/code&gt; вызывает &lt;code&gt;simulated_expensive_calculation&lt;/code&gt; дважды, &lt;code&gt;if&lt;/code&gt; внутри внешнего &lt;code&gt;else&lt;/code&gt; не вызывает его вообще, а код во втором случае &lt;code&gt;else&lt;/code&gt; вызывает его один раз.</target>
        </trans-unit>
        <trans-unit id="984f7b754ab17440aa0c07b718b002aed1594b7a" translate="yes" xml:space="preserve">
          <source>The code in Listing 16-1 not only stops the spawned thread prematurely most of the time due to the main thread ending, but also can&amp;rsquo;t guarantee that the spawned thread will get to run at all. The reason is that there is no guarantee on the order in which threads run!</source>
          <target state="translated">Код в листинге 16-1 не только в большинстве случаев преждевременно останавливает порожденный поток из-за завершения основного потока, но также не может гарантировать, что порожденный поток вообще будет запущен. Причина в том, что нет никакой гарантии относительно порядка, в котором выполняются потоки!</target>
        </trans-unit>
        <trans-unit id="4d5adfd375cd377b4763e2eeee96a84687acf4e5" translate="yes" xml:space="preserve">
          <source>The code in Listing 16-8 compiled and ran, but it didn&amp;rsquo;t clearly show us that two separate threads were talking to each other over the channel. In Listing 16-10 we&amp;rsquo;ve made some modifications that will prove the code in Listing 16-8 is running concurrently: the spawned thread will now send multiple messages and pause for a second between each message.</source>
          <target state="translated">Код в листинге 16-8 скомпилирован и запущен, но он не показал нам, что два отдельных потока общаются друг с другом по каналу. В листинге 16-10 мы внесли некоторые изменения, которые докажут, что код из листинга 16-8 работает одновременно: теперь порожденный поток будет отправлять несколько сообщений и делать паузу на секунду между каждым сообщением.</target>
        </trans-unit>
        <trans-unit id="9e7e0566bf3de2c83a460b61c17bb70770c4b1c5" translate="yes" xml:space="preserve">
          <source>The code in Listing 18-1 shows a series of checks for several conditions that decide what the background color should be. For this example, we&amp;rsquo;ve created variables with hardcoded values that a real program might receive from user input.</source>
          <target state="translated">Код в Листинге 18-1 показывает серию проверок нескольких условий, которые определяют, каким должен быть цвет фона. В этом примере мы создали переменные с жестко запрограммированными значениями, которые реальная программа может получать от пользовательского ввода.</target>
        </trans-unit>
        <trans-unit id="c12405c78a2c0d83f529e2201871e22f52a8474e" translate="yes" xml:space="preserve">
          <source>The code in Listing 18-3 will print the following:</source>
          <target state="translated">Код в Списке 18-3 напечатает следующее:</target>
        </trans-unit>
        <trans-unit id="efe51698d475c0b9864955b57e12d5b79c9bbf35" translate="yes" xml:space="preserve">
          <source>The code in Listing 20-14 will compile but doesn&amp;rsquo;t create any threads yet. We&amp;rsquo;ve changed the definition of &lt;code&gt;ThreadPool&lt;/code&gt; to hold a vector of &lt;code&gt;thread::JoinHandle&amp;lt;()&amp;gt;&lt;/code&gt; instances, initialized the vector with a capacity of &lt;code&gt;size&lt;/code&gt;, set up a &lt;code&gt;for&lt;/code&gt; loop that will run some code to create the threads, and returned a &lt;code&gt;ThreadPool&lt;/code&gt; instance containing them.</source>
          <target state="translated">Код в листинге 20-14 компилируется, но пока не создает никаких потоков. Мы изменили определение &lt;code&gt;ThreadPool&lt;/code&gt; , чтобы он &lt;code&gt;thread::JoinHandle&amp;lt;()&amp;gt;&lt;/code&gt; вектор экземпляров thread :: JoinHandle &amp;lt;()&amp;gt; , инициализировал вектор с емкостью &lt;code&gt;size&lt;/code&gt; , настроил цикл &lt;code&gt;for&lt;/code&gt; , который будет запускать некоторый код для создания потоков, и вернул Экземпляр &lt;code&gt;ThreadPool&lt;/code&gt; , содержащий их.</target>
        </trans-unit>
        <trans-unit id="d3a6f7dff2487d4bcc7b7e0489bef3c4a5207416" translate="yes" xml:space="preserve">
          <source>The code in Listing 20-20 is responding to requests asynchronously through the use of a thread pool, as we intended. We get some warnings about the &lt;code&gt;workers&lt;/code&gt;, &lt;code&gt;id&lt;/code&gt;, and &lt;code&gt;thread&lt;/code&gt; fields that we&amp;rsquo;re not using in a direct way that reminds us we&amp;rsquo;re not cleaning up anything. When we use the less elegant ctrl-c method to halt the main thread, all other threads are stopped immediately as well, even if they&amp;rsquo;re in the middle of serving a request.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b9b3fdc249a44ebef0cd41734527cea5bbbbc841" translate="yes" xml:space="preserve">
          <source>The code in Listing 20-21 is responding to requests asynchronously through the use of a thread pool, as we intended. We get some warnings about the &lt;code&gt;workers&lt;/code&gt;, &lt;code&gt;id&lt;/code&gt;, and &lt;code&gt;thread&lt;/code&gt; fields that we&amp;rsquo;re not using in a direct way that reminds us we&amp;rsquo;re not cleaning up anything. When we use the less elegant ctrl-c method to halt the main thread, all other threads are stopped immediately as well, even if they&amp;rsquo;re in the middle of serving a request.</source>
          <target state="translated">Код в листинге 20-21 отвечает на запросы асинхронно с использованием пула потоков, как мы и предполагали. Мы получаем некоторые предупреждения о полях &lt;code&gt;workers&lt;/code&gt; , &lt;code&gt;id&lt;/code&gt; и &lt;code&gt;thread&lt;/code&gt; , которые мы не используем напрямую, которые напоминают нам, что мы ничего не очищаем. Когда мы используем менее элегантный метод ctrl-c для остановки основного потока, все остальные потоки также немедленно останавливаются, даже если они находятся в процессе обслуживания запроса.</target>
        </trans-unit>
        <trans-unit id="af00e0657ebb48c72ab0e8023da460e28c0f23c3" translate="yes" xml:space="preserve">
          <source>The code in Listing 5-7 also creates an instance in &lt;code&gt;user2&lt;/code&gt; that has a different value for &lt;code&gt;email&lt;/code&gt; and &lt;code&gt;username&lt;/code&gt; but has the same values for the &lt;code&gt;active&lt;/code&gt; and &lt;code&gt;sign_in_count&lt;/code&gt; fields from &lt;code&gt;user1&lt;/code&gt;.</source>
          <target state="translated">Код в листинге 5-7 также создает экземпляр в &lt;code&gt;user2&lt;/code&gt; , который имеет другое значение для &lt;code&gt;email&lt;/code&gt; и &lt;code&gt;username&lt;/code&gt; но имеет те же значения для полей &lt;code&gt;active&lt;/code&gt; и &lt;code&gt;sign_in_count&lt;/code&gt; из &lt;code&gt;user1&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0531b3f098e465468fd76e222f809f69ed8edfae" translate="yes" xml:space="preserve">
          <source>The code in Listing 8-7 might look like it should work: why should a reference to the first element care about what changes at the end of the vector? This error is due to the way vectors work: adding a new element onto the end of the vector might require allocating new memory and copying the old elements to the new space, if there isn&amp;rsquo;t enough room to put all the elements next to each other where the vector currently is. In that case, the reference to the first element would be pointing to deallocated memory. The borrowing rules prevent programs from ending up in that situation.</source>
          <target state="translated">Код в листинге 8-7 может выглядеть так, как будто он должен работать: почему ссылка на первый элемент должна заботиться о том, какие изменения в конце вектора? Эта ошибка связана с тем, как работают векторы: добавление нового элемента в конец вектора может потребовать выделения новой памяти и копирования старых элементов в новое пространство, если недостаточно места для размещения всех элементов рядом с каждым. другое, где сейчас находится вектор. В этом случае ссылка на первый элемент будет указывать на освобожденную память. Правила заимствования предотвращают попадание программ в такую ​​ситуацию.</target>
        </trans-unit>
        <trans-unit id="94cc2f51904c3f9ddd0cfd3520b820c4eb301ad4" translate="yes" xml:space="preserve">
          <source>The code in Listing 9-4 will &lt;code&gt;panic!&lt;/code&gt; no matter why &lt;code&gt;File::open&lt;/code&gt; failed. What we want to do instead is take different actions for different failure reasons: if &lt;code&gt;File::open&lt;/code&gt; failed because the file doesn&amp;rsquo;t exist, we want to create the file and return the handle to the new file. If &lt;code&gt;File::open&lt;/code&gt; failed for any other reason&amp;mdash;for example, because we didn&amp;rsquo;t have permission to open the file&amp;mdash;we still want the code to &lt;code&gt;panic!&lt;/code&gt; in the same way as it did in Listing 9-4. Look at Listing 9-5, which adds an inner &lt;code&gt;match&lt;/code&gt; expression.</source>
          <target state="translated">Код в листинге 9-4 вызовет &lt;code&gt;panic!&lt;/code&gt; независимо от того, почему &lt;code&gt;File::open&lt;/code&gt; не удалось. Вместо этого мы хотим предпринять разные действия по разным причинам сбоя: если &lt;code&gt;File::open&lt;/code&gt; не удалось, потому что файл не существует, мы хотим создать файл и вернуть дескриптор нового файла. Если &lt;code&gt;File::open&lt;/code&gt; завершился неудачно по какой-либо другой причине - например, из-за того, что у нас не было разрешения на открытие файла - мы все равно хотим, чтобы код &lt;code&gt;panic!&lt;/code&gt; таким же образом, как в листинге 9-4. Посмотрите на листинге 9-5, который добавляет внутренний &lt;code&gt;match&lt;/code&gt; выражение.</target>
        </trans-unit>
        <trans-unit id="e95fa13e369d6a99c35a00c2091e07ffadc180a6" translate="yes" xml:space="preserve">
          <source>The code is trying to pass &lt;code&gt;receiver&lt;/code&gt; to multiple &lt;code&gt;Worker&lt;/code&gt; instances. This won&amp;rsquo;t work, as you&amp;rsquo;ll recall from Chapter 16: the channel implementation that Rust provides is multiple &lt;em&gt;producer&lt;/em&gt;, single &lt;em&gt;consumer&lt;/em&gt;. This means we can&amp;rsquo;t just clone the consuming end of the channel to fix this code. Even if we could, that is not the technique we would want to use; instead, we want to distribute the jobs across threads by sharing the single &lt;code&gt;receiver&lt;/code&gt; among all the workers.</source>
          <target state="translated">Код пытается передать &lt;code&gt;receiver&lt;/code&gt; нескольким экземплярам &lt;code&gt;Worker&lt;/code&gt; . Это не сработает, как вы помните из главы 16: реализация канала, которую предоставляет Rust, - это несколько &lt;em&gt;производителей&lt;/em&gt; , один &lt;em&gt;потребитель&lt;/em&gt; . Это означает, что мы не можем просто клонировать потребляющий конец канала, чтобы исправить этот код. Даже если бы мы могли, это не та техника, которую мы хотели бы использовать; вместо этого мы хотим распределять задания по потокам, разделяя один &lt;code&gt;receiver&lt;/code&gt; между всеми рабочими.</target>
        </trans-unit>
        <trans-unit id="404cdeaf9f9f5734a0b6eb5da98e14aed6b8934d" translate="yes" xml:space="preserve">
          <source>The code refers to a trait that is not in scope.</source>
          <target state="translated">Код относится к признаку,который не входит в область видимости.</target>
        </trans-unit>
        <trans-unit id="f585d5dc0ef34cc30960f293fe10c97e69068fe3" translate="yes" xml:space="preserve">
          <source>The code that calls this code will then handle getting either an &lt;code&gt;Ok&lt;/code&gt; value that contains a username or an &lt;code&gt;Err&lt;/code&gt; value that contains an &lt;code&gt;io::Error&lt;/code&gt;. We don&amp;rsquo;t know what the calling code will do with those values. If the calling code gets an &lt;code&gt;Err&lt;/code&gt; value, it could call &lt;code&gt;panic!&lt;/code&gt; and crash the program, use a default username, or look up the username from somewhere other than a file, for example. We don&amp;rsquo;t have enough information on what the calling code is actually trying to do, so we propagate all the success or error information upward for it to handle appropriately.</source>
          <target state="translated">Затем код, вызывающий этот код, будет обрабатывать получение либо значения &lt;code&gt;Ok&lt;/code&gt; , содержащего имя пользователя, либо значения &lt;code&gt;Err&lt;/code&gt; , содержащего &lt;code&gt;io::Error&lt;/code&gt; . Мы не знаем, что вызывающий код будет делать с этими значениями. Если вызывающий код получает значение &lt;code&gt;Err&lt;/code&gt; , это может вызвать &lt;code&gt;panic!&lt;/code&gt; и завершите работу программы, используйте имя пользователя по умолчанию или найдите имя пользователя, например, не из файла. У нас недостаточно информации о том, что на самом деле пытается сделать вызывающий код, поэтому мы распространяем всю информацию об успехе или ошибке вверх, чтобы он обрабатывался должным образом.</target>
        </trans-unit>
        <trans-unit id="cfac4f190729188f4689af6ae5b0042be7b9afad" translate="yes" xml:space="preserve">
          <source>The collection may reserve more space to avoid frequent reallocations.</source>
          <target state="translated">В коллекции может быть зарезервировано больше места,чтобы избежать частых перераспределений.</target>
        </trans-unit>
        <trans-unit id="a921d34f1378e463d6297235d9b237b6a37c1373" translate="yes" xml:space="preserve">
          <source>The comma following &lt;code&gt;$()&lt;/code&gt; indicates that a literal comma separator character could optionally appear after the code that matches the code in &lt;code&gt;$()&lt;/code&gt;. The &lt;code&gt;*&lt;/code&gt; specifies that the pattern matches zero or more of whatever precedes the &lt;code&gt;*&lt;/code&gt;.</source>
          <target state="translated">Запятая, следующая за &lt;code&gt;$()&lt;/code&gt; указывает, что буквальный символ-разделитель запятой может опционально стоять после кода, который соответствует коду в &lt;code&gt;$()&lt;/code&gt; . В &lt;code&gt;*&lt;/code&gt; указывает , что шаблон соответствует нулю или более независимо предшествует &lt;code&gt;*&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1bacb24582ff767b21e31f4cc1ad3d6012f25a0b" translate="yes" xml:space="preserve">
          <source>The command downloads a script and starts the installation of the &lt;code&gt;rustup&lt;/code&gt; tool, which installs the latest stable version of Rust. You might be prompted for your password. If the install is successful, the following line will appear:</source>
          <target state="translated">Команда загружает сценарий и запускает установку инструмента &lt;code&gt;rustup&lt;/code&gt; , который устанавливает последнюю стабильную версию Rust. Вам может быть предложено ввести пароль. Если установка прошла успешно, появится следующая строка:</target>
        </trans-unit>
        <trans-unit id="73b43b32097905758197f28a5b18a2fd54ae6279" translate="yes" xml:space="preserve">
          <source>The common part of these two paths is &lt;code&gt;std::io&lt;/code&gt;, and that&amp;rsquo;s the complete first path. To merge these two paths into one &lt;code&gt;use&lt;/code&gt; statement, we can use &lt;code&gt;self&lt;/code&gt; in the nested path, as shown in Listing 7-20.</source>
          <target state="translated">Общая часть этих двух путей - это &lt;code&gt;std::io&lt;/code&gt; , и это полный первый путь. Чтобы объединить эти два пути в один оператор &lt;code&gt;use&lt;/code&gt; , мы можем использовать &lt;code&gt;self&lt;/code&gt; во вложенном пути, как показано в листинге 7-20.</target>
        </trans-unit>
        <trans-unit id="3e8778a56f7c16d517be41bfd502f5b861a15290" translate="yes" xml:space="preserve">
          <source>The comparator function must define a total ordering for the elements in the slice. If the ordering is not total, the order of the elements is unspecified. An order is a total order if it is (for all &lt;code&gt;a&lt;/code&gt;, &lt;code&gt;b&lt;/code&gt; and &lt;code&gt;c&lt;/code&gt;):</source>
          <target state="translated">Функция компаратора должна определять общий порядок элементов в срезе. Если порядок не является полным, порядок элементов не указан. Заказ является общим заказом, если он (для всех &lt;code&gt;a&lt;/code&gt; , &lt;code&gt;b&lt;/code&gt; и &lt;code&gt;c&lt;/code&gt; ):</target>
        </trans-unit>
        <trans-unit id="aebc23a2aec802159973c4b13320302322bbb426" translate="yes" xml:space="preserve">
          <source>The comparator function must define a total ordering for the elements in the slice. If the ordering is not total, the order of the elements is unspecified. An order is a total order if it is (for all a, b and c):</source>
          <target state="translated">Функция компаратора должна определить общий порядок заказа элементов на срезе.Если заказ не является полным,то порядок элементов не указывается.Порядок является суммарным,если он есть (для всех a,b и c):</target>
        </trans-unit>
        <trans-unit id="92ccf3fc61c0a63453fa6ca42d0beca2274f875f" translate="yes" xml:space="preserve">
          <source>The comparator function should implement an order consistent with the sort order of the underlying slice, returning an order code that indicates whether its argument is &lt;code&gt;Less&lt;/code&gt;, &lt;code&gt;Equal&lt;/code&gt; or &lt;code&gt;Greater&lt;/code&gt; the desired target.</source>
          <target state="translated">Функция компаратора должна реализовывать порядок, согласованный с порядком сортировки нижележащего среза, возвращая код заказа, который указывает, является ли его аргумент &lt;code&gt;Less&lt;/code&gt; , &lt;code&gt;Equal&lt;/code&gt; или &lt;code&gt;Greater&lt;/code&gt; желаемой цели.</target>
        </trans-unit>
        <trans-unit id="45e688bbffc9733765a7b6aca03992e2d5e377a5" translate="yes" xml:space="preserve">
          <source>The comparison must satisfy, for all &lt;code&gt;a&lt;/code&gt;, &lt;code&gt;b&lt;/code&gt; and &lt;code&gt;c&lt;/code&gt;:</source>
          <target state="translated">Сравнение должно удовлетворять для всех &lt;code&gt;a&lt;/code&gt; , &lt;code&gt;b&lt;/code&gt; и &lt;code&gt;c&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="0c2765074489dd525efeb165a25dbc97454a652e" translate="yes" xml:space="preserve">
          <source>The compilation didn&amp;rsquo;t produce any errors, but the program resulted in a &lt;em&gt;runtime&lt;/em&gt; error and didn&amp;rsquo;t exit successfully. When you attempt to access an element using indexing, Rust will check that the index you&amp;rsquo;ve specified is less than the array length. If the index is greater than or equal to the array length, Rust will panic.</source>
          <target state="translated">Компиляция не вызвала никаких ошибок, но программа вызвала ошибку &lt;em&gt;времени выполнения&lt;/em&gt; и не завершилась успешно. Когда вы пытаетесь получить доступ к элементу с помощью индексации, Rust проверяет, что указанный вами индекс меньше длины массива. Если индекс больше или равен длине массива, Rust запаникует.</target>
        </trans-unit>
        <trans-unit id="0a0cf1febd61e4c4aeb0165c7c721394953162c8" translate="yes" xml:space="preserve">
          <source>The compilation model centers on artifacts called &lt;em&gt;crates&lt;/em&gt;. Each compilation processes a single crate in source form, and if successful, produces a single crate in binary form: either an executable or some sort of library.&lt;sup&gt;&lt;a href=&quot;#cratesourcefile&quot;&gt;2&lt;/a&gt;&lt;/sup&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="25f0592827e30de97cacdd81a110584696dcea70" translate="yes" xml:space="preserve">
          <source>The compilation model centers on artifacts called &lt;em&gt;crates&lt;/em&gt;. Each compilation processes a single crate in source form, and if successful, produces a single crate in binary form: either an executable or some sort of library.&lt;sup&gt;&lt;a href=&quot;crates-and-source-files#cratesourcefile&quot;&gt;2&lt;/a&gt;&lt;/sup&gt;</source>
          <target state="translated">Модель компиляции основана на артефактах, называемых &lt;em&gt;ящиками&lt;/em&gt; . Каждая компиляция обрабатывает один ящик в исходной форме и в случае успеха создает один ящик в двоичной форме: либо исполняемый файл, либо какую-то библиотеку. &lt;sup&gt;&lt;a href=&quot;crates-and-source-files#cratesourcefile&quot;&gt;2&lt;/a&gt;&lt;/sup&gt;</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
