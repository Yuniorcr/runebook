<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ru" datatype="htmlbody" original="rust">
    <body>
      <group id="rust">
        <trans-unit id="6f91f22939adae86de60c33d3fdb16972e0fb724" translate="yes" xml:space="preserve">
          <source>Accessing data in the heap is slower than accessing data on the stack because you have to follow a pointer to get there. Contemporary processors are faster if they jump around less in memory. Continuing the analogy, consider a server at a restaurant taking orders from many tables. It&amp;rsquo;s most efficient to get all the orders at one table before moving on to the next table. Taking an order from table A, then an order from table B, then one from A again, and then one from B again would be a much slower process. By the same token, a processor can do its job better if it works on data that&amp;rsquo;s close to other data (as it is on the stack) rather than farther away (as it can be on the heap). Allocating a large amount of space on the heap can also take time.</source>
          <target state="translated">Доступ к данным в куче происходит медленнее, чем доступ к данным в стеке, потому что вам нужно следовать указателю, чтобы попасть туда. Современные процессоры быстрее, если они меньше прыгают в памяти. Продолжая аналогию, представьте, что официант в ресторане принимает заказы со многих столиков. Наиболее эффективно собрать все заказы за одним столом, прежде чем переходить к следующему столу. Принятие заказа из таблицы A, затем заказа из таблицы B, затем снова из A, а затем снова из B, будет гораздо более медленным процессом. Точно так же процессор может лучше выполнять свою работу, если он работает с данными, близкими к другим данным (как они находятся в стеке), а не дальше (как это может быть в куче). Выделение большого количества места в куче также может занять время.</target>
        </trans-unit>
        <trans-unit id="f239f31c4b24ce084fa39af1811c8d4fc4e10b36" translate="yes" xml:space="preserve">
          <source>Accessing non-&lt;a href=&quot;keyword.mut&quot;&gt;&lt;code&gt;mut&lt;/code&gt;&lt;/a&gt;&lt;code&gt;static&lt;/code&gt; items is considered safe, but some restrictions apply. Most notably, the type of a &lt;code&gt;static&lt;/code&gt; value needs to implement the &lt;a href=&quot;marker/trait.sync&quot;&gt;&lt;code&gt;Sync&lt;/code&gt;&lt;/a&gt; trait, ruling out interior mutability containers like &lt;a href=&quot;cell/struct.refcell&quot;&gt;&lt;code&gt;RefCell&lt;/code&gt;&lt;/a&gt;. See the &lt;a href=&quot;../reference/items/static-items&quot;&gt;Reference&lt;/a&gt; for more information.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c20e5fc2ccd1b37aea7b882c463d596e55833b83" translate="yes" xml:space="preserve">
          <source>Accessing or Modifying a Mutable Static Variable</source>
          <target state="translated">Доступ к переменной статического электричества или ее изменение</target>
        </trans-unit>
        <trans-unit id="f13080b643bf72eee286858a8d7c3ab06b544915" translate="yes" xml:space="preserve">
          <source>Accessing unaligned fields directly with e.g. &lt;code&gt;packed.unaligned&lt;/code&gt; is safe however.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="12a3a4f498b28cbec01c44aacf0dc5e3a1b828ef" translate="yes" xml:space="preserve">
          <source>Accuracy</source>
          <target state="translated">Accuracy</target>
        </trans-unit>
        <trans-unit id="edc1ea5ed2dafd896f3493beb6ccad4cc0bfdeb7" translate="yes" xml:space="preserve">
          <source>Accurately documenting your packages will help other users know how and when to use them, so it&amp;rsquo;s worth investing the time to write documentation. In Chapter 3, we discussed how to comment Rust code using two slashes, &lt;code&gt;//&lt;/code&gt;. Rust also has a particular kind of comment for documentation, known conveniently as a &lt;em&gt;documentation comment&lt;/em&gt;, that will generate HTML documentation. The HTML displays the contents of documentation comments for public API items intended for programmers interested in knowing how to &lt;em&gt;use&lt;/em&gt; your crate as opposed to how your crate is &lt;em&gt;implemented&lt;/em&gt;.</source>
          <target state="translated">Точное документирование ваших пакетов поможет другим пользователям узнать, как и когда их использовать, поэтому стоит потратить время на написание документации. В главе 3 мы обсудили, как комментировать код Rust с помощью двух слэшей &lt;code&gt;//&lt;/code&gt; . В Rust также есть особый вид комментариев к документации, известный как &lt;em&gt;комментарий документации&lt;/em&gt; , который генерирует документацию HTML. HTML отображает содержимое комментариев к документации для общедоступных элементов API, предназначенных для программистов, заинтересованных в том, чтобы знать, как &lt;em&gt;использовать&lt;/em&gt; ваш ящик, в отличие от того, как ваш ящик &lt;em&gt;реализован&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="e550137a8ad5bf001d7b174a7d5416351ea9a342" translate="yes" xml:space="preserve">
          <source>AcqRel</source>
          <target state="translated">AcqRel</target>
        </trans-unit>
        <trans-unit id="9d0903a32f177d84829c27dd98a7a4772b87dcc5" translate="yes" xml:space="preserve">
          <source>Acquire</source>
          <target state="translated">Acquire</target>
        </trans-unit>
        <trans-unit id="6568c1be017add88e3d012e02f41ac58f3e66045" translate="yes" xml:space="preserve">
          <source>Acquire - a barrier for acquiring a lock. Subsequent reads and writes take place after the barrier.</source>
          <target state="translated">Приобрести-барьер для приобретения замка.Последующие чтения и записи происходят после барьера.</target>
        </trans-unit>
        <trans-unit id="af0f8ed1129c9ddf2134ed1c81b67a9bcb444f5a" translate="yes" xml:space="preserve">
          <source>Acquires a mutable reference to the owned form of the data.</source>
          <target state="translated">Приобретает изменяемую ссылку на форму данных,находящихся в собственности.</target>
        </trans-unit>
        <trans-unit id="ff3bc67bc303cd10ada41c07bb7edfd939dc9318" translate="yes" xml:space="preserve">
          <source>Acquires a mutex, blocking the current thread until it is able to do so.</source>
          <target state="translated">Приобретает мьютекс,блокируя текущую резьбу до тех пор,пока он не сможет это сделать.</target>
        </trans-unit>
        <trans-unit id="220a887115abad65ad7317817bfb97307bde3f84" translate="yes" xml:space="preserve">
          <source>Acquires a reference to the value in this TLS key.</source>
          <target state="translated">Получает ссылку на значение в этой клавише TLS.</target>
        </trans-unit>
        <trans-unit id="b36ce9a1808b77b91f2783ae64622ebad2a9cac9" translate="yes" xml:space="preserve">
          <source>Acquires the underlying &lt;code&gt;*mut&lt;/code&gt; pointer.</source>
          <target state="translated">Получает базовый указатель &lt;code&gt;*mut&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d4158950a66bbaeb08dff05a2933261e57fba1be" translate="yes" xml:space="preserve">
          <source>Acquiring the path of the current executable is a platform-specific operation that can fail for a good number of reasons. Some errors can include, but not be limited to, filesystem operations failing or general syscall failures.</source>
          <target state="translated">Получение пути к текущему исполняемому файлу является специфической для данной платформы операцией,которая может не сработать по целому ряду причин.Некоторые ошибки могут включать,но не ограничиваться,сбой в работе файловой системы или общий отказ системного интерфейса.</target>
        </trans-unit>
        <trans-unit id="6d8f12c840c97a885d954c4ab3f89cfe39b2655d" translate="yes" xml:space="preserve">
          <source>Active and inert attributes</source>
          <target state="translated">Активные и инертные атрибуты</target>
        </trans-unit>
        <trans-unit id="e07a4acdd5cdd3ab645fd0d90270662d13ac1718" translate="yes" xml:space="preserve">
          <source>Adapters</source>
          <target state="translated">Adapters</target>
        </trans-unit>
        <trans-unit id="876182ad9012a6c08f789f1f68ad82ee5e8c99b7" translate="yes" xml:space="preserve">
          <source>Adaptor to chain together two readers.</source>
          <target state="translated">Адаптер для соединения двух считывающих устройств.</target>
        </trans-unit>
        <trans-unit id="61cc55aa0453184734c3fa0b621eda6fa874bd83" translate="yes" xml:space="preserve">
          <source>Add</source>
          <target state="translated">Add</target>
        </trans-unit>
        <trans-unit id="5377ba24487df148115875083e9ad3100b466293" translate="yes" xml:space="preserve">
          <source>Add &lt;code&gt;'static&lt;/code&gt; requirement to fix them:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ca240252f7070cde72a7b776f50be32f04f2fc0d" translate="yes" xml:space="preserve">
          <source>Add a &lt;code&gt;reject&lt;/code&gt; method that changes the post&amp;rsquo;s state from &lt;code&gt;PendingReview&lt;/code&gt; back to &lt;code&gt;Draft&lt;/code&gt;.</source>
          <target state="translated">Добавьте метод &lt;code&gt;reject&lt;/code&gt; который изменяет состояние сообщения с &lt;code&gt;PendingReview&lt;/code&gt; обратно на &lt;code&gt;Draft&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a0a1e3ef1e8493d789dbbf3d73ecb2a795cba8db" translate="yes" xml:space="preserve">
          <source>Add a description that is just a sentence or two, because it will appear with your crate in search results. For the &lt;code&gt;license&lt;/code&gt; field, you need to give a &lt;em&gt;license identifier value&lt;/em&gt;. The &lt;a href=&quot;http://spdx.org/licenses/&quot;&gt;Linux Foundation&amp;rsquo;s Software Package Data Exchange (SPDX)&lt;/a&gt; lists the identifiers you can use for this value. For example, to specify that you&amp;rsquo;ve licensed your crate using the MIT License, add the &lt;code&gt;MIT&lt;/code&gt; identifier:</source>
          <target state="translated">Добавьте описание, состоящее из одного или двух предложений, потому что оно будет отображаться вместе с вашим ящиком в результатах поиска. Для поля &lt;code&gt;license&lt;/code&gt; вам необходимо &lt;em&gt;указать значение идентификатора лицензии&lt;/em&gt; . В &lt;a href=&quot;http://spdx.org/licenses/&quot;&gt;пакет программного обеспечения обмена данными Linux фонда (SPDX)&lt;/a&gt; перечислены идентификаторы , которые можно использовать для этого значения. Например, чтобы указать, что вы лицензировали свой ящик с использованием лицензии MIT, добавьте идентификатор &lt;code&gt;MIT&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="da701486edb0442db89b592a10ae443b6f2f41f8" translate="yes" xml:space="preserve">
          <source>Add a description that is just a sentence or two, because it will appear with your crate in search results. For the &lt;code&gt;license&lt;/code&gt; field, you need to give a &lt;em&gt;license identifier value&lt;/em&gt;. The &lt;a href=&quot;https://spdx.org/licenses/&quot;&gt;Linux Foundation&amp;rsquo;s Software Package Data Exchange (SPDX)&lt;/a&gt; lists the identifiers you can use for this value. For example, to specify that you&amp;rsquo;ve licensed your crate using the MIT License, add the &lt;code&gt;MIT&lt;/code&gt; identifier:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c8594387539a0f2f7158c8875d4643cbc796d8e9" translate="yes" xml:space="preserve">
          <source>Add a getter function:</source>
          <target state="translated">Добавить функцию геттера:</target>
        </trans-unit>
        <trans-unit id="c563aa838f46cc2ef90bbf765435b526485acbf0" translate="yes" xml:space="preserve">
          <source>Add constraints that must be upheld to use an item.</source>
          <target state="translated">Добавьте ограничения,которые должны быть сохранены,чтобы использовать элемент.</target>
        </trans-unit>
        <trans-unit id="0246ebd27a992d5a543dfa759b31edd44f7a3c51" translate="yes" xml:space="preserve">
          <source>Add credentials to the ancillary data.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="290a7219146772de857baff40ff966c8c90e0f42" translate="yes" xml:space="preserve">
          <source>Add file descriptors to the ancillary data.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="32aaebe9976898d3881c1a85d7d471c975e08486" translate="yes" xml:space="preserve">
          <source>Add more documentation to &lt;code&gt;ThreadPool&lt;/code&gt; and its public methods.</source>
          <target state="translated">Добавьте дополнительную документацию в &lt;code&gt;ThreadPool&lt;/code&gt; и его общедоступные методы.</target>
        </trans-unit>
        <trans-unit id="eac54db7026ed63754bb1e0481266ad4560b6f6c" translate="yes" xml:space="preserve">
          <source>Add tests of the library&amp;rsquo;s functionality.</source>
          <target state="translated">Добавьте тесты функциональности библиотеки.</target>
        </trans-unit>
        <trans-unit id="584510db3cf556aee671c49783907c6c03f2abe4" translate="yes" xml:space="preserve">
          <source>Add the size of the field.</source>
          <target state="translated">Добавьте размер поля.</target>
        </trans-unit>
        <trans-unit id="e0ef2ba9581371a273c725b4584816d08df6e970" translate="yes" xml:space="preserve">
          <source>Add::add</source>
          <target state="translated">Add::add</target>
        </trans-unit>
        <trans-unit id="bd166591010a18220168b51497b0b5e84b157433" translate="yes" xml:space="preserve">
          <source>AddAssign</source>
          <target state="translated">AddAssign</target>
        </trans-unit>
        <trans-unit id="6eecef84103332763bac0f11d9776217926be6a9" translate="yes" xml:space="preserve">
          <source>AddAssign::add_assign</source>
          <target state="translated">AddAssign::add_assign</target>
        </trans-unit>
        <trans-unit id="47bc308a358cb72c871f66d0703a1751fa8c3e13" translate="yes" xml:space="preserve">
          <source>Adding &lt;code&gt;rand&lt;/code&gt; as a dependency in &lt;em&gt;Cargo.toml&lt;/em&gt; tells Cargo to download the &lt;code&gt;rand&lt;/code&gt; package and any dependencies from &lt;a href=&quot;https://crates.io/&quot;&gt;crates.io&lt;/a&gt; and make &lt;code&gt;rand&lt;/code&gt; available to our project.</source>
          <target state="translated">Добавление &lt;code&gt;rand&lt;/code&gt; в качестве зависимости в &lt;em&gt;Cargo.toml&lt;/em&gt; сообщает Cargo, что нужно загрузить пакет &lt;code&gt;rand&lt;/code&gt; и любые зависимости из &lt;a href=&quot;https://crates.io/&quot;&gt;crates.io&lt;/a&gt; и сделать &lt;code&gt;rand&lt;/code&gt; доступным для нашего проекта.</target>
        </trans-unit>
        <trans-unit id="6951b086bf1e29a4acfdba85666aa713fe81534c" translate="yes" xml:space="preserve">
          <source>Adding &lt;code&gt;use&lt;/code&gt; and a path in a scope is similar to creating a symbolic link in the filesystem. By adding &lt;code&gt;use crate::front_of_house::hosting&lt;/code&gt; in the crate root, &lt;code&gt;hosting&lt;/code&gt; is now a valid name in that scope, just as though the &lt;code&gt;hosting&lt;/code&gt; module had been defined in the crate root. Paths brought into scope with &lt;code&gt;use&lt;/code&gt; also check privacy, like any other paths.</source>
          <target state="translated">Добавление &lt;code&gt;use&lt;/code&gt; и пути в область действия аналогично созданию символической ссылки в файловой системе. Добавив &lt;code&gt;use crate::front_of_house::hosting&lt;/code&gt; в корень ящика, &lt;code&gt;hosting&lt;/code&gt; теперь является допустимым именем в этой области, как если бы модуль &lt;code&gt;hosting&lt;/code&gt; был определен в корне ящика. Пути, попавшие в область действия с &lt;code&gt;use&lt;/code&gt; также проверяют конфиденциальность, как и любые другие пути.</target>
        </trans-unit>
        <trans-unit id="311633e0da4d8767a76b5d94813ce0272b9cb8a9" translate="yes" xml:space="preserve">
          <source>Adding Custom Failure Messages</source>
          <target state="translated">Добавление пользовательских сообщений о сбоях</target>
        </trans-unit>
        <trans-unit id="eb99698d7e26927ef9425258511b7fbda34cd647" translate="yes" xml:space="preserve">
          <source>Adding Metadata to a New Crate</source>
          <target state="translated">Добавление метаданных к новому тарифу</target>
        </trans-unit>
        <trans-unit id="6ff96d15a4dfd75cd1b39329a2970688120a37e4" translate="yes" xml:space="preserve">
          <source>Adding Useful Functionality with Derived Traits</source>
          <target state="translated">Добавление полезной функциональности с производными признаками</target>
        </trans-unit>
        <trans-unit id="b2524eeb321c4f1026793239c00d8c1b31c32e31" translate="yes" xml:space="preserve">
          <source>Adding a &lt;code&gt;PhantomData&amp;lt;T&amp;gt;&lt;/code&gt; field to your type tells the compiler that your type acts as though it stores a value of type &lt;code&gt;T&lt;/code&gt;, even though it doesn't really. This information is used when computing certain safety properties.</source>
          <target state="translated">Добавление &lt;code&gt;PhantomData&amp;lt;T&amp;gt;&lt;/code&gt; к вашему типу сообщает компилятору, что ваш тип действует так, как если бы он хранит значение типа &lt;code&gt;T&lt;/code&gt; , хотя на самом деле это не так. Эта информация используется при вычислении определенных характеристик безопасности.</target>
        </trans-unit>
        <trans-unit id="b87a48eb56569132271d6219a87c7a5229e982a0" translate="yes" xml:space="preserve">
          <source>Adding a &lt;code&gt;Self: Sized&lt;/code&gt; bound to these methods will generally make this compile.</source>
          <target state="translated">Добавление &lt;code&gt;Self: Sized&lt;/code&gt; привязанного к этим методам, обычно приводит к компиляции.</target>
        </trans-unit>
        <trans-unit id="88b9f27e251e16ee893bec092535b944c26b4aa9" translate="yes" xml:space="preserve">
          <source>Adding a Reference from a Child to Its Parent</source>
          <target state="translated">Добавление справки от ребенка к его родителю.</target>
        </trans-unit>
        <trans-unit id="23ab42376e070f08194bffa94071c8449a58479a" translate="yes" xml:space="preserve">
          <source>Adding a Test to a Workspace</source>
          <target state="translated">Добавление теста в рабочую область</target>
        </trans-unit>
        <trans-unit id="fd0c9f4d15902bc297e9dbf8af8d2743194e970b" translate="yes" xml:space="preserve">
          <source>Adding a field of type &lt;code&gt;PhantomData&amp;lt;T&amp;gt;&lt;/code&gt; indicates that your type owns data of type &lt;code&gt;T&lt;/code&gt;. This in turn implies that when your type is dropped, it may drop one or more instances of the type &lt;code&gt;T&lt;/code&gt;. This has bearing on the Rust compiler's &lt;a href=&quot;https://doc.rust-lang.org/nomicon/dropck.html&quot;&gt;drop check&lt;/a&gt; analysis.</source>
          <target state="translated">Добавление поля типа &lt;code&gt;PhantomData&amp;lt;T&amp;gt;&lt;/code&gt; указывает на то, что ваш тип имеет данные типа &lt;code&gt;T&lt;/code&gt; . Это , в свою очередь , означает , что , когда ваш тип отбрасывается, он может упасть один или несколько экземпляров типа &lt;code&gt;T&lt;/code&gt; . Это имеет отношение к анализу &lt;a href=&quot;https://doc.rust-lang.org/nomicon/dropck.html&quot;&gt;проверки падения&lt;/a&gt; компилятора Rust .</target>
        </trans-unit>
        <trans-unit id="2e98bb73927df33c08944823ebcc88b767156500" translate="yes" xml:space="preserve">
          <source>Adding example code blocks in your documentation comments can help demonstrate how to use your library, and doing so has an additional bonus: running &lt;code&gt;cargo test&lt;/code&gt; will run the code examples in your documentation as tests! Nothing is better than documentation with examples. But nothing is worse than examples that don&amp;rsquo;t work because the code has changed since the documentation was written. If we run &lt;code&gt;cargo test&lt;/code&gt; with the documentation for the &lt;code&gt;add_one&lt;/code&gt; function from Listing 14-1, we will see a section in the test results like this:</source>
          <target state="translated">Добавление блоков примеров кода в комментарии к документации может помочь продемонстрировать, как использовать вашу библиотеку, и это дает дополнительный бонус: при запуске &lt;code&gt;cargo test&lt;/code&gt; примеры кода из вашей документации будут запускаться как тесты! Нет ничего лучше документации с примерами. Но нет ничего хуже, чем примеры, которые не работают, потому что код изменился с момента написания документации. Если мы запустим &lt;code&gt;cargo test&lt;/code&gt; с документацией для функции &lt;code&gt;add_one&lt;/code&gt; из Листинга 14-1, мы увидим в результатах теста такой раздел:</target>
        </trans-unit>
        <trans-unit id="ceb9b506f927db7479477e625a150623510cf2aa" translate="yes" xml:space="preserve">
          <source>Adding the &lt;code id=&quot;adding-the-approve-method-that-changes-the-behavior-of-content&quot;&gt;approve&lt;/code&gt; Method that Changes the Behavior of &lt;code&gt;content&lt;/code&gt;</source>
          <target state="translated">Добавление метода &lt;code id=&quot;adding-the-approve-method-that-changes-the-behavior-of-content&quot;&gt;approve&lt;/code&gt; , изменяющего поведение &lt;code&gt;content&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="718d273106ffd821ac0c7d93c2d34d8556d7365d" translate="yes" xml:space="preserve">
          <source>Adding the &lt;code&gt;break&lt;/code&gt; line after &lt;code&gt;You win!&lt;/code&gt; makes the program exit the loop when the user guesses the secret number correctly. Exiting the loop also means exiting the program, because the loop is the last part of &lt;code&gt;main&lt;/code&gt;.</source>
          <target state="translated">Добавление линии &lt;code&gt;break&lt;/code&gt; после &lt;code&gt;You win!&lt;/code&gt; заставляет программу выйти из цикла, когда пользователь правильно угадает секретный номер. Выход из цикла также означает выход из программы, потому что цикл является последней частью &lt;code&gt;main&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="097cf74b7fb2e319a4766446302ea478dcd635f5" translate="yes" xml:space="preserve">
          <source>Adding the &lt;code&gt;mut&lt;/code&gt; keyword dereferences a mutable reference. The mutability must match the mutability of the reference.</source>
          <target state="translated">Добавление ключевого слова &lt;code&gt;mut&lt;/code&gt; разыменовывает изменяемую ссылку. Изменчивость должна соответствовать изменчивости ссылки.</target>
        </trans-unit>
        <trans-unit id="8e8428e85c661f03dd33db8f12b20a010ab5be5e" translate="yes" xml:space="preserve">
          <source>Addition</source>
          <target state="translated">Addition</target>
        </trans-unit>
        <trans-unit id="c8217392646c4b940c031f95cbb65a4bfa731556" translate="yes" xml:space="preserve">
          <source>Addition assignment</source>
          <target state="translated">Назначение добавок</target>
        </trans-unit>
        <trans-unit id="b078f9f7ba47f896a06212df108079bcbb1553ff" translate="yes" xml:space="preserve">
          <source>Additional functionality for numerics.</source>
          <target state="translated">Дополнительный функционал для работы с цифрами.</target>
        </trans-unit>
        <trans-unit id="2ffc443f11be980490aef62083275ee8c11f674b" translate="yes" xml:space="preserve">
          <source>Additional implementors</source>
          <target state="translated">Дополнительные исполнители</target>
        </trans-unit>
        <trans-unit id="911a0b354b810ade1b41221cd419095a4767144e" translate="yes" xml:space="preserve">
          <source>Additional information</source>
          <target state="translated">Дополнительная информация</target>
        </trans-unit>
        <trans-unit id="0c05d0c23b9a6f9971368dd97467c0d0e294ca18" translate="yes" xml:space="preserve">
          <source>Additional parameters passed to &lt;code&gt;format!&lt;/code&gt; replace the &lt;code&gt;{}&lt;/code&gt;s within the formatting string in the order given unless named or positional parameters are used; see &lt;a href=&quot;fmt/index&quot;&gt;&lt;code&gt;std::fmt&lt;/code&gt;&lt;/a&gt; for more information.</source>
          <target state="translated">В &lt;code&gt;format!&lt;/code&gt; переданы дополнительные параметры ! замените &lt;code&gt;{}&lt;/code&gt; в строке форматирования в указанном порядке, если не используются именованные или позиционные параметры; см. &lt;a href=&quot;fmt/index&quot;&gt; &lt;code&gt;std::fmt&lt;/code&gt; &lt;/a&gt; для получения дополнительной информации.</target>
        </trans-unit>
        <trans-unit id="b89443b71b82e921f27bf8622eec75e5bb710e5e" translate="yes" xml:space="preserve">
          <source>Additional parameters passed to &lt;code&gt;format!&lt;/code&gt; replace the &lt;code&gt;{}&lt;/code&gt;s within the formatting string in the order given unless named or positional parameters are used; see &lt;a href=&quot;https://doc.rust-lang.org/core/fmt/index.html&quot;&gt;&lt;code&gt;std::fmt&lt;/code&gt;&lt;/a&gt; for more information.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f5cf45e8eb3455f9aeaa5f7fa4c013c3116744f0" translate="yes" xml:space="preserve">
          <source>Additionally, &lt;code&gt;f32&lt;/code&gt; can represent a couple of special values:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dc3992de92a20dddf33d6770f13a67c41e82f34f" translate="yes" xml:space="preserve">
          <source>Additionally, a type &lt;code&gt;Foo&amp;lt;T&amp;gt;&lt;/code&gt; can implement &lt;code&gt;CoerceUnsized&amp;lt;Foo&amp;lt;U&amp;gt;&amp;gt;&lt;/code&gt; when &lt;code&gt;T&lt;/code&gt; implements &lt;code&gt;Unsize&amp;lt;U&amp;gt;&lt;/code&gt; or &lt;code&gt;CoerceUnsized&amp;lt;Foo&amp;lt;U&amp;gt;&amp;gt;&lt;/code&gt;. This allows it to provide a unsized coercion to &lt;code&gt;Foo&amp;lt;U&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">Кроме того, тип &lt;code&gt;Foo&amp;lt;T&amp;gt;&lt;/code&gt; может реализовывать &lt;code&gt;CoerceUnsized&amp;lt;Foo&amp;lt;U&amp;gt;&amp;gt;&lt;/code&gt; когда &lt;code&gt;T&lt;/code&gt; реализует &lt;code&gt;Unsize&amp;lt;U&amp;gt;&lt;/code&gt; или &lt;code&gt;CoerceUnsized&amp;lt;Foo&amp;lt;U&amp;gt;&amp;gt;&lt;/code&gt; . Это позволяет ему предоставлять некорректное приведение к &lt;code&gt;Foo&amp;lt;U&amp;gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="30e7a03e650ce2c7f3e6f58657d0e770d7ebbede" translate="yes" xml:space="preserve">
          <source>Additionally, even though &lt;code&gt;$crate&lt;/code&gt; allows a macro to refer to items within its own crate when expanding, its use has no effect on visibility. An item or macro referred to must still be visible from the invocation site. In the following example, any attempt to invoke &lt;code&gt;call_foo!()&lt;/code&gt; from outside its crate will fail because &lt;code&gt;foo()&lt;/code&gt; is not public.</source>
          <target state="translated">Кроме того, хотя &lt;code&gt;$crate&lt;/code&gt; позволяет макросу ссылаться на элементы в его собственном ящике при расширении, его использование не влияет на видимость. Упомянутый элемент или макрос должен быть видимым с сайта вызова. В следующем примере любая попытка вызвать &lt;code&gt;call_foo!()&lt;/code&gt; Из-за пределов своего ящика потерпит неудачу, потому что &lt;code&gt;foo()&lt;/code&gt; не является общедоступным.</target>
        </trans-unit>
        <trans-unit id="8bd65ffd560b03ecf2792061831bdc28c657f4f7" translate="yes" xml:space="preserve">
          <source>Additionally, if &lt;code&gt;T&lt;/code&gt; is not &lt;a href=&quot;../marker/trait.copy&quot;&gt;&lt;code&gt;Copy&lt;/code&gt;&lt;/a&gt;, using the pointed-to value after calling &lt;code&gt;drop_in_place&lt;/code&gt; can cause undefined behavior. Note that &lt;code&gt;*to_drop = foo&lt;/code&gt; counts as a use because it will cause the value to be dropped again. &lt;a href=&quot;../ptr/fn.write&quot;&gt;&lt;code&gt;write()&lt;/code&gt;&lt;/a&gt; can be used to overwrite data without causing it to be dropped.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="45cbb93035ac4b5290adcbd441c337adab3295a5" translate="yes" xml:space="preserve">
          <source>Additionally, if &lt;code&gt;T&lt;/code&gt; is not &lt;a href=&quot;../marker/trait.copy&quot;&gt;&lt;code&gt;Copy&lt;/code&gt;&lt;/a&gt;, using the pointed-to value after calling &lt;code&gt;drop_in_place&lt;/code&gt; can cause undefined behavior. Note that &lt;code&gt;*to_drop = foo&lt;/code&gt; counts as a use because it will cause the value to be dropped again. &lt;a href=&quot;../ptr/fn.write&quot;&gt;&lt;code&gt;write&lt;/code&gt;&lt;/a&gt; can be used to overwrite data without causing it to be dropped.</source>
          <target state="translated">Кроме того, если &lt;code&gt;T&lt;/code&gt; не &lt;a href=&quot;../marker/trait.copy&quot;&gt; &lt;code&gt;Copy&lt;/code&gt; &lt;/a&gt; , использование указанного значения после вызова &lt;code&gt;drop_in_place&lt;/code&gt; может привести к неопределенному поведению. Обратите внимание, что &lt;code&gt;*to_drop = foo&lt;/code&gt; считается использованием, потому что это приведет к повторному удалению значения. &lt;a href=&quot;../ptr/fn.write&quot;&gt; &lt;code&gt;write&lt;/code&gt; &lt;/a&gt; можно использовать для перезаписи данных без их удаления.</target>
        </trans-unit>
        <trans-unit id="4db0827a894435e479c60b5c414ff857b4d8ad46" translate="yes" xml:space="preserve">
          <source>Additionally, if &lt;code&gt;T&lt;/code&gt; is not &lt;a href=&quot;../marker/trait.copy&quot;&gt;&lt;code&gt;Copy&lt;/code&gt;&lt;/a&gt;, using the pointed-to value after calling &lt;code&gt;drop_in_place&lt;/code&gt; can cause undefined behavior. Note that &lt;code&gt;*to_drop = foo&lt;/code&gt; counts as a use because it will cause the value to be dropped again. &lt;a href=&quot;fn.write&quot;&gt;&lt;code&gt;write()&lt;/code&gt;&lt;/a&gt; can be used to overwrite data without causing it to be dropped.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="74bd1999d14b1334b93c7bef28b699b66b0d25fc" translate="yes" xml:space="preserve">
          <source>Additionally, if &lt;code&gt;T&lt;/code&gt; is not &lt;a href=&quot;../marker/trait.copy&quot;&gt;&lt;code&gt;Copy&lt;/code&gt;&lt;/a&gt;, using the pointed-to value after calling &lt;code&gt;drop_in_place&lt;/code&gt; can cause undefined behavior. Note that &lt;code&gt;*to_drop = foo&lt;/code&gt; counts as a use because it will cause the value to be dropped again. &lt;a href=&quot;fn.write&quot;&gt;&lt;code&gt;write&lt;/code&gt;&lt;/a&gt; can be used to overwrite data without causing it to be dropped.</source>
          <target state="translated">Кроме того, если &lt;code&gt;T&lt;/code&gt; не &lt;a href=&quot;../marker/trait.copy&quot;&gt; &lt;code&gt;Copy&lt;/code&gt; &lt;/a&gt; , использование указанного значения после вызова &lt;code&gt;drop_in_place&lt;/code&gt; может привести к неопределенному поведению. Обратите внимание, что &lt;code&gt;*to_drop = foo&lt;/code&gt; считается использованием, потому что это приведет к повторному удалению значения. &lt;a href=&quot;fn.write&quot;&gt; &lt;code&gt;write&lt;/code&gt; &lt;/a&gt; можно использовать для перезаписи данных без их удаления.</target>
        </trans-unit>
        <trans-unit id="90a70db7c7bfc77bbf274f46c324d605b6ac9ac3" translate="yes" xml:space="preserve">
          <source>Additionally, it does not drop &lt;code&gt;src&lt;/code&gt;. Semantically, &lt;code&gt;src&lt;/code&gt; is moved into the location pointed to by &lt;code&gt;dst&lt;/code&gt;.</source>
          <target state="translated">Кроме того, он не сбрасывает &lt;code&gt;src&lt;/code&gt; . Семантически &lt;code&gt;src&lt;/code&gt; перемещается в место, на которое указывает &lt;code&gt;dst&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a5ab7ed4a3b0357f6baec92b0d45381b0f7726c3" translate="yes" xml:space="preserve">
          <source>Additionally, on Unix &lt;a href=&quot;struct.osstring&quot;&gt;&lt;code&gt;OsString&lt;/code&gt;&lt;/a&gt; implements the &lt;code&gt;std::os::unix::ffi::&lt;/code&gt;&lt;a href=&quot;../os/unix/ffi/trait.osstringext&quot;&gt;&lt;code&gt;OsStringExt&lt;/code&gt;&lt;/a&gt; trait, which provides &lt;a href=&quot;../os/unix/ffi/trait.osstringext#tymethod.from_vec&quot;&gt;&lt;code&gt;from_vec&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../os/unix/ffi/trait.osstringext#tymethod.into_vec&quot;&gt;&lt;code&gt;into_vec&lt;/code&gt;&lt;/a&gt; methods that consume their arguments, and take or produce vectors of &lt;a href=&quot;../primitive.u8&quot;&gt;&lt;code&gt;u8&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Кроме того, в Unix &lt;a href=&quot;struct.osstring&quot;&gt; &lt;code&gt;OsString&lt;/code&gt; &lt;/a&gt; реализует трейт &lt;code&gt;std::os::unix::ffi::&lt;/code&gt; &lt;a href=&quot;../os/unix/ffi/trait.osstringext&quot;&gt; &lt;code&gt;OsStringExt&lt;/code&gt; &lt;/a&gt; :: OsStringExt , который предоставляет &lt;a href=&quot;../os/unix/ffi/trait.osstringext#tymethod.from_vec&quot;&gt; &lt;code&gt;from_vec&lt;/code&gt; &lt;/a&gt; и &lt;a href=&quot;../os/unix/ffi/trait.osstringext#tymethod.into_vec&quot;&gt; &lt;code&gt;into_vec&lt;/code&gt; ,&lt;/a&gt; которые используют их аргументы и принимают или создают векторы &lt;a href=&quot;../primitive.u8&quot;&gt; &lt;code&gt;u8&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="1db4d415a7232a66cc30ffdbd6dbfd6bc3c496f2" translate="yes" xml:space="preserve">
          <source>Additionally, on Unix &lt;a href=&quot;struct.osstring&quot;&gt;&lt;code&gt;OsString&lt;/code&gt;&lt;/a&gt; implements the &lt;code&gt;std::os::unix::ffi::&lt;/code&gt;&lt;a href=&quot;../os/unix/ffi/trait.osstringext&quot;&gt;&lt;code&gt;OsStringExt&lt;/code&gt;&lt;/a&gt; trait, which provides &lt;a href=&quot;../os/unix/ffi/trait.osstringext#tymethod.from_vec&quot;&gt;&lt;code&gt;from_vec&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../os/unix/ffi/trait.osstringext#tymethod.into_vec&quot;&gt;&lt;code&gt;into_vec&lt;/code&gt;&lt;/a&gt; methods that consume their arguments, and take or produce vectors of &lt;a href=&quot;https://doc.rust-lang.org/nightly/std/primitive.u8.html&quot;&gt;&lt;code&gt;u8&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8bb517701cd0832c45c67c28da4b399a605014b6" translate="yes" xml:space="preserve">
          <source>Additionally, on Windows &lt;a href=&quot;struct.osstring&quot;&gt;&lt;code&gt;OsString&lt;/code&gt;&lt;/a&gt; implements the &lt;code&gt;std::os::windows:ffi::&lt;/code&gt;&lt;a href=&quot;../os/windows/ffi/trait.osstringext&quot;&gt;&lt;code&gt;OsStringExt&lt;/code&gt;&lt;/a&gt; trait, which provides a &lt;a href=&quot;../os/windows/ffi/trait.osstringext#tymethod.from_wide&quot;&gt;&lt;code&gt;from_wide&lt;/code&gt;&lt;/a&gt; method. The result of this method is an &lt;a href=&quot;struct.osstring&quot;&gt;&lt;code&gt;OsString&lt;/code&gt;&lt;/a&gt; which can be round-tripped to a Windows string losslessly.</source>
          <target state="translated">Кроме того, в Windows &lt;a href=&quot;struct.osstring&quot;&gt; &lt;code&gt;OsString&lt;/code&gt; &lt;/a&gt; реализует трейт &lt;code&gt;std::os::windows:ffi::&lt;/code&gt; &lt;a href=&quot;../os/windows/ffi/trait.osstringext&quot;&gt; &lt;code&gt;OsStringExt&lt;/code&gt; &lt;/a&gt; :: OsStringExt , который предоставляет метод &lt;a href=&quot;../os/windows/ffi/trait.osstringext#tymethod.from_wide&quot;&gt; &lt;code&gt;from_wide&lt;/code&gt; &lt;/a&gt; . Результатом этого метода является &lt;a href=&quot;struct.osstring&quot;&gt; &lt;code&gt;OsString&lt;/code&gt; ,&lt;/a&gt; который может быть без потерь преобразован в строку Windows.</target>
        </trans-unit>
        <trans-unit id="0f7d5354cdb11e461595056b1602a23178a20138" translate="yes" xml:space="preserve">
          <source>Additionally, taking a job off the channel queue involves mutating the &lt;code&gt;receiver&lt;/code&gt;, so the threads need a safe way to share and modify &lt;code&gt;receiver&lt;/code&gt;; otherwise, we might get race conditions (as covered in Chapter 16).</source>
          <target state="translated">Кроме того, удаление задания из очереди канала включает изменение &lt;code&gt;receiver&lt;/code&gt; , поэтому потокам нужен безопасный способ совместного использования и изменения &lt;code&gt;receiver&lt;/code&gt; ; в противном случае мы можем получить состояние гонки (как описано в главе 16).</target>
        </trans-unit>
        <trans-unit id="0eb5702e98a03d052d40c8aabb340aee4d2332a4" translate="yes" xml:space="preserve">
          <source>Additionally, the &lt;code&gt;isize&lt;/code&gt; and &lt;code&gt;usize&lt;/code&gt; types depend on the kind of computer your program is running on: 64 bits if you&amp;rsquo;re on a 64-bit architecture and 32 bits if you&amp;rsquo;re on a 32-bit architecture.</source>
          <target state="translated">Кроме того, &lt;code&gt;isize&lt;/code&gt; и &lt;code&gt;usize&lt;/code&gt; зависят от типа компьютера, на котором работает ваша программа: 64-битные, если вы используете 64-битную архитектуру, и 32-битные, если вы используете 32-битную архитектуру.</target>
        </trans-unit>
        <trans-unit id="e3aa1d01d453f95734172c24dd2caadad96e569f" translate="yes" xml:space="preserve">
          <source>Additionally, the caller must ensure that writing &lt;code&gt;count * size_of::&amp;lt;T&amp;gt;()&lt;/code&gt; bytes to the given region of memory results in a valid value of &lt;code&gt;T&lt;/code&gt;. Using a region of memory typed as a &lt;code&gt;T&lt;/code&gt; that contains an invalid value of &lt;code&gt;T&lt;/code&gt; is undefined behavior.</source>
          <target state="translated">Кроме того, абонент должен убедиться , что писать &lt;code&gt;count * size_of::&amp;lt;T&amp;gt;()&lt;/code&gt; байты в данной области результатов памяти в верном значении &lt;code&gt;T&lt;/code&gt; . Использование области памяти типа &lt;code&gt;T&lt;/code&gt; , содержащей недопустимое значение &lt;code&gt;T&lt;/code&gt; , является неопределенным поведением.</target>
        </trans-unit>
        <trans-unit id="f3d0f5351803248ec3d677cec08967bab902a3b1" translate="yes" xml:space="preserve">
          <source>Additionally, the length of the string will be recalculated from the pointer.</source>
          <target state="translated">Кроме того,длина строки будет пересчитана по указателю.</target>
        </trans-unit>
        <trans-unit id="5c93e6fb82861fecd56783e8c74a9dcd85037abd" translate="yes" xml:space="preserve">
          <source>Additionally, the lifetime &lt;code&gt;'a&lt;/code&gt; returned is arbitrarily chosen and does not necessarily reflect the actual lifetime of the data. It is up to the caller to ensure that for the duration of this lifetime, the memory this pointer points to does not get accessed through any other pointer.</source>
          <target state="translated">Кроме того, срок службы &lt;code&gt;'a&lt;/code&gt; возвращаемый произвольно выбраны и не обязательно отражает фактическую продолжительность жизни данных. Вызывающий объект должен гарантировать, что в течение этого времени жизни память, на которую указывает этот указатель, не будет доступна через какой-либо другой указатель.</target>
        </trans-unit>
        <trans-unit id="6e203e0080d407af9cc4130e8b5859f062bfa85b" translate="yes" xml:space="preserve">
          <source>Additionally, the lifetime &lt;code&gt;'a&lt;/code&gt; returned is arbitrarily chosen and does not necessarily reflect the actual lifetime of the data. It is up to the caller to ensure that for the duration of this lifetime, the memory this pointer points to does not get written to outside of &lt;code&gt;UnsafeCell&amp;lt;U&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">Кроме того, срок службы &lt;code&gt;'a&lt;/code&gt; возвращаемый произвольно выбраны и не обязательно отражает фактическую продолжительность жизни данных. Вызывающий объект должен гарантировать, что в течение этого времени жизни память, на которую указывает этот указатель, не записывается за пределы &lt;code&gt;UnsafeCell&amp;lt;U&amp;gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="cb09e099663e4fdfec9970e8541bfc0bbcb8c136" translate="yes" xml:space="preserve">
          <source>Additionally, the return value of this function is &lt;a href=&quot;type.result&quot;&gt;&lt;code&gt;fmt::Result&lt;/code&gt;&lt;/a&gt; which is a type alias of &lt;a href=&quot;../result/enum.result&quot;&gt;&lt;code&gt;Result&lt;/code&gt;&lt;/a&gt;&lt;code&gt;&amp;lt;(), &lt;/code&gt;&lt;a href=&quot;struct.error&quot;&gt;&lt;code&gt;std::fmt::Error&lt;/code&gt;&lt;/a&gt;&lt;code&gt;&amp;gt;&lt;/code&gt;. Formatting implementations should ensure that they propagate errors from the &lt;a href=&quot;struct.formatter&quot;&gt;&lt;code&gt;Formatter&lt;/code&gt;&lt;/a&gt; (e.g., when calling &lt;a href=&quot;../macro.write&quot;&gt;&lt;code&gt;write!&lt;/code&gt;&lt;/a&gt;). However, they should never return errors spuriously. That is, a formatting implementation must and may only return an error if the passed-in &lt;a href=&quot;struct.formatter&quot;&gt;&lt;code&gt;Formatter&lt;/code&gt;&lt;/a&gt; returns an error. This is because, contrary to what the function signature might suggest, string formatting is an infallible operation. This function only returns a result because writing to the underlying stream might fail and it must provide a way to propagate the fact that an error has occurred back up the stack.</source>
          <target state="translated">Кроме того, возвращаемое значение этой функции - &lt;a href=&quot;type.result&quot;&gt; &lt;code&gt;fmt::Result&lt;/code&gt; &lt;/a&gt; который является псевдонимом типа &lt;a href=&quot;../result/enum.result&quot;&gt; &lt;code&gt;Result&lt;/code&gt; &lt;/a&gt; &lt;code&gt;&amp;lt;(), &lt;/code&gt; &lt;a href=&quot;struct.error&quot;&gt; &lt;code&gt;std::fmt::Error&lt;/code&gt; &lt;/a&gt; &lt;code&gt;&amp;gt;&lt;/code&gt; . Реализации форматирования должны гарантировать, что они распространяют ошибки от &lt;a href=&quot;struct.formatter&quot;&gt; &lt;code&gt;Formatter&lt;/code&gt; &lt;/a&gt; (например, при вызове &lt;a href=&quot;../macro.write&quot;&gt; &lt;code&gt;write!&lt;/code&gt; &lt;/a&gt; ). Однако они никогда не должны ложно возвращать ошибки. То есть, форматирование необходимо выполнение и может вернуть ошибку , если переданные в &lt;a href=&quot;struct.formatter&quot;&gt; &lt;code&gt;Formatter&lt;/code&gt; &lt;/a&gt;возвращает ошибку. Это потому, что, вопреки тому, что может предполагать сигнатура функции, форматирование строки является безошибочной операцией. Эта функция возвращает результат только потому, что запись в базовый поток может завершиться неудачно, и она должна обеспечивать способ распространения факта возникновения ошибки в резервную копию стека.</target>
        </trans-unit>
        <trans-unit id="c51e0d7d6467942093ff85910240899ecb3312bc" translate="yes" xml:space="preserve">
          <source>Additionally, we can&amp;rsquo;t yet provide the &lt;code&gt;hello_macro&lt;/code&gt; function with default implementation that will print the name of the type the trait is implemented on: Rust doesn&amp;rsquo;t have reflection capabilities, so it can&amp;rsquo;t look up the type&amp;rsquo;s name at runtime. We need a macro to generate code at compile time.</source>
          <target state="translated">Кроме того, мы пока не можем предоставить функцию &lt;code&gt;hello_macro&lt;/code&gt; с реализацией по умолчанию, которая будет печатать имя типа, для которого реализована черта: Rust не имеет возможностей отражения, поэтому он не может искать имя типа во время выполнения. Нам нужен макрос для генерации кода во время компиляции.</target>
        </trans-unit>
        <trans-unit id="009b5112bedb7bc7f35022f14f637dbf23e46083" translate="yes" xml:space="preserve">
          <source>Additionally, you&amp;rsquo;ll need a linker of some kind. It&amp;rsquo;s likely one is already installed, but when you try to compile a Rust program and get errors indicating that a linker could not execute, that means a linker isn&amp;rsquo;t installed on your system and you&amp;rsquo;ll need to install one manually. C compilers usually come with the correct linker. Check your platform&amp;rsquo;s documentation for how to install a C compiler. Also, some common Rust packages depend on C code and will need a C compiler. Therefore, it might be worth installing one now.</source>
          <target state="translated">Кроме того, вам понадобится какой-то компоновщик. Скорее всего, он уже установлен, но когда вы пытаетесь скомпилировать программу на Rust и получаете ошибки, указывающие на то, что компоновщик не может работать, это означает, что компоновщик не установлен в вашей системе, и вам нужно будет установить его вручную. Компиляторы C обычно поставляются с правильным компоновщиком. Проверьте документацию вашей платформы, чтобы узнать, как установить компилятор C. Кроме того, некоторые распространенные пакеты Rust зависят от кода C и требуют компилятора C. Поэтому, возможно, стоит установить его сейчас.</target>
        </trans-unit>
        <trans-unit id="e8f6c433136e97e0a25822d00a70a971083e0df2" translate="yes" xml:space="preserve">
          <source>AddrParseError</source>
          <target state="translated">AddrParseError</target>
        </trans-unit>
        <trans-unit id="4db89e8ded7777748645ac21edd601141065b25a" translate="yes" xml:space="preserve">
          <source>AddrParseError::borrow</source>
          <target state="translated">AddrParseError::borrow</target>
        </trans-unit>
        <trans-unit id="ba5e2e5b2d73d903fb597da8809d6182f967fe26" translate="yes" xml:space="preserve">
          <source>AddrParseError::borrow_mut</source>
          <target state="translated">AddrParseError::borrow_mut</target>
        </trans-unit>
        <trans-unit id="eec3364cb0e6e631bd766aeee8473eb3c5d8b783" translate="yes" xml:space="preserve">
          <source>AddrParseError::cause</source>
          <target state="translated">AddrParseError::cause</target>
        </trans-unit>
        <trans-unit id="c8650de9923d2b7b74fd1fb851b3c0ddd4117148" translate="yes" xml:space="preserve">
          <source>AddrParseError::clone</source>
          <target state="translated">AddrParseError::clone</target>
        </trans-unit>
        <trans-unit id="53ddfe6ad8c3351ba945f5b6cd6f647e3fa91325" translate="yes" xml:space="preserve">
          <source>AddrParseError::clone_from</source>
          <target state="translated">AddrParseError::clone_from</target>
        </trans-unit>
        <trans-unit id="08355c15003499e28a7411918357d4a2f001b709" translate="yes" xml:space="preserve">
          <source>AddrParseError::clone_into</source>
          <target state="translated">AddrParseError::clone_into</target>
        </trans-unit>
        <trans-unit id="25cb3b50c76347b7f6a85db7c339595baf0f003c" translate="yes" xml:space="preserve">
          <source>AddrParseError::description</source>
          <target state="translated">AddrParseError::description</target>
        </trans-unit>
        <trans-unit id="10b9b968cc3bf94f7c5c39dea8bf21d7dd54888c" translate="yes" xml:space="preserve">
          <source>AddrParseError::eq</source>
          <target state="translated">AddrParseError::eq</target>
        </trans-unit>
        <trans-unit id="49cf29f6a6f46e91fe5234ee3c02c53e59ab7578" translate="yes" xml:space="preserve">
          <source>AddrParseError::fmt</source>
          <target state="translated">AddrParseError::fmt</target>
        </trans-unit>
        <trans-unit id="60405d6d13708e4d85c176a98cb4377bfb7ee9d7" translate="yes" xml:space="preserve">
          <source>AddrParseError::from</source>
          <target state="translated">AddrParseError::from</target>
        </trans-unit>
        <trans-unit id="dbfcfd8a7eba25880c9888cb8208fce8e37c895d" translate="yes" xml:space="preserve">
          <source>AddrParseError::into</source>
          <target state="translated">AddrParseError::into</target>
        </trans-unit>
        <trans-unit id="81cea92a5c59d76a750c2dc91be0b6bebf9c1c4f" translate="yes" xml:space="preserve">
          <source>AddrParseError::ne</source>
          <target state="translated">AddrParseError::ne</target>
        </trans-unit>
        <trans-unit id="85b81474bbc6034c17600e25b324b8f7ff89e65b" translate="yes" xml:space="preserve">
          <source>AddrParseError::source</source>
          <target state="translated">AddrParseError::source</target>
        </trans-unit>
        <trans-unit id="ba1fd539045fde8129efbfd52fe6aba361392170" translate="yes" xml:space="preserve">
          <source>AddrParseError::to_owned</source>
          <target state="translated">AddrParseError::to_owned</target>
        </trans-unit>
        <trans-unit id="e2552e76eca8011ad4e06db73e14e51d90cd4e86" translate="yes" xml:space="preserve">
          <source>AddrParseError::to_string</source>
          <target state="translated">AddrParseError::to_string</target>
        </trans-unit>
        <trans-unit id="ff5f57540e8ea426311cdc19ccc6971134dcdb7f" translate="yes" xml:space="preserve">
          <source>AddrParseError::try_from</source>
          <target state="translated">AddrParseError::try_from</target>
        </trans-unit>
        <trans-unit id="bec376def9a1123d4f124dfc1a6840567151a145" translate="yes" xml:space="preserve">
          <source>AddrParseError::try_into</source>
          <target state="translated">AddrParseError::try_into</target>
        </trans-unit>
        <trans-unit id="26c560bba3044ee670c8f3ee436e252e0e2dad89" translate="yes" xml:space="preserve">
          <source>AddrParseError::type_id</source>
          <target state="translated">AddrParseError::type_id</target>
        </trans-unit>
        <trans-unit id="5cf7a9b41ce47d27a30e791bbfb6bec2ca816fcf" translate="yes" xml:space="preserve">
          <source>Address to pointer cast</source>
          <target state="translated">Адрес для литья указателей</target>
        </trans-unit>
        <trans-unit id="d7aa7412717eb74583761a8560faa539aaf27874" translate="yes" xml:space="preserve">
          <source>Address type can be any implementor of &lt;a href=&quot;trait.tosocketaddrs&quot;&gt;&lt;code&gt;ToSocketAddrs&lt;/code&gt;&lt;/a&gt; trait. See its documentation for concrete examples.</source>
          <target state="translated">Тип адреса может быть любым, реализующим признак &lt;a href=&quot;trait.tosocketaddrs&quot;&gt; &lt;code&gt;ToSocketAddrs&lt;/code&gt; &lt;/a&gt; . См. Его документацию для конкретных примеров.</target>
        </trans-unit>
        <trans-unit id="5a1149884af3cef69504ddd9428373fea25aa2ca" translate="yes" xml:space="preserve">
          <source>Addresses returned by the operating system that are not IP addresses are silently ignored.</source>
          <target state="translated">Возвращаемые операционной системой адреса,которые не являются IP-адресами,беззвучно игнорируются.</target>
        </trans-unit>
        <trans-unit id="5915abc490110180d1540b6234219f020e04a70a" translate="yes" xml:space="preserve">
          <source>Adds a &lt;a href=&quot;struct.peekable#method.peek&quot;&gt;&lt;code&gt;peek&lt;/code&gt;&lt;/a&gt; method to an iterator. See its documentation for more information.</source>
          <target state="translated">Добавление &lt;a href=&quot;struct.peekable#method.peek&quot;&gt; &lt;code&gt;peek&lt;/code&gt; &lt;/a&gt; метода к итератору. См. Его документацию для получения дополнительной информации.</target>
        </trans-unit>
        <trans-unit id="c870f816a116db65c4b82439ff891f426f80ff41" translate="yes" xml:space="preserve">
          <source>Adds a &lt;code&gt;usize&lt;/code&gt;, returning &lt;code&gt;None&lt;/code&gt; on overflow.</source>
          <target state="translated">Добавляет &lt;code&gt;usize&lt;/code&gt; , возвращая &lt;code&gt;None&lt;/code&gt; при переполнении.</target>
        </trans-unit>
        <trans-unit id="31cf127eab5bb935c2abe6cc6bba90f4ae0b71a3" translate="yes" xml:space="preserve">
          <source>Adds a new entry to the list output.</source>
          <target state="translated">Добавляет новую запись в вывод списка.</target>
        </trans-unit>
        <trans-unit id="15cb5f7efe200723c3b721e295fbebc13dfc9e31" translate="yes" xml:space="preserve">
          <source>Adds a new entry to the map output.</source>
          <target state="translated">Добавляет новую запись на выход карты.</target>
        </trans-unit>
        <trans-unit id="0ef3b59a4597ecf10372b8f11eb26c1a52f2f272" translate="yes" xml:space="preserve">
          <source>Adds a new entry to the set output.</source>
          <target state="translated">Добавляет новую запись в установленный выходной сигнал.</target>
        </trans-unit>
        <trans-unit id="60f1cf0bd8c4a027b017ecaa893cb9c74c91f78b" translate="yes" xml:space="preserve">
          <source>Adds a new field to the generated struct output.</source>
          <target state="translated">Добавляет новое поле к сгенерированному выходу структуры.</target>
        </trans-unit>
        <trans-unit id="b8fafafece871a01042ed5a0ab5c6c9b2e80442c" translate="yes" xml:space="preserve">
          <source>Adds a new field to the generated tuple struct output.</source>
          <target state="translated">Добавляет новое поле к сгенерированному выходу структуры кортежа.</target>
        </trans-unit>
        <trans-unit id="0b002c9af6c57cafdfe28d411ed57cf85e2ebe81" translate="yes" xml:space="preserve">
          <source>Adds a value to the set, replacing the existing value, if any, that is equal to the given one. Returns the replaced value.</source>
          <target state="translated">Добавляет к набору значение,заменяя существующее значение,если таковое имеется,равным данному.Возвращает замененное значение.</target>
        </trans-unit>
        <trans-unit id="82f4c899437f1a62750b1776b4b1b6599530f1e6" translate="yes" xml:space="preserve">
          <source>Adds a value to the set.</source>
          <target state="translated">Добавляет значение к набору.</target>
        </trans-unit>
        <trans-unit id="f1a3f6979754c5ca7c9e4122b44f7541e9636107" translate="yes" xml:space="preserve">
          <source>Adds an argument to pass to the program.</source>
          <target state="translated">Добавляет аргумент для передачи в программу.</target>
        </trans-unit>
        <trans-unit id="658707171b5a956fa506d45ca2578865d314c2a0" translate="yes" xml:space="preserve">
          <source>Adds an element first in the list.</source>
          <target state="translated">Добавляет элемент первым в списке.</target>
        </trans-unit>
        <trans-unit id="969d7672cd1e94e2e3f766816cef88b15855a861" translate="yes" xml:space="preserve">
          <source>Adds multiple arguments to pass to the program.</source>
          <target state="translated">Добавляет несколько аргументов для передачи в программу.</target>
        </trans-unit>
        <trans-unit id="68adca23d26862cb362a13d5d500e729dc911a8b" translate="yes" xml:space="preserve">
          <source>Adds one to this step, returning the result.</source>
          <target state="translated">Добавляет один к этому шагу,возвращает результат.</target>
        </trans-unit>
        <trans-unit id="0151250bd8bdb46ad8abec9aa6c7d2adc6f4d3c2" translate="yes" xml:space="preserve">
          <source>Adds or updates multiple environment variable mappings.</source>
          <target state="translated">Добавляет или обновляет несколько связок переменных окружения.</target>
        </trans-unit>
        <trans-unit id="c1ea158bb2722c6d5db848a523c49d2d1b4ef996" translate="yes" xml:space="preserve">
          <source>Adds support for special Unix file types such as block/character devices, pipes, and sockets.</source>
          <target state="translated">Добавляет поддержку специальных Unix-типов файлов,таких как блочные/символьные устройства,трубы и сокеты.</target>
        </trans-unit>
        <trans-unit id="671bf2741316962d688bf4f15b0556af370525fd" translate="yes" xml:space="preserve">
          <source>Adds the contents of an iterator of entries to the list output.</source>
          <target state="translated">Добавляет содержимое итератора записей в вывод списка.</target>
        </trans-unit>
        <trans-unit id="6172d9346f85a8afb18c30e9f6e11792ac6685f3" translate="yes" xml:space="preserve">
          <source>Adds the contents of an iterator of entries to the map output.</source>
          <target state="translated">Добавляет содержимое итератора записей в выходной файл карты.</target>
        </trans-unit>
        <trans-unit id="45f4916d90bbb31a57ac59c642d372fc8465632a" translate="yes" xml:space="preserve">
          <source>Adds the contents of an iterator of entries to the set output.</source>
          <target state="translated">Добавляет содержимое итератора записей в установленный выходной сигнал.</target>
        </trans-unit>
        <trans-unit id="525909640b425a3865879f7bf9b4776de0cbde79" translate="yes" xml:space="preserve">
          <source>Adds the key part of a new entry to the map output.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="82b33d8253f240296388fcf0db6ce4c17b122fb9" translate="yes" xml:space="preserve">
          <source>Adds the value part of a new entry to the map output.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="64dedb52a39f499be5ddacaf33bea0b6af530c2b" translate="yes" xml:space="preserve">
          <source>Adds to the current value, returning the previous value.</source>
          <target state="translated">Добавляет к текущему значению,возвращая предыдущее значение.</target>
        </trans-unit>
        <trans-unit id="fec400f1cdf6c0803479c71a8ae238f9468f9b58" translate="yes" xml:space="preserve">
          <source>Adds to the current value, returning the previous value. The stabilized version of this intrinsic is available on the &lt;code&gt;std::sync::atomic&lt;/code&gt; types via the &lt;code&gt;fetch_add&lt;/code&gt; method by passing &lt;a href=&quot;../sync/atomic/enum.ordering&quot;&gt;&lt;code&gt;Ordering::AcqRel&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;order&lt;/code&gt;. For example, &lt;a href=&quot;../sync/atomic/struct.atomicisize#method.fetch_add&quot;&gt;&lt;code&gt;AtomicIsize::fetch_add&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Добавляет к текущему значению, возвращая предыдущее значение. Стабилизированная версия этой встроенной функции доступна для типов &lt;code&gt;std::sync::atomic&lt;/code&gt; через метод &lt;code&gt;fetch_add&lt;/code&gt; , передав &lt;a href=&quot;../sync/atomic/enum.ordering&quot;&gt; &lt;code&gt;Ordering::AcqRel&lt;/code&gt; &lt;/a&gt; в качестве &lt;code&gt;order&lt;/code&gt; . Например, &lt;a href=&quot;../sync/atomic/struct.atomicisize#method.fetch_add&quot;&gt; &lt;code&gt;AtomicIsize::fetch_add&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="be9a5a4d4b7398c45da8fcba5bded3bbc8f71847" translate="yes" xml:space="preserve">
          <source>Adds to the current value, returning the previous value. The stabilized version of this intrinsic is available on the &lt;code&gt;std::sync::atomic&lt;/code&gt; types via the &lt;code&gt;fetch_add&lt;/code&gt; method by passing &lt;a href=&quot;../sync/atomic/enum.ordering&quot;&gt;&lt;code&gt;Ordering::Acquire&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;order&lt;/code&gt;. For example, &lt;a href=&quot;../sync/atomic/struct.atomicisize#method.fetch_add&quot;&gt;&lt;code&gt;AtomicIsize::fetch_add&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Добавляет к текущему значению, возвращая предыдущее значение. Стабилизированная версия этой встроенной функции доступна для типов &lt;code&gt;std::sync::atomic&lt;/code&gt; через метод &lt;code&gt;fetch_add&lt;/code&gt; , передав &lt;a href=&quot;../sync/atomic/enum.ordering&quot;&gt; &lt;code&gt;Ordering::Acquire&lt;/code&gt; &lt;/a&gt; в качестве &lt;code&gt;order&lt;/code&gt; . Например, &lt;a href=&quot;../sync/atomic/struct.atomicisize#method.fetch_add&quot;&gt; &lt;code&gt;AtomicIsize::fetch_add&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="e8510188bc5ebdc1c7bffee425e4b31fab3c7278" translate="yes" xml:space="preserve">
          <source>Adds to the current value, returning the previous value. The stabilized version of this intrinsic is available on the &lt;code&gt;std::sync::atomic&lt;/code&gt; types via the &lt;code&gt;fetch_add&lt;/code&gt; method by passing &lt;a href=&quot;../sync/atomic/enum.ordering&quot;&gt;&lt;code&gt;Ordering::Relaxed&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;order&lt;/code&gt;. For example, &lt;a href=&quot;../sync/atomic/struct.atomicisize#method.fetch_add&quot;&gt;&lt;code&gt;AtomicIsize::fetch_add&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Добавляет к текущему значению, возвращая предыдущее значение. Стабилизированная версия этой встроенной функции доступна для типов &lt;code&gt;std::sync::atomic&lt;/code&gt; через метод &lt;code&gt;fetch_add&lt;/code&gt; , передав &lt;a href=&quot;../sync/atomic/enum.ordering&quot;&gt; &lt;code&gt;Ordering::Relaxed&lt;/code&gt; &lt;/a&gt; в качестве &lt;code&gt;order&lt;/code&gt; . Например, &lt;a href=&quot;../sync/atomic/struct.atomicisize#method.fetch_add&quot;&gt; &lt;code&gt;AtomicIsize::fetch_add&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="5d050db3800c7dd71e5057e0d9def9358e61a419" translate="yes" xml:space="preserve">
          <source>Adds to the current value, returning the previous value. The stabilized version of this intrinsic is available on the &lt;code&gt;std::sync::atomic&lt;/code&gt; types via the &lt;code&gt;fetch_add&lt;/code&gt; method by passing &lt;a href=&quot;../sync/atomic/enum.ordering&quot;&gt;&lt;code&gt;Ordering::Release&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;order&lt;/code&gt;. For example, &lt;a href=&quot;../sync/atomic/struct.atomicisize#method.fetch_add&quot;&gt;&lt;code&gt;AtomicIsize::fetch_add&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Добавляет к текущему значению, возвращая предыдущее значение. Стабилизированная версия этой встроенной функции доступна для типов &lt;code&gt;std::sync::atomic&lt;/code&gt; через метод &lt;code&gt;fetch_add&lt;/code&gt; , передав &lt;a href=&quot;../sync/atomic/enum.ordering&quot;&gt; &lt;code&gt;Ordering::Release&lt;/code&gt; &lt;/a&gt; в качестве &lt;code&gt;order&lt;/code&gt; . Например, &lt;a href=&quot;../sync/atomic/struct.atomicisize#method.fetch_add&quot;&gt; &lt;code&gt;AtomicIsize::fetch_add&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="1973476bdfd162d29c3bf0eb0f1911803377eae3" translate="yes" xml:space="preserve">
          <source>Adds to the current value, returning the previous value. The stabilized version of this intrinsic is available on the &lt;code&gt;std::sync::atomic&lt;/code&gt; types via the &lt;code&gt;fetch_add&lt;/code&gt; method by passing &lt;a href=&quot;../sync/atomic/enum.ordering&quot;&gt;&lt;code&gt;Ordering::SeqCst&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;order&lt;/code&gt;. For example, &lt;a href=&quot;../sync/atomic/struct.atomicisize#method.fetch_add&quot;&gt;&lt;code&gt;AtomicIsize::fetch_add&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Добавляет к текущему значению, возвращая предыдущее значение. Стабилизированная версия этой встроенной функции доступна для типов &lt;code&gt;std::sync::atomic&lt;/code&gt; через метод &lt;code&gt;fetch_add&lt;/code&gt; , передав &lt;a href=&quot;../sync/atomic/enum.ordering&quot;&gt; &lt;code&gt;Ordering::SeqCst&lt;/code&gt; &lt;/a&gt; в качестве &lt;code&gt;order&lt;/code&gt; . Например, &lt;a href=&quot;../sync/atomic/struct.atomicisize#method.fetch_add&quot;&gt; &lt;code&gt;AtomicIsize::fetch_add&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="eb6c863d4412a4b55b1d93cf3d5f7516528289e4" translate="yes" xml:space="preserve">
          <source>Advance the internal cursor of the slice.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b2ed5841682a101d798c6152b62dca74cfea4b15" translate="yes" xml:space="preserve">
          <source>Advance to the next arg.</source>
          <target state="translated">Переходите к следующему аргументу.</target>
        </trans-unit>
        <trans-unit id="96731dbaea6a5720dd33b64dc334ff765eec736a" translate="yes" xml:space="preserve">
          <source>Advanced Features</source>
          <target state="translated">Дополнительные функции</target>
        </trans-unit>
        <trans-unit id="7f4668d91bf23526ef1f05a0e7de95630615e93b" translate="yes" xml:space="preserve">
          <source>Advanced Functions and Closures</source>
          <target state="translated">Расширенные функции и закрытие</target>
        </trans-unit>
        <trans-unit id="d5d49bfe71b011aa5e9e308b0bd9089c84c3c245" translate="yes" xml:space="preserve">
          <source>Advanced Traits</source>
          <target state="translated">Дополнительные характеристики</target>
        </trans-unit>
        <trans-unit id="ae95896c3a125d9a5e8ed95928ac9721dd8d3752" translate="yes" xml:space="preserve">
          <source>Advanced Types</source>
          <target state="translated">Расширенные типы</target>
        </trans-unit>
        <trans-unit id="9b4509b6a0eecdabec69457f9e139e56f305f9a7" translate="yes" xml:space="preserve">
          <source>Advanced functions and closures: function pointers and returning closures</source>
          <target state="translated">Расширенные функции и замыкания:указатели функций и обратные замыкания</target>
        </trans-unit>
        <trans-unit id="9c622feb39e22136f98cc1cfffb6cc56c0cb6ac7" translate="yes" xml:space="preserve">
          <source>Advanced traits: associated types, default type parameters, fully qualified syntax, supertraits, and the newtype pattern in relation to traits</source>
          <target state="translated">Расширенные трейты:ассоциированные типы,параметры типа по умолчанию,полностью квалифицированный синтаксис,супертрейты и шаблон нового типа по отношению к трейтам</target>
        </trans-unit>
        <trans-unit id="d050af08a92ff2ff0056bb035493a0f2f1620de8" translate="yes" xml:space="preserve">
          <source>Advanced types: more about the newtype pattern, type aliases, the never type, and dynamically sized types</source>
          <target state="translated">Продвинутые типы:подробнее о новом шаблоне типа,псевдонимах типа,никогда и динамически размещаемых типах.</target>
        </trans-unit>
        <trans-unit id="bc73315bb680ddc61259cb6b2cc7f603f7017af5" translate="yes" xml:space="preserve">
          <source>Advances the iterator and returns the next value.</source>
          <target state="translated">Перемещает итератор и возвращает следующее значение.</target>
        </trans-unit>
        <trans-unit id="47778efc70c16f19b03a33e09324cdfef37b8397" translate="yes" xml:space="preserve">
          <source>Advances the iterator and returns the next value. &lt;a href=&quot;../../../iter/trait.iterator#tymethod.next&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">Перемещает итератор вперед и возвращает следующее значение. &lt;a href=&quot;../../../iter/trait.iterator#tymethod.next&quot;&gt;Читать далее&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="e5c10d1dad50204036d6641dc96f179feac3c880" translate="yes" xml:space="preserve">
          <source>Advances the iterator and returns the next value. &lt;a href=&quot;../../iter/trait.iterator#tymethod.next&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">Перемещает итератор вперед и возвращает следующее значение. &lt;a href=&quot;../../iter/trait.iterator#tymethod.next&quot;&gt;Читать далее&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="e0d17cb524aa65c6531ab7f58b22a2915be47179" translate="yes" xml:space="preserve">
          <source>Advances the iterator and returns the next value. &lt;a href=&quot;../iter/trait.iterator#tymethod.next&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">Перемещает итератор вперед и возвращает следующее значение. &lt;a href=&quot;../iter/trait.iterator#tymethod.next&quot;&gt;Читать далее&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="2af190b4bf87220daaa7fcdfebb435d1dda577b1" translate="yes" xml:space="preserve">
          <source>Advances the iterator and returns the next value. &lt;a href=&quot;iter/trait.iterator#tymethod.next&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">Перемещает итератор вперед и возвращает следующее значение. &lt;a href=&quot;iter/trait.iterator#tymethod.next&quot;&gt;Читать далее&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="75ff050bc0f28af247ba9f7e987965071e370a8f" translate="yes" xml:space="preserve">
          <source>Advances the iterator and returns the next value. &lt;a href=&quot;trait.iterator#tymethod.next&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">Перемещает итератор вперед и возвращает следующее значение. &lt;a href=&quot;trait.iterator#tymethod.next&quot;&gt;Читать далее&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="6c629d1551783824351df46023949d62af853825" translate="yes" xml:space="preserve">
          <source>Advances the iterator by &lt;code&gt;n&lt;/code&gt; elements.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c9fef351384b0144be153be53f79c7fc476bedfc" translate="yes" xml:space="preserve">
          <source>Advances the iterator by &lt;code&gt;n&lt;/code&gt; elements. &lt;a href=&quot;../../../iter/trait.iterator#method.advance_by&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="41de8018927ed7b54950980aec11f8f12d46606f" translate="yes" xml:space="preserve">
          <source>Advances the iterator by &lt;code&gt;n&lt;/code&gt; elements. &lt;a href=&quot;../../iter/trait.iterator#method.advance_by&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="09741f9824923fbfa016237025da37c62ee69dcc" translate="yes" xml:space="preserve">
          <source>Advances the iterator by &lt;code&gt;n&lt;/code&gt; elements. &lt;a href=&quot;../iter/trait.iterator#method.advance_by&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5c3b9d2faa7136ddd042e31d3939c786f1c8da2c" translate="yes" xml:space="preserve">
          <source>Advances the iterator by &lt;code&gt;n&lt;/code&gt; elements. &lt;a href=&quot;iter/trait.iterator#method.advance_by&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="74fde24899e07da847358f17c288cfcfe8ae74ea" translate="yes" xml:space="preserve">
          <source>Advances the iterator by &lt;code&gt;n&lt;/code&gt; elements. &lt;a href=&quot;trait.iterator#method.advance_by&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4d66799c08b5e49880157cde9e0d13d223a5c3a3" translate="yes" xml:space="preserve">
          <source>Advances the iterator from the back by &lt;code&gt;n&lt;/code&gt; elements.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4f1f4e504d47f61c437fd02db056daa6ec47dc6c" translate="yes" xml:space="preserve">
          <source>Advances the iterator from the back by &lt;code&gt;n&lt;/code&gt; elements. &lt;a href=&quot;../../iter/trait.doubleendediterator#method.advance_back_by&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4d59517951217a4fde7238ff6227ce7834fa1b5e" translate="yes" xml:space="preserve">
          <source>Advances the iterator from the back by &lt;code&gt;n&lt;/code&gt; elements. &lt;a href=&quot;../iter/trait.doubleendediterator#method.advance_back_by&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="34bb721017aea2eeaededef2c5c856023eca871d" translate="yes" xml:space="preserve">
          <source>Advances the iterator from the back by &lt;code&gt;n&lt;/code&gt; elements. &lt;a href=&quot;iter/trait.doubleendediterator#method.advance_back_by&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="148c4a64097476a8bb5779b8f3210d3b2962ff05" translate="yes" xml:space="preserve">
          <source>Advances the iterator from the back by &lt;code&gt;n&lt;/code&gt; elements. &lt;a href=&quot;trait.doubleendediterator#method.advance_back_by&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fc5df98fcac936e0dd69b6d3ac4bff062078ea9f" translate="yes" xml:space="preserve">
          <source>After &lt;code&gt;#[test]&lt;/code&gt; we add the &lt;code&gt;#[ignore]&lt;/code&gt; line to the test we want to exclude. Now when we run our tests, &lt;code&gt;it_works&lt;/code&gt; runs, but &lt;code&gt;expensive_test&lt;/code&gt; doesn&amp;rsquo;t:</source>
          <target state="translated">После &lt;code&gt;#[test]&lt;/code&gt; мы добавляем строку &lt;code&gt;#[ignore]&lt;/code&gt; в тест, который хотим исключить. Теперь , когда мы проводим наши тесты, &lt;code&gt;it_works&lt;/code&gt; бежит, но &lt;code&gt;expensive_test&lt;/code&gt; не делает:</target>
        </trans-unit>
        <trans-unit id="471c4d510c078cce605f07ee5e3b57ac50f1448c" translate="yes" xml:space="preserve">
          <source>After &lt;code&gt;crate&lt;/code&gt;, we include each of the successive modules until we make our way to &lt;code&gt;add_to_waitlist&lt;/code&gt;. You can imagine a filesystem with the same structure, and we&amp;rsquo;d specify the path &lt;code&gt;/front_of_house/hosting/add_to_waitlist&lt;/code&gt; to run the &lt;code&gt;add_to_waitlist&lt;/code&gt; program; using the &lt;code&gt;crate&lt;/code&gt; name to start from the crate root is like using &lt;code&gt;/&lt;/code&gt; to start from the filesystem root in your shell.</source>
          <target state="translated">После &lt;code&gt;crate&lt;/code&gt; мы включаем каждый из последующих модулей, пока не &lt;code&gt;add_to_waitlist&lt;/code&gt; до add_to_waitlist . Вы можете представить файловую систему с такой же структурой, и мы должны указать путь &lt;code&gt;/front_of_house/hosting/add_to_waitlist&lt;/code&gt; для запуска программы &lt;code&gt;add_to_waitlist&lt;/code&gt; ; использование имени &lt;code&gt;crate&lt;/code&gt; для запуска из корня ящика аналогично использованию &lt;code&gt;/&lt;/code&gt; для запуска из корня файловой системы в вашей оболочке.</target>
        </trans-unit>
        <trans-unit id="72900f50989a74635a45f599f7af957665be760a" translate="yes" xml:space="preserve">
          <source>After &lt;code&gt;false&lt;/code&gt; is returned, &lt;code&gt;skip_while()&lt;/code&gt;'s job is over, and the rest of the elements are yielded.</source>
          <target state="translated">После того, как будет возвращено &lt;code&gt;false&lt;/code&gt; , &lt;code&gt;skip_while()&lt;/code&gt; , а остальные элементы .</target>
        </trans-unit>
        <trans-unit id="a8fe2c79e763fccf582bfde64f2cf9442ce9db7c" translate="yes" xml:space="preserve">
          <source>After &lt;code&gt;false&lt;/code&gt; is returned, &lt;code&gt;take_while()&lt;/code&gt;'s job is over, and the rest of the elements are ignored.</source>
          <target state="translated">После того, как будет возвращено &lt;code&gt;false&lt;/code&gt; , работа &lt;code&gt;take_while()&lt;/code&gt; , а остальные элементы игнорируются.</target>
        </trans-unit>
        <trans-unit id="d9d86d37284d13e516ed39f67cc2c963b4451b66" translate="yes" xml:space="preserve">
          <source>After &lt;code&gt;leaf&lt;/code&gt; is created, its &lt;code&gt;Rc&amp;lt;Node&amp;gt;&lt;/code&gt; has a strong count of 1 and a weak count of 0. In the inner scope, we create &lt;code&gt;branch&lt;/code&gt; and associate it with &lt;code&gt;leaf&lt;/code&gt;, at which point when we print the counts, the &lt;code&gt;Rc&amp;lt;Node&amp;gt;&lt;/code&gt; in &lt;code&gt;branch&lt;/code&gt; will have a strong count of 1 and a weak count of 1 (for &lt;code&gt;leaf.parent&lt;/code&gt; pointing to &lt;code&gt;branch&lt;/code&gt; with a &lt;code&gt;Weak&amp;lt;Node&amp;gt;&lt;/code&gt;). When we print the counts in &lt;code&gt;leaf&lt;/code&gt;, we&amp;rsquo;ll see it will have a strong count of 2, because &lt;code&gt;branch&lt;/code&gt; now has a clone of the &lt;code&gt;Rc&amp;lt;Node&amp;gt;&lt;/code&gt; of &lt;code&gt;leaf&lt;/code&gt; stored in &lt;code&gt;branch.children&lt;/code&gt;, but will still have a weak count of 0.</source>
          <target state="translated">После создания &lt;code&gt;leaf&lt;/code&gt; его &lt;code&gt;Rc&amp;lt;Node&amp;gt;&lt;/code&gt; имеет сильный счетчик 1 и слабый счетчик 0. Во внутренней области мы создаем &lt;code&gt;branch&lt;/code&gt; и связываем ее с &lt;code&gt;leaf&lt;/code&gt; , после чего, когда мы печатаем счетчики, &lt;code&gt;Rc&amp;lt;Node&amp;gt;&lt;/code&gt; in &lt;code&gt;branch&lt;/code&gt; будет иметь сильное значение 1 и слабое значение 1 (для &lt;code&gt;leaf.parent&lt;/code&gt; , указывающих на &lt;code&gt;branch&lt;/code&gt; с помощью &lt;code&gt;Weak&amp;lt;Node&amp;gt;&lt;/code&gt; ). Когда мы выводим подсчеты в &lt;code&gt;leaf&lt;/code&gt; , мы увидим , что будет иметь сильный счетчик 2, потому что &lt;code&gt;branch&lt;/code&gt; теперь имеет клон &lt;code&gt;Rc&amp;lt;Node&amp;gt;&lt;/code&gt; из &lt;code&gt;leaf&lt;/code&gt; , хранящийся в &lt;code&gt;branch.children&lt;/code&gt; , но по-прежнему будет иметь слабый счетчик 0.</target>
        </trans-unit>
        <trans-unit id="4cde8475e322a79219c56c165831cd534e7a6b56" translate="yes" xml:space="preserve">
          <source>After an iterator returns &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt;, future calls may or may not yield &lt;a href=&quot;../option/enum.option#variant.Some&quot;&gt;&lt;code&gt;Some(T)&lt;/code&gt;&lt;/a&gt; again. &lt;code&gt;fuse()&lt;/code&gt; adapts an iterator, ensuring that after a &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt; is given, it will always return &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt; forever.</source>
          <target state="translated">После того, как итератор вернет &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt; &lt;code&gt;None&lt;/code&gt; &lt;/a&gt; , будущие вызовы могут или не могут снова дать &lt;a href=&quot;../option/enum.option#variant.Some&quot;&gt; &lt;code&gt;Some(T)&lt;/code&gt; &lt;/a&gt; . &lt;code&gt;fuse()&lt;/code&gt; адаптирует итератор, гарантируя, что после &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt; &lt;code&gt;None&lt;/code&gt; &lt;/a&gt; он всегда будет возвращать &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt; &lt;code&gt;None&lt;/code&gt; &lt;/a&gt; навсегда.</target>
        </trans-unit>
        <trans-unit id="568e22b9792d58baafe078fb9cf96ab4d0418d3f" translate="yes" xml:space="preserve">
          <source>After applying this closure to every element of the iterator, &lt;code&gt;fold()&lt;/code&gt; returns the accumulator.</source>
          <target state="translated">После применения этого закрытия к каждому элементу итератора &lt;code&gt;fold()&lt;/code&gt; возвращает аккумулятор.</target>
        </trans-unit>
        <trans-unit id="c5c6fbc1d802b5c2313fc5d60dee8a9485ff2828" translate="yes" xml:space="preserve">
          <source>After applying this closure to every element of the iterator, &lt;code&gt;rfold()&lt;/code&gt; returns the accumulator.</source>
          <target state="translated">После применения этого замыкания к каждому элементу итератора &lt;code&gt;rfold()&lt;/code&gt; возвращает аккумулятор.</target>
        </trans-unit>
        <trans-unit id="dbffd4bfa583f6bbb8aa4395e63df871ca521db4" translate="yes" xml:space="preserve">
          <source>After calling &lt;code&gt;v.as_mut_ptr()&lt;/code&gt; and transmitting the ownership of the data to &lt;code&gt;s&lt;/code&gt;, the &lt;code&gt;v&lt;/code&gt; value is invalid. Even when a value is just moved to &lt;code&gt;mem::forget&lt;/code&gt; (which won't inspect it), some types have strict requirements on their values that make them invalid when dangling or no longer owned. Using invalid values in any way, including passing them to or returning them from functions, constitutes undefined behavior and may break the assumptions made by the compiler.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bc617f1ae4108d460b1173f3a7067fe06a8d7ed6" translate="yes" xml:space="preserve">
          <source>After calling this function, the caller is responsible for the memory previously managed by the &lt;code&gt;Box&lt;/code&gt;. In particular, the caller should properly destroy &lt;code&gt;T&lt;/code&gt; and release the memory, taking into account the &lt;a href=&quot;index#memory-layout&quot;&gt;memory layout&lt;/a&gt; used by &lt;code&gt;Box&lt;/code&gt;. The easiest way to do this is to convert the raw pointer back into a &lt;code&gt;Box&lt;/code&gt; with the &lt;a href=&quot;struct.box#method.from_raw&quot;&gt;&lt;code&gt;Box::from_raw&lt;/code&gt;&lt;/a&gt; function, allowing the &lt;code&gt;Box&lt;/code&gt; destructor to perform the cleanup.</source>
          <target state="translated">После вызова этой функции вызывающая сторона отвечает за память, ранее управляемую &lt;code&gt;Box&lt;/code&gt; . В частности, вызывающий должен правильно уничтожить &lt;code&gt;T&lt;/code&gt; и освободить память с учетом структуры &lt;a href=&quot;index#memory-layout&quot;&gt;памяти,&lt;/a&gt; используемой &lt;code&gt;Box&lt;/code&gt; . Самый простой способ сделать это - преобразовать необработанный указатель обратно в &lt;code&gt;Box&lt;/code&gt; с помощью функции &lt;a href=&quot;struct.box#method.from_raw&quot;&gt; &lt;code&gt;Box::from_raw&lt;/code&gt; &lt;/a&gt; , что позволит деструктору &lt;code&gt;Box&lt;/code&gt; выполнить очистку.</target>
        </trans-unit>
        <trans-unit id="7cad9f1c8273ecabd3f00d51212a63d92e2f707f" translate="yes" xml:space="preserve">
          <source>After calling this function, the caller is responsible for the memory previously managed by the &lt;code&gt;Box&lt;/code&gt;. In particular, the caller should properly destroy &lt;code&gt;T&lt;/code&gt; and release the memory, taking into account the &lt;a href=&quot;index#memory-layout&quot;&gt;memory layout&lt;/a&gt; used by &lt;code&gt;Box&lt;/code&gt;. The easiest way to do this is to convert the raw pointer back into a &lt;code&gt;Box&lt;/code&gt; with the &lt;a href=&quot;struct.box#method.from_raw_in&quot;&gt;&lt;code&gt;Box::from_raw_in&lt;/code&gt;&lt;/a&gt; function, allowing the &lt;code&gt;Box&lt;/code&gt; destructor to perform the cleanup.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="47bfd04ad6639821cf514c2ef1fb0d7b6f63839d" translate="yes" xml:space="preserve">
          <source>After calling this function, the caller is responsible for the memory previously managed by the &lt;code&gt;Box&lt;/code&gt;. In particular, the caller should properly destroy &lt;code&gt;T&lt;/code&gt; and release the memory. The easiest way to do so is to convert the &lt;code&gt;NonNull&amp;lt;T&amp;gt;&lt;/code&gt; pointer into a raw pointer and back into a &lt;code&gt;Box&lt;/code&gt; with the &lt;a href=&quot;struct.box#method.from_raw&quot;&gt;&lt;code&gt;Box::from_raw&lt;/code&gt;&lt;/a&gt; function.</source>
          <target state="translated">После вызова этой функции вызывающая сторона отвечает за память, ранее управляемую &lt;code&gt;Box&lt;/code&gt; . В частности, вызывающий должен правильно уничтожить &lt;code&gt;T&lt;/code&gt; и освободить память. Самый простой способ сделать это - преобразовать &lt;code&gt;NonNull&amp;lt;T&amp;gt;&lt;/code&gt; в необработанный указатель и обратно в &lt;code&gt;Box&lt;/code&gt; с помощью функции &lt;a href=&quot;struct.box#method.from_raw&quot;&gt; &lt;code&gt;Box::from_raw&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="4e43a947242c53bd7c33db133c10548b5bd4c117" translate="yes" xml:space="preserve">
          <source>After calling this function, the caller is responsible for the memory previously managed by the &lt;code&gt;String&lt;/code&gt;. The only way to do this is to convert the raw pointer, length, and capacity back into a &lt;code&gt;String&lt;/code&gt; with the &lt;a href=&quot;struct.string#method.from_raw_parts&quot;&gt;&lt;code&gt;from_raw_parts&lt;/code&gt;&lt;/a&gt; function, allowing the destructor to perform the cleanup.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="102d1de8629b57b21dac90f6d521b49048558b05" translate="yes" xml:space="preserve">
          <source>After calling this function, the caller is responsible for the memory previously managed by the &lt;code&gt;Vec&lt;/code&gt;. The only way to do this is to convert the raw pointer, length, and capacity back into a &lt;code&gt;Vec&lt;/code&gt; with the &lt;a href=&quot;struct.vec#method.from_raw_parts&quot;&gt;&lt;code&gt;from_raw_parts&lt;/code&gt;&lt;/a&gt; function, allowing the destructor to perform the cleanup.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="abe8789d4d89fe16b0db6cdf88a765be8535c340" translate="yes" xml:space="preserve">
          <source>After calling this function, the caller is responsible for the memory previously managed by the &lt;code&gt;Vec&lt;/code&gt;. The only way to do this is to convert the raw pointer, length, and capacity back into a &lt;code&gt;Vec&lt;/code&gt; with the &lt;a href=&quot;struct.vec#method.from_raw_parts_in&quot;&gt;&lt;code&gt;from_raw_parts_in&lt;/code&gt;&lt;/a&gt; function, allowing the destructor to perform the cleanup.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3d10c7bbc7ba580c584a70857a59b76ef027af83" translate="yes" xml:space="preserve">
          <source>After calling this function, the raw pointer is owned by the resulting &lt;code&gt;Box&lt;/code&gt;. Specifically, the &lt;code&gt;Box&lt;/code&gt; destructor will call the destructor of &lt;code&gt;T&lt;/code&gt; and free the allocated memory. For this to be safe, the memory must have been allocated in accordance with the &lt;a href=&quot;index#memory-layout&quot;&gt;memory layout&lt;/a&gt; used by &lt;code&gt;Box&lt;/code&gt; .</source>
          <target state="translated">После вызова этой функции необработанный указатель принадлежит результирующему &lt;code&gt;Box&lt;/code&gt; . В частности, деструктор &lt;code&gt;Box&lt;/code&gt; вызовет деструктор &lt;code&gt;T&lt;/code&gt; и освободит выделенную память. Чтобы это было безопасно, память должна быть выделена в соответствии со &lt;a href=&quot;index#memory-layout&quot;&gt;схемой памяти,&lt;/a&gt; используемой &lt;code&gt;Box&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ef76ea7ae2deed3f017eb7251cbd0d7c334a7aaf" translate="yes" xml:space="preserve">
          <source>After changing &lt;code&gt;println!&lt;/code&gt; to &lt;code&gt;eprintln!&lt;/code&gt;, let&amp;rsquo;s run the program again in the same way, without any arguments and redirecting standard output with &lt;code&gt;&amp;gt;&lt;/code&gt;:</source>
          <target state="translated">После изменения &lt;code&gt;println!&lt;/code&gt; в &lt;code&gt;eprintln!&lt;/code&gt; , давайте снова запустим программу таким же образом, без аргументов и перенаправляя стандартный вывод с помощью &lt;code&gt;&amp;gt;&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="93133f68d39862996d0135a231d1905a95e950c2" translate="yes" xml:space="preserve">
          <source>After creating a &lt;code&gt;TcpListener&lt;/code&gt; by &lt;a href=&quot;#method.bind&quot;&gt;&lt;code&gt;bind&lt;/code&gt;&lt;/a&gt;ing it to a socket address, it listens for incoming TCP connections. These can be accepted by calling &lt;a href=&quot;#method.accept&quot;&gt;&lt;code&gt;accept&lt;/code&gt;&lt;/a&gt; or by iterating over the &lt;a href=&quot;struct.incoming&quot;&gt;&lt;code&gt;Incoming&lt;/code&gt;&lt;/a&gt; iterator returned by &lt;a href=&quot;#method.incoming&quot;&gt;&lt;code&gt;incoming&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">После создания &lt;code&gt;TcpListener&lt;/code&gt; путем &lt;a href=&quot;#method.bind&quot;&gt; &lt;code&gt;bind&lt;/code&gt; &lt;/a&gt; ING его в адрес сокета, он прослушивает входящие соединения TCP. Их можно принять, вызвав &lt;a href=&quot;#method.accept&quot;&gt; &lt;code&gt;accept&lt;/code&gt; &lt;/a&gt; или перебрав итератор &lt;a href=&quot;struct.incoming&quot;&gt; &lt;code&gt;Incoming&lt;/code&gt; ,&lt;/a&gt; возвращаемый &lt;a href=&quot;#method.incoming&quot;&gt; &lt;code&gt;incoming&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="06868983dd9010816d16a947a2feebe64fc6c151" translate="yes" xml:space="preserve">
          <source>After creating a &lt;code&gt;TcpListener&lt;/code&gt; by &lt;a href=&quot;struct.tcplistener#method.bind&quot;&gt;&lt;code&gt;bind&lt;/code&gt;&lt;/a&gt;ing it to a socket address, it listens for incoming TCP connections. These can be accepted by calling &lt;a href=&quot;struct.tcplistener#method.accept&quot;&gt;&lt;code&gt;accept&lt;/code&gt;&lt;/a&gt; or by iterating over the &lt;a href=&quot;struct.incoming&quot;&gt;&lt;code&gt;Incoming&lt;/code&gt;&lt;/a&gt; iterator returned by &lt;a href=&quot;struct.tcplistener#method.incoming&quot;&gt;&lt;code&gt;incoming&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="422e2b7f3798df18a9e41b4f6d8230c5f7fbaae2" translate="yes" xml:space="preserve">
          <source>After creating a &lt;code&gt;TcpStream&lt;/code&gt; by either &lt;a href=&quot;#method.connect&quot;&gt;&lt;code&gt;connect&lt;/code&gt;&lt;/a&gt;ing to a remote host or &lt;a href=&quot;struct.tcplistener#method.accept&quot;&gt;&lt;code&gt;accept&lt;/code&gt;&lt;/a&gt;ing a connection on a &lt;a href=&quot;struct.tcplistener&quot;&gt;&lt;code&gt;TcpListener&lt;/code&gt;&lt;/a&gt;, data can be transmitted by &lt;a href=&quot;../io/trait.read&quot;&gt;reading&lt;/a&gt; and &lt;a href=&quot;../io/trait.write&quot;&gt;writing&lt;/a&gt; to it.</source>
          <target state="translated">После создания &lt;code&gt;TcpStream&lt;/code&gt; путем &lt;a href=&quot;#method.connect&quot;&gt; &lt;code&gt;connect&lt;/code&gt; &lt;/a&gt; к удаленному хосту или &lt;a href=&quot;struct.tcplistener#method.accept&quot;&gt; &lt;code&gt;accept&lt;/code&gt; &lt;/a&gt; соединения на &lt;a href=&quot;struct.tcplistener&quot;&gt; &lt;code&gt;TcpListener&lt;/code&gt; &lt;/a&gt; данные могут передаваться путем &lt;a href=&quot;../io/trait.read&quot;&gt;чтения&lt;/a&gt; и &lt;a href=&quot;../io/trait.write&quot;&gt;записи&lt;/a&gt; в него.</target>
        </trans-unit>
        <trans-unit id="dafc89a72358e6711ac4be0166b7dcfdffe57a68" translate="yes" xml:space="preserve">
          <source>After creating a &lt;code&gt;TcpStream&lt;/code&gt; by either &lt;a href=&quot;struct.tcpstream#method.connect&quot;&gt;&lt;code&gt;connect&lt;/code&gt;&lt;/a&gt;ing to a remote host or &lt;a href=&quot;struct.tcplistener#method.accept&quot;&gt;&lt;code&gt;accept&lt;/code&gt;&lt;/a&gt;ing a connection on a &lt;a href=&quot;struct.tcplistener&quot;&gt;&lt;code&gt;TcpListener&lt;/code&gt;&lt;/a&gt;, data can be transmitted by &lt;a href=&quot;../io/trait.read&quot;&gt;reading&lt;/a&gt; and &lt;a href=&quot;../io/trait.write&quot;&gt;writing&lt;/a&gt; to it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b9be232588db8403f71ee1411aa554678f33dfa7" translate="yes" xml:space="preserve">
          <source>After creating a &lt;code&gt;UdpSocket&lt;/code&gt; by &lt;a href=&quot;#method.bind&quot;&gt;&lt;code&gt;bind&lt;/code&gt;&lt;/a&gt;ing it to a socket address, data can be &lt;a href=&quot;#method.send_to&quot;&gt;sent to&lt;/a&gt; and &lt;a href=&quot;#method.recv_from&quot;&gt;received from&lt;/a&gt; any other socket address.</source>
          <target state="translated">После создания &lt;code&gt;UdpSocket&lt;/code&gt; путем &lt;a href=&quot;#method.bind&quot;&gt; &lt;code&gt;bind&lt;/code&gt; &lt;/a&gt; его к адресу сокета, данные могут быть &lt;a href=&quot;#method.send_to&quot;&gt;отправлены&lt;/a&gt; и &lt;a href=&quot;#method.recv_from&quot;&gt;получены с&lt;/a&gt; любого другого адреса сокета.</target>
        </trans-unit>
        <trans-unit id="394b482d2eb5a6a4fcc8d7fdff6cfe2cd24f75e2" translate="yes" xml:space="preserve">
          <source>After creating a &lt;code&gt;UdpSocket&lt;/code&gt; by &lt;a href=&quot;struct.udpsocket#method.bind&quot;&gt;&lt;code&gt;bind&lt;/code&gt;&lt;/a&gt;ing it to a socket address, data can be &lt;a href=&quot;struct.udpsocket#method.send_to&quot;&gt;sent to&lt;/a&gt; and &lt;a href=&quot;struct.udpsocket#method.recv_from&quot;&gt;received from&lt;/a&gt; any other socket address.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3fc506cb877752d66797eaa2996ad1bfc89765b7" translate="yes" xml:space="preserve">
          <source>After creating a new &lt;code&gt;Job&lt;/code&gt; instance using the closure we get in &lt;code&gt;execute&lt;/code&gt;, we send that job down the sending end of the channel. We&amp;rsquo;re calling &lt;code&gt;unwrap&lt;/code&gt; on &lt;code&gt;send&lt;/code&gt; for the case that sending fails. This might happen if, for example, we stop all our threads from executing, meaning the receiving end has stopped receiving new messages. At the moment, we can&amp;rsquo;t stop our threads from executing: our threads continue executing as long as the pool exists. The reason we use &lt;code&gt;unwrap&lt;/code&gt; is that we know the failure case won&amp;rsquo;t happen, but the compiler doesn&amp;rsquo;t know that.</source>
          <target state="translated">После создания нового экземпляра &lt;code&gt;Job&lt;/code&gt; с использованием замыкания, которое мы получаем в &lt;code&gt;execute&lt;/code&gt; , мы отправляем это задание на отправляющий конец канала. Мы вызываем &lt;code&gt;unwrap&lt;/code&gt; при &lt;code&gt;send&lt;/code&gt; в случае сбоя отправки. Это может произойти, если, например, мы остановим выполнение всех наших потоков, что означает, что принимающая сторона перестала получать новые сообщения. На данный момент мы не можем остановить выполнение наших потоков: наши потоки продолжают выполняться, пока существует пул. Причина, по которой мы используем &lt;code&gt;unwrap&lt;/code&gt; заключается в том, что мы знаем, что сбоя не произойдет, но компилятор этого не знает.</target>
        </trans-unit>
        <trans-unit id="458779f7008edf7b181827b22b99edf77f39bc41" translate="yes" xml:space="preserve">
          <source>After dropping the lock, we can print the mutex value and see that we were able to change the inner &lt;code&gt;i32&lt;/code&gt; to 6.</source>
          <target state="translated">После снятия блокировки мы можем распечатать значение мьютекса и увидеть, что мы смогли изменить внутренний &lt;code&gt;i32&lt;/code&gt; на 6.</target>
        </trans-unit>
        <trans-unit id="04760e628105c26e60bea171285ea7fc05de2cc2" translate="yes" xml:space="preserve">
          <source>After implementing the trait, we can call the methods on instances of &lt;code&gt;NewsArticle&lt;/code&gt; and &lt;code&gt;Tweet&lt;/code&gt; in the same way we call regular methods, like this:</source>
          <target state="translated">После реализации трейта мы можем вызывать методы экземпляров &lt;code&gt;NewsArticle&lt;/code&gt; и &lt;code&gt;Tweet&lt;/code&gt; так же, как мы вызываем обычные методы, например:</target>
        </trans-unit>
        <trans-unit id="6aee078dffc9ca07e378d1b98649828937e42093" translate="yes" xml:space="preserve">
          <source>After learning about the &lt;code&gt;while let&lt;/code&gt; loop in Chapter 18, you might be wondering why we didn&amp;rsquo;t write the worker thread code as shown in Listing 20-21.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5a81464f303d05310b655ad576139ba2eadc374a" translate="yes" xml:space="preserve">
          <source>After learning about the &lt;code&gt;while let&lt;/code&gt; loop in Chapter 18, you might be wondering why we didn&amp;rsquo;t write the worker thread code as shown in Listing 20-22.</source>
          <target state="translated">Узнав о цикле &lt;code&gt;while let&lt;/code&gt; в главе 18, вы можете задаться вопросом, почему мы не написали код рабочего потока, как показано в листинге 20-22.</target>
        </trans-unit>
        <trans-unit id="56e7d653965ec5efdfa2c953ebd2075ad09eb04a" translate="yes" xml:space="preserve">
          <source>After running the code, the precedence behavior is evident: if the match guard were applied only to the final value in the list of values specified using the &lt;code&gt;|&lt;/code&gt; operator, the arm would have matched and the program would have printed &lt;code&gt;yes&lt;/code&gt;.</source>
          <target state="translated">После запуска кода поведение приоритета становится очевидным: если защита совпадения применялась только к последнему значению в списке значений, указанном с помощью &lt;code&gt;|&lt;/code&gt; оператор, рука совпала бы, и программа напечатала бы &lt;code&gt;yes&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6918a63768fd69dd2401af6cba199a57c7c6b4f3" translate="yes" xml:space="preserve">
          <source>After some time, once Rust developers who use nightly releases have been able to try out the new feature, team members will discuss the feature, how it&amp;rsquo;s worked out on nightly, and decide if it should make it into stable Rust or not. If the decision is to move forward, the feature gate is removed, and the feature is now considered stable! It rides the trains into a new stable release of Rust.</source>
          <target state="translated">По прошествии некоторого времени, когда разработчики Rust, использующие ночные выпуски, смогут опробовать новую функцию, члены команды обсудят эту функцию, как она работает по ночам, и решат, должна ли она превратиться в стабильный Rust или нет. Если будет принято решение двигаться вперед, ворота функций удаляются, и теперь функция считается стабильной! Он переводит поезда в новую стабильную версию Rust.</target>
        </trans-unit>
        <trans-unit id="780f735c7776bf172259bb14b7f1d801e95b8329" translate="yes" xml:space="preserve">
          <source>After that statement, we&amp;rsquo;ve again added a temporary &lt;code&gt;println!&lt;/code&gt; statement that prints the value of &lt;code&gt;contents&lt;/code&gt; after the file is read, so we can check that the program is working so far.</source>
          <target state="translated">После этого оператора мы снова добавили временный &lt;code&gt;println!&lt;/code&gt; оператор, который печатает значение &lt;code&gt;contents&lt;/code&gt; после чтения файла, чтобы мы могли проверить, работает ли программа на данный момент.</target>
        </trans-unit>
        <trans-unit id="96e831200e66693625317e3844fc1e89f068a7a9" translate="yes" xml:space="preserve">
          <source>After the method signature, instead of providing an implementation within curly brackets, we use a semicolon. Each type implementing this trait must provide its own custom behavior for the body of the method. The compiler will enforce that any type that has the &lt;code&gt;Summary&lt;/code&gt; trait will have the method &lt;code&gt;summarize&lt;/code&gt; defined with this signature exactly.</source>
          <target state="translated">После подписи метода вместо предоставления реализации в фигурных скобках мы используем точку с запятой. Каждый тип, реализующий эту черту, должен предоставлять собственное настраиваемое поведение для тела метода. Компилятор будет обеспечивать, чтобы любой тип, имеющий черту &lt;code&gt;Summary&lt;/code&gt; , имел метод &lt;code&gt;summarize&lt;/code&gt; , определенный именно с этой сигнатурой.</target>
        </trans-unit>
        <trans-unit id="fd61e6cd4b0dca5587c3bdc8b19a36c54df5d01a" translate="yes" xml:space="preserve">
          <source>After the parameters, we place curly brackets that hold the body of the closure&amp;mdash;these are optional if the closure body is a single expression. The end of the closure, after the curly brackets, needs a semicolon to complete the &lt;code&gt;let&lt;/code&gt; statement. The value returned from the last line in the closure body (&lt;code&gt;num&lt;/code&gt;) will be the value returned from the closure when it&amp;rsquo;s called, because that line doesn&amp;rsquo;t end in a semicolon; just as in function bodies.</source>
          <target state="translated">После параметров мы помещаем фигурные скобки, которые удерживают тело замыкания - это необязательно, если тело замыкания представляет собой одно выражение. В конце замыкания после фигурных скобок необходимо поставить точку с запятой для завершения оператора &lt;code&gt;let&lt;/code&gt; . Значение, возвращаемое из последней строки в теле замыкания ( &lt;code&gt;num&lt;/code&gt; ), будет значением, возвращаемым замыканием при его вызове, потому что эта строка не заканчивается точкой с запятой; так же, как в функциональных телах.</target>
        </trans-unit>
        <trans-unit id="3409f581311196341ada32cc2fb23895a79e2d64" translate="yes" xml:space="preserve">
          <source>After the request line, the remaining lines starting from &lt;code&gt;Host:&lt;/code&gt; onward are headers. &lt;code&gt;GET&lt;/code&gt; requests have no body.</source>
          <target state="translated">После строки запроса оставшиеся строки, начиная с &lt;code&gt;Host:&lt;/code&gt; и далее, являются заголовками. Запросы &lt;code&gt;GET&lt;/code&gt; не имеют тела.</target>
        </trans-unit>
        <trans-unit id="94ada77990e54a7199b314d48e7c28b8866c26f5" translate="yes" xml:space="preserve">
          <source>After these two lines, &lt;code&gt;s&lt;/code&gt; will contain &lt;code&gt;foobar&lt;/code&gt;. The &lt;code&gt;push_str&lt;/code&gt; method takes a string slice because we don&amp;rsquo;t necessarily want to take ownership of the parameter. For example, the code in Listing 8-16 shows that it would be unfortunate if we weren&amp;rsquo;t able to use &lt;code&gt;s2&lt;/code&gt; after appending its contents to &lt;code&gt;s1&lt;/code&gt;.</source>
          <target state="translated">После этих двух строк &lt;code&gt;s&lt;/code&gt; будет содержать &lt;code&gt;foobar&lt;/code&gt; . Метод &lt;code&gt;push_str&lt;/code&gt; принимает фрагмент строки, потому что мы не обязательно хотим владеть параметром. Например, код в листинге 8-16 показывает, что было бы неудачно, если бы мы не смогли использовать &lt;code&gt;s2&lt;/code&gt; после добавления его содержимого в &lt;code&gt;s1&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d28bc7bf7124bb617821696b52f238bf37faf9be" translate="yes" xml:space="preserve">
          <source>After they have been consumed, the rest of the elements are yielded. Rather than overriding this method directly, instead override the &lt;code&gt;nth&lt;/code&gt; method.</source>
          <target state="translated">После того, как они были израсходованы, остальные элементы сдаются. Вместо того, чтобы напрямую переопределять этот метод, вместо этого переопределите &lt;code&gt;nth&lt;/code&gt; метод.</target>
        </trans-unit>
        <trans-unit id="d1a8c993e11b907a98ea3122f628acdebbd6b42e" translate="yes" xml:space="preserve">
          <source>After updating the registry, Cargo checks the &lt;code&gt;[dependencies]&lt;/code&gt; section and downloads any crates you don&amp;rsquo;t have yet. In this case, although we only listed &lt;code&gt;rand&lt;/code&gt; as a dependency, Cargo also grabbed &lt;code&gt;libc&lt;/code&gt; and &lt;code&gt;rand_core&lt;/code&gt;, because &lt;code&gt;rand&lt;/code&gt; depends on those to work. After downloading the crates, Rust compiles them and then compiles the project with the dependencies available.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="17378b2abc480d099ee902b5db16470e7091ec08" translate="yes" xml:space="preserve">
          <source>After updating the registry, Cargo checks the &lt;code&gt;[dependencies]&lt;/code&gt; section and downloads any crates you don&amp;rsquo;t have yet. In this case, although we only listed &lt;code&gt;rand&lt;/code&gt; as a dependency, Cargo also grabbed a copy of &lt;code&gt;libc&lt;/code&gt;, because &lt;code&gt;rand&lt;/code&gt; depends on &lt;code&gt;libc&lt;/code&gt; to work. After downloading the crates, Rust compiles them and then compiles the project with the dependencies available.</source>
          <target state="translated">После обновления реестра Cargo проверяет раздел &lt;code&gt;[dependencies]&lt;/code&gt; и загружает все ящики, которых у вас еще нет. В этом случае, хотя мы указали только &lt;code&gt;rand&lt;/code&gt; как зависимость, Cargo также получил копию &lt;code&gt;libc&lt;/code&gt; , потому что работа &lt;code&gt;rand&lt;/code&gt; зависит от &lt;code&gt;libc&lt;/code&gt; . После загрузки ящиков Rust компилирует их, а затем компилирует проект с доступными зависимостями.</target>
        </trans-unit>
        <trans-unit id="9d98c1489e41fbd88598871e5f8d212bbc3f78c5" translate="yes" xml:space="preserve">
          <source>After we define &lt;code&gt;summarize_author&lt;/code&gt;, we can call &lt;code&gt;summarize&lt;/code&gt; on instances of the &lt;code&gt;Tweet&lt;/code&gt; struct, and the default implementation of &lt;code&gt;summarize&lt;/code&gt; will call the definition of &lt;code&gt;summarize_author&lt;/code&gt; that we&amp;rsquo;ve provided. Because we&amp;rsquo;ve implemented &lt;code&gt;summarize_author&lt;/code&gt;, the &lt;code&gt;Summary&lt;/code&gt; trait has given us the behavior of the &lt;code&gt;summarize&lt;/code&gt; method without requiring us to write any more code.</source>
          <target state="translated">После определения &lt;code&gt;summarize_author&lt;/code&gt; мы можем вызвать &lt;code&gt;summarize&lt;/code&gt; для экземпляров структуры &lt;code&gt;Tweet&lt;/code&gt; , а реализация &lt;code&gt;summarize&lt;/code&gt; по умолчанию будет вызывать определение &lt;code&gt;summarize_author&lt;/code&gt; , которое мы предоставили. Поскольку мы реализовали &lt;code&gt;summarize_author&lt;/code&gt; , черта &lt;code&gt;Summary&lt;/code&gt; дала нам поведение метода &lt;code&gt;summarize&lt;/code&gt; , не требуя написания дополнительного кода.</target>
        </trans-unit>
        <trans-unit id="2556b8fd31ff1260ec94fc2ed10873de0af61a38" translate="yes" xml:space="preserve">
          <source>After we&amp;rsquo;ve acquired the lock, we can treat the return value, named &lt;code&gt;num&lt;/code&gt; in this case, as a mutable reference to the data inside. The type system ensures that we acquire a lock before using the value in &lt;code&gt;m&lt;/code&gt;: &lt;code&gt;Mutex&amp;lt;i32&amp;gt;&lt;/code&gt; is not an &lt;code&gt;i32&lt;/code&gt;, so we &lt;em&gt;must&lt;/em&gt; acquire the lock to be able to use the &lt;code&gt;i32&lt;/code&gt; value. We can&amp;rsquo;t forget; the type system won&amp;rsquo;t let us access the inner &lt;code&gt;i32&lt;/code&gt; otherwise.</source>
          <target state="translated">После того, как мы установили блокировку, мы можем рассматривать возвращаемое значение, в данном случае &lt;code&gt;num&lt;/code&gt; , как изменяемую ссылку на данные внутри. Система типов гарантирует, что мы получим блокировку перед использованием значения в &lt;code&gt;m&lt;/code&gt; : &lt;code&gt;Mutex&amp;lt;i32&amp;gt;&lt;/code&gt; не является &lt;code&gt;i32&lt;/code&gt; , поэтому мы &lt;em&gt;должны&lt;/em&gt; получить блокировку, чтобы иметь возможность использовать значение &lt;code&gt;i32&lt;/code&gt; . Мы не можем забыть; В противном случае система типов не позволит нам получить доступ к внутреннему &lt;code&gt;i32&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="eea76bdbc5658f7fad1ad625716859e45f8c384f" translate="yes" xml:space="preserve">
          <source>After we&amp;rsquo;ve created &lt;em&gt;tests/common/mod.rs&lt;/em&gt;, we can use it from any of the integration test files as a module. Here&amp;rsquo;s an example of calling the &lt;code&gt;setup&lt;/code&gt; function from the &lt;code&gt;it_adds_two&lt;/code&gt; test in &lt;em&gt;tests/integration_test.rs&lt;/em&gt;:</source>
          <target state="translated">После того, как мы создали &lt;em&gt;tests / common / mod.rs&lt;/em&gt; , мы можем использовать его из любого файла интеграционного теста в качестве модуля. Вот пример вызова функции &lt;code&gt;setup&lt;/code&gt; из теста &lt;code&gt;it_adds_two&lt;/code&gt; в &lt;em&gt;tests / integration_test.rs&lt;/em&gt; :</target>
        </trans-unit>
        <trans-unit id="43dc84fb12e1a579a9d73c911c37d0ab1b82a9f5" translate="yes" xml:space="preserve">
          <source>After we&amp;rsquo;ve created the lists in &lt;code&gt;a&lt;/code&gt;, &lt;code&gt;b&lt;/code&gt;, and &lt;code&gt;c&lt;/code&gt;, we add 10 to the value in &lt;code&gt;value&lt;/code&gt;. We do this by calling &lt;code&gt;borrow_mut&lt;/code&gt; on &lt;code&gt;value&lt;/code&gt;, which uses the automatic dereferencing feature we discussed in Chapter 5 (see the section &lt;a href=&quot;ch05-03-method-syntax#wheres-the---operator&quot;&gt;&amp;ldquo;Where&amp;rsquo;s the &lt;code&gt;-&amp;gt;&lt;/code&gt; Operator?&amp;rdquo;&lt;/a&gt;) to dereference the &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; to the inner &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt; value. The &lt;code&gt;borrow_mut&lt;/code&gt; method returns a &lt;code&gt;RefMut&amp;lt;T&amp;gt;&lt;/code&gt; smart pointer, and we use the dereference operator on it and change the inner value.</source>
          <target state="translated">После того, как мы создали списки в &lt;code&gt;a&lt;/code&gt; , &lt;code&gt;b&lt;/code&gt; и &lt;code&gt;c&lt;/code&gt; , мы добавляем 10 к значению &lt;code&gt;value&lt;/code&gt; . Мы делаем это, вызывая &lt;code&gt;borrow_mut&lt;/code&gt; по &lt;code&gt;value&lt;/code&gt; , который использует функцию автоматического разыменования, которую мы обсуждали в главе 5 (см. Раздел &lt;a href=&quot;ch05-03-method-syntax#wheres-the---operator&quot;&gt;&amp;laquo;Где находится оператор &lt;code&gt;-&amp;gt;&lt;/code&gt; ?&amp;raquo;&lt;/a&gt; ), Чтобы разыменовать &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; на внутреннее значение &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt; . Метод &lt;code&gt;borrow_mut&lt;/code&gt; возвращает умный указатель &lt;code&gt;RefMut&amp;lt;T&amp;gt;&lt;/code&gt; , и мы используем для него оператор разыменования и меняем внутреннее значение.</target>
        </trans-unit>
        <trans-unit id="b18bd157b258782bdf4328d729095843e56901f9" translate="yes" xml:space="preserve">
          <source>After writing a lot of Rust code, the Rust team found that Rust programmers were entering the same lifetime annotations over and over in particular situations. These situations were predictable and followed a few deterministic patterns. The developers programmed these patterns into the compiler&amp;rsquo;s code so the borrow checker could infer the lifetimes in these situations and wouldn&amp;rsquo;t need explicit annotations.</source>
          <target state="translated">После написания большого количества кода Rust команда Rust обнаружила, что программисты на Rust вводят одни и те же аннотации времени жизни снова и снова в определенных ситуациях. Эти ситуации были предсказуемыми и следовали нескольким детерминированным моделям. Разработчики запрограммировали эти шаблоны в код компилятора, чтобы средство проверки заимствований могло вывести время жизни в этих ситуациях и не нуждалось в явных аннотациях.</target>
        </trans-unit>
        <trans-unit id="8911f4e8942ad7726d100e32781ae750b7e4baf7" translate="yes" xml:space="preserve">
          <source>After you&amp;rsquo;ve installed Rust via &lt;code&gt;rustup&lt;/code&gt;, updating to the latest version is easy. From your shell, run the following update script:</source>
          <target state="translated">После того, как вы установили Rust через &lt;code&gt;rustup&lt;/code&gt; , выполнить обновление до последней версии очень просто. Из своей оболочки запустите следующий скрипт обновления:</target>
        </trans-unit>
        <trans-unit id="13f2d652f70945cb85fc5562fc3600a535ffb359" translate="yes" xml:space="preserve">
          <source>After:</source>
          <target state="translated">After:</target>
        </trans-unit>
        <trans-unit id="1d0c9f96248d537407790c171b6d4f7cd1fd7157" translate="yes" xml:space="preserve">
          <source>Again, this is the simplest implementation of the &lt;code&gt;execute&lt;/code&gt; method: it does nothing, but we&amp;rsquo;re trying only to make our code compile. Let&amp;rsquo;s check it again:</source>
          <target state="translated">Опять же, это простейшая реализация метода &lt;code&gt;execute&lt;/code&gt; : он ничего не делает, но мы пытаемся только скомпилировать наш код. Проверим еще раз:</target>
        </trans-unit>
        <trans-unit id="7b6d0c4005bedf77e43140c67158dc3c2786f272" translate="yes" xml:space="preserve">
          <source>Again, we&amp;rsquo;re using &lt;code&gt;thread::spawn&lt;/code&gt; to create a new thread and then using &lt;code&gt;move&lt;/code&gt; to move &lt;code&gt;tx&lt;/code&gt; into the closure so the spawned thread owns &lt;code&gt;tx&lt;/code&gt;. The spawned thread needs to own the transmitting end of the channel to be able to send messages through the channel.</source>
          <target state="translated">Опять же, мы используем &lt;code&gt;thread::spawn&lt;/code&gt; для создания нового потока, а затем используем &lt;code&gt;move&lt;/code&gt; для перемещения &lt;code&gt;tx&lt;/code&gt; в замыкание, чтобы порожденный поток владел &lt;code&gt;tx&lt;/code&gt; . Созданный поток должен владеть передающим концом канала, чтобы иметь возможность отправлять сообщения через канал.</target>
        </trans-unit>
        <trans-unit id="42935bf9ba7e07a25a52edfb6e2d38809a0c1bab" translate="yes" xml:space="preserve">
          <source>Again, you need not specify the full type if the compiler can infer it:</source>
          <target state="translated">Опять же,не нужно указывать полный тип,если компилятор может его вывести:</target>
        </trans-unit>
        <trans-unit id="3cc0e9834230ccbe94275d501fa3b8e31c8d1c62" translate="yes" xml:space="preserve">
          <source>Aha! The first error message indicates that &lt;code&gt;counter&lt;/code&gt; is moved into the closure for the thread associated with &lt;code&gt;handle&lt;/code&gt;. That move is preventing us from capturing &lt;code&gt;counter&lt;/code&gt; when we try to call &lt;code&gt;lock&lt;/code&gt; on it and store the result in &lt;code&gt;num2&lt;/code&gt; in the second thread! So Rust is telling us that we can&amp;rsquo;t move ownership of &lt;code&gt;counter&lt;/code&gt; into multiple threads. This was hard to see earlier because our threads were in a loop, and Rust can&amp;rsquo;t point to different threads in different iterations of the loop. Let&amp;rsquo;s fix the compiler error with a multiple-ownership method we discussed in Chapter 15.</source>
          <target state="translated">Ага! Первое сообщение об ошибке указывает, что &lt;code&gt;counter&lt;/code&gt; перемещен в закрытие для потока, связанного с &lt;code&gt;handle&lt;/code&gt; . Этот ход не позволяет нам захватить &lt;code&gt;counter&lt;/code&gt; когда мы пытаемся вызвать на нем &lt;code&gt;lock&lt;/code&gt; и сохранить результат в &lt;code&gt;num2&lt;/code&gt; во втором потоке! Итак, Rust сообщает нам, что мы не можем передать владение &lt;code&gt;counter&lt;/code&gt; нескольким потокам. Раньше это было трудно увидеть, потому что наши потоки были в цикле, а Rust не мог указывать на разные потоки в разных итерациях цикла. Давайте исправим ошибку компилятора с помощью метода множественного владения, который мы обсуждали в главе 15.</target>
        </trans-unit>
        <trans-unit id="7f8c5176c3f03b97659161923f2b6492f7de7e73" translate="yes" xml:space="preserve">
          <source>Alignment</source>
          <target state="translated">Alignment</target>
        </trans-unit>
        <trans-unit id="6c230b19ce360dc47ab1f803ec5d75221398ff9e" translate="yes" xml:space="preserve">
          <source>Alignment::borrow</source>
          <target state="translated">Alignment::borrow</target>
        </trans-unit>
        <trans-unit id="77b6c3d761057550ac535096603085a4ab21f25d" translate="yes" xml:space="preserve">
          <source>Alignment::borrow_mut</source>
          <target state="translated">Alignment::borrow_mut</target>
        </trans-unit>
        <trans-unit id="d45a68b20b4cc6114f5421add49178bf870ce27b" translate="yes" xml:space="preserve">
          <source>Alignment::fmt</source>
          <target state="translated">Alignment::fmt</target>
        </trans-unit>
        <trans-unit id="0912a9a905355e3a6df915cce4fce3e26fba4e82" translate="yes" xml:space="preserve">
          <source>Alignment::from</source>
          <target state="translated">Alignment::from</target>
        </trans-unit>
        <trans-unit id="14750a6b1eb92c0620b2d52bd702a109608e9cb3" translate="yes" xml:space="preserve">
          <source>Alignment::into</source>
          <target state="translated">Alignment::into</target>
        </trans-unit>
        <trans-unit id="b06fe916f5f193304938aca87ce9baf4fe4a81c0" translate="yes" xml:space="preserve">
          <source>Alignment::try_from</source>
          <target state="translated">Alignment::try_from</target>
        </trans-unit>
        <trans-unit id="7e4c9d31924344ef62791e3f5778cc0b64650841" translate="yes" xml:space="preserve">
          <source>Alignment::try_into</source>
          <target state="translated">Alignment::try_into</target>
        </trans-unit>
        <trans-unit id="f8d85378f8bd14502ad4a535bf35eace323f7be0" translate="yes" xml:space="preserve">
          <source>Alignment::type_id</source>
          <target state="translated">Alignment::type_id</target>
        </trans-unit>
        <trans-unit id="1f13dd31cf3795018ba8cb51097f5cee92e51d26" translate="yes" xml:space="preserve">
          <source>All &lt;a href=&quot;items&quot;&gt;item declarations&lt;/a&gt; accept outer attributes while &lt;a href=&quot;items/external-blocks&quot;&gt;external blocks&lt;/a&gt;, &lt;a href=&quot;items/functions&quot;&gt;functions&lt;/a&gt;, &lt;a href=&quot;items/implementations&quot;&gt;implementations&lt;/a&gt;, and &lt;a href=&quot;items/modules&quot;&gt;modules&lt;/a&gt; accept inner attributes.</source>
          <target state="translated">Все &lt;a href=&quot;items&quot;&gt;объявления элементов&lt;/a&gt; принимают внешние атрибуты, в то время как &lt;a href=&quot;items/external-blocks&quot;&gt;внешние блоки&lt;/a&gt; , &lt;a href=&quot;items/functions&quot;&gt;функции&lt;/a&gt; , &lt;a href=&quot;items/implementations&quot;&gt;реализации&lt;/a&gt; и &lt;a href=&quot;items/modules&quot;&gt;модули&lt;/a&gt; принимают внутренние атрибуты.</target>
        </trans-unit>
        <trans-unit id="e7edfb23f380c12b821737c77295267e0d55adfa" translate="yes" xml:space="preserve">
          <source>All &lt;code&gt;if&lt;/code&gt; expressions start with the keyword &lt;code&gt;if&lt;/code&gt;, which is followed by a condition. In this case, the condition checks whether or not the variable &lt;code&gt;number&lt;/code&gt; has a value less than 5. The block of code we want to execute if the condition is true is placed immediately after the condition inside curly brackets. Blocks of code associated with the conditions in &lt;code&gt;if&lt;/code&gt; expressions are sometimes called &lt;em&gt;arms&lt;/em&gt;, just like the arms in &lt;code&gt;match&lt;/code&gt; expressions that we discussed in the &lt;a href=&quot;ch02-00-guessing-game-tutorial#comparing-the-guess-to-the-secret-number&quot;&gt;&amp;ldquo;Comparing the Guess to the Secret Number&amp;rdquo;&lt;/a&gt; section of Chapter 2.</source>
          <target state="translated">Все выражения &lt;code&gt;if&lt;/code&gt; начинаются с ключевого слова &lt;code&gt;if&lt;/code&gt; , за которым следует условие. В этом случае условие проверяет, имеет ли &lt;code&gt;number&lt;/code&gt; переменной значение меньше 5. Блок кода, который мы хотим выполнить, если условие истинно, помещается сразу после условия в фигурные скобки. Блоки кода, связанные с условиями в выражениях &lt;code&gt;if&lt;/code&gt; , иногда называют &lt;em&gt;руками&lt;/em&gt; , точно так же, как руки в выражениях &lt;code&gt;match&lt;/code&gt; , которые мы обсуждали в разделе &lt;a href=&quot;ch02-00-guessing-game-tutorial#comparing-the-guess-to-the-secret-number&quot;&gt;&amp;laquo;Сравнение предположения с секретным числом&amp;raquo;&lt;/a&gt; главы 2.</target>
        </trans-unit>
        <trans-unit id="6d770608aae868ce44cc837cd9b78c8161bf1b4b" translate="yes" xml:space="preserve">
          <source>All ASCII</source>
          <target state="translated">Все ASCII</target>
        </trans-unit>
        <trans-unit id="941b268ba2f8b2e2bf50827de379fcc106a7ae00" translate="yes" xml:space="preserve">
          <source>All Rust compiler versions support any edition that existed prior to that compiler&amp;rsquo;s release, and they can link crates of any supported editions together. Edition changes only affect the way the compiler initially parses code. Therefore, if you&amp;rsquo;re using Rust 2015 and one of your dependencies uses Rust 2018, your project will compile and be able to use that dependency. The opposite situation, where your project uses Rust 2018 and a dependency uses Rust 2015, works as well.</source>
          <target state="translated">Все версии компилятора Rust поддерживают любые выпуски, существовавшие до выпуска этого компилятора, и могут связывать ящики любых поддерживаемых выпусков вместе. Изменения редакции влияют только на способ первоначального синтаксического анализа кода компилятором. Следовательно, если вы используете Rust 2015, а одна из ваших зависимостей использует Rust 2018, ваш проект будет скомпилирован и сможет использовать эту зависимость. Противоположная ситуация, когда ваш проект использует Rust 2018, а зависимость использует Rust 2015, также работает.</target>
        </trans-unit>
        <trans-unit id="7652c7eeda6497653864c68957d9fcd32bd3f053" translate="yes" xml:space="preserve">
          <source>All Unicode</source>
          <target state="translated">Все Unicode</target>
        </trans-unit>
        <trans-unit id="47de5609df925352bb65b1c68fe6d11ef3c5f11f" translate="yes" xml:space="preserve">
          <source>All Unicode characters contained in the raw string body represent themselves, the characters &lt;code&gt;U+0022&lt;/code&gt; (double-quote) (except when followed by at least as many &lt;code&gt;U+0023&lt;/code&gt; (&lt;code&gt;#&lt;/code&gt;) characters as were used to start the raw string literal) or &lt;code&gt;U+005C&lt;/code&gt; (&lt;code&gt;\&lt;/code&gt;) do not have any special meaning.</source>
          <target state="translated">Все символы Unicode, содержащиеся в теле необработанной строки, представляют собой символы &lt;code&gt;U+0022&lt;/code&gt; (двойные кавычки) (за исключением случаев, когда за ними следует по крайней мере столько же символов &lt;code&gt;U+0023&lt;/code&gt; ( &lt;code&gt;#&lt;/code&gt; ), сколько использовалось для начала необработанного строкового литерала) или &lt;code&gt;U+005C&lt;/code&gt; ( &lt;code&gt;\&lt;/code&gt; ) не имеют особого значения.</target>
        </trans-unit>
        <trans-unit id="8a1ba3bb13e8cd072a280ba55ff12cd4ec0faacf" translate="yes" xml:space="preserve">
          <source>All access to a static is safe, but there are a number of restrictions on statics:</source>
          <target state="translated">Весь доступ к статике безопасен,но существует ряд ограничений по статике:</target>
        </trans-unit>
        <trans-unit id="cc4193fdbde0490cb6df1ff9fd4927655f61fac3" translate="yes" xml:space="preserve">
          <source>All access to the inner value through methods is &lt;code&gt;unsafe&lt;/code&gt;.</source>
          <target state="translated">Любой доступ к внутреннему значению через методы &lt;code&gt;unsafe&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ceb9b59e717209dd478129622af76401fc92a7ef" translate="yes" xml:space="preserve">
          <source>All accesses performed by functions in this module are &lt;em&gt;non-atomic&lt;/em&gt; in the sense of &lt;a href=&quot;../sync/atomic/index&quot;&gt;atomic operations&lt;/a&gt; used to synchronize between threads. This means it is undefined behavior to perform two concurrent accesses to the same location from different threads unless both accesses only read from memory. Notice that this explicitly includes &lt;a href=&quot;fn.read_volatile&quot;&gt;&lt;code&gt;read_volatile&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;fn.write_volatile&quot;&gt;&lt;code&gt;write_volatile&lt;/code&gt;&lt;/a&gt;: Volatile accesses cannot be used for inter-thread synchronization.</source>
          <target state="translated">Все обращения, выполняемые функциями в этом модуле, &lt;em&gt;не&lt;/em&gt; являются &lt;em&gt;атомарными&lt;/em&gt; в смысле &lt;a href=&quot;../sync/atomic/index&quot;&gt;атомарных операций,&lt;/a&gt; используемых для синхронизации между потоками. Это означает, что выполнение двух одновременных обращений к одному и тому же месту из разных потоков является неопределенным, если только оба доступа не считывают данные из памяти. Обратите внимание, что это явно включает &lt;a href=&quot;fn.read_volatile&quot;&gt; &lt;code&gt;read_volatile&lt;/code&gt; &lt;/a&gt; и &lt;a href=&quot;fn.write_volatile&quot;&gt; &lt;code&gt;write_volatile&lt;/code&gt; &lt;/a&gt; : доступы Volatile нельзя использовать для межпоточной синхронизации.</target>
        </trans-unit>
        <trans-unit id="286be0b8b15ccf1efa39407656b792f78e80afd9" translate="yes" xml:space="preserve">
          <source>All amortized costs are for the potential need to resize when capacity is exhausted. If a resize occurs it will take &lt;em&gt;O&lt;/em&gt;(&lt;em&gt;n&lt;/em&gt;) time. Our collections never automatically shrink, so removal operations aren't amortized. Over a sufficiently large series of operations, the average cost per operation will deterministically equal the given cost.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5d3e246179e6158acb2b336b6eaaa6c3cd96b12d" translate="yes" xml:space="preserve">
          <source>All amortized costs are for the potential need to resize when capacity is exhausted. If a resize occurs it will take O(n) time. Our collections never automatically shrink, so removal operations aren't amortized. Over a sufficiently large series of operations, the average cost per operation will deterministically equal the given cost.</source>
          <target state="translated">Все амортизированные расходы связаны с потенциальной необходимостью изменения размера,когда мощности будут исчерпаны.При изменении размера потребуется время O(n).Наши коллекции никогда не уменьшаются автоматически,поэтому операции по удалению не амортизируются.В достаточно больших сериях операций средняя стоимость одной операции будет детерминированно равна заданной стоимости.</target>
        </trans-unit>
        <trans-unit id="ad40505a1a509d19ac8713b0e6d72bf2f8406439" translate="yes" xml:space="preserve">
          <source>All associated functions must either have a &lt;code&gt;where Self: Sized&lt;/code&gt; bound, or</source>
          <target state="translated">Все связанные функции должны иметь границу &lt;code&gt;where Self: Sized&lt;/code&gt; или</target>
        </trans-unit>
        <trans-unit id="15061bca973f1e3bdfd6bc4220f487a4d9f0fa2e" translate="yes" xml:space="preserve">
          <source>All atomic types in this module are guaranteed to be &lt;a href=&quot;https://en.wikipedia.org/wiki/Non-blocking_algorithm&quot;&gt;lock-free&lt;/a&gt; if they're available. This means they don't internally acquire a global mutex. Atomic types and operations are not guaranteed to be wait-free. This means that operations like &lt;code&gt;fetch_or&lt;/code&gt; may be implemented with a compare-and-swap loop.</source>
          <target state="translated">Все атомарные типы в этом модуле гарантированно &lt;a href=&quot;https://en.wikipedia.org/wiki/Non-blocking_algorithm&quot;&gt;свободны от блокировок,&lt;/a&gt; если они доступны. Это означает, что они не получают глобальный мьютекс внутри компании. Не гарантируется, что атомарные типы и операции будут без ожидания. Это означает, что такие операции, как &lt;code&gt;fetch_or&lt;/code&gt; , могут быть реализованы с помощью цикла сравнения и замены.</target>
        </trans-unit>
        <trans-unit id="290ed2d52fa06b05e83bf6a12f1d4aa3dca7ba7c" translate="yes" xml:space="preserve">
          <source>All binaries installed with &lt;code&gt;cargo install&lt;/code&gt; are stored in the installation root&amp;rsquo;s &lt;em&gt;bin&lt;/em&gt; folder. If you installed Rust using &lt;em&gt;rustup.rs&lt;/em&gt; and don&amp;rsquo;t have any custom configurations, this directory will be &lt;em&gt;$HOME/.cargo/bin&lt;/em&gt;. Ensure that directory is in your &lt;code&gt;$PATH&lt;/code&gt; to be able to run programs you&amp;rsquo;ve installed with &lt;code&gt;cargo install&lt;/code&gt;.</source>
          <target state="translated">Все двоичные файлы, установленные с помощью &lt;code&gt;cargo install&lt;/code&gt; , хранятся в папке &lt;em&gt;bin&lt;/em&gt; корневого &lt;em&gt;каталога&lt;/em&gt; установки . Если вы установили Rust с помощью &lt;em&gt;rustup.rs&lt;/em&gt; и у вас нет никаких пользовательских настроек, этот каталог будет &lt;em&gt;$ HOME / .cargo / bin&lt;/em&gt; . Убедитесь, что каталог находится в вашем &lt;code&gt;$PATH&lt;/code&gt; чтобы иметь возможность запускать программы, которые вы установили с помощью &lt;code&gt;cargo install&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="33d170f2503ad727df2773d3d501af5a7c6f33f7" translate="yes" xml:space="preserve">
          <source>All boolean operators except for &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; and &lt;code&gt;||&lt;/code&gt; which are banned since they are short-circuiting.</source>
          <target state="translated">Все логические операторы, кроме &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; и &lt;code&gt;||&lt;/code&gt; которые запрещены из-за короткого замыкания.</target>
        </trans-unit>
        <trans-unit id="1797e85af758baa0954345dbaa6c305b8c789f74" translate="yes" xml:space="preserve">
          <source>All bytes read from this source will be appended to the specified buffer &lt;code&gt;buf&lt;/code&gt;. This function will continuously call &lt;a href=&quot;trait.read#tymethod.read&quot;&gt;&lt;code&gt;read()&lt;/code&gt;&lt;/a&gt; to append more data to &lt;code&gt;buf&lt;/code&gt; until &lt;a href=&quot;trait.read#tymethod.read&quot;&gt;&lt;code&gt;read()&lt;/code&gt;&lt;/a&gt; returns either &lt;a href=&quot;../result/enum.result#variant.Ok&quot;&gt;&lt;code&gt;Ok(0)&lt;/code&gt;&lt;/a&gt; or an error of non-&lt;a href=&quot;enum.errorkind#variant.Interrupted&quot;&gt;&lt;code&gt;ErrorKind::Interrupted&lt;/code&gt;&lt;/a&gt; kind.</source>
          <target state="translated">Все байты, прочитанные из этого источника, будут добавлены в указанный буфер &lt;code&gt;buf&lt;/code&gt; . Эта функция будет постоянно вызывать&lt;a href=&quot;trait.read#tymethod.read&quot;&gt; &lt;code&gt;read()&lt;/code&gt; &lt;/a&gt; для добавления дополнительных данных в &lt;code&gt;buf&lt;/code&gt; , пока&lt;a href=&quot;trait.read#tymethod.read&quot;&gt; &lt;code&gt;read()&lt;/code&gt; &lt;/a&gt; вернет&lt;a href=&quot;../result/enum.result#variant.Ok&quot;&gt; &lt;code&gt;Ok(0)&lt;/code&gt; &lt;/a&gt; или ошибку не&lt;a href=&quot;enum.errorkind#variant.Interrupted&quot;&gt; &lt;code&gt;ErrorKind::Interrupted&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="7b662763d511d397b2cbc49f35a59edd0871bf65" translate="yes" xml:space="preserve">
          <source>All calls to &lt;a href=&quot;trait.write#tymethod.write&quot;&gt;&lt;code&gt;write&lt;/code&gt;&lt;/a&gt; on the returned instance will return &lt;code&gt;Ok(buf.len())&lt;/code&gt; and the contents of the buffer will not be inspected.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="792e4e8c3b4454b76d09b3a55c5244a2a04987c6" translate="yes" xml:space="preserve">
          <source>All calls to &lt;code&gt;write&lt;/code&gt; on the returned instance will return &lt;code&gt;Ok(buf.len())&lt;/code&gt; and the contents of the buffer will not be inspected.</source>
          <target state="translated">Все вызовы &lt;code&gt;write&lt;/code&gt; в возвращенный экземпляр вернут &lt;code&gt;Ok(buf.len())&lt;/code&gt; и содержимое буфера не будет проверяться.</target>
        </trans-unit>
        <trans-unit id="163ac7eae61cfe370b91ace9f314d434af91aec2" translate="yes" xml:space="preserve">
          <source>All characters contained in the raw string body represent their ASCII encoding, the characters &lt;code&gt;U+0022&lt;/code&gt; (double-quote) (except when followed by at least as many &lt;code&gt;U+0023&lt;/code&gt; (&lt;code&gt;#&lt;/code&gt;) characters as were used to start the raw string literal) or &lt;code&gt;U+005C&lt;/code&gt; (&lt;code&gt;\&lt;/code&gt;) do not have any special meaning.</source>
          <target state="translated">Все символы, содержащиеся в теле необработанной строки, представляют их кодировку ASCII, символы &lt;code&gt;U+0022&lt;/code&gt; (двойные кавычки) (кроме тех случаев, когда за ними следует по крайней мере столько же символов &lt;code&gt;U+0023&lt;/code&gt; ( &lt;code&gt;#&lt;/code&gt; ), сколько использовалось для начала литерала необработанной строки) или &lt;code&gt;U+005C&lt;/code&gt; ( &lt;code&gt;\&lt;/code&gt; ) не имеют особого значения.</target>
        </trans-unit>
        <trans-unit id="43d6b6384605c36d010e25334a7b59d1666b30b5" translate="yes" xml:space="preserve">
          <source>All closure types implement &lt;a href=&quot;../special-types-and-traits#sized&quot;&gt;&lt;code&gt;Sized&lt;/code&gt;&lt;/a&gt;. Additionally, closure types implement the following traits if allowed to do so by the types of the captures it stores:</source>
          <target state="translated">Все типы закрытия реализуют &lt;a href=&quot;../special-types-and-traits#sized&quot;&gt; &lt;code&gt;Sized&lt;/code&gt; &lt;/a&gt; . Кроме того, типы замыкания реализуют следующие черты, если это разрешено типами сохраняемых захватов:</target>
        </trans-unit>
        <trans-unit id="a34254512b20b7c3c4f4d4cb8623d62bc5f25917" translate="yes" xml:space="preserve">
          <source>All crates have a &lt;em&gt;prelude&lt;/em&gt; that automatically inserts names from a specific module, the &lt;em&gt;prelude module&lt;/em&gt;, into scope of each &lt;a href=&quot;items/modules&quot;&gt;module&lt;/a&gt; and an &lt;a href=&quot;items/extern-crates&quot;&gt;&lt;code&gt;extern crate&lt;/code&gt;&lt;/a&gt; into the crate root module. By default, the &lt;em&gt;standard prelude&lt;/em&gt; is used. The linked crate is &lt;a href=&quot;../std/index&quot;&gt;&lt;code&gt;std&lt;/code&gt;&lt;/a&gt; and the prelude module is &lt;a href=&quot;../std/prelude/index&quot;&gt;&lt;code&gt;std::prelude::v1&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">У всех ящиков есть &lt;em&gt;прелюдия,&lt;/em&gt; которая автоматически вставляет имена из определенного модуля, &lt;em&gt;модуль прелюдии&lt;/em&gt; , в область видимости каждого &lt;a href=&quot;items/modules&quot;&gt;модуля&lt;/a&gt; и внешний &lt;a href=&quot;items/extern-crates&quot;&gt; &lt;code&gt;extern crate&lt;/code&gt; &lt;/a&gt; в корневой модуль ящика. По умолчанию используется &lt;em&gt;стандартная прелюдия&lt;/em&gt; . Связанный ящик - это &lt;a href=&quot;../std/index&quot;&gt; &lt;code&gt;std&lt;/code&gt; ,&lt;/a&gt; а модуль &lt;a href=&quot;../std/prelude/index&quot;&gt; &lt;code&gt;std::prelude::v1&lt;/code&gt; &lt;/a&gt; - std :: prelude :: v1 .</target>
        </trans-unit>
        <trans-unit id="80e6d9f67f0a7d01f6edd0112ce6e32390cc7b99" translate="yes" xml:space="preserve">
          <source>All currently blocked and future &lt;a href=&quot;../io/trait.read&quot;&gt;reads&lt;/a&gt; will return &lt;a href=&quot;../result/enum.result#variant.Ok&quot;&gt;&lt;code&gt;Ok(0)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Все заблокированные в настоящее время и будущие &lt;a href=&quot;../io/trait.read&quot;&gt;чтения&lt;/a&gt; вернут &lt;a href=&quot;../result/enum.result#variant.Ok&quot;&gt; &lt;code&gt;Ok(0)&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="ab960fd018156ee2b72c293b0f7c46b28b261211" translate="yes" xml:space="preserve">
          <source>All currently blocked and future &lt;a href=&quot;../io/trait.read&quot;&gt;reads&lt;/a&gt; will return &lt;a href=&quot;../result/enum.result#variant.Ok&quot;&gt;&lt;code&gt;Ok&lt;/code&gt;&lt;/a&gt;&lt;code&gt;(0)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a6d40cb983863467fc229fa6f4b9f265ef62418a" translate="yes" xml:space="preserve">
          <source>All currently blocked and future &lt;a href=&quot;../io/trait.write&quot;&gt;writes&lt;/a&gt; will return an error.</source>
          <target state="translated">Все заблокированные в настоящее время и будущие &lt;a href=&quot;../io/trait.write&quot;&gt;записи&lt;/a&gt; будут возвращать ошибку.</target>
        </trans-unit>
        <trans-unit id="c24e8493495f5eda7feccf15dd8b5779f86db545" translate="yes" xml:space="preserve">
          <source>All data stored on the stack must have a known, fixed size. Data with an unknown size at compile time or a size that might change must be stored on the heap instead. The heap is less organized: when you put data on the heap, you request a certain amount of space. The memory allocator finds an empty spot in the heap that is big enough, marks it as being in use, and returns a &lt;em&gt;pointer&lt;/em&gt;, which is the address of that location. This process is called &lt;em&gt;allocating on the heap&lt;/em&gt; and is sometimes abbreviated as just &lt;em&gt;allocating&lt;/em&gt;. Pushing values onto the stack is not considered allocating. Because the pointer is a known, fixed size, you can store the pointer on the stack, but when you want the actual data, you must follow the pointer.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b5ad10491502eb3084d1fb833cddef2d6e97c099" translate="yes" xml:space="preserve">
          <source>All data stored on the stack must have a known, fixed size. Data with an unknown size at compile time or a size that might change must be stored on the heap instead. The heap is less organized: when you put data on the heap, you request a certain amount of space. The operating system finds an empty spot in the heap that is big enough, marks it as being in use, and returns a &lt;em&gt;pointer&lt;/em&gt;, which is the address of that location. This process is called &lt;em&gt;allocating on the heap&lt;/em&gt; and is sometimes abbreviated as just &lt;em&gt;allocating&lt;/em&gt;. Pushing values onto the stack is not considered allocating. Because the pointer is a known, fixed size, you can store the pointer on the stack, but when you want the actual data, you must follow the pointer.</source>
          <target state="translated">Все данные, хранящиеся в стеке, должны иметь известный фиксированный размер. Вместо этого данные с неизвестным размером во время компиляции или размером, который может измениться, должны храниться в куче. Куча менее организована: когда вы помещаете данные в кучу, вы запрашиваете определенный объем пространства. Операционная система находит в куче достаточно большое пустое место, отмечает его как используемое и возвращает&lt;em&gt; указатель&lt;/em&gt; , который является адресом этого места. Этот процесс называется &lt;em&gt;выделением в куче&lt;/em&gt; и иногда сокращенно называется просто &lt;em&gt;выделением&lt;/em&gt; . Размещение значений в стеке не считается выделением. Поскольку указатель имеет известный фиксированный размер, вы можете сохранить указатель в стеке, но когда вам нужны фактические данные, вы должны следовать за указателем.</target>
        </trans-unit>
        <trans-unit id="c3ab61183db153bdcb93b3db49372bcfa15c64d0" translate="yes" xml:space="preserve">
          <source>All elements of arrays are always initialized, and access to an array is always bounds-checked in safe methods and operators.</source>
          <target state="translated">Все элементы массивов всегда инициализируются,а доступ к массиву всегда проверяется безопасными методами и операторами.</target>
        </trans-unit>
        <trans-unit id="7fbb5676d98408c23a91ee3e50ae6931e19803d3" translate="yes" xml:space="preserve">
          <source>All elements of slices are always initialized, and access to a slice is always bounds-checked in safe methods and operators.</source>
          <target state="translated">Все элементы фрагментов всегда инициализируются,а доступ к фрагменту всегда проверяется безопасными методами и операторами.</target>
        </trans-unit>
        <trans-unit id="5797b6e64335a290bd1264b10ba82cdf81409cc5" translate="yes" xml:space="preserve">
          <source>All fields in a &lt;code&gt;union&lt;/code&gt; are all at the same place in memory which means borrowing one borrows the entire &lt;code&gt;union&lt;/code&gt;, for the same lifetime:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="833e88d98de8f4240c961bc71bc4ebdf6caf04e8" translate="yes" xml:space="preserve">
          <source>All five array values appear in the terminal, as expected. Even though &lt;code&gt;index&lt;/code&gt; will reach a value of &lt;code&gt;5&lt;/code&gt; at some point, the loop stops executing before trying to fetch a sixth value from the array.</source>
          <target state="translated">Как и ожидалось, в терминале появятся все пять значений массива. Даже если в какой-то момент &lt;code&gt;index&lt;/code&gt; достигнет значения &lt;code&gt;5&lt;/code&gt; , цикл прекращает выполнение перед попыткой получить шестое значение из массива.</target>
        </trans-unit>
        <trans-unit id="9baa2527c7d6929ffc1c3e903b5bd7bcaaf4a17a" translate="yes" xml:space="preserve">
          <source>All four types of loop support &lt;a href=&quot;#break-expressions&quot;&gt;&lt;code&gt;break&lt;/code&gt; expressions&lt;/a&gt;, &lt;a href=&quot;#continue-expressions&quot;&gt;&lt;code&gt;continue&lt;/code&gt; expressions&lt;/a&gt;, and &lt;a href=&quot;#loop-labels&quot;&gt;labels&lt;/a&gt;. Only &lt;code&gt;loop&lt;/code&gt; supports &lt;a href=&quot;#break-and-loop-values&quot;&gt;evaluation to non-trivial values&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e11d83f6e553be6952611c97ac05bbc3817eeae9" translate="yes" xml:space="preserve">
          <source>All four types of loop support &lt;a href=&quot;loop-expr#break-expressions&quot;&gt;&lt;code&gt;break&lt;/code&gt; expressions&lt;/a&gt;, &lt;a href=&quot;loop-expr#continue-expressions&quot;&gt;&lt;code&gt;continue&lt;/code&gt; expressions&lt;/a&gt;, and &lt;a href=&quot;loop-expr#loop-labels&quot;&gt;labels&lt;/a&gt;. Only &lt;code&gt;loop&lt;/code&gt; supports &lt;a href=&quot;loop-expr#break-and-loop-values&quot;&gt;evaluation to non-trivial values&lt;/a&gt;.</source>
          <target state="translated">Все четыре вида поддержки петли &lt;a href=&quot;loop-expr#break-expressions&quot;&gt; &lt;code&gt;break&lt;/code&gt; выражений&lt;/a&gt; , по- &lt;a href=&quot;loop-expr#continue-expressions&quot;&gt; &lt;code&gt;continue&lt;/code&gt; выражения&lt;/a&gt; и &lt;a href=&quot;loop-expr#loop-labels&quot;&gt;этикетки&lt;/a&gt; . Только &lt;code&gt;loop&lt;/code&gt; поддерживает &lt;a href=&quot;loop-expr#break-and-loop-values&quot;&gt;оценку нетривиальных значений&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="0615d0c10f128d4e7e9a656552c9285eca738194" translate="yes" xml:space="preserve">
          <source>All function items implement &lt;a href=&quot;../../std/ops/trait.fn&quot;&gt;&lt;code&gt;Fn&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../../std/ops/trait.fnmut&quot;&gt;&lt;code&gt;FnMut&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../../std/ops/trait.fnonce&quot;&gt;&lt;code&gt;FnOnce&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../special-types-and-traits#copy&quot;&gt;&lt;code&gt;Copy&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../special-types-and-traits#clone&quot;&gt;&lt;code&gt;Clone&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../special-types-and-traits#send&quot;&gt;&lt;code&gt;Send&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;../special-types-and-traits#sync&quot;&gt;&lt;code&gt;Sync&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Все функциональные элементы реализуют &lt;a href=&quot;../../std/ops/trait.fn&quot;&gt; &lt;code&gt;Fn&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;../../std/ops/trait.fnmut&quot;&gt; &lt;code&gt;FnMut&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;../../std/ops/trait.fnonce&quot;&gt; &lt;code&gt;FnOnce&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;../special-types-and-traits#copy&quot;&gt; &lt;code&gt;Copy&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;../special-types-and-traits#clone&quot;&gt; &lt;code&gt;Clone&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;../special-types-and-traits#send&quot;&gt; &lt;code&gt;Send&lt;/code&gt; &lt;/a&gt; и &lt;a href=&quot;../special-types-and-traits#sync&quot;&gt; &lt;code&gt;Sync&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="36815ff2f54c1ef032403bd6365a096bb5c32000" translate="yes" xml:space="preserve">
          <source>All function parameters are in the scope of the entire function body, so are dropped last when evaluating the function. Each actual function parameter is dropped after any bindings introduced in that parameter's pattern.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c77d0720d55ff4ece3326614a73ddde6503e3179" translate="yes" xml:space="preserve">
          <source>All implementations of &lt;code&gt;Unsize&lt;/code&gt; are provided automatically by the compiler.</source>
          <target state="translated">Все реализации &lt;code&gt;Unsize&lt;/code&gt; предоставляются компилятором автоматически.</target>
        </trans-unit>
        <trans-unit id="94282a18d174676690037624bae4b4b406cb02ee" translate="yes" xml:space="preserve">
          <source>All iterators implement a trait named &lt;code&gt;Iterator&lt;/code&gt; that is defined in the standard library. The definition of the trait looks like this:</source>
          <target state="translated">Все итераторы реализуют трейт с именем &lt;code&gt;Iterator&lt;/code&gt; , который определен в стандартной библиотеке. Определение признака выглядит так:</target>
        </trans-unit>
        <trans-unit id="7da42c45b54f4237c99325204711121b9f08beec" translate="yes" xml:space="preserve">
          <source>All kinds of ASCII whitespace are considered:</source>
          <target state="translated">Рассматриваются все виды ASCII пробельных символов:</target>
        </trans-unit>
        <trans-unit id="3e530c202d9d3c48672f8f7b98a14e41befed3be" translate="yes" xml:space="preserve">
          <source>All kinds of whitespace are considered:</source>
          <target state="translated">Рассматриваются все виды белых пробелов:</target>
        </trans-unit>
        <trans-unit id="9c42bdece20642dd1d10ab718ff507235d349b8d" translate="yes" xml:space="preserve">
          <source>All layouts have an associated non-negative size and a power-of-two alignment.</source>
          <target state="translated">Все компоновки имеют соответствующий неотрицательный размер и силу двойного выравнивания.</target>
        </trans-unit>
        <trans-unit id="ad65ecd6f4c6a3cd749629f3ba92add5fa618dd9" translate="yes" xml:space="preserve">
          <source>All layouts have an associated size and a power-of-two alignment.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7178a9053518ff1c5e401dc1d4bee4c24f25359b" translate="yes" xml:space="preserve">
          <source>All of</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="32f70044558e382c5ebf59ec68e9d711cc2cb7b2" translate="yes" xml:space="preserve">
          <source>All of the coefficients get stored in registers, which means accessing the values is very fast. There are no bounds checks on the array access at runtime. All these optimizations that Rust is able to apply make the resulting code extremely efficient. Now that you know this, you can use iterators and closures without fear! They make code seem like it&amp;rsquo;s higher level but don&amp;rsquo;t impose a runtime performance penalty for doing so.</source>
          <target state="translated">Все коэффициенты сохраняются в регистрах, что означает, что доступ к значениям осуществляется очень быстро. Нет никаких проверок границ доступа к массиву во время выполнения. Все эти оптимизации, которые может применить Rust, делают результирующий код чрезвычайно эффективным. Теперь, когда вы это знаете, вы можете без опасений использовать итераторы и замыкания! Они заставляют код казаться более высоким уровнем, но не налагают за это снижение производительности во время выполнения.</target>
        </trans-unit>
        <trans-unit id="17dabbf042cc2454dd1f0ba98c8b7c6f3be65ec5" translate="yes" xml:space="preserve">
          <source>All of the logic that manages the counts and value dropping is built into &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; and &lt;code&gt;Weak&amp;lt;T&amp;gt;&lt;/code&gt; and their implementations of the &lt;code&gt;Drop&lt;/code&gt; trait. By specifying that the relationship from a child to its parent should be a &lt;code&gt;Weak&amp;lt;T&amp;gt;&lt;/code&gt; reference in the definition of &lt;code&gt;Node&lt;/code&gt;, you&amp;rsquo;re able to have parent nodes point to child nodes and vice versa without creating a reference cycle and memory leaks.</source>
          <target state="translated">Вся логика, которая управляет подсчетами и сбросом значений, встроена в &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; и &lt;code&gt;Weak&amp;lt;T&amp;gt;&lt;/code&gt; и их реализации трейта &lt;code&gt;Drop&lt;/code&gt; . Указав, что отношение дочернего элемента к его родительскому элементу должно быть ссылкой &lt;code&gt;Weak&amp;lt;T&amp;gt;&lt;/code&gt; в определении &lt;code&gt;Node&lt;/code&gt; , вы можете указать родительские узлы на дочерние узлы и наоборот, без создания ссылочного цикла и утечек памяти.</target>
        </trans-unit>
        <trans-unit id="469c3254d30ae896569972fb8c0f6e762f31a91d" translate="yes" xml:space="preserve">
          <source>All of the standard collections provide several iterators for performing bulk manipulation of their contents. The three primary iterators almost every collection should provide are &lt;code&gt;iter&lt;/code&gt;, &lt;code&gt;iter_mut&lt;/code&gt;, and &lt;code&gt;into_iter&lt;/code&gt;. Some of these are not provided on collections where it would be unsound or unreasonable to provide them.</source>
          <target state="translated">Все стандартные коллекции предоставляют несколько итераторов для выполнения массовых манипуляций с их содержимым. Почти каждая коллекция должна предоставлять три основных итератора: &lt;code&gt;iter&lt;/code&gt; , &lt;code&gt;iter_mut&lt;/code&gt; и &lt;code&gt;into_iter&lt;/code&gt; . Некоторые из них не представлены в коллекциях, и их предоставление было бы необоснованным или необоснованным.</target>
        </trans-unit>
        <trans-unit id="7c09f50beeaa399a934ba76d5cc5d913f4961d31" translate="yes" xml:space="preserve">
          <source>All of these are valid &lt;code&gt;String&lt;/code&gt; values.</source>
          <target state="translated">Все это допустимые &lt;code&gt;String&lt;/code&gt; значения.</target>
        </trans-unit>
        <trans-unit id="3488f647e2016335e532591f4617d056149f656a" translate="yes" xml:space="preserve">
          <source>All of these method calls are possible because we specified how the &lt;code&gt;next&lt;/code&gt; method works, and the standard library provides default implementations for other methods that call &lt;code&gt;next&lt;/code&gt;.</source>
          <target state="translated">Все эти вызовы методов возможны, потому что мы указали, как работает &lt;code&gt;next&lt;/code&gt; метод, а стандартная библиотека предоставляет реализации по умолчанию для других методов, которые вызывают &lt;code&gt;next&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2a8409870b71900361c6e9ce41cc4d8b31f5a720" translate="yes" xml:space="preserve">
          <source>All options are initially set to &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">Для всех параметров изначально установлено значение &lt;code&gt;false&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="cec813890e4d07a2defc7bce522b39b7b6522a4d" translate="yes" xml:space="preserve">
          <source>All other arguments given to the &lt;code&gt;inline&lt;/code&gt; attribute will return this error. Example:</source>
          <target state="translated">Все остальные аргументы, данные &lt;code&gt;inline&lt;/code&gt; атрибуту, вернут эту ошибку. Пример:</target>
        </trans-unit>
        <trans-unit id="01957b2f8a375b806a015963a415dc2f430add14" translate="yes" xml:space="preserve">
          <source>All other arguments given to the &lt;code&gt;instruction_set&lt;/code&gt; attribute will return this error. Example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="110d2b10be35d17317e6c561cf91a4fabbf8e826" translate="yes" xml:space="preserve">
          <source>All other characters are given hexadecimal Unicode escapes; see &lt;a href=&quot;#method.escape_unicode&quot;&gt;&lt;code&gt;escape_unicode&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Всем остальным символам дается шестнадцатеричное экранирование Unicode; см. &lt;a href=&quot;#method.escape_unicode&quot;&gt; &lt;code&gt;escape_unicode&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="f76ce538d07b9974a525f600e48b7f5dff4ae16c" translate="yes" xml:space="preserve">
          <source>All other fragment specifiers have no restrictions.</source>
          <target state="translated">Все остальные спецификаторы фрагментов не имеют ограничений.</target>
        </trans-unit>
        <trans-unit id="fef84ba857bf1c83a92f8d5a5b2d52afc2b3c691" translate="yes" xml:space="preserve">
          <source>All pointers (except for the null pointer) are valid for all operations of &lt;a href=&quot;https://doc.rust-lang.org/nomicon/exotic-sizes.html#zero-sized-types-zsts&quot;&gt;size zero&lt;/a&gt;.</source>
          <target state="translated">Все указатели (кроме нулевого указателя) действительны для всех операций &lt;a href=&quot;https://doc.rust-lang.org/nomicon/exotic-sizes.html#zero-sized-types-zsts&quot;&gt;нулевого размера&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="bcec8da89ce19312f810d6e8b0a4c1c994af8c3f" translate="yes" xml:space="preserve">
          <source>All pointers in Rust are explicit first-class values. They can be moved or copied, stored into data structs, and returned from functions.</source>
          <target state="translated">Все указатели в Rust являются явными первоклассными значениями.Их можно перемещать или копировать,сохранять в структурах данных и возвращать из функций.</target>
        </trans-unit>
        <trans-unit id="6a33c45e166bf3f976aac4c7eec793b7d8946ca1" translate="yes" xml:space="preserve">
          <source>All programmers strive to make their code easy to understand, but sometimes extra explanation is warranted. In these cases, programmers leave notes, or &lt;em&gt;comments&lt;/em&gt;, in their source code that the compiler will ignore but people reading the source code may find useful.</source>
          <target state="translated">Все программисты стремятся сделать свой код легким для понимания, но иногда требуется дополнительное пояснение. В этих случаях программисты оставляют заметки или &lt;em&gt;комментарии&lt;/em&gt; в своем исходном коде, которые компилятор проигнорирует, но люди, читающие исходный код, могут найти их полезными.</target>
        </trans-unit>
        <trans-unit id="aa0c879bcf5cab9e7f4749d5ede013d5bf918c1f" translate="yes" xml:space="preserve">
          <source>All programs have to manage the way they use a computer&amp;rsquo;s memory while running. Some languages have garbage collection that constantly looks for no longer used memory as the program runs; in other languages, the programmer must explicitly allocate and free the memory. Rust uses a third approach: memory is managed through a system of ownership with a set of rules that the compiler checks at compile time. None of the ownership features slow down your program while it&amp;rsquo;s running.</source>
          <target state="translated">Все программы должны управлять тем, как они используют память компьютера во время работы. В некоторых языках есть сборщик мусора, который постоянно ищет неиспользуемую память во время работы программы; на других языках программист должен явно выделять и освобождать память. Rust использует третий подход: память управляется через систему владения с набором правил, которые компилятор проверяет во время компиляции. Ни одна из функций владения не замедляет работу вашей программы во время ее работы.</target>
        </trans-unit>
        <trans-unit id="cf610b10a23cb06f62489f071586a11ed04b1ece" translate="yes" xml:space="preserve">
          <source>All reads from the returned reader will return &lt;a href=&quot;../result/enum.result#variant.Ok&quot;&gt;&lt;code&gt;Ok&lt;/code&gt;&lt;/a&gt;&lt;code&gt;(0)&lt;/code&gt;.</source>
          <target state="translated">Все чтения от возвращенного ридера вернут &lt;a href=&quot;../result/enum.result#variant.Ok&quot;&gt; &lt;code&gt;Ok&lt;/code&gt; &lt;/a&gt; &lt;code&gt;(0)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5edadac5bb39f603d58e3300e69ef3e103ed0e48" translate="yes" xml:space="preserve">
          <source>All reads from this reader will succeed by filling the specified buffer with the given byte.</source>
          <target state="translated">Все чтения из этого считывателя будут успешными при заполнении указанного буфера заданным байтом.</target>
        </trans-unit>
        <trans-unit id="8042ca5a8b0159faa7d15d89ddf16924d0bee8ca" translate="yes" xml:space="preserve">
          <source>All results of &lt;code&gt;next()&lt;/code&gt; need to be identical to the results of &lt;code&gt;next_back()&lt;/code&gt; in reverse order.</source>
          <target state="translated">Все результаты &lt;code&gt;next()&lt;/code&gt; должны быть идентичны результатам &lt;code&gt;next_back()&lt;/code&gt; в обратном порядке.</target>
        </trans-unit>
        <trans-unit id="051b0a6da7e5a99366866472afe4cedd9c4ae587" translate="yes" xml:space="preserve">
          <source>All strings that adhere to the following &lt;a href=&quot;https://www.w3.org/TR/REC-xml/#sec-notation&quot;&gt;EBNF&lt;/a&gt; grammar will result in an &lt;a href=&quot;../result/enum.result#Ok.v&quot;&gt;&lt;code&gt;Ok&lt;/code&gt;&lt;/a&gt; being returned:</source>
          <target state="translated">Все строки, которые соответствуют следующей грамматике &lt;a href=&quot;https://www.w3.org/TR/REC-xml/#sec-notation&quot;&gt;EBNF&lt;/a&gt; , приведут к &lt;a href=&quot;../result/enum.result#Ok.v&quot;&gt; &lt;code&gt;Ok&lt;/code&gt; &lt;/a&gt;возврату :</target>
        </trans-unit>
        <trans-unit id="ba6c1035e6000e531913744213ce54c88bb453f8" translate="yes" xml:space="preserve">
          <source>All strings that adhere to the following &lt;a href=&quot;https://www.w3.org/TR/REC-xml/#sec-notation&quot;&gt;EBNF&lt;/a&gt; grammar will result in an &lt;a href=&quot;../result/enum.result#variant.Ok&quot;&gt;&lt;code&gt;Ok&lt;/code&gt;&lt;/a&gt; being returned:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8c2330d9e11176797f3b69c4b492614aa87568d1" translate="yes" xml:space="preserve">
          <source>All strings that adhere to the following &lt;a href=&quot;https://www.w3.org/TR/REC-xml/#sec-notation&quot;&gt;EBNF&lt;/a&gt; grammar will result in an &lt;a href=&quot;result/enum.result#Ok.v&quot;&gt;&lt;code&gt;Ok&lt;/code&gt;&lt;/a&gt; being returned:</source>
          <target state="translated">Все строки, которые соответствуют следующей грамматике &lt;a href=&quot;https://www.w3.org/TR/REC-xml/#sec-notation&quot;&gt;EBNF&lt;/a&gt; , приведут к возврату &lt;a href=&quot;result/enum.result#Ok.v&quot;&gt; &lt;code&gt;Ok&lt;/code&gt; &lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="5099415fb85a9568ce08c4de6d590b1962a9de28" translate="yes" xml:space="preserve">
          <source>All strings that adhere to the following &lt;a href=&quot;https://www.w3.org/TR/REC-xml/#sec-notation&quot;&gt;EBNF&lt;/a&gt; grammar will result in an &lt;a href=&quot;result/enum.result#variant.Ok&quot;&gt;&lt;code&gt;Ok&lt;/code&gt;&lt;/a&gt; being returned:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d19c4500c8b81bcefce226435a932d9bd67dd1d4" translate="yes" xml:space="preserve">
          <source>All supertraits must also be object safe.</source>
          <target state="translated">Все суперпризраки также должны быть защищены от посторонних предметов.</target>
        </trans-unit>
        <trans-unit id="3834b26accc0c7926a85719d5492f93bbdde2cd6" translate="yes" xml:space="preserve">
          <source>All the Places Patterns Can Be Used</source>
          <target state="translated">Все места Шаблоны могут быть использованы</target>
        </trans-unit>
        <trans-unit id="70ddc33f2c0eb4587fa8e2cac6e8f77be9184d95" translate="yes" xml:space="preserve">
          <source>All the code we&amp;rsquo;ve discussed so far has had Rust&amp;rsquo;s memory safety guarantees enforced at compile time. However, Rust has a second language hidden inside it that doesn&amp;rsquo;t enforce these memory safety guarantees: it&amp;rsquo;s called &lt;em&gt;unsafe Rust&lt;/em&gt; and works just like regular Rust, but gives us extra superpowers.</source>
          <target state="translated">Для всего кода, который мы обсуждали до сих пор, во время компиляции применяются гарантии безопасности памяти Rust. Однако в Rust спрятан второй язык, который не обеспечивает этих гарантий безопасности памяти: он называется &lt;em&gt;небезопасным Rust&lt;/em&gt; и работает так же, как обычный Rust, но дает нам дополнительные сверхспособности.</target>
        </trans-unit>
        <trans-unit id="5d094a6ebf518b356f6cc88f0daffccbeaa88d1a" translate="yes" xml:space="preserve">
          <source>All the floating point types, such as &lt;code&gt;f64&lt;/code&gt;.</source>
          <target state="translated">Все типы с плавающей запятой, такие как &lt;code&gt;f64&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="49768c9761f944e57fd8b28ffb7ccca3ce0255bf" translate="yes" xml:space="preserve">
          <source>All the integer types, such as &lt;code&gt;u32&lt;/code&gt;.</source>
          <target state="translated">Все целочисленные типы, например &lt;code&gt;u32&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7aad067d2eb4fd66349ef7460833027940768e31" translate="yes" xml:space="preserve">
          <source>All the traits in &lt;a href=&quot;fmt/index&quot;&gt;&lt;code&gt;std::fmt&lt;/code&gt;&lt;/a&gt; except &lt;a href=&quot;fmt/trait.pointer&quot;&gt;&lt;code&gt;Pointer&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;fmt/trait.write&quot;&gt;&lt;code&gt;fmt::Write&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">Все черты &lt;a href=&quot;fmt/index&quot;&gt; &lt;code&gt;std::fmt&lt;/code&gt; &lt;/a&gt; кроме &lt;a href=&quot;fmt/trait.pointer&quot;&gt; &lt;code&gt;Pointer&lt;/code&gt; &lt;/a&gt; и &lt;a href=&quot;fmt/trait.write&quot;&gt; &lt;code&gt;fmt::Write&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="5fbc378a4bea0c74a504553c4655c69b13216d43" translate="yes" xml:space="preserve">
          <source>All tokens have an associated &lt;code&gt;Span&lt;/code&gt;. A &lt;code&gt;Span&lt;/code&gt; is an opaque value that cannot be modified but can be manufactured. &lt;code&gt;Span&lt;/code&gt;s represent an extent of source code within a program and are primarily used for error reporting. You can modify the &lt;code&gt;Span&lt;/code&gt; of any token.</source>
          <target state="translated">У всех токенов есть связанный &lt;code&gt;Span&lt;/code&gt; . &lt;code&gt;Span&lt;/code&gt; является непрозрачным значением , которое не может быть изменено , но может быть изготовлено. &lt;code&gt;Span&lt;/code&gt; представляют собой объем исходного кода в программе и в основном используются для сообщения об ошибках. Вы можете изменить &lt;code&gt;Span&lt;/code&gt; любого токена.</target>
        </trans-unit>
        <trans-unit id="c4b7c6a0fbafa4ae17e0c283d126acf9c731f848" translate="yes" xml:space="preserve">
          <source>All traits define an implicit type parameter &lt;code&gt;Self&lt;/code&gt; that refers to &quot;the type that is implementing this interface&quot;. Traits may also contain additional type parameters. These type parameters, including &lt;code&gt;Self&lt;/code&gt;, may be constrained by other traits and so forth &lt;a href=&quot;generics&quot;&gt;as usual&lt;/a&gt;.</source>
          <target state="translated">Все черты определяют неявный параметр типа &lt;code&gt;Self&lt;/code&gt; , который относится к &amp;laquo;типу, реализующему этот интерфейс&amp;raquo;. Свойства могут также содержать дополнительные параметры типа. Эти параметры типа, включая &lt;code&gt;Self&lt;/code&gt; , могут быть ограничены другими чертами и так далее, &lt;a href=&quot;generics&quot;&gt;как обычно&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="e6af2c7840468532a887d826478745d410145630" translate="yes" xml:space="preserve">
          <source>All type parameters have an implicit bound of &lt;code&gt;Sized&lt;/code&gt;. The special syntax &lt;code&gt;?Sized&lt;/code&gt; can be used to remove this bound if it's not appropriate.</source>
          <target state="translated">Все параметры типа имеют неявную границу &lt;code&gt;Sized&lt;/code&gt; . Для удаления этой границы можно использовать специальный синтаксис &lt;code&gt;?Sized&lt;/code&gt; если он не подходит.</target>
        </trans-unit>
        <trans-unit id="9fcb4ee73e3ea3e00af83f66cf487fb2ad10ff05" translate="yes" xml:space="preserve">
          <source>All types in a tuple struct aren't the same when using the &lt;code&gt;#[simd]&lt;/code&gt; attribute.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="687bde44d55450fc7926f1ddbef8c12777b88228" translate="yes" xml:space="preserve">
          <source>All user-defined composite types (&lt;code&gt;struct&lt;/code&gt;s, &lt;code&gt;enum&lt;/code&gt;s, and &lt;code&gt;union&lt;/code&gt;s) have a &lt;em&gt;representation&lt;/em&gt; that specifies what the layout is for the type. The possible representations for a type are:</source>
          <target state="translated">Все определяемые пользователем составные типы ( &lt;code&gt;struct&lt;/code&gt; s, &lt;code&gt;enum&lt;/code&gt; s и &lt;code&gt;union&lt;/code&gt; s) имеют &lt;em&gt;представление,&lt;/em&gt; которое указывает макет для типа. Возможные представления типа:</target>
        </trans-unit>
        <trans-unit id="b66aa8bf38f6384faa05e5ba7a817e6473b9a5b6" translate="yes" xml:space="preserve">
          <source>All values have an alignment and size.</source>
          <target state="translated">Все значения имеют выравнивание и размер.</target>
        </trans-unit>
        <trans-unit id="6b3bc16295776314b52aa5587d61ce1888ff84c1" translate="yes" xml:space="preserve">
          <source>Alloc</source>
          <target state="translated">Alloc</target>
        </trans-unit>
        <trans-unit id="73c626eee3cffa40774dfe1fcb9f6b9bd69dc64f" translate="yes" xml:space="preserve">
          <source>Alloc::alloc</source>
          <target state="translated">Alloc::alloc</target>
        </trans-unit>
        <trans-unit id="58fa8f803498e5ec9addefde8bfd45a79dbec5ed" translate="yes" xml:space="preserve">
          <source>Alloc::alloc_array</source>
          <target state="translated">Alloc::alloc_array</target>
        </trans-unit>
        <trans-unit id="b50e7d6a8a9d06e47daea96c8b2aea5c45efb165" translate="yes" xml:space="preserve">
          <source>Alloc::alloc_excess</source>
          <target state="translated">Alloc::alloc_excess</target>
        </trans-unit>
        <trans-unit id="889b443e61594610d30213145f921f146db36832" translate="yes" xml:space="preserve">
          <source>Alloc::alloc_one</source>
          <target state="translated">Alloc::alloc_one</target>
        </trans-unit>
        <trans-unit id="a34261c2be453348710c37c58e7b9c83398884d8" translate="yes" xml:space="preserve">
          <source>Alloc::alloc_zeroed</source>
          <target state="translated">Alloc::alloc_zeroed</target>
        </trans-unit>
        <trans-unit id="7d3d2688c4fd76b53fe3390539a364662ab17d4b" translate="yes" xml:space="preserve">
          <source>Alloc::dealloc</source>
          <target state="translated">Alloc::dealloc</target>
        </trans-unit>
        <trans-unit id="640d5625de8ef766306d60749a2169115e55e156" translate="yes" xml:space="preserve">
          <source>Alloc::dealloc_array</source>
          <target state="translated">Alloc::dealloc_array</target>
        </trans-unit>
        <trans-unit id="7053fc65b9dd32b26e961ddd07f10fe845724b56" translate="yes" xml:space="preserve">
          <source>Alloc::dealloc_one</source>
          <target state="translated">Alloc::dealloc_one</target>
        </trans-unit>
        <trans-unit id="c1a3b352f967fd646042d5ec8feb84a7842b4835" translate="yes" xml:space="preserve">
          <source>Alloc::grow_in_place</source>
          <target state="translated">Alloc::grow_in_place</target>
        </trans-unit>
        <trans-unit id="b0c3031aac44345a0cd3601e017910c7886cd822" translate="yes" xml:space="preserve">
          <source>Alloc::realloc</source>
          <target state="translated">Alloc::realloc</target>
        </trans-unit>
        <trans-unit id="50682f5a6557029f4ae580a726dd0a2a8ee83c83" translate="yes" xml:space="preserve">
          <source>Alloc::realloc_array</source>
          <target state="translated">Alloc::realloc_array</target>
        </trans-unit>
        <trans-unit id="71b9b4276801f0c0a766cb281400a5a34452c7e1" translate="yes" xml:space="preserve">
          <source>Alloc::realloc_excess</source>
          <target state="translated">Alloc::realloc_excess</target>
        </trans-unit>
        <trans-unit id="caed8ad7c332dd652a64a2f5a64ee5adce448144" translate="yes" xml:space="preserve">
          <source>Alloc::shrink_in_place</source>
          <target state="translated">Alloc::shrink_in_place</target>
        </trans-unit>
        <trans-unit id="4bdde8e404d1e339cdf8e89ef42138d76fb64cb5" translate="yes" xml:space="preserve">
          <source>Alloc::usable_size</source>
          <target state="translated">Alloc::usable_size</target>
        </trans-unit>
        <trans-unit id="74f9a2a318fbafb57c2a318b7f97cd7f558235f5" translate="yes" xml:space="preserve">
          <source>AllocErr</source>
          <target state="translated">AllocErr</target>
        </trans-unit>
        <trans-unit id="81a1e8e44229166f6c5d59b8b5cdfbd7de11a910" translate="yes" xml:space="preserve">
          <source>AllocErr::borrow</source>
          <target state="translated">AllocErr::borrow</target>
        </trans-unit>
        <trans-unit id="cab0d29cfc07f03d441e5891d8fdae354b136ec1" translate="yes" xml:space="preserve">
          <source>AllocErr::borrow_mut</source>
          <target state="translated">AllocErr::borrow_mut</target>
        </trans-unit>
        <trans-unit id="c63e5f5e71fd2207c8a6514237ae70d9dca95cf3" translate="yes" xml:space="preserve">
          <source>AllocErr::cause</source>
          <target state="translated">AllocErr::cause</target>
        </trans-unit>
        <trans-unit id="09ff0aa0e6ca318ce203b20e17f08354650229f1" translate="yes" xml:space="preserve">
          <source>AllocErr::clone</source>
          <target state="translated">AllocErr::clone</target>
        </trans-unit>
        <trans-unit id="777d6911608c872b31c4bdb18d3b776c08a9b8f5" translate="yes" xml:space="preserve">
          <source>AllocErr::clone_from</source>
          <target state="translated">AllocErr::clone_from</target>
        </trans-unit>
        <trans-unit id="b678a089fb922c246660ee4daaf38a5251355da7" translate="yes" xml:space="preserve">
          <source>AllocErr::clone_into</source>
          <target state="translated">AllocErr::clone_into</target>
        </trans-unit>
        <trans-unit id="5df229543f81998e9da115264fa06013a927adb1" translate="yes" xml:space="preserve">
          <source>AllocErr::description</source>
          <target state="translated">AllocErr::description</target>
        </trans-unit>
        <trans-unit id="d2cf0a94fd5cf29c79c5284616875b84972fb312" translate="yes" xml:space="preserve">
          <source>AllocErr::eq</source>
          <target state="translated">AllocErr::eq</target>
        </trans-unit>
        <trans-unit id="5881f4abcdbf06d5924b4a78a521cc0027e69523" translate="yes" xml:space="preserve">
          <source>AllocErr::fmt</source>
          <target state="translated">AllocErr::fmt</target>
        </trans-unit>
        <trans-unit id="270a3da0beb21d444fb57d0c363b8a08cfe0f022" translate="yes" xml:space="preserve">
          <source>AllocErr::from</source>
          <target state="translated">AllocErr::from</target>
        </trans-unit>
        <trans-unit id="98b28dbbeacbc8b3f7530e8cbb0f5369608cd809" translate="yes" xml:space="preserve">
          <source>AllocErr::into</source>
          <target state="translated">AllocErr::into</target>
        </trans-unit>
        <trans-unit id="039711c278e014b513a0be997690fca2416f8474" translate="yes" xml:space="preserve">
          <source>AllocErr::ne</source>
          <target state="translated">AllocErr::ne</target>
        </trans-unit>
        <trans-unit id="ffa94c7186e9f5d1d7bf9c63828fb87e4a775ad5" translate="yes" xml:space="preserve">
          <source>AllocErr::source</source>
          <target state="translated">AllocErr::source</target>
        </trans-unit>
        <trans-unit id="0aeb755570b957275d6d9d5317212dc6a6535090" translate="yes" xml:space="preserve">
          <source>AllocErr::to_owned</source>
          <target state="translated">AllocErr::to_owned</target>
        </trans-unit>
        <trans-unit id="0e17e4e80e3c6af6ed45e6c032cf33d55d346e46" translate="yes" xml:space="preserve">
          <source>AllocErr::to_string</source>
          <target state="translated">AllocErr::to_string</target>
        </trans-unit>
        <trans-unit id="3e40fc0676c76a71ca131dafb97f38662652bfbf" translate="yes" xml:space="preserve">
          <source>AllocErr::try_from</source>
          <target state="translated">AllocErr::try_from</target>
        </trans-unit>
        <trans-unit id="34d1124cc06e84256717b819e1f63b955e0350bf" translate="yes" xml:space="preserve">
          <source>AllocErr::try_into</source>
          <target state="translated">AllocErr::try_into</target>
        </trans-unit>
        <trans-unit id="663b204a54c41c16c072ee135d91fa4be49de349" translate="yes" xml:space="preserve">
          <source>AllocErr::type_id</source>
          <target state="translated">AllocErr::type_id</target>
        </trans-unit>
        <trans-unit id="fc99a18ee7862835928c295e62957162ad4eb462" translate="yes" xml:space="preserve">
          <source>AllocError</source>
          <target state="translated">AllocError</target>
        </trans-unit>
        <trans-unit id="4893f8fbd4cad55fcdd644464bc1fe91c279e953" translate="yes" xml:space="preserve">
          <source>AllocRef</source>
          <target state="translated">AllocRef</target>
        </trans-unit>
        <trans-unit id="7cf8dec3c93750b3604d319f88c1f6b4a582f73b" translate="yes" xml:space="preserve">
          <source>Allocate at compile time. Should not be called at runtime.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4893c8174f6c1eabc41e7843e70d7ebcff1b1f84" translate="yes" xml:space="preserve">
          <source>Allocate memory as described by the given &lt;code&gt;layout&lt;/code&gt;.</source>
          <target state="translated">Выделите память, как описано в данном &lt;code&gt;layout&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="cd02c9bc4eedba216d90a16d722506e0ce680a8a" translate="yes" xml:space="preserve">
          <source>Allocate memory as described by the given &lt;code&gt;layout&lt;/code&gt;. &lt;a href=&quot;trait.globalalloc#tymethod.alloc&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">Выделите память, как описано в данном &lt;code&gt;layout&lt;/code&gt; . &lt;a href=&quot;trait.globalalloc#tymethod.alloc&quot;&gt;Читать далее&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="74c59d8374e4ee1d975ce714a71b5fcdbb7aacac" translate="yes" xml:space="preserve">
          <source>Allocate memory with the global allocator.</source>
          <target state="translated">Распределение памяти с глобальным аллокатором.</target>
        </trans-unit>
        <trans-unit id="cfb8411e19f0f79e91b6b66f6609da2b9991a1e5" translate="yes" xml:space="preserve">
          <source>Allocate zero-initialized memory with the global allocator.</source>
          <target state="translated">Распределение нулевой инициализированной памяти с помощью глобального аллокатора.</target>
        </trans-unit>
        <trans-unit id="1bfdf7915bd5c3db982b39e0a3309425f8ee260d" translate="yes" xml:space="preserve">
          <source>Allocates a block suitable for holding &lt;code&gt;n&lt;/code&gt; instances of &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">Распределяет блок - подходящие для проведения &lt;code&gt;n&lt;/code&gt; экземпляров &lt;code&gt;T&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c63c156459af2e92bb9b73d7f0f9844433b5dc2f" translate="yes" xml:space="preserve">
          <source>Allocates a block suitable for holding &lt;code&gt;n&lt;/code&gt; instances of &lt;code&gt;T&lt;/code&gt;. &lt;a href=&quot;trait.alloc#method.alloc_array&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">Распределяет блок - подходящие для проведения &lt;code&gt;n&lt;/code&gt; экземпляров &lt;code&gt;T&lt;/code&gt; . &lt;a href=&quot;trait.alloc#method.alloc_array&quot;&gt;Читать далее&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="ed375cd7b209e0c5769df096531bae03a872bbbb" translate="yes" xml:space="preserve">
          <source>Allocates a block suitable for holding an instance of &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">Распределяет блок , пригодный для проведения экземпляра &lt;code&gt;T&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="02c72ac7d36294390fedc764c2754fe1636d64b1" translate="yes" xml:space="preserve">
          <source>Allocates a block suitable for holding an instance of &lt;code&gt;T&lt;/code&gt;. &lt;a href=&quot;trait.alloc#method.alloc_one&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">Распределяет блок , пригодный для проведения экземпляра &lt;code&gt;T&lt;/code&gt; . &lt;a href=&quot;trait.alloc#method.alloc_one&quot;&gt;Читать далее&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="76e23de7e691468d4d99aac266130e3bc34f2ea4" translate="yes" xml:space="preserve">
          <source>Allocates an empty &lt;code&gt;PathBuf&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;PathBuf&lt;/code&gt; пустой PathBuf .</target>
        </trans-unit>
        <trans-unit id="3c08c70aff2d6ac267aff88abe6336b4c67e3719" translate="yes" xml:space="preserve">
          <source>Allocates memory in the given allocator then places &lt;code&gt;x&lt;/code&gt; into it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f9ce219d6c4b42c1f87ab6030532c065b1fec11f" translate="yes" xml:space="preserve">
          <source>Allocates memory on the heap and then places &lt;code&gt;x&lt;/code&gt; into it.</source>
          <target state="translated">Выделяет память в куче, а затем помещает в нее &lt;code&gt;x&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="cbf9e75065cafb419b19fb5a13dddefb2735eaa6" translate="yes" xml:space="preserve">
          <source>Allocator</source>
          <target state="translated">Allocator</target>
        </trans-unit>
        <trans-unit id="e910169c58168ed4f75b19228b519cfb61699e61" translate="yes" xml:space="preserve">
          <source>Allow generic type parameter to be a dynamically sized type</source>
          <target state="translated">Разрешить типовой параметр динамического размера</target>
        </trans-unit>
        <trans-unit id="40680c6330eab7e25541ffbe63efc1d14385635b" translate="yes" xml:space="preserve">
          <source>Allow users to add text content only when a post is in the &lt;code&gt;Draft&lt;/code&gt; state. Hint: have the state object responsible for what might change about the content but not responsible for modifying the &lt;code&gt;Post&lt;/code&gt;.</source>
          <target state="translated">Разрешить пользователям добавлять текстовое содержимое только тогда, когда сообщение находится в состоянии &lt;code&gt;Draft&lt;/code&gt; . Подсказка: пусть объект состояния отвечает за то, что может измениться в содержимом, но не отвечает за изменение &lt;code&gt;Post&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6cb50b4ef5745cf62353aeff34203276011ef50f" translate="yes" xml:space="preserve">
          <source>Allowing Access from Multiple Threads with &lt;code id=&quot;allowing-access-from-multiple-threads-with-sync&quot;&gt;Sync&lt;/code&gt;</source>
          <target state="translated">Разрешение доступа из нескольких потоков с &lt;code id=&quot;allowing-access-from-multiple-threads-with-sync&quot;&gt;Sync&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="fae2d8f4c50be8a20cdea347ace493568595fcd3" translate="yes" xml:space="preserve">
          <source>Allowing Multiple Guesses with Looping</source>
          <target state="translated">Разрешение нескольких догадок с петлей</target>
        </trans-unit>
        <trans-unit id="7db289670d5f2b576ba5fbc25cdc4ef16295c536" translate="yes" xml:space="preserve">
          <source>Allowing Transference of Ownership Between Threads with &lt;code id=&quot;allowing-transference-of-ownership-between-threads-with-send&quot;&gt;Send&lt;/code&gt;</source>
          <target state="translated">Разрешение передачи права собственности между потоками с помощью &lt;code id=&quot;allowing-transference-of-ownership-between-threads-with-send&quot;&gt;Send&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="fb09e5f22f3b7d16947a2ecaccff480c6609f901" translate="yes" xml:space="preserve">
          <source>Almost always it is better to use &lt;code&gt;Vec&lt;/code&gt; or &lt;a href=&quot;../vec_deque/struct.vecdeque&quot;&gt;&lt;code&gt;VecDeque&lt;/code&gt;&lt;/a&gt; instead of &lt;a href=&quot;struct.linkedlist&quot;&gt;&lt;code&gt;LinkedList&lt;/code&gt;&lt;/a&gt;. In general, array-based containers are faster, more memory efficient and make better use of CPU cache.</source>
          <target state="translated">Практически всегда лучше использовать &lt;code&gt;Vec&lt;/code&gt; или &lt;a href=&quot;../vec_deque/struct.vecdeque&quot;&gt; &lt;code&gt;VecDeque&lt;/code&gt; &lt;/a&gt; вместо &lt;a href=&quot;struct.linkedlist&quot;&gt; &lt;code&gt;LinkedList&lt;/code&gt; &lt;/a&gt; . Как правило, контейнеры на основе массивов быстрее, эффективнее используют память и лучше используют кэш ЦП.</target>
        </trans-unit>
        <trans-unit id="96a3f97ad5d3ab3ce2ee9333276a6a44f6055cf9" translate="yes" xml:space="preserve">
          <source>Almost always it is better to use &lt;code&gt;Vec&lt;/code&gt; or &lt;code&gt;VecDeque&lt;/code&gt; instead of &lt;code&gt;LinkedList&lt;/code&gt;. In general, array-based containers are faster, more memory efficient and make better use of CPU cache.</source>
          <target state="translated">Практически всегда лучше использовать &lt;code&gt;Vec&lt;/code&gt; или &lt;code&gt;VecDeque&lt;/code&gt; вместо &lt;code&gt;LinkedList&lt;/code&gt; . Как правило, контейнеры на основе массивов быстрее, эффективнее используют память и лучше используют кэш ЦП.</target>
        </trans-unit>
        <trans-unit id="30066ada2ed0aa1faf9262f27c4ed17333b52206" translate="yes" xml:space="preserve">
          <source>Along the way, we&amp;rsquo;ll show how to make our command line tool use features of the terminal that many command line tools use. We&amp;rsquo;ll read the value of an environment variable to allow the user to configure the behavior of our tool. We&amp;rsquo;ll also print error messages to the standard error console stream (&lt;code&gt;stderr&lt;/code&gt;) instead of standard output (&lt;code&gt;stdout&lt;/code&gt;), so, for example, the user can redirect successful output to a file while still seeing error messages onscreen.</source>
          <target state="translated">Попутно мы покажем, как заставить наш инструмент командной строки использовать функции терминала, которые используют многие инструменты командной строки. Мы прочитаем значение переменной среды, чтобы пользователь мог настроить поведение нашего инструмента. Мы также будем печатать сообщения об ошибках в стандартном потоке консоли ошибок ( &lt;code&gt;stderr&lt;/code&gt; ) вместо стандартного вывода ( &lt;code&gt;stdout&lt;/code&gt; ), поэтому, например, пользователь может перенаправить успешный вывод в файл, все еще видя сообщения об ошибках на экране.</target>
        </trans-unit>
        <trans-unit id="2cbf8cd5d5a46820a0f6ab73279f92ce571b3bc8" translate="yes" xml:space="preserve">
          <source>Along with being made public via &lt;code&gt;pub&lt;/code&gt;, &lt;code&gt;fn&lt;/code&gt; can also have an &lt;a href=&quot;keyword.extern&quot;&gt;&lt;code&gt;extern&lt;/code&gt;&lt;/a&gt; added for use in FFI.</source>
          <target state="translated">Наряду с публикацией через &lt;code&gt;pub&lt;/code&gt; , &lt;code&gt;fn&lt;/code&gt; также может иметь добавленный &lt;a href=&quot;keyword.extern&quot;&gt; &lt;code&gt;extern&lt;/code&gt; &lt;/a&gt; для использования в FFI.</target>
        </trans-unit>
        <trans-unit id="569f87a8387e1554badafba00588c85d0f8bf792" translate="yes" xml:space="preserve">
          <source>Along with the newtype pattern, Rust provides the ability to declare a &lt;em&gt;type alias&lt;/em&gt; to give an existing type another name. For this we use the &lt;code&gt;type&lt;/code&gt; keyword. For example, we can create the alias &lt;code&gt;Kilometers&lt;/code&gt; to &lt;code&gt;i32&lt;/code&gt; like so:</source>
          <target state="translated">Наряду с шаблоном newtype Rust предоставляет возможность объявить &lt;em&gt;псевдоним типа,&lt;/em&gt; чтобы дать существующему типу другое имя. Для этого мы используем ключевое слово &lt;code&gt;type&lt;/code&gt; . Например, мы можем создать псевдоним &amp;laquo; &lt;code&gt;Kilometers&lt;/code&gt; для &lt;code&gt;i32&lt;/code&gt; следующим образом:</target>
        </trans-unit>
        <trans-unit id="6444cb062f09d53622baea0cd17deb96b9dc9f75" translate="yes" xml:space="preserve">
          <source>Also discussed were the &lt;code&gt;Deref&lt;/code&gt; and &lt;code&gt;Drop&lt;/code&gt; traits, which enable a lot of the functionality of smart pointers. We explored reference cycles that can cause memory leaks and how to prevent them using &lt;code&gt;Weak&amp;lt;T&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">Также обсуждались &lt;code&gt;Deref&lt;/code&gt; и &lt;code&gt;Drop&lt;/code&gt; , которые обеспечивают большую часть функциональности интеллектуальных указателей. Мы изучили ссылочные циклы, которые могут вызывать утечки памяти, и способы их предотвращения с помощью &lt;code&gt;Weak&amp;lt;T&amp;gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d6fc1b2f8caf81c693f670285ed3e30e58c8f202" translate="yes" xml:space="preserve">
          <source>Also note that &lt;code&gt;Iterator&lt;/code&gt; provides a default implementation of methods such as &lt;code&gt;nth&lt;/code&gt; and &lt;code&gt;fold&lt;/code&gt; which call &lt;code&gt;next&lt;/code&gt; internally. However, it is also possible to write a custom implementation of methods like &lt;code&gt;nth&lt;/code&gt; and &lt;code&gt;fold&lt;/code&gt; if an iterator can compute them more efficiently without calling &lt;code&gt;next&lt;/code&gt;.</source>
          <target state="translated">Также обратите внимание, что &lt;code&gt;Iterator&lt;/code&gt; предоставляет реализацию по умолчанию таких методов, как &lt;code&gt;nth&lt;/code&gt; и &lt;code&gt;fold&lt;/code&gt; , которые вызывают внутренний вызов &lt;code&gt;next&lt;/code&gt; . Однако также можно написать собственную реализацию методов, таких как &lt;code&gt;nth&lt;/code&gt; и &lt;code&gt;fold&lt;/code&gt; , если итератор может вычислить их более эффективно без вызова &lt;code&gt;next&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2a7fb665b167f214e0e11085759c66fc45c5b538" translate="yes" xml:space="preserve">
          <source>Also note that Cargo build scripts can learn about this feature through &lt;a href=&quot;http://doc.crates.io/environment-variables.html#environment-variables-cargo-sets-for-build-scripts&quot;&gt;environment variables&lt;/a&gt;. In a build script you can detect the linkage via:</source>
          <target state="translated">Также обратите внимание, что скрипты сборки Cargo могут узнать об этой функции через &lt;a href=&quot;http://doc.crates.io/environment-variables.html#environment-variables-cargo-sets-for-build-scripts&quot;&gt;переменные среды&lt;/a&gt; . В сценарии сборки вы можете обнаружить связь через:</target>
        </trans-unit>
        <trans-unit id="0d1efc462e5f1fbd3ec91e9a65ca5ad80e9b3a5b" translate="yes" xml:space="preserve">
          <source>Also note that Cargo build scripts can learn about this feature through &lt;a href=&quot;https://doc.rust-lang.org/cargo/reference/environment-variables.html#environment-variables-cargo-sets-for-build-scripts&quot;&gt;environment variables&lt;/a&gt;. In a build script you can detect the linkage via:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="729f1c9440272260f81d5cd373556bbc830572f8" translate="yes" xml:space="preserve">
          <source>Also note that the values we get from the calls to &lt;code&gt;next&lt;/code&gt; are immutable references to the values in the vector. The &lt;code&gt;iter&lt;/code&gt; method produces an iterator over immutable references. If we want to create an iterator that takes ownership of &lt;code&gt;v1&lt;/code&gt; and returns owned values, we can call &lt;code&gt;into_iter&lt;/code&gt; instead of &lt;code&gt;iter&lt;/code&gt;. Similarly, if we want to iterate over mutable references, we can call &lt;code&gt;iter_mut&lt;/code&gt; instead of &lt;code&gt;iter&lt;/code&gt;.</source>
          <target state="translated">Также обратите внимание, что значения, которые мы получаем от вызовов &lt;code&gt;next&lt;/code&gt; , являются неизменяемыми ссылками на значения в векторе. Метод &lt;code&gt;iter&lt;/code&gt; создает итератор по неизменяемым ссылкам. Если мы хотим создать итератор, который становится владельцем &lt;code&gt;v1&lt;/code&gt; и возвращает принадлежащие ему значения, мы можем вызвать &lt;code&gt;into_iter&lt;/code&gt; вместо &lt;code&gt;iter&lt;/code&gt; . Точно так же, если мы хотим перебирать изменяемые ссылки, мы можем вызвать &lt;code&gt;iter_mut&lt;/code&gt; вместо &lt;code&gt;iter&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b9ce0f5a9623fa773f46d4f2d15f1add40c61350" translate="yes" xml:space="preserve">
          <source>Also note that unwinding into Rust code with a foreign exception (e.g. a an exception thrown from C++ code) is undefined behavior.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ce251a63845ba69b5ad2fd9f201455284f4f01ee" translate="yes" xml:space="preserve">
          <source>Also note that we switched the type of the &lt;code&gt;t&lt;/code&gt; parameter from &lt;code&gt;T&lt;/code&gt; to &lt;code&gt;&amp;amp;T&lt;/code&gt;. Because the type might not be &lt;code&gt;Sized&lt;/code&gt;, we need to use it behind some kind of pointer. In this case, we&amp;rsquo;ve chosen a reference.</source>
          <target state="translated">Также отметим , что мы перешли тип &lt;code&gt;t&lt;/code&gt; параметра от &lt;code&gt;T&lt;/code&gt; до &lt;code&gt;&amp;amp;T&lt;/code&gt; . Поскольку тип может не иметь &lt;code&gt;Sized&lt;/code&gt; , нам нужно использовать его за каким-то указателем. В данном случае мы выбрали ссылку.</target>
        </trans-unit>
        <trans-unit id="19148a1d1c1b97af52ac182d255aa33cc3c9304e" translate="yes" xml:space="preserve">
          <source>Also of note is the special syntax for &lt;code&gt;Fn&lt;/code&gt; traits (e.g. &lt;code&gt;Fn(usize, bool) -&amp;gt; usize&lt;/code&gt;). Those interested in the technical details of this can refer to &lt;a href=&quot;https://doc.rust-lang.org/nomicon/hrtb.html&quot;&gt;the relevant section in the &lt;em&gt;Rustonomicon&lt;/em&gt;&lt;/a&gt;.</source>
          <target state="translated">Также следует отметить специальный синтаксис для признаков &lt;code&gt;Fn&lt;/code&gt; (например, &lt;code&gt;Fn(usize, bool) -&amp;gt; usize&lt;/code&gt; ). Те, кто интересуется техническими подробностями этого, могут обратиться к &lt;a href=&quot;https://doc.rust-lang.org/nomicon/hrtb.html&quot;&gt;соответствующему разделу в &lt;em&gt;Rustonomicon&lt;/em&gt;&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="57bf42e074718d5ea685f5e68450e52bab2d09dc" translate="yes" xml:space="preserve">
          <source>Also verify that you didn't misspell the import name and that the import exists in the module from where you tried to import it. Example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ba09134ec4e68053a65f33dbded8cc605eed58ef" translate="yes" xml:space="preserve">
          <source>Also, &lt;code&gt;ManuallyDrop&lt;/code&gt; prevents us from having to &quot;touch&quot; &lt;code&gt;v&lt;/code&gt; after transferring the ownership to &lt;code&gt;s&lt;/code&gt; &amp;mdash; the final step of interacting with &lt;code&gt;v&lt;/code&gt; to dispose of it without running its destructor is entirely avoided.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9d4cb652a8b78bec628c1d26d0df6d4c9f7c28ed" translate="yes" xml:space="preserve">
          <source>Also, if the type of the expression to the left of the dot is a pointer, it is automatically dereferenced as many times as necessary to make the field access possible. In cases of ambiguity, we prefer fewer autoderefs to more.</source>
          <target state="translated">Также,если тип выражения слева от точки является указателем,то оно автоматически разыменовывается столько раз,сколько необходимо,чтобы сделать возможным доступ к полю.В случаях неоднозначности мы предпочитаем меньше автодокументов,а не больше.</target>
        </trans-unit>
        <trans-unit id="56542ee08fdcb89c559a45ec666da5ba100aa6fa" translate="yes" xml:space="preserve">
          <source>Also, it allocates temporary storage half the size of &lt;code&gt;self&lt;/code&gt;, but for short slices a non-allocating insertion sort is used instead.</source>
          <target state="translated">Кроме того, он выделяет временное хранилище в два раза меньше размера &lt;code&gt;self&lt;/code&gt; , но для коротких фрагментов вместо этого используется сортировка вставкой без выделения памяти .</target>
        </trans-unit>
        <trans-unit id="f704331d388fc32203be48400c9dc63ab996ddd9" translate="yes" xml:space="preserve">
          <source>Also, note that &lt;code&gt;vec![expr; 0]&lt;/code&gt; is allowed, and produces an empty vector. This will still evaluate &lt;code&gt;expr&lt;/code&gt;, however, and immediately drop the resulting value, so be mindful of side effects.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="71671f4bb484f8a1e973c0578cc13715a3aa2105" translate="yes" xml:space="preserve">
          <source>Also, note that because &lt;code&gt;back_of_house::Breakfast&lt;/code&gt; has a private field, the struct needs to provide a public associated function that constructs an instance of &lt;code&gt;Breakfast&lt;/code&gt; (we&amp;rsquo;ve named it &lt;code&gt;summer&lt;/code&gt; here). If &lt;code&gt;Breakfast&lt;/code&gt; didn&amp;rsquo;t have such a function, we couldn&amp;rsquo;t create an instance of &lt;code&gt;Breakfast&lt;/code&gt; in &lt;code&gt;eat_at_restaurant&lt;/code&gt; because we couldn&amp;rsquo;t set the value of the private &lt;code&gt;seasonal_fruit&lt;/code&gt; field in &lt;code&gt;eat_at_restaurant&lt;/code&gt;.</source>
          <target state="translated">Также обратите внимание, что, поскольку &lt;code&gt;back_of_house::Breakfast&lt;/code&gt; имеет частное поле, структура должна предоставить общедоступную связанную функцию, которая создает экземпляр &lt;code&gt;Breakfast&lt;/code&gt; (здесь мы назвали его &lt;code&gt;summer&lt;/code&gt; ). Если &lt;code&gt;Breakfast&lt;/code&gt; не имеет такой функции, мы не смогли создать экземпляр &lt;code&gt;Breakfast&lt;/code&gt; в &lt;code&gt;eat_at_restaurant&lt;/code&gt; , потому что мы не могли установить значение частного &lt;code&gt;seasonal_fruit&lt;/code&gt; поля в &lt;code&gt;eat_at_restaurant&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="477dbb63bb02aa6d30fe03da09f8465ff169a963" translate="yes" xml:space="preserve">
          <source>Also, note that the function body is wrapped in curly brackets, &lt;code&gt;{}&lt;/code&gt;. Rust requires these around all function bodies. It&amp;rsquo;s good style to place the opening curly bracket on the same line as the function declaration, adding one space in between.</source>
          <target state="translated">Также обратите внимание, что тело функции заключено в фигурные скобки, &lt;code&gt;{}&lt;/code&gt; . Rust требует их использования для всех функциональных тел. Хороший стиль - разместить открывающую фигурную скобку на той же строке, что и объявление функции, добавив между ними один пробел.</target>
        </trans-unit>
        <trans-unit id="8c50010a52d6913ce8428bd39d3014c723f0db3d" translate="yes" xml:space="preserve">
          <source>Also, please be aware that this method is only for special circumstances and is usually not what you want. In case of doubt, use &lt;a href=&quot;#method.borrow_mut&quot;&gt;&lt;code&gt;borrow_mut&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">Кроме того, имейте в виду, что этот метод предназначен только для особых обстоятельств и обычно не подходит вам. В случае сомнений используйте вместо этого &lt;a href=&quot;#method.borrow_mut&quot;&gt; &lt;code&gt;borrow_mut&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="f205a44cb9a6329dc5c185e41300997837dbbfe5" translate="yes" xml:space="preserve">
          <source>Also, please be aware that this method is only for special circumstances and is usually not what you want. In case of doubt, use &lt;a href=&quot;struct.refcell#method.borrow_mut&quot;&gt;&lt;code&gt;borrow_mut&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2edbd5a08a0137666e61eca4932691fdf6681fd9" translate="yes" xml:space="preserve">
          <source>Also, since &lt;code&gt;bool&lt;/code&gt; implements the &lt;a href=&quot;marker/trait.copy&quot;&gt;&lt;code&gt;Copy&lt;/code&gt;&lt;/a&gt; trait, we don't have to worry about the move semantics (just like the integer and float primitives).</source>
          <target state="translated">Кроме того, поскольку &lt;code&gt;bool&lt;/code&gt; реализует трейт &lt;a href=&quot;marker/trait.copy&quot;&gt; &lt;code&gt;Copy&lt;/code&gt; &lt;/a&gt; , нам не нужно беспокоиться о семантике перемещения (как и в примитивах integer и float).</target>
        </trans-unit>
        <trans-unit id="a9b0dcda2ee36870b49794f990ce3f2eb9803892" translate="yes" xml:space="preserve">
          <source>Alternatively there can be exactly two expressions inside the brackets, separated by a semi-colon. The expression after the &lt;code&gt;;&lt;/code&gt; must be a have type &lt;code&gt;usize&lt;/code&gt; and be a &lt;a href=&quot;../const_eval#constant-expressions&quot;&gt;constant expression&lt;/a&gt;, such as a &lt;a href=&quot;../tokens#literals&quot;&gt;literal&lt;/a&gt; or a &lt;a href=&quot;../items/constant-items&quot;&gt;constant item&lt;/a&gt;. &lt;code&gt;[a; b]&lt;/code&gt; creates an array containing &lt;code&gt;b&lt;/code&gt; copies of the value of &lt;code&gt;a&lt;/code&gt;. If the expression after the semi-colon has a value greater than 1 then this requires that the type of &lt;code&gt;a&lt;/code&gt; is &lt;a href=&quot;../special-types-and-traits#copy&quot;&gt;&lt;code&gt;Copy&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">В качестве альтернативы в скобках может быть ровно два выражения, разделенных точкой с запятой. Выражение после &lt;code&gt;;&lt;/code&gt; должен иметь тип &lt;code&gt;usize&lt;/code&gt; и быть &lt;a href=&quot;../const_eval#constant-expressions&quot;&gt;постоянным выражением&lt;/a&gt; , например &lt;a href=&quot;../tokens#literals&quot;&gt;литералом&lt;/a&gt; или &lt;a href=&quot;../items/constant-items&quot;&gt;константой&lt;/a&gt; . &lt;code&gt;[a; b]&lt;/code&gt; создает массив, содержащий &lt;code&gt;b&lt;/code&gt; копий значения &lt;code&gt;a&lt;/code&gt; . Если выражение после точки с запятой имеет значение больше 1, то это требует, чтобы тип &lt;code&gt;a&lt;/code&gt; был &lt;a href=&quot;../special-types-and-traits#copy&quot;&gt; &lt;code&gt;Copy&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="fc6c67aa2ed479ece24dfe7dd6029027bbfca2b3" translate="yes" xml:space="preserve">
          <source>Alternatively there can be exactly two expressions inside the brackets, separated by a semi-colon. The expression after the &lt;code&gt;;&lt;/code&gt; must have type &lt;code&gt;usize&lt;/code&gt; and be a &lt;a href=&quot;../const_eval#constant-expressions&quot;&gt;constant expression&lt;/a&gt;, such as a &lt;a href=&quot;../tokens#literals&quot;&gt;literal&lt;/a&gt; or a &lt;a href=&quot;../items/constant-items&quot;&gt;constant item&lt;/a&gt;. &lt;code&gt;[a; b]&lt;/code&gt; creates an array containing &lt;code&gt;b&lt;/code&gt; copies of the value of &lt;code&gt;a&lt;/code&gt;. If the expression after the semi-colon has a value greater than 1 then this requires that the type of &lt;code&gt;a&lt;/code&gt; is &lt;a href=&quot;../special-types-and-traits#copy&quot;&gt;&lt;code&gt;Copy&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3c2b342df42a5ce80106fad6cca3ec251f8df3e4" translate="yes" xml:space="preserve">
          <source>Alternatively, &lt;code&gt;PhantomData&amp;lt;T&amp;gt;&lt;/code&gt; has alignment 1 for all &lt;code&gt;T&lt;/code&gt;, so you can use it if you need to keep the field for some reason:</source>
          <target state="translated">В качестве альтернативы &lt;code&gt;PhantomData&amp;lt;T&amp;gt;&lt;/code&gt; имеет выравнивание 1 для всех &lt;code&gt;T&lt;/code&gt; , поэтому вы можете использовать его, если вам по какой-то причине нужно сохранить поле:</target>
        </trans-unit>
        <trans-unit id="38449305205a0baadf0d931713ad745060ac7795" translate="yes" xml:space="preserve">
          <source>Alternatively, a paren-less version of the attribute may be used to hint the compiler about inlining opportunity:</source>
          <target state="translated">Кроме того,безродная версия атрибута может быть использована для подсказки компилятору о возможности встраивания:</target>
        </trans-unit>
        <trans-unit id="d329c92752ab59bc5a187b9f641894d29c9fd208" translate="yes" xml:space="preserve">
          <source>Alternatively, define a trait locally and implement that instead:</source>
          <target state="translated">В качестве альтернативы,определите черту локально и используйте ее вместо этого:</target>
        </trans-unit>
        <trans-unit id="30596c4d15742cc562b249b398f8c80c1a13a17f" translate="yes" xml:space="preserve">
          <source>Alternatively, if the type parameter was intentionally inserted, it must be used. A simple fix is shown below:</source>
          <target state="translated">В качестве альтернативы,если параметр типа был введен намеренно,его необходимо использовать.Простое исправление показано ниже:</target>
        </trans-unit>
        <trans-unit id="7c8d494311629dbdec7e4dda72d552e11aace0ec" translate="yes" xml:space="preserve">
          <source>Alternatively, if we don't control the struct's definition, or mutable shared ownership is truly required, we can use &lt;code&gt;Rc&lt;/code&gt; and &lt;code&gt;RefCell&lt;/code&gt;:</source>
          <target state="translated">В качестве альтернативы, если мы не контролируем определение структуры или действительно требуется изменяемое совместное владение, мы можем использовать &lt;code&gt;Rc&lt;/code&gt; и &lt;code&gt;RefCell&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="0a59d2fc84eff79b213967bc64daab09652e8ccb" translate="yes" xml:space="preserve">
          <source>Alternatively, if your type implements &lt;code&gt;Clone&lt;/code&gt; and you need to own the value, consider borrowing and then cloning:</source>
          <target state="translated">В качестве альтернативы, если ваш тип реализует &lt;code&gt;Clone&lt;/code&gt; и вам нужно владеть значением, рассмотрите возможность заимствования, а затем клонирования:</target>
        </trans-unit>
        <trans-unit id="ed9c6950d0598f33adea6619e4f5e3230fd020da" translate="yes" xml:space="preserve">
          <source>Alternatively, move the other attributes to the contained type:</source>
          <target state="translated">Или же переместите остальные атрибуты к содержащемуся типу:</target>
        </trans-unit>
        <trans-unit id="b5cf6202d850db2d8b7a0068cf052fbe7d132528" translate="yes" xml:space="preserve">
          <source>Alternatively, split the pattern:</source>
          <target state="translated">Альтернативно,разделить шаблон:</target>
        </trans-unit>
        <trans-unit id="9b111c2948f7df0faec47eb57a97f3c7f99e8980" translate="yes" xml:space="preserve">
          <source>Alternatively, we can consider using the &lt;code&gt;Cell&lt;/code&gt; and &lt;code&gt;RefCell&lt;/code&gt; types to achieve interior mutability through a shared reference. Our example's &lt;code&gt;mutable&lt;/code&gt; function could be redefined as below:</source>
          <target state="translated">В качестве альтернативы, мы можем рассмотреть возможность использования типов &lt;code&gt;Cell&lt;/code&gt; и &lt;code&gt;RefCell&lt;/code&gt; для достижения внутренней изменчивости через общую ссылку. &lt;code&gt;mutable&lt;/code&gt; функцию нашего примера можно переопределить, как показано ниже:</target>
        </trans-unit>
        <trans-unit id="754e721e3e9779de9d32c607142b98694b9bb365" translate="yes" xml:space="preserve">
          <source>Alternatively, we can move out of &lt;code&gt;fancy_num&lt;/code&gt; into a second &lt;code&gt;fancy_num&lt;/code&gt;:</source>
          <target state="translated">В качестве альтернативы мы можем перейти от &lt;code&gt;fancy_num&lt;/code&gt; ко второму &lt;code&gt;fancy_num&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="da767a10b83371c7ea419ae14469880fbc9efc2b" translate="yes" xml:space="preserve">
          <source>Alternatively, wrapping trait objects requires something like the following:</source>
          <target state="translated">В качестве альтернативы,для обертки объектов чертежа требуется что-то вроде следующего:</target>
        </trans-unit>
        <trans-unit id="3374923e7cf24250807b521def52524879dd69d5" translate="yes" xml:space="preserve">
          <source>Alternatively, wrapping trait objects requires something:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="980127d7c92391c13b6615bd3076240a03531f1c" translate="yes" xml:space="preserve">
          <source>Alternatively, you can add the following line to your &lt;em&gt;~/.bash_profile&lt;/em&gt;:</source>
          <target state="translated">В качестве альтернативы вы можете добавить следующую строку в свой &lt;em&gt;~ / .bash_profile&lt;/em&gt; :</target>
        </trans-unit>
        <trans-unit id="9de397b8421cd9e5ee08981bcb6e02a87c244a79" translate="yes" xml:space="preserve">
          <source>Alternatively, you can also use the struct pattern by using the correct field names and binding them to new identifiers:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="53009511a1501672faf73d204dc3eb7eb0e15f4c" translate="yes" xml:space="preserve">
          <source>Alternatively, you can create a newtype. A newtype is a wrapping tuple-struct. For example, &lt;code&gt;NewType&lt;/code&gt; is a newtype over &lt;code&gt;Foo&lt;/code&gt; in &lt;code&gt;struct NewType(Foo)&lt;/code&gt;. Example:</source>
          <target state="translated">В качестве альтернативы вы можете создать новый тип. Newtype - это оборачивающая структура кортежа. Например, &lt;code&gt;NewType&lt;/code&gt; - это новый тип над &lt;code&gt;Foo&lt;/code&gt; в &lt;code&gt;struct NewType(Foo)&lt;/code&gt; . Пример:</target>
        </trans-unit>
        <trans-unit id="f44934b9e6665fc0ff65386cfc3a7e7022fcb44e" translate="yes" xml:space="preserve">
          <source>Alternatively, you can obtain a &lt;code&gt;&amp;amp;[&lt;/code&gt;&lt;a href=&quot;../primitive.u8&quot;&gt;&lt;code&gt;u8&lt;/code&gt;&lt;/a&gt;&lt;code&gt;]&lt;/code&gt; slice from a &lt;code&gt;CString&lt;/code&gt; with the &lt;a href=&quot;#method.as_bytes&quot;&gt;&lt;code&gt;as_bytes&lt;/code&gt;&lt;/a&gt; method. Slices produced in this way do &lt;em&gt;not&lt;/em&gt; contain the trailing nul terminator. This is useful when you will be calling an extern function that takes a &lt;code&gt;*const u8&lt;/code&gt; argument which is not necessarily nul-terminated, plus another argument with the length of the string &amp;mdash; like C's &lt;code&gt;strndup()&lt;/code&gt;. You can of course get the slice's length with its &lt;a href=&quot;../primitive.slice#method.len&quot;&gt;&lt;code&gt;len&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">В качестве альтернативы вы можете получить срез &lt;code&gt;&amp;amp;[&lt;/code&gt; &lt;a href=&quot;../primitive.u8&quot;&gt; &lt;code&gt;u8&lt;/code&gt; &lt;/a&gt; &lt;code&gt;]&lt;/code&gt; из &lt;code&gt;CString&lt;/code&gt; с &lt;a href=&quot;#method.as_bytes&quot;&gt; &lt;code&gt;as_bytes&lt;/code&gt; &lt;/a&gt; метода as_bytes . Срезы, полученные таким образом, &lt;em&gt;не&lt;/em&gt; содержат завершающего нулевого терминатора. Это полезно , когда вы будете называть экстерн функцию , которая принимает &lt;code&gt;*const u8&lt;/code&gt; аргумента , который не обязательно является завершающим нолем, плюс еще один аргумент с длиной строки - как язык C &lt;code&gt;strndup()&lt;/code&gt; . Конечно, вы можете получить длину среза с помощью метода &lt;a href=&quot;../primitive.slice#method.len&quot;&gt; &lt;code&gt;len&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="14ed2547343b0251c75ea8d794d5d3f83b965f7e" translate="yes" xml:space="preserve">
          <source>Alternatively, you can obtain a &lt;code&gt;&amp;amp;[&lt;/code&gt;&lt;a href=&quot;https://doc.rust-lang.org/nightly/std/primitive.u8.html&quot;&gt;&lt;code&gt;u8&lt;/code&gt;&lt;/a&gt;&lt;code&gt;]&lt;/code&gt; slice from a &lt;code&gt;CString&lt;/code&gt; with the &lt;a href=&quot;struct.cstring#method.as_bytes&quot;&gt;&lt;code&gt;CString::as_bytes&lt;/code&gt;&lt;/a&gt; method. Slices produced in this way do &lt;em&gt;not&lt;/em&gt; contain the trailing nul terminator. This is useful when you will be calling an extern function that takes a &lt;code&gt;*const u8&lt;/code&gt; argument which is not necessarily nul-terminated, plus another argument with the length of the string &amp;mdash; like C's &lt;code&gt;strndup()&lt;/code&gt;. You can of course get the slice's length with its &lt;a href=&quot;../primitive.slice#method.len&quot;&gt;&lt;code&gt;len&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3a4be7155bcffba0850c80a370bc5c6b34c37e74" translate="yes" xml:space="preserve">
          <source>Alternatives</source>
          <target state="translated">Alternatives</target>
        </trans-unit>
        <trans-unit id="fb4db1dca17b4c832ac69c83b18f73ad9aa68bf9" translate="yes" xml:space="preserve">
          <source>Although Rust will let you bind &lt;code&gt;Sized&lt;/code&gt; to a trait, you won't be able to use it to form a trait object later:</source>
          <target state="translated">Хотя Rust позволит вам привязать &lt;code&gt;Sized&lt;/code&gt; к трейту, вы не сможете использовать его для создания объекта трейта позже:</target>
        </trans-unit>
        <trans-unit id="18938413590ec4f421c089a648f9b8a820edd657" translate="yes" xml:space="preserve">
          <source>Although UDP is a connectionless protocol, this implementation provides an interface to set an address where data should be sent and received from. After setting a remote address with &lt;a href=&quot;#method.connect&quot;&gt;&lt;code&gt;connect&lt;/code&gt;&lt;/a&gt;, data can be sent to and received from that address with &lt;a href=&quot;#method.send&quot;&gt;&lt;code&gt;send&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#method.recv&quot;&gt;&lt;code&gt;recv&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Хотя UDP является протоколом без установления соединения, эта реализация предоставляет интерфейс для установки адреса, с которого должны отправляться и приниматься данные. После установки удаленного адреса с помощью &lt;a href=&quot;#method.connect&quot;&gt; &lt;code&gt;connect&lt;/code&gt; &lt;/a&gt; , данные могут быть отправлены и получены с этого адреса с помощью &lt;a href=&quot;#method.send&quot;&gt; &lt;code&gt;send&lt;/code&gt; &lt;/a&gt; и &lt;a href=&quot;#method.recv&quot;&gt; &lt;code&gt;recv&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="543c09d5bf5928a676597cb867e1ef6c78157058" translate="yes" xml:space="preserve">
          <source>Although UDP is a connectionless protocol, this implementation provides an interface to set an address where data should be sent and received from. After setting a remote address with &lt;a href=&quot;struct.udpsocket#method.connect&quot;&gt;&lt;code&gt;connect&lt;/code&gt;&lt;/a&gt;, data can be sent to and received from that address with &lt;a href=&quot;struct.udpsocket#method.send&quot;&gt;&lt;code&gt;send&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;struct.udpsocket#method.recv&quot;&gt;&lt;code&gt;recv&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6138cf1c64fdfba340547fa72a908d945fa65b3f" translate="yes" xml:space="preserve">
          <source>Although a &lt;code&gt;SystemTime&lt;/code&gt; cannot be directly inspected, the &lt;a href=&quot;constant.unix_epoch&quot;&gt;&lt;code&gt;UNIX_EPOCH&lt;/code&gt;&lt;/a&gt; constant is provided in this module as an anchor in time to learn information about a &lt;code&gt;SystemTime&lt;/code&gt;. By calculating the duration from this fixed point in time, a &lt;code&gt;SystemTime&lt;/code&gt; can be converted to a human-readable time, or perhaps some other string representation.</source>
          <target state="translated">Хотя &lt;code&gt;SystemTime&lt;/code&gt; нельзя напрямую проверить, в этом модуле предоставляется константа &lt;a href=&quot;constant.unix_epoch&quot;&gt; &lt;code&gt;UNIX_EPOCH&lt;/code&gt; &lt;/a&gt; в качестве привязки во времени для получения информации о &lt;code&gt;SystemTime&lt;/code&gt; . Вычисляя продолжительность от этого фиксированного момента времени, &lt;code&gt;SystemTime&lt;/code&gt; можно преобразовать в удобочитаемое время или, возможно, в какое-либо другое строковое представление.</target>
        </trans-unit>
        <trans-unit id="9bf2565395a043df30a2266cce3b26bdd4f8ff03" translate="yes" xml:space="preserve">
          <source>Although both Listing 7-11 and 7-13 accomplish the same task, Listing 7-11 is the idiomatic way to bring a function into scope with &lt;code&gt;use&lt;/code&gt;. Bringing the function&amp;rsquo;s parent module into scope with &lt;code&gt;use&lt;/code&gt; so we have to specify the parent module when calling the function makes it clear that the function isn&amp;rsquo;t locally defined while still minimizing repetition of the full path. The code in Listing 7-13 is unclear as to where &lt;code&gt;add_to_waitlist&lt;/code&gt; is defined.</source>
          <target state="translated">Хотя и листинг 7-11, и листинг 7-13 выполняют одну и ту же задачу, листинг 7-11 представляет собой идиоматический способ перенести функцию в область видимости с &lt;code&gt;use&lt;/code&gt; . Внесение родительского модуля функции в область видимости с &lt;code&gt;use&lt;/code&gt; поэтому мы должны указать родительский модуль при вызове функции, дает понять, что функция не определена локально, при этом минимизируя повторение полного пути. В коде листинга 7-13 неясно, где определен &lt;code&gt;add_to_waitlist&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="af1566b2870173a676122bd4c9750a25b9287966" translate="yes" xml:space="preserve">
          <source>Although functional programming languages use cons lists frequently, the cons list isn&amp;rsquo;t a commonly used data structure in Rust. Most of the time when you have a list of items in Rust, &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; is a better choice to use. Other, more complex recursive data types &lt;em&gt;are&lt;/em&gt; useful in various situations, but by starting with the cons list, we can explore how boxes let us define a recursive data type without much distraction.</source>
          <target state="translated">Хотя функциональные языки программирования часто используют списки cons, список cons не является широко используемой структурой данных в Rust. В большинстве случаев, когда у вас есть список элементов в Rust, лучше использовать &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; . Другие, более сложные рекурсивные типы данных &lt;em&gt;являются&lt;/em&gt; полезными в различных ситуациях, но, начиная со списком минусов, мы можем исследовать , как коробки определим рекурсивный тип данных без особого отвлечения внимания.</target>
        </trans-unit>
        <trans-unit id="d04af4e6b5ccd4c4682747098fc1db0b02dbd661" translate="yes" xml:space="preserve">
          <source>Although the &lt;code&gt;::&lt;/code&gt; token is allowed before the generics arguments, it is not required because there is no ambiguity like there is in &lt;em&gt;PathInExpression&lt;/em&gt;.</source>
          <target state="translated">Хотя токен &lt;code&gt;::&lt;/code&gt; допускается перед аргументами универсального типа, он не является обязательным, поскольку здесь нет двусмысленности, как в &lt;em&gt;PathInExpression&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="7bf75499d3d552ee0a87d1fa70ed0a0e35bd067e" translate="yes" xml:space="preserve">
          <source>Although the &lt;code&gt;let&lt;/code&gt; is pointless here, it illustrates the meaning of &lt;code&gt;!&lt;/code&gt;. Since &lt;code&gt;x&lt;/code&gt; is never assigned a value (because &lt;code&gt;return&lt;/code&gt; returns from the entire function), &lt;code&gt;x&lt;/code&gt; can be given type &lt;code&gt;!&lt;/code&gt;. We could also replace &lt;code&gt;return 123&lt;/code&gt; with a &lt;code&gt;panic!&lt;/code&gt; or a never-ending &lt;code&gt;loop&lt;/code&gt; and this code would still be valid.</source>
          <target state="translated">Хотя &lt;code&gt;let&lt;/code&gt; здесь бессмысленна, она иллюстрирует значение &lt;code&gt;!&lt;/code&gt; . Поскольку &lt;code&gt;x&lt;/code&gt; никогда не присваивается значение (потому что &lt;code&gt;return&lt;/code&gt; возвращается из всей функции), &lt;code&gt;x&lt;/code&gt; может быть задан тип &lt;code&gt;!&lt;/code&gt; . Мы могли бы также заменить &lt;code&gt;return 123&lt;/code&gt; на &lt;code&gt;panic!&lt;/code&gt; или бесконечный &lt;code&gt;loop&lt;/code&gt; и этот код все равно будет действителен.</target>
        </trans-unit>
        <trans-unit id="6e8ecdea30a2a1885eeb369d7e2426712a189f17" translate="yes" xml:space="preserve">
          <source>Although the SipHash algorithm is considered to be generally strong, it is not intended for cryptographic purposes. As such, all cryptographic uses of this implementation are &lt;em&gt;strongly discouraged&lt;/em&gt;.</source>
          <target state="translated">Хотя алгоритм SipHash в целом считается надежным, он не предназначен для криптографических целей. Таким образом, любое криптографическое использование этой реализации &lt;em&gt;категорически не рекомендуется&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="f07ca613351cf8dcbbc0ccd12d8ef0d4721b46b7" translate="yes" xml:space="preserve">
          <source>Although the number of keys and values is growable, each key can only have one value associated with it at a time. When you want to change the data in a hash map, you have to decide how to handle the case when a key already has a value assigned. You could replace the old value with the new value, completely disregarding the old value. You could keep the old value and ignore the new value, only adding the new value if the key &lt;em&gt;doesn&amp;rsquo;t&lt;/em&gt; already have a value. Or you could combine the old value and the new value. Let&amp;rsquo;s look at how to do each of these!</source>
          <target state="translated">Хотя количество ключей и значений может увеличиваться, каждый ключ может иметь только одно значение, связанное с ним за раз. Если вы хотите изменить данные в хэш-карте, вы должны решить, как поступить в случае, когда ключу уже присвоено значение. Вы можете заменить старое значение новым значением, полностью игнорируя старое значение. Вы можете сохранить старое значение и игнорировать новое значение, добавляя новое значение только в том случае, если ключ &lt;em&gt;еще не&lt;/em&gt; имеет значения. Или вы можете объединить старое значение и новое значение. Давайте посмотрим, как это сделать!</target>
        </trans-unit>
        <trans-unit id="9186f195f5116d4c11a411254011d9afb8932670" translate="yes" xml:space="preserve">
          <source>Although this API is unstable, it is exposed via stable APIs on the &lt;a href=&quot;../../primitive.str&quot;&gt;&lt;code&gt;str&lt;/code&gt;&lt;/a&gt; type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d281e954555c8484110a6fecba9e6260dd297fe7" translate="yes" xml:space="preserve">
          <source>Although this code has the same behavior as Listing 9-5, it doesn&amp;rsquo;t contain any &lt;code&gt;match&lt;/code&gt; expressions and is cleaner to read. Come back to this example after you&amp;rsquo;ve read Chapter 13, and look up the &lt;code&gt;unwrap_or_else&lt;/code&gt; method in the standard library documentation. Many more of these methods can clean up huge nested &lt;code&gt;match&lt;/code&gt; expressions when you&amp;rsquo;re dealing with errors.</source>
          <target state="translated">Хотя этот код имеет такое же поведение , как показано в листинге 9-5, он не содержит каких - либо &lt;code&gt;match&lt;/code&gt; выражений и чище читать. Вернитесь к этому примеру после прочтения главы 13 и &lt;code&gt;unwrap_or_else&lt;/code&gt; метод unwrap_or_else в документации стандартной библиотеки. Многие более из этих методов может очистить огромные вложенные &lt;code&gt;match&lt;/code&gt; выражений , когда вы имеете дело с ошибками.</target>
        </trans-unit>
        <trans-unit id="db0fe462f2aa334b05d61f387c6225bd0bc5a2b6" translate="yes" xml:space="preserve">
          <source>Although this code works, duplicating code is tedious and error prone. We also have to update the code in multiple places when we want to change it.</source>
          <target state="translated">Хотя этот код работает,дублирование кода утомительно и склонно к ошибкам.Также нам приходится обновлять код в нескольких местах,когда мы хотим его изменить.</target>
        </trans-unit>
        <trans-unit id="bf29b02a8b6e1719f55f981f1d8572dd8539b24f" translate="yes" xml:space="preserve">
          <source>Although using it won&amp;rsquo;t cause a compilation warning, new code should use &lt;a href=&quot;#associatedconstant.MAX&quot;&gt;&lt;code&gt;i128::MAX&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="05e69f2a6bb8b46764f8352e784a84dd0afadb9d" translate="yes" xml:space="preserve">
          <source>Although using it won&amp;rsquo;t cause a compilation warning, new code should use &lt;a href=&quot;#associatedconstant.MAX&quot;&gt;&lt;code&gt;i16::MAX&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ae2e6d7ac448ad026e808cfe3cdcdd25c692cbe9" translate="yes" xml:space="preserve">
          <source>Although using it won&amp;rsquo;t cause a compilation warning, new code should use &lt;a href=&quot;#associatedconstant.MAX&quot;&gt;&lt;code&gt;i32::MAX&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cad1997569aea8b22596a5906b14eaf599d36023" translate="yes" xml:space="preserve">
          <source>Although using it won&amp;rsquo;t cause a compilation warning, new code should use &lt;a href=&quot;#associatedconstant.MAX&quot;&gt;&lt;code&gt;i64::MAX&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="628ef478f32d02057364243517eb61194b2fa937" translate="yes" xml:space="preserve">
          <source>Although using it won&amp;rsquo;t cause a compilation warning, new code should use &lt;a href=&quot;#associatedconstant.MAX&quot;&gt;&lt;code&gt;i8::MAX&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4e48625fb423a49263c7f7ef3730f1cadc66a1e6" translate="yes" xml:space="preserve">
          <source>Although using it won&amp;rsquo;t cause a compilation warning, new code should use &lt;a href=&quot;#associatedconstant.MAX&quot;&gt;&lt;code&gt;isize::MAX&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7d04345ef80c5ecd03e51a7345f75034be31a60e" translate="yes" xml:space="preserve">
          <source>Although using it won&amp;rsquo;t cause a compilation warning, new code should use &lt;a href=&quot;#associatedconstant.MIN&quot;&gt;&lt;code&gt;i128::MIN&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="579ffa98c5f86f05f3788dc02042f9c6df508f9f" translate="yes" xml:space="preserve">
          <source>Although using it won&amp;rsquo;t cause a compilation warning, new code should use &lt;a href=&quot;#associatedconstant.MIN&quot;&gt;&lt;code&gt;i16::MIN&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="da2d071c44ca8237c16fc626e1f05fe6f73717ea" translate="yes" xml:space="preserve">
          <source>Although using it won&amp;rsquo;t cause a compilation warning, new code should use &lt;a href=&quot;#associatedconstant.MIN&quot;&gt;&lt;code&gt;i32::MIN&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4c915462451daa99c7af198c86febdd1a22d7597" translate="yes" xml:space="preserve">
          <source>Although using it won&amp;rsquo;t cause a compilation warning, new code should use &lt;a href=&quot;#associatedconstant.MIN&quot;&gt;&lt;code&gt;i64::MIN&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c7a387b30a94786833a9b0a30456b3027e1e9fbd" translate="yes" xml:space="preserve">
          <source>Although using it won&amp;rsquo;t cause a compilation warning, new code should use &lt;a href=&quot;#associatedconstant.MIN&quot;&gt;&lt;code&gt;i8::MIN&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e5bf4822c610526f0cdddf4534d5b49b86f74f58" translate="yes" xml:space="preserve">
          <source>Although using it won&amp;rsquo;t cause a compilation warning, new code should use &lt;a href=&quot;#associatedconstant.MIN&quot;&gt;&lt;code&gt;isize::MIN&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ebb42d33b9e27bf9b56623cf75d8b9afa2233265" translate="yes" xml:space="preserve">
          <source>Although using it won&amp;rsquo;t cause compilation warning, new code should use &lt;a href=&quot;#associatedconstant.MAX&quot;&gt;&lt;code&gt;u128::MAX&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5a7ac738426df2354794cb8df0537a30a74f6523" translate="yes" xml:space="preserve">
          <source>Although using it won&amp;rsquo;t cause compilation warning, new code should use &lt;a href=&quot;#associatedconstant.MAX&quot;&gt;&lt;code&gt;u16::MAX&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3e75c91d3cf3b6547d6e61a6969491f50f5e1d3e" translate="yes" xml:space="preserve">
          <source>Although using it won&amp;rsquo;t cause compilation warning, new code should use &lt;a href=&quot;#associatedconstant.MAX&quot;&gt;&lt;code&gt;u32::MAX&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="924beee0df8993e339f5ec14d80c789072c86cef" translate="yes" xml:space="preserve">
          <source>Although using it won&amp;rsquo;t cause compilation warning, new code should use &lt;a href=&quot;#associatedconstant.MAX&quot;&gt;&lt;code&gt;u64::MAX&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9ae4b957aed4f3be97f5bc6a6d75118ff06b3cad" translate="yes" xml:space="preserve">
          <source>Although using it won&amp;rsquo;t cause compilation warning, new code should use &lt;a href=&quot;#associatedconstant.MAX&quot;&gt;&lt;code&gt;u8::MAX&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c5ebde2d554567a7b7e90cd41cbc8b0acac4a1c2" translate="yes" xml:space="preserve">
          <source>Although using it won&amp;rsquo;t cause compilation warning, new code should use &lt;a href=&quot;#associatedconstant.MAX&quot;&gt;&lt;code&gt;usize::MAX&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ad32dc2d3be50a4f8c5fdf28af0d0fed17aa13dc" translate="yes" xml:space="preserve">
          <source>Although using it won&amp;rsquo;t cause compilation warning, new code should use &lt;a href=&quot;#associatedconstant.MIN&quot;&gt;&lt;code&gt;u128::MIN&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="66ce4a459f9d71da21dd5ea02e3b77c11475a92b" translate="yes" xml:space="preserve">
          <source>Although using it won&amp;rsquo;t cause compilation warning, new code should use &lt;a href=&quot;#associatedconstant.MIN&quot;&gt;&lt;code&gt;u16::MIN&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="863866e2fa75d6344d5a22903dbb6eb4e36d7217" translate="yes" xml:space="preserve">
          <source>Although using it won&amp;rsquo;t cause compilation warning, new code should use &lt;a href=&quot;#associatedconstant.MIN&quot;&gt;&lt;code&gt;u32::MIN&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f0557ca69022890678ed9741ea9a18e4b1b5c3ca" translate="yes" xml:space="preserve">
          <source>Although using it won&amp;rsquo;t cause compilation warning, new code should use &lt;a href=&quot;#associatedconstant.MIN&quot;&gt;&lt;code&gt;u64::MIN&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1bc8261189beb72f8e3ea2bfcc325eac36215e34" translate="yes" xml:space="preserve">
          <source>Although using it won&amp;rsquo;t cause compilation warning, new code should use &lt;a href=&quot;#associatedconstant.MIN&quot;&gt;&lt;code&gt;u8::MIN&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="018037ac23dbb67a32f73854e405231a6ffce4dc" translate="yes" xml:space="preserve">
          <source>Although using it won&amp;rsquo;t cause compilation warning, new code should use &lt;a href=&quot;#associatedconstant.MIN&quot;&gt;&lt;code&gt;usize::MIN&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="094096c8e8871948579e001659d96f6f0cd91ded" translate="yes" xml:space="preserve">
          <source>Although using it won&amp;rsquo;t cause compilation warning, new code should use &lt;a href=&quot;../fmt/trait.display&quot;&gt;&lt;code&gt;Display&lt;/code&gt;&lt;/a&gt; instead and new &lt;code&gt;impl&lt;/code&gt;s can omit it.</source>
          <target state="translated">Хотя его использование не вызовет предупреждения о компиляции, новый код должен использовать вместо него &lt;a href=&quot;../fmt/trait.display&quot;&gt; &lt;code&gt;Display&lt;/code&gt; ,&lt;/a&gt; а новые &lt;code&gt;impl&lt;/code&gt; могут его опустить.</target>
        </trans-unit>
        <trans-unit id="929ca8c36977dca3461b8596285cdc531c6b81df" translate="yes" xml:space="preserve">
          <source>Although using these constants won&amp;rsquo;t cause compilation warnings, new code should use the associated constants directly on the primitive type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ce3c8369369ce1fe72325205b70eb3e2961e011c" translate="yes" xml:space="preserve">
          <source>Although you can&amp;rsquo;t remove previous versions of a crate, you can prevent any future projects from adding them as a new dependency. This is useful when a crate version is broken for one reason or another. In such situations, Cargo supports &lt;em&gt;yanking&lt;/em&gt; a crate version.</source>
          <target state="translated">Хотя вы не можете удалить предыдущие версии ящика, вы можете запретить любым будущим проектам добавлять их в качестве новой зависимости. Это полезно, когда версия ящика сломана по той или иной причине. В таких ситуациях, Cargo поддерживает &lt;em&gt;дергает&lt;/em&gt; версию клети.</target>
        </trans-unit>
        <trans-unit id="a876dd4a0d144d06dda24f474bedf4412b3d4b86" translate="yes" xml:space="preserve">
          <source>Always empty bottom type for diverging functions</source>
          <target state="translated">Всегда пустой нижний тип для расходящихся функций</target>
        </trans-unit>
        <trans-unit id="30044213367fd946b86a46fbbf0f3c415f92d7bc" translate="yes" xml:space="preserve">
          <source>Always returns &lt;code&gt;Err&lt;/code&gt; on arithmetic overflow.</source>
          <target state="translated">Всегда возвращает &lt;code&gt;Err&lt;/code&gt; при арифметическом переполнении.</target>
        </trans-unit>
        <trans-unit id="81c2dadc15a7e41133f5895d6079a63549a2abb5" translate="yes" xml:space="preserve">
          <source>Always returns &lt;code&gt;true&lt;/code&gt; if &lt;code&gt;needle&lt;/code&gt; is an empty slice:</source>
          <target state="translated">Всегда возвращает &lt;code&gt;true&lt;/code&gt; если &lt;code&gt;needle&lt;/code&gt; - пустой срез:</target>
        </trans-unit>
        <trans-unit id="0d0ce480d587247832892434b17dbf1b556a5191" translate="yes" xml:space="preserve">
          <source>Always use &lt;code&gt;.add(count)&lt;/code&gt; instead when possible, because &lt;code&gt;add&lt;/code&gt; allows the compiler to optimize better.</source>
          <target state="translated">По возможности всегда используйте &lt;code&gt;.add(count)&lt;/code&gt; , потому что &lt;code&gt;add&lt;/code&gt; позволяет компилятору лучше оптимизировать.</target>
        </trans-unit>
        <trans-unit id="2dbc1421ee3e3a275bd2bb6e8f64943056afdc31" translate="yes" xml:space="preserve">
          <source>Always use &lt;code&gt;.offset(count)&lt;/code&gt; instead when possible, because &lt;code&gt;offset&lt;/code&gt; allows the compiler to optimize better. If you need to cross object boundaries, cast the pointer to an integer and do the arithmetic there.</source>
          <target state="translated">По возможности всегда используйте &lt;code&gt;.offset(count)&lt;/code&gt; , потому что &lt;code&gt;offset&lt;/code&gt; позволяет компилятору лучше оптимизировать. Если вам нужно пересечь границы объекта, приведите указатель к целому числу и выполните там арифметические операции.</target>
        </trans-unit>
        <trans-unit id="701562825affe99f99fee809f333cf1e955284e4" translate="yes" xml:space="preserve">
          <source>Always use &lt;code&gt;.sub(count)&lt;/code&gt; instead when possible, because &lt;code&gt;sub&lt;/code&gt; allows the compiler to optimize better.</source>
          <target state="translated">По возможности всегда используйте &lt;code&gt;.sub(count)&lt;/code&gt; , потому что &lt;code&gt;sub&lt;/code&gt; позволяет компилятору лучше оптимизировать.</target>
        </trans-unit>
        <trans-unit id="9fda5d5730cef377a6f455b42dbcfb53fb2ca5ca" translate="yes" xml:space="preserve">
          <source>Among other causes, &lt;code&gt;ParseIntError&lt;/code&gt; can be thrown because of leading or trailing whitespace in the string e.g., when it is obtained from the standard input. Using the &lt;a href=&quot;../primitive.str#method.trim&quot;&gt;&lt;code&gt;str.trim()&lt;/code&gt;&lt;/a&gt; method ensures that no whitespace remains before parsing.</source>
          <target state="translated">Среди других причин &lt;code&gt;ParseIntError&lt;/code&gt; может быть сгенерирован из-за начальных или конечных пробелов в строке, например, когда он получен из стандартного ввода. Использование &lt;a href=&quot;../primitive.str#method.trim&quot;&gt; &lt;code&gt;str.trim()&lt;/code&gt; &lt;/a&gt; гарантирует, что перед синтаксическим анализом не останется пробелов.</target>
        </trans-unit>
        <trans-unit id="f82aa4d4f03b38410c80f80025c8644ba744b247" translate="yes" xml:space="preserve">
          <source>Among other causes, this variant will be constructed when parsing a string that contains a letter.</source>
          <target state="translated">Среди прочих причин,этот вариант будет построен при разборе строки,содержащей букву.</target>
        </trans-unit>
        <trans-unit id="5a8bbd84610d1c777c353f8f16b14399af3b24f4" translate="yes" xml:space="preserve">
          <source>Among other causes, this variant will be constructed when parsing a string that contains a non-ASCII char.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e8d19d51f5faed38ee6324a9eb71c292315da9f7" translate="yes" xml:space="preserve">
          <source>Among other causes, this variant will be constructed when parsing an empty string.</source>
          <target state="translated">Среди прочих причин,этот вариант будет построен при разборе пустой строки.</target>
        </trans-unit>
        <trans-unit id="1692574d1eb8d1443991c925dc8e2acd8ed2cbd7" translate="yes" xml:space="preserve">
          <source>An &quot;or&quot; pattern was used where the variable bindings are not consistently bound across patterns.</source>
          <target state="translated">Использовалась &quot;или&quot; деталь,в которой переменные связки не были последовательно связаны между собой.</target>
        </trans-unit>
        <trans-unit id="43d68d3a293f07f835d90c6279bf8faa22ceb0c8" translate="yes" xml:space="preserve">
          <source>An &amp;lsquo;abstract syntax tree&amp;rsquo;, or &amp;lsquo;AST&amp;rsquo;, is an intermediate representation of the structure of the program when the compiler is compiling it.</source>
          <target state="translated">&amp;laquo;Абстрактное синтаксическое дерево&amp;raquo; или &amp;laquo;AST&amp;raquo; - это промежуточное представление структуры программы, когда компилятор ее компилирует.</target>
        </trans-unit>
        <trans-unit id="db2d4110f56313292c834e1861a95c89c601039f" translate="yes" xml:space="preserve">
          <source>An &lt;a href=&quot;../../../result/enum.result#Err.v&quot;&gt;&lt;code&gt;Err&lt;/code&gt;&lt;/a&gt; is returned if the zero &lt;a href=&quot;../../../time/struct.duration&quot;&gt;&lt;code&gt;Duration&lt;/code&gt;&lt;/a&gt; is passed to this method:</source>
          <target state="translated">&lt;a href=&quot;../../../result/enum.result#Err.v&quot;&gt; &lt;code&gt;Err&lt;/code&gt; &lt;/a&gt; возвращается , если нулевой &lt;a href=&quot;../../../time/struct.duration&quot;&gt; &lt;code&gt;Duration&lt;/code&gt; &lt;/a&gt; передается этому методу:</target>
        </trans-unit>
        <trans-unit id="c2d78c88964f9736a45223d8f771f07ad6bd857e" translate="yes" xml:space="preserve">
          <source>An &lt;a href=&quot;../../../result/enum.result#variant.Err&quot;&gt;&lt;code&gt;Err&lt;/code&gt;&lt;/a&gt; is returned if the zero &lt;a href=&quot;../../../time/struct.duration&quot;&gt;&lt;code&gt;Duration&lt;/code&gt;&lt;/a&gt; is passed to this method:</source>
          <target state="translated">&lt;a href=&quot;../../../result/enum.result#variant.Err&quot;&gt; &lt;code&gt;Err&lt;/code&gt; &lt;/a&gt; возвращается , если нулевой &lt;a href=&quot;../../../time/struct.duration&quot;&gt; &lt;code&gt;Duration&lt;/code&gt; &lt;/a&gt; передается этому методу:</target>
        </trans-unit>
        <trans-unit id="0a7f0956daf2ce936a64a4b1e04b5752d5af8c85" translate="yes" xml:space="preserve">
          <source>An &lt;a href=&quot;../items/enumerations&quot;&gt;&lt;code&gt;enum&lt;/code&gt; item&lt;/a&gt; declares both the type and a number of &lt;em&gt;variants&lt;/em&gt;, each of which is independently named and has the syntax of a struct, tuple struct or unit-like struct.</source>
          <target state="translated">&lt;a href=&quot;../items/enumerations&quot;&gt; &lt;code&gt;enum&lt;/code&gt; элемент&lt;/a&gt; объявляет как тип и количество &lt;em&gt;вариантов&lt;/em&gt; , каждый из которых независимо друг от друга по имени и имеет синтаксис структуру, кортежи структуры или блок типа структуры.</target>
        </trans-unit>
        <trans-unit id="eccb90f6f9e2e1cba49165645ca18ce97f7c3bdc" translate="yes" xml:space="preserve">
          <source>An &lt;a href=&quot;../result/enum.result#variant.Err&quot;&gt;&lt;code&gt;Err&lt;/code&gt;&lt;/a&gt; is returned if the zero &lt;a href=&quot;../time/struct.duration&quot;&gt;&lt;code&gt;Duration&lt;/code&gt;&lt;/a&gt; is passed to this method:</source>
          <target state="translated">&lt;a href=&quot;../result/enum.result#variant.Err&quot;&gt; &lt;code&gt;Err&lt;/code&gt; &lt;/a&gt; возвращается , если нулевой &lt;a href=&quot;../time/struct.duration&quot;&gt; &lt;code&gt;Duration&lt;/code&gt; &lt;/a&gt; передается этому методу:</target>
        </trans-unit>
        <trans-unit id="6c3aa2cd86bdd94aa99cad4f7b2a3826d70a323a" translate="yes" xml:space="preserve">
          <source>An &lt;a href=&quot;../result/enum.result#variant.Err&quot;&gt;&lt;code&gt;Err&lt;/code&gt;&lt;/a&gt; will be returned if an error occurs while flushing the buffer.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4a13d2042a47768129ce22a87e727826521c162e" translate="yes" xml:space="preserve">
          <source>An &lt;a href=&quot;book/ch19-04-advanced-types#dynamically-sized-types-and-the-sized-trait&quot;&gt;unsized type&lt;/a&gt; is any type where the compiler does not know the length or alignment of at compile time. Any struct containing an unsized type is also unsized.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a6662b5b221b841136c3780ac238b4001369d2fd" translate="yes" xml:space="preserve">
          <source>An &lt;a href=&quot;items&quot;&gt;item&lt;/a&gt; that is not a member of an &lt;a href=&quot;items/implementations&quot;&gt;implementation&lt;/a&gt;, such as a &lt;em&gt;free function&lt;/em&gt; or a &lt;em&gt;free const&lt;/em&gt;. Contrast to an &lt;a href=&quot;#associated-item&quot;&gt;associated item&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ee613500276e22e6ef67273653d1676ba809144c" translate="yes" xml:space="preserve">
          <source>An &lt;a href=&quot;items&quot;&gt;item&lt;/a&gt; that is not a member of an &lt;a href=&quot;items/implementations&quot;&gt;implementation&lt;/a&gt;, such as a &lt;em&gt;free function&lt;/em&gt; or a &lt;em&gt;free const&lt;/em&gt;. Contrast to an &lt;a href=&quot;glossary#associated-item&quot;&gt;associated item&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;items&quot;&gt;Элемент&lt;/a&gt; , который не является членом &lt;a href=&quot;items/implementations&quot;&gt;реализации&lt;/a&gt; , такими как &lt;em&gt;свободная функция&lt;/em&gt; или &lt;em&gt;свободной сопзЬ&lt;/em&gt; . Контраст со &lt;a href=&quot;glossary#associated-item&quot;&gt;связанным предметом&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="dcdff555d3629a9d75bb0e2e48e4c4243e57c8c2" translate="yes" xml:space="preserve">
          <source>An &lt;a href=&quot;items/implementations&quot;&gt;implementation&lt;/a&gt; that applies to a nominal type, not to a trait-type pair. &lt;a href=&quot;items/implementations#inherent-implementations&quot;&gt;More&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;items/implementations&quot;&gt;Реализация&lt;/a&gt; , которая применяется к номинальному типу, а не к паре черта типа. &lt;a href=&quot;items/implementations#inherent-implementations&quot;&gt;Больше&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="21e222f83548917bbd7accfb7becfb374f31ef4a" translate="yes" xml:space="preserve">
          <source>An &lt;a href=&quot;patterns#identifier-patterns&quot;&gt;identifier pattern&lt;/a&gt; that binds by reference or mutable reference.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b301517253f81d6c23866ea49ad7c91ecb7227ac" translate="yes" xml:space="preserve">
          <source>An &lt;a href=&quot;std/keyword.async&quot;&gt;&lt;code&gt;async&lt;/code&gt;&lt;/a&gt; function used recursion without boxing.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f864e2f214828c68972804234bf4534f4526fce2" translate="yes" xml:space="preserve">
          <source>An &lt;a href=&quot;struct.atomicbool&quot;&gt;&lt;code&gt;AtomicBool&lt;/code&gt;&lt;/a&gt; initialized to &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">&lt;a href=&quot;struct.atomicbool&quot;&gt; &lt;code&gt;AtomicBool&lt;/code&gt; &lt;/a&gt; инициализируется , &lt;code&gt;false&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0d020d51655a42acae9fc5de2d1ee76334d13d2a" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;#[inline(..)]&lt;/code&gt; attribute was incorrectly placed on something other than a function or method.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="36aa4d3dbc6bef64eda94b67a998204c02c9bc40" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;Err&lt;/code&gt; will be returned if an error occurs while flushing the buffer.</source>
          <target state="translated">&lt;code&gt;Err&lt;/code&gt; будет возвращен , если произошла ошибка во время очистки буфера.</target>
        </trans-unit>
        <trans-unit id="93af004a9cc5d8031f1774a01ca4ad5a16a22376" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;Instant&lt;/code&gt; is a wrapper around system-specific types and it may behave differently depending on the underlying operating system. For example, the following snippet is fine on Linux but panics on macOS:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="08eb1e2f2f021298ee3677019a6bda280ed6f694" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;Ordering&lt;/code&gt; is the result of a comparison between two values.</source>
          <target state="translated">&lt;code&gt;Ordering&lt;/code&gt; является результатом сравнения между двумя значениями.</target>
        </trans-unit>
        <trans-unit id="001eb435d69650fbb2db42365be5918489730c71" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;RwLock&lt;/code&gt;, like &lt;a href=&quot;struct.mutex&quot;&gt;&lt;code&gt;Mutex&lt;/code&gt;&lt;/a&gt;, will become poisoned on a panic. Note, however, that an &lt;code&gt;RwLock&lt;/code&gt; may only be poisoned if a panic occurs while it is locked exclusively (write mode). If a panic occurs in any reader, then the lock will not be poisoned.</source>
          <target state="translated">&lt;code&gt;RwLock&lt;/code&gt; , как &lt;a href=&quot;struct.mutex&quot;&gt; &lt;code&gt;Mutex&lt;/code&gt; &lt;/a&gt; , будет отравляются на панику. Обратите внимание, однако, что &lt;code&gt;RwLock&lt;/code&gt; может быть отравлен только в случае возникновения паники, когда он заблокирован исключительно (режим записи). Если паника возникнет в любом ридере, то блокировка не будет отравлена.</target>
        </trans-unit>
        <trans-unit id="5247e633cc3100e9500337757cb3044553bdf55d" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;enum&lt;/code&gt; with a discriminant must specify a &lt;code&gt;#[repr(inttype)]&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;enum&lt;/code&gt; с дискриминанта необходимо указать &lt;code&gt;#[repr(inttype)]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c8b1cbde5060ed31e602542132d6a281bf766f42" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;export_name&lt;/code&gt; attribute contains null characters (&lt;code&gt;\0&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="21ec5e4c1f77a0601ab37f0e8a98cf223a18e608" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;if let&lt;/code&gt; expression is equivalent to a &lt;a href=&quot;match-expr&quot;&gt;&lt;code&gt;match&lt;/code&gt; expression&lt;/a&gt; as follows:</source>
          <target state="translated">&lt;code&gt;if let&lt;/code&gt; выражение эквивалентно &lt;a href=&quot;match-expr&quot;&gt; &lt;code&gt;match&lt;/code&gt; выражение&lt;/a&gt; следующим образом :</target>
        </trans-unit>
        <trans-unit id="2ca624a02ac8519763d7ccacb2b0ad8dad16c279" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;if let&lt;/code&gt; expression is semantically similar to an &lt;code&gt;if&lt;/code&gt; expression but in place of a condition expression it expects the keyword &lt;code&gt;let&lt;/code&gt; followed by a pattern, an &lt;code&gt;=&lt;/code&gt; and a &lt;a href=&quot;../glossary#scrutinee&quot;&gt;scrutinee&lt;/a&gt; expression. If the value of the scrutinee matches the pattern, the corresponding block will execute. Otherwise, flow proceeds to the following &lt;code&gt;else&lt;/code&gt; block if it exists. Like &lt;code&gt;if&lt;/code&gt; expressions, &lt;code&gt;if let&lt;/code&gt; expressions have a value determined by the block that is evaluated.</source>
          <target state="translated">&lt;code&gt;if let&lt;/code&gt; выражение семантический подобно , &lt;code&gt;if&lt;/code&gt; выражение , но вместо условного выражения он ожидает , что ключевое слова , &lt;code&gt;let&lt;/code&gt; следует шаблон, An &lt;code&gt;=&lt;/code&gt; и &lt;a href=&quot;../glossary#scrutinee&quot;&gt;scrutinee&lt;/a&gt; выражение. Если значение scrutinee соответствует шаблону, будет выполнен соответствующий блок. В противном случае поток переходит к следующему блоку &lt;code&gt;else&lt;/code&gt; , если он существует. Подобно выражениям &lt;code&gt;if&lt;/code&gt; , выражения &lt;code&gt;if let&lt;/code&gt; имеют значение, определяемое вычисляемым блоком.</target>
        </trans-unit>
        <trans-unit id="eee510cf708477f86b4dc6237cd892de065d1aca" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;if&lt;/code&gt; expression allows you to branch your code depending on conditions. You provide a condition and then state, &amp;ldquo;If this condition is met, run this block of code. If the condition is not met, do not run this block of code.&amp;rdquo;</source>
          <target state="translated">&lt;code&gt;if&lt;/code&gt; выражение позволяет расшириться код в зависимости от условий. Вы указываете условие, а затем заявляете: &amp;laquo;Если это условие выполняется, запустите этот блок кода. Если условие не выполняется, не запускайте этот блок кода &amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="23bc01de0e1b8681253f7b567d2d01b7869caf61" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;if&lt;/code&gt; expression is a conditional branch in program control. The form of an &lt;code&gt;if&lt;/code&gt; expression is a condition expression, followed by a consequent block, any number of &lt;code&gt;else if&lt;/code&gt; conditions and blocks, and an optional trailing &lt;code&gt;else&lt;/code&gt; block. The condition expressions must have type &lt;code&gt;bool&lt;/code&gt;. If a condition expression evaluates to &lt;code&gt;true&lt;/code&gt;, the consequent block is executed and any subsequent &lt;code&gt;else if&lt;/code&gt; or &lt;code&gt;else&lt;/code&gt; block is skipped. If a condition expression evaluates to &lt;code&gt;false&lt;/code&gt;, the consequent block is skipped and any subsequent &lt;code&gt;else if&lt;/code&gt; condition is evaluated. If all &lt;code&gt;if&lt;/code&gt; and &lt;code&gt;else if&lt;/code&gt; conditions evaluate to &lt;code&gt;false&lt;/code&gt; then any &lt;code&gt;else&lt;/code&gt; block is executed. An if expression evaluates to the same value as the executed block, or &lt;code&gt;()&lt;/code&gt; if no block is evaluated. An &lt;code&gt;if&lt;/code&gt; expression must have the same type in all situations.</source>
          <target state="translated">&lt;code&gt;if&lt;/code&gt; выражение является условной ветвью в программном управлении. Форма выражения &lt;code&gt;if&lt;/code&gt; - это выражение условия, за которым следует последовательный блок, любое количество условий и блоков &lt;code&gt;else if&lt;/code&gt; и необязательный завершающий блок &lt;code&gt;else&lt;/code&gt; . Выражения условия должны иметь тип &lt;code&gt;bool&lt;/code&gt; . Если выражение условия &lt;code&gt;true&lt;/code&gt; , следующий блок выполняется, а любой последующий блок &lt;code&gt;else if&lt;/code&gt; или &lt;code&gt;else&lt;/code&gt; пропускается. Если выражение условия оценивается как &lt;code&gt;false&lt;/code&gt; , последующий блок пропускается, а любой последующий блок &lt;code&gt;else if&lt;/code&gt; оценивается. Если все, &lt;code&gt;if&lt;/code&gt; и &lt;code&gt;else if&lt;/code&gt; условия оцениваются как &lt;code&gt;false&lt;/code&gt; выполняется любой блок &lt;code&gt;else&lt;/code&gt; . Выражение if дает то же значение, что и выполненный блок, или &lt;code&gt;()&lt;/code&gt; , если ни один блок не оценивается. &lt;code&gt;if&lt;/code&gt; выражение должно иметь тот же тип во всех ситуациях.</target>
        </trans-unit>
        <trans-unit id="f4cc3ee1616a9030743a2ead317eecbbfda11446" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;if&lt;/code&gt; expression is missing an &lt;code&gt;else&lt;/code&gt; block.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8f0d0db502cd02811b94f8110c6b6a57d9c4d08b" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;if&lt;/code&gt; expression without an &lt;code&gt;else&lt;/code&gt; block has the type &lt;code&gt;()&lt;/code&gt;, so this is a type error. To resolve it, add an &lt;code&gt;else&lt;/code&gt; block having the same type as the &lt;code&gt;if&lt;/code&gt; block.</source>
          <target state="translated">&lt;code&gt;if&lt;/code&gt; выражение без &lt;code&gt;else&lt;/code&gt; блоков имеет тип &lt;code&gt;()&lt;/code&gt; , так что это ошибка типа. Чтобы решить эту проблему, добавьте блок &lt;code&gt;else&lt;/code&gt; того же типа, что и блок &lt;code&gt;if&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="86c2bbd51b64dbea789df858c004c474818f64aa" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;impl Trait&lt;/code&gt; type expands to a recursive type.</source>
          <target state="translated">&lt;code&gt;impl Trait&lt;/code&gt; типа расширяется до рекурсивного типа.</target>
        </trans-unit>
        <trans-unit id="714f0cd77b96bfb041f113fa02745f0b3de0da54" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;impl Trait&lt;/code&gt; type must be expandable to a concrete type that contains no &lt;code&gt;impl Trait&lt;/code&gt; types. For example the following example tries to create an &lt;code&gt;impl Trait&lt;/code&gt; type &lt;code&gt;T&lt;/code&gt; that is equal to &lt;code&gt;[T, T]&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;impl Trait&lt;/code&gt; тип должен быть расширен до типа бетона , который не содержит &lt;code&gt;impl Trait&lt;/code&gt; типов. Например, в следующем примере предпринимается &lt;code&gt;impl Trait&lt;/code&gt; создать Im Trait type &lt;code&gt;T&lt;/code&gt; , равный &lt;code&gt;[T, T]&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="5f9bf65171254b99489d8d01742247cb5f9f2b96" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;impl Trait&lt;/code&gt; type must be expandable to a concrete type that contains no &lt;code&gt;impl Trait&lt;/code&gt; types. For example the previous example tries to create an &lt;code&gt;impl Trait&lt;/code&gt; type &lt;code&gt;T&lt;/code&gt; that is equal to &lt;code&gt;[T, T]&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ee4fc89f6e27033dd75c8304209d0e35cd3688c5" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;impl&lt;/code&gt; for a &lt;code&gt;#[marker]&lt;/code&gt; trait tried to override an associated item.</source>
          <target state="translated">&lt;code&gt;impl&lt;/code&gt; на &lt;code&gt;#[marker]&lt;/code&gt; признак пытался переопределить соответствующий пункт.</target>
        </trans-unit>
        <trans-unit id="6d1073354ecc9c5e7785479d7d2a13da928ab63a" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;x&lt;/code&gt; with value &lt;code&gt;0&lt;/code&gt; will return the bit width of &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;x&lt;/code&gt; со значением &lt;code&gt;0&lt;/code&gt; возвращает ширину битовой &lt;code&gt;T&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="80f05b7296f4e1950e87afc07c23f9e722a69148" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;x&lt;/code&gt; with value &lt;code&gt;0&lt;/code&gt; will return the bit width of &lt;code&gt;T&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;x&lt;/code&gt; со значением &lt;code&gt;0&lt;/code&gt; возвращает ширину битовой &lt;code&gt;T&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="4ce321b8a11937b61aec381eab2e9acd0f2ae8bc" translate="yes" xml:space="preserve">
          <source>An &lt;em&gt;&lt;a href=&quot;../types/array&quot;&gt;array&lt;/a&gt; expression&lt;/em&gt; can be written by enclosing zero or more comma-separated expressions of uniform type in square brackets. This produces an array containing each of these values in the order they are written.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="534dc31a67cf35753f9f6ff5f73b65cd1ba58ab5" translate="yes" xml:space="preserve">
          <source>An &lt;em&gt;&lt;a href=&quot;../types/array&quot;&gt;array&lt;/a&gt; expression&lt;/em&gt; can be written by enclosing zero or more comma-separated expressions of uniform type in square brackets. This produces and array containing each of these values in the order they are written.</source>
          <target state="translated">&lt;em&gt;&lt;a href=&quot;../types/array&quot;&gt;Массив&lt;/a&gt; выражение&lt;/em&gt; можно записать, заключив ноль или более разделенных запятыми выражения однородного типа в квадратных скобках. Это создает массив, содержащий каждое из этих значений в порядке их записи.</target>
        </trans-unit>
        <trans-unit id="32616f8cb6d3bd819da208e9fcccc36635a05f1e" translate="yes" xml:space="preserve">
          <source>An &lt;em&gt;&lt;code&gt;extern crate&lt;/code&gt; declaration&lt;/em&gt; specifies a dependency on an external crate. The external crate is then bound into the declaring scope as the &lt;a href=&quot;../identifiers&quot;&gt;identifier&lt;/a&gt; provided in the &lt;code&gt;extern crate&lt;/code&gt; declaration. The &lt;code&gt;as&lt;/code&gt; clause can be used to bind the imported crate to a different name.</source>
          <target state="translated">&lt;em&gt; &lt;code&gt;extern crate&lt;/code&gt; декларация&lt;/em&gt; определяет зависимость от внешнего ящика. Затем внешний ящик привязывается к области объявления в качестве &lt;a href=&quot;../identifiers&quot;&gt;идентификатора,&lt;/a&gt; указанного в объявлении &lt;code&gt;extern crate&lt;/code&gt; . Предложение &lt;code&gt;as&lt;/code&gt; можно использовать для привязки импортированного ящика к другому имени.</target>
        </trans-unit>
        <trans-unit id="13494e1cedf4f5c5ecdcb7c07e83d0cd9827df20" translate="yes" xml:space="preserve">
          <source>An &lt;em&gt;absolute path&lt;/em&gt; starts from a crate root by using a crate name or a literal &lt;code&gt;crate&lt;/code&gt;.</source>
          <target state="translated">&lt;em&gt;Абсолютный путь&lt;/em&gt; начинается от корня ящика с помощью имени обрешетки или буквальной &lt;code&gt;crate&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="86fdc788150826ae707ba926f5a66e96063c57f9" translate="yes" xml:space="preserve">
          <source>An &lt;em&gt;assignment expression&lt;/em&gt; consists of a &lt;a href=&quot;../expressions#place-expressions-and-value-expressions&quot;&gt;place expression&lt;/a&gt; followed by an equals sign (&lt;code&gt;=&lt;/code&gt;) and a &lt;a href=&quot;../expressions#place-expressions-and-value-expressions&quot;&gt;value expression&lt;/a&gt;. Such an expression always has the &lt;a href=&quot;../types/tuple&quot;&gt;&lt;code&gt;unit&lt;/code&gt; type&lt;/a&gt;.</source>
          <target state="translated">&lt;em&gt;Выражение присваивания&lt;/em&gt; состоит из &lt;a href=&quot;../expressions#place-expressions-and-value-expressions&quot;&gt;выражения места&lt;/a&gt; , за которым следует знак равно ( &lt;code&gt;=&lt;/code&gt; ) и &lt;a href=&quot;../expressions#place-expressions-and-value-expressions&quot;&gt;стоимостное выражение&lt;/a&gt; . Такое выражение всегда имеет &lt;a href=&quot;../types/tuple&quot;&gt; &lt;code&gt;unit&lt;/code&gt; тип&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="ca56087cc708820efe9481bf7313fdab4a040e22" translate="yes" xml:space="preserve">
          <source>An &lt;em&gt;associated constant declaration&lt;/em&gt; declares a signature for associated constant definitions. It is written as &lt;code&gt;const&lt;/code&gt;, then an identifier, then &lt;code&gt;:&lt;/code&gt;, then a type, finished by a &lt;code&gt;;&lt;/code&gt;.</source>
          <target state="translated">Объявление &lt;em&gt;ассоциированной константы&lt;/em&gt; объявляет подпись для связанных определений констант. Он записывается как &lt;code&gt;const&lt;/code&gt; , затем идентификатор, затем &lt;code&gt;:&lt;/code&gt; , затем тип, заканчивающийся a &lt;code&gt;;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ec29836d6b0ec5f807474f5934209d4fe8c7bb83" translate="yes" xml:space="preserve">
          <source>An &lt;em&gt;associated constant definition&lt;/em&gt; defines a constant associated with a type. It is written the same as a &lt;a href=&quot;constant-items&quot;&gt;constant item&lt;/a&gt;.</source>
          <target state="translated">Связанное &lt;em&gt;определение константы&lt;/em&gt; определяет константу, связанную с типом. Он записывается так же, как &lt;a href=&quot;constant-items&quot;&gt;постоянный элемент&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="c9d2944c74176d8d6fa13f7d573ee85d9e742d32" translate="yes" xml:space="preserve">
          <source>An &lt;em&gt;associated function declaration&lt;/em&gt; declares a signature for an associated function definition. It is written as a function item, except the function body is replaced with a &lt;code&gt;;&lt;/code&gt;.</source>
          <target state="translated">Объявление &lt;em&gt;связанной функции&lt;/em&gt; объявляет подпись для определения связанной функции. Он написан как элемент функции, за исключением того, что тело функции заменено на &lt;code&gt;;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="dce2c17d462060e477f166e6bcfabaf54ef17987" translate="yes" xml:space="preserve">
          <source>An &lt;em&gt;associated function definition&lt;/em&gt; defines a function associated with another type. It is written the same as a &lt;a href=&quot;../types/function-item&quot;&gt;function item&lt;/a&gt;.</source>
          <target state="translated">&lt;em&gt;Связано определение функции&lt;/em&gt; определяет функцию , связанную с другим типом. Он написан так же, как и &lt;a href=&quot;../types/function-item&quot;&gt;функциональный элемент&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="ddd6d9f2bd71f652e6f6a519a466ea3ae43a3bff" translate="yes" xml:space="preserve">
          <source>An &lt;em&gt;associated type declaration&lt;/em&gt; declares a signature for associated type definitions. It is written as &lt;code&gt;type&lt;/code&gt;, then an &lt;a href=&quot;../identifiers&quot;&gt;identifier&lt;/a&gt;, and finally an optional list of trait bounds.</source>
          <target state="translated">Объявление &lt;em&gt;связанного типа&lt;/em&gt; объявляет подпись для определений связанного типа. Он записывается как &lt;code&gt;type&lt;/code&gt; , затем &lt;a href=&quot;../identifiers&quot;&gt;идентификатор&lt;/a&gt; и, наконец, необязательный список границ признаков.</target>
        </trans-unit>
        <trans-unit id="9bd2e844486eba2a5ee0638c6e470984a319e1bf" translate="yes" xml:space="preserve">
          <source>An &lt;em&gt;associated type definition&lt;/em&gt; defines a type alias on another type. It is written as &lt;code&gt;type&lt;/code&gt;, then an &lt;a href=&quot;../identifiers&quot;&gt;identifier&lt;/a&gt;, then an &lt;code&gt;=&lt;/code&gt;, and finally a &lt;a href=&quot;../types#type-expressions&quot;&gt;type&lt;/a&gt;.</source>
          <target state="translated">&lt;em&gt;Связано определение типа&lt;/em&gt; определяет тип псевдонима на другом типе. Он записывается как &lt;code&gt;type&lt;/code&gt; , затем &lt;a href=&quot;../identifiers&quot;&gt;идентификатор&lt;/a&gt; , затем знак &lt;code&gt;=&lt;/code&gt; и, наконец, &lt;a href=&quot;../types#type-expressions&quot;&gt;тип&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="d29048068c2d4e137f184a7dcfb9e91e3a77ac3e" translate="yes" xml:space="preserve">
          <source>An &lt;em&gt;async block&lt;/em&gt; is a variant of a block expression which evaluates to a &lt;em&gt;future&lt;/em&gt;. The final expression of the block, if present, determines the result value of the future.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="335c18325b2749c2db5132eb57bce1ffbfa512dc" translate="yes" xml:space="preserve">
          <source>An &lt;em&gt;attribute&lt;/em&gt; is a general, free-form metadatum that is interpreted according to name, convention, and language and compiler version. Attributes are modeled on Attributes in &lt;a href=&quot;https://www.ecma-international.org/publications/standards/Ecma-335.htm&quot;&gt;ECMA-335&lt;/a&gt;, with the syntax coming from &lt;a href=&quot;https://www.ecma-international.org/publications/standards/Ecma-334.htm&quot;&gt;ECMA-334&lt;/a&gt; (C#).</source>
          <target state="translated">&lt;em&gt;Атрибут&lt;/em&gt; является общей, в свободной форме metadatum , что интерпретируется в соответствии с названием, конвенцией, и языком , и компилятором версии. Атрибуты моделируются на основе атрибутов в &lt;a href=&quot;https://www.ecma-international.org/publications/standards/Ecma-335.htm&quot;&gt;ECMA-335&lt;/a&gt; с синтаксисом из &lt;a href=&quot;https://www.ecma-international.org/publications/standards/Ecma-334.htm&quot;&gt;ECMA-334&lt;/a&gt; (C #).</target>
        </trans-unit>
        <trans-unit id="7486c611897561f3f092f583b562152c09bc11bb" translate="yes" xml:space="preserve">
          <source>An &lt;em&gt;attribute&lt;/em&gt; is a general, free-form metadatum that is interpreted according to name, convention, language, and compiler version. Attributes are modeled on Attributes in &lt;a href=&quot;https://www.ecma-international.org/publications/standards/Ecma-335.htm&quot;&gt;ECMA-335&lt;/a&gt;, with the syntax coming from &lt;a href=&quot;https://www.ecma-international.org/publications/standards/Ecma-334.htm&quot;&gt;ECMA-334&lt;/a&gt; (C#).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8f90d06fddc7c21886a0949a73d97b908062294c" translate="yes" xml:space="preserve">
          <source>An &lt;em&gt;enumerated type&lt;/em&gt; is a nominal, heterogeneous disjoint union type, denoted by the name of an &lt;a href=&quot;../items/enumerations&quot;&gt;&lt;code&gt;enum&lt;/code&gt; item&lt;/a&gt;. &lt;sup&gt;&lt;a href=&quot;#enumtype&quot;&gt;1&lt;/a&gt;&lt;/sup&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fe8d0e2999c5dfed50da51262f087365afa14a25" translate="yes" xml:space="preserve">
          <source>An &lt;em&gt;enumerated type&lt;/em&gt; is a nominal, heterogeneous disjoint union type, denoted by the name of an &lt;a href=&quot;../items/enumerations&quot;&gt;&lt;code&gt;enum&lt;/code&gt; item&lt;/a&gt;. &lt;sup&gt;&lt;a href=&quot;enum#enumtype&quot;&gt;1&lt;/a&gt;&lt;/sup&gt;</source>
          <target state="translated">&lt;em&gt;Перечислимый типом&lt;/em&gt; является номинальным, гетерогенным типом несвязного, обозначается наименованием &lt;a href=&quot;../items/enumerations&quot;&gt; &lt;code&gt;enum&lt;/code&gt; элемента&lt;/a&gt; . &lt;sup&gt;&lt;a href=&quot;enum#enumtype&quot;&gt;1&lt;/a&gt;&lt;/sup&gt;</target>
        </trans-unit>
        <trans-unit id="519b32460e4cf24cbf7584ec56a2b57870f1cdef" translate="yes" xml:space="preserve">
          <source>An &lt;em&gt;enumeration&lt;/em&gt;, also referred to as &lt;em&gt;enum&lt;/em&gt; is a simultaneous definition of a nominal &lt;a href=&quot;../types/enum&quot;&gt;enumerated type&lt;/a&gt; as well as a set of &lt;em&gt;constructors&lt;/em&gt;, that can be used to create or pattern-match values of the corresponding enumerated type.</source>
          <target state="translated">&lt;em&gt;Перечисления&lt;/em&gt; , также упоминается как &lt;em&gt;перечисление&lt;/em&gt; является одновременным определением номинального &lt;a href=&quot;../types/enum&quot;&gt;перечислимого типа&lt;/a&gt; , а также набора &lt;em&gt;конструкторов&lt;/em&gt; , которые могут быть использованы для создания или значения сопоставления с образцом соответствующего типа перечисленного.</target>
        </trans-unit>
        <trans-unit id="670995bec677d5fc81f3189dbec41d6de7da346c" translate="yes" xml:space="preserve">
          <source>An &lt;em&gt;example term&lt;/em&gt; is an example of a term being defined.</source>
          <target state="translated">Примерный &lt;em&gt;термин&lt;/em&gt; - это пример определяемого термина.</target>
        </trans-unit>
        <trans-unit id="03f2bd4498afb61074c0d1568fbae87b71b0a6a3" translate="yes" xml:space="preserve">
          <source>An &lt;em&gt;expression statement&lt;/em&gt; is one that evaluates an &lt;a href=&quot;expressions&quot;&gt;expression&lt;/a&gt; and ignores its result. As a rule, an expression statement's purpose is to trigger the effects of evaluating its expression.</source>
          <target state="translated">&lt;em&gt;Выражение утверждение&lt;/em&gt; является тот , который вычисляет &lt;a href=&quot;expressions&quot;&gt;выражение&lt;/a&gt; и игнорирует его результат. Как правило, цель выражения выражения - вызвать эффекты оценки его выражения.</target>
        </trans-unit>
        <trans-unit id="4c66d5e565f712d67ccd031da7fc185642328c03" translate="yes" xml:space="preserve">
          <source>An &lt;em&gt;extending pattern&lt;/em&gt; is either</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="111aa957a35f04452bf335357f4b5845abfce6b9" translate="yes" xml:space="preserve">
          <source>An &lt;em&gt;implementation&lt;/em&gt; is an item that associates items with an &lt;em&gt;implementing type&lt;/em&gt;. Implementations are defined with the keyword &lt;code&gt;impl&lt;/code&gt; and contain functions that belong to an instance of the type that is being implemented or to the type statically.</source>
          <target state="translated">&lt;em&gt;Реализация&lt;/em&gt; является элементом , который связывает элементы со &lt;em&gt;реализующего типа&lt;/em&gt; . Реализации определяются с помощью ключевого слова &lt;code&gt;impl&lt;/code&gt; и содержат функции, которые принадлежат экземпляру типа, который реализуется, или типу статически.</target>
        </trans-unit>
        <trans-unit id="26714676268e63e4c19e025e4e919231c94ab7b4" translate="yes" xml:space="preserve">
          <source>An &lt;em&gt;integer literal&lt;/em&gt; has one of four forms:</source>
          <target state="translated">&lt;em&gt;Целочисленный литерал&lt;/em&gt; имеет одну из четырех форм:</target>
        </trans-unit>
        <trans-unit id="3b04f25de241c42aa4cc17d61d52253aec0db163" translate="yes" xml:space="preserve">
          <source>An &lt;em&gt;integer&lt;/em&gt; is a number without a fractional component. We used one integer type in Chapter 2, the &lt;code&gt;u32&lt;/code&gt; type. This type declaration indicates that the value it&amp;rsquo;s associated with should be an unsigned integer (signed integer types start with &lt;code&gt;i&lt;/code&gt;, instead of &lt;code&gt;u&lt;/code&gt;) that takes up 32 bits of space. Table 3-1 shows the built-in integer types in Rust. Each variant in the Signed and Unsigned columns (for example, &lt;code&gt;i16&lt;/code&gt;) can be used to declare the type of an integer value.</source>
          <target state="translated">Целое &lt;em&gt;число&lt;/em&gt; - это число без дробной части. В главе 2 мы использовали один целочисленный тип - тип &lt;code&gt;u32&lt;/code&gt; . Это объявление типа указывает, что значение, с которым он связан, должно быть целым числом без знака (целые типы со &lt;code&gt;i&lt;/code&gt; начинаются с i , а не с &lt;code&gt;u&lt;/code&gt; ), которое занимает 32 бита пространства. В таблице 3-1 показаны встроенные целочисленные типы в Rust. Каждый вариант в столбцах со &lt;code&gt;i16&lt;/code&gt; и без знака (например, i16 ) может использоваться для объявления типа целочисленного значения.</target>
        </trans-unit>
        <trans-unit id="c86645edb5b5b0c86e3d214a4daf335142eb0487" translate="yes" xml:space="preserve">
          <source>An &lt;em&gt;item declaration statement&lt;/em&gt; has a syntactic form identical to an &lt;a href=&quot;items&quot;&gt;item declaration&lt;/a&gt; within a &lt;a href=&quot;items/modules&quot;&gt;module&lt;/a&gt;. Declaring an item within a statement block restricts its scope to the block containing the statement. The item is not given a &lt;a href=&quot;paths#canonical-paths&quot;&gt;canonical path&lt;/a&gt; nor are any sub-items it may declare. The exception to this is that associated items defined by &lt;a href=&quot;items/implementations&quot;&gt;implementations&lt;/a&gt; are still accessible in outer scopes as long as the item and, if applicable, trait are accessible. It is otherwise identical in meaning to declaring the item inside a module.</source>
          <target state="translated">&lt;em&gt;Оператор объявления элемента&lt;/em&gt; имеет синтаксическую форму , идентичную к &lt;a href=&quot;items&quot;&gt;декларации элемента&lt;/a&gt; внутри &lt;a href=&quot;items/modules&quot;&gt;модуля&lt;/a&gt; . Объявление элемента в блоке операторов ограничивает его область действия блоком, содержащим оператор. Элементу не задан &lt;a href=&quot;paths#canonical-paths&quot;&gt;канонический путь,&lt;/a&gt; и нет никаких подпунктов, которые он может объявлять. Исключением является то, что связанные элементы, определенные &lt;a href=&quot;items/implementations&quot;&gt;реализациями&lt;/a&gt; , все еще доступны во внешних областях, пока доступны элемент и, если применимо, признак. В остальном это идентично объявлению элемента внутри модуля.</target>
        </trans-unit>
        <trans-unit id="7cb6bea3f24f939f1296c8f5c8b195169146ee81" translate="yes" xml:space="preserve">
          <source>An &lt;em&gt;item&lt;/em&gt; is a component of a crate. Items are organized within a crate by a nested set of &lt;a href=&quot;items/modules&quot;&gt;modules&lt;/a&gt;. Every crate has a single &quot;outermost&quot; anonymous module; all further items within the crate have &lt;a href=&quot;paths&quot;&gt;paths&lt;/a&gt; within the module tree of the crate.</source>
          <target state="translated">&lt;em&gt;Элемент&lt;/em&gt; является компонентом клети. Элементы организованы в ящике с помощью вложенного набора &lt;a href=&quot;items/modules&quot;&gt;модулей&lt;/a&gt; . Каждый ящик имеет единственный &amp;laquo;внешний&amp;raquo; анонимный модуль; все дальнейшие элементы в ящике имеют &lt;a href=&quot;paths&quot;&gt;пути&lt;/a&gt; в дереве модулей ящика.</target>
        </trans-unit>
        <trans-unit id="8df47e4537a8816a2744d87425d00def520f575a" translate="yes" xml:space="preserve">
          <source>An &lt;em&gt;octal literal&lt;/em&gt; starts with the character sequence &lt;code&gt;U+0030&lt;/code&gt;&lt;code&gt;U+006F&lt;/code&gt; (&lt;code&gt;0o&lt;/code&gt;) and continues as any mixture (with at least one digit) of octal digits and underscores.</source>
          <target state="translated">An &lt;em&gt;восьмеричные буквенные&lt;/em&gt; начинается с последовательностью символов &lt;code&gt;U+0030&lt;/code&gt; &lt;code&gt;U+006F&lt;/code&gt; ( &lt;code&gt;0o&lt;/code&gt; ) и продолжается , как и любая смесь (с , по меньшей мере одну цифры) из восьмеричных цифр и символов подчеркивания.</target>
        </trans-unit>
        <trans-unit id="a141d1e8af86d54f8339e504d3e1c56051728a15" translate="yes" xml:space="preserve">
          <source>An Example Program Using Structs</source>
          <target state="translated">Пример программы с использованием структур</target>
        </trans-unit>
        <trans-unit id="5aefcb56dc6b861369f867948d8b3b7d49377bfe" translate="yes" xml:space="preserve">
          <source>An I/O Project: Building a Command Line Program</source>
          <target state="translated">Проект ввода-вывода:Создание программы командной строки</target>
        </trans-unit>
        <trans-unit id="0827868381963388a6304543297f7f95e42e9164" translate="yes" xml:space="preserve">
          <source>An IP address, either IPv4 or IPv6.</source>
          <target state="translated">IP-адрес,либо IPv4,либо IPv6.</target>
        </trans-unit>
        <trans-unit id="ac4cbc9b22ca704cfdd900cac5407adcf23c5edb" translate="yes" xml:space="preserve">
          <source>An IPv4 address representing an unspecified address: 0.0.0.0</source>
          <target state="translated">Адрес IPv4,представляющий собой неопределенный адрес:0.0.0.0</target>
        </trans-unit>
        <trans-unit id="d2e22ab3badaaaa01e7375dd220a2065ca03f949" translate="yes" xml:space="preserve">
          <source>An IPv4 address representing the broadcast address: 255.255.255.255</source>
          <target state="translated">Адрес IPv4,представляющий широковещательный адрес:255.255.255.255</target>
        </trans-unit>
        <trans-unit id="5f0e70a5e365495e2ae4d74f302988b1f303a907" translate="yes" xml:space="preserve">
          <source>An IPv4 address with the address pointing to localhost: 127.0.0.1.</source>
          <target state="translated">IPv4-адрес с адресом,указывающим на localhost:127.0.0.1.</target>
        </trans-unit>
        <trans-unit id="c9d68f8900e66f00bfbfd5b6cf93e7f299173890" translate="yes" xml:space="preserve">
          <source>An IPv4 address.</source>
          <target state="translated">Адрес IPv4.</target>
        </trans-unit>
        <trans-unit id="5bb8e3b87105ecbe9c8ed2a2e3a9821088df2706" translate="yes" xml:space="preserve">
          <source>An IPv4 socket address.</source>
          <target state="translated">Адрес сокета IPv4.</target>
        </trans-unit>
        <trans-unit id="a30848e04ae8ee9ab468ffa0929f622538606ceb" translate="yes" xml:space="preserve">
          <source>An IPv6 address representing localhost: &lt;code&gt;::1&lt;/code&gt;.</source>
          <target state="translated">Адрес IPv6, представляющий localhost: &lt;code&gt;::1&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2e145c57ced7f65d6f3f83ddc10fbd40d1da4596" translate="yes" xml:space="preserve">
          <source>An IPv6 address representing the unspecified address: &lt;code&gt;::&lt;/code&gt;</source>
          <target state="translated">Адрес IPv6, представляющий неуказанный адрес: &lt;code&gt;::&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="ee7dda9f630704f82008f3562e22d445246045b1" translate="yes" xml:space="preserve">
          <source>An IPv6 address.</source>
          <target state="translated">Адрес IPv6.</target>
        </trans-unit>
        <trans-unit id="51d9d6e575aa92d12e0b2c0fb0d5fdcf4923ff85" translate="yes" xml:space="preserve">
          <source>An IPv6 socket address.</source>
          <target state="translated">Адрес сокета IPv6.</target>
        </trans-unit>
        <trans-unit id="bb7fb098f948c20be5364a0797d6630c8f71fe36" translate="yes" xml:space="preserve">
          <source>An RAII implementation of a &quot;scoped lock&quot; of a mutex. When this structure is dropped (falls out of scope), the lock will be unlocked.</source>
          <target state="translated">Реализация RAII &quot;скопированного замка&quot; мьютекса.Когда эта структура выпадает из поля зрения (выпадает из поля зрения),блокировка будет разблокирована.</target>
        </trans-unit>
        <trans-unit id="445fdaee68caea7b120e9af421a1f499e812ae92" translate="yes" xml:space="preserve">
          <source>An additional advantage of using Cargo is that the commands are the same no matter which operating system you&amp;rsquo;re working on. So, at this point, we&amp;rsquo;ll no longer provide specific instructions for Linux and macOS versus Windows.</source>
          <target state="translated">Дополнительным преимуществом использования Cargo является то, что команды одинаковы независимо от того, в какой операционной системе вы работаете. Итак, на данный момент мы больше не будем предоставлять конкретные инструкции для Linux и macOS по сравнению с Windows.</target>
        </trans-unit>
        <trans-unit id="71d51fdd16cd827000271f90af417efeb9cea05f" translate="yes" xml:space="preserve">
          <source>An address associated with a Unix socket.</source>
          <target state="translated">Адрес,связанный с Unix-сокетом.</target>
        </trans-unit>
        <trans-unit id="13ebc470b9c08ca083e04f253e5b3a814fa55f28" translate="yes" xml:space="preserve">
          <source>An anchor in time which can be used to create new &lt;code&gt;SystemTime&lt;/code&gt; instances or learn about where in time a &lt;code&gt;SystemTime&lt;/code&gt; lies.</source>
          <target state="translated">Якорь во времени, который можно использовать для создания новых экземпляров &lt;code&gt;SystemTime&lt;/code&gt; или изучения того, где находится &lt;code&gt;SystemTime&lt;/code&gt; во времени .</target>
        </trans-unit>
        <trans-unit id="0b2bb6c8ec3576952f4aecc99eb5bbbbf4cbd659" translate="yes" xml:space="preserve">
          <source>An array is a fixed-size sequence of &lt;code&gt;N&lt;/code&gt; elements of type &lt;code&gt;T&lt;/code&gt;. The array type is written as &lt;code&gt;[T; N]&lt;/code&gt;. The size is a &lt;a href=&quot;../const_eval#constant-expressions&quot;&gt;constant expression&lt;/a&gt; that evaluates to a &lt;a href=&quot;numeric#machine-dependent-integer-types&quot;&gt;&lt;code&gt;usize&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="65f427918d6366c3545d7bcd1528880b6655f86b" translate="yes" xml:space="preserve">
          <source>An array is a fixed-size sequence of &lt;code&gt;N&lt;/code&gt; elements of type &lt;code&gt;T&lt;/code&gt;. The array type is written as &lt;code&gt;[T; N]&lt;/code&gt;. The size is an expression that evaluates to a &lt;a href=&quot;numeric#machine-dependent-integer-types&quot;&gt;&lt;code&gt;usize&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Массив представляет собой последовательность фиксированного размера из &lt;code&gt;N&lt;/code&gt; элементов типа &lt;code&gt;T&lt;/code&gt; . Тип массива записывается как &lt;code&gt;[T; N]&lt;/code&gt; . Размер - это выражение, которое оценивается как &lt;a href=&quot;numeric#machine-dependent-integer-types&quot;&gt; &lt;code&gt;usize&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="d98f60a77f0bbfa809e448ded22428fbfae4e33e" translate="yes" xml:space="preserve">
          <source>An array is a single chunk of memory allocated on the stack. You can access elements of an array using indexing, like this:</source>
          <target state="translated">Массив-это один кусочек памяти,выделенный на стеке.Доступ к элементам массива можно получить с помощью индексации:</target>
        </trans-unit>
        <trans-unit id="a7bac5ec811f30188ce6fd849b796ac2d30ffddc" translate="yes" xml:space="preserve">
          <source>An array itself is not iterable:</source>
          <target state="translated">Массив сам по себе не является итерабельным:</target>
        </trans-unit>
        <trans-unit id="f510f3fd4950ebae5518ce0880fd83877599bc5e" translate="yes" xml:space="preserve">
          <source>An array or slice pattern required more elements than were present in the matched array.</source>
          <target state="translated">Массив или шаблон среза требуют больше элементов,чем было в соответствующем массиве.</target>
        </trans-unit>
        <trans-unit id="005f7187c479dcce2321a163ab284d4855025280" translate="yes" xml:space="preserve">
          <source>An array or slice pattern was matched against some other type.</source>
          <target state="translated">Массив или шаблон среза был сопоставлен с каким-либо другим типом.</target>
        </trans-unit>
        <trans-unit id="910b39cfa9beb5c32b52af8b271e7bb38ba1d4da" translate="yes" xml:space="preserve">
          <source>An array without a fixed length was pattern-matched.</source>
          <target state="translated">Массив без фиксированной длины был подобран по шаблону.</target>
        </trans-unit>
        <trans-unit id="9f6ee782e8b3dacab5901a68a88743cdf8f6df8d" translate="yes" xml:space="preserve">
          <source>An array, sometimes also called a fixed-size array or an inline array, is a value describing a collection of elements, each selected by an index that can be computed at run time by the program. It occupies a contiguous region of memory.</source>
          <target state="translated">Массив,иногда также называемый массивом фиксированного размера или массивом inline,представляет собой значение,описывающее коллекцию элементов,каждый из которых выбирается по индексу,который может быть вычислен программой во время выполнения.Он занимает сопряженную область памяти.</target>
        </trans-unit>
        <trans-unit id="f5926a4f64969381cfadf3083ad59aa47fe8cee7" translate="yes" xml:space="preserve">
          <source>An assignment operator was used on a non-place expression.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0369538fab9323882e54c1420899b941701d5cc4" translate="yes" xml:space="preserve">
          <source>An associated const has been referenced in a pattern.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="653f3f2885d5dd5f232a75cd2c5ed4a07f552285" translate="yes" xml:space="preserve">
          <source>An associated const was implemented when another trait item was expected.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="704af6b84f8ec0b7b57fdf7ea0ff93aa51a032a6" translate="yes" xml:space="preserve">
          <source>An associated const was implemented when another trait item was expected. Erroneous code example:</source>
          <target state="translated">Связанный с ним констант реализуется,когда ожидается появление еще одного признака.Пример ошибочного кода:</target>
        </trans-unit>
        <trans-unit id="597e595feda6e78ec52004cc35588610f09289b1" translate="yes" xml:space="preserve">
          <source>An associated constant whose name does not match any of the associated constants in the trait was used when implementing the trait.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ac10e51ff90ef78acbd226706348e7754e0cff2c" translate="yes" xml:space="preserve">
          <source>An associated function for a trait was defined to be a method (i.e., to take a &lt;code&gt;self&lt;/code&gt; parameter), but an implementation of the trait declared the same function to be static.</source>
          <target state="translated">Связанная функция для признака была определена как метод (т. Е. Принимающая параметр &lt;code&gt;self&lt;/code&gt; ), но реализация признака объявила ту же функцию статической.</target>
        </trans-unit>
        <trans-unit id="825b9fd38095eee93e418cc09ae8f9ace5e1f868" translate="yes" xml:space="preserve">
          <source>An associated function for a trait was defined to be static, but an implementation of the trait declared the same function to be a method (i.e., to take a &lt;code&gt;self&lt;/code&gt; parameter).</source>
          <target state="translated">Связанная функция для признака была определена как статическая, но реализация признака объявила ту же функцию как метод (т. Е. Для получения &lt;code&gt;self&lt;/code&gt; параметра).</target>
        </trans-unit>
        <trans-unit id="a1184c06942df2b68acc5d480218b30a08f0c9d0" translate="yes" xml:space="preserve">
          <source>An associated item is an item that is associated with another item. Associated items are defined in &lt;a href=&quot;items/implementations&quot;&gt;implementations&lt;/a&gt; and declared in &lt;a href=&quot;items/traits&quot;&gt;traits&lt;/a&gt;. Only functions, constants, and type aliases can be associated. Contrast to a &lt;a href=&quot;#free-item&quot;&gt;free item&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1035c9277b00c3deebef8eabfe1b836a5766b141" translate="yes" xml:space="preserve">
          <source>An associated item is an item that is associated with another item. Associated items are defined in &lt;a href=&quot;items/implementations&quot;&gt;implementations&lt;/a&gt; and declared in &lt;a href=&quot;items/traits&quot;&gt;traits&lt;/a&gt;. Only functions, constants, and type aliases can be associated. Contrast to a &lt;a href=&quot;glossary#free-item&quot;&gt;free item&lt;/a&gt;.</source>
          <target state="translated">Связанный элемент - это элемент, связанный с другим элементом. Связанные элементы определены в &lt;a href=&quot;items/implementations&quot;&gt;реализациях&lt;/a&gt; и объявлены в &lt;a href=&quot;items/traits&quot;&gt;трейтах&lt;/a&gt; . Могут быть связаны только функции, константы и псевдонимы типов. В отличие от &lt;a href=&quot;glossary#free-item&quot;&gt;бесплатного товара&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="ced942872757a981c250f3840769940a97d69e7c" translate="yes" xml:space="preserve">
          <source>An associated item wasn't found in the given type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7d46370a3ccac2f9ec0235a03f2055e6765250fa" translate="yes" xml:space="preserve">
          <source>An associated type binding was done outside of the type parameter declaration and &lt;code&gt;where&lt;/code&gt; clause.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9116723797d95c7e68863b40ba3626f52a6ce11f" translate="yes" xml:space="preserve">
          <source>An associated type binding was done outside of the type parameter declaration and &lt;code&gt;where&lt;/code&gt; clause. Erroneous code example:</source>
          <target state="translated">Связывание связанного типа было выполнено вне объявления параметра типа и предложения &lt;code&gt;where&lt;/code&gt; . Пример ошибочного кода:</target>
        </trans-unit>
        <trans-unit id="37ff7ecac0e044a097c6ebca208c9701778e86ec" translate="yes" xml:space="preserve">
          <source>An associated type value was specified more than once.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="247841afd59307a4cdd6a2a4e665f214e72f4dc2" translate="yes" xml:space="preserve">
          <source>An associated type was implemented when another trait item was expected.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="01d78cadc098f0f8d19a172d639f50a5e45d007b" translate="yes" xml:space="preserve">
          <source>An associated type was implemented when another trait item was expected. Erroneous code example:</source>
          <target state="translated">Связанный с ним тип реализуется,когда ожидается появление другого признака.Пример ошибочного кода:</target>
        </trans-unit>
        <trans-unit id="907ca33cb695a944297042466b1a4f3511ae0a97" translate="yes" xml:space="preserve">
          <source>An associated type wasn't specified for a trait object.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="57e68f500f344ba1542de979c138dbc82f1b75b2" translate="yes" xml:space="preserve">
          <source>An associated type whose name does not match any of the associated types in the trait was used when implementing the trait.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ca2d4322730aa4a674f88f33ea28a7a44379f38a" translate="yes" xml:space="preserve">
          <source>An asterisk &lt;code&gt;.*&lt;/code&gt;:</source>
          <target state="translated">Звездочка &lt;code&gt;.*&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="b4e5a645b1ce82ee08ed7b0b7215a18a0a85f802" translate="yes" xml:space="preserve">
          <source>An async function is roughly equivalent to a function that returns &lt;a href=&quot;../types/impl-trait&quot;&gt;&lt;code&gt;impl Future&lt;/code&gt;&lt;/a&gt; and with an &lt;a href=&quot;../expressions/block-expr#async-blocks&quot;&gt;&lt;code&gt;async move&lt;/code&gt; block&lt;/a&gt; as its body:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fcbf33b833d8349f917a7e3318533a910b1e01c0" translate="yes" xml:space="preserve">
          <source>An asynchronous, infinitely buffered channel. The &lt;a href=&quot;fn.channel&quot;&gt;&lt;code&gt;channel&lt;/code&gt;&lt;/a&gt; function will return a &lt;code&gt;(Sender, Receiver)&lt;/code&gt; tuple where all sends will be &lt;strong&gt;asynchronous&lt;/strong&gt; (they never block). The channel conceptually has an infinite buffer.</source>
          <target state="translated">Асинхронный канал с неограниченной буферизацией. Функция &lt;a href=&quot;fn.channel&quot;&gt; &lt;code&gt;channel&lt;/code&gt; &lt;/a&gt; вернет кортеж &lt;code&gt;(Sender, Receiver)&lt;/code&gt; котором все отправления будут &lt;strong&gt;асинхронными&lt;/strong&gt; (они никогда не блокируются). Канал концептуально имеет бесконечный буфер.</target>
        </trans-unit>
        <trans-unit id="f387b126eb53d62fa04e8482ab5a1aac01b56bf6" translate="yes" xml:space="preserve">
          <source>An atomic fence.</source>
          <target state="translated">Атомный забор.</target>
        </trans-unit>
        <trans-unit id="a37a15efc349a5896258ef2d831759eaab050729" translate="yes" xml:space="preserve">
          <source>An atomic integer initialized to &lt;code&gt;0&lt;/code&gt;.</source>
          <target state="translated">Атомарное целое число, инициализированное &lt;code&gt;0&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ae4be8bb4563b5c446bf4ec14a3a559fbf234d0d" translate="yes" xml:space="preserve">
          <source>An attempt to implement the &lt;code&gt;Copy&lt;/code&gt; trait for a struct failed because one of the fields does not implement &lt;code&gt;Copy&lt;/code&gt;. To fix this, you must implement &lt;code&gt;Copy&lt;/code&gt; for the mentioned field. Note that this may not be possible, as in the example of</source>
          <target state="translated">Попытка реализовать трейт &lt;code&gt;Copy&lt;/code&gt; для структуры не удалась, потому что одно из полей не реализует &lt;code&gt;Copy&lt;/code&gt; . Чтобы исправить это, вы должны реализовать &lt;code&gt;Copy&lt;/code&gt; для указанного поля. Обратите внимание, что это может быть невозможно, как в примере с</target>
        </trans-unit>
        <trans-unit id="2c5fbb1197d035a7f4fa92b6ea1f62d369096169" translate="yes" xml:space="preserve">
          <source>An attempt to implement the &lt;code&gt;Copy&lt;/code&gt; trait for an enum failed because one of the variants does not implement &lt;code&gt;Copy&lt;/code&gt;. To fix this, you must implement &lt;code&gt;Copy&lt;/code&gt; for the mentioned variant. Note that this may not be possible, as in the example of</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b71c2935e96e5f7fe3e3f35ad00fd7b30920019f" translate="yes" xml:space="preserve">
          <source>An attempt to index into a type which doesn't implement the &lt;code&gt;std::ops::Index&lt;/code&gt; trait was performed.</source>
          <target state="translated">Была произведена попытка индексирования в тип, который не реализует &lt;code&gt;std::ops::Index&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="51757a13968190cd3655b5b9aeefd9a5c033b3d1" translate="yes" xml:space="preserve">
          <source>An attempt to use index on a type which doesn't implement the &lt;code&gt;std::ops::Index&lt;/code&gt; trait was performed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8b97d7ea40069db8f20f10d06addb087be36d0ac" translate="yes" xml:space="preserve">
          <source>An attempt was made to access an associated constant through either a generic type parameter or &lt;code&gt;Self&lt;/code&gt;. This is not supported yet. An example causing this error is shown below:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b710e02452ddf90fa51364201e945e5cc61639f6" translate="yes" xml:space="preserve">
          <source>An attempt was made to assign to a borrowed value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1bdf1eb8c23bfc6042e5dd9af78ec4f5f794fefe" translate="yes" xml:space="preserve">
          <source>An attempt was made to constrain an associated type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8febb37ae18b2d657b2615e5b330d2a55118441d" translate="yes" xml:space="preserve">
          <source>An attempt was made to implement &lt;code&gt;Drop&lt;/code&gt; on a concrete specialization of a generic type. An example is shown below:</source>
          <target state="translated">Была предпринята попытка реализовать &lt;code&gt;Drop&lt;/code&gt; на конкретной специализации универсального типа. Пример показан ниже:</target>
        </trans-unit>
        <trans-unit id="26819bff2d7a8100bea5239c764f0f0d26036cba" translate="yes" xml:space="preserve">
          <source>An attempt was made to implement &lt;code&gt;Drop&lt;/code&gt; on a specialization of a generic type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="09ba79d4404f5653d6f77e24331c8ba336aac40d" translate="yes" xml:space="preserve">
          <source>An attempt was made to implement &lt;code&gt;Drop&lt;/code&gt; on a specialization of a generic type. An example is shown below:</source>
          <target state="translated">Была предпринята попытка реализовать &lt;code&gt;Drop&lt;/code&gt; на специализации универсального типа. Пример показан ниже:</target>
        </trans-unit>
        <trans-unit id="c55e6f81b7dc27d46319cedb33bad7716f5297f4" translate="yes" xml:space="preserve">
          <source>An attempt was made to implement Drop on a trait, which is not allowed: only structs and enums can implement Drop. An example causing this error:</source>
          <target state="translated">Была сделана попытка реализовать Drop on a trait,что не допускается:реализовать Drop могут только структуры и перечисления.Пример,вызывающий эту ошибку:</target>
        </trans-unit>
        <trans-unit id="e153b913d67d75c58662cead8cf242032c80e00b" translate="yes" xml:space="preserve">
          <source>An attempt was made to mutate data using a non-mutable reference. This commonly occurs when attempting to assign to a non-mutable reference of a mutable reference (&lt;code&gt;&amp;amp;(&amp;amp;mut T)&lt;/code&gt;).</source>
          <target state="translated">Была предпринята попытка изменить данные с помощью неизменяемой ссылки. Обычно это происходит при попытке назначить неизменяемую ссылку изменяемой ссылки ( &lt;code&gt;&amp;amp;(&amp;amp;mut T)&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="ca0f2abce0a16f2ca7a56625ca020df6fd2125b3" translate="yes" xml:space="preserve">
          <source>An attempt was made to retrieve an associated type, but the type was ambiguous.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="adb3222e10ca68a4902e2fef67ce06d659218b60" translate="yes" xml:space="preserve">
          <source>An attempt was made to retrieve an associated type, but the type was ambiguous. For example:</source>
          <target state="translated">Была предпринята попытка найти ассоциированный тип,но тип был неоднозначным.Например:</target>
        </trans-unit>
        <trans-unit id="89de6efbf294db50ea9580038de7bf4a99c6cc2d" translate="yes" xml:space="preserve">
          <source>An attempted conversion that consumes &lt;code&gt;self&lt;/code&gt;, which may or may not be expensive.</source>
          <target state="translated">Попытка преобразования, которая потребляет &lt;code&gt;self&lt;/code&gt; , что может быть дорогостоящим, а может и нет.</target>
        </trans-unit>
        <trans-unit id="2be91cd4a4fec9bf78dc3a63f6f2d68f35c2bdbd" translate="yes" xml:space="preserve">
          <source>An attempted implementation of a trait method has the wrong number of function parameters.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9d8894f1f89d7bc71fd853d9276ef9750108ee20" translate="yes" xml:space="preserve">
          <source>An attempted implementation of a trait method has the wrong number of type or const parameters.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="863f680a55f734bd0dbbca55a32cd8aa13a2d823" translate="yes" xml:space="preserve">
          <source>An attribute is either active or inert. During attribute processing, &lt;em&gt;active attributes&lt;/em&gt; remove themselves from the thing they are on while &lt;em&gt;inert attributes&lt;/em&gt; stay on.</source>
          <target state="translated">Атрибут может быть активным или инертным. Во время обработки атрибутов &lt;em&gt;активные атрибуты&lt;/em&gt; удаляются с того предмета, на котором они находятся, в то время как &lt;em&gt;инертные атрибуты&lt;/em&gt; остаются.</target>
        </trans-unit>
        <trans-unit id="de85bca69e396a8c71433fa18f072a410a4fc345" translate="yes" xml:space="preserve">
          <source>An auto trait was declared with a method or an associated item.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8f22761bfa3bdfb0003204a934bf1010c9716a93" translate="yes" xml:space="preserve">
          <source>An empty buffer returned indicates that the stream has reached EOF.</source>
          <target state="translated">Возвращаемый пустой буфер указывает на то,что поток достиг EOF.</target>
        </trans-unit>
        <trans-unit id="dc01027756efda949405e0e59c0d834ec342e061" translate="yes" xml:space="preserve">
          <source>An empty iterator returns &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">Пустой итератор возвращает &lt;code&gt;false&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="442cf9396651f26f54eeff92f4dde433d7f72454" translate="yes" xml:space="preserve">
          <source>An empty iterator returns &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">Пустой итератор возвращает &lt;code&gt;true&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e3ba001b1a53998b8d224cd77e4663359ef99e71" translate="yes" xml:space="preserve">
          <source>An empty iterator returns the one value of the type.</source>
          <target state="translated">Пустой итератор возвращает одно значение типа.</target>
        </trans-unit>
        <trans-unit id="54261d577d85895bf8c09d3febd150e6fae82418" translate="yes" xml:space="preserve">
          <source>An empty iterator returns the zero value of the type.</source>
          <target state="translated">Пустой итератор возвращает нулевое значение типа.</target>
        </trans-unit>
        <trans-unit id="b0823d0a93b876d1ef3cd6f73de147b3c9881c3f" translate="yes" xml:space="preserve">
          <source>An empty sequence is lexicographically less than any non-empty sequence.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="95f62854280c7cd5daf0c2b6b4a29d4a8c72ac30" translate="yes" xml:space="preserve">
          <source>An endpoint of a range of keys.</source>
          <target state="translated">Конечная точка из ряда клавиш.</target>
        </trans-unit>
        <trans-unit id="ee713135dbae7e11e49962ea65b30c33678861ed" translate="yes" xml:space="preserve">
          <source>An entity already exists, often a file.</source>
          <target state="translated">Сущность уже существует,часто это файл.</target>
        </trans-unit>
        <trans-unit id="2db4e2025a972767c9444bca8e88e9a77524203e" translate="yes" xml:space="preserve">
          <source>An entity was not found, often a file.</source>
          <target state="translated">Сущность не была найдена,часто это был файл.</target>
        </trans-unit>
        <trans-unit id="c5a4a196ff419cb4ace58ac8718f985652b454f9" translate="yes" xml:space="preserve">
          <source>An enum with the representation hint &lt;code&gt;repr(transparent)&lt;/code&gt; had zero or more than one variants.</source>
          <target state="translated">Перечисление с репрезентативной подсказкой &lt;code&gt;repr(transparent)&lt;/code&gt; имело ноль или более одного варианта.</target>
        </trans-unit>
        <trans-unit id="3dc999ff5594fd4673ff8dbd7678f9024bdecf27" translate="yes" xml:space="preserve">
          <source>An enumeration of possible errors associated with a &lt;a href=&quot;type.trylockresult&quot;&gt;&lt;code&gt;TryLockResult&lt;/code&gt;&lt;/a&gt; which can occur while trying to acquire a lock, from the &lt;a href=&quot;struct.mutex#method.try_lock&quot;&gt;&lt;code&gt;try_lock&lt;/code&gt;&lt;/a&gt; method on a &lt;a href=&quot;struct.mutex&quot;&gt;&lt;code&gt;Mutex&lt;/code&gt;&lt;/a&gt; or the &lt;a href=&quot;struct.rwlock#method.try_read&quot;&gt;&lt;code&gt;try_read&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;struct.rwlock#method.try_write&quot;&gt;&lt;code&gt;try_write&lt;/code&gt;&lt;/a&gt; methods on an &lt;a href=&quot;struct.rwlock&quot;&gt;&lt;code&gt;RwLock&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Перечень возможных ошибок , связанных с &lt;a href=&quot;type.trylockresult&quot;&gt; &lt;code&gt;TryLockResult&lt;/code&gt; &lt;/a&gt; , которые могут возникнуть при попытке получить блокировку, от &lt;a href=&quot;struct.mutex#method.try_lock&quot;&gt; &lt;code&gt;try_lock&lt;/code&gt; &lt;/a&gt; методы на &lt;a href=&quot;struct.mutex&quot;&gt; &lt;code&gt;Mutex&lt;/code&gt; &lt;/a&gt; или &lt;a href=&quot;struct.rwlock#method.try_read&quot;&gt; &lt;code&gt;try_read&lt;/code&gt; &lt;/a&gt; и &lt;a href=&quot;struct.rwlock#method.try_write&quot;&gt; &lt;code&gt;try_write&lt;/code&gt; &lt;/a&gt; методов на качестве &lt;a href=&quot;struct.rwlock&quot;&gt; &lt;code&gt;RwLock&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="09fd334e73fd76483600e0a3e0818465278a8c4f" translate="yes" xml:space="preserve">
          <source>An error indicating invalid UTF-8 when converting a &lt;a href=&quot;struct.cstring&quot;&gt;&lt;code&gt;CString&lt;/code&gt;&lt;/a&gt; into a &lt;a href=&quot;../string/struct.string&quot;&gt;&lt;code&gt;String&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Ошибка, указывающая на недопустимый UTF-8 при преобразовании &lt;a href=&quot;struct.cstring&quot;&gt; &lt;code&gt;CString&lt;/code&gt; &lt;/a&gt; в &lt;a href=&quot;../string/struct.string&quot;&gt; &lt;code&gt;String&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="7e00442ed63dafefaa24c2855dc12cc641d5d806" translate="yes" xml:space="preserve">
          <source>An error indicating that a nul byte was not in the expected position.</source>
          <target state="translated">Ошибка,указывающая на то,что нулевой байт не находился в ожидаемом положении.</target>
        </trans-unit>
        <trans-unit id="607c0a59f40344c6d402da3d92f1e4d75c5c8d03" translate="yes" xml:space="preserve">
          <source>An error indicating that an interior nul byte was found.</source>
          <target state="translated">Ошибка,указывающая на то,что был найден внутренний нуль-байт.</target>
        </trans-unit>
        <trans-unit id="2239ba3f9f1a9c04aabf258d44bc7c635e911959" translate="yes" xml:space="preserve">
          <source>An error of the &lt;a href=&quot;enum.errorkind#variant.Interrupted&quot;&gt;&lt;code&gt;ErrorKind::Interrupted&lt;/code&gt;&lt;/a&gt; kind is non-fatal and the read operation should be retried if there is nothing else to do.</source>
          <target state="translated">Ошибка типа &lt;a href=&quot;enum.errorkind#variant.Interrupted&quot;&gt; &lt;code&gt;ErrorKind::Interrupted&lt;/code&gt; &lt;/a&gt; является фатальной, и операцию чтения следует повторить, если больше нечего делать.</target>
        </trans-unit>
        <trans-unit id="ff800591cb202807f317ec28fbc572d02357615d" translate="yes" xml:space="preserve">
          <source>An error of the &lt;a href=&quot;enum.errorkind#variant.Interrupted&quot;&gt;&lt;code&gt;ErrorKind::Interrupted&lt;/code&gt;&lt;/a&gt; kind is non-fatal and the write operation should be retried if there is nothing else to do.</source>
          <target state="translated">Ошибка типа &lt;a href=&quot;enum.errorkind#variant.Interrupted&quot;&gt; &lt;code&gt;ErrorKind::Interrupted&lt;/code&gt; &lt;/a&gt; является фатальной, и операцию записи следует повторить, если больше нечего делать.</target>
        </trans-unit>
        <trans-unit id="597ff1fa4b12094e64ed86609fbee72af9e8d564" translate="yes" xml:space="preserve">
          <source>An error returned by &lt;a href=&quot;struct.bufwriter#method.into_inner&quot;&gt;&lt;code&gt;BufWriter::into_inner&lt;/code&gt;&lt;/a&gt; which combines an error that happened while writing out the buffer, and the buffered writer object which may be used to recover from the condition.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b6ad7c556d901c0beffc94b348b6d4d9e1e99f53" translate="yes" xml:space="preserve">
          <source>An error returned by &lt;a href=&quot;struct.localkey#method.try_with&quot;&gt;&lt;code&gt;LocalKey::try_with&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Ошибка, возвращаемая &lt;a href=&quot;struct.localkey#method.try_with&quot;&gt; &lt;code&gt;LocalKey::try_with&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="4a2bb23cc4bff912e225e8d82c808ebe1116d273" translate="yes" xml:space="preserve">
          <source>An error returned by &lt;a href=&quot;struct.refcell#method.try_borrow&quot;&gt;&lt;code&gt;RefCell::try_borrow&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Ошибка, возвращаемая &lt;a href=&quot;struct.refcell#method.try_borrow&quot;&gt; &lt;code&gt;RefCell::try_borrow&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="49b49c608a0a48a5c64a8db743785c3d4f2cbc87" translate="yes" xml:space="preserve">
          <source>An error returned by &lt;a href=&quot;struct.refcell#method.try_borrow_mut&quot;&gt;&lt;code&gt;RefCell::try_borrow_mut&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;struct.refcell#method.try_borrow_mut&quot;&gt; &lt;code&gt;RefCell::try_borrow_mut&lt;/code&gt; &lt;/a&gt; возвращает ошибку .</target>
        </trans-unit>
        <trans-unit id="6a9d323634dc21ac2ba61947c9f4ada5b0523975" translate="yes" xml:space="preserve">
          <source>An error returned by &lt;code&gt;into_inner&lt;/code&gt; which combines an error that happened while writing out the buffer, and the buffered writer object which may be used to recover from the condition.</source>
          <target state="translated">Ошибка, возвращаемая &lt;code&gt;into_inner&lt;/code&gt; , которая объединяет ошибку, произошедшую при записи буфера, и буферный объект записи, который можно использовать для восстановления из условия.</target>
        </trans-unit>
        <trans-unit id="408e9c71ed3bc2aa80ae9ddbf31a37ecbe128d0c" translate="yes" xml:space="preserve">
          <source>An error returned from &lt;a href=&quot;struct.path#method.strip_prefix&quot;&gt;&lt;code&gt;Path::strip_prefix&lt;/code&gt;&lt;/a&gt; if the prefix was not found.</source>
          <target state="translated">Ошибка возвращается из &lt;a href=&quot;struct.path#method.strip_prefix&quot;&gt; &lt;code&gt;Path::strip_prefix&lt;/code&gt; &lt;/a&gt; если префикс не был найден.</target>
        </trans-unit>
        <trans-unit id="788504f3aa85eadb6d0636b88bca37c397dba8e3" translate="yes" xml:space="preserve">
          <source>An error returned from the &lt;a href=&quot;struct.receiver#method.recv&quot;&gt;&lt;code&gt;recv&lt;/code&gt;&lt;/a&gt; function on a &lt;a href=&quot;struct.receiver&quot;&gt;&lt;code&gt;Receiver&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Ошибка, возвращенная функцией &lt;a href=&quot;struct.receiver#method.recv&quot;&gt; &lt;code&gt;recv&lt;/code&gt; &lt;/a&gt; на &lt;a href=&quot;struct.receiver&quot;&gt; &lt;code&gt;Receiver&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="9fec5ed88196e94f3e7939be6668b9ce8dfe54d0" translate="yes" xml:space="preserve">
          <source>An error returned from the &lt;a href=&quot;struct.sender#method.send&quot;&gt;&lt;code&gt;Sender::send&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;struct.syncsender#method.send&quot;&gt;&lt;code&gt;SyncSender::send&lt;/code&gt;&lt;/a&gt; function on &lt;strong&gt;channel&lt;/strong&gt;s.</source>
          <target state="translated">Ошибка, возвращенная функцией &lt;a href=&quot;struct.sender#method.send&quot;&gt; &lt;code&gt;Sender::send&lt;/code&gt; &lt;/a&gt; или &lt;a href=&quot;struct.syncsender#method.send&quot;&gt; &lt;code&gt;SyncSender::send&lt;/code&gt; &lt;/a&gt; на &lt;strong&gt;канале&lt;/strong&gt; s.</target>
        </trans-unit>
        <trans-unit id="b947bf8292263975edc2c833eac5521f6b3d5e94" translate="yes" xml:space="preserve">
          <source>An error returned from the &lt;code&gt;duration_since&lt;/code&gt; and &lt;code&gt;elapsed&lt;/code&gt; methods on &lt;code&gt;SystemTime&lt;/code&gt;, used to learn how far in the opposite direction a system time lies.</source>
          <target state="translated">Ошибка, возвращаемая методами &lt;code&gt;duration_since&lt;/code&gt; и &lt;code&gt;elapsed&lt;/code&gt; в &lt;code&gt;SystemTime&lt;/code&gt; , используется для определения того, как далеко в противоположном направлении лежит системное время.</target>
        </trans-unit>
        <trans-unit id="3cc3caad00d427c67aa297b2ffd580ffa8825463" translate="yes" xml:space="preserve">
          <source>An error returned when an operation could not be completed because a call to &lt;a href=&quot;trait.write#tymethod.write&quot;&gt;&lt;code&gt;write&lt;/code&gt;&lt;/a&gt; returned &lt;a href=&quot;../result/enum.result#variant.Ok&quot;&gt;&lt;code&gt;Ok(0)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f51f86543e577fd1d558ef170de94a1b52743f0b" translate="yes" xml:space="preserve">
          <source>An error returned when an operation could not be completed because a call to &lt;a href=&quot;trait.write#tymethod.write&quot;&gt;&lt;code&gt;write&lt;/code&gt;&lt;/a&gt; returned &lt;a href=&quot;type.result&quot;&gt;&lt;code&gt;Ok(0)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Ошибка возвращается, когда операция не может быть завершена, потому что вызов &lt;a href=&quot;trait.write#tymethod.write&quot;&gt; &lt;code&gt;write&lt;/code&gt; &lt;/a&gt; вернул &lt;a href=&quot;type.result&quot;&gt; &lt;code&gt;Ok(0)&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="b05482ca3068a6de89ef72655084867c49191841" translate="yes" xml:space="preserve">
          <source>An error returned when an operation could not be completed because an &quot;end of file&quot; was reached prematurely.</source>
          <target state="translated">Возвращается ошибка,когда операция не может быть завершена из-за преждевременного достижения &quot;конца файла&quot;.</target>
        </trans-unit>
        <trans-unit id="9c4fdb1f9f1ace5ab60797b01c282f3c5da7046e" translate="yes" xml:space="preserve">
          <source>An error returned when parsing a &lt;code&gt;bool&lt;/code&gt; using &lt;a href=&quot;../primitive.bool#method.from_str&quot;&gt;&lt;code&gt;from_str&lt;/code&gt;&lt;/a&gt; fails</source>
          <target state="translated">Ошибка возвращается при сбое синтаксического анализа &lt;code&gt;bool&lt;/code&gt; с помощью &lt;a href=&quot;../primitive.bool#method.from_str&quot;&gt; &lt;code&gt;from_str&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="b2cc322b72612b3329e40408b842ec85e5b854bf" translate="yes" xml:space="preserve">
          <source>An error returned when parsing a &lt;code&gt;bool&lt;/code&gt; using &lt;a href=&quot;trait.fromstr#tymethod.from_str&quot;&gt;&lt;code&gt;from_str&lt;/code&gt;&lt;/a&gt; fails</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="01956aad1d91d0a3eaa910ec372ba76608859bfc" translate="yes" xml:space="preserve">
          <source>An error that can be returned when decoding UTF-16 code points.</source>
          <target state="translated">Ошибка,которая может быть возвращена при декодировании кодовых точек UTF-16.</target>
        </trans-unit>
        <trans-unit id="3533bcb297f1b2a750fb10891e22e5dd49940449" translate="yes" xml:space="preserve">
          <source>An error when parsing a &lt;code&gt;String&lt;/code&gt;.</source>
          <target state="translated">Ошибка при разборе &lt;code&gt;String&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a8c4d17e195207f5a989ac26b5a78606dcbba09d" translate="yes" xml:space="preserve">
          <source>An error which can be returned when parsing a char.</source>
          <target state="translated">Ошибка,которая может быть возвращена при разборе символа char.</target>
        </trans-unit>
        <trans-unit id="6080f2ccd647721dacbdd21e9d94b2a3bec77e1f" translate="yes" xml:space="preserve">
          <source>An error which can be returned when parsing a float.</source>
          <target state="translated">Ошибка,которая может быть возвращена при разборе поплавка.</target>
        </trans-unit>
        <trans-unit id="8d76e3522dda33b8ed78bf99a4c5562182d54f08" translate="yes" xml:space="preserve">
          <source>An error which can be returned when parsing an IP address or a socket address.</source>
          <target state="translated">Ошибка,которая может быть возвращена при разборе IP-адреса или адреса сокета.</target>
        </trans-unit>
        <trans-unit id="c7b106b5fd117686f0aceb67097fd3cef2a189bf" translate="yes" xml:space="preserve">
          <source>An error which can be returned when parsing an integer.</source>
          <target state="translated">Ошибка,которая может быть возвращена при разборе целого числа.</target>
        </trans-unit>
        <trans-unit id="0c10923efe360df9a8a2484a223be28df23ba6ae" translate="yes" xml:space="preserve">
          <source>An evaluation of a trait requirement overflowed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1d7c5a9fd1d469b89a9d56899ca1f50026a1dd32" translate="yes" xml:space="preserve">
          <source>An example implementation for a domain in which two books are considered the same book if their ISBN matches, even if the formats differ:</source>
          <target state="translated">Пример реализации для домена,в котором две книги считаются одной и той же книгой,если их ISBN совпадает,даже если форматы отличаются:</target>
        </trans-unit>
        <trans-unit id="68ff7c567c0520a3da56cf3b0e9741fe24004f8f" translate="yes" xml:space="preserve">
          <source>An example implementation of the trait:</source>
          <target state="translated">Пример реализации этой черты:</target>
        </trans-unit>
        <trans-unit id="28b14342433cafd1cb0863789fedb01f7530bff9" translate="yes" xml:space="preserve">
          <source>An example is a generic struct holding a function pointer. In this case, the implementation of &lt;code&gt;Clone&lt;/code&gt; cannot be &lt;code&gt;derive&lt;/code&gt;d, but can be implemented as:</source>
          <target state="translated">Примером является универсальная структура, содержащая указатель на функцию. В этом случае реализация &lt;code&gt;Clone&lt;/code&gt; не может быть &lt;code&gt;derive&lt;/code&gt; , но может быть реализована как:</target>
        </trans-unit>
        <trans-unit id="da1a4e43cf80966a8d5beb99e7207867287f3da9" translate="yes" xml:space="preserve">
          <source>An example of &lt;code&gt;use&lt;/code&gt; declarations:</source>
          <target state="translated">Пример объявления &lt;code&gt;use&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="f512d81d83647ae47cd90bcb76d95f7b8768001b" translate="yes" xml:space="preserve">
          <source>An example of a &lt;code&gt;for&lt;/code&gt; loop over the contents of an array:</source>
          <target state="translated">Пример цикла &lt;code&gt;for&lt;/code&gt; по содержимому массива:</target>
        </trans-unit>
        <trans-unit id="fee9699f2c385a5203b6e01e13cf6011f2fcd8a4" translate="yes" xml:space="preserve">
          <source>An example of a &lt;code&gt;match&lt;/code&gt; expression:</source>
          <target state="translated">Пример &lt;code&gt;match&lt;/code&gt; выражение:</target>
        </trans-unit>
        <trans-unit id="cfd1afa80d53786d32ba47458c2ed4379f4003bf" translate="yes" xml:space="preserve">
          <source>An example of a &lt;code&gt;return&lt;/code&gt; expression:</source>
          <target state="translated">Пример &lt;code&gt;return&lt;/code&gt; выражения:</target>
        </trans-unit>
        <trans-unit id="9c5bf1e5202001a02f36098e504bd7cb0fe28030" translate="yes" xml:space="preserve">
          <source>An example of a &lt;code&gt;struct&lt;/code&gt; item and its use:</source>
          <target state="translated">Пример элемента &lt;code&gt;struct&lt;/code&gt; и его использования:</target>
        </trans-unit>
        <trans-unit id="3c2199ab0dce170bc0714704fc232fd68c69b281" translate="yes" xml:space="preserve">
          <source>An example of a &lt;em&gt;recursive&lt;/em&gt; type and its use:</source>
          <target state="translated">Пример &lt;em&gt;рекурсивного&lt;/em&gt; типа и его использования:</target>
        </trans-unit>
        <trans-unit id="0f62525fdcd99f7d466515d9585c0c13357e1b2b" translate="yes" xml:space="preserve">
          <source>An example of a common associated function is a &lt;code&gt;new&lt;/code&gt; function that returns a value of the type the associated function is associated with.</source>
          <target state="translated">Примером общей связанной функции является &lt;code&gt;new&lt;/code&gt; функция, которая возвращает значение типа, с которым связана связанная функция.</target>
        </trans-unit>
        <trans-unit id="6a351aa1ff4672ddb51a26e9d5f1e845614b350b" translate="yes" xml:space="preserve">
          <source>An example of a for loop over a series of integers:</source>
          <target state="translated">Пример цикла for для ряда целых чисел:</target>
        </trans-unit>
        <trans-unit id="9bcd2ce89adc17fbe7648c05a09884aa0d701978" translate="yes" xml:space="preserve">
          <source>An example of a module:</source>
          <target state="translated">Пример модуля:</target>
        </trans-unit>
        <trans-unit id="8e8435c013addb39ce3eb498c3c558d414e6f6ad" translate="yes" xml:space="preserve">
          <source>An example of a necessary use of parentheses is when calling a function pointer that is a member of a struct:</source>
          <target state="translated">Примером необходимого использования круглых скобок является вызов указателя функции,являющегося членом структуры:</target>
        </trans-unit>
        <trans-unit id="056ff1cdb43a917deab8c9dc0f118b2d9dd496e8" translate="yes" xml:space="preserve">
          <source>An example of a non-&lt;code&gt;Send&lt;/code&gt; type is the reference-counting pointer &lt;a href=&quot;../rc/struct.rc&quot;&gt;&lt;code&gt;rc::Rc&lt;/code&gt;&lt;/a&gt;. If two threads attempt to clone &lt;a href=&quot;../rc/struct.rc&quot;&gt;&lt;code&gt;Rc&lt;/code&gt;&lt;/a&gt;s that point to the same reference-counted value, they might try to update the reference count at the same time, which is &lt;a href=&quot;../../reference/behavior-considered-undefined&quot;&gt;undefined behavior&lt;/a&gt; because &lt;a href=&quot;../rc/struct.rc&quot;&gt;&lt;code&gt;Rc&lt;/code&gt;&lt;/a&gt; doesn't use atomic operations. Its cousin &lt;a href=&quot;../sync/struct.arc&quot;&gt;&lt;code&gt;sync::Arc&lt;/code&gt;&lt;/a&gt; does use atomic operations (incurring some overhead) and thus is &lt;code&gt;Send&lt;/code&gt;.</source>
          <target state="translated">Примером типа, отличного от &lt;code&gt;Send&lt;/code&gt; , является указатель подсчета ссылок &lt;a href=&quot;../rc/struct.rc&quot;&gt; &lt;code&gt;rc::Rc&lt;/code&gt; &lt;/a&gt; . Если два потока попытаются клонировать &lt;a href=&quot;../rc/struct.rc&quot;&gt; &lt;code&gt;Rc&lt;/code&gt; ,&lt;/a&gt; которые указывают на одно и то же значение с подсчетом ссылок, они могут попытаться обновить счетчик ссылок одновременно, что является &lt;a href=&quot;../../reference/behavior-considered-undefined&quot;&gt;неопределенным поведением,&lt;/a&gt; поскольку &lt;a href=&quot;../rc/struct.rc&quot;&gt; &lt;code&gt;Rc&lt;/code&gt; &lt;/a&gt; не использует атомарные операции. Его двоюродный брат &lt;a href=&quot;../sync/struct.arc&quot;&gt; &lt;code&gt;sync::Arc&lt;/code&gt; &lt;/a&gt; действительно использует атомарные операции (с некоторыми накладными расходами) и, следовательно, является &lt;code&gt;Send&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e38ec369f62f9a0e9cf71faa19b5cb843376b06e" translate="yes" xml:space="preserve">
          <source>An example of a parenthesized expression:</source>
          <target state="translated">Пример выражения в скобках:</target>
        </trans-unit>
        <trans-unit id="f06523b9f614521a822acb49c6502314b5223a29" translate="yes" xml:space="preserve">
          <source>An example of a trait object:</source>
          <target state="translated">Пример объекта черты:</target>
        </trans-unit>
        <trans-unit id="f97a42d4af253ea16c2f098f9cd1358538ff9ccc" translate="yes" xml:space="preserve">
          <source>An example of a trait that can&amp;rsquo;t be derived is &lt;code&gt;Display&lt;/code&gt;, which handles formatting for end users. You should always consider the appropriate way to display a type to an end user. What parts of the type should an end user be allowed to see? What parts would they find relevant? What format of the data would be most relevant to them? The Rust compiler doesn&amp;rsquo;t have this insight, so it can&amp;rsquo;t provide appropriate default behavior for you.</source>
          <target state="translated">Примером свойства, которое не может быть получено, является &lt;code&gt;Display&lt;/code&gt; , который обрабатывает форматирование для конечных пользователей. Вы всегда должны продумать подходящий способ отображения типа для конечного пользователя. Какие части шрифта должны быть разрешены для просмотра конечному пользователю? Какие части они сочтут актуальными? Какой формат данных будет для них наиболее актуален? Компилятор Rust не понимает этого, поэтому он не может предоставить вам подходящее поведение по умолчанию.</target>
        </trans-unit>
        <trans-unit id="b2a6dc626aff375aa4d434c66ea264d4dc08b800" translate="yes" xml:space="preserve">
          <source>An example of a trait whose methods are not object safe is the standard library&amp;rsquo;s &lt;code&gt;Clone&lt;/code&gt; trait. The signature for the &lt;code&gt;clone&lt;/code&gt; method in the &lt;code&gt;Clone&lt;/code&gt; trait looks like this:</source>
          <target state="translated">Примером трейта, методы которого не являются объектно-безопасными, является трейт &lt;code&gt;Clone&lt;/code&gt; стандартной библиотеки . Сигнатура метода &lt;code&gt;clone&lt;/code&gt; в &lt;code&gt;Clone&lt;/code&gt; выглядит так:</target>
        </trans-unit>
        <trans-unit id="5e81f6611106899f0be7f5a0792978a45ad55dd8" translate="yes" xml:space="preserve">
          <source>An example of a tuple type and its use:</source>
          <target state="translated">Пример типа кортежа и его использования:</target>
        </trans-unit>
        <trans-unit id="363c341cbe13044b212571253c8a33caae78cd45" translate="yes" xml:space="preserve">
          <source>An example of an &lt;code&gt;as&lt;/code&gt; expression:</source>
          <target state="translated">Пример выражения &lt;code&gt;as&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="a2db905e306fb4833044bdd9885bb27ab8f76d7f" translate="yes" xml:space="preserve">
          <source>An example of an &lt;code&gt;enum&lt;/code&gt; item and its use:</source>
          <target state="translated">Пример элемента &lt;code&gt;enum&lt;/code&gt; и его использования:</target>
        </trans-unit>
        <trans-unit id="9260a714aba6105dd14cba9d58f3d41f31de6503" translate="yes" xml:space="preserve">
          <source>An example of an empty type is &lt;code&gt;enum Empty { }&lt;/code&gt;. So, the following will work:</source>
          <target state="translated">Примером пустого типа является &lt;code&gt;enum Empty { }&lt;/code&gt; . Итак, будет работать следующее:</target>
        </trans-unit>
        <trans-unit id="ff969b10a01ab50464488192aa66638be2ebf171" translate="yes" xml:space="preserve">
          <source>An example of combining the above rules of &lt;code&gt;path&lt;/code&gt; attributes on inline modules and nested modules within (applies to both mod-rs and non-mod-rs files):</source>
          <target state="translated">Пример объединения вышеуказанных правил атрибутов &lt;code&gt;path&lt;/code&gt; во встроенных модулях и вложенных модулях внутри (применимо как к файлам mod-rs, так и к файлам non-mod-rs):</target>
        </trans-unit>
        <trans-unit id="6e09c1385fee93fd5fa2b4010458a4fc489b7a97" translate="yes" xml:space="preserve">
          <source>An example of implementing the formatting traits would look like:</source>
          <target state="translated">Пример реализации признаков форматирования будет выглядеть так:</target>
        </trans-unit>
        <trans-unit id="fa098562087edb062353d3aa89708207a19b395b" translate="yes" xml:space="preserve">
          <source>An example of matching non-exhaustively on the above enum is provided below:</source>
          <target state="translated">Ниже приведен пример неисключительного совпадения по приведенному выше перечню:</target>
        </trans-unit>
        <trans-unit id="7ef19768d994b2224d1f41bd49faef1709c5e7ef" translate="yes" xml:space="preserve">
          <source>An example of panic:</source>
          <target state="translated">Пример паники:</target>
        </trans-unit>
        <trans-unit id="884b0dfdd5d082bb94960ecce28dc9f3e6d384f8" translate="yes" xml:space="preserve">
          <source>An example of re-exporting:</source>
          <target state="translated">Пример реэкспорта:</target>
        </trans-unit>
        <trans-unit id="708c005211a8b1e93ec9aac2ad4a16e9c3bc2bc3" translate="yes" xml:space="preserve">
          <source>An example of this error:</source>
          <target state="translated">Пример этой ошибки:</target>
        </trans-unit>
        <trans-unit id="1d989db348ecf6096ab3ac95d001072dec12efa1" translate="yes" xml:space="preserve">
          <source>An example of this is when generating a new struct and an impl for it:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9b7f946fdd8d8a22da86833c61b5461d61a9c5be" translate="yes" xml:space="preserve">
          <source>An example of using tuple patterns:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="62347f606509b323a7de02a2bce976170f493c84" translate="yes" xml:space="preserve">
          <source>An example of what not to do and how this relates to &lt;code&gt;read_unaligned&lt;/code&gt; is:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6f16face177ebc3cd353bb963c0ea872b0ace950" translate="yes" xml:space="preserve">
          <source>An example of what not to do and how this relates to &lt;code&gt;write_unaligned&lt;/code&gt; is:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="64eb812bfe0819a20f7b7755d2742025cd360a65" translate="yes" xml:space="preserve">
          <source>An example of what will and will not work for &lt;code&gt;use&lt;/code&gt; items:</source>
          <target state="translated">Пример того, что будет и что не подойдет для &lt;code&gt;use&lt;/code&gt; предметов:</target>
        </trans-unit>
        <trans-unit id="8365f135946b3f7b044d8cfd3fa7997f776027f4" translate="yes" xml:space="preserve">
          <source>An example of when &lt;code&gt;Clone&lt;/code&gt; is required is when calling the &lt;code&gt;to_vec&lt;/code&gt; method on a slice. The slice doesn&amp;rsquo;t own the type instances it contains, but the vector returned from &lt;code&gt;to_vec&lt;/code&gt; will need to own its instances, so &lt;code&gt;to_vec&lt;/code&gt; calls &lt;code&gt;clone&lt;/code&gt; on each item. Thus, the type stored in the slice must implement &lt;code&gt;Clone&lt;/code&gt;.</source>
          <target state="translated">Примером того, когда требуется &lt;code&gt;Clone&lt;/code&gt; , является вызов метода &lt;code&gt;to_vec&lt;/code&gt; для среза. Срез не владеет экземплярами типов, которые он содержит, но вектор, возвращаемый из &lt;code&gt;to_vec&lt;/code&gt; , должен будет владеть своими экземплярами, поэтому &lt;code&gt;to_vec&lt;/code&gt; вызывает &lt;code&gt;clone&lt;/code&gt; для каждого элемента. Таким образом, тип, хранящийся в срезе, должен реализовывать &lt;code&gt;Clone&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="aaf3c4aa1a7d59f2304836782308596d0ae75f64" translate="yes" xml:space="preserve">
          <source>An example of when &lt;code&gt;Eq&lt;/code&gt; is required is for keys in a &lt;code&gt;HashMap&amp;lt;K, V&amp;gt;&lt;/code&gt; so the &lt;code&gt;HashMap&amp;lt;K, V&amp;gt;&lt;/code&gt; can tell whether two keys are the same.</source>
          <target state="translated">Примером того, когда требуется &lt;code&gt;Eq&lt;/code&gt; , являются ключи в &lt;code&gt;HashMap&amp;lt;K, V&amp;gt;&lt;/code&gt; поэтому &lt;code&gt;HashMap&amp;lt;K, V&amp;gt;&lt;/code&gt; может определить, являются ли два ключа одинаковыми.</target>
        </trans-unit>
        <trans-unit id="e410ff694a089e824c24843049bae108ce880220" translate="yes" xml:space="preserve">
          <source>An example of when &lt;code&gt;Hash&lt;/code&gt; is required is in storing keys in a &lt;code&gt;HashMap&amp;lt;K, V&amp;gt;&lt;/code&gt; to store data efficiently.</source>
          <target state="translated">Примером того, когда требуется &lt;code&gt;Hash&lt;/code&gt; , является хранение ключей в &lt;code&gt;HashMap&amp;lt;K, V&amp;gt;&lt;/code&gt; для эффективного хранения данных.</target>
        </trans-unit>
        <trans-unit id="13874d9be8af151d397c4923d18c3e3bb505d451" translate="yes" xml:space="preserve">
          <source>An example of when &lt;code&gt;Ord&lt;/code&gt; is required is when storing values in a &lt;code&gt;BTreeSet&amp;lt;T&amp;gt;&lt;/code&gt;, a data structure that stores data based on the sort order of the values.</source>
          <target state="translated">Примером того, когда требуется &lt;code&gt;Ord&lt;/code&gt; , является хранение значений в &lt;code&gt;BTreeSet&amp;lt;T&amp;gt;&lt;/code&gt; , структуре данных, в которой хранятся данные на основе порядка сортировки значений.</target>
        </trans-unit>
        <trans-unit id="309f6d59bf7b6968dcfb2187e53fc8e9c9c42a01" translate="yes" xml:space="preserve">
          <source>An example of when you might want to use an array rather than a vector is in a program that needs to know the names of the months of the year. It&amp;rsquo;s very unlikely that such a program will need to add or remove months, so you can use an array because you know it will always contain 12 elements:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f42b2c8e58eff03a7089947fa8ffae92137b9b5f" translate="yes" xml:space="preserve">
          <source>An example of when you might want to use an array rather than a vector is in a program that needs to know the names of the months of the year. It&amp;rsquo;s very unlikely that such a program will need to add or remove months, so you can use an array because you know it will always contain 12 items:</source>
          <target state="translated">Примером того, когда вы можете использовать массив, а не вектор, является программа, которой необходимо знать названия месяцев года. Очень маловероятно, что такой программе потребуется добавлять или удалять месяцы, поэтому вы можете использовать массив, потому что вы знаете, что он всегда будет содержать 12 элементов:</target>
        </trans-unit>
        <trans-unit id="bd0712d619a2d60e4c146e231ccdfbad8aba4743" translate="yes" xml:space="preserve">
          <source>An example of where you would want to only accept &lt;code&gt;fn&lt;/code&gt; and not closures is when interfacing with external code that doesn&amp;rsquo;t have closures: C functions can accept functions as arguments, but C doesn&amp;rsquo;t have closures.</source>
          <target state="translated">Примером того, где вы хотели бы принимать только &lt;code&gt;fn&lt;/code&gt; , а не замыкания, является взаимодействие с внешним кодом, который не имеет замыканий: функции C могут принимать функции в качестве аргументов, но C не имеет замыканий.</target>
        </trans-unit>
        <trans-unit id="e73f9f6c8b4fbcf9f4fd470408b5fff3f081d3b9" translate="yes" xml:space="preserve">
          <source>An example using a closure:</source>
          <target state="translated">Пример с закрытием:</target>
        </trans-unit>
        <trans-unit id="6d3969065ec2f88aef65174e1f6ffa620b0c83f2" translate="yes" xml:space="preserve">
          <source>An example where &lt;code&gt;Binop&lt;/code&gt; is defined as a function pointer type:</source>
          <target state="translated">Пример, в котором &lt;code&gt;Binop&lt;/code&gt; определяется как тип указателя на функцию:</target>
        </trans-unit>
        <trans-unit id="f481ad49809e7c27b79d2e6d830283b22c04c1f7" translate="yes" xml:space="preserve">
          <source>An example:</source>
          <target state="translated">Пример:</target>
        </trans-unit>
        <trans-unit id="9b338a4ae7f343a1618fa43d10bfc2df436ea62d" translate="yes" xml:space="preserve">
          <source>An exclusive bound.</source>
          <target state="translated">Эксклюзивное обязательство.</target>
        </trans-unit>
        <trans-unit id="0a0f5c759335e3ef134a90149eb082ea59cf661b" translate="yes" xml:space="preserve">
          <source>An executing Rust program consists of a collection of native OS threads, each with their own stack and local state. Threads can be named, and provide some built-in support for low-level synchronization.</source>
          <target state="translated">Выполняющаяся программа Rust состоит из коллекции нативных потоков ОС,каждый из которых имеет свой стек и локальное состояние.Потокам могут присваиваться имена,а также предоставляется некоторая встроенная поддержка низкоуровневой синхронизации.</target>
        </trans-unit>
        <trans-unit id="12c993ee363617797c480ae0e7fa61fa88f7540e" translate="yes" xml:space="preserve">
          <source>An explicit conversion from a &lt;code&gt;&amp;amp;str&lt;/code&gt; to a String is done as follows:</source>
          <target state="translated">Явное преобразование из &lt;code&gt;&amp;amp;str&lt;/code&gt; в String выполняется следующим образом:</target>
        </trans-unit>
        <trans-unit id="9863ad7a484538312614b219ee23d089bab88f2a" translate="yes" xml:space="preserve">
          <source>An expression enclosed in parentheses evaluates to the result of the enclosed expression. Parentheses can be used to explicitly specify evaluation order within an expression.</source>
          <target state="translated">Выражение,заключенное в круглые скобки,оценивает результат заключенного в скобки выражения.Круглые скобки могут быть использованы для явного указания порядка вычислений в выражении.</target>
        </trans-unit>
        <trans-unit id="b0b2d07f6ff343f37bbb2da0dbd07ed7ea53cb5d" translate="yes" xml:space="preserve">
          <source>An expression is a combination of values, constants, variables, operators and functions that evaluate to a single value, with or without side-effects.</source>
          <target state="translated">Выражение представляет собой комбинацию значений,констант,переменных,операторов и функций,которые оценивают до одного значения,с побочными эффектами или без них.</target>
        </trans-unit>
        <trans-unit id="8a470e20ec20f9f17fbbac4266c615aa43cc21c3" translate="yes" xml:space="preserve">
          <source>An expression may have two roles: it always produces a &lt;em&gt;value&lt;/em&gt;, and it may have &lt;em&gt;effects&lt;/em&gt; (otherwise known as &quot;side effects&quot;). An expression &lt;em&gt;evaluates to&lt;/em&gt; a value, and has effects during &lt;em&gt;evaluation&lt;/em&gt;. Many expressions contain sub-expressions (operands). The meaning of each kind of expression dictates several things:</source>
          <target state="translated">Выражение может иметь две роли: оно всегда производит &lt;em&gt;значение&lt;/em&gt; и может иметь &lt;em&gt;эффекты&lt;/em&gt; (также известные как &amp;laquo;побочные эффекты&amp;raquo;). Выражение &lt;em&gt;вычисляется&lt;/em&gt; как значение и оказывает влияние во время &lt;em&gt;вычисления&lt;/em&gt; . Многие выражения содержат подвыражения (операнды). Смысл каждого вида выражений определяет несколько вещей:</target>
        </trans-unit>
        <trans-unit id="894873bc5f587b4733b17f7dfb18b0f3059d2176" translate="yes" xml:space="preserve">
          <source>An expression that consists of only a &lt;a href=&quot;expressions/block-expr&quot;&gt;block expression&lt;/a&gt; or control flow expression, if used in a context where a statement is permitted, can omit the trailing semicolon. This can cause an ambiguity between it being parsed as a standalone statement and as a part of another expression; in this case, it is parsed as a statement. The type of &lt;a href=&quot;expressions&quot;&gt;&lt;em&gt;ExpressionWithBlock&lt;/em&gt;&lt;/a&gt; expressions when used as statements must be the unit type.</source>
          <target state="translated">Выражение, которое состоит только из &lt;a href=&quot;expressions/block-expr&quot;&gt;выражения блока&lt;/a&gt; или выражения потока управления, если оно используется в контексте, в котором разрешено выражение, может опускать конечную точку с запятой. Это может вызвать двусмысленность между его анализом как отдельным оператором и как частью другого выражения; в этом случае он анализируется как оператор. Тип &lt;a href=&quot;expressions&quot;&gt;&lt;em&gt;выражений ExpressionWithBlock&lt;/em&gt;&lt;/a&gt; при использовании в качестве операторов должен быть типом модуля.</target>
        </trans-unit>
        <trans-unit id="3db9b6e5300ec2a35e045cae789d7d65bc1644c2" translate="yes" xml:space="preserve">
          <source>An extension trait for concatenating slices</source>
          <target state="translated">Удлинительный признак для конкатенации ломтиков.</target>
        </trans-unit>
        <trans-unit id="12147a5a52fb5c2a1b9d7472abd1e716e6699134" translate="yes" xml:space="preserve">
          <source>An external crate dependency can be declared without binding its name in scope by using an underscore with the form &lt;code&gt;extern crate foo as _&lt;/code&gt;. This may be useful for crates that only need to be linked, but are never referenced, and will avoid being reported as unused.</source>
          <target state="translated">Зависимость внешнего ящика может быть объявлена ​​без привязки его имени к области видимости с помощью подчеркивания в форме &lt;code&gt;extern crate foo as _&lt;/code&gt; . Это может быть полезно для ящиков, которые нужно только связать, но на которые никогда не ссылаются, и позволит избежать сообщения о неиспользовании.</target>
        </trans-unit>
        <trans-unit id="af0969299b70206aefe5265b359a29ba784a7b81" translate="yes" xml:space="preserve">
          <source>An feature unstable in &lt;code&gt;const&lt;/code&gt; contexts was used.</source>
          <target state="translated">Использовалась функция, нестабильная в &lt;code&gt;const&lt;/code&gt; контекстах.</target>
        </trans-unit>
        <trans-unit id="67fba469014e18ca2e89e6de19c923fe7de4bee7" translate="yes" xml:space="preserve">
          <source>An identifier is any nonempty ASCII string of the following form:</source>
          <target state="translated">Идентификатором является любая непустая ASCII-строка следующей формы:</target>
        </trans-unit>
        <trans-unit id="c175628788a43110a89b193ae816462d4cf2d2a4" translate="yes" xml:space="preserve">
          <source>An identifier is bound more than once in a pattern.</source>
          <target state="translated">Идентификатор привязывается не один раз в шаблоне.</target>
        </trans-unit>
        <trans-unit id="b2a87fc4bed852d77bc4439f4f9b01dff5c6624b" translate="yes" xml:space="preserve">
          <source>An identifier that is neither defined nor a struct was used.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="804d52ee70392ba486d9daf55c4a0571322cd6a0" translate="yes" xml:space="preserve">
          <source>An identifier was used like a function name or a value was expected and the identifier exists but it belongs to a different namespace.</source>
          <target state="translated">Идентификатор используется как имя функции или ожидаемое значение,и идентификатор существует,но принадлежит другому пространству имён.</target>
        </trans-unit>
        <trans-unit id="21a7adea588a50a532e49278e2f1d4c02481c073" translate="yes" xml:space="preserve">
          <source>An identity function that &lt;em&gt;&lt;strong&gt;hints&lt;/strong&gt;&lt;/em&gt; to the compiler to be maximally pessimistic about what &lt;code&gt;black_box&lt;/code&gt; could do.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a9dd54d260c1e67a0aa0b597f6cdb8722318da30" translate="yes" xml:space="preserve">
          <source>An identity function.</source>
          <target state="translated">Функция идентификации.</target>
        </trans-unit>
        <trans-unit id="f4072cccbc13fd032256ab05516201c0d8df3e68" translate="yes" xml:space="preserve">
          <source>An if-let pattern attempts to match the pattern, and enters the body if the match was successful. If the match is irrefutable (when it cannot fail to match), use a regular &lt;code&gt;let&lt;/code&gt;-binding instead. For instance:</source>
          <target state="translated">Шаблон if-let пытается сопоставить шаблон и входит в тело, если сопоставление было успешным. Если совпадение неопровержимо (когда оно не может не совпадать), используйте вместо этого обычное &lt;code&gt;let&lt;/code&gt; - связывание. Например:</target>
        </trans-unit>
        <trans-unit id="a0284d91e655684ff663495c42199a2c25a3b7b6" translate="yes" xml:space="preserve">
          <source>An immutable variable was reassigned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4ba45e243c916e58a2890a2d541b968fddd22dd8" translate="yes" xml:space="preserve">
          <source>An implementation can take type and lifetime parameters, which can be used in the rest of the implementation. Type parameters declared for an implementation must be used at least once in either the trait or the implementing type of an implementation. Implementation parameters are written directly after the &lt;code&gt;impl&lt;/code&gt; keyword.</source>
          <target state="translated">Реализация может принимать параметры типа и времени жизни, которые могут использоваться в остальной части реализации. Параметры типа, объявленные для реализации, должны использоваться по крайней мере один раз либо в признаке, либо в типе реализации реализации. Параметры реализации записываются сразу после &lt;code&gt;impl&lt;/code&gt; слова impl .</target>
        </trans-unit>
        <trans-unit id="7debed941ec31b919fee56e16fed7f3d43603fb5" translate="yes" xml:space="preserve">
          <source>An implementation cannot be chosen unambiguously because of lack of information.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5c1c04198ba70d5ee214d020749cca1de7fc7d00" translate="yes" xml:space="preserve">
          <source>An implementation of &lt;code&gt;Alloc&lt;/code&gt; can allocate, reallocate, and deallocate arbitrary blocks of data described via &lt;code&gt;Layout&lt;/code&gt;.</source>
          <target state="translated">Реализация &lt;code&gt;Alloc&lt;/code&gt; может выделять, перераспределять и освобождать произвольные блоки данных, описанные с помощью &lt;code&gt;Layout&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="da7ec04c76427d5dd969fd2e136866257e58eb1e" translate="yes" xml:space="preserve">
          <source>An implementation of &lt;code&gt;AllocRef&lt;/code&gt; can allocate, grow, shrink, and deallocate arbitrary blocks of data described via &lt;a href=&quot;struct.layout&quot;&gt;&lt;code&gt;Layout&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="baf455213042b2250778e00516f43e9464f4756f" translate="yes" xml:space="preserve">
          <source>An implementation of &lt;code&gt;Allocator&lt;/code&gt; can allocate, grow, shrink, and deallocate arbitrary blocks of data described via &lt;a href=&quot;struct.layout&quot;&gt;&lt;code&gt;Layout&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="99623634884bf4add6cdc497873712ce416c8fd4" translate="yes" xml:space="preserve">
          <source>An implementation of &lt;code&gt;BitAnd&lt;/code&gt; for a wrapper around &lt;code&gt;Vec&amp;lt;bool&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">Реализация &lt;code&gt;BitAnd&lt;/code&gt; для оболочки вокруг &lt;code&gt;Vec&amp;lt;bool&amp;gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0e2ff6912f2ce30546aa9104a9c9d196708332bf" translate="yes" xml:space="preserve">
          <source>An implementation of &lt;code&gt;BitAnd&lt;/code&gt; for a wrapper around &lt;code&gt;bool&lt;/code&gt;.</source>
          <target state="translated">Реализация &lt;code&gt;BitAnd&lt;/code&gt; для оболочки вокруг &lt;code&gt;bool&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5f6dfa411cba86305e5e9cd742f9f63d63776e67" translate="yes" xml:space="preserve">
          <source>An implementation of &lt;code&gt;BitAndAssign&lt;/code&gt; that lifts the &lt;code&gt;&amp;amp;=&lt;/code&gt; operator to a wrapper around &lt;code&gt;bool&lt;/code&gt;.</source>
          <target state="translated">Реализация &lt;code&gt;BitAndAssign&lt;/code&gt; , которая переводит оператор &lt;code&gt;&amp;amp;=&lt;/code&gt; в оболочку вокруг &lt;code&gt;bool&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b3e86b6af5dd68737dcc690c4ff3a487a1934868" translate="yes" xml:space="preserve">
          <source>An implementation of &lt;code&gt;BitOr&lt;/code&gt; for a wrapper around &lt;code&gt;Vec&amp;lt;bool&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">Реализация &lt;code&gt;BitOr&lt;/code&gt; для оболочки вокруг &lt;code&gt;Vec&amp;lt;bool&amp;gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e8149ba6d1631c707939091192745b37494deb7b" translate="yes" xml:space="preserve">
          <source>An implementation of &lt;code&gt;BitOr&lt;/code&gt; for a wrapper around &lt;code&gt;bool&lt;/code&gt;.</source>
          <target state="translated">Реализация &lt;code&gt;BitOr&lt;/code&gt; для оболочки вокруг &lt;code&gt;bool&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ce43f6aba41bb7af32e0d6e55432c6b3ca8d7e1a" translate="yes" xml:space="preserve">
          <source>An implementation of &lt;code&gt;BitXor&lt;/code&gt; that lifts &lt;code&gt;^&lt;/code&gt; to a wrapper around &lt;code&gt;bool&lt;/code&gt;.</source>
          <target state="translated">Реализация &lt;code&gt;BitXor&lt;/code&gt; , которая переводит &lt;code&gt;^&lt;/code&gt; в оболочку вокруг &lt;code&gt;bool&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="65cb4db18d08218407844613de42d9029080f521" translate="yes" xml:space="preserve">
          <source>An implementation of &lt;code&gt;BitXor&lt;/code&gt; trait for a wrapper around &lt;code&gt;Vec&amp;lt;bool&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">Реализация трейта &lt;code&gt;BitXor&lt;/code&gt; для оболочки вокруг &lt;code&gt;Vec&amp;lt;bool&amp;gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b5b904d460aff616075d9ff33295d995d4012b99" translate="yes" xml:space="preserve">
          <source>An implementation of &lt;code&gt;Neg&lt;/code&gt; for &lt;code&gt;Sign&lt;/code&gt;, which allows the use of &lt;code&gt;-&lt;/code&gt; to negate its value.</source>
          <target state="translated">Реализация &lt;code&gt;Neg&lt;/code&gt; для &lt;code&gt;Sign&lt;/code&gt; , которая позволяет использовать &lt;code&gt;-&lt;/code&gt; для отрицания его значения.</target>
        </trans-unit>
        <trans-unit id="873b42d4cd981f821fbfc718a707b146669b45da" translate="yes" xml:space="preserve">
          <source>An implementation of &lt;code&gt;Not&lt;/code&gt; for &lt;code&gt;Answer&lt;/code&gt;, which enables the use of &lt;code&gt;!&lt;/code&gt; to invert its value.</source>
          <target state="translated">Реализация &lt;code&gt;Not&lt;/code&gt; for &lt;code&gt;Answer&lt;/code&gt; , которая позволяет использовать &lt;code&gt;!&lt;/code&gt; инвертировать его значение.</target>
        </trans-unit>
        <trans-unit id="b6ef2365698efd5099fd68eb5d996513953b40b7" translate="yes" xml:space="preserve">
          <source>An implementation of &lt;code&gt;Shl&lt;/code&gt; that lifts the &lt;code&gt;&amp;lt;&amp;lt;&lt;/code&gt; operation on integers to a wrapper around &lt;code&gt;usize&lt;/code&gt;.</source>
          <target state="translated">Реализация &lt;code&gt;Shl&lt;/code&gt; , поднимающая &lt;code&gt;&amp;lt;&amp;lt;&lt;/code&gt; операции на целых к обертке вокруг &lt;code&gt;usize&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8e679f132f9bdc673ab7525c566b308cef626454" translate="yes" xml:space="preserve">
          <source>An implementation of &lt;code&gt;Shl&lt;/code&gt; that spins a vector leftward by a given amount.</source>
          <target state="translated">Реализация &lt;code&gt;Shl&lt;/code&gt; , которая вращает вектор влево на заданную величину.</target>
        </trans-unit>
        <trans-unit id="4b9ea2f9d110fb7b7d2e508e8eb895f2a6c76af4" translate="yes" xml:space="preserve">
          <source>An implementation of &lt;code&gt;ShlAssign&lt;/code&gt; for a wrapper around &lt;code&gt;usize&lt;/code&gt;.</source>
          <target state="translated">Реализация &lt;code&gt;ShlAssign&lt;/code&gt; для оболочки вокруг &lt;code&gt;usize&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="fdc99f650e402a714069613aef9bb0ab1a03fe00" translate="yes" xml:space="preserve">
          <source>An implementation of &lt;code&gt;Shr&lt;/code&gt; that lifts the &lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt; operation on integers to a wrapper around &lt;code&gt;usize&lt;/code&gt;.</source>
          <target state="translated">Реализация &lt;code&gt;Shr&lt;/code&gt; , которая переводит операцию &lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt; над целыми числами в оболочку вокруг &lt;code&gt;usize&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="00b6c1f0f935bcc3f078a1d4c1fb779815701d8c" translate="yes" xml:space="preserve">
          <source>An implementation of &lt;code&gt;Shr&lt;/code&gt; that spins a vector rightward by a given amount.</source>
          <target state="translated">Реализация &lt;code&gt;Shr&lt;/code&gt; , которая вращает вектор вправо на заданную величину.</target>
        </trans-unit>
        <trans-unit id="fef3f9c26a074ccf18bb7e56e8695a2a73f26459" translate="yes" xml:space="preserve">
          <source>An implementation of &lt;code&gt;ShrAssign&lt;/code&gt; for a wrapper around &lt;code&gt;usize&lt;/code&gt;.</source>
          <target state="translated">Реализация &lt;code&gt;ShrAssign&lt;/code&gt; для оболочки вокруг &lt;code&gt;usize&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f0109084bf6e2896150bb542f8a8637f2cff32f1" translate="yes" xml:space="preserve">
          <source>An implementation of &lt;code&gt;poll&lt;/code&gt; should strive to return quickly, and should not block. Returning quickly prevents unnecessarily clogging up threads or event loops. If it is known ahead of time that a call to &lt;code&gt;poll&lt;/code&gt; may end up taking awhile, the work should be offloaded to a thread pool (or something similar) to ensure that &lt;code&gt;poll&lt;/code&gt; can return quickly.</source>
          <target state="translated">Реализация &lt;code&gt;poll&lt;/code&gt; должна стремиться к быстрому возврату и не должна блокировать. Быстрый возврат предотвращает ненужное засорение потоков или циклов событий. Если заранее известно, что вызов &lt;code&gt;poll&lt;/code&gt; может занять некоторое время, работа должна быть перенесена в пул потоков (или что-то подобное), чтобы обеспечить быстрое возвращение &lt;code&gt;poll&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="350059cec8495b6fd084c91dd06a8c1a8c6277a2" translate="yes" xml:space="preserve">
          <source>An implementation of SipHash 2-4.</source>
          <target state="translated">Внедрение SipHash 2-4.</target>
        </trans-unit>
        <trans-unit id="8a3dd636510b68fa6befc892111d7637911e62f8" translate="yes" xml:space="preserve">
          <source>An implementation of a trait doesn't match the type constraint.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a7c410f2271131f6e26f4c1a6c01fb2def54994c" translate="yes" xml:space="preserve">
          <source>An import was unresolved.</source>
          <target state="translated">Импорт не был решен.</target>
        </trans-unit>
        <trans-unit id="29610251a6990ca267c18a3b17be65ef65d80c1f" translate="yes" xml:space="preserve">
          <source>An important part of the process of learning Rust is learning how to read the error messages the compiler displays: these will guide you toward working code. As such, we&amp;rsquo;ll provide many examples that don&amp;rsquo;t compile along with the error message the compiler will show you in each situation. Know that if you enter and run a random example, it may not compile! Make sure you read the surrounding text to see whether the example you&amp;rsquo;re trying to run is meant to error. Ferris will also help you distinguish code that isn&amp;rsquo;t meant to work:</source>
          <target state="translated">Важная часть процесса изучения Rust - это научиться читать сообщения об ошибках, отображаемые компилятором: они помогут вам в работе над кодом. Таким образом, мы предоставим много примеров, которые не компилируются, вместе с сообщением об ошибке, которое компилятор будет показывать вам в каждой ситуации. Знайте, что если вы введете и запустите случайный пример, он может не компилироваться! Убедитесь, что вы прочитали окружающий текст, чтобы убедиться, что пример, который вы пытаетесь запустить, является ошибочным. Феррис также поможет вам отличить код, который не предназначен для работы:</target>
        </trans-unit>
        <trans-unit id="9068331ccd5e98287382db124205efdfb79f7cfb" translate="yes" xml:space="preserve">
          <source>An important thing to remember is that the type &lt;code&gt;fmt::Error&lt;/code&gt; should not be confused with &lt;a href=&quot;../io/struct.error&quot;&gt;&lt;code&gt;std::io::Error&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;../error/trait.error&quot;&gt;&lt;code&gt;std::error::Error&lt;/code&gt;&lt;/a&gt;, which you may also have in scope.</source>
          <target state="translated">Важно помнить, что тип &lt;code&gt;fmt::Error&lt;/code&gt; не следует путать с &lt;a href=&quot;../io/struct.error&quot;&gt; &lt;code&gt;std::io::Error&lt;/code&gt; &lt;/a&gt; или &lt;a href=&quot;../error/trait.error&quot;&gt; &lt;code&gt;std::error::Error&lt;/code&gt; &lt;/a&gt; , которые также могут быть в области видимости.</target>
        </trans-unit>
        <trans-unit id="8f9e81cf6c354fdfd3e66804e1f412009da97856" translate="yes" xml:space="preserve">
          <source>An inclusive bound.</source>
          <target state="translated">Исключительное обязательство.</target>
        </trans-unit>
        <trans-unit id="192433a73b5ee226652b56c2bf60e3939daf0558" translate="yes" xml:space="preserve">
          <source>An inclusive range needs an end in order to &lt;em&gt;include&lt;/em&gt; it. If you just need a start and no end, use a non-inclusive range (with &lt;code&gt;..&lt;/code&gt;):</source>
          <target state="translated">Инклюзивный диапазон должен иметь конец, чтобы &lt;em&gt;включать&lt;/em&gt; его. Если вам просто нужно начало, а не конец, используйте неисключительный диапазон (с &lt;code&gt;..&lt;/code&gt; ):</target>
        </trans-unit>
        <trans-unit id="50920c083a024a331ce9d74584285d9788301b90" translate="yes" xml:space="preserve">
          <source>An inclusive range was used with no end.</source>
          <target state="translated">Использовался всеохватывающий диапазон без конца.</target>
        </trans-unit>
        <trans-unit id="387b0473c559329b38860546da1e2cce85651e8f" translate="yes" xml:space="preserve">
          <source>An incompatible cast was attempted.</source>
          <target state="translated">Была предпринята попытка несовместимого гипса.</target>
        </trans-unit>
        <trans-unit id="890a9e60cf506bc22c185b6e6eaa04f58d616d41" translate="yes" xml:space="preserve">
          <source>An incorrect number of generic arguments were provided.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3ffd66f253621f41011842348ba63bd0896ca4ec" translate="yes" xml:space="preserve">
          <source>An incorrect visibility restriction was specified.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c9900f693c2e1b5744366ed3318b36a718fcf770" translate="yes" xml:space="preserve">
          <source>An infinite endpoint. Indicates that there is no bound in this direction.</source>
          <target state="translated">Бесконечная конечная точка.Указывает на то,что в этом направлении нет границы.</target>
        </trans-unit>
        <trans-unit id="f2f7f4bb84396a832ec236ff6b02e7c811f6141c" translate="yes" xml:space="preserve">
          <source>An inherent implementation is defined as the sequence of the &lt;code&gt;impl&lt;/code&gt; keyword, generic type declarations, a path to a nominal type, a where clause, and a bracketed set of associable items.</source>
          <target state="translated">Внутренняя реализация определяется как последовательность &lt;code&gt;impl&lt;/code&gt; слова impl , объявлений универсального типа, пути к номинальному типу, предложения where и заключенного в скобки набора связанных элементов.</target>
        </trans-unit>
        <trans-unit id="5e6c6207529ca7e8b2b41ce66b1a1399c7520ae8" translate="yes" xml:space="preserve">
          <source>An inherent implementation was defined for a type outside the current crate.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="506894b4a872753e6bf88eaab162c1ca6bc0d7d6" translate="yes" xml:space="preserve">
          <source>An inherent implementation was defined for something which isn't a struct, enum, union, or trait object.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="110853947b6a8113db0327e6e5f3081c7c63d981" translate="yes" xml:space="preserve">
          <source>An inherent implementation was marked unsafe.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cb3f4eca6453d0b265cd70c611dfbbd1e320cc15" translate="yes" xml:space="preserve">
          <source>An inner doc comment was used in an invalid context.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eaca7587ab66134ebcc5c9d98dddc7a6d1b623fb" translate="yes" xml:space="preserve">
          <source>An instance of &lt;code&gt;DirEntry&lt;/code&gt; represents an entry inside of a directory on the filesystem. Each entry can be inspected via methods to learn about the full path or possibly other metadata through per-platform extension traits.</source>
          <target state="translated">Экземпляр &lt;code&gt;DirEntry&lt;/code&gt; представляет собой запись внутри каталога файловой системы. Каждую запись можно проверить с помощью методов, чтобы узнать полный путь или, возможно, другие метаданные с помощью признаков расширения для каждой платформы.</target>
        </trans-unit>
        <trans-unit id="1fbc585e6de8e6bcaf356cf9f8023d57041f924e" translate="yes" xml:space="preserve">
          <source>An instance of &lt;code&gt;Layout&lt;/code&gt; describes a particular layout of memory. You build a &lt;code&gt;Layout&lt;/code&gt; up as an input to give to an allocator.</source>
          <target state="translated">Экземпляр &lt;code&gt;Layout&lt;/code&gt; описывает конкретный макет памяти. Вы создаете &lt;code&gt;Layout&lt;/code&gt; как вход для распределителя.</target>
        </trans-unit>
        <trans-unit id="b190fdcf2cbfcbc1313cacaba62570eb78c828a4" translate="yes" xml:space="preserve">
          <source>An instance of a &lt;code&gt;File&lt;/code&gt; can be read and/or written depending on what options it was opened with. Files also implement &lt;a href=&quot;../io/trait.seek&quot;&gt;&lt;code&gt;Seek&lt;/code&gt;&lt;/a&gt; to alter the logical cursor that the file contains internally.</source>
          <target state="translated">Экземпляр &lt;code&gt;File&lt;/code&gt; можно читать и / или записывать в зависимости от того, с какими параметрами он был открыт. Файлы также реализуют &lt;a href=&quot;../io/trait.seek&quot;&gt; &lt;code&gt;Seek&lt;/code&gt; &lt;/a&gt; для изменения логического курсора, который файл содержит внутри.</target>
        </trans-unit>
        <trans-unit id="4022f91af4f41ee796badb832f4f942b0dd3666a" translate="yes" xml:space="preserve">
          <source>An integer (&lt;code&gt;i*&lt;/code&gt;/&lt;code&gt;u*&lt;/code&gt;), floating point value (&lt;code&gt;f*&lt;/code&gt;), or raw pointer obtained from &lt;a href=&quot;http://llvm.org/docs/LangRef.html#undefined-values&quot;&gt;uninitialized memory&lt;/a&gt;, or uninitialized memory in a &lt;code&gt;str&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="633635f22724539e9ddd7e7cb1e102a34d52eb44" translate="yes" xml:space="preserve">
          <source>An integer (&lt;code&gt;i*&lt;/code&gt;/&lt;code&gt;u*&lt;/code&gt;), floating point value (&lt;code&gt;f*&lt;/code&gt;), or raw pointer obtained from &lt;a href=&quot;https://llvm.org/docs/LangRef.html#undefined-values&quot;&gt;uninitialized memory&lt;/a&gt;, or uninitialized memory in a &lt;code&gt;str&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f4459da0411b29eac8078029351bbb76f00d3282" translate="yes" xml:space="preserve">
          <source>An integer &lt;code&gt;.N&lt;/code&gt;:</source>
          <target state="translated">Целое число &lt;code&gt;.N&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="908da2eafc06fe6ced0bd1b3ca560bd9a2e72aa4" translate="yes" xml:space="preserve">
          <source>An integer or name followed by dollar sign &lt;code&gt;.N$&lt;/code&gt;:</source>
          <target state="translated">Целое число или имя, за которым следует знак доллара &lt;code&gt;.N$&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="d652b1aec455b9a1399356989d1b6e7890b6c2cf" translate="yes" xml:space="preserve">
          <source>An integer that is known not to equal zero.</source>
          <target state="translated">Целое число,которое,как известно,не равно нулю.</target>
        </trans-unit>
        <trans-unit id="23e972eabcd349c601672f385dadf7a600ee560a" translate="yes" xml:space="preserve">
          <source>An integer type which can be safely shared between threads.</source>
          <target state="translated">Целый тип,который можно безопасно разделить между потоками.</target>
        </trans-unit>
        <trans-unit id="7738cea88357f8684a294b13f985119f27bc796a" translate="yes" xml:space="preserve">
          <source>An intensity number from the user, which is specified when they request a workout to indicate whether they want a low-intensity workout or a high-intensity workout</source>
          <target state="translated">Число интенсивности от пользователя,которое указывается,когда он запрашивает тренировку,чтобы указать,хочет ли он тренироваться с низкой или высокой интенсивностью.</target>
        </trans-unit>
        <trans-unit id="ff8d693a0bfcced7e1e8e51c1bf01052178e048b" translate="yes" xml:space="preserve">
          <source>An interface for dealing with iterators.</source>
          <target state="translated">Интерфейс для работы с итераторами.</target>
        </trans-unit>
        <trans-unit id="22e5648e52f9b0472e117269511bde8fb3cbbf6f" translate="yes" xml:space="preserve">
          <source>An internet socket address, either IPv4 or IPv6.</source>
          <target state="translated">Адрес интернет-сокета,либо IPv4,либо IPv6.</target>
        </trans-unit>
        <trans-unit id="854d43a414a4b60a4e76077619d9f002787508df" translate="yes" xml:space="preserve">
          <source>An intrinsic is a function available for use in a given programming language whose implementation is handled specially by the compiler. In order to fix this error, just declare a function.</source>
          <target state="translated">Имманентная функция-это функция,доступная для использования на данном языке программирования,реализация которой специально обрабатывается компилятором.Чтобы исправить эту ошибку,достаточно объявить функцию.</target>
        </trans-unit>
        <trans-unit id="0e442cff22b27f71ce2c2ce15532cf3a41eb6841" translate="yes" xml:space="preserve">
          <source>An intrinsic is a function available for use in a given programming language whose implementation is handled specially by the compiler. In order to fix this error, just declare a function. Example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d4ed3f185066b7aaf4eec2eeca59086039ee692c" translate="yes" xml:space="preserve">
          <source>An intrinsic was declared without being a function.</source>
          <target state="translated">Внутренняя составляющая была объявлена,не являясь функцией.</target>
        </trans-unit>
        <trans-unit id="4c83eebd7c224b0a142aede3c5ec04a66d472405" translate="yes" xml:space="preserve">
          <source>An invalid &lt;code&gt;self&lt;/code&gt; import was made.</source>
          <target state="translated">Произведен недопустимый &lt;code&gt;self&lt;/code&gt; импорт.</target>
        </trans-unit>
        <trans-unit id="82555301e5ea450f3a2a3340087105706f32de3a" translate="yes" xml:space="preserve">
          <source>An invalid cast was attempted.</source>
          <target state="translated">Была предпринята попытка создания недействительного гипса.</target>
        </trans-unit>
        <trans-unit id="03180be565388e3e9bc81cc13b92d02f2dbb9f6d" translate="yes" xml:space="preserve">
          <source>An invalid input operand constraint was passed to the &lt;code&gt;llvm_asm&lt;/code&gt; macro (third line).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8c5bb35712d552d14538dee6299b1809a75931fc" translate="yes" xml:space="preserve">
          <source>An invalid left-hand side expression was used on an assignment operation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9a8cc59d01bca4002162d9e4ee195fba0f67e5eb" translate="yes" xml:space="preserve">
          <source>An invalid lint attribute has been given.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b45ca9e360736d39967051ef73e9a974697dc538" translate="yes" xml:space="preserve">
          <source>An invalid lint attribute has been given. Erroneous code example:</source>
          <target state="translated">Был дан недействительный атрибут ворсинок.Пример ошибочного кода:</target>
        </trans-unit>
        <trans-unit id="7afc8f120588eda0a5e01c8b52b3b7d783b74baf" translate="yes" xml:space="preserve">
          <source>An invalid meta-item was used inside an attribute.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="381c4fb826f13d2ae3a70efbf639e550ce3d899e" translate="yes" xml:space="preserve">
          <source>An invalid name was used for a lifetime parameter.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ca168fbcb5da1644a515cf8441248863a3fd9251" translate="yes" xml:space="preserve">
          <source>An invalid number of arguments was given when calling a closure.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7d49fec3c8ae574bb2ce4cd00863f78f3ce2c2fa" translate="yes" xml:space="preserve">
          <source>An invalid number of arguments was passed when calling a function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fd1272a4d79b74d35bfe264d5c84667b1b0428f6" translate="yes" xml:space="preserve">
          <source>An invalid number of type parameters was given to an intrinsic function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cc8a5020b458d81f8e941d19c95ab2d679341b81" translate="yes" xml:space="preserve">
          <source>An invalid syntax was passed to the second argument of an &lt;code&gt;llvm_asm&lt;/code&gt; macro line.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a410192aae8c1c9efe2c778af8302870ee71f57b" translate="yes" xml:space="preserve">
          <source>An item usage is ambiguous.</source>
          <target state="translated">Использование предмета неоднозначно.</target>
        </trans-unit>
        <trans-unit id="b5e68274b8d847f0c6926331f1e39e6fca71b9fd" translate="yes" xml:space="preserve">
          <source>An item was added on a negative impl.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a6cc9e350b081b1e617d64ca09e5f7073fb94361" translate="yes" xml:space="preserve">
          <source>An item which isn't a unit struct, a variant, nor a constant has been used as a match pattern.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b44509fac7828279e76e0b5a94ab5171cb157956" translate="yes" xml:space="preserve">
          <source>An iterator able to yield elements from both ends.</source>
          <target state="translated">Итератор способен выдавать элементы с обоих концов.</target>
        </trans-unit>
        <trans-unit id="a79f20c0e35d15b48bb2797970d35b63c3629a31" translate="yes" xml:space="preserve">
          <source>An iterator adaptor similar to &lt;a href=&quot;#method.fold&quot;&gt;&lt;code&gt;fold&lt;/code&gt;&lt;/a&gt; that holds internal state and produces a new iterator.</source>
          <target state="translated">Адаптер итератора, похожий на &lt;a href=&quot;#method.fold&quot;&gt; &lt;code&gt;fold&lt;/code&gt; ,&lt;/a&gt; который хранит внутреннее состояние и создает новый итератор.</target>
        </trans-unit>
        <trans-unit id="2e43d9b7345ad03f5ced2dcd31e711c42d237584" translate="yes" xml:space="preserve">
          <source>An iterator adaptor similar to &lt;a href=&quot;../../../iter/trait.iterator#method.fold&quot;&gt;&lt;code&gt;fold&lt;/code&gt;&lt;/a&gt; that holds internal state and produces a new iterator. &lt;a href=&quot;../../../iter/trait.iterator#method.scan&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="773601e7cb6c7b2cb91410d40c83395d2f5a2aba" translate="yes" xml:space="preserve">
          <source>An iterator adaptor similar to &lt;a href=&quot;../../iter/trait.iterator#method.fold&quot;&gt;&lt;code&gt;fold&lt;/code&gt;&lt;/a&gt; that holds internal state and produces a new iterator. &lt;a href=&quot;../../iter/trait.iterator#method.scan&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e8c9fb31213d58aac0ffdd0c9178139dd13dff6e" translate="yes" xml:space="preserve">
          <source>An iterator adaptor similar to &lt;a href=&quot;../iter/trait.iterator#method.fold&quot;&gt;&lt;code&gt;fold&lt;/code&gt;&lt;/a&gt; that holds internal state and produces a new iterator. &lt;a href=&quot;../iter/trait.iterator#method.scan&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fabf413b8f61a0afd7c5f9433f5804c39c0d2697" translate="yes" xml:space="preserve">
          <source>An iterator adaptor similar to &lt;a href=&quot;iter/trait.iterator#method.fold&quot;&gt;&lt;code&gt;fold&lt;/code&gt;&lt;/a&gt; that holds internal state and produces a new iterator. &lt;a href=&quot;iter/trait.iterator#method.scan&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2d2199c2efde5116c38701a8b589ced48670c6b8" translate="yes" xml:space="preserve">
          <source>An iterator adaptor similar to &lt;a href=&quot;trait.iterator#method.fold&quot;&gt;&lt;code&gt;fold&lt;/code&gt;&lt;/a&gt; that holds internal state and produces a new iterator.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1597ff1cbb678de32b1737072c75c63f3cb34a01" translate="yes" xml:space="preserve">
          <source>An iterator adaptor similar to &lt;a href=&quot;trait.iterator#method.fold&quot;&gt;&lt;code&gt;fold&lt;/code&gt;&lt;/a&gt; that holds internal state and produces a new iterator. &lt;a href=&quot;trait.iterator#method.scan&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4f7d60e521538ea62f876d5c70c545dc3addec69" translate="yes" xml:space="preserve">
          <source>An iterator adaptor similar to [&lt;code&gt;fold&lt;/code&gt;] that holds internal state and produces a new iterator. &lt;a href=&quot;../../../iter/trait.iterator#method.scan&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">Адаптер итератора, похожий на [ &lt;code&gt;fold&lt;/code&gt; ], который хранит внутреннее состояние и создает новый итератор. &lt;a href=&quot;../../../iter/trait.iterator#method.scan&quot;&gt;Читать далее&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="7a650dc159a2fda49c7766be96685d0f790f13a0" translate="yes" xml:space="preserve">
          <source>An iterator adaptor similar to [&lt;code&gt;fold&lt;/code&gt;] that holds internal state and produces a new iterator. &lt;a href=&quot;../../iter/trait.iterator#method.scan&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">Адаптер итератора, похожий на [ &lt;code&gt;fold&lt;/code&gt; ], который хранит внутреннее состояние и создает новый итератор. &lt;a href=&quot;../../iter/trait.iterator#method.scan&quot;&gt;Читать далее&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="3e898bdaf274bb7754df65ccfb97b6bd04568d2d" translate="yes" xml:space="preserve">
          <source>An iterator adaptor similar to [&lt;code&gt;fold&lt;/code&gt;] that holds internal state and produces a new iterator. &lt;a href=&quot;../iter/trait.iterator#method.scan&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">Адаптер итератора, похожий на [ &lt;code&gt;fold&lt;/code&gt; ], который хранит внутреннее состояние и создает новый итератор. &lt;a href=&quot;../iter/trait.iterator#method.scan&quot;&gt;Читать далее&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="e2996431c0507a4a842fe331c88d08e4bb45dcce" translate="yes" xml:space="preserve">
          <source>An iterator adaptor similar to [&lt;code&gt;fold&lt;/code&gt;] that holds internal state and produces a new iterator. &lt;a href=&quot;iter/trait.iterator#method.scan&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">Адаптер итератора, похожий на [ &lt;code&gt;fold&lt;/code&gt; ], который хранит внутреннее состояние и создает новый итератор. &lt;a href=&quot;iter/trait.iterator#method.scan&quot;&gt;Читать далее&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="ae7a2ef58596a8f574790d9946d5c7b0d3e0427f" translate="yes" xml:space="preserve">
          <source>An iterator adaptor similar to [&lt;code&gt;fold&lt;/code&gt;] that holds internal state and produces a new iterator. &lt;a href=&quot;trait.iterator#method.scan&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">Адаптер итератора, похожий на [ &lt;code&gt;fold&lt;/code&gt; ], который хранит внутреннее состояние и создает новый итератор. &lt;a href=&quot;trait.iterator#method.scan&quot;&gt;Читать далее&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="9ad9db34c1f6ac7b97514886d275ac1277b33c65" translate="yes" xml:space="preserve">
          <source>An iterator for stepping iterators by a custom amount.</source>
          <target state="translated">Итератор для настраиваемых итераторов.</target>
        </trans-unit>
        <trans-unit id="25debeb61a2ecc2a431e58a161838a09b915993a" translate="yes" xml:space="preserve">
          <source>An iterator has a method, &lt;a href=&quot;trait.iterator#tymethod.next&quot;&gt;&lt;code&gt;next&lt;/code&gt;&lt;/a&gt;, which when called, returns an &lt;a href=&quot;../option/enum.option&quot;&gt;&lt;code&gt;Option&lt;/code&gt;&lt;/a&gt;&lt;code&gt;&amp;lt;Item&amp;gt;&lt;/code&gt;. &lt;a href=&quot;trait.iterator#tymethod.next&quot;&gt;&lt;code&gt;next&lt;/code&gt;&lt;/a&gt; will return &lt;a href=&quot;../option/enum.option#variant.Some&quot;&gt;&lt;code&gt;Some(Item)&lt;/code&gt;&lt;/a&gt; as long as there are elements, and once they've all been exhausted, will return &lt;code&gt;None&lt;/code&gt; to indicate that iteration is finished. Individual iterators may choose to resume iteration, and so calling &lt;a href=&quot;trait.iterator#tymethod.next&quot;&gt;&lt;code&gt;next&lt;/code&gt;&lt;/a&gt; again may or may not eventually start returning &lt;a href=&quot;../option/enum.option#variant.Some&quot;&gt;&lt;code&gt;Some(Item)&lt;/code&gt;&lt;/a&gt; again at some point (for example, see &lt;a href=&quot;../sync/mpsc/struct.tryiter&quot;&gt;&lt;code&gt;TryIter&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fb45f260d1289d4ddcd0c03f93e3cf026ce37b59" translate="yes" xml:space="preserve">
          <source>An iterator has a method, &lt;a href=&quot;trait.iterator#tymethod.next&quot;&gt;&lt;code&gt;next&lt;/code&gt;&lt;/a&gt;, which when called, returns an &lt;a href=&quot;../option/enum.option&quot;&gt;&lt;code&gt;Option&lt;/code&gt;&lt;/a&gt;&lt;code&gt;&amp;lt;Item&amp;gt;&lt;/code&gt;. &lt;a href=&quot;trait.iterator#tymethod.next&quot;&gt;&lt;code&gt;next&lt;/code&gt;&lt;/a&gt; will return &lt;code&gt;Some(Item)&lt;/code&gt; as long as there are elements, and once they've all been exhausted, will return &lt;code&gt;None&lt;/code&gt; to indicate that iteration is finished. Individual iterators may choose to resume iteration, and so calling &lt;a href=&quot;trait.iterator#tymethod.next&quot;&gt;&lt;code&gt;next&lt;/code&gt;&lt;/a&gt; again may or may not eventually start returning &lt;code&gt;Some(Item)&lt;/code&gt; again at some point.</source>
          <target state="translated">У итератора есть метод &lt;a href=&quot;trait.iterator#tymethod.next&quot;&gt; &lt;code&gt;next&lt;/code&gt; &lt;/a&gt; , который при вызове возвращает &lt;a href=&quot;../option/enum.option&quot;&gt; &lt;code&gt;Option&lt;/code&gt; &lt;/a&gt; &lt;code&gt;&amp;lt;Item&amp;gt;&lt;/code&gt; . &lt;a href=&quot;trait.iterator#tymethod.next&quot;&gt; &lt;code&gt;next&lt;/code&gt; &lt;/a&gt; вернет &lt;code&gt;Some(Item)&lt;/code&gt; пока есть элементы, и как только они все будут исчерпаны, вернет &lt;code&gt;None&lt;/code&gt; , чтобы указать, что итерация завершена. Отдельные итераторы могут решить возобновить итерацию, и поэтому повторный вызов &lt;a href=&quot;trait.iterator#tymethod.next&quot;&gt; &lt;code&gt;next&lt;/code&gt; &lt;/a&gt; может в какой-то момент снова начать возвращать &lt;code&gt;Some(Item)&lt;/code&gt; , а может и не начать .</target>
        </trans-unit>
        <trans-unit id="e31522f53dadc02b86f505f8fd01b611f6643e8b" translate="yes" xml:space="preserve">
          <source>An iterator method that applies a fallible function to each item in the iterator, stopping at the first error and returning that error.</source>
          <target state="translated">Метод итератора,который применяет к каждому элементу в итераторе некорректную функцию,останавливаясь при первой ошибке и возвращая эту ошибку.</target>
        </trans-unit>
        <trans-unit id="eacb362cba384eacfe624626c78db089eba4406f" translate="yes" xml:space="preserve">
          <source>An iterator method that applies a fallible function to each item in the iterator, stopping at the first error and returning that error. &lt;a href=&quot;../../../iter/trait.iterator#method.try_for_each&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">Метод итератора, который применяет ошибочную функцию к каждому элементу в итераторе, останавливаясь при первой ошибке и возвращая эту ошибку. &lt;a href=&quot;../../../iter/trait.iterator#method.try_for_each&quot;&gt;Читать далее&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="ca00c28d4b5a3134e86a3f660b2fa54093267401" translate="yes" xml:space="preserve">
          <source>An iterator method that applies a fallible function to each item in the iterator, stopping at the first error and returning that error. &lt;a href=&quot;../../iter/trait.iterator#method.try_for_each&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">Метод итератора, который применяет ошибочную функцию к каждому элементу в итераторе, останавливаясь при первой ошибке и возвращая эту ошибку. &lt;a href=&quot;../../iter/trait.iterator#method.try_for_each&quot;&gt;Читать далее&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="e1489bd41c8525121e45484ed737c4171e974de0" translate="yes" xml:space="preserve">
          <source>An iterator method that applies a fallible function to each item in the iterator, stopping at the first error and returning that error. &lt;a href=&quot;../iter/trait.iterator#method.try_for_each&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">Метод итератора, который применяет ошибочную функцию к каждому элементу в итераторе, останавливается при первой ошибке и возвращает эту ошибку. &lt;a href=&quot;../iter/trait.iterator#method.try_for_each&quot;&gt;Читать далее&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="33c934134cacb66bd994968f86b620a631318b91" translate="yes" xml:space="preserve">
          <source>An iterator method that applies a fallible function to each item in the iterator, stopping at the first error and returning that error. &lt;a href=&quot;iter/trait.iterator#method.try_for_each&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">Метод итератора, который применяет ошибочную функцию к каждому элементу в итераторе, останавливается при первой ошибке и возвращает эту ошибку. &lt;a href=&quot;iter/trait.iterator#method.try_for_each&quot;&gt;Читать далее&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="19bfdbf913f10e6bc3776600b92d9135c032b4bf" translate="yes" xml:space="preserve">
          <source>An iterator method that applies a fallible function to each item in the iterator, stopping at the first error and returning that error. &lt;a href=&quot;trait.iterator#method.try_for_each&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">Метод итератора, который применяет ошибочную функцию к каждому элементу в итераторе, останавливается при первой ошибке и возвращает эту ошибку. &lt;a href=&quot;trait.iterator#method.try_for_each&quot;&gt;Читать далее&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="3b59c2e3f2042ddc5a53ef66ef4d7b79f1fb5301" translate="yes" xml:space="preserve">
          <source>An iterator method that applies a function as long as it returns successfully, producing a single, final value.</source>
          <target state="translated">Метод итератора,который применяет функцию до тех пор,пока она успешно возвращается,создавая единственное,конечное значение.</target>
        </trans-unit>
        <trans-unit id="117fd8070a23ba82f744d90c448b1e5813b4d282" translate="yes" xml:space="preserve">
          <source>An iterator method that applies a function as long as it returns successfully, producing a single, final value. &lt;a href=&quot;../../../iter/trait.iterator#method.try_fold&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">Метод итератора, который применяет функцию до тех пор, пока она успешно возвращается, создавая единственное окончательное значение. &lt;a href=&quot;../../../iter/trait.iterator#method.try_fold&quot;&gt;Читать далее&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="7ee1c8bd3a25e2ebef94ba8c0d6405c27ca7226b" translate="yes" xml:space="preserve">
          <source>An iterator method that applies a function as long as it returns successfully, producing a single, final value. &lt;a href=&quot;../../iter/trait.iterator#method.try_fold&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">Метод итератора, который применяет функцию до тех пор, пока она успешно возвращается, создавая единственное окончательное значение. &lt;a href=&quot;../../iter/trait.iterator#method.try_fold&quot;&gt;Читать далее&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="c658b3e624db269551bf93242408ef5c42e5fea9" translate="yes" xml:space="preserve">
          <source>An iterator method that applies a function as long as it returns successfully, producing a single, final value. &lt;a href=&quot;../iter/trait.iterator#method.try_fold&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">Метод итератора, который применяет функцию до тех пор, пока она успешно возвращается, создавая единственное окончательное значение. &lt;a href=&quot;../iter/trait.iterator#method.try_fold&quot;&gt;Читать далее&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="9a5362af3855236bb52258529c3514119a249eab" translate="yes" xml:space="preserve">
          <source>An iterator method that applies a function as long as it returns successfully, producing a single, final value. &lt;a href=&quot;iter/trait.iterator#method.try_fold&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">Метод итератора, который применяет функцию до тех пор, пока она успешно возвращается, создавая единственное окончательное значение. &lt;a href=&quot;iter/trait.iterator#method.try_fold&quot;&gt;Читать далее&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="22eb23eabd6f5888b0f6233654a7d6b3279d1ac7" translate="yes" xml:space="preserve">
          <source>An iterator method that applies a function as long as it returns successfully, producing a single, final value. &lt;a href=&quot;trait.iterator#method.try_fold&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">Метод итератора, который применяет функцию до тех пор, пока она успешно возвращается, создавая единственное окончательное значение. &lt;a href=&quot;trait.iterator#method.try_fold&quot;&gt;Читать далее&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="9d551693bdcaedeac0547d596669a3c5c5179447" translate="yes" xml:space="preserve">
          <source>An iterator method that applies a function, producing a single, final value.</source>
          <target state="translated">Метод итератора,который применяет функцию,создавая единственное,конечное значение.</target>
        </trans-unit>
        <trans-unit id="31400216ecaba12666aff645bec4ca26c5ba43ea" translate="yes" xml:space="preserve">
          <source>An iterator method that applies a function, producing a single, final value. &lt;a href=&quot;../../../iter/trait.iterator#method.fold&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">Метод итератора, который применяет функцию, создавая единственное окончательное значение. &lt;a href=&quot;../../../iter/trait.iterator#method.fold&quot;&gt;Читать далее&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="958c160388552a918125f55bba9e086f54f71484" translate="yes" xml:space="preserve">
          <source>An iterator method that applies a function, producing a single, final value. &lt;a href=&quot;../../iter/trait.iterator#method.fold&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">Метод итератора, который применяет функцию, создавая единственное окончательное значение. &lt;a href=&quot;../../iter/trait.iterator#method.fold&quot;&gt;Читать далее&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="5eddc2fc826e92b735803187068d19d4e441542e" translate="yes" xml:space="preserve">
          <source>An iterator method that applies a function, producing a single, final value. &lt;a href=&quot;../iter/trait.iterator#method.fold&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">Метод итератора, который применяет функцию, создавая единственное окончательное значение. &lt;a href=&quot;../iter/trait.iterator#method.fold&quot;&gt;Читать далее&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="062b8bbee99bc123d00bd6ddb37a2091ecaee57f" translate="yes" xml:space="preserve">
          <source>An iterator method that applies a function, producing a single, final value. &lt;a href=&quot;iter/trait.iterator#method.fold&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">Метод итератора, который применяет функцию, создавая единственное окончательное значение. &lt;a href=&quot;iter/trait.iterator#method.fold&quot;&gt;Читать далее&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="760ff7a591ac95e16cd7be5b9667ba1c820bc96e" translate="yes" xml:space="preserve">
          <source>An iterator method that applies a function, producing a single, final value. &lt;a href=&quot;trait.iterator#method.fold&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">Метод итератора, который применяет функцию, создавая единственное окончательное значение. &lt;a href=&quot;trait.iterator#method.fold&quot;&gt;Читать далее&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="e4cfaa2271cf9f33fe50ead23cff9cf9b29c2c97" translate="yes" xml:space="preserve">
          <source>An iterator method that reduces the iterator's elements to a single, final value, starting from the back.</source>
          <target state="translated">Метод итератора,который уменьшает элементы итератора до одного,конечного значения,начиная с задней части.</target>
        </trans-unit>
        <trans-unit id="c9c712bf49f750f238c96785e7e704d976a72f0e" translate="yes" xml:space="preserve">
          <source>An iterator method that reduces the iterator's elements to a single, final value, starting from the back. &lt;a href=&quot;../../iter/trait.doubleendediterator#method.rfold&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">Метод итератора, который уменьшает элементы итератора до одного конечного значения, начиная с задней части. &lt;a href=&quot;../../iter/trait.doubleendediterator#method.rfold&quot;&gt;Читать далее&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="b44201682fdbcad5c8da77522b47e4b7fc4a3dc1" translate="yes" xml:space="preserve">
          <source>An iterator method that reduces the iterator's elements to a single, final value, starting from the back. &lt;a href=&quot;../iter/trait.doubleendediterator#method.rfold&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">Метод итератора, который уменьшает элементы итератора до одного конечного значения, начиная с задней части. &lt;a href=&quot;../iter/trait.doubleendediterator#method.rfold&quot;&gt;Читать далее&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="fc53bae551d78289c9703ed2a397d1c3b35f285e" translate="yes" xml:space="preserve">
          <source>An iterator method that reduces the iterator's elements to a single, final value, starting from the back. &lt;a href=&quot;iter/trait.doubleendediterator#method.rfold&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">Метод итератора, который уменьшает элементы итератора до одного конечного значения, начиная с задней части. &lt;a href=&quot;iter/trait.doubleendediterator#method.rfold&quot;&gt;Читать далее&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="836f4f2e3fffc61e14c382d8890f27b7a367beeb" translate="yes" xml:space="preserve">
          <source>An iterator method that reduces the iterator's elements to a single, final value, starting from the back. &lt;a href=&quot;trait.doubleendediterator#method.rfold&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">Метод итератора, который уменьшает элементы итератора до одного конечного значения, начиная с задней части. &lt;a href=&quot;trait.doubleendediterator#method.rfold&quot;&gt;Читать далее&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="b2acafc012d5ccce6e7696757b55337a6d4029a3" translate="yes" xml:space="preserve">
          <source>An iterator of &lt;a href=&quot;../primitive.u16&quot;&gt;&lt;code&gt;u16&lt;/code&gt;&lt;/a&gt; over the string encoded as UTF-16.</source>
          <target state="translated">Итератор &lt;a href=&quot;../primitive.u16&quot;&gt; &lt;code&gt;u16&lt;/code&gt; &lt;/a&gt; по строке в кодировке UTF-16.</target>
        </trans-unit>
        <trans-unit id="143fd7db785baccd8bb8346c04f451192a09006a" translate="yes" xml:space="preserve">
          <source>An iterator over &lt;a href=&quot;struct.path&quot;&gt;&lt;code&gt;Path&lt;/code&gt;&lt;/a&gt; and its ancestors.</source>
          <target state="translated">Итератор по &lt;a href=&quot;struct.path&quot;&gt; &lt;code&gt;Path&lt;/code&gt; &lt;/a&gt; и его предкам.</target>
        </trans-unit>
        <trans-unit id="554dfaab9d83066a6b95354b7620556448cb3449" translate="yes" xml:space="preserve">
          <source>An iterator over &lt;a href=&quot;trait.error&quot;&gt;&lt;code&gt;Error&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">Итератор над &lt;a href=&quot;trait.error&quot;&gt; &lt;code&gt;Error&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="aef63e9607a8ec1f5f596fca15621080fd76af72" translate="yes" xml:space="preserve">
          <source>An iterator over &lt;code&gt;u8&lt;/code&gt; values of a reader.</source>
          <target state="translated">Итератор по значениям &lt;code&gt;u8&lt;/code&gt; читателя.</target>
        </trans-unit>
        <trans-unit id="34e3362281b15b977d0a61ac8c5fcd00a6511c9c" translate="yes" xml:space="preserve">
          <source>An iterator over a mutable reference to the &lt;a href=&quot;enum.option#variant.Some&quot;&gt;&lt;code&gt;Some&lt;/code&gt;&lt;/a&gt; variant of an &lt;a href=&quot;enum.option&quot;&gt;&lt;code&gt;Option&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Итератор над изменяемой ссылкой на &lt;a href=&quot;enum.option#variant.Some&quot;&gt; &lt;code&gt;Some&lt;/code&gt; &lt;/a&gt; вариант &lt;a href=&quot;enum.option&quot;&gt; &lt;code&gt;Option&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="c74c624cf35ae570735e4b7f11b57db582409878" translate="yes" xml:space="preserve">
          <source>An iterator over a mutable reference to the &lt;a href=&quot;enum.result#variant.Ok&quot;&gt;&lt;code&gt;Ok&lt;/code&gt;&lt;/a&gt; variant of a &lt;a href=&quot;enum.result&quot;&gt;&lt;code&gt;Result&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Итератор по изменяемой ссылке на вариант &lt;a href=&quot;enum.result#variant.Ok&quot;&gt; &lt;code&gt;Ok&lt;/code&gt; &lt;/a&gt;&lt;a href=&quot;enum.result&quot;&gt; &lt;code&gt;Result&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="f4de84f3b1b68ec9fb8cadcc939ec573f412a94a" translate="yes" xml:space="preserve">
          <source>An iterator over a reference to the &lt;a href=&quot;enum.option#variant.Some&quot;&gt;&lt;code&gt;Some&lt;/code&gt;&lt;/a&gt; variant of an &lt;a href=&quot;enum.option&quot;&gt;&lt;code&gt;Option&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Итератор по ссылке на &lt;a href=&quot;enum.option#variant.Some&quot;&gt; &lt;code&gt;Some&lt;/code&gt; &lt;/a&gt; вариант &lt;a href=&quot;enum.option&quot;&gt; &lt;code&gt;Option&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="8cd69f81931caab64a8dceae843c42a8b1faa3e1" translate="yes" xml:space="preserve">
          <source>An iterator over a reference to the &lt;a href=&quot;enum.result#variant.Ok&quot;&gt;&lt;code&gt;Ok&lt;/code&gt;&lt;/a&gt; variant of a &lt;a href=&quot;enum.result&quot;&gt;&lt;code&gt;Result&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Итератор по ссылке на вариант &lt;a href=&quot;enum.result#variant.Ok&quot;&gt; &lt;code&gt;Ok&lt;/code&gt; &lt;/a&gt;&lt;a href=&quot;enum.result&quot;&gt; &lt;code&gt;Result&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="3dc6f80802c085f551ddaf86ddf6e8acc1dc310c" translate="yes" xml:space="preserve">
          <source>An iterator over a slice in (non-overlapping) chunks (&lt;code&gt;N&lt;/code&gt; elements at a time), starting at the beginning of the slice.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6d2aa423fb037ba3e42490b4a4869e7a989a8b38" translate="yes" xml:space="preserve">
          <source>An iterator over a slice in (non-overlapping) chunks (&lt;code&gt;chunk_size&lt;/code&gt; elements at a time), starting at the beginning of the slice.</source>
          <target state="translated">Итератор по срезу в (неперекрывающихся) кусках ( элементы &lt;code&gt;chunk_size&lt;/code&gt; за раз), начиная с начала среза.</target>
        </trans-unit>
        <trans-unit id="51ba4c3e078709e91115e94720e3b32e5a3519a2" translate="yes" xml:space="preserve">
          <source>An iterator over a slice in (non-overlapping) chunks (&lt;code&gt;chunk_size&lt;/code&gt; elements at a time), starting at the end of the slice.</source>
          <target state="translated">Итератор по срезу в (неперекрывающихся) кусках ( элементы &lt;code&gt;chunk_size&lt;/code&gt; за раз), начиная с конца среза.</target>
        </trans-unit>
        <trans-unit id="d8851ef0d971f6cf3a6b130edee19da50b2e6eeb" translate="yes" xml:space="preserve">
          <source>An iterator over a slice in (non-overlapping) mutable chunks (&lt;code&gt;N&lt;/code&gt; elements at a time), starting at the beginning of the slice.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b727a794715c05c6c1c0cd0cd6149d40bd7c3a04" translate="yes" xml:space="preserve">
          <source>An iterator over a slice in (non-overlapping) mutable chunks (&lt;code&gt;chunk_size&lt;/code&gt; elements at a time), starting at the beginning of the slice.</source>
          <target state="translated">Итератор над срезом в (неперекрывающихся) изменяемых &lt;code&gt;chunk_size&lt;/code&gt; ( элементы chunk_size за раз), начиная с начала среза.</target>
        </trans-unit>
        <trans-unit id="590e04be01e914183b27d18dc8eff4e3ae5668f0" translate="yes" xml:space="preserve">
          <source>An iterator over a slice in (non-overlapping) mutable chunks (&lt;code&gt;chunk_size&lt;/code&gt; elements at a time), starting at the end of the slice.</source>
          <target state="translated">Итератор над срезом в (неперекрывающихся) изменяемых &lt;code&gt;chunk_size&lt;/code&gt; ( элементы chunk_size за раз), начиная с конца среза.</target>
        </trans-unit>
        <trans-unit id="68ad6606a48079fe489aab3faf8c6e3a26b992ca" translate="yes" xml:space="preserve">
          <source>An iterator over a snapshot of the environment variables of this process.</source>
          <target state="translated">Итератор над снимком переменных окружения этого процесса.</target>
        </trans-unit>
        <trans-unit id="a94e3f24bb1eb1ba2fd58ebddc9b4d9dba8309a8" translate="yes" xml:space="preserve">
          <source>An iterator over a sub-range of entries in a &lt;code&gt;BTreeMap&lt;/code&gt;.</source>
          <target state="translated">Итератор для поддиапазона записей в &lt;code&gt;BTreeMap&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d03569c5a9963027ad22996c9e0b70fb1554a87f" translate="yes" xml:space="preserve">
          <source>An iterator over a sub-range of items in a &lt;code&gt;BTreeSet&lt;/code&gt;.</source>
          <target state="translated">Итератор для поддиапазона элементов в &lt;code&gt;BTreeSet&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ce0b01e77f645194e2b6b751858aec640161f669" translate="yes" xml:space="preserve">
          <source>An iterator over an &lt;a href=&quot;trait.error&quot;&gt;&lt;code&gt;Error&lt;/code&gt;&lt;/a&gt; and its sources.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f19c5dd669fe6f36f81a65798f7219d0079a694d" translate="yes" xml:space="preserve">
          <source>An iterator over incoming connections to a &lt;a href=&quot;struct.unixlistener&quot;&gt;&lt;code&gt;UnixListener&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Итератор входящих подключений к &lt;a href=&quot;struct.unixlistener&quot;&gt; &lt;code&gt;UnixListener&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="4d7488e2fccb6b43b42e67c9ea07cad9428b393b" translate="yes" xml:space="preserve">
          <source>An iterator over messages on a &lt;a href=&quot;struct.receiver&quot;&gt;&lt;code&gt;Receiver&lt;/code&gt;&lt;/a&gt;, created by &lt;a href=&quot;struct.receiver#method.iter&quot;&gt;&lt;code&gt;iter&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Итератор сообщений в &lt;a href=&quot;struct.receiver&quot;&gt; &lt;code&gt;Receiver&lt;/code&gt; &lt;/a&gt; , созданный &lt;a href=&quot;struct.receiver#method.iter&quot;&gt; &lt;code&gt;iter&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="034a20701e995ae32aa63104e2d5dff0ab5db4e6" translate="yes" xml:space="preserve">
          <source>An iterator over overlapping subslices of length &lt;code&gt;size&lt;/code&gt;.</source>
          <target state="translated">Итератор, перекрывающий перекрывающиеся фрагменты &lt;code&gt;size&lt;/code&gt; длины .</target>
        </trans-unit>
        <trans-unit id="ba3bd9fb0e96735ece0b2069d478b585f0d8e7fe" translate="yes" xml:space="preserve">
          <source>An iterator over subslices separated by elements that match a predicate function, limited to a given number of splits, starting from the end of the slice.</source>
          <target state="translated">Итератор над подслассами,разделенный элементами,соответствующими предикатной функции,ограниченной заданным числом сплитов,начиная с конца среза.</target>
        </trans-unit>
        <trans-unit id="24b57b67d67808582aa0647134f85aea733abfd0" translate="yes" xml:space="preserve">
          <source>An iterator over subslices separated by elements that match a predicate function, limited to a given number of splits.</source>
          <target state="translated">Итератор над подсловами,разделенный элементами,соответствующими предикатной функции,ограниченной заданным числом сплитов.</target>
        </trans-unit>
        <trans-unit id="7f751853b227571562b0215c1381b97b30029d0a" translate="yes" xml:space="preserve">
          <source>An iterator over subslices separated by elements that match a predicate function, starting from the end of the slice.</source>
          <target state="translated">Итератор над подслассами,разделенный элементами,которые соответствуют предикатной функции,начиная с конца среза.</target>
        </trans-unit>
        <trans-unit id="6a41aa74d34fd0ce2985da917544c4f35cf020f9" translate="yes" xml:space="preserve">
          <source>An iterator over subslices separated by elements that match a predicate function.</source>
          <target state="translated">Итератор над подсловами,разделенный элементами,которые соответствуют предикатной функции.</target>
        </trans-unit>
        <trans-unit id="e1f02e8fb3b3f7adf4ed8a711ed0b9c2ca4cda3e" translate="yes" xml:space="preserve">
          <source>An iterator over substrings of &lt;code&gt;self&lt;/code&gt;, separated by characters matched by a pattern and yielded in reverse order.</source>
          <target state="translated">Итератор по подстрокам &lt;code&gt;self&lt;/code&gt; , разделенным символами, соответствующими шаблону и полученными в обратном порядке.</target>
        </trans-unit>
        <trans-unit id="61c715ce9520941f9108744caef70fb9d86c6529" translate="yes" xml:space="preserve">
          <source>An iterator over substrings of the given string slice, separated by a pattern, restricted to returning at most &lt;code&gt;n&lt;/code&gt; items.</source>
          <target state="translated">Итератор по подстрокам данного строкового среза, разделенных шаблоном, может возвращать не более &lt;code&gt;n&lt;/code&gt; элементов.</target>
        </trans-unit>
        <trans-unit id="44ffc34ab178359db4b3169f249d963fd153689b" translate="yes" xml:space="preserve">
          <source>An iterator over substrings of the given string slice, separated by characters matched by a pattern and yielded in reverse order.</source>
          <target state="translated">Итератор над подстроками заданного среза строки,разделенный символами,подобранными по шаблону,и выданный в обратном порядке.</target>
        </trans-unit>
        <trans-unit id="f65e61a07278abe6a5b629cd21c031c73243b0de" translate="yes" xml:space="preserve">
          <source>An iterator over substrings of the given string slice, separated by characters matched by a pattern.</source>
          <target state="translated">Итератор над подстроками заданного среза строки,разделенный символами,совпадающими с шаблоном.</target>
        </trans-unit>
        <trans-unit id="537813cfc78da0abdca4b435c9341ecf42939302" translate="yes" xml:space="preserve">
          <source>An iterator over substrings of this string slice, separated by a pattern, starting from the end of the string, restricted to returning at most &lt;code&gt;n&lt;/code&gt; items.</source>
          <target state="translated">Итератор по подстрокам этого среза строки, разделенным шаблоном, начиная с конца строки, ограничен возвратом не более &lt;code&gt;n&lt;/code&gt; элементов.</target>
        </trans-unit>
        <trans-unit id="02d9a6b83a0665db88c523e6eaff227f1f6e5ae9" translate="yes" xml:space="preserve">
          <source>An iterator over substrings of this string slice, separated by characters matched by a pattern.</source>
          <target state="translated">Итератор над подстроками этого среза строки,разделенный символами,совпадающими с шаблоном.</target>
        </trans-unit>
        <trans-unit id="a2052e6e3b1c0165802cd6417a16b0838afc588a" translate="yes" xml:space="preserve">
          <source>An iterator over substrings of this string slice, separated by characters matched by a pattern. Differs from the iterator produced by &lt;code&gt;split&lt;/code&gt; in that &lt;code&gt;split_inclusive&lt;/code&gt; leaves the matched part as the terminator of the substring.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0ef8a4c9f98576b84451f0afffc7c456b9562b40" translate="yes" xml:space="preserve">
          <source>An iterator over the &lt;a href=&quot;../primitive.char&quot;&gt;&lt;code&gt;char&lt;/code&gt;&lt;/a&gt;s of a string slice, and their positions.</source>
          <target state="translated">Итератор по &lt;a href=&quot;../primitive.char&quot;&gt; &lt;code&gt;char&lt;/code&gt; &lt;/a&gt; строкового среза и их позициям.</target>
        </trans-unit>
        <trans-unit id="6dbafa08f3b2b12e80351b71ca200a8528053590" translate="yes" xml:space="preserve">
          <source>An iterator over the &lt;a href=&quot;../primitive.char&quot;&gt;&lt;code&gt;char&lt;/code&gt;&lt;/a&gt;s of a string slice.</source>
          <target state="translated">Итератор по &lt;a href=&quot;../primitive.char&quot;&gt; &lt;code&gt;char&lt;/code&gt; &lt;/a&gt; строкового фрагмента.</target>
        </trans-unit>
        <trans-unit id="94f1d147d9aa55e9343a89220481dd294b3c1ca7" translate="yes" xml:space="preserve">
          <source>An iterator over the &lt;a href=&quot;enum.component&quot;&gt;&lt;code&gt;Component&lt;/code&gt;&lt;/a&gt;s of a &lt;a href=&quot;struct.path&quot;&gt;&lt;code&gt;Path&lt;/code&gt;&lt;/a&gt;, as &lt;a href=&quot;../ffi/struct.osstr&quot;&gt;&lt;code&gt;OsStr&lt;/code&gt;&lt;/a&gt; slices.</source>
          <target state="translated">Итератор над &lt;a href=&quot;enum.component&quot;&gt; &lt;code&gt;Component&lt;/code&gt; &lt;/a&gt; S из &lt;a href=&quot;struct.path&quot;&gt; &lt;code&gt;Path&lt;/code&gt; &lt;/a&gt; , а &lt;a href=&quot;../ffi/struct.osstr&quot;&gt; &lt;code&gt;OsStr&lt;/code&gt; &lt;/a&gt; ломтиками.</target>
        </trans-unit>
        <trans-unit id="81b7c7eac770fb32d5f49a8fa6788046e188a635" translate="yes" xml:space="preserve">
          <source>An iterator over the &lt;a href=&quot;enum.component&quot;&gt;&lt;code&gt;Component&lt;/code&gt;&lt;/a&gt;s of a &lt;a href=&quot;struct.path&quot;&gt;&lt;code&gt;Path&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Итератор над &lt;a href=&quot;enum.component&quot;&gt; &lt;code&gt;Component&lt;/code&gt; &lt;/a&gt; S из &lt;a href=&quot;struct.path&quot;&gt; &lt;code&gt;Path&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="0046da9ead2fd2c36a6a2fa82a2d2ece3e53ebf5" translate="yes" xml:space="preserve">
          <source>An iterator over the arguments of a process, yielding a &lt;a href=&quot;../string/struct.string&quot;&gt;&lt;code&gt;String&lt;/code&gt;&lt;/a&gt; value for each argument.</source>
          <target state="translated">Итератор по аргументам процесса, возвращающий значение &lt;a href=&quot;../string/struct.string&quot;&gt; &lt;code&gt;String&lt;/code&gt; &lt;/a&gt; для каждого аргумента.</target>
        </trans-unit>
        <trans-unit id="ebb5d1c5d63504b0108ad325cad0bf7d2676c9ed" translate="yes" xml:space="preserve">
          <source>An iterator over the arguments of a process, yielding an &lt;a href=&quot;../ffi/struct.osstring&quot;&gt;&lt;code&gt;OsString&lt;/code&gt;&lt;/a&gt; value for each argument.</source>
          <target state="translated">Итератор по аргументам процесса, &lt;a href=&quot;../ffi/struct.osstring&quot;&gt; &lt;code&gt;OsString&lt;/code&gt; &lt;/a&gt; значение OsString для каждого аргумента.</target>
        </trans-unit>
        <trans-unit id="db156c74a7f7733ec8d2fb32dcfb0fa41d392992" translate="yes" xml:space="preserve">
          <source>An iterator over the bytes of a string slice.</source>
          <target state="translated">Итератор над байтами среза строки.</target>
        </trans-unit>
        <trans-unit id="3d759394e80e7fa435aa3e0e0304961fda1ff609" translate="yes" xml:space="preserve">
          <source>An iterator over the command arguments.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bc24e95b2a3b7911eb4e4a74052e9fbce963a97d" translate="yes" xml:space="preserve">
          <source>An iterator over the command environment variables.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e870ff1a2a9d31100b2ac9cb6ffbae140349bbde" translate="yes" xml:space="preserve">
          <source>An iterator over the contents of an instance of &lt;code&gt;BufRead&lt;/code&gt; split on a particular byte.</source>
          <target state="translated">Итератор по содержимому экземпляра &lt;code&gt;BufRead&lt;/code&gt; , разбитого на определенный байт.</target>
        </trans-unit>
        <trans-unit id="df77d35e2c4e122e560661a4bc012ddb30bf89c7" translate="yes" xml:space="preserve">
          <source>An iterator over the disjoint matches of a pattern within &lt;code&gt;self&lt;/code&gt;, yielded in reverse order along with the index of the match.</source>
          <target state="translated">Итератор по непересекающимся совпадениям шаблона внутри &lt;code&gt;self&lt;/code&gt; , полученный в обратном порядке вместе с индексом совпадения.</target>
        </trans-unit>
        <trans-unit id="f7d549ea470a7ac3f5b7f05549ca71296a3cf479" translate="yes" xml:space="preserve">
          <source>An iterator over the disjoint matches of a pattern within the given string slice.</source>
          <target state="translated">Итератор над разобщенными совпадениями шаблона внутри заданного среза строки.</target>
        </trans-unit>
        <trans-unit id="4e8c4e320605a2ab4ab8ef1e11e40919b14ac665" translate="yes" xml:space="preserve">
          <source>An iterator over the disjoint matches of a pattern within this string slice as well as the index that the match starts at.</source>
          <target state="translated">Итератор над разобщенными совпадениями образца внутри этого среза строки,а также индекс,с которого начинается это совпадение.</target>
        </trans-unit>
        <trans-unit id="bf644211cc86eb9babefe771489adf416b34d943" translate="yes" xml:space="preserve">
          <source>An iterator over the disjoint matches of a pattern within this string slice, yielded in reverse order.</source>
          <target state="translated">Итератор над разобщенными совпадениями паттерна внутри этого среза строки,полученный в обратном порядке.</target>
        </trans-unit>
        <trans-unit id="a4b7288e219c65d73a3e6a54b4428c628926ca26" translate="yes" xml:space="preserve">
          <source>An iterator over the elements of a &lt;code&gt;BinaryHeap&lt;/code&gt;.</source>
          <target state="translated">Итератор по элементам &lt;code&gt;BinaryHeap&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="60a4b99de7b2aa615fb862b4ef6662bf265a07b3" translate="yes" xml:space="preserve">
          <source>An iterator over the elements of a &lt;code&gt;LinkedList&lt;/code&gt;.</source>
          <target state="translated">Итератор по элементам &lt;code&gt;LinkedList&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2f97f18a1c5aa5746176c6f51c4eafd84be2fce3" translate="yes" xml:space="preserve">
          <source>An iterator over the elements of a &lt;code&gt;VecDeque&lt;/code&gt;.</source>
          <target state="translated">Итератор по элементам &lt;code&gt;VecDeque&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="91db6e4ce90dbed18c33044e96c535db60789527" translate="yes" xml:space="preserve">
          <source>An iterator over the entries of a &lt;code&gt;BTreeMap&lt;/code&gt;.</source>
          <target state="translated">Итератор по записям &lt;code&gt;BTreeMap&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="89075f098d105168914ad089684eab6ab82bd15c" translate="yes" xml:space="preserve">
          <source>An iterator over the entries of a &lt;code&gt;HashMap&lt;/code&gt;.</source>
          <target state="translated">Итератор по записям &lt;code&gt;HashMap&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6598ccbf021650c51246c68845640e9702eed23d" translate="yes" xml:space="preserve">
          <source>An iterator over the escaped version of a byte.</source>
          <target state="translated">Итератор над ускользающей версией байта.</target>
        </trans-unit>
        <trans-unit id="56eb86799cc14570dbdb72543cfaf21c05c1abe2" translate="yes" xml:space="preserve">
          <source>An iterator over the items of a &lt;code&gt;BTreeSet&lt;/code&gt;.</source>
          <target state="translated">Итератор по элементам &lt;code&gt;BTreeSet&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d5fd2e8685f9eef9092473bf82703d995770cb96" translate="yes" xml:space="preserve">
          <source>An iterator over the items of a &lt;code&gt;HashSet&lt;/code&gt;.</source>
          <target state="translated">Итератор по элементам &lt;code&gt;HashSet&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c8ce67dcd74b8165190d1c5586f09c2e5112934e" translate="yes" xml:space="preserve">
          <source>An iterator over the keys of a &lt;code&gt;BTreeMap&lt;/code&gt;.</source>
          <target state="translated">Итератор по ключам &lt;code&gt;BTreeMap&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6ab13d3c24ccbf1b667994220cf1ff47151b518f" translate="yes" xml:space="preserve">
          <source>An iterator over the keys of a &lt;code&gt;HashMap&lt;/code&gt;.</source>
          <target state="translated">Итератор по ключам &lt;code&gt;HashMap&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="bdb3c68f21440272514f422ef05c2d524b30604a" translate="yes" xml:space="preserve">
          <source>An iterator over the lines of a string, as string slices.</source>
          <target state="translated">Итератор над строками,как срезы строки.</target>
        </trans-unit>
        <trans-unit id="47a35066a39c1ed7b30ce9f4878b660c0a1e7474" translate="yes" xml:space="preserve">
          <source>An iterator over the lines of a string.</source>
          <target state="translated">Итератор над строками.</target>
        </trans-unit>
        <trans-unit id="4cce7f5b74c3be64996357d548c448d7d2f4462a" translate="yes" xml:space="preserve">
          <source>An iterator over the lines of an instance of &lt;code&gt;BufRead&lt;/code&gt;.</source>
          <target state="translated">Итератор по строкам экземпляра &lt;code&gt;BufRead&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="cc70893f07fa207bd53da767c3e857dc38ff1063" translate="yes" xml:space="preserve">
          <source>An iterator over the mutable subslices of the vector which are separated by elements that match &lt;code&gt;pred&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a3ce41435c2e05d485713b80e3d67f84041531ab" translate="yes" xml:space="preserve">
          <source>An iterator over the non-ASCII-whitespace substrings of a string, separated by any amount of ASCII whitespace.</source>
          <target state="translated">Итератор над не-ASCII-белыми подстроками строки,разделенный любым количеством ASCII-белых пробельных символов.</target>
        </trans-unit>
        <trans-unit id="98639edcf075ef0bbd56694e6fd8f3ab5801fa3b" translate="yes" xml:space="preserve">
          <source>An iterator over the non-whitespace substrings of a string, separated by any amount of whitespace.</source>
          <target state="translated">Итератор над небелыми подстроками строки,разделенный любым количеством белых пробельных символов.</target>
        </trans-unit>
        <trans-unit id="f6d3a015ca8e0813b9d2a570221365ce0bb7b9f3" translate="yes" xml:space="preserve">
          <source>An iterator over the subslices of the vector which are separated by elements that match &lt;code&gt;pred&lt;/code&gt;, starting from the end of the slice.</source>
          <target state="translated">Итератор по частям вектора, которые разделены элементами, соответствующими &lt;code&gt;pred&lt;/code&gt; , начиная с конца среза.</target>
        </trans-unit>
        <trans-unit id="82456e1206b372bf7ea9d2f45cb440546d002943" translate="yes" xml:space="preserve">
          <source>An iterator over the subslices of the vector which are separated by elements that match &lt;code&gt;pred&lt;/code&gt;.</source>
          <target state="translated">Итератор по частям вектора, разделенным элементами, соответствующими &lt;code&gt;pred&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="551626c835c28af1e23d1b77fa736e5fca587fd5" translate="yes" xml:space="preserve">
          <source>An iterator over the value in &lt;a href=&quot;enum.option#variant.Some&quot;&gt;&lt;code&gt;Some&lt;/code&gt;&lt;/a&gt; variant of an &lt;a href=&quot;enum.option&quot;&gt;&lt;code&gt;Option&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Итератор над значением в &lt;a href=&quot;enum.option#variant.Some&quot;&gt; &lt;code&gt;Some&lt;/code&gt; &lt;/a&gt; варианте с &lt;a href=&quot;enum.option&quot;&gt; &lt;code&gt;Option&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="2ad0a62fd20b029d94f3ea06e170d6042fc65d39" translate="yes" xml:space="preserve">
          <source>An iterator over the value in a &lt;a href=&quot;enum.result#variant.Ok&quot;&gt;&lt;code&gt;Ok&lt;/code&gt;&lt;/a&gt; variant of a &lt;a href=&quot;enum.result&quot;&gt;&lt;code&gt;Result&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Итератор по значению в варианте &lt;a href=&quot;enum.result#variant.Ok&quot;&gt; &lt;code&gt;Ok&lt;/code&gt; &lt;/a&gt;&lt;a href=&quot;enum.result&quot;&gt; &lt;code&gt;Result&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="06914df7e2feff75ffe46782ed50136c93cfaa1b" translate="yes" xml:space="preserve">
          <source>An iterator over the values of a &lt;code&gt;BTreeMap&lt;/code&gt;.</source>
          <target state="translated">Итератор по значениям &lt;code&gt;BTreeMap&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="25879aa8de242e212254e6f312a25f5c0bfcd32b" translate="yes" xml:space="preserve">
          <source>An iterator over the values of a &lt;code&gt;HashMap&lt;/code&gt;.</source>
          <target state="translated">Итератор по значениям &lt;code&gt;HashMap&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1d5f58fc7c0c008712ec4e6eb8559eb52c39ce18" translate="yes" xml:space="preserve">
          <source>An iterator produced by &lt;code&gt;repeat_with()&lt;/code&gt; is not a &lt;a href=&quot;trait.doubleendediterator&quot;&gt;&lt;code&gt;DoubleEndedIterator&lt;/code&gt;&lt;/a&gt;. If you need &lt;code&gt;repeat_with()&lt;/code&gt; to return a &lt;a href=&quot;trait.doubleendediterator&quot;&gt;&lt;code&gt;DoubleEndedIterator&lt;/code&gt;&lt;/a&gt;, please open a GitHub issue explaining your use case.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="28ebf2a599d5ab4a921fbe241809a3d3600be3e5" translate="yes" xml:space="preserve">
          <source>An iterator produced by &lt;code&gt;repeat_with()&lt;/code&gt; is not a &lt;code&gt;DoubleEndedIterator&lt;/code&gt;. If you need &lt;code&gt;repeat_with()&lt;/code&gt; to return a &lt;code&gt;DoubleEndedIterator&lt;/code&gt;, please open a GitHub issue explaining your use case.</source>
          <target state="translated">Итератор, созданный &lt;code&gt;repeat_with()&lt;/code&gt; , не является &lt;code&gt;DoubleEndedIterator&lt;/code&gt; . Если вам нужно &lt;code&gt;repeat_with()&lt;/code&gt; для возврата &lt;code&gt;DoubleEndedIterator&lt;/code&gt; , откройте проблему GitHub с объяснением вашего варианта использования.</target>
        </trans-unit>
        <trans-unit id="57a784df1f13cfa8da5679e054cc8033f6fabdb2" translate="yes" xml:space="preserve">
          <source>An iterator produced by calling &lt;code&gt;drain_filter&lt;/code&gt; on BTreeMap.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8506c9bfb6eed5d29b225ea0333e263b7b9b1840" translate="yes" xml:space="preserve">
          <source>An iterator produced by calling &lt;code&gt;drain_filter&lt;/code&gt; on BTreeSet.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c51b3a9a86a32de916b3441f5cc928b34139d94d" translate="yes" xml:space="preserve">
          <source>An iterator produced by calling &lt;code&gt;drain_filter&lt;/code&gt; on LinkedList.</source>
          <target state="translated">Итератор, созданный путем вызова &lt;code&gt;drain_filter&lt;/code&gt; в LinkedList.</target>
        </trans-unit>
        <trans-unit id="d90f64072c9b86fb5e160826e11d54a35519d306" translate="yes" xml:space="preserve">
          <source>An iterator produced by calling &lt;code&gt;drain_filter&lt;/code&gt; on Vec.</source>
          <target state="translated">Итератор, созданный путем вызова &lt;code&gt;drain_filter&lt;/code&gt; на Vec.</target>
        </trans-unit>
        <trans-unit id="e2f38bdab7ee3f88662413a8d0762d07987cc9e4" translate="yes" xml:space="preserve">
          <source>An iterator that always continues to yield &lt;code&gt;None&lt;/code&gt; when exhausted.</source>
          <target state="translated">Итератор, который всегда продолжает возвращать &lt;code&gt;None&lt;/code&gt; при исчерпании ресурсов.</target>
        </trans-unit>
        <trans-unit id="d75b48632d15091a831b75304f768ce72229865c" translate="yes" xml:space="preserve">
          <source>An iterator that attempts to yield all pending values for a &lt;a href=&quot;struct.receiver&quot;&gt;&lt;code&gt;Receiver&lt;/code&gt;&lt;/a&gt;, created by &lt;a href=&quot;struct.receiver#method.try_iter&quot;&gt;&lt;code&gt;try_iter&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Итератор, который пытается получить все ожидающие значения для &lt;a href=&quot;struct.receiver&quot;&gt; &lt;code&gt;Receiver&lt;/code&gt; &lt;/a&gt; , созданного &lt;a href=&quot;struct.receiver#method.try_iter&quot;&gt; &lt;code&gt;try_iter&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="0c0e45d489e23ad54f254e3c451b03c3ad3633b8" translate="yes" xml:space="preserve">
          <source>An iterator that calls a function with a reference to each element before yielding it.</source>
          <target state="translated">Итератор,который вызывает функцию со ссылкой на каждый элемент до получения его.</target>
        </trans-unit>
        <trans-unit id="51a9a929e3e766e1bc15473a2edf034711e9603a" translate="yes" xml:space="preserve">
          <source>An iterator that clones the elements of an underlying iterator.</source>
          <target state="translated">Итератор,который клонирует элементы базового итератора.</target>
        </trans-unit>
        <trans-unit id="d2287777325ba0f8a82eefc9f82886c5e6c0375c" translate="yes" xml:space="preserve">
          <source>An iterator that copies the elements of an underlying iterator.</source>
          <target state="translated">Итератор,который копирует элементы базового итератора.</target>
        </trans-unit>
        <trans-unit id="11b5eb68a058f133076c97a53287f7350b19b4ed" translate="yes" xml:space="preserve">
          <source>An iterator that decodes UTF-16 encoded code points from an iterator of &lt;code&gt;u16&lt;/code&gt;s.</source>
          <target state="translated">Итератор, который декодирует кодовые точки в кодировке UTF-16 из итератора &lt;code&gt;u16&lt;/code&gt; s.</target>
        </trans-unit>
        <trans-unit id="a7c2f22f759edefd0c02e7989a0830d2b9927824" translate="yes" xml:space="preserve">
          <source>An iterator that filters the elements of &lt;code&gt;iter&lt;/code&gt; with &lt;code&gt;predicate&lt;/code&gt;.</source>
          <target state="translated">Итератор, фильтрующий элементы &lt;code&gt;iter&lt;/code&gt; с помощью &lt;code&gt;predicate&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="538c0bdbb5f2579b6454154f638e3b2235b91db1" translate="yes" xml:space="preserve">
          <source>An iterator that flattens one level of nesting in an iterator of things that can be turned into iterators.</source>
          <target state="translated">Итератор,который сплющивает один уровень гнездования в итераторе вещей,которые могут быть превращены в итераторы.</target>
        </trans-unit>
        <trans-unit id="9dbf52f6fb3a5236b83ac424b9036cbd60fd5a39" translate="yes" xml:space="preserve">
          <source>An iterator that infinitely &lt;a href=&quot;struct.tcplistener#method.accept&quot;&gt;&lt;code&gt;accept&lt;/code&gt;&lt;/a&gt;s connections on a &lt;a href=&quot;struct.tcplistener&quot;&gt;&lt;code&gt;TcpListener&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Итератор, который бесконечно &lt;a href=&quot;struct.tcplistener#method.accept&quot;&gt; &lt;code&gt;accept&lt;/code&gt; &lt;/a&gt; s подключений к &lt;a href=&quot;struct.tcplistener&quot;&gt; &lt;code&gt;TcpListener&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="81a5d4ccf76ade25979b7f90350112e1ade77257" translate="yes" xml:space="preserve">
          <source>An iterator that iterates two other iterators simultaneously.</source>
          <target state="translated">Итератор,который итерирует два других итератора одновременно.</target>
        </trans-unit>
        <trans-unit id="ca3c41a43b14bf4c961d798c07db548fe5c4306e" translate="yes" xml:space="preserve">
          <source>An iterator that knows its exact length.</source>
          <target state="translated">Итератор,который знает его точную длину.</target>
        </trans-unit>
        <trans-unit id="6bd3d7d181c5f76ada28bd405c55b98768c1a53e" translate="yes" xml:space="preserve">
          <source>An iterator that links two iterators together, in a chain.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fd413348f096597213f95708520a2a2ee8e8c6ff" translate="yes" xml:space="preserve">
          <source>An iterator that maps each element to an iterator, and yields the elements of the produced iterators.</source>
          <target state="translated">Итератор,который сопоставляет каждый элемент с итератором,и дает элементы произведенных итераторов.</target>
        </trans-unit>
        <trans-unit id="e00fb1707b378038f217f0122cb5c2c693a99ce9" translate="yes" xml:space="preserve">
          <source>An iterator that maps the values of &lt;code&gt;iter&lt;/code&gt; with &lt;code&gt;f&lt;/code&gt;.</source>
          <target state="translated">Итератор, отображающий значения &lt;code&gt;iter&lt;/code&gt; с &lt;code&gt;f&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c89c4d0277ad0dbe70fcef9f7526e1d26306d3c4" translate="yes" xml:space="preserve">
          <source>An iterator that moves out of a vector.</source>
          <target state="translated">Итератор,который выходит из вектора.</target>
        </trans-unit>
        <trans-unit id="18d1634bc6586ab56c39fac0a163c9d8e2300d06" translate="yes" xml:space="preserve">
          <source>An iterator that only accepts elements while &lt;code&gt;predicate&lt;/code&gt; returns &lt;code&gt;Some(_)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5d780c4556be41e5ade58ccb90a4cb9745c8a4a0" translate="yes" xml:space="preserve">
          <source>An iterator that only accepts elements while &lt;code&gt;predicate&lt;/code&gt; returns &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">Итератор, который принимает только элементы, в то время как &lt;code&gt;predicate&lt;/code&gt; возвращает &lt;code&gt;true&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ca756e17e11dd720fde75ad3acbb4dc61da5a0b9" translate="yes" xml:space="preserve">
          <source>An iterator that only iterates over the first &lt;code&gt;n&lt;/code&gt; iterations of &lt;code&gt;iter&lt;/code&gt;.</source>
          <target state="translated">Итератор, который выполняет только первые &lt;code&gt;n&lt;/code&gt; итераций &lt;code&gt;iter&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="473994edf3f2b12636ecfbae9c0cf95e9976442a" translate="yes" xml:space="preserve">
          <source>An iterator that rejects elements while &lt;code&gt;predicate&lt;/code&gt; returns &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">Итератор, который отклоняет элементы, в то время как &lt;code&gt;predicate&lt;/code&gt; возвращает значение &lt;code&gt;true&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0464de53ba73fee454800ae2dd5fef9380113b90" translate="yes" xml:space="preserve">
          <source>An iterator that repeats an element endlessly.</source>
          <target state="translated">Итератор,бесконечно повторяющий элемент.</target>
        </trans-unit>
        <trans-unit id="7f0331c06c1f3247687712e4a8fa91faa255da79" translate="yes" xml:space="preserve">
          <source>An iterator that repeats elements of type &lt;code&gt;A&lt;/code&gt; endlessly by applying the provided closure &lt;code&gt;F: FnMut() -&amp;gt; A&lt;/code&gt;.</source>
          <target state="translated">Итератора , который повторяет элементы типа &lt;code&gt;A&lt;/code&gt; бесконечно, применяя при условии закрытия &lt;code&gt;F: FnMut() -&amp;gt; A&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4f71391fe387efdecec312046c6dd55bbf198321" translate="yes" xml:space="preserve">
          <source>An iterator that repeats endlessly.</source>
          <target state="translated">Итератор,который повторяет бесконечно.</target>
        </trans-unit>
        <trans-unit id="905426af2dba7f51c454090a12d4200524fdd44c" translate="yes" xml:space="preserve">
          <source>An iterator that reports an accurate length using size_hint.</source>
          <target state="translated">Итератор,который сообщает точную длину с помощью size_hint.</target>
        </trans-unit>
        <trans-unit id="6e8e68927103c8756bd8e724310ac62f637e383b" translate="yes" xml:space="preserve">
          <source>An iterator that skips over &lt;code&gt;n&lt;/code&gt; elements of &lt;code&gt;iter&lt;/code&gt;.</source>
          <target state="translated">Итератор, пропускающий &lt;code&gt;n&lt;/code&gt; элементов &lt;code&gt;iter&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="cc8fdbf15929bf39a9148cd3ad1f02b7e2f3e8e1" translate="yes" xml:space="preserve">
          <source>An iterator that splits an environment variable into paths according to platform-specific conventions.</source>
          <target state="translated">Итератор,который разделяет переменную окружения на пути в соответствии со специфическими для платформы конвенциями.</target>
        </trans-unit>
        <trans-unit id="57ccd12f7079988974d92028c7ca992c2e3dc8d6" translate="yes" xml:space="preserve">
          <source>An iterator that strings two iterators together.</source>
          <target state="translated">Итератор,который связывает два итератора вместе.</target>
        </trans-unit>
        <trans-unit id="277e34f21de2c1bcf08658ea7180ea41a724c7da" translate="yes" xml:space="preserve">
          <source>An iterator that uses &lt;code&gt;f&lt;/code&gt; to both filter and map elements from &lt;code&gt;iter&lt;/code&gt;.</source>
          <target state="translated">Итератор, который использует &lt;code&gt;f&lt;/code&gt; как для фильтрации, так и для отображения элементов из &lt;code&gt;iter&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d1c29ab729712117252122597b1f8dee40693e18" translate="yes" xml:space="preserve">
          <source>An iterator that when yielding an item will have taken at least one element from its underlying &lt;a href=&quot;trait.sourceiter&quot;&gt;&lt;code&gt;SourceIter&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="290a4df52520d8c2cd218b2c5a66207c17bd76b5" translate="yes" xml:space="preserve">
          <source>An iterator that yields &lt;code&gt;None&lt;/code&gt; forever after the underlying iterator yields &lt;code&gt;None&lt;/code&gt; once.</source>
          <target state="translated">Итератор, который возвращает &lt;code&gt;None&lt;/code&gt; навсегда после того, как базовый итератор возвращает &lt;code&gt;None&lt;/code&gt; один раз.</target>
        </trans-unit>
        <trans-unit id="8077f46e4926a9ba2fe0c3a0111f99b3bfd0cee7" translate="yes" xml:space="preserve">
          <source>An iterator that yields a single element of type &lt;code&gt;A&lt;/code&gt; by applying the provided closure &lt;code&gt;F: FnOnce() -&amp;gt; A&lt;/code&gt;.</source>
          <target state="translated">Итератора , который дает один элемент типа &lt;code&gt;A&lt;/code&gt; , применяя при условии закрытия &lt;code&gt;F: FnOnce() -&amp;gt; A&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f74ed23fee03be7f9726d86e04759a8cdc7c98f8" translate="yes" xml:space="preserve">
          <source>An iterator that yields an element exactly once.</source>
          <target state="translated">Итератор,который дает элемент ровно один раз.</target>
        </trans-unit>
        <trans-unit id="d839e72a6966bc49a09991c75f6ebb8c0f577f86" translate="yes" xml:space="preserve">
          <source>An iterator that yields nothing.</source>
          <target state="translated">Итератор,который ничего не дает.</target>
        </trans-unit>
        <trans-unit id="5c4e0833b181576427135eb9c8df2d3b1200509f" translate="yes" xml:space="preserve">
          <source>An iterator that yields the current count and the element during iteration.</source>
          <target state="translated">Итератор,который дает текущий счет и элемент во время итерации.</target>
        </trans-unit>
        <trans-unit id="13cc9cc84ea0ac8db6860e2d362f3768df8c56c8" translate="yes" xml:space="preserve">
          <source>An iterator that yields the literal escape code of a &lt;code&gt;char&lt;/code&gt;.</source>
          <target state="translated">Итератор, который выдает буквальный escape-код &lt;code&gt;char&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f37b0b305dd49cedb47e6f8dfa5f3a2bdad3bf67" translate="yes" xml:space="preserve">
          <source>An iterator to maintain state while iterating another iterator.</source>
          <target state="translated">Итератор для поддержания состояния во время итерации другого итератора.</target>
        </trans-unit>
        <trans-unit id="47ba4cac2215dd1a04b338eb0e4a94df69cf3c0f" translate="yes" xml:space="preserve">
          <source>An iterator visiting all elements in arbitrary order. The iterator element type is &lt;code&gt;&amp;amp;'a T&lt;/code&gt;.</source>
          <target state="translated">Итератор, посещающий все элементы в произвольном порядке. Тип итератора элемент &lt;code&gt;&amp;amp;'a T&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7550894b7d1bb85e45b801eaeed48efa989854c0" translate="yes" xml:space="preserve">
          <source>An iterator visiting all key-value pairs in arbitrary order, with mutable references to the values. The iterator element type is &lt;code&gt;(&amp;amp;'a K, &amp;amp;'a mut V)&lt;/code&gt;.</source>
          <target state="translated">Итератор, посещающий все пары ключ-значение в произвольном порядке с изменяемыми ссылками на значения. Тип элемента итератора - &lt;code&gt;(&amp;amp;'a K, &amp;amp;'a mut V)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1b08b2653f7dcb8dc940ed24069740a24ab5b76a" translate="yes" xml:space="preserve">
          <source>An iterator visiting all key-value pairs in arbitrary order. The iterator element type is &lt;code&gt;(&amp;amp;'a K, &amp;amp;'a V)&lt;/code&gt;.</source>
          <target state="translated">Итератор, посещающий все пары ключ-значение в произвольном порядке. Тип элемента итератора - &lt;code&gt;(&amp;amp;'a K, &amp;amp;'a V)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a52b26a20f6e5a2edebe10f6f90cf9507490a85c" translate="yes" xml:space="preserve">
          <source>An iterator visiting all keys in arbitrary order. The iterator element type is &lt;code&gt;&amp;amp;'a K&lt;/code&gt;.</source>
          <target state="translated">Итератор, посещающий все ключи в произвольном порядке. Тип итератора элемент &lt;code&gt;&amp;amp;'a K&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="cee3468b8b5e0fdd5a440c2d5df35c4c2db2ae90" translate="yes" xml:space="preserve">
          <source>An iterator visiting all values in arbitrary order. The iterator element type is &lt;code&gt;&amp;amp;'a V&lt;/code&gt;.</source>
          <target state="translated">Итератор, просматривающий все значения в произвольном порядке. Тип итератора элемент &lt;code&gt;&amp;amp;'a V&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7ae307f212519994d8b694a5d942377f4aec4823" translate="yes" xml:space="preserve">
          <source>An iterator visiting all values mutably in arbitrary order. The iterator element type is &lt;code&gt;&amp;amp;'a mut V&lt;/code&gt;.</source>
          <target state="translated">Итератор, взаимно посещающий все значения в произвольном порядке. Тип итератора элемент &lt;code&gt;&amp;amp;'a mut V&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="211d7c1adc8a12b57341be994e857003e54c6bbd" translate="yes" xml:space="preserve">
          <source>An iterator where each iteration calls the provided closure &lt;code&gt;F: FnMut() -&amp;gt; Option&amp;lt;T&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">Итератор, в котором каждая итерация вызывает указанное закрытие &lt;code&gt;F: FnMut() -&amp;gt; Option&amp;lt;T&amp;gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="33d8e5b7da8d4676782754a628f4083ffd272c18" translate="yes" xml:space="preserve">
          <source>An iterator which uses a closure to determine if an element should be removed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c53ddbd1d3e296430ed20afa68efda72ca0ded32" translate="yes" xml:space="preserve">
          <source>An iterator with a &lt;code&gt;peek()&lt;/code&gt; that returns an optional reference to the next element.</source>
          <target state="translated">Итератор с &lt;code&gt;peek()&lt;/code&gt; которая возвращает необязательную ссылку на следующий элемент.</target>
        </trans-unit>
        <trans-unit id="c9cd5154a20293338cfe2c0c0c884bc897a9a0cb" translate="yes" xml:space="preserve">
          <source>An new iterator where each successive item is computed based on the preceding one.</source>
          <target state="translated">Новый итератор,в котором каждый последующий элемент вычисляется на основе предыдущего.</target>
        </trans-unit>
        <trans-unit id="a64664459e6bcefaf4f866fe61f4c89bbbc6e913" translate="yes" xml:space="preserve">
          <source>An non-ascii identifier was used in an invalid context.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="767a832ec64e700730e273e825321e36a3ef86e1" translate="yes" xml:space="preserve">
          <source>An occupied entry.</source>
          <target state="translated">Занятый вход.</target>
        </trans-unit>
        <trans-unit id="678664bfa424da9fc0ca21e4760f29b4b952648d" translate="yes" xml:space="preserve">
          <source>An optional item</source>
          <target state="translated">Необязательный предмет</target>
        </trans-unit>
        <trans-unit id="d7f5308e6f605cdab4dbb8b387f9c93de98d0922" translate="yes" xml:space="preserve">
          <source>An order is a total order if it is (for all &lt;code&gt;a&lt;/code&gt;, &lt;code&gt;b&lt;/code&gt; and &lt;code&gt;c&lt;/code&gt;):</source>
          <target state="translated">Заказ является общим заказом, если он (для всех &lt;code&gt;a&lt;/code&gt; , &lt;code&gt;b&lt;/code&gt; и &lt;code&gt;c&lt;/code&gt; ):</target>
        </trans-unit>
        <trans-unit id="e7c75396d6933448cc7456d6beaf9cf648ea0ef5" translate="yes" xml:space="preserve">
          <source>An ordering where a compared value is equal to another.</source>
          <target state="translated">Заказ,при котором сравниваемое значение равно другому.</target>
        </trans-unit>
        <trans-unit id="09dba8210b3d0ce590a3a5f065b62a6a8ab493fb" translate="yes" xml:space="preserve">
          <source>An ordering where a compared value is greater than another.</source>
          <target state="translated">Заказ,при котором сравниваемая величина больше другой.</target>
        </trans-unit>
        <trans-unit id="a2c8ca4c96fc50eebfe4b351916be57d1bf56d8c" translate="yes" xml:space="preserve">
          <source>An ordering where a compared value is less than another.</source>
          <target state="translated">Заказ,при котором сравниваемое значение меньше другого.</target>
        </trans-unit>
        <trans-unit id="38792f39e0fa160ba176220b302fc6518c1e2555" translate="yes" xml:space="preserve">
          <source>An owned permission to join on a thread (block on its termination).</source>
          <target state="translated">Собственное разрешение на соединение на нитке (блок на ее окончание).</target>
        </trans-unit>
        <trans-unit id="8c3512dc7441f7c48feb0adfb2813ca8cbecd465" translate="yes" xml:space="preserve">
          <source>An owned, mutable path (akin to &lt;a href=&quot;../string/struct.string&quot;&gt;&lt;code&gt;String&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">Собственный изменяемый путь (похожий на &lt;a href=&quot;../string/struct.string&quot;&gt; &lt;code&gt;String&lt;/code&gt; &lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="e84205a36cc39374bcb7d05c1b1547f37b9b5189" translate="yes" xml:space="preserve">
          <source>An owning iterator over messages on a &lt;a href=&quot;struct.receiver&quot;&gt;&lt;code&gt;Receiver&lt;/code&gt;&lt;/a&gt;, created by &lt;strong&gt;Receiver::into_iter&lt;/strong&gt;.</source>
          <target state="translated">Итератор-владелец сообщений в &lt;a href=&quot;struct.receiver&quot;&gt; &lt;code&gt;Receiver&lt;/code&gt; &lt;/a&gt; , созданный &lt;strong&gt;Receiver :: into_iter&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="83bd664b01b4716a8aced24a8192a6358972a99f" translate="yes" xml:space="preserve">
          <source>An owning iterator over the elements of a &lt;code&gt;BinaryHeap&lt;/code&gt;.</source>
          <target state="translated">Итератор-владелец для элементов &lt;code&gt;BinaryHeap&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="34718a674d09c2eb637513ac6f89289f300970ef" translate="yes" xml:space="preserve">
          <source>An owning iterator over the elements of a &lt;code&gt;LinkedList&lt;/code&gt;.</source>
          <target state="translated">Итератор-владелец для элементов &lt;code&gt;LinkedList&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f6f353b2a400a09971f91285403f6b780ae991c4" translate="yes" xml:space="preserve">
          <source>An owning iterator over the elements of a &lt;code&gt;VecDeque&lt;/code&gt;.</source>
          <target state="translated">Итератор-владелец элементов &lt;code&gt;VecDeque&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="77a86a6c2dd3031f17c5e8abfe6100f81887dd42" translate="yes" xml:space="preserve">
          <source>An owning iterator over the entries of a &lt;code&gt;BTreeMap&lt;/code&gt;.</source>
          <target state="translated">Итератор-владелец записей &lt;code&gt;BTreeMap&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="209ab8cbe2152f0b0d82c7256751114f7cd068b9" translate="yes" xml:space="preserve">
          <source>An owning iterator over the entries of a &lt;code&gt;HashMap&lt;/code&gt;.</source>
          <target state="translated">Итератор-владелец для записей &lt;code&gt;HashMap&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ef6f78f2a2dbde9b33ceeac921bd77fbb502b5bc" translate="yes" xml:space="preserve">
          <source>An owning iterator over the items of a &lt;code&gt;BTreeSet&lt;/code&gt;.</source>
          <target state="translated">Итератор-владелец по элементам &lt;code&gt;BTreeSet&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="427fdeccedc75e2673269080f0ce6c0924e6c1bd" translate="yes" xml:space="preserve">
          <source>An owning iterator over the items of a &lt;code&gt;HashSet&lt;/code&gt;.</source>
          <target state="translated">Итератор-владелец по элементам &lt;code&gt;HashSet&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="63f91fac0583c8f40d303b24662fb74f3439b187" translate="yes" xml:space="preserve">
          <source>An owning iterator over the keys of a &lt;code&gt;BTreeMap&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3d2eac75b0f121647617969553f50d0b9466ca4f" translate="yes" xml:space="preserve">
          <source>An owning iterator over the keys of a &lt;code&gt;HashMap&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c812167dc1a9620fc28974d42c5f815dace73059" translate="yes" xml:space="preserve">
          <source>An owning iterator over the values of a &lt;code&gt;BTreeMap&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e996a80994408e932109330c3a7b8f4f5821448e" translate="yes" xml:space="preserve">
          <source>An owning iterator over the values of a &lt;code&gt;HashMap&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b9b2d7fe27e12071feb7334cad3f7f83e9e84aa2" translate="yes" xml:space="preserve">
          <source>An unary operator was used on a type which doesn't implement it.</source>
          <target state="translated">Унарный оператор использовался на типе,который его не реализует.</target>
        </trans-unit>
        <trans-unit id="dcb71e1bf306a3b27e4be98207d51ae66d320fdd" translate="yes" xml:space="preserve">
          <source>An unbounded range (&lt;code&gt;..&lt;/code&gt;).</source>
          <target state="translated">Неограниченный диапазон ( &lt;code&gt;..&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="17e397882c6b5d98ce823af67a0207c6b4f0a351" translate="yes" xml:space="preserve">
          <source>An unboxed trait object was used as a return value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="77330b9c19314a31717caeb5c6b57d3f4259e03a" translate="yes" xml:space="preserve">
          <source>An unchecked assertion allows a program in an inconsistent state to keep running, which might have unexpected consequences but does not introduce unsafety as long as this only happens in safe code. The performance cost of assertions, however, is not measurable in general. Replacing &lt;a href=&quot;macro.assert&quot;&gt;&lt;code&gt;assert!&lt;/code&gt;&lt;/a&gt; with &lt;code&gt;debug_assert!&lt;/code&gt; is thus only encouraged after thorough profiling, and more importantly, only in safe code!</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3caad6b327abced5bae6f8ff205241ca33ed53ab" translate="yes" xml:space="preserve">
          <source>An unchecked assertion allows a program in an inconsistent state to keep running, which might have unexpected consequences but does not introduce unsafety as long as this only happens in safe code. The performance cost of assertions, is however, not measurable in general. Replacing &lt;a href=&quot;macro.assert&quot;&gt;&lt;code&gt;assert!&lt;/code&gt;&lt;/a&gt; with &lt;code&gt;debug_assert!&lt;/code&gt; is thus only encouraged after thorough profiling, and more importantly, only in safe code!</source>
          <target state="translated">Непроверенное утверждение позволяет программе в несогласованном состоянии продолжать работу, что может иметь неожиданные последствия, но не вносит небезопасности, пока это происходит только в безопасном коде. Однако стоимость утверждений в целом не поддается измерению. Замена &lt;a href=&quot;macro.assert&quot;&gt; &lt;code&gt;assert!&lt;/code&gt; &lt;/a&gt;с помощью &lt;code&gt;debug_assert!&lt;/code&gt; поэтому рекомендуется только после тщательного профилирования и, что более важно, только в безопасном коде!</target>
        </trans-unit>
        <trans-unit id="442287d37e019d0e550c26e6f3dfcfb70e25272a" translate="yes" xml:space="preserve">
          <source>An undeclared crate, module, or type was used.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="490b1d248ac38d604233cacff667b31a463976df" translate="yes" xml:space="preserve">
          <source>An undeclared label was used.</source>
          <target state="translated">Использовалась незадекларированная этикетка.</target>
        </trans-unit>
        <trans-unit id="5cc74f4a7dec23f15c6176f5d92410a97be0cd49" translate="yes" xml:space="preserve">
          <source>An undeclared lifetime was used.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fc0bdd57bc131e7f23a48af9227bf2c7b9e2b4dd" translate="yes" xml:space="preserve">
          <source>An undeclared type or module was used.</source>
          <target state="translated">Использовался незадекларированный тип или модуль.</target>
        </trans-unit>
        <trans-unit id="62b209ea92b4732aa055c2148d6eb87f3bf6ae79" translate="yes" xml:space="preserve">
          <source>An undefined atomic operation function was declared.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="edf946e9423b88dbc97c6f1ffa6e16764af6cd52" translate="yes" xml:space="preserve">
          <source>An underscore &lt;code&gt;_&lt;/code&gt; character has been used as the identifier for a lifetime.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5c74d6c9b38a67d2a5eb623d75e946df289a3fbc" translate="yes" xml:space="preserve">
          <source>An unknown &quot;kind&quot; was specified for a link attribute.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2dbef161c3305374da24ca6e3ae9cdc7bdefe6b4" translate="yes" xml:space="preserve">
          <source>An unknown &quot;kind&quot; was specified for a link attribute. Erroneous code example:</source>
          <target state="translated">Для атрибута ссылки был указан неизвестный &quot;вид&quot;.Пример ошибочного кода:</target>
        </trans-unit>
        <trans-unit id="a5956e957dc8b784f0e077b9955dd790db201d80" translate="yes" xml:space="preserve">
          <source>An unknown argument was given to the &lt;code&gt;inline&lt;/code&gt; attribute.</source>
          <target state="translated">Неизвестный аргумент передан &lt;code&gt;inline&lt;/code&gt; атрибуту.</target>
        </trans-unit>
        <trans-unit id="7d952bcfdbb1c8f63e3755c7054750e6c464627c" translate="yes" xml:space="preserve">
          <source>An unknown argument was given to the &lt;code&gt;instruction_set&lt;/code&gt; attribute.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="55c4e65153fb4fac3f59b06b3332f14a29b39777" translate="yes" xml:space="preserve">
          <source>An unknown external lang item was used.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9a99f6d07dc4d8ba35aa89128cc34d06dd11ce0f" translate="yes" xml:space="preserve">
          <source>An unknown external lang item was used. Erroneous code example:</source>
          <target state="translated">Использовался неизвестный внешний элемент ремня.Пример ошибочного кода:</target>
        </trans-unit>
        <trans-unit id="1356f6d3a3c2ce1216defe8b6863fd5e9393d5fa" translate="yes" xml:space="preserve">
          <source>An unknown field was specified into a structure.</source>
          <target state="translated">В структуру было введено неизвестное поле.</target>
        </trans-unit>
        <trans-unit id="672bd73128faa09c7f440466e9f29739ad4de42d" translate="yes" xml:space="preserve">
          <source>An unknown field was specified into an enum's structure variant.</source>
          <target state="translated">В варианте структуры перечисления было указано неизвестное поле.</target>
        </trans-unit>
        <trans-unit id="bee5691463189269e4f427b52c0849d39e9df4f5" translate="yes" xml:space="preserve">
          <source>An unknown intrinsic function was declared.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e8a840a4e189fb8e18f90b5fe877d384d51d1d3c" translate="yes" xml:space="preserve">
          <source>An unknown lint was used on the command line.</source>
          <target state="translated">В командной строке была использована неизвестная ворсинка.</target>
        </trans-unit>
        <trans-unit id="d472ec49c42739263d3ec941f6cf5b5468a2d3b2" translate="yes" xml:space="preserve">
          <source>An unknown meta item was used.</source>
          <target state="translated">Использовалась неизвестная мета-точка.</target>
        </trans-unit>
        <trans-unit id="a940cccd136dc43c95bcfd2c10667fe77e672634" translate="yes" xml:space="preserve">
          <source>An unknown predicate was used inside the &lt;code&gt;cfg&lt;/code&gt; attribute.</source>
          <target state="translated">Внутри атрибута &lt;code&gt;cfg&lt;/code&gt; был использован неизвестный предикат .</target>
        </trans-unit>
        <trans-unit id="99aaced696882b10f70ccb01859e75fc7704670e" translate="yes" xml:space="preserve">
          <source>An unknown tool name was found in a scoped lint.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="676d0b3b83f48e6af11d16fc5aee8adc4d048290" translate="yes" xml:space="preserve">
          <source>An unknown tuple struct/variant has been used.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c12ae2fbe23adbaee9a27dcd9a18b88d8f9167df" translate="yes" xml:space="preserve">
          <source>An unnamed address:</source>
          <target state="translated">Безымянный адрес:</target>
        </trans-unit>
        <trans-unit id="91f0af616d741e6aae624d3d1dd86d853eef5383" translate="yes" xml:space="preserve">
          <source>An unnecessary type or const parameter was given in a type alias.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f156b900d9fe99f8832687ac7404efd74f0ba00f" translate="yes" xml:space="preserve">
          <source>An unpoisoned &lt;a href=&quot;struct.once&quot;&gt;&lt;code&gt;Once&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3386e5166859dc07663dec10855432efda42e389" translate="yes" xml:space="preserve">
          <source>An unpoisoned &lt;code&gt;Once&lt;/code&gt;:</source>
          <target state="translated">Неотравленный &lt;code&gt;Once&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="940487cb36b1ca715dc9f782d9f8a844e917518b" translate="yes" xml:space="preserve">
          <source>An unreachable label was used.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9a03f5a8f224f5f2ce3d5df647878dfe5aac207b" translate="yes" xml:space="preserve">
          <source>An unresolved name was used.</source>
          <target state="translated">Было использовано нераскрытое имя.</target>
        </trans-unit>
        <trans-unit id="261553d92051fa692c480d6d0e6fd303bf5038fd" translate="yes" xml:space="preserve">
          <source>An unsafe trait was implemented without an unsafe implementation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="084105813293c7ee4385ace5ee9239e1a67b6d57" translate="yes" xml:space="preserve">
          <source>An unstable feature in &lt;code&gt;const&lt;/code&gt; contexts was used.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c801b4c85f18e94f7cb6ce228ae449c345e89b49" translate="yes" xml:space="preserve">
          <source>An unstable feature was used.</source>
          <target state="translated">Была использована нестабильная функция.</target>
        </trans-unit>
        <trans-unit id="2837c8cb90a7a15d78fb3ebeda3b87105514ef73" translate="yes" xml:space="preserve">
          <source>An unsupported expression was used inside a const context.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ad604b2507c78bd47c93ad249e197a918e7208ca" translate="yes" xml:space="preserve">
          <source>An unsupported representation was attempted on a zero-variant enum.</source>
          <target state="translated">В переписи с нулевым вариантом было предпринято покушение на неподтвержденное представление.</target>
        </trans-unit>
        <trans-unit id="999140d65b2dddb09bc1533f2a2a2de632081b87" translate="yes" xml:space="preserve">
          <source>Anatomy of a Rust Program</source>
          <target state="translated">Программа &quot;Анатомия ржавчины</target>
        </trans-unit>
        <trans-unit id="f96afdd93db8b2e4f4aa8b97a7ac6e4f106649a9" translate="yes" xml:space="preserve">
          <source>Ancestors</source>
          <target state="translated">Ancestors</target>
        </trans-unit>
        <trans-unit id="a69185f73b3266ea2ea0196235a7920d98b23569" translate="yes" xml:space="preserve">
          <source>Ancestors::all</source>
          <target state="translated">Ancestors::all</target>
        </trans-unit>
        <trans-unit id="5d0f93422db0f668490adf089654ecece89c57a9" translate="yes" xml:space="preserve">
          <source>Ancestors::any</source>
          <target state="translated">Ancestors::any</target>
        </trans-unit>
        <trans-unit id="c4d070344a11e561f295e6e7e6205f761d5798b6" translate="yes" xml:space="preserve">
          <source>Ancestors::borrow</source>
          <target state="translated">Ancestors::borrow</target>
        </trans-unit>
        <trans-unit id="a84c8539090bc4c2974d99b05a787e636ebe0acb" translate="yes" xml:space="preserve">
          <source>Ancestors::borrow_mut</source>
          <target state="translated">Ancestors::borrow_mut</target>
        </trans-unit>
        <trans-unit id="334238f85474f459cc0ffaef3421caf90b07c6e6" translate="yes" xml:space="preserve">
          <source>Ancestors::by_ref</source>
          <target state="translated">Ancestors::by_ref</target>
        </trans-unit>
        <trans-unit id="6fdc4e3375706d83d8aecc92a22ee70bff5dfab4" translate="yes" xml:space="preserve">
          <source>Ancestors::chain</source>
          <target state="translated">Ancestors::chain</target>
        </trans-unit>
        <trans-unit id="dce0f9cae4b8d7222a0b11c873b249cd98da26b3" translate="yes" xml:space="preserve">
          <source>Ancestors::clone</source>
          <target state="translated">Ancestors::clone</target>
        </trans-unit>
        <trans-unit id="31848f144e07d27fc7390a8c92d56ab88474c213" translate="yes" xml:space="preserve">
          <source>Ancestors::clone_from</source>
          <target state="translated">Ancestors::clone_from</target>
        </trans-unit>
        <trans-unit id="35f7611233faafb5be9d7d385104097f21e72511" translate="yes" xml:space="preserve">
          <source>Ancestors::clone_into</source>
          <target state="translated">Ancestors::clone_into</target>
        </trans-unit>
        <trans-unit id="0d02f4a4459ad43a2bc9f83a20b48ce81eb5eefc" translate="yes" xml:space="preserve">
          <source>Ancestors::cloned</source>
          <target state="translated">Ancestors::cloned</target>
        </trans-unit>
        <trans-unit id="67ff55ec2d9537e58736a03fd50c337049b761f0" translate="yes" xml:space="preserve">
          <source>Ancestors::cmp</source>
          <target state="translated">Ancestors::cmp</target>
        </trans-unit>
        <trans-unit id="0d35d199d39196de0523350cd24a1241424fa231" translate="yes" xml:space="preserve">
          <source>Ancestors::collect</source>
          <target state="translated">Ancestors::collect</target>
        </trans-unit>
        <trans-unit id="4865b6ff2a1901685d10435c12cf071b254d3a62" translate="yes" xml:space="preserve">
          <source>Ancestors::copied</source>
          <target state="translated">Ancestors::copied</target>
        </trans-unit>
        <trans-unit id="f28d6b4a44e14f0d15c4f132d556116c210c1c84" translate="yes" xml:space="preserve">
          <source>Ancestors::count</source>
          <target state="translated">Ancestors::count</target>
        </trans-unit>
        <trans-unit id="a6a740680e9008614345c582b8e1985861829875" translate="yes" xml:space="preserve">
          <source>Ancestors::cycle</source>
          <target state="translated">Ancestors::cycle</target>
        </trans-unit>
        <trans-unit id="0810bcf20fe4de2312f283ad13e930eaa61b0c30" translate="yes" xml:space="preserve">
          <source>Ancestors::enumerate</source>
          <target state="translated">Ancestors::enumerate</target>
        </trans-unit>
        <trans-unit id="f443387bf4a86a6cc1330d9f2c4d3b913b1c1dd0" translate="yes" xml:space="preserve">
          <source>Ancestors::eq</source>
          <target state="translated">Ancestors::eq</target>
        </trans-unit>
        <trans-unit id="796eb87c3af9fac554be5d4ec57ca702d510701f" translate="yes" xml:space="preserve">
          <source>Ancestors::filter</source>
          <target state="translated">Ancestors::filter</target>
        </trans-unit>
        <trans-unit id="d1822e4ea409150f5e23e24201bc84ef25560137" translate="yes" xml:space="preserve">
          <source>Ancestors::filter_map</source>
          <target state="translated">Ancestors::filter_map</target>
        </trans-unit>
        <trans-unit id="1e6cc0ef677409077aa639becd452ada01ece8d8" translate="yes" xml:space="preserve">
          <source>Ancestors::find</source>
          <target state="translated">Ancestors::find</target>
        </trans-unit>
        <trans-unit id="657aafc8bbaf8304573fbc00e24419ba040782a9" translate="yes" xml:space="preserve">
          <source>Ancestors::find_map</source>
          <target state="translated">Ancestors::find_map</target>
        </trans-unit>
        <trans-unit id="beeb7e3fb0fbc04618a5300c980c6f59ed075dcd" translate="yes" xml:space="preserve">
          <source>Ancestors::flat_map</source>
          <target state="translated">Ancestors::flat_map</target>
        </trans-unit>
        <trans-unit id="47bd10eda5c1ca25f0cc303ef197cbc1220d1b53" translate="yes" xml:space="preserve">
          <source>Ancestors::flatten</source>
          <target state="translated">Ancestors::flatten</target>
        </trans-unit>
        <trans-unit id="a456cec1879b2b70a77233841a841755191a8a86" translate="yes" xml:space="preserve">
          <source>Ancestors::fmt</source>
          <target state="translated">Ancestors::fmt</target>
        </trans-unit>
        <trans-unit id="1f02f420430d3894ec9ecddf11dd94365e77ac19" translate="yes" xml:space="preserve">
          <source>Ancestors::fold</source>
          <target state="translated">Ancestors::fold</target>
        </trans-unit>
        <trans-unit id="3ca5818636166fd5b398f8e40a922c894b0abbb6" translate="yes" xml:space="preserve">
          <source>Ancestors::for_each</source>
          <target state="translated">Ancestors::for_each</target>
        </trans-unit>
        <trans-unit id="4264a030cb324bfbad2fa80a46e42c679803a0c3" translate="yes" xml:space="preserve">
          <source>Ancestors::from</source>
          <target state="translated">Ancestors::from</target>
        </trans-unit>
        <trans-unit id="32047f73315575a8e50a462155406bb910ceed17" translate="yes" xml:space="preserve">
          <source>Ancestors::fuse</source>
          <target state="translated">Ancestors::fuse</target>
        </trans-unit>
        <trans-unit id="41f1796019df27f1dc523c24819d1254f099c660" translate="yes" xml:space="preserve">
          <source>Ancestors::ge</source>
          <target state="translated">Ancestors::ge</target>
        </trans-unit>
        <trans-unit id="f1594f0c385b82f3427f45ed26a50d1dac4fa05e" translate="yes" xml:space="preserve">
          <source>Ancestors::gt</source>
          <target state="translated">Ancestors::gt</target>
        </trans-unit>
        <trans-unit id="dd54e2ff77b477361ff6376d5b04afaad6a7ef21" translate="yes" xml:space="preserve">
          <source>Ancestors::inspect</source>
          <target state="translated">Ancestors::inspect</target>
        </trans-unit>
        <trans-unit id="1bc8d1bb95f4aedebacf2a84051d097086c1cc75" translate="yes" xml:space="preserve">
          <source>Ancestors::into</source>
          <target state="translated">Ancestors::into</target>
        </trans-unit>
        <trans-unit id="6f7bdf57cf985a0498067e483576359d43c33000" translate="yes" xml:space="preserve">
          <source>Ancestors::into_iter</source>
          <target state="translated">Ancestors::into_iter</target>
        </trans-unit>
        <trans-unit id="e4f570f8f86838a0b2f0996de24967465582d845" translate="yes" xml:space="preserve">
          <source>Ancestors::is_sorted</source>
          <target state="translated">Ancestors::is_sorted</target>
        </trans-unit>
        <trans-unit id="8fa7773f21437bd02461103d0f128fe2f328180a" translate="yes" xml:space="preserve">
          <source>Ancestors::is_sorted_by</source>
          <target state="translated">Ancestors::is_sorted_by</target>
        </trans-unit>
        <trans-unit id="da156b45c81720439526b87f492a4b80dde53f7a" translate="yes" xml:space="preserve">
          <source>Ancestors::is_sorted_by_key</source>
          <target state="translated">Ancestors::is_sorted_by_key</target>
        </trans-unit>
        <trans-unit id="6bf6d1d6ec433eb2498f88c1821e2e8d204490c9" translate="yes" xml:space="preserve">
          <source>Ancestors::last</source>
          <target state="translated">Ancestors::last</target>
        </trans-unit>
        <trans-unit id="6182ceed3235394e0830f635f2568ba50e3e7bb2" translate="yes" xml:space="preserve">
          <source>Ancestors::le</source>
          <target state="translated">Ancestors::le</target>
        </trans-unit>
        <trans-unit id="ba00a013a0f8fd57e29b01f66afccf088e1d0023" translate="yes" xml:space="preserve">
          <source>Ancestors::lt</source>
          <target state="translated">Ancestors::lt</target>
        </trans-unit>
        <trans-unit id="b588193780984cc7ebdb2f28a2c09aad1660160a" translate="yes" xml:space="preserve">
          <source>Ancestors::map</source>
          <target state="translated">Ancestors::map</target>
        </trans-unit>
        <trans-unit id="aa73ed60029c8667bd3541a6cd43b17d298a34bc" translate="yes" xml:space="preserve">
          <source>Ancestors::max</source>
          <target state="translated">Ancestors::max</target>
        </trans-unit>
        <trans-unit id="ab6d430bbae01a6904e8639546e74aa743ec4546" translate="yes" xml:space="preserve">
          <source>Ancestors::max_by</source>
          <target state="translated">Ancestors::max_by</target>
        </trans-unit>
        <trans-unit id="3f9a117ba2cfb9ce3093457ddf5a2896b25c3699" translate="yes" xml:space="preserve">
          <source>Ancestors::max_by_key</source>
          <target state="translated">Ancestors::max_by_key</target>
        </trans-unit>
        <trans-unit id="d86ac9020bc2e94f4de10dd0521bc6648555300a" translate="yes" xml:space="preserve">
          <source>Ancestors::min</source>
          <target state="translated">Ancestors::min</target>
        </trans-unit>
        <trans-unit id="d1a3237b0f7d1400e70026876d1a9e1edfd954fb" translate="yes" xml:space="preserve">
          <source>Ancestors::min_by</source>
          <target state="translated">Ancestors::min_by</target>
        </trans-unit>
        <trans-unit id="4a76ef60a157a414e53965e7b20bdb80a42a93c5" translate="yes" xml:space="preserve">
          <source>Ancestors::min_by_key</source>
          <target state="translated">Ancestors::min_by_key</target>
        </trans-unit>
        <trans-unit id="5d2760f02e37aabc523ea5766e6897c5ccc56a0b" translate="yes" xml:space="preserve">
          <source>Ancestors::ne</source>
          <target state="translated">Ancestors::ne</target>
        </trans-unit>
        <trans-unit id="94b5fbd4a6186842bbae09888725d74af29ff76c" translate="yes" xml:space="preserve">
          <source>Ancestors::next</source>
          <target state="translated">Ancestors::next</target>
        </trans-unit>
        <trans-unit id="061044f738cb0378794d00307372b84bda535007" translate="yes" xml:space="preserve">
          <source>Ancestors::nth</source>
          <target state="translated">Ancestors::nth</target>
        </trans-unit>
        <trans-unit id="104a8aab4cf5a11201b887398168f2f5e1f87087" translate="yes" xml:space="preserve">
          <source>Ancestors::partial_cmp</source>
          <target state="translated">Ancestors::partial_cmp</target>
        </trans-unit>
        <trans-unit id="bed7abfd1f96e21405eb173c4d15c03b456d92a5" translate="yes" xml:space="preserve">
          <source>Ancestors::partition</source>
          <target state="translated">Ancestors::partition</target>
        </trans-unit>
        <trans-unit id="84cd0d32c4daeda367ba0a2ae2e2b6a7ff4841da" translate="yes" xml:space="preserve">
          <source>Ancestors::peekable</source>
          <target state="translated">Ancestors::peekable</target>
        </trans-unit>
        <trans-unit id="b4ddc60ef630227f7ade5b8c560fef259500316e" translate="yes" xml:space="preserve">
          <source>Ancestors::position</source>
          <target state="translated">Ancestors::position</target>
        </trans-unit>
        <trans-unit id="7a31ee815f86cdd427869f86ea4e16e837ac74a5" translate="yes" xml:space="preserve">
          <source>Ancestors::product</source>
          <target state="translated">Ancestors::product</target>
        </trans-unit>
        <trans-unit id="b560f4cdd9c918e68c647f28819fc526f4443425" translate="yes" xml:space="preserve">
          <source>Ancestors::rev</source>
          <target state="translated">Ancestors::rev</target>
        </trans-unit>
        <trans-unit id="2d6150b963da3a5f8bb4fbcf3bede9ac1d149eac" translate="yes" xml:space="preserve">
          <source>Ancestors::rposition</source>
          <target state="translated">Ancestors::rposition</target>
        </trans-unit>
        <trans-unit id="33695d4fc7bd02cc81076a7f065f59ae331ce9d8" translate="yes" xml:space="preserve">
          <source>Ancestors::scan</source>
          <target state="translated">Ancestors::scan</target>
        </trans-unit>
        <trans-unit id="a71e116d1152775af982054ee8766888b8c17bf5" translate="yes" xml:space="preserve">
          <source>Ancestors::size_hint</source>
          <target state="translated">Ancestors::size_hint</target>
        </trans-unit>
        <trans-unit id="1492747daf21eb6d17932ae78e4e1bb6900ec817" translate="yes" xml:space="preserve">
          <source>Ancestors::skip</source>
          <target state="translated">Ancestors::skip</target>
        </trans-unit>
        <trans-unit id="7ccb1c50d003cbcf82f746c7c89b476d0db40ef9" translate="yes" xml:space="preserve">
          <source>Ancestors::skip_while</source>
          <target state="translated">Ancestors::skip_while</target>
        </trans-unit>
        <trans-unit id="2d680c75e7e0a20bba67113ba634c0b9819ec275" translate="yes" xml:space="preserve">
          <source>Ancestors::step_by</source>
          <target state="translated">Ancestors::step_by</target>
        </trans-unit>
        <trans-unit id="bb4081cc4c0735468e080f3f00abdd7bfc4c7b73" translate="yes" xml:space="preserve">
          <source>Ancestors::sum</source>
          <target state="translated">Ancestors::sum</target>
        </trans-unit>
        <trans-unit id="b184ac7bf98e724a647631566c8e7b44261ba11d" translate="yes" xml:space="preserve">
          <source>Ancestors::take</source>
          <target state="translated">Ancestors::take</target>
        </trans-unit>
        <trans-unit id="551d6d8baae9a0ead4f49097f5951591191f29fd" translate="yes" xml:space="preserve">
          <source>Ancestors::take_while</source>
          <target state="translated">Ancestors::take_while</target>
        </trans-unit>
        <trans-unit id="f38b2d2e57427d6c5d34e24a9e37978f181043c7" translate="yes" xml:space="preserve">
          <source>Ancestors::to_owned</source>
          <target state="translated">Ancestors::to_owned</target>
        </trans-unit>
        <trans-unit id="bd8e948ee34c84cdc8f1385bf9b2d83abdbf9fb4" translate="yes" xml:space="preserve">
          <source>Ancestors::try_fold</source>
          <target state="translated">Ancestors::try_fold</target>
        </trans-unit>
        <trans-unit id="46ad3f23b6a14805c5bb02a0abccbaa9ad1f0c58" translate="yes" xml:space="preserve">
          <source>Ancestors::try_for_each</source>
          <target state="translated">Ancestors::try_for_each</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
