<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ru" datatype="htmlbody" original="rust">
    <body>
      <group id="rust">
        <trans-unit id="98d2de96a420de7658219d3f9bda5b24ca2443f7" translate="yes" xml:space="preserve">
          <source>Args::rfind</source>
          <target state="translated">Args::rfind</target>
        </trans-unit>
        <trans-unit id="3cc34e3e8eb1da327b82585d5a13fd8b2bb5890e" translate="yes" xml:space="preserve">
          <source>Args::rfold</source>
          <target state="translated">Args::rfold</target>
        </trans-unit>
        <trans-unit id="3a7a7236e75fdfae5572db48f2aad6e6378da2eb" translate="yes" xml:space="preserve">
          <source>Args::rposition</source>
          <target state="translated">Args::rposition</target>
        </trans-unit>
        <trans-unit id="9fc0f79d5cd6405747d8f5be32af5064749f81b9" translate="yes" xml:space="preserve">
          <source>Args::scan</source>
          <target state="translated">Args::scan</target>
        </trans-unit>
        <trans-unit id="12148001c865165a5de07ba3c727c97aab92c761" translate="yes" xml:space="preserve">
          <source>Args::size_hint</source>
          <target state="translated">Args::size_hint</target>
        </trans-unit>
        <trans-unit id="1189df09a529d4be32c97dfca9793d84611fd824" translate="yes" xml:space="preserve">
          <source>Args::skip</source>
          <target state="translated">Args::skip</target>
        </trans-unit>
        <trans-unit id="764acccc052619da2c47813fd259dab289d9bd67" translate="yes" xml:space="preserve">
          <source>Args::skip_while</source>
          <target state="translated">Args::skip_while</target>
        </trans-unit>
        <trans-unit id="904035ea6ead93ad6bd21ffe6010b797797cfccb" translate="yes" xml:space="preserve">
          <source>Args::step_by</source>
          <target state="translated">Args::step_by</target>
        </trans-unit>
        <trans-unit id="d5a7f219c1fc0a0f719ef62e5e91b056ae17a132" translate="yes" xml:space="preserve">
          <source>Args::sum</source>
          <target state="translated">Args::sum</target>
        </trans-unit>
        <trans-unit id="27af1223e3252d8316e5510ef65c11dd18e7e048" translate="yes" xml:space="preserve">
          <source>Args::take</source>
          <target state="translated">Args::take</target>
        </trans-unit>
        <trans-unit id="70510b85e050ccfd0ca156b8552398d830c8ca29" translate="yes" xml:space="preserve">
          <source>Args::take_while</source>
          <target state="translated">Args::take_while</target>
        </trans-unit>
        <trans-unit id="29671ebf88bfe467b330af20810dd95f14bee716" translate="yes" xml:space="preserve">
          <source>Args::try_fold</source>
          <target state="translated">Args::try_fold</target>
        </trans-unit>
        <trans-unit id="11314668861a5fe3812661a0778a42dd4d60ecc6" translate="yes" xml:space="preserve">
          <source>Args::try_for_each</source>
          <target state="translated">Args::try_for_each</target>
        </trans-unit>
        <trans-unit id="a3e7a43251306d98977b3648cb61a36b6b67f71f" translate="yes" xml:space="preserve">
          <source>Args::try_from</source>
          <target state="translated">Args::try_from</target>
        </trans-unit>
        <trans-unit id="ea7b4151424c750739941030cbfa813500f83861" translate="yes" xml:space="preserve">
          <source>Args::try_into</source>
          <target state="translated">Args::try_into</target>
        </trans-unit>
        <trans-unit id="a09bc59807578d3bfcb3f5e6f7f7b11ca71a5fda" translate="yes" xml:space="preserve">
          <source>Args::try_rfold</source>
          <target state="translated">Args::try_rfold</target>
        </trans-unit>
        <trans-unit id="ef5ea75da51804787206df18b378f5490fe6418b" translate="yes" xml:space="preserve">
          <source>Args::type_id</source>
          <target state="translated">Args::type_id</target>
        </trans-unit>
        <trans-unit id="3e828aa1b5449d683bef869c26ce0986ec45e670" translate="yes" xml:space="preserve">
          <source>Args::unzip</source>
          <target state="translated">Args::unzip</target>
        </trans-unit>
        <trans-unit id="468f2b4280fd073d79df60860923a06807813556" translate="yes" xml:space="preserve">
          <source>Args::zip</source>
          <target state="translated">Args::zip</target>
        </trans-unit>
        <trans-unit id="08a635e24e7197ec936245f74886d0fae256f6f3" translate="yes" xml:space="preserve">
          <source>ArgsOs</source>
          <target state="translated">ArgsOs</target>
        </trans-unit>
        <trans-unit id="1699d7288d57eee287607a5a8cf4daa06cbf36b5" translate="yes" xml:space="preserve">
          <source>ArgsOs::all</source>
          <target state="translated">ArgsOs::all</target>
        </trans-unit>
        <trans-unit id="1845d364695de9046a1a2e308d836950518c8379" translate="yes" xml:space="preserve">
          <source>ArgsOs::any</source>
          <target state="translated">ArgsOs::any</target>
        </trans-unit>
        <trans-unit id="b88db8b95877207b42c5e88cfc5b222b32d38f42" translate="yes" xml:space="preserve">
          <source>ArgsOs::borrow</source>
          <target state="translated">ArgsOs::borrow</target>
        </trans-unit>
        <trans-unit id="6883c744eb4014b5c2b448f2adc1b25a04e5fc9e" translate="yes" xml:space="preserve">
          <source>ArgsOs::borrow_mut</source>
          <target state="translated">ArgsOs::borrow_mut</target>
        </trans-unit>
        <trans-unit id="54a7160bba6f31fb20a2a3b6f79944613335629e" translate="yes" xml:space="preserve">
          <source>ArgsOs::by_ref</source>
          <target state="translated">ArgsOs::by_ref</target>
        </trans-unit>
        <trans-unit id="45e9d062b28c81d2586823abf5265cf79f0f53c3" translate="yes" xml:space="preserve">
          <source>ArgsOs::chain</source>
          <target state="translated">ArgsOs::chain</target>
        </trans-unit>
        <trans-unit id="06a86328c3295b9577a55fd6532e3d512a4376ad" translate="yes" xml:space="preserve">
          <source>ArgsOs::cloned</source>
          <target state="translated">ArgsOs::cloned</target>
        </trans-unit>
        <trans-unit id="aa33a26c7a85d39e633ece2b7ab215364fa8c21f" translate="yes" xml:space="preserve">
          <source>ArgsOs::cmp</source>
          <target state="translated">ArgsOs::cmp</target>
        </trans-unit>
        <trans-unit id="4444bf776c1fcbbef6e3005b548a29289b32ecc4" translate="yes" xml:space="preserve">
          <source>ArgsOs::collect</source>
          <target state="translated">ArgsOs::collect</target>
        </trans-unit>
        <trans-unit id="efa527796ad53e7b95c87dfbab81f527bd59777a" translate="yes" xml:space="preserve">
          <source>ArgsOs::copied</source>
          <target state="translated">ArgsOs::copied</target>
        </trans-unit>
        <trans-unit id="cf8617f607b90e848c8eda2dcecf733646bd740b" translate="yes" xml:space="preserve">
          <source>ArgsOs::count</source>
          <target state="translated">ArgsOs::count</target>
        </trans-unit>
        <trans-unit id="9774f0ee5373559d8ebaf6e270d32276c2460f0f" translate="yes" xml:space="preserve">
          <source>ArgsOs::cycle</source>
          <target state="translated">ArgsOs::cycle</target>
        </trans-unit>
        <trans-unit id="0c42cc7e9e0e5f5dcbc76f351e7fb1817634bb40" translate="yes" xml:space="preserve">
          <source>ArgsOs::enumerate</source>
          <target state="translated">ArgsOs::enumerate</target>
        </trans-unit>
        <trans-unit id="d5b0b5b450101b6daed6089615021285ab2aa9bc" translate="yes" xml:space="preserve">
          <source>ArgsOs::eq</source>
          <target state="translated">ArgsOs::eq</target>
        </trans-unit>
        <trans-unit id="22ebb6f40c3d512ac39613bf4969beaa463bb89c" translate="yes" xml:space="preserve">
          <source>ArgsOs::filter</source>
          <target state="translated">ArgsOs::filter</target>
        </trans-unit>
        <trans-unit id="ec9b19d64b96da14ed417d0d212d3d54ea4a4759" translate="yes" xml:space="preserve">
          <source>ArgsOs::filter_map</source>
          <target state="translated">ArgsOs::filter_map</target>
        </trans-unit>
        <trans-unit id="f90d91bcb86730d9c77f4746181813b55b242a5f" translate="yes" xml:space="preserve">
          <source>ArgsOs::find</source>
          <target state="translated">ArgsOs::find</target>
        </trans-unit>
        <trans-unit id="8c42c2da49296751bd09d90e62d79798dd8f5449" translate="yes" xml:space="preserve">
          <source>ArgsOs::find_map</source>
          <target state="translated">ArgsOs::find_map</target>
        </trans-unit>
        <trans-unit id="8ae8230900a56717520df737b9d2946aa58958f4" translate="yes" xml:space="preserve">
          <source>ArgsOs::flat_map</source>
          <target state="translated">ArgsOs::flat_map</target>
        </trans-unit>
        <trans-unit id="582b0a8882844e707b1b16686981fe8a3215c0f7" translate="yes" xml:space="preserve">
          <source>ArgsOs::flatten</source>
          <target state="translated">ArgsOs::flatten</target>
        </trans-unit>
        <trans-unit id="42a3165a3645e00a5c082e56522288eb3545955a" translate="yes" xml:space="preserve">
          <source>ArgsOs::fmt</source>
          <target state="translated">ArgsOs::fmt</target>
        </trans-unit>
        <trans-unit id="c973a490f8d75776d7cc21ebc26d8640412d8da5" translate="yes" xml:space="preserve">
          <source>ArgsOs::fold</source>
          <target state="translated">ArgsOs::fold</target>
        </trans-unit>
        <trans-unit id="521243a10a5ee6932b3c00a38bb64a1066346423" translate="yes" xml:space="preserve">
          <source>ArgsOs::for_each</source>
          <target state="translated">ArgsOs::for_each</target>
        </trans-unit>
        <trans-unit id="b3beb1c32ac134bd58a5525cb75b6818caadc2e7" translate="yes" xml:space="preserve">
          <source>ArgsOs::from</source>
          <target state="translated">ArgsOs::from</target>
        </trans-unit>
        <trans-unit id="0467b6e7a5907960746adb88f1797855273e5e38" translate="yes" xml:space="preserve">
          <source>ArgsOs::fuse</source>
          <target state="translated">ArgsOs::fuse</target>
        </trans-unit>
        <trans-unit id="8d918573a70aed631b8ef7e464f6978aeac45512" translate="yes" xml:space="preserve">
          <source>ArgsOs::ge</source>
          <target state="translated">ArgsOs::ge</target>
        </trans-unit>
        <trans-unit id="ed7bd18154ad5939e8306b095fe2d6551d9c5960" translate="yes" xml:space="preserve">
          <source>ArgsOs::gt</source>
          <target state="translated">ArgsOs::gt</target>
        </trans-unit>
        <trans-unit id="f6ab996f18c666c657723e3d6b826e9d4f34afa4" translate="yes" xml:space="preserve">
          <source>ArgsOs::inspect</source>
          <target state="translated">ArgsOs::inspect</target>
        </trans-unit>
        <trans-unit id="118a0e4c62985069de5d564f7e5aeaefdb4f3eee" translate="yes" xml:space="preserve">
          <source>ArgsOs::into</source>
          <target state="translated">ArgsOs::into</target>
        </trans-unit>
        <trans-unit id="6fe469f351f3d71c45f5b8b8a01a85ba417f2962" translate="yes" xml:space="preserve">
          <source>ArgsOs::into_iter</source>
          <target state="translated">ArgsOs::into_iter</target>
        </trans-unit>
        <trans-unit id="52e21117a73746309084ded1b85082f14e2f4f3c" translate="yes" xml:space="preserve">
          <source>ArgsOs::is_empty</source>
          <target state="translated">ArgsOs::is_empty</target>
        </trans-unit>
        <trans-unit id="bc22f51d728c32072e58dab02dc3f74a273221da" translate="yes" xml:space="preserve">
          <source>ArgsOs::is_sorted</source>
          <target state="translated">ArgsOs::is_sorted</target>
        </trans-unit>
        <trans-unit id="6ce480c601285e3d630fdd46e557dfb3c792fc47" translate="yes" xml:space="preserve">
          <source>ArgsOs::is_sorted_by</source>
          <target state="translated">ArgsOs::is_sorted_by</target>
        </trans-unit>
        <trans-unit id="1bd6484be8e79119af4f357c6727e9cce127bfb7" translate="yes" xml:space="preserve">
          <source>ArgsOs::is_sorted_by_key</source>
          <target state="translated">ArgsOs::is_sorted_by_key</target>
        </trans-unit>
        <trans-unit id="2960d55410634dcaa01ebfd4efb87d3210b4b30b" translate="yes" xml:space="preserve">
          <source>ArgsOs::last</source>
          <target state="translated">ArgsOs::last</target>
        </trans-unit>
        <trans-unit id="49cd1005a59ab868a13fc3b698fa037af9e3cc25" translate="yes" xml:space="preserve">
          <source>ArgsOs::le</source>
          <target state="translated">ArgsOs::le</target>
        </trans-unit>
        <trans-unit id="9662bed516b84aec77303964e4aba365d517a6ce" translate="yes" xml:space="preserve">
          <source>ArgsOs::len</source>
          <target state="translated">ArgsOs::len</target>
        </trans-unit>
        <trans-unit id="a4fd3a509313cc726b4eb5e364e66dd0311cbccc" translate="yes" xml:space="preserve">
          <source>ArgsOs::lt</source>
          <target state="translated">ArgsOs::lt</target>
        </trans-unit>
        <trans-unit id="b4ee6f488be886ab0828730edfa187e1158ffbf4" translate="yes" xml:space="preserve">
          <source>ArgsOs::map</source>
          <target state="translated">ArgsOs::map</target>
        </trans-unit>
        <trans-unit id="ae8b8dee55299bdeb6e240152d7d260302e580f0" translate="yes" xml:space="preserve">
          <source>ArgsOs::max</source>
          <target state="translated">ArgsOs::max</target>
        </trans-unit>
        <trans-unit id="f393dc70d5755703ad87bcd703e01acde42fd52e" translate="yes" xml:space="preserve">
          <source>ArgsOs::max_by</source>
          <target state="translated">ArgsOs::max_by</target>
        </trans-unit>
        <trans-unit id="c3d12b23ad084b94bc1bb5877f3a0e669b6dcbe5" translate="yes" xml:space="preserve">
          <source>ArgsOs::max_by_key</source>
          <target state="translated">ArgsOs::max_by_key</target>
        </trans-unit>
        <trans-unit id="1877909fb92070e732d578d5a61015d6567d1c05" translate="yes" xml:space="preserve">
          <source>ArgsOs::min</source>
          <target state="translated">ArgsOs::min</target>
        </trans-unit>
        <trans-unit id="1b9560ee3684ef678a7f2060396e14192ebd977a" translate="yes" xml:space="preserve">
          <source>ArgsOs::min_by</source>
          <target state="translated">ArgsOs::min_by</target>
        </trans-unit>
        <trans-unit id="ce07e6453a52864ecbf5f176d284c9622c84c927" translate="yes" xml:space="preserve">
          <source>ArgsOs::min_by_key</source>
          <target state="translated">ArgsOs::min_by_key</target>
        </trans-unit>
        <trans-unit id="77abc8099c1b361ea642538729c1cfa9c4ad2af8" translate="yes" xml:space="preserve">
          <source>ArgsOs::ne</source>
          <target state="translated">ArgsOs::ne</target>
        </trans-unit>
        <trans-unit id="94df206ce16974feea2fee745eeb9bededb98233" translate="yes" xml:space="preserve">
          <source>ArgsOs::next</source>
          <target state="translated">ArgsOs::next</target>
        </trans-unit>
        <trans-unit id="0b4bd6a54c1bdb1cb1c37909c4bbdf8ee8eedba4" translate="yes" xml:space="preserve">
          <source>ArgsOs::next_back</source>
          <target state="translated">ArgsOs::next_back</target>
        </trans-unit>
        <trans-unit id="32001a37fe7fa6c38a9dab6e3ccac83215a6af0b" translate="yes" xml:space="preserve">
          <source>ArgsOs::nth</source>
          <target state="translated">ArgsOs::nth</target>
        </trans-unit>
        <trans-unit id="eed0fe5e0346646ed8f493e45f87707e6ef665d0" translate="yes" xml:space="preserve">
          <source>ArgsOs::nth_back</source>
          <target state="translated">ArgsOs::nth_back</target>
        </trans-unit>
        <trans-unit id="76d2262b3586a0b114f133d396c15e36cdbd64ee" translate="yes" xml:space="preserve">
          <source>ArgsOs::partial_cmp</source>
          <target state="translated">ArgsOs::partial_cmp</target>
        </trans-unit>
        <trans-unit id="c88ee3f44d1aaf87a7e7075664272abea7e57c22" translate="yes" xml:space="preserve">
          <source>ArgsOs::partition</source>
          <target state="translated">ArgsOs::partition</target>
        </trans-unit>
        <trans-unit id="b772163bfba047ed1ad9679588037cc0b2a982a9" translate="yes" xml:space="preserve">
          <source>ArgsOs::peekable</source>
          <target state="translated">ArgsOs::peekable</target>
        </trans-unit>
        <trans-unit id="28f42c15452e45ff29cd38077309d81cd1bf23ef" translate="yes" xml:space="preserve">
          <source>ArgsOs::position</source>
          <target state="translated">ArgsOs::position</target>
        </trans-unit>
        <trans-unit id="9c54799fe9d66e9fe809d53c0ad35f91d0345b2d" translate="yes" xml:space="preserve">
          <source>ArgsOs::product</source>
          <target state="translated">ArgsOs::product</target>
        </trans-unit>
        <trans-unit id="24d0c67c7635532e04027af92577d329d52e0d8d" translate="yes" xml:space="preserve">
          <source>ArgsOs::rev</source>
          <target state="translated">ArgsOs::rev</target>
        </trans-unit>
        <trans-unit id="9a893fd65a1fd7e4f90c4c16dad18ae09e1e6440" translate="yes" xml:space="preserve">
          <source>ArgsOs::rfind</source>
          <target state="translated">ArgsOs::rfind</target>
        </trans-unit>
        <trans-unit id="2473c6d05109d83b7921dc7c8d9e3fd3e1540366" translate="yes" xml:space="preserve">
          <source>ArgsOs::rfold</source>
          <target state="translated">ArgsOs::rfold</target>
        </trans-unit>
        <trans-unit id="61e2d2493b8b480b1c184877bc7c4508f85f3e68" translate="yes" xml:space="preserve">
          <source>ArgsOs::rposition</source>
          <target state="translated">ArgsOs::rposition</target>
        </trans-unit>
        <trans-unit id="f7c9d7d4183c0e1185d8f756359b7aa52e99dec6" translate="yes" xml:space="preserve">
          <source>ArgsOs::scan</source>
          <target state="translated">ArgsOs::scan</target>
        </trans-unit>
        <trans-unit id="be9f72e6896d64043f92118bf0351dd06875451e" translate="yes" xml:space="preserve">
          <source>ArgsOs::size_hint</source>
          <target state="translated">ArgsOs::size_hint</target>
        </trans-unit>
        <trans-unit id="dfcbf514097e12c73f97a48d644499d52e01f449" translate="yes" xml:space="preserve">
          <source>ArgsOs::skip</source>
          <target state="translated">ArgsOs::skip</target>
        </trans-unit>
        <trans-unit id="b5cea38564a840936b5adf617a54cb9e1705e9a4" translate="yes" xml:space="preserve">
          <source>ArgsOs::skip_while</source>
          <target state="translated">ArgsOs::skip_while</target>
        </trans-unit>
        <trans-unit id="bd31eff15f1513280f3660b278f44b8403fe5bb7" translate="yes" xml:space="preserve">
          <source>ArgsOs::step_by</source>
          <target state="translated">ArgsOs::step_by</target>
        </trans-unit>
        <trans-unit id="b896b50f4e9946df9f811558add55e6c7f4d9c0e" translate="yes" xml:space="preserve">
          <source>ArgsOs::sum</source>
          <target state="translated">ArgsOs::sum</target>
        </trans-unit>
        <trans-unit id="55f7ee9ef7a277d1da50d3847c5267d10c02f3d6" translate="yes" xml:space="preserve">
          <source>ArgsOs::take</source>
          <target state="translated">ArgsOs::take</target>
        </trans-unit>
        <trans-unit id="67ae1d83993d54c201cebc7e961a4745875403a9" translate="yes" xml:space="preserve">
          <source>ArgsOs::take_while</source>
          <target state="translated">ArgsOs::take_while</target>
        </trans-unit>
        <trans-unit id="6feaa7bb16a2f86b2de35c4152c898840e5c73a7" translate="yes" xml:space="preserve">
          <source>ArgsOs::try_fold</source>
          <target state="translated">ArgsOs::try_fold</target>
        </trans-unit>
        <trans-unit id="4de4927e12902d929342841a0f0a05adc02a2b88" translate="yes" xml:space="preserve">
          <source>ArgsOs::try_for_each</source>
          <target state="translated">ArgsOs::try_for_each</target>
        </trans-unit>
        <trans-unit id="ef2e8777c2c6780af369e18d8923c4a5b07b73cc" translate="yes" xml:space="preserve">
          <source>ArgsOs::try_from</source>
          <target state="translated">ArgsOs::try_from</target>
        </trans-unit>
        <trans-unit id="dde21f1986a82cfe6d32ebda71aaf8cffb865725" translate="yes" xml:space="preserve">
          <source>ArgsOs::try_into</source>
          <target state="translated">ArgsOs::try_into</target>
        </trans-unit>
        <trans-unit id="752061f583e2a023f82e25f293fbc12638874e24" translate="yes" xml:space="preserve">
          <source>ArgsOs::try_rfold</source>
          <target state="translated">ArgsOs::try_rfold</target>
        </trans-unit>
        <trans-unit id="9cea18d9f52cf4e66c35caae6f3a3d7426f8ebf1" translate="yes" xml:space="preserve">
          <source>ArgsOs::type_id</source>
          <target state="translated">ArgsOs::type_id</target>
        </trans-unit>
        <trans-unit id="dcc7a51ed1d3dac6d37f7b6f7415fe425b54aac1" translate="yes" xml:space="preserve">
          <source>ArgsOs::unzip</source>
          <target state="translated">ArgsOs::unzip</target>
        </trans-unit>
        <trans-unit id="0477d6e4f174e07114d3143d029569031152c407" translate="yes" xml:space="preserve">
          <source>ArgsOs::zip</source>
          <target state="translated">ArgsOs::zip</target>
        </trans-unit>
        <trans-unit id="bd7faaad666e01c1bc85c0559542193db97f87bb" translate="yes" xml:space="preserve">
          <source>Argument and element separator</source>
          <target state="translated">Сепаратор аргументов и элементов</target>
        </trans-unit>
        <trans-unit id="0e653d9296c0f3183cfcfa59576a82649ae7862d" translate="yes" xml:space="preserve">
          <source>Argument types</source>
          <target state="translated">Виды аргументов</target>
        </trans-unit>
        <trans-unit id="cbb9fa252e60809efa55a7ad83aea5438ef56753" translate="yes" xml:space="preserve">
          <source>Arguments</source>
          <target state="translated">Arguments</target>
        </trans-unit>
        <trans-unit id="a3115a849e9a8fd08f66c020b31248aefac3bb62" translate="yes" xml:space="preserve">
          <source>Arguments for function calls</source>
          <target state="translated">Аргументы для вызова функций</target>
        </trans-unit>
        <trans-unit id="599f9cef30e51c86c0307365f585d93f4615d4d0" translate="yes" xml:space="preserve">
          <source>Arguments passed to &lt;code&gt;map_or&lt;/code&gt; are eagerly evaluated; if you are passing the result of a function call, it is recommended to use &lt;a href=&quot;enum.option#method.map_or_else&quot;&gt;&lt;code&gt;map_or_else&lt;/code&gt;&lt;/a&gt;, which is lazily evaluated.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f0b13e1e9de1f734ef5d809e601926031419d1d8" translate="yes" xml:space="preserve">
          <source>Arguments passed to &lt;code&gt;map_or&lt;/code&gt; are eagerly evaluated; if you are passing the result of a function call, it is recommended to use &lt;a href=&quot;enum.result#method.map_or_else&quot;&gt;&lt;code&gt;map_or_else&lt;/code&gt;&lt;/a&gt;, which is lazily evaluated.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="60b48e4141151169e113485ecab80a4bb3c30bdc" translate="yes" xml:space="preserve">
          <source>Arguments passed to &lt;code&gt;ok_or&lt;/code&gt; are eagerly evaluated; if you are passing the result of a function call, it is recommended to use &lt;a href=&quot;#method.ok_or_else&quot;&gt;&lt;code&gt;ok_or_else&lt;/code&gt;&lt;/a&gt;, which is lazily evaluated.</source>
          <target state="translated">Аргументы, переданные в &lt;code&gt;ok_or&lt;/code&gt; ,быстро оцениваются; если вы передаете результат вызова функции, рекомендуется использовать &lt;a href=&quot;#method.ok_or_else&quot;&gt; &lt;code&gt;ok_or_else&lt;/code&gt; &lt;/a&gt; , который вычисляется лениво.</target>
        </trans-unit>
        <trans-unit id="c72e63e8acf76e2210299bb8523a4d987e02e598" translate="yes" xml:space="preserve">
          <source>Arguments passed to &lt;code&gt;ok_or&lt;/code&gt; are eagerly evaluated; if you are passing the result of a function call, it is recommended to use &lt;a href=&quot;enum.option#method.ok_or_else&quot;&gt;&lt;code&gt;ok_or_else&lt;/code&gt;&lt;/a&gt;, which is lazily evaluated.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b34ba4a25e5cb9253c52e9c96f12b4a3b5b442c1" translate="yes" xml:space="preserve">
          <source>Arguments passed to &lt;code&gt;or&lt;/code&gt; are eagerly evaluated; if you are passing the result of a function call, it is recommended to use &lt;a href=&quot;#method.or_else&quot;&gt;&lt;code&gt;or_else&lt;/code&gt;&lt;/a&gt;, which is lazily evaluated.</source>
          <target state="translated">Аргументы передаются &lt;code&gt;or&lt;/code&gt; активно оцениваются; если вы передаете результат вызова функции, рекомендуется использовать &lt;a href=&quot;#method.or_else&quot;&gt; &lt;code&gt;or_else&lt;/code&gt; &lt;/a&gt; , которое вычисляется лениво.</target>
        </trans-unit>
        <trans-unit id="e8e3ad3f9d440f41a4bced3ec981aa2d05bd534c" translate="yes" xml:space="preserve">
          <source>Arguments passed to &lt;code&gt;or&lt;/code&gt; are eagerly evaluated; if you are passing the result of a function call, it is recommended to use &lt;a href=&quot;enum.option#method.or_else&quot;&gt;&lt;code&gt;or_else&lt;/code&gt;&lt;/a&gt;, which is lazily evaluated.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3fb2e5d47e33897712d4dff15280a3a0c997b492" translate="yes" xml:space="preserve">
          <source>Arguments passed to &lt;code&gt;or&lt;/code&gt; are eagerly evaluated; if you are passing the result of a function call, it is recommended to use &lt;a href=&quot;enum.result#method.or_else&quot;&gt;&lt;code&gt;or_else&lt;/code&gt;&lt;/a&gt;, which is lazily evaluated.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="81e7e0f40306bc29fb2793ce221652d077995d0b" translate="yes" xml:space="preserve">
          <source>Arguments passed to &lt;code&gt;unwrap_or&lt;/code&gt; are eagerly evaluated; if you are passing the result of a function call, it is recommended to use &lt;a href=&quot;#method.unwrap_or_else&quot;&gt;&lt;code&gt;unwrap_or_else&lt;/code&gt;&lt;/a&gt;, which is lazily evaluated.</source>
          <target state="translated">Аргументы, переданные в &lt;code&gt;unwrap_or&lt;/code&gt; ,быстро оцениваются; если вы передаете результат вызова функции, рекомендуется использовать &lt;a href=&quot;#method.unwrap_or_else&quot;&gt; &lt;code&gt;unwrap_or_else&lt;/code&gt; &lt;/a&gt; , который вычисляется лениво.</target>
        </trans-unit>
        <trans-unit id="15ac6e3ce55f8f212059dc3a36cc981d9be8aca1" translate="yes" xml:space="preserve">
          <source>Arguments passed to &lt;code&gt;unwrap_or&lt;/code&gt; are eagerly evaluated; if you are passing the result of a function call, it is recommended to use &lt;a href=&quot;enum.option#method.unwrap_or_else&quot;&gt;&lt;code&gt;unwrap_or_else&lt;/code&gt;&lt;/a&gt;, which is lazily evaluated.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="935c37b281819663d093edd0e6a0df21fc148074" translate="yes" xml:space="preserve">
          <source>Arguments passed to &lt;code&gt;unwrap_or&lt;/code&gt; are eagerly evaluated; if you are passing the result of a function call, it is recommended to use &lt;a href=&quot;enum.result#method.unwrap_or_else&quot;&gt;&lt;code&gt;unwrap_or_else&lt;/code&gt;&lt;/a&gt;, which is lazily evaluated.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ca682bb604cd951faf7e687e9dc577ccfb4ccbcc" translate="yes" xml:space="preserve">
          <source>Arguments::borrow</source>
          <target state="translated">Arguments::borrow</target>
        </trans-unit>
        <trans-unit id="02b0d59380fa1adbbfa0a4e488839d014c6a84b9" translate="yes" xml:space="preserve">
          <source>Arguments::borrow_mut</source>
          <target state="translated">Arguments::borrow_mut</target>
        </trans-unit>
        <trans-unit id="beee63977406683694c63c877a281368e8498185" translate="yes" xml:space="preserve">
          <source>Arguments::clone</source>
          <target state="translated">Arguments::clone</target>
        </trans-unit>
        <trans-unit id="9b4336ed72fcc8790d465ff622f1ee33ef64dd5f" translate="yes" xml:space="preserve">
          <source>Arguments::clone_from</source>
          <target state="translated">Arguments::clone_from</target>
        </trans-unit>
        <trans-unit id="9f534ce31b28796358e33f058c8f30771441c413" translate="yes" xml:space="preserve">
          <source>Arguments::clone_into</source>
          <target state="translated">Arguments::clone_into</target>
        </trans-unit>
        <trans-unit id="e2264984672013569ff3cb5667d1fb059d3a9aff" translate="yes" xml:space="preserve">
          <source>Arguments::fmt</source>
          <target state="translated">Arguments::fmt</target>
        </trans-unit>
        <trans-unit id="e6967e42010df585387f1e1ee0a1ddd2861644a6" translate="yes" xml:space="preserve">
          <source>Arguments::from</source>
          <target state="translated">Arguments::from</target>
        </trans-unit>
        <trans-unit id="f7110cbfaa9d19f7a1a5d2f96c337419907bb156" translate="yes" xml:space="preserve">
          <source>Arguments::into</source>
          <target state="translated">Arguments::into</target>
        </trans-unit>
        <trans-unit id="f71fad745c8ecba4adbbf940ce0a934c1bbb9409" translate="yes" xml:space="preserve">
          <source>Arguments::to_owned</source>
          <target state="translated">Arguments::to_owned</target>
        </trans-unit>
        <trans-unit id="2f1106daf75575ebf9ff5096d88d4bd32bee8e3a" translate="yes" xml:space="preserve">
          <source>Arguments::to_string</source>
          <target state="translated">Arguments::to_string</target>
        </trans-unit>
        <trans-unit id="44514fad8f521c67acba588fe00d7592016a908f" translate="yes" xml:space="preserve">
          <source>Arguments::try_from</source>
          <target state="translated">Arguments::try_from</target>
        </trans-unit>
        <trans-unit id="8bb902c723ba932ded5aa3da8d68330e0bd8dfdd" translate="yes" xml:space="preserve">
          <source>Arguments::try_into</source>
          <target state="translated">Arguments::try_into</target>
        </trans-unit>
        <trans-unit id="93c384146f511c59251c10079f21618fcc345340" translate="yes" xml:space="preserve">
          <source>Arguments::type_id</source>
          <target state="translated">Arguments::type_id</target>
        </trans-unit>
        <trans-unit id="52ed5399cec328eed1c4d10b234f6d54945d8379" translate="yes" xml:space="preserve">
          <source>Arithmetic addition</source>
          <target state="translated">арифметическое добавление</target>
        </trans-unit>
        <trans-unit id="b6a2b173c28c2d32e0f07c5865706f1a0af1dc82" translate="yes" xml:space="preserve">
          <source>Arithmetic addition and assignment</source>
          <target state="translated">арифметическое добавление и назначение</target>
        </trans-unit>
        <trans-unit id="481206dd7e4055d67971a43266f17dd6c8acf74d" translate="yes" xml:space="preserve">
          <source>Arithmetic and Logical Binary Operators</source>
          <target state="translated">Арифметические и логические двоичные операторы</target>
        </trans-unit>
        <trans-unit id="ba8c163933eb964b78854dfa7b1e1313a4ece109" translate="yes" xml:space="preserve">
          <source>Arithmetic and comparison operators on integers</source>
          <target state="translated">Арифметические операторы и операторы сравнения на целых числах</target>
        </trans-unit>
        <trans-unit id="3a2ccea0b8aef06fcf5a90ab7c705782be897b40" translate="yes" xml:space="preserve">
          <source>Arithmetic division</source>
          <target state="translated">арифметическое разделение</target>
        </trans-unit>
        <trans-unit id="dfc8f592565726eb9a5251995ebe9c35af2683f2" translate="yes" xml:space="preserve">
          <source>Arithmetic division and assignment</source>
          <target state="translated">арифметическое разделение и назначение</target>
        </trans-unit>
        <trans-unit id="5e0f6d1b7afc18895e08ec06673e25445eca9bd9" translate="yes" xml:space="preserve">
          <source>Arithmetic multiplication</source>
          <target state="translated">арифметическое умножение</target>
        </trans-unit>
        <trans-unit id="aed641007b737ba787b84c11db1a76f81a7265ec" translate="yes" xml:space="preserve">
          <source>Arithmetic multiplication and assignment</source>
          <target state="translated">арифметическое умножение и назначение</target>
        </trans-unit>
        <trans-unit id="9501694b83625ba1c4c32e0300c7e3ef0ea5895a" translate="yes" xml:space="preserve">
          <source>Arithmetic negation</source>
          <target state="translated">арифметическое отрицание</target>
        </trans-unit>
        <trans-unit id="4b7e345ffd8cb02b4c25248f3c2916dd526e2269" translate="yes" xml:space="preserve">
          <source>Arithmetic remainder</source>
          <target state="translated">арифметический остаток</target>
        </trans-unit>
        <trans-unit id="4af14fe332c2fec7e550537a659d27f7672cf52b" translate="yes" xml:space="preserve">
          <source>Arithmetic remainder and assignment</source>
          <target state="translated">арифметический остаток и назначение</target>
        </trans-unit>
        <trans-unit id="54604a8945847efcfbb8925458787851115f9296" translate="yes" xml:space="preserve">
          <source>Arithmetic subtraction</source>
          <target state="translated">арифметическое вычитание</target>
        </trans-unit>
        <trans-unit id="40c2d180ceb1daebfda27a7dc052bf6e18437123" translate="yes" xml:space="preserve">
          <source>Arithmetic subtraction and assignment</source>
          <target state="translated">арифметическое вычитание и назначение</target>
        </trans-unit>
        <trans-unit id="9d9b31e17e60151ad825cdde7693ca0fcca238c9" translate="yes" xml:space="preserve">
          <source>Arity</source>
          <target state="translated">Arity</target>
        </trans-unit>
        <trans-unit id="1fd516c87a7c389dccca9649a7b656d2f047d85d" translate="yes" xml:space="preserve">
          <source>Arity refers to the number of arguments a function or operator takes. For some examples, &lt;code&gt;f(2, 3)&lt;/code&gt; and &lt;code&gt;g(4, 6)&lt;/code&gt; have arity 2, while &lt;code&gt;h(8, 2, 6)&lt;/code&gt; has arity 3. The &lt;code&gt;!&lt;/code&gt; operator has arity 1.</source>
          <target state="translated">Артистичность относится к количеству аргументов, которые принимает функция или оператор. Для некоторых примеров, &lt;code&gt;f(2, 3)&lt;/code&gt; и &lt;code&gt;g(4, 6)&lt;/code&gt; имеют арность 2, а &lt;code&gt;h(8, 2, 6)&lt;/code&gt; - арность 3. &lt;code&gt;!&lt;/code&gt; оператор имеет арность 1.</target>
        </trans-unit>
        <trans-unit id="107004472b7ba4e5e31f3082ee1fb5a1239eec61" translate="yes" xml:space="preserve">
          <source>Array</source>
          <target state="translated">Array</target>
        </trans-unit>
        <trans-unit id="e88a1d916bd09fa0781281dd0639410541b1c200" translate="yes" xml:space="preserve">
          <source>Array Layout</source>
          <target state="translated">Макет массива</target>
        </trans-unit>
        <trans-unit id="811e7deb41b753134a124c771bc129d2aad4f69f" translate="yes" xml:space="preserve">
          <source>Array and array index expressions</source>
          <target state="translated">Выражения индексов массивов и массивов</target>
        </trans-unit>
        <trans-unit id="0844515b5a634fa1753332ae502ec5bc059c9bf4" translate="yes" xml:space="preserve">
          <source>Array and slice indexing expressions</source>
          <target state="translated">Выражения индексации массивов и срезов</target>
        </trans-unit>
        <trans-unit id="1c901b7185d5b71317418dac8afa7a9edb10a639" translate="yes" xml:space="preserve">
          <source>Array expression attributes</source>
          <target state="translated">Атрибуты выражения массива</target>
        </trans-unit>
        <trans-unit id="ff659441b84e2964045ca09a8c18a08d44b84a61" translate="yes" xml:space="preserve">
          <source>Array expressions</source>
          <target state="translated">Массивные выражения</target>
        </trans-unit>
        <trans-unit id="b4a857fc21bf592938e9dd2ec1d467878b6cf83e" translate="yes" xml:space="preserve">
          <source>Array literal</source>
          <target state="translated">Массив буквально</target>
        </trans-unit>
        <trans-unit id="4935b8502c9911035c4038af29553fcfde8b5706" translate="yes" xml:space="preserve">
          <source>Array literal containing &lt;code&gt;len&lt;/code&gt; copies of &lt;code&gt;expr&lt;/code&gt;</source>
          <target state="translated">Литерал массива, содержащий &lt;code&gt;len&lt;/code&gt; копий &lt;code&gt;expr&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="235f924c7c3818aed78845bd2de8791d4d3ba101" translate="yes" xml:space="preserve">
          <source>Array literals with repeating syntax, where the array has type &lt;code&gt;[U; n]&lt;/code&gt;. The repeated sub-expression is a coercion site for coercion to type &lt;code&gt;U&lt;/code&gt;.</source>
          <target state="translated">Литералы массива с повторяющимся синтаксисом, где массив имеет тип &lt;code&gt;[U; n]&lt;/code&gt; . Неоднократное Подвыражение является принуждение сайта для принуждения к типу &lt;code&gt;U&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="41d08ca772cf664e0e365d09949f5835931ea185" translate="yes" xml:space="preserve">
          <source>Array literals, where the array has type &lt;code&gt;[U; n]&lt;/code&gt;. Each sub-expression in the array literal is a coercion site for coercion to type &lt;code&gt;U&lt;/code&gt;.</source>
          <target state="translated">Литералы массива, где массив имеет тип &lt;code&gt;[U; n]&lt;/code&gt; . Каждый суб-выражение в буквальном массива является принуждение сайта для принуждения к типу &lt;code&gt;U&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5de52c0cb2ce4e0eb71f0c098408cbd13a499a61" translate="yes" xml:space="preserve">
          <source>Array repeat length expressions</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ea9dbd560327931c17a47c31880f0fcea2d052f4" translate="yes" xml:space="preserve">
          <source>Array to pointer cast</source>
          <target state="translated">Массив для литья указателей</target>
        </trans-unit>
        <trans-unit id="45de270a590c4d4b0320d8105310eb72bc4364df" translate="yes" xml:space="preserve">
          <source>Array type containing &lt;code&gt;len&lt;/code&gt; instances of &lt;code&gt;type&lt;/code&gt;</source>
          <target state="translated">Тип массива, содержащий &lt;code&gt;len&lt;/code&gt; экземпляров &lt;code&gt;type&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="51a7c3ed1d5f017cc725067fca3064cb604b7344" translate="yes" xml:space="preserve">
          <source>Array type length expressions</source>
          <target state="translated">Выражения длины типа массива</target>
        </trans-unit>
        <trans-unit id="ee988191e1f320445ced1a772858430505143153" translate="yes" xml:space="preserve">
          <source>Array types</source>
          <target state="translated">Типы массивов</target>
        </trans-unit>
        <trans-unit id="51fa61d38d898a29b7f71e858ac412133bb4aa78" translate="yes" xml:space="preserve">
          <source>Array types, for all sizes, if the item type also implements &lt;code&gt;Clone&lt;/code&gt; (e.g., &lt;code&gt;[i32; 123456]&lt;/code&gt;)</source>
          <target state="translated">Типы массивов для всех размеров, если тип элемента также реализует &lt;code&gt;Clone&lt;/code&gt; (например, &lt;code&gt;[i32; 123456]&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="c11c5b2f8cc2056c662bde9d8e7265077775fda2" translate="yes" xml:space="preserve">
          <source>Array types, for all sizes, if the item type also implements &lt;code&gt;Copy&lt;/code&gt; (e.g., &lt;code&gt;[i32; 123456]&lt;/code&gt;)</source>
          <target state="translated">Типы массивов для всех размеров, если тип элемента также реализует &lt;code&gt;Copy&lt;/code&gt; (например, &lt;code&gt;[i32; 123456]&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="95c5c33f29f0547a430b0665b6ac583648900bd6" translate="yes" xml:space="preserve">
          <source>ArrayChunks</source>
          <target state="translated">ArrayChunks</target>
        </trans-unit>
        <trans-unit id="5d42cc662a1c24ca3713c4fbd65f30d1d4685e7c" translate="yes" xml:space="preserve">
          <source>ArrayChunksMut</source>
          <target state="translated">ArrayChunksMut</target>
        </trans-unit>
        <trans-unit id="f83b691df0418afaddc970026f4eccfa1541c51f" translate="yes" xml:space="preserve">
          <source>ArrayWindows</source>
          <target state="translated">ArrayWindows</target>
        </trans-unit>
        <trans-unit id="aa557f1be66399eaf12f2be07d75660861cacf56" translate="yes" xml:space="preserve">
          <source>Arrays are laid out so that the &lt;code&gt;nth&lt;/code&gt; element of the array is offset from the start of the array by &lt;code&gt;n * the size of the type&lt;/code&gt; bytes. An array of &lt;code&gt;[T; n]&lt;/code&gt; has a size of &lt;code&gt;size_of::&amp;lt;T&amp;gt;() * n&lt;/code&gt; and the same alignment of &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">Массивы располагаются так, что &lt;code&gt;nth&lt;/code&gt; элемент массива смещен от начала массива на &lt;code&gt;n * the size of the type&lt;/code&gt; байтов типа . Массив &lt;code&gt;[T; n]&lt;/code&gt; имеет размер &lt;code&gt;size_of::&amp;lt;T&amp;gt;() * n&lt;/code&gt; и то же выравнивание &lt;code&gt;T&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="02fe2a892020ef77103f56bebff06ee9353b3385" translate="yes" xml:space="preserve">
          <source>Arrays are useful when you want your data allocated on the stack rather than the heap (we will discuss the stack and the heap more in Chapter 4) or when you want to ensure you always have a fixed number of elements. An array isn&amp;rsquo;t as flexible as the vector type, though. A vector is a similar collection type provided by the standard library that &lt;em&gt;is&lt;/em&gt; allowed to grow or shrink in size. If you&amp;rsquo;re unsure whether to use an array or a vector, you should probably use a vector. Chapter 8 discusses vectors in more detail.</source>
          <target state="translated">Массивы полезны, когда вы хотите, чтобы ваши данные были размещены в стеке, а не в куче (мы обсудим стек и кучу подробнее в главе 4) или когда вы хотите, чтобы у вас всегда было фиксированное количество элементов. Однако массив не так гибок, как векторный тип. Вектор - это аналогичный тип коллекции, предоставляемый стандартной библиотекой, который &lt;em&gt;может&lt;/em&gt; увеличиваться или уменьшаться в размере. Если вы не уверены, использовать ли массив или вектор, вам, вероятно, следует использовать вектор. В главе 8 векторы рассматриваются более подробно.</target>
        </trans-unit>
        <trans-unit id="3b3785f54b6fb9b400ea9ab57c87c42e59186241" translate="yes" xml:space="preserve">
          <source>Arrays coerce to &lt;a href=&quot;primitive.slice&quot;&gt;slices (&lt;code&gt;[T]&lt;/code&gt;)&lt;/a&gt;, so a slice method may be called on an array. Indeed, this provides most of the API for working with arrays. Slices have a dynamic size and do not coerce to arrays.</source>
          <target state="translated">Массивы приводятся к &lt;a href=&quot;primitive.slice&quot;&gt;срезам ( &lt;code&gt;[T]&lt;/code&gt; )&lt;/a&gt; , поэтому метод срезов может быть вызван для массива. Действительно, это предоставляет большую часть API для работы с массивами. Срезы имеют динамический размер и не переходят в массивы.</target>
        </trans-unit>
        <trans-unit id="a5463b6c378c5a1ce536679177693788d8a488ef" translate="yes" xml:space="preserve">
          <source>Arrays of &lt;em&gt;any&lt;/em&gt; size are &lt;a href=&quot;marker/trait.copy&quot;&gt;&lt;code&gt;Copy&lt;/code&gt;&lt;/a&gt; if the element type is &lt;a href=&quot;marker/trait.copy&quot;&gt;&lt;code&gt;Copy&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;clone/trait.clone&quot;&gt;&lt;code&gt;Clone&lt;/code&gt;&lt;/a&gt; if the element type is &lt;a href=&quot;clone/trait.clone&quot;&gt;&lt;code&gt;Clone&lt;/code&gt;&lt;/a&gt;. This works because &lt;a href=&quot;marker/trait.copy&quot;&gt;&lt;code&gt;Copy&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;clone/trait.clone&quot;&gt;&lt;code&gt;Clone&lt;/code&gt;&lt;/a&gt; traits are specially known to the compiler.</source>
          <target state="translated">Массивы &lt;em&gt;любого&lt;/em&gt; размера - это &lt;a href=&quot;marker/trait.copy&quot;&gt; &lt;code&gt;Copy&lt;/code&gt; &lt;/a&gt; если тип элемента - &lt;a href=&quot;marker/trait.copy&quot;&gt; &lt;code&gt;Copy&lt;/code&gt; &lt;/a&gt; и &lt;a href=&quot;clone/trait.clone&quot;&gt; &lt;code&gt;Clone&lt;/code&gt; &lt;/a&gt; если тип элемента - &lt;a href=&quot;clone/trait.clone&quot;&gt; &lt;code&gt;Clone&lt;/code&gt; &lt;/a&gt; . Это работает, потому что &lt;a href=&quot;marker/trait.copy&quot;&gt; &lt;code&gt;Copy&lt;/code&gt; &lt;/a&gt; и &lt;a href=&quot;clone/trait.clone&quot;&gt; &lt;code&gt;Clone&lt;/code&gt; &lt;/a&gt; специально известны компилятору.</target>
        </trans-unit>
        <trans-unit id="44fcd591dcf7f314f13f655158af04cf8a3c0c81" translate="yes" xml:space="preserve">
          <source>Arrays of &lt;em&gt;any&lt;/em&gt; size implement the following traits if the element type allows it:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6563ac44bbb67213c7a3f6f4eeedf9dc732e3220" translate="yes" xml:space="preserve">
          <source>Arrays of sizes from 0 to 32 (inclusive) implement &lt;a href=&quot;default/trait.default&quot;&gt;&lt;code&gt;Default&lt;/code&gt;&lt;/a&gt; trait if the element type allows it. As a stopgap, trait implementations are statically generated up to size 32.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e22eb391f81362ae0eac8c4cd60b81a4562599d8" translate="yes" xml:space="preserve">
          <source>Arrays of sizes from 0 to 32 (inclusive) implement the following traits if the element type allows it:</source>
          <target state="translated">Массивы размеров от 0 до 32 (включительно)реализуют следующие признаки,если позволяет тип элемента:</target>
        </trans-unit>
        <trans-unit id="3520f70ba3a61ccc1286dbddd33fb0815248aa0b" translate="yes" xml:space="preserve">
          <source>As &lt;code&gt;if&lt;/code&gt; expressions have their pattern matching variant in &lt;code&gt;if let&lt;/code&gt;, so too do &lt;code&gt;while&lt;/code&gt; expressions with &lt;code&gt;while let&lt;/code&gt;. The &lt;code&gt;while let&lt;/code&gt; expression matches the pattern against the expression, then runs the loop body if pattern matching succeeds, or exits the loop otherwise. We can use &lt;code&gt;break&lt;/code&gt; and &lt;code&gt;continue&lt;/code&gt; in &lt;code&gt;while let&lt;/code&gt; expressions just like in &lt;code&gt;while&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2be2422a9ce4d7fe654319fa259c94897e3e7b46" translate="yes" xml:space="preserve">
          <source>As IANA assigns new addresses, this method will be updated. This may result in non-reserved addresses being treated as reserved in code that relies on an outdated version of this method.</source>
          <target state="translated">По мере того,как IANA присваивает новые адреса,этот метод будет обновляться.Это может привести к тому,что незарезервированные адреса будут рассматриваться как зарезервированные в коде,который опирается на устаревшую версию данного метода.</target>
        </trans-unit>
        <trans-unit id="204e461bb880d4d3e097aeac5f123e90d90ae7f0" translate="yes" xml:space="preserve">
          <source>As Rust automatically calls the destructors of all contained fields, you don't have to implement &lt;code&gt;Drop&lt;/code&gt; in most cases. But there are some cases where it is useful, for example for types which directly manage a resource. That resource may be memory, it may be a file descriptor, it may be a network socket. Once a value of that type is no longer going to be used, it should &quot;clean up&quot; its resource by freeing the memory or closing the file or socket. This is the job of a destructor, and therefore the job of &lt;code&gt;Drop::drop&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0e9f144fd6603397ae748bc2c2b95fde2038ac9c" translate="yes" xml:space="preserve">
          <source>As a companion to &lt;a href=&quot;trait.borrow&quot;&gt;&lt;code&gt;Borrow&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt; this trait allows a type to borrow as an underlying type by providing a mutable reference. See &lt;a href=&quot;trait.borrow&quot;&gt;&lt;code&gt;Borrow&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt; for more information on borrowing as another type.</source>
          <target state="translated">В качестве дополнения к &lt;a href=&quot;trait.borrow&quot;&gt; &lt;code&gt;Borrow&amp;lt;T&amp;gt;&lt;/code&gt; &lt;/a&gt; эта черта позволяет типу заимствовать как базовый тип, предоставляя изменяемую ссылку. См. &lt;a href=&quot;trait.borrow&quot;&gt; &lt;code&gt;Borrow&amp;lt;T&amp;gt;&lt;/code&gt; &lt;/a&gt; для получения дополнительной информации о заимствовании в качестве другого типа.</target>
        </trans-unit>
        <trans-unit id="f044338e83e2522cd461ee6d84f7c5ea2e52e486" translate="yes" xml:space="preserve">
          <source>As a consequence, the hash map breaks if a &lt;code&gt;K&lt;/code&gt; wrapping a &lt;code&gt;Q&lt;/code&gt; value produces a different hash than &lt;code&gt;Q&lt;/code&gt;. For instance, imagine you have a type that wraps a string but compares ASCII letters ignoring their case:</source>
          <target state="translated">Как следствие, хэш - карта брейки если в &lt;code&gt;K&lt;/code&gt; Обертывание &lt;code&gt;Q&lt;/code&gt; значение производит различные хэш , чем &lt;code&gt;Q&lt;/code&gt; . Например, представьте, что у вас есть тип, который обертывает строку, но сравнивает буквы ASCII, игнорируя их регистр:</target>
        </trans-unit>
        <trans-unit id="21e6ec20b4bccf73414453b9c7ceac9ffa2614a2" translate="yes" xml:space="preserve">
          <source>As a data collection, &lt;a href=&quot;../collections/struct.hashmap&quot;&gt;&lt;code&gt;HashMap&amp;lt;K, V&amp;gt;&lt;/code&gt;&lt;/a&gt; owns both keys and values. If the key&amp;rsquo;s actual data is wrapped in a managing type of some kind, it should, however, still be possible to search for a value using a reference to the key&amp;rsquo;s data. For instance, if the key is a string, then it is likely stored with the hash map as a &lt;a href=&quot;../string/struct.string&quot;&gt;&lt;code&gt;String&lt;/code&gt;&lt;/a&gt;, while it should be possible to search using a &lt;a href=&quot;../primitive.str&quot;&gt;&lt;code&gt;&amp;amp;str&lt;/code&gt;&lt;/a&gt;. Thus, &lt;code&gt;insert&lt;/code&gt; needs to operate on a &lt;code&gt;String&lt;/code&gt; while &lt;code&gt;get&lt;/code&gt; needs to be able to use a &lt;code&gt;&amp;amp;str&lt;/code&gt;.</source>
          <target state="translated">В качестве сбора данных &lt;a href=&quot;../collections/struct.hashmap&quot;&gt; &lt;code&gt;HashMap&amp;lt;K, V&amp;gt;&lt;/code&gt; &lt;/a&gt; владеет как ключами, так и значениями. Если фактические данные ключа обернуты в какой-либо управляющий тип, тем не менее, должна быть возможность поиска значения с использованием ссылки на данные ключа. Например, если ключ является строкой, то он, скорее всего, хранится с хеш-картой как &lt;a href=&quot;../string/struct.string&quot;&gt; &lt;code&gt;String&lt;/code&gt; &lt;/a&gt; , тогда как поиск должен быть возможен с использованием &lt;a href=&quot;../primitive.str&quot;&gt; &lt;code&gt;&amp;amp;str&lt;/code&gt; &lt;/a&gt; . Таким образом, &lt;code&gt;insert&lt;/code&gt; должен работать со &lt;code&gt;String&lt;/code&gt; тогда как &lt;code&gt;get&lt;/code&gt; должен иметь возможность использовать &lt;code&gt;&amp;amp;str&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="72b018e0e36049ad8edb2d9275fa43ffbd253ac2" translate="yes" xml:space="preserve">
          <source>As a first example of ownership, we&amp;rsquo;ll look at the &lt;em&gt;scope&lt;/em&gt; of some variables. A scope is the range within a program for which an item is valid. Let&amp;rsquo;s say we have a variable that looks like this:</source>
          <target state="translated">В качестве первого примера владения мы рассмотрим &lt;em&gt;область&lt;/em&gt; действия некоторых переменных. Область действия - это диапазон в программе, для которой действителен элемент. Допустим, у нас есть переменная, которая выглядит так:</target>
        </trans-unit>
        <trans-unit id="0024a0a24aed0a7ac58334f18eea8263ecf48ec1" translate="yes" xml:space="preserve">
          <source>As a language, Rust cares a &lt;em&gt;lot&lt;/em&gt; about the stability of your code. We want Rust to be a rock-solid foundation you can build on, and if things were constantly changing, that would be impossible. At the same time, if we can&amp;rsquo;t experiment with new features, we may not find out important flaws until after their release, when we can no longer change things.</source>
          <target state="translated">Как язык, Rust заботится &lt;em&gt;много&lt;/em&gt; о стабильности вашего кода. Мы хотим, чтобы Rust был прочным фундаментом, на котором можно было строить, и если бы все было постоянно, это было бы невозможно. В то же время, если мы не можем экспериментировать с новыми функциями, мы можем обнаружить важные недостатки только после их выпуска, когда мы больше не сможем ничего изменить.</target>
        </trans-unit>
        <trans-unit id="c7163ba6f2bf3417c3c81c5ac8d3af7e28902510" translate="yes" xml:space="preserve">
          <source>As a library author, you should always prefer implementing &lt;a href=&quot;trait.from&quot;&gt;&lt;code&gt;From&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;trait.tryfrom&quot;&gt;&lt;code&gt;TryFrom&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt; rather than &lt;a href=&quot;trait.into&quot;&gt;&lt;code&gt;Into&amp;lt;U&amp;gt;&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;trait.tryinto&quot;&gt;&lt;code&gt;TryInto&amp;lt;U&amp;gt;&lt;/code&gt;&lt;/a&gt;, as &lt;a href=&quot;trait.from&quot;&gt;&lt;code&gt;From&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;trait.tryfrom&quot;&gt;&lt;code&gt;TryFrom&lt;/code&gt;&lt;/a&gt; provide greater flexibility and offer equivalent &lt;a href=&quot;trait.into&quot;&gt;&lt;code&gt;Into&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;trait.tryinto&quot;&gt;&lt;code&gt;TryInto&lt;/code&gt;&lt;/a&gt; implementations for free, thanks to a blanket implementation in the standard library. Only implement &lt;a href=&quot;trait.into&quot;&gt;&lt;code&gt;Into&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;trait.tryinto&quot;&gt;&lt;code&gt;TryInto&lt;/code&gt;&lt;/a&gt; when a conversion to a type outside the current crate is required.</source>
          <target state="translated">Как автор библиотеки, вы всегда должны предпочесть реализацию &lt;a href=&quot;trait.from&quot;&gt; &lt;code&gt;From&amp;lt;T&amp;gt;&lt;/code&gt; &lt;/a&gt; или &lt;a href=&quot;trait.tryfrom&quot;&gt; &lt;code&gt;TryFrom&amp;lt;T&amp;gt;&lt;/code&gt; &lt;/a&gt; а не &lt;a href=&quot;trait.into&quot;&gt; &lt;code&gt;Into&amp;lt;U&amp;gt;&lt;/code&gt; &lt;/a&gt; или &lt;a href=&quot;trait.tryinto&quot;&gt; &lt;code&gt;TryInto&amp;lt;U&amp;gt;&lt;/code&gt; &lt;/a&gt; , поскольку &lt;a href=&quot;trait.from&quot;&gt; &lt;code&gt;From&lt;/code&gt; &lt;/a&gt; и &lt;a href=&quot;trait.tryfrom&quot;&gt; &lt;code&gt;TryFrom&lt;/code&gt; &lt;/a&gt; обеспечивают большую гибкость и предлагают эквивалентные реализации &lt;a href=&quot;trait.into&quot;&gt; &lt;code&gt;Into&lt;/code&gt; &lt;/a&gt; или &lt;a href=&quot;trait.tryinto&quot;&gt; &lt;code&gt;TryInto&lt;/code&gt; &lt;/a&gt; бесплатно благодаря бланкетная реализация в стандартной библиотеке. Только реализовать &lt;a href=&quot;trait.into&quot;&gt; &lt;code&gt;Into&lt;/code&gt; &lt;/a&gt; или &lt;a href=&quot;trait.tryinto&quot;&gt; &lt;code&gt;TryInto&lt;/code&gt; &lt;/a&gt; , когда преобразование к типу за пределами текущего ящика требуется.</target>
        </trans-unit>
        <trans-unit id="c688289e645266d022bd25b11abee98bf47d494f" translate="yes" xml:space="preserve">
          <source>As a library author, you should always prefer implementing &lt;a href=&quot;trait.from&quot;&gt;&lt;code&gt;From&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;trait.tryfrom&quot;&gt;&lt;code&gt;TryFrom&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt; rather than &lt;a href=&quot;trait.into&quot;&gt;&lt;code&gt;Into&amp;lt;U&amp;gt;&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;trait.tryinto&quot;&gt;&lt;code&gt;TryInto&amp;lt;U&amp;gt;&lt;/code&gt;&lt;/a&gt;, as &lt;a href=&quot;trait.from&quot;&gt;&lt;code&gt;From&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;trait.tryfrom&quot;&gt;&lt;code&gt;TryFrom&lt;/code&gt;&lt;/a&gt; provide greater flexibility and offer equivalent &lt;a href=&quot;trait.into&quot;&gt;&lt;code&gt;Into&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;trait.tryinto&quot;&gt;&lt;code&gt;TryInto&lt;/code&gt;&lt;/a&gt; implementations for free, thanks to a blanket implementation in the standard library. When targeting a version prior to Rust 1.41, it may be necessary to implement &lt;a href=&quot;trait.into&quot;&gt;&lt;code&gt;Into&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;trait.tryinto&quot;&gt;&lt;code&gt;TryInto&lt;/code&gt;&lt;/a&gt; directly when converting to a type outside the current crate.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ff562238e6519efc127fd0f82f8c3d4cbe94172e" translate="yes" xml:space="preserve">
          <source>As a more concise alternative, you can use a &lt;code&gt;for&lt;/code&gt; loop and execute some code for each item in a collection. A &lt;code&gt;for&lt;/code&gt; loop looks like the code in Listing 3-5.</source>
          <target state="translated">В качестве более краткой альтернативы вы можете использовать цикл &lt;code&gt;for&lt;/code&gt; и выполнить некоторый код для каждого элемента в коллекции. Цикл &lt;code&gt;for&lt;/code&gt; выглядит как код в листинге 3-5.</target>
        </trans-unit>
        <trans-unit id="4b5b050c97f5fa423f8a999dca4b012b9c78134c" translate="yes" xml:space="preserve">
          <source>As a result of this code, &lt;code&gt;s&lt;/code&gt; will contain &lt;code&gt;lol&lt;/code&gt;.</source>
          <target state="translated">В результате этого кода &lt;code&gt;s&lt;/code&gt; будет содержать &lt;code&gt;lol&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b710b8f0107d2ffba9437950b5808cd39ab806b4" translate="yes" xml:space="preserve">
          <source>As a result, this method consider addresses such as &lt;code&gt;fe80:0:0:1::&lt;/code&gt; or &lt;code&gt;fe81::&lt;/code&gt; to be unicast link-local addresses, whereas &lt;a href=&quot;struct.ipv6addr#method.is_unicast_link_local_strict&quot;&gt;&lt;code&gt;Ipv6Addr::is_unicast_link_local_strict()&lt;/code&gt;&lt;/a&gt; does not. If you need a strict validation fully compliant with the RFC, use &lt;a href=&quot;struct.ipv6addr#method.is_unicast_link_local_strict&quot;&gt;&lt;code&gt;Ipv6Addr::is_unicast_link_local_strict()&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0f98a89f1abd2dd1d5bfe499fd5b56372a5800c2" translate="yes" xml:space="preserve">
          <source>As a result, this method consider addresses such as &lt;code&gt;fe80:0:0:1::&lt;/code&gt; or &lt;code&gt;fe81::&lt;/code&gt; to be unicast link-local addresses, whereas &lt;a href=&quot;struct.ipv6addr#method.is_unicast_link_local_strict&quot;&gt;&lt;code&gt;is_unicast_link_local_strict()&lt;/code&gt;&lt;/a&gt; does not. If you need a strict validation fully compliant with the RFC, use &lt;a href=&quot;struct.ipv6addr#method.is_unicast_link_local_strict&quot;&gt;&lt;code&gt;is_unicast_link_local_strict()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">В результате этот метод рассматривает такие адреса, как &lt;code&gt;fe80:0:0:1::&lt;/code&gt; или &lt;code&gt;fe81::&lt;/code&gt; , как &lt;a href=&quot;struct.ipv6addr#method.is_unicast_link_local_strict&quot;&gt; &lt;code&gt;is_unicast_link_local_strict()&lt;/code&gt; &lt;/a&gt; для одноадресной передачи, тогда как is_unicast_link_local_strict () - нет. Если вам нужна строгая проверка, полностью соответствующая RFC, используйте &lt;a href=&quot;struct.ipv6addr#method.is_unicast_link_local_strict&quot;&gt; &lt;code&gt;is_unicast_link_local_strict()&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="486c7c23286a7b0e1299ccac2ee0a869b3e82ee5" translate="yes" xml:space="preserve">
          <source>As a string slice consists of a sequence of bytes, we can iterate through a string slice by byte. This method returns such an iterator.</source>
          <target state="translated">Так как строковый срез состоит из последовательности байтов,мы можем выполнить итерацию через строковый срез по байтам.Этот метод возвращает такой итератор.</target>
        </trans-unit>
        <trans-unit id="13230333554cf4f41cab6ad4fc5190eeee2538f2" translate="yes" xml:space="preserve">
          <source>As a string slice consists of valid UTF-8, we can iterate through a string slice by &lt;a href=&quot;../char/index&quot;&gt;&lt;code&gt;char&lt;/code&gt;&lt;/a&gt;. This method returns an iterator of both these &lt;a href=&quot;../char/index&quot;&gt;&lt;code&gt;char&lt;/code&gt;&lt;/a&gt;s, as well as their byte positions.</source>
          <target state="translated">Поскольку фрагмент строки состоит из действительного UTF-8, мы можем перебирать фрагмент строки по &lt;a href=&quot;../char/index&quot;&gt; &lt;code&gt;char&lt;/code&gt; &lt;/a&gt; . Этот метод возвращает итератор обоих этих &lt;a href=&quot;../char/index&quot;&gt; &lt;code&gt;char&lt;/code&gt; &lt;/a&gt; , а также их позиции в байтах.</target>
        </trans-unit>
        <trans-unit id="437cfa80202d923ee25f6cf5ad0fd2f02cfb01ea" translate="yes" xml:space="preserve">
          <source>As a string slice consists of valid UTF-8, we can iterate through a string slice by &lt;a href=&quot;../char/index&quot;&gt;&lt;code&gt;char&lt;/code&gt;&lt;/a&gt;. This method returns such an iterator.</source>
          <target state="translated">Поскольку фрагмент строки состоит из действительного UTF-8, мы можем перебирать фрагмент строки по &lt;a href=&quot;../char/index&quot;&gt; &lt;code&gt;char&lt;/code&gt; &lt;/a&gt; . Этот метод возвращает такой итератор.</target>
        </trans-unit>
        <trans-unit id="5e4e8ad23ff47badf3452433750942f67bdc2881" translate="yes" xml:space="preserve">
          <source>As a string slice consists of valid UTF-8, we can iterate through a string slice by &lt;a href=&quot;../primitive.char&quot;&gt;&lt;code&gt;char&lt;/code&gt;&lt;/a&gt;. This method returns an iterator of both these &lt;a href=&quot;../primitive.char&quot;&gt;&lt;code&gt;char&lt;/code&gt;&lt;/a&gt;s, as well as their byte positions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b276d81f1ebeb72ef92a468ba3b31b82b8dbf57a" translate="yes" xml:space="preserve">
          <source>As a string slice consists of valid UTF-8, we can iterate through a string slice by &lt;a href=&quot;../primitive.char&quot;&gt;&lt;code&gt;char&lt;/code&gt;&lt;/a&gt;. This method returns such an iterator.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fb40adb4e231d6bdd9f0bd0f9320f4357a2e82ae" translate="yes" xml:space="preserve">
          <source>As a string slice consists of valid UTF-8, we can iterate through a string slice by &lt;a href=&quot;char/index&quot;&gt;&lt;code&gt;char&lt;/code&gt;&lt;/a&gt;. This method returns an iterator of both these &lt;a href=&quot;char/index&quot;&gt;&lt;code&gt;char&lt;/code&gt;&lt;/a&gt;s, as well as their byte positions.</source>
          <target state="translated">Поскольку фрагмент строки состоит из действительного UTF-8, мы можем перебирать фрагмент строки по &lt;a href=&quot;char/index&quot;&gt; &lt;code&gt;char&lt;/code&gt; &lt;/a&gt; . Этот метод возвращает итератор обоих этих &lt;a href=&quot;char/index&quot;&gt; &lt;code&gt;char&lt;/code&gt; &lt;/a&gt; , а также их позиции в байтах.</target>
        </trans-unit>
        <trans-unit id="bf66f1c269d4394c9cb4445fd4fd600e640f2992" translate="yes" xml:space="preserve">
          <source>As a string slice consists of valid UTF-8, we can iterate through a string slice by &lt;a href=&quot;char/index&quot;&gt;&lt;code&gt;char&lt;/code&gt;&lt;/a&gt;. This method returns such an iterator.</source>
          <target state="translated">Поскольку фрагмент строки состоит из действительного UTF-8, мы можем перебирать фрагмент строки по &lt;a href=&quot;char/index&quot;&gt; &lt;code&gt;char&lt;/code&gt; &lt;/a&gt; . Этот метод возвращает такой итератор.</target>
        </trans-unit>
        <trans-unit id="047a0a2f69f724c14716efaa0063a5ea83e459c4" translate="yes" xml:space="preserve">
          <source>As a string slice consists of valid UTF-8, we can iterate through a string slice by &lt;a href=&quot;primitive.char&quot;&gt;&lt;code&gt;char&lt;/code&gt;&lt;/a&gt;. This method returns an iterator of both these &lt;a href=&quot;primitive.char&quot;&gt;&lt;code&gt;char&lt;/code&gt;&lt;/a&gt;s, as well as their byte positions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6d408364fefca0ab968a9b16914cf4b387f8e95e" translate="yes" xml:space="preserve">
          <source>As a string slice consists of valid UTF-8, we can iterate through a string slice by &lt;a href=&quot;primitive.char&quot;&gt;&lt;code&gt;char&lt;/code&gt;&lt;/a&gt;. This method returns such an iterator.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b4d78aa978dc16456ba4fafe0a526ad6183e3881" translate="yes" xml:space="preserve">
          <source>As always, remember that a human intuition for 'character' may not map to Unicode's definitions. For example, despite looking similar, the '&amp;eacute;' character is one Unicode code point while 'é' is two Unicode code points:</source>
          <target state="translated">Как всегда, помните, что человеческая интуиция для &amp;laquo;символа&amp;raquo; может не соответствовать определениям Unicode. Например, несмотря на схожесть, символ &amp;laquo;&amp;eacute;&amp;raquo; - это одна кодовая точка Unicode, а &amp;laquo;&amp;eacute;&amp;raquo; - это две кодовые точки Unicode:</target>
        </trans-unit>
        <trans-unit id="8d82369403176e5c690373478594ff76e764a9ef" translate="yes" xml:space="preserve">
          <source>As always, we can use curly brackets to create a new scope, allowing for multiple mutable references, just not &lt;em&gt;simultaneous&lt;/em&gt; ones:</source>
          <target state="translated">Как всегда, мы можем использовать фигурные скобки для создания новой области видимости, позволяющей использовать несколько изменяемых ссылок, но не &lt;em&gt;одновременные&lt;/em&gt; :</target>
        </trans-unit>
        <trans-unit id="c5be02ef05f525885a914931855842d0bd0941ea" translate="yes" xml:space="preserve">
          <source>As an example of how to use a mutex, let&amp;rsquo;s start by using a mutex in a single-threaded context, as shown in Listing 16-12:</source>
          <target state="translated">В качестве примера использования мьютекса давайте начнем с использования мьютекса в однопоточном контексте, как показано в листинге 16-12:</target>
        </trans-unit>
        <trans-unit id="0a2b1532710f708a62d9bd14aa059c7176218c09" translate="yes" xml:space="preserve">
          <source>As an example of methods on a trait, consider the following:</source>
          <target state="translated">В качестве примера методов на чертеже рассмотрим следующее:</target>
        </trans-unit>
        <trans-unit id="46ce22c9bcccaee92580f06aedfeeb7db04850fe" translate="yes" xml:space="preserve">
          <source>As an example of where you could use either a closure defined inline or a named function, let&amp;rsquo;s look at a use of &lt;code&gt;map&lt;/code&gt;. To use the &lt;code&gt;map&lt;/code&gt; function to turn a vector of numbers into a vector of strings, we could use a closure, like this:</source>
          <target state="translated">В качестве примера того, где вы можете использовать либо встроенное закрытие, либо именованную функцию, давайте рассмотрим использование &lt;code&gt;map&lt;/code&gt; . Чтобы использовать функцию &lt;code&gt;map&lt;/code&gt; для преобразования вектора чисел в вектор строк, мы могли бы использовать закрытие, например:</target>
        </trans-unit>
        <trans-unit id="37540a09808abda7d1579f892bfd40fb102faf8d" translate="yes" xml:space="preserve">
          <source>As an example, Listing 11-10 has a silly function that prints the value of its parameter and returns 10, as well as a test that passes and a test that fails.</source>
          <target state="translated">Например,Listing 11-10 имеет глупую функцию,которая печатает значение своего параметра и возвращает 10,а также тест,который проходит и тест,который дает сбой.</target>
        </trans-unit>
        <trans-unit id="53691b327422875e6972393627946b878398498e" translate="yes" xml:space="preserve">
          <source>As an example, a macro matcher like &lt;code&gt;$i:expr [ , ]&lt;/code&gt; could in theory be accepted in Rust today, since &lt;code&gt;[,]&lt;/code&gt; cannot be part of a legal expression and therefore the parse would always be unambiguous. However, because &lt;code&gt;[&lt;/code&gt; can start trailing expressions, &lt;code&gt;[&lt;/code&gt; is not a character which can safely be ruled out as coming after an expression. If &lt;code&gt;[,]&lt;/code&gt; were accepted in a later version of Rust, this matcher would become ambiguous or would misparse, breaking working code. Matchers like &lt;code&gt;$i:expr,&lt;/code&gt; or &lt;code&gt;$i:expr;&lt;/code&gt; would be legal, however, because &lt;code&gt;,&lt;/code&gt; and &lt;code&gt;;&lt;/code&gt; are legal expression separators. The specific rules are:</source>
          <target state="translated">Например, сопоставление макросов, такое как &lt;code&gt;$i:expr [ , ]&lt;/code&gt; теоретически может быть принято в Rust сегодня, поскольку &lt;code&gt;[,]&lt;/code&gt; не может быть частью допустимого выражения, и поэтому синтаксический анализ всегда будет однозначным. Однако, поскольку &lt;code&gt;[&lt;/code&gt; может начинать завершающие выражения, &lt;code&gt;[&lt;/code&gt; не является символом, который можно безопасно исключить как следующий после выражения. Если бы &lt;code&gt;[,]&lt;/code&gt; были приняты в более поздних версиях Rust, этот сопоставитель стал бы неоднозначным или неправильно анализировал бы, нарушая рабочий код. Матчеры вроде &lt;code&gt;$i:expr,&lt;/code&gt; или &lt;code&gt;$i:expr;&lt;/code&gt; было бы законным, однако, потому что &lt;code&gt;,&lt;/code&gt; и &lt;code&gt;;&lt;/code&gt; являются законными разделителями выражений. Конкретные правила:</target>
        </trans-unit>
        <trans-unit id="3c5226f2d8790540dbbe88f9ad68f2409b55a32e" translate="yes" xml:space="preserve">
          <source>As an example, change the &lt;em&gt;src/main.rs&lt;/em&gt; file in your &lt;em&gt;loops&lt;/em&gt; directory to look like this:</source>
          <target state="translated">В качестве примера измените файл &lt;em&gt;src / main.rs&lt;/em&gt; в каталоге &lt;em&gt;циклов,&lt;/em&gt; чтобы он выглядел следующим образом:</target>
        </trans-unit>
        <trans-unit id="7f0fd43eedc8fb375dd6813798e9b7e3996a0f09" translate="yes" xml:space="preserve">
          <source>As an example, let&amp;rsquo;s change one of our enum variants to hold data inside it. From 1999 through 2008, the United States minted quarters with different designs for each of the 50 states on one side. No other coins got state designs, so only quarters have this extra value. We can add this information to our &lt;code&gt;enum&lt;/code&gt; by changing the &lt;code&gt;Quarter&lt;/code&gt; variant to include a &lt;code&gt;UsState&lt;/code&gt; value stored inside it, which we&amp;rsquo;ve done here in Listing 6-4.</source>
          <target state="translated">В качестве примера давайте изменим один из наших вариантов перечисления, чтобы хранить в нем данные. С 1999 по 2008 год в США чеканили четверти с разным орнаментом для каждого из 50 штатов с одной стороны. Никакие другие монеты не имеют государственного образца, поэтому только четверти имеют эту дополнительную ценность. Мы можем добавить эту информацию в наше &lt;code&gt;enum&lt;/code&gt; , изменив вариант &lt;code&gt;Quarter&lt;/code&gt; , включив в &lt;code&gt;UsState&lt;/code&gt; значение UsState , которое мы сделали здесь, в листинге 6-4.</target>
        </trans-unit>
        <trans-unit id="d430493784bb7c38b9bfd2132c640f18ef8a2cfc" translate="yes" xml:space="preserve">
          <source>As an example, let&amp;rsquo;s say we want to implement &lt;code&gt;Display&lt;/code&gt; on &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt;, which the orphan rule prevents us from doing directly because the &lt;code&gt;Display&lt;/code&gt; trait and the &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; type are defined outside our crate. We can make a &lt;code&gt;Wrapper&lt;/code&gt; struct that holds an instance of &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt;; then we can implement &lt;code&gt;Display&lt;/code&gt; on &lt;code&gt;Wrapper&lt;/code&gt; and use the &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; value, as shown in Listing 19-23.</source>
          <target state="translated">В качестве примера предположим, что мы хотим реализовать &lt;code&gt;Display&lt;/code&gt; на &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; , что не позволяет нам делать это правило сироты, потому что типаж &lt;code&gt;Display&lt;/code&gt; и тип &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; определены вне нашего ящика. Мы можем создать структуру &lt;code&gt;Wrapper&lt;/code&gt; , которая содержит экземпляр &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; ; тогда мы можем реализовать &lt;code&gt;Display&lt;/code&gt; в &lt;code&gt;Wrapper&lt;/code&gt; и использовать значение &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; , как показано в листинге 19-23.</target>
        </trans-unit>
        <trans-unit id="0a293358ddd19b42df03eeb78c691469d4c0e122" translate="yes" xml:space="preserve">
          <source>As an example, let&amp;rsquo;s write a library crate that provides the functionality of a restaurant. We&amp;rsquo;ll define the signatures of functions but leave their bodies empty to concentrate on the organization of the code, rather than actually implement a restaurant in code.</source>
          <target state="translated">В качестве примера напишем ящик для библиотеки, обеспечивающий функциональность ресторана. Мы определим сигнатуры функций, но оставим их тела пустыми, чтобы сосредоточиться на организации кода, а не на реализации ресторана в коде.</target>
        </trans-unit>
        <trans-unit id="5e1d4bdb076d3e495d340c82a90a7bc9edd4704c" translate="yes" xml:space="preserve">
          <source>As an example, rather than using a list whose items know only about the next item, we&amp;rsquo;ll create a tree whose items know about their children items &lt;em&gt;and&lt;/em&gt; their parent items.</source>
          <target state="translated">В качестве примера, вместо того, чтобы использовать список, элементы которого знают только о следующем элементе, мы создадим дерево, элементы которого знают о своих дочерних элементах &lt;em&gt;и&lt;/em&gt; своих родительских элементах.</target>
        </trans-unit>
        <trans-unit id="84057f7bc04baf2d73dfbd111ea89a20d0d17089" translate="yes" xml:space="preserve">
          <source>As an example, recall the &lt;code&gt;Sync&lt;/code&gt; and &lt;code&gt;Send&lt;/code&gt; marker traits we discussed in the &lt;a href=&quot;ch16-04-extensible-concurrency-sync-and-send#extensible-concurrency-with-the-sync-and-send-traits&quot;&gt;&amp;ldquo;Extensible Concurrency with the &lt;code&gt;Sync&lt;/code&gt; and &lt;code&gt;Send&lt;/code&gt; Traits&amp;rdquo;&lt;/a&gt; section in Chapter 16: the compiler implements these traits automatically if our types are composed entirely of &lt;code&gt;Send&lt;/code&gt; and &lt;code&gt;Sync&lt;/code&gt; types. If we implement a type that contains a type that is not &lt;code&gt;Send&lt;/code&gt; or &lt;code&gt;Sync&lt;/code&gt;, such as raw pointers, and we want to mark that type as &lt;code&gt;Send&lt;/code&gt; or &lt;code&gt;Sync&lt;/code&gt;, we must use &lt;code&gt;unsafe&lt;/code&gt;. Rust can&amp;rsquo;t verify that our type upholds the guarantees that it can be safely sent across threads or accessed from multiple threads; therefore, we need to do those checks manually and indicate as such with &lt;code&gt;unsafe&lt;/code&gt;.</source>
          <target state="translated">В качестве примера вспомните особенности маркеров &lt;code&gt;Sync&lt;/code&gt; и &lt;code&gt;Send&lt;/code&gt; , которые мы обсуждали в разделе &lt;a href=&quot;ch16-04-extensible-concurrency-sync-and-send#extensible-concurrency-with-the-sync-and-send-traits&quot;&gt;&amp;laquo;Расширяемый параллелизм с &lt;code&gt;Sync&lt;/code&gt; &lt;code&gt;Send&lt;/code&gt; &lt;/a&gt; признаками Sync и Send &amp;raquo; в главе 16: компилятор реализует эти особенности автоматически, если наши типы полностью состоят из типов &lt;code&gt;Send&lt;/code&gt; и &lt;code&gt;Sync&lt;/code&gt; . Если мы реализуем тип, который содержит тип, который не является &lt;code&gt;Send&lt;/code&gt; или &lt;code&gt;Sync&lt;/code&gt; , например необработанные указатели, и мы хотим пометить этот тип как &lt;code&gt;Send&lt;/code&gt; или &lt;code&gt;Sync&lt;/code&gt; , мы должны использовать &lt;code&gt;unsafe&lt;/code&gt; . Rust не может проверить, поддерживает ли наш тип гарантии того, что его можно безопасно пересылать по потокам или получать доступ из нескольких потоков; поэтому нам нужно выполнить эти проверки вручную и указать как таковые &lt;code&gt;unsafe&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="38a88a1bad47211ae1a10e5bfcee84726e1f325e" translate="yes" xml:space="preserve">
          <source>As an example, say we write a function called &lt;code&gt;add_two&lt;/code&gt; that adds 2 to whatever number is passed to it. This function&amp;rsquo;s signature accepts an integer as a parameter and returns an integer as a result. When we implement and compile that function, Rust does all the type checking and borrow checking that you&amp;rsquo;ve learned so far to ensure that, for instance, we aren&amp;rsquo;t passing a &lt;code&gt;String&lt;/code&gt; value or an invalid reference to this function. But Rust &lt;em&gt;can&amp;rsquo;t&lt;/em&gt; check that this function will do precisely what we intend, which is return the parameter plus 2 rather than, say, the parameter plus 10 or the parameter minus 50! That&amp;rsquo;s where tests come in.</source>
          <target state="translated">В качестве примера предположим, что мы пишем функцию с именем &lt;code&gt;add_two&lt;/code&gt; , которая добавляет 2 к любому переданному ей числу. Сигнатура этой функции принимает целое число в качестве параметра и возвращает целое число в качестве результата. Когда мы реализуем и компилируем эту функцию, Rust выполняет все проверки типов и заимствований, которые вы изучили до сих пор, чтобы гарантировать, например, что мы не передаем значение &lt;code&gt;String&lt;/code&gt; или недопустимую ссылку на эту функцию. Но Rust &lt;em&gt;не может&lt;/em&gt; проверить, что эта функция будет делать именно то, что мы намереваемся, а именно возвращать параметр плюс 2, а не, скажем, параметр плюс 10 или параметр минус 50! Вот тут-то и нужны тесты.</target>
        </trans-unit>
        <trans-unit id="0c46b40f3e5f774d5bd6d946904f04146f347849" translate="yes" xml:space="preserve">
          <source>As an example, the pattern &lt;code&gt;&quot;aaa&quot;&lt;/code&gt; and the haystack &lt;code&gt;&quot;cbaaaaab&quot;&lt;/code&gt; might produce the stream &lt;code&gt;[Reject(0, 1), Reject(1, 2), Match(2, 5), Reject(5, 8)]&lt;/code&gt;</source>
          <target state="translated">Например, шаблон &lt;code&gt;&quot;aaa&quot;&lt;/code&gt; и стог сена &lt;code&gt;&quot;cbaaaaab&quot;&lt;/code&gt; могут создавать поток &lt;code&gt;[Reject(0, 1), Reject(1, 2), Match(2, 5), Reject(5, 8)]&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="f6b604f8510907ca9fe9178dfcf2a6874e95e6b5" translate="yes" xml:space="preserve">
          <source>As an example, the pattern &lt;code&gt;&quot;aaa&quot;&lt;/code&gt; and the haystack &lt;code&gt;&quot;cbaaaaab&quot;&lt;/code&gt; might produce the stream &lt;code&gt;[Reject(7, 8), Match(4, 7), Reject(1, 4), Reject(0, 1)]&lt;/code&gt;</source>
          <target state="translated">Например, шаблон &lt;code&gt;&quot;aaa&quot;&lt;/code&gt; и стог сена &lt;code&gt;&quot;cbaaaaab&quot;&lt;/code&gt; могут создавать поток &lt;code&gt;[Reject(7, 8), Match(4, 7), Reject(1, 4), Reject(0, 1)]&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="4bbd3fe41e9f9da754b12e58c1b62e309d7fedd0" translate="yes" xml:space="preserve">
          <source>As an example, the pattern &lt;code&gt;&quot;aaa&quot;&lt;/code&gt; and the haystack &lt;code&gt;&quot;cbaaaaab&quot;&lt;/code&gt; might produce the stream &lt;code&gt;[Reject(7, 8), Match(4, 7), Reject(1, 4), Reject(0, 1)]&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="877bff60769fbc36114e44fb0843def0fdaa302f" translate="yes" xml:space="preserve">
          <source>As an iterator:</source>
          <target state="translated">Как итератор:</target>
        </trans-unit>
        <trans-unit id="04b8526b20e002ad597cb978c8868c4ab1a90f67" translate="yes" xml:space="preserve">
          <source>As another example, suppose we have a &lt;code&gt;Maker&lt;/code&gt; trait and want to establish a type &lt;code&gt;FooMaker&lt;/code&gt; that makes &lt;code&gt;Foo&lt;/code&gt;s:</source>
          <target state="translated">В качестве другого примера предположим, что у нас есть черта &lt;code&gt;Maker&lt;/code&gt; и мы хотим создать тип &lt;code&gt;FooMaker&lt;/code&gt; , который делает &lt;code&gt;Foo&lt;/code&gt; s:</target>
        </trans-unit>
        <trans-unit id="5213c1c4f3b10c9c56042b19c8c0157b715adba7" translate="yes" xml:space="preserve">
          <source>As another example, the following code is taken from an audio decoder. The decoding algorithm uses the linear prediction mathematical operation to estimate future values based on a linear function of the previous samples. This code uses an iterator chain to do some math on three variables in scope: a &lt;code&gt;buffer&lt;/code&gt; slice of data, an array of 12 &lt;code&gt;coefficients&lt;/code&gt;, and an amount by which to shift data in &lt;code&gt;qlp_shift&lt;/code&gt;. We&amp;rsquo;ve declared the variables within this example but not given them any values; although this code doesn&amp;rsquo;t have much meaning outside of its context, it&amp;rsquo;s still a concise, real-world example of how Rust translates high-level ideas to low-level code.</source>
          <target state="translated">В качестве другого примера следующий код взят из аудиодекодера. Алгоритм декодирования использует математическую операцию линейного предсказания для оценки будущих значений на основе линейной функции предыдущих выборок. Этот код использует цепочку итераторов для выполнения некоторых математических расчетов с тремя переменными в области видимости: срез данных в &lt;code&gt;buffer&lt;/code&gt; , массив из 12 &lt;code&gt;coefficients&lt;/code&gt; и количество сдвига данных в &lt;code&gt;qlp_shift&lt;/code&gt; . Мы объявили переменные в этом примере, но не дали им никаких значений; хотя этот код не имеет большого значения вне контекста, он по-прежнему является кратким, реальным примером того, как Rust переводит высокоуровневые идеи в низкоуровневый код.</target>
        </trans-unit>
        <trans-unit id="50430e10a27b5bcf53132a5539fdc175dfb8f896" translate="yes" xml:space="preserve">
          <source>As can be seen below, &lt;code&gt;else&lt;/code&gt; must be followed by either: &lt;code&gt;if&lt;/code&gt;, &lt;code&gt;if let&lt;/code&gt;, or a block &lt;code&gt;{}&lt;/code&gt; and it will return the value of that expression.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ceca2c634722fa77d0d672657c5578a7251142a0" translate="yes" xml:space="preserve">
          <source>As described, &lt;a href=&quot;../i32/index&quot;&gt;&lt;code&gt;i32&lt;/code&gt;&lt;/a&gt; implements &lt;code&gt;TryFrom&amp;lt;i64&amp;gt;&lt;/code&gt;:</source>
          <target state="translated">Как описано, &lt;a href=&quot;../i32/index&quot;&gt; &lt;code&gt;i32&lt;/code&gt; &lt;/a&gt; реализует &lt;code&gt;TryFrom&amp;lt;i64&amp;gt;&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="7af5c30f33f1fda6dc417defcc8e46844e2584e3" translate="yes" xml:space="preserve">
          <source>As described, &lt;a href=&quot;../primitive.i32&quot;&gt;&lt;code&gt;i32&lt;/code&gt;&lt;/a&gt; implements &lt;code&gt;TryFrom&amp;lt;&lt;/code&gt;&lt;a href=&quot;../primitive.i64&quot;&gt;&lt;code&gt;i64&lt;/code&gt;&lt;/a&gt;&lt;code&gt;&amp;gt;&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0958482afe9fd3c8317c6c0d343e311be75015c7" translate="yes" xml:space="preserve">
          <source>As discussed in Chapter 10, to implement a trait, we need to provide implementations for the trait&amp;rsquo;s required methods. The &lt;code&gt;Deref&lt;/code&gt; trait, provided by the standard library, requires us to implement one method named &lt;code&gt;deref&lt;/code&gt; that borrows &lt;code&gt;self&lt;/code&gt; and returns a reference to the inner data. Listing 15-10 contains an implementation of &lt;code&gt;Deref&lt;/code&gt; to add to the definition of &lt;code&gt;MyBox&lt;/code&gt;:</source>
          <target state="translated">Как обсуждалось в главе 10, чтобы реализовать трейт, нам нужно предоставить реализации для требуемых методов трейта. &lt;code&gt;Deref&lt;/code&gt; черта, при условии стандартной библиотеки, требует от нас реализовать один метод , названный &lt;code&gt;deref&lt;/code&gt; заимствуется &lt;code&gt;self&lt;/code&gt; и возвращает ссылку на внутренние данные. Листинг 15-10 содержит реализацию &lt;code&gt;Deref&lt;/code&gt; для добавления к определению &lt;code&gt;MyBox&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="d5f5ed3e00ea3332f0559aed11908528d1ba499a" translate="yes" xml:space="preserve">
          <source>As discussed in Chapter 17, the &lt;code&gt;take&lt;/code&gt; method on &lt;code&gt;Option&lt;/code&gt; takes the &lt;code&gt;Some&lt;/code&gt; variant out and leaves &lt;code&gt;None&lt;/code&gt; in its place. We&amp;rsquo;re using &lt;code&gt;if let&lt;/code&gt; to destructure the &lt;code&gt;Some&lt;/code&gt; and get the thread; then we call &lt;code&gt;join&lt;/code&gt; on the thread. If a worker&amp;rsquo;s thread is already &lt;code&gt;None&lt;/code&gt;, we know that worker has already had its thread cleaned up, so nothing happens in that case.</source>
          <target state="translated">Как уже говорилось в главе 17, то &lt;code&gt;take&lt;/code&gt; метод на &lt;code&gt;Option&lt;/code&gt; не принимает &lt;code&gt;Some&lt;/code&gt; вариант из и листья &lt;code&gt;None&lt;/code&gt; в своем месте. Мы используем &lt;code&gt;if let&lt;/code&gt; для разрушения &lt;code&gt;Some&lt;/code&gt; и получения нити; затем мы вызываем &lt;code&gt;join&lt;/code&gt; в потоке. Если рабочий поток уже имеет значение &lt;code&gt;None&lt;/code&gt; , мы знаем, что этот рабочий поток уже очистил свой поток, поэтому в этом случае ничего не происходит.</target>
        </trans-unit>
        <trans-unit id="9fd5d9a215556134ab45028a161d57190ff678d3" translate="yes" xml:space="preserve">
          <source>As discussed in Chapter 6, we use patterns in the arms of &lt;code&gt;match&lt;/code&gt; expressions. Formally, &lt;code&gt;match&lt;/code&gt; expressions are defined as the keyword &lt;code&gt;match&lt;/code&gt;, a value to match on, and one or more match arms that consist of a pattern and an expression to run if the value matches that arm&amp;rsquo;s pattern, like this:</source>
          <target state="translated">Как уже говорилось в главе 6, мы используем образцы в руках &lt;code&gt;match&lt;/code&gt; выражений. Формально &lt;code&gt;match&lt;/code&gt; выражения определяется как ключевое слово &lt;code&gt;match&lt;/code&gt; , значение для сопоставления, и один или несколько матчей руки , которые состоят из шаблона и выражения для запуска , если значение соответствует шаблону этой руки, как это:</target>
        </trans-unit>
        <trans-unit id="b597a68d9b285f7d308e42a0c9a8b37ad1bf7193" translate="yes" xml:space="preserve">
          <source>As for what happens behind the scenes, when optimizations are enabled the final generated machine code might look very different from the code:</source>
          <target state="translated">Что касается того,что происходит за кулисами,когда оптимизация включена,окончательный сгенерированный машинный код может выглядеть очень по-другому:</target>
        </trans-unit>
        <trans-unit id="e7061cd66862cc7d4e84cb20891d413f4dbad19d" translate="yes" xml:space="preserve">
          <source>As functions, they must either return syntax, panic, or loop endlessly. Returned syntax either replaces or adds the syntax depending on the kind of procedural macro. Panics are caught by the compiler and are turned into a compiler error. Endless loops are not caught by the compiler which hangs the compiler.</source>
          <target state="translated">В качестве функций они должны либо возвращать синтаксис,панику,либо цикл бесконечно.Возвращаемый синтаксис либо заменяет,либо добавляет синтаксис в зависимости от типа процедурного макроса.Паника перехватывается компилятором и превращается в ошибку компилятора.Бесконечные циклы не перехватываются компилятором,который вешает компилятор.</target>
        </trans-unit>
        <trans-unit id="fd8f9685a0be8d16b4d260e66976648f0f435f12" translate="yes" xml:space="preserve">
          <source>As humans, we can look at this code and see that &lt;code&gt;string1&lt;/code&gt; is longer than &lt;code&gt;string2&lt;/code&gt; and therefore &lt;code&gt;result&lt;/code&gt; will contain a reference to &lt;code&gt;string1&lt;/code&gt;. Because &lt;code&gt;string1&lt;/code&gt; has not gone out of scope yet, a reference to &lt;code&gt;string1&lt;/code&gt; will still be valid for the &lt;code&gt;println!&lt;/code&gt; statement. However, the compiler can&amp;rsquo;t see that the reference is valid in this case. We&amp;rsquo;ve told Rust that the lifetime of the reference returned by the &lt;code&gt;longest&lt;/code&gt; function is the same as the smaller of the lifetimes of the references passed in. Therefore, the borrow checker disallows the code in Listing 10-24 as possibly having an invalid reference.</source>
          <target state="translated">Как люди, мы можем взглянуть на этот код и увидеть, что &lt;code&gt;string1&lt;/code&gt; длиннее, чем &lt;code&gt;string2&lt;/code&gt; и поэтому &lt;code&gt;result&lt;/code&gt; будет содержать ссылку на &lt;code&gt;string1&lt;/code&gt; . Поскольку &lt;code&gt;string1&lt;/code&gt; еще не вышла за пределы области видимости, ссылка на &lt;code&gt;string1&lt;/code&gt; прежнему будет действительна для &lt;code&gt;println!&lt;/code&gt; заявление. Однако компилятор не видит, что ссылка действительна в этом случае. Мы сообщили Rust, что время жизни ссылки, возвращаемой самой &lt;code&gt;longest&lt;/code&gt; функцией, такое же, как и меньшее из значений времени жизни переданных ссылок. Таким образом, программа проверки заимствований запрещает код в Листинге 10-24, поскольку он может иметь недопустимую ссылку. .</target>
        </trans-unit>
        <trans-unit id="6d9f4910be4026effcf198634df42e1c4041dff1" translate="yes" xml:space="preserve">
          <source>As in most other programming languages, a Boolean type in Rust has two possible values: &lt;code&gt;true&lt;/code&gt; and &lt;code&gt;false&lt;/code&gt;. Booleans are one byte in size. The Boolean type in Rust is specified using &lt;code&gt;bool&lt;/code&gt;. For example:</source>
          <target state="translated">Как и в большинстве других языков программирования, логический тип в Rust имеет два возможных значения: &lt;code&gt;true&lt;/code&gt; и &lt;code&gt;false&lt;/code&gt; . Логические значения имеют размер один байт. Тип Boolean в Rust указывается с помощью &lt;code&gt;bool&lt;/code&gt; . Например:</target>
        </trans-unit>
        <trans-unit id="45c7aa166fa09685143658300364b92158ea06fe" translate="yes" xml:space="preserve">
          <source>As is the case in &lt;a href=&quot;if-expr#if-let-expressions&quot;&gt;&lt;code&gt;if let&lt;/code&gt; expressions&lt;/a&gt;, the scrutinee cannot be a &lt;a href=&quot;operator-expr#lazy-boolean-operators&quot;&gt;lazy boolean operator expression&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="118d39ec67253c2f49ef6f0a1ef21526ef7b61b3" translate="yes" xml:space="preserve">
          <source>As it turns out, though, most traits can have an &lt;code&gt;impl&lt;/code&gt; for &lt;code&gt;!&lt;/code&gt;. Take &lt;a href=&quot;fmt/trait.debug&quot;&gt;&lt;code&gt;Debug&lt;/code&gt;&lt;/a&gt; for example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a025b290deb94845050bfa62909fd15fe5ae74be" translate="yes" xml:space="preserve">
          <source>As long as your command line parsing logic is small, it can remain in &lt;em&gt;main.rs&lt;/em&gt;.</source>
          <target state="translated">Пока ваш командная строка синтаксический логик мал, она может оставаться в &lt;em&gt;main.rs&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="8323a3696731d93f0a84dafc08f2d32df5ef0903" translate="yes" xml:space="preserve">
          <source>As mentioned at the start of the chapter, testing is a complex discipline, and different people use different terminology and organization. The Rust community thinks about tests in terms of two main categories: &lt;em&gt;unit tests&lt;/em&gt; and &lt;em&gt;integration tests&lt;/em&gt;. Unit tests are small and more focused, testing one module in isolation at a time, and can test private interfaces. Integration tests are entirely external to your library and use your code in the same way any other external code would, using only the public interface and potentially exercising multiple modules per test.</source>
          <target state="translated">Как упоминалось в начале главы, тестирование - сложная дисциплина, и разные люди используют разную терминологию и организацию. Сообщество Rust рассматривает тесты с точки зрения двух основных категорий: &lt;em&gt;модульные тесты&lt;/em&gt; и &lt;em&gt;интеграционные тесты&lt;/em&gt; . Модульные тесты небольшие и более сфокусированные, тестируют один модуль изолированно и могут тестировать частные интерфейсы. Интеграционные тесты являются полностью внешними по отношению к вашей библиотеке и используют ваш код так же, как любой другой внешний код, используя только общедоступный интерфейс и потенциально выполняя несколько модулей для каждого теста.</target>
        </trans-unit>
        <trans-unit id="10eda87545057c2aa683c0bbfe8990122953ece6" translate="yes" xml:space="preserve">
          <source>As mentioned before, trait objects contain pointers to method tables. So, if we have:</source>
          <target state="translated">Как уже упоминалось ранее,объекты трейта содержат указатели на таблицы методов.Так что,если у нас есть:</target>
        </trans-unit>
        <trans-unit id="4761017ad6dee318134842b138bc05d35199a594" translate="yes" xml:space="preserve">
          <source>As mentioned earlier, &lt;code&gt;read_line&lt;/code&gt; puts what the user types into the string we&amp;rsquo;re passing it, but it also returns a value&amp;mdash;in this case, an &lt;a href=&quot;../std/io/type.result&quot;&gt;&lt;code&gt;io::Result&lt;/code&gt;&lt;/a&gt;. Rust has a number of types named &lt;code&gt;Result&lt;/code&gt; in its standard library: a generic &lt;a href=&quot;../std/result/enum.result&quot;&gt;&lt;code&gt;Result&lt;/code&gt;&lt;/a&gt; as well as specific versions for submodules, such as &lt;code&gt;io::Result&lt;/code&gt;.</source>
          <target state="translated">Как упоминалось ранее, &lt;code&gt;read_line&lt;/code&gt; помещает то, что пользователь вводит, в строку, которую мы ему передаем, но также возвращает значение - в данном случае &lt;a href=&quot;../std/io/type.result&quot;&gt; &lt;code&gt;io::Result&lt;/code&gt; &lt;/a&gt; . В стандартной библиотеке Rust есть несколько типов с именем &lt;code&gt;Result&lt;/code&gt; : общий &lt;a href=&quot;../std/result/enum.result&quot;&gt; &lt;code&gt;Result&lt;/code&gt; &lt;/a&gt; а также специальные версии для подмодулей, такие как &lt;code&gt;io::Result&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3f7435a393907a8b1c4a2fc1b69a43772076a5c5" translate="yes" xml:space="preserve">
          <source>As mentioned earlier, because very little of how Rust handles concurrency is part of the language, many concurrency solutions are implemented as crates. These evolve more quickly than the standard library, so be sure to search online for the current, state-of-the-art crates to use in multithreaded situations.</source>
          <target state="translated">Как уже упоминалось ранее,поскольку очень мало параллелизма в работе Rust является частью языка,многие параллельные решения реализуются в виде ящиков.Они развиваются быстрее,чем стандартная библиотека,поэтому не забудьте поискать в Интернете современные ящики для использования в многопоточных ситуациях.</target>
        </trans-unit>
        <trans-unit id="a6f8e14141b394aeafb54cb0af5563e56c04e70c" translate="yes" xml:space="preserve">
          <source>As mentioned in Chapter 2, by default variables are immutable. This is one of many nudges Rust gives you to write your code in a way that takes advantage of the safety and easy concurrency that Rust offers. However, you still have the option to make your variables mutable. Let&amp;rsquo;s explore how and why Rust encourages you to favor immutability and why sometimes you might want to opt out.</source>
          <target state="translated">Как упоминалось в главе 2, по умолчанию переменные неизменяемы. Это один из многих стимулов, которые Rust дает вам для написания кода таким образом, чтобы использовать преимущества безопасности и простого параллелизма, которые предлагает Rust. Однако у вас все еще есть возможность сделать свои переменные изменяемыми. Давайте разберемся, как и почему Rust побуждает вас отдавать предпочтение неизменности и почему иногда вы можете отказаться от него.</target>
        </trans-unit>
        <trans-unit id="7641c8a38df92f9203220e805ba01b7f30732a0c" translate="yes" xml:space="preserve">
          <source>As mentioned in the module documentation, threads are usually made to communicate using &lt;a href=&quot;../sync/mpsc/index&quot;&gt;&lt;code&gt;channels&lt;/code&gt;&lt;/a&gt;, here is how it usually looks.</source>
          <target state="translated">Как упоминалось в документации модуля, потоки обычно создаются для связи с использованием &lt;a href=&quot;../sync/mpsc/index&quot;&gt; &lt;code&gt;channels&lt;/code&gt; &lt;/a&gt; , вот как это обычно выглядит.</target>
        </trans-unit>
        <trans-unit id="fad7d9a9d62e3d2756844c471849a76502954355" translate="yes" xml:space="preserve">
          <source>As non-Rust calling conventions do not support unwinding, unwinding past the end of an extern function will cause the process to abort. In LLVM, this is implemented by executing an illegal instruction.</source>
          <target state="translated">Поскольку соглашения о не ржавых вызовах не поддерживают раскручивание,раскручивание после окончания функции внешнего вызова приведет к прерыванию процесса.В LLVM это реализуется путем выполнения незаконной инструкции.</target>
        </trans-unit>
        <trans-unit id="10482a83c62e485259adbe51b49060ecef064cde" translate="yes" xml:space="preserve">
          <source>As noted above, coercions mean that most code doesn't have to be concerned with this distinction. However, you can tell the difference when using &lt;strong&gt;transmute&lt;/strong&gt; to convert a fn item into a fn pointer.</source>
          <target state="translated">Как отмечалось выше, принуждение означает, что большая часть кода не должна учитывать это различие. Однако вы можете заметить разницу при использовании &lt;strong&gt;преобразования&lt;/strong&gt; для преобразования элемента fn в указатель fn.</target>
        </trans-unit>
        <trans-unit id="a5cb1839eab079676f60d9f52ac6387e18acb792" translate="yes" xml:space="preserve">
          <source>As noted in the documentation for the type itself, it is essentially an opaque ID, but is guaranteed to be unique for each thread. The returned value is entirely opaque -- only equality testing is stable. Note that it is not guaranteed which values new threads will return, and this may change across Rust versions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f7018b1edbbce45316477bb25e1ffd907f9a0adb" translate="yes" xml:space="preserve">
          <source>As one would expect, primitive types like &lt;a href=&quot;../primitive.u8&quot;&gt;&lt;code&gt;u8&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../primitive.f64&quot;&gt;&lt;code&gt;f64&lt;/code&gt;&lt;/a&gt; are all &lt;a href=&quot;trait.sync&quot;&gt;&lt;code&gt;Sync&lt;/code&gt;&lt;/a&gt;, and so are simple aggregate types containing them, like tuples, structs and enums. More examples of basic &lt;a href=&quot;trait.sync&quot;&gt;&lt;code&gt;Sync&lt;/code&gt;&lt;/a&gt; types include &quot;immutable&quot; types like &lt;code&gt;&amp;amp;T&lt;/code&gt;, and those with simple inherited mutability, such as &lt;a href=&quot;../boxed/struct.box&quot;&gt;&lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../vec/struct.vec&quot;&gt;&lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt; and most other collection types. (Generic parameters need to be &lt;a href=&quot;trait.sync&quot;&gt;&lt;code&gt;Sync&lt;/code&gt;&lt;/a&gt; for their container to be &lt;a href=&quot;trait.sync&quot;&gt;&lt;code&gt;Sync&lt;/code&gt;&lt;/a&gt;.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="78cffef75c7264e29f3831c1d70df7b7db90b085" translate="yes" xml:space="preserve">
          <source>As one would expect, primitive types like &lt;a href=&quot;../primitive.u8&quot;&gt;&lt;code&gt;u8&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../primitive.f64&quot;&gt;&lt;code&gt;f64&lt;/code&gt;&lt;/a&gt; are all &lt;code&gt;Sync&lt;/code&gt;, and so are simple aggregate types containing them, like tuples, structs and enums. More examples of basic &lt;code&gt;Sync&lt;/code&gt; types include &quot;immutable&quot; types like &lt;code&gt;&amp;amp;T&lt;/code&gt;, and those with simple inherited mutability, such as &lt;a href=&quot;../boxed/struct.box&quot;&gt;&lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../vec/struct.vec&quot;&gt;&lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt; and most other collection types. (Generic parameters need to be &lt;code&gt;Sync&lt;/code&gt; for their container to be &lt;code&gt;Sync&lt;/code&gt;.)</source>
          <target state="translated">Как и следовало ожидать, все примитивные типы, такие как &lt;a href=&quot;../primitive.u8&quot;&gt; &lt;code&gt;u8&lt;/code&gt; &lt;/a&gt; и &lt;a href=&quot;../primitive.f64&quot;&gt; &lt;code&gt;f64&lt;/code&gt; ,&lt;/a&gt; являются &lt;code&gt;Sync&lt;/code&gt; , как и простые агрегатные типы, содержащие их, такие как кортежи, структуры и перечисления. Дополнительные примеры базовых типов &lt;code&gt;Sync&lt;/code&gt; включают &amp;laquo;неизменяемые&amp;raquo; типы, такие как &lt;code&gt;&amp;amp;T&lt;/code&gt; , и типы с простой наследуемой изменчивостью, такие как &lt;a href=&quot;../boxed/struct.box&quot;&gt; &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;../vec/struct.vec&quot;&gt; &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; &lt;/a&gt; и большинство других типов коллекций. (Общие параметры должны быть &lt;code&gt;Sync&lt;/code&gt; чтобы их контейнер был &lt;code&gt;Sync&lt;/code&gt; .)</target>
        </trans-unit>
        <trans-unit id="e3262fa97dd64c6174eeff7f6dc1bf92e0938ab9" translate="yes" xml:space="preserve">
          <source>As per &lt;a href=&quot;https://tools.ietf.org/html/rfc3879&quot;&gt;RFC 3879&lt;/a&gt;, the whole &lt;code&gt;FEC0::/10&lt;/code&gt; prefix is deprecated. New software must not support site-local addresses.</source>
          <target state="translated">Согласно &lt;a href=&quot;https://tools.ietf.org/html/rfc3879&quot;&gt;RFC 3879&lt;/a&gt; , весь &lt;code&gt;FEC0::/10&lt;/code&gt; устарел. Новое программное обеспечение не должно поддерживать локальные адреса сайта.</target>
        </trans-unit>
        <trans-unit id="a8a04accdf6a8ca9fa81bf61cc029868f206046f" translate="yes" xml:space="preserve">
          <source>As said above, the &lt;code&gt;derive&lt;/code&gt; attribute is only allowed on structs, unions or enums:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="51aa8d67495f62b66ef894735fcf63e6606dac28" translate="yes" xml:space="preserve">
          <source>As shown in the example above, &lt;code&gt;for&lt;/code&gt; loops (along with all other loops) can be tagged, using similar syntax to lifetimes (only visually similar, entirely distinct in practice). Giving the same tag to &lt;code&gt;break&lt;/code&gt; breaks the tagged loop, which is useful for inner loops. It is definitely not a goto.</source>
          <target state="translated">Как показано в приведенном выше примере, циклы &lt;code&gt;for&lt;/code&gt; (вместе со всеми другими циклами) могут быть помечены с использованием синтаксиса, аналогичного времени жизни (только визуально похожего, полностью отличного на практике). Предоставление того же тега &lt;code&gt;break&lt;/code&gt; прерывает помеченный цикл, что полезно для внутренних циклов. Это определенно не goto.</target>
        </trans-unit>
        <trans-unit id="ea3901788f56444df8cfba46d8496b7c3ef215ae" translate="yes" xml:space="preserve">
          <source>As slices store the length of the sequence they refer to, they have twice the size of pointers to &lt;a href=&quot;marker/trait.sized&quot;&gt;&lt;code&gt;Sized&lt;/code&gt;&lt;/a&gt; types. Also see the reference on &lt;a href=&quot;../reference/dynamically-sized-types&quot;&gt;dynamically sized types&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c276f971f322ddf36b0d0a39caeff0e860e6ee88" translate="yes" xml:space="preserve">
          <source>As stated in the User Datagram Protocol's specification in &lt;a href=&quot;https://tools.ietf.org/html/rfc768&quot;&gt;IETF RFC 768&lt;/a&gt;, UDP is an unordered, unreliable protocol; refer to &lt;a href=&quot;struct.tcplistener&quot;&gt;&lt;code&gt;TcpListener&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;struct.tcpstream&quot;&gt;&lt;code&gt;TcpStream&lt;/code&gt;&lt;/a&gt; for TCP primitives.</source>
          <target state="translated">Как указано в спецификации протокола пользовательских дейтаграмм в &lt;a href=&quot;https://tools.ietf.org/html/rfc768&quot;&gt;IETF RFC 768&lt;/a&gt; , UDP - это неупорядоченный и ненадежный протокол; см. &lt;a href=&quot;struct.tcplistener&quot;&gt; &lt;code&gt;TcpListener&lt;/code&gt; &lt;/a&gt; и &lt;a href=&quot;struct.tcpstream&quot;&gt; &lt;code&gt;TcpStream&lt;/code&gt; &lt;/a&gt; для примитивов TCP.</target>
        </trans-unit>
        <trans-unit id="5379cc453111a9586b0e6132f3432e2017bb8946" translate="yes" xml:space="preserve">
          <source>As string slices are a slice of bytes, the raw pointer points to a &lt;a href=&quot;../primitive.u8&quot;&gt;&lt;code&gt;u8&lt;/code&gt;&lt;/a&gt;. This pointer will be pointing to the first byte of the string slice.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="54d4fd727ce2657161522c6ae3a06633673c9cbd" translate="yes" xml:space="preserve">
          <source>As string slices are a slice of bytes, the raw pointer points to a &lt;a href=&quot;primitive.u8&quot;&gt;&lt;code&gt;u8&lt;/code&gt;&lt;/a&gt;. This pointer will be pointing to the first byte of the string slice.</source>
          <target state="translated">Поскольку фрагменты строки представляют собой фрагменты байтов, необработанный указатель указывает на &lt;a href=&quot;primitive.u8&quot;&gt; &lt;code&gt;u8&lt;/code&gt; &lt;/a&gt; . Этот указатель будет указывать на первый байт среза строки.</target>
        </trans-unit>
        <trans-unit id="b757bf93c530db10fdab40d9aeca4c3f17d50ad1" translate="yes" xml:space="preserve">
          <source>As such, the &lt;code&gt;from_utf8&lt;/code&gt; family of functions and methods for both &lt;a href=&quot;../string/struct.string#method.from_utf8&quot;&gt;&lt;code&gt;String&lt;/code&gt;&lt;/a&gt;s and &lt;a href=&quot;fn.from_utf8&quot;&gt;&lt;code&gt;&amp;amp;str&lt;/code&gt;&lt;/a&gt;s make use of this error, for example.</source>
          <target state="translated">Таким образом, семейство функций и методов &lt;code&gt;from_utf8&lt;/code&gt; для &lt;a href=&quot;../string/struct.string#method.from_utf8&quot;&gt; &lt;code&gt;String&lt;/code&gt; &lt;/a&gt; s и &lt;a href=&quot;fn.from_utf8&quot;&gt; &lt;code&gt;&amp;amp;str&lt;/code&gt; &lt;/a&gt; , например, использует эту ошибку.</target>
        </trans-unit>
        <trans-unit id="a7bae3aa148344b33c64086da16dba6a42474602" translate="yes" xml:space="preserve">
          <source>As the author of a data structure you get to decide for each field whether pinning &quot;propagates&quot; to this field or not. Pinning that propagates is also called &quot;structural&quot;, because it follows the structure of the type. In the following subsections, we describe the considerations that have to be made for either choice.</source>
          <target state="translated">Как автор структуры данных Вы можете решить для каждого поля,будет ли пиннинг &quot;распространяться&quot; на это поле или нет.Пиннинг,который распространяется,также называется &quot;структурным&quot;,так как он следует за структурой типа.В следующих подразделах мы опишем соображения,которые необходимо учитывать при выборе того или иного типа.</target>
        </trans-unit>
        <trans-unit id="0b86e5cf0a558c007bb8a3eed83a07619a169108" translate="yes" xml:space="preserve">
          <source>As the error message indicates, only &lt;code&gt;u8&lt;/code&gt; can be cast into &lt;code&gt;char&lt;/code&gt;. Example:</source>
          <target state="translated">Как указано в сообщении об ошибке, только &lt;code&gt;u8&lt;/code&gt; можно преобразовать в &lt;code&gt;char&lt;/code&gt; . Пример:</target>
        </trans-unit>
        <trans-unit id="6c037f01ab1e44c1b49068f96530e00f210988e8" translate="yes" xml:space="preserve">
          <source>As the target platform's native endianness is used, portable code likely wants to use &lt;a href=&quot;#method.from_be_bytes&quot;&gt;&lt;code&gt;from_be_bytes&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#method.from_le_bytes&quot;&gt;&lt;code&gt;from_le_bytes&lt;/code&gt;&lt;/a&gt;, as appropriate instead.</source>
          <target state="translated">Поскольку используется собственный порядок байтов целевой платформы, переносимый код, вероятно, захочет использовать &lt;a href=&quot;#method.from_be_bytes&quot;&gt; &lt;code&gt;from_be_bytes&lt;/code&gt; &lt;/a&gt; или &lt;a href=&quot;#method.from_le_bytes&quot;&gt; &lt;code&gt;from_le_bytes&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="1c8bfefec8dafcbb055c2ea433ad31a56feecccd" translate="yes" xml:space="preserve">
          <source>As the target platform's native endianness is used, portable code should use &lt;a href=&quot;#method.to_be_bytes&quot;&gt;&lt;code&gt;to_be_bytes&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#method.to_le_bytes&quot;&gt;&lt;code&gt;to_le_bytes&lt;/code&gt;&lt;/a&gt;, as appropriate, instead.</source>
          <target state="translated">Поскольку используется собственный порядок байтов целевой платформы, переносимый код должен использовать &lt;a href=&quot;#method.to_be_bytes&quot;&gt; &lt;code&gt;to_be_bytes&lt;/code&gt; &lt;/a&gt; или &lt;a href=&quot;#method.to_le_bytes&quot;&gt; &lt;code&gt;to_le_bytes&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="c2aae14d23e6b4a7f032b38d8e95a4d1b336b019" translate="yes" xml:space="preserve">
          <source>As this is the only method for this trait, the &lt;a href=&quot;trait.extend&quot;&gt;trait-level&lt;/a&gt; docs contain more details.</source>
          <target state="translated">Поскольку это единственный метод для этой черты, документация на &lt;a href=&quot;trait.extend&quot;&gt;уровне черт&lt;/a&gt; содержит более подробную информацию.</target>
        </trans-unit>
        <trans-unit id="3b3bf99d81b548977e24e38bef4df0cf86423b5b" translate="yes" xml:space="preserve">
          <source>As this is the only required method for this trait, the &lt;a href=&quot;trait.extend&quot;&gt;trait-level&lt;/a&gt; docs contain more details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f292830332806677ad0b0527bf74ceadc350e53c" translate="yes" xml:space="preserve">
          <source>As usual, this output tells us exactly what has gone wrong.</source>
          <target state="translated">Как обычно,этот выход говорит нам о том,что именно пошло не так.</target>
        </trans-unit>
        <trans-unit id="6d6b5c58bde3c21428520a679924eb54e0901d4d" translate="yes" xml:space="preserve">
          <source>As we did with structs, we can define enums to hold generic data types in their variants. Let&amp;rsquo;s take another look at the &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt; enum that the standard library provides, which we used in Chapter 6:</source>
          <target state="translated">Как и в случае со структурами, мы можем определить перечисления для хранения универсальных типов данных в их вариантах. Давайте еще раз посмотрим на перечисление &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt; , предоставляемое стандартной библиотекой, которое мы использовали в главе 6:</target>
        </trans-unit>
        <trans-unit id="c9b62e53d822366f9040eaf9632aa096cd8d407c" translate="yes" xml:space="preserve">
          <source>As we saw when we printed the vector, the program&amp;rsquo;s name takes up the first value in the vector at &lt;code&gt;args[0]&lt;/code&gt;, so we&amp;rsquo;re starting at index &lt;code&gt;1&lt;/code&gt;. The first argument &lt;code&gt;minigrep&lt;/code&gt; takes is the string we&amp;rsquo;re searching for, so we put a reference to the first argument in the variable &lt;code&gt;query&lt;/code&gt;. The second argument will be the filename, so we put a reference to the second argument in the variable &lt;code&gt;filename&lt;/code&gt;.</source>
          <target state="translated">Как мы видели при печати вектора, имя программы занимает первое значение в векторе с &lt;code&gt;args[0]&lt;/code&gt; , поэтому мы начинаем с индекса &lt;code&gt;1&lt;/code&gt; . Первый аргумент, &lt;code&gt;minigrep&lt;/code&gt; принимает minigrep, - это строка, которую мы ищем, поэтому мы помещаем ссылку на первый аргумент в &lt;code&gt;query&lt;/code&gt; переменной . Вторым аргументом будет имя файла, поэтому мы помещаем ссылку на второй аргумент в &lt;code&gt;filename&lt;/code&gt; переменной .</target>
        </trans-unit>
        <trans-unit id="387526bcd86a3d932ce8d276666fe3de9ea36fb2" translate="yes" xml:space="preserve">
          <source>As well as overloading the unary &lt;code&gt;*&lt;/code&gt; operator, &lt;a href=&quot;../std/ops/trait.deref&quot;&gt;&lt;code&gt;Deref&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../std/ops/trait.derefmut&quot;&gt;&lt;code&gt;DerefMut&lt;/code&gt;&lt;/a&gt; are also used in &lt;a href=&quot;expressions/method-call-expr&quot;&gt;method resolution&lt;/a&gt; and &lt;a href=&quot;type-coercions#coercion-types&quot;&gt;deref coercions&lt;/a&gt;.</source>
          <target state="translated">Помимо перегрузки унарного оператора &lt;code&gt;*&lt;/code&gt; , &lt;a href=&quot;../std/ops/trait.deref&quot;&gt; &lt;code&gt;Deref&lt;/code&gt; &lt;/a&gt; и &lt;a href=&quot;../std/ops/trait.derefmut&quot;&gt; &lt;code&gt;DerefMut&lt;/code&gt; &lt;/a&gt; также используются в &lt;a href=&quot;expressions/method-call-expr&quot;&gt;разрешении методов&lt;/a&gt; и приведениях &lt;a href=&quot;type-coercions#coercion-types&quot;&gt;deref&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="00f0078e7027bdd5fb06a3cdb9f947f1a54e08c1" translate="yes" xml:space="preserve">
          <source>As with &lt;a href=&quot;#method.as_ref&quot;&gt;&lt;code&gt;as_ref&lt;/code&gt;&lt;/a&gt;, this is unsafe because it cannot verify the validity of the returned pointer, nor can it ensure that the lifetime &lt;code&gt;'a&lt;/code&gt; returned is indeed a valid lifetime for the contained data.</source>
          <target state="translated">Как и в случае с &lt;a href=&quot;#method.as_ref&quot;&gt; &lt;code&gt;as_ref&lt;/code&gt; &lt;/a&gt; , это небезопасно, потому что он не может проверить действительность возвращенного указателя и не может гарантировать, что время жизни &lt;code&gt;'a&lt;/code&gt; действительно является допустимым временем жизни для содержащихся данных.</target>
        </trans-unit>
        <trans-unit id="700b249dcaa7ad65d8fbe7b2f99bd14fed03c63b" translate="yes" xml:space="preserve">
          <source>As with &lt;a href=&quot;../mem/union.maybeuninit#method.assume_init&quot;&gt;&lt;code&gt;MaybeUninit::assume_init&lt;/code&gt;&lt;/a&gt;, it is up to the caller to guarantee that the inner value really is in an initialized state. Calling this when the content is not yet fully initialized causes immediate undefined behavior.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b569f01826b7a489e1b0df46d3df2feea0987b31" translate="yes" xml:space="preserve">
          <source>As with &lt;a href=&quot;../mem/union.maybeuninit#method.assume_init&quot;&gt;&lt;code&gt;MaybeUninit::assume_init&lt;/code&gt;&lt;/a&gt;, it is up to the caller to guarantee that the value really is in an initialized state. Calling this when the content is not yet fully initialized causes immediate undefined behavior.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b5a160954fc2e5db9027a60b41aea2242946a496" translate="yes" xml:space="preserve">
          <source>As with &lt;a href=&quot;../mem/union.maybeuninit#method.assume_init&quot;&gt;&lt;code&gt;MaybeUninit::assume_init&lt;/code&gt;&lt;/a&gt;, it is up to the caller to guarantee that the values really are in an initialized state. Calling this when the content is not yet fully initialized causes immediate undefined behavior.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e824f1a2f05ba862631703f190681d4c2dd2b70b" translate="yes" xml:space="preserve">
          <source>As with &lt;a href=&quot;use-declarations#underscore-imports&quot;&gt;underscore imports&lt;/a&gt;, macros may safely emit the same unnamed constant in the same scope more than once. For example, the following should not produce an error:</source>
          <target state="translated">Как и при &lt;a href=&quot;use-declarations#underscore-imports&quot;&gt;импорте подчеркивания&lt;/a&gt; , макросы могут безопасно генерировать одну и ту же безымянную константу в одной и той же области более одного раза. Например, следующее не должно приводить к ошибке:</target>
        </trans-unit>
        <trans-unit id="4c083e9f314596dd1da24d21de9af221cdf99253" translate="yes" xml:space="preserve">
          <source>As with &lt;code&gt;let&lt;/code&gt; bindings, function arguments are irrefutable &lt;a href=&quot;../patterns&quot;&gt;patterns&lt;/a&gt;, so any pattern that is valid in a let binding is also valid as an argument:</source>
          <target state="translated">Как и в случае привязок &lt;code&gt;let&lt;/code&gt; , аргументы функции являются неопровержимыми &lt;a href=&quot;../patterns&quot;&gt;шаблонами&lt;/a&gt; , поэтому любой шаблон, допустимый в привязке let, также действителен в качестве аргумента:</target>
        </trans-unit>
        <trans-unit id="021860f0b9c701b01e24f471ef9064ff787c7fc6" translate="yes" xml:space="preserve">
          <source>As with &lt;code&gt;split()&lt;/code&gt;, if the first or last element is matched, an empty slice will be the first (or last) item returned by the iterator.</source>
          <target state="translated">Как и в случае с &lt;code&gt;split()&lt;/code&gt; , если совпадают первый или последний элемент, пустой срез будет первым (или последним) элементом, возвращаемым итератором.</target>
        </trans-unit>
        <trans-unit id="a311c5a68716dfa8ec04c201fd72e1f6bf20977d" translate="yes" xml:space="preserve">
          <source>As with any variable, if we want to be able to change its value, we need to make it mutable using the &lt;code&gt;mut&lt;/code&gt; keyword, as discussed in Chapter 3. The numbers we place inside are all of type &lt;code&gt;i32&lt;/code&gt;, and Rust infers this from the data, so we don&amp;rsquo;t need the &lt;code&gt;Vec&amp;lt;i32&amp;gt;&lt;/code&gt; annotation.</source>
          <target state="translated">Как и в случае с любой другой переменной, если мы хотим иметь возможность изменять ее значение, нам нужно сделать ее изменяемой с помощью ключевого слова &lt;code&gt;mut&lt;/code&gt; , как обсуждалось в главе 3. Все числа, которые мы &lt;code&gt;i32&lt;/code&gt; внутрь, относятся к типу i32 , и Rust выводит это из data, поэтому аннотация &lt;code&gt;Vec&amp;lt;i32&amp;gt;&lt;/code&gt; нам не нужна .</target>
        </trans-unit>
        <trans-unit id="4275e8a23f25e311b7879f2ca06bcf06be2ae3c3" translate="yes" xml:space="preserve">
          <source>As with many types, we create a &lt;code&gt;Mutex&amp;lt;T&amp;gt;&lt;/code&gt; using the associated function &lt;code&gt;new&lt;/code&gt;. To access the data inside the mutex, we use the &lt;code&gt;lock&lt;/code&gt; method to acquire the lock. This call will block the current thread so it can&amp;rsquo;t do any work until it&amp;rsquo;s our turn to have the lock.</source>
          <target state="translated">Как и многие другие типы, мы создаем &lt;code&gt;Mutex&amp;lt;T&amp;gt;&lt;/code&gt; используя связанную функцию &lt;code&gt;new&lt;/code&gt; . Чтобы получить доступ к данным внутри мьютекса, мы используем метод &lt;code&gt;lock&lt;/code&gt; для получения блокировки. Этот вызов заблокирует текущий поток, поэтому он не сможет выполнять никакой работы, пока не наступит наша очередь получить блокировку.</target>
        </trans-unit>
        <trans-unit id="35a5907e5dda02884b0d94275e42a50fca56e187" translate="yes" xml:space="preserve">
          <source>As with regular variables, we specify mutability using the &lt;code&gt;mut&lt;/code&gt; keyword. Any code that reads or writes from &lt;code&gt;COUNTER&lt;/code&gt; must be within an &lt;code&gt;unsafe&lt;/code&gt; block. This code compiles and prints &lt;code&gt;COUNTER: 3&lt;/code&gt; as we would expect because it&amp;rsquo;s single threaded. Having multiple threads access &lt;code&gt;COUNTER&lt;/code&gt; would likely result in data races.</source>
          <target state="translated">Как и в случае с обычными переменными, мы указываем изменчивость с помощью ключевого слова &lt;code&gt;mut&lt;/code&gt; . Любой код, который читает или пишет из &lt;code&gt;COUNTER&lt;/code&gt; , должен находиться в &lt;code&gt;unsafe&lt;/code&gt; блоке. Этот код компилирует и выводит &lt;code&gt;COUNTER: 3&lt;/code&gt; как и следовало ожидать, потому что он однопоточный. Наличие доступа к &lt;code&gt;COUNTER&lt;/code&gt; из нескольких потоков может привести к гонке данных.</target>
        </trans-unit>
        <trans-unit id="3db9d1e08dae612689e0b7adf381cac76d2a83bc" translate="yes" xml:space="preserve">
          <source>As with the &lt;a href=&quot;../struct.hashmap&quot;&gt;&lt;code&gt;HashMap&lt;/code&gt;&lt;/a&gt; type, a &lt;code&gt;HashSet&lt;/code&gt; requires that the elements implement the &lt;a href=&quot;../../cmp/trait.eq&quot;&gt;&lt;code&gt;Eq&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../../hash/trait.hash&quot;&gt;&lt;code&gt;Hash&lt;/code&gt;&lt;/a&gt; traits. This can frequently be achieved by using &lt;code&gt;#[derive(PartialEq, Eq, Hash)]&lt;/code&gt;. If you implement these yourself, it is important that the following property holds:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1fb7b19ef9483e218deb8b0d1a3f5269874b86ed" translate="yes" xml:space="preserve">
          <source>As with the &lt;a href=&quot;struct.hashmap&quot;&gt;&lt;code&gt;HashMap&lt;/code&gt;&lt;/a&gt; type, a &lt;code&gt;HashSet&lt;/code&gt; requires that the elements implement the &lt;a href=&quot;../../cmp/trait.eq&quot;&gt;&lt;code&gt;Eq&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../../hash/trait.hash&quot;&gt;&lt;code&gt;Hash&lt;/code&gt;&lt;/a&gt; traits. This can frequently be achieved by using &lt;code&gt;#[derive(PartialEq, Eq, Hash)]&lt;/code&gt;. If you implement these yourself, it is important that the following property holds:</source>
          <target state="translated">Как и в случае с типом &lt;a href=&quot;struct.hashmap&quot;&gt; &lt;code&gt;HashMap&lt;/code&gt; &lt;/a&gt; , для &lt;code&gt;HashSet&lt;/code&gt; требуется, чтобы элементы реализовывали черты &lt;a href=&quot;../../cmp/trait.eq&quot;&gt; &lt;code&gt;Eq&lt;/code&gt; &lt;/a&gt; и &lt;a href=&quot;../../hash/trait.hash&quot;&gt; &lt;code&gt;Hash&lt;/code&gt; &lt;/a&gt; . Этого часто можно добиться с помощью &lt;code&gt;#[derive(PartialEq, Eq, Hash)]&lt;/code&gt; . Если вы реализуете их самостоятельно, важно, чтобы выполнялось следующее свойство:</target>
        </trans-unit>
        <trans-unit id="c568bda8aab01e836f5470185110a68fb4739aa1" translate="yes" xml:space="preserve">
          <source>As with the &lt;a href=&quot;struct.hashmap&quot;&gt;&lt;code&gt;HashMap&lt;/code&gt;&lt;/a&gt; type, a &lt;code&gt;HashSet&lt;/code&gt; requires that the elements implement the &lt;a href=&quot;../cmp/trait.eq&quot;&gt;&lt;code&gt;Eq&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../hash/trait.hash&quot;&gt;&lt;code&gt;Hash&lt;/code&gt;&lt;/a&gt; traits. This can frequently be achieved by using &lt;code&gt;#[derive(PartialEq, Eq, Hash)]&lt;/code&gt;. If you implement these yourself, it is important that the following property holds:</source>
          <target state="translated">Как и в случае с типом &lt;a href=&quot;struct.hashmap&quot;&gt; &lt;code&gt;HashMap&lt;/code&gt; &lt;/a&gt; , для &lt;code&gt;HashSet&lt;/code&gt; требуется, чтобы элементы реализовывали черты &lt;a href=&quot;../cmp/trait.eq&quot;&gt; &lt;code&gt;Eq&lt;/code&gt; &lt;/a&gt; и &lt;a href=&quot;../hash/trait.hash&quot;&gt; &lt;code&gt;Hash&lt;/code&gt; &lt;/a&gt; . Этого часто можно добиться с помощью &lt;code&gt;#[derive(PartialEq, Eq, Hash)]&lt;/code&gt; . Если вы реализуете их самостоятельно, важно, чтобы выполнялось следующее свойство:</target>
        </trans-unit>
        <trans-unit id="ae28ea4c57639b6218be246b12eabdfb50b7b74a" translate="yes" xml:space="preserve">
          <source>As with variables, we can add type annotations if we want to increase explicitness and clarity at the cost of being more verbose than is strictly necessary. Annotating the types for the closure we defined in Listing 13-5 would look like the definition shown in Listing 13-7.</source>
          <target state="translated">Как и в случае с переменными,мы можем добавлять типовые аннотации,если мы хотим увеличить явность и ясность за счет того,что они более многословны,чем это строго необходимо.Аннотации типов для закрытия,которые мы определили в Листинге 13-5,будут выглядеть как определение,показанное в Листинге 13-7.</target>
        </trans-unit>
        <trans-unit id="96c2069203f702eae6427926792a296cebb74618" translate="yes" xml:space="preserve">
          <source>As you add more integration tests, you might want to make more than one file in the &lt;em&gt;tests&lt;/em&gt; directory to help organize them; for example, you can group the test functions by the functionality they&amp;rsquo;re testing. As mentioned earlier, each file in the &lt;em&gt;tests&lt;/em&gt; directory is compiled as its own separate crate.</source>
          <target state="translated">По мере добавления дополнительных интеграционных тестов вы можете захотеть создать несколько файлов в каталоге &lt;em&gt;тестов,&lt;/em&gt; чтобы упорядочить их; например, вы можете сгруппировать тестовые функции по функциональности, которую они тестируют. Как упоминалось ранее, каждый файл в каталоге &lt;em&gt;тестов&lt;/em&gt; компилируется как отдельный ящик.</target>
        </trans-unit>
        <trans-unit id="064638b9138d50bf7a76d4f1fb8907e6d00d4af4" translate="yes" xml:space="preserve">
          <source>As you also learned in Chapter 1, &lt;code&gt;println!&lt;/code&gt; is a macro that prints a string to the screen:</source>
          <target state="translated">Как вы также узнали из главы 1, &lt;code&gt;println!&lt;/code&gt; это макрос, который выводит на экран строку:</target>
        </trans-unit>
        <trans-unit id="cfbf1a7efc3caed67bc7e41bd453d7589ffb22d8" translate="yes" xml:space="preserve">
          <source>As you can see in the signature of &lt;code&gt;spawn&lt;/code&gt; there are two constraints on both the closure given to &lt;code&gt;spawn&lt;/code&gt; and its return value, let's explain them:</source>
          <target state="translated">Как вы можете видеть в сигнатуре &lt;code&gt;spawn&lt;/code&gt; , есть два ограничения как на закрытие, данное для &lt;code&gt;spawn&lt;/code&gt; ,так и на его возвращаемое значение, давайте объясним их:</target>
        </trans-unit>
        <trans-unit id="0420fe0c9530d1e1d147961f14b139b3fe83e9e2" translate="yes" xml:space="preserve">
          <source>As you can see, the stable toolchain is the default. Most Rust users use stable most of the time. You might want to use stable most of the time, but use nightly on a specific project, because you care about a cutting-edge feature. To do so, you can use &lt;code&gt;rustup override&lt;/code&gt; in that project&amp;rsquo;s directory to set the nightly toolchain as the one &lt;code&gt;rustup&lt;/code&gt; should use when you&amp;rsquo;re in that directory:</source>
          <target state="translated">Как видите, по умолчанию используется стабильный набор инструментов. Большинство пользователей Rust большую часть времени используют стабильную версию. Возможно, вы захотите использовать стабильную версию большую часть времени, но используйте каждую ночь в конкретном проекте, потому что вы заботитесь о передовых функциях. Для этого вы можете использовать &lt;code&gt;rustup override&lt;/code&gt; в каталоге этого проекта, чтобы установить ночную цепочку инструментов в качестве той, которую &lt;code&gt;rustup&lt;/code&gt; должен использовать, когда вы находитесь в этом каталоге:</target>
        </trans-unit>
        <trans-unit id="9d87736b18e618ced4be36c042766a61a7024b14" translate="yes" xml:space="preserve">
          <source>As you can see, this will return the expected, valid items.</source>
          <target state="translated">Как вы видите,это вернет ожидаемые,действительные элементы.</target>
        </trans-unit>
        <trans-unit id="2afcd0df9449bfb1b32a67c779124a1b65363260" translate="yes" xml:space="preserve">
          <source>As you can see, using the parent modules distinguishes the two &lt;code&gt;Result&lt;/code&gt; types. If instead we specified &lt;code&gt;use std::fmt::Result&lt;/code&gt; and &lt;code&gt;use std::io::Result&lt;/code&gt;, we&amp;rsquo;d have two &lt;code&gt;Result&lt;/code&gt; types in the same scope and Rust wouldn&amp;rsquo;t know which one we meant when we used &lt;code&gt;Result&lt;/code&gt;.</source>
          <target state="translated">Как видите, использование родительских модулей различает два типа &lt;code&gt;Result&lt;/code&gt; . Если бы вместо этого мы указали &lt;code&gt;use std::fmt::Result&lt;/code&gt; и &lt;code&gt;use std::io::Result&lt;/code&gt; , у нас было бы два типа &lt;code&gt;Result&lt;/code&gt; в одной и той же области, и Rust не знал бы, какой из них мы имели в виду, когда использовали &lt;code&gt;Result&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="20722bacbfbb971e3e58847f05a0049adb3a009e" translate="yes" xml:space="preserve">
          <source>As you can see, we&amp;rsquo;ve moved everything into a loop from the guess input prompt onward. Be sure to indent the lines inside the loop another four spaces each and run the program again. Notice that there is a new problem because the program is doing exactly what we told it to do: ask for another guess forever! It doesn&amp;rsquo;t seem like the user can quit!</source>
          <target state="translated">Как видите, мы переместили все в цикл, начиная с подсказки ввода предположений и далее. Обязательно отступите строки внутри цикла еще на четыре пробела каждая и снова запустите программу. Обратите внимание на новую проблему, потому что программа делает именно то, что мы ей сказали: вечно спрашивать другое предположение! Не похоже, что пользователь может выйти!</target>
        </trans-unit>
        <trans-unit id="ac1ee84193bb1d8e87992969494a2311a45eebb9" translate="yes" xml:space="preserve">
          <source>As you can see, you can specify type parameters in curly braces for substitution with the actual types (using the regular format string syntax) in a given situation. Furthermore, &lt;code&gt;{Self}&lt;/code&gt; will substitute to the type (in this case, &lt;code&gt;bool&lt;/code&gt;) that we tried to use.</source>
          <target state="translated">Как видите, вы можете указать параметры типа в фигурных скобках для подстановки фактическими типами (используя синтаксис строки обычного формата) в данной ситуации. Кроме того, &lt;code&gt;{Self}&lt;/code&gt; заменит тип (в данном случае &lt;code&gt;bool&lt;/code&gt; ), который мы пытались использовать.</target>
        </trans-unit>
        <trans-unit id="b2e9ae4479b0983efbf6a5f5ed8ba7b27ba6777d" translate="yes" xml:space="preserve">
          <source>As you could see, in many aspects (except for layouts, safety and ownership) unions behave exactly like structs, largely as a consequence of inheriting their syntactic shape from structs. This is also true for many unmentioned aspects of Rust language (such as privacy, name resolution, type inference, generics, trait implementations, inherent implementations, coherence, pattern checking, etc etc etc).</source>
          <target state="translated">Как вы могли видеть,во многих аспектах (за исключением компоновки,безопасности и собственности)союзы ведут себя точно так же,как и структуры,в основном,как следствие наследования их синтаксической формы от структур.Это также относится ко многим неупоминаемым аспектам языка Rust (таким как конфиденциальность,разрешение имен,вывод типа,дженерики,реализации признаков,имманентные реализации,когерентность,проверка шаблонов и т.д.и т.п.).</target>
        </trans-unit>
        <trans-unit id="82fa816a0b7088673d7a49e7db89040e62362916" translate="yes" xml:space="preserve">
          <source>As you could see, in many aspects (except for layouts, safety, and ownership) unions behave exactly like structs, largely as a consequence of inheriting their syntactic shape from structs. This is also true for many unmentioned aspects of Rust language (such as privacy, name resolution, type inference, generics, trait implementations, inherent implementations, coherence, pattern checking, etc etc etc).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b701fb6519447ef85d48d0e79a042ed086034a11" translate="yes" xml:space="preserve">
          <source>As you learned in Chapter 16, &lt;code&gt;thread::spawn&lt;/code&gt; will create a new thread and then run the code in the closure in the new thread. If you run this code and load &lt;em&gt;/sleep&lt;/em&gt; in your browser, then &lt;em&gt;/&lt;/em&gt; in two more browser tabs, you&amp;rsquo;ll indeed see that the requests to &lt;em&gt;/&lt;/em&gt; don&amp;rsquo;t have to wait for &lt;em&gt;/sleep&lt;/em&gt; to finish. But as we mentioned, this will eventually overwhelm the system because you&amp;rsquo;d be making new threads without any limit.</source>
          <target state="translated">Как вы узнали из главы 16, &lt;code&gt;thread::spawn&lt;/code&gt; создает новый поток, а затем запускает код в закрытии в новом потоке. Если вы запустите этот код и загрузите &lt;em&gt;/ спите&lt;/em&gt; в своем браузере, а затем &lt;em&gt;/&lt;/em&gt; на еще двух вкладках браузера, вы действительно увидите, что запросы к &lt;em&gt;/&lt;/em&gt; не должны ждать завершения &lt;em&gt;/ сна&lt;/em&gt; . Но, как мы уже упоминали, это в конечном итоге приведет к перегрузке системы, потому что вы будете создавать новые потоки без каких-либо ограничений.</target>
        </trans-unit>
        <trans-unit id="f4d2e2ae7d1d7339cbe38cf89981448ff9804651" translate="yes" xml:space="preserve">
          <source>As you might have guessed, &lt;code&gt;continue&lt;/code&gt; has a &lt;code&gt;!&lt;/code&gt; value. That is, when Rust computes the type of &lt;code&gt;guess&lt;/code&gt;, it looks at both match arms, the former with a value of &lt;code&gt;u32&lt;/code&gt; and the latter with a &lt;code&gt;!&lt;/code&gt; value. Because &lt;code&gt;!&lt;/code&gt; can never have a value, Rust decides that the type of &lt;code&gt;guess&lt;/code&gt; is &lt;code&gt;u32&lt;/code&gt;.</source>
          <target state="translated">Как вы уже догадались, у &lt;code&gt;continue&lt;/code&gt; есть &lt;code&gt;!&lt;/code&gt; стоимость. То есть, когда Rust вычисляет тип &lt;code&gt;guess&lt;/code&gt; , он смотрит на обе спички, первая со значением &lt;code&gt;u32&lt;/code&gt; , а вторая с a &lt;code&gt;!&lt;/code&gt; стоимость. Потому что &lt;code&gt;!&lt;/code&gt; никогда не может иметь значения, Rust решает, что тип &lt;code&gt;guess&lt;/code&gt; - &lt;code&gt;u32&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="467cfe4dd8e4d010791398ae5c6bd0fbee6d53ca" translate="yes" xml:space="preserve">
          <source>As you might suspect, &lt;code&gt;Mutex&amp;lt;T&amp;gt;&lt;/code&gt; is a smart pointer. More accurately, the call to &lt;code&gt;lock&lt;/code&gt;&lt;em&gt;returns&lt;/em&gt; a smart pointer called &lt;code&gt;MutexGuard&lt;/code&gt;, wrapped in a &lt;code&gt;LockResult&lt;/code&gt; that we handled with the call to &lt;code&gt;unwrap&lt;/code&gt;. The &lt;code&gt;MutexGuard&lt;/code&gt; smart pointer implements &lt;code&gt;Deref&lt;/code&gt; to point at our inner data; the smart pointer also has a &lt;code&gt;Drop&lt;/code&gt; implementation that releases the lock automatically when a &lt;code&gt;MutexGuard&lt;/code&gt; goes out of scope, which happens at the end of the inner scope in Listing 16-12. As a result, we don&amp;rsquo;t risk forgetting to release the lock and blocking the mutex from being used by other threads because the lock release happens automatically.</source>
          <target state="translated">Как вы могли догадаться, &lt;code&gt;Mutex&amp;lt;T&amp;gt;&lt;/code&gt; - умный указатель. Точнее, вызов &lt;code&gt;lock&lt;/code&gt; &lt;em&gt;возвращает&lt;/em&gt; интеллектуальный указатель с именем &lt;code&gt;MutexGuard&lt;/code&gt; , заключенный в &lt;code&gt;LockResult&lt;/code&gt; , который мы обработали с помощью вызова &lt;code&gt;unwrap&lt;/code&gt; . В &lt;code&gt;MutexGuard&lt;/code&gt; умный указатель реализует &lt;code&gt;Deref&lt;/code&gt; к точке нашей внутренней информации; интеллектуальный указатель также имеет реализацию &lt;code&gt;Drop&lt;/code&gt; , которая автоматически снимает блокировку, когда &lt;code&gt;MutexGuard&lt;/code&gt; выходит за пределы области видимости, что происходит в конце внутренней области в Листинге 16-12. В результате мы не рискуем забыть снять блокировку и заблокировать мьютекс от использования другими потоками, потому что снятие блокировки происходит автоматически.</target>
        </trans-unit>
        <trans-unit id="e4e495363e711b35cf1aef444d4c023b03ec561b" translate="yes" xml:space="preserve">
          <source>As you saw in Chapter 1, &lt;code&gt;cargo new&lt;/code&gt; generates a &amp;ldquo;Hello, world!&amp;rdquo; program for you. Check out the &lt;em&gt;src/main.rs&lt;/em&gt; file:</source>
          <target state="translated">Как вы видели в главе 1, &lt;code&gt;cargo new&lt;/code&gt; порождает &amp;laquo;Hello, world!&amp;raquo; программа для вас. Посмотрите файл &lt;em&gt;src / main.rs&lt;/em&gt; :</target>
        </trans-unit>
        <trans-unit id="acce671b7472bf5e5eaabe31a3ccfe6aca667c9d" translate="yes" xml:space="preserve">
          <source>As you saw in Chapter 1, the &lt;code&gt;main&lt;/code&gt; function is the entry point into the program:</source>
          <target state="translated">Как вы видели в главе 1, &lt;code&gt;main&lt;/code&gt; функция - это точка входа в программу:</target>
        </trans-unit>
        <trans-unit id="1b995f5c38439d41d9506c07ed8d2188c4fc0f99" translate="yes" xml:space="preserve">
          <source>As you saw in Chapter 6, you can match patterns against literals directly. The following code gives some examples:</source>
          <target state="translated">Как вы видели в Главе 6,вы можете напрямую сопоставлять шаблоны с буквами.Следующий код дает несколько примеров:</target>
        </trans-unit>
        <trans-unit id="fa0b472a10784179b99aa6fee609e3cfddb9cc55" translate="yes" xml:space="preserve">
          <source>As you saw in Listing 17-15, we can write methods that use the syntax &lt;code&gt;self: Box&amp;lt;Self&amp;gt;&lt;/code&gt;, which allows the method to take ownership of a &lt;code&gt;Self&lt;/code&gt; value stored in a &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt;. That&amp;rsquo;s exactly what we want to do here, but unfortunately Rust won&amp;rsquo;t let us: the part of Rust that implements behavior when a closure is called isn&amp;rsquo;t implemented using &lt;code&gt;self: Box&amp;lt;Self&amp;gt;&lt;/code&gt;. So Rust doesn&amp;rsquo;t yet understand that it could use &lt;code&gt;self: Box&amp;lt;Self&amp;gt;&lt;/code&gt; in this situation to take ownership of the closure and move the closure out of the &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">Как вы видели в листинге 17-15, мы можем писать методы, использующие синтаксис &lt;code&gt;self: Box&amp;lt;Self&amp;gt;&lt;/code&gt; , который позволяет методу стать владельцем значения &lt;code&gt;Self&lt;/code&gt; , хранящегося в &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; . Это именно то, что мы хотим здесь сделать, но, к сожалению, Rust не позволяет нам: часть Rust, которая реализует поведение при вызове замыкания, не реализована с использованием &lt;code&gt;self: Box&amp;lt;Self&amp;gt;&lt;/code&gt; . Таким образом, Rust еще не понимает, что он может использовать &lt;code&gt;self: Box&amp;lt;Self&amp;gt;&lt;/code&gt; в этой ситуации, чтобы взять на себя закрытие и переместить закрытие из &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5d8ebbcc7fc2cf4e602d0e1985852befad2da85e" translate="yes" xml:space="preserve">
          <source>As you saw in the guessing game tutorial in the &lt;a href=&quot;ch02-00-guessing-game-tutorial#comparing-the-guess-to-the-secret-number&quot;&gt;&amp;ldquo;Comparing the Guess to the Secret Number&amp;rdquo;&lt;/a&gt; section in Chapter 2, you can declare a new variable with the same name as a previous variable, and the new variable shadows the previous variable. Rustaceans say that the first variable is &lt;em&gt;shadowed&lt;/em&gt; by the second, which means that the second variable&amp;rsquo;s value is what appears when the variable is used. We can shadow a variable by using the same variable&amp;rsquo;s name and repeating the use of the &lt;code&gt;let&lt;/code&gt; keyword as follows:</source>
          <target state="translated">Как вы видели в руководстве по игре в угадывание в разделе &lt;a href=&quot;ch02-00-guessing-game-tutorial#comparing-the-guess-to-the-secret-number&quot;&gt;&amp;laquo;Сравнение догадки с секретным числом&amp;raquo;&lt;/a&gt; в главе 2, вы можете объявить новую переменную с тем же именем, что и предыдущая переменная, и новая переменная затеняет предыдущую переменную. Rustaceans сказать , что первая переменная &lt;em&gt;слежку&lt;/em&gt; в секунду, что означает , что значение второй переменной является то , что появляется , когда используется переменная. Мы можем затенять переменную, используя то же имя переменной и повторяя использование ключевого слова &lt;code&gt;let&lt;/code&gt; следующим образом:</target>
        </trans-unit>
        <trans-unit id="c47b398566173be1e06632198f7039025f10ae00" translate="yes" xml:space="preserve">
          <source>As you write large programs, organizing your code will be important because keeping track of your entire program in your head will become impossible. By grouping related functionality and separating code with distinct features, you&amp;rsquo;ll clarify where to find code that implements a particular feature and where to go to change how a feature works.</source>
          <target state="translated">Когда вы пишете большие программы, организация вашего кода будет иметь большое значение, потому что отслеживать всю вашу программу в голове станет невозможно. Сгруппировав связанные функции и разделив код на отдельные функции, вы проясните, где найти код, реализующий конкретную функцию, и куда перейти, чтобы изменить способ работы функции.</target>
        </trans-unit>
        <trans-unit id="a48835105e35976d30850d6478e3e8cb37ac0bc5" translate="yes" xml:space="preserve">
          <source>As your project grows, consider using a workspace: it&amp;rsquo;s easier to understand smaller, individual components than one big blob of code. Furthermore, keeping the crates in a workspace can make coordination between them easier if they are often changed at the same time.</source>
          <target state="translated">По мере роста вашего проекта подумайте об использовании рабочей области: легче понять небольшие отдельные компоненты, чем один большой кусок кода. Кроме того, размещение ящиков в рабочем пространстве может облегчить координацию между ними, если они часто меняются одновременно.</target>
        </trans-unit>
        <trans-unit id="db2e27ecee3ef7df382d73da5185cf2c81a313eb" translate="yes" xml:space="preserve">
          <source>AsMut</source>
          <target state="translated">AsMut</target>
        </trans-unit>
        <trans-unit id="9dee5144fa49d1023659054cfeb7b935d110f729" translate="yes" xml:space="preserve">
          <source>AsMut::as_mut</source>
          <target state="translated">AsMut::as_mut</target>
        </trans-unit>
        <trans-unit id="fa6cbff29c8fee2a75af18139d6ec5d8bb30e951" translate="yes" xml:space="preserve">
          <source>AsRawFd</source>
          <target state="translated">AsRawFd</target>
        </trans-unit>
        <trans-unit id="bf4b7b3bd11f76d54ac78e508bf69a1df97a73ab" translate="yes" xml:space="preserve">
          <source>AsRawHandle</source>
          <target state="translated">AsRawHandle</target>
        </trans-unit>
        <trans-unit id="bcb7263b347977861cfead462a0183ddbacb93a0" translate="yes" xml:space="preserve">
          <source>AsRawSocket</source>
          <target state="translated">AsRawSocket</target>
        </trans-unit>
        <trans-unit id="ecb4ad32c0bbcb0030bdba05dd0126fda307a2ef" translate="yes" xml:space="preserve">
          <source>AsRef</source>
          <target state="translated">AsRef</target>
        </trans-unit>
        <trans-unit id="ce713a708d26f349ef9d3da2c64c32c52ede1f28" translate="yes" xml:space="preserve">
          <source>AsRef::as_ref</source>
          <target state="translated">AsRef::as_ref</target>
        </trans-unit>
        <trans-unit id="a4ef661b82f652f581223b25a6824dec40ae544d" translate="yes" xml:space="preserve">
          <source>AsciiExt</source>
          <target state="translated">AsciiExt</target>
        </trans-unit>
        <trans-unit id="46e0dda46ad92722f1539fd012c3778f39c3b187" translate="yes" xml:space="preserve">
          <source>AsciiExt::eq_ignore_ascii_case</source>
          <target state="translated">AsciiExt::eq_ignore_ascii_case</target>
        </trans-unit>
        <trans-unit id="afaf433bc6efc0517fc1bdeb6f7c5eafce3e74d4" translate="yes" xml:space="preserve">
          <source>AsciiExt::is_ascii</source>
          <target state="translated">AsciiExt::is_ascii</target>
        </trans-unit>
        <trans-unit id="a117348e90cbeb6580ea282ea76b737d649c0ce2" translate="yes" xml:space="preserve">
          <source>AsciiExt::make_ascii_lowercase</source>
          <target state="translated">AsciiExt::make_ascii_lowercase</target>
        </trans-unit>
        <trans-unit id="014f8e9aa886e527dbae3bd8a29a0232814779eb" translate="yes" xml:space="preserve">
          <source>AsciiExt::make_ascii_uppercase</source>
          <target state="translated">AsciiExt::make_ascii_uppercase</target>
        </trans-unit>
        <trans-unit id="ac47518e69af0774bb76855d1ba4fd45ba076dbb" translate="yes" xml:space="preserve">
          <source>AsciiExt::to_ascii_lowercase</source>
          <target state="translated">AsciiExt::to_ascii_lowercase</target>
        </trans-unit>
        <trans-unit id="e04741744413a75fb42c855cb8f9068dc93b7a29" translate="yes" xml:space="preserve">
          <source>AsciiExt::to_ascii_uppercase</source>
          <target state="translated">AsciiExt::to_ascii_uppercase</target>
        </trans-unit>
        <trans-unit id="1b3c2291de90fba8268fb52f3659391950c3a127" translate="yes" xml:space="preserve">
          <source>Aside from the closing curly bracket, there&amp;rsquo;s only one more line to discuss in the code added so far, which is the following:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f99c599e0e3924b919cda05ade321af8f7909739" translate="yes" xml:space="preserve">
          <source>Aside from the closing curly brackets, there&amp;rsquo;s only one more line to discuss in the code added so far, which is the following:</source>
          <target state="translated">Помимо закрывающих фигурных скобок, в добавленном коде есть еще одна строка, которую нужно обсудить, а именно:</target>
        </trans-unit>
        <trans-unit id="ccfa1ea33000ed1fdc5e32d6d85a1f23b351c53c" translate="yes" xml:space="preserve">
          <source>Asked how long the string is, you might say 12. However, Rust&amp;rsquo;s answer is 24: that&amp;rsquo;s the number of bytes it takes to encode &amp;ldquo;Здравствуйте&amp;rdquo; in UTF-8, because each Unicode scalar value in that string takes 2 bytes of storage. Therefore, an index into the string&amp;rsquo;s bytes will not always correlate to a valid Unicode scalar value. To demonstrate, consider this invalid Rust code:</source>
          <target state="translated">На вопрос о длине строки можно ответить 12. Однако ответ Rust равен 24: это количество байтов, которое требуется для кодирования &amp;laquo;Здравствуйте&amp;raquo; в UTF-8, потому что каждое скалярное значение Unicode в этой строке занимает 2 байта памяти. Следовательно, индекс в байтах строки не всегда будет соответствовать допустимому скалярному значению Unicode. Чтобы продемонстрировать это, рассмотрим этот недопустимый код Rust:</target>
        </trans-unit>
        <trans-unit id="e7689cb162bee3d282a7b39ef7b90263d73428fa" translate="yes" xml:space="preserve">
          <source>Assert the results are what you expect.</source>
          <target state="translated">Утверждайте,что результаты-это то,чего вы ожидаете.</target>
        </trans-unit>
        <trans-unit id="14ec22b40bdfb6faadf461156fa13c1003c498f7" translate="yes" xml:space="preserve">
          <source>AssertUnwindSafe</source>
          <target state="translated">AssertUnwindSafe</target>
        </trans-unit>
        <trans-unit id="b22e5cc4bce8496592970be5b25d370d67581697" translate="yes" xml:space="preserve">
          <source>AssertUnwindSafe::borrow</source>
          <target state="translated">AssertUnwindSafe::borrow</target>
        </trans-unit>
        <trans-unit id="e9b2629172195580950a107f4837fef269c6587e" translate="yes" xml:space="preserve">
          <source>AssertUnwindSafe::borrow_mut</source>
          <target state="translated">AssertUnwindSafe::borrow_mut</target>
        </trans-unit>
        <trans-unit id="65951f8f36689c68821ae0439274d4a0186d7055" translate="yes" xml:space="preserve">
          <source>AssertUnwindSafe::call_once</source>
          <target state="translated">AssertUnwindSafe::call_once</target>
        </trans-unit>
        <trans-unit id="846bd763b3f520ae6051ff0597c886f310c2c6ea" translate="yes" xml:space="preserve">
          <source>AssertUnwindSafe::deref</source>
          <target state="translated">AssertUnwindSafe::deref</target>
        </trans-unit>
        <trans-unit id="0f7f2436811897e328934158a966a543668732f9" translate="yes" xml:space="preserve">
          <source>AssertUnwindSafe::deref_mut</source>
          <target state="translated">AssertUnwindSafe::deref_mut</target>
        </trans-unit>
        <trans-unit id="df50057fe584f587876a9e064fa1ae0b0acfbda2" translate="yes" xml:space="preserve">
          <source>AssertUnwindSafe::fmt</source>
          <target state="translated">AssertUnwindSafe::fmt</target>
        </trans-unit>
        <trans-unit id="d34a0fd3c126015a7f7ea1d7a1780f16da8c0c7f" translate="yes" xml:space="preserve">
          <source>AssertUnwindSafe::from</source>
          <target state="translated">AssertUnwindSafe::from</target>
        </trans-unit>
        <trans-unit id="bc1f4df4473c05cd44c2d50adf3e2f9062513d4c" translate="yes" xml:space="preserve">
          <source>AssertUnwindSafe::into</source>
          <target state="translated">AssertUnwindSafe::into</target>
        </trans-unit>
        <trans-unit id="3b850d0a322410d738f80adc8cf728ee8170ee1d" translate="yes" xml:space="preserve">
          <source>AssertUnwindSafe::poll</source>
          <target state="translated">AssertUnwindSafe::poll</target>
        </trans-unit>
        <trans-unit id="daed5606c5d5daf7eeeb4806493948f969bf4f99" translate="yes" xml:space="preserve">
          <source>AssertUnwindSafe::try_from</source>
          <target state="translated">AssertUnwindSafe::try_from</target>
        </trans-unit>
        <trans-unit id="eb82a427dc920b4169ca7e00269601d2ac319ce2" translate="yes" xml:space="preserve">
          <source>AssertUnwindSafe::try_into</source>
          <target state="translated">AssertUnwindSafe::try_into</target>
        </trans-unit>
        <trans-unit id="9f7d994301cc07488a1ff2b7d4c3da5dab748286" translate="yes" xml:space="preserve">
          <source>AssertUnwindSafe::type_id</source>
          <target state="translated">AssertUnwindSafe::type_id</target>
        </trans-unit>
        <trans-unit id="caf84242142f24165f73b39c5c6b3d3bc20e5c26" translate="yes" xml:space="preserve">
          <source>Assertions are always checked in both debug and release builds, and cannot be disabled. See &lt;a href=&quot;macro.debug_assert&quot;&gt;&lt;code&gt;debug_assert!&lt;/code&gt;&lt;/a&gt; for assertions that are not enabled in release builds by default.</source>
          <target state="translated">Утверждения всегда проверяются как в отладочной, так и в выпускной сборках и не могут быть отключены. См. &lt;a href=&quot;macro.debug_assert&quot;&gt; &lt;code&gt;debug_assert!&lt;/code&gt; &lt;/a&gt;для утверждений, которые по умолчанию не включены в сборках выпуска.</target>
        </trans-unit>
        <trans-unit id="e17cdfab7869a902dcf07cf1a4cdf602ea080d95" translate="yes" xml:space="preserve">
          <source>Asserts that a boolean expression is &lt;code&gt;true&lt;/code&gt; at runtime.</source>
          <target state="translated">Утверждает, что логическое выражение &lt;code&gt;true&lt;/code&gt; во время выполнения.</target>
        </trans-unit>
        <trans-unit id="2cab5457990719d367e9e18b69d1f9cf567a9ba6" translate="yes" xml:space="preserve">
          <source>Asserts that two expressions are equal to each other (using &lt;a href=&quot;cmp/trait.partialeq&quot;&gt;&lt;code&gt;PartialEq&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">Утверждает, что два выражения равны друг другу (с использованием &lt;a href=&quot;cmp/trait.partialeq&quot;&gt; &lt;code&gt;PartialEq&lt;/code&gt; &lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="ebf68c5dd99f7adc415f813d7cd9a9965b251c70" translate="yes" xml:space="preserve">
          <source>Asserts that two expressions are equal to each other.</source>
          <target state="translated">Утверждает,что два выражения равны друг другу.</target>
        </trans-unit>
        <trans-unit id="c856365534a0e73e93b9d798530cb553f48e1b9c" translate="yes" xml:space="preserve">
          <source>Asserts that two expressions are not equal to each other (using &lt;a href=&quot;cmp/trait.partialeq&quot;&gt;&lt;code&gt;PartialEq&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">Утверждает, что два выражения не равны друг другу (с использованием &lt;a href=&quot;cmp/trait.partialeq&quot;&gt; &lt;code&gt;PartialEq&lt;/code&gt; &lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="4b3283be054a95811542a229062df29f52cd4b0a" translate="yes" xml:space="preserve">
          <source>Asserts that two expressions are not equal to each other.</source>
          <target state="translated">Утверждает,что два выражения не равны друг другу.</target>
        </trans-unit>
        <trans-unit id="6a70c6eb716321451f69851e0a0b3e6de46cfe0a" translate="yes" xml:space="preserve">
          <source>Assignment expressions</source>
          <target state="translated">Выражения назначения</target>
        </trans-unit>
        <trans-unit id="db7b4a247e0cd4b439f9a236f4dd17ca687d0c37" translate="yes" xml:space="preserve">
          <source>Assignment of &lt;code&gt;A + B&lt;/code&gt; to &lt;code&gt;A&lt;/code&gt; might be removed, since the sum can be stored in a temporary location until it gets printed, with the global variable never getting updated.</source>
          <target state="translated">Присвоение &lt;code&gt;A + B&lt;/code&gt; к &lt;code&gt;A&lt;/code&gt; может быть удалено, поскольку сумма может храниться во временном месте до тех пор, пока она не будет напечатана, при этом глобальная переменная никогда не обновляется.</target>
        </trans-unit>
        <trans-unit id="fb5a2f19ac5c2fbe53a27d32c54a5315d8390b9c" translate="yes" xml:space="preserve">
          <source>Assignment/equivalence</source>
          <target state="translated">Assignment/equivalence</target>
        </trans-unit>
        <trans-unit id="1ec71ff0ba20c7a0026ccba467326b673793511e" translate="yes" xml:space="preserve">
          <source>Assignments are not allowed in pattern guards, because matching cannot have side effects. Side effects could alter the matched object or the environment on which the match depends in such a way, that the match would not be exhaustive. For instance, the following would not match any arm if assignments were allowed:</source>
          <target state="translated">Назначение не разрешается в защитных сетях шаблонов,так как совпадение не может иметь побочных эффектов.Побочные эффекты могут изменить соответствующий объект или среду,от которой зависит соответствие,таким образом,что соответствие не будет исчерпывающим.Например,следующее не будет совпадать ни с одной рукой,если назначения разрешены:</target>
        </trans-unit>
        <trans-unit id="681eeaa9b3a793bf0806817da80c3be3c3a0567b" translate="yes" xml:space="preserve">
          <source>Assigns a new value to the memory behind the pinned reference.</source>
          <target state="translated">Присваивает новое значение памяти,находящейся за штырьковой опорной точкой.</target>
        </trans-unit>
        <trans-unit id="b443e8292f53b80a70f9ceabc76037bb4e254686" translate="yes" xml:space="preserve">
          <source>Associated Constants</source>
          <target state="translated">Связанные константы</target>
        </trans-unit>
        <trans-unit id="aea3ba1170590168c2a8d38c0934f41a1081bd96" translate="yes" xml:space="preserve">
          <source>Associated Constants Examples</source>
          <target state="translated">Связанные константы Примеры</target>
        </trans-unit>
        <trans-unit id="eb724e00631164f5e2c7a1805aa66c501706a7b7" translate="yes" xml:space="preserve">
          <source>Associated Functions</source>
          <target state="translated">Связанные функции</target>
        </trans-unit>
        <trans-unit id="b9d6b786d3dce88371ca3fec1b3f0f5dcc494947" translate="yes" xml:space="preserve">
          <source>Associated Items</source>
          <target state="translated">Сопутствующие предметы</target>
        </trans-unit>
        <trans-unit id="26904b659cb34afa59632d8007e5d7c3c1f7672c" translate="yes" xml:space="preserve">
          <source>Associated Types</source>
          <target state="translated">Связанные типы</target>
        </trans-unit>
        <trans-unit id="d854ee9b0fbbb41a1a8293a522b3a7fd759f3935" translate="yes" xml:space="preserve">
          <source>Associated Types Container Example</source>
          <target state="translated">Пример контейнера ассоциированных типов</target>
        </trans-unit>
        <trans-unit id="6176d44495c67b15b26948f8a03f37c611fcd9c1" translate="yes" xml:space="preserve">
          <source>Associated constants, functions, and types</source>
          <target state="translated">Соответствующие константы,функции и типы</target>
        </trans-unit>
        <trans-unit id="bf8fe32d8bff33aaf1adf4d6ce640603da967659" translate="yes" xml:space="preserve">
          <source>Associated functions and methods</source>
          <target state="translated">Связанные функции и методы</target>
        </trans-unit>
        <trans-unit id="ca7658fbd81144f975e114c63e67d2067128142d" translate="yes" xml:space="preserve">
          <source>Associated functions are often used for constructors that will return a new instance of the struct. For example, we could provide an associated function that would have one dimension parameter and use that as both width and height, thus making it easier to create a square &lt;code&gt;Rectangle&lt;/code&gt; rather than having to specify the same value twice:</source>
          <target state="translated">Связанные функции часто используются для конструкторов, которые возвращают новый экземпляр структуры. Например, мы могли бы предоставить связанную функцию, у которой был бы один параметр измерения, и использовать его как ширину и высоту, тем самым упростив создание квадратного &lt;code&gt;Rectangle&lt;/code&gt; вместо того, чтобы указывать одно и то же значение дважды:</target>
        </trans-unit>
        <trans-unit id="1d8027bfb0422adf6fa755c7366da969f12a3f99" translate="yes" xml:space="preserve">
          <source>Associated functions whose first parameter is named &lt;code&gt;self&lt;/code&gt; are called &lt;em&gt;methods&lt;/em&gt; and may be invoked using the &lt;a href=&quot;../expressions/method-call-expr&quot;&gt;method call operator&lt;/a&gt;, for example, &lt;code&gt;x.foo()&lt;/code&gt;, as well as the usual function call notation.</source>
          <target state="translated">Связанные функции, первый параметр которых называется &lt;code&gt;self&lt;/code&gt; , называются &lt;em&gt;методами&lt;/em&gt; и могут быть вызваны с помощью &lt;a href=&quot;../expressions/method-call-expr&quot;&gt;оператора вызова метода&lt;/a&gt; , например &lt;code&gt;x.foo()&lt;/code&gt; , а также с помощью обычной нотации вызова функций.</target>
        </trans-unit>
        <trans-unit id="50f4dee25317e303fd0eeee4d556e246ef57db0b" translate="yes" xml:space="preserve">
          <source>Associated item</source>
          <target state="translated">Соответствующий пункт</target>
        </trans-unit>
        <trans-unit id="4627f0f1df7ed7ad7efce2d0583317bf3d8df511" translate="yes" xml:space="preserve">
          <source>Associated item for a type that cannot be directly named (e.g., &lt;code&gt;&amp;lt;&amp;amp;T&amp;gt;::...&lt;/code&gt;, &lt;code&gt;&amp;lt;[T]&amp;gt;::...&lt;/code&gt;, etc.)</source>
          <target state="translated">Связанный элемент для типа, который не может быть назван напрямую (например, &lt;code&gt;&amp;lt;&amp;amp;T&amp;gt;::...&lt;/code&gt; , &lt;code&gt;&amp;lt;[T]&amp;gt;::...&lt;/code&gt; и т. Д.)</target>
        </trans-unit>
        <trans-unit id="f0dda5ab7ff2aba410ad872aa8c289173200dd02" translate="yes" xml:space="preserve">
          <source>Associated items are useful when the associated item logically is related to the associating item. For example, the &lt;code&gt;is_some&lt;/code&gt; method on &lt;code&gt;Option&lt;/code&gt; is intrinsically related to Options, so should be associated.</source>
          <target state="translated">Связанные элементы полезны, когда связанный элемент логически связан с ассоциированным элементом. Например, метод &lt;code&gt;is_some&lt;/code&gt; в &lt;code&gt;Option&lt;/code&gt; внутренне связан с Options, поэтому должен быть связан.</target>
        </trans-unit>
        <trans-unit id="13ba4a748e2d8dab765ce941e0df6910e63030e1" translate="yes" xml:space="preserve">
          <source>Associated searcher for this pattern</source>
          <target state="translated">Ассоциированный искатель для этого шаблона</target>
        </trans-unit>
        <trans-unit id="ce35cedae86fe81ca2cf2bcb725660816d309811" translate="yes" xml:space="preserve">
          <source>Associated type for &lt;code&gt;&amp;lt;&amp;amp;[char] as Pattern&amp;lt;'a&amp;gt;&amp;gt;::Searcher&lt;/code&gt;.</source>
          <target state="translated">Связанный тип для &lt;code&gt;&amp;lt;&amp;amp;[char] as Pattern&amp;lt;'a&amp;gt;&amp;gt;::Searcher&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e195d76e814dc3f6b09416fe019701da4141e61f" translate="yes" xml:space="preserve">
          <source>Associated type for &lt;code&gt;&amp;lt;&amp;amp;str as Pattern&amp;lt;'a&amp;gt;&amp;gt;::Searcher&lt;/code&gt;.</source>
          <target state="translated">Связанный тип для &lt;code&gt;&amp;lt;&amp;amp;str as Pattern&amp;lt;'a&amp;gt;&amp;gt;::Searcher&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="da9f3600b580da18821fb0932aa55c1e82dc8484" translate="yes" xml:space="preserve">
          <source>Associated type for &lt;code&gt;&amp;lt;F as Pattern&amp;lt;'a&amp;gt;&amp;gt;::Searcher&lt;/code&gt;.</source>
          <target state="translated">Связанный тип для &lt;code&gt;&amp;lt;F as Pattern&amp;lt;'a&amp;gt;&amp;gt;::Searcher&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="470b87bc44e9aa3c27db7ff27c851ded51a493f4" translate="yes" xml:space="preserve">
          <source>Associated type for &lt;code&gt;&amp;lt;char as Pattern&amp;lt;'a&amp;gt;&amp;gt;::Searcher&lt;/code&gt;.</source>
          <target state="translated">Связанный тип для &lt;code&gt;&amp;lt;char as Pattern&amp;lt;'a&amp;gt;&amp;gt;::Searcher&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4b2aeb71be1e33f6aef873e1957563d04f8d17e0" translate="yes" xml:space="preserve">
          <source>Associated types from &lt;code&gt;Trait&lt;/code&gt; can be used.</source>
          <target state="translated">Можно использовать связанные типы из &lt;code&gt;Trait&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b94fe8e8235a5eac0ea7986a3bc24833e5f55164" translate="yes" xml:space="preserve">
          <source>Associated types might seem like a similar concept to generics, in that the latter allow us to define a function without specifying what types it can handle. So why use associated types?</source>
          <target state="translated">Ассоциированные типы могут показаться похожими на дженерики,в том смысле,что последние позволяют определить функцию,не указывая,с какими типами она может работать.Так зачем же использовать ассоциированные типы?</target>
        </trans-unit>
        <trans-unit id="d20b5a26a1cdf631954b50a5206246dff93d9c8a" translate="yes" xml:space="preserve">
          <source>Associativity</source>
          <target state="translated">Associativity</target>
        </trans-unit>
        <trans-unit id="434de15a9f2e5951652f37ae43c858535ba0b678" translate="yes" xml:space="preserve">
          <source>Assume there are two files in the same directory with the following contents:</source>
          <target state="translated">Предположим,что в одной директории находятся два файла со следующим содержимым:</target>
        </trans-unit>
        <trans-unit id="9c07290f30084dee9d612cccf40372822beeda08" translate="yes" xml:space="preserve">
          <source>Assumes that the slice is sorted by the key, for instance with &lt;a href=&quot;#method.sort_by_key&quot;&gt;&lt;code&gt;sort_by_key&lt;/code&gt;&lt;/a&gt; using the same key extraction function.</source>
          <target state="translated">Предполагает, что срез сортируется по ключу, например, с помощью &lt;a href=&quot;#method.sort_by_key&quot;&gt; &lt;code&gt;sort_by_key&lt;/code&gt; &lt;/a&gt; с использованием той же функции извлечения ключа.</target>
        </trans-unit>
        <trans-unit id="7da83b920d859bea1ef24ff98129cc3f739b791b" translate="yes" xml:space="preserve">
          <source>Assuming all the elements are initialized, get a mutable slice to them.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0d70f82d569a6dc638a5854fc3e366cb50b91e26" translate="yes" xml:space="preserve">
          <source>Assuming all the elements are initialized, get a slice to them.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c924c9518b3ab961e095e1c3fb8fc583399ec253" translate="yes" xml:space="preserve">
          <source>Assuming there&amp;rsquo;s a file named &lt;code&gt;foo.txt&lt;/code&gt; with contents &lt;code&gt;abcdef\n&lt;/code&gt;, create two handles, seek one of them, and read the remaining bytes from the other handle:</source>
          <target state="translated">Предполагая, что существует файл с именем &lt;code&gt;foo.txt&lt;/code&gt; с содержимым &lt;code&gt;abcdef\n&lt;/code&gt; , создайте два дескриптора, найдите один из них и прочтите оставшиеся байты из другого дескриптора:</target>
        </trans-unit>
        <trans-unit id="31936e0a0d8572ee4060f19296edebc34a7f6f8c" translate="yes" xml:space="preserve">
          <source>Asterisk glob imports will import items imported with &lt;code&gt;_&lt;/code&gt; in their unnameable form.</source>
          <target state="translated">Импорт глобуса Asterisk будет импортировать элементы, импортированные с &lt;code&gt;_&lt;/code&gt; в их безымянной форме.</target>
        </trans-unit>
        <trans-unit id="940e0ca02bfde86559dac73ad0f3397300f703e1" translate="yes" xml:space="preserve">
          <source>Async blocks act like a function boundary, much like closures. Therefore, the &lt;code&gt;?&lt;/code&gt; operator and &lt;code&gt;return&lt;/code&gt; expressions both affect the output of the future, not the enclosing function or other context. That is, &lt;code&gt;return &amp;lt;expr&amp;gt;&lt;/code&gt; from within a closure will return the result of &lt;code&gt;&amp;lt;expr&amp;gt;&lt;/code&gt; as the output of the future. Similarly, if &lt;code&gt;&amp;lt;expr&amp;gt;?&lt;/code&gt; propagates an error, that error is propagated as the result of the future.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="214d7973c7382a6a34b11e3f97cf5442c859fb3e" translate="yes" xml:space="preserve">
          <source>Async blocks capture variables from their environment using the same &lt;a href=&quot;../types/closure#capture-modes&quot;&gt;capture modes&lt;/a&gt; as closures. Like closures, when written &lt;code&gt;async { .. }&lt;/code&gt; the capture mode for each variable will be inferred from the content of the block. &lt;code&gt;async move { .. }&lt;/code&gt; blocks however will move all referenced variables into the resulting future.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="57f9a16fc928066d87c71b1e0690e9ad26edea0a" translate="yes" xml:space="preserve">
          <source>Async context</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5ef2ec7c086db048016785067a80b5c302021dc3" translate="yes" xml:space="preserve">
          <source>Async functions</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="99471e2fa36e20e9d7193c5529dfbf6f52a711a2" translate="yes" xml:space="preserve">
          <source>Async functions do no work when called: instead, they capture their arguments into a future. When polled, that future will execute the function's body.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c318095156a540e68b8cc7d9ad9ab72fce83a154" translate="yes" xml:space="preserve">
          <source>Asynchronous values.</source>
          <target state="translated">Асинхронные значения.</target>
        </trans-unit>
        <trans-unit id="0855009c46728a5c8cb9aa53860e3b38d932c17a" translate="yes" xml:space="preserve">
          <source>At</source>
          <target state="translated">At</target>
        </trans-unit>
        <trans-unit id="6aa8b3387e6ffd75791adbf0065888a4924635f2" translate="yes" xml:space="preserve">
          <source>At a high level, a &lt;a href=&quot;struct.pin&quot;&gt;&lt;code&gt;Pin&amp;lt;P&amp;gt;&lt;/code&gt;&lt;/a&gt; ensures that the pointee of any pointer type &lt;code&gt;P&lt;/code&gt; has a stable location in memory, meaning it cannot be moved elsewhere and its memory cannot be deallocated until it gets dropped. We say that the pointee is &quot;pinned&quot;. Things get more subtle when discussing types that combine pinned with non-pinned data; &lt;a href=&quot;#projections-and-structural-pinning&quot;&gt;see below&lt;/a&gt; for more details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d9cacf1832e8829a2c65089757588eeeacfc9330" translate="yes" xml:space="preserve">
          <source>At all times, you must avoid data races. If multiple threads have access to the same &lt;code&gt;UnsafeCell&lt;/code&gt;, then any writes must have a proper happens-before relation to all other accesses (or use atomics).</source>
          <target state="translated">Всегда следует избегать гонок за данными. Если несколько потоков имеют доступ к одной и той же &lt;code&gt;UnsafeCell&lt;/code&gt; , тогда любая запись должна иметь правильное отношение &amp;laquo;произошло до&amp;raquo; ко всем другим доступам (или использовать атомику).</target>
        </trans-unit>
        <trans-unit id="c68169e0fac1472856a75bc093cd4e904a65d3b5" translate="yes" xml:space="preserve">
          <source>At any given time, you can have &lt;em&gt;either&lt;/em&gt; (but not both of) one mutable reference or any number of immutable references.</source>
          <target state="translated">В любой момент времени у вас может быть &lt;em&gt;одна&lt;/em&gt; (но не обе) одна изменяемая ссылка или любое количество неизменяемых ссылок.</target>
        </trans-unit>
        <trans-unit id="97c27bc0fbd95b57400fcf731e3e7a7d89c5cf2f" translate="yes" xml:space="preserve">
          <source>At any given time, you can have &lt;em&gt;either&lt;/em&gt; one mutable reference &lt;em&gt;or&lt;/em&gt; any number of immutable references.</source>
          <target state="translated">В любой момент времени вы можете иметь &lt;em&gt;либо&lt;/em&gt; одну изменяемую ссылку, &lt;em&gt;либо&lt;/em&gt; любое количество неизменяемых ссылок.</target>
        </trans-unit>
        <trans-unit id="b790d9edc1873ab13071956060a912cd284deda5" translate="yes" xml:space="preserve">
          <source>At compile time each implementation of &lt;code&gt;Trait&lt;/code&gt; will produce a table containing the various methods (and other items) related to the implementation.</source>
          <target state="translated">Во время компиляции каждая реализация &lt;code&gt;Trait&lt;/code&gt; будет создавать таблицу, содержащую различные методы (и другие элементы), связанные с реализацией.</target>
        </trans-unit>
        <trans-unit id="26e37b1b35b52ad10610ea1ef12403fe61f658c6" translate="yes" xml:space="preserve">
          <source>At compile time, Rust needs to know how much space a type takes up. One type whose size can&amp;rsquo;t be known at compile time is a &lt;em&gt;recursive type&lt;/em&gt;, where a value can have as part of itself another value of the same type. Because this nesting of values could theoretically continue infinitely, Rust doesn&amp;rsquo;t know how much space a value of a recursive type needs. However, boxes have a known size, so by inserting a box in a recursive type definition, you can have recursive types.</source>
          <target state="translated">Во время компиляции Rust должен знать, сколько места занимает тип. Один тип, размер которого не может быть известен во время компиляции, - это &lt;em&gt;рекурсивный тип&lt;/em&gt; , в котором значение может иметь как часть самого себя другое значение того же типа. Поскольку это вложение значений теоретически может продолжаться бесконечно, Rust не знает, сколько места требуется для значения рекурсивного типа. Однако блоки имеют известный размер, поэтому, вставив блок в определение рекурсивного типа, вы можете получить рекурсивные типы.</target>
        </trans-unit>
        <trans-unit id="b2f9b5afe99b75e0f39f01ec88be93443b074a9d" translate="yes" xml:space="preserve">
          <source>At each point in the program where the reference count changes, we print the reference count, which we can get by calling the &lt;code&gt;Rc::strong_count&lt;/code&gt; function. This function is named &lt;code&gt;strong_count&lt;/code&gt; rather than &lt;code&gt;count&lt;/code&gt; because the &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; type also has a &lt;code&gt;weak_count&lt;/code&gt;; we&amp;rsquo;ll see what &lt;code&gt;weak_count&lt;/code&gt; is used for in the &lt;a href=&quot;ch15-06-reference-cycles#preventing-reference-cycles-turning-an-rct-into-a-weakt&quot;&gt;&amp;ldquo;Preventing Reference Cycles: Turning an &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; into a &lt;code&gt;Weak&amp;lt;T&amp;gt;&lt;/code&gt;&amp;rdquo;&lt;/a&gt; section.</source>
          <target state="translated">В каждой точке программы, где изменяется счетчик ссылок, мы печатаем счетчик ссылок, который мы можем получить, вызвав функцию &lt;code&gt;Rc::strong_count&lt;/code&gt; . Эта функция называется &lt;code&gt;strong_count&lt;/code&gt; , а не &lt;code&gt;count&lt;/code&gt; , потому что тип &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; также имеет &lt;code&gt;weak_count&lt;/code&gt; ; мы увидим, для чего используется &lt;code&gt;weak_count&lt;/code&gt; , в разделе &lt;a href=&quot;ch15-06-reference-cycles#preventing-reference-cycles-turning-an-rct-into-a-weakt&quot;&gt;&amp;laquo;Предотвращение ссылочных циклов: превращение &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; в &lt;code&gt;Weak&amp;lt;T&amp;gt;&lt;/code&gt; &amp;raquo;&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="f2afe7e487c0f1c732676abe97c30fdb7bfd5600" translate="yes" xml:space="preserve">
          <source>At first, we have no memory allocated at all, but as we append to the string, it increases its capacity appropriately. If we instead use the &lt;a href=&quot;#method.with_capacity&quot;&gt;&lt;code&gt;with_capacity&lt;/code&gt;&lt;/a&gt; method to allocate the correct capacity initially:</source>
          <target state="translated">Сначала у нас вообще нет выделенной памяти, но когда мы добавляем к строке, она соответственно увеличивает ее емкость. Если вместо этого мы используем метод &lt;a href=&quot;#method.with_capacity&quot;&gt; &lt;code&gt;with_capacity&lt;/code&gt; &lt;/a&gt; для первоначального выделения правильной емкости:</target>
        </trans-unit>
        <trans-unit id="dc05814fc863fd7b76fdcfe7f779c72f9533e270" translate="yes" xml:space="preserve">
          <source>At first, we have no memory allocated at all, but as we append to the string, it increases its capacity appropriately. If we instead use the &lt;a href=&quot;struct.string#method.with_capacity&quot;&gt;&lt;code&gt;with_capacity&lt;/code&gt;&lt;/a&gt; method to allocate the correct capacity initially:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0295e56a89c227419234a744fcdff39f54bbbd31" translate="yes" xml:space="preserve">
          <source>At its simplest, a test in Rust is a function that&amp;rsquo;s annotated with the &lt;code&gt;test&lt;/code&gt; attribute. Attributes are metadata about pieces of Rust code; one example is the &lt;code&gt;derive&lt;/code&gt; attribute we used with structs in Chapter 5. To change a function into a test function, add &lt;code&gt;#[test]&lt;/code&gt; on the line before &lt;code&gt;fn&lt;/code&gt;. When you run your tests with the &lt;code&gt;cargo test&lt;/code&gt; command, Rust builds a test runner binary that runs the functions annotated with the &lt;code&gt;test&lt;/code&gt; attribute and reports on whether each test function passes or fails.</source>
          <target state="translated">В простейшем случае тест в Rust - это функция, помеченная атрибутом &lt;code&gt;test&lt;/code&gt; . Атрибуты - это метаданные о фрагментах кода Rust; Одним из примеров является атрибут &lt;code&gt;derive&lt;/code&gt; ,который мы использовали со структурами в главе 5. Чтобы превратить функцию в тестовую, добавьте &lt;code&gt;#[test]&lt;/code&gt; в строку перед &lt;code&gt;fn&lt;/code&gt; . Когда вы запускаете свои тесты с помощью команды &lt;code&gt;cargo test&lt;/code&gt; , Rust создает двоичный файл средства выполнения тестов, который запускает функции, аннотированные атрибутом &lt;code&gt;test&lt;/code&gt; , и сообщает, прошла ли каждая функция теста успешно или нет.</target>
        </trans-unit>
        <trans-unit id="37583ea386b39553438667ee1326a11884d8ac4d" translate="yes" xml:space="preserve">
          <source>At least one of either &lt;code&gt;Self&lt;/code&gt; or a generic type parameter of the trait must meet the following grammar, where &lt;code&gt;C&lt;/code&gt; is a nominal type defined within the containing crate:</source>
          <target state="translated">По крайней мере, один из параметров типа &lt;code&gt;Self&lt;/code&gt; или универсального типа должен соответствовать следующей грамматике, где &lt;code&gt;C&lt;/code&gt; - номинальный тип, определенный в содержащем контейнере:</target>
        </trans-unit>
        <trans-unit id="6340eab1a988a949757faf0b3ab2c9f1d577f929" translate="yes" xml:space="preserve">
          <source>At least one of the pointers is being used to write to the data.</source>
          <target state="translated">Для записи в данные используется хотя бы один из указателей.</target>
        </trans-unit>
        <trans-unit id="5724aa0694940a76277017d916e0999814aa1912" translate="yes" xml:space="preserve">
          <source>At least one of the types &lt;code&gt;T0..=Tn&lt;/code&gt; must be a &lt;a href=&quot;../glossary#local-type&quot;&gt;local type&lt;/a&gt;. Let &lt;code&gt;Ti&lt;/code&gt; be the first such type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e87e525060c2b4080d7c34755a062916a4109c19" translate="yes" xml:space="preserve">
          <source>At least one of the types &lt;code&gt;T0..=Tn&lt;/code&gt; must be a local type. Let &lt;code&gt;Ti&lt;/code&gt; be the first such type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a139025cd9d3b2fee71807f78a3b49ac15b212ef" translate="yes" xml:space="preserve">
          <source>At present few predefined ABI's (like Rust, C, system, etc.) can be used in Rust. Verify that the ABI is predefined. For example you can replace the given ABI from 'Rust'.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e2c9357843faff292144d5026ce32c57e9298ff6" translate="yes" xml:space="preserve">
          <source>At present, it is not permitted to have a yield that occurs while a borrow is still in scope. To resolve this error, the borrow must either be &quot;contained&quot; to a smaller scope that does not overlap the yield or else eliminated in another way. So, for example, we might resolve the previous example by removing the borrow and just storing the integer by value:</source>
          <target state="translated">В настоящее время не разрешается иметь доходность,которая возникает в то время,когда заем еще не погашен.Чтобы устранить эту ошибку,заём должен либо &quot;содержаться&quot; в меньшем объеме,который не перекрывает доходность,либо быть исключён иным образом.Так,например,мы можем разрешить предыдущий пример,удалив заём и просто сохранив целое число по значению:</target>
        </trans-unit>
        <trans-unit id="c58aa6f87c5fb2f5db7b812c6bc9a21b048e36a1" translate="yes" xml:space="preserve">
          <source>At present, it is not permitted to pass more than one explicit parameter for a generator.This can be fixed by using at most 1 parameter for the generator. For example, we might resolve the previous example by passing only one parameter.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4e36fb08191e884058237321d264d01b5dc6a45f" translate="yes" xml:space="preserve">
          <source>At run-time, when a method needs to be called on the &lt;code&gt;dyn Trait&lt;/code&gt;, the vtable is consulted to get the function pointer and then that function pointer is called.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="acf3e76f07038198aca7a45dd9300fbaa0a3ed8a" translate="yes" xml:space="preserve">
          <source>At runtime this function behaves like &lt;code&gt;self != other&lt;/code&gt;. However, in some contexts (e.g., compile-time evaluation), it is not always possible to determine the inequality of two pointers, so this function may spuriously return &lt;code&gt;false&lt;/code&gt; for pointers that later actually turn out to be unequal. But when it returns &lt;code&gt;true&lt;/code&gt;, the pointers are guaranteed to be unequal.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3ddac349169d1a744bfbed1eee12e4790040330f" translate="yes" xml:space="preserve">
          <source>At runtime this function behaves like &lt;code&gt;self == other&lt;/code&gt;. However, in some contexts (e.g., compile-time evaluation), it is not always possible to determine equality of two pointers, so this function may spuriously return &lt;code&gt;false&lt;/code&gt; for pointers that later actually turn out to be equal. But when it returns &lt;code&gt;true&lt;/code&gt;, the pointers are guaranteed to be equal.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="880cb1d1611d41944fc45c1105942f35a2cea331" translate="yes" xml:space="preserve">
          <source>At the beginning of this chapter, we said that vectors can only store values that are the same type. This can be inconvenient; there are definitely use cases for needing to store a list of items of different types. Fortunately, the variants of an enum are defined under the same enum type, so when we need to store elements of a different type in a vector, we can define and use an enum!</source>
          <target state="translated">В начале этой главы мы говорили,что векторы могут хранить только значения одного типа.Это может быть неудобно;определенно существуют случаи использования для хранения списка элементов разных типов.К счастью,варианты перечисления определяются под одним и тем же типом перечисления,поэтому,когда нам нужно хранить в векторе элементы другого типа,мы можем определить и использовать перечисление!</target>
        </trans-unit>
        <trans-unit id="b0f9f410d4d3f041a8bbac0598dae49519ac5a0f" translate="yes" xml:space="preserve">
          <source>At the moment the &lt;code&gt;if&lt;/code&gt; and &lt;code&gt;else&lt;/code&gt; blocks have a lot of repetition: they&amp;rsquo;re both reading files and writing the contents of the files to the stream. The only differences are the status line and the filename. Let&amp;rsquo;s make the code more concise by pulling out those differences into separate &lt;code&gt;if&lt;/code&gt; and &lt;code&gt;else&lt;/code&gt; lines that will assign the values of the status line and the filename to variables; we can then use those variables unconditionally in the code to read the file and write the response. Listing 20-9 shows the resulting code after replacing the large &lt;code&gt;if&lt;/code&gt; and &lt;code&gt;else&lt;/code&gt; blocks.</source>
          <target state="translated">В настоящий момент блоки &lt;code&gt;if&lt;/code&gt; и &lt;code&gt;else&lt;/code&gt; часто повторяются: они читают файлы и записывают содержимое файлов в поток. Единственные различия - это строка состояния и имя файла. Давайте сделаем код более кратким, выделив эти различия в отдельные строки &lt;code&gt;if&lt;/code&gt; и &lt;code&gt;else&lt;/code&gt; , которые будут назначать значения строки состояния и имени файла переменным; затем мы можем безоговорочно использовать эти переменные в коде для чтения файла и записи ответа. В листинге 20-9 показан код, полученный после замены больших блоков &lt;code&gt;if&lt;/code&gt; и &lt;code&gt;else&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="929c7d4e23e7e49a6c726514ca62a32c23fbe8e1" translate="yes" xml:space="preserve">
          <source>At the moment, &lt;code&gt;if&lt;/code&gt; and &lt;code&gt;match&lt;/code&gt;, as well as the looping constructs &lt;code&gt;for&lt;/code&gt;, &lt;code&gt;while&lt;/code&gt;, and &lt;code&gt;loop&lt;/code&gt;, are forbidden inside a &lt;code&gt;const&lt;/code&gt;, &lt;code&gt;static&lt;/code&gt;, or &lt;code&gt;const fn&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1f16df13b8f4c863b823dc86f56453377891952c" translate="yes" xml:space="preserve">
          <source>At the moment, we&amp;rsquo;re writing all of our output to the terminal using the &lt;code&gt;println!&lt;/code&gt; function. Most terminals provide two kinds of output: &lt;em&gt;standard output&lt;/em&gt; (&lt;code&gt;stdout&lt;/code&gt;) for general information and &lt;em&gt;standard error&lt;/em&gt; (&lt;code&gt;stderr&lt;/code&gt;) for error messages. This distinction enables users to choose to direct the successful output of a program to a file but still print error messages to the screen.</source>
          <target state="translated">На данный момент мы записываем весь наш вывод в терминал, используя &lt;code&gt;println!&lt;/code&gt; функция. Большинство терминалов предоставляют два вида вывода: &lt;em&gt;стандартный вывод&lt;/em&gt; ( &lt;code&gt;stdout&lt;/code&gt; ) для общей информации и &lt;em&gt;стандартный &lt;/em&gt; &lt;code&gt;stderr&lt;/code&gt; &lt;em&gt;ошибок&lt;/em&gt; ( stderr ) для сообщений об ошибках. Это различие позволяет пользователям выбрать направление успешного вывода программы в файл, но при этом выводить сообщения об ошибках на экран.</target>
        </trans-unit>
        <trans-unit id="8d5aa8f95e2e92d8aada8f026371cf7b990b2775" translate="yes" xml:space="preserve">
          <source>At the moment, we&amp;rsquo;re writing all of our output to the terminal using the &lt;code&gt;println!&lt;/code&gt; macro. Most terminals provide two kinds of output: &lt;em&gt;standard output&lt;/em&gt; (&lt;code&gt;stdout&lt;/code&gt;) for general information and &lt;em&gt;standard error&lt;/em&gt; (&lt;code&gt;stderr&lt;/code&gt;) for error messages. This distinction enables users to choose to direct the successful output of a program to a file but still print error messages to the screen.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3818ff95eb637709816bb6cd777c917a43bae444" translate="yes" xml:space="preserve">
          <source>At the time of this writing, an automatic formatter tool called &lt;code&gt;rustfmt&lt;/code&gt; is under development. If you want to stick to a standard style across Rust projects, &lt;code&gt;rustfmt&lt;/code&gt; will format your code in a particular style. The Rust team plans to eventually include this tool with the standard Rust distribution, like &lt;code&gt;rustc&lt;/code&gt;. So depending on when you read this book, it might already be installed on your computer! Check the online documentation for more details.</source>
          <target state="translated">На момент написания этой статьи инструмент автоматического форматирования под названием &lt;code&gt;rustfmt&lt;/code&gt; находится в стадии разработки. Если вы хотите придерживаться стандартного стиля в проектах Rust, &lt;code&gt;rustfmt&lt;/code&gt; отформатирует ваш код в определенном стиле. Команда Rust планирует в конечном итоге включить этот инструмент в стандартный дистрибутив Rust, например, в &lt;code&gt;rustc&lt;/code&gt; . Так что в зависимости от того, когда вы читаете эту книгу, она может быть уже установлена ​​на вашем компьютере! Для получения более подробной информации проверьте онлайн-документацию.</target>
        </trans-unit>
        <trans-unit id="1eca2e64861fbf60436be0df95a81ecf4dd4db51" translate="yes" xml:space="preserve">
          <source>At the time of this writing, two Rust editions are available: Rust 2015 and Rust 2018. This book is written using Rust 2018 edition idioms.</source>
          <target state="translated">На момент написания этой статьи доступны два издания Rust:Ржавчина 2015 и Ржавчина 2018.Эта книга написана с использованием идиоматических названий изданий &quot;Ржавчина 2018&quot;.</target>
        </trans-unit>
        <trans-unit id="d0b83ac2e98214df1ca34576f6616d27aede53ff" translate="yes" xml:space="preserve">
          <source>At the time, we said not to worry about the inefficient &lt;code&gt;clone&lt;/code&gt; calls because we would remove them in the future. Well, that time is now!</source>
          <target state="translated">В то время мы сказали, что не стоит беспокоиться о неэффективных вызовах &lt;code&gt;clone&lt;/code&gt; потому что мы удалим их в будущем. Что ж, время пришло!</target>
        </trans-unit>
        <trans-unit id="bf023d508177d86413d3379134e446a32a09142c" translate="yes" xml:space="preserve">
          <source>At the time, we skipped over some details in this code. In Chapter 6 in &lt;a href=&quot;ch06-02-match#the-match-control-flow-operator&quot;&gt;&amp;ldquo;The &lt;code&gt;match&lt;/code&gt; Control Flow Operator&amp;rdquo;&lt;/a&gt; section, we discussed that &lt;code&gt;match&lt;/code&gt; arms must all return the same type. So, for example, the following code doesn&amp;rsquo;t work:</source>
          <target state="translated">В то время мы пропустили некоторые детали в этом коде. В главе 6 в &lt;a href=&quot;ch06-02-match#the-match-control-flow-operator&quot;&gt;&amp;laquo; &lt;code&gt;match&lt;/code&gt; Оператор Flow Control&amp;raquo;&lt;/a&gt; раздел, мы обсуждали , что &lt;code&gt;match&lt;/code&gt; рука должна все вернуть тот же тип. Так, например, следующий код не работает:</target>
        </trans-unit>
        <trans-unit id="7ade322c88e63df6a4a8c865c0fa8c7d63812d90" translate="yes" xml:space="preserve">
          <source>At this point, &lt;code&gt;cargo build&lt;/code&gt; should complete successfully in both &lt;code&gt;hello_macro&lt;/code&gt; and &lt;code&gt;hello_macro_derive&lt;/code&gt;. Let&amp;rsquo;s hook up these crates to the code in Listing 19-30 to see the procedural macro in action! Create a new binary project in your &lt;em&gt;projects&lt;/em&gt; directory using &lt;code&gt;cargo new pancakes&lt;/code&gt;. We need to add &lt;code&gt;hello_macro&lt;/code&gt; and &lt;code&gt;hello_macro_derive&lt;/code&gt; as dependencies in the &lt;code&gt;pancakes&lt;/code&gt; crate&amp;rsquo;s &lt;em&gt;Cargo.toml&lt;/em&gt;. If you&amp;rsquo;re publishing your versions of &lt;code&gt;hello_macro&lt;/code&gt; and &lt;code&gt;hello_macro_derive&lt;/code&gt; to &lt;a href=&quot;https://crates.io/&quot;&gt;crates.io&lt;/a&gt;, they would be regular dependencies; if not, you can specify them as &lt;code&gt;path&lt;/code&gt; dependencies as follows:</source>
          <target state="translated">На этом этапе &lt;code&gt;cargo build&lt;/code&gt; должна успешно завершиться как в &lt;code&gt;hello_macro&lt;/code&gt; ,так и в &lt;code&gt;hello_macro_derive&lt;/code&gt; . Давайте подключим эти ящики к коду из Листинга 19-30, чтобы увидеть процедурный макрос в действии! Создайте новый бинарный проект в каталоге ваших &lt;em&gt;проектов,&lt;/em&gt; используя &lt;code&gt;cargo new pancakes&lt;/code&gt; . Нам нужно добавить &lt;code&gt;hello_macro&lt;/code&gt; и &lt;code&gt;hello_macro_derive&lt;/code&gt; в качестве зависимостей в &lt;code&gt;pancakes&lt;/code&gt; Crate в &lt;em&gt;Cargo.toml&lt;/em&gt; . Если вы публикуете свои версии &lt;code&gt;hello_macro&lt;/code&gt; и &lt;code&gt;hello_macro_derive&lt;/code&gt; на &lt;a href=&quot;https://crates.io/&quot;&gt;crates.io&lt;/a&gt; , они будут обычными зависимостями; если нет, вы можете указать их как &lt;code&gt;path&lt;/code&gt; следующие зависимости пути :</target>
        </trans-unit>
        <trans-unit id="b945ef4a755c9f52a155f619e7f39f1e0b11da63" translate="yes" xml:space="preserve">
          <source>At this point, &lt;code&gt;s&lt;/code&gt; will be &lt;code&gt;tic-tac-toe&lt;/code&gt;. With all of the &lt;code&gt;+&lt;/code&gt; and &lt;code&gt;&quot;&lt;/code&gt; characters, it&amp;rsquo;s difficult to see what&amp;rsquo;s going on. For more complicated string combining, we can use the &lt;code&gt;format!&lt;/code&gt; macro:</source>
          <target state="translated">На данный момент, &lt;code&gt;s&lt;/code&gt; будет &lt;code&gt;tic-tac-toe&lt;/code&gt; . Со всеми символами &lt;code&gt;+&lt;/code&gt; и &lt;code&gt;&quot;&lt;/code&gt; сложно понять, что происходит. Для более сложного комбинирования строк мы можем использовать макрос &lt;code&gt;format!&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="bad906bb2d4d513518792ef63a17dbb628e284cd" translate="yes" xml:space="preserve">
          <source>At this point, the first part of the game is done: we&amp;rsquo;re getting input from the keyboard and then printing it.</source>
          <target state="translated">На этом первая часть игры завершена: мы получаем ввод с клавиатуры и затем печатаем его.</target>
        </trans-unit>
        <trans-unit id="645fa0bc97b2e92b8b41b6c72b5e6804e2731419" translate="yes" xml:space="preserve">
          <source>At this point, the relationship between scopes and when variables are valid is similar to that in other programming languages. Now we&amp;rsquo;ll build on top of this understanding by introducing the &lt;code&gt;String&lt;/code&gt; type.</source>
          <target state="translated">На этом этапе отношения между областями действия и действительными переменными аналогичны отношениям в других языках программирования. Теперь мы будем опираться на это понимание, введя тип &lt;code&gt;String&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="440b2812ba3e248d39262c445df6cb473f1a4cf8" translate="yes" xml:space="preserve">
          <source>At this point, we can build the workspace by running &lt;code&gt;cargo build&lt;/code&gt;. The files in your &lt;em&gt;add&lt;/em&gt; directory should look like this:</source>
          <target state="translated">На этом этапе мы можем создать рабочее пространство, запустив &lt;code&gt;cargo build&lt;/code&gt; . Файлы в вашем каталоге &lt;em&gt;добавления&lt;/em&gt; должны выглядеть следующим образом:</target>
        </trans-unit>
        <trans-unit id="f644530959c577881d3641aeacacd055e0614725" translate="yes" xml:space="preserve">
          <source>At this point, we could consider opportunities for refactoring the implementation of the search function while keeping the tests passing to maintain the same functionality. The code in the search function isn&amp;rsquo;t too bad, but it doesn&amp;rsquo;t take advantage of some useful features of iterators. We&amp;rsquo;ll return to this example in &lt;a href=&quot;ch13-02-iterators&quot;&gt;Chapter 13&lt;/a&gt;, where we&amp;rsquo;ll explore iterators in detail, and look at how to improve it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7be13e6f2293ee19341faecbce38cbce6581638c" translate="yes" xml:space="preserve">
          <source>At this point, we could consider opportunities for refactoring the implementation of the search function while keeping the tests passing to maintain the same functionality. The code in the search function isn&amp;rsquo;t too bad, but it doesn&amp;rsquo;t take advantage of some useful features of iterators. We&amp;rsquo;ll return to this example in [Chapter 13][ch13], where we&amp;rsquo;ll explore iterators in detail, and look at how to improve it.</source>
          <target state="translated">На этом этапе мы могли бы рассмотреть возможности рефакторинга реализации функции поиска при сохранении прохождения тестов для сохранения той же функциональности. Код в функции поиска неплох, но он не использует некоторых полезных функций итераторов. Мы вернемся к этому примеру в [Глава 13] [ch13], где мы подробно исследуем итераторы и посмотрим, как его улучшить.</target>
        </trans-unit>
        <trans-unit id="12d2e7392939d54c75dd7be38b3f433458f57624" translate="yes" xml:space="preserve">
          <source>At this point, when we call &lt;code&gt;content&lt;/code&gt; on the &lt;code&gt;&amp;amp;Box&amp;lt;dyn State&amp;gt;&lt;/code&gt;, deref coercion will take effect on the &lt;code&gt;&amp;amp;&lt;/code&gt; and the &lt;code&gt;Box&lt;/code&gt; so the &lt;code&gt;content&lt;/code&gt; method will ultimately be called on the type that implements the &lt;code&gt;State&lt;/code&gt; trait. That means we need to add &lt;code&gt;content&lt;/code&gt; to the &lt;code&gt;State&lt;/code&gt; trait definition, and that is where we&amp;rsquo;ll put the logic for what content to return depending on which state we have, as shown in Listing 17-18:</source>
          <target state="translated">На этом этапе, когда мы вызываем &lt;code&gt;content&lt;/code&gt; в &lt;code&gt;&amp;amp;Box&amp;lt;dyn State&amp;gt;&lt;/code&gt; , приведение deref будет действовать в &lt;code&gt;&amp;amp;&lt;/code&gt; и &lt;code&gt;Box&lt;/code&gt; , поэтому метод &lt;code&gt;content&lt;/code&gt; конечном итоге будет вызываться для типа, который реализует черту &lt;code&gt;State&lt;/code&gt; . Это означает, что нам нужно добавить &lt;code&gt;content&lt;/code&gt; в определение свойства &lt;code&gt;State&lt;/code&gt; , и именно здесь мы поместим логику того, какой контент возвращать в зависимости от того, какое у нас состояние, как показано в листинге 17-18:</target>
        </trans-unit>
        <trans-unit id="41d03c60eead1f80179e902c1b4d9814280d6245" translate="yes" xml:space="preserve">
          <source>At this point, when we try to get a reference to the parent of &lt;code&gt;leaf&lt;/code&gt; by using the &lt;code&gt;upgrade&lt;/code&gt; method, we get a &lt;code&gt;None&lt;/code&gt; value. We see this in the output from the first &lt;code&gt;println!&lt;/code&gt; statement:</source>
          <target state="translated">На этом этапе, когда мы пытаемся получить ссылку на родительский элемент &lt;code&gt;leaf&lt;/code&gt; с помощью метода &lt;code&gt;upgrade&lt;/code&gt; , мы получаем значение &lt;code&gt;None&lt;/code&gt; . Мы видим это в выводе первого &lt;code&gt;println!&lt;/code&gt; заявление:</target>
        </trans-unit>
        <trans-unit id="3822c3ca41678f3e73f1513ee4103e0d10a48e3d" translate="yes" xml:space="preserve">
          <source>At this point, you would also notice a change in your &lt;em&gt;Cargo.lock&lt;/em&gt; file noting that the version of the &lt;code&gt;rand&lt;/code&gt; crate you are now using is &lt;code&gt;0.3.15&lt;/code&gt;.</source>
          <target state="translated">На этом этапе вы также заметите изменение в вашем файле &lt;em&gt;Cargo.lock,&lt;/em&gt; в котором &lt;em&gt;указано,&lt;/em&gt; что версия ящика &lt;code&gt;rand&lt;/code&gt; ,которую вы сейчас используете, - &lt;code&gt;0.3.15&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="980ca773a0cc1c507c75dc787b2ebd61a83c58ee" translate="yes" xml:space="preserve">
          <source>At this point, you would also notice a change in your &lt;em&gt;Cargo.lock&lt;/em&gt; file noting that the version of the &lt;code&gt;rand&lt;/code&gt; crate you are now using is &lt;code&gt;0.5.6&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ace63d2aec4c0fa2eb5be485664adddc5d8c8911" translate="yes" xml:space="preserve">
          <source>At this point, you&amp;rsquo;ve seen several ways of using patterns, but patterns don&amp;rsquo;t work the same in every place we can use them. In some places, the patterns must be irrefutable; in other circumstances, they can be refutable. We&amp;rsquo;ll discuss these two concepts next.</source>
          <target state="translated">На этом этапе вы видели несколько способов использования шаблонов, но шаблоны работают не везде, где мы можем их использовать. В некоторых местах образцы должны быть неопровержимы; при других обстоятельствах они могут быть опровергнуты. Далее мы обсудим эти две концепции.</target>
        </trans-unit>
        <trans-unit id="e19eb30ab901969b293ab5f50d80d0816b9dd309" translate="yes" xml:space="preserve">
          <source>At this point, you&amp;rsquo;ve successfully built the guessing game. Congratulations!</source>
          <target state="translated">На этом этапе вы успешно создали игру в угадайку. Поздравляю!</target>
        </trans-unit>
        <trans-unit id="632731832807bd949f8afaff185b846c11bff1a6" translate="yes" xml:space="preserve">
          <source>Atomic Reference Counting with &lt;code id=&quot;atomic-reference-counting-with-arct&quot;&gt;Arc&amp;lt;T&amp;gt;&lt;/code&gt;</source>
          <target state="translated">Подсчет атомных ссылок с помощью &lt;code id=&quot;atomic-reference-counting-with-arct&quot;&gt;Arc&amp;lt;T&amp;gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="81578fbf1ea44596108fd645f27e6431bf82318a" translate="yes" xml:space="preserve">
          <source>Atomic memory orderings</source>
          <target state="translated">Атомные заказы памяти</target>
        </trans-unit>
        <trans-unit id="7d5338021e809e34d20a6b06646a458b5152b9dc" translate="yes" xml:space="preserve">
          <source>Atomic operations may be implemented at the instruction layer with larger-size atomics. For example some platforms use 4-byte atomic instructions to implement &lt;code&gt;AtomicI8&lt;/code&gt;. Note that this emulation should not have an impact on correctness of code, it's just something to be aware of.</source>
          <target state="translated">Атомарные операции могут быть реализованы на уровне команд с помощью атомарных операций большего размера. Например, на некоторых платформах для реализации &lt;code&gt;AtomicI8&lt;/code&gt; используются 4-байтовые атомарные инструкции . Обратите внимание, что эта эмуляция не должна влиять на правильность кода, это просто то, о чем нужно знать.</target>
        </trans-unit>
        <trans-unit id="8e24008909c0fc6f23ca4f4f874bb53512815caa" translate="yes" xml:space="preserve">
          <source>Atomic operations with &lt;a href=&quot;enum.ordering#variant.Release&quot;&gt;&lt;code&gt;Release&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;enum.ordering#variant.Acquire&quot;&gt;&lt;code&gt;Acquire&lt;/code&gt;&lt;/a&gt; semantics can also synchronize with a fence.</source>
          <target state="translated">Атомарные операции с семантикой &lt;a href=&quot;enum.ordering#variant.Release&quot;&gt; &lt;code&gt;Release&lt;/code&gt; &lt;/a&gt; или &lt;a href=&quot;enum.ordering#variant.Acquire&quot;&gt; &lt;code&gt;Acquire&lt;/code&gt; &lt;/a&gt; также могут синхронизироваться с забором.</target>
        </trans-unit>
        <trans-unit id="6bd53298c2672a3d3501c1b3d668970f3f55e051" translate="yes" xml:space="preserve">
          <source>Atomic types</source>
          <target state="translated">Атомные типы</target>
        </trans-unit>
        <trans-unit id="bd540eaa28be66ef79bdb0e6dc9e7f21a135c077" translate="yes" xml:space="preserve">
          <source>Atomic types may be stored in static variables, initialized using the constant initializers like &lt;a href=&quot;struct.atomicbool#method.new&quot;&gt;&lt;code&gt;AtomicBool::new&lt;/code&gt;&lt;/a&gt;. Atomic statics are often used for lazy global initialization.</source>
          <target state="translated">Атомарные типы могут храниться в статических переменных, инициализированных с помощью инициализаторов констант, таких как &lt;a href=&quot;struct.atomicbool#method.new&quot;&gt; &lt;code&gt;AtomicBool::new&lt;/code&gt; &lt;/a&gt; . Атомарная статика часто используется для ленивой глобальной инициализации.</target>
        </trans-unit>
        <trans-unit id="af8191cce263e5511ffa70b9167ccc44038ee579" translate="yes" xml:space="preserve">
          <source>Atomic types provide primitive shared-memory communication between threads, and are the building blocks of other concurrent types.</source>
          <target state="translated">Атомные типы обеспечивают примитивное взаимодействие общей памяти между потоками и являются строительными блоками других параллельных типов.</target>
        </trans-unit>
        <trans-unit id="489ec10910f60409e46dc7b2401064ba30bfb22a" translate="yes" xml:space="preserve">
          <source>Atomic variables are safe to share between threads (they implement &lt;a href=&quot;../../marker/trait.sync&quot;&gt;&lt;code&gt;Sync&lt;/code&gt;&lt;/a&gt;) but they do not themselves provide the mechanism for sharing and follow the &lt;a href=&quot;../../thread/index#the-threading-model&quot;&gt;threading model&lt;/a&gt; of Rust. The most common way to share an atomic variable is to put it into an &lt;a href=&quot;../struct.arc&quot;&gt;&lt;code&gt;Arc&lt;/code&gt;&lt;/a&gt; (an atomically-reference-counted shared pointer).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bdcc7b682e49710ce243d11d666d0605dd24412a" translate="yes" xml:space="preserve">
          <source>Atomic variables are safe to share between threads (they implement &lt;a href=&quot;../../marker/trait.sync&quot;&gt;&lt;code&gt;Sync&lt;/code&gt;&lt;/a&gt;) but they do not themselves provide the mechanism for sharing and follow the &lt;a href=&quot;../../thread/index#the-threading-model&quot;&gt;threading model&lt;/a&gt; of rust. The most common way to share an atomic variable is to put it into an &lt;a href=&quot;../struct.arc&quot;&gt;&lt;code&gt;Arc&lt;/code&gt;&lt;/a&gt; (an atomically-reference-counted shared pointer).</source>
          <target state="translated">Атомарные переменные безопасно разделять между потоками (они реализуют &lt;a href=&quot;../../marker/trait.sync&quot;&gt; &lt;code&gt;Sync&lt;/code&gt; &lt;/a&gt; ), но сами по себе они не предоставляют механизма для совместного использования и следуют &lt;a href=&quot;../../thread/index#the-threading-model&quot;&gt;потоковой модели&lt;/a&gt; ржавчины. Самый распространенный способ поделиться атомарной переменной - поместить ее в &lt;a href=&quot;../struct.arc&quot;&gt; &lt;code&gt;Arc&lt;/code&gt; &lt;/a&gt; (общий указатель с атомарным подсчетом ссылок).</target>
        </trans-unit>
        <trans-unit id="6674d00db7a2e69964175c1325e3eccae698e4d3" translate="yes" xml:space="preserve">
          <source>AtomicBool</source>
          <target state="translated">AtomicBool</target>
        </trans-unit>
        <trans-unit id="c3f581e842f52532b7b151cdbc4ce7233b954e8c" translate="yes" xml:space="preserve">
          <source>AtomicI16</source>
          <target state="translated">AtomicI16</target>
        </trans-unit>
        <trans-unit id="29b774c369d481cc7134a7a13427afa21b7fc9cd" translate="yes" xml:space="preserve">
          <source>AtomicI32</source>
          <target state="translated">AtomicI32</target>
        </trans-unit>
        <trans-unit id="d734b8bd0031516fdc53fb6831e8dec9b067b165" translate="yes" xml:space="preserve">
          <source>AtomicI64</source>
          <target state="translated">AtomicI64</target>
        </trans-unit>
        <trans-unit id="e94562e900680db9e18fda42ce322ce7a5e558bf" translate="yes" xml:space="preserve">
          <source>AtomicI8</source>
          <target state="translated">AtomicI8</target>
        </trans-unit>
        <trans-unit id="c2cc2ca63393294d4014028c732f15eca926e7a2" translate="yes" xml:space="preserve">
          <source>AtomicIsize</source>
          <target state="translated">AtomicIsize</target>
        </trans-unit>
        <trans-unit id="7bc45caa3c8c7a6bbad87dd4b67403e414361ce1" translate="yes" xml:space="preserve">
          <source>AtomicPtr</source>
          <target state="translated">AtomicPtr</target>
        </trans-unit>
        <trans-unit id="17a70c0c14e8b2c47d91d2253122896320428148" translate="yes" xml:space="preserve">
          <source>AtomicU16</source>
          <target state="translated">AtomicU16</target>
        </trans-unit>
        <trans-unit id="8840103173e424948e002b5ffec50c44e404d250" translate="yes" xml:space="preserve">
          <source>AtomicU32</source>
          <target state="translated">AtomicU32</target>
        </trans-unit>
        <trans-unit id="32ac2d92ec899ed90a2638fc480a4297cef99b45" translate="yes" xml:space="preserve">
          <source>AtomicU64</source>
          <target state="translated">AtomicU64</target>
        </trans-unit>
        <trans-unit id="a496370705e1f84302673bc11932128de26a2fea" translate="yes" xml:space="preserve">
          <source>AtomicU8</source>
          <target state="translated">AtomicU8</target>
        </trans-unit>
        <trans-unit id="9d9469a55330492f15842defa35b0f1ef07cac12" translate="yes" xml:space="preserve">
          <source>AtomicUsize</source>
          <target state="translated">AtomicUsize</target>
        </trans-unit>
        <trans-unit id="48c5fb201c75414dd3666a318d954dd873099b2d" translate="yes" xml:space="preserve">
          <source>Atomically makes the handle's token available if it is not already.</source>
          <target state="translated">Атомически делает маркер ручки доступным,если его еще нет.</target>
        </trans-unit>
        <trans-unit id="22cd0cbd81dee9dcd227285a4fb456261af24ea4" translate="yes" xml:space="preserve">
          <source>Atomics</source>
          <target state="translated">Atomics</target>
        </trans-unit>
        <trans-unit id="fe4c2e56ace1dd5cd16118bb6ad5e5256c61db83" translate="yes" xml:space="preserve">
          <source>Attempt to downcast the &lt;code&gt;Arc&amp;lt;dyn Any + Send + Sync&amp;gt;&lt;/code&gt; to a concrete type.</source>
          <target state="translated">Попытка преобразовать &lt;code&gt;Arc&amp;lt;dyn Any + Send + Sync&amp;gt;&lt;/code&gt; в конкретный тип.</target>
        </trans-unit>
        <trans-unit id="92df3d44a91e7d67c064d6d725fec8b2e940cc64" translate="yes" xml:space="preserve">
          <source>Attempt to downcast the &lt;code&gt;Rc&amp;lt;dyn Any&amp;gt;&lt;/code&gt; to a concrete type.</source>
          <target state="translated">Попытка свести &lt;code&gt;Rc&amp;lt;dyn Any&amp;gt;&lt;/code&gt; к конкретному типу.</target>
        </trans-unit>
        <trans-unit id="886d23c3fa7b51635fa7bbdd282f2babcd6cb45c" translate="yes" xml:space="preserve">
          <source>Attempt to downcast the box to a concrete type.</source>
          <target state="translated">Попытайтесь придать коробке бетонный вид.</target>
        </trans-unit>
        <trans-unit id="175cf296f94bed8278b4e811c5245f622f67f97c" translate="yes" xml:space="preserve">
          <source>Attempt to resolve the future to a final value, registering the current task for wakeup if the value is not yet available.</source>
          <target state="translated">Попытайтесь разрешить будущее до конечного значения,регистрируя текущее задание для пробуждения,если это значение еще не доступно.</target>
        </trans-unit>
        <trans-unit id="0b1794f780a4845e82f1aa618849777a9e5b6e42" translate="yes" xml:space="preserve">
          <source>Attempt to resolve the future to a final value, registering the current task for wakeup if the value is not yet available. &lt;a href=&quot;../future/trait.future#tymethod.poll&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">Попытка разрешить будущее до окончательного значения, зарегистрировав текущую задачу для пробуждения, если значение еще не доступно. &lt;a href=&quot;../future/trait.future#tymethod.poll&quot;&gt;Читать далее&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="55136df45140cab2915451715291fdde1ced9b25" translate="yes" xml:space="preserve">
          <source>Attempt to resolve the future to a final value, registering the current task for wakeup if the value is not yet available. &lt;a href=&quot;future/trait.future#tymethod.poll&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">Попытка разрешить будущее до окончательного значения, зарегистрировав текущую задачу для пробуждения, если значение еще не доступно. &lt;a href=&quot;future/trait.future#tymethod.poll&quot;&gt;Читать далее&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="856e8b63203e04805b09dd95b9d3481ff3097c22" translate="yes" xml:space="preserve">
          <source>Attempt was made to import an item whereas an extern crate with this name has already been imported.</source>
          <target state="translated">Была предпринята попытка импортировать товар,в то время как внешний ящик с таким именем уже был импортирован.</target>
        </trans-unit>
        <trans-unit id="5fc738aa7f6254311ae3614b150f4fe1cec8fe27" translate="yes" xml:space="preserve">
          <source>Attempt was made to import an unimportable value. This can happen when trying to import a method from a trait.</source>
          <target state="translated">Была предпринята попытка импортировать неимоверную стоимость.Это может произойти при попытке импортировать метод из признака.</target>
        </trans-unit>
        <trans-unit id="2c61d256e7903ca5ede61e01fd8467962bbb349b" translate="yes" xml:space="preserve">
          <source>Attempted to access a field on a primitive type.</source>
          <target state="translated">Попытка получить доступ к полю на примитивном типе.</target>
        </trans-unit>
        <trans-unit id="a54332e7df630f85a467d7ec89246d77c007b643" translate="yes" xml:space="preserve">
          <source>Attempted to access a method like a field.</source>
          <target state="translated">Попытка получить доступ к такому методу,как поле.</target>
        </trans-unit>
        <trans-unit id="48f28400d9c83d5af115ff62dc11ba5e26ca8457" translate="yes" xml:space="preserve">
          <source>Attempted to access a non-existent field in a struct.</source>
          <target state="translated">Попытка получить доступ к несуществующему полю в структуре.</target>
        </trans-unit>
        <trans-unit id="03b41486da885815831596a9c99e4264efdf5d06" translate="yes" xml:space="preserve">
          <source>Attempted to access a private field on a struct.</source>
          <target state="translated">Попытка получить доступ к приватному полю на структуре.</target>
        </trans-unit>
        <trans-unit id="a1ad3c1a31bd1ae534677401ea798535b99a38e5" translate="yes" xml:space="preserve">
          <source>Attempted to call something which isn't a function nor a method.</source>
          <target state="translated">Попытка вызова чего-то,что не является ни функцией,ни методом.</target>
        </trans-unit>
        <trans-unit id="19e440b538f0d8907b6a787acfc5bb52be0236f7" translate="yes" xml:space="preserve">
          <source>Attempted to cast to/from a pointer with an unknown kind.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eef4156ee856f3204829c854633733e0594d2319" translate="yes" xml:space="preserve">
          <source>Attempted to dereference a variable which cannot be dereferenced.</source>
          <target state="translated">Попытка разыменования переменной,которая не может быть разыменована.</target>
        </trans-unit>
        <trans-unit id="1372db0ea32a319cb23e92d2e2d51b6cd2d1a4fb" translate="yes" xml:space="preserve">
          <source>Attempted to pass an invalid type of variable into a variadic function.</source>
          <target state="translated">Попытка передать в вариадическую функцию недействительный тип переменной.</target>
        </trans-unit>
        <trans-unit id="7adfef6b18f86865559fc727494e616e0b3f7f80" translate="yes" xml:space="preserve">
          <source>Attempting to compile now gives us the following output:</source>
          <target state="translated">Попытка компиляции дает нам следующий результат:</target>
        </trans-unit>
        <trans-unit id="e83036683d0914f18e7de7ebbb8a14c9db8b6c5c" translate="yes" xml:space="preserve">
          <source>Attempting to compile this code results in this type error:</source>
          <target state="translated">Попытка скомпилировать данный код приводит к подобной ошибке:</target>
        </trans-unit>
        <trans-unit id="71aec9a6c07f86af18ab65ed514253e4a11e1117" translate="yes" xml:space="preserve">
          <source>Attempting to create a &lt;a href=&quot;enum.socketaddr&quot;&gt;&lt;code&gt;SocketAddr&lt;/code&gt;&lt;/a&gt; iterator from an improperly formatted socket address &lt;code&gt;&amp;amp;str&lt;/code&gt; (missing the port):</source>
          <target state="translated">Попытка создать итератор &lt;a href=&quot;enum.socketaddr&quot;&gt; &lt;code&gt;SocketAddr&lt;/code&gt; &lt;/a&gt; из неправильно отформатированного адреса сокета &lt;code&gt;&amp;amp;str&lt;/code&gt; (отсутствует порт):</target>
        </trans-unit>
        <trans-unit id="ef35b76897ce014407ed31f4f40475dbcd2bb582" translate="yes" xml:space="preserve">
          <source>Attempting to create a raw pointer to an &lt;code&gt;unaligned&lt;/code&gt; struct field with an expression such as &lt;code&gt;&amp;amp;packed.unaligned as *const FieldType&lt;/code&gt; creates an intermediate unaligned reference before converting that to a raw pointer. That this reference is temporary and immediately cast is inconsequential as the compiler always expects references to be properly aligned. As a result, using &lt;code&gt;&amp;amp;packed.unaligned as *const FieldType&lt;/code&gt; causes immediate &lt;em&gt;undefined behavior&lt;/em&gt; in your program.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="baf8e0e513c1e7d75d1c56986d1f69437e36903e" translate="yes" xml:space="preserve">
          <source>Attempting to create a trait object for a non object-safe trait will trigger this error.</source>
          <target state="translated">Попытка создать объект трейта для не объектно-безопасного трейта спровоцирует эту ошибку.</target>
        </trans-unit>
        <trans-unit id="fcaf285fe223ac76c6b6f3a248ca791f9480d826" translate="yes" xml:space="preserve">
          <source>Attempts to acquire this lock.</source>
          <target state="translated">Попытки заполучить этот замок.</target>
        </trans-unit>
        <trans-unit id="ed9809bcb2ab4f39482ae3c8ecc3990c35b19e02" translate="yes" xml:space="preserve">
          <source>Attempts to acquire this rwlock with shared read access.</source>
          <target state="translated">Попытки получить этот rwlock с общим доступом на чтение.</target>
        </trans-unit>
        <trans-unit id="855d837817da86285b7a962a1f7fe2fb0ca3b0f2" translate="yes" xml:space="preserve">
          <source>Attempts to allocate a block of memory. &lt;a href=&quot;alloc/trait.allocref#tymethod.alloc&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cba17f171bdff89eb9e4d13d3205c5589ee7c0ea" translate="yes" xml:space="preserve">
          <source>Attempts to allocate a block of memory. &lt;a href=&quot;trait.allocref#tymethod.alloc&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aa06f6d37e15f994598953d5d55e85873c353cbb" translate="yes" xml:space="preserve">
          <source>Attempts to collect the exit status of the child if it has already exited.</source>
          <target state="translated">Попытки забрать статус выхода ребенка,если он уже вышел.</target>
        </trans-unit>
        <trans-unit id="2ba2351b2e57e9559c0f3714a76ac923ea85c4c4" translate="yes" xml:space="preserve">
          <source>Attempts to convert &lt;code&gt;i128&lt;/code&gt; to &lt;code&gt;NonZeroI128&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2730452bbdf6d0154f196dd3387e5268fcbaae6d" translate="yes" xml:space="preserve">
          <source>Attempts to convert &lt;code&gt;i16&lt;/code&gt; to &lt;code&gt;NonZeroI16&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="89a676b16e76690126c8c689d7093c8a36a6dc3d" translate="yes" xml:space="preserve">
          <source>Attempts to convert &lt;code&gt;i32&lt;/code&gt; to &lt;code&gt;NonZeroI32&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="af2f75ee1f964bb69b3471df2010cd26d4f8b3c4" translate="yes" xml:space="preserve">
          <source>Attempts to convert &lt;code&gt;i64&lt;/code&gt; to &lt;code&gt;NonZeroI64&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c93de3bc4194ab8f5cef5b860227606b9963f2e3" translate="yes" xml:space="preserve">
          <source>Attempts to convert &lt;code&gt;i8&lt;/code&gt; to &lt;code&gt;NonZeroI8&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6042fa62c1123d272cfaedcf34e40785b595efa5" translate="yes" xml:space="preserve">
          <source>Attempts to convert &lt;code&gt;isize&lt;/code&gt; to &lt;code&gt;NonZeroIsize&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d44685c697bf86bf627255f318a92026c3067b36" translate="yes" xml:space="preserve">
          <source>Attempts to convert &lt;code&gt;u128&lt;/code&gt; to &lt;code&gt;NonZeroU128&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="83f6c21bb3f0a85bb02b720c0facffc143df545d" translate="yes" xml:space="preserve">
          <source>Attempts to convert &lt;code&gt;u16&lt;/code&gt; to &lt;code&gt;NonZeroU16&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4f25fe04e2aca5c5faadb4cc9021f2c2472cc8a3" translate="yes" xml:space="preserve">
          <source>Attempts to convert &lt;code&gt;u32&lt;/code&gt; to &lt;code&gt;NonZeroU32&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dbf97d063f75afad6228d1db287eb0de45a1ab04" translate="yes" xml:space="preserve">
          <source>Attempts to convert &lt;code&gt;u64&lt;/code&gt; to &lt;code&gt;NonZeroU64&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="89d08d408000b79c0c0f0951f917eed73ebef3a3" translate="yes" xml:space="preserve">
          <source>Attempts to convert &lt;code&gt;u8&lt;/code&gt; to &lt;code&gt;NonZeroU8&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8cee9eaea9548154103d038cde6240ee1cc68830" translate="yes" xml:space="preserve">
          <source>Attempts to convert &lt;code&gt;usize&lt;/code&gt; to &lt;code&gt;NonZeroUsize&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2d9e42b5d35e242781f009f21f3c5ea257d9b8d7" translate="yes" xml:space="preserve">
          <source>Attempts to converts a &lt;a href=&quot;../vec/struct.vec&quot;&gt;&lt;code&gt;Vec&lt;/code&gt;&lt;/a&gt;&lt;code&gt;&amp;lt;u8&amp;gt;&lt;/code&gt; to a &lt;a href=&quot;struct.cstring&quot;&gt;&lt;code&gt;CString&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8d17c0e55fb5767927f25b2be2aaccc4cffbef7d" translate="yes" xml:space="preserve">
          <source>Attempts to downcast the box to a concrete type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2067ade47b4e19fcd748b5622bcd5a578000fa70" translate="yes" xml:space="preserve">
          <source>Attempts to extend the allocation referenced by &lt;code&gt;ptr&lt;/code&gt; to fit &lt;code&gt;new_size&lt;/code&gt;.</source>
          <target state="translated">Попытки расширить выделение, на которое ссылается &lt;code&gt;ptr&lt;/code&gt; , чтобы соответствовать &lt;code&gt;new_size&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1f0524b8bf45261cb2e5192b808b5a4a85102e03" translate="yes" xml:space="preserve">
          <source>Attempts to extend the allocation referenced by &lt;code&gt;ptr&lt;/code&gt; to fit &lt;code&gt;new_size&lt;/code&gt;. &lt;a href=&quot;trait.alloc#method.grow_in_place&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">Попытки расширить выделение, на которое ссылается &lt;code&gt;ptr&lt;/code&gt; , чтобы соответствовать &lt;code&gt;new_size&lt;/code&gt; . &lt;a href=&quot;trait.alloc#method.grow_in_place&quot;&gt;Читать далее&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="27c873a148fefc84fd64a13dc7df4ae1e7fa3719" translate="yes" xml:space="preserve">
          <source>Attempts to extend the memory block. &lt;a href=&quot;alloc/trait.allocref#method.grow&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="adef0a0225d086130a40a297ad3ad900429332c4" translate="yes" xml:space="preserve">
          <source>Attempts to extend the memory block. &lt;a href=&quot;trait.allocref#method.grow&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="14aa482507a26cdd1d3724ec04b0d14909b4ce76" translate="yes" xml:space="preserve">
          <source>Attempts to lock this rwlock with exclusive write access.</source>
          <target state="translated">Попытки заблокировать этот rwlock с эксклюзивным доступом на запись.</target>
        </trans-unit>
        <trans-unit id="3e149a02e4c5943a78110a9fe37e7dfdc1377a23" translate="yes" xml:space="preserve">
          <source>Attempts to open a file in read-only mode.</source>
          <target state="translated">Попытки открыть файл в режиме только для чтения.</target>
        </trans-unit>
        <trans-unit id="ce00391cd1170f4f9f1ed2dc7adb3e45ca14e46a" translate="yes" xml:space="preserve">
          <source>Attempts to return a pending value on this receiver without blocking.</source>
          <target state="translated">Попытки вернуть отложенное значение на этом приемнике без блокировки.</target>
        </trans-unit>
        <trans-unit id="88500c10aaa3c7978ed8857be5643440673d4380" translate="yes" xml:space="preserve">
          <source>Attempts to send a value on this channel without blocking.</source>
          <target state="translated">Попытки отправить значение по этому каналу без блокировки.</target>
        </trans-unit>
        <trans-unit id="44fed3b4d1c2db46234c4d30a1056c0ccd124c87" translate="yes" xml:space="preserve">
          <source>Attempts to send a value on this channel, returning it back if it could not be sent.</source>
          <target state="translated">Попытки отправить значение по этому каналу,возвращая его обратно,если его не удалось отправить.</target>
        </trans-unit>
        <trans-unit id="6da3e262b2372fb386666634b5d39f9d3f7bb80a" translate="yes" xml:space="preserve">
          <source>Attempts to shrink the allocation referenced by &lt;code&gt;ptr&lt;/code&gt; to fit &lt;code&gt;new_size&lt;/code&gt;.</source>
          <target state="translated">Пытается уменьшить выделение, на которое указывает &lt;code&gt;ptr&lt;/code&gt; , чтобы оно соответствовало &lt;code&gt;new_size&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d9dd72c543bd49d83f78f0fdf1367b07147238f9" translate="yes" xml:space="preserve">
          <source>Attempts to shrink the allocation referenced by &lt;code&gt;ptr&lt;/code&gt; to fit &lt;code&gt;new_size&lt;/code&gt;. &lt;a href=&quot;trait.alloc#method.shrink_in_place&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">Пытается уменьшить выделение, на которое указывает &lt;code&gt;ptr&lt;/code&gt; , чтобы оно соответствовало &lt;code&gt;new_size&lt;/code&gt; . &lt;a href=&quot;trait.alloc#method.shrink_in_place&quot;&gt;Читать далее&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="b70a3bb894ec313a60c83cc036390a2df8753cb7" translate="yes" xml:space="preserve">
          <source>Attempts to shrink the memory block. &lt;a href=&quot;alloc/trait.allocref#method.shrink&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="96e65f083a95479e0e7fff8e23938d5ab69fdc1f" translate="yes" xml:space="preserve">
          <source>Attempts to shrink the memory block. &lt;a href=&quot;trait.allocref#method.shrink&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d431ee47732f5fda5d822308d953fb6c4ab546af" translate="yes" xml:space="preserve">
          <source>Attempts to sync all OS-internal metadata to disk.</source>
          <target state="translated">Попытки синхронизации всех внутренних метаданных ОС на диск.</target>
        </trans-unit>
        <trans-unit id="bd1357cf9c16c8860cced8547ac6ac2266fff48b" translate="yes" xml:space="preserve">
          <source>Attempts to upgrade the &lt;code&gt;Weak&lt;/code&gt; pointer to an &lt;a href=&quot;struct.arc&quot;&gt;&lt;code&gt;Arc&lt;/code&gt;&lt;/a&gt;, delaying dropping of the inner value if successful.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e1a28bf0ca8943d3102fb17a5f930dbd42c32e93" translate="yes" xml:space="preserve">
          <source>Attempts to upgrade the &lt;code&gt;Weak&lt;/code&gt; pointer to an &lt;a href=&quot;struct.arc&quot;&gt;&lt;code&gt;Arc&lt;/code&gt;&lt;/a&gt;, extending the lifetime of the value if successful.</source>
          <target state="translated">Пытается обновить &lt;code&gt;Weak&lt;/code&gt; указатель до &lt;a href=&quot;struct.arc&quot;&gt; &lt;code&gt;Arc&lt;/code&gt; &lt;/a&gt; , в случае успеха продлевая время жизни значения.</target>
        </trans-unit>
        <trans-unit id="3f7dd7ca12e8b115613fa365887978f9fb146c24" translate="yes" xml:space="preserve">
          <source>Attempts to upgrade the &lt;code&gt;Weak&lt;/code&gt; pointer to an &lt;a href=&quot;struct.rc&quot;&gt;&lt;code&gt;Rc&lt;/code&gt;&lt;/a&gt;, delaying dropping of the inner value if successful.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c10f653d6058260dd8df6597f6fc625f0e90a7a2" translate="yes" xml:space="preserve">
          <source>Attempts to upgrade the &lt;code&gt;Weak&lt;/code&gt; pointer to an &lt;a href=&quot;struct.rc&quot;&gt;&lt;code&gt;Rc&lt;/code&gt;&lt;/a&gt;, extending the lifetime of the value if successful.</source>
          <target state="translated">Пытается обновить &lt;code&gt;Weak&lt;/code&gt; указатель до &lt;a href=&quot;struct.rc&quot;&gt; &lt;code&gt;Rc&lt;/code&gt; &lt;/a&gt; , в случае успеха увеличивая время жизни значения.</target>
        </trans-unit>
        <trans-unit id="4ed9981b4c97d4946f7cc66f3d69625251a285c0" translate="yes" xml:space="preserve">
          <source>Attempts to wait for a value on this receiver, returning an error if the corresponding channel has hung up, or if &lt;code&gt;deadline&lt;/code&gt; is reached.</source>
          <target state="translated">Пытается дождаться значения на этом приемнике, возвращая ошибку, если соответствующий канал повесил трубку или если достигнут &lt;code&gt;deadline&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="eea7708f089d17a724b4fe150c8a5b22b7b7cd15" translate="yes" xml:space="preserve">
          <source>Attempts to wait for a value on this receiver, returning an error if the corresponding channel has hung up, or if it waits more than &lt;code&gt;timeout&lt;/code&gt;.</source>
          <target state="translated">Пытается дождаться значения на этом приемнике, возвращая ошибку, если соответствующий канал повесил трубку, или если он ждет больше времени &lt;code&gt;timeout&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c5624ed9b3f4c32e9214ed479d11bee18fe54f2a" translate="yes" xml:space="preserve">
          <source>Attempts to wait for a value on this receiver, returning an error if the corresponding channel has hung up.</source>
          <target state="translated">Пытается дождаться значения на этом приемнике,возвращая ошибку,если соответствующий канал завис.</target>
        </trans-unit>
        <trans-unit id="66681ba198baa628940b6e0e8d1d21d555ae1a8d" translate="yes" xml:space="preserve">
          <source>Attempts to write an entire buffer into this writer.</source>
          <target state="translated">Попытки записать целый буфер в этот писатель.</target>
        </trans-unit>
        <trans-unit id="50c44c33216c75388385c7158cbb2db3b18cd276" translate="yes" xml:space="preserve">
          <source>Attempts to write an entire buffer into this writer. &lt;a href=&quot;../../../io/trait.write#method.write_all&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">Пытается записать в этот писатель весь буфер. &lt;a href=&quot;../../../io/trait.write#method.write_all&quot;&gt;Читать далее&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="cb65a661c9940f60efcdfd42e570120d00134516" translate="yes" xml:space="preserve">
          <source>Attempts to write an entire buffer into this writer. &lt;a href=&quot;../io/trait.write#method.write_all&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">Пытается записать в этот писатель весь буфер. &lt;a href=&quot;../io/trait.write#method.write_all&quot;&gt;Читать далее&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="7537ca8f100350d628ddd2455b7d2b9261e91786" translate="yes" xml:space="preserve">
          <source>Attempts to write an entire buffer into this writer. &lt;a href=&quot;io/trait.write#method.write_all&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">Пытается записать в этот писатель весь буфер. &lt;a href=&quot;io/trait.write#method.write_all&quot;&gt;Читать далее&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="c4a079954569cfca76bb04671c6eef0de6f2845b" translate="yes" xml:space="preserve">
          <source>Attempts to write an entire buffer into this writer. &lt;a href=&quot;trait.write#method.write_all&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">Пытается записать в этот писатель весь буфер. &lt;a href=&quot;trait.write#method.write_all&quot;&gt;Читать далее&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="3a4550331cd75411aa797d05589ea44d59948931" translate="yes" xml:space="preserve">
          <source>Attempts to write an entire buffer starting from a given offset.</source>
          <target state="translated">Попытки записать весь буфер,начиная с заданного смещения.</target>
        </trans-unit>
        <trans-unit id="bd08d9b38e39a23845ecac7733a7135e68b5844b" translate="yes" xml:space="preserve">
          <source>Attempts to write an entire buffer starting from a given offset. &lt;a href=&quot;../os/unix/fs/trait.fileext#method.write_all_at&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">Пытается записать весь буфер, начиная с заданного смещения. &lt;a href=&quot;../os/unix/fs/trait.fileext#method.write_all_at&quot;&gt;Читать далее&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="3cd154a661d834b07894c77674ab8ed918e6d062" translate="yes" xml:space="preserve">
          <source>Attempts to write multiple buffers into this writer.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fc422df0d6aeefc153e9d11191c7acdab0fee066" translate="yes" xml:space="preserve">
          <source>Attempts to write multiple buffers into this writer. &lt;a href=&quot;../../../io/trait.write#method.write_all_vectored&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ef049b1e411811d76553b0e75329cbd0d79e8485" translate="yes" xml:space="preserve">
          <source>Attempts to write multiple buffers into this writer. &lt;a href=&quot;../io/trait.write#method.write_all_vectored&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="59af638438e522a4fe5eaeba810e068e6c90b8b0" translate="yes" xml:space="preserve">
          <source>Attempts to write multiple buffers into this writer. &lt;a href=&quot;io/trait.write#method.write_all_vectored&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4d6a58aa82ce87e3367d27cafec071fe08afba77" translate="yes" xml:space="preserve">
          <source>Attempts to write multiple buffers into this writer. &lt;a href=&quot;trait.write#method.write_all_vectored&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="63578c033690b22f88448dc9020fc65119c91cf5" translate="yes" xml:space="preserve">
          <source>Attribute contains same meta item more than once.</source>
          <target state="translated">Атрибут содержит один и тот же мета-элемент не один раз.</target>
        </trans-unit>
        <trans-unit id="645ef54c5f28a9cf578382e9466764d3ebe4899c" translate="yes" xml:space="preserve">
          <source>Attribute macros</source>
          <target state="translated">Атрибутировать макросы</target>
        </trans-unit>
        <trans-unit id="1a7e3b192d591463acc213e348e2d3be95158e41" translate="yes" xml:space="preserve">
          <source>Attribute macros are defined by a &lt;a href=&quot;visibility-and-privacy&quot;&gt;public&lt;/a&gt;&lt;a href=&quot;items/functions&quot;&gt;function&lt;/a&gt; with the &lt;code&gt;proc_macro_attribute&lt;/code&gt;&lt;a href=&quot;attributes&quot;&gt;attribute&lt;/a&gt; that has a signature of &lt;code&gt;(TokenStream, TokenStream) -&amp;gt; TokenStream&lt;/code&gt;. The first &lt;a href=&quot;https://doc.rust-lang.org/proc_macro/struct.TokenStream.html&quot;&gt;&lt;code&gt;TokenStream&lt;/code&gt;&lt;/a&gt; is the delimited token tree following the attribute's name, not including the outer delimiters. If the attribute is written as a bare attribute name, the attribute &lt;a href=&quot;https://doc.rust-lang.org/proc_macro/struct.TokenStream.html&quot;&gt;&lt;code&gt;TokenStream&lt;/code&gt;&lt;/a&gt; is empty. The second &lt;a href=&quot;https://doc.rust-lang.org/proc_macro/struct.TokenStream.html&quot;&gt;&lt;code&gt;TokenStream&lt;/code&gt;&lt;/a&gt; is the rest of the &lt;a href=&quot;items&quot;&gt;item&lt;/a&gt; including other &lt;a href=&quot;attributes&quot;&gt;attributes&lt;/a&gt; on the &lt;a href=&quot;items&quot;&gt;item&lt;/a&gt;. The returned &lt;a href=&quot;https://doc.rust-lang.org/proc_macro/struct.TokenStream.html&quot;&gt;&lt;code&gt;TokenStream&lt;/code&gt;&lt;/a&gt; replaces the &lt;a href=&quot;items&quot;&gt;item&lt;/a&gt; with an arbitrary number of &lt;a href=&quot;items&quot;&gt;items&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="859156ebbcd8a20df68582e72c9cb8ebb2f8d6d9" translate="yes" xml:space="preserve">
          <source>Attribute macros are defined by a &lt;a href=&quot;visibility-and-privacy&quot;&gt;public&lt;/a&gt;&lt;a href=&quot;items/functions&quot;&gt;function&lt;/a&gt; with the &lt;code&gt;proc_macro_attribute&lt;/code&gt;&lt;a href=&quot;attributes&quot;&gt;attribute&lt;/a&gt; that has a signature of &lt;code&gt;(TokenStream, TokenStream) -&amp;gt; TokenStream&lt;/code&gt;. The first &lt;a href=&quot;https://doc.rust-lang.org/proc_macro/struct.TokenStream.html&quot;&gt;&lt;code&gt;TokenStream&lt;/code&gt;&lt;/a&gt; is the delimited token tree following the attribute's name, not including the outer delimiters. If the attribute is written as a bare attribute name, the attribute &lt;a href=&quot;https://doc.rust-lang.org/proc_macro/struct.TokenStream.html&quot;&gt;&lt;code&gt;TokenStream&lt;/code&gt;&lt;/a&gt; is empty. The second &lt;a href=&quot;https://doc.rust-lang.org/proc_macro/struct.TokenStream.html&quot;&gt;&lt;code&gt;TokenStream&lt;/code&gt;&lt;/a&gt; is the rest of the &lt;a href=&quot;items&quot;&gt;item&lt;/a&gt; including other &lt;a href=&quot;attributes&quot;&gt;attributes&lt;/a&gt; on the &lt;a href=&quot;items&quot;&gt;item&lt;/a&gt;. The returned &lt;a href=&quot;https://doc.rust-lang.org/proc_macro/struct.TokenStream.html&quot;&gt;&lt;code&gt;TokenStream&lt;/code&gt;&lt;/a&gt; replaces the &lt;a href=&quot;items&quot;&gt;item&lt;/a&gt; with an arbitrary number of &lt;a href=&quot;items&quot;&gt;items&lt;/a&gt;. These macros cannot expand to syntax that defines new &lt;code&gt;macro_rules&lt;/code&gt; style macros.</source>
          <target state="translated">&lt;code&gt;proc_macro_attribute&lt;/code&gt; &lt;a href=&quot;attributes&quot;&gt;атрибутов&lt;/a&gt; определяются &lt;a href=&quot;visibility-and-privacy&quot;&gt;публичной &lt;/a&gt;&lt;a href=&quot;items/functions&quot;&gt;функцией&lt;/a&gt; с атрибутом proc_macro_attribute , имеющим подпись &lt;code&gt;(TokenStream, TokenStream) -&amp;gt; TokenStream&lt;/code&gt; . Первый &lt;a href=&quot;https://doc.rust-lang.org/proc_macro/struct.TokenStream.html&quot;&gt; &lt;code&gt;TokenStream&lt;/code&gt; &lt;/a&gt; - это дерево токенов с разделителями, следующее за именем атрибута, не включая внешние разделители. Если атрибут записан как простое имя атрибута, атрибут &lt;a href=&quot;https://doc.rust-lang.org/proc_macro/struct.TokenStream.html&quot;&gt; &lt;code&gt;TokenStream&lt;/code&gt; &lt;/a&gt; пуст. Второй &lt;a href=&quot;https://doc.rust-lang.org/proc_macro/struct.TokenStream.html&quot;&gt; &lt;code&gt;TokenStream&lt;/code&gt; &lt;/a&gt; является остальной частью &lt;a href=&quot;items&quot;&gt;элемента&lt;/a&gt; , включая другие &lt;a href=&quot;attributes&quot;&gt;атрибуты&lt;/a&gt; на &lt;a href=&quot;items&quot;&gt;изделии&lt;/a&gt; . Возвращенный &lt;a href=&quot;https://doc.rust-lang.org/proc_macro/struct.TokenStream.html&quot;&gt; &lt;code&gt;TokenStream&lt;/code&gt; &lt;/a&gt; заменяет &lt;a href=&quot;items&quot;&gt;элемент&lt;/a&gt; с произвольным числом&lt;a href=&quot;items&quot;&gt;предметы&lt;/a&gt; . Эти макросы не могут расширяться до синтаксиса, который определяет новые &lt;code&gt;macro_rules&lt;/code&gt; стиля macro_rules .</target>
        </trans-unit>
        <trans-unit id="e9cdb4472ce392123fa434d8e8286aab92c7c80b" translate="yes" xml:space="preserve">
          <source>Attribute-like macros</source>
          <target state="translated">Атрибутные макросы</target>
        </trans-unit>
        <trans-unit id="59290a10bc07737a4a9b4b98cbfa7a104e8da35e" translate="yes" xml:space="preserve">
          <source>Attribute-like macros are similar to custom derive macros, but instead of generating code for the &lt;code&gt;derive&lt;/code&gt; attribute, they allow you to create new attributes. They&amp;rsquo;re also more flexible: &lt;code&gt;derive&lt;/code&gt; only works for structs and enums; attributes can be applied to other items as well, such as functions. Here&amp;rsquo;s an example of using an attribute-like macro: say you have an attribute named &lt;code&gt;route&lt;/code&gt; that annotates functions when using a web application framework:</source>
          <target state="translated">Макросы, подобные атрибутам, аналогичны макросам настраиваемого получения, но вместо создания кода для атрибута &lt;code&gt;derive&lt;/code&gt; они позволяют создавать новые атрибуты. Кроме того, они более гибкие: &lt;code&gt;derive&lt;/code&gt; работает только для структур и перечислений; атрибуты могут применяться и к другим элементам, например к функциям. Вот пример использования макроса, похожего на атрибут: скажем, у вас есть атрибут с именем &lt;code&gt;route&lt;/code&gt; , который аннотирует функции при использовании инфраструктуры веб-приложения:</target>
        </trans-unit>
        <trans-unit id="ec087a512ee5c8fbe6233f1c1cc119ebd6524585" translate="yes" xml:space="preserve">
          <source>Attribute-like macros that define custom attributes usable on any item</source>
          <target state="translated">Атрибутоподобные макросы,которые определяют пользовательские атрибуты,используемые на любом элементе.</target>
        </trans-unit>
        <trans-unit id="a6652617f2c799eb11ee727b16c5646c48af6905" translate="yes" xml:space="preserve">
          <source>Attributes</source>
          <target state="translated">Attributes</target>
        </trans-unit>
        <trans-unit id="873679be0cfb954acbd8355a7b353607aec111e8" translate="yes" xml:space="preserve">
          <source>Attributes can be classified into the following kinds:</source>
          <target state="translated">Атрибуты можно разделить на следующие виды:</target>
        </trans-unit>
        <trans-unit id="f75246581fb116635159a5829418eadb80ff6d3d" translate="yes" xml:space="preserve">
          <source>Attributes may be applied to many things in the language:</source>
          <target state="translated">Атрибуты могут быть применены ко многим вещам на языке:</target>
        </trans-unit>
        <trans-unit id="54528912cd579e0bc00be1a8a68e351287624bb1" translate="yes" xml:space="preserve">
          <source>Attributes on Implementations</source>
          <target state="translated">Атрибуты на имплементации</target>
        </trans-unit>
        <trans-unit id="37b3e9d71f1e2b7a16d851acde890909a1eeac05" translate="yes" xml:space="preserve">
          <source>Attributes on Modules</source>
          <target state="translated">Атрибуты на модулях</target>
        </trans-unit>
        <trans-unit id="bd970fc906dcf4e6b3d5342f7f8f7b6b3fc07d29" translate="yes" xml:space="preserve">
          <source>Attributes on Statements</source>
          <target state="translated">Атрибуты на Выписки</target>
        </trans-unit>
        <trans-unit id="002821d69ecf6475cc851545267b8d3000e1ad75" translate="yes" xml:space="preserve">
          <source>Attributes on block expressions</source>
          <target state="translated">Атрибуты на блочных выражениях</target>
        </trans-unit>
        <trans-unit id="9c665fd3a622574987a78d02ed515c34731bae9e" translate="yes" xml:space="preserve">
          <source>Attributes on closure parameters</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9b9724999b0840379dc53e44bc7f9fc3b9f933c5" translate="yes" xml:space="preserve">
          <source>Attributes on closure parameters follow the same rules and restrictions as &lt;a href=&quot;../items/functions#attributes-on-function-parameters&quot;&gt;regular function parameters&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ceeb23e9fab4cfc5da27d608e1b53f610954cf73" translate="yes" xml:space="preserve">
          <source>Attributes on extern blocks</source>
          <target state="translated">Атрибуты на внешних блоках</target>
        </trans-unit>
        <trans-unit id="2b100159215337704a6b1e09760f5eccf7526a5d" translate="yes" xml:space="preserve">
          <source>Attributes on extern function parameters follow the same rules and restrictions as &lt;a href=&quot;functions#attributes-on-function-parameters&quot;&gt;regular function parameters&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="59c13f89c0293ca7012e37e58c92591846eac3f7" translate="yes" xml:space="preserve">
          <source>Attributes on function parameters</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ed27ab14062c4e9a4e3408735f20ce008b94ed1f" translate="yes" xml:space="preserve">
          <source>Attributes on function pointer parameters</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d19964d112392f9f4c6dafbc3caa5ef3b3d5eb10" translate="yes" xml:space="preserve">
          <source>Attributes on function pointer parameters follow the same rules and restrictions as &lt;a href=&quot;../items/functions#attributes-on-function-parameters&quot;&gt;regular function parameters&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3cccaf98e2daf69778514e782644b524ef8bcdb7" translate="yes" xml:space="preserve">
          <source>Attributes on functions</source>
          <target state="translated">Атрибуты функций</target>
        </trans-unit>
        <trans-unit id="05e9060a13a0e0d138adc8680df67a664480dcc8" translate="yes" xml:space="preserve">
          <source>Attributes on match arms</source>
          <target state="translated">Атрибуты на спичечных руках</target>
        </trans-unit>
        <trans-unit id="2af6ac2f621f1343b06367e7a182dd005ff55bf7" translate="yes" xml:space="preserve">
          <source>Attributes on method parameters</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="09d4e80c9597ea7a33de2f4472d2c8f5b6ac76e0" translate="yes" xml:space="preserve">
          <source>Attributes on method parameters follow the same rules and restrictions as &lt;a href=&quot;functions#attributes-on-function-parameters&quot;&gt;regular function parameters&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4692270821bce03e7c9c56f2250b4d84c0ed4e73" translate="yes" xml:space="preserve">
          <source>Augments &lt;code&gt;AllocErr&lt;/code&gt; with a CapacityOverflow variant.</source>
          <target state="translated">Дополняет &lt;code&gt;AllocErr&lt;/code&gt; вариантом CapacityOverflow.</target>
        </trans-unit>
        <trans-unit id="18a0388aaf485c373d9fa2601ae76a1e2a8efdf4" translate="yes" xml:space="preserve">
          <source>Austin Group Bugzilla</source>
          <target state="translated">Austin Group Bugzilla</target>
        </trans-unit>
        <trans-unit id="e84cdcfde23e335b70dccbea7484975e25932774" translate="yes" xml:space="preserve">
          <source>Auto Trait Implementations</source>
          <target state="translated">Автоматическое управление трейтом</target>
        </trans-unit>
        <trans-unit id="3210ce5fd6c71ac203dc3858abcda035931c425a" translate="yes" xml:space="preserve">
          <source>Auto implementors</source>
          <target state="translated">Автоисполнители</target>
        </trans-unit>
        <trans-unit id="883a358e80c549bb53d94b1393e3b00efd025f86" translate="yes" xml:space="preserve">
          <source>Auto traits</source>
          <target state="translated">Автоматические черты</target>
        </trans-unit>
        <trans-unit id="907a84f140f8fccdc36e6967fab33354d93f68e0" translate="yes" xml:space="preserve">
          <source>Auto traits can also have negative implementations, shown as &lt;code&gt;impl !AutoTrait for T&lt;/code&gt; in the standard library documentation, that override the automatic implementations. For example &lt;code&gt;*mut T&lt;/code&gt; has a negative implementation of &lt;code&gt;Send&lt;/code&gt;, and so &lt;code&gt;*mut T&lt;/code&gt; is not &lt;code&gt;Send&lt;/code&gt;, even if &lt;code&gt;T&lt;/code&gt; is. There is currently no stable way to specify additional negative implementations; they exist only in the standard library.</source>
          <target state="translated">Автоматические свойства также могут иметь отрицательные реализации, показанные как &lt;code&gt;impl !AutoTrait for T&lt;/code&gt; в документации стандартной библиотеки, которые отменяют автоматические реализации. Например &lt;code&gt;*mut T&lt;/code&gt; имеет отрицательную реализацию &lt;code&gt;Send&lt;/code&gt; , и так &lt;code&gt;*mut T&lt;/code&gt; не &lt;code&gt;Send&lt;/code&gt; , даже если &lt;code&gt;T&lt;/code&gt; есть. В настоящее время нет стабильного способа указать дополнительные отрицательные реализации; они существуют только в стандартной библиотеке.</target>
        </trans-unit>
        <trans-unit id="eed6125b479d147f9973b57bfcd959c6cdf11e7c" translate="yes" xml:space="preserve">
          <source>Auto traits cannot have methods or associated items. For more information see the &lt;a href=&quot;https://github.com/rust-lang/rfcs/blob/master/text/0019-opt-in-builtin-traits.md&quot;&gt;opt-in builtin traits RFC&lt;/a&gt;.</source>
          <target state="translated">Авто-черты не могут иметь методов или связанных элементов. Дополнительные сведения см. В &lt;a href=&quot;https://github.com/rust-lang/rfcs/blob/master/text/0019-opt-in-builtin-traits.md&quot;&gt;RFC встроенных свойств opt-in&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="589d3531f6899aa76d5a037b26ecc86cf31af6da" translate="yes" xml:space="preserve">
          <source>Auto traits may be added as an additional bound to any &lt;a href=&quot;types/trait-object&quot;&gt;trait object&lt;/a&gt;, even though normally only one trait is allowed. For instance, &lt;code&gt;Box&amp;lt;dyn Debug + Send + UnwindSafe&amp;gt;&lt;/code&gt; is a valid type.</source>
          <target state="translated">Автоматические черты могут быть добавлены как дополнительная привязка к любому &lt;a href=&quot;types/trait-object&quot;&gt;объекту черты&lt;/a&gt; , даже если обычно допускается только одна черта. Например, допустимым типом является &lt;code&gt;Box&amp;lt;dyn Debug + Send + UnwindSafe&amp;gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7ab019d8f27eff675f0469b46eedbbd5bc764f0c" translate="yes" xml:space="preserve">
          <source>Auto traits such as Send and Sync are an exception to this rule: It's possible to have bounds of one non-builtin trait, plus any number of auto traits. For example, the following compiles correctly:</source>
          <target state="translated">Такие автотрейты,как Send и Sync,являются исключением из этого правила:можно иметь границы одного нестрояного трейта плюс любое количество автотрейтов.Например,следующие компилируются корректно:</target>
        </trans-unit>
        <trans-unit id="291824a57cec52e3b37ba600a0c8891145191849" translate="yes" xml:space="preserve">
          <source>Auto-&lt;code&gt;deref&lt;/code&gt; is undesirable; for example, distinguishing between methods on a smart pointer itself and the pointer's referent</source>
          <target state="translated">Автомототехника &lt;code&gt;deref&lt;/code&gt; нежелательно; например, различение методов на самом умном указателе и референте указателя</target>
        </trans-unit>
        <trans-unit id="07a06ac20697a76a3d6c77f425115fda11438cdd" translate="yes" xml:space="preserve">
          <source>Automatic Formatting with &lt;code id=&quot;automatic-formatting-with-rustfmt&quot;&gt;rustfmt&lt;/code&gt;</source>
          <target state="translated">Автоматическое форматирование с помощью &lt;code id=&quot;automatic-formatting-with-rustfmt&quot;&gt;rustfmt&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="fd22060c7b367de18d29110de1ffaa7a8381ad30" translate="yes" xml:space="preserve">
          <source>Available features</source>
          <target state="translated">Доступные особенности</target>
        </trans-unit>
        <trans-unit id="25bea30bca4696d831be0e14c1144f604b2efac9" translate="yes" xml:space="preserve">
          <source>Awesome! We now have a simple web server in approximately 40 lines of Rust code that responds to one request with a page of content and responds to all other requests with a 404 response.</source>
          <target state="translated">Потрясающе! Теперь у нас есть простой веб-сервер примерно в 40 строках кода Rust,который отвечает на один запрос содержимым страницы и отвечает на все остальные запросы ответом 404.</target>
        </trans-unit>
        <trans-unit id="799c6a1aafdeb5752f0a6da17b30526204336545" translate="yes" xml:space="preserve">
          <source>Awesome! With one tiny final tweak, we will finish the guessing game. Recall that the program is still printing the secret number. That worked well for testing, but it ruins the game. Let&amp;rsquo;s delete the &lt;code&gt;println!&lt;/code&gt; that outputs the secret number. Listing 2-6 shows the final code.</source>
          <target state="translated">Потрясающие! Сделав одну крошечную последнюю настройку, мы закончим игру в угадывание. Напомним, что программа все еще печатает секретное число. Это хорошо сработало для тестирования, но испортило игру. Давайте удалить &lt;code&gt;println!&lt;/code&gt; который выводит секретный номер. В листинге 2-6 показан окончательный код.</target>
        </trans-unit>
        <trans-unit id="358de401329e3394893b21243300f3a3bf6b4d17" translate="yes" xml:space="preserve">
          <source>B-Trees represent a fundamental compromise between cache-efficiency and actually minimizing the amount of work performed in a search. In theory, a binary search tree (BST) is the optimal choice for a sorted map, as a perfectly balanced BST performs the theoretical minimum amount of comparisons necessary to find an element (log&lt;sub&gt;2&lt;/sub&gt;n). However, in practice the way this is done is &lt;em&gt;very&lt;/em&gt; inefficient for modern computer architectures. In particular, every element is stored in its own individually heap-allocated node. This means that every single insertion triggers a heap-allocation, and every single comparison should be a cache-miss. Since these are both notably expensive things to do in practice, we are forced to at very least reconsider the BST strategy.</source>
          <target state="translated">B-деревья представляют собой фундаментальный компромисс между эффективностью кеширования и фактической минимизацией объема работы, выполняемой при поиске. Теоретически двоичное дерево поиска (BST) является оптимальным выбором для отсортированной карты, так как идеально сбалансированный BST выполняет теоретически минимальное количество сравнений, необходимое для поиска элемента (log &lt;sub&gt;2&lt;/sub&gt; n). Однако на практике это &lt;em&gt;очень&lt;/em&gt; неэффективно для современных компьютерных архитектур. В частности, каждый элемент хранится в отдельном узле, выделенном в куче. Это означает, что каждая отдельная вставка запускает выделение кучи, и каждое отдельное сравнение должно быть промахом кеширования. Поскольку на практике это очень дорогое удовольствие, мы вынуждены, по крайней мере, пересмотреть стратегию BST.</target>
        </trans-unit>
        <trans-unit id="4ce046eb7e16ef9995c1ff852988df751464fa48" translate="yes" xml:space="preserve">
          <source>BIN_DIGIT : [&lt;code&gt;0&lt;/code&gt;-&lt;code&gt;1&lt;/code&gt;]</source>
          <target state="translated">BIN_DIGIT: [ &lt;code&gt;0&lt;/code&gt; - &lt;code&gt;1&lt;/code&gt; ]</target>
        </trans-unit>
        <trans-unit id="93c309eceddcd432100b37d2f21aed97ad5516a1" translate="yes" xml:space="preserve">
          <source>BIN_LITERAL :</source>
          <target state="translated">BIN_LITERAL :</target>
        </trans-unit>
        <trans-unit id="1ce23e42f8a0fadda89f03bff4138edc76257e9f" translate="yes" xml:space="preserve">
          <source>BLOCK_COMMENT</source>
          <target state="translated">BLOCK_COMMENT</target>
        </trans-unit>
        <trans-unit id="54d41dd6d7f607cbfdbd93df26df009dd384ea37" translate="yes" xml:space="preserve">
          <source>BLOCK_COMMENT :</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="46a2a0792f35fba20ff9af816bd7d67867d91ee5" translate="yes" xml:space="preserve">
          <source>BOOLEAN_LITERAL</source>
          <target state="translated">BOOLEAN_LITERAL</target>
        </trans-unit>
        <trans-unit id="984b539364047c18d12aa2a5107f4ca7034f1745" translate="yes" xml:space="preserve">
          <source>BOOLEAN_LITERAL :</source>
          <target state="translated">BOOLEAN_LITERAL :</target>
        </trans-unit>
        <trans-unit id="25ed99c15ff33b077d8ef4f89cfb12043f799e5c" translate="yes" xml:space="preserve">
          <source>BTreeMap</source>
          <target state="translated">BTreeMap</target>
        </trans-unit>
        <trans-unit id="14b812dd3cb5eae3767a2df53640bea358a44ec3" translate="yes" xml:space="preserve">
          <source>BTreeMap::append</source>
          <target state="translated">BTreeMap::append</target>
        </trans-unit>
        <trans-unit id="4439b2dd76bd007a7ee702af3eca0f027a45eb09" translate="yes" xml:space="preserve">
          <source>BTreeMap::borrow</source>
          <target state="translated">BTreeMap::borrow</target>
        </trans-unit>
        <trans-unit id="a411a7ebcb50db356ed987a9d5f1ea3e6fb40efd" translate="yes" xml:space="preserve">
          <source>BTreeMap::borrow_mut</source>
          <target state="translated">BTreeMap::borrow_mut</target>
        </trans-unit>
        <trans-unit id="0e1837335635833d079465e2a07ece32097ef9ee" translate="yes" xml:space="preserve">
          <source>BTreeMap::clamp</source>
          <target state="translated">BTreeMap::clamp</target>
        </trans-unit>
        <trans-unit id="a5095900a69512f07d67a4318ed72ed754b7ec9a" translate="yes" xml:space="preserve">
          <source>BTreeMap::clear</source>
          <target state="translated">BTreeMap::clear</target>
        </trans-unit>
        <trans-unit id="d9dc0be9a162cd4c9a8d0d87ef461b431cc2996f" translate="yes" xml:space="preserve">
          <source>BTreeMap::clone</source>
          <target state="translated">BTreeMap::clone</target>
        </trans-unit>
        <trans-unit id="b18aa414095cedffcf379ff71fa52f0f3e5a2e30" translate="yes" xml:space="preserve">
          <source>BTreeMap::clone_from</source>
          <target state="translated">BTreeMap::clone_from</target>
        </trans-unit>
        <trans-unit id="94cc1d51e045cecb444cb20cb07a89d16ef1abae" translate="yes" xml:space="preserve">
          <source>BTreeMap::clone_into</source>
          <target state="translated">BTreeMap::clone_into</target>
        </trans-unit>
        <trans-unit id="7fc5895f7f2221a66d3e8ff613cbb9e54a398512" translate="yes" xml:space="preserve">
          <source>BTreeMap::cmp</source>
          <target state="translated">BTreeMap::cmp</target>
        </trans-unit>
        <trans-unit id="10f80450d5f9791627fc6f70e8eea8d607e5abc1" translate="yes" xml:space="preserve">
          <source>BTreeMap::contains_key</source>
          <target state="translated">BTreeMap::contains_key</target>
        </trans-unit>
        <trans-unit id="237ebd61fd35b922ed92337aaeb092096989c551" translate="yes" xml:space="preserve">
          <source>BTreeMap::default</source>
          <target state="translated">BTreeMap::default</target>
        </trans-unit>
        <trans-unit id="67360895fa8faeb3288ff2a48f56ac5fb63f6cfa" translate="yes" xml:space="preserve">
          <source>BTreeMap::drop</source>
          <target state="translated">BTreeMap::drop</target>
        </trans-unit>
        <trans-unit id="e35986d9fdbf3de52b6c707270d8af046337a4b7" translate="yes" xml:space="preserve">
          <source>BTreeMap::entry</source>
          <target state="translated">BTreeMap::entry</target>
        </trans-unit>
        <trans-unit id="1fd856b6f3486469ed5b9716d4c0ef16fd26570a" translate="yes" xml:space="preserve">
          <source>BTreeMap::eq</source>
          <target state="translated">BTreeMap::eq</target>
        </trans-unit>
        <trans-unit id="2eb6b59d7803ce34a4aebcb1a5cebd29ebb2ace1" translate="yes" xml:space="preserve">
          <source>BTreeMap::extend</source>
          <target state="translated">BTreeMap::extend</target>
        </trans-unit>
        <trans-unit id="14a4894c2a33cba6f17b28aab882b15d8fa0507e" translate="yes" xml:space="preserve">
          <source>BTreeMap::fmt</source>
          <target state="translated">BTreeMap::fmt</target>
        </trans-unit>
        <trans-unit id="f8ff830626694a395da9bcdf07413636ef382d2a" translate="yes" xml:space="preserve">
          <source>BTreeMap::from</source>
          <target state="translated">BTreeMap::from</target>
        </trans-unit>
        <trans-unit id="40d5df351e6a78b82beed9049802e2600890cdef" translate="yes" xml:space="preserve">
          <source>BTreeMap::from_iter</source>
          <target state="translated">BTreeMap::from_iter</target>
        </trans-unit>
        <trans-unit id="42bc9380f48558951feaee861f324b3e97cc339c" translate="yes" xml:space="preserve">
          <source>BTreeMap::ge</source>
          <target state="translated">BTreeMap::ge</target>
        </trans-unit>
        <trans-unit id="fdc4bec6666f5d3bd604897331fbae31d76e02c5" translate="yes" xml:space="preserve">
          <source>BTreeMap::get</source>
          <target state="translated">BTreeMap::get</target>
        </trans-unit>
        <trans-unit id="10123fe58d4d51981db653bb17bb2c5bd1739f48" translate="yes" xml:space="preserve">
          <source>BTreeMap::get_key_value</source>
          <target state="translated">BTreeMap::get_key_value</target>
        </trans-unit>
        <trans-unit id="77ed844b0571d2308549c11d94f75218d5fc647d" translate="yes" xml:space="preserve">
          <source>BTreeMap::get_mut</source>
          <target state="translated">BTreeMap::get_mut</target>
        </trans-unit>
        <trans-unit id="5aeca596bd768adcad438b3384e1977cf6475276" translate="yes" xml:space="preserve">
          <source>BTreeMap::gt</source>
          <target state="translated">BTreeMap::gt</target>
        </trans-unit>
        <trans-unit id="aef92c85a8fd215fe067e91d2cc54253d395041e" translate="yes" xml:space="preserve">
          <source>BTreeMap::hash</source>
          <target state="translated">BTreeMap::hash</target>
        </trans-unit>
        <trans-unit id="cf9f5d8139a53420363c542bee60960cfdf4b73f" translate="yes" xml:space="preserve">
          <source>BTreeMap::hash_slice</source>
          <target state="translated">BTreeMap::hash_slice</target>
        </trans-unit>
        <trans-unit id="9d0f58d76739deb0afae24d930afc89e886727c1" translate="yes" xml:space="preserve">
          <source>BTreeMap::index</source>
          <target state="translated">BTreeMap::index</target>
        </trans-unit>
        <trans-unit id="495b083c76694857a7d488aae7997ecc9b65b8fd" translate="yes" xml:space="preserve">
          <source>BTreeMap::insert</source>
          <target state="translated">BTreeMap::insert</target>
        </trans-unit>
        <trans-unit id="df183dd97d9b53936c9da9b18c544dcca3159f96" translate="yes" xml:space="preserve">
          <source>BTreeMap::into</source>
          <target state="translated">BTreeMap::into</target>
        </trans-unit>
        <trans-unit id="fc4dae35af80d2a787e9d9736c90c00c41315ce5" translate="yes" xml:space="preserve">
          <source>BTreeMap::into_iter</source>
          <target state="translated">BTreeMap::into_iter</target>
        </trans-unit>
        <trans-unit id="34464fef785cdf817cc72448c6950077bd889a22" translate="yes" xml:space="preserve">
          <source>BTreeMap::is_empty</source>
          <target state="translated">BTreeMap::is_empty</target>
        </trans-unit>
        <trans-unit id="f0cc7817b62e10040c3cb5b80461b8e39c5f0f79" translate="yes" xml:space="preserve">
          <source>BTreeMap::iter</source>
          <target state="translated">BTreeMap::iter</target>
        </trans-unit>
        <trans-unit id="db8aca8da8288f53fcb308f1bc4fd2b4cacd2358" translate="yes" xml:space="preserve">
          <source>BTreeMap::iter_mut</source>
          <target state="translated">BTreeMap::iter_mut</target>
        </trans-unit>
        <trans-unit id="17e2b2189c6d71bc1225646a44b2dd0dedd8f47e" translate="yes" xml:space="preserve">
          <source>BTreeMap::keys</source>
          <target state="translated">BTreeMap::keys</target>
        </trans-unit>
        <trans-unit id="9d8ea9a92f24bfb8408ae08918cf32d255567986" translate="yes" xml:space="preserve">
          <source>BTreeMap::le</source>
          <target state="translated">BTreeMap::le</target>
        </trans-unit>
        <trans-unit id="69fcce80124f37da2a3264b3eb42f4416e80e515" translate="yes" xml:space="preserve">
          <source>BTreeMap::len</source>
          <target state="translated">BTreeMap::len</target>
        </trans-unit>
        <trans-unit id="9d226dd3e31bc04059d6780da00c779d71a0c07b" translate="yes" xml:space="preserve">
          <source>BTreeMap::lt</source>
          <target state="translated">BTreeMap::lt</target>
        </trans-unit>
        <trans-unit id="28cb2cc6fd2d128843e6d248dab95763d1010e94" translate="yes" xml:space="preserve">
          <source>BTreeMap::max</source>
          <target state="translated">BTreeMap::max</target>
        </trans-unit>
        <trans-unit id="e204c8d42ea76d6a7764ea9e58274fe5c3bb002d" translate="yes" xml:space="preserve">
          <source>BTreeMap::min</source>
          <target state="translated">BTreeMap::min</target>
        </trans-unit>
        <trans-unit id="b1f505e6c5b1bc5d067a0962eaa8081602c15a7a" translate="yes" xml:space="preserve">
          <source>BTreeMap::ne</source>
          <target state="translated">BTreeMap::ne</target>
        </trans-unit>
        <trans-unit id="553eafd890c40ffaf003fe540a734e36e0e18621" translate="yes" xml:space="preserve">
          <source>BTreeMap::new</source>
          <target state="translated">BTreeMap::new</target>
        </trans-unit>
        <trans-unit id="145a5aeffe19ab72f79646e0207cf635764ce346" translate="yes" xml:space="preserve">
          <source>BTreeMap::partial_cmp</source>
          <target state="translated">BTreeMap::partial_cmp</target>
        </trans-unit>
        <trans-unit id="db1a963168ea048f3f16233197ab263e60b2b507" translate="yes" xml:space="preserve">
          <source>BTreeMap::range</source>
          <target state="translated">BTreeMap::range</target>
        </trans-unit>
        <trans-unit id="3fee919f6744bdc9b2c87f1284d03bd737c587e9" translate="yes" xml:space="preserve">
          <source>BTreeMap::range_mut</source>
          <target state="translated">BTreeMap::range_mut</target>
        </trans-unit>
        <trans-unit id="f730581dfe02c1cd76fc7cd5f47e7e1ec7741713" translate="yes" xml:space="preserve">
          <source>BTreeMap::remove</source>
          <target state="translated">BTreeMap::remove</target>
        </trans-unit>
        <trans-unit id="a37cec31f9d8447344a2cb11b02572d5369eaecb" translate="yes" xml:space="preserve">
          <source>BTreeMap::split_off</source>
          <target state="translated">BTreeMap::split_off</target>
        </trans-unit>
        <trans-unit id="dd1d37326d92e085a2131397045e5968a461a29d" translate="yes" xml:space="preserve">
          <source>BTreeMap::to_owned</source>
          <target state="translated">BTreeMap::to_owned</target>
        </trans-unit>
        <trans-unit id="f4b12905aac1d13f63c54fa99e15b6d767c0949a" translate="yes" xml:space="preserve">
          <source>BTreeMap::try_from</source>
          <target state="translated">BTreeMap::try_from</target>
        </trans-unit>
        <trans-unit id="8714974f74a34a38551f441ede21c0f7c7518766" translate="yes" xml:space="preserve">
          <source>BTreeMap::try_into</source>
          <target state="translated">BTreeMap::try_into</target>
        </trans-unit>
        <trans-unit id="a562c087f2e1443045e2342f53c040d13fff0500" translate="yes" xml:space="preserve">
          <source>BTreeMap::type_id</source>
          <target state="translated">BTreeMap::type_id</target>
        </trans-unit>
        <trans-unit id="fef95975d5290dbd397d0e8018f6118b5b3445f8" translate="yes" xml:space="preserve">
          <source>BTreeMap::values</source>
          <target state="translated">BTreeMap::values</target>
        </trans-unit>
        <trans-unit id="b2e013070087a41fefec42e8c8812a309f157c48" translate="yes" xml:space="preserve">
          <source>BTreeMap::values_mut</source>
          <target state="translated">BTreeMap::values_mut</target>
        </trans-unit>
        <trans-unit id="529df1988796f2371c28af38a10631626e30c033" translate="yes" xml:space="preserve">
          <source>BTreeSet</source>
          <target state="translated">BTreeSet</target>
        </trans-unit>
        <trans-unit id="8863be2c232d70a5eeb4560459b4be5b2c0073a8" translate="yes" xml:space="preserve">
          <source>BTreeSet::append</source>
          <target state="translated">BTreeSet::append</target>
        </trans-unit>
        <trans-unit id="208528633622bb579ebc99572c1cd5b23c0ff3fe" translate="yes" xml:space="preserve">
          <source>BTreeSet::bitand</source>
          <target state="translated">BTreeSet::bitand</target>
        </trans-unit>
        <trans-unit id="8c7f6d7d0bd709c67b308f34e3fdea1982987576" translate="yes" xml:space="preserve">
          <source>BTreeSet::bitor</source>
          <target state="translated">BTreeSet::bitor</target>
        </trans-unit>
        <trans-unit id="b50a2f00b4df89c4fc2d8b38a2151e87a882ff0b" translate="yes" xml:space="preserve">
          <source>BTreeSet::bitxor</source>
          <target state="translated">BTreeSet::bitxor</target>
        </trans-unit>
        <trans-unit id="cccc4bace80a38b5837fc997cc5c49754d796ac4" translate="yes" xml:space="preserve">
          <source>BTreeSet::borrow</source>
          <target state="translated">BTreeSet::borrow</target>
        </trans-unit>
        <trans-unit id="c3906f6d078061570593f2fe7b73fa2840328771" translate="yes" xml:space="preserve">
          <source>BTreeSet::borrow_mut</source>
          <target state="translated">BTreeSet::borrow_mut</target>
        </trans-unit>
        <trans-unit id="4aa030ae00992ccd9a53652df9153409be56a2a2" translate="yes" xml:space="preserve">
          <source>BTreeSet::clamp</source>
          <target state="translated">BTreeSet::clamp</target>
        </trans-unit>
        <trans-unit id="7dbd4b9a7ec2f778cf457d4c27e677b1357aa7da" translate="yes" xml:space="preserve">
          <source>BTreeSet::clear</source>
          <target state="translated">BTreeSet::clear</target>
        </trans-unit>
        <trans-unit id="5b30f459964be9100787e5939f482cd8d7073397" translate="yes" xml:space="preserve">
          <source>BTreeSet::clone</source>
          <target state="translated">BTreeSet::clone</target>
        </trans-unit>
        <trans-unit id="050795ce2f3842fb14df3b7b6623ddb813ac2ad6" translate="yes" xml:space="preserve">
          <source>BTreeSet::clone_from</source>
          <target state="translated">BTreeSet::clone_from</target>
        </trans-unit>
        <trans-unit id="53b99dc8a6c6498122bd0b00e8114abe2667c8af" translate="yes" xml:space="preserve">
          <source>BTreeSet::clone_into</source>
          <target state="translated">BTreeSet::clone_into</target>
        </trans-unit>
        <trans-unit id="de2ebfb73a4bfaed7ca14354db78235b93dbbcb9" translate="yes" xml:space="preserve">
          <source>BTreeSet::cmp</source>
          <target state="translated">BTreeSet::cmp</target>
        </trans-unit>
        <trans-unit id="3e582a8879cbba7048152fe7baf6d319ff38bc16" translate="yes" xml:space="preserve">
          <source>BTreeSet::contains</source>
          <target state="translated">BTreeSet::contains</target>
        </trans-unit>
        <trans-unit id="21aa5487bfe6b638ff9a362eaa67cb633fc82867" translate="yes" xml:space="preserve">
          <source>BTreeSet::default</source>
          <target state="translated">BTreeSet::default</target>
        </trans-unit>
        <trans-unit id="d7c44959c458f0838dfab77ed6b6f2add8735a14" translate="yes" xml:space="preserve">
          <source>BTreeSet::difference</source>
          <target state="translated">BTreeSet::difference</target>
        </trans-unit>
        <trans-unit id="16f9dc4e686355d372b64a80e877507f0084b34a" translate="yes" xml:space="preserve">
          <source>BTreeSet::eq</source>
          <target state="translated">BTreeSet::eq</target>
        </trans-unit>
        <trans-unit id="9edee760d67dfee35cacd64d97c0b93bcecc3eb7" translate="yes" xml:space="preserve">
          <source>BTreeSet::extend</source>
          <target state="translated">BTreeSet::extend</target>
        </trans-unit>
        <trans-unit id="afc2d0e53bf4c5f63abce2f83b8f542897205aac" translate="yes" xml:space="preserve">
          <source>BTreeSet::fmt</source>
          <target state="translated">BTreeSet::fmt</target>
        </trans-unit>
        <trans-unit id="50633916fcf03b37e42d17b8960dc21b40ef24a7" translate="yes" xml:space="preserve">
          <source>BTreeSet::from</source>
          <target state="translated">BTreeSet::from</target>
        </trans-unit>
        <trans-unit id="caf6d0db82051ce20ec56dd44cb0a17ec0b98d23" translate="yes" xml:space="preserve">
          <source>BTreeSet::from_iter</source>
          <target state="translated">BTreeSet::from_iter</target>
        </trans-unit>
        <trans-unit id="be2acc08fadae340b24bbbb5601dcd11b43af4ff" translate="yes" xml:space="preserve">
          <source>BTreeSet::ge</source>
          <target state="translated">BTreeSet::ge</target>
        </trans-unit>
        <trans-unit id="eebfcd72f45c81fa6bcc82833412cbba7e8dc9f6" translate="yes" xml:space="preserve">
          <source>BTreeSet::get</source>
          <target state="translated">BTreeSet::get</target>
        </trans-unit>
        <trans-unit id="692fcfa52c7940ed1e980094be254853ea4f2c35" translate="yes" xml:space="preserve">
          <source>BTreeSet::gt</source>
          <target state="translated">BTreeSet::gt</target>
        </trans-unit>
        <trans-unit id="0546ef8f63c560e2610c71f5ad1ae889cfa00795" translate="yes" xml:space="preserve">
          <source>BTreeSet::hash</source>
          <target state="translated">BTreeSet::hash</target>
        </trans-unit>
        <trans-unit id="4f6fe8cde85490c116cbac4ed558e1916281d86a" translate="yes" xml:space="preserve">
          <source>BTreeSet::hash_slice</source>
          <target state="translated">BTreeSet::hash_slice</target>
        </trans-unit>
        <trans-unit id="eda956eff955ffd9727eb53f2bf7e0715817c65d" translate="yes" xml:space="preserve">
          <source>BTreeSet::insert</source>
          <target state="translated">BTreeSet::insert</target>
        </trans-unit>
        <trans-unit id="2ec6cd19695748bdc3218a5649d6ac291b66845a" translate="yes" xml:space="preserve">
          <source>BTreeSet::intersection</source>
          <target state="translated">BTreeSet::intersection</target>
        </trans-unit>
        <trans-unit id="d885d81e267a989f9b6f96d27d81a920eec34664" translate="yes" xml:space="preserve">
          <source>BTreeSet::into</source>
          <target state="translated">BTreeSet::into</target>
        </trans-unit>
        <trans-unit id="f09a0e4a6b10a390e2f04fd66332a740593fc953" translate="yes" xml:space="preserve">
          <source>BTreeSet::into_iter</source>
          <target state="translated">BTreeSet::into_iter</target>
        </trans-unit>
        <trans-unit id="a2120b284c22116b26329e55b63c0619a0f8641f" translate="yes" xml:space="preserve">
          <source>BTreeSet::is_disjoint</source>
          <target state="translated">BTreeSet::is_disjoint</target>
        </trans-unit>
        <trans-unit id="fa3982b7c70f77cdc4a183838b7ec4738fe0c535" translate="yes" xml:space="preserve">
          <source>BTreeSet::is_empty</source>
          <target state="translated">BTreeSet::is_empty</target>
        </trans-unit>
        <trans-unit id="f1e3ee85ccb9602474d41d5d154e3e8901defc32" translate="yes" xml:space="preserve">
          <source>BTreeSet::is_subset</source>
          <target state="translated">BTreeSet::is_subset</target>
        </trans-unit>
        <trans-unit id="56a933bbd8f86feb814db247df53b23e17a9695d" translate="yes" xml:space="preserve">
          <source>BTreeSet::is_superset</source>
          <target state="translated">BTreeSet::is_superset</target>
        </trans-unit>
        <trans-unit id="b5818b3b23dd28b80dc81cc819a86f1ec187aacf" translate="yes" xml:space="preserve">
          <source>BTreeSet::iter</source>
          <target state="translated">BTreeSet::iter</target>
        </trans-unit>
        <trans-unit id="de70e88d73a501b174fd29598eceebcee11a3887" translate="yes" xml:space="preserve">
          <source>BTreeSet::le</source>
          <target state="translated">BTreeSet::le</target>
        </trans-unit>
        <trans-unit id="d6f9cf6208fd574420dfb2b2c0da01ae4ce09d55" translate="yes" xml:space="preserve">
          <source>BTreeSet::len</source>
          <target state="translated">BTreeSet::len</target>
        </trans-unit>
        <trans-unit id="b1797fe67e7fb20ec6e3d268d0239e6f0a7e8a35" translate="yes" xml:space="preserve">
          <source>BTreeSet::lt</source>
          <target state="translated">BTreeSet::lt</target>
        </trans-unit>
        <trans-unit id="a9e0d4eb0cfb5c71cb33c6469839efbbe2cc32b4" translate="yes" xml:space="preserve">
          <source>BTreeSet::max</source>
          <target state="translated">BTreeSet::max</target>
        </trans-unit>
        <trans-unit id="05e2ada4eca69c113c843b5a4bf4e82b6cbab803" translate="yes" xml:space="preserve">
          <source>BTreeSet::min</source>
          <target state="translated">BTreeSet::min</target>
        </trans-unit>
        <trans-unit id="1bf7816f409ee91ea7b933df2aa5aafb248eb221" translate="yes" xml:space="preserve">
          <source>BTreeSet::ne</source>
          <target state="translated">BTreeSet::ne</target>
        </trans-unit>
        <trans-unit id="eaf3ecdf9b29068bb6526653c7887b6ce53f95db" translate="yes" xml:space="preserve">
          <source>BTreeSet::new</source>
          <target state="translated">BTreeSet::new</target>
        </trans-unit>
        <trans-unit id="df8c5a54c5b8f9c4c785c5ef82c145a8f51964cb" translate="yes" xml:space="preserve">
          <source>BTreeSet::partial_cmp</source>
          <target state="translated">BTreeSet::partial_cmp</target>
        </trans-unit>
        <trans-unit id="d87bbd755881f1e9919b94d6de0e6bf8ffad49ba" translate="yes" xml:space="preserve">
          <source>BTreeSet::range</source>
          <target state="translated">BTreeSet::range</target>
        </trans-unit>
        <trans-unit id="ef12ebd2434d1cb833ec3822d788df805d7d9bd6" translate="yes" xml:space="preserve">
          <source>BTreeSet::remove</source>
          <target state="translated">BTreeSet::remove</target>
        </trans-unit>
        <trans-unit id="9478913c250333ed4078096ba5b68c78bc2a2420" translate="yes" xml:space="preserve">
          <source>BTreeSet::replace</source>
          <target state="translated">BTreeSet::replace</target>
        </trans-unit>
        <trans-unit id="3c5930911fa948ea3f0f63bb1262c5e03b59d4c8" translate="yes" xml:space="preserve">
          <source>BTreeSet::split_off</source>
          <target state="translated">BTreeSet::split_off</target>
        </trans-unit>
        <trans-unit id="c4362726060659abf8310f7f4e795bc37b50e1bc" translate="yes" xml:space="preserve">
          <source>BTreeSet::sub</source>
          <target state="translated">BTreeSet::sub</target>
        </trans-unit>
        <trans-unit id="1dc28627821fcb677e88cc0779199b1f7545d0d5" translate="yes" xml:space="preserve">
          <source>BTreeSet::symmetric_difference</source>
          <target state="translated">BTreeSet::symmetric_difference</target>
        </trans-unit>
        <trans-unit id="2164e4022af6db54cb98c455e4d65521424dc945" translate="yes" xml:space="preserve">
          <source>BTreeSet::take</source>
          <target state="translated">BTreeSet::take</target>
        </trans-unit>
        <trans-unit id="976d0d251360ff452f9cb215b1b7bd9b85411230" translate="yes" xml:space="preserve">
          <source>BTreeSet::to_owned</source>
          <target state="translated">BTreeSet::to_owned</target>
        </trans-unit>
        <trans-unit id="0992e1b4495c890673b5468165634f32bea3f77d" translate="yes" xml:space="preserve">
          <source>BTreeSet::try_from</source>
          <target state="translated">BTreeSet::try_from</target>
        </trans-unit>
        <trans-unit id="00828429015178852a18ee4ff94e0453f5ca2ad3" translate="yes" xml:space="preserve">
          <source>BTreeSet::try_into</source>
          <target state="translated">BTreeSet::try_into</target>
        </trans-unit>
        <trans-unit id="6292b066b8d0a77ef6636bc177c940749dde0313" translate="yes" xml:space="preserve">
          <source>BTreeSet::type_id</source>
          <target state="translated">BTreeSet::type_id</target>
        </trans-unit>
        <trans-unit id="a20d276d5c8ff0b1126047f789b8548caf5f132d" translate="yes" xml:space="preserve">
          <source>BTreeSet::union</source>
          <target state="translated">BTreeSet::union</target>
        </trans-unit>
        <trans-unit id="a211a3e292d0c406efdf997cbec3abf1f2bc9197" translate="yes" xml:space="preserve">
          <source>BYTE_ESCAPE :</source>
          <target state="translated">BYTE_ESCAPE :</target>
        </trans-unit>
        <trans-unit id="e985813955ef288c8ead5994a2092542fb8c5bfb" translate="yes" xml:space="preserve">
          <source>BYTE_LITERAL :</source>
          <target state="translated">BYTE_LITERAL :</target>
        </trans-unit>
        <trans-unit id="e07c048067fa9215a18b4b2891f03e3f5148f8fe" translate="yes" xml:space="preserve">
          <source>BYTE_STRING_LITERAL :</source>
          <target state="translated">BYTE_STRING_LITERAL :</target>
        </trans-unit>
        <trans-unit id="a826c283ce6a52f2d32eb19de6510cb9098ad99b" translate="yes" xml:space="preserve">
          <source>Backslash</source>
          <target state="translated">Backslash</target>
        </trans-unit>
        <trans-unit id="2df2f36ad1b16c1667285665d27221aa512fe540" translate="yes" xml:space="preserve">
          <source>Backslash is escaped as &lt;code&gt;\&lt;/code&gt;.</source>
          <target state="translated">Обратная косая черта экранируется как &lt;code&gt;\&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a92ed9890561e42d2d0eb715d201f51180f68785" translate="yes" xml:space="preserve">
          <source>Backslash is escaped as &lt;code&gt;\\&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="10c02649e226d430bd75a5b6315a41c0db9992a2" translate="yes" xml:space="preserve">
          <source>Barrier</source>
          <target state="translated">Barrier</target>
        </trans-unit>
        <trans-unit id="05bc93718262068d5416ebba28511ebef76c4e14" translate="yes" xml:space="preserve">
          <source>Barrier::borrow</source>
          <target state="translated">Barrier::borrow</target>
        </trans-unit>
        <trans-unit id="48d8a6ca5d7ebcc052fa58321357d3bc36aa03a7" translate="yes" xml:space="preserve">
          <source>Barrier::borrow_mut</source>
          <target state="translated">Barrier::borrow_mut</target>
        </trans-unit>
        <trans-unit id="248c7b32ba40054cd50084ccaaff12b9c63d122a" translate="yes" xml:space="preserve">
          <source>Barrier::fmt</source>
          <target state="translated">Barrier::fmt</target>
        </trans-unit>
        <trans-unit id="d7dd85fbb601276305eb0ee52f6cb5d377f1fcc6" translate="yes" xml:space="preserve">
          <source>Barrier::from</source>
          <target state="translated">Barrier::from</target>
        </trans-unit>
        <trans-unit id="b342290a92d4444218a0ad57c6d277b796cd87a3" translate="yes" xml:space="preserve">
          <source>Barrier::into</source>
          <target state="translated">Barrier::into</target>
        </trans-unit>
        <trans-unit id="7468c224f8c905662e2e9c948739eef5bda7db0f" translate="yes" xml:space="preserve">
          <source>Barrier::new</source>
          <target state="translated">Barrier::new</target>
        </trans-unit>
        <trans-unit id="e30be523849f626aaa57ff5ee4069d25af8b70d1" translate="yes" xml:space="preserve">
          <source>Barrier::try_from</source>
          <target state="translated">Barrier::try_from</target>
        </trans-unit>
        <trans-unit id="e446147c6eb4453799cb6b4e470660354d138fed" translate="yes" xml:space="preserve">
          <source>Barrier::try_into</source>
          <target state="translated">Barrier::try_into</target>
        </trans-unit>
        <trans-unit id="97c7cb229080f5ec6d48954bf4e25fbf0b1b07ce" translate="yes" xml:space="preserve">
          <source>Barrier::type_id</source>
          <target state="translated">Barrier::type_id</target>
        </trans-unit>
        <trans-unit id="89f8492b0a8df428938e6f6ec1470925533e2645" translate="yes" xml:space="preserve">
          <source>Barrier::wait</source>
          <target state="translated">Barrier::wait</target>
        </trans-unit>
        <trans-unit id="1fdffd384d740408663001485f7d1d001cd2a0cd" translate="yes" xml:space="preserve">
          <source>BarrierWaitResult</source>
          <target state="translated">BarrierWaitResult</target>
        </trans-unit>
        <trans-unit id="e4a4959fb6b835a4c39d1adf5dc13e01c6574236" translate="yes" xml:space="preserve">
          <source>BarrierWaitResult::borrow</source>
          <target state="translated">BarrierWaitResult::borrow</target>
        </trans-unit>
        <trans-unit id="df6d4d2a45b72573796ce25c163ceca562fea277" translate="yes" xml:space="preserve">
          <source>BarrierWaitResult::borrow_mut</source>
          <target state="translated">BarrierWaitResult::borrow_mut</target>
        </trans-unit>
        <trans-unit id="ab607187cf3b656038040cc905673df49597a85b" translate="yes" xml:space="preserve">
          <source>BarrierWaitResult::fmt</source>
          <target state="translated">BarrierWaitResult::fmt</target>
        </trans-unit>
        <trans-unit id="40c08de59f1f4830ac002ad44e2d3553862e48a4" translate="yes" xml:space="preserve">
          <source>BarrierWaitResult::from</source>
          <target state="translated">BarrierWaitResult::from</target>
        </trans-unit>
        <trans-unit id="0ad014a8be36da91076930d7e3b4ff7218ef30aa" translate="yes" xml:space="preserve">
          <source>BarrierWaitResult::into</source>
          <target state="translated">BarrierWaitResult::into</target>
        </trans-unit>
        <trans-unit id="24471f5273b1cd68c1f7b8b58afe489ead7b1e9c" translate="yes" xml:space="preserve">
          <source>BarrierWaitResult::is_leader</source>
          <target state="translated">BarrierWaitResult::is_leader</target>
        </trans-unit>
        <trans-unit id="30b419cdf31db8213f868433400e90eb5bd6bd09" translate="yes" xml:space="preserve">
          <source>BarrierWaitResult::try_from</source>
          <target state="translated">BarrierWaitResult::try_from</target>
        </trans-unit>
        <trans-unit id="917cd48270dee8a42dabe702984f20fa69cc47a8" translate="yes" xml:space="preserve">
          <source>BarrierWaitResult::try_into</source>
          <target state="translated">BarrierWaitResult::try_into</target>
        </trans-unit>
        <trans-unit id="29252f73362aacd393a5eec57cfc8edfc91915f8" translate="yes" xml:space="preserve">
          <source>BarrierWaitResult::type_id</source>
          <target state="translated">BarrierWaitResult::type_id</target>
        </trans-unit>
        <trans-unit id="0798504393a70fe84f8d6d8445159e80798bd3ac" translate="yes" xml:space="preserve">
          <source>Barriers are re-usable after all threads have rendezvoused once, and can be used continuously.</source>
          <target state="translated">Барьеры можно использовать повторно после того,как все нити встретились один раз,и их можно использовать непрерывно.</target>
        </trans-unit>
        <trans-unit id="b20cbc384159fd820ed034fd3615298ec09f5902" translate="yes" xml:space="preserve">
          <source>Basic Usage</source>
          <target state="translated">Основное использование</target>
        </trans-unit>
        <trans-unit id="e688514e6e0a6b01ae26314b3eb88e5e53881bcb" translate="yes" xml:space="preserve">
          <source>Basic behavior:</source>
          <target state="translated">Основное поведение:</target>
        </trans-unit>
        <trans-unit id="11bf4d2856fba52165f40435250d1ec2e6c3316a" translate="yes" xml:space="preserve">
          <source>Basic functions for dealing with memory.</source>
          <target state="translated">Основные функции для работы с памятью.</target>
        </trans-unit>
        <trans-unit id="ec83756dfd527ebf8f2a042db474987a95d353c4" translate="yes" xml:space="preserve">
          <source>Basic implementation of &lt;code&gt;FromStr&lt;/code&gt; on an example &lt;code&gt;Point&lt;/code&gt; type:</source>
          <target state="translated">Базовая реализация &lt;code&gt;FromStr&lt;/code&gt; на примере типа &lt;code&gt;Point&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="c3d9f55cf67e9ea4d900c6c2497ec5a08343c0a5" translate="yes" xml:space="preserve">
          <source>Basic mathematical constants.</source>
          <target state="translated">Основные математические константы.</target>
        </trans-unit>
        <trans-unit id="03619f20093f70d07eb4c7482bb00f0ec8e3c3fc" translate="yes" xml:space="preserve">
          <source>Basic pattern matching on &lt;a href=&quot;enum.option&quot;&gt;&lt;code&gt;Option&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">Базовое сопоставление с образцом в &lt;a href=&quot;enum.option&quot;&gt; &lt;code&gt;Option&lt;/code&gt; &lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="cb3a8802da5b3164771a468d78ff7995a249f08a" translate="yes" xml:space="preserve">
          <source>Basic usage</source>
          <target state="translated">Основное использование</target>
        </trans-unit>
        <trans-unit id="30a9f8a0441549550539e36ec0f9f9002255cfd0" translate="yes" xml:space="preserve">
          <source>Basic usage example:</source>
          <target state="translated">Основной пример использования:</target>
        </trans-unit>
        <trans-unit id="4ba20db65bc2f86fd8313d56d1906d6e40c680fc" translate="yes" xml:space="preserve">
          <source>Basic usage with &lt;a href=&quot;../primitive.i32&quot;&gt;&lt;code&gt;i32&lt;/code&gt;&lt;/a&gt;, a type that implements &lt;code&gt;FromStr&lt;/code&gt;:</source>
          <target state="translated">Базовое использование с &lt;a href=&quot;../primitive.i32&quot;&gt; &lt;code&gt;i32&lt;/code&gt; &lt;/a&gt; , типом, реализующим &lt;code&gt;FromStr&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="e86fea8c030e7f6d48033a20b07738fb6cc7d1e1" translate="yes" xml:space="preserve">
          <source>Basic usage with &lt;a href=&quot;../primitive.i32&quot;&gt;&lt;code&gt;i32&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">Базовое использование с &lt;a href=&quot;../primitive.i32&quot;&gt; &lt;code&gt;i32&lt;/code&gt; &lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="a8f910f3980e5f4caf7f91e6c92b1c5ff7ef8744" translate="yes" xml:space="preserve">
          <source>Basic usage with &lt;code&gt;&amp;amp;i32&lt;/code&gt;:</source>
          <target state="translated">Базовое использование с &lt;code&gt;&amp;amp;i32&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="4b7db61f0810a48b5403cec32d70374937db6803" translate="yes" xml:space="preserve">
          <source>Basic usage with &lt;code&gt;f64&lt;/code&gt;:</source>
          <target state="translated">Базовое использование с &lt;code&gt;f64&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="473dba01450bbaa0ba0aec1bf0715ab6ef2ccb9f" translate="yes" xml:space="preserve">
          <source>Basic usage with &lt;code&gt;i32&lt;/code&gt;:</source>
          <target state="translated">Базовое использование с &lt;code&gt;i32&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="65f639d2a40570f68ed54fc56bf243ceac2035a0" translate="yes" xml:space="preserve">
          <source>Basic usage:</source>
          <target state="translated">Основное использование:</target>
        </trans-unit>
        <trans-unit id="ae854127dfb82027c5681daec7e882045161fa8e" translate="yes" xml:space="preserve">
          <source>Be a &lt;a href=&quot;associated-items#methods&quot;&gt;method&lt;/a&gt; that does not use &lt;code&gt;Self&lt;/code&gt; except in the type of the receiver.</source>
          <target state="translated">Будьте &lt;a href=&quot;associated-items#methods&quot;&gt;методом&lt;/a&gt; , который не использует &lt;code&gt;Self&lt;/code&gt; , за исключением типа получателя.</target>
        </trans-unit>
        <trans-unit id="a9609503521663742afb4db6d34fce975c5ef790" translate="yes" xml:space="preserve">
          <source>Be aware that operations on seemingly non-ASCII characters can sometimes have unexpected results. Consider this example:</source>
          <target state="translated">Имейте в виду,что операции над,казалось бы,не-ASCII-символами могут иногда давать неожиданные результаты.Рассмотрим этот пример:</target>
        </trans-unit>
        <trans-unit id="f7eed2246078297c7f3c1974fe5ece00f24fc71c" translate="yes" xml:space="preserve">
          <source>Be careful when publishing a crate because a publish is &lt;em&gt;permanent&lt;/em&gt;. The version can never be overwritten, and the code cannot be deleted. One major goal of &lt;a href=&quot;https://crates.io/&quot;&gt;crates.io&lt;/a&gt; is to act as a permanent archive of code so that builds of all projects that depend on crates from &lt;a href=&quot;https://crates.io/&quot;&gt;crates.io&lt;/a&gt; will continue to work. Allowing version deletions would make fulfilling that goal impossible. However, there is no limit to the number of crate versions you can publish.</source>
          <target state="translated">Будьте осторожны при публикации ящика, потому что публикация является &lt;em&gt;постоянной&lt;/em&gt; . Версия никогда не может быть перезаписана, а код не может быть удален. Одна из основных целей &lt;a href=&quot;https://crates.io/&quot;&gt;crates.io&lt;/a&gt; - действовать как постоянный архив кода, чтобы сборки всех проектов, зависящих от ящиков &lt;a href=&quot;https://crates.io/&quot;&gt;crates.io&lt;/a&gt; , продолжали работать. Разрешение удаления версий сделало бы достижение этой цели невозможным. Однако количество версий ящиков, которые вы можете опубликовать, не ограничено.</target>
        </trans-unit>
        <trans-unit id="dca86f7e9af3880530e74de899f022486c60c4c6" translate="yes" xml:space="preserve">
          <source>Be representable in the return type &lt;code&gt;Int&lt;/code&gt;, after truncating off its fractional part</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="944c776ebe8836f4d5f40423d2d077f777d1f2db" translate="yes" xml:space="preserve">
          <source>Be sure to copy over any bounds as well:</source>
          <target state="translated">Обязательно скопируйте и за любые рамки:</target>
        </trans-unit>
        <trans-unit id="b7d22470344866c1dcd5a2efc22d2e6cb51a1ab2" translate="yes" xml:space="preserve">
          <source>Bear in mind that methods on infinite iterators, even those for which a result can be determined mathematically in finite time, may not terminate. Specifically, methods such as &lt;a href=&quot;trait.iterator#method.min&quot;&gt;&lt;code&gt;min&lt;/code&gt;&lt;/a&gt;, which in the general case require traversing every element in the iterator, are likely not to return successfully for any infinite iterators.</source>
          <target state="translated">Имейте в виду, что методы на бесконечных итераторах, даже те, для которых результат может быть определен математически за конечное время, могут не завершаться. В частности, такие методы, как &lt;a href=&quot;trait.iterator#method.min&quot;&gt; &lt;code&gt;min&lt;/code&gt; &lt;/a&gt; , которые в общем случае требуют обхода каждого элемента в итераторе, скорее всего, не вернутся успешно для любых бесконечных итераторов.</target>
        </trans-unit>
        <trans-unit id="3d00abb1d72a8bac8ecec238c14739dba53b4125" translate="yes" xml:space="preserve">
          <source>Because &lt;code&gt;Animal::baby_name&lt;/code&gt; is an associated function rather than a method, and thus doesn&amp;rsquo;t have a &lt;code&gt;self&lt;/code&gt; parameter, Rust can&amp;rsquo;t figure out which implementation of &lt;code&gt;Animal::baby_name&lt;/code&gt; we want. We&amp;rsquo;ll get this compiler error:</source>
          <target state="translated">Поскольку &lt;code&gt;Animal::baby_name&lt;/code&gt; - это связанная функция, а не метод, и, следовательно, не имеет параметра &lt;code&gt;self&lt;/code&gt; , Rust не может определить, какую реализацию &lt;code&gt;Animal::baby_name&lt;/code&gt; мы хотим. Мы получим эту ошибку компилятора:</target>
        </trans-unit>
        <trans-unit id="e982f4d1ceaa6ebce2e39ce35fa3517925f4eb60" translate="yes" xml:space="preserve">
          <source>Because &lt;code&gt;Drop::drop&lt;/code&gt; is used to clean up a value, it may be dangerous to use this value after the method has been called. As &lt;code&gt;Drop::drop&lt;/code&gt; does not take ownership of its input, Rust prevents misuse by not allowing you to call &lt;code&gt;Drop::drop&lt;/code&gt; directly.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c77d0afa61b96acdbbf5c9bd8c7ad5776b21e2a7" translate="yes" xml:space="preserve">
          <source>Because &lt;code&gt;Kilometers&lt;/code&gt; and &lt;code&gt;i32&lt;/code&gt; are the same type, we can add values of both types and we can pass &lt;code&gt;Kilometers&lt;/code&gt; values to functions that take &lt;code&gt;i32&lt;/code&gt; parameters. However, using this method, we don&amp;rsquo;t get the type checking benefits that we get from the newtype pattern discussed earlier.</source>
          <target state="translated">Поскольку &lt;code&gt;Kilometers&lt;/code&gt; и &lt;code&gt;i32&lt;/code&gt; относятся к одному типу, мы можем добавлять значения обоих типов и передавать значения &lt;code&gt;Kilometers&lt;/code&gt; функциям, которые принимают параметры &lt;code&gt;i32&lt;/code&gt; . Однако, используя этот метод, мы не получаем преимуществ проверки типов, которые мы получаем от описанного ранее шаблона newtype.</target>
        </trans-unit>
        <trans-unit id="6b9cbc9e966e04746993324da12bc0b094791922" translate="yes" xml:space="preserve">
          <source>Because &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt; allows mutable borrows checked at runtime, you can mutate the value inside the &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt; even when the &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt; is immutable.</source>
          <target state="translated">Поскольку &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt; допускает изменяемые заимствования, проверяемые во время выполнения, вы можете &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt; значение внутри RefCell &amp;lt;T&amp;gt;, даже если &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt; является неизменным.</target>
        </trans-unit>
        <trans-unit id="3648820fdd060b2ae98ec9efe9a7aa20de6bd4e7" translate="yes" xml:space="preserve">
          <source>Because &lt;code&gt;_x&lt;/code&gt; is moved into the function, it is automatically dropped before the function returns.</source>
          <target state="translated">Поскольку &lt;code&gt;_x&lt;/code&gt; перемещается в функцию, он автоматически удаляется перед возвратом функции.</target>
        </trans-unit>
        <trans-unit id="02501fd298567a0388a172b4febd506fefcf8337" translate="yes" xml:space="preserve">
          <source>Because &lt;code&gt;collect()&lt;/code&gt; is so general, it can cause problems with type inference. As such, &lt;code&gt;collect()&lt;/code&gt; is one of the few times you'll see the syntax affectionately known as the 'turbofish': &lt;code&gt;::&amp;lt;&amp;gt;&lt;/code&gt;. This helps the inference algorithm understand specifically which collection you're trying to collect into.</source>
          <target state="translated">Поскольку &lt;code&gt;collect()&lt;/code&gt; является настолько общим, он может вызвать проблемы с выводом типа. Таким образом, &lt;code&gt;collect()&lt;/code&gt; - один из немногих случаев, когда вы увидите синтаксис, ласково известный как 'turbofish': &lt;code&gt;::&amp;lt;&amp;gt;&lt;/code&gt; . Это помогает алгоритму вывода конкретно понять, в какую коллекцию вы пытаетесь собрать.</target>
        </trans-unit>
        <trans-unit id="f792523afdd09554f3c4c09b932d34d5d3beab5f" translate="yes" xml:space="preserve">
          <source>Because &lt;code&gt;collect()&lt;/code&gt; only cares about what you're collecting into, you can still use a partial type hint, &lt;code&gt;_&lt;/code&gt;, with the turbofish:</source>
          <target state="translated">Поскольку &lt;code&gt;collect()&lt;/code&gt; заботится только о том, во что вы собираете, вы все равно можете использовать подсказку частичного типа, &lt;code&gt;_&lt;/code&gt; , с turbofish:</target>
        </trans-unit>
        <trans-unit id="b2e79e04cb1d4d369cbb0462d719cf25107b631b" translate="yes" xml:space="preserve">
          <source>Because &lt;code&gt;fancy_ref&lt;/code&gt; still holds a reference to &lt;code&gt;fancy_num&lt;/code&gt;, &lt;code&gt;fancy_num&lt;/code&gt; can't be assigned to a new value as it would invalidate the reference.</source>
          <target state="translated">Поскольку &lt;code&gt;fancy_ref&lt;/code&gt; по- прежнему содержит ссылку на &lt;code&gt;fancy_num&lt;/code&gt; , &lt;code&gt;fancy_num&lt;/code&gt; нельзя присвоить новому значению, поскольку это сделает ссылку недействительной.</target>
        </trans-unit>
        <trans-unit id="ad62e74aea9006b0878a087eb02874ec0ddf69c6" translate="yes" xml:space="preserve">
          <source>Because &lt;code&gt;find()&lt;/code&gt; takes a reference, and many iterators iterate over references, this leads to a possibly confusing situation where the argument is a double reference. You can see this effect in the examples below, with &lt;code&gt;&amp;amp;&amp;amp;x&lt;/code&gt;.</source>
          <target state="translated">Поскольку &lt;code&gt;find()&lt;/code&gt; принимает ссылку, а многие итераторы перебирают ссылки, это может привести к запутанной ситуации, когда аргумент является двойной ссылкой. Вы можете увидеть этот эффект в примерах ниже с помощью &lt;code&gt;&amp;amp;&amp;amp;x&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8154baa71c56f29ade9fab7717781feba4bbd572" translate="yes" xml:space="preserve">
          <source>Because &lt;code&gt;if&lt;/code&gt; is an expression, we can use it on the right side of a &lt;code&gt;let&lt;/code&gt; statement, as in Listing 3-2.</source>
          <target state="translated">Поскольку &lt;code&gt;if&lt;/code&gt; является выражением, мы можем использовать его в правой части оператора &lt;code&gt;let&lt;/code&gt; , как показано в листинге 3-2.</target>
        </trans-unit>
        <trans-unit id="9997aaaef6017b0cb2af61885b73aab100c2b5f6" translate="yes" xml:space="preserve">
          <source>Because &lt;code&gt;map&lt;/code&gt; takes a closure, we can specify any operation we want to perform on each item. This is a great example of how closures let you customize some behavior while reusing the iteration behavior that the &lt;code&gt;Iterator&lt;/code&gt; trait provides.</source>
          <target state="translated">Поскольку &lt;code&gt;map&lt;/code&gt; принимает замыкание, мы можем указать любую операцию, которую хотим выполнить с каждым элементом. Это отличный пример того, как замыкания позволяют настраивать некоторое поведение при повторном использовании итерационного поведения, предоставляемого чертой &lt;code&gt;Iterator&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b6c4314864b0e06485267f3ca664e542a4a9d24f" translate="yes" xml:space="preserve">
          <source>Because &lt;code&gt;map_while()&lt;/code&gt; needs to look at the value in order to see if it should be included or not, consuming iterators will see that it is removed:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3d80f24c4a2216ac3e891c23c7f333250fe61032" translate="yes" xml:space="preserve">
          <source>Because &lt;code&gt;parse&lt;/code&gt; is so general, it can cause problems with type inference. As such, &lt;code&gt;parse&lt;/code&gt; is one of the few times you'll see the syntax affectionately known as the 'turbofish': &lt;code&gt;::&amp;lt;&amp;gt;&lt;/code&gt;. This helps the inference algorithm understand specifically which type you're trying to parse into.</source>
          <target state="translated">Поскольку &lt;code&gt;parse&lt;/code&gt; настолько общий, он может вызвать проблемы с выводом типа. Таким образом, &lt;code&gt;parse&lt;/code&gt; - это один из немногих случаев, когда вы увидите синтаксис, ласково известный как 'turbofish': &lt;code&gt;::&amp;lt;&amp;gt;&lt;/code&gt; . Это помогает алгоритму вывода конкретно понять, какой тип вы пытаетесь проанализировать.</target>
        </trans-unit>
        <trans-unit id="f088d61355fe261cd42315fc674f33d7a3ce9310" translate="yes" xml:space="preserve">
          <source>Because &lt;code&gt;peek()&lt;/code&gt; returns a reference, and many iterators iterate over references, there can be a possibly confusing situation where the return value is a double reference. You can see this effect in the examples below.</source>
          <target state="translated">Поскольку &lt;code&gt;peek()&lt;/code&gt; возвращает ссылку, а многие итераторы перебирают ссылки, может возникнуть ситуация, которая может сбивать с толку, когда возвращаемое значение является двойной ссылкой. Вы можете увидеть этот эффект в примерах ниже.</target>
        </trans-unit>
        <trans-unit id="a7eb647ad22291b28a51fd607cc84aff6f4abc83" translate="yes" xml:space="preserve">
          <source>Because &lt;code&gt;rfind()&lt;/code&gt; takes a reference, and many iterators iterate over references, this leads to a possibly confusing situation where the argument is a double reference. You can see this effect in the examples below, with &lt;code&gt;&amp;amp;&amp;amp;x&lt;/code&gt;.</source>
          <target state="translated">Поскольку &lt;code&gt;rfind()&lt;/code&gt; принимает ссылку, а многие итераторы выполняют итерацию по ссылкам, это может привести к запутанной ситуации, когда аргумент является двойной ссылкой. Вы можете увидеть этот эффект в примерах ниже с помощью &lt;code&gt;&amp;amp;&amp;amp;x&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ddf1f7383234f0909d810cef598c63fc6f240534" translate="yes" xml:space="preserve">
          <source>Because &lt;code&gt;s&lt;/code&gt; is created inside &lt;code&gt;dangle&lt;/code&gt;, when the code of &lt;code&gt;dangle&lt;/code&gt; is finished, &lt;code&gt;s&lt;/code&gt; will be deallocated. But we tried to return a reference to it. That means this reference would be pointing to an invalid &lt;code&gt;String&lt;/code&gt;. That&amp;rsquo;s no good! Rust won&amp;rsquo;t let us do this.</source>
          <target state="translated">Поскольку &lt;code&gt;s&lt;/code&gt; создается внутри &lt;code&gt;dangle&lt;/code&gt; , когда код &lt;code&gt;dangle&lt;/code&gt; завершен, &lt;code&gt;s&lt;/code&gt; будет освобожден. Но мы попытались вернуть ссылку на него. Это означает, что эта ссылка будет указывать на недопустимую &lt;code&gt;String&lt;/code&gt; . Это не хорошо! Ржавчина не позволит нам этого сделать.</target>
        </trans-unit>
        <trans-unit id="ad3a4a81012df51bdd1c2d631b8bd2d26a080ac6" translate="yes" xml:space="preserve">
          <source>Because &lt;code&gt;take_while()&lt;/code&gt; needs to look at the value in order to see if it should be included or not, consuming iterators will see that it is removed:</source>
          <target state="translated">Поскольку &lt;code&gt;take_while()&lt;/code&gt; необходимо посмотреть на значение, чтобы увидеть, следует ли его включать или нет, итераторы-потребители увидят, что оно удалено:</target>
        </trans-unit>
        <trans-unit id="a2c09e5f782c06a87c2e923fecb0abf777de8d4b" translate="yes" xml:space="preserve">
          <source>Because Rust compiles generic code into code that specifies the type in each instance, we pay no runtime cost for using generics. When the code runs, it performs just as it would if we had duplicated each definition by hand. The process of monomorphization makes Rust&amp;rsquo;s generics extremely efficient at runtime.</source>
          <target state="translated">Поскольку Rust компилирует общий код в код, который определяет тип в каждом экземпляре, мы не платим затрат времени выполнения за использование универсальных шаблонов. Когда код запускается, он работает так же, как если бы мы продублировали каждое определение вручную. Процесс мономорфизации делает дженерики Rust чрезвычайно эффективными во время выполнения.</target>
        </trans-unit>
        <trans-unit id="cb2c4627fadc957440586a7d9c240acafefffc6b" translate="yes" xml:space="preserve">
          <source>Because a &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; is a pointer, Rust always knows how much space a &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; needs: a pointer&amp;rsquo;s size doesn&amp;rsquo;t change based on the amount of data it&amp;rsquo;s pointing to. This means we can put a &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; inside the &lt;code&gt;Cons&lt;/code&gt; variant instead of another &lt;code&gt;List&lt;/code&gt; value directly. The &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; will point to the next &lt;code&gt;List&lt;/code&gt; value that will be on the heap rather than inside the &lt;code&gt;Cons&lt;/code&gt; variant. Conceptually, we still have a list, created with lists &amp;ldquo;holding&amp;rdquo; other lists, but this implementation is now more like placing the items next to one another rather than inside one another.</source>
          <target state="translated">Поскольку &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; является указателем, Rust всегда знает, сколько места требуется &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; : размер указателя не изменяется в зависимости от количества данных, на которые он указывает. Это означает, что мы можем поместить &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; в вариант &lt;code&gt;Cons&lt;/code&gt; вместо другого значения &lt;code&gt;List&lt;/code&gt; напрямую. &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; будет указывать на следующий &lt;code&gt;List&lt;/code&gt; значение , которое будет в куче , а не внутри &lt;code&gt;Cons&lt;/code&gt; варианта. Концептуально у нас все еще есть список, созданный со списками, &amp;laquo;содержащими&amp;raquo; другие списки, но эта реализация теперь больше похожа на размещение элементов рядом друг с другом, а не внутри друг друга.</target>
        </trans-unit>
        <trans-unit id="cf81e03b95485ed347873e7e3fe9e72472e6c6b8" translate="yes" xml:space="preserve">
          <source>Because async blocks construct a future, they define an &lt;strong&gt;async context&lt;/strong&gt; which can in turn contain &lt;a href=&quot;await-expr&quot;&gt;&lt;code&gt;await&lt;/code&gt; expressions&lt;/a&gt;. Async contexts are established by async blocks as well as the bodies of async functions, whose semantics are defined in terms of async blocks.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1af0938fa6746a245ca497556ef936994388e62f" translate="yes" xml:space="preserve">
          <source>Because captures are often by reference, the following general rules arise:</source>
          <target state="translated">Поскольку захваты часто производятся путем отсылки,возникают следующие общие правила:</target>
        </trans-unit>
        <trans-unit id="48453fbdaf06b97c2a50276382893c7136610cb4" translate="yes" xml:space="preserve">
          <source>Because forgetting a value is allowed, any &lt;code&gt;unsafe&lt;/code&gt; code you write must allow for this possibility. You cannot return a value and expect that the caller will necessarily run the value's destructor.</source>
          <target state="translated">Поскольку забывание значения разрешено, любой &lt;code&gt;unsafe&lt;/code&gt; код, который вы пишете, должен учитывать эту возможность. Вы не можете вернуть значение и ожидать, что вызывающий объект обязательно запустит деструктор значения.</target>
        </trans-unit>
        <trans-unit id="757a75cd5c62512d1ecdcf5444c4066082ba840e" translate="yes" xml:space="preserve">
          <source>Because having variable names match the fields is common and because writing &lt;code&gt;let Point { x: x, y: y } = p;&lt;/code&gt; contains a lot of duplication, there is a shorthand for patterns that match struct fields: you only need to list the name of the struct field, and the variables created from the pattern will have the same names. Listing 18-13 shows code that behaves in the same way as the code in Listing 18-12, but the variables created in the &lt;code&gt;let&lt;/code&gt; pattern are &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; instead of &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt;.</source>
          <target state="translated">Поскольку имена переменных совпадают с полями, это обычное дело и поскольку запись &lt;code&gt;let Point { x: x, y: y } = p;&lt;/code&gt; содержит много дублирования, существует сокращение для шаблонов, соответствующих полям структуры: вам нужно только указать имя поля структуры, и переменные, созданные из шаблона, будут иметь те же имена. В листинге 18-13 показан код, который ведет себя так же, как код в листинге 18-12, но переменные, созданные в шаблоне &lt;code&gt;let&lt;/code&gt; , - это &lt;code&gt;x&lt;/code&gt; и &lt;code&gt;y&lt;/code&gt; вместо &lt;code&gt;a&lt;/code&gt; и &lt;code&gt;b&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="83438caeb4e092f6346d53e11e3dc5cc7d15ebb0" translate="yes" xml:space="preserve">
          <source>Because marker traits are allowed to have multiple implementations for the same type, it's not allowed to override anything in those implementations, as it would be ambiguous which override should actually be used.</source>
          <target state="translated">Так как признакам маркера разрешено иметь несколько реализаций для одного и того же типа,запрещается переопределять что-либо в этих реализациях,так как было бы двусмысленно,какое переопределение на самом деле должно быть использовано.</target>
        </trans-unit>
        <trans-unit id="e1154d896f41e24691d4a2066a20e9a97b30a6b0" translate="yes" xml:space="preserve">
          <source>Because of the call to the &lt;code&gt;foo&lt;/code&gt; macro, the compiler guesses that the missing module could be inside it and fails because the macro definition cannot be found.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="620af94cb9d051d4dfe9f749a85e09b10b24aa07" translate="yes" xml:space="preserve">
          <source>Because of the early return, &lt;code&gt;try!&lt;/code&gt; can only be used in functions that return &lt;a href=&quot;result/enum.result&quot;&gt;&lt;code&gt;Result&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Из-за скорейшего возвращения &lt;code&gt;try!&lt;/code&gt; может использоваться только в функциях, возвращающих &lt;a href=&quot;result/enum.result&quot;&gt; &lt;code&gt;Result&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="9c9db3f614804b168272d0d3012c3d9bae7f766b" translate="yes" xml:space="preserve">
          <source>Because of this dual purpose, it is possible to create types that are not useful for interfacing with the C programming language.</source>
          <target state="translated">Благодаря этому двойному назначению можно создавать типы,не полезные для взаимодействия с языком программирования Си.</target>
        </trans-unit>
        <trans-unit id="6eba9459a54a420c4009843eca1a3d7462a26445" translate="yes" xml:space="preserve">
          <source>Because of this recursive dropping, you do not need to implement this trait unless your type needs its own destructor logic.</source>
          <target state="translated">Из-за этого рекурсивного падения вам не нужно реализовывать этот признак,если только вашему типу не нужна собственная логика деструктора.</target>
        </trans-unit>
        <trans-unit id="df92f9c80443d85d1d1f8c4ed514d9988ba7345d" translate="yes" xml:space="preserve">
          <source>Because of this, the behavior when both &lt;code&gt;from&lt;/code&gt; and &lt;code&gt;to&lt;/code&gt; exist differs. On Unix, if &lt;code&gt;from&lt;/code&gt; is a directory, &lt;code&gt;to&lt;/code&gt; must also be an (empty) directory. If &lt;code&gt;from&lt;/code&gt; is not a directory, &lt;code&gt;to&lt;/code&gt; must also be not a directory. In contrast, on Windows, &lt;code&gt;from&lt;/code&gt; can be anything, but &lt;code&gt;to&lt;/code&gt; must &lt;em&gt;not&lt;/em&gt; be a directory.</source>
          <target state="translated">Из-за этого поведение, когда и &lt;code&gt;from&lt;/code&gt; и &lt;code&gt;to&lt;/code&gt; существования, отличается. В Unix, если &lt;code&gt;from&lt;/code&gt; - это каталог, &lt;code&gt;to&lt;/code&gt; также должен быть (пустым) каталогом. Если &lt;code&gt;from&lt;/code&gt; не является каталогом, &lt;code&gt;to&lt;/code&gt; также не должен быть каталогом. В отличие от этого , в Windows, &lt;code&gt;from&lt;/code&gt; может быть что угодно, но &lt;code&gt;to&lt;/code&gt; сусло &lt;em&gt;не&lt;/em&gt; быть каталогом.</target>
        </trans-unit>
        <trans-unit id="edb25a77d997330fe82c62f487b65b2a449f7a57" translate="yes" xml:space="preserve">
          <source>Because of this, you must give the numeric literal or binding a type:</source>
          <target state="translated">Поэтому необходимо задать числовой буквенный или связывающий тип:</target>
        </trans-unit>
        <trans-unit id="f5828ddf70feaedc77b7fe1498bca4e7ef61a70f" translate="yes" xml:space="preserve">
          <source>Because ownership is a new concept for many programmers, it does take some time to get used to. The good news is that the more experienced you become with Rust and the rules of the ownership system, the more you&amp;rsquo;ll be able to naturally develop code that is safe and efficient. Keep at it!</source>
          <target state="translated">Поскольку владение - это новое понятие для многих программистов, нужно время, чтобы к нему привыкнуть. Хорошая новость заключается в том, что чем больше вы приобретете опыт работы с Rust и правилами системы владения, тем лучше вы сможете естественно разработать безопасный и эффективный код. Держись! Не сдавайся!</target>
        </trans-unit>
        <trans-unit id="e400474ad8de5abb677ee1fb6adda287a3d95af5" translate="yes" xml:space="preserve">
          <source>Because raw entries provide much more low-level control, it's much easier to put the HashMap into an inconsistent state which, while memory-safe, will cause the map to produce seemingly random results. Higher-level and more foolproof APIs like &lt;code&gt;entry&lt;/code&gt; should be preferred when possible.</source>
          <target state="translated">Поскольку необработанные записи обеспечивают гораздо более низкоуровневый контроль, гораздо проще перевести HashMap в несогласованное состояние, которое, хотя и безопасно для памяти, приведет к тому, что карта будет выдавать кажущиеся случайными результаты. По возможности следует отдавать предпочтение более высокоуровневым и более надежным API, таким как &lt;code&gt;entry&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="25432f6301bbde0b420035486d49aeb28bde5fd2" translate="yes" xml:space="preserve">
          <source>Because some analysis is impossible, if the Rust compiler can&amp;rsquo;t be sure the code complies with the ownership rules, it might reject a correct program; in this way, it&amp;rsquo;s conservative. If Rust accepted an incorrect program, users wouldn&amp;rsquo;t be able to trust in the guarantees Rust makes. However, if Rust rejects a correct program, the programmer will be inconvenienced, but nothing catastrophic can occur. The &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt; type is useful when you&amp;rsquo;re sure your code follows the borrowing rules but the compiler is unable to understand and guarantee that.</source>
          <target state="translated">Поскольку некоторый анализ невозможен, если компилятор Rust не может быть уверен, что код соответствует правилам владения, он может отклонить правильную программу; в этом смысле это консервативно. Если бы Rust принял неправильную программу, пользователи не смогли бы поверить в гарантии, которые дает Rust. Однако, если Rust отвергает правильную программу, программисту будут неудобны, но ничего катастрофического не произойдет. Тип &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt; полезен, когда вы уверены, что ваш код следует правилам заимствования, но компилятор не может этого понять и гарантировать.</target>
        </trans-unit>
        <trans-unit id="029a6be2649372b5b88e5ae502ff0638c469c42e" translate="yes" xml:space="preserve">
          <source>Because strings are used for so many things, we can use many different generic APIs for strings, providing us with a lot of options. Some of them can seem redundant, but they all have their place! In this case, &lt;code&gt;String::from&lt;/code&gt; and &lt;code&gt;to_string&lt;/code&gt; do the same thing, so which you choose is a matter of style.</source>
          <target state="translated">Поскольку строки используются для очень многих вещей, мы можем использовать множество различных общих API для строк, предоставляя нам множество вариантов. Некоторые из них могут показаться избыточными, но все они имеют свое место! В этом случае &lt;code&gt;String::from&lt;/code&gt; и &lt;code&gt;to_string&lt;/code&gt; делают то же самое, поэтому выбор зависит от стиля.</target>
        </trans-unit>
        <trans-unit id="1b950a204977447e5ef7cd3c6942f49baa8eb222" translate="yes" xml:space="preserve">
          <source>Because the &lt;code&gt;enumerate&lt;/code&gt; method returns a tuple, we can use patterns to destructure that tuple, just like everywhere else in Rust. So in the &lt;code&gt;for&lt;/code&gt; loop, we specify a pattern that has &lt;code&gt;i&lt;/code&gt; for the index in the tuple and &lt;code&gt;&amp;amp;item&lt;/code&gt; for the single byte in the tuple. Because we get a reference to the element from &lt;code&gt;.iter().enumerate()&lt;/code&gt;, we use &lt;code&gt;&amp;amp;&lt;/code&gt; in the pattern.</source>
          <target state="translated">Поскольку метод &lt;code&gt;enumerate&lt;/code&gt; возвращает кортеж, мы можем использовать шаблоны для деструктуризации этого кортежа, как и везде в Rust. Итак, в цикле &lt;code&gt;for&lt;/code&gt; мы указываем шаблон, в котором &lt;code&gt;i&lt;/code&gt; для индекса в кортеже и &lt;code&gt;&amp;amp;item&lt;/code&gt; для одиночного байта в кортеже. Поскольку мы получаем ссылку на элемент из &lt;code&gt;.iter().enumerate()&lt;/code&gt; , мы используем &lt;code&gt;&amp;amp;&lt;/code&gt; в шаблоне.</target>
        </trans-unit>
        <trans-unit id="4bad4d17c2470c688d65e4cf4cd29dd8d9a6843c" translate="yes" xml:space="preserve">
          <source>Because the &lt;code&gt;fly&lt;/code&gt; method takes a &lt;code&gt;self&lt;/code&gt; parameter, if we had two &lt;em&gt;types&lt;/em&gt; that both implement one &lt;em&gt;trait&lt;/em&gt;, Rust could figure out which implementation of a trait to use based on the type of &lt;code&gt;self&lt;/code&gt;.</source>
          <target state="translated">Поскольку метод &lt;code&gt;fly&lt;/code&gt; принимает параметр &lt;code&gt;self&lt;/code&gt; , если бы у нас было два &lt;em&gt;типа,&lt;/em&gt; которые реализуют одну &lt;em&gt;черту&lt;/em&gt; , Rust мог бы определить, какую реализацию черты использовать, на основе типа &lt;code&gt;self&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2dfa04ea7812d8d0a045650338922229931556bb" translate="yes" xml:space="preserve">
          <source>Because the &lt;code&gt;toast&lt;/code&gt; field in the &lt;code&gt;back_of_house::Breakfast&lt;/code&gt; struct is public, in &lt;code&gt;eat_at_restaurant&lt;/code&gt; we can write and read to the &lt;code&gt;toast&lt;/code&gt; field using dot notation. Notice that we can&amp;rsquo;t use the &lt;code&gt;seasonal_fruit&lt;/code&gt; field in &lt;code&gt;eat_at_restaurant&lt;/code&gt; because &lt;code&gt;seasonal_fruit&lt;/code&gt; is private. Try uncommenting the line modifying the &lt;code&gt;seasonal_fruit&lt;/code&gt; field value to see what error you get!</source>
          <target state="translated">Поскольку поле &lt;code&gt;toast&lt;/code&gt; в структуре &lt;code&gt;back_of_house::Breakfast&lt;/code&gt; является общедоступным, в &lt;code&gt;eat_at_restaurant&lt;/code&gt; мы можем писать и читать в поле &lt;code&gt;toast&lt;/code&gt; используя точечную нотацию. Обратите внимание , что мы не можем использовать &lt;code&gt;seasonal_fruit&lt;/code&gt; поле в &lt;code&gt;eat_at_restaurant&lt;/code&gt; , потому что &lt;code&gt;seasonal_fruit&lt;/code&gt; является частным. Попробуйте раскомментировать строку изменения &lt;code&gt;seasonal_fruit&lt;/code&gt; значения поля , чтобы увидеть , что ошибка , которую вы получите!</target>
        </trans-unit>
        <trans-unit id="185de19b862032b52b28484b2c6cc55792a266c3" translate="yes" xml:space="preserve">
          <source>Because the &lt;code&gt;write&lt;/code&gt; operation could fail, we use &lt;code&gt;unwrap&lt;/code&gt; on any error result as before. Again, in a real application you would add error handling here. Finally, &lt;code&gt;flush&lt;/code&gt; will wait and prevent the program from continuing until all the bytes are written to the connection; &lt;code&gt;TcpStream&lt;/code&gt; contains an internal buffer to minimize calls to the underlying operating system.</source>
          <target state="translated">Поскольку операция &lt;code&gt;write&lt;/code&gt; может завершиться неудачно, мы, как и раньше , используем &lt;code&gt;unwrap&lt;/code&gt; для любого результата ошибки. Опять же, в реальном приложении вы бы добавили сюда обработку ошибок. Наконец, &lt;code&gt;flush&lt;/code&gt; будет ждать и предотвращать продолжение программы до тех пор, пока все байты не будут записаны в соединение; &lt;code&gt;TcpStream&lt;/code&gt; содержит внутренний буфер для минимизации обращений к базовой операционной системе.</target>
        </trans-unit>
        <trans-unit id="1b1f6fd955e3dd56c20447476cad2f0ff374150c" translate="yes" xml:space="preserve">
          <source>Because the closure passed to &lt;code&gt;filter()&lt;/code&gt; takes a reference, and many iterators iterate over references, this leads to a possibly confusing situation, where the type of the closure is a double reference:</source>
          <target state="translated">Поскольку закрытие, переданное в &lt;code&gt;filter()&lt;/code&gt; принимает ссылку, а многие итераторы перебирают ссылки, это приводит к, возможно, запутанной ситуации, когда тип закрытия является двойной ссылкой:</target>
        </trans-unit>
        <trans-unit id="58c9579a8a89655df95e712d81cbf2a21bf02a65" translate="yes" xml:space="preserve">
          <source>Because the closure passed to &lt;code&gt;skip_while()&lt;/code&gt; takes a reference, and many iterators iterate over references, this leads to a possibly confusing situation, where the type of the closure is a double reference:</source>
          <target state="translated">Поскольку закрытие, переданное в &lt;code&gt;skip_while()&lt;/code&gt; принимает ссылку, а многие итераторы выполняют итерацию по ссылкам, это приводит к, возможно, запутанной ситуации, когда тип закрытия является двойной ссылкой:</target>
        </trans-unit>
        <trans-unit id="8479afb170cef741fbbcede9d3610679171e5033" translate="yes" xml:space="preserve">
          <source>Because the closure passed to &lt;code&gt;take_while()&lt;/code&gt; takes a reference, and many iterators iterate over references, this leads to a possibly confusing situation, where the type of the closure is a double reference:</source>
          <target state="translated">Поскольку закрытие, переданное в &lt;code&gt;take_while()&lt;/code&gt; принимает ссылку, а многие итераторы перебирают ссылки, это приводит к, возможно, запутанной ситуации, когда тип закрытия является двойной ссылкой:</target>
        </trans-unit>
        <trans-unit id="2eb937137f69efc7f4d05e71e805b680ad9ce55c" translate="yes" xml:space="preserve">
          <source>Because the correct result of the &lt;code&gt;can_hold&lt;/code&gt; function in this case is &lt;code&gt;false&lt;/code&gt;, we need to negate that result before we pass it to the &lt;code&gt;assert!&lt;/code&gt; macro. As a result, our test will pass if &lt;code&gt;can_hold&lt;/code&gt; returns &lt;code&gt;false&lt;/code&gt;:</source>
          <target state="translated">Поскольку правильный результат функции &lt;code&gt;can_hold&lt;/code&gt; в этом случае &lt;code&gt;false&lt;/code&gt; , нам нужно отрицать этот результат, прежде чем мы передадим его в &lt;code&gt;assert!&lt;/code&gt; макрос. В результате наш тест пройдёт, если &lt;code&gt;can_hold&lt;/code&gt; вернет &lt;code&gt;false&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="90666aa0415ee00d8f72df1807729b34de2b7424" translate="yes" xml:space="preserve">
          <source>Because the function item type explicitly identifies the function, the item types of different functions - different items, or the same item with different generics - are distinct, and mixing them will create a type error:</source>
          <target state="translated">Поскольку тип элемента функции явно идентифицирует функцию,то типы элементов различных функций-различные элементы или один и тот же элемент с разными генераторами-различаются,и их смешивание приведет к ошибке типа:</target>
        </trans-unit>
        <trans-unit id="91472ca2849f01f7f3aadf84c45216c15e72f922" translate="yes" xml:space="preserve">
          <source>Because the goal is to keep all these rules inside the structs that implement &lt;code&gt;State&lt;/code&gt;, we call a &lt;code&gt;content&lt;/code&gt; method on the value in &lt;code&gt;state&lt;/code&gt; and pass the post instance (that is, &lt;code&gt;self&lt;/code&gt;) as an argument. Then we return the value that is returned from using the &lt;code&gt;content&lt;/code&gt; method on the &lt;code&gt;state&lt;/code&gt; value.</source>
          <target state="translated">Поскольку цель состоит в том, чтобы сохранить все эти правила внутри структур, реализующих &lt;code&gt;State&lt;/code&gt; , мы вызываем метод &lt;code&gt;content&lt;/code&gt; для значения в &lt;code&gt;state&lt;/code&gt; и передаем экземпляр сообщения (то есть &lt;code&gt;self&lt;/code&gt; ) в качестве аргумента. Затем мы возвращаем значение, которое возвращается при использовании метода &lt;code&gt;content&lt;/code&gt; для значения &lt;code&gt;state&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="030b08f8ea47335b102e955f832da8f8f1553c44" translate="yes" xml:space="preserve">
          <source>Because the parameter names and the struct field names are exactly the same in Listing 5-4, we can use the &lt;em&gt;field init shorthand&lt;/em&gt; syntax to rewrite &lt;code&gt;build_user&lt;/code&gt; so that it behaves exactly the same but doesn&amp;rsquo;t have the repetition of &lt;code&gt;email&lt;/code&gt; and &lt;code&gt;username&lt;/code&gt;, as shown in Listing 5-5.</source>
          <target state="translated">Поскольку имена параметров и имена полей структуры в листинге 5-4 полностью совпадают, мы можем использовать &lt;em&gt;сокращенный&lt;/em&gt; синтаксис &lt;em&gt;field init,&lt;/em&gt; чтобы переписать &lt;code&gt;build_user&lt;/code&gt; так, чтобы он вел себя точно так же, но не повторял &lt;code&gt;email&lt;/code&gt; и &lt;code&gt;username&lt;/code&gt; , как показано в листинге 5-5.</target>
        </trans-unit>
        <trans-unit id="d69419dfb414355067e2d4508090380593ccdd03" translate="yes" xml:space="preserve">
          <source>Because the standard library has this blanket implementation, we can call the &lt;code&gt;to_string&lt;/code&gt; method defined by the &lt;code&gt;ToString&lt;/code&gt; trait on any type that implements the &lt;code&gt;Display&lt;/code&gt; trait. For example, we can turn integers into their corresponding &lt;code&gt;String&lt;/code&gt; values like this because integers implement &lt;code&gt;Display&lt;/code&gt;:</source>
          <target state="translated">Поскольку стандартная библиотека имеет эту общую реализацию, мы можем вызвать метод &lt;code&gt;to_string&lt;/code&gt; , определенный трейтом &lt;code&gt;ToString&lt;/code&gt; для любого типа, который реализует трейт &lt;code&gt;Display&lt;/code&gt; . Например, мы можем превратить целые числа в соответствующие им &lt;code&gt;String&lt;/code&gt; значения, как это, потому что целые числа реализуют &lt;code&gt;Display&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="37ef1e15d186d9fd04a65d1942d30d946ce68135" translate="yes" xml:space="preserve">
          <source>Because the third rule really only applies in method signatures, we&amp;rsquo;ll look at lifetimes in that context next to see why the third rule means we don&amp;rsquo;t have to annotate lifetimes in method signatures very often.</source>
          <target state="translated">Поскольку третье правило действительно применяется только в сигнатурах методов, мы рассмотрим время жизни в этом контексте, чтобы понять, почему третье правило означает, что нам не нужно очень часто аннотировать время жизни в сигнатурах методов.</target>
        </trans-unit>
        <trans-unit id="70d45c4687665d4e0a5b39f62a85fe258555be07" translate="yes" xml:space="preserve">
          <source>Because the value that &lt;code&gt;Weak&amp;lt;T&amp;gt;&lt;/code&gt; references might have been dropped, to do anything with the value that a &lt;code&gt;Weak&amp;lt;T&amp;gt;&lt;/code&gt; is pointing to, you must make sure the value still exists. Do this by calling the &lt;code&gt;upgrade&lt;/code&gt; method on a &lt;code&gt;Weak&amp;lt;T&amp;gt;&lt;/code&gt; instance, which will return an &lt;code&gt;Option&amp;lt;Rc&amp;lt;T&amp;gt;&amp;gt;&lt;/code&gt;. You&amp;rsquo;ll get a result of &lt;code&gt;Some&lt;/code&gt; if the &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; value has not been dropped yet and a result of &lt;code&gt;None&lt;/code&gt; if the &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; value has been dropped. Because &lt;code&gt;upgrade&lt;/code&gt; returns an &lt;code&gt;Option&amp;lt;Rc&amp;lt;T&amp;gt;&amp;gt;&lt;/code&gt;, Rust will ensure that the &lt;code&gt;Some&lt;/code&gt; case and the &lt;code&gt;None&lt;/code&gt; case are handled, and there won&amp;rsquo;t be an invalid pointer.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d8bf4707482fe4f59a8a059222ee5cf8616fe8ba" translate="yes" xml:space="preserve">
          <source>Because the value that &lt;code&gt;Weak&amp;lt;T&amp;gt;&lt;/code&gt; references might have been dropped, to do anything with the value that a &lt;code&gt;Weak&amp;lt;T&amp;gt;&lt;/code&gt; is pointing to, you must make sure the value still exists. Do this by calling the &lt;code&gt;upgrade&lt;/code&gt; method on a &lt;code&gt;Weak&amp;lt;T&amp;gt;&lt;/code&gt; instance, which will return an &lt;code&gt;Option&amp;lt;Rc&amp;lt;T&amp;gt;&amp;gt;&lt;/code&gt;. You&amp;rsquo;ll get a result of &lt;code&gt;Some&lt;/code&gt; if the &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; value has not been dropped yet and a result of &lt;code&gt;None&lt;/code&gt; if the &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; value has been dropped. Because &lt;code&gt;upgrade&lt;/code&gt; returns an &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt;, Rust will ensure that the &lt;code&gt;Some&lt;/code&gt; case and the &lt;code&gt;None&lt;/code&gt; case are handled, and there won&amp;rsquo;t be an invalid pointer.</source>
          <target state="translated">Поскольку значение, на которое ссылается &lt;code&gt;Weak&amp;lt;T&amp;gt;&lt;/code&gt; могло быть отброшено, чтобы сделать что-либо со значением, на которое указывает &lt;code&gt;Weak&amp;lt;T&amp;gt;&lt;/code&gt; , вы должны убедиться, что значение все еще существует. Сделайте это, вызвав метод &lt;code&gt;upgrade&lt;/code&gt; экземпляра &lt;code&gt;Weak&amp;lt;T&amp;gt;&lt;/code&gt; , который вернет &lt;code&gt;Option&amp;lt;Rc&amp;lt;T&amp;gt;&amp;gt;&lt;/code&gt; . Вы получите результат &lt;code&gt;Some&lt;/code&gt; , если значение &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; еще не было отброшено, и результат &lt;code&gt;None&lt;/code&gt; , если значение &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; было отброшено. Поскольку &lt;code&gt;upgrade&lt;/code&gt; возвращает &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt; , Rust гарантирует, что &lt;code&gt;Some&lt;/code&gt; case и &lt;code&gt;None&lt;/code&gt; case обрабатываются, и недействительного указателя не будет.</target>
        </trans-unit>
        <trans-unit id="14741fffc1dc74532e1921d454b0c26246f646ef" translate="yes" xml:space="preserve">
          <source>Because the vast majority of Rust projects use Cargo, the rest of this book assumes that you&amp;rsquo;re using Cargo too. Cargo comes installed with Rust if you used the official installers discussed in the &lt;a href=&quot;ch01-01-installation#installation&quot;&gt;&amp;ldquo;Installation&amp;rdquo;&lt;/a&gt; section. If you installed Rust through some other means, check whether Cargo is installed by entering the following into your terminal:</source>
          <target state="translated">Поскольку подавляющее большинство проектов на Rust используют Cargo, остальная часть этой книги предполагает, что вы тоже используете Cargo. Cargo поставляется с Rust, если вы использовали официальные установщики, описанные в разделе &lt;a href=&quot;ch01-01-installation#installation&quot;&gt;&amp;laquo;Установка&amp;raquo;&lt;/a&gt; . Если вы установили Rust каким-либо другим способом, проверьте, установлен ли Cargo, введя в свой терминал следующее:</target>
        </trans-unit>
        <trans-unit id="50d3009a3e9b08a6e3dea49369c4a3eff85c4a99" translate="yes" xml:space="preserve">
          <source>Because they are traits, &lt;a href=&quot;trait.read&quot;&gt;&lt;code&gt;Read&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;trait.write&quot;&gt;&lt;code&gt;Write&lt;/code&gt;&lt;/a&gt; are implemented by a number of other types, and you can implement them for your types too. As such, you'll see a few different types of I/O throughout the documentation in this module: &lt;a href=&quot;../fs/struct.file&quot;&gt;&lt;code&gt;File&lt;/code&gt;&lt;/a&gt;s, &lt;a href=&quot;../net/struct.tcpstream&quot;&gt;&lt;code&gt;TcpStream&lt;/code&gt;&lt;/a&gt;s, and sometimes even &lt;a href=&quot;../vec/struct.vec&quot;&gt;&lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt;s. For example, &lt;a href=&quot;trait.read&quot;&gt;&lt;code&gt;Read&lt;/code&gt;&lt;/a&gt; adds a &lt;a href=&quot;trait.read#tymethod.read&quot;&gt;&lt;code&gt;read&lt;/code&gt;&lt;/a&gt; method, which we can use on &lt;a href=&quot;../fs/struct.file&quot;&gt;&lt;code&gt;File&lt;/code&gt;&lt;/a&gt;s:</source>
          <target state="translated">Поскольку они являются чертами, &lt;a href=&quot;trait.read&quot;&gt; &lt;code&gt;Read&lt;/code&gt; &lt;/a&gt; и &lt;a href=&quot;trait.write&quot;&gt; &lt;code&gt;Write&lt;/code&gt; &lt;/a&gt; реализуются рядом других типов, и вы также можете реализовать их для своих типов. Таким образом, вы увидите несколько различных типов ввода-вывода в документации этого модуля: &lt;a href=&quot;../fs/struct.file&quot;&gt; &lt;code&gt;File&lt;/code&gt; &lt;/a&gt; s, &lt;a href=&quot;../net/struct.tcpstream&quot;&gt; &lt;code&gt;TcpStream&lt;/code&gt; &lt;/a&gt; s, а иногда даже &lt;a href=&quot;../vec/struct.vec&quot;&gt; &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; &lt;/a&gt; s. Например, &lt;a href=&quot;trait.read&quot;&gt; &lt;code&gt;Read&lt;/code&gt; &lt;/a&gt; добавляет метод &lt;a href=&quot;trait.read#tymethod.read&quot;&gt; &lt;code&gt;read&lt;/code&gt; &lt;/a&gt; , который мы можем использовать для &lt;a href=&quot;../fs/struct.file&quot;&gt; &lt;code&gt;File&lt;/code&gt; &lt;/a&gt; s:</target>
        </trans-unit>
        <trans-unit id="e07ae336ff59e9ed0b225ca89429b661de0679cf" translate="yes" xml:space="preserve">
          <source>Because this declaration is in the &lt;code&gt;std::io&lt;/code&gt; module, we can use the fully qualified alias &lt;code&gt;std::io::Result&amp;lt;T&amp;gt;&lt;/code&gt;&amp;mdash;that is, a &lt;code&gt;Result&amp;lt;T, E&amp;gt;&lt;/code&gt; with the &lt;code&gt;E&lt;/code&gt; filled in as &lt;code&gt;std::io::Error&lt;/code&gt;. The &lt;code&gt;Write&lt;/code&gt; trait function signatures end up looking like this:</source>
          <target state="translated">Поскольку это объявление находится в модуле &lt;code&gt;std::io&lt;/code&gt; , мы можем использовать полный псевдоним &lt;code&gt;std::io::Result&amp;lt;T&amp;gt;&lt;/code&gt; то есть &lt;code&gt;Result&amp;lt;T, E&amp;gt;&lt;/code&gt; с &lt;code&gt;E&lt;/code&gt; , заполненным как &lt;code&gt;std::io::Error&lt;/code&gt; . В &lt;code&gt;Write&lt;/code&gt; сигнатуры функции Trait в конечном итоге выглядит так:</target>
        </trans-unit>
        <trans-unit id="4d78cf22aaa22c544c68896425f6652ea68b656d" translate="yes" xml:space="preserve">
          <source>Because this error message starts with the text we specified, &lt;code&gt;Failed to open hello.txt&lt;/code&gt;, it will be easier to find where in the code this error message is coming from. If we use &lt;code&gt;unwrap&lt;/code&gt; in multiple places, it can take more time to figure out exactly which &lt;code&gt;unwrap&lt;/code&gt; is causing the panic because all &lt;code&gt;unwrap&lt;/code&gt; calls that panic print the same message.</source>
          <target state="translated">Поскольку это сообщение об ошибке начинается с указанного нами текста &amp;laquo; &lt;code&gt;Failed to open hello.txt&lt;/code&gt; , будет легче найти, откуда в коде это сообщение об ошибке. Если мы используем &lt;code&gt;unwrap&lt;/code&gt; в разных местах, это может занять больше времени , чтобы выяснить , какие именно &lt;code&gt;unwrap&lt;/code&gt; вызывает панику , потому что все &lt;code&gt;unwrap&lt;/code&gt; вызовов, паника печать то же самое сообщение.</target>
        </trans-unit>
        <trans-unit id="f9ecc9d043c4a1c0a98d5acfc2202fd98ea778e6" translate="yes" xml:space="preserve">
          <source>Because this function may panic, its use is generally discouraged. Instead, prefer to use pattern matching and handle the &lt;a href=&quot;enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt; case explicitly, or call &lt;a href=&quot;enum.option#method.unwrap_or&quot;&gt;&lt;code&gt;unwrap_or&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;enum.option#method.unwrap_or_else&quot;&gt;&lt;code&gt;unwrap_or_else&lt;/code&gt;&lt;/a&gt;, or &lt;a href=&quot;enum.option#method.unwrap_or_default&quot;&gt;&lt;code&gt;unwrap_or_default&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="324230b46d81d1ff99203ce38c74a82aa7a9a294" translate="yes" xml:space="preserve">
          <source>Because this function may panic, its use is generally discouraged. Instead, prefer to use pattern matching and handle the &lt;a href=&quot;enum.result#variant.Err&quot;&gt;&lt;code&gt;Err&lt;/code&gt;&lt;/a&gt; case explicitly, or call &lt;a href=&quot;enum.result#method.unwrap_or&quot;&gt;&lt;code&gt;unwrap_or&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;enum.result#method.unwrap_or_else&quot;&gt;&lt;code&gt;unwrap_or_else&lt;/code&gt;&lt;/a&gt;, or &lt;a href=&quot;enum.result#method.unwrap_or_default&quot;&gt;&lt;code&gt;unwrap_or_default&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f4fba9e24de13af0b7e1e106a0a89b1207341158" translate="yes" xml:space="preserve">
          <source>Because this representation delegates type layout to another type, it cannot be used with any other representation.</source>
          <target state="translated">Так как это представление делегирует тип в другой тип,оно не может быть использовано с любым другим представлением.</target>
        </trans-unit>
        <trans-unit id="210e09fafaa62c8b440f8de035b1059405d433ec" translate="yes" xml:space="preserve">
          <source>Because transparent enums are represented exactly like one of their variants at run time, said variant must be uniquely determined. If there is no variant, or if there are multiple variants, it is not clear how the enum should be represented.</source>
          <target state="translated">Поскольку прозрачные перечисления представлены в точности так же,как и один из их вариантов во время работы,этот вариант должен быть однозначно определен.Если нет,или если есть несколько вариантов,то непонятно,как должно быть представлено перечисление.</target>
        </trans-unit>
        <trans-unit id="fcd01a50be2628ee7e2de7196f3290d3a3e7d1ae" translate="yes" xml:space="preserve">
          <source>Because transparent structs are represented exactly like one of their fields at run time, said field must be uniquely determined. If there is no field, or if there are multiple fields, it is not clear how the struct should be represented. Note that fields of zero-sized types (e.g., &lt;code&gt;PhantomData&lt;/code&gt;) can also exist alongside the field that contains the actual data, they do not count for this error. When generic types are involved (as in the above example), an error is reported because the type parameter could be non-zero-sized.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="986c4abde2bf1faaf2d6c694b66e22c945ede5c1" translate="yes" xml:space="preserve">
          <source>Because transparent structs are represented exactly like one of their fields at run time, said field must be uniquely determined. If there is no field, or if there are multiple fields, it is not clear how the struct should be represented. Note that fields of zero-typed types (e.g., &lt;code&gt;PhantomData&lt;/code&gt;) can also exist alongside the field that contains the actual data, they do not count for this error. When generic types are involved (as in the above example), an error is reported because the type parameter could be non-zero-sized.</source>
          <target state="translated">Поскольку прозрачные структуры представляются точно так же, как одно из их полей во время выполнения, это поле должно быть однозначно определено. Если поля нет или есть несколько полей, неясно, как должна быть представлена ​​структура. Обратите внимание, что поля типов с нулевым типом (например, &lt;code&gt;PhantomData&lt;/code&gt; ) также могут существовать вместе с полем, содержащим фактические данные, они не учитываются для этой ошибки. Когда задействованы универсальные типы (как в приведенном выше примере), выдается сообщение об ошибке, поскольку параметр типа может иметь ненулевой размер.</target>
        </trans-unit>
        <trans-unit id="f937fa2c0a9f5f4a819643c4edaf58d80a839cab" translate="yes" xml:space="preserve">
          <source>Because tuple elements don't have a name, they can only be accessed by pattern-matching or by using &lt;code&gt;N&lt;/code&gt; directly as a field to access the &lt;code&gt;N&lt;/code&gt;th element.</source>
          <target state="translated">Поскольку элементы кортежа не имеют имени, к ним можно получить доступ только путем сопоставления с образцом или путем прямого использования &lt;code&gt;N&lt;/code&gt; в качестве поля для доступа к &lt;code&gt;N&lt;/code&gt; - му элементу.</target>
        </trans-unit>
        <trans-unit id="efb0d44a57a7bf30820d634e0cfe1255770c836f" translate="yes" xml:space="preserve">
          <source>Because two equal values need to produce the same hash value, the implementation of &lt;code&gt;Hash&lt;/code&gt; needs to ignore ASCII case, too:</source>
          <target state="translated">Поскольку два равных значения должны давать одно и то же значение хеш-функции, реализация &lt;code&gt;Hash&lt;/code&gt; также должна игнорировать регистр ASCII:</target>
        </trans-unit>
        <trans-unit id="b787dccee7a3448c9761d599ebe1a0e8e174bf88" translate="yes" xml:space="preserve">
          <source>Because types that are made up of &lt;code&gt;Send&lt;/code&gt; and &lt;code&gt;Sync&lt;/code&gt; traits are automatically also &lt;code&gt;Send&lt;/code&gt; and &lt;code&gt;Sync&lt;/code&gt;, we don&amp;rsquo;t have to implement those traits manually. As marker traits, they don&amp;rsquo;t even have any methods to implement. They&amp;rsquo;re just useful for enforcing invariants related to concurrency.</source>
          <target state="translated">Поскольку типы, состоящие из признаков &lt;code&gt;Send&lt;/code&gt; и &lt;code&gt;Sync&lt;/code&gt; , автоматически также являются &lt;code&gt;Send&lt;/code&gt; и &lt;code&gt;Sync&lt;/code&gt; , нам не нужно реализовывать эти свойства вручную. В качестве маркерных черт у них даже нет методов для реализации. Они просто полезны для обеспечения соблюдения инвариантов, связанных с параллелизмом.</target>
        </trans-unit>
        <trans-unit id="e80dfd56aee472a3a988ee77f8d092b4c7dec341" translate="yes" xml:space="preserve">
          <source>Because we called the function with &lt;code&gt;5&lt;/code&gt; as the value for &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;6&lt;/code&gt; is passed as the value for &lt;code&gt;y&lt;/code&gt;, the two strings are printed with these values.</source>
          <target state="translated">Поскольку мы вызвали функцию с &lt;code&gt;5&lt;/code&gt; в качестве значения для &lt;code&gt;x&lt;/code&gt; и &lt;code&gt;6&lt;/code&gt; передается как значение для &lt;code&gt;y&lt;/code&gt; , две строки печатаются с этими значениями.</target>
        </trans-unit>
        <trans-unit id="085b82e8e32a790482293e536266e4e46e15732c" translate="yes" xml:space="preserve">
          <source>Because we didn&amp;rsquo;t cover (and couldn&amp;rsquo;t cover!) every valid value with the pattern &lt;code&gt;Some(x)&lt;/code&gt;, Rust rightfully produces a compiler error.</source>
          <target state="translated">Поскольку мы не охватили (и не смогли охватить!) Каждое допустимое значение с помощью шаблона &lt;code&gt;Some(x)&lt;/code&gt; , Rust по праву выдает ошибку компилятора.</target>
        </trans-unit>
        <trans-unit id="c4e7a282ae038191d5b4c16b5d5eaad3c33d3637" translate="yes" xml:space="preserve">
          <source>Because we don&amp;rsquo;t have any code that pauses or delays in the &lt;code&gt;for&lt;/code&gt; loop in the main thread, we can tell that the main thread is waiting to receive values from the spawned thread.</source>
          <target state="translated">Поскольку у нас нет кода, который приостанавливает или задерживает цикл &lt;code&gt;for&lt;/code&gt; в основном потоке, мы можем сказать, что основной поток ожидает получения значений от порожденного потока.</target>
        </trans-unit>
        <trans-unit id="9a0bac08c9a7a0c19671aaf3dbc27401041da77e" translate="yes" xml:space="preserve">
          <source>Because we don&amp;rsquo;t have any tests we&amp;rsquo;ve marked as ignored, the summary shows &lt;code&gt;0 ignored&lt;/code&gt;. We also haven&amp;rsquo;t filtered the tests being run, so the end of the summary shows &lt;code&gt;0 filtered out&lt;/code&gt;. We&amp;rsquo;ll talk about ignoring and filtering out tests in the next section, &lt;a href=&quot;ch11-02-running-tests#controlling-how-tests-are-run&quot;&gt;&amp;ldquo;Controlling How Tests Are Run.&amp;rdquo;&lt;/a&gt;</source>
          <target state="translated">Поскольку у нас нет тестов, которые мы пометили как игнорируемые, в сводке отображается &lt;code&gt;0 ignored&lt;/code&gt; . Мы также не отфильтровали выполняемые тесты, поэтому в конце сводки отображается &lt;code&gt;0 filtered out&lt;/code&gt; . Мы поговорим об игнорировании и фильтрации тестов в следующем разделе &lt;a href=&quot;ch11-02-running-tests#controlling-how-tests-are-run&quot;&gt;&amp;laquo;Управление выполнением тестов&amp;raquo;.&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="19d2af6731059978bb0fd7b94ea0d510b217b381" translate="yes" xml:space="preserve">
          <source>Because we don&amp;rsquo;t need them anymore, let&amp;rsquo;s remove the &lt;code&gt;println!&lt;/code&gt; statements from &lt;em&gt;src/lib.rs&lt;/em&gt; and &lt;em&gt;src/main.rs&lt;/em&gt; that we used to check the program&amp;rsquo;s behavior. Then, in &lt;em&gt;src/lib.rs&lt;/em&gt;, we&amp;rsquo;ll add a &lt;code&gt;tests&lt;/code&gt; module with a test function, as we did in &lt;a href=&quot;ch11-01-writing-tests#the-anatomy-of-a-test-function&quot;&gt;Chapter 11&lt;/a&gt;. The test function specifies the behavior we want the &lt;code&gt;search&lt;/code&gt; function to have: it will take a query and the text to search for the query in, and it will return only the lines from the text that contain the query. Listing 12-15 shows this test, which won&amp;rsquo;t compile yet.</source>
          <target state="translated">Поскольку они нам больше не нужны, давайте удалим &lt;code&gt;println!&lt;/code&gt; операторы из &lt;em&gt;src / lib.rs&lt;/em&gt; и &lt;em&gt;src / main.rs,&lt;/em&gt; которые мы использовали для проверки поведения программы. Затем в &lt;em&gt;src / lib.rs&lt;/em&gt; мы добавим модуль &lt;code&gt;tests&lt;/code&gt; с функцией тестирования, как мы это сделали в &lt;a href=&quot;ch11-01-writing-tests#the-anatomy-of-a-test-function&quot;&gt;главе 11&lt;/a&gt; . Тестовая функция определяет поведение, которое мы хотим, чтобы функция &lt;code&gt;search&lt;/code&gt; имела: она будет принимать запрос и текст для поиска запроса, и она вернет только те строки из текста, которые содержат запрос. В листинге 12-15 показан этот тест, который еще не компилируется.</target>
        </trans-unit>
        <trans-unit id="27d7fc6d652236fca2f45fe08fc889c62e6d8253" translate="yes" xml:space="preserve">
          <source>Because we just mentioned coins, let&amp;rsquo;s use them as an example using &lt;code&gt;match&lt;/code&gt;! We can write a function that can take an unknown United States coin and, in a similar way as the counting machine, determine which coin it is and return its value in cents, as shown here in Listing 6-3.</source>
          <target state="translated">Поскольку мы только что упомянули монеты, давайте использовать их в качестве примера, используя &lt;code&gt;match&lt;/code&gt; ! Мы можем написать функцию, которая может принимать неизвестную монету Соединенных Штатов и, подобно счетной машине, определять, какая это монета, и возвращать ее стоимость в центах, как показано здесь в листинге 6-3.</target>
        </trans-unit>
        <trans-unit id="564bbf6a7d7bf6b1e61c40462e20a2bae78026d7" translate="yes" xml:space="preserve">
          <source>Because we made the &lt;code&gt;Appetizer&lt;/code&gt; enum public, we can use the &lt;code&gt;Soup&lt;/code&gt; and &lt;code&gt;Salad&lt;/code&gt; variants in &lt;code&gt;eat_at_restaurant&lt;/code&gt;. Enums aren&amp;rsquo;t very useful unless their variants are public; it would be annoying to have to annotate all enum variants with &lt;code&gt;pub&lt;/code&gt; in every case, so the default for enum variants is to be public. Structs are often useful without their fields being public, so struct fields follow the general rule of everything being private by default unless annotated with &lt;code&gt;pub&lt;/code&gt;.</source>
          <target state="translated">Поскольку мы сделали перечисление &lt;code&gt;Appetizer&lt;/code&gt; общедоступным, мы можем использовать варианты &lt;code&gt;Soup&lt;/code&gt; и &lt;code&gt;Salad&lt;/code&gt; в &lt;code&gt;eat_at_restaurant&lt;/code&gt; . Перечисления не очень полезны, если их варианты не являются общедоступными; было бы неприятно аннотировать все варианты перечисления с помощью &lt;code&gt;pub&lt;/code&gt; в каждом случае, поэтому по умолчанию для вариантов перечисления должно быть открыто. Структуры часто полезны без того, чтобы их поля были общедоступными, поэтому поля структуры следуют общему правилу, согласно которому все по умолчанию является закрытым, если не аннотировано с помощью &lt;code&gt;pub&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e429697f925edbd87724bb6af67eea48f644c38e" translate="yes" xml:space="preserve">
          <source>Because we need to go through the &lt;code&gt;String&lt;/code&gt; element by element and check whether a value is a space, we&amp;rsquo;ll convert our &lt;code&gt;String&lt;/code&gt; to an array of bytes using the &lt;code&gt;as_bytes&lt;/code&gt; method:</source>
          <target state="translated">Поскольку нам нужно пройти по элементу &lt;code&gt;String&lt;/code&gt; и проверить, является ли значение пробелом, мы преобразуем нашу &lt;code&gt;String&lt;/code&gt; в массив байтов с &lt;code&gt;as_bytes&lt;/code&gt; метода as_bytes :</target>
        </trans-unit>
        <trans-unit id="78563068540adbc0f963cccfafb7b2fef86f3a05" translate="yes" xml:space="preserve">
          <source>Because we&amp;rsquo;ve encapsulated the implementation details of the struct &lt;code&gt;AveragedCollection&lt;/code&gt;, we can easily change aspects, such as the data structure, in the future. For instance, we could use a &lt;code&gt;HashSet&amp;lt;i32&amp;gt;&lt;/code&gt; instead of a &lt;code&gt;Vec&amp;lt;i32&amp;gt;&lt;/code&gt; for the &lt;code&gt;list&lt;/code&gt; field. As long as the signatures of the &lt;code&gt;add&lt;/code&gt;, &lt;code&gt;remove&lt;/code&gt;, and &lt;code&gt;average&lt;/code&gt; public methods stay the same, code using &lt;code&gt;AveragedCollection&lt;/code&gt; wouldn&amp;rsquo;t need to change. If we made &lt;code&gt;list&lt;/code&gt; public instead, this wouldn&amp;rsquo;t necessarily be the case: &lt;code&gt;HashSet&amp;lt;i32&amp;gt;&lt;/code&gt; and &lt;code&gt;Vec&amp;lt;i32&amp;gt;&lt;/code&gt; have different methods for adding and removing items, so the external code would likely have to change if it were modifying &lt;code&gt;list&lt;/code&gt; directly.</source>
          <target state="translated">Поскольку мы инкапсулировали детали реализации структуры &lt;code&gt;AveragedCollection&lt;/code&gt; , мы можем легко изменить аспекты, такие как структура данных, в будущем. Например, мы могли бы использовать &lt;code&gt;HashSet&amp;lt;i32&amp;gt;&lt;/code&gt; вместо &lt;code&gt;Vec&amp;lt;i32&amp;gt;&lt;/code&gt; для поля &lt;code&gt;list&lt;/code&gt; . Пока подписи общедоступных методов &lt;code&gt;add&lt;/code&gt; , &lt;code&gt;remove&lt;/code&gt; и &lt;code&gt;average&lt;/code&gt; остаются неизменными, код, использующий &lt;code&gt;AveragedCollection&lt;/code&gt; , изменять не нужно. Если вместо этого мы сделаем &lt;code&gt;list&lt;/code&gt; общедоступным, это не обязательно будет иметь место: &lt;code&gt;HashSet&amp;lt;i32&amp;gt;&lt;/code&gt; и &lt;code&gt;Vec&amp;lt;i32&amp;gt;&lt;/code&gt; имеют разные методы для добавления и удаления элементов, поэтому внешний код, вероятно, придется изменить, если он изменяет &lt;code&gt;list&lt;/code&gt; напрямую.</target>
        </trans-unit>
        <trans-unit id="012f083807416b28f83d8847eef6766da2f64d4c" translate="yes" xml:space="preserve">
          <source>Because we&amp;rsquo;ve given initial &lt;code&gt;i32&lt;/code&gt; values, Rust can infer that the type of &lt;code&gt;v&lt;/code&gt; is &lt;code&gt;Vec&amp;lt;i32&amp;gt;&lt;/code&gt;, and the type annotation isn&amp;rsquo;t necessary. Next, we&amp;rsquo;ll look at how to modify a vector.</source>
          <target state="translated">Поскольку мы &lt;code&gt;i32&lt;/code&gt; начальные значения i32 , Rust может сделать вывод, что тип &lt;code&gt;v&lt;/code&gt; - &lt;code&gt;Vec&amp;lt;i32&amp;gt;&lt;/code&gt; , и аннотация типа не требуется. Далее мы посмотрим, как изменить вектор.</target>
        </trans-unit>
        <trans-unit id="9fe6f6ecc3242b6ec15902f2774b2a48334d7481" translate="yes" xml:space="preserve">
          <source>Because we&amp;rsquo;ve specified that &lt;code&gt;OutlinePrint&lt;/code&gt; requires the &lt;code&gt;Display&lt;/code&gt; trait, we can use the &lt;code&gt;to_string&lt;/code&gt; function that is automatically implemented for any type that implements &lt;code&gt;Display&lt;/code&gt;. If we tried to use &lt;code&gt;to_string&lt;/code&gt; without adding a colon and specifying the &lt;code&gt;Display&lt;/code&gt; trait after the trait name, we&amp;rsquo;d get an error saying that no method named &lt;code&gt;to_string&lt;/code&gt; was found for the type &lt;code&gt;&amp;amp;Self&lt;/code&gt; in the current scope.</source>
          <target state="translated">Поскольку мы указали, что &lt;code&gt;OutlinePrint&lt;/code&gt; требует признака &lt;code&gt;Display&lt;/code&gt; , мы можем использовать функцию &lt;code&gt;to_string&lt;/code&gt; , которая автоматически реализуется для любого типа, реализующего &lt;code&gt;Display&lt;/code&gt; . Если бы мы попытались использовать &lt;code&gt;to_string&lt;/code&gt; без добавления двоеточия и указания признака &lt;code&gt;Display&lt;/code&gt; после имени признака, мы бы получили сообщение об ошибке о том, что для типа &lt;code&gt;&amp;amp;Self&lt;/code&gt; в текущей области не найден метод с именем &lt;code&gt;to_string&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="627748e661f805aeaed04a41d6aadf854f4f0452" translate="yes" xml:space="preserve">
          <source>Because we're not buffering, we write each one in turn, incurring the overhead of a system call per byte written. We can fix this with a &lt;code&gt;BufWriter&amp;lt;W&amp;gt;&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a715fdf861e47ef758515cd362976557a262f981" translate="yes" xml:space="preserve">
          <source>Because we're not buffering, we write each one in turn, incurring the overhead of a system call per byte written. We can fix this with a &lt;code&gt;BufWriter&lt;/code&gt;:</source>
          <target state="translated">Поскольку мы не буферизуем, мы записываем каждый из них по очереди, что приводит к накладным расходам системного вызова на каждый записанный байт. Мы можем исправить это с помощью &lt;code&gt;BufWriter&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="cbd558490c4d9352a7af3024ff9549f8d11edc55" translate="yes" xml:space="preserve">
          <source>Because you can stack-allocate a &lt;code&gt;[u8; N]&lt;/code&gt;, and you can take a &lt;a href=&quot;../primitive.slice&quot;&gt;&lt;code&gt;&amp;amp;[u8]&lt;/code&gt;&lt;/a&gt; of it, this function is one way to have a stack-allocated string. There is an example of this in the examples section below.</source>
          <target state="translated">Поскольку вы можете выделить в &lt;code&gt;[u8; N]&lt;/code&gt; , и вы можете взять его &lt;a href=&quot;../primitive.slice&quot;&gt; &lt;code&gt;&amp;amp;[u8]&lt;/code&gt; &lt;/a&gt; , эта функция - один из способов получить строку, выделенную стеком. Пример этого можно найти в разделе примеров ниже.</target>
        </trans-unit>
        <trans-unit id="abb004f87792d4a102d3232d143d81ed4ffc2ed8" translate="yes" xml:space="preserve">
          <source>Before an expression used as a &lt;a href=&quot;statements&quot;&gt;statement&lt;/a&gt;.</source>
          <target state="translated">Перед выражением, используемым как &lt;a href=&quot;statements&quot;&gt;утверждение&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="6fb622789c9cc297dc766f85b7b47e7c5b64a4c2" translate="yes" xml:space="preserve">
          <source>Before diving into generics syntax, let&amp;rsquo;s first look at how to remove duplication that doesn&amp;rsquo;t involve generic types by extracting a function. Then we&amp;rsquo;ll apply this technique to extract a generic function! In the same way that you recognize duplicated code to extract into a function, you&amp;rsquo;ll start to recognize duplicated code that can use generics.</source>
          <target state="translated">Прежде чем погрузиться в синтаксис универсальных типов, давайте сначала посмотрим, как удалить дублирование, не связанное с универсальными типами, путем извлечения функции. Затем мы применим эту технику для извлечения универсальной функции! Точно так же, как вы распознаете дублированный код для извлечения в функцию, вы начнете распознавать дублированный код, который может использовать дженерики.</target>
        </trans-unit>
        <trans-unit id="beaf5bffc2c85ad951a60c9ddac3eebe2cec9b8f" translate="yes" xml:space="preserve">
          <source>Before explaining more, let's talk about how this module is structured:</source>
          <target state="translated">Прежде чем объяснить подробнее,давайте поговорим о том,как устроен этот модуль:</target>
        </trans-unit>
        <trans-unit id="cd09ad07440aee110c115ad35adea181d0515ee9" translate="yes" xml:space="preserve">
          <source>Before running a Rust program, you must compile it using the Rust compiler by entering the &lt;code&gt;rustc&lt;/code&gt; command and passing it the name of your source file, like this:</source>
          <target state="translated">Перед запуском программы на Rust вы должны скомпилировать ее с помощью компилятора Rust, введя команду &lt;code&gt;rustc&lt;/code&gt; и передав ей имя вашего исходного файла, например:</target>
        </trans-unit>
        <trans-unit id="992020b016b482ffafd2657fccaa8d509f2063e9" translate="yes" xml:space="preserve">
          <source>Before the loop, we declare a variable named &lt;code&gt;counter&lt;/code&gt; and initialize it to &lt;code&gt;0&lt;/code&gt;. Then we declare a variable named &lt;code&gt;result&lt;/code&gt; to hold the value returned from the loop. On every iteration of the loop, we add &lt;code&gt;1&lt;/code&gt; to the &lt;code&gt;counter&lt;/code&gt; variable, and then check whether the counter is equal to &lt;code&gt;10&lt;/code&gt;. When it is, we use the &lt;code&gt;break&lt;/code&gt; keyword with the value &lt;code&gt;counter * 2&lt;/code&gt;. After the loop, we use a semicolon to end the statement that assigns the value to &lt;code&gt;result&lt;/code&gt;. Finally, we print the value in &lt;code&gt;result&lt;/code&gt;, which in this case is 20.</source>
          <target state="translated">Перед циклом мы объявляем переменную с именем &lt;code&gt;counter&lt;/code&gt; и инициализируем ее значением &lt;code&gt;0&lt;/code&gt; . Затем мы объявляем переменную с именем &lt;code&gt;result&lt;/code&gt; для хранения значения, возвращаемого из цикла. На каждой итерации цикла мы добавляем &lt;code&gt;1&lt;/code&gt; к переменной &lt;code&gt;counter&lt;/code&gt; , а затем проверяем, равен ли счетчик &lt;code&gt;10&lt;/code&gt; . Когда это так, мы используем ключевое слово &lt;code&gt;break&lt;/code&gt; со &lt;code&gt;counter * 2&lt;/code&gt; значений * 2 . После цикла мы используем точку с запятой в конце оператора, который присваивает значение &lt;code&gt;result&lt;/code&gt; . Наконец, мы печатаем &lt;code&gt;result&lt;/code&gt; , который в данном случае равен 20.</target>
        </trans-unit>
        <trans-unit id="31a496e8ed09fdd1bd621c7cc15fdcecbd8eebc7" translate="yes" xml:space="preserve">
          <source>Before we begin implementing a thread pool, let&amp;rsquo;s talk about what using the pool should look like. When you&amp;rsquo;re trying to design code, writing the client interface first can help guide your design. Write the API of the code so it&amp;rsquo;s structured in the way you want to call it; then implement the functionality within that structure rather than implementing the functionality and then designing the public API.</source>
          <target state="translated">Прежде чем мы начнем реализацию пула потоков, давайте поговорим о том, как должно выглядеть использование пула. Когда вы пытаетесь спроектировать код, написание сначала клиентского интерфейса может помочь вам в разработке. Напишите API кода, чтобы он был структурирован так, как вы хотите его вызывать; затем реализовать функциональность внутри этой структуры, а не реализовывать функциональность и затем разрабатывать общедоступный API.</target>
        </trans-unit>
        <trans-unit id="5531bdacd5e27e11cff8fcc2e36e3c004527f8b8" translate="yes" xml:space="preserve">
          <source>Before we discuss this use case for &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt;, we&amp;rsquo;ll cover the syntax and how to interact with values stored within a &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">Прежде чем обсуждать этот вариант использования &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; , мы рассмотрим синтаксис и способы взаимодействия со значениями, хранящимися в &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d85d751d3cdedcf3deebd350f36e7cb28a00a5d2" translate="yes" xml:space="preserve">
          <source>Before we go into more details to explain the guarantees and choices associated with &lt;code&gt;Pin&amp;lt;T&amp;gt;&lt;/code&gt;, we discuss some examples for how it might be used. Feel free to &lt;a href=&quot;#drop-guarantee&quot;&gt;skip to where the theoretical discussion continues&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1e5cb50dd4a282df49da6b5ffaeda1d9ab676ba8" translate="yes" xml:space="preserve">
          <source>Before you can publish any crates, you need to create an account on &lt;a href=&quot;https://crates.io/&quot;&gt;crates.io&lt;/a&gt; and get an API token. To do so, visit the home page at &lt;a href=&quot;https://crates.io/&quot;&gt;crates.io&lt;/a&gt; and log in via a GitHub account. (The GitHub account is currently a requirement, but the site might support other ways of creating an account in the future.) Once you&amp;rsquo;re logged in, visit your account settings at &lt;a href=&quot;https://crates.io/me/&quot;&gt;https://crates.io/me/&lt;/a&gt; and retrieve your API key. Then run the &lt;code&gt;cargo login&lt;/code&gt; command with your API key, like this:</source>
          <target state="translated">Прежде чем вы сможете публиковать какие-либо ящики, вам необходимо создать учетную запись на &lt;a href=&quot;https://crates.io/&quot;&gt;crates.io&lt;/a&gt; и получить токен API. Для этого посетите домашнюю страницу &lt;a href=&quot;https://crates.io/&quot;&gt;crates.io&lt;/a&gt; и войдите в систему через учетную запись GitHub. (Учетная запись GitHub в настоящее время является обязательным требованием, но сайт может поддерживать другие способы создания учетной записи в будущем.) После входа в систему перейдите в настройки своей учетной записи на &lt;a href=&quot;https://crates.io/me/&quot;&gt;https://crates.io/me/&lt;/a&gt; и получите Ключ API. Затем запустите команду &lt;code&gt;cargo login&lt;/code&gt; Cargo с вашим ключом API, например:</target>
        </trans-unit>
        <trans-unit id="842beb51ca9c5417a27f472386d0e0d52dcc074f" translate="yes" xml:space="preserve">
          <source>Before:</source>
          <target state="translated">Before:</target>
        </trans-unit>
        <trans-unit id="bb11daf93347e89962e3d0ed85d6b809ec3ab729" translate="yes" xml:space="preserve">
          <source>Beginning in the 2018 edition, &lt;a href=&quot;use-declarations&quot;&gt;use declarations&lt;/a&gt; can reference crates in the extern prelude, so it is considered unidiomatic to use &lt;code&gt;extern crate&lt;/code&gt;.</source>
          <target state="translated">Начиная с версии 2018, &lt;a href=&quot;use-declarations&quot;&gt;объявления use&lt;/a&gt; могут ссылаться на ящики в прелюдии extern, поэтому использование &lt;code&gt;extern crate&lt;/code&gt; считается неидиоматичным .</target>
        </trans-unit>
        <trans-unit id="f69c63a9aa10f7772ed95a8efc915f42e685135b" translate="yes" xml:space="preserve">
          <source>Beginning in the 2018 edition, &lt;code&gt;dyn&lt;/code&gt; has been promoted to a strict keyword.</source>
          <target state="translated">Начиная с версии 2018 года, ключевое слово &lt;code&gt;dyn&lt;/code&gt; было повышено до строгого.</target>
        </trans-unit>
        <trans-unit id="747fb066bbb4af54f78aaa8f212256984b77092b" translate="yes" xml:space="preserve">
          <source>Beginning in the 2018 edition, &lt;code&gt;dyn&lt;/code&gt; is a true keyword and is not allowed in paths, so the parentheses are not necessary.</source>
          <target state="translated">Начиная с версии 2018, &lt;code&gt;dyn&lt;/code&gt; является истинным ключевым словом и не допускается в путях, поэтому скобки не нужны.</target>
        </trans-unit>
        <trans-unit id="88113dc243c443e4dd51d39dc5f37a435a2966eb" translate="yes" xml:space="preserve">
          <source>Beginning in the 2018 edition, function or method parameter patterns are no longer optional. Also, all irrefutable patterns are allowed as long as there is a body. Without a body, the limitations listed above are still in effect.</source>
          <target state="translated">Начиная с редакции 2018 года,образцы параметров функций или методов больше не являются необязательными.Кроме того,все неопровержимые шаблоны допускаются до тех пор,пока есть тело.Без тела ограничения,перечисленные выше,остаются в силе.</target>
        </trans-unit>
        <trans-unit id="72201b43a6b1623bf8606d5ddd5bead0602a3d00" translate="yes" xml:space="preserve">
          <source>Beginning with the 2018 Edition, paths starting with &lt;code&gt;::&lt;/code&gt; can only reference crates.</source>
          <target state="translated">Начиная с версии 2018, пути, начинающиеся с &lt;code&gt;::&lt;/code&gt; , могут ссылаться только на ящики.</target>
        </trans-unit>
        <trans-unit id="020cfc8d7ce4473da0deda931f3cf2410d4b4068" translate="yes" xml:space="preserve">
          <source>Behaves like &lt;code&gt;alloc&lt;/code&gt;, but also ensures that the contents are set to zero before being returned.</source>
          <target state="translated">Действует аналогично &lt;code&gt;alloc&lt;/code&gt; , но также обеспечивает нулевое значение содержимого перед возвратом.</target>
        </trans-unit>
        <trans-unit id="26b6dab3100989fb3cbafd53582c862ac5c9f9f9" translate="yes" xml:space="preserve">
          <source>Behaves like &lt;code&gt;alloc&lt;/code&gt;, but also ensures that the contents are set to zero before being returned. &lt;a href=&quot;trait.alloc#method.alloc_zeroed&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">Действует аналогично &lt;code&gt;alloc&lt;/code&gt; , но также обеспечивает нулевое значение содержимого перед возвратом. &lt;a href=&quot;trait.alloc#method.alloc_zeroed&quot;&gt;Читать далее&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="cebb7ac8ceac00cf4605e1537d21a42ae0a8334d" translate="yes" xml:space="preserve">
          <source>Behaves like &lt;code&gt;alloc&lt;/code&gt;, but also ensures that the contents are set to zero before being returned. &lt;a href=&quot;trait.globalalloc#method.alloc_zeroed&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">Действует аналогично &lt;code&gt;alloc&lt;/code&gt; , но также обеспечивает нулевое значение содержимого перед возвратом. &lt;a href=&quot;trait.globalalloc#method.alloc_zeroed&quot;&gt;Читать далее&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="082a664b538f66f0a51ac4134a98aba6f77d5cde" translate="yes" xml:space="preserve">
          <source>Behaves like &lt;code&gt;alloc&lt;/code&gt;, but also ensures that the returned memory is zero-initialized. &lt;a href=&quot;alloc/trait.allocref#method.alloc_zeroed&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="be234e6a7de7bb5e73ad2c0df1090886fa61a11b" translate="yes" xml:space="preserve">
          <source>Behaves like &lt;code&gt;alloc&lt;/code&gt;, but also ensures that the returned memory is zero-initialized. &lt;a href=&quot;trait.allocref#method.alloc_zeroed&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="16853ad48a342bbd03514f294c9cb5b40dbdc15d" translate="yes" xml:space="preserve">
          <source>Behaves like &lt;code&gt;alloc&lt;/code&gt;, but also returns the whole size of the returned block. For some &lt;code&gt;layout&lt;/code&gt; inputs, like arrays, this may include extra storage usable for additional data.</source>
          <target state="translated">Действует как &lt;code&gt;alloc&lt;/code&gt; , но также возвращает весь размер возвращенного блока. Для некоторых входных данных &lt;code&gt;layout&lt;/code&gt; , таких как массивы, это может включать дополнительное хранилище, используемое для дополнительных данных.</target>
        </trans-unit>
        <trans-unit id="40c1d1b115b0d7d4586e89d6b5493bd9bd25a35d" translate="yes" xml:space="preserve">
          <source>Behaves like &lt;code&gt;alloc&lt;/code&gt;, but also returns the whole size of the returned block. For some &lt;code&gt;layout&lt;/code&gt; inputs, like arrays, this may include extra storage usable for additional data. &lt;a href=&quot;trait.alloc#method.alloc_excess&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">Действует как &lt;code&gt;alloc&lt;/code&gt; , но также возвращает весь размер возвращенного блока. Для некоторых входных данных &lt;code&gt;layout&lt;/code&gt; , таких как массивы, это может включать дополнительное хранилище, используемое для дополнительных данных. &lt;a href=&quot;trait.alloc#method.alloc_excess&quot;&gt;Читать далее&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="dcc5bb4de65f26b5cfc9c0d306890b6a3dfd8426" translate="yes" xml:space="preserve">
          <source>Behaves like &lt;code&gt;grow&lt;/code&gt;, but also ensures that the new contents are set to zero before being returned. &lt;a href=&quot;alloc/trait.allocref#method.grow_zeroed&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b00b17315ce422677165dd747a2622a3bae967c2" translate="yes" xml:space="preserve">
          <source>Behaves like &lt;code&gt;grow&lt;/code&gt;, but also ensures that the new contents are set to zero before being returned. &lt;a href=&quot;trait.allocref#method.grow_zeroed&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d6dee35b4dc6dfa21486bfd27863270c134037f5" translate="yes" xml:space="preserve">
          <source>Behaves like &lt;code&gt;realloc&lt;/code&gt;, but also returns the whole size of the returned block. For some &lt;code&gt;layout&lt;/code&gt; inputs, like arrays, this may include extra storage usable for additional data.</source>
          <target state="translated">Действует как &lt;code&gt;realloc&lt;/code&gt; , но также возвращает весь размер возвращенного блока. Для некоторых входных данных &lt;code&gt;layout&lt;/code&gt; , таких как массивы, это может включать дополнительное хранилище, используемое для дополнительных данных.</target>
        </trans-unit>
        <trans-unit id="c12028831748d6fe621f72695ab145b2de0f2ea6" translate="yes" xml:space="preserve">
          <source>Behaves like &lt;code&gt;realloc&lt;/code&gt;, but also returns the whole size of the returned block. For some &lt;code&gt;layout&lt;/code&gt; inputs, like arrays, this may include extra storage usable for additional data. &lt;a href=&quot;trait.alloc#method.realloc_excess&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">Действует как &lt;code&gt;realloc&lt;/code&gt; , но также возвращает весь размер возвращенного блока. Для некоторых входных данных &lt;code&gt;layout&lt;/code&gt; , таких как массивы, это может включать дополнительное хранилище, используемое для дополнительных данных. &lt;a href=&quot;trait.alloc#method.realloc_excess&quot;&gt;Читать далее&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="70cb647a88bd7c9c17d225eecdaf0f898261eb60" translate="yes" xml:space="preserve">
          <source>Behavior</source>
          <target state="translated">Behavior</target>
        </trans-unit>
        <trans-unit id="095fb761bd6565ed9b50c488d53be7f174ad6258" translate="yes" xml:space="preserve">
          <source>Behavior considered undefined</source>
          <target state="translated">Поведение считается неопределенным</target>
        </trans-unit>
        <trans-unit id="387f0e642c525f9f6e8bb2a3ac2dfb1f45db317b" translate="yes" xml:space="preserve">
          <source>Behavior during const evaluation</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b1544a3801fc2d10e0c4fa2700cbde205e380188" translate="yes" xml:space="preserve">
          <source>Behavior is undefined if any of the following conditions are violated:</source>
          <target state="translated">Поведение не определено,если нарушается одно из следующих условий:</target>
        </trans-unit>
        <trans-unit id="9d1d94b77ecaf322c48c942eb7769975f61f7e1b" translate="yes" xml:space="preserve">
          <source>Behavior not considered &lt;code id=&quot;behavior-not-considered-unsafe&quot;&gt;unsafe&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3c89d307ed32970842af58f6e49fccbe4976a8de" translate="yes" xml:space="preserve">
          <source>Behavior not considered &lt;code&gt;unsafe&lt;/code&gt;</source>
          <target state="translated">Поведение не считается &lt;code&gt;unsafe&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="56466d174610967ccd7c4e4d2f8e7fb575e6e68b" translate="yes" xml:space="preserve">
          <source>Being unable to change the value of a variable might have reminded you of another programming concept that most other languages have: &lt;em&gt;constants&lt;/em&gt;. Like immutable variables, constants are values that are bound to a name and are not allowed to change, but there are a few differences between constants and variables.</source>
          <target state="translated">Отсутствие возможности изменить значение переменной могло напомнить вам о другой концепции программирования, которая присутствует в большинстве других языков: о &lt;em&gt;константах&lt;/em&gt; . Как и неизменяемые переменные, константы - это значения, которые привязаны к имени и не могут изменяться, но между константами и переменными есть несколько различий.</target>
        </trans-unit>
        <trans-unit id="2b1f5f4233d209308eb232700a1ebe15446b03df" translate="yes" xml:space="preserve">
          <source>Believe it or not, there is much more to learn on the topics we discussed in this chapter: Chapter 17 discusses trait objects, which are another way to use traits. Chapter 19 covers more complex scenarios involving lifetime annotations as well as some advanced type system features. But next, you&amp;rsquo;ll learn how to write tests in Rust so you can make sure your code is working the way it should.</source>
          <target state="translated">Хотите верьте, хотите нет, но по темам, которые мы обсуждали в этой главе, можно узнать гораздо больше: в главе 17 обсуждаются объекты-признаки, которые представляют собой еще один способ использования признаков. В главе 19 рассматриваются более сложные сценарии, включающие аннотации времени жизни, а также некоторые расширенные функции системы типов. Но затем вы узнаете, как писать тесты на Rust, чтобы убедиться, что ваш код работает так, как должен.</target>
        </trans-unit>
        <trans-unit id="58b3731b9aba86dccac77d4faa0d50972846f846" translate="yes" xml:space="preserve">
          <source>Believe it or not, there is much more to learn on the topics we discussed in this chapter: Chapter 17 discusses trait objects, which are another way to use traits. There are also more complex scenarios involving lifetime annotations that you will only need in very advanced scenarios; for those, you should read the &lt;a href=&quot;../reference/index&quot;&gt;Rust Reference&lt;/a&gt;. But next, you&amp;rsquo;ll learn how to write tests in Rust so you can make sure your code is working the way it should.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d677fae0ad7b93321bdf5902d4670326f019ecfb" translate="yes" xml:space="preserve">
          <source>Below are formal inductive definitions for FIRST and LAST.</source>
          <target state="translated">Ниже приведены формальные индуктивные определения ПЕРВЫХ и ПОСЛЕДНИХ.</target>
        </trans-unit>
        <trans-unit id="9aa1c322ef5127bad20114a3c08180f48d6a1ff0" translate="yes" xml:space="preserve">
          <source>Below are some examples of FIRST and LAST. (Note in particular how the special &amp;epsilon; element is introduced and eliminated based on the interaction between the pieces of the input.)</source>
          <target state="translated">Ниже приведены некоторые примеры ПЕРВОГО и ПОСЛЕДНЕГО. (Обратите внимание, в частности, на то, как специальный элемент &amp;epsilon; вводится и удаляется в зависимости от взаимодействия между частями ввода.)</target>
        </trans-unit>
        <trans-unit id="7b50be87542e5985746393609c4b0d26c14c49a1" translate="yes" xml:space="preserve">
          <source>Below is an example that shows under what conditions the compiler keeps a &lt;code&gt;static&lt;/code&gt; item in the output object file.</source>
          <target state="translated">Ниже приведен пример, показывающий, при каких условиях компилятор сохраняет &lt;code&gt;static&lt;/code&gt; элемент в выходном объектном файле.</target>
        </trans-unit>
        <trans-unit id="1aa487609f84f4a503144112602dbfe1aef5f203" translate="yes" xml:space="preserve">
          <source>Below is shown a &lt;code&gt;panic_handler&lt;/code&gt; function that logs the panic message and then halts the thread.</source>
          <target state="translated">Ниже показана функция &lt;code&gt;panic_handler&lt;/code&gt; , которая регистрирует сообщение о панике, а затем останавливает поток.</target>
        </trans-unit>
        <trans-unit id="2a2f598979a5de21d86b57d75eda1c3bfc34d2c7" translate="yes" xml:space="preserve">
          <source>Besides basic data types, the standard library is largely concerned with abstracting over differences in common platforms, most notably Windows and Unix derivatives.</source>
          <target state="translated">Помимо базовых типов данных,стандартная библиотека в основном занимается абстрагированием различий в общих платформах,в частности,производных Windows и Unix.</target>
        </trans-unit>
        <trans-unit id="f03b60f7e52b7ce49ed1e4f9fa511c452a2185bb" translate="yes" xml:space="preserve">
          <source>Beta</source>
          <target state="translated">Beta</target>
        </trans-unit>
        <trans-unit id="234f044b4bf52384fd2873935962aa4a005b114a" translate="yes" xml:space="preserve">
          <source>Beyond that, there are two important traits that are provided: &lt;a href=&quot;trait.seek&quot;&gt;&lt;code&gt;Seek&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;trait.bufread&quot;&gt;&lt;code&gt;BufRead&lt;/code&gt;&lt;/a&gt;. Both of these build on top of a reader to control how the reading happens. &lt;a href=&quot;trait.seek&quot;&gt;&lt;code&gt;Seek&lt;/code&gt;&lt;/a&gt; lets you control where the next byte is coming from:</source>
          <target state="translated">Помимо этого, есть две важные особенности: &lt;a href=&quot;trait.seek&quot;&gt; &lt;code&gt;Seek&lt;/code&gt; &lt;/a&gt; и &lt;a href=&quot;trait.bufread&quot;&gt; &lt;code&gt;BufRead&lt;/code&gt; &lt;/a&gt; . Оба они построены на основе читателя, чтобы контролировать, как происходит чтение. &lt;a href=&quot;trait.seek&quot;&gt; &lt;code&gt;Seek&lt;/code&gt; &lt;/a&gt; позволяет вам контролировать, откуда берется следующий байт:</target>
        </trans-unit>
        <trans-unit id="66639f7d455dd71faa9147f5d69e5ce885d8bebd" translate="yes" xml:space="preserve">
          <source>Binary</source>
          <target state="translated">Binary</target>
        </trans-unit>
        <trans-unit id="528a653c1337877f018509c599539f6092a1c73c" translate="yes" xml:space="preserve">
          <source>Binary integer</source>
          <target state="translated">двоичное целое число</target>
        </trans-unit>
        <trans-unit id="c45c03039baf74ccb71d2cd15ae8c1ec54d6c3fc" translate="yes" xml:space="preserve">
          <source>Binary operator expressions (&lt;a href=&quot;expressions/operator-expr#arithmetic-and-logical-binary-operators&quot;&gt;&lt;em&gt;ArithmeticOrLogicalExpression&lt;/em&gt;&lt;/a&gt;, &lt;a href=&quot;expressions/operator-expr#comparison-operators&quot;&gt;&lt;em&gt;ComparisonExpression&lt;/em&gt;&lt;/a&gt;, &lt;a href=&quot;expressions/operator-expr#lazy-boolean-operators&quot;&gt;&lt;em&gt;LazyBooleanExpression&lt;/em&gt;&lt;/a&gt;, &lt;a href=&quot;expressions/operator-expr#type-cast-expressions&quot;&gt;&lt;em&gt;TypeCastExpression&lt;/em&gt;&lt;/a&gt;, &lt;a href=&quot;expressions/operator-expr#assignment-expressions&quot;&gt;&lt;em&gt;AssignmentExpression&lt;/em&gt;&lt;/a&gt;, &lt;a href=&quot;expressions/operator-expr#compound-assignment-expressions&quot;&gt;&lt;em&gt;CompoundAssignmentExpression&lt;/em&gt;&lt;/a&gt;).</source>
          <target state="translated">Выражения двоичных операторов ( &lt;a href=&quot;expressions/operator-expr#arithmetic-and-logical-binary-operators&quot;&gt;&lt;em&gt;ArithmeticOrLogicalExpression&lt;/em&gt;&lt;/a&gt; , &lt;a href=&quot;expressions/operator-expr#comparison-operators&quot;&gt;&lt;em&gt;ComparisonExpression&lt;/em&gt;&lt;/a&gt; , &lt;a href=&quot;expressions/operator-expr#lazy-boolean-operators&quot;&gt;&lt;em&gt;LazyBooleanExpression&lt;/em&gt;&lt;/a&gt; , &lt;a href=&quot;expressions/operator-expr#type-cast-expressions&quot;&gt;&lt;em&gt;TypeCastExpression&lt;/em&gt;&lt;/a&gt; , &lt;a href=&quot;expressions/operator-expr#assignment-expressions&quot;&gt;&lt;em&gt;AssignmentExpression&lt;/em&gt;&lt;/a&gt; , &lt;a href=&quot;expressions/operator-expr#compound-assignment-expressions&quot;&gt;&lt;em&gt;CompoundAssignmentExpression&lt;/em&gt;&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="19f576ed80d6aac8fef3b9d639229b5cf1b86087" translate="yes" xml:space="preserve">
          <source>Binary operators expressions are all written with infix notation. This table summarizes the behavior of arithmetic and logical binary operators on primitive types and which traits are used to overload these operators for other types. Remember that signed integers are always represented using two's complement. The operands of all of these operators are evaluated in &lt;a href=&quot;../expressions#place-expressions-and-value-expressions&quot;&gt;value expression context&lt;/a&gt; so are moved or copied.</source>
          <target state="translated">Все выражения бинарных операторов записываются с инфиксной нотацией. Эта таблица суммирует поведение арифметических и логических бинарных операторов над примитивными типами и какие характеристики используются для перегрузки этих операторов для других типов. Помните, что целые числа со знаком всегда представлены в виде дополнения до двух. Операнды всех этих операторов оцениваются в &lt;a href=&quot;../expressions#place-expressions-and-value-expressions&quot;&gt;контексте выражения значения,&lt;/a&gt; поэтому перемещаются или копируются.</target>
        </trans-unit>
        <trans-unit id="bb24e7a177053effeaa97b02e6e1d53bea903394" translate="yes" xml:space="preserve">
          <source>Binary searches this sorted slice for a given element.</source>
          <target state="translated">Двоичный поиск этого отсортированного среза для данного элемента.</target>
        </trans-unit>
        <trans-unit id="342759ca0bc54fef96ecf37bc0ddadb9e9d73749" translate="yes" xml:space="preserve">
          <source>Binary searches this sorted slice with a comparator function.</source>
          <target state="translated">Двоичный поиск этого отсортированного среза с функцией компаратора.</target>
        </trans-unit>
        <trans-unit id="7bc8abd5fd12b3c23822c666fc1626829d2282bf" translate="yes" xml:space="preserve">
          <source>Binary searches this sorted slice with a key extraction function.</source>
          <target state="translated">Двоичный поиск этого отсортированного среза с помощью функции извлечения ключей.</target>
        </trans-unit>
        <trans-unit id="0f756fdf55ff6fbf54d5489a870831d4c60ffda7" translate="yes" xml:space="preserve">
          <source>Binary::fmt</source>
          <target state="translated">Binary::fmt</target>
        </trans-unit>
        <trans-unit id="f4b68b2fab22d221207f75497f220c953edad9fd" translate="yes" xml:space="preserve">
          <source>BinaryHeap</source>
          <target state="translated">BinaryHeap</target>
        </trans-unit>
        <trans-unit id="dacf4e220750a1b0f951db1cac365b1b687b357f" translate="yes" xml:space="preserve">
          <source>BinaryHeap::append</source>
          <target state="translated">BinaryHeap::append</target>
        </trans-unit>
        <trans-unit id="237581b8c07d3a6f7c2056bca73d832b0ff9b185" translate="yes" xml:space="preserve">
          <source>BinaryHeap::borrow</source>
          <target state="translated">BinaryHeap::borrow</target>
        </trans-unit>
        <trans-unit id="6cc1c3995d6cbe9775c025f1c009843f3a795e95" translate="yes" xml:space="preserve">
          <source>BinaryHeap::borrow_mut</source>
          <target state="translated">BinaryHeap::borrow_mut</target>
        </trans-unit>
        <trans-unit id="ea651796c70f924cd09768869629d83a528f3966" translate="yes" xml:space="preserve">
          <source>BinaryHeap::capacity</source>
          <target state="translated">BinaryHeap::capacity</target>
        </trans-unit>
        <trans-unit id="4db927bbac3d9fd9afcc396f05abd8a6d2369849" translate="yes" xml:space="preserve">
          <source>BinaryHeap::clear</source>
          <target state="translated">BinaryHeap::clear</target>
        </trans-unit>
        <trans-unit id="44380118a5aafd372e4d29c4729fc27883446a63" translate="yes" xml:space="preserve">
          <source>BinaryHeap::clone</source>
          <target state="translated">BinaryHeap::clone</target>
        </trans-unit>
        <trans-unit id="c4238fb46fd7eaa2a0823eded93fee09138cb72e" translate="yes" xml:space="preserve">
          <source>BinaryHeap::clone_from</source>
          <target state="translated">BinaryHeap::clone_from</target>
        </trans-unit>
        <trans-unit id="b77853e2e7d4b57b08f38a8fa17f28d29076c075" translate="yes" xml:space="preserve">
          <source>BinaryHeap::clone_into</source>
          <target state="translated">BinaryHeap::clone_into</target>
        </trans-unit>
        <trans-unit id="d4e562b332ce963cb95b5b307cb7485615e014fc" translate="yes" xml:space="preserve">
          <source>BinaryHeap::default</source>
          <target state="translated">BinaryHeap::default</target>
        </trans-unit>
        <trans-unit id="fdc5438d4f6cad011f4663afcc9664e54dc0d85e" translate="yes" xml:space="preserve">
          <source>BinaryHeap::drain</source>
          <target state="translated">BinaryHeap::drain</target>
        </trans-unit>
        <trans-unit id="0aaca4d42181f37288aa7e21316d709a6ff71f49" translate="yes" xml:space="preserve">
          <source>BinaryHeap::extend</source>
          <target state="translated">BinaryHeap::extend</target>
        </trans-unit>
        <trans-unit id="f4c67172d6c1cdb39c6636230b079c173cf83f2c" translate="yes" xml:space="preserve">
          <source>BinaryHeap::fmt</source>
          <target state="translated">BinaryHeap::fmt</target>
        </trans-unit>
        <trans-unit id="871dac7b5ceedfbec71447a6d6ed9de357acd044" translate="yes" xml:space="preserve">
          <source>BinaryHeap::from</source>
          <target state="translated">BinaryHeap::from</target>
        </trans-unit>
        <trans-unit id="f175a9eb33f99d6629fe67f65984c4a890519755" translate="yes" xml:space="preserve">
          <source>BinaryHeap::from_iter</source>
          <target state="translated">BinaryHeap::from_iter</target>
        </trans-unit>
        <trans-unit id="abdea679542fd107e906ae5d58ce503cb54c014d" translate="yes" xml:space="preserve">
          <source>BinaryHeap::into</source>
          <target state="translated">BinaryHeap::into</target>
        </trans-unit>
        <trans-unit id="45541a8cf8b33e80b63d4c7b7d8a3acfe03252c0" translate="yes" xml:space="preserve">
          <source>BinaryHeap::into_iter</source>
          <target state="translated">BinaryHeap::into_iter</target>
        </trans-unit>
        <trans-unit id="a4f3a26fa362623ceae23603112262e72024f7b9" translate="yes" xml:space="preserve">
          <source>BinaryHeap::into_sorted_vec</source>
          <target state="translated">BinaryHeap::into_sorted_vec</target>
        </trans-unit>
        <trans-unit id="1db086875600549522e8a9e52684ebd526b5b129" translate="yes" xml:space="preserve">
          <source>BinaryHeap::into_vec</source>
          <target state="translated">BinaryHeap::into_vec</target>
        </trans-unit>
        <trans-unit id="a112ebac833a70561b615451c2e74f51b6f19a74" translate="yes" xml:space="preserve">
          <source>BinaryHeap::is_empty</source>
          <target state="translated">BinaryHeap::is_empty</target>
        </trans-unit>
        <trans-unit id="0ee572360922722532c0921740eb1f614a7ab7ce" translate="yes" xml:space="preserve">
          <source>BinaryHeap::iter</source>
          <target state="translated">BinaryHeap::iter</target>
        </trans-unit>
        <trans-unit id="119b277a11fb08dfc4b80fb6b74bafd3221914e4" translate="yes" xml:space="preserve">
          <source>BinaryHeap::len</source>
          <target state="translated">BinaryHeap::len</target>
        </trans-unit>
        <trans-unit id="227d527ad8e44dcb2418c2e7e8e075d2359fb772" translate="yes" xml:space="preserve">
          <source>BinaryHeap::new</source>
          <target state="translated">BinaryHeap::new</target>
        </trans-unit>
        <trans-unit id="1fed1ee8afbb235ea1f87d7947786969b3a00687" translate="yes" xml:space="preserve">
          <source>BinaryHeap::peek</source>
          <target state="translated">BinaryHeap::peek</target>
        </trans-unit>
        <trans-unit id="23133fcfda988b66f1b73cca51b41c4297acc6b5" translate="yes" xml:space="preserve">
          <source>BinaryHeap::peek_mut</source>
          <target state="translated">BinaryHeap::peek_mut</target>
        </trans-unit>
        <trans-unit id="d6e00b82d35a37cd32b1907ca0812180a4fe6813" translate="yes" xml:space="preserve">
          <source>BinaryHeap::pop</source>
          <target state="translated">BinaryHeap::pop</target>
        </trans-unit>
        <trans-unit id="9d087a89ba80a46d773a7b420f9c4e221911780c" translate="yes" xml:space="preserve">
          <source>BinaryHeap::push</source>
          <target state="translated">BinaryHeap::push</target>
        </trans-unit>
        <trans-unit id="f989d57cf0e0868e0ab3e99ccd663f3feb35ed09" translate="yes" xml:space="preserve">
          <source>BinaryHeap::reserve</source>
          <target state="translated">BinaryHeap::reserve</target>
        </trans-unit>
        <trans-unit id="2c3a34b08e6d7927826662441c85562fbe689c5c" translate="yes" xml:space="preserve">
          <source>BinaryHeap::reserve_exact</source>
          <target state="translated">BinaryHeap::reserve_exact</target>
        </trans-unit>
        <trans-unit id="7748954939d681e885fda180afed19fde978c11a" translate="yes" xml:space="preserve">
          <source>BinaryHeap::shrink_to</source>
          <target state="translated">BinaryHeap::shrink_to</target>
        </trans-unit>
        <trans-unit id="a6cb12e1cadaa03dc4bd1cee0a924e07fbf651bc" translate="yes" xml:space="preserve">
          <source>BinaryHeap::shrink_to_fit</source>
          <target state="translated">BinaryHeap::shrink_to_fit</target>
        </trans-unit>
        <trans-unit id="3173fa304efc6acd170d96dcfc16d265f0d5bb04" translate="yes" xml:space="preserve">
          <source>BinaryHeap::to_owned</source>
          <target state="translated">BinaryHeap::to_owned</target>
        </trans-unit>
        <trans-unit id="545a06b62d55dcf95e6aed766f34093361650315" translate="yes" xml:space="preserve">
          <source>BinaryHeap::try_from</source>
          <target state="translated">BinaryHeap::try_from</target>
        </trans-unit>
        <trans-unit id="9ff50e94eaf55b6f7a7c5638416c4db484934500" translate="yes" xml:space="preserve">
          <source>BinaryHeap::try_into</source>
          <target state="translated">BinaryHeap::try_into</target>
        </trans-unit>
        <trans-unit id="337697412c6fd50a3b2ba815044c47d165af3cd6" translate="yes" xml:space="preserve">
          <source>BinaryHeap::type_id</source>
          <target state="translated">BinaryHeap::type_id</target>
        </trans-unit>
        <trans-unit id="8acc5ae886b9efd0dc8fb7d4fc82df425c356c37" translate="yes" xml:space="preserve">
          <source>BinaryHeap::with_capacity</source>
          <target state="translated">BinaryHeap::with_capacity</target>
        </trans-unit>
        <trans-unit id="c33a043d5763d9b3ea7f89a9ac614fa68ca83bc4" translate="yes" xml:space="preserve">
          <source>Bind a TCP listener to an address, listen for connections, and read bytes in nonblocking mode:</source>
          <target state="translated">Привязывайте TCP-прослушиватель к адресу,прослушивайте соединения и читайте байты в неблокирующем режиме:</target>
        </trans-unit>
        <trans-unit id="359dde3378dea26f13c20bf3ab1abd7d31ba2c01" translate="yes" xml:space="preserve">
          <source>Bind a value to a variable.</source>
          <target state="translated">Привязать значение к переменной.</target>
        </trans-unit>
        <trans-unit id="d22542d4de6d5029b1ac0ccd7c008fc51102ba8b" translate="yes" xml:space="preserve">
          <source>Bind by reference during pattern matching.</source>
          <target state="translated">Привязывание по ссылке во время совмещения образцов.</target>
        </trans-unit>
        <trans-unit id="069dbd36e80b491e8ea0d0898b003375a28c5f42" translate="yes" xml:space="preserve">
          <source>Binding all paths matching a given prefix, using the asterisk wildcard syntax &lt;code&gt;use a::b::*;&lt;/code&gt;.</source>
          <target state="translated">Связывание всех путей, соответствующих заданному префиксу, с использованием синтаксиса подстановочного знака звездочки &lt;code&gt;use a::b::*;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="edac8dc0f66a2e81b54912d09ade5eca329f5dcd" translate="yes" xml:space="preserve">
          <source>Binding modes</source>
          <target state="translated">Режимы привязки</target>
        </trans-unit>
        <trans-unit id="30c9ed787b1702852e9d605cfb98fe4532008152" translate="yes" xml:space="preserve">
          <source>Binding with a port number of 0 will request that the OS assigns a port to this listener. The port allocated can be queried via the &lt;a href=&quot;#method.local_addr&quot;&gt;&lt;code&gt;local_addr&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">При связывании с номером порта 0 ОС будет запрашивать назначение порта этому прослушивателю. &lt;a href=&quot;#method.local_addr&quot;&gt; &lt;code&gt;local_addr&lt;/code&gt; &lt;/a&gt; порт можно запросить с помощью метода local_addr .</target>
        </trans-unit>
        <trans-unit id="ace7ad2d8af42b873b8f9c931c9515626c9ccb54" translate="yes" xml:space="preserve">
          <source>Binding with a port number of 0 will request that the OS assigns a port to this listener. The port allocated can be queried via the &lt;a href=&quot;struct.tcplistener#method.local_addr&quot;&gt;&lt;code&gt;TcpListener::local_addr&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2c4806bd148356225d8f9e9c34e40c18cd70837a" translate="yes" xml:space="preserve">
          <source>Binds a reference to the &lt;code&gt;name&lt;/code&gt; field to the variable &lt;code&gt;person_name&lt;/code&gt;.</source>
          <target state="translated">Привязывает ссылку на поле &lt;code&gt;name&lt;/code&gt; к переменной &lt;code&gt;person_name&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="309af9e25956170a810f78e3c71afc45e9766ccf" translate="yes" xml:space="preserve">
          <source>BitAnd</source>
          <target state="translated">BitAnd</target>
        </trans-unit>
        <trans-unit id="597ad73fbf9aa40cebae5f999cfe7db4afecce4e" translate="yes" xml:space="preserve">
          <source>BitAnd::bitand</source>
          <target state="translated">BitAnd::bitand</target>
        </trans-unit>
        <trans-unit id="943b337ab11ab98e677d691725140875e5b353e9" translate="yes" xml:space="preserve">
          <source>BitAndAssign</source>
          <target state="translated">BitAndAssign</target>
        </trans-unit>
        <trans-unit id="f5e3873189453b3d2f6432bcad61a66bb4d9501b" translate="yes" xml:space="preserve">
          <source>BitAndAssign::bitand_assign</source>
          <target state="translated">BitAndAssign::bitand_assign</target>
        </trans-unit>
        <trans-unit id="f64578ede789cb16c75f551e17bc358c839da2a7" translate="yes" xml:space="preserve">
          <source>BitOr</source>
          <target state="translated">BitOr</target>
        </trans-unit>
        <trans-unit id="44191b5eea700acecf61cce1d97b9be216180188" translate="yes" xml:space="preserve">
          <source>BitOr::bitor</source>
          <target state="translated">BitOr::bitor</target>
        </trans-unit>
        <trans-unit id="960e956c7d9aabe97b11d326569299236d4948a9" translate="yes" xml:space="preserve">
          <source>BitOrAssign</source>
          <target state="translated">BitOrAssign</target>
        </trans-unit>
        <trans-unit id="3034c1fbe2a99f07e023c8c2cb9d42ee22ccc4c1" translate="yes" xml:space="preserve">
          <source>BitOrAssign::bitor_assign</source>
          <target state="translated">BitOrAssign::bitor_assign</target>
        </trans-unit>
        <trans-unit id="427e64f1c1cbca75038d127034792de35e048e3d" translate="yes" xml:space="preserve">
          <source>BitXor</source>
          <target state="translated">BitXor</target>
        </trans-unit>
        <trans-unit id="2e397bf0da401d643f9083e54c584225e131c7ca" translate="yes" xml:space="preserve">
          <source>BitXor::bitxor</source>
          <target state="translated">BitXor::bitxor</target>
        </trans-unit>
        <trans-unit id="6a826e6c5b73b200c07a57a2aec1b711ff40e1d4" translate="yes" xml:space="preserve">
          <source>BitXorAssign</source>
          <target state="translated">BitXorAssign</target>
        </trans-unit>
        <trans-unit id="cbbbcfd713c363f58df6976ea8f22e15d59645d6" translate="yes" xml:space="preserve">
          <source>BitXorAssign::bitxor_assign</source>
          <target state="translated">BitXorAssign::bitxor_assign</target>
        </trans-unit>
        <trans-unit id="77e08df74f0783fd374c97b42304776b3399af7d" translate="yes" xml:space="preserve">
          <source>Bitwise &quot;and&quot; with the current value.</source>
          <target state="translated">Побитовое &quot;и&quot; с текущим значением.</target>
        </trans-unit>
        <trans-unit id="2c404667875b6822ca47e4a6888c165e459b533c" translate="yes" xml:space="preserve">
          <source>Bitwise &quot;nand&quot; with the current value.</source>
          <target state="translated">Побитовое &quot;nand&quot; с текущим значением.</target>
        </trans-unit>
        <trans-unit id="1f35aa22f6cd34a5220faabf04cbbb20527ee643" translate="yes" xml:space="preserve">
          <source>Bitwise &quot;or&quot; with the current value.</source>
          <target state="translated">Побитовое &quot;или&quot; с текущим значением.</target>
        </trans-unit>
        <trans-unit id="5c076254fac7febb41ccccf46680d5e14a161fa4" translate="yes" xml:space="preserve">
          <source>Bitwise &quot;xor&quot; with the current value.</source>
          <target state="translated">Побитовое &quot;xor&quot; с текущим значением.</target>
        </trans-unit>
        <trans-unit id="17e80e5f71e9b85954b350f117d4dfeb3c5cf70a" translate="yes" xml:space="preserve">
          <source>Bitwise AND</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4a9a6c94eeeaf50fe1cbac8c1cdc883b234d3b2b" translate="yes" xml:space="preserve">
          <source>Bitwise AND and assignment</source>
          <target state="translated">Прямо пропорционально И и задание</target>
        </trans-unit>
        <trans-unit id="714d6d47971ffbb15128b6a55a03723a5c596cc3" translate="yes" xml:space="preserve">
          <source>Bitwise And assignment</source>
          <target state="translated">Понятно.И задание.</target>
        </trans-unit>
        <trans-unit id="136c3a93310929e09124297eaf66ab9f3782d009" translate="yes" xml:space="preserve">
          <source>Bitwise NOT</source>
          <target state="translated">Побочно НЕ</target>
        </trans-unit>
        <trans-unit id="f4be0adcfa81c37e1e7bbf2e23630f30974d164f" translate="yes" xml:space="preserve">
          <source>Bitwise OR</source>
          <target state="translated">Побочно ИЛИ</target>
        </trans-unit>
        <trans-unit id="ea162d3eb732111137dc7e851592f946afbda822" translate="yes" xml:space="preserve">
          <source>Bitwise OR and assignment</source>
          <target state="translated">Побитовое ИЛИ и назначение</target>
        </trans-unit>
        <trans-unit id="efa8078cf56f653efb920477181cc2fe85068270" translate="yes" xml:space="preserve">
          <source>Bitwise Or assignment</source>
          <target state="translated">Прямо пропорционально или по назначению</target>
        </trans-unit>
        <trans-unit id="74269e9a4eb117ac43a93ed74bc3c8cd96fd4ff4" translate="yes" xml:space="preserve">
          <source>Bitwise XOR</source>
          <target state="translated">битумный XOR</target>
        </trans-unit>
        <trans-unit id="e3e1709ce290a67ec5f21e03a6b6317c9f304436" translate="yes" xml:space="preserve">
          <source>Bitwise XOR assignment</source>
          <target state="translated">битовое XOR-присвоение</target>
        </trans-unit>
        <trans-unit id="1f5eabb7a575f79f20f4d75b3fa1ac6c470a8bf6" translate="yes" xml:space="preserve">
          <source>Bitwise and Logical XOR</source>
          <target state="translated">Побитовый и логический XOR</target>
        </trans-unit>
        <trans-unit id="f5a1528826bb49fb0b14c31ab4934d10465ebdc5" translate="yes" xml:space="preserve">
          <source>Bitwise and with the current value, returning the previous value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ad214175503cf05c10c463c5f6a4d2dbb82dbf24" translate="yes" xml:space="preserve">
          <source>Bitwise and with the current value, returning the previous value. The stabilized version of this intrinsic is available on the &lt;code&gt;std::sync::atomic&lt;/code&gt; types via the &lt;code&gt;fetch_and&lt;/code&gt; method by passing &lt;a href=&quot;../sync/atomic/enum.ordering&quot;&gt;&lt;code&gt;Ordering::AcqRel&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;order&lt;/code&gt;. For example, &lt;a href=&quot;../sync/atomic/struct.atomicbool#method.fetch_and&quot;&gt;&lt;code&gt;AtomicBool::fetch_and&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Поразрядно и с текущим значением, возвращая предыдущее значение. Стабилизированная версия этой встроенной функции доступна для типов &lt;code&gt;std::sync::atomic&lt;/code&gt; через метод &lt;code&gt;fetch_and&lt;/code&gt; , передав &lt;a href=&quot;../sync/atomic/enum.ordering&quot;&gt; &lt;code&gt;Ordering::AcqRel&lt;/code&gt; &lt;/a&gt; в качестве &lt;code&gt;order&lt;/code&gt; . Например, &lt;a href=&quot;../sync/atomic/struct.atomicbool#method.fetch_and&quot;&gt; &lt;code&gt;AtomicBool::fetch_and&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="52dda2454098469eb02e841cfd17da11a1a8b11c" translate="yes" xml:space="preserve">
          <source>Bitwise and with the current value, returning the previous value. The stabilized version of this intrinsic is available on the &lt;code&gt;std::sync::atomic&lt;/code&gt; types via the &lt;code&gt;fetch_and&lt;/code&gt; method by passing &lt;a href=&quot;../sync/atomic/enum.ordering&quot;&gt;&lt;code&gt;Ordering::Acquire&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;order&lt;/code&gt;. For example, &lt;a href=&quot;../sync/atomic/struct.atomicbool#method.fetch_and&quot;&gt;&lt;code&gt;AtomicBool::fetch_and&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Поразрядно и с текущим значением, возвращая предыдущее значение. Стабилизированная версия этой встроенной функции доступна для типов &lt;code&gt;std::sync::atomic&lt;/code&gt; через метод &lt;code&gt;fetch_and&lt;/code&gt; , передав &lt;a href=&quot;../sync/atomic/enum.ordering&quot;&gt; &lt;code&gt;Ordering::Acquire&lt;/code&gt; &lt;/a&gt; в качестве &lt;code&gt;order&lt;/code&gt; . Например, &lt;a href=&quot;../sync/atomic/struct.atomicbool#method.fetch_and&quot;&gt; &lt;code&gt;AtomicBool::fetch_and&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="0c63ecd3d802b04a4e0e8dfab8248d912515dec0" translate="yes" xml:space="preserve">
          <source>Bitwise and with the current value, returning the previous value. The stabilized version of this intrinsic is available on the &lt;code&gt;std::sync::atomic&lt;/code&gt; types via the &lt;code&gt;fetch_and&lt;/code&gt; method by passing &lt;a href=&quot;../sync/atomic/enum.ordering&quot;&gt;&lt;code&gt;Ordering::Relaxed&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;order&lt;/code&gt;. For example, &lt;a href=&quot;../sync/atomic/struct.atomicbool#method.fetch_and&quot;&gt;&lt;code&gt;AtomicBool::fetch_and&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Поразрядно и с текущим значением, возвращая предыдущее значение. Стабилизированная версия этой встроенной функции доступна для типов &lt;code&gt;std::sync::atomic&lt;/code&gt; через метод &lt;code&gt;fetch_and&lt;/code&gt; путем передачи &lt;a href=&quot;../sync/atomic/enum.ordering&quot;&gt; &lt;code&gt;Ordering::Relaxed&lt;/code&gt; &lt;/a&gt; в качестве &lt;code&gt;order&lt;/code&gt; . Например, &lt;a href=&quot;../sync/atomic/struct.atomicbool#method.fetch_and&quot;&gt; &lt;code&gt;AtomicBool::fetch_and&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="4b6a21a8674eebce391a665fc4970562e774c483" translate="yes" xml:space="preserve">
          <source>Bitwise and with the current value, returning the previous value. The stabilized version of this intrinsic is available on the &lt;code&gt;std::sync::atomic&lt;/code&gt; types via the &lt;code&gt;fetch_and&lt;/code&gt; method by passing &lt;a href=&quot;../sync/atomic/enum.ordering&quot;&gt;&lt;code&gt;Ordering::Release&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;order&lt;/code&gt;. For example, &lt;a href=&quot;../sync/atomic/struct.atomicbool#method.fetch_and&quot;&gt;&lt;code&gt;AtomicBool::fetch_and&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Поразрядно и с текущим значением, возвращая предыдущее значение. Стабилизированная версия этой встроенной функции доступна для типов &lt;code&gt;std::sync::atomic&lt;/code&gt; через метод &lt;code&gt;fetch_and&lt;/code&gt; , передав &lt;a href=&quot;../sync/atomic/enum.ordering&quot;&gt; &lt;code&gt;Ordering::Release&lt;/code&gt; &lt;/a&gt; в качестве &lt;code&gt;order&lt;/code&gt; . Например, &lt;a href=&quot;../sync/atomic/struct.atomicbool#method.fetch_and&quot;&gt; &lt;code&gt;AtomicBool::fetch_and&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="63f47ad2a1e6e1fb335c5dc45db81e8017584432" translate="yes" xml:space="preserve">
          <source>Bitwise and with the current value, returning the previous value. The stabilized version of this intrinsic is available on the &lt;code&gt;std::sync::atomic&lt;/code&gt; types via the &lt;code&gt;fetch_and&lt;/code&gt; method by passing &lt;a href=&quot;../sync/atomic/enum.ordering&quot;&gt;&lt;code&gt;Ordering::SeqCst&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;order&lt;/code&gt;. For example, &lt;a href=&quot;../sync/atomic/struct.atomicbool#method.fetch_and&quot;&gt;&lt;code&gt;AtomicBool::fetch_and&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Поразрядно и с текущим значением, возвращая предыдущее значение. Стабилизированная версия этой встроенной функции доступна для типов &lt;code&gt;std::sync::atomic&lt;/code&gt; через метод &lt;code&gt;fetch_and&lt;/code&gt; путем передачи &lt;a href=&quot;../sync/atomic/enum.ordering&quot;&gt; &lt;code&gt;Ordering::SeqCst&lt;/code&gt; &lt;/a&gt; в качестве &lt;code&gt;order&lt;/code&gt; . Например, &lt;a href=&quot;../sync/atomic/struct.atomicbool#method.fetch_and&quot;&gt; &lt;code&gt;AtomicBool::fetch_and&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="3ba80ac4bf1c4bbad0f4a7d6ddfd25841835e177" translate="yes" xml:space="preserve">
          <source>Bitwise exclusive OR</source>
          <target state="translated">Битвайз эксклюзив ИЛИ</target>
        </trans-unit>
        <trans-unit id="87474ce9659a0e1b133611bb2ae41c7ede6c0a5d" translate="yes" xml:space="preserve">
          <source>Bitwise exclusive OR and assignment</source>
          <target state="translated">Побитовое эксклюзивное ИЛИ и задание</target>
        </trans-unit>
        <trans-unit id="868d075a0dad8cd3d8fb9f9f26964659d2c6164a" translate="yes" xml:space="preserve">
          <source>Bitwise nand with the current value, returning the previous value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="544da95df04807eeb86f0e070273fd4dd28cb7cf" translate="yes" xml:space="preserve">
          <source>Bitwise nand with the current value, returning the previous value. The stabilized version of this intrinsic is available on the &lt;code&gt;std::sync::atomic::AtomicBool&lt;/code&gt; type via the &lt;code&gt;fetch_nand&lt;/code&gt; method by passing &lt;a href=&quot;../sync/atomic/enum.ordering&quot;&gt;&lt;code&gt;Ordering::AcqRel&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;order&lt;/code&gt;. For example, &lt;a href=&quot;../sync/atomic/struct.atomicbool#method.fetch_nand&quot;&gt;&lt;code&gt;AtomicBool::fetch_nand&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Побитовое nand с текущим значением, возвращающее предыдущее значение. Стабилизированная версия этой встроенной функции доступна для типа &lt;code&gt;std::sync::atomic::AtomicBool&lt;/code&gt; через метод &lt;code&gt;fetch_nand&lt;/code&gt; , передав &lt;a href=&quot;../sync/atomic/enum.ordering&quot;&gt; &lt;code&gt;Ordering::AcqRel&lt;/code&gt; &lt;/a&gt; в качестве &lt;code&gt;order&lt;/code&gt; . Например, &lt;a href=&quot;../sync/atomic/struct.atomicbool#method.fetch_nand&quot;&gt; &lt;code&gt;AtomicBool::fetch_nand&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="d773083e9bfa18a72e7f0b0ab1c138c37ef42288" translate="yes" xml:space="preserve">
          <source>Bitwise nand with the current value, returning the previous value. The stabilized version of this intrinsic is available on the &lt;code&gt;std::sync::atomic::AtomicBool&lt;/code&gt; type via the &lt;code&gt;fetch_nand&lt;/code&gt; method by passing &lt;a href=&quot;../sync/atomic/enum.ordering&quot;&gt;&lt;code&gt;Ordering::Acquire&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;order&lt;/code&gt;. For example, &lt;a href=&quot;../sync/atomic/struct.atomicbool#method.fetch_nand&quot;&gt;&lt;code&gt;AtomicBool::fetch_nand&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Побитовое nand с текущим значением, возвращающее предыдущее значение. Стабилизированная версия этой встроенной функции доступна для типа &lt;code&gt;std::sync::atomic::AtomicBool&lt;/code&gt; через метод &lt;code&gt;fetch_nand&lt;/code&gt; , передав &lt;a href=&quot;../sync/atomic/enum.ordering&quot;&gt; &lt;code&gt;Ordering::Acquire&lt;/code&gt; &lt;/a&gt; в качестве &lt;code&gt;order&lt;/code&gt; . Например, &lt;a href=&quot;../sync/atomic/struct.atomicbool#method.fetch_nand&quot;&gt; &lt;code&gt;AtomicBool::fetch_nand&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="203338bb702fd121bec1c0bf9d6a954aecd4347e" translate="yes" xml:space="preserve">
          <source>Bitwise nand with the current value, returning the previous value. The stabilized version of this intrinsic is available on the &lt;code&gt;std::sync::atomic::AtomicBool&lt;/code&gt; type via the &lt;code&gt;fetch_nand&lt;/code&gt; method by passing &lt;a href=&quot;../sync/atomic/enum.ordering&quot;&gt;&lt;code&gt;Ordering::Relaxed&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;order&lt;/code&gt;. For example, &lt;a href=&quot;../sync/atomic/struct.atomicbool#method.fetch_nand&quot;&gt;&lt;code&gt;AtomicBool::fetch_nand&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Побитовое nand с текущим значением, возвращающее предыдущее значение. Стабилизированная версия этой встроенной функции доступна для типа &lt;code&gt;std::sync::atomic::AtomicBool&lt;/code&gt; через метод &lt;code&gt;fetch_nand&lt;/code&gt; , передав &lt;a href=&quot;../sync/atomic/enum.ordering&quot;&gt; &lt;code&gt;Ordering::Relaxed&lt;/code&gt; &lt;/a&gt; в качестве &lt;code&gt;order&lt;/code&gt; . Например, &lt;a href=&quot;../sync/atomic/struct.atomicbool#method.fetch_nand&quot;&gt; &lt;code&gt;AtomicBool::fetch_nand&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="6134a1fe2a25d4dbb615e6688200dbe8e85fe9f6" translate="yes" xml:space="preserve">
          <source>Bitwise nand with the current value, returning the previous value. The stabilized version of this intrinsic is available on the &lt;code&gt;std::sync::atomic::AtomicBool&lt;/code&gt; type via the &lt;code&gt;fetch_nand&lt;/code&gt; method by passing &lt;a href=&quot;../sync/atomic/enum.ordering&quot;&gt;&lt;code&gt;Ordering::Release&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;order&lt;/code&gt;. For example, &lt;a href=&quot;../sync/atomic/struct.atomicbool#method.fetch_nand&quot;&gt;&lt;code&gt;AtomicBool::fetch_nand&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Побитовое nand с текущим значением, возвращающее предыдущее значение. Стабилизированная версия этой встроенной функции доступна для типа &lt;code&gt;std::sync::atomic::AtomicBool&lt;/code&gt; через метод &lt;code&gt;fetch_nand&lt;/code&gt; путем передачи &lt;a href=&quot;../sync/atomic/enum.ordering&quot;&gt; &lt;code&gt;Ordering::Release&lt;/code&gt; &lt;/a&gt; в качестве &lt;code&gt;order&lt;/code&gt; . Например, &lt;a href=&quot;../sync/atomic/struct.atomicbool#method.fetch_nand&quot;&gt; &lt;code&gt;AtomicBool::fetch_nand&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="f8ddb011394cb17fb806f98da48b371ebbb0870e" translate="yes" xml:space="preserve">
          <source>Bitwise nand with the current value, returning the previous value. The stabilized version of this intrinsic is available on the &lt;code&gt;std::sync::atomic::AtomicBool&lt;/code&gt; type via the &lt;code&gt;fetch_nand&lt;/code&gt; method by passing &lt;a href=&quot;../sync/atomic/enum.ordering&quot;&gt;&lt;code&gt;Ordering::SeqCst&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;order&lt;/code&gt;. For example, &lt;a href=&quot;../sync/atomic/struct.atomicbool#method.fetch_nand&quot;&gt;&lt;code&gt;AtomicBool::fetch_nand&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Побитовое nand с текущим значением, возвращающее предыдущее значение. Стабилизированная версия этой встроенной функции доступна для типа &lt;code&gt;std::sync::atomic::AtomicBool&lt;/code&gt; через метод &lt;code&gt;fetch_nand&lt;/code&gt; , передав &lt;a href=&quot;../sync/atomic/enum.ordering&quot;&gt; &lt;code&gt;Ordering::SeqCst&lt;/code&gt; &lt;/a&gt; в качестве &lt;code&gt;order&lt;/code&gt; . Например, &lt;a href=&quot;../sync/atomic/struct.atomicbool#method.fetch_nand&quot;&gt; &lt;code&gt;AtomicBool::fetch_nand&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="60a4df2d9448161e88049fa61b8cadfe600ad676" translate="yes" xml:space="preserve">
          <source>Bitwise or logical complement</source>
          <target state="translated">Побочное или логическое дополнение</target>
        </trans-unit>
        <trans-unit id="7b4a22d8edc7cc62ea1716050e10c7737c8c1e1f" translate="yes" xml:space="preserve">
          <source>Bitwise or with the current value, returning the previous value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="535640642d3aa1c0482deebda0463eaa8ec0186f" translate="yes" xml:space="preserve">
          <source>Bitwise or with the current value, returning the previous value. The stabilized version of this intrinsic is available on the &lt;code&gt;std::sync::atomic&lt;/code&gt; types via the &lt;code&gt;fetch_or&lt;/code&gt; method by passing &lt;a href=&quot;../sync/atomic/enum.ordering&quot;&gt;&lt;code&gt;Ordering::AcqRel&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;order&lt;/code&gt;. For example, &lt;a href=&quot;../sync/atomic/struct.atomicbool#method.fetch_or&quot;&gt;&lt;code&gt;AtomicBool::fetch_or&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Побитовое или с текущим значением, возвращая предыдущее значение. Стабилизированная версия этой встроенной функции доступна для типов &lt;code&gt;std::sync::atomic&lt;/code&gt; через метод &lt;code&gt;fetch_or&lt;/code&gt; , передав &lt;a href=&quot;../sync/atomic/enum.ordering&quot;&gt; &lt;code&gt;Ordering::AcqRel&lt;/code&gt; &lt;/a&gt; в качестве &lt;code&gt;order&lt;/code&gt; . Например, &lt;a href=&quot;../sync/atomic/struct.atomicbool#method.fetch_or&quot;&gt; &lt;code&gt;AtomicBool::fetch_or&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="5bd0c7ff8a606308243e5fe0283ace8408191438" translate="yes" xml:space="preserve">
          <source>Bitwise or with the current value, returning the previous value. The stabilized version of this intrinsic is available on the &lt;code&gt;std::sync::atomic&lt;/code&gt; types via the &lt;code&gt;fetch_or&lt;/code&gt; method by passing &lt;a href=&quot;../sync/atomic/enum.ordering&quot;&gt;&lt;code&gt;Ordering::Acquire&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;order&lt;/code&gt;. For example, &lt;a href=&quot;../sync/atomic/struct.atomicbool#method.fetch_or&quot;&gt;&lt;code&gt;AtomicBool::fetch_or&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Побитовое или с текущим значением, возвращая предыдущее значение. Стабилизированная версия этой встроенной функции доступна для типов &lt;code&gt;std::sync::atomic&lt;/code&gt; через метод &lt;code&gt;fetch_or&lt;/code&gt; , передав &lt;a href=&quot;../sync/atomic/enum.ordering&quot;&gt; &lt;code&gt;Ordering::Acquire&lt;/code&gt; &lt;/a&gt; в качестве &lt;code&gt;order&lt;/code&gt; . Например, &lt;a href=&quot;../sync/atomic/struct.atomicbool#method.fetch_or&quot;&gt; &lt;code&gt;AtomicBool::fetch_or&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="1d6bccdc0a09c0e78855aa36b6446bb0697edc37" translate="yes" xml:space="preserve">
          <source>Bitwise or with the current value, returning the previous value. The stabilized version of this intrinsic is available on the &lt;code&gt;std::sync::atomic&lt;/code&gt; types via the &lt;code&gt;fetch_or&lt;/code&gt; method by passing &lt;a href=&quot;../sync/atomic/enum.ordering&quot;&gt;&lt;code&gt;Ordering::Relaxed&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;order&lt;/code&gt;. For example, &lt;a href=&quot;../sync/atomic/struct.atomicbool#method.fetch_or&quot;&gt;&lt;code&gt;AtomicBool::fetch_or&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Побитовое или с текущим значением, возвращая предыдущее значение. Стабилизированная версия этой встроенной функции доступна для типов &lt;code&gt;std::sync::atomic&lt;/code&gt; через метод &lt;code&gt;fetch_or&lt;/code&gt; , передав &lt;a href=&quot;../sync/atomic/enum.ordering&quot;&gt; &lt;code&gt;Ordering::Relaxed&lt;/code&gt; &lt;/a&gt; в качестве &lt;code&gt;order&lt;/code&gt; . Например, &lt;a href=&quot;../sync/atomic/struct.atomicbool#method.fetch_or&quot;&gt; &lt;code&gt;AtomicBool::fetch_or&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="7457b18d65f2f07bafb68e32e88a446590597ffd" translate="yes" xml:space="preserve">
          <source>Bitwise or with the current value, returning the previous value. The stabilized version of this intrinsic is available on the &lt;code&gt;std::sync::atomic&lt;/code&gt; types via the &lt;code&gt;fetch_or&lt;/code&gt; method by passing &lt;a href=&quot;../sync/atomic/enum.ordering&quot;&gt;&lt;code&gt;Ordering::Release&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;order&lt;/code&gt;. For example, &lt;a href=&quot;../sync/atomic/struct.atomicbool#method.fetch_or&quot;&gt;&lt;code&gt;AtomicBool::fetch_or&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Побитовое или с текущим значением, возвращая предыдущее значение. Стабилизированная версия этой встроенной функции доступна для типов &lt;code&gt;std::sync::atomic&lt;/code&gt; через метод &lt;code&gt;fetch_or&lt;/code&gt; , передав &lt;a href=&quot;../sync/atomic/enum.ordering&quot;&gt; &lt;code&gt;Ordering::Release&lt;/code&gt; &lt;/a&gt; в качестве &lt;code&gt;order&lt;/code&gt; . Например, &lt;a href=&quot;../sync/atomic/struct.atomicbool#method.fetch_or&quot;&gt; &lt;code&gt;AtomicBool::fetch_or&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="6a1e96dd5049ad694cd97688db2eb461734bf5e6" translate="yes" xml:space="preserve">
          <source>Bitwise or with the current value, returning the previous value. The stabilized version of this intrinsic is available on the &lt;code&gt;std::sync::atomic&lt;/code&gt; types via the &lt;code&gt;fetch_or&lt;/code&gt; method by passing &lt;a href=&quot;../sync/atomic/enum.ordering&quot;&gt;&lt;code&gt;Ordering::SeqCst&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;order&lt;/code&gt;. For example, &lt;a href=&quot;../sync/atomic/struct.atomicbool#method.fetch_or&quot;&gt;&lt;code&gt;AtomicBool::fetch_or&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Побитовое или с текущим значением, возвращая предыдущее значение. Стабилизированная версия этой встроенной функции доступна для типов &lt;code&gt;std::sync::atomic&lt;/code&gt; через метод &lt;code&gt;fetch_or&lt;/code&gt; , передав &lt;a href=&quot;../sync/atomic/enum.ordering&quot;&gt; &lt;code&gt;Ordering::SeqCst&lt;/code&gt; &lt;/a&gt; в качестве &lt;code&gt;order&lt;/code&gt; . Например, &lt;a href=&quot;../sync/atomic/struct.atomicbool#method.fetch_or&quot;&gt; &lt;code&gt;AtomicBool::fetch_or&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="181decb693bb642be494fbe5c52383467e0c228c" translate="yes" xml:space="preserve">
          <source>Bitwise xor with the current value, returning the previous value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aa1d7bc97bda02349e1fee1efbf8d66b5e91fc88" translate="yes" xml:space="preserve">
          <source>Bitwise xor with the current value, returning the previous value. The stabilized version of this intrinsic is available on the &lt;code&gt;std::sync::atomic&lt;/code&gt; types via the &lt;code&gt;fetch_xor&lt;/code&gt; method by passing &lt;a href=&quot;../sync/atomic/enum.ordering&quot;&gt;&lt;code&gt;Ordering::AcqRel&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;order&lt;/code&gt;. For example, &lt;a href=&quot;../sync/atomic/struct.atomicbool#method.fetch_xor&quot;&gt;&lt;code&gt;AtomicBool::fetch_xor&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Побитовый xor с текущим значением, возвращающий предыдущее значение. Стабилизированная версия этой встроенной функции доступна для типов &lt;code&gt;std::sync::atomic&lt;/code&gt; через метод &lt;code&gt;fetch_xor&lt;/code&gt; , передав &lt;a href=&quot;../sync/atomic/enum.ordering&quot;&gt; &lt;code&gt;Ordering::AcqRel&lt;/code&gt; &lt;/a&gt; в качестве &lt;code&gt;order&lt;/code&gt; . Например, &lt;a href=&quot;../sync/atomic/struct.atomicbool#method.fetch_xor&quot;&gt; &lt;code&gt;AtomicBool::fetch_xor&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="3805cb63a3c1121fa142484c3b378fcb265aa95c" translate="yes" xml:space="preserve">
          <source>Bitwise xor with the current value, returning the previous value. The stabilized version of this intrinsic is available on the &lt;code&gt;std::sync::atomic&lt;/code&gt; types via the &lt;code&gt;fetch_xor&lt;/code&gt; method by passing &lt;a href=&quot;../sync/atomic/enum.ordering&quot;&gt;&lt;code&gt;Ordering::Acquire&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;order&lt;/code&gt;. For example, &lt;a href=&quot;../sync/atomic/struct.atomicbool#method.fetch_xor&quot;&gt;&lt;code&gt;AtomicBool::fetch_xor&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Побитовый xor с текущим значением, возвращающий предыдущее значение. Стабилизированная версия этой встроенной функции доступна для типов &lt;code&gt;std::sync::atomic&lt;/code&gt; через метод &lt;code&gt;fetch_xor&lt;/code&gt; , передав &lt;a href=&quot;../sync/atomic/enum.ordering&quot;&gt; &lt;code&gt;Ordering::Acquire&lt;/code&gt; &lt;/a&gt; в качестве &lt;code&gt;order&lt;/code&gt; . Например, &lt;a href=&quot;../sync/atomic/struct.atomicbool#method.fetch_xor&quot;&gt; &lt;code&gt;AtomicBool::fetch_xor&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="c5ce9f030ae16f9b2b741aab2abe9cb20f55a4eb" translate="yes" xml:space="preserve">
          <source>Bitwise xor with the current value, returning the previous value. The stabilized version of this intrinsic is available on the &lt;code&gt;std::sync::atomic&lt;/code&gt; types via the &lt;code&gt;fetch_xor&lt;/code&gt; method by passing &lt;a href=&quot;../sync/atomic/enum.ordering&quot;&gt;&lt;code&gt;Ordering::Relaxed&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;order&lt;/code&gt;. For example, &lt;a href=&quot;../sync/atomic/struct.atomicbool#method.fetch_xor&quot;&gt;&lt;code&gt;AtomicBool::fetch_xor&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Побитовый xor с текущим значением, возвращающий предыдущее значение. Стабилизированная версия этой встроенной функции доступна для типов &lt;code&gt;std::sync::atomic&lt;/code&gt; через метод &lt;code&gt;fetch_xor&lt;/code&gt; , передав &lt;a href=&quot;../sync/atomic/enum.ordering&quot;&gt; &lt;code&gt;Ordering::Relaxed&lt;/code&gt; &lt;/a&gt; в качестве &lt;code&gt;order&lt;/code&gt; . Например, &lt;a href=&quot;../sync/atomic/struct.atomicbool#method.fetch_xor&quot;&gt; &lt;code&gt;AtomicBool::fetch_xor&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="15836191977a94f34a9eedc80d403307d7b6d4ed" translate="yes" xml:space="preserve">
          <source>Bitwise xor with the current value, returning the previous value. The stabilized version of this intrinsic is available on the &lt;code&gt;std::sync::atomic&lt;/code&gt; types via the &lt;code&gt;fetch_xor&lt;/code&gt; method by passing &lt;a href=&quot;../sync/atomic/enum.ordering&quot;&gt;&lt;code&gt;Ordering::Release&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;order&lt;/code&gt;. For example, &lt;a href=&quot;../sync/atomic/struct.atomicbool#method.fetch_xor&quot;&gt;&lt;code&gt;AtomicBool::fetch_xor&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Побитовый xor с текущим значением, возвращающий предыдущее значение. Стабилизированная версия этой встроенной функции доступна для типов &lt;code&gt;std::sync::atomic&lt;/code&gt; через метод &lt;code&gt;fetch_xor&lt;/code&gt; , передав &lt;a href=&quot;../sync/atomic/enum.ordering&quot;&gt; &lt;code&gt;Ordering::Release&lt;/code&gt; &lt;/a&gt; в качестве &lt;code&gt;order&lt;/code&gt; . Например, &lt;a href=&quot;../sync/atomic/struct.atomicbool#method.fetch_xor&quot;&gt; &lt;code&gt;AtomicBool::fetch_xor&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="ffe95ab6a76bb352e681774fae150809af8a6615" translate="yes" xml:space="preserve">
          <source>Bitwise xor with the current value, returning the previous value. The stabilized version of this intrinsic is available on the &lt;code&gt;std::sync::atomic&lt;/code&gt; types via the &lt;code&gt;fetch_xor&lt;/code&gt; method by passing &lt;a href=&quot;../sync/atomic/enum.ordering&quot;&gt;&lt;code&gt;Ordering::SeqCst&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;order&lt;/code&gt;. For example, &lt;a href=&quot;../sync/atomic/struct.atomicbool#method.fetch_xor&quot;&gt;&lt;code&gt;AtomicBool::fetch_xor&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Побитовый xor с текущим значением, возвращающий предыдущее значение. Стабилизированная версия этой встроенной функции доступна для типов &lt;code&gt;std::sync::atomic&lt;/code&gt; через метод &lt;code&gt;fetch_xor&lt;/code&gt; , передав &lt;a href=&quot;../sync/atomic/enum.ordering&quot;&gt; &lt;code&gt;Ordering::SeqCst&lt;/code&gt; &lt;/a&gt; в качестве &lt;code&gt;order&lt;/code&gt; . Например, &lt;a href=&quot;../sync/atomic/struct.atomicbool#method.fetch_xor&quot;&gt; &lt;code&gt;AtomicBool::fetch_xor&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="88de087af89700f4c1004e0042a100c96cfad709" translate="yes" xml:space="preserve">
          <source>Blanket Implementations</source>
          <target state="translated">Охватывающие имплементации</target>
        </trans-unit>
        <trans-unit id="7ebf10e8c63d15dc33875a65edf15f33311b088f" translate="yes" xml:space="preserve">
          <source>Blanket implementation</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b62ea629ea517115ba87dea634c655ff0a340dd4" translate="yes" xml:space="preserve">
          <source>Blanket implementations appear in the documentation for the trait in the &amp;ldquo;Implementors&amp;rdquo; section.</source>
          <target state="translated">Общие реализации появляются в документации для трейта в разделе &amp;laquo;Разработчики&amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="a06bbda0eab9ea08dbe94577274cbb7b473571d4" translate="yes" xml:space="preserve">
          <source>Block comment</source>
          <target state="translated">Блок-комментарий</target>
        </trans-unit>
        <trans-unit id="684096ae991ba36b90c5953d624c41ac5080dfdf" translate="yes" xml:space="preserve">
          <source>Block expression</source>
          <target state="translated">Блок-выражение</target>
        </trans-unit>
        <trans-unit id="8b403969dc1821977a4545f2dd574d603b1654fd" translate="yes" xml:space="preserve">
          <source>Block expressions</source>
          <target state="translated">Блочные выражения</target>
        </trans-unit>
        <trans-unit id="7805c38c778b7b8d59aebeff2b37473f6e635d86" translate="yes" xml:space="preserve">
          <source>Block expressions as elements of &lt;a href=&quot;array-expr&quot;&gt;array expressions&lt;/a&gt;, &lt;a href=&quot;tuple-expr&quot;&gt;tuple expressions&lt;/a&gt;, &lt;a href=&quot;call-expr&quot;&gt;call expressions&lt;/a&gt;, and tuple-style &lt;a href=&quot;struct-expr&quot;&gt;struct&lt;/a&gt; and &lt;a href=&quot;enum-variant-expr&quot;&gt;enum variant&lt;/a&gt; expressions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9e069137567cf4c22756c0a181e015e273f3b097" translate="yes" xml:space="preserve">
          <source>Block expressions as elements of &lt;a href=&quot;array-expr&quot;&gt;array expressions&lt;/a&gt;, &lt;a href=&quot;tuple-expr&quot;&gt;tuple expressions&lt;/a&gt;, &lt;a href=&quot;call-expr&quot;&gt;call expressions&lt;/a&gt;, tuple-style &lt;a href=&quot;struct-expr&quot;&gt;struct&lt;/a&gt; and &lt;a href=&quot;enum-variant-expr&quot;&gt;enum variant&lt;/a&gt; expressions.</source>
          <target state="translated">Блок выражение в качестве элементов &lt;a href=&quot;array-expr&quot;&gt;выражений массива&lt;/a&gt; , &lt;a href=&quot;tuple-expr&quot;&gt;кортеж выражений&lt;/a&gt; , &lt;a href=&quot;call-expr&quot;&gt;выражений вызова&lt;/a&gt; , кортеж стиля &lt;a href=&quot;struct-expr&quot;&gt;структуры&lt;/a&gt; и &lt;a href=&quot;enum-variant-expr&quot;&gt;перечисление вариантных&lt;/a&gt; выражений.</target>
        </trans-unit>
        <trans-unit id="502282ec9c201c5e6057f4beae39b5897d6f29ed" translate="yes" xml:space="preserve">
          <source>Block expressions used as a &lt;a href=&quot;../statements&quot;&gt;statement&lt;/a&gt;.</source>
          <target state="translated">Блочные выражения, используемые как &lt;a href=&quot;../statements&quot;&gt;оператор&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="d83a4ba900681b1d6bb448e76ababb6b95a22052" translate="yes" xml:space="preserve">
          <source>Blocks are always &lt;a href=&quot;../expressions#place-expressions-and-value-expressions&quot;&gt;value expressions&lt;/a&gt; and evaluate the last expression in value expression context. This can be used to force moving a value if really needed. For example, the following example fails on the call to &lt;code&gt;consume_self&lt;/code&gt; because the struct was moved out of &lt;code&gt;s&lt;/code&gt; in the block expression.</source>
          <target state="translated">Блоки всегда являются &lt;a href=&quot;../expressions#place-expressions-and-value-expressions&quot;&gt;выражениями значений&lt;/a&gt; и оценивают последнее выражение в контексте выражения значения. Это можно использовать для принудительного перемещения значения, если это действительно необходимо. Например, в следующем примере &lt;code&gt;consume_self&lt;/code&gt; сбой при вызове consumer_self, потому что структура была перемещена из &lt;code&gt;s&lt;/code&gt; в выражении блока.</target>
        </trans-unit>
        <trans-unit id="c18efbe7496c8880dfb8b33f1bb639d10ba9c80d" translate="yes" xml:space="preserve">
          <source>Blocks are written as &lt;code&gt;{&lt;/code&gt;, then any &lt;a href=&quot;../attributes&quot;&gt;inner attributes&lt;/a&gt;, then &lt;a href=&quot;../statements&quot;&gt;statements&lt;/a&gt;, then an optional expression, and finally a &lt;code&gt;}&lt;/code&gt;. Statements are usually required to be followed a semicolon, with two exceptions. Item declaration statements do not need to be followed by a semicolon. Expression statements usually require a following semicolon except if its outer expression is a flow control expression. Furthermore, extra semicolons between statements are allowed, but these semicolons do not affect semantics.</source>
          <target state="translated">Блоки записываются как &lt;code&gt;{&lt;/code&gt; , затем любые &lt;a href=&quot;../attributes&quot;&gt;внутренние атрибуты&lt;/a&gt; , затем &lt;a href=&quot;../statements&quot;&gt;операторы&lt;/a&gt; , затем необязательное выражение и, наконец, a &lt;code&gt;}&lt;/code&gt; . Заявления обычно ставятся после точки с запятой, за двумя исключениями. В объявлениях элементов не обязательно ставить точку с запятой. Для операторов выражения обычно требуется следующая точка с запятой, за исключением случаев, когда его внешнее выражение является выражением управления потоком. Кроме того, между операторами разрешены дополнительные точки с запятой, но эти точки с запятой не влияют на семантику.</target>
        </trans-unit>
        <trans-unit id="ae067769ea09e9988dc3c94bd840ffd9a2112129" translate="yes" xml:space="preserve">
          <source>Blocks are written as &lt;code&gt;{&lt;/code&gt;, then any &lt;a href=&quot;../attributes&quot;&gt;inner attributes&lt;/a&gt;, then &lt;a href=&quot;../statements&quot;&gt;statements&lt;/a&gt;, then an optional expression, and finally a &lt;code&gt;}&lt;/code&gt;. Statements are usually required to be followed by a semicolon, with two exceptions. Item declaration statements do not need to be followed by a semicolon. Expression statements usually require a following semicolon except if its outer expression is a flow control expression. Furthermore, extra semicolons between statements are allowed, but these semicolons do not affect semantics.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b3b5253f4cf51bfc8b7e410d8b0b217d0e9c0335" translate="yes" xml:space="preserve">
          <source>Blocks the current thread until all threads have rendezvoused here.</source>
          <target state="translated">Блокирует текущий поток до тех пор,пока все потоки не встретились здесь.</target>
        </trans-unit>
        <trans-unit id="d45aaa4f52bf36a05dbf87c3a8418aac5e1ca210" translate="yes" xml:space="preserve">
          <source>Blocks the current thread until this condition variable receives a notification and the provided condition is false.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6fa33f5cb6fe4954947bbb580e0c51b7b87a1d8c" translate="yes" xml:space="preserve">
          <source>Blocks the current thread until this condition variable receives a notification and the required condition is met. Spurious wakeups are ignored and this function will only return once the condition has been met.</source>
          <target state="translated">Блокирует текущий поток до тех пор,пока эта переменная условия не получит уведомление и необходимое условие не будет выполнено.Поддельные пробуждения игнорируются,и эта функция вернется только после выполнения условия.</target>
        </trans-unit>
        <trans-unit id="80e976210b81b30997de305efb4640d505e6cf39" translate="yes" xml:space="preserve">
          <source>Blocks the current thread until this condition variable receives a notification.</source>
          <target state="translated">Блокирует текущий поток до тех пор,пока данная переменная условия не получит уведомление.</target>
        </trans-unit>
        <trans-unit id="410a3ef0dd4f7761ff571ad2f23d0ad96832450b" translate="yes" xml:space="preserve">
          <source>Blocks unless or until the current thread's token is made available or the specified duration has been reached (may wake spuriously).</source>
          <target state="translated">Блокирует до тех пор,пока не станет доступен токен текущей нити или пока не будет достигнута указанная продолжительность (может пробудиться ложно).</target>
        </trans-unit>
        <trans-unit id="7e4f7a13eb5259dea6da862f685681bb73f6e91b" translate="yes" xml:space="preserve">
          <source>Blocks unless or until the current thread's token is made available.</source>
          <target state="translated">Блокирует до тех пор,пока не станет доступен токен текущей резьбы или пока он не станет доступен.</target>
        </trans-unit>
        <trans-unit id="e81a87a7fdc340ba3287800ef9018a00b1adc455" translate="yes" xml:space="preserve">
          <source>Blocks: if a block has type &lt;code&gt;U&lt;/code&gt;, then the last expression in the block (if it is not semicolon-terminated) is a coercion site to &lt;code&gt;U&lt;/code&gt;. This includes blocks which are part of control flow statements, such as &lt;code&gt;if&lt;/code&gt;/&lt;code&gt;else&lt;/code&gt;, if the block has a known type.</source>
          <target state="translated">Блоки: если блок имеет типа &lt;code&gt;U&lt;/code&gt; , то последнее выражение в блоке (если он не точка с запятой концевым) является принуждение сайта &lt;code&gt;U&lt;/code&gt; . Сюда входят блоки, которые являются частью операторов потока управления, например &lt;code&gt;if&lt;/code&gt; / &lt;code&gt;else&lt;/code&gt; , если блок имеет известный тип.</target>
        </trans-unit>
        <trans-unit id="104329f4432c8b8b5d3c19fc3d250dfe2ab027d2" translate="yes" xml:space="preserve">
          <source>Bodies of unsafe functions are effectively &lt;code&gt;unsafe&lt;/code&gt; blocks, so to perform other unsafe operations within an unsafe function, we don&amp;rsquo;t need to add another &lt;code&gt;unsafe&lt;/code&gt; block.</source>
          <target state="translated">Тела небезопасных функций фактически являются &lt;code&gt;unsafe&lt;/code&gt; блоками, поэтому для выполнения других небезопасных операций внутри небезопасной функции нам не нужно добавлять еще один &lt;code&gt;unsafe&lt;/code&gt; блок.</target>
        </trans-unit>
        <trans-unit id="c9a26dc7a812c76d486afec462ae9a205a68b3e6" translate="yes" xml:space="preserve">
          <source>Boolean literals</source>
          <target state="translated">булевские буквы</target>
        </trans-unit>
        <trans-unit id="49f29c844f200eead7503c6d10737135d242ba2b" translate="yes" xml:space="preserve">
          <source>Boolean type</source>
          <target state="translated">булевский тип</target>
        </trans-unit>
        <trans-unit id="cb4702d3f3cd69e09a0563d0dcdc4d54d0023693" translate="yes" xml:space="preserve">
          <source>Borrow</source>
          <target state="translated">Borrow</target>
        </trans-unit>
        <trans-unit id="1fd0a944ea8cfb257b2b56f1afcd67ff9e3b25e2" translate="yes" xml:space="preserve">
          <source>Borrow operators</source>
          <target state="translated">Заёмщики</target>
        </trans-unit>
        <trans-unit id="08ef91a49ea57c4babbbcf16cff803659fb46ac3" translate="yes" xml:space="preserve">
          <source>Borrow::borrow</source>
          <target state="translated">Borrow::borrow</target>
        </trans-unit>
        <trans-unit id="2928c5f6ce470ed45869ce9bc666a02f1b276c3c" translate="yes" xml:space="preserve">
          <source>BorrowError</source>
          <target state="translated">BorrowError</target>
        </trans-unit>
        <trans-unit id="cd83210bbc26f6a86f78acc2c5aab6cb300d7a3f" translate="yes" xml:space="preserve">
          <source>BorrowError::borrow</source>
          <target state="translated">BorrowError::borrow</target>
        </trans-unit>
        <trans-unit id="522f3d26a1b9c184b1451ca62d5ed845e00d0b54" translate="yes" xml:space="preserve">
          <source>BorrowError::borrow_mut</source>
          <target state="translated">BorrowError::borrow_mut</target>
        </trans-unit>
        <trans-unit id="7a951e76d02cd0d1326baee884b3df884ef7505b" translate="yes" xml:space="preserve">
          <source>BorrowError::cause</source>
          <target state="translated">BorrowError::cause</target>
        </trans-unit>
        <trans-unit id="9346d595a8c0688d171353745aeb9cb098c34080" translate="yes" xml:space="preserve">
          <source>BorrowError::description</source>
          <target state="translated">BorrowError::description</target>
        </trans-unit>
        <trans-unit id="89396ee3db16dbcc29597b262afc46558ed2366f" translate="yes" xml:space="preserve">
          <source>BorrowError::fmt</source>
          <target state="translated">BorrowError::fmt</target>
        </trans-unit>
        <trans-unit id="f021a214bcd178a0ea344c71db12231f4f31c50f" translate="yes" xml:space="preserve">
          <source>BorrowError::from</source>
          <target state="translated">BorrowError::from</target>
        </trans-unit>
        <trans-unit id="886751874954c88f3e019db825f51742642c3fcc" translate="yes" xml:space="preserve">
          <source>BorrowError::into</source>
          <target state="translated">BorrowError::into</target>
        </trans-unit>
        <trans-unit id="26e12b28f77d9243f30385a8268af2b47555aa7c" translate="yes" xml:space="preserve">
          <source>BorrowError::source</source>
          <target state="translated">BorrowError::source</target>
        </trans-unit>
        <trans-unit id="13b09f10b5e2154e8e5ae8b9b7bc53371a685504" translate="yes" xml:space="preserve">
          <source>BorrowError::to_string</source>
          <target state="translated">BorrowError::to_string</target>
        </trans-unit>
        <trans-unit id="2ce8439dd5781fe13a435aac312be62b63c7c5be" translate="yes" xml:space="preserve">
          <source>BorrowError::try_from</source>
          <target state="translated">BorrowError::try_from</target>
        </trans-unit>
        <trans-unit id="433ecad73e66b8dc9a31fe37870bbe334a572245" translate="yes" xml:space="preserve">
          <source>BorrowError::try_into</source>
          <target state="translated">BorrowError::try_into</target>
        </trans-unit>
        <trans-unit id="65acd86f1a255edf5a9bf5a76b81126963ed5e13" translate="yes" xml:space="preserve">
          <source>BorrowError::type_id</source>
          <target state="translated">BorrowError::type_id</target>
        </trans-unit>
        <trans-unit id="7ecce6e07f46ad690e4097354d0bc6aaa0f99008" translate="yes" xml:space="preserve">
          <source>BorrowMut</source>
          <target state="translated">BorrowMut</target>
        </trans-unit>
        <trans-unit id="d9285d895ed643451254273bc8c4bbd62b0abca2" translate="yes" xml:space="preserve">
          <source>BorrowMut::borrow_mut</source>
          <target state="translated">BorrowMut::borrow_mut</target>
        </trans-unit>
        <trans-unit id="05ef9e71b85c91963a382e2cbdd7ebb51b1ef2c3" translate="yes" xml:space="preserve">
          <source>BorrowMutError</source>
          <target state="translated">BorrowMutError</target>
        </trans-unit>
        <trans-unit id="6c84f92cc03620eeb60a2a75a6198806e41c99cf" translate="yes" xml:space="preserve">
          <source>BorrowMutError::borrow</source>
          <target state="translated">BorrowMutError::borrow</target>
        </trans-unit>
        <trans-unit id="c9194e522b34f7f0397b113f83851e0a0750ebff" translate="yes" xml:space="preserve">
          <source>BorrowMutError::borrow_mut</source>
          <target state="translated">BorrowMutError::borrow_mut</target>
        </trans-unit>
        <trans-unit id="320189f255d75bf0531f1d4da80752757ad88765" translate="yes" xml:space="preserve">
          <source>BorrowMutError::cause</source>
          <target state="translated">BorrowMutError::cause</target>
        </trans-unit>
        <trans-unit id="5d91335b7a43a382a81f901fb2092637fc2b1b30" translate="yes" xml:space="preserve">
          <source>BorrowMutError::description</source>
          <target state="translated">BorrowMutError::description</target>
        </trans-unit>
        <trans-unit id="de7386f3e6ce0f0541da576e92b462815d327aa2" translate="yes" xml:space="preserve">
          <source>BorrowMutError::fmt</source>
          <target state="translated">BorrowMutError::fmt</target>
        </trans-unit>
        <trans-unit id="0eaaabb7614aee38df98b183695570760d2a3bd8" translate="yes" xml:space="preserve">
          <source>BorrowMutError::from</source>
          <target state="translated">BorrowMutError::from</target>
        </trans-unit>
        <trans-unit id="f361017eeaa59fd5af6e66dc8387dd7623505766" translate="yes" xml:space="preserve">
          <source>BorrowMutError::into</source>
          <target state="translated">BorrowMutError::into</target>
        </trans-unit>
        <trans-unit id="4c422d071ef6d2a11942aa38c90bd2712b395f0a" translate="yes" xml:space="preserve">
          <source>BorrowMutError::source</source>
          <target state="translated">BorrowMutError::source</target>
        </trans-unit>
        <trans-unit id="2eb0e23a66aa4d528bf24f44d0b10d6fbb428403" translate="yes" xml:space="preserve">
          <source>BorrowMutError::to_string</source>
          <target state="translated">BorrowMutError::to_string</target>
        </trans-unit>
        <trans-unit id="b02bd0326962794fede5f5e186f12a2fd926a13b" translate="yes" xml:space="preserve">
          <source>BorrowMutError::try_from</source>
          <target state="translated">BorrowMutError::try_from</target>
        </trans-unit>
        <trans-unit id="6719140c2e78bc9c851d093ca84a7d95a4fe42cf" translate="yes" xml:space="preserve">
          <source>BorrowMutError::try_into</source>
          <target state="translated">BorrowMutError::try_into</target>
        </trans-unit>
        <trans-unit id="aed34dec1357c0aa84876bb9c79b00511d803df2" translate="yes" xml:space="preserve">
          <source>BorrowMutError::type_id</source>
          <target state="translated">BorrowMutError::type_id</target>
        </trans-unit>
        <trans-unit id="5868e9faf108a7771c407ab907889934dd63b50a" translate="yes" xml:space="preserve">
          <source>Borrowed data.</source>
          <target state="translated">Заимствованные данные.</target>
        </trans-unit>
        <trans-unit id="c7098078c609573d3fe94c28cfeb29c10812c3db" translate="yes" xml:space="preserve">
          <source>Borrowed pointer type</source>
          <target state="translated">Заимствованный тип указателя</target>
        </trans-unit>
        <trans-unit id="74d965d163933b4d9c245330d676a9a3a774550a" translate="yes" xml:space="preserve">
          <source>Borrowed reference to an OS string (see &lt;a href=&quot;struct.osstring&quot;&gt;&lt;code&gt;OsString&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">Заимствованная ссылка на строку ОС (см. &lt;a href=&quot;struct.osstring&quot;&gt; &lt;code&gt;OsString&lt;/code&gt; &lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="885dff407470f8d8cfa69af65835344b4ec2492e" translate="yes" xml:space="preserve">
          <source>Borrows an iterator, rather than consuming it.</source>
          <target state="translated">Зарывает итератор,вместо того,чтобы потреблять его.</target>
        </trans-unit>
        <trans-unit id="e4b68387bd9a788e153fefb151f2e36c5cc3e492" translate="yes" xml:space="preserve">
          <source>Borrows an iterator, rather than consuming it. &lt;a href=&quot;../../../iter/trait.iterator#method.by_ref&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">Заимствует итератор, а не использует его. &lt;a href=&quot;../../../iter/trait.iterator#method.by_ref&quot;&gt;Читать далее&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="4c2a592fe9d3573696dcb4e01f0c58c8f29d9729" translate="yes" xml:space="preserve">
          <source>Borrows an iterator, rather than consuming it. &lt;a href=&quot;../../iter/trait.iterator#method.by_ref&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">Заимствует итератор, а не использует его. &lt;a href=&quot;../../iter/trait.iterator#method.by_ref&quot;&gt;Читать далее&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="dc9f6098309a428e4660e57ac0d7a128a57eb4f3" translate="yes" xml:space="preserve">
          <source>Borrows an iterator, rather than consuming it. &lt;a href=&quot;../iter/trait.iterator#method.by_ref&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">Заимствует итератор, а не использует его. &lt;a href=&quot;../iter/trait.iterator#method.by_ref&quot;&gt;Читать далее&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="b4d7aa1610c7d0263c276944863186c7f5b54aca" translate="yes" xml:space="preserve">
          <source>Borrows an iterator, rather than consuming it. &lt;a href=&quot;iter/trait.iterator#method.by_ref&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">Заимствует итератор, а не использует его. &lt;a href=&quot;iter/trait.iterator#method.by_ref&quot;&gt;Читать далее&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="0448c3473f95cd23244ee44dd3147a10fd3dd487" translate="yes" xml:space="preserve">
          <source>Borrows an iterator, rather than consuming it. &lt;a href=&quot;trait.iterator#method.by_ref&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">Заимствует итератор, а не использует его. &lt;a href=&quot;trait.iterator#method.by_ref&quot;&gt;Читать далее&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="f99b7e6b9280152eedd396f475e3d3c1511ee27c" translate="yes" xml:space="preserve">
          <source>Both &lt;a href=&quot;book/ch17-02-trait-objects#using-trait-objects-that-allow-for-values-of-different-types&quot;&gt;&lt;code&gt;dyn Trait&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;book/ch10-02-traits#returning-types-that-implement-traits&quot;&gt;&lt;code&gt;impl Trait&lt;/code&gt;&lt;/a&gt; in return types have a an implicit &lt;code&gt;'static&lt;/code&gt; requirement, meaning that the value implementing them that is being returned has to be either a &lt;code&gt;'static&lt;/code&gt; borrow or an owned value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5f521714f9167c57599a72f6be51da170e80a3dd" translate="yes" xml:space="preserve">
          <source>Both &lt;a href=&quot;items/constant-items&quot;&gt;constant&lt;/a&gt; and &lt;a href=&quot;items/static-items&quot;&gt;static&lt;/a&gt; declarations of reference types have &lt;em&gt;implicit&lt;/em&gt;&lt;code&gt;'static&lt;/code&gt; lifetimes unless an explicit lifetime is specified. As such, the constant declarations involving &lt;code&gt;'static&lt;/code&gt; above may be written without the lifetimes.</source>
          <target state="translated">И &lt;a href=&quot;items/constant-items&quot;&gt;постоянные,&lt;/a&gt; и &lt;a href=&quot;items/static-items&quot;&gt;статические&lt;/a&gt; объявления ссылочных типов имеют &lt;em&gt;неявное &lt;/em&gt; &lt;code&gt;'static&lt;/code&gt; время жизни&amp;raquo;, если не указано явное время жизни. Таким образом, объявления констант, включающие &lt;code&gt;'static&lt;/code&gt; выше, могут быть написаны без времени жизни.</target>
        </trans-unit>
        <trans-unit id="05a5142bb4165da20e62a15a12a49d69f51e7d7c" translate="yes" xml:space="preserve">
          <source>Both &lt;a href=&quot;struct.mutex&quot;&gt;&lt;code&gt;Mutex&lt;/code&gt;&lt;/a&gt;es and &lt;a href=&quot;struct.rwlock&quot;&gt;&lt;code&gt;RwLock&lt;/code&gt;&lt;/a&gt;s are poisoned whenever a thread fails while the lock is held. The precise semantics for when a lock is poisoned is documented on each lock, but once a lock is poisoned then all future acquisitions will return this error.</source>
          <target state="translated">Оба &lt;a href=&quot;struct.mutex&quot;&gt; &lt;code&gt;Mutex&lt;/code&gt; &lt;/a&gt; эс и &lt;a href=&quot;struct.rwlock&quot;&gt; &lt;code&gt;RwLock&lt;/code&gt; &lt;/a&gt; s отравлены , когда поток не удается , пока блокировка удерживается. Точная семантика того, когда блокировка отравлена, задокументирована для каждой блокировки, но как только блокировка отравлена, все будущие приобретения будут возвращать эту ошибку.</target>
        </trans-unit>
        <trans-unit id="92f3e1242e71f216f2553ecade5c0b56c112c46f" translate="yes" xml:space="preserve">
          <source>Both &lt;code&gt;src&lt;/code&gt; and &lt;code&gt;dst&lt;/code&gt; must be properly aligned.</source>
          <target state="translated">Оба &lt;code&gt;src&lt;/code&gt; и &lt;code&gt;dst&lt;/code&gt; должны быть правильно выровнены.</target>
        </trans-unit>
        <trans-unit id="c1a304706d4634a69f512f48a553ca6de0a57224" translate="yes" xml:space="preserve">
          <source>Both &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; must be &lt;a href=&quot;index#safety&quot;&gt;valid&lt;/a&gt; for both reads and writes of &lt;code&gt;count * size_of::&amp;lt;T&amp;gt;()&lt;/code&gt; bytes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="62b58df899df91147ad1851a44f1534537b8baae" translate="yes" xml:space="preserve">
          <source>Both &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; must be &lt;a href=&quot;index#safety&quot;&gt;valid&lt;/a&gt; for both reads and writes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2af274f82063aea319dd50db89daaff81dd41c5b" translate="yes" xml:space="preserve">
          <source>Both &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; must be &lt;a href=&quot;index#safety&quot;&gt;valid&lt;/a&gt; for reads and writes of &lt;code&gt;count * size_of::&amp;lt;T&amp;gt;()&lt;/code&gt; bytes.</source>
          <target state="translated">И &lt;code&gt;x&lt;/code&gt; , и &lt;code&gt;y&lt;/code&gt; должны быть &lt;a href=&quot;index#safety&quot;&gt;допустимыми&lt;/a&gt; для чтения и записи &lt;code&gt;count * size_of::&amp;lt;T&amp;gt;()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f6aa81faf4ff06762f89afa21d147f447e5913ea" translate="yes" xml:space="preserve">
          <source>Both &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; must be &lt;a href=&quot;index#safety&quot;&gt;valid&lt;/a&gt; for reads and writes.</source>
          <target state="translated">И &lt;code&gt;x&lt;/code&gt; , и &lt;code&gt;y&lt;/code&gt; должны быть &lt;a href=&quot;index#safety&quot;&gt;допустимыми&lt;/a&gt; для чтения и записи.</target>
        </trans-unit>
        <trans-unit id="ab994fd6a56d4038a2b10fa7688bd17375033138" translate="yes" xml:space="preserve">
          <source>Both &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; must be properly aligned.</source>
          <target state="translated">Оба &lt;code&gt;x&lt;/code&gt; и &lt;code&gt;y&lt;/code&gt; должны быть правильно выровнены.</target>
        </trans-unit>
        <trans-unit id="c79da800bdef51dcfa75d10a65ea136a827d95b9" translate="yes" xml:space="preserve">
          <source>Both absolute and relative paths are followed by one or more identifiers separated by double colons (&lt;code&gt;::&lt;/code&gt;).</source>
          <target state="translated">За абсолютным и относительным путями следует один или несколько идентификаторов, разделенных двойным двоеточием ( &lt;code&gt;::&lt;/code&gt; :) .</target>
        </trans-unit>
        <trans-unit id="c285e2e79ff8d2abdbcbfce35a32a0f639fd60af" translate="yes" xml:space="preserve">
          <source>Both are equivalent to:</source>
          <target state="translated">Оба эквивалентны:</target>
        </trans-unit>
        <trans-unit id="d969a72eda5767cc021898e028fbe0fc071270ae" translate="yes" xml:space="preserve">
          <source>Both attributes can be used on &lt;a href=&quot;../items/functions&quot;&gt;functions&lt;/a&gt;. When applied to a function in a &lt;a href=&quot;../items/traits&quot;&gt;trait&lt;/a&gt;, they apply only to that function when used as a default function for a trait implementation and not to all trait implementations. The attributes have no effect on a trait function without a body.</source>
          <target state="translated">Оба атрибута можно использовать в &lt;a href=&quot;../items/functions&quot;&gt;функциях&lt;/a&gt; . Когда они применяются к функции в &lt;a href=&quot;../items/traits&quot;&gt;признаке&lt;/a&gt; , они применяются только к этой функции при использовании в качестве функции по умолчанию для реализации признака, а не ко всем реализациям признака. Атрибуты не влияют на функцию трейта без тела.</target>
        </trans-unit>
        <trans-unit id="969434c27ab08daa9144a7ddff09f258b6b015fd" translate="yes" xml:space="preserve">
          <source>Both match arms must produce values of type &lt;a href=&quot;https://doc.rust-lang.org/nightly/std/primitive.u32.html&quot;&gt;&lt;code&gt;u32&lt;/code&gt;&lt;/a&gt;, but since &lt;code&gt;break&lt;/code&gt; never produces a value at all we know it can never produce a value which isn't a &lt;a href=&quot;https://doc.rust-lang.org/nightly/std/primitive.u32.html&quot;&gt;&lt;code&gt;u32&lt;/code&gt;&lt;/a&gt;. This illustrates another behaviour of the &lt;code&gt;!&lt;/code&gt; type - expressions with type &lt;code&gt;!&lt;/code&gt; will coerce into any other type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f415dc3d7d35015fcd0e7c895d9cc2c978758324" translate="yes" xml:space="preserve">
          <source>Both match arms must produce values of type &lt;a href=&quot;primitive.str&quot;&gt;&lt;code&gt;u32&lt;/code&gt;&lt;/a&gt;, but since &lt;code&gt;break&lt;/code&gt; never produces a value at all we know it can never produce a value which isn't a &lt;a href=&quot;primitive.str&quot;&gt;&lt;code&gt;u32&lt;/code&gt;&lt;/a&gt;. This illustrates another behaviour of the &lt;code&gt;!&lt;/code&gt; type - expressions with type &lt;code&gt;!&lt;/code&gt; will coerce into any other type.</source>
          <target state="translated">Оба &lt;a href=&quot;primitive.str&quot;&gt; &lt;code&gt;u32&lt;/code&gt; &lt;/a&gt; должны выдавать значения типа u32 , но, поскольку &lt;code&gt;break&lt;/code&gt; никогда не дает значения, мы знаем, что он никогда не может произвести значение, &lt;a href=&quot;primitive.str&quot;&gt; &lt;code&gt;u32&lt;/code&gt; &lt;/a&gt; от u32 . Это иллюстрирует другое поведение &lt;code&gt;!&lt;/code&gt; type - выражения с типом &lt;code&gt;!&lt;/code&gt; будет принуждать к любому другому типу.</target>
        </trans-unit>
        <trans-unit id="cc4e0abfff334b57590e92cdeed48cb0b5815f3f" translate="yes" xml:space="preserve">
          <source>Both of the following must be true:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8047c2fba1b8345d0b2a7bfe41d16519cea0cd82" translate="yes" xml:space="preserve">
          <source>Both pointers must be &lt;em&gt;derived from&lt;/em&gt; a pointer to the same object. (See below for an example.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2bf778379c09be3c08a3e90c46c05409146c7bf5" translate="yes" xml:space="preserve">
          <source>Both the &lt;code&gt;Post&lt;/code&gt; and &lt;code&gt;DraftPost&lt;/code&gt; structs have a private &lt;code&gt;content&lt;/code&gt; field that stores the blog post text. The structs no longer have the &lt;code&gt;state&lt;/code&gt; field because we&amp;rsquo;re moving the encoding of the state to the types of the structs. The &lt;code&gt;Post&lt;/code&gt; struct will represent a published post, and it has a &lt;code&gt;content&lt;/code&gt; method that returns the &lt;code&gt;content&lt;/code&gt;.</source>
          <target state="translated">И в структурах &lt;code&gt;Post&lt;/code&gt; , и в &lt;code&gt;DraftPost&lt;/code&gt; есть личное поле &lt;code&gt;content&lt;/code&gt; котором хранится текст сообщения в блоге. У структур больше нет поля &lt;code&gt;state&lt;/code&gt; потому что мы перемещаем кодировку состояния в типы структур. Структура &lt;code&gt;Post&lt;/code&gt; будет представлять опубликованную запись и имеет метод &lt;code&gt;content&lt;/code&gt; который возвращает &lt;code&gt;content&lt;/code&gt; .</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
