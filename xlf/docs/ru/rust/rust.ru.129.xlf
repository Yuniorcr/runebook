<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ru" datatype="htmlbody" original="rust">
    <body>
      <group id="rust">
        <trans-unit id="8b31f38dd6420c845ba1f6d21593f75a93127852" translate="yes" xml:space="preserve">
          <source>Signals the processor that it is inside a busy-wait spin-loop (&quot;spin lock&quot;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6e3665d85fde70112ccec1bb287428d4fd142fcc" translate="yes" xml:space="preserve">
          <source>Signed</source>
          <target state="translated">Signed</target>
        </trans-unit>
        <trans-unit id="bbc2b0c702b08dd5d5de05934c9988f7f0eff014" translate="yes" xml:space="preserve">
          <source>Significantly, closure expressions &lt;em&gt;capture their environment&lt;/em&gt;, which regular &lt;a href=&quot;../items/functions&quot;&gt;function definitions&lt;/a&gt; do not. Without the &lt;code&gt;move&lt;/code&gt; keyword, the closure expression &lt;a href=&quot;../types/closure#capture-modes&quot;&gt;infers how it captures each variable from its environment&lt;/a&gt;, preferring to capture by shared reference, effectively borrowing all outer variables mentioned inside the closure's body. If needed the compiler will infer that instead mutable references should be taken, or that the values should be moved or copied (depending on their type) from the environment. A closure can be forced to capture its environment by copying or moving values by prefixing it with the &lt;code&gt;move&lt;/code&gt; keyword. This is often used to ensure that the closure's type is &lt;code&gt;'static&lt;/code&gt;.</source>
          <target state="translated">Примечательно, что выражения замыкания &lt;em&gt;фиксируют свое окружение&lt;/em&gt; , чего нет в &lt;a href=&quot;../items/functions&quot;&gt;определениях&lt;/a&gt; обычных функций . Без ключевого слова &lt;code&gt;move&lt;/code&gt; выражение замыкания &lt;a href=&quot;../types/closure#capture-modes&quot;&gt;определяет, как оно захватывает каждую переменную из своей среды&lt;/a&gt; , предпочитая захват по общей ссылке, эффективно заимствуя все внешние переменные, упомянутые в теле замыкания. При необходимости компилятор сделает вывод, что вместо них следует использовать изменяемые ссылки или что значения следует перемещать или копировать (в зависимости от их типа) из среды. Замыкание может быть принудительно захвачено своим окружением путем копирования или перемещения значений с помощью префикса с ключевым словом &lt;code&gt;move&lt;/code&gt; . Это часто используется, чтобы гарантировать, что тип закрытия является &lt;code&gt;'static&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a3a265e9f838485e31901511e6f2045135b0cce6" translate="yes" xml:space="preserve">
          <source>Similar in construction to &lt;code&gt;if let&lt;/code&gt;, the &lt;code&gt;while let&lt;/code&gt; conditional loop allows a &lt;code&gt;while&lt;/code&gt; loop to run for as long as a pattern continues to match. The example in Listing 18-2 shows a &lt;code&gt;while let&lt;/code&gt; loop that uses a vector as a stack and prints the values in the vector in the opposite order in which they were pushed.</source>
          <target state="translated">Аналогичный по конструкции , &lt;code&gt;if let&lt;/code&gt; , то в &lt;code&gt;while let&lt;/code&gt; условный цикл позволяет во &lt;code&gt;while&lt;/code&gt; цикла , чтобы работать до тех пор , пока картина продолжает соответствовать. Пример в листинге 18-2 показывает цикл &lt;code&gt;while let&lt;/code&gt; , который использует вектор в качестве стека и печатает значения в векторе в порядке, обратном тому, в котором они были помещены.</target>
        </trans-unit>
        <trans-unit id="64ae3c66d57a2a6b39e286d0598b2a92f6754d01" translate="yes" xml:space="preserve">
          <source>Similar to &lt;a href=&quot;../../../io/trait.read#method.read_exact&quot;&gt;&lt;code&gt;Read::read_exact&lt;/code&gt;&lt;/a&gt; but uses &lt;a href=&quot;#tymethod.read_at&quot;&gt;&lt;code&gt;read_at&lt;/code&gt;&lt;/a&gt; instead of &lt;code&gt;read&lt;/code&gt;.</source>
          <target state="translated">Аналогичен &lt;a href=&quot;../../../io/trait.read#method.read_exact&quot;&gt; &lt;code&gt;Read::read_exact&lt;/code&gt; &lt;/a&gt; но использует &lt;a href=&quot;#tymethod.read_at&quot;&gt; &lt;code&gt;read_at&lt;/code&gt; &lt;/a&gt; вместо &lt;code&gt;read&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e99138b160f2a86b9da9922eb45a2b91269d8bbe" translate="yes" xml:space="preserve">
          <source>Similar to &lt;a href=&quot;../../../io/trait.read#method.read_exact&quot;&gt;&lt;code&gt;io::Read::read_exact&lt;/code&gt;&lt;/a&gt; but uses &lt;a href=&quot;trait.fileext#tymethod.read_at&quot;&gt;&lt;code&gt;read_at&lt;/code&gt;&lt;/a&gt; instead of &lt;code&gt;read&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="edd67ee22ad5d982cd10f26e69756d73303d48b2" translate="yes" xml:space="preserve">
          <source>Similar to &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt;, &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt; is only for use in single-threaded scenarios and will give you a compile-time error if you try using it in a multithreaded context. We&amp;rsquo;ll talk about how to get the functionality of &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt; in a multithreaded program in Chapter 16.</source>
          <target state="translated">Подобно &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; , &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt; предназначен только для использования в однопоточных сценариях и выдаст ошибку времени компиляции, если вы попытаетесь использовать его в многопоточном контексте. Мы поговорим о том, как получить функциональность &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt; в многопоточной программе в главе 16.</target>
        </trans-unit>
        <trans-unit id="4994bf8a405f841ed46d5b238330129c5daee3e1" translate="yes" xml:space="preserve">
          <source>Similar to &lt;code&gt;request_review&lt;/code&gt;, if we call the &lt;code&gt;approve&lt;/code&gt; method on a &lt;code&gt;Draft&lt;/code&gt;, it will have no effect because it will return &lt;code&gt;self&lt;/code&gt;. When we call &lt;code&gt;approve&lt;/code&gt; on &lt;code&gt;PendingReview&lt;/code&gt;, it returns a new, boxed instance of the &lt;code&gt;Published&lt;/code&gt; struct. The &lt;code&gt;Published&lt;/code&gt; struct implements the &lt;code&gt;State&lt;/code&gt; trait, and for both the &lt;code&gt;request_review&lt;/code&gt; method and the &lt;code&gt;approve&lt;/code&gt; method, it returns itself, because the post should stay in the &lt;code&gt;Published&lt;/code&gt; state in those cases.</source>
          <target state="translated">Как и в случае с &lt;code&gt;request_review&lt;/code&gt; , если мы вызовем метод &lt;code&gt;approve&lt;/code&gt; в &lt;code&gt;Draft&lt;/code&gt; , он не будет иметь никакого эффекта, потому что вернет &lt;code&gt;self&lt;/code&gt; . Когда мы вызываем &lt;code&gt;approve&lt;/code&gt; для &lt;code&gt;PendingReview&lt;/code&gt; , он возвращает новый упакованный экземпляр структуры &lt;code&gt;Published&lt;/code&gt; . Структура &lt;code&gt;Published&lt;/code&gt; реализует черту &lt;code&gt;State&lt;/code&gt; , и как для метода &lt;code&gt;request_review&lt;/code&gt; , так и для метода &lt;code&gt;approve&lt;/code&gt; она возвращает себя, потому что в этих случаях сообщение должно оставаться в состоянии &lt;code&gt;Published&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="88e10b6c2ce7d024990190fdfd83529adab1128c" translate="yes" xml:space="preserve">
          <source>Similar to &lt;code&gt;uid&lt;/code&gt;, but sets the group ID of the child process. This has the same semantics as the &lt;code&gt;uid&lt;/code&gt; field.</source>
          <target state="translated">Аналогичен &lt;code&gt;uid&lt;/code&gt; , но устанавливает идентификатор группы дочернего процесса. Имеет ту же семантику, что и поле &lt;code&gt;uid&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4e3696cd516232fdd3724614c9f05eedaa21b3e4" translate="yes" xml:space="preserve">
          <source>Similar to &lt;code&gt;uid&lt;/code&gt;, but sets the group ID of the child process. This has the same semantics as the &lt;code&gt;uid&lt;/code&gt; field. &lt;a href=&quot;../os/unix/process/trait.commandext#tymethod.gid&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">Аналогичен &lt;code&gt;uid&lt;/code&gt; , но устанавливает идентификатор группы дочернего процесса. Имеет ту же семантику, что и поле &lt;code&gt;uid&lt;/code&gt; . &lt;a href=&quot;../os/unix/process/trait.commandext#tymethod.gid&quot;&gt;Читать далее&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="f4bd1c5d39c2240e3d2e352bf6eab674bdb7120d" translate="yes" xml:space="preserve">
          <source>Similar to how we used test-driven development in the project in Chapter 12, we&amp;rsquo;ll use compiler-driven development here. We&amp;rsquo;ll write the code that calls the functions we want, and then we&amp;rsquo;ll look at errors from the compiler to determine what we should change next to get the code to work.</source>
          <target state="translated">Подобно тому, как мы использовали разработку через тестирование в проекте в главе 12, здесь мы будем использовать разработку через компилятор. Мы напишем код, который вызывает нужные нам функции, а затем посмотрим на ошибки компилятора, чтобы определить, что мы должны изменить дальше, чтобы код заработал.</target>
        </trans-unit>
        <trans-unit id="a44c70a0afcab0a2cb8b8b5e6459531560f406d9" translate="yes" xml:space="preserve">
          <source>Similar to how you use the &lt;code&gt;Deref&lt;/code&gt; trait to override the &lt;code&gt;*&lt;/code&gt; operator on immutable references, you can use the &lt;code&gt;DerefMut&lt;/code&gt; trait to override the &lt;code&gt;*&lt;/code&gt; operator on mutable references.</source>
          <target state="translated">Подобно тому, как вы используете &lt;code&gt;Deref&lt;/code&gt; для переопределения оператора &lt;code&gt;*&lt;/code&gt; в неизменяемых ссылках, вы можете использовать &lt;code&gt;DerefMut&lt;/code&gt; для переопределения оператора &lt;code&gt;*&lt;/code&gt; в изменяемых ссылках.</target>
        </trans-unit>
        <trans-unit id="07b70f124a730d4cd85b8e804701685c3f75301d" translate="yes" xml:space="preserve">
          <source>Similar to the way a function takes parameters with unknown values to run the same code on multiple concrete values, functions can take parameters of some generic type instead of a concrete type, like &lt;code&gt;i32&lt;/code&gt; or &lt;code&gt;String&lt;/code&gt;. In fact, we&amp;rsquo;ve already used generics in Chapter 6 with &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt;, Chapter 8 with &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; and &lt;code&gt;HashMap&amp;lt;K, V&amp;gt;&lt;/code&gt;, and Chapter 9 with &lt;code&gt;Result&amp;lt;T, E&amp;gt;&lt;/code&gt;. In this chapter, you&amp;rsquo;ll explore how to define your own types, functions, and methods with generics!</source>
          <target state="translated">Подобно тому, как функция принимает параметры с неизвестными значениями для запуска одного и того же кода для нескольких конкретных значений, функции могут принимать параметры некоторого универсального типа вместо конкретного типа, например &lt;code&gt;i32&lt;/code&gt; или &lt;code&gt;String&lt;/code&gt; . Фактически, мы уже использовали дженерики в главе 6 с &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt; , главе 8 с &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; и &lt;code&gt;HashMap&amp;lt;K, V&amp;gt;&lt;/code&gt; и главе 9 с &lt;code&gt;Result&amp;lt;T, E&amp;gt;&lt;/code&gt; . В этой главе вы узнаете, как определять свои собственные типы, функции и методы с помощью обобщений!</target>
        </trans-unit>
        <trans-unit id="6e8f822081e736e94d313c98afa2efd044c3746e" translate="yes" xml:space="preserve">
          <source>Similarily, calling &lt;code&gt;Pin::new_unchecked&lt;/code&gt; on an &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; is unsafe because there could be aliases to the same data that are not subject to the pinning restrictions:</source>
          <target state="translated">&lt;code&gt;Pin::new_unchecked&lt;/code&gt; вызов Pin :: new_unchecked для &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; небезопасен, потому что могут быть псевдонимы для тех же данных, которые не подпадают под ограничения закрепления:</target>
        </trans-unit>
        <trans-unit id="fc1608213ac13199c43c176b1bb1a0dafa112729" translate="yes" xml:space="preserve">
          <source>Similarities Between &lt;code id=&quot;similarities-between-refcelltrct-and-mutextarct&quot;&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt;/&lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; and &lt;code&gt;Mutex&amp;lt;T&amp;gt;&lt;/code&gt;/&lt;code&gt;Arc&amp;lt;T&amp;gt;&lt;/code&gt;</source>
          <target state="translated">Сходства между &lt;code id=&quot;similarities-between-refcelltrct-and-mutextarct&quot;&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt; / &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; и &lt;code&gt;Mutex&amp;lt;T&amp;gt;&lt;/code&gt; / &lt;code&gt;Arc&amp;lt;T&amp;gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="c9732fced80440502cea1e483af3c96733c510ed" translate="yes" xml:space="preserve">
          <source>Similarly to how adding more unit test functions adds more result lines to the unit tests section, adding more test functions to the integration test file adds more result lines to this integration test file&amp;rsquo;s section. Each integration test file has its own section, so if we add more files in the &lt;em&gt;tests&lt;/em&gt; directory, there will be more integration test sections.</source>
          <target state="translated">Аналогично тому, как добавление дополнительных функций модульного тестирования добавляет больше строк результатов в раздел модульных тестов, добавление дополнительных функций тестирования в файл интеграционного теста добавляет больше строк результатов в раздел этого файла интеграционного теста. Каждый файл интеграционного теста имеет свой собственный раздел, поэтому, если мы добавим больше файлов в каталог &lt;em&gt;тестов&lt;/em&gt; , будет больше разделов теста интеграции.</target>
        </trans-unit>
        <trans-unit id="7660d0adab8b6b631f474c1b7695efb3238541f3" translate="yes" xml:space="preserve">
          <source>Similarly, &lt;a href=&quot;../../../ffi/struct.osstr&quot;&gt;&lt;code&gt;OsStr&lt;/code&gt;&lt;/a&gt; is the Rust wrapper for borrowed strings from preferred representation of the operating system. On Windows, the &lt;a href=&quot;trait.osstrext&quot;&gt;&lt;code&gt;OsStrExt&lt;/code&gt;&lt;/a&gt; trait provides the &lt;a href=&quot;trait.osstrext#tymethod.encode_wide&quot;&gt;&lt;code&gt;OsStrExt::encode_wide&lt;/code&gt;&lt;/a&gt; method, which outputs an &lt;a href=&quot;struct.encodewide&quot;&gt;&lt;code&gt;EncodeWide&lt;/code&gt;&lt;/a&gt; iterator. You can &lt;a href=&quot;../../../iter/trait.iterator#method.collect&quot;&gt;&lt;code&gt;collect&lt;/code&gt;&lt;/a&gt; this iterator, for example, to obtain a &lt;code&gt;Vec&amp;lt;u16&amp;gt;&lt;/code&gt;; you can later get a pointer to this vector's contents and feed it to Windows APIs.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5b862eb4b9399982687d0163ad488253ccdc9958" translate="yes" xml:space="preserve">
          <source>Similarly, &lt;a href=&quot;../../../ffi/struct.osstr&quot;&gt;&lt;code&gt;OsStr&lt;/code&gt;&lt;/a&gt; is the Rust wrapper for borrowed strings from preferred representation of the operating system. On Windows, the &lt;a href=&quot;trait.osstrext&quot;&gt;&lt;code&gt;OsStrExt&lt;/code&gt;&lt;/a&gt; trait provides the &lt;a href=&quot;trait.osstrext#tymethod.encode_wide&quot;&gt;&lt;code&gt;encode_wide&lt;/code&gt;&lt;/a&gt; method, which outputs an &lt;a href=&quot;struct.encodewide&quot;&gt;&lt;code&gt;EncodeWide&lt;/code&gt;&lt;/a&gt; iterator. You can &lt;a href=&quot;../../../iter/trait.iterator#method.collect&quot;&gt;&lt;code&gt;collect&lt;/code&gt;&lt;/a&gt; this iterator, for example, to obtain a &lt;code&gt;Vec&amp;lt;u16&amp;gt;&lt;/code&gt;; you can later get a pointer to this vector's contents and feed it to Windows APIs.</source>
          <target state="translated">Точно так же &lt;a href=&quot;../../../ffi/struct.osstr&quot;&gt; &lt;code&gt;OsStr&lt;/code&gt; &lt;/a&gt; - это оболочка Rust для заимствованных строк из предпочтительного представления операционной системы. В Windows &lt;a href=&quot;trait.osstrext&quot;&gt; &lt;code&gt;OsStrExt&lt;/code&gt; &lt;/a&gt; предоставляет метод &lt;a href=&quot;trait.osstrext#tymethod.encode_wide&quot;&gt; &lt;code&gt;encode_wide&lt;/code&gt; &lt;/a&gt; , который выводит итератор &lt;a href=&quot;struct.encodewide&quot;&gt; &lt;code&gt;EncodeWide&lt;/code&gt; &lt;/a&gt; . Вы можете &lt;a href=&quot;../../../iter/trait.iterator#method.collect&quot;&gt; &lt;code&gt;collect&lt;/code&gt; &lt;/a&gt; этот итератор, например, чтобы получить &lt;code&gt;Vec&amp;lt;u16&amp;gt;&lt;/code&gt; ; позже вы можете получить указатель на содержимое этого вектора и передать его API Windows.</target>
        </trans-unit>
        <trans-unit id="21888fa75549881b10ce400876eec72ecd5ad10f" translate="yes" xml:space="preserve">
          <source>Similarly, calling &lt;code&gt;Pin::new_unchecked&lt;/code&gt; on an &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; is unsafe because there could be aliases to the same data that are not subject to the pinning restrictions:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="331d62920cf450c0aa7d5ef9d689f928128d9ddb" translate="yes" xml:space="preserve">
          <source>Similarly, entirely uninitialized memory may have any content, while a &lt;code&gt;bool&lt;/code&gt; must always be &lt;code&gt;true&lt;/code&gt; or &lt;code&gt;false&lt;/code&gt;. Hence, creating an uninitialized &lt;code&gt;bool&lt;/code&gt; is undefined behavior:</source>
          <target state="translated">Точно так же полностью неинициализированная память может иметь любое содержимое, а &lt;code&gt;bool&lt;/code&gt; всегда должно быть &lt;code&gt;true&lt;/code&gt; или &lt;code&gt;false&lt;/code&gt; . Следовательно, создание неинициализированного &lt;code&gt;bool&lt;/code&gt; - это поведение undefined:</target>
        </trans-unit>
        <trans-unit id="ed164c6b174ba78425b6e3b0cccce0c52c2d4a48" translate="yes" xml:space="preserve">
          <source>Similarly, for structs, match with &lt;code&gt;..&lt;/code&gt; to avoid this error.</source>
          <target state="translated">Точно так же для структур сопоставьте с &lt;code&gt;..&lt;/code&gt; , чтобы избежать этой ошибки.</target>
        </trans-unit>
        <trans-unit id="bb8e5654df6f95ffc903dbcd643004ef73553391" translate="yes" xml:space="preserve">
          <source>Similarly, here is an example of calling supertrait methods on trait objects.</source>
          <target state="translated">Аналогично,вот пример вызова методов супертрэйта на объектах трейта.</target>
        </trans-unit>
        <trans-unit id="7053a5d2b2cc9ee0f9baea0c0b8570f148cfc9b7" translate="yes" xml:space="preserve">
          <source>Similarly, the &lt;code&gt;unwrap&lt;/code&gt; and &lt;code&gt;expect&lt;/code&gt; methods are very handy when prototyping, before you&amp;rsquo;re ready to decide how to handle errors. They leave clear markers in your code for when you&amp;rsquo;re ready to make your program more robust.</source>
          <target state="translated">Точно так же методы &lt;code&gt;unwrap&lt;/code&gt; и &lt;code&gt;expect&lt;/code&gt; очень удобны при прототипировании, прежде чем вы будете готовы решить, как обрабатывать ошибки. Они оставляют в вашем коде четкие маркеры, когда вы будете готовы сделать свою программу более устойчивой.</target>
        </trans-unit>
        <trans-unit id="909815a68ff4f68cdf616f89894d91c5fbf5f80e" translate="yes" xml:space="preserve">
          <source>Similarly, the second arm matches any point on the &lt;code&gt;y&lt;/code&gt; axis by specifying that the &lt;code&gt;x&lt;/code&gt; field matches if its value is &lt;code&gt;0&lt;/code&gt; and creates a variable &lt;code&gt;y&lt;/code&gt; for the value of the &lt;code&gt;y&lt;/code&gt; field. The third arm doesn&amp;rsquo;t specify any literals, so it matches any other &lt;code&gt;Point&lt;/code&gt; and creates variables for both the &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; fields.</source>
          <target state="translated">Точно так же вторая рука соответствует любой точке на оси &lt;code&gt;y&lt;/code&gt; , указав, что поле &lt;code&gt;x&lt;/code&gt; соответствует, если его значение равно &lt;code&gt;0&lt;/code&gt; , и создает переменную &lt;code&gt;y&lt;/code&gt; для значения поля &lt;code&gt;y&lt;/code&gt; . Третья рука не определяет никаких литералов, поэтому соответствует любой другой &lt;code&gt;Point&lt;/code&gt; и создает переменные для полей &lt;code&gt;x&lt;/code&gt; и &lt;code&gt;y&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5da9bf3bc246d43649d642f7bf04333c4a2ee655" translate="yes" xml:space="preserve">
          <source>Similarly, this book does not usually document the specifics of &lt;code&gt;rustc&lt;/code&gt; as a tool or of Cargo. &lt;code&gt;rustc&lt;/code&gt; has its own &lt;a href=&quot;https://doc.rust-lang.org/rustc/index.html&quot;&gt;book&lt;/a&gt;. Cargo has a &lt;a href=&quot;https://doc.rust-lang.org/cargo/index.html&quot;&gt;book&lt;/a&gt; that contains a &lt;a href=&quot;https://doc.rust-lang.org/cargo/reference/index.html&quot;&gt;reference&lt;/a&gt;. There are a few pages such as &lt;a href=&quot;linkage&quot;&gt;linkage&lt;/a&gt; that still describe how &lt;code&gt;rustc&lt;/code&gt; works.</source>
          <target state="translated">Точно так же эта книга обычно не документирует особенности &lt;code&gt;rustc&lt;/code&gt; как инструмента или Cargo. &lt;code&gt;rustc&lt;/code&gt; есть своя собственная &lt;a href=&quot;https://doc.rust-lang.org/rustc/index.html&quot;&gt;книга&lt;/a&gt; . У Cargo есть &lt;a href=&quot;https://doc.rust-lang.org/cargo/index.html&quot;&gt;книга, в&lt;/a&gt; которой есть &lt;a href=&quot;https://doc.rust-lang.org/cargo/reference/index.html&quot;&gt;ссылка&lt;/a&gt; . Есть несколько страниц, таких как &lt;a href=&quot;linkage&quot;&gt;linkage,&lt;/a&gt; которые все еще описывают, как работает &lt;code&gt;rustc&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2bd04063dfceec281f5e4d66a8b58a68fc14c509" translate="yes" xml:space="preserve">
          <source>Similarly, you can call builder methods after spawning a process and then spawn a new process with the modified settings.</source>
          <target state="translated">Аналогичным образом,можно вызывать методы конструктора после порождения процесса,а затем порождать новый процесс с измененными настройками.</target>
        </trans-unit>
        <trans-unit id="5c261bda61f3e96d861e1be54d36d7213b2aa3f1" translate="yes" xml:space="preserve">
          <source>Simple &lt;code&gt;static&lt;/code&gt;s</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6d9ea6b63528572b56d731de1e5520f39fc27921" translate="yes" xml:space="preserve">
          <source>Simple Paths</source>
          <target state="translated">Простые пути</target>
        </trans-unit>
        <trans-unit id="5c152b8373cb9fabbb581e0ae99f8530d663375b" translate="yes" xml:space="preserve">
          <source>Simple and safe type conversions that may fail in a controlled way under some circumstances. It is the reciprocal of &lt;a href=&quot;trait.tryinto&quot;&gt;&lt;code&gt;TryInto&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Простое и безопасное преобразование типов, которое при некоторых обстоятельствах может не сработать. Это &lt;a href=&quot;trait.tryinto&quot;&gt; &lt;code&gt;TryInto&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="1eab99ad89fb7c87259173deb7be33f807b20b8a" translate="yes" xml:space="preserve">
          <source>Simple paths are used in &lt;a href=&quot;visibility-and-privacy&quot;&gt;visibility&lt;/a&gt; markers, &lt;a href=&quot;attributes&quot;&gt;attributes&lt;/a&gt;, &lt;a href=&quot;macros-by-example&quot;&gt;macros&lt;/a&gt;, and &lt;a href=&quot;items/use-declarations&quot;&gt;&lt;code&gt;use&lt;/code&gt;&lt;/a&gt; items. Examples:</source>
          <target state="translated">Простые пути используются в маркерах &lt;a href=&quot;visibility-and-privacy&quot;&gt;видимости&lt;/a&gt; , &lt;a href=&quot;attributes&quot;&gt;атрибутах&lt;/a&gt; , &lt;a href=&quot;macros-by-example&quot;&gt;макросах&lt;/a&gt; и элементах &lt;a href=&quot;items/use-declarations&quot;&gt; &lt;code&gt;use&lt;/code&gt; &lt;/a&gt; . Примеры:</target>
        </trans-unit>
        <trans-unit id="d30ca8657f691b790156ae3e1eda88a721749a7f" translate="yes" xml:space="preserve">
          <source>Simple patterns:</source>
          <target state="translated">Простые узоры:</target>
        </trans-unit>
        <trans-unit id="f9e72abc4ccbeabab6d891f4fb04960cf410c43e" translate="yes" xml:space="preserve">
          <source>Simple usage</source>
          <target state="translated">Простое использование</target>
        </trans-unit>
        <trans-unit id="521b9cdb40aeee087c0baf82b63bf75e645545cd" translate="yes" xml:space="preserve">
          <source>Simple usage:</source>
          <target state="translated">Простое использование:</target>
        </trans-unit>
        <trans-unit id="540febaa026e0c164b7b6c82435c094ba3f10d68" translate="yes" xml:space="preserve">
          <source>Simply put, a type &lt;code&gt;T&lt;/code&gt; implements &lt;code&gt;UnwindSafe&lt;/code&gt; if it cannot easily allow witnessing a broken invariant through the use of &lt;code&gt;catch_unwind&lt;/code&gt; (catching a panic). This trait is an auto trait, so it is automatically implemented for many types, and it is also structurally composed (e.g., a struct is unwind safe if all of its components are unwind safe).</source>
          <target state="translated">Проще говоря, тип &lt;code&gt;T&lt;/code&gt; реализует &lt;code&gt;UnwindSafe&lt;/code&gt; , если он не может легко разрешить свидетельство сломанного инварианта с помощью &lt;code&gt;catch_unwind&lt;/code&gt; (поймать панику). Это свойство является автоматическим, поэтому оно автоматически реализуется для многих типов, а также структурно составлено (например, структура безопасна для размотки, если все ее компоненты безопасны для размотки).</target>
        </trans-unit>
        <trans-unit id="7c0fcb3a991c60765331a98cb1ff570fc3f074b7" translate="yes" xml:space="preserve">
          <source>Simulating a Slow Request in the Current Server Implementation</source>
          <target state="translated">Моделирование медленного запроса в текущей реализации сервера</target>
        </trans-unit>
        <trans-unit id="12e2a47a5ff7fe1df209befb5642d47f09168633" translate="yes" xml:space="preserve">
          <source>Simultaneously binding a list of paths with a common prefix and their common parent module, using the &lt;a href=&quot;keyword.self&quot;&gt;&lt;code&gt;self&lt;/code&gt;&lt;/a&gt; keyword, such as &lt;code&gt;use a::b::{self, c, d::e};&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1c95e390ae299ab0a4224d3333c97e6af7ae7eb5" translate="yes" xml:space="preserve">
          <source>Simultaneously binding a list of paths with a common prefix and their common parent module, using the &lt;code&gt;self&lt;/code&gt; keyword, such as &lt;code&gt;use a::b::{self, c, d::e};&lt;/code&gt;</source>
          <target state="translated">Одновременное связывание списка путей с общим префиксом и их общим родительским модулем с использованием ключевого слова &lt;code&gt;self&lt;/code&gt; , например &lt;code&gt;use a::b::{self, c, d::e};&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="bfb7386ffac3ad84f3f639dd029ef6518cae9303" translate="yes" xml:space="preserve">
          <source>Simultaneously binding a list of paths with a common prefix, using the glob-like brace syntax &lt;code&gt;use a::b::{c, d, e::f, g::h::i};&lt;/code&gt;</source>
          <target state="translated">Одновременное связывание списка путей с общим префиксом с использованием синтаксиса фигурных скобок, подобного глобусу, &lt;code&gt;use a::b::{c, d, e::f, g::h::i};&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="ddbdcfff59de6a5aac21219338aec3ba07afbdc5" translate="yes" xml:space="preserve">
          <source>Simultaneously computes the sine and cosine of the number, &lt;code&gt;x&lt;/code&gt;. Returns &lt;code&gt;(sin(x), cos(x))&lt;/code&gt;.</source>
          <target state="translated">Одновременно вычисляет синус и косинус числа &lt;code&gt;x&lt;/code&gt; . Возвращает &lt;code&gt;(sin(x), cos(x))&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8c4638b0d965c7d35475023eaa850cf6607c84bf" translate="yes" xml:space="preserve">
          <source>Simultaneously waits for the child to exit and collect all remaining output on the stdout/stderr handles, returning an &lt;code&gt;Output&lt;/code&gt; instance.</source>
          <target state="translated">Одновременно ожидает выхода потомка и собирает весь оставшийся вывод на дескрипторах stdout / stderr, возвращая экземпляр &lt;code&gt;Output&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b580c75acd8a59ac52d76a587525a6d1f2ad2173" translate="yes" xml:space="preserve">
          <source>Since &lt;a href=&quot;../cell/struct.refcell&quot;&gt;&lt;code&gt;RefCell&lt;/code&gt;&lt;/a&gt; enforces the borrow rules at runtime, &lt;code&gt;drop&lt;/code&gt; can release a &lt;a href=&quot;../cell/struct.refcell&quot;&gt;&lt;code&gt;RefCell&lt;/code&gt;&lt;/a&gt; borrow:</source>
          <target state="translated">Поскольку &lt;a href=&quot;../cell/struct.refcell&quot;&gt; &lt;code&gt;RefCell&lt;/code&gt; &lt;/a&gt; применяет правила заимствования во время выполнения, &lt;code&gt;drop&lt;/code&gt; может освободить заимствование &lt;a href=&quot;../cell/struct.refcell&quot;&gt; &lt;code&gt;RefCell&lt;/code&gt; &lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="1c6dcce02f4add8169e3d2f77fc05356bfe10cc0" translate="yes" xml:space="preserve">
          <source>Since &lt;a href=&quot;trait.fnonce&quot;&gt;&lt;code&gt;FnOnce&lt;/code&gt;&lt;/a&gt; is a supertrait of &lt;code&gt;FnMut&lt;/code&gt;, any instance of &lt;code&gt;FnMut&lt;/code&gt; can be used where a &lt;a href=&quot;trait.fnonce&quot;&gt;&lt;code&gt;FnOnce&lt;/code&gt;&lt;/a&gt; is expected, and since &lt;a href=&quot;trait.fn&quot;&gt;&lt;code&gt;Fn&lt;/code&gt;&lt;/a&gt; is a subtrait of &lt;code&gt;FnMut&lt;/code&gt;, any instance of &lt;a href=&quot;trait.fn&quot;&gt;&lt;code&gt;Fn&lt;/code&gt;&lt;/a&gt; can be used where &lt;code&gt;FnMut&lt;/code&gt; is expected.</source>
          <target state="translated">Поскольку &lt;a href=&quot;trait.fnonce&quot;&gt; &lt;code&gt;FnOnce&lt;/code&gt; &lt;/a&gt; является &lt;code&gt;FnMut&lt;/code&gt; , любой экземпляр &lt;code&gt;FnMut&lt;/code&gt; может использоваться там, где ожидается &lt;a href=&quot;trait.fnonce&quot;&gt; &lt;code&gt;FnOnce&lt;/code&gt; &lt;/a&gt; , а так как &lt;a href=&quot;trait.fn&quot;&gt; &lt;code&gt;Fn&lt;/code&gt; &lt;/a&gt; является частичным &lt;code&gt;FnMut&lt;/code&gt; , любой экземпляр &lt;a href=&quot;trait.fn&quot;&gt; &lt;code&gt;Fn&lt;/code&gt; &lt;/a&gt; может использоваться там, где ожидается &lt;code&gt;FnMut&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c26b94cb5b32aac4f4b274599dd1a658b6761ca7" translate="yes" xml:space="preserve">
          <source>Since &lt;code&gt;!&lt;/code&gt; has no values, it has no default value either. It's true that we could write an &lt;code&gt;impl&lt;/code&gt; for this which simply panics, but the same is true for any type (we could &lt;code&gt;impl Default&lt;/code&gt; for (eg.) &lt;a href=&quot;fs/struct.file&quot;&gt;&lt;code&gt;File&lt;/code&gt;&lt;/a&gt; by just making &lt;a href=&quot;default/trait.default#tymethod.default&quot;&gt;&lt;code&gt;default()&lt;/code&gt;&lt;/a&gt; panic.)</source>
          <target state="translated">Поскольку &lt;code&gt;!&lt;/code&gt; не имеет значений, не имеет значения по умолчанию. Верно, что мы могли бы написать для этого &lt;code&gt;impl&lt;/code&gt; , который просто вызывает панику, но то же самое верно для любого типа (мы могли бы &lt;code&gt;impl Default&lt;/code&gt; для (например) &lt;a href=&quot;fs/struct.file&quot;&gt; &lt;code&gt;File&lt;/code&gt; &lt;/a&gt; , просто сделав &lt;a href=&quot;default/trait.default#tymethod.default&quot;&gt; &lt;code&gt;default()&lt;/code&gt; &lt;/a&gt; panic.)</target>
        </trans-unit>
        <trans-unit id="6538e8c17f8ab9a15a41a6c2b62591b4db139233" translate="yes" xml:space="preserve">
          <source>Since &lt;code&gt;'static&lt;/code&gt; outlives the lifetime parameter &lt;code&gt;'a&lt;/code&gt;, &lt;code&gt;&amp;amp;'static str&lt;/code&gt; is a subtype of &lt;code&gt;&amp;amp;'a str&lt;/code&gt;.</source>
          <target state="translated">Так как &lt;code&gt;'static&lt;/code&gt; переживает параметр времени жизни &lt;code&gt;'a&lt;/code&gt; , &lt;code&gt;&amp;amp;'static str&lt;/code&gt; является подтипом &lt;code&gt;&amp;amp;'a str&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="54da8d1cecd13aae6b43892c91292b5d0b233e7f" translate="yes" xml:space="preserve">
          <source>Since &lt;code&gt;?&lt;/code&gt; represents at most one occurrence, it cannot be used with a separator.</source>
          <target state="translated">С &lt;code&gt;?&lt;/code&gt; представляет не более одного вхождения, его нельзя использовать с разделителем.</target>
        </trans-unit>
        <trans-unit id="c9806b12ce1093b7dae486d7b9b428620b9d39e1" translate="yes" xml:space="preserve">
          <source>Since &lt;code&gt;Clone&lt;/code&gt; is more general than &lt;a href=&quot;../marker/trait.copy&quot;&gt;&lt;code&gt;Copy&lt;/code&gt;&lt;/a&gt;, you can automatically make anything &lt;a href=&quot;../marker/trait.copy&quot;&gt;&lt;code&gt;Copy&lt;/code&gt;&lt;/a&gt; be &lt;code&gt;Clone&lt;/code&gt; as well.</source>
          <target state="translated">Поскольку &lt;code&gt;Clone&lt;/code&gt; является более общим , чем &lt;a href=&quot;../marker/trait.copy&quot;&gt; &lt;code&gt;Copy&lt;/code&gt; &lt;/a&gt; , вы можете автоматически сделать что - либо &lt;a href=&quot;../marker/trait.copy&quot;&gt; &lt;code&gt;Copy&lt;/code&gt; &lt;/a&gt; быть &lt;code&gt;Clone&lt;/code&gt; , а также.</target>
        </trans-unit>
        <trans-unit id="8e572576a02e098cf819824ba101e184709a2232" translate="yes" xml:space="preserve">
          <source>Since &lt;code&gt;MyStruct&lt;/code&gt; is a type that is not marked &lt;code&gt;Copy&lt;/code&gt;, the data gets moved out of &lt;code&gt;x&lt;/code&gt; when we set &lt;code&gt;y&lt;/code&gt;. This is fundamental to Rust's ownership system: outside of workarounds like &lt;code&gt;Rc&lt;/code&gt;, a value cannot be owned by more than one variable.</source>
          <target state="translated">Поскольку &lt;code&gt;MyStruct&lt;/code&gt; - это тип, который не помечен как &lt;code&gt;Copy&lt;/code&gt; , данные перемещаются из &lt;code&gt;x&lt;/code&gt; , когда мы устанавливаем &lt;code&gt;y&lt;/code&gt; . Это фундаментально для системы владения Rust: вне обходных путей, таких как &lt;code&gt;Rc&lt;/code&gt; , значение не может принадлежать более чем одной переменной.</target>
        </trans-unit>
        <trans-unit id="f01318a26a4f8d5a0b3d02e51cc97912faf805a6" translate="yes" xml:space="preserve">
          <source>Since &lt;code&gt;VecDeque&lt;/code&gt; is a ring buffer, its elements are not necessarily contiguous in memory. If you want to access the elements as a single slice, such as for efficient sorting, you can use &lt;a href=&quot;../struct.vecdeque#method.make_contiguous&quot;&gt;&lt;code&gt;make_contiguous&lt;/code&gt;&lt;/a&gt;. It rotates the &lt;code&gt;VecDeque&lt;/code&gt; so that its elements do not wrap, and returns a mutable slice to the now-contiguous element sequence.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f28e716b3437cb79c3640f168f027915fd73a75c" translate="yes" xml:space="preserve">
          <source>Since &lt;code&gt;VecDeque&lt;/code&gt; is a ring buffer, its elements are not necessarily contiguous in memory. If you want to access the elements as a single slice, such as for efficient sorting, you can use &lt;a href=&quot;struct.vecdeque#method.make_contiguous&quot;&gt;&lt;code&gt;make_contiguous&lt;/code&gt;&lt;/a&gt;. It rotates the &lt;code&gt;VecDeque&lt;/code&gt; so that its elements do not wrap, and returns a mutable slice to the now-contiguous element sequence.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="496588742528c660f3dc424fab673464dbf01876" translate="yes" xml:space="preserve">
          <source>Since &lt;code&gt;consume()&lt;/code&gt; is meant to be used with &lt;a href=&quot;#tymethod.fill_buf&quot;&gt;&lt;code&gt;fill_buf&lt;/code&gt;&lt;/a&gt;, that method's example includes an example of &lt;code&gt;consume()&lt;/code&gt;.</source>
          <target state="translated">Поскольку &lt;code&gt;consume()&lt;/code&gt; предназначен для использования с &lt;a href=&quot;#tymethod.fill_buf&quot;&gt; &lt;code&gt;fill_buf&lt;/code&gt; &lt;/a&gt; , пример этого метода включает в себя пример consumer &lt;code&gt;consume()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e1d5b75fc592741c0d1be15eaf95352a204e467d" translate="yes" xml:space="preserve">
          <source>Since &lt;code&gt;consume()&lt;/code&gt; is meant to be used with &lt;a href=&quot;trait.bufread#tymethod.fill_buf&quot;&gt;&lt;code&gt;fill_buf&lt;/code&gt;&lt;/a&gt;, that method's example includes an example of &lt;code&gt;consume()&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1c5531c624a4d1e39bfd0832114ff1d071877ab0" translate="yes" xml:space="preserve">
          <source>Since &lt;code&gt;return;&lt;/code&gt; is just like &lt;code&gt;return ();&lt;/code&gt;, there is a mismatch between the function's return type and the value being returned.</source>
          <target state="translated">С &lt;code&gt;return;&lt;/code&gt; как &lt;code&gt;return ();&lt;/code&gt; , существует несоответствие между типом, возвращаемым функцией, и возвращаемым значением.</target>
        </trans-unit>
        <trans-unit id="7a98cfe045701dbcce3babcaa95e649ec3bd08fc" translate="yes" xml:space="preserve">
          <source>Since &lt;code&gt;str&lt;/code&gt; is a &lt;a href=&quot;../dynamically-sized-types&quot;&gt;dynamically sized type&lt;/a&gt;, it can only be instantiated through a pointer type, such as &lt;code&gt;&amp;amp;str&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eb8389e693f4fb90eb8f831b714ec1477b38653c" translate="yes" xml:space="preserve">
          <source>Since &lt;code&gt;unsafe fn&lt;/code&gt; and &lt;code&gt;unsafe trait&lt;/code&gt; indicate that there is a safety contract that the compiler cannot enforce, documenting it is important. The standard library has many examples of this, like the following which is an extract from &lt;a href=&quot;vec/struct.vec#method.set_len&quot;&gt;&lt;code&gt;Vec::set_len&lt;/code&gt;&lt;/a&gt;. The &lt;code&gt;# Safety&lt;/code&gt; section explains the contract that must be fulfilled to safely call the function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="106e002553ec8f223d69f89942bc4486d15f8e50" translate="yes" xml:space="preserve">
          <source>Since Rust itself has no notion of immovable types, and considers moves (e.g. through assignment or &lt;a href=&quot;../mem/fn.replace&quot;&gt;&lt;code&gt;mem::replace&lt;/code&gt;&lt;/a&gt;) to always be safe, this trait cannot prevent types from moving by itself.</source>
          <target state="translated">Поскольку сам Rust не имеет понятия о неподвижных типах и считает перемещения (например, посредством присваивания или &lt;a href=&quot;../mem/fn.replace&quot;&gt; &lt;code&gt;mem::replace&lt;/code&gt; &lt;/a&gt; ) всегда безопасными, эта черта не может предотвратить перемещение типов само по себе.</target>
        </trans-unit>
        <trans-unit id="1f285e86fcd5f303d057612bb02278ca3219d62a" translate="yes" xml:space="preserve">
          <source>Since a &lt;code&gt;Weak&lt;/code&gt; reference does not count towards ownership, it will not prevent the inner value from being dropped, and &lt;code&gt;Weak&lt;/code&gt; itself makes no guarantees about the value still being present and may return &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt; when &lt;a href=&quot;struct.weak#method.upgrade&quot;&gt;&lt;code&gt;upgrade&lt;/code&gt;&lt;/a&gt;d.</source>
          <target state="translated">Поскольку &lt;code&gt;Weak&lt;/code&gt; ссылка не учитываются права собственности, оно не будет препятствовать внутреннее значение при падении, и &lt;code&gt;Weak&lt;/code&gt; сама по себе не дает никаких гарантий относительно стоимости все еще присутствует , и не может возвращать &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt; &lt;code&gt;None&lt;/code&gt; &lt;/a&gt; , когда &lt;a href=&quot;struct.weak#method.upgrade&quot;&gt; &lt;code&gt;upgrade&lt;/code&gt; &lt;/a&gt; д.</target>
        </trans-unit>
        <trans-unit id="670c8d8450bb33a1f925b38f371b3ea24d1a7174" translate="yes" xml:space="preserve">
          <source>Since a &lt;code&gt;Weak&lt;/code&gt; reference does not count towards ownership, it will not prevent the value stored in the allocation from being dropped, and &lt;code&gt;Weak&lt;/code&gt; itself makes no guarantees about the value still being present. Thus it may return &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt; when &lt;a href=&quot;struct.weak#method.upgrade&quot;&gt;&lt;code&gt;upgrade&lt;/code&gt;&lt;/a&gt;d. Note however that a &lt;code&gt;Weak&lt;/code&gt; reference &lt;em&gt;does&lt;/em&gt; prevent the allocation itself (the backing store) from being deallocated.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0b5e80c5d1baff33e622575e429a6609253a9875" translate="yes" xml:space="preserve">
          <source>Since a trait object can contain references, the lifetimes of those references need to be expressed as part of the trait object. This lifetime is written as &lt;code&gt;Trait + 'a&lt;/code&gt;. There are &lt;a href=&quot;../lifetime-elision#default-trait-object-lifetimes&quot;&gt;defaults&lt;/a&gt; that allow this lifetime to usually be inferred with a sensible choice.</source>
          <target state="translated">Поскольку объект признака может содержать ссылки, время жизни этих ссылок должно быть выражено как часть объекта признака. Эта жизнь записывается как &lt;code&gt;Trait + 'a&lt;/code&gt; . Существуют &lt;a href=&quot;../lifetime-elision#default-trait-object-lifetimes&quot;&gt;значения по умолчанию,&lt;/a&gt; которые позволяют сделать вывод об этом времени жизни с разумным выбором.</target>
        </trans-unit>
        <trans-unit id="2b1463c8dcb680af22f8df7f2ab74c2c8b9a5142" translate="yes" xml:space="preserve">
          <source>Since an auto trait is implemented on all existing types, adding a super trait would filter out a lot of those types. In the current example, almost none of all the existing types could implement &lt;code&gt;Bound&lt;/code&gt; because very few of them have the &lt;code&gt;Copy&lt;/code&gt; trait.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b65d93863acfe950e5cf2f8ad1f543c418cf7cb6" translate="yes" xml:space="preserve">
          <source>Since an auto trait is implemented on all existing types, the compiler would not be able to infer the types of the trait's generic parameters.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="20e98f0e177bac52b1c7e34f6c53603646a0456a" translate="yes" xml:space="preserve">
          <source>Since both &lt;a href=&quot;trait.fn&quot;&gt;&lt;code&gt;Fn&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;trait.fnmut&quot;&gt;&lt;code&gt;FnMut&lt;/code&gt;&lt;/a&gt; are subtraits of &lt;code&gt;FnOnce&lt;/code&gt;, any instance of &lt;a href=&quot;trait.fn&quot;&gt;&lt;code&gt;Fn&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;trait.fnmut&quot;&gt;&lt;code&gt;FnMut&lt;/code&gt;&lt;/a&gt; can be used where a &lt;code&gt;FnOnce&lt;/code&gt; is expected.</source>
          <target state="translated">Поскольку и &lt;a href=&quot;trait.fn&quot;&gt; &lt;code&gt;Fn&lt;/code&gt; ,&lt;/a&gt; и &lt;a href=&quot;trait.fnmut&quot;&gt; &lt;code&gt;FnMut&lt;/code&gt; &lt;/a&gt; являются дочерними элементами &lt;code&gt;FnOnce&lt;/code&gt; , можно использовать любой экземпляр &lt;a href=&quot;trait.fn&quot;&gt; &lt;code&gt;Fn&lt;/code&gt; &lt;/a&gt; или &lt;a href=&quot;trait.fnmut&quot;&gt; &lt;code&gt;FnMut&lt;/code&gt; &lt;/a&gt; там, где ожидается &lt;code&gt;FnOnce&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3d51e0cb7393cc23f814f7df339e871875cf9298" translate="yes" xml:space="preserve">
          <source>Since both &lt;a href=&quot;trait.fnmut&quot;&gt;&lt;code&gt;FnMut&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;trait.fnonce&quot;&gt;&lt;code&gt;FnOnce&lt;/code&gt;&lt;/a&gt; are supertraits of &lt;code&gt;Fn&lt;/code&gt;, any instance of &lt;code&gt;Fn&lt;/code&gt; can be used as a parameter where a &lt;a href=&quot;trait.fnmut&quot;&gt;&lt;code&gt;FnMut&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;trait.fnonce&quot;&gt;&lt;code&gt;FnOnce&lt;/code&gt;&lt;/a&gt; is expected.</source>
          <target state="translated">Поскольку и &lt;a href=&quot;trait.fnmut&quot;&gt; &lt;code&gt;FnMut&lt;/code&gt; ,&lt;/a&gt; и &lt;a href=&quot;trait.fnonce&quot;&gt; &lt;code&gt;FnOnce&lt;/code&gt; &lt;/a&gt; являются надстройками &lt;code&gt;Fn&lt;/code&gt; , любой экземпляр &lt;code&gt;Fn&lt;/code&gt; может использоваться в качестве параметра там, где &lt;a href=&quot;trait.fnmut&quot;&gt; &lt;code&gt;FnMut&lt;/code&gt; &lt;/a&gt; или &lt;a href=&quot;trait.fnonce&quot;&gt; &lt;code&gt;FnOnce&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="d32e7ee7bdef075cb130707fe0d5e03c56eca7e3" translate="yes" xml:space="preserve">
          <source>Since our new thread runs in parallel, the stack frame containing &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; may well have disappeared by the time we try to use them. Even if we call &lt;code&gt;thr.join()&lt;/code&gt; within foo (which blocks until &lt;code&gt;thr&lt;/code&gt; has completed, ensuring the stack frame won't disappear), we will not succeed: the compiler cannot prove that this behavior is safe, and so won't let us do it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="551e6652d59fd9a852edd6ce421865877e505046" translate="yes" xml:space="preserve">
          <source>Since our new thread runs in parallel, the stack frame containing &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; may well have disappeared by the time we try to use them. Even if we call &lt;code&gt;thr.join()&lt;/code&gt; within foo (which blocks until &lt;code&gt;thr&lt;/code&gt; has completed, ensuring the stack frame won't disappear), we will not succeed: the compiler cannot prove that this behaviour is safe, and so won't let us do it.</source>
          <target state="translated">Поскольку наш новый поток работает параллельно, кадр стека, содержащий &lt;code&gt;x&lt;/code&gt; и &lt;code&gt;y&lt;/code&gt; , вполне может исчезнуть к тому времени, когда мы попытаемся их использовать. Даже если мы вызовем &lt;code&gt;thr.join()&lt;/code&gt; внутри foo (который блокируется до завершения &lt;code&gt;thr&lt;/code&gt; , гарантируя, что кадр стека не исчезнет), мы не добьемся успеха: компилятор не может доказать, что это поведение безопасно, и поэтому не позволит мы делаем это.</target>
        </trans-unit>
        <trans-unit id="095fdf5547d3660f78803933a7399a71c65c3ba1" translate="yes" xml:space="preserve">
          <source>Since some characters can expand into multiple characters when changing the case, this function returns a &lt;a href=&quot;string/struct.string&quot;&gt;&lt;code&gt;String&lt;/code&gt;&lt;/a&gt; instead of modifying the parameter in-place.</source>
          <target state="translated">Поскольку при изменении регистра некоторые символы могут расширяться до нескольких символов, эта функция возвращает &lt;a href=&quot;string/struct.string&quot;&gt; &lt;code&gt;String&lt;/code&gt; &lt;/a&gt; вместо изменения параметра на месте.</target>
        </trans-unit>
        <trans-unit id="4bf3f68229cf3a628e7e55b26edce417454ecee0" translate="yes" xml:space="preserve">
          <source>Since some characters can expand into multiple characters when changing the case, this function returns a &lt;a href=&quot;struct.string&quot;&gt;&lt;code&gt;String&lt;/code&gt;&lt;/a&gt; instead of modifying the parameter in-place.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="996ff67fa6512e8ea590630f1af9075b393fc7b8" translate="yes" xml:space="preserve">
          <source>Since the &lt;a href=&quot;result/enum.result#variant.Err&quot;&gt;&lt;code&gt;Err&lt;/code&gt;&lt;/a&gt; variant contains a &lt;code&gt;!&lt;/code&gt;, it can never occur. If the &lt;code&gt;exhaustive_patterns&lt;/code&gt; feature is present this means we can exhaustively match on &lt;a href=&quot;result/enum.result&quot;&gt;&lt;code&gt;Result&amp;lt;T, !&amp;gt;&lt;/code&gt;&lt;/a&gt; by just taking the &lt;a href=&quot;result/enum.result#variant.Ok&quot;&gt;&lt;code&gt;Ok&lt;/code&gt;&lt;/a&gt; variant. This illustrates another behaviour of &lt;code&gt;!&lt;/code&gt; - it can be used to &quot;delete&quot; certain enum variants from generic types like &lt;code&gt;Result&lt;/code&gt;.</source>
          <target state="translated">Поскольку вариант &lt;a href=&quot;result/enum.result#variant.Err&quot;&gt; &lt;code&gt;Err&lt;/code&gt; &lt;/a&gt; содержит &lt;code&gt;!&lt;/code&gt; , этого никогда не может произойти. Если &lt;code&gt;exhaustive_patterns&lt;/code&gt; функция присутствует это означает , что мы можем исчерпывающе соответствовать на &lt;a href=&quot;result/enum.result&quot;&gt; &lt;code&gt;Result&amp;lt;T, !&amp;gt;&lt;/code&gt; &lt;/a&gt; , Просто принимая &lt;a href=&quot;result/enum.result#variant.Ok&quot;&gt; &lt;code&gt;Ok&lt;/code&gt; &lt;/a&gt; вариант. Это иллюстрирует другое поведение &lt;code&gt;!&lt;/code&gt; - его можно использовать для &amp;laquo;удаления&amp;raquo; определенных вариантов перечисления из универсальных типов, таких как &lt;code&gt;Result&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="02dc928dc96c27acf83c332b2f0b99c175919f2e" translate="yes" xml:space="preserve">
          <source>Since the argument to &lt;code&gt;chain()&lt;/code&gt; uses &lt;a href=&quot;trait.intoiterator&quot;&gt;&lt;code&gt;IntoIterator&lt;/code&gt;&lt;/a&gt;, we can pass anything that can be converted into an &lt;a href=&quot;trait.iterator&quot;&gt;&lt;code&gt;Iterator&lt;/code&gt;&lt;/a&gt;, not just an &lt;a href=&quot;trait.iterator&quot;&gt;&lt;code&gt;Iterator&lt;/code&gt;&lt;/a&gt; itself. For example, slices (&lt;code&gt;&amp;amp;[T]&lt;/code&gt;) implement &lt;a href=&quot;trait.intoiterator&quot;&gt;&lt;code&gt;IntoIterator&lt;/code&gt;&lt;/a&gt;, and so can be passed to &lt;code&gt;chain()&lt;/code&gt; directly:</source>
          <target state="translated">Поскольку аргумент &lt;code&gt;chain()&lt;/code&gt; использует &lt;a href=&quot;trait.intoiterator&quot;&gt; &lt;code&gt;IntoIterator&lt;/code&gt; &lt;/a&gt; , мы можем передать все, что может быть преобразовано в &lt;a href=&quot;trait.iterator&quot;&gt; &lt;code&gt;Iterator&lt;/code&gt; &lt;/a&gt; , а не только сам &lt;a href=&quot;trait.iterator&quot;&gt; &lt;code&gt;Iterator&lt;/code&gt; &lt;/a&gt; . Например, срезы ( &lt;code&gt;&amp;amp;[T]&lt;/code&gt; ) реализуют &lt;a href=&quot;trait.intoiterator&quot;&gt; &lt;code&gt;IntoIterator&lt;/code&gt; &lt;/a&gt; , поэтому их можно напрямую передать в &lt;code&gt;chain()&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="a895265506313c461054e22d44ad004a5290527c" translate="yes" xml:space="preserve">
          <source>Since the argument to &lt;code&gt;zip()&lt;/code&gt; uses &lt;a href=&quot;trait.intoiterator&quot;&gt;&lt;code&gt;IntoIterator&lt;/code&gt;&lt;/a&gt;, we can pass anything that can be converted into an &lt;a href=&quot;trait.iterator&quot;&gt;&lt;code&gt;Iterator&lt;/code&gt;&lt;/a&gt;, not just an &lt;a href=&quot;trait.iterator&quot;&gt;&lt;code&gt;Iterator&lt;/code&gt;&lt;/a&gt; itself. For example, slices (&lt;code&gt;&amp;amp;[T]&lt;/code&gt;) implement &lt;a href=&quot;trait.intoiterator&quot;&gt;&lt;code&gt;IntoIterator&lt;/code&gt;&lt;/a&gt;, and so can be passed to &lt;code&gt;zip()&lt;/code&gt; directly:</source>
          <target state="translated">Поскольку аргумент &lt;code&gt;zip()&lt;/code&gt; использует &lt;a href=&quot;trait.intoiterator&quot;&gt; &lt;code&gt;IntoIterator&lt;/code&gt; &lt;/a&gt; , мы можем передать все, что можно преобразовать в &lt;a href=&quot;trait.iterator&quot;&gt; &lt;code&gt;Iterator&lt;/code&gt; &lt;/a&gt; , а не только сам &lt;a href=&quot;trait.iterator&quot;&gt; &lt;code&gt;Iterator&lt;/code&gt; &lt;/a&gt; . Например, срезы ( &lt;code&gt;&amp;amp;[T]&lt;/code&gt; ) реализуют &lt;a href=&quot;trait.intoiterator&quot;&gt; &lt;code&gt;IntoIterator&lt;/code&gt; &lt;/a&gt; , поэтому их можно напрямую передать в &lt;code&gt;zip()&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="d74a16dbce9fae58c39cce1fd66b21ace599f36b" translate="yes" xml:space="preserve">
          <source>Since the enum is already public, adding &lt;code&gt;pub&lt;/code&gt; on one its elements is unnecessary. Example:</source>
          <target state="translated">Поскольку перечисление уже является общедоступным, добавлять &lt;code&gt;pub&lt;/code&gt; к одному из его элементов не нужно. Пример:</target>
        </trans-unit>
        <trans-unit id="16af503f8386670f482deb401cd8105b1c60875c" translate="yes" xml:space="preserve">
          <source>Since the last element is zero, it would underflow. Thus, the resulting value is &lt;code&gt;None&lt;/code&gt;.</source>
          <target state="translated">Поскольку последний элемент равен нулю, он будет переполнен. Таким образом, результирующее значение равно &lt;code&gt;None&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="78c2449ef951719357023f624a45507fe4592e5f" translate="yes" xml:space="preserve">
          <source>Since the third element caused an underflow, no further elements were taken, so the final value of &lt;code&gt;shared&lt;/code&gt; is 6 (= &lt;code&gt;3 + 2 + 1&lt;/code&gt;), not 16.</source>
          <target state="translated">Поскольку третий элемент вызвал потерю значимости, никакие дополнительные элементы не были взяты, поэтому окончательное значение &lt;code&gt;shared&lt;/code&gt; равно 6 (= &lt;code&gt;3 + 2 + 1&lt;/code&gt; ), а не 16.</target>
        </trans-unit>
        <trans-unit id="9ae4b12cefea6c705a428595fef84ba94949d6b8" translate="yes" xml:space="preserve">
          <source>Since this call borrows the &lt;code&gt;Mutex&lt;/code&gt; mutably, no actual locking needs to take place -- the mutable borrow statically guarantees no locks exist.</source>
          <target state="translated">Так как этот вызов заимствует &lt;code&gt;Mutex&lt;/code&gt; mutably, никаких фактических потребности запирающих не происходят - изменяемые заимствуют статический гарантирует не существуют никаких блокировок.</target>
        </trans-unit>
        <trans-unit id="500751d314a9f5868d6621b41878f53a69f9d880" translate="yes" xml:space="preserve">
          <source>Since this call borrows the &lt;code&gt;RwLock&lt;/code&gt; mutably, no actual locking needs to take place -- the mutable borrow statically guarantees no locks exist.</source>
          <target state="translated">Поскольку этот вызов заимствует &lt;code&gt;RwLock&lt;/code&gt; изменчиво, никакой фактической блокировки не требуется - изменяемое заимствование статически гарантирует отсутствие блокировок.</target>
        </trans-unit>
        <trans-unit id="2c78daff2631b4a84550cc0108989855d06f6a22" translate="yes" xml:space="preserve">
          <source>Since this compares pointers it means that &lt;code&gt;Weak::new()&lt;/code&gt; will equal each other, even though they don't point to any allocation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8a08fbb9b9d229eef360d5f515027ef774d609b9" translate="yes" xml:space="preserve">
          <source>Since this compares pointers it means that &lt;code&gt;Weak::new()&lt;/code&gt; will equal each other, even though they don't point to any value.</source>
          <target state="translated">Поскольку это сравнивает указатели, это означает, что &lt;code&gt;Weak::new()&lt;/code&gt; будут равны друг другу, даже если они не указывают ни на какое значение.</target>
        </trans-unit>
        <trans-unit id="cf2f4735d740fd043cfc0f0f6661429a49ef1b73" translate="yes" xml:space="preserve">
          <source>Since this enum has no variant, a value of this type can never actually exist. This can be useful for generic APIs that use &lt;a href=&quot;../result/enum.result&quot;&gt;&lt;code&gt;Result&lt;/code&gt;&lt;/a&gt; and parameterize the error type, to indicate that the result is always &lt;a href=&quot;../result/enum.result#variant.Ok&quot;&gt;&lt;code&gt;Ok&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Поскольку это перечисление не имеет варианта, значение этого типа никогда не может существовать. Это может быть полезно для общих API, которые используют &lt;a href=&quot;../result/enum.result&quot;&gt; &lt;code&gt;Result&lt;/code&gt; &lt;/a&gt; и параметризуют тип ошибки, чтобы указать, что результат всегда &lt;a href=&quot;../result/enum.result#variant.Ok&quot;&gt; &lt;code&gt;Ok&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="76b5e2d69255c4231c83c94903ea5b7b37a4db43" translate="yes" xml:space="preserve">
          <source>Since type parameters are evaluated in-order, you may be able to fix this issue by doing:</source>
          <target state="translated">Поскольку параметры типа обрабатываются по заказу,вы можете исправить эту проблему:</target>
        </trans-unit>
        <trans-unit id="586ab9e36a2a610444fcbcb9e44aed06a4a34545" translate="yes" xml:space="preserve">
          <source>Since union fields share common storage, gaining write access to one field of a union can give write access to all its remaining fields. Borrow checking rules have to be adjusted to account for this fact. As a result, if one field of a union is borrowed, all its remaining fields are borrowed as well for the same lifetime.</source>
          <target state="translated">Поскольку поля союза имеют общее хранилище,получение доступа на запись к одному полю союза может дать доступ на запись ко всем его оставшимся полям.Правила проверки заимствований должны быть скорректированы с учетом этого факта.В результате,если одно из полей союза заимствовано,то все остальные поля союза также заимствуются на один и тот же срок.</target>
        </trans-unit>
        <trans-unit id="6c20c8f37c4b7bf77f2a31df2f6719c9fb72df7d" translate="yes" xml:space="preserve">
          <source>Since unsigned types do not have negative equivalents all applications of this function will wrap (except for &lt;code&gt;-0&lt;/code&gt;). For values smaller than the corresponding signed type's maximum the result is the same as casting the corresponding signed value. Any larger values are equivalent to &lt;code&gt;MAX + 1 - (val - MAX - 1)&lt;/code&gt; where &lt;code&gt;MAX&lt;/code&gt; is the corresponding signed type's maximum.</source>
          <target state="translated">Поскольку беззнаковые типы не имеют отрицательных эквивалентов, все приложения этой функции будут переноситься (кроме &lt;code&gt;-0&lt;/code&gt; ). Для значений меньше, чем максимальное значение соответствующего типа со знаком, результат такой же, как при приведении соответствующего значения со знаком. Любые большие значения эквивалентны &lt;code&gt;MAX + 1 - (val - MAX - 1)&lt;/code&gt; где &lt;code&gt;MAX&lt;/code&gt; - это максимум соответствующего типа со знаком.</target>
        </trans-unit>
        <trans-unit id="cbaa65c28e509bdfabc1a47426821c06f77d26f9" translate="yes" xml:space="preserve">
          <source>Since we cannot access items defined inside a function, the visibility of its items does not impact outer code. So using the &lt;code&gt;pub&lt;/code&gt; keyword in this context is invalid.</source>
          <target state="translated">Поскольку мы не можем получить доступ к элементам, определенным внутри функции, видимость ее элементов не влияет на внешний код. Поэтому использование ключевого слова &lt;code&gt;pub&lt;/code&gt; в этом контексте недопустимо.</target>
        </trans-unit>
        <trans-unit id="4dba81bbe7820e8868eb07b19a8befa396058675" translate="yes" xml:space="preserve">
          <source>Since, for the positive integers, all common definitions of division are equal, this is exactly equal to &lt;code&gt;self % rhs&lt;/code&gt;.</source>
          <target state="translated">Поскольку для положительных целых чисел все общие определения деления равны, это в точности равно &lt;code&gt;self % rhs&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="dda0de02b51725f6a06052d7f7ac014a8396a781" translate="yes" xml:space="preserve">
          <source>Since, for the positive integers, all common definitions of division are equal, this is exactly equal to &lt;code&gt;self / rhs&lt;/code&gt;.</source>
          <target state="translated">Поскольку для положительных целых чисел все общие определения деления равны, это в точности равно &lt;code&gt;self / rhs&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b103261a83b179716c89c6c92972b372068f6b15" translate="yes" xml:space="preserve">
          <source>Single quote</source>
          <target state="translated">Единая цитата</target>
        </trans-unit>
        <trans-unit id="fa3c3ce2e1143e5f02a7e1c6ba83790a55e509ea" translate="yes" xml:space="preserve">
          <source>Single quote is escaped as &lt;code&gt;'&lt;/code&gt;.</source>
          <target state="translated">Одиночная кавычка экранируется как &lt;code&gt;'&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7ee0383414a0c9196e3c308e7d9a5c46f51c9908" translate="yes" xml:space="preserve">
          <source>Single quote is escaped as &lt;code&gt;\'&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c87f2f54a082c54d228ff842301df84465a008c3" translate="yes" xml:space="preserve">
          <source>Single-element tuple expression</source>
          <target state="translated">одноэлементное выражение кортежа</target>
        </trans-unit>
        <trans-unit id="eeac5881e3707a24870f65943d84687eb7b0c026" translate="yes" xml:space="preserve">
          <source>Single-element tuple type</source>
          <target state="translated">Одноэлементный кортеж</target>
        </trans-unit>
        <trans-unit id="d75a58a33dda256da44b82cf7f4c80227b9e1afe" translate="yes" xml:space="preserve">
          <source>Single-threaded reference-counting pointers. 'Rc' stands for 'Reference Counted'.</source>
          <target state="translated">Однопоточные указатели.'Rc' означает 'Счетчик ссылок'.</target>
        </trans-unit>
        <trans-unit id="e53e8d5300c878019a997d4cfb7201c7ed2ee003" translate="yes" xml:space="preserve">
          <source>Sink</source>
          <target state="translated">Sink</target>
        </trans-unit>
        <trans-unit id="60c77f672b65aaac8580302bf8cda9c91ba1cad6" translate="yes" xml:space="preserve">
          <source>Sink::borrow</source>
          <target state="translated">Sink::borrow</target>
        </trans-unit>
        <trans-unit id="6d9c51b3db09f18a5f1f96544a01a60b2f227eab" translate="yes" xml:space="preserve">
          <source>Sink::borrow_mut</source>
          <target state="translated">Sink::borrow_mut</target>
        </trans-unit>
        <trans-unit id="1da011f3be06f5727221fdf2c29af5810aa1e90c" translate="yes" xml:space="preserve">
          <source>Sink::by_ref</source>
          <target state="translated">Sink::by_ref</target>
        </trans-unit>
        <trans-unit id="736ddcaae3f79d64fd9ada96bbbcd86659dcb149" translate="yes" xml:space="preserve">
          <source>Sink::flush</source>
          <target state="translated">Sink::flush</target>
        </trans-unit>
        <trans-unit id="1cc460d6dea281e2f0b294cba322984d76827293" translate="yes" xml:space="preserve">
          <source>Sink::fmt</source>
          <target state="translated">Sink::fmt</target>
        </trans-unit>
        <trans-unit id="2395cef4421cc589b077a40b42899b78928eca8a" translate="yes" xml:space="preserve">
          <source>Sink::from</source>
          <target state="translated">Sink::from</target>
        </trans-unit>
        <trans-unit id="08d05b7e780b04c22db75adb4dcbf52a0fd47257" translate="yes" xml:space="preserve">
          <source>Sink::into</source>
          <target state="translated">Sink::into</target>
        </trans-unit>
        <trans-unit id="4be29718f19d2b922b9f5929c80d09871c9ec765" translate="yes" xml:space="preserve">
          <source>Sink::try_from</source>
          <target state="translated">Sink::try_from</target>
        </trans-unit>
        <trans-unit id="8eec324a6cd9312538375d319f03ae5b437fac6f" translate="yes" xml:space="preserve">
          <source>Sink::try_into</source>
          <target state="translated">Sink::try_into</target>
        </trans-unit>
        <trans-unit id="754adefc1f84a53a66700415103c74fc10d2208d" translate="yes" xml:space="preserve">
          <source>Sink::type_id</source>
          <target state="translated">Sink::type_id</target>
        </trans-unit>
        <trans-unit id="5472b671b415c7460696ca133e1af23bc3ba15b8" translate="yes" xml:space="preserve">
          <source>Sink::write</source>
          <target state="translated">Sink::write</target>
        </trans-unit>
        <trans-unit id="8b5df7265c21521886c1d6e0faf91eb2236fc6a1" translate="yes" xml:space="preserve">
          <source>Sink::write_all</source>
          <target state="translated">Sink::write_all</target>
        </trans-unit>
        <trans-unit id="ae44c989306894e93f20c1bd3c46e78e41aa999e" translate="yes" xml:space="preserve">
          <source>Sink::write_fmt</source>
          <target state="translated">Sink::write_fmt</target>
        </trans-unit>
        <trans-unit id="2b518739227f1ce8933d3bddfccc03d9fdb432e6" translate="yes" xml:space="preserve">
          <source>Sink::write_vectored</source>
          <target state="translated">Sink::write_vectored</target>
        </trans-unit>
        <trans-unit id="815c525669d8f021e79d156d95cefcd1fa4048ee" translate="yes" xml:space="preserve">
          <source>SipHash is a general-purpose hashing function: it runs at a good speed (competitive with Spooky and City) and permits strong &lt;em&gt;keyed&lt;/em&gt; hashing. This lets you key your hash tables from a strong RNG, such as &lt;a href=&quot;https://doc.rust-lang.org/rand/rand/os/struct.OsRng.html&quot;&gt;&lt;code&gt;rand::os::OsRng&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c0d73ca2870698f5904e43434297eaf18f9ba593" translate="yes" xml:space="preserve">
          <source>SipHash is a general-purpose hashing function: it runs at a good speed (competitive with Spooky and City) and permits strong &lt;em&gt;keyed&lt;/em&gt; hashing. This lets you key your hashtables from a strong RNG, such as &lt;a href=&quot;https://doc.rust-lang.org/rand/rand/os/struct.OsRng.html&quot;&gt;&lt;code&gt;rand::os::OsRng&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">SipHash является функцией хеширования общего назначения: он работает на скорость хорошей (сопоставимой с Spooky и городами) и допускает сильное &lt;em&gt;шпоночным&lt;/em&gt; хэширование. Это позволяет вам &lt;a href=&quot;https://doc.rust-lang.org/rand/rand/os/struct.OsRng.html&quot;&gt; &lt;code&gt;rand::os::OsRng&lt;/code&gt; &lt;/a&gt; из сильного RNG, такого как rand :: os :: OsRng .</target>
        </trans-unit>
        <trans-unit id="f9cb0c54ab98623776ca7d12c37c5a965ab239e3" translate="yes" xml:space="preserve">
          <source>SipHasher</source>
          <target state="translated">SipHasher</target>
        </trans-unit>
        <trans-unit id="9cedebf8939af7acb2722fe2fa6e5500dcc0267d" translate="yes" xml:space="preserve">
          <source>SipHasher::borrow</source>
          <target state="translated">SipHasher::borrow</target>
        </trans-unit>
        <trans-unit id="6f78bf5c40eda613634b22b06fd42ab3d0250faa" translate="yes" xml:space="preserve">
          <source>SipHasher::borrow_mut</source>
          <target state="translated">SipHasher::borrow_mut</target>
        </trans-unit>
        <trans-unit id="cc289741e2695624776b986e52b00d8f23a94048" translate="yes" xml:space="preserve">
          <source>SipHasher::clone</source>
          <target state="translated">SipHasher::clone</target>
        </trans-unit>
        <trans-unit id="97fe54ce712ce3a5267fa485ee5a26f2658a360a" translate="yes" xml:space="preserve">
          <source>SipHasher::clone_from</source>
          <target state="translated">SipHasher::clone_from</target>
        </trans-unit>
        <trans-unit id="625ae718fa03c7281d696cebdc8b4d5ef419ba8e" translate="yes" xml:space="preserve">
          <source>SipHasher::clone_into</source>
          <target state="translated">SipHasher::clone_into</target>
        </trans-unit>
        <trans-unit id="5e14ff4d39e15208d2ce324e1c3d9b1cd2601aac" translate="yes" xml:space="preserve">
          <source>SipHasher::default</source>
          <target state="translated">SipHasher::default</target>
        </trans-unit>
        <trans-unit id="7161704faf8df64e88863702b3e55cf0aa7ed08f" translate="yes" xml:space="preserve">
          <source>SipHasher::finish</source>
          <target state="translated">SipHasher::finish</target>
        </trans-unit>
        <trans-unit id="dbf68c90fc16c278c984e9a20353b175f9bf5fae" translate="yes" xml:space="preserve">
          <source>SipHasher::fmt</source>
          <target state="translated">SipHasher::fmt</target>
        </trans-unit>
        <trans-unit id="55aaab86cd50570c6967e5cb1be889d31f00c5c3" translate="yes" xml:space="preserve">
          <source>SipHasher::from</source>
          <target state="translated">SipHasher::from</target>
        </trans-unit>
        <trans-unit id="f5f59a1bd2f303a9262c508b718d3d6df44c4aaa" translate="yes" xml:space="preserve">
          <source>SipHasher::into</source>
          <target state="translated">SipHasher::into</target>
        </trans-unit>
        <trans-unit id="e4a8f7f5784838af85c04408b90d9ea75e69b189" translate="yes" xml:space="preserve">
          <source>SipHasher::new</source>
          <target state="translated">SipHasher::new</target>
        </trans-unit>
        <trans-unit id="e33acab93fc2fc493546063a61939686f7af77ee" translate="yes" xml:space="preserve">
          <source>SipHasher::new_with_keys</source>
          <target state="translated">SipHasher::new_with_keys</target>
        </trans-unit>
        <trans-unit id="3b90ab6bf88c2dbd6667b56cb38a8e459989460c" translate="yes" xml:space="preserve">
          <source>SipHasher::to_owned</source>
          <target state="translated">SipHasher::to_owned</target>
        </trans-unit>
        <trans-unit id="12c806474a3ae608918282ae770dec9b62f0b382" translate="yes" xml:space="preserve">
          <source>SipHasher::try_from</source>
          <target state="translated">SipHasher::try_from</target>
        </trans-unit>
        <trans-unit id="2cd9d0b149edef9bacd57b249b8149d3817315c7" translate="yes" xml:space="preserve">
          <source>SipHasher::try_into</source>
          <target state="translated">SipHasher::try_into</target>
        </trans-unit>
        <trans-unit id="cbb961e7c7039fb46a1b3b6615e8e9ad0c6e6000" translate="yes" xml:space="preserve">
          <source>SipHasher::type_id</source>
          <target state="translated">SipHasher::type_id</target>
        </trans-unit>
        <trans-unit id="8dce40dc64d99daa5c7c82a5dd674ea488a633de" translate="yes" xml:space="preserve">
          <source>SipHasher::write</source>
          <target state="translated">SipHasher::write</target>
        </trans-unit>
        <trans-unit id="c5c657a251d28888ab38871cd5365bc241246900" translate="yes" xml:space="preserve">
          <source>SipHasher::write_i128</source>
          <target state="translated">SipHasher::write_i128</target>
        </trans-unit>
        <trans-unit id="081f835a8f97633ee9c90294cbf01e6872a68e4d" translate="yes" xml:space="preserve">
          <source>SipHasher::write_i16</source>
          <target state="translated">SipHasher::write_i16</target>
        </trans-unit>
        <trans-unit id="534c0d75c7057a1243d040ed54d6d2089e7a7cf2" translate="yes" xml:space="preserve">
          <source>SipHasher::write_i32</source>
          <target state="translated">SipHasher::write_i32</target>
        </trans-unit>
        <trans-unit id="216359e513bd8a5178869764748567d747157db7" translate="yes" xml:space="preserve">
          <source>SipHasher::write_i64</source>
          <target state="translated">SipHasher::write_i64</target>
        </trans-unit>
        <trans-unit id="114f8115dd2a8666c8ced62d0e00a14733a00d63" translate="yes" xml:space="preserve">
          <source>SipHasher::write_i8</source>
          <target state="translated">SipHasher::write_i8</target>
        </trans-unit>
        <trans-unit id="15e7675543a4110211cbe808fcb13bd45e7008de" translate="yes" xml:space="preserve">
          <source>SipHasher::write_isize</source>
          <target state="translated">SipHasher::write_isize</target>
        </trans-unit>
        <trans-unit id="a259163f68fa6032e75f103bf4080aa27ba329d2" translate="yes" xml:space="preserve">
          <source>SipHasher::write_u128</source>
          <target state="translated">SipHasher::write_u128</target>
        </trans-unit>
        <trans-unit id="099c7c79450a47f4f8124fb8b6727a36a03390dc" translate="yes" xml:space="preserve">
          <source>SipHasher::write_u16</source>
          <target state="translated">SipHasher::write_u16</target>
        </trans-unit>
        <trans-unit id="d7ecaa1047bea8c31cd7f22a3bcdc883bc97810d" translate="yes" xml:space="preserve">
          <source>SipHasher::write_u32</source>
          <target state="translated">SipHasher::write_u32</target>
        </trans-unit>
        <trans-unit id="31d6e5ccde9767e49d1674c68c727f65298672fe" translate="yes" xml:space="preserve">
          <source>SipHasher::write_u64</source>
          <target state="translated">SipHasher::write_u64</target>
        </trans-unit>
        <trans-unit id="9169019178e6022743fc9d89de5f8e8745aaaf95" translate="yes" xml:space="preserve">
          <source>SipHasher::write_u8</source>
          <target state="translated">SipHasher::write_u8</target>
        </trans-unit>
        <trans-unit id="4da530848e33a9c560398180914f191393e00574" translate="yes" xml:space="preserve">
          <source>SipHasher::write_usize</source>
          <target state="translated">SipHasher::write_usize</target>
        </trans-unit>
        <trans-unit id="ee91ac0df1cda6cca56ba0ddc07b04ecdae2eb79" translate="yes" xml:space="preserve">
          <source>Six weeks after the first beta was created, it&amp;rsquo;s time for a stable release! The &lt;code&gt;stable&lt;/code&gt; branch is produced from the &lt;code&gt;beta&lt;/code&gt; branch:</source>
          <target state="translated">Через шесть недель после создания первой бета-версии пришло время стабильного выпуска! &lt;code&gt;stable&lt;/code&gt; ветвь получают из &lt;code&gt;beta&lt;/code&gt; - ветви:</target>
        </trans-unit>
        <trans-unit id="b7152342a267362add3c0d7f69f720f7a9c76c9e" translate="yes" xml:space="preserve">
          <source>Size</source>
          <target state="translated">Size</target>
        </trans-unit>
        <trans-unit id="8b2137531250f928e063debe4f1ffaa0a169ef4c" translate="yes" xml:space="preserve">
          <source>Size and Alignment</source>
          <target state="translated">Размер и выравнивание</target>
        </trans-unit>
        <trans-unit id="2e8e7d128fe5b9a8867e6a426fb44ec115e0e9a2" translate="yes" xml:space="preserve">
          <source>Size of &lt;code&gt;#[repr(C)]&lt;/code&gt; items</source>
          <target state="translated">Размер &lt;code&gt;#[repr(C)]&lt;/code&gt; элементов</target>
        </trans-unit>
        <trans-unit id="aa6a08373f71dd56c89763573898cda876af66a9" translate="yes" xml:space="preserve">
          <source>Size of Enums</source>
          <target state="translated">Размер переписей</target>
        </trans-unit>
        <trans-unit id="6b52ecd2f9fc6e1813053b01f83a05b834e08941" translate="yes" xml:space="preserve">
          <source>Size of Structs</source>
          <target state="translated">Размеры струн</target>
        </trans-unit>
        <trans-unit id="1feff492ca8a9a3bc4a26e483e6cb0262d851ca0" translate="yes" xml:space="preserve">
          <source>Size of Unions</source>
          <target state="translated">Размер Союза</target>
        </trans-unit>
        <trans-unit id="2ecf7208ad77d957cb2e1a89293524823cf35c3e" translate="yes" xml:space="preserve">
          <source>Sized</source>
          <target state="translated">Sized</target>
        </trans-unit>
        <trans-unit id="3da474537ac378c616d6b301acc1674bc348cecd" translate="yes" xml:space="preserve">
          <source>Skip</source>
          <target state="translated">Skip</target>
        </trans-unit>
        <trans-unit id="bf47c2169ff524c7aead5b6e515a8d42bd4b77a9" translate="yes" xml:space="preserve">
          <source>Skip to the next iteration of a loop.</source>
          <target state="translated">Переходим к следующей итерации петли.</target>
        </trans-unit>
        <trans-unit id="8d67699e65efc053e93dca13ef4b1f6202ba1901" translate="yes" xml:space="preserve">
          <source>Skip::all</source>
          <target state="translated">Skip::all</target>
        </trans-unit>
        <trans-unit id="141e853bf04e8103da2b2c07dbf8000f54f570bf" translate="yes" xml:space="preserve">
          <source>Skip::any</source>
          <target state="translated">Skip::any</target>
        </trans-unit>
        <trans-unit id="c572bc5841959dca75e9c92d6139c6c8321aabf8" translate="yes" xml:space="preserve">
          <source>Skip::borrow</source>
          <target state="translated">Skip::borrow</target>
        </trans-unit>
        <trans-unit id="bb425ddbe3925202b0b1566fb4567e3171373ac7" translate="yes" xml:space="preserve">
          <source>Skip::borrow_mut</source>
          <target state="translated">Skip::borrow_mut</target>
        </trans-unit>
        <trans-unit id="abc1b8180d94b0691f88b2c8b5f9022896fcd951" translate="yes" xml:space="preserve">
          <source>Skip::by_ref</source>
          <target state="translated">Skip::by_ref</target>
        </trans-unit>
        <trans-unit id="ac8d08d116f5cee3f4346786234b2f95b0e8712c" translate="yes" xml:space="preserve">
          <source>Skip::chain</source>
          <target state="translated">Skip::chain</target>
        </trans-unit>
        <trans-unit id="05348998f0a735c96821775992fcabcbe0f2637b" translate="yes" xml:space="preserve">
          <source>Skip::clone</source>
          <target state="translated">Skip::clone</target>
        </trans-unit>
        <trans-unit id="ab942803336d4a18c570f4b33a95565c2f912da9" translate="yes" xml:space="preserve">
          <source>Skip::clone_from</source>
          <target state="translated">Skip::clone_from</target>
        </trans-unit>
        <trans-unit id="54eb30686bf309c8534a4169a59b2eb41600beb1" translate="yes" xml:space="preserve">
          <source>Skip::clone_into</source>
          <target state="translated">Skip::clone_into</target>
        </trans-unit>
        <trans-unit id="ed4e38033dd806ff8d752e63571ae83c6733409d" translate="yes" xml:space="preserve">
          <source>Skip::cloned</source>
          <target state="translated">Skip::cloned</target>
        </trans-unit>
        <trans-unit id="b0bf2a0cd01bdd325ee257ee06de3b9c617e0d11" translate="yes" xml:space="preserve">
          <source>Skip::cmp</source>
          <target state="translated">Skip::cmp</target>
        </trans-unit>
        <trans-unit id="02c0a58a456fffb957ceb2519514865d280ec66a" translate="yes" xml:space="preserve">
          <source>Skip::collect</source>
          <target state="translated">Skip::collect</target>
        </trans-unit>
        <trans-unit id="f572ea5aae0784c24ea52b6f645ec73b1b72c674" translate="yes" xml:space="preserve">
          <source>Skip::copied</source>
          <target state="translated">Skip::copied</target>
        </trans-unit>
        <trans-unit id="40d90248faa89c2b6340db905f56295e956458ea" translate="yes" xml:space="preserve">
          <source>Skip::count</source>
          <target state="translated">Skip::count</target>
        </trans-unit>
        <trans-unit id="5c13df6d2d71e1aeab130ef4967e90660241c022" translate="yes" xml:space="preserve">
          <source>Skip::cycle</source>
          <target state="translated">Skip::cycle</target>
        </trans-unit>
        <trans-unit id="81f0912435fda5e9269d1b7959e08d64503d681f" translate="yes" xml:space="preserve">
          <source>Skip::enumerate</source>
          <target state="translated">Skip::enumerate</target>
        </trans-unit>
        <trans-unit id="8d4632bae1e84eda74aeae1018124ebf229eda3e" translate="yes" xml:space="preserve">
          <source>Skip::eq</source>
          <target state="translated">Skip::eq</target>
        </trans-unit>
        <trans-unit id="eb8a3a22b5ea79cfb61fb7507a6d78a8f1292f27" translate="yes" xml:space="preserve">
          <source>Skip::filter</source>
          <target state="translated">Skip::filter</target>
        </trans-unit>
        <trans-unit id="874be171075c0b4b3eee66f8ced42abe0b0e3baa" translate="yes" xml:space="preserve">
          <source>Skip::filter_map</source>
          <target state="translated">Skip::filter_map</target>
        </trans-unit>
        <trans-unit id="a30fb0f619bbc4f631f8c4492f10c577c7f6de5b" translate="yes" xml:space="preserve">
          <source>Skip::find</source>
          <target state="translated">Skip::find</target>
        </trans-unit>
        <trans-unit id="dbc55aa235c22a0214953850ca711401b23ed4a4" translate="yes" xml:space="preserve">
          <source>Skip::find_map</source>
          <target state="translated">Skip::find_map</target>
        </trans-unit>
        <trans-unit id="8a9e86e948e9bd0ef00a26f68bef19063068548f" translate="yes" xml:space="preserve">
          <source>Skip::flat_map</source>
          <target state="translated">Skip::flat_map</target>
        </trans-unit>
        <trans-unit id="e16f1f9ef8d1d4589cd1c4bd5ed7f80c4d5f6ddd" translate="yes" xml:space="preserve">
          <source>Skip::flatten</source>
          <target state="translated">Skip::flatten</target>
        </trans-unit>
        <trans-unit id="9086b93356bb81e44b2d7f1412ac4fe86bd0dcb1" translate="yes" xml:space="preserve">
          <source>Skip::fmt</source>
          <target state="translated">Skip::fmt</target>
        </trans-unit>
        <trans-unit id="e3d9c86bbe78f52a56ad6fff4a0b01475f10581d" translate="yes" xml:space="preserve">
          <source>Skip::fold</source>
          <target state="translated">Skip::fold</target>
        </trans-unit>
        <trans-unit id="c8e88869f2740a973d0537592ce1555579baa1b7" translate="yes" xml:space="preserve">
          <source>Skip::for_each</source>
          <target state="translated">Skip::for_each</target>
        </trans-unit>
        <trans-unit id="c104bc225095dfb31451ec18bca1d818a9b034cc" translate="yes" xml:space="preserve">
          <source>Skip::from</source>
          <target state="translated">Skip::from</target>
        </trans-unit>
        <trans-unit id="e67aaeac0314d54938507d57ca05493c7d19a56d" translate="yes" xml:space="preserve">
          <source>Skip::fuse</source>
          <target state="translated">Skip::fuse</target>
        </trans-unit>
        <trans-unit id="f0e121a4c13868ff9f1bc27cbb52b11b553a299c" translate="yes" xml:space="preserve">
          <source>Skip::ge</source>
          <target state="translated">Skip::ge</target>
        </trans-unit>
        <trans-unit id="5cfa9f35d793092fb95d4bd2c5bfbdee2b01d07e" translate="yes" xml:space="preserve">
          <source>Skip::gt</source>
          <target state="translated">Skip::gt</target>
        </trans-unit>
        <trans-unit id="32d75c54c889166e3bbe5ec4632b338aaa132ad5" translate="yes" xml:space="preserve">
          <source>Skip::inspect</source>
          <target state="translated">Skip::inspect</target>
        </trans-unit>
        <trans-unit id="3d8db1257125ff8e4340421bc43225609fe092b2" translate="yes" xml:space="preserve">
          <source>Skip::into</source>
          <target state="translated">Skip::into</target>
        </trans-unit>
        <trans-unit id="55521a2f13f746b7b112a71469d51f5284ad5f45" translate="yes" xml:space="preserve">
          <source>Skip::into_iter</source>
          <target state="translated">Skip::into_iter</target>
        </trans-unit>
        <trans-unit id="5038f6c0c3001beb5f7a911c129fa9f1cee58ee5" translate="yes" xml:space="preserve">
          <source>Skip::is_empty</source>
          <target state="translated">Skip::is_empty</target>
        </trans-unit>
        <trans-unit id="272bf3795578cd2bc47dda4c90cfee7e48d2a48e" translate="yes" xml:space="preserve">
          <source>Skip::is_sorted</source>
          <target state="translated">Skip::is_sorted</target>
        </trans-unit>
        <trans-unit id="f24a2c232270c929008d3680d05c96536a1217b0" translate="yes" xml:space="preserve">
          <source>Skip::is_sorted_by</source>
          <target state="translated">Skip::is_sorted_by</target>
        </trans-unit>
        <trans-unit id="47d5c21e2c2c68b022473e8f093afd6958451210" translate="yes" xml:space="preserve">
          <source>Skip::is_sorted_by_key</source>
          <target state="translated">Skip::is_sorted_by_key</target>
        </trans-unit>
        <trans-unit id="10bf154533e067f3dd7f0c05e621c3870a0af4da" translate="yes" xml:space="preserve">
          <source>Skip::last</source>
          <target state="translated">Skip::last</target>
        </trans-unit>
        <trans-unit id="315ffa7298e0fefbae874a8a39d9da1e324efed4" translate="yes" xml:space="preserve">
          <source>Skip::le</source>
          <target state="translated">Skip::le</target>
        </trans-unit>
        <trans-unit id="74eddfb30c713b021758da54f8dfa23e300f61e7" translate="yes" xml:space="preserve">
          <source>Skip::len</source>
          <target state="translated">Skip::len</target>
        </trans-unit>
        <trans-unit id="45c696c0e3866151d3a57b3bff59b8fff75e35d0" translate="yes" xml:space="preserve">
          <source>Skip::lt</source>
          <target state="translated">Skip::lt</target>
        </trans-unit>
        <trans-unit id="636efebe4a0de6af6b19ee04711f693b72aa7384" translate="yes" xml:space="preserve">
          <source>Skip::map</source>
          <target state="translated">Skip::map</target>
        </trans-unit>
        <trans-unit id="3110dfcf391e72c609e1fcb719b14d271b6338f1" translate="yes" xml:space="preserve">
          <source>Skip::max</source>
          <target state="translated">Skip::max</target>
        </trans-unit>
        <trans-unit id="cf79602620d165a3c07f034e49eccbc6fae960cf" translate="yes" xml:space="preserve">
          <source>Skip::max_by</source>
          <target state="translated">Skip::max_by</target>
        </trans-unit>
        <trans-unit id="cb499c31e556db2f15927d4f82a032492a61ceca" translate="yes" xml:space="preserve">
          <source>Skip::max_by_key</source>
          <target state="translated">Skip::max_by_key</target>
        </trans-unit>
        <trans-unit id="de3235931a068719ad0f8fc80b83d097f439212e" translate="yes" xml:space="preserve">
          <source>Skip::min</source>
          <target state="translated">Skip::min</target>
        </trans-unit>
        <trans-unit id="8e5aeeb79f94b335034d3d7c10d7cc32b084728e" translate="yes" xml:space="preserve">
          <source>Skip::min_by</source>
          <target state="translated">Skip::min_by</target>
        </trans-unit>
        <trans-unit id="446117a44e4232d0b4427dfab79f31d57b72b374" translate="yes" xml:space="preserve">
          <source>Skip::min_by_key</source>
          <target state="translated">Skip::min_by_key</target>
        </trans-unit>
        <trans-unit id="016ccdf91210df76c448998f1e0e4b330645b257" translate="yes" xml:space="preserve">
          <source>Skip::ne</source>
          <target state="translated">Skip::ne</target>
        </trans-unit>
        <trans-unit id="8712be814c452b15d7f4b42f9c05395226c88dcb" translate="yes" xml:space="preserve">
          <source>Skip::next</source>
          <target state="translated">Skip::next</target>
        </trans-unit>
        <trans-unit id="534d1f6dac0a6c0bdd3cac0df7681b2be1851f06" translate="yes" xml:space="preserve">
          <source>Skip::next_back</source>
          <target state="translated">Skip::next_back</target>
        </trans-unit>
        <trans-unit id="0ebc6ec7583aba4767668232540e401fd9ba6c7b" translate="yes" xml:space="preserve">
          <source>Skip::nth</source>
          <target state="translated">Skip::nth</target>
        </trans-unit>
        <trans-unit id="273d494c50d7f8cb0a2fb38ae8a28f07301aa066" translate="yes" xml:space="preserve">
          <source>Skip::nth_back</source>
          <target state="translated">Skip::nth_back</target>
        </trans-unit>
        <trans-unit id="dea71f0f125872655107e8b4862adffe97b60b5b" translate="yes" xml:space="preserve">
          <source>Skip::partial_cmp</source>
          <target state="translated">Skip::partial_cmp</target>
        </trans-unit>
        <trans-unit id="aa7460464f565bc9cd21936e33b7617d739e1591" translate="yes" xml:space="preserve">
          <source>Skip::partition</source>
          <target state="translated">Skip::partition</target>
        </trans-unit>
        <trans-unit id="075b408bc35851d7da6cfa726867a7bd57d185c9" translate="yes" xml:space="preserve">
          <source>Skip::peekable</source>
          <target state="translated">Skip::peekable</target>
        </trans-unit>
        <trans-unit id="47240470807be493a133c5eaddde44f49995839f" translate="yes" xml:space="preserve">
          <source>Skip::position</source>
          <target state="translated">Skip::position</target>
        </trans-unit>
        <trans-unit id="691499df965f712a43ae65c1614c977032337079" translate="yes" xml:space="preserve">
          <source>Skip::product</source>
          <target state="translated">Skip::product</target>
        </trans-unit>
        <trans-unit id="2cfb56bc1abe3ee9eacbe6e1bf0440aeda494cd5" translate="yes" xml:space="preserve">
          <source>Skip::rev</source>
          <target state="translated">Skip::rev</target>
        </trans-unit>
        <trans-unit id="0480cefdfad343de236e3b69c19f0c4377b5e322" translate="yes" xml:space="preserve">
          <source>Skip::rfind</source>
          <target state="translated">Skip::rfind</target>
        </trans-unit>
        <trans-unit id="769a4497620dd9facd3c69ccfc0dad2e78eafc81" translate="yes" xml:space="preserve">
          <source>Skip::rfold</source>
          <target state="translated">Skip::rfold</target>
        </trans-unit>
        <trans-unit id="932d2a0b7f9aa1aa05317836e0f63443976068eb" translate="yes" xml:space="preserve">
          <source>Skip::rposition</source>
          <target state="translated">Skip::rposition</target>
        </trans-unit>
        <trans-unit id="a721c32fcaf7b2dbd6fab9a691bffaa10e317dcb" translate="yes" xml:space="preserve">
          <source>Skip::scan</source>
          <target state="translated">Skip::scan</target>
        </trans-unit>
        <trans-unit id="019356e9e0e60bb58c85bb7605bb1dff8fbb644b" translate="yes" xml:space="preserve">
          <source>Skip::size_hint</source>
          <target state="translated">Skip::size_hint</target>
        </trans-unit>
        <trans-unit id="605b884d4e68ad0652454fe028c2b2b2d0bf1f55" translate="yes" xml:space="preserve">
          <source>Skip::skip</source>
          <target state="translated">Skip::skip</target>
        </trans-unit>
        <trans-unit id="a84c497b977bf164cf38b614420a401bf122afec" translate="yes" xml:space="preserve">
          <source>Skip::skip_while</source>
          <target state="translated">Skip::skip_while</target>
        </trans-unit>
        <trans-unit id="72c015c31df7b28c6bf48d72fcf7687cd5cc5f08" translate="yes" xml:space="preserve">
          <source>Skip::step_by</source>
          <target state="translated">Skip::step_by</target>
        </trans-unit>
        <trans-unit id="b24eeb276057c34c15267d264cdde7e24b28e94c" translate="yes" xml:space="preserve">
          <source>Skip::sum</source>
          <target state="translated">Skip::sum</target>
        </trans-unit>
        <trans-unit id="786fbffb58c10870fc6472b0f9ebe8e005834e6e" translate="yes" xml:space="preserve">
          <source>Skip::take</source>
          <target state="translated">Skip::take</target>
        </trans-unit>
        <trans-unit id="6a7a19f72cb62542178db1b5acfc97dbf3534f4b" translate="yes" xml:space="preserve">
          <source>Skip::take_while</source>
          <target state="translated">Skip::take_while</target>
        </trans-unit>
        <trans-unit id="61a46f4a7c5265079c849af4f618df1736685196" translate="yes" xml:space="preserve">
          <source>Skip::to_owned</source>
          <target state="translated">Skip::to_owned</target>
        </trans-unit>
        <trans-unit id="c176adab52c0482523c3a0bdfc430057f640bc68" translate="yes" xml:space="preserve">
          <source>Skip::try_fold</source>
          <target state="translated">Skip::try_fold</target>
        </trans-unit>
        <trans-unit id="bc4fbff9cdd49a0c0ec58c470298314a0d351890" translate="yes" xml:space="preserve">
          <source>Skip::try_for_each</source>
          <target state="translated">Skip::try_for_each</target>
        </trans-unit>
        <trans-unit id="3a6ff77afd53390d404c04b4d8b824a12d11fe69" translate="yes" xml:space="preserve">
          <source>Skip::try_from</source>
          <target state="translated">Skip::try_from</target>
        </trans-unit>
        <trans-unit id="0ff3cc9a1085dadeb6133ba9f367559c2327c721" translate="yes" xml:space="preserve">
          <source>Skip::try_into</source>
          <target state="translated">Skip::try_into</target>
        </trans-unit>
        <trans-unit id="3e4ddfb53f35b3ff6209898a989c06b6d31b6a15" translate="yes" xml:space="preserve">
          <source>Skip::try_rfold</source>
          <target state="translated">Skip::try_rfold</target>
        </trans-unit>
        <trans-unit id="4d0b4d7dcbb0aec04511db37ea98be0fcaf79295" translate="yes" xml:space="preserve">
          <source>Skip::type_id</source>
          <target state="translated">Skip::type_id</target>
        </trans-unit>
        <trans-unit id="f66f20cf5e4ce8073947e7bdcea46c6358bf9608" translate="yes" xml:space="preserve">
          <source>Skip::unzip</source>
          <target state="translated">Skip::unzip</target>
        </trans-unit>
        <trans-unit id="8932bfb221e72115e120c13485894171d4582d0e" translate="yes" xml:space="preserve">
          <source>Skip::zip</source>
          <target state="translated">Skip::zip</target>
        </trans-unit>
        <trans-unit id="22e179bea92af551a86509fda88cb097314902ec" translate="yes" xml:space="preserve">
          <source>SkipWhile</source>
          <target state="translated">SkipWhile</target>
        </trans-unit>
        <trans-unit id="a251611a5ac9647617f802344994207a8b4db01a" translate="yes" xml:space="preserve">
          <source>SkipWhile::all</source>
          <target state="translated">SkipWhile::all</target>
        </trans-unit>
        <trans-unit id="2ae549195f30071a0e9d8d90c2e8583a38099511" translate="yes" xml:space="preserve">
          <source>SkipWhile::any</source>
          <target state="translated">SkipWhile::any</target>
        </trans-unit>
        <trans-unit id="98baaebe6857101ea22467675357020bb4fcd7a9" translate="yes" xml:space="preserve">
          <source>SkipWhile::borrow</source>
          <target state="translated">SkipWhile::borrow</target>
        </trans-unit>
        <trans-unit id="ce2e2f99def3c54e6795960ad9510b8130f483f0" translate="yes" xml:space="preserve">
          <source>SkipWhile::borrow_mut</source>
          <target state="translated">SkipWhile::borrow_mut</target>
        </trans-unit>
        <trans-unit id="c64071d1ca91b85edf166d56a370e88fe51d3b6d" translate="yes" xml:space="preserve">
          <source>SkipWhile::by_ref</source>
          <target state="translated">SkipWhile::by_ref</target>
        </trans-unit>
        <trans-unit id="b884d6e3b0cc117790f90239ec9dbd1eac5f13e4" translate="yes" xml:space="preserve">
          <source>SkipWhile::chain</source>
          <target state="translated">SkipWhile::chain</target>
        </trans-unit>
        <trans-unit id="cfc70cf8aed73488e407b6a7889ed7a8418ac602" translate="yes" xml:space="preserve">
          <source>SkipWhile::clone</source>
          <target state="translated">SkipWhile::clone</target>
        </trans-unit>
        <trans-unit id="acb8841d5260a38a1c9a9e05a7fab9292b8b7432" translate="yes" xml:space="preserve">
          <source>SkipWhile::clone_from</source>
          <target state="translated">SkipWhile::clone_from</target>
        </trans-unit>
        <trans-unit id="23f06ee81a3fc0167121fb8614c94b17561b2d77" translate="yes" xml:space="preserve">
          <source>SkipWhile::clone_into</source>
          <target state="translated">SkipWhile::clone_into</target>
        </trans-unit>
        <trans-unit id="8f58781a9269c6913f408bde07a5a2294de2446c" translate="yes" xml:space="preserve">
          <source>SkipWhile::cloned</source>
          <target state="translated">SkipWhile::cloned</target>
        </trans-unit>
        <trans-unit id="d4bbd6d43c74619248fe631024a5933fc3b97d5c" translate="yes" xml:space="preserve">
          <source>SkipWhile::cmp</source>
          <target state="translated">SkipWhile::cmp</target>
        </trans-unit>
        <trans-unit id="07c66ff1c2afbc10eb23e76ea19f3a092d94be54" translate="yes" xml:space="preserve">
          <source>SkipWhile::collect</source>
          <target state="translated">SkipWhile::collect</target>
        </trans-unit>
        <trans-unit id="514f5d9b2ee067a9a9ff4a4372834b6f2a4a029d" translate="yes" xml:space="preserve">
          <source>SkipWhile::copied</source>
          <target state="translated">SkipWhile::copied</target>
        </trans-unit>
        <trans-unit id="b39287b6c7743f091fb51959b8ed9fc02fc1c441" translate="yes" xml:space="preserve">
          <source>SkipWhile::count</source>
          <target state="translated">SkipWhile::count</target>
        </trans-unit>
        <trans-unit id="b372492b95553200f08ed5d8376e3d5b6576ce37" translate="yes" xml:space="preserve">
          <source>SkipWhile::cycle</source>
          <target state="translated">SkipWhile::cycle</target>
        </trans-unit>
        <trans-unit id="8de5e9639de9bf1bdfd7ee1683e67a7fe1b00ae5" translate="yes" xml:space="preserve">
          <source>SkipWhile::enumerate</source>
          <target state="translated">SkipWhile::enumerate</target>
        </trans-unit>
        <trans-unit id="3bc9577a92b59142e8578d161b13a1218a9fd0f8" translate="yes" xml:space="preserve">
          <source>SkipWhile::eq</source>
          <target state="translated">SkipWhile::eq</target>
        </trans-unit>
        <trans-unit id="bdb5592467ce942b2dd3afbb042a05ca026980fe" translate="yes" xml:space="preserve">
          <source>SkipWhile::filter</source>
          <target state="translated">SkipWhile::filter</target>
        </trans-unit>
        <trans-unit id="a4820567d9d6b30953a49ae15c41d964dba436eb" translate="yes" xml:space="preserve">
          <source>SkipWhile::filter_map</source>
          <target state="translated">SkipWhile::filter_map</target>
        </trans-unit>
        <trans-unit id="f4406599d75121d440746ae6a4d7f7780b74a7cd" translate="yes" xml:space="preserve">
          <source>SkipWhile::find</source>
          <target state="translated">SkipWhile::find</target>
        </trans-unit>
        <trans-unit id="719989fc5cfa90ef05d766b5b2d16a9e9f2cdaec" translate="yes" xml:space="preserve">
          <source>SkipWhile::find_map</source>
          <target state="translated">SkipWhile::find_map</target>
        </trans-unit>
        <trans-unit id="11659c0940aa3e200438cdeb7d9d829adaada9c8" translate="yes" xml:space="preserve">
          <source>SkipWhile::flat_map</source>
          <target state="translated">SkipWhile::flat_map</target>
        </trans-unit>
        <trans-unit id="eb45e6310d61b51a6f8e05810a0a9936481b0f76" translate="yes" xml:space="preserve">
          <source>SkipWhile::flatten</source>
          <target state="translated">SkipWhile::flatten</target>
        </trans-unit>
        <trans-unit id="3717dc2daffe5d4b403a4ca71a02890431980d8c" translate="yes" xml:space="preserve">
          <source>SkipWhile::fmt</source>
          <target state="translated">SkipWhile::fmt</target>
        </trans-unit>
        <trans-unit id="6fde0ea9ce42ccbfc6d6d7195a3168b240db9631" translate="yes" xml:space="preserve">
          <source>SkipWhile::fold</source>
          <target state="translated">SkipWhile::fold</target>
        </trans-unit>
        <trans-unit id="50caa2bd8e84ee483a82d00cc9915273efd59ac4" translate="yes" xml:space="preserve">
          <source>SkipWhile::for_each</source>
          <target state="translated">SkipWhile::for_each</target>
        </trans-unit>
        <trans-unit id="84ff07782bb5f48c0970cd148af80cb045a0eac0" translate="yes" xml:space="preserve">
          <source>SkipWhile::from</source>
          <target state="translated">SkipWhile::from</target>
        </trans-unit>
        <trans-unit id="754ae44be63a5b026814434cd281e24557f66cdb" translate="yes" xml:space="preserve">
          <source>SkipWhile::fuse</source>
          <target state="translated">SkipWhile::fuse</target>
        </trans-unit>
        <trans-unit id="e7c0f6e0d8dd018d9e212577757ec3b99507a73c" translate="yes" xml:space="preserve">
          <source>SkipWhile::ge</source>
          <target state="translated">SkipWhile::ge</target>
        </trans-unit>
        <trans-unit id="add5b99883ab21fed5358f11a1e9df18abb3be62" translate="yes" xml:space="preserve">
          <source>SkipWhile::gt</source>
          <target state="translated">SkipWhile::gt</target>
        </trans-unit>
        <trans-unit id="6bf9339ed08e9bb39b3d1ee30f930256d5188169" translate="yes" xml:space="preserve">
          <source>SkipWhile::inspect</source>
          <target state="translated">SkipWhile::inspect</target>
        </trans-unit>
        <trans-unit id="c1ff330f5ce8c23a7ad4ae6e8a2d96352b366c30" translate="yes" xml:space="preserve">
          <source>SkipWhile::into</source>
          <target state="translated">SkipWhile::into</target>
        </trans-unit>
        <trans-unit id="0f10f4984c69a0e0da2f055eec7170dc535a19b5" translate="yes" xml:space="preserve">
          <source>SkipWhile::into_iter</source>
          <target state="translated">SkipWhile::into_iter</target>
        </trans-unit>
        <trans-unit id="137eb73e5cdd03b27635d4bc69c4197194535aac" translate="yes" xml:space="preserve">
          <source>SkipWhile::is_sorted</source>
          <target state="translated">SkipWhile::is_sorted</target>
        </trans-unit>
        <trans-unit id="68f8c6e87e6e587a32da249478bba4ada1e29934" translate="yes" xml:space="preserve">
          <source>SkipWhile::is_sorted_by</source>
          <target state="translated">SkipWhile::is_sorted_by</target>
        </trans-unit>
        <trans-unit id="73a054a3c41f51790c051964baf7b2c43240f041" translate="yes" xml:space="preserve">
          <source>SkipWhile::is_sorted_by_key</source>
          <target state="translated">SkipWhile::is_sorted_by_key</target>
        </trans-unit>
        <trans-unit id="17b146d86e99d5592fe3427358624989bfbde86a" translate="yes" xml:space="preserve">
          <source>SkipWhile::last</source>
          <target state="translated">SkipWhile::last</target>
        </trans-unit>
        <trans-unit id="e9af22e02429653f1e5e05d885c6f9c3a2b8d11c" translate="yes" xml:space="preserve">
          <source>SkipWhile::le</source>
          <target state="translated">SkipWhile::le</target>
        </trans-unit>
        <trans-unit id="0364dacead75cc42dd00a0f9c451a6a421f03a24" translate="yes" xml:space="preserve">
          <source>SkipWhile::lt</source>
          <target state="translated">SkipWhile::lt</target>
        </trans-unit>
        <trans-unit id="c5698741d64b9f591e0fdc7367422c2732e1e5c5" translate="yes" xml:space="preserve">
          <source>SkipWhile::map</source>
          <target state="translated">SkipWhile::map</target>
        </trans-unit>
        <trans-unit id="ec412fa6842f2575adf5d3fb75c664a4852eedf8" translate="yes" xml:space="preserve">
          <source>SkipWhile::max</source>
          <target state="translated">SkipWhile::max</target>
        </trans-unit>
        <trans-unit id="0a0616fff10b52d273e49c0e5ac50ae16e2e2c07" translate="yes" xml:space="preserve">
          <source>SkipWhile::max_by</source>
          <target state="translated">SkipWhile::max_by</target>
        </trans-unit>
        <trans-unit id="d7587f5d81d60f3ea50c6983e15764f4e5dd9150" translate="yes" xml:space="preserve">
          <source>SkipWhile::max_by_key</source>
          <target state="translated">SkipWhile::max_by_key</target>
        </trans-unit>
        <trans-unit id="52358d799e74f228b4f92a70c2807042b6cca1f2" translate="yes" xml:space="preserve">
          <source>SkipWhile::min</source>
          <target state="translated">SkipWhile::min</target>
        </trans-unit>
        <trans-unit id="73f597f3beaf6b11d49b5d22aecf078de23f6bd0" translate="yes" xml:space="preserve">
          <source>SkipWhile::min_by</source>
          <target state="translated">SkipWhile::min_by</target>
        </trans-unit>
        <trans-unit id="5a1a140874972b854960962e46f7276e2af59e01" translate="yes" xml:space="preserve">
          <source>SkipWhile::min_by_key</source>
          <target state="translated">SkipWhile::min_by_key</target>
        </trans-unit>
        <trans-unit id="183883d7b1286b35bcc0572cad98b0334c5d761a" translate="yes" xml:space="preserve">
          <source>SkipWhile::ne</source>
          <target state="translated">SkipWhile::ne</target>
        </trans-unit>
        <trans-unit id="6808d12fec2558ee9e7d9db84926b66fbdfca8a5" translate="yes" xml:space="preserve">
          <source>SkipWhile::next</source>
          <target state="translated">SkipWhile::next</target>
        </trans-unit>
        <trans-unit id="048ee149a8b3bdb60154996c24b928e7eae9e765" translate="yes" xml:space="preserve">
          <source>SkipWhile::nth</source>
          <target state="translated">SkipWhile::nth</target>
        </trans-unit>
        <trans-unit id="edf2c6724fae8ee0a9d4aa2c7dcb71ea3ad5286e" translate="yes" xml:space="preserve">
          <source>SkipWhile::partial_cmp</source>
          <target state="translated">SkipWhile::partial_cmp</target>
        </trans-unit>
        <trans-unit id="235286e617118ef2eedf3de3d0ebf82026f8fd5d" translate="yes" xml:space="preserve">
          <source>SkipWhile::partition</source>
          <target state="translated">SkipWhile::partition</target>
        </trans-unit>
        <trans-unit id="ac388412dbf3931e3b5ea83b1c7d9712285bcb38" translate="yes" xml:space="preserve">
          <source>SkipWhile::peekable</source>
          <target state="translated">SkipWhile::peekable</target>
        </trans-unit>
        <trans-unit id="07e918bf1b8f1a943e4aa4437dea685dd0df01b7" translate="yes" xml:space="preserve">
          <source>SkipWhile::position</source>
          <target state="translated">SkipWhile::position</target>
        </trans-unit>
        <trans-unit id="0e320f453b91cba9a36d985bd6e2429ffa0e8064" translate="yes" xml:space="preserve">
          <source>SkipWhile::product</source>
          <target state="translated">SkipWhile::product</target>
        </trans-unit>
        <trans-unit id="c640a2bb803f9e27faec1b403698fd2e5f2317e0" translate="yes" xml:space="preserve">
          <source>SkipWhile::rev</source>
          <target state="translated">SkipWhile::rev</target>
        </trans-unit>
        <trans-unit id="be0da2c868e6e89f9992a40468321a3b7785fc27" translate="yes" xml:space="preserve">
          <source>SkipWhile::rposition</source>
          <target state="translated">SkipWhile::rposition</target>
        </trans-unit>
        <trans-unit id="6da80a895515ebcde023348aaab45576a62e8242" translate="yes" xml:space="preserve">
          <source>SkipWhile::scan</source>
          <target state="translated">SkipWhile::scan</target>
        </trans-unit>
        <trans-unit id="2a18e5a45186e93c570ed7bc1be516990e9d8596" translate="yes" xml:space="preserve">
          <source>SkipWhile::size_hint</source>
          <target state="translated">SkipWhile::size_hint</target>
        </trans-unit>
        <trans-unit id="b2f6ae931605aef6528f5eea7e1adc04d9d521b5" translate="yes" xml:space="preserve">
          <source>SkipWhile::skip</source>
          <target state="translated">SkipWhile::skip</target>
        </trans-unit>
        <trans-unit id="14349868da94b723f6e3342b39932c98acce80b3" translate="yes" xml:space="preserve">
          <source>SkipWhile::skip_while</source>
          <target state="translated">SkipWhile::skip_while</target>
        </trans-unit>
        <trans-unit id="24b712d0e65ede1461313b83ed15cb426add409e" translate="yes" xml:space="preserve">
          <source>SkipWhile::step_by</source>
          <target state="translated">SkipWhile::step_by</target>
        </trans-unit>
        <trans-unit id="307822395f63d85b6d4ad3f4f5d8695ff56b05c7" translate="yes" xml:space="preserve">
          <source>SkipWhile::sum</source>
          <target state="translated">SkipWhile::sum</target>
        </trans-unit>
        <trans-unit id="b5ebfade771014ee60f290ee3f34856921c4965a" translate="yes" xml:space="preserve">
          <source>SkipWhile::take</source>
          <target state="translated">SkipWhile::take</target>
        </trans-unit>
        <trans-unit id="ccec794ebfdc1546c5df129f1d4ff37a111976d1" translate="yes" xml:space="preserve">
          <source>SkipWhile::take_while</source>
          <target state="translated">SkipWhile::take_while</target>
        </trans-unit>
        <trans-unit id="39b22a520487262ca064f7848b2d0e2cdf9801b7" translate="yes" xml:space="preserve">
          <source>SkipWhile::to_owned</source>
          <target state="translated">SkipWhile::to_owned</target>
        </trans-unit>
        <trans-unit id="d8b0ab2cf16dc0748bb4549ffb37f837e39f5dba" translate="yes" xml:space="preserve">
          <source>SkipWhile::try_fold</source>
          <target state="translated">SkipWhile::try_fold</target>
        </trans-unit>
        <trans-unit id="0a1e9cd3d27da6ea2f47c61b83974e7ad5cee996" translate="yes" xml:space="preserve">
          <source>SkipWhile::try_for_each</source>
          <target state="translated">SkipWhile::try_for_each</target>
        </trans-unit>
        <trans-unit id="3f8a1565c038614fe428a25de2a00d13c06a46d4" translate="yes" xml:space="preserve">
          <source>SkipWhile::try_from</source>
          <target state="translated">SkipWhile::try_from</target>
        </trans-unit>
        <trans-unit id="b5986509cedc2dd0d67c67f3110a76f983758512" translate="yes" xml:space="preserve">
          <source>SkipWhile::try_into</source>
          <target state="translated">SkipWhile::try_into</target>
        </trans-unit>
        <trans-unit id="034417ac3e34efa5dff73aa36d45ff52950bafaf" translate="yes" xml:space="preserve">
          <source>SkipWhile::type_id</source>
          <target state="translated">SkipWhile::type_id</target>
        </trans-unit>
        <trans-unit id="aa8085a3efd31556a82ba60ccda975bf65ad2268" translate="yes" xml:space="preserve">
          <source>SkipWhile::unzip</source>
          <target state="translated">SkipWhile::unzip</target>
        </trans-unit>
        <trans-unit id="a701a8dc1340972d721fb7163deea6fd76dafdf3" translate="yes" xml:space="preserve">
          <source>SkipWhile::zip</source>
          <target state="translated">SkipWhile::zip</target>
        </trans-unit>
        <trans-unit id="a2c169fcee2a0e0599001b3215f71adf47f0699e" translate="yes" xml:space="preserve">
          <source>Slash</source>
          <target state="translated">Slash</target>
        </trans-unit>
        <trans-unit id="01ce38023820b6dfa8f41557520ebca667e1ad59" translate="yes" xml:space="preserve">
          <source>SlashEq</source>
          <target state="translated">SlashEq</target>
        </trans-unit>
        <trans-unit id="0c8525a31f225d6db84222cdc68f43cb8c6c18bf" translate="yes" xml:space="preserve">
          <source>Slice</source>
          <target state="translated">Slice</target>
        </trans-unit>
        <trans-unit id="34e7eb0ad02d68841a482e6343474939a06188ca" translate="yes" xml:space="preserve">
          <source>Slice Layout</source>
          <target state="translated">Макет среза</target>
        </trans-unit>
        <trans-unit id="8b85692c79a013e21b5bc8d7b364bf45e1566533" translate="yes" xml:space="preserve">
          <source>Slice metadata is invalid if the length is not a valid &lt;code&gt;usize&lt;/code&gt; (i.e., it must not be read from uninitialized memory).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="769f0ac84c24a3608c1a3219a0a737194226fde7" translate="yes" xml:space="preserve">
          <source>Slice patterns</source>
          <target state="translated">Узоры на срезах</target>
        </trans-unit>
        <trans-unit id="66ec64e6a3f3a0d922746be7dc2d16d8e60b1604" translate="yes" xml:space="preserve">
          <source>Slice patterns are irrefutable when matching an array as long as each element is irrefutable. When matching a slice, it is irrefutable only in the form with a single &lt;code&gt;..&lt;/code&gt;&lt;a href=&quot;#rest-patterns&quot;&gt;rest pattern&lt;/a&gt; or &lt;a href=&quot;#identifier-patterns&quot;&gt;identifier pattern&lt;/a&gt; with the &lt;code&gt;..&lt;/code&gt; rest pattern as a subpattern.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4e49fa811ea06da1bbcb6ce9682db443bbcb90e6" translate="yes" xml:space="preserve">
          <source>Slice patterns can match both arrays of fixed size and slices of dynamic size.</source>
          <target state="translated">Детали-фрагменты могут совпадать как с массивами фиксированного размера,так и с динамическими.</target>
        </trans-unit>
        <trans-unit id="e2a9b1a1f4c9d64f18dacb35757c94c4dba09de1" translate="yes" xml:space="preserve">
          <source>Slice types</source>
          <target state="translated">Типы срезов</target>
        </trans-unit>
        <trans-unit id="19695157734085157c78fbe17854f5408e269cc7" translate="yes" xml:space="preserve">
          <source>SliceConcatExt</source>
          <target state="translated">SliceConcatExt</target>
        </trans-unit>
        <trans-unit id="fa0533cad21e882e60e6470f5bbc433b34d70004" translate="yes" xml:space="preserve">
          <source>SliceConcatExt::concat</source>
          <target state="translated">SliceConcatExt::concat</target>
        </trans-unit>
        <trans-unit id="413a1df9b8364943cc23688168d5136007df7cd0" translate="yes" xml:space="preserve">
          <source>SliceConcatExt::connect</source>
          <target state="translated">SliceConcatExt::connect</target>
        </trans-unit>
        <trans-unit id="9785208fcb75d3242fa124a38e51980ffbd6d547" translate="yes" xml:space="preserve">
          <source>SliceConcatExt::join</source>
          <target state="translated">SliceConcatExt::join</target>
        </trans-unit>
        <trans-unit id="3e40446492e38511497e76ecb094b6028ead119a" translate="yes" xml:space="preserve">
          <source>SliceIndex</source>
          <target state="translated">SliceIndex</target>
        </trans-unit>
        <trans-unit id="6ce54ae25502325520f32754715055e196288255" translate="yes" xml:space="preserve">
          <source>SliceIndex::get</source>
          <target state="translated">SliceIndex::get</target>
        </trans-unit>
        <trans-unit id="572d3ba13df857766a6ae76c80fb65fabe4524e9" translate="yes" xml:space="preserve">
          <source>SliceIndex::get_mut</source>
          <target state="translated">SliceIndex::get_mut</target>
        </trans-unit>
        <trans-unit id="d0175e753163e484a6a27fba6d5bc114ef60ba17" translate="yes" xml:space="preserve">
          <source>SliceIndex::get_unchecked</source>
          <target state="translated">SliceIndex::get_unchecked</target>
        </trans-unit>
        <trans-unit id="f443fce2352caf6b4c8b798713f211deff2a2933" translate="yes" xml:space="preserve">
          <source>SliceIndex::get_unchecked_mut</source>
          <target state="translated">SliceIndex::get_unchecked_mut</target>
        </trans-unit>
        <trans-unit id="7916b515f5353dea5a33113689e5b4aeb6fc1a48" translate="yes" xml:space="preserve">
          <source>SliceIndex::index</source>
          <target state="translated">SliceIndex::index</target>
        </trans-unit>
        <trans-unit id="afb808e647e6e4fc8f460862d19066860e2d10b3" translate="yes" xml:space="preserve">
          <source>SliceIndex::index_mut</source>
          <target state="translated">SliceIndex::index_mut</target>
        </trans-unit>
        <trans-unit id="f144ad4093e39f92a8b125982226bc32f5fbad6c" translate="yes" xml:space="preserve">
          <source>Slices are a view into a block of memory represented as a pointer and a length.</source>
          <target state="translated">Слайзы-это вид в блок памяти,представленный в виде указателя и длины.</target>
        </trans-unit>
        <trans-unit id="92d46edfcdc60ce1b717ef56f1d122c47640c96a" translate="yes" xml:space="preserve">
          <source>Slices are also compared by their length (fat pointers):</source>
          <target state="translated">ломтики также сравниваются по длине (жировые указки):</target>
        </trans-unit>
        <trans-unit id="eca1373d0eca9016bccd6079114ae36016d11777" translate="yes" xml:space="preserve">
          <source>Slices are either mutable or shared. The shared slice type is &lt;code&gt;&amp;amp;[T]&lt;/code&gt;, while the mutable slice type is &lt;code&gt;&amp;amp;mut [T]&lt;/code&gt;, where &lt;code&gt;T&lt;/code&gt; represents the element type. For example, you can mutate the block of memory that a mutable slice points to:</source>
          <target state="translated">Срезы могут быть изменяемыми или общими. Тип общего фрагмента - &lt;code&gt;&amp;amp;[T]&lt;/code&gt; , а изменяемый тип фрагмента - &lt;code&gt;&amp;amp;mut [T]&lt;/code&gt; , где &lt;code&gt;T&lt;/code&gt; представляет тип элемента. Например, вы можете изменить блок памяти, на который указывает изменяемый фрагмент:</target>
        </trans-unit>
        <trans-unit id="399a28c583a0d46cb74512eb0c802ebe3fdcca4b" translate="yes" xml:space="preserve">
          <source>Slices can only be handled through some kind of &lt;em&gt;pointer&lt;/em&gt;, and as such come in many flavors such as:</source>
          <target state="translated">Срезы можно обрабатывать только с помощью какого-либо &lt;em&gt;указателя&lt;/em&gt; , и поэтому они бывают разных видов , например:</target>
        </trans-unit>
        <trans-unit id="78267e28e81cb8eb425db97c7c9bfe2fadd9598a" translate="yes" xml:space="preserve">
          <source>Slices have the same layout as the section of the array they slice.</source>
          <target state="translated">Фрагменты имеют такую же раскладку,как и секция массива,который они разрезают.</target>
        </trans-unit>
        <trans-unit id="0b8d3bff7b282e8424f968f9e948b9dc2006e7fb" translate="yes" xml:space="preserve">
          <source>Slicing</source>
          <target state="translated">Slicing</target>
        </trans-unit>
        <trans-unit id="6b5423b129b4d84874f0627bbd4fe8799ddf84f1" translate="yes" xml:space="preserve">
          <source>Slicing Strings</source>
          <target state="translated">Струны для нарезки</target>
        </trans-unit>
        <trans-unit id="fae28e1d5e9f8d8129325c2a7488d0feff194552" translate="yes" xml:space="preserve">
          <source>Slightly simplified, the relevant parts of &lt;code&gt;HashMap&amp;lt;K, V&amp;gt;&lt;/code&gt; look like this:</source>
          <target state="translated">Немного упрощенно соответствующие части &lt;code&gt;HashMap&amp;lt;K, V&amp;gt;&lt;/code&gt; выглядят так:</target>
        </trans-unit>
        <trans-unit id="1678b1d39516a61fe21f13e53c26f8494d328ac0" translate="yes" xml:space="preserve">
          <source>Small details, such as where &lt;code&gt;join&lt;/code&gt; is called, can affect whether or not your threads run at the same time.</source>
          <target state="translated">Небольшие детали, например, где вызывается &lt;code&gt;join&lt;/code&gt; , могут повлиять на то, будут ли ваши потоки выполняться одновременно.</target>
        </trans-unit>
        <trans-unit id="55ae7c282af0b63d2784182817786afd115171b8" translate="yes" xml:space="preserve">
          <source>Smallest finite &lt;code&gt;f32&lt;/code&gt; value.</source>
          <target state="translated">Наименьшее конечное значение &lt;code&gt;f32&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="31524bec0d990ed7e6e9cc110d97ce473f1f88ce" translate="yes" xml:space="preserve">
          <source>Smallest finite &lt;code&gt;f32&lt;/code&gt; value. Use &lt;a href=&quot;../primitive.f32#associatedconstant.MIN&quot;&gt;&lt;code&gt;f32::MIN&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3efc1f33cd5c2f54b38a7ec43b4874db20a71c8c" translate="yes" xml:space="preserve">
          <source>Smallest finite &lt;code&gt;f64&lt;/code&gt; value.</source>
          <target state="translated">Наименьшее конечное значение &lt;code&gt;f64&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0d8fa99bc9f9ec1346732091a253ada7c82f99ed" translate="yes" xml:space="preserve">
          <source>Smallest finite &lt;code&gt;f64&lt;/code&gt; value. Use &lt;a href=&quot;../primitive.f64#associatedconstant.MIN&quot;&gt;&lt;code&gt;f64::MIN&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="11079465374ccbdcd10e62557b51a729b8f92e19" translate="yes" xml:space="preserve">
          <source>Smallest positive normal &lt;code&gt;f32&lt;/code&gt; value.</source>
          <target state="translated">Наименьшее положительное нормальное значение &lt;code&gt;f32&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4f180b6c9245b0fb77d240d191cd241df88d0420" translate="yes" xml:space="preserve">
          <source>Smallest positive normal &lt;code&gt;f32&lt;/code&gt; value. Use &lt;a href=&quot;../primitive.f32#associatedconstant.MIN_POSITIVE&quot;&gt;&lt;code&gt;f32::MIN_POSITIVE&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3ff046c02ca4aa23e9ac84b74059747fa266f688" translate="yes" xml:space="preserve">
          <source>Smallest positive normal &lt;code&gt;f64&lt;/code&gt; value.</source>
          <target state="translated">Наименьшее положительное нормальное значение &lt;code&gt;f64&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0470031c3594b76ca12bbf0eedd86a185cf1662a" translate="yes" xml:space="preserve">
          <source>Smallest positive normal &lt;code&gt;f64&lt;/code&gt; value. Use &lt;a href=&quot;../primitive.f64#associatedconstant.MIN_POSITIVE&quot;&gt;&lt;code&gt;f64::MIN_POSITIVE&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2d0cbc1ceeeee81e325edc2271fdb116c132030c" translate="yes" xml:space="preserve">
          <source>Smart Pointers</source>
          <target state="translated">Умные указатели</target>
        </trans-unit>
        <trans-unit id="5966fa5e593332b4a5ba3c51105fe7097a2c40d7" translate="yes" xml:space="preserve">
          <source>Smart pointers are usually implemented using structs. The characteristic that distinguishes a smart pointer from an ordinary struct is that smart pointers implement the &lt;code&gt;Deref&lt;/code&gt; and &lt;code&gt;Drop&lt;/code&gt; traits. The &lt;code&gt;Deref&lt;/code&gt; trait allows an instance of the smart pointer struct to behave like a reference so you can write code that works with either references or smart pointers. The &lt;code&gt;Drop&lt;/code&gt; trait allows you to customize the code that is run when an instance of the smart pointer goes out of scope. In this chapter, we&amp;rsquo;ll discuss both traits and demonstrate why they&amp;rsquo;re important to smart pointers.</source>
          <target state="translated">Умные указатели обычно реализуются с использованием структур. Характеристика, которая отличает интеллектуальный указатель от обычной структуры, заключается в том, что интеллектуальные указатели реализуют черты &lt;code&gt;Deref&lt;/code&gt; и &lt;code&gt;Drop&lt;/code&gt; . &lt;code&gt;Deref&lt;/code&gt; черта позволяет экземпляр смарт - указатель структуры , чтобы вести себя как ссылки , так что вы можете написать код , который работает либо с ссылками или смарт - указатели. &lt;code&gt;Drop&lt;/code&gt; черта позволяет настроить код , который запускается , когда экземпляр смарт - указатель выходит из области видимости. В этой главе мы обсудим обе черты и покажем, почему они важны для интеллектуальных указателей.</target>
        </trans-unit>
        <trans-unit id="72d1aec640db40ccfdc35704271c9e066ad324a7" translate="yes" xml:space="preserve">
          <source>So &lt;code&gt;ref x&lt;/code&gt;, &lt;code&gt;V(ref x)&lt;/code&gt; and &lt;code&gt;[ref x, y]&lt;/code&gt; are all extending patterns, but &lt;code&gt;x&lt;/code&gt;, &lt;code&gt;&amp;amp;ref x&lt;/code&gt; and &lt;code&gt;&amp;amp;(ref x,)&lt;/code&gt; are not.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7fafb080819da713ce19c2d9024c6ed5ebb639bb" translate="yes" xml:space="preserve">
          <source>So although a &lt;code&gt;&amp;amp;T&lt;/code&gt; is a single value that stores the memory address of where the &lt;code&gt;T&lt;/code&gt; is located, a &lt;code&gt;&amp;amp;str&lt;/code&gt; is &lt;em&gt;two&lt;/em&gt; values: the address of the &lt;code&gt;str&lt;/code&gt; and its length. As such, we can know the size of a &lt;code&gt;&amp;amp;str&lt;/code&gt; value at compile time: it&amp;rsquo;s twice the length of a &lt;code&gt;usize&lt;/code&gt;. That is, we always know the size of a &lt;code&gt;&amp;amp;str&lt;/code&gt;, no matter how long the string it refers to is. In general, this is the way in which dynamically sized types are used in Rust: they have an extra bit of metadata that stores the size of the dynamic information. The golden rule of dynamically sized types is that we must always put values of dynamically sized types behind a pointer of some kind.</source>
          <target state="translated">Таким образом, хотя &lt;code&gt;&amp;amp;T&lt;/code&gt; - это единственное значение, в котором хранится адрес памяти, где находится &lt;code&gt;T&lt;/code&gt; , &lt;code&gt;&amp;amp;str&lt;/code&gt; - это &lt;em&gt;два&lt;/em&gt; значения: адрес &lt;code&gt;str&lt;/code&gt; и его длина. Таким образом, мы можем узнать размер значения &lt;code&gt;&amp;amp;str&lt;/code&gt; во время компиляции: это в два раза больше длины &lt;code&gt;usize&lt;/code&gt; . То есть мы всегда знаем размер &lt;code&gt;&amp;amp;str&lt;/code&gt; , независимо от длины строки, на которую он ссылается. В общем, именно так в Rust используются типы с динамическим размером: у них есть дополнительный бит метаданных, в которых хранится размер динамической информации. Золотое правило типов с динамическим размером состоит в том, что мы всегда должны помещать значения типов с динамическим размером за какой-либо указатель.</target>
        </trans-unit>
        <trans-unit id="c16bbee2a76d4ec726e1d72f7adeb6ec7f08a4b3" translate="yes" xml:space="preserve">
          <source>So far we&amp;rsquo;ve used only the most basic features of Cargo to build, run, and test our code, but it can do a lot more. In this chapter, we&amp;rsquo;ll discuss some of its other, more advanced features to show you how to do the following:</source>
          <target state="translated">До сих пор мы использовали только самые основные функции Cargo для сборки, запуска и тестирования нашего кода, но он может делать гораздо больше. В этой главе мы обсудим некоторые другие, более продвинутые функции, чтобы показать вам, как делать следующее:</target>
        </trans-unit>
        <trans-unit id="2fe8f00779014a1d9cc882174e66ad8f5580069b" translate="yes" xml:space="preserve">
          <source>So far we&amp;rsquo;ve worked only with numbers, but Rust supports letters too. Rust&amp;rsquo;s &lt;code&gt;char&lt;/code&gt; type is the language&amp;rsquo;s most primitive alphabetic type, and the following code shows one way to use it. (Note that &lt;code&gt;char&lt;/code&gt; literals are specified with single quotes, as opposed to string literals, which use double quotes.)</source>
          <target state="translated">Пока мы работали только с числами, но Rust поддерживает и буквы. Тип &lt;code&gt;char&lt;/code&gt; в Rust - это самый примитивный алфавитный тип языка, и следующий код показывает один из способов его использования. (Обратите внимание, что литералы &lt;code&gt;char&lt;/code&gt; указываются в одинарных кавычках, в отличие от строковых литералов, в которых используются двойные кавычки.)</target>
        </trans-unit>
        <trans-unit id="00aafa05a852a94e93631ef3de3a49f8b21ad2df" translate="yes" xml:space="preserve">
          <source>So far, all the examples in this chapter defined multiple modules in one file. When modules get large, you might want to move their definitions to a separate file to make the code easier to navigate.</source>
          <target state="translated">Пока все примеры в этой главе определяли несколько модулей в одном файле.Когда модули становятся большими,вы можете захотеть перенести их определения в отдельный файл,чтобы облегчить навигацию по коду.</target>
        </trans-unit>
        <trans-unit id="4ecfb53b194c3f5b057d9cda7a0b0656c0bbd71b" translate="yes" xml:space="preserve">
          <source>So far, we&amp;rsquo;ve demonstrated that calling &lt;code&gt;Rc::clone&lt;/code&gt; increases the &lt;code&gt;strong_count&lt;/code&gt; of an &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; instance, and an &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; instance is only cleaned up if its &lt;code&gt;strong_count&lt;/code&gt; is 0. You can also create a &lt;em&gt;weak reference&lt;/em&gt; to the value within an &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; instance by calling &lt;code&gt;Rc::downgrade&lt;/code&gt; and passing a reference to the &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt;. When you call &lt;code&gt;Rc::downgrade&lt;/code&gt;, you get a smart pointer of type &lt;code&gt;Weak&amp;lt;T&amp;gt;&lt;/code&gt;. Instead of increasing the &lt;code&gt;strong_count&lt;/code&gt; in the &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; instance by 1, calling &lt;code&gt;Rc::downgrade&lt;/code&gt; increases the &lt;code&gt;weak_count&lt;/code&gt; by 1. The &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; type uses &lt;code&gt;weak_count&lt;/code&gt; to keep track of how many &lt;code&gt;Weak&amp;lt;T&amp;gt;&lt;/code&gt; references exist, similar to &lt;code&gt;strong_count&lt;/code&gt;. The difference is the &lt;code&gt;weak_count&lt;/code&gt; doesn&amp;rsquo;t need to be 0 for the &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; instance to be cleaned up.</source>
          <target state="translated">До сих пор, мы показали , что вызов &lt;code&gt;Rc::clone&lt;/code&gt; увеличивает &lt;code&gt;strong_count&lt;/code&gt; в качестве &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; , например, и &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; экземпляр только очищается, если ее &lt;code&gt;strong_count&lt;/code&gt; 0. Вы также можете создать &lt;em&gt;слабую ссылку&lt;/em&gt; к значение в экземпляре &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; путем вызова &lt;code&gt;Rc::downgrade&lt;/code&gt; и передачи ссылки на &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; . Когда вы вызываете &lt;code&gt;Rc::downgrade&lt;/code&gt; , вы получаете умный указатель типа &lt;code&gt;Weak&amp;lt;T&amp;gt;&lt;/code&gt; . Вместо увеличения &lt;code&gt;strong_count&lt;/code&gt; в экземпляре &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; на 1, вызов &lt;code&gt;Rc::downgrade&lt;/code&gt; увеличивает &lt;code&gt;weak_count&lt;/code&gt; на 1. Тип &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; использует &lt;code&gt;weak_count&lt;/code&gt; для отслеживания количества существующих ссылок &lt;code&gt;Weak&amp;lt;T&amp;gt;&lt;/code&gt; , аналогично &lt;code&gt;strong_count&lt;/code&gt; . Разница в том, что &lt;code&gt;weak_count&lt;/code&gt; не обязательно должен быть 0, чтобы экземпляр &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; был очищен.</target>
        </trans-unit>
        <trans-unit id="5d415f69b7962c9c2a42c33ce1eada2a42f0bbd5" translate="yes" xml:space="preserve">
          <source>So far, we&amp;rsquo;ve extracted the logic responsible for parsing the command line arguments from &lt;code&gt;main&lt;/code&gt; and placed it in the &lt;code&gt;parse_config&lt;/code&gt; function. Doing so helped us to see that the &lt;code&gt;query&lt;/code&gt; and &lt;code&gt;filename&lt;/code&gt; values were related and that relationship should be conveyed in our code. We then added a &lt;code&gt;Config&lt;/code&gt; struct to name the related purpose of &lt;code&gt;query&lt;/code&gt; and &lt;code&gt;filename&lt;/code&gt; and to be able to return the values&amp;rsquo; names as struct field names from the &lt;code&gt;parse_config&lt;/code&gt; function.</source>
          <target state="translated">До сих пор мы извлекли из &lt;code&gt;main&lt;/code&gt; логику, отвечающую за анализ аргументов командной строки, и поместили ее в функцию &lt;code&gt;parse_config&lt;/code&gt; . Это помогло нам увидеть, что значения &lt;code&gt;query&lt;/code&gt; и &lt;code&gt;filename&lt;/code&gt; связаны, и эту связь следует передать в нашем коде. Затем мы добавили структуру &lt;code&gt;Config&lt;/code&gt; , чтобы указать связанную цель &lt;code&gt;query&lt;/code&gt; и &lt;code&gt;filename&lt;/code&gt; и иметь возможность возвращать имена значений как имена полей структуры из функции &lt;code&gt;parse_config&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="31792465eea309944f93175f35f9662ee847ff84" translate="yes" xml:space="preserve">
          <source>So far, we&amp;rsquo;ve only defined structs to hold owned types. It&amp;rsquo;s possible for structs to hold references, but in that case we would need to add a lifetime annotation on every reference in the struct&amp;rsquo;s definition. Listing 10-25 has a struct named &lt;code&gt;ImportantExcerpt&lt;/code&gt; that holds a string slice.</source>
          <target state="translated">До сих пор мы определили только структуры для хранения принадлежащих типов. Структуры могут содержать ссылки, но в этом случае нам нужно будет добавить аннотацию времени жизни к каждой ссылке в определении структуры. В листинге 10-25 есть структура с именем &lt;code&gt;ImportantExcerpt&lt;/code&gt; , которая содержит фрагмент строки.</target>
        </trans-unit>
        <trans-unit id="5e4c617f5787ec277cad1062392545472df08030" translate="yes" xml:space="preserve">
          <source>So far, we&amp;rsquo;ve written tests that panic when they fail. We can also write tests that use &lt;code&gt;Result&amp;lt;T, E&amp;gt;&lt;/code&gt;! Here&amp;rsquo;s the test from Listing 11-1, rewritten to use &lt;code&gt;Result&amp;lt;T, E&amp;gt;&lt;/code&gt; and return an &lt;code&gt;Err&lt;/code&gt; instead of panicking:</source>
          <target state="translated">До сих пор мы писали тесты, которые вызывают панику, когда они терпят неудачу. Мы также можем писать тесты, использующие &lt;code&gt;Result&amp;lt;T, E&amp;gt;&lt;/code&gt; ! Вот тест из Листинга 11-1, переписанный для использования &lt;code&gt;Result&amp;lt;T, E&amp;gt;&lt;/code&gt; и возврата &lt;code&gt;Err&lt;/code&gt; вместо паники:</target>
        </trans-unit>
        <trans-unit id="c8622855d6f00ed43ee6c71fb4080061585e00e0" translate="yes" xml:space="preserve">
          <source>So for example there is a &lt;a href=&quot;primitive.i32&quot;&gt;page for the primitive type &lt;code&gt;i32&lt;/code&gt;&lt;/a&gt; that lists all the methods that can be called on 32-bit integers (very useful), and there is a &lt;a href=&quot;i32/index&quot;&gt;page for the module &lt;code&gt;std::i32&lt;/code&gt;&lt;/a&gt; that documents the constant values &lt;a href=&quot;i32/constant.min&quot;&gt;&lt;code&gt;MIN&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;i32/constant.max&quot;&gt;&lt;code&gt;MAX&lt;/code&gt;&lt;/a&gt; (rarely useful).</source>
          <target state="translated">Так, например, есть &lt;a href=&quot;primitive.i32&quot;&gt;страница для примитивного типа &lt;code&gt;i32&lt;/code&gt; ,на&lt;/a&gt; которой перечислены все методы, которые могут быть вызваны для 32-битных целых чисел (очень полезно), а также есть &lt;a href=&quot;i32/index&quot;&gt;страница для модуля &lt;code&gt;std::i32&lt;/code&gt; &lt;/a&gt; которая документирует значения констант &lt;a href=&quot;i32/constant.min&quot;&gt; &lt;code&gt;MIN&lt;/code&gt; &lt;/a&gt; и &lt;a href=&quot;i32/constant.max&quot;&gt; &lt;code&gt;MAX&lt;/code&gt; &lt;/a&gt; (редко бывает полезным).</target>
        </trans-unit>
        <trans-unit id="2555bdc669f18a60939e157232ea5e5688ffc8a7" translate="yes" xml:space="preserve">
          <source>So for the first solution, you can do it by replacing &lt;code&gt;'a&lt;/code&gt; with &lt;code&gt;'a: 'b&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ab510d0df8ff03139c6bde1653955915d7b63d9c" translate="yes" xml:space="preserve">
          <source>So how do we get a published post? We want to enforce the rule that a draft post has to be reviewed and approved before it can be published. A post in the pending review state should still not display any content. Let&amp;rsquo;s implement these constraints by adding another struct, &lt;code&gt;PendingReviewPost&lt;/code&gt;, defining the &lt;code&gt;request_review&lt;/code&gt; method on &lt;code&gt;DraftPost&lt;/code&gt; to return a &lt;code&gt;PendingReviewPost&lt;/code&gt;, and defining an &lt;code&gt;approve&lt;/code&gt; method on &lt;code&gt;PendingReviewPost&lt;/code&gt; to return a &lt;code&gt;Post&lt;/code&gt;, as shown in Listing 17-20:</source>
          <target state="translated">Так как же получить опубликованный пост? Мы хотим обеспечить соблюдение правила, согласно которому черновик сообщения должен быть просмотрен и одобрен перед публикацией. Сообщение в состоянии ожидания проверки не должно отображать никакого содержания. Давайте реализуем эти ограничения, добавив другую структуру, &lt;code&gt;PendingReviewPost&lt;/code&gt; , определив метод &lt;code&gt;request_review&lt;/code&gt; в &lt;code&gt;DraftPost&lt;/code&gt; для возврата &lt;code&gt;PendingReviewPost&lt;/code&gt; и определив метод &lt;code&gt;approve&lt;/code&gt; в &lt;code&gt;PendingReviewPost&lt;/code&gt; для возврата &lt;code&gt;Post&lt;/code&gt; , как показано в листинге 17-20:</target>
        </trans-unit>
        <trans-unit id="41cfc4a146acbbdc3e7cbb1dc74c09ee0aee7f91" translate="yes" xml:space="preserve">
          <source>So how do you decide when you should call &lt;code&gt;panic!&lt;/code&gt; and when you should return &lt;code&gt;Result&lt;/code&gt;? When code panics, there&amp;rsquo;s no way to recover. You could call &lt;code&gt;panic!&lt;/code&gt; for any error situation, whether there&amp;rsquo;s a possible way to recover or not, but then you&amp;rsquo;re making the decision on behalf of the code calling your code that a situation is unrecoverable. When you choose to return a &lt;code&gt;Result&lt;/code&gt; value, you give the calling code options rather than making the decision for it. The calling code could choose to attempt to recover in a way that&amp;rsquo;s appropriate for its situation, or it could decide that an &lt;code&gt;Err&lt;/code&gt; value in this case is unrecoverable, so it can call &lt;code&gt;panic!&lt;/code&gt; and turn your recoverable error into an unrecoverable one. Therefore, returning &lt;code&gt;Result&lt;/code&gt; is a good default choice when you&amp;rsquo;re defining a function that might fail.</source>
          <target state="translated">Так как же решить, когда следует вызывать &lt;code&gt;panic!&lt;/code&gt; а когда тебе надо вернуть &lt;code&gt;Result&lt;/code&gt; ? Когда код паникует, восстановления нет. Вы можете вызвать &lt;code&gt;panic!&lt;/code&gt; для любой ситуации с ошибкой, независимо от того, есть ли способ восстановления или нет, но затем вы принимаете решение от имени кода, вызывающего ваш код, что ситуацию невозможно исправить. Когда вы решаете вернуть значение &lt;code&gt;Result&lt;/code&gt; , вы предоставляете параметры вызывающего кода, а не принимаете решение. Вызывающий код может выбрать попытку восстановления способом, который подходит для его ситуации, или может решить, что значение &lt;code&gt;Err&lt;/code&gt; в этом случае невозможно восстановить, поэтому он может вызвать &lt;code&gt;panic!&lt;/code&gt; и превратите вашу исправляемую ошибку в неустранимую. Следовательно, возвращение &lt;code&gt;Result&lt;/code&gt; - хороший выбор по умолчанию, когда вы определяете функцию, которая может дать сбой.</target>
        </trans-unit>
        <trans-unit id="7bee6cab338aeb3ff333063f830e83a375530ced" translate="yes" xml:space="preserve">
          <source>So how do you know which type of integer to use? If you&amp;rsquo;re unsure, Rust&amp;rsquo;s defaults are generally good choices, and integer types default to &lt;code&gt;i32&lt;/code&gt;: this type is generally the fastest, even on 64-bit systems. The primary situation in which you&amp;rsquo;d use &lt;code&gt;isize&lt;/code&gt; or &lt;code&gt;usize&lt;/code&gt; is when indexing some sort of collection.</source>
          <target state="translated">Итак, как узнать, какой тип целого числа использовать? Если вы не уверены, значения по умолчанию для Rust, как правило, являются хорошим выбором, а для целочисленных типов по умолчанию используется &lt;code&gt;i32&lt;/code&gt; : этот тип обычно самый быстрый, даже в 64-битных системах. Основная ситуация, в которой вы бы использовали &lt;code&gt;isize&lt;/code&gt; или &lt;code&gt;usize&lt;/code&gt; , - это индексирование какой-либо коллекции.</target>
        </trans-unit>
        <trans-unit id="ff2c62bc2f0b0ef57e58a2f6531efebdcbc69010" translate="yes" xml:space="preserve">
          <source>So how do you learn about these new features? Rust&amp;rsquo;s development model follows a &lt;em&gt;Request For Comments (RFC) process&lt;/em&gt;. If you&amp;rsquo;d like an improvement in Rust, you can write up a proposal, called an RFC.</source>
          <target state="translated">Так как же узнать об этих новых функциях? Модель разработки Rust следует &lt;em&gt;процессу запроса комментариев (RFC)&lt;/em&gt; . Если вы хотите улучшить Rust, вы можете написать предложение, которое называется RFC.</target>
        </trans-unit>
        <trans-unit id="a431eb6b7f65a188b9084e0b248314b342aef52a" translate="yes" xml:space="preserve">
          <source>So instead of &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt;, we&amp;rsquo;ll make the type of &lt;code&gt;parent&lt;/code&gt; use &lt;code&gt;Weak&amp;lt;T&amp;gt;&lt;/code&gt;, specifically a &lt;code&gt;RefCell&amp;lt;Weak&amp;lt;Node&amp;gt;&amp;gt;&lt;/code&gt;. Now our &lt;code&gt;Node&lt;/code&gt; struct definition looks like this:</source>
          <target state="translated">Поэтому вместо &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; мы заставим тип &lt;code&gt;parent&lt;/code&gt; использовать &lt;code&gt;Weak&amp;lt;T&amp;gt;&lt;/code&gt; , в частности &lt;code&gt;RefCell&amp;lt;Weak&amp;lt;Node&amp;gt;&amp;gt;&lt;/code&gt; . Теперь определение нашей структуры &lt;code&gt;Node&lt;/code&gt; выглядит так:</target>
        </trans-unit>
        <trans-unit id="a3d7c32f4a97177e667e63247652c2041a2a6cb0" translate="yes" xml:space="preserve">
          <source>So long as &lt;code&gt;T: Sized&lt;/code&gt;, a &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; is guaranteed to be represented as a single pointer and is also ABI-compatible with C pointers (i.e. the C type &lt;code&gt;T*&lt;/code&gt;). This means that if you have extern &quot;C&quot; Rust functions that will be called from C, you can define those Rust functions using &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; types, and use &lt;code&gt;T*&lt;/code&gt; as corresponding type on the C side. As an example, consider this C header which declares functions that create and destroy some kind of &lt;code&gt;Foo&lt;/code&gt; value:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e7d94a46d4c8df2f4221ca14314326a2bd0b53cc" translate="yes" xml:space="preserve">
          <source>So now that the purpose of the &lt;code&gt;parse_config&lt;/code&gt; function is to create a &lt;code&gt;Config&lt;/code&gt; instance, we can change &lt;code&gt;parse_config&lt;/code&gt; from a plain function to a function named &lt;code&gt;new&lt;/code&gt; that is associated with the &lt;code&gt;Config&lt;/code&gt; struct. Making this change will make the code more idiomatic. We can create instances of types in the standard library, such as &lt;code&gt;String&lt;/code&gt;, by calling &lt;code&gt;String::new&lt;/code&gt;. Similarly, by changing &lt;code&gt;parse_config&lt;/code&gt; into a &lt;code&gt;new&lt;/code&gt; function associated with &lt;code&gt;Config&lt;/code&gt;, we&amp;rsquo;ll be able to create instances of &lt;code&gt;Config&lt;/code&gt; by calling &lt;code&gt;Config::new&lt;/code&gt;. Listing 12-7 shows the changes we need to make.</source>
          <target state="translated">Итак, теперь, когда целью функции &lt;code&gt;parse_config&lt;/code&gt; является создание экземпляра &lt;code&gt;Config&lt;/code&gt; , мы можем изменить &lt;code&gt;parse_config&lt;/code&gt; с простой функции на функцию с именем &lt;code&gt;new&lt;/code&gt; , которая связана со структурой &lt;code&gt;Config&lt;/code&gt; . Внесение этого изменения сделает код более идиоматичным. Мы можем создавать экземпляры типов в стандартной библиотеке, например &lt;code&gt;String&lt;/code&gt; , вызывая &lt;code&gt;String::new&lt;/code&gt; . Точно так же, изменив &lt;code&gt;parse_config&lt;/code&gt; на &lt;code&gt;new&lt;/code&gt; функцию, связанную с &lt;code&gt;Config&lt;/code&gt; , мы сможем создавать экземпляры &lt;code&gt;Config&lt;/code&gt; , вызывая &lt;code&gt;Config::new&lt;/code&gt; . В листинге 12-7 показаны изменения, которые нам необходимо внести.</target>
        </trans-unit>
        <trans-unit id="bf87019d2ee31b20bd27453a9815c39765179193" translate="yes" xml:space="preserve">
          <source>So the borrow expressions in &lt;code&gt;&amp;amp;mut 0&lt;/code&gt;, &lt;code&gt;(&amp;amp;1, &amp;amp;mut 2)&lt;/code&gt;, and &lt;code&gt;Some { 0: &amp;amp;mut 3 }&lt;/code&gt; are all extending expressions. The borrows in &lt;code&gt;&amp;amp;0 + &amp;amp;1&lt;/code&gt; and &lt;code&gt;Some(&amp;amp;mut 0)&lt;/code&gt; are not: the latter is syntactically a function call expression.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f074b0771df976fb716af57669f38fc08493992b" translate="yes" xml:space="preserve">
          <source>So this, for example, can only be done on types implementing &lt;code&gt;Unpin&lt;/code&gt;:</source>
          <target state="translated">Так, например, это можно сделать только для типов, реализующих &lt;code&gt;Unpin&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="66c66bb788c3f0aec3e67d69032df19434a61113" translate="yes" xml:space="preserve">
          <source>So to fix the previous code example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7e77e163b0a6f38404491eda0a512dc9b1b67ed8" translate="yes" xml:space="preserve">
          <source>So we know we want to update the definition of &lt;code&gt;Worker&lt;/code&gt; like this:</source>
          <target state="translated">Итак, мы знаем, что хотим обновить определение &lt;code&gt;Worker&lt;/code&gt; следующим образом:</target>
        </trans-unit>
        <trans-unit id="f4be5fd758b3b88db54e58e5c1f6997e8740355a" translate="yes" xml:space="preserve">
          <source>So what do we do? In this case, you already know the answer: we make the types of &lt;code&gt;s1&lt;/code&gt; and &lt;code&gt;s2&lt;/code&gt; a &lt;code&gt;&amp;amp;str&lt;/code&gt; rather than a &lt;code&gt;str&lt;/code&gt;. Recall that in the &lt;a href=&quot;ch04-03-slices#string-slices&quot;&gt;&amp;ldquo;String Slices&amp;rdquo;&lt;/a&gt; section of Chapter 4, we said the slice data structure stores the starting position and the length of the slice.</source>
          <target state="translated">Так что же нам делать? В этом случае вы уже знаете ответ: мы делаем типы &lt;code&gt;s1&lt;/code&gt; и &lt;code&gt;s2&lt;/code&gt; a &lt;code&gt;&amp;amp;str&lt;/code&gt; а не &lt;code&gt;str&lt;/code&gt; . Напомним, что в разделе &lt;a href=&quot;ch04-03-slices#string-slices&quot;&gt;&amp;laquo;Строковые фрагменты&amp;raquo;&lt;/a&gt; главы 4 мы сказали, что структура данных среза хранит начальную позицию и длину среза.</target>
        </trans-unit>
        <trans-unit id="c32c5415e3271d676a4ba9d1e43c6961dc8eb8d5" translate="yes" xml:space="preserve">
          <source>So what happens if we try to modify something we&amp;rsquo;re borrowing? Try the code in Listing 4-6. Spoiler alert: it doesn&amp;rsquo;t work!</source>
          <target state="translated">Так что же произойдет, если мы попытаемся изменить то, что заимствуем? Попробуйте код из листинга 4-6. Спойлер: не работает!</target>
        </trans-unit>
        <trans-unit id="6ad1c29cb1977f541537e5923d038a2f846397f6" translate="yes" xml:space="preserve">
          <source>So what types are &lt;code&gt;Copy&lt;/code&gt;? You can check the documentation for the given type to be sure, but as a general rule, any group of simple scalar values can be &lt;code&gt;Copy&lt;/code&gt;, and nothing that requires allocation or is some form of resource is &lt;code&gt;Copy&lt;/code&gt;. Here are some of the types that are &lt;code&gt;Copy&lt;/code&gt;:</source>
          <target state="translated">Итак, какие типы &lt;code&gt;Copy&lt;/code&gt; ? Вы можете проверить документацию для данного типа, чтобы быть уверенным, но, как правило, любая группа простых скалярных значений может быть &lt;code&gt;Copy&lt;/code&gt; , и ничего, что требует выделения или является какой-либо формой ресурса, является &lt;code&gt;Copy&lt;/code&gt; . Вот некоторые из типов &lt;code&gt;Copy&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="e7d596654860b048147570b1da4292f50a003e3c" translate="yes" xml:space="preserve">
          <source>So, for example, the following is not allowed:</source>
          <target state="translated">Так,например,следующее не разрешено:</target>
        </trans-unit>
        <trans-unit id="8972432c4affa16f8f98b7b09f7f4b89c9affbb9" translate="yes" xml:space="preserve">
          <source>So, how do you get the &lt;code&gt;T&lt;/code&gt; value out of a &lt;code&gt;Some&lt;/code&gt; variant when you have a value of type &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt; so you can use that value? The &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt; enum has a large number of methods that are useful in a variety of situations; you can check them out in &lt;a href=&quot;../std/option/enum.option&quot;&gt;its documentation&lt;/a&gt;. Becoming familiar with the methods on &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt; will be extremely useful in your journey with Rust.</source>
          <target state="translated">Итак, как получить значение &lt;code&gt;T&lt;/code&gt; из варианта &lt;code&gt;Some&lt;/code&gt; , если у вас есть значение типа &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt; чтобы вы могли использовать это значение? &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt; перечисление имеет большое количество методов, которые полезны в различных ситуациях; вы можете проверить их в &lt;a href=&quot;../std/option/enum.option&quot;&gt;документации&lt;/a&gt; . Знакомство с методами &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt; будет чрезвычайно полезным в вашем путешествии с Rust.</target>
        </trans-unit>
        <trans-unit id="6054892d83d4ff63740ad87325aa1edbc9c2ed83" translate="yes" xml:space="preserve">
          <source>So, in order to solve this error, either use statics which are &lt;code&gt;Sync&lt;/code&gt;:</source>
          <target state="translated">Итак, чтобы решить эту ошибку, используйте статику &lt;code&gt;Sync&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="3efb8fcaca7cf44d29993d4584dcd65be6752ad8" translate="yes" xml:space="preserve">
          <source>So, what&amp;rsquo;s the difference here? Why can &lt;code&gt;String&lt;/code&gt; be mutated but literals cannot? The difference is how these two types deal with memory.</source>
          <target state="translated">Итак, какая здесь разница? Почему &lt;code&gt;String&lt;/code&gt; можно изменять, а литералы - нет? Разница в том, как эти два типа работают с памятью.</target>
        </trans-unit>
        <trans-unit id="982f4e650d509676fd2fc1befb07f1f97185e427" translate="yes" xml:space="preserve">
          <source>SocketAddr</source>
          <target state="translated">SocketAddr</target>
        </trans-unit>
        <trans-unit id="7b76e6fef13b8c151a69cc1489b6030db22c8df5" translate="yes" xml:space="preserve">
          <source>SocketAddr::borrow</source>
          <target state="translated">SocketAddr::borrow</target>
        </trans-unit>
        <trans-unit id="05e5c4f99fe9e01eb67955d1e0c15c5de404bc09" translate="yes" xml:space="preserve">
          <source>SocketAddr::borrow_mut</source>
          <target state="translated">SocketAddr::borrow_mut</target>
        </trans-unit>
        <trans-unit id="10b9b6dd1dca90bba53547883240ba388344d678" translate="yes" xml:space="preserve">
          <source>SocketAddr::clone</source>
          <target state="translated">SocketAddr::clone</target>
        </trans-unit>
        <trans-unit id="7e82ae1ad37713c7946ec73ae8e4a4b129b91b5d" translate="yes" xml:space="preserve">
          <source>SocketAddr::clone_from</source>
          <target state="translated">SocketAddr::clone_from</target>
        </trans-unit>
        <trans-unit id="fa9172cd6e3157231bd216e413365c39529dcb5b" translate="yes" xml:space="preserve">
          <source>SocketAddr::clone_into</source>
          <target state="translated">SocketAddr::clone_into</target>
        </trans-unit>
        <trans-unit id="8c755b826cc428e128fb193cc9198929fc151997" translate="yes" xml:space="preserve">
          <source>SocketAddr::eq</source>
          <target state="translated">SocketAddr::eq</target>
        </trans-unit>
        <trans-unit id="7eea75763a3736da07cda2f6f9a742ff5cc2508b" translate="yes" xml:space="preserve">
          <source>SocketAddr::fmt</source>
          <target state="translated">SocketAddr::fmt</target>
        </trans-unit>
        <trans-unit id="9746b01dbeb72b517f1582ab0ba63bf19762561d" translate="yes" xml:space="preserve">
          <source>SocketAddr::from</source>
          <target state="translated">SocketAddr::from</target>
        </trans-unit>
        <trans-unit id="7bab699fce83466661a1331294a6a61fffdb12c0" translate="yes" xml:space="preserve">
          <source>SocketAddr::from_str</source>
          <target state="translated">SocketAddr::from_str</target>
        </trans-unit>
        <trans-unit id="d0abc27d9ac8e920ff65d558ec4fab556aeb72f0" translate="yes" xml:space="preserve">
          <source>SocketAddr::hash</source>
          <target state="translated">SocketAddr::hash</target>
        </trans-unit>
        <trans-unit id="57f9440e0b1557e8a687b6cbbe68aebc372b810d" translate="yes" xml:space="preserve">
          <source>SocketAddr::hash_slice</source>
          <target state="translated">SocketAddr::hash_slice</target>
        </trans-unit>
        <trans-unit id="359dc56742e672e37102044d1a5837358b05c259" translate="yes" xml:space="preserve">
          <source>SocketAddr::into</source>
          <target state="translated">SocketAddr::into</target>
        </trans-unit>
        <trans-unit id="a72bff1fc4a8d70b73e024e3e77a5a7e15b3d8ef" translate="yes" xml:space="preserve">
          <source>SocketAddr::ip</source>
          <target state="translated">SocketAddr::ip</target>
        </trans-unit>
        <trans-unit id="df313c9acddcd250f8a5dd524b4694a23c721582" translate="yes" xml:space="preserve">
          <source>SocketAddr::is_ipv4</source>
          <target state="translated">SocketAddr::is_ipv4</target>
        </trans-unit>
        <trans-unit id="724fde3cc837842047612e83a0b060b424072291" translate="yes" xml:space="preserve">
          <source>SocketAddr::is_ipv6</source>
          <target state="translated">SocketAddr::is_ipv6</target>
        </trans-unit>
        <trans-unit id="b48285083c13b1d25e0fd32d224dd7224d4b5713" translate="yes" xml:space="preserve">
          <source>SocketAddr::ne</source>
          <target state="translated">SocketAddr::ne</target>
        </trans-unit>
        <trans-unit id="97b42db1f2e774c922a5711eb4bd452eb11e4a7a" translate="yes" xml:space="preserve">
          <source>SocketAddr::new</source>
          <target state="translated">SocketAddr::new</target>
        </trans-unit>
        <trans-unit id="f69565f34ef1fada1cb2f0d63fc92ba0efa235b9" translate="yes" xml:space="preserve">
          <source>SocketAddr::port</source>
          <target state="translated">SocketAddr::port</target>
        </trans-unit>
        <trans-unit id="774b4e1f005f22ee8c0b028c287f01dbea22e030" translate="yes" xml:space="preserve">
          <source>SocketAddr::set_ip</source>
          <target state="translated">SocketAddr::set_ip</target>
        </trans-unit>
        <trans-unit id="bec32854bf21e824a4fa9a0d7b44db616df52318" translate="yes" xml:space="preserve">
          <source>SocketAddr::set_port</source>
          <target state="translated">SocketAddr::set_port</target>
        </trans-unit>
        <trans-unit id="fe4346a026d7ffb567366d36af1b79417d962103" translate="yes" xml:space="preserve">
          <source>SocketAddr::to_owned</source>
          <target state="translated">SocketAddr::to_owned</target>
        </trans-unit>
        <trans-unit id="7b71632e29ab8b9a928be8a15d7afca736749a51" translate="yes" xml:space="preserve">
          <source>SocketAddr::to_socket_addrs</source>
          <target state="translated">SocketAddr::to_socket_addrs</target>
        </trans-unit>
        <trans-unit id="4f6b5c00f68c140936e9f3f32ee6059cc024fad4" translate="yes" xml:space="preserve">
          <source>SocketAddr::to_string</source>
          <target state="translated">SocketAddr::to_string</target>
        </trans-unit>
        <trans-unit id="c6ca6f5af2b971219538a2091097aaa41b1dc436" translate="yes" xml:space="preserve">
          <source>SocketAddr::try_from</source>
          <target state="translated">SocketAddr::try_from</target>
        </trans-unit>
        <trans-unit id="716746fffcc0460fa5b5b7b39b39fed16701c2d4" translate="yes" xml:space="preserve">
          <source>SocketAddr::try_into</source>
          <target state="translated">SocketAddr::try_into</target>
        </trans-unit>
        <trans-unit id="d4f1c48b673e9c03d6894ddac4a6f76e75db3196" translate="yes" xml:space="preserve">
          <source>SocketAddr::type_id</source>
          <target state="translated">SocketAddr::type_id</target>
        </trans-unit>
        <trans-unit id="2e411fdc7242c1962d9bdc180a582206cc8b1d30" translate="yes" xml:space="preserve">
          <source>SocketAddrV4</source>
          <target state="translated">SocketAddrV4</target>
        </trans-unit>
        <trans-unit id="75e3b74af97586957cb6bbcbf99b5e8d1adde136" translate="yes" xml:space="preserve">
          <source>SocketAddrV4::borrow</source>
          <target state="translated">SocketAddrV4::borrow</target>
        </trans-unit>
        <trans-unit id="4d361b6e156dc3dfb56ca0e8e0dc4e0a5b168d12" translate="yes" xml:space="preserve">
          <source>SocketAddrV4::borrow_mut</source>
          <target state="translated">SocketAddrV4::borrow_mut</target>
        </trans-unit>
        <trans-unit id="a1fd56f672c607cb9273c197c816a7a4e2905e2a" translate="yes" xml:space="preserve">
          <source>SocketAddrV4::clone</source>
          <target state="translated">SocketAddrV4::clone</target>
        </trans-unit>
        <trans-unit id="3a37da63ee2c37711495f1eebc7170e9d20c2609" translate="yes" xml:space="preserve">
          <source>SocketAddrV4::clone_from</source>
          <target state="translated">SocketAddrV4::clone_from</target>
        </trans-unit>
        <trans-unit id="eb0a32006835b5434f6c3ba39cf20d627c257026" translate="yes" xml:space="preserve">
          <source>SocketAddrV4::clone_into</source>
          <target state="translated">SocketAddrV4::clone_into</target>
        </trans-unit>
        <trans-unit id="c1b4fe28184db8300439d430dc3c94116411c119" translate="yes" xml:space="preserve">
          <source>SocketAddrV4::eq</source>
          <target state="translated">SocketAddrV4::eq</target>
        </trans-unit>
        <trans-unit id="5304bbfe77b1b3ff9948bed9e44e2ba835bc1752" translate="yes" xml:space="preserve">
          <source>SocketAddrV4::fmt</source>
          <target state="translated">SocketAddrV4::fmt</target>
        </trans-unit>
        <trans-unit id="ba7642e89ba5ff37a9528b98decffb956584dd07" translate="yes" xml:space="preserve">
          <source>SocketAddrV4::from</source>
          <target state="translated">SocketAddrV4::from</target>
        </trans-unit>
        <trans-unit id="d54305f480b5f9920ddea513082584583ab11f04" translate="yes" xml:space="preserve">
          <source>SocketAddrV4::from_str</source>
          <target state="translated">SocketAddrV4::from_str</target>
        </trans-unit>
        <trans-unit id="a61d7b0786ad97e5ccdc2d9753e797a4e92ceab5" translate="yes" xml:space="preserve">
          <source>SocketAddrV4::hash</source>
          <target state="translated">SocketAddrV4::hash</target>
        </trans-unit>
        <trans-unit id="36cdd68ef7364910489bb755ad11d3244886227e" translate="yes" xml:space="preserve">
          <source>SocketAddrV4::hash_slice</source>
          <target state="translated">SocketAddrV4::hash_slice</target>
        </trans-unit>
        <trans-unit id="265192c0953c9652e01d051111cd4c4e244a073a" translate="yes" xml:space="preserve">
          <source>SocketAddrV4::into</source>
          <target state="translated">SocketAddrV4::into</target>
        </trans-unit>
        <trans-unit id="bcc9b01a8b6ac6bf9cb18abecd80c612d96f295a" translate="yes" xml:space="preserve">
          <source>SocketAddrV4::ip</source>
          <target state="translated">SocketAddrV4::ip</target>
        </trans-unit>
        <trans-unit id="5c7bb0a2c9ab349475d12c0f3a7876c8313171b3" translate="yes" xml:space="preserve">
          <source>SocketAddrV4::ne</source>
          <target state="translated">SocketAddrV4::ne</target>
        </trans-unit>
        <trans-unit id="7648d57b2179c40c2995d5dcef0f39436334e915" translate="yes" xml:space="preserve">
          <source>SocketAddrV4::new</source>
          <target state="translated">SocketAddrV4::new</target>
        </trans-unit>
        <trans-unit id="34fa3c9cd9b21d78c26a87925462b3a1f0dd159a" translate="yes" xml:space="preserve">
          <source>SocketAddrV4::port</source>
          <target state="translated">SocketAddrV4::port</target>
        </trans-unit>
        <trans-unit id="6b1645a03590fa2c425bcd5e3d55a48fe687747b" translate="yes" xml:space="preserve">
          <source>SocketAddrV4::set_ip</source>
          <target state="translated">SocketAddrV4::set_ip</target>
        </trans-unit>
        <trans-unit id="442bc9fb004c3435d748d287fb4e657d12819afc" translate="yes" xml:space="preserve">
          <source>SocketAddrV4::set_port</source>
          <target state="translated">SocketAddrV4::set_port</target>
        </trans-unit>
        <trans-unit id="f94c8e8bc5e342413fde74ba98069b330530abe5" translate="yes" xml:space="preserve">
          <source>SocketAddrV4::to_owned</source>
          <target state="translated">SocketAddrV4::to_owned</target>
        </trans-unit>
        <trans-unit id="4c076e0e279fcac5fe930bd7f231dc463c4af910" translate="yes" xml:space="preserve">
          <source>SocketAddrV4::to_socket_addrs</source>
          <target state="translated">SocketAddrV4::to_socket_addrs</target>
        </trans-unit>
        <trans-unit id="50b24a72ad9bcf56ea6d4dfc00a1cc1f4ae545d2" translate="yes" xml:space="preserve">
          <source>SocketAddrV4::to_string</source>
          <target state="translated">SocketAddrV4::to_string</target>
        </trans-unit>
        <trans-unit id="891c0dd9ce25ec71be3534cbafc45fd3ae05f1b7" translate="yes" xml:space="preserve">
          <source>SocketAddrV4::try_from</source>
          <target state="translated">SocketAddrV4::try_from</target>
        </trans-unit>
        <trans-unit id="a9ac2fe099f08b7d16bb0a49954f312840871371" translate="yes" xml:space="preserve">
          <source>SocketAddrV4::try_into</source>
          <target state="translated">SocketAddrV4::try_into</target>
        </trans-unit>
        <trans-unit id="46aaa31435425799c133d708c8ea7559ef69b6bd" translate="yes" xml:space="preserve">
          <source>SocketAddrV4::type_id</source>
          <target state="translated">SocketAddrV4::type_id</target>
        </trans-unit>
        <trans-unit id="2a82ed719ff88f86747881e650245de3a45b485d" translate="yes" xml:space="preserve">
          <source>SocketAddrV6</source>
          <target state="translated">SocketAddrV6</target>
        </trans-unit>
        <trans-unit id="6f3d80be251a7c9f7ee0eec1539c2ee8cd14b150" translate="yes" xml:space="preserve">
          <source>SocketAddrV6::borrow</source>
          <target state="translated">SocketAddrV6::borrow</target>
        </trans-unit>
        <trans-unit id="9f5ed8415f745a24c04e8a4298b04a1d147b4e44" translate="yes" xml:space="preserve">
          <source>SocketAddrV6::borrow_mut</source>
          <target state="translated">SocketAddrV6::borrow_mut</target>
        </trans-unit>
        <trans-unit id="fcd19982de7f53a2ffc007e3fb4d960e721ab4b0" translate="yes" xml:space="preserve">
          <source>SocketAddrV6::clone</source>
          <target state="translated">SocketAddrV6::clone</target>
        </trans-unit>
        <trans-unit id="f55e0b0afcd5d8fe69f272a554104970de30ed37" translate="yes" xml:space="preserve">
          <source>SocketAddrV6::clone_from</source>
          <target state="translated">SocketAddrV6::clone_from</target>
        </trans-unit>
        <trans-unit id="7e02937dcdb8092cfdb1e06a3c0629a45ec8c613" translate="yes" xml:space="preserve">
          <source>SocketAddrV6::clone_into</source>
          <target state="translated">SocketAddrV6::clone_into</target>
        </trans-unit>
        <trans-unit id="3a6b8b2f9e3b425d85568b95ab8297e1715430ee" translate="yes" xml:space="preserve">
          <source>SocketAddrV6::eq</source>
          <target state="translated">SocketAddrV6::eq</target>
        </trans-unit>
        <trans-unit id="cb0432227f015e547a695d18bc763c7ad5b1f137" translate="yes" xml:space="preserve">
          <source>SocketAddrV6::flowinfo</source>
          <target state="translated">SocketAddrV6::flowinfo</target>
        </trans-unit>
        <trans-unit id="57023336af76787be2e4c534237c60dd312a8304" translate="yes" xml:space="preserve">
          <source>SocketAddrV6::fmt</source>
          <target state="translated">SocketAddrV6::fmt</target>
        </trans-unit>
        <trans-unit id="0b4276728eb5db2c8481e59e288ff98e624226e7" translate="yes" xml:space="preserve">
          <source>SocketAddrV6::from</source>
          <target state="translated">SocketAddrV6::from</target>
        </trans-unit>
        <trans-unit id="8a421da1861aecbff43ed6db92d3ca4ea955db4c" translate="yes" xml:space="preserve">
          <source>SocketAddrV6::from_str</source>
          <target state="translated">SocketAddrV6::from_str</target>
        </trans-unit>
        <trans-unit id="4af0a4a2dc3890a6999679693ab7ede3ce48f504" translate="yes" xml:space="preserve">
          <source>SocketAddrV6::hash</source>
          <target state="translated">SocketAddrV6::hash</target>
        </trans-unit>
        <trans-unit id="c1cd7639e97b734ebc4359a46f77b5338b196005" translate="yes" xml:space="preserve">
          <source>SocketAddrV6::hash_slice</source>
          <target state="translated">SocketAddrV6::hash_slice</target>
        </trans-unit>
        <trans-unit id="eea88942dd8e116f8bae7c475306c1e25d577fc8" translate="yes" xml:space="preserve">
          <source>SocketAddrV6::into</source>
          <target state="translated">SocketAddrV6::into</target>
        </trans-unit>
        <trans-unit id="ec4829a1fc51f808a3166d1207d8edcc1a96cd57" translate="yes" xml:space="preserve">
          <source>SocketAddrV6::ip</source>
          <target state="translated">SocketAddrV6::ip</target>
        </trans-unit>
        <trans-unit id="77a714a3ad557f314e500819551d941d06155cd8" translate="yes" xml:space="preserve">
          <source>SocketAddrV6::ne</source>
          <target state="translated">SocketAddrV6::ne</target>
        </trans-unit>
        <trans-unit id="44494c573299c5132f1a609984c69c57ef01e76c" translate="yes" xml:space="preserve">
          <source>SocketAddrV6::new</source>
          <target state="translated">SocketAddrV6::new</target>
        </trans-unit>
        <trans-unit id="1ab36b09219f39990eea0f3e64c06c333fb4504f" translate="yes" xml:space="preserve">
          <source>SocketAddrV6::port</source>
          <target state="translated">SocketAddrV6::port</target>
        </trans-unit>
        <trans-unit id="447b45ff4d0e34372ef8fa330fe8bfba6659e704" translate="yes" xml:space="preserve">
          <source>SocketAddrV6::scope_id</source>
          <target state="translated">SocketAddrV6::scope_id</target>
        </trans-unit>
        <trans-unit id="b421d8a1202f7aaab572adbdb5b1325f4621aa33" translate="yes" xml:space="preserve">
          <source>SocketAddrV6::set_flowinfo</source>
          <target state="translated">SocketAddrV6::set_flowinfo</target>
        </trans-unit>
        <trans-unit id="10fca5b860af2d166e62ee77d423bcffe6454b57" translate="yes" xml:space="preserve">
          <source>SocketAddrV6::set_ip</source>
          <target state="translated">SocketAddrV6::set_ip</target>
        </trans-unit>
        <trans-unit id="af698b7eac5ec17fbd3fb4347ccebc949b6a519e" translate="yes" xml:space="preserve">
          <source>SocketAddrV6::set_port</source>
          <target state="translated">SocketAddrV6::set_port</target>
        </trans-unit>
        <trans-unit id="7be377fcf0d2ff4ef23b1db072ec95367859ac22" translate="yes" xml:space="preserve">
          <source>SocketAddrV6::set_scope_id</source>
          <target state="translated">SocketAddrV6::set_scope_id</target>
        </trans-unit>
        <trans-unit id="5a8a41fe1eb5e9516e083308b063d5b9514970b3" translate="yes" xml:space="preserve">
          <source>SocketAddrV6::to_owned</source>
          <target state="translated">SocketAddrV6::to_owned</target>
        </trans-unit>
        <trans-unit id="d048fbae3ef9e243530f04ac9a777559ef665914" translate="yes" xml:space="preserve">
          <source>SocketAddrV6::to_socket_addrs</source>
          <target state="translated">SocketAddrV6::to_socket_addrs</target>
        </trans-unit>
        <trans-unit id="c2627bba75f17c17b79e53ad84b1106fd67cecab" translate="yes" xml:space="preserve">
          <source>SocketAddrV6::to_string</source>
          <target state="translated">SocketAddrV6::to_string</target>
        </trans-unit>
        <trans-unit id="bd4e5413241d810aaf8cbb9ec4b872862307c3d4" translate="yes" xml:space="preserve">
          <source>SocketAddrV6::try_from</source>
          <target state="translated">SocketAddrV6::try_from</target>
        </trans-unit>
        <trans-unit id="d18c4f695f7bea37405e4856fbc0c64bee129e7e" translate="yes" xml:space="preserve">
          <source>SocketAddrV6::try_into</source>
          <target state="translated">SocketAddrV6::try_into</target>
        </trans-unit>
        <trans-unit id="14104db8b94a9a8b11d37bdfd84939c50560053b" translate="yes" xml:space="preserve">
          <source>SocketAddrV6::type_id</source>
          <target state="translated">SocketAddrV6::type_id</target>
        </trans-unit>
        <trans-unit id="0c2066f053f508b4c0c843ade1ac1437bac212a7" translate="yes" xml:space="preserve">
          <source>Solution #1: Bind the pattern's values the same way.</source>
          <target state="translated">Решение №1:Связать значения шаблона таким же образом.</target>
        </trans-unit>
        <trans-unit id="913e14ce2731e1f5c5084ef479e21694820c85a9" translate="yes" xml:space="preserve">
          <source>Solution #1: Rename the item.</source>
          <target state="translated">Решение №1:Переименовать элемент.</target>
        </trans-unit>
        <trans-unit id="228f8e354c6932ad110d73d004853969429e19ac" translate="yes" xml:space="preserve">
          <source>Solution #2: Implement the &lt;code&gt;Copy&lt;/code&gt; trait for the &lt;code&gt;X&lt;/code&gt; structure.</source>
          <target state="translated">Решение №2: &lt;code&gt;Copy&lt;/code&gt; свойство Copy для &lt;code&gt;X&lt;/code&gt; - структуры.</target>
        </trans-unit>
        <trans-unit id="e7b19c62d01a7e3e5709bf524ce576fa1d6ddcb8" translate="yes" xml:space="preserve">
          <source>Solution #2: Import the crate with a different name.</source>
          <target state="translated">Решение № 2:Импорт ящика с другим именем.</target>
        </trans-unit>
        <trans-unit id="0563a8d6ac0a042a4a8e127d3a94d1467ee40577" translate="yes" xml:space="preserve">
          <source>Some additional &lt;em&gt;escapes&lt;/em&gt; are available in either byte or non-raw byte string literals. An escape starts with a &lt;code&gt;U+005C&lt;/code&gt; (&lt;code&gt;\&lt;/code&gt;) and continues with one of the following forms:</source>
          <target state="translated">Некоторые дополнительные &lt;em&gt;escape&lt;/em&gt; -последовательности доступны как в байтовых строковых литералах, так и в необработанных байтовых строковых литералах. Эскейп начинается с &lt;code&gt;U+005C&lt;/code&gt; ( &lt;code&gt;\&lt;/code&gt; ) и продолжается одной из следующих форм:</target>
        </trans-unit>
        <trans-unit id="1b26e19347b2f0fbbb46e779d09457187a4ad813" translate="yes" xml:space="preserve">
          <source>Some additional &lt;em&gt;escapes&lt;/em&gt; are available in either character or non-raw string literals. An escape starts with a &lt;code&gt;U+005C&lt;/code&gt; (&lt;code&gt;\&lt;/code&gt;) and continues with one of the following forms:</source>
          <target state="translated">Некоторые дополнительные &lt;em&gt;escape-&lt;/em&gt; символы доступны как в символьных, так и в строковых литералах, не являющихся исходными. Эскейп начинается с &lt;code&gt;U+005C&lt;/code&gt; ( &lt;code&gt;\&lt;/code&gt; ) и продолжается одной из следующих форм:</target>
        </trans-unit>
        <trans-unit id="2b058503db09aa39221c4a7fe1f4a51447d81392" translate="yes" xml:space="preserve">
          <source>Some command line options go to &lt;code&gt;cargo test&lt;/code&gt;, and some go to the resulting test binary. To separate these two types of arguments, you list the arguments that go to &lt;code&gt;cargo test&lt;/code&gt; followed by the separator &lt;code&gt;--&lt;/code&gt; and then the ones that go to the test binary. Running &lt;code&gt;cargo test --help&lt;/code&gt; displays the options you can use with &lt;code&gt;cargo test&lt;/code&gt;, and running &lt;code&gt;cargo test -- --help&lt;/code&gt; displays the options you can use after the separator &lt;code&gt;--&lt;/code&gt;.</source>
          <target state="translated">Некоторые опции командной строки перейдите к &lt;code&gt;cargo test&lt;/code&gt; , а некоторые идут к полученному тесту двоичной системы . Для того, чтобы разделить эти два типа аргументов, вы перечислить аргументы , которые идут к &lt;code&gt;cargo test&lt;/code&gt; с последующим разделителем &lt;code&gt;--&lt;/code&gt; а затем те , которые идут к испытательному двоичному. Запуск &lt;code&gt;cargo test --help&lt;/code&gt; отображает параметры, которые можно использовать с &lt;code&gt;cargo test&lt;/code&gt; , а запуск &lt;code&gt;cargo test -- --help&lt;/code&gt; отображает параметры, которые можно использовать после разделителя &lt;code&gt;--&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3bc8a5b5ab004f33f3d313ba2f0c49c5b66a7ca4" translate="yes" xml:space="preserve">
          <source>Some examples of attributes:</source>
          <target state="translated">Некоторые примеры атрибутов:</target>
        </trans-unit>
        <trans-unit id="2243be5a688dbf232c39ca5d950ae959b2ee998b" translate="yes" xml:space="preserve">
          <source>Some examples of meta items are:</source>
          <target state="translated">Некоторые примеры мета-элементов:</target>
        </trans-unit>
        <trans-unit id="2f158a3a6ebb6ae4f387bb83ae0c0dc6662470a7" translate="yes" xml:space="preserve">
          <source>Some examples of the &lt;a href=&quot;../macro.format&quot;&gt;&lt;code&gt;format!&lt;/code&gt;&lt;/a&gt; extension are:</source>
          <target state="translated">Несколько примеров &lt;a href=&quot;../macro.format&quot;&gt; &lt;code&gt;format!&lt;/code&gt; &lt;/a&gt;расширение:</target>
        </trans-unit>
        <trans-unit id="e9573b985828840e7a24788ac2cb2800024df3d0" translate="yes" xml:space="preserve">
          <source>Some examples of the output from both traits:</source>
          <target state="translated">Некоторые примеры вывода из обоих признаков:</target>
        </trans-unit>
        <trans-unit id="bcebc814147d823ce2e8db6662c984429f65698d" translate="yes" xml:space="preserve">
          <source>Some examples of tuple types:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5276140ed8ab5855b7e53291e8d6476d11a9a5b7" translate="yes" xml:space="preserve">
          <source>Some examples of what will and will not work for &lt;code&gt;use&lt;/code&gt; items:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aa3c6a4e85d404223aa99965ce20b1fdf220b8c7" translate="yes" xml:space="preserve">
          <source>Some examples on functions:</source>
          <target state="translated">Некоторые примеры функций:</target>
        </trans-unit>
        <trans-unit id="01706013cfdbcb0fc543d3c97784f3f4c235d630" translate="yes" xml:space="preserve">
          <source>Some examples:</source>
          <target state="translated">Несколько примеров:</target>
        </trans-unit>
        <trans-unit id="68f160c42cafa15f86d6a95981d29c57e9030b96" translate="yes" xml:space="preserve">
          <source>Some items form an implicit scope for the declaration of sub-items. In other words, within a function or module, declarations of items can (in many cases) be mixed with the statements, control blocks, and similar artifacts that otherwise compose the item body. The meaning of these scoped items is the same as if the item was declared outside the scope &amp;mdash; it is still a static item &amp;mdash; except that the item's &lt;em&gt;path name&lt;/em&gt; within the module namespace is qualified by the name of the enclosing item, or is private to the enclosing item (in the case of functions). The grammar specifies the exact locations in which sub-item declarations may appear.</source>
          <target state="translated">Некоторые элементы образуют неявную область для объявления подпунктов. Другими словами, внутри функции или модуля объявления элементов могут (во многих случаях) смешиваться с операторами, блоками управления и аналогичными артефактами, которые в противном случае составляют тело элемента. Значение этих элементов с заданной областью такое же, как если бы элемент был объявлен вне области - это все еще статический элемент, за исключением того, что &lt;em&gt;имя пути&lt;/em&gt; элемента в пространстве имен модуля уточняется именем включающего элемента или является частным для охватывающий элемент (в случае функций). Грамматика определяет точные места, в которых могут появляться объявления подпунктов.</target>
        </trans-unit>
        <trans-unit id="ad868bf29644aa3c2d96a099950b1be49e222d52" translate="yes" xml:space="preserve">
          <source>Some languages call this operation flatmap.</source>
          <target state="translated">Некоторые языки называют эту операцию плоской картой.</target>
        </trans-unit>
        <trans-unit id="5c742d5cb3f7602a56083df57274c35942061f20" translate="yes" xml:space="preserve">
          <source>Some of the methods require that a layout &lt;em&gt;fit&lt;/em&gt; a memory block. What it means for a layout to &quot;fit&quot; a memory block means (or equivalently, for a memory block to &quot;fit&quot; a layout) is that the following conditions must hold:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ec744582d348ac916573975c541aa67c7110d8fa" translate="yes" xml:space="preserve">
          <source>Some of the methods require that a layout &lt;em&gt;fit&lt;/em&gt; a memory block. What it means for a layout to &quot;fit&quot; a memory block means (or equivalently, for a memory block to &quot;fit&quot; a layout) is that the following two conditions must hold:</source>
          <target state="translated">Некоторые методы требуют, чтобы макет &lt;em&gt;соответствовал&lt;/em&gt; блоку памяти. То, что макет &quot;подходит&quot; к блоку памяти, означает (или, что эквивалентно, для блока памяти &quot;подходит&quot; макет), что должны выполняться следующие два условия:</target>
        </trans-unit>
        <trans-unit id="95bb46f84c997c823dac7e6e0d9bce09adabf3dc" translate="yes" xml:space="preserve">
          <source>Some of the methods require that a memory block be &lt;em&gt;currently allocated&lt;/em&gt; via an allocator. This means that:</source>
          <target state="translated">Некоторые методы требуют, чтобы блок памяти был &lt;em&gt;выделен в данный момент&lt;/em&gt; через распределитель. Это означает, что:</target>
        </trans-unit>
        <trans-unit id="222076c2af94120505dcdff91bf0dd46c85e1ae9" translate="yes" xml:space="preserve">
          <source>Some of these traits are imported by the prelude, so they are available in every Rust program. Only operators backed by traits can be overloaded. For example, the addition operator (&lt;code&gt;+&lt;/code&gt;) can be overloaded through the &lt;a href=&quot;trait.add&quot;&gt;&lt;code&gt;Add&lt;/code&gt;&lt;/a&gt; trait, but since the assignment operator (&lt;code&gt;=&lt;/code&gt;) has no backing trait, there is no way of overloading its semantics. Additionally, this module does not provide any mechanism to create new operators. If traitless overloading or custom operators are required, you should look toward macros or compiler plugins to extend Rust's syntax.</source>
          <target state="translated">Некоторые из этих черт импортируются прелюдией, поэтому они доступны в каждой программе на Rust. Только операторы, поддерживаемые трейтами, могут быть перегружены. Например, оператор сложения ( &lt;code&gt;+&lt;/code&gt; ) может быть перегружен с помощью признака &lt;a href=&quot;trait.add&quot;&gt; &lt;code&gt;Add&lt;/code&gt; &lt;/a&gt; , но поскольку оператор присваивания ( &lt;code&gt;=&lt;/code&gt; ) не имеет поддерживающего признака, нет способа перегрузить его семантику. Кроме того, этот модуль не предоставляет никакого механизма для создания новых операторов. Если требуется перегрузка без признаков или пользовательские операторы, вам следует обратить внимание на макросы или плагины компилятора для расширения синтаксиса Rust.</target>
        </trans-unit>
        <trans-unit id="f01c5fd014f6ba000dfac578d5888065f628161a" translate="yes" xml:space="preserve">
          <source>Some platforms do not provide access to the current timeout.</source>
          <target state="translated">Некоторые платформы не предоставляют доступ к текущему таймауту.</target>
        </trans-unit>
        <trans-unit id="358e5fe641941b3b99590f3b5a62dbfefcd41b19" translate="yes" xml:space="preserve">
          <source>Some possible values:</source>
          <target state="translated">Некоторые возможные значения:</target>
        </trans-unit>
        <trans-unit id="8c829abe4cbf6dda3204f3a6987ef00d5c7d24bd" translate="yes" xml:space="preserve">
          <source>Some programs allow arguments &lt;em&gt;and&lt;/em&gt; environment variables for the same configuration. In those cases, the programs decide that one or the other takes precedence. For another exercise on your own, try controlling case insensitivity through either a command line argument or an environment variable. Decide whether the command line argument or the environment variable should take precedence if the program is run with one set to case sensitive and one set to case insensitive.</source>
          <target state="translated">Некоторые программы позволяют использовать аргументы &lt;em&gt;и&lt;/em&gt; переменные среды для одной и той же конфигурации. В таких случаях программы решают, что одно из них имеет приоритет. В качестве другого самостоятельного упражнения попробуйте контролировать нечувствительность к регистру с помощью аргумента командной строки или переменной среды. Решите, должен ли аргумент командной строки или переменная среды иметь приоритет, если программа запускается с одним набором чувствительности к регистру, а другим - без учета регистра.</target>
        </trans-unit>
        <trans-unit id="abe7b976e1b0d3e4291f7926f32c54bb5f29a679" translate="yes" xml:space="preserve">
          <source>Some rules in the grammar &amp;mdash; notably &lt;a href=&quot;expressions/operator-expr#borrow-operators&quot;&gt;unary operators&lt;/a&gt;, &lt;a href=&quot;expressions/operator-expr#arithmetic-and-logical-binary-operators&quot;&gt;binary operators&lt;/a&gt;, and &lt;a href=&quot;keywords&quot;&gt;keywords&lt;/a&gt; &amp;mdash; are given in a simplified form: as a listing of printable strings. These cases form a subset of the rules regarding the &lt;a href=&quot;tokens&quot;&gt;token&lt;/a&gt; rule, and are assumed to be the result of a lexical-analysis phase feeding the parser, driven by a</source>
          <target state="translated">Некоторые правила грамматики - особенно &lt;a href=&quot;expressions/operator-expr#borrow-operators&quot;&gt;унарные операторы&lt;/a&gt; , &lt;a href=&quot;expressions/operator-expr#arithmetic-and-logical-binary-operators&quot;&gt;бинарные операторы&lt;/a&gt; и &lt;a href=&quot;keywords&quot;&gt;ключевые слова&lt;/a&gt; - даются в упрощенной форме: в виде списка печатаемых строк. Эти кейсы образуют подмножество правил, касающихся правила &lt;a href=&quot;tokens&quot;&gt;лексемы&lt;/a&gt; , и предполагается, что они являются результатом фазы лексического анализа, обрабатываемой синтаксическим анализатором, управляемой</target>
        </trans-unit>
        <trans-unit id="f221c8fd967ff4f3d5c7c0df018f045fb84910f0" translate="yes" xml:space="preserve">
          <source>Some traits may be unsafe to implement. Using the &lt;a href=&quot;keyword.unsafe&quot;&gt;&lt;code&gt;unsafe&lt;/code&gt;&lt;/a&gt; keyword in front of the trait's declaration is used to mark this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b7b4fd9fd085cf7f8062ca0116154d54b2f67425" translate="yes" xml:space="preserve">
          <source>Some type parameters have the same name.</source>
          <target state="translated">Некоторые параметры типа имеют одно и то же название.</target>
        </trans-unit>
        <trans-unit id="44cd5246860ce8877c0c50833e18009c3c5adbcd" translate="yes" xml:space="preserve">
          <source>Some types can't be copied safely. For example, copying &lt;code&gt;&amp;amp;mut T&lt;/code&gt; would create an aliased mutable reference. Copying &lt;a href=&quot;../string/struct.string&quot;&gt;&lt;code&gt;String&lt;/code&gt;&lt;/a&gt; would duplicate responsibility for managing the &lt;a href=&quot;../string/struct.string&quot;&gt;&lt;code&gt;String&lt;/code&gt;&lt;/a&gt;'s buffer, leading to a double free.</source>
          <target state="translated">Некоторые типы нельзя безопасно скопировать. Например, копирование &lt;code&gt;&amp;amp;mut T&lt;/code&gt; создаст изменяемую ссылку с псевдонимом. Копирование &lt;a href=&quot;../string/struct.string&quot;&gt; &lt;code&gt;String&lt;/code&gt; &lt;/a&gt; дублирует ответственность за управление буфером &lt;a href=&quot;../string/struct.string&quot;&gt; &lt;code&gt;String&lt;/code&gt; &lt;/a&gt; , что приводит к двойному освобождению.</target>
        </trans-unit>
        <trans-unit id="395f2accbb2c55d74192ec105383cfaec91e432d" translate="yes" xml:space="preserve">
          <source>Some types have no ownership semantics at all and are trivial to duplicate. An example is &lt;code&gt;i32&lt;/code&gt; and the other number types. We don't have to call &lt;code&gt;.clone()&lt;/code&gt; to clone them, because they are marked &lt;code&gt;Copy&lt;/code&gt; in addition to &lt;code&gt;Clone&lt;/code&gt;. Implicit cloning is more convenient in this case. We can mark our own types &lt;code&gt;Copy&lt;/code&gt; if all their members also are marked &lt;code&gt;Copy&lt;/code&gt;.</source>
          <target state="translated">Некоторые типы вообще не имеют семантики владения и их тривиально дублировать. Пример - &lt;code&gt;i32&lt;/code&gt; и другие числовые типы. Нам не нужно вызывать &lt;code&gt;.clone()&lt;/code&gt; для их клонирования, потому что они помечены как &lt;code&gt;Copy&lt;/code&gt; в дополнение к &lt;code&gt;Clone&lt;/code&gt; . В этом случае удобнее неявное клонирование. Мы можем пометить наши собственные типы &lt;code&gt;Copy&lt;/code&gt; , если все их члены также отмечены &lt;code&gt;Copy&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8827ce6f7fbbe39876def8741d8f6c0f34bda4ac" translate="yes" xml:space="preserve">
          <source>Some types make it possible to go from borrowed to owned, usually by implementing the &lt;code&gt;Clone&lt;/code&gt; trait. But &lt;code&gt;Clone&lt;/code&gt; works only for going from &lt;code&gt;&amp;amp;T&lt;/code&gt; to &lt;code&gt;T&lt;/code&gt;. The &lt;code&gt;ToOwned&lt;/code&gt; trait generalizes &lt;code&gt;Clone&lt;/code&gt; to construct owned data from any borrow of a given type.</source>
          <target state="translated">Некоторые типы позволяют перейти от заимствованного к собственному, обычно за счет реализации трейта &lt;code&gt;Clone&lt;/code&gt; . Но &lt;code&gt;Clone&lt;/code&gt; работает только для перехода от &lt;code&gt;&amp;amp;T&lt;/code&gt; до &lt;code&gt;T&lt;/code&gt; . &lt;code&gt;ToOwned&lt;/code&gt; черта обобщает &lt;code&gt;Clone&lt;/code&gt; построить принадлежащие данные из любого заема данного типа.</target>
        </trans-unit>
        <trans-unit id="1fa499ad14d540d4ab748c3f63c14c59562feb8d" translate="yes" xml:space="preserve">
          <source>Some value &lt;code&gt;T&lt;/code&gt;</source>
          <target state="translated">Некоторое значение &lt;code&gt;T&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="878090a0fad65a133ac057071000349608e90593" translate="yes" xml:space="preserve">
          <source>Somehow reclaim the ownership.</source>
          <target state="translated">Каким-то образом вернуть право собственности.</target>
        </trans-unit>
        <trans-unit id="f781cf82d5c3741244bc8c4aeb0b4f682140871d" translate="yes" xml:space="preserve">
          <source>Something other than a module was found in visibility scope.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b475f4837c8088ae9e2316ee2cc452a611abdd5e" translate="yes" xml:space="preserve">
          <source>Something other than a struct, variant or union has been used when one was expected.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0c0b8d60e3d74c7cecb9ea23d7c89fc75bd5de97" translate="yes" xml:space="preserve">
          <source>Something other than a type has been used when one was expected.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5fcd1c6adde9ce2b8b8f8c24f05d8cba59dab8fc" translate="yes" xml:space="preserve">
          <source>Something other than a type or an associated type was given.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c9b777e07031a8e6299f68aae25ccc20a24a398e" translate="yes" xml:space="preserve">
          <source>Something other than numbers and characters has been used for a range.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="04c99ebec2739e6e397c7eed6e9e1c2df41e5a11" translate="yes" xml:space="preserve">
          <source>Something that implements &lt;code&gt;DoubleEndedIterator&lt;/code&gt; has one extra capability over something that implements &lt;a href=&quot;trait.iterator&quot;&gt;&lt;code&gt;Iterator&lt;/code&gt;&lt;/a&gt;: the ability to also take &lt;code&gt;Item&lt;/code&gt;s from the back, as well as the front.</source>
          <target state="translated">То, что реализует &lt;code&gt;DoubleEndedIterator&lt;/code&gt; , имеет одну дополнительную возможность по сравнению с тем, что реализует &lt;a href=&quot;trait.iterator&quot;&gt; &lt;code&gt;Iterator&lt;/code&gt; &lt;/a&gt; : способность также принимать &lt;code&gt;Item&lt;/code&gt; как сзади, так и спереди.</target>
        </trans-unit>
        <trans-unit id="32ead51bd610490468db45da53a1bf9c6c66393f" translate="yes" xml:space="preserve">
          <source>Something which is neither a tuple struct nor a tuple variant was used as a pattern.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e879dd2e95b609ab6dd974536decd029eefa2e22" translate="yes" xml:space="preserve">
          <source>Sometimes a certain value is used many times throughout a program, and it can become inconvenient to copy it over and over. What's more, it's not always possible or desirable to make it a variable that gets carried around to each function that needs it. In these cases, the &lt;code&gt;const&lt;/code&gt; keyword provides a convenient alternative to code duplication.</source>
          <target state="translated">Иногда определенное значение используется много раз в программе, и может быть неудобно копировать его снова и снова. Более того, не всегда возможно или желательно сделать его переменной, которая будет передаваться каждой функции, которая в ней нуждается. В этих случаях ключевое слово &lt;code&gt;const&lt;/code&gt; представляет собой удобную альтернативу дублированию кода.</target>
        </trans-unit>
        <trans-unit id="d57e753282f59a43c70aec54356a0dabe1596422" translate="yes" xml:space="preserve">
          <source>Sometimes a certain value is used many times throughout a program, and it can become inconvenient to copy it over and over. What's more, it's not always possible or desirable to make it a variable that gets carried around to each function that needs it. In these cases, the &lt;code&gt;const&lt;/code&gt; keyword provides a convenient alternative to code duplication:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7b4ce2023b0107d37a404740c834f4e456c69887" translate="yes" xml:space="preserve">
          <source>Sometimes a few specific tests can be very time-consuming to execute, so you might want to exclude them during most runs of &lt;code&gt;cargo test&lt;/code&gt;. Rather than listing as arguments all tests you do want to run, you can instead annotate the time-consuming tests using the &lt;code&gt;ignore&lt;/code&gt; attribute to exclude them, as shown here:</source>
          <target state="translated">Иногда выполнение нескольких конкретных тестов может занять очень много времени, поэтому вы можете исключить их во время большинства запусков &lt;code&gt;cargo test&lt;/code&gt; . Вместо того, чтобы перечислять в качестве аргументов все тесты, которые вы хотите запустить, вы можете вместо этого аннотировать трудоемкие тесты, используя атрибут &lt;code&gt;ignore&lt;/code&gt; для их исключения, как показано здесь:</target>
        </trans-unit>
        <trans-unit id="22420dec705f5672d2fbfde1a393dbcf1c213a8d" translate="yes" xml:space="preserve">
          <source>Sometimes a type needs be mutated while having multiple aliases. In Rust this is achieved using a pattern called &lt;em&gt;interior mutability&lt;/em&gt;. A type has interior mutability if its internal state can be changed through a &lt;a href=&quot;types/pointer#shared-references-&quot;&gt;shared reference&lt;/a&gt; to it. This goes against the usual &lt;a href=&quot;behavior-considered-undefined&quot;&gt;requirement&lt;/a&gt; that the value pointed to by a shared reference is not mutated.</source>
          <target state="translated">Иногда требуется изменить тип, имея несколько псевдонимов. В Rust это достигается с помощью паттерна, называемого &lt;em&gt;внутренней изменчивостью&lt;/em&gt; . Тип имеет внутреннюю изменчивость, если его внутреннее состояние может быть изменено с помощью &lt;a href=&quot;types/pointer#shared-references-&quot;&gt;общей ссылки&lt;/a&gt; на него. Это противоречит обычному &lt;a href=&quot;behavior-considered-undefined&quot;&gt;требованию&lt;/a&gt; , чтобы значение, на которое указывает общая ссылка, не изменялось.</target>
        </trans-unit>
        <trans-unit id="924fa07f8faef6f0df6e1f6bc3870b009c5c2243" translate="yes" xml:space="preserve">
          <source>Sometimes a type needs to be mutated while having multiple aliases. In Rust this is achieved using a pattern called &lt;em&gt;interior mutability&lt;/em&gt;. A type has interior mutability if its internal state can be changed through a &lt;a href=&quot;types/pointer#shared-references-&quot;&gt;shared reference&lt;/a&gt; to it. This goes against the usual &lt;a href=&quot;behavior-considered-undefined&quot;&gt;requirement&lt;/a&gt; that the value pointed to by a shared reference is not mutated.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a9720e6d76f55a2ee93872054183df80d4aae5ef" translate="yes" xml:space="preserve">
          <source>Sometimes it&amp;rsquo;s useful to have default behavior for some or all of the methods in a trait instead of requiring implementations for all methods on every type. Then, as we implement the trait on a particular type, we can keep or override each method&amp;rsquo;s default behavior.</source>
          <target state="translated">Иногда полезно иметь поведение по умолчанию для некоторых или всех методов в трейте вместо того, чтобы требовать реализации для всех методов для каждого типа. Затем, когда мы реализуем трейт для определенного типа, мы можем сохранить или переопределить поведение каждого метода по умолчанию.</target>
        </trans-unit>
        <trans-unit id="c0682d5f8323b14fe072519e99ff0b6b6bc710c2" translate="yes" xml:space="preserve">
          <source>Sometimes we don't need to move the value. Using a reference, we can let another function borrow the value without changing its ownership. In the example below, we don't actually have to move our string to &lt;code&gt;calculate_length&lt;/code&gt;, we can give it a reference to it with &lt;code&gt;&amp;amp;&lt;/code&gt; instead.</source>
          <target state="translated">Иногда нам не нужно перемещать значение. Используя ссылку, мы можем позволить другой функции заимствовать значение, не меняя владельца. В приведенном ниже примере нам на самом деле не нужно перемещать нашу строку в &lt;code&gt;calculate_length&lt;/code&gt; , мы можем вместо этого указать ссылку на нее с помощью &lt;code&gt;&amp;amp;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="354a53eabe5fcae89d7d1b83e827a4a82dec495d" translate="yes" xml:space="preserve">
          <source>Sometimes we don't want a reference, but a duplicate. All types marked &lt;code&gt;Clone&lt;/code&gt; can be duplicated by calling &lt;code&gt;.clone()&lt;/code&gt;. Subsequent changes to a clone do not affect the original variable.</source>
          <target state="translated">Иногда нам нужна не ссылка, а дубликат. Все типы, помеченные как &lt;code&gt;Clone&lt;/code&gt; , можно скопировать, вызвав &lt;code&gt;.clone()&lt;/code&gt; . Последующие изменения клона не влияют на исходную переменную.</target>
        </trans-unit>
        <trans-unit id="ff912c381f4928aab54a72b634a6064d57ffd41a" translate="yes" xml:space="preserve">
          <source>Sometimes, bad things happen in your code, and there&amp;rsquo;s nothing you can do about it. In these cases, Rust has the &lt;code&gt;panic!&lt;/code&gt; macro. When the &lt;code&gt;panic!&lt;/code&gt; macro executes, your program will print a failure message, unwind and clean up the stack, and then quit. This most commonly occurs when a bug of some kind has been detected and it&amp;rsquo;s not clear to the programmer how to handle the error.</source>
          <target state="translated">Иногда в вашем коде происходят плохие вещи, и вы ничего не можете с этим поделать. В таких случаях у Rust возникает &lt;code&gt;panic!&lt;/code&gt; макрос. Когда &lt;code&gt;panic!&lt;/code&gt; макроса, ваша программа распечатает сообщение об ошибке, развернет и очистит стек, а затем завершит работу. Чаще всего это происходит, когда обнаружена какая-либо ошибка, и программисту непонятно, как с ней справиться.</target>
        </trans-unit>
        <trans-unit id="c0e1220c83bd29682d8aeeb6c70d9bd1fcc32412" translate="yes" xml:space="preserve">
          <source>Sometimes, running a full test suite can take a long time. If you&amp;rsquo;re working on code in a particular area, you might want to run only the tests pertaining to that code. You can choose which tests to run by passing &lt;code&gt;cargo test&lt;/code&gt; the name or names of the test(s) you want to run as an argument.</source>
          <target state="translated">Иногда выполнение полного набора тестов может занять много времени. Если вы работаете над кодом в определенной области, вы можете захотеть запустить только тесты, относящиеся к этому коду. Вы можете выбрать, какие тесты запускать, передав в &lt;code&gt;cargo test&lt;/code&gt; имя или имена тестов, которые вы хотите запустить, в качестве аргумента.</target>
        </trans-unit>
        <trans-unit id="33934c254a892896c6e91fea97bdb219087bd1a5" translate="yes" xml:space="preserve">
          <source>Sometimes, you might need one trait to use another trait&amp;rsquo;s functionality. In this case, you need to rely on the dependent trait also being implemented. The trait you rely on is a &lt;em&gt;supertrait&lt;/em&gt; of the trait you&amp;rsquo;re implementing.</source>
          <target state="translated">Иногда вам может понадобиться одна черта, чтобы использовать функции другой черты. В этом случае нужно полагаться на реализуемую зависимую черту. Черта, на которую вы полагаетесь, является &lt;em&gt;надстройкой&lt;/em&gt; той черты, которую вы реализуете.</target>
        </trans-unit>
        <trans-unit id="7dd2749cfb5be67fe5b24695dba8809079cc076a" translate="yes" xml:space="preserve">
          <source>Sometimes, you want to fall back to some kind of default value, and don't particularly care what it is. This comes up often with &lt;code&gt;struct&lt;/code&gt;s that define a set of options:</source>
          <target state="translated">Иногда вы хотите вернуться к какому-либо значению по умолчанию, и вам все равно, что это такое. Это часто встречается со &lt;code&gt;struct&lt;/code&gt; которые определяют набор параметров:</target>
        </trans-unit>
        <trans-unit id="a5542a442b57c4e85de5da2fb88f9df18bb1e825" translate="yes" xml:space="preserve">
          <source>Sometimes, you&amp;rsquo;ll see multiple messages printed for one browser request; the reason might be that the browser is making a request for the page as well as a request for other resources, like the &lt;em&gt;favicon.ico&lt;/em&gt; icon that appears in the browser tab.</source>
          <target state="translated">Иногда вы видите несколько сообщений, напечатанных для одного запроса браузера; Причина может заключаться в том, что браузер делает запрос страницы, а также запрос других ресурсов, таких как значок &lt;em&gt;favicon.ico,&lt;/em&gt; который появляется на вкладке браузера.</target>
        </trans-unit>
        <trans-unit id="cd4fa08a56f591f3a44dac915c98df209a1bd2bf" translate="yes" xml:space="preserve">
          <source>Sometimes, your Rust code might need to interact with code written in another language. For this, Rust has a keyword, &lt;code&gt;extern&lt;/code&gt;, that facilitates the creation and use of a &lt;em&gt;Foreign Function Interface (FFI)&lt;/em&gt;. An FFI is a way for a programming language to define functions and enable a different (foreign) programming language to call those functions.</source>
          <target state="translated">Иногда вашему коду Rust может потребоваться взаимодействие с кодом, написанным на другом языке. Для этого в Rust есть ключевое слово &lt;code&gt;extern&lt;/code&gt; , которое облегчает создание и использование &lt;em&gt;интерфейса внешних функций (FFI)&lt;/em&gt; . FFI - это способ для языка программирования определять функции и позволять другому (иностранному) языку программирования вызывать эти функции.</target>
        </trans-unit>
        <trans-unit id="a41bcc58d5abfba7380b0c52ec09f547cfe68f0e" translate="yes" xml:space="preserve">
          <source>Soon we&amp;rsquo;ll define the &lt;code&gt;impl_hello_macro&lt;/code&gt; function, which is where we&amp;rsquo;ll build the new Rust code we want to include. But before we do, note that the output for our derive macro is also a &lt;code&gt;TokenStream&lt;/code&gt;. The returned &lt;code&gt;TokenStream&lt;/code&gt; is added to the code that our crate users write, so when they compile their crate, they&amp;rsquo;ll get the extra functionality that we provide in the modified &lt;code&gt;TokenStream&lt;/code&gt;.</source>
          <target state="translated">Вскоре мы определим функцию &lt;code&gt;impl_hello_macro&lt;/code&gt; , в которой мы создадим новый код Rust, который мы хотим включить. Но прежде чем мы это сделаем, обратите внимание, что вывод для нашего производного макроса также является &lt;code&gt;TokenStream&lt;/code&gt; . Возвращенный &lt;code&gt;TokenStream&lt;/code&gt; добавляется к коду , что наши пользователи клеть писать, поэтому , когда они компилировать их клеть, они будут получать дополнительные функциональные возможности, которые мы предоставляем в модифицированном &lt;code&gt;TokenStream&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ec475886cfea806d371a2f2778f02299b4f357d8" translate="yes" xml:space="preserve">
          <source>Sorting the content of a deque.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8426200d0f6fa7ad9d762b86260809e08c44014e" translate="yes" xml:space="preserve">
          <source>Sorts the slice with a comparator function, but may not preserve the order of equal elements.</source>
          <target state="translated">Сортирует срез с функцией компаратора,но не может сохранять порядок одинаковых элементов.</target>
        </trans-unit>
        <trans-unit id="b82ccd89f52b63e5b4440242a27febda3e964e83" translate="yes" xml:space="preserve">
          <source>Sorts the slice with a comparator function.</source>
          <target state="translated">Сортирует кусочек с функцией компаратора.</target>
        </trans-unit>
        <trans-unit id="dbc7bc291a372357db09800ac2e37d3ac779ef97" translate="yes" xml:space="preserve">
          <source>Sorts the slice with a key extraction function, but may not preserve the order of equal elements.</source>
          <target state="translated">Сортирует срез с помощью функции извлечения ключа,но не может сохранять порядок одинаковых элементов.</target>
        </trans-unit>
        <trans-unit id="8f84fa97c498bfa88df86d33d1265c8844c055a6" translate="yes" xml:space="preserve">
          <source>Sorts the slice with a key extraction function.</source>
          <target state="translated">Сортирует кусочек с помощью функции извлечения ключа.</target>
        </trans-unit>
        <trans-unit id="0017e05bd16c8d58c49a577c9b4b892ce88f07b2" translate="yes" xml:space="preserve">
          <source>Sorts the slice, but may not preserve the order of equal elements.</source>
          <target state="translated">Сортирует ломтик,но не может сохранять порядок одинаковых элементов.</target>
        </trans-unit>
        <trans-unit id="7818ee857300496e42253e304ef95d74874e5e7b" translate="yes" xml:space="preserve">
          <source>Sorts the slice.</source>
          <target state="translated">Сортирует кусочек.</target>
        </trans-unit>
        <trans-unit id="7b37110e5b01350732eac4676af2611966b9ccef" translate="yes" xml:space="preserve">
          <source>Source Code</source>
          <target state="translated">Исходный код</target>
        </trans-unit>
        <trans-unit id="da9fb400dd20d98034fe54139d4b1854fa050f78" translate="yes" xml:space="preserve">
          <source>Source File</source>
          <target state="translated">Файл источника</target>
        </trans-unit>
        <trans-unit id="4fde6fe6a49f40cd5e5e64f4893cf5deb11807bb" translate="yes" xml:space="preserve">
          <source>SourceIter</source>
          <target state="translated">SourceIter</target>
        </trans-unit>
        <trans-unit id="e5ce2cc6a5699323b6831e47e5174d91fe3c8511" translate="yes" xml:space="preserve">
          <source>Spawning a process</source>
          <target state="translated">Назревание процесса</target>
        </trans-unit>
        <trans-unit id="7454c02ba355d0433ce7be23ac48b7b250144890" translate="yes" xml:space="preserve">
          <source>Spawning a thread</source>
          <target state="translated">Икрометание нити</target>
        </trans-unit>
        <trans-unit id="483805b840862ed495832b49431de70641c81f46" translate="yes" xml:space="preserve">
          <source>Spawns a new thread by taking ownership of the &lt;code&gt;Builder&lt;/code&gt;, and returns an &lt;a href=&quot;../io/type.result&quot;&gt;&lt;code&gt;io::Result&lt;/code&gt;&lt;/a&gt; to its &lt;a href=&quot;struct.joinhandle&quot;&gt;&lt;code&gt;JoinHandle&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Создает новый поток, &lt;a href=&quot;struct.joinhandle&quot;&gt; &lt;code&gt;JoinHandle&lt;/code&gt; &lt;/a&gt; владельцем &lt;code&gt;Builder&lt;/code&gt; , и возвращает &lt;a href=&quot;../io/type.result&quot;&gt; &lt;code&gt;io::Result&lt;/code&gt; &lt;/a&gt; его JoinHandle .</target>
        </trans-unit>
        <trans-unit id="92e23ac918399fba2469fc0427afc1b87a34fe41" translate="yes" xml:space="preserve">
          <source>Spawns a new thread without any lifetime restrictions by taking ownership of the &lt;code&gt;Builder&lt;/code&gt;, and returns an &lt;a href=&quot;../io/type.result&quot;&gt;&lt;code&gt;io::Result&lt;/code&gt;&lt;/a&gt; to its &lt;a href=&quot;struct.joinhandle&quot;&gt;&lt;code&gt;JoinHandle&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Создает новый поток без каких-либо ограничений времени жизни, принимая на себя ответственность за &lt;code&gt;Builder&lt;/code&gt; , и возвращает &lt;a href=&quot;../io/type.result&quot;&gt; &lt;code&gt;io::Result&lt;/code&gt; &lt;/a&gt; своему &lt;a href=&quot;struct.joinhandle&quot;&gt; &lt;code&gt;JoinHandle&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="05b9b0a3d86e039bcc54742ca681657104d05e1f" translate="yes" xml:space="preserve">
          <source>Spawns a new thread, returning a &lt;a href=&quot;struct.joinhandle&quot;&gt;&lt;code&gt;JoinHandle&lt;/code&gt;&lt;/a&gt; for it.</source>
          <target state="translated">Создает новый поток, возвращая для него &lt;a href=&quot;struct.joinhandle&quot;&gt; &lt;code&gt;JoinHandle&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="325ea90d05b6256fb997f282a35a193bb878a063" translate="yes" xml:space="preserve">
          <source>Speaking of different ways to write this function, Listing 9-9 shows that there&amp;rsquo;s a way to make this even shorter.</source>
          <target state="translated">Говоря о различных способах написания этой функции, листинг 9-9 показывает, что есть способ сделать это еще короче.</target>
        </trans-unit>
        <trans-unit id="8528f5513b210fdc5ba63bbf7c9fcc5a49feb440" translate="yes" xml:space="preserve">
          <source>Special types and traits</source>
          <target state="translated">Специальные типы и черты</target>
        </trans-unit>
        <trans-unit id="ac4fd7fd5b591159d1aee83a6b7504035d209e56" translate="yes" xml:space="preserve">
          <source>Specialization only allows you to override &lt;code&gt;default&lt;/code&gt; functions in implementations.</source>
          <target state="translated">Специализация позволяет вам заменять только функции по &lt;code&gt;default&lt;/code&gt; в реализациях.</target>
        </trans-unit>
        <trans-unit id="2d00577e9194f109a205fbc91c68f0a3e7799e4d" translate="yes" xml:space="preserve">
          <source>Specifically, &lt;code&gt;size_hint()&lt;/code&gt; returns a tuple where the first element is the lower bound, and the second element is the upper bound.</source>
          <target state="translated">В частности, &lt;code&gt;size_hint()&lt;/code&gt; возвращает кортеж, в котором первый элемент является нижней границей, а второй элемент - верхней границей.</target>
        </trans-unit>
        <trans-unit id="80bb8eabe8ca6d37cb7c125a325bc00d052360f7" translate="yes" xml:space="preserve">
          <source>Specifically, you&amp;rsquo;ll learn about variables, basic types, functions, comments, and control flow. These foundations will be in every Rust program, and learning them early will give you a strong core to start from.</source>
          <target state="translated">В частности, вы узнаете о переменных, основных типах, функциях, комментариях и потоке управления. Эти основы будут в каждой программе на Rust, и их раннее изучение даст вам сильную основу для начала.</target>
        </trans-unit>
        <trans-unit id="4d422ba73af671dffcac7951c667b3d3523e7f2d" translate="yes" xml:space="preserve">
          <source>Specifies parameters to generic type in a type (e.g., &lt;code&gt;Vec&amp;lt;u8&amp;gt;&lt;/code&gt;)</source>
          <target state="translated">Задает параметры универсального типа в типе (например, &lt;code&gt;Vec&amp;lt;u8&amp;gt;&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="5848c6c54e7cf62a457a1ca7b8601c6891978fe7" translate="yes" xml:space="preserve">
          <source>Specifies parameters to generic type, function, or method in an expression; often referred to as turbofish (e.g., &lt;code&gt;&quot;42&quot;.parse::&amp;lt;i32&amp;gt;()&lt;/code&gt;)</source>
          <target state="translated">Задает параметры универсального типа, функции или метода в выражении; часто называют турбофиш (например, &lt;code&gt;&quot;42&quot;.parse::&amp;lt;i32&amp;gt;()&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="68e65850f75a9e00d279c77db1c7ca3ab3d82f87" translate="yes" xml:space="preserve">
          <source>Specifies the file extension used for shared libraries on this platform that goes after the dot. Example value is &lt;code&gt;so&lt;/code&gt;.</source>
          <target state="translated">Задает расширение файла, используемое для общих библиотек на этой платформе, которое ставится после точки. Примерное значение &lt;code&gt;so&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9cefdece2a06c3c0efa70639ac46798ab027b1c3" translate="yes" xml:space="preserve">
          <source>Specifies the file extension, if any, used for executable binaries on this platform. Example value is &lt;code&gt;exe&lt;/code&gt;.</source>
          <target state="translated">Задает расширение файла, если оно есть, используемое для исполняемых двоичных файлов на этой платформе. Примерное значение - &lt;code&gt;exe&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d8d9d5fb786047c6ab8ade0bb17752bf87883d0c" translate="yes" xml:space="preserve">
          <source>Specifies the filename prefix used for shared libraries on this platform. Example value is &lt;code&gt;lib&lt;/code&gt;.</source>
          <target state="translated">Задает префикс имени файла, используемый для разделяемых библиотек на этой платформе. Примерное значение - &lt;code&gt;lib&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="616edeb7819affd938929d61c6ce30b2bccea100" translate="yes" xml:space="preserve">
          <source>Specifies the filename suffix used for executable binaries on this platform. Example value is &lt;code&gt;.exe&lt;/code&gt;.</source>
          <target state="translated">Задает суффикс имени файла, используемый для исполняемых двоичных файлов на этой платформе. Примерное значение - &lt;code&gt;.exe&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="092de69a444716b03c470d8e276de2d325391db4" translate="yes" xml:space="preserve">
          <source>Specifies the filename suffix used for shared libraries on this platform. Example value is &lt;code&gt;.so&lt;/code&gt;.</source>
          <target state="translated">Задает суффикс имени файла, используемый для разделяемых библиотек на этой платформе. Примерное значение - &lt;code&gt;.so&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9d28aa36d621dad03992a1432875cb351ee9c51a" translate="yes" xml:space="preserve">
          <source>Specify the code to run when a value goes out of scope by implementing the &lt;code&gt;Drop&lt;/code&gt; trait. The &lt;code&gt;Drop&lt;/code&gt; trait requires you to implement one method named &lt;code&gt;drop&lt;/code&gt; that takes a mutable reference to &lt;code&gt;self&lt;/code&gt;. To see when Rust calls &lt;code&gt;drop&lt;/code&gt;, let&amp;rsquo;s implement &lt;code&gt;drop&lt;/code&gt; with &lt;code&gt;println!&lt;/code&gt; statements for now.</source>
          <target state="translated">Укажите код, который будет запускаться, когда значение выходит за пределы области видимости, реализовав &lt;code&gt;Drop&lt;/code&gt; . &lt;code&gt;Drop&lt;/code&gt; черта требует , чтобы реализовать один метод с именем &lt;code&gt;drop&lt;/code&gt; , который принимает изменяемую ссылку на &lt;code&gt;self&lt;/code&gt; . Чтобы увидеть, когда Rust вызывает &lt;code&gt;drop&lt;/code&gt; , давайте реализуем &lt;code&gt;drop&lt;/code&gt; с &lt;code&gt;println!&lt;/code&gt; заявления на данный момент.</target>
        </trans-unit>
        <trans-unit id="53bce43a089241f4c2fafff5a8b175cee67180c5" translate="yes" xml:space="preserve">
          <source>Specifying Multiple Trait Bounds with the &lt;code id=&quot;specifying-multiple-trait-bounds-with-the--syntax&quot;&gt;+&lt;/code&gt; Syntax</source>
          <target state="translated">Указание нескольких границ свойств с помощью синтаксиса &lt;code id=&quot;specifying-multiple-trait-bounds-with-the--syntax&quot;&gt;+&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="64d10a40d688450eabd55d43552d23834ffba599" translate="yes" xml:space="preserve">
          <source>Specifying Placeholder Types in Trait Definitions with Associated Types</source>
          <target state="translated">Указание типов владельцев площадей в определениях трейтов с ассоциированными типами</target>
        </trans-unit>
        <trans-unit id="da26747b5b8c997ced717129fbec68e2cdbe7a45" translate="yes" xml:space="preserve">
          <source>Specifying a relative path with &lt;code&gt;use&lt;/code&gt; is slightly different. Instead of starting from a name in the current scope, we must start the path given to &lt;code&gt;use&lt;/code&gt; with the keyword &lt;code&gt;self&lt;/code&gt;. Listing 7-12 shows how to specify a relative path to get the same behavior as in Listing 7-11.</source>
          <target state="translated">Указание относительного пути с &lt;code&gt;use&lt;/code&gt; немного отличается. Вместо того, чтобы начинать с имени в текущей области, мы должны начать путь, указанный для &lt;code&gt;use&lt;/code&gt; с ключевого слова &lt;code&gt;self&lt;/code&gt; . В листинге 7-12 показано, как указать относительный путь для получения того же поведения, что и в листинге 7-11.</target>
        </trans-unit>
        <trans-unit id="fc11eff720809c4cd493109eac5dc2d81ef40e9c" translate="yes" xml:space="preserve">
          <source>Specifying the trait name before the method name clarifies to Rust which implementation of &lt;code&gt;fly&lt;/code&gt; we want to call. We could also write &lt;code&gt;Human::fly(&amp;amp;person)&lt;/code&gt;, which is equivalent to the &lt;code&gt;person.fly()&lt;/code&gt; that we used in Listing 19-18, but this is a bit longer to write if we don&amp;rsquo;t need to disambiguate.</source>
          <target state="translated">Указание имени трейта перед именем метода проясняет Rust, какую реализацию &lt;code&gt;fly&lt;/code&gt; мы хотим вызвать. Мы также могли бы написать &lt;code&gt;Human::fly(&amp;amp;person)&lt;/code&gt; , который эквивалентен &lt;code&gt;person.fly()&lt;/code&gt; который мы использовали в листинге 19-18, но это немного больше времени для написания, если нам не нужно устранять неоднозначность.</target>
        </trans-unit>
        <trans-unit id="fdd3fcfb95f79f565b62aab40aff6c5797f83dce" translate="yes" xml:space="preserve">
          <source>Splice</source>
          <target state="translated">Splice</target>
        </trans-unit>
        <trans-unit id="102a13cdf7dd5683f20ca56504f851ec5d4093f7" translate="yes" xml:space="preserve">
          <source>Splice::all</source>
          <target state="translated">Splice::all</target>
        </trans-unit>
        <trans-unit id="babc83a710145cf29ba5445f9a833761727d85e2" translate="yes" xml:space="preserve">
          <source>Splice::any</source>
          <target state="translated">Splice::any</target>
        </trans-unit>
        <trans-unit id="a39117cda9a6799d2b046f5064ad27e81c8b7d5e" translate="yes" xml:space="preserve">
          <source>Splice::borrow</source>
          <target state="translated">Splice::borrow</target>
        </trans-unit>
        <trans-unit id="022eb3a4b4a3bd40f080da9a0e93e67b820b75b9" translate="yes" xml:space="preserve">
          <source>Splice::borrow_mut</source>
          <target state="translated">Splice::borrow_mut</target>
        </trans-unit>
        <trans-unit id="ff7eb6c2e890ee28b4d42522a568ad4b9b48c363" translate="yes" xml:space="preserve">
          <source>Splice::by_ref</source>
          <target state="translated">Splice::by_ref</target>
        </trans-unit>
        <trans-unit id="62d42f608770ea5ae5c702b0103a25bb0ca13a0f" translate="yes" xml:space="preserve">
          <source>Splice::chain</source>
          <target state="translated">Splice::chain</target>
        </trans-unit>
        <trans-unit id="451464e9658673df48db7da7c1a46940dbb41ff8" translate="yes" xml:space="preserve">
          <source>Splice::cloned</source>
          <target state="translated">Splice::cloned</target>
        </trans-unit>
        <trans-unit id="2bbc8d6617fd04cbf168523ef4090fec6bf1a14d" translate="yes" xml:space="preserve">
          <source>Splice::cmp</source>
          <target state="translated">Splice::cmp</target>
        </trans-unit>
        <trans-unit id="5f8a1da44559a77b748b3f6abf002f9d0db173bf" translate="yes" xml:space="preserve">
          <source>Splice::collect</source>
          <target state="translated">Splice::collect</target>
        </trans-unit>
        <trans-unit id="3b7f7a8c970a343e1eaadb07c2da66c9efd7e77d" translate="yes" xml:space="preserve">
          <source>Splice::copied</source>
          <target state="translated">Splice::copied</target>
        </trans-unit>
        <trans-unit id="ba54e7ed93441b38a9b01983d469ce12f568db6f" translate="yes" xml:space="preserve">
          <source>Splice::count</source>
          <target state="translated">Splice::count</target>
        </trans-unit>
        <trans-unit id="45d4337a700716d7839d3746c85fc7fc40d5988a" translate="yes" xml:space="preserve">
          <source>Splice::cycle</source>
          <target state="translated">Splice::cycle</target>
        </trans-unit>
        <trans-unit id="53242c9915296db70b6a71a2cde8eb9109c0f23d" translate="yes" xml:space="preserve">
          <source>Splice::drop</source>
          <target state="translated">Splice::drop</target>
        </trans-unit>
        <trans-unit id="0071535faec3336e523e6d1a1272b46979258d35" translate="yes" xml:space="preserve">
          <source>Splice::enumerate</source>
          <target state="translated">Splice::enumerate</target>
        </trans-unit>
        <trans-unit id="01e94ace5d2cfe2543e74dfb7fa0055a44ee9fea" translate="yes" xml:space="preserve">
          <source>Splice::eq</source>
          <target state="translated">Splice::eq</target>
        </trans-unit>
        <trans-unit id="dd000471f364dceac679d4352065fa0ae0e8c457" translate="yes" xml:space="preserve">
          <source>Splice::filter</source>
          <target state="translated">Splice::filter</target>
        </trans-unit>
        <trans-unit id="5e358571c8faf5b751e10a1cd686dd036ecc316c" translate="yes" xml:space="preserve">
          <source>Splice::filter_map</source>
          <target state="translated">Splice::filter_map</target>
        </trans-unit>
        <trans-unit id="961a4aa3a919c6a8b919240300dc2fd22d2c1c91" translate="yes" xml:space="preserve">
          <source>Splice::find</source>
          <target state="translated">Splice::find</target>
        </trans-unit>
        <trans-unit id="486f11abd990d21f3257c01a71e7f28db5506a8c" translate="yes" xml:space="preserve">
          <source>Splice::find_map</source>
          <target state="translated">Splice::find_map</target>
        </trans-unit>
        <trans-unit id="8f321bf0b2ca33ebb6a97663107e3617ec2c137e" translate="yes" xml:space="preserve">
          <source>Splice::flat_map</source>
          <target state="translated">Splice::flat_map</target>
        </trans-unit>
        <trans-unit id="499eeb25b3b20a78fb1cd8b34ee0f1a13abf1370" translate="yes" xml:space="preserve">
          <source>Splice::flatten</source>
          <target state="translated">Splice::flatten</target>
        </trans-unit>
        <trans-unit id="ce5fb222ef2ec7c095e8b6e325fe96997504ba61" translate="yes" xml:space="preserve">
          <source>Splice::fmt</source>
          <target state="translated">Splice::fmt</target>
        </trans-unit>
        <trans-unit id="c6a7ba92d0ef033b5d48af7d964a50a86e18162a" translate="yes" xml:space="preserve">
          <source>Splice::fold</source>
          <target state="translated">Splice::fold</target>
        </trans-unit>
        <trans-unit id="e82705600b1f26364c718836b0449d586d4eb1ea" translate="yes" xml:space="preserve">
          <source>Splice::for_each</source>
          <target state="translated">Splice::for_each</target>
        </trans-unit>
        <trans-unit id="21323427a2a29a43c17c997c3dbd79b674bfb4e8" translate="yes" xml:space="preserve">
          <source>Splice::from</source>
          <target state="translated">Splice::from</target>
        </trans-unit>
        <trans-unit id="a7cead373f4b952225e0764832f3c62efdc4a6cf" translate="yes" xml:space="preserve">
          <source>Splice::fuse</source>
          <target state="translated">Splice::fuse</target>
        </trans-unit>
        <trans-unit id="aa50f3408da9d84c54899b17015b29bbede05d5b" translate="yes" xml:space="preserve">
          <source>Splice::ge</source>
          <target state="translated">Splice::ge</target>
        </trans-unit>
        <trans-unit id="e32ac27b7a480cce928d49c2b1bc40e73780fecd" translate="yes" xml:space="preserve">
          <source>Splice::gt</source>
          <target state="translated">Splice::gt</target>
        </trans-unit>
        <trans-unit id="38eceb5e345323b05e52c82393da17d52e70cbe9" translate="yes" xml:space="preserve">
          <source>Splice::inspect</source>
          <target state="translated">Splice::inspect</target>
        </trans-unit>
        <trans-unit id="491d5b0b46d1c2d818131b73e335fe5ca82e5b48" translate="yes" xml:space="preserve">
          <source>Splice::into</source>
          <target state="translated">Splice::into</target>
        </trans-unit>
        <trans-unit id="98f2ae726cd2762c1db54d8758051fc1261e16cf" translate="yes" xml:space="preserve">
          <source>Splice::into_iter</source>
          <target state="translated">Splice::into_iter</target>
        </trans-unit>
        <trans-unit id="383d95f7f63652db96cc3aec4aa2d1b740db1135" translate="yes" xml:space="preserve">
          <source>Splice::is_empty</source>
          <target state="translated">Splice::is_empty</target>
        </trans-unit>
        <trans-unit id="e65d1565e1f581593a8ecd6e860dd977c23b52c9" translate="yes" xml:space="preserve">
          <source>Splice::is_sorted</source>
          <target state="translated">Splice::is_sorted</target>
        </trans-unit>
        <trans-unit id="4fcaeab7099b38cf11d286c70e6781f06cf82691" translate="yes" xml:space="preserve">
          <source>Splice::is_sorted_by</source>
          <target state="translated">Splice::is_sorted_by</target>
        </trans-unit>
        <trans-unit id="18bddef0dba34d9e52d2fa579f0e69e1694f8f0e" translate="yes" xml:space="preserve">
          <source>Splice::is_sorted_by_key</source>
          <target state="translated">Splice::is_sorted_by_key</target>
        </trans-unit>
        <trans-unit id="ba7524a53544c3d3016b167f7fc9deb79720b18f" translate="yes" xml:space="preserve">
          <source>Splice::last</source>
          <target state="translated">Splice::last</target>
        </trans-unit>
        <trans-unit id="f570faebe931a784fb2709e99800059f3f92a268" translate="yes" xml:space="preserve">
          <source>Splice::le</source>
          <target state="translated">Splice::le</target>
        </trans-unit>
        <trans-unit id="ac9374e537a63770b62a448312472a9dc3d4a8ab" translate="yes" xml:space="preserve">
          <source>Splice::len</source>
          <target state="translated">Splice::len</target>
        </trans-unit>
        <trans-unit id="6d78866daf059bac4c1db0a3f185ee417ae09fe8" translate="yes" xml:space="preserve">
          <source>Splice::lt</source>
          <target state="translated">Splice::lt</target>
        </trans-unit>
        <trans-unit id="363a586253b0de42e9bc51b01820d6cd56b4a63e" translate="yes" xml:space="preserve">
          <source>Splice::map</source>
          <target state="translated">Splice::map</target>
        </trans-unit>
        <trans-unit id="c5cfae9189da826784c424506a8955cf97bff5a5" translate="yes" xml:space="preserve">
          <source>Splice::max</source>
          <target state="translated">Splice::max</target>
        </trans-unit>
        <trans-unit id="a8c3e4f24cc13f365be780b3805514395ccbc405" translate="yes" xml:space="preserve">
          <source>Splice::max_by</source>
          <target state="translated">Splice::max_by</target>
        </trans-unit>
        <trans-unit id="8229392864f24a74b716976cb653abe3703dd9f1" translate="yes" xml:space="preserve">
          <source>Splice::max_by_key</source>
          <target state="translated">Splice::max_by_key</target>
        </trans-unit>
        <trans-unit id="d703d1486f11021ef75c055680b2b99db9b75899" translate="yes" xml:space="preserve">
          <source>Splice::min</source>
          <target state="translated">Splice::min</target>
        </trans-unit>
        <trans-unit id="0ab332500f5703d676d91657b86bf9e1965dcf11" translate="yes" xml:space="preserve">
          <source>Splice::min_by</source>
          <target state="translated">Splice::min_by</target>
        </trans-unit>
        <trans-unit id="1f553ce50563a0a28d5de7bfe1638bab7dca6dc2" translate="yes" xml:space="preserve">
          <source>Splice::min_by_key</source>
          <target state="translated">Splice::min_by_key</target>
        </trans-unit>
        <trans-unit id="ba29255cd5c58d38127acf8b53877bd8c7828c4f" translate="yes" xml:space="preserve">
          <source>Splice::ne</source>
          <target state="translated">Splice::ne</target>
        </trans-unit>
        <trans-unit id="30d321559302113af9914b75260c174c9412f906" translate="yes" xml:space="preserve">
          <source>Splice::next</source>
          <target state="translated">Splice::next</target>
        </trans-unit>
        <trans-unit id="b4a407cbe153bcddb6c861793351fb23454f3a5b" translate="yes" xml:space="preserve">
          <source>Splice::next_back</source>
          <target state="translated">Splice::next_back</target>
        </trans-unit>
        <trans-unit id="cf6219bb4e39772af2093b7bc00b413958c3ae44" translate="yes" xml:space="preserve">
          <source>Splice::nth</source>
          <target state="translated">Splice::nth</target>
        </trans-unit>
        <trans-unit id="a5a9ee518d12670f202aa4ce6973ff33a0df7922" translate="yes" xml:space="preserve">
          <source>Splice::nth_back</source>
          <target state="translated">Splice::nth_back</target>
        </trans-unit>
        <trans-unit id="9b21bc4e106668f934eb7f233a9ca2cc44a6a913" translate="yes" xml:space="preserve">
          <source>Splice::partial_cmp</source>
          <target state="translated">Splice::partial_cmp</target>
        </trans-unit>
        <trans-unit id="1dee4e2895d327033ad3c3b66c820542684a464e" translate="yes" xml:space="preserve">
          <source>Splice::partition</source>
          <target state="translated">Splice::partition</target>
        </trans-unit>
        <trans-unit id="aa1db17c392f556e335fcce5561711bb05a03b92" translate="yes" xml:space="preserve">
          <source>Splice::peekable</source>
          <target state="translated">Splice::peekable</target>
        </trans-unit>
        <trans-unit id="1eadd0033d01820bc0d97f1f2e33d53eb5ec1779" translate="yes" xml:space="preserve">
          <source>Splice::position</source>
          <target state="translated">Splice::position</target>
        </trans-unit>
        <trans-unit id="666018549e296c04d8c5c52771470078bbb7862a" translate="yes" xml:space="preserve">
          <source>Splice::product</source>
          <target state="translated">Splice::product</target>
        </trans-unit>
        <trans-unit id="ecd9316bd8bc61c51b016bdd8cd9883015f5c3cd" translate="yes" xml:space="preserve">
          <source>Splice::rev</source>
          <target state="translated">Splice::rev</target>
        </trans-unit>
        <trans-unit id="7386f1859ba07bbd5f17923107c38e480304fbfe" translate="yes" xml:space="preserve">
          <source>Splice::rfind</source>
          <target state="translated">Splice::rfind</target>
        </trans-unit>
        <trans-unit id="24ba7570e44bb8b3aea278a77720639f4e59dfd0" translate="yes" xml:space="preserve">
          <source>Splice::rfold</source>
          <target state="translated">Splice::rfold</target>
        </trans-unit>
        <trans-unit id="ec2cdc5eaa84d8e2631b6832f7d4a8fdd17a6bc4" translate="yes" xml:space="preserve">
          <source>Splice::rposition</source>
          <target state="translated">Splice::rposition</target>
        </trans-unit>
        <trans-unit id="fabc1d12e61dba4a5c5c2c6b1924c2c5f8609f4c" translate="yes" xml:space="preserve">
          <source>Splice::scan</source>
          <target state="translated">Splice::scan</target>
        </trans-unit>
        <trans-unit id="8d5ee36fd72fb3460109d468d4d74555827a0ee9" translate="yes" xml:space="preserve">
          <source>Splice::size_hint</source>
          <target state="translated">Splice::size_hint</target>
        </trans-unit>
        <trans-unit id="09f288b17a862c019979176e29e7ccea42d1dedc" translate="yes" xml:space="preserve">
          <source>Splice::skip</source>
          <target state="translated">Splice::skip</target>
        </trans-unit>
        <trans-unit id="3d180d62d277f379bb8a60b4f1823d06b1bfa2e6" translate="yes" xml:space="preserve">
          <source>Splice::skip_while</source>
          <target state="translated">Splice::skip_while</target>
        </trans-unit>
        <trans-unit id="cd11d5291334a37b5de45419d0b7eedb5e4469cb" translate="yes" xml:space="preserve">
          <source>Splice::step_by</source>
          <target state="translated">Splice::step_by</target>
        </trans-unit>
        <trans-unit id="831a4f097a3c47319b54babc561d38910f170c02" translate="yes" xml:space="preserve">
          <source>Splice::sum</source>
          <target state="translated">Splice::sum</target>
        </trans-unit>
        <trans-unit id="3c5d879dcd505f6b39c7518de9b235dc8c01e4fc" translate="yes" xml:space="preserve">
          <source>Splice::take</source>
          <target state="translated">Splice::take</target>
        </trans-unit>
        <trans-unit id="2d71962fbf8d0ead68d89535d6778944abcdc679" translate="yes" xml:space="preserve">
          <source>Splice::take_while</source>
          <target state="translated">Splice::take_while</target>
        </trans-unit>
        <trans-unit id="38f93c9f33eeb59968290a7e0897c1f55f96c687" translate="yes" xml:space="preserve">
          <source>Splice::try_fold</source>
          <target state="translated">Splice::try_fold</target>
        </trans-unit>
        <trans-unit id="724df3527b404d3a53b3e31356080824d05c7816" translate="yes" xml:space="preserve">
          <source>Splice::try_for_each</source>
          <target state="translated">Splice::try_for_each</target>
        </trans-unit>
        <trans-unit id="fd574e8628936827c6ae9027b872e02aa508a457" translate="yes" xml:space="preserve">
          <source>Splice::try_from</source>
          <target state="translated">Splice::try_from</target>
        </trans-unit>
        <trans-unit id="eb53ae611017056488d398b33cbbc3d7954de6ee" translate="yes" xml:space="preserve">
          <source>Splice::try_into</source>
          <target state="translated">Splice::try_into</target>
        </trans-unit>
        <trans-unit id="44e12332c99bd4ce49d2bb351c49223807207dd9" translate="yes" xml:space="preserve">
          <source>Splice::try_rfold</source>
          <target state="translated">Splice::try_rfold</target>
        </trans-unit>
        <trans-unit id="161d232f5fe792d5ecbec788482e69487e0c0d56" translate="yes" xml:space="preserve">
          <source>Splice::type_id</source>
          <target state="translated">Splice::type_id</target>
        </trans-unit>
        <trans-unit id="1bbfd48d60c0a4558b463911dbf85558f413ffa6" translate="yes" xml:space="preserve">
          <source>Splice::unzip</source>
          <target state="translated">Splice::unzip</target>
        </trans-unit>
        <trans-unit id="08e4a64b53c528f2a546f45e3fc516d0e8819ad4" translate="yes" xml:space="preserve">
          <source>Splice::zip</source>
          <target state="translated">Splice::zip</target>
        </trans-unit>
        <trans-unit id="fc8230b4119ad4b994db2324d71f4e0ae7ad932c" translate="yes" xml:space="preserve">
          <source>Split</source>
          <target state="translated">Split</target>
        </trans-unit>
        <trans-unit id="b97656a3c38e1335485a4b3a9614459a6c47d666" translate="yes" xml:space="preserve">
          <source>Split your program into a &lt;em&gt;main.rs&lt;/em&gt; and a &lt;em&gt;lib.rs&lt;/em&gt; and move your program&amp;rsquo;s logic to &lt;em&gt;lib.rs&lt;/em&gt;.</source>
          <target state="translated">Разделить вашу программу в &lt;em&gt;main.rs&lt;/em&gt; и через &lt;em&gt;lib.rs&lt;/em&gt; и переместить логику вашей программы в &lt;em&gt;lib.rs&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="50d9b1e83df2fc97d5402e500dababd9cd5b96e5" translate="yes" xml:space="preserve">
          <source>Split::all</source>
          <target state="translated">Split::all</target>
        </trans-unit>
        <trans-unit id="c3ffc2df77467ddf70ca7e247ca14fe7bf5358c5" translate="yes" xml:space="preserve">
          <source>Split::any</source>
          <target state="translated">Split::any</target>
        </trans-unit>
        <trans-unit id="ddee622860a4181fe41501ad32f30df9891bae71" translate="yes" xml:space="preserve">
          <source>Split::borrow</source>
          <target state="translated">Split::borrow</target>
        </trans-unit>
        <trans-unit id="fd8aa3f4c0c069bec8b3cc99e23a4f97d1e387e5" translate="yes" xml:space="preserve">
          <source>Split::borrow_mut</source>
          <target state="translated">Split::borrow_mut</target>
        </trans-unit>
        <trans-unit id="60a9acc7030fe94d73196e5eb6bc9945c2cb214d" translate="yes" xml:space="preserve">
          <source>Split::by_ref</source>
          <target state="translated">Split::by_ref</target>
        </trans-unit>
        <trans-unit id="07781b46907c350ec31533fd95ff333fb83f4672" translate="yes" xml:space="preserve">
          <source>Split::chain</source>
          <target state="translated">Split::chain</target>
        </trans-unit>
        <trans-unit id="01414495bfb2107bcb842363eaa2aaefde42adcb" translate="yes" xml:space="preserve">
          <source>Split::clone</source>
          <target state="translated">Split::clone</target>
        </trans-unit>
        <trans-unit id="8fa94e8f3a6947468861d014a2242e7e533419de" translate="yes" xml:space="preserve">
          <source>Split::clone_from</source>
          <target state="translated">Split::clone_from</target>
        </trans-unit>
        <trans-unit id="9fabd2265062c7c41c7e60fd2c8e2d73bfd612ce" translate="yes" xml:space="preserve">
          <source>Split::clone_into</source>
          <target state="translated">Split::clone_into</target>
        </trans-unit>
        <trans-unit id="11b7d114dd91e3f592d1c2b7c0ca525a9ce90a2b" translate="yes" xml:space="preserve">
          <source>Split::cloned</source>
          <target state="translated">Split::cloned</target>
        </trans-unit>
        <trans-unit id="f1939db29648a91dd7990b7724eaa4701118728c" translate="yes" xml:space="preserve">
          <source>Split::cmp</source>
          <target state="translated">Split::cmp</target>
        </trans-unit>
        <trans-unit id="feb6a82b0f70e568351ee948035313650d3cdcae" translate="yes" xml:space="preserve">
          <source>Split::collect</source>
          <target state="translated">Split::collect</target>
        </trans-unit>
        <trans-unit id="f42c61d8dcd2768f77ba1f6b43cf6d82bfd95a0c" translate="yes" xml:space="preserve">
          <source>Split::copied</source>
          <target state="translated">Split::copied</target>
        </trans-unit>
        <trans-unit id="11a6cf772057ae6ae09af76efbe481b7757c7027" translate="yes" xml:space="preserve">
          <source>Split::count</source>
          <target state="translated">Split::count</target>
        </trans-unit>
        <trans-unit id="a5c31ec93192ead6403df1675cb15b6ee7b4d58b" translate="yes" xml:space="preserve">
          <source>Split::cycle</source>
          <target state="translated">Split::cycle</target>
        </trans-unit>
        <trans-unit id="290ea8f15ce52868f93720412912e4fac41386bc" translate="yes" xml:space="preserve">
          <source>Split::enumerate</source>
          <target state="translated">Split::enumerate</target>
        </trans-unit>
        <trans-unit id="6470537034febc0a41d05fe1b8c54e6642ed5710" translate="yes" xml:space="preserve">
          <source>Split::eq</source>
          <target state="translated">Split::eq</target>
        </trans-unit>
        <trans-unit id="3e0182cc7cce03790b888fd7e5621fa6310f5671" translate="yes" xml:space="preserve">
          <source>Split::filter</source>
          <target state="translated">Split::filter</target>
        </trans-unit>
        <trans-unit id="e022fab0242f750d87a4773ec168842ee2272b50" translate="yes" xml:space="preserve">
          <source>Split::filter_map</source>
          <target state="translated">Split::filter_map</target>
        </trans-unit>
        <trans-unit id="e47d64b530b616f401c93bae4ee8bf3ff9c2c2ad" translate="yes" xml:space="preserve">
          <source>Split::find</source>
          <target state="translated">Split::find</target>
        </trans-unit>
        <trans-unit id="276ea1a6ed0ab1a1afa6d11176c14710591f7017" translate="yes" xml:space="preserve">
          <source>Split::find_map</source>
          <target state="translated">Split::find_map</target>
        </trans-unit>
        <trans-unit id="dbc673f557faad90dab8cfd1589d478be4cca50d" translate="yes" xml:space="preserve">
          <source>Split::flat_map</source>
          <target state="translated">Split::flat_map</target>
        </trans-unit>
        <trans-unit id="3eb3bdbfcf189cdbddc53ee7c555d0c894120388" translate="yes" xml:space="preserve">
          <source>Split::flatten</source>
          <target state="translated">Split::flatten</target>
        </trans-unit>
        <trans-unit id="0d8b40866f46797be348740ff483561e720809ce" translate="yes" xml:space="preserve">
          <source>Split::fmt</source>
          <target state="translated">Split::fmt</target>
        </trans-unit>
        <trans-unit id="8a69413ed1025ab5a65e6ad7a67e546a9b1537d6" translate="yes" xml:space="preserve">
          <source>Split::fold</source>
          <target state="translated">Split::fold</target>
        </trans-unit>
        <trans-unit id="3adabc4c500f9a537343e92dac5c4991923519ed" translate="yes" xml:space="preserve">
          <source>Split::for_each</source>
          <target state="translated">Split::for_each</target>
        </trans-unit>
        <trans-unit id="441247b5ec062b07c88a33c5175e2910780529cc" translate="yes" xml:space="preserve">
          <source>Split::from</source>
          <target state="translated">Split::from</target>
        </trans-unit>
        <trans-unit id="b1a6fc85bc1161a4514f86f6e96450c7f841e4e4" translate="yes" xml:space="preserve">
          <source>Split::fuse</source>
          <target state="translated">Split::fuse</target>
        </trans-unit>
        <trans-unit id="5aac8922d817b4d53555c678b593594282426858" translate="yes" xml:space="preserve">
          <source>Split::ge</source>
          <target state="translated">Split::ge</target>
        </trans-unit>
        <trans-unit id="feaa50f076eb0484c6e0fefa6a6827d3da0bd1c7" translate="yes" xml:space="preserve">
          <source>Split::gt</source>
          <target state="translated">Split::gt</target>
        </trans-unit>
        <trans-unit id="7bd592077ce46ab7b90f4261897ca14b87ec5194" translate="yes" xml:space="preserve">
          <source>Split::inspect</source>
          <target state="translated">Split::inspect</target>
        </trans-unit>
        <trans-unit id="588a8db2c9edb4b478b5d1594d123060d448e1a9" translate="yes" xml:space="preserve">
          <source>Split::into</source>
          <target state="translated">Split::into</target>
        </trans-unit>
        <trans-unit id="e970a8d04d9e36a414020b04dff64a969290f0f1" translate="yes" xml:space="preserve">
          <source>Split::into_iter</source>
          <target state="translated">Split::into_iter</target>
        </trans-unit>
        <trans-unit id="0a8f968378caa772c20086c35351d82df1837972" translate="yes" xml:space="preserve">
          <source>Split::is_sorted</source>
          <target state="translated">Split::is_sorted</target>
        </trans-unit>
        <trans-unit id="34056b76c665f7be79e8651e1c8f20d425717c78" translate="yes" xml:space="preserve">
          <source>Split::is_sorted_by</source>
          <target state="translated">Split::is_sorted_by</target>
        </trans-unit>
        <trans-unit id="76b13879897a61dc42dca33af29cc9bc2fc2760d" translate="yes" xml:space="preserve">
          <source>Split::is_sorted_by_key</source>
          <target state="translated">Split::is_sorted_by_key</target>
        </trans-unit>
        <trans-unit id="9bc119d9f67f43b057707fffaec9815374669138" translate="yes" xml:space="preserve">
          <source>Split::last</source>
          <target state="translated">Split::last</target>
        </trans-unit>
        <trans-unit id="e5d43b05e2041fda9086dcf3f35965b6a24007b5" translate="yes" xml:space="preserve">
          <source>Split::le</source>
          <target state="translated">Split::le</target>
        </trans-unit>
        <trans-unit id="ba589e923802be4e070003ef40aa8845efddce27" translate="yes" xml:space="preserve">
          <source>Split::lt</source>
          <target state="translated">Split::lt</target>
        </trans-unit>
        <trans-unit id="b38fb187055514eb72383463c85da215f3da4fe1" translate="yes" xml:space="preserve">
          <source>Split::map</source>
          <target state="translated">Split::map</target>
        </trans-unit>
        <trans-unit id="e010482e64f9c285ae88cf82df5b76db7cf2b649" translate="yes" xml:space="preserve">
          <source>Split::max</source>
          <target state="translated">Split::max</target>
        </trans-unit>
        <trans-unit id="5eab3fa296e8537a093d5f5e8063c2f02f582fba" translate="yes" xml:space="preserve">
          <source>Split::max_by</source>
          <target state="translated">Split::max_by</target>
        </trans-unit>
        <trans-unit id="258517aa4008cfc72777c2376c53d21374bd5656" translate="yes" xml:space="preserve">
          <source>Split::max_by_key</source>
          <target state="translated">Split::max_by_key</target>
        </trans-unit>
        <trans-unit id="bc50a26f402b344fb899caf810b0def30e5d1dca" translate="yes" xml:space="preserve">
          <source>Split::min</source>
          <target state="translated">Split::min</target>
        </trans-unit>
        <trans-unit id="f1ad32652850da8822d09826affb4648a0d39632" translate="yes" xml:space="preserve">
          <source>Split::min_by</source>
          <target state="translated">Split::min_by</target>
        </trans-unit>
        <trans-unit id="fee1bae7b3b47edea9d46ac3dac894f4fd1614c5" translate="yes" xml:space="preserve">
          <source>Split::min_by_key</source>
          <target state="translated">Split::min_by_key</target>
        </trans-unit>
        <trans-unit id="ab21044e56e236570fbb48ceb8f4b82b8833a4fe" translate="yes" xml:space="preserve">
          <source>Split::ne</source>
          <target state="translated">Split::ne</target>
        </trans-unit>
        <trans-unit id="69e1332ab0eef325213c7889d02322cfa1281bb4" translate="yes" xml:space="preserve">
          <source>Split::next</source>
          <target state="translated">Split::next</target>
        </trans-unit>
        <trans-unit id="2cd815c7af10d8b0bc5d16dbaa70a6b69527c1b7" translate="yes" xml:space="preserve">
          <source>Split::next_back</source>
          <target state="translated">Split::next_back</target>
        </trans-unit>
        <trans-unit id="4e856029c7f1d106a5cf5fc1becf8a15422b108e" translate="yes" xml:space="preserve">
          <source>Split::nth</source>
          <target state="translated">Split::nth</target>
        </trans-unit>
        <trans-unit id="7b4860833d4ad747b5e65a8f370fada4a1432fd6" translate="yes" xml:space="preserve">
          <source>Split::nth_back</source>
          <target state="translated">Split::nth_back</target>
        </trans-unit>
        <trans-unit id="dc1b0229941cf8b20d138b1023eebccf8451cf32" translate="yes" xml:space="preserve">
          <source>Split::partial_cmp</source>
          <target state="translated">Split::partial_cmp</target>
        </trans-unit>
        <trans-unit id="c7d9913162c3677d8bac12afb6a694f5f105a9f8" translate="yes" xml:space="preserve">
          <source>Split::partition</source>
          <target state="translated">Split::partition</target>
        </trans-unit>
        <trans-unit id="961d77a032a928d54913ed6eca45b6e06e6c8174" translate="yes" xml:space="preserve">
          <source>Split::peekable</source>
          <target state="translated">Split::peekable</target>
        </trans-unit>
        <trans-unit id="ae9169bc8be272cfa23e68cd5f4e426a1e2b3961" translate="yes" xml:space="preserve">
          <source>Split::position</source>
          <target state="translated">Split::position</target>
        </trans-unit>
        <trans-unit id="87890f06d77b6968728d8ee9694097de4c610bb8" translate="yes" xml:space="preserve">
          <source>Split::product</source>
          <target state="translated">Split::product</target>
        </trans-unit>
        <trans-unit id="35213fb752a5b5bbb276ab01ac84176b7251c52d" translate="yes" xml:space="preserve">
          <source>Split::rev</source>
          <target state="translated">Split::rev</target>
        </trans-unit>
        <trans-unit id="ee209e46c7f8b6e5cd6aed47575d93ce798e401f" translate="yes" xml:space="preserve">
          <source>Split::rfind</source>
          <target state="translated">Split::rfind</target>
        </trans-unit>
        <trans-unit id="32d95393bf8ae13a3852962e06783efb871b80a6" translate="yes" xml:space="preserve">
          <source>Split::rfold</source>
          <target state="translated">Split::rfold</target>
        </trans-unit>
        <trans-unit id="07f05471920b2b3f6656d2b04abe680cef524a88" translate="yes" xml:space="preserve">
          <source>Split::rposition</source>
          <target state="translated">Split::rposition</target>
        </trans-unit>
        <trans-unit id="7a1c3c74c8ae0725d19081f4a1ca841d9fd2dec7" translate="yes" xml:space="preserve">
          <source>Split::scan</source>
          <target state="translated">Split::scan</target>
        </trans-unit>
        <trans-unit id="7c0fc0bdc609dfa382892d64a2a7e3a2efeff0de" translate="yes" xml:space="preserve">
          <source>Split::size_hint</source>
          <target state="translated">Split::size_hint</target>
        </trans-unit>
        <trans-unit id="5af2bd4e57bf3b46ae39e915378f1f2dbc608a46" translate="yes" xml:space="preserve">
          <source>Split::skip</source>
          <target state="translated">Split::skip</target>
        </trans-unit>
        <trans-unit id="740bee51d776f693585c9e5594be146cb3db6aa1" translate="yes" xml:space="preserve">
          <source>Split::skip_while</source>
          <target state="translated">Split::skip_while</target>
        </trans-unit>
        <trans-unit id="0d27ff1a798e23835ac66bd88e625680c9c8c9f7" translate="yes" xml:space="preserve">
          <source>Split::step_by</source>
          <target state="translated">Split::step_by</target>
        </trans-unit>
        <trans-unit id="179b66ffe02b59141755cfc1241777501fd7543e" translate="yes" xml:space="preserve">
          <source>Split::sum</source>
          <target state="translated">Split::sum</target>
        </trans-unit>
        <trans-unit id="6d463898bdb1cb53234bbf848897fcbba8190ee0" translate="yes" xml:space="preserve">
          <source>Split::take</source>
          <target state="translated">Split::take</target>
        </trans-unit>
        <trans-unit id="7f6a952a1692b07553718cdc67d432973b1261e1" translate="yes" xml:space="preserve">
          <source>Split::take_while</source>
          <target state="translated">Split::take_while</target>
        </trans-unit>
        <trans-unit id="9ca43b1a3f4230d0fef2b187d47fb55d37acabdf" translate="yes" xml:space="preserve">
          <source>Split::to_owned</source>
          <target state="translated">Split::to_owned</target>
        </trans-unit>
        <trans-unit id="b50e56f5abdcbb35ebe7d1b6cc547e72ace802bd" translate="yes" xml:space="preserve">
          <source>Split::try_fold</source>
          <target state="translated">Split::try_fold</target>
        </trans-unit>
        <trans-unit id="015e63b25160f6122fe77dd744701849d9a03a5f" translate="yes" xml:space="preserve">
          <source>Split::try_for_each</source>
          <target state="translated">Split::try_for_each</target>
        </trans-unit>
        <trans-unit id="68511a9a23952d6eccceb051a625074d14965f9a" translate="yes" xml:space="preserve">
          <source>Split::try_from</source>
          <target state="translated">Split::try_from</target>
        </trans-unit>
        <trans-unit id="31717709fc95ec449f7ce525fcbd0b5e5f3174f9" translate="yes" xml:space="preserve">
          <source>Split::try_into</source>
          <target state="translated">Split::try_into</target>
        </trans-unit>
        <trans-unit id="784b035c4e8a4134d459c72a4ea7e69712c8c22e" translate="yes" xml:space="preserve">
          <source>Split::try_rfold</source>
          <target state="translated">Split::try_rfold</target>
        </trans-unit>
        <trans-unit id="e3c1ce2c5493f1c93f55d45c9500cdbc16c2ca3b" translate="yes" xml:space="preserve">
          <source>Split::type_id</source>
          <target state="translated">Split::type_id</target>
        </trans-unit>
        <trans-unit id="8f95043837c49c3998da677e92b7a8f0155033d9" translate="yes" xml:space="preserve">
          <source>Split::unzip</source>
          <target state="translated">Split::unzip</target>
        </trans-unit>
        <trans-unit id="93f6cd29447a8f906199ee1ad7e5720c410a92aa" translate="yes" xml:space="preserve">
          <source>Split::zip</source>
          <target state="translated">Split::zip</target>
        </trans-unit>
        <trans-unit id="126441d014f1cdde4fdac3cf99d9f344d0bb738b" translate="yes" xml:space="preserve">
          <source>SplitAsciiWhitespace</source>
          <target state="translated">SplitAsciiWhitespace</target>
        </trans-unit>
        <trans-unit id="1a0393d90d30f312db7ace8ae16c5d8e83f07cf8" translate="yes" xml:space="preserve">
          <source>SplitAsciiWhitespace::all</source>
          <target state="translated">SplitAsciiWhitespace::all</target>
        </trans-unit>
        <trans-unit id="80e240cfb292a71b796ce9a9722f1db158dff38d" translate="yes" xml:space="preserve">
          <source>SplitAsciiWhitespace::any</source>
          <target state="translated">SplitAsciiWhitespace::any</target>
        </trans-unit>
        <trans-unit id="4056ffa7082c494913e3962285b8d66bad26f48f" translate="yes" xml:space="preserve">
          <source>SplitAsciiWhitespace::borrow</source>
          <target state="translated">SplitAsciiWhitespace::borrow</target>
        </trans-unit>
        <trans-unit id="4ecb54d68e57f98ef8b096145f822aad8723da51" translate="yes" xml:space="preserve">
          <source>SplitAsciiWhitespace::borrow_mut</source>
          <target state="translated">SplitAsciiWhitespace::borrow_mut</target>
        </trans-unit>
        <trans-unit id="35d40b06c1ff423c4ece2e8e26dfdb363af15974" translate="yes" xml:space="preserve">
          <source>SplitAsciiWhitespace::by_ref</source>
          <target state="translated">SplitAsciiWhitespace::by_ref</target>
        </trans-unit>
        <trans-unit id="3f2e1fcae7af96f2dc58b6072c0d1b0f150d1ae6" translate="yes" xml:space="preserve">
          <source>SplitAsciiWhitespace::chain</source>
          <target state="translated">SplitAsciiWhitespace::chain</target>
        </trans-unit>
        <trans-unit id="97ad72f7c00e04dc3282ab746019df15b15c4bc9" translate="yes" xml:space="preserve">
          <source>SplitAsciiWhitespace::clone</source>
          <target state="translated">SplitAsciiWhitespace::clone</target>
        </trans-unit>
        <trans-unit id="1576477caecfd8aec2064710b011e54b8d2b6071" translate="yes" xml:space="preserve">
          <source>SplitAsciiWhitespace::clone_from</source>
          <target state="translated">SplitAsciiWhitespace::clone_from</target>
        </trans-unit>
        <trans-unit id="27b9026274da398d76f9e9878799eb4b6464c4f1" translate="yes" xml:space="preserve">
          <source>SplitAsciiWhitespace::clone_into</source>
          <target state="translated">SplitAsciiWhitespace::clone_into</target>
        </trans-unit>
        <trans-unit id="a649c1c5639f12c498882f17faeb39196654582e" translate="yes" xml:space="preserve">
          <source>SplitAsciiWhitespace::cloned</source>
          <target state="translated">SplitAsciiWhitespace::cloned</target>
        </trans-unit>
        <trans-unit id="b8f818785a93160d09f563d3660592bc69c103ba" translate="yes" xml:space="preserve">
          <source>SplitAsciiWhitespace::cmp</source>
          <target state="translated">SplitAsciiWhitespace::cmp</target>
        </trans-unit>
        <trans-unit id="41c9c933147b5754f438d23f1e177d6638cbd2ad" translate="yes" xml:space="preserve">
          <source>SplitAsciiWhitespace::collect</source>
          <target state="translated">SplitAsciiWhitespace::collect</target>
        </trans-unit>
        <trans-unit id="0609f416eb86d1e403dbb9e3e349736676f93264" translate="yes" xml:space="preserve">
          <source>SplitAsciiWhitespace::copied</source>
          <target state="translated">SplitAsciiWhitespace::copied</target>
        </trans-unit>
        <trans-unit id="e09df544770b8509355f5dc78044291f19a3674e" translate="yes" xml:space="preserve">
          <source>SplitAsciiWhitespace::count</source>
          <target state="translated">SplitAsciiWhitespace::count</target>
        </trans-unit>
        <trans-unit id="ea2c872cc37c8bfe914e1c20225cb89633985deb" translate="yes" xml:space="preserve">
          <source>SplitAsciiWhitespace::cycle</source>
          <target state="translated">SplitAsciiWhitespace::cycle</target>
        </trans-unit>
        <trans-unit id="5662cbbe89ef49905be3ea7f1fdfd8b154b608d7" translate="yes" xml:space="preserve">
          <source>SplitAsciiWhitespace::enumerate</source>
          <target state="translated">SplitAsciiWhitespace::enumerate</target>
        </trans-unit>
        <trans-unit id="c1183a2c05484a76906656646293d93d281ca2fb" translate="yes" xml:space="preserve">
          <source>SplitAsciiWhitespace::eq</source>
          <target state="translated">SplitAsciiWhitespace::eq</target>
        </trans-unit>
        <trans-unit id="91b1919a54aed7ea3b10bbb74cad9e2278d1723f" translate="yes" xml:space="preserve">
          <source>SplitAsciiWhitespace::filter</source>
          <target state="translated">SplitAsciiWhitespace::filter</target>
        </trans-unit>
        <trans-unit id="76b1bcc4cb577b92b3bc2feceb82586f2f361424" translate="yes" xml:space="preserve">
          <source>SplitAsciiWhitespace::filter_map</source>
          <target state="translated">SplitAsciiWhitespace::filter_map</target>
        </trans-unit>
        <trans-unit id="9ff29c8778bd9b2f81ce751c494427625b066d43" translate="yes" xml:space="preserve">
          <source>SplitAsciiWhitespace::find</source>
          <target state="translated">SplitAsciiWhitespace::find</target>
        </trans-unit>
        <trans-unit id="df5a125787532b0b925bb44ea57bd7fe3dcf07b8" translate="yes" xml:space="preserve">
          <source>SplitAsciiWhitespace::find_map</source>
          <target state="translated">SplitAsciiWhitespace::find_map</target>
        </trans-unit>
        <trans-unit id="76f9c5019ea5f7c69e93e5d48f7ae23992ecf9a0" translate="yes" xml:space="preserve">
          <source>SplitAsciiWhitespace::flat_map</source>
          <target state="translated">SplitAsciiWhitespace::flat_map</target>
        </trans-unit>
        <trans-unit id="4b4cde4fdaefa4d559290e0699d32b4a404b5bda" translate="yes" xml:space="preserve">
          <source>SplitAsciiWhitespace::flatten</source>
          <target state="translated">SplitAsciiWhitespace::flatten</target>
        </trans-unit>
        <trans-unit id="e58b5fe3af09d951acbc08a6e2dd4e3b1707df55" translate="yes" xml:space="preserve">
          <source>SplitAsciiWhitespace::fmt</source>
          <target state="translated">SplitAsciiWhitespace::fmt</target>
        </trans-unit>
        <trans-unit id="57c353e0e941c86b78416e5bfd1e7d0ce29d69a3" translate="yes" xml:space="preserve">
          <source>SplitAsciiWhitespace::fold</source>
          <target state="translated">SplitAsciiWhitespace::fold</target>
        </trans-unit>
        <trans-unit id="6184a4204bcd6ae617cc28215c432427aeabc001" translate="yes" xml:space="preserve">
          <source>SplitAsciiWhitespace::for_each</source>
          <target state="translated">SplitAsciiWhitespace::for_each</target>
        </trans-unit>
        <trans-unit id="0f43fe4e291dadcf528141c23de7e3f59c7e9e8b" translate="yes" xml:space="preserve">
          <source>SplitAsciiWhitespace::from</source>
          <target state="translated">SplitAsciiWhitespace::from</target>
        </trans-unit>
        <trans-unit id="a1c033af232b37ef66143377ab5969536437610b" translate="yes" xml:space="preserve">
          <source>SplitAsciiWhitespace::fuse</source>
          <target state="translated">SplitAsciiWhitespace::fuse</target>
        </trans-unit>
        <trans-unit id="310b67ad4f4983ccba3e2d8c240103561dda9d7b" translate="yes" xml:space="preserve">
          <source>SplitAsciiWhitespace::ge</source>
          <target state="translated">SplitAsciiWhitespace::ge</target>
        </trans-unit>
        <trans-unit id="2a0ff36ce7bbe1b9615ebde75af1161098e4520b" translate="yes" xml:space="preserve">
          <source>SplitAsciiWhitespace::gt</source>
          <target state="translated">SplitAsciiWhitespace::gt</target>
        </trans-unit>
        <trans-unit id="59bae30052c567c9b9ce625b0eeb78c2a684eb02" translate="yes" xml:space="preserve">
          <source>SplitAsciiWhitespace::inspect</source>
          <target state="translated">SplitAsciiWhitespace::inspect</target>
        </trans-unit>
        <trans-unit id="069da77511094ed76dbbf1425acb3643a8d8c019" translate="yes" xml:space="preserve">
          <source>SplitAsciiWhitespace::into</source>
          <target state="translated">SplitAsciiWhitespace::into</target>
        </trans-unit>
        <trans-unit id="0b7e370c0a366ad830b5ca184deed03b75134ae6" translate="yes" xml:space="preserve">
          <source>SplitAsciiWhitespace::into_iter</source>
          <target state="translated">SplitAsciiWhitespace::into_iter</target>
        </trans-unit>
        <trans-unit id="2e689227dafd5929f003b950b47dc64a8c99cd16" translate="yes" xml:space="preserve">
          <source>SplitAsciiWhitespace::is_sorted</source>
          <target state="translated">SplitAsciiWhitespace::is_sorted</target>
        </trans-unit>
        <trans-unit id="11748df1d77daa90c258ec57aa9ed89c40f92d6e" translate="yes" xml:space="preserve">
          <source>SplitAsciiWhitespace::is_sorted_by</source>
          <target state="translated">SplitAsciiWhitespace::is_sorted_by</target>
        </trans-unit>
        <trans-unit id="f26f028c49d0003e5394959ffd46f3ce538ebae2" translate="yes" xml:space="preserve">
          <source>SplitAsciiWhitespace::is_sorted_by_key</source>
          <target state="translated">SplitAsciiWhitespace::is_sorted_by_key</target>
        </trans-unit>
        <trans-unit id="528e446454f64307260cdb5a9ece2b8172e3d19a" translate="yes" xml:space="preserve">
          <source>SplitAsciiWhitespace::last</source>
          <target state="translated">SplitAsciiWhitespace::last</target>
        </trans-unit>
        <trans-unit id="36423e071337db8c4a041c7a563d9c217a5ead49" translate="yes" xml:space="preserve">
          <source>SplitAsciiWhitespace::le</source>
          <target state="translated">SplitAsciiWhitespace::le</target>
        </trans-unit>
        <trans-unit id="72f1b824d265d3ab654d3d10700a66929e998456" translate="yes" xml:space="preserve">
          <source>SplitAsciiWhitespace::lt</source>
          <target state="translated">SplitAsciiWhitespace::lt</target>
        </trans-unit>
        <trans-unit id="4ef418a46604bf013d6a9b465e38d7f0c5ad99f3" translate="yes" xml:space="preserve">
          <source>SplitAsciiWhitespace::map</source>
          <target state="translated">SplitAsciiWhitespace::map</target>
        </trans-unit>
        <trans-unit id="9be46a6d947252ec6a1dd251fb4e0fcc2f6119e2" translate="yes" xml:space="preserve">
          <source>SplitAsciiWhitespace::max</source>
          <target state="translated">SplitAsciiWhitespace::max</target>
        </trans-unit>
        <trans-unit id="127e45fa2c12983d00df5fab27b5b8e195384207" translate="yes" xml:space="preserve">
          <source>SplitAsciiWhitespace::max_by</source>
          <target state="translated">SplitAsciiWhitespace::max_by</target>
        </trans-unit>
        <trans-unit id="1c6df694cc86df818a30e5b112a49a4205c39eb2" translate="yes" xml:space="preserve">
          <source>SplitAsciiWhitespace::max_by_key</source>
          <target state="translated">SplitAsciiWhitespace::max_by_key</target>
        </trans-unit>
        <trans-unit id="be2847e2c36c5bde77cdbe695d9a22650c0c12e2" translate="yes" xml:space="preserve">
          <source>SplitAsciiWhitespace::min</source>
          <target state="translated">SplitAsciiWhitespace::min</target>
        </trans-unit>
        <trans-unit id="5fba24b9cbe2f52e16529f2bbf82de6a19203c5a" translate="yes" xml:space="preserve">
          <source>SplitAsciiWhitespace::min_by</source>
          <target state="translated">SplitAsciiWhitespace::min_by</target>
        </trans-unit>
        <trans-unit id="aae362e0111ad6ca4337cd1ae93b061988acee85" translate="yes" xml:space="preserve">
          <source>SplitAsciiWhitespace::min_by_key</source>
          <target state="translated">SplitAsciiWhitespace::min_by_key</target>
        </trans-unit>
        <trans-unit id="c67248bea73f211db9a542d83ddb9a36d94b5afd" translate="yes" xml:space="preserve">
          <source>SplitAsciiWhitespace::ne</source>
          <target state="translated">SplitAsciiWhitespace::ne</target>
        </trans-unit>
        <trans-unit id="82893c758771243e61a8413ef50f1562d3c1e12b" translate="yes" xml:space="preserve">
          <source>SplitAsciiWhitespace::next</source>
          <target state="translated">SplitAsciiWhitespace::next</target>
        </trans-unit>
        <trans-unit id="9015cf406b343904881630d5e945b44f9de54418" translate="yes" xml:space="preserve">
          <source>SplitAsciiWhitespace::next_back</source>
          <target state="translated">SplitAsciiWhitespace::next_back</target>
        </trans-unit>
        <trans-unit id="800ffb6ace87d9335f20155619137664404e736f" translate="yes" xml:space="preserve">
          <source>SplitAsciiWhitespace::nth</source>
          <target state="translated">SplitAsciiWhitespace::nth</target>
        </trans-unit>
        <trans-unit id="d803c25fe950079c1ee0fcdc2cb07c6d7b6e5c86" translate="yes" xml:space="preserve">
          <source>SplitAsciiWhitespace::nth_back</source>
          <target state="translated">SplitAsciiWhitespace::nth_back</target>
        </trans-unit>
        <trans-unit id="dafe039e0602461f999aaffd35c6aa3cceab09eb" translate="yes" xml:space="preserve">
          <source>SplitAsciiWhitespace::partial_cmp</source>
          <target state="translated">SplitAsciiWhitespace::partial_cmp</target>
        </trans-unit>
        <trans-unit id="dcc86fb07b1239a5e6fba657205cf35cef67501a" translate="yes" xml:space="preserve">
          <source>SplitAsciiWhitespace::partition</source>
          <target state="translated">SplitAsciiWhitespace::partition</target>
        </trans-unit>
        <trans-unit id="111e562523a8602ffc04e4a6072c974f779b738f" translate="yes" xml:space="preserve">
          <source>SplitAsciiWhitespace::peekable</source>
          <target state="translated">SplitAsciiWhitespace::peekable</target>
        </trans-unit>
        <trans-unit id="af368f70215bf75f17802631e1fc5f718f626e27" translate="yes" xml:space="preserve">
          <source>SplitAsciiWhitespace::position</source>
          <target state="translated">SplitAsciiWhitespace::position</target>
        </trans-unit>
        <trans-unit id="cb77328d8d1ee014b57f24c2ccc88ce5b8e62c1d" translate="yes" xml:space="preserve">
          <source>SplitAsciiWhitespace::product</source>
          <target state="translated">SplitAsciiWhitespace::product</target>
        </trans-unit>
        <trans-unit id="7a50e4bb4d9e8a0173382540fd87b867aae2d288" translate="yes" xml:space="preserve">
          <source>SplitAsciiWhitespace::rev</source>
          <target state="translated">SplitAsciiWhitespace::rev</target>
        </trans-unit>
        <trans-unit id="16e496a0b8ed19b3f842cf913785bb9aa4fc8961" translate="yes" xml:space="preserve">
          <source>SplitAsciiWhitespace::rfind</source>
          <target state="translated">SplitAsciiWhitespace::rfind</target>
        </trans-unit>
        <trans-unit id="1715f991533f4675efb8b6c56d86be138a40da7a" translate="yes" xml:space="preserve">
          <source>SplitAsciiWhitespace::rfold</source>
          <target state="translated">SplitAsciiWhitespace::rfold</target>
        </trans-unit>
        <trans-unit id="e2b34504a07710470c1959e1f83ab83920ea1290" translate="yes" xml:space="preserve">
          <source>SplitAsciiWhitespace::rposition</source>
          <target state="translated">SplitAsciiWhitespace::rposition</target>
        </trans-unit>
        <trans-unit id="65bbacf4df364edec256188ba99abe9ed0cbcfe9" translate="yes" xml:space="preserve">
          <source>SplitAsciiWhitespace::scan</source>
          <target state="translated">SplitAsciiWhitespace::scan</target>
        </trans-unit>
        <trans-unit id="0f32ba62e7a1465fc1d1effcdec4fa37d30ff203" translate="yes" xml:space="preserve">
          <source>SplitAsciiWhitespace::size_hint</source>
          <target state="translated">SplitAsciiWhitespace::size_hint</target>
        </trans-unit>
        <trans-unit id="690c47d40b3f54f05b2ab7a4627a079915fe351d" translate="yes" xml:space="preserve">
          <source>SplitAsciiWhitespace::skip</source>
          <target state="translated">SplitAsciiWhitespace::skip</target>
        </trans-unit>
        <trans-unit id="8a2c9001716ae0239a5bbf8359a3ec445e81acb3" translate="yes" xml:space="preserve">
          <source>SplitAsciiWhitespace::skip_while</source>
          <target state="translated">SplitAsciiWhitespace::skip_while</target>
        </trans-unit>
        <trans-unit id="217fca41bc16a021f8ab7c549af56a114f593a0e" translate="yes" xml:space="preserve">
          <source>SplitAsciiWhitespace::step_by</source>
          <target state="translated">SplitAsciiWhitespace::step_by</target>
        </trans-unit>
        <trans-unit id="0aced7b4ec8d99679bfbd1ae84d621cb721f1bf9" translate="yes" xml:space="preserve">
          <source>SplitAsciiWhitespace::sum</source>
          <target state="translated">SplitAsciiWhitespace::sum</target>
        </trans-unit>
        <trans-unit id="91dd9c3d22777c96c94075aefbab05b3d2288f45" translate="yes" xml:space="preserve">
          <source>SplitAsciiWhitespace::take</source>
          <target state="translated">SplitAsciiWhitespace::take</target>
        </trans-unit>
        <trans-unit id="7cbbf417b286e13398b71757444e4f8752f5b529" translate="yes" xml:space="preserve">
          <source>SplitAsciiWhitespace::take_while</source>
          <target state="translated">SplitAsciiWhitespace::take_while</target>
        </trans-unit>
        <trans-unit id="f3de387ae43a9572825277de4ce2b214d342dd7e" translate="yes" xml:space="preserve">
          <source>SplitAsciiWhitespace::to_owned</source>
          <target state="translated">SplitAsciiWhitespace::to_owned</target>
        </trans-unit>
        <trans-unit id="ecc0da33afce2dc7e10369c26b360220d1d78e32" translate="yes" xml:space="preserve">
          <source>SplitAsciiWhitespace::try_fold</source>
          <target state="translated">SplitAsciiWhitespace::try_fold</target>
        </trans-unit>
        <trans-unit id="1f60c9615c55654daec7a4cf006038d497e6b0b7" translate="yes" xml:space="preserve">
          <source>SplitAsciiWhitespace::try_for_each</source>
          <target state="translated">SplitAsciiWhitespace::try_for_each</target>
        </trans-unit>
        <trans-unit id="c2294684e72bfd9a84b5012da3bcc907529b9cfc" translate="yes" xml:space="preserve">
          <source>SplitAsciiWhitespace::try_from</source>
          <target state="translated">SplitAsciiWhitespace::try_from</target>
        </trans-unit>
        <trans-unit id="2b0b05327dad549e95544d31f8876fa08eb481a1" translate="yes" xml:space="preserve">
          <source>SplitAsciiWhitespace::try_into</source>
          <target state="translated">SplitAsciiWhitespace::try_into</target>
        </trans-unit>
        <trans-unit id="2cffb23622e9856698308f79023e5010597e0426" translate="yes" xml:space="preserve">
          <source>SplitAsciiWhitespace::try_rfold</source>
          <target state="translated">SplitAsciiWhitespace::try_rfold</target>
        </trans-unit>
        <trans-unit id="53ddbab2216aea28798a718405d3ea5674b5b71c" translate="yes" xml:space="preserve">
          <source>SplitAsciiWhitespace::type_id</source>
          <target state="translated">SplitAsciiWhitespace::type_id</target>
        </trans-unit>
        <trans-unit id="808e6a2877c52b21ba18e8a5ed73755ab37122ac" translate="yes" xml:space="preserve">
          <source>SplitAsciiWhitespace::unzip</source>
          <target state="translated">SplitAsciiWhitespace::unzip</target>
        </trans-unit>
        <trans-unit id="a8f2029938b77a34b0d281702e7c3381b8c65da6" translate="yes" xml:space="preserve">
          <source>SplitAsciiWhitespace::zip</source>
          <target state="translated">SplitAsciiWhitespace::zip</target>
        </trans-unit>
        <trans-unit id="fea4bc9ee6da0bf1ba0b8639d2f7171e8c27b627" translate="yes" xml:space="preserve">
          <source>SplitMut</source>
          <target state="translated">SplitMut</target>
        </trans-unit>
        <trans-unit id="20206e90fcc4395df7feeeec3587e4fdf0c908f9" translate="yes" xml:space="preserve">
          <source>SplitMut::all</source>
          <target state="translated">SplitMut::all</target>
        </trans-unit>
        <trans-unit id="a5e736eff61c632c906ccc2055616d0e72b6e186" translate="yes" xml:space="preserve">
          <source>SplitMut::any</source>
          <target state="translated">SplitMut::any</target>
        </trans-unit>
        <trans-unit id="b71a732cfe7ae698c523092d708a2350233050ef" translate="yes" xml:space="preserve">
          <source>SplitMut::borrow</source>
          <target state="translated">SplitMut::borrow</target>
        </trans-unit>
        <trans-unit id="fb571d070b4af0c2364088c2ebd063c995b0ddf5" translate="yes" xml:space="preserve">
          <source>SplitMut::borrow_mut</source>
          <target state="translated">SplitMut::borrow_mut</target>
        </trans-unit>
        <trans-unit id="b562dfd918c487d57df4688eec5336c81d02a867" translate="yes" xml:space="preserve">
          <source>SplitMut::by_ref</source>
          <target state="translated">SplitMut::by_ref</target>
        </trans-unit>
        <trans-unit id="f5a6ea0a5254cd7fa04309b98118cc9a4253494f" translate="yes" xml:space="preserve">
          <source>SplitMut::chain</source>
          <target state="translated">SplitMut::chain</target>
        </trans-unit>
        <trans-unit id="4eace10a6db11151f8b1c52e939d52f4ce5d86e3" translate="yes" xml:space="preserve">
          <source>SplitMut::cloned</source>
          <target state="translated">SplitMut::cloned</target>
        </trans-unit>
        <trans-unit id="f0acc5792c7f2b777a795150aadee0760acc5090" translate="yes" xml:space="preserve">
          <source>SplitMut::cmp</source>
          <target state="translated">SplitMut::cmp</target>
        </trans-unit>
        <trans-unit id="c38c2137231b60394ac5c2e3f4bb57a19fbb9575" translate="yes" xml:space="preserve">
          <source>SplitMut::collect</source>
          <target state="translated">SplitMut::collect</target>
        </trans-unit>
        <trans-unit id="2ed1683fcd240c755198fcd38588b405eea9dfe7" translate="yes" xml:space="preserve">
          <source>SplitMut::copied</source>
          <target state="translated">SplitMut::copied</target>
        </trans-unit>
        <trans-unit id="c13e6d8a785dc692a0639f0e32e4a8c64fcee4a4" translate="yes" xml:space="preserve">
          <source>SplitMut::count</source>
          <target state="translated">SplitMut::count</target>
        </trans-unit>
        <trans-unit id="4c7a0ba794c7e18b97214f0ec8aa0c514fdf408e" translate="yes" xml:space="preserve">
          <source>SplitMut::cycle</source>
          <target state="translated">SplitMut::cycle</target>
        </trans-unit>
        <trans-unit id="2232d7b04b4bf06a4c92d2a9b9691552c014c3f9" translate="yes" xml:space="preserve">
          <source>SplitMut::enumerate</source>
          <target state="translated">SplitMut::enumerate</target>
        </trans-unit>
        <trans-unit id="846661ba130aa85c29ead92d060a256c90b6734f" translate="yes" xml:space="preserve">
          <source>SplitMut::eq</source>
          <target state="translated">SplitMut::eq</target>
        </trans-unit>
        <trans-unit id="0189cb2a15812d4ef3b0fbd404fee90b9e1c2423" translate="yes" xml:space="preserve">
          <source>SplitMut::filter</source>
          <target state="translated">SplitMut::filter</target>
        </trans-unit>
        <trans-unit id="edc992f7708a7411f1faa75438b2bdacb44710f9" translate="yes" xml:space="preserve">
          <source>SplitMut::filter_map</source>
          <target state="translated">SplitMut::filter_map</target>
        </trans-unit>
        <trans-unit id="3a9885ecd88a39b6bb0b519ce04d23246fafd898" translate="yes" xml:space="preserve">
          <source>SplitMut::find</source>
          <target state="translated">SplitMut::find</target>
        </trans-unit>
        <trans-unit id="d635d90f1b6ece770ef2f36f7f64b12f4cb3904d" translate="yes" xml:space="preserve">
          <source>SplitMut::find_map</source>
          <target state="translated">SplitMut::find_map</target>
        </trans-unit>
        <trans-unit id="302f584a59e59164ec4a4b5bd8c6e13223ea03d3" translate="yes" xml:space="preserve">
          <source>SplitMut::flat_map</source>
          <target state="translated">SplitMut::flat_map</target>
        </trans-unit>
        <trans-unit id="5d4f110597153143a0a3650309b2c50c7fd902e7" translate="yes" xml:space="preserve">
          <source>SplitMut::flatten</source>
          <target state="translated">SplitMut::flatten</target>
        </trans-unit>
        <trans-unit id="5099707abaa042e1ffb0d89dd5dbb06c549395b8" translate="yes" xml:space="preserve">
          <source>SplitMut::fmt</source>
          <target state="translated">SplitMut::fmt</target>
        </trans-unit>
        <trans-unit id="aed14cdc4bd5fb853c1c2392b5e7dc619e76d60a" translate="yes" xml:space="preserve">
          <source>SplitMut::fold</source>
          <target state="translated">SplitMut::fold</target>
        </trans-unit>
        <trans-unit id="73aa634ae991252e43a303480dc0ed056f0340d5" translate="yes" xml:space="preserve">
          <source>SplitMut::for_each</source>
          <target state="translated">SplitMut::for_each</target>
        </trans-unit>
        <trans-unit id="2852a96161b9ecc71293c8fe9b3dab11d0ae1552" translate="yes" xml:space="preserve">
          <source>SplitMut::from</source>
          <target state="translated">SplitMut::from</target>
        </trans-unit>
        <trans-unit id="6143cfe4d589a7d6717f45153116e86253256ecf" translate="yes" xml:space="preserve">
          <source>SplitMut::fuse</source>
          <target state="translated">SplitMut::fuse</target>
        </trans-unit>
        <trans-unit id="89536afa53b6b6dc8c71f1de1b91d789011c5d9f" translate="yes" xml:space="preserve">
          <source>SplitMut::ge</source>
          <target state="translated">SplitMut::ge</target>
        </trans-unit>
        <trans-unit id="a10b89f6079d7a532cd04577ec701b7fa1c150bf" translate="yes" xml:space="preserve">
          <source>SplitMut::gt</source>
          <target state="translated">SplitMut::gt</target>
        </trans-unit>
        <trans-unit id="9791c41d4deefe7a2df85b0d0dc7716e0980a802" translate="yes" xml:space="preserve">
          <source>SplitMut::inspect</source>
          <target state="translated">SplitMut::inspect</target>
        </trans-unit>
        <trans-unit id="2e9b92dd317f57917d610f26e5b4684dfcd1faca" translate="yes" xml:space="preserve">
          <source>SplitMut::into</source>
          <target state="translated">SplitMut::into</target>
        </trans-unit>
        <trans-unit id="c494d7a4b6814217996661cca35583783cb08e6d" translate="yes" xml:space="preserve">
          <source>SplitMut::into_iter</source>
          <target state="translated">SplitMut::into_iter</target>
        </trans-unit>
        <trans-unit id="bd0b5e2be5227e216a5b1571efa44177559e250c" translate="yes" xml:space="preserve">
          <source>SplitMut::is_sorted</source>
          <target state="translated">SplitMut::is_sorted</target>
        </trans-unit>
        <trans-unit id="f5935f25264d3c7818e7454c6b771624cc3018a1" translate="yes" xml:space="preserve">
          <source>SplitMut::is_sorted_by</source>
          <target state="translated">SplitMut::is_sorted_by</target>
        </trans-unit>
        <trans-unit id="ca6bb363ed6ba8e746509979f646f40911baff59" translate="yes" xml:space="preserve">
          <source>SplitMut::is_sorted_by_key</source>
          <target state="translated">SplitMut::is_sorted_by_key</target>
        </trans-unit>
        <trans-unit id="0bab1c560e39cdbb9b32a04c72e27770f0675860" translate="yes" xml:space="preserve">
          <source>SplitMut::last</source>
          <target state="translated">SplitMut::last</target>
        </trans-unit>
        <trans-unit id="de5ff505373a03db4bc6e1c2423dc90e725ccf1d" translate="yes" xml:space="preserve">
          <source>SplitMut::le</source>
          <target state="translated">SplitMut::le</target>
        </trans-unit>
        <trans-unit id="5485825db66e1ec2af52a05773f218aa68975db4" translate="yes" xml:space="preserve">
          <source>SplitMut::lt</source>
          <target state="translated">SplitMut::lt</target>
        </trans-unit>
        <trans-unit id="bd6834e13f4c5195d21cd5d559d6242f832b47dd" translate="yes" xml:space="preserve">
          <source>SplitMut::map</source>
          <target state="translated">SplitMut::map</target>
        </trans-unit>
        <trans-unit id="c0b4fcf226d9d2003cbdc6e6bcc64c81e072d854" translate="yes" xml:space="preserve">
          <source>SplitMut::max</source>
          <target state="translated">SplitMut::max</target>
        </trans-unit>
        <trans-unit id="54140c9550aafbc4e20ff15fa0e5e0a94290a93b" translate="yes" xml:space="preserve">
          <source>SplitMut::max_by</source>
          <target state="translated">SplitMut::max_by</target>
        </trans-unit>
        <trans-unit id="8eb2b9ac27b077e103ac0412edd18591a84e5907" translate="yes" xml:space="preserve">
          <source>SplitMut::max_by_key</source>
          <target state="translated">SplitMut::max_by_key</target>
        </trans-unit>
        <trans-unit id="6665443d5d217dc2f7fe86247c1bbac2934415aa" translate="yes" xml:space="preserve">
          <source>SplitMut::min</source>
          <target state="translated">SplitMut::min</target>
        </trans-unit>
        <trans-unit id="f4a96f6c160a7ed3e79564d0cff3badb853b2f6a" translate="yes" xml:space="preserve">
          <source>SplitMut::min_by</source>
          <target state="translated">SplitMut::min_by</target>
        </trans-unit>
        <trans-unit id="3b46f65b9c4046f1da460b7e24eb5462b74a57e9" translate="yes" xml:space="preserve">
          <source>SplitMut::min_by_key</source>
          <target state="translated">SplitMut::min_by_key</target>
        </trans-unit>
        <trans-unit id="30957514e25fa430fe59e4b67ccb699eadd7e6ac" translate="yes" xml:space="preserve">
          <source>SplitMut::ne</source>
          <target state="translated">SplitMut::ne</target>
        </trans-unit>
        <trans-unit id="37372ea2a5031dd483e65cd5cd3612700e496ee8" translate="yes" xml:space="preserve">
          <source>SplitMut::next</source>
          <target state="translated">SplitMut::next</target>
        </trans-unit>
        <trans-unit id="cefb6f6029ac920475c0b403fd90848015dc9534" translate="yes" xml:space="preserve">
          <source>SplitMut::next_back</source>
          <target state="translated">SplitMut::next_back</target>
        </trans-unit>
        <trans-unit id="ee2301f8b42dc90c989136ded153d020ad5d7675" translate="yes" xml:space="preserve">
          <source>SplitMut::nth</source>
          <target state="translated">SplitMut::nth</target>
        </trans-unit>
        <trans-unit id="2c63b5f36f6d206c4812d641ea388572cec30fed" translate="yes" xml:space="preserve">
          <source>SplitMut::nth_back</source>
          <target state="translated">SplitMut::nth_back</target>
        </trans-unit>
        <trans-unit id="d17454d80fde91f9e9c65cdd86720e46e6e0b313" translate="yes" xml:space="preserve">
          <source>SplitMut::partial_cmp</source>
          <target state="translated">SplitMut::partial_cmp</target>
        </trans-unit>
        <trans-unit id="e1fde268ce94515a7e4a1a7cfbc882255f1594a7" translate="yes" xml:space="preserve">
          <source>SplitMut::partition</source>
          <target state="translated">SplitMut::partition</target>
        </trans-unit>
        <trans-unit id="c96cb0feba3dacbbc5b762291a840a8050aa61de" translate="yes" xml:space="preserve">
          <source>SplitMut::peekable</source>
          <target state="translated">SplitMut::peekable</target>
        </trans-unit>
        <trans-unit id="f8444b29f2ac3d1f7deb66730af9fa3ee8cdd548" translate="yes" xml:space="preserve">
          <source>SplitMut::position</source>
          <target state="translated">SplitMut::position</target>
        </trans-unit>
        <trans-unit id="5ccab74320ecb86a7e67746e0bd6af936ae7f505" translate="yes" xml:space="preserve">
          <source>SplitMut::product</source>
          <target state="translated">SplitMut::product</target>
        </trans-unit>
        <trans-unit id="628ba356aca57ecbdae880df99459db0cf443cd7" translate="yes" xml:space="preserve">
          <source>SplitMut::rev</source>
          <target state="translated">SplitMut::rev</target>
        </trans-unit>
        <trans-unit id="f26246a1486622aa329878355bf05623a81ce9be" translate="yes" xml:space="preserve">
          <source>SplitMut::rfind</source>
          <target state="translated">SplitMut::rfind</target>
        </trans-unit>
        <trans-unit id="3b544bc118ab36de53257f4bd5d45f58adad6a7e" translate="yes" xml:space="preserve">
          <source>SplitMut::rfold</source>
          <target state="translated">SplitMut::rfold</target>
        </trans-unit>
        <trans-unit id="eca3055cedf3ba5364f16f949bfbbb61473a1124" translate="yes" xml:space="preserve">
          <source>SplitMut::rposition</source>
          <target state="translated">SplitMut::rposition</target>
        </trans-unit>
        <trans-unit id="3a098145ea0946d93efbe7baf21f05a89bf7ec07" translate="yes" xml:space="preserve">
          <source>SplitMut::scan</source>
          <target state="translated">SplitMut::scan</target>
        </trans-unit>
        <trans-unit id="061e9c4a19805c6d5769b81858d416ce425f8c1f" translate="yes" xml:space="preserve">
          <source>SplitMut::size_hint</source>
          <target state="translated">SplitMut::size_hint</target>
        </trans-unit>
        <trans-unit id="1f53a493ed3bb4e2cd0887d2a4091fba1a5a31f1" translate="yes" xml:space="preserve">
          <source>SplitMut::skip</source>
          <target state="translated">SplitMut::skip</target>
        </trans-unit>
        <trans-unit id="68eebe6bd72f45df24cb588cda23ac503a34a2b1" translate="yes" xml:space="preserve">
          <source>SplitMut::skip_while</source>
          <target state="translated">SplitMut::skip_while</target>
        </trans-unit>
        <trans-unit id="13d1bd3f1e09c0f698859b9d9e41592a7556ee64" translate="yes" xml:space="preserve">
          <source>SplitMut::step_by</source>
          <target state="translated">SplitMut::step_by</target>
        </trans-unit>
        <trans-unit id="298d9044c7bdda094f311f1fd94aae26d5abfd34" translate="yes" xml:space="preserve">
          <source>SplitMut::sum</source>
          <target state="translated">SplitMut::sum</target>
        </trans-unit>
        <trans-unit id="990dd1698269f85fbf5446bbde7a4833dc9ac601" translate="yes" xml:space="preserve">
          <source>SplitMut::take</source>
          <target state="translated">SplitMut::take</target>
        </trans-unit>
        <trans-unit id="6f5728524fd7240e3b30406730fe5c12bcb73e86" translate="yes" xml:space="preserve">
          <source>SplitMut::take_while</source>
          <target state="translated">SplitMut::take_while</target>
        </trans-unit>
        <trans-unit id="f02c923d285cc8d43703f446a3f5941ed72a5403" translate="yes" xml:space="preserve">
          <source>SplitMut::try_fold</source>
          <target state="translated">SplitMut::try_fold</target>
        </trans-unit>
        <trans-unit id="c2e6f99080f6d6a48c899e62ec7a31ec8e823694" translate="yes" xml:space="preserve">
          <source>SplitMut::try_for_each</source>
          <target state="translated">SplitMut::try_for_each</target>
        </trans-unit>
        <trans-unit id="bff0b93e0bc80beaab7376ac083610d07f858ea2" translate="yes" xml:space="preserve">
          <source>SplitMut::try_from</source>
          <target state="translated">SplitMut::try_from</target>
        </trans-unit>
        <trans-unit id="9900dd1b01ab865e71a8b9620368ee396732e68d" translate="yes" xml:space="preserve">
          <source>SplitMut::try_into</source>
          <target state="translated">SplitMut::try_into</target>
        </trans-unit>
        <trans-unit id="8e9ab1bbfc05ef43646065397d47b9e01ed301ed" translate="yes" xml:space="preserve">
          <source>SplitMut::try_rfold</source>
          <target state="translated">SplitMut::try_rfold</target>
        </trans-unit>
        <trans-unit id="ee86b9f65b2c2e9e017cf3d1d25e875e9b29c342" translate="yes" xml:space="preserve">
          <source>SplitMut::type_id</source>
          <target state="translated">SplitMut::type_id</target>
        </trans-unit>
        <trans-unit id="5412d53b0d28fed40234eae1cd0b12f8cb2eaded" translate="yes" xml:space="preserve">
          <source>SplitMut::unzip</source>
          <target state="translated">SplitMut::unzip</target>
        </trans-unit>
        <trans-unit id="4e5275a4a48054490c51798e482b88273fc37f9d" translate="yes" xml:space="preserve">
          <source>SplitMut::zip</source>
          <target state="translated">SplitMut::zip</target>
        </trans-unit>
        <trans-unit id="84cfaf9bc325cc024ba8d73b2f03f1f0b940f375" translate="yes" xml:space="preserve">
          <source>SplitN</source>
          <target state="translated">SplitN</target>
        </trans-unit>
        <trans-unit id="122739cc4318bd1f17b9ecdcf64503694d129b07" translate="yes" xml:space="preserve">
          <source>SplitN::all</source>
          <target state="translated">SplitN::all</target>
        </trans-unit>
        <trans-unit id="f22a50edd00e4694503cf3374a70577df0b3e533" translate="yes" xml:space="preserve">
          <source>SplitN::any</source>
          <target state="translated">SplitN::any</target>
        </trans-unit>
        <trans-unit id="336bcfdda643a5e1e9c28174874ec96704590db4" translate="yes" xml:space="preserve">
          <source>SplitN::borrow</source>
          <target state="translated">SplitN::borrow</target>
        </trans-unit>
        <trans-unit id="490b0d78c0681f8492f7af42daa3a7def5d70a27" translate="yes" xml:space="preserve">
          <source>SplitN::borrow_mut</source>
          <target state="translated">SplitN::borrow_mut</target>
        </trans-unit>
        <trans-unit id="3bd7504cf511166bc478563f699dfa4bbe634ffe" translate="yes" xml:space="preserve">
          <source>SplitN::by_ref</source>
          <target state="translated">SplitN::by_ref</target>
        </trans-unit>
        <trans-unit id="7ef14ea09d563f6244a306d2a2fb1777b4968a13" translate="yes" xml:space="preserve">
          <source>SplitN::chain</source>
          <target state="translated">SplitN::chain</target>
        </trans-unit>
        <trans-unit id="ef43f93e7129f677ba8bb87619e9b4bdfcb97d3a" translate="yes" xml:space="preserve">
          <source>SplitN::clone</source>
          <target state="translated">SplitN::clone</target>
        </trans-unit>
        <trans-unit id="fb6e1769c703590e4216e06d016494cb27f7d2c1" translate="yes" xml:space="preserve">
          <source>SplitN::clone_from</source>
          <target state="translated">SplitN::clone_from</target>
        </trans-unit>
        <trans-unit id="c9a61b9009525e282d49323582f8b56f31b5b08a" translate="yes" xml:space="preserve">
          <source>SplitN::clone_into</source>
          <target state="translated">SplitN::clone_into</target>
        </trans-unit>
        <trans-unit id="4312e557df7befa3bf2dbb3dc60b50e5a0b4771d" translate="yes" xml:space="preserve">
          <source>SplitN::cloned</source>
          <target state="translated">SplitN::cloned</target>
        </trans-unit>
        <trans-unit id="3476733cfab685ad5f068f4e1628ce32cf01a4a4" translate="yes" xml:space="preserve">
          <source>SplitN::cmp</source>
          <target state="translated">SplitN::cmp</target>
        </trans-unit>
        <trans-unit id="ec93a1f80200a136680eda5efbcd79bc4210ce8c" translate="yes" xml:space="preserve">
          <source>SplitN::collect</source>
          <target state="translated">SplitN::collect</target>
        </trans-unit>
        <trans-unit id="62783fc3a5b18489dcc3ea45742e157a5335f0f9" translate="yes" xml:space="preserve">
          <source>SplitN::copied</source>
          <target state="translated">SplitN::copied</target>
        </trans-unit>
        <trans-unit id="dccfd6459163a470f07c9501e050ab2c502b5307" translate="yes" xml:space="preserve">
          <source>SplitN::count</source>
          <target state="translated">SplitN::count</target>
        </trans-unit>
        <trans-unit id="02499e5ba89665bd94c9c835be4db2449a2ccef6" translate="yes" xml:space="preserve">
          <source>SplitN::cycle</source>
          <target state="translated">SplitN::cycle</target>
        </trans-unit>
        <trans-unit id="e6a5b0f346075645754d0b71e13524100e59ff98" translate="yes" xml:space="preserve">
          <source>SplitN::enumerate</source>
          <target state="translated">SplitN::enumerate</target>
        </trans-unit>
        <trans-unit id="3d18b3008357613dc445c918b35bc97d7a069176" translate="yes" xml:space="preserve">
          <source>SplitN::eq</source>
          <target state="translated">SplitN::eq</target>
        </trans-unit>
        <trans-unit id="d54d53ea7aea91a96a76e27c4385fbead44b7c5e" translate="yes" xml:space="preserve">
          <source>SplitN::filter</source>
          <target state="translated">SplitN::filter</target>
        </trans-unit>
        <trans-unit id="a3777ec6f8731741ef7dc6517f5f311b440269d1" translate="yes" xml:space="preserve">
          <source>SplitN::filter_map</source>
          <target state="translated">SplitN::filter_map</target>
        </trans-unit>
        <trans-unit id="df220dc5e55d1e47fca0f72bff502436ac832bfe" translate="yes" xml:space="preserve">
          <source>SplitN::find</source>
          <target state="translated">SplitN::find</target>
        </trans-unit>
        <trans-unit id="0c5ed15b954402a97c57458f3f5fc41a98dcc792" translate="yes" xml:space="preserve">
          <source>SplitN::find_map</source>
          <target state="translated">SplitN::find_map</target>
        </trans-unit>
        <trans-unit id="98d41110c2558fc567d8923ff520ebad7bb5eaf3" translate="yes" xml:space="preserve">
          <source>SplitN::flat_map</source>
          <target state="translated">SplitN::flat_map</target>
        </trans-unit>
        <trans-unit id="80a6a8cf3ba46f779ef8d18c4bd3403365057478" translate="yes" xml:space="preserve">
          <source>SplitN::flatten</source>
          <target state="translated">SplitN::flatten</target>
        </trans-unit>
        <trans-unit id="5d87df857db806ea96763e81d2646a039765e3dd" translate="yes" xml:space="preserve">
          <source>SplitN::fmt</source>
          <target state="translated">SplitN::fmt</target>
        </trans-unit>
        <trans-unit id="e9832127e3fa28bea6bd8412ac21e2ad3e8c0310" translate="yes" xml:space="preserve">
          <source>SplitN::fold</source>
          <target state="translated">SplitN::fold</target>
        </trans-unit>
        <trans-unit id="1834a8473d4bec69f12d9dc52c8b383aeed7fe0f" translate="yes" xml:space="preserve">
          <source>SplitN::for_each</source>
          <target state="translated">SplitN::for_each</target>
        </trans-unit>
        <trans-unit id="d2c893944b190fa3b860239523e5791fdd571c0e" translate="yes" xml:space="preserve">
          <source>SplitN::from</source>
          <target state="translated">SplitN::from</target>
        </trans-unit>
        <trans-unit id="da81f035cef35745d353a2035446f599f4983e33" translate="yes" xml:space="preserve">
          <source>SplitN::fuse</source>
          <target state="translated">SplitN::fuse</target>
        </trans-unit>
        <trans-unit id="d1fda09cb7d8ec3fbca0339bfaa32bf7bdad7356" translate="yes" xml:space="preserve">
          <source>SplitN::ge</source>
          <target state="translated">SplitN::ge</target>
        </trans-unit>
        <trans-unit id="aa731f7a4b02d3b0a81fe4b654c437870c8d34b6" translate="yes" xml:space="preserve">
          <source>SplitN::gt</source>
          <target state="translated">SplitN::gt</target>
        </trans-unit>
        <trans-unit id="c5618febbcf525c645381667581e58703662edd0" translate="yes" xml:space="preserve">
          <source>SplitN::inspect</source>
          <target state="translated">SplitN::inspect</target>
        </trans-unit>
        <trans-unit id="8bb460910139af21ac29118fb663910d592e882f" translate="yes" xml:space="preserve">
          <source>SplitN::into</source>
          <target state="translated">SplitN::into</target>
        </trans-unit>
        <trans-unit id="e1042f51982fc7dbc155002d451ce4e1ca574dca" translate="yes" xml:space="preserve">
          <source>SplitN::into_iter</source>
          <target state="translated">SplitN::into_iter</target>
        </trans-unit>
        <trans-unit id="8463463f8a36a64e44101c34593800e1bc905f29" translate="yes" xml:space="preserve">
          <source>SplitN::is_sorted</source>
          <target state="translated">SplitN::is_sorted</target>
        </trans-unit>
        <trans-unit id="b5af2679a1b0859700692f13ec99ed4f729d0d23" translate="yes" xml:space="preserve">
          <source>SplitN::is_sorted_by</source>
          <target state="translated">SplitN::is_sorted_by</target>
        </trans-unit>
        <trans-unit id="faa9b81c956435b32cb3748bb185a2e8b58d3a13" translate="yes" xml:space="preserve">
          <source>SplitN::is_sorted_by_key</source>
          <target state="translated">SplitN::is_sorted_by_key</target>
        </trans-unit>
        <trans-unit id="95889fb9614babcc26a11cdea5748581c7c88d65" translate="yes" xml:space="preserve">
          <source>SplitN::last</source>
          <target state="translated">SplitN::last</target>
        </trans-unit>
        <trans-unit id="e97daab9d7578e2931baa7d1d46cd78e6376313a" translate="yes" xml:space="preserve">
          <source>SplitN::le</source>
          <target state="translated">SplitN::le</target>
        </trans-unit>
        <trans-unit id="028d068db19bdb09ad13cd9b8462734d9757ed4b" translate="yes" xml:space="preserve">
          <source>SplitN::lt</source>
          <target state="translated">SplitN::lt</target>
        </trans-unit>
        <trans-unit id="307fa967c67a2ce84e64f0b3818337bbd9d621d3" translate="yes" xml:space="preserve">
          <source>SplitN::map</source>
          <target state="translated">SplitN::map</target>
        </trans-unit>
        <trans-unit id="f1e758cba3c4683313000028f0c50e9f8b040a9e" translate="yes" xml:space="preserve">
          <source>SplitN::max</source>
          <target state="translated">SplitN::max</target>
        </trans-unit>
        <trans-unit id="75c2e8ce37698bfde673be74257adcbcc7b88295" translate="yes" xml:space="preserve">
          <source>SplitN::max_by</source>
          <target state="translated">SplitN::max_by</target>
        </trans-unit>
        <trans-unit id="33f258f7c5a1f3da0faa0548afc4c8c25706e6f0" translate="yes" xml:space="preserve">
          <source>SplitN::max_by_key</source>
          <target state="translated">SplitN::max_by_key</target>
        </trans-unit>
        <trans-unit id="54ac5b81e18ab0f8c92abe64ccc4f5301b02fc8b" translate="yes" xml:space="preserve">
          <source>SplitN::min</source>
          <target state="translated">SplitN::min</target>
        </trans-unit>
        <trans-unit id="b9a9686df44477991685521397f094f623314564" translate="yes" xml:space="preserve">
          <source>SplitN::min_by</source>
          <target state="translated">SplitN::min_by</target>
        </trans-unit>
        <trans-unit id="0eded5e718c37a846c755f2507832792cf7bfde5" translate="yes" xml:space="preserve">
          <source>SplitN::min_by_key</source>
          <target state="translated">SplitN::min_by_key</target>
        </trans-unit>
        <trans-unit id="68338043b35f857554c965714c90308819ddf388" translate="yes" xml:space="preserve">
          <source>SplitN::ne</source>
          <target state="translated">SplitN::ne</target>
        </trans-unit>
        <trans-unit id="ed6941fc5b27d1832efe7268ecbb911be8c6a16c" translate="yes" xml:space="preserve">
          <source>SplitN::next</source>
          <target state="translated">SplitN::next</target>
        </trans-unit>
        <trans-unit id="8d78abab34e9057d07d0fb5bc365979243499aac" translate="yes" xml:space="preserve">
          <source>SplitN::nth</source>
          <target state="translated">SplitN::nth</target>
        </trans-unit>
        <trans-unit id="e1b96349e7b005cb27ed10fd7583c3c122868a91" translate="yes" xml:space="preserve">
          <source>SplitN::partial_cmp</source>
          <target state="translated">SplitN::partial_cmp</target>
        </trans-unit>
        <trans-unit id="e3d9fa88c318832c6af7e7c7311f01d9978c47c6" translate="yes" xml:space="preserve">
          <source>SplitN::partition</source>
          <target state="translated">SplitN::partition</target>
        </trans-unit>
        <trans-unit id="f5cabce5868b7653c7e52336618a295286430046" translate="yes" xml:space="preserve">
          <source>SplitN::peekable</source>
          <target state="translated">SplitN::peekable</target>
        </trans-unit>
        <trans-unit id="974c8b6afca8ebb48f8f3ff5ece0eb8ffd55909f" translate="yes" xml:space="preserve">
          <source>SplitN::position</source>
          <target state="translated">SplitN::position</target>
        </trans-unit>
        <trans-unit id="8688e6ca520758cfb193536575d8f729a67cdd37" translate="yes" xml:space="preserve">
          <source>SplitN::product</source>
          <target state="translated">SplitN::product</target>
        </trans-unit>
        <trans-unit id="191e23eb02b3b7c67f52a633c039415b22b95b14" translate="yes" xml:space="preserve">
          <source>SplitN::rev</source>
          <target state="translated">SplitN::rev</target>
        </trans-unit>
        <trans-unit id="a55bfcd72970297b44c4e59d676de9ba3711bf64" translate="yes" xml:space="preserve">
          <source>SplitN::rposition</source>
          <target state="translated">SplitN::rposition</target>
        </trans-unit>
        <trans-unit id="5410bc76c40307385588b0b6d5c39a0d74265064" translate="yes" xml:space="preserve">
          <source>SplitN::scan</source>
          <target state="translated">SplitN::scan</target>
        </trans-unit>
        <trans-unit id="435fa26b031ae4d199174bcbc3d795df2087b1b5" translate="yes" xml:space="preserve">
          <source>SplitN::size_hint</source>
          <target state="translated">SplitN::size_hint</target>
        </trans-unit>
        <trans-unit id="495748c4da8d66742956405a3eada3abc1ebff04" translate="yes" xml:space="preserve">
          <source>SplitN::skip</source>
          <target state="translated">SplitN::skip</target>
        </trans-unit>
        <trans-unit id="6f36e16ed19c5224b87c544f0e92c8433a66b3b6" translate="yes" xml:space="preserve">
          <source>SplitN::skip_while</source>
          <target state="translated">SplitN::skip_while</target>
        </trans-unit>
        <trans-unit id="fc330722be71050cea54d16a8bf776b1244f6090" translate="yes" xml:space="preserve">
          <source>SplitN::step_by</source>
          <target state="translated">SplitN::step_by</target>
        </trans-unit>
        <trans-unit id="fc92ae01a6c4930351b4ef1ae82d8220a544936c" translate="yes" xml:space="preserve">
          <source>SplitN::sum</source>
          <target state="translated">SplitN::sum</target>
        </trans-unit>
        <trans-unit id="914ed2a8fc50777e1c082f41134b2b1f3f199c0b" translate="yes" xml:space="preserve">
          <source>SplitN::take</source>
          <target state="translated">SplitN::take</target>
        </trans-unit>
        <trans-unit id="c0b9cf8b5a279495349959e0936942f8c893dd65" translate="yes" xml:space="preserve">
          <source>SplitN::take_while</source>
          <target state="translated">SplitN::take_while</target>
        </trans-unit>
        <trans-unit id="8a17c8faeb884b01df70ea9aedafbea6c9e56234" translate="yes" xml:space="preserve">
          <source>SplitN::to_owned</source>
          <target state="translated">SplitN::to_owned</target>
        </trans-unit>
        <trans-unit id="d9cfaaff73dc1534a24fc707da5e0daa472edd2a" translate="yes" xml:space="preserve">
          <source>SplitN::try_fold</source>
          <target state="translated">SplitN::try_fold</target>
        </trans-unit>
        <trans-unit id="871ac84a3325fa781171370dec4d4e81593149f3" translate="yes" xml:space="preserve">
          <source>SplitN::try_for_each</source>
          <target state="translated">SplitN::try_for_each</target>
        </trans-unit>
        <trans-unit id="85319574adacf15e91791d48524fc096d71f6cfd" translate="yes" xml:space="preserve">
          <source>SplitN::try_from</source>
          <target state="translated">SplitN::try_from</target>
        </trans-unit>
        <trans-unit id="3b99ca99bba0ef038a7c1d5f8d8a182ba56f328b" translate="yes" xml:space="preserve">
          <source>SplitN::try_into</source>
          <target state="translated">SplitN::try_into</target>
        </trans-unit>
        <trans-unit id="4646de3a3fe2f07ea85477fb52285e49f53a1cf1" translate="yes" xml:space="preserve">
          <source>SplitN::type_id</source>
          <target state="translated">SplitN::type_id</target>
        </trans-unit>
        <trans-unit id="f49e5a4e63257e311308f8360781592c18f70410" translate="yes" xml:space="preserve">
          <source>SplitN::unzip</source>
          <target state="translated">SplitN::unzip</target>
        </trans-unit>
        <trans-unit id="8f152e20d90c1bc5f244fe76d7ddb23dc2b822f0" translate="yes" xml:space="preserve">
          <source>SplitN::zip</source>
          <target state="translated">SplitN::zip</target>
        </trans-unit>
        <trans-unit id="37f53f27df8a1e82b06b34901a971d08ceefaf3c" translate="yes" xml:space="preserve">
          <source>SplitNMut</source>
          <target state="translated">SplitNMut</target>
        </trans-unit>
        <trans-unit id="4c0e338962bdbbfc29ce29cc826ccca9f18dd5d7" translate="yes" xml:space="preserve">
          <source>SplitNMut::all</source>
          <target state="translated">SplitNMut::all</target>
        </trans-unit>
        <trans-unit id="c47eedee42d52d9fb8ec91b13118b22a6fd2c148" translate="yes" xml:space="preserve">
          <source>SplitNMut::any</source>
          <target state="translated">SplitNMut::any</target>
        </trans-unit>
        <trans-unit id="e49c8c20ae615b0c4cb6c25fc6c29c1057dbd2d4" translate="yes" xml:space="preserve">
          <source>SplitNMut::borrow</source>
          <target state="translated">SplitNMut::borrow</target>
        </trans-unit>
        <trans-unit id="c9b0d189b4d8f4a09740b9dc37fef976b4b0a7c8" translate="yes" xml:space="preserve">
          <source>SplitNMut::borrow_mut</source>
          <target state="translated">SplitNMut::borrow_mut</target>
        </trans-unit>
        <trans-unit id="c30a28755b28eae83a0128bd575ea45d1445f248" translate="yes" xml:space="preserve">
          <source>SplitNMut::by_ref</source>
          <target state="translated">SplitNMut::by_ref</target>
        </trans-unit>
        <trans-unit id="4cee4fd56377c8d4c737a159c4626eb9b66b0abd" translate="yes" xml:space="preserve">
          <source>SplitNMut::chain</source>
          <target state="translated">SplitNMut::chain</target>
        </trans-unit>
        <trans-unit id="48872779a65635a20c7efbd50dec9071cf416868" translate="yes" xml:space="preserve">
          <source>SplitNMut::cloned</source>
          <target state="translated">SplitNMut::cloned</target>
        </trans-unit>
        <trans-unit id="136be0de650548dccf182a46618f53fb577b02c8" translate="yes" xml:space="preserve">
          <source>SplitNMut::cmp</source>
          <target state="translated">SplitNMut::cmp</target>
        </trans-unit>
        <trans-unit id="6fa41a9fc3044e9e0a18e9ae5ec96b6e0be20d93" translate="yes" xml:space="preserve">
          <source>SplitNMut::collect</source>
          <target state="translated">SplitNMut::collect</target>
        </trans-unit>
        <trans-unit id="539e380600f3cf3a398bedb5ea5ac9faa86e3bd2" translate="yes" xml:space="preserve">
          <source>SplitNMut::copied</source>
          <target state="translated">SplitNMut::copied</target>
        </trans-unit>
        <trans-unit id="2274ac91cf6da704ec8620d24b7c91e7e3a0eb08" translate="yes" xml:space="preserve">
          <source>SplitNMut::count</source>
          <target state="translated">SplitNMut::count</target>
        </trans-unit>
        <trans-unit id="605e1c5227d054d4a043a2e31b51bc7663e413f6" translate="yes" xml:space="preserve">
          <source>SplitNMut::cycle</source>
          <target state="translated">SplitNMut::cycle</target>
        </trans-unit>
        <trans-unit id="97821e6bfcd7e54b98d576388e7877979b57cad5" translate="yes" xml:space="preserve">
          <source>SplitNMut::enumerate</source>
          <target state="translated">SplitNMut::enumerate</target>
        </trans-unit>
        <trans-unit id="f64bc79a9760b64a3611b9c1a200fe6953bb5d91" translate="yes" xml:space="preserve">
          <source>SplitNMut::eq</source>
          <target state="translated">SplitNMut::eq</target>
        </trans-unit>
        <trans-unit id="7e3820c2690f61a72e05851bf81b24e11ade74f5" translate="yes" xml:space="preserve">
          <source>SplitNMut::filter</source>
          <target state="translated">SplitNMut::filter</target>
        </trans-unit>
        <trans-unit id="cf701ab6ae23e84f217a1644b271553fab59b484" translate="yes" xml:space="preserve">
          <source>SplitNMut::filter_map</source>
          <target state="translated">SplitNMut::filter_map</target>
        </trans-unit>
        <trans-unit id="b4da8042a147027f8d622ce501ea15b83f6b7239" translate="yes" xml:space="preserve">
          <source>SplitNMut::find</source>
          <target state="translated">SplitNMut::find</target>
        </trans-unit>
        <trans-unit id="7f01897f6836b7fcc7b7abaab25f0db4f47d9a0e" translate="yes" xml:space="preserve">
          <source>SplitNMut::find_map</source>
          <target state="translated">SplitNMut::find_map</target>
        </trans-unit>
        <trans-unit id="632cc2377e06466fd8139a1e3b82897ba3aad182" translate="yes" xml:space="preserve">
          <source>SplitNMut::flat_map</source>
          <target state="translated">SplitNMut::flat_map</target>
        </trans-unit>
        <trans-unit id="7d61f56bb2bd62c551fb454570e1002c65f8e0d6" translate="yes" xml:space="preserve">
          <source>SplitNMut::flatten</source>
          <target state="translated">SplitNMut::flatten</target>
        </trans-unit>
        <trans-unit id="0dea7da0d6e45d6a8174a8df0e0cdad6f9af6992" translate="yes" xml:space="preserve">
          <source>SplitNMut::fmt</source>
          <target state="translated">SplitNMut::fmt</target>
        </trans-unit>
        <trans-unit id="933cb3c024bff66f63b42715c659ec4ed5ab427b" translate="yes" xml:space="preserve">
          <source>SplitNMut::fold</source>
          <target state="translated">SplitNMut::fold</target>
        </trans-unit>
        <trans-unit id="0f8977d28b6e4f6d4cbf0582820764b7dccfc1e6" translate="yes" xml:space="preserve">
          <source>SplitNMut::for_each</source>
          <target state="translated">SplitNMut::for_each</target>
        </trans-unit>
        <trans-unit id="0c579c727e80083a312253a77c4beaff91e6de3e" translate="yes" xml:space="preserve">
          <source>SplitNMut::from</source>
          <target state="translated">SplitNMut::from</target>
        </trans-unit>
        <trans-unit id="25429d25e481c3c08c825c5d40c9054a1e62d368" translate="yes" xml:space="preserve">
          <source>SplitNMut::fuse</source>
          <target state="translated">SplitNMut::fuse</target>
        </trans-unit>
        <trans-unit id="2adeddd6086e37d9999f95255c521d8fd1340be0" translate="yes" xml:space="preserve">
          <source>SplitNMut::ge</source>
          <target state="translated">SplitNMut::ge</target>
        </trans-unit>
        <trans-unit id="c588cf62255c1ab0a8711fa004ba5fe334206d65" translate="yes" xml:space="preserve">
          <source>SplitNMut::gt</source>
          <target state="translated">SplitNMut::gt</target>
        </trans-unit>
        <trans-unit id="edc2c238a403b4882bbd5d050bc089826c959abe" translate="yes" xml:space="preserve">
          <source>SplitNMut::inspect</source>
          <target state="translated">SplitNMut::inspect</target>
        </trans-unit>
        <trans-unit id="d1e9b9a48ffffd32edcb025916c55122fe9f5093" translate="yes" xml:space="preserve">
          <source>SplitNMut::into</source>
          <target state="translated">SplitNMut::into</target>
        </trans-unit>
        <trans-unit id="54b9fa0fc0c6efeea3b1bf9f2f6ed4a2606fd980" translate="yes" xml:space="preserve">
          <source>SplitNMut::into_iter</source>
          <target state="translated">SplitNMut::into_iter</target>
        </trans-unit>
        <trans-unit id="8cee2a2c07cc63a9afc3c746a8ae10737e22a7e5" translate="yes" xml:space="preserve">
          <source>SplitNMut::is_sorted</source>
          <target state="translated">SplitNMut::is_sorted</target>
        </trans-unit>
        <trans-unit id="57c830641ceb4a77f1a978890a1d0858ecf11e85" translate="yes" xml:space="preserve">
          <source>SplitNMut::is_sorted_by</source>
          <target state="translated">SplitNMut::is_sorted_by</target>
        </trans-unit>
        <trans-unit id="017061da8a5bf0d758e0b8a23a787c7e30bc38b8" translate="yes" xml:space="preserve">
          <source>SplitNMut::is_sorted_by_key</source>
          <target state="translated">SplitNMut::is_sorted_by_key</target>
        </trans-unit>
        <trans-unit id="9056b917ae8d9911661189718ca7f2c454a0ae4d" translate="yes" xml:space="preserve">
          <source>SplitNMut::last</source>
          <target state="translated">SplitNMut::last</target>
        </trans-unit>
        <trans-unit id="76296c2a39c2177e659dc061adde050bf166095d" translate="yes" xml:space="preserve">
          <source>SplitNMut::le</source>
          <target state="translated">SplitNMut::le</target>
        </trans-unit>
        <trans-unit id="91045453f4e83beb6f056ffd764031695b65d058" translate="yes" xml:space="preserve">
          <source>SplitNMut::lt</source>
          <target state="translated">SplitNMut::lt</target>
        </trans-unit>
        <trans-unit id="3396ae835432a2640e4b743bd5e9c1a32606f138" translate="yes" xml:space="preserve">
          <source>SplitNMut::map</source>
          <target state="translated">SplitNMut::map</target>
        </trans-unit>
        <trans-unit id="209efacf4d587c105d733cca25095d03793ece6a" translate="yes" xml:space="preserve">
          <source>SplitNMut::max</source>
          <target state="translated">SplitNMut::max</target>
        </trans-unit>
        <trans-unit id="287c9cbce4c84663fa5c6ad76d0b898fe7b12a72" translate="yes" xml:space="preserve">
          <source>SplitNMut::max_by</source>
          <target state="translated">SplitNMut::max_by</target>
        </trans-unit>
        <trans-unit id="5a48c762d71fececea5967ad45f9c482979955bc" translate="yes" xml:space="preserve">
          <source>SplitNMut::max_by_key</source>
          <target state="translated">SplitNMut::max_by_key</target>
        </trans-unit>
        <trans-unit id="13d6b2a062d40c56e264109030e1084da951c3f6" translate="yes" xml:space="preserve">
          <source>SplitNMut::min</source>
          <target state="translated">SplitNMut::min</target>
        </trans-unit>
        <trans-unit id="92c1d5f9da2c477e2875ee1e54546716f584d742" translate="yes" xml:space="preserve">
          <source>SplitNMut::min_by</source>
          <target state="translated">SplitNMut::min_by</target>
        </trans-unit>
        <trans-unit id="cb4cf67fa183bc4195c8a335896088905c209d8e" translate="yes" xml:space="preserve">
          <source>SplitNMut::min_by_key</source>
          <target state="translated">SplitNMut::min_by_key</target>
        </trans-unit>
        <trans-unit id="e422085bfbae789622692a9f57482510de70a51c" translate="yes" xml:space="preserve">
          <source>SplitNMut::ne</source>
          <target state="translated">SplitNMut::ne</target>
        </trans-unit>
        <trans-unit id="79701a290397f83dff7191fc5d522087d64b94ad" translate="yes" xml:space="preserve">
          <source>SplitNMut::next</source>
          <target state="translated">SplitNMut::next</target>
        </trans-unit>
        <trans-unit id="1f3af99622e8b046c0dafa0e70815c8a440e6d96" translate="yes" xml:space="preserve">
          <source>SplitNMut::nth</source>
          <target state="translated">SplitNMut::nth</target>
        </trans-unit>
        <trans-unit id="1ba51ebb31573ee9a87ca245b7dad3e618c6afaf" translate="yes" xml:space="preserve">
          <source>SplitNMut::partial_cmp</source>
          <target state="translated">SplitNMut::partial_cmp</target>
        </trans-unit>
        <trans-unit id="7a68bf0b6edddb7e68babe6af2515cd4a71f32bf" translate="yes" xml:space="preserve">
          <source>SplitNMut::partition</source>
          <target state="translated">SplitNMut::partition</target>
        </trans-unit>
        <trans-unit id="9e2b52abf4624a0f31359d085ea9282907f3ce13" translate="yes" xml:space="preserve">
          <source>SplitNMut::peekable</source>
          <target state="translated">SplitNMut::peekable</target>
        </trans-unit>
        <trans-unit id="9eca2690b3367c1435eb105cfcece74e692a47f5" translate="yes" xml:space="preserve">
          <source>SplitNMut::position</source>
          <target state="translated">SplitNMut::position</target>
        </trans-unit>
        <trans-unit id="da540d19fb430cc61cfcb584f1eecc7702b474d5" translate="yes" xml:space="preserve">
          <source>SplitNMut::product</source>
          <target state="translated">SplitNMut::product</target>
        </trans-unit>
        <trans-unit id="133612340955fa3cfb981ad8291be05f4372a836" translate="yes" xml:space="preserve">
          <source>SplitNMut::rev</source>
          <target state="translated">SplitNMut::rev</target>
        </trans-unit>
        <trans-unit id="343f8e1ef12460ed78461507e7620a1f0528f71f" translate="yes" xml:space="preserve">
          <source>SplitNMut::rposition</source>
          <target state="translated">SplitNMut::rposition</target>
        </trans-unit>
        <trans-unit id="aea64acadcd9a6942de2bda0b5a7a554c09d17b5" translate="yes" xml:space="preserve">
          <source>SplitNMut::scan</source>
          <target state="translated">SplitNMut::scan</target>
        </trans-unit>
        <trans-unit id="bbc6e66edd951ef18e6c581252e98557724ff623" translate="yes" xml:space="preserve">
          <source>SplitNMut::size_hint</source>
          <target state="translated">SplitNMut::size_hint</target>
        </trans-unit>
        <trans-unit id="bcbbf9f169d0b1158cfd33aed850cb1a285ed04b" translate="yes" xml:space="preserve">
          <source>SplitNMut::skip</source>
          <target state="translated">SplitNMut::skip</target>
        </trans-unit>
        <trans-unit id="50e0922664c88a6a9de5cd8ca66589685407e929" translate="yes" xml:space="preserve">
          <source>SplitNMut::skip_while</source>
          <target state="translated">SplitNMut::skip_while</target>
        </trans-unit>
        <trans-unit id="e26f2196c1c4e81517879036c030ac1bf9fb7242" translate="yes" xml:space="preserve">
          <source>SplitNMut::step_by</source>
          <target state="translated">SplitNMut::step_by</target>
        </trans-unit>
        <trans-unit id="22c8deb5450c8dc8765d39e617368d45985d09ca" translate="yes" xml:space="preserve">
          <source>SplitNMut::sum</source>
          <target state="translated">SplitNMut::sum</target>
        </trans-unit>
        <trans-unit id="321673a9cd4fe8f8dd1539d820e59098f0589598" translate="yes" xml:space="preserve">
          <source>SplitNMut::take</source>
          <target state="translated">SplitNMut::take</target>
        </trans-unit>
        <trans-unit id="77c59de28ec49ac8197d5bce7ea567716d9e4f3c" translate="yes" xml:space="preserve">
          <source>SplitNMut::take_while</source>
          <target state="translated">SplitNMut::take_while</target>
        </trans-unit>
        <trans-unit id="d929a36e3ae42c5778bff7a70486b9efe45f49b9" translate="yes" xml:space="preserve">
          <source>SplitNMut::try_fold</source>
          <target state="translated">SplitNMut::try_fold</target>
        </trans-unit>
        <trans-unit id="1e3a2cc95cc68bd1db268249420579015c6b1f1a" translate="yes" xml:space="preserve">
          <source>SplitNMut::try_for_each</source>
          <target state="translated">SplitNMut::try_for_each</target>
        </trans-unit>
        <trans-unit id="5513ba597776f2350b8c04bb4dfea4ebb6afdff9" translate="yes" xml:space="preserve">
          <source>SplitNMut::try_from</source>
          <target state="translated">SplitNMut::try_from</target>
        </trans-unit>
        <trans-unit id="39d347607af42c6a75d0c65f8a8f9382b57f340d" translate="yes" xml:space="preserve">
          <source>SplitNMut::try_into</source>
          <target state="translated">SplitNMut::try_into</target>
        </trans-unit>
        <trans-unit id="481cfa894e1b4c06b8279766b0d45177f62871ab" translate="yes" xml:space="preserve">
          <source>SplitNMut::type_id</source>
          <target state="translated">SplitNMut::type_id</target>
        </trans-unit>
        <trans-unit id="b68dc2de077efc2a96f8d45596a0acd71cf05007" translate="yes" xml:space="preserve">
          <source>SplitNMut::unzip</source>
          <target state="translated">SplitNMut::unzip</target>
        </trans-unit>
        <trans-unit id="b0396af098fd20bc04ef554c33dc5ce21425086e" translate="yes" xml:space="preserve">
          <source>SplitNMut::zip</source>
          <target state="translated">SplitNMut::zip</target>
        </trans-unit>
        <trans-unit id="ecb7b24980fc6948e26c7406d71646df8ef64d9b" translate="yes" xml:space="preserve">
          <source>SplitPaths</source>
          <target state="translated">SplitPaths</target>
        </trans-unit>
        <trans-unit id="bcb92c8d23e31b7a36777e6be769d3f239505088" translate="yes" xml:space="preserve">
          <source>SplitPaths::all</source>
          <target state="translated">SplitPaths::all</target>
        </trans-unit>
        <trans-unit id="b101ce53a83b89861d80d8838391a2cc0a33c44e" translate="yes" xml:space="preserve">
          <source>SplitPaths::any</source>
          <target state="translated">SplitPaths::any</target>
        </trans-unit>
        <trans-unit id="7edab2871d8fc2ec00dc27f02b962160797b6efb" translate="yes" xml:space="preserve">
          <source>SplitPaths::borrow</source>
          <target state="translated">SplitPaths::borrow</target>
        </trans-unit>
        <trans-unit id="d63e1c5be3f98a190f7f0e37c98fb43100453cbe" translate="yes" xml:space="preserve">
          <source>SplitPaths::borrow_mut</source>
          <target state="translated">SplitPaths::borrow_mut</target>
        </trans-unit>
        <trans-unit id="872b2fd231032679a497e2a9a5546e374bd7ce7c" translate="yes" xml:space="preserve">
          <source>SplitPaths::by_ref</source>
          <target state="translated">SplitPaths::by_ref</target>
        </trans-unit>
        <trans-unit id="555f0f50aca9dc26a62aa3d74aaab86b7494e191" translate="yes" xml:space="preserve">
          <source>SplitPaths::chain</source>
          <target state="translated">SplitPaths::chain</target>
        </trans-unit>
        <trans-unit id="f8da78e1024a3b666234e3627801f46b9d1a930c" translate="yes" xml:space="preserve">
          <source>SplitPaths::cloned</source>
          <target state="translated">SplitPaths::cloned</target>
        </trans-unit>
        <trans-unit id="6d3dbd20c7e1433a1b2b38d798f779e3c6ec966c" translate="yes" xml:space="preserve">
          <source>SplitPaths::cmp</source>
          <target state="translated">SplitPaths::cmp</target>
        </trans-unit>
        <trans-unit id="6a464f6e27b55ccea222caf1821e67cd6791511a" translate="yes" xml:space="preserve">
          <source>SplitPaths::collect</source>
          <target state="translated">SplitPaths::collect</target>
        </trans-unit>
        <trans-unit id="08c417fe4992ea54915c1cab35c0560285f9d75b" translate="yes" xml:space="preserve">
          <source>SplitPaths::copied</source>
          <target state="translated">SplitPaths::copied</target>
        </trans-unit>
        <trans-unit id="e1aa6c5f1eaa69159b50997627bb004e6b5a0bae" translate="yes" xml:space="preserve">
          <source>SplitPaths::count</source>
          <target state="translated">SplitPaths::count</target>
        </trans-unit>
        <trans-unit id="aabdd2130c2cd42547f3a394603830047d3fd723" translate="yes" xml:space="preserve">
          <source>SplitPaths::cycle</source>
          <target state="translated">SplitPaths::cycle</target>
        </trans-unit>
        <trans-unit id="5b1b1cbbfedcac997c352e3ca2c867281238a15f" translate="yes" xml:space="preserve">
          <source>SplitPaths::enumerate</source>
          <target state="translated">SplitPaths::enumerate</target>
        </trans-unit>
        <trans-unit id="1c420169f4480d6f5457322b64217abdd3e5bd7c" translate="yes" xml:space="preserve">
          <source>SplitPaths::eq</source>
          <target state="translated">SplitPaths::eq</target>
        </trans-unit>
        <trans-unit id="aa8e9435275a1e06354bc3b45f9f9f789a3eb18f" translate="yes" xml:space="preserve">
          <source>SplitPaths::filter</source>
          <target state="translated">SplitPaths::filter</target>
        </trans-unit>
        <trans-unit id="e97d30671a4a7d6834d87aceea858199751eecaa" translate="yes" xml:space="preserve">
          <source>SplitPaths::filter_map</source>
          <target state="translated">SplitPaths::filter_map</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
