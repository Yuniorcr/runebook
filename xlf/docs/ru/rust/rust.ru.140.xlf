<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ru" datatype="htmlbody" original="rust">
    <body>
      <group id="rust">
        <trans-unit id="1ff8f63be235b7ea2055383c2e9b72b84c7bd07e" translate="yes" xml:space="preserve">
          <source>Notable traits for Scan&amp;lt;I, St, F&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="985d073dbfe88a46f9a5d9a064d7c96c1a9ddbdb" translate="yes" xml:space="preserve">
          <source>Notable traits for Skip&amp;lt;I&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4f0eaba444b8b7b51819626fe7d8a57f993cdf9a" translate="yes" xml:space="preserve">
          <source>Notable traits for SkipWhile&amp;lt;I, P&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ca8f82912aa693cda641dbb9a8f2619f7e15ddea" translate="yes" xml:space="preserve">
          <source>Notable traits for Splice&amp;lt;'_, I&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="12d474f38bf85bfc1567b98ee3eb463b107a0ce2" translate="yes" xml:space="preserve">
          <source>Notable traits for Splice&amp;lt;'_, I, A&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ef399e09acd6419098e7cfcabf45df6744dbfbc6" translate="yes" xml:space="preserve">
          <source>Notable traits for Split&amp;lt;'a, P&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e1f967c2a861c03dbdc5cf356551e97bb60b084f" translate="yes" xml:space="preserve">
          <source>Notable traits for Split&amp;lt;'a, T, P&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e39a8c3f513e0738a443ac406858d3b7bc026953" translate="yes" xml:space="preserve">
          <source>Notable traits for Split&amp;lt;B&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d1d5f710d040b4a11a5d716baa68dcf2d617217b" translate="yes" xml:space="preserve">
          <source>Notable traits for SplitAsciiWhitespace&amp;lt;'a&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fb7865e840a56b3e0895b5ec1bdbc829b951351d" translate="yes" xml:space="preserve">
          <source>Notable traits for SplitInclusive&amp;lt;'a, T, P&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9818f4f1fdfe2d933ac6655c5c4953e8aff5a7e1" translate="yes" xml:space="preserve">
          <source>Notable traits for SplitInclusiveMut&amp;lt;'a, T, P&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0838dd01ca950ce33cd2058b8d0ff4fd43821113" translate="yes" xml:space="preserve">
          <source>Notable traits for SplitMut&amp;lt;'a, T, P&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e5880f295f9b58cf5125e602e8fae3c01c02bfbe" translate="yes" xml:space="preserve">
          <source>Notable traits for SplitN&amp;lt;'a, P&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7599a2d009c0938be30293d468e1a75ce65377d5" translate="yes" xml:space="preserve">
          <source>Notable traits for SplitN&amp;lt;'a, T, P&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="37e0cb911750681c09ba0b190a9557e42adc2590" translate="yes" xml:space="preserve">
          <source>Notable traits for SplitNMut&amp;lt;'a, T, P&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f48dc2915683e916503c8dcf3e59f491126656bf" translate="yes" xml:space="preserve">
          <source>Notable traits for SplitTerminator&amp;lt;'a, P&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d707147c6fab5cc551e32ce5467c609e374e4f50" translate="yes" xml:space="preserve">
          <source>Notable traits for SplitWhitespace&amp;lt;'a&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="437caeb56851568308dca5cb78609789356f0853" translate="yes" xml:space="preserve">
          <source>Notable traits for StderrLock&amp;lt;'_&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="48c194fa1f0bd2541f390bd24896165b0c23c7e5" translate="yes" xml:space="preserve">
          <source>Notable traits for StdinLock&amp;lt;'_&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ee33f3797cb0a601933ebede73fe50f827c75b6e" translate="yes" xml:space="preserve">
          <source>Notable traits for StdoutLock&amp;lt;'_&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3e0ae991bfa5ac7c9c453dec86d28b7d72d47073" translate="yes" xml:space="preserve">
          <source>Notable traits for StepBy&amp;lt;I&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="83f5fe0a710de90155479f39d5f77c153488c0a5" translate="yes" xml:space="preserve">
          <source>Notable traits for Successors&amp;lt;T, F&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="647ebf3b1fc10e80b4ce476f35a75fa114a5fab1" translate="yes" xml:space="preserve">
          <source>Notable traits for SymmetricDifference&amp;lt;'a, T&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5e0deb017937ef51088c94bb895f3902110ffe16" translate="yes" xml:space="preserve">
          <source>Notable traits for SymmetricDifference&amp;lt;'a, T, S&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6b271862886a9e625b5ac46fc4e49bcce91334f9" translate="yes" xml:space="preserve">
          <source>Notable traits for Take&amp;lt;I&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8d1491004df1c3cd73af985e7889ffe06072d374" translate="yes" xml:space="preserve">
          <source>Notable traits for Take&amp;lt;T&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8c484c47892ef31d80e9449405b6a45f7812a953" translate="yes" xml:space="preserve">
          <source>Notable traits for TakeWhile&amp;lt;I, P&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ce43b5e8ae4c3d3abba449747c3b74da4e5cf5b2" translate="yes" xml:space="preserve">
          <source>Notable traits for TcpStream</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0e1590902cedb9997418d686f3b41f48a7faa5a8" translate="yes" xml:space="preserve">
          <source>Notable traits for ToLowercase</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="71cea9ba6a0245158a668390fdcdb390b3ee3a95" translate="yes" xml:space="preserve">
          <source>Notable traits for ToUppercase</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2bc316517c095ef6246876fb36dafafef8842df0" translate="yes" xml:space="preserve">
          <source>Notable traits for TryIter&amp;lt;'a, T&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="36cd3ac7d99db311332b377e21251e4fba5322ec" translate="yes" xml:space="preserve">
          <source>Notable traits for Union&amp;lt;'a, T&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a1623bf8aee40498694e04160abcc7cc94e51160" translate="yes" xml:space="preserve">
          <source>Notable traits for Union&amp;lt;'a, T, S&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="41fbaa40eb7f00c2be283feaa1fbb38e29701e83" translate="yes" xml:space="preserve">
          <source>Notable traits for UnixStream</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9c50d1662883c24d433db05a688c0aa44526ac2e" translate="yes" xml:space="preserve">
          <source>Notable traits for Values&amp;lt;'a, K, V&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="58c872469ad3d287548b76d4b848eba9a4a4c7d9" translate="yes" xml:space="preserve">
          <source>Notable traits for ValuesMut&amp;lt;'a, K, V&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="34aac67be859564d9e8c0c60e00e2a029f471028" translate="yes" xml:space="preserve">
          <source>Notable traits for Vec&amp;lt;u8&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3f1ce7df300d5a68156470029c1320d12946032a" translate="yes" xml:space="preserve">
          <source>Notable traits for Windows&amp;lt;'a, T&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a8ed148e4a8689fea1373b25b6f60ce6eb17047c" translate="yes" xml:space="preserve">
          <source>Notable traits for Zip&amp;lt;A, B&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f8f7449873c705105af159faa9949fb17717e319" translate="yes" xml:space="preserve">
          <source>Notably this function ignores the &lt;code&gt;flag&lt;/code&gt; parameters.</source>
          <target state="translated">Примечательно, что эта функция игнорирует параметры &lt;code&gt;flag&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0a8a9d000182248a3513e5a205741807831d1022" translate="yes" xml:space="preserve">
          <source>Notably: &lt;a href=&quot;variables&quot;&gt;variables&lt;/a&gt;, function parameters, &lt;a href=&quot;items/constant-items&quot;&gt;const&lt;/a&gt; and &lt;a href=&quot;items/static-items&quot;&gt;static&lt;/a&gt; items must be &lt;code&gt;Sized&lt;/code&gt;.</source>
          <target state="translated">В частности: &lt;a href=&quot;variables&quot;&gt;переменные&lt;/a&gt; , параметры функций, &lt;a href=&quot;items/constant-items&quot;&gt;константные&lt;/a&gt; и &lt;a href=&quot;items/static-items&quot;&gt;статические&lt;/a&gt; элементы должны иметь &lt;code&gt;Sized&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9f3163ffda0d3418a1866865fdb1ef76cb2dbf4b" translate="yes" xml:space="preserve">
          <source>Notation</source>
          <target state="translated">Notation</target>
        </trans-unit>
        <trans-unit id="2c924e3088204ee77ba681f72be3444357932fca" translate="yes" xml:space="preserve">
          <source>Note</source>
          <target state="translated">Note</target>
        </trans-unit>
        <trans-unit id="c3fe4ddff5db29b0cb1f0eb2b355940acc3e474c" translate="yes" xml:space="preserve">
          <source>Note 1: The element range is removed even if the iterator is not consumed until the end.</source>
          <target state="translated">Примечание 1:Диапазон элементов снимается,даже если итератор потребляется не до конца.</target>
        </trans-unit>
        <trans-unit id="73bad292ab0326c274afe69e790430a32b7dd7b6" translate="yes" xml:space="preserve">
          <source>Note 1: The element range is removed even if the iterator is only partially consumed or not consumed at all.</source>
          <target state="translated">Примечание 1:Диапазон элементов снимается,даже если итератор потребляется только частично или не потребляется вообще.</target>
        </trans-unit>
        <trans-unit id="375f6bc156b4954ecc954926534e181389ad6af2" translate="yes" xml:space="preserve">
          <source>Note 1: The first element of the iterator will always be returned, regardless of the step given.</source>
          <target state="translated">Примечание 1:Первый элемент итератора всегда возвращается независимо от заданного шага.</target>
        </trans-unit>
        <trans-unit id="0b81032a73d39d946d8d288ed04acdd88cf53ecf" translate="yes" xml:space="preserve">
          <source>Note 2: It is unspecified how many elements are removed from the deque, if the &lt;code&gt;Drain&lt;/code&gt; value is not dropped, but the borrow it holds expires (e.g., due to &lt;code&gt;mem::forget&lt;/code&gt;).</source>
          <target state="translated">Примечание 2: не указано, сколько элементов удаляется из двухсторонней очереди, если значение &lt;code&gt;Drain&lt;/code&gt; не сбрасывается, но срок заимствования истекает (например, из-за &lt;code&gt;mem::forget&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="2ad2f022b2009c4ce2fc1713a74b64ee404e87d1" translate="yes" xml:space="preserve">
          <source>Note 2: It is unspecified how many elements are removed from the vector if the &lt;code&gt;Drain&lt;/code&gt; value is leaked.</source>
          <target state="translated">Примечание 2: не указано, сколько элементов удаляется из вектора, если значение &lt;code&gt;Drain&lt;/code&gt; утекло.</target>
        </trans-unit>
        <trans-unit id="506d02500f5463906be1bc26ef13102642229ab6" translate="yes" xml:space="preserve">
          <source>Note 2: The time at which ignored elements are pulled is not fixed. &lt;code&gt;StepBy&lt;/code&gt; behaves like the sequence &lt;code&gt;next(), nth(step-1), nth(step-1), &amp;hellip;&lt;/code&gt;, but is also free to behave like the sequence &lt;code&gt;advance_n_and_return_first(step), advance_n_and_return_first(step), &amp;hellip;&lt;/code&gt; Which way is used may change for some iterators for performance reasons. The second way will advance the iterator earlier and may consume more items.</source>
          <target state="translated">Примечание 2: время вытягивания игнорируемых элементов не фиксировано. &lt;code&gt;StepBy&lt;/code&gt; ведет себя как последовательность &lt;code&gt;next(), nth(step-1), nth(step-1), &amp;hellip;&lt;/code&gt; , но также может вести себя как последовательность &lt;code&gt;advance_n_and_return_first(step), advance_n_and_return_first(step), &amp;hellip;&lt;/code&gt; Какой путь используется, может изменить некоторые итераторы по соображениям производительности. Второй способ продвинет итератор раньше и может потреблять больше элементов.</target>
        </trans-unit>
        <trans-unit id="3276127b29ca84c8dd6a3e6919af65a48a707afa" translate="yes" xml:space="preserve">
          <source>Note also that in Listing 19-1 and 19-3, we created &lt;code&gt;*const i32&lt;/code&gt; and &lt;code&gt;*mut i32&lt;/code&gt; raw pointers that both pointed to the same memory location, where &lt;code&gt;num&lt;/code&gt; is stored. If we instead tried to create an immutable and a mutable reference to &lt;code&gt;num&lt;/code&gt;, the code would not have compiled because Rust&amp;rsquo;s ownership rules don&amp;rsquo;t allow a mutable reference at the same time as any immutable references. With raw pointers, we can create a mutable pointer and an immutable pointer to the same location and change data through the mutable pointer, potentially creating a data race. Be careful!</source>
          <target state="translated">Также обратите внимание, что в листингах 19-1 и 19-3 мы создали необработанные указатели &lt;code&gt;*const i32&lt;/code&gt; и &lt;code&gt;*mut i32&lt;/code&gt; , которые оба указывают на одну и ту же ячейку памяти, где хранится &lt;code&gt;num&lt;/code&gt; . Если бы мы вместо этого попытались создать неизменяемую и изменяемую ссылку на &lt;code&gt;num&lt;/code&gt; , код не был бы скомпилирован, потому что правила владения Rust не допускают изменяемую ссылку одновременно с любыми неизменяемыми ссылками. С помощью необработанных указателей мы можем создать изменяемый указатель и неизменяемый указатель на одно и то же место и изменять данные с помощью изменяемого указателя, потенциально создавая гонку данных. Быть осторожен!</target>
        </trans-unit>
        <trans-unit id="6de37aeaf259b01294052b110f1c5546480ac1df" translate="yes" xml:space="preserve">
          <source>Note also that in the context of this formalism, the term &quot;token&quot; generally &lt;em&gt;includes&lt;/em&gt; simple NTs.</source>
          <target state="translated">Также обратите внимание, что в контексте этого формализма термин &amp;laquo;токен&amp;raquo; обычно &lt;em&gt;включает&lt;/em&gt; простые NT.</target>
        </trans-unit>
        <trans-unit id="ddbcd5d0f2ca8f557f88753b63844e194aa420bc" translate="yes" xml:space="preserve">
          <source>Note however that:</source>
          <target state="translated">Обратите внимание,однако:</target>
        </trans-unit>
        <trans-unit id="ac8dc1e3e610d665d4339a3068108ed3e4e3d7f2" translate="yes" xml:space="preserve">
          <source>Note however, that &lt;code&gt;black_box&lt;/code&gt; is only (and can only be) provided on a &quot;best-effort&quot; basis. The extent to which it can block optimisations may vary depending upon the platform and code-gen backend used. Programs cannot rely on &lt;code&gt;black_box&lt;/code&gt; for &lt;em&gt;correctness&lt;/em&gt; in any way.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="09b6433b842ad661442a50c48f705bbda92a3877" translate="yes" xml:space="preserve">
          <source>Note on locale</source>
          <target state="translated">Примечание на месте</target>
        </trans-unit>
        <trans-unit id="6dac41f357fcb628dff23b9354a4451a8f0457e9" translate="yes" xml:space="preserve">
          <source>Note that &amp;amp;Any is limited to testing whether a value is of a specified concrete type, and cannot be used to test whether a type implements a trait.</source>
          <target state="translated">Обратите внимание, что &amp;amp; Any ограничено проверкой того, принадлежит ли значение указанному конкретному типу, и не может использоваться для проверки того, реализует ли тип признак.</target>
        </trans-unit>
        <trans-unit id="57e530ae79447e200db1291082ac88c201431874" translate="yes" xml:space="preserve">
          <source>Note that &lt;a href=&quot;../ptr/fn.drop_in_place&quot;&gt;&lt;code&gt;drop_in_place&lt;/code&gt;&lt;/a&gt; already performs this check, so if your workload can be reduced to some small number of &lt;a href=&quot;../ptr/fn.drop_in_place&quot;&gt;&lt;code&gt;drop_in_place&lt;/code&gt;&lt;/a&gt; calls, using this is unnecessary. In particular note that you can &lt;a href=&quot;../ptr/fn.drop_in_place&quot;&gt;&lt;code&gt;drop_in_place&lt;/code&gt;&lt;/a&gt; a slice, and that will do a single needs_drop check for all the values.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9bf762ffc91bdd3eff38c069a4a949827e702fcc" translate="yes" xml:space="preserve">
          <source>Note that &lt;a href=&quot;../sync/mpsc/index&quot;&gt;&lt;code&gt;channel&lt;/code&gt;&lt;/a&gt;s for example are implemented using this primitive. Indeed when you call &lt;code&gt;send&lt;/code&gt; or &lt;code&gt;recv&lt;/code&gt;, which are blocking, they will yield if the channel is not available.</source>
          <target state="translated">Обратите внимание, что, например , &lt;a href=&quot;../sync/mpsc/index&quot;&gt; &lt;code&gt;channel&lt;/code&gt; &lt;/a&gt; реализованы с использованием этого примитива. Действительно, когда вы вызываете &lt;code&gt;send&lt;/code&gt; или &lt;code&gt;recv&lt;/code&gt; , которые блокируются, они будут уступать, если канал недоступен.</target>
        </trans-unit>
        <trans-unit id="b25a38a73d437340101dfed415d44fe9cc8bfeca" translate="yes" xml:space="preserve">
          <source>Note that &lt;a href=&quot;struct.childstderr&quot;&gt;&lt;code&gt;ChildStderr&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;struct.childstdout&quot;&gt;&lt;code&gt;ChildStdout&lt;/code&gt;&lt;/a&gt; implement &lt;a href=&quot;../io/trait.read&quot;&gt;&lt;code&gt;Read&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;struct.childstdin&quot;&gt;&lt;code&gt;ChildStdin&lt;/code&gt;&lt;/a&gt; implements &lt;a href=&quot;../io/trait.write&quot;&gt;&lt;code&gt;Write&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">Обратите внимание, что &lt;a href=&quot;struct.childstderr&quot;&gt; &lt;code&gt;ChildStderr&lt;/code&gt; &lt;/a&gt; и &lt;a href=&quot;struct.childstdout&quot;&gt; &lt;code&gt;ChildStdout&lt;/code&gt; &lt;/a&gt; реализуют &lt;a href=&quot;../io/trait.read&quot;&gt; &lt;code&gt;Read&lt;/code&gt; ,&lt;/a&gt; а &lt;a href=&quot;struct.childstdin&quot;&gt; &lt;code&gt;ChildStdin&lt;/code&gt; &lt;/a&gt; реализует &lt;a href=&quot;../io/trait.write&quot;&gt; &lt;code&gt;Write&lt;/code&gt; &lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="cb54b0f71bbcbfc437ecfe318e92da06296ef44e" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;&amp;amp;dyn Any&lt;/code&gt; is limited to testing whether a value is of a specified concrete type, and cannot be used to test whether a type implements a trait.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="40772281e6e9e65973c825aa35cf8a449645ff88" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;(T,)&lt;/code&gt; always denotes the type of a 1-tuple containing an element of type &lt;code&gt;T&lt;/code&gt;. The comma is necessary for syntactic disambiguation.</source>
          <target state="translated">Следует отметить , что &lt;code&gt;(T,)&lt;/code&gt; всегда обозначает тип 1-кортежа , содержащего элемент типа &lt;code&gt;T&lt;/code&gt; . Запятая необходима для устранения синтаксической неоднозначности.</target>
        </trans-unit>
        <trans-unit id="83c24ee2be7e8854e259c9b6dfc4dd85416ed0a7" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;CoerceUnsized&lt;/code&gt; is mainly used by smart pointers like &lt;code&gt;Box&lt;/code&gt;, &lt;code&gt;Rc&lt;/code&gt; and &lt;code&gt;Arc&lt;/code&gt; to be able to mark that they can coerce unsized types that they are pointing at.</source>
          <target state="translated">Обратите внимание, что &lt;code&gt;CoerceUnsized&lt;/code&gt; в основном используется интеллектуальными указателями, такими как &lt;code&gt;Box&lt;/code&gt; , &lt;code&gt;Rc&lt;/code&gt; и &lt;code&gt;Arc&lt;/code&gt; , чтобы иметь возможность отмечать, что они могут приводить к безразмерным типам, на которые они указывают.</target>
        </trans-unit>
        <trans-unit id="67f3e9957b8f2c4f460edc12ad2bfe3cbc26e031" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; is only for use in single-threaded scenarios. When we discuss concurrency in Chapter 16, we&amp;rsquo;ll cover how to do reference counting in multithreaded programs.</source>
          <target state="translated">Обратите внимание, что &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; предназначен только для использования в однопоточных сценариях. Обсуждая параллелизм в главе 16, мы рассмотрим, как выполнять подсчет ссылок в многопоточных программах.</target>
        </trans-unit>
        <trans-unit id="5d99e9077b96e1db0f895f5becbb122b93be4c0b" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;Rhs&lt;/code&gt; is &lt;code&gt;Self&lt;/code&gt; by default, but this is not mandatory.</source>
          <target state="translated">Обратите внимание, что по умолчанию &lt;code&gt;Rhs&lt;/code&gt; имеет значение &lt;code&gt;Self&lt;/code&gt; , но это не обязательно.</target>
        </trans-unit>
        <trans-unit id="2200d088885b3a3d42f0732955184ac9e811ecb3" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;Rhs&lt;/code&gt; is &lt;code&gt;Self&lt;/code&gt; by default, but this is not mandatory. For example, &lt;a href=&quot;../time/struct.systemtime&quot;&gt;&lt;code&gt;std::time::SystemTime&lt;/code&gt;&lt;/a&gt; implements &lt;code&gt;Add&amp;lt;Duration&amp;gt;&lt;/code&gt;, which permits operations of the form &lt;code&gt;SystemTime = SystemTime + Duration&lt;/code&gt;.</source>
          <target state="translated">Обратите внимание, что по умолчанию &lt;code&gt;Rhs&lt;/code&gt; имеет значение &lt;code&gt;Self&lt;/code&gt; , но это не обязательно. Например, &lt;a href=&quot;../time/struct.systemtime&quot;&gt; &lt;code&gt;std::time::SystemTime&lt;/code&gt; &lt;/a&gt; реализует &lt;code&gt;Add&amp;lt;Duration&amp;gt;&lt;/code&gt; , который разрешает операции формы &lt;code&gt;SystemTime = SystemTime + Duration&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6326c7ae251a36c65278ccf6246055e8e4c505f9" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;Rhs&lt;/code&gt; is &lt;code&gt;Self&lt;/code&gt; by default, but this is not mandatory. For example, &lt;a href=&quot;../time/struct.systemtime&quot;&gt;&lt;code&gt;std::time::SystemTime&lt;/code&gt;&lt;/a&gt; implements &lt;code&gt;Sub&amp;lt;Duration&amp;gt;&lt;/code&gt;, which permits operations of the form &lt;code&gt;SystemTime = SystemTime - Duration&lt;/code&gt;.</source>
          <target state="translated">Обратите внимание, что по умолчанию &lt;code&gt;Rhs&lt;/code&gt; имеет значение &lt;code&gt;Self&lt;/code&gt; , но это не обязательно. Например, &lt;a href=&quot;../time/struct.systemtime&quot;&gt; &lt;code&gt;std::time::SystemTime&lt;/code&gt; &lt;/a&gt; реализует &lt;code&gt;Sub&amp;lt;Duration&amp;gt;&lt;/code&gt; , который разрешает операции формы &lt;code&gt;SystemTime = SystemTime - Duration&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5d4b833ed91bb546ce7e87843871f8e854946fd3" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;T&lt;/code&gt; does not necessarily implement &lt;a href=&quot;../clone/trait.clone&quot;&gt;&lt;code&gt;Clone&lt;/code&gt;&lt;/a&gt;, so it can't even clone and reset &lt;code&gt;self.buf&lt;/code&gt;. But &lt;code&gt;replace&lt;/code&gt; can be used to disassociate the original value of &lt;code&gt;self.buf&lt;/code&gt; from &lt;code&gt;self&lt;/code&gt;, allowing it to be returned:</source>
          <target state="translated">Обратите внимание, что &lt;code&gt;T&lt;/code&gt; не обязательно реализует &lt;a href=&quot;../clone/trait.clone&quot;&gt; &lt;code&gt;Clone&lt;/code&gt; &lt;/a&gt; , поэтому он не может даже клонировать и сбрасывать &lt;code&gt;self.buf&lt;/code&gt; . Но &lt;code&gt;replace&lt;/code&gt; можно использовать, чтобы отделить исходное значение &lt;code&gt;self.buf&lt;/code&gt; от &lt;code&gt;self&lt;/code&gt; , позволяя вернуть его:</target>
        </trans-unit>
        <trans-unit id="ce9900f79b589dea762e357b371f9431cba99bba" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;T&lt;/code&gt; does not necessarily implement &lt;a href=&quot;../clone/trait.clone&quot;&gt;&lt;code&gt;Clone&lt;/code&gt;&lt;/a&gt;, so it can't even clone and reset &lt;code&gt;self.buf&lt;/code&gt;. But &lt;code&gt;take&lt;/code&gt; can be used to disassociate the original value of &lt;code&gt;self.buf&lt;/code&gt; from &lt;code&gt;self&lt;/code&gt;, allowing it to be returned:</source>
          <target state="translated">Обратите внимание, что &lt;code&gt;T&lt;/code&gt; не обязательно реализует &lt;a href=&quot;../clone/trait.clone&quot;&gt; &lt;code&gt;Clone&lt;/code&gt; &lt;/a&gt; , поэтому он не может даже клонировать и сбрасывать &lt;code&gt;self.buf&lt;/code&gt; . Но &lt;code&gt;take&lt;/code&gt; можно использовать, чтобы отделить исходное значение &lt;code&gt;self.buf&lt;/code&gt; от &lt;code&gt;self&lt;/code&gt; , позволяя вернуть его:</target>
        </trans-unit>
        <trans-unit id="ac00b6421a53f1cb355d37f763df7d0ab6908815" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;T&lt;/code&gt; does not necessarily implement &lt;a href=&quot;../clone/trait.clone&quot;&gt;&lt;code&gt;Clone&lt;/code&gt;&lt;/a&gt;, so we can't even clone &lt;code&gt;self.buf[i]&lt;/code&gt; to avoid the move. But &lt;code&gt;replace&lt;/code&gt; can be used to disassociate the original value at that index from &lt;code&gt;self&lt;/code&gt;, allowing it to be returned:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a23e62c56ad5b9bcbd4370446379ba67e37df78f" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;[expr; 0]&lt;/code&gt; is allowed, and produces an empty array. This will still evaluate &lt;code&gt;expr&lt;/code&gt;, however, and immediately drop the resulting value, so be mindful of side effects.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a7210db58c23cf5014deeb9448717499ab480d12" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;a &amp;lt;= b&lt;/code&gt; does &lt;em&gt;not&lt;/em&gt; imply &lt;code&gt;steps_between(&amp;amp;a, &amp;amp;b) != None&lt;/code&gt;; this is the case when it would require more than &lt;code&gt;usize::MAX&lt;/code&gt; steps to get to &lt;code&gt;b&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d217a13df9cefce26828e70c341f97e6fe273cac" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;drain_filter&lt;/code&gt; also lets you mutate every element in the filter closure, regardless of whether you choose to keep or remove it.</source>
          <target state="translated">Обратите внимание, что &lt;code&gt;drain_filter&lt;/code&gt; также позволяет вам изменять каждый элемент в закрытии фильтра, независимо от того, хотите ли вы оставить его или удалить.</target>
        </trans-unit>
        <trans-unit id="98dacb5f160d6bac2dc7474d61b47f1366bd10c0" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;drain_filter&lt;/code&gt; lets you mutate every element in the filter closure, regardless of whether you choose to keep or remove it.</source>
          <target state="translated">Обратите внимание, что &lt;code&gt;drain_filter&lt;/code&gt; позволяет вам изменять каждый элемент в закрытии фильтра, независимо от того, хотите ли вы оставить его или удалить.</target>
        </trans-unit>
        <trans-unit id="5c2297eec650eb177080c75bea870e375a760bc0" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;drain_filter&lt;/code&gt; lets you mutate every value in the filter closure, regardless of whether you choose to keep or remove it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="900305edc91345ae356f030caba1b6142733f009" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;iter.filter(f).next()&lt;/code&gt; is equivalent to &lt;code&gt;iter.find(f)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b7d482051dadae6146f69f3e213d64c34dd92558" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;iter.find(f)&lt;/code&gt; is equivalent to &lt;code&gt;iter.filter(f).next()&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3a3d7e41ea7c72a3b5b7e84cc631a89a603d2cd0" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;ptr::drop_in_place&lt;/code&gt; already performs this check, so if your workload can be reduced to some small number of drop_in_place calls, using this is unnecessary. In particular note that you can drop_in_place a slice, and that will do a single needs_drop check for all the values.</source>
          <target state="translated">Обратите внимание, что &lt;code&gt;ptr::drop_in_place&lt;/code&gt; уже выполняет эту проверку, поэтому, если ваша рабочая нагрузка может быть уменьшена до небольшого количества вызовов drop_in_place, в этом нет необходимости. В частности, обратите внимание, что вы можете drop_in_place срез, и это выполнит единственную проверку needs_drop для всех значений.</target>
        </trans-unit>
        <trans-unit id="437bc8fdeeb2ba2175b3e963d9a28d86c8a4a21f" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;query&lt;/code&gt; is now a &lt;code&gt;String&lt;/code&gt; rather than a string slice, because calling &lt;code&gt;to_lowercase&lt;/code&gt; creates new data rather than referencing existing data. Say the query is &lt;code&gt;&quot;rUsT&quot;&lt;/code&gt;, as an example: that string slice doesn&amp;rsquo;t contain a lowercase &lt;code&gt;u&lt;/code&gt; or &lt;code&gt;t&lt;/code&gt; for us to use, so we have to allocate a new &lt;code&gt;String&lt;/code&gt; containing &lt;code&gt;&quot;rust&quot;&lt;/code&gt;. When we pass &lt;code&gt;query&lt;/code&gt; as an argument to the &lt;code&gt;contains&lt;/code&gt; method now, we need to add an ampersand because the signature of &lt;code&gt;contains&lt;/code&gt; is defined to take a string slice.</source>
          <target state="translated">Обратите внимание, что &lt;code&gt;query&lt;/code&gt; теперь представляет собой &lt;code&gt;String&lt;/code&gt; а не фрагмент строки, потому что вызов &lt;code&gt;to_lowercase&lt;/code&gt; создает новые данные, а не ссылается на существующие данные. Скажем, запрос - это &lt;code&gt;&quot;rUsT&quot;&lt;/code&gt; , в качестве примера: этот строковый фрагмент не содержит строчные буквы &lt;code&gt;u&lt;/code&gt; или &lt;code&gt;t&lt;/code&gt; ,которые мы могли бы использовать, поэтому мы должны выделить новую &lt;code&gt;String&lt;/code&gt; содержащую &lt;code&gt;&quot;rust&quot;&lt;/code&gt; . Теперь, когда мы передаем &lt;code&gt;query&lt;/code&gt; в качестве аргумента методу &lt;code&gt;contains&lt;/code&gt; , нам нужно добавить амперсанд, потому что подпись &lt;code&gt;contains&lt;/code&gt; определена для получения фрагмента строки.</target>
        </trans-unit>
        <trans-unit id="d0952252c7abd133f9767b9cae9e5576b814cc56" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;std::env::args&lt;/code&gt; will panic if any argument contains invalid Unicode. If your program needs to accept arguments containing invalid Unicode, use &lt;code&gt;std::env::args_os&lt;/code&gt; instead. That function returns an iterator that produces &lt;code&gt;OsString&lt;/code&gt; values instead of &lt;code&gt;String&lt;/code&gt; values. We&amp;rsquo;ve chosen to use &lt;code&gt;std::env::args&lt;/code&gt; here for simplicity, because &lt;code&gt;OsString&lt;/code&gt; values differ per platform and are more complex to work with than &lt;code&gt;String&lt;/code&gt; values.</source>
          <target state="translated">Обратите внимание, что &lt;code&gt;std::env::args&lt;/code&gt; вызовет панику, если какой-либо аргумент содержит недопустимый Unicode. Если ваша программа должна принимать аргументы, содержащие недопустимый Unicode, используйте вместо этого &lt;code&gt;std::env::args_os&lt;/code&gt; . Эта функция возвращает итератор, который производит значения &lt;code&gt;OsString&lt;/code&gt; вместо значений &lt;code&gt;String&lt;/code&gt; . Мы решили использовать здесь &lt;code&gt;std::env::args&lt;/code&gt; для простоты, потому &lt;code&gt;OsString&lt;/code&gt; значения OsString различаются для разных платформ и с ними сложнее работать, чем со значениями &lt;code&gt;String&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="46299fa0ac2a6d6905de493039f518d4e56af3e6" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;zip&lt;/code&gt; produces only four pairs; the theoretical fifth pair &lt;code&gt;(5, None)&lt;/code&gt; is never produced because &lt;code&gt;zip&lt;/code&gt; returns &lt;code&gt;None&lt;/code&gt; when either of its input iterators return &lt;code&gt;None&lt;/code&gt;.</source>
          <target state="translated">Обратите внимание, что на &lt;code&gt;zip&lt;/code&gt; получается всего четыре пары; теоретическая пятая пара &lt;code&gt;(5, None)&lt;/code&gt; никогда не создается, потому что &lt;code&gt;zip&lt;/code&gt; возвращает &lt;code&gt;None&lt;/code&gt; , когда любой из его итераторов ввода возвращает &lt;code&gt;None&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="df23fedf4cb715b65ef5d705d642f0cedf378647" translate="yes" xml:space="preserve">
          <source>Note that Rust does not have a notion of optional function arguments or variadic functions (except for its C-FFI).</source>
          <target state="translated">Обратите внимание,что в Rust нет понятия необязательных аргументов функций или вариадических функций (за исключением его C-FFI).</target>
        </trans-unit>
        <trans-unit id="9dba02396ec6e8b7b0a98dc4c9d2e9628008b426" translate="yes" xml:space="preserve">
          <source>Note that a &quot;best effort&quot; is made to ensure that destructors for types stored in thread local storage are run, but not all platforms can guarantee that destructors will be run for all types in thread local storage. For example, there are a number of known caveats where destructors are not run:</source>
          <target state="translated">Обратите внимание,что &quot;прилагаются все усилия&quot;,чтобы деструкторы для типов,хранящихся в потоковом локальном хранилище,были запущены,но не все платформы могут гарантировать,что деструкторы будут запущены для всех типов в потоковом локальном хранилище.Например,известен ряд предостережений,в которых деструкторы не запускаются:</target>
        </trans-unit>
        <trans-unit id="aa61dce391cdbcb5b806d9a3fb49147f0dba491d" translate="yes" xml:space="preserve">
          <source>Note that a &lt;code&gt;()&lt;/code&gt;-returning &lt;code&gt;main&lt;/code&gt; implicitly results in a successful termination, so there's no need to return this from &lt;code&gt;main&lt;/code&gt; unless you're also returning other possible codes.</source>
          <target state="translated">Обратите внимание, что &lt;code&gt;()&lt;/code&gt; -возврат из &lt;code&gt;main&lt;/code&gt; неявно приводит к успешному завершению, поэтому нет необходимости возвращать это из &lt;code&gt;main&lt;/code&gt; , если вы также не возвращаете другие возможные коды.</target>
        </trans-unit>
        <trans-unit id="8c3f037daacb11aa4c63650c08cd568774329dcc" translate="yes" xml:space="preserve">
          <source>Note that a capture will either move or borrow a variable, but in this situation, the closure is borrowing the variable. Take a look at http://rustbyexample.com/fn/closures/capture.html for more information about capturing.</source>
          <target state="translated">Обратите внимание,что захват либо передвигает,либо заимствует переменную,но в этой ситуации закрытие заимствует переменную.Дополнительную информацию о захвате можно найти на сайте http://rustbyexample.com/fn/closures/capture.html.</target>
        </trans-unit>
        <trans-unit id="d28236ceeda3d941466d94520f9be31d9496ffc8" translate="yes" xml:space="preserve">
          <source>Note that a capture will either move or borrow a variable, but in this situation, the closure is borrowing the variable. Take a look at the chapter on &lt;a href=&quot;https://doc.rust-lang.org/stable/rust-by-example/fn/closures/capture.html&quot;&gt;Capturing&lt;/a&gt; in Rust By Example for more information.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b647009da3543b51ed32c9ce05f0008653d4bcc6" translate="yes" xml:space="preserve">
          <source>Note that a matcher is merely a token tree. A &quot;simple NT&quot;, as mentioned above, is an meta-variable NT; thus it is a non-repetition. For example, &lt;code&gt;$foo:ty&lt;/code&gt; is a simple NT but &lt;code&gt;$($foo:ty)+&lt;/code&gt; is a complex NT.</source>
          <target state="translated">Обратите внимание, что сопоставитель - это просто дерево токенов. &amp;laquo;Простая NT&amp;raquo;, как упоминалось выше, является NT метапеременной; таким образом, это неповторение. Например, &lt;code&gt;$foo:ty&lt;/code&gt; - это простая NT, а &lt;code&gt;$($foo:ty)+&lt;/code&gt; - сложная NT.</target>
        </trans-unit>
        <trans-unit id="166c645f512c5060e3e63517e9e2f60db5770e99" translate="yes" xml:space="preserve">
          <source>Note that a reference&amp;rsquo;s scope starts from where it is introduced and continues through the last time that reference is used. For instance, this code will compile because the last usage of the immutable references occurs before the mutable reference is introduced:</source>
          <target state="translated">Обратите внимание, что область действия ссылки начинается с того места, где она была введена, и продолжается до последнего использования этой ссылки. Например, этот код будет компилироваться, потому что последнее использование неизменяемых ссылок происходит до введения изменяемой ссылки:</target>
        </trans-unit>
        <trans-unit id="f3f4807c52376e81ba95b7f4b622c918a83cf1d4" translate="yes" xml:space="preserve">
          <source>Note that a successful send does &lt;em&gt;not&lt;/em&gt; guarantee that the receiver will ever see the data if there is a buffer on this channel. Items may be enqueued in the internal buffer for the receiver to receive at a later time. If the buffer size is 0, however, the channel becomes a rendezvous channel and it guarantees that the receiver has indeed received the data if this function returns success.</source>
          <target state="translated">Обратите внимание, что успешная отправка &lt;em&gt;не&lt;/em&gt; гарантирует, что получатель когда-либо увидит данные, если на этом канале есть буфер. Элементы могут быть помещены в очередь во внутреннем буфере, чтобы получатель мог получить их позже. Однако, если размер буфера равен 0, канал становится каналом рандеву и гарантирует, что получатель действительно получил данные, если эта функция возвращает успех.</target>
        </trans-unit>
        <trans-unit id="1f0335bd5206c4df046874965f0d18fc2183ed51" translate="yes" xml:space="preserve">
          <source>Note that accessing the value inside a &lt;code&gt;ManuallyDrop&amp;lt;T&amp;gt;&lt;/code&gt; is safe. This means that a &lt;code&gt;ManuallyDrop&amp;lt;T&amp;gt;&lt;/code&gt; whose content has been dropped must not be exposed through a public safe API. Correspondingly, &lt;code&gt;ManuallyDrop::drop&lt;/code&gt; is unsafe.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5885b8aa2d181f8795166dedd7f6344e9a60f6b3" translate="yes" xml:space="preserve">
          <source>Note that alignment may not be implemented by some types. In particular, it is not generally implemented for the &lt;code&gt;Debug&lt;/code&gt; trait. A good way to ensure padding is applied is to format your input, then pad this resulting string to obtain your output:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e3a19fce9bb891c546eeeb563b1b7a91ed25675f" translate="yes" xml:space="preserve">
          <source>Note that alignment may not be implemented by some types. In particular, it is not generally implemented for the &lt;code&gt;Debug&lt;/code&gt; trait. A good way to ensure padding is applied is to format your input, then use this resulting string to pad your output.</source>
          <target state="translated">Обратите внимание, что некоторые типы могут не выполнять выравнивание. В частности, это обычно не реализуется для трейта &lt;code&gt;Debug&lt;/code&gt; . Хороший способ обеспечить применение отступов - отформатировать ввод, а затем использовать полученную строку для дополнения вывода.</target>
        </trans-unit>
        <trans-unit id="76db1b0ab7636a80673dac1a141ed05d052cb403" translate="yes" xml:space="preserve">
          <source>Note that all &lt;a href=&quot;../primitive.char&quot;&gt;&lt;code&gt;char&lt;/code&gt;&lt;/a&gt;s are valid &lt;a href=&quot;../primitive.u32&quot;&gt;&lt;code&gt;u32&lt;/code&gt;&lt;/a&gt;s, and can be cast to one with &lt;code&gt;as&lt;/code&gt;:</source>
          <target state="translated">Обратите внимание , что все &lt;a href=&quot;../primitive.char&quot;&gt; &lt;code&gt;char&lt;/code&gt; &lt;/a&gt; s действительны &lt;a href=&quot;../primitive.u32&quot;&gt; &lt;code&gt;u32&lt;/code&gt; &lt;/a&gt; s, и могут быть приведены к одному с , &lt;code&gt;as&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="516c2ce158a14ccb1ab369bf0a62cbade5443e81" translate="yes" xml:space="preserve">
          <source>Note that all &lt;code&gt;char&lt;/code&gt;s are valid &lt;a href=&quot;primitive.u32&quot;&gt;&lt;code&gt;u32&lt;/code&gt;&lt;/a&gt;s, and can be cast to one with &lt;code&gt;as&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f0494b2e843f4a073b41bb1890333a63fc3eaceb" translate="yes" xml:space="preserve">
          <source>Note that all elements between the end and the returned element will be consumed, including the returned element. This also means that calling &lt;code&gt;nth_back(0)&lt;/code&gt; multiple times on the same iterator will return different elements.</source>
          <target state="translated">Обратите внимание, что все элементы между концом и возвращенным элементом будут использованы, включая возвращенный элемент. Это также означает, что вызов &lt;code&gt;nth_back(0)&lt;/code&gt; несколько раз на одном и том же итераторе вернет разные элементы.</target>
        </trans-unit>
        <trans-unit id="50ea5f0e3ab7dc58cad2b538ddb240e9c4984ee9" translate="yes" xml:space="preserve">
          <source>Note that all preceding elements, as well as the returned element, will be consumed from the iterator. That means that the preceding elements will be discarded, and also that calling &lt;code&gt;nth(0)&lt;/code&gt; multiple times on the same iterator will return different elements.</source>
          <target state="translated">Обратите внимание, что все предыдущие элементы, а также возвращаемый элемент будут использованы итератором. Это означает, что предыдущие элементы будут отброшены, а также что многократный вызов &lt;code&gt;nth(0)&lt;/code&gt; на одном и том же итераторе вернет разные элементы.</target>
        </trans-unit>
        <trans-unit id="491da8d1616c74f297c93c3f76ed9c42830ffa59" translate="yes" xml:space="preserve">
          <source>Note that any code in earlier iterations of &lt;em&gt;The Rust Programming Language&lt;/em&gt; that compiled will continue to compile without &lt;code&gt;edition=&quot;2018&quot;&lt;/code&gt; in the project&amp;rsquo;s &lt;em&gt;Cargo.toml&lt;/em&gt;, even as you update the Rust compiler version you&amp;rsquo;re using. That&amp;rsquo;s Rust&amp;rsquo;s backward compatibility guarantees at work!</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8557ae8a9f894db68722639fc1170d53ad338fd1" translate="yes" xml:space="preserve">
          <source>Note that any code in the first printing of &lt;em&gt;The Rust Programming Language&lt;/em&gt; that compiled will continue to compile without &lt;code&gt;edition=&quot;2018&quot;&lt;/code&gt; in the project&amp;rsquo;s &lt;em&gt;Cargo.toml&lt;/em&gt;, even as you update the Rust compiler version you&amp;rsquo;re using. That&amp;rsquo;s Rust&amp;rsquo;s backward compatibility guarantees at work!</source>
          <target state="translated">Обратите внимание, что любой скомпилированный код в первом &lt;code&gt;edition=&quot;2018&quot;&lt;/code&gt; &lt;em&gt;языка программирования Rust&lt;/em&gt; будет продолжать компилироваться без edition = &quot;2018&quot; в &lt;em&gt;Cargo.toml&lt;/em&gt; проекта , даже если вы обновите версию компилятора Rust, которую используете. Это гарантии обратной совместимости Rust в действии!</target>
        </trans-unit>
        <trans-unit id="816a2f31fb1f17b4e41f02fda3eaa37e852b4d6e" translate="yes" xml:space="preserve">
          <source>Note that any leftover data in the internal buffer is lost.</source>
          <target state="translated">Обратите внимание,что все оставшиеся данные во внутреннем буфере теряются.</target>
        </trans-unit>
        <trans-unit id="2a041883f7bee5eb6e6f55708c727c8ab3a3ed00" translate="yes" xml:space="preserve">
          <source>Note that any leftover data in the internal buffer is lost. Therefore, a following read from the underlying reader may lead to data loss.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="45719b2fc23ab9d812a1864bec0c46011337290e" translate="yes" xml:space="preserve">
          <source>Note that because this function never returns, and that it terminates the process, no destructors on the current stack or any other thread's stack will be run.</source>
          <target state="translated">Обратите внимание,что из-за того,что эта функция никогда не возвращается,а также из-за того,что она завершает процесс,ни деструкторы на текущем стеке,ни любой другой стек потока не будут запущены.</target>
        </trans-unit>
        <trans-unit id="8ee637b0f22097f2447433c9e30b0952e702b8b7" translate="yes" xml:space="preserve">
          <source>Note that because this function never returns, and that it terminates the process, no destructors on the current stack or any other thread's stack will be run. If a clean shutdown is needed it is recommended to only call this function at a known point where there are no more destructors left to run.</source>
          <target state="translated">Обратите внимание,что из-за того,что эта функция никогда не возвращается,а также из-за того,что она завершает процесс,ни деструкторы на текущем стеке,ни любой другой стек потока не будут запущены.Если требуется чистое выключение,рекомендуется вызывать эту функцию только в известной точке,где больше не осталось деструкторов для выполнения.</target>
        </trans-unit>
        <trans-unit id="25d3aa7c2b95febeff16d7f5e6ce36387044d531" translate="yes" xml:space="preserve">
          <source>Note that because we defined the &lt;code&gt;Summary&lt;/code&gt; trait and the &lt;code&gt;NewsArticle&lt;/code&gt; and &lt;code&gt;Tweet&lt;/code&gt; types in the same &lt;em&gt;lib.rs&lt;/em&gt; in Listing 10-13, they&amp;rsquo;re all in the same scope. Let&amp;rsquo;s say this &lt;em&gt;lib.rs&lt;/em&gt; is for a crate we&amp;rsquo;ve called &lt;code&gt;aggregator&lt;/code&gt; and someone else wants to use our crate&amp;rsquo;s functionality to implement the &lt;code&gt;Summary&lt;/code&gt; trait on a struct defined within their library&amp;rsquo;s scope. They would need to bring the trait into their scope first. They would do so by specifying &lt;code&gt;use aggregator::Summary;&lt;/code&gt;, which then would enable them to implement &lt;code&gt;Summary&lt;/code&gt; for their type. The &lt;code&gt;Summary&lt;/code&gt; trait would also need to be a public trait for another crate to implement it, which it is because we put the &lt;code&gt;pub&lt;/code&gt; keyword before &lt;code&gt;trait&lt;/code&gt; in Listing 10-12.</source>
          <target state="translated">Заметим , что , поскольку мы определили &lt;code&gt;Summary&lt;/code&gt; черту и &lt;code&gt;NewsArticle&lt;/code&gt; и &lt;code&gt;Tweet&lt;/code&gt; типы в одних и тех же &lt;em&gt;lib.rs&lt;/em&gt; в листинге 10-13, все они в той же области. Допустим, этот &lt;em&gt;lib.rs&lt;/em&gt; предназначен для ящика, который мы назвали &lt;code&gt;aggregator&lt;/code&gt; и кто-то еще хочет использовать функциональность нашего ящика для реализации трейта &lt;code&gt;Summary&lt;/code&gt; в структуре, определенной в пределах их библиотеки. Им нужно будет сначала включить эту черту в свою область видимости. Они сделали бы это, указав &lt;code&gt;use aggregator::Summary;&lt;/code&gt; , что затем позволит им реализовать &lt;code&gt;Summary&lt;/code&gt; для своего типа. &lt;code&gt;Summary&lt;/code&gt; trait также должен быть общедоступным для другого ящика, чтобы реализовать его, потому что мы поместили ключевое слово &lt;code&gt;pub&lt;/code&gt; перед &lt;code&gt;trait&lt;/code&gt; в листинге 10-12.</target>
        </trans-unit>
        <trans-unit id="5c2746c98858012c4f3f702901d1b8fef09f722f" translate="yes" xml:space="preserve">
          <source>Note that because we&amp;rsquo;ve used only one generic type to define &lt;code&gt;Point&amp;lt;T&amp;gt;&lt;/code&gt;, this definition says that the &lt;code&gt;Point&amp;lt;T&amp;gt;&lt;/code&gt; struct is generic over some type &lt;code&gt;T&lt;/code&gt;, and the fields &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; are &lt;em&gt;both&lt;/em&gt; that same type, whatever that type may be. If we create an instance of a &lt;code&gt;Point&amp;lt;T&amp;gt;&lt;/code&gt; that has values of different types, as in Listing 10-7, our code won&amp;rsquo;t compile.</source>
          <target state="translated">Обратите внимание: поскольку мы использовали только один универсальный тип для определения &lt;code&gt;Point&amp;lt;T&amp;gt;&lt;/code&gt; , это определение говорит, что структура &lt;code&gt;Point&amp;lt;T&amp;gt;&lt;/code&gt; является универсальной для некоторого типа &lt;code&gt;T&lt;/code&gt; , а поля &lt;code&gt;x&lt;/code&gt; и &lt;code&gt;y&lt;/code&gt; имеют один &lt;em&gt;и&lt;/em&gt; тот же тип, независимо от этого типа. может быть. Если мы создадим экземпляр &lt;code&gt;Point&amp;lt;T&amp;gt;&lt;/code&gt; который имеет значения разных типов, как в листинге 10-7, наш код не будет компилироваться.</target>
        </trans-unit>
        <trans-unit id="ee83d2a98a726eb4d0819a08ff35a51d203bcc33" translate="yes" xml:space="preserve">
          <source>Note that capturing a backtrace can be an expensive operation on some platforms, so this should be used with caution in performance-sensitive parts of code.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8b44ef6f5d455a7524a366399e247106ccce266f" translate="yes" xml:space="preserve">
          <source>Note that dropping a &lt;code&gt;MaybeUninit&amp;lt;T&amp;gt;&lt;/code&gt; will never call &lt;code&gt;T&lt;/code&gt;'s drop code. It is your responsibility to make sure &lt;code&gt;T&lt;/code&gt; gets dropped if it got initialized.</source>
          <target state="translated">Обратите внимание, что удаление &lt;code&gt;MaybeUninit&amp;lt;T&amp;gt;&lt;/code&gt; никогда не вызовет код отбрасывания &lt;code&gt;T&lt;/code&gt; .Вы несете ответственность за то, чтобы &lt;code&gt;T&lt;/code&gt; был сброшен, если он был инициализирован.</target>
        </trans-unit>
        <trans-unit id="1ca6aa2552d35e463ab42d6ea3dc8e136eb4776f" translate="yes" xml:space="preserve">
          <source>Note that due to method call deref coercion, simply calling a trait method will act like they work on references as well as they do on owned values! The implementations described here are meant for generic contexts, where the final type &lt;code&gt;T&lt;/code&gt; is a type parameter or otherwise not locally known.</source>
          <target state="translated">Обратите внимание, что из-за принуждения deref вызова метода простой вызов метода черты будет действовать так, как будто они работают со ссылками так же, как и с собственными значениями! Описанные здесь реализации предназначены для общих контекстов, где последний тип &lt;code&gt;T&lt;/code&gt; является параметром типа или иным образом не известен локально.</target>
        </trans-unit>
        <trans-unit id="1de74eaeec2a2aa72b741e1bb4ba4ee5991fbccf" translate="yes" xml:space="preserve">
          <source>Note that empty arrays &lt;code&gt;[T; 0]&lt;/code&gt; have the same alignment requirement as the element type &lt;code&gt;T&lt;/code&gt;. Also note that the error is conservatively reported even when the alignment of the zero-sized type is less than or equal to the data field's alignment.</source>
          <target state="translated">Обратите внимание, что пустые массивы &lt;code&gt;[T; 0]&lt;/code&gt; имеют то же требование выравнивания в качестве типа элемента &lt;code&gt;T&lt;/code&gt; . Также обратите внимание, что об ошибке сообщается консервативно, даже если выравнивание типа нулевого размера меньше или равно выравниванию поля данных.</target>
        </trans-unit>
        <trans-unit id="03aca4023a1e7014a85e0b59db326c1054412c53" translate="yes" xml:space="preserve">
          <source>Note that environment variable names are case-insensitive (but case-preserving) on Windows, and case-sensitive on all other platforms.</source>
          <target state="translated">Обратите внимание,что имена переменных окружения не чувствительны к регистру (но сохраняют регистр)на Windows,и чувствительны к регистру на всех других платформах.</target>
        </trans-unit>
        <trans-unit id="af3176ad62da7d96f31254f9c337151434d91850" translate="yes" xml:space="preserve">
          <source>Note that even if &lt;code&gt;T&lt;/code&gt; has size &lt;code&gt;0&lt;/code&gt;, the pointer must be non-NULL and properly aligned.</source>
          <target state="translated">Обратите внимание, что даже если &lt;code&gt;T&lt;/code&gt; имеет размер &lt;code&gt;0&lt;/code&gt; , указатель не должен быть NULL и правильно выровнен.</target>
        </trans-unit>
        <trans-unit id="58d2d77f2d5d331bda29fe5d0af29fd62177b001" translate="yes" xml:space="preserve">
          <source>Note that even if &lt;code&gt;T&lt;/code&gt; has size &lt;code&gt;0&lt;/code&gt;, the pointer must be non-NULL.</source>
          <target state="translated">Обратите внимание, что даже если &lt;code&gt;T&lt;/code&gt; имеет размер &lt;code&gt;0&lt;/code&gt; , указатель не должен быть NULL.</target>
        </trans-unit>
        <trans-unit id="aca2272e34501c47a8d86a387930c81a45160055" translate="yes" xml:space="preserve">
          <source>Note that even if &lt;code&gt;T&lt;/code&gt; has size &lt;code&gt;0&lt;/code&gt;, the pointers must be non-NULL and properly aligned.</source>
          <target state="translated">Обратите внимание, что даже если &lt;code&gt;T&lt;/code&gt; имеет размер &lt;code&gt;0&lt;/code&gt; , указатели не должны быть NULL и правильно выровнены.</target>
        </trans-unit>
        <trans-unit id="9806a4590799343d8c64ae41117a4958b8386ffa" translate="yes" xml:space="preserve">
          <source>Note that even if the effectively copied size (&lt;code&gt;count * size_of::&amp;lt;T&amp;gt;()&lt;/code&gt;) is &lt;code&gt;0&lt;/code&gt;, the pointer must be non-NULL and properly aligned.</source>
          <target state="translated">Обратите внимание, что даже если эффективно скопированный размер ( &lt;code&gt;count * size_of::&amp;lt;T&amp;gt;()&lt;/code&gt; ) равен &lt;code&gt;0&lt;/code&gt; , указатель должен быть не NULL и правильно выровнен.</target>
        </trans-unit>
        <trans-unit id="851cd0d9eb90b03ed21845664c6d4ace9ece4acd" translate="yes" xml:space="preserve">
          <source>Note that even if the effectively copied size (&lt;code&gt;count * size_of::&amp;lt;T&amp;gt;()&lt;/code&gt;) is &lt;code&gt;0&lt;/code&gt;, the pointers must be non-NULL and properly aligned.</source>
          <target state="translated">Обратите внимание, что даже если эффективно скопированный размер ( &lt;code&gt;count * size_of::&amp;lt;T&amp;gt;()&lt;/code&gt; ) равен &lt;code&gt;0&lt;/code&gt; , указатели не должны быть NULL и правильно выровнены.</target>
        </trans-unit>
        <trans-unit id="6c1ad3562574888b0c8c8e999ed33eff7030ffcd" translate="yes" xml:space="preserve">
          <source>Note that even if this panics, the value is considered to be dropped; you must not cause &lt;code&gt;drop&lt;/code&gt; to be called again. This is normally automatically handled by the compiler, but when using unsafe code, can sometimes occur unintentionally, particularly when using &lt;a href=&quot;../ptr/fn.drop_in_place&quot;&gt;&lt;code&gt;ptr::drop_in_place&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e70094585dad750582f0b20dfaa8a3722d32400a" translate="yes" xml:space="preserve">
          <source>Note that even though the standard library contains a definition for &lt;code&gt;IpAddr&lt;/code&gt;, we can still create and use our own definition without conflict because we haven&amp;rsquo;t brought the standard library&amp;rsquo;s definition into our scope. We&amp;rsquo;ll talk more about bringing types into scope in Chapter 7.</source>
          <target state="translated">Обратите внимание, что даже несмотря на то, что стандартная библиотека содержит определение для &lt;code&gt;IpAddr&lt;/code&gt; , мы все равно можем создавать и использовать собственное определение без конфликтов, поскольку мы не добавили определение стандартной библиотеки в нашу область видимости. Подробнее о включении типов в область видимости мы поговорим в главе 7.</target>
        </trans-unit>
        <trans-unit id="31c2c0947f08a70cf66a5f5539b0e2dc387b144b" translate="yes" xml:space="preserve">
          <source>Note that future platforms may be added that also do not have support for some atomic operations. Maximally portable code will want to be careful about which atomic types are used. &lt;code&gt;AtomicUsize&lt;/code&gt; and &lt;code&gt;AtomicIsize&lt;/code&gt; are generally the most portable, but even then they're not available everywhere. For reference, the &lt;code&gt;std&lt;/code&gt; library requires pointer-sized atomics, although &lt;code&gt;core&lt;/code&gt; does not.</source>
          <target state="translated">Обратите внимание, что в будущем могут быть добавлены платформы, которые также не поддерживают некоторые атомарные операции. Максимально переносимый код должен быть осторожен с тем, какие атомарные типы используются. &lt;code&gt;AtomicUsize&lt;/code&gt; и &lt;code&gt;AtomicIsize&lt;/code&gt; , как правило, наиболее переносимы, но даже тогда они доступны не везде. Для справки: библиотека &lt;code&gt;std&lt;/code&gt; требует атомики размером с указатель, а &lt;code&gt;core&lt;/code&gt; - нет.</target>
        </trans-unit>
        <trans-unit id="59fbfedac3227479331b23c365329ce5aabd1a1b" translate="yes" xml:space="preserve">
          <source>Note that generic arguments for enum variant constructors go after the variant, not after the enum. For example, you would write &lt;code&gt;Option::None::&amp;lt;u32&amp;gt;&lt;/code&gt;, rather than &lt;code&gt;Option::&amp;lt;u32&amp;gt;::None&lt;/code&gt;.</source>
          <target state="translated">Обратите внимание, что общие аргументы для конструкторов вариантов перечисления идут после варианта, а не после перечисления. Например, вы должны написать &lt;code&gt;Option::None::&amp;lt;u32&amp;gt;&lt;/code&gt; , а не &lt;code&gt;Option::&amp;lt;u32&amp;gt;::None&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b6e3284112fc89aa89918b12b076295886a2da9b" translate="yes" xml:space="preserve">
          <source>Note that here the call to &lt;a href=&quot;mem/fn.drop&quot;&gt;&lt;code&gt;drop&lt;/code&gt;&lt;/a&gt; is for clarity - it indicates that we are done with the given value and it should be destroyed.</source>
          <target state="translated">Обратите внимание, что здесь вызов &lt;a href=&quot;mem/fn.drop&quot;&gt; &lt;code&gt;drop&lt;/code&gt; &lt;/a&gt; сделан для ясности - он указывает, что мы закончили с заданным значением, и его следует уничтожить.</target>
        </trans-unit>
        <trans-unit id="0753b6373f6f1d65a2eb747fb24056dce4b9d211" translate="yes" xml:space="preserve">
          <source>Note that if &lt;code&gt;Self::Item&lt;/code&gt; is only &lt;code&gt;PartialOrd&lt;/code&gt;, but not &lt;code&gt;Ord&lt;/code&gt;, the above definition implies that this function returns &lt;code&gt;false&lt;/code&gt; if any two consecutive items are not comparable.</source>
          <target state="translated">Обратите внимание, что если &lt;code&gt;Self::Item&lt;/code&gt; имеет значение только &lt;code&gt;PartialOrd&lt;/code&gt; , но не &lt;code&gt;Ord&lt;/code&gt; , приведенное выше определение подразумевает, что эта функция возвращает &lt;code&gt;false&lt;/code&gt; , если любые два последовательных элемента не сопоставимы.</target>
        </trans-unit>
        <trans-unit id="b91bc8063fbfefef1d18b41e7b347e2c6fec2abd" translate="yes" xml:space="preserve">
          <source>Note that if &lt;code&gt;from&lt;/code&gt; and &lt;code&gt;to&lt;/code&gt; both point to the same file, then the file will likely get truncated by this operation.</source>
          <target state="translated">Обратите внимание: если &lt;code&gt;from&lt;/code&gt; и &lt;code&gt;to&lt;/code&gt; оба указывают на один и тот же файл, то файл, скорее всего, будет усечен этой операцией.</target>
        </trans-unit>
        <trans-unit id="9d3e37ab6666f6f897eee8b56db717458b005ac3" translate="yes" xml:space="preserve">
          <source>Note that if a function takes multiple type arguments but you want the compiler to infer some of them, you can use type placeholders:</source>
          <target state="translated">Обратите внимание,что если функция принимает несколько аргументов типа,но вы хотите,чтобы компилятор сделал вывод о некоторых из них,вы можете использовать плейсхолдеры типов:</target>
        </trans-unit>
        <trans-unit id="cd535d6f6d4b53f3c244d297f7914a6181acf961" translate="yes" xml:space="preserve">
          <source>Note that if the &lt;code&gt;static&lt;/code&gt; or &lt;code&gt;const&lt;/code&gt; items include function or closure references, which themselves include references, the compiler will first try the standard elision rules. If it is unable to resolve the lifetimes by its usual rules, then it will error. By way of example:</source>
          <target state="translated">Обратите внимание, что если &lt;code&gt;static&lt;/code&gt; или &lt;code&gt;const&lt;/code&gt; элементы включают ссылки на функции или замыкания, которые сами включают ссылки, компилятор сначала попробует стандартные правила исключения. Если он не может определить время жизни по обычным правилам, он выдаст ошибку. В качестве примера:</target>
        </trans-unit>
        <trans-unit id="9ef199153d75a42174c42cff6fb7c6c1476957fd" translate="yes" xml:space="preserve">
          <source>Note that implementations do not necessarily have to provide access to the inner-most source of a pipeline. A stateful intermediate adapter might eagerly evaluate a part of the pipeline and expose its internal storage as source.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c0702815af49297e37a4e0bb02d65562e392c8a7" translate="yes" xml:space="preserve">
          <source>Note that in Rust, structs can only contain an unsized type if the field containing the unsized type is the last and only unsized type field in the struct.</source>
          <target state="translated">Обратите внимание,что в Rust структуры могут содержать тип unsized только в том случае,если поле,содержащее тип unsized,является последним и единственным полем типа unsized в структуре.</target>
        </trans-unit>
        <trans-unit id="523c7fb2b8819c356a6b0490b2a0d8371495e11f" translate="yes" xml:space="preserve">
          <source>Note that in some languages and test frameworks, the parameters to the functions that assert two values are equal are called &lt;code&gt;expected&lt;/code&gt; and &lt;code&gt;actual&lt;/code&gt;, and the order in which we specify the arguments matters. However, in Rust, they&amp;rsquo;re called &lt;code&gt;left&lt;/code&gt; and &lt;code&gt;right&lt;/code&gt;, and the order in which we specify the value we expect and the value that the code under test produces doesn&amp;rsquo;t matter. We could write the assertion in this test as &lt;code&gt;assert_eq!(add_two(2), 4)&lt;/code&gt;, which would result in a failure message that displays &lt;code&gt;assertion failed: `(left == right)`&lt;/code&gt; and that &lt;code&gt;left&lt;/code&gt; was &lt;code&gt;5&lt;/code&gt; and &lt;code&gt;right&lt;/code&gt; was &lt;code&gt;4&lt;/code&gt;.</source>
          <target state="translated">Обратите внимание, что в некоторых языках и платформах тестирования параметры функций, которые утверждают, что два значения равны, называются &lt;code&gt;expected&lt;/code&gt; и &lt;code&gt;actual&lt;/code&gt; , и порядок, в котором мы указываем аргументы, имеет значение. Однако в Rust они называются &lt;code&gt;left&lt;/code&gt; и &lt;code&gt;right&lt;/code&gt; , и порядок, в котором мы указываем ожидаемое значение и значение, которое генерирует тестируемый код, не имеет значения. Мы могли бы записать утверждение в этом тесте как &lt;code&gt;assert_eq!(add_two(2), 4)&lt;/code&gt; , что приведет к сообщению об ошибке , отображающему &lt;code&gt;assertion failed: `(left == right)`&lt;/code&gt; , где &lt;code&gt;left&lt;/code&gt; было &lt;code&gt;5&lt;/code&gt; , а &lt;code&gt;right&lt;/code&gt; было &lt;code&gt;4&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="bd234e5e31b58a835a7427c6ccb9ea99860e96d4" translate="yes" xml:space="preserve">
          <source>Note that introducing another &lt;code&gt;struct&lt;/code&gt; just to have a place for the other attributes may have unintended side effects on the representation:</source>
          <target state="translated">Обратите внимание, что введение другой &lt;code&gt;struct&lt;/code&gt; только для того, чтобы иметь место для других атрибутов, может иметь непреднамеренные побочные эффекты на представление:</target>
        </trans-unit>
        <trans-unit id="6abfc6c98c1133dd19e39dfc110c77706058a67e" translate="yes" xml:space="preserve">
          <source>Note that it is impossible to link in native dynamic dependencies to a static library, and in this case warnings will be printed about all unlinked native dynamic dependencies.</source>
          <target state="translated">Обратите внимание,что в родных динамических зависимостях невозможно связать со статической библиотекой,и в этом случае будут выведены предупреждения обо всех несвязанных родных динамических зависимостях.</target>
        </trans-unit>
        <trans-unit id="213f52c82816211eed8a84af1c6306ce11d2042d" translate="yes" xml:space="preserve">
          <source>Note that it isn&amp;rsquo;t possible to call the default implementation from an overriding implementation of that same method.</source>
          <target state="translated">Обратите внимание, что невозможно вызвать реализацию по умолчанию из замещающей реализации того же метода.</target>
        </trans-unit>
        <trans-unit id="431dfb333d11627033bd73c3c12aac0f9ce02166" translate="yes" xml:space="preserve">
          <source>Note that length of a stream can change over time (for example, when data is appended to a file). So calling this method multiple times does not necessarily return the same length each time.</source>
          <target state="translated">Обратите внимание,что длина потока может меняться со временем (например,когда данные добавляются в файл).Поэтому многократный вызов этого метода не обязательно каждый раз возвращает одну и ту же длину.</target>
        </trans-unit>
        <trans-unit id="313ba1495decd5683c08865a1c2d8bbad489994a" translate="yes" xml:space="preserve">
          <source>Note that negating any positive integer will overflow.</source>
          <target state="translated">Обратите внимание,что при отрицании любого положительного целого переполнится.</target>
        </trans-unit>
        <trans-unit id="0310d257cad5180cd2a5706628685feb28fa8baa" translate="yes" xml:space="preserve">
          <source>Note that no other normalization takes place; in particular, &lt;code&gt;a/c&lt;/code&gt; and &lt;code&gt;a/b/../c&lt;/code&gt; are distinct, to account for the possibility that &lt;code&gt;b&lt;/code&gt; is a symbolic link (so its parent isn't &lt;code&gt;a&lt;/code&gt;).</source>
          <target state="translated">Обратите внимание, что никакой другой нормализации не происходит; в частности, &lt;code&gt;a/c&lt;/code&gt; и &lt;code&gt;a/b/../c&lt;/code&gt; различны, чтобы учесть возможность того, что &lt;code&gt;b&lt;/code&gt; является символической ссылкой (поэтому ее родительский &lt;code&gt;a&lt;/code&gt; не является a ).</target>
        </trans-unit>
        <trans-unit id="0f36d8aec30ccdcaddeba64d187fcf335e3e550e" translate="yes" xml:space="preserve">
          <source>Note that not all errors contain a &lt;code&gt;Backtrace&lt;/code&gt;. Also note that a &lt;code&gt;Backtrace&lt;/code&gt; may actually be empty. For more information consult the &lt;code&gt;Backtrace&lt;/code&gt; type itself.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6048f485eb4e07bdf2aa23e3dab346aa63dbf7f5" translate="yes" xml:space="preserve">
          <source>Note that not all platforms will keep this field update in a file's metadata, for example Windows has an option to disable updating this time when files are accessed and Linux similarly has &lt;code&gt;noatime&lt;/code&gt;.</source>
          <target state="translated">Обратите внимание , что не все платформы будут держать это обновление поля в метаданных файла, например , Windows , имеет возможность отключить обновления на этот раз , когда файлы доступны и Linux так же имеет &lt;code&gt;noatime&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d5ed45efedb5980a8a1a6af222c209c849963838" translate="yes" xml:space="preserve">
          <source>Note that nowhere in this output do we see &lt;code&gt;I got the value 4&lt;/code&gt;, which is what is printed when the test that passes runs. That output has been captured. The output from the test that failed, &lt;code&gt;I got the value 8&lt;/code&gt;, appears in the section of the test summary output, which also shows the cause of the test failure.</source>
          <target state="translated">Обратите внимание, что нигде в этом выводе мы не видим, что &lt;code&gt;I got the value 4&lt;/code&gt; , которое печатается при выполнении пройденного теста. Этот вывод был записан. Результат неудачного теста, &lt;code&gt;I got the value 8&lt;/code&gt; , появляется в разделе итоговых результатов теста, который также показывает причину неудачного теста.</target>
        </trans-unit>
        <trans-unit id="5a80c5201601b7cd22253cd99d33bff329ba0af9" translate="yes" xml:space="preserve">
          <source>Note that on multiple calls to &lt;code&gt;poll&lt;/code&gt;, only the &lt;a href=&quot;../task/struct.waker&quot;&gt;&lt;code&gt;Waker&lt;/code&gt;&lt;/a&gt; from the &lt;a href=&quot;../task/struct.context&quot;&gt;&lt;code&gt;Context&lt;/code&gt;&lt;/a&gt; passed to the most recent call should be scheduled to receive a wakeup.</source>
          <target state="translated">Обратите внимание, что при нескольких вызовах для &lt;code&gt;poll&lt;/code&gt; только &lt;a href=&quot;../task/struct.waker&quot;&gt; &lt;code&gt;Waker&lt;/code&gt; &lt;/a&gt; из &lt;a href=&quot;../task/struct.context&quot;&gt; &lt;code&gt;Context&lt;/code&gt; &lt;/a&gt; переданный последнему вызову, должен быть запланирован для получения пробуждения.</target>
        </trans-unit>
        <trans-unit id="55bd215fbbafcd54535dc669556609d05462d431" translate="yes" xml:space="preserve">
          <source>Note that one cannot pass &lt;code&gt;CannotReallocInPlace&lt;/code&gt; to the &lt;code&gt;handle_alloc_error&lt;/code&gt; function; clients are expected either to be able to recover from &lt;code&gt;grow_in_place&lt;/code&gt; failures without aborting, or to fall back on another reallocation method before resorting to an abort.</source>
          <target state="translated">Обратите внимание , что один не может пройти &lt;code&gt;CannotReallocInPlace&lt;/code&gt; к &lt;code&gt;handle_alloc_error&lt;/code&gt; функции; Ожидается, что клиенты либо смогут восстанавливаться &lt;code&gt;grow_in_place&lt;/code&gt; сбоев grow_in_place без прерывания, либо прибегнут к другому методу перераспределения, прежде чем прибегать к прерыванию.</target>
        </trans-unit>
        <trans-unit id="b9605ecaf6269fd2f9ec9b6cd8fec45c27c798c5" translate="yes" xml:space="preserve">
          <source>Note that one cannot pass &lt;code&gt;CannotReallocInPlace&lt;/code&gt; to the &lt;code&gt;handle_alloc_error&lt;/code&gt; function; clients are expected either to be able to recover from &lt;code&gt;shrink_in_place&lt;/code&gt; failures without aborting, or to fall back on another reallocation method before resorting to an abort.</source>
          <target state="translated">Обратите внимание , что один не может пройти &lt;code&gt;CannotReallocInPlace&lt;/code&gt; к &lt;code&gt;handle_alloc_error&lt;/code&gt; функции; Ожидается, что клиенты смогут либо восстанавливаться &lt;code&gt;shrink_in_place&lt;/code&gt; сбоев shrink_in_place без прерывания, либо прибегнуть к другому методу перераспределения, прежде чем прибегать к прерыванию.</target>
        </trans-unit>
        <trans-unit id="b6bbee529e21d8d6f27eb0394a352b9a59dfbecb" translate="yes" xml:space="preserve">
          <source>Note that panics in Rust are not always implemented via unwinding, but they may be implemented by aborting the process. If this function is called when panics are implemented this way then this function will abort the process, not trigger an unwind.</source>
          <target state="translated">Обратите внимание,что паники в Rust не всегда реализуются через разматывание,но они могут быть реализованы путем прерывания процесса.Если эта функция вызывается при реализации паники таким образом,то она прерывает процесс,а не запускает размотку.</target>
        </trans-unit>
        <trans-unit id="5e3c061738b40532446b85ef7e5e80f755eaa54c" translate="yes" xml:space="preserve">
          <source>Note that parts of this block are in use:</source>
          <target state="translated">Обратите внимание,что части этого блока используются:</target>
        </trans-unit>
        <trans-unit id="fff05e35d755803ade4b50f50d29c987f0007787" translate="yes" xml:space="preserve">
          <source>Note that pinning and &lt;a href=&quot;../marker/trait.unpin&quot;&gt;&lt;code&gt;Unpin&lt;/code&gt;&lt;/a&gt; only affect the pointed-to type &lt;code&gt;P::Target&lt;/code&gt;, not the pointer type &lt;code&gt;P&lt;/code&gt; itself that got wrapped in &lt;a href=&quot;struct.pin&quot;&gt;&lt;code&gt;Pin&amp;lt;P&amp;gt;&lt;/code&gt;&lt;/a&gt;. For example, whether or not &lt;a href=&quot;../boxed/struct.box&quot;&gt;&lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt; is &lt;a href=&quot;../marker/trait.unpin&quot;&gt;&lt;code&gt;Unpin&lt;/code&gt;&lt;/a&gt; has no effect on the behavior of &lt;a href=&quot;struct.pin&quot;&gt;&lt;code&gt;Pin&lt;/code&gt;&lt;/a&gt;&lt;code&gt;&amp;lt;&lt;/code&gt;&lt;a href=&quot;../boxed/struct.box&quot;&gt;&lt;code&gt;Box&lt;/code&gt;&lt;/a&gt;&lt;code&gt;&amp;lt;T&amp;gt;&amp;gt;&lt;/code&gt; (here, &lt;code&gt;T&lt;/code&gt; is the pointed-to type).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8df6e9ecf182c2febaad6a991ebf5bacd1fab01f" translate="yes" xml:space="preserve">
          <source>Note that pinning and &lt;code&gt;Unpin&lt;/code&gt; only affect the pointed-to type &lt;code&gt;P::Target&lt;/code&gt;, not the pointer type &lt;code&gt;P&lt;/code&gt; itself that got wrapped in &lt;code&gt;Pin&amp;lt;P&amp;gt;&lt;/code&gt;. For example, whether or not &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; is &lt;code&gt;Unpin&lt;/code&gt; has no effect on the behavior of &lt;code&gt;Pin&amp;lt;Box&amp;lt;T&amp;gt;&amp;gt;&lt;/code&gt; (here, &lt;code&gt;T&lt;/code&gt; is the pointed-to type).</source>
          <target state="translated">Обратите внимание, что закрепление и &lt;code&gt;Unpin&lt;/code&gt; влияют только на указываемый тип &lt;code&gt;P::Target&lt;/code&gt; , а не на сам тип указателя &lt;code&gt;P&lt;/code&gt; , заключенный в &lt;code&gt;Pin&amp;lt;P&amp;gt;&lt;/code&gt; . Например, нерафинированные или &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; является &lt;code&gt;Unpin&lt;/code&gt; не оказывает никакого влияния на поведение &lt;code&gt;Pin&amp;lt;Box&amp;lt;T&amp;gt;&amp;gt;&lt;/code&gt; (здесь, &lt;code&gt;T&lt;/code&gt; является заостренный к типу).</target>
        </trans-unit>
        <trans-unit id="2fe7274dabcb32334d2b65bc1dce4238c4a816f1" translate="yes" xml:space="preserve">
          <source>Note that reading updates the slice to point to the yet unread part. The slice will be empty when EOF is reached.</source>
          <target state="translated">Обратите внимание,что чтение обновляет ломтик,указывая на еще не прочитанную часть.При достижении EOF ломтик будет пустым.</target>
        </trans-unit>
        <trans-unit id="4175de8081524003025f4bfc586324edc516ca55" translate="yes" xml:space="preserve">
          <source>Note that similar to &lt;a href=&quot;../../../fs/struct.file#method.read&quot;&gt;&lt;code&gt;File::read&lt;/code&gt;&lt;/a&gt;, it is not an error to return with a short read.</source>
          <target state="translated">Обратите внимание, что, как и в случае с &lt;a href=&quot;../../../fs/struct.file#method.read&quot;&gt; &lt;code&gt;File::read&lt;/code&gt; &lt;/a&gt; , возврат с коротким чтением не является ошибкой.</target>
        </trans-unit>
        <trans-unit id="78d8286e3fe0bd2fe84e388fefe8408d278761d1" translate="yes" xml:space="preserve">
          <source>Note that similar to &lt;a href=&quot;../../../fs/struct.file#method.write&quot;&gt;&lt;code&gt;File::write&lt;/code&gt;&lt;/a&gt;, it is not an error to return a short write.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="18a21f083a37ce3c0667ef89806f56b48c052291" translate="yes" xml:space="preserve">
          <source>Note that similar to &lt;a href=&quot;../../../fs/struct.file#write.v&quot;&gt;&lt;code&gt;File::write&lt;/code&gt;&lt;/a&gt;, it is not an error to return a short write.</source>
          <target state="translated">Обратите внимание, что, как и в случае с &lt;a href=&quot;../../../fs/struct.file#write.v&quot;&gt; &lt;code&gt;File::write&lt;/code&gt; &lt;/a&gt; , возврат короткой записи не является ошибкой.</target>
        </trans-unit>
        <trans-unit id="c9ab4b26c6a7bf726c988738e7c68f1f0c9fa972" translate="yes" xml:space="preserve">
          <source>Note that similar to &lt;code&gt;File::read&lt;/code&gt;, it is not an error to return with a short read. When returning from such a short read, the file pointer is still updated.</source>
          <target state="translated">Обратите внимание, что, как и в случае с &lt;code&gt;File::read&lt;/code&gt; , возврат с коротким чтением не является ошибкой. При возврате из такого короткого чтения указатель файла все еще обновляется.</target>
        </trans-unit>
        <trans-unit id="1f1bfbbca00b5726c71935536de215a864a82741" translate="yes" xml:space="preserve">
          <source>Note that similar to &lt;code&gt;File::write&lt;/code&gt;, it is not an error to return a short write. When returning from such a short write, the file pointer is still updated.</source>
          <target state="translated">Обратите внимание, что, как и в случае с &lt;code&gt;File::write&lt;/code&gt; , возврат короткой записи не является ошибкой. При возврате из такой короткой записи указатель файла все еще обновляется.</target>
        </trans-unit>
        <trans-unit id="eea44851a548460d198f033df0aa2c78011af765" translate="yes" xml:space="preserve">
          <source>Note that some platforms may simply implement this in terms of &lt;a href=&quot;struct.file#method.sync_all&quot;&gt;&lt;code&gt;sync_all&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Обратите внимание, что некоторые платформы могут просто реализовать это в терминах &lt;a href=&quot;struct.file#method.sync_all&quot;&gt; &lt;code&gt;sync_all&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="903a64802e8ba87174caa993876c0922efd29b51" translate="yes" xml:space="preserve">
          <source>Note that stdout is frequently line-buffered by default so it may be necessary to use &lt;a href=&quot;io/trait.write#tymethod.flush&quot;&gt;&lt;code&gt;io::stdout().flush()&lt;/code&gt;&lt;/a&gt; to ensure the output is emitted immediately.</source>
          <target state="translated">Обратите внимание, что stdout часто по умолчанию буферизуется по строкам, поэтому может потребоваться использовать &lt;a href=&quot;io/trait.write#tymethod.flush&quot;&gt; &lt;code&gt;io::stdout().flush()&lt;/code&gt; &lt;/a&gt; чтобы обеспечить немедленную выдачу вывода.</target>
        </trans-unit>
        <trans-unit id="b78b962ade7d55d80fe60c36c51b53741b559cf7" translate="yes" xml:space="preserve">
          <source>Note that thanks to Rust's safety guarantees, accessing global (static) variables requires &lt;code&gt;unsafe&lt;/code&gt; code, assuming we don't use any of the synchronization primitives in this module.</source>
          <target state="translated">Обратите внимание, что благодаря гарантиям безопасности Rust для доступа к глобальным (статическим) переменным требуется &lt;code&gt;unsafe&lt;/code&gt; код, если мы не используем какие-либо примитивы синхронизации в этом модуле.</target>
        </trans-unit>
        <trans-unit id="7e334bbf7d2932e1e0dab50b1bbb42d3e778d93e" translate="yes" xml:space="preserve">
          <source>Note that the &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; and &lt;code&gt;||&lt;/code&gt; operators short-circuit, i.e., they only evaluate their second operand if it contributes to the result. Since this behavior is not enforceable by traits, &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; and &lt;code&gt;||&lt;/code&gt; are not supported as overloadable operators.</source>
          <target state="translated">Обратите внимание, что &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; и &lt;code&gt;||&lt;/code&gt; операторы сокращают замыкание, т. е. они оценивают свой второй операнд только в том случае, если он влияет на результат. Так как это поведение не может быть обеспечено с помощью трейтов, &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; и &lt;code&gt;||&lt;/code&gt; не поддерживаются как перегружаемые операторы.</target>
        </trans-unit>
        <trans-unit id="eabb54c531ee493a23016d47151401e59c37e082" translate="yes" xml:space="preserve">
          <source>Note that the &lt;code&gt;*&lt;/code&gt; operator is replaced with a call to the &lt;code&gt;deref&lt;/code&gt; method and then a call to the &lt;code&gt;*&lt;/code&gt; operator just once, each time we use a &lt;code&gt;*&lt;/code&gt; in our code. Because the substitution of the &lt;code&gt;*&lt;/code&gt; operator does not recurse infinitely, we end up with data of type &lt;code&gt;i32&lt;/code&gt;, which matches the &lt;code&gt;5&lt;/code&gt; in &lt;code&gt;assert_eq!&lt;/code&gt; in Listing 15-9.</source>
          <target state="translated">Обратите внимание, что оператор &lt;code&gt;*&lt;/code&gt; заменяется вызовом метода &lt;code&gt;deref&lt;/code&gt; , а затем вызовом оператора &lt;code&gt;*&lt;/code&gt; только один раз, каждый раз, когда мы используем &lt;code&gt;*&lt;/code&gt; в нашем коде. Поскольку подстановка оператора &lt;code&gt;*&lt;/code&gt; не повторяется бесконечно, мы получаем данные типа &lt;code&gt;i32&lt;/code&gt; , которые соответствуют &lt;code&gt;5&lt;/code&gt; в &lt;code&gt;assert_eq!&lt;/code&gt; в Листинге 15-9.</target>
        </trans-unit>
        <trans-unit id="42a41979051d804f1901f27167063da0694efa1d" translate="yes" xml:space="preserve">
          <source>Note that the &lt;code&gt;Backtrace::force_capture&lt;/code&gt; function can be used to ignore these environment variables. Also note that the state of environment variables is cached once the first backtrace is created, so altering &lt;code&gt;RUST_LIB_BACKTRACE&lt;/code&gt; or &lt;code&gt;RUST_BACKTRACE&lt;/code&gt; at runtime may not actually change how backtraces are captured.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2c6dbff824203032252330e130f2e622a82a7979" translate="yes" xml:space="preserve">
          <source>Note that the &lt;code&gt;FromFn&lt;/code&gt; iterator doesn&amp;rsquo;t make assumptions about the behavior of the closure, and therefore conservatively does not implement &lt;a href=&quot;trait.fusediterator&quot;&gt;&lt;code&gt;FusedIterator&lt;/code&gt;&lt;/a&gt;, or override &lt;a href=&quot;trait.iterator#method.size_hint&quot;&gt;&lt;code&gt;Iterator::size_hint()&lt;/code&gt;&lt;/a&gt; from its default &lt;code&gt;(0, None)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8f63b935f8ce4492cffe03bd17e920a6c5bccf71" translate="yes" xml:space="preserve">
          <source>Note that the &lt;code&gt;FromFn&lt;/code&gt; iterator doesn&amp;rsquo;t make assumptions about the behavior of the closure, and therefore conservatively does not implement &lt;a href=&quot;trait.fusediterator&quot;&gt;&lt;code&gt;FusedIterator&lt;/code&gt;&lt;/a&gt;, or override &lt;a href=&quot;trait.iterator#method.size_hint&quot;&gt;&lt;code&gt;Iterator::size_hint&lt;/code&gt;&lt;/a&gt; from its default &lt;code&gt;(0, None)&lt;/code&gt;.</source>
          <target state="translated">Обратите внимание, что итератор &lt;code&gt;FromFn&lt;/code&gt; не делает предположений о поведении замыкания и поэтому консервативно не реализует &lt;a href=&quot;trait.fusediterator&quot;&gt; &lt;code&gt;FusedIterator&lt;/code&gt; &lt;/a&gt; и не переопределяет &lt;a href=&quot;trait.iterator#method.size_hint&quot;&gt; &lt;code&gt;Iterator::size_hint&lt;/code&gt; &lt;/a&gt; умолчанию &lt;code&gt;(0, None)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="bea015d687dff2009a1239b5a7393bd8adb473e8" translate="yes" xml:space="preserve">
          <source>Note that the &lt;code&gt;PrimaryColor&lt;/code&gt; and &lt;code&gt;SecondaryColor&lt;/code&gt; types aren&amp;rsquo;t listed on the front page, nor is the &lt;code&gt;mix&lt;/code&gt; function. We have to click &lt;code&gt;kinds&lt;/code&gt; and &lt;code&gt;utils&lt;/code&gt; to see them.</source>
          <target state="translated">Обратите внимание, что &lt;code&gt;PrimaryColor&lt;/code&gt; и &lt;code&gt;SecondaryColor&lt;/code&gt; не указаны на первой странице, как и функция &lt;code&gt;mix&lt;/code&gt; . Чтобы увидеть их, нужно щелкнуть по &lt;code&gt;kinds&lt;/code&gt; и &lt;code&gt;utils&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8f49c43ce4bf9debfde5b04db98c0212ba6c8e15" translate="yes" xml:space="preserve">
          <source>Note that the &lt;code&gt;SOME_PROPERTY&lt;/code&gt; associated constant would not compile, as its type &lt;code&gt;bool&lt;/code&gt; refers to the struct, rather than to the primitive bool type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="659da6617a0c6362038e0166dcdb0fdd380d7b37" translate="yes" xml:space="preserve">
          <source>Note that the &lt;code&gt;black&lt;/code&gt; and &lt;code&gt;origin&lt;/code&gt; values are different types, because they&amp;rsquo;re instances of different tuple structs. Each struct you define is its own type, even though the fields within the struct have the same types. For example, a function that takes a parameter of type &lt;code&gt;Color&lt;/code&gt; cannot take a &lt;code&gt;Point&lt;/code&gt; as an argument, even though both types are made up of three &lt;code&gt;i32&lt;/code&gt; values. Otherwise, tuple struct instances behave like tuples: you can destructure them into their individual pieces, you can use a &lt;code&gt;.&lt;/code&gt; followed by the index to access an individual value, and so on.</source>
          <target state="translated">Обратите внимание, что значения &lt;code&gt;black&lt;/code&gt; и &lt;code&gt;origin&lt;/code&gt; относятся к разным типам, потому что они являются экземплярами разных структур кортежей. Каждая определяемая вами структура имеет собственный тип, даже если поля в структуре имеют одинаковые типы. Например, функция, которая принимает параметр типа &lt;code&gt;Color&lt;/code&gt; , не может принимать &lt;code&gt;Point&lt;/code&gt; в качестве аргумента, даже если оба типа состоят из трех значений &lt;code&gt;i32&lt;/code&gt; . В противном случае экземпляры структуры кортежа ведут себя как кортежи: вы можете разложить их на отдельные части, вы можете использовать файл &lt;code&gt;.&lt;/code&gt; за которым следует индекс для доступа к отдельному значению и т. д.</target>
        </trans-unit>
        <trans-unit id="7585cdf9a53bb6203f72700ad7d5c4700090428d" translate="yes" xml:space="preserve">
          <source>Note that the &lt;code&gt;internal_adder&lt;/code&gt; function is not marked as &lt;code&gt;pub&lt;/code&gt;, but because tests are just Rust code and the &lt;code&gt;tests&lt;/code&gt; module is just another module, you can bring &lt;code&gt;internal_adder&lt;/code&gt; into a test&amp;rsquo;s scope and call it. If you don&amp;rsquo;t think private functions should be tested, there&amp;rsquo;s nothing in Rust that will compel you to do so.</source>
          <target state="translated">Обратите внимание, что функция &lt;code&gt;internal_adder&lt;/code&gt; не помечена как &lt;code&gt;pub&lt;/code&gt; , но поскольку тесты - это просто код Rust, а модуль &lt;code&gt;tests&lt;/code&gt; - просто еще один модуль, вы можете перенести &lt;code&gt;internal_adder&lt;/code&gt; в область проверки и вызвать его. Если вы не думаете, что частные функции следует тестировать, в Rust нет ничего, что заставило бы вас это делать.</target>
        </trans-unit>
        <trans-unit id="1dfcc45249eab2386a4a77c00ed86344264ef031" translate="yes" xml:space="preserve">
          <source>Note that the &lt;code&gt;mod common;&lt;/code&gt; declaration is the same as the module declaration we demonstrated in Listing 7-21. Then in the test function, we can call the &lt;code&gt;common::setup()&lt;/code&gt; function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2416a0788bd332296b9d3351af29231165e12f7f" translate="yes" xml:space="preserve">
          <source>Note that the &lt;code&gt;mod common;&lt;/code&gt; declaration is the same as the module declaration we demonstrated in Listing 7-25. Then in the test function, we can call the &lt;code&gt;common::setup()&lt;/code&gt; function.</source>
          <target state="translated">Обратите внимание, что &lt;code&gt;mod common;&lt;/code&gt; объявление такое же, как объявление модуля, которое мы продемонстрировали в листинге 7-25. Затем в тестовой функции мы можем вызвать функцию &lt;code&gt;common::setup()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3b202266f93986284846e418aa656da415bb5e7b" translate="yes" xml:space="preserve">
          <source>Note that the &lt;code&gt;pub use crate::front_of_house::hosting&lt;/code&gt; statement in &lt;em&gt;src/lib.rs&lt;/em&gt; also hasn&amp;rsquo;t changed, nor does &lt;code&gt;use&lt;/code&gt; have any impact on what files are compiled as part of the crate. The &lt;code&gt;mod&lt;/code&gt; keyword declares modules, and Rust looks in a file with the same name as the module for the code that goes into that module.</source>
          <target state="translated">Обратите внимание, что оператор &lt;code&gt;pub use crate::front_of_house::hosting&lt;/code&gt; в &lt;em&gt;src / lib.rs&lt;/em&gt; также не изменился, и при этом &lt;code&gt;use&lt;/code&gt; не влияет на то, какие файлы компилируются как часть ящика. &lt;code&gt;mod&lt;/code&gt; ключевое слово объявляет модули, и Руст смотрит в файл с тем же именем, что и модуль для кода , который входит в этот модуль.</target>
        </trans-unit>
        <trans-unit id="ebf0b34b8114310255f844126e635bca0217f44d" translate="yes" xml:space="preserve">
          <source>Note that the Rust syntax considers &lt;code&gt;-1i8&lt;/code&gt; as an application of the &lt;a href=&quot;expressions/operator-expr#negation-operators&quot;&gt;unary minus operator&lt;/a&gt; to an integer literal &lt;code&gt;1i8&lt;/code&gt;, rather than a single integer literal.</source>
          <target state="translated">Обратите внимание, что синтаксис Rust рассматривает &lt;code&gt;-1i8&lt;/code&gt; как приложение &lt;a href=&quot;expressions/operator-expr#negation-operators&quot;&gt;унарного оператора минус&lt;/a&gt; к целочисленному &lt;code&gt;1i8&lt;/code&gt; , а не к одному целочисленному литералу .</target>
        </trans-unit>
        <trans-unit id="56aae01ce79d910a619efda10dafe9ed6c6133a8" translate="yes" xml:space="preserve">
          <source>Note that the alignment of the resulting layout will be the maximum of those of &lt;code&gt;self&lt;/code&gt; and &lt;code&gt;next&lt;/code&gt;, in order to ensure alignment of both parts.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d7d6c6c7cc7587fa146a6b97e717ca83d5839bcb" translate="yes" xml:space="preserve">
          <source>Note that the allocator may give the collection more space than it requests. Therefore capacity can not be relied upon to be precisely minimal. Prefer &lt;a href=&quot;#method.reserve&quot;&gt;&lt;code&gt;reserve&lt;/code&gt;&lt;/a&gt; if future insertions are expected.</source>
          <target state="translated">Обратите внимание, что распределитель может предоставить коллекции больше места, чем она запрашивает. Поэтому нельзя полагаться на то, что мощность будет точно минимальной. Предпочтите &lt;a href=&quot;#method.reserve&quot;&gt; &lt;code&gt;reserve&lt;/code&gt; &lt;/a&gt; если ожидаются будущие вставки.</target>
        </trans-unit>
        <trans-unit id="3c27c4a17236d84a273debe0206e2acee86fe4f0" translate="yes" xml:space="preserve">
          <source>Note that the allocator may give the collection more space than it requests. Therefore capacity can not be relied upon to be precisely minimal. Prefer &lt;a href=&quot;../struct.binaryheap#method.reserve&quot;&gt;&lt;code&gt;reserve&lt;/code&gt;&lt;/a&gt; if future insertions are expected.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0b0700ca055cbce179ecc3d9a30bb5baa7a6c28e" translate="yes" xml:space="preserve">
          <source>Note that the allocator may give the collection more space than it requests. Therefore capacity can not be relied upon to be precisely minimal. Prefer &lt;a href=&quot;../struct.vecdeque#method.reserve&quot;&gt;&lt;code&gt;reserve&lt;/code&gt;&lt;/a&gt; if future insertions are expected.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="088614193a26ec5fa144e1468834aa2d40a502e0" translate="yes" xml:space="preserve">
          <source>Note that the allocator may give the collection more space than it requests. Therefore capacity can not be relied upon to be precisely minimal. Prefer &lt;a href=&quot;struct.binaryheap#method.reserve&quot;&gt;&lt;code&gt;reserve&lt;/code&gt;&lt;/a&gt; if future insertions are expected.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e71fe50cc784bf479a83f567c5fb33ac0db88d1d" translate="yes" xml:space="preserve">
          <source>Note that the allocator may give the collection more space than it requests. Therefore capacity can not be relied upon to be precisely minimal. Prefer &lt;a href=&quot;struct.vecdeque#method.reserve&quot;&gt;&lt;code&gt;reserve&lt;/code&gt;&lt;/a&gt; if future insertions are expected.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e47a0cb986bfab2cf7630c87b9673550639fc541" translate="yes" xml:space="preserve">
          <source>Note that the allocator may give the collection more space than it requests. Therefore, capacity can not be relied upon to be precisely minimal. Prefer &lt;code&gt;reserve&lt;/code&gt; if future insertions are expected.</source>
          <target state="translated">Обратите внимание, что распределитель может предоставить коллекции больше места, чем она запрашивает. Таким образом, нельзя полагаться на то, что мощность будет минимальной. Предпочтите &lt;code&gt;reserve&lt;/code&gt; если ожидаются будущие вставки.</target>
        </trans-unit>
        <trans-unit id="a8effc4910252eded99b791d1c4a5c812a34bdf2" translate="yes" xml:space="preserve">
          <source>Note that the allocator may give the collection more space than it requests. Therefore, capacity can not be relied upon to be precisely minimal. Prefer reserve if future insertions are expected.</source>
          <target state="translated">Обратите внимание,что аллокатор может предоставить коллекции больше места,чем она запрашивает.Поэтому на вместимость нельзя полагаться,чтобы она была точно минимальной.Предпочтителено резервирование,если ожидаются будущие вставки.</target>
        </trans-unit>
        <trans-unit id="08c862951a6a3b03e0330454b0efc29b2b754947" translate="yes" xml:space="preserve">
          <source>Note that the argument is not passed through a shell, but given literally to the program. This means that shell syntax like quotes, escaped characters, word splitting, glob patterns, substitution, etc. have no effect.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ba0769350c5d5d78015e993d43a239511a252097" translate="yes" xml:space="preserve">
          <source>Note that the arguments are not passed through a shell, but given literally to the program. This means that shell syntax like quotes, escaped characters, word splitting, glob patterns, substitution, etc. have no effect.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e7c41ef52ce2694587693c73f46ceb1c3c96783c" translate="yes" xml:space="preserve">
          <source>Note that the best effort is made to ensure that the time waited is measured with a monotonic clock, and not affected by the changes made to the system time.</source>
          <target state="translated">Обратите внимание,что максимальные усилия прилагаются для того,чтобы ожидаемое время измерялось с помощью монотонных часов,и на него не влияли изменения,вносимые в системное время.</target>
        </trans-unit>
        <trans-unit id="0ef4b3d8d9fa38a1ed8bb900aa8106bdb93d4e77" translate="yes" xml:space="preserve">
          <source>Note that the best effort is made to ensure that the time waited is measured with a monotonic clock, and not affected by the changes made to the system time. This function is susceptible to spurious wakeups. Condition variables normally have a boolean predicate associated with them, and the predicate must always be checked each time this function returns to protect against spurious wakeups. Additionally, it is typically desirable for the time-out to not exceed some duration in spite of spurious wakes, thus the sleep-duration is decremented by the amount slept. Alternatively, use the &lt;code&gt;wait_timeout_until&lt;/code&gt; method to wait until a condition is met with a total time-out regardless of spurious wakes.</source>
          <target state="translated">Обратите внимание, что прилагаются все усилия, чтобы гарантировать, что время ожидания измеряется с помощью монотонных часов и не зависит от изменений, внесенных в системное время. Эта функция подвержена ложным срабатываниям. Переменные условия обычно имеют связанный с ними логический предикат, и этот предикат всегда должен проверяться каждый раз, когда эта функция возвращается, чтобы защитить от ложного пробуждения. Кроме того, обычно желательно, чтобы тайм-аут не превышал некоторой продолжительности, несмотря на ложные пробуждения, таким образом, продолжительность сна уменьшается на количество сна. В качестве альтернативы можно использовать метод &lt;code&gt;wait_timeout_until&lt;/code&gt; , чтобы дождаться выполнения условия с общим тайм-аутом, независимо от ложных пробуждений.</target>
        </trans-unit>
        <trans-unit id="a6a58cc27a5e657fb0a670643552701080e58296" translate="yes" xml:space="preserve">
          <source>Note that the best effort is made to ensure that the time waited is measured with a monotonic clock, and not affected by the changes made to the system time. This function is susceptible to spurious wakeups. Condition variables normally have a boolean predicate associated with them, and the predicate must always be checked each time this function returns to protect against spurious wakeups. Additionally, it is typically desirable for the timeout to not exceed some duration in spite of spurious wakes, thus the sleep-duration is decremented by the amount slept. Alternatively, use the &lt;code&gt;wait_timeout_while&lt;/code&gt; method to wait with a timeout while a predicate is true.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4f53fcb70ba490adf24ce12bac9972be4901a158" translate="yes" xml:space="preserve">
          <source>Note that the capacity of &lt;code&gt;self&lt;/code&gt; does not change.</source>
          <target state="translated">Обратите внимание, что способность к &lt;code&gt;self&lt;/code&gt; не меняется.</target>
        </trans-unit>
        <trans-unit id="e939a8d32c47b3615c351b8f5ecdfdb4467cf4dc" translate="yes" xml:space="preserve">
          <source>Note that the entire instance must be mutable; Rust doesn&amp;rsquo;t allow us to mark only certain fields as mutable. As with any expression, we can construct a new instance of the struct as the last expression in the function body to implicitly return that new instance.</source>
          <target state="translated">Обратите внимание, что весь экземпляр должен быть изменяемым; Rust не позволяет нам помечать только определенные поля как изменяемые. Как и в случае с любым выражением, мы можем создать новый экземпляр структуры в качестве последнего выражения в теле функции, чтобы неявно вернуть этот новый экземпляр.</target>
        </trans-unit>
        <trans-unit id="893d3a404a478f2bef24f1a4da4b0eecf6cccd02" translate="yes" xml:space="preserve">
          <source>Note that the error here is in the definition of the generic function: Although we only call it with a parameter that does implement &lt;code&gt;Debug&lt;/code&gt;, the compiler still rejects the function: It must work with all possible input types. In order to make this example compile, we need to restrict the generic type we're accepting:</source>
          <target state="translated">Обратите внимание, что ошибка здесь в определении универсальной функции: хотя мы вызываем ее только с параметром, реализующим &lt;code&gt;Debug&lt;/code&gt; , компилятор все равно отклоняет функцию: она должна работать со всеми возможными типами ввода. Чтобы скомпилировать этот пример, нам нужно ограничить общий тип, который мы принимаем:</target>
        </trans-unit>
        <trans-unit id="06b34748b35f43179a334f500ab5063640caf614" translate="yes" xml:space="preserve">
          <source>Note that the expanded results of the input tokens may change in the future. You should be careful if you rely on the output.</source>
          <target state="translated">Обратите внимание,что расширенные результаты маркеров ввода могут измениться в будущем.Вы должны быть осторожны,если полагаетесь на результат.</target>
        </trans-unit>
        <trans-unit id="b4d3e131a7a31ae2f39a3a9a0dd9a292fd33ee3f" translate="yes" xml:space="preserve">
          <source>Note that the innermost object sets the bound, so &lt;code&gt;&amp;amp;'a Box&amp;lt;dyn Foo&amp;gt;&lt;/code&gt; is still &lt;code&gt;&amp;amp;'a Box&amp;lt;dyn Foo + 'static&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">Обратите внимание, что самый внутренний объект устанавливает границу, поэтому &lt;code&gt;&amp;amp;'a Box&amp;lt;dyn Foo&amp;gt;&lt;/code&gt; по-прежнему &lt;code&gt;&amp;amp;'a Box&amp;lt;dyn Foo + 'static&amp;gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="20accbf3ad080e6a83efff23cbdda0ba37be7c3a" translate="yes" xml:space="preserve">
          <source>Note that the lowercase dotted 'i' is the same as the Latin. Therefore:</source>
          <target state="translated">Обратите внимание,что строчная точка &quot;i&quot; совпадает с латиницей.Поэтому:</target>
        </trans-unit>
        <trans-unit id="0529503c0b783f1fa295149899ee5a9048a3f3e4" translate="yes" xml:space="preserve">
          <source>Note that the macro is intended as a debugging tool and therefore you should avoid having uses of it in version control for long periods. Use cases involving debug output that should be added to version control are better served by macros such as &lt;a href=&quot;https://docs.rs/log/*/log/macro.debug.html&quot;&gt;&lt;code&gt;debug!&lt;/code&gt;&lt;/a&gt; from the &lt;a href=&quot;https://crates.io/crates/log&quot;&gt;&lt;code&gt;log&lt;/code&gt;&lt;/a&gt; crate.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="33af38a46c0f54bbd2f36a31035d5f75fa5f8705" translate="yes" xml:space="preserve">
          <source>Note that the macro is intended as a debugging tool and therefore you should avoid having uses of it in version control for longer periods. Use cases involving debug output that should be added to version control are better served by macros such as &lt;a href=&quot;https://docs.rs/log/*/log/macro.debug.html&quot;&gt;&lt;code&gt;debug!&lt;/code&gt;&lt;/a&gt; from the &lt;a href=&quot;https://crates.io/crates/log&quot;&gt;&lt;code&gt;log&lt;/code&gt;&lt;/a&gt; crate.</source>
          <target state="translated">Обратите внимание, что макрос предназначен как средство отладки, и поэтому вам следует избегать его использования в системе контроля версий в течение длительного времени. Сценарии использования, включающие вывод отладки, которые следует добавить в систему контроля версий, лучше обслуживаются макросами, такими как &lt;a href=&quot;https://docs.rs/log/*/log/macro.debug.html&quot;&gt; &lt;code&gt;debug!&lt;/code&gt; &lt;/a&gt;из &lt;a href=&quot;https://crates.io/crates/log&quot;&gt; &lt;code&gt;log&lt;/code&gt; &lt;/a&gt; обрешетки.</target>
        </trans-unit>
        <trans-unit id="f68f549dc0f6cc4029741bd007637b70e59d35a0" translate="yes" xml:space="preserve">
          <source>Note that the output for the tests and the test results are interleaved; the reason is that the tests are running in parallel, as we talked about in the previous section. Try using the &lt;code&gt;--test-threads=1&lt;/code&gt; option and the &lt;code&gt;--nocapture&lt;/code&gt; flag, and see what the output looks like then!</source>
          <target state="translated">Обратите внимание, что выходные данные тестов и результаты тестов чередуются; причина в том, что тесты выполняются параллельно, о чем мы говорили в предыдущем разделе. Попробуйте использовать параметр &lt;code&gt;--test-threads=1&lt;/code&gt; и флаг &lt;code&gt;--nocapture&lt;/code&gt; , и посмотрите, как будет выглядеть результат!</target>
        </trans-unit>
        <trans-unit id="a844a8727324231842256b1e8aa12a2943bbaceb" translate="yes" xml:space="preserve">
          <source>Note that the pointer value may potentially represent a valid pointer to a &lt;code&gt;T&lt;/code&gt;, which means this must not be used as a &quot;not yet initialized&quot; sentinel value. Types that lazily allocate must track initialization by some other means.</source>
          <target state="translated">Обратите внимание, что значение указателя потенциально может представлять действительный указатель на &lt;code&gt;T&lt;/code&gt; , что означает, что его нельзя использовать как &amp;laquo;еще не инициализированное&amp;raquo; контрольное значение. Типы, которые распределяются лениво, должны отслеживать инициализацию другими способами.</target>
        </trans-unit>
        <trans-unit id="219a901fc4bbd905770e11b959092de46ce1a4b3" translate="yes" xml:space="preserve">
          <source>Note that the pointer value may potentially represent a valid pointer, which means this must not be used as a &quot;not yet initialized&quot; sentinel value. Types that lazily allocate must track initialization by some other means.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3e42d22c3d181aaaed5a33c43a08345afdbe2126" translate="yes" xml:space="preserve">
          <source>Note that the stack size of the main thread is &lt;em&gt;not&lt;/em&gt; determined by Rust.</source>
          <target state="translated">Обратите внимание, что размер стека основного потока &lt;em&gt;не&lt;/em&gt; определяется Rust.</target>
        </trans-unit>
        <trans-unit id="5317fa424b787d9e3193b4c178e1e274e73ebdb4" translate="yes" xml:space="preserve">
          <source>Note that the standard library (&lt;code&gt;std&lt;/code&gt;) is also a crate that&amp;rsquo;s external to our package. Because the standard library is shipped with the Rust language, we don&amp;rsquo;t need to change &lt;em&gt;Cargo.toml&lt;/em&gt; to include &lt;code&gt;std&lt;/code&gt;. But we do need to refer to it with &lt;code&gt;use&lt;/code&gt; to bring items from there into our package&amp;rsquo;s scope. For example, with &lt;code&gt;HashMap&lt;/code&gt; we would use this line:</source>
          <target state="translated">Обратите внимание, что стандартная библиотека ( &lt;code&gt;std&lt;/code&gt; ) также является ящиком, внешним по отношению к нашему пакету. Поскольку стандартная библиотека поставляется с языком Rust, нам не нужно изменять &lt;em&gt;Cargo.toml&lt;/em&gt; для включения &lt;code&gt;std&lt;/code&gt; . Но нам действительно нужно обращаться к нему с &lt;code&gt;use&lt;/code&gt; чтобы переносить элементы оттуда в область действия нашего пакета. Например, с &lt;code&gt;HashMap&lt;/code&gt; мы могли бы использовать эту строку:</target>
        </trans-unit>
        <trans-unit id="81d14f271d71ceb8a4e63a395e2c2b18f3026e6e" translate="yes" xml:space="preserve">
          <source>Note that the traits &lt;a href=&quot;../convert/trait.asref&quot;&gt;&lt;code&gt;AsRef&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../convert/trait.asmut&quot;&gt;&lt;code&gt;AsMut&lt;/code&gt;&lt;/a&gt; provide similar methods for types that may not be fixed-size arrays. Implementors should prefer those traits instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="405821d50e551ea851eed49e6fdd0bf01f98b46a" translate="yes" xml:space="preserve">
          <source>Note that the traits AsRef and AsMut provide similar methods for types that may not be fixed-size arrays. Implementors should prefer those traits instead.</source>
          <target state="translated">Обратите внимание,что трейты AsRef и AsMut предоставляют схожие методы для типов,которые не могут быть массивами фиксированного размера.Реализаторы должны предпочитать эти трейты.</target>
        </trans-unit>
        <trans-unit id="6289f32f721dc9ae628a24b212ad3154b1e5c872" translate="yes" xml:space="preserve">
          <source>Note that the type of &lt;code&gt;v&lt;/code&gt; can now be inferred from the type of &lt;code&gt;temp&lt;/code&gt;.</source>
          <target state="translated">Обратите внимание, что тип &lt;code&gt;v&lt;/code&gt; теперь можно определить по типу &lt;code&gt;temp&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6cb7f36bf472ae404403c7eb996727201edfc32d" translate="yes" xml:space="preserve">
          <source>Note that the underlying iterator is still advanced when &lt;a href=&quot;struct.peekable#method.peek&quot;&gt;&lt;code&gt;peek&lt;/code&gt;&lt;/a&gt; is called for the first time: In order to retrieve the next element, &lt;a href=&quot;trait.iterator#tymethod.next&quot;&gt;&lt;code&gt;next&lt;/code&gt;&lt;/a&gt; is called on the underlying iterator, hence any side effects (i.e. anything other than fetching the next value) of the &lt;a href=&quot;trait.iterator#tymethod.next&quot;&gt;&lt;code&gt;next&lt;/code&gt;&lt;/a&gt; method will occur.</source>
          <target state="translated">Обратите внимание, что базовый итератор по-прежнему расширяется, когда &lt;a href=&quot;struct.peekable#method.peek&quot;&gt; &lt;code&gt;peek&lt;/code&gt; &lt;/a&gt; вызывается в первый раз: чтобы получить следующий элемент, &lt;a href=&quot;trait.iterator#tymethod.next&quot;&gt; &lt;code&gt;next&lt;/code&gt; &lt;/a&gt; вызывается на базовом итераторе, следовательно, любые побочные эффекты (т. Е. Все, кроме выборки следующего значения) &lt;a href=&quot;trait.iterator#tymethod.next&quot;&gt; &lt;code&gt;next&lt;/code&gt; &lt;/a&gt; метод произойдет.</target>
        </trans-unit>
        <trans-unit id="5e9890cf8ac181c5bdc0d2e127263d39bf20f96f" translate="yes" xml:space="preserve">
          <source>Note that the utility of the returned value requires &lt;code&gt;align&lt;/code&gt; to be less than or equal to the alignment of the starting address for the whole allocated block of memory. One way to satisfy this constraint is to ensure &lt;code&gt;align &amp;lt;= self.align()&lt;/code&gt;.</source>
          <target state="translated">Обратите внимание, что полезность возвращаемого значения требует, чтобы &lt;code&gt;align&lt;/code&gt; было меньше или равно выравниванию начального адреса для всего выделенного блока памяти. Один из способов удовлетворить это ограничение - обеспечить &lt;code&gt;align &amp;lt;= self.align()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2d911cb36c04dcf8463355e9c033efd2983dc723" translate="yes" xml:space="preserve">
          <source>Note that the variants of the enum are namespaced under its identifier, and we use a double colon to separate the two. The reason this is useful is that now both values &lt;code&gt;IpAddrKind::V4&lt;/code&gt; and &lt;code&gt;IpAddrKind::V6&lt;/code&gt; are of the same type: &lt;code&gt;IpAddrKind&lt;/code&gt;. We can then, for instance, define a function that takes any &lt;code&gt;IpAddrKind&lt;/code&gt;:</source>
          <target state="translated">Обратите внимание, что варианты перечисления помещены в пространство имен под его идентификатором, и мы используем двойное двоеточие для их разделения. Причина, по которой это полезно, заключается в том, что теперь оба значения &lt;code&gt;IpAddrKind::V4&lt;/code&gt; и &lt;code&gt;IpAddrKind::V6&lt;/code&gt; имеют один и тот же тип: &lt;code&gt;IpAddrKind&lt;/code&gt; . Затем мы можем, например, определить функцию, которая принимает любой &lt;code&gt;IpAddrKind&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="16c052a3290e3d52e2b4ef43bfa0c661287a1967" translate="yes" xml:space="preserve">
          <source>Note that there is a subtle difference between using only &lt;code&gt;_&lt;/code&gt; and using a name that starts with an underscore. The syntax &lt;code&gt;_x&lt;/code&gt; still binds the value to the variable, whereas &lt;code&gt;_&lt;/code&gt; doesn&amp;rsquo;t bind at all. To show a case where this distinction matters, Listing 18-21 will provide us with an error.</source>
          <target state="translated">Обратите внимание, что есть небольшая разница между использованием только &lt;code&gt;_&lt;/code&gt; и использованием имени, которое начинается с подчеркивания. Синтаксис &lt;code&gt;_x&lt;/code&gt; по- прежнему связывает значение с переменной, тогда как &lt;code&gt;_&lt;/code&gt; не связывает вообще. Чтобы показать случай, когда это различие имеет значение, в листинге 18-21 содержится ошибка.</target>
        </trans-unit>
        <trans-unit id="a9f69008c63ee1bbbd3dca68ce2579a7f11ccac4" translate="yes" xml:space="preserve">
          <source>Note that there is no guarantee that the file is immediately deleted (e.g., depending on platform, other open file descriptors may prevent immediate removal).</source>
          <target state="translated">Обратите внимание,что нет гарантии,что файл будет немедленно удален (например,в зависимости от платформы,другие открытые дескрипторы файлов могут препятствовать немедленному удалению).</target>
        </trans-unit>
        <trans-unit id="c1d60a1d35c01b7a3e982971929136941cc6d773" translate="yes" xml:space="preserve">
          <source>Note that there might be more than one &lt;code&gt;Reject&lt;/code&gt; between two &lt;code&gt;Match&lt;/code&gt;es, there is no requirement for them to be combined into one.</source>
          <target state="translated">Обратите внимание, что между двумя &lt;code&gt;Match&lt;/code&gt; может быть более одного &lt;code&gt;Reject&lt;/code&gt; их необязательно объединять в одно.</target>
        </trans-unit>
        <trans-unit id="66991018cda906aad5fc546c336b3be880291e4b" translate="yes" xml:space="preserve">
          <source>Note that these outputs are stackable in the sense that if multiple are specified, then the compiler will produce each form of output at once without having to recompile. However, this only applies for outputs specified by the same method. If only &lt;code&gt;crate_type&lt;/code&gt; attributes are specified, then they will all be built, but if one or more &lt;code&gt;--crate-type&lt;/code&gt; command line flags are specified, then only those outputs will be built.</source>
          <target state="translated">Обратите внимание, что эти выходные данные можно наращивать в том смысле, что, если указано несколько, компилятор будет создавать каждую форму вывода сразу без необходимости перекомпиляции. Однако это применимо только к выходам, указанным тем же методом. Если &lt;code&gt;crate_type&lt;/code&gt; только атрибуты crate_type , тогда все они будут построены, но если &lt;code&gt;--crate-type&lt;/code&gt; один или несколько флагов командной строки --crate-type , то будут построены только эти выходные данные.</target>
        </trans-unit>
        <trans-unit id="68d9fc76dd03b0153bd61663810434ccc46dcc2c" translate="yes" xml:space="preserve">
          <source>Note that these requirements mean that the trait itself must be implemented symmetrically and transitively: if &lt;code&gt;T: PartialEq&amp;lt;U&amp;gt;&lt;/code&gt; and &lt;code&gt;U: PartialEq&amp;lt;V&amp;gt;&lt;/code&gt; then &lt;code&gt;U: PartialEq&amp;lt;T&amp;gt;&lt;/code&gt; and &lt;code&gt;T: PartialEq&amp;lt;V&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">Обратите внимание, что эти требования означают, что сам &lt;code&gt;T: PartialEq&amp;lt;U&amp;gt;&lt;/code&gt; должен быть реализован симметрично и транзитивно: если T: PartialEq &amp;lt;U&amp;gt; и &lt;code&gt;U: PartialEq&amp;lt;V&amp;gt;&lt;/code&gt; то &lt;code&gt;U: PartialEq&amp;lt;T&amp;gt;&lt;/code&gt; и &lt;code&gt;T: PartialEq&amp;lt;V&amp;gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="68c8d8134a3ad3fb6c3b8c1e1d2d42e5a3391556" translate="yes" xml:space="preserve">
          <source>Note that these requirements mean that the trait itself must be implemented symmetrically and transitively: if &lt;code&gt;T: PartialOrd&amp;lt;U&amp;gt;&lt;/code&gt; and &lt;code&gt;U: PartialOrd&amp;lt;V&amp;gt;&lt;/code&gt; then &lt;code&gt;U: PartialOrd&amp;lt;T&amp;gt;&lt;/code&gt; and &lt;code&gt;T: PartialOrd&amp;lt;V&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">Обратите внимание, что эти требования означают, что сам &lt;code&gt;T: PartialOrd&amp;lt;U&amp;gt;&lt;/code&gt; должен быть реализован симметрично и транзитивно: если T: PartialOrd &amp;lt;U&amp;gt; и &lt;code&gt;U: PartialOrd&amp;lt;V&amp;gt;&lt;/code&gt; то &lt;code&gt;U: PartialOrd&amp;lt;T&amp;gt;&lt;/code&gt; и &lt;code&gt;T: PartialOrd&amp;lt;V&amp;gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0a875078880a05f44d1479047dbce85f081dc8bf" translate="yes" xml:space="preserve">
          <source>Note that this &lt;code&gt;let&lt;/code&gt; statement means &lt;code&gt;expensive_closure&lt;/code&gt; contains the &lt;em&gt;definition&lt;/em&gt; of an anonymous function, not the &lt;em&gt;resulting value&lt;/em&gt; of calling the anonymous function. Recall that we&amp;rsquo;re using a closure because we want to define the code to call at one point, store that code, and call it at a later point; the code we want to call is now stored in &lt;code&gt;expensive_closure&lt;/code&gt;.</source>
          <target state="translated">Обратите внимание на то, что этот оператор &lt;code&gt;let&lt;/code&gt; означает, что &amp;laquo; &lt;code&gt;expensive_closure&lt;/code&gt; содержит &lt;em&gt;определение&lt;/em&gt; анонимной функции, а не &lt;em&gt;результирующее значение&lt;/em&gt; вызова анонимной функции. Напомним, что мы используем замыкание, потому что хотим определить код для вызова в одной точке, сохранить этот код и вызвать его позже; код, который мы хотим вызвать, теперь хранится в &lt;code&gt;expensive_closure&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f79a43777883bf04ed897be6d605f1d017ef8797" translate="yes" xml:space="preserve">
          <source>Note that this approach needs a reference to S with lifetime &lt;code&gt;'a&lt;/code&gt;. Nothing shorter than &lt;code&gt;'a&lt;/code&gt; will suffice: a shorter lifetime would imply that after &lt;code&gt;demo&lt;/code&gt; finishes executing, something else (such as the destructor!) could access &lt;code&gt;s.data&lt;/code&gt; after the end of that shorter lifetime, which would again violate the &lt;code&gt;&amp;amp;mut&lt;/code&gt;-borrow's exclusive access.</source>
          <target state="translated">Обратите внимание, что этот подход требует ссылки на S со временем жизни &lt;code&gt;'a&lt;/code&gt; . Ничего короче, чем &lt;code&gt;'a&lt;/code&gt; , будет достаточно: более короткое время жизни будет означать, что после завершения &lt;code&gt;demo&lt;/code&gt; что-то еще (например, деструктор!) &lt;code&gt;s.data&lt;/code&gt; получить доступ к s.data после окончания этого более короткого времени жизни, что снова нарушит исключительное свойство &lt;code&gt;&amp;amp;mut&lt;/code&gt; -borrow. доступ.</target>
        </trans-unit>
        <trans-unit id="c27fe5a5d1e022b605f9e160ee6f188847c0730a" translate="yes" xml:space="preserve">
          <source>Note that this behavior is a consequence of the desugaring to a function that returns an &lt;code&gt;impl Future&lt;/code&gt; -- in this case, the function we desugar to is an &lt;code&gt;unsafe&lt;/code&gt; function, but the return value remains the same.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d559316d5513a320d9bd5dde1c5db0aa4a3ef581" translate="yes" xml:space="preserve">
          <source>Note that this differs from the behavior of &lt;a href=&quot;../rc/struct.rc#method.make_mut&quot;&gt;&lt;code&gt;Rc::make_mut&lt;/code&gt;&lt;/a&gt; which disassociates any remaining &lt;code&gt;Weak&lt;/code&gt; pointers.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3192c9f3997431085906a96d26c01c024cf3788d" translate="yes" xml:space="preserve">
          <source>Note that this does &lt;strong&gt;not&lt;/strong&gt; return the number of bytes in the string in OS string form.</source>
          <target state="translated">Обратите внимание, что это &lt;strong&gt;не&lt;/strong&gt; возвращает количество байтов в строке в строковой форме ОС.</target>
        </trans-unit>
        <trans-unit id="80ff79baf2f49c9d290848de9fb000d654394ab7" translate="yes" xml:space="preserve">
          <source>Note that this does not move &lt;code&gt;v&lt;/code&gt; (unlike &lt;code&gt;transmute&lt;/code&gt;), and may need a call to &lt;code&gt;mem::forget(v)&lt;/code&gt; in case you want to avoid destructors being called.</source>
          <target state="translated">Обратите внимание, что это не перемещает &lt;code&gt;v&lt;/code&gt; (в отличие от &lt;code&gt;transmute&lt;/code&gt; ), и может потребоваться вызов &lt;code&gt;mem::forget(v)&lt;/code&gt; в случае, если вы хотите избежать вызова деструкторов.</target>
        </trans-unit>
        <trans-unit id="7810f8cddc029bde853e42fc348f1144623db2c4" translate="yes" xml:space="preserve">
          <source>Note that this example uses &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; and not &lt;code&gt;Arc&amp;lt;T&amp;gt;&lt;/code&gt;. &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt;s are for single-threaded scenarios. Consider using &lt;code&gt;RwLock&amp;lt;T&amp;gt;&lt;/code&gt; or &lt;code&gt;Mutex&amp;lt;T&amp;gt;&lt;/code&gt; if you need shared mutability in a multi-threaded situation.</source>
          <target state="translated">Обратите внимание, что в этом примере используется &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; а не &lt;code&gt;Arc&amp;lt;T&amp;gt;&lt;/code&gt; . &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt; предназначены для однопоточных сценариев. Рассмотрите возможность использования &lt;code&gt;RwLock&amp;lt;T&amp;gt;&lt;/code&gt; или &lt;code&gt;Mutex&amp;lt;T&amp;gt;&lt;/code&gt; если вам нужна общая изменчивость в многопоточной ситуации.</target>
        </trans-unit>
        <trans-unit id="cdd8e4eb74f462e708e2264904eba6fd4dc6a6a0" translate="yes" xml:space="preserve">
          <source>Note that this example won&amp;rsquo;t compile just yet; we&amp;rsquo;ll explain why in a bit.</source>
          <target state="translated">Обратите внимание, что этот пример пока не компилируется; мы объясним почему позже.</target>
        </trans-unit>
        <trans-unit id="5bd9e1731fac8ae0cac27d3b3c2a1bac0e799687" translate="yes" xml:space="preserve">
          <source>Note that this function &lt;strong&gt;may not catch all panics&lt;/strong&gt; in Rust. A panic in Rust is not always implemented via unwinding, but can be implemented by aborting the process as well. This function &lt;em&gt;only&lt;/em&gt; catches unwinding panics, not those that abort the process.</source>
          <target state="translated">Обратите внимание, что эта функция &lt;strong&gt;может не улавливать все паники&lt;/strong&gt; в Rust. Паника в Rust не всегда реализуется через раскручивание, но также может быть реализована путем прерывания процесса. Эта функция перехватывает &lt;em&gt;только&lt;/em&gt; панику при раскручивании, но не прерывание процесса.</target>
        </trans-unit>
        <trans-unit id="d3651367d7bc20ea65e217082fe9e78b8f819776" translate="yes" xml:space="preserve">
          <source>Note that this function does not always agree with the &lt;a href=&quot;cmp/trait.partialord&quot;&gt;&lt;code&gt;PartialOrd&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;cmp/trait.partialeq&quot;&gt;&lt;code&gt;PartialEq&lt;/code&gt;&lt;/a&gt; implementations of &lt;code&gt;f32&lt;/code&gt;. In particular, they regard negative and positive zero as equal, while &lt;code&gt;total_cmp&lt;/code&gt; doesn't.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2d6a1415dd489b9fd2f261b68de74159561b45e0" translate="yes" xml:space="preserve">
          <source>Note that this function does not always agree with the &lt;a href=&quot;cmp/trait.partialord&quot;&gt;&lt;code&gt;PartialOrd&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;cmp/trait.partialeq&quot;&gt;&lt;code&gt;PartialEq&lt;/code&gt;&lt;/a&gt; implementations of &lt;code&gt;f64&lt;/code&gt;. In particular, they regard negative and positive zero as equal, while &lt;code&gt;total_cmp&lt;/code&gt; doesn't.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="19f0a1a5449c981a5e246c3b5e6a9fcf303b7fa2" translate="yes" xml:space="preserve">
          <source>Note that this function is distinct from &lt;code&gt;as&lt;/code&gt; casting, which attempts to preserve the &lt;em&gt;numeric&lt;/em&gt; value, and not the bitwise value.</source>
          <target state="translated">Обратите внимание , что эта функция отличается от , &lt;code&gt;as&lt;/code&gt; отливки, которая пытается сохранить &lt;em&gt;числовое&lt;/em&gt; значение, а не значение побитового.</target>
        </trans-unit>
        <trans-unit id="d63eb9d4a24784000530071fbe51104de3bf3f2c" translate="yes" xml:space="preserve">
          <source>Note that this function is same as &lt;a href=&quot;#method.extend&quot;&gt;&lt;code&gt;extend&lt;/code&gt;&lt;/a&gt; except that it is specialized to work with slices instead. If and when Rust gets specialization this function will likely be deprecated (but still available).</source>
          <target state="translated">Обратите внимание, что эта функция аналогична &lt;a href=&quot;#method.extend&quot;&gt; &lt;code&gt;extend&lt;/code&gt; &lt;/a&gt; за исключением того, что она специализируется на работе с срезами. Если и когда Rust получит специализацию, эта функция, вероятно, станет устаревшей (но все еще будет доступна).</target>
        </trans-unit>
        <trans-unit id="0f406b6d417033b808228cce14b8dbb1120d5c7d" translate="yes" xml:space="preserve">
          <source>Note that this function is same as &lt;a href=&quot;struct.vec#method.extend&quot;&gt;&lt;code&gt;extend&lt;/code&gt;&lt;/a&gt; except that it is specialized to work with slices instead. If and when Rust gets specialization this function will likely be deprecated (but still available).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="65def495fd9076c99d32e3ed9abc467516100c9b" translate="yes" xml:space="preserve">
          <source>Note that this function is susceptible to spurious wakeups. Condition variables normally have a boolean predicate associated with them, and the predicate must always be checked each time this function returns to protect against spurious wakeups.</source>
          <target state="translated">Обратите внимание,что эта функция подвержена поддельным пробуждениям.Переменные условий обычно имеют связанный с ними булевый предикат,и предикат всегда должен проверяться каждый раз,когда эта функция возвращается для защиты от поддельных пробуждений.</target>
        </trans-unit>
        <trans-unit id="313e92b88c0b90cea2623eaa38278951f5c4defe" translate="yes" xml:space="preserve">
          <source>Note that this function may block the current thread while resolution is performed.</source>
          <target state="translated">Обратите внимание,что эта функция может блокировать текущий поток при выполнении разрешения.</target>
        </trans-unit>
        <trans-unit id="380b102b57d47b1e80ead440741eb736cbc5acae" translate="yes" xml:space="preserve">
          <source>Note that this function returns NaN if the initial value was NaN as well.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="041273b62662865c4b0b3972fa9f215d6a183216" translate="yes" xml:space="preserve">
          <source>Note that this is &lt;em&gt;also&lt;/em&gt; different from Windows-1252 a.k.a. code page 1252, which is a superset ISO/IEC 8859-1 that assigns some (not all!) blanks to punctuation and various Latin characters.</source>
          <target state="translated">Обратите внимание, что это &lt;em&gt;также&lt;/em&gt; отличается от Windows-1252 или кодовой страницы 1252, которая представляет собой расширенный набор ISO / IEC 8859-1, который назначает некоторые (не все!) Пробелы знакам пунктуации и различным латинским символам.</target>
        </trans-unit>
        <trans-unit id="c12e3030c3946db5f00ad56e92693e7a60e9d4f4" translate="yes" xml:space="preserve">
          <source>Note that this is &lt;em&gt;not&lt;/em&gt; the same as a rotate-left; the RHS of a wrapping shift-left is restricted to the range of the type, rather than the bits shifted out of the LHS being returned to the other end. The primitive integer types all implement a &lt;a href=&quot;#method.rotate_left&quot;&gt;&lt;code&gt;rotate_left&lt;/code&gt;&lt;/a&gt; function, which may be what you want instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d05d921ff847b716a1e90578f4bb30e691402415" translate="yes" xml:space="preserve">
          <source>Note that this is &lt;em&gt;not&lt;/em&gt; the same as a rotate-left; the RHS of a wrapping shift-left is restricted to the range of the type, rather than the bits shifted out of the LHS being returned to the other end. The primitive integer types all implement a &lt;code&gt;[&lt;/code&gt;rotate_left`](#method.rotate_left) function, which may be what you want instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b16eb422b8b7fd380457bb98366ee9e32e4eb27b" translate="yes" xml:space="preserve">
          <source>Note that this is &lt;em&gt;not&lt;/em&gt; the same as a rotate-left; the RHS of a wrapping shift-left is restricted to the range of the type, rather than the bits shifted out of the LHS being returned to the other end. The primitive integer types all implement a &lt;code&gt;rotate_left&lt;/code&gt; function, which may be what you want instead.</source>
          <target state="translated">Обратите внимание, что это &lt;em&gt;не&lt;/em&gt; то же самое, что поворот влево; правая часть оборачивающего сдвига влево ограничена диапазоном типа, а не биты, сдвинутые из LHS, возвращаемые на другой конец. Все примитивные целочисленные типы реализуют функцию &lt;code&gt;rotate_left&lt;/code&gt; , которая может быть тем, что вам нужно.</target>
        </trans-unit>
        <trans-unit id="3efbf7b6ffbe371fa44b1cbc24ab53cb5dc43bf3" translate="yes" xml:space="preserve">
          <source>Note that this is &lt;em&gt;not&lt;/em&gt; the same as a rotate-right; the RHS of a wrapping shift-right is restricted to the range of the type, rather than the bits shifted out of the LHS being returned to the other end. The primitive integer types all implement a &lt;a href=&quot;#method.rotate_right&quot;&gt;&lt;code&gt;rotate_right&lt;/code&gt;&lt;/a&gt; function, which may be what you want instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3e2418939b1c8a1ff22ccadf416147fa70a3f1d3" translate="yes" xml:space="preserve">
          <source>Note that this is &lt;em&gt;not&lt;/em&gt; the same as a rotate-right; the RHS of a wrapping shift-right is restricted to the range of the type, rather than the bits shifted out of the LHS being returned to the other end. The primitive integer types all implement a &lt;code&gt;rotate_right&lt;/code&gt; function, which may be what you want instead.</source>
          <target state="translated">Обратите внимание, что это &lt;em&gt;не&lt;/em&gt; то же самое, что поворот вправо; Правая часть оборачивающего сдвига вправо ограничена диапазоном типа, а не биты, сдвинутые из LHS, возвращаются на другой конец. Все примитивные целочисленные типы реализуют функцию &lt;code&gt;rotate_right&lt;/code&gt; , которая может быть тем, что вам нужно.</target>
        </trans-unit>
        <trans-unit id="5e7c41ce1c84929477918f04b930178589599b47" translate="yes" xml:space="preserve">
          <source>Note that this is different from ISO/IEC 8859-1 a.k.a. ISO 8859-1 (with one less hyphen), which leaves some &quot;blanks&quot;, byte values that are not assigned to any character. ISO-8859-1 (the IANA one) assigns them to the C0 and C1 control codes.</source>
          <target state="translated">Обратите внимание,что это отличается от ISO/IEC 8859-1,также известного как ISO 8859-1 (с одним дефисом меньше),что оставляет некоторые &quot;пробелы&quot;,байтовые значения,которые не присваиваются ни одному символу.ISO-8859-1 (IANA)присваивает их контрольным кодам С0 и С1.</target>
        </trans-unit>
        <trans-unit id="8c4108681b9fe84accc050cbc8f424a5d8e729f9" translate="yes" xml:space="preserve">
          <source>Note that this is not fully supported yet.</source>
          <target state="translated">Обратите внимание,что это еще не полностью поддерживается.</target>
        </trans-unit>
        <trans-unit id="f63d3c3ade69b60f12aa852f379afa06c0c1f9ef" translate="yes" xml:space="preserve">
          <source>Note that this list may get tweaked over time as clarifications are made in the future.</source>
          <target state="translated">Обратите внимание,что этот список может со временем меняться по мере того,как в будущем будут вноситься уточнения.</target>
        </trans-unit>
        <trans-unit id="03886768677567c6f0e7dd2acec0f3c2f274c587" translate="yes" xml:space="preserve">
          <source>Note that this may not have any affect on IPv6 sockets.</source>
          <target state="translated">Обратите внимание,что это может никак не повлиять на IPv6 сокеты.</target>
        </trans-unit>
        <trans-unit id="75b3dfc6f40c762d7bf2bac499b7412fe6b10302" translate="yes" xml:space="preserve">
          <source>Note that this may not have any effect on IPv6 sockets.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2dd32cd539a7711b8e3e1fa20fa744535b499c0b" translate="yes" xml:space="preserve">
          <source>Note that this method alters the content of the underlying file, even though it takes &lt;code&gt;&amp;amp;self&lt;/code&gt; rather than &lt;code&gt;&amp;amp;mut self&lt;/code&gt;.</source>
          <target state="translated">Обратите внимание, что этот метод изменяет содержимое базового файла, даже если он принимает &lt;code&gt;&amp;amp;self&lt;/code&gt; а не &lt;code&gt;&amp;amp;mut self&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="108aecbc7f980094cc29f71b2bba33a5524e868d" translate="yes" xml:space="preserve">
          <source>Note that this method alters the permissions of the underlying file, even though it takes &lt;code&gt;&amp;amp;self&lt;/code&gt; rather than &lt;code&gt;&amp;amp;mut self&lt;/code&gt;.</source>
          <target state="translated">Обратите внимание, что этот метод изменяет права доступа к базовому файлу, даже если он принимает &lt;code&gt;&amp;amp;self&lt;/code&gt; а не &lt;code&gt;&amp;amp;mut self&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e2935aad8d6fdca6a365f84d6feb6723528101b9" translate="yes" xml:space="preserve">
          <source>Note that this method does not add any padding to the overall size, regardless of whether the returned layout has a different alignment. In other words, if &lt;code&gt;K&lt;/code&gt; has size 16, &lt;code&gt;K.align_to(32)&lt;/code&gt; will &lt;em&gt;still&lt;/em&gt; have size 16.</source>
          <target state="translated">Обратите внимание, что этот метод не добавляет никаких отступов к общему размеру, независимо от того, имеет ли возвращаемый макет другое выравнивание. Другими словами, если &lt;code&gt;K&lt;/code&gt; имеет размер 16, &lt;code&gt;K.align_to(32)&lt;/code&gt; все &lt;em&gt;равно&lt;/em&gt; будет иметь размер 16.</target>
        </trans-unit>
        <trans-unit id="be7d3b69a88f7138cbd894fa652fd4db3b576956" translate="yes" xml:space="preserve">
          <source>Note that this method has no effect on the allocated capacity of the string</source>
          <target state="translated">Обратите внимание,что этот метод не влияет на выделенную емкость строки</target>
        </trans-unit>
        <trans-unit id="c7737d7dae93fa9ff008b32d416192e1953f17cf" translate="yes" xml:space="preserve">
          <source>Note that this method has no effect on the allocated capacity of the vector.</source>
          <target state="translated">Обратите внимание,что этот метод не влияет на выделенную емкость вектора.</target>
        </trans-unit>
        <trans-unit id="89e693fcdc5244de65fc2d6120edee9bdcd4b3ee" translate="yes" xml:space="preserve">
          <source>Note that this structure is &lt;strong&gt;not&lt;/strong&gt;&lt;code&gt;repr(C)&lt;/code&gt; and is not recommended to be placed in the signatures of FFI functions. Instead, safe wrappers of FFI functions may leverage the unsafe &lt;a href=&quot;#method.from_ptr&quot;&gt;&lt;code&gt;from_ptr&lt;/code&gt;&lt;/a&gt; constructor to provide a safe interface to other consumers.</source>
          <target state="translated">Обратите внимание, что эта структура &lt;strong&gt;не&lt;/strong&gt; является &lt;code&gt;repr(C)&lt;/code&gt; и ее не рекомендуется помещать в подписи функций FFI. Вместо этого безопасные оболочки функций FFI могут использовать небезопасный конструктор &lt;a href=&quot;#method.from_ptr&quot;&gt; &lt;code&gt;from_ptr&lt;/code&gt; ,&lt;/a&gt; чтобы обеспечить безопасный интерфейс для других потребителей.</target>
        </trans-unit>
        <trans-unit id="9aac27458abae34c90a97df1aff42a3fdeee40a4" translate="yes" xml:space="preserve">
          <source>Note that this structure is &lt;strong&gt;not&lt;/strong&gt;&lt;code&gt;repr(C)&lt;/code&gt; and is not recommended to be placed in the signatures of FFI functions. Instead, safe wrappers of FFI functions may leverage the unsafe &lt;a href=&quot;struct.cstr#method.from_ptr&quot;&gt;&lt;code&gt;CStr::from_ptr&lt;/code&gt;&lt;/a&gt; constructor to provide a safe interface to other consumers.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f5da6d2d2aa3f48414658a9bcd539c6d50d1d673" translate="yes" xml:space="preserve">
          <source>Note that this technique can also be used in the arms of a match expression:</source>
          <target state="translated">Обратите внимание,что эта техника также может быть использована в выражениях на руках матча:</target>
        </trans-unit>
        <trans-unit id="b13210c5a5854d88abb024233653585819c00385" translate="yes" xml:space="preserve">
          <source>Note that this will drop any excess capacity.</source>
          <target state="translated">Обратите внимание,что это приведет к снижению любой избыточной мощности.</target>
        </trans-unit>
        <trans-unit id="6affebf246a6b9323b472569ce7b0d2dca1b6504" translate="yes" xml:space="preserve">
          <source>Note that unlike &lt;a href=&quot;trait.iterator#method.take_while&quot;&gt;&lt;code&gt;take_while&lt;/code&gt;&lt;/a&gt; this iterator is &lt;strong&gt;not&lt;/strong&gt; fused. It is also not specified what this iterator returns after the first&lt;code&gt; None&lt;/code&gt; is returned. If you need fused iterator, use &lt;a href=&quot;trait.iterator#method.fuse&quot;&gt;&lt;code&gt;fuse&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4d98fb91c14420919b7eff367a1230b8f150b713" translate="yes" xml:space="preserve">
          <source>Note that unlike &lt;code&gt;wait&lt;/code&gt;, this function will not attempt to drop stdin.</source>
          <target state="translated">Обратите внимание, что в отличие от &lt;code&gt;wait&lt;/code&gt; эта функция не будет пытаться сбросить стандартный ввод.</target>
        </trans-unit>
        <trans-unit id="cb34ec44c63eee46c533ae8549230c0956f06438" translate="yes" xml:space="preserve">
          <source>Note that unlike array expressions this syntax supports all elements which implement &lt;a href=&quot;clone/trait.clone&quot;&gt;&lt;code&gt;Clone&lt;/code&gt;&lt;/a&gt; and the number of elements doesn't have to be a constant.</source>
          <target state="translated">Обратите внимание, что в отличие от выражений массива этот синтаксис поддерживает все элементы, которые реализуют &lt;a href=&quot;clone/trait.clone&quot;&gt; &lt;code&gt;Clone&lt;/code&gt; &lt;/a&gt; и количество элементов не обязательно должно быть константой.</target>
        </trans-unit>
        <trans-unit id="09bd0257d3adc41b553ee0c1fba837b27ed6d43d" translate="yes" xml:space="preserve">
          <source>Note that unsized types have many possible null pointers, as only the raw data pointer is considered, not their length, vtable, etc. Therefore, two pointers that are null may still not compare equal to each other.</source>
          <target state="translated">Обратите внимание,что неразмерные типы имеют много возможных нулевых указателей,так как учитывается только указатель на необработанные данные,а не их длина,табуляция и т.д.Поэтому два нулевых указателя все равно могут не сравниваться друг с другом.</target>
        </trans-unit>
        <trans-unit id="1f2131c92cffd468fb8e9760cfdc9ed5b9347fe9" translate="yes" xml:space="preserve">
          <source>Note that using &lt;code&gt;self&lt;/code&gt; in this way might not be necessary in the future; it&amp;rsquo;s an inconsistency in the language that Rust developers are working to eliminate.</source>
          <target state="translated">Обратите внимание, что использование &lt;code&gt;self&lt;/code&gt; таким образом может не понадобиться в будущем; это несоответствие языка, над которым работают разработчики Rust.</target>
        </trans-unit>
        <trans-unit id="d0ff9c8a29cb263c7447b50b428f4e5035b7a3bd" translate="yes" xml:space="preserve">
          <source>Note that using the &lt;code&gt;type&lt;/code&gt; keyword does not work here because &lt;code&gt;type&lt;/code&gt; only introduces a type alias:</source>
          <target state="translated">Обратите внимание, что использование ключевого слова &lt;code&gt;type&lt;/code&gt; здесь не работает, потому что &lt;code&gt;type&lt;/code&gt; вводит только псевдоним типа:</target>
        </trans-unit>
        <trans-unit id="bb6b42394e9bea5f3f448212418ce1a68b9d76c5" translate="yes" xml:space="preserve">
          <source>Note that using these trait methods will result in a heap allocation per-function-call. This is not a significant cost for the vast majority of applications, but should be considered when deciding whether to use this functionality in the public API of a low-level function that is expected to be called millions of times a second.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="96eb45dab421603d86bba0634bd20e8a1fa6f567" translate="yes" xml:space="preserve">
          <source>Note that variants without a manually specified discriminant are numbered from top to bottom starting from 0, so clashes can occur with seemingly unrelated variants.</source>
          <target state="translated">Обратите внимание,что варианты без вручную заданного дискриминанта нумеруются сверху вниз,начиная с 0,поэтому столкновения могут происходить с кажущимися несвязанными между собой вариантами.</target>
        </trans-unit>
        <trans-unit id="76fed75fcc53f6083929938f0584d1d34ef49d4d" translate="yes" xml:space="preserve">
          <source>Note that we added a type annotation here. Because we aren&amp;rsquo;t inserting any values into this vector, Rust doesn&amp;rsquo;t know what kind of elements we intend to store. This is an important point. Vectors are implemented using generics; we&amp;rsquo;ll cover how to use generics with your own types in Chapter 10. For now, know that the &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; type provided by the standard library can hold any type, and when a specific vector holds a specific type, the type is specified within angle brackets. In Listing 8-1, we&amp;rsquo;ve told Rust that the &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; in &lt;code&gt;v&lt;/code&gt; will hold elements of the &lt;code&gt;i32&lt;/code&gt; type.</source>
          <target state="translated">Обратите внимание, что здесь мы добавили аннотацию типа. Поскольку мы не вставляем никаких значений в этот вектор, Rust не знает, какие элементы мы собираемся хранить. Это важный момент. Векторы реализованы с использованием дженериков; мы рассмотрим, как использовать обобщенные типы с вашими собственными типами в главе 10. На данный момент знайте, что тип &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; предоставляемый стандартной библиотекой, может содержать любой тип, а когда конкретный вектор содержит определенный тип, тип будет указаны в угловых скобках. В листинге 8-1 мы сообщили Rust, что &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; в &lt;code&gt;v&lt;/code&gt; будет содержать элементы типа &lt;code&gt;i32&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2c79056cb286ed85ac028f7264150a40f531f9d9" translate="yes" xml:space="preserve">
          <source>Note that we added the &lt;code&gt;case_sensitive&lt;/code&gt; field that holds a Boolean. Next, we need the &lt;code&gt;run&lt;/code&gt; function to check the &lt;code&gt;case_sensitive&lt;/code&gt; field&amp;rsquo;s value and use that to decide whether to call the &lt;code&gt;search&lt;/code&gt; function or the &lt;code&gt;search_case_insensitive&lt;/code&gt; function, as shown in Listing 12-22. Note this still won&amp;rsquo;t compile yet.</source>
          <target state="translated">Обратите внимание, что мы добавили поле &lt;code&gt;case_sensitive&lt;/code&gt; , содержащее логическое значение. Затем нам нужна функция &lt;code&gt;run&lt;/code&gt; , чтобы проверить &lt;code&gt;case_sensitive&lt;/code&gt; поля case_sensitive и использовать его, чтобы решить, вызывать ли функцию &lt;code&gt;search&lt;/code&gt; или функцию &lt;code&gt;search_case_insensitive&lt;/code&gt; , как показано в Листинге 12-22. Обратите внимание, что это еще не компилируется.</target>
        </trans-unit>
        <trans-unit id="d033b37f19d17a68bf9778f4a3805418777a67e9" translate="yes" xml:space="preserve">
          <source>Note that we don&amp;rsquo;t need to mark the resulting &lt;code&gt;split_at_mut&lt;/code&gt; function as &lt;code&gt;unsafe&lt;/code&gt;, and we can call this function from safe Rust. We&amp;rsquo;ve created a safe abstraction to the unsafe code with an implementation of the function that uses &lt;code&gt;unsafe&lt;/code&gt; code in a safe way, because it creates only valid pointers from the data this function has access to.</source>
          <target state="translated">Обратите внимание, что нам не нужно отмечать результирующую функцию &lt;code&gt;split_at_mut&lt;/code&gt; как &lt;code&gt;unsafe&lt;/code&gt; , и мы можем вызвать эту функцию из безопасного Rust. Мы создали безопасную абстракцию небезопасного кода с реализацией функции, которая использует &lt;code&gt;unsafe&lt;/code&gt; код безопасным способом, потому что она создает только действительные указатели из данных, к которым эта функция имеет доступ.</target>
        </trans-unit>
        <trans-unit id="79f8d5116fd5bb5dc0c20baa33c391d983b3d588" translate="yes" xml:space="preserve">
          <source>Note that we have to declare &lt;code&gt;T&lt;/code&gt; just after &lt;code&gt;impl&lt;/code&gt; so we can use it to specify that we&amp;rsquo;re implementing methods on the type &lt;code&gt;Point&amp;lt;T&amp;gt;&lt;/code&gt;. By declaring &lt;code&gt;T&lt;/code&gt; as a generic type after &lt;code&gt;impl&lt;/code&gt;, Rust can identify that the type in the angle brackets in &lt;code&gt;Point&lt;/code&gt; is a generic type rather than a concrete type.</source>
          <target state="translated">Обратите внимание, что мы должны объявить &lt;code&gt;T&lt;/code&gt; сразу после &lt;code&gt;impl&lt;/code&gt; , чтобы мы могли использовать его, чтобы указать, что мы реализуем методы для типа &lt;code&gt;Point&amp;lt;T&amp;gt;&lt;/code&gt; . Объявляя &lt;code&gt;T&lt;/code&gt; как универсальный тип после &lt;code&gt;impl&lt;/code&gt; , Rust может определить, что тип в угловых скобках в &lt;code&gt;Point&lt;/code&gt; является универсальным типом, а не конкретным типом.</target>
        </trans-unit>
        <trans-unit id="21933f931bffb1331e5d307d3ac351285280040d" translate="yes" xml:space="preserve">
          <source>Note that we must use the fully qualified syntax that we talked about earlier in the &lt;a href=&quot;ch19-03-advanced-traits#advanced-traits&quot;&gt;&amp;ldquo;Advanced Traits&amp;rdquo;&lt;/a&gt; section because there are multiple functions available named &lt;code&gt;to_string&lt;/code&gt;. Here, we&amp;rsquo;re using the &lt;code&gt;to_string&lt;/code&gt; function defined in the &lt;code&gt;ToString&lt;/code&gt; trait, which the standard library has implemented for any type that implements &lt;code&gt;Display&lt;/code&gt;.</source>
          <target state="translated">Обратите внимание, что мы должны использовать полностью определенный синтаксис, о котором мы говорили ранее в разделе &lt;a href=&quot;ch19-03-advanced-traits#advanced-traits&quot;&gt;&amp;laquo;Расширенные свойства&amp;raquo;,&lt;/a&gt; потому что доступно несколько функций с именем &lt;code&gt;to_string&lt;/code&gt; . Здесь мы используем функцию &lt;code&gt;to_string&lt;/code&gt; , определенную в трейте &lt;code&gt;ToString&lt;/code&gt; , который стандартная библиотека реализовала для любого типа, реализующего &lt;code&gt;Display&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="096f913e45816f67a5f4300a1107c11162218bda" translate="yes" xml:space="preserve">
          <source>Note that we need lifetime annotations on this method, as we discussed in Chapter 10. We&amp;rsquo;re taking a reference to a &lt;code&gt;post&lt;/code&gt; as an argument and returning a reference to part of that &lt;code&gt;post&lt;/code&gt;, so the lifetime of the returned reference is related to the lifetime of the &lt;code&gt;post&lt;/code&gt; argument.</source>
          <target state="translated">Обратите внимание, что нам нужны аннотации времени жизни для этого метода, как мы обсуждали в главе 10. Мы берем ссылку на &lt;code&gt;post&lt;/code&gt; в качестве аргумента и возвращаем ссылку на часть этого &lt;code&gt;post&lt;/code&gt; , поэтому время жизни возвращенной ссылки связано с время жизни аргумента &lt;code&gt;post&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0a3ac30cf1c59aeb030a71d5cf7a71a2b0dfbcb7" translate="yes" xml:space="preserve">
          <source>Note that we need to first &lt;code&gt;use&lt;/code&gt; the &lt;code&gt;HashMap&lt;/code&gt; from the collections portion of the standard library. Of our three common collections, this one is the least often used, so it&amp;rsquo;s not included in the features brought into scope automatically in the prelude. Hash maps also have less support from the standard library; there&amp;rsquo;s no built-in macro to construct them, for example.</source>
          <target state="translated">Обратите внимание , что мы должны сначала &lt;code&gt;use&lt;/code&gt; в &lt;code&gt;HashMap&lt;/code&gt; из части коллекций стандартной библиотеки. Из трех наших общих коллекций эта используется реже всего, поэтому она не включается в функции, автоматически включенные в область видимости в прелюдии. Хеш-карты также менее поддерживаются стандартной библиотекой; например, нет встроенного макроса для их создания.</target>
        </trans-unit>
        <trans-unit id="5da3fc4decf52dc450c6e612f0f2c00362fc9669" translate="yes" xml:space="preserve">
          <source>Note that we needed the &lt;code&gt;: Vec&amp;lt;i32&amp;gt;&lt;/code&gt; on the left-hand side. This is because we could collect into, for example, a &lt;a href=&quot;../collections/struct.vecdeque&quot;&gt;&lt;code&gt;VecDeque&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt; instead:</source>
          <target state="translated">Обратите внимание, что нам нужен &lt;code&gt;: Vec&amp;lt;i32&amp;gt;&lt;/code&gt; с левой стороны. Это потому, что вместо этого мы могли бы собрать, например, &lt;a href=&quot;../collections/struct.vecdeque&quot;&gt; &lt;code&gt;VecDeque&amp;lt;T&amp;gt;&lt;/code&gt; &lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="75b55fff64dcfe7729e494e2a0b5e033941b67c8" translate="yes" xml:space="preserve">
          <source>Note that we needed to make &lt;code&gt;v1_iter&lt;/code&gt; mutable: calling the &lt;code&gt;next&lt;/code&gt; method on an iterator changes internal state that the iterator uses to keep track of where it is in the sequence. In other words, this code &lt;em&gt;consumes&lt;/em&gt;, or uses up, the iterator. Each call to &lt;code&gt;next&lt;/code&gt; eats up an item from the iterator. We didn&amp;rsquo;t need to make &lt;code&gt;v1_iter&lt;/code&gt; mutable when we used a &lt;code&gt;for&lt;/code&gt; loop because the loop took ownership of &lt;code&gt;v1_iter&lt;/code&gt; and made it mutable behind the scenes.</source>
          <target state="translated">Обратите внимание, что нам нужно было сделать &lt;code&gt;v1_iter&lt;/code&gt; изменяемым: вызов &lt;code&gt;next&lt;/code&gt; метода на итераторе изменяет внутреннее состояние, которое итератор использует для отслеживания того, где он находится в последовательности. Другими словами, этот код &lt;em&gt;потребляет&lt;/em&gt; или использует итератор. Каждый вызов &lt;code&gt;next&lt;/code&gt; съедает элемент из итератора. Нам не нужно было делать &lt;code&gt;v1_iter&lt;/code&gt; изменяемым, когда мы использовали цикл &lt;code&gt;for&lt;/code&gt; , потому что цикл стал владельцем &lt;code&gt;v1_iter&lt;/code&gt; и сделал его изменяемым за кулисами.</target>
        </trans-unit>
        <trans-unit id="5994cd1512c44aaad650a1803fdb7c349136ad1d" translate="yes" xml:space="preserve">
          <source>Note that we want the function to take string slices, which are references, because we don&amp;rsquo;t want the &lt;code&gt;longest&lt;/code&gt; function to take ownership of its parameters. Refer to the &lt;a href=&quot;ch04-03-slices#string-slices-as-parameters&quot;&gt;&amp;ldquo;String Slices as Parameters&amp;rdquo;&lt;/a&gt; section in Chapter 4 for more discussion about why the parameters we use in Listing 10-20 are the ones we want.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5ee6c1ea883902ac8da8cc6969cf6510f9cd8cc8" translate="yes" xml:space="preserve">
          <source>Note that we want the function to take string slices, which are references, because we don&amp;rsquo;t want the &lt;code&gt;longest&lt;/code&gt; function to take ownership of its parameters. We want to allow the function to accept slices of a &lt;code&gt;String&lt;/code&gt; (the type stored in the variable &lt;code&gt;string1&lt;/code&gt;) as well as string literals (which is what variable &lt;code&gt;string2&lt;/code&gt; contains).</source>
          <target state="translated">Обратите внимание, что мы хотим, чтобы функция принимала строковые фрагменты, которые являются ссылками, потому что мы не хотим, чтобы самая &lt;code&gt;longest&lt;/code&gt; функция стала владеть своими параметрами. Мы хотим, чтобы функция могла принимать фрагменты &lt;code&gt;String&lt;/code&gt; (тип, хранящийся в переменной &lt;code&gt;string1&lt;/code&gt; ), а также строковые литералы (которые и содержатся в переменной &lt;code&gt;string2&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="f37dca568a2a5ec6c0b22f134958fd92838997bb" translate="yes" xml:space="preserve">
          <source>Note that we&amp;rsquo;ve added a new line inside the &lt;code&gt;tests&lt;/code&gt; module: &lt;code&gt;use super::*;&lt;/code&gt;. The &lt;code&gt;tests&lt;/code&gt; module is a regular module that follows the usual visibility rules we covered in Chapter 7 in the &lt;a href=&quot;ch07-02-defining-modules-to-control-scope-and-privacy&quot;&gt;&amp;ldquo;Modules as the Privacy Boundary&amp;rdquo;&lt;/a&gt; section. Because the &lt;code&gt;tests&lt;/code&gt; module is an inner module, we need to bring the code under test in the outer module into the scope of the inner module. We use a glob here so anything we define in the outer module is available to this &lt;code&gt;tests&lt;/code&gt; module.</source>
          <target state="translated">Обратите внимание, что мы добавили новую строку в модуль &lt;code&gt;tests&lt;/code&gt; : &lt;code&gt;use super::*;&lt;/code&gt; . Модуль &lt;code&gt;tests&lt;/code&gt; - это обычный модуль, который следует обычным правилам видимости, которые мы рассмотрели в главе 7 в разделе &lt;a href=&quot;ch07-02-defining-modules-to-control-scope-and-privacy&quot;&gt;&amp;laquo;Модули как граница конфиденциальности&amp;raquo;&lt;/a&gt; . Поскольку модуль &lt;code&gt;tests&lt;/code&gt; является внутренним модулем, нам нужно перенести тестируемый код во внешнем модуле в область видимости внутреннего модуля. Здесь мы используем глобус, поэтому все, что мы определяем во внешнем модуле, доступно этому модулю &lt;code&gt;tests&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8e05c11c9aa8615f8372dccd3f7625301eed4295" translate="yes" xml:space="preserve">
          <source>Note that we&amp;rsquo;ve added a new line inside the &lt;code&gt;tests&lt;/code&gt; module: &lt;code&gt;use super::*;&lt;/code&gt;. The &lt;code&gt;tests&lt;/code&gt; module is a regular module that follows the usual visibility rules we covered in Chapter 7 in the &lt;a href=&quot;ch07-03-paths-for-referring-to-an-item-in-the-module-tree&quot;&gt;&amp;ldquo;Paths for Referring to an Item in the Module Tree&amp;rdquo;&lt;/a&gt; section. Because the &lt;code&gt;tests&lt;/code&gt; module is an inner module, we need to bring the code under test in the outer module into the scope of the inner module. We use a glob here so anything we define in the outer module is available to this &lt;code&gt;tests&lt;/code&gt; module.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="26a0be4b24350107b09144aaaa2ad0fb91731191" translate="yes" xml:space="preserve">
          <source>Note that we&amp;rsquo;ve edited the old test&amp;rsquo;s &lt;code&gt;contents&lt;/code&gt; too. We&amp;rsquo;ve added a new line with the text &lt;code&gt;&quot;Duct tape.&quot;&lt;/code&gt; using a capital D that shouldn&amp;rsquo;t match the query &lt;code&gt;&quot;duct&quot;&lt;/code&gt; when we&amp;rsquo;re searching in a case-sensitive manner. Changing the old test in this way helps ensure that we don&amp;rsquo;t accidentally break the case-sensitive search functionality that we&amp;rsquo;ve already implemented. This test should pass now and should continue to pass as we work on the case-insensitive search.</source>
          <target state="translated">Обратите внимание, что мы редактировали и &lt;code&gt;contents&lt;/code&gt; старого теста . Мы добавили новую строку с текстом &lt;code&gt;&quot;Duct tape.&quot;&lt;/code&gt; использование заглавной буквы D, которая не должна соответствовать запросу &lt;code&gt;&quot;duct&quot;&lt;/code&gt; при поиске с учетом регистра. Такое изменение старого теста гарантирует, что мы случайно не нарушим уже реализованную нами функцию поиска с учетом регистра. Этот тест должен пройти сейчас и должен продолжаться, пока мы работаем над поиском без учета регистра.</target>
        </trans-unit>
        <trans-unit id="2e87959963706a5a2e57c9724a365d2a982bba5d" translate="yes" xml:space="preserve">
          <source>Note that when the wildcard &lt;code&gt;*&lt;/code&gt; is used on a type, it does not import its methods (though for &lt;code&gt;enum&lt;/code&gt;s it imports the variants, as shown in the example below).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2b7bbbf14e1bc0dbc3662e9181bd406f83393130" translate="yes" xml:space="preserve">
          <source>Note that where ties occur, &lt;a href=&quot;../vec/struct.vec&quot;&gt;&lt;code&gt;Vec&lt;/code&gt;&lt;/a&gt; is generally going to be faster than &lt;a href=&quot;struct.vecdeque&quot;&gt;&lt;code&gt;VecDeque&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;struct.vecdeque&quot;&gt;&lt;code&gt;VecDeque&lt;/code&gt;&lt;/a&gt; is generally going to be faster than &lt;a href=&quot;struct.linkedlist&quot;&gt;&lt;code&gt;LinkedList&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Обратите внимание, что там, где возникают связи, &lt;a href=&quot;../vec/struct.vec&quot;&gt; &lt;code&gt;Vec&lt;/code&gt; &lt;/a&gt; обычно будет быстрее, чем &lt;a href=&quot;struct.vecdeque&quot;&gt; &lt;code&gt;VecDeque&lt;/code&gt; &lt;/a&gt; , а &lt;a href=&quot;struct.vecdeque&quot;&gt; &lt;code&gt;VecDeque&lt;/code&gt; &lt;/a&gt; обычно будет быстрее, чем &lt;a href=&quot;struct.linkedlist&quot;&gt; &lt;code&gt;LinkedList&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="b62f50352e9e786c961cd72638314895b5c9fdfc" translate="yes" xml:space="preserve">
          <source>Note that while concurrent access to environment variables is safe in Rust, some platforms only expose inherently unsafe non-threadsafe APIs for inspecting the environment. As a result extra care needs to be taken when auditing calls to unsafe external FFI functions to ensure that any external environment accesses are properly synchronized with accesses in Rust.</source>
          <target state="translated">Обратите внимание,что хотя параллельный доступ к переменным окружения безопасен в Rust,на некоторых платформах для проверки окружения могут использоваться только небезопасные,по своей сути,не-потокобезопасные API.В результате,при проверке вызовов небезопасных внешних FFI-функций необходимо проявлять дополнительную осторожность,чтобы убедиться в том,что любой доступ к внешней среде корректно синхронизирован с доступом в Rust.</target>
        </trans-unit>
        <trans-unit id="d3954c01ae7015c1edc03c422ae6922dcf56ba11" translate="yes" xml:space="preserve">
          <source>Note that while concurrent access to environment variables is safe in Rust, some platforms only expose inherently unsafe non-threadsafe APIs for inspecting the environment. As a result, extra care needs to be taken when auditing calls to unsafe external FFI functions to ensure that any external environment accesses are properly synchronized with accesses in Rust.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="324300377b3c3f353b3f11bc282603959b1e1422" translate="yes" xml:space="preserve">
          <source>Note that while mutating or mutably aliasing the contents of an &lt;code&gt;&amp;amp;UnsafeCell&amp;lt;T&amp;gt;&lt;/code&gt; is ok (provided you enforce the invariants some other way), it is still undefined behavior to have multiple &lt;code&gt;&amp;amp;mut UnsafeCell&amp;lt;T&amp;gt;&lt;/code&gt; aliases.</source>
          <target state="translated">Обратите внимание, что при изменении или изменяемом псевдониме содержимого &lt;code&gt;&amp;amp;UnsafeCell&amp;lt;T&amp;gt;&lt;/code&gt; все в порядке (при условии, что вы принудительно применяете инварианты каким-либо другим способом), наличие нескольких псевдонимов &lt;code&gt;&amp;amp;mut UnsafeCell&amp;lt;T&amp;gt;&lt;/code&gt; прежнему является неопределенным поведением .</target>
        </trans-unit>
        <trans-unit id="f5bec177fd61b6b3b97ae7f2a117594bad43deaa" translate="yes" xml:space="preserve">
          <source>Note that whilst mutating the contents of an &lt;code&gt;&amp;amp;UnsafeCell&amp;lt;T&amp;gt;&lt;/code&gt; (even while other &lt;code&gt;&amp;amp;UnsafeCell&amp;lt;T&amp;gt;&lt;/code&gt; references alias the cell) is ok (provided you enforce the above invariants some other way), it is still undefined behavior to have multiple &lt;code&gt;&amp;amp;mut UnsafeCell&amp;lt;T&amp;gt;&lt;/code&gt; aliases. That is, &lt;code&gt;UnsafeCell&lt;/code&gt; is a wrapper designed to have a special interaction with &lt;em&gt;shared&lt;/em&gt; accesses (&lt;em&gt;i.e.&lt;/em&gt;, through an &lt;code&gt;&amp;amp;UnsafeCell&amp;lt;_&amp;gt;&lt;/code&gt; reference); there is no magic whatsoever when dealing with &lt;em&gt;exclusive&lt;/em&gt; accesses (&lt;em&gt;e.g.&lt;/em&gt;, through an &lt;code&gt;&amp;amp;mut UnsafeCell&amp;lt;_&amp;gt;&lt;/code&gt;): neither the cell nor the wrapped value may be aliased for the duration of that &lt;code&gt;&amp;amp;mut&lt;/code&gt; borrow. This is showcased by the &lt;a href=&quot;struct.unsafecell#method.get_mut&quot;&gt;&lt;code&gt;.get_mut()&lt;/code&gt;&lt;/a&gt; accessor, which is a &lt;em&gt;safe&lt;/em&gt; getter that yields a &lt;code&gt;&amp;amp;mut T&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9eb90457458f8170cc06094675d04f9c0e8116dd" translate="yes" xml:space="preserve">
          <source>Note that whilst mutating the contents of an &lt;code&gt;&amp;amp;UnsafeCell&amp;lt;T&amp;gt;&lt;/code&gt; (even while other &lt;code&gt;&amp;amp;UnsafeCell&amp;lt;T&amp;gt;&lt;/code&gt; references alias the cell) is ok (provided you enforce the above invariants some other way), it is still undefined behavior to have multiple &lt;code&gt;&amp;amp;mut UnsafeCell&amp;lt;T&amp;gt;&lt;/code&gt; aliases. That is, &lt;code&gt;UnsafeCell&lt;/code&gt; is a wrapper designed to have a special interaction with &lt;em&gt;shared&lt;/em&gt; accesses (&lt;em&gt;i.e.&lt;/em&gt;, through an &lt;code&gt;&amp;amp;UnsafeCell&amp;lt;_&amp;gt;&lt;/code&gt; reference); there is no magic whatsoever when dealing with &lt;em&gt;exclusive&lt;/em&gt; accesses (&lt;em&gt;e.g.&lt;/em&gt;, through an &lt;code&gt;&amp;amp;mut UnsafeCell&amp;lt;_&amp;gt;&lt;/code&gt;): neither the cell nor the wrapped value may be aliased for the duration of that &lt;code&gt;&amp;amp;mut&lt;/code&gt; borrow. This is showcased by the &lt;a href=&quot;struct.unsafecell#method.get_mut&quot;&gt;&lt;code&gt;.get_mut()&lt;/code&gt;&lt;/a&gt; accessor, which is a non-&lt;code&gt;unsafe&lt;/code&gt; getter that yields a &lt;code&gt;&amp;amp;mut T&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7ea0c44d2eb4a19014b1a6e779035e8b52686247" translate="yes" xml:space="preserve">
          <source>Note that with this function, the new thread will be stopped when the main thread ends, whether or not it has finished running. The output from this program might be a little different every time, but it will look similar to the following:</source>
          <target state="translated">Обратите внимание,что с помощью этой функции новый поток будет остановлен,когда основной поток завершит свою работу,независимо от того,завершился он или нет.Выходная информация из этой программы может каждый раз немного отличаться,но она будет выглядеть так,как показано ниже:</target>
        </trans-unit>
        <trans-unit id="499913d6f995a629a9ad09275a1ae60af65eff00" translate="yes" xml:space="preserve">
          <source>Note that writing updates the slice to point to the yet unwritten part. The slice will be empty when it has been completely overwritten.</source>
          <target state="translated">Обратите внимание,что запись обновляет фрагмент,указывая на еще не написанную часть.Кусок будет пустым,когда он будет полностью переписан.</target>
        </trans-unit>
        <trans-unit id="30da6e410f76967402353bb250335b332eb88eb5" translate="yes" xml:space="preserve">
          <source>Note that you cannot use the &lt;a href=&quot;../../book/appendix-02-operators&quot;&gt;&lt;code&gt;?&lt;/code&gt; operator&lt;/a&gt; in functions that do not return a &lt;a href=&quot;../result/enum.result&quot;&gt;&lt;code&gt;Result&amp;lt;T, E&amp;gt;&lt;/code&gt;&lt;/a&gt;. Instead, you can call &lt;a href=&quot;../result/enum.result#method.unwrap&quot;&gt;&lt;code&gt;.unwrap()&lt;/code&gt;&lt;/a&gt; or &lt;code&gt;match&lt;/code&gt; on the return value to catch any possible errors:</source>
          <target state="translated">Обратите внимание, что вы не можете использовать &lt;a href=&quot;../../book/appendix-02-operators&quot;&gt; &lt;code&gt;?&lt;/code&gt; оператор&lt;/a&gt; в функциях, которые не возвращают &lt;a href=&quot;../result/enum.result&quot;&gt; &lt;code&gt;Result&amp;lt;T, E&amp;gt;&lt;/code&gt; &lt;/a&gt; . Вместо этого вы можете вызвать &lt;a href=&quot;../result/enum.result#method.unwrap&quot;&gt; &lt;code&gt;.unwrap()&lt;/code&gt; &lt;/a&gt; или &lt;code&gt;match&lt;/code&gt; возвращаемое значение, чтобы отловить любые возможные ошибки:</target>
        </trans-unit>
        <trans-unit id="8cd9969c1871eeacc0200593b93cdcffbccf3e66" translate="yes" xml:space="preserve">
          <source>Note that, although read and write methods require a &lt;code&gt;&amp;amp;mut File&lt;/code&gt;, because of the interfaces for &lt;a href=&quot;../io/trait.read&quot;&gt;&lt;code&gt;Read&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../io/trait.write&quot;&gt;&lt;code&gt;Write&lt;/code&gt;&lt;/a&gt;, the holder of a &lt;code&gt;&amp;amp;File&lt;/code&gt; can still modify the file, either through methods that take &lt;code&gt;&amp;amp;File&lt;/code&gt; or by retrieving the underlying OS object and modifying the file that way. Additionally, many operating systems allow concurrent modification of files by different processes. Avoid assuming that holding a &lt;code&gt;&amp;amp;File&lt;/code&gt; means that the file will not change.</source>
          <target state="translated">Обратите внимание, что хотя для методов чтения и записи требуется &lt;code&gt;&amp;amp;mut File&lt;/code&gt; , из-за интерфейсов для &lt;a href=&quot;../io/trait.read&quot;&gt; &lt;code&gt;Read&lt;/code&gt; &lt;/a&gt; и &lt;a href=&quot;../io/trait.write&quot;&gt; &lt;code&gt;Write&lt;/code&gt; &lt;/a&gt; владелец &lt;code&gt;&amp;amp;File&lt;/code&gt; может по-прежнему изменять файл либо с помощью методов, которые принимают &lt;code&gt;&amp;amp;File&lt;/code&gt; либо путем извлечения базового объекта ОС и изменения файла. туда. Кроме того, многие операционные системы допускают одновременное изменение файлов разными процессами. Не предполагайте, что наличие &lt;code&gt;&amp;amp;File&lt;/code&gt; означает, что файл не изменится.</target>
        </trans-unit>
        <trans-unit id="1d0cf8461e762586f36c776928c774ad1d9122e5" translate="yes" xml:space="preserve">
          <source>Note that, because &lt;code&gt;$crate&lt;/code&gt; refers to the current crate, it must be used with a fully qualified module path when referring to non-macro items:</source>
          <target state="translated">Обратите внимание, что, поскольку &lt;code&gt;$crate&lt;/code&gt; относится к текущему ящику, он должен использоваться с полным путем к модулю при обращении к элементам, не относящимся к макросам:</target>
        </trans-unit>
        <trans-unit id="160864ae0e83232cc21d9f02b2b16fec0e686a4e" translate="yes" xml:space="preserve">
          <source>Note that, like the &lt;code&gt;Option&lt;/code&gt; enum, the &lt;code&gt;Result&lt;/code&gt; enum and its variants have been brought into scope by the prelude, so we don&amp;rsquo;t need to specify &lt;code&gt;Result::&lt;/code&gt; before the &lt;code&gt;Ok&lt;/code&gt; and &lt;code&gt;Err&lt;/code&gt; variants in the &lt;code&gt;match&lt;/code&gt; arms.</source>
          <target state="translated">Обратите внимание, что, как и перечисление &lt;code&gt;Option&lt;/code&gt; , перечисление &lt;code&gt;Result&lt;/code&gt; и его варианты были включены в область действия прелюдией, поэтому нам не нужно указывать &lt;code&gt;Result::&lt;/code&gt; перед вариантами &lt;code&gt;Ok&lt;/code&gt; и &lt;code&gt;Err&lt;/code&gt; в ответвлениях &lt;code&gt;match&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="669f2ea820772978e72d4c3d94e7389c9756f1a1" translate="yes" xml:space="preserve">
          <source>Note that, this &lt;a href=&quot;../io/index#platform-specific-behavior&quot;&gt;may change in the future&lt;/a&gt;.</source>
          <target state="translated">Обратите внимание, что это &lt;a href=&quot;../io/index#platform-specific-behavior&quot;&gt;может измениться в будущем&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="169cf16d0a1c963eafd20679aea07a420f4eaf39" translate="yes" xml:space="preserve">
          <source>Note that, unlike &lt;code&gt;repeat&lt;/code&gt;, &lt;code&gt;repeat_packed&lt;/code&gt; does not guarantee that the repeated instances of &lt;code&gt;self&lt;/code&gt; will be properly aligned, even if a given instance of &lt;code&gt;self&lt;/code&gt; is properly aligned. In other words, if the layout returned by &lt;code&gt;repeat_packed&lt;/code&gt; is used to allocate an array, it is not guaranteed that all elements in the array will be properly aligned.</source>
          <target state="translated">Обратите внимание, что, в отличие от &lt;code&gt;repeat&lt;/code&gt; , &lt;code&gt;repeat_packed&lt;/code&gt; не гарантирует, что повторяющиеся экземпляры &lt;code&gt;self&lt;/code&gt; будут правильно выровнены, даже если данный экземпляр &lt;code&gt;self&lt;/code&gt; правильно выровнен. Другими словами, если макет, возвращаемый &lt;code&gt;repeat_packed&lt;/code&gt; , используется для выделения массива, не гарантируется, что все элементы в массиве будут правильно выровнены.</target>
        </trans-unit>
        <trans-unit id="285f98e8d01e4962eff6724b78a3c6724d0931e6" translate="yes" xml:space="preserve">
          <source>Note that:</source>
          <target state="translated">Обратите внимание:</target>
        </trans-unit>
        <trans-unit id="fc7308ef65a4b47d9c6953435d548f4e965b07bd" translate="yes" xml:space="preserve">
          <source>Note the documentation for the primitives &lt;a href=&quot;https://doc.rust-lang.org/nightly/std/primitive.str.html&quot;&gt;&lt;code&gt;str&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;slice/index&quot;&gt;&lt;code&gt;[T]&lt;/code&gt;&lt;/a&gt; (also called 'slice'). Many method calls on &lt;a href=&quot;string/struct.string&quot;&gt;&lt;code&gt;String&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;vec/struct.vec&quot;&gt;&lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt; are actually calls to methods on &lt;a href=&quot;https://doc.rust-lang.org/nightly/std/primitive.str.html&quot;&gt;&lt;code&gt;str&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;slice/index&quot;&gt;&lt;code&gt;[T]&lt;/code&gt;&lt;/a&gt; respectively, via &lt;a href=&quot;../book/ch15-02-deref#implicit-deref-coercions-with-functions-and-methods&quot;&gt;deref coercions&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d6d8fcef27cc36a94771021effc9ea114018af44" translate="yes" xml:space="preserve">
          <source>Note the documentation for the primitives &lt;a href=&quot;primitive.str&quot;&gt;&lt;code&gt;str&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;primitive.slice&quot;&gt;&lt;code&gt;[T]&lt;/code&gt;&lt;/a&gt; (also called 'slice'). Many method calls on &lt;a href=&quot;string/struct.string&quot;&gt;&lt;code&gt;String&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;vec/index&quot;&gt;&lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt; are actually calls to methods on &lt;a href=&quot;primitive.str&quot;&gt;&lt;code&gt;str&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;primitive.slice&quot;&gt;&lt;code&gt;[T]&lt;/code&gt;&lt;/a&gt; respectively, via &lt;a href=&quot;../book/ch15-02-deref#implicit-deref-coercions-with-functions-and-methods&quot;&gt;deref coercions&lt;/a&gt;.</source>
          <target state="translated">Обратите внимание на документацию для примитивов &lt;a href=&quot;primitive.str&quot;&gt; &lt;code&gt;str&lt;/code&gt; &lt;/a&gt; и &lt;a href=&quot;primitive.slice&quot;&gt; &lt;code&gt;[T]&lt;/code&gt; &lt;/a&gt; (также называемых &amp;laquo;срез&amp;raquo;). Многие вызовы методов на &lt;a href=&quot;string/struct.string&quot;&gt; &lt;code&gt;String&lt;/code&gt; &lt;/a&gt; и &lt;a href=&quot;vec/index&quot;&gt; &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; &lt;/a&gt; на самом деле являются вызовами методов на &lt;a href=&quot;primitive.str&quot;&gt; &lt;code&gt;str&lt;/code&gt; &lt;/a&gt; и &lt;a href=&quot;primitive.slice&quot;&gt; &lt;code&gt;[T]&lt;/code&gt; &lt;/a&gt; соответственно посредством приведения &lt;a href=&quot;../book/ch15-02-deref#implicit-deref-coercions-with-functions-and-methods&quot;&gt;deref&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="9ca3cd3caadb8f1bb227db05f6c5c7202e5bbf2b" translate="yes" xml:space="preserve">
          <source>Note to Implementors</source>
          <target state="translated">Примечание для исполнителей</target>
        </trans-unit>
        <trans-unit id="c4cf4c3bcaeb43c85321fdb977bbc1c650a58e54" translate="yes" xml:space="preserve">
          <source>Note to implementors: If this returns &lt;code&gt;Ok(ptr)&lt;/code&gt;, then &lt;code&gt;ptr&lt;/code&gt; must be considered &quot;currently allocated&quot; and must be acceptable input to methods such as &lt;code&gt;realloc&lt;/code&gt; or &lt;code&gt;dealloc&lt;/code&gt;, &lt;em&gt;even if&lt;/em&gt;&lt;code&gt;T&lt;/code&gt; is a zero-sized type. In other words, if your &lt;code&gt;Alloc&lt;/code&gt; implementation overrides this method in a manner that can return a zero-sized &lt;code&gt;ptr&lt;/code&gt;, then all reallocation and deallocation methods need to be similarly overridden to accept such values as input.</source>
          <target state="translated">Примечание для разработчиков: если это возвращает &lt;code&gt;Ok(ptr)&lt;/code&gt; , тогда &lt;code&gt;ptr&lt;/code&gt; должен считаться &amp;laquo;выделенным в данный момент&amp;raquo; и должен быть приемлемым вводом для таких методов, как &lt;code&gt;realloc&lt;/code&gt; или &lt;code&gt;dealloc&lt;/code&gt; , &lt;em&gt;даже если &lt;/em&gt; &lt;code&gt;T&lt;/code&gt; является типом нулевого размера. Другими словами, если ваша реализация &lt;code&gt;Alloc&lt;/code&gt; переопределяет этот метод таким образом, чтобы он мог возвращать &lt;code&gt;ptr&lt;/code&gt; нулевого размера , то все методы перераспределения и освобождения должны быть аналогичным образом переопределены, чтобы принимать такие значения в качестве входных.</target>
        </trans-unit>
        <trans-unit id="eb0cc1533f57d8d34b3b5bb324e9cedcd986a56b" translate="yes" xml:space="preserve">
          <source>Note two details here. First, we use the index value of &lt;code&gt;2&lt;/code&gt; to get the third element: vectors are indexed by number, starting at zero. Second, the two ways to get the third element are by using &lt;code&gt;&amp;amp;&lt;/code&gt; and &lt;code&gt;[]&lt;/code&gt;, which gives us a reference, or by using the &lt;code&gt;get&lt;/code&gt; method with the index passed as an argument, which gives us an &lt;code&gt;Option&amp;lt;&amp;amp;T&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">Обратите внимание на две детали здесь. Во-первых, мы используем значение индекса &lt;code&gt;2&lt;/code&gt; , чтобы получить третий элемент: векторы индексируются по номерам, начиная с нуля. Во-вторых, получить третий элемент можно двумя способами: с помощью &lt;code&gt;&amp;amp;&lt;/code&gt; и &lt;code&gt;[]&lt;/code&gt; , что дает нам ссылку, или с помощью метода &lt;code&gt;get&lt;/code&gt; с индексом, переданным в качестве аргумента, который дает нам &lt;code&gt;Option&amp;lt;&amp;amp;T&amp;gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3c6f9d9871d6089da68d73e5351d58428691fe43" translate="yes" xml:space="preserve">
          <source>Note, &lt;code&gt;OsString&lt;/code&gt; and &lt;a href=&quot;struct.osstr&quot;&gt;&lt;code&gt;OsStr&lt;/code&gt;&lt;/a&gt; internally do not necessarily hold strings in the form native to the platform; While on Unix, strings are stored as a sequence of 8-bit values, on Windows, where strings are 16-bit value based as just discussed, strings are also actually stored as a sequence of 8-bit values, encoded in a less-strict variant of UTF-8. This is useful to understand when handling capacity and length values.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c01e48a0e7e3eba8ed1aa3834f9c910b228bd638" translate="yes" xml:space="preserve">
          <source>Note, &lt;code&gt;OsString&lt;/code&gt; and &lt;code&gt;OsStr&lt;/code&gt; internally do not necessarily hold strings in the form native to the platform; While on Unix, strings are stored as a sequence of 8-bit values, on Windows, where strings are 16-bit value based as just discussed, strings are also actually stored as a sequence of 8-bit values, encoded in a less-strict variant of UTF-8. This is useful to understand when handling capacity and length values.</source>
          <target state="translated">Обратите внимание, что &lt;code&gt;OsString&lt;/code&gt; и &lt;code&gt;OsStr&lt;/code&gt; внутри не обязательно содержат строки в форме , присущей платформе; В то время как в Unix строки хранятся как последовательность 8-битных значений, в Windows, где строки представляют собой 16-битные значения на основе, как только что обсуждалось, строки также фактически хранятся как последовательность 8-битных значений, закодированных в менее строгий вариант UTF-8. Это полезно понимать при работе со значениями емкости и длины.</target>
        </trans-unit>
        <trans-unit id="1b6562c6a35d081cb513ca527b316f894645e45c" translate="yes" xml:space="preserve">
          <source>Note, however, that instants are not guaranteed to be &lt;strong&gt;steady&lt;/strong&gt;. In other words, each tick of the underlying clock may not be the same length (e.g. some seconds may be longer than others). An instant may jump forwards or experience time dilation (slow down or speed up), but it will never go backwards.</source>
          <target state="translated">Однако следует отметить, что моменты не гарантированно &lt;strong&gt;устойчивым&lt;/strong&gt; . Другими словами, каждый тик базовых часов может быть разной длины (например, некоторые секунды могут быть длиннее других). Мгновение может перескочить вперед или испытать замедление времени (замедление или ускорение), но оно никогда не вернется назад.</target>
        </trans-unit>
        <trans-unit id="9fd9dfc12db2bc0dbc56fcf4d3cda55381327924" translate="yes" xml:space="preserve">
          <source>Note, however, that items with the same name are allowed for inherent &lt;code&gt;impl&lt;/code&gt; blocks that don't overlap:</source>
          <target state="translated">Обратите внимание, однако, что элементы с тем же именем разрешены для &lt;code&gt;impl&lt;/code&gt; блоков impl, которые не перекрываются:</target>
        </trans-unit>
        <trans-unit id="bba68cd3cf8ae8ea0e35e174666c8e34f0cdd55c" translate="yes" xml:space="preserve">
          <source>Note, however, that this is not an unsafe trait, so there is not a succinct contract that this trait is providing. Instead it is intended as more of a &quot;speed bump&quot; to alert users of &lt;code&gt;catch_unwind&lt;/code&gt; that broken invariants may be witnessed and may need to be accounted for.</source>
          <target state="translated">Обратите внимание, однако, что это не небезопасная черта, поэтому не существует краткого контракта, предоставляемого этой чертой. Вместо этого он предназначен скорее как &amp;laquo; &lt;code&gt;catch_unwind&lt;/code&gt; &amp;raquo;, чтобы предупредить пользователей catch_unwind о том, что нарушенные инварианты могут быть засвидетельствованы и, возможно, необходимо учитывать.</target>
        </trans-unit>
        <trans-unit id="d9f40e0b31d5319e2e2946733cad557830f8c197" translate="yes" xml:space="preserve">
          <source>Note, in many cases, the &lt;code&gt;.parse()&lt;/code&gt; method on &lt;code&gt;str&lt;/code&gt; is more proper.</source>
          <target state="translated">Обратите внимание, что во многих случаях метод &lt;code&gt;.parse()&lt;/code&gt; для &lt;code&gt;str&lt;/code&gt; является более подходящим.</target>
        </trans-unit>
        <trans-unit id="83423c198b6099edba08f185f940042d5dba3b79" translate="yes" xml:space="preserve">
          <source>Note:</source>
          <target state="translated">Note:</target>
        </trans-unit>
        <trans-unit id="74d10a535a759833af93c81cb97d5c0957382347" translate="yes" xml:space="preserve">
          <source>Note: &lt;code&gt;Pin&lt;/code&gt; also implements &lt;code&gt;Deref&lt;/code&gt; to the target, which can be used to access the inner value. However, &lt;code&gt;Deref&lt;/code&gt; only provides a reference that lives for as long as the borrow of the &lt;code&gt;Pin&lt;/code&gt;, not the lifetime of the &lt;code&gt;Pin&lt;/code&gt; itself. This method allows turning the &lt;code&gt;Pin&lt;/code&gt; into a reference with the same lifetime as the original &lt;code&gt;Pin&lt;/code&gt;.</source>
          <target state="translated">Примечание: &lt;code&gt;Pin&lt;/code&gt; также реализует &lt;code&gt;Deref&lt;/code&gt; для цели, которая может использоваться для доступа к внутреннему значению. Однако &lt;code&gt;Deref&lt;/code&gt; предоставляет только ссылку, которая живет до тех пор, пока заимствована &lt;code&gt;Pin&lt;/code&gt; , а не время жизни самого &lt;code&gt;Pin&lt;/code&gt; . Этот метод позволяет превратить &lt;code&gt;Pin&lt;/code&gt; в ссылку с таким же сроком службы, что и исходный &lt;code&gt;Pin&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e10aafb3dc6afa8d8827646e5b1be7126b35103b" translate="yes" xml:space="preserve">
          <source>Note: &lt;code&gt;Pin&lt;/code&gt; also implements &lt;code&gt;DerefMut&lt;/code&gt; to the data, which can be used to access the inner value. However, &lt;code&gt;DerefMut&lt;/code&gt; only provides a reference that lives for as long as the borrow of the &lt;code&gt;Pin&lt;/code&gt;, not the lifetime of the &lt;code&gt;Pin&lt;/code&gt; itself. This method allows turning the &lt;code&gt;Pin&lt;/code&gt; into a reference with the same lifetime as the original &lt;code&gt;Pin&lt;/code&gt;.</source>
          <target state="translated">Примечание. &lt;code&gt;Pin&lt;/code&gt; также реализует &lt;code&gt;DerefMut&lt;/code&gt; для данных, которые можно использовать для доступа к внутреннему значению. Однако &lt;code&gt;DerefMut&lt;/code&gt; предоставляет только ссылку, которая живет до тех пор, пока заимствована &lt;code&gt;Pin&lt;/code&gt; , а не время жизни самого &lt;code&gt;Pin&lt;/code&gt; . Этот метод позволяет превратить &lt;code&gt;Pin&lt;/code&gt; в ссылку с таким же сроком службы, что и исходный &lt;code&gt;Pin&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="fe08fa35bb3e2ac30191647bef4f566cd6842a4b" translate="yes" xml:space="preserve">
          <source>Note: &lt;code&gt;core&lt;/code&gt; provides &lt;a href=&quot;https://doc.rust-lang.org/core/panic/struct.Location.html#method.caller&quot;&gt;&lt;code&gt;core::panic::Location::caller&lt;/code&gt;&lt;/a&gt; for observing caller locations. It wraps the &lt;a href=&quot;https://doc.rust-lang.org/core/intrinsics/fn.caller_location.html&quot;&gt;&lt;code&gt;core::intrinsics::caller_location&lt;/code&gt;&lt;/a&gt; intrinsic implemented by &lt;code&gt;rustc&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="da175d20fbd0f82cb13b82934a46d444a5435526" translate="yes" xml:space="preserve">
          <source>Note: &lt;code&gt;fold()&lt;/code&gt;, and similar methods that traverse the entire iterator, may not terminate for infinite iterators, even on traits for which a result is determinable in finite time.</source>
          <target state="translated">Примечание: &lt;code&gt;fold()&lt;/code&gt; и аналогичные методы, которые проходят через весь итератор, могут не завершаться для бесконечных итераторов, даже для признаков, для которых результат можно определить за конечное время.</target>
        </trans-unit>
        <trans-unit id="e47db031d7d5048ad3ea3101c6bbce09857b0d75" translate="yes" xml:space="preserve">
          <source>Note: &lt;code&gt;move&lt;/code&gt; closures may still implement &lt;a href=&quot;../../std/ops/trait.fn&quot;&gt;&lt;code&gt;Fn&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;../../std/ops/trait.fnmut&quot;&gt;&lt;code&gt;FnMut&lt;/code&gt;&lt;/a&gt;, even though they capture variables by move. This is because the traits implemented by a closure type are determined by what the closure does with captured values, not how it captures them.</source>
          <target state="translated">Примечание: замыкания &lt;code&gt;move&lt;/code&gt; могут по-прежнему реализовывать &lt;a href=&quot;../../std/ops/trait.fn&quot;&gt; &lt;code&gt;Fn&lt;/code&gt; &lt;/a&gt; или &lt;a href=&quot;../../std/ops/trait.fnmut&quot;&gt; &lt;code&gt;FnMut&lt;/code&gt; &lt;/a&gt; , даже если они захватывают переменные перемещением. Это связано с тем, что свойства, реализуемые типом замыкания, определяются тем, что замыкание делает с захваченными значениями, а не тем, как оно их захватывает.</target>
        </trans-unit>
        <trans-unit id="ddaee189fcb99b6fc9ed6acd8de34bd62f953e86" translate="yes" xml:space="preserve">
          <source>Note: &lt;code&gt;move&lt;/code&gt; closures may still implement &lt;a href=&quot;ops/trait.fn&quot;&gt;&lt;code&gt;Fn&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;ops/trait.fnmut&quot;&gt;&lt;code&gt;FnMut&lt;/code&gt;&lt;/a&gt;, even though they capture variables by &lt;code&gt;move&lt;/code&gt;. This is because the traits implemented by a closure type are determined by &lt;em&gt;what&lt;/em&gt; the closure does with captured values, not &lt;em&gt;how&lt;/em&gt; it captures them:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="153802f008ce0ac25a19e7452c9f21a823543a00" translate="yes" xml:space="preserve">
          <source>Note: &lt;code&gt;move&lt;/code&gt; closures may still implement &lt;code&gt;Fn&lt;/code&gt; or &lt;code&gt;FnMut&lt;/code&gt;, even though they capture variables by move. This is because the traits implemented by a closure type are determined by what the closure does with captured values, not how it captures them. The &lt;code&gt;move&lt;/code&gt; keyword only specifies the latter.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="690213e0deea1a6806299e07c579a3daee97b81a" translate="yes" xml:space="preserve">
          <source>Note: &lt;code&gt;rustc&lt;/code&gt; currently recognizes the tools &quot;clippy&quot; and &quot;rustfmt&quot;.</source>
          <target state="translated">Примечание: в настоящее время &lt;code&gt;rustc&lt;/code&gt; распознает инструменты clippy и rustfmt.</target>
        </trans-unit>
        <trans-unit id="16697ad37b7a39052ef81a40c40ae4ac1a88fc27" translate="yes" xml:space="preserve">
          <source>Note: &lt;code&gt;rustc&lt;/code&gt; has a default set of features enabled for each target and CPU. The CPU may be chosen with the &lt;a href=&quot;https://doc.rust-lang.org/rustc/codegen-options/index.html#target-cpu&quot;&gt;&lt;code&gt;-C target-cpu&lt;/code&gt;&lt;/a&gt; flag. Individual features may be enabled or disabled for an entire crate with the &lt;a href=&quot;https://doc.rust-lang.org/rustc/codegen-options/index.html#target-feature&quot;&gt;&lt;code&gt;-C target-feature&lt;/code&gt;&lt;/a&gt; flag.</source>
          <target state="translated">Примечание: &lt;code&gt;rustc&lt;/code&gt; имеет набор функций по умолчанию, включенных для каждой цели и процессора. ЦП можно выбрать с помощью флага &lt;a href=&quot;https://doc.rust-lang.org/rustc/codegen-options/index.html#target-cpu&quot;&gt; &lt;code&gt;-C target-cpu&lt;/code&gt; &lt;/a&gt; . Отдельные функции могут быть включены или отключены для всего ящика с помощью флага &lt;a href=&quot;https://doc.rust-lang.org/rustc/codegen-options/index.html#target-feature&quot;&gt; &lt;code&gt;-C target-feature&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="3f9c395bf29ddc7654449b79d4dc0411e7becef5" translate="yes" xml:space="preserve">
          <source>Note: &lt;code&gt;str&lt;/code&gt; in &lt;code&gt;Concat&amp;lt;str&amp;gt;&lt;/code&gt; is not meaningful here. This type parameter of the trait only exists to enable another impl.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c0d79cac345f205a82618d9422d71b4ef0b8bd13" translate="yes" xml:space="preserve">
          <source>Note: &lt;code&gt;union&lt;/code&gt;s with non-&lt;code&gt;Copy&lt;/code&gt; fields are unstable, see &lt;a href=&quot;https://github.com/rust-lang/rust/issues/55149&quot;&gt;55149&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="03f067cb5c2a75451afd3b78affad51470bfd979" translate="yes" xml:space="preserve">
          <source>Note: A saying you might hear about languages with strict compilers, such as Haskell and Rust, is &amp;ldquo;if the code compiles, it works.&amp;rdquo; But this saying is not universally true. Our project compiles, but it does absolutely nothing! If we were building a real, complete project, this would be a good time to start writing unit tests to check that the code compiles &lt;em&gt;and&lt;/em&gt; has the behavior we want.</source>
          <target state="translated">Примечание. О языках со строгими компиляторами, таких как Haskell и Rust, можно услышать поговорку: &amp;laquo;Если код компилируется, он работает&amp;raquo;. Но это высказывание не всегда верно. Наш проект компилируется, но ничего не делает! Если бы мы создавали настоящий, законченный проект, это было бы хорошее время, чтобы начать писать модульные тесты, чтобы проверить, компилируется ли код &lt;em&gt;и&lt;/em&gt; имеет ли он желаемое поведение.</target>
        </trans-unit>
        <trans-unit id="84c66645b448fa01124ab16b053b24421063478c" translate="yes" xml:space="preserve">
          <source>Note: Although Rust, like any other language, can be implemented by an interpreter as well as a compiler, the only existing implementation is a compiler, and the language has always been designed to be compiled. For these reasons, this section assumes a compiler.</source>
          <target state="translated">Замечание:Хотя Rust,как и любой другой язык,может быть реализован как интерпретатором,так и компилятором,единственная существующая реализация-это компилятор,и язык всегда разрабатывался для компиляции.По этим причинам в данном разделе предполагается компилятор.</target>
        </trans-unit>
        <trans-unit id="549bd43e93414c7d2e6a9dbfe6f61cd7449ba2c8" translate="yes" xml:space="preserve">
          <source>Note: As a consequence of the representation being an attribute on the item, the representation does not depend on generic parameters. Any two types with the same name have the same representation. For example, &lt;code&gt;Foo&amp;lt;Bar&amp;gt;&lt;/code&gt; and &lt;code&gt;Foo&amp;lt;Baz&amp;gt;&lt;/code&gt; both have the same representation.</source>
          <target state="translated">Примечание. Поскольку представление является атрибутом элемента, представление не зависит от общих параметров. Любые два типа с одинаковым именем имеют одинаковое представление. Например, &lt;code&gt;Foo&amp;lt;Bar&amp;gt;&lt;/code&gt; и &lt;code&gt;Foo&amp;lt;Baz&amp;gt;&lt;/code&gt; имеют одинаковое представление.</target>
        </trans-unit>
        <trans-unit id="4eecc607640ace8103d5bc0d89cfb23325aabecd" translate="yes" xml:space="preserve">
          <source>Note: As a control flow expression, if a block expression is the outer expression of an expression statement, the expected type is &lt;code&gt;()&lt;/code&gt; unless it is followed immediately by a semicolon.</source>
          <target state="translated">Примечание. В качестве выражения потока управления, если выражение блока является внешним выражением оператора выражения, ожидаемым типом является &lt;code&gt;()&lt;/code&gt; , если сразу после него не ставится точка с запятой.</target>
        </trans-unit>
        <trans-unit id="09b47fffa556007259b32260e62d1512eb70865a" translate="yes" xml:space="preserve">
          <source>Note: Due to the representation of &lt;code&gt;repr(C)&lt;/code&gt; structs and unions, if a variant has a single field there is no difference between putting that field directly in the union or wrapping it in a struct; any system which wishes to manipulate such an &lt;code&gt;enum&lt;/code&gt;'s representation may therefore use whichever form is more convenient or consistent for them.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4faa88d09ab8f796d3c14502d5099ff92578c5dd" translate="yes" xml:space="preserve">
          <source>Note: Except for lints, it is idiomatic to only use outer attributes on function items.</source>
          <target state="translated">Примечание:За исключением линтов,идиоматически использовать внешние атрибуты только на элементах функций.</target>
        </trans-unit>
        <trans-unit id="6b662a83fcf6e331b5fc245d3658b8a2a3115d43" translate="yes" xml:space="preserve">
          <source>Note: For clarity, it is recommended to always use the &lt;code&gt;dyn&lt;/code&gt; keyword on your trait objects unless your codebase supports compiling with Rust 1.26 or lower.</source>
          <target state="translated">Примечание: для ясности рекомендуется всегда использовать ключевое слово &lt;code&gt;dyn&lt;/code&gt; в ваших объектах признаков, если ваша кодовая база не поддерживает компиляцию с Rust 1.26 или ниже.</target>
        </trans-unit>
        <trans-unit id="1aaba7d58782adfa40a3a8e21596376db2da64ca" translate="yes" xml:space="preserve">
          <source>Note: For more on the implementation details of the &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; type, see &amp;ldquo;The Rustonomicon&amp;rdquo; at https://doc.rust-lang.org/stable/nomicon/vec.html.</source>
          <target state="translated">Примечание. Для получения дополнительных сведений о реализации типа &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; см. &amp;laquo;Rustonomicon&amp;raquo; на https://doc.rust-lang.org/stable/nomicon/vec.html.</target>
        </trans-unit>
        <trans-unit id="12ed0cecef028f179120e48d11efd24c874bfd2d" translate="yes" xml:space="preserve">
          <source>Note: For more on the implementation details of the &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; type, see &lt;a href=&quot;https://doc.rust-lang.org/nomicon/vec.html&quot;&gt;&amp;ldquo;The Rustonomicon&amp;rdquo;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0e05c47a1f80ea2f9b4aa153e205bdf1032d2902" translate="yes" xml:space="preserve">
          <source>Note: For simplicity&amp;rsquo;s sake, we&amp;rsquo;ll refer to many of the problems as &lt;em&gt;concurrent&lt;/em&gt; rather than being more precise by saying &lt;em&gt;concurrent and/or parallel&lt;/em&gt;. If this book were about concurrency and/or parallelism, we&amp;rsquo;d be more specific. For this chapter, please mentally substitute &lt;em&gt;concurrent and/or parallel&lt;/em&gt; whenever we use &lt;em&gt;concurrent&lt;/em&gt;.</source>
          <target state="translated">Примечание. Для простоты мы будем называть многие проблемы &lt;em&gt;параллельными,&lt;/em&gt; а не точнее говорить о &lt;em&gt;параллельных и / или параллельных&lt;/em&gt; . Если бы эта книга была о параллелизме и / или параллелизме, мы были бы более конкретными. В этой главе, пожалуйста, мысленно заменяйте &lt;em&gt;concurrent и / или parallel&lt;/em&gt; всякий раз, когда мы используем &lt;em&gt;concurrent&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="f2bcd0ee14b84ad9b9e572efa4f60a2cdc02453c" translate="yes" xml:space="preserve">
          <source>Note: Functions can implement all three of the &lt;code&gt;Fn&lt;/code&gt; traits too. If what we want to do doesn&amp;rsquo;t require capturing a value from the environment, we can use a function rather than a closure where we need something that implements an &lt;code&gt;Fn&lt;/code&gt; trait.</source>
          <target state="translated">Примечание. Функции также могут реализовывать все три черты &lt;code&gt;Fn&lt;/code&gt; . Если то, что мы хотим сделать, не требует захвата значения из среды, мы можем использовать функцию, а не замыкание, когда нам нужно что-то, реализующее черту &lt;code&gt;Fn&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7d3096da378822b99ae4c5c058d93a4ddaf9860b" translate="yes" xml:space="preserve">
          <source>Note: Git is a common version control system. You can change &lt;code&gt;cargo new&lt;/code&gt; to use a different version control system or no version control system by using the &lt;code&gt;--vcs&lt;/code&gt; flag. Run &lt;code&gt;cargo new --help&lt;/code&gt; to see the available options.</source>
          <target state="translated">Примечание. Git - это распространенная система контроля версий. Вы можете изменить &lt;code&gt;cargo new&lt;/code&gt; для использования другой системы контроля версий или отсутствия системы контроля версий с помощью флага &lt;code&gt;--vcs&lt;/code&gt; . Запустите &lt;code&gt;cargo new --help&lt;/code&gt; чтобы увидеть доступные параметры.</target>
        </trans-unit>
        <trans-unit id="0df14a643f96169ae07176fb1e5faadaf3d41970" translate="yes" xml:space="preserve">
          <source>Note: Historically, place expressions were called &lt;em&gt;lvalues&lt;/em&gt; and value expressions were called &lt;em&gt;rvalues&lt;/em&gt;.</source>
          <target state="translated">Примечание: Исторически выражения места назывались &lt;em&gt;lvalues,&lt;/em&gt; а выражения значений - &lt;em&gt;rvalues&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="95d17fa37d73d94b4ba6d7a45e2dff4566bcf95b" translate="yes" xml:space="preserve">
          <source>Note: If the &lt;code&gt;PeekMut&lt;/code&gt; value is leaked, the heap may be in an inconsistent state.</source>
          <target state="translated">Примечание. Если значение &lt;code&gt;PeekMut&lt;/code&gt; просочилось, куча может находиться в несогласованном состоянии.</target>
        </trans-unit>
        <trans-unit id="b84582c8d2e5caf9e744d83f9c53f4f316f3938a" translate="yes" xml:space="preserve">
          <source>Note: If you prefer not to use &lt;code&gt;rustup&lt;/code&gt; for some reason, please see &lt;a href=&quot;https://www.rust-lang.org/tools/install&quot;&gt;the Rust installation page&lt;/a&gt; for other options.</source>
          <target state="translated">Примечание: если вы по &lt;code&gt;rustup&lt;/code&gt; то причине предпочитаете не использовать rustup , пожалуйста, посетите &lt;a href=&quot;https://www.rust-lang.org/tools/install&quot;&gt;страницу установки Rust&lt;/a&gt; , чтобы узнать о других вариантах.</target>
        </trans-unit>
        <trans-unit id="0d58c0919378a7a1e84f8dd3400503ede165358e" translate="yes" xml:space="preserve">
          <source>Note: In C++, this pattern of deallocating resources at the end of an item&amp;rsquo;s lifetime is sometimes called &lt;em&gt;Resource Acquisition Is Initialization (RAII)&lt;/em&gt;. The &lt;code&gt;drop&lt;/code&gt; function in Rust will be familiar to you if you&amp;rsquo;ve used RAII patterns.</source>
          <target state="translated">Примечание. В C ++ этот шаблон освобождения ресурсов в конце жизненного цикла элемента иногда называется &lt;em&gt;инициализацией получения ресурсов (RAII)&lt;/em&gt; . Функция &lt;code&gt;drop&lt;/code&gt; в Rust будет вам знакома, если вы использовали шаблоны RAII.</target>
        </trans-unit>
        <trans-unit id="54b56211cde322330df3d7c8028b1e66317b030b" translate="yes" xml:space="preserve">
          <source>Note: In general, you should not use &lt;code&gt;FusedIterator&lt;/code&gt; in generic bounds if you need a fused iterator. Instead, you should just call &lt;a href=&quot;trait.iterator#method.fuse&quot;&gt;&lt;code&gt;Iterator::fuse()&lt;/code&gt;&lt;/a&gt; on the iterator. If the iterator is already fused, the additional &lt;a href=&quot;struct.fuse&quot;&gt;&lt;code&gt;Fuse&lt;/code&gt;&lt;/a&gt; wrapper will be a no-op with no performance penalty.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="de232dc8ccf3ad3cf06506f2846d4c5ae30df0ce" translate="yes" xml:space="preserve">
          <source>Note: In general, you should not use &lt;code&gt;FusedIterator&lt;/code&gt; in generic bounds if you need a fused iterator. Instead, you should just call &lt;a href=&quot;trait.iterator#method.fuse&quot;&gt;&lt;code&gt;Iterator::fuse&lt;/code&gt;&lt;/a&gt; on the iterator. If the iterator is already fused, the additional &lt;a href=&quot;struct.fuse&quot;&gt;&lt;code&gt;Fuse&lt;/code&gt;&lt;/a&gt; wrapper will be a no-op with no performance penalty.</source>
          <target state="translated">Примечание. В общем случае не следует использовать &lt;code&gt;FusedIterator&lt;/code&gt; в общих границах, если вам нужен объединенный итератор. Вместо этого вы должны просто вызвать &lt;a href=&quot;trait.iterator#method.fuse&quot;&gt; &lt;code&gt;Iterator::fuse&lt;/code&gt; &lt;/a&gt; на итераторе. Если итератор уже объединен, дополнительная оболочка &lt;a href=&quot;struct.fuse&quot;&gt; &lt;code&gt;Fuse&lt;/code&gt; не&lt;/a&gt; будет работать без потери производительности.</target>
        </trans-unit>
        <trans-unit id="30cece00231291046dd06875e4aca4bb16fbdc74" translate="yes" xml:space="preserve">
          <source>Note: In the edge case where you're seeking with &lt;a href=&quot;enum.seekfrom#variant.Current&quot;&gt;&lt;code&gt;SeekFrom::Current&lt;/code&gt;&lt;/a&gt;&lt;code&gt;(n)&lt;/code&gt; where &lt;code&gt;n&lt;/code&gt; minus the internal buffer length overflows an &lt;code&gt;i64&lt;/code&gt;, two seeks will be performed instead of one. If the second seek returns &lt;a href=&quot;../result/enum.result#variant.Err&quot;&gt;&lt;code&gt;Err&lt;/code&gt;&lt;/a&gt;, the underlying reader will be left at the same position it would have if you called &lt;code&gt;seek&lt;/code&gt; with &lt;a href=&quot;enum.seekfrom#variant.Current&quot;&gt;&lt;code&gt;SeekFrom::Current&lt;/code&gt;&lt;/a&gt;&lt;code&gt;(0)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3a4be906ba1df5fea075ac60c84354ab807a7ba2" translate="yes" xml:space="preserve">
          <source>Note: In the edge case where you're seeking with &lt;code&gt;SeekFrom::Current(n)&lt;/code&gt; where &lt;code&gt;n&lt;/code&gt; minus the internal buffer length overflows an &lt;code&gt;i64&lt;/code&gt;, two seeks will be performed instead of one. If the second seek returns &lt;code&gt;Err&lt;/code&gt;, the underlying reader will be left at the same position it would have if you called &lt;code&gt;seek&lt;/code&gt; with &lt;code&gt;SeekFrom::Current(0)&lt;/code&gt;.</source>
          <target state="translated">Примечание. В &lt;code&gt;SeekFrom::Current(n)&lt;/code&gt; случае, когда вы ищите с помощью SeekFrom :: Current (n), где &lt;code&gt;n&lt;/code&gt; минус длина внутреннего буфера переполняет &lt;code&gt;i64&lt;/code&gt; , будут выполняться два поиска вместо одного. Если второй поиск возвращает &lt;code&gt;Err&lt;/code&gt; , базовый считыватель останется в том же положении, что и при вызове &lt;code&gt;SeekFrom::Current(0)&lt;/code&gt; &lt;code&gt;seek&lt;/code&gt; с помощью SeekFrom :: Current (0) .</target>
        </trans-unit>
        <trans-unit id="ffeb95a03330faff30434eb464fab2ecfe395aa0" translate="yes" xml:space="preserve">
          <source>Note: It is idiomatic to use a &lt;a href=&quot;../statements#let-statements&quot;&gt;let statement&lt;/a&gt; with a pattern of &lt;code&gt;_&lt;/code&gt; when a must-used value is purposely discarded.</source>
          <target state="translated">Примечание. Идиоматично использовать оператор &lt;a href=&quot;../statements#let-statements&quot;&gt;let&lt;/a&gt; с шаблоном &lt;code&gt;_&lt;/code&gt; , когда обязательное значение намеренно отбрасывается.</target>
        </trans-unit>
        <trans-unit id="a98353ad4c2ea48db43b41e0a837834f6a8b30a0" translate="yes" xml:space="preserve">
          <source>Note: Lifetimes can be and usually are elided with this shorthand.</source>
          <target state="translated">Примечание:Скорость жизни может быть и,как правило,не учитывается при написании этого сокращения.</target>
        </trans-unit>
        <trans-unit id="9458a465758bdea1aa806edbdf38d0829ff7abbc" translate="yes" xml:space="preserve">
          <source>Note: Multiple matches using the &lt;code&gt;|&lt;/code&gt; operator can cause the pattern guard and the side effects it has to execute multiple times. For example:</source>
          <target state="translated">Примечание: множественные совпадения с использованием &lt;code&gt;|&lt;/code&gt; Оператор может вызвать защиту шаблона и побочные эффекты, которые он должен выполнять несколько раз. Например:</target>
        </trans-unit>
        <trans-unit id="b48aac9382dceff2ad2732e0844fc1d124e5afbe" translate="yes" xml:space="preserve">
          <source>Note: String slice range indices must occur at valid UTF-8 character boundaries. If you attempt to create a string slice in the middle of a multibyte character, your program will exit with an error. For the purposes of introducing string slices, we are assuming ASCII only in this section; a more thorough discussion of UTF-8 handling is in the &lt;a href=&quot;ch08-02-strings#storing-utf-8-encoded-text-with-strings&quot;&gt;&amp;ldquo;Storing UTF-8 Encoded Text with Strings&amp;rdquo;&lt;/a&gt; section of Chapter 8.</source>
          <target state="translated">Примечание. Индексы диапазона среза строки должны находиться на допустимой границе символа UTF-8. Если вы попытаетесь создать строковый фрагмент в середине многобайтового символа, ваша программа завершится с ошибкой. В целях представления строковых фрагментов мы предполагаем ASCII только в этом разделе; более подробное обсуждение обработки UTF-8 находится в разделе &lt;a href=&quot;ch08-02-strings#storing-utf-8-encoded-text-with-strings&quot;&gt;&amp;laquo;Сохранение текста в кодировке UTF-8 со строками&amp;raquo;&lt;/a&gt; главы 8.</target>
        </trans-unit>
        <trans-unit id="d0300d6a8e919cca08e1ab2c8db38b624e4574c2" translate="yes" xml:space="preserve">
          <source>Note: The &lt;a href=&quot;../../std/vec/struct.vec&quot;&gt;&lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt; standard library type provides a heap-allocated resizable array type.</source>
          <target state="translated">Примечание. Тип стандартной библиотеки &lt;a href=&quot;../../std/vec/struct.vec&quot;&gt; &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; &lt;/a&gt; предоставляет тип массива с изменяемым размером, размещенным в куче.</target>
        </trans-unit>
        <trans-unit id="29d2f706dbf0a3794fd072f42986f2a9c440ff62" translate="yes" xml:space="preserve">
          <source>Note: The &lt;code&gt;//&lt;/code&gt; syntax starts a comment that continues until the end of the line. Rust ignores everything in comments, which are discussed in more detail in Chapter 3.</source>
          <target state="translated">Примечание. Синтаксис &lt;code&gt;//&lt;/code&gt; запускает комментарий, который продолжается до конца строки. Rust игнорирует все, что есть в комментариях, которые более подробно обсуждаются в главе 3.</target>
        </trans-unit>
        <trans-unit id="187085942721c7c78a8ec180c1642f4ed13694fc" translate="yes" xml:space="preserve">
          <source>Note: The &lt;code&gt;2..=9&lt;/code&gt; is a &lt;a href=&quot;../patterns#range-patterns&quot;&gt;Range Pattern&lt;/a&gt;, not a &lt;a href=&quot;range-expr&quot;&gt;Range Expression&lt;/a&gt;. Thus, only those types of ranges supported by range patterns can be used in match arms.</source>
          <target state="translated">Примечание. &lt;code&gt;2..=9&lt;/code&gt; - это &lt;a href=&quot;../patterns#range-patterns&quot;&gt;шаблон диапазона&lt;/a&gt; , а не &lt;a href=&quot;range-expr&quot;&gt;выражение диапазона&lt;/a&gt; . Таким образом, в матчевых руках могут использоваться только те типы диапазонов, которые поддерживаются шаблонами диапазонов.</target>
        </trans-unit>
        <trans-unit id="f039047f79b4edcb39be10eb9b4e9a5ff0260001" translate="yes" xml:space="preserve">
          <source>Note: The actual definition of the &lt;code&gt;vec!&lt;/code&gt; macro in the standard library includes code to preallocate the correct amount of memory up front. That code is an optimization that we don&amp;rsquo;t include here to make the example simpler.</source>
          <target state="translated">Примечание. Фактическое определение &lt;code&gt;vec!&lt;/code&gt; макрос в стандартной библиотеке включает код для предварительного выделения правильного объема памяти. Этот код является оптимизацией, которую мы не включаем здесь, чтобы упростить пример.</target>
        </trans-unit>
        <trans-unit id="43e1990329df70de099fd02b501085a14776154b" translate="yes" xml:space="preserve">
          <source>Note: The aforementioned shim for function pointers is necessary because &lt;code&gt;rustc&lt;/code&gt; implements &lt;code&gt;track_caller&lt;/code&gt; in a codegen context by appending an implicit parameter to the function ABI, but this would be unsound for an indirect call because the parameter is not a part of the function's type and a given function pointer type may or may not refer to a function with the attribute. The creation of a shim hides the implicit parameter from callers of the function pointer, preserving soundness.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="130fc90f1f7559f295e76dc148708d583a3eb9e9" translate="yes" xml:space="preserve">
          <source>Note: The default in &lt;code&gt;rustc&lt;/code&gt; is 1048576.</source>
          <target state="translated">Примечание: значение по умолчанию в &lt;code&gt;rustc&lt;/code&gt; - 1048576.</target>
        </trans-unit>
        <trans-unit id="26390a0ab47722e2e502de5688756dbd639d3d95" translate="yes" xml:space="preserve">
          <source>Note: The default in &lt;code&gt;rustc&lt;/code&gt; is 128.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a3d9efde740053cef26656af7a7f6ab7316f24e6" translate="yes" xml:space="preserve">
          <source>Note: The default in &lt;code&gt;rustc&lt;/code&gt; is 64.</source>
          <target state="translated">Примечание: по умолчанию в &lt;code&gt;rustc&lt;/code&gt; установлено 64.</target>
        </trans-unit>
        <trans-unit id="8180c8df8ae11541f19b00a561591d13760a8ee6" translate="yes" xml:space="preserve">
          <source>Note: The element range is removed even if the iterator is not consumed until the end.</source>
          <target state="translated">Примечание:Диапазон элементов снимается,даже если итератор потребляется не до конца.</target>
        </trans-unit>
        <trans-unit id="9f4fea507ec4e68a49f42af2c77e67668a288392" translate="yes" xml:space="preserve">
          <source>Note: The enum representation in C is implementation defined, so this is really a &quot;best guess&quot;. In particular, this may be incorrect when the C code of interest is compiled with certain flags.</source>
          <target state="translated">Замечание:представление перечисления на C определено реализацией,так что это действительно &quot;лучшая догадка&quot;.В частности,это может быть некорректно,когда интересующий код на Си скомпилирован с определенными флагами.</target>
        </trans-unit>
        <trans-unit id="4cee4fb70834d29d39a99e3fa46a091ae845a20c" translate="yes" xml:space="preserve">
          <source>Note: The examples above used to be (erroneously) accepted by the compiler, but this was since corrected. See &lt;a href=&quot;https://github.com/rust-lang/rust/issues/33685&quot;&gt;issue #33685&lt;/a&gt; for more details.</source>
          <target state="translated">Примечание. Приведенные выше примеры (ошибочно) принимались компилятором, но с тех пор это было исправлено. Подробнее см. &lt;a href=&quot;https://github.com/rust-lang/rust/issues/33685&quot;&gt;Выпуск № 33685&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="daadbb2b1b33b48dcd9e6359e7eecc90c0e80c1e" translate="yes" xml:space="preserve">
          <source>Note: The examples in Listings 10-17, 10-18, and 10-24 declare variables without giving them an initial value, so the variable name exists in the outer scope. At first glance, this might appear to be in conflict with Rust&amp;rsquo;s having no null values. However, if we try to use a variable before giving it a value, we&amp;rsquo;ll get a compile-time error, which shows that Rust indeed does not allow null values.</source>
          <target state="translated">Примечание. В примерах в листингах 10-17, 10-18 и 10-24 переменные объявляются без присвоения им начального значения, поэтому имя переменной существует во внешней области. На первый взгляд может показаться, что это противоречит тому, что в Rust нет нулевых значений. Однако, если мы попытаемся использовать переменную перед присвоением ей значения, мы получим ошибку времени компиляции, которая показывает, что Rust действительно не допускает нулевых значений.</target>
        </trans-unit>
        <trans-unit id="50e01f1ed4a46f62a5d14f0b5fa9d8b4796d1c64" translate="yes" xml:space="preserve">
          <source>Note: The implementation of which return types are allowed is determined by the unstable &lt;a href=&quot;../../std/process/trait.termination&quot;&gt;&lt;code&gt;Termination&lt;/code&gt;&lt;/a&gt; trait.</source>
          <target state="translated">Примечание. Реализация разрешенных типов возвращаемых значений определяется трейтом нестабильное &lt;a href=&quot;../../std/process/trait.termination&quot;&gt; &lt;code&gt;Termination&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="788f6375fff581af876a714c5f38068ea6a94a60" translate="yes" xml:space="preserve">
          <source>Note: The implementation of which return types are allowed is determined by the unstable &lt;a href=&quot;../std/process/trait.termination&quot;&gt;&lt;code&gt;Termination&lt;/code&gt;&lt;/a&gt; trait.</source>
          <target state="translated">Примечание. Реализация разрешенных типов возвращаемых значений определяется трейтом нестабильное &lt;a href=&quot;../std/process/trait.termination&quot;&gt; &lt;code&gt;Termination&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="40b1e975f4973c7f7bd859ba82ec6ff70298303a" translate="yes" xml:space="preserve">
          <source>Note: The lint checks supported by &lt;code&gt;rustc&lt;/code&gt; can be found via &lt;code&gt;rustc -W help&lt;/code&gt;, along with their default settings and are documented in the &lt;a href=&quot;https://doc.rust-lang.org/rustc/lints/index.html&quot;&gt;rustc book&lt;/a&gt;.</source>
          <target state="translated">Примечание. Проверки линта, поддерживаемые &lt;code&gt;rustc&lt;/code&gt; , можно найти с помощью команды &lt;code&gt;rustc -W help&lt;/code&gt; вместе с их настройками по умолчанию, и они задокументированы в &lt;a href=&quot;https://doc.rust-lang.org/rustc/lints/index.html&quot;&gt;книге rustc&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="5df3cfb866cdb5ad3722ea9687c561d88d29727a" translate="yes" xml:space="preserve">
          <source>Note: The next section assumes you&amp;rsquo;ve read the earlier section &lt;a href=&quot;ch19-03-advanced-traits#using-the-newtype-pattern-to-implement-external-traits-on-external-types&quot;&gt;&amp;ldquo;Using the Newtype Pattern to Implement External Traits on External Types.&amp;rdquo;&lt;/a&gt;</source>
          <target state="translated">Примечание. В следующем разделе предполагается, что вы прочитали предыдущий раздел &lt;a href=&quot;ch19-03-advanced-traits#using-the-newtype-pattern-to-implement-external-traits-on-external-types&quot;&gt;&amp;laquo;Использование шаблона Newtype для реализации внешних признаков на внешних типах&amp;raquo;.&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="7007864547a1ff842641db1454a617feb860ba4c" translate="yes" xml:space="preserve">
          <source>Note: The opposite of referencing by using &lt;code&gt;&amp;amp;&lt;/code&gt; is &lt;em&gt;dereferencing&lt;/em&gt;, which is accomplished with the dereference operator, &lt;code&gt;*&lt;/code&gt;. We&amp;rsquo;ll see some uses of the dereference operator in Chapter 8 and discuss details of dereferencing in Chapter 15.</source>
          <target state="translated">Примечание. Противоположностью ссылки с помощью &lt;code&gt;&amp;amp;&lt;/code&gt; является &lt;em&gt;разыменование&lt;/em&gt; , которое выполняется с помощью оператора разыменования &lt;code&gt;*&lt;/code&gt; . Мы увидим некоторые варианты использования оператора разыменования в главе 8 и обсудим детали разыменования в главе 15.</target>
        </trans-unit>
        <trans-unit id="a0cacc6a55793cf1996cae56b2d43488d313d554" translate="yes" xml:space="preserve">
          <source>Note: The semicolon following a statement is not a part of the statement itself. They are invalid when using the &lt;code&gt;stmt&lt;/code&gt; macro matcher.</source>
          <target state="translated">Примечание. Точка с запятой после оператора не является частью самого оператора. Они недействительны при использовании сопоставления макросов &lt;code&gt;stmt&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ebd41440d85e280e6b8e0940e9eb1baf556c6663" translate="yes" xml:space="preserve">
          <source>Note: The test mode is enabled by passing the &lt;code&gt;--test&lt;/code&gt; argument to &lt;code&gt;rustc&lt;/code&gt; or using &lt;code&gt;cargo test&lt;/code&gt;.</source>
          <target state="translated">Примечание: Тестовый режим включен, передавая &lt;code&gt;--test&lt;/code&gt; аргумента &lt;code&gt;rustc&lt;/code&gt; или с помощью &lt;code&gt;cargo test&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="019655f819e73b6b959d0e74887282806fb3a878" translate="yes" xml:space="preserve">
          <source>Note: This algorithm can produce zero-sized structs. In C, an empty struct declaration like &lt;code&gt;struct Foo { }&lt;/code&gt; is illegal. However, both gcc and clang support options to enable such structs, and assign them size zero. C++, in contrast, gives empty structs a size of 1, unless they are inherited from or they are fields that have the &lt;code&gt;[[no_unique_address]]&lt;/code&gt; attribute, in which case they do not increase the overall size of the struct.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a7281566219ec90e2a7e767d6f73d5379e3c0db2" translate="yes" xml:space="preserve">
          <source>Note: This algorithm can produce zero-sized structs. This differs from C where structs without data still have a size of one byte.</source>
          <target state="translated">Примечание:Этот алгоритм может создавать структуры нулевого размера.Это отличается от C,где структуры без данных все еще имеют размер в один байт.</target>
        </trans-unit>
        <trans-unit id="84916df8964c95c521b7aa5c595fc0771cbfc9af" translate="yes" xml:space="preserve">
          <source>Note: This book assumes basic familiarity with the command line. Rust makes no specific demands about your editing or tooling or where your code lives, so if you prefer to use an integrated development environment (IDE) instead of the command line, feel free to use your favorite IDE. Many IDEs now have some degree of Rust support; check the IDE&amp;rsquo;s documentation for details. Recently, the Rust team has been focusing on enabling great IDE support, and progress has been made rapidly on that front!</source>
          <target state="translated">Примечание: эта книга предполагает базовое знакомство с командной строкой. Rust не предъявляет особых требований к вашему редактированию или инструментам, или где находится ваш код, поэтому, если вы предпочитаете использовать интегрированную среду разработки (IDE) вместо командной строки, не стесняйтесь использовать свою любимую IDE. Многие IDE теперь имеют некоторую поддержку Rust; подробности см. в документации IDE. В последнее время команда Rust сосредоточилась на обеспечении отличной поддержки IDE, и в этом направлении был достигнут быстрый прогресс!</target>
        </trans-unit>
        <trans-unit id="5ac1eb98b0f589191a31e26db76121648795b41e" translate="yes" xml:space="preserve">
          <source>Note: This edition of the book is the same as &lt;a href=&quot;https://nostarch.com/rust&quot;&gt;The Rust Programming Language&lt;/a&gt; available in print and ebook format from &lt;a href=&quot;https://nostarch.com/&quot;&gt;No Starch Press&lt;/a&gt;.</source>
          <target state="translated">Примечание: это издание книги такое же, как &lt;a href=&quot;https://nostarch.com/rust&quot;&gt;язык программирования Rust,&lt;/a&gt; доступное в печатном и электронном формате от &lt;a href=&quot;https://nostarch.com/&quot;&gt;No Starch Press&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="12f5db48053663ec58249f015893f0934fb3f9cb" translate="yes" xml:space="preserve">
          <source>Note: This example shows the internals of &lt;code&gt;&amp;amp;str&lt;/code&gt;. &lt;code&gt;unsafe&lt;/code&gt; should not be used to get a string slice under normal circumstances. Use &lt;code&gt;as_slice&lt;/code&gt; instead.</source>
          <target state="translated">Примечание. В этом примере показано внутреннее устройство &lt;code&gt;&amp;amp;str&lt;/code&gt; . &lt;code&gt;unsafe&lt;/code&gt; не следует использовать для получения отрезка строки при нормальных обстоятельствах. &lt;code&gt;as_slice&lt;/code&gt; этого используйте as_slice .</target>
        </trans-unit>
        <trans-unit id="98315c88f72bf459de14ba0cdd9324f6a6dfd072" translate="yes" xml:space="preserve">
          <source>Note: This example shows the internals of &lt;code&gt;&amp;amp;str&lt;/code&gt;. &lt;code&gt;unsafe&lt;/code&gt; should not be used to get a string slice under normal circumstances. Use &lt;code&gt;as_str&lt;/code&gt; instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="71c5367b5e1ca4ccf0bf834db2cd4b500fbdeb5c" translate="yes" xml:space="preserve">
          <source>Note: This is about the raw &lt;code&gt;[T]&lt;/code&gt; type, not pointers (&lt;code&gt;&amp;amp;[T]&lt;/code&gt;, &lt;code&gt;Box&amp;lt;[T]&amp;gt;&lt;/code&gt;, etc.) to slices.</source>
          <target state="translated">Примечание. Речь идет о необработанном типе &lt;code&gt;[T]&lt;/code&gt; , а не об указателях ( &lt;code&gt;&amp;amp;[T]&lt;/code&gt; , &lt;code&gt;Box&amp;lt;[T]&amp;gt;&lt;/code&gt; и т. Д.) На фрагменты.</target>
        </trans-unit>
        <trans-unit id="53274b0feb8252b3f7e0516cd656e66a12715d39" translate="yes" xml:space="preserve">
          <source>Note: This is about the raw trait object types, not pointers (&lt;code&gt;&amp;amp;Trait&lt;/code&gt;, &lt;code&gt;Box&amp;lt;Trait&amp;gt;&lt;/code&gt;, etc.) to trait objects.</source>
          <target state="translated">Примечание. Речь идет о необработанных типах объектов-признаков, а не указателях ( &lt;code&gt;&amp;amp;Trait&lt;/code&gt; , &lt;code&gt;Box&amp;lt;Trait&amp;gt;&lt;/code&gt; и т. Д.) На объекты-признаки.</target>
        </trans-unit>
        <trans-unit id="c578bc980d0061348761c9a476bec4981d2bea05" translate="yes" xml:space="preserve">
          <source>Note: This is about the raw trait object types, not pointers (&lt;code&gt;&amp;amp;dyn Trait&lt;/code&gt;, &lt;code&gt;Box&amp;lt;dyn Trait&amp;gt;&lt;/code&gt;, etc.) to trait objects.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3efbe622a99893d160a87ba1b5dbe54cdc04b646" translate="yes" xml:space="preserve">
          <source>Note: This is often called &quot;impl Trait in argument position&quot;.</source>
          <target state="translated">Примечание:Это часто называется &quot;импл трейт в позиции аргумента&quot;.</target>
        </trans-unit>
        <trans-unit id="ebd18dc0abe826773a124050720a5e27942c51e0" translate="yes" xml:space="preserve">
          <source>Note: This is often called &quot;impl Trait in return position&quot;.</source>
          <target state="translated">Примечание:Это часто называется &quot;трейт имплантата в обратной позиции&quot;.</target>
        </trans-unit>
        <trans-unit id="dcf4aae415a3e26a6bf431396708d40ea1b5d658" translate="yes" xml:space="preserve">
          <source>Note: This macro can be used in &lt;code&gt;no_std&lt;/code&gt; setups as well. In a &lt;code&gt;no_std&lt;/code&gt; setup you are responsible for the implementation details of the components.</source>
          <target state="translated">Примечание. Этот макрос также можно использовать в настройках &lt;code&gt;no_std&lt;/code&gt; . В настройке &lt;code&gt;no_std&lt;/code&gt; вы несете ответственность за детали реализации компонентов.</target>
        </trans-unit>
        <trans-unit id="3ba312fede1a13f53566373763f2cc827d3cc6a0" translate="yes" xml:space="preserve">
          <source>Note: This may call the function multiple times if the value has been changed from other threads in the meantime, as long as the function returns &lt;code&gt;Some(_)&lt;/code&gt;, but the function will have been applied but once to the stored value.</source>
          <target state="translated">Примечание: это может вызвать функцию несколько раз, если значение было изменено из других потоков тем временем, пока функция возвращает &lt;code&gt;Some(_)&lt;/code&gt; , но функция будет применена только один раз к сохраненному значению.</target>
        </trans-unit>
        <trans-unit id="859d3e3283a94e543f2b35839b775cd31f5e0f59" translate="yes" xml:space="preserve">
          <source>Note: This may call the function multiple times if the value has been changed from other threads in the meantime, as long as the function returns &lt;code&gt;Some(_)&lt;/code&gt;, but the function will have been applied only once to the stored value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="64c40b5289fbe1388c2536811cdec7566f0df820" translate="yes" xml:space="preserve">
          <source>Note: This representation is unchanged if the tag is given its own member in the union, should that make manipulation more clear for you (although to follow the C++ standard the tag member should be wrapped in a &lt;code&gt;struct&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="239a5948be38f752de16eb5b0ffe5444c5d1e29d" translate="yes" xml:space="preserve">
          <source>Note: This section is a placeholder for more comprehensive reference material.</source>
          <target state="translated">Примечание:Этот раздел является размещением для более подробных справочных материалов.</target>
        </trans-unit>
        <trans-unit id="5b012ed05fd45d1a0619d2a532517a96144ac5c9" translate="yes" xml:space="preserve">
          <source>Note: This section is described more in terms of the compiler than of the language.</source>
          <target state="translated">Замечание:Этот раздел описан больше с точки зрения компилятора,чем языка.</target>
        </trans-unit>
        <trans-unit id="3b7a991aa3513a216522c1b812051b6fd94ca027" translate="yes" xml:space="preserve">
          <source>Note: Though you should not rely on this, all pointers to</source>
          <target state="translated">Примечание:Хотя вы не должны полагаться на это,все указывает на то,что</target>
        </trans-unit>
        <trans-unit id="ccec92c826b382bbeb8d0f3b3ce8f2aff5320851" translate="yes" xml:space="preserve">
          <source>Note: Traits are similar to a feature often called &lt;em&gt;interfaces&lt;/em&gt; in other languages, although with some differences.</source>
          <target state="translated">Примечание. Черты похожи на функцию, которую на других языках часто называют &lt;em&gt;интерфейсами&lt;/em&gt; , хотя и с некоторыми отличиями.</target>
        </trans-unit>
        <trans-unit id="0ff8579bff78c963092559227a81a969d9708ad7" translate="yes" xml:space="preserve">
          <source>Note: Trivial no-op expressions containing the value will not violate the lint. Examples include wrapping the value in a type that does not implement &lt;a href=&quot;../special-types-and-traits#drop&quot;&gt;&lt;code&gt;Drop&lt;/code&gt;&lt;/a&gt; and then not using that type and being the final expression of a &lt;a href=&quot;../expressions/block-expr&quot;&gt;block expression&lt;/a&gt; that is not used.</source>
          <target state="translated">Примечание. Тривиальные выражения без операции, содержащие значение, не нарушат линта. Примеры включают перенос значения в тип, который не реализует &lt;a href=&quot;../special-types-and-traits#drop&quot;&gt; &lt;code&gt;Drop&lt;/code&gt; ,&lt;/a&gt; а затем не использование этого типа и окончательное выражение выражения &lt;a href=&quot;../expressions/block-expr&quot;&gt;блока&lt;/a&gt; , которое не используется.</target>
        </trans-unit>
        <trans-unit id="eb186d5904a6ce9b777e0cf94b3203a9889bfac8" translate="yes" xml:space="preserve">
          <source>Note: Using primitive values when a complex type would be more appropriate is an anti-pattern known as &lt;em&gt;primitive obsession&lt;/em&gt;.</source>
          <target state="translated">Примечание: использование примитивных значений, когда сложный тип был бы более подходящим, является анти-паттерном, известным как &lt;em&gt;примитивная одержимость&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="04993cf7d2f50288aed55f19ed2ebc1756b87d27" translate="yes" xml:space="preserve">
          <source>Note: We&amp;rsquo;re implementing a cons list that holds only &lt;code&gt;i32&lt;/code&gt; values for the purposes of this example. We could have implemented it using generics, as we discussed in Chapter 10, to define a cons list type that could store values of any type.</source>
          <target state="translated">Примечание: мы реализуем список недостатков, который содержит только значения &lt;code&gt;i32&lt;/code&gt; для целей этого примера. Мы могли бы реализовать его, используя обобщения, как мы обсуждали в главе 10, для определения типа списка cons, который может хранить значения любого типа.</target>
        </trans-unit>
        <trans-unit id="9a9063f50fe88aae84e6d578aa20b9af4873e66f" translate="yes" xml:space="preserve">
          <source>Note: While the definition of the unsized coercions and their implementation has been stabilized, the traits themselves are not yet stable and therefore can't be used directly in stable Rust.</source>
          <target state="translated">Примечание:Несмотря на то,что определение неразмерных принуждений и их реализация стабилизировались,сами черты еще не являются стабильными и поэтому не могут быть использованы непосредственно в стабильной ржавчине.</target>
        </trans-unit>
        <trans-unit id="2dfa6e64910004aadc24cb034a538f296b64dc2f" translate="yes" xml:space="preserve">
          <source>Note: Windows Portability Consideration</source>
          <target state="translated">Примечание:Учет переносимости Windows</target>
        </trans-unit>
        <trans-unit id="54ec2a3d57d83413137977409179cfe79c9797ac" translate="yes" xml:space="preserve">
          <source>Note: You won&amp;rsquo;t just know which traits to use and which methods and functions to call from a crate. Instructions for using a crate are in each crate&amp;rsquo;s documentation. Another neat feature of Cargo is that you can run the &lt;code&gt;cargo doc --open&lt;/code&gt; command, which will build documentation provided by all of your dependencies locally and open it in your browser. If you&amp;rsquo;re interested in other functionality in the &lt;code&gt;rand&lt;/code&gt; crate, for example, run &lt;code&gt;cargo doc --open&lt;/code&gt; and click &lt;code&gt;rand&lt;/code&gt; in the sidebar on the left.</source>
          <target state="translated">Примечание: вы не просто будете знать, какие черты использовать и какие методы и функции вызывать из ящика. Инструкции по использованию ящика есть в документации к каждому ящику. Еще одна интересная особенность Cargo заключается в том, что вы можете запустить команду &lt;code&gt;cargo doc --open&lt;/code&gt; , которая локально создаст документацию, предоставляемую всеми вашими зависимостями, и откроет ее в вашем браузере. Если вас интересуют другие функции ящика &lt;code&gt;rand&lt;/code&gt; , например, запустите &lt;code&gt;cargo doc --open&lt;/code&gt; и щелкните &lt;code&gt;rand&lt;/code&gt; на боковой панели слева.</target>
        </trans-unit>
        <trans-unit id="8dd21546f26b11f02ddb49b823b4ad3f527dfdac" translate="yes" xml:space="preserve">
          <source>Note: any changes to the constness of intrinsics should be discussed with the language team. This includes changes in the stability of the constness.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1377a2c8bb6dcbd807394d1b50fa3eae990de774" translate="yes" xml:space="preserve">
          <source>Note: because the resulting &lt;code&gt;Location&lt;/code&gt; is a hint, an implementation may halt its walk up the stack early. See &lt;a href=&quot;#limitations&quot;&gt;Limitations&lt;/a&gt; for important caveats.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fa7e98c548306a32db0bad3d57bbd3a5f699aa40" translate="yes" xml:space="preserve">
          <source>Note: if you open &lt;em&gt;/sleep&lt;/em&gt; in multiple browser windows simultaneously, they might load one at a time in 5 second intervals. Some web browsers execute multiple instances of the same request sequentially for caching reasons. This limitation is not caused by our web server.</source>
          <target state="translated">Примечание: если вы открываете &lt;em&gt;/ спите&lt;/em&gt; в нескольких окнах браузера одновременно, они могут загружаться по одному с 5-секундными интервалами. Некоторые веб-браузеры последовательно выполняют несколько экземпляров одного и того же запроса из соображений кеширования. Это ограничение не вызвано нашим веб-сервером.</target>
        </trans-unit>
        <trans-unit id="0f059d54c5a420d80b996d0b044829768d22d426" translate="yes" xml:space="preserve">
          <source>Note: in a future Rust version this method may become unnecessary when array literal syntax allows &lt;a href=&quot;https://github.com/rust-lang/rust/issues/49147&quot;&gt;repeating const expressions&lt;/a&gt;. The example below could then use &lt;code&gt;let mut buf = [MaybeUninit::&amp;lt;u8&amp;gt;::uninit(); 32];&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a67ae8b5976b293a38b572b260c03db2df6555be" translate="yes" xml:space="preserve">
          <source>Note: mathematical operations like &lt;a href=&quot;struct.instant#method.add&quot;&gt;&lt;code&gt;add&lt;/code&gt;&lt;/a&gt; may panic if the underlying structure cannot represent the new point in time.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="670b99fc8bc3c4e3e76a24aaf458d8652eb20452" translate="yes" xml:space="preserve">
          <source>Note: mathematical operations like &lt;a href=&quot;struct.systemtime#method.add&quot;&gt;&lt;code&gt;add&lt;/code&gt;&lt;/a&gt; may panic if the underlying structure cannot represent the new point in time.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="94be0b88d71e4f4b09ff423fbdb3966a642ec68a" translate="yes" xml:space="preserve">
          <source>Note: only extended grapheme codepoints that begin the string will be escaped.</source>
          <target state="translated">Замечание:только расширенные кодовые точки графем,которые начинают строку,будут экранированы.</target>
        </trans-unit>
        <trans-unit id="15aa3f25c0678e364c46087d4cf15cef24972d41" translate="yes" xml:space="preserve">
          <source>Note: the &lt;code&gt;Item&lt;/code&gt; type parameter is not used in this trait, but it allows impls to be more generic. Without it, we get this error:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="59ba94b4a0ce80567a5f66bf9563fcdf82240def" translate="yes" xml:space="preserve">
          <source>Note: the lookup is done for each type in order, which can occasionally lead to surprising results. The below code will print &quot;In trait impl!&quot;, because &lt;code&gt;&amp;amp;self&lt;/code&gt; methods are looked up first, the trait method is found before the struct's &lt;code&gt;&amp;amp;mut self&lt;/code&gt; method is found.</source>
          <target state="translated">Примечание: поиск выполняется для каждого типа по порядку, что иногда может приводить к неожиданным результатам. В приведенном ниже коде будет напечатано &amp;laquo;In trait impl!&amp;raquo;, Поскольку сначала ищутся методы &lt;code&gt;&amp;amp;self&lt;/code&gt; , метод trait обнаруживается до того, как будет найден метод struct &lt;code&gt;&amp;amp;mut self&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c7cb38696a69ae9af0ae23e81e9d982ddfe77188" translate="yes" xml:space="preserve">
          <source>Note: the value returned by this method is unspecified after the range has been iterated to exhaustion.</source>
          <target state="translated">Примечание:значение,возвращаемое этим методом,не уточняется после исчерпания диапазона.</target>
        </trans-unit>
        <trans-unit id="aa3e5b7333a9df0d2dc6ac8acfc43125fde51982" translate="yes" xml:space="preserve">
          <source>Note: there&amp;rsquo;s one big difference between the &lt;code&gt;MyBox&amp;lt;T&amp;gt;&lt;/code&gt; type we&amp;rsquo;re about to build and the real &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt;: our version will not store its data on the heap. We are focusing this example on &lt;code&gt;Deref&lt;/code&gt;, so where the data is actually stored is less important than the pointer-like behavior.</source>
          <target state="translated">Примечание: есть одно большое различие между &lt;code&gt;MyBox&amp;lt;T&amp;gt;&lt;/code&gt; мы собираемся создать, и настоящим &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; : наша версия не будет хранить свои данные в куче. В этом примере мы сосредоточили внимание на &lt;code&gt;Deref&lt;/code&gt; , поэтому место, где фактически хранятся данные, менее важно, чем поведение, подобное указателю.</target>
        </trans-unit>
        <trans-unit id="07525906ea71db41f7991cef8484c00c750f6dcb" translate="yes" xml:space="preserve">
          <source>Note: this error code is no longer emitted by the compiler</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0c580688b8d6e9090963bfacda97bc90a713c687" translate="yes" xml:space="preserve">
          <source>Note: this error code is no longer emitted by the compiler.</source>
          <target state="translated">Замечание:данный код ошибки больше не выдается компилятором.</target>
        </trans-unit>
        <trans-unit id="82b6db0c7e241e7e5bc0253c1ea4acf7f9b04451" translate="yes" xml:space="preserve">
          <source>Note: this is an associated function, which means that you have to call it as &lt;code&gt;Box::alloc_ref(&amp;amp;b)&lt;/code&gt; instead of &lt;code&gt;b.alloc_ref()&lt;/code&gt;. This is so that there is no conflict with a method on the inner type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5d8c035d8819f3ef6c6af80dffef20eae4c16d50" translate="yes" xml:space="preserve">
          <source>Note: this is an associated function, which means that you have to call it as &lt;code&gt;Box::allocator(&amp;amp;b)&lt;/code&gt; instead of &lt;code&gt;b.allocator()&lt;/code&gt;. This is so that there is no conflict with a method on the inner type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="de79d60b5ae69ae8de10ccab3addf181d505537b" translate="yes" xml:space="preserve">
          <source>Note: this is an associated function, which means that you have to call it as &lt;code&gt;Box::into_raw(b)&lt;/code&gt; instead of &lt;code&gt;b.into_raw()&lt;/code&gt;. This is so that there is no conflict with a method on the inner type.</source>
          <target state="translated">Примечание: это связанная функция, а это значит, что вы должны вызывать ее как &lt;code&gt;Box::into_raw(b)&lt;/code&gt; вместо &lt;code&gt;b.into_raw()&lt;/code&gt; . Это сделано для того, чтобы не было конфликта с методом внутреннего типа.</target>
        </trans-unit>
        <trans-unit id="9801006a2ac0b25e680ddaebb4a6a97fc9bd8dc1" translate="yes" xml:space="preserve">
          <source>Note: this is an associated function, which means that you have to call it as &lt;code&gt;Box::into_raw_non_null(b)&lt;/code&gt; instead of &lt;code&gt;b.into_raw_non_null()&lt;/code&gt;. This is so that there is no conflict with a method on the inner type.</source>
          <target state="translated">Примечание: это связанная функция, а это означает, что вы должны вызывать ее как &lt;code&gt;Box::into_raw_non_null(b)&lt;/code&gt; вместо &lt;code&gt;b.into_raw_non_null()&lt;/code&gt; . Это сделано для того, чтобы не было конфликта с методом внутреннего типа.</target>
        </trans-unit>
        <trans-unit id="3ad7dd66ed2768898bcd615504f6e1f37abf0500" translate="yes" xml:space="preserve">
          <source>Note: this is an associated function, which means that you have to call it as &lt;code&gt;Box::into_raw_with_alloc(b)&lt;/code&gt; instead of &lt;code&gt;b.into_raw_with_alloc()&lt;/code&gt;. This is so that there is no conflict with a method on the inner type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cc8801e3986d4fa9491ea8a20db52c0e7bd9b75a" translate="yes" xml:space="preserve">
          <source>Note: this is an associated function, which means that you have to call it as &lt;code&gt;Box::into_raw_with_allocator(b)&lt;/code&gt; instead of &lt;code&gt;b.into_raw_with_allocator()&lt;/code&gt;. This is so that there is no conflict with a method on the inner type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b61290dcffaed8f71df5ea3435ea91289cbca703" translate="yes" xml:space="preserve">
          <source>Note: this is an associated function, which means that you have to call it as &lt;code&gt;Box::leak(b)&lt;/code&gt; instead of &lt;code&gt;b.leak()&lt;/code&gt;. This is so that there is no conflict with a method on the inner type.</source>
          <target state="translated">Примечание: это связанная функция, а это значит, что вы должны вызывать ее как &lt;code&gt;Box::leak(b)&lt;/code&gt; &lt;code&gt;b.leak()&lt;/code&gt; b) вместо b.leak () . Это сделано для того, чтобы не было конфликта с методом внутреннего типа.</target>
        </trans-unit>
        <trans-unit id="99cc9083edfe04d950b19fddc376275a0d86e32a" translate="yes" xml:space="preserve">
          <source>Note: while this type is unstable, the functionality it provides can be accessed through the &lt;a href=&quot;https://doc.rust-lang.org/alloc/alloc/index.html#functions&quot;&gt;free functions in &lt;code&gt;alloc&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="855408558daaf89b8b3b6445b95d7c1b8fc7ac9c" translate="yes" xml:space="preserve">
          <source>Note: while this type is unstable, the functionality it provides can be accessed through the &lt;a href=&quot;index#functions&quot;&gt;free functions in &lt;code&gt;alloc&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Примечание: хотя этот тип нестабилен, к предоставляемым им функциям можно получить доступ через &lt;a href=&quot;index#functions&quot;&gt;бесплатные функции в &lt;code&gt;alloc&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="70440046a3dc2e079f23ee1c57dfa76669b732aa" translate="yes" xml:space="preserve">
          <source>Notes</source>
          <target state="translated">Notes</target>
        </trans-unit>
        <trans-unit id="9ea884e20e19e59213993b5d483a5cae6c6deb6b" translate="yes" xml:space="preserve">
          <source>Notes about side effects</source>
          <target state="translated">Заметки о побочных эффектах</target>
        </trans-unit>
        <trans-unit id="0665801607b97f01a2cf09fef56752d404c94329" translate="yes" xml:space="preserve">
          <source>Notes and Safety</source>
          <target state="translated">Примечания и безопасность</target>
        </trans-unit>
        <trans-unit id="5367ad0070e3b4dc018a1e98ba396857c9a89c8b" translate="yes" xml:space="preserve">
          <source>Notes that contain useful information about the state of the book or point out useful, but mostly out of scope, information are in blockquotes that start with the word &quot;Note:&quot; in &lt;strong&gt;bold&lt;/strong&gt;.</source>
          <target state="translated">Примечания, которые содержат полезную информацию о состоянии книги или указывают на полезную, но в основном выходящую за рамки, информацию заключают в кавычки, которые начинаются со слова &amp;laquo;Примечание:&amp;raquo; &lt;strong&gt;жирным шрифтом&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="343e2ff0e712d5880f73c89d0629c959a0cbc677" translate="yes" xml:space="preserve">
          <source>Nothing in Rust prevents a trait from having a method with the same name as another trait&amp;rsquo;s method, nor does Rust prevent you from implementing both traits on one type. It&amp;rsquo;s also possible to implement a method directly on the type with the same name as methods from traits.</source>
          <target state="translated">Ничто в Rust не препятствует тому, чтобы у признака был метод с тем же именем, что и у метода другого признака, равно как и в Rust не мешает вам реализовать оба признака в одном типе. Также возможно реализовать метод непосредственно в типе с тем же именем, что и у методов из трейтов.</target>
        </trans-unit>
        <trans-unit id="85a8ab9caff8306933eb7dd48f9cd08900551077" translate="yes" xml:space="preserve">
          <source>Notice in Listing 16-1 that the closure we pass to &lt;code&gt;thread::spawn&lt;/code&gt; takes no arguments: we&amp;rsquo;re not using any data from the main thread in the spawned thread&amp;rsquo;s code. To use data from the main thread in the spawned thread, the spawned thread&amp;rsquo;s closure must capture the values it needs. Listing 16-3 shows an attempt to create a vector in the main thread and use it in the spawned thread. However, this won&amp;rsquo;t yet work, as you&amp;rsquo;ll see in a moment.</source>
          <target state="translated">Обратите внимание на листинг 16-1, что закрытие, которое мы передаем в &lt;code&gt;thread::spawn&lt;/code&gt; принимает аргументов: мы не используем никаких данных из основного потока в коде порожденного потока. Чтобы использовать данные из основного потока в порожденном потоке, закрытие порожденного потока должно захватывать требуемые значения. В листинге 16-3 показана попытка создать вектор в основном потоке и использовать его в порожденном потоке. Однако это пока не сработает, как вы вскоре увидите.</target>
        </trans-unit>
        <trans-unit id="753a2ed5c1b14367e2086b1d9e2763add33258b6" translate="yes" xml:space="preserve">
          <source>Notice one interesting aspect of this particular execution: the &lt;code&gt;ThreadPool&lt;/code&gt; sent the terminate messages down the channel, and before any worker received the messages, we tried to join worker 0. Worker 0 had not yet received the terminate message, so the main thread blocked waiting for worker 0 to finish. In the meantime, each of the workers received the termination messages. When worker 0 finished, the main thread waited for the rest of the workers to finish. At that point, they had all received the termination message and were able to shut down.</source>
          <target state="translated">Обратите внимание на один интересный аспект этого конкретного выполнения: &lt;code&gt;ThreadPool&lt;/code&gt; отправил сообщения о завершении по каналу, и до того, как какой-либо рабочий процесс получил сообщения, мы попытались присоединиться к рабочему процессу 0. Рабочий 0 еще не получил сообщение о завершении, поэтому основной поток заблокировал ожидание для рабочего 0 закончить. Тем временем каждый из рабочих получил сообщение о завершении. Когда рабочий 0 закончил, основной поток ждал завершения остальных рабочих. В этот момент все они получили сообщение о завершении и смогли завершить работу.</target>
        </trans-unit>
        <trans-unit id="d88bd61c5288b6b4a4fab344b4f64355a8809dd2" translate="yes" xml:space="preserve">
          <source>Notice that &lt;code&gt;NonNull&amp;lt;T&amp;gt;&lt;/code&gt; has a &lt;code&gt;From&lt;/code&gt; instance for &lt;code&gt;&amp;amp;T&lt;/code&gt;. However, this does not change the fact that mutating through a (pointer derived from a) shared reference is undefined behavior unless the mutation happens inside an &lt;a href=&quot;../cell/struct.unsafecell&quot;&gt;&lt;code&gt;UnsafeCell&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt;. The same goes for creating a mutable reference from a shared reference. When using this &lt;code&gt;From&lt;/code&gt; instance without an &lt;code&gt;UnsafeCell&amp;lt;T&amp;gt;&lt;/code&gt;, it is your responsibility to ensure that &lt;code&gt;as_mut&lt;/code&gt; is never called, and &lt;code&gt;as_ptr&lt;/code&gt; is never used for mutation.</source>
          <target state="translated">Обратите внимание , что &lt;code&gt;NonNull&amp;lt;T&amp;gt;&lt;/code&gt; имеет &lt;code&gt;From&lt;/code&gt; экземпляра для &lt;code&gt;&amp;amp;T&lt;/code&gt; . Однако это не меняет того факта, что изменение с помощью (указателя, полученного из) общей ссылки является неопределенным поведением, если только изменение не происходит внутри &lt;a href=&quot;../cell/struct.unsafecell&quot;&gt; &lt;code&gt;UnsafeCell&amp;lt;T&amp;gt;&lt;/code&gt; &lt;/a&gt; . То же самое касается создания изменяемой ссылки из общей ссылки. При использовании этого экземпляра &lt;code&gt;From&lt;/code&gt; без &lt;code&gt;UnsafeCell&amp;lt;T&amp;gt;&lt;/code&gt; вы должны убедиться, что &lt;code&gt;as_mut&lt;/code&gt; никогда не вызывается, а &lt;code&gt;as_ptr&lt;/code&gt; никогда не используется для мутации.</target>
        </trans-unit>
        <trans-unit id="a4555814d84e265a1a37b6f84e64a162ac1d207e" translate="yes" xml:space="preserve">
          <source>Notice that &lt;code&gt;x&lt;/code&gt; is stack-allocated by &lt;code&gt;foo()&lt;/code&gt;. By default, Rust captures closed-over data by reference. This means that once &lt;code&gt;foo()&lt;/code&gt; returns, &lt;code&gt;x&lt;/code&gt; no longer exists. An attempt to access &lt;code&gt;x&lt;/code&gt; within the closure would thus be unsafe.</source>
          <target state="translated">Обратите внимание, что &lt;code&gt;x&lt;/code&gt; выделяется в стеке функцией &lt;code&gt;foo()&lt;/code&gt; . По умолчанию Rust захватывает закрытые данные по ссылке. Это означает, что после возврата из &lt;code&gt;foo()&lt;/code&gt; &lt;code&gt;x&lt;/code&gt; больше не существует. Таким образом, попытка доступа к &lt;code&gt;x&lt;/code&gt; внутри замыкания была бы небезопасной.</target>
        </trans-unit>
        <trans-unit id="0e90ccdac3be23d4ae5fee41e5c9c069831f7aa8" translate="yes" xml:space="preserve">
          <source>Notice that being unblocked does not imply any synchronization with someone that unparked this thread, it could also be spurious. For example, it would be a valid, but inefficient, implementation to make both &lt;a href=&quot;fn.park&quot;&gt;&lt;code&gt;park&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;struct.thread#method.unpark&quot;&gt;&lt;code&gt;unpark&lt;/code&gt;&lt;/a&gt; return immediately without doing anything.</source>
          <target state="translated">Обратите внимание, что разблокировка не подразумевает никакой синхронизации с кем-то, кто разблокировал этот поток, это также может быть ложным. Например, было бы допустимым, но неэффективным вариантом реализации немедленного возврата и &lt;a href=&quot;fn.park&quot;&gt; &lt;code&gt;park&lt;/code&gt; &lt;/a&gt; и &lt;a href=&quot;struct.thread#method.unpark&quot;&gt; &lt;code&gt;unpark&lt;/code&gt; &lt;/a&gt;парковки, ничего не делая.</target>
        </trans-unit>
        <trans-unit id="6dc4ada24330684cf56181017076bf6667acd63e" translate="yes" xml:space="preserve">
          <source>Notice that in the case of &lt;code&gt;compare_and_swap&lt;/code&gt;, it is possible that the operation ends up not performing any store and hence it has just &lt;a href=&quot;enum.ordering#variant.Acquire&quot;&gt;&lt;code&gt;Acquire&lt;/code&gt;&lt;/a&gt; ordering. However, &lt;code&gt;AcqRel&lt;/code&gt; will never perform &lt;a href=&quot;enum.ordering#variant.Relaxed&quot;&gt;&lt;code&gt;Relaxed&lt;/code&gt;&lt;/a&gt; accesses.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a7aa95fb880edfba626d059a08ec359fcae43db0" translate="yes" xml:space="preserve">
          <source>Notice that in the case of &lt;code&gt;compare_and_swap&lt;/code&gt;, it is possible that the operation ends up not performing any store and hence it has just &lt;a href=&quot;https://llvm.org/docs/Atomics.html#acquire&quot;&gt;&lt;code&gt;Acquire&lt;/code&gt;&lt;/a&gt; ordering. However, &lt;a href=&quot;https://llvm.org/docs/Atomics.html#acquirerelease&quot;&gt;&lt;code&gt;AcqRel&lt;/code&gt;&lt;/a&gt; will never perform &lt;a href=&quot;https://llvm.org/docs/Atomics.html#monotonic&quot;&gt;&lt;code&gt;Relaxed&lt;/code&gt;&lt;/a&gt; accesses.</source>
          <target state="translated">Обратите внимание, что в случае &lt;code&gt;compare_and_swap&lt;/code&gt; вполне возможно, что операция не выполняет никакого сохранения и, следовательно, имеет только порядок &lt;a href=&quot;https://llvm.org/docs/Atomics.html#acquire&quot;&gt; &lt;code&gt;Acquire&lt;/code&gt; &lt;/a&gt; . Однако, &lt;a href=&quot;https://llvm.org/docs/Atomics.html#acquirerelease&quot;&gt; &lt;code&gt;AcqRel&lt;/code&gt; &lt;/a&gt; никогда не будет выполнять &lt;a href=&quot;https://llvm.org/docs/Atomics.html#monotonic&quot;&gt; &lt;code&gt;Relaxed&lt;/code&gt; &lt;/a&gt; доступов.</target>
        </trans-unit>
        <trans-unit id="d68951af70c1b2b14c8581375aa37ef775c2c882" translate="yes" xml:space="preserve">
          <source>Notice that the code panicked with the message &lt;code&gt;already borrowed: BorrowMutError&lt;/code&gt;. This is how &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt; handles violations of the borrowing rules at runtime.</source>
          <target state="translated">Обратите внимание, что код запаниковал с &lt;code&gt;already borrowed: BorrowMutError&lt;/code&gt; сообщением : BorrowMutError . Вот как &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt; обрабатывает нарушения правил заимствования во время выполнения.</target>
        </trans-unit>
        <trans-unit id="e6e01b202ce551c042845c38802ff1f31e6bfcd1" translate="yes" xml:space="preserve">
          <source>Notice that the compiler performs this copy automatically when dropping packed structs, i.e., you do not usually have to worry about such issues unless you call &lt;code&gt;drop_in_place&lt;/code&gt; manually.</source>
          <target state="translated">Обратите внимание, что компилятор выполняет эту копию автоматически при отбрасывании упакованных структур, т. &lt;code&gt;drop_in_place&lt;/code&gt; Вам обычно не нужно беспокоиться о таких проблемах, если вы не вызываете drop_in_place вручную.</target>
        </trans-unit>
        <trans-unit id="90e25cc098640b84fbba68a414a9fbb480dff45c" translate="yes" xml:space="preserve">
          <source>Notice that the first value in the vector is &lt;code&gt;&quot;target/debug/minigrep&quot;&lt;/code&gt;, which is the name of our binary. This matches the behavior of the arguments list in C, letting programs use the name by which they were invoked in their execution. It&amp;rsquo;s often convenient to have access to the program name in case you want to print it in messages or change behavior of the program based on what command line alias was used to invoke the program. But for the purposes of this chapter, we&amp;rsquo;ll ignore it and save only the two arguments we need.</source>
          <target state="translated">Обратите внимание, что первое значение в векторе - &lt;code&gt;&quot;target/debug/minigrep&quot;&lt;/code&gt; , что является именем нашего двоичного файла . Это соответствует поведению списка аргументов в C, позволяя программам использовать имя, под которым они были вызваны при их выполнении. Часто бывает удобно иметь доступ к имени программы, если вы хотите напечатать его в сообщениях или изменить поведение программы в зависимости от того, какой псевдоним командной строки использовался для вызова программы. Но для целей этой главы мы проигнорируем его и сохраним только два необходимых нам аргумента.</target>
        </trans-unit>
        <trans-unit id="a69330b1430c6944224f92b74bbe0967131daf2e" translate="yes" xml:space="preserve">
          <source>Notice that the only type we&amp;rsquo;re interacting with from the crate is the &lt;code&gt;Post&lt;/code&gt; type. This type will use the state pattern and will hold a value that will be one of three state objects representing the various states a post can be in&amp;mdash;draft, waiting for review, or published. Changing from one state to another will be managed internally within the &lt;code&gt;Post&lt;/code&gt; type. The states change in response to the methods called by our library&amp;rsquo;s users on the &lt;code&gt;Post&lt;/code&gt; instance, but they don&amp;rsquo;t have to manage the state changes directly. Also, users can&amp;rsquo;t make a mistake with the states, like publishing a post before it&amp;rsquo;s reviewed.</source>
          <target state="translated">Обратите внимание, что единственный тип, с которым мы взаимодействуем из ящика, - это тип &lt;code&gt;Post&lt;/code&gt; . Этот тип будет использовать шаблон состояния и будет содержать значение, которое будет одним из трех объектов состояния, представляющих различные состояния, в которых может находиться сообщение - черновик, ожидающий проверки или опубликованный. Управление переходом из одного состояния в другое осуществляется внутри типа &lt;code&gt;Post&lt;/code&gt; . Состояния изменяются в ответ на методы, вызываемые пользователями нашей библиотеки в экземпляре &lt;code&gt;Post&lt;/code&gt; , но им не нужно напрямую управлять изменениями состояния. Кроме того, пользователи не могут ошибиться с состояниями, например, опубликовать сообщение до его проверки.</target>
        </trans-unit>
        <trans-unit id="a7d5a7d44a98e57a3adf5c0193845ed9098d4a93" translate="yes" xml:space="preserve">
          <source>Notice that the workspace has only one &lt;em&gt;Cargo.lock&lt;/em&gt; file at the top level of the workspace rather than having a &lt;em&gt;Cargo.lock&lt;/em&gt; in each crate&amp;rsquo;s directory. This ensures that all crates are using the same version of all dependencies. If we add the &lt;code&gt;rand&lt;/code&gt; crate to the &lt;em&gt;adder/Cargo.toml&lt;/em&gt; and &lt;em&gt;add-one/Cargo.toml&lt;/em&gt; files, Cargo will resolve both of those to one version of &lt;code&gt;rand&lt;/code&gt; and record that in the one &lt;em&gt;Cargo.lock&lt;/em&gt;. Making all crates in the workspace use the same dependencies means the crates in the workspace will always be compatible with each other. Let&amp;rsquo;s add the &lt;code&gt;rand&lt;/code&gt; crate to the &lt;code&gt;[dependencies]&lt;/code&gt; section in the &lt;em&gt;add-one/Cargo.toml&lt;/em&gt; file to be able to use the &lt;code&gt;rand&lt;/code&gt; crate in the &lt;code&gt;add-one&lt;/code&gt; crate:</source>
          <target state="translated">Обратите внимание, что в рабочем пространстве есть только один файл &lt;em&gt;Cargo.lock&lt;/em&gt; на верхнем уровне рабочего пространства, а не в &lt;em&gt;каталоге&lt;/em&gt; каждого ящика &lt;em&gt;Cargo.lock&lt;/em&gt; . Это гарантирует, что все ящики используют одну и ту же версию всех зависимостей. Если мы добавим ящик &lt;code&gt;rand&lt;/code&gt; в &lt;em&gt;файлы adder / Cargo.toml&lt;/em&gt; и &lt;em&gt;add-one / Cargo.toml&lt;/em&gt; , Cargo разрешит оба из них в одной версии &lt;code&gt;rand&lt;/code&gt; и запишет это в один &lt;em&gt;Cargo.lock&lt;/em&gt; . Использование одинаковых зависимостей для всех ящиков в рабочей области означает, что ящики в рабочей области всегда будут совместимы друг с другом. Давайте добавим ящик &lt;code&gt;rand&lt;/code&gt; в раздел &lt;code&gt;[dependencies]&lt;/code&gt; в&lt;em&gt;add-one / Cargo.toml,&lt;/em&gt; чтобы иметь возможность использовать ящик &lt;code&gt;rand&lt;/code&gt; в &lt;em&gt;контейнере &lt;/em&gt; &lt;code&gt;add-one&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="43f89d0af380f75c1edd764ee3eac2d94a06cd6c" translate="yes" xml:space="preserve">
          <source>Notice that the workspace has only one &lt;em&gt;Cargo.lock&lt;/em&gt; file at the top level of the workspace rather than having a &lt;em&gt;Cargo.lock&lt;/em&gt; in each crate&amp;rsquo;s directory. This ensures that all crates are using the same version of all dependencies. If we add the &lt;code&gt;rand&lt;/code&gt; package to the &lt;em&gt;adder/Cargo.toml&lt;/em&gt; and &lt;em&gt;add-one/Cargo.toml&lt;/em&gt; files, Cargo will resolve both of those to one version of &lt;code&gt;rand&lt;/code&gt; and record that in the one &lt;em&gt;Cargo.lock&lt;/em&gt;. Making all crates in the workspace use the same dependencies means the crates in the workspace will always be compatible with each other. Let&amp;rsquo;s add the &lt;code&gt;rand&lt;/code&gt; crate to the &lt;code&gt;[dependencies]&lt;/code&gt; section in the &lt;em&gt;add-one/Cargo.toml&lt;/em&gt; file to be able to use the &lt;code&gt;rand&lt;/code&gt; crate in the &lt;code&gt;add-one&lt;/code&gt; crate:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aa6a1647ef2a65fa35dd0dfd2179008c8845ec9d" translate="yes" xml:space="preserve">
          <source>Notice that this guarantee does &lt;em&gt;not&lt;/em&gt; mean that memory does not leak! It is still completely okay not ever to call &lt;a href=&quot;../ops/trait.drop#tymethod.drop&quot;&gt;&lt;code&gt;drop&lt;/code&gt;&lt;/a&gt; on a pinned element (e.g., you can still call &lt;a href=&quot;../mem/fn.forget&quot;&gt;&lt;code&gt;mem::forget&lt;/code&gt;&lt;/a&gt; on a &lt;a href=&quot;struct.pin&quot;&gt;&lt;code&gt;Pin&lt;/code&gt;&lt;/a&gt;&lt;code&gt;&amp;lt;&lt;/code&gt;&lt;a href=&quot;../boxed/struct.box&quot;&gt;&lt;code&gt;Box&lt;/code&gt;&lt;/a&gt;&lt;code&gt;&amp;lt;T&amp;gt;&amp;gt;&lt;/code&gt;). In the example of the doubly-linked list, that element would just stay in the list. However you may not free or reuse the storage &lt;em&gt;without calling &lt;a href=&quot;../ops/trait.drop#tymethod.drop&quot;&gt;&lt;code&gt;drop&lt;/code&gt;&lt;/a&gt;&lt;/em&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d099748c8a2369f6e0484b9fb1916260cb072d44" translate="yes" xml:space="preserve">
          <source>Notice that this guarantee does &lt;em&gt;not&lt;/em&gt; mean that memory does not leak! It is still completely okay not ever to call &lt;code&gt;drop&lt;/code&gt; on a pinned element (e.g., you can still call &lt;a href=&quot;../mem/fn.forget&quot;&gt;&lt;code&gt;mem::forget&lt;/code&gt;&lt;/a&gt; on a &lt;code&gt;Pin&amp;lt;Box&amp;lt;T&amp;gt;&amp;gt;&lt;/code&gt;). In the example of the doubly-linked list, that element would just stay in the list. However you may not free or reuse the storage &lt;em&gt;without calling &lt;code&gt;drop&lt;/code&gt;&lt;/em&gt;.</source>
          <target state="translated">Обратите внимание, что эта гарантия &lt;em&gt;не&lt;/em&gt; означает, что память не протекает! По-прежнему совершенно нормально никогда не вызывать &lt;code&gt;drop&lt;/code&gt; для закрепленного элемента (например, вы все еще можете вызывать &lt;a href=&quot;../mem/fn.forget&quot;&gt; &lt;code&gt;mem::forget&lt;/code&gt; &lt;/a&gt; для &lt;code&gt;Pin&amp;lt;Box&amp;lt;T&amp;gt;&amp;gt;&lt;/code&gt; ). В примере с двусвязным списком этот элемент просто останется в списке. Однако вы не можете освободить или повторно использовать хранилище &lt;em&gt;без вызова &lt;code&gt;drop&lt;/code&gt; &lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="e8e96d92ae370594b0a23d663a0a9b44ba5cff77" translate="yes" xml:space="preserve">
          <source>Notice that this time we didn&amp;rsquo;t see output indicating that Cargo was compiling &lt;code&gt;hello_cargo&lt;/code&gt;. Cargo figured out that the files hadn&amp;rsquo;t changed, so it just ran the binary. If you had modified your source code, Cargo would have rebuilt the project before running it, and you would have seen this output:</source>
          <target state="translated">Обратите внимание, что на этот раз мы не увидели вывода, указывающего на то, что Cargo компилирует &lt;code&gt;hello_cargo&lt;/code&gt; . Cargo выяснил, что файлы не изменились, поэтому просто запустил двоичный файл. Если бы вы изменили исходный код, Cargo пересобирал бы проект перед его запуском, и вы бы увидели такой вывод:</target>
        </trans-unit>
        <trans-unit id="75afd928e1d9d07e8e8783b4a4c896142a3ef3bd" translate="yes" xml:space="preserve">
          <source>Notice that using this ordering for an operation that combines loads and stores leads to a &lt;a href=&quot;enum.ordering#variant.Relaxed&quot;&gt;&lt;code&gt;Relaxed&lt;/code&gt;&lt;/a&gt; load operation!</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bc0d2528578bd301fdbec6c6a7d80185cfd20062" translate="yes" xml:space="preserve">
          <source>Notice that using this ordering for an operation that combines loads and stores leads to a &lt;a href=&quot;enum.ordering#variant.Relaxed&quot;&gt;&lt;code&gt;Relaxed&lt;/code&gt;&lt;/a&gt; store operation!</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6af1b53e3b0f26b23d98afe8cfa1fff0e78676da" translate="yes" xml:space="preserve">
          <source>Notice that using this ordering for an operation that combines loads and stores leads to a &lt;a href=&quot;https://llvm.org/docs/Atomics.html#monotonic&quot;&gt;&lt;code&gt;Relaxed&lt;/code&gt;&lt;/a&gt; load operation!</source>
          <target state="translated">Обратите внимание, что использование этого порядка для операции, объединяющей загрузки и сохранения, приводит к операции &lt;a href=&quot;https://llvm.org/docs/Atomics.html#monotonic&quot;&gt; &lt;code&gt;Relaxed&lt;/code&gt; &lt;/a&gt; загрузки!</target>
        </trans-unit>
        <trans-unit id="a34cbcc2842b5a9803de21bbd3cea40bd2f9faf2" translate="yes" xml:space="preserve">
          <source>Notice that using this ordering for an operation that combines loads and stores leads to a &lt;a href=&quot;https://llvm.org/docs/Atomics.html#monotonic&quot;&gt;&lt;code&gt;Relaxed&lt;/code&gt;&lt;/a&gt; store operation!</source>
          <target state="translated">Обратите внимание, что использование этого порядка для операции, которая объединяет загрузки и сохранения, приводит к операции &lt;a href=&quot;https://llvm.org/docs/Atomics.html#monotonic&quot;&gt; &lt;code&gt;Relaxed&lt;/code&gt; &lt;/a&gt; хранения!</target>
        </trans-unit>
        <trans-unit id="1648ed9eef01e81103715c2fb558bce27eedcadf" translate="yes" xml:space="preserve">
          <source>Notice that we don&amp;rsquo;t include the &lt;code&gt;unsafe&lt;/code&gt; keyword in this code. We can create raw pointers in safe code; we just can&amp;rsquo;t dereference raw pointers outside an unsafe block, as you&amp;rsquo;ll see in a bit.</source>
          <target state="translated">Обратите внимание, что мы не включаем ключевое слово &lt;code&gt;unsafe&lt;/code&gt; в этот код. Мы можем создавать необработанные указатели в безопасном коде; мы просто не можем разыменовать необработанные указатели вне небезопасного блока, как вы вскоре увидите.</target>
        </trans-unit>
        <trans-unit id="111ab81f0256d10482ec4d240e310c1571a40527" translate="yes" xml:space="preserve">
          <source>Notice that we need an explicit lifetime &lt;code&gt;'a&lt;/code&gt; defined in the signature of &lt;code&gt;search&lt;/code&gt; and used with the &lt;code&gt;contents&lt;/code&gt; argument and the return value. Recall in &lt;a href=&quot;ch10-03-lifetime-syntax&quot;&gt;Chapter 10&lt;/a&gt; that the lifetime parameters specify which argument lifetime is connected to the lifetime of the return value. In this case, we indicate that the returned vector should contain string slices that reference slices of the argument &lt;code&gt;contents&lt;/code&gt; (rather than the argument &lt;code&gt;query&lt;/code&gt;).</source>
          <target state="translated">Обратите внимание, что нам нужно явное время жизни &lt;code&gt;'a&lt;/code&gt; определенное в сигнатуре &lt;code&gt;search&lt;/code&gt; и используемое с аргументом &lt;code&gt;contents&lt;/code&gt; и возвращаемым значением. Напомним, что в &lt;a href=&quot;ch10-03-lifetime-syntax&quot;&gt;главе 10&lt;/a&gt; параметры времени жизни указывают, какое время жизни аргумента связано со временем жизни возвращаемого значения. В этом случае мы указываем, что возвращаемый вектор должен содержать фрагменты строки, которые ссылаются на фрагменты &lt;code&gt;contents&lt;/code&gt; аргумента (а не &lt;code&gt;query&lt;/code&gt; аргумента ).</target>
        </trans-unit>
        <trans-unit id="fd9233164b7146f50abe145b0977e2ddba8ac9ff" translate="yes" xml:space="preserve">
          <source>Notice that we&amp;rsquo;ve split the code into the &lt;code&gt;hello_macro_derive&lt;/code&gt; function, which is responsible for parsing the &lt;code&gt;TokenStream&lt;/code&gt;, and the &lt;code&gt;impl_hello_macro&lt;/code&gt; function, which is responsible for transforming the syntax tree: this makes writing a procedural macro more convenient. The code in the outer function (&lt;code&gt;hello_macro_derive&lt;/code&gt; in this case) will be the same for almost every procedural macro crate you see or create. The code you specify in the body of the inner function (&lt;code&gt;impl_hello_macro&lt;/code&gt; in this case) will be different depending on your procedural macro&amp;rsquo;s purpose.</source>
          <target state="translated">Обратите внимание, что мы разделили код на функцию &lt;code&gt;hello_macro_derive&lt;/code&gt; , которая отвечает за синтаксический анализ &lt;code&gt;TokenStream&lt;/code&gt; , и функцию &lt;code&gt;impl_hello_macro&lt;/code&gt; , которая отвечает за преобразование синтаксического дерева: это делает написание процедурного макроса более удобным. Код во внешней функции ( в данном случае &lt;code&gt;hello_macro_derive&lt;/code&gt; ) будет одинаковым почти для всех процедурных ящиков макросов, которые вы видите или создаете. Код, который вы указываете в теле внутренней функции ( в данном случае &lt;code&gt;impl_hello_macro&lt;/code&gt; ), будет отличаться в зависимости от цели вашего процедурного макроса.</target>
        </trans-unit>
        <trans-unit id="8966a5e7726edf21a4dc24ce7e3b95ed94980ac9" translate="yes" xml:space="preserve">
          <source>Notice there isn&amp;rsquo;t any code after the last line that begins with &lt;code&gt;//!&lt;/code&gt;. Because we started the comments with &lt;code&gt;//!&lt;/code&gt; instead of &lt;code&gt;///&lt;/code&gt;, we&amp;rsquo;re documenting the item that contains this comment rather than an item that follows this comment. In this case, the item that contains this comment is the &lt;em&gt;src/lib.rs&lt;/em&gt; file, which is the crate root. These comments describe the entire crate.</source>
          <target state="translated">Обратите внимание, что после последней строки, начинающейся с &lt;code&gt;//!&lt;/code&gt; нет кода ! . Потому что мы начали комментарии с &lt;code&gt;//!&lt;/code&gt; вместо &lt;code&gt;///&lt;/code&gt; мы документируем элемент, содержащий этот комментарий, а не элемент, следующий за этим комментарием. В этом случае элементом, содержащим этот комментарий, является файл &lt;em&gt;src / lib.rs&lt;/em&gt; , который является корнем ящика. Эти комментарии описывают весь ящик.</target>
        </trans-unit>
        <trans-unit id="fcd0fb110f9fe32ec66824d300336739072d5b34" translate="yes" xml:space="preserve">
          <source>Notice this definition uses some new syntax: &lt;code&gt;type Item&lt;/code&gt; and &lt;code&gt;Self::Item&lt;/code&gt;, which are defining an &lt;em&gt;associated type&lt;/em&gt; with this trait. We&amp;rsquo;ll talk about associated types in depth in Chapter 19. For now, all you need to know is that this code says implementing the &lt;code&gt;Iterator&lt;/code&gt; trait requires that you also define an &lt;code&gt;Item&lt;/code&gt; type, and this &lt;code&gt;Item&lt;/code&gt; type is used in the return type of the &lt;code&gt;next&lt;/code&gt; method. In other words, the &lt;code&gt;Item&lt;/code&gt; type will be the type returned from the iterator.</source>
          <target state="translated">Обратите внимание, что в этом определении используется новый синтаксис: &lt;code&gt;type Item&lt;/code&gt; и &lt;code&gt;Self::Item&lt;/code&gt; , которые определяют &lt;em&gt;связанный тип&lt;/em&gt; с этой характеристикой. Мы подробно поговорим о связанных типах в главе 19. На данный момент все, что вам нужно знать, это то, что в этом коде говорится, что для реализации трейта &lt;code&gt;Iterator&lt;/code&gt; необходимо также определить тип &lt;code&gt;Item&lt;/code&gt; , и этот тип &lt;code&gt;Item&lt;/code&gt; используется в типе возвращаемого значения &lt;code&gt;next&lt;/code&gt; метод. Другими словами, тип &lt;code&gt;Item&lt;/code&gt; будет типом, возвращаемым итератором.</target>
        </trans-unit>
        <trans-unit id="e0aa323f0e9e9e9d80a8d3d6a7b2a9db9ba76843" translate="yes" xml:space="preserve">
          <source>Now all the instances of &lt;code&gt;Point&lt;/code&gt; shown are allowed! You can use as many generic type parameters in a definition as you want, but using more than a few makes your code hard to read. When you need lots of generic types in your code, it could indicate that your code needs restructuring into smaller pieces.</source>
          <target state="translated">Теперь все показанные экземпляры &lt;code&gt;Point&lt;/code&gt; разрешены! Вы можете использовать в определении столько параметров универсального типа, сколько захотите, но использование большего количества параметров затрудняет чтение вашего кода. Когда вам нужно много общих типов в вашем коде, это может указывать на то, что ваш код нуждается в реструктуризации на более мелкие части.</target>
        </trans-unit>
        <trans-unit id="23eaa14436421a3e3cff4560bf4fb71eb52f11da" translate="yes" xml:space="preserve">
          <source>Now all the references in this function signature have lifetimes, and the compiler can continue its analysis without needing the programmer to annotate the lifetimes in this function signature.</source>
          <target state="translated">Теперь все ссылки в сигнатуре этой функции имеют пожизненный срок службы,и компилятор может продолжить свой анализ,не требуя от программиста аннотации пожизненного срока службы в сигнатуре этой функции.</target>
        </trans-unit>
        <trans-unit id="6e1a1d010dc9ab9a0953fedbe299c3c77ffa1062" translate="yes" xml:space="preserve">
          <source>Now an example of &lt;code&gt;bool&lt;/code&gt; cast to integer type:</source>
          <target state="translated">Теперь пример приведения &lt;code&gt;bool&lt;/code&gt; к целочисленному типу:</target>
        </trans-unit>
        <trans-unit id="d65b9b0f422f439e94c8e42e9b963ca1e3008607" translate="yes" xml:space="preserve">
          <source>Now consider this twist where we add a call to &lt;code&gt;rev&lt;/code&gt;. This version will print &lt;code&gt;('c', 1), ('b', 2), ('a', 3)&lt;/code&gt;. Note that the letters are reversed, but the values of the counter still go in order. This is because &lt;code&gt;map()&lt;/code&gt; is still being called lazily on each item, but we are popping items off the back of the vector now, instead of shifting them from the front.</source>
          <target state="translated">Теперь рассмотрим этот поворот, когда мы добавляем вызов в &lt;code&gt;rev&lt;/code&gt; . Эта версия напечатает &lt;code&gt;('c', 1), ('b', 2), ('a', 3)&lt;/code&gt; . Обратите внимание, что буквы поменяны местами, но значения счетчика по-прежнему идут по порядку. Это потому, что &lt;code&gt;map()&lt;/code&gt; по-прежнему лениво вызывается для каждого элемента, но теперь мы выталкиваем элементы с обратной стороны вектора, а не смещаем их спереди.</target>
        </trans-unit>
        <trans-unit id="3a875ba4bda66efea86acc1d83b8c4cd40356ff2" translate="yes" xml:space="preserve">
          <source>Now enter the code in Listing 20-1 in &lt;em&gt;src/main.rs&lt;/em&gt; to start. This code will listen at the address &lt;code&gt;127.0.0.1:7878&lt;/code&gt; for incoming TCP streams. When it gets an incoming stream, it will print &lt;code&gt;Connection established!&lt;/code&gt;.</source>
          <target state="translated">Теперь введите код из Листинга 20-1 в &lt;em&gt;src / main.rs,&lt;/em&gt; чтобы начать. Этот код будет прослушивать по адресу &lt;code&gt;127.0.0.1:7878&lt;/code&gt; входящие потоки TCP. Когда он получит входящий поток, он напечатает &amp;laquo; &lt;code&gt;Connection established!&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="dc71b87d7408d245b3b0aa3a92982cb74fc6ac9f" translate="yes" xml:space="preserve">
          <source>Now everything in the program should work as expected. Let&amp;rsquo;s try it:</source>
          <target state="translated">Теперь все в программе должно работать как положено. Давай попробуем:</target>
        </trans-unit>
        <trans-unit id="d7f4763863038d188ed1914c2142e2e561d22201" translate="yes" xml:space="preserve">
          <source>Now if we change either the function or the example so the &lt;code&gt;assert_eq!&lt;/code&gt; in the example panics and run &lt;code&gt;cargo test&lt;/code&gt; again, we&amp;rsquo;ll see that the doc tests catch that the example and the code are out of sync with each other!</source>
          <target state="translated">Теперь, если мы изменим либо функцию, либо пример так, чтобы &lt;code&gt;assert_eq!&lt;/code&gt; в примере паникает и снова запускается &lt;code&gt;cargo test&lt;/code&gt; , мы увидим, что тесты документации обнаруживают, что пример и код не синхронизированы друг с другом!</target>
        </trans-unit>
        <trans-unit id="2e5aa4ec7130600ff4ecc4d4f5150848ff00d36e" translate="yes" xml:space="preserve">
          <source>Now it's possible to create at least one instance of &lt;code&gt;Foo&lt;/code&gt;: &lt;code&gt;Foo { x: None }&lt;/code&gt;.</source>
          <target state="translated">Теперь можно создать хотя бы один экземпляр &lt;code&gt;Foo&lt;/code&gt; : &lt;code&gt;Foo { x: None }&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="57dee911ce426e019e30db0fccc486981ac3d8d4" translate="yes" xml:space="preserve">
          <source>Now let&amp;rsquo;s add the code in Listing 20-7 to the &lt;code&gt;else&lt;/code&gt; block to return a response with the status code 404, which signals that the content for the request was not found. We&amp;rsquo;ll also return some HTML for a page to render in the browser indicating the response to the end user.</source>
          <target state="translated">Теперь давайте добавим код из листинга 20-7 в блок &lt;code&gt;else&lt;/code&gt; , чтобы вернуть ответ с кодом состояния 404, который сигнализирует, что контент для запроса не был найден. Мы также вернем HTML-код для страницы, отображаемой в браузере, с указанием ответа конечному пользователю.</target>
        </trans-unit>
        <trans-unit id="82511279c647b8b87ee818b8d44458ab76617b1f" translate="yes" xml:space="preserve">
          <source>Now let&amp;rsquo;s compile this &amp;ldquo;Hello, world!&amp;rdquo; program and run it in the same step using the &lt;code&gt;cargo run&lt;/code&gt; command:</source>
          <target state="translated">Теперь давайте скомпилируем это &amp;laquo;Hello, world!&amp;raquo; программу и запустите ее на том же этапе, используя команду &lt;code&gt;cargo run&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="8863ee5075a8246e730bfe40012862faba75a02b" translate="yes" xml:space="preserve">
          <source>Now let&amp;rsquo;s consider the second call of &lt;code&gt;plus_one&lt;/code&gt; in Listing 6-5, where &lt;code&gt;x&lt;/code&gt; is &lt;code&gt;None&lt;/code&gt;. We enter the &lt;code&gt;match&lt;/code&gt; and compare to the first arm.</source>
          <target state="translated">Теперь давайте рассмотрим второй вызов &lt;code&gt;plus_one&lt;/code&gt; в листинге 6-5, где &lt;code&gt;x&lt;/code&gt; - &lt;code&gt;None&lt;/code&gt; . Входим в &lt;code&gt;match&lt;/code&gt; и сравниваем с первой рукой.</target>
        </trans-unit>
        <trans-unit id="b8300b290a67f9ed128322c21050dab12f2d0aa0" translate="yes" xml:space="preserve">
          <source>Now let&amp;rsquo;s examine lifetime annotations in the context of the &lt;code&gt;longest&lt;/code&gt; function. As with generic type parameters, we need to declare generic lifetime parameters inside angle brackets between the function name and the parameter list. The constraint we want to express in this signature is that all the references in the parameters and the return value must have the same lifetime. We&amp;rsquo;ll name the lifetime &lt;code&gt;'a&lt;/code&gt; and then add it to each reference, as shown in Listing 10-22.</source>
          <target state="translated">Теперь давайте рассмотрим аннотации времени жизни в контексте самой &lt;code&gt;longest&lt;/code&gt; функции. Как и в случае с параметрами универсального типа, нам необходимо объявить параметры универсального времени в угловых скобках между именем функции и списком параметров. Ограничение, которое мы хотим выразить в этой сигнатуре, состоит в том, что все ссылки в параметрах и возвращаемом значении должны иметь одинаковое время жизни. Мы назовем время жизни &lt;code&gt;'a&lt;/code&gt; и затем добавим его к каждой ссылке, как показано в Листинге 10-22.</target>
        </trans-unit>
        <trans-unit id="4d1d28eae4c7f65ed347f71ad22936c83ed0eb43" translate="yes" xml:space="preserve">
          <source>Now let&amp;rsquo;s lean on the compiler to find the other places that need to change. Checking this code, we get two errors:</source>
          <target state="translated">Теперь давайте опираемся на компилятор, чтобы найти другие места, которые нужно изменить. Проверяя этот код, получаем две ошибки:</target>
        </trans-unit>
        <trans-unit id="89a2cc6c6da74e574a540dd470febae8d113a245" translate="yes" xml:space="preserve">
          <source>Now let&amp;rsquo;s look at the &lt;code&gt;String&lt;/code&gt; version:</source>
          <target state="translated">Теперь посмотрим на версию &lt;code&gt;String&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="aaee68df203c11b18152dd8afe26709ec73580c1" translate="yes" xml:space="preserve">
          <source>Now let&amp;rsquo;s look at the pattern in the body of the code associated with this arm: &lt;code&gt;temp_vec.push()&lt;/code&gt; within &lt;code&gt;$()*&lt;/code&gt; is generated for each part that matches &lt;code&gt;$()&lt;/code&gt; in the pattern zero or more times depending on how many times the pattern matches. The &lt;code&gt;$x&lt;/code&gt; is replaced with each expression matched. When we call this macro with &lt;code&gt;vec![1, 2, 3];&lt;/code&gt;, the code generated that replaces this macro call will be the following:</source>
          <target state="translated">Теперь давайте посмотрим на шаблон в теле кода, связанного с этой рукой: &lt;code&gt;temp_vec.push()&lt;/code&gt; внутри &lt;code&gt;$()*&lt;/code&gt; создается для каждой части, которая соответствует &lt;code&gt;$()&lt;/code&gt; в шаблоне ноль или более раз, в зависимости от того, сколько раз совпадение шаблонов. &lt;code&gt;$x&lt;/code&gt; заменяется с каждым выражением согласованной. Когда мы вызываем этот макрос с помощью &lt;code&gt;vec![1, 2, 3];&lt;/code&gt; , сгенерированный код, заменяющий этот вызов макроса, будет следующим:</target>
        </trans-unit>
        <trans-unit id="c4243cfe8f9ac10ec246b38ad823287bb3f58d73" translate="yes" xml:space="preserve">
          <source>Now let&amp;rsquo;s look at what&amp;rsquo;s different when we build and run the &amp;ldquo;Hello, world!&amp;rdquo; program with Cargo! From your &lt;em&gt;hello_cargo&lt;/em&gt; directory, build your project by entering the following command:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="80b98c3dc4276471e5dedcfc50a6872d575390db" translate="yes" xml:space="preserve">
          <source>Now let&amp;rsquo;s look at what&amp;rsquo;s different when we build and run the Hello, world! program with Cargo! From your &lt;em&gt;hello_cargo&lt;/em&gt; directory, build your project by entering the following command:</source>
          <target state="translated">Теперь давайте посмотрим, что изменилось при создании и запуске Hello, world! программа с Cargo! В каталоге &lt;em&gt;hello_cargo&lt;/em&gt; создайте проект, введя следующую команду:</target>
        </trans-unit>
        <trans-unit id="5b581411bc505a7c21b9a362d12d054fb0134b63" translate="yes" xml:space="preserve">
          <source>Now let&amp;rsquo;s run the test:</source>
          <target state="translated">Теперь запустим тест:</target>
        </trans-unit>
        <trans-unit id="f0501637a3932ce5ddf54dd291b5e0f5788b9a63" translate="yes" xml:space="preserve">
          <source>Now open &lt;em&gt;src/main.rs&lt;/em&gt; and take a look:</source>
          <target state="translated">Теперь откройте &lt;em&gt;src / main.rs&lt;/em&gt; и посмотрите:</target>
        </trans-unit>
        <trans-unit id="b399f29f23b6c286984286dd9b48d3e844228cb4" translate="yes" xml:space="preserve">
          <source>Now open the &lt;em&gt;main.rs&lt;/em&gt; file you just created and enter the code in Listing 1-1.</source>
          <target state="translated">Теперь откройте только что &lt;em&gt;созданный&lt;/em&gt; файл &lt;em&gt;main.rs&lt;/em&gt; и введите код из Листинга 1-1.</target>
        </trans-unit>
        <trans-unit id="d981ccfedbc387139591c6429e1ab6bbb51ae547" translate="yes" xml:space="preserve">
          <source>Now our code more clearly conveys that &lt;code&gt;query&lt;/code&gt; and &lt;code&gt;filename&lt;/code&gt; are related and that their purpose is to configure how the program will work. Any code that uses these values knows to find them in the &lt;code&gt;config&lt;/code&gt; instance in the fields named for their purpose.</source>
          <target state="translated">Теперь наш код более четко передает, что &lt;code&gt;query&lt;/code&gt; и &lt;code&gt;filename&lt;/code&gt; связаны, и что их цель - настроить работу программы. Любой код, использующий эти значения, знает, как найти их в экземпляре &lt;code&gt;config&lt;/code&gt; в полях, названных в соответствии с их назначением.</target>
        </trans-unit>
        <trans-unit id="e98906bcddd6edae414bc05f0060b41c04becc18" translate="yes" xml:space="preserve">
          <source>Now run &lt;code&gt;cargo test&lt;/code&gt; in the top-level &lt;em&gt;add&lt;/em&gt; directory:</source>
          <target state="translated">Теперь запустите &lt;code&gt;cargo test&lt;/code&gt; в каталоге &lt;em&gt;добавления&lt;/em&gt; верхнего уровня :</target>
        </trans-unit>
        <trans-unit id="d7999991a01bc3db0ab51179e8f7d5b7ea1e4709" translate="yes" xml:space="preserve">
          <source>Now that the &lt;code&gt;search&lt;/code&gt; function is working and tested, we need to call &lt;code&gt;search&lt;/code&gt; from our &lt;code&gt;run&lt;/code&gt; function. We need to pass the &lt;code&gt;config.query&lt;/code&gt; value and the &lt;code&gt;contents&lt;/code&gt; that &lt;code&gt;run&lt;/code&gt; reads from the file to the &lt;code&gt;search&lt;/code&gt; function. Then &lt;code&gt;run&lt;/code&gt; will print each line returned from &lt;code&gt;search&lt;/code&gt;:</source>
          <target state="translated">Теперь, когда функция &lt;code&gt;search&lt;/code&gt; работает и протестирована, нам нужно вызвать &lt;code&gt;search&lt;/code&gt; из нашей функции &lt;code&gt;run&lt;/code&gt; . Нам нужно передать значение &lt;code&gt;config.query&lt;/code&gt; и &lt;code&gt;contents&lt;/code&gt; которое &lt;code&gt;run&lt;/code&gt; чтение из файла, в функцию &lt;code&gt;search&lt;/code&gt; . Затем &lt;code&gt;run&lt;/code&gt; напечатает каждую строку, полученную при &lt;code&gt;search&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="03229adf31a42bdb64eb9cba521d26f0154223d5" translate="yes" xml:space="preserve">
          <source>Now that the closure has its own copy of the data, there's no need to worry about safety.</source>
          <target state="translated">Теперь,когда у закрытия есть своя копия данных,нет необходимости беспокоиться о безопасности.</target>
        </trans-unit>
        <trans-unit id="80c8ae661a453d666a29851514f9590667d50328" translate="yes" xml:space="preserve">
          <source>Now that we have a library crate in the workspace, we can have the binary crate &lt;code&gt;adder&lt;/code&gt; depend on the library crate &lt;code&gt;add-one&lt;/code&gt;. First, we&amp;rsquo;ll need to add a path dependency on &lt;code&gt;add-one&lt;/code&gt; to &lt;em&gt;adder/Cargo.toml&lt;/em&gt;.</source>
          <target state="translated">Теперь, когда у нас есть ящик с библиотекой в ​​рабочей области, мы можем сделать так, чтобы двоичный &lt;code&gt;adder&lt;/code&gt; ящиков зависел от &lt;code&gt;add-one&lt;/code&gt; библиотеки . Во-первых, нам нужно добавить зависимость пути от &lt;code&gt;add-one&lt;/code&gt; в &lt;em&gt;adder / Cargo.toml&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="e1d03746f7af11550c4dab530f554fdd12c9b9be" translate="yes" xml:space="preserve">
          <source>Now that we have a way to know we have a valid number of threads to store in the pool, we can create those threads and store them in the &lt;code&gt;ThreadPool&lt;/code&gt; struct before returning it. But how do we &amp;ldquo;store&amp;rdquo; a thread? Let&amp;rsquo;s take another look at the &lt;code&gt;thread::spawn&lt;/code&gt; signature:</source>
          <target state="translated">Теперь, когда у нас есть способ узнать, что у нас есть допустимое количество потоков для хранения в пуле, мы можем создать эти потоки и сохранить их в структуре &lt;code&gt;ThreadPool&lt;/code&gt; перед ее возвратом. Но как нам &amp;laquo;хранить&amp;raquo; нить? Давайте еще раз посмотрим на подпись &lt;code&gt;thread::spawn&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="bda29c679c337b77198a68eb0c281ffe77fd4dfe" translate="yes" xml:space="preserve">
          <source>Now that we have an external dependency, Cargo fetches the latest versions of everything from the &lt;em&gt;registry&lt;/em&gt;, which is a copy of data from &lt;a href=&quot;https://crates.io/&quot;&gt;Crates.io&lt;/a&gt;. Crates.io is where people in the Rust ecosystem post their open source Rust projects for others to use.</source>
          <target state="translated">Теперь, когда у нас есть внешняя зависимость, Cargo извлекает последние версии всего из &lt;em&gt;реестра&lt;/em&gt; , который является копией данных из &lt;a href=&quot;https://crates.io/&quot;&gt;Crates.io&lt;/a&gt; . Crates.io - это место, где люди в экосистеме Rust публикуют свои проекты на Rust с открытым исходным кодом для использования другими.</target>
        </trans-unit>
        <trans-unit id="b1ccc08848b1ba0169c7f988c879a0f190ff1fea" translate="yes" xml:space="preserve">
          <source>Now that we have another package in the workspace, we can have the &lt;code&gt;adder&lt;/code&gt; package with our binary depend on the &lt;code&gt;add-one&lt;/code&gt; package, that has our library. First, we&amp;rsquo;ll need to add a path dependency on &lt;code&gt;add-one&lt;/code&gt; to &lt;em&gt;adder/Cargo.toml&lt;/em&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3228f1351fbe40c57701ca17a80dd025a6bfe94f" translate="yes" xml:space="preserve">
          <source>Now that we have the code to turn the annotated Rust code from a &lt;code&gt;TokenStream&lt;/code&gt; into a &lt;code&gt;DeriveInput&lt;/code&gt; instance, let&amp;rsquo;s generate the code that implements the &lt;code&gt;HelloMacro&lt;/code&gt; trait on the annotated type, as shown in Listing 19-33.</source>
          <target state="translated">Теперь, когда у нас есть код для &lt;code&gt;TokenStream&lt;/code&gt; аннотированного кода Rust из TokenStream в экземпляр &lt;code&gt;DeriveInput&lt;/code&gt; , давайте сгенерируем код, который реализует черту &lt;code&gt;HelloMacro&lt;/code&gt; для аннотированного типа, как показано в Листинге 19-33.</target>
        </trans-unit>
        <trans-unit id="a05d1adf4441c02b17aff2e4ed6b1b6d76dccfa3" translate="yes" xml:space="preserve">
          <source>Now that we have the context, let&amp;rsquo;s get to the algorithm. The function &lt;code&gt;generate_workout&lt;/code&gt; in Listing 13-3 contains the business logic of the app that we&amp;rsquo;re most concerned with in this example. The rest of the code changes in this example will be made to this function.</source>
          <target state="translated">Теперь, когда у нас есть контекст, давайте перейдем к алгоритму. Функция &lt;code&gt;generate_workout&lt;/code&gt; в листинге 13-3 содержит бизнес-логику приложения, которое нас больше всего интересует в этом примере. Остальные изменения кода в этом примере будут внесены в эту функцию.</target>
        </trans-unit>
        <trans-unit id="d0d7185e0fbe1a274eebe89e5b39be3986c2db0a" translate="yes" xml:space="preserve">
          <source>Now that we have user input and a random number, we can compare them. That step is shown in Listing 2-4. Note that this code won&amp;rsquo;t compile quite yet, as we will explain.</source>
          <target state="translated">Теперь, когда у нас есть вводимые пользователем данные и случайное число, мы можем их сравнить. Этот шаг показан в листинге 2-4. Обратите внимание, что этот код еще не компилируется, как мы объясним.</target>
        </trans-unit>
        <trans-unit id="38f50db14e5d3025086efbe8bea15a9ba8ef6b08" translate="yes" xml:space="preserve">
          <source>Now that we know what the browser is asking for, let&amp;rsquo;s send back some data!</source>
          <target state="translated">Теперь, когда мы знаем, что запрашивает браузер, давайте вернем некоторые данные!</target>
        </trans-unit>
        <trans-unit id="e92484795e9a806e19045c8bd7479798242a92b0" translate="yes" xml:space="preserve">
          <source>Now that we&amp;rsquo;ve defined the desired behavior using the &lt;code&gt;Summary&lt;/code&gt; trait, we can implement it on the types in our media aggregator. Listing 10-13 shows an implementation of the &lt;code&gt;Summary&lt;/code&gt; trait on the &lt;code&gt;NewsArticle&lt;/code&gt; struct that uses the headline, the author, and the location to create the return value of &lt;code&gt;summarize&lt;/code&gt;. For the &lt;code&gt;Tweet&lt;/code&gt; struct, we define &lt;code&gt;summarize&lt;/code&gt; as the username followed by the entire text of the tweet, assuming that tweet content is already limited to 280 characters.</source>
          <target state="translated">Теперь, когда мы определили желаемое поведение с помощью трейта &lt;code&gt;Summary&lt;/code&gt; , мы можем реализовать его для типов в нашем агрегаторе мультимедиа. В листинге 10-13 показана реализация трейта &lt;code&gt;Summary&lt;/code&gt; в структуре &lt;code&gt;NewsArticle&lt;/code&gt; , которая использует заголовок, автора и местоположение для создания возвращаемого значения &lt;code&gt;summarize&lt;/code&gt; . Для &lt;code&gt;Tweet&lt;/code&gt; структуры, мы определяем &lt;code&gt;summarize&lt;/code&gt; , как имя пользователя , а затем весь текст чирикать, при условии , что содержание твит уже ограничена 280 символами.</target>
        </trans-unit>
        <trans-unit id="847c864456f96a628c83e8df1e38c081c9008635" translate="yes" xml:space="preserve">
          <source>Now that we&amp;rsquo;ve defined threads in Rust, let&amp;rsquo;s explore how to use the thread-related API provided by the standard library.</source>
          <target state="translated">Теперь, когда мы определили потоки в Rust, давайте рассмотрим, как использовать связанный с потоками API, предоставляемый стандартной библиотекой.</target>
        </trans-unit>
        <trans-unit id="4bba9ff87fd1d7a113978a70c232f211dcf89ab4" translate="yes" xml:space="preserve">
          <source>Now that we&amp;rsquo;ve discussed some of the most common ways to use vectors, be sure to review &lt;a href=&quot;../std/vec/struct.vec&quot;&gt;the API documentation&lt;/a&gt; for all the many useful methods defined on &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; by the standard library. For example, in addition to &lt;code&gt;push&lt;/code&gt;, a &lt;code&gt;pop&lt;/code&gt; method removes and returns the last element. Let&amp;rsquo;s move on to the next collection type: &lt;code&gt;String&lt;/code&gt;!</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="87dd1868af24eb68dc999a15f4b71b72a52c4914" translate="yes" xml:space="preserve">
          <source>Now that we&amp;rsquo;ve discussed some of the most common ways to use vectors, be sure to review the API documentation for all the many useful methods defined on &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; by the standard library. For example, in addition to &lt;code&gt;push&lt;/code&gt;, a &lt;code&gt;pop&lt;/code&gt; method removes and returns the last element. Let&amp;rsquo;s move on to the next collection type: &lt;code&gt;String&lt;/code&gt;!</source>
          <target state="translated">Теперь, когда мы обсудили некоторые из наиболее распространенных способов использования векторов, обязательно просмотрите документацию по API для всех многих полезных методов, определенных в &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; стандартной библиотекой. Например, помимо &lt;code&gt;push&lt;/code&gt; , метод &lt;code&gt;pop&lt;/code&gt; удаляет и возвращает последний элемент. Перейдем к следующему типу коллекции: &lt;code&gt;String&lt;/code&gt; !</target>
        </trans-unit>
        <trans-unit id="2ec4c24a317d3f7bc3c352fa146805708f0bd185" translate="yes" xml:space="preserve">
          <source>Now that we&amp;rsquo;ve discussed the details of calling &lt;code&gt;panic!&lt;/code&gt; or returning &lt;code&gt;Result&lt;/code&gt;, let&amp;rsquo;s return to the topic of how to decide which is appropriate to use in which cases.</source>
          <target state="translated">Теперь, когда мы обсудили детали вызова &lt;code&gt;panic!&lt;/code&gt; или возвращая &lt;code&gt;Result&lt;/code&gt; , давайте вернемся к теме о том, как решить, что подходит для использования в каких случаях.</target>
        </trans-unit>
        <trans-unit id="dcf9675ca650b7816e93bbac61987240fde0e1c1" translate="yes" xml:space="preserve">
          <source>Now that we&amp;rsquo;ve examined &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; and some of the characteristics of smart pointers, let&amp;rsquo;s look at a few other smart pointers defined in the standard library.</source>
          <target state="translated">Теперь, когда мы изучили &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; и некоторые характеристики интеллектуальных указателей, давайте посмотрим на несколько других интеллектуальных указателей, определенных в стандартной библиотеке.</target>
        </trans-unit>
        <trans-unit id="1275cf5c5193957df5e8d9870d52448402e96389" translate="yes" xml:space="preserve">
          <source>Now that we&amp;rsquo;ve explored how variables work, let&amp;rsquo;s look at more data types they can have.</source>
          <target state="translated">Теперь, когда мы изучили, как работают переменные, давайте рассмотрим другие типы данных, которые они могут иметь.</target>
        </trans-unit>
        <trans-unit id="b53e79d7c3785836a15f4ecfc6aac9abee118b76" translate="yes" xml:space="preserve">
          <source>Now that we&amp;rsquo;ve extracted the logic into &lt;em&gt;src/lib.rs&lt;/em&gt; and left the argument collecting and error handling in &lt;em&gt;src/main.rs&lt;/em&gt;, it&amp;rsquo;s much easier to write tests for the core functionality of our code. We can call functions directly with various arguments and check return values without having to call our binary from the command line. Feel free to write some tests for the functionality in the &lt;code&gt;Config::new&lt;/code&gt; and &lt;code&gt;run&lt;/code&gt; functions on your own.</source>
          <target state="translated">Теперь, когда мы извлекли логику в &lt;em&gt;src / lib.rs&lt;/em&gt; и оставили сбор аргументов и обработку ошибок в &lt;em&gt;src / main.rs&lt;/em&gt; , стало намного проще писать тесты для основных функций нашего кода. Мы можем вызывать функции напрямую с различными аргументами и проверять возвращаемые значения без необходимости вызывать наш двоичный файл из командной строки. Не стесняйтесь писать несколько тестов для функциональности в &lt;code&gt;Config::new&lt;/code&gt; и &lt;code&gt;run&lt;/code&gt; функции самостоятельно.</target>
        </trans-unit>
        <trans-unit id="2a08eff4bb167e5da1e95f954b1304af56f21965" translate="yes" xml:space="preserve">
          <source>Now that we&amp;rsquo;ve finished refactoring the configuration parsing, let&amp;rsquo;s turn to the program&amp;rsquo;s logic. As we stated in &lt;a href=&quot;#separation-of-concerns-for-binary-projects&quot;&gt;&amp;ldquo;Separation of Concerns for Binary Projects&amp;rdquo;&lt;/a&gt;, we&amp;rsquo;ll extract a function named &lt;code&gt;run&lt;/code&gt; that will hold all the logic currently in the &lt;code&gt;main&lt;/code&gt; function that isn&amp;rsquo;t involved with setting up configuration or handling errors. When we&amp;rsquo;re done, &lt;code&gt;main&lt;/code&gt; will be concise and easy to verify by inspection, and we&amp;rsquo;ll be able to write tests for all the other logic.</source>
          <target state="translated">Теперь, когда мы закончили рефакторинг парсинга конфигурации, перейдем к логике программы. Как мы заявляли в &lt;a href=&quot;#separation-of-concerns-for-binary-projects&quot;&gt;разделе &amp;laquo;Разделение проблем для двоичных проектов&amp;raquo;&lt;/a&gt; , мы извлечем функцию с именем &lt;code&gt;run&lt;/code&gt; , которая будет содержать всю логику, которая в настоящее время находится в &lt;code&gt;main&lt;/code&gt; функции, которая не связана с настройкой конфигурации или обработкой ошибок. Когда мы закончим, &lt;code&gt;main&lt;/code&gt; будет кратким и легко проверяемым, и мы сможем писать тесты для всей остальной логики.</target>
        </trans-unit>
        <trans-unit id="67636ff52e1a7401207e61d89497c3656085f595" translate="yes" xml:space="preserve">
          <source>Now that we&amp;rsquo;ve improved the expressiveness of our I/O project, let&amp;rsquo;s look at some more features of &lt;code&gt;cargo&lt;/code&gt; that will help us share the project with the world.</source>
          <target state="translated">Теперь, когда мы улучшили выразительность нашего проекта ввода-вывода, давайте рассмотрим еще несколько функций &lt;code&gt;cargo&lt;/code&gt; , которые помогут нам поделиться проектом со всем миром.</target>
        </trans-unit>
        <trans-unit id="f8c732cbf77e2073635c5b38e31310fafb9b6c1e" translate="yes" xml:space="preserve">
          <source>Now that we&amp;rsquo;ve introduced iterators, we can demonstrate a common use of closures that capture their environment by using the &lt;code&gt;filter&lt;/code&gt; iterator adaptor. The &lt;code&gt;filter&lt;/code&gt; method on an iterator takes a closure that takes each item from the iterator and returns a Boolean. If the closure returns &lt;code&gt;true&lt;/code&gt;, the value will be included in the iterator produced by &lt;code&gt;filter&lt;/code&gt;. If the closure returns &lt;code&gt;false&lt;/code&gt;, the value won&amp;rsquo;t be included in the resulting iterator.</source>
          <target state="translated">Теперь, когда мы ввели итераторы, мы можем продемонстрировать обычное использование замыканий, которые захватывают их среду, с помощью адаптера &lt;code&gt;filter&lt;/code&gt; итератора. Метод &lt;code&gt;filter&lt;/code&gt; на итераторе принимает замыкание, которое берет каждый элемент из итератора и возвращает логическое значение. Если замыкание возвращает &lt;code&gt;true&lt;/code&gt; , значение будет включено в итератор, созданный &lt;code&gt;filter&lt;/code&gt; . Если замыкание возвращает &lt;code&gt;false&lt;/code&gt; , значение не будет включено в итоговый итератор.</target>
        </trans-unit>
        <trans-unit id="0f5c8cc4166bf098c054b91aa56eafdd80a280aa" translate="yes" xml:space="preserve">
          <source>Now that we&amp;rsquo;ve looked at how channels work, let&amp;rsquo;s look at a different method of concurrency.</source>
          <target state="translated">Теперь, когда мы рассмотрели, как работают каналы, давайте рассмотрим другой метод параллелизма.</target>
        </trans-unit>
        <trans-unit id="67653a6049372ba09d60cbd375a44f6c3cccaf9a" translate="yes" xml:space="preserve">
          <source>Now that we've got an idea of what unwind safety is in Rust, it's also important to understand what this trait represents. As mentioned above, one way to witness broken invariants is through the &lt;code&gt;catch_unwind&lt;/code&gt; function in this module as it allows catching a panic and then re-using the environment of the closure.</source>
          <target state="translated">Теперь, когда мы получили представление о том, что такое размоточная безопасность в Rust, также важно понять, что представляет собой эта черта. Как упоминалось выше, один из способов увидеть нарушенные инварианты - &lt;code&gt;catch_unwind&lt;/code&gt; функцию catch_unwind в этом модуле, поскольку она позволяет поймать панику и затем повторно использовать среду закрытия.</target>
        </trans-unit>
        <trans-unit id="d02969884890c4347910c461b721cc439357c5a4" translate="yes" xml:space="preserve">
          <source>Now that you have an account, let&amp;rsquo;s say you have a crate you want to publish. Before publishing, you&amp;rsquo;ll need to add some metadata to your crate by adding it to the &lt;code&gt;[package]&lt;/code&gt; section of the crate&amp;rsquo;s &lt;em&gt;Cargo.toml&lt;/em&gt; file.</source>
          <target state="translated">Теперь, когда у вас есть учетная запись, допустим, у вас есть ящик, который вы хотите опубликовать. Перед публикацией вам необходимо добавить некоторые метаданные в ваш ящик, добавив их в раздел &lt;code&gt;[package]&lt;/code&gt; файла &lt;em&gt;Cargo.toml&lt;/em&gt; ящика .</target>
        </trans-unit>
        <trans-unit id="09f54035802dcb8ec1dd44caa3ea32209f58c20d" translate="yes" xml:space="preserve">
          <source>Now that you know how to create, update, and destroy vectors, knowing how to read their contents is a good next step. There are two ways to reference a value stored in a vector. In the examples, we&amp;rsquo;ve annotated the types of the values that are returned from these functions for extra clarity.</source>
          <target state="translated">Теперь, когда вы знаете, как создавать, обновлять и уничтожать векторы, умение читать их содержимое - хороший следующий шаг. Есть два способа ссылаться на значение, хранящееся в векторе. В примерах мы аннотировали типы значений, возвращаемых этими функциями, для большей ясности.</target>
        </trans-unit>
        <trans-unit id="81f4f18161b98344a0f7e41a60ca860036728be7" translate="yes" xml:space="preserve">
          <source>Now that you know how to define and implement traits, we can explore how to use traits to define functions that accept many different types.</source>
          <target state="translated">Теперь,когда вы знаете,как определять и реализовывать трейты,мы можем изучить,как использовать трейты для определения функций,которые принимают множество различных типов.</target>
        </trans-unit>
        <trans-unit id="abb4d086b7b2c677929b00ae06d7123ecd180a15" translate="yes" xml:space="preserve">
          <source>Now that you know how to specify the behavior you want to use using the generic type parameter&amp;rsquo;s bounds, let&amp;rsquo;s return to Listing 10-5 to fix the definition of the &lt;code&gt;largest&lt;/code&gt; function that uses a generic type parameter! Last time we tried to run that code, we received this error:</source>
          <target state="translated">Теперь, когда вы знаете, как указать поведение, которое хотите использовать, используя границы параметра универсального типа, давайте вернемся к листингу 10-5, чтобы исправить определение самой &lt;code&gt;largest&lt;/code&gt; функции, использующей параметр универсального типа! В прошлый раз, когда мы пытались запустить этот код, мы получили эту ошибку:</target>
        </trans-unit>
        <trans-unit id="e396981103292f81034753c73fe592831d9392a8" translate="yes" xml:space="preserve">
          <source>Now that you know several ways to write tests, let&amp;rsquo;s look at what is happening when we run our tests and explore the different options we can use with &lt;code&gt;cargo test&lt;/code&gt;.</source>
          <target state="translated">Теперь, когда вы знаете несколько способов написания тестов, давайте посмотрим, что происходит, когда мы запускаем наши тесты, и исследуем различные варианты, которые мы можем использовать с &lt;code&gt;cargo test&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e62f4573546a99a0fd5e85dde630775910ab5fc8" translate="yes" xml:space="preserve">
          <source>Now that you know where the lifetimes of references are and how Rust analyzes lifetimes to ensure references will always be valid, let&amp;rsquo;s explore generic lifetimes of parameters and return values in the context of functions.</source>
          <target state="translated">Теперь, когда вы знаете, где находится время жизни ссылок и как Rust анализирует время жизни, чтобы гарантировать, что ссылки всегда будут действительными, давайте рассмотрим общие времена жизни параметров и возвращаемых значений в контексте функций.</target>
        </trans-unit>
        <trans-unit id="30a6477678dd7180d7e0d481486280f7e98fefae" translate="yes" xml:space="preserve">
          <source>Now that you know where to use patterns and the difference between refutable and irrefutable patterns, let&amp;rsquo;s cover all the syntax we can use to create patterns.</source>
          <target state="translated">Теперь, когда вы знаете, где использовать шаблоны и разницу между опровержимыми и неопровержимыми шаблонами, давайте рассмотрим весь синтаксис, который мы можем использовать для создания шаблонов.</target>
        </trans-unit>
        <trans-unit id="31528a068a5d3a841cff61741fee15a1c0b2479f" translate="yes" xml:space="preserve">
          <source>Now that you&amp;rsquo;ve added the &lt;code&gt;rand&lt;/code&gt; crate to &lt;em&gt;Cargo.toml&lt;/em&gt;, let&amp;rsquo;s start using &lt;code&gt;rand&lt;/code&gt;. The next step is to update &lt;em&gt;src/main.rs&lt;/em&gt;, as shown in Listing 2-3.</source>
          <target state="translated">Теперь, когда вы добавили ящик &lt;code&gt;rand&lt;/code&gt; в &lt;em&gt;Cargo.toml&lt;/em&gt; , давайте начнем использовать &lt;code&gt;rand&lt;/code&gt; . Следующим шагом является обновление &lt;em&gt;src / main.rs&lt;/em&gt; , как показано в листинге 2-3.</target>
        </trans-unit>
        <trans-unit id="25f40b5e485b1b15ed8e4d216ebb9b698b979c06" translate="yes" xml:space="preserve">
          <source>Now that you&amp;rsquo;ve created an account, saved your API token, chosen a name for your crate, and specified the required metadata, you&amp;rsquo;re ready to publish! Publishing a crate uploads a specific version to &lt;a href=&quot;https://crates.io/&quot;&gt;crates.io&lt;/a&gt; for others to use.</source>
          <target state="translated">Теперь, когда вы создали учетную запись, сохранили токен API, выбрали имя для своего ящика и указали необходимые метаданные, вы готовы к публикации! Публикация ящика загружает определенную версию на &lt;a href=&quot;https://crates.io/&quot;&gt;crates.io,&lt;/a&gt; чтобы ее могли использовать другие.</target>
        </trans-unit>
        <trans-unit id="920c59c826e17db818f515c07dfec7c798d59ee0" translate="yes" xml:space="preserve">
          <source>Now that you&amp;rsquo;ve installed Rust, let&amp;rsquo;s write your first Rust program. It&amp;rsquo;s traditional when learning a new language to write a little program that prints the text &lt;code&gt;Hello, world!&lt;/code&gt; to the screen, so we&amp;rsquo;ll do the same here!</source>
          <target state="translated">Теперь, когда вы установили Rust, давайте напишем вашу первую программу на Rust. При изучении нового языка принято писать небольшую программу, которая печатает текст &lt;code&gt;Hello, world!&lt;/code&gt; на экран, так что и здесь мы сделаем то же самое!</target>
        </trans-unit>
        <trans-unit id="da83ac95984492a0d09f569c59cd96503f2138e1" translate="yes" xml:space="preserve">
          <source>Now that you&amp;rsquo;ve seen how to use &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt;, let&amp;rsquo;s dig into how it works!</source>
          <target state="translated">Теперь, когда вы &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt; как использовать RefCell &amp;lt;T&amp;gt; , давайте рассмотрим, как это работает!</target>
        </trans-unit>
        <trans-unit id="3226e5056b022a9871764bceba61de34cf95da11" translate="yes" xml:space="preserve">
          <source>Now that you&amp;rsquo;ve seen useful ways that the standard library uses generics with the &lt;code&gt;Option&lt;/code&gt; and &lt;code&gt;Result&lt;/code&gt; enums, we&amp;rsquo;ll talk about how generics work and how you can use them in your code.</source>
          <target state="translated">Теперь, когда вы увидели полезные способы использования универсальных шаблонов в стандартной библиотеке с перечислениями &lt;code&gt;Option&lt;/code&gt; и &lt;code&gt;Result&lt;/code&gt; , мы поговорим о том, как работают универсальные шаблоны и как вы можете использовать их в своем коде.</target>
        </trans-unit>
        <trans-unit id="c62551adf3df866d6c2e2a8e1a359461a03ffa45" translate="yes" xml:space="preserve">
          <source>Now that you&amp;rsquo;ve seen what the test results look like in different scenarios, let&amp;rsquo;s look at some macros other than &lt;code&gt;panic!&lt;/code&gt; that are useful in tests.</source>
          <target state="translated">Теперь, когда вы увидели, как выглядят результаты теста в различных сценариях, давайте рассмотрим некоторые макросы, кроме &lt;code&gt;panic!&lt;/code&gt; которые полезны в тестах.</target>
        </trans-unit>
        <trans-unit id="b7ef50d26b9af16e9b7dc94b8c74f1d0f89a5d4f" translate="yes" xml:space="preserve">
          <source>Now the &lt;code&gt;if&lt;/code&gt; and &lt;code&gt;else&lt;/code&gt; blocks only return the appropriate values for the status line and filename in a tuple; we then use destructuring to assign these two values to &lt;code&gt;status_line&lt;/code&gt; and &lt;code&gt;filename&lt;/code&gt; using a pattern in the &lt;code&gt;let&lt;/code&gt; statement, as discussed in Chapter 18.</source>
          <target state="translated">Теперь блоки &lt;code&gt;if&lt;/code&gt; и &lt;code&gt;else&lt;/code&gt; возвращают только соответствующие значения для строки состояния и имени файла в кортеже; Затем мы используем деструктурирование, чтобы присвоить эти два значения &lt;code&gt;status_line&lt;/code&gt; и &lt;code&gt;filename&lt;/code&gt; , используя шаблон в операторе &lt;code&gt;let&lt;/code&gt; , как описано в главе 18.</target>
        </trans-unit>
        <trans-unit id="4c7125187714db67fed394d49d485e2e00abd4cb" translate="yes" xml:space="preserve">
          <source>Now the &lt;code&gt;search&lt;/code&gt; function should return only the lines that contain &lt;code&gt;query&lt;/code&gt;, and our test should pass. Let&amp;rsquo;s run the test:</source>
          <target state="translated">Теперь функция &lt;code&gt;search&lt;/code&gt; должна возвращать только строки, содержащие &lt;code&gt;query&lt;/code&gt; , и наш тест должен пройти. Запустим тест:</target>
        </trans-unit>
        <trans-unit id="522023e5be1135a608b1cd7f8c8337b4cfc43235" translate="yes" xml:space="preserve">
          <source>Now the code will compile! Let&amp;rsquo;s look at the absolute and the relative path and double-check why adding the &lt;code&gt;pub&lt;/code&gt; keyword lets us use these paths in &lt;code&gt;add_to_waitlist&lt;/code&gt; with respect to the privacy rules.</source>
          <target state="translated">Теперь код скомпилируется! Давайте посмотрим на абсолютный и относительный пути и дважды проверим, почему добавление ключевого слова &lt;code&gt;pub&lt;/code&gt; позволяет нам использовать эти пути в &lt;code&gt;add_to_waitlist&lt;/code&gt; с учетом правил конфиденциальности.</target>
        </trans-unit>
        <trans-unit id="9b0d5ba9ad57069914ace4b7ba7c228161663abb" translate="yes" xml:space="preserve">
          <source>Now the entire program should work! Let&amp;rsquo;s try it out, first with a word that should return exactly one line from the Emily Dickinson poem, &amp;ldquo;frog&amp;rdquo;:</source>
          <target state="translated">Теперь вся программа должна работать! Давайте попробуем, сначала со словом, которое должно возвращать ровно одну строку из стихотворения Эмили Дикинсон &amp;laquo;лягушка&amp;raquo;:</target>
        </trans-unit>
        <trans-unit id="acdcf552dc404df4d014e75904c60498b68c4c55" translate="yes" xml:space="preserve">
          <source>Now the error occurs because we don&amp;rsquo;t have an &lt;code&gt;execute&lt;/code&gt; method on &lt;code&gt;ThreadPool&lt;/code&gt;. Recall from the &lt;a href=&quot;#creating-a-similar-interface-for-a-finite-number-of-threads&quot;&gt;&amp;ldquo;Creating a Similar Interface for a Finite Number of Threads&amp;rdquo;&lt;/a&gt; section that we decided our thread pool should have an interface similar to &lt;code&gt;thread::spawn&lt;/code&gt;. In addition, we&amp;rsquo;ll implement the &lt;code&gt;execute&lt;/code&gt; function so it takes the closure it&amp;rsquo;s given and gives it to an idle thread in the pool to run.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="14d34886bdb2d79a108c1eb310a74fea56db9de1" translate="yes" xml:space="preserve">
          <source>Now the expensive calculation is called in only one place, and we&amp;rsquo;re only executing that code where we need the results.</source>
          <target state="translated">Теперь дорогостоящие вычисления вызываются только в одном месте, и мы выполняем этот код только там, где нам нужны результаты.</target>
        </trans-unit>
        <trans-unit id="e22993365c1cb308452dac73cf5565235b2c67e8" translate="yes" xml:space="preserve">
          <source>Now the program is getting interesting! There&amp;rsquo;s a lot going on in this little line. Notice that this is a &lt;code&gt;let&lt;/code&gt; statement, which is used to create a &lt;em&gt;variable&lt;/em&gt;. Here&amp;rsquo;s another example:</source>
          <target state="translated">Теперь программа становится интереснее! В этой маленькой строке много чего происходит. Обратите внимание, что это оператор &lt;code&gt;let&lt;/code&gt; , который используется для создания &lt;em&gt;переменной&lt;/em&gt; . Вот еще один пример:</target>
        </trans-unit>
        <trans-unit id="9b5e26741b88a54ad8284d61f9e2e51ca7f82268" translate="yes" xml:space="preserve">
          <source>Now the signature indicates that the function data borrowed from either &lt;code&gt;x&lt;/code&gt; or &lt;code&gt;y&lt;/code&gt;. Alternatively, you could change the body to not return data from &lt;code&gt;y&lt;/code&gt;:</source>
          <target state="translated">Теперь подпись указывает, что данные функции заимствованы из &lt;code&gt;x&lt;/code&gt; или &lt;code&gt;y&lt;/code&gt; . В качестве альтернативы вы можете изменить тело, чтобы не возвращать данные из &lt;code&gt;y&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="c1198ca2a8c86240e1af84c3d28743f89fded1ad" translate="yes" xml:space="preserve">
          <source>Now we can start seeing the advantages of the state pattern: the &lt;code&gt;request_review&lt;/code&gt; method on &lt;code&gt;Post&lt;/code&gt; is the same no matter its &lt;code&gt;state&lt;/code&gt; value. Each state is responsible for its own rules.</source>
          <target state="translated">Теперь мы можем начать видеть преимущества шаблона состояний: метод &lt;code&gt;request_review&lt;/code&gt; в &lt;code&gt;Post&lt;/code&gt; одинаков, независимо от его значения &lt;code&gt;state&lt;/code&gt; . Каждое государство отвечает за свои правила.</target>
        </trans-unit>
        <trans-unit id="0ea1cd6e6626b68365f6c8947fa55d16ff141954" translate="yes" xml:space="preserve">
          <source>Now we get a warning and an error. Ignoring the warning for a moment, the error occurs because we don&amp;rsquo;t have an &lt;code&gt;execute&lt;/code&gt; method on &lt;code&gt;ThreadPool&lt;/code&gt;. Recall from the &lt;a href=&quot;#creating-a-similar-interface-for-a-finite-number-of-threads&quot;&gt;&amp;ldquo;Creating a Similar Interface for a Finite Number of Threads&amp;rdquo;&lt;/a&gt; section that we decided our thread pool should have an interface similar to &lt;code&gt;thread::spawn&lt;/code&gt;. In addition, we&amp;rsquo;ll implement the &lt;code&gt;execute&lt;/code&gt; function so it takes the closure it&amp;rsquo;s given and gives it to an idle thread in the pool to run.</source>
          <target state="translated">Теперь получаем предупреждение и ошибку. Если на мгновение игнорировать предупреждение, ошибка возникает из-за того, что у нас нет метода &lt;code&gt;execute&lt;/code&gt; в &lt;code&gt;ThreadPool&lt;/code&gt; . Вспомните из раздела &lt;a href=&quot;#creating-a-similar-interface-for-a-finite-number-of-threads&quot;&gt;&amp;laquo;Создание&lt;/a&gt; подобного интерфейса для конечного числа потоков&amp;raquo;, что мы решили, что наш пул потоков должен иметь интерфейс, аналогичный &lt;code&gt;thread::spawn&lt;/code&gt; . Кроме того, мы реализуем функцию &lt;code&gt;execute&lt;/code&gt; , чтобы она принимала заданное закрытие и передавала его для запуска незанятому потоку в пуле.</target>
        </trans-unit>
        <trans-unit id="d7705a7f1894fbc9d3a536be0dfea4d6af32a807" translate="yes" xml:space="preserve">
          <source>Now we need to bring the code we moved to &lt;em&gt;src/lib.rs&lt;/em&gt; into the scope of the binary crate in &lt;em&gt;src/main.rs&lt;/em&gt;, as shown in Listing 12-14.</source>
          <target state="translated">Теперь нам нужно перенести код, который мы переместили в &lt;em&gt;src / lib.rs,&lt;/em&gt; в область видимости двоичного &lt;em&gt;контейнера&lt;/em&gt; в &lt;em&gt;src / main.rs&lt;/em&gt; , как показано в листинге 12-14.</target>
        </trans-unit>
        <trans-unit id="b54fd4c3b5f78dc6afcacc14a208e5f25a781f43" translate="yes" xml:space="preserve">
          <source>Now we need to update the &lt;code&gt;content&lt;/code&gt; method on &lt;code&gt;Post&lt;/code&gt;: if the state is &lt;code&gt;Published&lt;/code&gt;, we want to return the value in the post&amp;rsquo;s &lt;code&gt;content&lt;/code&gt; field; otherwise, we want to return an empty string slice, as shown in Listing 17-17:</source>
          <target state="translated">Теперь нам нужно обновить метод &lt;code&gt;content&lt;/code&gt; в &lt;code&gt;Post&lt;/code&gt; : если состояние &lt;code&gt;Published&lt;/code&gt; , мы хотим вернуть значение в поле &lt;code&gt;content&lt;/code&gt; ; в противном случае мы хотим вернуть пустой фрагмент строки, как показано в листинге 17-17:</target>
        </trans-unit>
        <trans-unit id="6174f1c624d6e6d6e079aee3674396394f363d5b" translate="yes" xml:space="preserve">
          <source>Now we see the error onscreen and &lt;em&gt;output.txt&lt;/em&gt; contains nothing, which is the behavior we expect of command line programs.</source>
          <target state="translated">Теперь мы видим ошибку на экране, а &lt;em&gt;файл output.txt&lt;/em&gt; ничего не содержит, чего мы ожидаем от программ командной строки.</target>
        </trans-unit>
        <trans-unit id="cdda59c39165af59e97381c7390ecfef3d12a8f6" translate="yes" xml:space="preserve">
          <source>Now we&amp;rsquo;ll add functionality to read the file that is specified in the &lt;code&gt;filename&lt;/code&gt; command line argument. First, we need a sample file to test it with: the best kind of file to use to make sure &lt;code&gt;minigrep&lt;/code&gt; is working is one with a small amount of text over multiple lines with some repeated words. Listing 12-3 has an Emily Dickinson poem that will work well! Create a file called &lt;em&gt;poem.txt&lt;/em&gt; at the root level of your project, and enter the poem &amp;ldquo;I&amp;rsquo;m Nobody! Who are you?&amp;rdquo;</source>
          <target state="translated">Теперь мы добавим функциональность для чтения файла, указанного в аргументе командной строки &lt;code&gt;filename&lt;/code&gt; . Во-первых, нам нужен образец файла для его тестирования: лучший тип файла для проверки &lt;code&gt;minigrep&lt;/code&gt; - это файл с небольшим количеством текста на нескольких строках с некоторыми повторяющимися словами. В листинге 12-3 есть стихотворение Эмили Дикинсон, которое подойдет! Создайте файл под названием &lt;em&gt;poem.txt&lt;/em&gt; на корневом уровне вашего проекта и введите стихотворение &amp;laquo;Я никто! Кто ты?&quot;</target>
        </trans-unit>
        <trans-unit id="dd1d31103e62a1ec520be0bcddbbbdb89e976849" translate="yes" xml:space="preserve">
          <source>Now we&amp;rsquo;ll add some types that implement the &lt;code&gt;Draw&lt;/code&gt; trait. We&amp;rsquo;ll provide the &lt;code&gt;Button&lt;/code&gt; type. Again, actually implementing a GUI library is beyond the scope of this book, so the &lt;code&gt;draw&lt;/code&gt; method won&amp;rsquo;t have any useful implementation in its body. To imagine what the implementation might look like, a &lt;code&gt;Button&lt;/code&gt; struct might have fields for &lt;code&gt;width&lt;/code&gt;, &lt;code&gt;height&lt;/code&gt;, and &lt;code&gt;label&lt;/code&gt;, as shown in Listing 17-7:</source>
          <target state="translated">Теперь мы добавим несколько типов, реализующих &lt;code&gt;Draw&lt;/code&gt; . Мы предоставим тип &lt;code&gt;Button&lt;/code&gt; . Опять же, реализация библиотеки GUI выходит за рамки этой книги, поэтому метод &lt;code&gt;draw&lt;/code&gt; не будет иметь какой-либо полезной реализации в своем теле. Чтобы представить, как может выглядеть реализация, структура &lt;code&gt;Button&lt;/code&gt; может иметь поля для &lt;code&gt;width&lt;/code&gt; , &lt;code&gt;height&lt;/code&gt; и &lt;code&gt;label&lt;/code&gt; , как показано в листинге 17-7:</target>
        </trans-unit>
        <trans-unit id="e57698dd0ca960cc0b20cbcaaf7560d2276dfedc" translate="yes" xml:space="preserve">
          <source>Now we&amp;rsquo;ll implement sending data in response to a client request. Responses have the following format:</source>
          <target state="translated">Теперь реализуем отправку данных в ответ на запрос клиента. Ответы имеют следующий формат:</target>
        </trans-unit>
        <trans-unit id="faa7223d94f8959f76182c7251992c3581bab825" translate="yes" xml:space="preserve">
          <source>Now we&amp;rsquo;ll implement the &lt;code&gt;Drop&lt;/code&gt; trait to call &lt;code&gt;join&lt;/code&gt; on each of the threads in the pool so they can finish the requests they&amp;rsquo;re working on before closing. Then we&amp;rsquo;ll implement a way to tell the threads they should stop accepting new requests and shut down. To see this code in action, we&amp;rsquo;ll modify our server to accept only two requests before gracefully shutting down its thread pool.</source>
          <target state="translated">Теперь мы реализуем &lt;code&gt;Drop&lt;/code&gt; для вызова &lt;code&gt;join&lt;/code&gt; для каждого из потоков в пуле, чтобы они могли завершить запросы, над которыми они работают, до закрытия. Затем мы реализуем способ сообщить потокам, что они должны прекратить прием новых запросов и завершить работу. Чтобы увидеть этот код в действии, мы изменим наш сервер так, чтобы он принимал только два запроса, прежде чем корректно закрыть его пул потоков.</target>
        </trans-unit>
        <trans-unit id="f36ce7a9b5e2c1e7eedfaeab844cfb65b78a49c0" translate="yes" xml:space="preserve">
          <source>Now we&amp;rsquo;ll tackle the problem that the closures given to &lt;code&gt;thread::spawn&lt;/code&gt; do absolutely nothing. Currently, we get the closure we want to execute in the &lt;code&gt;execute&lt;/code&gt; method. But we need to give &lt;code&gt;thread::spawn&lt;/code&gt; a closure to run when we create each &lt;code&gt;Worker&lt;/code&gt; during the creation of the &lt;code&gt;ThreadPool&lt;/code&gt;.</source>
          <target state="translated">Теперь мы решим проблему, заключающуюся в том, что замыкания, данные для &lt;code&gt;thread::spawn&lt;/code&gt; , абсолютно ничего не делают. В настоящее время мы получаем закрытие, которое хотим выполнить в методе &lt;code&gt;execute&lt;/code&gt; . Но нам нужно дать &lt;code&gt;thread::spawn&lt;/code&gt; закрытие для запуска при создании каждого &lt;code&gt;Worker&lt;/code&gt; во время создания &lt;code&gt;ThreadPool&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0ff72d33ea4877ceb607d0497b7819ecb5fe8345" translate="yes" xml:space="preserve">
          <source>Now we&amp;rsquo;ll work on fixing our error handling. Recall that attempting to access the values in the &lt;code&gt;args&lt;/code&gt; vector at index 1 or index 2 will cause the program to panic if the vector contains fewer than three items. Try running the program without any arguments; it will look like this:</source>
          <target state="translated">Теперь мы будем работать над исправлением нашей обработки ошибок. Напомним, что попытка доступа к значениям в векторе &lt;code&gt;args&lt;/code&gt; по индексу 1 или 2 вызовет панику программы, если вектор содержит менее трех элементов. Попробуйте запустить программу без аргументов; это будет выглядеть так:</target>
        </trans-unit>
        <trans-unit id="13208408fb234a6274c662e0cea2839eb0d4df4f" translate="yes" xml:space="preserve">
          <source>Now we&amp;rsquo;re tracking a starting &lt;em&gt;and&lt;/em&gt; an ending index, and we have even more values that were calculated from data in a particular state but aren&amp;rsquo;t tied to that state at all. We now have three unrelated variables floating around that need to be kept in sync.</source>
          <target state="translated">Теперь мы отслеживаем начальный &lt;em&gt;и&lt;/em&gt; конечный индексы, и у нас есть еще больше значений, которые были рассчитаны на основе данных в определенном состоянии, но совершенно не привязаны к этому состоянию. Теперь у нас есть три несвязанные переменные, которые необходимо синхронизировать.</target>
        </trans-unit>
        <trans-unit id="e2c6d85ff7e11c55ebfacf4a5ea15b76883f9037" translate="yes" xml:space="preserve">
          <source>Now when we call &lt;code&gt;first_word&lt;/code&gt;, we get back a single value that is tied to the underlying data. The value is made up of a reference to the starting point of the slice and the number of elements in the slice.</source>
          <target state="translated">Теперь, когда мы вызываем &lt;code&gt;first_word&lt;/code&gt; , мы получаем одно значение, привязанное к базовым данным. Значение состоит из ссылки на начальную точку среза и количества элементов в срезе.</target>
        </trans-unit>
        <trans-unit id="ae56f18fed45d04e5e1b1341584607fec330d0c6" translate="yes" xml:space="preserve">
          <source>Now when we run the program, we won&amp;rsquo;t get any errors, and we&amp;rsquo;ll see the following output:</source>
          <target state="translated">Теперь, когда мы запустим программу, мы не получим никаких ошибок и увидим следующий результат:</target>
        </trans-unit>
        <trans-unit id="a1e40e49d7c93a75ee26e23465f603f6bbef3e57" translate="yes" xml:space="preserve">
          <source>Now when we run the test, we&amp;rsquo;ll get a more informative error message:</source>
          <target state="translated">Теперь, когда мы запустим тест, мы получим более информативное сообщение об ошибке:</target>
        </trans-unit>
        <trans-unit id="77f2a1a56e2b0bc8d28e09777d58b6d63d25bdc8" translate="yes" xml:space="preserve">
          <source>Now you know how the newtype pattern is used in relation to traits; it&amp;rsquo;s also a useful pattern even when traits are not involved. Let&amp;rsquo;s switch focus and look at some advanced ways to interact with Rust&amp;rsquo;s type system.</source>
          <target state="translated">Теперь вы знаете, как паттерн newtype используется по отношению к признакам; это также полезный паттерн, даже если черты не задействованы. Давайте сменим фокус и рассмотрим некоторые продвинутые способы взаимодействия с системой типов Rust.</target>
        </trans-unit>
        <trans-unit id="698e184c44b77b78a4f0259358fd0568a9ef42f1" translate="yes" xml:space="preserve">
          <source>Now, &lt;code&gt;foo()&lt;/code&gt; can no longer be called on a trait object, but you will now be allowed to make a trait object, and that will be able to call any object-safe methods. With such a bound, one can still call &lt;code&gt;foo()&lt;/code&gt; on types implementing that trait that aren't behind trait objects.</source>
          <target state="translated">Теперь &lt;code&gt;foo()&lt;/code&gt; больше не может вызываться для объекта-признака, но теперь вам будет разрешено создавать объект-признак, и он сможет вызывать любые объектно-безопасные методы. С такой привязкой можно по-прежнему вызывать &lt;code&gt;foo()&lt;/code&gt; для типов, реализующих эту черту, которые не находятся за объектами черт.</target>
        </trans-unit>
        <trans-unit id="e2eab767e7fabf7d41783d8a69e9cbea73a62c87" translate="yes" xml:space="preserve">
          <source>Now, every time you call &lt;code&gt;rustc&lt;/code&gt; or &lt;code&gt;cargo&lt;/code&gt; inside of &lt;em&gt;~/projects/needs-nightly&lt;/em&gt;, &lt;code&gt;rustup&lt;/code&gt; will make sure that you are using nightly Rust, rather than your default of stable Rust. This comes in handy when you have a lot of Rust projects!</source>
          <target state="translated">Теперь, каждый раз, когда вы вызываете &lt;code&gt;rustc&lt;/code&gt; или &lt;code&gt;cargo&lt;/code&gt; внутри &lt;em&gt;~ / projects / needs- &lt;/em&gt; &lt;code&gt;rustup&lt;/code&gt; , rustup будет следить за тем, чтобы вы использовали ночной Rust, а не стабильный Rust по умолчанию. Это пригодится, когда у вас много проектов на Rust!</target>
        </trans-unit>
        <trans-unit id="e79236607753f413c66ac854a24fa640c09a981f" translate="yes" xml:space="preserve">
          <source>Now, if we have the following code:</source>
          <target state="translated">Теперь,если у нас есть следующий код:</target>
        </trans-unit>
        <trans-unit id="8bfc390ee5863dbfd9bc2b1fac71150d32bafb63" translate="yes" xml:space="preserve">
          <source>Now, let&amp;rsquo;s try to share a value between multiple threads using &lt;code&gt;Mutex&amp;lt;T&amp;gt;&lt;/code&gt;. We&amp;rsquo;ll spin up 10 threads and have them each increment a counter value by 1, so the counter goes from 0 to 10. Note that the next few examples will have compiler errors, and we&amp;rsquo;ll use those errors to learn more about using &lt;code&gt;Mutex&amp;lt;T&amp;gt;&lt;/code&gt; and how Rust helps us use it correctly. Listing 16-13 has our starting example:</source>
          <target state="translated">Теперь давайте попробуем разделить значение между несколькими потоками с помощью &lt;code&gt;Mutex&amp;lt;T&amp;gt;&lt;/code&gt; . Мы развернем 10 потоков, и каждый из них будет увеличивать значение счетчика на 1, поэтому счетчик переходит от 0 до 10. Обратите внимание, что в следующих нескольких примерах будут ошибки компилятора, и мы будем использовать эти ошибки, чтобы узнать больше об использовании &lt;code&gt;Mutex&amp;lt;T&amp;gt;&lt;/code&gt; и как Rust помогает нам правильно его использовать. В листинге 16-13 приведен наш начальный пример:</target>
        </trans-unit>
        <trans-unit id="12a0ede889bbdab76f8ecdca9c8b3f108a1224a8" translate="yes" xml:space="preserve">
          <source>Now, let&amp;rsquo;s try to share a value between multiple threads using &lt;code&gt;Mutex&amp;lt;T&amp;gt;&lt;/code&gt;. We&amp;rsquo;ll spin up 10 threads and have them each increment a counter value by 1, so the counter goes from 0 to 10. The next example in Listing 16-13 will have a compiler error, and we&amp;rsquo;ll use that error to learn more about using &lt;code&gt;Mutex&amp;lt;T&amp;gt;&lt;/code&gt; and how Rust helps us use it correctly.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4684dc088b34ae2083e2057208489a24262c5c09" translate="yes" xml:space="preserve">
          <source>Now, run this program using &lt;code&gt;cargo run&lt;/code&gt;:</source>
          <target state="translated">Теперь запустите эту программу, используя &lt;code&gt;cargo run&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="5f63a9b785af57bd0365b9cf3f0ad0d87a3314b8" translate="yes" xml:space="preserve">
          <source>Now, the alias &lt;code&gt;Kilometers&lt;/code&gt; is a &lt;em&gt;synonym&lt;/em&gt; for &lt;code&gt;i32&lt;/code&gt;; unlike the &lt;code&gt;Millimeters&lt;/code&gt; and &lt;code&gt;Meters&lt;/code&gt; types we created in Listing 19-15, &lt;code&gt;Kilometers&lt;/code&gt; is not a separate, new type. Values that have the type &lt;code&gt;Kilometers&lt;/code&gt; will be treated the same as values of type &lt;code&gt;i32&lt;/code&gt;:</source>
          <target state="translated">Теперь, псевдоним &lt;code&gt;Kilometers&lt;/code&gt; является &lt;em&gt;синонимом&lt;/em&gt; для &lt;code&gt;i32&lt;/code&gt; ; В отличие от типов &lt;code&gt;Millimeters&lt;/code&gt; и &lt;code&gt;Meters&lt;/code&gt; , которые мы создали в Листинге 19-15, &lt;code&gt;Kilometers&lt;/code&gt; не является отдельным новым типом. Значения типа &amp;laquo; &lt;code&gt;Kilometers&lt;/code&gt; будут обрабатываться так же, как значения типа &lt;code&gt;i32&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="89254150c2be7dc87d0a9f78d979708d51af3c47" translate="yes" xml:space="preserve">
          <source>Now, we can go further. Here are some erroneous code examples:</source>
          <target state="translated">Теперь мы можем пойти дальше.Вот несколько ошибочных примеров кода:</target>
        </trans-unit>
        <trans-unit id="0a10d92135d2873e2b02f8fce9c6f1692a0cbb60" translate="yes" xml:space="preserve">
          <source>Now, we can use &lt;code&gt;?&lt;/code&gt; instead of &lt;code&gt;match&lt;/code&gt;, and the return type makes a lot more sense: if the loop ever stops, it means that an error occurred. We don't even have to wrap the loop in an &lt;code&gt;Ok&lt;/code&gt; because &lt;code&gt;!&lt;/code&gt; coerces to &lt;code&gt;Result&amp;lt;!, ConnectionError&amp;gt;&lt;/code&gt; automatically.</source>
          <target state="translated">Теперь мы можем использовать &lt;code&gt;?&lt;/code&gt; вместо &lt;code&gt;match&lt;/code&gt; , и тип возвращаемого значения имеет гораздо больше смысла: если цикл когда-либо останавливается, это означает, что произошла ошибка. Нам даже не нужно заключать цикл в &lt;code&gt;Ok&lt;/code&gt; потому что &lt;code&gt;!&lt;/code&gt; автоматически приводит к &lt;code&gt;Result&amp;lt;!, ConnectionError&amp;gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="00574ee534bf3b794cc8e985f367f79be7646f65" translate="yes" xml:space="preserve">
          <source>Now, when the server disconnects, we exit the loop with an error instead of panicking. While it might be intuitive to simply return the error, we might want to wrap it in a &lt;a href=&quot;result/enum.result&quot;&gt;&lt;code&gt;Result&amp;lt;!, E&amp;gt;&lt;/code&gt;&lt;/a&gt; instead:</source>
          <target state="translated">Теперь, когда сервер отключается, мы выходим из цикла с ошибкой вместо паники. Хотя может показаться интуитивно понятным просто вернуть ошибку, мы могли бы вместо этого заключить ее в &lt;a href=&quot;result/enum.result&quot;&gt; &lt;code&gt;Result&amp;lt;!, E&amp;gt;&lt;/code&gt; &lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="63f5d491af12e32408bf602e1dfb4af7a20ca44f" translate="yes" xml:space="preserve">
          <source>Now, without changing any of the code, let&amp;rsquo;s build the project, as shown in Listing 2-2.</source>
          <target state="translated">Теперь, не меняя код, создадим проект, как показано в листинге 2-2.</target>
        </trans-unit>
        <trans-unit id="335506e2ff8a4e3e39e5a5e2b3fc6bf1463c0bb5" translate="yes" xml:space="preserve">
          <source>Now, you get all of the default values. Rust implements &lt;code&gt;Default&lt;/code&gt; for various primitives types.</source>
          <target state="translated">Теперь вы получите все значения по умолчанию. Rust реализует &lt;code&gt;Default&lt;/code&gt; для различных типов примитивов.</target>
        </trans-unit>
        <trans-unit id="019a7808328d4c7ef510130b49858e7cc7a93df4" translate="yes" xml:space="preserve">
          <source>NulError</source>
          <target state="translated">NulError</target>
        </trans-unit>
        <trans-unit id="0cb22fef16057827ecc4973a05f1f48159ecfb08" translate="yes" xml:space="preserve">
          <source>NulError::borrow</source>
          <target state="translated">NulError::borrow</target>
        </trans-unit>
        <trans-unit id="093c6ad11b2674276a386aef18e019c41e18c73d" translate="yes" xml:space="preserve">
          <source>NulError::borrow_mut</source>
          <target state="translated">NulError::borrow_mut</target>
        </trans-unit>
        <trans-unit id="2212c8b5028758465c03e3f70e4f2b53155ddf4f" translate="yes" xml:space="preserve">
          <source>NulError::cause</source>
          <target state="translated">NulError::cause</target>
        </trans-unit>
        <trans-unit id="29768f5bfd32a963dcb296b9cb20f40a82c74df5" translate="yes" xml:space="preserve">
          <source>NulError::clone</source>
          <target state="translated">NulError::clone</target>
        </trans-unit>
        <trans-unit id="11102afce6dc8292dc39655665283f8191fb13f1" translate="yes" xml:space="preserve">
          <source>NulError::clone_from</source>
          <target state="translated">NulError::clone_from</target>
        </trans-unit>
        <trans-unit id="f533f8602af54aaa16eff696d1575d42e14848a1" translate="yes" xml:space="preserve">
          <source>NulError::clone_into</source>
          <target state="translated">NulError::clone_into</target>
        </trans-unit>
        <trans-unit id="dbdb7cc3a8e4e6691a99909b0fc53de13cd8f2d3" translate="yes" xml:space="preserve">
          <source>NulError::description</source>
          <target state="translated">NulError::description</target>
        </trans-unit>
        <trans-unit id="90a567cb98b0dcdd50aff9ea97e9fff9eaab566d" translate="yes" xml:space="preserve">
          <source>NulError::eq</source>
          <target state="translated">NulError::eq</target>
        </trans-unit>
        <trans-unit id="5a4bafcb93f1795790aaa47109d1e73bf1dc48ee" translate="yes" xml:space="preserve">
          <source>NulError::fmt</source>
          <target state="translated">NulError::fmt</target>
        </trans-unit>
        <trans-unit id="fea70f345cef208acafc3c691d14a34ddbaffb2c" translate="yes" xml:space="preserve">
          <source>NulError::from</source>
          <target state="translated">NulError::from</target>
        </trans-unit>
        <trans-unit id="c667a60cc8a552cdd2774d6820e70ba3a6f7fa11" translate="yes" xml:space="preserve">
          <source>NulError::into</source>
          <target state="translated">NulError::into</target>
        </trans-unit>
        <trans-unit id="30b7683d9cdd43993a6fc1126ff7ee715887f7b2" translate="yes" xml:space="preserve">
          <source>NulError::into_vec</source>
          <target state="translated">NulError::into_vec</target>
        </trans-unit>
        <trans-unit id="0a051a00c0c437269ea80583c284491216e4bda7" translate="yes" xml:space="preserve">
          <source>NulError::ne</source>
          <target state="translated">NulError::ne</target>
        </trans-unit>
        <trans-unit id="2853d8c78438f77254b0a497c86fde1fc17dc043" translate="yes" xml:space="preserve">
          <source>NulError::nul_position</source>
          <target state="translated">NulError::nul_position</target>
        </trans-unit>
        <trans-unit id="266ad98111087a4df9e19e655c096e1306270de2" translate="yes" xml:space="preserve">
          <source>NulError::source</source>
          <target state="translated">NulError::source</target>
        </trans-unit>
        <trans-unit id="5a34a4566a411696ebf16a2b9ec49441272c8c0b" translate="yes" xml:space="preserve">
          <source>NulError::to_owned</source>
          <target state="translated">NulError::to_owned</target>
        </trans-unit>
        <trans-unit id="657290a7e7bc42a0480eee65c34175ba47172560" translate="yes" xml:space="preserve">
          <source>NulError::to_string</source>
          <target state="translated">NulError::to_string</target>
        </trans-unit>
        <trans-unit id="d1202df6e66660732652af8ec880ff1ae89ff7c3" translate="yes" xml:space="preserve">
          <source>NulError::try_from</source>
          <target state="translated">NulError::try_from</target>
        </trans-unit>
        <trans-unit id="1d16960d944bfade9db6cf467b0e67afd7e5faaf" translate="yes" xml:space="preserve">
          <source>NulError::try_into</source>
          <target state="translated">NulError::try_into</target>
        </trans-unit>
        <trans-unit id="1f3e1c8599374779dd8128ca0f06731901b2e4e4" translate="yes" xml:space="preserve">
          <source>NulError::type_id</source>
          <target state="translated">NulError::type_id</target>
        </trans-unit>
        <trans-unit id="109085beaaa80ac89858b283a64f7c75d7e5bb12" translate="yes" xml:space="preserve">
          <source>Null</source>
          <target state="translated">Null</target>
        </trans-unit>
        <trans-unit id="a7321f8049c14a666fefc1ca42149346db408d7b" translate="yes" xml:space="preserve">
          <source>Null-unchecked version</source>
          <target state="translated">Нулевая версия</target>
        </trans-unit>
        <trans-unit id="2276df81ba459368e74bc9d4361d3c8cfd09f1df" translate="yes" xml:space="preserve">
          <source>Nullable pointers</source>
          <target state="translated">Накладные указатели</target>
        </trans-unit>
        <trans-unit id="c25cad253b19d0908d73f07b038e8b9aad37e183" translate="yes" xml:space="preserve">
          <source>Number literals</source>
          <target state="translated">Числовые буквы</target>
        </trans-unit>
        <trans-unit id="bcec75d4dad01d7ef8298e79673d17da682b5ff9" translate="yes" xml:space="preserve">
          <source>Number of significant digits in base 2.</source>
          <target state="translated">Количество значащих цифр в базе 2.</target>
        </trans-unit>
        <trans-unit id="2805eca363fc3f5bc17c10d2663c97e212a66b12" translate="yes" xml:space="preserve">
          <source>Number of significant digits in base 2. Use &lt;a href=&quot;../primitive.f32#associatedconstant.MANTISSA_DIGITS&quot;&gt;&lt;code&gt;f32::MANTISSA_DIGITS&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="12801815bc7acefa87d6f150e6c4da3f8cfc4e2c" translate="yes" xml:space="preserve">
          <source>Number of significant digits in base 2. Use &lt;a href=&quot;../primitive.f64#associatedconstant.MANTISSA_DIGITS&quot;&gt;&lt;code&gt;f64::MANTISSA_DIGITS&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7e53821f70ae16079c4a6a64c52a91fae645bc5f" translate="yes" xml:space="preserve">
          <source>Numbers</source>
          <target state="translated">Numbers</target>
        </trans-unit>
        <trans-unit id="21e67f90f74a7a640f48c34557cd9804c3bb16bf" translate="yes" xml:space="preserve">
          <source>Numeric Operations</source>
          <target state="translated">Числовые операции</target>
        </trans-unit>
        <trans-unit id="46e7eddaee58aa04d38eef7cd137db7696751094" translate="yes" xml:space="preserve">
          <source>Numeric cast</source>
          <target state="translated">числовой кастинг</target>
        </trans-unit>
        <trans-unit id="5fc7eba5de8d1ad8c7f788326b72adec568ef6c6" translate="yes" xml:space="preserve">
          <source>Numeric literal of specific type</source>
          <target state="translated">числовой букварь конкретного типа</target>
        </trans-unit>
        <trans-unit id="1569010f07b1014b3cf4df2495e2025b598353cd" translate="yes" xml:space="preserve">
          <source>Numeric type</source>
          <target state="translated">числовой тип</target>
        </trans-unit>
        <trans-unit id="d74de684582cb87f5abe203c6987280191b1e915" translate="yes" xml:space="preserve">
          <source>Numeric types</source>
          <target state="translated">Числовые типы</target>
        </trans-unit>
        <trans-unit id="448f04fec46467e790879ea8707bb67f916a6de0" translate="yes" xml:space="preserve">
          <source>Numeric values used in this type don't have portable meanings, and different platforms may mask different amounts of them.</source>
          <target state="translated">Числовые значения,используемые в этом типе,не имеют переносимых значений,и разные платформы могут маскировать разные их количества.</target>
        </trans-unit>
        <trans-unit id="6c69dc5bbeb314ef78589c0047ce04c8e5006432" translate="yes" xml:space="preserve">
          <source>O(1)</source>
          <target state="translated">O(1)</target>
        </trans-unit>
        <trans-unit id="41a98fdd88fe9c4cdb77aa3ef162d2e340554b26" translate="yes" xml:space="preserve">
          <source>O(1)~</source>
          <target state="translated">O(1)~</target>
        </trans-unit>
        <trans-unit id="aae47a530dc867303fbce9c5d00c60595dd72df2" translate="yes" xml:space="preserve">
          <source>O(1)~*</source>
          <target state="translated">O(1)~*</target>
        </trans-unit>
        <trans-unit id="21c63d891edf29bd0dc5694a68dc0fe5e6523174" translate="yes" xml:space="preserve">
          <source>O(log n)</source>
          <target state="translated">O(log n)</target>
        </trans-unit>
        <trans-unit id="e74f9c141120b2be3e1dcb28f8561ddce1e8fcd1" translate="yes" xml:space="preserve">
          <source>O(log(n))</source>
          <target state="translated">O(log(n))</target>
        </trans-unit>
        <trans-unit id="eed5a0c9d789f93df61247fbcb2bb3a3c20ad0c2" translate="yes" xml:space="preserve">
          <source>O(m)*</source>
          <target state="translated">O(m)*</target>
        </trans-unit>
        <trans-unit id="0a498ed9d22d1c99ae0662d3eb2e582169c852e2" translate="yes" xml:space="preserve">
          <source>O(min(i, n-i))</source>
          <target state="translated">O(min(i,n-i)).</target>
        </trans-unit>
        <trans-unit id="dede0f12fa78bfb74f3fa2188214d44df32644d9" translate="yes" xml:space="preserve">
          <source>O(min(i, n-i))*</source>
          <target state="translated">O(min(i,n-i))*</target>
        </trans-unit>
        <trans-unit id="1eb19fcfc5873ac1d44e4d58ddd8518a66a4491a" translate="yes" xml:space="preserve">
          <source>O(n+m)</source>
          <target state="translated">O(n+m)</target>
        </trans-unit>
        <trans-unit id="c8fadbf37575cb84317acb6f8d4f3d46463f8753" translate="yes" xml:space="preserve">
          <source>O(n-i)</source>
          <target state="translated">O(n-i)</target>
        </trans-unit>
        <trans-unit id="cc8b4f2a60d0d1f3741e6ca4292cce74adf6d07a" translate="yes" xml:space="preserve">
          <source>O(n-i)*</source>
          <target state="translated">O(n-i)*</target>
        </trans-unit>
        <trans-unit id="40df041793dd78f66b71a0840b6daf38640d0a3a" translate="yes" xml:space="preserve">
          <source>OCT_DIGIT : [&lt;code&gt;0&lt;/code&gt;-&lt;code&gt;7&lt;/code&gt;]</source>
          <target state="translated">OCT_DIGIT: [ &lt;code&gt;0&lt;/code&gt; - &lt;code&gt;7&lt;/code&gt; ]</target>
        </trans-unit>
        <trans-unit id="2458dc9d400f320af963a0c090896d1bb8a3eafb" translate="yes" xml:space="preserve">
          <source>OCT_LITERAL :</source>
          <target state="translated">OCT_LITERAL :</target>
        </trans-unit>
        <trans-unit id="7eefb54fc6fa85bcfd8cad8fd3e002943372f832" translate="yes" xml:space="preserve">
          <source>ONCE_INIT</source>
          <target state="translated">ONCE_INIT</target>
        </trans-unit>
        <trans-unit id="de8aa86286dbb8eb74d2748c7b6d4486d0458203" translate="yes" xml:space="preserve">
          <source>OS</source>
          <target state="translated">OS</target>
        </trans-unit>
        <trans-unit id="7367af2af477750e5937879b87fd589c058636c7" translate="yes" xml:space="preserve">
          <source>OS-specific behaviors</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c616ed05e5cb0d4373e277ab3e8348ce34b627e9" translate="yes" xml:space="preserve">
          <source>OS-specific extensions to &lt;a href=&quot;../../../fs/struct.metadata&quot;&gt;&lt;code&gt;fs::Metadata&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Расширения для конкретной ОС для &lt;a href=&quot;../../../fs/struct.metadata&quot;&gt; &lt;code&gt;fs::Metadata&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="d40770bb8444e5820c3f38469b205f65cc11cae4" translate="yes" xml:space="preserve">
          <source>OS-specific functionality.</source>
          <target state="translated">Функциональность,специфичная для операционной системы.</target>
        </trans-unit>
        <trans-unit id="a6c434024b24606a906b9f03f39592fffa3be309" translate="yes" xml:space="preserve">
          <source>OUTER_BLOCK_DOC :</source>
          <target state="translated">OUTER_BLOCK_DOC :</target>
        </trans-unit>
        <trans-unit id="0bb940376a39f5fb9ff8c9b1c3a635c5bc777eb9" translate="yes" xml:space="preserve">
          <source>OUTER_LINE_DOC :</source>
          <target state="translated">OUTER_LINE_DOC :</target>
        </trans-unit>
        <trans-unit id="497044c1c5d284e50b6c69945072ebc9add34281" translate="yes" xml:space="preserve">
          <source>Object Oriented Programming Features of Rust</source>
          <target state="translated">Объектно-ориентированное программирование Особенности ржавчины</target>
        </trans-unit>
        <trans-unit id="1cd60d3a8e30cd469c24d35e86095d88eed38ea9" translate="yes" xml:space="preserve">
          <source>Object Safety</source>
          <target state="translated">Безопасность объектов</target>
        </trans-unit>
        <trans-unit id="907637cc210857e2030448d19632670732a6954a" translate="yes" xml:space="preserve">
          <source>Object Safety Is Required for Trait Objects</source>
          <target state="translated">Безопасность объектов является обязательным требованием для объектов,предназначенных для эксплуатации.</target>
        </trans-unit>
        <trans-unit id="bca6b9d231b55a9e6e8a10f5e5322c009f386439" translate="yes" xml:space="preserve">
          <source>Object safe traits</source>
          <target state="translated">Безопасные черты объекта</target>
        </trans-unit>
        <trans-unit id="c0123c00fdac3367f93d574c1f48635a32708f0d" translate="yes" xml:space="preserve">
          <source>Object safe traits can be the base trait of a &lt;a href=&quot;../types/trait-object&quot;&gt;trait object&lt;/a&gt;. A trait is &lt;em&gt;object safe&lt;/em&gt; if it has the following qualities (defined in &lt;a href=&quot;https://github.com/rust-lang/rfcs/blob/master/text/0255-object-safety.md&quot;&gt;RFC 255&lt;/a&gt;):</source>
          <target state="translated">Безопасные для объекта черты могут быть базовой &lt;a href=&quot;../types/trait-object&quot;&gt;чертой объекта-признака&lt;/a&gt; . Признак является &lt;em&gt;объектно-безопасным,&lt;/em&gt; если он имеет следующие качества (определенные в &lt;a href=&quot;https://github.com/rust-lang/rfcs/blob/master/text/0255-object-safety.md&quot;&gt;RFC 255&lt;/a&gt; ):</target>
        </trans-unit>
        <trans-unit id="23297e036939da16d72f8c944d8900bfb5bf3104" translate="yes" xml:space="preserve">
          <source>Object-oriented programming (OOP) is a way of modeling programs. Objects came from Simula in the 1960s. Those objects influenced Alan Kay&amp;rsquo;s programming architecture in which objects pass messages to each other. He coined the term &lt;em&gt;object-oriented programming&lt;/em&gt; in 1967 to describe this architecture. Many competing definitions describe what OOP is; some definitions would classify Rust as object oriented, but other definitions would not. In this chapter, we&amp;rsquo;ll explore certain characteristics that are commonly considered object oriented and how those characteristics translate to idiomatic Rust. We&amp;rsquo;ll then show you how to implement an object-oriented design pattern in Rust and discuss the trade-offs of doing so versus implementing a solution using some of Rust&amp;rsquo;s strengths instead.</source>
          <target state="translated">Объектно-ориентированное программирование (ООП) - это способ моделирования программ. Объекты пришли из Simula в 1960-х. Эти объекты повлияли на архитектуру программирования Алана Кея, в которой объекты передают сообщения друг другу. Он ввел термин &lt;em&gt;объектно-ориентированное программирование&lt;/em&gt; в 1967 году для описания этой архитектуры. Многие конкурирующие определения описывают, что такое ООП; некоторые определения классифицируют Rust как объектно-ориентированный, а другие нет. В этой главе мы исследуем некоторые характеристики, которые обычно считаются объектно-ориентированными, и то, как эти характеристики переводятся в идиоматический Rust. Затем мы покажем вам, как реализовать объектно-ориентированный шаблон проектирования в Rust, и обсудим компромиссы этого по сравнению с реализацией решения с использованием вместо этого некоторых сильных сторон Rust.</target>
        </trans-unit>
        <trans-unit id="93a2f7998a1b0abd936ff0b0c2f570cbbedd6635" translate="yes" xml:space="preserve">
          <source>Object-oriented programs are made up of objects. An &lt;em&gt;object&lt;/em&gt; packages both data and the procedures that operate on that data. The procedures are typically called &lt;em&gt;methods&lt;/em&gt; or &lt;em&gt;operations&lt;/em&gt;.</source>
          <target state="translated">Объектно-ориентированные программы состоят из объектов. An &lt;em&gt;объект&lt;/em&gt; пакеты как данные , так и процедуры , которые работают на этих данных. Процедуры обычно называются &lt;em&gt;методами&lt;/em&gt; или &lt;em&gt;операциями&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="69fa88294fcaac54902a4347d53a07e91ef5771c" translate="yes" xml:space="preserve">
          <source>Objects Contain Data and Behavior</source>
          <target state="translated">Объекты содержат данные и поведение</target>
        </trans-unit>
        <trans-unit id="d206d3fa18be5581f351f10db48f9bf4a1014628" translate="yes" xml:space="preserve">
          <source>Objects that can be stepped over in both directions.</source>
          <target state="translated">Объекты,которые могут быть перешагнуты в обоих направлениях.</target>
        </trans-unit>
        <trans-unit id="c6ec1c4f32b6ec8b2dd6c5acb228ddee1480f8b1" translate="yes" xml:space="preserve">
          <source>Objects that have a notion of &lt;em&gt;successor&lt;/em&gt; and &lt;em&gt;predecessor&lt;/em&gt; operations.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b899f01274e7bc44fb14d411dd765a15a7787c5f" translate="yes" xml:space="preserve">
          <source>Occasionally it may be desirable not to expose in an API that there is mutation happening &quot;under the hood&quot;. This may be because logically the operation is immutable, but e.g., caching forces the implementation to perform mutation; or because you must employ mutation to implement a trait method that was originally defined to take &lt;code&gt;&amp;amp;self&lt;/code&gt;.</source>
          <target state="translated">Иногда может быть желательно не раскрывать в API, что мутация происходит &amp;laquo;под капотом&amp;raquo;. Это может быть связано с тем, что логически операция неизменна, но, например, кеширование заставляет реализацию выполнять мутацию; или потому, что вы должны использовать мутацию для реализации метода черты, который изначально был определен как take &lt;code&gt;&amp;amp;self&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="473e728a2f59da64c670799897819b1d614ba35f" translate="yes" xml:space="preserve">
          <source>OccupiedEntry</source>
          <target state="translated">OccupiedEntry</target>
        </trans-unit>
        <trans-unit id="9d9953ee64c9a9ed960498f1a51e79c8aae9c8dd" translate="yes" xml:space="preserve">
          <source>Occurrences of &lt;code&gt;.&lt;/code&gt; are normalized away, except if they are at the beginning of the path. For example, &lt;code&gt;a/./b&lt;/code&gt;, &lt;code&gt;a/b/&lt;/code&gt;, &lt;code&gt;a/b/.&lt;/code&gt; and &lt;code&gt;a/b&lt;/code&gt; all have &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; as components, but &lt;code&gt;./a/b&lt;/code&gt; starts with an additional &lt;a href=&quot;enum.component#variant.CurDir&quot;&gt;&lt;code&gt;CurDir&lt;/code&gt;&lt;/a&gt; component.</source>
          <target state="translated">Появления &lt;code&gt;.&lt;/code&gt; нормализованы, кроме случаев, когда они находятся в начале пути. Например, &lt;code&gt;a/./b&lt;/code&gt; , &lt;code&gt;a/b/&lt;/code&gt; , &lt;code&gt;a/b/.&lt;/code&gt; и &lt;code&gt;a/b&lt;/code&gt; имеют &lt;code&gt;a&lt;/code&gt; качестве компонентов a и &lt;code&gt;b&lt;/code&gt; , но &lt;code&gt;./a/b&lt;/code&gt; начинается с дополнительного компонента &lt;a href=&quot;enum.component#variant.CurDir&quot;&gt; &lt;code&gt;CurDir&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="10500e54805775e3d661be35724e87f0b1dbc4c9" translate="yes" xml:space="preserve">
          <source>Octal</source>
          <target state="translated">Octal</target>
        </trans-unit>
        <trans-unit id="e6f02e23e2b227ac6699b92be300da464d475a6e" translate="yes" xml:space="preserve">
          <source>Octal integer</source>
          <target state="translated">целое октября</target>
        </trans-unit>
        <trans-unit id="d04577406c042a11b4da7bb39486816308c607a6" translate="yes" xml:space="preserve">
          <source>Octal::fmt</source>
          <target state="translated">Octal::fmt</target>
        </trans-unit>
        <trans-unit id="615b20b5b110a1806177c985ebbca57031daa785" translate="yes" xml:space="preserve">
          <source>Of course, knowing which collection is the right one for the job doesn't instantly permit you to use it correctly. Here are some quick tips for efficient and correct usage of the standard collections in general. If you're interested in how to use a specific collection in particular, consult its documentation for detailed discussion and code examples.</source>
          <target state="translated">Конечно,знание того,какая коллекция подходит для данной работы,не сразу позволяет правильно ее использовать.Вот несколько быстрых советов по эффективному и правильному использованию стандартных коллекций в целом.Если вас интересует,как использовать конкретную коллекцию в частности,проконсультируйтесь с ее документацией для подробного обсуждения и примеров кода.</target>
        </trans-unit>
        <trans-unit id="2cbe09e34f3d1d91d444d3537b55bb92b3326aea" translate="yes" xml:space="preserve">
          <source>Of course, using &lt;a href=&quot;fn.stdout&quot;&gt;&lt;code&gt;io::stdout&lt;/code&gt;&lt;/a&gt; directly is less common than something like &lt;a href=&quot;../macro.println&quot;&gt;&lt;code&gt;println!&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Конечно, прямое использование &lt;a href=&quot;fn.stdout&quot;&gt; &lt;code&gt;io::stdout&lt;/code&gt; &lt;/a&gt; менее распространено, чем что-то вроде &lt;a href=&quot;../macro.println&quot;&gt; &lt;code&gt;println!&lt;/code&gt; &lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="35c2f4d3ee9ba6ff467650c366d5a389ebdd0812" translate="yes" xml:space="preserve">
          <source>Of course, you can do it as long as the module you're referring to is an ancestor:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="35d478ea3e054425d68cac2b881bb4303c629df5" translate="yes" xml:space="preserve">
          <source>Often, you&amp;rsquo;ll want to combine two existing strings. One way is to use the &lt;code&gt;+&lt;/code&gt; operator, as shown in Listing 8-18.</source>
          <target state="translated">Часто вам нужно объединить две существующие строки. Один из способов - использовать оператор &lt;code&gt;+&lt;/code&gt; , как показано в листинге 8-18.</target>
        </trans-unit>
        <trans-unit id="3894dea4e557c370e601b5214f719623a770bfec" translate="yes" xml:space="preserve">
          <source>On &lt;code&gt;packed&lt;/code&gt; structs</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6b1d4e18544489b4eaf442b238d12d6d0846066b" translate="yes" xml:space="preserve">
          <source>On Linux systems, if this is compiled as &lt;code&gt;foo&lt;/code&gt;:</source>
          <target state="translated">В системах Linux, если это скомпилировано как &lt;code&gt;foo&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="81c83f6982dcc0359616815ff2d1c2e0f9aa8bfa" translate="yes" xml:space="preserve">
          <source>On Linux, macOS, and PowerShell on Windows, you can see the executable by entering the &lt;code&gt;ls&lt;/code&gt; command in your shell. On Linux and macOS, you&amp;rsquo;ll see two files. With PowerShell on Windows, you&amp;rsquo;ll see the same three files that you would see using CMD.</source>
          <target state="translated">В Linux, macOS и PowerShell в Windows вы можете увидеть исполняемый файл, введя команду &lt;code&gt;ls&lt;/code&gt; в своей оболочке. В Linux и macOS вы увидите два файла. С PowerShell в Windows вы увидите те же три файла, что и при использовании CMD.</target>
        </trans-unit>
        <trans-unit id="7fc3d52902162d74f8ed313c5de739bb86f3a25d" translate="yes" xml:space="preserve">
          <source>On Linux:</source>
          <target state="translated">На Linux:</target>
        </trans-unit>
        <trans-unit id="28f964279968ee11e024ad4734a1849f6d567b40" translate="yes" xml:space="preserve">
          <source>On Redox this always returns &lt;code&gt;None&lt;/code&gt;.</source>
          <target state="translated">В Redox это всегда возвращает &lt;code&gt;None&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2c27c55a04c34d1416124c71c1487f965daf5e2b" translate="yes" xml:space="preserve">
          <source>On Unix</source>
          <target state="translated">На Unix</target>
        </trans-unit>
        <trans-unit id="f580d63739e00a5c78d3db723e0a54f4eebdec61" translate="yes" xml:space="preserve">
          <source>On Unix platforms, calling this method corresponds to calling &lt;code&gt;fcntl&lt;/code&gt;&lt;code&gt;FIONBIO&lt;/code&gt;. On Windows calling this method corresponds to calling &lt;code&gt;ioctlsocket&lt;/code&gt;&lt;code&gt;FIONBIO&lt;/code&gt;.</source>
          <target state="translated">На платформах Unix вызов этого метода соответствует вызову &lt;code&gt;fcntl&lt;/code&gt; &lt;code&gt;FIONBIO&lt;/code&gt; . В Windows вызов этого метода соответствует вызову &lt;code&gt;ioctlsocket&lt;/code&gt; &lt;code&gt;FIONBIO&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="368e8ed37eeed58c150496b19476b91dc7031ee8" translate="yes" xml:space="preserve">
          <source>On Unix platforms, the underlying syscall may be interrupted by a spurious wakeup or signal handler. To ensure the sleep occurs for at least the specified duration, this function may invoke that system call multiple times.</source>
          <target state="translated">На Unix-платформах базовый системный вызов может быть прерван поддельным пробуждением или обработчиком сигнала.Чтобы гарантировать,что сон происходит как минимум в течение заданной продолжительности,эта функция может вызвать системный вызов несколько раз.</target>
        </trans-unit>
        <trans-unit id="5d8d403cb28547a9afda373b97085e009420f7cc" translate="yes" xml:space="preserve">
          <source>On Unix platforms, the underlying syscall may be interrupted by a spurious wakeup or signal handler. To ensure the sleep occurs for at least the specified duration, this function may invoke that system call multiple times. Platforms which do not support nanosecond precision for sleeping will have &lt;code&gt;dur&lt;/code&gt; rounded up to the nearest granularity of time they can sleep for.</source>
          <target state="translated">На платформах Unix базовый системный вызов может быть прерван ложным пробуждением или обработчиком сигнала. Чтобы гарантировать, что сон продолжается по крайней мере на указанную продолжительность, эта функция может вызывать этот системный вызов несколько раз. Платформы , которые не поддерживают точность наносекунд для сна будет иметь &lt;code&gt;dur&lt;/code&gt; округляются до ближайшей зернистости времени они могут спать на.</target>
        </trans-unit>
        <trans-unit id="f15b383f304eefe4931d61a084a59f34627760f4" translate="yes" xml:space="preserve">
          <source>On Unix systems shell usually expands unquoted arguments with glob patterns (such as &lt;code&gt;*&lt;/code&gt; and &lt;code&gt;?&lt;/code&gt;). On Windows this is not done, and such arguments are passed as-is.</source>
          <target state="translated">В системах Unix оболочка обычно расширяет аргументы без кавычек с помощью глобальных шаблонов (таких как &lt;code&gt;*&lt;/code&gt; и &lt;code&gt;?&lt;/code&gt; ). В Windows этого не происходит, и такие аргументы передаются как есть.</target>
        </trans-unit>
        <trans-unit id="35aecf3282b41109feea97145ac8fcf33e5a85c0" translate="yes" xml:space="preserve">
          <source>On Unix systems the shell usually expands unquoted arguments with glob patterns (such as &lt;code&gt;*&lt;/code&gt; and &lt;code&gt;?&lt;/code&gt;). On Windows this is not done, and such arguments are passed as-is.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="73ed9ce935220230672af1ba06994403c22fd01d" translate="yes" xml:space="preserve">
          <source>On Unix systems when pthread-based TLS is being used, destructors will not be run for TLS values on the main thread when it exits. Note that the application will exit immediately after the main thread exits as well.</source>
          <target state="translated">На Unix-системах при использовании pthread-based TLS деструкторы не будут запускаться для значений TLS на главном потоке при его выходе.Обратите внимание,что приложение также выйдет сразу после выхода основного потока.</target>
        </trans-unit>
        <trans-unit id="fb3ee6950e481b93ea06bd207e97b8f1a208a9e6" translate="yes" xml:space="preserve">
          <source>On Unix systems, strings are often arbitrary sequences of non-zero bytes, in many cases interpreted as UTF-8.</source>
          <target state="translated">На Unix-системах строки часто представляют собой произвольные последовательности ненулевых байтов,во многих случаях интерпретируемые как UTF-8.</target>
        </trans-unit>
        <trans-unit id="ade1ebaf1f97bbb67b44937124b853209f01a0de" translate="yes" xml:space="preserve">
          <source>On Unix, &lt;a href=&quot;struct.osstr&quot;&gt;&lt;code&gt;OsStr&lt;/code&gt;&lt;/a&gt; implements the &lt;code&gt;std::os::unix::ffi::&lt;/code&gt;&lt;a href=&quot;../os/unix/ffi/trait.osstrext&quot;&gt;&lt;code&gt;OsStrExt&lt;/code&gt;&lt;/a&gt; trait, which augments it with two methods, &lt;a href=&quot;../os/unix/ffi/trait.osstrext#tymethod.from_bytes&quot;&gt;&lt;code&gt;from_bytes&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../os/unix/ffi/trait.osstrext#tymethod.as_bytes&quot;&gt;&lt;code&gt;as_bytes&lt;/code&gt;&lt;/a&gt;. These do inexpensive conversions from and to UTF-8 byte slices.</source>
          <target state="translated">В Unix &lt;a href=&quot;struct.osstr&quot;&gt; &lt;code&gt;OsStr&lt;/code&gt; &lt;/a&gt; реализует трейт &lt;code&gt;std::os::unix::ffi::&lt;/code&gt; &lt;a href=&quot;../os/unix/ffi/trait.osstrext&quot;&gt; &lt;code&gt;OsStrExt&lt;/code&gt; &lt;/a&gt; :: OsStrExt , который дополняет его двумя методами, &lt;a href=&quot;../os/unix/ffi/trait.osstrext#tymethod.from_bytes&quot;&gt; &lt;code&gt;from_bytes&lt;/code&gt; &lt;/a&gt; и &lt;a href=&quot;../os/unix/ffi/trait.osstrext#tymethod.as_bytes&quot;&gt; &lt;code&gt;as_bytes&lt;/code&gt; &lt;/a&gt; . Они делают недорогие преобразования из и в байтовые сегменты UTF-8.</target>
        </trans-unit>
        <trans-unit id="947b55450ee1839446a5472dd42bc83b983d60aa" translate="yes" xml:space="preserve">
          <source>On Unix, a path has a root if it begins with &lt;code&gt;/&lt;/code&gt;.</source>
          <target state="translated">В Unix у пути есть корень, если он начинается с &lt;code&gt;/&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3bd3b4c86524e4799caf099ecd37af36c6672deb" translate="yes" xml:space="preserve">
          <source>On Unix, a path is absolute if it starts with the root, so &lt;code&gt;is_absolute&lt;/code&gt; and &lt;a href=&quot;#method.has_root&quot;&gt;&lt;code&gt;has_root&lt;/code&gt;&lt;/a&gt; are equivalent.</source>
          <target state="translated">В Unix путь является абсолютным, если он начинается с корня, поэтому &lt;code&gt;is_absolute&lt;/code&gt; и &lt;a href=&quot;#method.has_root&quot;&gt; &lt;code&gt;has_root&lt;/code&gt; &lt;/a&gt; эквивалентны.</target>
        </trans-unit>
        <trans-unit id="c1d8cd80a5b3e4b5d2416174dfc8848e290d79c0" translate="yes" xml:space="preserve">
          <source>On Unix, a path is absolute if it starts with the root, so &lt;code&gt;is_absolute&lt;/code&gt; and &lt;a href=&quot;struct.path#method.has_root&quot;&gt;&lt;code&gt;has_root&lt;/code&gt;&lt;/a&gt; are equivalent.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8c49b23a9e8913d5f28e887403c1dd64ea25f5f0" translate="yes" xml:space="preserve">
          <source>On Unix, this will return &lt;code&gt;None&lt;/code&gt; if the process was terminated by a signal; &lt;code&gt;std::os::unix&lt;/code&gt; provides an extension trait for extracting the signal and other details from the &lt;code&gt;ExitStatus&lt;/code&gt;.</source>
          <target state="translated">В Unix это вернет &lt;code&gt;None&lt;/code&gt; , если процесс был завершен сигналом; &lt;code&gt;std::os::unix&lt;/code&gt; предоставляет свойство расширения для извлечения сигнала и других деталей из &lt;code&gt;ExitStatus&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="08103bc8083664f610de1cd76da40c7342e367bf" translate="yes" xml:space="preserve">
          <source>On Windows</source>
          <target state="translated">On Windows</target>
        </trans-unit>
        <trans-unit id="340634e7ba37ae9abb46e394a10f468ca07b5406" translate="yes" xml:space="preserve">
          <source>On Windows and most Unix platforms this function is free (no extra system calls needed), but some Unix platforms may require the equivalent call to &lt;code&gt;symlink_metadata&lt;/code&gt; to learn about the target file type.</source>
          <target state="translated">В Windows и большинстве платформ Unix эта функция бесплатна (дополнительные системные вызовы не требуются), но на некоторых платформах Unix может потребоваться эквивалентный вызов &lt;code&gt;symlink_metadata&lt;/code&gt; , чтобы узнать о целевом типе файла.</target>
        </trans-unit>
        <trans-unit id="dc05b2580f0d12742976994a81fdd3a92daa9627" translate="yes" xml:space="preserve">
          <source>On Windows this function is cheap to call (no extra system calls needed), but on Unix platforms this function is the equivalent of calling &lt;code&gt;symlink_metadata&lt;/code&gt; on the path.</source>
          <target state="translated">В Windows эту функцию дешево вызывать (дополнительные системные вызовы не требуются), но на платформах Unix эта функция эквивалентна вызову &lt;code&gt;symlink_metadata&lt;/code&gt; на пути.</target>
        </trans-unit>
        <trans-unit id="96488f7f2e398f8d620db102c3767404f52cec35" translate="yes" xml:space="preserve">
          <source>On Windows, &lt;a href=&quot;struct.osstr&quot;&gt;&lt;code&gt;OsStr&lt;/code&gt;&lt;/a&gt; implements the &lt;code&gt;std::os::windows::ffi::&lt;/code&gt;&lt;a href=&quot;../os/windows/ffi/trait.osstrext&quot;&gt;&lt;code&gt;OsStrExt&lt;/code&gt;&lt;/a&gt; trait, which provides an &lt;a href=&quot;../os/windows/ffi/trait.osstrext#tymethod.encode_wide&quot;&gt;&lt;code&gt;encode_wide&lt;/code&gt;&lt;/a&gt; method. This provides an iterator that can be &lt;a href=&quot;../iter/trait.iterator#method.collect&quot;&gt;&lt;code&gt;collect&lt;/code&gt;&lt;/a&gt;ed into a vector of &lt;a href=&quot;../primitive.u16&quot;&gt;&lt;code&gt;u16&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">В Windows &lt;a href=&quot;struct.osstr&quot;&gt; &lt;code&gt;OsStr&lt;/code&gt; &lt;/a&gt; реализует трейт &lt;code&gt;std::os::windows::ffi::&lt;/code&gt; &lt;a href=&quot;../os/windows/ffi/trait.osstrext&quot;&gt; &lt;code&gt;OsStrExt&lt;/code&gt; &lt;/a&gt; :: OsStrExt , который предоставляет метод &lt;a href=&quot;../os/windows/ffi/trait.osstrext#tymethod.encode_wide&quot;&gt; &lt;code&gt;encode_wide&lt;/code&gt; &lt;/a&gt; . Это обеспечивает итератор, который можно &lt;a href=&quot;../iter/trait.iterator#method.collect&quot;&gt; &lt;code&gt;collect&lt;/code&gt; &lt;/a&gt; в вектор &lt;a href=&quot;../primitive.u16&quot;&gt; &lt;code&gt;u16&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="354971d9fc4cf41d4726d0f246b8a7efa90a20dd" translate="yes" xml:space="preserve">
          <source>On Windows, &lt;a href=&quot;struct.osstr&quot;&gt;&lt;code&gt;OsStr&lt;/code&gt;&lt;/a&gt; implements the &lt;code&gt;std::os::windows::ffi::&lt;/code&gt;&lt;a href=&quot;../os/windows/ffi/trait.osstrext&quot;&gt;&lt;code&gt;OsStrExt&lt;/code&gt;&lt;/a&gt; trait, which provides an &lt;a href=&quot;../os/windows/ffi/trait.osstrext#tymethod.encode_wide&quot;&gt;&lt;code&gt;encode_wide&lt;/code&gt;&lt;/a&gt; method. This provides an iterator that can be &lt;a href=&quot;../iter/trait.iterator#method.collect&quot;&gt;&lt;code&gt;collect&lt;/code&gt;&lt;/a&gt;ed into a vector of &lt;a href=&quot;https://doc.rust-lang.org/nightly/std/primitive.u16.html&quot;&gt;&lt;code&gt;u16&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9af64d7ebac16f152870c457029381910a90ad98" translate="yes" xml:space="preserve">
          <source>On Windows, a path has a root if it:</source>
          <target state="translated">В Windows путь имеет корень,если он есть:</target>
        </trans-unit>
        <trans-unit id="23aad31490e7c68a187977dea619fd53f62cad2c" translate="yes" xml:space="preserve">
          <source>On Windows, a path is absolute if it has a prefix and starts with the root: &lt;code&gt;c:\windows&lt;/code&gt; is absolute, while &lt;code&gt;c:temp&lt;/code&gt; and &lt;code&gt;\temp&lt;/code&gt; are not.</source>
          <target state="translated">В Windows путь является абсолютным, если он имеет префикс и начинается с корня: &lt;code&gt;c:\windows&lt;/code&gt; является абсолютным, а &lt;code&gt;c:temp&lt;/code&gt; и &lt;code&gt;\temp&lt;/code&gt; - нет.</target>
        </trans-unit>
        <trans-unit id="76c59bd2f582fcbc4571a1c46e5718df63ea4def" translate="yes" xml:space="preserve">
          <source>On Windows, a symbolic link knows whether it is a file or directory.</source>
          <target state="translated">В Windows символическая ссылка знает,является ли она файлом или каталогом.</target>
        </trans-unit>
        <trans-unit id="21bc0d515b3e6fb7f3d9412e9a760b756bd52140" translate="yes" xml:space="preserve">
          <source>On Windows, enter the command &lt;code&gt;.\main.exe&lt;/code&gt; instead of &lt;code&gt;./main&lt;/code&gt;:</source>
          <target state="translated">В Windows введите команду &lt;code&gt;.\main.exe&lt;/code&gt; вместо &lt;code&gt;./main&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="a5430ea74797e1304f80750653012edbeaab36ca" translate="yes" xml:space="preserve">
          <source>On Windows, go to &lt;a href=&quot;https://www.rust-lang.org/tools/install&quot;&gt;https://www.rust-lang.org/tools/install&lt;/a&gt; and follow the instructions for installing Rust. At some point in the installation, you&amp;rsquo;ll receive a message explaining that you&amp;rsquo;ll also need the C++ build tools for Visual Studio 2013 or later. The easiest way to acquire the build tools is to install &lt;a href=&quot;https://visualstudio.microsoft.com/visual-cpp-build-tools/&quot;&gt;Build Tools for Visual Studio 2019&lt;/a&gt;. When asked which workloads to install make sure &quot;C++ build tools&quot; is selected and that the Windows 10 SDK and the English language pack components are included.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bd7a73ca0a18d815fd6e51cfa03502575932403d" translate="yes" xml:space="preserve">
          <source>On Windows, go to &lt;a href=&quot;https://www.rust-lang.org/tools/install&quot;&gt;https://www.rust-lang.org/tools/install&lt;/a&gt; and follow the instructions for installing Rust. At some point in the installation, you&amp;rsquo;ll receive a message explaining that you&amp;rsquo;ll also need the C++ build tools for Visual Studio 2013 or later. The easiest way to acquire the build tools is to install &lt;a href=&quot;https://www.visualstudio.com/downloads/#build-tools-for-visual-studio-2019&quot;&gt;Build Tools for Visual Studio 2019&lt;/a&gt;. The tools are in the Other Tools and Frameworks section.</source>
          <target state="translated">В Windows перейдите по &lt;a href=&quot;https://www.rust-lang.org/tools/install&quot;&gt;адресу https://www.rust-lang.org/tools/install&lt;/a&gt; и следуйте инструкциям по установке Rust. В какой-то момент установки вы получите сообщение о том, что вам также понадобятся инструменты сборки C ++ для Visual Studio 2013 или более поздней версии. Самый простой способ получить инструменты сборки - установить &lt;a href=&quot;https://www.visualstudio.com/downloads/#build-tools-for-visual-studio-2019&quot;&gt;Build Tools for Visual Studio 2019&lt;/a&gt; . Инструменты находятся в разделе &amp;laquo;Другие инструменты и платформы&amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="f9e96b3ce49cbd593ce10eba431579916c1beb4e" translate="yes" xml:space="preserve">
          <source>On Windows, strings are often arbitrary sequences of non-zero 16-bit values, interpreted as UTF-16 when it is valid to do so.</source>
          <target state="translated">В Windows строки часто представляют собой произвольные последовательности ненулевых 16-битных значений,интерпретируемых как UTF-16,когда это допустимо.</target>
        </trans-unit>
        <trans-unit id="4d87cfdfbe26beaf98d7cabde9343985e270cf11" translate="yes" xml:space="preserve">
          <source>On Windows, this converts the path to use &lt;a href=&quot;https://docs.microsoft.com/en-us/windows/win32/fileio/naming-a-file&quot;&gt;extended length path&lt;/a&gt; syntax, which allows your program to use longer path names, but means you can only join backslash-delimited paths to it, and it may be incompatible with other applications (if passed to the application on the command-line, or written to a file another application may read).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e57ac5776aebf69e1a4091e5f62bdd9bd9a59609" translate="yes" xml:space="preserve">
          <source>On Windows, this converts the path to use &lt;a href=&quot;https://msdn.microsoft.com/en-us/library/windows/desktop/aa365247(v=vs.85).aspx#maxpath&quot;&gt;extended length path&lt;/a&gt; syntax, which allows your program to use longer path names, but means you can only join backslash-delimited paths to it, and it may be incompatible with other applications (if passed to the application on the command-line, or written to a file another application may read).</source>
          <target state="translated">В Windows это преобразует путь для использования синтаксиса &lt;a href=&quot;https://msdn.microsoft.com/en-us/library/windows/desktop/aa365247(v=vs.85).aspx#maxpath&quot;&gt;расширенного пути&lt;/a&gt; , что позволяет вашей программе использовать более длинные имена путей, но означает, что вы можете присоединять к нему только пути, разделенные обратными косыми чертами, и он может быть несовместим с другими приложениями (если передан приложение в командной строке или записанный в файл, который может прочитать другое приложение).</target>
        </trans-unit>
        <trans-unit id="22cfd134aef9e5447e4029c33c01913e82dca29d" translate="yes" xml:space="preserve">
          <source>On Windows, you must specify whether a symbolic link points to a file or directory. Use &lt;code&gt;os::windows::fs::symlink_file&lt;/code&gt; to create a symbolic link to a file, or &lt;code&gt;os::windows::fs::symlink_dir&lt;/code&gt; to create a symbolic link to a directory. Additionally, the process must have &lt;code&gt;SeCreateSymbolicLinkPrivilege&lt;/code&gt; in order to be able to create a symbolic link.</source>
          <target state="translated">В Windows необходимо указать, указывает ли символическая ссылка на файл или каталог. Используйте &lt;code&gt;os::windows::fs::symlink_file&lt;/code&gt; чтобы создать символьную ссылку на файл, или &lt;code&gt;os::windows::fs::symlink_dir&lt;/code&gt; чтобы создать символьную ссылку на каталог. Кроме того, процесс должен иметь &lt;code&gt;SeCreateSymbolicLinkPrivilege&lt;/code&gt; , чтобы иметь возможность создавать символическую ссылку.</target>
        </trans-unit>
        <trans-unit id="55b56364276b5f7e47e7f031287b139fc5b947d5" translate="yes" xml:space="preserve">
          <source>On Windows:</source>
          <target state="translated">На Windows:</target>
        </trans-unit>
        <trans-unit id="2d943049f7275605af2957c0729af75e15804644" translate="yes" xml:space="preserve">
          <source>On a struct pattern, the fields are referenced by name, index (in the case of tuple structs) or ignored by use of &lt;code&gt;..&lt;/code&gt;:</source>
          <target state="translated">В шаблоне структуры на поля ссылаются по имени, индексу (в случае кортежных структур) или игнорируются с помощью &lt;code&gt;..&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="bc5ae395985a077524b266fc2c058a9c41f9a6c9" translate="yes" xml:space="preserve">
          <source>On a technical level, Rust inserts</source>
          <target state="translated">На техническом уровне,ржавые вставки</target>
        </trans-unit>
        <trans-unit id="1b348ad01b675597a26bee9f6007707cf4e88f3f" translate="yes" xml:space="preserve">
          <source>On all platforms it's possible for TLS to re-initialize other TLS slots during destruction. Some platforms ensure that this cannot happen infinitely by preventing re-initialization of any slot that has been destroyed, but not all platforms have this guard. Those platforms that do not guard typically have a synthetic limit after which point no more destructors are run.</source>
          <target state="translated">На всех платформах TLS может повторно инициализировать другие слоты TLS во время разрушения.Некоторые платформы гарантируют,что это не может происходить бесконечно,предотвращая повторную инициализацию любого слота,который был уничтожен,но не на всех платформах есть такая защита.Те платформы,которые не защищают,обычно имеют синтетический лимит,после которого больше не запускаются деструкторы.</target>
        </trans-unit>
        <trans-unit id="037d4731f94d8fe39eb9b4a6879b2f19130604a0" translate="yes" xml:space="preserve">
          <source>On all platforms, the newline is the LINE FEED character (&lt;code&gt;\n&lt;/code&gt;/&lt;code&gt;U+000A&lt;/code&gt;) alone (no additional CARRIAGE RETURN (&lt;code&gt;\r&lt;/code&gt;/&lt;code&gt;U+000D&lt;/code&gt;)).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d799d2a3d45a2a27a645560d44031039269d8400" translate="yes" xml:space="preserve">
          <source>On all platforms, the newline is the LINE FEED character (&lt;code&gt;\n&lt;/code&gt;/&lt;code&gt;U+000A&lt;/code&gt;) alone (no additional CARRIAGE RETURN (&lt;code&gt;\r&lt;/code&gt;/&lt;code&gt;U+000D&lt;/code&gt;).</source>
          <target state="translated">На всех платформах символ новой строки - это только символ LINE FEED ( &lt;code&gt;\n&lt;/code&gt; / &lt;code&gt;U+000A&lt;/code&gt; ) (без дополнительного ВОЗВРАТА ПЕРЕВОЗКИ ( &lt;code&gt;\r&lt;/code&gt; / &lt;code&gt;U+000D&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="8026d1566cfb33142845deb08dc55be0e48c8b84" translate="yes" xml:space="preserve">
          <source>On arithmetic overflow, returns &lt;code&gt;LayoutErr&lt;/code&gt;.</source>
          <target state="translated">При арифметическом переполнении возвращает &lt;code&gt;LayoutErr&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="bf819fffd5786da2be15358bf27201c594c34573" translate="yes" xml:space="preserve">
          <source>On arithmetic overflow, returns &lt;code&gt;LayoutError&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="62056a56ee350ef2ac48d7878ee0e8c05c6cdab9" translate="yes" xml:space="preserve">
          <source>On big endian this is a no-op. On little endian the bytes are swapped.</source>
          <target state="translated">На большом эндиане это &quot;нет-оп&quot;.На маленьком эндиане байты меняются.</target>
        </trans-unit>
        <trans-unit id="3209db243d37f470d1d7cfe42ce3d766b7bc29ef" translate="yes" xml:space="preserve">
          <source>On failure, ownership of the original &lt;code&gt;CString&lt;/code&gt; is returned.</source>
          <target state="translated">В случае ошибки право собственности на исходный &lt;code&gt;CString&lt;/code&gt; возвращается.</target>
        </trans-unit>
        <trans-unit id="4c9afd72e5fc07b12e4a58aab05b5a861ccfe991" translate="yes" xml:space="preserve">
          <source>On failure, ownership of the original &lt;code&gt;OsString&lt;/code&gt; is returned.</source>
          <target state="translated">В случае сбоя право собственности на исходную &lt;code&gt;OsString&lt;/code&gt; возвращается.</target>
        </trans-unit>
        <trans-unit id="259a9191e45f4405904adb74ccfbaecde8fac969" translate="yes" xml:space="preserve">
          <source>On glibc Linux systems, arguments are retrieved by placing a function in &quot;.init_array&quot;. Glibc passes argc, argv, and envp to functions in &quot;.init_array&quot;, as a non-standard extension. This allows &lt;code&gt;std::env::args&lt;/code&gt; to work even in a &lt;code&gt;cdylib&lt;/code&gt; or &lt;code&gt;staticlib&lt;/code&gt;, as it does on macOS and Windows.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d682d53e730f8107b6e28e70ea3aca1f2f84a3a2" translate="yes" xml:space="preserve">
          <source>On glibc Linux systems, arguments are retrieved by placing a function in &lt;code&gt;.init_array&lt;/code&gt;. Glibc passes &lt;code&gt;argc&lt;/code&gt;, &lt;code&gt;argv&lt;/code&gt;, and &lt;code&gt;envp&lt;/code&gt; to functions in &lt;code&gt;.init_array&lt;/code&gt;, as a non-standard extension. This allows &lt;code&gt;std::env::args&lt;/code&gt; to work even in a &lt;code&gt;cdylib&lt;/code&gt; or &lt;code&gt;staticlib&lt;/code&gt;, as it does on macOS and Windows.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3818a4eb5a3ae2432429a2be6f00d2b57327ad67" translate="yes" xml:space="preserve">
          <source>On iteration, the closure will be applied to each element of the iterator and the return value from the closure, an &lt;a href=&quot;../option/enum.option&quot;&gt;&lt;code&gt;Option&lt;/code&gt;&lt;/a&gt;, is yielded by the iterator.</source>
          <target state="translated">При итерации закрытие будет применено к каждому элементу итератора, и итератор выдает возвращаемое из замыкания значение &lt;a href=&quot;../option/enum.option&quot;&gt; &lt;code&gt;Option&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="7ac8ec0fd24d5e212f6e7881f085d7af49a49607" translate="yes" xml:space="preserve">
          <source>On little endian this is a no-op. On big endian the bytes are swapped.</source>
          <target state="translated">На маленьком эндиане это безумие.На большом эндиане байты меняются.</target>
        </trans-unit>
        <trans-unit id="4e3e1efffa4b7d24fe7283223e058e550576b614" translate="yes" xml:space="preserve">
          <source>On many architectures, this function can perform better than &lt;code&gt;leading_zeros()&lt;/code&gt; on the underlying integer type, as special handling of zero can be avoided.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="848a615b6290900cfd1ddd55f346fc45b2bed670" translate="yes" xml:space="preserve">
          <source>On many architectures, this function can perform better than &lt;code&gt;trailing_zeros()&lt;/code&gt; on the underlying integer type, as special handling of zero can be avoided.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5d4ddcfc8d324d93f4c94125de45c5742f4d5101" translate="yes" xml:space="preserve">
          <source>On non-pointer types &lt;code&gt;*x&lt;/code&gt; is equivalent to &lt;code&gt;*std::ops::Deref::deref(&amp;amp;x)&lt;/code&gt; in an &lt;a href=&quot;../expressions#mutability&quot;&gt;immutable place expression context&lt;/a&gt; and &lt;code&gt;*std::ops::DerefMut::deref_mut(&amp;amp;mut x)&lt;/code&gt; in a mutable place expression context.</source>
          <target state="translated">Для типов без указателей &lt;code&gt;*x&lt;/code&gt; эквивалентен &lt;code&gt;*std::ops::Deref::deref(&amp;amp;x)&lt;/code&gt; в &lt;a href=&quot;../expressions#mutability&quot;&gt;неизменяемом контексте выражения места&lt;/a&gt; и &lt;code&gt;*std::ops::DerefMut::deref_mut(&amp;amp;mut x)&lt;/code&gt; в изменяемом месте контекст выражения.</target>
        </trans-unit>
        <trans-unit id="152e667068d08065574b6f3ea75735b1ef22f81c" translate="yes" xml:space="preserve">
          <source>On panic, this macro will print the values of the expressions with their debug representations.</source>
          <target state="translated">В панике этот макрос выведет значения выражений с их отладочными представлениями.</target>
        </trans-unit>
        <trans-unit id="a0e8d873b690ac84365bcb6ce9a48ba9ac4a73cf" translate="yes" xml:space="preserve">
          <source>On some system, calling &lt;a href=&quot;#method.wait&quot;&gt;&lt;code&gt;wait&lt;/code&gt;&lt;/a&gt; or similar is necessary for the OS to release resources. A process that terminated but has not been waited on is still around as a &quot;zombie&quot;. Leaving too many zombies around may exhaust global resources (for example process IDs).</source>
          <target state="translated">В некоторых системах вызов &lt;a href=&quot;#method.wait&quot;&gt; &lt;code&gt;wait&lt;/code&gt; &lt;/a&gt; или аналогичный вызов необходим ОС для освобождения ресурсов. Процесс, который завершился, но не ожидался, все еще существует как &amp;laquo;зомби&amp;raquo;. Если оставить слишком много зомби, это может истощить глобальные ресурсы (например, идентификаторы процессов).</target>
        </trans-unit>
        <trans-unit id="8d680bbd1b29ac2bd7f1c4039cc2f034c2409b58" translate="yes" xml:space="preserve">
          <source>On some systems, calling &lt;a href=&quot;struct.child#method.wait&quot;&gt;&lt;code&gt;wait&lt;/code&gt;&lt;/a&gt; or similar is necessary for the OS to release resources. A process that terminated but has not been waited on is still around as a &quot;zombie&quot;. Leaving too many zombies around may exhaust global resources (for example process IDs).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f95b6f9f5ca3589fe7d076155399faa6b71dbbbe" translate="yes" xml:space="preserve">
          <source>On success this function will not return, and otherwise it will return an error indicating why the exec (or another part of the setup of the &lt;code&gt;Command&lt;/code&gt;) failed.</source>
          <target state="translated">В случае успеха эта функция не вернется, в противном случае она вернет ошибку, указывающую, почему не удалось выполнить exec (или другую часть настройки &lt;code&gt;Command&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="9dc3aca4d292aed062c338c543e13af0f74c89de" translate="yes" xml:space="preserve">
          <source>On success, returns a &lt;a href=&quot;../ptr/struct.nonnull&quot;&gt;&lt;code&gt;NonNull&amp;lt;[u8]&amp;gt;&lt;/code&gt;&lt;/a&gt; meeting the size and alignment guarantees of &lt;code&gt;layout&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="105508220fba1586b41aed6de3e9afe8bdcad7d2" translate="yes" xml:space="preserve">
          <source>On success, returns the number of bytes read and if the data was truncated.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="85ee4aa1b293e333458ae17de2dc9971adc5a07b" translate="yes" xml:space="preserve">
          <source>On success, returns the number of bytes read and the address from whence the data came.</source>
          <target state="translated">В случае успеха возвращает количество прочитанных байт и адрес,откуда пришли данные.</target>
        </trans-unit>
        <trans-unit id="dfc14b3f66c1dadb297ac68b0d484bfc6cc7a217" translate="yes" xml:space="preserve">
          <source>On success, returns the number of bytes read, if the data was truncated and the address from whence the msg came.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4ea0ccaabe0c9b1fbc90341ab5a04d65215e560d" translate="yes" xml:space="preserve">
          <source>On success, returns the number of bytes read.</source>
          <target state="translated">При успешной работе возвращает количество прочитанных байт.</target>
        </trans-unit>
        <trans-unit id="bc5a49aba56a5b26329959ae0e37a7391cbb54ed" translate="yes" xml:space="preserve">
          <source>On success, returns the number of bytes written.</source>
          <target state="translated">При успехе возвращает количество написанных байтов.</target>
        </trans-unit>
        <trans-unit id="f9b7167ab1cb81802d4cc93ff38048bd7cd2f218" translate="yes" xml:space="preserve">
          <source>On success, the total number of bytes copied is returned and it is equal to the length of the &lt;code&gt;to&lt;/code&gt; file as reported by &lt;code&gt;metadata&lt;/code&gt;.</source>
          <target state="translated">В случае успеха, общее количество байт , скопированных возвращаются и она равна длиной &lt;code&gt;to&lt;/code&gt; файла , как сообщают &lt;code&gt;metadata&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a6bfa6f8c514698639a06b222dc94c1639495b9f" translate="yes" xml:space="preserve">
          <source>On success, the total number of bytes that were copied from &lt;code&gt;reader&lt;/code&gt; to &lt;code&gt;writer&lt;/code&gt; is returned.</source>
          <target state="translated">В случае успеха, общее количество байт, скопированных из &lt;code&gt;reader&lt;/code&gt; к &lt;code&gt;writer&lt;/code&gt; возвращается.</target>
        </trans-unit>
        <trans-unit id="43a00d4716ce2886f17dadaa3b0e2204d940167a" translate="yes" xml:space="preserve">
          <source>On the &lt;code&gt;Screen&lt;/code&gt; struct, we&amp;rsquo;ll define a method named &lt;code&gt;run&lt;/code&gt; that will call the &lt;code&gt;draw&lt;/code&gt; method on each of its &lt;code&gt;components&lt;/code&gt;, as shown in Listing 17-5:</source>
          <target state="translated">В структуре &lt;code&gt;Screen&lt;/code&gt; мы определим метод с именем &lt;code&gt;run&lt;/code&gt; , который будет вызывать метод &lt;code&gt;draw&lt;/code&gt; для каждого из своих &lt;code&gt;components&lt;/code&gt; , как показано в листинге 17-5:</target>
        </trans-unit>
        <trans-unit id="417a01b51fb2fc402d7ff9e7a38ed36ddb3ab97a" translate="yes" xml:space="preserve">
          <source>On the first line of &lt;code&gt;main&lt;/code&gt;, we call &lt;code&gt;env::args&lt;/code&gt;, and we immediately use &lt;code&gt;collect&lt;/code&gt; to turn the iterator into a vector containing all the values produced by the iterator. We can use the &lt;code&gt;collect&lt;/code&gt; function to create many kinds of collections, so we explicitly annotate the type of &lt;code&gt;args&lt;/code&gt; to specify that we want a vector of strings. Although we very rarely need to annotate types in Rust, &lt;code&gt;collect&lt;/code&gt; is one function you do often need to annotate because Rust isn&amp;rsquo;t able to infer the kind of collection you want.</source>
          <target state="translated">В первой строке &lt;code&gt;main&lt;/code&gt; мы вызываем &lt;code&gt;env::args&lt;/code&gt; и сразу же используем &lt;code&gt;collect&lt;/code&gt; , чтобы превратить итератор в вектор, содержащий все значения, созданные итератором. Мы можем использовать функцию &lt;code&gt;collect&lt;/code&gt; для создания множества видов коллекций, поэтому мы явно аннотируем тип &lt;code&gt;args&lt;/code&gt; чтобы указать, что нам нужен вектор строк. Хотя нам очень редко нужно аннотировать типы в Rust, &lt;code&gt;collect&lt;/code&gt; - это одна из функций, которую вам часто нужно аннотировать, потому что Rust не может вывести тип коллекции, которую вы хотите.</target>
        </trans-unit>
        <trans-unit id="9eddcffce559b2f4fd96faa276545d34f1b2fe9a" translate="yes" xml:space="preserve">
          <source>On the other hand, one trait which would not be appropriate to implement is &lt;a href=&quot;default/trait.default&quot;&gt;&lt;code&gt;Default&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">С другой стороны, одна черта, которую не следует реализовывать, - это &lt;a href=&quot;default/trait.default&quot;&gt; &lt;code&gt;Default&lt;/code&gt; &lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="c286483c8f6ceb616a180cf64f82c92b911d5676" translate="yes" xml:space="preserve">
          <source>On the other hand, this is correct:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8cf67f3b833240197b7f3967e7a28b88e1336e77" translate="yes" xml:space="preserve">
          <source>On the other hand, this will not compile because the &lt;code&gt;where 'b: 'a&lt;/code&gt; clause is missing: the &lt;code&gt;'b&lt;/code&gt; lifetime is not known to live at least as long as &lt;code&gt;'a&lt;/code&gt; which means this function cannot ensure it always returns a valid reference:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="09d6ad3b118e12286d44db37bda32a77e5392fde" translate="yes" xml:space="preserve">
          <source>On the other hand, when bringing in structs, enums, and other items with &lt;code&gt;use&lt;/code&gt;, it&amp;rsquo;s idiomatic to specify the full path. Listing 7-14 shows the idiomatic way to bring the standard library&amp;rsquo;s &lt;code&gt;HashMap&lt;/code&gt; struct into the scope of a binary crate.</source>
          <target state="translated">С другой стороны, при вводе структур, перечислений и других элементов с &lt;code&gt;use&lt;/code&gt; идиоматично указывать полный путь. В листинге 7-14 показан идиоматический способ переноса структуры &lt;code&gt;HashMap&lt;/code&gt; стандартной библиотеки в область видимости двоичного ящика.</target>
        </trans-unit>
        <trans-unit id="50d2f428f140a723a3dc474c3eb5d43ababe5b45" translate="yes" xml:space="preserve">
          <source>On the other hand, with the method using trait objects, one &lt;code&gt;Screen&lt;/code&gt; instance can hold a &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; that contains a &lt;code&gt;Box&amp;lt;Button&amp;gt;&lt;/code&gt; as well as a &lt;code&gt;Box&amp;lt;TextField&amp;gt;&lt;/code&gt;. Let&amp;rsquo;s look at how this works, and then we&amp;rsquo;ll talk about the runtime performance implications.</source>
          <target state="translated">С другой стороны, с методом, использующим типажные объекты, один экземпляр &lt;code&gt;Screen&lt;/code&gt; может содержать &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; который содержит &lt;code&gt;Box&amp;lt;Button&amp;gt;&lt;/code&gt; а также &lt;code&gt;Box&amp;lt;TextField&amp;gt;&lt;/code&gt; . Давайте посмотрим, как это работает, а затем поговорим о последствиях для производительности во время выполнения.</target>
        </trans-unit>
        <trans-unit id="05a08140d648b8eef0f62e5e0b016ae12318d58b" translate="yes" xml:space="preserve">
          <source>On the surface, &lt;code&gt;static&lt;/code&gt; items seem very similar to &lt;a href=&quot;keyword.const&quot;&gt;&lt;code&gt;const&lt;/code&gt;&lt;/a&gt;s: both contain a value, both require type annotations and both can only be initialized with constant functions and values. However, &lt;code&gt;static&lt;/code&gt;s are notably different in that they represent a location in memory. That means that you can have references to &lt;code&gt;static&lt;/code&gt; items and potentially even modify them, making them essentially global variables.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8593d2dddd7916b4461c2238bc4c5b8191583e5e" translate="yes" xml:space="preserve">
          <source>On top of that, all additional invariants of the type &lt;code&gt;T&lt;/code&gt; must be satisfied, as the &lt;code&gt;Drop&lt;/code&gt; implementation of &lt;code&gt;T&lt;/code&gt; (or its members) may rely on this. For example, a &lt;code&gt;1&lt;/code&gt;-initialized &lt;a href=&quot;../vec/struct.vec&quot;&gt;&lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt; is considered initialized (under the current implementation; this does not constitute a stable guarantee) because the only requirement the compiler knows about it is that the data pointer must be non-null. Dropping such a &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; however will cause undefined behaviour.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7d7c692a18f46234aa3957edc945a28ff83c44fe" translate="yes" xml:space="preserve">
          <source>On top of that, function pointers can vary based on what ABI they use. This is achieved by adding the &lt;code&gt;extern&lt;/code&gt; keyword before the type, followed by the ABI in question. The default ABI is &quot;Rust&quot;, i.e., &lt;code&gt;fn()&lt;/code&gt; is the exact same type as &lt;code&gt;extern &quot;Rust&quot; fn()&lt;/code&gt;. A pointer to a function with C ABI would have type &lt;code&gt;extern &quot;C&quot; fn()&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a7c793eb037e8ef3b7da8efa89ac452132495eae" translate="yes" xml:space="preserve">
          <source>On top of that, function pointers can vary based on what ABI they use. This is achieved by adding the &lt;code&gt;extern&lt;/code&gt; keyword to the type name, followed by the ABI in question. For example, &lt;code&gt;fn()&lt;/code&gt; is different from &lt;code&gt;extern &quot;C&quot; fn()&lt;/code&gt;, which itself is different from &lt;code&gt;extern &quot;stdcall&quot; fn()&lt;/code&gt;, and so on for the various ABIs that Rust supports. Non-&lt;code&gt;extern&lt;/code&gt; functions have an ABI of &lt;code&gt;&quot;Rust&quot;&lt;/code&gt;, and &lt;code&gt;extern&lt;/code&gt; functions without an explicit ABI have an ABI of &lt;code&gt;&quot;C&quot;&lt;/code&gt;. For more information, see &lt;a href=&quot;https://doc.rust-lang.org/nomicon/ffi.html#foreign-calling-conventions&quot;&gt;the nomicon's section on foreign calling conventions&lt;/a&gt;.</source>
          <target state="translated">Кроме того, указатели на функции могут различаться в зависимости от того, какой ABI они используют. Это достигается путем добавления ключевого слова &lt;code&gt;extern&lt;/code&gt; к имени типа, за которым следует рассматриваемый ABI. Например, &lt;code&gt;fn()&lt;/code&gt; отличается от &lt;code&gt;extern &quot;C&quot; fn()&lt;/code&gt; , который сам по себе отличается от &lt;code&gt;extern &quot;stdcall&quot; fn()&lt;/code&gt; , и так далее для различных ABI, поддерживаемых Rust. Не &lt;code&gt;extern&lt;/code&gt; функции имеют ABI &lt;code&gt;&quot;Rust&quot;&lt;/code&gt; , а &lt;code&gt;extern&lt;/code&gt; функции без явного ABI имеют ABI &lt;code&gt;&quot;C&quot;&lt;/code&gt; . Для получения дополнительной информации см. &lt;a href=&quot;https://doc.rust-lang.org/nomicon/ffi.html#foreign-calling-conventions&quot;&gt;Раздел nomicon, посвященный соглашениям о внешних вызовах&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="7b2aa688af42ea89b3fbf818f2d4bdeab6c73c4a" translate="yes" xml:space="preserve">
          <source>On top of that, remember that most types have additional invariants beyond merely being considered initialized at the type level. For example, a &lt;code&gt;1&lt;/code&gt;-initialized &lt;a href=&quot;../vec/struct.vec&quot;&gt;&lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt; is considered initialized (under the current implementation; this does not constitute a stable guarantee) because the only requirement the compiler knows about it is that the data pointer must be non-null. Creating such a &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; does not cause &lt;em&gt;immediate&lt;/em&gt; undefined behavior, but will cause undefined behavior with most safe operations (including dropping it).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="630c59f788be2f8b6b4b1ca247b245094c3530e8" translate="yes" xml:space="preserve">
          <source>On top of that, remember that most types have additional invariants beyond merely being considered initialized at the type level. For example, a &lt;code&gt;1&lt;/code&gt;-initialized &lt;a href=&quot;../vec/struct.vec&quot;&gt;&lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt; is considered initialized because the only requirement the compiler knows about it is that the data pointer must be non-null. Creating such a &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; does not cause &lt;em&gt;immediate&lt;/em&gt; undefined behavior, but will cause undefined behavior with most safe operations (including dropping it).</source>
          <target state="translated">Кроме того, помните, что большинство типов имеют дополнительные инварианты, помимо того, что они считаются инициализированными на уровне типа. Например, &lt;code&gt;1&lt;/code&gt; - инициализированный &lt;a href=&quot;../vec/struct.vec&quot;&gt; &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; &lt;/a&gt; считается инициализированным, потому что единственное требование, которое компилятор знает о нем, - это то, что указатель данных не должен быть нулевым. Создание такого &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; не вызывает &lt;em&gt;немедленного&lt;/em&gt; неопределенного поведения, но приведет к неопределенному поведению при большинстве безопасных операций (включая его удаление).</target>
        </trans-unit>
        <trans-unit id="d9c768782ea8653d485fb3b7f5aba21cb2ca7bf3" translate="yes" xml:space="preserve">
          <source>Once</source>
          <target state="translated">Once</target>
        </trans-unit>
        <trans-unit id="dde4e913efe3a7bb20d91e29731b497ad0b7ade2" translate="yes" xml:space="preserve">
          <source>Once &lt;code&gt;Config::new&lt;/code&gt; takes ownership of the iterator and stops using indexing operations that borrow, we can move the &lt;code&gt;String&lt;/code&gt; values from the iterator into &lt;code&gt;Config&lt;/code&gt; rather than calling &lt;code&gt;clone&lt;/code&gt; and making a new allocation.</source>
          <target state="translated">Как только &lt;code&gt;Config::new&lt;/code&gt; становится владельцем итератора и перестает использовать заимствованные операции индексации, мы можем переместить значения &lt;code&gt;String&lt;/code&gt; из итератора в &lt;code&gt;Config&lt;/code&gt; вместо вызова &lt;code&gt;clone&lt;/code&gt; и создания нового распределения.</target>
        </trans-unit>
        <trans-unit id="8b0de6bbc4d6a271545919a41560436f915e4647" translate="yes" xml:space="preserve">
          <source>Once a future has completed (returned &lt;code&gt;Ready&lt;/code&gt; from &lt;code&gt;poll&lt;/code&gt;), calling its &lt;code&gt;poll&lt;/code&gt; method again may panic, block forever, or cause other kinds of problems; the &lt;code&gt;Future&lt;/code&gt; trait places no requirements on the effects of such a call. However, as the &lt;code&gt;poll&lt;/code&gt; method is not marked &lt;code&gt;unsafe&lt;/code&gt;, Rust's usual rules apply: calls must never cause undefined behavior (memory corruption, incorrect use of &lt;code&gt;unsafe&lt;/code&gt; functions, or the like), regardless of the future's state.</source>
          <target state="translated">Как только будущее завершено (возвращается &lt;code&gt;Ready&lt;/code&gt; из &lt;code&gt;poll&lt;/code&gt; ), повторный вызов его метода &lt;code&gt;poll&lt;/code&gt; может вызвать панику, блокировку навсегда или вызвать другие виды проблем; &lt;code&gt;Future&lt;/code&gt; черта не накладывает какие - либо требований о последствиях такого вызова. Однако, поскольку метод &lt;code&gt;poll&lt;/code&gt; не помечен как &lt;code&gt;unsafe&lt;/code&gt; , применяются обычные правила Rust: вызовы никогда не должны вызывать неопределенное поведение (повреждение памяти, неправильное использование &lt;code&gt;unsafe&lt;/code&gt; функций и т.п.), независимо от состояния в будущем.</target>
        </trans-unit>
        <trans-unit id="472f512f503c00a7a3badf54bca4e8a984d78d81" translate="yes" xml:space="preserve">
          <source>Once a future has finished, clients should not &lt;code&gt;poll&lt;/code&gt; it again.</source>
          <target state="translated">Как только фьючерс закончен, клиенты не должны &lt;code&gt;poll&lt;/code&gt; его снова.</target>
        </trans-unit>
        <trans-unit id="52d66dce2b0cbeb3ef0b4a40c595411581c4bf47" translate="yes" xml:space="preserve">
          <source>Once a valid size is received, our &lt;code&gt;ThreadPool&lt;/code&gt; creates a new vector that can hold &lt;code&gt;size&lt;/code&gt; items. We haven&amp;rsquo;t used the &lt;code&gt;with_capacity&lt;/code&gt; function in this book yet, which performs the same task as &lt;code&gt;Vec::new&lt;/code&gt; but with an important difference: it preallocates space in the vector. Because we know we need to store &lt;code&gt;size&lt;/code&gt; elements in the vector, doing this allocation up front is slightly more efficient than using &lt;code&gt;Vec::new&lt;/code&gt;, which resizes itself as elements are inserted.</source>
          <target state="translated">После получения допустимого размера наш &lt;code&gt;ThreadPool&lt;/code&gt; создает новый вектор, который может содержать элементы &lt;code&gt;size&lt;/code&gt; . В этой книге мы еще не использовали функцию &lt;code&gt;with_capacity&lt;/code&gt; , которая выполняет ту же задачу, что и &lt;code&gt;Vec::new&lt;/code&gt; но с важным отличием: она предварительно выделяет пространство в векторе. Поскольку мы знаем, что нам нужно хранить элементы &lt;code&gt;size&lt;/code&gt; в векторе, выполнение этого распределения вперед немного более эффективно, чем использование &lt;code&gt;Vec::new&lt;/code&gt; , которое изменяет свои размеры при вставке элементов.</target>
        </trans-unit>
        <trans-unit id="b9c2a150a70fbfb0f86650e1f5cd73ca0f595c49" translate="yes" xml:space="preserve">
          <source>Once again we're using &lt;code&gt;!&lt;/code&gt;'s ability to coerce into any other type, in this case &lt;a href=&quot;fmt/type.result&quot;&gt;&lt;code&gt;fmt::Result&lt;/code&gt;&lt;/a&gt;. Since this method takes a &lt;code&gt;&amp;amp;!&lt;/code&gt; as an argument we know that it can never be called (because there is no value of type &lt;code&gt;!&lt;/code&gt; for it to be called with). Writing &lt;code&gt;*self&lt;/code&gt; essentially tells the compiler &quot;We know that this code can never be run, so just treat the entire function body as having type &lt;a href=&quot;fmt/type.result&quot;&gt;&lt;code&gt;fmt::Result&lt;/code&gt;&lt;/a&gt;&quot;. This pattern can be used a lot when implementing traits for &lt;code&gt;!&lt;/code&gt;. Generally, any trait which only has methods which take a &lt;code&gt;self&lt;/code&gt; parameter should have such an impl.</source>
          <target state="translated">Еще раз используем &lt;code&gt;!&lt;/code&gt; возможность принуждения к любому другому типу, в данном случае &lt;a href=&quot;fmt/type.result&quot;&gt; &lt;code&gt;fmt::Result&lt;/code&gt; &lt;/a&gt; . Поскольку этот метод принимает &lt;code&gt;&amp;amp;!&lt;/code&gt; в качестве аргумента мы знаем, что он никогда не может быть вызван (потому что нет значения типа &lt;code&gt;!&lt;/code&gt; , с которым он мог бы быть вызван). Написание &lt;code&gt;*self&lt;/code&gt; по существу сообщает компилятору: &amp;laquo;Мы знаем, что этот код никогда не может быть запущен, поэтому просто рассматривайте все тело функции как имеющее тип &lt;a href=&quot;fmt/type.result&quot;&gt; &lt;code&gt;fmt::Result&lt;/code&gt; &lt;/a&gt; &amp;raquo;. Этот шаблон можно часто использовать при реализации трейтов для &lt;code&gt;!&lt;/code&gt; . Как правило, любой трейт, у которого есть только методы, принимающие параметр &lt;code&gt;self&lt;/code&gt; , должен иметь такой impl.</target>
        </trans-unit>
        <trans-unit id="3c60f2098dcfc1948a1cd5eb57c13cccf48d2d00" translate="yes" xml:space="preserve">
          <source>Once again, we compile and get... different errors! The compiler is teaching us a lot.</source>
          <target state="translated">Еще раз,мы компилируем и получаем...разные ошибки! Компилятор нас многому учит.</target>
        </trans-unit>
        <trans-unit id="30ba447807ee16c40637ce8c42ca10892e8780ac" translate="yes" xml:space="preserve">
          <source>Once half of a channel has been deallocated, most operations can no longer continue to make progress, so &lt;a href=&quot;../../result/enum.result#variant.Err&quot;&gt;&lt;code&gt;Err&lt;/code&gt;&lt;/a&gt; will be returned. Many applications will continue to &lt;a href=&quot;../../result/enum.result#method.unwrap&quot;&gt;&lt;code&gt;unwrap&lt;/code&gt;&lt;/a&gt; the results returned from this module, instigating a propagation of failure among threads if one unexpectedly dies.</source>
          <target state="translated">После того, как половина канала освобождена, выполнение большинства операций больше не может продолжаться, поэтому будет возвращена &lt;a href=&quot;../../result/enum.result#variant.Err&quot;&gt; &lt;code&gt;Err&lt;/code&gt; &lt;/a&gt; . Многие приложения будут продолжать &lt;a href=&quot;../../result/enum.result#method.unwrap&quot;&gt; &lt;code&gt;unwrap&lt;/code&gt; &lt;/a&gt; результаты, возвращаемые этим модулем, инициируя распространение сбоя среди потоков, если один из них неожиданно умирает.</target>
        </trans-unit>
        <trans-unit id="a91c464fe4209e458222e2a75f2d92f1b46b0155" translate="yes" xml:space="preserve">
          <source>Once the internal storage is contiguous, the &lt;a href=&quot;../struct.vecdeque#method.as_slices&quot;&gt;&lt;code&gt;as_slices&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../struct.vecdeque#method.as_mut_slices&quot;&gt;&lt;code&gt;as_mut_slices&lt;/code&gt;&lt;/a&gt; methods will return the entire contents of the &lt;code&gt;VecDeque&lt;/code&gt; in a single slice.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6364bb4d426e3f0cecb2911427f26ed73152d755" translate="yes" xml:space="preserve">
          <source>Once the internal storage is contiguous, the &lt;a href=&quot;struct.vecdeque#method.as_slices&quot;&gt;&lt;code&gt;as_slices&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;struct.vecdeque#method.as_mut_slices&quot;&gt;&lt;code&gt;as_mut_slices&lt;/code&gt;&lt;/a&gt; methods will return the entire contents of the &lt;code&gt;VecDeque&lt;/code&gt; in a single slice.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7b36c9a4ffe1c545648e7557d44e1b469b4df260" translate="yes" xml:space="preserve">
          <source>Once this function returns, the contents of &lt;code&gt;bufs&lt;/code&gt; are unspecified, as this depends on how many calls to &lt;a href=&quot;trait.write#method.write_vectored&quot;&gt;&lt;code&gt;write_vectored&lt;/code&gt;&lt;/a&gt; were necessary. It is best to understand this function as taking ownership of &lt;code&gt;bufs&lt;/code&gt; and to not use &lt;code&gt;bufs&lt;/code&gt; afterwards. The underlying buffers, to which the &lt;a href=&quot;struct.ioslice&quot;&gt;&lt;code&gt;IoSlice&lt;/code&gt;&lt;/a&gt;s point (but not the &lt;a href=&quot;struct.ioslice&quot;&gt;&lt;code&gt;IoSlice&lt;/code&gt;&lt;/a&gt;s themselves), are unchanged and can be reused.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0fa4b20ac7b7c2a8a0f92535a2333b6aa807706f" translate="yes" xml:space="preserve">
          <source>Once we&amp;rsquo;ve created an iterator, we can use it in a variety of ways. In Listing 3-5 in Chapter 3, we used iterators with &lt;code&gt;for&lt;/code&gt; loops to execute some code on each item, although we glossed over what the call to &lt;code&gt;iter&lt;/code&gt; did until now.</source>
          <target state="translated">После того, как мы создали итератор, мы можем использовать его различными способами. В листинге 3-5 главы 3 мы использовали итераторы с циклами &lt;code&gt;for&lt;/code&gt; для выполнения некоторого кода для каждого элемента, хотя до сих пор мы не освещали то, что делал вызов &lt;code&gt;iter&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="58851a1903858c976f2730a714ae3f3f46765304" translate="yes" xml:space="preserve">
          <source>Once we&amp;rsquo;ve implemented the &lt;code&gt;Iterator&lt;/code&gt; trait, we have an iterator! Listing 13-22 shows a test demonstrating that we can use the iterator functionality of our &lt;code&gt;Counter&lt;/code&gt; struct by calling the &lt;code&gt;next&lt;/code&gt; method on it directly, just as we did with the iterator created from a vector in Listing 13-15.</source>
          <target state="translated">Как только мы реализовали &lt;code&gt;Iterator&lt;/code&gt; , у нас есть итератор! В листинге 13-22 показан тест, демонстрирующий, что мы можем использовать функциональные возможности итератора нашей структуры &lt;code&gt;Counter&lt;/code&gt; , напрямую вызывая на ней &lt;code&gt;next&lt;/code&gt; метод, точно так же, как мы это делали с итератором, созданным из вектора в листинге 13-15.</target>
        </trans-unit>
        <trans-unit id="84bcbd885f09e288fb3013478b1c1b345aab434e" translate="yes" xml:space="preserve">
          <source>Once you are familiar with the contents of the standard library you may begin to find the verbosity of the prose distracting. At this stage in your development you may want to press the &lt;code&gt;[-]&lt;/code&gt; button near the top of the page to collapse it into a more skimmable view.</source>
          <target state="translated">Как только вы ознакомитесь с содержимым стандартной библиотеки, вы, возможно, начнете находить, что многословие прозы отвлекает. На этом этапе разработки вы можете нажать кнопку &lt;code&gt;[-]&lt;/code&gt; в верхней части страницы, чтобы свернуть ее в более удобное для просмотра изображение.</target>
        </trans-unit>
        <trans-unit id="f9e4ff73fcbf2b9b71b1855afa48c76c6aa49139" translate="yes" xml:space="preserve">
          <source>Once you have the kind of slice you need (with or without a nul terminator), you can call the slice's own &lt;a href=&quot;../primitive.slice#method.as_ptr&quot;&gt;&lt;code&gt;as_ptr&lt;/code&gt;&lt;/a&gt; method to get a read-only raw pointer to pass to extern functions. See the documentation for that function for a discussion on ensuring the lifetime of the raw pointer.</source>
          <target state="translated">Как только у вас есть нужный вам фрагмент (с нулевым терминатором или без него), вы можете вызвать собственный метод &lt;a href=&quot;../primitive.slice#method.as_ptr&quot;&gt; &lt;code&gt;as_ptr&lt;/code&gt; фрагмента,&lt;/a&gt; чтобы получить доступный только для чтения необработанный указатель для перехода к внешним функциям. См. Документацию по этой функции для обсуждения обеспечения времени жизни необработанного указателя.</target>
        </trans-unit>
        <trans-unit id="ef776c26c7f6b2f89aaf4c349afba29be9ab2040" translate="yes" xml:space="preserve">
          <source>Once::all</source>
          <target state="translated">Once::all</target>
        </trans-unit>
        <trans-unit id="fa85c00dce196844734611fc55302ba498cdda9b" translate="yes" xml:space="preserve">
          <source>Once::any</source>
          <target state="translated">Once::any</target>
        </trans-unit>
        <trans-unit id="826f1ec43224196e7c0e18a9f4c8ba3d03de27f1" translate="yes" xml:space="preserve">
          <source>Once::borrow</source>
          <target state="translated">Once::borrow</target>
        </trans-unit>
        <trans-unit id="e53e91b8fe24cb0570a1a97b3316a02ec5d3ee03" translate="yes" xml:space="preserve">
          <source>Once::borrow_mut</source>
          <target state="translated">Once::borrow_mut</target>
        </trans-unit>
        <trans-unit id="c2f8e8374534fd9f5e2ff592398a6ffc6014fd99" translate="yes" xml:space="preserve">
          <source>Once::by_ref</source>
          <target state="translated">Once::by_ref</target>
        </trans-unit>
        <trans-unit id="28a72e0c985bccd2edce22b1340d3ed027a4ac1f" translate="yes" xml:space="preserve">
          <source>Once::call_once</source>
          <target state="translated">Once::call_once</target>
        </trans-unit>
        <trans-unit id="e0cfc1e91951cfca51a0190fd8a21d0b035190a9" translate="yes" xml:space="preserve">
          <source>Once::call_once_force</source>
          <target state="translated">Once::call_once_force</target>
        </trans-unit>
        <trans-unit id="1376857cb86f72af6eff74ad397cf00fcde6210e" translate="yes" xml:space="preserve">
          <source>Once::chain</source>
          <target state="translated">Once::chain</target>
        </trans-unit>
        <trans-unit id="190ff92b2c593bf6e13bca7abde87e505a3ec2bb" translate="yes" xml:space="preserve">
          <source>Once::clone</source>
          <target state="translated">Once::clone</target>
        </trans-unit>
        <trans-unit id="212f098b1763e1e51ae7f7bc19ffa302ddfe30a1" translate="yes" xml:space="preserve">
          <source>Once::clone_from</source>
          <target state="translated">Once::clone_from</target>
        </trans-unit>
        <trans-unit id="311f7aa02f0a54433f61dae481c3b3e4040d2495" translate="yes" xml:space="preserve">
          <source>Once::clone_into</source>
          <target state="translated">Once::clone_into</target>
        </trans-unit>
        <trans-unit id="19afa196b08d6f8f3b6f43f40d2d7cd3c50fbc8f" translate="yes" xml:space="preserve">
          <source>Once::cloned</source>
          <target state="translated">Once::cloned</target>
        </trans-unit>
        <trans-unit id="6b4930ea79c81962eae48dcaf70c7227f1aa12a7" translate="yes" xml:space="preserve">
          <source>Once::cmp</source>
          <target state="translated">Once::cmp</target>
        </trans-unit>
        <trans-unit id="5d169980cad74ac2c6880808ed94fb787b98960a" translate="yes" xml:space="preserve">
          <source>Once::collect</source>
          <target state="translated">Once::collect</target>
        </trans-unit>
        <trans-unit id="313d94ea32a51b1b516cb8b52850728efe9ae8b5" translate="yes" xml:space="preserve">
          <source>Once::copied</source>
          <target state="translated">Once::copied</target>
        </trans-unit>
        <trans-unit id="f98560cce6e4eadc3911ce81d61f52d107ea5142" translate="yes" xml:space="preserve">
          <source>Once::count</source>
          <target state="translated">Once::count</target>
        </trans-unit>
        <trans-unit id="2ef6bd0928aad3dcaf46fb7f0bdafb3492745ec4" translate="yes" xml:space="preserve">
          <source>Once::cycle</source>
          <target state="translated">Once::cycle</target>
        </trans-unit>
        <trans-unit id="8ad5b4150f82970fff0038e17ac64a51521d1924" translate="yes" xml:space="preserve">
          <source>Once::enumerate</source>
          <target state="translated">Once::enumerate</target>
        </trans-unit>
        <trans-unit id="23c903ad536fa2bd73035fce46787048ed4f628a" translate="yes" xml:space="preserve">
          <source>Once::eq</source>
          <target state="translated">Once::eq</target>
        </trans-unit>
        <trans-unit id="82879e4fcf39171c09b466e2bf43bc8f45af6822" translate="yes" xml:space="preserve">
          <source>Once::filter</source>
          <target state="translated">Once::filter</target>
        </trans-unit>
        <trans-unit id="095605951ca140555bd59e4149308c63f272478d" translate="yes" xml:space="preserve">
          <source>Once::filter_map</source>
          <target state="translated">Once::filter_map</target>
        </trans-unit>
        <trans-unit id="7ca070326207c327aa1bb557f657f2fac61b1c8a" translate="yes" xml:space="preserve">
          <source>Once::find</source>
          <target state="translated">Once::find</target>
        </trans-unit>
        <trans-unit id="f8cbae0491d42da2ee0b9caaa6d41cbeef0233e4" translate="yes" xml:space="preserve">
          <source>Once::find_map</source>
          <target state="translated">Once::find_map</target>
        </trans-unit>
        <trans-unit id="8f0358e16d2477b8dc5e572ca1dae6005b455b17" translate="yes" xml:space="preserve">
          <source>Once::flat_map</source>
          <target state="translated">Once::flat_map</target>
        </trans-unit>
        <trans-unit id="8580b5a613c1d1f4df99cede210bdc2e9fe3a843" translate="yes" xml:space="preserve">
          <source>Once::flatten</source>
          <target state="translated">Once::flatten</target>
        </trans-unit>
        <trans-unit id="c9a403b6a5f9f7ce825a2ce8e6b8fc78c53b4261" translate="yes" xml:space="preserve">
          <source>Once::fmt</source>
          <target state="translated">Once::fmt</target>
        </trans-unit>
        <trans-unit id="a4dbe0ef075896956284d0f6da5e3cf48dd08238" translate="yes" xml:space="preserve">
          <source>Once::fold</source>
          <target state="translated">Once::fold</target>
        </trans-unit>
        <trans-unit id="9129023999880ed84891680b4f8fd96dda590894" translate="yes" xml:space="preserve">
          <source>Once::for_each</source>
          <target state="translated">Once::for_each</target>
        </trans-unit>
        <trans-unit id="d64f18e6780e0faf671ed9d539a0b268b8174066" translate="yes" xml:space="preserve">
          <source>Once::from</source>
          <target state="translated">Once::from</target>
        </trans-unit>
        <trans-unit id="bbf7ace21ce049891d14dd08bdb7b81831f05411" translate="yes" xml:space="preserve">
          <source>Once::fuse</source>
          <target state="translated">Once::fuse</target>
        </trans-unit>
        <trans-unit id="6d843124e3a2669cb3c40cac626394b00fbd78a9" translate="yes" xml:space="preserve">
          <source>Once::ge</source>
          <target state="translated">Once::ge</target>
        </trans-unit>
        <trans-unit id="a9af56769b34f56c5ffcf89a8ea47ff768c6858a" translate="yes" xml:space="preserve">
          <source>Once::gt</source>
          <target state="translated">Once::gt</target>
        </trans-unit>
        <trans-unit id="52b97e5420ac6c5141f11b243b00d6a1d91a82aa" translate="yes" xml:space="preserve">
          <source>Once::inspect</source>
          <target state="translated">Once::inspect</target>
        </trans-unit>
        <trans-unit id="24c9670c06579750ad91802403773c861f00f73c" translate="yes" xml:space="preserve">
          <source>Once::into</source>
          <target state="translated">Once::into</target>
        </trans-unit>
        <trans-unit id="efb0afcea9cf69ad9f300407891f7cf24889abde" translate="yes" xml:space="preserve">
          <source>Once::into_iter</source>
          <target state="translated">Once::into_iter</target>
        </trans-unit>
        <trans-unit id="0608fd7f8eac14cce16ca80dbfd5613b14204122" translate="yes" xml:space="preserve">
          <source>Once::is_completed</source>
          <target state="translated">Once::is_completed</target>
        </trans-unit>
        <trans-unit id="7251c3dcf49fe3c4c5830d926dcb3f340b9a4518" translate="yes" xml:space="preserve">
          <source>Once::is_empty</source>
          <target state="translated">Once::is_empty</target>
        </trans-unit>
        <trans-unit id="4b0fbfe12c4a015929a04dd53407a0499a03410c" translate="yes" xml:space="preserve">
          <source>Once::is_sorted</source>
          <target state="translated">Once::is_sorted</target>
        </trans-unit>
        <trans-unit id="6f25e0f3331d93f4e5eb47652d49ab83abddd5c6" translate="yes" xml:space="preserve">
          <source>Once::is_sorted_by</source>
          <target state="translated">Once::is_sorted_by</target>
        </trans-unit>
        <trans-unit id="cb7a1da6af62c62d1c48e6f892b45246ff8fb722" translate="yes" xml:space="preserve">
          <source>Once::is_sorted_by_key</source>
          <target state="translated">Once::is_sorted_by_key</target>
        </trans-unit>
        <trans-unit id="12b8716333449d7ef6ccc84a866d8c71f4d4596a" translate="yes" xml:space="preserve">
          <source>Once::last</source>
          <target state="translated">Once::last</target>
        </trans-unit>
        <trans-unit id="14b21ec5ab3251444e0715d08a995824bf98046f" translate="yes" xml:space="preserve">
          <source>Once::le</source>
          <target state="translated">Once::le</target>
        </trans-unit>
        <trans-unit id="c7ec127a76b81f92cbddfa60f7e443869f07dfc3" translate="yes" xml:space="preserve">
          <source>Once::len</source>
          <target state="translated">Once::len</target>
        </trans-unit>
        <trans-unit id="5200802a32d08edabd28e77c8bfacda66faabb5f" translate="yes" xml:space="preserve">
          <source>Once::lt</source>
          <target state="translated">Once::lt</target>
        </trans-unit>
        <trans-unit id="f2976b7d4debc6f0c6faff19e72feb23c6da98c9" translate="yes" xml:space="preserve">
          <source>Once::map</source>
          <target state="translated">Once::map</target>
        </trans-unit>
        <trans-unit id="37c43ed9043bf5a1d86c776c7a83980f8e44b550" translate="yes" xml:space="preserve">
          <source>Once::max</source>
          <target state="translated">Once::max</target>
        </trans-unit>
        <trans-unit id="42f687a90cb8ae799fc923fe98bf332780e16e1a" translate="yes" xml:space="preserve">
          <source>Once::max_by</source>
          <target state="translated">Once::max_by</target>
        </trans-unit>
        <trans-unit id="f790fae0c1ab8520d2b3bb6dee8c10e0df61fb21" translate="yes" xml:space="preserve">
          <source>Once::max_by_key</source>
          <target state="translated">Once::max_by_key</target>
        </trans-unit>
        <trans-unit id="be86a53ca110f0c0f2e5f786db25770b11e8fb89" translate="yes" xml:space="preserve">
          <source>Once::min</source>
          <target state="translated">Once::min</target>
        </trans-unit>
        <trans-unit id="5b4c2bfd34d4ce8913a24cdbba40c903c58ba228" translate="yes" xml:space="preserve">
          <source>Once::min_by</source>
          <target state="translated">Once::min_by</target>
        </trans-unit>
        <trans-unit id="0ff4bd1f1edb9d1e53ee61824c45a6b65f4eafd0" translate="yes" xml:space="preserve">
          <source>Once::min_by_key</source>
          <target state="translated">Once::min_by_key</target>
        </trans-unit>
        <trans-unit id="6236fe088142c957857770ab09a2b6fc2f27b69e" translate="yes" xml:space="preserve">
          <source>Once::ne</source>
          <target state="translated">Once::ne</target>
        </trans-unit>
        <trans-unit id="7d6911dda1f2483e209159a8e136b2c52051e6bb" translate="yes" xml:space="preserve">
          <source>Once::new</source>
          <target state="translated">Once::new</target>
        </trans-unit>
        <trans-unit id="578bd116c5e7fde5716979b05be2a783abe2fcec" translate="yes" xml:space="preserve">
          <source>Once::next</source>
          <target state="translated">Once::next</target>
        </trans-unit>
        <trans-unit id="8af821c9e317f67614d97739eed7d7394a46629b" translate="yes" xml:space="preserve">
          <source>Once::next_back</source>
          <target state="translated">Once::next_back</target>
        </trans-unit>
        <trans-unit id="430bb3482a938ef6cd7fe977041d4fa3bbc1fc55" translate="yes" xml:space="preserve">
          <source>Once::nth</source>
          <target state="translated">Once::nth</target>
        </trans-unit>
        <trans-unit id="c55b0c5a25d6a4c7729b67045964bd182f6c743b" translate="yes" xml:space="preserve">
          <source>Once::nth_back</source>
          <target state="translated">Once::nth_back</target>
        </trans-unit>
        <trans-unit id="22c36618829e3a03fdefff9bbca40dbd8e473846" translate="yes" xml:space="preserve">
          <source>Once::partial_cmp</source>
          <target state="translated">Once::partial_cmp</target>
        </trans-unit>
        <trans-unit id="b7269ba05ed7753f4b47e7a0b54fad46c7fdfa25" translate="yes" xml:space="preserve">
          <source>Once::partition</source>
          <target state="translated">Once::partition</target>
        </trans-unit>
        <trans-unit id="a2a93318d906b75ba7d478b7d2053f09b5d47c8e" translate="yes" xml:space="preserve">
          <source>Once::peekable</source>
          <target state="translated">Once::peekable</target>
        </trans-unit>
        <trans-unit id="443ba5a518af1ceeeb00165b521452d07ea04e5b" translate="yes" xml:space="preserve">
          <source>Once::position</source>
          <target state="translated">Once::position</target>
        </trans-unit>
        <trans-unit id="aefb04c2392cc211f451d367f733cc6c65c3e11b" translate="yes" xml:space="preserve">
          <source>Once::product</source>
          <target state="translated">Once::product</target>
        </trans-unit>
        <trans-unit id="0bc9c08f73c34cac78d945ebc22d8397bbb66131" translate="yes" xml:space="preserve">
          <source>Once::rev</source>
          <target state="translated">Once::rev</target>
        </trans-unit>
        <trans-unit id="3c7856aff7c1c10689eb91760b905ac36a86fd8f" translate="yes" xml:space="preserve">
          <source>Once::rfind</source>
          <target state="translated">Once::rfind</target>
        </trans-unit>
        <trans-unit id="bb98b537fa90b815cfad245be9b6f8a9980c10ad" translate="yes" xml:space="preserve">
          <source>Once::rfold</source>
          <target state="translated">Once::rfold</target>
        </trans-unit>
        <trans-unit id="068dbc2b0446d02924974dc89dc2e5c0506be3c0" translate="yes" xml:space="preserve">
          <source>Once::rposition</source>
          <target state="translated">Once::rposition</target>
        </trans-unit>
        <trans-unit id="2f7d42081a9a3b1a18973e17303b804987f7c991" translate="yes" xml:space="preserve">
          <source>Once::scan</source>
          <target state="translated">Once::scan</target>
        </trans-unit>
        <trans-unit id="689e357b41f0be20a1862814b9c83d77ef8f1e70" translate="yes" xml:space="preserve">
          <source>Once::size_hint</source>
          <target state="translated">Once::size_hint</target>
        </trans-unit>
        <trans-unit id="cbf339d38d49468cb345d7cfb9cb77b78f365fd1" translate="yes" xml:space="preserve">
          <source>Once::skip</source>
          <target state="translated">Once::skip</target>
        </trans-unit>
        <trans-unit id="86fd91a24a1bbc66ca2ece695858498a65db16dd" translate="yes" xml:space="preserve">
          <source>Once::skip_while</source>
          <target state="translated">Once::skip_while</target>
        </trans-unit>
        <trans-unit id="6fe0f81f7153271dc977040947a6cad61882f9d1" translate="yes" xml:space="preserve">
          <source>Once::step_by</source>
          <target state="translated">Once::step_by</target>
        </trans-unit>
        <trans-unit id="033b2578f1615ee184814d95335d5fd74302c231" translate="yes" xml:space="preserve">
          <source>Once::sum</source>
          <target state="translated">Once::sum</target>
        </trans-unit>
        <trans-unit id="442e2927616d29972c328197ab646af0a109e0ac" translate="yes" xml:space="preserve">
          <source>Once::take</source>
          <target state="translated">Once::take</target>
        </trans-unit>
        <trans-unit id="e0055054cf1a45bf179b412f905b6b7b804fe427" translate="yes" xml:space="preserve">
          <source>Once::take_while</source>
          <target state="translated">Once::take_while</target>
        </trans-unit>
        <trans-unit id="1ff7fdb84e0ce09813e50c320654790d32c718fe" translate="yes" xml:space="preserve">
          <source>Once::to_owned</source>
          <target state="translated">Once::to_owned</target>
        </trans-unit>
        <trans-unit id="b045ee709dc7ad89b9c21500aecbcde1537d7e58" translate="yes" xml:space="preserve">
          <source>Once::try_fold</source>
          <target state="translated">Once::try_fold</target>
        </trans-unit>
        <trans-unit id="ca7011c5d5b35881f4391164193c191f7c91a8ed" translate="yes" xml:space="preserve">
          <source>Once::try_for_each</source>
          <target state="translated">Once::try_for_each</target>
        </trans-unit>
        <trans-unit id="145392f846fa35a3754a9cdb737cf3389c9b3bb1" translate="yes" xml:space="preserve">
          <source>Once::try_from</source>
          <target state="translated">Once::try_from</target>
        </trans-unit>
        <trans-unit id="36d585158ca953d0dbbe69c61419f1e9cfd5cbd0" translate="yes" xml:space="preserve">
          <source>Once::try_into</source>
          <target state="translated">Once::try_into</target>
        </trans-unit>
        <trans-unit id="bb47966988d0ea30157cfc9b32edfc0454ef3340" translate="yes" xml:space="preserve">
          <source>Once::try_rfold</source>
          <target state="translated">Once::try_rfold</target>
        </trans-unit>
        <trans-unit id="0e7005b30f23dbe8e521fbb090487b02e260839e" translate="yes" xml:space="preserve">
          <source>Once::type_id</source>
          <target state="translated">Once::type_id</target>
        </trans-unit>
        <trans-unit id="89b4b7dbbcd40342a9b06361de2f912cf9887391" translate="yes" xml:space="preserve">
          <source>Once::unzip</source>
          <target state="translated">Once::unzip</target>
        </trans-unit>
        <trans-unit id="9c587dbc5b4ada9eb96816888453bd9099854f2c" translate="yes" xml:space="preserve">
          <source>Once::zip</source>
          <target state="translated">Once::zip</target>
        </trans-unit>
        <trans-unit id="69dcb4de79e8a81381a0466b75f257a36ecf89cd" translate="yes" xml:space="preserve">
          <source>OnceCell</source>
          <target state="translated">OnceCell</target>
        </trans-unit>
        <trans-unit id="2db71cb543a4836972aba340022bf66c34ca9483" translate="yes" xml:space="preserve">
          <source>OnceState</source>
          <target state="translated">OnceState</target>
        </trans-unit>
        <trans-unit id="864b2494c0a17291fe44802d2dfa7280c6515a58" translate="yes" xml:space="preserve">
          <source>OnceState::borrow</source>
          <target state="translated">OnceState::borrow</target>
        </trans-unit>
        <trans-unit id="3ba03425574355acef161a03b37753e3dc3fce0d" translate="yes" xml:space="preserve">
          <source>OnceState::borrow_mut</source>
          <target state="translated">OnceState::borrow_mut</target>
        </trans-unit>
        <trans-unit id="137f612918b3ff9f01b5b2eed8a892cbbde080f1" translate="yes" xml:space="preserve">
          <source>OnceState::fmt</source>
          <target state="translated">OnceState::fmt</target>
        </trans-unit>
        <trans-unit id="cc9d74ec28c33e153d2d0894a6de5f14c5c9aabd" translate="yes" xml:space="preserve">
          <source>OnceState::from</source>
          <target state="translated">OnceState::from</target>
        </trans-unit>
        <trans-unit id="d968db4b631f42cce77d0ea2bff8656be4e57c06" translate="yes" xml:space="preserve">
          <source>OnceState::into</source>
          <target state="translated">OnceState::into</target>
        </trans-unit>
        <trans-unit id="5279da3ce88f5a2ebd344f9b9ae566f2cb009268" translate="yes" xml:space="preserve">
          <source>OnceState::poisoned</source>
          <target state="translated">OnceState::poisoned</target>
        </trans-unit>
        <trans-unit id="8447bc72e127b3443efef418a2e8188e3cc3f620" translate="yes" xml:space="preserve">
          <source>OnceState::try_from</source>
          <target state="translated">OnceState::try_from</target>
        </trans-unit>
        <trans-unit id="2a35fc55239b76803a74ad10688fe793f6102501" translate="yes" xml:space="preserve">
          <source>OnceState::try_into</source>
          <target state="translated">OnceState::try_into</target>
        </trans-unit>
        <trans-unit id="fcd8d541e6822fd809940974bebc8a81f8b16c8d" translate="yes" xml:space="preserve">
          <source>OnceState::type_id</source>
          <target state="translated">OnceState::type_id</target>
        </trans-unit>
        <trans-unit id="bac414ebd5a08ef0bd8f0f09a9b6b081da1540b4" translate="yes" xml:space="preserve">
          <source>OnceWith</source>
          <target state="translated">OnceWith</target>
        </trans-unit>
        <trans-unit id="9421b02fba334e65b31591c89d7fcfa34aea5e57" translate="yes" xml:space="preserve">
          <source>OnceWith::all</source>
          <target state="translated">OnceWith::all</target>
        </trans-unit>
        <trans-unit id="ec045f959571abb529fe845ffb143c5aa440d98a" translate="yes" xml:space="preserve">
          <source>OnceWith::any</source>
          <target state="translated">OnceWith::any</target>
        </trans-unit>
        <trans-unit id="1ef37dd0c57f299c431f6fc7296ed50225f08e1a" translate="yes" xml:space="preserve">
          <source>OnceWith::borrow</source>
          <target state="translated">OnceWith::borrow</target>
        </trans-unit>
        <trans-unit id="527f129227b962c7154dfbbc8fa56239753273a3" translate="yes" xml:space="preserve">
          <source>OnceWith::borrow_mut</source>
          <target state="translated">OnceWith::borrow_mut</target>
        </trans-unit>
        <trans-unit id="220386db15c3ac797f2d78a1fa6328e0e524bbaa" translate="yes" xml:space="preserve">
          <source>OnceWith::by_ref</source>
          <target state="translated">OnceWith::by_ref</target>
        </trans-unit>
        <trans-unit id="8cca4e55ae50dd0aee68afe79ea244d5bca99ced" translate="yes" xml:space="preserve">
          <source>OnceWith::chain</source>
          <target state="translated">OnceWith::chain</target>
        </trans-unit>
        <trans-unit id="69a3e8d814785ab85c33556c6a099c9cc6ea940e" translate="yes" xml:space="preserve">
          <source>OnceWith::clone</source>
          <target state="translated">OnceWith::clone</target>
        </trans-unit>
        <trans-unit id="18ada5e17d413555745065a07348ed90106c203d" translate="yes" xml:space="preserve">
          <source>OnceWith::clone_from</source>
          <target state="translated">OnceWith::clone_from</target>
        </trans-unit>
        <trans-unit id="840d6af9e9dfbf237e7af2ccf27dbd5ad69cee46" translate="yes" xml:space="preserve">
          <source>OnceWith::clone_into</source>
          <target state="translated">OnceWith::clone_into</target>
        </trans-unit>
        <trans-unit id="28fb35fd1901c33eee7b84b451b7753c7c867260" translate="yes" xml:space="preserve">
          <source>OnceWith::cloned</source>
          <target state="translated">OnceWith::cloned</target>
        </trans-unit>
        <trans-unit id="30d119dee0d9c070c3e61005d6831099ce8bd793" translate="yes" xml:space="preserve">
          <source>OnceWith::cmp</source>
          <target state="translated">OnceWith::cmp</target>
        </trans-unit>
        <trans-unit id="abe9447efe3162bb1b99fa4be3a78e85a49dc04b" translate="yes" xml:space="preserve">
          <source>OnceWith::collect</source>
          <target state="translated">OnceWith::collect</target>
        </trans-unit>
        <trans-unit id="4d6da14365d0d73a28c1b23f782a042915618b92" translate="yes" xml:space="preserve">
          <source>OnceWith::copied</source>
          <target state="translated">OnceWith::copied</target>
        </trans-unit>
        <trans-unit id="7016f9903cc220eec1b3d930f0d6d91062934899" translate="yes" xml:space="preserve">
          <source>OnceWith::count</source>
          <target state="translated">OnceWith::count</target>
        </trans-unit>
        <trans-unit id="addfc373b9df5fc305b9e5e6eb635cd2466d07d4" translate="yes" xml:space="preserve">
          <source>OnceWith::cycle</source>
          <target state="translated">OnceWith::cycle</target>
        </trans-unit>
        <trans-unit id="095f0dc0c2b642b81131fb698197ca6766b54a2e" translate="yes" xml:space="preserve">
          <source>OnceWith::enumerate</source>
          <target state="translated">OnceWith::enumerate</target>
        </trans-unit>
        <trans-unit id="7e9ec613a8f6c55d8eb6ea553ee7ebd7e6244ce6" translate="yes" xml:space="preserve">
          <source>OnceWith::eq</source>
          <target state="translated">OnceWith::eq</target>
        </trans-unit>
        <trans-unit id="f3f3ad0faefd45bbd859ece3bf3eef9075759214" translate="yes" xml:space="preserve">
          <source>OnceWith::filter</source>
          <target state="translated">OnceWith::filter</target>
        </trans-unit>
        <trans-unit id="ea81115d4b00890df3a160e9b9a84ff71ded3a01" translate="yes" xml:space="preserve">
          <source>OnceWith::filter_map</source>
          <target state="translated">OnceWith::filter_map</target>
        </trans-unit>
        <trans-unit id="04462b9dd7bbda24ad2bd90e2b7883781de4acd6" translate="yes" xml:space="preserve">
          <source>OnceWith::find</source>
          <target state="translated">OnceWith::find</target>
        </trans-unit>
        <trans-unit id="aca2dee92401221e00169ab44175f018d2db65f4" translate="yes" xml:space="preserve">
          <source>OnceWith::find_map</source>
          <target state="translated">OnceWith::find_map</target>
        </trans-unit>
        <trans-unit id="10d39de4f24d2dcddb78ea6874f21fecb0e42b39" translate="yes" xml:space="preserve">
          <source>OnceWith::flat_map</source>
          <target state="translated">OnceWith::flat_map</target>
        </trans-unit>
        <trans-unit id="6ff780249f2a51d00d5d95dcfd4610dadafd2bd8" translate="yes" xml:space="preserve">
          <source>OnceWith::flatten</source>
          <target state="translated">OnceWith::flatten</target>
        </trans-unit>
        <trans-unit id="e7394a8ea887cd043223fc687a97cc1f193256c1" translate="yes" xml:space="preserve">
          <source>OnceWith::fmt</source>
          <target state="translated">OnceWith::fmt</target>
        </trans-unit>
        <trans-unit id="5e004a4ea95a589f773f9befbef25abe72f46ba2" translate="yes" xml:space="preserve">
          <source>OnceWith::fold</source>
          <target state="translated">OnceWith::fold</target>
        </trans-unit>
        <trans-unit id="0826514ea858174b22832240424d387a6a62a698" translate="yes" xml:space="preserve">
          <source>OnceWith::for_each</source>
          <target state="translated">OnceWith::for_each</target>
        </trans-unit>
        <trans-unit id="6f44e41130791319e6c6d5e080615570ac91fa72" translate="yes" xml:space="preserve">
          <source>OnceWith::from</source>
          <target state="translated">OnceWith::from</target>
        </trans-unit>
        <trans-unit id="d991094123caac201e372f78da1221c72316dec1" translate="yes" xml:space="preserve">
          <source>OnceWith::fuse</source>
          <target state="translated">OnceWith::fuse</target>
        </trans-unit>
        <trans-unit id="491865c492a9358b9d74d7461f65fbb3c2ad3116" translate="yes" xml:space="preserve">
          <source>OnceWith::ge</source>
          <target state="translated">OnceWith::ge</target>
        </trans-unit>
        <trans-unit id="cb6cb84ba3cef039e288bea61f9e271654ca16b3" translate="yes" xml:space="preserve">
          <source>OnceWith::gt</source>
          <target state="translated">OnceWith::gt</target>
        </trans-unit>
        <trans-unit id="f9bca0dbc5eb1308057e3acda537f87ae5584bf0" translate="yes" xml:space="preserve">
          <source>OnceWith::inspect</source>
          <target state="translated">OnceWith::inspect</target>
        </trans-unit>
        <trans-unit id="130c0779f2fab716215af75fb82426f43a016224" translate="yes" xml:space="preserve">
          <source>OnceWith::into</source>
          <target state="translated">OnceWith::into</target>
        </trans-unit>
        <trans-unit id="e53104deb8174e788d926bdbaa53ed5840ec7390" translate="yes" xml:space="preserve">
          <source>OnceWith::into_iter</source>
          <target state="translated">OnceWith::into_iter</target>
        </trans-unit>
        <trans-unit id="57fb266c4456dcf8194282f31a9c9693a675f52f" translate="yes" xml:space="preserve">
          <source>OnceWith::is_empty</source>
          <target state="translated">OnceWith::is_empty</target>
        </trans-unit>
        <trans-unit id="35067e17a5dc55a4bb918b85dcd10ca948035cb7" translate="yes" xml:space="preserve">
          <source>OnceWith::is_sorted</source>
          <target state="translated">OnceWith::is_sorted</target>
        </trans-unit>
        <trans-unit id="fa54dbd797d14264ee865bf4783d41bbaaceb9bb" translate="yes" xml:space="preserve">
          <source>OnceWith::is_sorted_by</source>
          <target state="translated">OnceWith::is_sorted_by</target>
        </trans-unit>
        <trans-unit id="0805f33825aaffa765bd319b5f5123f28e25c541" translate="yes" xml:space="preserve">
          <source>OnceWith::is_sorted_by_key</source>
          <target state="translated">OnceWith::is_sorted_by_key</target>
        </trans-unit>
        <trans-unit id="b8642e0e6fa2a743b75cee962cacad7d55075240" translate="yes" xml:space="preserve">
          <source>OnceWith::last</source>
          <target state="translated">OnceWith::last</target>
        </trans-unit>
        <trans-unit id="93fa8fd9eba96e349d5cb407b64fe72f152eb5a8" translate="yes" xml:space="preserve">
          <source>OnceWith::le</source>
          <target state="translated">OnceWith::le</target>
        </trans-unit>
        <trans-unit id="7222c5552e670e1ab40e927a15a3bb3893a18137" translate="yes" xml:space="preserve">
          <source>OnceWith::len</source>
          <target state="translated">OnceWith::len</target>
        </trans-unit>
        <trans-unit id="115bc72442e41419d2748702b3dc2105c1045ca1" translate="yes" xml:space="preserve">
          <source>OnceWith::lt</source>
          <target state="translated">OnceWith::lt</target>
        </trans-unit>
        <trans-unit id="4a5a3ea857244c9e36891ebf8831e5ae98613302" translate="yes" xml:space="preserve">
          <source>OnceWith::map</source>
          <target state="translated">OnceWith::map</target>
        </trans-unit>
        <trans-unit id="e13117c44b319bc7f0f9709faa2a5544da1bccc4" translate="yes" xml:space="preserve">
          <source>OnceWith::max</source>
          <target state="translated">OnceWith::max</target>
        </trans-unit>
        <trans-unit id="5fe974dd4baeb92c36de177f1091466a40a950e9" translate="yes" xml:space="preserve">
          <source>OnceWith::max_by</source>
          <target state="translated">OnceWith::max_by</target>
        </trans-unit>
        <trans-unit id="4bced0b61c3c1cb8410f882718a68a33aeae5a9b" translate="yes" xml:space="preserve">
          <source>OnceWith::max_by_key</source>
          <target state="translated">OnceWith::max_by_key</target>
        </trans-unit>
        <trans-unit id="06568f09e719a331a84ceae60f4b66de6e9d0ea4" translate="yes" xml:space="preserve">
          <source>OnceWith::min</source>
          <target state="translated">OnceWith::min</target>
        </trans-unit>
        <trans-unit id="286481980c2d0b526534de52416aa1cce0683996" translate="yes" xml:space="preserve">
          <source>OnceWith::min_by</source>
          <target state="translated">OnceWith::min_by</target>
        </trans-unit>
        <trans-unit id="5dd37a258caeec2b0eb6451dca8a726b836a9a92" translate="yes" xml:space="preserve">
          <source>OnceWith::min_by_key</source>
          <target state="translated">OnceWith::min_by_key</target>
        </trans-unit>
        <trans-unit id="69f93b3a318af71379ddca4ec93fe8d140ce5f0f" translate="yes" xml:space="preserve">
          <source>OnceWith::ne</source>
          <target state="translated">OnceWith::ne</target>
        </trans-unit>
        <trans-unit id="ac26f725cccaf1526e5014347f9adea936f74ce7" translate="yes" xml:space="preserve">
          <source>OnceWith::next</source>
          <target state="translated">OnceWith::next</target>
        </trans-unit>
        <trans-unit id="e4330c855cf5f92fc7584c51cdee41319443487c" translate="yes" xml:space="preserve">
          <source>OnceWith::next_back</source>
          <target state="translated">OnceWith::next_back</target>
        </trans-unit>
        <trans-unit id="1527b9229bda86674b9d9102f7590dba88349ecd" translate="yes" xml:space="preserve">
          <source>OnceWith::nth</source>
          <target state="translated">OnceWith::nth</target>
        </trans-unit>
        <trans-unit id="52e0f2df5caf846213c666b22fff6456cda8a68f" translate="yes" xml:space="preserve">
          <source>OnceWith::nth_back</source>
          <target state="translated">OnceWith::nth_back</target>
        </trans-unit>
        <trans-unit id="2d124bbf09c7f2b80ff84f088c67f3f07ae5780b" translate="yes" xml:space="preserve">
          <source>OnceWith::partial_cmp</source>
          <target state="translated">OnceWith::partial_cmp</target>
        </trans-unit>
        <trans-unit id="cabc7165c7c9b316158511856e73e51b4305e89b" translate="yes" xml:space="preserve">
          <source>OnceWith::partition</source>
          <target state="translated">OnceWith::partition</target>
        </trans-unit>
        <trans-unit id="1cda021009cce16eced253abaf1a3a1b11566d18" translate="yes" xml:space="preserve">
          <source>OnceWith::peekable</source>
          <target state="translated">OnceWith::peekable</target>
        </trans-unit>
        <trans-unit id="03590b6367dd3bb1ba4d65b39afee2b09ca08df1" translate="yes" xml:space="preserve">
          <source>OnceWith::position</source>
          <target state="translated">OnceWith::position</target>
        </trans-unit>
        <trans-unit id="e1735abbbee6972dc130e89d570fd8fa919407fe" translate="yes" xml:space="preserve">
          <source>OnceWith::product</source>
          <target state="translated">OnceWith::product</target>
        </trans-unit>
        <trans-unit id="ec925c93a26e2eadc7d07e055f695e74c83d4c23" translate="yes" xml:space="preserve">
          <source>OnceWith::rev</source>
          <target state="translated">OnceWith::rev</target>
        </trans-unit>
        <trans-unit id="6243776ef017e4a1cf3d502a3968703e2ab8d6ed" translate="yes" xml:space="preserve">
          <source>OnceWith::rfind</source>
          <target state="translated">OnceWith::rfind</target>
        </trans-unit>
        <trans-unit id="aea12fd7d31659bccdee8c41ecdb4fb0f15444db" translate="yes" xml:space="preserve">
          <source>OnceWith::rfold</source>
          <target state="translated">OnceWith::rfold</target>
        </trans-unit>
        <trans-unit id="0c9e294cb61289d08c63ceca07aff5dfaea0261e" translate="yes" xml:space="preserve">
          <source>OnceWith::rposition</source>
          <target state="translated">OnceWith::rposition</target>
        </trans-unit>
        <trans-unit id="cef9b43e5eedf9af103faef7b1bbe4d12db9ab2f" translate="yes" xml:space="preserve">
          <source>OnceWith::scan</source>
          <target state="translated">OnceWith::scan</target>
        </trans-unit>
        <trans-unit id="cc6e5c82263a6bf9a575956ff17a327f6e8e1a12" translate="yes" xml:space="preserve">
          <source>OnceWith::size_hint</source>
          <target state="translated">OnceWith::size_hint</target>
        </trans-unit>
        <trans-unit id="eb30275a1bfcdf9e0075819a60e55de8140da973" translate="yes" xml:space="preserve">
          <source>OnceWith::skip</source>
          <target state="translated">OnceWith::skip</target>
        </trans-unit>
        <trans-unit id="d51df4ad9879230eee4b7d1f410130e26dd6a97e" translate="yes" xml:space="preserve">
          <source>OnceWith::skip_while</source>
          <target state="translated">OnceWith::skip_while</target>
        </trans-unit>
        <trans-unit id="13b1461f738d3541f7f825bf588919136b55d36d" translate="yes" xml:space="preserve">
          <source>OnceWith::step_by</source>
          <target state="translated">OnceWith::step_by</target>
        </trans-unit>
        <trans-unit id="74e43ad0cf8bc22a5af2d491f032ca5523c1d7b0" translate="yes" xml:space="preserve">
          <source>OnceWith::sum</source>
          <target state="translated">OnceWith::sum</target>
        </trans-unit>
        <trans-unit id="89cc6b13712f2c2ac536c3feb4e1809f1a6b5cc2" translate="yes" xml:space="preserve">
          <source>OnceWith::take</source>
          <target state="translated">OnceWith::take</target>
        </trans-unit>
        <trans-unit id="8c2cd8a3d3dfa6e2cb6f5f270f11cddff7173ce1" translate="yes" xml:space="preserve">
          <source>OnceWith::take_while</source>
          <target state="translated">OnceWith::take_while</target>
        </trans-unit>
        <trans-unit id="5a630013ba78b1577b011778f861dca34fdb6510" translate="yes" xml:space="preserve">
          <source>OnceWith::to_owned</source>
          <target state="translated">OnceWith::to_owned</target>
        </trans-unit>
        <trans-unit id="030ec595a21a12e03c641afa5fc2a0fbf3cfd96d" translate="yes" xml:space="preserve">
          <source>OnceWith::try_fold</source>
          <target state="translated">OnceWith::try_fold</target>
        </trans-unit>
        <trans-unit id="716d560ebaa2fa12887a04435f9271204fee9212" translate="yes" xml:space="preserve">
          <source>OnceWith::try_for_each</source>
          <target state="translated">OnceWith::try_for_each</target>
        </trans-unit>
        <trans-unit id="585e7e8b9f7e6990f4b13d54ca37d88a0bf70ca8" translate="yes" xml:space="preserve">
          <source>OnceWith::try_from</source>
          <target state="translated">OnceWith::try_from</target>
        </trans-unit>
        <trans-unit id="7cb93d634335cbd032ccfe91d14126a928250279" translate="yes" xml:space="preserve">
          <source>OnceWith::try_into</source>
          <target state="translated">OnceWith::try_into</target>
        </trans-unit>
        <trans-unit id="640ef41bdeff4cb6f8ee26085f02e8464a124452" translate="yes" xml:space="preserve">
          <source>OnceWith::try_rfold</source>
          <target state="translated">OnceWith::try_rfold</target>
        </trans-unit>
        <trans-unit id="100a64512cd2fe1b9fbd4ceea4850862b8f813b7" translate="yes" xml:space="preserve">
          <source>OnceWith::type_id</source>
          <target state="translated">OnceWith::type_id</target>
        </trans-unit>
        <trans-unit id="64fd105a0a6aa5f709a9477cafb3d6c01fd6cfb0" translate="yes" xml:space="preserve">
          <source>OnceWith::unzip</source>
          <target state="translated">OnceWith::unzip</target>
        </trans-unit>
        <trans-unit id="433df116ad00f74cb6d78ea83682ace23f21cb19" translate="yes" xml:space="preserve">
          <source>OnceWith::zip</source>
          <target state="translated">OnceWith::zip</target>
        </trans-unit>
        <trans-unit id="c04e60357eae6b0d2f646024db69bbf3bdb3f30b" translate="yes" xml:space="preserve">
          <source>One Rust community member, Andrew Gallant, has already created a fully featured, very fast version of &lt;code&gt;grep&lt;/code&gt;, called &lt;code&gt;ripgrep&lt;/code&gt;. By comparison, our version of &lt;code&gt;grep&lt;/code&gt; will be fairly simple, but this chapter will give you some of the background knowledge you need to understand a real-world project such as &lt;code&gt;ripgrep&lt;/code&gt;.</source>
          <target state="translated">Один из участников сообщества Rust, Эндрю Галлант, уже создал полнофункциональную, очень быструю версию &lt;code&gt;grep&lt;/code&gt; под названием &lt;code&gt;ripgrep&lt;/code&gt; . Для сравнения, наша версия &lt;code&gt;grep&lt;/code&gt; будет довольно простой, но эта глава даст вам некоторые &lt;code&gt;ripgrep&lt;/code&gt; знания, необходимые для понимания реального проекта, такого как ripgrep .</target>
        </trans-unit>
        <trans-unit id="6d8cb1de18a6c59ff63b7aa03082a18e5d9546ee" translate="yes" xml:space="preserve">
          <source>One benefit of implementing &lt;code&gt;IntoIterator&lt;/code&gt; is that your type will &lt;a href=&quot;index#for-loops-and-intoiterator&quot;&gt;work with Rust's &lt;code&gt;for&lt;/code&gt; loop syntax&lt;/a&gt;.</source>
          <target state="translated">Одним из преимуществ реализации &lt;code&gt;IntoIterator&lt;/code&gt; является то, что ваш тип будет &lt;a href=&quot;index#for-loops-and-intoiterator&quot;&gt;работать с синтаксисом цикла &lt;code&gt;for&lt;/code&gt; в Rust&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="1d5bdf955d9dc47b0601586e8217dda6094c541f" translate="yes" xml:space="preserve">
          <source>One character can become multiple:</source>
          <target state="translated">Один персонаж может стать многократным:</target>
        </trans-unit>
        <trans-unit id="9a0e2dea9fc38cc31adcbb6e264358edce5cb875" translate="yes" xml:space="preserve">
          <source>One could use &lt;code&gt;std::os::raw::c_void&lt;/code&gt; if they want to support old Rust compiler down to 1.1.0. After Rust 1.30.0, it was re-exported by this definition. For more information, please read &lt;a href=&quot;https://github.com/rust-lang/rfcs/blob/master/text/2521-c_void-reunification.md&quot;&gt;RFC 2521&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fa91f526636a9109f1e67616db8e82d52af8d580" translate="yes" xml:space="preserve">
          <source>One detail we didn&amp;rsquo;t discuss in the &lt;a href=&quot;ch04-02-references-and-borrowing#references-and-borrowing&quot;&gt;&amp;ldquo;References and Borrowing&amp;rdquo;&lt;/a&gt; section in Chapter 4 is that every reference in Rust has a &lt;em&gt;lifetime&lt;/em&gt;, which is the scope for which that reference is valid. Most of the time, lifetimes are implicit and inferred, just like most of the time, types are inferred. We must annotate types when multiple types are possible. In a similar way, we must annotate lifetimes when the lifetimes of references could be related in a few different ways. Rust requires us to annotate the relationships using generic lifetime parameters to ensure the actual references used at runtime will definitely be valid.</source>
          <target state="translated">Одна деталь, которую мы не обсуждали в разделе &lt;a href=&quot;ch04-02-references-and-borrowing#references-and-borrowing&quot;&gt;&amp;laquo;Ссылки и заимствование&amp;raquo;&lt;/a&gt; в главе 4, заключается в том, что каждая ссылка в Rust имеет время &lt;em&gt;жизни&lt;/em&gt; , которое является областью действия, для которой эта ссылка действительна. В большинстве случаев время жизни неявно и подразумевается, как и большую часть времени, предполагаются типы. Мы должны аннотировать типы, когда возможны несколько типов. Аналогичным образом мы должны аннотировать время жизни, когда время жизни ссылок может быть связано несколькими разными способами. Rust требует, чтобы мы аннотировали отношения, используя общие параметры времени жизни, чтобы гарантировать, что фактические ссылки, используемые во время выполнения, определенно будут действительными.</target>
        </trans-unit>
        <trans-unit id="d218cebb1b26aab7ac78425185eee65d682c0943" translate="yes" xml:space="preserve">
          <source>One downside of the state pattern is that, because the states implement the transitions between states, some of the states are coupled to each other. If we add another state between &lt;code&gt;PendingReview&lt;/code&gt; and &lt;code&gt;Published&lt;/code&gt;, such as &lt;code&gt;Scheduled&lt;/code&gt;, we would have to change the code in &lt;code&gt;PendingReview&lt;/code&gt; to transition to &lt;code&gt;Scheduled&lt;/code&gt; instead. It would be less work if &lt;code&gt;PendingReview&lt;/code&gt; didn&amp;rsquo;t need to change with the addition of a new state, but that would mean switching to another design pattern.</source>
          <target state="translated">Одним из недостатков паттерна состояний является то, что, поскольку состояния реализуют переходы между состояниями, некоторые состояния связаны друг с другом. Если мы добавим другое состояние между &lt;code&gt;PendingReview&lt;/code&gt; и &lt;code&gt;Published&lt;/code&gt; , например &lt;code&gt;Scheduled&lt;/code&gt; , нам придется изменить код в &lt;code&gt;PendingReview&lt;/code&gt; для перехода к &lt;code&gt;Scheduled&lt;/code&gt; . Было бы меньше работы, если бы &lt;code&gt;PendingReview&lt;/code&gt; не нужно было изменять с добавлением нового состояния, но это означало бы переключение на другой шаблон проектирования.</target>
        </trans-unit>
        <trans-unit id="79dab74a608a5fe55775f425d883e5609ea6484a" translate="yes" xml:space="preserve">
          <source>One example of a trait with an associated type is the &lt;code&gt;Iterator&lt;/code&gt; trait that the standard library provides. The associated type is named &lt;code&gt;Item&lt;/code&gt; and stands in for the type of the values the type implementing the &lt;code&gt;Iterator&lt;/code&gt; trait is iterating over. In &lt;a href=&quot;ch13-02-iterators#the-iterator-trait-and-the-next-method&quot;&gt;&amp;ldquo;The &lt;code&gt;Iterator&lt;/code&gt; Trait and the &lt;code&gt;next&lt;/code&gt; Method&amp;rdquo;&lt;/a&gt; section of Chapter 13, we mentioned that the definition of the &lt;code&gt;Iterator&lt;/code&gt; trait is as shown in Listing 19-12.</source>
          <target state="translated">Одним из примеров признака со связанным типом является признак &lt;code&gt;Iterator&lt;/code&gt; , предоставляемый стандартной библиотекой. Связанный тип называется &lt;code&gt;Item&lt;/code&gt; и заменяет тип значений, которые повторяет тип, реализующий свойство &lt;code&gt;Iterator&lt;/code&gt; . В разделе &lt;a href=&quot;ch13-02-iterators#the-iterator-trait-and-the-next-method&quot;&gt;&amp;laquo; &lt;code&gt;Iterator&lt;/code&gt; и &lt;code&gt;next&lt;/code&gt; метод&amp;raquo;&lt;/a&gt; главы 13 мы упоминали, что определение признака &lt;code&gt;Iterator&lt;/code&gt; показано в листинге 19-12.</target>
        </trans-unit>
        <trans-unit id="6e24d429d27b48134811a91f7546e1e6d93fd489" translate="yes" xml:space="preserve">
          <source>One final expression that has the type &lt;code&gt;!&lt;/code&gt; is a &lt;code&gt;loop&lt;/code&gt;:</source>
          <target state="translated">Последнее выражение, имеющее тип &lt;code&gt;!&lt;/code&gt; это &lt;code&gt;loop&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="08b7d5a5c0be732c550b04476aeb4d64ed0d9f34" translate="yes" xml:space="preserve">
          <source>One fix is to use &lt;code&gt;Option&lt;/code&gt;, like so:</source>
          <target state="translated">Одно из исправлений - использовать &lt;code&gt;Option&lt;/code&gt; , например:</target>
        </trans-unit>
        <trans-unit id="0404f28b47072e36d14ad36dc7e51fdfb00d1799" translate="yes" xml:space="preserve">
          <source>One fix may be to increase the recursion limit. Note that it is possible to create an infinite recursion of dereferencing, in which case the only fix is to somehow break the recursion.</source>
          <target state="translated">Одним из исправлений может быть увеличение предела рекурсии.Обратите внимание,что можно создать бесконечную рекурсию разыменования,в этом случае единственное исправление-это как-то прервать рекурсию.</target>
        </trans-unit>
        <trans-unit id="604777bf4c9ef568f65e74a5ef4770d9197bf0e4" translate="yes" xml:space="preserve">
          <source>One greater than the minimum possible normal power of 2 exponent.</source>
          <target state="translated">На один больше,чем минимально возможная нормальная мощность 2-х экспонентов.</target>
        </trans-unit>
        <trans-unit id="d1aad5d49e44c9e98dc9d596c60e87f16270d447" translate="yes" xml:space="preserve">
          <source>One greater than the minimum possible normal power of 2 exponent. Use &lt;a href=&quot;../primitive.f32#associatedconstant.MIN_EXP&quot;&gt;&lt;code&gt;f32::MIN_EXP&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="af913244c1df707f9c82d8aebefb4735e4abcae8" translate="yes" xml:space="preserve">
          <source>One greater than the minimum possible normal power of 2 exponent. Use &lt;a href=&quot;../primitive.f64#associatedconstant.MIN_EXP&quot;&gt;&lt;code&gt;f64::MIN_EXP&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d6888a831481b2df0737ae6067a1763cc0ae4b8b" translate="yes" xml:space="preserve">
          <source>One important part of this code is that the &lt;code&gt;Messenger&lt;/code&gt; trait has one method called &lt;code&gt;send&lt;/code&gt; that takes an immutable reference to &lt;code&gt;self&lt;/code&gt; and the text of the message. This is the interface our mock object needs to have. The other important part is that we want to test the behavior of the &lt;code&gt;set_value&lt;/code&gt; method on the &lt;code&gt;LimitTracker&lt;/code&gt;. We can change what we pass in for the &lt;code&gt;value&lt;/code&gt; parameter, but &lt;code&gt;set_value&lt;/code&gt; doesn&amp;rsquo;t return anything for us to make assertions on. We want to be able to say that if we create a &lt;code&gt;LimitTracker&lt;/code&gt; with something that implements the &lt;code&gt;Messenger&lt;/code&gt; trait and a particular value for &lt;code&gt;max&lt;/code&gt;, when we pass different numbers for &lt;code&gt;value&lt;/code&gt;, the messenger is told to send the appropriate messages.</source>
          <target state="translated">Одной из важных частей этого кода является то, что у черты &lt;code&gt;Messenger&lt;/code&gt; есть один метод, называемый &lt;code&gt;send&lt;/code&gt; , который принимает неизменяемую ссылку на &lt;code&gt;self&lt;/code&gt; и текст сообщения. Это интерфейс, который должен иметь наш фиктивный объект. Другой важной частью является то , что мы хотим , чтобы проверить поведение &lt;code&gt;set_value&lt;/code&gt; метода на &lt;code&gt;LimitTracker&lt;/code&gt; . Мы можем изменить то, что мы передаем в качестве параметра &lt;code&gt;value&lt;/code&gt; , но &lt;code&gt;set_value&lt;/code&gt; не возвращает нам ничего, на что мы могли бы делать утверждения. Мы хотим иметь возможность сказать, что если мы создадим &lt;code&gt;LimitTracker&lt;/code&gt; с чем-то, что реализует черту &lt;code&gt;Messenger&lt;/code&gt; и определенное значение для &lt;code&gt;max&lt;/code&gt; , когда мы передаем разные числа в качестве &lt;code&gt;value&lt;/code&gt; , мессенджеру предлагается отправить соответствующие сообщения.</target>
        </trans-unit>
        <trans-unit id="ded7cc38097138108681f22bf5306daeb4f49884" translate="yes" xml:space="preserve">
          <source>One increasingly popular approach to ensuring safe concurrency is &lt;em&gt;message passing&lt;/em&gt;, where threads or actors communicate by sending each other messages containing data. Here&amp;rsquo;s the idea in a slogan from &lt;a href=&quot;http://golang.org/doc/effective_go.html&quot;&gt;the Go language documentation&lt;/a&gt;: &amp;ldquo;Do not communicate by sharing memory; instead, share memory by communicating.&amp;rdquo;</source>
          <target state="translated">Одним из набирающих популярность подходов к обеспечению безопасного параллелизма является &lt;em&gt;передача сообщений&lt;/em&gt; , при которой потоки или субъекты взаимодействуют, отправляя друг другу сообщения, содержащие данные. Вот идея слогана из &lt;a href=&quot;http://golang.org/doc/effective_go.html&quot;&gt;документации по языку Go&lt;/a&gt; : &amp;laquo;Не общайтесь, разделяя память; вместо этого делитесь воспоминаниями, общаясь &amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="d3eaa18d42b0806c5f4bdf2e764c2ce7e402d5e8" translate="yes" xml:space="preserve">
          <source>One increasingly popular approach to ensuring safe concurrency is &lt;em&gt;message passing&lt;/em&gt;, where threads or actors communicate by sending each other messages containing data. Here&amp;rsquo;s the idea in a slogan from &lt;a href=&quot;https://golang.org/doc/effective_go.html#concurrency&quot;&gt;the Go language documentation&lt;/a&gt;: &amp;ldquo;Do not communicate by sharing memory; instead, share memory by communicating.&amp;rdquo;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d6b559b40224203447024d2ae45e68a9e1945eed" translate="yes" xml:space="preserve">
          <source>One last example:</source>
          <target state="translated">Последний пример:</target>
        </trans-unit>
        <trans-unit id="1ad534544463088b932bc112e0ba96d50acc9887" translate="yes" xml:space="preserve">
          <source>One lifetime annotation by itself doesn&amp;rsquo;t have much meaning, because the annotations are meant to tell Rust how generic lifetime parameters of multiple references relate to each other. For example, let&amp;rsquo;s say we have a function with the parameter &lt;code&gt;first&lt;/code&gt; that is a reference to an &lt;code&gt;i32&lt;/code&gt; with lifetime &lt;code&gt;'a&lt;/code&gt;. The function also has another parameter named &lt;code&gt;second&lt;/code&gt; that is another reference to an &lt;code&gt;i32&lt;/code&gt; that also has the lifetime &lt;code&gt;'a&lt;/code&gt;. The lifetime annotations indicate that the references &lt;code&gt;first&lt;/code&gt; and &lt;code&gt;second&lt;/code&gt; must both live as long as that generic lifetime.</source>
          <target state="translated">Одна аннотация времени жизни сама по себе не имеет особого значения, потому что аннотации предназначены для того, чтобы сообщить Rust, как общие параметры времени жизни нескольких ссылок связаны друг с другом. Например, предположим, что у нас есть функция с параметром &lt;code&gt;first&lt;/code&gt; который является ссылкой на &lt;code&gt;i32&lt;/code&gt; со временем жизни &lt;code&gt;'a&lt;/code&gt; . У функции также есть еще один параметр с именем &lt;code&gt;second&lt;/code&gt; , который является еще одной ссылкой на &lt;code&gt;i32&lt;/code&gt; , который также имеет время жизни &lt;code&gt;'a&lt;/code&gt; . Аннотации времени жизни указывают, что ссылки &lt;code&gt;first&lt;/code&gt; и &lt;code&gt;second&lt;/code&gt; должны существовать столько же, сколько и это общее время жизни.</target>
        </trans-unit>
        <trans-unit id="eb999aea4a6804c2aba22f0ab64c0d473a5cc357" translate="yes" xml:space="preserve">
          <source>One major tool Rust has for accomplishing message-sending concurrency is the &lt;em&gt;channel&lt;/em&gt;, a programming concept that Rust&amp;rsquo;s standard library provides an implementation of. You can imagine a channel in programming as being like a channel of water, such as a stream or a river. If you put something like a rubber duck or boat into a stream, it will travel downstream to the end of the waterway.</source>
          <target state="translated">Одним из основных инструментов Rust для обеспечения параллельной отправки сообщений является &lt;em&gt;канал&lt;/em&gt; , концепция программирования, реализацию которой предоставляет стандартная библиотека Rust. Вы можете представить канал в программировании как канал с водой, такой как ручей или река. Если вы поместите в ручей что-то вроде резиновой утки или лодку, она поплывет вниз по течению до конца водного пути.</target>
        </trans-unit>
        <trans-unit id="5a21bfbca68fd0fbb69da3809cb39488fd50f372" translate="yes" xml:space="preserve">
          <source>One maybe obvious note when using append-mode: make sure that all data that belongs together is written to the file in one operation. This can be done by concatenating strings before passing them to &lt;a href=&quot;../io/trait.write#tymethod.write&quot;&gt;&lt;code&gt;write()&lt;/code&gt;&lt;/a&gt;, or using a buffered writer (with a buffer of adequate size), and calling &lt;a href=&quot;../io/trait.write#tymethod.flush&quot;&gt;&lt;code&gt;flush()&lt;/code&gt;&lt;/a&gt; when the message is complete.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a100de9eac9101d503c874b2c73fc8e99b7771dc" translate="yes" xml:space="preserve">
          <source>One maybe obvious note when using append-mode: make sure that all data that belongs together is written to the file in one operation. This can be done by concatenating strings before passing them to &lt;a href=&quot;struct.file#method.write&quot;&gt;&lt;code&gt;write()&lt;/code&gt;&lt;/a&gt;, or using a buffered writer (with a buffer of adequate size), and calling &lt;a href=&quot;struct.file#method.flush&quot;&gt;&lt;code&gt;flush()&lt;/code&gt;&lt;/a&gt; when the message is complete.</source>
          <target state="translated">Одно очевидное замечание при использовании режима добавления: убедитесь, что все данные, которые принадлежат друг другу, записываются в файл за одну операцию. Это может быть выполнено путем объединения строк перед их передачей в &lt;a href=&quot;struct.file#method.write&quot;&gt; &lt;code&gt;write()&lt;/code&gt; &lt;/a&gt; или использования буферизованного модуля записи (с буфером соответствующего размера) и вызова &lt;a href=&quot;struct.file#method.flush&quot;&gt; &lt;code&gt;flush()&lt;/code&gt; &lt;/a&gt; после завершения сообщения.</target>
        </trans-unit>
        <trans-unit id="2650888f948816ac8a9838e1462a292b91d57e17" translate="yes" xml:space="preserve">
          <source>One of the keys to &lt;code&gt;collect()&lt;/code&gt;'s power is that many things you might not think of as 'collections' actually are. For example, a &lt;a href=&quot;../string/struct.string&quot;&gt;&lt;code&gt;String&lt;/code&gt;&lt;/a&gt; is a collection of &lt;a href=&quot;../primitive.char&quot;&gt;&lt;code&gt;char&lt;/code&gt;&lt;/a&gt;s. And a collection of &lt;a href=&quot;../result/enum.result&quot;&gt;&lt;code&gt;Result&amp;lt;T, E&amp;gt;&lt;/code&gt;&lt;/a&gt; can be thought of as single &lt;a href=&quot;../result/enum.result&quot;&gt;&lt;code&gt;Result&lt;/code&gt;&lt;/a&gt;&lt;code&gt;&amp;lt;Collection&amp;lt;T&amp;gt;, E&amp;gt;&lt;/code&gt;. See the examples below for more.</source>
          <target state="translated">Один из ключей к силе метода &lt;code&gt;collect()&lt;/code&gt; заключается в том, что многие вещи, которые вы, возможно, не воспринимали как &amp;laquo;коллекции&amp;raquo;, на самом деле являются. Например, &lt;a href=&quot;../string/struct.string&quot;&gt; &lt;code&gt;String&lt;/code&gt; &lt;/a&gt; - это набор &lt;a href=&quot;../primitive.char&quot;&gt; &lt;code&gt;char&lt;/code&gt; &lt;/a&gt; . А коллекцию &lt;a href=&quot;../result/enum.result&quot;&gt; &lt;code&gt;Result&amp;lt;T, E&amp;gt;&lt;/code&gt; &lt;/a&gt; можно рассматривать как один &lt;a href=&quot;../result/enum.result&quot;&gt; &lt;code&gt;Result&lt;/code&gt; &lt;/a&gt; &lt;code&gt;&amp;lt;Collection&amp;lt;T&amp;gt;, E&amp;gt;&lt;/code&gt; . См. Примеры ниже.</target>
        </trans-unit>
        <trans-unit id="c25ed3c3dc3acc46e3e6ecc55a7e68acca10b918" translate="yes" xml:space="preserve">
          <source>One of the uses of a &lt;code&gt;loop&lt;/code&gt; is to retry an operation you know might fail, such as checking whether a thread has completed its job. However, you might need to pass the result of that operation to the rest of your code. To do this, you can add the value you want returned after the &lt;code&gt;break&lt;/code&gt; expression you use to stop the loop; that value will be returned out of the loop so you can use it, as shown here:</source>
          <target state="translated">Одно из применений &lt;code&gt;loop&lt;/code&gt; - повторить операцию, которая, как вы знаете, может потерпеть неудачу, например, проверка того, завершил ли поток свое задание. Однако вам может потребоваться передать результат этой операции остальной части вашего кода. Для этого вы можете добавить значение, которое вы хотите вернуть, после выражения &lt;code&gt;break&lt;/code&gt; ,которое вы используете для остановки цикла; это значение будет возвращено из цикла, чтобы вы могли его использовать, как показано здесь:</target>
        </trans-unit>
        <trans-unit id="f31603daf9af84bcc62de6d02f7c02e0a197c236" translate="yes" xml:space="preserve">
          <source>One requirement for &lt;code&gt;match&lt;/code&gt; expressions is that they need to be &lt;em&gt;exhaustive&lt;/em&gt; in the sense that all possibilities for the value in the &lt;code&gt;match&lt;/code&gt; expression must be accounted for. One way to ensure you&amp;rsquo;ve covered every possibility is to have a catchall pattern for the last arm: for example, a variable name matching any value can never fail and thus covers every remaining case.</source>
          <target state="translated">Одно из требований для &lt;code&gt;match&lt;/code&gt; выражений является то , что они должны быть &lt;em&gt;исчерпывающими&lt;/em&gt; в том смысле , что все возможности для значения в &lt;code&gt;match&lt;/code&gt; выражении должны быть учтены. Один из способов убедиться, что вы охватили все возможности, - это иметь общий шаблон для последнего плеча: например, имя переменной, соответствующее любому значению, никогда не может дать сбой и, таким образом, охватывает все оставшиеся случаи.</target>
        </trans-unit>
        <trans-unit id="2015b7ca5d5d193e7b2cd1b845883b1560077b31" translate="yes" xml:space="preserve">
          <source>One restriction to note with trait implementations is that we can implement a trait on a type only if either the trait or the type is local to our crate. For example, we can implement standard library traits like &lt;code&gt;Display&lt;/code&gt; on a custom type like &lt;code&gt;Tweet&lt;/code&gt; as part of our &lt;code&gt;aggregator&lt;/code&gt; crate functionality, because the type &lt;code&gt;Tweet&lt;/code&gt; is local to our &lt;code&gt;aggregator&lt;/code&gt; crate. We can also implement &lt;code&gt;Summary&lt;/code&gt; on &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; in our &lt;code&gt;aggregator&lt;/code&gt; crate, because the trait &lt;code&gt;Summary&lt;/code&gt; is local to our &lt;code&gt;aggregator&lt;/code&gt; crate.</source>
          <target state="translated">Одно ограничение, которое следует отметить при реализации трейтов, заключается в том, что мы можем реализовать трейт для типа, только если трейт или тип являются локальными для нашего ящика. Например, мы можем реализовать стандартные библиотечные свойства, такие как &lt;code&gt;Display&lt;/code&gt; , в настраиваемом типе, таком как &lt;code&gt;Tweet&lt;/code&gt; , как часть функциональности нашего ящика &lt;code&gt;aggregator&lt;/code&gt; , поскольку тип &lt;code&gt;Tweet&lt;/code&gt; является локальным для нашего ящика &lt;code&gt;aggregator&lt;/code&gt; . Мы также можем реализовать &lt;code&gt;Summary&lt;/code&gt; на &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; в нашем ящике &lt;code&gt;aggregator&lt;/code&gt; , потому что свойство &lt;code&gt;Summary&lt;/code&gt; является локальным для нашего ящика &lt;code&gt;aggregator&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3ca14e0e855a4d320ac718d1dbab1d5658779f12" translate="yes" xml:space="preserve">
          <source>One should always prefer implementing &lt;code&gt;From&lt;/code&gt; over &lt;a href=&quot;trait.into&quot;&gt;&lt;code&gt;Into&lt;/code&gt;&lt;/a&gt; because implementing &lt;code&gt;From&lt;/code&gt; automatically provides one with a implementation of &lt;a href=&quot;trait.into&quot;&gt;&lt;code&gt;Into&lt;/code&gt;&lt;/a&gt; thanks to the blanket implementation in the standard library.</source>
          <target state="translated">Всегда следует предпочесть реализацию &lt;code&gt;From&lt;/code&gt; через &lt;a href=&quot;trait.into&quot;&gt; &lt;code&gt;Into&lt;/code&gt; ,&lt;/a&gt; потому что реализация &lt;code&gt;From&lt;/code&gt; автоматически обеспечивает реализацию &lt;a href=&quot;trait.into&quot;&gt; &lt;code&gt;Into&lt;/code&gt; &lt;/a&gt; благодаря общей реализации в стандартной библиотеке.</target>
        </trans-unit>
        <trans-unit id="721950a5dec28e319b3fc49a8295aa63db96bacc" translate="yes" xml:space="preserve">
          <source>One should always prefer implementing &lt;code&gt;From&lt;/code&gt; over &lt;a href=&quot;trait.into&quot;&gt;&lt;code&gt;Into&lt;/code&gt;&lt;/a&gt; because implementing &lt;code&gt;From&lt;/code&gt; automatically provides one with an implementation of &lt;a href=&quot;trait.into&quot;&gt;&lt;code&gt;Into&lt;/code&gt;&lt;/a&gt; thanks to the blanket implementation in the standard library.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bb98649134293913fe4a45ee10ddf0211b082fad" translate="yes" xml:space="preserve">
          <source>One should avoid implementing &lt;a href=&quot;trait.into&quot;&gt;&lt;code&gt;Into&lt;/code&gt;&lt;/a&gt; and implement &lt;a href=&quot;trait.from&quot;&gt;&lt;code&gt;From&lt;/code&gt;&lt;/a&gt; instead. Implementing &lt;a href=&quot;trait.from&quot;&gt;&lt;code&gt;From&lt;/code&gt;&lt;/a&gt; automatically provides one with an implementation of &lt;a href=&quot;trait.into&quot;&gt;&lt;code&gt;Into&lt;/code&gt;&lt;/a&gt; thanks to the blanket implementation in the standard library.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b9063035453c1b2c42529a52a82eaf086598016e" translate="yes" xml:space="preserve">
          <source>One should only implement &lt;a href=&quot;trait.into&quot;&gt;&lt;code&gt;Into&lt;/code&gt;&lt;/a&gt; if a conversion to a type outside the current crate is required. Otherwise one should always prefer implementing &lt;a href=&quot;trait.from&quot;&gt;&lt;code&gt;From&lt;/code&gt;&lt;/a&gt; over &lt;a href=&quot;trait.into&quot;&gt;&lt;code&gt;Into&lt;/code&gt;&lt;/a&gt; because implementing &lt;a href=&quot;trait.from&quot;&gt;&lt;code&gt;From&lt;/code&gt;&lt;/a&gt; automatically provides one with a implementation of &lt;a href=&quot;trait.into&quot;&gt;&lt;code&gt;Into&lt;/code&gt;&lt;/a&gt; thanks to the blanket implementation in the standard library. &lt;a href=&quot;trait.from&quot;&gt;&lt;code&gt;From&lt;/code&gt;&lt;/a&gt; cannot do these type of conversions because of Rust's orphaning rules.</source>
          <target state="translated">Следует реализовывать &lt;a href=&quot;trait.into&quot;&gt; &lt;code&gt;Into&lt;/code&gt; &lt;/a&gt; только в том случае, если требуется преобразование в тип вне текущего ящика. В противном случае всегда следует предпочесть реализацию &lt;a href=&quot;trait.from&quot;&gt; &lt;code&gt;From&lt;/code&gt; &lt;/a&gt; через &lt;a href=&quot;trait.into&quot;&gt; &lt;code&gt;Into&lt;/code&gt; ,&lt;/a&gt; потому что реализация &lt;a href=&quot;trait.from&quot;&gt; &lt;code&gt;From&lt;/code&gt; &lt;/a&gt; автоматически обеспечивает реализацию &lt;a href=&quot;trait.into&quot;&gt; &lt;code&gt;Into&lt;/code&gt; &lt;/a&gt; благодаря полной реализации в стандартной библиотеке. &lt;a href=&quot;trait.from&quot;&gt; &lt;code&gt;From&lt;/code&gt; &lt;/a&gt; не может выполнять такие преобразования из-за правил сиротства в Rust.</target>
        </trans-unit>
        <trans-unit id="1a1308a26b40990e2a9ab226282be34a9c0f3915" translate="yes" xml:space="preserve">
          <source>One special lifetime we need to discuss is &lt;code&gt;'static&lt;/code&gt;, which means that this reference &lt;em&gt;can&lt;/em&gt; live for the entire duration of the program. All string literals have the &lt;code&gt;'static&lt;/code&gt; lifetime, which we can annotate as follows:</source>
          <target state="translated">Одно особое время жизни, которое нам нужно обсудить, - &lt;code&gt;'static&lt;/code&gt; , что означает, что эта ссылка &lt;em&gt;может&lt;/em&gt; существовать в течение всего времени программы. Все строковые литералы имеют &lt;code&gt;'static&lt;/code&gt; время жизни, которое мы можем аннотировать следующим образом:</target>
        </trans-unit>
        <trans-unit id="b3c0e81ae8d50e16a5ef5685ec5ba7252876cd13" translate="yes" xml:space="preserve">
          <source>One way to do this would be to parse the guess as an &lt;code&gt;i32&lt;/code&gt; instead of only a &lt;code&gt;u32&lt;/code&gt; to allow potentially negative numbers, and then add a check for the number being in range, like so:</source>
          <target state="translated">Один из способов сделать это - проанализировать предположение как &lt;code&gt;i32&lt;/code&gt; , а не только &lt;code&gt;u32&lt;/code&gt; , чтобы разрешить потенциально отрицательные числа, а затем добавить проверку числа, находящегося в диапазоне, например:</target>
        </trans-unit>
        <trans-unit id="040e8b6c5e16e2eb7dbd8ea369897b2ed67939bb" translate="yes" xml:space="preserve">
          <source>One way to fix this is by wrapping &lt;code&gt;ListNode&lt;/code&gt; in a &lt;code&gt;Box&lt;/code&gt;, like so:</source>
          <target state="translated">Один из способов исправить это - обернуть &lt;code&gt;ListNode&lt;/code&gt; в &lt;code&gt;Box&lt;/code&gt; , например:</target>
        </trans-unit>
        <trans-unit id="7b55ce1dd92a000535e70271090068fe574bb882" translate="yes" xml:space="preserve">
          <source>One way to fix this is to remove the items in negative impls:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e58c5baae639d4247baa5d3c55a2e51c5fc2fcbf" translate="yes" xml:space="preserve">
          <source>One way to use &lt;code&gt;AssertUnwindSafe&lt;/code&gt; is to assert that the entire closure itself is unwind safe, bypassing all checks for all variables:</source>
          <target state="translated">Один из способов использования &lt;code&gt;AssertUnwindSafe&lt;/code&gt; - утверждать, что само закрытие является безопасным для раскрутки, минуя все проверки для всех переменных:</target>
        </trans-unit>
        <trans-unit id="1d8228fcb1896e7f726b443ff97084ceedc8b0d1" translate="yes" xml:space="preserve">
          <source>One way to work around this is to introduce a phantom type parameter into &lt;code&gt;FooMaker&lt;/code&gt;, like so:</source>
          <target state="translated">Один из способов обойти это - ввести параметр фантомного типа в &lt;code&gt;FooMaker&lt;/code&gt; , например:</target>
        </trans-unit>
        <trans-unit id="5b0ab36b863c12847512c68879148e05a2480f26" translate="yes" xml:space="preserve">
          <source>Only &lt;a href=&quot;hash_map/struct.hashmap&quot;&gt;&lt;code&gt;HashMap&lt;/code&gt;&lt;/a&gt; has expected costs, due to the probabilistic nature of hashing. It is theoretically possible, though very unlikely, for &lt;a href=&quot;hash_map/struct.hashmap&quot;&gt;&lt;code&gt;HashMap&lt;/code&gt;&lt;/a&gt; to experience worse performance.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5d2a1cfc42a9afc1fe710bb8389ace0259e088eb" translate="yes" xml:space="preserve">
          <source>Only &lt;a href=&quot;struct.hashmap&quot;&gt;&lt;code&gt;HashMap&lt;/code&gt;&lt;/a&gt; has expected costs, due to the probabilistic nature of hashing. It is theoretically possible, though very unlikely, for &lt;a href=&quot;struct.hashmap&quot;&gt;&lt;code&gt;HashMap&lt;/code&gt;&lt;/a&gt; to experience worse performance.</source>
          <target state="translated">Только &lt;a href=&quot;struct.hashmap&quot;&gt; &lt;code&gt;HashMap&lt;/code&gt; &lt;/a&gt; имеет ожидаемые затраты из-за вероятностного характера хеширования. Теоретически возможно, хотя и очень маловероятно, что производительность &lt;a href=&quot;struct.hashmap&quot;&gt; &lt;code&gt;HashMap&lt;/code&gt; &lt;/a&gt; будет хуже.</target>
        </trans-unit>
        <trans-unit id="c64700ee184977494a32292609d647c2790da91d" translate="yes" xml:space="preserve">
          <source>Only &lt;code&gt;extern crate&lt;/code&gt; imports at the crate root level are allowed to import macros.</source>
          <target state="translated">Только &lt;code&gt;extern crate&lt;/code&gt; импорт ящика на корневом уровне ящика может импортировать макросы.</target>
        </trans-unit>
        <trans-unit id="0f1a591311049947010f4fb443dacb5d1227b8a1" translate="yes" xml:space="preserve">
          <source>Only Inserting a Value If the Key Has No Value</source>
          <target state="translated">Вставка значения выполняется только в том случае,если ключ не имеет значения.</target>
        </trans-unit>
        <trans-unit id="a86a2e98e34b9080a837979f0cd7c8a23bdc05cc" translate="yes" xml:space="preserve">
          <source>Only a higher-ranked bound can be used here as the lifetime of the reference is shorter than a lifetime parameter on the function:</source>
          <target state="translated">Здесь может быть использована только привязка с более высоким рейтингом,так как время жизни ссылки меньше,чем время жизни параметра функции:</target>
        </trans-unit>
        <trans-unit id="154f9dfbda3c7139a94a5be92a5a5842ea10cd7e" translate="yes" xml:space="preserve">
          <source>Only a single explicit lifetime bound is permitted on trait objects. To fix this error, consider removing one of the lifetime bounds:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1d9857467e96b586319b486e37d19a227573b8ef" translate="yes" xml:space="preserve">
          <source>Only considers whole path components to match.</source>
          <target state="translated">Считает только,что все компоненты пути совпадают.</target>
        </trans-unit>
        <trans-unit id="79d045850f7f84e6ac5788c792fcb946090d94ed" translate="yes" xml:space="preserve">
          <source>Only field-less enums can be cast to numerical primitives, so this attribute will not apply to structs.</source>
          <target state="translated">К числовым примитивам могут быть приведены только беспольные перечисления,поэтому данный атрибут не будет применяться к структурам.</target>
        </trans-unit>
        <trans-unit id="848279e3313c44734789a01608c8102412c68498" translate="yes" xml:space="preserve">
          <source>Only foreign functions can use the C-variadic type (&lt;code&gt;...&lt;/code&gt;). In such functions, &lt;code&gt;...&lt;/code&gt; may only occur non-nested. That is, &lt;code&gt;y: &amp;amp;'a ...&lt;/code&gt; is not allowed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="905a2eaaaa2de81962debc1768f8a3e80eac42bb" translate="yes" xml:space="preserve">
          <source>Only functions and methods can be called using &lt;code&gt;()&lt;/code&gt;. Example:</source>
          <target state="translated">С помощью &lt;code&gt;()&lt;/code&gt; можно вызывать только функции и методы . Пример:</target>
        </trans-unit>
        <trans-unit id="75a9ac98deeca6b24da630baa2c701b9504057f7" translate="yes" xml:space="preserve">
          <source>Only implement &lt;a href=&quot;trait.into&quot;&gt;&lt;code&gt;Into&lt;/code&gt;&lt;/a&gt; if a conversion to a type outside the current crate is required. &lt;code&gt;From&lt;/code&gt; cannot do these type of conversions because of Rust's orphaning rules. See &lt;a href=&quot;trait.into&quot;&gt;&lt;code&gt;Into&lt;/code&gt;&lt;/a&gt; for more details.</source>
          <target state="translated">Реализуйте &lt;a href=&quot;trait.into&quot;&gt; &lt;code&gt;Into&lt;/code&gt; &lt;/a&gt; только в том случае, если требуется преобразование в тип вне текущего ящика. &lt;code&gt;From&lt;/code&gt; не может выполнять такие преобразования из-за правил сиротства в Rust. См. Подробности в &lt;a href=&quot;trait.into&quot;&gt; &lt;code&gt;Into&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="9b305a83e8f3d0e4a37b5c57b23584e5d9862317" translate="yes" xml:space="preserve">
          <source>Only implement &lt;a href=&quot;trait.into&quot;&gt;&lt;code&gt;Into&lt;/code&gt;&lt;/a&gt; when targeting a version prior to Rust 1.41 and converting to a type outside the current crate. &lt;code&gt;From&lt;/code&gt; was not able to do these types of conversions in earlier versions because of Rust's orphaning rules. See &lt;a href=&quot;trait.into&quot;&gt;&lt;code&gt;Into&lt;/code&gt;&lt;/a&gt; for more details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="32f9fc3a3cbf2058b25d70080083b8cc212e6656" translate="yes" xml:space="preserve">
          <source>Only one argument can be passed per use. So instead of:</source>
          <target state="translated">На каждое использование может быть передан только один аргумент.Так что вместо этого:</target>
        </trans-unit>
        <trans-unit id="457e98acf3983b9b27751cc789092296edcc762f" translate="yes" xml:space="preserve">
          <source>Only one thread will have &lt;code&gt;true&lt;/code&gt; returned from their result, all other threads will have &lt;code&gt;false&lt;/code&gt; returned.</source>
          <target state="translated">Только один поток вернет &lt;code&gt;true&lt;/code&gt; из своего результата, все остальные потоки вернут &lt;code&gt;false&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="bc230d3e221cc5ba4ebb17173e6ee922e206f00e" translate="yes" xml:space="preserve">
          <source>Only paths to traits are allowed as argument inside &lt;code&gt;#[derive]&lt;/code&gt;. You can find more information about the &lt;code&gt;#[derive]&lt;/code&gt; attribute in the &lt;a href=&quot;book/appendix-03-derivable-traits&quot;&gt;Rust Book&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e3609d3dffa4fe7169c12045193a601a2a125a6f" translate="yes" xml:space="preserve">
          <source>Only primitive types can be cast into each other. Examples:</source>
          <target state="translated">Только примитивные типы могут быть вложены друг в друга.Примеры:</target>
        </trans-unit>
        <trans-unit id="ab9f48b23a6a48f0ef7b5f4e6bfbc32e252bb8f0" translate="yes" xml:space="preserve">
          <source>Only published blog posts return content to print, so unapproved posts can&amp;rsquo;t accidentally be published.</source>
          <target state="translated">Только опубликованные сообщения блога возвращают контент в печать, поэтому неутвержденные сообщения не могут быть случайно опубликованы.</target>
        </trans-unit>
        <trans-unit id="073ebf55d3884fb61165383e76a504c9d12cc4b5" translate="yes" xml:space="preserve">
          <source>Only structs and enums are permitted to impl Send, Sync, and other opt-out trait, and the struct or enum must be local to the current crate. So, for example, &lt;code&gt;unsafe impl Send for Rc&amp;lt;Foo&amp;gt;&lt;/code&gt; is not allowed.</source>
          <target state="translated">Только структуры и перечисления могут использовать Send, Sync и другие свойства отказа, а структура или перечисление должны быть локальными по отношению к текущему ящику. Так, например, &lt;code&gt;unsafe impl Send for Rc&amp;lt;Foo&amp;gt;&lt;/code&gt; не допускается.</target>
        </trans-unit>
        <trans-unit id="48b01a920bc2fb585e3535476a3e6dbbaef350e6" translate="yes" xml:space="preserve">
          <source>Only structural-match types (that is, types that derive &lt;code&gt;PartialEq&lt;/code&gt; and &lt;code&gt;Eq&lt;/code&gt;) may be used as the types of const generic parameters.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="51b0c3f2b71fcd0ea3442b5d718eb8c566a2296f" translate="yes" xml:space="preserve">
          <source>Only the appearance of &lt;em&gt;uncovered&lt;/em&gt; type parameters is restricted. Note that for the purposes of coherence, &lt;a href=&quot;../glossary#fundamental-type-constructors&quot;&gt;fundamental types&lt;/a&gt; are special. The &lt;code&gt;T&lt;/code&gt; in &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; is not considered covered, and &lt;code&gt;Box&amp;lt;LocalType&amp;gt;&lt;/code&gt; is considered local.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="62a5a90afa5fbb53aff61b9a8c2fc3d66d83b35e" translate="yes" xml:space="preserve">
          <source>Only the last field of &lt;code&gt;Foo&lt;/code&gt; has a type involving &lt;code&gt;T&lt;/code&gt;</source>
          <target state="translated">Только последнее поле &lt;code&gt;Foo&lt;/code&gt; имеет тип, включающий &lt;code&gt;T&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="aa278176dd71a6e098f1078a99115e300d8910ce" translate="yes" xml:space="preserve">
          <source>Only the test with the name &lt;code&gt;one_hundred&lt;/code&gt; ran; the other two tests didn&amp;rsquo;t match that name. The test output lets us know we had more tests than what this command ran by displaying &lt;code&gt;2 filtered out&lt;/code&gt; at the end of the summary line.</source>
          <target state="translated">&lt;code&gt;one_hundred&lt;/code&gt; только тест с названием one_hundred ; два других теста не соответствовали этому названию. Выходные данные теста позволяют нам узнать, что у нас было больше тестов, чем было выполнено этой командой, путем отображения &lt;code&gt;2 filtered out&lt;/code&gt; в конце итоговой строки.</target>
        </trans-unit>
        <trans-unit id="d609ff949d70f19612dfe2483b65eb476e7f69db" translate="yes" xml:space="preserve">
          <source>Only traits defined in the current crate can be implemented for arbitrary types.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="faa9f253f7801e4d949e62ca0dcb20642b072d46" translate="yes" xml:space="preserve">
          <source>Only types implementing &lt;code&gt;std::ops::Deref&lt;/code&gt; can be dereferenced (such as &lt;code&gt;&amp;amp;T&lt;/code&gt;). Example:</source>
          <target state="translated">&lt;code&gt;std::ops::Deref&lt;/code&gt; можно только типы, реализующие std :: ops :: Deref (например, &lt;code&gt;&amp;amp;T&lt;/code&gt; ). Пример:</target>
        </trans-unit>
        <trans-unit id="5b7cee0492b998101b493b89f7410ea880e0f8c8" translate="yes" xml:space="preserve">
          <source>Only use the item in the scope it has been defined:</source>
          <target state="translated">Используйте только тот элемент,который определен в области применения:</target>
        </trans-unit>
        <trans-unit id="737047a48ebff11c2ae87259e8e12b5a0ea9f000" translate="yes" xml:space="preserve">
          <source>Opaque type representing the discriminant of an enum.</source>
          <target state="translated">Непрозрачный тип,представляющий собой дискриминант переписи.</target>
        </trans-unit>
        <trans-unit id="3ba5a04eec7ab34d16390d75e26fc3fe98620cc4" translate="yes" xml:space="preserve">
          <source>Open &lt;em&gt;Cargo.toml&lt;/em&gt; in your text editor of choice. It should look similar to the code in Listing 1-2.</source>
          <target state="translated">Откройте &lt;em&gt;Cargo.toml&lt;/em&gt; в &lt;em&gt;любом&lt;/em&gt; текстовом редакторе. Он должен быть похож на код в листинге 1-2.</target>
        </trans-unit>
        <trans-unit id="0b3dfe100cddab4329734c9e3ee2eed64968e7db" translate="yes" xml:space="preserve">
          <source>Open Source Developers</source>
          <target state="translated">Разработчики с открытым исходным кодом</target>
        </trans-unit>
        <trans-unit id="9e593a95e08dd5f0164cac54edffcaa5d02e5a5e" translate="yes" xml:space="preserve">
          <source>Open a TCP connection to &lt;code&gt;127.0.0.1:8080&lt;/code&gt;. If the connection fails, open a TCP connection to &lt;code&gt;127.0.0.1:8081&lt;/code&gt;:</source>
          <target state="translated">Откройте TCP-соединение с &lt;code&gt;127.0.0.1:8080&lt;/code&gt; . В случае сбоя подключения откройте TCP-подключение к &lt;code&gt;127.0.0.1:8081&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="36758b7ca5d96a8abc3401009a4668433b033b74" translate="yes" xml:space="preserve">
          <source>Open a TCP connection to &lt;code&gt;127.0.0.1:8080&lt;/code&gt;:</source>
          <target state="translated">Откройте TCP-соединение с &lt;code&gt;127.0.0.1:8080&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="7e13d18d4e6433983fbb1efa54b9983d326c5ae6" translate="yes" xml:space="preserve">
          <source>Open a terminal and enter the following commands to make a &lt;em&gt;projects&lt;/em&gt; directory and a directory for the &amp;ldquo;Hello, world!&amp;rdquo; project within the &lt;em&gt;projects&lt;/em&gt; directory.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="65c15f3ba1726083fcf5e460a4e8e6321cd0586e" translate="yes" xml:space="preserve">
          <source>Open a terminal and enter the following commands to make a &lt;em&gt;projects&lt;/em&gt; directory and a directory for the Hello, world! project within the &lt;em&gt;projects&lt;/em&gt; directory.</source>
          <target state="translated">Откройте терминал и введите следующие команды, чтобы создать каталог &lt;em&gt;проектов&lt;/em&gt; и каталог для Hello, world! проект в каталоге &lt;em&gt;проектов&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="b4eb537f2a91bae055600573be45de77a27b9ed7" translate="yes" xml:space="preserve">
          <source>Open locally installed documentation</source>
          <target state="translated">Открытая локально установленная документация</target>
        </trans-unit>
        <trans-unit id="84587cdad70cebf6217908dcf7d0133574192d78" translate="yes" xml:space="preserve">
          <source>Open your I/O project&amp;rsquo;s &lt;em&gt;src/main.rs&lt;/em&gt; file, which should look like this:</source>
          <target state="translated">Откройте файл &lt;em&gt;src / main.rs&lt;/em&gt; вашего проекта ввода-вывода , который должен выглядеть так:</target>
        </trans-unit>
        <trans-unit id="aa0399eaec8c7efbd5c34bb50abdda7465b3ccba" translate="yes" xml:space="preserve">
          <source>OpenOptions</source>
          <target state="translated">OpenOptions</target>
        </trans-unit>
        <trans-unit id="8de57f288f4a4084e69c7c4b2aa9da0a06b4257d" translate="yes" xml:space="preserve">
          <source>OpenOptions::access_mode</source>
          <target state="translated">OpenOptions::access_mode</target>
        </trans-unit>
        <trans-unit id="b67e2c499284523d04746aeea5c1bfc24b967904" translate="yes" xml:space="preserve">
          <source>OpenOptions::append</source>
          <target state="translated">OpenOptions::append</target>
        </trans-unit>
        <trans-unit id="32e358709483fecc1c34aed91a515c84a061da75" translate="yes" xml:space="preserve">
          <source>OpenOptions::attributes</source>
          <target state="translated">OpenOptions::attributes</target>
        </trans-unit>
        <trans-unit id="e5c7a13c833ad959de5247957e258cf0746e21f9" translate="yes" xml:space="preserve">
          <source>OpenOptions::borrow</source>
          <target state="translated">OpenOptions::borrow</target>
        </trans-unit>
        <trans-unit id="0acab324be26d91ab189d61abdf16dc747c5192c" translate="yes" xml:space="preserve">
          <source>OpenOptions::borrow_mut</source>
          <target state="translated">OpenOptions::borrow_mut</target>
        </trans-unit>
        <trans-unit id="ebf38deb5d5125bd571ab2fbede6b16bab299f15" translate="yes" xml:space="preserve">
          <source>OpenOptions::clone</source>
          <target state="translated">OpenOptions::clone</target>
        </trans-unit>
        <trans-unit id="f31d22dcf8f9c141ab8ed3fbc1d9d368635388e2" translate="yes" xml:space="preserve">
          <source>OpenOptions::clone_from</source>
          <target state="translated">OpenOptions::clone_from</target>
        </trans-unit>
        <trans-unit id="b0b15f6e5b6b2ad70a686d3798f9b969c1be6e56" translate="yes" xml:space="preserve">
          <source>OpenOptions::clone_into</source>
          <target state="translated">OpenOptions::clone_into</target>
        </trans-unit>
        <trans-unit id="2924b17a8e2b9d34f65d2694a37b0e1b92b85fc1" translate="yes" xml:space="preserve">
          <source>OpenOptions::create</source>
          <target state="translated">OpenOptions::create</target>
        </trans-unit>
        <trans-unit id="518de4d4d480c6aa0ee355b7e8b68e44c261345e" translate="yes" xml:space="preserve">
          <source>OpenOptions::create_new</source>
          <target state="translated">OpenOptions::create_new</target>
        </trans-unit>
        <trans-unit id="5af121b8450a8bfc83582fafa544f257437f0c14" translate="yes" xml:space="preserve">
          <source>OpenOptions::custom_flags</source>
          <target state="translated">OpenOptions::custom_flags</target>
        </trans-unit>
        <trans-unit id="676df7a6e2a4b55c69a37308e4d1e8ab3f83cd3a" translate="yes" xml:space="preserve">
          <source>OpenOptions::fmt</source>
          <target state="translated">OpenOptions::fmt</target>
        </trans-unit>
        <trans-unit id="82f3b255624db61ae979a06d980867d5802d4709" translate="yes" xml:space="preserve">
          <source>OpenOptions::from</source>
          <target state="translated">OpenOptions::from</target>
        </trans-unit>
        <trans-unit id="96ad0ddadc43e2419e6227a5777a55351dd9ac83" translate="yes" xml:space="preserve">
          <source>OpenOptions::into</source>
          <target state="translated">OpenOptions::into</target>
        </trans-unit>
        <trans-unit id="8b77c907fad19cddc5960121fab1fa49b4431f22" translate="yes" xml:space="preserve">
          <source>OpenOptions::mode</source>
          <target state="translated">OpenOptions::mode</target>
        </trans-unit>
        <trans-unit id="1285fb69a9cc28fa9fdf3579b2f9690ab52069d7" translate="yes" xml:space="preserve">
          <source>OpenOptions::new</source>
          <target state="translated">OpenOptions::new</target>
        </trans-unit>
        <trans-unit id="aa320b137860771a593f171b8bca56f205bab7e2" translate="yes" xml:space="preserve">
          <source>OpenOptions::open</source>
          <target state="translated">OpenOptions::open</target>
        </trans-unit>
        <trans-unit id="add50a5d5957c658756ea3d2bf5f0dc20542a4ce" translate="yes" xml:space="preserve">
          <source>OpenOptions::read</source>
          <target state="translated">OpenOptions::read</target>
        </trans-unit>
        <trans-unit id="7e91e59a4c689bbc7efae946cf7ef51cecceeefe" translate="yes" xml:space="preserve">
          <source>OpenOptions::security_qos_flags</source>
          <target state="translated">OpenOptions::security_qos_flags</target>
        </trans-unit>
        <trans-unit id="90b2992d4cec48c28058dee872298370548406ec" translate="yes" xml:space="preserve">
          <source>OpenOptions::share_mode</source>
          <target state="translated">OpenOptions::share_mode</target>
        </trans-unit>
        <trans-unit id="48a692736f06da779873a596d6bb2424b9ad7161" translate="yes" xml:space="preserve">
          <source>OpenOptions::to_owned</source>
          <target state="translated">OpenOptions::to_owned</target>
        </trans-unit>
        <trans-unit id="46e980851a36d656e0daadb411e16ffdbbc2e1eb" translate="yes" xml:space="preserve">
          <source>OpenOptions::truncate</source>
          <target state="translated">OpenOptions::truncate</target>
        </trans-unit>
        <trans-unit id="5f197b60663b22df305247c4bfa1a457e5c0d835" translate="yes" xml:space="preserve">
          <source>OpenOptions::try_from</source>
          <target state="translated">OpenOptions::try_from</target>
        </trans-unit>
        <trans-unit id="747eda4c8e3b44e7c01f7e027a9bd03352e1f790" translate="yes" xml:space="preserve">
          <source>OpenOptions::try_into</source>
          <target state="translated">OpenOptions::try_into</target>
        </trans-unit>
        <trans-unit id="5058de688dcc60c90693a5096962f6405ea1f171" translate="yes" xml:space="preserve">
          <source>OpenOptions::type_id</source>
          <target state="translated">OpenOptions::type_id</target>
        </trans-unit>
        <trans-unit id="19a0518d3e6a36eb2eabd3b78700ce36d617b64d" translate="yes" xml:space="preserve">
          <source>OpenOptions::write</source>
          <target state="translated">OpenOptions::write</target>
        </trans-unit>
        <trans-unit id="6dc0ebb4fa3738b9bc9aac0db1fdc06f34fea9fc" translate="yes" xml:space="preserve">
          <source>OpenOptionsExt</source>
          <target state="translated">OpenOptionsExt</target>
        </trans-unit>
        <trans-unit id="45d6a023e7aaf3a8b617725a7efb650cf62cdf6c" translate="yes" xml:space="preserve">
          <source>Opening a file for both reading and writing, as well as creating it if it doesn't exist:</source>
          <target state="translated">Открытие файла как для чтения,так и для записи,а также его создание,если он не существует:</target>
        </trans-unit>
        <trans-unit id="d0521aae78e8ad155838f7de5e8f14d0ef7781f3" translate="yes" xml:space="preserve">
          <source>Opening a file to read:</source>
          <target state="translated">Открытие файла для чтения:</target>
        </trans-unit>
        <trans-unit id="d7d34b4c8e94f4c904313459b9fb9b442177d441" translate="yes" xml:space="preserve">
          <source>Opens a TCP connection to a remote host with a timeout.</source>
          <target state="translated">Открывает TCP-соединение с удаленным хостом с таймаутом.</target>
        </trans-unit>
        <trans-unit id="209d3641e1fce80e2ba36a03cac2a67f569fb4c6" translate="yes" xml:space="preserve">
          <source>Opens a TCP connection to a remote host.</source>
          <target state="translated">Открывает TCP-соединение с удаленным хостом.</target>
        </trans-unit>
        <trans-unit id="48dea963058d766cb37add48852fe3f445feaf08" translate="yes" xml:space="preserve">
          <source>Opens a file at &lt;code&gt;path&lt;/code&gt; with the options specified by &lt;code&gt;self&lt;/code&gt;.</source>
          <target state="translated">Открывает файл по &lt;code&gt;path&lt;/code&gt; с параметрами, указанными в &lt;code&gt;self&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1ebe50b26242826a11bca679d30a026d4444d1a2" translate="yes" xml:space="preserve">
          <source>Opens a file in write-only mode.</source>
          <target state="translated">Открывает файл в режиме только для записи.</target>
        </trans-unit>
        <trans-unit id="127d959111790c197f023d709985c8cb7e583159" translate="yes" xml:space="preserve">
          <source>Operand of the &lt;a href=&quot;expressions/operator-expr#the-dereference-operator&quot;&gt;dereference operator&lt;/a&gt; (&lt;code&gt;*&lt;/code&gt;).</source>
          <target state="translated">Операнд &lt;a href=&quot;expressions/operator-expr#the-dereference-operator&quot;&gt;оператора разыменования&lt;/a&gt; ( &lt;code&gt;*&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="a2b8c4621b34e3c27498c6c8832719e530f09634" translate="yes" xml:space="preserve">
          <source>Operands</source>
          <target state="translated">Operands</target>
        </trans-unit>
        <trans-unit id="3b28f00441a9534ad36bef8779425496277b4521" translate="yes" xml:space="preserve">
          <source>Operands of &lt;a href=&quot;expressions/operator-expr#comparison-operators&quot;&gt;comparison&lt;/a&gt;.</source>
          <target state="translated">Операнды &lt;a href=&quot;expressions/operator-expr#comparison-operators&quot;&gt;сравнения&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="796e9c6aba0ed5f7facb56a161b990345eb7dff2" translate="yes" xml:space="preserve">
          <source>Operations like &lt;code&gt;+&lt;/code&gt; on &lt;code&gt;u32&lt;/code&gt; values are intended to never overflow, and in some debug configurations overflow is detected and results in a panic. While most arithmetic falls into this category, some code explicitly expects and relies upon modular arithmetic (e.g., hashing).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fd7809a925050c789646447f7ccccf00c4e8608c" translate="yes" xml:space="preserve">
          <source>Operations like &lt;code&gt;+&lt;/code&gt; on &lt;code&gt;u32&lt;/code&gt; values is intended to never overflow, and in some debug configurations overflow is detected and results in a panic. While most arithmetic falls into this category, some code explicitly expects and relies upon modular arithmetic (e.g., hashing).</source>
          <target state="translated">Операции , как &lt;code&gt;+&lt;/code&gt; на &lt;code&gt;u32&lt;/code&gt; значениях предназначены для никогда переполнения, а в некоторых отладочных конфигурациях переполнения обнаружено и результатах в панике. Хотя большая часть арифметики попадает в эту категорию, некоторый код явно ожидает и полагается на модульную арифметику (например, хеширование).</target>
        </trans-unit>
        <trans-unit id="732a02d050941e6169a56caaf931604a39dfcf26" translate="yes" xml:space="preserve">
          <source>Operations on ASCII strings and characters.</source>
          <target state="translated">Операции со строками и символами ASCII.</target>
        </trans-unit>
        <trans-unit id="d0e687b079fb70f2208d1f8d2c75d64d74925496" translate="yes" xml:space="preserve">
          <source>Operator</source>
          <target state="translated">Operator</target>
        </trans-unit>
        <trans-unit id="e2cce0c9ff63663c1cea812414bb03fc6e974bec" translate="yes" xml:space="preserve">
          <source>Operator Traits</source>
          <target state="translated">Трейты оператора</target>
        </trans-unit>
        <trans-unit id="9cad0fd3139ef048c0168daf393a34c1807af1a2" translate="yes" xml:space="preserve">
          <source>Operator expressions</source>
          <target state="translated">Выражения оператора</target>
        </trans-unit>
        <trans-unit id="9ae1b0ed74ef02f2a20320b8054a76c10c592467" translate="yes" xml:space="preserve">
          <source>Operator/Expression</source>
          <target state="translated">Operator/Expression</target>
        </trans-unit>
        <trans-unit id="e90414358dbfff0a68e4eb5d68a16978cf197d5a" translate="yes" xml:space="preserve">
          <source>Operators</source>
          <target state="translated">Operators</target>
        </trans-unit>
        <trans-unit id="a48efc62628a97b690c020f8a1e8f8cb0bb0733d" translate="yes" xml:space="preserve">
          <source>Operators are defined for built in types by the Rust language. Many of the following operators can also be overloaded using traits in &lt;code&gt;std::ops&lt;/code&gt; or &lt;code&gt;std::cmp&lt;/code&gt;.</source>
          <target state="translated">Операторы для встроенных типов определены языком Rust. Многие из следующих операторов также могут быть перегружены с помощью трейтов в &lt;code&gt;std::ops&lt;/code&gt; или &lt;code&gt;std::cmp&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d7b5d154187c93c9da7d2603b606ea0b5d7ebfc3" translate="yes" xml:space="preserve">
          <source>Optimization hints</source>
          <target state="translated">Подсказки по оптимизации</target>
        </trans-unit>
        <trans-unit id="e31d972229de381b461860014dd710856361917a" translate="yes" xml:space="preserve">
          <source>Option</source>
          <target state="translated">Option</target>
        </trans-unit>
        <trans-unit id="9a8587bd4b256cb6bf9e533c046c7ec07658a2a8" translate="yes" xml:space="preserve">
          <source>Option::and</source>
          <target state="translated">Option::and</target>
        </trans-unit>
        <trans-unit id="ad6a1d3208211ea9f4a0bbc163a21ab722dcc207" translate="yes" xml:space="preserve">
          <source>Option::and_then</source>
          <target state="translated">Option::and_then</target>
        </trans-unit>
        <trans-unit id="3f27b9ef99923ea0d93a7d269559394c38b333c3" translate="yes" xml:space="preserve">
          <source>Option::as_mut</source>
          <target state="translated">Option::as_mut</target>
        </trans-unit>
        <trans-unit id="e2458bfdc527d230aa943b40bea1e47ef7c1716a" translate="yes" xml:space="preserve">
          <source>Option::as_pin_mut</source>
          <target state="translated">Option::as_pin_mut</target>
        </trans-unit>
        <trans-unit id="627cd8388f389dc8a414dc64f0bd2aeb93b8bdb8" translate="yes" xml:space="preserve">
          <source>Option::as_pin_ref</source>
          <target state="translated">Option::as_pin_ref</target>
        </trans-unit>
        <trans-unit id="9e1386f584a53f30c4efc9f16fd6a42d3d390020" translate="yes" xml:space="preserve">
          <source>Option::as_ref</source>
          <target state="translated">Option::as_ref</target>
        </trans-unit>
        <trans-unit id="7e71699a5e7a9d061403b6a9d9cd2031f35e7d57" translate="yes" xml:space="preserve">
          <source>Option::borrow</source>
          <target state="translated">Option::borrow</target>
        </trans-unit>
        <trans-unit id="5a2fc76bcd6cc7797b2fc8e79077c3b905ad253b" translate="yes" xml:space="preserve">
          <source>Option::borrow_mut</source>
          <target state="translated">Option::borrow_mut</target>
        </trans-unit>
        <trans-unit id="f8c7733356cc897d454d9d0b3ed5583a86a4fc0c" translate="yes" xml:space="preserve">
          <source>Option::clamp</source>
          <target state="translated">Option::clamp</target>
        </trans-unit>
        <trans-unit id="b2ed5b3da837f6c02fff44b90e9fcf28f2c92857" translate="yes" xml:space="preserve">
          <source>Option::clone</source>
          <target state="translated">Option::clone</target>
        </trans-unit>
        <trans-unit id="41a138cf124c5fbd9ab6a71d2a521b6f7b355bd9" translate="yes" xml:space="preserve">
          <source>Option::clone_from</source>
          <target state="translated">Option::clone_from</target>
        </trans-unit>
        <trans-unit id="428c2ed3ef54229edff7bb1c574b0bfd79b5c01e" translate="yes" xml:space="preserve">
          <source>Option::clone_into</source>
          <target state="translated">Option::clone_into</target>
        </trans-unit>
        <trans-unit id="7cd06b03e80642a3e13258da69f36190c57d76fe" translate="yes" xml:space="preserve">
          <source>Option::cloned</source>
          <target state="translated">Option::cloned</target>
        </trans-unit>
        <trans-unit id="7ea9e4985c5cd3b4ff11c4891148d8ba5e1cf7f3" translate="yes" xml:space="preserve">
          <source>Option::cmp</source>
          <target state="translated">Option::cmp</target>
        </trans-unit>
        <trans-unit id="0498a1a6447eab280dd5d4ffdbbf44f5e3cd0a3e" translate="yes" xml:space="preserve">
          <source>Option::copied</source>
          <target state="translated">Option::copied</target>
        </trans-unit>
        <trans-unit id="cb4ad142555a29053e45e10fc10d79edcbc2a96c" translate="yes" xml:space="preserve">
          <source>Option::default</source>
          <target state="translated">Option::default</target>
        </trans-unit>
        <trans-unit id="ba7eb304c78625b7673ed4fb2b20bafd2105ff7d" translate="yes" xml:space="preserve">
          <source>Option::deref</source>
          <target state="translated">Option::deref</target>
        </trans-unit>
        <trans-unit id="cb4668f98374c478c313d6124b78706cb9deedbc" translate="yes" xml:space="preserve">
          <source>Option::eq</source>
          <target state="translated">Option::eq</target>
        </trans-unit>
        <trans-unit id="76cfff0c978f7770807e24ce63e5dfca252d4367" translate="yes" xml:space="preserve">
          <source>Option::expect</source>
          <target state="translated">Option::expect</target>
        </trans-unit>
        <trans-unit id="6a0b764b6cbe10497b80db91840a28c114598907" translate="yes" xml:space="preserve">
          <source>Option::filter</source>
          <target state="translated">Option::filter</target>
        </trans-unit>
        <trans-unit id="560bd097e6d518e06d94482f4a9697ad398f15d0" translate="yes" xml:space="preserve">
          <source>Option::flatten</source>
          <target state="translated">Option::flatten</target>
        </trans-unit>
        <trans-unit id="d94a2e5f0e616513666e331c6d9144bddb878e9c" translate="yes" xml:space="preserve">
          <source>Option::fmt</source>
          <target state="translated">Option::fmt</target>
        </trans-unit>
        <trans-unit id="cbd7d776e3b699aac19b698f4ca1165601a486cb" translate="yes" xml:space="preserve">
          <source>Option::from</source>
          <target state="translated">Option::from</target>
        </trans-unit>
        <trans-unit id="e4ce8c942f648512db0f55fca12f5af00d0f8696" translate="yes" xml:space="preserve">
          <source>Option::from_error</source>
          <target state="translated">Option::from_error</target>
        </trans-unit>
        <trans-unit id="7e569e7075b5cfd328272103d6b5f8ce7d4d2194" translate="yes" xml:space="preserve">
          <source>Option::from_iter</source>
          <target state="translated">Option::from_iter</target>
        </trans-unit>
        <trans-unit id="a43b3b6ad08c70527052c24fb47f39fcaa4ebb0e" translate="yes" xml:space="preserve">
          <source>Option::from_ok</source>
          <target state="translated">Option::from_ok</target>
        </trans-unit>
        <trans-unit id="39c61b7ca243afc1e123c7964d51460ccf7ce39f" translate="yes" xml:space="preserve">
          <source>Option::ge</source>
          <target state="translated">Option::ge</target>
        </trans-unit>
        <trans-unit id="9b6edfb0a8e4a4f18c5a5177c880df9517534d89" translate="yes" xml:space="preserve">
          <source>Option::get_or_insert</source>
          <target state="translated">Option::get_or_insert</target>
        </trans-unit>
        <trans-unit id="998b5cc317f56f6b2107c170f3756fdcf6a6be39" translate="yes" xml:space="preserve">
          <source>Option::get_or_insert_with</source>
          <target state="translated">Option::get_or_insert_with</target>
        </trans-unit>
        <trans-unit id="ff18d337dd9fab1c83bb85ddea3fd7d94d3281c1" translate="yes" xml:space="preserve">
          <source>Option::gt</source>
          <target state="translated">Option::gt</target>
        </trans-unit>
        <trans-unit id="501ecb8b666b964e28da12f4615b48d3b7e450ee" translate="yes" xml:space="preserve">
          <source>Option::hash</source>
          <target state="translated">Option::hash</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
