<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ru" datatype="htmlbody" original="rust">
    <body>
      <group id="rust">
        <trans-unit id="676fb636ec3ef59315a4dc9ef64f5fbe3403351d" translate="yes" xml:space="preserve">
          <source>This way, the lifetime of the &lt;a href=&quot;struct.cstring&quot;&gt;&lt;code&gt;CString&lt;/code&gt;&lt;/a&gt; in &lt;code&gt;hello&lt;/code&gt; encompasses the lifetime of &lt;code&gt;ptr&lt;/code&gt; and the &lt;code&gt;unsafe&lt;/code&gt; block.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0051a5a0c2153685b22e3e481253428438ae9b0d" translate="yes" xml:space="preserve">
          <source>This way, the lifetime of the &lt;code&gt;CString&lt;/code&gt; in &lt;code&gt;hello&lt;/code&gt; encompasses the lifetime of &lt;code&gt;ptr&lt;/code&gt; and the &lt;code&gt;unsafe&lt;/code&gt; block.</source>
          <target state="translated">Таким образом, время жизни &lt;code&gt;CString&lt;/code&gt; в &lt;code&gt;hello&lt;/code&gt; включает время жизни &lt;code&gt;ptr&lt;/code&gt; и &lt;code&gt;unsafe&lt;/code&gt; блока.</target>
        </trans-unit>
        <trans-unit id="6a66e53cbccdcf1dd0b129068e28220aa1da407b" translate="yes" xml:space="preserve">
          <source>This will allocate as many times as needed for constructing the &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; and then it will allocate once for turning the &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; into the &lt;code&gt;Arc&amp;lt;[T]&amp;gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="be23e02db6f58e9303929f35bcf996dc6954c461" translate="yes" xml:space="preserve">
          <source>This will allocate as many times as needed for constructing the &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; and then it will allocate once for turning the &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; into the &lt;code&gt;Rc&amp;lt;[T]&amp;gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c87576c37932e7e920719c7c3053295204953101" translate="yes" xml:space="preserve">
          <source>This will always &lt;a href=&quot;macro.panic&quot;&gt;&lt;code&gt;panic!&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">Это всегда вызовет &lt;a href=&quot;macro.panic&quot;&gt; &lt;code&gt;panic!&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="1c37af121800fff05f23ea7195ec86eae7b112d6" translate="yes" xml:space="preserve">
          <source>This will always &lt;a href=&quot;macro.panic&quot;&gt;panic!&lt;/a&gt;</source>
          <target state="translated">Это всегда вызовет &lt;a href=&quot;macro.panic&quot;&gt;панику!&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="f7ba30b4423020d7c6174593849644ce672a970c" translate="yes" xml:space="preserve">
          <source>This will always &lt;a href=&quot;macro.panic&quot;&gt;panic!&lt;/a&gt; because &lt;code&gt;unimplemented!&lt;/code&gt; is just a shorthand for &lt;code&gt;panic!&lt;/code&gt; with a fixed, specific message.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ca9dc67930c6219a678b4690efb3c9a2b4b3cc3e" translate="yes" xml:space="preserve">
          <source>This will be a max-heap.</source>
          <target state="translated">Это будет максимальная куча.</target>
        </trans-unit>
        <trans-unit id="835f899ffcb476aee6b318f9e24a76f9e21b8043" translate="yes" xml:space="preserve">
          <source>This will be allowed at some point in the future, but the implementation is not yet complete. See the &lt;a href=&quot;https://github.com/rust-lang/rust/issues/61949&quot;&gt;issue-61949&lt;/a&gt; for this limitation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="850691bcf932c0c55cd89eb4535ca90e22acf61f" translate="yes" xml:space="preserve">
          <source>This will be allowed at some point in the future, but the implementation is not yet complete. See the tracking issue for &lt;a href=&quot;https://github.com/rust-lang/rust/issues/49146&quot;&gt;conditionals&lt;/a&gt; or &lt;a href=&quot;https://github.com/rust-lang/rust/issues/52000&quot;&gt;loops&lt;/a&gt; in a const context for the current status.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4fffbe8e22b797d8b6890d54d873414453d3490a" translate="yes" xml:space="preserve">
          <source>This will cause an error:</source>
          <target state="translated">Это приведет к ошибке:</target>
        </trans-unit>
        <trans-unit id="5b06471f77c7403c58187c73c7a664a50663e032" translate="yes" xml:space="preserve">
          <source>This will commonly, but not always, be a &lt;code&gt;&amp;amp;'static str&lt;/code&gt; or &lt;a href=&quot;../string/struct.string&quot;&gt;&lt;code&gt;String&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Обычно, но не всегда, это &lt;code&gt;&amp;amp;'static str&lt;/code&gt; &lt;a href=&quot;../string/struct.string&quot;&gt; &lt;code&gt;String&lt;/code&gt; &lt;/a&gt; &amp;amp; или String .</target>
        </trans-unit>
        <trans-unit id="1a8b17614cf7c240a7a1eb116da8eea5f59c7b71" translate="yes" xml:space="preserve">
          <source>This will compile, because it has the constraint on the type parameter:</source>
          <target state="translated">Это будет скомпилировано,так как имеет ограничение на параметр типа:</target>
        </trans-unit>
        <trans-unit id="3520fed49c822ab60288ef2f8f669d15b4a41e6f" translate="yes" xml:space="preserve">
          <source>This will compile:</source>
          <target state="translated">Это будет собрано:</target>
        </trans-unit>
        <trans-unit id="49cc821a81b4f339dbb259efc2d82e6ee470759f" translate="yes" xml:space="preserve">
          <source>This will create a &lt;a href=&quot;../primitive.str&quot;&gt;&lt;code&gt;&amp;amp;str&lt;/code&gt;&lt;/a&gt; from the &lt;code&gt;String&lt;/code&gt; and pass it in. This conversion is very inexpensive, and so generally, functions will accept &lt;a href=&quot;../primitive.str&quot;&gt;&lt;code&gt;&amp;amp;str&lt;/code&gt;&lt;/a&gt;s as arguments unless they need a &lt;code&gt;String&lt;/code&gt; for some specific reason.</source>
          <target state="translated">Это создаст &lt;a href=&quot;../primitive.str&quot;&gt; &lt;code&gt;&amp;amp;str&lt;/code&gt; &lt;/a&gt; из &lt;code&gt;String&lt;/code&gt; и передаст его. Это преобразование очень недорогое, и поэтому обычно функции принимают &lt;a href=&quot;../primitive.str&quot;&gt; &lt;code&gt;&amp;amp;str&lt;/code&gt; &lt;/a&gt; качестве аргументов, если им не нужна &lt;code&gt;String&lt;/code&gt; по какой-либо конкретной причине.</target>
        </trans-unit>
        <trans-unit id="1b5cc9b9f228f1bae8ee73a71afeed4d549dd793" translate="yes" xml:space="preserve">
          <source>This will create a thread using default parameters of &lt;a href=&quot;struct.builder&quot;&gt;&lt;code&gt;Builder&lt;/code&gt;&lt;/a&gt;, if you want to specify the stack size or the name of the thread, use this API instead.</source>
          <target state="translated">Это создаст поток с использованием параметров &lt;a href=&quot;struct.builder&quot;&gt; &lt;code&gt;Builder&lt;/code&gt; &lt;/a&gt; по умолчанию , если вы хотите указать размер стека или имя потока, используйте вместо этого этот API.</target>
        </trans-unit>
        <trans-unit id="e391cc107c46641450ffa0654fcfb8cbca70a73b" translate="yes" xml:space="preserve">
          <source>This will decrement the strong reference count. If the strong reference count reaches zero then the only other references (if any) are &lt;a href=&quot;../rc/struct.weak&quot;&gt;&lt;code&gt;Weak&lt;/code&gt;&lt;/a&gt;, so we &lt;code&gt;drop&lt;/code&gt; the inner value.</source>
          <target state="translated">Это уменьшит количество сильных ссылок. Если счетчик сильных ссылок достигает нуля, тогда единственные другие ссылки (если есть) являются &lt;a href=&quot;../rc/struct.weak&quot;&gt; &lt;code&gt;Weak&lt;/code&gt; &lt;/a&gt; , поэтому мы &lt;code&gt;drop&lt;/code&gt; внутреннее значение.</target>
        </trans-unit>
        <trans-unit id="97b7f84f70f9d3f5d6303968924e2733780bc78b" translate="yes" xml:space="preserve">
          <source>This will decrement the strong reference count. If the strong reference count reaches zero then the only other references (if any) are &lt;a href=&quot;../sync/struct.weak&quot;&gt;&lt;code&gt;Weak&lt;/code&gt;&lt;/a&gt;, so we &lt;code&gt;drop&lt;/code&gt; the inner value.</source>
          <target state="translated">Это уменьшит количество сильных ссылок. Если счетчик сильных ссылок достигает нуля, тогда единственные другие ссылки (если есть) являются &lt;a href=&quot;../sync/struct.weak&quot;&gt; &lt;code&gt;Weak&lt;/code&gt; &lt;/a&gt; , поэтому мы &lt;code&gt;drop&lt;/code&gt; внутреннее значение.</target>
        </trans-unit>
        <trans-unit id="b917396cbcb63b72ec008aadc499d642c7abbf61" translate="yes" xml:space="preserve">
          <source>This will decrement the strong reference count. If the strong reference count reaches zero then the only other references (if any) are &lt;a href=&quot;struct.weak&quot;&gt;&lt;code&gt;Weak&lt;/code&gt;&lt;/a&gt;, so we &lt;code&gt;drop&lt;/code&gt; the inner value.</source>
          <target state="translated">Это уменьшит количество сильных ссылок. Если счетчик сильных ссылок достигает нуля, тогда единственные другие ссылки (если есть) являются &lt;a href=&quot;struct.weak&quot;&gt; &lt;code&gt;Weak&lt;/code&gt; &lt;/a&gt; , поэтому мы &lt;code&gt;drop&lt;/code&gt; внутреннее значение.</target>
        </trans-unit>
        <trans-unit id="0e9819c7b2177172935ef1092ecc4f74eaf1578f" translate="yes" xml:space="preserve">
          <source>This will drop any excess capacity.</source>
          <target state="translated">Это снизит любую избыточную мощность.</target>
        </trans-unit>
        <trans-unit id="354a015dbdb2ab35ae4e0b061d1f50f5025f7cbe" translate="yes" xml:space="preserve">
          <source>This will escape characters with the Rust syntax of the form &lt;code&gt;\u{NNNNNN}&lt;/code&gt; where &lt;code&gt;NNNNNN&lt;/code&gt; is a hexadecimal representation.</source>
          <target state="translated">Это позволит избежать символов с синтаксисом Rust в форме &lt;code&gt;\u{NNNNNN}&lt;/code&gt; где &lt;code&gt;NNNNNN&lt;/code&gt; - шестнадцатеричное представление.</target>
        </trans-unit>
        <trans-unit id="c51882eef9b6927fb20dc2b079d5f33d822ffcef" translate="yes" xml:space="preserve">
          <source>This will escape the characters similar to the &lt;code&gt;Debug&lt;/code&gt; implementations of &lt;code&gt;str&lt;/code&gt; or &lt;code&gt;char&lt;/code&gt;.</source>
          <target state="translated">Это позволит избежать символов, аналогичных реализациям &lt;code&gt;Debug&lt;/code&gt; &lt;code&gt;str&lt;/code&gt; или &lt;code&gt;char&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7463a3fbad059d7822b7a64865f64ec71f56ca6c" translate="yes" xml:space="preserve">
          <source>This will fail because the compiler does not know which instance of &lt;code&gt;Foo&lt;/code&gt; to call &lt;code&gt;bar&lt;/code&gt; on. Change &lt;code&gt;Foo::bar()&lt;/code&gt; to &lt;code&gt;Foo::&amp;lt;T&amp;gt;::bar()&lt;/code&gt; to resolve the error.</source>
          <target state="translated">Это не удастся, потому что компилятор не знает, какой экземпляр &lt;code&gt;Foo&lt;/code&gt; вызывать &lt;code&gt;bar&lt;/code&gt; . Измените &lt;code&gt;Foo::bar()&lt;/code&gt; на &lt;code&gt;Foo::&amp;lt;T&amp;gt;::bar()&lt;/code&gt; чтобы устранить ошибку.</target>
        </trans-unit>
        <trans-unit id="b95565727f175f666e1822f4733ae91ef6a1780e" translate="yes" xml:space="preserve">
          <source>This will fail to compile because we cannot implement a trait for a type if both the trait and the type are not defined by the current crate. This is due to Rust's orphaning rules. To bypass this, you can implement &lt;a href=&quot;trait.into&quot;&gt;&lt;code&gt;Into&lt;/code&gt;&lt;/a&gt; directly:</source>
          <target state="translated">Это не будет скомпилировано, потому что мы не сможем реализовать трейт для типа, если и трейт, и тип не определены текущим ящиком. Это связано с правилами Rust по поводу сиротства. Чтобы обойти это, вы можете напрямую реализовать &lt;a href=&quot;trait.into&quot;&gt; &lt;code&gt;Into&lt;/code&gt; &lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="8648eb6ea2730446e0cfb046319d740aba54d8bb" translate="yes" xml:space="preserve">
          <source>This will fail to compile in older versions of the language because Rust's orphaning rules used to be a little bit more strict. To bypass this, you could implement &lt;a href=&quot;trait.into&quot;&gt;&lt;code&gt;Into&lt;/code&gt;&lt;/a&gt; directly:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5c41f14d1e2c5310aaa0b927129f701a7031c03a" translate="yes" xml:space="preserve">
          <source>This will invoke the &lt;a href=&quot;macro.panic&quot;&gt;&lt;code&gt;panic!&lt;/code&gt;&lt;/a&gt; macro if the provided expression cannot be evaluated to &lt;code&gt;true&lt;/code&gt; at runtime.</source>
          <target state="translated">Это вызовет &lt;a href=&quot;macro.panic&quot;&gt; &lt;code&gt;panic!&lt;/code&gt; &lt;/a&gt;макрос, если предоставленное выражение не может быть оценено как &lt;code&gt;true&lt;/code&gt; во время выполнения.</target>
        </trans-unit>
        <trans-unit id="2deb5f847f234caa59a2e70f4ab65edaeb2fdead" translate="yes" xml:space="preserve">
          <source>This will lazily initialize the value if this thread has not referenced this key yet.</source>
          <target state="translated">Это позволит лениво инициализировать значение,если данный поток еще не ссылался на этот ключ.</target>
        </trans-unit>
        <trans-unit id="2be746d77ee47101c5a961aeebfbec50b6101d49" translate="yes" xml:space="preserve">
          <source>This will lazily initialize the value if this thread has not referenced this key yet. If the key has been destroyed (which may happen if this is called in a destructor), this function will return an &lt;a href=&quot;struct.accesserror&quot;&gt;&lt;code&gt;AccessError&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Это будет лениво инициализировать значение, если этот поток еще не ссылался на этот ключ. Если ключ был уничтожен (что может произойти, если он вызывается в деструкторе), эта функция вернет &lt;a href=&quot;struct.accesserror&quot;&gt; &lt;code&gt;AccessError&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="3800eafd69cf59aa81eb6bb72cb9493004b5c43e" translate="yes" xml:space="preserve">
          <source>This will make &lt;code&gt;CASE_INSENSITIVE&lt;/code&gt; persist for the remainder of your shell session. It can be unset with the &lt;code&gt;Remove-Item&lt;/code&gt; cmdlet:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4b457d7ac05dde73ffae7dfa5283d452dba90a68" translate="yes" xml:space="preserve">
          <source>This will not print any values, as we only created an iterator, rather than using it. The compiler will warn us about this kind of behavior:</source>
          <target state="translated">При этом не будут печататься никакие значения,так как мы только создали итератор,а не используем его.Компилятор предупредит нас о подобном поведении:</target>
        </trans-unit>
        <trans-unit id="7884f03c74d608aa53fe96a0fe19b6f01fc64a4e" translate="yes" xml:space="preserve">
          <source>This will not work if the new name is on a different mount point.</source>
          <target state="translated">Это не будет работать,если новое имя находится в другой точке крепления.</target>
        </trans-unit>
        <trans-unit id="29502fa64160996ff78f02e55cbb4b83b39e3b0d" translate="yes" xml:space="preserve">
          <source>This will not:</source>
          <target state="translated">Этого не случится:</target>
        </trans-unit>
        <trans-unit id="b5b85ab1e962bdcb10ff35cb96c42d807c436122" translate="yes" xml:space="preserve">
          <source>This will output the following:</source>
          <target state="translated">В результате будет выдано следующее:</target>
        </trans-unit>
        <trans-unit id="01e646d50274ee113a75cb82fc9f837874518988" translate="yes" xml:space="preserve">
          <source>This will override the &lt;code&gt;read&lt;/code&gt;, &lt;code&gt;write&lt;/code&gt;, and &lt;code&gt;append&lt;/code&gt; flags on the &lt;code&gt;OpenOptions&lt;/code&gt; structure. This method provides fine-grained control over the permissions to read, write and append data, attributes (like hidden and system), and extended attributes.</source>
          <target state="translated">Это переопределит флаги &lt;code&gt;read&lt;/code&gt; , &lt;code&gt;write&lt;/code&gt; и &lt;code&gt;append&lt;/code&gt; в структуре &lt;code&gt;OpenOptions&lt;/code&gt; . Этот метод обеспечивает детальный контроль над разрешениями на чтение, запись и добавление данных, атрибутов (например, скрытых и системных) и расширенных атрибутов.</target>
        </trans-unit>
        <trans-unit id="2ed7ee1155828d2b2b40b29d755792b670ff1874" translate="yes" xml:space="preserve">
          <source>This will print</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="475997c398cd5b2921c0cb8cd3f062a1e5e787e7" translate="yes" xml:space="preserve">
          <source>This will print &quot;('a', 1), ('b', 2), ('c', 3)&quot;.</source>
          <target state="translated">Это напечатает &quot;('a',1),('b',2),('c',3)&quot;.</target>
        </trans-unit>
        <trans-unit id="3a5f8c78def77453ab00074a3cd30ff4dd27218b" translate="yes" xml:space="preserve">
          <source>This will print &lt;code&gt;1&lt;/code&gt; through &lt;code&gt;5&lt;/code&gt;, each on their own line.</source>
          <target state="translated">Это напечатает от &lt;code&gt;1&lt;/code&gt; до &lt;code&gt;5&lt;/code&gt; , каждый в отдельной строке.</target>
        </trans-unit>
        <trans-unit id="45cc5d4168a6948db8686b2c0a8d37fbb64175cc" translate="yes" xml:space="preserve">
          <source>This will print &lt;code&gt;Cons(1, Cons(2, Nil))&lt;/code&gt;.</source>
          <target state="translated">Это напечатает &lt;code&gt;Cons(1, Cons(2, Nil))&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="fa3cd6bbcdf4b75c4bbd0f80ed7b9518ac88ecb8" translate="yes" xml:space="preserve">
          <source>This will print the numbers &lt;code&gt;0&lt;/code&gt; through &lt;code&gt;4&lt;/code&gt;, each on their own line.</source>
          <target state="translated">Это напечатает числа от &lt;code&gt;0&lt;/code&gt; до &lt;code&gt;4&lt;/code&gt; , каждое в отдельной строке.</target>
        </trans-unit>
        <trans-unit id="a40fac0ea22a56e98579c9cc97554e4f4a65b5bb" translate="yes" xml:space="preserve">
          <source>This will print the numbers one through five, each on their own line. But you'll notice something here: we never called anything on our vector to produce an iterator. What gives?</source>
          <target state="translated">Это выведет цифры с первого по пятый,каждая на свою линию.Но здесь вы заметите кое-что:мы никогда ничего не вызывали по нашему вектору для создания итератора.Что дает?</target>
        </trans-unit>
        <trans-unit id="6e363eb5c9d1e189e7877f05521713cb961f9afe" translate="yes" xml:space="preserve">
          <source>This will print:</source>
          <target state="translated">Это напечатает:</target>
        </trans-unit>
        <trans-unit id="e3f9d6eebc7d0a9c3006485e1bf2fe9250c18991" translate="yes" xml:space="preserve">
          <source>This will result in &lt;code&gt;read&lt;/code&gt;, &lt;code&gt;write&lt;/code&gt;, &lt;code&gt;recv&lt;/code&gt; and &lt;code&gt;send&lt;/code&gt; operations becoming nonblocking, i.e., immediately returning from their calls. If the IO operation is successful, &lt;code&gt;Ok&lt;/code&gt; is returned and no further action is required. If the IO operation could not be completed and needs to be retried, an error with kind &lt;a href=&quot;../io/enum.errorkind#variant.WouldBlock&quot;&gt;&lt;code&gt;io::ErrorKind::WouldBlock&lt;/code&gt;&lt;/a&gt; is returned.</source>
          <target state="translated">Это приведет &lt;code&gt;read&lt;/code&gt; , &lt;code&gt;write&lt;/code&gt; , &lt;code&gt;recv&lt;/code&gt; и &lt;code&gt;send&lt;/code&gt; операций становится неблокируемым, то есть, сразу же возвращаясь из своих звонков. Если операция ввода-вывода прошла успешно, возвращается &lt;code&gt;Ok&lt;/code&gt; и никаких дальнейших действий не требуется. Если операция ввода-вывода не может быть завершена и ее необходимо &lt;a href=&quot;../io/enum.errorkind#variant.WouldBlock&quot;&gt; &lt;code&gt;io::ErrorKind::WouldBlock&lt;/code&gt; &lt;/a&gt; , возвращается ошибка вида io :: ErrorKind :: wouldBlock .</target>
        </trans-unit>
        <trans-unit id="4b3da21af1f8f50bfb5fb08b425cfbfeb0c3196a" translate="yes" xml:space="preserve">
          <source>This will result in &lt;code&gt;recv&lt;/code&gt;, &lt;code&gt;recv_from&lt;/code&gt;, &lt;code&gt;send&lt;/code&gt;, and &lt;code&gt;send_to&lt;/code&gt; operations becoming nonblocking, i.e., immediately returning from their calls. If the IO operation is successful, &lt;code&gt;Ok&lt;/code&gt; is returned and no further action is required. If the IO operation could not be completed and needs to be retried, an error with kind &lt;a href=&quot;../io/enum.errorkind#variant.WouldBlock&quot;&gt;&lt;code&gt;io::ErrorKind::WouldBlock&lt;/code&gt;&lt;/a&gt; is returned.</source>
          <target state="translated">Это приведет к тому , что &lt;code&gt;recv_from&lt;/code&gt; &lt;code&gt;recv&lt;/code&gt; , recv_from , &lt;code&gt;send&lt;/code&gt; и &lt;code&gt;send_to&lt;/code&gt; станут неблокирующими, т. Е. Немедленно вернутся из своих вызовов. Если операция ввода-вывода прошла успешно, возвращается &lt;code&gt;Ok&lt;/code&gt; и никаких дальнейших действий не требуется. Если операция ввода-вывода не может быть завершена и ее необходимо &lt;a href=&quot;../io/enum.errorkind#variant.WouldBlock&quot;&gt; &lt;code&gt;io::ErrorKind::WouldBlock&lt;/code&gt; &lt;/a&gt; , возвращается ошибка вида io :: ErrorKind :: wouldBlock .</target>
        </trans-unit>
        <trans-unit id="5f9e536d8780a7dfeadd69ff71cc712be79eb591" translate="yes" xml:space="preserve">
          <source>This will result in the &lt;code&gt;accept&lt;/code&gt; operation becoming nonblocking, i.e., immediately returning from their calls. If the IO operation is successful, &lt;code&gt;Ok&lt;/code&gt; is returned and no further action is required. If the IO operation could not be completed and needs to be retried, an error with kind &lt;a href=&quot;../../../io/enum.errorkind#variant.WouldBlock&quot;&gt;&lt;code&gt;io::ErrorKind::WouldBlock&lt;/code&gt;&lt;/a&gt; is returned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="62e7ab507f523fe704d7f615781e7105b958a139" translate="yes" xml:space="preserve">
          <source>This will result in the &lt;code&gt;accept&lt;/code&gt; operation becoming nonblocking, i.e., immediately returning from their calls. If the IO operation is successful, &lt;code&gt;Ok&lt;/code&gt; is returned and no further action is required. If the IO operation could not be completed and needs to be retried, an error with kind &lt;a href=&quot;../io/enum.errorkind#variant.WouldBlock&quot;&gt;&lt;code&gt;io::ErrorKind::WouldBlock&lt;/code&gt;&lt;/a&gt; is returned.</source>
          <target state="translated">Это приведет к &lt;code&gt;accept&lt;/code&gt; операция accept станет неблокирующей, т. Е. Немедленно вернется из своих вызовов. Если операция ввода-вывода прошла успешно, возвращается &lt;code&gt;Ok&lt;/code&gt; и никаких дальнейших действий не требуется. Если операция ввода-вывода не может быть завершена и ее необходимо &lt;a href=&quot;../io/enum.errorkind#variant.WouldBlock&quot;&gt; &lt;code&gt;io::ErrorKind::WouldBlock&lt;/code&gt; &lt;/a&gt; , возвращается ошибка вида io :: ErrorKind :: wouldBlock .</target>
        </trans-unit>
        <trans-unit id="b55e73be7a2382bca6297d35304f77d90844f6fa" translate="yes" xml:space="preserve">
          <source>This will retrieve the stored error in the underlying socket, clearing the field in the process. This can be useful for checking errors between calls.</source>
          <target state="translated">При этом будет восстановлена сохраненная ошибка в базовом разъеме,а поле в процессе очистки будет очищено.Это может быть полезно для проверки ошибок между вызовами.</target>
        </trans-unit>
        <trans-unit id="88ce8a4d0f2f6725fab10313d205fd945723d024" translate="yes" xml:space="preserve">
          <source>This will return &lt;code&gt;None&lt;/code&gt; if the &lt;code&gt;Metadata&lt;/code&gt; instance was created from a call to &lt;code&gt;DirEntry::metadata&lt;/code&gt;. If this &lt;code&gt;Metadata&lt;/code&gt; was created by using &lt;code&gt;fs::metadata&lt;/code&gt; or &lt;code&gt;File::metadata&lt;/code&gt;, then this will return &lt;code&gt;Some&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3f194e7c7453fbebb97c4d612baa72decde0dd60" translate="yes" xml:space="preserve">
          <source>This will return an error when the IP version of the local socket does not match that returned from &lt;a href=&quot;trait.tosocketaddrs&quot;&gt;&lt;code&gt;ToSocketAddrs&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Это вернет ошибку, если IP-версия локального сокета не совпадает с &lt;a href=&quot;trait.tosocketaddrs&quot;&gt; &lt;code&gt;ToSocketAddrs&lt;/code&gt; &lt;/a&gt; , возвращенной ToSocketAddrs .</target>
        </trans-unit>
        <trans-unit id="fc0cdcc30572aec7d1df1cbb47d079cf5a14ac66" translate="yes" xml:space="preserve">
          <source>This will succeed even if there are outstanding weak references.</source>
          <target state="translated">Это удастся,даже если есть невыполненные слабые рекомендации.</target>
        </trans-unit>
        <trans-unit id="2bd1f4c0ae47dc79d8ec8c7bba4ba6b5d8664eba" translate="yes" xml:space="preserve">
          <source>This will use &lt;code&gt;clone&lt;/code&gt; to duplicate an expression, so one should be careful using this with types having a nonstandard &lt;code&gt;Clone&lt;/code&gt; implementation. For example, &lt;code&gt;vec![Rc::new(1); 5]&lt;/code&gt; will create a vector of five references to the same boxed integer value, not five references pointing to independently boxed integers.</source>
          <target state="translated">Это будет использовать &lt;code&gt;clone&lt;/code&gt; для дублирования выражения, поэтому следует быть осторожным, используя это с типами, имеющими нестандартную реализацию &lt;code&gt;Clone&lt;/code&gt; . Например, &lt;code&gt;vec![Rc::new(1); 5]&lt;/code&gt; создаст вектор из пяти ссылок на одно и то же целое число в рамке, а не из пяти ссылок, указывающих на независимо упакованные целые числа.</target>
        </trans-unit>
        <trans-unit id="1af0f8715542d97c1e40ad188906242d9ebb10f7" translate="yes" xml:space="preserve">
          <source>This works because &lt;code&gt;Box&lt;/code&gt; is a pointer, so its size is well-known.</source>
          <target state="translated">Это работает, потому что &lt;code&gt;Box&lt;/code&gt; является указателем, поэтому его размер хорошо известен.</target>
        </trans-unit>
        <trans-unit id="e6ae7145b95212826784b081e816d005693796fd" translate="yes" xml:space="preserve">
          <source>This works differently from defining a struct that uses a generic type parameter with trait bounds. A generic type parameter can only be substituted with one concrete type at a time, whereas trait objects allow for multiple concrete types to fill in for the trait object at runtime. For example, we could have defined the &lt;code&gt;Screen&lt;/code&gt; struct using a generic type and a trait bound as in Listing 17-6:</source>
          <target state="translated">Это работает иначе, чем определение структуры, которая использует параметр универсального типа с границами характеристик. Параметр универсального типа может быть заменен только одним конкретным типом за раз, тогда как объекты признаков позволяют нескольким конкретным типам заменять объект признака во время выполнения. Например, мы могли бы определить структуру &lt;code&gt;Screen&lt;/code&gt; , используя общий тип и привязку характеристики, как в листинге 17-6:</target>
        </trans-unit>
        <trans-unit id="a99f3af5ecd17821d147ce27f764af7ca400396e" translate="yes" xml:space="preserve">
          <source>This works fine, but when the method gains generic parameters, we can have a problem.</source>
          <target state="translated">Это хорошо работает,но когда метод получает общие параметры,у нас может возникнуть проблема.</target>
        </trans-unit>
        <trans-unit id="d71531129bdd4b29a09ed683d862d9540e2e5d1c" translate="yes" xml:space="preserve">
          <source>This works just fine and explicitly produces the behavior shown in Figure 4-3, where the heap data &lt;em&gt;does&lt;/em&gt; get copied.</source>
          <target state="translated">Это прекрасно работает и явно производит поведение показано на рисунке 4-3, где данные кучи &lt;em&gt;действительно&lt;/em&gt; копируются.</target>
        </trans-unit>
        <trans-unit id="bfbfb994099b13008a48f4d00df577d26e30661c" translate="yes" xml:space="preserve">
          <source>This works without any problems. Ownership is moved out, and nothing is deallocated.</source>
          <target state="translated">Это работает без проблем.Собственность вывозится,и ничего не перераспределяется.</target>
        </trans-unit>
        <trans-unit id="6c438e4eca96ad10f658e6fd464bdd00bbab9e0b" translate="yes" xml:space="preserve">
          <source>This wrapper helps with explicitly documenting the drop order dependencies between fields of the type:</source>
          <target state="translated">Эта обертка помогает явно документировать зависимости порядка падения между полями типа:</target>
        </trans-unit>
        <trans-unit id="77c94458816b78e926120564c533b185a38f9981" translate="yes" xml:space="preserve">
          <source>This wrapper is 0-cost.</source>
          <target state="translated">Эта обёртка стоит 0.</target>
        </trans-unit>
        <trans-unit id="bb9a9b150cc6f7bfa7d25085c5da29bd09b9aebf" translate="yes" xml:space="preserve">
          <source>This zero-sized type &lt;em&gt;coerces&lt;/em&gt; to a regular function pointer. For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8adf6fbbeb84fc23d69997d38f588cc8535a0a6a" translate="yes" xml:space="preserve">
          <source>Though they both have scary names, &lt;code&gt;PhantomData&lt;/code&gt; and 'phantom types' are related, but not identical. A phantom type parameter is simply a type parameter which is never used. In Rust, this often causes the compiler to complain, and the solution is to add a &quot;dummy&quot; use by way of &lt;code&gt;PhantomData&lt;/code&gt;.</source>
          <target state="translated">Хотя у них обоих устрашающие имена, &lt;code&gt;PhantomData&lt;/code&gt; и &amp;laquo;фантомные типы&amp;raquo; связаны, но не идентичны. Параметр фантомного типа - это просто параметр типа, который никогда не используется. В Rust это часто вызывает недовольство компилятора, и решение состоит в том, чтобы добавить &amp;laquo;фиктивное&amp;raquo; использование посредством &lt;code&gt;PhantomData&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="394004c26aaecc036ffcf91c8fc18935b18646a0" translate="yes" xml:space="preserve">
          <source>Though this example seems innocuous and easy to solve, the problem becomes clear when it encounters functions which consume the value:</source>
          <target state="translated">Хотя этот пример кажется безобидным и легко решаемым,проблема становится понятной,когда она сталкивается с функциями,которые потребляют значение:</target>
        </trans-unit>
        <trans-unit id="68fc8c5fcce31dacdf37236f648493191d2504be" translate="yes" xml:space="preserve">
          <source>Though this method is safe for any two pointers, note that its result will be mostly useless if the two pointers aren't into the same allocated object, for example if they point to two different local variables.</source>
          <target state="translated">Хотя этот метод безопасен для любых двух указателей,обратите внимание,что его результат будет в основном бесполезен,если эти два указателя не находятся в одном и том же выделенном объекте,например,если они указывают на две различные локальные переменные.</target>
        </trans-unit>
        <trans-unit id="7863f7503e5377891a3b7452c7d6cc377d443fe7" translate="yes" xml:space="preserve">
          <source>Thread</source>
          <target state="translated">Thread</target>
        </trans-unit>
        <trans-unit id="b66b6cbe04365929e922b75680e179e46127f3a3" translate="yes" xml:space="preserve">
          <source>Thread Safety</source>
          <target state="translated">Безопасность резьбы</target>
        </trans-unit>
        <trans-unit id="8acbe8abc881f5530528aa5ba52eb0a3d5f4e21c" translate="yes" xml:space="preserve">
          <source>Thread factory, which can be used in order to configure the properties of a new thread.</source>
          <target state="translated">Завод-изготовитель нитей,который может быть использован для настройки свойств нового потока.</target>
        </trans-unit>
        <trans-unit id="3f259cba637903dc7da0506c4d921b66c4b2c1d2" translate="yes" xml:space="preserve">
          <source>Thread with a specified name:</source>
          <target state="translated">Нить с указанным именем:</target>
        </trans-unit>
        <trans-unit id="ccd9cecfbe050ef8f7199536919145c98a9ee01e" translate="yes" xml:space="preserve">
          <source>Thread-local storage</source>
          <target state="translated">Резьбовое хранилище</target>
        </trans-unit>
        <trans-unit id="031ccc205829651d22cb916d91b65f0a8f208375" translate="yes" xml:space="preserve">
          <source>Thread::borrow</source>
          <target state="translated">Thread::borrow</target>
        </trans-unit>
        <trans-unit id="c95c792ba6b184afddca7a8e36aefd1fbf1d6ade" translate="yes" xml:space="preserve">
          <source>Thread::borrow_mut</source>
          <target state="translated">Thread::borrow_mut</target>
        </trans-unit>
        <trans-unit id="dbb6daabaec761c7c46cdca4426de7d2af20b09f" translate="yes" xml:space="preserve">
          <source>Thread::clone</source>
          <target state="translated">Thread::clone</target>
        </trans-unit>
        <trans-unit id="e27a758e7d203684411b93372f7af767f3888a92" translate="yes" xml:space="preserve">
          <source>Thread::clone_from</source>
          <target state="translated">Thread::clone_from</target>
        </trans-unit>
        <trans-unit id="21aa2dd81c0fa05128232b310f0bc9892cddef0b" translate="yes" xml:space="preserve">
          <source>Thread::clone_into</source>
          <target state="translated">Thread::clone_into</target>
        </trans-unit>
        <trans-unit id="070b95410e1e4362fb02748c2208a536c3a47c62" translate="yes" xml:space="preserve">
          <source>Thread::fmt</source>
          <target state="translated">Thread::fmt</target>
        </trans-unit>
        <trans-unit id="15bec62911f03b003cb69d406b3848ca01770f8f" translate="yes" xml:space="preserve">
          <source>Thread::from</source>
          <target state="translated">Thread::from</target>
        </trans-unit>
        <trans-unit id="4a91eeba81f613beaaf6029aae0e32dad80d38b8" translate="yes" xml:space="preserve">
          <source>Thread::id</source>
          <target state="translated">Thread::id</target>
        </trans-unit>
        <trans-unit id="b2a4ffaaac236ade773000faaa7bef3c1f0cc8f6" translate="yes" xml:space="preserve">
          <source>Thread::into</source>
          <target state="translated">Thread::into</target>
        </trans-unit>
        <trans-unit id="344f7d7a1faf3f99cb05399e695391adc35f7d18" translate="yes" xml:space="preserve">
          <source>Thread::name</source>
          <target state="translated">Thread::name</target>
        </trans-unit>
        <trans-unit id="2dcbcae4f337ba144bfa61f602dbf53a215ffbaa" translate="yes" xml:space="preserve">
          <source>Thread::to_owned</source>
          <target state="translated">Thread::to_owned</target>
        </trans-unit>
        <trans-unit id="08e8a562777dded639d27f7f44cfadcf3bf00a5e" translate="yes" xml:space="preserve">
          <source>Thread::try_from</source>
          <target state="translated">Thread::try_from</target>
        </trans-unit>
        <trans-unit id="ea003eda575d811cf577619ef02836592885180a" translate="yes" xml:space="preserve">
          <source>Thread::try_into</source>
          <target state="translated">Thread::try_into</target>
        </trans-unit>
        <trans-unit id="ee3875fc112ad5bc121f3e391fcecb3da4daa377" translate="yes" xml:space="preserve">
          <source>Thread::type_id</source>
          <target state="translated">Thread::type_id</target>
        </trans-unit>
        <trans-unit id="a2b67a0f80271fce8e8b3bd5ec25f2445ebea8c7" translate="yes" xml:space="preserve">
          <source>Thread::unpark</source>
          <target state="translated">Thread::unpark</target>
        </trans-unit>
        <trans-unit id="cd1b87b64abdd5b00fbed5a0cf0c46e8cabde3e0" translate="yes" xml:space="preserve">
          <source>ThreadId</source>
          <target state="translated">ThreadId</target>
        </trans-unit>
        <trans-unit id="e1f6247a7eef6633e4e5d83608be9b3187e0c969" translate="yes" xml:space="preserve">
          <source>ThreadId::borrow</source>
          <target state="translated">ThreadId::borrow</target>
        </trans-unit>
        <trans-unit id="22f5c0c99a3c51f5db8e51f093d172c44439f9bc" translate="yes" xml:space="preserve">
          <source>ThreadId::borrow_mut</source>
          <target state="translated">ThreadId::borrow_mut</target>
        </trans-unit>
        <trans-unit id="f272ac73f50e66007497d727840b4334ee1f128b" translate="yes" xml:space="preserve">
          <source>ThreadId::clone</source>
          <target state="translated">ThreadId::clone</target>
        </trans-unit>
        <trans-unit id="6c35d53945f00e081a8257913c3ad292495b0c89" translate="yes" xml:space="preserve">
          <source>ThreadId::clone_from</source>
          <target state="translated">ThreadId::clone_from</target>
        </trans-unit>
        <trans-unit id="9abe12a7685c82abc8d5bcbb6509a690fccefb0b" translate="yes" xml:space="preserve">
          <source>ThreadId::clone_into</source>
          <target state="translated">ThreadId::clone_into</target>
        </trans-unit>
        <trans-unit id="1fcd1d752fe2d53f1b3acff5f74fcaa56fbea5a4" translate="yes" xml:space="preserve">
          <source>ThreadId::eq</source>
          <target state="translated">ThreadId::eq</target>
        </trans-unit>
        <trans-unit id="02c70e2223708a5777dae53420e0c974498720e0" translate="yes" xml:space="preserve">
          <source>ThreadId::fmt</source>
          <target state="translated">ThreadId::fmt</target>
        </trans-unit>
        <trans-unit id="b838b903c39a24240409358be89ed6329a9df09a" translate="yes" xml:space="preserve">
          <source>ThreadId::from</source>
          <target state="translated">ThreadId::from</target>
        </trans-unit>
        <trans-unit id="ddc023441f52408bece6bf2ff774b50209750066" translate="yes" xml:space="preserve">
          <source>ThreadId::hash</source>
          <target state="translated">ThreadId::hash</target>
        </trans-unit>
        <trans-unit id="8244a05f09ebefd9016fbce0f8394db6f762584b" translate="yes" xml:space="preserve">
          <source>ThreadId::hash_slice</source>
          <target state="translated">ThreadId::hash_slice</target>
        </trans-unit>
        <trans-unit id="fd5bfcfa29d7d00b83774a3201acbc0e51fa4872" translate="yes" xml:space="preserve">
          <source>ThreadId::into</source>
          <target state="translated">ThreadId::into</target>
        </trans-unit>
        <trans-unit id="a87f4470467c3e753de867438c3b5d2edf68e527" translate="yes" xml:space="preserve">
          <source>ThreadId::ne</source>
          <target state="translated">ThreadId::ne</target>
        </trans-unit>
        <trans-unit id="3cd41ae993fc3fddaa9fb843d50a8938bb01dd02" translate="yes" xml:space="preserve">
          <source>ThreadId::to_owned</source>
          <target state="translated">ThreadId::to_owned</target>
        </trans-unit>
        <trans-unit id="c7ce06f7b4875caccd8b2ef7310bb3589387aaa7" translate="yes" xml:space="preserve">
          <source>ThreadId::try_from</source>
          <target state="translated">ThreadId::try_from</target>
        </trans-unit>
        <trans-unit id="1723d15638b0712b0610f447b496de925bf9fce1" translate="yes" xml:space="preserve">
          <source>ThreadId::try_into</source>
          <target state="translated">ThreadId::try_into</target>
        </trans-unit>
        <trans-unit id="586fd641683540c80a212ba3dd698b0a2d8e64c3" translate="yes" xml:space="preserve">
          <source>ThreadId::type_id</source>
          <target state="translated">ThreadId::type_id</target>
        </trans-unit>
        <trans-unit id="c8f829eec28b00e160b939476f6112a322b89854" translate="yes" xml:space="preserve">
          <source>Threads are able to have associated names for identification purposes. By default, spawned threads are unnamed. To specify a name for a thread, build the thread with &lt;a href=&quot;struct.builder&quot;&gt;&lt;code&gt;Builder&lt;/code&gt;&lt;/a&gt; and pass the desired thread name to &lt;a href=&quot;struct.builder#method.name&quot;&gt;&lt;code&gt;Builder::name&lt;/code&gt;&lt;/a&gt;. To retrieve the thread name from within the thread, use &lt;a href=&quot;struct.thread#method.name&quot;&gt;&lt;code&gt;Thread::name&lt;/code&gt;&lt;/a&gt;. A couple examples of where the name of a thread gets used:</source>
          <target state="translated">Потоки могут иметь связанные имена для целей идентификации. По умолчанию порожденные потоки не имеют имени. Чтобы указать имя для потока, создайте поток с помощью &lt;a href=&quot;struct.builder&quot;&gt; &lt;code&gt;Builder&lt;/code&gt; &lt;/a&gt; и передайте желаемое имя потока в &lt;a href=&quot;struct.builder#method.name&quot;&gt; &lt;code&gt;Builder::name&lt;/code&gt; &lt;/a&gt; . Чтобы получить имя потока из потока, используйте &lt;a href=&quot;struct.thread#method.name&quot;&gt; &lt;code&gt;Thread::name&lt;/code&gt; &lt;/a&gt; . Пара примеров использования имени потока:</target>
        </trans-unit>
        <trans-unit id="fac19ffa706cd7f7c61cd4298da14db7d3225341" translate="yes" xml:space="preserve">
          <source>Threads are represented via the &lt;a href=&quot;struct.thread&quot;&gt;&lt;code&gt;Thread&lt;/code&gt;&lt;/a&gt; type, which you can get in one of two ways:</source>
          <target state="translated">Потоки представлены через тип &lt;a href=&quot;struct.thread&quot;&gt; &lt;code&gt;Thread&lt;/code&gt; &lt;/a&gt; , который можно получить одним из двух способов:</target>
        </trans-unit>
        <trans-unit id="dfac2e4a30b24c7a0b51fc7ce730d2b041ad7fac" translate="yes" xml:space="preserve">
          <source>Threads are represented via the &lt;code&gt;Thread&lt;/code&gt; type, which you can get in one of two ways:</source>
          <target state="translated">Потоки представлены через тип &lt;code&gt;Thread&lt;/code&gt; , который можно получить одним из двух способов:</target>
        </trans-unit>
        <trans-unit id="61ca9f4a8a357e814dec07995e4960f9fb1789c1" translate="yes" xml:space="preserve">
          <source>Threads by default have no name specified:</source>
          <target state="translated">Нитки по умолчанию не имеют указанного имени:</target>
        </trans-unit>
        <trans-unit id="968a06f03211a8e28589507e83ecbad68bacd321" translate="yes" xml:space="preserve">
          <source>Three examples of &lt;code&gt;extern crate&lt;/code&gt; declarations:</source>
          <target state="translated">Три примера объявлений &lt;code&gt;extern crate&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="adf3f084c350f9e4e1af9b596fea76609465c5c2" translate="yes" xml:space="preserve">
          <source>Throughout the book, you&amp;rsquo;ve seen examples of many kinds of patterns. In this section, we gather all the syntax valid in patterns and discuss why you might want to use each one.</source>
          <target state="translated">На протяжении всей книги вы видели примеры самых разных шаблонов. В этом разделе мы собираем весь синтаксис, действующий в шаблонах, и обсуждаем, почему вы можете захотеть использовать каждый из них.</target>
        </trans-unit>
        <trans-unit id="60bf7601d61de03ae0783bd8d23bcd9c972360eb" translate="yes" xml:space="preserve">
          <source>Throughout the documentation, we will follow a few conventions. For all operations, the collection's size is denoted by n. If another collection is involved in the operation, it contains m elements. Operations which have an &lt;em&gt;amortized&lt;/em&gt; cost are suffixed with a &lt;code&gt;*&lt;/code&gt;. Operations with an &lt;em&gt;expected&lt;/em&gt; cost are suffixed with a &lt;code&gt;~&lt;/code&gt;.</source>
          <target state="translated">В документации мы будем придерживаться нескольких соглашений. Для всех операций размер коллекции обозначается n. Если в операции участвует другая коллекция, она содержит m элементов. Операции, имеющие &lt;em&gt;амортизированную&lt;/em&gt; стоимость , обозначаются знаком &lt;code&gt;*&lt;/code&gt; . Операции с &lt;em&gt;ожидаемой&lt;/em&gt; стоимостью помечаются суффиксом &lt;code&gt;~&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="238f30330684e8f9c133d5faa32478b32bb7092d" translate="yes" xml:space="preserve">
          <source>Throughout this book, we&amp;rsquo;ve used &lt;code&gt;let&lt;/code&gt; like this hundreds of times, and although you might not have realized it, you were using patterns! More formally, a &lt;code&gt;let&lt;/code&gt; statement looks like this:</source>
          <target state="translated">На протяжении всей книги мы использовали &lt;code&gt;let&lt;/code&gt; как это сотни раз, и хотя вы могли этого не осознавать, вы использовали шаблоны! Более формально оператор &lt;code&gt;let&lt;/code&gt; выглядит так:</target>
        </trans-unit>
        <trans-unit id="3b79edbe5b3429757c6a6c5658f9e500a2a9f5f8" translate="yes" xml:space="preserve">
          <source>Thus the pattern of &lt;code&gt;yield&lt;/code&gt;ing after a failed poll is rather common when implementing low-level shared resources or synchronization primitives.</source>
          <target state="translated">Таким образом, модель &lt;code&gt;yield&lt;/code&gt; после неудачного опроса довольно распространена при реализации низкоуровневых общих ресурсов или примитивов синхронизации.</target>
        </trans-unit>
        <trans-unit id="821dfcf79b1432754988865d9447fbfdba546e04" translate="yes" xml:space="preserve">
          <source>Thus, &lt;code&gt;ref&lt;/code&gt; is not something that is being matched against. Its objective is exclusively to make the matched binding a reference, instead of potentially copying or moving what was matched.</source>
          <target state="translated">Таким образом, &lt;code&gt;ref&lt;/code&gt; - это не то, с чем сравниваются. Его цель состоит исключительно в том, чтобы сделать сопоставленную привязку ссылкой, вместо того, чтобы потенциально копировать или перемещать сопоставленные.</target>
        </trans-unit>
        <trans-unit id="f25396ffdb747466e5fd6748ffb6e2945d105f98" translate="yes" xml:space="preserve">
          <source>Thus, a sensible way to handle a thread panic is to either:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bbe716d48d812e780f5d0c025cd7d8e8d137e139" translate="yes" xml:space="preserve">
          <source>Thus:</source>
          <target state="translated">Thus:</target>
        </trans-unit>
        <trans-unit id="667c88e4323d998577ae614b3d0f0d63105deed4" translate="yes" xml:space="preserve">
          <source>Time complexity</source>
          <target state="translated">Сложность во времени</target>
        </trans-unit>
        <trans-unit id="87e54a385b9de69cf35ac4ab359d69ed9aa1950a" translate="yes" xml:space="preserve">
          <source>To &lt;code id=&quot;to-panic-or-not-to-panic&quot;&gt;panic!&lt;/code&gt; or Not to &lt;code&gt;panic!&lt;/code&gt;</source>
          <target state="translated">Для &lt;code id=&quot;to-panic-or-not-to-panic&quot;&gt;panic!&lt;/code&gt; или не &lt;code&gt;panic!&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="6c0ba38264d0a297ae9df50179b24027837bbba6" translate="yes" xml:space="preserve">
          <source>To add &lt;code&gt;Millimeters&lt;/code&gt; and &lt;code&gt;Meters&lt;/code&gt;, we specify &lt;code&gt;impl Add&amp;lt;Meters&amp;gt;&lt;/code&gt; to set the value of the &lt;code&gt;RHS&lt;/code&gt; type parameter instead of using the default of &lt;code&gt;Self&lt;/code&gt;.</source>
          <target state="translated">Чтобы добавить &lt;code&gt;Millimeters&lt;/code&gt; и &lt;code&gt;Meters&lt;/code&gt; , мы указываем &lt;code&gt;impl Add&amp;lt;Meters&amp;gt;&lt;/code&gt; для установки значения параметра типа &lt;code&gt;RHS&lt;/code&gt; вместо использования значения по умолчанию &lt;code&gt;Self&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="cba3d2f6052bb257fd3b265e03522cd76a90182d" translate="yes" xml:space="preserve">
          <source>To add &lt;code&gt;Millimeters&lt;/code&gt; and &lt;code&gt;Meters&lt;/code&gt;, we specify &lt;code&gt;impl Add&amp;lt;Meters&amp;gt;&lt;/code&gt; to set the value of the &lt;code&gt;Rhs&lt;/code&gt; type parameter instead of using the default of &lt;code&gt;Self&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="48e27f28761495c993b1d146a55214b33393a503" translate="yes" xml:space="preserve">
          <source>To allow customization in specific cases most users won&amp;rsquo;t need</source>
          <target state="translated">Чтобы разрешить настройку в определенных случаях, большинству пользователей не понадобится</target>
        </trans-unit>
        <trans-unit id="b1d5c30e2acf4bd68628daf0a08fcdb7d03b4380" translate="yes" xml:space="preserve">
          <source>To assist with proper design, the following scenarios are explicitly declared legal for single-threaded code:</source>
          <target state="translated">Для помощи в правильном проектировании следующие сценарии однопоточного кода явным образом объявляются законными:</target>
        </trans-unit>
        <trans-unit id="3ff5f80d30f1f493faf134bdcac7192bc4fe0c89" translate="yes" xml:space="preserve">
          <source>To avoid a memory leak the pointer must be converted back to an &lt;code&gt;Arc&lt;/code&gt; using &lt;a href=&quot;struct.arc#method.from_raw&quot;&gt;&lt;code&gt;Arc::from_raw&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Чтобы избежать утечки памяти, указатель необходимо преобразовать обратно в &lt;code&gt;Arc&lt;/code&gt; с помощью &lt;a href=&quot;struct.arc#method.from_raw&quot;&gt; &lt;code&gt;Arc::from_raw&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="c1e40b418899dc58e251a0e3e3662f5034b84fa8" translate="yes" xml:space="preserve">
          <source>To avoid a memory leak the pointer must be converted back to an &lt;code&gt;Rc&lt;/code&gt; using &lt;a href=&quot;struct.rc#method.from_raw&quot;&gt;&lt;code&gt;Rc::from_raw&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Чтобы избежать утечки памяти, указатель должен быть преобразован обратно в &lt;code&gt;Rc&lt;/code&gt; с помощью &lt;a href=&quot;struct.rc#method.from_raw&quot;&gt; &lt;code&gt;Rc::from_raw&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="4a5ee855a608ecd864fa2e7b73853f23dfbb067b" translate="yes" xml:space="preserve">
          <source>To avoid creating &lt;code&gt;&amp;amp;mut [T]&lt;/code&gt; references that alias, the returned slice borrows its lifetime from the iterator the method is applied on.</source>
          <target state="translated">Чтобы избежать создания ссылок &lt;code&gt;&amp;amp;mut [T]&lt;/code&gt; на этот псевдоним, возвращаемый фрагмент заимствует свое время жизни у итератора, к которому применяется метод.</target>
        </trans-unit>
        <trans-unit id="ffa0cd99296c4663ce93793ddad7c9407847a5e2" translate="yes" xml:space="preserve">
          <source>To avoid creating &lt;code&gt;&amp;amp;mut&lt;/code&gt; references that alias, this is forced to consume the iterator.</source>
          <target state="translated">Чтобы избежать создания ссылок &lt;code&gt;&amp;amp;mut&lt;/code&gt; на этот псевдоним, он вынужден использовать итератор.</target>
        </trans-unit>
        <trans-unit id="1aefc821eaa401be8625ea8100fecfc992fdeed8" translate="yes" xml:space="preserve">
          <source>To avoid having &lt;code&gt;common&lt;/code&gt; appear in the test output, instead of creating &lt;em&gt;tests/common.rs&lt;/em&gt;, we&amp;rsquo;ll create &lt;em&gt;tests/common/mod.rs&lt;/em&gt;. This is an alternate naming convention that Rust also understands. Naming the file this way tells Rust not to treat the &lt;code&gt;common&lt;/code&gt; module as an integration test file. When we move the &lt;code&gt;setup&lt;/code&gt; function code into &lt;em&gt;tests/common/mod.rs&lt;/em&gt; and delete the &lt;em&gt;tests/common.rs&lt;/em&gt; file, the section in the test output will no longer appear. Files in subdirectories of the &lt;em&gt;tests&lt;/em&gt; directory don&amp;rsquo;t get compiled as separate crates or have sections in the test output.</source>
          <target state="translated">Для того, чтобы избежать &lt;code&gt;common&lt;/code&gt; в выводе теста, вместо того чтобы создавать &lt;em&gt;тесты / common.rs&lt;/em&gt; , мы будем создавать &lt;em&gt;тесты / Common / mod.rs&lt;/em&gt; . Это альтернативное соглашение об именах, которое также понимает Rust. Такое имя файла говорит Rust не рассматривать &lt;code&gt;common&lt;/code&gt; модуль как тестовый файл интеграции. Когда мы перемещаем код функции &lt;code&gt;setup&lt;/code&gt; в &lt;em&gt;tests / common / mod.rs&lt;/em&gt; и удаляем файл &lt;em&gt;tests / common.rs&lt;/em&gt; , раздел в выходных данных теста больше не появляется. Файлы в подкаталогах каталога &lt;em&gt;тестов&lt;/em&gt; не компилируются как отдельные ящики и не имеют разделов в выходных данных теста.</target>
        </trans-unit>
        <trans-unit id="3621c2a13fc7da454e2221c729cf687e93b1bda8" translate="yes" xml:space="preserve">
          <source>To avoid it, you have to replace the non-constant value:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ea7a1a1787370230342d01e7d26cc5eb0fdaf231" translate="yes" xml:space="preserve">
          <source>To avoid the error there are a couple of options.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1645dd8754fa06f0f760253ea0a8f05162d861bf" translate="yes" xml:space="preserve">
          <source>To avoid this error, first bind the temporary to a named local variable:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="97ceede3cc5738536ea015edb67ed85c3d3dcd2e" translate="yes" xml:space="preserve">
          <source>To avoid this error, you have to keep only one of them and remove the others. So let's take our example and fix it:</source>
          <target state="translated">Чтобы избежать этой ошибки,необходимо оставить только одну из них и удалить остальные.Так что давайте возьмем наш пример и исправим его:</target>
        </trans-unit>
        <trans-unit id="a30b99a191595831b8cb7e0383bc895012a3666a" translate="yes" xml:space="preserve">
          <source>To avoid this kind of error, ensure that at least one local type is referenced by the &lt;code&gt;impl&lt;/code&gt;:</source>
          <target state="translated">Чтобы избежать такого рода ошибок, убедитесь, что по крайней мере на один локальный тип ссылается &lt;code&gt;impl&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="a83579bf275c61511e259b0f6a5393712638d88c" translate="yes" xml:space="preserve">
          <source>To avoid those issues, you have to make the types match correctly. So we can fix the previous examples like this:</source>
          <target state="translated">Чтобы избежать этих проблем,необходимо сделать так,чтобы типы соответствовали друг другу.Таким образом,мы можем исправить предыдущие примеры:</target>
        </trans-unit>
        <trans-unit id="8cca79e59af2d0e450f9f7893d8b74973a17a0c1" translate="yes" xml:space="preserve">
          <source>To be able to index into a type it needs to implement the &lt;code&gt;std::ops::Index&lt;/code&gt; trait. Example:</source>
          <target state="translated">Чтобы иметь возможность индексировать в тип, необходимо реализовать черту &lt;code&gt;std::ops::Index&lt;/code&gt; . Пример:</target>
        </trans-unit>
        <trans-unit id="e0c4569eca23f12e74ce8e43ea0b16ae30221104" translate="yes" xml:space="preserve">
          <source>To be clear: most features will be available on all editions. Developers using any Rust edition will continue to see improvements as new stable releases are made. However, in some cases, mainly when new keywords are added, some new features might only be available in later editions. You will need to switch editions if you want to take advantage of such features.</source>
          <target state="translated">Чтобы было понятно:большинство функций будет доступно во всех редакциях.Разработчики,использующие любую версию Rust,будут продолжать видеть улучшения по мере выпуска новых стабильных релизов.Однако в некоторых случаях,в основном при добавлении новых ключевых слов,некоторые новые возможности могут быть доступны только в более поздних редакциях.Если вы хотите воспользоваться такими возможностями,вам нужно будет поменять редакции.</target>
        </trans-unit>
        <trans-unit id="28519d7825ab9ef768276a220fcc5248c6cfd08d" translate="yes" xml:space="preserve">
          <source>To be valid, a matcher must meet the following three invariants. The definitions of FIRST and FOLLOW are described later.</source>
          <target state="translated">Чтобы быть действительным,матчер должен соответствовать следующим трем инвариантам.Определения ПЕРВЫЙ и ПЕРВЫЙ описаны ниже.</target>
        </trans-unit>
        <trans-unit id="4dcb6216e57dabede5c512636b8402fc6577f67d" translate="yes" xml:space="preserve">
          <source>To better understand how these work in Rust, read the &lt;a href=&quot;book/ch13-01-closures&quot;&gt;Closures&lt;/a&gt; chapter of the Book.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d27f02149ea4da378573490ec467ba6b8b5c842f" translate="yes" xml:space="preserve">
          <source>To better understand why we need two separate loops, imagine a scenario with two workers. If we used a single loop to iterate through each worker, on the first iteration a terminate message would be sent down the channel and &lt;code&gt;join&lt;/code&gt; called on the first worker&amp;rsquo;s thread. If that first worker was busy processing a request at that moment, the second worker would pick up the terminate message from the channel and shut down. We would be left waiting on the first worker to shut down, but it never would because the second thread picked up the terminate message. Deadlock!</source>
          <target state="translated">Чтобы лучше понять, зачем нам нужны два отдельных цикла, представьте сценарий с двумя рабочими. Если бы мы использовали один цикл для итерации каждого рабочего потока , на первой итерации сообщение о завершении было бы отправлено по каналу, и &lt;code&gt;join&lt;/code&gt; вызвало бы первый рабочий поток. Если этот первый рабочий процесс был занят обработкой запроса в тот момент, второй рабочий забрал бы сообщение о завершении из канала и отключился. Нам оставалось бы ждать, пока завершится первый рабочий процесс, но этого не произойдет, потому что второй поток принял сообщение о завершении. Тупик!</target>
        </trans-unit>
        <trans-unit id="a92bd1b796549d070a95e516f74d8da028284983" translate="yes" xml:space="preserve">
          <source>To bind the matched value of a pattern to a variable, use the syntax &lt;code&gt;variable @ subpattern&lt;/code&gt;. For example, the following binds the value 2 to &lt;code&gt;e&lt;/code&gt; (not the entire range: the range here is a range subpattern).</source>
          <target state="translated">Чтобы привязать совпадающее значение шаблона к переменной, используйте синтаксис &lt;code&gt;variable @ subpattern&lt;/code&gt; . Например, следующее связывает значение 2 с &lt;code&gt;e&lt;/code&gt; (не весь диапазон: диапазон здесь является подшаблоном диапазона).</target>
        </trans-unit>
        <trans-unit id="b830c9413c38579d4ef7795bcf7bbde269208939" translate="yes" xml:space="preserve">
          <source>To build or modify paths, use &lt;a href=&quot;struct.pathbuf&quot;&gt;&lt;code&gt;PathBuf&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">Для создания или изменения путей используйте &lt;a href=&quot;struct.pathbuf&quot;&gt; &lt;code&gt;PathBuf&lt;/code&gt; &lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="bfa1e223892bc7e4bd4f7e711edfd1f7972be85d" translate="yes" xml:space="preserve">
          <source>To calculate the layout of a &lt;code&gt;#[repr(C)]&lt;/code&gt; structure and the offsets of the fields from its fields' layouts:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a716f5c06d1b56904d9c9ecdfaef8a89e71a7435" translate="yes" xml:space="preserve">
          <source>To calculate the value of &lt;code&gt;prediction&lt;/code&gt;, this code iterates through each of the 12 values in &lt;code&gt;coefficients&lt;/code&gt; and uses the &lt;code&gt;zip&lt;/code&gt; method to pair the coefficient values with the previous 12 values in &lt;code&gt;buffer&lt;/code&gt;. Then, for each pair, we multiply the values together, sum all the results, and shift the bits in the sum &lt;code&gt;qlp_shift&lt;/code&gt; bits to the right.</source>
          <target state="translated">Чтобы вычислить значение &lt;code&gt;prediction&lt;/code&gt; , этот код выполняет итерацию по каждому из 12 значений в &lt;code&gt;coefficients&lt;/code&gt; и использует метод &lt;code&gt;zip&lt;/code&gt; для объединения значений коэффициента с предыдущими 12 значениями в &lt;code&gt;buffer&lt;/code&gt; . Затем для каждой пары мы умножаем значения вместе, суммируем все результаты и сдвигаем биты в сумме &lt;code&gt;qlp_shift&lt;/code&gt; битов вправо.</target>
        </trans-unit>
        <trans-unit id="e1e36c60ac0b0cf3c0b11863470e32d28a059d98" translate="yes" xml:space="preserve">
          <source>To call the &lt;code&gt;fly&lt;/code&gt; methods from either the &lt;code&gt;Pilot&lt;/code&gt; trait or the &lt;code&gt;Wizard&lt;/code&gt; trait, we need to use more explicit syntax to specify which &lt;code&gt;fly&lt;/code&gt; method we mean. Listing 19-18 demonstrates this syntax.</source>
          <target state="translated">Чтобы вызвать методы &lt;code&gt;fly&lt;/code&gt; из черты &lt;code&gt;Pilot&lt;/code&gt; или &lt;code&gt;Wizard&lt;/code&gt; , нам нужно использовать более явный синтаксис, чтобы указать, какой метод &lt;code&gt;fly&lt;/code&gt; мы имеем в виду. Перечисление 19-18 демонстрирует этот синтаксис.</target>
        </trans-unit>
        <trans-unit id="5c07c5eaca75954c044b220e0d9378c6ce45b1a4" translate="yes" xml:space="preserve">
          <source>To call this associated function, we use the &lt;code&gt;::&lt;/code&gt; syntax with the struct name; &lt;code&gt;let sq = Rectangle::square(3);&lt;/code&gt; is an example. This function is namespaced by the struct: the &lt;code&gt;::&lt;/code&gt; syntax is used for both associated functions and namespaces created by modules. We&amp;rsquo;ll discuss modules in Chapter 7.</source>
          <target state="translated">Чтобы вызвать эту связанную функцию, мы используем синтаксис &lt;code&gt;::&lt;/code&gt; с именем структуры; &lt;code&gt;let sq = Rectangle::square(3);&lt;/code&gt; это пример. Пространство имен этой функции определяется структурой: синтаксис &lt;code&gt;::&lt;/code&gt; используется как для связанных функций, так и для пространств имен, созданных модулями. Мы обсудим модули в главе 7.</target>
        </trans-unit>
        <trans-unit id="191c93d8beeacd6897f106d1c47af3f257c7dd5f" translate="yes" xml:space="preserve">
          <source>To call this code with only those types that implement the &lt;code&gt;Copy&lt;/code&gt; trait, we can add &lt;code&gt;Copy&lt;/code&gt; to the trait bounds of &lt;code&gt;T&lt;/code&gt;! Listing 10-15 shows the complete code of a generic &lt;code&gt;largest&lt;/code&gt; function that will compile as long as the types of the values in the slice that we pass into the function implement the &lt;code&gt;PartialOrd&lt;/code&gt;&lt;em&gt;and&lt;/em&gt;&lt;code&gt;Copy&lt;/code&gt; traits, like &lt;code&gt;i32&lt;/code&gt; and &lt;code&gt;char&lt;/code&gt; do.</source>
          <target state="translated">Чтобы вызвать этот код только с теми типами, которые реализуют трейт &lt;code&gt;Copy&lt;/code&gt; , мы можем добавить &lt;code&gt;Copy&lt;/code&gt; к границам трейта &lt;code&gt;T&lt;/code&gt; ! В листинге 10-15 показан полный код универсальной &lt;code&gt;largest&lt;/code&gt; функции, которая будет компилироваться до тех пор, пока типы значений в срезе, который мы передаем в функцию, реализуют черты &lt;code&gt;PartialOrd&lt;/code&gt; &lt;em&gt;и &lt;/em&gt; &lt;code&gt;Copy&lt;/code&gt; , как это &lt;code&gt;i32&lt;/code&gt; и &lt;code&gt;char&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2ae7caef9479d77c77a3d3a0a7f430defd27a454" translate="yes" xml:space="preserve">
          <source>To change the value that the mutable reference refers to, we have to use the dereference operator (&lt;code&gt;*&lt;/code&gt;) to get to the value in &lt;code&gt;i&lt;/code&gt; before we can use the &lt;code&gt;+=&lt;/code&gt; operator. We&amp;rsquo;ll talk more about the dereference operator in the &lt;a href=&quot;ch15-02-deref#following-the-pointer-to-the-value-with-the-dereference-operator&quot;&gt;&amp;ldquo;Following the Pointer to the Value with the Dereference Operator&amp;rdquo;&lt;/a&gt; section of Chapter 15.</source>
          <target state="translated">Чтобы изменить значение, на которое ссылается изменяемая ссылка, мы должны использовать оператор разыменования ( &lt;code&gt;*&lt;/code&gt; ), чтобы получить значение в &lt;code&gt;i&lt;/code&gt; , прежде чем мы сможем использовать оператор &lt;code&gt;+=&lt;/code&gt; . Подробнее об операторе разыменования мы поговорим в разделе &lt;a href=&quot;ch15-02-deref#following-the-pointer-to-the-value-with-the-dereference-operator&quot;&gt;&amp;laquo;Следование указателю на значение с помощью оператора разыменования&amp;raquo;&lt;/a&gt; главы 15.</target>
        </trans-unit>
        <trans-unit id="ff93ea5d521caed491ca6edf931b71effa3ca726" translate="yes" xml:space="preserve">
          <source>To check whether you have Rust installed correctly, open a shell and enter this line:</source>
          <target state="translated">Чтобы проверить,правильно ли установлен Rust,откройте оболочку и введите эту строку:</target>
        </trans-unit>
        <trans-unit id="b81a5a29868dab97f44f48c2bd716ec3edc16d7e" translate="yes" xml:space="preserve">
          <source>To combine &lt;code&gt;repr(transparent)&lt;/code&gt; with type parameters, &lt;code&gt;PhantomData&lt;/code&gt; may be useful:</source>
          <target state="translated">Чтобы объединить &lt;code&gt;repr(transparent)&lt;/code&gt; с параметрами типа, &lt;code&gt;PhantomData&lt;/code&gt; может быть полезен:</target>
        </trans-unit>
        <trans-unit id="ac3f03b22205947cc54e2019b2f0993969841a80" translate="yes" xml:space="preserve">
          <source>To confuse things further, &lt;a href=&quot;https://encoding.spec.whatwg.org/&quot;&gt;on the Web&lt;/a&gt;&lt;code&gt;ascii&lt;/code&gt;, &lt;code&gt;iso-8859-1&lt;/code&gt;, and &lt;code&gt;windows-1252&lt;/code&gt; are all aliases for a superset of Windows-1252 that fills the remaining blanks with corresponding C0 and C1 control codes.</source>
          <target state="translated">Чтобы еще больше запутать ситуацию, &lt;a href=&quot;https://encoding.spec.whatwg.org/&quot;&gt;в Интернете &lt;/a&gt; &lt;code&gt;ascii&lt;/code&gt; , &lt;code&gt;iso-8859-1&lt;/code&gt; и &lt;code&gt;windows-1252&lt;/code&gt; - это псевдонимы для расширенного набора Windows-1252, который заполняет оставшиеся пробелы соответствующими управляющими кодами C0 и C1.</target>
        </trans-unit>
        <trans-unit id="9e961e97b1bab5bb4d05da5fe7c2fc74357a8b93" translate="yes" xml:space="preserve">
          <source>To consume the old state, the &lt;code&gt;request_review&lt;/code&gt; method needs to take ownership of the state value. This is where the &lt;code&gt;Option&lt;/code&gt; in the &lt;code&gt;state&lt;/code&gt; field of &lt;code&gt;Post&lt;/code&gt; comes in: we call the &lt;code&gt;take&lt;/code&gt; method to take the &lt;code&gt;Some&lt;/code&gt; value out of the &lt;code&gt;state&lt;/code&gt; field and leave a &lt;code&gt;None&lt;/code&gt; in its place, because Rust doesn&amp;rsquo;t let us have unpopulated fields in structs. This lets us move the &lt;code&gt;state&lt;/code&gt; value out of &lt;code&gt;Post&lt;/code&gt; rather than borrowing it. Then we&amp;rsquo;ll set the post&amp;rsquo;s &lt;code&gt;state&lt;/code&gt; value to the result of this operation.</source>
          <target state="translated">Чтобы использовать старое состояние, метод &lt;code&gt;request_review&lt;/code&gt; должен стать владельцем значения состояния. Это где &lt;code&gt;Option&lt;/code&gt; в &lt;code&gt;state&lt;/code&gt; сфере &lt;code&gt;Post&lt;/code&gt; приходит в: мы называем &lt;code&gt;take&lt;/code&gt; метод принять &lt;code&gt;Some&lt;/code&gt; значения из &lt;code&gt;state&lt;/code&gt; поля и не оставить &lt;code&gt;None&lt;/code&gt; в своем месте, потому что ржавчина не давайте безлюдные поля в структурах. Это позволяет нам вынести значение &lt;code&gt;state&lt;/code&gt; из &lt;code&gt;Post&lt;/code&gt; , а не заимствовать его. Затем мы установим значение &lt;code&gt;state&lt;/code&gt; поста на результат этой операции.</target>
        </trans-unit>
        <trans-unit id="f337e083c37a19b6c9f78383e9d486a4274f1380" translate="yes" xml:space="preserve">
          <source>To control whether interfaces can be used across modules, Rust checks each use of an item to see whether it should be allowed or not. This is where privacy warnings are generated, or otherwise &quot;you used a private item of another module and weren't allowed to.&quot;</source>
          <target state="translated">Чтобы контролировать,могут ли интерфейсы использоваться между модулями,Rust проверяет каждое использование элемента,чтобы определить,должен ли он быть разрешен или нет.В этом случае выдаются предупреждения о конфиденциальности,или иным образом &quot;вы использовали личный элемент другого модуля и не были разрешены&quot;.</target>
        </trans-unit>
        <trans-unit id="ba21f5abea5c571067a1a7d57de3d3aa5bc54641" translate="yes" xml:space="preserve">
          <source>To convert a single value to a string, use the &lt;a href=&quot;../string/trait.tostring&quot;&gt;&lt;code&gt;to_string&lt;/code&gt;&lt;/a&gt; method. This will use the &lt;a href=&quot;trait.display&quot;&gt;&lt;code&gt;Display&lt;/code&gt;&lt;/a&gt; formatting trait.</source>
          <target state="translated">Чтобы преобразовать одиночное значение в строку, используйте метод &lt;a href=&quot;../string/trait.tostring&quot;&gt; &lt;code&gt;to_string&lt;/code&gt; &lt;/a&gt; . Это будет использовать свойство форматирования &lt;a href=&quot;trait.display&quot;&gt; &lt;code&gt;Display&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="3cb338cb9ed195af952f18624a8d65c1ca64787f" translate="yes" xml:space="preserve">
          <source>To convert a single value to a string, use the &lt;a href=&quot;string/trait.tostring&quot;&gt;&lt;code&gt;to_string&lt;/code&gt;&lt;/a&gt; method. This will use the &lt;a href=&quot;fmt/trait.display&quot;&gt;&lt;code&gt;Display&lt;/code&gt;&lt;/a&gt; formatting trait.</source>
          <target state="translated">Чтобы преобразовать одиночное значение в строку, используйте метод &lt;a href=&quot;string/trait.tostring&quot;&gt; &lt;code&gt;to_string&lt;/code&gt; &lt;/a&gt; . Это будет использовать свойство форматирования &lt;a href=&quot;fmt/trait.display&quot;&gt; &lt;code&gt;Display&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="015234ea3f6220712aedf5ea26711d734042f76e" translate="yes" xml:space="preserve">
          <source>To create a &lt;code&gt;match&lt;/code&gt; expression that compares the values of the outer &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt;, rather than introducing a shadowed variable, we would need to use a match guard conditional instead. We&amp;rsquo;ll talk about match guards later in the &lt;a href=&quot;#extra-conditionals-with-match-guards&quot;&gt;&amp;ldquo;Extra Conditionals with Match Guards&amp;rdquo;&lt;/a&gt; section.</source>
          <target state="translated">Для создания &lt;code&gt;match&lt;/code&gt; выражения , которое сравнивает значения внешних &lt;code&gt;x&lt;/code&gt; и &lt;code&gt;y&lt;/code&gt; , а не вводить затененную переменный, мы должны были бы использовать спички сторожевой Условные вместо этого. Мы поговорим об охранниках матча позже в разделе &lt;a href=&quot;#extra-conditionals-with-match-guards&quot;&gt;&amp;laquo;Дополнительные условия с охранниками матча&amp;raquo;&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="d6a361bf034a44065bf4d983adf9bd5159e505a7" translate="yes" xml:space="preserve">
          <source>To create a new thread, we call the &lt;code&gt;thread::spawn&lt;/code&gt; function and pass it a closure (we talked about closures in Chapter 13) containing the code we want to run in the new thread. The example in Listing 16-1 prints some text from a main thread and other text from a new thread:</source>
          <target state="translated">Чтобы создать новый поток, мы вызываем функцию &lt;code&gt;thread::spawn&lt;/code&gt; и передаем ей замыкание (о замыканиях мы говорили в главе 13), содержащее код, который мы хотим запустить в новом потоке. Пример в листинге 16-1 печатает некоторый текст из основного потока и другой текст из нового потока:</target>
        </trans-unit>
        <trans-unit id="aa89b2295fcdc6f9c080aa3a4a8e8468c77980e1" translate="yes" xml:space="preserve">
          <source>To create a new, empty vector, we can call the &lt;code&gt;Vec::new&lt;/code&gt; function, as shown in Listing 8-1.</source>
          <target state="translated">Чтобы создать новый пустой вектор, мы можем вызвать функцию &lt;code&gt;Vec::new&lt;/code&gt; , как показано в Листинге 8-1.</target>
        </trans-unit>
        <trans-unit id="1a88aa76c7ad4f90214c55053637e980f11dd3a9" translate="yes" xml:space="preserve">
          <source>To create a vector and then add elements to it, we can use the &lt;code&gt;push&lt;/code&gt; method, as shown in Listing 8-3.</source>
          <target state="translated">Чтобы создать вектор и затем добавить к нему элементы, мы можем использовать метод &lt;code&gt;push&lt;/code&gt; , как показано в Листинге 8-3.</target>
        </trans-unit>
        <trans-unit id="00c0015adacecd8350d6133979871ae1b1edfe94" translate="yes" xml:space="preserve">
          <source>To define a &lt;code&gt;Point&lt;/code&gt; struct where &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; are both generics but could have different types, we can use multiple generic type parameters. For example, in Listing 10-8, we can change the definition of &lt;code&gt;Point&lt;/code&gt; to be generic over types &lt;code&gt;T&lt;/code&gt; and &lt;code&gt;U&lt;/code&gt; where &lt;code&gt;x&lt;/code&gt; is of type &lt;code&gt;T&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; is of type &lt;code&gt;U&lt;/code&gt;.</source>
          <target state="translated">Чтобы определить структуру &lt;code&gt;Point&lt;/code&gt; , где &lt;code&gt;x&lt;/code&gt; и &lt;code&gt;y&lt;/code&gt; являются универсальными, но могут иметь разные типы, мы можем использовать несколько параметров универсального типа. Например, в листинге 10-8, мы можем изменить определение &lt;code&gt;Point&lt;/code&gt; , чтобы быть универсальным над типами &lt;code&gt;T&lt;/code&gt; и &lt;code&gt;U&lt;/code&gt; , где &lt;code&gt;x&lt;/code&gt; имеет тип &lt;code&gt;T&lt;/code&gt; и &lt;code&gt;y&lt;/code&gt; имеет тип &lt;code&gt;U&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="48e3d6adfbf70e45f3b29de0115bced82f45c8ba" translate="yes" xml:space="preserve">
          <source>To define a macro, you use the &lt;code&gt;macro_rules!&lt;/code&gt; construct. Let&amp;rsquo;s explore how to use &lt;code&gt;macro_rules!&lt;/code&gt; by looking at how the &lt;code&gt;vec!&lt;/code&gt; macro is defined. Chapter 8 covered how we can use the &lt;code&gt;vec!&lt;/code&gt; macro to create a new vector with particular values. For example, the following macro creates a new vector containing three integers:</source>
          <target state="translated">Чтобы определить макрос, вы используете &lt;code&gt;macro_rules!&lt;/code&gt; построить. Давайте посмотрим, как использовать &lt;code&gt;macro_rules!&lt;/code&gt; посмотрев, как работает &lt;code&gt;vec!&lt;/code&gt; макрос определен. В главе 8 рассказывается, как мы можем использовать &lt;code&gt;vec!&lt;/code&gt; макрос для создания нового вектора с определенными значениями. Например, следующий макрос создает новый вектор, содержащий три целых числа:</target>
        </trans-unit>
        <trans-unit id="0305c11d131bdcb2f62d25c1e047d31c7b279a29" translate="yes" xml:space="preserve">
          <source>To define a struct, we enter the keyword &lt;code&gt;struct&lt;/code&gt; and name the entire struct. A struct&amp;rsquo;s name should describe the significance of the pieces of data being grouped together. Then, inside curly brackets, we define the names and types of the pieces of data, which we call &lt;em&gt;fields&lt;/em&gt;. For example, Listing 5-1 shows a struct that stores information about a user account.</source>
          <target state="translated">Чтобы определить структуру, мы вводим ключевое слово &lt;code&gt;struct&lt;/code&gt; и называем всю структуру. Имя структуры должно описывать значимость группируемых частей данных. Затем в фигурных скобках мы определяем имена и типы фрагментов данных, которые мы называем &lt;em&gt;полями&lt;/em&gt; . Например, в листинге 5-1 показана структура, в которой хранится информация об учетной записи пользователя.</target>
        </trans-unit>
        <trans-unit id="8f9b83d2cc8d6fc88b967504ac913c99c3032360" translate="yes" xml:space="preserve">
          <source>To define a tuple struct, start with the &lt;code&gt;struct&lt;/code&gt; keyword and the struct name followed by the types in the tuple. For example, here are definitions and usages of two tuple structs named &lt;code&gt;Color&lt;/code&gt; and &lt;code&gt;Point&lt;/code&gt;:</source>
          <target state="translated">Чтобы определить структуру кортежа, начните с ключевого слова &lt;code&gt;struct&lt;/code&gt; и имени структуры, за которыми следуют типы в кортеже. Например, вот определения и использование двух структур кортежей с именами &lt;code&gt;Color&lt;/code&gt; и &lt;code&gt;Point&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="bf22e9ab26d9ba6ee6b2e46fe0b19d5124fc0343" translate="yes" xml:space="preserve">
          <source>To define the function within the context of &lt;code&gt;Rectangle&lt;/code&gt;, we start an &lt;code&gt;impl&lt;/code&gt; (implementation) block. Then we move the &lt;code&gt;area&lt;/code&gt; function within the &lt;code&gt;impl&lt;/code&gt; curly brackets and change the first (and in this case, only) parameter to be &lt;code&gt;self&lt;/code&gt; in the signature and everywhere within the body. In &lt;code&gt;main&lt;/code&gt;, where we called the &lt;code&gt;area&lt;/code&gt; function and passed &lt;code&gt;rect1&lt;/code&gt; as an argument, we can instead use &lt;em&gt;method syntax&lt;/em&gt; to call the &lt;code&gt;area&lt;/code&gt; method on our &lt;code&gt;Rectangle&lt;/code&gt; instance. The method syntax goes after an instance: we add a dot followed by the method name, parentheses, and any arguments.</source>
          <target state="translated">Чтобы определить функцию в контексте &lt;code&gt;Rectangle&lt;/code&gt; , мы запускаем блок &lt;code&gt;impl&lt;/code&gt; (реализация). Затем мы перемещаем функцию &lt;code&gt;area&lt;/code&gt; в &lt;code&gt;impl&lt;/code&gt; фигурные скобки и меняем первый (и в данном случае единственный) параметр на &lt;code&gt;self&lt;/code&gt; в подписи и везде в теле. В &lt;code&gt;main&lt;/code&gt; , где мы вызвали функцию &lt;code&gt;area&lt;/code&gt; и передали &lt;code&gt;rect1&lt;/code&gt; в качестве аргумента, вместо этого мы можем использовать &lt;em&gt;синтаксис метода&lt;/em&gt; для вызова метода &lt;code&gt;area&lt;/code&gt; в нашем экземпляре &lt;code&gt;Rectangle&lt;/code&gt; . Синтаксис метода идет после экземпляра: мы добавляем точку, за которой следует имя метода, круглые скобки и любые аргументы.</target>
        </trans-unit>
        <trans-unit id="2de6b544c44b76668f6d2936d8d501f7f9f3abad" translate="yes" xml:space="preserve">
          <source>To demonstrate how to run a subset of tests, we&amp;rsquo;ll create three tests for our &lt;code&gt;add_two&lt;/code&gt; function, as shown in Listing 11-11, and choose which ones to run.</source>
          <target state="translated">Чтобы продемонстрировать, как запускать подмножество тестов, мы создадим три теста для нашей функции &lt;code&gt;add_two&lt;/code&gt; , как показано в листинге 11-11, и выберем, какие из них запускать.</target>
        </trans-unit>
        <trans-unit id="e75dc3dfe6b153a0ceea282766b5c4d1615452e1" translate="yes" xml:space="preserve">
          <source>To demonstrate, let&amp;rsquo;s create an iterator that will only ever count from 1 to 5. First, we&amp;rsquo;ll create a struct to hold some values. Then we&amp;rsquo;ll make this struct into an iterator by implementing the &lt;code&gt;Iterator&lt;/code&gt; trait and using the values in that implementation.</source>
          <target state="translated">Для демонстрации давайте создадим итератор, который будет считать только от 1 до 5. Сначала мы создадим структуру для хранения некоторых значений. Затем мы превратим эту структуру в итератор, реализуя черту &lt;code&gt;Iterator&lt;/code&gt; и используя значения в этой реализации.</target>
        </trans-unit>
        <trans-unit id="b6b548838142d67d34f12bfbc64f7cdb12a47cc6" translate="yes" xml:space="preserve">
          <source>To determine how much space to allocate for a &lt;code&gt;Message&lt;/code&gt; value, Rust goes through each of the variants to see which variant needs the most space. Rust sees that &lt;code&gt;Message::Quit&lt;/code&gt; doesn&amp;rsquo;t need any space, &lt;code&gt;Message::Move&lt;/code&gt; needs enough space to store two &lt;code&gt;i32&lt;/code&gt; values, and so forth. Because only one variant will be used, the most space a &lt;code&gt;Message&lt;/code&gt; value will need is the space it would take to store the largest of its variants.</source>
          <target state="translated">Чтобы определить, сколько места выделить для значения &lt;code&gt;Message&lt;/code&gt; , Rust просматривает каждый из вариантов, чтобы увидеть, какой вариант требует больше всего места. Rust видит, что &lt;code&gt;Message::Quit&lt;/code&gt; не требует места, &lt;code&gt;Message::Move&lt;/code&gt; нужно достаточно места для хранения двух значений &lt;code&gt;i32&lt;/code&gt; и так далее. Поскольку будет использоваться только один вариант, наибольшее пространство, которое потребуется значению &lt;code&gt;Message&lt;/code&gt; , - это пространство, которое потребуется для хранения самого большого из его вариантов.</target>
        </trans-unit>
        <trans-unit id="375df8edff8c14a24952e9e1d54e255a42b357a9" translate="yes" xml:space="preserve">
          <source>To determine if a &lt;code&gt;T&lt;/code&gt; is &lt;code&gt;Foo&lt;/code&gt;, we need to check if &lt;code&gt;Bar&amp;lt;T&amp;gt;&lt;/code&gt; is &lt;code&gt;Foo&lt;/code&gt;. However, to do this check, we need to determine that &lt;code&gt;Bar&amp;lt;Bar&amp;lt;T&amp;gt;&amp;gt;&lt;/code&gt; is &lt;code&gt;Foo&lt;/code&gt;. To determine this, we check if &lt;code&gt;Bar&amp;lt;Bar&amp;lt;Bar&amp;lt;T&amp;gt;&amp;gt;&amp;gt;&lt;/code&gt; is &lt;code&gt;Foo&lt;/code&gt;, and so on. This is clearly a recursive requirement that can't be resolved directly.</source>
          <target state="translated">Для того, чтобы определить , является ли &lt;code&gt;T&lt;/code&gt; является &lt;code&gt;Foo&lt;/code&gt; , нам нужно проверить , если &lt;code&gt;Bar&amp;lt;T&amp;gt;&lt;/code&gt; является &lt;code&gt;Foo&lt;/code&gt; . Однако для выполнения этой проверки нам нужно определить, что &lt;code&gt;Bar&amp;lt;Bar&amp;lt;T&amp;gt;&amp;gt;&lt;/code&gt; имеет значение &lt;code&gt;Foo&lt;/code&gt; . Чтобы определить это, мы проверяем , если &lt;code&gt;Bar&amp;lt;Bar&amp;lt;Bar&amp;lt;T&amp;gt;&amp;gt;&amp;gt;&lt;/code&gt; является &lt;code&gt;Foo&lt;/code&gt; , и так далее. Это явно рекурсивное требование, которое нельзя решить напрямую.</target>
        </trans-unit>
        <trans-unit id="b8666f35753eb530d957bee0ef54848c41571aca" translate="yes" xml:space="preserve">
          <source>To determine the total number of seconds represented by the &lt;code&gt;Duration&lt;/code&gt;, use &lt;code&gt;as_secs&lt;/code&gt; in combination with &lt;a href=&quot;#method.subsec_nanos&quot;&gt;&lt;code&gt;subsec_nanos&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">Чтобы определить общее количество секунд, представленное &lt;code&gt;Duration&lt;/code&gt; , используйте &lt;code&gt;as_secs&lt;/code&gt; в сочетании с &lt;a href=&quot;#method.subsec_nanos&quot;&gt; &lt;code&gt;subsec_nanos&lt;/code&gt; &lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="08d2c31864b299072e74b4018700dfb17575ecb3" translate="yes" xml:space="preserve">
          <source>To determine the total number of seconds represented by the &lt;code&gt;Duration&lt;/code&gt;, use &lt;code&gt;as_secs&lt;/code&gt; in combination with &lt;a href=&quot;struct.duration#method.subsec_nanos&quot;&gt;&lt;code&gt;subsec_nanos&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1c73fc588227a5e5b304d8e85115a9b2d547b13e" translate="yes" xml:space="preserve">
          <source>To determine whether to use loops or iterators, you need to know which version of our &lt;code&gt;search&lt;/code&gt; functions is faster: the version with an explicit &lt;code&gt;for&lt;/code&gt; loop or the version with iterators.</source>
          <target state="translated">Чтобы определить, использовать ли циклы или итераторы, вам необходимо знать, какая версия наших функций &lt;code&gt;search&lt;/code&gt; работает быстрее: версия с явным циклом &lt;code&gt;for&lt;/code&gt; или версия с итераторами.</target>
        </trans-unit>
        <trans-unit id="235f6ddc8fb93b9bc27bd450e93516c6f056381f" translate="yes" xml:space="preserve">
          <source>To disambiguate and tell Rust that we want to use the implementation of &lt;code&gt;Animal&lt;/code&gt; for &lt;code&gt;Dog&lt;/code&gt;, we need to use fully qualified syntax. Listing 19-21 demonstrates how to use fully qualified syntax.</source>
          <target state="translated">Чтобы устранить неоднозначность и сообщить Rust, что мы хотим использовать реализацию &lt;code&gt;Animal&lt;/code&gt; for &lt;code&gt;Dog&lt;/code&gt; , нам нужно использовать полностью определенный синтаксис. В листинге 19-21 показано, как использовать полностью определенный синтаксис.</target>
        </trans-unit>
        <trans-unit id="f6bc5e83e5f978fc7521ec1ad0ec48fc0bc1e6d4" translate="yes" xml:space="preserve">
          <source>To do this in a language with inheritance, we might define a class named &lt;code&gt;Component&lt;/code&gt; that has a method named &lt;code&gt;draw&lt;/code&gt; on it. The other classes, such as &lt;code&gt;Button&lt;/code&gt;, &lt;code&gt;Image&lt;/code&gt;, and &lt;code&gt;SelectBox&lt;/code&gt;, would inherit from &lt;code&gt;Component&lt;/code&gt; and thus inherit the &lt;code&gt;draw&lt;/code&gt; method. They could each override the &lt;code&gt;draw&lt;/code&gt; method to define their custom behavior, but the framework could treat all of the types as if they were &lt;code&gt;Component&lt;/code&gt; instances and call &lt;code&gt;draw&lt;/code&gt; on them. But because Rust doesn&amp;rsquo;t have inheritance, we need another way to structure the &lt;code&gt;gui&lt;/code&gt; library to allow users to extend it with new types.</source>
          <target state="translated">Чтобы сделать это на языке с наследованием, мы могли бы определить класс с именем &lt;code&gt;Component&lt;/code&gt; , у которого есть метод с именем &lt;code&gt;draw&lt;/code&gt; . Другие классы, такие как &lt;code&gt;Button&lt;/code&gt; , &lt;code&gt;Image&lt;/code&gt; и &lt;code&gt;SelectBox&lt;/code&gt; , унаследуют от &lt;code&gt;Component&lt;/code&gt; и, таким образом, унаследуют метод &lt;code&gt;draw&lt;/code&gt; . Каждый из них может переопределить метод &lt;code&gt;draw&lt;/code&gt; чтобы определить свое настраиваемое поведение, но платформа может обрабатывать все типы, как если бы они были экземплярами &lt;code&gt;Component&lt;/code&gt; и вызывать для них &lt;code&gt;draw&lt;/code&gt; . Но поскольку в Rust нет наследования, нам нужен другой способ структурирования библиотеки &lt;code&gt;gui&lt;/code&gt; , чтобы пользователи могли расширять ее новыми типами.</target>
        </trans-unit>
        <trans-unit id="4978131923d35532be220aa91636f57efe0f7f12" translate="yes" xml:space="preserve">
          <source>To easily implement the Clone trait, you can also use &lt;code&gt;#[derive(Clone)]&lt;/code&gt;. Example:</source>
          <target state="translated">Чтобы легко реализовать трейт Clone, вы также можете использовать &lt;code&gt;#[derive(Clone)]&lt;/code&gt; . Пример:</target>
        </trans-unit>
        <trans-unit id="d0cd2dd965d6ad9f646e83059dd95c728c0a97cf" translate="yes" xml:space="preserve">
          <source>To eliminate this duplication, we can create an abstraction by defining a function that operates on any list of integers given to it in a parameter. This solution makes our code clearer and lets us express the concept of finding the largest number in a list abstractly.</source>
          <target state="translated">Чтобы устранить это дублирование,можно создать абстракцию,определив функцию,которая оперирует любым списком целых чисел,заданным ей в параметре.Это решение делает наш код более понятным и позволяет абстрактно выразить понятие нахождения наибольшего числа в списке.</target>
        </trans-unit>
        <trans-unit id="29cf48fa5d156f2e83366c6a4eab852452303d3f" translate="yes" xml:space="preserve">
          <source>To enable &lt;code&gt;minigrep&lt;/code&gt; to read the values of command line arguments we pass to it, we&amp;rsquo;ll need a function provided in Rust&amp;rsquo;s standard library, which is &lt;code&gt;std::env::args&lt;/code&gt;. This function returns an iterator of the command line arguments that were given to &lt;code&gt;minigrep&lt;/code&gt;. We&amp;rsquo;ll cover iterators fully in &lt;a href=&quot;ch13-00-functional-features&quot;&gt;Chapter 13&lt;/a&gt;. For now, you only need to know two details about iterators: iterators produce a series of values, and we can call the &lt;code&gt;collect&lt;/code&gt; method on an iterator to turn it into a collection, such as a vector, containing all the elements the iterator produces.</source>
          <target state="translated">Чтобы позволить &lt;code&gt;minigrep&lt;/code&gt; читать значения аргументов командной строки, которые мы ему передаем, нам понадобится функция, предоставленная в стандартной библиотеке Rust, которая называется &lt;code&gt;std::env::args&lt;/code&gt; . Эта функция возвращает итератор аргументов командной строки, переданных &lt;code&gt;minigrep&lt;/code&gt; . Мы полностью рассмотрим итераторы в &lt;a href=&quot;ch13-00-functional-features&quot;&gt;главе 13&lt;/a&gt; . На данный момент вам нужно знать только две детали об итераторах: итераторы создают серию значений, и мы можем вызвать метод &lt;code&gt;collect&lt;/code&gt; на итераторе, чтобы превратить его в коллекцию, такую ​​как вектор, содержащую все элементы, создаваемые итератором.</target>
        </trans-unit>
        <trans-unit id="ad43deb7c3d4847ed4f9b3c47149e285bd2d149c" translate="yes" xml:space="preserve">
          <source>To enable multiple ownership, Rust has a type called &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt;, which is an abbreviation for &lt;em&gt;reference counting&lt;/em&gt;. The &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; type keeps track of the number of references to a value which determines whether or not a value is still in use. If there are zero references to a value, the value can be cleaned up without any references becoming invalid.</source>
          <target state="translated">Чтобы разрешить множественное владение, в Rust есть тип под названием &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; , который является сокращением для &lt;em&gt;подсчета ссылок&lt;/em&gt; . Тип &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; отслеживает количество ссылок на значение, которое определяет, используется ли значение по-прежнему. Если есть нулевые ссылки на значение, значение может быть очищено, и никакие ссылки не станут недействительными.</target>
        </trans-unit>
        <trans-unit id="e59e1050701d5494b23014e46f9317fad2eac0b0" translate="yes" xml:space="preserve">
          <source>To enable this feature on a nightly version of rustc, add the &lt;code&gt;const_fn&lt;/code&gt; feature flag:</source>
          <target state="translated">Чтобы включить эту функцию в ночной версии rustc, добавьте &lt;code&gt;const_fn&lt;/code&gt; функции const_fn :</target>
        </trans-unit>
        <trans-unit id="d24a8c41c8e51812d2f6a3d4df4d4bc30f42fd94" translate="yes" xml:space="preserve">
          <source>To ensure memory safety, there&amp;rsquo;s one more detail to what happens in this situation in Rust. Instead of trying to copy the allocated memory, Rust considers &lt;code&gt;s1&lt;/code&gt; to no longer be valid and, therefore, Rust doesn&amp;rsquo;t need to free anything when &lt;code&gt;s1&lt;/code&gt; goes out of scope. Check out what happens when you try to use &lt;code&gt;s1&lt;/code&gt; after &lt;code&gt;s2&lt;/code&gt; is created; it won&amp;rsquo;t work:</source>
          <target state="translated">Чтобы обеспечить безопасность памяти, есть еще одна деталь о том, что происходит в этой ситуации в Rust. Вместо того, чтобы пытаться скопировать выделенную память, Rust считает &lt;code&gt;s1&lt;/code&gt; недействительным и, следовательно, Rust не нужно ничего освобождать, когда &lt;code&gt;s1&lt;/code&gt; выходит за рамки. Посмотрите, что происходит, когда вы пытаетесь использовать &lt;code&gt;s1&lt;/code&gt; после создания &lt;code&gt;s2&lt;/code&gt; ; это не сработает:</target>
        </trans-unit>
        <trans-unit id="44d8c4aeacd237bf73174a5745772ccb9ea1f421" translate="yes" xml:space="preserve">
          <source>To ensure soundness, Safe Rust is restricted enough that it can be automatically checked. Sometimes, however, it is necessary to write code that is correct for reasons which are too clever for the compiler to understand. In those cases, you need to use Unsafe Rust.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8ccd9133d33f00e1b04fd5409b4bd62ab4182d4d" translate="yes" xml:space="preserve">
          <source>To extend a type without breaking existing code</source>
          <target state="translated">Для расширения типа без взлома существующего кода</target>
        </trans-unit>
        <trans-unit id="986aa5a06f6c7eab4fbf8758ab21e34c28998b7b" translate="yes" xml:space="preserve">
          <source>To find the largest number in two different lists of numbers, we can duplicate the code in Listing 10-1 and use the same logic at two different places in the program, as shown in Listing 10-2.</source>
          <target state="translated">Чтобы найти наибольшее число в двух разных списках номеров,мы можем продублировать код в Листинге 10-1 и использовать одну и ту же логику в двух разных местах в программе,как показано в Листинге 10-2.</target>
        </trans-unit>
        <trans-unit id="05412e512ad05fb982373163c001384a6dc6dc41" translate="yes" xml:space="preserve">
          <source>To fix such code, put them in an extern &quot;C&quot; block:</source>
          <target state="translated">Чтобы исправить такой код,поместите их в блок extern &quot;C&quot;:</target>
        </trans-unit>
        <trans-unit id="3f641101a15aa5663f425af7eca864860358c2b4" translate="yes" xml:space="preserve">
          <source>To fix the compiler error in Listing 16-3, we can use the error message&amp;rsquo;s advice:</source>
          <target state="translated">Чтобы исправить ошибку компилятора в листинге 16-3, мы можем использовать совет сообщения об ошибке:</target>
        </trans-unit>
        <trans-unit id="35eb0225e4203818949db81d35253471e9bc1946" translate="yes" xml:space="preserve">
          <source>To fix the issue, remove patterns (&lt;code&gt;_&lt;/code&gt; is allowed though). Example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ea4b2f5b453763912d29b2bc8e5d29a39885b8b2" translate="yes" xml:space="preserve">
          <source>To fix the issue, remove the duplicate declaration:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a982630d24bce9f0c2bacf99524398a473cc7ece" translate="yes" xml:space="preserve">
          <source>To fix the previous code example, we derive &lt;code&gt;PartialEq&lt;/code&gt; and &lt;code&gt;Eq&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9a70249adaf4eb50343b8e3cb8c112aee0c4394d" translate="yes" xml:space="preserve">
          <source>To fix the problem where we have a refutable pattern where an irrefutable pattern is needed, we can change the code that uses the pattern: instead of using &lt;code&gt;let&lt;/code&gt;, we can use &lt;code&gt;if let&lt;/code&gt;. Then if the pattern doesn&amp;rsquo;t match, the code will just skip the code in the curly brackets, giving it a way to continue validly. Listing 18-9 shows how to fix the code in Listing 18-8.</source>
          <target state="translated">Чтобы решить проблему, когда у нас есть опровергнутый шаблон, где требуется неопровержимый шаблон, мы можем изменить код, который использует этот шаблон: вместо использования &lt;code&gt;let&lt;/code&gt; мы можем использовать &lt;code&gt;if let&lt;/code&gt; . Затем, если шаблон не совпадает, код просто пропустит код в фигурных скобках, давая возможность продолжить работу. В листинге 18-9 показано, как исправить код в листинге 18-8.</target>
        </trans-unit>
        <trans-unit id="3d38f12fb6a882b38564fce2f1f7c9cb9d1796dd" translate="yes" xml:space="preserve">
          <source>To fix the problem, either remove the unknown meta item, or rename it if you provided the wrong name.</source>
          <target state="translated">Чтобы решить проблему,либо удалите неизвестный мета-элемент,либо переименуйте его,если вы указали неверное имя.</target>
        </trans-unit>
        <trans-unit id="ff15ef440d8fd65fc53847fcd7d27134b37684e0" translate="yes" xml:space="preserve">
          <source>To fix the problem, remove all but one of the meta items with the same key.</source>
          <target state="translated">Чтобы устранить проблему,удалите все мета-элементы,кроме одного,одним и тем же ключом.</target>
        </trans-unit>
        <trans-unit id="ea6969ed4bf2de9ff5e1987bde2a5974361798c0" translate="yes" xml:space="preserve">
          <source>To fix this and consume the iterator, we&amp;rsquo;ll use the &lt;code&gt;collect&lt;/code&gt; method, which we used in Chapter 12 with &lt;code&gt;env::args&lt;/code&gt; in Listing 12-1. This method consumes the iterator and collects the resulting values into a collection data type.</source>
          <target state="translated">Чтобы исправить это и использовать итератор, мы будем использовать метод &lt;code&gt;collect&lt;/code&gt; , который мы использовали в главе 12 с &lt;code&gt;env::args&lt;/code&gt; в листинге 12-1. Этот метод использует итератор и собирает полученные значения в тип данных коллекции.</target>
        </trans-unit>
        <trans-unit id="7ddafefb4eada6e20a8873619c096afec9d9e821" translate="yes" xml:space="preserve">
          <source>To fix this error we need to spell out &lt;code&gt;Self&lt;/code&gt; to &lt;code&gt;S&amp;lt;'a&amp;gt;&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d00f739419dcbd64823b1ea3abe0a10a9be4cbba" translate="yes" xml:space="preserve">
          <source>To fix this error, add a &lt;code&gt;main&lt;/code&gt; function:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b190c393f2e104afe11b9ff6d75785abc13b4fac" translate="yes" xml:space="preserve">
          <source>To fix this error, add the missing digits:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="74f9240b7df9e2cdcc942864074f152c08f49afd" translate="yes" xml:space="preserve">
          <source>To fix this error, add the missing double quote at the end of the string:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b2a45c1a4916fd6685c913af98c59a6ca44a92d9" translate="yes" xml:space="preserve">
          <source>To fix this error, add the missing quote:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="14bc23db223a3a7adb6fd2ea01135a7a51e21b23" translate="yes" xml:space="preserve">
          <source>To fix this error, check that you didn't misspell the field's name or that the field actually exists. Example:</source>
          <target state="translated">Чтобы исправить эту ошибку,проверьте,что вы не неправильно написали имя поля или что поле действительно существует.Пример:</target>
        </trans-unit>
        <trans-unit id="75b750ac4b7d89ba0d9d76afc4c969c263359a34" translate="yes" xml:space="preserve">
          <source>To fix this error, compile your code for a Rust target that supports the TrustZone-M extension. The current possible targets are:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a7f0d68c9258ec3385682a9e7888b4d82a961453" translate="yes" xml:space="preserve">
          <source>To fix this error, declare &lt;code&gt;ss&lt;/code&gt; as mutable by using the &lt;code&gt;mut&lt;/code&gt; keyword:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9a10ae82ce30bea6273b20c3ae88287f346a01ba" translate="yes" xml:space="preserve">
          <source>To fix this error, declare your entry function with a C ABI, using &lt;code&gt;extern &quot;C&quot;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ec4c03a79b5dd9aa983287afa6ca9be17b72579d" translate="yes" xml:space="preserve">
          <source>To fix this error, don't try to cast directly between thin and fat pointers.</source>
          <target state="translated">Чтобы исправить эту ошибку,не пытайтесь бросать прямо между тонкими и толстыми указками.</target>
        </trans-unit>
        <trans-unit id="851cef01fbc24aa508b07321c6a80e736f5740f3" translate="yes" xml:space="preserve">
          <source>To fix this error, either lessen the expected lifetime or find a way to not have to use this reference outside of its current scope (by running the code directly in the same block for example?):</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2cf449e499fd02815621561773f0782493f1f5ff" translate="yes" xml:space="preserve">
          <source>To fix this error, either split into multiple match arms:</source>
          <target state="translated">Чтобы исправить эту ошибку,либо разделитесь на несколько спичечных рук:</target>
        </trans-unit>
        <trans-unit id="4a625dc9e5fa99f625b4f36ca500334a72e9f93e" translate="yes" xml:space="preserve">
          <source>To fix this error, ensure that each field from the struct's definition is mentioned in the pattern, or use &lt;code&gt;..&lt;/code&gt; to ignore unwanted fields. Example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="59d5e036d18215af29bf5d6026ec79c924cc4630" translate="yes" xml:space="preserve">
          <source>To fix this error, ensure that you don't have any other references to the variable before trying to access it mutably:</source>
          <target state="translated">Чтобы исправить эту ошибку,убедитесь,что у вас нет других ссылок на переменную,прежде чем пытаться получить к ней мутильный доступ:</target>
        </trans-unit>
        <trans-unit id="c41c6753158354db97000bee3e6d1e71d162a5c2" translate="yes" xml:space="preserve">
          <source>To fix this error, ensure the match arm kind is the same as the expression matched.</source>
          <target state="translated">Чтобы исправить эту ошибку,убедитесь,что тип совпадающего плеча совпадает с выражением.</target>
        </trans-unit>
        <trans-unit id="0e0f8c883662f36aaeadf872304efd94871b85a2" translate="yes" xml:space="preserve">
          <source>To fix this error, just change the binding's name in order to avoid shadowing one of the following:</source>
          <target state="translated">Чтобы исправить эту ошибку,достаточно изменить имя привязки,чтобы избежать затенения одного из следующих пунктов:</target>
        </trans-unit>
        <trans-unit id="547cd595fdb912c2692881e0fc69f7e09c4e06b4" translate="yes" xml:space="preserve">
          <source>To fix this error, just specify the type of the variable. Example:</source>
          <target state="translated">Для исправления ошибки достаточно указать тип переменной.Пример:</target>
        </trans-unit>
        <trans-unit id="ac9826f4a5f0aca5be2cbd8435bee957e2a23961" translate="yes" xml:space="preserve">
          <source>To fix this error, just use the same mode in both cases. Generally using &lt;code&gt;ref&lt;/code&gt; or &lt;code&gt;ref mut&lt;/code&gt; where not already used will fix this:</source>
          <target state="translated">Чтобы исправить эту ошибку, просто используйте один и тот же режим в обоих случаях. Обычно это исправляет использование &lt;code&gt;ref&lt;/code&gt; или &lt;code&gt;ref mut&lt;/code&gt; там, где они еще не использовались:</target>
        </trans-unit>
        <trans-unit id="f5f3bd9b98cede2f9883569f89f15b8f146e95f8" translate="yes" xml:space="preserve">
          <source>To fix this error, please be sure that the module is in scope:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="130e6cb76ab8ba2e39f9316003d15648f16e824e" translate="yes" xml:space="preserve">
          <source>To fix this error, please check that this type implements this binary operation. Example:</source>
          <target state="translated">Для исправления этой ошибки проверьте,что этот тип реализует эту двоичную операцию.Пример:</target>
        </trans-unit>
        <trans-unit id="5f8bccc6c37b14540562ff31ba77c03a4a691b62" translate="yes" xml:space="preserve">
          <source>To fix this error, please ensure that all the fields of the struct are public, or implement a function for easy instantiation. Examples:</source>
          <target state="translated">Чтобы исправить эту ошибку,пожалуйста,убедитесь,что все поля структуры являются общедоступными,или реализуйте функцию для легкой конкретизации.Примеры:</target>
        </trans-unit>
        <trans-unit id="342e8c2f7a1ada9b484baabdc9d06d406ca80a54" translate="yes" xml:space="preserve">
          <source>To fix this error, please implement a trait on the type or wrap it in a struct. Example:</source>
          <target state="translated">Для исправления этой ошибки необходимо реализовать трейт на типе или обернуть его в структуру.Пример:</target>
        </trans-unit>
        <trans-unit id="befadb1ed4ec4a8c074944e9002910bb635c2bda" translate="yes" xml:space="preserve">
          <source>To fix this error, please remove the visibility qualifier when it is not required. Example:</source>
          <target state="translated">Для исправления этой ошибки,пожалуйста,удалите квалификатор видимости,когда он не требуется.Пример:</target>
        </trans-unit>
        <trans-unit id="dd5bba6de2aa5f4e39e98433e92b409c0d3ccac5" translate="yes" xml:space="preserve">
          <source>To fix this error, please replace the value with a constant. Example:</source>
          <target state="translated">Для исправления этой ошибки,пожалуйста,замените значение на константу.Пример:</target>
        </trans-unit>
        <trans-unit id="29332719480b2d3d455368380fd1815d30eebf29" translate="yes" xml:space="preserve">
          <source>To fix this error, please verify that the method name wasn't misspelled and verify that you are indeed implementing the correct trait items. Example:</source>
          <target state="translated">Чтобы исправить эту ошибку,пожалуйста,проверьте,что имя метода не было неправильно написано,и убедитесь,что вы действительно реализуете правильные элементы трейта.Пример:</target>
        </trans-unit>
        <trans-unit id="d6526d13f1c406efebc4022cedccc7bfc1d5dbc7" translate="yes" xml:space="preserve">
          <source>To fix this error, please verify you didn't misspell the type name, you did declare it or imported it into the scope. Examples:</source>
          <target state="translated">Чтобы исправить эту ошибку,пожалуйста,убедитесь,что вы не неправильно написали имя типа,вы его декларировали или импортировали в область видимости.Примеры:</target>
        </trans-unit>
        <trans-unit id="e76357808cad4720013a780f0b9c4aca40fe0097" translate="yes" xml:space="preserve">
          <source>To fix this error, remove the null characters:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1b0aa8ad2a46bb3a87624f0ae14dc2151334230f" translate="yes" xml:space="preserve">
          <source>To fix this error, replace the pattern argument with a regular one. Example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5459bb70fc45530a8171a7e09df41fa4c970e0d5" translate="yes" xml:space="preserve">
          <source>To fix this error, use a concrete type for the const parameter:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ca68924d905d97b9f1af1bea1e0a2d8cf16561fb" translate="yes" xml:space="preserve">
          <source>To fix this error, we need to move the &lt;code&gt;Shark&lt;/code&gt; struct inside the &lt;code&gt;Sea&lt;/code&gt; module:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="140824e6ec67ac2a81b7a4c3bb6daa38bc47f6d7" translate="yes" xml:space="preserve">
          <source>To fix this error, you can declare &lt;code&gt;create_some&lt;/code&gt; as a constant function:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6da3993819cb20099d5b634dd66120eb7048a481" translate="yes" xml:space="preserve">
          <source>To fix this error, you can finish using the closure before using the captured variable:</source>
          <target state="translated">Чтобы исправить эту ошибку,можно закончить использование закрытия,прежде чем использовать захваченную переменную:</target>
        </trans-unit>
        <trans-unit id="271f576e3469a4d5c3d47381caa4c74a644868c6" translate="yes" xml:space="preserve">
          <source>To fix this error, you can use the tuple pattern:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b3282af9d0d83b5725d812a840935cf798392f05" translate="yes" xml:space="preserve">
          <source>To fix this error, you have to move &lt;code&gt;yield&lt;/code&gt; out of the &lt;code&gt;async&lt;/code&gt; block:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="62676a2c0346704243e5e296c782b376a8f848ca" translate="yes" xml:space="preserve">
          <source>To fix this error, you have two solutions:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d18371bc4c07ba0c41f6206f4861a5d76f0f6e55" translate="yes" xml:space="preserve">
          <source>To fix this error, you need to mark all the parent implementations as default. Example:</source>
          <target state="translated">Чтобы исправить эту ошибку,необходимо по умолчанию отметить все родительские реализации.Пример:</target>
        </trans-unit>
        <trans-unit id="cf4fd1eefb95ff6d8562a2c0c639ea77e8a69e6e" translate="yes" xml:space="preserve">
          <source>To fix this issue, either use the lifetime in the arguments, or use &lt;code&gt;'static&lt;/code&gt;. Example:</source>
          <target state="translated">Чтобы устранить эту проблему, либо используйте время жизни в аргументах, либо используйте &lt;code&gt;'static&lt;/code&gt; . Пример:</target>
        </trans-unit>
        <trans-unit id="9bc21023f3e82d02ae5ca480adede6bb29ef608c" translate="yes" xml:space="preserve">
          <source>To fix this issue, either use the lifetime in the arguments, or use the &lt;code&gt;'static&lt;/code&gt; lifetime. Example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bb2e9d61c37258f8ed9cce9fe2929803d6d2313b" translate="yes" xml:space="preserve">
          <source>To fix this issue, either use the lifetime in the inputs, or use &lt;code&gt;'static&lt;/code&gt;. Example:</source>
          <target state="translated">Чтобы решить эту проблему, либо используйте время жизни во входных данных, либо используйте &lt;code&gt;'static&lt;/code&gt; . Пример:</target>
        </trans-unit>
        <trans-unit id="1c9273cf829edc7ecc1d2ffb40566c6ec5264a53" translate="yes" xml:space="preserve">
          <source>To fix this issue, just remove the generics:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="47d656f4427ec08945a130e9ab24f44d356e73c6" translate="yes" xml:space="preserve">
          <source>To fix this issue, just remove the return keyword or move the expression into a function. Example:</source>
          <target state="translated">Чтобы исправить эту проблему,просто удалите возвращаемое ключевое слово или переместите выражение в функцию.Пример:</target>
        </trans-unit>
        <trans-unit id="f7f17c649ffe42ea1218c2db05314ba8b680b067" translate="yes" xml:space="preserve">
          <source>To fix this issue, just remove the super trait:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6045b449bd1ac38773b2f91ba227f233a40af26b" translate="yes" xml:space="preserve">
          <source>To fix this issue, the lifetime in the const generic need to be changed to &lt;code&gt;'static&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9924221c408a112fe763d167c1b4a29e5c450e04" translate="yes" xml:space="preserve">
          <source>To fix this issue, you have to rename at least one of the two imports. Example:</source>
          <target state="translated">Чтобы исправить эту проблему,необходимо переименовать хотя бы один из двух импортов.Пример:</target>
        </trans-unit>
        <trans-unit id="8b92f6f0312b161fc6e42dd1de00eb946169f081" translate="yes" xml:space="preserve">
          <source>To fix this problem, we&amp;rsquo;ll modify the threads so they listen for either a &lt;code&gt;Job&lt;/code&gt; to run or a signal that they should stop listening and exit the infinite loop. Instead of &lt;code&gt;Job&lt;/code&gt; instances, our channel will send one of these two enum variants.</source>
          <target state="translated">Чтобы решить эту проблему, мы изменим потоки, чтобы они слушали либо выполнение &lt;code&gt;Job&lt;/code&gt; либо сигнал о том, что им следует прекратить прослушивание и выйти из бесконечного цикла. Вместо экземпляров &lt;code&gt;Job&lt;/code&gt; наш канал будет отправлять один из этих двух вариантов перечисления.</target>
        </trans-unit>
        <trans-unit id="c3ddf887a4b5f979d5c4754fbe5d3842c28e8398" translate="yes" xml:space="preserve">
          <source>To fix this problem, you can do either of these things:</source>
          <target state="translated">Чтобы решить эту проблему,вы можете сделать любую из этих вещей:</target>
        </trans-unit>
        <trans-unit id="d1040dc78ad7b42b1b39bcb93179f38486776a0b" translate="yes" xml:space="preserve">
          <source>To fix this problem, you need to create a local variable to store the value in rather than relying on a temporary. For example, you might change the original program to the following:</source>
          <target state="translated">Для исправления этой проблемы необходимо создать локальную переменную,в которой будет храниться значение,а не полагаться на временную.Например,вы можете изменить исходную программу на следующую:</target>
        </trans-unit>
        <trans-unit id="038c4ea9697da9d94b0b431c704689f74be084b1" translate="yes" xml:space="preserve">
          <source>To fix this we have to define the lifetime at the function or impl level and use that lifetime in the &lt;code&gt;impl Trait&lt;/code&gt;. For example you can define the lifetime at the function:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="396fe77bfe601f99ac29d2d6217b45f0b4c303c2" translate="yes" xml:space="preserve">
          <source>To fix this we have to use the labeled block properly. For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="360a9b00506f1addbb3267f917ea23dd8584e790" translate="yes" xml:space="preserve">
          <source>To fix this, add a label specifying which loop is being broken out of:</source>
          <target state="translated">Чтобы это исправить,добавьте метку,указывающую,из какого цикла происходит разрыв:</target>
        </trans-unit>
        <trans-unit id="4f4f5291163064ff6fda56abd889a7618c40d282" translate="yes" xml:space="preserve">
          <source>To fix this, add an implementation for each default method from the trait:</source>
          <target state="translated">Чтобы исправить это,добавьте реализацию для каждого метода по умолчанию из трейта:</target>
        </trans-unit>
        <trans-unit id="56a92651d517e6a1850a1ad3d4745e7b392eba21" translate="yes" xml:space="preserve">
          <source>To fix this, edit the &lt;em&gt;Cargo.toml&lt;/em&gt; file for the &lt;code&gt;adder&lt;/code&gt; crate and indicate that &lt;code&gt;rand&lt;/code&gt; is a dependency for that crate as well. Building the &lt;code&gt;adder&lt;/code&gt; crate will add &lt;code&gt;rand&lt;/code&gt; to the list of dependencies for &lt;code&gt;adder&lt;/code&gt; in &lt;em&gt;Cargo.lock&lt;/em&gt;, but no additional copies of &lt;code&gt;rand&lt;/code&gt; will be downloaded. Cargo has ensured that every crate in the workspace using the &lt;code&gt;rand&lt;/code&gt; crate will be using the same version. Using the same version of &lt;code&gt;rand&lt;/code&gt; across the workspace saves space because we won&amp;rsquo;t have multiple copies and ensures that the crates in the workspace will be compatible with each other.</source>
          <target state="translated">Чтобы исправить это, отредактируйте файл &lt;em&gt;Cargo.toml&lt;/em&gt; для ящика &lt;code&gt;adder&lt;/code&gt; и укажите, что &lt;code&gt;rand&lt;/code&gt; также является зависимостью для этого ящика. Сборка ящика &lt;code&gt;adder&lt;/code&gt; добавит &lt;code&gt;rand&lt;/code&gt; в список зависимостей &lt;code&gt;adder&lt;/code&gt; в &lt;em&gt;Cargo.lock&lt;/em&gt; , но никакие дополнительные копии &lt;code&gt;rand&lt;/code&gt; не будут загружены. Cargo позаботился о том, чтобы каждый ящик в рабочей области, в котором использовался ящик &lt;code&gt;rand&lt;/code&gt; , имел одну и ту же версию. Использование одной и той же версии &lt;code&gt;rand&lt;/code&gt; в рабочей области экономит место, потому что у нас не будет нескольких копий, и гарантирует, что ящики в рабочей области будут совместимы друг с другом.</target>
        </trans-unit>
        <trans-unit id="9d9a4693a46d51eb0d6120d0488c70fc938ea0de" translate="yes" xml:space="preserve">
          <source>To fix this, edit the &lt;em&gt;Cargo.toml&lt;/em&gt; file for the &lt;code&gt;adder&lt;/code&gt; package and indicate that &lt;code&gt;rand&lt;/code&gt; is a dependency for it as well. Building the &lt;code&gt;adder&lt;/code&gt; package will add &lt;code&gt;rand&lt;/code&gt; to the list of dependencies for &lt;code&gt;adder&lt;/code&gt; in &lt;em&gt;Cargo.lock&lt;/em&gt;, but no additional copies of &lt;code&gt;rand&lt;/code&gt; will be downloaded. Cargo has ensured that every crate in every package in the workspace using the &lt;code&gt;rand&lt;/code&gt; package will be using the same version. Using the same version of &lt;code&gt;rand&lt;/code&gt; across the workspace saves space because we won&amp;rsquo;t have multiple copies and ensures that the crates in the workspace will be compatible with each other.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9dd753bd45e01fa10b5929e59eda068f06c82e05" translate="yes" xml:space="preserve">
          <source>To fix this, either remove the outer reference:</source>
          <target state="translated">Чтобы это исправить,либо удалите внешнюю ссылку:</target>
        </trans-unit>
        <trans-unit id="cb0074c2565e11e981fa6efe9e6d5af9f075e607" translate="yes" xml:space="preserve">
          <source>To fix this, ensure that any declared variables are initialized before being used. Example:</source>
          <target state="translated">Чтобы исправить это,убедитесь,что все объявленные переменные инициализированы перед использованием.Пример:</target>
        </trans-unit>
        <trans-unit id="437601cd4925a7106ff21615c74bc484d85aef14" translate="yes" xml:space="preserve">
          <source>To fix this, ensure that the name was correctly spelled, and that the correct form of initializer was used.</source>
          <target state="translated">Чтобы это исправить,убедитесь,что имя было правильно написано,и что была использована правильная форма инициализатора.</target>
        </trans-unit>
        <trans-unit id="890f488bd89f18960203be014ab27fb39dfc6d22" translate="yes" xml:space="preserve">
          <source>To fix this, it is suggested to use a &lt;code&gt;where Self: Sized&lt;/code&gt; bound similar to the fix for the sub-error above if you do not intend to call the method with type parameters:</source>
          <target state="translated">Чтобы исправить это, предлагается использовать &lt;code&gt;where Self: Sized&lt;/code&gt; аналогичную исправлению для под-ошибки выше, если вы не собираетесь вызывать метод с параметрами типа:</target>
        </trans-unit>
        <trans-unit id="c7b0cc36b1cf18605167b9e261109b879dd0c485" translate="yes" xml:space="preserve">
          <source>To fix this, please set manually the next enum value or put the enum variant with the maximum value at the end of the enum. Examples:</source>
          <target state="translated">Для исправления этого,пожалуйста,установите вручную следующее значение перечисления или поставьте вариант перечисления с максимальным значением в конце перечисления.Примеры:</target>
        </trans-unit>
        <trans-unit id="fa4bb08fcba49cd98aef8848abbf20a6a3f3bfcb" translate="yes" xml:space="preserve">
          <source>To fix this, replace the generic parameter with the specializations that you need:</source>
          <target state="translated">Чтобы это исправить,замените общий параметр на нужные вам специализации:</target>
        </trans-unit>
        <trans-unit id="0f9e6f402abcaecb02615cbeb4f9eaf1b18503a7" translate="yes" xml:space="preserve">
          <source>To fix this, the value can be extracted as a const and then used:</source>
          <target state="translated">Чтобы это исправить,значение может быть извлечено как константа,а затем использовано:</target>
        </trans-unit>
        <trans-unit id="34e96f574d6d4b3f0139f4794453e1b644fdb7fa" translate="yes" xml:space="preserve">
          <source>To fix this, we implement &lt;code&gt;Display&lt;/code&gt; on &lt;code&gt;Point&lt;/code&gt; and satisfy the constraint that &lt;code&gt;OutlinePrint&lt;/code&gt; requires, like so:</source>
          <target state="translated">Чтобы исправить это, мы реализуем &lt;code&gt;Display&lt;/code&gt; on &lt;code&gt;Point&lt;/code&gt; и удовлетворяем ограничению, &lt;code&gt;OutlinePrint&lt;/code&gt; требует OutlinePrint , например:</target>
        </trans-unit>
        <trans-unit id="1afba8b0958bf7d54c00a1e357d6112f94820fbc" translate="yes" xml:space="preserve">
          <source>To fix this, you must reference the lifetime &lt;code&gt;'x&lt;/code&gt; from the return type. For example, changing the return type to &lt;code&gt;impl Trait&amp;lt;'y&amp;gt; + 'x&lt;/code&gt; would work:</source>
          <target state="translated">Чтобы исправить это, вы должны указать время жизни &lt;code&gt;'x&lt;/code&gt; ' из возвращаемого типа. Например, изменение типа возвращаемого значения на &lt;code&gt;impl Trait&amp;lt;'y&amp;gt; + 'x&lt;/code&gt; будет работать:</target>
        </trans-unit>
        <trans-unit id="b2c5b5034aa90905612a009b913793af12d3e3ac" translate="yes" xml:space="preserve">
          <source>To further refine the game&amp;rsquo;s behavior, rather than crashing the program when the user inputs a non-number, let&amp;rsquo;s make the game ignore a non-number so the user can continue guessing. We can do that by altering the line where &lt;code&gt;guess&lt;/code&gt; is converted from a &lt;code&gt;String&lt;/code&gt; to a &lt;code&gt;u32&lt;/code&gt;, as shown in Listing 2-5.</source>
          <target state="translated">Чтобы еще больше улучшить поведение игры, вместо того, чтобы приводить к сбою программы, когда пользователь вводит нечисловое значение, давайте заставим игру игнорировать нечисловое число, чтобы пользователь мог продолжать угадывать. Мы можем сделать это, изменив строку, в которой &lt;code&gt;guess&lt;/code&gt; преобразуется из &lt;code&gt;String&lt;/code&gt; в &lt;code&gt;u32&lt;/code&gt; , как показано в листинге 2-5.</target>
        </trans-unit>
        <trans-unit id="bea9207f63bde7916694d159ff6b4254f0892dc5" translate="yes" xml:space="preserve">
          <source>To get a mutable string slice instead, see the &lt;a href=&quot;#method.slice_mut_unchecked&quot;&gt;&lt;code&gt;slice_mut_unchecked&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">Чтобы вместо этого получить изменяемый строковый фрагмент, см. Метод &lt;a href=&quot;#method.slice_mut_unchecked&quot;&gt; &lt;code&gt;slice_mut_unchecked&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="baed129549ca4f37d13996fe220fb567ab069ac8" translate="yes" xml:space="preserve">
          <source>To get a mutable string slice instead, see the &lt;a href=&quot;../primitive.str#method.slice_mut_unchecked&quot;&gt;&lt;code&gt;slice_mut_unchecked&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8139e232eb226615d326fd45327940952c09f923" translate="yes" xml:space="preserve">
          <source>To get a mutable string slice instead, see the &lt;a href=&quot;primitive.str#method.slice_mut_unchecked&quot;&gt;&lt;code&gt;slice_mut_unchecked&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0238d96367a691acb632dbf4d73cc5fd2a706ad9" translate="yes" xml:space="preserve">
          <source>To get a pointer to a boxed value, dereference the box:</source>
          <target state="translated">Чтобы получить указатель на ячейку,разыменуйте ячейку:</target>
        </trans-unit>
        <trans-unit id="8f1e8a2f8899e777c3546c1b586cd81156849069" translate="yes" xml:space="preserve">
          <source>To get a specific value from a struct, we can use dot notation. If we wanted just this user&amp;rsquo;s email address, we could use &lt;code&gt;user1.email&lt;/code&gt; wherever we wanted to use this value. If the instance is mutable, we can change a value by using the dot notation and assigning into a particular field. Listing 5-3 shows how to change the value in the &lt;code&gt;email&lt;/code&gt; field of a mutable &lt;code&gt;User&lt;/code&gt; instance.</source>
          <target state="translated">Чтобы получить конкретное значение из структуры, мы можем использовать точечную нотацию. Если бы нам нужен был только адрес электронной почты этого пользователя, мы могли бы использовать &lt;code&gt;user1.email&lt;/code&gt; везде, где хотели бы использовать это значение. Если экземпляр является изменяемым, мы можем изменить значение, используя точечную нотацию и присвоение определенному полю. В листинге 5-3 показано, как изменить значение в поле &lt;code&gt;email&lt;/code&gt; изменяемого экземпляра &lt;code&gt;User&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ffd19be588eb8df1e329d2bc1905f6d517e8c370" translate="yes" xml:space="preserve">
          <source>To get an immutable string slice instead, see the &lt;a href=&quot;#method.slice_unchecked&quot;&gt;&lt;code&gt;slice_unchecked&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">Чтобы вместо этого получить неизменяемый строковый фрагмент, см. Метод &lt;a href=&quot;#method.slice_unchecked&quot;&gt; &lt;code&gt;slice_unchecked&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="4160b8923a79d4ccc00d36a66c387740f16ca557" translate="yes" xml:space="preserve">
          <source>To get an immutable string slice instead, see the &lt;a href=&quot;../primitive.str#method.slice_unchecked&quot;&gt;&lt;code&gt;slice_unchecked&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7ce6e3247525a78442e0ee3f76231a67e813fe82" translate="yes" xml:space="preserve">
          <source>To get an immutable string slice instead, see the &lt;a href=&quot;primitive.str#method.slice_unchecked&quot;&gt;&lt;code&gt;slice_unchecked&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="29270bb604499679be31005db9630fdff3a329f3" translate="yes" xml:space="preserve">
          <source>To get immutable string slices instead, see the &lt;a href=&quot;#method.split_at&quot;&gt;&lt;code&gt;split_at&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">Чтобы вместо этого получить неизменяемые фрагменты строки, см. Метод &lt;a href=&quot;#method.split_at&quot;&gt; &lt;code&gt;split_at&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="1773350f816d14b08d14b8fc6f4503505910e146" translate="yes" xml:space="preserve">
          <source>To get immutable string slices instead, see the &lt;a href=&quot;../primitive.str#method.split_at&quot;&gt;&lt;code&gt;split_at&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="130eb39bd47cd566af1912b3ccb9f5e133aeacd3" translate="yes" xml:space="preserve">
          <source>To get immutable string slices instead, see the &lt;a href=&quot;primitive.str#method.split_at&quot;&gt;&lt;code&gt;split_at&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d6bbcb0bb220df37e8c688ef821b8733765b09b5" translate="yes" xml:space="preserve">
          <source>To get mutable string slices instead, see the &lt;a href=&quot;#method.split_at_mut&quot;&gt;&lt;code&gt;split_at_mut&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">Чтобы вместо этого получить изменяемые фрагменты строки, см. Метод &lt;a href=&quot;#method.split_at_mut&quot;&gt; &lt;code&gt;split_at_mut&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="7b8786ffc3edfea977e5fb933b851cad79af05d7" translate="yes" xml:space="preserve">
          <source>To get mutable string slices instead, see the &lt;a href=&quot;../primitive.str#method.split_at_mut&quot;&gt;&lt;code&gt;split_at_mut&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="46f032d280d4b30ddfbcd15e779b494aafdce282" translate="yes" xml:space="preserve">
          <source>To get mutable string slices instead, see the &lt;a href=&quot;primitive.str#method.split_at_mut&quot;&gt;&lt;code&gt;split_at_mut&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2a0349cd0d37a5287741f4237e8c49df43c4e0c6" translate="yes" xml:space="preserve">
          <source>To get this out of the way: you should probably just use &lt;a href=&quot;../vec/struct.vec&quot;&gt;&lt;code&gt;Vec&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;struct.hashmap&quot;&gt;&lt;code&gt;HashMap&lt;/code&gt;&lt;/a&gt;. These two collections cover most use cases for generic data storage and processing. They are exceptionally good at doing what they do. All the other collections in the standard library have specific use cases where they are the optimal choice, but these cases are borderline &lt;em&gt;niche&lt;/em&gt; in comparison. Even when &lt;code&gt;Vec&lt;/code&gt; and &lt;code&gt;HashMap&lt;/code&gt; are technically suboptimal, they're probably a good enough choice to get started.</source>
          <target state="translated">Чтобы избежать этого: вам, вероятно, следует просто использовать &lt;a href=&quot;../vec/struct.vec&quot;&gt; &lt;code&gt;Vec&lt;/code&gt; &lt;/a&gt; или &lt;a href=&quot;struct.hashmap&quot;&gt; &lt;code&gt;HashMap&lt;/code&gt; &lt;/a&gt; . Эти две коллекции охватывают большинство вариантов использования для хранения и обработки общих данных. Они исключительно хороши в том, что делают. Все остальные коллекции в стандартной библиотеке имеют определенные варианты использования, в которых они являются оптимальным выбором, но по сравнению с ними эти случаи являются пограничной &lt;em&gt;нишей&lt;/em&gt; . Даже когда &lt;code&gt;Vec&lt;/code&gt; и &lt;code&gt;HashMap&lt;/code&gt; технически неоптимальны, они, вероятно, достаточно хороший выбор для начала.</target>
        </trans-unit>
        <trans-unit id="18773042303056fd8c79476f3616f355ff443a51" translate="yes" xml:space="preserve">
          <source>To handle the error case and print a user-friendly message, we need to update &lt;code&gt;main&lt;/code&gt; to handle the &lt;code&gt;Result&lt;/code&gt; being returned by &lt;code&gt;Config::new&lt;/code&gt;, as shown in Listing 12-10. We&amp;rsquo;ll also take the responsibility of exiting the command line tool with a nonzero error code from &lt;code&gt;panic!&lt;/code&gt; and implement it by hand. A nonzero exit status is a convention to signal to the process that called our program that the program exited with an error state.</source>
          <target state="translated">Чтобы обработать случай ошибки и напечатать удобное для пользователя сообщение, нам нужно обновить &lt;code&gt;main&lt;/code&gt; для обработки &lt;code&gt;Result&lt;/code&gt; , возвращаемого &lt;code&gt;Config::new&lt;/code&gt; , как показано в листинге 12-10. Мы также берем на себя ответственность выйти из инструмента командной строки с ненулевым кодом ошибки из &lt;code&gt;panic!&lt;/code&gt; и реализуем вручную. Ненулевой статус выхода - это соглашение, сигнализирующее процессу, вызвавшему нашу программу, о том, что программа завершилась с ошибкой.</target>
        </trans-unit>
        <trans-unit id="482ebf3be5fe8298225b2e8f09ccc5e7f7c51bf1" translate="yes" xml:space="preserve">
          <source>To help IDE integration, the Rust project distributes the &lt;em&gt;Rust Language Server&lt;/em&gt; (&lt;code&gt;rls&lt;/code&gt;). This tool speaks the &lt;a href=&quot;http://langserver.org/&quot;&gt;Language Server Protocol&lt;/a&gt;, which is a specification for IDEs and programming languages to communicate with each other. Different clients can use the &lt;code&gt;rls&lt;/code&gt;, such as &lt;a href=&quot;https://marketplace.visualstudio.com/items?itemName=rust-lang.rust&quot;&gt;the Rust plug-in for Visual Studio Code&lt;/a&gt;.</source>
          <target state="translated">Чтобы помочь интеграции IDE, проект Rust распространяет &lt;em&gt;Rust Language Server&lt;/em&gt; ( &lt;code&gt;rls&lt;/code&gt; ). Этот инструмент использует &lt;a href=&quot;http://langserver.org/&quot;&gt;протокол языкового сервера&lt;/a&gt; , который является спецификацией для IDE и языков программирования для взаимодействия друг с другом. Различные клиенты могут использовать &lt;code&gt;rls&lt;/code&gt; , например &lt;a href=&quot;https://marketplace.visualstudio.com/items?itemName=rust-lang.rust&quot;&gt;подключаемый модуль Rust для Visual Studio Code&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="20b8f11e3eb504aaf128f283d04500f6915052b5" translate="yes" xml:space="preserve">
          <source>To illustrate situations where closures that can capture their environment are useful as function parameters, let&amp;rsquo;s move on to our next topic: iterators.</source>
          <target state="translated">Чтобы проиллюстрировать ситуации, когда замыкания, которые могут захватывать свою среду, полезны в качестве параметров функции, давайте перейдем к нашей следующей теме: итераторам.</target>
        </trans-unit>
        <trans-unit id="6bb8bf87527987f23e438b1c1bc78391e818826e" translate="yes" xml:space="preserve">
          <source>To illustrate the rules of ownership, we need a data type that is more complex than the ones we covered in the &lt;a href=&quot;ch03-02-data-types#data-types&quot;&gt;&amp;ldquo;Data Types&amp;rdquo;&lt;/a&gt; section of Chapter 3. The types covered previously are all stored on the stack and popped off the stack when their scope is over, but we want to look at data that is stored on the heap and explore how Rust knows when to clean up that data.</source>
          <target state="translated">Чтобы проиллюстрировать правила владения, нам нужен более сложный тип данных, чем те, которые мы рассмотрели в разделе &lt;a href=&quot;ch03-02-data-types#data-types&quot;&gt;&amp;laquo;Типы данных&amp;raquo;&lt;/a&gt; главы 3. Типы, рассмотренные ранее, все хранятся в стеке и извлекаются из стека, когда их область видимости закончился, но мы хотим посмотреть на данные, которые хранятся в куче, и выяснить, как Rust знает, когда нужно очистить эти данные.</target>
        </trans-unit>
        <trans-unit id="60712450a97e23097bf6dbe8ed26e2265884e8b7" translate="yes" xml:space="preserve">
          <source>To implement the behavior we want &lt;code&gt;gui&lt;/code&gt; to have, we&amp;rsquo;ll define a trait named &lt;code&gt;Draw&lt;/code&gt; that will have one method named &lt;code&gt;draw&lt;/code&gt;. Then we can define a vector that takes a &lt;em&gt;trait object&lt;/em&gt;. A trait object points to both an instance of a type implementing our specified trait as well as a table used to look up trait methods on that type at runtime. We create a trait object by specifying some sort of pointer, such as a &lt;code&gt;&amp;amp;&lt;/code&gt; reference or a &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; smart pointer, then the &lt;code&gt;dyn&lt;/code&gt; keyword, and then specifying the relevant trait. (We&amp;rsquo;ll talk about the reason trait objects must use a pointer in Chapter 19 in the section &lt;a href=&quot;ch19-04-advanced-types#dynamically-sized-types-and-the-sized-trait&quot;&gt;&amp;ldquo;Dynamically Sized Types and the &lt;code&gt;Sized&lt;/code&gt; Trait.&amp;rdquo;&lt;/a&gt;) We can use trait objects in place of a generic or concrete type. Wherever we use a trait object, Rust&amp;rsquo;s type system will ensure at compile time that any value used in that context will implement the trait object&amp;rsquo;s trait. Consequently, we don&amp;rsquo;t need to know all the possible types at compile time.</source>
          <target state="translated">Чтобы реализовать поведение, которое мы хотим, чтобы &lt;code&gt;gui&lt;/code&gt; имел, мы определим трейт с именем &lt;code&gt;Draw&lt;/code&gt; , который будет иметь один метод с именем &lt;code&gt;draw&lt;/code&gt; . Затем мы можем определить вектор, который принимает &lt;em&gt;объект-признак&lt;/em&gt; . Объект признака указывает как на экземпляр типа, реализующего нашу указанную особенность, так и на таблицу, используемую для поиска методов признака этого типа во время выполнения. Мы создаем объект признака, указывая какой-то указатель, такой как &lt;code&gt;&amp;amp;&lt;/code&gt; ссылка или умный указатель &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; , затем ключевое слово &lt;code&gt;dyn&lt;/code&gt; и затем определяя соответствующий признак. (О причинах, по которым типажные объекты должны использовать указатель, мы поговорим в главе 19 в разделе &lt;a href=&quot;ch19-04-advanced-types#dynamically-sized-types-and-the-sized-trait&quot;&gt;&amp;laquo;Типы с динамическим размером и &lt;code&gt;Sized&lt;/code&gt; Черта.&quot; &lt;/a&gt;) Мы можем использовать типажные объекты вместо общего или конкретного типа. Везде, где мы используем объект-признак, система типов Rust гарантирует во время компиляции, что любое значение, используемое в этом контексте, будет реализовывать признак объекта-признака. Следовательно, нам не нужно знать все возможные типы во время компиляции.</target>
        </trans-unit>
        <trans-unit id="f5e8a5c28a454d1f90112a6c60c0f8aea2b5196d" translate="yes" xml:space="preserve">
          <source>To improve our program, we&amp;rsquo;ll fix four problems that have to do with the program&amp;rsquo;s structure and how it&amp;rsquo;s handling potential errors.</source>
          <target state="translated">Чтобы улучшить нашу программу, мы исправим четыре проблемы, которые связаны со структурой программы и тем, как она обрабатывает потенциальные ошибки.</target>
        </trans-unit>
        <trans-unit id="bf9b4462d1a02f4d70e5d13cf8540c79a5e14d1a" translate="yes" xml:space="preserve">
          <source>To incorporate the &lt;code&gt;Message&lt;/code&gt; enum, we need to change &lt;code&gt;Job&lt;/code&gt; to &lt;code&gt;Message&lt;/code&gt; in two places: the definition of &lt;code&gt;ThreadPool&lt;/code&gt; and the signature of &lt;code&gt;Worker::new&lt;/code&gt;. The &lt;code&gt;execute&lt;/code&gt; method of &lt;code&gt;ThreadPool&lt;/code&gt; needs to send jobs wrapped in the &lt;code&gt;Message::NewJob&lt;/code&gt; variant. Then, in &lt;code&gt;Worker::new&lt;/code&gt; where a &lt;code&gt;Message&lt;/code&gt; is received from the channel, the job will be processed if the &lt;code&gt;NewJob&lt;/code&gt; variant is received, and the thread will break out of the loop if the &lt;code&gt;Terminate&lt;/code&gt; variant is received.</source>
          <target state="translated">Чтобы включить перечисление &lt;code&gt;Message&lt;/code&gt; , нам нужно изменить &lt;code&gt;Job&lt;/code&gt; на &lt;code&gt;Message&lt;/code&gt; в двух местах: в определении &lt;code&gt;ThreadPool&lt;/code&gt; и в подписи &lt;code&gt;Worker::new&lt;/code&gt; . &lt;code&gt;execute&lt;/code&gt; метод &lt;code&gt;ThreadPool&lt;/code&gt; необходим для отправки заданий , завернутых в &lt;code&gt;Message::NewJob&lt;/code&gt; варианта. Затем в &lt;code&gt;Worker::new&lt;/code&gt; где &lt;code&gt;Message&lt;/code&gt; получено из канала, задание будет обработано, если &lt;code&gt;NewJob&lt;/code&gt; вариант NewJob , и поток выйдет из цикла, если получен вариант &lt;code&gt;Terminate&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0f9206704ddf29e2ebea715304ccfd9e3f3ba5f3" translate="yes" xml:space="preserve">
          <source>To install &lt;code&gt;rustfmt&lt;/code&gt;, enter the following:</source>
          <target state="translated">Чтобы установить &lt;code&gt;rustfmt&lt;/code&gt; , введите следующее:</target>
        </trans-unit>
        <trans-unit id="35fe5fa9574aed79cc4c533785f5e0d142e0e320" translate="yes" xml:space="preserve">
          <source>To install Clippy, enter the following:</source>
          <target state="translated">Чтобы установить Clippy,введите следующее:</target>
        </trans-unit>
        <trans-unit id="44d584ca391c2045c83ab8a58e67b2e401ab33be" translate="yes" xml:space="preserve">
          <source>To install the &lt;code&gt;rls&lt;/code&gt;, enter the following:</source>
          <target state="translated">Чтобы установить &lt;code&gt;rls&lt;/code&gt; , введите следующее:</target>
        </trans-unit>
        <trans-unit id="71a54c2518d0f86ead8ba016e32755cf1ca226ed" translate="yes" xml:space="preserve">
          <source>To interact with a &lt;code&gt;Formatter&lt;/code&gt;, you'll call various methods to change the various options related to formatting. For examples, please see the documentation of the methods defined on &lt;code&gt;Formatter&lt;/code&gt; below.</source>
          <target state="translated">Для взаимодействия с &lt;code&gt;Formatter&lt;/code&gt; вы вызовете различные методы, чтобы изменить различные параметры, связанные с форматированием. Примеры см. В документации методов, определенных в &lt;code&gt;Formatter&lt;/code&gt; ниже.</target>
        </trans-unit>
        <trans-unit id="b498caa788bb95865cf7ae29f319574a69dd854b" translate="yes" xml:space="preserve">
          <source>To isolate unsafe code as much as possible, it&amp;rsquo;s best to enclose unsafe code within a safe abstraction and provide a safe API, which we&amp;rsquo;ll discuss later in the chapter when we examine unsafe functions and methods. Parts of the standard library are implemented as safe abstractions over unsafe code that has been audited. Wrapping unsafe code in a safe abstraction prevents uses of &lt;code&gt;unsafe&lt;/code&gt; from leaking out into all the places that you or your users might want to use the functionality implemented with &lt;code&gt;unsafe&lt;/code&gt; code, because using a safe abstraction is safe.</source>
          <target state="translated">Чтобы максимально изолировать небезопасный код, лучше всего заключить небезопасный код в безопасную абстракцию и предоставить безопасный API, который мы обсудим позже в этой главе, когда мы исследуем небезопасные функции и методы. Части стандартной библиотеки реализованы как безопасные абстракции над небезопасным кодом, который прошел аудит. Обертывание небезопасного кода в безопасной абстракции препятствует использованию &lt;code&gt;unsafe&lt;/code&gt; от утечки во все места , которые вы или ваши пользователи могли бы хотеть , чтобы использовать функциональные возможности реализованы с &lt;code&gt;unsafe&lt;/code&gt; кодом, потому что с помощью безопасной абстракции является безопасным.</target>
        </trans-unit>
        <trans-unit id="a6753382b748af96b119a035edd05c7a836b948d" translate="yes" xml:space="preserve">
          <source>To learn about the other kinds of collections provided by the standard library, see &lt;a href=&quot;../std/collections/index&quot;&gt;the documentation&lt;/a&gt;.</source>
          <target state="translated">Чтобы узнать о других типах коллекций, предоставляемых стандартной библиотекой, см. &lt;a href=&quot;../std/collections/index&quot;&gt;Документацию&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="0dbbd03b2e667a7e6b225ed1de228878e32e5817" translate="yes" xml:space="preserve">
          <source>To learn more about allowing access, see the documentation for the &lt;a href=&quot;keyword.pub&quot;&gt;&lt;code&gt;pub&lt;/code&gt;&lt;/a&gt; keyword.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c2736d1e6ef2a3faad24038e53f6bde645f76d87" translate="yes" xml:space="preserve">
          <source>To lowercase ASCII characters in addition to non-ASCII characters, use &lt;a href=&quot;#method.to_lowercase&quot;&gt;&lt;code&gt;to_lowercase&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Чтобы строчные символы ASCII в дополнение к символам не-ASCII, используйте &lt;a href=&quot;#method.to_lowercase&quot;&gt; &lt;code&gt;to_lowercase&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="e94e0d4cfd63a504442f11c93df0afa614a2f0d4" translate="yes" xml:space="preserve">
          <source>To lowercase ASCII characters in addition to non-ASCII characters, use &lt;a href=&quot;../primitive.str#method.to_lowercase&quot;&gt;&lt;code&gt;str::to_lowercase&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Для строчных символов ASCII в дополнение к символам, отличным от ASCII, используйте &lt;a href=&quot;../primitive.str#method.to_lowercase&quot;&gt; &lt;code&gt;str::to_lowercase&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="63a5fbbc07007136d2c958a62c0c4ca27bbb449c" translate="yes" xml:space="preserve">
          <source>To lowercase ASCII characters in addition to non-ASCII characters, use &lt;a href=&quot;https://doc.rust-lang.org/nightly/std/primitive.str.html#method.to_lowercase&quot;&gt;&lt;code&gt;str::to_lowercase&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5ab2513e3de2d60d109900818fb2429fd91b99d2" translate="yes" xml:space="preserve">
          <source>To lowercase the value in-place, use &lt;a href=&quot;#method.make_ascii_lowercase&quot;&gt;&lt;code&gt;make_ascii_lowercase&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Чтобы &lt;a href=&quot;#method.make_ascii_lowercase&quot;&gt; &lt;code&gt;make_ascii_lowercase&lt;/code&gt; &lt;/a&gt; значение на месте, используйте make_ascii_lowercase .</target>
        </trans-unit>
        <trans-unit id="ef146744579c27e21ed699daf39b3a3250767c77" translate="yes" xml:space="preserve">
          <source>To lowercase the value in-place, use &lt;a href=&quot;#tymethod.make_ascii_lowercase&quot;&gt;&lt;code&gt;make_ascii_lowercase&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Чтобы &lt;a href=&quot;#tymethod.make_ascii_lowercase&quot;&gt; &lt;code&gt;make_ascii_lowercase&lt;/code&gt; &lt;/a&gt; значение на месте, используйте make_ascii_lowercase .</target>
        </trans-unit>
        <trans-unit id="67608258687aa72b226fb9d75937d3aa5583b343" translate="yes" xml:space="preserve">
          <source>To lowercase the value in-place, use &lt;a href=&quot;../primitive.str#method.make_ascii_lowercase&quot;&gt;&lt;code&gt;make_ascii_lowercase&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0c6481a0667301c8cf17a1fc74a4e7ea446e2ab9" translate="yes" xml:space="preserve">
          <source>To lowercase the value in-place, use &lt;a href=&quot;../primitive.u8#method.make_ascii_lowercase&quot;&gt;&lt;code&gt;make_ascii_lowercase&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6a33f76160389c879809056277f95cb426933c88" translate="yes" xml:space="preserve">
          <source>To lowercase the value in-place, use &lt;a href=&quot;primitive.str#method.make_ascii_lowercase&quot;&gt;&lt;code&gt;make_ascii_lowercase&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="13cfe6c801715fff699dce762afc98ca7e8ff1fa" translate="yes" xml:space="preserve">
          <source>To lowercase the value in-place, use &lt;a href=&quot;primitive.u8#method.make_ascii_lowercase&quot;&gt;&lt;code&gt;make_ascii_lowercase&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4a0549668b9dec3f8fe6cc76087d773d360d9c8f" translate="yes" xml:space="preserve">
          <source>To lowercase the value in-place, use &lt;a href=&quot;struct.osstr#method.make_ascii_lowercase&quot;&gt;&lt;code&gt;OsStr::make_ascii_lowercase&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dd861f60ceee6cd011393e0efbd8975fcac733a1" translate="yes" xml:space="preserve">
          <source>To lowercase the value in-place, use &lt;a href=&quot;trait.asciiext#tymethod.make_ascii_lowercase&quot;&gt;&lt;code&gt;make_ascii_lowercase&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="21e4a3f169edf0cfb32c3841ee2bea7479d1a5e1" translate="yes" xml:space="preserve">
          <source>To make a struct that holds a closure, we need to specify the type of the closure, because a struct definition needs to know the types of each of its fields. Each closure instance has its own unique anonymous type: that is, even if two closures have the same signature, their types are still considered different. To define structs, enums, or function parameters that use closures, we use generics and trait bounds, as we discussed in Chapter 10.</source>
          <target state="translated">Для того чтобы сделать структуру,удерживающую закрытие,нам необходимо указать тип закрытия,потому что определение структуры должно знать типы каждого из ее полей.Каждый экземпляр закрытия имеет свой уникальный анонимный тип:то есть,даже если два закрытия имеют одну и ту же сигнатуру,их типы все равно считаются разными.Для определения структур,перечислений или параметров функций,использующих замыкание,мы используем генерические и трейтовые границы,как мы обсуждали в главе 10.</target>
        </trans-unit>
        <trans-unit id="f551bbd5751f05a17c69a727dd31a7a20561b4f8" translate="yes" xml:space="preserve">
          <source>To make it valid, write the following:</source>
          <target state="translated">Чтобы сделать его действительным,напишите следующее:</target>
        </trans-unit>
        <trans-unit id="11b284dcb2ba4ceac9f02b253f7b17b9698ddf3b" translate="yes" xml:space="preserve">
          <source>To make struct &lt;code&gt;Bar&lt;/code&gt; only visible in module &lt;code&gt;foo&lt;/code&gt; the &lt;code&gt;in&lt;/code&gt; keyword should be used:</source>
          <target state="translated">Для того, чтобы структура &lt;code&gt;Bar&lt;/code&gt; отображается только в модуле &lt;code&gt;foo&lt;/code&gt; &lt;code&gt;in&lt;/code&gt; ключевом слове должно быть использовано:</target>
        </trans-unit>
        <trans-unit id="fc2021393a94974377e271f291f7d97ada3aa985" translate="yes" xml:space="preserve">
          <source>To make the child node aware of its parent, we need to add a &lt;code&gt;parent&lt;/code&gt; field to our &lt;code&gt;Node&lt;/code&gt; struct definition. The trouble is in deciding what the type of &lt;code&gt;parent&lt;/code&gt; should be. We know it can&amp;rsquo;t contain an &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt;, because that would create a reference cycle with &lt;code&gt;leaf.parent&lt;/code&gt; pointing to &lt;code&gt;branch&lt;/code&gt; and &lt;code&gt;branch.children&lt;/code&gt; pointing to &lt;code&gt;leaf&lt;/code&gt;, which would cause their &lt;code&gt;strong_count&lt;/code&gt; values to never be 0.</source>
          <target state="translated">Чтобы дочерний узел знал о своем родителе, нам нужно добавить &lt;code&gt;parent&lt;/code&gt; поле к нашему определению структуры &lt;code&gt;Node&lt;/code&gt; . Проблема в том, чтобы решить, каким должен быть &lt;code&gt;parent&lt;/code&gt; . Мы знаем, что он не может содержать &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; , потому что это создаст ссылочный цикл с &lt;code&gt;leaf.parent&lt;/code&gt; , указывающим на &lt;code&gt;branch&lt;/code&gt; и &lt;code&gt;branch.children&lt;/code&gt; , указывающим на &lt;code&gt;leaf&lt;/code&gt; , что приведет к тому, что их значения &lt;code&gt;strong_count&lt;/code&gt; никогда не будут равны 0.</target>
        </trans-unit>
        <trans-unit id="d22320c45b662fb11c8113dfcbe82f4c5091e1e8" translate="yes" xml:space="preserve">
          <source>To make this work, every element has pointers to its predecessor and successor in the list. Elements can only be added when they are pinned, because moving the elements around would invalidate the pointers. Moreover, the &lt;a href=&quot;../ops/trait.drop#tymethod.drop&quot;&gt;&lt;code&gt;Drop&lt;/code&gt;&lt;/a&gt; implementation of a linked list element will patch the pointers of its predecessor and successor to remove itself from the list.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b7b483d37995579653b3a66a999867efa81ab8f9" translate="yes" xml:space="preserve">
          <source>To make this work, every element has pointers to its predecessor and successor in the list. Elements can only be added when they are pinned, because moving the elements around would invalidate the pointers. Moreover, the &lt;code&gt;Drop&lt;/code&gt; implementation of a linked list element will patch the pointers of its predecessor and successor to remove itself from the list.</source>
          <target state="translated">Чтобы это работало, каждый элемент имеет указатели на своего предшественника и преемника в списке. Элементы могут быть добавлены только тогда, когда они закреплены, потому что перемещение элементов сделает указатели недействительными. Более того, реализация &lt;code&gt;Drop&lt;/code&gt; элемента связанного списка исправит указатели своего предшественника и преемника, чтобы удалить себя из списка.</target>
        </trans-unit>
        <trans-unit id="addd7b5a3eab2bcc498269d4b5030ddd2652429e" translate="yes" xml:space="preserve">
          <source>To many people, polymorphism is synonymous with inheritance. But it&amp;rsquo;s actually a more general concept that refers to code that can work with data of multiple types. For inheritance, those types are generally subclasses.</source>
          <target state="translated">Для многих полиморфизм является синонимом наследования. Но на самом деле это более общая концепция, относящаяся к коду, который может работать с данными нескольких типов. Для наследования эти типы обычно являются подклассами.</target>
        </trans-unit>
        <trans-unit id="e542c92de7f2ff8b0e65e4059a685882563b6c24" translate="yes" xml:space="preserve">
          <source>To measure elapsed time reliably, use &lt;a href=&quot;struct.instant&quot;&gt;&lt;code&gt;Instant&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c1808ba5fbc9308fb8282df842ce731348ff5abf" translate="yes" xml:space="preserve">
          <source>To model pointers to opaque types in FFI, until &lt;code&gt;extern type&lt;/code&gt; is stabilized, it is recommended to use a newtype wrapper around an empty byte array. See the &lt;a href=&quot;https://doc.rust-lang.org/nomicon/ffi.html#representing-opaque-structs&quot;&gt;Nomicon&lt;/a&gt; for details.</source>
          <target state="translated">Для моделирования указателей на непрозрачные типы в FFI, пока &lt;code&gt;extern type&lt;/code&gt; не стабилизируется, рекомендуется использовать оболочку newtype вокруг пустого байтового массива. Подробности см. В &lt;a href=&quot;https://doc.rust-lang.org/nomicon/ffi.html#representing-opaque-structs&quot;&gt;Nomicon&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="92f1c0826630a6e44e7c7249d92c4a26d91785e3" translate="yes" xml:space="preserve">
          <source>To obtain error description as a string, use &lt;code&gt;to_string()&lt;/code&gt;.</source>
          <target state="translated">Чтобы получить описание ошибки в виде строки, используйте &lt;code&gt;to_string()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0354419a51c55b7a4f425ab3291d7b635b1d30c9" translate="yes" xml:space="preserve">
          <source>To parameterize the types in the new function we&amp;rsquo;ll define, we need to name the type parameter, just as we do for the value parameters to a function. You can use any identifier as a type parameter name. But we&amp;rsquo;ll use &lt;code&gt;T&lt;/code&gt; because, by convention, parameter names in Rust are short, often just a letter, and Rust&amp;rsquo;s type-naming convention is CamelCase. Short for &amp;ldquo;type,&amp;rdquo; &lt;code&gt;T&lt;/code&gt; is the default choice of most Rust programmers.</source>
          <target state="translated">Чтобы параметризовать типы в новой функции, которую мы определим, нам нужно назвать параметр типа, как мы делаем это для параметров значения функции. В качестве имени параметра типа можно использовать любой идентификатор. Но мы будем использовать &lt;code&gt;T&lt;/code&gt; , потому что по соглашению имена параметров в Rust короткие, часто всего лишь буква, а соглашение об именах типов в Rust - CamelCase. Сокращенно от &amp;laquo;type&amp;raquo;, &lt;code&gt;T&lt;/code&gt; - это выбор по умолчанию большинства программистов на Rust.</target>
        </trans-unit>
        <trans-unit id="075fa626d389c13dd84df398e2b600267ba414fd" translate="yes" xml:space="preserve">
          <source>To parse a path, you can create a &lt;a href=&quot;struct.path&quot;&gt;&lt;code&gt;Path&lt;/code&gt;&lt;/a&gt; slice from a &lt;a href=&quot;../primitive.str&quot;&gt;&lt;code&gt;str&lt;/code&gt;&lt;/a&gt; slice and start asking questions:</source>
          <target state="translated">Чтобы проанализировать путь, вы можете создать срез &lt;a href=&quot;struct.path&quot;&gt; &lt;code&gt;Path&lt;/code&gt; &lt;/a&gt; из среза &lt;a href=&quot;../primitive.str&quot;&gt; &lt;code&gt;str&lt;/code&gt; &lt;/a&gt; и начать задавать вопросы:</target>
        </trans-unit>
        <trans-unit id="a91f9eb8a09ec43223d4a3a69ca02691cc9a5535" translate="yes" xml:space="preserve">
          <source>To parse a path, you can create a &lt;a href=&quot;struct.path&quot;&gt;&lt;code&gt;Path&lt;/code&gt;&lt;/a&gt; slice from a &lt;a href=&quot;https://doc.rust-lang.org/nightly/std/primitive.str.html&quot;&gt;&lt;code&gt;str&lt;/code&gt;&lt;/a&gt; slice and start asking questions:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f7f45d830d337ce8a4f493ea8b6014f97c0fb6eb" translate="yes" xml:space="preserve">
          <source>To pass a single argument see &lt;a href=&quot;#method.arg&quot;&gt;&lt;code&gt;arg&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Чтобы передать один аргумент, см. &lt;a href=&quot;#method.arg&quot;&gt; &lt;code&gt;arg&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="30a7bace681f793e8820181cf7574f94401b280d" translate="yes" xml:space="preserve">
          <source>To pass a single argument see &lt;a href=&quot;struct.command#method.arg&quot;&gt;&lt;code&gt;arg&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2f3d970a69fb7cac0396fffe3d7483eb856d59e9" translate="yes" xml:space="preserve">
          <source>To pass multiple arguments see &lt;a href=&quot;#method.args&quot;&gt;&lt;code&gt;args&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Чтобы передать несколько аргументов, см. &lt;a href=&quot;#method.args&quot;&gt; &lt;code&gt;args&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="f24e6cb8e923f8cee5441a6183ab318931f04cf1" translate="yes" xml:space="preserve">
          <source>To pass multiple arguments see &lt;a href=&quot;struct.command#method.args&quot;&gt;&lt;code&gt;args&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cdc2c49e6f2624612dfa9af5bb72c9d5988a62aa" translate="yes" xml:space="preserve">
          <source>To perform async recursion, the &lt;code&gt;async fn&lt;/code&gt; needs to be desugared such that the &lt;code&gt;Future&lt;/code&gt; is explicit in the return type:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="af6d76d570505ba666bcda7baecd5871dcf2d3a2" translate="yes" xml:space="preserve">
          <source>To prevent this scenario, we first put all of our &lt;code&gt;Terminate&lt;/code&gt; messages on the channel in one loop; then we join on all the threads in another loop. Each worker will stop receiving requests on the channel once it gets a terminate message. So, we can be sure that if we send the same number of terminate messages as there are workers, each worker will receive a terminate message before &lt;code&gt;join&lt;/code&gt; is called on its thread.</source>
          <target state="translated">Чтобы предотвратить этот сценарий, мы сначала помещаем все наши сообщения &lt;code&gt;Terminate&lt;/code&gt; в канал в один цикл; затем мы объединяем все потоки в другой цикл. Каждый рабочий перестанет получать запросы на канале, как только получит сообщение о завершении. Таким образом, мы можем быть уверены , что если мы посылаем такое же количество заканчивающихся сообщений, есть рабочие, каждый работник получит сообщение , прежде чем прекратить &lt;code&gt;join&lt;/code&gt; называется на своей нити.</target>
        </trans-unit>
        <trans-unit id="add5b6cf5a307a5e6af227f8cc2b7b101db763e7" translate="yes" xml:space="preserve">
          <source>To protect your program from this sort of vulnerability, if you try to read an element at an index that doesn&amp;rsquo;t exist, Rust will stop execution and refuse to continue. Let&amp;rsquo;s try it and see:</source>
          <target state="translated">Чтобы защитить вашу программу от такой уязвимости, если вы попытаетесь прочитать элемент по несуществующему индексу, Rust остановит выполнение и откажется продолжить. Попробуем и увидим:</target>
        </trans-unit>
        <trans-unit id="fb3ab9d085bae205d404a7ba202d1b27f55784c2" translate="yes" xml:space="preserve">
          <source>To recover from a poisoned mutex:</source>
          <target state="translated">Чтобы оправиться от отравленного мьютекса:</target>
        </trans-unit>
        <trans-unit id="e0f842e4093b64f03623cd49c1c17718cfbe95dc" translate="yes" xml:space="preserve">
          <source>To remove the internal organization from the public API, we can modify the &lt;code&gt;art&lt;/code&gt; crate code in Listing 14-3 to add &lt;code&gt;pub use&lt;/code&gt; statements to re-export the items at the top level, as shown in Listing 14-5:</source>
          <target state="translated">Чтобы удалить внутреннюю организацию из общедоступного API, мы можем изменить код &lt;code&gt;art&lt;/code&gt; ящика в Листинге 14-3, чтобы добавить операторы &lt;code&gt;pub use&lt;/code&gt; для повторного экспорта элементов на верхнем уровне, как показано в Листинге 14-5:</target>
        </trans-unit>
        <trans-unit id="5b0280b8819ec3479f9646e558c6310c8632f058" translate="yes" xml:space="preserve">
          <source>To resolve the ambiguity, the programmer may refer to their desired method or function using more specific paths, types, or traits.</source>
          <target state="translated">Для устранения неоднозначности,программист может обратиться к желаемому методу или функции,используя более специфические пути,типы или черты.</target>
        </trans-unit>
        <trans-unit id="40806bdac66961c97f14caf3bdb5bd4161107da4" translate="yes" xml:space="preserve">
          <source>To resolve this error use the concrete type:</source>
          <target state="translated">Для устранения этой ошибки используйте конкретный тип:</target>
        </trans-unit>
        <trans-unit id="bba50911f39e97c448e79f8065cbe76ff37d962c" translate="yes" xml:space="preserve">
          <source>To resolve this error, use a concrete type for the intermediate expression:</source>
          <target state="translated">Для устранения этой ошибки используйте конкретный тип для промежуточного выражения:</target>
        </trans-unit>
        <trans-unit id="336222d4e74857a65248fce76ba73fa02fe1c00a" translate="yes" xml:space="preserve">
          <source>To return a new lowercased value without modifying the existing one, use &lt;a href=&quot;#method.to_ascii_lowercase&quot;&gt;&lt;code&gt;to_ascii_lowercase&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Чтобы вернуть новое значение в нижнем регистре без изменения существующего, используйте &lt;a href=&quot;#method.to_ascii_lowercase&quot;&gt; &lt;code&gt;to_ascii_lowercase&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="c6eff45b987ef30ba84b5033a569d4671d667c28" translate="yes" xml:space="preserve">
          <source>To return a new lowercased value without modifying the existing one, use &lt;a href=&quot;#tymethod.to_ascii_lowercase&quot;&gt;&lt;code&gt;to_ascii_lowercase&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Чтобы вернуть новое значение в нижнем регистре без изменения существующего, используйте &lt;a href=&quot;#tymethod.to_ascii_lowercase&quot;&gt; &lt;code&gt;to_ascii_lowercase&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="8a6b8af0a2d7bad5168dd7563a5faab87aca3dc2" translate="yes" xml:space="preserve">
          <source>To return a new lowercased value without modifying the existing one, use &lt;a href=&quot;struct.osstr#method.to_ascii_lowercase&quot;&gt;&lt;code&gt;OsStr::to_ascii_lowercase&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="99049f339cacaaabe4b0c50ed3b0d3a63d16bda2" translate="yes" xml:space="preserve">
          <source>To return a new lowercased value without modifying the existing one, use &lt;a href=&quot;trait.asciiext#tymethod.to_ascii_lowercase&quot;&gt;&lt;code&gt;to_ascii_lowercase&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4fc2431e450771dead21af33dda64aadfaf2de37" translate="yes" xml:space="preserve">
          <source>To return a new uppercased value without modifying the existing one, use &lt;a href=&quot;#method.to_ascii_uppercase&quot;&gt;&lt;code&gt;to_ascii_uppercase&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Чтобы вернуть новое значение в верхнем регистре без изменения существующего, используйте &lt;a href=&quot;#method.to_ascii_uppercase&quot;&gt; &lt;code&gt;to_ascii_uppercase&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="3f98861983753d9167b54a4036b6c14ee7465a79" translate="yes" xml:space="preserve">
          <source>To return a new uppercased value without modifying the existing one, use &lt;a href=&quot;#tymethod.to_ascii_uppercase&quot;&gt;&lt;code&gt;to_ascii_uppercase&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Чтобы вернуть новое значение в верхнем регистре без изменения существующего, используйте &lt;a href=&quot;#tymethod.to_ascii_uppercase&quot;&gt; &lt;code&gt;to_ascii_uppercase&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="b269c5e12c3307032fd7c3ae09e5e6e5ef1b2811" translate="yes" xml:space="preserve">
          <source>To return a new uppercased value without modifying the existing one, use &lt;a href=&quot;struct.osstr#method.to_ascii_uppercase&quot;&gt;&lt;code&gt;OsStr::to_ascii_uppercase&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b8bdcca7b53a29d96e387d59f21508e247003424" translate="yes" xml:space="preserve">
          <source>To return a new uppercased value without modifying the existing one, use &lt;a href=&quot;trait.asciiext#tymethod.to_ascii_uppercase&quot;&gt;&lt;code&gt;to_ascii_uppercase&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b3eb99467dbfaa372dd0858f79acae31153782c2" translate="yes" xml:space="preserve">
          <source>To round out this project, we&amp;rsquo;ll briefly demonstrate how to work with environment variables and how to print to standard error, both of which are useful when you&amp;rsquo;re writing command line programs.</source>
          <target state="translated">Чтобы завершить этот проект, мы вкратце продемонстрируем, как работать с переменными среды и как выполнять печать со стандартными ошибками, которые полезны при написании программ командной строки.</target>
        </trans-unit>
        <trans-unit id="1d354bd55577a0ae6fc2f95a62753d1f62548897" translate="yes" xml:space="preserve">
          <source>To run Clippy&amp;rsquo;s lints on any Cargo project, enter the following:</source>
          <target state="translated">Чтобы запустить lints Clippy в любом проекте Cargo, введите следующее:</target>
        </trans-unit>
        <trans-unit id="38b636b1ad46eb0add3e75f7e9d97cbfc1d6f9d8" translate="yes" xml:space="preserve">
          <source>To run the binary crate from the &lt;em&gt;add&lt;/em&gt; directory, we can specify which package in the workspace we want to run by using the &lt;code&gt;-p&lt;/code&gt; argument and the package name with &lt;code&gt;cargo run&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d744134b2344eca07ba0f4cf9819619cc570948e" translate="yes" xml:space="preserve">
          <source>To run the binary crate from the &lt;em&gt;add&lt;/em&gt; directory, we need to specify which package in the workspace we want to use by using the &lt;code&gt;-p&lt;/code&gt; argument and the package name with &lt;code&gt;cargo run&lt;/code&gt;:</source>
          <target state="translated">Чтобы запустить двоичный ящик из каталога &lt;em&gt;добавления&lt;/em&gt; , нам нужно указать, какой пакет в рабочей области мы хотим использовать, используя аргумент &lt;code&gt;-p&lt;/code&gt; и имя пакета с &lt;code&gt;cargo run&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="8bc4f6782a835ae358ae31b6f96421e46fc704f9" translate="yes" xml:space="preserve">
          <source>To see deref coercion in action, let&amp;rsquo;s use the &lt;code&gt;MyBox&amp;lt;T&amp;gt;&lt;/code&gt; type we defined in Listing 15-8 as well as the implementation of &lt;code&gt;Deref&lt;/code&gt; that we added in Listing 15-10. Listing 15-11 shows the definition of a function that has a string slice parameter:</source>
          <target state="translated">Чтобы увидеть приведение deref в действии, давайте воспользуемся &lt;code&gt;MyBox&amp;lt;T&amp;gt;&lt;/code&gt; мы определили в листинге 15-8, а также реализацией &lt;code&gt;Deref&lt;/code&gt; , которую мы добавили в листинге 15-10. В листинге 15-11 показано определение функции, имеющей параметр среза строки:</target>
        </trans-unit>
        <trans-unit id="0acf6acdd95133438e45baebe84203f1ed05a023" translate="yes" xml:space="preserve">
          <source>To see destructors in action, let's take a look at the following program:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="46d871d99b751923bfc8199196805ccdb06df1da" translate="yes" xml:space="preserve">
          <source>To see the pattern matching aspect of &lt;code&gt;let&lt;/code&gt; more clearly, consider Listing 18-4, which uses a pattern with &lt;code&gt;let&lt;/code&gt; to destructure a tuple.</source>
          <target state="translated">Чтобы более четко увидеть аспект сопоставления с образцом в &lt;code&gt;let&lt;/code&gt; , рассмотрим листинг 18-4, в котором используется образец с &lt;code&gt;let&lt;/code&gt; для деструкции кортежа.</target>
        </trans-unit>
        <trans-unit id="76ec71028cdc11f78838d4138f08838dc91ccb67" translate="yes" xml:space="preserve">
          <source>To see this code in action, let&amp;rsquo;s modify &lt;code&gt;main&lt;/code&gt; to accept only two requests before gracefully shutting down the server, as shown in Listing 20-25.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="be7f1edd4187697ed5c2e4f6dc220a6d712ca92f" translate="yes" xml:space="preserve">
          <source>To see this code in action, let&amp;rsquo;s modify &lt;code&gt;main&lt;/code&gt; to accept only two requests before gracefully shutting down the server, as shown in Listing 20-26.</source>
          <target state="translated">Чтобы увидеть этот код в действии, давайте изменим &lt;code&gt;main&lt;/code&gt; так, чтобы он принимал только два запроса, прежде чем корректно завершить работу сервера, как показано в листинге 20-26.</target>
        </trans-unit>
        <trans-unit id="a7940de3192aef0247f83e244b60b2d3b6e58939" translate="yes" xml:space="preserve">
          <source>To see what happens when a &lt;code&gt;should_panic&lt;/code&gt; test with an &lt;code&gt;expected&lt;/code&gt; message fails, let&amp;rsquo;s again introduce a bug into our code by swapping the bodies of the &lt;code&gt;if value &amp;lt; 1&lt;/code&gt; and the &lt;code&gt;else if value &amp;gt; 100&lt;/code&gt; blocks:</source>
          <target state="translated">Чтобы увидеть, что происходит, когда тест &lt;code&gt;should_panic&lt;/code&gt; с &lt;code&gt;expected&lt;/code&gt; сообщением терпит неудачу, давайте снова внесем ошибку в наш код, поменяв местами тела блоков &lt;code&gt;if value &amp;lt; 1&lt;/code&gt; и &lt;code&gt;else if value &amp;gt; 100&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="8576f35029f2c29efb15d99933a9de10a34dcb7b" translate="yes" xml:space="preserve">
          <source>To see why that last example was allowed, you need to understand the general rule. Unfortunately this rule is a bit tricky to state. Consider an &lt;code&gt;impl&lt;/code&gt;:</source>
          <target state="translated">Чтобы понять, почему этот последний пример был разрешен, вам нужно понять общее правило. К сожалению, это правило сложно сформулировать. Рассмотрим &lt;code&gt;impl&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="a14fdfe6208af1cb452de86927ad706e8201fb30" translate="yes" xml:space="preserve">
          <source>To seek without discarding the internal buffer, use &lt;a href=&quot;struct.bufreader#method.seek_relative&quot;&gt;&lt;code&gt;BufReader::seek_relative&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Чтобы искать, не отбрасывая внутренний буфер, используйте &lt;a href=&quot;struct.bufreader#method.seek_relative&quot;&gt; &lt;code&gt;BufReader::seek_relative&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="0d7ebdd071ebe03ef9670cc1129fd6804ce04dfa" translate="yes" xml:space="preserve">
          <source>To service better ergonomics, patterns operate in different &lt;em&gt;binding modes&lt;/em&gt; in order to make it easier to bind references to values. When a reference value is matched by a non-reference pattern, it will be automatically treated as a &lt;code&gt;ref&lt;/code&gt; or &lt;code&gt;ref mut&lt;/code&gt; binding. Example:</source>
          <target state="translated">Для улучшения эргономики шаблоны работают в разных &lt;em&gt;режимах привязки&lt;/em&gt; , чтобы упростить привязку ссылок к значениям. Когда значение ссылки совпадает с шаблоном, не являющимся ссылкой, оно автоматически обрабатывается как привязка &lt;code&gt;ref&lt;/code&gt; или &lt;code&gt;ref mut&lt;/code&gt; . Пример:</target>
        </trans-unit>
        <trans-unit id="a3d0badb6b5b316657f5cb3fda3963d136213146" translate="yes" xml:space="preserve">
          <source>To set up a new project, go to the &lt;em&gt;projects&lt;/em&gt; directory that you created in Chapter 1 and make a new project using Cargo, like so:</source>
          <target state="translated">Чтобы создать новый проект, перейдите в каталог &lt;em&gt;проектов,&lt;/em&gt; который вы создали в главе 1, и создайте новый проект с помощью Cargo, например:</target>
        </trans-unit>
        <trans-unit id="58b49ff05dd6fb8ece812d318c3efc42db98cdbb" translate="yes" xml:space="preserve">
          <source>To show Rust where to find an item in a module tree, we use a path in the same way we use a path when navigating a filesystem. If we want to call a function, we need to know its path.</source>
          <target state="translated">Чтобы показать Rust,где найти элемент в дереве модулей,мы используем путь точно так же,как мы используем путь при навигации по файловой системе.Если мы хотим вызвать функцию,нам нужно знать ее путь.</target>
        </trans-unit>
        <trans-unit id="da1e1e9f2dd7b1c40ddec9ecef1f4d928ddb4f25" translate="yes" xml:space="preserve">
          <source>To silence this warning, edit your code to use an explicit bound. Most of the time, this means that you will want to change the signature of a function that you are calling. For example, if the error is reported on a call like &lt;code&gt;foo(x)&lt;/code&gt;, and &lt;code&gt;foo&lt;/code&gt; is defined as follows:</source>
          <target state="translated">Чтобы отключить это предупреждение, отредактируйте свой код, чтобы использовать явную привязку. В большинстве случаев это означает, что вы захотите изменить подпись вызываемой функции. Например, если об ошибке сообщается при таком вызове, как &lt;code&gt;foo(x)&lt;/code&gt; , а &lt;code&gt;foo&lt;/code&gt; определяется следующим образом:</target>
        </trans-unit>
        <trans-unit id="0ae8db76a02a996f64985b9fc49d037c6c1ea0c5" translate="yes" xml:space="preserve">
          <source>To solve this error you can use conditional compilation:</source>
          <target state="translated">Для решения этой ошибки можно использовать условную компиляцию:</target>
        </trans-unit>
        <trans-unit id="384aa431a554e0c72ecb63fe411f4d1d9ac5425c" translate="yes" xml:space="preserve">
          <source>To solve this error, please ensure that the trait is also public. The trait can be made inaccessible if necessary by placing it into a private inner module, but it still has to be marked with &lt;code&gt;pub&lt;/code&gt;. Example:</source>
          <target state="translated">Чтобы устранить эту ошибку, убедитесь, что трейт также является общедоступным. При необходимости трейт можно сделать недоступным, поместив его в закрытый внутренний модуль, но он все равно должен быть отмечен значком &lt;code&gt;pub&lt;/code&gt; . Пример:</target>
        </trans-unit>
        <trans-unit id="e8fd0f72a971d26cc1bbb2830412854500357f79" translate="yes" xml:space="preserve">
          <source>To solve this error, please ensure that the type is also public. The type can be made inaccessible if necessary by placing it into a private inner module, but it still has to be marked with &lt;code&gt;pub&lt;/code&gt;. Example:</source>
          <target state="translated">Чтобы устранить эту ошибку, убедитесь, что этот тип также является общедоступным. При необходимости тип можно сделать недоступным, поместив его в закрытый внутренний модуль, но он все равно должен быть помечен как &lt;code&gt;pub&lt;/code&gt; . Пример:</target>
        </trans-unit>
        <trans-unit id="3cffb477b8b527a4ad5d6a5090b9a2b24adc51f1" translate="yes" xml:space="preserve">
          <source>To solve this error, please move the type bindings in the type parameter declaration:</source>
          <target state="translated">Для устранения этой ошибки необходимо переместить привязки типов в объявлении параметров типа:</target>
        </trans-unit>
        <trans-unit id="4a77dd198bd76ba335ad5b87d56789f39f1b6b5e" translate="yes" xml:space="preserve">
          <source>To solve this error, the best solution is generally to keep the path before the item when using it. Example:</source>
          <target state="translated">Лучшим решением для устранения этой ошибки,как правило,является сохранение пути перед элементом при его использовании.Пример:</target>
        </trans-unit>
        <trans-unit id="e0683b0386295fb5b1a3a7f5a6c76d0ac644fc3b" translate="yes" xml:space="preserve">
          <source>To solve this issue, multiple solutions are available. First, is it required for this variable to be used in more than one closure at a time? If it is the case, use reference counted types such as &lt;code&gt;Rc&lt;/code&gt; (or &lt;code&gt;Arc&lt;/code&gt; if it runs concurrently):</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="41f267efd7ba6e9990897495f245eaad001164fa" translate="yes" xml:space="preserve">
          <source>To solve, ensure that the trait object has at least one trait:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d8595d9620d15e23dd7e60f0c946808adb0c94b9" translate="yes" xml:space="preserve">
          <source>To split by Unicode &lt;code&gt;Whitespace&lt;/code&gt; instead, use &lt;a href=&quot;#method.split_whitespace&quot;&gt;&lt;code&gt;split_whitespace&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Для того, чтобы разделить на Unicode &lt;code&gt;Whitespace&lt;/code&gt; Вместо этого, используйте &lt;a href=&quot;#method.split_whitespace&quot;&gt; &lt;code&gt;split_whitespace&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="f4419c6b42b03b7ee73a5252ee2ba8b90aa54d16" translate="yes" xml:space="preserve">
          <source>To split by Unicode &lt;code&gt;Whitespace&lt;/code&gt; instead, use &lt;a href=&quot;../primitive.str#method.split_whitespace&quot;&gt;&lt;code&gt;split_whitespace&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="008a095ac9e41d95c26562938b70663fdac5db0b" translate="yes" xml:space="preserve">
          <source>To split by Unicode &lt;code&gt;Whitespace&lt;/code&gt; instead, use &lt;a href=&quot;primitive.str#method.split_whitespace&quot;&gt;&lt;code&gt;split_whitespace&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="39efc8d301c98f5b54ae3dfd338106520f5157d1" translate="yes" xml:space="preserve">
          <source>To start defining the procedural macro, place the code in Listing 19-31 into your &lt;em&gt;src/lib.rs&lt;/em&gt; file for the &lt;code&gt;hello_macro_derive&lt;/code&gt; crate. Note that this code won&amp;rsquo;t compile until we add a definition for the &lt;code&gt;impl_hello_macro&lt;/code&gt; function.</source>
          <target state="translated">Чтобы начать определение процедурного макроса, поместите код из Листинга 19-31 в ваш файл &lt;em&gt;src / lib.rs&lt;/em&gt; для &lt;code&gt;hello_macro_derive&lt;/code&gt; . Обратите внимание, что этот код не будет компилироваться, пока мы не добавим определение для функции &lt;code&gt;impl_hello_macro&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4cd7a51fb6e1263e5fbdd69b060072fe94d9dc2f" translate="yes" xml:space="preserve">
          <source>To start, we&amp;rsquo;ll build a tree with nodes that know about their child nodes. We&amp;rsquo;ll create a struct named &lt;code&gt;Node&lt;/code&gt; that holds its own &lt;code&gt;i32&lt;/code&gt; value as well as references to its children &lt;code&gt;Node&lt;/code&gt; values:</source>
          <target state="translated">Для начала мы построим дерево с узлами, которые знают о своих дочерних узлах. Мы создадим структуру с именем &lt;code&gt;Node&lt;/code&gt; , которая будет содержать собственное значение &lt;code&gt;i32&lt;/code&gt; , а также ссылки на его дочерние значения &lt;code&gt;Node&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="e88b248a81f262510bb36c205a0d4dc2d7d064a2" translate="yes" xml:space="preserve">
          <source>To structure our crate in the same way that a real restaurant works, we can organize the functions into nested modules. Create a new library named &lt;code&gt;restaurant&lt;/code&gt; by running &lt;code&gt;cargo new --lib restaurant&lt;/code&gt;; then put the code in Listing 7-1 into &lt;em&gt;src/lib.rs&lt;/em&gt; to define some modules and function signatures.</source>
          <target state="translated">Чтобы структурировать наш ящик так же, как работает настоящий ресторан, мы можем организовать функции во вложенные модули. Создайте новую библиотеку с именем &lt;code&gt;restaurant&lt;/code&gt; , запустив &lt;code&gt;cargo new --lib restaurant&lt;/code&gt; ; затем поместите код из листинга 7.1 в &lt;em&gt;src / lib.rs,&lt;/em&gt; чтобы определить некоторые модули и сигнатуры функций.</target>
        </trans-unit>
        <trans-unit id="314819f76bd8c5d973c493b80242bed1a2fc84f6" translate="yes" xml:space="preserve">
          <source>To summarize, here you can find the full grammar of format strings. The syntax for the formatting language used is drawn from other languages, so it should not be too alien. Arguments are formatted with Python-like syntax, meaning that arguments are surrounded by &lt;code&gt;{}&lt;/code&gt; instead of the C-like &lt;code&gt;%&lt;/code&gt;. The actual grammar for the formatting syntax is:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9f66b79eaf886d6c72a892191c1e18c1c1df90d3" translate="yes" xml:space="preserve">
          <source>To summarize, strings are complicated. Different programming languages make different choices about how to present this complexity to the programmer. Rust has chosen to make the correct handling of &lt;code&gt;String&lt;/code&gt; data the default behavior for all Rust programs, which means programmers have to put more thought into handling UTF-8 data upfront. This trade-off exposes more of the complexity of strings than is apparent in other programming languages, but it prevents you from having to handle errors involving non-ASCII characters later in your development life cycle.</source>
          <target state="translated">Подводя итог, можно сказать, что струны сложны. Разные языки программирования принимают разные решения о том, как представить эту сложность программисту. Rust решил сделать правильную обработку &lt;code&gt;String&lt;/code&gt; данных поведением по умолчанию для всех программ на Rust, что означает, что программисты должны заранее продумать обработку данных UTF-8. Этот компромисс демонстрирует большую сложность строк, чем это очевидно в других языках программирования, но избавляет вас от необходимости обрабатывать ошибки, связанные с символами, отличными от ASCII, на более поздних этапах жизненного цикла разработки.</target>
        </trans-unit>
        <trans-unit id="de7e750f454d2e6ac7a8ffdfb7a0160a0d2868ee" translate="yes" xml:space="preserve">
          <source>To summarize, the &lt;code&gt;let mut guess = String::new();&lt;/code&gt; line has created a mutable variable that is currently bound to a new, empty instance of a &lt;code&gt;String&lt;/code&gt;. Whew!</source>
          <target state="translated">Подводя итог, &lt;code&gt;let mut guess = String::new();&lt;/code&gt; line создала изменяемую переменную, которая в настоящее время привязана к новому пустому экземпляру &lt;code&gt;String&lt;/code&gt; . Ух!</target>
        </trans-unit>
        <trans-unit id="9cb396520770d271c92551f4d7e0bcd83c651b95" translate="yes" xml:space="preserve">
          <source>To switch to unsafe Rust, use the &lt;code&gt;unsafe&lt;/code&gt; keyword and then start a new block that holds the unsafe code. You can take five actions in unsafe Rust, called &lt;em&gt;unsafe superpowers&lt;/em&gt;, that you can&amp;rsquo;t in safe Rust. Those superpowers include the ability to:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f43e14ce7587570f1bef4bdb30b6cbaa4b75f17f" translate="yes" xml:space="preserve">
          <source>To switch to unsafe Rust, use the &lt;code&gt;unsafe&lt;/code&gt; keyword and then start a new block that holds the unsafe code. You can take four actions in unsafe Rust, called &lt;em&gt;unsafe superpowers&lt;/em&gt;, that you can&amp;rsquo;t in safe Rust. Those superpowers include the ability to:</source>
          <target state="translated">Чтобы переключиться на небезопасный Rust, используйте ключевое слово &lt;code&gt;unsafe&lt;/code&gt; и затем запустите новый блок, содержащий небезопасный код. Вы можете выполнить четыре действия в небезопасном Rust, называемые &lt;em&gt;небезопасными суперсилами&lt;/em&gt; , которые вы не можете выполнить в безопасном Rust. Эти суперсилы включают способность:</target>
        </trans-unit>
        <trans-unit id="11f1d9981c2d0b02d68889e44295f6ab0f30c56d" translate="yes" xml:space="preserve">
          <source>To terminate a raw string, you have to have the same number of &lt;code&gt;#&lt;/code&gt; at the end as at the beginning. Example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="31217910df272b1f25ece09faa304c39aefdc3a5" translate="yes" xml:space="preserve">
          <source>To this:</source>
          <target state="translated">За это:</target>
        </trans-unit>
        <trans-unit id="057adfa85ddef458f115bd296031094452f5b4a0" translate="yes" xml:space="preserve">
          <source>To understand better how closures work in Rust, read: https://doc.rust-lang.org/book/ch13-01-closures.html</source>
          <target state="translated">Чтобы лучше понять,как работает закрытие в Расте,читайте:https://doc.rust-lang.org/book/ch13-01-closures.html.</target>
        </trans-unit>
        <trans-unit id="28d2bbf95b0b86d0881e2c7c6550fc005fe06275" translate="yes" xml:space="preserve">
          <source>To understand what this means, it is perhaps easier to consider a few examples.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c87f629cfb96af20696ef3d804bdc670ac7c36a2" translate="yes" xml:space="preserve">
          <source>To understand when we might want to use structs, let&amp;rsquo;s write a program that calculates the area of a rectangle. We&amp;rsquo;ll start with single variables, and then refactor the program until we&amp;rsquo;re using structs instead.</source>
          <target state="translated">Чтобы понять, когда мы можем использовать структуры, давайте напишем программу, которая вычисляет площадь прямоугольника. Мы начнем с одиночных переменных, а затем проведем рефакторинг программы, пока не будем использовать структуры.</target>
        </trans-unit>
        <trans-unit id="f3887dc1ab813c2423acfe9d57d029c4502fb78e" translate="yes" xml:space="preserve">
          <source>To uninstall Rust and &lt;code&gt;rustup&lt;/code&gt;, run the following uninstall script from your shell:</source>
          <target state="translated">Чтобы удалить Rust и &lt;code&gt;rustup&lt;/code&gt; , запустите следующий сценарий удаления из вашей оболочки:</target>
        </trans-unit>
        <trans-unit id="662f41af8eb574e21b57913c6f9a0bd1516cbc7a" translate="yes" xml:space="preserve">
          <source>To uppercase ASCII characters in addition to non-ASCII characters, use &lt;a href=&quot;#method.to_uppercase&quot;&gt;&lt;code&gt;to_uppercase&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Для прописных символов ASCII в дополнение к символам, &lt;a href=&quot;#method.to_uppercase&quot;&gt; &lt;code&gt;to_uppercase&lt;/code&gt; &lt;/a&gt; ASCII, используйте to_uppercase .</target>
        </trans-unit>
        <trans-unit id="bae7e9e1be3baf0aecb5ead601705215f7341743" translate="yes" xml:space="preserve">
          <source>To uppercase ASCII characters in addition to non-ASCII characters, use &lt;a href=&quot;../primitive.str#method.to_uppercase&quot;&gt;&lt;code&gt;str::to_uppercase&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Для прописных символов ASCII в дополнение к не-ASCII символам используйте &lt;a href=&quot;../primitive.str#method.to_uppercase&quot;&gt; &lt;code&gt;str::to_uppercase&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="3ceeb5afb45130513f95c0c76f8c194cbc22cc90" translate="yes" xml:space="preserve">
          <source>To uppercase ASCII characters in addition to non-ASCII characters, use &lt;a href=&quot;https://doc.rust-lang.org/nightly/std/primitive.str.html#method.to_uppercase&quot;&gt;&lt;code&gt;str::to_uppercase&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="00c3dbee0cfe96289d27fa6bc805ddc167d97ef8" translate="yes" xml:space="preserve">
          <source>To uppercase the value in-place, use &lt;a href=&quot;#method.make_ascii_uppercase&quot;&gt;&lt;code&gt;make_ascii_uppercase&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Чтобы &lt;a href=&quot;#method.make_ascii_uppercase&quot;&gt; &lt;code&gt;make_ascii_uppercase&lt;/code&gt; &lt;/a&gt; значение на месте, используйте make_ascii_uppercase .</target>
        </trans-unit>
        <trans-unit id="f0fee41197e5788cb8d5e92ad9fa5f070d016314" translate="yes" xml:space="preserve">
          <source>To uppercase the value in-place, use &lt;a href=&quot;#tymethod.make_ascii_uppercase&quot;&gt;&lt;code&gt;make_ascii_uppercase&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Чтобы &lt;a href=&quot;#tymethod.make_ascii_uppercase&quot;&gt; &lt;code&gt;make_ascii_uppercase&lt;/code&gt; &lt;/a&gt; значение на месте, используйте make_ascii_uppercase .</target>
        </trans-unit>
        <trans-unit id="03872893861b26ce89768ebad491eb1be2bc29f7" translate="yes" xml:space="preserve">
          <source>To uppercase the value in-place, use &lt;a href=&quot;../primitive.str#method.make_ascii_uppercase&quot;&gt;&lt;code&gt;make_ascii_uppercase&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="52ba625fbc6adb072f55ed4d3847b030100a31e3" translate="yes" xml:space="preserve">
          <source>To uppercase the value in-place, use &lt;a href=&quot;../primitive.u8#method.make_ascii_uppercase&quot;&gt;&lt;code&gt;make_ascii_uppercase&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e8d877f3de3ce27771a5ff9e83ea6d9c1e61cdbd" translate="yes" xml:space="preserve">
          <source>To uppercase the value in-place, use &lt;a href=&quot;primitive.str#method.make_ascii_uppercase&quot;&gt;&lt;code&gt;make_ascii_uppercase&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a9ebf88e0ca05fe29ac69ce486bd57ddd729efb8" translate="yes" xml:space="preserve">
          <source>To uppercase the value in-place, use &lt;a href=&quot;primitive.u8#method.make_ascii_uppercase&quot;&gt;&lt;code&gt;make_ascii_uppercase&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1ad9a8481cb2cb5dd232df2f396463103d3a41d2" translate="yes" xml:space="preserve">
          <source>To uppercase the value in-place, use &lt;a href=&quot;struct.osstr#method.make_ascii_uppercase&quot;&gt;&lt;code&gt;OsStr::make_ascii_uppercase&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2ec9e0a0dd307f8b51434cf6c875a527cefcad70" translate="yes" xml:space="preserve">
          <source>To uppercase the value in-place, use &lt;a href=&quot;trait.asciiext#tymethod.make_ascii_uppercase&quot;&gt;&lt;code&gt;make_ascii_uppercase&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2a0a581c19fda5f34a2ecc353cab28485839d3f8" translate="yes" xml:space="preserve">
          <source>To use a default implementation to summarize instances of &lt;code&gt;NewsArticle&lt;/code&gt; instead of defining a custom implementation, we specify an empty &lt;code&gt;impl&lt;/code&gt; block with &lt;code&gt;impl Summary for NewsArticle {}&lt;/code&gt;.</source>
          <target state="translated">Для того, чтобы использовать реализацию по умолчанию для обобщения экземпляры &lt;code&gt;NewsArticle&lt;/code&gt; вместо определения пользовательской реализации, мы указываем пустой &lt;code&gt;impl&lt;/code&gt; блок с &lt;code&gt;impl Summary for NewsArticle {}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9f435d65416d088237053151174da52702ca2759" translate="yes" xml:space="preserve">
          <source>To use a module from your current crate, add the &lt;code&gt;crate::&lt;/code&gt; prefix to the path.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="adbf67a283306a6366d793a3b3158fdc68b8ad73" translate="yes" xml:space="preserve">
          <source>To use a namespace itself in addition to some of its members, &lt;code&gt;self&lt;/code&gt; may appear as part of a brace-enclosed list of imports:</source>
          <target state="translated">Чтобы использовать само пространство имен в дополнение к некоторым его членам, &lt;code&gt;self&lt;/code&gt; может появиться как часть заключенного в фигурные скобки списка импорта:</target>
        </trans-unit>
        <trans-unit id="4b03ec43b2895de636748b67704c685a1fa98427" translate="yes" xml:space="preserve">
          <source>To use a pattern, we compare it to some value. If the pattern matches the value, we use the value parts in our code. Recall the &lt;code&gt;match&lt;/code&gt; expressions in Chapter 6 that used patterns, such as the coin-sorting machine example. If the value fits the shape of the pattern, we can use the named pieces. If it doesn&amp;rsquo;t, the code associated with the pattern won&amp;rsquo;t run.</source>
          <target state="translated">Чтобы использовать узор, мы сравниваем его с некоторым значением. Если шаблон соответствует значению, мы используем части значения в нашем коде. Напомним, &lt;code&gt;match&lt;/code&gt; выражения в главе 6, используемые шаблоны, такие как монеты сортировки , например машины. Если значение соответствует форме узора, мы можем использовать названные части. В противном случае код, связанный с шаблоном, не запустится.</target>
        </trans-unit>
        <trans-unit id="6cd526c3f5cdfb3e49b95a57c88c2fc1245de535" translate="yes" xml:space="preserve">
          <source>To use a slice type it generally has to be used behind a pointer for example as:</source>
          <target state="translated">Чтобы использовать тип среза,его обычно нужно использовать за указателем,например,как:</target>
        </trans-unit>
        <trans-unit id="1d9510373e7fd3a8d97cc9744e3544cf1ebe365c" translate="yes" xml:space="preserve">
          <source>To use a struct after we&amp;rsquo;ve defined it, we create an &lt;em&gt;instance&lt;/em&gt; of that struct by specifying concrete values for each of the fields. We create an instance by stating the name of the struct and then add curly brackets containing &lt;code&gt;key: value&lt;/code&gt; pairs, where the keys are the names of the fields and the values are the data we want to store in those fields. We don&amp;rsquo;t have to specify the fields in the same order in which we declared them in the struct. In other words, the struct definition is like a general template for the type, and instances fill in that template with particular data to create values of the type. For example, we can declare a particular user as shown in Listing 5-2.</source>
          <target state="translated">Чтобы использовать структуру после того, как мы ее определили, мы создаем &lt;em&gt;экземпляр&lt;/em&gt; этой структуры, указывая конкретные значения для каждого из полей. Мы создаем экземпляр, указывая имя структуры, а затем добавляем фигурные скобки, содержащие пары &lt;code&gt;key: value&lt;/code&gt; , где ключи - это имена полей, а значения - это данные, которые мы хотим сохранить в этих полях. Нам не нужно указывать поля в том же порядке, в котором мы объявили их в структуре. Другими словами, определение структуры похоже на общий шаблон для типа, и экземпляры заполняют этот шаблон конкретными данными для создания значений типа. Например, мы можем объявить конкретного пользователя, как показано в листинге 5-2.</target>
        </trans-unit>
        <trans-unit id="27989b6610882b719a5ea410b5f71f23c1e34efa" translate="yes" xml:space="preserve">
          <source>To use this feature locally, you typically will use the &lt;code&gt;RUSTFLAGS&lt;/code&gt; environment variable to specify flags to the compiler through Cargo. For example to compile a statically linked binary on MSVC you would execute:</source>
          <target state="translated">Чтобы использовать эту функцию локально, вы обычно используете &lt;code&gt;RUSTFLAGS&lt;/code&gt; среды RUSTFLAGS, чтобы указать флаги для компилятора через Cargo. Например, чтобы скомпилировать статически связанный двоичный файл на MSVC, вы должны выполнить:</target>
        </trans-unit>
        <trans-unit id="aa8b8effb94e7abcaae16085a72643f10b8227aa" translate="yes" xml:space="preserve">
          <source>To use this version of &lt;code&gt;Summary&lt;/code&gt;, we only need to define &lt;code&gt;summarize_author&lt;/code&gt; when we implement the trait on a type:</source>
          <target state="translated">Чтобы использовать эту версию &lt;code&gt;Summary&lt;/code&gt; , нам нужно определить &lt;code&gt;summarize_author&lt;/code&gt; только тогда, когда мы реализуем трейт для типа:</target>
        </trans-unit>
        <trans-unit id="bc4c76af44cf81aae5a3bedd1a4fabcaf591ba2f" translate="yes" xml:space="preserve">
          <source>To wake up all threads, see &lt;a href=&quot;#method.notify_all&quot;&gt;&lt;code&gt;notify_all&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Чтобы разбудить все потоки, см. &lt;a href=&quot;#method.notify_all&quot;&gt; &lt;code&gt;notify_all&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="1bba606e9595f006eac21496e730831a817fd203" translate="yes" xml:space="preserve">
          <source>To wake up all threads, see &lt;a href=&quot;struct.condvar#method.notify_all&quot;&gt;&lt;code&gt;notify_all&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="43d932c297a4d2b73e1f772e97d55db4b8e0dc93" translate="yes" xml:space="preserve">
          <source>To wake up only one thread, see &lt;a href=&quot;#method.notify_one&quot;&gt;&lt;code&gt;notify_one&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Чтобы разбудить только один поток, см. &lt;a href=&quot;#method.notify_one&quot;&gt; &lt;code&gt;notify_one&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="bee8651caa9f53e075921bde6a903cb8a56a8a73" translate="yes" xml:space="preserve">
          <source>To wake up only one thread, see &lt;a href=&quot;struct.condvar#method.notify_one&quot;&gt;&lt;code&gt;notify_one&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c88cf3ca8e9feae5d3beb7bbd55b97e74623d342" translate="yes" xml:space="preserve">
          <source>To work around this restriction, consider &quot;hiding&quot; the value behind a reference: either &lt;code&gt;&amp;amp;x&lt;/code&gt; or &lt;code&gt;&amp;amp;mut x&lt;/code&gt;. Since a reference has a fixed size, this lets you move it around as usual. Example:</source>
          <target state="translated">Чтобы обойти это ограничение, рассмотрите возможность &amp;laquo;скрытия&amp;raquo; значения за ссылкой: либо &lt;code&gt;&amp;amp;x&lt;/code&gt; либо &lt;code&gt;&amp;amp;mut x&lt;/code&gt; . Поскольку ссылка имеет фиксированный размер, это позволяет перемещать ее как обычно. Пример:</target>
        </trans-unit>
        <trans-unit id="6500c202f483ded49d90dd12d80754b82fdf0dff" translate="yes" xml:space="preserve">
          <source>To work around this, it can be covered with a local type, &lt;code&gt;MyType&lt;/code&gt;:</source>
          <target state="translated">Чтобы обойти это, его можно покрыть локальным типом &lt;code&gt;MyType&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="36dd8bd129ed7bbb15977196b4ec891eb2cbcdbb" translate="yes" xml:space="preserve">
          <source>To work around this, we can use &lt;a href=&quot;#method.split_at_mut&quot;&gt;&lt;code&gt;split_at_mut&lt;/code&gt;&lt;/a&gt; to create two distinct mutable sub-slices from a slice:</source>
          <target state="translated">Чтобы обойти это, мы можем использовать &lt;a href=&quot;#method.split_at_mut&quot;&gt; &lt;code&gt;split_at_mut&lt;/code&gt; &lt;/a&gt; для создания двух различных изменяемых суб-срезов из среза:</target>
        </trans-unit>
        <trans-unit id="24f7e027af97b0bcea482e03195ef7fce8ba5648" translate="yes" xml:space="preserve">
          <source>To work around this, we can use &lt;a href=&quot;#method.split_at_mut&quot;&gt;&lt;code&gt;split_at_mut&lt;/code&gt;&lt;/a&gt; to create two distinct sub-slices from a slice:</source>
          <target state="translated">Чтобы обойти это, мы можем использовать &lt;a href=&quot;#method.split_at_mut&quot;&gt; &lt;code&gt;split_at_mut&lt;/code&gt; &lt;/a&gt; для создания двух отдельных суб-срезов из среза:</target>
        </trans-unit>
        <trans-unit id="88426551199f60d0c53bc995bbba2a8ae94e26e1" translate="yes" xml:space="preserve">
          <source>To work with DSTs, Rust has a particular trait called the &lt;code&gt;Sized&lt;/code&gt; trait to determine whether or not a type&amp;rsquo;s size is known at compile time. This trait is automatically implemented for everything whose size is known at compile time. In addition, Rust implicitly adds a bound on &lt;code&gt;Sized&lt;/code&gt; to every generic function. That is, a generic function definition like this:</source>
          <target state="translated">Для работы с DST в Rust есть особая черта, называемая чертой &lt;code&gt;Sized&lt;/code&gt; , которая определяет, известен ли размер типа во время компиляции. Эта черта автоматически реализуется для всего, размер которого известен во время компиляции. Вдобавок Rust неявно добавляет ограничение на &lt;code&gt;Sized&lt;/code&gt; для каждой универсальной функции. То есть определение общей функции, подобное этому:</target>
        </trans-unit>
        <trans-unit id="fb14220cb77cbb7e4cc1fc269b18360bfeb61f7b" translate="yes" xml:space="preserve">
          <source>To yank a version of a crate, run &lt;code&gt;cargo yank&lt;/code&gt; and specify which version you want to yank:</source>
          <target state="translated">Чтобы восстановить версию ящика, запустите функцию Cargo &lt;code&gt;cargo yank&lt;/code&gt; и укажите, какую версию вы хотите восстановить:</target>
        </trans-unit>
        <trans-unit id="358ef599a863a7317d7b73949a61a65e9c8b5929" translate="yes" xml:space="preserve">
          <source>ToLowercase</source>
          <target state="translated">ToLowercase</target>
        </trans-unit>
        <trans-unit id="df38106c5dbe8437c114ca2d685149a2779acb46" translate="yes" xml:space="preserve">
          <source>ToLowercase::all</source>
          <target state="translated">ToLowercase::all</target>
        </trans-unit>
        <trans-unit id="bbeaa264c1c37f2bac007b1544ec3f5ad9fa247a" translate="yes" xml:space="preserve">
          <source>ToLowercase::any</source>
          <target state="translated">ToLowercase::any</target>
        </trans-unit>
        <trans-unit id="0a141811b0b02a8a6bc1f88e69b931b80579b5c2" translate="yes" xml:space="preserve">
          <source>ToLowercase::borrow</source>
          <target state="translated">ToLowercase::borrow</target>
        </trans-unit>
        <trans-unit id="cdeca1abdbe65f3026e21a79b8f904e797c979d8" translate="yes" xml:space="preserve">
          <source>ToLowercase::borrow_mut</source>
          <target state="translated">ToLowercase::borrow_mut</target>
        </trans-unit>
        <trans-unit id="04089a7fe4a382bdeab885ef9891fb5765277adf" translate="yes" xml:space="preserve">
          <source>ToLowercase::by_ref</source>
          <target state="translated">ToLowercase::by_ref</target>
        </trans-unit>
        <trans-unit id="a079ce9b966f7512985cc3db6325af88008cc5f5" translate="yes" xml:space="preserve">
          <source>ToLowercase::chain</source>
          <target state="translated">ToLowercase::chain</target>
        </trans-unit>
        <trans-unit id="34f89547554d65a0175fa66474bd90120ecce7b1" translate="yes" xml:space="preserve">
          <source>ToLowercase::clone</source>
          <target state="translated">ToLowercase::clone</target>
        </trans-unit>
        <trans-unit id="0a39078458104a1579ea1ffbefc1eff627ca4db9" translate="yes" xml:space="preserve">
          <source>ToLowercase::clone_from</source>
          <target state="translated">ToLowercase::clone_from</target>
        </trans-unit>
        <trans-unit id="69987693fa5c572002cf4a8687ae06044830821a" translate="yes" xml:space="preserve">
          <source>ToLowercase::clone_into</source>
          <target state="translated">ToLowercase::clone_into</target>
        </trans-unit>
        <trans-unit id="121cb5982b6d466308c6295488de685c5924188f" translate="yes" xml:space="preserve">
          <source>ToLowercase::cloned</source>
          <target state="translated">ToLowercase::cloned</target>
        </trans-unit>
        <trans-unit id="2a56c21b2935dd999e82afb8be288b273e7d2e4e" translate="yes" xml:space="preserve">
          <source>ToLowercase::cmp</source>
          <target state="translated">ToLowercase::cmp</target>
        </trans-unit>
        <trans-unit id="9a83c4a51b2449ab4001a1ea57020189f34eb86e" translate="yes" xml:space="preserve">
          <source>ToLowercase::collect</source>
          <target state="translated">ToLowercase::collect</target>
        </trans-unit>
        <trans-unit id="fc76b0e4ac6af8ee61de5ea6000b4e90b61281f6" translate="yes" xml:space="preserve">
          <source>ToLowercase::copied</source>
          <target state="translated">ToLowercase::copied</target>
        </trans-unit>
        <trans-unit id="ebd8500418acdbe357cc1847a2d0349da2ad6802" translate="yes" xml:space="preserve">
          <source>ToLowercase::count</source>
          <target state="translated">ToLowercase::count</target>
        </trans-unit>
        <trans-unit id="46c2bfc1c56cb3945b434e3354e83dfe8b8c506d" translate="yes" xml:space="preserve">
          <source>ToLowercase::cycle</source>
          <target state="translated">ToLowercase::cycle</target>
        </trans-unit>
        <trans-unit id="17c64b13d578e62f4865fa3a426a453511fad16f" translate="yes" xml:space="preserve">
          <source>ToLowercase::enumerate</source>
          <target state="translated">ToLowercase::enumerate</target>
        </trans-unit>
        <trans-unit id="22c6e7593fef2063b7782e7156f48b60a1a13824" translate="yes" xml:space="preserve">
          <source>ToLowercase::eq</source>
          <target state="translated">ToLowercase::eq</target>
        </trans-unit>
        <trans-unit id="a97a62afe9c15bee17e74d16036987e2c4a3f22a" translate="yes" xml:space="preserve">
          <source>ToLowercase::filter</source>
          <target state="translated">ToLowercase::filter</target>
        </trans-unit>
        <trans-unit id="282e7712aa0755dc3cee721bbb60ae3056ffd1b8" translate="yes" xml:space="preserve">
          <source>ToLowercase::filter_map</source>
          <target state="translated">ToLowercase::filter_map</target>
        </trans-unit>
        <trans-unit id="5e623530b92901b135346a206054ea74de34c74b" translate="yes" xml:space="preserve">
          <source>ToLowercase::find</source>
          <target state="translated">ToLowercase::find</target>
        </trans-unit>
        <trans-unit id="8199273d20714ffb35f8bf63fc8de1aeeb62aaaf" translate="yes" xml:space="preserve">
          <source>ToLowercase::find_map</source>
          <target state="translated">ToLowercase::find_map</target>
        </trans-unit>
        <trans-unit id="4ed7f75d1d13393082ea7b8eeecf7e820cecc331" translate="yes" xml:space="preserve">
          <source>ToLowercase::flat_map</source>
          <target state="translated">ToLowercase::flat_map</target>
        </trans-unit>
        <trans-unit id="8faef9a1d718b76295200253966c7806e7cdc59c" translate="yes" xml:space="preserve">
          <source>ToLowercase::flatten</source>
          <target state="translated">ToLowercase::flatten</target>
        </trans-unit>
        <trans-unit id="d060a84d6f235fd2215550273860f38eeab5eccf" translate="yes" xml:space="preserve">
          <source>ToLowercase::fmt</source>
          <target state="translated">ToLowercase::fmt</target>
        </trans-unit>
        <trans-unit id="8131b5a5bcf84d17a43fb10e483ba9ff1d8d359c" translate="yes" xml:space="preserve">
          <source>ToLowercase::fold</source>
          <target state="translated">ToLowercase::fold</target>
        </trans-unit>
        <trans-unit id="327b78b92e355c99705bbf603c2bb143fa92d2e9" translate="yes" xml:space="preserve">
          <source>ToLowercase::for_each</source>
          <target state="translated">ToLowercase::for_each</target>
        </trans-unit>
        <trans-unit id="c1d00ad3539f24458681e04a1741cd54badd39cf" translate="yes" xml:space="preserve">
          <source>ToLowercase::from</source>
          <target state="translated">ToLowercase::from</target>
        </trans-unit>
        <trans-unit id="7d595874443f42a9e344ead1449f7c72a2522b74" translate="yes" xml:space="preserve">
          <source>ToLowercase::fuse</source>
          <target state="translated">ToLowercase::fuse</target>
        </trans-unit>
        <trans-unit id="5f012ebb8814c9cf77a450ef55b693640b7421e7" translate="yes" xml:space="preserve">
          <source>ToLowercase::ge</source>
          <target state="translated">ToLowercase::ge</target>
        </trans-unit>
        <trans-unit id="a451e0c1969a73439fef2468147038b278d489fd" translate="yes" xml:space="preserve">
          <source>ToLowercase::gt</source>
          <target state="translated">ToLowercase::gt</target>
        </trans-unit>
        <trans-unit id="642b22a76015cab4922545ce0b1b8fce9e09e5ed" translate="yes" xml:space="preserve">
          <source>ToLowercase::inspect</source>
          <target state="translated">ToLowercase::inspect</target>
        </trans-unit>
        <trans-unit id="7ca3893f4299d51675bc4e51e48ab78b6e95e7ae" translate="yes" xml:space="preserve">
          <source>ToLowercase::into</source>
          <target state="translated">ToLowercase::into</target>
        </trans-unit>
        <trans-unit id="9baa58c23f7e0d689b278ecfab3e39c8efae52c3" translate="yes" xml:space="preserve">
          <source>ToLowercase::into_iter</source>
          <target state="translated">ToLowercase::into_iter</target>
        </trans-unit>
        <trans-unit id="41740e63b2346c1e13490d8bb5f5d3524774e936" translate="yes" xml:space="preserve">
          <source>ToLowercase::is_empty</source>
          <target state="translated">ToLowercase::is_empty</target>
        </trans-unit>
        <trans-unit id="0a3555fc3fa048af9c1a10c2d056047061c3acad" translate="yes" xml:space="preserve">
          <source>ToLowercase::is_sorted</source>
          <target state="translated">ToLowercase::is_sorted</target>
        </trans-unit>
        <trans-unit id="d1e0425d483ec70bb6984df2a767d8b9e4f434c4" translate="yes" xml:space="preserve">
          <source>ToLowercase::is_sorted_by</source>
          <target state="translated">ToLowercase::is_sorted_by</target>
        </trans-unit>
        <trans-unit id="a66c5bf8964eab56ac90671d7ee744d61569a85f" translate="yes" xml:space="preserve">
          <source>ToLowercase::is_sorted_by_key</source>
          <target state="translated">ToLowercase::is_sorted_by_key</target>
        </trans-unit>
        <trans-unit id="f9ef704f171d5f967ad9a902b9e6c885aa657d95" translate="yes" xml:space="preserve">
          <source>ToLowercase::last</source>
          <target state="translated">ToLowercase::last</target>
        </trans-unit>
        <trans-unit id="d3f98dd839d26ad724880104a40c7e70d33d18c3" translate="yes" xml:space="preserve">
          <source>ToLowercase::le</source>
          <target state="translated">ToLowercase::le</target>
        </trans-unit>
        <trans-unit id="e1ba36fd3934ba511b5d0af5c6f135a35664771b" translate="yes" xml:space="preserve">
          <source>ToLowercase::len</source>
          <target state="translated">ToLowercase::len</target>
        </trans-unit>
        <trans-unit id="2eed1cdf88b1cb0a9fa1233f81e8f43967248498" translate="yes" xml:space="preserve">
          <source>ToLowercase::lt</source>
          <target state="translated">ToLowercase::lt</target>
        </trans-unit>
        <trans-unit id="e43226c948078b9cc9aebaa496f80af6656f0917" translate="yes" xml:space="preserve">
          <source>ToLowercase::map</source>
          <target state="translated">ToLowercase::map</target>
        </trans-unit>
        <trans-unit id="e0c53789432635e282bac9afc1520196b7c560e8" translate="yes" xml:space="preserve">
          <source>ToLowercase::max</source>
          <target state="translated">ToLowercase::max</target>
        </trans-unit>
        <trans-unit id="903a830f2d66f982a4644a703e0e8e4957273461" translate="yes" xml:space="preserve">
          <source>ToLowercase::max_by</source>
          <target state="translated">ToLowercase::max_by</target>
        </trans-unit>
        <trans-unit id="18bae373fc9373515a693f2601a3ad81cbde3459" translate="yes" xml:space="preserve">
          <source>ToLowercase::max_by_key</source>
          <target state="translated">ToLowercase::max_by_key</target>
        </trans-unit>
        <trans-unit id="bb9afa7050228536bbc7504f5c5dfc47a13e78c0" translate="yes" xml:space="preserve">
          <source>ToLowercase::min</source>
          <target state="translated">ToLowercase::min</target>
        </trans-unit>
        <trans-unit id="77c4813b999aa04010a0f28c8553bcc6214e1616" translate="yes" xml:space="preserve">
          <source>ToLowercase::min_by</source>
          <target state="translated">ToLowercase::min_by</target>
        </trans-unit>
        <trans-unit id="423a7c3614737a7cb7033368fb85813297ba5915" translate="yes" xml:space="preserve">
          <source>ToLowercase::min_by_key</source>
          <target state="translated">ToLowercase::min_by_key</target>
        </trans-unit>
        <trans-unit id="45cf81c6356fb6305106b81d4e38e7f435f86cc1" translate="yes" xml:space="preserve">
          <source>ToLowercase::ne</source>
          <target state="translated">ToLowercase::ne</target>
        </trans-unit>
        <trans-unit id="a71fc3ee26e013ac8645c417796e09cd264a122e" translate="yes" xml:space="preserve">
          <source>ToLowercase::next</source>
          <target state="translated">ToLowercase::next</target>
        </trans-unit>
        <trans-unit id="1911198040fb257baaa909fbd9e0ff4bd63738b2" translate="yes" xml:space="preserve">
          <source>ToLowercase::nth</source>
          <target state="translated">ToLowercase::nth</target>
        </trans-unit>
        <trans-unit id="8e0ec3fa9f7c6b4e02f5cdbcceafdedd84b428e3" translate="yes" xml:space="preserve">
          <source>ToLowercase::partial_cmp</source>
          <target state="translated">ToLowercase::partial_cmp</target>
        </trans-unit>
        <trans-unit id="47c77ae9e15794fc333d6ed8815d4414bb103610" translate="yes" xml:space="preserve">
          <source>ToLowercase::partition</source>
          <target state="translated">ToLowercase::partition</target>
        </trans-unit>
        <trans-unit id="75ec1c2334a1ca3250b6d8818285245c4e4389b7" translate="yes" xml:space="preserve">
          <source>ToLowercase::peekable</source>
          <target state="translated">ToLowercase::peekable</target>
        </trans-unit>
        <trans-unit id="5bd4eb545154844db83963b7bf6e24d4160c4184" translate="yes" xml:space="preserve">
          <source>ToLowercase::position</source>
          <target state="translated">ToLowercase::position</target>
        </trans-unit>
        <trans-unit id="da1c2a6ce254ef365fc893f21ebcfb9884ec4d92" translate="yes" xml:space="preserve">
          <source>ToLowercase::product</source>
          <target state="translated">ToLowercase::product</target>
        </trans-unit>
        <trans-unit id="7513906fb803029e9d762eb5a94c745eb5662524" translate="yes" xml:space="preserve">
          <source>ToLowercase::rev</source>
          <target state="translated">ToLowercase::rev</target>
        </trans-unit>
        <trans-unit id="418774bd5cf3162562c6090441d234e9d61a03d7" translate="yes" xml:space="preserve">
          <source>ToLowercase::rposition</source>
          <target state="translated">ToLowercase::rposition</target>
        </trans-unit>
        <trans-unit id="9b317c9f2c5a4d58ea3427624437ce70f6752c98" translate="yes" xml:space="preserve">
          <source>ToLowercase::scan</source>
          <target state="translated">ToLowercase::scan</target>
        </trans-unit>
        <trans-unit id="2347172afd0d4f896ed7b4c55d0f9d8e2916251b" translate="yes" xml:space="preserve">
          <source>ToLowercase::size_hint</source>
          <target state="translated">ToLowercase::size_hint</target>
        </trans-unit>
        <trans-unit id="418c2ea2c35afdc50dcf9a90930d3ce62e8f3999" translate="yes" xml:space="preserve">
          <source>ToLowercase::skip</source>
          <target state="translated">ToLowercase::skip</target>
        </trans-unit>
        <trans-unit id="95df49075bec9d23f70a04c44f6a727846e429e6" translate="yes" xml:space="preserve">
          <source>ToLowercase::skip_while</source>
          <target state="translated">ToLowercase::skip_while</target>
        </trans-unit>
        <trans-unit id="b9d44057d9ed2703572ffed49f6eca5288b3d100" translate="yes" xml:space="preserve">
          <source>ToLowercase::step_by</source>
          <target state="translated">ToLowercase::step_by</target>
        </trans-unit>
        <trans-unit id="12fc6d57d9454f947a272a38199873e4fabe30e6" translate="yes" xml:space="preserve">
          <source>ToLowercase::sum</source>
          <target state="translated">ToLowercase::sum</target>
        </trans-unit>
        <trans-unit id="0f151b1e0bb55576903eeeb5a1d3d1df40fa455c" translate="yes" xml:space="preserve">
          <source>ToLowercase::take</source>
          <target state="translated">ToLowercase::take</target>
        </trans-unit>
        <trans-unit id="bb7ec83ca1b296882f68aab3b80d313fe4becdda" translate="yes" xml:space="preserve">
          <source>ToLowercase::take_while</source>
          <target state="translated">ToLowercase::take_while</target>
        </trans-unit>
        <trans-unit id="4ee080cf3eb36fa9ffb413ea40781d5206121d04" translate="yes" xml:space="preserve">
          <source>ToLowercase::to_owned</source>
          <target state="translated">ToLowercase::to_owned</target>
        </trans-unit>
        <trans-unit id="89719f79b975bafdc49f6c2bf1b53c77dd82479f" translate="yes" xml:space="preserve">
          <source>ToLowercase::to_string</source>
          <target state="translated">ToLowercase::to_string</target>
        </trans-unit>
        <trans-unit id="02fb5f5e1e24ebbf9a57d55d395e203de6f1bb79" translate="yes" xml:space="preserve">
          <source>ToLowercase::try_fold</source>
          <target state="translated">ToLowercase::try_fold</target>
        </trans-unit>
        <trans-unit id="24adb2676fd932bafa66d72575c91291c6415cb3" translate="yes" xml:space="preserve">
          <source>ToLowercase::try_for_each</source>
          <target state="translated">ToLowercase::try_for_each</target>
        </trans-unit>
        <trans-unit id="ca18cfcbad0e84fa95fbec8b5bfb913cdebdfd50" translate="yes" xml:space="preserve">
          <source>ToLowercase::try_from</source>
          <target state="translated">ToLowercase::try_from</target>
        </trans-unit>
        <trans-unit id="e06d04b43ebaa98937e8ae299a145ab53f8f8401" translate="yes" xml:space="preserve">
          <source>ToLowercase::try_into</source>
          <target state="translated">ToLowercase::try_into</target>
        </trans-unit>
        <trans-unit id="37b6363c64db2b818bf5770928eeb9cb5799b27c" translate="yes" xml:space="preserve">
          <source>ToLowercase::type_id</source>
          <target state="translated">ToLowercase::type_id</target>
        </trans-unit>
        <trans-unit id="5dab7a97b855d1005e423aac5a301136ccbfbda8" translate="yes" xml:space="preserve">
          <source>ToLowercase::unzip</source>
          <target state="translated">ToLowercase::unzip</target>
        </trans-unit>
        <trans-unit id="8c6300316ee7d9e235cf97abcd7ffe7ee60f526a" translate="yes" xml:space="preserve">
          <source>ToLowercase::zip</source>
          <target state="translated">ToLowercase::zip</target>
        </trans-unit>
        <trans-unit id="6a954abfe9e5f07fb766f0356ed1234d8f9b2362" translate="yes" xml:space="preserve">
          <source>ToOwned</source>
          <target state="translated">ToOwned</target>
        </trans-unit>
        <trans-unit id="88395f188f7e1627b5813c10232224a853eb2ce1" translate="yes" xml:space="preserve">
          <source>ToOwned::clone_into</source>
          <target state="translated">ToOwned::clone_into</target>
        </trans-unit>
        <trans-unit id="b54aeb29a238430e61c4864d679de09e146fc8bd" translate="yes" xml:space="preserve">
          <source>ToOwned::to_owned</source>
          <target state="translated">ToOwned::to_owned</target>
        </trans-unit>
        <trans-unit id="db76836dc2d12f75bc694c079718628342759cd3" translate="yes" xml:space="preserve">
          <source>ToSocketAddrs</source>
          <target state="translated">ToSocketAddrs</target>
        </trans-unit>
        <trans-unit id="0fed83f8d392d8ac77157990f089f9649d9b7750" translate="yes" xml:space="preserve">
          <source>ToSocketAddrs::to_socket_addrs</source>
          <target state="translated">ToSocketAddrs::to_socket_addrs</target>
        </trans-unit>
        <trans-unit id="1dbc7385badbfda548fb27e2160a33cf32c0f545" translate="yes" xml:space="preserve">
          <source>ToString</source>
          <target state="translated">ToString</target>
        </trans-unit>
        <trans-unit id="44b9808561fdc5221237b58497f052b0ab411690" translate="yes" xml:space="preserve">
          <source>ToString::to_string</source>
          <target state="translated">ToString::to_string</target>
        </trans-unit>
        <trans-unit id="0e33b561569f62cb10ee567c1f64d4f901389c05" translate="yes" xml:space="preserve">
          <source>ToUppercase</source>
          <target state="translated">ToUppercase</target>
        </trans-unit>
        <trans-unit id="9ff9a36e95ac5564578763dcb0e10b5a089787be" translate="yes" xml:space="preserve">
          <source>ToUppercase::all</source>
          <target state="translated">ToUppercase::all</target>
        </trans-unit>
        <trans-unit id="65730a9e88411b06193ba55e82da8ee1907a8064" translate="yes" xml:space="preserve">
          <source>ToUppercase::any</source>
          <target state="translated">ToUppercase::any</target>
        </trans-unit>
        <trans-unit id="7bbc3824337aaeab2c429030633a1af5ed905e80" translate="yes" xml:space="preserve">
          <source>ToUppercase::borrow</source>
          <target state="translated">ToUppercase::borrow</target>
        </trans-unit>
        <trans-unit id="054e212cd833cb188e6198592b3d47a12224a8d7" translate="yes" xml:space="preserve">
          <source>ToUppercase::borrow_mut</source>
          <target state="translated">ToUppercase::borrow_mut</target>
        </trans-unit>
        <trans-unit id="6cb0a8be2d9bacab3bc53f929148bf74eddc427a" translate="yes" xml:space="preserve">
          <source>ToUppercase::by_ref</source>
          <target state="translated">ToUppercase::by_ref</target>
        </trans-unit>
        <trans-unit id="f6523db9347a61697b6b9197bca2d6fba8a42d3c" translate="yes" xml:space="preserve">
          <source>ToUppercase::chain</source>
          <target state="translated">ToUppercase::chain</target>
        </trans-unit>
        <trans-unit id="c0aca2868b888310176cab83baeec3b2d775557f" translate="yes" xml:space="preserve">
          <source>ToUppercase::clone</source>
          <target state="translated">ToUppercase::clone</target>
        </trans-unit>
        <trans-unit id="67fd93e201a873e97c66908ead7ceae8bc1e8a92" translate="yes" xml:space="preserve">
          <source>ToUppercase::clone_from</source>
          <target state="translated">ToUppercase::clone_from</target>
        </trans-unit>
        <trans-unit id="b84ef7303ff66cf2803f532b77195b1cf5d457a1" translate="yes" xml:space="preserve">
          <source>ToUppercase::clone_into</source>
          <target state="translated">ToUppercase::clone_into</target>
        </trans-unit>
        <trans-unit id="5ccbf12c4818e31f1595aa777831465b36f69a51" translate="yes" xml:space="preserve">
          <source>ToUppercase::cloned</source>
          <target state="translated">ToUppercase::cloned</target>
        </trans-unit>
        <trans-unit id="a8f2e905cd5750074d352d368e76df6b39f96427" translate="yes" xml:space="preserve">
          <source>ToUppercase::cmp</source>
          <target state="translated">ToUppercase::cmp</target>
        </trans-unit>
        <trans-unit id="1dc5a2f9004fb521903e5e5a3fd364dc11757205" translate="yes" xml:space="preserve">
          <source>ToUppercase::collect</source>
          <target state="translated">ToUppercase::collect</target>
        </trans-unit>
        <trans-unit id="af8f9ceea80fc5e950363e9318dd158d01a4d040" translate="yes" xml:space="preserve">
          <source>ToUppercase::copied</source>
          <target state="translated">ToUppercase::copied</target>
        </trans-unit>
        <trans-unit id="1366fc011a472ff5d53cde6f1ac86461228351e7" translate="yes" xml:space="preserve">
          <source>ToUppercase::count</source>
          <target state="translated">ToUppercase::count</target>
        </trans-unit>
        <trans-unit id="1184c3c693dff48405ca7548cca0ed458ff29830" translate="yes" xml:space="preserve">
          <source>ToUppercase::cycle</source>
          <target state="translated">ToUppercase::cycle</target>
        </trans-unit>
        <trans-unit id="4e91911466f6b5af4078b70e11c4d24775fe742f" translate="yes" xml:space="preserve">
          <source>ToUppercase::enumerate</source>
          <target state="translated">ToUppercase::enumerate</target>
        </trans-unit>
        <trans-unit id="7840d75ecceac6bb8014df3896750d9d72c6c4f4" translate="yes" xml:space="preserve">
          <source>ToUppercase::eq</source>
          <target state="translated">ToUppercase::eq</target>
        </trans-unit>
        <trans-unit id="2a9bfa9a45635d09ff4f0e7dbad7c78cf4865a99" translate="yes" xml:space="preserve">
          <source>ToUppercase::filter</source>
          <target state="translated">ToUppercase::filter</target>
        </trans-unit>
        <trans-unit id="a2ce94b0c7944e165ba6c67b1e1d6438853b3133" translate="yes" xml:space="preserve">
          <source>ToUppercase::filter_map</source>
          <target state="translated">ToUppercase::filter_map</target>
        </trans-unit>
        <trans-unit id="33b7908aaa91c2cca1edd3fbd1eb5ed2b7161ab8" translate="yes" xml:space="preserve">
          <source>ToUppercase::find</source>
          <target state="translated">ToUppercase::find</target>
        </trans-unit>
        <trans-unit id="26582c132713274fb6090fc39fe168d493ee012a" translate="yes" xml:space="preserve">
          <source>ToUppercase::find_map</source>
          <target state="translated">ToUppercase::find_map</target>
        </trans-unit>
        <trans-unit id="d2233ee6bb72d979bc01f41100247c5902cf0607" translate="yes" xml:space="preserve">
          <source>ToUppercase::flat_map</source>
          <target state="translated">ToUppercase::flat_map</target>
        </trans-unit>
        <trans-unit id="bc467f30c7752c24841765febf75cc9fdc574574" translate="yes" xml:space="preserve">
          <source>ToUppercase::flatten</source>
          <target state="translated">ToUppercase::flatten</target>
        </trans-unit>
        <trans-unit id="da04bbd5685fac2d5a4df3c9db6cca8ac3ddfa78" translate="yes" xml:space="preserve">
          <source>ToUppercase::fmt</source>
          <target state="translated">ToUppercase::fmt</target>
        </trans-unit>
        <trans-unit id="dab772b50aae344c74f698ba5170622c5f015ee3" translate="yes" xml:space="preserve">
          <source>ToUppercase::fold</source>
          <target state="translated">ToUppercase::fold</target>
        </trans-unit>
        <trans-unit id="771853b6cd0b3a3d225b473ef9703bb5e4303729" translate="yes" xml:space="preserve">
          <source>ToUppercase::for_each</source>
          <target state="translated">ToUppercase::for_each</target>
        </trans-unit>
        <trans-unit id="8ce8c4bb893f0605c572e1569c0a3c898fc706ea" translate="yes" xml:space="preserve">
          <source>ToUppercase::from</source>
          <target state="translated">ToUppercase::from</target>
        </trans-unit>
        <trans-unit id="e5bc2c74a5fd665c9a82c2a33e80270730f97b12" translate="yes" xml:space="preserve">
          <source>ToUppercase::fuse</source>
          <target state="translated">ToUppercase::fuse</target>
        </trans-unit>
        <trans-unit id="20067e8f8574346c33f6af0deb21cc95edf75430" translate="yes" xml:space="preserve">
          <source>ToUppercase::ge</source>
          <target state="translated">ToUppercase::ge</target>
        </trans-unit>
        <trans-unit id="d691aa9e30d434c7acd37842ea89626858043c5a" translate="yes" xml:space="preserve">
          <source>ToUppercase::gt</source>
          <target state="translated">ToUppercase::gt</target>
        </trans-unit>
        <trans-unit id="2c07bcd9aa88f2987da2c05609b8b051fbd0bd49" translate="yes" xml:space="preserve">
          <source>ToUppercase::inspect</source>
          <target state="translated">ToUppercase::inspect</target>
        </trans-unit>
        <trans-unit id="fdebac9771e781ff415a919dcfc0e2e2f813f95f" translate="yes" xml:space="preserve">
          <source>ToUppercase::into</source>
          <target state="translated">ToUppercase::into</target>
        </trans-unit>
        <trans-unit id="28c925e3769d53d774548da83c53adf049d9614e" translate="yes" xml:space="preserve">
          <source>ToUppercase::into_iter</source>
          <target state="translated">ToUppercase::into_iter</target>
        </trans-unit>
        <trans-unit id="bf3856a1c7cdbe8a6b0b5d5447d4f1dda66c5b87" translate="yes" xml:space="preserve">
          <source>ToUppercase::is_empty</source>
          <target state="translated">ToUppercase::is_empty</target>
        </trans-unit>
        <trans-unit id="e56ebe838b86d90990ba23ebb8e7d7b475bfba70" translate="yes" xml:space="preserve">
          <source>ToUppercase::is_sorted</source>
          <target state="translated">ToUppercase::is_sorted</target>
        </trans-unit>
        <trans-unit id="e213f890c3567bf89ebbd96dd28396c3c8369989" translate="yes" xml:space="preserve">
          <source>ToUppercase::is_sorted_by</source>
          <target state="translated">ToUppercase::is_sorted_by</target>
        </trans-unit>
        <trans-unit id="4214e06077f37c115583c69ea8457f9ca4ca03c8" translate="yes" xml:space="preserve">
          <source>ToUppercase::is_sorted_by_key</source>
          <target state="translated">ToUppercase::is_sorted_by_key</target>
        </trans-unit>
        <trans-unit id="43c20634324c1e57c53610dd095c7b85f97be6a8" translate="yes" xml:space="preserve">
          <source>ToUppercase::last</source>
          <target state="translated">ToUppercase::last</target>
        </trans-unit>
        <trans-unit id="e15b9289846aa62aa7c399eec130546dddf92570" translate="yes" xml:space="preserve">
          <source>ToUppercase::le</source>
          <target state="translated">ToUppercase::le</target>
        </trans-unit>
        <trans-unit id="bf4ae1725f8c939f34b0f3698672e2eca8d46e36" translate="yes" xml:space="preserve">
          <source>ToUppercase::len</source>
          <target state="translated">ToUppercase::len</target>
        </trans-unit>
        <trans-unit id="6ef86484cb6e83aca67edc255bfe91855fddeaee" translate="yes" xml:space="preserve">
          <source>ToUppercase::lt</source>
          <target state="translated">ToUppercase::lt</target>
        </trans-unit>
        <trans-unit id="36fb30f84e7d12187cc3a5d20674f0ffa2e7e434" translate="yes" xml:space="preserve">
          <source>ToUppercase::map</source>
          <target state="translated">ToUppercase::map</target>
        </trans-unit>
        <trans-unit id="a5794f06c8f621ebfd36483cb2bdfba69962a46b" translate="yes" xml:space="preserve">
          <source>ToUppercase::max</source>
          <target state="translated">ToUppercase::max</target>
        </trans-unit>
        <trans-unit id="54ed5ffb42b174875a2cfcdf299aa03324e7d8e8" translate="yes" xml:space="preserve">
          <source>ToUppercase::max_by</source>
          <target state="translated">ToUppercase::max_by</target>
        </trans-unit>
        <trans-unit id="82140a942c03457466b33d70a38f8b426ee443a8" translate="yes" xml:space="preserve">
          <source>ToUppercase::max_by_key</source>
          <target state="translated">ToUppercase::max_by_key</target>
        </trans-unit>
        <trans-unit id="8c46ff457e70dbefd5377da1fe14a1d716feed69" translate="yes" xml:space="preserve">
          <source>ToUppercase::min</source>
          <target state="translated">ToUppercase::min</target>
        </trans-unit>
        <trans-unit id="1f4f06fa647a15bfd6777e3ad80989539da952c2" translate="yes" xml:space="preserve">
          <source>ToUppercase::min_by</source>
          <target state="translated">ToUppercase::min_by</target>
        </trans-unit>
        <trans-unit id="d2ca7b43662db6e83751c9781321c5f447b69b54" translate="yes" xml:space="preserve">
          <source>ToUppercase::min_by_key</source>
          <target state="translated">ToUppercase::min_by_key</target>
        </trans-unit>
        <trans-unit id="a2c10d642735dd01dd2230f6eb42d2d15de01ca4" translate="yes" xml:space="preserve">
          <source>ToUppercase::ne</source>
          <target state="translated">ToUppercase::ne</target>
        </trans-unit>
        <trans-unit id="bdcf8b574275972312b79411fc90c298fec5c707" translate="yes" xml:space="preserve">
          <source>ToUppercase::next</source>
          <target state="translated">ToUppercase::next</target>
        </trans-unit>
        <trans-unit id="d3b98223ff39c0cf8bc6901176a913dbb5af5a3f" translate="yes" xml:space="preserve">
          <source>ToUppercase::nth</source>
          <target state="translated">ToUppercase::nth</target>
        </trans-unit>
        <trans-unit id="ac55c59ffb3d1b90b5281f1cdb8221031a9f3d86" translate="yes" xml:space="preserve">
          <source>ToUppercase::partial_cmp</source>
          <target state="translated">ToUppercase::partial_cmp</target>
        </trans-unit>
        <trans-unit id="43ba4010531c56c76a71cac5c7783bb9326c06ff" translate="yes" xml:space="preserve">
          <source>ToUppercase::partition</source>
          <target state="translated">ToUppercase::partition</target>
        </trans-unit>
        <trans-unit id="8a67cd96d9e9df3939b7f6b2d037a84acda5915a" translate="yes" xml:space="preserve">
          <source>ToUppercase::peekable</source>
          <target state="translated">ToUppercase::peekable</target>
        </trans-unit>
        <trans-unit id="c5de4cd05b5eea91f6372ea13496d89698a886d9" translate="yes" xml:space="preserve">
          <source>ToUppercase::position</source>
          <target state="translated">ToUppercase::position</target>
        </trans-unit>
        <trans-unit id="3276e7acdf8a52ca46452466df5445f95d4c42ce" translate="yes" xml:space="preserve">
          <source>ToUppercase::product</source>
          <target state="translated">ToUppercase::product</target>
        </trans-unit>
        <trans-unit id="2ec3aca6fa0998e131a8dbb7e0429f53b8e20e3a" translate="yes" xml:space="preserve">
          <source>ToUppercase::rev</source>
          <target state="translated">ToUppercase::rev</target>
        </trans-unit>
        <trans-unit id="1f5b04931231d64a89f93330632ae0491d9a8306" translate="yes" xml:space="preserve">
          <source>ToUppercase::rposition</source>
          <target state="translated">ToUppercase::rposition</target>
        </trans-unit>
        <trans-unit id="bd0bd16a7f62be84e2b4f57e866e556615bf5f51" translate="yes" xml:space="preserve">
          <source>ToUppercase::scan</source>
          <target state="translated">ToUppercase::scan</target>
        </trans-unit>
        <trans-unit id="c12a079f9acc9eb022d00c3c9e691984df24e3dd" translate="yes" xml:space="preserve">
          <source>ToUppercase::size_hint</source>
          <target state="translated">ToUppercase::size_hint</target>
        </trans-unit>
        <trans-unit id="36cc8342ae3ebfcc66e29de8713ad4b5d25ed1ec" translate="yes" xml:space="preserve">
          <source>ToUppercase::skip</source>
          <target state="translated">ToUppercase::skip</target>
        </trans-unit>
        <trans-unit id="bc763b46d6ffe3cde30022e6b310b987fb4690fc" translate="yes" xml:space="preserve">
          <source>ToUppercase::skip_while</source>
          <target state="translated">ToUppercase::skip_while</target>
        </trans-unit>
        <trans-unit id="bdd73144830ccf5acc66a08a0eb4055b58dd100c" translate="yes" xml:space="preserve">
          <source>ToUppercase::step_by</source>
          <target state="translated">ToUppercase::step_by</target>
        </trans-unit>
        <trans-unit id="355510b3a2c94feee0516eb6236e6b26c520c86f" translate="yes" xml:space="preserve">
          <source>ToUppercase::sum</source>
          <target state="translated">ToUppercase::sum</target>
        </trans-unit>
        <trans-unit id="5f1bfaa41ae891ff2a87080b765b405813dfaf1e" translate="yes" xml:space="preserve">
          <source>ToUppercase::take</source>
          <target state="translated">ToUppercase::take</target>
        </trans-unit>
        <trans-unit id="ace4eaaac22836c883eb26f26b69083a1e81c44a" translate="yes" xml:space="preserve">
          <source>ToUppercase::take_while</source>
          <target state="translated">ToUppercase::take_while</target>
        </trans-unit>
        <trans-unit id="aeac81822411ec59962d593c1135903013fb64dd" translate="yes" xml:space="preserve">
          <source>ToUppercase::to_owned</source>
          <target state="translated">ToUppercase::to_owned</target>
        </trans-unit>
        <trans-unit id="c254c93eabb3947af47ca116107ff60db0f65f9f" translate="yes" xml:space="preserve">
          <source>ToUppercase::to_string</source>
          <target state="translated">ToUppercase::to_string</target>
        </trans-unit>
        <trans-unit id="9586835b3ffa68bc81bff272ded62df7bfd896a5" translate="yes" xml:space="preserve">
          <source>ToUppercase::try_fold</source>
          <target state="translated">ToUppercase::try_fold</target>
        </trans-unit>
        <trans-unit id="3285dc30d7466785bb24e349a2a90f48ee1105df" translate="yes" xml:space="preserve">
          <source>ToUppercase::try_for_each</source>
          <target state="translated">ToUppercase::try_for_each</target>
        </trans-unit>
        <trans-unit id="f78675d80da0fb2dc076781338842ee7388e6bbb" translate="yes" xml:space="preserve">
          <source>ToUppercase::try_from</source>
          <target state="translated">ToUppercase::try_from</target>
        </trans-unit>
        <trans-unit id="bbc85f420c55ff506706c343e3d016f559155d33" translate="yes" xml:space="preserve">
          <source>ToUppercase::try_into</source>
          <target state="translated">ToUppercase::try_into</target>
        </trans-unit>
        <trans-unit id="67c5523cb2fdea348c069bcedcae5b194e0fa100" translate="yes" xml:space="preserve">
          <source>ToUppercase::type_id</source>
          <target state="translated">ToUppercase::type_id</target>
        </trans-unit>
        <trans-unit id="59512192fd21e6e15883e4c5f16fa785a7ae4b9e" translate="yes" xml:space="preserve">
          <source>ToUppercase::unzip</source>
          <target state="translated">ToUppercase::unzip</target>
        </trans-unit>
        <trans-unit id="71c5320853e9bf97d3c8e47e587d200e6ab7e991" translate="yes" xml:space="preserve">
          <source>ToUppercase::zip</source>
          <target state="translated">ToUppercase::zip</target>
        </trans-unit>
        <trans-unit id="c38c6c1f3a2743f8626703abb302e403d20ff81c" translate="yes" xml:space="preserve">
          <source>Tokens</source>
          <target state="translated">Tokens</target>
        </trans-unit>
        <trans-unit id="23b07a92f99f26864b1d4cab09dbe7e6ffc01402" translate="yes" xml:space="preserve">
          <source>Tokens are primitive productions in the grammar defined by regular (non-recursive) languages. Rust source input can be broken down into the following kinds of tokens:</source>
          <target state="translated">Жетоны-это примитивные произведения в грамматике,определяемые обычными (не рекурсивными)языками.Входные данные источника ржавчины могут быть разбиты на следующие виды токенов:</target>
        </trans-unit>
        <trans-unit id="d3997b5b9595479642fa6a353b8f62de4c85bdb4" translate="yes" xml:space="preserve">
          <source>Too few type arguments were supplied for a function. For example:</source>
          <target state="translated">Слишком мало аргументов типа было предоставлено для функции.Например:</target>
        </trans-unit>
        <trans-unit id="b64cc80b4d048074e951f53af2266c9b980ecc1d" translate="yes" xml:space="preserve">
          <source>Too many type arguments were supplied for a function. For example:</source>
          <target state="translated">Слишком много аргументов типа было предоставлено для функции.Например:</target>
        </trans-unit>
        <trans-unit id="3becdad8640a8a7664cb1587373bbed530e9eaef" translate="yes" xml:space="preserve">
          <source>Tool attributes</source>
          <target state="translated">Атрибуты инструмента</target>
        </trans-unit>
        <trans-unit id="298b5435880f729f28b40fb8cb4d6d358f7d7bda" translate="yes" xml:space="preserve">
          <source>Tool attributes are not available if the &lt;a href=&quot;items/modules#prelude-items&quot;&gt;&lt;code&gt;no_implicit_prelude&lt;/code&gt;&lt;/a&gt; attribute is used.</source>
          <target state="translated">Атрибуты инструмента недоступны, если &lt;a href=&quot;items/modules#prelude-items&quot;&gt; &lt;code&gt;no_implicit_prelude&lt;/code&gt; &lt;/a&gt; атрибут no_implicit_prelude .</target>
        </trans-unit>
        <trans-unit id="04ecf72079460c624f56de2aec19167e9b592e5f" translate="yes" xml:space="preserve">
          <source>Tool lint attributes</source>
          <target state="translated">Атрибуты ворса инструмента</target>
        </trans-unit>
        <trans-unit id="9e4ff695f8d7f54d10234c8c693febf11bceeb0a" translate="yes" xml:space="preserve">
          <source>Tool lints allows using scoped lints, to &lt;code&gt;allow&lt;/code&gt;, &lt;code&gt;warn&lt;/code&gt;, &lt;code&gt;deny&lt;/code&gt; or &lt;code&gt;forbid&lt;/code&gt; lints of certain tools.</source>
          <target state="translated">Инструмент позволяет Линц с помощью контекстного Линца, чтобы &lt;code&gt;allow&lt;/code&gt; , &lt;code&gt;warn&lt;/code&gt; , &lt;code&gt;deny&lt;/code&gt; или &lt;code&gt;forbid&lt;/code&gt; Линц определенных инструментов.</target>
        </trans-unit>
        <trans-unit id="b0cfacecf587078db6db43488caa6d580978c4bb" translate="yes" xml:space="preserve">
          <source>Tool lints only get checked when the associated tool is active. If a lint attribute, such as &lt;code&gt;allow&lt;/code&gt;, references a nonexistent tool lint, the compiler will not warn about the nonexistent lint until you use the tool.</source>
          <target state="translated">Линия инструмента проверяется только тогда, когда соответствующий инструмент активен. Если атрибут lint, такой как &lt;code&gt;allow&lt;/code&gt; , ссылается на несуществующий lint инструмента, компилятор не предупредит о несуществующем lint, пока вы не воспользуетесь этим инструментом.</target>
        </trans-unit>
        <trans-unit id="2b3bf7074f1000742128073f003a13e0d75375fa" translate="yes" xml:space="preserve">
          <source>Tracking the inebriation of customers at a bar</source>
          <target state="translated">Отслеживание интоксикации клиентов в баре</target>
        </trans-unit>
        <trans-unit id="dad674e48704a92597b8a13244ba1d8ca29324b7" translate="yes" xml:space="preserve">
          <source>Trade-offs</source>
          <target state="translated">Trade-offs</target>
        </trans-unit>
        <trans-unit id="8a6c5b14d85fb7777855348d57172119a05a9066" translate="yes" xml:space="preserve">
          <source>Trade-offs of the State Pattern</source>
          <target state="translated">Компромиссы государственного образца</target>
        </trans-unit>
        <trans-unit id="b36366d44b437b0f859e29f4614b0107cecfe355" translate="yes" xml:space="preserve">
          <source>Trait</source>
          <target state="translated">Trait</target>
        </trans-unit>
        <trans-unit id="7418cda1dddd9f707baf2b1acabeb7297ddae8f4" translate="yes" xml:space="preserve">
          <source>Trait Bound Syntax</source>
          <target state="translated">Связанный с признаками синтаксис</target>
        </trans-unit>
        <trans-unit id="79d040a039f209d4b088e4414045e49f19a318f9" translate="yes" xml:space="preserve">
          <source>Trait Implementation Coherence</source>
          <target state="translated">Согласованность реализации признаков</target>
        </trans-unit>
        <trans-unit id="26b898f7f42ac0607067211907cfe144baef2099" translate="yes" xml:space="preserve">
          <source>Trait Implementations</source>
          <target state="translated">Трейт-внедрение</target>
        </trans-unit>
        <trans-unit id="29c33623e3eecc134b62bfbdf8421daa25449235" translate="yes" xml:space="preserve">
          <source>Trait Object Layout</source>
          <target state="translated">Макет объекта</target>
        </trans-unit>
        <trans-unit id="1d17f32f109df2cae8776e118c0cd08d010484eb" translate="yes" xml:space="preserve">
          <source>Trait Object Lifetime Bounds</source>
          <target state="translated">Черты объекта Срок годности</target>
        </trans-unit>
        <trans-unit id="0f2fa6f9f52d26ee86cd56ce4895853eea3665a6" translate="yes" xml:space="preserve">
          <source>Trait Objects Perform Dynamic Dispatch</source>
          <target state="translated">Трейт-объекты выполняют динамическую отправку</target>
        </trans-unit>
        <trans-unit id="a75e14ab76ff0ab816d5d3c2937abd862e423b2f" translate="yes" xml:space="preserve">
          <source>Trait and lifetime bounds</source>
          <target state="translated">Признак и пожизненные ограничения</target>
        </trans-unit>
        <trans-unit id="41af368f93d8a39d7122b161977ffe16f6a12e35" translate="yes" xml:space="preserve">
          <source>Trait and lifetime bounds are also used to name &lt;a href=&quot;types/trait-object&quot;&gt;trait objects&lt;/a&gt;.</source>
          <target state="translated">Границы признаков и времени жизни также используются для именования &lt;a href=&quot;types/trait-object&quot;&gt;объектов признаков&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="941497474640686e1a5e201b7a0add49b752830f" translate="yes" xml:space="preserve">
          <source>Trait bounds</source>
          <target state="translated">Границы признаков</target>
        </trans-unit>
        <trans-unit id="4fcf62d60d13dd717001ca9dd0618f2bf25f60fb" translate="yes" xml:space="preserve">
          <source>Trait for equality comparisons which are &lt;a href=&quot;http://en.wikipedia.org/wiki/Partial_equivalence_relation&quot;&gt;partial equivalence relations&lt;/a&gt;.</source>
          <target state="translated">Признак для сравнений на равенство, которые являются &lt;a href=&quot;http://en.wikipedia.org/wiki/Partial_equivalence_relation&quot;&gt;отношениями частичной эквивалентности&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="ef0a7e79d3d4953fe69d9a8d5ee6294c86326bfd" translate="yes" xml:space="preserve">
          <source>Trait for equality comparisons which are &lt;a href=&quot;https://en.wikipedia.org/wiki/Equivalence_relation&quot;&gt;equivalence relations&lt;/a&gt;.</source>
          <target state="translated">Признак для сравнений на равенство, которые являются &lt;a href=&quot;https://en.wikipedia.org/wiki/Equivalence_relation&quot;&gt;отношениями эквивалентности&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="eac0088c6ab97a23265d057818a34fc5c7b03fb7" translate="yes" xml:space="preserve">
          <source>Trait for equality comparisons which are &lt;a href=&quot;https://en.wikipedia.org/wiki/Partial_equivalence_relation&quot;&gt;partial equivalence relations&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8cec9bd7b654341aff1af9f8d64c24f966f7b024" translate="yes" xml:space="preserve">
          <source>Trait for types that form a &lt;a href=&quot;https://en.wikipedia.org/wiki/Total_order&quot;&gt;total order&lt;/a&gt;.</source>
          <target state="translated">Признак для типов, образующих &lt;a href=&quot;https://en.wikipedia.org/wiki/Total_order&quot;&gt;общий порядок&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="eda5d9fc229c855a2ef6aa3c2bfb5731468bf0cc" translate="yes" xml:space="preserve">
          <source>Trait for values that can be compared for a sort-order.</source>
          <target state="translated">Трейт для значений,которые можно сравнить для сортировочного заказа.</target>
        </trans-unit>
        <trans-unit id="64186133cfc350eebda0888af60b096eb938c6a7" translate="yes" xml:space="preserve">
          <source>Trait implementations</source>
          <target state="translated">Линейные внедрения</target>
        </trans-unit>
        <trans-unit id="ddca8ab133e8a574bb0807189227aaf80ac0b4fc" translate="yes" xml:space="preserve">
          <source>Trait implementations can only implement associated constants that are members of the trait in question.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1a2ed29df58a98467df7b65482664c061f2e57d4" translate="yes" xml:space="preserve">
          <source>Trait implementations can only implement associated constants that are members of the trait in question. This error indicates that you attempted to implement an associated constant whose name does not match the name of any associated constant in the trait.</source>
          <target state="translated">Реализации трейта могут реализовывать только ассоциированные константы,являющиеся членами рассматриваемого трейта.Эта ошибка указывает на то,что Вы пытались реализовать ассоциированную константу,имя которой не совпадает с именем ни одной ассоциированной константы в трейте.</target>
        </trans-unit>
        <trans-unit id="826d4810ddc337c0170d557193ecb3f363cb0584" translate="yes" xml:space="preserve">
          <source>Trait implementations can only implement associated types that are members of the trait in question.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dc82d5ecd28dae290ae968b51be9ef3018535288" translate="yes" xml:space="preserve">
          <source>Trait implementations can only implement associated types that are members of the trait in question. This error indicates that you attempted to implement an associated type whose name does not match the name of any associated type in the trait.</source>
          <target state="translated">Реализации трейта могут реализовывать только ассоциированные типы,являющиеся членами рассматриваемого трейта.Эта ошибка указывает на то,что Вы пытались реализовать ассоциированный тип,имя которого не совпадает с именем ни одного ассоциированного типа в трейте.</target>
        </trans-unit>
        <trans-unit id="24048bbeb068432309ce266edfa2a054d72baec8" translate="yes" xml:space="preserve">
          <source>Trait items syntactically allow a &lt;a href=&quot;../visibility-and-privacy&quot;&gt;&lt;em&gt;Visibility&lt;/em&gt;&lt;/a&gt; annotation, but this is rejected when the trait is validated. This allows items to be parsed with a unified syntax across different contexts where they are used. As an example, an empty &lt;code&gt;vis&lt;/code&gt; macro fragment specifier can be used for trait items, where the macro rule may be used in other situations where visibility is allowed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="93dc7d0661c7c1cf56a871254e1715d367179182" translate="yes" xml:space="preserve">
          <source>Trait methods cannot be declared &lt;code&gt;const&lt;/code&gt; by design. For more information, see &lt;a href=&quot;https://github.com/rust-lang/rfcs/pull/911&quot;&gt;RFC 911&lt;/a&gt;.</source>
          <target state="translated">Методы трейта не могут быть объявлены &lt;code&gt;const&lt;/code&gt; по дизайну. Для получения дополнительной информации см. &lt;a href=&quot;https://github.com/rust-lang/rfcs/pull/911&quot;&gt;RFC 911&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="3a51226ce6186ef57bc4f8d39074c6398e097981" translate="yes" xml:space="preserve">
          <source>Trait methods currently cannot take patterns as arguments.</source>
          <target state="translated">Трейт-методы в настоящее время не могут принимать паттерны в качестве аргументов.</target>
        </trans-unit>
        <trans-unit id="2484ce752e551a673766cb07f53076cdd0470999" translate="yes" xml:space="preserve">
          <source>Trait objects</source>
          <target state="translated">Чертовы предметы</target>
        </trans-unit>
        <trans-unit id="d0ff67bb0a0ee2576fc48fed596bc8092c7aa725" translate="yes" xml:space="preserve">
          <source>Trait objects are a form of dynamic dispatch and use a dynamically sized type for the inner type. So, for a given trait &lt;code&gt;Trait&lt;/code&gt;, when &lt;code&gt;Trait&lt;/code&gt; is treated as a type, as in &lt;code&gt;Box&amp;lt;Trait&amp;gt;&lt;/code&gt;, the inner type is 'unsized'. In such cases the boxed pointer is a 'fat pointer' that contains an extra pointer to a table of methods (among other things) for dynamic dispatch. This design mandates some restrictions on the types of traits that are allowed to be used in trait objects, which are collectively termed as 'object safety' rules.</source>
          <target state="translated">Объекты-черты представляют собой форму динамической отправки и используют тип с динамическим размером для внутреннего типа. Таким образом, для данного признака &lt;code&gt;Trait&lt;/code&gt; , когда &lt;code&gt;Trait&lt;/code&gt; рассматривается как тип, как в &lt;code&gt;Box&amp;lt;Trait&amp;gt;&lt;/code&gt; , внутренний тип является &amp;laquo;безразмерным&amp;raquo;. В таких случаях указатель в рамке представляет собой &amp;laquo;толстый указатель&amp;raquo;, который содержит дополнительный указатель на таблицу методов (среди прочего) для динамической отправки. Этот дизайн налагает некоторые ограничения на типы признаков, которые разрешено использовать в объектах признаков, которые в совокупности называются правилами &amp;laquo;безопасности объекта&amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="5ea53f21fe7d48d8c36beccecda99fd8c1606afe" translate="yes" xml:space="preserve">
          <source>Trait objects are written as the optional keyword &lt;code&gt;dyn&lt;/code&gt; followed by a set of trait bounds, but with the following restrictions on the trait bounds. All traits except the first trait must be auto traits, there may not be more than one lifetime, and opt-out bounds (e.g. &lt;code&gt;?Sized&lt;/code&gt;) are not allowed. Furthermore, paths to traits may be parenthesized.</source>
          <target state="translated">Объекты признаков записываются как необязательное ключевое слово &lt;code&gt;dyn&lt;/code&gt; , за которым следует набор границ признаков, но со следующими ограничениями на границы признаков. Все черты, кроме первого, должны быть автоматическими, не может быть более одного времени жизни, и ограничения отказа (например, &lt;code&gt;?Sized&lt;/code&gt; ) не допускаются. Кроме того, пути к характеристикам могут быть заключены в скобки.</target>
        </trans-unit>
        <trans-unit id="59817a6fb01d811236061d6945ce61c60bbb6a8e" translate="yes" xml:space="preserve">
          <source>Trait objects have the same layout as the value the trait object is of.</source>
          <target state="translated">Объекты трейта имеют такое же расположение,что и значение,которое имеет объект трейта.</target>
        </trans-unit>
        <trans-unit id="1bbbb43369cd1da1e54ccdae8b4bbe0c9a735c31" translate="yes" xml:space="preserve">
          <source>Trait objects implement the base trait, its auto traits, and any &lt;a href=&quot;../items/traits#supertraits&quot;&gt;supertraits&lt;/a&gt; of the base trait.</source>
          <target state="translated">Объекты-черты реализуют базовую черту, ее автоматические черты и любые &lt;a href=&quot;../items/traits#supertraits&quot;&gt;надстройки&lt;/a&gt; базовой черты.</target>
        </trans-unit>
        <trans-unit id="d4f37b1632bc74808bbd4522d9d582acfc5a118f" translate="yes" xml:space="preserve">
          <source>Trait objects like &lt;code&gt;Box&amp;lt;Trait&amp;gt;&lt;/code&gt; can only be constructed when certain requirements are satisfied by the trait in question.</source>
          <target state="translated">Объекты-черты, такие как &lt;code&gt;Box&amp;lt;Trait&amp;gt;&lt;/code&gt; могут быть созданы только тогда, когда определенные требования удовлетворяются рассматриваемым признаком.</target>
        </trans-unit>
        <trans-unit id="046dc44c748313b6f776a3acf8abdd3d74f9acc5" translate="yes" xml:space="preserve">
          <source>Trait objects need to have all associated types specified. Erroneous code example:</source>
          <target state="translated">Объекты трейта должны иметь все ассоциированные типы.Пример ошибочного кода:</target>
        </trans-unit>
        <trans-unit id="e77aaa69af7e604fc6cf7c5dbf4abb6705458260" translate="yes" xml:space="preserve">
          <source>Trait objects need to have all associated types specified. Please verify that all associated types of the trait were specified and the correct trait was used. Example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ad068a7a9dcf8a835215d9d2bd6df82d37ea9f8e" translate="yes" xml:space="preserve">
          <source>Trait std::alloc::Alloc</source>
          <target state="translated">Трейт std::allocation::Alloc</target>
        </trans-unit>
        <trans-unit id="863608218cf19a899841e79768deb9add49e00f3" translate="yes" xml:space="preserve">
          <source>Trait std::alloc::GlobalAlloc</source>
          <target state="translated">Трейт std::allocation::GlobalAlloc</target>
        </trans-unit>
        <trans-unit id="392d8121c387b6100e7dca67e7c52d32a16a3def" translate="yes" xml:space="preserve">
          <source>Trait std::any::Any</source>
          <target state="translated">Сверхъестественная черта::любая::любая</target>
        </trans-unit>
        <trans-unit id="0bdbfe0deda36628eacc51abdb83fdbfcea6cc11" translate="yes" xml:space="preserve">
          <source>Trait std::array::FixedSizeArray</source>
          <target state="translated">Трейт std::array::FixedSizeArray</target>
        </trans-unit>
        <trans-unit id="1eb8a5154ce5a680a452312a74723021b34c3aaa" translate="yes" xml:space="preserve">
          <source>Trait std::ascii::AsciiExt</source>
          <target state="translated">Стандартная черта::acii::AsciiExt</target>
        </trans-unit>
        <trans-unit id="5de77502b5980be7c3473a72d6105527f1215243" translate="yes" xml:space="preserve">
          <source>Trait std::borrow::Borrow</source>
          <target state="translated">Trait std::borrow::loan::loan</target>
        </trans-unit>
        <trans-unit id="70f054dd274fb96a8db0596d418507c91adce6b6" translate="yes" xml:space="preserve">
          <source>Trait std::borrow::BorrowMut</source>
          <target state="translated">Trait std::borrow::BorrowMut</target>
        </trans-unit>
        <trans-unit id="bbcce0cbc4cb2a4bf5264b04d903d25c0a192013" translate="yes" xml:space="preserve">
          <source>Trait std::borrow::ToOwned</source>
          <target state="translated">Trait std::borrow::ToOwned</target>
        </trans-unit>
        <trans-unit id="f2b9f8276056ca658e39ee7a72fdcb03a7c37efb" translate="yes" xml:space="preserve">
          <source>Trait std::clone::Clone</source>
          <target state="translated">Трейт std::клон::клон</target>
        </trans-unit>
        <trans-unit id="7cd5d0fd30409561bc6e76fd837e1f62470836a8" translate="yes" xml:space="preserve">
          <source>Trait std::cmp::Eq</source>
          <target state="translated">Стэндвич::cmp::Eq</target>
        </trans-unit>
        <trans-unit id="246cf166657201c68115fb66fd9221b8ffeb9ec4" translate="yes" xml:space="preserve">
          <source>Trait std::cmp::Ord</source>
          <target state="translated">Строка std::cmp::Приказ</target>
        </trans-unit>
        <trans-unit id="72ff4c9778d08578e0f03c27d9d6272685274d91" translate="yes" xml:space="preserve">
          <source>Trait std::cmp::PartialEq</source>
          <target state="translated">Std::cmp::PartialEq line</target>
        </trans-unit>
        <trans-unit id="4fde07025ebb4afc05e6897ef74b43fe5347e982" translate="yes" xml:space="preserve">
          <source>Trait std::cmp::PartialOrd</source>
          <target state="translated">Std line::cmp::PartialOrd</target>
        </trans-unit>
        <trans-unit id="d870aa7cb7664d7c10835889d14c6b391cb4500e" translate="yes" xml:space="preserve">
          <source>Trait std::convert::AsMut</source>
          <target state="translated">Std line::convert::AsMut</target>
        </trans-unit>
        <trans-unit id="d445d52fad68586ece567104043e8c242d2c7a73" translate="yes" xml:space="preserve">
          <source>Trait std::convert::AsRef</source>
          <target state="translated">Std line::convert::AsRef</target>
        </trans-unit>
        <trans-unit id="1da7f8aa53cf47c39294631d860061958af42da6" translate="yes" xml:space="preserve">
          <source>Trait std::convert::From</source>
          <target state="translated">Std line::convert::From</target>
        </trans-unit>
        <trans-unit id="b6ffd418e0a0b6d0cb5548ea09febb34aa5a1ba4" translate="yes" xml:space="preserve">
          <source>Trait std::convert::Into</source>
          <target state="translated">Std line::convert::Into</target>
        </trans-unit>
        <trans-unit id="4d1380373e375c0e4553b789733d1a89b1fb0101" translate="yes" xml:space="preserve">
          <source>Trait std::convert::TryFrom</source>
          <target state="translated">Std line::convert::TryFrom</target>
        </trans-unit>
        <trans-unit id="052f060bad402d8a2cd358057bd4871783c01ba4" translate="yes" xml:space="preserve">
          <source>Trait std::convert::TryInto</source>
          <target state="translated">Стд черта::конвертировать::попробовать...</target>
        </trans-unit>
        <trans-unit id="36871446454b625eddb2f384614252a30a76670d" translate="yes" xml:space="preserve">
          <source>Trait std::default::Default</source>
          <target state="translated">Трейт std::по умолчанию::По умолчанию</target>
        </trans-unit>
        <trans-unit id="adf0d0f8b00918a2c28aba66b14f04f6c4e0fded" translate="yes" xml:space="preserve">
          <source>Trait std::error::Error</source>
          <target state="translated">Std строка::ошибка::Ошибка</target>
        </trans-unit>
        <trans-unit id="c2d288fe88fdd80f7dd81a3a1f2aeef5dc8ba7dc" translate="yes" xml:space="preserve">
          <source>Trait std::fmt::Binary</source>
          <target state="translated">Стд черта::fmt::бинарный</target>
        </trans-unit>
        <trans-unit id="33f44cc3a6de7dd1507041a00c8faf2775c0c8df" translate="yes" xml:space="preserve">
          <source>Trait std::fmt::Debug</source>
          <target state="translated">Трейт std::fmt::Debug</target>
        </trans-unit>
        <trans-unit id="245d17885bbc5448412416b59b0f51c9d9b68eac" translate="yes" xml:space="preserve">
          <source>Trait std::fmt::Display</source>
          <target state="translated">Трейт std::fmt::Display</target>
        </trans-unit>
        <trans-unit id="c8de6a747580fa084cc85d42225e02c2e93e67d5" translate="yes" xml:space="preserve">
          <source>Trait std::fmt::LowerExp</source>
          <target state="translated">Трейт std::fmt::LowerExp</target>
        </trans-unit>
        <trans-unit id="e725d6041bd9bc4d83fca5b07971b62d421e6e64" translate="yes" xml:space="preserve">
          <source>Trait std::fmt::LowerHex</source>
          <target state="translated">Трейт std::fmt::LowerHex</target>
        </trans-unit>
        <trans-unit id="194006985569f163bb35c90c3abcdbc7deec0e4a" translate="yes" xml:space="preserve">
          <source>Trait std::fmt::Octal</source>
          <target state="translated">Std::fmt::Octal line</target>
        </trans-unit>
        <trans-unit id="8a32cd848a50f19a4618eac36d5bd1b3a315cf4d" translate="yes" xml:space="preserve">
          <source>Trait std::fmt::Pointer</source>
          <target state="translated">Std line::fmt::Pointer</target>
        </trans-unit>
        <trans-unit id="8718228edc98337e120714c5797ad6fa1124ce31" translate="yes" xml:space="preserve">
          <source>Trait std::fmt::UpperExp</source>
          <target state="translated">Трейт std::fmt::UpperExp</target>
        </trans-unit>
        <trans-unit id="26a977a1233b688edd74d1ce605bed2138e89350" translate="yes" xml:space="preserve">
          <source>Trait std::fmt::UpperHex</source>
          <target state="translated">Стд линия::fmt::UpperHex</target>
        </trans-unit>
        <trans-unit id="0e6b8aa3448ea0d1e3124dcc61d87f01fb6bfd66" translate="yes" xml:space="preserve">
          <source>Trait std::fmt::Write</source>
          <target state="translated">Std line::fmt::Write</target>
        </trans-unit>
        <trans-unit id="e8d3634caaf52ad6c8639c87d834bc299c37f7d5" translate="yes" xml:space="preserve">
          <source>Trait std::future::Future</source>
          <target state="translated">Трейт std::future::Future</target>
        </trans-unit>
        <trans-unit id="e9cb7ef33fdeeee2adf1be409e245554e4935f7b" translate="yes" xml:space="preserve">
          <source>Trait std::hash::BuildHasher</source>
          <target state="translated">Трейт std::hash::BuildHasher</target>
        </trans-unit>
        <trans-unit id="c7747499a3fe2fcc70735dec924c847206626023" translate="yes" xml:space="preserve">
          <source>Trait std::hash::Hash</source>
          <target state="translated">Std line::hash::Hash</target>
        </trans-unit>
        <trans-unit id="2254c3bc605b18ffc7e9aa4bd6f57a17e5b13944" translate="yes" xml:space="preserve">
          <source>Trait std::hash::Hasher</source>
          <target state="translated">Стд черта::хэш:Хэшер</target>
        </trans-unit>
        <trans-unit id="fd3fa6f5ef1435b1cb913f92dfb4fe0a0ac0248a" translate="yes" xml:space="preserve">
          <source>Trait std::io::BufRead</source>
          <target state="translated">Стд черта::io::BufRead</target>
        </trans-unit>
        <trans-unit id="4c4e965bc67dd33a7c09b8db70c86024088aa45b" translate="yes" xml:space="preserve">
          <source>Trait std::io::Read</source>
          <target state="translated">Стд черта::io::Read</target>
        </trans-unit>
        <trans-unit id="5d0aac0ef2620914932ce91ac2b555eba9c75b6a" translate="yes" xml:space="preserve">
          <source>Trait std::io::Seek</source>
          <target state="translated">Стд черта::io::Seek</target>
        </trans-unit>
        <trans-unit id="23c37542e0343a876f9566d6681875d507142219" translate="yes" xml:space="preserve">
          <source>Trait std::io::Write</source>
          <target state="translated">Стд черта::io::Пишите.</target>
        </trans-unit>
        <trans-unit id="557d86b90451662a5be206878fb6037c4adc186c" translate="yes" xml:space="preserve">
          <source>Trait std::iter::DoubleEndedIterator</source>
          <target state="translated">Трейт std::iter::DoubleEndedIterator</target>
        </trans-unit>
        <trans-unit id="f1b39cf8be9a057d9577992deaebe45e596b1a85" translate="yes" xml:space="preserve">
          <source>Trait std::iter::ExactSizeIterator</source>
          <target state="translated">Трейт std::iter::ExactSizeIterator</target>
        </trans-unit>
        <trans-unit id="993ad040e2e34adc2956488f0eb4db104a067cbf" translate="yes" xml:space="preserve">
          <source>Trait std::iter::Extend</source>
          <target state="translated">Стд черта::итер::продлить</target>
        </trans-unit>
        <trans-unit id="5d994406c4beb394a68ed1206fddfd385bea8323" translate="yes" xml:space="preserve">
          <source>Trait std::iter::FromIterator</source>
          <target state="translated">Трейт std::iter::FromIterator</target>
        </trans-unit>
        <trans-unit id="2fce9eb181dd3ce47112a06174082d5e79cf74c2" translate="yes" xml:space="preserve">
          <source>Trait std::iter::FusedIterator</source>
          <target state="translated">Трейт std::iter::FusedIterator</target>
        </trans-unit>
        <trans-unit id="e86b71b89c47a871b78ca20df617b375a62e7185" translate="yes" xml:space="preserve">
          <source>Trait std::iter::IntoIterator</source>
          <target state="translated">Трейт std::iter::IntoIterator</target>
        </trans-unit>
        <trans-unit id="2da3e674c34b9eab7bfc5aeebb0e4f54178e88c3" translate="yes" xml:space="preserve">
          <source>Trait std::iter::Iterator</source>
          <target state="translated">Trait std::iter::Iterator</target>
        </trans-unit>
        <trans-unit id="28c48f7585e0c72c08462070ebcfc21850b855dd" translate="yes" xml:space="preserve">
          <source>Trait std::iter::Product</source>
          <target state="translated">Трейт std:::итер:::продукт</target>
        </trans-unit>
        <trans-unit id="4cd139b55d183603c0136ea95dadb637efaf38a2" translate="yes" xml:space="preserve">
          <source>Trait std::iter::Step</source>
          <target state="translated">Стд черта::итер::шаг</target>
        </trans-unit>
        <trans-unit id="5db41fec6d94d07ed5a8c95c380992ba4e70704b" translate="yes" xml:space="preserve">
          <source>Trait std::iter::Sum</source>
          <target state="translated">Стд черта::iter::Sum</target>
        </trans-unit>
        <trans-unit id="d2c14fdb677cf9e40834e0c15272aef7a318414f" translate="yes" xml:space="preserve">
          <source>Trait std::iter::TrustedLen</source>
          <target state="translated">Trait std::iter::TrustedLen</target>
        </trans-unit>
        <trans-unit id="97864c14469b7b4a0942294bc953528cb554eb45" translate="yes" xml:space="preserve">
          <source>Trait std::marker::Copy</source>
          <target state="translated">Трейт std::marker::Copy</target>
        </trans-unit>
        <trans-unit id="d7b568be22b28c92ca0e71ed060c7b03cf03fb4f" translate="yes" xml:space="preserve">
          <source>Trait std::marker::Send</source>
          <target state="translated">Трейт std::marker::Send</target>
        </trans-unit>
        <trans-unit id="00852f537576ef249f511a14cf0e0d88604a985c" translate="yes" xml:space="preserve">
          <source>Trait std::marker::Sized</source>
          <target state="translated">Трейт std::маркер::размер</target>
        </trans-unit>
        <trans-unit id="259bdec063434c0a27f0691a2488a4567088a5e0" translate="yes" xml:space="preserve">
          <source>Trait std::marker::Sync</source>
          <target state="translated">Trait std::marker::Sync</target>
        </trans-unit>
        <trans-unit id="3f94365e96f98d2913bb838b56a6cb437e2a3543" translate="yes" xml:space="preserve">
          <source>Trait std::marker::Unpin</source>
          <target state="translated">Трейт std::маркер::Unpin</target>
        </trans-unit>
        <trans-unit id="311396699adc0c66b758dcec6485921335dcacf8" translate="yes" xml:space="preserve">
          <source>Trait std::marker::Unsize</source>
          <target state="translated">Трейт std::marker::Unsize</target>
        </trans-unit>
        <trans-unit id="56b1f3f0f786678bf876540fb69232e234007e31" translate="yes" xml:space="preserve">
          <source>Trait std::net::ToSocketAddrs</source>
          <target state="translated">Трейт std::net::ToSocketAddrs</target>
        </trans-unit>
        <trans-unit id="37966fc5ec2acafba273f997b504b3bf34ed922b" translate="yes" xml:space="preserve">
          <source>Trait std::ops::Add</source>
          <target state="translated">Std line::ops::Add</target>
        </trans-unit>
        <trans-unit id="eb2302d36fa57d1adc4a45dc1d240d27866b69da" translate="yes" xml:space="preserve">
          <source>Trait std::ops::AddAssign</source>
          <target state="translated">Трейт std::ops::AddAssign</target>
        </trans-unit>
        <trans-unit id="b5f5f47beac59c26ee424be54e3b7e3d95164b94" translate="yes" xml:space="preserve">
          <source>Trait std::ops::BitAnd</source>
          <target state="translated">СТД линия::ОП::БитАнд</target>
        </trans-unit>
        <trans-unit id="fb181e8cea7de0ad56c4c91c6a0777e1d53fd765" translate="yes" xml:space="preserve">
          <source>Trait std::ops::BitAndAssign</source>
          <target state="translated">Трейт std::ops::BitAndAssign</target>
        </trans-unit>
        <trans-unit id="b888f514c1fa78a8e8fe84b58a6fbc1d25aaf2c1" translate="yes" xml:space="preserve">
          <source>Trait std::ops::BitOr</source>
          <target state="translated">СТД линия::ОП::БитОр</target>
        </trans-unit>
        <trans-unit id="ca3ae8400b524007a326d21b18e44fb657bdb697" translate="yes" xml:space="preserve">
          <source>Trait std::ops::BitOrAssign</source>
          <target state="translated">Трейт std::ops::BitOrAssign</target>
        </trans-unit>
        <trans-unit id="8d18eaa27370f1eb1f6ce036dc60c1aa5493c417" translate="yes" xml:space="preserve">
          <source>Trait std::ops::BitXor</source>
          <target state="translated">Std line::ops::BitXor</target>
        </trans-unit>
        <trans-unit id="5961f53888aa07cd5cd15ed30fa1971a719c8b25" translate="yes" xml:space="preserve">
          <source>Trait std::ops::BitXorAssign</source>
          <target state="translated">Трейт std::ops::BitXorAssign</target>
        </trans-unit>
        <trans-unit id="5e9158651355d13bfdd0cc23ab8ae22e93570742" translate="yes" xml:space="preserve">
          <source>Trait std::ops::CoerceUnsized</source>
          <target state="translated">Трейт std::ops::CoerceUnsized</target>
        </trans-unit>
        <trans-unit id="e2225eef9926066643795abab6cb04cea79ce68b" translate="yes" xml:space="preserve">
          <source>Trait std::ops::Deref</source>
          <target state="translated">Сверхъестественная черта::оп::Дереф</target>
        </trans-unit>
        <trans-unit id="8071035f23a5d586519a8248517d2e29e7adcb51" translate="yes" xml:space="preserve">
          <source>Trait std::ops::DerefMut</source>
          <target state="translated">Trait std::ops::DerefMut</target>
        </trans-unit>
        <trans-unit id="1bdb82d5309eaed70f5481f05b19a4d41b5808d7" translate="yes" xml:space="preserve">
          <source>Trait std::ops::DispatchFromDyn</source>
          <target state="translated">Стандартная черта::ОП::ДиспетчерФроммДина</target>
        </trans-unit>
        <trans-unit id="9119f5359ef3817ec9f0b7e45b3f1ecbc08a66ae" translate="yes" xml:space="preserve">
          <source>Trait std::ops::Div</source>
          <target state="translated">Стд черта::ОП::Див</target>
        </trans-unit>
        <trans-unit id="f65e4311dbd340efad891a4945558b2592826b48" translate="yes" xml:space="preserve">
          <source>Trait std::ops::DivAssign</source>
          <target state="translated">Трейт std::ops::DivAssign</target>
        </trans-unit>
        <trans-unit id="ead9d9ba97193a4d1ac24f05c905c8b13350ed9c" translate="yes" xml:space="preserve">
          <source>Trait std::ops::Drop</source>
          <target state="translated">СТД-линия::ОП::Бросьте</target>
        </trans-unit>
        <trans-unit id="516e4c37897e1d20a60743aea36782c56e8156a9" translate="yes" xml:space="preserve">
          <source>Trait std::ops::Fn</source>
          <target state="translated">Std line::ops::Fn</target>
        </trans-unit>
        <trans-unit id="77005c859f62996c3f249d5673d1b2c4d6da6a8e" translate="yes" xml:space="preserve">
          <source>Trait std::ops::FnMut</source>
          <target state="translated">Std line::ops::FnMut</target>
        </trans-unit>
        <trans-unit id="b435f6c3c75102c4c8177872a25a996a1ff95c72" translate="yes" xml:space="preserve">
          <source>Trait std::ops::FnOnce</source>
          <target state="translated">Характеристика Стд::ОП::СнГ</target>
        </trans-unit>
        <trans-unit id="9aa827be880a5bea9bb3024a041653fb3a60ff06" translate="yes" xml:space="preserve">
          <source>Trait std::ops::Generator</source>
          <target state="translated">Trait std::ops::Generator</target>
        </trans-unit>
        <trans-unit id="59811c59bb31cbb96886cf966994463b72ad700c" translate="yes" xml:space="preserve">
          <source>Trait std::ops::Index</source>
          <target state="translated">Std линия::ops::Index</target>
        </trans-unit>
        <trans-unit id="1b08e9090daf7ede77089f8107e6507872bde2ab" translate="yes" xml:space="preserve">
          <source>Trait std::ops::IndexMut</source>
          <target state="translated">Std line::ops::IndexMut</target>
        </trans-unit>
        <trans-unit id="10babff383e103d1471a771d922a28289586b73a" translate="yes" xml:space="preserve">
          <source>Trait std::ops::Mul</source>
          <target state="translated">Сверхъестественная черта::Ops::Mul</target>
        </trans-unit>
        <trans-unit id="b32e6664a7b4d68e303b33188cda08fc977bd7b7" translate="yes" xml:space="preserve">
          <source>Trait std::ops::MulAssign</source>
          <target state="translated">Трейт std::ops::MulAssign</target>
        </trans-unit>
        <trans-unit id="7244a7be2c4624654c9b462b1947447297e505fd" translate="yes" xml:space="preserve">
          <source>Trait std::ops::Neg</source>
          <target state="translated">Std line::ops::Neg</target>
        </trans-unit>
        <trans-unit id="598dee8649518d42201f87386801464e34102c60" translate="yes" xml:space="preserve">
          <source>Trait std::ops::Not</source>
          <target state="translated">СТД линия::ОП:Нет</target>
        </trans-unit>
        <trans-unit id="bc51ccaddf33118323d7fc1d905d959ce650d2fc" translate="yes" xml:space="preserve">
          <source>Trait std::ops::RangeBounds</source>
          <target state="translated">Трейт std::ops::RangeBounds</target>
        </trans-unit>
        <trans-unit id="4ee55841b26a89cf9d805e3a28fb34dc38ab767a" translate="yes" xml:space="preserve">
          <source>Trait std::ops::Rem</source>
          <target state="translated">Std line::ops::Rem</target>
        </trans-unit>
        <trans-unit id="a0e35ffe757b24704f0ad197b4f1a2195f4a4f69" translate="yes" xml:space="preserve">
          <source>Trait std::ops::RemAssign</source>
          <target state="translated">Трейт std::ops::RemAssign</target>
        </trans-unit>
        <trans-unit id="5922247946e4630b62a74e89d87c15ed9dbf8321" translate="yes" xml:space="preserve">
          <source>Trait std::ops::Shl</source>
          <target state="translated">Std line::ops::Shl</target>
        </trans-unit>
        <trans-unit id="f84eeb046dfef53ab5217181c0fe9161eb7133b2" translate="yes" xml:space="preserve">
          <source>Trait std::ops::ShlAssign</source>
          <target state="translated">Трейт std::ops::ShlAssign</target>
        </trans-unit>
        <trans-unit id="55d865e44b6599da1d5b41d269ec7455a02e4d75" translate="yes" xml:space="preserve">
          <source>Trait std::ops::Shr</source>
          <target state="translated">Std line::ops::Shr</target>
        </trans-unit>
        <trans-unit id="e7c92d6f8a50e1ae3b29a226a8335aff1fecf601" translate="yes" xml:space="preserve">
          <source>Trait std::ops::ShrAssign</source>
          <target state="translated">Трейт std::ops::ShrAssign</target>
        </trans-unit>
        <trans-unit id="cbaeb43954d65c4471777365a4ccdaf3b98314da" translate="yes" xml:space="preserve">
          <source>Trait std::ops::Sub</source>
          <target state="translated">Std line::ops::Sub</target>
        </trans-unit>
        <trans-unit id="60e6a61f8c88f9e6239b7053de7f86d23a70926d" translate="yes" xml:space="preserve">
          <source>Trait std::ops::SubAssign</source>
          <target state="translated">Трейт std::ops::SubAssign</target>
        </trans-unit>
        <trans-unit id="1e84214c3e8570e12d3f9ef3b558be6c152516f7" translate="yes" xml:space="preserve">
          <source>Trait std::ops::Try</source>
          <target state="translated">Стд черта::оп::Попробуйте.</target>
        </trans-unit>
        <trans-unit id="aee85e47c1ef28a026ccdb2b42dd67004cf6d92b" translate="yes" xml:space="preserve">
          <source>Trait std::os::linux::fs::MetadataExt</source>
          <target state="translated">Трейт std::os::linux::fs::MetadataExt</target>
        </trans-unit>
        <trans-unit id="ce6f693798415e4676d8d1ff10beb4360e2b88ea" translate="yes" xml:space="preserve">
          <source>Trait std::os::unix::ffi::OsStrExt</source>
          <target state="translated">Std признак::os::unix::ffi::OsStrExt</target>
        </trans-unit>
        <trans-unit id="ccee631397fcdd7aa7a9f0bce0da5d850063085b" translate="yes" xml:space="preserve">
          <source>Trait std::os::unix::ffi::OsStringExt</source>
          <target state="translated">Трейт std::os::unix::ffi::OsStringExt</target>
        </trans-unit>
        <trans-unit id="e621c9f13dd9d62e26bc7432de51e95d4d92457d" translate="yes" xml:space="preserve">
          <source>Trait std::os::unix::fs::DirBuilderExt</source>
          <target state="translated">Трейт std::os::unix::fs::DirBuilderExt</target>
        </trans-unit>
        <trans-unit id="0709fdc0b13d2f0cb5f5c17d0f41b133a5719e30" translate="yes" xml:space="preserve">
          <source>Trait std::os::unix::fs::DirEntryExt</source>
          <target state="translated">Std черта::os::unix::fs::DirEntryExt</target>
        </trans-unit>
        <trans-unit id="030f7ec1f295cca2c02129cf381f726caf5a30ca" translate="yes" xml:space="preserve">
          <source>Trait std::os::unix::fs::FileExt</source>
          <target state="translated">Std строка::os::unix::fs::FileExt</target>
        </trans-unit>
        <trans-unit id="f955ea7fe9356c94c24f7600e345d8c1f23ecc81" translate="yes" xml:space="preserve">
          <source>Trait std::os::unix::fs::FileTypeExt</source>
          <target state="translated">Std trait::os::unix::fs::FileTypeExt</target>
        </trans-unit>
        <trans-unit id="062f7bd7816b0a1187ddcd41fdc03811ea335026" translate="yes" xml:space="preserve">
          <source>Trait std::os::unix::fs::MetadataExt</source>
          <target state="translated">Std признак::os::unix::fs::MetadataExt</target>
        </trans-unit>
        <trans-unit id="5cc7126ad859e04f63e6bf507db0f3f32c1e3609" translate="yes" xml:space="preserve">
          <source>Trait std::os::unix::fs::OpenOptionsExt</source>
          <target state="translated">Особенность Std::os::unix::fs::OpenOptionsExt</target>
        </trans-unit>
        <trans-unit id="7b61dfb2986a0864a907b937d464ff43d30cc28a" translate="yes" xml:space="preserve">
          <source>Trait std::os::unix::fs::PermissionsExt</source>
          <target state="translated">Std черта::os::unix::fs::PermissionsExt</target>
        </trans-unit>
        <trans-unit id="029585bd86a69a9cb4ab7c864e7dc9b2373a14b3" translate="yes" xml:space="preserve">
          <source>Trait std::os::unix::io::AsRawFd</source>
          <target state="translated">Std trait::os::unix::io::AsRawFd</target>
        </trans-unit>
        <trans-unit id="e4e4a27468811544480dddf3c4047ee3d4694a0c" translate="yes" xml:space="preserve">
          <source>Trait std::os::unix::io::FromRawFd</source>
          <target state="translated">Std трейт::os::unix::io::FromRawFd</target>
        </trans-unit>
        <trans-unit id="ad731bff461d938e10c799939e10ae14e837a1d4" translate="yes" xml:space="preserve">
          <source>Trait std::os::unix::io::IntoRawFd</source>
          <target state="translated">Std.stroke::os::unix::io::IntoRawFd</target>
        </trans-unit>
        <trans-unit id="e0e834bab744daaedf71c0c8937cc0857c11c815" translate="yes" xml:space="preserve">
          <source>Trait std::os::unix::process::CommandExt</source>
          <target state="translated">Std trait::os::unix::процесс::CommandExt</target>
        </trans-unit>
        <trans-unit id="3fdb072f5381c741536b73b80e58115bb5f3dc4d" translate="yes" xml:space="preserve">
          <source>Trait std::os::unix::process::ExitStatusExt</source>
          <target state="translated">Трейт std::os::unix::процесс::ExitStatusExt</target>
        </trans-unit>
        <trans-unit id="398944c7337c4aa8b95b799fcb3bb79124d70d16" translate="yes" xml:space="preserve">
          <source>Trait std::os::unix::thread::JoinHandleExt</source>
          <target state="translated">Трейт std::os::unix::thread::JoinHandleExt</target>
        </trans-unit>
        <trans-unit id="775a7a0c3bd36d7ff6360e6cd0ef765ee978cd67" translate="yes" xml:space="preserve">
          <source>Trait std::os::windows::ffi::OsStrExt</source>
          <target state="translated">Трейт std::os::windows::ffi::OsStrExt</target>
        </trans-unit>
        <trans-unit id="fef545ee7fe66334043f38cfbfbf352be492c487" translate="yes" xml:space="preserve">
          <source>Trait std::os::windows::ffi::OsStringExt</source>
          <target state="translated">Трейт std::os::windows::ffi::OsStringExt</target>
        </trans-unit>
        <trans-unit id="ecb052e97ecce0a67db913c47f009bfcbacc3af0" translate="yes" xml:space="preserve">
          <source>Trait std::os::windows::fs::FileExt</source>
          <target state="translated">Трейт std::os::windows::fs::FileExt</target>
        </trans-unit>
        <trans-unit id="91c8fb448f57a608a43c2c6a50e10bec34d5ab25" translate="yes" xml:space="preserve">
          <source>Trait std::os::windows::fs::FileTypeExt</source>
          <target state="translated">Трейт std::os::windows::fs::FileTypeExt</target>
        </trans-unit>
        <trans-unit id="48eaa197d2777c5eb543ac927807cb3bcfa429bf" translate="yes" xml:space="preserve">
          <source>Trait std::os::windows::fs::MetadataExt</source>
          <target state="translated">Трейт std::os::windows::fs::MetadataExt</target>
        </trans-unit>
        <trans-unit id="adfee6aa3be6cbe6237011186a8914e73584ae0c" translate="yes" xml:space="preserve">
          <source>Trait std::os::windows::fs::OpenOptionsExt</source>
          <target state="translated">Функция Std::os::windows::fs::OpenOptionsExt</target>
        </trans-unit>
        <trans-unit id="2cdd2fa8158633908c8d054d4d1297a0e8730a45" translate="yes" xml:space="preserve">
          <source>Trait std::os::windows::io::AsRawHandle</source>
          <target state="translated">Трейт std::os::windows::io::AsRawHandle</target>
        </trans-unit>
        <trans-unit id="0d00fd25b06cb924c3fdd7f42d54ec1498a98e1b" translate="yes" xml:space="preserve">
          <source>Trait std::os::windows::io::AsRawSocket</source>
          <target state="translated">Std черта::os::windows::io::AsRawSocket</target>
        </trans-unit>
        <trans-unit id="61063f360cb8b5295929ae6072d8fe4c6d6e69db" translate="yes" xml:space="preserve">
          <source>Trait std::os::windows::io::FromRawHandle</source>
          <target state="translated">Трейт std::os::windows::io::FromRawHandle</target>
        </trans-unit>
        <trans-unit id="7942dc2954f8548cc31aadda78e4bf28314f92d8" translate="yes" xml:space="preserve">
          <source>Trait std::os::windows::io::FromRawSocket</source>
          <target state="translated">Трейт std::os::windows::io::FromRawSocket</target>
        </trans-unit>
        <trans-unit id="bb1fb08e33748cf05582377cef8603a0b7d61ea6" translate="yes" xml:space="preserve">
          <source>Trait std::os::windows::io::IntoRawHandle</source>
          <target state="translated">Трейт std::os::windows::io::IntoRawHandle</target>
        </trans-unit>
        <trans-unit id="1fe8126ee24f29a74bcdb4233344f05c1aaeb804" translate="yes" xml:space="preserve">
          <source>Trait std::os::windows::io::IntoRawSocket</source>
          <target state="translated">Трейт std::os::windows::io::IntoRawSocket</target>
        </trans-unit>
        <trans-unit id="03f13d9ed2758f8306f48846a3b40b6e4ee6fb67" translate="yes" xml:space="preserve">
          <source>Trait std::os::windows::process::CommandExt</source>
          <target state="translated">Трейт std::os::windows::process::CommandExt</target>
        </trans-unit>
        <trans-unit id="5474211db770299d01cd13e53280d9a32e0a6eb8" translate="yes" xml:space="preserve">
          <source>Trait std::os::windows::process::ExitStatusExt</source>
          <target state="translated">Трейт std::os::windows::process::ExitStatusExt</target>
        </trans-unit>
        <trans-unit id="f12279b49645006e0e35a65e657e45472c813936" translate="yes" xml:space="preserve">
          <source>Trait std::panic::RefUnwindSafe</source>
          <target state="translated">Трейт std::panic::RefUnwindSafe</target>
        </trans-unit>
        <trans-unit id="94584086fc586a7b81f5ac90f21ac1115c03a3ce" translate="yes" xml:space="preserve">
          <source>Trait std::panic::UnwindSafe</source>
          <target state="translated">Trait std::panic::UnwindSafe</target>
        </trans-unit>
        <trans-unit id="adb81f6851cec81b5352770932f85397129ab8a4" translate="yes" xml:space="preserve">
          <source>Trait std::process::Termination</source>
          <target state="translated">Трейт std::процесс::Завершение</target>
        </trans-unit>
        <trans-unit id="7640946c865124bdea836774595f3568b91b7998" translate="yes" xml:space="preserve">
          <source>Trait std::slice::SliceConcatExt</source>
          <target state="translated">Трейт std::ломтик::SliceConcatExt</target>
        </trans-unit>
        <trans-unit id="f46e5f5628a346f08367c4e254d503cf40a8e630" translate="yes" xml:space="preserve">
          <source>Trait std::slice::SliceIndex</source>
          <target state="translated">Трэйт Стэд::ломтик::ломтик::ломтик:SliceIndex</target>
        </trans-unit>
        <trans-unit id="376de5fab14024883dddc8825294275d1ab087fe" translate="yes" xml:space="preserve">
          <source>Trait std::str::FromStr</source>
          <target state="translated">Трейт std::str::FromStr</target>
        </trans-unit>
        <trans-unit id="44dfa41c6566ca84e623c4ad35fe85e2a3871106" translate="yes" xml:space="preserve">
          <source>Trait std::str::pattern::DoubleEndedSearcher</source>
          <target state="translated">Трейт std::str::pattern::DoubleEndedSearcher</target>
        </trans-unit>
        <trans-unit id="60d7ae5ae877268eee71ef1b870695c55f5799dd" translate="yes" xml:space="preserve">
          <source>Trait std::str::pattern::Pattern</source>
          <target state="translated">Трейт std::str::pattern::Pattern</target>
        </trans-unit>
        <trans-unit id="57c9157b22b76a9e5814b9b5b2e9d0438b5d56c6" translate="yes" xml:space="preserve">
          <source>Trait std::str::pattern::ReverseSearcher</source>
          <target state="translated">Трейт std::str::pattern::ReverseSearcher</target>
        </trans-unit>
        <trans-unit id="c47b1d5d24f300a29158b5903ba66de94f2261c7" translate="yes" xml:space="preserve">
          <source>Trait std::str::pattern::Searcher</source>
          <target state="translated">Трейт std::str::pattern::Searcher</target>
        </trans-unit>
        <trans-unit id="44bc0cc22a45fc90a102d47cbd5cd3c88d279925" translate="yes" xml:space="preserve">
          <source>Trait std::string::ToString</source>
          <target state="translated">Трейт std::string::ToString</target>
        </trans-unit>
        <trans-unit id="902e019f3fc71a92236203a22158a6e688676cd4" translate="yes" xml:space="preserve">
          <source>Trait that indicates that this is a pointer or a wrapper for one, where unsizing can be performed on the pointee.</source>
          <target state="translated">Признак,указывающий на то,что это указатель или обертка для одного из них,где на указателе может быть выполнено распаковка.</target>
        </trans-unit>
        <trans-unit id="914213ad374b434003e30cd9d7bcaca26d295c77" translate="yes" xml:space="preserve">
          <source>Trait to represent types that can be created by multiplying elements of an iterator.</source>
          <target state="translated">Трейт для представления типов,которые могут быть созданы путем умножения элементов итератора.</target>
        </trans-unit>
        <trans-unit id="badf961de53295edcdb207c7619b3c8c3ea8ab3f" translate="yes" xml:space="preserve">
          <source>Trait to represent types that can be created by summing up an iterator.</source>
          <target state="translated">Трейт для представления типов,которые могут быть созданы путем суммирования итератора.</target>
        </trans-unit>
        <trans-unit id="d881d840fb21638a45b7fe784d4a5eb2d495d58e" translate="yes" xml:space="preserve">
          <source>Trait types:</source>
          <target state="translated">Типы признаков:</target>
        </trans-unit>
        <trans-unit id="602d794344a5274058fe843b2cdf8ec0429dd8a0" translate="yes" xml:space="preserve">
          <source>Trait types: &lt;a href=&quot;types/trait-object&quot;&gt;Trait objects&lt;/a&gt; and &lt;a href=&quot;types/impl-trait&quot;&gt;impl trait&lt;/a&gt;.</source>
          <target state="translated">Типы &lt;a href=&quot;types/impl-trait&quot;&gt;черт&lt;/a&gt; : &lt;a href=&quot;types/trait-object&quot;&gt;Объекты &lt;/a&gt;черт и имплицитная черта .</target>
        </trans-unit>
        <trans-unit id="9bb3c78c542b9f8ec90ade6e9ec8d9a3209bf67e" translate="yes" xml:space="preserve">
          <source>TraitObject</source>
          <target state="translated">TraitObject</target>
        </trans-unit>
        <trans-unit id="6dafbe61d09e60652f6bbad6957562daf88836c1" translate="yes" xml:space="preserve">
          <source>TraitObject::borrow</source>
          <target state="translated">TraitObject::borrow</target>
        </trans-unit>
        <trans-unit id="d4a155778d83f0c6e0941f69c58ed350bc406da6" translate="yes" xml:space="preserve">
          <source>TraitObject::borrow_mut</source>
          <target state="translated">TraitObject::borrow_mut</target>
        </trans-unit>
        <trans-unit id="1ad27b39ed4c34288ce66526e3c4d0c6cfa27a49" translate="yes" xml:space="preserve">
          <source>TraitObject::clone</source>
          <target state="translated">TraitObject::clone</target>
        </trans-unit>
        <trans-unit id="f7e5bbc88cb023be138b61515a8a95359d090a5c" translate="yes" xml:space="preserve">
          <source>TraitObject::clone_from</source>
          <target state="translated">TraitObject::clone_from</target>
        </trans-unit>
        <trans-unit id="fdf0c70ef2387158d4df2cba6555b292ed39d46d" translate="yes" xml:space="preserve">
          <source>TraitObject::clone_into</source>
          <target state="translated">TraitObject::clone_into</target>
        </trans-unit>
        <trans-unit id="743885aa5243b74deebe5c3d51ac4806100e3c4f" translate="yes" xml:space="preserve">
          <source>TraitObject::from</source>
          <target state="translated">TraitObject::from</target>
        </trans-unit>
        <trans-unit id="83e65850a79cb15fc900dff422e0637ecd287f18" translate="yes" xml:space="preserve">
          <source>TraitObject::into</source>
          <target state="translated">TraitObject::into</target>
        </trans-unit>
        <trans-unit id="4d10ca4ab3471cdb18500652e2706f1af91011a7" translate="yes" xml:space="preserve">
          <source>TraitObject::to_owned</source>
          <target state="translated">TraitObject::to_owned</target>
        </trans-unit>
        <trans-unit id="cb08794c131e1ac1a49313ec36f386568341f2c9" translate="yes" xml:space="preserve">
          <source>TraitObject::try_from</source>
          <target state="translated">TraitObject::try_from</target>
        </trans-unit>
        <trans-unit id="368b837c4e44612f1f89ff1a01dc94c771822d93" translate="yes" xml:space="preserve">
          <source>TraitObject::try_into</source>
          <target state="translated">TraitObject::try_into</target>
        </trans-unit>
        <trans-unit id="74e84d6c289e114766c37bd05fe2729da4981e80" translate="yes" xml:space="preserve">
          <source>TraitObject::type_id</source>
          <target state="translated">TraitObject::type_id</target>
        </trans-unit>
        <trans-unit id="d1a616085a1a99a58e14bafaa350abc6783a3160" translate="yes" xml:space="preserve">
          <source>Traits</source>
          <target state="translated">Traits</target>
        </trans-unit>
        <trans-unit id="9c97df5331a0dd1cf9d7e4754c7f28e534496f46" translate="yes" xml:space="preserve">
          <source>Traits and trait bounds let us write code that uses generic type parameters to reduce duplication but also specify to the compiler that we want the generic type to have particular behavior. The compiler can then use the trait bound information to check that all the concrete types used with our code provide the correct behavior. In dynamically typed languages, we would get an error at runtime if we called a method on a type that the type didn&amp;rsquo;t implement. But Rust moves these errors to compile time so we&amp;rsquo;re forced to fix the problems before our code is even able to run. Additionally, we don&amp;rsquo;t have to write code that checks for behavior at runtime because we&amp;rsquo;ve already checked at compile time. Doing so improves performance without having to give up the flexibility of generics.</source>
          <target state="translated">Признаки и их границы позволяют нам писать код, который использует параметры универсального типа для уменьшения дублирования, но также указывает компилятору, что мы хотим, чтобы универсальный тип имел определенное поведение. Затем компилятор может использовать информацию, связанную с признаками, чтобы проверить, что все конкретные типы, используемые с нашим кодом, обеспечивают правильное поведение. В языках с динамической типизацией мы получили бы ошибку во время выполнения, если бы вызывали метод для типа, который этот тип не реализовал. Но Rust перемещает эти ошибки во время компиляции, поэтому мы вынуждены исправлять проблемы еще до того, как наш код будет запущен. Кроме того, нам не нужно писать код, который проверяет поведение во время выполнения, потому что мы уже проверяли во время компиляции. Это повышает производительность, не отказываясь от гибкости универсальных шаблонов.</target>
        </trans-unit>
        <trans-unit id="3fc76183719059f2c0c8080816f40e16e5dee060" translate="yes" xml:space="preserve">
          <source>Traits and trait bounds let us write code that uses generic type parameters to reduce duplication but also specify to the compiler that we want the generic type to have particular behavior. The compiler can then use the trait bound information to check that all the concrete types used with our code provide the correct behavior. In dynamically typed languages, we would get an error at runtime if we called a method on a type which didn&amp;rsquo;t define the method. But Rust moves these errors to compile time so we&amp;rsquo;re forced to fix the problems before our code is even able to run. Additionally, we don&amp;rsquo;t have to write code that checks for behavior at runtime because we&amp;rsquo;ve already checked at compile time. Doing so improves performance without having to give up the flexibility of generics.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="30d92be1538d577b3a476ce5c89b01f7242bf547" translate="yes" xml:space="preserve">
          <source>Traits are also compared by their implementation:</source>
          <target state="translated">Черты также сравниваются по их реализации:</target>
        </trans-unit>
        <trans-unit id="e9a67b2444510e46e8948ad83a34775ca31fa40c" translate="yes" xml:space="preserve">
          <source>Traits are declared using the &lt;code&gt;trait&lt;/code&gt; keyword. Types can implement them using &lt;a href=&quot;keyword.impl&quot;&gt;&lt;code&gt;impl&lt;/code&gt;&lt;/a&gt;&lt;code&gt;Trait&lt;/code&gt;&lt;a href=&quot;keyword.for&quot;&gt;&lt;code&gt;for&lt;/code&gt;&lt;/a&gt;&lt;code&gt;Type&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="66685be42641df1c5c014df0db7fb2681f6517c0" translate="yes" xml:space="preserve">
          <source>Traits are implemented for specific types through separate &lt;a href=&quot;implementations&quot;&gt;implementations&lt;/a&gt;.</source>
          <target state="translated">Черты реализуются для определенных типов через отдельные &lt;a href=&quot;implementations&quot;&gt;реализации&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="68c3dbb43f5798e7691ebd93a6d889062ce5c80e" translate="yes" xml:space="preserve">
          <source>Traits as Parameters</source>
          <target state="translated">Параметры как параметры</target>
        </trans-unit>
        <trans-unit id="4bf9fb060bd902afb2cded8739189581c26cdf0d" translate="yes" xml:space="preserve">
          <source>Traits can also be declared as &lt;code&gt;unsafe&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="661e39b3878b924290822d7b53ab6af8bbecce44" translate="yes" xml:space="preserve">
          <source>Traits can be generic, with constraints or without:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b9d13ed5586289e0d3d40796b5bf51fc03fcc1f1" translate="yes" xml:space="preserve">
          <source>Traits can be made up of three varieties of associated items:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2f25be72831238ea3a0070cedc0b27becde04cb1" translate="yes" xml:space="preserve">
          <source>Traits can be used in functions, as parameters:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d1a444e95cf19cfd56b5bd44d15b0d8f1bb04bba" translate="yes" xml:space="preserve">
          <source>Traits can build upon the requirements of other traits. In the example below &lt;code&gt;Iterator&lt;/code&gt; is a &lt;strong&gt;supertrait&lt;/strong&gt; and &lt;code&gt;ThreeIterator&lt;/code&gt; is a &lt;strong&gt;subtrait&lt;/strong&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a5bf3800cd574708d91373db1be628b4ff994b51" translate="yes" xml:space="preserve">
          <source>Traits can serve as markers or carry other logical semantics that aren't expressed through their items. When a type implements that trait it is promising to uphold its contract. &lt;a href=&quot;marker/trait.send&quot;&gt;&lt;code&gt;Send&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;marker/trait.sync&quot;&gt;&lt;code&gt;Sync&lt;/code&gt;&lt;/a&gt; are two such marker traits present in the standard library.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f1779dfd4e53a302206ca9f432ac589991148919" translate="yes" xml:space="preserve">
          <source>Traits for conversions between types.</source>
          <target state="translated">Признаки для преобразования между типами.</target>
        </trans-unit>
        <trans-unit id="5129fe11a670c9d54f51f82654cb88d2c5359dd3" translate="yes" xml:space="preserve">
          <source>Traits for working with Errors.</source>
          <target state="translated">Признаки для работы с ошибками.</target>
        </trans-unit>
        <trans-unit id="e714d1e850bbb5cbfe4cbf81d9f96ff676eaae8d" translate="yes" xml:space="preserve">
          <source>Traits items that begin with the &lt;code&gt;unsafe&lt;/code&gt; keyword indicate that &lt;em&gt;implementing&lt;/em&gt; the trait may be &lt;a href=&quot;../unsafety&quot;&gt;unsafe&lt;/a&gt;. It is safe to use a correctly implemented unsafe trait. The &lt;a href=&quot;implementations#trait-implementations&quot;&gt;trait implementation&lt;/a&gt; must also begin with the &lt;code&gt;unsafe&lt;/code&gt; keyword.</source>
          <target state="translated">Элементы свойств, начинающиеся с ключевого слова &lt;code&gt;unsafe&lt;/code&gt; , указывают на то, что &lt;em&gt;реализация&lt;/em&gt; свойства может быть &lt;a href=&quot;../unsafety&quot;&gt;небезопасной&lt;/a&gt; . Можно безопасно использовать правильно реализованную черту unsafe. Реализация &lt;a href=&quot;implementations#trait-implementations&quot;&gt;признака&lt;/a&gt; также должна начинаться с ключевого слова &lt;code&gt;unsafe&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c4f3eba08a0ef9ddc5179fc934760dae14913d40" translate="yes" xml:space="preserve">
          <source>Traits marked as &lt;code&gt;unsafe&lt;/code&gt; must be &lt;a href=&quot;keyword.impl&quot;&gt;&lt;code&gt;impl&lt;/code&gt;&lt;/a&gt;emented using &lt;code&gt;unsafe impl&lt;/code&gt;. This makes a guarantee to other &lt;code&gt;unsafe&lt;/code&gt; code that the implementation satisfies the trait's safety contract. The &lt;a href=&quot;marker/trait.send&quot;&gt;Send&lt;/a&gt; and &lt;a href=&quot;marker/trait.sync&quot;&gt;Sync&lt;/a&gt; traits are examples of this behaviour in the standard library.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a0bb75d5aa409703504921566195fb3122da2052" translate="yes" xml:space="preserve">
          <source>Traits may also contain additional type parameters. Those type parameters or the trait itself can be constrained by other traits.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7b45c49a33c4022855bfa5d2a686751214a7126a" translate="yes" xml:space="preserve">
          <source>Traits may be implemented for</source>
          <target state="translated">Признаки могут быть реализованы для</target>
        </trans-unit>
        <trans-unit id="986fcbb6a73e7cc26d2d8b2b6164011d8bab7460" translate="yes" xml:space="preserve">
          <source>Traits, helpers, and type definitions for core I/O functionality.</source>
          <target state="translated">Черты,помощники и определения типов для функциональности ядра ввода/вывода.</target>
        </trans-unit>
        <trans-unit id="9aa77953b92e4e6c565758326d541910014cfd21" translate="yes" xml:space="preserve">
          <source>Traits: Defining Shared Behavior</source>
          <target state="translated">Черты:Определение общего поведения</target>
        </trans-unit>
        <trans-unit id="d8a8f61d9f0fd714531d17d414abcb212572f131" translate="yes" xml:space="preserve">
          <source>Transcribing</source>
          <target state="translated">Transcribing</target>
        </trans-unit>
        <trans-unit id="2df1d93dea4e259eb26edde2c26eb9c20992b104" translate="yes" xml:space="preserve">
          <source>Transforms an iterator into a collection.</source>
          <target state="translated">Преобразует итератор в коллекцию.</target>
        </trans-unit>
        <trans-unit id="81c1484a18bb69461dc41663b8ca61aba770c66a" translate="yes" xml:space="preserve">
          <source>Transforms an iterator into a collection. &lt;a href=&quot;../../../iter/trait.iterator#method.collect&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">Преобразует итератор в коллекцию. &lt;a href=&quot;../../../iter/trait.iterator#method.collect&quot;&gt;Читать далее&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="0fe9703c09ae5aff473aa850cc9ea84e177f2a25" translate="yes" xml:space="preserve">
          <source>Transforms an iterator into a collection. &lt;a href=&quot;../../iter/trait.iterator#method.collect&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">Преобразует итератор в коллекцию. &lt;a href=&quot;../../iter/trait.iterator#method.collect&quot;&gt;Читать далее&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="d95c53779cc93ec00cbab50bc8d1d781ee0140b9" translate="yes" xml:space="preserve">
          <source>Transforms an iterator into a collection. &lt;a href=&quot;../iter/trait.iterator#method.collect&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">Преобразует итератор в коллекцию. &lt;a href=&quot;../iter/trait.iterator#method.collect&quot;&gt;Читать далее&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="8f6c7d5e9d128d42f6100c26dc454bf0231e3a05" translate="yes" xml:space="preserve">
          <source>Transforms an iterator into a collection. &lt;a href=&quot;iter/trait.iterator#method.collect&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">Преобразует итератор в коллекцию. &lt;a href=&quot;iter/trait.iterator#method.collect&quot;&gt;Читать далее&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="6f3c54bd44a2ac346c25bc4bf8dc990a7215290b" translate="yes" xml:space="preserve">
          <source>Transforms an iterator into a collection. &lt;a href=&quot;trait.iterator#method.collect&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">Преобразует итератор в коллекцию. &lt;a href=&quot;trait.iterator#method.collect&quot;&gt;Читать далее&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="6d04afdfe20a5d1e30c5697c258379dba1dfdd82" translate="yes" xml:space="preserve">
          <source>Transforms the &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt; into a &lt;a href=&quot;../result/enum.result&quot;&gt;&lt;code&gt;Result&amp;lt;T, E&amp;gt;&lt;/code&gt;&lt;/a&gt;, mapping &lt;a href=&quot;#variant.Some&quot;&gt;&lt;code&gt;Some(v)&lt;/code&gt;&lt;/a&gt; to &lt;a href=&quot;../result/enum.result#variant.Ok&quot;&gt;&lt;code&gt;Ok(v)&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt; to &lt;a href=&quot;../result/enum.result#variant.Err&quot;&gt;&lt;code&gt;Err(err())&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Преобразует &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt; в &lt;a href=&quot;../result/enum.result&quot;&gt; &lt;code&gt;Result&amp;lt;T, E&amp;gt;&lt;/code&gt; &lt;/a&gt; , сопоставляя &lt;a href=&quot;#variant.Some&quot;&gt; &lt;code&gt;Some(v)&lt;/code&gt; &lt;/a&gt; с &lt;a href=&quot;../result/enum.result#variant.Ok&quot;&gt; &lt;code&gt;Ok(v)&lt;/code&gt; &lt;/a&gt; и &lt;a href=&quot;#variant.None&quot;&gt; &lt;code&gt;None&lt;/code&gt; &lt;/a&gt; с &lt;a href=&quot;../result/enum.result#variant.Err&quot;&gt; &lt;code&gt;Err(err())&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="9a32b0b090c9474f23fede28872bd2f862d58ca7" translate="yes" xml:space="preserve">
          <source>Transforms the &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt; into a &lt;a href=&quot;../result/enum.result&quot;&gt;&lt;code&gt;Result&amp;lt;T, E&amp;gt;&lt;/code&gt;&lt;/a&gt;, mapping &lt;a href=&quot;#variant.Some&quot;&gt;&lt;code&gt;Some(v)&lt;/code&gt;&lt;/a&gt; to &lt;a href=&quot;../result/enum.result#variant.Ok&quot;&gt;&lt;code&gt;Ok(v)&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt; to &lt;a href=&quot;../result/enum.result#variant.Err&quot;&gt;&lt;code&gt;Err(err)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Преобразует &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt; в &lt;a href=&quot;../result/enum.result&quot;&gt; &lt;code&gt;Result&amp;lt;T, E&amp;gt;&lt;/code&gt; &lt;/a&gt; , сопоставляя &lt;a href=&quot;#variant.Some&quot;&gt; &lt;code&gt;Some(v)&lt;/code&gt; &lt;/a&gt; с &lt;a href=&quot;../result/enum.result#variant.Ok&quot;&gt; &lt;code&gt;Ok(v)&lt;/code&gt; &lt;/a&gt; и &lt;a href=&quot;#variant.None&quot;&gt; &lt;code&gt;None&lt;/code&gt; &lt;/a&gt; с &lt;a href=&quot;../result/enum.result#variant.Err&quot;&gt; &lt;code&gt;Err(err)&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="398730368239daf72c58a553f251431298c7cfb2" translate="yes" xml:space="preserve">
          <source>Transforms the &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt; into a &lt;a href=&quot;../result/enum.result&quot;&gt;&lt;code&gt;Result&amp;lt;T, E&amp;gt;&lt;/code&gt;&lt;/a&gt;, mapping &lt;a href=&quot;enum.option#variant.Some&quot;&gt;&lt;code&gt;Some(v)&lt;/code&gt;&lt;/a&gt; to &lt;a href=&quot;../result/enum.result#variant.Ok&quot;&gt;&lt;code&gt;Ok(v)&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt; to &lt;a href=&quot;../result/enum.result#variant.Err&quot;&gt;&lt;code&gt;Err(err())&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3d6f8723802ef085327c42e8d97e13f22a876933" translate="yes" xml:space="preserve">
          <source>Transforms the &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt; into a &lt;a href=&quot;../result/enum.result&quot;&gt;&lt;code&gt;Result&amp;lt;T, E&amp;gt;&lt;/code&gt;&lt;/a&gt;, mapping &lt;a href=&quot;enum.option#variant.Some&quot;&gt;&lt;code&gt;Some(v)&lt;/code&gt;&lt;/a&gt; to &lt;a href=&quot;../result/enum.result#variant.Ok&quot;&gt;&lt;code&gt;Ok(v)&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt; to &lt;a href=&quot;../result/enum.result#variant.Err&quot;&gt;&lt;code&gt;Err(err)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eeb313d7fccfec96291e799fbdbae78f85b64379" translate="yes" xml:space="preserve">
          <source>Transforms this &lt;code&gt;Read&lt;/code&gt; instance to an &lt;a href=&quot;../../../iter/trait.iterator&quot;&gt;&lt;code&gt;Iterator&lt;/code&gt;&lt;/a&gt; over its bytes. &lt;a href=&quot;../../../io/trait.read#method.bytes&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b4eb95563ead3e77457aefa3ae80b465ed16f04e" translate="yes" xml:space="preserve">
          <source>Transforms this &lt;code&gt;Read&lt;/code&gt; instance to an &lt;a href=&quot;../iter/trait.iterator&quot;&gt;&lt;code&gt;Iterator&lt;/code&gt;&lt;/a&gt; over its bytes.</source>
          <target state="translated">Преобразует этот экземпляр &lt;code&gt;Read&lt;/code&gt; в &lt;a href=&quot;../iter/trait.iterator&quot;&gt; &lt;code&gt;Iterator&lt;/code&gt; &lt;/a&gt; по его байтам.</target>
        </trans-unit>
        <trans-unit id="95b63dbe9d04ab6189a2f04a995620130158a036" translate="yes" xml:space="preserve">
          <source>Transforms this &lt;code&gt;Read&lt;/code&gt; instance to an &lt;a href=&quot;../iter/trait.iterator&quot;&gt;&lt;code&gt;Iterator&lt;/code&gt;&lt;/a&gt; over its bytes. &lt;a href=&quot;../io/trait.read#method.bytes&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="87a749feee7f6dbf3973b0c9eb615ab3107735d9" translate="yes" xml:space="preserve">
          <source>Transforms this &lt;code&gt;Read&lt;/code&gt; instance to an &lt;a href=&quot;../iter/trait.iterator&quot;&gt;&lt;code&gt;Iterator&lt;/code&gt;&lt;/a&gt; over its bytes. &lt;a href=&quot;trait.read#method.bytes&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="96b59ca5339cfaac01d1e21047c3e9f00c4f7918" translate="yes" xml:space="preserve">
          <source>Transforms this &lt;code&gt;Read&lt;/code&gt; instance to an &lt;a href=&quot;iter/trait.iterator&quot;&gt;&lt;code&gt;Iterator&lt;/code&gt;&lt;/a&gt; over its bytes. &lt;a href=&quot;io/trait.read#method.bytes&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="03c96526be3584d2d000005b6f01d7d3341c8987" translate="yes" xml:space="preserve">
          <source>Transforms this &lt;code&gt;Read&lt;/code&gt; instance to an [&lt;code&gt;Iterator&lt;/code&gt;] over its bytes. &lt;a href=&quot;../../../io/trait.read#method.bytes&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">Преобразует этот экземпляр &lt;code&gt;Read&lt;/code&gt; в [ &lt;code&gt;Iterator&lt;/code&gt; ] по его байтам. &lt;a href=&quot;../../../io/trait.read#method.bytes&quot;&gt;Читать далее&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="12fec74288b63220271ad545369927ef8290a081" translate="yes" xml:space="preserve">
          <source>Transforms this &lt;code&gt;Read&lt;/code&gt; instance to an [&lt;code&gt;Iterator&lt;/code&gt;] over its bytes. &lt;a href=&quot;../io/trait.read#method.bytes&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">Преобразует этот экземпляр &lt;code&gt;Read&lt;/code&gt; в [ &lt;code&gt;Iterator&lt;/code&gt; ] по его байтам. &lt;a href=&quot;../io/trait.read#method.bytes&quot;&gt;Читать далее&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="caf9cf05351d52e3be9282ae06933a14488056d3" translate="yes" xml:space="preserve">
          <source>Transforms this &lt;code&gt;Read&lt;/code&gt; instance to an [&lt;code&gt;Iterator&lt;/code&gt;] over its bytes. &lt;a href=&quot;io/trait.read#method.bytes&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">Преобразует этот экземпляр &lt;code&gt;Read&lt;/code&gt; в [ &lt;code&gt;Iterator&lt;/code&gt; ] по его байтам. &lt;a href=&quot;io/trait.read#method.bytes&quot;&gt;Читать далее&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="971992e8ed9d30a3c4193fa3cfd51e0926ac6cae" translate="yes" xml:space="preserve">
          <source>Transforms this &lt;code&gt;Read&lt;/code&gt; instance to an [&lt;code&gt;Iterator&lt;/code&gt;] over its bytes. &lt;a href=&quot;trait.read#method.bytes&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">Преобразует этот экземпляр &lt;code&gt;Read&lt;/code&gt; в [ &lt;code&gt;Iterator&lt;/code&gt; ] по его байтам. &lt;a href=&quot;trait.read#method.bytes&quot;&gt;Читать далее&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="1a3526b9261f151b08efa12a2cb227e4ab668a50" translate="yes" xml:space="preserve">
          <source>Transmute the slice to a slice of another type, ensuring alignment of the types is maintained.</source>
          <target state="translated">Передайте фрагмент на фрагмент другого типа,обеспечив выравнивание типов.</target>
        </trans-unit>
        <trans-unit id="b2cf0502b0b75797a67313725bcf7174bc249f5e" translate="yes" xml:space="preserve">
          <source>Transmute with two differently sized types was attempted.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f952303e87a91f8044520d869ced49cf3453271e" translate="yes" xml:space="preserve">
          <source>Transmute with two differently sized types was attempted. Erroneous code example:</source>
          <target state="translated">Была предпринята попытка передачи с двумя разными по размеру типами.Пример ошибочного кода:</target>
        </trans-unit>
        <trans-unit id="b4634eab766a7c67f4a788882ed6708930ac7723" translate="yes" xml:space="preserve">
          <source>Transposes a &lt;code&gt;Result&lt;/code&gt; of an &lt;code&gt;Option&lt;/code&gt; into an &lt;code&gt;Option&lt;/code&gt; of a &lt;code&gt;Result&lt;/code&gt;.</source>
          <target state="translated">Транспонирование на &lt;code&gt;Result&lt;/code&gt; в качестве &lt;code&gt;Option&lt;/code&gt; в качестве &lt;code&gt;Option&lt;/code&gt; в виде &lt;code&gt;Result&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="aeec9f606ca7cc27f401e6245265d892d7c06264" translate="yes" xml:space="preserve">
          <source>Transposes an &lt;code&gt;Option&lt;/code&gt; of a &lt;a href=&quot;../result/enum.result&quot;&gt;&lt;code&gt;Result&lt;/code&gt;&lt;/a&gt; into a &lt;a href=&quot;../result/enum.result&quot;&gt;&lt;code&gt;Result&lt;/code&gt;&lt;/a&gt; of an &lt;code&gt;Option&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="86f3938f31467da551894d5bc312a73ba5dfa379" translate="yes" xml:space="preserve">
          <source>Transposes an &lt;code&gt;Option&lt;/code&gt; of a &lt;code&gt;Result&lt;/code&gt; into a &lt;code&gt;Result&lt;/code&gt; of an &lt;code&gt;Option&lt;/code&gt;.</source>
          <target state="translated">Транспонирование в &lt;code&gt;Option&lt;/code&gt; из более &lt;code&gt;Result&lt;/code&gt; в &lt;code&gt;Result&lt;/code&gt; в качестве &lt;code&gt;Option&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c9ccf92c436ad92e69f629d1e0488d9928d7d7e6" translate="yes" xml:space="preserve">
          <source>Treating Smart Pointers Like Regular References with the &lt;code id=&quot;treating-smart-pointers-like-regular-references-with-the-deref-trait&quot;&gt;Deref&lt;/code&gt; Trait</source>
          <target state="translated">Лечение интеллектуальных указателей как обычные Ссылки с &lt;code id=&quot;treating-smart-pointers-like-regular-references-with-the-deref-trait&quot;&gt;Deref&lt;/code&gt; Trait</target>
        </trans-unit>
        <trans-unit id="453a0f8e23093d2d468470224b84f666ef425b17" translate="yes" xml:space="preserve">
          <source>Treating a Type Like a Reference by Implementing the &lt;code id=&quot;treating-a-type-like-a-reference-by-implementing-the-deref-trait&quot;&gt;Deref&lt;/code&gt; Trait</source>
          <target state="translated">Лечение Типа как ссылка путем реализации &lt;code id=&quot;treating-a-type-like-a-reference-by-implementing-the-deref-trait&quot;&gt;Deref&lt;/code&gt; Trait</target>
        </trans-unit>
        <trans-unit id="dc5f05aecd7821404c68147034c8c8b762c94716" translate="yes" xml:space="preserve">
          <source>Treating each integration test file as its own crate is useful to create separate scopes that are more like the way end users will be using your crate. However, this means files in the &lt;em&gt;tests&lt;/em&gt; directory don&amp;rsquo;t share the same behavior as files in &lt;em&gt;src&lt;/em&gt; do, as you learned in Chapter 7 regarding how to separate code into modules and files.</source>
          <target state="translated">Рассмотрение каждого файла интеграционного теста как отдельного ящика полезно для создания отдельных областей, которые больше похожи на то, как конечные пользователи будут использовать ваш ящик. Однако это означает, что файлы в каталоге &lt;em&gt;tests&lt;/em&gt; не имеют того же поведения, что и файлы в &lt;em&gt;src&lt;/em&gt; , как вы узнали в главе 7 о том, как разделить код на модули и файлы.</target>
        </trans-unit>
        <trans-unit id="7569cb1679e0c3aa7540702f13a5f8dd4a1739a0" translate="yes" xml:space="preserve">
          <source>Tries to reserve capacity for at least &lt;code&gt;additional&lt;/code&gt; more elements to be inserted in the given &lt;code&gt;HashMap&amp;lt;K,V&amp;gt;&lt;/code&gt;. The collection may reserve more space to avoid frequent reallocations.</source>
          <target state="translated">Пытается зарезервировать емкость, по крайней мере, для &lt;code&gt;additional&lt;/code&gt; элементов, которые будут вставлены в данный &lt;code&gt;HashMap&amp;lt;K,V&amp;gt;&lt;/code&gt; . Коллекция может зарезервировать больше места, чтобы избежать частого перераспределения.</target>
        </trans-unit>
        <trans-unit id="44298809e4f1f115c9f5ba28f46ae5a8d609bfc3" translate="yes" xml:space="preserve">
          <source>Tries to reserve capacity for at least &lt;code&gt;additional&lt;/code&gt; more elements to be inserted in the given &lt;code&gt;HashSet&amp;lt;K,V&amp;gt;&lt;/code&gt;. The collection may reserve more space to avoid frequent reallocations.</source>
          <target state="translated">Пытается зарезервировать емкость по крайней мере для &lt;code&gt;additional&lt;/code&gt; элементов, которые должны быть вставлены в данный &lt;code&gt;HashSet&amp;lt;K,V&amp;gt;&lt;/code&gt; . Коллекция может зарезервировать больше места, чтобы избежать частого перераспределения.</target>
        </trans-unit>
        <trans-unit id="57b7ed7bcbd15d35b279a1bce9bfd658efd71b2a" translate="yes" xml:space="preserve">
          <source>Tries to reserve capacity for at least &lt;code&gt;additional&lt;/code&gt; more elements to be inserted in the given &lt;code&gt;String&lt;/code&gt;. The collection may reserve more space to avoid frequent reallocations. After calling &lt;code&gt;reserve&lt;/code&gt;, capacity will be greater than or equal to &lt;code&gt;self.len() + additional&lt;/code&gt;. Does nothing if capacity is already sufficient.</source>
          <target state="translated">Пытается зарезервировать емкость, по крайней мере, для &lt;code&gt;additional&lt;/code&gt; элементов, которые будут вставлены в данную &lt;code&gt;String&lt;/code&gt; . Коллекция может зарезервировать больше места, чтобы избежать частого перераспределения. После вызова &lt;code&gt;reserve&lt;/code&gt; емкости емкость будет больше или равна &lt;code&gt;self.len() + additional&lt;/code&gt; . Ничего не делает, если емкости уже достаточно.</target>
        </trans-unit>
        <trans-unit id="1cd7b987cbc0791bfb1324cfd6464263751dd7d3" translate="yes" xml:space="preserve">
          <source>Tries to reserve capacity for at least &lt;code&gt;additional&lt;/code&gt; more elements to be inserted in the given &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt;. The collection may reserve more space to avoid frequent reallocations. After calling &lt;code&gt;reserve&lt;/code&gt;, capacity will be greater than or equal to &lt;code&gt;self.len() + additional&lt;/code&gt;. Does nothing if capacity is already sufficient.</source>
          <target state="translated">Пытается зарезервировать емкость, по крайней мере, для &lt;code&gt;additional&lt;/code&gt; элементов, которые будут вставлены в данный &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; . Коллекция может зарезервировать больше места, чтобы избежать частого перераспределения. После вызова &lt;code&gt;reserve&lt;/code&gt; емкости емкость будет больше или равна &lt;code&gt;self.len() + additional&lt;/code&gt; . Ничего не делает, если емкости уже достаточно.</target>
        </trans-unit>
        <trans-unit id="3cfac0433720c8cd13adc91772d417cffa80bddb" translate="yes" xml:space="preserve">
          <source>Tries to reserve capacity for at least &lt;code&gt;additional&lt;/code&gt; more elements to be inserted in the given &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt;. The collection may reserve more space to avoid frequent reallocations. After calling &lt;code&gt;try_reserve&lt;/code&gt;, capacity will be greater than or equal to &lt;code&gt;self.len() + additional&lt;/code&gt;. Does nothing if capacity is already sufficient.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4ddb2f7e963d7384fcd84f59781aafbcb1eefd0c" translate="yes" xml:space="preserve">
          <source>Tries to reserve capacity for at least &lt;code&gt;additional&lt;/code&gt; more elements to be inserted in the given &lt;code&gt;VecDeque&amp;lt;T&amp;gt;&lt;/code&gt;. The collection may reserve more space to avoid frequent reallocations. After calling &lt;code&gt;reserve&lt;/code&gt;, capacity will be greater than or equal to &lt;code&gt;self.len() + additional&lt;/code&gt;. Does nothing if capacity is already sufficient.</source>
          <target state="translated">Пытается зарезервировать емкость, по крайней мере, для &lt;code&gt;additional&lt;/code&gt; элементов, которые будут вставлены в данный &lt;code&gt;VecDeque&amp;lt;T&amp;gt;&lt;/code&gt; . Коллекция может зарезервировать больше места, чтобы избежать частого перераспределения. После вызова &lt;code&gt;reserve&lt;/code&gt; емкости емкость будет больше или равна &lt;code&gt;self.len() + additional&lt;/code&gt; . Ничего не делает, если емкости уже достаточно.</target>
        </trans-unit>
        <trans-unit id="c6ae8edff340a9bc30d1fc3ea07c88a2d615e594" translate="yes" xml:space="preserve">
          <source>Tries to reserve capacity for at least &lt;code&gt;additional&lt;/code&gt; more elements to be inserted in the given &lt;code&gt;VecDeque&amp;lt;T&amp;gt;&lt;/code&gt;. The collection may reserve more space to avoid frequent reallocations. After calling &lt;code&gt;try_reserve&lt;/code&gt;, capacity will be greater than or equal to &lt;code&gt;self.len() + additional&lt;/code&gt;. Does nothing if capacity is already sufficient.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="64c1225ca478afba96e69e3738929c44dc44f818" translate="yes" xml:space="preserve">
          <source>Tries to reserve the minimum capacity for exactly &lt;code&gt;additional&lt;/code&gt; elements to be inserted in the given &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt;. After calling &lt;code&gt;try_reserve_exact&lt;/code&gt;, capacity will be greater than or equal to &lt;code&gt;self.len() + additional&lt;/code&gt; if it returns &lt;code&gt;Ok(())&lt;/code&gt;. Does nothing if the capacity is already sufficient.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1c910716261f7e551f1259edf1ea661f9578f8fe" translate="yes" xml:space="preserve">
          <source>Tries to reserve the minimum capacity for exactly &lt;code&gt;additional&lt;/code&gt; more elements to be inserted in the given &lt;code&gt;VecDeque&amp;lt;T&amp;gt;&lt;/code&gt;. After calling &lt;code&gt;try_reserve_exact&lt;/code&gt;, capacity will be greater than or equal to &lt;code&gt;self.len() + additional&lt;/code&gt;. Does nothing if the capacity is already sufficient.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ea826f973c60e61f52c1a1545b1dfe84c909b71b" translate="yes" xml:space="preserve">
          <source>Tries to reserves the minimum capacity for exactly &lt;code&gt;additional&lt;/code&gt; more elements to be inserted in the given &lt;code&gt;String&lt;/code&gt;. After calling &lt;code&gt;reserve_exact&lt;/code&gt;, capacity will be greater than or equal to &lt;code&gt;self.len() + additional&lt;/code&gt;. Does nothing if the capacity is already sufficient.</source>
          <target state="translated">Пытается зарезервировать минимальную емкость для &lt;code&gt;additional&lt;/code&gt; элементов, которые будут вставлены в данную &lt;code&gt;String&lt;/code&gt; . После вызова &lt;code&gt;reserve_exact&lt;/code&gt; емкость будет больше или равна &lt;code&gt;self.len() + additional&lt;/code&gt; . Ничего не делает, если емкости уже достаточно.</target>
        </trans-unit>
        <trans-unit id="c6bd5db90f8cb9540fd3f35c2883f8b8a881d37a" translate="yes" xml:space="preserve">
          <source>Tries to reserves the minimum capacity for exactly &lt;code&gt;additional&lt;/code&gt; more elements to be inserted in the given &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt;. After calling &lt;code&gt;reserve_exact&lt;/code&gt;, capacity will be greater than or equal to &lt;code&gt;self.len() + additional&lt;/code&gt;. Does nothing if the capacity is already sufficient.</source>
          <target state="translated">Пытается зарезервировать минимальную емкость для вставки &lt;code&gt;additional&lt;/code&gt; элементов в данный &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; . После вызова &lt;code&gt;reserve_exact&lt;/code&gt; емкость будет больше или равна &lt;code&gt;self.len() + additional&lt;/code&gt; . Ничего не делает, если емкости уже достаточно.</target>
        </trans-unit>
        <trans-unit id="90bd1ab7f76bd67110646c064057b5e26a376cef" translate="yes" xml:space="preserve">
          <source>Tries to reserves the minimum capacity for exactly &lt;code&gt;additional&lt;/code&gt; more elements to be inserted in the given &lt;code&gt;VecDeque&amp;lt;T&amp;gt;&lt;/code&gt;. After calling &lt;code&gt;reserve_exact&lt;/code&gt;, capacity will be greater than or equal to &lt;code&gt;self.len() + additional&lt;/code&gt;. Does nothing if the capacity is already sufficient.</source>
          <target state="translated">Пытается &lt;code&gt;VecDeque&amp;lt;T&amp;gt;&lt;/code&gt; минимальную емкость для вставки &lt;code&gt;additional&lt;/code&gt; элементов в данный VecDeque &amp;lt;T&amp;gt; . После вызова &lt;code&gt;reserve_exact&lt;/code&gt; емкость будет больше или равна &lt;code&gt;self.len() + additional&lt;/code&gt; . Ничего не делает, если емкости уже достаточно.</target>
        </trans-unit>
        <trans-unit id="6547ac01541509cbac431ef7568ec956f10079ba" translate="yes" xml:space="preserve">
          <source>Triggers a panic without invoking the panic hook.</source>
          <target state="translated">Спровоцирует панику,не вызывая панического крючка.</target>
        </trans-unit>
        <trans-unit id="285ec850c11d78bac10f6bfa31b69a37f1b257c9" translate="yes" xml:space="preserve">
          <source>Troubleshooting</source>
          <target state="translated">Troubleshooting</target>
        </trans-unit>
        <trans-unit id="27c211f297ff6afd2354cf8148b012cae3b0628b" translate="yes" xml:space="preserve">
          <source>Truncates &lt;code&gt;self&lt;/code&gt; to &lt;a href=&quot;struct.path#method.parent&quot;&gt;&lt;code&gt;self.parent&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="adb95599ef56aa13caaac1499a3644565e8b6049" translate="yes" xml:space="preserve">
          <source>Truncates &lt;code&gt;self&lt;/code&gt; to &lt;a href=&quot;struct.pathbuf#method.parent&quot;&gt;&lt;code&gt;self.parent&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Обрезает &lt;code&gt;self&lt;/code&gt; в &lt;a href=&quot;struct.pathbuf#method.parent&quot;&gt; &lt;code&gt;self.parent&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="5927f0d5ac8801b4254d8379327d991a701a80da" translate="yes" xml:space="preserve">
          <source>Truncates or extends the underlying file, updating the size of this file to become &lt;code&gt;size&lt;/code&gt;.</source>
          <target state="translated">Обрезает или расширяет базовый файл, обновляя размер этого файла до &lt;code&gt;size&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2702cfbf0e58f8f82fb23e8d650e499d7cc927c5" translate="yes" xml:space="preserve">
          <source>Truncates the &lt;code&gt;OsString&lt;/code&gt; to zero length.</source>
          <target state="translated">Усекает &lt;code&gt;OsString&lt;/code&gt; до нулевой длины.</target>
        </trans-unit>
        <trans-unit id="ed28d8bdecc758ddcef76eed8b86ffa1d4ea3181" translate="yes" xml:space="preserve">
          <source>Truncates this &lt;code&gt;String&lt;/code&gt;, removing all contents.</source>
          <target state="translated">Обрезает эту &lt;code&gt;String&lt;/code&gt; , удаляя все содержимое.</target>
        </trans-unit>
        <trans-unit id="5474aa5946c713a1f6e7a033ad591db623edd6d3" translate="yes" xml:space="preserve">
          <source>Truncating a five element vector to two elements:</source>
          <target state="translated">Усечение пятиэлементного вектора на два элемента:</target>
        </trans-unit>
        <trans-unit id="743f01c9ef69fe480785553858265deba678132e" translate="yes" xml:space="preserve">
          <source>Truncating when &lt;code&gt;len == 0&lt;/code&gt; is equivalent to calling the &lt;a href=&quot;#method.clear&quot;&gt;&lt;code&gt;clear&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">Усечение, когда &lt;code&gt;len == 0&lt;/code&gt; эквивалентно вызову метода &lt;a href=&quot;#method.clear&quot;&gt; &lt;code&gt;clear&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="7b9f4a78a76c6893e05b1ff011a47211505551b2" translate="yes" xml:space="preserve">
          <source>Truncating when &lt;code&gt;len == 0&lt;/code&gt; is equivalent to calling the &lt;a href=&quot;struct.vec#method.clear&quot;&gt;&lt;code&gt;clear&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="63908c3dcfc457f07a333b89f52c763024b846da" translate="yes" xml:space="preserve">
          <source>TrustedLen</source>
          <target state="translated">TrustedLen</target>
        </trans-unit>
        <trans-unit id="72677028b4d0d41af475041fdbe030f7c7146d2c" translate="yes" xml:space="preserve">
          <source>Try</source>
          <target state="translated">Try</target>
        </trans-unit>
        <trans-unit id="93cacc9f6a162523f52bc4401526c741faac95a0" translate="yes" xml:space="preserve">
          <source>Try designing more experiments that vary the values and lifetimes of the references passed in to the &lt;code&gt;longest&lt;/code&gt; function and how the returned reference is used. Make hypotheses about whether or not your experiments will pass the borrow checker before you compile; then check to see if you&amp;rsquo;re right!</source>
          <target state="translated">Попробуйте разработать больше экспериментов, которые изменяют значения и время жизни ссылок, передаваемых самой &lt;code&gt;longest&lt;/code&gt; функции, и способы использования возвращаемой ссылки. Выдвигайте гипотезы о том, пройдут ли ваши эксперименты проверку заимствований перед компиляцией; затем проверьте, правы ли вы!</target>
        </trans-unit>
        <trans-unit id="b25651affa48a09fef804a246293a9441327deef" translate="yes" xml:space="preserve">
          <source>Try making a request from a different browser or asking for a different address, such as &lt;em&gt;127.0.0.1:7878/test&lt;/em&gt;, to see how the request data changes.</source>
          <target state="translated">Попробуйте сделать запрос из другого браузера или запросить другой адрес, например &lt;em&gt;127.0.0.1:7878/test&lt;/em&gt; , чтобы увидеть, как изменяются данные запроса.</target>
        </trans-unit>
        <trans-unit id="3cdedf03df7f2d7ff7f62a3fe4c0233e49c2605a" translate="yes" xml:space="preserve">
          <source>Try modifying &lt;code&gt;Cacher&lt;/code&gt; to hold a hash map rather than a single value. The keys of the hash map will be the &lt;code&gt;arg&lt;/code&gt; values that are passed in, and the values of the hash map will be the result of calling the closure on that key. Instead of looking at whether &lt;code&gt;self.value&lt;/code&gt; directly has a &lt;code&gt;Some&lt;/code&gt; or a &lt;code&gt;None&lt;/code&gt; value, the &lt;code&gt;value&lt;/code&gt; function will look up the &lt;code&gt;arg&lt;/code&gt; in the hash map and return the value if it&amp;rsquo;s present. If it&amp;rsquo;s not present, the &lt;code&gt;Cacher&lt;/code&gt; will call the closure and save the resulting value in the hash map associated with its &lt;code&gt;arg&lt;/code&gt; value.</source>
          <target state="translated">Попробуйте изменить &lt;code&gt;Cacher&lt;/code&gt; , чтобы он содержал хеш-карту, а не одно значение. Ключи хэш-карты будут значениями &lt;code&gt;arg&lt;/code&gt; , которые передаются, а значения хеш-карты будут результатом вызова замыкания для этого ключа. Вместо того, чтобы смотреть, имеет ли &lt;code&gt;self.value&lt;/code&gt; непосредственно значение &lt;code&gt;Some&lt;/code&gt; или &lt;code&gt;None&lt;/code&gt; , функция &lt;code&gt;value&lt;/code&gt; будет искать &lt;code&gt;arg&lt;/code&gt; в хэш-карте и возвращать значение, если оно присутствует. Если его нет, &lt;code&gt;Cacher&lt;/code&gt; вызовет закрытие и сохранит полученное значение в хэш-карте, связанной с его значением &lt;code&gt;arg&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="746db25e46725d2a25a5be38541b8fd90c0e318e" translate="yes" xml:space="preserve">
          <source>Try running the program a few times:</source>
          <target state="translated">Попробуйте запустить программу несколько раз:</target>
        </trans-unit>
        <trans-unit id="40db21ca976b20c4f1a37614a766d7e0fedff356" translate="yes" xml:space="preserve">
          <source>Try running this code; you should see the following output:</source>
          <target state="translated">Попробуйте запустить этот код;вы должны увидеть следующий вывод:</target>
        </trans-unit>
        <trans-unit id="0c704dff8c8947b24bdb19d42ed1933021fa9b51" translate="yes" xml:space="preserve">
          <source>Try running this program with the &lt;code&gt;main&lt;/code&gt; function from Listing 13-2. Change the values in the &lt;code&gt;simulated_user_specified_value&lt;/code&gt; and &lt;code&gt;simulated_random_number&lt;/code&gt; variables to verify that in all the cases in the various &lt;code&gt;if&lt;/code&gt; and &lt;code&gt;else&lt;/code&gt; blocks, &lt;code&gt;calculating slowly...&lt;/code&gt; appears only once and only when needed. The &lt;code&gt;Cacher&lt;/code&gt; takes care of the logic necessary to ensure we aren&amp;rsquo;t calling the expensive calculation more than we need to so &lt;code&gt;generate_workout&lt;/code&gt; can focus on the business logic.</source>
          <target state="translated">Попробуйте запустить эту программу с функцией &lt;code&gt;main&lt;/code&gt; из Листинга 13-2. Измените значения в переменных &lt;code&gt;simulated_user_specified_value&lt;/code&gt; и &lt;code&gt;simulated_random_number&lt;/code&gt; , чтобы убедиться, что во всех случаях в различных блоках &lt;code&gt;if&lt;/code&gt; и &lt;code&gt;else&lt;/code&gt; , &lt;code&gt;calculating slowly...&lt;/code&gt; появляется только один раз и только тогда, когда это необходимо. &lt;code&gt;Cacher&lt;/code&gt; заботится о логике , необходимой для обеспечения мы не называем дорогой расчет больше , чем нужно , так &lt;code&gt;generate_workout&lt;/code&gt; может сосредоточиться на бизнес - логике.</target>
        </trans-unit>
        <trans-unit id="f64954535b22680cee23c59284f0821d313912c5" translate="yes" xml:space="preserve">
          <source>Try running this program; you should get the following output:</source>
          <target state="translated">Попробуйте запустить эту программу;вы должны получить следующий вывод:</target>
        </trans-unit>
        <trans-unit id="4e2f79e768da3d333677b7768aba6698b9473abe" translate="yes" xml:space="preserve">
          <source>Try the tasks suggested for additional requirements that we mentioned at the start of this section on the &lt;code&gt;blog&lt;/code&gt; crate as it is after Listing 17-20 to see what you think about the design of this version of the code. Note that some of the tasks might be completed already in this design.</source>
          <target state="translated">Попробуйте выполнить задачи, предложенные для дополнительных требований, которые мы упомянули в начале этого раздела на ящике &lt;code&gt;blog&lt;/code&gt; как это указано в листинге 17-20, чтобы узнать, что вы думаете о дизайне этой версии кода. Обратите внимание, что некоторые задачи могут быть выполнены уже в этом дизайне.</target>
        </trans-unit>
        <trans-unit id="bea7aa5241bc934fb93d73fbe72c3c92fd9cb391" translate="yes" xml:space="preserve">
          <source>Try this instead:</source>
          <target state="translated">Попробуй вместо этого:</target>
        </trans-unit>
        <trans-unit id="cf4dffd1f17e87d4131fe9dbd6ed3566366e3295" translate="yes" xml:space="preserve">
          <source>Try to avoid moving the variable.</source>
          <target state="translated">Постарайтесь не перемещать переменную.</target>
        </trans-unit>
        <trans-unit id="708f496ce718cad5f2bfb9c2203cb73e375d06e0" translate="yes" xml:space="preserve">
          <source>Try to create the target number type from a source number type. This returns an error if the source value is outside of the range of the target type.</source>
          <target state="translated">Попробуйте создать тип целевого номера из типа исходного номера.Это возвращает ошибку,если значение источника находится за пределами диапазона типа целевого номера.</target>
        </trans-unit>
        <trans-unit id="d7bb54d91c5813615d6b6445e2ebf488e82cdc0c" translate="yes" xml:space="preserve">
          <source>Try using &lt;code&gt;{}&lt;/code&gt; instead:</source>
          <target state="translated">Попробуйте вместо этого использовать &lt;code&gt;{}&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="b8a1eb6a4114d62537aa281f5d03abf55ba6e9e3" translate="yes" xml:space="preserve">
          <source>Try using type inference instead. Example:</source>
          <target state="translated">Попробуйте вместо этого использовать типовой вывод.Пример:</target>
        </trans-unit>
        <trans-unit id="ea0079401a89dd04fe8291c0c734d4aa5a8c7177" translate="yes" xml:space="preserve">
          <source>Try::from_error</source>
          <target state="translated">Try::from_error</target>
        </trans-unit>
        <trans-unit id="bde6f44b7e04bd6491a07ffb037c4fa48b882a33" translate="yes" xml:space="preserve">
          <source>Try::from_ok</source>
          <target state="translated">Try::from_ok</target>
        </trans-unit>
        <trans-unit id="809111dd75695d75905fa1c8b4bad5d14691a30e" translate="yes" xml:space="preserve">
          <source>Try::into_result</source>
          <target state="translated">Try::into_result</target>
        </trans-unit>
        <trans-unit id="18e77d4b44ff639060d9a2fa2960f190781f7859" translate="yes" xml:space="preserve">
          <source>TryFrom</source>
          <target state="translated">TryFrom</target>
        </trans-unit>
        <trans-unit id="4acc1ac1c58ab4ae6724001d461baf2c8b8dbc3a" translate="yes" xml:space="preserve">
          <source>TryFrom::try_from</source>
          <target state="translated">TryFrom::try_from</target>
        </trans-unit>
        <trans-unit id="ad96c601815ad5f050e0b6351dd0b189e48a31a9" translate="yes" xml:space="preserve">
          <source>TryFromIntError</source>
          <target state="translated">TryFromIntError</target>
        </trans-unit>
        <trans-unit id="f81061adcf59a4b18f6432dc500e16b9a793d0e6" translate="yes" xml:space="preserve">
          <source>TryFromIntError::borrow</source>
          <target state="translated">TryFromIntError::borrow</target>
        </trans-unit>
        <trans-unit id="4d5e6ded3e6e6a7b69de27e74b52df8d33085625" translate="yes" xml:space="preserve">
          <source>TryFromIntError::borrow_mut</source>
          <target state="translated">TryFromIntError::borrow_mut</target>
        </trans-unit>
        <trans-unit id="8c6ac7bc7b08a0164c28c84e181d07ac7264caa1" translate="yes" xml:space="preserve">
          <source>TryFromIntError::cause</source>
          <target state="translated">TryFromIntError::cause</target>
        </trans-unit>
        <trans-unit id="f0da83cb703ff9ab478400076f17fb3b6df58453" translate="yes" xml:space="preserve">
          <source>TryFromIntError::clone</source>
          <target state="translated">TryFromIntError::clone</target>
        </trans-unit>
        <trans-unit id="21c991dfc7c9f46d0f223e9ada6bbb1b3ddc0419" translate="yes" xml:space="preserve">
          <source>TryFromIntError::clone_from</source>
          <target state="translated">TryFromIntError::clone_from</target>
        </trans-unit>
        <trans-unit id="611f56282230f313fea840ae9d1b4022b318faec" translate="yes" xml:space="preserve">
          <source>TryFromIntError::clone_into</source>
          <target state="translated">TryFromIntError::clone_into</target>
        </trans-unit>
        <trans-unit id="05df18eb5e5e51ad418c603a8c9e45f939b7afa0" translate="yes" xml:space="preserve">
          <source>TryFromIntError::description</source>
          <target state="translated">TryFromIntError::description</target>
        </trans-unit>
        <trans-unit id="cffa72c79f028d8b2b67ac3b5a88fa8e893445f1" translate="yes" xml:space="preserve">
          <source>TryFromIntError::eq</source>
          <target state="translated">TryFromIntError::eq</target>
        </trans-unit>
        <trans-unit id="7ec29ac29b26af4ad4e22c908d20f04e34123009" translate="yes" xml:space="preserve">
          <source>TryFromIntError::fmt</source>
          <target state="translated">TryFromIntError::fmt</target>
        </trans-unit>
        <trans-unit id="27af3cbe1fc043a4ba2263a1ddb04f43ed3341d8" translate="yes" xml:space="preserve">
          <source>TryFromIntError::from</source>
          <target state="translated">TryFromIntError::from</target>
        </trans-unit>
        <trans-unit id="88b0ca4bd6e97295df88042c17da3bc4ad1d1e49" translate="yes" xml:space="preserve">
          <source>TryFromIntError::into</source>
          <target state="translated">TryFromIntError::into</target>
        </trans-unit>
        <trans-unit id="b590493dab8454ef91bc8263edc4d90474ae7585" translate="yes" xml:space="preserve">
          <source>TryFromIntError::ne</source>
          <target state="translated">TryFromIntError::ne</target>
        </trans-unit>
        <trans-unit id="34bc40cbf452f309c77160c0bc046a559d512c4c" translate="yes" xml:space="preserve">
          <source>TryFromIntError::source</source>
          <target state="translated">TryFromIntError::source</target>
        </trans-unit>
        <trans-unit id="4650111711913011245aed1cfd4e401bf80b92bd" translate="yes" xml:space="preserve">
          <source>TryFromIntError::to_owned</source>
          <target state="translated">TryFromIntError::to_owned</target>
        </trans-unit>
        <trans-unit id="145d38c6294ea7b0b18a9beaf5c2ba62d71c6d31" translate="yes" xml:space="preserve">
          <source>TryFromIntError::to_string</source>
          <target state="translated">TryFromIntError::to_string</target>
        </trans-unit>
        <trans-unit id="3bd074fd7b824eb16d5c009603fefee21d967354" translate="yes" xml:space="preserve">
          <source>TryFromIntError::try_from</source>
          <target state="translated">TryFromIntError::try_from</target>
        </trans-unit>
        <trans-unit id="2a66975e8a4a9df97b01eea79b97edba1ce4fc13" translate="yes" xml:space="preserve">
          <source>TryFromIntError::try_into</source>
          <target state="translated">TryFromIntError::try_into</target>
        </trans-unit>
        <trans-unit id="853b95e029b9b10b04426ea41bce22a33cadfde3" translate="yes" xml:space="preserve">
          <source>TryFromIntError::type_id</source>
          <target state="translated">TryFromIntError::type_id</target>
        </trans-unit>
        <trans-unit id="f7ae979f3e3e5c6883cf562acec4a3d8911ff6b7" translate="yes" xml:space="preserve">
          <source>TryFromSliceError</source>
          <target state="translated">TryFromSliceError</target>
        </trans-unit>
        <trans-unit id="08abda7dda4132c13ad2de215a8116ad1c512693" translate="yes" xml:space="preserve">
          <source>TryFromSliceError::borrow</source>
          <target state="translated">TryFromSliceError::borrow</target>
        </trans-unit>
        <trans-unit id="a42a16b656b3e78ad3c1fba788c25cca8562aa04" translate="yes" xml:space="preserve">
          <source>TryFromSliceError::borrow_mut</source>
          <target state="translated">TryFromSliceError::borrow_mut</target>
        </trans-unit>
        <trans-unit id="6b154dc43d23a695abe3c26c810c9600a10bbfc7" translate="yes" xml:space="preserve">
          <source>TryFromSliceError::cause</source>
          <target state="translated">TryFromSliceError::cause</target>
        </trans-unit>
        <trans-unit id="06c3cdee5b115341587a81b7640e380fd15333ea" translate="yes" xml:space="preserve">
          <source>TryFromSliceError::clone</source>
          <target state="translated">TryFromSliceError::clone</target>
        </trans-unit>
        <trans-unit id="a4d48a9b9f7dd5e07e2bb398d2d1029a5b1eb76b" translate="yes" xml:space="preserve">
          <source>TryFromSliceError::clone_from</source>
          <target state="translated">TryFromSliceError::clone_from</target>
        </trans-unit>
        <trans-unit id="faf3d5f757e37a47d1e58275eb48efaa726218ad" translate="yes" xml:space="preserve">
          <source>TryFromSliceError::clone_into</source>
          <target state="translated">TryFromSliceError::clone_into</target>
        </trans-unit>
        <trans-unit id="49619f8bf5df143f7d9e552904f6a84fca8093ea" translate="yes" xml:space="preserve">
          <source>TryFromSliceError::description</source>
          <target state="translated">TryFromSliceError::description</target>
        </trans-unit>
        <trans-unit id="fc484006f6aa38bffa40eb517d8b4b32091a5671" translate="yes" xml:space="preserve">
          <source>TryFromSliceError::fmt</source>
          <target state="translated">TryFromSliceError::fmt</target>
        </trans-unit>
        <trans-unit id="630dd1955f1b733df02d2f1446cd6b9ba9cd293b" translate="yes" xml:space="preserve">
          <source>TryFromSliceError::from</source>
          <target state="translated">TryFromSliceError::from</target>
        </trans-unit>
        <trans-unit id="2a5519380aabe238e175f9b6849d0a2d7f53c5a8" translate="yes" xml:space="preserve">
          <source>TryFromSliceError::into</source>
          <target state="translated">TryFromSliceError::into</target>
        </trans-unit>
        <trans-unit id="b1ef9a7f4941a7c7fc1ee4d269c0be752b4049c1" translate="yes" xml:space="preserve">
          <source>TryFromSliceError::source</source>
          <target state="translated">TryFromSliceError::source</target>
        </trans-unit>
        <trans-unit id="46b791fdfec792bbb13fbb3115a245caecffc0d8" translate="yes" xml:space="preserve">
          <source>TryFromSliceError::to_owned</source>
          <target state="translated">TryFromSliceError::to_owned</target>
        </trans-unit>
        <trans-unit id="04f8529255b3a3ba17e31837ca350fb03a1837a0" translate="yes" xml:space="preserve">
          <source>TryFromSliceError::to_string</source>
          <target state="translated">TryFromSliceError::to_string</target>
        </trans-unit>
        <trans-unit id="d39f8030ca01a81b1eedd289678e98a9a8c6374d" translate="yes" xml:space="preserve">
          <source>TryFromSliceError::try_from</source>
          <target state="translated">TryFromSliceError::try_from</target>
        </trans-unit>
        <trans-unit id="87b56d5270282ca8cea8f2ae22fb393b6ef2e185" translate="yes" xml:space="preserve">
          <source>TryFromSliceError::try_into</source>
          <target state="translated">TryFromSliceError::try_into</target>
        </trans-unit>
        <trans-unit id="273ef45502220a3e82cc6cd2ff47d1b967ced192" translate="yes" xml:space="preserve">
          <source>TryFromSliceError::type_id</source>
          <target state="translated">TryFromSliceError::type_id</target>
        </trans-unit>
        <trans-unit id="eb91bb9edb358310d1de44ff46dcb50ed3d4dbf6" translate="yes" xml:space="preserve">
          <source>TryInto</source>
          <target state="translated">TryInto</target>
        </trans-unit>
        <trans-unit id="d4782bb6e82830853df5d390b765742f2ed433ce" translate="yes" xml:space="preserve">
          <source>TryInto::try_into</source>
          <target state="translated">TryInto::try_into</target>
        </trans-unit>
        <trans-unit id="d550a8f93a6fe62cffc66481db4e53166b4de9e5" translate="yes" xml:space="preserve">
          <source>TryIter</source>
          <target state="translated">TryIter</target>
        </trans-unit>
        <trans-unit id="b4f81b18947056193693e5cce08cae5bcc996cf1" translate="yes" xml:space="preserve">
          <source>TryLockError</source>
          <target state="translated">TryLockError</target>
        </trans-unit>
        <trans-unit id="6408d526dcb04978c761f176b4b48253f6e2b3a3" translate="yes" xml:space="preserve">
          <source>TryLockError::borrow</source>
          <target state="translated">TryLockError::borrow</target>
        </trans-unit>
        <trans-unit id="c1162b670a7e56c24667fd355cb74c01579b66f6" translate="yes" xml:space="preserve">
          <source>TryLockError::borrow_mut</source>
          <target state="translated">TryLockError::borrow_mut</target>
        </trans-unit>
        <trans-unit id="645caaf83340c9e36066d5283df40d2289f0c56a" translate="yes" xml:space="preserve">
          <source>TryLockError::cause</source>
          <target state="translated">TryLockError::cause</target>
        </trans-unit>
        <trans-unit id="edc35be2771c53d502f5e8aaee878dd2e15d3b5a" translate="yes" xml:space="preserve">
          <source>TryLockError::description</source>
          <target state="translated">TryLockError::description</target>
        </trans-unit>
        <trans-unit id="c6f2c000c844249e646527b009bb44e488eef5e5" translate="yes" xml:space="preserve">
          <source>TryLockError::fmt</source>
          <target state="translated">TryLockError::fmt</target>
        </trans-unit>
        <trans-unit id="9001bf82d878e70373f04e6654b0f776179b2f53" translate="yes" xml:space="preserve">
          <source>TryLockError::from</source>
          <target state="translated">TryLockError::from</target>
        </trans-unit>
        <trans-unit id="655a2e7bdf752d14f5354358dacab8b46b5c1b0d" translate="yes" xml:space="preserve">
          <source>TryLockError::into</source>
          <target state="translated">TryLockError::into</target>
        </trans-unit>
        <trans-unit id="e4ccb09bacf6984439f523c7aecac39df9844058" translate="yes" xml:space="preserve">
          <source>TryLockError::source</source>
          <target state="translated">TryLockError::source</target>
        </trans-unit>
        <trans-unit id="c61e09fc91fbcfa81bcf718beb714ea63719b4eb" translate="yes" xml:space="preserve">
          <source>TryLockError::to_string</source>
          <target state="translated">TryLockError::to_string</target>
        </trans-unit>
        <trans-unit id="ebcde8097671e82bd0e812397421ce3e5f83aa6a" translate="yes" xml:space="preserve">
          <source>TryLockError::try_from</source>
          <target state="translated">TryLockError::try_from</target>
        </trans-unit>
        <trans-unit id="7b92cc07d0ee9b28099cb947d6053805d66baac1" translate="yes" xml:space="preserve">
          <source>TryLockError::try_into</source>
          <target state="translated">TryLockError::try_into</target>
        </trans-unit>
        <trans-unit id="904eaeeceb270dd726f594af3ac7324866060774" translate="yes" xml:space="preserve">
          <source>TryLockError::type_id</source>
          <target state="translated">TryLockError::type_id</target>
        </trans-unit>
        <trans-unit id="7d779fd6e34ddc3c9ecd145e12eaab2707fb88f2" translate="yes" xml:space="preserve">
          <source>TryLockResult</source>
          <target state="translated">TryLockResult</target>
        </trans-unit>
        <trans-unit id="b00cb1382a524b91c7b6f872f909018a2ba2fcdb" translate="yes" xml:space="preserve">
          <source>TryRecvError</source>
          <target state="translated">TryRecvError</target>
        </trans-unit>
        <trans-unit id="ffa19b2195d0c15e9339c99460878fe4f010d76d" translate="yes" xml:space="preserve">
          <source>TryReserveError</source>
          <target state="translated">TryReserveError</target>
        </trans-unit>
        <trans-unit id="7b782adc98cd68cba60f49733fd7fc4e8ce78c2c" translate="yes" xml:space="preserve">
          <source>TrySendError</source>
          <target state="translated">TrySendError</target>
        </trans-unit>
        <trans-unit id="bb111acc067364e9c3571b77d0ce5c4a9c6b3124" translate="yes" xml:space="preserve">
          <source>Trying to implement this scenario using our definition of &lt;code&gt;List&lt;/code&gt; with &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; won&amp;rsquo;t work, as shown in Listing 15-17:</source>
          <target state="translated">Попытка реализовать этот сценарий с использованием нашего определения &lt;code&gt;List&lt;/code&gt; с &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; не будет работать, как показано в Листинге 15-17:</target>
        </trans-unit>
        <trans-unit id="c41a2be51027c17da2914785c19c9af65da7231f" translate="yes" xml:space="preserve">
          <source>Tuple</source>
          <target state="translated">Tuple</target>
        </trans-unit>
        <trans-unit id="5518f0873d902287241e5e83188a303861d5a9e6" translate="yes" xml:space="preserve">
          <source>Tuple Layout</source>
          <target state="translated">Макет кортежа</target>
        </trans-unit>
        <trans-unit id="11dd41e6851bdf449646a773272c37c50a284fc9" translate="yes" xml:space="preserve">
          <source>Tuple and tuple indexing expressions</source>
          <target state="translated">Выражения индексации кортежа и кортежа</target>
        </trans-unit>
        <trans-unit id="6bdf2a89da03771b9bc590f650c8c5b6c77c5197" translate="yes" xml:space="preserve">
          <source>Tuple expression</source>
          <target state="translated">выражение кортежа</target>
        </trans-unit>
        <trans-unit id="a63a11d9cdfd9d84d9c0b5569d554b9e83dcf1cc" translate="yes" xml:space="preserve">
          <source>Tuple expression attributes</source>
          <target state="translated">атрибуты выражения кортежа</target>
        </trans-unit>
        <trans-unit id="e822aa7ad790f9164d76dd24bd82039b2ac65758" translate="yes" xml:space="preserve">
          <source>Tuple expressions</source>
          <target state="translated">Кортежи</target>
        </trans-unit>
        <trans-unit id="f601e94cafc9d12d8593dd02c6d703d40de35c4d" translate="yes" xml:space="preserve">
          <source>Tuple index</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fe6c1f43b44b32fa35dca7937a6775d19792506c" translate="yes" xml:space="preserve">
          <source>Tuple indexing</source>
          <target state="translated">индексирование кортежей</target>
        </trans-unit>
        <trans-unit id="44dc4b3b01b16ad2661df0966d7c7a1cf905b8b9" translate="yes" xml:space="preserve">
          <source>Tuple indexing expressions</source>
          <target state="translated">Выражения индексирования кортежей</target>
        </trans-unit>
        <trans-unit id="b8a1d058f14f452a93d10da089ec69f4c32d794e" translate="yes" xml:space="preserve">
          <source>Tuple indices are compared with the literal token directly. Tuple indices start with &lt;code&gt;0&lt;/code&gt; and each successive index increments the value by &lt;code&gt;1&lt;/code&gt; as a decimal value. Thus, only decimal values will match, and the value must not have any extra &lt;code&gt;0&lt;/code&gt; prefix characters.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f28c59e960977888e94a3c34b0278e6e00c6936d" translate="yes" xml:space="preserve">
          <source>Tuple patterns</source>
          <target state="translated">Образцы кортежей</target>
        </trans-unit>
        <trans-unit id="49d48b16cda97c82ccd41f82c8b675a2db8b4116" translate="yes" xml:space="preserve">
          <source>Tuple patterns match tuple values that match all criteria defined by its subpatterns. They are also used to &lt;a href=&quot;#destructuring&quot;&gt;destructure&lt;/a&gt; a tuple.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0d60a4a77a7ad9b86665dc5ec42ea14f2698ee75" translate="yes" xml:space="preserve">
          <source>Tuple patterns match tuple values that match all criteria defined by its subpatterns. They are also used to &lt;a href=&quot;patterns#destructuring&quot;&gt;destructure&lt;/a&gt; a tuple.</source>
          <target state="translated">Шаблоны кортежей соответствуют значениям кортежей, которые соответствуют всем критериям, определенным его подшаблонами. Они также используются для &lt;a href=&quot;patterns#destructuring&quot;&gt;разрушения&lt;/a&gt; кортежа.</target>
        </trans-unit>
        <trans-unit id="f4691e7b0b597791c415f166cd1397c0daec1163" translate="yes" xml:space="preserve">
          <source>Tuple struct expression</source>
          <target state="translated">выражение структуры кортежа</target>
        </trans-unit>
        <trans-unit id="ea9f0838dcbcc88a01e222d90f53e8f39880136f" translate="yes" xml:space="preserve">
          <source>Tuple struct patterns</source>
          <target state="translated">Структура кортежа</target>
        </trans-unit>
        <trans-unit id="91a08356932d9cf1d09320f96dfca3ba26d2fc8a" translate="yes" xml:space="preserve">
          <source>Tuple struct patterns match tuple struct and enum values that match all criteria defined by its subpatterns. They are also used to &lt;a href=&quot;#destructuring&quot;&gt;destructure&lt;/a&gt; a tuple struct or enum value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6ce23bf97599891184ee6af65a034650dc03427a" translate="yes" xml:space="preserve">
          <source>Tuple struct patterns match tuple struct and enum values that match all criteria defined by its subpatterns. They are also used to &lt;a href=&quot;patterns#destructuring&quot;&gt;destructure&lt;/a&gt; a tuple struct or enum value.</source>
          <target state="translated">Шаблоны структуры кортежа соответствуют значениям структуры кортежа и перечисления, которые соответствуют всем критериям, определенным его подшаблонами. Они также используются для &lt;a href=&quot;patterns#destructuring&quot;&gt;разрушения&lt;/a&gt; структуры кортежа или значения перечисления.</target>
        </trans-unit>
        <trans-unit id="dd28158a620f360ba4aa0c759eb104e4dede6329" translate="yes" xml:space="preserve">
          <source>Tuple structs are instantiated in the same way as tuples themselves, except with the struct's name as a prefix: &lt;code&gt;Foo(123, false, 0.1)&lt;/code&gt;.</source>
          <target state="translated">Структуры кортежей создаются так же, как и сами кортежи, за исключением того, что имя структуры используется в качестве префикса: &lt;code&gt;Foo(123, false, 0.1)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="985c4283e220405d4d0ac504a38671b8b680d3c5" translate="yes" xml:space="preserve">
          <source>Tuple structs are similar to regular structs, but its fields have no names. They are used like tuples, with deconstruction possible via &lt;code&gt;let TupleStruct(x, y) = foo;&lt;/code&gt; syntax. For accessing individual variables, the same syntax is used as with regular tuples, namely &lt;code&gt;foo.0&lt;/code&gt;, &lt;code&gt;foo.1&lt;/code&gt;, etc, starting at zero.</source>
          <target state="translated">Кортежные структуры похожи на обычные структуры, но их поля не имеют имен. Они используются как кортежи, с возможностью деконструкции через &lt;code&gt;let TupleStruct(x, y) = foo;&lt;/code&gt; синтаксис. Для доступа к отдельным переменным используется тот же синтаксис, что и для обычных кортежей, а именно &lt;code&gt;foo.0&lt;/code&gt; , &lt;code&gt;foo.1&lt;/code&gt; и т.д., начиная с нуля.</target>
        </trans-unit>
        <trans-unit id="405d7b4bc4604c6657b54f4846e0560006e9fc0e" translate="yes" xml:space="preserve">
          <source>Tuple type</source>
          <target state="translated">тип кортежа</target>
        </trans-unit>
        <trans-unit id="5501f69a4f42fb8e135b4df10c2273778be704fd" translate="yes" xml:space="preserve">
          <source>Tuple types</source>
          <target state="translated">типы кортежей</target>
        </trans-unit>
        <trans-unit id="5e273646744d8620cb13d8fba10b333bc84bed1e" translate="yes" xml:space="preserve">
          <source>Tuple types and values are denoted by listing the types or values of their elements, respectively, in a parenthesized, comma-separated list.</source>
          <target state="translated">Типы кортежей и значения обозначаются перечислением типов или значений их элементов,соответственно,в списке,разделенном скобками и запятыми.</target>
        </trans-unit>
        <trans-unit id="3fbd57dd63bac7c82834159ddc9ea56e1515ece9" translate="yes" xml:space="preserve">
          <source>Tuple types, if each component also implements &lt;code&gt;Clone&lt;/code&gt; (e.g., &lt;code&gt;()&lt;/code&gt;, &lt;code&gt;(i32, bool)&lt;/code&gt;)</source>
          <target state="translated">Типы кортежей, если каждый компонент также реализует &lt;code&gt;Clone&lt;/code&gt; (например, &lt;code&gt;()&lt;/code&gt; , &lt;code&gt;(i32, bool)&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="bd89c408cfdec88fd6d8e898f3566b701ea35d3a" translate="yes" xml:space="preserve">
          <source>Tuple types, if each component also implements &lt;code&gt;Copy&lt;/code&gt; (e.g., &lt;code&gt;()&lt;/code&gt;, &lt;code&gt;(i32, bool)&lt;/code&gt;)</source>
          <target state="translated">Типы кортежей, если каждый компонент также реализует &lt;code&gt;Copy&lt;/code&gt; (например, &lt;code&gt;()&lt;/code&gt; , &lt;code&gt;(i32, bool)&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="56d624bd930abb83c2a720d48bf858a7d49eb690" translate="yes" xml:space="preserve">
          <source>Tuples are &lt;em&gt;finite&lt;/em&gt;. In other words, a tuple has a length. Here's a tuple of length &lt;code&gt;3&lt;/code&gt;:</source>
          <target state="translated">Кортежи &lt;em&gt;конечны&lt;/em&gt; . Другими словами, кортеж имеет длину. Вот кортеж длиной &lt;code&gt;3&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="4da05b6b2dc1fb19e334d246d97430b523feb378" translate="yes" xml:space="preserve">
          <source>Tuples are &lt;em&gt;heterogeneous&lt;/em&gt;. This means that each element of the tuple can have a different type. In that tuple above, it has the type:</source>
          <target state="translated">Кортежи &lt;em&gt;неоднородны&lt;/em&gt; . Это означает, что каждый элемент кортежа может иметь разный тип. В приведенном выше кортеже он имеет тип:</target>
        </trans-unit>
        <trans-unit id="567f8079007690271f5a29cda47d067992841b99" translate="yes" xml:space="preserve">
          <source>Tuples are a &lt;em&gt;sequence&lt;/em&gt;. This means that they can be accessed by position; this is called 'tuple indexing', and it looks like this:</source>
          <target state="translated">Кортежи - это &lt;em&gt;последовательность&lt;/em&gt; . Это означает, что к ним можно получить доступ по позиции; это называется &amp;laquo;индексацией кортежей&amp;raquo;, и выглядит это так:</target>
        </trans-unit>
        <trans-unit id="e91ee0fad8731c0386a059fa3bf0652dd08c64d3" translate="yes" xml:space="preserve">
          <source>Tuples are often used as a return type when you want to return more than one value:</source>
          <target state="translated">Кортежи часто используются в качестве типа возврата,когда необходимо вернуть более одного значения:</target>
        </trans-unit>
        <trans-unit id="d7ee3ba750e08e0013c45b2b001ce78e8459fa90" translate="yes" xml:space="preserve">
          <source>Tuples are written by enclosing zero or more comma-separated expressions in parentheses. They are used to create &lt;a href=&quot;../types/tuple&quot;&gt;tuple-typed&lt;/a&gt; values.</source>
          <target state="translated">Кортежи записываются заключением в скобки нуля или нескольких выражений, разделенных запятыми. Они используются для создания значений &lt;a href=&quot;../types/tuple&quot;&gt;кортежного типа&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="5fb8ee22cf29120bf8f87bd0e3ee7ebd9949b96b" translate="yes" xml:space="preserve">
          <source>Tuples do not have any guarantees about their layout.</source>
          <target state="translated">Кортежи не имеют никаких гарантий относительно их компоновки.</target>
        </trans-unit>
        <trans-unit id="cf3ce6296bd35ecede807c2ca855fee144afacb9" translate="yes" xml:space="preserve">
          <source>Tuples, if they only contain types that are also &lt;code&gt;Copy&lt;/code&gt;. For example, &lt;code&gt;(i32, i32)&lt;/code&gt; is &lt;code&gt;Copy&lt;/code&gt;, but &lt;code&gt;(i32, String)&lt;/code&gt; is not.</source>
          <target state="translated">Кортежи, если они содержат только типы, которые также являются &lt;code&gt;Copy&lt;/code&gt; . Например, &lt;code&gt;(i32, i32)&lt;/code&gt; - это &lt;code&gt;Copy&lt;/code&gt; , а &lt;code&gt;(i32, String)&lt;/code&gt; - нет.</target>
        </trans-unit>
        <trans-unit id="f9c67af2890eabc2460069a200a1d4229437528f" translate="yes" xml:space="preserve">
          <source>Tuples, where a tuple is a coercion site to type &lt;code&gt;(U_0, U_1, ..., U_n)&lt;/code&gt;. Each sub-expression is a coercion site to the respective type, e.g. the zeroth sub-expression is a coercion site to type &lt;code&gt;U_0&lt;/code&gt;.</source>
          <target state="translated">Кортежи, где кортеж - это сайт принуждения для ввода &lt;code&gt;(U_0, U_1, ..., U_n)&lt;/code&gt; . Каждое подвыражение является сайтом приведения к соответствующему типу, например, нулевое подвыражение является сайтом принуждения к типу &lt;code&gt;U_0&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c9853aa9de5add5fa51a4530e193cc7279fd6159" translate="yes" xml:space="preserve">
          <source>Turn a &lt;a href=&quot;../../vec/struct.vec&quot;&gt;&lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt; into a &lt;a href=&quot;../struct.vecdeque&quot;&gt;&lt;code&gt;VecDeque&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e89ab8db9a13e916878d1aff18816e183dfae8d6" translate="yes" xml:space="preserve">
          <source>Turn a &lt;a href=&quot;../collections/struct.vecdeque&quot;&gt;&lt;code&gt;VecDeque&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt; into a &lt;a href=&quot;../vec/struct.vec&quot;&gt;&lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e7311ea0eb58a505bdf5f01b88b3339c4b7cd8b3" translate="yes" xml:space="preserve">
          <source>Turn a &lt;a href=&quot;../collections/struct.vecdeque&quot;&gt;&lt;code&gt;VecDeque&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt; into a &lt;a href=&quot;struct.vec&quot;&gt;&lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2b38a71dfcaefc79a39b01d00754205648079aa2" translate="yes" xml:space="preserve">
          <source>Turn a &lt;a href=&quot;../struct.vecdeque&quot;&gt;&lt;code&gt;VecDeque&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt; into a &lt;a href=&quot;../../vec/struct.vec&quot;&gt;&lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6fe97f664cc043b9cae686cc00711fc73ef1df08" translate="yes" xml:space="preserve">
          <source>Turn a &lt;a href=&quot;../vec/struct.vec&quot;&gt;&lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt; into a &lt;a href=&quot;../collections/struct.vecdeque&quot;&gt;&lt;code&gt;VecDeque&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3fbea64da5a5f06d75e0a8af0090b3b0e2a08380" translate="yes" xml:space="preserve">
          <source>Turn a &lt;a href=&quot;../vec/struct.vec&quot;&gt;&lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt; into a &lt;a href=&quot;struct.vecdeque&quot;&gt;&lt;code&gt;VecDeque&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4669fd8f77a02ec1c266c7fe545791bb7885dad1" translate="yes" xml:space="preserve">
          <source>Turn a &lt;a href=&quot;struct.vec&quot;&gt;&lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt; into a &lt;a href=&quot;../collections/struct.vecdeque&quot;&gt;&lt;code&gt;VecDeque&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b09625451991a5b8e805da34776aaedc90525fbd" translate="yes" xml:space="preserve">
          <source>Turn a &lt;a href=&quot;struct.vecdeque&quot;&gt;&lt;code&gt;VecDeque&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt; into a &lt;a href=&quot;../vec/struct.vec&quot;&gt;&lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="54437abef1f3840afb67899d2d515749e44d9fef" translate="yes" xml:space="preserve">
          <source>Turn a [&lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt;] into a [&lt;code&gt;VecDeque&amp;lt;T&amp;gt;&lt;/code&gt;].</source>
          <target state="translated">Превратите [ &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; ] в [ &lt;code&gt;VecDeque&amp;lt;T&amp;gt;&lt;/code&gt; ].</target>
        </trans-unit>
        <trans-unit id="e6b58be63cc031a2c0fb9a41ef4a5c4c544f30d9" translate="yes" xml:space="preserve">
          <source>Turn a [&lt;code&gt;VecDeque&amp;lt;T&amp;gt;&lt;/code&gt;] into a [&lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt;].</source>
          <target state="translated">Превратите [ &lt;code&gt;VecDeque&amp;lt;T&amp;gt;&lt;/code&gt; ] в [ &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; ].</target>
        </trans-unit>
        <trans-unit id="68fccb5986b95d1769fe3ac2f5db1e4528fbe17a" translate="yes" xml:space="preserve">
          <source>Turning Our Single-Threaded Server into a Multithreaded Server</source>
          <target state="translated">Превращение нашего однопоточного сервера в многопоточный.</target>
        </trans-unit>
        <trans-unit id="b859b7ff96007e824952102a2b6cf7f2532bb6f5" translate="yes" xml:space="preserve">
          <source>Turning a &lt;code&gt;*mut T&lt;/code&gt; into an &lt;code&gt;&amp;amp;mut T&lt;/code&gt;:</source>
          <target state="translated">Превращение &lt;code&gt;*mut T&lt;/code&gt; в &lt;code&gt;&amp;amp;mut T&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="92f32c54d91cd32dab86c92433ff5bf59fbe670a" translate="yes" xml:space="preserve">
          <source>Turning a &lt;code&gt;Vec&amp;lt;&amp;amp;T&amp;gt;&lt;/code&gt; into a &lt;code&gt;Vec&amp;lt;Option&amp;lt;&amp;amp;T&amp;gt;&amp;gt;&lt;/code&gt;:</source>
          <target state="translated">Превращение &lt;code&gt;Vec&amp;lt;&amp;amp;T&amp;gt;&lt;/code&gt; в &lt;code&gt;Vec&amp;lt;Option&amp;lt;&amp;amp;T&amp;gt;&amp;gt;&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="ddddd1c6a422bfc2e73b1e1e06d4513f4b671ef3" translate="yes" xml:space="preserve">
          <source>Turning a pointer into a &lt;code&gt;usize&lt;/code&gt;:</source>
          <target state="translated">Превращаем указатель в &lt;code&gt;usize&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="0cfcb75a89ff8f3d42e0969a81b68c58ff41ffed" translate="yes" xml:space="preserve">
          <source>Turning a pointer into a function pointer. This is &lt;em&gt;not&lt;/em&gt; portable to machines where function pointers and data pointers have different sizes.</source>
          <target state="translated">Превращение указателя в указатель функции. Это &lt;em&gt;не&lt;/em&gt; переносимо на машины, на которых указатели функций и указатели данных имеют разные размеры.</target>
        </trans-unit>
        <trans-unit id="406e60e2392b6e162c75155bdd0eec0802166101" translate="yes" xml:space="preserve">
          <source>Turning an &lt;code&gt;&amp;amp;mut T&lt;/code&gt; into an &lt;code&gt;&amp;amp;mut U&lt;/code&gt;:</source>
          <target state="translated">Превращение &lt;code&gt;&amp;amp;mut T&lt;/code&gt; в &lt;code&gt;&amp;amp;mut U&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="b7709a825d906324651f42904d312bfc3d9cfdce" translate="yes" xml:space="preserve">
          <source>Turning an &lt;code&gt;&amp;amp;str&lt;/code&gt; into an &lt;code&gt;&amp;amp;[u8]&lt;/code&gt;:</source>
          <target state="translated">Превращаем &lt;code&gt;&amp;amp;str&lt;/code&gt; в &lt;code&gt;&amp;amp;[u8]&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="8fe665706a3a9d23c3f80f786fb6f659e7dafb3b" translate="yes" xml:space="preserve">
          <source>Turning raw bytes(&lt;code&gt;&amp;amp;[u8]&lt;/code&gt;) to &lt;code&gt;u32&lt;/code&gt;, &lt;code&gt;f64&lt;/code&gt;, etc.:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="45cfabf1744551752d0d316f8226b7949182c80d" translate="yes" xml:space="preserve">
          <source>Two &lt;code&gt;Arc&lt;/code&gt;s are equal if their inner values are equal, even if they are stored in different allocation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1e4a5ffe0d58bc942e71a31a403ac137dbf193dd" translate="yes" xml:space="preserve">
          <source>Two &lt;code&gt;Arc&lt;/code&gt;s are equal if their inner values are equal.</source>
          <target state="translated">Две &lt;code&gt;Arc&lt;/code&gt; равны, если их внутренние значения равны.</target>
        </trans-unit>
        <trans-unit id="3b0340dc9882895d2ed9f18ec41d4ee9ceaf4e0c" translate="yes" xml:space="preserve">
          <source>Two &lt;code&gt;Arc&lt;/code&gt;s are unequal if their inner values are unequal.</source>
          <target state="translated">Две &lt;code&gt;Arc&lt;/code&gt; равны, если их внутренние значения не равны.</target>
        </trans-unit>
        <trans-unit id="77c963714f423503919254b2ffd83b6fa90a298e" translate="yes" xml:space="preserve">
          <source>Two &lt;code&gt;Rc&lt;/code&gt;s are equal if their inner values are equal, even if they are stored in different allocation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d6a2d18514777aaae37a7ce067b908310bbd6b4b" translate="yes" xml:space="preserve">
          <source>Two &lt;code&gt;Rc&lt;/code&gt;s are equal if their inner values are equal.</source>
          <target state="translated">Два &lt;code&gt;Rc&lt;/code&gt; равны, если их внутренние значения равны.</target>
        </trans-unit>
        <trans-unit id="2fa5c112e4e91cdb91570c34d930cf27ff1cdefa" translate="yes" xml:space="preserve">
          <source>Two &lt;code&gt;Rc&lt;/code&gt;s are unequal if their inner values are unequal.</source>
          <target state="translated">Два &lt;code&gt;Rc&lt;/code&gt; не равны, если их внутренние значения не равны.</target>
        </trans-unit>
        <trans-unit id="2b4b2f527e82e5d4b1ed0e9743d509787616d686" translate="yes" xml:space="preserve">
          <source>Two associated items (like methods, associated types, associated functions, etc.) were defined with the same identifier.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="026acb3ca4aa61acf271a2918c10ebc97e741248" translate="yes" xml:space="preserve">
          <source>Two examples of simple paths consisting of only identifier segments:</source>
          <target state="translated">Два примера простых путей,состоящих только из идентификационных сегментов:</target>
        </trans-unit>
        <trans-unit id="0cd83d672a615733082e8ee7f56c39b0af561a3e" translate="yes" xml:space="preserve">
          <source>Two items of the same name cannot be imported without rebinding one of the items under a new local name.</source>
          <target state="translated">Два одноименных предмета не могут быть импортированы без перепривязки одного из предметов под новым местным названием.</target>
        </trans-unit>
        <trans-unit id="cbb02c3e2b1b62256b2dccb2ec1aec1fddd7391c" translate="yes" xml:space="preserve">
          <source>Two kind of item &lt;em&gt;declarations&lt;/em&gt; are allowed in external blocks: &lt;a href=&quot;functions&quot;&gt;functions&lt;/a&gt; and &lt;a href=&quot;static-items&quot;&gt;statics&lt;/a&gt;. Calling functions or accessing statics that are declared in external blocks is only allowed in an &lt;code&gt;unsafe&lt;/code&gt; context.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f6d0f0b6138243f294ae08264cc55ed1bd1ca167" translate="yes" xml:space="preserve">
          <source>Two lifetimes cannot have the same name. To fix this example, change the second &lt;code&gt;'a&lt;/code&gt; lifetime into something else (&lt;code&gt;'c&lt;/code&gt; for example):</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="30c944c513e67b8c4ff5047db8e7ab8f3c379bad" translate="yes" xml:space="preserve">
          <source>Two or more pointers access the same data at the same time.</source>
          <target state="translated">Два или более указателей получают доступ к одним и тем же данным одновременно.</target>
        </trans-unit>
        <trans-unit id="ea818e0ad4fe2dcf3d6dd4c02bacf808745d38d6" translate="yes" xml:space="preserve">
          <source>Two possibilities are available to solve this issue:</source>
          <target state="translated">Для решения этого вопроса существует два варианта:</target>
        </trans-unit>
        <trans-unit id="9e61db6f0549ccd99ae56429864c2f4cbe98bb50" translate="yes" xml:space="preserve">
          <source>Two such examples are macros and &lt;code&gt;#[cfg]&lt;/code&gt; environments.</source>
          <target state="translated">Двумя такими примерами являются макросы и среды &lt;code&gt;#[cfg]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9d8a406e3a91b6f18f7fee9fffccd411cd7bea0e" translate="yes" xml:space="preserve">
          <source>Two tests that pass! Now let&amp;rsquo;s see what happens to our test results when we introduce a bug in our code. Let&amp;rsquo;s change the implementation of the &lt;code&gt;can_hold&lt;/code&gt; method by replacing the greater than sign with a less than sign when it compares the widths:</source>
          <target state="translated">Два успешно пройденных теста! Теперь давайте посмотрим, что произойдет с результатами наших тестов, когда мы введем ошибку в наш код. Давайте изменим реализацию метода &lt;code&gt;can_hold&lt;/code&gt; , заменив знак &amp;laquo;больше&amp;raquo; на знак &amp;laquo;меньше&amp;raquo; при сравнении ширины:</target>
        </trans-unit>
        <trans-unit id="6831c93d3c0041ecff78583892f51cefdc18f74a" translate="yes" xml:space="preserve">
          <source>Two things are important to note about this function:</source>
          <target state="translated">Две вещи очень важны для этой функции:</target>
        </trans-unit>
        <trans-unit id="d73651bf2df8af467f41b29a872952ef24a40245" translate="yes" xml:space="preserve">
          <source>Two trait implementations overlap when there is a non-empty intersection of the traits the implementation is for, the implementations can be instantiated with the same type.</source>
          <target state="translated">Две реализации трейтов накладываются друг на друга при наличии непустого пересечения трейтов,для которых реализация предназначена,реализации могут быть инстанциированы одним и тем же типом.</target>
        </trans-unit>
        <trans-unit id="45049ec7ea97abec9bd8269a665797ccca478bf9" translate="yes" xml:space="preserve">
          <source>Two trait object types alias each other if the base traits alias each other and if the sets of auto traits are the same and the lifetime bounds are the same. For example, &lt;code&gt;dyn Trait + Send + UnwindSafe&lt;/code&gt; is the same as &lt;code&gt;dyn Trait + UnwindSafe + Send&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7b6094fd54b67e7d276ce315b3b79ffc2dd18ae2" translate="yes" xml:space="preserve">
          <source>Two trait object types alias each other if the base traits alias each other and if the sets of auto traits are the same and the lifetime bounds are the same. For example, &lt;code&gt;dyn Trait + Send + UnwindSafe&lt;/code&gt; is the same as &lt;code&gt;dyn Trait + Unwindsafe + Send&lt;/code&gt;.</source>
          <target state="translated">Два типа объектов-признаков являются псевдонимами друг друга, если базовые характеристики являются псевдонимами друг друга и если наборы автоматических свойств совпадают и границы времени жизни одинаковы. Например, &lt;code&gt;dyn Trait + Send + UnwindSafe&lt;/code&gt; совпадает с &lt;code&gt;dyn Trait + Unwindsafe + Send&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0d078a0dedfa986439265f5fefabc817ba279445" translate="yes" xml:space="preserve">
          <source>Two traits, &lt;a href=&quot;../std/marker/trait.unsize&quot;&gt;&lt;code&gt;Unsize&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../std/ops/trait.coerceunsized&quot;&gt;&lt;code&gt;CoerceUnsized&lt;/code&gt;&lt;/a&gt;, are used to assist in this process and expose it for library use. The following coercions are built-ins and, if &lt;code&gt;T&lt;/code&gt; can be coerced to &lt;code&gt;U&lt;/code&gt; with one of them, then an implementation of &lt;code&gt;Unsize&amp;lt;U&amp;gt;&lt;/code&gt; for &lt;code&gt;T&lt;/code&gt; will be provided:</source>
          <target state="translated">Два &lt;a href=&quot;../std/marker/trait.unsize&quot;&gt; &lt;code&gt;Unsize&lt;/code&gt; &lt;/a&gt; , Unsize и &lt;a href=&quot;../std/ops/trait.coerceunsized&quot;&gt; &lt;code&gt;CoerceUnsized&lt;/code&gt; &lt;/a&gt; , используются, чтобы помочь в этом процессе и предоставить его для использования библиотекой. Следующие приведения являются встроенными, и, если &lt;code&gt;T&lt;/code&gt; может быть приведен к &lt;code&gt;U&lt;/code&gt; с помощью одного из них, то будет предоставлена ​​реализация &lt;code&gt;Unsize&amp;lt;U&amp;gt;&lt;/code&gt; для &lt;code&gt;T&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="0c40881391e5533daaab739e69ccda2bb7bda270" translate="yes" xml:space="preserve">
          <source>TyCtor(&lt;code&gt;T&lt;/code&gt;) to TyCtor(&lt;code&gt;U&lt;/code&gt;), where TyCtor(&lt;code&gt;T&lt;/code&gt;) is one of</source>
          <target state="translated">TyCtor ( &lt;code&gt;T&lt;/code&gt; ) в TyCtor ( &lt;code&gt;U&lt;/code&gt; ), где TyCtor ( &lt;code&gt;T&lt;/code&gt; ) - один из</target>
        </trans-unit>
        <trans-unit id="3deb7456519697ecf4eefc455516c969a3681bae" translate="yes" xml:space="preserve">
          <source>Type</source>
          <target state="translated">Type</target>
        </trans-unit>
        <trans-unit id="8893ac4ddfe0ea4688a44afc0ddfe4ebc76a84ef" translate="yes" xml:space="preserve">
          <source>Type &lt;a href=&quot;enum.option&quot;&gt;&lt;code&gt;Option&lt;/code&gt;&lt;/a&gt; represents an optional value: every &lt;a href=&quot;enum.option&quot;&gt;&lt;code&gt;Option&lt;/code&gt;&lt;/a&gt; is either &lt;a href=&quot;enum.option#variant.Some&quot;&gt;&lt;code&gt;Some&lt;/code&gt;&lt;/a&gt; and contains a value, or &lt;a href=&quot;enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt;, and does not. &lt;a href=&quot;enum.option&quot;&gt;&lt;code&gt;Option&lt;/code&gt;&lt;/a&gt; types are very common in Rust code, as they have a number of uses:</source>
          <target state="translated">Тип &lt;a href=&quot;enum.option&quot;&gt; &lt;code&gt;Option&lt;/code&gt; &lt;/a&gt; представляет необязательное значение: каждый &lt;a href=&quot;enum.option&quot;&gt; &lt;code&gt;Option&lt;/code&gt; &lt;/a&gt; имеет значение &lt;a href=&quot;enum.option#variant.Some&quot;&gt; &lt;code&gt;Some&lt;/code&gt; &lt;/a&gt; и содержит значение или &lt;a href=&quot;enum.option#variant.None&quot;&gt; &lt;code&gt;None&lt;/code&gt; &lt;/a&gt; , но не содержит. Типы &lt;a href=&quot;enum.option&quot;&gt; &lt;code&gt;Option&lt;/code&gt; &lt;/a&gt; очень распространены в коде Rust, так как они имеют ряд применений:</target>
        </trans-unit>
        <trans-unit id="5a34cc9264aacb6462265b18d25bcf726faf398f" translate="yes" xml:space="preserve">
          <source>Type Definition std::fmt::Result</source>
          <target state="translated">Определение типа std::fmt::Результат</target>
        </trans-unit>
        <trans-unit id="34dd3e846f6d75301a90ce0c190a60bbb2f75015" translate="yes" xml:space="preserve">
          <source>Type Definition std::io::Result</source>
          <target state="translated">Тип Определение std::io::Результат</target>
        </trans-unit>
        <trans-unit id="46f6920a49ecfbe5727cafe69a86a93c6dc323b4" translate="yes" xml:space="preserve">
          <source>Type Definition std::os::linux::raw::blkcnt_t</source>
          <target state="translated">Тип Определение std::os::linux::raw::blkcnt_t</target>
        </trans-unit>
        <trans-unit id="85fbcc37c53b78d2794e588bd5f55d25d53b121b" translate="yes" xml:space="preserve">
          <source>Type Definition std::os::linux::raw::blksize_t</source>
          <target state="translated">Тип Определение std::os::linux::raw::blksize_t</target>
        </trans-unit>
        <trans-unit id="e2606fd8324f1985d42d98f82ef97532070eae3e" translate="yes" xml:space="preserve">
          <source>Type Definition std::os::linux::raw::dev_t</source>
          <target state="translated">Тип Определение std::os::linux::raw::dev_t</target>
        </trans-unit>
        <trans-unit id="1a0725c0d449cfcc82b033154c822ab6aa94cb70" translate="yes" xml:space="preserve">
          <source>Type Definition std::os::linux::raw::ino_t</source>
          <target state="translated">Тип Определение std::os::linux::raw::ino_t</target>
        </trans-unit>
        <trans-unit id="96a7fc18b0419da7fc9a515e767bed1bfbc9562c" translate="yes" xml:space="preserve">
          <source>Type Definition std::os::linux::raw::mode_t</source>
          <target state="translated">Тип Определение std::os::linux::raw::mode_t</target>
        </trans-unit>
        <trans-unit id="75a060e0f5140a7dabbcb1ba8000909c3c0378d8" translate="yes" xml:space="preserve">
          <source>Type Definition std::os::linux::raw::nlink_t</source>
          <target state="translated">Тип Определение std::os::linux::raw::nlink_t</target>
        </trans-unit>
        <trans-unit id="7ae7bb16976469a8ad4e67f2c0d76a2afe6847e7" translate="yes" xml:space="preserve">
          <source>Type Definition std::os::linux::raw::off_t</source>
          <target state="translated">Тип Определение std::os::linux::raw::off_t</target>
        </trans-unit>
        <trans-unit id="76556b9aa9b1d76aecac20fd90dee8158aed1fa4" translate="yes" xml:space="preserve">
          <source>Type Definition std::os::linux::raw::pthread_t</source>
          <target state="translated">Тип Определение std::os::linux::raw::pthread_t</target>
        </trans-unit>
        <trans-unit id="c8140af217e68caacdab8d2aaef2318b6e02ba66" translate="yes" xml:space="preserve">
          <source>Type Definition std::os::linux::raw::time_t</source>
          <target state="translated">Тип Определение std::os::linux::raw::time_t</target>
        </trans-unit>
        <trans-unit id="d80e70a5e9f44648db2fa12eba538e96a084706b" translate="yes" xml:space="preserve">
          <source>Type Definition std::os::raw::c_char</source>
          <target state="translated">Тип Определение std::os::raw::c_char</target>
        </trans-unit>
        <trans-unit id="47268ec268f5e51266c8c9b25e903a966387595d" translate="yes" xml:space="preserve">
          <source>Type Definition std::os::raw::c_double</source>
          <target state="translated">Тип Определение std::os::raw::c_double</target>
        </trans-unit>
        <trans-unit id="167acfa92657a06bc69cb3f91777f380110e4dc9" translate="yes" xml:space="preserve">
          <source>Type Definition std::os::raw::c_float</source>
          <target state="translated">Тип Определение std::os::raw::c_float</target>
        </trans-unit>
        <trans-unit id="c27fd9199e90c2472f965bdc0cca23d6c8c570f4" translate="yes" xml:space="preserve">
          <source>Type Definition std::os::raw::c_int</source>
          <target state="translated">Тип Определение std::os::raw::c_int</target>
        </trans-unit>
        <trans-unit id="19f693eccac3c497abf741d0f8baed1d19e53f4b" translate="yes" xml:space="preserve">
          <source>Type Definition std::os::raw::c_long</source>
          <target state="translated">Тип Определение std::os::raw::c_long</target>
        </trans-unit>
        <trans-unit id="8600d6f2d9a4b023e7037b70faa22dc15e66388f" translate="yes" xml:space="preserve">
          <source>Type Definition std::os::raw::c_longlong</source>
          <target state="translated">Тип Определение std::os::raw::c_longlong</target>
        </trans-unit>
        <trans-unit id="38fbb377e146c43dbf57e7ef0b9149de46dd63ee" translate="yes" xml:space="preserve">
          <source>Type Definition std::os::raw::c_schar</source>
          <target state="translated">Тип Определение std::os::raw::c_schar</target>
        </trans-unit>
        <trans-unit id="24f91247eef9f189a56e0d26eb63e94174545d18" translate="yes" xml:space="preserve">
          <source>Type Definition std::os::raw::c_short</source>
          <target state="translated">Тип Определение std::os::raw::c_short</target>
        </trans-unit>
        <trans-unit id="8fd264b0559dbbedb815b835dcd8dc23c60e3e46" translate="yes" xml:space="preserve">
          <source>Type Definition std::os::raw::c_uchar</source>
          <target state="translated">Тип Определение std::os::raw::c_uchar</target>
        </trans-unit>
        <trans-unit id="73ae8275dba1734adb8dd3eb79d165dfd8926f8e" translate="yes" xml:space="preserve">
          <source>Type Definition std::os::raw::c_uint</source>
          <target state="translated">Тип Определение std::os::raw::c_uint</target>
        </trans-unit>
        <trans-unit id="963d890a0fa816ac69f7b2a91122d42f47482af6" translate="yes" xml:space="preserve">
          <source>Type Definition std::os::raw::c_ulong</source>
          <target state="translated">Тип Определение std::os::raw::c_ulong</target>
        </trans-unit>
        <trans-unit id="9529b81e31c700d29c794b44439c31236befee6e" translate="yes" xml:space="preserve">
          <source>Type Definition std::os::raw::c_ulonglong</source>
          <target state="translated">Определение типа std::os::raw::c_ulonglong</target>
        </trans-unit>
        <trans-unit id="2add572706fcd5310850bb5c41c263a68becd701" translate="yes" xml:space="preserve">
          <source>Type Definition std::os::raw::c_ushort</source>
          <target state="translated">Тип Определение std::os::raw::c_ushort</target>
        </trans-unit>
        <trans-unit id="af576d5699684e5ccc6dd3bdda06f283b79646ba" translate="yes" xml:space="preserve">
          <source>Type Definition std::os::unix::io::RawFd</source>
          <target state="translated">Определение типа std::os::unix::io::RawFd</target>
        </trans-unit>
        <trans-unit id="54df1b972115ebdb7492ee1ec118ad059c5b96b9" translate="yes" xml:space="preserve">
          <source>Type Definition std::os::unix::raw::blkcnt_t</source>
          <target state="translated">Тип Определение std::os::unix::raw::blkcnt_t</target>
        </trans-unit>
        <trans-unit id="24cf96c7673dcafd447d654adb8e4cf01b30bb6f" translate="yes" xml:space="preserve">
          <source>Type Definition std::os::unix::raw::blksize_t</source>
          <target state="translated">Тип Определение std::os::unix::raw::blksize_t</target>
        </trans-unit>
        <trans-unit id="27da02afd4df0cefb0f36b07dc40fb05a497c94e" translate="yes" xml:space="preserve">
          <source>Type Definition std::os::unix::raw::dev_t</source>
          <target state="translated">Тип Определение std::os::unix::raw::dev_t</target>
        </trans-unit>
        <trans-unit id="73d1317f78cb687f50d63c8e6d4ee01bdba096f4" translate="yes" xml:space="preserve">
          <source>Type Definition std::os::unix::raw::gid_t</source>
          <target state="translated">Тип Определение std::os::unix::raw::gid_t</target>
        </trans-unit>
        <trans-unit id="f1c61da35b3b5a8948934b0c33b08607e17ab49a" translate="yes" xml:space="preserve">
          <source>Type Definition std::os::unix::raw::ino_t</source>
          <target state="translated">Тип Определение std::os::unix::raw::ino_t</target>
        </trans-unit>
        <trans-unit id="f57f89ce06fb76c13960558bcf6af72b48025b0a" translate="yes" xml:space="preserve">
          <source>Type Definition std::os::unix::raw::mode_t</source>
          <target state="translated">Тип Определение std::os::unix::raw::mode_t</target>
        </trans-unit>
        <trans-unit id="6efe4bc154c56731d72a72033b5e96f1e8e776fa" translate="yes" xml:space="preserve">
          <source>Type Definition std::os::unix::raw::nlink_t</source>
          <target state="translated">Тип Определение std::os::unix::raw::nlink_t</target>
        </trans-unit>
        <trans-unit id="16d41f66ea53de25694ff8008809453896212992" translate="yes" xml:space="preserve">
          <source>Type Definition std::os::unix::raw::off_t</source>
          <target state="translated">Тип Определение std::os::unix::raw::off_t</target>
        </trans-unit>
        <trans-unit id="7fcd1c7c7d47846aeea79e3b67b951552799ecac" translate="yes" xml:space="preserve">
          <source>Type Definition std::os::unix::raw::pid_t</source>
          <target state="translated">Тип Определение std::os::unix::raw::pid_t</target>
        </trans-unit>
        <trans-unit id="15394730cd6adf60683b03d0f547388ed732a617" translate="yes" xml:space="preserve">
          <source>Type Definition std::os::unix::raw::pthread_t</source>
          <target state="translated">Тип Определение std::os::unix::raw::pthread_t</target>
        </trans-unit>
        <trans-unit id="f5866aac0842b4a721a91364de015f0e36fbc706" translate="yes" xml:space="preserve">
          <source>Type Definition std::os::unix::raw::time_t</source>
          <target state="translated">Тип Определение std::os::unix::raw::time_t</target>
        </trans-unit>
        <trans-unit id="c10ba42310b44320213f70095552a73e406c10bc" translate="yes" xml:space="preserve">
          <source>Type Definition std::os::unix::raw::uid_t</source>
          <target state="translated">Тип Определение std::os::unix::raw::uid_t</target>
        </trans-unit>
        <trans-unit id="ccfd242450d8d8e764c541c183e48c95060db965" translate="yes" xml:space="preserve">
          <source>Type Definition std::os::unix::thread::RawPthread</source>
          <target state="translated">Определение типа std::os::unix::thread::RawPthread</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
