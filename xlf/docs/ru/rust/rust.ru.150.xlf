<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ru" datatype="htmlbody" original="rust">
    <body>
      <group id="rust">
        <trans-unit id="1fd449b5671c0c531048bf228bce50b5745274bb" translate="yes" xml:space="preserve">
          <source>The connection was aborted (terminated) by the remote server.</source>
          <target state="translated">Соединение было прервано (прервано)удаленным сервером.</target>
        </trans-unit>
        <trans-unit id="394cd4f1c44fd561007d2b956b477de854f22ebc" translate="yes" xml:space="preserve">
          <source>The connection was refused by the remote server.</source>
          <target state="translated">Соединение было прервано удаленным сервером.</target>
        </trans-unit>
        <trans-unit id="ee9eafc82d73396db6a743b750893f5328ee460c" translate="yes" xml:space="preserve">
          <source>The connection was reset by the remote server.</source>
          <target state="translated">Соединение было сброшено удаленным сервером.</target>
        </trans-unit>
        <trans-unit id="c5c0b8221782b43e8764b446a2f5d5156fcf8b34" translate="yes" xml:space="preserve">
          <source>The connection will be closed when the value is dropped. The reading and writing portions of the connection can also be shut down individually with the &lt;a href=&quot;#method.shutdown&quot;&gt;&lt;code&gt;shutdown&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">Соединение будет закрыто, когда значение будет сброшено. Части соединения для чтения и записи также могут быть отключены по отдельности с помощью метода &lt;a href=&quot;#method.shutdown&quot;&gt; &lt;code&gt;shutdown&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="ee6719cfaf61adca10461f2b171bde13e23a4a41" translate="yes" xml:space="preserve">
          <source>The connection will be closed when the value is dropped. The reading and writing portions of the connection can also be shut down individually with the &lt;a href=&quot;struct.tcpstream#method.shutdown&quot;&gt;&lt;code&gt;shutdown&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="98a1585e2f9a061b72de9d4f949a75a416a4fb56" translate="yes" xml:space="preserve">
          <source>The cons function concept has made its way into more general functional programming jargon: &amp;ldquo;to cons &lt;em&gt;x&lt;/em&gt; onto &lt;em&gt;y&lt;/em&gt;&amp;rdquo; informally means to construct a new container instance by putting the element &lt;em&gt;x&lt;/em&gt; at the start of this new container, followed by the container &lt;em&gt;y&lt;/em&gt;.</source>
          <target state="translated">Концепция функции cons перешла в более общий жаргон функционального программирования: &amp;laquo;преобразовать &lt;em&gt;x&lt;/em&gt; в &lt;em&gt;y&lt;/em&gt; &amp;raquo; неформально означает создать новый экземпляр контейнера, поместив элемент &lt;em&gt;x&lt;/em&gt; в начало этого нового контейнера, за которым следует контейнер &lt;em&gt;y&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="3946118b0e2f7f5ec1675cedbf82ccd7c8d576ce" translate="yes" xml:space="preserve">
          <source>The contents of &lt;em&gt;src/lib.rs&lt;/em&gt; should have the signatures shown in Listing 12-13 (we&amp;rsquo;ve omitted the bodies of the functions for brevity). Note that this won&amp;rsquo;t compile until we modify &lt;em&gt;src/main.rs&lt;/em&gt; in Listing 12-14.</source>
          <target state="translated">Содержимое &lt;em&gt;src / lib.rs&lt;/em&gt; должно иметь сигнатуры, показанные в листинге 12-13 (мы для краткости опускали тела функций). Обратите внимание, что это не будет компилироваться, пока мы не &lt;em&gt;изменим src / main.rs&lt;/em&gt; в листинге 12-14.</target>
        </trans-unit>
        <trans-unit id="4fb4cd20ff2b04a7f8f088847ce2546308d2b8ce" translate="yes" xml:space="preserve">
          <source>The contents of the &lt;em&gt;src/lib.rs&lt;/em&gt; file in your &lt;code&gt;adder&lt;/code&gt; library should look like Listing 11-1.</source>
          <target state="translated">Содержимое файла &lt;em&gt;src / lib.rs&lt;/em&gt; в вашей библиотеке &lt;code&gt;adder&lt;/code&gt; должно выглядеть как Листинг 11-1.</target>
        </trans-unit>
        <trans-unit id="1735f7c56c57e86fb0b029da9024a55f63cc6d92" translate="yes" xml:space="preserve">
          <source>The contents of the repetition must be able to follow whatever comes before, and whatever comes after must be able to follow the contents of the repetition.</source>
          <target state="translated">Содержание повторения должно быть в состоянии следовать тому,что приходит до,и тому,что приходит после,должно быть в состоянии следовать содержанию повторения.</target>
        </trans-unit>
        <trans-unit id="33e5fb5d650df50a2e77352564f0bccccceac217" translate="yes" xml:space="preserve">
          <source>The contents of the returned &lt;a href=&quot;../raw/struct.stat&quot;&gt;&lt;code&gt;stat&lt;/code&gt;&lt;/a&gt; are &lt;strong&gt;not&lt;/strong&gt; consistent across Unix platforms. The &lt;code&gt;os::unix::fs::MetadataExt&lt;/code&gt; trait contains the cross-Unix abstractions contained within the raw stat.</source>
          <target state="translated">Содержимое возвращенного &lt;a href=&quot;../raw/struct.stat&quot;&gt; &lt;code&gt;stat&lt;/code&gt; &lt;/a&gt; являются &lt;strong&gt;не&lt;/strong&gt; последовательно через Unix платформах. &lt;code&gt;os::unix::fs::MetadataExt&lt;/code&gt; признак содержит абстракции кросс-Unix , содержащихся в сыром стат.</target>
        </trans-unit>
        <trans-unit id="0770383d0616ee4e47049d055237250b7b2bfaef" translate="yes" xml:space="preserve">
          <source>The conversion allocates on the heap and moves &lt;code&gt;t&lt;/code&gt; from the stack into it.</source>
          <target state="translated">Преобразование выделяется в куче и перемещает &lt;code&gt;t&lt;/code&gt; из стека в нее.</target>
        </trans-unit>
        <trans-unit id="66e8c9afb284902c1e321d76aa570359994fd792" translate="yes" xml:space="preserve">
          <source>The conversion consumes the &lt;a href=&quot;../ffi/struct.cstring&quot;&gt;&lt;code&gt;CString&lt;/code&gt;&lt;/a&gt;, and removes the terminating NUL byte.</source>
          <target state="translated">Преобразование потребляет &lt;a href=&quot;../ffi/struct.cstring&quot;&gt; &lt;code&gt;CString&lt;/code&gt; &lt;/a&gt; и удаляет завершающий байт NUL.</target>
        </trans-unit>
        <trans-unit id="b49f9ee7f1f30037339c1daa1d1e1cd395843299" translate="yes" xml:space="preserve">
          <source>The conversion consumes the &lt;a href=&quot;struct.cstring&quot;&gt;&lt;code&gt;CString&lt;/code&gt;&lt;/a&gt;, and removes the terminating NUL byte.</source>
          <target state="translated">Преобразование потребляет &lt;a href=&quot;struct.cstring&quot;&gt; &lt;code&gt;CString&lt;/code&gt; &lt;/a&gt; и удаляет завершающий байт NUL.</target>
        </trans-unit>
        <trans-unit id="9ff60369ad0f3cbf8d85443d93a8bb4f7f1f7686" translate="yes" xml:space="preserve">
          <source>The conversion copies the data, and includes an allocation on the heap.</source>
          <target state="translated">Преобразование копирует данные и включает в себя распределение по куче.</target>
        </trans-unit>
        <trans-unit id="cbdea02b60597ccd54b5d9dbad9b3681336b3420" translate="yes" xml:space="preserve">
          <source>The core method of future, &lt;code&gt;poll&lt;/code&gt;, &lt;em&gt;attempts&lt;/em&gt; to resolve the future into a final value. This method does not block if the value is not ready. Instead, the current task is scheduled to be woken up when it's possible to make further progress by &lt;code&gt;poll&lt;/code&gt;ing again. The &lt;code&gt;context&lt;/code&gt; passed to the &lt;code&gt;poll&lt;/code&gt; method can provide a &lt;a href=&quot;../task/struct.waker&quot;&gt;&lt;code&gt;Waker&lt;/code&gt;&lt;/a&gt;, which is a handle for waking up the current task.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="af0586e1698754134d6653d1c35d55045868b007" translate="yes" xml:space="preserve">
          <source>The core method of future, &lt;code&gt;poll&lt;/code&gt;, &lt;em&gt;attempts&lt;/em&gt; to resolve the future into a final value. This method does not block if the value is not ready. Instead, the current task is scheduled to be woken up when it's possible to make further progress by &lt;code&gt;poll&lt;/code&gt;ing again. The &lt;code&gt;context&lt;/code&gt; passed to the &lt;code&gt;poll&lt;/code&gt; method can provide a &lt;code&gt;Waker&lt;/code&gt;, which is a handle for waking up the current task.</source>
          <target state="translated">Основной метод будущего - &lt;code&gt;poll&lt;/code&gt; - &lt;em&gt;пытается&lt;/em&gt; преобразовать будущее в окончательную ценность. Этот метод не блокируется, если значение не готово. Вместо этого планируется разбудить текущую задачу, когда можно будет добиться дальнейшего прогресса путем повторного &lt;code&gt;poll&lt;/code&gt; . &lt;code&gt;context&lt;/code&gt; передается в &lt;code&gt;poll&lt;/code&gt; метод может обеспечить &lt;code&gt;Waker&lt;/code&gt; , который является ручкой для пробуждения текущей задачи.</target>
        </trans-unit>
        <trans-unit id="7cb53e3d2cc08f8c1b0d6306a44e9e0ab47f9511" translate="yes" xml:space="preserve">
          <source>The core of the error states that there are &lt;em&gt;mismatched types&lt;/em&gt;. Rust has a strong, static type system. However, it also has type inference. When we wrote &lt;code&gt;let mut guess = String::new()&lt;/code&gt;, Rust was able to infer that &lt;code&gt;guess&lt;/code&gt; should be a &lt;code&gt;String&lt;/code&gt; and didn&amp;rsquo;t make us write the type. The &lt;code&gt;secret_number&lt;/code&gt;, on the other hand, is a number type. A few number types can have a value between 1 and 100: &lt;code&gt;i32&lt;/code&gt;, a 32-bit number; &lt;code&gt;u32&lt;/code&gt;, an unsigned 32-bit number; &lt;code&gt;i64&lt;/code&gt;, a 64-bit number; as well as others. Rust defaults to an &lt;code&gt;i32&lt;/code&gt;, which is the type of &lt;code&gt;secret_number&lt;/code&gt; unless you add type information elsewhere that would cause Rust to infer a different numerical type. The reason for the error is that Rust cannot compare a string and a number type.</source>
          <target state="translated">Суть ошибки заключается в том, что существуют &lt;em&gt;несовпадающие типы&lt;/em&gt; . Rust имеет сильную статическую систему типов. Однако он также имеет вывод типа. Когда мы написали &lt;code&gt;let mut guess = String::new()&lt;/code&gt; , Rust смог сделать вывод, что это &lt;code&gt;guess&lt;/code&gt; должно быть &lt;code&gt;String&lt;/code&gt; , и не заставил нас написать тип. С другой стороны, &lt;code&gt;secret_number&lt;/code&gt; - это числовой тип. Некоторые &lt;code&gt;i32&lt;/code&gt; типы могут иметь значение от 1 до 100: i32 , 32-битное число; &lt;code&gt;u32&lt;/code&gt; , 32-битное число без знака; &lt;code&gt;i64&lt;/code&gt; , 64-битное число; а также другие. По умолчанию в Rust используется &lt;code&gt;i32&lt;/code&gt; , который является типом &lt;code&gt;secret_number&lt;/code&gt; .если вы не добавите информацию о типе где-либо еще, что заставит Rust вывести другой числовой тип. Причина ошибки в том, что Rust не может сравнивать строковый и числовой типы.</target>
        </trans-unit>
        <trans-unit id="ddff64ad7c369ce0737f5b8b0b3f4b7511787cca" translate="yes" xml:space="preserve">
          <source>The core primitive for interior mutability in Rust.</source>
          <target state="translated">Ядро примитива для внутренней мутации в Ржавчине.</target>
        </trans-unit>
        <trans-unit id="e23a80c74457fb7f3e04241567981840f6b6a5f0" translate="yes" xml:space="preserve">
          <source>The corresponding definitions are in &lt;code&gt;compiler/rustc_codegen_llvm/src/intrinsic.rs&lt;/code&gt;. The corresponding const implementations are in &lt;code&gt;compiler/rustc_mir/src/interpret/intrinsics.rs&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="159b3bf04af466ed5bc13962fe870a560dd18283" translate="yes" xml:space="preserve">
          <source>The corresponding definitions are in &lt;code&gt;librustc_codegen_llvm/intrinsic.rs&lt;/code&gt;.</source>
          <target state="translated">Соответствующие определения находятся в &lt;code&gt;librustc_codegen_llvm/intrinsic.rs&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="46698ed84aa8c683839a27c0dd70bde9fa62d21c" translate="yes" xml:space="preserve">
          <source>The counts are not affected in any way and the &lt;code&gt;Arc&lt;/code&gt; is not consumed. The pointer is valid for as long as there are strong counts in the &lt;code&gt;Arc&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="77f706694dca621192d20fdc480b2fbc8fb70f49" translate="yes" xml:space="preserve">
          <source>The counts are not affected in any way and the &lt;code&gt;Rc&lt;/code&gt; is not consumed. The pointer is valid for as long there are strong counts in the &lt;code&gt;Rc&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5d69c16c8fa846f1af610002036c48591d43f28f" translate="yes" xml:space="preserve">
          <source>The crate name must not be empty, and must only contain &lt;a href=&quot;../std/primitive.char#method.is_alphanumeric&quot;&gt;Unicode alphanumeric&lt;/a&gt; or &lt;code&gt;-&lt;/code&gt; (U+002D) characters.</source>
          <target state="translated">Имя ящика не должно быть пустым и должно содержать только &lt;a href=&quot;../std/primitive.char#method.is_alphanumeric&quot;&gt;буквенно-цифровые символы Unicode&lt;/a&gt; или символы &lt;code&gt;-&lt;/code&gt; (U + 002D).</target>
        </trans-unit>
        <trans-unit id="be4dd5125e77acafd163c79956b21bce0b41caf8" translate="yes" xml:space="preserve">
          <source>The created map has the default initial capacity.</source>
          <target state="translated">Созданная карта имеет начальную емкость по умолчанию.</target>
        </trans-unit>
        <trans-unit id="a9c04b6351b379cccf29eab61f8204218529d934" translate="yes" xml:space="preserve">
          <source>The current algorithm is an adaptive, iterative merge sort inspired by &lt;a href=&quot;https://en.wikipedia.org/wiki/Timsort&quot;&gt;timsort&lt;/a&gt;. It is designed to be very fast in cases where the slice is nearly sorted, or consists of two or more sorted sequences concatenated one after another.</source>
          <target state="translated">Текущий алгоритм представляет собой адаптивную итеративную сортировку слиянием, вдохновленную &lt;a href=&quot;https://en.wikipedia.org/wiki/Timsort&quot;&gt;timsort&lt;/a&gt; . Он разработан, чтобы быть очень быстрым в случаях, когда фрагмент почти отсортирован или состоит из двух или более отсортированных последовательностей, соединенных друг за другом.</target>
        </trans-unit>
        <trans-unit id="bf4d84cfe0f7a72eb4a521a3a9fe9d6ec790d19e" translate="yes" xml:space="preserve">
          <source>The current algorithm is based on &lt;a href=&quot;https://github.com/orlp/pdqsort&quot;&gt;pattern-defeating quicksort&lt;/a&gt; by Orson Peters, which combines the fast average case of randomized quicksort with the fast worst case of heapsort, while achieving linear time on slices with certain patterns. It uses some randomization to avoid degenerate cases, but with a fixed seed to always provide deterministic behavior.</source>
          <target state="translated">Текущий алгоритм основан на &lt;a href=&quot;https://github.com/orlp/pdqsort&quot;&gt;быстрой сортировке&lt;/a&gt; Орсона Петерса с уничтожением шаблонов, которая сочетает в себе быстрый средний случай рандомизированной быстрой сортировки с наихудшим быстрым случаем динамической сортировки при достижении линейного времени на срезах с определенными шаблонами. Он использует некоторую рандомизацию, чтобы избежать вырожденных случаев, но с фиксированным начальным значением, чтобы всегда обеспечивать детерминированное поведение.</target>
        </trans-unit>
        <trans-unit id="17185ac0ce099c141b9827d28f04ee4d12e294f8" translate="yes" xml:space="preserve">
          <source>The current algorithm is based on the quickselect portion of the same quicksort algorithm used for &lt;a href=&quot;#method.sort_unstable&quot;&gt;&lt;code&gt;sort_unstable&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Текущий алгоритм основан на части быстрого выбора того же алгоритма быстрой сортировки, который используется для &lt;a href=&quot;#method.sort_unstable&quot;&gt; &lt;code&gt;sort_unstable&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="593e3fc1b65f7b6d06f9c45167b067a1a762655b" translate="yes" xml:space="preserve">
          <source>The current file cursor is not affected by this function.</source>
          <target state="translated">Данная функция не влияет на курсор текущего файла.</target>
        </trans-unit>
        <trans-unit id="b3777ab23f3b1144c9a96d550ee493d6bc6e2d44" translate="yes" xml:space="preserve">
          <source>The current implementation uses the same infrastructure as compiler diagnostics and debuginfo, but this is not guaranteed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3346ba5eca8038cde57805738abeaa90cd6a63c6" translate="yes" xml:space="preserve">
          <source>The current module path can be thought of as the hierarchy of modules leading back up to the crate root. The first component of the path returned is the name of the crate currently being compiled.</source>
          <target state="translated">Текущий путь к модулю можно рассматривать как иерархию модулей,ведущую обратно к корню ящика.Первым компонентом возвращаемого пути является имя компилируемого в данный момент ящика.</target>
        </trans-unit>
        <trans-unit id="bdf915fa340c78bb10eee5926542917da6f9a74d" translate="yes" xml:space="preserve">
          <source>The current process does not have the permission rights to access &lt;code&gt;from&lt;/code&gt; or write &lt;code&gt;to&lt;/code&gt;.</source>
          <target state="translated">Текущий процесс не имеет право разрешения на доступ &lt;code&gt;from&lt;/code&gt; или записи &lt;code&gt;to&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1b9c6f166ff606296d138016ea8392f66f7ed63a" translate="yes" xml:space="preserve">
          <source>The current status of a backtrace, indicating whether it was captured or whether it is empty for some other reason.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aa1cdfe5525c9cd270fc9b5826bff19009fb273e" translate="yes" xml:space="preserve">
          <source>The current version of the prelude (version 1) lives in &lt;a href=&quot;v1/index&quot;&gt;&lt;code&gt;std::prelude::v1&lt;/code&gt;&lt;/a&gt;, and re-exports the following.</source>
          <target state="translated">Текущая версия prelude (версия 1) находится в &lt;a href=&quot;v1/index&quot;&gt; &lt;code&gt;std::prelude::v1&lt;/code&gt; &lt;/a&gt; и повторно экспортирует следующее.</target>
        </trans-unit>
        <trans-unit id="c9ba6afb3853703b17e8a712fa55252cfe708a67" translate="yes" xml:space="preserve">
          <source>The current version of the prelude (version 1) lives in &lt;a href=&quot;v1/index&quot;&gt;&lt;code&gt;std::prelude::v1&lt;/code&gt;&lt;/a&gt;, and re-exports the following:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="912528c0cfbd7646c08850f1e407245a6bf7145e" translate="yes" xml:space="preserve">
          <source>The cursor is pointing to the &quot;ghost&quot; non-element if the list is empty.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b9ad03e9a3edaaa56118f6fc3f2871f3d642b3c0" translate="yes" xml:space="preserve">
          <source>The data could not be sent on the &lt;a href=&quot;fn.sync_channel&quot;&gt;&lt;code&gt;sync_channel&lt;/code&gt;&lt;/a&gt; because it would require that the callee block to send the data.</source>
          <target state="translated">Данные не могут быть отправлены по &lt;a href=&quot;fn.sync_channel&quot;&gt; &lt;code&gt;sync_channel&lt;/code&gt; ,&lt;/a&gt; потому что это потребует, чтобы вызываемый блок отправлял данные.</target>
        </trans-unit>
        <trans-unit id="caac8e332d6bed98dbe6a446c232bbf7ded49130" translate="yes" xml:space="preserve">
          <source>The data members that this trait exposes correspond to the members of the &lt;a href=&quot;https://docs.microsoft.com/en-us/windows/win32/api/fileapi/ns-fileapi-by_handle_file_information&quot;&gt;&lt;code&gt;BY_HANDLE_FILE_INFORMATION&lt;/code&gt;&lt;/a&gt; structure.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="113312da9f41c00330f3f6a2627f87633cf51181" translate="yes" xml:space="preserve">
          <source>The data members that this trait exposes correspond to the members of the &lt;a href=&quot;https://msdn.microsoft.com/en-us/library/windows/desktop/aa363788.aspx&quot;&gt;&lt;code&gt;BY_HANDLE_FILE_INFORMATION&lt;/code&gt;&lt;/a&gt; structure.</source>
          <target state="translated">Члены данных, которые предоставляет эта характеристика, соответствуют членам структуры &lt;a href=&quot;https://msdn.microsoft.com/en-us/library/windows/desktop/aa363788.aspx&quot;&gt; &lt;code&gt;BY_HANDLE_FILE_INFORMATION&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="c9421f388aa0f6bda7993e70317be2c01ffcdb74" translate="yes" xml:space="preserve">
          <source>The data protected by the mutex can be accessed through this guard via its &lt;a href=&quot;../ops/trait.deref&quot;&gt;&lt;code&gt;Deref&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../ops/trait.derefmut&quot;&gt;&lt;code&gt;DerefMut&lt;/code&gt;&lt;/a&gt; implementations.</source>
          <target state="translated">Доступ к данным, защищенным мьютексом, можно получить через эту &lt;a href=&quot;../ops/trait.deref&quot;&gt; &lt;code&gt;Deref&lt;/code&gt; &lt;/a&gt; через его реализации Deref и &lt;a href=&quot;../ops/trait.derefmut&quot;&gt; &lt;code&gt;DerefMut&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="a8b69bce2135d478ffa031311b309f0dc7de4fc2" translate="yes" xml:space="preserve">
          <source>The data that the process wrote to stderr.</source>
          <target state="translated">Данные,которые процесс записал в stderr.</target>
        </trans-unit>
        <trans-unit id="5ad3bfb524d0ca744c539d652ec4054ab0b9dc35" translate="yes" xml:space="preserve">
          <source>The data that the process wrote to stdout.</source>
          <target state="translated">Данные,которые процесс записал в stdout.</target>
        </trans-unit>
        <trans-unit id="f0f62565562b0bbca1d9e555b1c167c8869cc294" translate="yes" xml:space="preserve">
          <source>The declaration of &lt;code&gt;another_function&lt;/code&gt; has one parameter named &lt;code&gt;x&lt;/code&gt;. The type of &lt;code&gt;x&lt;/code&gt; is specified as &lt;code&gt;i32&lt;/code&gt;. When &lt;code&gt;5&lt;/code&gt; is passed to &lt;code&gt;another_function&lt;/code&gt;, the &lt;code&gt;println!&lt;/code&gt; macro puts &lt;code&gt;5&lt;/code&gt; where the pair of curly brackets were in the format string.</source>
          <target state="translated">Объявление &lt;code&gt;another_function&lt;/code&gt; имеет один параметр с именем &lt;code&gt;x&lt;/code&gt; . Тип &lt;code&gt;x&lt;/code&gt; указан как &lt;code&gt;i32&lt;/code&gt; . Когда &lt;code&gt;5&lt;/code&gt; передается в &lt;code&gt;another_function&lt;/code&gt; , &lt;code&gt;println!&lt;/code&gt; макрос помещает &lt;code&gt;5&lt;/code&gt; там, где была пара фигурных скобок в строке формата.</target>
        </trans-unit>
        <trans-unit id="f3e2b77707e4042bb7d326cf080f9fda22d6fd02" translate="yes" xml:space="preserve">
          <source>The default &lt;a href=&quot;#fillalignment&quot;&gt;fill/alignment&lt;/a&gt; for non-numerics is a space and left-aligned. The default for numeric formatters is also a space character but with right-alignment. If the &lt;code&gt;0&lt;/code&gt; flag (see below) is specified for numerics, then the implicit fill character is &lt;code&gt;0&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6a4c3f3e9f4bf073db3de78ffdfd8f78a08679d0" translate="yes" xml:space="preserve">
          <source>The default &lt;a href=&quot;#fillalignment&quot;&gt;fill/alignment&lt;/a&gt; for non-numerics is a space and left-aligned. The defaults for numeric formatters is also a space but with right-alignment. If the &lt;code&gt;0&lt;/code&gt; flag is specified for numerics, then the implicit fill character is &lt;code&gt;0&lt;/code&gt;.</source>
          <target state="translated">Для нечисловых значений &lt;a href=&quot;#fillalignment&quot;&gt;заливка / выравнивание&lt;/a&gt; по умолчанию - это пробел с выравниванием по левому краю. По умолчанию для числовых форматеров также используется пробел, но с выравниванием по правому краю. Если для числовых значений указан флаг &lt;code&gt;0&lt;/code&gt; , то неявный символ заполнения равен &lt;code&gt;0&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e71d3da519e1259cb4d0ff052a4082fe544273e4" translate="yes" xml:space="preserve">
          <source>The default &lt;a href=&quot;../../hash/trait.hasher&quot;&gt;&lt;code&gt;Hasher&lt;/code&gt;&lt;/a&gt; used by &lt;a href=&quot;struct.randomstate&quot;&gt;&lt;code&gt;RandomState&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">По умолчанию &lt;a href=&quot;../../hash/trait.hasher&quot;&gt; &lt;code&gt;Hasher&lt;/code&gt; &lt;/a&gt; используется &lt;a href=&quot;struct.randomstate&quot;&gt; &lt;code&gt;RandomState&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="81a33ca44ce969a6a0433a7aff9f0392c46b2e52" translate="yes" xml:space="preserve">
          <source>The default behavior of this function is to print a message to standard error and abort the process. It can be replaced with &lt;a href=&quot;fn.set_alloc_error_hook&quot;&gt;&lt;code&gt;set_alloc_error_hook&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;fn.take_alloc_error_hook&quot;&gt;&lt;code&gt;take_alloc_error_hook&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">По умолчанию эта функция выводит сообщение об ошибке и прерывает процесс. Его можно заменить на &lt;a href=&quot;fn.set_alloc_error_hook&quot;&gt; &lt;code&gt;set_alloc_error_hook&lt;/code&gt; &lt;/a&gt; и &lt;a href=&quot;fn.take_alloc_error_hook&quot;&gt; &lt;code&gt;take_alloc_error_hook&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="1fe48c8009742af8ee8a3efe0842a923bc01bf9d" translate="yes" xml:space="preserve">
          <source>The default generic type in this code is within the &lt;code&gt;Add&lt;/code&gt; trait. Here is its definition:</source>
          <target state="translated">Универсальный тип по умолчанию в этом коде находится внутри признака &lt;code&gt;Add&lt;/code&gt; . Вот его определение:</target>
        </trans-unit>
        <trans-unit id="697b922437171b9fe1e8c84494c4b161d6fd03d3" translate="yes" xml:space="preserve">
          <source>The default hashing algorithm is currently SipHash 1-3, though this is subject to change at any point in the future. While its performance is very competitive for medium sized keys, other hashing algorithms will outperform it for small keys such as integers as well as large keys such as long strings, though those algorithms will typically &lt;em&gt;not&lt;/em&gt; protect against attacks such as HashDoS.</source>
          <target state="translated">Алгоритм хеширования по умолчанию в настоящее время SipHash 1-3, хотя он может быть изменен в любой момент в будущем. Хотя его производительность очень конкурентоспособна для ключей среднего размера, другие алгоритмы хеширования будут превосходить его для небольших ключей, таких как целые числа, а также для больших ключей, таких как длинные строки, хотя эти алгоритмы обычно &lt;em&gt;не&lt;/em&gt; защищают от атак, таких как HashDoS.</target>
        </trans-unit>
        <trans-unit id="80e587164750efd5907b562bcc2c0ec8621ca1dc" translate="yes" xml:space="preserve">
          <source>The default implementation calls &lt;a href=&quot;trait.write#tymethod.write&quot;&gt;&lt;code&gt;write&lt;/code&gt;&lt;/a&gt; with either the first nonempty buffer provided, or an empty one if none exists.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="73b38e69c912c9cd2a1d35da9b4cb8282e56833f" translate="yes" xml:space="preserve">
          <source>The default implementation calls &lt;code&gt;read&lt;/code&gt; with either the first nonempty buffer provided, or an empty one if none exists.</source>
          <target state="translated">Реализация по умолчанию вызывает &lt;code&gt;read&lt;/code&gt; либо с первым предоставленным непустым буфером, либо с пустым, если его нет.</target>
        </trans-unit>
        <trans-unit id="2e19ee8802e471056a9e27a45d3086893e133973" translate="yes" xml:space="preserve">
          <source>The default implementation calls &lt;code&gt;write&lt;/code&gt; with either the first nonempty buffer provided, or an empty one if none exists.</source>
          <target state="translated">Реализация по умолчанию вызывает &lt;code&gt;write&lt;/code&gt; либо с первым предоставленным непустым буфером, либо с пустым, если его нет.</target>
        </trans-unit>
        <trans-unit id="917b792910290b9f104f9e9bb1c1c376f6e62a1b" translate="yes" xml:space="preserve">
          <source>The default implementation does nothing.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cda4f183b9995aecf4b0037179612271bde1f6bd" translate="yes" xml:space="preserve">
          <source>The default implementation returns &lt;code&gt;(0, &lt;/code&gt;&lt;a href=&quot;../option/enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt;&lt;code&gt;)&lt;/code&gt; which is correct for any iterator.</source>
          <target state="translated">Реализация по умолчанию возвращает &lt;code&gt;(0, &lt;/code&gt; &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt; &lt;code&gt;None&lt;/code&gt; &lt;/a&gt; &lt;code&gt;)&lt;/code&gt; , что верно для любого итератора.</target>
        </trans-unit>
        <trans-unit id="e33ad58e76bb269caa1c45076544afb93bb1e40d" translate="yes" xml:space="preserve">
          <source>The default implementation returns &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="969fb25f2024192b2aecf3ee3a177be1b86acfb5" translate="yes" xml:space="preserve">
          <source>The default implementation returns an initializer which will zero buffers.</source>
          <target state="translated">Реализация по умолчанию возвращает инициализатор,который будет иметь нулевые буферы.</target>
        </trans-unit>
        <trans-unit id="bb3d803ebf5acd8c1abc49ce5f1cae9b36493095" translate="yes" xml:space="preserve">
          <source>The default implementations are returning &lt;code&gt;libc::EXIT_SUCCESS&lt;/code&gt; to indicate a successful execution. In case of a failure, &lt;code&gt;libc::EXIT_FAILURE&lt;/code&gt; is returned.</source>
          <target state="translated">Реализации по умолчанию возвращают &lt;code&gt;libc::EXIT_SUCCESS&lt;/code&gt; чтобы указать на успешное выполнение. В случае сбоя возвращается &lt;code&gt;libc::EXIT_FAILURE&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="31cdcfae6f2b31eff3f08e0d9f029eeb9ec7bee1" translate="yes" xml:space="preserve">
          <source>The default is chosen with a bias toward producing literals that are legal in a variety of languages, including C++11 and similar C-family languages. The exact rules are:</source>
          <target state="translated">По умолчанию выбирается с предубеждением к созданию литералов,легальных в различных языках,включая C++11 и аналогичные языки семейства C.Точные правила таковы:</target>
        </trans-unit>
        <trans-unit id="b02cae987658ffb74f03215f87762f2599f0c7eb" translate="yes" xml:space="preserve">
          <source>The default memory allocator provided by the operating system.</source>
          <target state="translated">Выделение памяти по умолчанию,предоставляемое операционной системой.</target>
        </trans-unit>
        <trans-unit id="1dd4678ade75055f3987aad761b36a01d2353c9f" translate="yes" xml:space="preserve">
          <source>The default stack size for spawned threads is 2 MiB, though this particular stack size is subject to change in the future. There are two ways to manually specify the stack size for spawned threads:</source>
          <target state="translated">По умолчанию размер стека для порожденных потоков составляет 2 Мб,хотя этот конкретный размер стека может измениться в будущем.Есть два способа вручную указать размер стека для порожденных потоков:</target>
        </trans-unit>
        <trans-unit id="0f91c7ab56b392b9e17d4e1e13452f2f412a7407" translate="yes" xml:space="preserve">
          <source>The definition for complex NTs deserves some justification. SEP_SET(M) defines the possibility that the separator could be a valid first token for M, which happens when there is a separator defined and the repeated fragment could be empty. ALPHA_SET(M) defines the possibility that the complex NT could be empty, meaning that M's valid first tokens are those of the following token-tree sequences &lt;code&gt;&amp;alpha;&lt;/code&gt;. This occurs when either &lt;code&gt;\*&lt;/code&gt; or &lt;code&gt;?&lt;/code&gt; is used, in which case there could be zero repetitions. In theory, this could also occur if &lt;code&gt;+&lt;/code&gt; was used with a potentially-empty repeating fragment, but this is forbidden by the third invariant.</source>
          <target state="translated">Определение сложных НТ заслуживает некоторого обоснования. SEP_SET (M) определяет возможность того, что разделитель может быть допустимым первым токеном для M, что происходит, когда определен разделитель и повторяющийся фрагмент может быть пустым. ALPHA_SET (M) определяет вероятность того, что сложный NT может быть пустым, что означает, что действительные первые токены M являются токенами следующих последовательностей дерева токенов &lt;code&gt;&amp;alpha;&lt;/code&gt; . Это происходит, когда либо &lt;code&gt;\*&lt;/code&gt; либо &lt;code&gt;?&lt;/code&gt; используется, и в этом случае может быть ноль повторов. Теоретически это может также произойти, если &lt;code&gt;+&lt;/code&gt; использовался с потенциально пустым повторяющимся фрагментом, но это запрещено третьим инвариантом.</target>
        </trans-unit>
        <trans-unit id="985a8049c57bbba61492d3048826a9b3471b56f7" translate="yes" xml:space="preserve">
          <source>The definition of &lt;code&gt;Config&lt;/code&gt;</source>
          <target state="translated">Определение &lt;code&gt;Config&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="830ab684e6b9340db4f9c07a73c12e27ccb95977" translate="yes" xml:space="preserve">
          <source>The dereference operator</source>
          <target state="translated">Оператор снятия с производства</target>
        </trans-unit>
        <trans-unit id="75ad44a3ef91af0a45f2841a370dda11b833e07f" translate="yes" xml:space="preserve">
          <source>The desired behavior of the &lt;code&gt;generate_workout&lt;/code&gt; function is to first check whether the user wants a low-intensity workout (indicated by a number less than 25) or a high-intensity workout (a number of 25 or greater).</source>
          <target state="translated">Желаемое поведение функции &lt;code&gt;generate_workout&lt;/code&gt; состоит в том, чтобы сначала проверить, хочет ли пользователь тренировку низкой интенсивности (обозначается числом меньше 25) или тренировкой высокой интенсивности (число 25 или больше).</target>
        </trans-unit>
        <trans-unit id="f11d06267e33f3ae0370e1b473dace96a1d49d65" translate="yes" xml:space="preserve">
          <source>The destructor of a type &lt;code&gt;T&lt;/code&gt; consists of:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="be2c8573e9de352b5e8e680cfa4b055e97512426" translate="yes" xml:space="preserve">
          <source>The destructor of a type consists of</source>
          <target state="translated">Деструктор типа состоит из</target>
        </trans-unit>
        <trans-unit id="c9c60944e1a21001c2063c93ac3b0f4cb46946e2" translate="yes" xml:space="preserve">
          <source>The destructor of the struct must not move structural fields out of its argument. This is the exact point that was raised in the &lt;a href=&quot;#drop-implementation&quot;&gt;previous section&lt;/a&gt;: &lt;code&gt;drop&lt;/code&gt; takes &lt;code&gt;&amp;amp;mut self&lt;/code&gt;, but the struct (and hence its fields) might have been pinned before. You have to guarantee that you do not move a field inside your &lt;a href=&quot;../ops/trait.drop#tymethod.drop&quot;&gt;&lt;code&gt;Drop&lt;/code&gt;&lt;/a&gt; implementation. In particular, as explained previously, this means that your struct must &lt;em&gt;not&lt;/em&gt; be &lt;code&gt;#[repr(packed)]&lt;/code&gt;. See that section for how to write &lt;a href=&quot;../ops/trait.drop#tymethod.drop&quot;&gt;&lt;code&gt;drop&lt;/code&gt;&lt;/a&gt; in a way that the compiler can help you not accidentally break pinning.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="30054f3bf420ad868745eedcb4cc73a1da34e82c" translate="yes" xml:space="preserve">
          <source>The destructor of the struct must not move structural fields out of its argument. This is the exact point that was raised in the &lt;a href=&quot;#drop-implementation&quot;&gt;previous section&lt;/a&gt;: &lt;code&gt;drop&lt;/code&gt; takes &lt;code&gt;&amp;amp;mut self&lt;/code&gt;, but the struct (and hence its fields) might have been pinned before. You have to guarantee that you do not move a field inside your &lt;code&gt;Drop&lt;/code&gt; implementation. In particular, as explained previously, this means that your struct must &lt;em&gt;not&lt;/em&gt; be &lt;code&gt;#[repr(packed)]&lt;/code&gt;. See that section for how to write &lt;code&gt;drop&lt;/code&gt; in a way that the compiler can help you not accidentally break pinning.</source>
          <target state="translated">Деструктор структуры не должен перемещать структурные поля из своего аргумента. Это точный момент, который был поднят в &lt;a href=&quot;#drop-implementation&quot;&gt;предыдущем разделе&lt;/a&gt; : &lt;code&gt;drop&lt;/code&gt; принимает &lt;code&gt;&amp;amp;mut self&lt;/code&gt; , но структура (и, следовательно, ее поля) могла быть закреплена раньше. Вы должны гарантировать, что не перемещаете поле внутри своей реализации &lt;code&gt;Drop&lt;/code&gt; . В частности, как объяснялось ранее, это означает, что ваша структура &lt;em&gt;не&lt;/em&gt; должна быть &lt;code&gt;#[repr(packed)]&lt;/code&gt; . В этом разделе рассказывается, как написать &lt;code&gt;drop&lt;/code&gt; , чтобы компилятор мог помочь вам случайно не нарушить закрепление.</target>
        </trans-unit>
        <trans-unit id="f85efc5c824a33e7773d4a9703af1abcf28610ef" translate="yes" xml:space="preserve">
          <source>The difference between 'the prelude' and these other preludes is that they are not automatically &lt;code&gt;use&lt;/code&gt;'d, and must be imported manually. This is still easier than importing all of their constituent components.</source>
          <target state="translated">Разница между прелюдией и другими прелюдиями в том, что они не &lt;code&gt;use&lt;/code&gt; автоматически d и должны быть импортированы вручную. Это все еще проще, чем импортировать все составляющие их компоненты.</target>
        </trans-unit>
        <trans-unit id="505a24f6c966bf30ebbdd0623555d0248f90c11b" translate="yes" xml:space="preserve">
          <source>The difference between &lt;a href=&quot;macro.unimplemented&quot;&gt;&lt;code&gt;unimplemented!&lt;/code&gt;&lt;/a&gt; and &lt;code&gt;todo!&lt;/code&gt; is that while &lt;code&gt;todo!&lt;/code&gt; conveys an intent of implementing the functionality later and the message is &quot;not yet implemented&quot;, &lt;code&gt;unimplemented!&lt;/code&gt; makes no such claims. Its message is &quot;not implemented&quot;. Also some IDEs will mark &lt;code&gt;todo!&lt;/code&gt;s.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="03297ced74ba958f935a37ee67580ef54eeb9a79" translate="yes" xml:space="preserve">
          <source>The difference between &lt;code&gt;unimplemented!&lt;/code&gt; and &lt;a href=&quot;macro.todo&quot;&gt;&lt;code&gt;todo!&lt;/code&gt;&lt;/a&gt; is that while &lt;code&gt;todo!&lt;/code&gt; conveys an intent of implementing the functionality later and the message is &quot;not yet implemented&quot;, &lt;code&gt;unimplemented!&lt;/code&gt; makes no such claims. Its message is &quot;not implemented&quot;. Also some IDEs will mark &lt;code&gt;todo!&lt;/code&gt;s.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3d53ebfe9f22c1eb14437a5afaa7bab7ac81b640" translate="yes" xml:space="preserve">
          <source>The difference is that when using generics, as in Listing 19-13, we must annotate the types in each implementation; because we can also implement &lt;code&gt;Iterator&amp;lt;String&amp;gt; for Counter&lt;/code&gt; or any other type, we could have multiple implementations of &lt;code&gt;Iterator&lt;/code&gt; for &lt;code&gt;Counter&lt;/code&gt;. In other words, when a trait has a generic parameter, it can be implemented for a type multiple times, changing the concrete types of the generic type parameters each time. When we use the &lt;code&gt;next&lt;/code&gt; method on &lt;code&gt;Counter&lt;/code&gt;, we would have to provide type annotations to indicate which implementation of &lt;code&gt;Iterator&lt;/code&gt; we want to use.</source>
          <target state="translated">Разница в том, что при использовании универсальных шаблонов, как в листинге 19-13, мы должны аннотировать типы в каждой реализации; поскольку мы также можем реализовать &lt;code&gt;Iterator&amp;lt;String&amp;gt; for Counter&lt;/code&gt; или любого другого типа, у нас может быть несколько реализаций &lt;code&gt;Iterator&lt;/code&gt; для &lt;code&gt;Counter&lt;/code&gt; . Другими словами, когда признак имеет универсальный параметр, он может быть реализован для типа несколько раз, каждый раз изменяя конкретные типы параметров универсального типа. Когда мы используем &lt;code&gt;next&lt;/code&gt; метод в &lt;code&gt;Counter&lt;/code&gt; , нам нужно будет предоставить аннотации типов, чтобы указать, какую реализацию &lt;code&gt;Iterator&lt;/code&gt; мы хотим использовать.</target>
        </trans-unit>
        <trans-unit id="5d4f5e1a47f10d66452650a5f161fd164ebd410d" translate="yes" xml:space="preserve">
          <source>The differences about paths and the &lt;code&gt;use&lt;/code&gt; keyword between the 2015 and 2018 editions can also be found in the &lt;a href=&quot;../reference/items/use-declarations&quot;&gt;Reference&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d9b61b2f901725762b56d16bf06bea0055df6804" translate="yes" xml:space="preserve">
          <source>The different behavior of files in the &lt;em&gt;tests&lt;/em&gt; directory is most noticeable when you have a set of helper functions that would be useful in multiple integration test files and you try to follow the steps in the &lt;a href=&quot;ch07-05-separating-modules-into-different-files&quot;&gt;&amp;ldquo;Separating Modules into Different Files&amp;rdquo;&lt;/a&gt; section of Chapter 7 to extract them into a common module. For example, if we create &lt;em&gt;tests/common.rs&lt;/em&gt; and place a function named &lt;code&gt;setup&lt;/code&gt; in it, we can add some code to &lt;code&gt;setup&lt;/code&gt; that we want to call from multiple test functions in multiple test files:</source>
          <target state="translated">Различное поведение файлов в каталоге &lt;em&gt;тестов&lt;/em&gt; наиболее заметно, когда у вас есть набор вспомогательных функций, которые могут быть полезны в нескольких файлах тестов интеграции, и вы пытаетесь выполнить шаги, описанные в разделе &lt;a href=&quot;ch07-05-separating-modules-into-different-files&quot;&gt;&amp;laquo;Разделение модулей на разные файлы&amp;raquo;&lt;/a&gt; главы 7, чтобы извлеките их в общий модуль. Например, если мы создадим &lt;em&gt;tests / common.rs&lt;/em&gt; и &lt;em&gt;поместим&lt;/em&gt; в него функцию с именем &lt;code&gt;setup&lt;/code&gt; , мы можем добавить в &lt;code&gt;setup&lt;/code&gt; код, который мы хотим вызвать из нескольких тестовых функций в нескольких тестовых файлах:</target>
        </trans-unit>
        <trans-unit id="d5be1c02c26fe5ef598a5696a274160d696e7977" translate="yes" xml:space="preserve">
          <source>The different meanings of &lt;code&gt;unsafe&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1fd895f49df6ac41f021206eb05bd5dfbc8e5ada" translate="yes" xml:space="preserve">
          <source>The directories and files used for loading external file modules can be influenced with the &lt;code&gt;path&lt;/code&gt; attribute.</source>
          <target state="translated">На каталоги и файлы, используемые для загрузки внешних файловых модулей, можно влиять с помощью атрибута &lt;code&gt;path&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1e92ecf8e1ea3e2a6e4c02654c525e112d825547" translate="yes" xml:space="preserve">
          <source>The directory isn't empty.</source>
          <target state="translated">Каталог не пуст.</target>
        </trans-unit>
        <trans-unit id="8e9718c5436468359091854f47e29ace6b258c73" translate="yes" xml:space="preserve">
          <source>The discriminant enum from the example &lt;a href=&quot;#reprc-enums-with-fields&quot;&gt;earlier&lt;/a&gt; then becomes:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5406bf9928b412a24605eecb2ec809ade9b2bfca" translate="yes" xml:space="preserve">
          <source>The discriminant of an enum variant may change if the enum definition changes. A discriminant of some variant will not change between compilations with the same compiler.</source>
          <target state="translated">Дискриминант варианта перечисления может измениться,если изменится определение перечисления.Дискриминант некоторого варианта не изменится между компиляциями с одним и тем же компилятором.</target>
        </trans-unit>
        <trans-unit id="e1e71495d678a5d4be21061931a65d8862bd4e7e" translate="yes" xml:space="preserve">
          <source>The distance being in bounds cannot rely on &quot;wrapping around&quot; the address space.</source>
          <target state="translated">Расстояние,находящееся в границах,не может полагаться на &quot;обертывание&quot; адресного пространства.</target>
        </trans-unit>
        <trans-unit id="6c785ac664fd8d2346ca1bb482fcd8b5593d6af3" translate="yes" xml:space="preserve">
          <source>The distance between the pointers, &lt;strong&gt;in bytes&lt;/strong&gt;, cannot overflow an &lt;code&gt;isize&lt;/code&gt;.</source>
          <target state="translated">Расстояние между указателями &lt;strong&gt;в байтах&lt;/strong&gt; не может &lt;code&gt;isize&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="bd1487c3b6f63cdfefd3896403e040d0a14037e5" translate="yes" xml:space="preserve">
          <source>The distance between the pointers, in bytes, must be an exact multiple of the size of &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">Расстояние между указателями, в байтах, должно быть точным кратным размером &lt;code&gt;T&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c85eee3f8fcb1e3d7acfa8c71113a8ed01e9b6ce" translate="yes" xml:space="preserve">
          <source>The division assignment operator &lt;code&gt;/=&lt;/code&gt;.</source>
          <target state="translated">Оператор присваивания деления &lt;code&gt;/=&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="fac0cbbb13a4ae4385140ac3ccea99961d57c224" translate="yes" xml:space="preserve">
          <source>The division operator &lt;code&gt;/&lt;/code&gt;.</source>
          <target state="translated">Оператор деления &lt;code&gt;/&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d4bae769945be3db52fcb8fef6b0f5ad9c54eef4" translate="yes" xml:space="preserve">
          <source>The documentation for this keyword is &lt;a href=&quot;https://github.com/rust-lang/rust/issues/34601&quot;&gt;not yet complete&lt;/a&gt;. Pull requests welcome!</source>
          <target state="translated">Документация по этому ключевому слову еще &lt;a href=&quot;https://github.com/rust-lang/rust/issues/34601&quot;&gt;не завершена&lt;/a&gt; . Запросы на вытягивание приветствуются!</target>
        </trans-unit>
        <trans-unit id="7092af2bcd91c441c2dfc4c8d572a11dfce60e91" translate="yes" xml:space="preserve">
          <source>The double colon (&lt;code&gt;::&lt;/code&gt;) is an operator that allows us to namespace this particular &lt;code&gt;from&lt;/code&gt; function under the &lt;code&gt;String&lt;/code&gt; type rather than using some sort of name like &lt;code&gt;string_from&lt;/code&gt;. We&amp;rsquo;ll discuss this syntax more in the &lt;a href=&quot;ch05-03-method-syntax#method-syntax&quot;&gt;&amp;ldquo;Method Syntax&amp;rdquo;&lt;/a&gt; section of Chapter 5 and when we talk about namespacing with modules in &lt;a href=&quot;ch07-03-paths-for-referring-to-an-item-in-the-module-tree&quot;&gt;&amp;ldquo;Paths for Referring to an Item in the Module Tree&amp;rdquo;&lt;/a&gt; in Chapter 7.</source>
          <target state="translated">Двойное двоеточие ( &lt;code&gt;::&lt;/code&gt; ) является оператором , который позволяет это пространство имен частности &lt;code&gt;from&lt;/code&gt; функции под &lt;code&gt;String&lt;/code&gt; типа , а не с помощью какой - то имя , как &lt;code&gt;string_from&lt;/code&gt; . Мы обсудим этот синтаксис более подробно в разделе &lt;a href=&quot;ch05-03-method-syntax#method-syntax&quot;&gt;&amp;laquo;Синтаксис метода&amp;raquo;&lt;/a&gt; главы 5 и когда мы будем говорить о пространстве имен с модулями в разделе &lt;a href=&quot;ch07-03-paths-for-referring-to-an-item-in-the-module-tree&quot;&gt;&amp;laquo;Пути для ссылки на элемент в дереве модулей&amp;raquo;&lt;/a&gt; в главе 7.</target>
        </trans-unit>
        <trans-unit id="27b2d1743e157ab144583c8c6b85ea9ad0092f0b" translate="yes" xml:space="preserve">
          <source>The downside of using &lt;code&gt;if let&lt;/code&gt; expressions is that the compiler doesn&amp;rsquo;t check exhaustiveness, whereas with &lt;code&gt;match&lt;/code&gt; expressions it does. If we omitted the last &lt;code&gt;else&lt;/code&gt; block and therefore missed handling some cases, the compiler would not alert us to the possible logic bug.</source>
          <target state="translated">Недостатком использования , &lt;code&gt;if let&lt;/code&gt; выражений является то , что компилятор не проверяет полноту, в то время как с &lt;code&gt;match&lt;/code&gt; выражениями он делает. Если мы пропустили последний блок &lt;code&gt;else&lt;/code&gt; и, следовательно, пропустили обработку некоторых случаев, компилятор не предупредит нас о возможной логической ошибке.</target>
        </trans-unit>
        <trans-unit id="e387e6a833f24807236bb7fd7266c18e39a1df6d" translate="yes" xml:space="preserve">
          <source>The downside of using this technique is that &lt;code&gt;Wrapper&lt;/code&gt; is a new type, so it doesn&amp;rsquo;t have the methods of the value it&amp;rsquo;s holding. We would have to implement all the methods of &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; directly on &lt;code&gt;Wrapper&lt;/code&gt; such that the methods delegate to &lt;code&gt;self.0&lt;/code&gt;, which would allow us to treat &lt;code&gt;Wrapper&lt;/code&gt; exactly like a &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt;. If we wanted the new type to have every method the inner type has, implementing the &lt;code&gt;Deref&lt;/code&gt; trait (discussed in Chapter 15 in the &lt;a href=&quot;ch15-02-deref#treating-smart-pointers-like-regular-references-with-the-deref-trait&quot;&gt;&amp;ldquo;Treating Smart Pointers Like Regular References with the &lt;code&gt;Deref&lt;/code&gt; Trait&amp;rdquo;&lt;/a&gt; section) on the &lt;code&gt;Wrapper&lt;/code&gt; to return the inner type would be a solution. If we don&amp;rsquo;t want the &lt;code&gt;Wrapper&lt;/code&gt; type to have all the methods of the inner type&amp;mdash;for example, to restrict the &lt;code&gt;Wrapper&lt;/code&gt; type&amp;rsquo;s behavior&amp;mdash;we would have to implement just the methods we do want manually.</source>
          <target state="translated">Обратной стороной использования этого метода является то, что &lt;code&gt;Wrapper&lt;/code&gt; - это новый тип, поэтому у него нет методов хранимого в нем значения. Нам пришлось бы реализовать все методы &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; непосредственно в &lt;code&gt;Wrapper&lt;/code&gt; , чтобы методы делегировали &lt;code&gt;self.0&lt;/code&gt; , что позволило бы нам обращаться с &lt;code&gt;Wrapper&lt;/code&gt; точно так же, как с &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; . Если бы мы хотели, чтобы новый тип имел все методы, которые есть у внутреннего типа, реализуя &lt;code&gt;Deref&lt;/code&gt; (обсуждаемый в главе 15 в разделе &lt;a href=&quot;ch15-02-deref#treating-smart-pointers-like-regular-references-with-the-deref-trait&quot;&gt;&amp;laquo;Обработка умных указателей как обычных ссылок с помощью &lt;code&gt;Deref&lt;/code&gt; &amp;raquo;&lt;/a&gt; ) в &lt;code&gt;Wrapper&lt;/code&gt; возвращение внутреннего типа было бы решением. Если мы не хотим, чтобы тип &lt;code&gt;Wrapper&lt;/code&gt; имел все методы внутреннего типа - например, для ограничения поведения типа &lt;code&gt;Wrapper&lt;/code&gt; - нам пришлось бы реализовать вручную только те методы, которые нам нужны.</target>
        </trans-unit>
        <trans-unit id="0e7aa88c59ccdb8f5ae43f1abe07297a4d7ace58" translate="yes" xml:space="preserve">
          <source>The downside to implementing a macro instead of a function is that macro definitions are more complex than function definitions because you&amp;rsquo;re writing Rust code that writes Rust code. Due to this indirection, macro definitions are generally more difficult to read, understand, and maintain than function definitions.</source>
          <target state="translated">Обратной стороной реализации макроса вместо функции является то, что определения макросов более сложны, чем определения функций, потому что вы пишете код Rust, который пишет код Rust. Из-за этого косвенного обращения определения макросов, как правило, труднее читать, понимать и поддерживать, чем определения функций.</target>
        </trans-unit>
        <trans-unit id="719fc8d49d59015d6dffe7ccc55e5816d1966b0e" translate="yes" xml:space="preserve">
          <source>The duration of one microsecond.</source>
          <target state="translated">Продолжительностью в одну микросекунду.</target>
        </trans-unit>
        <trans-unit id="e68beeeb11183a3ff18abb9e6896356e66b6200f" translate="yes" xml:space="preserve">
          <source>The duration of one millisecond.</source>
          <target state="translated">Продолжительностью в одну миллисекунду.</target>
        </trans-unit>
        <trans-unit id="e9d186359c1c80de39171fea4281a767f86db9c5" translate="yes" xml:space="preserve">
          <source>The duration of one nanosecond.</source>
          <target state="translated">Длительность в одну наносекунду.</target>
        </trans-unit>
        <trans-unit id="926b58a37c99c224d9cf0ad023e9e79f2bae5af3" translate="yes" xml:space="preserve">
          <source>The duration of one second.</source>
          <target state="translated">Продолжительность одной секунды.</target>
        </trans-unit>
        <trans-unit id="51e82336197f20c9062a20d4490259f940ada0fe" translate="yes" xml:space="preserve">
          <source>The easiest fix is to rewrite your closure into a top-level function, or into a method. In some cases, you may also be able to have your closure call itself by capturing a &lt;code&gt;&amp;amp;Fn()&lt;/code&gt; object or &lt;code&gt;fn()&lt;/code&gt; pointer that refers to itself. That is permitting, since the closure would be invoking itself via a virtual call, and hence does not directly reference its own &lt;em&gt;type&lt;/em&gt;.</source>
          <target state="translated">Самое простое решение - переписать замыкание в функцию верхнего уровня или в метод. В некоторых случаях вы также можете иметь сам вызов закрытия, захватив объект &lt;code&gt;&amp;amp;Fn()&lt;/code&gt; или указатель &lt;code&gt;fn()&lt;/code&gt; который ссылается на себя. Это допустимо, так как замыкание будет вызываться через виртуальный вызов и, следовательно, не будет напрямую ссылаться на свой собственный &lt;em&gt;тип&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="8b90152377c4d2fa6a58836b95414b3c64c66683" translate="yes" xml:space="preserve">
          <source>The easiest way to use &lt;code&gt;HashMap&lt;/code&gt; with a custom key type is to derive &lt;a href=&quot;../../cmp/trait.eq&quot;&gt;&lt;code&gt;Eq&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../../hash/trait.hash&quot;&gt;&lt;code&gt;Hash&lt;/code&gt;&lt;/a&gt;. We must also derive &lt;a href=&quot;../../cmp/trait.partialeq&quot;&gt;&lt;code&gt;PartialEq&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Самый простой способ использовать &lt;code&gt;HashMap&lt;/code&gt; с настраиваемым типом ключа - это получить &lt;a href=&quot;../../cmp/trait.eq&quot;&gt; &lt;code&gt;Eq&lt;/code&gt; &lt;/a&gt; и &lt;a href=&quot;../../hash/trait.hash&quot;&gt; &lt;code&gt;Hash&lt;/code&gt; &lt;/a&gt; . Мы также должны получить &lt;a href=&quot;../../cmp/trait.partialeq&quot;&gt; &lt;code&gt;PartialEq&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="8fdc4a2a7876216a8a5156bcc124c1c5c1d13c54" translate="yes" xml:space="preserve">
          <source>The easiest way to use &lt;code&gt;HashMap&lt;/code&gt; with a custom key type is to derive &lt;a href=&quot;../cmp/trait.eq&quot;&gt;&lt;code&gt;Eq&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../hash/trait.hash&quot;&gt;&lt;code&gt;Hash&lt;/code&gt;&lt;/a&gt;. We must also derive &lt;a href=&quot;../cmp/trait.partialeq&quot;&gt;&lt;code&gt;PartialEq&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Самый простой способ использовать &lt;code&gt;HashMap&lt;/code&gt; с настраиваемым типом ключа - это получить &lt;a href=&quot;../cmp/trait.eq&quot;&gt; &lt;code&gt;Eq&lt;/code&gt; &lt;/a&gt; и &lt;a href=&quot;../hash/trait.hash&quot;&gt; &lt;code&gt;Hash&lt;/code&gt; &lt;/a&gt; . Мы также должны получить &lt;a href=&quot;../cmp/trait.partialeq&quot;&gt; &lt;code&gt;PartialEq&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="2b835cd73ddea2cd4aee637c4f9c2cd855ee696f" translate="yes" xml:space="preserve">
          <source>The easiest way to use &lt;code&gt;HashSet&lt;/code&gt; with a custom type is to derive &lt;a href=&quot;../../cmp/trait.eq&quot;&gt;&lt;code&gt;Eq&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../../hash/trait.hash&quot;&gt;&lt;code&gt;Hash&lt;/code&gt;&lt;/a&gt;. We must also derive &lt;a href=&quot;../../cmp/trait.partialeq&quot;&gt;&lt;code&gt;PartialEq&lt;/code&gt;&lt;/a&gt;, this will in the future be implied by &lt;a href=&quot;../../cmp/trait.eq&quot;&gt;&lt;code&gt;Eq&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Самый простой способ использовать &lt;code&gt;HashSet&lt;/code&gt; с настраиваемым типом - это получить &lt;a href=&quot;../../cmp/trait.eq&quot;&gt; &lt;code&gt;Eq&lt;/code&gt; &lt;/a&gt; и &lt;a href=&quot;../../hash/trait.hash&quot;&gt; &lt;code&gt;Hash&lt;/code&gt; &lt;/a&gt; . Мы также должны вывести &lt;a href=&quot;../../cmp/trait.partialeq&quot;&gt; &lt;code&gt;PartialEq&lt;/code&gt; &lt;/a&gt; , это в будущем будет подразумеваться &lt;a href=&quot;../../cmp/trait.eq&quot;&gt; &lt;code&gt;Eq&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="bcd32a61d8029373ce3811b4c81b01b04e2fcd8a" translate="yes" xml:space="preserve">
          <source>The easiest way to use &lt;code&gt;HashSet&lt;/code&gt; with a custom type is to derive &lt;a href=&quot;../cmp/trait.eq&quot;&gt;&lt;code&gt;Eq&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../hash/trait.hash&quot;&gt;&lt;code&gt;Hash&lt;/code&gt;&lt;/a&gt;. We must also derive &lt;a href=&quot;../cmp/trait.partialeq&quot;&gt;&lt;code&gt;PartialEq&lt;/code&gt;&lt;/a&gt;, this will in the future be implied by &lt;a href=&quot;../cmp/trait.eq&quot;&gt;&lt;code&gt;Eq&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Самый простой способ использовать &lt;code&gt;HashSet&lt;/code&gt; с настраиваемым типом - это получить &lt;a href=&quot;../cmp/trait.eq&quot;&gt; &lt;code&gt;Eq&lt;/code&gt; &lt;/a&gt; и &lt;a href=&quot;../hash/trait.hash&quot;&gt; &lt;code&gt;Hash&lt;/code&gt; &lt;/a&gt; . Мы также должны вывести &lt;a href=&quot;../cmp/trait.partialeq&quot;&gt; &lt;code&gt;PartialEq&lt;/code&gt; &lt;/a&gt; , это в будущем будет подразумеваться &lt;a href=&quot;../cmp/trait.eq&quot;&gt; &lt;code&gt;Eq&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="4abca09eae529f079207e693c4204e4240160458" translate="yes" xml:space="preserve">
          <source>The element range is removed even if the iterator is not consumed until the end.</source>
          <target state="translated">Диапазон элементов снимается,даже если итератор не расходуется до конца.</target>
        </trans-unit>
        <trans-unit id="857f1367d5858bf310bc19ad475cfec76822e623" translate="yes" xml:space="preserve">
          <source>The element that was removed is returned, and the cursor is moved to point to the next element in the &lt;code&gt;LinkedList&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="17d488f8279ef9d0e051cac2f43dff0a68f18b2b" translate="yes" xml:space="preserve">
          <source>The elements are removed in arbitrary order.</source>
          <target state="translated">Элементы удаляются в произвольном порядке.</target>
        </trans-unit>
        <trans-unit id="5fe5f813b6a2f233abc73bad03a94ec158695239" translate="yes" xml:space="preserve">
          <source>The elements at &lt;code&gt;old_len..new_len&lt;/code&gt; must be initialized.</source>
          <target state="translated">Элементы в &lt;code&gt;old_len..new_len&lt;/code&gt; должны быть инициализированы.</target>
        </trans-unit>
        <trans-unit id="2bafc31dee9d33ba4d10ed67ef0f71ab38bfff69" translate="yes" xml:space="preserve">
          <source>The elements of an &lt;a href=&quot;types/array&quot;&gt;array&lt;/a&gt; or owned &lt;a href=&quot;types/array&quot;&gt;slice&lt;/a&gt; are dropped from the first element to the last. *</source>
          <target state="translated">Элементы &lt;a href=&quot;types/array&quot;&gt;массива&lt;/a&gt; или принадлежащего &lt;a href=&quot;types/array&quot;&gt;среза&lt;/a&gt; удаляются с первого элемента до последнего. *</target>
        </trans-unit>
        <trans-unit id="1e3e69cc26857f9c1293b40c529b047e54164338" translate="yes" xml:space="preserve">
          <source>The elements of an &lt;a href=&quot;types/array&quot;&gt;array&lt;/a&gt; or owned &lt;a href=&quot;types/slice&quot;&gt;slice&lt;/a&gt; are dropped from the first element to the last.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2aa9bb19de05cfdf90da669db74c8f4ff87b16d5" translate="yes" xml:space="preserve">
          <source>The elements yielded by &lt;code&gt;DoubleEndedIterator&lt;/code&gt;'s methods may differ from the ones yielded by &lt;a href=&quot;trait.iterator&quot;&gt;&lt;code&gt;Iterator&lt;/code&gt;&lt;/a&gt;'s methods:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="88efd616f1a1b2e8d8f2dcc3a848a8c623471404" translate="yes" xml:space="preserve">
          <source>The elision rules don&amp;rsquo;t provide full inference. If Rust deterministically applies the rules but there is still ambiguity as to what lifetimes the references have, the compiler won&amp;rsquo;t guess what the lifetime of the remaining references should be. In this case, instead of guessing, the compiler will give you an error that you can resolve by adding the lifetime annotations that specify how the references relate to each other.</source>
          <target state="translated">Правила исключения не обеспечивают полного вывода. Если Rust детерминированно применяет правила, но все еще остается неясность относительно того, какое время жизни имеют ссылки, компилятор не угадывает, каким должно быть время жизни оставшихся ссылок. В этом случае вместо того, чтобы угадывать, компилятор выдаст вам ошибку, которую вы можете решить, добавив аннотации времени жизни, которые определяют, как ссылки связаны друг с другом.</target>
        </trans-unit>
        <trans-unit id="3e3b658969dac70797ae99e22406a5919df5b0c6" translate="yes" xml:space="preserve">
          <source>The entire expression uses the given values for the fields that were specified and moves or copies the remaining fields from the base expression. As with all struct expressions, all of the fields of the struct must be &lt;a href=&quot;../visibility-and-privacy&quot;&gt;visible&lt;/a&gt;, even those not explicitly named.</source>
          <target state="translated">Все выражение использует данные значения для указанных полей и перемещает или копирует оставшиеся поля из базового выражения. Как и во всех выражениях структуры, все поля структуры должны быть &lt;a href=&quot;../visibility-and-privacy&quot;&gt;видимыми&lt;/a&gt; , даже те, которые явно не названы.</target>
        </trans-unit>
        <trans-unit id="a0574dfce03935016b1e7370699d140878e68385" translate="yes" xml:space="preserve">
          <source>The entire file name if the file name begins with &lt;code&gt;.&lt;/code&gt; and has no other &lt;code&gt;.&lt;/code&gt;s within;</source>
          <target state="translated">Полное имя файла, если имя файла начинается с &lt;code&gt;.&lt;/code&gt; и другого нет &lt;code&gt;.&lt;/code&gt; с внутри;</target>
        </trans-unit>
        <trans-unit id="e83cf0228defdcd6e7afea0984d3278d36eab74c" translate="yes" xml:space="preserve">
          <source>The entire file name if there is no embedded &lt;code&gt;.&lt;/code&gt;;</source>
          <target state="translated">Полное имя файла, если нет встроенного &lt;code&gt;.&lt;/code&gt; ;</target>
        </trans-unit>
        <trans-unit id="3fa274546f438640798ab62aae39ac18398db5cc" translate="yes" xml:space="preserve">
          <source>The entire function</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8a5d709e7f69a77cb8061cae38e47a941e97332f" translate="yes" xml:space="preserve">
          <source>The entire function body.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5c15c39c685d0906fec325e3d5c2bea1c6eb708a" translate="yes" xml:space="preserve">
          <source>The entire function scope is the outer most scope.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9b8eedec31f30287b3b74ad1f2675a525e2c3cf5" translate="yes" xml:space="preserve">
          <source>The entire hash map is generic over a key type &lt;code&gt;K&lt;/code&gt;. Because these keys are stored with the hash map, this type has to own the key&amp;rsquo;s data. When inserting a key-value pair, the map is given such a &lt;code&gt;K&lt;/code&gt; and needs to find the correct hash bucket and check if the key is already present based on that &lt;code&gt;K&lt;/code&gt;. It therefore requires &lt;code&gt;K: Hash + Eq&lt;/code&gt;.</source>
          <target state="translated">Вся хэш - карта является общей над ключевым типом &lt;code&gt;K&lt;/code&gt; . Поскольку эти ключи хранятся с хэш-картой, этот тип должен владеть данными ключа. При вставке пары ключ-значение, карта дается такое &lt;code&gt;K&lt;/code&gt; и потребности , чтобы найти правильный хэш ведро и проверить , если ключ уже присутствует на основе этого &lt;code&gt;K&lt;/code&gt; . Поэтому требуется &lt;code&gt;K: Hash + Eq&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0297c1c788a21e67f6b7fde15406ec3888485937" translate="yes" xml:space="preserve">
          <source>The entire memory range of this slice must be contained within a single allocated object! Slices can never span across multiple allocated objects.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d250d768cfabd095635656557072ab76a1e3cbad" translate="yes" xml:space="preserve">
          <source>The entire memory range of this slice must be contained within a single allocated object! Slices can never span across multiple allocated objects. See &lt;a href=&quot;#incorrect-usage&quot;&gt;below&lt;/a&gt; for an example incorrectly not taking this into account.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="97dea0260f138033ef7cf2f5ca57a634d6eea616" translate="yes" xml:space="preserve">
          <source>The entry point of the program was marked as &lt;code&gt;async&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="82f98df6718e5a9d6fd411d1cc853597af7467ed" translate="yes" xml:space="preserve">
          <source>The error and the note tell the story: Rust strings don&amp;rsquo;t support indexing. But why not? To answer that question, we need to discuss how Rust stores strings in memory.</source>
          <target state="translated">Ошибка и примечание рассказывают историю: строки Rust не поддерживают индексацию. Но почему нет? Чтобы ответить на этот вопрос, нам нужно обсудить, как Rust хранит строки в памяти.</target>
        </trans-unit>
        <trans-unit id="41a72aa86a9d9e55bed7f9841f1b9fdc25696e6c" translate="yes" xml:space="preserve">
          <source>The error happens on numeric literals and on numeric bindings without an identified concrete type:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1decc58ff466451824639b9b2033b046dfa94fee" translate="yes" xml:space="preserve">
          <source>The error happens on numeric literals:</source>
          <target state="translated">Ошибка происходит на цифровых буквах:</target>
        </trans-unit>
        <trans-unit id="39121a17de405ba30c8238c549d55b70becaf449" translate="yes" xml:space="preserve">
          <source>The error indicates that Rust expected a &lt;code&gt;bool&lt;/code&gt; but got an integer. Unlike languages such as Ruby and JavaScript, Rust will not automatically try to convert non-Boolean types to a Boolean. You must be explicit and always provide &lt;code&gt;if&lt;/code&gt; with a Boolean as its condition. If we want the &lt;code&gt;if&lt;/code&gt; code block to run only when a number is not equal to &lt;code&gt;0&lt;/code&gt;, for example, we can change the &lt;code&gt;if&lt;/code&gt; expression to the following:</source>
          <target state="translated">Ошибка указывает на то, что Rust ожидал &lt;code&gt;bool&lt;/code&gt; но получил целое число. В отличие от таких языков, как Ruby и JavaScript, Rust не будет автоматически пытаться преобразовать не-логические типы в логические. Вы должны быть явными и всегда указывать &lt;code&gt;if&lt;/code&gt; с логическим значением в качестве условия. Если мы хотим, &lt;code&gt;if&lt;/code&gt; блок кода if запускался, например, только тогда, когда число не равно &lt;code&gt;0&lt;/code&gt; , мы можем изменить выражение &lt;code&gt;if&lt;/code&gt; на следующее:</target>
        </trans-unit>
        <trans-unit id="82fe814b563c83c1ad42c2a44464d60e45abeb59" translate="yes" xml:space="preserve">
          <source>The error message indicates that the cause of the error is that you &lt;code&gt;cannot assign twice to immutable variable x&lt;/code&gt;, because you tried to assign a second value to the immutable &lt;code&gt;x&lt;/code&gt; variable.</source>
          <target state="translated">Сообщение об ошибке указывает, что причина ошибки в том, что вы &lt;code&gt;cannot assign twice to immutable variable x&lt;/code&gt; , потому что вы пытались присвоить второе значение неизменной переменной &lt;code&gt;x&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1acd99d552c691a91137d21fedf0cc394ac8a4d0" translate="yes" xml:space="preserve">
          <source>The error message states that the &lt;code&gt;counter&lt;/code&gt; value is moved into the closure and then captured when we call &lt;code&gt;lock&lt;/code&gt;. That description sounds like what we wanted, but it&amp;rsquo;s not allowed!</source>
          <target state="translated">В сообщении об ошибке указано, что значение &lt;code&gt;counter&lt;/code&gt; перемещается в замыкание, а затем фиксируется, когда мы вызываем &lt;code&gt;lock&lt;/code&gt; . Это описание звучит так, как мы хотели, но это запрещено!</target>
        </trans-unit>
        <trans-unit id="5bb7a0ad71457e0f1d6ce226ce7b55ec5697ceba" translate="yes" xml:space="preserve">
          <source>The error message states that the &lt;code&gt;counter&lt;/code&gt; value was moved in the previous iteration of the loop. So Rust is telling us that we can&amp;rsquo;t move the ownership of lock &lt;code&gt;counter&lt;/code&gt; into multiple threads. Let&amp;rsquo;s fix the compiler error with a multiple-ownership method we discussed in Chapter 15.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6326b5d7f5ddab487c6090e5e84a18d25a0a3db6" translate="yes" xml:space="preserve">
          <source>The error messages say that module &lt;code&gt;hosting&lt;/code&gt; is private. In other words, we have the correct paths for the &lt;code&gt;hosting&lt;/code&gt; module and the &lt;code&gt;add_to_waitlist&lt;/code&gt; function, but Rust won&amp;rsquo;t let us use them because it doesn&amp;rsquo;t have access to the private sections.</source>
          <target state="translated">В сообщениях об ошибках указано, что &lt;code&gt;hosting&lt;/code&gt; модуля является частным. Другими словами, у нас есть правильные пути для модуля &lt;code&gt;hosting&lt;/code&gt; и функции &lt;code&gt;add_to_waitlist&lt;/code&gt; , но Rust не позволит нам их использовать, потому что у него нет доступа к приватным разделам.</target>
        </trans-unit>
        <trans-unit id="8eb6e3e38ad85be87f507639136fdec21b108288" translate="yes" xml:space="preserve">
          <source>The error occurs because &lt;code&gt;foo&lt;/code&gt; accepts a closure that takes an &lt;code&gt;i32&lt;/code&gt; argument, but in &lt;code&gt;main&lt;/code&gt;, it is passed a closure with a &lt;code&gt;&amp;amp;str&lt;/code&gt; argument.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4df536d23e48c26eec2d844083fbc5169ab15de6" translate="yes" xml:space="preserve">
          <source>The error occurs because keyword &lt;code&gt;yield&lt;/code&gt; can only be used inside the generator literal. This can be fixed by constructing the generator correctly.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5bce45a967fbcca42003bd3fc6c351711632526a" translate="yes" xml:space="preserve">
          <source>The error references the &lt;code&gt;Sized&lt;/code&gt; trait again! Rust doesn&amp;rsquo;t know how much space it will need to store the closure. We saw a solution to this problem earlier. We can use a trait object:</source>
          <target state="translated">Ошибка снова ссылается на &lt;code&gt;Sized&lt;/code&gt; ! Rust не знает, сколько места потребуется для хранения укупорочного средства. Мы видели решение этой проблемы ранее. Мы можем использовать объект-признак:</target>
        </trans-unit>
        <trans-unit id="687172b839a6f9ace430c7922b4119fecbbc273c" translate="yes" xml:space="preserve">
          <source>The error says we&amp;rsquo;re not allowed to mutate a variable&amp;rsquo;s type:</source>
          <target state="translated">Ошибка говорит, что нам не разрешено изменять тип переменной:</target>
        </trans-unit>
        <trans-unit id="4c799801c95c3499262c7f795808c56dd04d3f03" translate="yes" xml:space="preserve">
          <source>The error shows that for &lt;code&gt;result&lt;/code&gt; to be valid for the &lt;code&gt;println!&lt;/code&gt; statement, &lt;code&gt;string2&lt;/code&gt; would need to be valid until the end of the outer scope. Rust knows this because we annotated the lifetimes of the function parameters and return values using the same lifetime parameter &lt;code&gt;'a&lt;/code&gt;.</source>
          <target state="translated">Ошибка показывает, что для того, чтобы &lt;code&gt;result&lt;/code&gt; был действительным для &lt;code&gt;println!&lt;/code&gt; оператор, &lt;code&gt;string2&lt;/code&gt; должна быть действительной до конца внешней области. Rust знает это, потому что мы аннотировали время жизни параметров функции и возвращаемые значения, используя один и тот же параметр времени жизни &lt;code&gt;'a&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="81dd6345e63f7b9b970ec324dc927c2a78ce87e8" translate="yes" xml:space="preserve">
          <source>The error shows that you can&amp;rsquo;t use the keyword &lt;code&gt;match&lt;/code&gt; as the function identifier. To use &lt;code&gt;match&lt;/code&gt; as a function name, you need to use the raw identifier syntax, like this:</source>
          <target state="translated">Ошибка показывает, что вы не можете использовать &lt;code&gt;match&lt;/code&gt; ключевого слова в качестве идентификатора функции. Чтобы использовать &lt;code&gt;match&lt;/code&gt; в качестве имени функции, вам необходимо использовать синтаксис необработанного идентификатора, например:</target>
        </trans-unit>
        <trans-unit id="17031b6288809d4b66c77a71348fe05200b2e1e5" translate="yes" xml:space="preserve">
          <source>The error shows this type &amp;ldquo;has infinite size.&amp;rdquo; The reason is that we&amp;rsquo;ve defined &lt;code&gt;List&lt;/code&gt; with a variant that is recursive: it holds another value of itself directly. As a result, Rust can&amp;rsquo;t figure out how much space it needs to store a &lt;code&gt;List&lt;/code&gt; value. Let&amp;rsquo;s break down why we get this error a bit. First, let&amp;rsquo;s look at how Rust decides how much space it needs to store a value of a non-recursive type.</source>
          <target state="translated">Ошибка показывает, что этот тип &amp;laquo;имеет бесконечный размер&amp;raquo;. Причина в том, что мы определили &lt;code&gt;List&lt;/code&gt; с рекурсивным вариантом: он напрямую содержит другое значение. В результате Rust не может определить, сколько места ему нужно для хранения значения &lt;code&gt;List&lt;/code&gt; . Давайте немного разберемся, почему мы получаем эту ошибку. Во-первых, давайте посмотрим, как Rust определяет, сколько места ему нужно для хранения значения нерекурсивного типа.</target>
        </trans-unit>
        <trans-unit id="ddd69ec9cc85fcc63997c43bed364cf16ee6b3f9" translate="yes" xml:space="preserve">
          <source>The error tells us we can&amp;rsquo;t call &lt;code&gt;join&lt;/code&gt; because we only have a mutable borrow of each &lt;code&gt;worker&lt;/code&gt; and &lt;code&gt;join&lt;/code&gt; takes ownership of its argument. To solve this issue, we need to move the thread out of the &lt;code&gt;Worker&lt;/code&gt; instance that owns &lt;code&gt;thread&lt;/code&gt; so &lt;code&gt;join&lt;/code&gt; can consume the thread. We did this in Listing 17-15: if &lt;code&gt;Worker&lt;/code&gt; holds an &lt;code&gt;Option&amp;lt;thread::JoinHandle&amp;lt;()&amp;gt;&amp;gt;&lt;/code&gt; instead, we can call the &lt;code&gt;take&lt;/code&gt; method on the &lt;code&gt;Option&lt;/code&gt; to move the value out of the &lt;code&gt;Some&lt;/code&gt; variant and leave a &lt;code&gt;None&lt;/code&gt; variant in its place. In other words, a &lt;code&gt;Worker&lt;/code&gt; that is running will have a &lt;code&gt;Some&lt;/code&gt; variant in &lt;code&gt;thread&lt;/code&gt;, and when we want to clean up a &lt;code&gt;Worker&lt;/code&gt;, we&amp;rsquo;ll replace &lt;code&gt;Some&lt;/code&gt; with &lt;code&gt;None&lt;/code&gt; so the &lt;code&gt;Worker&lt;/code&gt; doesn&amp;rsquo;t have a thread to run.</source>
          <target state="translated">Ошибка говорит нам, что мы не можем вызвать &lt;code&gt;join&lt;/code&gt; , потому что у нас есть только изменяемое заимствование каждого &lt;code&gt;worker&lt;/code&gt; и &lt;code&gt;join&lt;/code&gt; становится владельцем своего аргумента. Чтобы решить эту проблему, нам нужно переместить поток из экземпляра &lt;code&gt;Worker&lt;/code&gt; , которому принадлежит &lt;code&gt;thread&lt;/code&gt; чтобы &lt;code&gt;join&lt;/code&gt; могло потреблять поток. Мы сделали это в листинге 17-15: если вместо этого &lt;code&gt;Worker&lt;/code&gt; содержит &lt;code&gt;Option&amp;lt;thread::JoinHandle&amp;lt;()&amp;gt;&amp;gt;&lt;/code&gt; , мы можем вызвать метод &lt;code&gt;take&lt;/code&gt; для &lt;code&gt;Option&lt;/code&gt; , чтобы переместить значение из варианта &lt;code&gt;Some&lt;/code&gt; и оставить вариант &lt;code&gt;None&lt;/code&gt; в свое место. Другими словами, &lt;code&gt;Worker&lt;/code&gt; который выполняется, будет иметь вариант &lt;code&gt;Some&lt;/code&gt; в &lt;code&gt;thread&lt;/code&gt; , и когда мы хотим очистить &lt;code&gt;Worker&lt;/code&gt; , мы заменим &lt;code&gt;Some&lt;/code&gt; на &lt;code&gt;None&lt;/code&gt; , чтобы у &lt;code&gt;Worker&lt;/code&gt; не было потока для запуска.</target>
        </trans-unit>
        <trans-unit id="58b8d8f068cf467e7f55c896bbdf137f3a755bf5" translate="yes" xml:space="preserve">
          <source>The error type for &lt;code&gt;try_reserve&lt;/code&gt; methods.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="458fb320b83d2d5563146d6c64a5e9086c1cdbe5" translate="yes" xml:space="preserve">
          <source>The error type for I/O operations of the &lt;a href=&quot;trait.read&quot;&gt;&lt;code&gt;Read&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;trait.write&quot;&gt;&lt;code&gt;Write&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;trait.seek&quot;&gt;&lt;code&gt;Seek&lt;/code&gt;&lt;/a&gt;, and associated traits.</source>
          <target state="translated">Тип ошибки для операций ввода-вывода для свойств &lt;a href=&quot;trait.read&quot;&gt; &lt;code&gt;Read&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;trait.write&quot;&gt; &lt;code&gt;Write&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;trait.seek&quot;&gt; &lt;code&gt;Seek&lt;/code&gt; &lt;/a&gt; и связанных с ними.</target>
        </trans-unit>
        <trans-unit id="3e8c3a7432541c640c48492379ea610ecb40f6ae" translate="yes" xml:space="preserve">
          <source>The error type for errors that can never happen.</source>
          <target state="translated">Тип ошибки для ошибок,которые никогда не могут произойти.</target>
        </trans-unit>
        <trans-unit id="fdb319ec59d1f1964ec642ac851b7301cdf60e57" translate="yes" xml:space="preserve">
          <source>The error type for operations interacting with environment variables. Possibly returned from &lt;a href=&quot;fn.var&quot;&gt;&lt;code&gt;env::var()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="751842d7baf0779231030e01a15db69a4f03c6bc" translate="yes" xml:space="preserve">
          <source>The error type for operations interacting with environment variables. Possibly returned from the &lt;a href=&quot;fn.var&quot;&gt;&lt;code&gt;env::var&lt;/code&gt;&lt;/a&gt; function.</source>
          <target state="translated">Тип ошибки для операций, взаимодействующих с переменными среды. Возможно, возвращается из функции &lt;a href=&quot;fn.var&quot;&gt; &lt;code&gt;env::var&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="11ea1ae6c021101c095eab4ba4b755be8b16c063" translate="yes" xml:space="preserve">
          <source>The error type for operations on the &lt;code&gt;PATH&lt;/code&gt; variable. Possibly returned from &lt;a href=&quot;fn.join_paths&quot;&gt;&lt;code&gt;env::join_paths()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="04e8342895bd312f045a40780238aabb9ef5de36" translate="yes" xml:space="preserve">
          <source>The error type for operations on the &lt;code&gt;PATH&lt;/code&gt; variable. Possibly returned from the &lt;a href=&quot;fn.join_paths&quot;&gt;&lt;code&gt;env::join_paths&lt;/code&gt;&lt;/a&gt; function.</source>
          <target state="translated">Тип ошибки для операций с &lt;code&gt;PATH&lt;/code&gt; . Возможно, возвращено функцией &lt;a href=&quot;fn.join_paths&quot;&gt; &lt;code&gt;env::join_paths&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="92c7e92ce900890826a3bdc04f0bdb6f93a2ae4e" translate="yes" xml:space="preserve">
          <source>The error type returned when a checked integral type conversion fails.</source>
          <target state="translated">Тип ошибки возвращается при неудачном проверочном приведении интегрального типа.</target>
        </trans-unit>
        <trans-unit id="7c03030b0922657a2b23ad871594bf872bfa86e8" translate="yes" xml:space="preserve">
          <source>The error type returned when a conversion from a slice to an array fails.</source>
          <target state="translated">Тип ошибки возвращается при неудачном преобразовании среза в массив.</target>
        </trans-unit>
        <trans-unit id="5bd755e234651b9d8db0dad82d899820eb73c1c6" translate="yes" xml:space="preserve">
          <source>The error type returned when a conversion from u32 to char fails.</source>
          <target state="translated">Тип ошибки возвращается при неудачном преобразовании из u32 в char.</target>
        </trans-unit>
        <trans-unit id="74bd671788812266d70e1e6379cd71d68b83bdd8" translate="yes" xml:space="preserve">
          <source>The error type that results from applying the try operator (&lt;code&gt;?&lt;/code&gt;) to a &lt;code&gt;None&lt;/code&gt; value. If you wish to allow &lt;code&gt;x?&lt;/code&gt; (where &lt;code&gt;x&lt;/code&gt; is an &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt;) to be converted into your error type, you can implement &lt;code&gt;impl From&amp;lt;NoneError&amp;gt;&lt;/code&gt; for &lt;code&gt;YourErrorType&lt;/code&gt;. In that case, &lt;code&gt;x?&lt;/code&gt; within a function that returns &lt;code&gt;Result&amp;lt;_, YourErrorType&amp;gt;&lt;/code&gt; will translate a &lt;code&gt;None&lt;/code&gt; value into an &lt;code&gt;Err&lt;/code&gt; result.</source>
          <target state="translated">Тип ошибки, возникающий в результате применения оператора try ( &lt;code&gt;?&lt;/code&gt; ) К значению &lt;code&gt;None&lt;/code&gt; . Если вы хотите разрешить &lt;code&gt;x?&lt;/code&gt; (где &lt;code&gt;x&lt;/code&gt; - это &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt; ) для преобразования в ваш тип ошибки, вы можете реализовать &lt;code&gt;impl From&amp;lt;NoneError&amp;gt;&lt;/code&gt; для &lt;code&gt;YourErrorType&lt;/code&gt; . В таком случае &lt;code&gt;x?&lt;/code&gt; внутри функции, которая возвращает &lt;code&gt;Result&amp;lt;_, YourErrorType&amp;gt;&lt;/code&gt; преобразует значение &lt;code&gt;None&lt;/code&gt; в результат &lt;code&gt;Err&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="620e9e66f647e7af133c1492023ad78f941762d1" translate="yes" xml:space="preserve">
          <source>The error type which is returned from formatting a message into a stream.</source>
          <target state="translated">Тип ошибки,возвращаемой из форматирования сообщения в поток.</target>
        </trans-unit>
        <trans-unit id="de3d4a50ecffe879839aa645e297acf63f3f41e3" translate="yes" xml:space="preserve">
          <source>The error type which is returned from parsing the type a control message.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d4672a685f085da2d7d7f62486ff4649fbce70a5" translate="yes" xml:space="preserve">
          <source>The errors in Listing 7-6 say that the &lt;code&gt;add_to_waitlist&lt;/code&gt; function is private. The privacy rules apply to structs, enums, functions, and methods as well as modules.</source>
          <target state="translated">Ошибки в листинге 7-6 говорят о том, &lt;code&gt;add_to_waitlist&lt;/code&gt; функция add_to_waitlist является частной. Правила конфиденциальности применяются к структурам, перечислениям, функциям и методам, а также к модулям.</target>
        </trans-unit>
        <trans-unit id="5c9b02894ffaf56c3eee190bd9f4d3e5a18ff962" translate="yes" xml:space="preserve">
          <source>The exact behavior on locking a mutex in the thread which already holds the lock is left unspecified. However, this function will not return on the second call (it might panic or deadlock, for example).</source>
          <target state="translated">Точное поведение при блокировке мьютекса в потоке,который уже держит блокировку,остается неуточненным.Однако эта функция не вернется при втором вызове (например,она может запаниковать или зайти в тупик).</target>
        </trans-unit>
        <trans-unit id="ec573024d9a369fea8772d4967a09d1e972fae0a" translate="yes" xml:space="preserve">
          <source>The exact character(s)</source>
          <target state="translated">Точный характер(ы)</target>
        </trans-unit>
        <trans-unit id="df2f57248767dbedd045941faa73ddbe53944b27" translate="yes" xml:space="preserve">
          <source>The exact order may be useful for tracking external state, like an index.</source>
          <target state="translated">Точный порядок может быть полезен для отслеживания внешнего состояния,например,индекса.</target>
        </trans-unit>
        <trans-unit id="8fe495e6414bd43e7bea5f0003cca50741a5b59b" translate="yes" xml:space="preserve">
          <source>The exact output printed by this macro should not be relied upon and is subject to future changes.</source>
          <target state="translated">На точный вывод,напечатанный с помощью этого макроса,полагаться не следует,и он может быть изменен в будущем.</target>
        </trans-unit>
        <trans-unit id="469498f0144088c9a82cccca15de67704811a8dd" translate="yes" xml:space="preserve">
          <source>The exact text, of course, depends on what files you have in &lt;code&gt;.&lt;/code&gt;.</source>
          <target state="translated">Точный текст, конечно, зависит от того, какие файлы у вас есть &lt;code&gt;.&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="395c851d3758c4daf594b9f6b458c5ca4cd7434f" translate="yes" xml:space="preserve">
          <source>The example in Listing 13-14 separates the creation of the iterator from the use of the iterator in the &lt;code&gt;for&lt;/code&gt; loop. The iterator is stored in the &lt;code&gt;v1_iter&lt;/code&gt; variable, and no iteration takes place at that time. When the &lt;code&gt;for&lt;/code&gt; loop is called using the iterator in &lt;code&gt;v1_iter&lt;/code&gt;, each element in the iterator is used in one iteration of the loop, which prints out each value.</source>
          <target state="translated">Пример в листинге 13-14 отделяет создание итератора от использования итератора в цикле &lt;code&gt;for&lt;/code&gt; . Итератор хранится в переменной &lt;code&gt;v1_iter&lt;/code&gt; , и в это время итерация не выполняется. Когда цикл &lt;code&gt;for&lt;/code&gt; вызывается с использованием итератора в &lt;code&gt;v1_iter&lt;/code&gt; , каждый элемент в итераторе используется в одной итерации цикла, которая выводит каждое значение.</target>
        </trans-unit>
        <trans-unit id="e88d69a7ee7e1056409be12e179c7703287290b1" translate="yes" xml:space="preserve">
          <source>The exception to this idiom is if we&amp;rsquo;re bringing two items with the same name into scope with &lt;code&gt;use&lt;/code&gt; statements, because Rust doesn&amp;rsquo;t allow that. Listing 7-15 shows how to bring two &lt;code&gt;Result&lt;/code&gt; types into scope that have the same name but different parent modules and how to refer to them.</source>
          <target state="translated">Исключением из этой идиомы является то, что мы переносим два элемента с одинаковым именем в область видимости с &lt;code&gt;use&lt;/code&gt; операторов use , потому что Rust этого не допускает. В листинге 7-15 показано, как &lt;code&gt;Result&lt;/code&gt; в область видимости два типа результатов, которые имеют одинаковое имя, но разные родительские модули, и как ссылаться на них.</target>
        </trans-unit>
        <trans-unit id="f9ff06ceaf161b4f26d0944c142b9739231935eb" translate="yes" xml:space="preserve">
          <source>The exception to this is the unit tuple (&lt;code&gt;()&lt;/code&gt;) which is guaranteed as a zero-sized type to have a size of 0 and an alignment of 1.</source>
          <target state="translated">Исключением является единичный кортеж ( &lt;code&gt;()&lt;/code&gt; ), который гарантированно имеет нулевой размер, размер 0 и выравнивание 1.</target>
        </trans-unit>
        <trans-unit id="3dc57cf649d183700b8e68c720c692cad27e1162" translate="yes" xml:space="preserve">
          <source>The expanded expression has type &lt;code&gt;&amp;amp;'static str&lt;/code&gt;, and the returned file is not the invocation of the &lt;code&gt;file!&lt;/code&gt; macro itself, but rather the first macro invocation leading up to the invocation of the &lt;code&gt;file!&lt;/code&gt; macro.</source>
          <target state="translated">Расширенное выражение имеет тип &lt;code&gt;&amp;amp;'static str&lt;/code&gt; , а возвращаемый файл не является его вызовом &lt;code&gt;file!&lt;/code&gt; макрос, а скорее первый вызов макроса, ведущий к вызову &lt;code&gt;file!&lt;/code&gt; макрос.</target>
        </trans-unit>
        <trans-unit id="2027bedff965dc7817b0dd952d1fc211920c5f6d" translate="yes" xml:space="preserve">
          <source>The expanded expression has type &lt;code&gt;u32&lt;/code&gt; and is 1-based, so the first column in each line evaluates to 1, the second to 2, etc. This is consistent with error messages by common compilers or popular editors. The returned column is &lt;em&gt;not necessarily&lt;/em&gt; the line of the &lt;code&gt;column!&lt;/code&gt; invocation itself, but rather the first macro invocation leading up to the invocation of the &lt;code&gt;column!&lt;/code&gt; macro.</source>
          <target state="translated">Расширенное выражение имеет тип &lt;code&gt;u32&lt;/code&gt; и начинается с 1, поэтому первый столбец в каждой строке оценивается как 1, второй - как 2 и т. Д. Это согласуется с сообщениями об ошибках от распространенных компиляторов или популярных редакторов. Возвращаемый столбец &lt;em&gt;не обязательно&lt;/em&gt; является строкой &lt;code&gt;column!&lt;/code&gt; сам вызов, а скорее первый вызов макроса, ведущий к вызову &lt;code&gt;column!&lt;/code&gt; макрос.</target>
        </trans-unit>
        <trans-unit id="b0b06f58ec99c372d86a17a34c7166fa5de08c27" translate="yes" xml:space="preserve">
          <source>The expanded expression has type &lt;code&gt;u32&lt;/code&gt; and is 1-based, so the first line in each file evaluates to 1, the second to 2, etc. This is consistent with error messages by common compilers or popular editors. The returned line is &lt;em&gt;not necessarily&lt;/em&gt; the line of the &lt;code&gt;line!&lt;/code&gt; invocation itself, but rather the first macro invocation leading up to the invocation of the &lt;code&gt;line!&lt;/code&gt; macro.</source>
          <target state="translated">Расширенное выражение имеет тип &lt;code&gt;u32&lt;/code&gt; и начинается с 1, поэтому первая строка в каждом файле оценивается как 1, вторая - как 2 и т. Д. Это согласуется с сообщениями об ошибках распространенных компиляторов или популярных редакторов. Возвращенная строка &lt;em&gt;не обязательно&lt;/em&gt; является строкой &lt;code&gt;line!&lt;/code&gt; сам вызов, а скорее первый вызов макроса, ведущий к вызову &lt;code&gt;line!&lt;/code&gt; макрос.</target>
        </trans-unit>
        <trans-unit id="6dec360ada9c00c421ed26b5b352f032e17122ed" translate="yes" xml:space="preserve">
          <source>The expected cost of &lt;code&gt;push&lt;/code&gt;, averaged over every possible ordering of the elements being pushed, and over a sufficiently large number of pushes, is &lt;em&gt;O&lt;/em&gt;(1). This is the most meaningful cost metric when pushing elements that are &lt;em&gt;not&lt;/em&gt; already in any sorted pattern.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="606b0f6565bb5e33a7e793c7978e5b02d8b8d28b" translate="yes" xml:space="preserve">
          <source>The expected cost of &lt;code&gt;push&lt;/code&gt;, averaged over every possible ordering of the elements being pushed, and over a sufficiently large number of pushes, is O(1). This is the most meaningful cost metric when pushing elements that are &lt;em&gt;not&lt;/em&gt; already in any sorted pattern.</source>
          <target state="translated">Ожидаемая стоимость &lt;code&gt;push&lt;/code&gt; , усредненная по каждому возможному порядку выталкиваемых элементов и за достаточно большое количество нажатий, составляет O (1). Это наиболее значимая метрика стоимости при отправке элементов, которые еще &lt;em&gt;не&lt;/em&gt; входят &lt;em&gt;ни&lt;/em&gt; в один отсортированный шаблон.</target>
        </trans-unit>
        <trans-unit id="a72ec7eef34f0a8ffd7d99e9cfce2da0536188e2" translate="yes" xml:space="preserve">
          <source>The expression above creates a value of type &lt;code&gt;MyUnion&lt;/code&gt; and initializes the storage using field &lt;code&gt;f1&lt;/code&gt;. The union can be accessed using the same syntax as struct fields:</source>
          <target state="translated">Выражение выше создает значение типа &lt;code&gt;MyUnion&lt;/code&gt; и инициализирует хранилище с помощью поля &lt;code&gt;f1&lt;/code&gt; . Доступ к объединению можно получить с помощью того же синтаксиса, что и для полей структуры:</target>
        </trans-unit>
        <trans-unit id="b5fa765f11cc060019641c8e75e38c695bdb1bda" translate="yes" xml:space="preserve">
          <source>The expression cannot be a &lt;a href=&quot;operator-expr#lazy-boolean-operators&quot;&gt;lazy boolean operator expression&lt;/a&gt;. Use of a lazy boolean operator is ambiguous with a planned feature change of the language (the implementation of if-let chains - see &lt;a href=&quot;https://github.com/rust-lang/rfcs/blob/master/text/2497-if-let-chains.md#rollout-plan-and-transitioning-to-rust-2018&quot;&gt;eRFC 2947&lt;/a&gt;). When lazy boolean operator expression is desired, this can be achieved by using parenthesis as below:</source>
          <target state="translated">Выражение не может быть &lt;a href=&quot;operator-expr#lazy-boolean-operators&quot;&gt;выражением ленивого логического оператора&lt;/a&gt; . Использование ленивого логического оператора неоднозначно с запланированным изменением функций языка (реализация цепочек if-let - см. &lt;a href=&quot;https://github.com/rust-lang/rfcs/blob/master/text/2497-if-let-chains.md#rollout-plan-and-transitioning-to-rust-2018&quot;&gt;ERFC 2947&lt;/a&gt; ). Когда требуется ленивое логическое выражение оператора, это может быть достигнуто с помощью скобок, как показано ниже:</target>
        </trans-unit>
        <trans-unit id="a608f321648c235bb5c3f09a506a153d6d9a7fa1" translate="yes" xml:space="preserve">
          <source>The expression for a match arm.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="edc402eeeb9a7639cb3c026b59f168e6cd732965" translate="yes" xml:space="preserve">
          <source>The expression immediately following &lt;code&gt;in&lt;/code&gt; must implement the &lt;a href=&quot;../book/ch13-04-performance&quot;&gt;&lt;code&gt;IntoIterator&lt;/code&gt;&lt;/a&gt; trait.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="64c3c13114c938924165b32b931fcfa0929a3dad" translate="yes" xml:space="preserve">
          <source>The expression in the &lt;code&gt;if&lt;/code&gt; block evaluates to an integer, and the expression in the &lt;code&gt;else&lt;/code&gt; block evaluates to a string. This won&amp;rsquo;t work because variables must have a single type. Rust needs to know at compile time what type the &lt;code&gt;number&lt;/code&gt; variable is, definitively, so it can verify at compile time that its type is valid everywhere we use &lt;code&gt;number&lt;/code&gt;. Rust wouldn&amp;rsquo;t be able to do that if the type of &lt;code&gt;number&lt;/code&gt; was only determined at runtime; the compiler would be more complex and would make fewer guarantees about the code if it had to keep track of multiple hypothetical types for any variable.</source>
          <target state="translated">Выражение в блоке &lt;code&gt;if&lt;/code&gt; оценивается как целое число, а выражение в блоке &lt;code&gt;else&lt;/code&gt; оценивается как строка. Это не сработает, потому что переменные должны иметь один тип. Во время компиляции Rust должен точно знать, к какому типу относится &lt;code&gt;number&lt;/code&gt; переменная, чтобы во время компиляции можно было проверить, что ее тип действителен везде, где мы используем &lt;code&gt;number&lt;/code&gt; . Rust не смог бы этого сделать, если бы тип &lt;code&gt;number&lt;/code&gt; определялся только во время выполнения; компилятор был бы более сложным и дал бы меньше гарантий в отношении кода, если бы ему приходилось отслеживать несколько гипотетических типов для любой переменной.</target>
        </trans-unit>
        <trans-unit id="7947155b0fa5fdbbf2d84b0fb9bff1298adf4bf1" translate="yes" xml:space="preserve">
          <source>The extension is:</source>
          <target state="translated">Расширение:</target>
        </trans-unit>
        <trans-unit id="ea39e7727f6084ef5165d4f9b888542528c3cc1d" translate="yes" xml:space="preserve">
          <source>The external crate is resolved to a specific &lt;code&gt;soname&lt;/code&gt; at compile time, and a runtime linkage requirement to that &lt;code&gt;soname&lt;/code&gt; is passed to the linker for loading at runtime. The &lt;code&gt;soname&lt;/code&gt; is resolved at compile time by scanning the compiler's library path and matching the optional &lt;code&gt;crateid&lt;/code&gt; provided against the &lt;code&gt;crateid&lt;/code&gt; attributes that were declared on the external crate when it was compiled. If no &lt;code&gt;crateid&lt;/code&gt; is provided, a default &lt;code&gt;name&lt;/code&gt; attribute is assumed, equal to the &lt;a href=&quot;../identifiers&quot;&gt;identifier&lt;/a&gt; given in the &lt;code&gt;extern crate&lt;/code&gt; declaration.</source>
          <target state="translated">Внешний ящик &lt;code&gt;soname&lt;/code&gt; в конкретное soname во время компиляции, и требование связывания времени выполнения с этим &lt;code&gt;soname&lt;/code&gt; передается компоновщику для загрузки во время выполнения. &lt;code&gt;soname&lt;/code&gt; разрешено во время компиляции путем сканирования библиотеки пути компилятора и соответствия дополнительного &lt;code&gt;crateid&lt;/code&gt; при условии против &lt;code&gt;crateid&lt;/code&gt; атрибутов , которые были признаны на внешнем ящике , когда он был собран. Если &lt;code&gt;crateid&lt;/code&gt; не указан , предполагается атрибут &lt;code&gt;name&lt;/code&gt; умолчанию , равный &lt;a href=&quot;../identifiers&quot;&gt;идентификатору,&lt;/a&gt; указанному в объявлении &lt;code&gt;extern crate&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2d4ff9b9a673e6ef5c73fd0d74de95c1584abb9d" translate="yes" xml:space="preserve">
          <source>The failure message indicates that this test did indeed panic as we expected, but the panic message did not include the expected string &lt;code&gt;'Guess value must be less than or equal to 100'&lt;/code&gt;. The panic message that we did get in this case was &lt;code&gt;Guess value must be greater than or equal to 1, got 200.&lt;/code&gt; Now we can start figuring out where our bug is!</source>
          <target state="translated">Сообщение об ошибке указывает на то, что этот тест действительно вызвал панику, как мы и ожидали, но сообщение о панике не включало ожидаемую строку &lt;code&gt;'Guess value must be less than or equal to 100'&lt;/code&gt; . Паническое сообщение, которое мы получили в этом случае, заключалось в том, что &lt;code&gt;Guess value must be greater than or equal to 1, got 200.&lt;/code&gt; Теперь мы можем начать выяснять, где находится наша ошибка!</target>
        </trans-unit>
        <trans-unit id="1264d4255ef5d1877747639a91dce97d95706422" translate="yes" xml:space="preserve">
          <source>The family of the operating system. Example value is &lt;code&gt;unix&lt;/code&gt;.</source>
          <target state="translated">Семейство операционной системы. Пример значения - &lt;code&gt;unix&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1f19a750b2fcc57343d113fae5c2d35cbbeabd61" translate="yes" xml:space="preserve">
          <source>The field names can be decimal integer values to specify indices for constructing tuple structs. This can be used with base structs to fill out the remaining indices not specified:</source>
          <target state="translated">Имена полей могут быть десятичными целыми значениями для указания индексов для построения структур кортежей.Это может быть использовано с базовыми структурами для заполнения оставшихся не указанными индексами:</target>
        </trans-unit>
        <trans-unit id="0bbc5c6747805ec7b206ff1d7bd4fc19a67e98d4" translate="yes" xml:space="preserve">
          <source>The fields of a &lt;a href=&quot;types/struct&quot;&gt;struct&lt;/a&gt; are dropped in declaration order.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c1e05fef4f32d53e63c8251d9d852a226e0b9d94" translate="yes" xml:space="preserve">
          <source>The fields of a &lt;a href=&quot;types/struct&quot;&gt;struct&lt;/a&gt;, &lt;a href=&quot;types/tuple&quot;&gt;tuple&lt;/a&gt; or &lt;a href=&quot;types/enum&quot;&gt;enum variant&lt;/a&gt; are dropped in declaration order. *</source>
          <target state="translated">Поля &lt;a href=&quot;types/enum&quot;&gt;варианта &lt;/a&gt;&lt;a href=&quot;types/struct&quot;&gt;структуры&lt;/a&gt; , &lt;a href=&quot;types/tuple&quot;&gt;кортежа&lt;/a&gt; или перечисления удаляются в порядке объявления. *</target>
        </trans-unit>
        <trans-unit id="ad3f74fe8b6e787f7b7254796fcea650c623bbf0" translate="yes" xml:space="preserve">
          <source>The fields of a &lt;a href=&quot;types/tuple&quot;&gt;tuple&lt;/a&gt; are dropped in order.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="985befbf65bb726fbdc7e8fa5788956f4d2e4bf1" translate="yes" xml:space="preserve">
          <source>The fields of a &lt;code&gt;struct&lt;/code&gt; may be qualified by &lt;a href=&quot;../visibility-and-privacy&quot;&gt;visibility modifiers&lt;/a&gt;, to allow access to data in a struct outside a module.</source>
          <target state="translated">Поля &lt;code&gt;struct&lt;/code&gt; могут быть &lt;a href=&quot;../visibility-and-privacy&quot;&gt;уточнены модификаторами видимости&lt;/a&gt; , чтобы разрешить доступ к данным в структуре вне модуля.</target>
        </trans-unit>
        <trans-unit id="d44253ff03665f86e16760d6d12a49f11125c4e2" translate="yes" xml:space="preserve">
          <source>The fields of the active &lt;a href=&quot;types/enum&quot;&gt;enum variant&lt;/a&gt; are dropped in declaration order.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="40ccc036f7a6ce305846dd9b315fdf1f96b15a3b" translate="yes" xml:space="preserve">
          <source>The fields of this struct show that the Rust code we&amp;rsquo;ve parsed is a unit struct with the &lt;code&gt;ident&lt;/code&gt; (identifier, meaning the name) of &lt;code&gt;Pancakes&lt;/code&gt;. There are more fields on this struct for describing all sorts of Rust code; check the &lt;a href=&quot;https://docs.rs/syn/0.14.4/syn/struct.DeriveInput.html&quot;&gt;&lt;code&gt;syn&lt;/code&gt; documentation for &lt;code&gt;DeriveInput&lt;/code&gt;&lt;/a&gt; for more information.</source>
          <target state="translated">Поля этой структуры показывают, что код Rust, который мы проанализировали, представляет собой единичную структуру с &lt;code&gt;ident&lt;/code&gt; (идентификатором, означающим имя) &lt;code&gt;Pancakes&lt;/code&gt; . В этой структуре есть больше полей для описания всех видов кода Rust; проверить &lt;a href=&quot;https://docs.rs/syn/0.14.4/syn/struct.DeriveInput.html&quot;&gt; &lt;code&gt;syn&lt;/code&gt; документацию для &lt;code&gt;DeriveInput&lt;/code&gt; &lt;/a&gt; для получения дополнительной информации.</target>
        </trans-unit>
        <trans-unit id="b0794c80e766c7ef30098e79990a99a126d86062" translate="yes" xml:space="preserve">
          <source>The fields of this struct show that the Rust code we&amp;rsquo;ve parsed is a unit struct with the &lt;code&gt;ident&lt;/code&gt; (identifier, meaning the name) of &lt;code&gt;Pancakes&lt;/code&gt;. There are more fields on this struct for describing all sorts of Rust code; check the &lt;a href=&quot;https://docs.rs/syn/1.0/syn/struct.DeriveInput.html&quot;&gt;&lt;code&gt;syn&lt;/code&gt; documentation for &lt;code&gt;DeriveInput&lt;/code&gt;&lt;/a&gt; for more information.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="41f21e4814cce1d92447f83c7dd9a65499d60626" translate="yes" xml:space="preserve">
          <source>The file doesn't exist.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c618b2bfdd921c07e86f2a30b8c3ccd4f98ae789" translate="yes" xml:space="preserve">
          <source>The file is located relative to the current file (similarly to how modules are found).</source>
          <target state="translated">Файл расположен относительно текущего файла (аналогично тому,как находятся модули).</target>
        </trans-unit>
        <trans-unit id="0630128fbb4da19cb239333b356fc43bbab7e18f" translate="yes" xml:space="preserve">
          <source>The file is located relative to the current file (similarly to how modules are found). The provided path is interpreted in a platform-specific way at compile time. So, for instance, an invocation with a Windows path containing backslashes &lt;code&gt;\&lt;/code&gt; would not compile correctly on Unix.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a1df7519bc8cdda06f6336bd152ecc0e5b1b6c7c" translate="yes" xml:space="preserve">
          <source>The file is located relative to the current file. (similarly to how modules are found)</source>
          <target state="translated">Файл расположен относительно текущего файла.(аналогично тому,как находятся модули)</target>
        </trans-unit>
        <trans-unit id="d6c5af6a5c60f4fa56d05a0fa81955ff57e694aa" translate="yes" xml:space="preserve">
          <source>The file must be opened with write access for truncate to work.</source>
          <target state="translated">Файл должен быть открыт с доступом на запись,чтобы он работал в усеченном виде.</target>
        </trans-unit>
        <trans-unit id="b64dc47988604588017060c77446efa88568cbbc" translate="yes" xml:space="preserve">
          <source>The file must be opened with write or append access in order to create a new file.</source>
          <target state="translated">Файл должен быть открыт с доступом на запись или приложением для создания нового файла.</target>
        </trans-unit>
        <trans-unit id="55a4d79c2d543091872b4da347b5d4b201da5902" translate="yes" xml:space="preserve">
          <source>The file's cursor isn't changed. In particular, if the cursor was at the end and the file is shrunk using this operation, the cursor will now be past the end.</source>
          <target state="translated">Курсор файла не изменился.В частности,если курсор был в конце,и файл был сжат с помощью этой операции,то теперь курсор будет проходить мимо конца.</target>
        </trans-unit>
        <trans-unit id="6c8ba754d920c70b815c96a59ae89e2ab19e9615" translate="yes" xml:space="preserve">
          <source>The fill character is provided normally in conjunction with the &lt;a href=&quot;#width&quot;&gt;&lt;code&gt;width&lt;/code&gt;&lt;/a&gt; parameter. This indicates that if the value being formatted is smaller than &lt;code&gt;width&lt;/code&gt; some extra characters will be printed around it. The extra characters are specified by &lt;code&gt;fill&lt;/code&gt;, and the alignment can be one of the following options:</source>
          <target state="translated">Символ заполнения обычно предоставляется вместе с параметром &lt;a href=&quot;#width&quot;&gt; &lt;code&gt;width&lt;/code&gt; &lt;/a&gt; . Это означает, что если форматируемое значение меньше &lt;code&gt;width&lt;/code&gt; вокруг него будут напечатаны дополнительные символы. Дополнительные символы указываются &lt;code&gt;fill&lt;/code&gt; , а выравнивание может быть одним из следующих вариантов:</target>
        </trans-unit>
        <trans-unit id="85f2c169cb253978c0bcbcb827b4f9bdee23de08" translate="yes" xml:space="preserve">
          <source>The final action that works only with &lt;code&gt;unsafe&lt;/code&gt; is accessing fields of a &lt;em&gt;union&lt;/em&gt;. A &lt;code&gt;union&lt;/code&gt; is similar to a &lt;code&gt;struct&lt;/code&gt;, but only one declared field is used in a particular instance at one time. Unions are primarily used to interface with unions in C code. Accessing union fields is unsafe because Rust can&amp;rsquo;t guarantee the type of the data currently being stored in the union instance. You can learn more about unions in &lt;a href=&quot;../reference/items/unions&quot;&gt;the reference&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="93dbdf12316da4d04bf621e9eb356e67a9dd2780" translate="yes" xml:space="preserve">
          <source>The final action that works only with &lt;code&gt;unsafe&lt;/code&gt; is implementing an unsafe trait. A trait is unsafe when at least one of its methods has some invariant that the compiler can&amp;rsquo;t verify. We can declare that a trait is &lt;code&gt;unsafe&lt;/code&gt; by adding the &lt;code&gt;unsafe&lt;/code&gt; keyword before &lt;code&gt;trait&lt;/code&gt; and marking the implementation of the trait as &lt;code&gt;unsafe&lt;/code&gt; too, as shown in Listing 19-11.</source>
          <target state="translated">Последнее действие, которое работает только с &lt;code&gt;unsafe&lt;/code&gt; - это реализация свойства unsafe. Признак небезопасен, если хотя бы один из его методов имеет инвариант, который компилятор не может проверить. Мы можем объявить трейт &lt;code&gt;unsafe&lt;/code&gt; , добавив ключевое слово &lt;code&gt;unsafe&lt;/code&gt; перед &lt;code&gt;trait&lt;/code&gt; и пометив реализацию трейта как &lt;code&gt;unsafe&lt;/code&gt; , как показано в листинге 19-11.</target>
        </trans-unit>
        <trans-unit id="49a4f7cf0e0e66e3c555d75f0978be5130fe5dec" translate="yes" xml:space="preserve">
          <source>The final expression of any extending &lt;a href=&quot;expressions/block-expr&quot;&gt;block expression&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5d305704a4fbc5372e6355348bdb324639855c0b" translate="yes" xml:space="preserve">
          <source>The final line ending is optional.</source>
          <target state="translated">Окончание последней строки необязательно.</target>
        </trans-unit>
        <trans-unit id="7bcad5659fa398bc4723e1a1e4ec534359f32934" translate="yes" xml:space="preserve">
          <source>The final line ending is optional. A string that ends with a final line ending will return the same lines as an otherwise identical string without a final line ending.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d405e4ac4031d3643938bc829210c93b1a171c2a" translate="yes" xml:space="preserve">
          <source>The final line ending isn't required:</source>
          <target state="translated">Окончание последней строки не требуется:</target>
        </trans-unit>
        <trans-unit id="c5271e27e91796af655967c8ffbfa429a17a75cb" translate="yes" xml:space="preserve">
          <source>The final result could be determined just by looking at the code at compile time, so &lt;a href=&quot;https://en.wikipedia.org/wiki/Constant_folding&quot;&gt;constant folding&lt;/a&gt; might turn the whole block into a simple &lt;code&gt;println!(&quot;7 4 4&quot;)&lt;/code&gt;.</source>
          <target state="translated">Конечный результат можно определить, просто взглянув на код во время компиляции, поэтому &lt;a href=&quot;https://en.wikipedia.org/wiki/Constant_folding&quot;&gt;сворачивание констант&lt;/a&gt; может превратить весь блок в простой &lt;code&gt;println!(&quot;7 4 4&quot;)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4e59d9d4ed7f661f21e1daf6cf7e1143fd8d7bfa" translate="yes" xml:space="preserve">
          <source>The first &lt;code&gt;Cons&lt;/code&gt; value holds &lt;code&gt;1&lt;/code&gt; and another &lt;code&gt;List&lt;/code&gt; value. This &lt;code&gt;List&lt;/code&gt; value is another &lt;code&gt;Cons&lt;/code&gt; value that holds &lt;code&gt;2&lt;/code&gt; and another &lt;code&gt;List&lt;/code&gt; value. This &lt;code&gt;List&lt;/code&gt; value is one more &lt;code&gt;Cons&lt;/code&gt; value that holds &lt;code&gt;3&lt;/code&gt; and a &lt;code&gt;List&lt;/code&gt; value, which is finally &lt;code&gt;Nil&lt;/code&gt;, the non-recursive variant that signals the end of the list.</source>
          <target state="translated">Первое значение &lt;code&gt;Cons&lt;/code&gt; содержит &lt;code&gt;1&lt;/code&gt; и другое значение &lt;code&gt;List&lt;/code&gt; . Это значение &lt;code&gt;List&lt;/code&gt; является еще одним значением &lt;code&gt;Cons&lt;/code&gt; , содержащим &lt;code&gt;2&lt;/code&gt; и еще одно значение &lt;code&gt;List&lt;/code&gt; . Это значение &lt;code&gt;List&lt;/code&gt; является еще одним значением &lt;code&gt;Cons&lt;/code&gt; , содержащим &lt;code&gt;3&lt;/code&gt; , и значением &lt;code&gt;List&lt;/code&gt; , которым, наконец, является &lt;code&gt;Nil&lt;/code&gt; , нерекурсивный вариант, который сигнализирует о конце списка.</target>
        </trans-unit>
        <trans-unit id="b8427aa75fccc52f421b7262b47d3cb66ca8ba99" translate="yes" xml:space="preserve">
          <source>The first &lt;code&gt;length&lt;/code&gt; bytes at &lt;code&gt;buf&lt;/code&gt; need to be valid UTF-8.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b2f6ee38297963ecf451ec169c5ecff0bb88450f" translate="yes" xml:space="preserve">
          <source>The first argument &lt;code&gt;format!&lt;/code&gt; receives is a format string. This must be a string literal. The power of the formatting string is in the &lt;code&gt;{}&lt;/code&gt;s contained.</source>
          <target state="translated">Формат первого аргумента &lt;code&gt;format!&lt;/code&gt; получает - это строка формата. Это должен быть строковый литерал. Мощность строки форматирования заключена в содержащихся &lt;code&gt;{}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="172d64775742c02b6a5a5317561d4368b0242e63" translate="yes" xml:space="preserve">
          <source>The first argument we gave to the &lt;code&gt;assert_eq!&lt;/code&gt; macro, &lt;code&gt;4&lt;/code&gt;, is equal to the result of calling &lt;code&gt;add_two(2)&lt;/code&gt;. The line for this test is &lt;code&gt;test tests::it_adds_two ... ok&lt;/code&gt;, and the &lt;code&gt;ok&lt;/code&gt; text indicates that our test passed!</source>
          <target state="translated">Первый аргумент &lt;code&gt;assert_eq!&lt;/code&gt; макрос, &lt;code&gt;4&lt;/code&gt; , равен результату вызова &lt;code&gt;add_two(2)&lt;/code&gt; . Строка для этого теста - &lt;code&gt;test tests::it_adds_two ... ok&lt;/code&gt; , а текст &lt;code&gt;ok&lt;/code&gt; указывает, что наш тест прошел!</target>
        </trans-unit>
        <trans-unit id="3de15e9c98b000a8208779afdf2f678b58acd245" translate="yes" xml:space="preserve">
          <source>The first arm will match any point that lies on the &lt;code&gt;x&lt;/code&gt; axis by specifying that the &lt;code&gt;y&lt;/code&gt; field matches if its value matches the literal &lt;code&gt;0&lt;/code&gt;. The pattern still creates an &lt;code&gt;x&lt;/code&gt; variable that we can use in the code for this arm.</source>
          <target state="translated">Первая рука будет соответствовать любой точке, которая лежит на оси &lt;code&gt;x&lt;/code&gt; , указав, что поле &lt;code&gt;y&lt;/code&gt; совпадает, если его значение совпадает с литералом &lt;code&gt;0&lt;/code&gt; . Шаблон по-прежнему создает переменную &lt;code&gt;x&lt;/code&gt; , которую мы можем использовать в коде для этой руки.</target>
        </trans-unit>
        <trans-unit id="0d5278ef07d533df9f2058795a528bf65f8762b5" translate="yes" xml:space="preserve">
          <source>The first character is &lt;code&gt;_&lt;/code&gt;.</source>
          <target state="translated">Первый символ - &lt;code&gt;_&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6995348ce355253fb2b3997cb5b666e8341177e1" translate="yes" xml:space="preserve">
          <source>The first character is a letter.</source>
          <target state="translated">Первый иероглиф-буква.</target>
        </trans-unit>
        <trans-unit id="a8c76b012fc5c6ec5d1d2757128af41ec43b821f" translate="yes" xml:space="preserve">
          <source>The first collection type we&amp;rsquo;ll look at is &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt;, also known as a &lt;em&gt;vector&lt;/em&gt;. Vectors allow you to store more than one value in a single data structure that puts all the values next to each other in memory. Vectors can only store values of the same type. They are useful when you have a list of items, such as the lines of text in a file or the prices of items in a shopping cart.</source>
          <target state="translated">Первый тип коллекции, который мы рассмотрим, - это &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; , также известный как &lt;em&gt;вектор&lt;/em&gt; . Векторы позволяют хранить более одного значения в одной структуре данных, которая помещает все значения рядом друг с другом в памяти. Векторы могут хранить значения только одного типа. Они полезны, когда у вас есть список товаров, например строки текста в файле или цены на товары в корзине.</target>
        </trans-unit>
        <trans-unit id="428cb6a8ac810de3963e02d4205a82867bb3d81a" translate="yes" xml:space="preserve">
          <source>The first command creates a new directory called &lt;em&gt;hello_cargo&lt;/em&gt;. We&amp;rsquo;ve named our project &lt;em&gt;hello_cargo&lt;/em&gt;, and Cargo creates its files in a directory of the same name.</source>
          <target state="translated">Первая команда создает новый каталог с именем &lt;em&gt;hello_cargo&lt;/em&gt; . Мы назвали наш проект &lt;em&gt;hello_cargo&lt;/em&gt; , и Cargo создает свои файлы в каталоге с тем же именем.</target>
        </trans-unit>
        <trans-unit id="63eaa7d21eca5ee74b5e72e48aed31081f441d50" translate="yes" xml:space="preserve">
          <source>The first command, &lt;code&gt;cargo new&lt;/code&gt;, takes the name of the project (&lt;code&gt;guessing_game&lt;/code&gt;) as the first argument. The second command changes to the new project&amp;rsquo;s directory.</source>
          <target state="translated">Первая команда, &lt;code&gt;cargo new&lt;/code&gt; , принимает имя проекта ( &lt;code&gt;guessing_game&lt;/code&gt; ) в качестве первого аргумента. Вторая команда переходит в каталог нового проекта.</target>
        </trans-unit>
        <trans-unit id="0041dd0d29e2c266e11aba3af3bc7df1a46ad21b" translate="yes" xml:space="preserve">
          <source>The first element is traditionally the path of the executable, but it can be set to arbitrary text, and it may not even exist, so this property should not be relied upon for security purposes.</source>
          <target state="translated">Первым элементом традиционно является путь исполняемого файла,но он может быть установлен в произвольный текст,и его может даже не существовать,поэтому на это свойство не следует полагаться в целях безопасности.</target>
        </trans-unit>
        <trans-unit id="d1fd88a9bd4f9b97a6544f441d40f72dd7a6a337" translate="yes" xml:space="preserve">
          <source>The first element is traditionally the path of the executable, but it can be set to arbitrary text, and may not even exist. This means this property should not be relied upon for security purposes.</source>
          <target state="translated">Первым элементом традиционно является путь исполняемого файла,но он может быть установлен в произвольный текст,а может даже и не существовать.Это означает,что на это свойство не следует полагаться в целях безопасности.</target>
        </trans-unit>
        <trans-unit id="57c13dc1f835e54c634e0d373f7f324807f9c426" translate="yes" xml:space="preserve">
          <source>The first element was moved out of the array, but this is not possible because &lt;code&gt;NonCopy&lt;/code&gt; does not implement the &lt;code&gt;Copy&lt;/code&gt; trait.</source>
          <target state="translated">Первый элемент был перемещен из массива, но это невозможно, потому что &lt;code&gt;NonCopy&lt;/code&gt; не реализует трейт &lt;code&gt;Copy&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7e08bb0a99fdc3cd6e428394eb70ec134e104b16" translate="yes" xml:space="preserve">
          <source>The first enum shown is the usual kind of enum you'd find in a C-style language. The second shows off a hypothetical example of something storing location data, with &lt;code&gt;Coord&lt;/code&gt; being any other type that's needed, for example a struct. The third example demonstrates the kind of data a variant can store, ranging from nothing, to a tuple, to an anonymous struct.</source>
          <target state="translated">Первое показанное перечисление - это обычный вид перечисления, который вы найдете в языке C-стиля. Второй демонстрирует гипотетический пример того, что что-то хранит данные о местоположении, причем &lt;code&gt;Coord&lt;/code&gt; является любым другим типом, который нужен, например, структурой. Третий пример демонстрирует, какие данные может хранить вариант: от нуля до кортежа и анонимной структуры.</target>
        </trans-unit>
        <trans-unit id="356931433c23df443c1df1a79c8ba26a23e35bf5" translate="yes" xml:space="preserve">
          <source>The first error is in our &lt;code&gt;Drop&lt;/code&gt; implementation. We mentioned earlier that we intended to call &lt;code&gt;take&lt;/code&gt; on the &lt;code&gt;Option&lt;/code&gt; value to move &lt;code&gt;thread&lt;/code&gt; out of &lt;code&gt;worker&lt;/code&gt;. The following changes will do so:</source>
          <target state="translated">Первая ошибка - в нашей реализации &lt;code&gt;Drop&lt;/code&gt; . Ранее мы упоминали, что намеревались вызвать &lt;code&gt;take&lt;/code&gt; для значения &lt;code&gt;Option&lt;/code&gt; , чтобы вывести &lt;code&gt;thread&lt;/code&gt; из &lt;code&gt;worker&lt;/code&gt; . Следующие изменения сделают это:</target>
        </trans-unit>
        <trans-unit id="65b1330f4d7e9b563ff90a9ab4bea0daa6bb9857" translate="yes" xml:space="preserve">
          <source>The first invariant says that whatever actual token that comes after a matcher, if any, must be somewhere in the predetermined follow set. This ensures that a legal macro definition will continue to assign the same determination as to where &lt;code&gt;... tt&lt;/code&gt; ends and &lt;code&gt;uu ...&lt;/code&gt; begins, even as new syntactic forms are added to the language.</source>
          <target state="translated">Первый инвариант говорит, что любой фактический токен, который идет после сопоставителя, если он есть, должен быть где-то в заранее определенном последующем наборе. Это гарантирует, что допустимое определение макроса будет продолжать назначать то же определение, где &lt;code&gt;... tt&lt;/code&gt; заканчивается и &lt;code&gt;uu ...&lt;/code&gt; начинается, даже если в язык добавляются новые синтаксические формы.</target>
        </trans-unit>
        <trans-unit id="5f19def176a50d6a90af45519ada69ee7f97eb7e" translate="yes" xml:space="preserve">
          <source>The first is that it is how much memory must be allocated to store that value.</source>
          <target state="translated">Во-первых,это то,сколько памяти должно быть выделено для хранения этого значения.</target>
        </trans-unit>
        <trans-unit id="beaa6fcb1bf59defe3de830f4f2763f9980dd889" translate="yes" xml:space="preserve">
          <source>The first is to answer a specific question. If you know which chapter answers that question, you can jump to that chapter in the table of contents. Otherwise, you can press &lt;code&gt;s&lt;/code&gt; or the click the magnifying glass on the top bar to search for keywords related to your question. For example, say you wanted to know when a temporary value created in a let statement is dropped. If you didn't already know that the &lt;a href=&quot;expressions#temporaries&quot;&gt;lifetime of temporaries&lt;/a&gt; is defined in the &lt;a href=&quot;expressions&quot;&gt;expressions chapter&lt;/a&gt;, you could search &quot;temporary let&quot; and the first search result will take you to that section.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6fc0f539a4da8814ced28ee34b9432e35dbaf3f6" translate="yes" xml:space="preserve">
          <source>The first is to answer a specific question. If you know which chapter answers that question, you can jump to that chapter in the table of contents. Otherwise, you can press &lt;code&gt;s&lt;/code&gt; or the click the magnifying glass on the top bar to search for keywords related to your question. For example, say you wanted to know when a temporary value created in a let statement is dropped. If you didn't already know that the &lt;a href=&quot;expressions#temporary-lifetimes&quot;&gt;lifetime of temporaries&lt;/a&gt; is defined in the &lt;a href=&quot;expressions&quot;&gt;expressions chapter&lt;/a&gt;, you could search &quot;temporary let&quot; and the first search result will take you to that section.</source>
          <target state="translated">Первый - ответить на конкретный вопрос. Если вы знаете, какая глава отвечает на этот вопрос, вы можете перейти к этой главе в оглавлении. В противном случае вы можете нажать &lt;code&gt;s&lt;/code&gt; или щелкнуть увеличительное стекло на верхней панели для поиска ключевых слов, связанных с вашим вопросом. Например, скажем, вы хотите знать, когда временное значение, созданное в инструкции let, удаляется. Если вы еще не знали, что время &lt;a href=&quot;expressions#temporary-lifetimes&quot;&gt;жизни временных&lt;/a&gt; файлов определено в &lt;a href=&quot;expressions&quot;&gt;главе&lt;/a&gt; о выражениях , вы можете выполнить поиск по запросу &amp;laquo;временный let&amp;raquo;, и первый результат поиска приведет вас к этому разделу.</target>
        </trans-unit>
        <trans-unit id="9d5da3096efb5359ed9929a25c1646ef8f4d3a16" translate="yes" xml:space="preserve">
          <source>The first line is a &lt;em&gt;status line&lt;/em&gt; that contains the HTTP version used in the response, a numeric status code that summarizes the result of the request, and a reason phrase that provides a text description of the status code. After the CRLF sequence are any headers, another CRLF sequence, and the body of the response.</source>
          <target state="translated">Первая строка - это &lt;em&gt;строка состояния,&lt;/em&gt; которая содержит версию HTTP, используемую в ответе, числовой код состояния, который суммирует результат запроса, и фразу причины, которая предоставляет текстовое описание кода состояния. После последовательности CRLF идут любые заголовки, другая последовательность CRLF и тело ответа.</target>
        </trans-unit>
        <trans-unit id="f9ee7ff7ce4ca8fcacdd1bbbd80ae645db3e5b9c" translate="yes" xml:space="preserve">
          <source>The first line is the &lt;em&gt;request line&lt;/em&gt; that holds information about what the client is requesting. The first part of the request line indicates the &lt;em&gt;method&lt;/em&gt; being used, such as &lt;code&gt;GET&lt;/code&gt; or &lt;code&gt;POST&lt;/code&gt;, which describes how the client is making this request. Our client used a &lt;code&gt;GET&lt;/code&gt; request.</source>
          <target state="translated">Первая строка - это &lt;em&gt;строка запроса&lt;/em&gt; , содержащая информацию о том, что запрашивает клиент. Первая часть строки запроса указывает используемый &lt;em&gt;метод&lt;/em&gt; , например &lt;code&gt;GET&lt;/code&gt; или &lt;code&gt;POST&lt;/code&gt; , который описывает, как клиент выполняет этот запрос. Наш клиент использовал запрос &lt;code&gt;GET&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="81a313a5dc649f34279e079a51051be71d71d911" translate="yes" xml:space="preserve">
          <source>The first line shows a function definition, and the second line shows a fully annotated closure definition. The third line removes the type annotations from the closure definition, and the fourth line removes the brackets, which are optional because the closure body has only one expression. These are all valid definitions that will produce the same behavior when they&amp;rsquo;re called.</source>
          <target state="translated">В первой строке показано определение функции, а во второй строке - полностью аннотированное определение замыкания. Третья строка удаляет аннотации типов из определения замыкания, а четвертая строка удаляет скобки, которые являются необязательными, поскольку тело замыкания имеет только одно выражение. Все это действительные определения, которые при вызове вызывают одинаковое поведение.</target>
        </trans-unit>
        <trans-unit id="ee8e9ca51bced15f598c9116a158790ff9d282d7" translate="yes" xml:space="preserve">
          <source>The first line shows a function definition, and the second line shows a fully annotated closure definition. The third line removes the type annotations from the closure definition, and the fourth line removes the brackets, which are optional because the closure body has only one expression. These are all valid definitions that will produce the same behavior when they&amp;rsquo;re called. Calling the closures is required for &lt;code&gt;add_one_v3&lt;/code&gt; and &lt;code&gt;add_one_v4&lt;/code&gt; to be able to compile because the types will be inferred from their usage.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="98148895ad25eccad7c245ba3595f3571d1d992c" translate="yes" xml:space="preserve">
          <source>The first line, &lt;code&gt;[package]&lt;/code&gt;, is a section heading that indicates that the following statements are configuring a package. As we add more information to this file, we&amp;rsquo;ll add other sections.</source>
          <target state="translated">Первая строка, &lt;code&gt;[package]&lt;/code&gt; , - это заголовок раздела, который указывает, что следующие операторы настраивают пакет. По мере добавления дополнительной информации в этот файл мы будем добавлять и другие разделы.</target>
        </trans-unit>
        <trans-unit id="b65c034b9a1653c1664e07497c1d14736ba472ab" translate="yes" xml:space="preserve">
          <source>The first mismatching element defines which sequence is lexicographically less or greater than the other.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8b310676b3019d119c9c467f577a365e7a655455" translate="yes" xml:space="preserve">
          <source>The first new bit here is another &lt;code&gt;use&lt;/code&gt; statement, bringing a type called &lt;code&gt;std::cmp::Ordering&lt;/code&gt; into scope from the standard library. Like &lt;code&gt;Result&lt;/code&gt;, &lt;code&gt;Ordering&lt;/code&gt; is another enum, but the variants for &lt;code&gt;Ordering&lt;/code&gt; are &lt;code&gt;Less&lt;/code&gt;, &lt;code&gt;Greater&lt;/code&gt;, and &lt;code&gt;Equal&lt;/code&gt;. These are the three outcomes that are possible when you compare two values.</source>
          <target state="translated">Первый новый бит здесь - это еще один оператор &lt;code&gt;use&lt;/code&gt; , &lt;code&gt;std::cmp::Ordering&lt;/code&gt; в область видимости тип std :: cmp :: Ordering из стандартной библиотеки. Как и &lt;code&gt;Result&lt;/code&gt; , &lt;code&gt;Ordering&lt;/code&gt; - это еще одно перечисление, но варианты &lt;code&gt;Ordering&lt;/code&gt; : &lt;code&gt;Less&lt;/code&gt; , &lt;code&gt;Greater&lt;/code&gt; и &lt;code&gt;Equal&lt;/code&gt; . Это три результата, которые возможны при сравнении двух значений.</target>
        </trans-unit>
        <trans-unit id="cc86c6e2624cc3af0cff65094ba89e9de1e68ebb" translate="yes" xml:space="preserve">
          <source>The first new line defines the &lt;code&gt;response&lt;/code&gt; variable that holds the success message&amp;rsquo;s data. Then we call &lt;code&gt;as_bytes&lt;/code&gt; on our &lt;code&gt;response&lt;/code&gt; to convert the string data to bytes. The &lt;code&gt;write&lt;/code&gt; method on &lt;code&gt;stream&lt;/code&gt; takes a &lt;code&gt;&amp;amp;[u8]&lt;/code&gt; and sends those bytes directly down the connection.</source>
          <target state="translated">Первая новая строка определяет переменную &lt;code&gt;response&lt;/code&gt; которая содержит данные сообщения об успешном завершении. Затем мы вызываем &lt;code&gt;as_bytes&lt;/code&gt; в нашем &lt;code&gt;response&lt;/code&gt; чтобы преобразовать строковые данные в байты. Метод &lt;code&gt;write&lt;/code&gt; в &lt;code&gt;stream&lt;/code&gt; принимает &lt;code&gt;&amp;amp;[u8]&lt;/code&gt; и отправляет эти байты напрямую по соединению.</target>
        </trans-unit>
        <trans-unit id="155e4331405457b07f19de5018b6f05e551344c8" translate="yes" xml:space="preserve">
          <source>The first one looks much cleaner. This automatic referencing behavior works because methods have a clear receiver&amp;mdash;the type of &lt;code&gt;self&lt;/code&gt;. Given the receiver and name of a method, Rust can figure out definitively whether the method is reading (&lt;code&gt;&amp;amp;self&lt;/code&gt;), mutating (&lt;code&gt;&amp;amp;mut self&lt;/code&gt;), or consuming (&lt;code&gt;self&lt;/code&gt;). The fact that Rust makes borrowing implicit for method receivers is a big part of making ownership ergonomic in practice.</source>
          <target state="translated">Первый выглядит намного чище. Такое поведение автоматической ссылки работает, потому что у методов есть четкий получатель - тип &lt;code&gt;self&lt;/code&gt; . Учитывая получателя и имя метода, Rust может окончательно определить, является ли метод считыванием ( &lt;code&gt;&amp;amp;self&lt;/code&gt; ), изменением ( &lt;code&gt;&amp;amp;mut self&lt;/code&gt; ) или потреблением ( &lt;code&gt;self&lt;/code&gt; ). Тот факт, что Rust делает заимствование неявным образом для приемников методов, является важной частью практической эргономичности владения.</target>
        </trans-unit>
        <trans-unit id="69774098a6b4b7c12621ff37f51e96103a8b7208" translate="yes" xml:space="preserve">
          <source>The first part of the guessing game program will ask for user input, process that input, and check that the input is in the expected form. To start, we&amp;rsquo;ll allow the player to input a guess. Enter the code in Listing 2-1 into &lt;em&gt;src/main.rs&lt;/em&gt;.</source>
          <target state="translated">Первая часть программы игры в угадайку будет запрашивать ввод пользователя, обрабатывать его и проверять, находится ли ввод в ожидаемой форме. Для начала мы позволим игроку ввести предположение. Введите код в листинге 2-1 в &lt;em&gt;SRC / main.rs&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="2750d61c6d5f6fdb7cf8539aba812571a959c619" translate="yes" xml:space="preserve">
          <source>The first parts of the module system we&amp;rsquo;ll cover are packages and crates. A crate is a binary or library. The &lt;em&gt;crate root&lt;/em&gt; is a source file that the Rust compiler starts from and makes up the root module of your crate (we&amp;rsquo;ll explain modules in depth in the &lt;a href=&quot;ch07-02-defining-modules-to-control-scope-and-privacy&quot;&gt;&amp;ldquo;Defining Modules to Control Scope and Privacy&amp;rdquo;&lt;/a&gt; section). A &lt;em&gt;package&lt;/em&gt; is one or more crates that provide a set of functionality. A package contains a &lt;em&gt;Cargo.toml&lt;/em&gt; file that describes how to build those crates.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="84c014079631c14ba610d8bbfcba357c51089179" translate="yes" xml:space="preserve">
          <source>The first parts of the module system we&amp;rsquo;ll cover are packages and crates. A crate is a binary or library. The &lt;em&gt;crate root&lt;/em&gt; is a source file that the Rust compiler starts from and makes up the root module of your crate (we&amp;rsquo;ll explain modules in depth in the &lt;a href=&quot;ch07-02-defining-modules-to-control-scope-and-privacy&quot;&gt;&amp;ldquo;Defining Modules to Control Scope and Privacy&amp;rdquo;&lt;/a&gt;) section. A &lt;em&gt;package&lt;/em&gt; is one or more crates that provide a set of functionality. A package contains a &lt;em&gt;Cargo.toml&lt;/em&gt; file that describes how to build those crates.</source>
          <target state="translated">Первыми частями модульной системы, которые мы рассмотрим, являются пакеты и ящики. Ящик - это двоичный файл или библиотека. &lt;em&gt;Корень клети&lt;/em&gt; является исходным файлом, компилятор Rust начинается и составляет корневой модуль вашего ящика (мы объясним модули в глубине в &lt;a href=&quot;ch07-02-defining-modules-to-control-scope-and-privacy&quot;&gt;&amp;laquo;Defining модули для контроля Scope и конфиденциальности&amp;raquo;&lt;/a&gt; ) раздел. &lt;em&gt;Пакет&lt;/em&gt; представляет собой один или несколько ящиков , которые предоставляют набор функциональных возможностей . Пакет содержит файл &lt;em&gt;Cargo.toml,&lt;/em&gt; который описывает, как &lt;em&gt;собирать&lt;/em&gt; эти ящики.</target>
        </trans-unit>
        <trans-unit id="af7ae34fc30a5ff985eeb202b31d100b9995dad4" translate="yes" xml:space="preserve">
          <source>The first problem is that a &lt;code&gt;Cacher&lt;/code&gt; instance assumes it will always get the same value for the parameter &lt;code&gt;arg&lt;/code&gt; to the &lt;code&gt;value&lt;/code&gt; method. That is, this test of &lt;code&gt;Cacher&lt;/code&gt; will fail:</source>
          <target state="translated">Первая проблема заключается в том , что &lt;code&gt;Cacher&lt;/code&gt; экземпляр предполагает , что он всегда будет получать такое же значение для параметра &lt;code&gt;arg&lt;/code&gt; к &lt;code&gt;value&lt;/code&gt; метода. То есть этот тест &lt;code&gt;Cacher&lt;/code&gt; не удастся:</target>
        </trans-unit>
        <trans-unit id="dafa36fcdade4f5ce81d7dee337248690a10ae6d" translate="yes" xml:space="preserve">
          <source>The first purpose is similar to the second but in reverse: if you want to add a type parameter to an existing trait, you can give it a default to allow extension of the functionality of the trait without breaking the existing implementation code.</source>
          <target state="translated">Первое назначение аналогично второму,но наоборот:если вы хотите добавить параметр типа в существующий трейт,вы можете дать ему по умолчанию разрешение на расширение функциональности трейта без разрыва существующего реализационного кода.</target>
        </trans-unit>
        <trans-unit id="5f5a900754c112ed82386f584763afdd02db421d" translate="yes" xml:space="preserve">
          <source>The first rule is that each parameter that is a reference gets its own lifetime parameter. In other words, a function with one parameter gets one lifetime parameter: &lt;code&gt;fn foo&amp;lt;'a&amp;gt;(x: &amp;amp;'a i32)&lt;/code&gt;; a function with two parameters gets two separate lifetime parameters: &lt;code&gt;fn foo&amp;lt;'a, 'b&amp;gt;(x: &amp;amp;'a i32, y: &amp;amp;'b i32)&lt;/code&gt;; and so on.</source>
          <target state="translated">Первое правило состоит в том, что каждый параметр, являющийся ссылкой, получает свой собственный параметр времени жизни. Другими словами, функция с одним параметром получает один параметр времени жизни: &lt;code&gt;fn foo&amp;lt;'a&amp;gt;(x: &amp;amp;'a i32)&lt;/code&gt; ; функция с двумя параметрами получает два отдельных параметра времени жизни: &lt;code&gt;fn foo&amp;lt;'a, 'b&amp;gt;(x: &amp;amp;'a i32, y: &amp;amp;'b i32)&lt;/code&gt; ; и так далее.</target>
        </trans-unit>
        <trans-unit id="d13f338beec8e6c884aee47f7c30a9f0bc21c5c9" translate="yes" xml:space="preserve">
          <source>The first section of the output shows that the &lt;code&gt;it_works&lt;/code&gt; test in the &lt;code&gt;add-one&lt;/code&gt; crate passed. The next section shows that zero tests were found in the &lt;code&gt;adder&lt;/code&gt; crate, and then the last section shows zero documentation tests were found in the &lt;code&gt;add-one&lt;/code&gt; crate. Running &lt;code&gt;cargo test&lt;/code&gt; in a workspace structured like this one will run the tests for all the crates in the workspace.</source>
          <target state="translated">Первый раздел выходных данных показывает, что тест &lt;code&gt;it_works&lt;/code&gt; в крейте &lt;code&gt;add-one&lt;/code&gt; прошел успешно . В следующем разделе показано, что в ящике &lt;code&gt;adder&lt;/code&gt; было обнаружено ни &lt;code&gt;add-one&lt;/code&gt; теста, а в последнем разделе показано, что в ящике дополнительного устройства не было найдено ни одного теста документации . Выполнение &lt;code&gt;cargo test&lt;/code&gt; в рабочей области со структурой, подобной этой, запустит тесты для всех ящиков в рабочей области.</target>
        </trans-unit>
        <trans-unit id="1aa6d921fdf65cd84a902ac9021b32a10817790a" translate="yes" xml:space="preserve">
          <source>The first step is to build a list of candidate receiver types. Obtain these by repeatedly &lt;a href=&quot;operator-expr#the-dereference-operator&quot;&gt;dereferencing&lt;/a&gt; the receiver expression's type, adding each type encountered to the list, then finally attempting an &lt;a href=&quot;../type-coercions#unsized-coercions&quot;&gt;unsized coercion&lt;/a&gt; at the end, and adding the result type if that is successful. Then, for each candidate &lt;code&gt;T&lt;/code&gt;, add &lt;code&gt;&amp;amp;T&lt;/code&gt; and &lt;code&gt;&amp;amp;mut T&lt;/code&gt; to the list immediately after &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">Первым шагом является создание списка возможных типов приемников. Получите их, многократно &lt;a href=&quot;operator-expr#the-dereference-operator&quot;&gt;разыменуя&lt;/a&gt; тип выражения получателя, добавляя каждый встреченный тип в список, затем, наконец, пытаясь выполнить &lt;a href=&quot;../type-coercions#unsized-coercions&quot;&gt;безразмерное приведение&lt;/a&gt; в конце и добавляя тип результата, если это успешно. Затем для каждого кандидата &lt;code&gt;T&lt;/code&gt; , добавьте &lt;code&gt;&amp;amp;T&lt;/code&gt; и &lt;code&gt;&amp;amp;mut T&lt;/code&gt; в список сразу после &lt;code&gt;T&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7046b8e80cd49555b791ba84b08e3a496f0ebd34" translate="yes" xml:space="preserve">
          <source>The first step is to install Rust. We&amp;rsquo;ll download Rust through &lt;code&gt;rustup&lt;/code&gt;, a command line tool for managing Rust versions and associated tools. You&amp;rsquo;ll need an internet connection for the download.</source>
          <target state="translated">Первый шаг - установить Rust. Мы &lt;code&gt;rustup&lt;/code&gt; Rust через rustup , инструмент командной строки для управления версиями Rust и соответствующими инструментами. Для загрузки вам потребуется подключение к Интернету.</target>
        </trans-unit>
        <trans-unit id="50ad5f65969d8efb886424560b9363334f047aa4" translate="yes" xml:space="preserve">
          <source>The first store to &lt;code&gt;C&lt;/code&gt; might be moved before the store to &lt;code&gt;A&lt;/code&gt; or &lt;code&gt;B&lt;/code&gt;, &lt;em&gt;as if&lt;/em&gt; we had written &lt;code&gt;C = 4; A = 3; B = 4&lt;/code&gt;.</source>
          <target state="translated">Первый магазин в &lt;code&gt;C&lt;/code&gt; может быть перемещен раньше, чем в &lt;code&gt;A&lt;/code&gt; или &lt;code&gt;B&lt;/code&gt; , &lt;em&gt;как если бы&lt;/em&gt; мы написали &lt;code&gt;C = 4; A = 3; B = 4&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0a6ba14d6296fbc087c2dbd538a2ed25e14b36c1" translate="yes" xml:space="preserve">
          <source>The first task is to make &lt;code&gt;minigrep&lt;/code&gt; accept its two command line arguments: the filename and a string to search for. That is, we want to be able to run our program with &lt;code&gt;cargo run&lt;/code&gt;, a string to search for, and a path to a file to search in, like so:</source>
          <target state="translated">Первая задача - заставить &lt;code&gt;minigrep&lt;/code&gt; принимать два аргумента командной строки: имя файла и строку для поиска. То есть мы хотим иметь возможность запускать нашу программу с &lt;code&gt;cargo run&lt;/code&gt; , строкой для поиска и путем к файлу для поиска, например:</target>
        </trans-unit>
        <trans-unit id="31729bd9aa0c04461ab01bb63b4c75c53baddad1" translate="yes" xml:space="preserve">
          <source>The first time we call &lt;code&gt;example_closure&lt;/code&gt; with the &lt;code&gt;String&lt;/code&gt; value, the compiler infers the type of &lt;code&gt;x&lt;/code&gt; and the return type of the closure to be &lt;code&gt;String&lt;/code&gt;. Those types are then locked in to the closure in &lt;code&gt;example_closure&lt;/code&gt;, and we get a type error if we try to use a different type with the same closure.</source>
          <target state="translated">В первый раз, когда мы вызываем &lt;code&gt;example_closure&lt;/code&gt; со значением &lt;code&gt;String&lt;/code&gt; , компилятор определяет тип &lt;code&gt;x&lt;/code&gt; и возвращаемый тип закрытия как &lt;code&gt;String&lt;/code&gt; . Затем эти типы привязаны к замыканию в &lt;code&gt;example_closure&lt;/code&gt; , и мы получим ошибку типа, если попытаемся использовать другой тип с таким же замыканием.</target>
        </trans-unit>
        <trans-unit id="bd2776b4ba26113bcf03f01d82d4cc2a793fc112" translate="yes" xml:space="preserve">
          <source>The first time we call the &lt;code&gt;add_to_waitlist&lt;/code&gt; function in &lt;code&gt;eat_at_restaurant&lt;/code&gt;, we use an absolute path. The &lt;code&gt;add_to_waitlist&lt;/code&gt; function is defined in the same crate as &lt;code&gt;eat_at_restaurant&lt;/code&gt;, which means we can use the &lt;code&gt;crate&lt;/code&gt; keyword to start an absolute path.</source>
          <target state="translated">Первый раз , когда мы называем &lt;code&gt;add_to_waitlist&lt;/code&gt; функции в &lt;code&gt;eat_at_restaurant&lt;/code&gt; , мы используем абсолютный путь. Функция &lt;code&gt;add_to_waitlist&lt;/code&gt; определена в том же ящике, что и &lt;code&gt;eat_at_restaurant&lt;/code&gt; , что означает, что мы можем использовать ключевое слово &lt;code&gt;crate&lt;/code&gt; для начала абсолютного пути.</target>
        </trans-unit>
        <trans-unit id="fcbd8f43979f6a3f91b2e8d0489ac836799ae483" translate="yes" xml:space="preserve">
          <source>The first two cases are the same except for mutability. The first case states that if you have a &lt;code&gt;&amp;amp;T&lt;/code&gt;, and &lt;code&gt;T&lt;/code&gt; implements &lt;code&gt;Deref&lt;/code&gt; to some type &lt;code&gt;U&lt;/code&gt;, you can get a &lt;code&gt;&amp;amp;U&lt;/code&gt; transparently. The second case states that the same deref coercion happens for mutable references.</source>
          <target state="translated">Первые два случая такие же, за исключением изменчивости. В первом случае говорится, что если у вас есть &lt;code&gt;&amp;amp;T&lt;/code&gt; , а &lt;code&gt;T&lt;/code&gt; реализует &lt;code&gt;Deref&lt;/code&gt; для некоторого типа &lt;code&gt;U&lt;/code&gt; , вы можете получить &lt;code&gt;&amp;amp;U&lt;/code&gt; прозрачно. Во втором случае говорится, что такое же принуждение deref происходит для изменяемых ссылок.</target>
        </trans-unit>
        <trans-unit id="286885295f7366f4af40320e50ad88bb3b1732e7" translate="yes" xml:space="preserve">
          <source>The first version of the prelude of The Rust Standard Library.</source>
          <target state="translated">Первая версия прелюдии &quot;Стандартная библиотека &quot;Ржавчина&quot;.</target>
        </trans-unit>
        <trans-unit id="2833ddd57d8c251f327110ae65b75e17455b9bb3" translate="yes" xml:space="preserve">
          <source>The first will contain all indices from &lt;code&gt;[0, mid)&lt;/code&gt; (excluding the index &lt;code&gt;mid&lt;/code&gt; itself) and the second will contain all indices from &lt;code&gt;[mid, len)&lt;/code&gt; (excluding the index &lt;code&gt;len&lt;/code&gt; itself).</source>
          <target state="translated">Первый будет содержать все индексы из &lt;code&gt;[0, mid)&lt;/code&gt; (за исключением самого индекса &lt;code&gt;mid&lt;/code&gt; ), а второй будет содержать все индексы из &lt;code&gt;[mid, len)&lt;/code&gt; (за исключением самого индекса &lt;code&gt;len&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="d13813ed09799c4deb40bb4b4bb042ae0365adde" translate="yes" xml:space="preserve">
          <source>The following &lt;a href=&quot;../attributes&quot;&gt;attributes&lt;/a&gt; affect compile-time limits.</source>
          <target state="translated">Следующие &lt;a href=&quot;../attributes&quot;&gt;атрибуты&lt;/a&gt; влияют на ограничения времени компиляции.</target>
        </trans-unit>
        <trans-unit id="1c0907607a038e19917ef67594e99ddd26567897" translate="yes" xml:space="preserve">
          <source>The following &lt;a href=&quot;../attributes&quot;&gt;attributes&lt;/a&gt; are used for changing how a type can be used.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="53b431e371001b409fc98d06f983cdb135709c0f" translate="yes" xml:space="preserve">
          <source>The following &lt;a href=&quot;../attributes&quot;&gt;attributes&lt;/a&gt; are used for controlling code generation.</source>
          <target state="translated">Следующие &lt;a href=&quot;../attributes&quot;&gt;атрибуты&lt;/a&gt; используются для управления генерацией кода.</target>
        </trans-unit>
        <trans-unit id="26da618b938f5c0f34421c8ac509923a988969a6" translate="yes" xml:space="preserve">
          <source>The following &lt;a href=&quot;../attributes&quot;&gt;attributes&lt;/a&gt; are used for controlling or generating diagnostic messages during compilation.</source>
          <target state="translated">Следующие &lt;a href=&quot;../attributes&quot;&gt;атрибуты&lt;/a&gt; используются для управления или генерации диагностических сообщений во время компиляции.</target>
        </trans-unit>
        <trans-unit id="a094c614790975d250927975ec0fe6928fcd7c3a" translate="yes" xml:space="preserve">
          <source>The following &lt;a href=&quot;../attributes&quot;&gt;attributes&lt;/a&gt; are used for specifying functions for performing tests. Compiling a crate in &quot;test&quot; mode enables building the test functions along with a test harness for executing the tests. Enabling the test mode also enables the &lt;a href=&quot;../conditional-compilation#test&quot;&gt;&lt;code&gt;test&lt;/code&gt; conditional compilation option&lt;/a&gt;.</source>
          <target state="translated">Следующие &lt;a href=&quot;../attributes&quot;&gt;атрибуты&lt;/a&gt; используются для определения функций для выполнения тестов. Компиляция ящика в &amp;laquo;тестовом&amp;raquo; режиме позволяет создавать тестовые функции вместе с тестовой оснасткой для выполнения тестов. Включение тестового режима также включает &lt;a href=&quot;../conditional-compilation#test&quot;&gt;опцию условной компиляции &lt;/a&gt; &lt;code&gt;test&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c6bd6f609f21755a5a941e395bd92f148b7a32a4" translate="yes" xml:space="preserve">
          <source>The following &lt;a href=&quot;../attributes&quot;&gt;attributes&lt;/a&gt; control the behavior of external blocks.</source>
          <target state="translated">Следующие &lt;a href=&quot;../attributes&quot;&gt;атрибуты&lt;/a&gt; управляют поведением внешних блоков.</target>
        </trans-unit>
        <trans-unit id="e4c3204613b4a8b1aeaa7e0d193d03d0b636c5e8" translate="yes" xml:space="preserve">
          <source>The following &lt;code&gt;join_slices&lt;/code&gt; function is &lt;strong&gt;unsound&lt;/strong&gt; ⚠️</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="34e28a9dda5b8f30dd258681b177c05e512cb9ec" translate="yes" xml:space="preserve">
          <source>The following are examples of struct expressions:</source>
          <target state="translated">Ниже приведены примеры структурных выражений:</target>
        </trans-unit>
        <trans-unit id="0cfa813f73eeb4b3df6024040cdcdc9bf704edb3" translate="yes" xml:space="preserve">
          <source>The following code tries to return a closure directly, but it won&amp;rsquo;t compile:</source>
          <target state="translated">Следующий код пытается вернуть закрытие напрямую, но не компилируется:</target>
        </trans-unit>
        <trans-unit id="9fdd790090c328b0bac332ac3bf94fd48a22d310" translate="yes" xml:space="preserve">
          <source>The following coercions are called &lt;code&gt;unsized coercions&lt;/code&gt;, since they relate to converting sized types to unsized types, and are permitted in a few cases where other coercions are not, as described above. They can still happen anywhere else a coercion can occur.</source>
          <target state="translated">Следующие ниже приведения называются &lt;code&gt;unsized coercions&lt;/code&gt; , поскольку они относятся к преобразованию размерных типов в безразмерные типы и разрешены в некоторых случаях, когда другие приведения - нет, как описано выше. Они все еще могут происходить везде, где может произойти принуждение.</target>
        </trans-unit>
        <trans-unit id="5faa68338d0213add2f9ec4c067dc00f82eb825f" translate="yes" xml:space="preserve">
          <source>The following contexts are &lt;em&gt;place expression&lt;/em&gt; contexts:</source>
          <target state="translated">Следующие контексты являются контекстами &lt;em&gt;выражения места&lt;/em&gt; :</target>
        </trans-unit>
        <trans-unit id="a03f434198c8f12dc538595d512c2779094f1534" translate="yes" xml:space="preserve">
          <source>The following example contains a circular dependency between two traits:</source>
          <target state="translated">Следующий пример содержит круговую зависимость между двумя признаками:</target>
        </trans-unit>
        <trans-unit id="19cc88ac0ce4f5388077204fb21e73c4ffb89f2d" translate="yes" xml:space="preserve">
          <source>The following example implements &lt;code&gt;Index&lt;/code&gt; on a read-only &lt;code&gt;NucleotideCount&lt;/code&gt; container, enabling individual counts to be retrieved with index syntax.</source>
          <target state="translated">В следующем примере &lt;code&gt;Index&lt;/code&gt; реализуется для контейнера &lt;code&gt;NucleotideCount&lt;/code&gt; , доступного только для чтения , что позволяет получать отдельные счетчики с помощью синтаксиса индекса.</target>
        </trans-unit>
        <trans-unit id="1e6d78aaf2b8415e3caf24e2fa8603dbd9c8a54c" translate="yes" xml:space="preserve">
          <source>The following example showcases the fact that exclusive access to an &lt;code&gt;UnsafeCell&amp;lt;T&amp;gt;&lt;/code&gt; implies exclusive access to its &lt;code&gt;T&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b79316b13dbff6d7faf92f7fbb6c36c3b4504a1c" translate="yes" xml:space="preserve">
          <source>The following example uses &lt;a href=&quot;enum.option&quot;&gt;&lt;code&gt;Option&lt;/code&gt;&lt;/a&gt; to create an optional box of &lt;a href=&quot;../primitive.i32&quot;&gt;&lt;code&gt;i32&lt;/code&gt;&lt;/a&gt;. Notice that in order to use the inner &lt;a href=&quot;../primitive.i32&quot;&gt;&lt;code&gt;i32&lt;/code&gt;&lt;/a&gt; value first, the &lt;code&gt;check_optional&lt;/code&gt; function needs to use pattern matching to determine whether the box has a value (i.e., it is &lt;a href=&quot;enum.option#variant.Some&quot;&gt;&lt;code&gt;Some(...)&lt;/code&gt;&lt;/a&gt;) or not (&lt;a href=&quot;enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">В следующем примере &lt;a href=&quot;enum.option&quot;&gt; &lt;code&gt;Option&lt;/code&gt; &lt;/a&gt; используется для создания дополнительного блока &lt;a href=&quot;../primitive.i32&quot;&gt; &lt;code&gt;i32&lt;/code&gt; &lt;/a&gt; . Обратите внимание , что для того , чтобы использовать внутреннюю &lt;a href=&quot;../primitive.i32&quot;&gt; &lt;code&gt;i32&lt;/code&gt; &lt;/a&gt; значение первого, то &lt;code&gt;check_optional&lt;/code&gt; потребности функции для использования сопоставления с образцом , чтобы определить , имеет ли поле значение (то есть, это не &lt;a href=&quot;enum.option#variant.Some&quot;&gt; &lt;code&gt;Some(...)&lt;/code&gt; &lt;/a&gt; ) или нет ( &lt;a href=&quot;enum.option#variant.None&quot;&gt; &lt;code&gt;None&lt;/code&gt; &lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="0098b757352995332c14af09f0677dc80f9a0b00" translate="yes" xml:space="preserve">
          <source>The following expressions are constant expressions, so long as any operands are also constant expressions and do not cause any &lt;a href=&quot;destructors&quot;&gt;&lt;code&gt;Drop::drop&lt;/code&gt;&lt;/a&gt; calls to be run.</source>
          <target state="translated">Следующие ниже выражения являются постоянными выражениями, если любые операнды также являются постоянными выражениями и не вызывают выполнения каких-либо вызовов &lt;a href=&quot;destructors&quot;&gt; &lt;code&gt;Drop::drop&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="a4fd2c18c35c909a948ecc39653105d7e64c5323" translate="yes" xml:space="preserve">
          <source>The following expressions are equivalent.</source>
          <target state="translated">Следующие выражения эквивалентны.</target>
        </trans-unit>
        <trans-unit id="f79e25578dbebf348320c4abf5b91615c4d5d3bd" translate="yes" xml:space="preserve">
          <source>The following expressions can be mutable place expression contexts:</source>
          <target state="translated">Следующие выражения могут быть изменяемыми контекстами выражения места:</target>
        </trans-unit>
        <trans-unit id="0e8e60bb585909210311dad5aced6fb1ca9a2411" translate="yes" xml:space="preserve">
          <source>The following illustrates how tokens can be directly matched after matching a &lt;code&gt;tt&lt;/code&gt; fragment:</source>
          <target state="translated">Ниже показано, как токены могут быть напрямую сопоставлены после сопоставления фрагмента &lt;code&gt;tt&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="4cba4cc8b1a51987e47e31e5a3e9298ced934caa" translate="yes" xml:space="preserve">
          <source>The following is a list of the available feature names.</source>
          <target state="translated">Ниже приведен список доступных названий функций.</target>
        </trans-unit>
        <trans-unit id="7bfbc404b57ece9100ac4d9b168ae9cc179de313" translate="yes" xml:space="preserve">
          <source>The following is an example of a derive macro. Instead of doing anything useful with its input, it just appends a function &lt;code&gt;answer&lt;/code&gt;.</source>
          <target state="translated">Ниже приведен пример макроса извлечения. Вместо того, чтобы делать что-нибудь полезное со своим вводом, он просто добавляет &lt;code&gt;answer&lt;/code&gt; функции .</target>
        </trans-unit>
        <trans-unit id="cb90a0db80f40417302eef01e3aacf14fbc10a30" translate="yes" xml:space="preserve">
          <source>The following is an example of declaring &lt;code&gt;Shape&lt;/code&gt; to be a supertrait of &lt;code&gt;Circle&lt;/code&gt;.</source>
          <target state="translated">Ниже приведен пример объявления &lt;code&gt;Shape&lt;/code&gt; надстройкой &lt;code&gt;Circle&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0bc86808e703044cc02c714fea381b5d6b4eb104" translate="yes" xml:space="preserve">
          <source>The following is an index of all built-in attributes.</source>
          <target state="translated">Ниже приведен индекс всех встроенных атрибутов.</target>
        </trans-unit>
        <trans-unit id="7cc1fc6a380ba45eaa1f4f2110280733486f387c" translate="yes" xml:space="preserve">
          <source>The following is an overview of the available synchronization objects:</source>
          <target state="translated">Ниже приведен обзор доступных объектов синхронизации:</target>
        </trans-unit>
        <trans-unit id="e77d4cd3fb5ca40ba38b2400787449b1eb8f401a" translate="yes" xml:space="preserve">
          <source>The following keywords are reserved beginning in the 2018 edition.</source>
          <target state="translated">Следующие ключевые слова зарезервированы начиная с издания 2018 года.</target>
        </trans-unit>
        <trans-unit id="88a73d4d23e456f05faa46221aa0e7b9298c7349" translate="yes" xml:space="preserve">
          <source>The following keywords currently have the functionality described.</source>
          <target state="translated">Следующие ключевые слова в настоящее время имеют описанную функциональность.</target>
        </trans-unit>
        <trans-unit id="b5d973323cad12bb72185383671304dcd5ab9469" translate="yes" xml:space="preserve">
          <source>The following keywords do not have any functionality but are reserved by Rust for potential future use.</source>
          <target state="translated">Следующие ключевые слова не имеют никакой функциональности,но зарезервированы Rust для потенциального использования в будущем.</target>
        </trans-unit>
        <trans-unit id="e441a28a0807978c7d9ce6b3cf8c4bd39296d4e8" translate="yes" xml:space="preserve">
          <source>The following keywords were added beginning in the 2018 edition.</source>
          <target state="translated">Начиная с издания 2018 года были добавлены следующие ключевые слова.</target>
        </trans-unit>
        <trans-unit id="7de22ffd047d06a2d94087f0583e69c5de3c8513" translate="yes" xml:space="preserve">
          <source>The following language level features cannot be used in the safe subset of Rust:</source>
          <target state="translated">В безопасном подмножестве &quot;Ржавчина&quot; нельзя использовать следующие языковые функции:</target>
        </trans-unit>
        <trans-unit id="fa4bbe49e1fb3a478a935beaddada675b665b643" translate="yes" xml:space="preserve">
          <source>The following list contains all non-letters that don&amp;rsquo;t function as operators; that is, they don&amp;rsquo;t behave like a function or method call.</source>
          <target state="translated">Следующий список содержит все небуквенные символы, которые не работают как операторы; то есть они не ведут себя как вызов функции или метода.</target>
        </trans-unit>
        <trans-unit id="35b04ccb391eee75aac9df7cb7f1bfc81254ebee" translate="yes" xml:space="preserve">
          <source>The following list contains keywords that are reserved for current or future use by the Rust language. As such, they cannot be used as identifiers (except as raw identifiers as we&amp;rsquo;ll discuss in the &amp;ldquo;&lt;a href=&quot;#raw-identifiers&quot;&gt;Raw Identifiers&lt;/a&gt;&amp;rdquo; section), including names of functions, variables, parameters, struct fields, modules, crates, constants, macros, static values, attributes, types, traits, or lifetimes.</source>
          <target state="translated">Следующий список содержит ключевые слова, которые зарезервированы для текущего или будущего использования языком Rust. Таким образом, они не могут использоваться в качестве идентификаторов (за исключением необработанных идентификаторов, как мы обсудим в разделе &amp;laquo; &lt;a href=&quot;#raw-identifiers&quot;&gt;Необработанные идентификаторы&lt;/a&gt; &amp;raquo;), включая имена функций, переменных, параметров, полей структуры, модулей, ящиков, констант, макросов, статических значений. , атрибуты, типы, черты или время жизни.</target>
        </trans-unit>
        <trans-unit id="92af89abc5b10810cac2bde7c4403090edbb5361" translate="yes" xml:space="preserve">
          <source>The following notations are used by the &lt;em&gt;Lexer&lt;/em&gt; and &lt;em&gt;Syntax&lt;/em&gt; grammar snippets:</source>
          <target state="translated">В фрагментах грамматики &lt;em&gt;Lexer&lt;/em&gt; и &lt;em&gt;Syntax&lt;/em&gt; используются следующие обозначения :</target>
        </trans-unit>
        <trans-unit id="6c611de22c83326f1c10498c47d838ad78c2827b" translate="yes" xml:space="preserve">
          <source>The following return &lt;a href=&quot;../primitive.bool&quot;&gt;&lt;code&gt;false&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">Следующее возвращает &lt;a href=&quot;../primitive.bool&quot;&gt; &lt;code&gt;false&lt;/code&gt; &lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="1c03f7174ac895e9b31fae2f8cfc928f6b6b192e" translate="yes" xml:space="preserve">
          <source>The following return &lt;a href=&quot;https://doc.rust-lang.org/nightly/std/primitive.bool.html&quot;&gt;&lt;code&gt;false&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="452576d6c51a73e57d8181671d67361d1616b8f6" translate="yes" xml:space="preserve">
          <source>The following return false:</source>
          <target state="translated">Следующий возврат ложный:</target>
        </trans-unit>
        <trans-unit id="b857efb8bb558af5cdfcfd53ef42f4d49fe84301" translate="yes" xml:space="preserve">
          <source>The following rewritten version of &lt;code&gt;another_function&lt;/code&gt; shows what parameters look like in Rust:</source>
          <target state="translated">Следующая переписанная версия &lt;code&gt;another_function&lt;/code&gt; показывает, как выглядят параметры в Rust:</target>
        </trans-unit>
        <trans-unit id="7befecdaf697f20709a802fcb20813e2f422fba6" translate="yes" xml:space="preserve">
          <source>The following sections contain reference material you may find useful in your Rust journey.</source>
          <target state="translated">Следующие разделы содержат справочные материалы,которые Вы можете найти полезными в Вашем путешествии по Ржавчине.</target>
        </trans-unit>
        <trans-unit id="5d4dd709d05236da16b69a96983ce9c67ce45124" translate="yes" xml:space="preserve">
          <source>The following steps install the latest stable version of the Rust compiler. Rust&amp;rsquo;s stability guarantees ensure that all the examples in the book that compile will continue to compile with newer Rust versions. The output might differ slightly between versions, because Rust often improves error messages and warnings. In other words, any newer, stable version of Rust you install using these steps should work as expected with the content of this book.</source>
          <target state="translated">Следующие шаги устанавливают последнюю стабильную версию компилятора Rust. Стабильность Rust гарантирует, что все примеры в книге, которые компилируются, будут продолжать компилироваться с более новыми версиями Rust. Вывод может немного отличаться в зависимости от версии, потому что Rust часто улучшает сообщения об ошибках и предупреждения. Другими словами, любая более новая стабильная версия Rust, которую вы устанавливаете с помощью этих шагов, должна работать должным образом с содержанием этой книги.</target>
        </trans-unit>
        <trans-unit id="d23c37bf8f18aef980fb1fbefe90db0a500a0719" translate="yes" xml:space="preserve">
          <source>The following table gives the size for primitives.</source>
          <target state="translated">В следующей таблице приведен размер для примитивов.</target>
        </trans-unit>
        <trans-unit id="3bc9c0126109b1bad1345c2a1d2c68127ed67d67" translate="yes" xml:space="preserve">
          <source>The following traits are implemented for all &lt;code&gt;&amp;amp;T&lt;/code&gt;, regardless of the type of its referent:</source>
          <target state="translated">Следующие черты реализованы для всех &lt;code&gt;&amp;amp;T&lt;/code&gt; , независимо от типа его референта:</target>
        </trans-unit>
        <trans-unit id="3e9fcf457a5e9ecd7495ab63bfd0f41db2476290" translate="yes" xml:space="preserve">
          <source>The following traits are implemented on &lt;code&gt;&amp;amp;T&lt;/code&gt; references if the underlying &lt;code&gt;T&lt;/code&gt; also implements that trait:</source>
          <target state="translated">Следующие трейты реализуются в ссылках &lt;code&gt;&amp;amp;T&lt;/code&gt; если базовый &lt;code&gt;T&lt;/code&gt; также реализует этот трейт:</target>
        </trans-unit>
        <trans-unit id="be48c1df52265e0b68ec35bc1f2481219af6ad7a" translate="yes" xml:space="preserve">
          <source>The following will print &quot;Custom panic hook&quot;:</source>
          <target state="translated">Далее будет напечатано &quot;Пользовательский панический крючок&quot;:</target>
        </trans-unit>
        <trans-unit id="882019462e8fd74a5df1bf54582eb004918743ba" translate="yes" xml:space="preserve">
          <source>The following will print &quot;Normal panic&quot;:</source>
          <target state="translated">Далее будет напечатано &quot;Нормальная паника&quot;:</target>
        </trans-unit>
        <trans-unit id="7ed71896f2a34a4014ac80c7f9efbde1c744961e" translate="yes" xml:space="preserve">
          <source>The form &lt;code&gt;(..)&lt;/code&gt; with a single &lt;a href=&quot;#rest-patterns&quot;&gt;&lt;em&gt;RestPattern&lt;/em&gt;&lt;/a&gt; is a special form that does not require a comma, and matches a tuple of any size.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2a310cc6ed2f47da18129871732d4b9900992d6f" translate="yes" xml:space="preserve">
          <source>The formal way of describing this behavior is that expressions of type &lt;code&gt;!&lt;/code&gt; can be coerced into any other type. We&amp;rsquo;re allowed to end this &lt;code&gt;match&lt;/code&gt; arm with &lt;code&gt;continue&lt;/code&gt; because &lt;code&gt;continue&lt;/code&gt; doesn&amp;rsquo;t return a value; instead, it moves control back to the top of the loop, so in the &lt;code&gt;Err&lt;/code&gt; case, we never assign a value to &lt;code&gt;guess&lt;/code&gt;.</source>
          <target state="translated">Формальный способ описания этого поведения - это выражения типа &lt;code&gt;!&lt;/code&gt; может быть принужден к любому другому типу. Нам разрешено закончить эту руку &lt;code&gt;match&lt;/code&gt; с помощью &lt;code&gt;continue&lt;/code&gt; , потому что &lt;code&gt;continue&lt;/code&gt; не возвращает значение; вместо этого он перемещает управление обратно в начало цикла, поэтому в случае &lt;code&gt;Err&lt;/code&gt; мы никогда не присваиваем значение для &lt;code&gt;guess&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="99bcb45d13b51e9ae5259463fdd2a32bb1c9a90e" translate="yes" xml:space="preserve">
          <source>The full circle constant (&amp;tau;)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cd8574fedd8387c0dcc9c1aeee32062dd23e8095" translate="yes" xml:space="preserve">
          <source>The full path is created by joining the original path to &lt;code&gt;read_dir&lt;/code&gt; with the filename of this entry.</source>
          <target state="translated">Полный путь создается путем соединения исходного пути к &lt;code&gt;read_dir&lt;/code&gt; с именем файла этой записи.</target>
        </trans-unit>
        <trans-unit id="32f32b59c17ac39e46a137b79b14f93e65ff40c1" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;inner_drop&lt;/code&gt; has the type that &lt;a href=&quot;../ops/trait.drop#tymethod.drop&quot;&gt;&lt;code&gt;drop&lt;/code&gt;&lt;/a&gt;&lt;em&gt;should&lt;/em&gt; have, so this makes sure that you do not accidentally use &lt;code&gt;self&lt;/code&gt;/&lt;code&gt;this&lt;/code&gt; in a way that is in conflict with pinning.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="41bd7d7e62e02a905d152c2bd99a0375a7ed8226" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;inner_drop&lt;/code&gt; has the type that &lt;code&gt;drop&lt;/code&gt;&lt;em&gt;should&lt;/em&gt; have, so this makes sure that you do not accidentally use &lt;code&gt;self&lt;/code&gt;/&lt;code&gt;this&lt;/code&gt; in a way that is in conflict with pinning.</source>
          <target state="translated">Функция &lt;code&gt;inner_drop&lt;/code&gt; имеет тип, который &lt;em&gt;должен&lt;/em&gt; иметь &lt;code&gt;drop&lt;/code&gt; , поэтому это гарантирует, что вы случайно не используете &lt;code&gt;self&lt;/code&gt; / &lt;code&gt;this&lt;/code&gt; таким образом, который противоречит закреплению.&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="cf14d5d5cd860e1137527a26dcf1970a6fdcd6cb" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;slice::from_raw_parts_mut&lt;/code&gt; is unsafe because it takes a raw pointer and must trust that this pointer is valid. The &lt;code&gt;add&lt;/code&gt; method on raw pointers is also unsafe, because it must trust that the offset location is also a valid pointer. Therefore, we had to put an &lt;code&gt;unsafe&lt;/code&gt; block around our calls to &lt;code&gt;slice::from_raw_parts_mut&lt;/code&gt; and &lt;code&gt;add&lt;/code&gt; so we could call them. By looking at the code and by adding the assertion that &lt;code&gt;mid&lt;/code&gt; must be less than or equal to &lt;code&gt;len&lt;/code&gt;, we can tell that all the raw pointers used within the &lt;code&gt;unsafe&lt;/code&gt; block will be valid pointers to data within the slice. This is an acceptable and appropriate use of &lt;code&gt;unsafe&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bcc8f276c3240e55b6476f93fee8521728c232e7" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;slice::from_raw_parts_mut&lt;/code&gt; is unsafe because it takes a raw pointer and must trust that this pointer is valid. The &lt;code&gt;offset&lt;/code&gt; method on raw pointers is also unsafe, because it must trust that the offset location is also a valid pointer. Therefore, we had to put an &lt;code&gt;unsafe&lt;/code&gt; block around our calls to &lt;code&gt;slice::from_raw_parts_mut&lt;/code&gt; and &lt;code&gt;offset&lt;/code&gt; so we could call them. By looking at the code and by adding the assertion that &lt;code&gt;mid&lt;/code&gt; must be less than or equal to &lt;code&gt;len&lt;/code&gt;, we can tell that all the raw pointers used within the &lt;code&gt;unsafe&lt;/code&gt; block will be valid pointers to data within the slice. This is an acceptable and appropriate use of &lt;code&gt;unsafe&lt;/code&gt;.</source>
          <target state="translated">Функция &lt;code&gt;slice::from_raw_parts_mut&lt;/code&gt; небезопасна, потому что она принимает необработанный указатель и должна доверять тому, что этот указатель действителен. Метод &lt;code&gt;offset&lt;/code&gt; для необработанных указателей также небезопасен, потому что он должен быть уверен, что местоположение смещения также является допустимым указателем. Следовательно, нам пришлось поместить &lt;code&gt;unsafe&lt;/code&gt; блок вокруг наших вызовов &lt;code&gt;slice::from_raw_parts_mut&lt;/code&gt; и &lt;code&gt;offset&lt;/code&gt; , чтобы мы могли их вызывать. Посмотрев на код и добавив утверждение, что &lt;code&gt;mid&lt;/code&gt; должно быть меньше или равно &lt;code&gt;len&lt;/code&gt; , мы можем сказать, что все исходные указатели, используемые в &lt;code&gt;unsafe&lt;/code&gt; блоке, будут действительными указателями на данные внутри среза. Это приемлемое и уместное использование &lt;code&gt;unsafe&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9e2ea4196275fb1f06fa7661da10e384c365aa9f" translate="yes" xml:space="preserve">
          <source>The function body block is contained within the scope of the entire function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2cd654b546be7671958f348149444656b0175877" translate="yes" xml:space="preserve">
          <source>The function body uses the &lt;code&gt;assert_eq!&lt;/code&gt; macro to assert that 2 + 2 equals 4. This assertion serves as an example of the format for a typical test. Let&amp;rsquo;s run it to see that this test passes.</source>
          <target state="translated">В теле функции используется &lt;code&gt;assert_eq!&lt;/code&gt; макрос, подтверждающий, что 2 + 2 равно 4. Это утверждение служит примером формата для типичного теста. Давайте запустим его, чтобы убедиться, что этот тест пройден.</target>
        </trans-unit>
        <trans-unit id="fce36fec5fc1977be02dde267db493eca3e79d7a" translate="yes" xml:space="preserve">
          <source>The function must be called with valid byte array &lt;code&gt;buf&lt;/code&gt; of sufficient size to hold the message bytes. If a message is too long to fit in the supplied buffer, excess bytes may be discarded.</source>
          <target state="translated">Функция должна быть вызвана с допустимым байтовым массивом &lt;code&gt;buf&lt;/code&gt; достаточного размера для хранения байтов сообщения. Если сообщение слишком длинное, чтобы поместиться в предоставленный буфер, лишние байты могут быть отброшены.</target>
        </trans-unit>
        <trans-unit id="e529ccf733a9b5ef8b1c476a20d42d70328c6fe4" translate="yes" xml:space="preserve">
          <source>The function panics if &lt;code&gt;align&lt;/code&gt; is not a power-of-two.</source>
          <target state="translated">Функция паникует, если &lt;code&gt;align&lt;/code&gt; не является степенью двойки.</target>
        </trans-unit>
        <trans-unit id="b268ef11b8c08ae232cf81ee855904ac47e81a51" translate="yes" xml:space="preserve">
          <source>The function returns &lt;code&gt;true&lt;/code&gt; if there was enough space in the buffer. If there was not enough space then no credentials was appended. Technically, that means this operation adds a control message with the level &lt;code&gt;SOL_SOCKET&lt;/code&gt; and type &lt;code&gt;SCM_CREDENTIALS&lt;/code&gt; or &lt;code&gt;SCM_CREDS&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="571e08cd267873dac614b1a31157ac35e6c1e16a" translate="yes" xml:space="preserve">
          <source>The function returns &lt;code&gt;true&lt;/code&gt; if there was enough space in the buffer. If there was not enough space then no file descriptors was appended. Technically, that means this operation adds a control message with the level &lt;code&gt;SOL_SOCKET&lt;/code&gt; and type &lt;code&gt;SCM_RIGHTS&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3c4c57538d04834ae5173c38a3f23dea7037d387" translate="yes" xml:space="preserve">
          <source>The function signature now tells Rust that for some lifetime &lt;code&gt;'a&lt;/code&gt;, the function takes two parameters, both of which are string slices that live at least as long as lifetime &lt;code&gt;'a&lt;/code&gt;. The function signature also tells Rust that the string slice returned from the function will live at least as long as lifetime &lt;code&gt;'a&lt;/code&gt;. In practice, it means that the lifetime of the reference returned by the &lt;code&gt;longest&lt;/code&gt; function is the same as the smaller of the lifetimes of the references passed in. These constraints are what we want Rust to enforce. Remember, when we specify the lifetime parameters in this function signature, we&amp;rsquo;re not changing the lifetimes of any values passed in or returned. Rather, we&amp;rsquo;re specifying that the borrow checker should reject any values that don&amp;rsquo;t adhere to these constraints. Note that the &lt;code&gt;longest&lt;/code&gt; function doesn&amp;rsquo;t need to know exactly how long &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; will live, only that some scope can be substituted for &lt;code&gt;'a&lt;/code&gt; that will satisfy this signature.</source>
          <target state="translated">Сигнатура функции теперь сообщает Rust, что в течение некоторого времени жизни &lt;code&gt;'a&lt;/code&gt; функция принимает два параметра, оба из которых являются строковыми срезами, которые живут как минимум столько же, сколько время жизни &lt;code&gt;'a&lt;/code&gt; . Сигнатура функции также сообщает Rust, что фрагмент строки, возвращаемый функцией, будет существовать по крайней мере столько же, сколько времени жизни &lt;code&gt;'a&lt;/code&gt; . На практике это означает, что время жизни ссылки, возвращаемой самой &lt;code&gt;longest&lt;/code&gt; это то же самое, что и меньшее время жизни переданных ссылок. Эти ограничения - это то, что мы хотим, чтобы Rust соблюдал. Помните, что когда мы указываем параметры времени жизни в этой сигнатуре функции, мы не меняем время жизни каких-либо переданных или возвращаемых значений. Скорее, мы указываем, что средство проверки заимствований должно отклонять любые значения, которые не соответствуют этим ограничениям. Обратите внимание, что самой &lt;code&gt;longest&lt;/code&gt; функции не нужно точно знать, как долго будут жить &lt;code&gt;x&lt;/code&gt; и &lt;code&gt;y&lt;/code&gt; , только то, что некоторая область видимости может быть заменена на &lt;code&gt;'a&lt;/code&gt; , которая удовлетворяет этой сигнатуре.</target>
        </trans-unit>
        <trans-unit id="bdcb7a1c11baa13711e61ba40d7e28572f624f97" translate="yes" xml:space="preserve">
          <source>The function that defines a procedural macro takes a &lt;code&gt;TokenStream&lt;/code&gt; as an input and produces a &lt;code&gt;TokenStream&lt;/code&gt; as an output. The &lt;code&gt;TokenStream&lt;/code&gt; type is defined by the &lt;code&gt;proc_macro&lt;/code&gt; crate that is included with Rust and represents a sequence of tokens. This is the core of the macro: the source code that the macro is operating on makes up the input &lt;code&gt;TokenStream&lt;/code&gt;, and the code the macro produces is the output &lt;code&gt;TokenStream&lt;/code&gt;. The function also has an attribute attached to it that specifies which kind of procedural macro we&amp;rsquo;re creating. We can have multiple kinds of procedural macros in the same crate.</source>
          <target state="translated">Функция, определяющая процедурный макрос, принимает &lt;code&gt;TokenStream&lt;/code&gt; в качестве входных данных и создает &lt;code&gt;TokenStream&lt;/code&gt; в качестве выходных данных. Тип &lt;code&gt;TokenStream&lt;/code&gt; определяется &lt;code&gt;proc_macro&lt;/code&gt; который включен в Rust и представляет собой последовательность токенов. Это ядро ​​макроса: исходный код, с которым работает макрос, составляет входной &lt;code&gt;TokenStream&lt;/code&gt; , а код, создаваемый макросом, является выходным &lt;code&gt;TokenStream&lt;/code&gt; . Функция также имеет прикрепленный к ней атрибут, который указывает, какой процедурный макрос мы создаем. У нас может быть несколько видов процедурных макросов в одном ящике.</target>
        </trans-unit>
        <trans-unit id="bf36f24b39c35b8342b2a6251cb9fb9f153537b5" translate="yes" xml:space="preserve">
          <source>The function will never return and will immediately terminate the current process in a platform specific &quot;abnormal&quot; manner.</source>
          <target state="translated">Функция никогда не вернется и немедленно завершит текущий процесс &quot;аномальным&quot; способом,характерным для платформы.</target>
        </trans-unit>
        <trans-unit id="0c78d2fcec6d6debbe4ef0124bd9c3f517852fce" translate="yes" xml:space="preserve">
          <source>The functional record update syntax is only allowed for structs (struct-like enum variants don't qualify, for example). To fix the previous code, rewrite the expression without functional record update syntax:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4265d286c4ebab2fa68494c58f7e5472bec6ff8e" translate="yes" xml:space="preserve">
          <source>The functional record update syntax is only allowed for structs. (Struct-like enum variants don't qualify, for example.)</source>
          <target state="translated">Синтаксис обновления функциональных записей разрешен только для структур.(Например,структурно-подобные варианты перечислений не удовлетворяют требованиям).</target>
        </trans-unit>
        <trans-unit id="771371fc3674c285662522a3ce8c91121a8eb8d5" translate="yes" xml:space="preserve">
          <source>The functional record update syntax was used on something other than a struct.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3064e7a399dc1562d735ddcb75b4d1c141aa6d18" translate="yes" xml:space="preserve">
          <source>The functionality and syntax of Rust can be extended with custom definitions called macros. They are given names, and invoked through a consistent syntax:&lt;code&gt;some_extension!(...)&lt;/code&gt;.</source>
          <target state="translated">Функциональность и синтаксис Rust можно расширить с помощью пользовательских определений, называемых макросами. Им присваиваются имена, и они вызываются через &lt;code&gt;some_extension!(...)&lt;/code&gt; синтаксис: some_extension! (...) .</target>
        </trans-unit>
        <trans-unit id="90f6e5d380880e28cc22176bc452d0a2cfb51f5f" translate="yes" xml:space="preserve">
          <source>The functions inside this struct are only intended be called on the &lt;code&gt;data&lt;/code&gt; pointer of a properly constructed &lt;a href=&quot;struct.rawwaker&quot;&gt;&lt;code&gt;RawWaker&lt;/code&gt;&lt;/a&gt; object from inside the &lt;a href=&quot;struct.rawwaker&quot;&gt;&lt;code&gt;RawWaker&lt;/code&gt;&lt;/a&gt; implementation. Calling one of the contained functions using any other &lt;code&gt;data&lt;/code&gt; pointer will cause undefined behavior.</source>
          <target state="translated">Функции внутри этой структуры предназначены только быть созваны по &lt;code&gt;data&lt;/code&gt; указателя правильно построенной &lt;a href=&quot;struct.rawwaker&quot;&gt; &lt;code&gt;RawWaker&lt;/code&gt; &lt;/a&gt; объекта изнутри &lt;a href=&quot;struct.rawwaker&quot;&gt; &lt;code&gt;RawWaker&lt;/code&gt; &lt;/a&gt; реализации. Вызов одной из содержащихся функций с использованием любого другого указателя &lt;code&gt;data&lt;/code&gt; приведет к неопределенному поведению.</target>
        </trans-unit>
        <trans-unit id="5d3fe931a60678fe761ffe2bfb5b03361ca50257" translate="yes" xml:space="preserve">
          <source>The functions inside this struct are only intended to be called on the &lt;code&gt;data&lt;/code&gt; pointer of a properly constructed &lt;a href=&quot;struct.rawwaker&quot;&gt;&lt;code&gt;RawWaker&lt;/code&gt;&lt;/a&gt; object from inside the &lt;a href=&quot;struct.rawwaker&quot;&gt;&lt;code&gt;RawWaker&lt;/code&gt;&lt;/a&gt; implementation. Calling one of the contained functions using any other &lt;code&gt;data&lt;/code&gt; pointer will cause undefined behavior.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="df0966ed788f9044d3bbbf28ed214b74382d234e" translate="yes" xml:space="preserve">
          <source>The general case</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="44389c2bb8540f5071dbf79b16d89782c82ab1a7" translate="yes" xml:space="preserve">
          <source>The general categories for numbers (&lt;code&gt;Nd&lt;/code&gt; for decimal digits, &lt;code&gt;Nl&lt;/code&gt; for letter-like numeric characters, and &lt;code&gt;No&lt;/code&gt; for other numeric characters) are specified in the &lt;a href=&quot;https://www.unicode.org/reports/tr44/&quot;&gt;Unicode Character Database&lt;/a&gt;&lt;a href=&quot;https://www.unicode.org/Public/UCD/latest/ucd/UnicodeData.txt&quot;&gt;&lt;code&gt;UnicodeData.txt&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3a1ceefd46a3c1a3651802a4204c4c589bc3c7f6" translate="yes" xml:space="preserve">
          <source>The generated &lt;code&gt;impl&lt;/code&gt; for &lt;code&gt;PartialEq&lt;/code&gt; is equivalent to</source>
          <target state="translated">Сгенерированный &lt;code&gt;impl&lt;/code&gt; для &lt;code&gt;PartialEq&lt;/code&gt; эквивалентен</target>
        </trans-unit>
        <trans-unit id="b683f5ed135731413c6d034116ca989acf594401" translate="yes" xml:space="preserve">
          <source>The generator completed with a return value.</source>
          <target state="translated">Генератор заполнен возвращаемым значением.</target>
        </trans-unit>
        <trans-unit id="156bc757a593c6f0753b493e20c7157ef75917ae" translate="yes" xml:space="preserve">
          <source>The generator suspended with a value.</source>
          <target state="translated">Генератор приостановлен со значением.</target>
        </trans-unit>
        <trans-unit id="cd45c192be4dc3d892b1ef2f0b632aaff12d6653" translate="yes" xml:space="preserve">
          <source>The generic type &lt;code&gt;T&lt;/code&gt; specified as the type of the &lt;code&gt;item1&lt;/code&gt; and &lt;code&gt;item2&lt;/code&gt; parameters constrains the function such that the concrete type of the value passed as an argument for &lt;code&gt;item1&lt;/code&gt; and &lt;code&gt;item2&lt;/code&gt; must be the same.</source>
          <target state="translated">&lt;code&gt;item2&lt;/code&gt; тип &lt;code&gt;T&lt;/code&gt; , указанный как тип параметров &lt;code&gt;item1&lt;/code&gt; и item2, ограничивает функцию таким образом, что конкретный тип значения, переданного в качестве аргумента для &lt;code&gt;item1&lt;/code&gt; и &lt;code&gt;item2&lt;/code&gt; , должен быть одинаковым.</target>
        </trans-unit>
        <trans-unit id="1bc01fb3a417f3ff749e03a42ff1490b6833bd43" translate="yes" xml:space="preserve">
          <source>The generic type has to be a SIMD type. Example:</source>
          <target state="translated">Общий тип должен быть типом SIMD.Пример:</target>
        </trans-unit>
        <trans-unit id="e58faf99c3204433210564e65725762b8514494f" translate="yes" xml:space="preserve">
          <source>The given &lt;a href=&quot;../vec/struct.vec&quot;&gt;&lt;code&gt;Vec&lt;/code&gt;&lt;/a&gt;&lt;strong&gt;must&lt;/strong&gt; have one nul byte as its last element. This means it cannot be empty nor have any other nul byte anywhere else.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b25fdf4b8d15b07b7d25cece8768d803831d5b3d" translate="yes" xml:space="preserve">
          <source>The given block must have been produced by this allocator, and must be suitable for storing a &lt;code&gt;T&lt;/code&gt; (in terms of alignment as well as minimum and maximum size); otherwise yields undefined behavior.</source>
          <target state="translated">Данный блок должен быть создан этим распределителем и подходить для хранения &lt;code&gt;T&lt;/code&gt; (с точки зрения выравнивания, а также минимального и максимального размера); в противном случае дает неопределенное поведение.</target>
        </trans-unit>
        <trans-unit id="3ef7afeafd2e9737676d96a4cbd3c7dc2e9ffdbc" translate="yes" xml:space="preserve">
          <source>The glob operator is often used when testing to bring everything under test into the &lt;code&gt;tests&lt;/code&gt; module; we&amp;rsquo;ll talk about that in the &lt;a href=&quot;ch11-01-writing-tests#how-to-write-tests&quot;&gt;&amp;ldquo;How to Write Tests&amp;rdquo;&lt;/a&gt; section in Chapter 11. The glob operator is also sometimes used as part of the prelude pattern: see &lt;a href=&quot;../std/prelude/index#other-preludes&quot;&gt;the standard library documentation&lt;/a&gt; for more information on that pattern.</source>
          <target state="translated">Оператор glob часто используется при тестировании, чтобы перенести все, что тестируется, в модуль &lt;code&gt;tests&lt;/code&gt; ; мы поговорим об этом в разделе &lt;a href=&quot;ch11-01-writing-tests#how-to-write-tests&quot;&gt;&amp;laquo;Как писать тесты&amp;raquo;&lt;/a&gt; в главе 11. Оператор glob также иногда используется как часть шаблона &lt;a href=&quot;../std/prelude/index#other-preludes&quot;&gt;вступления&lt;/a&gt; : дополнительную информацию об этом шаблоне см. в документации стандартной библиотеки .</target>
        </trans-unit>
        <trans-unit id="edae830710bf3e8598def4042b918afe98bc10c2" translate="yes" xml:space="preserve">
          <source>The global memory allocator.</source>
          <target state="translated">Глобальный аллокатор памяти.</target>
        </trans-unit>
        <trans-unit id="ec4646ba1a1fdd24f47203209a1bde5837e4ed73" translate="yes" xml:space="preserve">
          <source>The good news is that if the structure &lt;em&gt;isn&amp;rsquo;t&lt;/em&gt; convenient for others to use from another library, you don&amp;rsquo;t have to rearrange your internal organization: instead, you can re-export items to make a public structure that&amp;rsquo;s different from your private structure by using &lt;code&gt;pub use&lt;/code&gt;. Re-exporting takes a public item in one location and makes it public in another location, as if it were defined in the other location instead.</source>
          <target state="translated">Хорошая новость заключается в том, что если структура из другой библиотеки &lt;em&gt;не&lt;/em&gt; удобна для использования другими, вам не нужно реорганизовывать свою внутреннюю организацию: вместо этого вы можете реэкспортировать элементы, чтобы сделать общедоступную структуру, отличную от вашей частной структуры. используя &lt;code&gt;pub use&lt;/code&gt; . При повторном экспорте общедоступный элемент в одном месте становится общедоступным в другом месте, как если бы он был определен в другом месте.</target>
        </trans-unit>
        <trans-unit id="9e529cd967841dc9eed1fc815f3a4e6b886e5b38" translate="yes" xml:space="preserve">
          <source>The grammar and lexical structure is in blockquotes with either &quot;Lexer&quot; or &quot;Syntax&quot; in &lt;sup&gt;&lt;strong&gt;bold superscript&lt;/strong&gt;&lt;/sup&gt; as the first line.</source>
          <target state="translated">Грамматика и лексическая структура заключены в &lt;sup&gt;&lt;strong&gt;кавычки,&lt;/strong&gt;&lt;/sup&gt; а в первой строке &lt;sup&gt;&lt;strong&gt;жирным надстрочным шрифтом выделены&lt;/strong&gt;&lt;/sup&gt; либо &amp;laquo;Lexer&amp;raquo;, либо &amp;laquo;Syntax&amp;raquo; .</target>
        </trans-unit>
        <trans-unit id="1f36df1235888018fbfcd5153ebfed60de89aef3" translate="yes" xml:space="preserve">
          <source>The grammar production for reference patterns has to match the token &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; to match a reference to a reference because it is a token by itself, not two &lt;code&gt;&amp;amp;&lt;/code&gt; tokens.</source>
          <target state="translated">Грамматика для ссылочных шаблонов должна соответствовать токену &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; , чтобы соответствовать ссылке на ссылку, потому что это токен сам по себе, а не два токена &lt;code&gt;&amp;amp;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ecdb2fc042ccb9955819301d5b939d1fbe330ddf" translate="yes" xml:space="preserve">
          <source>The green-threading M:N model requires a larger language runtime to manage threads. As such, the Rust standard library only provides an implementation of 1:1 threading. Because Rust is such a low-level language, there are crates that implement M:N threading if you would rather trade overhead for aspects such as more control over which threads run when and lower costs of context switching, for example.</source>
          <target state="translated">Модель M:N,использующая зеленый поток,требует большего времени исполнения на языке для управления потоками.Таким образом,стандартная библиотека Rust предоставляет только реализацию многопоточности 1:1.Поскольку Rust является столь низкоуровневым языком,существуют ящики,реализующие многопотоковую модель M:N,если вы предпочитаете торговать накладными расходами на такие аспекты,как больший контроль над тем,какие потоки выполняются,например,когда и более низкие затраты на переключение контекста.</target>
        </trans-unit>
        <trans-unit id="ebee4d45f3971e13391e35d52c5a14b0340c1efd" translate="yes" xml:space="preserve">
          <source>The handle for reading from the child's standard error (stderr), if it has been captured.</source>
          <target state="translated">Ручка для чтения со стандартной ошибки ребенка (stderr),если она была захвачена.</target>
        </trans-unit>
        <trans-unit id="71a4cc891c9774ed993ea2778e2ec4e78d46aa4f" translate="yes" xml:space="preserve">
          <source>The handle for reading from the child's standard error (stderr), if it has been captured. You might find it helpful to do</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fbdaac9b24bb1d15aadc721c15a3031cb1337d9a" translate="yes" xml:space="preserve">
          <source>The handle for reading from the child's standard output (stdout), if it has been captured.</source>
          <target state="translated">Ручка для чтения со стандартного вывода ребенка (stdout),если он был захвачен.</target>
        </trans-unit>
        <trans-unit id="5b65d5fd43c0bfac48d483d2399323a0f40fd595" translate="yes" xml:space="preserve">
          <source>The handle for reading from the child's standard output (stdout), if it has been captured. You might find it helpful to do</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d208573c971bb153ba34475100ea53bd4242537e" translate="yes" xml:space="preserve">
          <source>The handle for writing to the child's standard input (stdin), if it has been captured.</source>
          <target state="translated">Ручка для записи на стандартный вход ребенка (stdin),если она была захвачена.</target>
        </trans-unit>
        <trans-unit id="1008f723c1fd717a94e8a77d7bc5c5ff92ef4700" translate="yes" xml:space="preserve">
          <source>The handle for writing to the child's standard input (stdin), if it has been captured. To avoid partially moving the &lt;code&gt;child&lt;/code&gt; and thus blocking yourself from calling functions on &lt;code&gt;child&lt;/code&gt; while using &lt;code&gt;stdin&lt;/code&gt;, you might find it helpful:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a9febcaaba526b722c76a7ab2b805ffd862b6652" translate="yes" xml:space="preserve">
          <source>The hash map is initially created with a capacity of 0, so it will not allocate until it is first inserted into.</source>
          <target state="translated">Хэш-карта изначально создается с емкостью 0,поэтому она не будет выделяться до тех пор,пока не будет вставлена в нее в первый раз.</target>
        </trans-unit>
        <trans-unit id="ee8ffcf3c4827d14350f3675ea8e7360ee55ee19" translate="yes" xml:space="preserve">
          <source>The hash map will be able to hold at least &lt;code&gt;capacity&lt;/code&gt; elements without reallocating. If &lt;code&gt;capacity&lt;/code&gt; is 0, the hash map will not allocate.</source>
          <target state="translated">Хеш-карта сможет содержать как минимум элементы &lt;code&gt;capacity&lt;/code&gt; без перераспределения. Если &lt;code&gt;capacity&lt;/code&gt; равна 0, хэш-карта не выделяется.</target>
        </trans-unit>
        <trans-unit id="0b56c1bdca2b1b95316afe0ecdd6afdabfe66713" translate="yes" xml:space="preserve">
          <source>The hash set is also created with the default initial capacity.</source>
          <target state="translated">Набор хэшей также создается с начальной емкостью по умолчанию.</target>
        </trans-unit>
        <trans-unit id="b637bd7a31fb790788f10cfb96ebb867cfd6151d" translate="yes" xml:space="preserve">
          <source>The hash set is initially created with a capacity of 0, so it will not allocate until it is first inserted into.</source>
          <target state="translated">Набор хэшей изначально создается емкостью 0,поэтому он не будет выделяться до тех пор,пока не будет вставлен в него в первый раз.</target>
        </trans-unit>
        <trans-unit id="7b099ba43b1ded8417cfcd0145835bc5cf64881f" translate="yes" xml:space="preserve">
          <source>The hash set will be able to hold at least &lt;code&gt;capacity&lt;/code&gt; elements without reallocating. If &lt;code&gt;capacity&lt;/code&gt; is 0, the hash set will not allocate.</source>
          <target state="translated">Хэш-набор сможет содержать как минимум элементы &lt;code&gt;capacity&lt;/code&gt; без перераспределения. Если &lt;code&gt;capacity&lt;/code&gt; равна 0, хэш-набор не выделяется.</target>
        </trans-unit>
        <trans-unit id="d8a4e0ea14c5f027cfeb61abdb7d26fe519f8ab6" translate="yes" xml:space="preserve">
          <source>The hash table implementation is a Rust port of Google's &lt;a href=&quot;https://abseil.io/blog/20180927-swisstables&quot;&gt;SwissTable&lt;/a&gt;. The original C++ version of SwissTable can be found &lt;a href=&quot;https://github.com/abseil/abseil-cpp/blob/master/absl/container/internal/raw_hash_set.h&quot;&gt;here&lt;/a&gt;, and this &lt;a href=&quot;https://www.youtube.com/watch?v=ncHmEUmJZf4&quot;&gt;CppCon talk&lt;/a&gt; gives an overview of how the algorithm works.</source>
          <target state="translated">Реализация хэш-таблицы - это порт Google &lt;a href=&quot;https://abseil.io/blog/20180927-swisstables&quot;&gt;SwissTable&lt;/a&gt; на Rust . Исходную версию SwissTable на C ++ можно найти &lt;a href=&quot;https://github.com/abseil/abseil-cpp/blob/master/absl/container/internal/raw_hash_set.h&quot;&gt;здесь&lt;/a&gt; , а в этом &lt;a href=&quot;https://www.youtube.com/watch?v=ncHmEUmJZf4&quot;&gt;выступлении на CppCon&lt;/a&gt; дается обзор того, как работает алгоритм.</target>
        </trans-unit>
        <trans-unit id="415bb7e03ead8b051422fe277c860425b7ebbf61" translate="yes" xml:space="preserve">
          <source>The hashing algorithm can be replaced on a per-&lt;code&gt;HashMap&lt;/code&gt; basis using the &lt;a href=&quot;#method.default&quot;&gt;&lt;code&gt;default&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#method.with_hasher&quot;&gt;&lt;code&gt;with_hasher&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;#method.with_capacity_and_hasher&quot;&gt;&lt;code&gt;with_capacity_and_hasher&lt;/code&gt;&lt;/a&gt; methods. Many alternative algorithms are available on crates.io, such as the &lt;a href=&quot;https://crates.io/crates/fnv&quot;&gt;&lt;code&gt;fnv&lt;/code&gt;&lt;/a&gt; crate.</source>
          <target state="translated">Алгоритм хеширования может быть заменен на ослабленный &lt;code&gt;HashMap&lt;/code&gt; основе с использованием по &lt;a href=&quot;#method.default&quot;&gt; &lt;code&gt;default&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#method.with_hasher&quot;&gt; &lt;code&gt;with_hasher&lt;/code&gt; &lt;/a&gt; и &lt;a href=&quot;#method.with_capacity_and_hasher&quot;&gt; &lt;code&gt;with_capacity_and_hasher&lt;/code&gt; &lt;/a&gt; методы. На crates.io доступно множество альтернативных алгоритмов, например, &lt;a href=&quot;https://crates.io/crates/fnv&quot;&gt; &lt;code&gt;fnv&lt;/code&gt; &lt;/a&gt; crate.</target>
        </trans-unit>
        <trans-unit id="142488b9261462c1e559bf3f2ad49337e31e2ac1" translate="yes" xml:space="preserve">
          <source>The hashing algorithm can be replaced on a per-&lt;code&gt;HashMap&lt;/code&gt; basis using the &lt;a href=&quot;../../default/trait.default#tymethod.default&quot;&gt;&lt;code&gt;default&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../struct.hashmap#method.with_hasher&quot;&gt;&lt;code&gt;with_hasher&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;../struct.hashmap#method.with_capacity_and_hasher&quot;&gt;&lt;code&gt;with_capacity_and_hasher&lt;/code&gt;&lt;/a&gt; methods. Many alternative algorithms are available on crates.io, such as the &lt;a href=&quot;https://crates.io/crates/fnv&quot;&gt;&lt;code&gt;fnv&lt;/code&gt;&lt;/a&gt; crate.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="abc423f45ad76627b7f09d1c195dab7e2c377478" translate="yes" xml:space="preserve">
          <source>The hashing algorithm can be replaced on a per-&lt;code&gt;HashMap&lt;/code&gt; basis using the &lt;a href=&quot;../../default/trait.default#tymethod.default&quot;&gt;&lt;code&gt;default&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;struct.hashmap#method.with_hasher&quot;&gt;&lt;code&gt;with_hasher&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;struct.hashmap#method.with_capacity_and_hasher&quot;&gt;&lt;code&gt;with_capacity_and_hasher&lt;/code&gt;&lt;/a&gt; methods. There are many alternative &lt;a href=&quot;https://crates.io/keywords/hasher&quot;&gt;hashing algorithms available on crates.io&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d12087b42b0b99fc1565d3b697e609feca661351" translate="yes" xml:space="preserve">
          <source>The hashing algorithm can be replaced on a per-&lt;code&gt;HashMap&lt;/code&gt; basis using the &lt;a href=&quot;../default/trait.default#tymethod.default&quot;&gt;&lt;code&gt;default&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;hash_map/struct.hashmap#method.with_hasher&quot;&gt;&lt;code&gt;with_hasher&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;hash_map/struct.hashmap#method.with_capacity_and_hasher&quot;&gt;&lt;code&gt;with_capacity_and_hasher&lt;/code&gt;&lt;/a&gt; methods. There are many alternative &lt;a href=&quot;https://crates.io/keywords/hasher&quot;&gt;hashing algorithms available on crates.io&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="417d67f06aec820d5f0416a0fabba770f0ab5392" translate="yes" xml:space="preserve">
          <source>The hashing algorithm can be replaced on a per-&lt;code&gt;HashMap&lt;/code&gt; basis using the &lt;a href=&quot;../default/trait.default#tymethod.default&quot;&gt;&lt;code&gt;default&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;struct.hashmap#method.with_hasher&quot;&gt;&lt;code&gt;with_hasher&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;struct.hashmap#method.with_capacity_and_hasher&quot;&gt;&lt;code&gt;with_capacity_and_hasher&lt;/code&gt;&lt;/a&gt; methods. Many alternative algorithms are available on crates.io, such as the &lt;a href=&quot;https://crates.io/crates/fnv&quot;&gt;&lt;code&gt;fnv&lt;/code&gt;&lt;/a&gt; crate.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="36e2055f1b7671fa46f87316bf9cf49547025536" translate="yes" xml:space="preserve">
          <source>The heart and soul of this module is the &lt;a href=&quot;trait.iterator&quot;&gt;&lt;code&gt;Iterator&lt;/code&gt;&lt;/a&gt; trait. The core of &lt;a href=&quot;trait.iterator&quot;&gt;&lt;code&gt;Iterator&lt;/code&gt;&lt;/a&gt; looks like this:</source>
          <target state="translated">Сердце и душа этого модуля - черта &lt;a href=&quot;trait.iterator&quot;&gt; &lt;code&gt;Iterator&lt;/code&gt; &lt;/a&gt; . Ядро &lt;a href=&quot;trait.iterator&quot;&gt; &lt;code&gt;Iterator&lt;/code&gt; &lt;/a&gt; выглядит так:</target>
        </trans-unit>
        <trans-unit id="f7cf9da11ff393d577012f24f0fd7f9d800c440a" translate="yes" xml:space="preserve">
          <source>The heart of the change is that where &lt;code&gt;&amp;amp;'a Box&amp;lt;SomeTrait&amp;gt;&lt;/code&gt; used to default to &lt;code&gt;&amp;amp;'a Box&amp;lt;SomeTrait+'a&amp;gt;&lt;/code&gt;, it now defaults to &lt;code&gt;&amp;amp;'a Box&amp;lt;SomeTrait+'static&amp;gt;&lt;/code&gt; (here, &lt;code&gt;SomeTrait&lt;/code&gt; is the name of some trait type). Note that the only types which are affected are references to boxes, like &lt;code&gt;&amp;amp;Box&amp;lt;SomeTrait&amp;gt;&lt;/code&gt; or &lt;code&gt;&amp;amp;[Box&amp;lt;SomeTrait&amp;gt;]&lt;/code&gt;. More common types like &lt;code&gt;&amp;amp;SomeTrait&lt;/code&gt; or &lt;code&gt;Box&amp;lt;SomeTrait&amp;gt;&lt;/code&gt; are unaffected.</source>
          <target state="translated">Суть изменения заключается в том, что если для &lt;code&gt;&amp;amp;'a Box&amp;lt;SomeTrait&amp;gt;&lt;/code&gt; по умолчанию использовался &lt;code&gt;&amp;amp;'a Box&amp;lt;SomeTrait+'a&amp;gt;&lt;/code&gt; , теперь по умолчанию используется &lt;code&gt;&amp;amp;'a Box&amp;lt;SomeTrait+'static&amp;gt;&lt;/code&gt; (здесь &lt;code&gt;SomeTrait&lt;/code&gt; - это имя какой-то тип черты). Обратите внимание, что затрагиваются только типы ссылок на блоки, например &lt;code&gt;&amp;amp;Box&amp;lt;SomeTrait&amp;gt;&lt;/code&gt; или &lt;code&gt;&amp;amp;[Box&amp;lt;SomeTrait&amp;gt;]&lt;/code&gt; . Более распространенные типы, такие как &lt;code&gt;&amp;amp;SomeTrait&lt;/code&gt; или &lt;code&gt;Box&amp;lt;SomeTrait&amp;gt;&lt;/code&gt; , не затрагиваются.</target>
        </trans-unit>
        <trans-unit id="8b80292943879aaefba4fcd89176f25fb4fe681b" translate="yes" xml:space="preserve">
          <source>The help text reveals that the return type needs a generic lifetime parameter on it because Rust can&amp;rsquo;t tell whether the reference being returned refers to &lt;code&gt;x&lt;/code&gt; or &lt;code&gt;y&lt;/code&gt;. Actually, we don&amp;rsquo;t know either, because the &lt;code&gt;if&lt;/code&gt; block in the body of this function returns a reference to &lt;code&gt;x&lt;/code&gt; and the &lt;code&gt;else&lt;/code&gt; block returns a reference to &lt;code&gt;y&lt;/code&gt;!</source>
          <target state="translated">Текст справки показывает, что возвращаемому типу нужен общий параметр времени жизни, потому что Rust не может определить, относится ли возвращаемая ссылка к &lt;code&gt;x&lt;/code&gt; или &lt;code&gt;y&lt;/code&gt; . На самом деле мы тоже не знаем, потому что блок &lt;code&gt;if&lt;/code&gt; в теле этой функции возвращает ссылку на &lt;code&gt;x&lt;/code&gt; , а блок &lt;code&gt;else&lt;/code&gt; возвращает ссылку на &lt;code&gt;y&lt;/code&gt; !</target>
        </trans-unit>
        <trans-unit id="d58a9f4bf1938432cc316db1e69ad2bfca3de5d4" translate="yes" xml:space="preserve">
          <source>The highest valid code point a &lt;code&gt;char&lt;/code&gt; can have.</source>
          <target state="translated">Наивысшая допустимая кодовая точка, которую может иметь &lt;code&gt;char&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2c0d414ff9adc0b33c0f3d50d800e4ef1b9ec6d2" translate="yes" xml:space="preserve">
          <source>The hook is provided with a &lt;code&gt;Layout&lt;/code&gt; struct which contains information about the allocation that failed.</source>
          <target state="translated">Перехватчик снабжен структурой &lt;code&gt;Layout&lt;/code&gt; которая содержит информацию об отказе выделения.</target>
        </trans-unit>
        <trans-unit id="c05a8db594383eaa649c0ea9f1230d31e2d9d207" translate="yes" xml:space="preserve">
          <source>The hook is provided with a &lt;code&gt;PanicInfo&lt;/code&gt; struct which contains information about the origin of the panic, including the payload passed to &lt;code&gt;panic!&lt;/code&gt; and the source code location from which the panic originated.</source>
          <target state="translated">Крюк снабжен &lt;code&gt;PanicInfo&lt;/code&gt; структурой , которая содержит информацию о происхождении паники, включая полезную нагрузку передается &lt;code&gt;panic!&lt;/code&gt; и местоположение исходного кода, из которого возникла паника.</target>
        </trans-unit>
        <trans-unit id="c5e73d7bf13606a783c42b98ca4eecc2c703d2de" translate="yes" xml:space="preserve">
          <source>The identifier is more than one character. &lt;code&gt;_&lt;/code&gt; alone is not an identifier.</source>
          <target state="translated">Идентификатор состоит из более чем одного символа. &lt;code&gt;_&lt;/code&gt; сам по себе не является идентификатором.</target>
        </trans-unit>
        <trans-unit id="714243f838efe98c2e10bdbb7f1411daa3ecd7a0" translate="yes" xml:space="preserve">
          <source>The identifier is the name of the constant used in the path. The type is the type that the definition has to implement.</source>
          <target state="translated">Идентификатор-это имя константы,используемой в пути.Тип-это тип,который должно быть реализовано в определении.</target>
        </trans-unit>
        <trans-unit id="3a2c9033b8c31ad61606f019cbc00c4420b891b9" translate="yes" xml:space="preserve">
          <source>The identifier is the name of the declared type alias. The optional trait bounds must be fulfilled by the implementations of the type alias.</source>
          <target state="translated">Идентификатором является имя объявленного псевдонима типа.Необязательные границы трейта должны выполняться реализациями псевдонима типа.</target>
        </trans-unit>
        <trans-unit id="1c83f053af5e622145b3145a7189cafa0c9167a0" translate="yes" xml:space="preserve">
          <source>The identifier is the name of the function. The generics, parameter list, return type, and where clause of the associated function must be the same as the associated function declarations's.</source>
          <target state="translated">Идентификатором является имя функции.Генерики,список параметров,тип возврата,а также место,где выражение ассоциированной функции должно совпадать с объявлениями ассоциированной функции.</target>
        </trans-unit>
        <trans-unit id="c54b94a826db4a7c6ce8d411476041b69555f1aa" translate="yes" xml:space="preserve">
          <source>The identity function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a0f93995f216b848984f480fd53d07ae2b2c30e6" translate="yes" xml:space="preserve">
          <source>The idiomatic way to write a &lt;a href=&quot;trait.iterator#method.map&quot;&gt;&lt;code&gt;map&lt;/code&gt;&lt;/a&gt; for its side effects is to use a &lt;code&gt;for&lt;/code&gt; loop instead:</source>
          <target state="translated">Идиоматический способ написать &lt;a href=&quot;trait.iterator#method.map&quot;&gt; &lt;code&gt;map&lt;/code&gt; &lt;/a&gt; для ее побочных эффектов - использовать вместо этого цикл &lt;code&gt;for&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="20b4ace5ebaf142e4e8addc0656248d8010dca32" translate="yes" xml:space="preserve">
          <source>The idiomatic way to write a &lt;a href=&quot;trait.iterator#method.map&quot;&gt;&lt;code&gt;map&lt;/code&gt;&lt;/a&gt; for its side effects is to use a &lt;code&gt;for&lt;/code&gt; loop or call the &lt;a href=&quot;trait.iterator#method.for_each&quot;&gt;&lt;code&gt;for_each&lt;/code&gt;&lt;/a&gt; method:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1dc3122c538d92098d293869587f4b3a0100941a" translate="yes" xml:space="preserve">
          <source>The implementation ensures that the iterator will return exactly &lt;code&gt;len()&lt;/code&gt; more times a &lt;a href=&quot;../option/enum.option#variant.Some&quot;&gt;&lt;code&gt;Some(T)&lt;/code&gt;&lt;/a&gt; value, before returning &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt;. This method has a default implementation, so you usually should not implement it directly. However, if you can provide a more efficient implementation, you can do so. See the &lt;a href=&quot;trait.exactsizeiterator&quot;&gt;trait-level&lt;/a&gt; docs for an example.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a17be86477c61cc7613b2ed105a5af337a27c206" translate="yes" xml:space="preserve">
          <source>The implementation of &lt;code&gt;Display&lt;/code&gt; uses &lt;code&gt;self.0&lt;/code&gt; to access the inner &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt;, because &lt;code&gt;Wrapper&lt;/code&gt; is a tuple struct and &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; is the item at index 0 in the tuple. Then we can use the functionality of the &lt;code&gt;Display&lt;/code&gt; type on &lt;code&gt;Wrapper&lt;/code&gt;.</source>
          <target state="translated">Реализация &lt;code&gt;Display&lt;/code&gt; использует &lt;code&gt;self.0&lt;/code&gt; для доступа к внутреннему &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; , потому что &lt;code&gt;Wrapper&lt;/code&gt; - это структура кортежа, а &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; - это элемент с индексом 0 в кортеже. Затем мы можем использовать функциональность типа &lt;code&gt;Display&lt;/code&gt; в &lt;code&gt;Wrapper&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="64d2ca9bc84ea7c438a453f8d81beffdb2cea48b" translate="yes" xml:space="preserve">
          <source>The implementation of &lt;code&gt;get&lt;/code&gt; relies in particular on identical implementations of &lt;code&gt;Hash&lt;/code&gt; by determining the key&amp;rsquo;s hash bucket by calling &lt;code&gt;Hash::hash&lt;/code&gt; on the &lt;code&gt;Q&lt;/code&gt; value even though it inserted the key based on the hash value calculated from the &lt;code&gt;K&lt;/code&gt; value.</source>
          <target state="translated">Реализация &lt;code&gt;get&lt;/code&gt; зависит, в частности, от идентичных реализаций &lt;code&gt;Hash&lt;/code&gt; путем определения хэш-корзины ключа путем вызова &lt;code&gt;Hash::hash&lt;/code&gt; для значения &lt;code&gt;Q&lt;/code&gt; , даже если он вставил ключ на основе значения хеш-функции, вычисленного из значения &lt;code&gt;K&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9ddcc339944cbb72b0b66f63ad73cbbefd5f13bf" translate="yes" xml:space="preserve">
          <source>The implementation of this function must make sure to release any resources that are associated with this instance of a &lt;a href=&quot;struct.rawwaker&quot;&gt;&lt;code&gt;RawWaker&lt;/code&gt;&lt;/a&gt; and associated task.</source>
          <target state="translated">Реализация этой функции должна гарантировать освобождение всех ресурсов, связанных с этим экземпляром &lt;a href=&quot;struct.rawwaker&quot;&gt; &lt;code&gt;RawWaker&lt;/code&gt; &lt;/a&gt; и связанной с ним задачей.</target>
        </trans-unit>
        <trans-unit id="b2b66f02783344ac4bc18a2fce3954484c2ba8e0" translate="yes" xml:space="preserve">
          <source>The implementation of this function must retain all resources that are required for this additional instance of a &lt;a href=&quot;struct.rawwaker&quot;&gt;&lt;code&gt;RawWaker&lt;/code&gt;&lt;/a&gt; and associated task. Calling &lt;code&gt;wake&lt;/code&gt; on the resulting &lt;a href=&quot;struct.rawwaker&quot;&gt;&lt;code&gt;RawWaker&lt;/code&gt;&lt;/a&gt; should result in a wakeup of the same task that would have been awoken by the original &lt;a href=&quot;struct.rawwaker&quot;&gt;&lt;code&gt;RawWaker&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Реализация этой функции должна сохранять все ресурсы, которые требуются для этого дополнительного экземпляра &lt;a href=&quot;struct.rawwaker&quot;&gt; &lt;code&gt;RawWaker&lt;/code&gt; &lt;/a&gt; и связанной задачи. Вызов &lt;code&gt;wake&lt;/code&gt; в результирующем &lt;a href=&quot;struct.rawwaker&quot;&gt; &lt;code&gt;RawWaker&lt;/code&gt; &lt;/a&gt; должен привести к пробуждению той же задачи, которая была бы пробуждена исходным &lt;a href=&quot;struct.rawwaker&quot;&gt; &lt;code&gt;RawWaker&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="497d98f3948b6fc88a56b8970a7685389e682fb3" translate="yes" xml:space="preserve">
          <source>The implementation of waking a task on an executor.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d439e7f4f40d7bfe18d46ea25d8affbdc7117648" translate="yes" xml:space="preserve">
          <source>The implementation using the state pattern is easy to extend to add more functionality. To see the simplicity of maintaining code that uses the state pattern, try a few of these suggestions:</source>
          <target state="translated">Реализация с использованием шаблона состояния легко расширяется для добавления дополнительной функциональности.Чтобы увидеть простоту сопровождения кода,использующего шаблон состояния,попробуйте несколько из этих предложений:</target>
        </trans-unit>
        <trans-unit id="57e5372af92c8ddd71806b33dbda4afe86f48e3e" translate="yes" xml:space="preserve">
          <source>The implementing type within a &lt;a href=&quot;keyword.trait&quot;&gt;&lt;code&gt;trait&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;keyword.impl&quot;&gt;&lt;code&gt;impl&lt;/code&gt;&lt;/a&gt; block, or the current type within a type definition.</source>
          <target state="translated">&lt;a href=&quot;keyword.impl&quot;&gt; &lt;code&gt;impl&lt;/code&gt; &lt;/a&gt; тип в блоке &lt;a href=&quot;keyword.trait&quot;&gt; &lt;code&gt;trait&lt;/code&gt; &lt;/a&gt; или impl или текущий тип в определении типа.</target>
        </trans-unit>
        <trans-unit id="9972687dbff5abd8f4ecb962303ef66ce3678542" translate="yes" xml:space="preserve">
          <source>The index ranges returned by this trait are not required to exactly match those of the forward search in reverse.</source>
          <target state="translated">Диапазоны индексов,возвращаемые этим признаком,не требуются для точного совпадения с диапазонами прямого поиска в обратном направлении.</target>
        </trans-unit>
        <trans-unit id="fb8e7f22599fed31a57edfd5bc4f1d4fe1de7766" translate="yes" xml:space="preserve">
          <source>The indexed operand of an array indexing expression.</source>
          <target state="translated">Индексированный операнд выражения индексации массива.</target>
        </trans-unit>
        <trans-unit id="8a276159145a3d291ba8902040d397309a6a3910" translate="yes" xml:space="preserve">
          <source>The inferred type asks the compiler to infer the type if possible based on the surrounding information available. It cannot be used in item signatures. It is often used in generic arguments:</source>
          <target state="translated">Выведенный тип запрашивает у компилятора выводить тип,если это возможно,на основе имеющейся сопутствующей информации.Он не может быть использован в сигнатурах элементов.Часто используется в общих аргументах:</target>
        </trans-unit>
        <trans-unit id="1b63924c7210ee52ef50642e7b6012f573489c1d" translate="yes" xml:space="preserve">
          <source>The inherent methods of &lt;code&gt;Rc&lt;/code&gt; are all associated functions, which means that you have to call them as e.g., &lt;a href=&quot;#method.get_mut&quot;&gt;&lt;code&gt;Rc::get_mut(&amp;amp;mut value)&lt;/code&gt;&lt;/a&gt; instead of &lt;code&gt;value.get_mut()&lt;/code&gt;. This avoids conflicts with methods of the inner type &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">Все присущие &lt;code&gt;Rc&lt;/code&gt; методы являются связанными функциями, что означает, что вы должны вызывать их, например, как &lt;a href=&quot;#method.get_mut&quot;&gt; &lt;code&gt;Rc::get_mut(&amp;amp;mut value)&lt;/code&gt; &lt;/a&gt; вместо &lt;code&gt;value.get_mut()&lt;/code&gt; . Это позволяет избежать конфликтов с методами внутреннего типа &lt;code&gt;T&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="cdd48be31dd031602338fabd7f9987080846befd" translate="yes" xml:space="preserve">
          <source>The inherent methods of &lt;code&gt;Rc&lt;/code&gt; are all associated functions, which means that you have to call them as e.g., &lt;a href=&quot;struct.rc#method.get_mut&quot;&gt;&lt;code&gt;Rc::get_mut(&amp;amp;mut value)&lt;/code&gt;&lt;/a&gt; instead of &lt;code&gt;value.get_mut()&lt;/code&gt;. This avoids conflicts with methods of the inner type &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e9a135c5b11a6bdd25cebdf7bee36ffe6f4a888e" translate="yes" xml:space="preserve">
          <source>The initial value is the value the accumulator will have on the first call.</source>
          <target state="translated">Начальное значение-это значение,которое аккумулятор будет иметь при первом вызове.</target>
        </trans-unit>
        <trans-unit id="05cd051eb5f45770d700d15bc2c291712fe7349d" translate="yes" xml:space="preserve">
          <source>The initial value is the value the accumulator will have on the first call. If applying the closure succeeded against every element of the iterator, &lt;code&gt;try_fold()&lt;/code&gt; returns the final accumulator as success.</source>
          <target state="translated">Начальное значение - это значение, которое аккумулятор будет иметь при первом вызове. Если закрытие успешно применяется к каждому элементу итератора, &lt;code&gt;try_fold()&lt;/code&gt; возвращает последний аккумулятор как успешный.</target>
        </trans-unit>
        <trans-unit id="3215ce085488e89e5b23ed55a5028caf27292850" translate="yes" xml:space="preserve">
          <source>The initializer expression.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="005959a16886789f6cb716c2b5dc5bbb0daa12f9" translate="yes" xml:space="preserve">
          <source>The initializer of</source>
          <target state="translated">Инициализатор</target>
        </trans-unit>
        <trans-unit id="37009e2d28047124f91d44e005708dbff225d4db" translate="yes" xml:space="preserve">
          <source>The initializer of a &lt;a href=&quot;statements#let-statements&quot;&gt;let statement&lt;/a&gt;.</source>
          <target state="translated">Инициализатор оператора &lt;a href=&quot;statements#let-statements&quot;&gt;let&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="b9db1fa1a8ca22dc3f22f48be8f2cc5fef02b51c" translate="yes" xml:space="preserve">
          <source>The input &lt;a href=&quot;https://doc.rust-lang.org/proc_macro/struct.TokenStream.html&quot;&gt;&lt;code&gt;TokenStream&lt;/code&gt;&lt;/a&gt; is the token stream of the item that has the &lt;code&gt;derive&lt;/code&gt; attribute on it. The output &lt;a href=&quot;https://doc.rust-lang.org/proc_macro/struct.TokenStream.html&quot;&gt;&lt;code&gt;TokenStream&lt;/code&gt;&lt;/a&gt; must be a set of items that are then appended to the &lt;a href=&quot;items/modules&quot;&gt;module&lt;/a&gt; or &lt;a href=&quot;expressions/block-expr&quot;&gt;block&lt;/a&gt; that the item from the input &lt;a href=&quot;https://doc.rust-lang.org/proc_macro/struct.TokenStream.html&quot;&gt;&lt;code&gt;TokenStream&lt;/code&gt;&lt;/a&gt; is in.</source>
          <target state="translated">Входной &lt;a href=&quot;https://doc.rust-lang.org/proc_macro/struct.TokenStream.html&quot;&gt; &lt;code&gt;TokenStream&lt;/code&gt; &lt;/a&gt; - это токен-поток элемента, имеющего атрибут &lt;code&gt;derive&lt;/code&gt; . Выходной &lt;a href=&quot;https://doc.rust-lang.org/proc_macro/struct.TokenStream.html&quot;&gt; &lt;code&gt;TokenStream&lt;/code&gt; &lt;/a&gt; должен быть набором элементов, которые затем добавляются к &lt;a href=&quot;items/modules&quot;&gt;модулю&lt;/a&gt; или &lt;a href=&quot;expressions/block-expr&quot;&gt;блоку&lt;/a&gt; , в котором находится элемент из входного &lt;a href=&quot;https://doc.rust-lang.org/proc_macro/struct.TokenStream.html&quot;&gt; &lt;code&gt;TokenStream&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="3584f2f431d39b47066e06bb0ba2d085c77c3d1e" translate="yes" xml:space="preserve">
          <source>The input iterator &lt;code&gt;replace_with&lt;/code&gt; is only consumed when the &lt;code&gt;Splice&lt;/code&gt; value is dropped.</source>
          <target state="translated">Итератор ввода &lt;code&gt;replace_with&lt;/code&gt; используется только при &lt;code&gt;Splice&lt;/code&gt; значения Splice .</target>
        </trans-unit>
        <trans-unit id="5b45dbdf7cc3adb9c8ff29ad732df76183eebf5c" translate="yes" xml:space="preserve">
          <source>The installation of Rust also includes a copy of the documentation locally, so you can read it offline. Run &lt;code&gt;rustup doc&lt;/code&gt; to open the local documentation in your browser.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c198c64d60547785c3da652e9852896f77fa00d7" translate="yes" xml:space="preserve">
          <source>The installation script automatically adds Rust to your system PATH after your next login. If you want to start using Rust right away instead of restarting your terminal, run the following command in your shell to add Rust to your system PATH manually:</source>
          <target state="translated">Скрипт установки автоматически добавляет Rust в ваш системный PATH после вашего следующего входа в систему.Если вы хотите сразу же начать использовать Rust вместо перезагрузки терминала,запустите следующую команду в оболочке,чтобы добавить Rust в системный PATH вручную:</target>
        </trans-unit>
        <trans-unit id="a382c15195dddde8bba4823548e75c4adc802c3c" translate="yes" xml:space="preserve">
          <source>The installer also includes a copy of the documentation locally, so you can read it offline. Run &lt;code&gt;rustup doc&lt;/code&gt; to open the local documentation in your browser.</source>
          <target state="translated">Установщик также включает локальную копию документации, поэтому вы можете читать ее в автономном режиме. Запустите &lt;code&gt;rustup doc&lt;/code&gt; , чтобы открыть локальную документацию в вашем браузере.</target>
        </trans-unit>
        <trans-unit id="eb4481a6d93414e0e2ed7586ff1e0910b51585be" translate="yes" xml:space="preserve">
          <source>The integral types provide inherent methods to allow programmers explicitly to perform wrapping arithmetic. For example, &lt;code&gt;i32::wrapping_add&lt;/code&gt; provides two's complement, wrapping addition.</source>
          <target state="translated">Целочисленные типы предоставляют встроенные методы, позволяющие программистам явно выполнять арифметические операции с оболочкой. Например, &lt;code&gt;i32::wrapping_add&lt;/code&gt; обеспечивает дополнение до двух, добавление оболочки .</target>
        </trans-unit>
        <trans-unit id="a2f153ef163d784268a26bcb041875def3bd700b" translate="yes" xml:space="preserve">
          <source>The integration tests section starts with the line &lt;code&gt;Running target/debug/deps/integration_test-ce99bcc2479f4607&lt;/code&gt; (the hash at the end of your output will be different). Next, there is a line for each test function in that integration test and a summary line for the results of the integration test just before the &lt;code&gt;Doc-tests adder&lt;/code&gt; section starts.</source>
          <target state="translated">Раздел интеграционных тестов начинается со строки &lt;code&gt;Running target/debug/deps/integration_test-ce99bcc2479f4607&lt;/code&gt; (хеш в конце вашего вывода будет другим). Далее идет строка для каждой тестовой функции в этом интеграционном тесте и итоговая строка для результатов интеграционного теста непосредственно перед &lt;code&gt;Doc-tests adder&lt;/code&gt; раздела сумматора Doc-tests .</target>
        </trans-unit>
        <trans-unit id="9c8b39dac0f0603ab0205cf2bfd1df712c7506c4" translate="yes" xml:space="preserve">
          <source>The intention is that the underlying data is only valid for the lifetime &lt;code&gt;'a&lt;/code&gt;, so &lt;code&gt;Slice&lt;/code&gt; should not outlive &lt;code&gt;'a&lt;/code&gt;. However, this intent is not expressed in the code, since there are no uses of the lifetime &lt;code&gt;'a&lt;/code&gt; and hence it is not clear what data it applies to. We can correct this by telling the compiler to act &lt;em&gt;as if&lt;/em&gt; the &lt;code&gt;Slice&lt;/code&gt; struct contained a reference &lt;code&gt;&amp;amp;'a T&lt;/code&gt;:</source>
          <target state="translated">Предполагается, что базовые данные действительны только в течение времени жизни &lt;code&gt;'a&lt;/code&gt; , поэтому &lt;code&gt;Slice&lt;/code&gt; не должен &lt;code&gt;'a&lt;/code&gt; дольше a . Однако это намерение не выражено в коде, поскольку время жизни &lt;code&gt;'a&lt;/code&gt; не используется, и поэтому неясно, к каким данным оно применяется. Мы можем исправить это, указав компилятору действовать так, &lt;em&gt;как если&lt;/em&gt; бы структура &lt;code&gt;Slice&lt;/code&gt; содержала ссылку &lt;code&gt;&amp;amp;'a T&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="c6ec3ee71b429b0c861d2949630c53c1d4103ef2" translate="yes" xml:space="preserve">
          <source>The internal algorithm is not specified, and so it and its hashes should not be relied upon over releases.</source>
          <target state="translated">Внутренний алгоритм не указан,поэтому на него и на его хэши не следует полагаться поверх релизов.</target>
        </trans-unit>
        <trans-unit id="c411eb080c209397146b14ba5a4bb34e75cec138" translate="yes" xml:space="preserve">
          <source>The internal buffer is written out before returning the writer.</source>
          <target state="translated">Внутренний буфер выписывается перед возвращением записывающего устройства.</target>
        </trans-unit>
        <trans-unit id="06716cd4a735b362271ebfeb2853eaa89b39ee1b" translate="yes" xml:space="preserve">
          <source>The internal iterator over the argument has not been advanced by the time the first &lt;code&gt;{}&lt;/code&gt; is seen, so it prints the first argument. Then upon reaching the second &lt;code&gt;{}&lt;/code&gt;, the iterator has advanced forward to the second argument. Essentially, parameters that explicitly name their argument do not affect parameters that do not name an argument in terms of positional specifiers.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ce78ff22afeda7a6f00a6ca8444175752d52c4ff" translate="yes" xml:space="preserve">
          <source>The internal iterator over the argument has not been advanced by the time the first &lt;code&gt;{}&lt;/code&gt; is seen, so it prints the first argument. Then upon reaching the second &lt;code&gt;{}&lt;/code&gt;, the iterator has advanced forward to the second argument. Essentially, parameters which explicitly name their argument do not affect parameters which do not name an argument in terms of positional specifiers.</source>
          <target state="translated">Внутренний итератор по аргументу не был продвинут к моменту появления первого &lt;code&gt;{}&lt;/code&gt; , поэтому он печатает первый аргумент. Затем, достигнув второго &lt;code&gt;{}&lt;/code&gt; , итератор перешел ко второму аргументу. По сути, параметры, которые явно называют свой аргумент, не влияют на параметры, которые не именуют аргумент в терминах позиционных спецификаторов.</target>
        </trans-unit>
        <trans-unit id="2c46dda1624f616f75baf2894d6d6e54ab12f317" translate="yes" xml:space="preserve">
          <source>The inverse of this method is &lt;a href=&quot;#method.from_utf8&quot;&gt;&lt;code&gt;from_utf8&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Обратный к этому методу - &lt;a href=&quot;#method.from_utf8&quot;&gt; &lt;code&gt;from_utf8&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="dbc762f2fb2ae9279c20887c42fbcb66ef8ed68d" translate="yes" xml:space="preserve">
          <source>The inverse of this method is &lt;a href=&quot;struct.string#method.as_bytes&quot;&gt;&lt;code&gt;as_bytes&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Обратный к этому методу - &lt;a href=&quot;struct.string#method.as_bytes&quot;&gt; &lt;code&gt;as_bytes&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="2ef5a2c8bf418a538796f28bdc7b3ed8b4214bec" translate="yes" xml:space="preserve">
          <source>The inverse of this method is &lt;a href=&quot;struct.string#method.from_utf8&quot;&gt;&lt;code&gt;from_utf8&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="00033d91f205bb0450cf7878d82bad2da288007b" translate="yes" xml:space="preserve">
          <source>The inverse of this method is &lt;a href=&quot;struct.string#method.into_bytes&quot;&gt;&lt;code&gt;into_bytes&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0d5754a49ec3bccb9874e0108120d01b2fee9ec9" translate="yes" xml:space="preserve">
          <source>The issue can be resolved by changing the associated type:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2057c4ad17ebd71c1902c8394bd83a7474bbd6d5" translate="yes" xml:space="preserve">
          <source>The issue in this case is that &lt;code&gt;foo&lt;/code&gt; is defined as accepting a &lt;code&gt;Fn&lt;/code&gt; with one argument of type &lt;code&gt;String&lt;/code&gt;, but the closure we attempted to pass to it requires one arguments of type &lt;code&gt;usize&lt;/code&gt;.</source>
          <target state="translated">Проблема в этом случае заключается в том, что &lt;code&gt;foo&lt;/code&gt; определяется как принимающий &lt;code&gt;Fn&lt;/code&gt; с одним аргументом типа &lt;code&gt;String&lt;/code&gt; , но закрытие, которое мы пытались передать ему, требует одного аргумента типа &lt;code&gt;usize&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c02789dc84a563007f1b001c6388d43c1756fd64" translate="yes" xml:space="preserve">
          <source>The issue with the tuple code in Listing 4-5 is that we have to return the &lt;code&gt;String&lt;/code&gt; to the calling function so we can still use the &lt;code&gt;String&lt;/code&gt; after the call to &lt;code&gt;calculate_length&lt;/code&gt;, because the &lt;code&gt;String&lt;/code&gt; was moved into &lt;code&gt;calculate_length&lt;/code&gt;.</source>
          <target state="translated">Проблема с кодом кортежа в листинге 4-5 заключается в том, что мы должны вернуть &lt;code&gt;String&lt;/code&gt; в вызывающую функцию, чтобы мы могли использовать &lt;code&gt;String&lt;/code&gt; после вызова метода &lt;code&gt;calculate_length&lt;/code&gt; , потому что &lt;code&gt;String&lt;/code&gt; была перемещена в &lt;code&gt;calculate_length&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1013a496d8eb9ca295e23a82f7ffaec17e1ba13a" translate="yes" xml:space="preserve">
          <source>The issue with this code is evident in the signature of &lt;code&gt;area&lt;/code&gt;:</source>
          <target state="translated">Проблема с этим кодом очевидна в подписи &lt;code&gt;area&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="e382444929f7f8a00ff868439efd08f11891e2df" translate="yes" xml:space="preserve">
          <source>The items of marker traits cannot be overridden, so there's no need to have them when they cannot be changed per-type anyway. If you wanted them for ergonomic reasons, consider making an extension trait instead.</source>
          <target state="translated">Элементы признаков маркера не могут быть переопределены,поэтому нет необходимости иметь их,когда они не могут быть изменены для каждого типа в любом случае.Если они нужны вам по эргономическим соображениям,подумайте о создании признака расширения.</target>
        </trans-unit>
        <trans-unit id="5e506ce8ee681f90bb70782d8bb4d2dad5bd0685" translate="yes" xml:space="preserve">
          <source>The iterator element type is &lt;a href=&quot;../path/struct.pathbuf&quot;&gt;&lt;code&gt;PathBuf&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Тип элемента итератора - &lt;a href=&quot;../path/struct.pathbuf&quot;&gt; &lt;code&gt;PathBuf&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="6824e2e2ab7393d35f45cbd58638289d41c35be1" translate="yes" xml:space="preserve">
          <source>The iterator must produce exactly the number of elements it reported or diverge before reaching the end.</source>
          <target state="translated">Итератор должен выдать точное количество элементов,о которых он сообщил,или отклониться от них,прежде чем достигнет конца.</target>
        </trans-unit>
        <trans-unit id="857086b346b7dd5e8adf55ad86cbe1dbbf8cbe54" translate="yes" xml:space="preserve">
          <source>The iterator pattern allows you to perform some task on a sequence of items in turn. An iterator is responsible for the logic of iterating over each item and determining when the sequence has finished. When you use iterators, you don&amp;rsquo;t have to reimplement that logic yourself.</source>
          <target state="translated">Шаблон итератора позволяет вам по очереди выполнять некоторые задачи над последовательностью элементов. Итератор отвечает за логику перебора каждого элемента и определения, когда последовательность закончилась. Когда вы используете итераторы, вам не нужно заново реализовывать эту логику.</target>
        </trans-unit>
        <trans-unit id="6db07328b493618fb3fe592624d4f327dc32ce7b" translate="yes" xml:space="preserve">
          <source>The iterator reports a size hint where it is either exact (lower bound is equal to upper bound), or the upper bound is &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt;. The upper bound must only be &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt; if the actual iterator length is larger than &lt;a href=&quot;../usize/constant.max&quot;&gt;&lt;code&gt;usize::MAX&lt;/code&gt;&lt;/a&gt;. In that case, the lower bound must be &lt;a href=&quot;../usize/constant.max&quot;&gt;&lt;code&gt;usize::MAX&lt;/code&gt;&lt;/a&gt;, resulting in a &lt;a href=&quot;trait.iterator#method.size_hint&quot;&gt;&lt;code&gt;.size_hint&lt;/code&gt;&lt;/a&gt; of &lt;code&gt;(usize::MAX, None)&lt;/code&gt;.</source>
          <target state="translated">Итератор сообщает подсказку о размере, где она либо точна (нижняя граница равна верхней), либо верхняя граница - &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt; &lt;code&gt;None&lt;/code&gt; &lt;/a&gt; . Верхняя граница должна быть &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt; &lt;code&gt;None&lt;/code&gt; &lt;/a&gt; только в том случае, если фактическая длина итератора больше, чем &lt;a href=&quot;../usize/constant.max&quot;&gt; &lt;code&gt;usize::MAX&lt;/code&gt; &lt;/a&gt; . В этом случае нижняя граница должна быть &lt;a href=&quot;../usize/constant.max&quot;&gt; &lt;code&gt;usize::MAX&lt;/code&gt; &lt;/a&gt; , в результате чего &lt;a href=&quot;trait.iterator#method.size_hint&quot;&gt; &lt;code&gt;.size_hint&lt;/code&gt; &lt;/a&gt; из &lt;code&gt;(usize::MAX, None)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="761f99bb11c75b1d69af8441ba4ad3812f9ffc53" translate="yes" xml:space="preserve">
          <source>The iterator reports a size hint where it is either exact (lower bound is equal to upper bound), or the upper bound is &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt;. The upper bound must only be &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt; if the actual iterator length is larger than &lt;a href=&quot;../usize/constant.max&quot;&gt;&lt;code&gt;usize::MAX&lt;/code&gt;&lt;/a&gt;. In that case, the lower bound must be &lt;a href=&quot;../usize/constant.max&quot;&gt;&lt;code&gt;usize::MAX&lt;/code&gt;&lt;/a&gt;, resulting in a &lt;a href=&quot;trait.iterator#method.size_hint&quot;&gt;&lt;code&gt;Iterator::size_hint()&lt;/code&gt;&lt;/a&gt; of &lt;code&gt;(usize::MAX, None)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f5b68d7a8101dc216e0d59f65c1ebaa471e720b2" translate="yes" xml:space="preserve">
          <source>The iterator returned from this function will return instances of &lt;a href=&quot;type.result&quot;&gt;&lt;code&gt;io::Result&lt;/code&gt;&lt;/a&gt;&lt;code&gt;&amp;lt;&lt;/code&gt;&lt;a href=&quot;../vec/struct.vec&quot;&gt;&lt;code&gt;Vec&amp;lt;u8&amp;gt;&lt;/code&gt;&lt;/a&gt;&lt;code&gt;&amp;gt;&lt;/code&gt;. Each vector returned will &lt;em&gt;not&lt;/em&gt; have the delimiter byte at the end.</source>
          <target state="translated">Итератор, возвращенный этой функцией, вернет экземпляры &lt;a href=&quot;type.result&quot;&gt; &lt;code&gt;io::Result&lt;/code&gt; &lt;/a&gt; &lt;code&gt;&amp;lt;&lt;/code&gt; &lt;a href=&quot;../vec/struct.vec&quot;&gt; &lt;code&gt;Vec&amp;lt;u8&amp;gt;&lt;/code&gt; &lt;/a&gt; &lt;code&gt;&amp;gt;&lt;/code&gt; . Каждый возвращаемый вектор &lt;em&gt;не&lt;/em&gt; будет иметь байта-разделителя в конце.</target>
        </trans-unit>
        <trans-unit id="43d518530c9a6385f97f5ea0cf3b95e6447ddfae" translate="yes" xml:space="preserve">
          <source>The iterator returned from this function will yield instances of &lt;a href=&quot;type.result&quot;&gt;&lt;code&gt;io::Result&lt;/code&gt;&lt;/a&gt;&lt;code&gt;&amp;lt;&lt;/code&gt;&lt;a href=&quot;../string/struct.string&quot;&gt;&lt;code&gt;String&lt;/code&gt;&lt;/a&gt;&lt;code&gt;&amp;gt;&lt;/code&gt;. Each string returned will &lt;em&gt;not&lt;/em&gt; have a newline byte (the 0xA byte) or CRLF (0xD, 0xA bytes) at the end.</source>
          <target state="translated">Итератор, возвращенный этой функцией, даст экземпляры &lt;a href=&quot;type.result&quot;&gt; &lt;code&gt;io::Result&lt;/code&gt; &lt;/a&gt; &lt;code&gt;&amp;lt;&lt;/code&gt; &lt;a href=&quot;../string/struct.string&quot;&gt; &lt;code&gt;String&lt;/code&gt; &lt;/a&gt; &lt;code&gt;&amp;gt;&lt;/code&gt; . Каждая возвращенная строка &lt;em&gt;не&lt;/em&gt; будет иметь в конце байта новой строки (байта 0xA) или CRLF (байта 0xD, 0xA).</target>
        </trans-unit>
        <trans-unit id="11be39dc954e81f8e71f68fa0b756ad22ee17df7" translate="yes" xml:space="preserve">
          <source>The iterator returned from this function will yield instances of &lt;a href=&quot;type.result&quot;&gt;&lt;code&gt;io::Result&lt;/code&gt;&lt;/a&gt;&lt;code&gt;&amp;lt;&lt;/code&gt;&lt;a href=&quot;../string/struct.string&quot;&gt;&lt;code&gt;String&lt;/code&gt;&lt;/a&gt;&lt;code&gt;&amp;gt;&lt;/code&gt;. Each string returned will &lt;em&gt;not&lt;/em&gt; have a newline byte (the &lt;code&gt;0xA&lt;/code&gt; byte) or &lt;code&gt;CRLF&lt;/code&gt; (&lt;code&gt;0xD&lt;/code&gt;, &lt;code&gt;0xA&lt;/code&gt; bytes) at the end.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d98222c90db1c99a084846a0ad925665e5230738" translate="yes" xml:space="preserve">
          <source>The iterator returned will return string slices that are sub-slices of the original string slice, separated by any amount of ASCII whitespace.</source>
          <target state="translated">Возвращаемый итератор вернет фрагменты строки,являющиеся субликами исходного фрагмента строки,разделенными любым количеством пробельных символов ASCII.</target>
        </trans-unit>
        <trans-unit id="406100c150ec04008e29a14c30e99aed0f63af21" translate="yes" xml:space="preserve">
          <source>The iterator returned will return string slices that are sub-slices of the original string slice, separated by any amount of whitespace.</source>
          <target state="translated">Возвращаемый итератор вернет фрагменты строки,являющиеся субликами исходного фрагмента строки,разделенными любым количеством пробельных символов.</target>
        </trans-unit>
        <trans-unit id="4221546e7793ded4aa41dc1718c0ee56c99339b5" translate="yes" xml:space="preserve">
          <source>The iterator returned yields pairs &lt;code&gt;(i, val)&lt;/code&gt;, where &lt;code&gt;i&lt;/code&gt; is the current index of iteration and &lt;code&gt;val&lt;/code&gt; is the value returned by the iterator.</source>
          <target state="translated">Возвращенный итератором возвращает пары &lt;code&gt;(i, val)&lt;/code&gt; , где &lt;code&gt;i&lt;/code&gt; - текущий индекс итерации, а &lt;code&gt;val&lt;/code&gt; - значение, возвращаемое итератором.</target>
        </trans-unit>
        <trans-unit id="0d65a2fef7d4c6664fcfb9659495ac349d06a758" translate="yes" xml:space="preserve">
          <source>The iterator starts with the given first item (if any) and calls the given &lt;code&gt;FnMut(&amp;amp;T) -&amp;gt; Option&amp;lt;T&amp;gt;&lt;/code&gt; closure to compute each item&amp;rsquo;s successor.</source>
          <target state="translated">Итератор начинается с данного первого элемента (если есть) и вызывает данное &lt;code&gt;FnMut(&amp;amp;T) -&amp;gt; Option&amp;lt;T&amp;gt;&lt;/code&gt; для вычисления преемника каждого элемента.</target>
        </trans-unit>
        <trans-unit id="fe7ef8d083d96a8372351bad5e0da1e04819839b" translate="yes" xml:space="preserve">
          <source>The iterator version was slightly faster! We won&amp;rsquo;t explain the benchmark code here, because the point is not to prove that the two versions are equivalent but to get a general sense of how these two implementations compare performance-wise.</source>
          <target state="translated">Версия итератора была немного быстрее! Мы не будем объяснять здесь тестовый код, потому что цель не в том, чтобы доказать, что две версии эквивалентны, а в том, чтобы получить общее представление о том, как эти две реализации сравниваются с точки зрения производительности.</target>
        </trans-unit>
        <trans-unit id="40a9eac2c27490989d9bce69b525d51e8393ef6d" translate="yes" xml:space="preserve">
          <source>The iterator will never return &lt;a href=&quot;../../../option/enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt; and will also not yield the peer's &lt;a href=&quot;struct.socketaddr&quot;&gt;&lt;code&gt;SocketAddr&lt;/code&gt;&lt;/a&gt; structure.</source>
          <target state="translated">Итератор никогда не вернет &lt;a href=&quot;../../../option/enum.option#variant.None&quot;&gt; &lt;code&gt;None&lt;/code&gt; ,&lt;/a&gt; а также не &lt;a href=&quot;struct.socketaddr&quot;&gt; &lt;code&gt;SocketAddr&lt;/code&gt; &lt;/a&gt; структуру SocketAddr партнера .</target>
        </trans-unit>
        <trans-unit id="1eb81e5b136891ec83f03fa70901b0982c774c3e" translate="yes" xml:space="preserve">
          <source>The iterator will yield instances of &lt;a href=&quot;../io/type.result&quot;&gt;&lt;code&gt;io::Result&lt;/code&gt;&lt;/a&gt;&lt;code&gt;&amp;lt;&lt;/code&gt;&lt;a href=&quot;../fs/struct.direntry&quot;&gt;&lt;code&gt;DirEntry&lt;/code&gt;&lt;/a&gt;&lt;code&gt;&amp;gt;&lt;/code&gt;. New errors may be encountered after an iterator is initially constructed.</source>
          <target state="translated">Итератор выдаст экземпляры &lt;a href=&quot;../io/type.result&quot;&gt; &lt;code&gt;io::Result&lt;/code&gt; &lt;/a&gt; &lt;code&gt;&amp;lt;&lt;/code&gt; &lt;a href=&quot;../fs/struct.direntry&quot;&gt; &lt;code&gt;DirEntry&lt;/code&gt; &lt;/a&gt; &lt;code&gt;&amp;gt;&lt;/code&gt; . После первоначального построения итератора могут возникнуть новые ошибки.</target>
        </trans-unit>
        <trans-unit id="fea22bab4e7d7d638613556e79b891a323ca2ee5" translate="yes" xml:space="preserve">
          <source>The iterator will yield instances of &lt;a href=&quot;../io/type.result&quot;&gt;&lt;code&gt;io::Result&lt;/code&gt;&lt;/a&gt;&lt;code&gt;&amp;lt;&lt;/code&gt;&lt;a href=&quot;../fs/struct.direntry&quot;&gt;&lt;code&gt;fs::DirEntry&lt;/code&gt;&lt;/a&gt;&lt;code&gt;&amp;gt;&lt;/code&gt;. New errors may be encountered after an iterator is initially constructed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="54667f9a5f59c23223b23e9276c48f67c43aae4e" translate="yes" xml:space="preserve">
          <source>The iterator will yield instances of &lt;a href=&quot;../io/type.result&quot;&gt;&lt;code&gt;io::Result&lt;/code&gt;&lt;/a&gt;&lt;code&gt;&amp;lt;&lt;/code&gt;&lt;a href=&quot;struct.direntry&quot;&gt;&lt;code&gt;DirEntry&lt;/code&gt;&lt;/a&gt;&lt;code&gt;&amp;gt;&lt;/code&gt;. New errors may be encountered after an iterator is initially constructed.</source>
          <target state="translated">Итератор выдаст экземпляры &lt;a href=&quot;../io/type.result&quot;&gt; &lt;code&gt;io::Result&lt;/code&gt; &lt;/a&gt; &lt;code&gt;&amp;lt;&lt;/code&gt; &lt;a href=&quot;struct.direntry&quot;&gt; &lt;code&gt;DirEntry&lt;/code&gt; &lt;/a&gt; &lt;code&gt;&amp;gt;&lt;/code&gt; . После первоначального построения итератора могут возникнуть новые ошибки.</target>
        </trans-unit>
        <trans-unit id="6720eac87f145ca4ebd08c14afcbc3e18eb5bc63" translate="yes" xml:space="preserve">
          <source>The iterator will yield the &lt;code&gt;Path&lt;/code&gt; that is returned if the &lt;a href=&quot;struct.path#method.parent&quot;&gt;&lt;code&gt;parent&lt;/code&gt;&lt;/a&gt; method is used zero or more times. That means, the iterator will yield &lt;code&gt;&amp;amp;self&lt;/code&gt;, &lt;code&gt;&amp;amp;self.parent().unwrap()&lt;/code&gt;, &lt;code&gt;&amp;amp;self.parent().unwrap().parent().unwrap()&lt;/code&gt; and so on. If the &lt;a href=&quot;struct.path#method.parent&quot;&gt;&lt;code&gt;parent&lt;/code&gt;&lt;/a&gt; method returns &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt;, the iterator will do likewise. The iterator will always yield at least one value, namely &lt;code&gt;&amp;amp;self&lt;/code&gt;.</source>
          <target state="translated">Итератор вернет &lt;code&gt;Path&lt;/code&gt; который возвращается, если &lt;a href=&quot;struct.path#method.parent&quot;&gt; &lt;code&gt;parent&lt;/code&gt; &lt;/a&gt; метод используется ноль или более раз. Это означает, что итератор выдаст &lt;code&gt;&amp;amp;self&lt;/code&gt; , &lt;code&gt;&amp;amp;self.parent().unwrap()&lt;/code&gt; , &lt;code&gt;&amp;amp;self.parent().unwrap().parent().unwrap()&lt;/code&gt; и так далее. Если &lt;a href=&quot;struct.path#method.parent&quot;&gt; &lt;code&gt;parent&lt;/code&gt; &lt;/a&gt; метод возвращает &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt; &lt;code&gt;None&lt;/code&gt; &lt;/a&gt; , итератор будет делать то же самое. Итератор всегда возвращает хотя бы одно значение, а именно &lt;code&gt;&amp;amp;self&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="36ed296a3da7075e704c60a55541d4eefcc61a2e" translate="yes" xml:space="preserve">
          <source>The iterator yields one value if the &lt;a href=&quot;enum.option&quot;&gt;&lt;code&gt;Option&lt;/code&gt;&lt;/a&gt; is a &lt;a href=&quot;enum.option#variant.Some&quot;&gt;&lt;code&gt;Some&lt;/code&gt;&lt;/a&gt;, otherwise none.</source>
          <target state="translated">Итератор выдает одно значение, если &lt;a href=&quot;enum.option&quot;&gt; &lt;code&gt;Option&lt;/code&gt; &lt;/a&gt; - &lt;a href=&quot;enum.option#variant.Some&quot;&gt; &lt;code&gt;Some&lt;/code&gt; &lt;/a&gt; , в противном случае - нет.</target>
        </trans-unit>
        <trans-unit id="33a7221657feedb4eb9bdbc29b15b1cfdbff0941" translate="yes" xml:space="preserve">
          <source>The iterator yields one value if the result is &lt;a href=&quot;../result/enum.result#Ok.v&quot;&gt;&lt;code&gt;Result::Ok&lt;/code&gt;&lt;/a&gt;, otherwise none.</source>
          <target state="translated">Итератор возвращает одно значение, если результатом является &lt;a href=&quot;../result/enum.result#Ok.v&quot;&gt; &lt;code&gt;Result::Ok&lt;/code&gt; &lt;/a&gt; , в противном случае - нет.</target>
        </trans-unit>
        <trans-unit id="98fcd488b58bec9ba13c409525786e8e34d2f3d0" translate="yes" xml:space="preserve">
          <source>The iterator yields one value if the result is &lt;a href=&quot;../result/enum.result#variant.Ok&quot;&gt;&lt;code&gt;Result::Ok&lt;/code&gt;&lt;/a&gt;, otherwise none.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="908b09e4328c560c75c00a1be9bba8fa3c1792fa" translate="yes" xml:space="preserve">
          <source>The iterator yields one value if the result is &lt;a href=&quot;enum.result#Ok.v&quot;&gt;&lt;code&gt;Result::Ok&lt;/code&gt;&lt;/a&gt;, otherwise none.</source>
          <target state="translated">Итератор возвращает одно значение, если результатом является &lt;a href=&quot;enum.result#Ok.v&quot;&gt; &lt;code&gt;Result::Ok&lt;/code&gt; &lt;/a&gt; , в противном случае - нет.</target>
        </trans-unit>
        <trans-unit id="8fd298b9ad5df85747acb6e44bba1366e3481860" translate="yes" xml:space="preserve">
          <source>The iterator yields one value if the result is &lt;a href=&quot;enum.result#variant.Ok&quot;&gt;&lt;code&gt;Ok&lt;/code&gt;&lt;/a&gt;, otherwise none.</source>
          <target state="translated">Итератор возвращает одно значение, если результат &lt;a href=&quot;enum.result#variant.Ok&quot;&gt; &lt;code&gt;Ok&lt;/code&gt; &lt;/a&gt; , в противном случае - нет.</target>
        </trans-unit>
        <trans-unit id="41c263ba9c3e1377bcbb306e69ddac6adfb8f150" translate="yes" xml:space="preserve">
          <source>The iterator yields one value if the result is &lt;a href=&quot;enum.result#variant.Ok&quot;&gt;&lt;code&gt;Result::Ok&lt;/code&gt;&lt;/a&gt;, otherwise none.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b80110840b4186388c3ebdd6fff4960efb23a3ca" translate="yes" xml:space="preserve">
          <source>The iterator yields tuples. The position is first, the &lt;a href=&quot;../char/index&quot;&gt;&lt;code&gt;char&lt;/code&gt;&lt;/a&gt; is second.</source>
          <target state="translated">Итератор выдает кортежи. Позиция первая, &lt;a href=&quot;../char/index&quot;&gt; &lt;code&gt;char&lt;/code&gt; &lt;/a&gt; - вторая.</target>
        </trans-unit>
        <trans-unit id="6ec1542f766c1ecbdef3897acebe4cebd30ca6ee" translate="yes" xml:space="preserve">
          <source>The iterator yields tuples. The position is first, the &lt;a href=&quot;../primitive.char&quot;&gt;&lt;code&gt;char&lt;/code&gt;&lt;/a&gt; is second.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="787f68c0ad38019edb27d78451a4d5831f65e4ab" translate="yes" xml:space="preserve">
          <source>The iterator yields tuples. The position is first, the &lt;a href=&quot;char/index&quot;&gt;&lt;code&gt;char&lt;/code&gt;&lt;/a&gt; is second.</source>
          <target state="translated">Итератор выдает кортежи. Позиция первая, &lt;a href=&quot;char/index&quot;&gt; &lt;code&gt;char&lt;/code&gt; &lt;/a&gt; - вторая.</target>
        </trans-unit>
        <trans-unit id="10db2a64e13645a875ad4c150b72d85dec4465d0" translate="yes" xml:space="preserve">
          <source>The iterator yields tuples. The position is first, the &lt;a href=&quot;primitive.char&quot;&gt;&lt;code&gt;char&lt;/code&gt;&lt;/a&gt; is second.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6814fb791ef3836a2e395759e70c2ff3a369ee11" translate="yes" xml:space="preserve">
          <source>The job of &lt;code&gt;read_line&lt;/code&gt; is to take whatever the user types into standard input and place that into a string, so it takes that string as an argument. The string argument needs to be mutable so the method can change the string&amp;rsquo;s content by adding the user input.</source>
          <target state="translated">Задача &lt;code&gt;read_line&lt;/code&gt; - взять все, что вводит пользователь, в стандартный ввод и поместить это в строку, чтобы она принимала эту строку в качестве аргумента. Строковый аргумент должен быть изменяемым, чтобы метод мог изменять содержимое строки, добавляя ввод пользователя.</target>
        </trans-unit>
        <trans-unit id="41c36730094f242762fc2db352770667844d977d" translate="yes" xml:space="preserve">
          <source>The join handle will implicitly &lt;em&gt;detach&lt;/em&gt; the child thread upon being dropped. In this case, the child thread may outlive the parent (unless the parent thread is the main thread; the whole process is terminated when the main thread finishes). Additionally, the join handle provides a &lt;a href=&quot;struct.joinhandle#method.join&quot;&gt;&lt;code&gt;join&lt;/code&gt;&lt;/a&gt; method that can be used to join the child thread. If the child thread panics, &lt;a href=&quot;struct.joinhandle#method.join&quot;&gt;&lt;code&gt;join&lt;/code&gt;&lt;/a&gt; will return an &lt;a href=&quot;../result/enum.result#variant.Err&quot;&gt;&lt;code&gt;Err&lt;/code&gt;&lt;/a&gt; containing the argument given to &lt;a href=&quot;../macro.panic&quot;&gt;&lt;code&gt;panic!&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cc7b114b0c6414134b72184594654a5acaffb577" translate="yes" xml:space="preserve">
          <source>The join handle will implicitly &lt;em&gt;detach&lt;/em&gt; the child thread upon being dropped. In this case, the child thread may outlive the parent (unless the parent thread is the main thread; the whole process is terminated when the main thread finishes). Additionally, the join handle provides a &lt;a href=&quot;struct.joinhandle#method.join&quot;&gt;&lt;code&gt;join&lt;/code&gt;&lt;/a&gt; method that can be used to join the child thread. If the child thread panics, &lt;a href=&quot;struct.joinhandle#method.join&quot;&gt;&lt;code&gt;join&lt;/code&gt;&lt;/a&gt; will return an &lt;a href=&quot;../result/enum.result#variant.Err&quot;&gt;&lt;code&gt;Err&lt;/code&gt;&lt;/a&gt; containing the argument given to &lt;a href=&quot;../macro.panic&quot;&gt;&lt;code&gt;panic&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Дескриптор соединения неявно &lt;em&gt;отсоединит&lt;/em&gt; дочерний поток после удаления. В этом случае дочерний поток может пережить родительский (если родительский поток не является основным; весь процесс завершается, когда основной поток завершается). Кроме того, дескриптор соединения предоставляет метод &lt;a href=&quot;struct.joinhandle#method.join&quot;&gt; &lt;code&gt;join&lt;/code&gt; &lt;/a&gt; который можно использовать для присоединения к дочернему потоку. Если дочерний поток паникует, &lt;a href=&quot;struct.joinhandle#method.join&quot;&gt; &lt;code&gt;join&lt;/code&gt; &lt;/a&gt; вернет &lt;a href=&quot;../result/enum.result#variant.Err&quot;&gt; &lt;code&gt;Err&lt;/code&gt; ,&lt;/a&gt; содержащий аргумент, заданный для &lt;a href=&quot;../macro.panic&quot;&gt; &lt;code&gt;panic&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="099a2e1e2bdb72897b42735f9f375efdb1e2c049" translate="yes" xml:space="preserve">
          <source>The key line in this error is &lt;code&gt;cannot move out of type [T], a non-copy slice&lt;/code&gt;. With our non-generic versions of the &lt;code&gt;largest&lt;/code&gt; function, we were only trying to find the largest &lt;code&gt;i32&lt;/code&gt; or &lt;code&gt;char&lt;/code&gt;. As discussed in the &lt;a href=&quot;ch04-01-what-is-ownership#stack-only-data-copy&quot;&gt;&amp;ldquo;Stack-Only Data: Copy&amp;rdquo;&lt;/a&gt; section in Chapter 4, types like &lt;code&gt;i32&lt;/code&gt; and &lt;code&gt;char&lt;/code&gt; that have a known size can be stored on the stack, so they implement the &lt;code&gt;Copy&lt;/code&gt; trait. But when we made the &lt;code&gt;largest&lt;/code&gt; function generic, it became possible for the &lt;code&gt;list&lt;/code&gt; parameter to have types in it that don&amp;rsquo;t implement the &lt;code&gt;Copy&lt;/code&gt; trait. Consequently, we wouldn&amp;rsquo;t be able to move the value out of &lt;code&gt;list[0]&lt;/code&gt; and into the &lt;code&gt;largest&lt;/code&gt; variable, resulting in this error.</source>
          <target state="translated">Ключевая строка в этой ошибке - &lt;code&gt;cannot move out of type [T], a non-copy slice&lt;/code&gt; . В наших неуниверсальных версиях самой &lt;code&gt;largest&lt;/code&gt; функции мы пытались найти только самый большой &lt;code&gt;i32&lt;/code&gt; или &lt;code&gt;char&lt;/code&gt; . Как обсуждалось в разделе &lt;a href=&quot;ch04-01-what-is-ownership#stack-only-data-copy&quot;&gt;&amp;laquo;Данные только для стека: копирование&amp;raquo;&lt;/a&gt; в главе 4, такие типы, как &lt;code&gt;i32&lt;/code&gt; и &lt;code&gt;char&lt;/code&gt; , которые имеют известный размер, могут быть сохранены в стеке, поэтому они реализуют свойство &lt;code&gt;Copy&lt;/code&gt; . Но когда мы сделали самую &lt;code&gt;largest&lt;/code&gt; функцию универсальной, стало возможным для параметра &lt;code&gt;list&lt;/code&gt; иметь в нем типы, которые не реализуют &lt;code&gt;Copy&lt;/code&gt; черта. Следовательно, мы не сможем переместить значение из &lt;code&gt;list[0]&lt;/code&gt; в самую &lt;code&gt;largest&lt;/code&gt; переменную, что приведет к этой ошибке.</target>
        </trans-unit>
        <trans-unit id="bceeadadeee15f4a164537fd341fe02f08db51ce" translate="yes" xml:space="preserve">
          <source>The key may be any borrowed form of the map's key type, but &lt;a href=&quot;../../hash/trait.hash&quot;&gt;&lt;code&gt;Hash&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../../cmp/trait.eq&quot;&gt;&lt;code&gt;Eq&lt;/code&gt;&lt;/a&gt; on the borrowed form &lt;em&gt;must&lt;/em&gt; match those for the key type.</source>
          <target state="translated">Ключ может быть любой заимствованной формой типа ключа карты, но &lt;a href=&quot;../../hash/trait.hash&quot;&gt; &lt;code&gt;Hash&lt;/code&gt; &lt;/a&gt; и &lt;a href=&quot;../../cmp/trait.eq&quot;&gt; &lt;code&gt;Eq&lt;/code&gt; &lt;/a&gt; в заимствованной форме &lt;em&gt;должны&lt;/em&gt; совпадать с таковыми для типа ключа.</target>
        </trans-unit>
        <trans-unit id="1967c0afcde1ba185b21a2a66c76557126c2a896" translate="yes" xml:space="preserve">
          <source>The key may be any borrowed form of the map's key type, but &lt;a href=&quot;../hash/trait.hash&quot;&gt;&lt;code&gt;Hash&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../cmp/trait.eq&quot;&gt;&lt;code&gt;Eq&lt;/code&gt;&lt;/a&gt; on the borrowed form &lt;em&gt;must&lt;/em&gt; match those for the key type.</source>
          <target state="translated">Ключ может быть любой заимствованной формой типа ключа карты, но &lt;a href=&quot;../hash/trait.hash&quot;&gt; &lt;code&gt;Hash&lt;/code&gt; &lt;/a&gt; и &lt;a href=&quot;../cmp/trait.eq&quot;&gt; &lt;code&gt;Eq&lt;/code&gt; &lt;/a&gt; в заимствованной форме &lt;em&gt;должны&lt;/em&gt; совпадать с таковыми для типа ключа.</target>
        </trans-unit>
        <trans-unit id="25f3fabcbbf37a65231d46a27fb9b7a82a76e913" translate="yes" xml:space="preserve">
          <source>The key may be any borrowed form of the map's key type, but the ordering on the borrowed form &lt;em&gt;must&lt;/em&gt; match the ordering on the key type.</source>
          <target state="translated">Ключ может быть любой заимствованной формой типа ключа карты, но порядок в заимствованной форме &lt;em&gt;должен&lt;/em&gt; соответствовать порядку в типе ключа.</target>
        </trans-unit>
        <trans-unit id="5794a7e2452d7c2d7acdcd9ca75f9f681dde7e71" translate="yes" xml:space="preserve">
          <source>The key property of unions is that all fields of a union share common storage. As a result writes to one field of a union can overwrite its other fields, and size of a union is determined by the size of its largest field.</source>
          <target state="translated">Ключевым свойством профсоюзов является то,что все сферы деятельности профсоюза имеют общее хранилище.В результате записи в одно поле профсоюза можно перезаписать другие его поля,а размер профсоюза определяется размером его самого большого поля.</target>
        </trans-unit>
        <trans-unit id="af36c49ed669c54fb87fd9d4d2b45f5df4d5de97" translate="yes" xml:space="preserve">
          <source>The key property of unions is that all fields of a union share common storage. As a result, writes to one field of a union can overwrite its other fields, and size of a union is determined by the size of its largest field.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="730d38429c1bd8714c2ac7995eb67557271f3b30" translate="yes" xml:space="preserve">
          <source>The keyword &lt;code&gt;pub&lt;/code&gt; makes any module, function, or data structure accessible from inside of external modules. The &lt;code&gt;pub&lt;/code&gt; keyword may also be used in a &lt;code&gt;use&lt;/code&gt; declaration to re-export an identifier from a namespace.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6097954d2b4ff2c7af7f3ee3f3f7074587267681" translate="yes" xml:space="preserve">
          <source>The kinds of patterns for parameters is limited to one of the following:</source>
          <target state="translated">Виды шаблонов для параметров ограничены одним из следующих:</target>
        </trans-unit>
        <trans-unit id="9150d911250adb9488a9891d8d1a7dd89c179545" translate="yes" xml:space="preserve">
          <source>The lack of infinite output indicates that this code didn&amp;rsquo;t create a reference cycle. We can also tell this by looking at the values we get from calling &lt;code&gt;Rc::strong_count&lt;/code&gt; and &lt;code&gt;Rc::weak_count&lt;/code&gt;.</source>
          <target state="translated">Отсутствие бесконечного вывода указывает на то, что этот код не создавал ссылочный цикл. Мы также можем сказать это, посмотрев на значения, которые мы получаем от вызова &lt;code&gt;Rc::strong_count&lt;/code&gt; и &lt;code&gt;Rc::weak_count&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4f0cd1d95a878dd3fb3eb033669531c63a686db3" translate="yes" xml:space="preserve">
          <source>The lang attribute is intended for marking special items that are built-in to Rust itself. This includes special traits (like &lt;code&gt;Copy&lt;/code&gt; and &lt;code&gt;Sized&lt;/code&gt;) that affect how the compiler behaves, as well as special functions that may be automatically invoked (such as the handler for out-of-bounds accesses when indexing a slice).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="60e53524d7493db6ac00628d4141587167732e22" translate="yes" xml:space="preserve">
          <source>The lang attribute is intended for marking special items that are built-in to Rust itself. This includes special traits (like &lt;code&gt;Copy&lt;/code&gt; and &lt;code&gt;Sized&lt;/code&gt;) that affect how the compiler behaves, as well as special functions that may be automatically invoked (such as the handler for out-of-bounds accesses when indexing a slice). Erroneous code example:</source>
          <target state="translated">Атрибут lang предназначен для обозначения специальных элементов, встроенных в сам Rust. Это включает в себя специальные свойства (например, &lt;code&gt;Copy&lt;/code&gt; и &lt;code&gt;Sized&lt;/code&gt; ), которые влияют на поведение компилятора, а также специальные функции, которые могут быть автоматически вызваны (например, обработчик для доступа за пределы при индексировании среза). Пример ошибочного кода:</target>
        </trans-unit>
        <trans-unit id="080a1610af4bccfcd8725cb110cddf449fbd60f7" translate="yes" xml:space="preserve">
          <source>The lang attribute was used in an invalid context.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d001aa0e948f210ef67db3ed9f1079f66965d658" translate="yes" xml:space="preserve">
          <source>The largest value that can be represented by this integer type.</source>
          <target state="translated">Наибольшее значение,которое может быть представлено этим целочисленным типом.</target>
        </trans-unit>
        <trans-unit id="55a17e21fb4394b20facf75f686648a8590b11f1" translate="yes" xml:space="preserve">
          <source>The largest value that can be represented by this integer type. Use &lt;a href=&quot;../primitive.i128#associatedconstant.MAX&quot;&gt;&lt;code&gt;i128::MAX&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b73325de7bc5986e41ec8d92ed9701ddacd280f3" translate="yes" xml:space="preserve">
          <source>The largest value that can be represented by this integer type. Use &lt;a href=&quot;../primitive.i16#associatedconstant.MAX&quot;&gt;&lt;code&gt;i16::MAX&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f7bb87b47e7f2c22de123ec199f4be989c0dcaf2" translate="yes" xml:space="preserve">
          <source>The largest value that can be represented by this integer type. Use &lt;a href=&quot;../primitive.i32#associatedconstant.MAX&quot;&gt;&lt;code&gt;i32::MAX&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cf18dde926e284162a660a1b1a2a30b118d1c49a" translate="yes" xml:space="preserve">
          <source>The largest value that can be represented by this integer type. Use &lt;a href=&quot;../primitive.i64#associatedconstant.MAX&quot;&gt;&lt;code&gt;i64::MAX&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b22c4dd542e2ceff2527d706e65d0c5acc6f4d52" translate="yes" xml:space="preserve">
          <source>The largest value that can be represented by this integer type. Use &lt;a href=&quot;../primitive.i8#associatedconstant.MAX&quot;&gt;&lt;code&gt;i8::MAX&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6a2e67766c1f950d1a3f862bddde0bc78e36aacd" translate="yes" xml:space="preserve">
          <source>The largest value that can be represented by this integer type. Use &lt;a href=&quot;../primitive.isize#associatedconstant.MAX&quot;&gt;&lt;code&gt;isize::MAX&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="697ca9e8dc5fcb1feb5a529df70222ec030c2428" translate="yes" xml:space="preserve">
          <source>The largest value that can be represented by this integer type. Use &lt;a href=&quot;../primitive.u128#associatedconstant.MAX&quot;&gt;&lt;code&gt;u128::MAX&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="23128039031afffa375e1d18e6f18c10d1470457" translate="yes" xml:space="preserve">
          <source>The largest value that can be represented by this integer type. Use &lt;a href=&quot;../primitive.u16#associatedconstant.MAX&quot;&gt;&lt;code&gt;u16::MAX&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3cead8aa8b3423346a603591b8a3bb3bb38de07d" translate="yes" xml:space="preserve">
          <source>The largest value that can be represented by this integer type. Use &lt;a href=&quot;../primitive.u32#associatedconstant.MAX&quot;&gt;&lt;code&gt;u32::MAX&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dfdca1f692589c69870c6eba29a4be248c639ebc" translate="yes" xml:space="preserve">
          <source>The largest value that can be represented by this integer type. Use &lt;a href=&quot;../primitive.u64#associatedconstant.MAX&quot;&gt;&lt;code&gt;u64::MAX&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="de1cfd44e67cca085f5a9478c1e9579b369e52ad" translate="yes" xml:space="preserve">
          <source>The largest value that can be represented by this integer type. Use &lt;a href=&quot;../primitive.u8#associatedconstant.MAX&quot;&gt;&lt;code&gt;u8::MAX&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9c52af57b6ca83f430b64beb1abd9c9176989341" translate="yes" xml:space="preserve">
          <source>The largest value that can be represented by this integer type. Use &lt;a href=&quot;../primitive.usize#associatedconstant.MAX&quot;&gt;&lt;code&gt;usize::MAX&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5bab83aeec1382113d53e6e7d14863dd49ec843d" translate="yes" xml:space="preserve">
          <source>The last change we have to make is in the assertion: to see how many items are in the inner vector, we call &lt;code&gt;borrow&lt;/code&gt; on the &lt;code&gt;RefCell&amp;lt;Vec&amp;lt;String&amp;gt;&amp;gt;&lt;/code&gt; to get an immutable reference to the vector.</source>
          <target state="translated">Последнее изменение, которое нам нужно сделать, касается утверждения: чтобы увидеть, сколько элементов находится во внутреннем векторе, мы вызываем &lt;code&gt;borrow&lt;/code&gt; для &lt;code&gt;RefCell&amp;lt;Vec&amp;lt;String&amp;gt;&amp;gt;&lt;/code&gt; чтобы получить неизменяемую ссылку на вектор.</target>
        </trans-unit>
        <trans-unit id="b92b068be4c2b594134000422ae50b8df0c8bac3" translate="yes" xml:space="preserve">
          <source>The last difference is that constants may be set only to a constant expression, not the result of a function call or any other value that could only be computed at runtime.</source>
          <target state="translated">Последнее отличие состоит в том,что константы могут быть установлены только в константное выражение,а не в результат вызова функции или любое другое значение,которое могло быть вычислено только во время выполнения.</target>
        </trans-unit>
        <trans-unit id="293474ffe041aff8a994854d8cad3ac993cf31b4" translate="yes" xml:space="preserve">
          <source>The last element returned, if any, will contain the remainder of the slice.</source>
          <target state="translated">Последний возвращаемый элемент,если он есть,будет содержать оставшийся ломтик.</target>
        </trans-unit>
        <trans-unit id="8d491eebdf550e16362be621e1476cb5ece9206f" translate="yes" xml:space="preserve">
          <source>The last field of &lt;code&gt;Foo&lt;/code&gt; has a type involving &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">Последнее поле &lt;code&gt;Foo&lt;/code&gt; имеет тип с участием &lt;code&gt;T&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="bf70627b4e81c57a3ddc9f76311bc0b01f381dcd" translate="yes" xml:space="preserve">
          <source>The last line of the output shows the location and the name of the installed binary, which in the case of &lt;code&gt;ripgrep&lt;/code&gt; is &lt;code&gt;rg&lt;/code&gt;. As long as the installation directory is in your &lt;code&gt;$PATH&lt;/code&gt;, as mentioned previously, you can then run &lt;code&gt;rg --help&lt;/code&gt; and start using a faster, rustier tool for searching files!</source>
          <target state="translated">Последняя строка выходных данных показывает расположение и имя установленного двоичного &lt;code&gt;ripgrep&lt;/code&gt; , которым в случае ripgrep является &lt;code&gt;rg&lt;/code&gt; . Пока каталог установки находится в вашем &lt;code&gt;$PATH&lt;/code&gt; , как упоминалось ранее, вы можете запустить &lt;code&gt;rg --help&lt;/code&gt; и начать использовать более быстрый и более ржавый инструмент для поиска файлов!</target>
        </trans-unit>
        <trans-unit id="3dc7b6a27a6191be06711a90615e83b643711efc" translate="yes" xml:space="preserve">
          <source>The last line shows that &lt;code&gt;&amp;amp;bar&lt;/code&gt; is not a function pointer either. Rather, it is a reference to the function-specific ZST. &lt;code&gt;&amp;amp;bar&lt;/code&gt; is basically never what you want when &lt;code&gt;bar&lt;/code&gt; is a function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="982060970609630bdcfd3dbdc543a9a98b2de24a" translate="yes" xml:space="preserve">
          <source>The last line, &lt;code&gt;[dependencies]&lt;/code&gt;, is the start of a section for you to list any of your project&amp;rsquo;s dependencies. In Rust, packages of code are referred to as &lt;em&gt;crates&lt;/em&gt;. We won&amp;rsquo;t need any other crates for this project, but we will in the first project in Chapter 2, so we&amp;rsquo;ll use this dependencies section then.</source>
          <target state="translated">Последняя строка &lt;code&gt;[dependencies]&lt;/code&gt; - это начало раздела, в котором вы можете перечислить любые зависимости вашего проекта. В Rust пакеты кода называются &lt;em&gt;ящиками&lt;/em&gt; . Нам не понадобятся другие крейты для этого проекта, но мы будем использовать их в первом проекте в главе 2, поэтому мы будем использовать этот раздел зависимостей.</target>
        </trans-unit>
        <trans-unit id="c8d286da9b3987ef73f4d9e79523c9888a168257" translate="yes" xml:space="preserve">
          <source>The last of our common collections is the &lt;em&gt;hash map&lt;/em&gt;. The type &lt;code&gt;HashMap&amp;lt;K, V&amp;gt;&lt;/code&gt; stores a mapping of keys of type &lt;code&gt;K&lt;/code&gt; to values of type &lt;code&gt;V&lt;/code&gt;. It does this via a &lt;em&gt;hashing function&lt;/em&gt;, which determines how it places these keys and values into memory. Many programming languages support this kind of data structure, but they often use a different name, such as hash, map, object, hash table, dictionary, or associative array, just to name a few.</source>
          <target state="translated">Последняя из наших общих коллекций - это &lt;em&gt;хеш-карта&lt;/em&gt; . Типа &lt;code&gt;HashMap&amp;lt;K, V&amp;gt;&lt;/code&gt; хранит отображение ключей типа &lt;code&gt;K&lt;/code&gt; для значений типа &lt;code&gt;V&lt;/code&gt; . Он делает это с помощью &lt;em&gt;функции хеширования&lt;/em&gt; , которая определяет, как он помещает эти ключи и значения в память. Многие языки программирования поддерживают этот тип структуры данных, но они часто используют другое имя, такое как хэш, карта, объект, хеш-таблица, словарь или ассоциативный массив, и это лишь некоторые из них.</target>
        </trans-unit>
        <trans-unit id="e50377e1cc3271006121b6b6e503348b95075085" translate="yes" xml:space="preserve">
          <source>The last part is the HTTP version the client uses, and then the request line ends in a &lt;em&gt;CRLF sequence&lt;/em&gt;. (CRLF stands for &lt;em&gt;carriage return&lt;/em&gt; and &lt;em&gt;line feed&lt;/em&gt;, which are terms from the typewriter days!) The CRLF sequence can also be written as &lt;code&gt;\r\n&lt;/code&gt;, where &lt;code&gt;\r&lt;/code&gt; is a carriage return and &lt;code&gt;\n&lt;/code&gt; is a line feed. The CRLF sequence separates the request line from the rest of the request data. Note that when the CRLF is printed, we see a new line start rather than &lt;code&gt;\r\n&lt;/code&gt;.</source>
          <target state="translated">Последняя часть - это версия HTTP, которую использует клиент, а затем строка запроса заканчивается &lt;em&gt;последовательностью CRLF&lt;/em&gt; . (CRLF означает &lt;em&gt;возврат каретки&lt;/em&gt; и &lt;em&gt;перевод строки&lt;/em&gt; , что является термином из дней пишущих машинок!) Последовательность CRLF также может быть записана как &lt;code&gt;\r\n&lt;/code&gt; , где &lt;code&gt;\r&lt;/code&gt; - возврат каретки, а &lt;code&gt;\n&lt;/code&gt; - перевод строки. Последовательность CRLF отделяет строку запроса от остальных данных запроса. Обратите внимание, что при печати CRLF мы видим начало новой строки, а не &lt;code&gt;\r\n&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e7f87628bb5e91d33e6ee47cc631179039d310fa" translate="yes" xml:space="preserve">
          <source>The layout of a type is its size, alignment, and the relative offsets of its fields. For enums, how the discriminant is laid out and interpreted is also part of type layout.</source>
          <target state="translated">Макет типа-это его размер,выравнивание и относительные смещения его полей.Для перечислений то,как разложен и интерпретирован дискриминант,также является частью раскладки типа.</target>
        </trans-unit>
        <trans-unit id="bb7242c48b73507f4d4792c2cb29fe84ab3a4519" translate="yes" xml:space="preserve">
          <source>The layout of allocation request that failed</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d81ce81ead59e71cfd072129a8c87907148c562c" translate="yes" xml:space="preserve">
          <source>The left operand of an &lt;a href=&quot;expressions/operator-expr#assignment-expressions&quot;&gt;assignment&lt;/a&gt; or &lt;a href=&quot;expressions/operator-expr#compound-assignment-expressions&quot;&gt;compound assignment&lt;/a&gt; expression.</source>
          <target state="translated">Левый операнд &lt;a href=&quot;expressions/operator-expr#assignment-expressions&quot;&gt;присваивания&lt;/a&gt; или &lt;a href=&quot;expressions/operator-expr#compound-assignment-expressions&quot;&gt;составного&lt;/a&gt; выражения присваивания .</target>
        </trans-unit>
        <trans-unit id="1c0d113ddd28e543817cdc902e3988c72a15e13a" translate="yes" xml:space="preserve">
          <source>The left shift assignment operator &lt;code&gt;&amp;lt;&amp;lt;=&lt;/code&gt;.</source>
          <target state="translated">Оператор присваивания сдвига влево &lt;code&gt;&amp;lt;&amp;lt;=&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="553d8d3f55b49cb8907e0699dd0a3d9c13298c80" translate="yes" xml:space="preserve">
          <source>The left shift operator &lt;code&gt;&amp;lt;&amp;lt;&lt;/code&gt;. Note that because this trait is implemented for all integer types with multiple right-hand-side types, Rust's type checker has special handling for &lt;code&gt;_ &amp;lt;&amp;lt; _&lt;/code&gt;, setting the result type for integer operations to the type of the left-hand-side operand. This means that though &lt;code&gt;a &amp;lt;&amp;lt; b&lt;/code&gt; and &lt;code&gt;a.shl(b)&lt;/code&gt; are one and the same from an evaluation standpoint, they are different when it comes to type inference.</source>
          <target state="translated">Оператор сдвига влево &lt;code&gt;&amp;lt;&amp;lt;&lt;/code&gt; . Обратите внимание, что, поскольку эта черта реализована для всех целочисленных типов с несколькими типами с правой стороны, средство проверки типов в Rust имеет специальную обработку для &lt;code&gt;_ &amp;lt;&amp;lt; _&lt;/code&gt; , устанавливая тип результата для целочисленных операций на тип левого операнда. . Это означает, что хотя &lt;code&gt;a &amp;lt;&amp;lt; b&lt;/code&gt; и &lt;code&gt;a.shl(b)&lt;/code&gt; - одно и то же с точки зрения оценки, они различаются, когда дело доходит до вывода типов.</target>
        </trans-unit>
        <trans-unit id="abb83d0dbf2481e1c0cc0aff75ee4837acd9c8fb" translate="yes" xml:space="preserve">
          <source>The left-hand side of a compound assignment expression must be a place expression. A place expression represents a memory location and includes item paths (ie, namespaced variables), dereferences, indexing expressions, and field references.</source>
          <target state="translated">Левая сторона составного выражения задания должна быть выражением места.Выражение &quot;место&quot; представляет собой ячейку памяти и включает в себя пути к элементам (т.е.переменные в пространстве имён),разыменования,индексирующие выражения и ссылки на поля.</target>
        </trans-unit>
        <trans-unit id="9df6999a3c0f46759818b5fb8abefef29f79e559" translate="yes" xml:space="preserve">
          <source>The left-hand side of an assignment operator must be a place expression. A place expression represents a memory location and can be a variable (with optional namespacing), a dereference, an indexing expression or a field reference.</source>
          <target state="translated">Левая сторона оператора присваивания должна быть пространственным выражением.Местное выражение представляет собой ячейку памяти и может быть переменной (с необязательным интервалом имён),разыменованием,индексным выражением или ссылкой на поле.</target>
        </trans-unit>
        <trans-unit id="e2c37a7f1d5752be8f4a3cd4c10444c370f709c8" translate="yes" xml:space="preserve">
          <source>The length is how much memory, in bytes, the contents of the &lt;code&gt;String&lt;/code&gt; is currently using. The capacity is the total amount of memory, in bytes, that the &lt;code&gt;String&lt;/code&gt; has received from the allocator. The difference between length and capacity matters, but not in this context, so for now, it&amp;rsquo;s fine to ignore the capacity.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="583ea3cae577825fe984e0b2dabdc2098e762a9c" translate="yes" xml:space="preserve">
          <source>The length is how much memory, in bytes, the contents of the &lt;code&gt;String&lt;/code&gt; is currently using. The capacity is the total amount of memory, in bytes, that the &lt;code&gt;String&lt;/code&gt; has received from the operating system. The difference between length and capacity matters, but not in this context, so for now, it&amp;rsquo;s fine to ignore the capacity.</source>
          <target state="translated">Длина - это объем памяти в байтах, который в настоящее время используется содержимым &lt;code&gt;String&lt;/code&gt; . Емкость - это общий объем памяти в байтах, который &lt;code&gt;String&lt;/code&gt; получила от операционной системы. Разница между длиной и емкостью имеет значение, но не в этом контексте, поэтому на данный момент можно игнорировать емкость.</target>
        </trans-unit>
        <trans-unit id="bec01c75ecf9080484e0035ecb4817690e9d17fa" translate="yes" xml:space="preserve">
          <source>The length of &lt;code&gt;other&lt;/code&gt; must be the same as &lt;code&gt;self&lt;/code&gt;.</source>
          <target state="translated">Длина &lt;code&gt;other&lt;/code&gt; должна быть такой же, как у &lt;code&gt;self&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1d3c6c04d874a34e3f73cf44da542c5ee7d39510" translate="yes" xml:space="preserve">
          <source>The length of &lt;code&gt;src&lt;/code&gt; must be the same as &lt;code&gt;self&lt;/code&gt;.</source>
          <target state="translated">Длина &lt;code&gt;src&lt;/code&gt; должна быть такой же, как у &lt;code&gt;self&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f5ae40e336b72c0149684750f73301547acc7603" translate="yes" xml:space="preserve">
          <source>The length of the platform-intrinsic function &lt;code&gt;simd_shuffle&lt;/code&gt; wasn't specified.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="65b0bfaafe677ff19be99641d06a9d0388b357ef" translate="yes" xml:space="preserve">
          <source>The length of the platform-intrinsic function &lt;code&gt;simd_shuffle&lt;/code&gt; wasn't specified. Erroneous code example:</source>
          <target state="translated">Длина встроенной в платформу функции &lt;code&gt;simd_shuffle&lt;/code&gt; не указана. Пример ошибочного кода:</target>
        </trans-unit>
        <trans-unit id="2e4dc711d20d353ed60fc2eb7d0105870f230a29" translate="yes" xml:space="preserve">
          <source>The length returned is that of the underlying storage used by &lt;code&gt;OsStr&lt;/code&gt;. As discussed in the &lt;a href=&quot;struct.osstring&quot;&gt;&lt;code&gt;OsString&lt;/code&gt;&lt;/a&gt; introduction, &lt;a href=&quot;struct.osstring&quot;&gt;&lt;code&gt;OsString&lt;/code&gt;&lt;/a&gt; and &lt;code&gt;OsStr&lt;/code&gt; store strings in a form best suited for cheap inter-conversion between native-platform and Rust string forms, which may differ significantly from both of them, including in storage size and encoding.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2fe8cad4da628228b8d9a6730b144662e5d5b147" translate="yes" xml:space="preserve">
          <source>The length returned is that of the underlying storage used by &lt;code&gt;OsStr&lt;/code&gt;; As discussed in the &lt;a href=&quot;struct.osstring&quot;&gt;&lt;code&gt;OsString&lt;/code&gt;&lt;/a&gt; introduction, &lt;a href=&quot;struct.osstring&quot;&gt;&lt;code&gt;OsString&lt;/code&gt;&lt;/a&gt; and &lt;code&gt;OsStr&lt;/code&gt; store strings in a form best suited for cheap inter-conversion between native-platform and Rust string forms, which may differ significantly from both of them, including in storage size and encoding.</source>
          <target state="translated">Возвращаемая длина - это длина базового хранилища, используемого &lt;code&gt;OsStr&lt;/code&gt; ; Как обсуждалось во введении к &lt;a href=&quot;struct.osstring&quot;&gt; &lt;code&gt;OsString&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;struct.osstring&quot;&gt; &lt;code&gt;OsString&lt;/code&gt; &lt;/a&gt; и &lt;code&gt;OsStr&lt;/code&gt; хранят строки в форме, которая лучше всего подходит для дешевого взаимного преобразования между строковыми формами нативной платформы и Rust, которые могут значительно отличаться от них обоих, в том числе по размеру хранилища и кодировке.</target>
        </trans-unit>
        <trans-unit id="f60b6a38bf38c34c5675869a8bbe49e47496b10f" translate="yes" xml:space="preserve">
          <source>The level is equal to &lt;code&gt;SOL_SOCKET&lt;/code&gt; and the type is equal to &lt;code&gt;SCM_CREDENTIALS&lt;/code&gt; or &lt;code&gt;SCM_CREDS&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3be4076f729c77100ef1624a826253f7fce0e4b7" translate="yes" xml:space="preserve">
          <source>The level is equal to &lt;code&gt;SOL_SOCKET&lt;/code&gt; and the type is equal to &lt;code&gt;SCM_RIGHTS&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="99a0d51daa7130da604f883d5259ae5835cb10c2" translate="yes" xml:space="preserve">
          <source>The lifetime bound for this object type cannot be deduced from context and must be specified.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="71866b1db7de253967c22f08d6dc545dfcd4182b" translate="yes" xml:space="preserve">
          <source>The lifetime constraint &lt;code&gt;'b&lt;/code&gt; for &lt;code&gt;bar()&lt;/code&gt; implementation does not match the trait declaration. Ensure lifetime declarations match exactly in both trait declaration and implementation. Example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="30238ceba60deefc79cfa25b4649d1a595edd0d8" translate="yes" xml:space="preserve">
          <source>The lifetime constraint &lt;code&gt;'b&lt;/code&gt; for bar() implementation does not match the trait declaration. Ensure lifetime declarations match exactly in both trait declaration and implementation. Example:</source>
          <target state="translated">Ограничение времени жизни &lt;code&gt;'b&lt;/code&gt; для реализации bar () не соответствует объявлению признака. Убедитесь, что объявления времени жизни точно совпадают как в объявлении черты, так и в реализации. Пример:</target>
        </trans-unit>
        <trans-unit id="61076c57b01b556a6cbf075ae8202a67124b97eb" translate="yes" xml:space="preserve">
          <source>The lifetime elision rules require that any function signature with an elided output lifetime must either have</source>
          <target state="translated">Правила элиминации времени жизни требуют,чтобы любая сигнатура функции с элиминированным временем жизни на выходе должна иметь либо</target>
        </trans-unit>
        <trans-unit id="15fb2549a777717fb62ea70833166d18eb32b15d" translate="yes" xml:space="preserve">
          <source>The lifetime elision rules require that any function signature with an elided output lifetime must either have:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7914129f994f43353c3efa7974019d9a960355fb" translate="yes" xml:space="preserve">
          <source>The lifetime for the returned slice is inferred from its usage. To prevent accidental misuse, it's suggested to tie the lifetime to whichever source lifetime is safe in the context, such as by providing a helper function taking the lifetime of a host value for the slice, or by explicit annotation.</source>
          <target state="translated">Срок службы возвращаемого ломтика определяется исходя из его использования.Чтобы предотвратить случайное использование,предлагается привязать время жизни к тому,какое время жизни источника безопасно в контексте,например,путем предоставления функции помощника,принимающей время жизни хоста для ломтика,или путем явной аннотации.</target>
        </trans-unit>
        <trans-unit id="af0f1e1de97ff5087fa423eab95c1e381b7b3ee8" translate="yes" xml:space="preserve">
          <source>The lifetime of the returned &lt;code&gt;Cursor&lt;/code&gt; is bound to that of the &lt;code&gt;CursorMut&lt;/code&gt;, which means it cannot outlive the &lt;code&gt;CursorMut&lt;/code&gt; and that the &lt;code&gt;CursorMut&lt;/code&gt; is frozen for the lifetime of the &lt;code&gt;Cursor&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="57046a8e7fbf89990ae303fb2235f525d1c99061" translate="yes" xml:space="preserve">
          <source>The lifetime parameter declaration after &lt;code&gt;impl&lt;/code&gt; and its use after the type name are required, but we&amp;rsquo;re not required to annotate the lifetime of the reference to &lt;code&gt;self&lt;/code&gt; because of the first elision rule.</source>
          <target state="translated">Объявление параметра времени жизни после &lt;code&gt;impl&lt;/code&gt; и его использование после имени типа обязательны, но мы не обязаны аннотировать время жизни ссылки на &lt;code&gt;self&lt;/code&gt; из-за первого правила исключения.</target>
        </trans-unit>
        <trans-unit id="37f7629efc4022ff5cf0b561478f77607b602987" translate="yes" xml:space="preserve">
          <source>The lifetime parameters of the method do not match the trait declaration.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="14f07422d02861a626046c58ce643a2a52da0ac8" translate="yes" xml:space="preserve">
          <source>The line &lt;code&gt;index out of bounds: the len is 1 but the index is 1&lt;/code&gt; is an error message intended for programmers. It won&amp;rsquo;t help our end users understand what happened and what they should do instead. Let&amp;rsquo;s fix that now.</source>
          <target state="translated">Линия &lt;code&gt;index out of bounds: the len is 1 but the index is 1&lt;/code&gt; представляет собой сообщение об ошибке , предназначенном для программистов. Это не поможет нашим конечным пользователям понять, что произошло и что им следует делать вместо этого. Давайте исправим это сейчас.</target>
        </trans-unit>
        <trans-unit id="5a0147b8f24f32bab15f7fb8959607d1c4391ac2" translate="yes" xml:space="preserve">
          <source>The line is:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="de1c3b88f137cbbbccea4f427174e92d6650dd55" translate="yes" xml:space="preserve">
          <source>The lines execute in the order in which they appear in the &lt;code&gt;main&lt;/code&gt; function. First, the &amp;ldquo;Hello, world!&amp;rdquo; message prints, and then &lt;code&gt;another_function&lt;/code&gt; is called and its message is printed.</source>
          <target state="translated">Строки выполняются в том порядке, в котором они появляются в &lt;code&gt;main&lt;/code&gt; функции. Во-первых, &amp;laquo;Привет, мир!&amp;raquo; сообщение распечатывается, затем вызывается &lt;code&gt;another_function&lt;/code&gt; и печатается его сообщение.</target>
        </trans-unit>
        <trans-unit id="a2f50a40f788fe52620261459fe43b43f06256a8" translate="yes" xml:space="preserve">
          <source>The linkage of the C runtime is configured to respect the &lt;code&gt;crt-static&lt;/code&gt; target feature. These target features are typically configured from the command line via flags to the compiler itself. For example to enable a static runtime you would execute:</source>
          <target state="translated">Связывание среды выполнения C настроено с учетом целевой функции &lt;code&gt;crt-static&lt;/code&gt; . Эти целевые функции обычно настраиваются из командной строки с помощью флагов самого компилятора. Например, чтобы включить статическую среду выполнения, вы должны выполнить:</target>
        </trans-unit>
        <trans-unit id="efca89d0995e1ff0c39cef27089410685b77deb1" translate="yes" xml:space="preserve">
          <source>The list of derivable traits provided in this appendix is not comprehensive: libraries can implement &lt;code&gt;derive&lt;/code&gt; for their own traits, making the list of traits you can use &lt;code&gt;derive&lt;/code&gt; with truly open-ended. Implementing &lt;code&gt;derive&lt;/code&gt; involves using a procedural macro, which is covered in the &lt;a href=&quot;ch19-06-macros#macros&quot;&gt;&amp;ldquo;Macros&amp;rdquo;&lt;/a&gt; section of Chapter 19.</source>
          <target state="translated">Список производных признаков, представленный в этом приложении, не является исчерпывающим: библиотеки могут реализовывать &lt;code&gt;derive&lt;/code&gt; для своих собственных признаков, делая список признаков, которые вы можете использовать, &lt;code&gt;derive&lt;/code&gt; настоящему открытыми. Реализация &lt;code&gt;derive&lt;/code&gt; включает использование процедурного макроса, который рассматривается в разделе &lt;a href=&quot;ch19-06-macros#macros&quot;&gt;&amp;laquo;Макросы&amp;raquo;&lt;/a&gt; главы 19.</target>
        </trans-unit>
        <trans-unit id="e9a2965c85bdbd082d28a62c5ab1cef15f730b46" translate="yes" xml:space="preserve">
          <source>The list of types is:</source>
          <target state="translated">Список типов:</target>
        </trans-unit>
        <trans-unit id="91f214c30e2ceb29652b72be6f5c77765c1026b7" translate="yes" xml:space="preserve">
          <source>The literal characters &lt;code&gt;{&lt;/code&gt; and &lt;code&gt;}&lt;/code&gt; may be included in a string by preceding them with the same character. For example, the &lt;code&gt;{&lt;/code&gt; character is escaped with &lt;code&gt;{{&lt;/code&gt; and the &lt;code&gt;}&lt;/code&gt; character is escaped with &lt;code&gt;}}&lt;/code&gt;.</source>
          <target state="translated">Литеральные символы &lt;code&gt;{&lt;/code&gt; и &lt;code&gt;}&lt;/code&gt; могут быть включены в строку, поставив перед ними один и тот же символ. Например, символ &lt;code&gt;{&lt;/code&gt; экранируется с помощью &lt;code&gt;{{&lt;/code&gt; , а символ &lt;code&gt;}&lt;/code&gt; экранируется с помощью &lt;code&gt;}}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d5be7b0512e1a505e9266eb524c4b5165ed24536" translate="yes" xml:space="preserve">
          <source>The lock could not be acquired at this time because the operation would otherwise block.</source>
          <target state="translated">В данный момент замок не может быть приобретен,так как в противном случае операция будет заблокирована.</target>
        </trans-unit>
        <trans-unit id="ca27685a95f0186521159c6d95fa9cb158ac3333" translate="yes" xml:space="preserve">
          <source>The lock could not be acquired because another thread failed while holding the lock.</source>
          <target state="translated">Замок не мог быть приобретен,потому что другая резьба отказала во время удержания замка.</target>
        </trans-unit>
        <trans-unit id="e835ab2030797bd0af68c5e546090096d0ef15ed" translate="yes" xml:space="preserve">
          <source>The lock is released when the returned lock goes out of scope. The returned guard also implements the &lt;a href=&quot;trait.read&quot;&gt;&lt;code&gt;Read&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;trait.bufread&quot;&gt;&lt;code&gt;BufRead&lt;/code&gt;&lt;/a&gt; traits for accessing the underlying data.</source>
          <target state="translated">Блокировка снимается, когда возвращенная блокировка выходит за пределы области действия. &lt;a href=&quot;trait.bufread&quot;&gt; &lt;code&gt;BufRead&lt;/code&gt; &lt;/a&gt; сторож также реализует трейты &lt;a href=&quot;trait.read&quot;&gt; &lt;code&gt;Read&lt;/code&gt; &lt;/a&gt; и BufRead для доступа к базовым данным.</target>
        </trans-unit>
        <trans-unit id="ca99507e16c078ed3bf090ad447532972842294c" translate="yes" xml:space="preserve">
          <source>The lock is released when the returned lock goes out of scope. The returned guard also implements the &lt;a href=&quot;trait.write&quot;&gt;&lt;code&gt;Write&lt;/code&gt;&lt;/a&gt; trait for writing data.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="95f3d5bdf30a84c247ddb912c9e27503ec850ddb" translate="yes" xml:space="preserve">
          <source>The lock is released when the returned lock goes out of scope. The returned guard also implements the &lt;code&gt;Write&lt;/code&gt; trait for writing data.</source>
          <target state="translated">Блокировка снимается, когда возвращенная блокировка выходит за пределы области действия. Возвращенный сторож также реализует трейт &lt;code&gt;Write&lt;/code&gt; для записи данных.</target>
        </trans-unit>
        <trans-unit id="9fbc8134425c3ce849c012cee6ed6bdb948d21a6" translate="yes" xml:space="preserve">
          <source>The logic around the &lt;code&gt;value&lt;/code&gt; field we&amp;rsquo;ve just described is defined in Listing 13-10.</source>
          <target state="translated">Логика только что описанного поля &lt;code&gt;value&lt;/code&gt; определена в листинге 13-10.</target>
        </trans-unit>
        <trans-unit id="f2cf3737106dde9e749616b8670f272a444680a9" translate="yes" xml:space="preserve">
          <source>The lower bound of the range (inclusive).</source>
          <target state="translated">Нижняя граница диапазона (включительно).</target>
        </trans-unit>
        <trans-unit id="0766d14228f909fbfdac3f3dca197e2a666359ec" translate="yes" xml:space="preserve">
          <source>The lower-level cause of this error, if any.</source>
          <target state="translated">Причина этой ошибки нижнего уровня,если таковая имеется.</target>
        </trans-unit>
        <trans-unit id="4b8803f6ab5b8d7b772e6a580f89ee4b72aef2f4" translate="yes" xml:space="preserve">
          <source>The lower-level cause of this error, if any. &lt;a href=&quot;../../error/trait.error#method.cause&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">Причина этой ошибки нижнего уровня, если таковая имеется. &lt;a href=&quot;../../error/trait.error#method.cause&quot;&gt;Читать далее&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="5980cf0091c024091baef1d2b8180b13d7e8fb92" translate="yes" xml:space="preserve">
          <source>The lower-level cause of this error, if any. &lt;a href=&quot;../error/trait.error#method.cause&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">Причина этой ошибки нижнего уровня, если таковая имеется. &lt;a href=&quot;../error/trait.error#method.cause&quot;&gt;Читать далее&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="f757a43bf56678673d64a896a7ea59d83e9d1668" translate="yes" xml:space="preserve">
          <source>The lower-level cause of this error, if any. &lt;a href=&quot;error/trait.error#method.cause&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">Причина этой ошибки нижнего уровня, если таковая имеется. &lt;a href=&quot;error/trait.error#method.cause&quot;&gt;Читать далее&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="828185ce8f6bedf0299995b3c4e9cb20b7a41ecd" translate="yes" xml:space="preserve">
          <source>The lower-level source of this error, if any.</source>
          <target state="translated">Низкоуровневый источник этой ошибки,если таковой имеется.</target>
        </trans-unit>
        <trans-unit id="ea0a6930dc7de4d466ce55f6448d31ae162ca38c" translate="yes" xml:space="preserve">
          <source>The lower-level source of this error, if any. &lt;a href=&quot;../../error/trait.error#method.source&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">Источник этой ошибки нижнего уровня, если таковой имеется. &lt;a href=&quot;../../error/trait.error#method.source&quot;&gt;Читать далее&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="fb0a1822fe706b0e16bb4cab78928338d81339e3" translate="yes" xml:space="preserve">
          <source>The lower-level source of this error, if any. &lt;a href=&quot;../error/trait.error#method.source&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">Источник этой ошибки нижнего уровня, если таковой имеется. &lt;a href=&quot;../error/trait.error#method.source&quot;&gt;Читать далее&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="bccd557ca491cf82db4f740ce89716ec64f4fabf" translate="yes" xml:space="preserve">
          <source>The lower-level source of this error, if any. &lt;a href=&quot;error/trait.error#method.source&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">Источник этой ошибки нижнего уровня, если таковой имеется. &lt;a href=&quot;error/trait.error#method.source&quot;&gt;Читать далее&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="f6b9226fd8ae01998a5ebc10002aa19b3691743f" translate="yes" xml:space="preserve">
          <source>The machine code for &lt;code&gt;foo::&amp;lt;u8&amp;gt;()&lt;/code&gt;, &lt;code&gt;foo::&amp;lt;bool&amp;gt;()&lt;/code&gt;, &lt;code&gt;foo::&amp;lt;String&amp;gt;()&lt;/code&gt;, or any other type substitution is different. Hence the compiler generates the implementation on-demand. If you call &lt;code&gt;foo()&lt;/code&gt; with a &lt;code&gt;bool&lt;/code&gt; parameter, the compiler will only generate code for &lt;code&gt;foo::&amp;lt;bool&amp;gt;()&lt;/code&gt;. When we have additional type parameters, the number of monomorphized implementations the compiler generates does not grow drastically, since the compiler will only generate an implementation if the function is called with unparametrized substitutions (i.e., substitutions where none of the substituted types are themselves parameterized).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9e0846c263b7366386582dfe4d412a3ad4ba7b9f" translate="yes" xml:space="preserve">
          <source>The machine code for &lt;code&gt;foo::&amp;lt;u8&amp;gt;()&lt;/code&gt;, &lt;code&gt;foo::&amp;lt;bool&amp;gt;()&lt;/code&gt;, &lt;code&gt;foo::&amp;lt;String&amp;gt;()&lt;/code&gt;, or any other type substitution is different. Hence the compiler generates the implementation on-demand. If you call &lt;code&gt;foo()&lt;/code&gt; with a &lt;code&gt;bool&lt;/code&gt; parameter, the compiler will only generate code for &lt;code&gt;foo::&amp;lt;bool&amp;gt;()&lt;/code&gt;. When we have additional type parameters, the number of monomorphized implementations the compiler generates does not grow drastically, since the compiler will only generate an implementation if the function is called with unparametrized substitutions (i.e., substitutions where none of the substituted types are themselves parametrized).</source>
          <target state="translated">Машинный код для &lt;code&gt;foo::&amp;lt;u8&amp;gt;()&lt;/code&gt; , &lt;code&gt;foo::&amp;lt;bool&amp;gt;()&lt;/code&gt; , &lt;code&gt;foo::&amp;lt;String&amp;gt;()&lt;/code&gt; или любой другой подстановки типа отличается. Следовательно, компилятор генерирует реализацию по запросу. Если вы вызываете &lt;code&gt;foo()&lt;/code&gt; с параметром &lt;code&gt;bool&lt;/code&gt; , компилятор сгенерирует только код для &lt;code&gt;foo::&amp;lt;bool&amp;gt;()&lt;/code&gt; . Когда у нас есть дополнительные параметры типа, количество мономорфных реализаций, генерируемых компилятором, не увеличивается резко, поскольку компилятор будет генерировать реализацию только в том случае, если функция вызывается с непараметризованными подстановками (т. Е. Подстановками, в которых ни один из замещаемых типов сам по себе не параметризован) .</target>
        </trans-unit>
        <trans-unit id="ec5d54a07ee0f8ac568e82f61b376d035a168bca" translate="yes" xml:space="preserve">
          <source>The macro itself will decide how to interpret such a token and whether to produce an error or not.</source>
          <target state="translated">Сам макрос решает,как интерпретировать такую лексему и выдавать ли ошибку или нет.</target>
        </trans-unit>
        <trans-unit id="8db5958c7dabf9cedcc4db6e6fa16a59d45c2565" translate="yes" xml:space="preserve">
          <source>The macro works by using the &lt;code&gt;Debug&lt;/code&gt; implementation of the type of the given expression to print the value to &lt;a href=&quot;https://en.wikipedia.org/wiki/Standard_streams#Standard_error_(stderr)&quot;&gt;stderr&lt;/a&gt; along with the source location of the macro invocation as well as the source code of the expression.</source>
          <target state="translated">Макрос работает с использованием реализации &lt;code&gt;Debug&lt;/code&gt; типа данного выражения для вывода значения в &lt;a href=&quot;https://en.wikipedia.org/wiki/Standard_streams#Standard_error_(stderr)&quot;&gt;stderr&lt;/a&gt; вместе с исходным местоположением вызова макроса, а также с исходным кодом выражения.</target>
        </trans-unit>
        <trans-unit id="9498e8eb390e83cb5dbd448b585676f4b5c37123" translate="yes" xml:space="preserve">
          <source>The macro wraps any number of static declarations and makes them thread local. Publicity and attributes for each static are allowed. Example:</source>
          <target state="translated">Макрос обертывает любое количество статических деклараций и делает их потоковыми локальными.Публичность и атрибуты для каждой статики разрешены.Пример:</target>
        </trans-unit>
        <trans-unit id="2eb59c956ec6e4722a7e8cfdea3a410b913da22e" translate="yes" xml:space="preserve">
          <source>The main aim of lifetimes is to prevent dangling references, which cause a program to reference data other than the data it&amp;rsquo;s intended to reference. Consider the program in Listing 10-17, which has an outer scope and an inner scope.</source>
          <target state="translated">Основная цель времени жизни - предотвратить висячие ссылки, которые заставляют программу ссылаться на данные, отличные от данных, на которые она предназначена. Рассмотрим программу в Листинге 10-17, у которой есть внешняя и внутренняя области видимости.</target>
        </trans-unit>
        <trans-unit id="c087688652f35bf8ea7f8323996c74d4edfcf197" translate="yes" xml:space="preserve">
          <source>The main benefit of using methods instead of functions, in addition to using method syntax and not having to repeat the type of &lt;code&gt;self&lt;/code&gt; in every method&amp;rsquo;s signature, is for organization. We&amp;rsquo;ve put all the things we can do with an instance of a type in one &lt;code&gt;impl&lt;/code&gt; block rather than making future users of our code search for capabilities of &lt;code&gt;Rectangle&lt;/code&gt; in various places in the library we provide.</source>
          <target state="translated">Основное преимущество использования методов вместо функций, помимо использования синтаксиса метода и отсутствия необходимости повторять тип &lt;code&gt;self&lt;/code&gt; в каждой сигнатуре метода, касается организации. Мы поместили все, что мы можем делать с экземпляром типа в один блок &lt;code&gt;impl&lt;/code&gt; , вместо того, чтобы заставлять будущих пользователей нашего кода искать возможности &lt;code&gt;Rectangle&lt;/code&gt; в различных местах в предоставляемой нами библиотеке.</target>
        </trans-unit>
        <trans-unit id="8008407990a4be341211e8be036085a004b45e43" translate="yes" xml:space="preserve">
          <source>The main error message, &amp;ldquo;mismatched types,&amp;rdquo; reveals the core issue with this code. The definition of the function &lt;code&gt;plus_one&lt;/code&gt; says that it will return an &lt;code&gt;i32&lt;/code&gt;, but statements don&amp;rsquo;t evaluate to a value, which is expressed by &lt;code&gt;()&lt;/code&gt;, an empty tuple. Therefore, nothing is returned, which contradicts the function definition and results in an error. In this output, Rust provides a message to possibly help rectify this issue: it suggests removing the semicolon, which would fix the error.</source>
          <target state="translated">Основное сообщение об ошибке &amp;laquo;несовпадающие типы&amp;raquo; раскрывает основную проблему этого кода. В определении функции &lt;code&gt;plus_one&lt;/code&gt; говорится, что она вернет &lt;code&gt;i32&lt;/code&gt; , но операторы не оценивают значение, которое выражается &lt;code&gt;()&lt;/code&gt; , пустым кортежем. Следовательно, ничего не возвращается, что противоречит определению функции и приводит к ошибке. В этом выводе Rust предоставляет сообщение, которое, возможно, поможет исправить эту проблему: он предлагает удалить точку с запятой, что исправит ошибку.</target>
        </trans-unit>
        <trans-unit id="573ea76510aaa810e82bed4691dcc0e4c2771be9" translate="yes" xml:space="preserve">
          <source>The main place you'll see &lt;code&gt;!&lt;/code&gt; used explicitly is in generic code. Consider the &lt;a href=&quot;str/trait.fromstr&quot;&gt;&lt;code&gt;FromStr&lt;/code&gt;&lt;/a&gt; trait:</source>
          <target state="translated">Главное место, которое ты увидишь &lt;code&gt;!&lt;/code&gt; явно используется в универсальном коде. Рассмотрим &lt;a href=&quot;str/trait.fromstr&quot;&gt; &lt;code&gt;FromStr&lt;/code&gt; &lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="3347fce894ee36b7a76776d17f6b05d7ee4e0c6f" translate="yes" xml:space="preserve">
          <source>The main thread will wait for the spawned thread to finish and then run its &lt;code&gt;for&lt;/code&gt; loop, so the output won&amp;rsquo;t be interleaved anymore, as shown here:</source>
          <target state="translated">Основной поток будет ждать завершения порожденного потока, а затем запускает его цикл &lt;code&gt;for&lt;/code&gt; , поэтому вывод больше не будет чередоваться, как показано здесь:</target>
        </trans-unit>
        <trans-unit id="d7af4b9befadab1a133dab8d7948b44dbc8d708d" translate="yes" xml:space="preserve">
          <source>The main thread will wait with a timeout on the condvar and then leave once the boolean has been updated and notified.</source>
          <target state="translated">Основной поток будет ждать с таймаутом на кондоне,а затем уйдет,как только булевы будут обновлены и оповещены.</target>
        </trans-unit>
        <trans-unit id="2f4d9785a094ac7050147e12df1b0f82f8cae6fe" translate="yes" xml:space="preserve">
          <source>The main use case for type synonyms is to reduce repetition. For example, we might have a lengthy type like this:</source>
          <target state="translated">Основным случаем использования типовых синонимов является уменьшение количества повторений.Например,у нас может быть длинный тип,как этот:</target>
        </trans-unit>
        <trans-unit id="e1aa73c2c8bcfa6f25fb308f2154aee4987ca459" translate="yes" xml:space="preserve">
          <source>The main way to use Boolean values is through conditionals, such as an &lt;code&gt;if&lt;/code&gt; expression. We&amp;rsquo;ll cover how &lt;code&gt;if&lt;/code&gt; expressions work in Rust in the &lt;a href=&quot;ch03-05-control-flow#control-flow&quot;&gt;&amp;ldquo;Control Flow&amp;rdquo;&lt;/a&gt; section.</source>
          <target state="translated">Основной способ использования логических значений - это использование условных выражений , таких как выражение &lt;code&gt;if&lt;/code&gt; . Мы рассмотрим , как &lt;code&gt;if&lt;/code&gt; выражения работают в Русте в &lt;a href=&quot;ch03-05-control-flow#control-flow&quot;&gt;&amp;laquo;Flow Control&amp;raquo;&lt;/a&gt; раздел.</target>
        </trans-unit>
        <trans-unit id="67f97a592dc5c37dc58d2c3fd741d8753b33f60e" translate="yes" xml:space="preserve">
          <source>The mapping to &lt;a href=&quot;../io/enum.errorkind&quot;&gt;&lt;code&gt;ErrorKind&lt;/code&gt;&lt;/a&gt;s is not part of the compatibility contract of the function, especially the &lt;a href=&quot;../io/enum.errorkind#variant.Other&quot;&gt;&lt;code&gt;Other&lt;/code&gt;&lt;/a&gt; kind might change to more specific kinds in the future.</source>
          <target state="translated">Сопоставление с &lt;a href=&quot;../io/enum.errorkind&quot;&gt; &lt;code&gt;ErrorKind&lt;/code&gt; &lt;/a&gt; s не является частью контракта совместимости функции, особенно тип &lt;a href=&quot;../io/enum.errorkind#variant.Other&quot;&gt; &lt;code&gt;Other&lt;/code&gt; &lt;/a&gt; может измениться на более конкретные виды в будущем.</target>
        </trans-unit>
        <trans-unit id="f8fda3a6ce0d45625dd9cd044a1a98a742c97014" translate="yes" xml:space="preserve">
          <source>The match condition states that the arm only matches if the value of &lt;code&gt;x&lt;/code&gt; is equal to &lt;code&gt;4&lt;/code&gt;, &lt;code&gt;5&lt;/code&gt;, or &lt;code&gt;6&lt;/code&gt;&lt;em&gt;and&lt;/em&gt; if &lt;code&gt;y&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;. When this code runs, the pattern of the first arm matches because &lt;code&gt;x&lt;/code&gt; is &lt;code&gt;4&lt;/code&gt;, but the match guard &lt;code&gt;if y&lt;/code&gt; is false, so the first arm is not chosen. The code moves on to the second arm, which does match, and this program prints &lt;code&gt;no&lt;/code&gt;. The reason is that the &lt;code&gt;if&lt;/code&gt; condition applies to the whole pattern &lt;code&gt;4 | 5 | 6&lt;/code&gt;, not only to the last value &lt;code&gt;6&lt;/code&gt;. In other words, the precedence of a match guard in relation to a pattern behaves like this:</source>
          <target state="translated">В состояние матча гласит , что рука соответствует только если значение &lt;code&gt;x&lt;/code&gt; равно &lt;code&gt;4&lt;/code&gt; , &lt;code&gt;5&lt;/code&gt; или &lt;code&gt;6&lt;/code&gt; ,&lt;em&gt;и&lt;/em&gt; , если &lt;code&gt;y&lt;/code&gt; является &lt;code&gt;true&lt;/code&gt; . Когда этот код запускается, образец первой руки совпадает, потому что &lt;code&gt;x&lt;/code&gt; равен &lt;code&gt;4&lt;/code&gt; , но защита совпадения, &lt;code&gt;if y&lt;/code&gt; ложна, поэтому первая рука не выбирается. Код переходит ко второму плечу, которое действительно совпадает, и эта программа печатает &lt;code&gt;no&lt;/code&gt; . Причина в том, что условие &lt;code&gt;if&lt;/code&gt; применяется ко всему шаблону &lt;code&gt;4 | 5 | 6&lt;/code&gt; , а не только до последнего значения &lt;code&gt;6&lt;/code&gt; . Другими словами, приоритет защиты совпадений по отношению к шаблону выглядит следующим образом:</target>
        </trans-unit>
        <trans-unit id="6477b3c15cf1efd2f96aba3a277d7e0dd00d128c" translate="yes" xml:space="preserve">
          <source>The match guard &lt;code&gt;if n == y&lt;/code&gt; is not a pattern and therefore doesn&amp;rsquo;t introduce new variables. This &lt;code&gt;y&lt;/code&gt;&lt;em&gt;is&lt;/em&gt; the outer &lt;code&gt;y&lt;/code&gt; rather than a new shadowed &lt;code&gt;y&lt;/code&gt;, and we can look for a value that has the same value as the outer &lt;code&gt;y&lt;/code&gt; by comparing &lt;code&gt;n&lt;/code&gt; to &lt;code&gt;y&lt;/code&gt;.</source>
          <target state="translated">Защита соответствия, &lt;code&gt;if n == y&lt;/code&gt; не является шаблоном и, следовательно, не вводит новые переменные. Это &lt;code&gt;y&lt;/code&gt; &lt;em&gt;является&lt;/em&gt; внешним &lt;code&gt;y&lt;/code&gt; , а не новым затененным &lt;code&gt;y&lt;/code&gt; , и мы можем найти значение, которое имеет то же значение, что и внешний &lt;code&gt;y&lt;/code&gt; , сравнивая &lt;code&gt;n&lt;/code&gt; с &lt;code&gt;y&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0a68bad7489889370013d2c1b380ae26eafd0a34" translate="yes" xml:space="preserve">
          <source>The matched value was assigned in a match guard.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="da4a7cee97aca95b9c65ea2bcda5404ae104d4f6" translate="yes" xml:space="preserve">
          <source>The maximum duration.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="639334ee92fbc7d55384c7ec82527ac8487a080f" translate="yes" xml:space="preserve">
          <source>The maximum value of an enum was reached, so it cannot be automatically set in the next enum value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="444f3162cb088de418eba38f4a421be7235eea6f" translate="yes" xml:space="preserve">
          <source>The maximum value of an enum was reached, so it cannot be automatically set in the next enum value. Erroneous code example:</source>
          <target state="translated">Максимальное значение перечисления было достигнуто,поэтому оно не может быть автоматически установлено в следующем значении перечисления.Пример ошибочного кода:</target>
        </trans-unit>
        <trans-unit id="69d28668979329993270aea55163f780c2136684" translate="yes" xml:space="preserve">
          <source>The memory allocator returned an error</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f691ffd885b1cdd7c3aced4e660ea6b5f2bc5114" translate="yes" xml:space="preserve">
          <source>The memory at &lt;code&gt;buf&lt;/code&gt; needs to have been previously allocated by the same allocator the standard library uses, with a required alignment of exactly 1.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="297bebe1d80f3b348c7c8e6094a67afc0f518766" translate="yes" xml:space="preserve">
          <source>The memory at &lt;code&gt;ptr&lt;/code&gt; needs to have been previously allocated by the same allocator the standard library uses.</source>
          <target state="translated">Память в &lt;code&gt;ptr&lt;/code&gt; должна быть ранее выделена тем же распределителем, который использует стандартная библиотека.</target>
        </trans-unit>
        <trans-unit id="533d683a4cce37c267e983c916aea2694b115c42" translate="yes" xml:space="preserve">
          <source>The memory block will contain the following contents after a successful call to &lt;code&gt;grow_zeroed&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9f4c6be6867180c56169b0ceb625f117dffee9cb" translate="yes" xml:space="preserve">
          <source>The memory layout of a &lt;code&gt;struct&lt;/code&gt; is undefined by default to allow for compiler optimizations like field reordering, but it can be fixed with the &lt;a href=&quot;../type-layout#representations&quot;&gt;&lt;code&gt;repr&lt;/code&gt; attribute&lt;/a&gt;. In either case, fields may be given in any order in a corresponding struct &lt;em&gt;expression&lt;/em&gt;; the resulting &lt;code&gt;struct&lt;/code&gt; value will always have the same memory layout.</source>
          <target state="translated">Макет памяти &lt;code&gt;struct&lt;/code&gt; по умолчанию не определен, чтобы обеспечить оптимизацию компилятора, такую ​​как переупорядочение полей, но это можно исправить с помощью &lt;a href=&quot;../type-layout#representations&quot;&gt;атрибута &lt;/a&gt; &lt;code&gt;repr&lt;/code&gt; . В любом случае поля могут быть указаны в любом порядке в соответствующем структурном &lt;em&gt;выражении&lt;/em&gt; ; результирующее значение &lt;code&gt;struct&lt;/code&gt; всегда будет иметь один и тот же макет памяти.</target>
        </trans-unit>
        <trans-unit id="613a15d193cb4b5b9d7d2448a0d26f441bad60d3" translate="yes" xml:space="preserve">
          <source>The memory layout of a &lt;code&gt;union&lt;/code&gt; is undefined by default, but the &lt;code&gt;#[repr(...)]&lt;/code&gt; attribute can be used to fix a layout.</source>
          <target state="translated">Макет памяти &lt;code&gt;union&lt;/code&gt; по умолчанию не определен, но атрибут &lt;code&gt;#[repr(...)]&lt;/code&gt; может использоваться для исправления макета.</target>
        </trans-unit>
        <trans-unit id="62988640c5b4ea3199910497b4399a06d9aa4bb8" translate="yes" xml:space="preserve">
          <source>The memory must be requested from the memory allocator at runtime.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5158117ae58dde222908d602ad3b6cfbc19fbd1b" translate="yes" xml:space="preserve">
          <source>The memory must be requested from the operating system at runtime.</source>
          <target state="translated">Память необходимо запрашивать у операционной системы во время выполнения.</target>
        </trans-unit>
        <trans-unit id="5fb7e987a9654eee8114bb60b92e8b3cf5d47151" translate="yes" xml:space="preserve">
          <source>The memory referenced by the returned slice must not be accessed through any other pointer (not derived from the return value) for the duration of lifetime &lt;code&gt;'a&lt;/code&gt;. Both read and write accesses are forbidden.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ff115e1f60568ae547418e535b08f2a38631c573" translate="yes" xml:space="preserve">
          <source>The memory referenced by the returned slice must not be mutated for the duration of lifetime &lt;code&gt;'a&lt;/code&gt;, except inside an &lt;code&gt;UnsafeCell&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6139b94477b7472bd857c001d753b72d8df9f27e" translate="yes" xml:space="preserve">
          <source>The message can be of any (&lt;code&gt;Any + Send&lt;/code&gt;) type, not just strings.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3d782721b766f719dd5b6d817f0d6bb437eb7d6a" translate="yes" xml:space="preserve">
          <source>The message is wrapped in a &lt;code&gt;Box&amp;lt;'static + Any + Send&amp;gt;&lt;/code&gt;, which can be accessed later using &lt;a href=&quot;struct.panicinfo#method.payload&quot;&gt;&lt;code&gt;PanicInfo::payload&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c86a2a43ba3e98f03e1d643c5eb2cb7bce34d7c4" translate="yes" xml:space="preserve">
          <source>The method does no guarding against overflows, so counting elements of an iterator with more than &lt;a href=&quot;../usize/constant.max&quot;&gt;&lt;code&gt;usize::MAX&lt;/code&gt;&lt;/a&gt; elements either produces the wrong result or panics. If debug assertions are enabled, a panic is guaranteed.</source>
          <target state="translated">Этот метод не защищает от переполнений, поэтому подсчет элементов итератора с большим &lt;a href=&quot;../usize/constant.max&quot;&gt; &lt;code&gt;usize::MAX&lt;/code&gt; &lt;/a&gt; элементов, чем usize :: MAX, либо дает неправильный результат, либо вызывает панику. Если отладочные утверждения включены, паника гарантирована.</target>
        </trans-unit>
        <trans-unit id="177a5c2ea6344ea77e9ae3a6db8fc74469cc253c" translate="yes" xml:space="preserve">
          <source>The method does no guarding against overflows, so enumerating more than &lt;a href=&quot;../usize/constant.max&quot;&gt;&lt;code&gt;usize::MAX&lt;/code&gt;&lt;/a&gt; elements either produces the wrong result or panics. If debug assertions are enabled, a panic is guaranteed.</source>
          <target state="translated">Этот метод не &lt;a href=&quot;../usize/constant.max&quot;&gt; &lt;code&gt;usize::MAX&lt;/code&gt; &lt;/a&gt; от переполнения, поэтому перечисление большего количества элементов, чем usize :: MAX, либо дает неверный результат, либо вызывает панику. Если отладочные утверждения включены, паника гарантирована.</target>
        </trans-unit>
        <trans-unit id="3a1826392947e9b9a700c20663562183cfe20bf1" translate="yes" xml:space="preserve">
          <source>The method does no guarding against overflows, so enumerating more than &lt;code&gt;usize::MAX&lt;/code&gt; elements either produces the wrong result or panics. If debug assertions are enabled, a panic is guaranteed.</source>
          <target state="translated">Этот метод не &lt;code&gt;usize::MAX&lt;/code&gt; от переполнения, поэтому перечисление большего количества элементов, чем usize :: MAX, либо дает неверный результат, либо вызывает панику. Если отладочные утверждения включены, паника гарантирована.</target>
        </trans-unit>
        <trans-unit id="19d8816b84fe470f79cf77755eeb8ee64e555da5" translate="yes" xml:space="preserve">
          <source>The method does no guarding against overflows, so if there are more than &lt;a href=&quot;../usize/constant.max&quot;&gt;&lt;code&gt;usize::MAX&lt;/code&gt;&lt;/a&gt; non-matching elements, it either produces the wrong result or panics. If debug assertions are enabled, a panic is guaranteed.</source>
          <target state="translated">Этот метод не &lt;a href=&quot;../usize/constant.max&quot;&gt; &lt;code&gt;usize::MAX&lt;/code&gt; &lt;/a&gt; от переполнения, поэтому, если несоответствующих элементов больше, чем usize :: MAX , он либо дает неправильный результат, либо вызывает панику. Если отладочные утверждения включены, паника гарантирована.</target>
        </trans-unit>
        <trans-unit id="1be550addda456adee08f228dc9b4f31db12dda4" translate="yes" xml:space="preserve">
          <source>The method will panic if the given step is &lt;code&gt;0&lt;/code&gt;.</source>
          <target state="translated">Метод запаникует, если данный шаг равен &lt;code&gt;0&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="18a6ab41791924ffc3860ab7c005689a5ace692a" translate="yes" xml:space="preserve">
          <source>The minimum alignment of a type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d61a28fc808f2bb8277ab6d2dda14e2b5dc3214d" translate="yes" xml:space="preserve">
          <source>The minimum byte alignment for a memory block of this layout.</source>
          <target state="translated">Минимальное выравнивание по байтам для блока памяти данной раскладки.</target>
        </trans-unit>
        <trans-unit id="e621ea6ab30e14c7bfa77e4fee05fb852bfe464d" translate="yes" xml:space="preserve">
          <source>The minimum duration.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5b04e5eee8d92581fabe61b454bd932d16d3b4ee" translate="yes" xml:space="preserve">
          <source>The minimum size in bytes for a memory block of this layout.</source>
          <target state="translated">Минимальный размер в байтах для блока памяти данной компоновки.</target>
        </trans-unit>
        <trans-unit id="4650b1470ff8fe4b9a6a554cb10a84ba4229b041" translate="yes" xml:space="preserve">
          <source>The mirror use case of FFI is also done via the &lt;code&gt;extern&lt;/code&gt; keyword:</source>
          <target state="translated">Зеркальный вариант использования FFI также выполняется с помощью ключевого слова &lt;code&gt;extern&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="a82559d5a04edc93a72fe140de851778ee358fc2" translate="yes" xml:space="preserve">
          <source>The module tree might remind you of the filesystem&amp;rsquo;s directory tree on your computer; this is a very apt comparison! Just like directories in a filesystem, you use modules to organize your code. And just like files in a directory, we need a way to find our modules.</source>
          <target state="translated">Дерево модулей может напоминать вам дерево каталогов файловой системы на вашем компьютере; это очень удачное сравнение! Как и каталоги в файловой системе, вы используете модули для организации своего кода. И точно так же, как файлы в каталоге, нам нужен способ найти наши модули.</target>
        </trans-unit>
        <trans-unit id="ea4c9b3e2b6f858a3799aa18909b3e42f1061d3e" translate="yes" xml:space="preserve">
          <source>The module tree remains the same, and the function calls in &lt;code&gt;eat_at_restaurant&lt;/code&gt; will work without any modification, even though the definitions live in different files. This technique lets you move modules to new files as they grow in size.</source>
          <target state="translated">Дерево модулей остается прежним, и вызовы функций в &lt;code&gt;eat_at_restaurant&lt;/code&gt; будут работать без каких-либо изменений, даже если определения находятся в разных файлах. Этот метод позволяет перемещать модули в новые файлы по мере их увеличения.</target>
        </trans-unit>
        <trans-unit id="fb5cf295cab45b30e8f8d196e49ec369e86db99a" translate="yes" xml:space="preserve">
          <source>The monomorphized version of the code looks like the following. The generic &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt; is replaced with the specific definitions created by the compiler:</source>
          <target state="translated">Мономорфизированная версия кода выглядит следующим образом. Общий &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt; заменяется конкретными определениями, созданными компилятором:</target>
        </trans-unit>
        <trans-unit id="75cf509b67ca81925881254de671f6530c684e13" translate="yes" xml:space="preserve">
          <source>The more common inherited mutability, where one must have unique access to mutate a value, is one of the key language elements that enables Rust to reason strongly about pointer aliasing, statically preventing crash bugs. Because of that, inherited mutability is preferred, and interior mutability is something of a last resort. Since cell types enable mutation where it would otherwise be disallowed though, there are occasions when interior mutability might be appropriate, or even &lt;em&gt;must&lt;/em&gt; be used, e.g.</source>
          <target state="translated">Более распространенная наследуемая изменчивость, при которой необходимо иметь уникальный доступ для изменения значения, является одним из ключевых языковых элементов, который позволяет Rust серьезно рассуждать о псевдониме указателя, статически предотвращая ошибки сбоя. Из-за этого предпочтение отдается унаследованной изменчивости, а внутренняя изменчивость - это последнее средство. Поскольку типы клеток допускают мутацию там, где в противном случае она была бы запрещена, бывают случаи, когда внутренняя изменчивость может быть подходящей или даже &lt;em&gt;должна&lt;/em&gt; использоваться, например</target>
        </trans-unit>
        <trans-unit id="22b87181f4af9bcd4494ede540e86fdd7af786b7" translate="yes" xml:space="preserve">
          <source>The most basic pattern in which &lt;code&gt;collect()&lt;/code&gt; is used is to turn one collection into another. You take a collection, call &lt;a href=&quot;trait.iterator#tymethod.next&quot;&gt;&lt;code&gt;iter&lt;/code&gt;&lt;/a&gt; on it, do a bunch of transformations, and then &lt;code&gt;collect()&lt;/code&gt; at the end.</source>
          <target state="translated">Самый простой паттерн, в котором используется &lt;code&gt;collect()&lt;/code&gt; - это превращение одной коллекции в другую. Берет коллекцию, звоните &lt;a href=&quot;trait.iterator#tymethod.next&quot;&gt; &lt;code&gt;iter&lt;/code&gt; &lt;/a&gt; на него, сделать кучу преобразований, а затем &lt;code&gt;collect()&lt;/code&gt; в конце.</target>
        </trans-unit>
        <trans-unit id="8acfa5660545764d445a8a9080882c9972414cad" translate="yes" xml:space="preserve">
          <source>The most basic usage of the keyword is &lt;code&gt;use path::to::item;&lt;/code&gt;, though a number of convenient shortcuts are supported:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="524cfe2dc48693915271c90c3e4b7d15d2163d53" translate="yes" xml:space="preserve">
          <source>The most likely source of this error is using angle-bracket notation without wrapping the function argument type into a tuple, for example:</source>
          <target state="translated">Наиболее вероятным источником этой ошибки является использование нотации в виде угловой скобки без обёртывания типа аргумента функции в кортеж,например:</target>
        </trans-unit>
        <trans-unit id="f1fae4bef53f01c296ad8cf52cd2f776bcb2545a" translate="yes" xml:space="preserve">
          <source>The most straightforward smart pointer is a &lt;em&gt;box&lt;/em&gt;, whose type is written &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt;. Boxes allow you to store data on the heap rather than the stack. What remains on the stack is the pointer to the heap data. Refer to Chapter 4 to review the difference between the stack and the heap.</source>
          <target state="translated">Самый простой умный указатель - это &lt;em&gt;прямоугольник&lt;/em&gt; , тип которого написан &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; . Ящики позволяют хранить данные в куче, а не в стеке. В стеке остается указатель на данные кучи. Обратитесь к Главе 4, чтобы увидеть разницу между стеком и кучей.</target>
        </trans-unit>
        <trans-unit id="c84503d5e594d47f23b7b930df844dc25ee59200" translate="yes" xml:space="preserve">
          <source>The most surprising behavior occurs when &quot;the same&quot; file is reachable via multiple paths in the module system (usually using the &lt;code&gt;#[path = &quot;...&quot;]&lt;/code&gt; attribute or similar), which can cause what appears to be identical code to return differing values from this function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="224b0446b4293b35c3feb8b386382ff2882bd862" translate="yes" xml:space="preserve">
          <source>The most widely used form of macros in Rust is &lt;em&gt;declarative macros&lt;/em&gt;. These are also sometimes referred to as &amp;ldquo;macros by example,&amp;rdquo; &amp;ldquo;&lt;code&gt;macro_rules!&lt;/code&gt; macros,&amp;rdquo; or just plain &amp;ldquo;macros.&amp;rdquo; At their core, declarative macros allow you to write something similar to a Rust &lt;code&gt;match&lt;/code&gt; expression. As discussed in Chapter 6, &lt;code&gt;match&lt;/code&gt; expressions are control structures that take an expression, compare the resulting value of the expression to patterns, and then run the code associated with the matching pattern. Macros also compare a value to patterns that are associated with particular code: in this situation, the value is the literal Rust source code passed to the macro; the patterns are compared with the structure of that source code; and the code associated with each pattern, when matched, replaces the code passed to the macro. This all happens during compilation.</source>
          <target state="translated">Наиболее широко используемая форма макросов в Rust - это &lt;em&gt;декларативные макросы&lt;/em&gt; . Их также иногда называют &amp;laquo;макросы на примере&amp;raquo;, &amp;laquo; &lt;code&gt;macro_rules!&lt;/code&gt; макросы &amp;raquo;или просто&amp;laquo; макросы &amp;raquo;. По своей сути декларативные макросы позволяют писать что-то похожее на выражение &lt;code&gt;match&lt;/code&gt; в Rust . Как обсуждалось в главе 6, &lt;code&gt;match&lt;/code&gt; Выражения - это управляющие структуры, которые принимают выражение, сравнивают полученное значение выражения с шаблонами и затем запускают код, связанный с совпадающим шаблоном. Макросы также сравнивают значение с шаблонами, которые связаны с конкретным кодом: в этой ситуации значение представляет собой буквальный исходный код Rust, переданный макросу; шаблоны сравниваются со структурой этого исходного кода; и код, связанный с каждым шаблоном, при совпадении заменяет код, переданный макросу. Все это происходит во время компиляции.</target>
        </trans-unit>
        <trans-unit id="5c8119cbdd49364e9c5037e1b8a03abc1bccdb46" translate="yes" xml:space="preserve">
          <source>The motivation for this design is twofold:</source>
          <target state="translated">Мотивация этого проекта двоякая:</target>
        </trans-unit>
        <trans-unit id="6fd4e131dbce656fa77aa6dbacb12fee04853072" translate="yes" xml:space="preserve">
          <source>The multi-argument form of this macro panics with a string and has the &lt;a href=&quot;macro.format&quot;&gt;&lt;code&gt;format!&lt;/code&gt;&lt;/a&gt; syntax for building a string.</source>
          <target state="translated">Форма с несколькими аргументами этого макроса вызывает панику со строкой и имеет &lt;a href=&quot;macro.format&quot;&gt; &lt;code&gt;format!&lt;/code&gt; &lt;/a&gt;синтаксис для построения строки.</target>
        </trans-unit>
        <trans-unit id="ff7a3f839c4dac34de65c2bfcbc13d6c2f460e6c" translate="yes" xml:space="preserve">
          <source>The multiplication assignment operator &lt;code&gt;*=&lt;/code&gt;.</source>
          <target state="translated">Оператор присваивания умножения &lt;code&gt;*=&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="945e202ccc3f817f464a16a52710aeff055613cc" translate="yes" xml:space="preserve">
          <source>The multiplication operator &lt;code&gt;*&lt;/code&gt;.</source>
          <target state="translated">Оператор умножения &lt;code&gt;*&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="395bf55779b3f4b37031c67eb2f13567f6e766a4" translate="yes" xml:space="preserve">
          <source>The mutability of a pointer does not change its size. As such, &lt;code&gt;&amp;amp;T&lt;/code&gt; and &lt;code&gt;&amp;amp;mut T&lt;/code&gt; have the same size. Likewise for &lt;code&gt;*const T&lt;/code&gt; and &lt;code&gt;*mut T&lt;/code&gt;.</source>
          <target state="translated">Изменчивость указателя не меняет его размер. Таким образом, &lt;code&gt;&amp;amp;T&lt;/code&gt; и &lt;code&gt;&amp;amp;mut T&lt;/code&gt; имеют одинаковый размер. Аналогично для &lt;code&gt;*const T&lt;/code&gt; и &lt;code&gt;*mut T&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f42a8b27f0c72155ef0f3b14d7be6cafaaf62841" translate="yes" xml:space="preserve">
          <source>The mutable slice yields mutable references to the elements:</source>
          <target state="translated">Мутируемый срез дает мутирующие ссылки на элементы:</target>
        </trans-unit>
        <trans-unit id="3c3cbd1ab17a10688ead5cf4d56f2dfc9e512608" translate="yes" xml:space="preserve">
          <source>The mutexes in this module implement a strategy called &quot;poisoning&quot; where a mutex is considered poisoned whenever a thread panics while holding the mutex. Once a mutex is poisoned, all other threads are unable to access the data by default as it is likely tainted (some invariant is not being upheld).</source>
          <target state="translated">Мьютексы в этом модуле реализуют стратегию,называемую &quot;отравление&quot;,при которой мьютекс считается отравленным всякий раз,когда поток паникует,удерживая мьютекс.После того,как мьютекс отравлен,все остальные потоки не могут получить доступ к данным по умолчанию,так как они,скорее всего,испорчены (какой-то инвариант не поддерживается).</target>
        </trans-unit>
        <trans-unit id="d8b50303b0747d7e3abc95898503b5bde7711980" translate="yes" xml:space="preserve">
          <source>The name chosen for an external crate conflicts with another external crate that has been imported into the current module.</source>
          <target state="translated">Имя,выбранное для внешнего ящика,конфликтует с другим внешним ящиком,который был импортирован в текущий модуль.</target>
        </trans-unit>
        <trans-unit id="d94375d609f70bc0ddb2da1f070fd5b681c30cc1" translate="yes" xml:space="preserve">
          <source>The name for an item declaration conflicts with an external crate's name.</source>
          <target state="translated">Имя для декларации предмета противоречит имени внешнего ящика.</target>
        </trans-unit>
        <trans-unit id="286d59804da04e407ec36eb2be39e9e0c7ff3343" translate="yes" xml:space="preserve">
          <source>The name must not contain null bytes (&lt;code&gt;\0&lt;/code&gt;).</source>
          <target state="translated">Имя не должно содержать нулевых байтов ( &lt;code&gt;\0&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="6584162ced4a99e7d4548e6dfca0a1b5adbdbd8e" translate="yes" xml:space="preserve">
          <source>The need for synchronization</source>
          <target state="translated">Необходимость синхронизации</target>
        </trans-unit>
        <trans-unit id="9491a60a88ee503552e1418886a35e38dd1f594f" translate="yes" xml:space="preserve">
          <source>The need for this type arises from the fact that:</source>
          <target state="translated">Потребность в таком типе возникает из-за того,что..:</target>
        </trans-unit>
        <trans-unit id="3e795b9b16f895fca00c98b1df11fc0d63c7301f" translate="yes" xml:space="preserve">
          <source>The network operation failed because it was not connected yet.</source>
          <target state="translated">Сетевая операция завершилась неудачей,потому что она еще не была подключена.</target>
        </trans-unit>
        <trans-unit id="7c5a2cc50c7976456054417007ed08f73bfd9e80" translate="yes" xml:space="preserve">
          <source>The never type &lt;code&gt;!&lt;/code&gt; is a type with no values, representing the result of computations that never complete. Expressions of type &lt;code&gt;!&lt;/code&gt; can be coerced into any other type.</source>
          <target state="translated">Никогда не печатай &lt;code&gt;!&lt;/code&gt; это тип без значений, представляющий результат вычислений, которые никогда не завершаются. Выражения типа &lt;code&gt;!&lt;/code&gt; может быть принужден к любому другому типу.</target>
        </trans-unit>
        <trans-unit id="2876200ee40ea0a4251130e3bb42070db01f59e5" translate="yes" xml:space="preserve">
          <source>The never type is useful with the &lt;code&gt;panic!&lt;/code&gt; macro as well. Remember the &lt;code&gt;unwrap&lt;/code&gt; function that we call on &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt; values to produce a value or panic? Here is its definition:</source>
          <target state="translated">Тип never полезен при &lt;code&gt;panic!&lt;/code&gt; макрос тоже. Помните функцию &lt;code&gt;unwrap&lt;/code&gt; которую мы вызываем для значений &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt; для создания значения или паники? Вот его определение:</target>
        </trans-unit>
        <trans-unit id="56b6326e5da7a2c1bad08c52fe9675cb30d6fc5f" translate="yes" xml:space="preserve">
          <source>The new test for the case-&lt;em&gt;insensitive&lt;/em&gt; search uses &lt;code&gt;&quot;rUsT&quot;&lt;/code&gt; as its query. In the &lt;code&gt;search_case_insensitive&lt;/code&gt; function we&amp;rsquo;re about to add, the query &lt;code&gt;&quot;rUsT&quot;&lt;/code&gt; should match the line containing &lt;code&gt;&quot;Rust:&quot;&lt;/code&gt; with a capital R and match the line &lt;code&gt;&quot;Trust me.&quot;&lt;/code&gt; even though both have different casing from the query. This is our failing test, and it will fail to compile because we haven&amp;rsquo;t yet defined the &lt;code&gt;search_case_insensitive&lt;/code&gt; function. Feel free to add a skeleton implementation that always returns an empty vector, similar to the way we did for the &lt;code&gt;search&lt;/code&gt; function in Listing 12-16 to see the test compile and fail.</source>
          <target state="translated">Новый тест для поиска без &lt;code&gt;&quot;rUsT&quot;&lt;/code&gt; &lt;em&gt;регистра&lt;/em&gt; использует в качестве запроса &quot;rUsT&quot; . В функции &lt;code&gt;search_case_insensitive&lt;/code&gt; ,которую мы собираемся добавить, запрос &lt;code&gt;&quot;rUsT&quot;&lt;/code&gt; должен соответствовать строке, содержащей &lt;code&gt;&quot;Rust:&quot;&lt;/code&gt; с заглавной буквой R, и совпадать со строкой &lt;code&gt;&quot;Trust me.&quot;&lt;/code&gt; даже если оба имеют регистр, отличный от запроса. Это наш неудачный тест, и он не будет скомпилирован, потому что мы еще не определили функцию &lt;code&gt;search_case_insensitive&lt;/code&gt; . Не стесняйтесь добавлять скелетную реализацию, которая всегда возвращает пустой вектор, аналогично тому, как мы делали для функции &lt;code&gt;search&lt;/code&gt; в листинге 12-16, чтобы увидеть, как тест компилируется и терпит неудачу.</target>
        </trans-unit>
        <trans-unit id="9a3696a40107bd6d0870f3607ce5d6e5073b6d6b" translate="yes" xml:space="preserve">
          <source>The newtype pattern is useful for tasks beyond those we&amp;rsquo;ve discussed so far, including statically enforcing that values are never confused and indicating the units of a value. You saw an example of using newtypes to indicate units in Listing 19-15: recall that the &lt;code&gt;Millimeters&lt;/code&gt; and &lt;code&gt;Meters&lt;/code&gt; structs wrapped &lt;code&gt;u32&lt;/code&gt; values in a newtype. If we wrote a function with a parameter of type &lt;code&gt;Millimeters&lt;/code&gt;, we couldn&amp;rsquo;t compile a program that accidentally tried to call that function with a value of type &lt;code&gt;Meters&lt;/code&gt; or a plain &lt;code&gt;u32&lt;/code&gt;.</source>
          <target state="translated">Шаблон newtype полезен для задач, выходящих за рамки тех, которые мы обсуждали до сих пор, включая статическое обеспечение того, чтобы значения никогда не путались, и указание единиц значения. Вы видели пример использования Newtypes для обозначения единиц в листинге 19-15: напомнят , что &lt;code&gt;Millimeters&lt;/code&gt; и &lt;code&gt;Meters&lt;/code&gt; Структура завернутых &lt;code&gt;u32&lt;/code&gt; значения в Newtype. Если бы мы написали функцию с параметром типа &lt;code&gt;Millimeters&lt;/code&gt; , мы не смогли бы скомпилировать программу, которая случайно попыталась бы вызвать эту функцию со значением типа &lt;code&gt;Meters&lt;/code&gt; или обычным &lt;code&gt;u32&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b591edfc8b3d018e277499297a4856c76a36dc2a" translate="yes" xml:space="preserve">
          <source>The next four lines set the configuration information Cargo needs to compile your program: the name, the version, who wrote it, and the edition of Rust to use. Cargo gets your name and email information from your environment, so if that information is not correct, fix the information now and then save the file. We&amp;rsquo;ll talk about the &lt;code&gt;edition&lt;/code&gt; key in Appendix E.</source>
          <target state="translated">Следующие четыре строки задают информацию о конфигурации, необходимую Cargo для компиляции вашей программы: имя, версию, автор и версию Rust, которую нужно использовать. Cargo получает ваше имя и адрес электронной почты из вашей среды, поэтому, если эта информация неверна, исправьте ее сейчас, а затем сохраните файл. Мы поговорим о ключе &lt;code&gt;edition&lt;/code&gt; в Приложении E.</target>
        </trans-unit>
        <trans-unit id="6a7a2603b03740bcea191aea3d000fd9f48ffbb9" translate="yes" xml:space="preserve">
          <source>The next logical question is which style you should choose in your own code and why: the original implementation in Listing 13-28 or the version using iterators in Listing 13-29. Most Rust programmers prefer to use the iterator style. It&amp;rsquo;s a bit tougher to get the hang of at first, but once you get a feel for the various iterator adaptors and what they do, iterators can be easier to understand. Instead of fiddling with the various bits of looping and building new vectors, the code focuses on the high-level objective of the loop. This abstracts away some of the commonplace code so it&amp;rsquo;s easier to see the concepts that are unique to this code, such as the filtering condition each element in the iterator must pass.</source>
          <target state="translated">Следующий логический вопрос - какой стиль вы должны выбрать в своем собственном коде и почему: исходную реализацию в листинге 13-28 или версию с использованием итераторов в листинге 13-29. Большинство программистов на Rust предпочитают использовать стиль итератора. Сначала это немного сложнее освоить, но как только вы почувствуете различные адаптеры итераторов и то, что они делают, итераторы можно будет легче понять. Вместо того, чтобы возиться с различными битами цикла и строить новые векторы, код фокусируется на высокоуровневой цели цикла. Это абстрагирует часть обычного кода, поэтому легче увидеть концепции, уникальные для этого кода, такие как условие фильтрации, которое должен пройти каждый элемент в итераторе.</target>
        </trans-unit>
        <trans-unit id="57f6548988daa34617ffdf2e9ca86d7e443df79f" translate="yes" xml:space="preserve">
          <source>The next note line tells us that we can set the &lt;code&gt;RUST_BACKTRACE&lt;/code&gt; environment variable to get a backtrace of exactly what happened to cause the error. A &lt;em&gt;backtrace&lt;/em&gt; is a list of all the functions that have been called to get to this point. Backtraces in Rust work as they do in other languages: the key to reading the backtrace is to start from the top and read until you see files you wrote. That&amp;rsquo;s the spot where the problem originated. The lines above the lines mentioning your files are code that your code called; the lines below are code that called your code. These lines might include core Rust code, standard library code, or crates that you&amp;rsquo;re using. Let&amp;rsquo;s try getting a backtrace by setting the &lt;code&gt;RUST_BACKTRACE&lt;/code&gt; environment variable to any value except 0. Listing 9-2 shows output similar to what you&amp;rsquo;ll see.</source>
          <target state="translated">Следующая строка примечания сообщает нам, что мы можем установить &lt;code&gt;RUST_BACKTRACE&lt;/code&gt; окружения RUST_BACKTRACE, чтобы получить точную информацию о том, что именно привело к ошибке. &lt;em&gt;Трассировку&lt;/em&gt; список всех функций , которые были призваны , чтобы добраться до этой точки. Обратные трассировки в Rust работают так же, как и в других языках: ключ к чтению трассировки - начать сверху и читать, пока не увидите файлы, которые вы написали. Это место, где возникла проблема. Строки над строками, в которых упоминаются ваши файлы, представляют собой код, который вызывал ваш код; следующие строки - это код, который вызвал ваш код. Эти строки могут включать основной код Rust, код стандартной библиотеки или используемые вами ящики. Давайте попробуем получить обратную трассировку, установив &lt;code&gt;RUST_BACKTRACE&lt;/code&gt; переменную окружения на любое значение, кроме 0. В листинге 9-2 показан вывод, аналогичный тому, что вы увидите.</target>
        </trans-unit>
        <trans-unit id="771993487043dfd3c7aa5a2390e7d9f0063dbedb" translate="yes" xml:space="preserve">
          <source>The next part of the code, &lt;code&gt;.read_line(&amp;amp;mut guess)&lt;/code&gt;, calls the &lt;a href=&quot;../std/io/struct.stdin#method.read_line&quot;&gt;&lt;code&gt;read_line&lt;/code&gt;&lt;/a&gt; method on the standard input handle to get input from the user. We&amp;rsquo;re also passing one argument to &lt;code&gt;read_line&lt;/code&gt;: &lt;code&gt;&amp;amp;mut guess&lt;/code&gt;.</source>
          <target state="translated">Следующая часть кода, &lt;code&gt;.read_line(&amp;amp;mut guess)&lt;/code&gt; , вызывает метод &lt;a href=&quot;../std/io/struct.stdin#method.read_line&quot;&gt; &lt;code&gt;read_line&lt;/code&gt; &lt;/a&gt; в стандартном дескрипторе ввода, чтобы получить ввод от пользователя. Мы также &lt;code&gt;read_line&lt;/code&gt; один аргумент read_line : &lt;code&gt;&amp;amp;mut guess&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8f3a0383282eca508bd91153f03681dc6f1973f4" translate="yes" xml:space="preserve">
          <source>The next part of the request line is &lt;em&gt;/&lt;/em&gt;, which indicates the &lt;em&gt;Uniform Resource Identifier&lt;/em&gt;&lt;em&gt;(URI)&lt;/em&gt; the client is requesting: a URI is almost, but not quite, the same as a &lt;em&gt;Uniform Resource Locator&lt;/em&gt;&lt;em&gt;(URL)&lt;/em&gt;. The difference between URIs and URLs isn&amp;rsquo;t important for our purposes in this chapter, but the HTTP spec uses the term URI, so we can just mentally substitute URL for URI here.</source>
          <target state="translated">Следующая часть строки запроса - это &lt;em&gt;/&lt;/em&gt; , которая указывает &lt;em&gt;унифицированный идентификатор &lt;/em&gt;&lt;em&gt;ресурса (URI),&lt;/em&gt; который запрашивает клиент: URI почти, но не совсем то же самое, что &lt;em&gt;унифицированный указатель ресурса &lt;/em&gt;&lt;em&gt;(URL)&lt;/em&gt; . Разница между URI и URL-адресами не важна для наших целей в этой главе, но в спецификации HTTP используется термин URI, поэтому мы можем просто мысленно заменить URL-адрес на URI здесь.</target>
        </trans-unit>
        <trans-unit id="504232041214e8dae75346e3d17c4c0bf4814b9b" translate="yes" xml:space="preserve">
          <source>The next part of the test output, which starts with &lt;code&gt;Doc-tests adder&lt;/code&gt;, is for the results of any documentation tests. We don&amp;rsquo;t have any documentation tests yet, but Rust can compile any code examples that appear in our API documentation. This feature helps us keep our docs and our code in sync! We&amp;rsquo;ll discuss how to write documentation tests in the &lt;a href=&quot;ch14-02-publishing-to-crates-io#documentation-comments-as-tests&quot;&gt;&amp;ldquo;Documentation Comments as Tests&amp;rdquo;&lt;/a&gt; section of Chapter 14. For now, we&amp;rsquo;ll ignore the &lt;code&gt;Doc-tests&lt;/code&gt; output.</source>
          <target state="translated">Следующая часть результатов теста, которая начинается с &lt;code&gt;Doc-tests adder&lt;/code&gt; , предназначена для результатов любых тестов документации. У нас еще нет тестов документации, но Rust может скомпилировать любые примеры кода, которые появляются в нашей документации по API. Эта функция помогает нам синхронизировать наши документы и наш код! Мы обсудим, как писать тесты документации, в разделе &lt;a href=&quot;ch14-02-publishing-to-crates-io#documentation-comments-as-tests&quot;&gt;&amp;laquo;Комментарии к документации как тесты&amp;raquo;&lt;/a&gt; главы 14. На данный момент мы проигнорируем вывод &lt;code&gt;Doc-tests&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1ac4585430b879637fa9bf73df289a63ff5c8c8c" translate="yes" xml:space="preserve">
          <source>The next step is to define the procedural macro. At the time of this writing, procedural macros need to be in their own crate. Eventually, this restriction might be lifted. The convention for structuring crates and macro crates is as follows: for a crate named &lt;code&gt;foo&lt;/code&gt;, a custom derive procedural macro crate is called &lt;code&gt;foo_derive&lt;/code&gt;. Let&amp;rsquo;s start a new crate called &lt;code&gt;hello_macro_derive&lt;/code&gt; inside our &lt;code&gt;hello_macro&lt;/code&gt; project:</source>
          <target state="translated">Следующим шагом является определение процедурного макроса. На момент написания этой статьи процедурные макросы должны быть в отдельной корзине. Со временем это ограничение может быть снято. Соглашение о структурировании ящиков и ящиков макросов следующее: для ящика с именем &lt;code&gt;foo&lt;/code&gt; настраиваемый процедурный ящик макроса &lt;code&gt;foo_derive&lt;/code&gt; называется foo_derive . Давайте запустим новый ящик под названием &lt;code&gt;hello_macro_derive&lt;/code&gt; внутри нашего проекта &lt;code&gt;hello_macro&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="86c376c4d2f9126074dd6023a007174609449704" translate="yes" xml:space="preserve">
          <source>The next time you run &lt;code&gt;cargo build&lt;/code&gt;, Cargo will update the registry of crates available and reevaluate your &lt;code&gt;rand&lt;/code&gt; requirements according to the new version you have specified.</source>
          <target state="translated">В следующий раз, когда вы запустите &lt;code&gt;cargo build&lt;/code&gt; Cargo, Cargo обновит реестр доступных ящиков и повторно оценит ваши требования &lt;code&gt;rand&lt;/code&gt; в соответствии с указанной вами новой версией.</target>
        </trans-unit>
        <trans-unit id="14f1a8115e3ecc473c296ccb90a19424fd7f3781" translate="yes" xml:space="preserve">
          <source>The nightly feature &lt;a href=&quot;https://doc.rust-lang.org/unstable-book/language-features/arbitrary-self-types.html&quot;&gt;Arbitrary self types&lt;/a&gt; extends the accepted set of receiver types to also include any type that can dereference to &lt;code&gt;Self&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b3e15e37e03d384e681f27ce15aeb9d3bb4095a8" translate="yes" xml:space="preserve">
          <source>The node that was removed is returned as a new &lt;code&gt;LinkedList&lt;/code&gt; containing only this node. The cursor is moved to point to the next element in the current &lt;code&gt;LinkedList&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="145ccdcfae9c0bd6f7e5de42ea443500c786c639" translate="yes" xml:space="preserve">
          <source>The nominal type is called the &lt;em&gt;implementing type&lt;/em&gt; and the associable items are the &lt;em&gt;associated items&lt;/em&gt; to the implementing type.</source>
          <target state="translated">Номинальный тип называется &lt;em&gt;реализуемым типом,&lt;/em&gt; а связанные элементы являются элементами, &lt;em&gt;связанными&lt;/em&gt; с реализуемым типом.</target>
        </trans-unit>
        <trans-unit id="a450d39487d717bce9613fc2953a92eb80b07994" translate="yes" xml:space="preserve">
          <source>The note mentions &lt;code&gt;std::cmp::PartialOrd&lt;/code&gt;, which is a &lt;em&gt;trait&lt;/em&gt;. We&amp;rsquo;ll talk about traits in the next section. For now, this error states that the body of &lt;code&gt;largest&lt;/code&gt; won&amp;rsquo;t work for all possible types that &lt;code&gt;T&lt;/code&gt; could be. Because we want to compare values of type &lt;code&gt;T&lt;/code&gt; in the body, we can only use types whose values can be ordered. To enable comparisons, the standard library has the &lt;code&gt;std::cmp::PartialOrd&lt;/code&gt; trait that you can implement on types (see Appendix C for more on this trait). You&amp;rsquo;ll learn how to specify that a generic type has a particular trait in the &lt;a href=&quot;ch10-02-traits#traits-as-parameters&quot;&gt;&amp;ldquo;Traits as Parameters&amp;rdquo;&lt;/a&gt; section, but let&amp;rsquo;s first explore other ways of using generic type parameters.</source>
          <target state="translated">В примечании упоминается &lt;code&gt;std::cmp::PartialOrd&lt;/code&gt; , что является &lt;em&gt;признаком&lt;/em&gt; . Мы поговорим о чертах характера в следующем разделе. На данный момент эта ошибка указывает, что тело &lt;code&gt;largest&lt;/code&gt; не будет работать для всех возможных типов, которыми мог бы быть &lt;code&gt;T&lt;/code&gt; . Поскольку мы хотим сравнивать значения типа &lt;code&gt;T&lt;/code&gt; в теле, мы можем использовать только типы, значения которых можно упорядочить. Чтобы включить сравнения, стандартная библиотека имеет черту &lt;code&gt;std::cmp::PartialOrd&lt;/code&gt; которую вы можете реализовать для типов (см. Приложение C для получения дополнительной информации об этой характеристике). Вы узнаете, как указать, что универсальный тип имеет определенную черту, в разделе &lt;a href=&quot;ch10-02-traits#traits-as-parameters&quot;&gt;&amp;laquo;Свойства как параметры&amp;raquo;&lt;/a&gt; , но давайте сначала рассмотрим другие способы использования параметров универсального типа.</target>
        </trans-unit>
        <trans-unit id="39a86e3fff1f9b2a932559db164eca88c47636bb" translate="yes" xml:space="preserve">
          <source>The number of arguments passed to a function must match the number of arguments specified in the function signature.</source>
          <target state="translated">Количество аргументов,передаваемых функции,должно соответствовать количеству аргументов,указанных в сигнатуре функции.</target>
        </trans-unit>
        <trans-unit id="1499b95664ab693551effdfbf1800a214feda909" translate="yes" xml:space="preserve">
          <source>The number of elements determines the arity of the tuple. A tuple with &lt;code&gt;n&lt;/code&gt; elements is called an &lt;code&gt;n-ary tuple&lt;/code&gt;. For example, a tuple with 2 elements is a 2-ary tuple.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="29c5008d92a3f283390aac2066e3363b4399cff1" translate="yes" xml:space="preserve">
          <source>The number of elements in an array or slice pattern differed from the number of elements in the array being matched.</source>
          <target state="translated">Количество элементов в массиве или образце среза отличалось от количества элементов в согласовываемом массиве.</target>
        </trans-unit>
        <trans-unit id="110544a8e2a789b8a0779516d37df0cd0dba8ad5" translate="yes" xml:space="preserve">
          <source>The number of operands is the arity of the constructed tuple. Tuple expressions without operands produce the unit tuple. For other tuple expressions, the first written operand initializes the 0th element and subsequent operands initializes the next highest element. For example, in the tuple expression &lt;code&gt;('a', 'b', 'c')&lt;/code&gt;, &lt;code&gt;'a'&lt;/code&gt; initializes the value of the 0th element, &lt;code&gt;'b'&lt;/code&gt; the 1st, and &lt;code&gt;'c'&lt;/code&gt; the 2nd.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7202e21ed0c94540f8855e2b43b5089a13dd9685" translate="yes" xml:space="preserve">
          <source>The number of supplied arguments must exactly match the number of defined type parameters.</source>
          <target state="translated">Количество поставляемых аргументов должно точно соответствовать количеству заданных параметров типа.</target>
        </trans-unit>
        <trans-unit id="1505278c99d9fb45d4f4157fc24b25e9be942498" translate="yes" xml:space="preserve">
          <source>The offset being in bounds cannot rely on &quot;wrapping around&quot; the address space. That is, the infinite-precision sum must fit in a &lt;code&gt;usize&lt;/code&gt;.</source>
          <target state="translated">Смещение, находящееся в границах, не может полагаться на &quot;обертывание&quot; адресного пространства. То есть сумма с бесконечной точностью должна уместиться в &lt;code&gt;usize&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="eb0b1c110f4f91ff6afa42a1772303d08fd7f686" translate="yes" xml:space="preserve">
          <source>The offset being in bounds cannot rely on &quot;wrapping around&quot; the address space. That is, the infinite-precision sum must fit in a usize.</source>
          <target state="translated">Смещение в границах не может полагаться на &quot;обертывание&quot; адресного пространства.То есть,бесконечно точная сумма должна вписываться в размер.</target>
        </trans-unit>
        <trans-unit id="dec85f2a58c1002de0f34de579c15b9ae5dcc5c3" translate="yes" xml:space="preserve">
          <source>The offset being in bounds cannot rely on &quot;wrapping around&quot; the address space. That is, the infinite-precision sum, &lt;strong&gt;in bytes&lt;/strong&gt; must fit in a usize.</source>
          <target state="translated">Смещение, находящееся в границах, не может полагаться на &quot;обертывание&quot; адресного пространства. То есть сумма бесконечной точности &lt;strong&gt;в байтах&lt;/strong&gt; должна соответствовать usize.</target>
        </trans-unit>
        <trans-unit id="b405bb6eb2033937b629bd683503a6e77a48009c" translate="yes" xml:space="preserve">
          <source>The offset is expressed in number of &lt;code&gt;T&lt;/code&gt; elements, and not bytes. The value returned can be used with the &lt;code&gt;offset&lt;/code&gt; or &lt;code&gt;offset_to&lt;/code&gt; methods.</source>
          <target state="translated">Смещение выражается в количестве &lt;code&gt;T&lt;/code&gt; элементов, а не в байтах. Возвращаемое значение можно использовать с методами &lt;code&gt;offset&lt;/code&gt; или &lt;code&gt;offset_to&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="85ba9b2d34ef606ffd767c5e393592519fd3aa95" translate="yes" xml:space="preserve">
          <source>The offset is expressed in number of &lt;code&gt;T&lt;/code&gt; elements, and not bytes. The value returned can be used with the &lt;code&gt;wrapping_add&lt;/code&gt; method.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1be821c2089924c0d18d107c2c27f16675f5ac1c" translate="yes" xml:space="preserve">
          <source>The offset is relative to the start of the file and thus independent from the current cursor.</source>
          <target state="translated">Смещение относительно начала файла и,таким образом,не зависит от текущего курсора.</target>
        </trans-unit>
        <trans-unit id="084e82e27a45f945c98a971924845d2bbfc865a4" translate="yes" xml:space="preserve">
          <source>The offset is relative to the start of the file and thus independent from the current cursor. The current cursor &lt;strong&gt;is&lt;/strong&gt; affected by this function, it is set to the end of the read.</source>
          <target state="translated">Смещение относительно начала файла и, следовательно, не зависит от текущего курсора. Текущий курсор &lt;strong&gt;находится&lt;/strong&gt; зависит от этой функции, она устанавливается в конце чтения.</target>
        </trans-unit>
        <trans-unit id="caf802013d8abd4267e3b977c2a718d4ec2a76b7" translate="yes" xml:space="preserve">
          <source>The offset is relative to the start of the file and thus independent from the current cursor. The current cursor &lt;strong&gt;is&lt;/strong&gt; affected by this function, it is set to the end of the write.</source>
          <target state="translated">Смещение относительно начала файла и, следовательно, не зависит от текущего курсора. Тока Курсор &lt;strong&gt;находится&lt;/strong&gt; зависит от этой функции, она установлена в конце записи.</target>
        </trans-unit>
        <trans-unit id="e661f5d3042445d2052a045a18f9872b66b5bc29" translate="yes" xml:space="preserve">
          <source>The old borrow checker has known soundness issues that are basically impossible to fix. The new NLL-based borrow checker is the fix.</source>
          <target state="translated">Старая проверка заемщиков знает о проблемах со здоровьем,которые в принципе невозможно исправить.Новая проверка заемщиков на основе NLL-это исправление.</target>
        </trans-unit>
        <trans-unit id="ff9f5d5ca24724dc4d44a56e5f4a630aa34c4326" translate="yes" xml:space="preserve">
          <source>The one exception is the implicit &lt;code&gt;Self&lt;/code&gt; type of a trait. A trait does not have an implicit &lt;code&gt;Sized&lt;/code&gt; bound as this is incompatible with &lt;a href=&quot;../../book/ch17-02-trait-objects&quot;&gt;trait object&lt;/a&gt;s where, by definition, the trait needs to work with all possible implementors, and thus could be any size.</source>
          <target state="translated">Единственное исключение - это неявный тип черты &lt;code&gt;Self&lt;/code&gt; . Признак не имеет неявной привязки &lt;code&gt;Sized&lt;/code&gt; ,так как это несовместимо с &lt;a href=&quot;../../book/ch17-02-trait-objects&quot;&gt;объектами признака&lt;/a&gt; s, где, по определению, признак должен работать со всеми возможными разработчиками и, следовательно, может иметь любой размер.</target>
        </trans-unit>
        <trans-unit id="251eb8c6b3ec1dc5000df1aa3f1d9769e8fc67e3" translate="yes" xml:space="preserve">
          <source>The only case where such wrapping can occur is when one divides &lt;code&gt;MIN / -1&lt;/code&gt; on a signed type (where &lt;code&gt;MIN&lt;/code&gt; is the negative minimal value for the type); this is equivalent to &lt;code&gt;-MIN&lt;/code&gt;, a positive value that is too large to represent in the type. In such a case, this function returns &lt;code&gt;MIN&lt;/code&gt; itself.</source>
          <target state="translated">Единственный случай, когда такая упаковка может произойти, - это когда &lt;code&gt;MIN / -1&lt;/code&gt; делится на тип со &lt;code&gt;MIN&lt;/code&gt; (где MIN - отрицательное минимальное значение для типа); это эквивалентно &lt;code&gt;-MIN&lt;/code&gt; , положительному значению, которое слишком велико для представления в типе. В таком случае эта функция сама возвращает &lt;code&gt;MIN&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="76c053c143fda09cee97a50ed7a5afba7b9b021c" translate="yes" xml:space="preserve">
          <source>The only case where such wrapping can occur is when one negates &lt;code&gt;MIN&lt;/code&gt; on a signed type (where &lt;code&gt;MIN&lt;/code&gt; is the negative minimal value for the type); this is a positive value that is too large to represent in the type. In such a case, this function returns &lt;code&gt;MIN&lt;/code&gt; itself.</source>
          <target state="translated">Единственный случай, когда может произойти такое обертывание, - это отрицание &lt;code&gt;MIN&lt;/code&gt; для знакового типа (где &lt;code&gt;MIN&lt;/code&gt; - отрицательное минимальное значение для типа); это положительное значение, слишком большое для представления в типе. В таком случае эта функция сама возвращает &lt;code&gt;MIN&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4f6de3ab26de46b22b8646658bc86041ba8f3d5e" translate="yes" xml:space="preserve">
          <source>The only case where such wrapping can occur is when one takes the absolute value of the negative minimal value for the type this is a positive value that is too large to represent in the type. In such a case, this function returns &lt;code&gt;MIN&lt;/code&gt; itself.</source>
          <target state="translated">Единственный случай, когда может произойти такая упаковка, - это когда для типа берется абсолютное значение отрицательного минимального значения, это положительное значение, которое слишком велико для представления в типе. В таком случае эта функция сама возвращает &lt;code&gt;MIN&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="45d6aabe4740755ea8f6332847150daa44a43b07" translate="yes" xml:space="preserve">
          <source>The only case where such wrapping can occur is when one takes the absolute value of the negative minimal value for the type; this is a positive value that is too large to represent in the type. In such a case, this function returns &lt;code&gt;MIN&lt;/code&gt; itself.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="63e8e964be307b9ddc1a920575e78207b9d44077" translate="yes" xml:space="preserve">
          <source>The only difference between Listing 15-7 and Listing 15-6 is that here we set &lt;code&gt;y&lt;/code&gt; to be an instance of a box pointing to a copied value of &lt;code&gt;x&lt;/code&gt; rather than a reference pointing to the value of &lt;code&gt;x&lt;/code&gt;. In the last assertion, we can use the dereference operator to follow the box&amp;rsquo;s pointer in the same way that we did when &lt;code&gt;y&lt;/code&gt; was a reference. Next, we&amp;rsquo;ll explore what is special about &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; that enables us to use the dereference operator by defining our own box type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="51b5a7f2069f2def348d2148cbc38445c3e27f4c" translate="yes" xml:space="preserve">
          <source>The only difference between Listing 15-7 and Listing 15-6 is that here we set &lt;code&gt;y&lt;/code&gt; to be an instance of a box pointing to the value in &lt;code&gt;x&lt;/code&gt; rather than a reference pointing to the value of &lt;code&gt;x&lt;/code&gt;. In the last assertion, we can use the dereference operator to follow the box&amp;rsquo;s pointer in the same way that we did when &lt;code&gt;y&lt;/code&gt; was a reference. Next, we&amp;rsquo;ll explore what is special about &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; that enables us to use the dereference operator by defining our own box type.</source>
          <target state="translated">Единственное различие между листингом 15-7 и листингом 15-6 состоит в том, что здесь мы устанавливаем &lt;code&gt;y&lt;/code&gt; как экземпляр блока, указывающего на значение в &lt;code&gt;x&lt;/code&gt; , а не как ссылку, указывающую на значение &lt;code&gt;x&lt;/code&gt; . В последнем утверждении мы можем использовать оператор разыменования, чтобы следовать за указателем блока точно так же, как мы это делали, когда &lt;code&gt;y&lt;/code&gt; было ссылкой. Далее мы исследуем особенность &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; которая позволяет нам использовать оператор разыменования путем определения нашего собственного типа бокса.</target>
        </trans-unit>
        <trans-unit id="f7b8368bfb1b8c79cdb7d78152517d184d409bdd" translate="yes" xml:space="preserve">
          <source>The only functions that can be called in static or constant expressions are &lt;code&gt;const&lt;/code&gt; functions, and struct/enum constructors.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aa7a3f715132d2845165ebc499ef1753bb78d047" translate="yes" xml:space="preserve">
          <source>The only functions that can be called in static or constant expressions are &lt;code&gt;const&lt;/code&gt; functions, and struct/enum constructors. &lt;code&gt;const&lt;/code&gt; functions are only available on a nightly compiler. Rust currently does not support more general compile-time function execution.</source>
          <target state="translated">Единственные функции , которые могут быть вызваны в статическом или постоянных выражениях &lt;code&gt;const&lt;/code&gt; функций и структуру / перечислениях конструкторы. Функции &lt;code&gt;const&lt;/code&gt; доступны только в ночном компиляторе. В настоящее время Rust не поддерживает выполнение более общих функций во время компиляции.</target>
        </trans-unit>
        <trans-unit id="f7c42c506a124c9ffe70241d1844e481774b0efe" translate="yes" xml:space="preserve">
          <source>The only lifetime allowed in a constant is &lt;code&gt;'static&lt;/code&gt;, which is the lifetime that encompasses all others in a Rust program. For example, if you wanted to define a constant string, it would look like this:</source>
          <target state="translated">Единственное время жизни, разрешенное в константе, - &lt;code&gt;'static&lt;/code&gt; , то есть время жизни, которое охватывает все остальные в программе на Rust. Например, если вы хотите определить постоянную строку, это будет выглядеть так:</target>
        </trans-unit>
        <trans-unit id="c90e7627a1475de1daf664c395cb8fc220c2a179" translate="yes" xml:space="preserve">
          <source>The operand of a field expression.</source>
          <target state="translated">Операнд полевого выражения.</target>
        </trans-unit>
        <trans-unit id="c815094584bba28655815f7e3484796d5b4ac295" translate="yes" xml:space="preserve">
          <source>The operand of a unary &lt;a href=&quot;expressions/operator-expr#borrow-operators&quot;&gt;borrow&lt;/a&gt; or &lt;a href=&quot;expressions/operator-expr#the-dereference-operator&quot;&gt;dereference&lt;/a&gt; operator.</source>
          <target state="translated">Операнд унарного оператора &lt;a href=&quot;expressions/operator-expr#borrow-operators&quot;&gt;заимствования&lt;/a&gt; или &lt;a href=&quot;expressions/operator-expr#the-dereference-operator&quot;&gt;разыменования&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="cfdf71c707b06cc703ce65b9173f06d5346346a9" translate="yes" xml:space="preserve">
          <source>The operand of an extending &lt;a href=&quot;expressions/operator-expr#borrow-operators&quot;&gt;borrow expression&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="93f114bcdcaebb0db94cec84309f6c6e9289e758" translate="yes" xml:space="preserve">
          <source>The operand of any &lt;a href=&quot;#implicit-borrows&quot;&gt;implicit borrow&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8300616806da6883f068d3a939bb5817283d75af" translate="yes" xml:space="preserve">
          <source>The operand of any &lt;a href=&quot;expressions#implicit-borrows&quot;&gt;implicit borrow&lt;/a&gt;.</source>
          <target state="translated">Операнд любого &lt;a href=&quot;expressions#implicit-borrows&quot;&gt;неявного заимствования&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="13205f7dcdf1bb624db42e4217ccc5c5fe9a6c93" translate="yes" xml:space="preserve">
          <source>The operand of any extending borrow expression has its temporary scope extended.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0018d918b5db8fa5a5c40594da4082243e89b941" translate="yes" xml:space="preserve">
          <source>The operand(s) of an extending &lt;a href=&quot;expressions/array-expr#array-expressions&quot;&gt;array&lt;/a&gt;, &lt;a href=&quot;expressions/operator-expr#type-cast-expressions&quot;&gt;cast&lt;/a&gt;, &lt;a href=&quot;expressions/struct-expr&quot;&gt;braced struct&lt;/a&gt;, or &lt;a href=&quot;expressions/tuple-expr#tuple-expressions&quot;&gt;tuple&lt;/a&gt; expression.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="02413f33b0997a467453e2cc175754042613115c" translate="yes" xml:space="preserve">
          <source>The operation failed because a pipe was closed.</source>
          <target state="translated">Операция провалилась,потому что труба была закрыта.</target>
        </trans-unit>
        <trans-unit id="e0b6b6bb05edcbe700535a8a02fd6257faeb1085" translate="yes" xml:space="preserve">
          <source>The operation lacked the necessary privileges to complete.</source>
          <target state="translated">Операция не имела необходимых для ее завершения привилегий.</target>
        </trans-unit>
        <trans-unit id="d56bd5ac430688946f617fddd5ff8737ea77aabc" translate="yes" xml:space="preserve">
          <source>The operation needs to block to complete, but the blocking operation was requested to not occur.</source>
          <target state="translated">Для завершения операции необходимо было заблокировать,но операция по блокировке не должна была выполняться.</target>
        </trans-unit>
        <trans-unit id="554600e43876fa49fe1808261768a1599008a1a5" translate="yes" xml:space="preserve">
          <source>The operators &lt;code&gt;||&lt;/code&gt; and &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; may be applied to operands of boolean type. The &lt;code&gt;||&lt;/code&gt; operator denotes logical 'or', and the &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; operator denotes logical 'and'. They differ from &lt;code&gt;|&lt;/code&gt; and &lt;code&gt;&amp;amp;&lt;/code&gt; in that the right-hand operand is only evaluated when the left-hand operand does not already determine the result of the expression. That is, &lt;code&gt;||&lt;/code&gt; only evaluates its right-hand operand when the left-hand operand evaluates to &lt;code&gt;false&lt;/code&gt;, and &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; only when it evaluates to &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">Операторы &lt;code&gt;||&lt;/code&gt; и &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; может применяться к операндам логического типа. &lt;code&gt;||&lt;/code&gt; оператор обозначает логическое &amp;laquo;или&amp;raquo;, а оператор &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; обозначает логическое &amp;laquo;и&amp;raquo;. Они отличаются от &lt;code&gt;|&lt;/code&gt; и &lt;code&gt;&amp;amp;&lt;/code&gt; в том, что правый операнд оценивается только тогда, когда левый операнд еще не определяет результат выражения. То есть &lt;code&gt;||&lt;/code&gt; оценивает только свой правый операнд, когда левый операнд оценивается как &lt;code&gt;false&lt;/code&gt; , и &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; только когда он оценивается как &lt;code&gt;true&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="94a90205d7a5e5f5664d5fdcbd09052010d467f6" translate="yes" xml:space="preserve">
          <source>The optional &lt;a href=&quot;https://en.wikipedia.org/wiki/Byte_order_mark#UTF-8&quot;&gt;&lt;em&gt;UTF8 byte order mark&lt;/em&gt;&lt;/a&gt; (UTF8BOM production) indicates that the file is encoded in UTF8. It can only occur at the beginning of the file and is ignored by the compiler.</source>
          <target state="translated">Необязательная &lt;a href=&quot;https://en.wikipedia.org/wiki/Byte_order_mark#UTF-8&quot;&gt;&lt;em&gt;метка порядка байтов UTF8&lt;/em&gt;&lt;/a&gt; (производство UTF8BOM) указывает, что файл закодирован в UTF8. Это может произойти только в начале файла и игнорируется компилятором.</target>
        </trans-unit>
        <trans-unit id="22d7081f01819ecc0a53443b4c5e3e1a4e2c048a" translate="yes" xml:space="preserve">
          <source>The optional fill character and alignment is provided normally in conjunction with the &lt;a href=&quot;#width&quot;&gt;&lt;code&gt;width&lt;/code&gt;&lt;/a&gt; parameter. It must be defined before &lt;code&gt;width&lt;/code&gt;, right after the &lt;code&gt;:&lt;/code&gt;. This indicates that if the value being formatted is smaller than &lt;code&gt;width&lt;/code&gt; some extra characters will be printed around it. Filling comes in the following variants for different alignments:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1ef92817d2fa5638a8f8e4bfed63d30ce997249b" translate="yes" xml:space="preserve">
          <source>The order in which this iterator returns entries is platform and filesystem dependent.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="60297fe01f4f2a21350a894e6ee139ac8e93f1b8" translate="yes" xml:space="preserve">
          <source>The order in which to evaluate the sub-expressions</source>
          <target state="translated">Порядок оценки подвыражений</target>
        </trans-unit>
        <trans-unit id="61bedc7c16635e05c26ee08451d7e761461ef5bb" translate="yes" xml:space="preserve">
          <source>The organizational problem of allocating responsibility for multiple tasks to the &lt;code&gt;main&lt;/code&gt; function is common to many binary projects. As a result, the Rust community has developed a process to use as a guideline for splitting the separate concerns of a binary program when &lt;code&gt;main&lt;/code&gt; starts getting large. The process has the following steps:</source>
          <target state="translated">Организационная проблема распределения ответственности за несколько задач между &lt;code&gt;main&lt;/code&gt; функцией является общей для многих бинарных проектов. В результате сообщество Rust разработало процесс, который можно использовать в качестве руководства для разделения отдельных задач двоичной программы, когда &lt;code&gt;main&lt;/code&gt; начинает увеличиваться. Процесс состоит из следующих этапов:</target>
        </trans-unit>
        <trans-unit id="41be0c260fec224b2719e05df384f73991bede1b" translate="yes" xml:space="preserve">
          <source>The other arm of the &lt;code&gt;match&lt;/code&gt; handles the case where we get an &lt;code&gt;Err&lt;/code&gt; value from &lt;code&gt;File::open&lt;/code&gt;. In this example, we&amp;rsquo;ve chosen to call the &lt;code&gt;panic!&lt;/code&gt; macro. If there&amp;rsquo;s no file named &lt;em&gt;hello.txt&lt;/em&gt; in our current directory and we run this code, we&amp;rsquo;ll see the following output from the &lt;code&gt;panic!&lt;/code&gt; macro:</source>
          <target state="translated">Другая часть &lt;code&gt;match&lt;/code&gt; обрабатывает случай, когда мы получаем значение &lt;code&gt;Err&lt;/code&gt; из &lt;code&gt;File::open&lt;/code&gt; . В этом примере мы решили вызвать &lt;code&gt;panic!&lt;/code&gt; макрос. Если в нашем текущем каталоге нет файла с именем &lt;em&gt;hello.txt&lt;/em&gt; и мы запустим этот код, мы увидим следующий результат &lt;code&gt;panic!&lt;/code&gt; макрос:</target>
        </trans-unit>
        <trans-unit id="a7bf4938ef9d644fa6590a14199d49f21d906882" translate="yes" xml:space="preserve">
          <source>The other difference between &lt;code&gt;mut&lt;/code&gt; and shadowing is that because we&amp;rsquo;re effectively creating a new variable when we use the &lt;code&gt;let&lt;/code&gt; keyword again, we can change the type of the value but reuse the same name. For example, say our program asks a user to show how many spaces they want between some text by inputting space characters, but we really want to store that input as a number:</source>
          <target state="translated">Другое различие между &lt;code&gt;mut&lt;/code&gt; и shadowing заключается в том, что, поскольку мы эффективно создаем новую переменную, когда снова используем ключевое слово &lt;code&gt;let&lt;/code&gt; , мы можем изменить тип значения, но повторно использовать то же имя. Например, скажем, наша программа просит пользователя показать, сколько пробелов они хотят между некоторым текстом, вводя символы пробела, но мы действительно хотим сохранить этот ввод как число:</target>
        </trans-unit>
        <trans-unit id="df7669a1bf85d9740015e4131e57d2cd1eb9d9d3" translate="yes" xml:space="preserve">
          <source>The other main use of the &lt;code&gt;const&lt;/code&gt; keyword is in &lt;code&gt;const fn&lt;/code&gt;. This marks a function as being callable in the body of a &lt;code&gt;const&lt;/code&gt; or &lt;code&gt;static&lt;/code&gt; item and in array initializers (commonly called &quot;const contexts&quot;). &lt;code&gt;const fn&lt;/code&gt; are restricted in the set of operations they can perform, to ensure that they can be evaluated at compile-time. See the &lt;a href=&quot;../reference/const_eval&quot;&gt;Reference&lt;/a&gt; for more detail.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a27877809931e30e4d816c929aaf44550dc13948" translate="yes" xml:space="preserve">
          <source>The other option is to decide that pinning is &quot;structural&quot; for &lt;code&gt;field&lt;/code&gt;, meaning that if the struct is pinned then so is the field.</source>
          <target state="translated">Другой вариант - решить, что закрепление является &amp;laquo;структурным&amp;raquo; для &lt;code&gt;field&lt;/code&gt; , что означает, что если структура закреплена, то и поле будет закреплено.</target>
        </trans-unit>
        <trans-unit id="0642ecd58583a2694ae6dacfe0a415f63c694440" translate="yes" xml:space="preserve">
          <source>The other reason to use inheritance relates to the type system: to enable a child type to be used in the same places as the parent type. This is also called &lt;em&gt;polymorphism&lt;/em&gt;, which means that you can substitute multiple objects for each other at runtime if they share certain characteristics.</source>
          <target state="translated">Другая причина использования наследования связана с системой типов: чтобы разрешить использование дочернего типа в тех же местах, что и родительский тип. Это также называется &lt;em&gt;полиморфизмом&lt;/em&gt; , что означает, что вы можете заменять друг друга несколькими объектами во время выполнения, если они имеют определенные характеристики.</target>
        </trans-unit>
        <trans-unit id="89dc389d4ca8b1b17999395cda6f46045ddfd179" translate="yes" xml:space="preserve">
          <source>The other use of the &lt;code&gt;impl&lt;/code&gt; keyword is in &lt;code&gt;impl Trait&lt;/code&gt; syntax, which can be seen as a shorthand for &quot;a concrete type that implements this trait&quot;. Its primary use is working with closures, which have type definitions generated at compile time that can't be simply typed out.</source>
          <target state="translated">Другое использование &lt;code&gt;impl&lt;/code&gt; слова impl - &lt;code&gt;impl Trait&lt;/code&gt; синтаксис impl Trait , который можно рассматривать как сокращение для &amp;laquo;конкретного типа, реализующего эту черту&amp;raquo;. Его основное использование - работа с замыканиями, определения типов которых генерируются во время компиляции, которые нельзя просто ввести.</target>
        </trans-unit>
        <trans-unit id="5fa7bdd2f67d8992d16557677350c79fe148aa6f" translate="yes" xml:space="preserve">
          <source>The other way to solve this error is to make the private type public. Example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="69b16008db0e7fefb3576376fa59c7cdb24bc4ca" translate="yes" xml:space="preserve">
          <source>The outer scope declares a variable named &lt;code&gt;r&lt;/code&gt; with no initial value, and the inner scope declares a variable named &lt;code&gt;x&lt;/code&gt; with the initial value of 5. Inside the inner scope, we attempt to set the value of &lt;code&gt;r&lt;/code&gt; as a reference to &lt;code&gt;x&lt;/code&gt;. Then the inner scope ends, and we attempt to print the value in &lt;code&gt;r&lt;/code&gt;. This code won&amp;rsquo;t compile because the value &lt;code&gt;r&lt;/code&gt; is referring to has gone out of scope before we try to use it. Here is the error message:</source>
          <target state="translated">Внешняя область объявляет переменную с именем &lt;code&gt;r&lt;/code&gt; без начального значения, а внутренняя область объявляет переменную с именем &lt;code&gt;x&lt;/code&gt; с начальным значением 5. Внутри внутренней области мы пытаемся установить значение &lt;code&gt;r&lt;/code&gt; как ссылку на &lt;code&gt;x&lt;/code&gt; . Затем внутренняя область видимости заканчивается, и мы пытаемся вывести значение в &lt;code&gt;r&lt;/code&gt; . Этот код не будет компилироваться, потому что значение &lt;code&gt;r&lt;/code&gt; ,на которое ссылается, вышло из области видимости, прежде чем мы попытаемся его использовать. Вот сообщение об ошибке:</target>
        </trans-unit>
        <trans-unit id="ee4813584901b6edf7255c9100533eb924eb1e04" translate="yes" xml:space="preserve">
          <source>The output of a finished process.</source>
          <target state="translated">Вывод готового процесса.</target>
        </trans-unit>
        <trans-unit id="7091d6ad7f032d028b64c465cb0226168ae0e89e" translate="yes" xml:space="preserve">
          <source>The output of this function should not be used in anything that might have security implications. For example:</source>
          <target state="translated">Вывод этой функции не должен использоваться ни в чем,что может иметь последствия для безопасности.Например:</target>
        </trans-unit>
        <trans-unit id="c978821bc364ab92333f8a77fd4cf50814193dc4" translate="yes" xml:space="preserve">
          <source>The output that the future will produce on completion.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4e5a226f1cb2eaa0ff96072c4caeb2fee856332d" translate="yes" xml:space="preserve">
          <source>The output type returned by methods.</source>
          <target state="translated">Тип выхода,возвращаемый методами.</target>
        </trans-unit>
        <trans-unit id="b3fedfd8280044a357b6d9f266e6194249a97d9a" translate="yes" xml:space="preserve">
          <source>The output will be the recommended workout plan. Listing 13-2 shows the &lt;code&gt;main&lt;/code&gt; function we&amp;rsquo;ll use.</source>
          <target state="translated">Результатом будет рекомендованный план тренировки. В листинге 13-2 показана &lt;code&gt;main&lt;/code&gt; функция, которую мы будем использовать.</target>
        </trans-unit>
        <trans-unit id="884c1b47c0faf2e5f38e29c6c1a9622d7629d70c" translate="yes" xml:space="preserve">
          <source>The overall goal of these requirements is to let the consumer of a pipeline use</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c750221db5bde24f0432e5395fa0e7d6b2249e8f" translate="yes" xml:space="preserve">
          <source>The ownership of &lt;code&gt;buf&lt;/code&gt; is effectively transferred to the &lt;code&gt;String&lt;/code&gt; which may then deallocate, reallocate or change the contents of memory pointed to by the pointer at will. Ensure that nothing else uses the pointer after calling this function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b39c88ef6b933b61e4ea4a039f34870326ac716b" translate="yes" xml:space="preserve">
          <source>The ownership of &lt;code&gt;ptr&lt;/code&gt; is effectively transferred to the &lt;code&gt;String&lt;/code&gt; which may then deallocate, reallocate or change the contents of memory pointed to by the pointer at will. Ensure that nothing else uses the pointer after calling this function.</source>
          <target state="translated">Право собственности на &lt;code&gt;ptr&lt;/code&gt; эффективно передается &lt;code&gt;String&lt;/code&gt; , которая затем может освобождать, перераспределять или изменять содержимое памяти, на которое указывает указатель, по желанию. После вызова этой функции убедитесь, что указатель больше не используется.</target>
        </trans-unit>
        <trans-unit id="0c5ac2aeb05d71a34b822c034365a66e97f5d90e" translate="yes" xml:space="preserve">
          <source>The ownership of &lt;code&gt;ptr&lt;/code&gt; is effectively transferred to the &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; which may then deallocate, reallocate or change the contents of memory pointed to by the pointer at will. Ensure that nothing else uses the pointer after calling this function.</source>
          <target state="translated">Право собственности на &lt;code&gt;ptr&lt;/code&gt; эффективно передается &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; который затем может освобождать, перераспределять или изменять содержимое памяти, на которое указывает указатель, по желанию. После вызова этой функции убедитесь, что указатель больше не используется.</target>
        </trans-unit>
        <trans-unit id="459d615a7b443b2b18398d7b4e4094d21aa9904a" translate="yes" xml:space="preserve">
          <source>The ownership of a variable follows the same pattern every time: assigning a value to another variable moves it. When a variable that includes data on the heap goes out of scope, the value will be cleaned up by &lt;code&gt;drop&lt;/code&gt; unless the data has been moved to be owned by another variable.</source>
          <target state="translated">Владение переменной каждый раз следует одному и тому же шаблону: присвоение значения другой переменной перемещает ее. Когда переменная, содержащая данные в куче, выходит за пределы области видимости, значение будет очищено путем &lt;code&gt;drop&lt;/code&gt; если только данные не были перемещены в другую переменную.</target>
        </trans-unit>
        <trans-unit id="8158170312c35ad0b4ff632e830474174c9789f6" translate="yes" xml:space="preserve">
          <source>The ownership rules play a vital role in message sending because they help you write safe, concurrent code. Preventing errors in concurrent programming is the advantage of thinking about ownership throughout your Rust programs. Let&amp;rsquo;s do an experiment to show how channels and ownership work together to prevent problems: we&amp;rsquo;ll try to use a &lt;code&gt;val&lt;/code&gt; value in the spawned thread &lt;em&gt;after&lt;/em&gt; we&amp;rsquo;ve sent it down the channel. Try compiling the code in Listing 16-9 to see why this code isn&amp;rsquo;t allowed:</source>
          <target state="translated">Правила владения играют жизненно важную роль в отправке сообщений, потому что они помогают писать безопасный параллельный код. Предотвращение ошибок в параллельном программировании - преимущество размышлений о праве собственности во всех программах на Rust. Давайте проведем эксперимент, чтобы показать, как каналы и владение работают вместе, чтобы предотвратить проблемы: мы попробуем использовать значение &lt;code&gt;val&lt;/code&gt; в порожденном потоке &lt;em&gt;после&lt;/em&gt; того, &lt;em&gt;как&lt;/em&gt; мы отправим его по каналу. Попробуйте скомпилировать код из листинга 16-9, чтобы понять, почему этот код не разрешен:</target>
        </trans-unit>
        <trans-unit id="58f56a016b810f8287c744364955b1ffc32f9240" translate="yes" xml:space="preserve">
          <source>The panic hook is a global resource.</source>
          <target state="translated">Крючок паники-это глобальный ресурс.</target>
        </trans-unit>
        <trans-unit id="684aef30b999855f4bf1399a43d22fd82b7e6c9d" translate="yes" xml:space="preserve">
          <source>The panic hook is invoked when a thread panics, but before the panic runtime is invoked. As such, the hook will run with both the aborting and unwinding runtimes. The default hook prints a message to standard error and generates a backtrace if requested, but this behavior can be customized with the &lt;code&gt;set_hook&lt;/code&gt; and &lt;a href=&quot;fn.take_hook&quot;&gt;&lt;code&gt;take_hook&lt;/code&gt;&lt;/a&gt; functions.</source>
          <target state="translated">Ловушка паники вызывается при панике потока, но до вызова среды выполнения паники. Таким образом, обработчик будет работать как с прерыванием, так и со средой выполнения. Хук по умолчанию выводит сообщение об ошибке и генерирует обратную трассировку, если требуется, но это поведение можно настроить с помощью &lt;code&gt;set_hook&lt;/code&gt; и &lt;a href=&quot;fn.take_hook&quot;&gt; &lt;code&gt;take_hook&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="563c97e45aeee516b45222324d4cc368e8c084ba" translate="yes" xml:space="preserve">
          <source>The parameters given to &lt;code&gt;Layout::from_size_align&lt;/code&gt; or some other &lt;code&gt;Layout&lt;/code&gt; constructor do not satisfy its documented constraints.</source>
          <target state="translated">Параметры, передаваемые &lt;code&gt;Layout::from_size_align&lt;/code&gt; или другому конструктору &lt;code&gt;Layout&lt;/code&gt; , не удовлетворяют его задокументированным ограничениям.</target>
        </trans-unit>
        <trans-unit id="3c2a54faaf19386dc2b06158bf3003e146fc0f45" translate="yes" xml:space="preserve">
          <source>The parameters of any trait method must match between a trait implementation and the trait definition.</source>
          <target state="translated">Параметры любого метода трейта должны совпадать между реализацией трейта и его определением.</target>
        </trans-unit>
        <trans-unit id="df3b8f99f35d92ad550b740bf7dc9171d35b97ed" translate="yes" xml:space="preserve">
          <source>The parent of a statement scope is the scope of the block that contains the statement.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c46091b9f972d668faf65caa23b2e09a8a170568" translate="yes" xml:space="preserve">
          <source>The parent of all other scopes is the scope of the immediately enclosing expression.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e04065a98d4b38354b6e3e4d4abb130f6c621783" translate="yes" xml:space="preserve">
          <source>The parent of the arm scope is the scope of the &lt;code&gt;match&lt;/code&gt; expression that it belongs to.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="09a327800a21f08b5d4e1948e88aac172c2121be" translate="yes" xml:space="preserve">
          <source>The parent of the current &lt;a href=&quot;../reference/items/modules&quot;&gt;module&lt;/a&gt;.</source>
          <target state="translated">Родитель текущего &lt;a href=&quot;../reference/items/modules&quot;&gt;модуля&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="529eb4e30d49293a9076afc4b5e1cde599b49562" translate="yes" xml:space="preserve">
          <source>The parent of the expression after the &lt;code&gt;=&amp;gt;&lt;/code&gt; in a &lt;code&gt;match&lt;/code&gt; expression is the scope of the arm that it's in.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7bf69b726f2264b18f25a14f0c4351943f8d4d50" translate="yes" xml:space="preserve">
          <source>The parent of the expression for a &lt;code&gt;match&lt;/code&gt; guard is the scope of the arm that the guard is for.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="10e7154b1118c2abd23aedcc36e2f4febf44487b" translate="yes" xml:space="preserve">
          <source>The parent of the expression in an expression statement is the scope of the statement.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bf1edfebb91e8c5be33d3f8d00037717971d53a2" translate="yes" xml:space="preserve">
          <source>The parent of the initializer of a &lt;a href=&quot;statements#let-statements&quot;&gt;&lt;code&gt;let&lt;/code&gt; statement&lt;/a&gt; is the &lt;code&gt;let&lt;/code&gt; statement's scope.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f7896dc490ba78587890c7c602aaea52ff1e61a5" translate="yes" xml:space="preserve">
          <source>The parent thread can also wait on the completion of the child thread; a call to &lt;a href=&quot;fn.spawn&quot;&gt;&lt;code&gt;spawn&lt;/code&gt;&lt;/a&gt; produces a &lt;a href=&quot;struct.joinhandle&quot;&gt;&lt;code&gt;JoinHandle&lt;/code&gt;&lt;/a&gt;, which provides a &lt;code&gt;join&lt;/code&gt; method for waiting:</source>
          <target state="translated">Родительский поток также может ждать завершения дочернего потока; вызов &lt;a href=&quot;fn.spawn&quot;&gt; &lt;code&gt;spawn&lt;/code&gt; &lt;/a&gt; производит &lt;a href=&quot;struct.joinhandle&quot;&gt; &lt;code&gt;JoinHandle&lt;/code&gt; &lt;/a&gt; , который предоставляет метод &lt;code&gt;join&lt;/code&gt; для ожидания:</target>
        </trans-unit>
        <trans-unit id="46e80e0e5a125dc6b093687f5b3dfa680a2d94d7" translate="yes" xml:space="preserve">
          <source>The parenthesized &lt;code&gt;inline&lt;/code&gt; attribute requires the parameter to be specified:</source>
          <target state="translated">&lt;code&gt;inline&lt;/code&gt; атрибут в скобках требует, чтобы параметр был указан:</target>
        </trans-unit>
        <trans-unit id="15c1964228f17e3bf48dc3c0a27f630dfed2aef1" translate="yes" xml:space="preserve">
          <source>The parenthesized &lt;code&gt;instruction_set&lt;/code&gt; attribute requires the parameter to be specified:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d2172d9db47abf995cf78b6d1056e43a62f663b4" translate="yes" xml:space="preserve">
          <source>The parser used by the macro system is reasonably powerful, but it is limited in order to prevent ambiguity in current or future versions of the language. In particular, in addition to the rule about ambiguous expansions, a nonterminal matched by a metavariable must be followed by a token which has been decided can be safely used after that kind of match.</source>
          <target state="translated">Синтаксический анализатор,используемый в системе макросов,достаточно мощный,но он ограничен для того,чтобы предотвратить неоднозначность в текущей или будущих версиях языка.В частности,в дополнение к правилу о неоднозначных расширениях,за нетерминалом,совпадающим с метапеременной,должен следовать токен,решение о котором может быть безопасно использовано после такого совпадения.</target>
        </trans-unit>
        <trans-unit id="72524139620fe5680057ec138f1bc4009c442555" translate="yes" xml:space="preserve">
          <source>The path prefix for modules is the canonical path to that module. For bare implementations, it is the canonical path of the item being implemented surrounded by angle (&lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt;) brackets. For &lt;a href=&quot;items/implementations#trait-implementations&quot;&gt;trait implementations&lt;/a&gt;, it is the canonical path of the item being implemented followed by &lt;code&gt;as&lt;/code&gt; followed by the canonical path to the trait all surrounded in angle (&lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt;) brackets.</source>
          <target state="translated">Префикс пути для модулей - это канонический путь к этому модулю. Для простых реализаций это канонический путь реализуемого элемента, заключенный в угловые скобки ( &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; ). Для &lt;a href=&quot;items/implementations#trait-implementations&quot;&gt;признака реализаций&lt;/a&gt; , это канонический путь элемента реализуется затем , &lt;code&gt;as&lt;/code&gt; следует каноническому пути к черту все окруженного под углом ( &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; ) скобки.</target>
        </trans-unit>
        <trans-unit id="c6a4fb9e71adbfcd1bb4598c90adf218d993dcba" translate="yes" xml:space="preserve">
          <source>The path to the associated items is &lt;code&gt;&amp;lt;&lt;/code&gt; followed by a path to the implementing type followed by &lt;code&gt;as&lt;/code&gt; followed by a path to the trait followed by &lt;code&gt;&amp;gt;&lt;/code&gt; as a path component followed by the associated item's path component.</source>
          <target state="translated">Путь к ассоциированным элементам является &lt;code&gt;&amp;lt;&lt;/code&gt; следует пути к типу , реализующему с последующим , &lt;code&gt;as&lt;/code&gt; следует путь к черте с последующим &lt;code&gt;&amp;gt;&lt;/code&gt; в качестве компонента пути следует компонент пути ассоциированного элемента.</target>
        </trans-unit>
        <trans-unit id="e791bfe4c14128fe94a9448b536323c040235679" translate="yes" xml:space="preserve">
          <source>The pattern can be a &lt;a href=&quot;../char/index&quot;&gt;&lt;code&gt;char&lt;/code&gt;&lt;/a&gt; or a closure that determines if a character matches.</source>
          <target state="translated">Шаблон может быть &lt;a href=&quot;../char/index&quot;&gt; &lt;code&gt;char&lt;/code&gt; &lt;/a&gt; или закрытием, определяющим совпадение символа.</target>
        </trans-unit>
        <trans-unit id="9b997b2f72267455f266b90593be72c411299620" translate="yes" xml:space="preserve">
          <source>The pattern can be a &lt;a href=&quot;char/index&quot;&gt;&lt;code&gt;char&lt;/code&gt;&lt;/a&gt; or a closure that determines if a character matches.</source>
          <target state="translated">Шаблон может быть &lt;a href=&quot;char/index&quot;&gt; &lt;code&gt;char&lt;/code&gt; &lt;/a&gt; или закрытием, определяющим совпадение символа.</target>
        </trans-unit>
        <trans-unit id="d7a545179141a5b3642800fa8e44597af1f79a17" translate="yes" xml:space="preserve">
          <source>The pattern can be a &lt;code&gt;&amp;amp;str&lt;/code&gt;, &lt;a href=&quot;../char/index&quot;&gt;&lt;code&gt;char&lt;/code&gt;&lt;/a&gt;, or a closure that determines if a character matches.</source>
          <target state="translated">Шаблон может быть &lt;code&gt;&amp;amp;str&lt;/code&gt; , &lt;a href=&quot;../char/index&quot;&gt; &lt;code&gt;char&lt;/code&gt; &lt;/a&gt; или закрытием, определяющим совпадение символа.</target>
        </trans-unit>
        <trans-unit id="eab1bd44108e3c6ec8d1d8c6acc9fac3b5f45a9e" translate="yes" xml:space="preserve">
          <source>The pattern can be a &lt;code&gt;&amp;amp;str&lt;/code&gt;, &lt;a href=&quot;char/index&quot;&gt;&lt;code&gt;char&lt;/code&gt;&lt;/a&gt;, or a closure that determines if a character matches.</source>
          <target state="translated">Шаблон может быть &lt;code&gt;&amp;amp;str&lt;/code&gt; , &lt;a href=&quot;char/index&quot;&gt; &lt;code&gt;char&lt;/code&gt; &lt;/a&gt; или закрытием, определяющим совпадение символа.</target>
        </trans-unit>
        <trans-unit id="b3313c804137756973c3dae6df1f5d957a288624" translate="yes" xml:space="preserve">
          <source>The pattern can be a &lt;code&gt;&amp;amp;str&lt;/code&gt;, &lt;a href=&quot;primitive.char&quot;&gt;&lt;code&gt;char&lt;/code&gt;&lt;/a&gt;, or a closure that determines if a character matches.</source>
          <target state="translated">Шаблон может быть &lt;code&gt;&amp;amp;str&lt;/code&gt; , &lt;a href=&quot;primitive.char&quot;&gt; &lt;code&gt;char&lt;/code&gt; &lt;/a&gt; или закрытием, определяющим совпадение символа.</target>
        </trans-unit>
        <trans-unit id="bfcc6e07c89f929bc9a9b9157ac58712686768e0" translate="yes" xml:space="preserve">
          <source>The pattern can be any type that implements the Pattern trait. Notable examples are &lt;code&gt;&amp;amp;str&lt;/code&gt;, &lt;a href=&quot;../char/index&quot;&gt;&lt;code&gt;char&lt;/code&gt;&lt;/a&gt;, and closures that determines the split.</source>
          <target state="translated">Шаблон может быть любого типа, реализующего свойство Pattern. Яркими примерами являются &lt;code&gt;&amp;amp;str&lt;/code&gt; , &lt;a href=&quot;../char/index&quot;&gt; &lt;code&gt;char&lt;/code&gt; &lt;/a&gt; и замыкания, определяющие разделение.</target>
        </trans-unit>
        <trans-unit id="eb766e07c7ab39fe3b62bc217205480afe2f8cd2" translate="yes" xml:space="preserve">
          <source>The pattern can be any type that implements the Pattern trait. Notable examples are &lt;code&gt;&amp;amp;str&lt;/code&gt;, &lt;a href=&quot;../char/index&quot;&gt;&lt;code&gt;char&lt;/code&gt;&lt;/a&gt;, and closures that determines the split. Additional libraries might provide more complex patterns like regular expressions.</source>
          <target state="translated">Шаблон может быть любого типа, реализующего свойство Pattern. Яркими примерами являются &lt;code&gt;&amp;amp;str&lt;/code&gt; , &lt;a href=&quot;../char/index&quot;&gt; &lt;code&gt;char&lt;/code&gt; &lt;/a&gt; и замыкания, определяющие разделение. Дополнительные библиотеки могут предоставлять более сложные шаблоны, такие как регулярные выражения.</target>
        </trans-unit>
        <trans-unit id="53665fb10463c2a5a8c8a6c23b4c3d2013b572a7" translate="yes" xml:space="preserve">
          <source>The pattern can be any type that implements the Pattern trait. Notable examples are &lt;code&gt;&amp;amp;str&lt;/code&gt;, &lt;a href=&quot;char/index&quot;&gt;&lt;code&gt;char&lt;/code&gt;&lt;/a&gt;, and closures that determines the split.</source>
          <target state="translated">Шаблон может быть любого типа, реализующего свойство Pattern. Яркими примерами являются &lt;code&gt;&amp;amp;str&lt;/code&gt; , &lt;a href=&quot;char/index&quot;&gt; &lt;code&gt;char&lt;/code&gt; &lt;/a&gt; и замыкания, определяющие разделение.</target>
        </trans-unit>
        <trans-unit id="8059c918e0a15a39f2f09be5faf1d4cb011e74e6" translate="yes" xml:space="preserve">
          <source>The pattern can be any type that implements the Pattern trait. Notable examples are &lt;code&gt;&amp;amp;str&lt;/code&gt;, &lt;a href=&quot;char/index&quot;&gt;&lt;code&gt;char&lt;/code&gt;&lt;/a&gt;, and closures that determines the split. Additional libraries might provide more complex patterns like regular expressions.</source>
          <target state="translated">Шаблон может быть любого типа, реализующего свойство Pattern. Яркими примерами являются &lt;code&gt;&amp;amp;str&lt;/code&gt; , &lt;a href=&quot;char/index&quot;&gt; &lt;code&gt;char&lt;/code&gt; &lt;/a&gt; и замыкания, определяющие разделение. Дополнительные библиотеки могут предоставлять более сложные шаблоны, такие как регулярные выражения.</target>
        </trans-unit>
        <trans-unit id="70fe7a4be65487325b69a6e9166bdb513323e0b5" translate="yes" xml:space="preserve">
          <source>The pattern in the following example does four things:</source>
          <target state="translated">Узор в следующем примере делает четыре вещи:</target>
        </trans-unit>
        <trans-unit id="5a181811e45dbf2fc9dddcbe8e2017ec7127d78e" translate="yes" xml:space="preserve">
          <source>The pattern in the second match arm introduces a new variable named &lt;code&gt;y&lt;/code&gt; that will match any value inside a &lt;code&gt;Some&lt;/code&gt; value. Because we&amp;rsquo;re in a new scope inside the &lt;code&gt;match&lt;/code&gt; expression, this is a new &lt;code&gt;y&lt;/code&gt; variable, not the &lt;code&gt;y&lt;/code&gt; we declared at the beginning with the value 10. This new &lt;code&gt;y&lt;/code&gt; binding will match any value inside a &lt;code&gt;Some&lt;/code&gt;, which is what we have in &lt;code&gt;x&lt;/code&gt;. Therefore, this new &lt;code&gt;y&lt;/code&gt; binds to the inner value of the &lt;code&gt;Some&lt;/code&gt; in &lt;code&gt;x&lt;/code&gt;. That value is &lt;code&gt;5&lt;/code&gt;, so the expression for that arm executes and prints &lt;code&gt;Matched, y = 5&lt;/code&gt;.</source>
          <target state="translated">Шаблон во второй ветви соответствия вводит новую переменную с именем &lt;code&gt;y&lt;/code&gt; , которая будет соответствовать любому значению внутри значения &lt;code&gt;Some&lt;/code&gt; . Поскольку внутри выражения &lt;code&gt;match&lt;/code&gt; мы находимся в новой области видимости , это новая переменная &lt;code&gt;y&lt;/code&gt; , а не &lt;code&gt;y&lt;/code&gt; ,который мы объявили в начале со значением 10. Эта новая привязка &lt;code&gt;y&lt;/code&gt; будет соответствовать любому значению внутри &lt;code&gt;Some&lt;/code&gt; , что у нас есть в &lt;code&gt;x&lt;/code&gt; . Следовательно, этот новый &lt;code&gt;y&lt;/code&gt; привязывается к внутреннему значению &lt;code&gt;Some&lt;/code&gt; в &lt;code&gt;x&lt;/code&gt; . Это значение равно &lt;code&gt;5&lt;/code&gt; , поэтому выражение для этой руки выполняется и выводит &lt;code&gt;Matched, y = 5&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="fd1b310fb5c60706a33dc63407dcff2f0de81ecd" translate="yes" xml:space="preserve">
          <source>The pattern is most commonly a single variable, which means no pattern matching is done and the expression given is bound to the variable. Apart from that, patterns used in &lt;code&gt;let&lt;/code&gt; bindings can be as complicated as needed, given that the pattern is exhaustive. See the &lt;a href=&quot;../book/ch06-02-match&quot;&gt;Rust book&lt;/a&gt; for more information on pattern matching. The type of the pattern is optionally given afterwards, but if left blank is automatically inferred by the compiler if possible.</source>
          <target state="translated">Чаще всего шаблон представляет собой единственную переменную, что означает, что сопоставление с шаблоном не выполняется и данное выражение привязано к переменной. Кроме того, шаблоны, используемые в привязках &lt;code&gt;let&lt;/code&gt; , могут быть настолько сложными, насколько это необходимо, учитывая, что шаблон является исчерпывающим. См. &lt;a href=&quot;../book/ch06-02-match&quot;&gt;Книгу Rust&lt;/a&gt; для получения дополнительной информации о сопоставлении с образцом. Тип шаблона необязательно указывается позже, но, если он оставлен пустым, по возможности автоматически определяется компилятором.</target>
        </trans-unit>
        <trans-unit id="c2459ac3b35f7ffa8e048896d3c16ca10cfe1608" translate="yes" xml:space="preserve">
          <source>The pattern of the first arm in the &lt;code&gt;match&lt;/code&gt; expression matches a &lt;code&gt;Message::ChangeColor&lt;/code&gt; enum variant that contains a &lt;code&gt;Color::Rgb&lt;/code&gt; variant; then the pattern binds to the three inner &lt;code&gt;i32&lt;/code&gt; values. The pattern of the second arm also matches a &lt;code&gt;Message::ChangeColor&lt;/code&gt; enum variant, but the inner enum matches the &lt;code&gt;Color::Hsv&lt;/code&gt; variant instead. We can specify these complex conditions in one &lt;code&gt;match&lt;/code&gt; expression, even though two enums are involved.</source>
          <target state="translated">Рисунок первого плеча в &lt;code&gt;match&lt;/code&gt; выражении соответствует &lt;code&gt;Message::ChangeColor&lt;/code&gt; перечисления вариант , который содержит &lt;code&gt;Color::Rgb&lt;/code&gt; вариант; затем шаблон привязывается к трем внутренним значениям &lt;code&gt;i32&lt;/code&gt; . Образец второй &lt;code&gt;Message::ChangeColor&lt;/code&gt; также соответствует варианту перечисления Message :: ChangeColor , но вместо этого внутреннее перечисление соответствует варианту &lt;code&gt;Color::Hsv&lt;/code&gt; . Мы можем определить эти сложные условия в одном &lt;code&gt;match&lt;/code&gt; выражения, даже если два перечислений участвуют.</target>
        </trans-unit>
        <trans-unit id="a42d62f0f2bbc370e10f35406b8b10d13fb51143" translate="yes" xml:space="preserve">
          <source>The patterns programmed into Rust&amp;rsquo;s analysis of references are called the &lt;em&gt;lifetime elision rules&lt;/em&gt;. These aren&amp;rsquo;t rules for programmers to follow; they&amp;rsquo;re a set of particular cases that the compiler will consider, and if your code fits these cases, you don&amp;rsquo;t need to write the lifetimes explicitly.</source>
          <target state="translated">Шаблоны, запрограммированные в анализе ссылок в Rust, называются &lt;em&gt;правилами исключения&lt;/em&gt; времени &lt;em&gt;жизни&lt;/em&gt; . Это не правила, которым должны следовать программисты; они представляют собой набор частных случаев, которые компилятор рассмотрит, и если ваш код соответствует этим случаям, вам не нужно явно указывать время жизни.</target>
        </trans-unit>
        <trans-unit id="012a0566d4550e7174697625c83965140d98cc31" translate="yes" xml:space="preserve">
          <source>The peer address may be set by the &lt;code&gt;connect&lt;/code&gt; method, and this method will return an error if the socket has not already been connected.</source>
          <target state="translated">Адрес однорангового узла может быть установлен методом &lt;code&gt;connect&lt;/code&gt; , и этот метод вернет ошибку, если сокет еще не был подключен.</target>
        </trans-unit>
        <trans-unit id="c7338ebe0eb2e257ec72f81d23df2b1d8ecc7ce7" translate="yes" xml:space="preserve">
          <source>The performance of these two features (Spoiler alert: they&amp;rsquo;re faster than you might think!)</source>
          <target state="translated">Производительность этих двух функций (предупреждение о спойлере: они быстрее, чем вы думаете!)</target>
        </trans-unit>
        <trans-unit id="b42828007b197505190540700b376ffcea8793e7" translate="yes" xml:space="preserve">
          <source>The pointer is valid only if there are some strong references. The pointer may be dangling, unaligned or even &lt;a href=&quot;../ptr/fn.null&quot;&gt;&lt;code&gt;null&lt;/code&gt;&lt;/a&gt; otherwise.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3c13daf063b9e605b83028dc0feae2167ff80511" translate="yes" xml:space="preserve">
          <source>The pointer may be &lt;a href=&quot;../ptr/fn.null&quot;&gt;&lt;code&gt;null&lt;/code&gt;&lt;/a&gt; or be dangling in case the object has already been destroyed.</source>
          <target state="translated">Указатель может быть &lt;a href=&quot;../ptr/fn.null&quot;&gt; &lt;code&gt;null&lt;/code&gt; &lt;/a&gt; или болтаться, если объект уже был уничтожен.</target>
        </trans-unit>
        <trans-unit id="c51f7cfe5691f3edc0397a76000e0e31815c58dc" translate="yes" xml:space="preserve">
          <source>The pointer must be &lt;a href=&quot;index#safety&quot;&gt;valid&lt;/a&gt; for reads and writes for &lt;code&gt;ptr.len() * mem::size_of::&amp;lt;T&amp;gt;()&lt;/code&gt; many bytes, and it must be properly aligned. This means in particular:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2d6cc95e7b609b2c158e2115aa97ef7549141c5d" translate="yes" xml:space="preserve">
          <source>The pointer must be &lt;a href=&quot;index#safety&quot;&gt;valid&lt;/a&gt; for reads for &lt;code&gt;ptr.len() * mem::size_of::&amp;lt;T&amp;gt;()&lt;/code&gt; many bytes, and it must be properly aligned. This means in particular:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eab75a519555d7d953b751dc8250587661100bb4" translate="yes" xml:space="preserve">
          <source>The pointer must be &lt;a href=&quot;ptr/index#safety&quot;&gt;valid&lt;/a&gt; for reads and writes for &lt;code&gt;ptr.len() * mem::size_of::&amp;lt;T&amp;gt;()&lt;/code&gt; many bytes, and it must be properly aligned. This means in particular:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="032bd62f596d84915c186de815c7e316435955e0" translate="yes" xml:space="preserve">
          <source>The pointer must be &lt;a href=&quot;ptr/index#safety&quot;&gt;valid&lt;/a&gt; for reads for &lt;code&gt;ptr.len() * mem::size_of::&amp;lt;T&amp;gt;()&lt;/code&gt; many bytes, and it must be properly aligned. This means in particular:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ada677800eded9f5bb09a12d4c9272e1a48a79a4" translate="yes" xml:space="preserve">
          <source>The pointer must be aligned even for zero-length slices. One reason for this is that enum layout optimizations may rely on references (including slices of any length) being aligned and non-null to distinguish them from other data. You can obtain a pointer that is usable as &lt;code&gt;data&lt;/code&gt; for zero-length slices using &lt;a href=&quot;ptr/struct.nonnull#method.dangling&quot;&gt;&lt;code&gt;NonNull::dangling()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5f6efbb545be55e13f893ac7dc6eaebbf999874a" translate="yes" xml:space="preserve">
          <source>The pointer must be aligned even for zero-length slices. One reason for this is that enum layout optimizations may rely on references (including slices of any length) being aligned and non-null to distinguish them from other data. You can obtain a pointer that is usable as &lt;code&gt;data&lt;/code&gt; for zero-length slices using &lt;a href=&quot;struct.nonnull#method.dangling&quot;&gt;&lt;code&gt;NonNull::dangling()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7882f94a6f87dc84506e67cf6e6f86cd53b02982" translate="yes" xml:space="preserve">
          <source>The pointer must be properly aligned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e3de011a05d32ff014b1d75b10f32cd8a5ceea0c" translate="yes" xml:space="preserve">
          <source>The pointer must have been obtained through &lt;code&gt;Arc::into_raw&lt;/code&gt;, and the associated &lt;code&gt;Arc&lt;/code&gt; instance must be valid (i.e. the strong count must be at least 1) for the duration of this method.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d97c31e45ac08eaf340466af2855c1d69a8c822f" translate="yes" xml:space="preserve">
          <source>The pointer must have been obtained through &lt;code&gt;Arc::into_raw&lt;/code&gt;, and the associated &lt;code&gt;Arc&lt;/code&gt; instance must be valid (i.e. the strong count must be at least 1) when invoking this method. This method can be used to release the final &lt;code&gt;Arc&lt;/code&gt; and backing storage, but &lt;strong&gt;should not&lt;/strong&gt; be called after the final &lt;code&gt;Arc&lt;/code&gt; has been released.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="15b7d63adfc51a7db20582294688b5c6c47a0e5f" translate="yes" xml:space="preserve">
          <source>The pointer must have originated from the &lt;a href=&quot;struct.weak#method.into_raw&quot;&gt;&lt;code&gt;into_raw&lt;/code&gt;&lt;/a&gt; and must still own its potential weak reference.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="561496e3426c59f66cb3091efa83ade648ff436f" translate="yes" xml:space="preserve">
          <source>The pointer must point to an initialized instance of &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d562cc44e11330190c6c67edae5c28019986b445" translate="yes" xml:space="preserve">
          <source>The pointer must represent one valid weak count. In other words, it must point to &lt;code&gt;T&lt;/code&gt; which is or &lt;em&gt;was&lt;/em&gt; managed by an &lt;a href=&quot;struct.arc&quot;&gt;&lt;code&gt;Arc&lt;/code&gt;&lt;/a&gt; and the weak count of that &lt;a href=&quot;struct.arc&quot;&gt;&lt;code&gt;Arc&lt;/code&gt;&lt;/a&gt; must not have reached 0. It is allowed for the strong count to be 0.</source>
          <target state="translated">Указатель должен представлять один допустимый слабый счетчик. Другими слова, он должен указать на &lt;code&gt;T&lt;/code&gt; , которая является или &lt;em&gt;был&lt;/em&gt; управляемым с помощью &lt;a href=&quot;struct.arc&quot;&gt; &lt;code&gt;Arc&lt;/code&gt; &lt;/a&gt; и слабого подсчета , что &lt;a href=&quot;struct.arc&quot;&gt; &lt;code&gt;Arc&lt;/code&gt; &lt;/a&gt; не должна быть достигнута 0. Это позволили за сильный подсчет , чтобы быть 0.</target>
        </trans-unit>
        <trans-unit id="20794b93602408cab637197663bf6c675231f221" translate="yes" xml:space="preserve">
          <source>The pointer must represent one valid weak count. In other words, it must point to &lt;code&gt;T&lt;/code&gt; which is or &lt;em&gt;was&lt;/em&gt; managed by an &lt;a href=&quot;struct.rc&quot;&gt;&lt;code&gt;Rc&lt;/code&gt;&lt;/a&gt; and the weak count of that &lt;a href=&quot;struct.rc&quot;&gt;&lt;code&gt;Rc&lt;/code&gt;&lt;/a&gt; must not have reached 0. It is allowed for the strong count to be 0.</source>
          <target state="translated">Указатель должен представлять один допустимый слабый счетчик. Другими словами, он должен указать на &lt;code&gt;T&lt;/code&gt; , которая является или &lt;em&gt;была&lt;/em&gt; управляемой с помощью &lt;a href=&quot;struct.rc&quot;&gt; &lt;code&gt;Rc&lt;/code&gt; &lt;/a&gt; и слабого подсчета , что &lt;a href=&quot;struct.rc&quot;&gt; &lt;code&gt;Rc&lt;/code&gt; &lt;/a&gt; не должно быть достигнуто 0. Это позволило за сильного подсчета , чтобы быть 0.</target>
        </trans-unit>
        <trans-unit id="d6200eb92cc97fc1d9fec6dde1612acc6fca320f" translate="yes" xml:space="preserve">
          <source>The pointer passed to all functions inside the vtable is the &lt;code&gt;data&lt;/code&gt; pointer from the enclosing &lt;a href=&quot;struct.rawwaker&quot;&gt;&lt;code&gt;RawWaker&lt;/code&gt;&lt;/a&gt; object.</source>
          <target state="translated">Указатель, переданный всем функциям внутри vtable, является указателем &lt;code&gt;data&lt;/code&gt; из включающего объекта &lt;a href=&quot;struct.rawwaker&quot;&gt; &lt;code&gt;RawWaker&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="1edb65c05d4061d65ef7c599b48750ef7ff50704" translate="yes" xml:space="preserve">
          <source>The pointer which this function returns must be returned to Rust and reconstituted using &lt;a href=&quot;#method.from_raw&quot;&gt;&lt;code&gt;from_raw&lt;/code&gt;&lt;/a&gt; to be properly deallocated. Specifically, one should &lt;em&gt;not&lt;/em&gt; use the standard C &lt;code&gt;free()&lt;/code&gt; function to deallocate this string.</source>
          <target state="translated">Указатель, который возвращает эта функция, должен быть возвращен в Rust и воссоздан с помощью &lt;a href=&quot;#method.from_raw&quot;&gt; &lt;code&gt;from_raw&lt;/code&gt; ,&lt;/a&gt; чтобы он был должным образом освобожден. В частности, следует &lt;em&gt;не&lt;/em&gt; использовать стандартные С &lt;code&gt;free()&lt;/code&gt; функции , чтобы освободить эту строку.</target>
        </trans-unit>
        <trans-unit id="80c5d8a7d931f08c90875d736c69378d02a8b64f" translate="yes" xml:space="preserve">
          <source>The pointer which this function returns must be returned to Rust and reconstituted using &lt;a href=&quot;struct.cstring#method.from_raw&quot;&gt;&lt;code&gt;CString::from_raw&lt;/code&gt;&lt;/a&gt; to be properly deallocated. Specifically, one should &lt;em&gt;not&lt;/em&gt; use the standard C &lt;code&gt;free()&lt;/code&gt; function to deallocate this string.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="33be8edf304b61e5005625c2c6aab855fc0ce0b3" translate="yes" xml:space="preserve">
          <source>The pointer will be properly aligned and non-null.</source>
          <target state="translated">Указатель будет правильно выровнен и не будет занулен.</target>
        </trans-unit>
        <trans-unit id="0c49a977fe21d66debc9a4c8b7d4cbbf312c9ff9" translate="yes" xml:space="preserve">
          <source>The pointer-sized signed integer type.</source>
          <target state="translated">Знаковый целочисленный тип размером с указатель.</target>
        </trans-unit>
        <trans-unit id="aebc6996cd3e6c3ef507e0e5f263e13ad4dcb04b" translate="yes" xml:space="preserve">
          <source>The pointer-sized unsigned integer type.</source>
          <target state="translated">Беззнаковый целочисленный тип,размером с указатель.</target>
        </trans-unit>
        <trans-unit id="589a00e779c762d350b4058d583ec6c935c455c7" translate="yes" xml:space="preserve">
          <source>The position used for seeking with &lt;a href=&quot;enum.seekfrom#variant.Current&quot;&gt;&lt;code&gt;SeekFrom::Current&lt;/code&gt;&lt;/a&gt;&lt;code&gt;(_)&lt;/code&gt; is the position the underlying reader would be at if the &lt;code&gt;BufReader&amp;lt;R&amp;gt;&lt;/code&gt; had no internal buffer.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4aef48aecfebe1bd9e6f96a0939bb1d8fec84054" translate="yes" xml:space="preserve">
          <source>The position used for seeking with &lt;code&gt;SeekFrom::Current(_)&lt;/code&gt; is the position the underlying reader would be at if the &lt;code&gt;BufReader&lt;/code&gt; had no internal buffer.</source>
          <target state="translated">Позиция, используемая для поиска с помощью &lt;code&gt;SeekFrom::Current(_)&lt;/code&gt; - это позиция, в которой находился бы базовый считыватель, если бы &lt;code&gt;BufReader&lt;/code&gt; не имел внутреннего буфера.</target>
        </trans-unit>
        <trans-unit id="6f1678b0e093177e7620807a9112f4ef7365e563" translate="yes" xml:space="preserve">
          <source>The positive difference of two numbers.</source>
          <target state="translated">Положительная разница в двух числах.</target>
        </trans-unit>
        <trans-unit id="e0a83025808dfefbef9f39106ce5fafd89bb2f1c" translate="yes" xml:space="preserve">
          <source>The practical use cases for &lt;code&gt;forget&lt;/code&gt; are rather specialized and mainly come up in unsafe or FFI code.</source>
          <target state="translated">Практические варианты использования &lt;code&gt;forget&lt;/code&gt; довольно специализированы и в основном возникают в небезопасном коде или коде FFI.</target>
        </trans-unit>
        <trans-unit id="fb2efbc552f75b7ae8fe422ecdae2c87a030f044" translate="yes" xml:space="preserve">
          <source>The precedence of Rust operators and expressions is ordered as follows, going from strong to weak. Binary Operators at the same precedence level are grouped in the order given by their associativity.</source>
          <target state="translated">Приоритет операторов и выражений Rust упорядочен следующим образом,переходя от сильного к слабому.Двоичные операторы,имеющие одинаковый уровень приоритета,группируются в порядке,заданном их ассоциативностью.</target>
        </trans-unit>
        <trans-unit id="5ed57a298428ca0f7395d0616c5eb17f0804c549" translate="yes" xml:space="preserve">
          <source>The precise Rust aliasing rules are somewhat in flux, but the main points are not contentious:</source>
          <target state="translated">Точные правила наложения ржавчины несколько изменчивы,но основные моменты не являются спорными:</target>
        </trans-unit>
        <trans-unit id="b19f5cee233892caf5ddceb163f25862486da448" translate="yes" xml:space="preserve">
          <source>The precise definition is: a type &lt;code&gt;T&lt;/code&gt; is &lt;a href=&quot;trait.sync&quot;&gt;&lt;code&gt;Sync&lt;/code&gt;&lt;/a&gt; if and only if &lt;code&gt;&amp;amp;T&lt;/code&gt; is &lt;a href=&quot;trait.send&quot;&gt;&lt;code&gt;Send&lt;/code&gt;&lt;/a&gt;. In other words, if there is no possibility of &lt;a href=&quot;../../reference/behavior-considered-undefined&quot;&gt;undefined behavior&lt;/a&gt; (including data races) when passing &lt;code&gt;&amp;amp;T&lt;/code&gt; references between threads.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d40bd8a03d88e20d491263cadc1752cd72c99258" translate="yes" xml:space="preserve">
          <source>The precise definition is: a type &lt;code&gt;T&lt;/code&gt; is &lt;code&gt;Sync&lt;/code&gt; if and only if &lt;code&gt;&amp;amp;T&lt;/code&gt; is &lt;a href=&quot;trait.send&quot;&gt;&lt;code&gt;Send&lt;/code&gt;&lt;/a&gt;. In other words, if there is no possibility of &lt;a href=&quot;../../reference/behavior-considered-undefined&quot;&gt;undefined behavior&lt;/a&gt; (including data races) when passing &lt;code&gt;&amp;amp;T&lt;/code&gt; references between threads.</source>
          <target state="translated">Точное определение таково: тип &lt;code&gt;T&lt;/code&gt; является &lt;code&gt;Sync&lt;/code&gt; тогда и только тогда, когда &lt;code&gt;&amp;amp;T&lt;/code&gt; имеет значение &lt;a href=&quot;trait.send&quot;&gt; &lt;code&gt;Send&lt;/code&gt; &lt;/a&gt; . Другими словами, если нет возможности &lt;a href=&quot;../../reference/behavior-considered-undefined&quot;&gt;неопределенного поведения&lt;/a&gt; (включая гонку данных) при передаче ссылок &lt;code&gt;&amp;amp;T&lt;/code&gt; между потоками.</target>
        </trans-unit>
        <trans-unit id="f47fdb8c6eff67732e48f22a8373d2422de700a9" translate="yes" xml:space="preserve">
          <source>The precise memory layout of a struct is not specified. One can specify a particular layout using the &lt;a href=&quot;../type-layout#representations&quot;&gt;&lt;code&gt;repr&lt;/code&gt; attribute&lt;/a&gt;.</source>
          <target state="translated">Точная структура памяти структуры не указана. Можно указать конкретный макет с помощью &lt;a href=&quot;../type-layout#representations&quot;&gt;атрибута &lt;/a&gt; &lt;code&gt;repr&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="18073d476ac74d19109a41401163857e8cd5056d" translate="yes" xml:space="preserve">
          <source>The precise rules for validity are not determined yet. The guarantees that are provided at this point are very minimal:</source>
          <target state="translated">Точные правила действительности еще не определены.Гарантии,которые предоставляются на данном этапе,очень минимальны:</target>
        </trans-unit>
        <trans-unit id="4933f50236b0c7e48edc0beedb70199f13c5e285" translate="yes" xml:space="preserve">
          <source>The predicate passed to &lt;code&gt;partition()&lt;/code&gt; can return &lt;code&gt;true&lt;/code&gt;, or &lt;code&gt;false&lt;/code&gt;. &lt;code&gt;partition()&lt;/code&gt; returns a pair, all of the elements for which it returned &lt;code&gt;true&lt;/code&gt;, and all of the elements for which it returned &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">Предикат, переданный в &lt;code&gt;partition()&lt;/code&gt; может возвращать &lt;code&gt;true&lt;/code&gt; или &lt;code&gt;false&lt;/code&gt; . &lt;code&gt;partition()&lt;/code&gt; возвращает пару: все элементы, для которых он вернул &lt;code&gt;true&lt;/code&gt; , и все элементы, для которых он вернул &lt;code&gt;false&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7fb4a93626b0bdb54fdbc20512bf4f76ed5cc7cd" translate="yes" xml:space="preserve">
          <source>The preferred alignment of a type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dbc19e95dcebc744b29e267ad8d2ebfde2e212c0" translate="yes" xml:space="preserve">
          <source>The prelude can be changed to the &lt;em&gt;core prelude&lt;/em&gt; by using the &lt;code&gt;no_std&lt;/code&gt;&lt;a href=&quot;attributes&quot;&gt;attribute&lt;/a&gt; on the root crate module. The linked crate is &lt;a href=&quot;https://doc.rust-lang.org/core/index.html&quot;&gt;&lt;code&gt;core&lt;/code&gt;&lt;/a&gt; and the prelude module is &lt;a href=&quot;https://doc.rust-lang.org/core/prelude/index.html&quot;&gt;&lt;code&gt;core::prelude::v1&lt;/code&gt;&lt;/a&gt;. Using the core prelude over the standard prelude is useful when either the crate is targeting a platform that does not support the standard library or is purposefully not using the capabilities of the standard library. Those capabilities are mainly dynamic memory allocation (e.g. &lt;code&gt;Box&lt;/code&gt; and &lt;code&gt;Vec&lt;/code&gt;) and file and network capabilities (e.g. &lt;code&gt;std::fs&lt;/code&gt; and &lt;code&gt;std::io&lt;/code&gt;).</source>
          <target state="translated">Прелюдия можно изменить на &lt;em&gt;прелюдию ядра&lt;/em&gt; , используя &lt;a href=&quot;attributes&quot;&gt;атрибут &lt;/a&gt; &lt;code&gt;no_std&lt;/code&gt; в модуле корневого ящика. Связанный ящик - это &lt;a href=&quot;https://doc.rust-lang.org/core/index.html&quot;&gt; &lt;code&gt;core&lt;/code&gt; ,&lt;/a&gt; а модуль prelude - &lt;a href=&quot;https://doc.rust-lang.org/core/prelude/index.html&quot;&gt; &lt;code&gt;core::prelude::v1&lt;/code&gt; &lt;/a&gt; . Использование основной прелюдии вместо стандартной прелюдии полезно, когда либо ящик нацелен на платформу, которая не поддерживает стандартную библиотеку, либо намеренно не использует возможности стандартной библиотеки. Эти возможности в основном представляют собой динамическое распределение памяти (например, &lt;code&gt;Box&lt;/code&gt; и &lt;code&gt;Vec&lt;/code&gt; ), а также файловые и сетевые возможности (например, &lt;code&gt;std::fs&lt;/code&gt; и &lt;code&gt;std::io&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="97af9d37776d235cea4e5a19d84cc2b3492bd088" translate="yes" xml:space="preserve">
          <source>The previous Appendix D, &amp;ldquo;Macros,&amp;rdquo; has been expanded to include procedural macros and was moved to the &amp;ldquo;Macros&amp;rdquo; section in Chapter 19.</source>
          <target state="translated">Предыдущее приложение D &amp;laquo;Макросы&amp;raquo; было расширено за счет включения процедурных макросов и перемещено в раздел &amp;laquo;Макросы&amp;raquo; в главе 19.</target>
        </trans-unit>
        <trans-unit id="757bcf5f0a1b2e7c263eb1294cae88079f56068e" translate="yes" xml:space="preserve">
          <source>The previous code example fixed:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3f0414a5a5139b7f4e08b6a8b19dea661159e39f" translate="yes" xml:space="preserve">
          <source>The previous example contains a circular dependency between two traits: &lt;code&gt;FirstTrait&lt;/code&gt; depends on &lt;code&gt;SecondTrait&lt;/code&gt; which itself depends on &lt;code&gt;FirstTrait&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="74a02be48083e6dc1dccc9a7d07cadacc4a53e7c" translate="yes" xml:space="preserve">
          <source>The previously duplicated code is now outside the &lt;code&gt;if&lt;/code&gt; and &lt;code&gt;else&lt;/code&gt; blocks and uses the &lt;code&gt;status_line&lt;/code&gt; and &lt;code&gt;filename&lt;/code&gt; variables. This makes it easier to see the difference between the two cases, and it means we have only one place to update the code if we want to change how the file reading and response writing work. The behavior of the code in Listing 20-9 will be the same as that in Listing 20-8.</source>
          <target state="translated">Ранее дублированный код теперь находится за пределами блоков &lt;code&gt;if&lt;/code&gt; и &lt;code&gt;else&lt;/code&gt; и использует переменные &lt;code&gt;status_line&lt;/code&gt; и &lt;code&gt;filename&lt;/code&gt; . Это позволяет легче увидеть разницу между двумя случаями, и это означает, что у нас есть только одно место для обновления кода, если мы хотим изменить работу чтения файла и записи ответа. Поведение кода в листинге 20-9 будет таким же, как в листинге 20-8.</target>
        </trans-unit>
        <trans-unit id="3c5b34498a69e2cebc3edcacf3022a159fa0d3cf" translate="yes" xml:space="preserve">
          <source>The primary separator of path components for the current platform.</source>
          <target state="translated">Основной разделитель компонентов пути для текущей платформы.</target>
        </trans-unit>
        <trans-unit id="d6d94c1dd4c2a4fb7b30d949d7313e70926e43b0" translate="yes" xml:space="preserve">
          <source>The primary use for the &lt;code&gt;let&lt;/code&gt; keyword is in &lt;code&gt;let&lt;/code&gt; statements, which are used to introduce a new set of variables into the current scope, as given by a pattern.</source>
          <target state="translated">Первичное использование для &lt;code&gt;let&lt;/code&gt; ключевого слова в &lt;code&gt;let&lt;/code&gt; утверждениях, которые используются , чтобы ввести новый набор переменных в текущую область, как указано с помощью шаблона.</target>
        </trans-unit>
        <trans-unit id="14d97c2e9b793134fb211ba0f8484d81636a707d" translate="yes" xml:space="preserve">
          <source>The primary use of the &lt;code&gt;crate&lt;/code&gt; keyword is as a part of &lt;code&gt;extern crate&lt;/code&gt; declarations, which are used to specify a dependency on a crate external to the one it's declared in. Crates are the fundamental compilation unit of Rust code, and can be seen as libraries or projects. More can be read about crates in the &lt;a href=&quot;../reference/items/extern-crates&quot;&gt;Reference&lt;/a&gt;.</source>
          <target state="translated">Основное использование ключевого слова &lt;code&gt;crate&lt;/code&gt; - это часть объявлений &lt;code&gt;extern crate&lt;/code&gt; , которые используются для указания зависимости от контейнера, внешнего по отношению к тому, в котором он объявлен. Ящики являются фундаментальной единицей компиляции кода Rust и могут рассматриваться как библиотеки или проекты. Подробнее о ящиках можно прочитать в &lt;a href=&quot;../reference/items/extern-crates&quot;&gt;Справочнике&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="229057a153cb547539a5140063be86de4fd5f109" translate="yes" xml:space="preserve">
          <source>The priority policy of the lock is dependent on the underlying operating system's implementation, and this type does not guarantee that any particular policy will be used.</source>
          <target state="translated">Политика приоритета замка зависит от реализации базовой операционной системы,и этот тип не гарантирует,что будет использоваться какая-либо конкретная политика.</target>
        </trans-unit>
        <trans-unit id="aa4bf60f4fab6128150a2cced20eb507a73f2223" translate="yes" xml:space="preserve">
          <source>The private address ranges are defined in &lt;a href=&quot;https://tools.ietf.org/html/rfc1918&quot;&gt;IETF RFC 1918&lt;/a&gt; and include:</source>
          <target state="translated">Диапазоны частных адресов определены в &lt;a href=&quot;https://tools.ietf.org/html/rfc1918&quot;&gt;IETF RFC 1918&lt;/a&gt; и включают:</target>
        </trans-unit>
        <trans-unit id="66e536d148965eb5f5f66293b59e6e08d6c64117" translate="yes" xml:space="preserve">
          <source>The problem above can be solved by using the &lt;code&gt;ref&lt;/code&gt; keyword.</source>
          <target state="translated">Вышеуказанную проблему можно решить с помощью ключевого слова &lt;code&gt;ref&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a6b09f11dabd510af2bfd7f547ade1211b4999bd" translate="yes" xml:space="preserve">
          <source>The problem here is that foo is defined as accepting a parameter of type &lt;code&gt;Fn&lt;/code&gt;. Closures passed into foo will thus be inferred to be of type &lt;code&gt;Fn&lt;/code&gt;, meaning that they capture their context immutably.</source>
          <target state="translated">Проблема здесь в том, что foo определяется как принимающий параметр типа &lt;code&gt;Fn&lt;/code&gt; . Таким образом, предполагается , что замыкания, переданные в foo, относятся к типу &lt;code&gt;Fn&lt;/code&gt; , что означает, что они неизменяемо фиксируют свой контекст.</target>
        </trans-unit>
        <trans-unit id="31cdd55efce31c6be1cacdfc4b62449817b4add1" translate="yes" xml:space="preserve">
          <source>The problem here is that if the given type or one of its fields implements the &lt;code&gt;Drop&lt;/code&gt; trait, this &lt;code&gt;Drop&lt;/code&gt; implementation cannot be called within a const context since it may run arbitrary, non-const-checked code. To prevent this issue, ensure all values with custom a custom &lt;code&gt;Drop&lt;/code&gt; implementation escape the initializer.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2c0a1b6d65ca057a3fdc49e919abfbdd1b60d9bd" translate="yes" xml:space="preserve">
          <source>The problem here is that the lifetime isn't contrained by any of the arguments, making it impossible to determine how long it's supposed to live.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fe892e0206a6e32b9668f223826cd09ae2236ca9" translate="yes" xml:space="preserve">
          <source>The problem here is that we're attempting to take the type of X from MyTrait. Unfortunately, the type of X is not defined, because it's only made concrete in implementations of the trait. A working version of this code might look like:</source>
          <target state="translated">Проблема здесь в том,что мы пытаемся взять тип X из MyTrait.К сожалению,тип X не определен,так как он сделан конкретным в реализации трейта.Рабочая версия этого кода может выглядеть так:</target>
        </trans-unit>
        <trans-unit id="e5cbbff1b6bec23be456b36b8e81795c5a5d74a0" translate="yes" xml:space="preserve">
          <source>The problem is that &lt;code&gt;result&lt;/code&gt; goes out of scope and gets cleaned up at the end of the &lt;code&gt;longest&lt;/code&gt; function. We&amp;rsquo;re also trying to return a reference to &lt;code&gt;result&lt;/code&gt; from the function. There is no way we can specify lifetime parameters that would change the dangling reference, and Rust won&amp;rsquo;t let us create a dangling reference. In this case, the best fix would be to return an owned data type rather than a reference so the calling function is then responsible for cleaning up the value.</source>
          <target state="translated">Проблема в том, что &lt;code&gt;result&lt;/code&gt; выходит за рамки и очищается в конце самой &lt;code&gt;longest&lt;/code&gt; функции. Мы также пытаемся вернуть ссылку на &lt;code&gt;result&lt;/code&gt; из функции. Мы не можем указать параметры времени жизни, которые могли бы изменить висящую ссылку, а Rust не позволит нам создать висящую ссылку. В этом случае лучшим решением было бы вернуть принадлежащий тип данных, а не ссылку, чтобы вызывающая функция затем отвечала за очистку значения.</target>
        </trans-unit>
        <trans-unit id="967a587dbf080c4427ca5b25acc74fdfbb85e443" translate="yes" xml:space="preserve">
          <source>The problem is that the first time we called &lt;code&gt;c.value&lt;/code&gt; with 1, the &lt;code&gt;Cacher&lt;/code&gt; instance saved &lt;code&gt;Some(1)&lt;/code&gt; in &lt;code&gt;self.value&lt;/code&gt;. Thereafter, no matter what we pass in to the &lt;code&gt;value&lt;/code&gt; method, it will always return 1.</source>
          <target state="translated">Проблема в том, что при первом вызове &lt;code&gt;c.value&lt;/code&gt; с 1 экземпляр &lt;code&gt;Cacher&lt;/code&gt; сохранил &lt;code&gt;Some(1)&lt;/code&gt; в &lt;code&gt;self.value&lt;/code&gt; . После этого, независимо от того, что мы передаем методу &lt;code&gt;value&lt;/code&gt; , он всегда будет возвращать 1.</target>
        </trans-unit>
        <trans-unit id="833738d2692abe453105a9ed609d8a8bc820fa2a" translate="yes" xml:space="preserve">
          <source>The problem is that the parameter &lt;code&gt;T&lt;/code&gt; does not appear in the implementing type (&lt;code&gt;Foo&lt;/code&gt;) of the impl. In this case, we can fix the error by moving the type parameter from the &lt;code&gt;impl&lt;/code&gt; to the method &lt;code&gt;get&lt;/code&gt;:</source>
          <target state="translated">Проблема в том, что параметр &lt;code&gt;T&lt;/code&gt; не появляется в типе реализации ( &lt;code&gt;Foo&lt;/code&gt; ) имп. В этом случае мы можем исправить ошибку, переместив параметр типа из &lt;code&gt;impl&lt;/code&gt; в метод &lt;code&gt;get&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="457d0fe3119f86c660d95b413dfdd79fba1ea792" translate="yes" xml:space="preserve">
          <source>The problem isn&amp;rsquo;t really with the concept but with the particular implementation. As such, Rust does not have nulls, but it does have an enum that can encode the concept of a value being present or absent. This enum is &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt;, and it is &lt;a href=&quot;../std/option/enum.option&quot;&gt;defined by the standard library&lt;/a&gt; as follows:</source>
          <target state="translated">Проблема не в самой концепции, а в конкретной реализации. Таким образом, в Rust нет нулей, но есть перечисление, которое может закодировать концепцию наличия или отсутствия значения. Это перечисление &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt; , и оно &lt;a href=&quot;../std/option/enum.option&quot;&gt;определяется стандартной библиотекой&lt;/a&gt; следующим образом:</target>
        </trans-unit>
        <trans-unit id="11afe9c5b7d3b341c43395982cbb657bcfedf0f3" translate="yes" xml:space="preserve">
          <source>The problem with null values is that if you try to use a null value as a not-null value, you&amp;rsquo;ll get an error of some kind. Because this null or not-null property is pervasive, it&amp;rsquo;s extremely easy to make this kind of error.</source>
          <target state="translated">Проблема с нулевыми значениями заключается в том, что если вы попытаетесь использовать нулевое значение в качестве ненулевого значения, вы получите какую-то ошибку. Поскольку это свойство null или ненулевое значение широко распространено, очень легко допустить ошибку такого рода.</target>
        </trans-unit>
        <trans-unit id="c7ffb82b1f0d51caf9c86374d324e2fb9ccac1dd" translate="yes" xml:space="preserve">
          <source>The process lacks permissions to view the contents.</source>
          <target state="translated">В процессе отсутствует разрешение на просмотр содержимого.</target>
        </trans-unit>
        <trans-unit id="475777e2dbe3eb987a1fdf9f7258e8744d697a33" translate="yes" xml:space="preserve">
          <source>The process lacks permissions to view the number of hardware threads available.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d5a1f341aa82ec15ad62b2ae6744edcef123d4a7" translate="yes" xml:space="preserve">
          <source>The process may be in a &quot;broken state&quot; if this function returns in error. For example the working directory, environment variables, signal handling settings, various user/group information, or aspects of stdio file descriptors may have changed. If a &quot;transactional spawn&quot; is required to gracefully handle errors it is recommended to use the cross-platform &lt;code&gt;spawn&lt;/code&gt; instead.</source>
          <target state="translated">Процесс может находиться в &amp;laquo;неработающем состоянии&amp;raquo;, если эта функция возвращает ошибку. Например, могли измениться рабочий каталог, переменные среды, параметры обработки сигналов, различная информация о пользователях / группах или аспекты дескрипторов файлов stdio. Если для корректной обработки ошибок требуется &amp;laquo;транзакционный порождение&amp;raquo;, рекомендуется вместо него использовать кроссплатформенное &lt;code&gt;spawn&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="68c2b04d8256c338d13f147c4eb19b87b45d4040" translate="yes" xml:space="preserve">
          <source>The programs we&amp;rsquo;ve written so far have been in one module in one file. As a project grows, you can organize code by splitting it into multiple modules and then multiple files. A package can contain multiple binary crates and optionally one library crate. As a package grows, you can extract parts into separate crates that become external dependencies. This chapter covers all these techniques. For very large projects of a set of interrelated packages that evolve together, Cargo provides workspaces, which we&amp;rsquo;ll cover in the &lt;a href=&quot;ch14-03-cargo-workspaces&quot;&gt;&amp;ldquo;Cargo Workspaces&amp;rdquo;&lt;/a&gt; section in Chapter 14.</source>
          <target state="translated">Программы, которые мы написали до сих пор, были в одном модуле в одном файле. По мере роста проекта вы можете организовать код, разделив его на несколько модулей, а затем на несколько файлов. Пакет может содержать несколько бинарных ящиков и, возможно, один ящик библиотеки. По мере роста пакета вы можете извлекать части в отдельные ящики, которые становятся внешними зависимостями. В этой главе рассматриваются все эти техники. Для очень больших проектов набора взаимосвязанных пакетов, которые развиваются вместе, Cargo предоставляет рабочие области, которые мы рассмотрим в разделе &lt;a href=&quot;ch14-03-cargo-workspaces&quot;&gt;&amp;laquo;Рабочие пространства Cargo&amp;raquo;&lt;/a&gt; в главе 14.</target>
        </trans-unit>
        <trans-unit id="5cc2497d5ed1d06060f022ff65bd8b3ff66c60a9" translate="yes" xml:space="preserve">
          <source>The provided &lt;a href=&quot;struct.layout#method.size&quot;&gt;&lt;code&gt;layout.size()&lt;/code&gt;&lt;/a&gt; must fall in the range &lt;code&gt;min ..= max&lt;/code&gt;, where:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="be1cd28ce339784f890d38adb07a623811959d09" translate="yes" xml:space="preserve">
          <source>The provided &lt;code&gt;path&lt;/code&gt; doesn't exist.</source>
          <target state="translated">Указанный &lt;code&gt;path&lt;/code&gt; не существует.</target>
        </trans-unit>
        <trans-unit id="a99e10f876c8ad74bd47e22ac1f9e01fe1760d28" translate="yes" xml:space="preserve">
          <source>The public methods &lt;code&gt;add&lt;/code&gt;, &lt;code&gt;remove&lt;/code&gt;, and &lt;code&gt;average&lt;/code&gt; are the only ways to access or modify data in an instance of &lt;code&gt;AveragedCollection&lt;/code&gt;. When an item is added to &lt;code&gt;list&lt;/code&gt; using the &lt;code&gt;add&lt;/code&gt; method or removed using the &lt;code&gt;remove&lt;/code&gt; method, the implementations of each call the private &lt;code&gt;update_average&lt;/code&gt; method that handles updating the &lt;code&gt;average&lt;/code&gt; field as well.</source>
          <target state="translated">Общедоступные методы &lt;code&gt;add&lt;/code&gt; , &lt;code&gt;remove&lt;/code&gt; и &lt;code&gt;average&lt;/code&gt; - единственные способы доступа или изменения данных в экземпляре &lt;code&gt;AveragedCollection&lt;/code&gt; . Когда элемент добавляется в &lt;code&gt;list&lt;/code&gt; с помощью метода &lt;code&gt;add&lt;/code&gt; или удаляется с помощью метода &lt;code&gt;remove&lt;/code&gt; , реализации каждого из них вызывают частный метод &lt;code&gt;update_average&lt;/code&gt; , который также обрабатывает обновление &lt;code&gt;average&lt;/code&gt; поля.</target>
        </trans-unit>
        <trans-unit id="c64a2ba34c09d4f2e756bf0b0db2bf928ce82f04" translate="yes" xml:space="preserve">
          <source>The purpose of pinning is to be able to rely on the placement of some data in memory. To make this work, not just moving the data is restricted; deallocating, repurposing, or otherwise invalidating the memory used to store the data is restricted, too. Concretely, for pinned data you have to maintain the invariant that &lt;em&gt;its memory will not get invalidated or repurposed from the moment it gets pinned until when &lt;a href=&quot;../ops/trait.drop#tymethod.drop&quot;&gt;&lt;code&gt;drop&lt;/code&gt;&lt;/a&gt; is called&lt;/em&gt;. Only once &lt;a href=&quot;../ops/trait.drop#tymethod.drop&quot;&gt;&lt;code&gt;drop&lt;/code&gt;&lt;/a&gt; returns or panics, the memory may be reused.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4a93f31254516d6844f82cc6e94b5893fc7d6231" translate="yes" xml:space="preserve">
          <source>The purpose of pinning is to be able to rely on the placement of some data in memory. To make this work, not just moving the data is restricted; deallocating, repurposing, or otherwise invalidating the memory used to store the data is restricted, too. Concretely, for pinned data you have to maintain the invariant that &lt;em&gt;its memory will not get invalidated or repurposed from the moment it gets pinned until when &lt;code&gt;drop&lt;/code&gt; is called&lt;/em&gt;. Memory can be invalidated by deallocation, but also by replacing a &lt;a href=&quot;../option/enum.option#variant.Some&quot;&gt;&lt;code&gt;Some(v)&lt;/code&gt;&lt;/a&gt; by &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt;, or calling &lt;a href=&quot;../vec/struct.vec#method.set_len&quot;&gt;&lt;code&gt;Vec::set_len&lt;/code&gt;&lt;/a&gt; to &quot;kill&quot; some elements off of a vector. It can be repurposed by using &lt;a href=&quot;../ptr/fn.write&quot;&gt;&lt;code&gt;ptr::write&lt;/code&gt;&lt;/a&gt; to overwrite it without calling the destructor first.</source>
          <target state="translated">Целью закрепления является возможность полагаться на размещение некоторых данных в памяти. Чтобы это работало, ограничивается не только перемещение данных; освобождение, перепрофилирование или иное обезвреживание памяти, используемой для хранения данных, также ограничено. В частности, для возлагали данные вы должны поддерживать инвариант , что &lt;em&gt;его память не будет признана недействительной или переориентирована с того момента , он не получает возлагал до тех пор , когда &lt;code&gt;drop&lt;/code&gt; называется&lt;/em&gt; . Память можно сделать недействительной путем освобождения памяти, а также путем замены &lt;a href=&quot;../option/enum.option#variant.Some&quot;&gt; &lt;code&gt;Some(v)&lt;/code&gt; &lt;/a&gt; на &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt; &lt;code&gt;None&lt;/code&gt; &lt;/a&gt; или вызова &lt;a href=&quot;../vec/struct.vec#method.set_len&quot;&gt; &lt;code&gt;Vec::set_len&lt;/code&gt; &lt;/a&gt; для &amp;laquo;уничтожения&amp;raquo; некоторых элементов вектора. Его можно перепрофилировать, используя &lt;a href=&quot;../ptr/fn.write&quot;&gt; &lt;code&gt;ptr::write&lt;/code&gt; &lt;/a&gt; чтобы перезаписать его без предварительного вызова деструктора.</target>
        </trans-unit>
        <trans-unit id="dadde1acddaa4f2663e0f0f8fe2f53b8bd256d16" translate="yes" xml:space="preserve">
          <source>The purpose of these &lt;code&gt;Result&lt;/code&gt; types is to encode error-handling information. Values of the &lt;code&gt;Result&lt;/code&gt; type, like values of any type, have methods defined on them. An instance of &lt;code&gt;io::Result&lt;/code&gt; has an &lt;a href=&quot;../std/result/enum.result#method.expect&quot;&gt;&lt;code&gt;expect&lt;/code&gt; method&lt;/a&gt; that you can call. If this instance of &lt;code&gt;io::Result&lt;/code&gt; is an &lt;code&gt;Err&lt;/code&gt; value, &lt;code&gt;expect&lt;/code&gt; will cause the program to crash and display the message that you passed as an argument to &lt;code&gt;expect&lt;/code&gt;. If the &lt;code&gt;read_line&lt;/code&gt; method returns an &lt;code&gt;Err&lt;/code&gt;, it would likely be the result of an error coming from the underlying operating system. If this instance of &lt;code&gt;io::Result&lt;/code&gt; is an &lt;code&gt;Ok&lt;/code&gt; value, &lt;code&gt;expect&lt;/code&gt; will take the return value that &lt;code&gt;Ok&lt;/code&gt; is holding and return just that value to you so you can use it. In this case, that value is the number of bytes in what the user entered into standard input.</source>
          <target state="translated">Эти типы &lt;code&gt;Result&lt;/code&gt; предназначены для кодирования информации об обработке ошибок. Значения типа &lt;code&gt;Result&lt;/code&gt; , как и значения любого типа, имеют определенные методы. Экземпляр &lt;code&gt;io::Result&lt;/code&gt; имеет &lt;a href=&quot;../std/result/enum.result#method.expect&quot;&gt; &lt;code&gt;expect&lt;/code&gt; метод,&lt;/a&gt; который вы можете вызвать. Если этот экземпляр &lt;code&gt;io::Result&lt;/code&gt; является значением &lt;code&gt;Err&lt;/code&gt; , &lt;code&gt;expect&lt;/code&gt; вызовет сбой программы и отобразит сообщение, которое вы передали в качестве &lt;code&gt;expect&lt;/code&gt; аргумента . Если метод &lt;code&gt;read_line&lt;/code&gt; возвращает ошибку &lt;code&gt;Err&lt;/code&gt; , это, скорее всего, является результатом ошибки, исходящей от базовой операционной системы. Если этот экземпляр &lt;code&gt;io::Result&lt;/code&gt; является &lt;code&gt;Ok&lt;/code&gt; значение, &lt;code&gt;expect&lt;/code&gt; примет возвращаемое значение, которое держит &lt;code&gt;Ok&lt;/code&gt; , и вернет вам только это значение, чтобы вы могли его использовать. В данном случае это значение представляет собой количество байтов, которое пользователь ввел в стандартный ввод.</target>
        </trans-unit>
        <trans-unit id="17a957e4dd15537d9df26e9cd567ee8ac4ab9c24" translate="yes" xml:space="preserve">
          <source>The purpose of this example is to demonstrate a situation in which some generic parameters are declared with &lt;code&gt;impl&lt;/code&gt; and some are declared with the method definition. Here, the generic parameters &lt;code&gt;T&lt;/code&gt; and &lt;code&gt;U&lt;/code&gt; are declared after &lt;code&gt;impl&lt;/code&gt;, because they go with the struct definition. The generic parameters &lt;code&gt;V&lt;/code&gt; and &lt;code&gt;W&lt;/code&gt; are declared after &lt;code&gt;fn mixup&lt;/code&gt;, because they&amp;rsquo;re only relevant to the method.</source>
          <target state="translated">Цель этого примера - продемонстрировать ситуацию, в которой некоторые общие параметры объявляются с помощью &lt;code&gt;impl&lt;/code&gt; , а некоторые - с помощью определения метода. Здесь общие параметры &lt;code&gt;T&lt;/code&gt; и &lt;code&gt;U&lt;/code&gt; объявляются после &lt;code&gt;impl&lt;/code&gt; , потому что они идут с определением структуры. Общие параметры &lt;code&gt;V&lt;/code&gt; и &lt;code&gt;W&lt;/code&gt; объявляются после &lt;code&gt;fn mixup&lt;/code&gt; , потому что они относятся только к методу.</target>
        </trans-unit>
        <trans-unit id="83464f6d897f3cf3890af3a243744932372ed118" translate="yes" xml:space="preserve">
          <source>The purpose of this module is to alleviate imports of many common I/O traits by adding a glob import to the top of I/O heavy modules:</source>
          <target state="translated">Целью данного модуля является облегчение импорта многих распространенных признаков ввода/вывода путем добавления глобуса импорта в верхнюю часть тяжелых модулей ввода/вывода:</target>
        </trans-unit>
        <trans-unit id="c5176304cb4e1480563977bff5f9fc8f29f52bf7" translate="yes" xml:space="preserve">
          <source>The purpose of trait objects is to permit &quot;late binding&quot; of methods. Calling a method on a trait object results in virtual dispatch at runtime: that is, a function pointer is loaded from the trait object vtable and invoked indirectly. The actual implementation for each vtable entry can vary on an object-by-object basis.</source>
          <target state="translated">Назначение объектов чертежа-разрешение &quot;поздней привязки&quot; методов.Вызов метода на объекте трейта приводит к виртуальной диспетчеризации во время выполнения:то есть указатель функции загружается из vtable объекта трейта и вызывается косвенным образом.Реальная реализация для каждой записи таблицы может варьироваться в зависимости от объекта.</target>
        </trans-unit>
        <trans-unit id="f15fea39e76fdfafefd43bfce074d20361154e36" translate="yes" xml:space="preserve">
          <source>The purpose of unit tests is to test each unit of code in isolation from the rest of the code to quickly pinpoint where code is and isn&amp;rsquo;t working as expected. You&amp;rsquo;ll put unit tests in the &lt;em&gt;src&lt;/em&gt; directory in each file with the code that they&amp;rsquo;re testing. The convention is to create a module named &lt;code&gt;tests&lt;/code&gt; in each file to contain the test functions and to annotate the module with &lt;code&gt;cfg(test)&lt;/code&gt;.</source>
          <target state="translated">Цель модульных тестов - протестировать каждую единицу кода отдельно от остальной части кода, чтобы быстро определить, где код работает, а где не работает должным образом. Вы поместите модульные тесты в каталог &lt;em&gt;src&lt;/em&gt; в каждый файл с кодом, который они тестируют. По соглашению в каждом файле создается модуль с именем &lt;code&gt;tests&lt;/code&gt; , содержащий тестовые функции и аннотированный с помощью &lt;code&gt;cfg(test)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="60cba1f37e61726b832a14d7f1500e4426e9a5cc" translate="yes" xml:space="preserve">
          <source>The question mark operator</source>
          <target state="translated">Оператор вопросительного знака</target>
        </trans-unit>
        <trans-unit id="018537889ded2ab112f094946b8612c9a86b99ba" translate="yes" xml:space="preserve">
          <source>The question mark operator (&lt;code&gt;?&lt;/code&gt;) unwraps valid values or returns erroneous values, propagating them to the calling function. It is a unary postfix operator that can only be applied to the types &lt;code&gt;Result&amp;lt;T, E&amp;gt;&lt;/code&gt; and &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">Оператор вопросительного знака ( &lt;code&gt;?&lt;/code&gt; ) Разворачивает допустимые значения или возвращает ошибочные значения, передавая их вызывающей функции. Это унарный постфиксный оператор, который может применяться только к типам &lt;code&gt;Result&amp;lt;T, E&amp;gt;&lt;/code&gt; и &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7ea5d63d0d5a319dd6d9072a4460aea03a494584" translate="yes" xml:space="preserve">
          <source>The question mark operator, &lt;code&gt;?&lt;/code&gt;</source>
          <target state="translated">Оператор вопросительного знака &lt;code&gt;?&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="61208bdae8b221a09aba4f839d74c11c2925c51c" translate="yes" xml:space="preserve">
          <source>The radix or base of the internal representation of &lt;code&gt;f32&lt;/code&gt;.</source>
          <target state="translated">Основание или основание внутреннего представления &lt;code&gt;f32&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ea313a35fa236b37b46428fb2657491b2e33dea3" translate="yes" xml:space="preserve">
          <source>The radix or base of the internal representation of &lt;code&gt;f32&lt;/code&gt;. Use &lt;a href=&quot;../primitive.f32#associatedconstant.RADIX&quot;&gt;&lt;code&gt;f32::RADIX&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fc170d8fddda3392ca3bbfeb02d09cfb7f6a80ce" translate="yes" xml:space="preserve">
          <source>The radix or base of the internal representation of &lt;code&gt;f64&lt;/code&gt;.</source>
          <target state="translated">Основание внутреннего представления &lt;code&gt;f64&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="eb77af93de4b13de0ebcbd9266a033e54a3960fe" translate="yes" xml:space="preserve">
          <source>The radix or base of the internal representation of &lt;code&gt;f64&lt;/code&gt;. Use &lt;a href=&quot;../primitive.f64#associatedconstant.RADIX&quot;&gt;&lt;code&gt;f64::RADIX&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0b9457bd197a286afc52dbcebb942e61605b222d" translate="yes" xml:space="preserve">
          <source>The range &lt;code&gt;start..end&lt;/code&gt; contains all values with &lt;code&gt;start &amp;lt;= x &amp;lt; end&lt;/code&gt;. It is empty if &lt;code&gt;start &amp;gt;= end&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="510a943d569cb4f1080072d01ababcb91699bcc6" translate="yes" xml:space="preserve">
          <source>The range is empty if either side is incomparable:</source>
          <target state="translated">Диапазон пуст,если любая из сторон несопоставима:</target>
        </trans-unit>
        <trans-unit id="a7d43b8cf204eefd21645fceff96d69cfb297982" translate="yes" xml:space="preserve">
          <source>The raw pointer must have been previously returned by a call to &lt;a href=&quot;struct.arc#method.into_raw&quot;&gt;&lt;code&gt;Arc&amp;lt;U&amp;gt;::into_raw&lt;/code&gt;&lt;/a&gt; where &lt;code&gt;U&lt;/code&gt; must have the same size and alignment as &lt;code&gt;T&lt;/code&gt;. This is trivially true if &lt;code&gt;U&lt;/code&gt; is &lt;code&gt;T&lt;/code&gt;. Note that if &lt;code&gt;U&lt;/code&gt; is not &lt;code&gt;T&lt;/code&gt; but has the same size and alignment, this is basically like transmuting references of different types. See &lt;a href=&quot;../mem/fn.transmute&quot;&gt;&lt;code&gt;mem::transmute&lt;/code&gt;&lt;/a&gt; for more information on what restrictions apply in this case.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7a2067413bc1879d44bf7542436c24e1555ca1bc" translate="yes" xml:space="preserve">
          <source>The raw pointer must have been previously returned by a call to &lt;a href=&quot;struct.rc#method.into_raw&quot;&gt;&lt;code&gt;Rc&amp;lt;U&amp;gt;::into_raw&lt;/code&gt;&lt;/a&gt; where &lt;code&gt;U&lt;/code&gt; must have the same size and alignment as &lt;code&gt;T&lt;/code&gt;. This is trivially true if &lt;code&gt;U&lt;/code&gt; is &lt;code&gt;T&lt;/code&gt;. Note that if &lt;code&gt;U&lt;/code&gt; is not &lt;code&gt;T&lt;/code&gt; but has the same size and alignment, this is basically like transmuting references of different types. See &lt;a href=&quot;../mem/fn.transmute&quot;&gt;&lt;code&gt;mem::transmute&lt;/code&gt;&lt;/a&gt; for more information on what restrictions apply in this case.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9cc134868dea70688318900dea4fb56c096c2fce" translate="yes" xml:space="preserve">
          <source>The raw pointer must have been previously returned by a call to a &lt;a href=&quot;struct.arc#method.into_raw&quot;&gt;&lt;code&gt;Arc::into_raw&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Необработанный указатель должен быть ранее возвращен вызовом &lt;a href=&quot;struct.arc#method.into_raw&quot;&gt; &lt;code&gt;Arc::into_raw&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="cb442a6e9f4c3ea3ad88f7d20cbb90e50f086583" translate="yes" xml:space="preserve">
          <source>The raw pointer must have been previously returned by a call to a &lt;a href=&quot;struct.rc#method.into_raw&quot;&gt;&lt;code&gt;Rc::into_raw&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Необработанный указатель должен быть ранее возвращен вызовом &lt;a href=&quot;struct.rc#method.into_raw&quot;&gt; &lt;code&gt;Rc::into_raw&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="61edb86c6e775bcbcc090bf0b2354d8086752aee" translate="yes" xml:space="preserve">
          <source>The re-ordering prevented by the different ordering semantics are:</source>
          <target state="translated">Переупорядочиванию препятствуют различные семантики упорядочения:</target>
        </trans-unit>
        <trans-unit id="db75fd7d163698847a2930407a821664ef9dc7a1" translate="yes" xml:space="preserve">
          <source>The reading portion of the &lt;a href=&quot;struct.tcpstream&quot;&gt;&lt;code&gt;TcpStream&lt;/code&gt;&lt;/a&gt; should be shut down.</source>
          <target state="translated">Часть чтения &lt;a href=&quot;struct.tcpstream&quot;&gt; &lt;code&gt;TcpStream&lt;/code&gt; &lt;/a&gt; должна быть отключена.</target>
        </trans-unit>
        <trans-unit id="bb2e18a8faa1f91810d19956a7143af41d8b7e9f" translate="yes" xml:space="preserve">
          <source>The reason for deprecation is that the function basically cannot be used correctly: &lt;a href=&quot;union.maybeuninit#initialization-invariant&quot;&gt;the Rust compiler assumes&lt;/a&gt; that values are properly initialized. As a consequence, calling e.g. &lt;code&gt;mem::uninitialized::&amp;lt;bool&amp;gt;()&lt;/code&gt; causes immediate undefined behavior for returning a &lt;code&gt;bool&lt;/code&gt; that is not definitely either &lt;code&gt;true&lt;/code&gt; or &lt;code&gt;false&lt;/code&gt;. Worse, truly uninitialized memory like what gets returned here is special in that the compiler knows that it does not have a fixed value. This makes it undefined behavior to have uninitialized data in a variable even if that variable has an integer type. (Notice that the rules around uninitialized integers are not finalized yet, but until they are, it is advisable to avoid them.)</source>
          <target state="translated">Причина устаревания заключается в том, что функция в принципе не может использоваться правильно: &lt;a href=&quot;union.maybeuninit#initialization-invariant&quot;&gt;компилятор Rust предполагает,&lt;/a&gt; что значения правильно инициализированы. Как следствие, вызов, например, &lt;code&gt;mem::uninitialized::&amp;lt;bool&amp;gt;()&lt;/code&gt; вызывает немедленное неопределенное поведение для возврата &lt;code&gt;bool&lt;/code&gt; , которое не является ни &lt;code&gt;true&lt;/code&gt; ни &lt;code&gt;false&lt;/code&gt; . Хуже того, действительно неинициализированная память, подобная той, что здесь возвращается, является особенной, поскольку компилятор знает, что у нее нет фиксированного значения. Это делает неопределенным поведение неинициализированных данных в переменной, даже если эта переменная имеет целочисленный тип. (Обратите внимание, что правила для неинициализированных целых чисел еще не окончательно утверждены, но пока они не будут завершены, рекомендуется их избегать.)</target>
        </trans-unit>
        <trans-unit id="0a840dd2de2cd2ee34a26f979453151250b4e843" translate="yes" xml:space="preserve">
          <source>The reason for deprecation is that the function basically cannot be used correctly: it has the same effect as &lt;a href=&quot;union.maybeuninit#method.uninit&quot;&gt;&lt;code&gt;MaybeUninit::uninit().assume_init()&lt;/code&gt;&lt;/a&gt;. As the &lt;a href=&quot;union.maybeuninit#method.assume_init&quot;&gt;&lt;code&gt;assume_init&lt;/code&gt; documentation&lt;/a&gt; explains, &lt;a href=&quot;union.maybeuninit#initialization-invariant&quot;&gt;the Rust compiler assumes&lt;/a&gt; that values are properly initialized. As a consequence, calling e.g. &lt;code&gt;mem::uninitialized::&amp;lt;bool&amp;gt;()&lt;/code&gt; causes immediate undefined behavior for returning a &lt;code&gt;bool&lt;/code&gt; that is not definitely either &lt;code&gt;true&lt;/code&gt; or &lt;code&gt;false&lt;/code&gt;. Worse, truly uninitialized memory like what gets returned here is special in that the compiler knows that it does not have a fixed value. This makes it undefined behavior to have uninitialized data in a variable even if that variable has an integer type. (Notice that the rules around uninitialized integers are not finalized yet, but until they are, it is advisable to avoid them.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d5d0c9e3177e947296d0e4cad464419f6391db88" translate="yes" xml:space="preserve">
          <source>The reason for this is that &lt;code&gt;rlib&lt;/code&gt; files do not contain any of their upstream dependencies. It wouldn't be very efficient for all &lt;code&gt;rlib&lt;/code&gt; files to contain a copy of &lt;code&gt;libstd.rlib&lt;/code&gt;!</source>
          <target state="translated">Причина этого в том, что файлы &lt;code&gt;rlib&lt;/code&gt; не содержат никаких зависимостей от вышестоящего уровня. Было бы не очень эффективно, если бы все файлы &lt;code&gt;rlib&lt;/code&gt; содержали копию &lt;code&gt;libstd.rlib&lt;/code&gt; !</target>
        </trans-unit>
        <trans-unit id="f95aa7105ee4000143fc92462b837053383a52a0" translate="yes" xml:space="preserve">
          <source>The reason for this is that there are two appearances of type parameter &lt;code&gt;T&lt;/code&gt; in the &lt;code&gt;impl&lt;/code&gt; header, both as parameters for &lt;code&gt;ForeignTrait2&lt;/code&gt;. The first appearance is uncovered, and so runs afoul of the orphan rule.</source>
          <target state="translated">Причина этого заключается в том , что существует два типа появления параметра &lt;code&gt;T&lt;/code&gt; в &lt;code&gt;impl&lt;/code&gt; заголовка, так как параметры для &lt;code&gt;ForeignTrait2&lt;/code&gt; . Первое появление раскрыто, и это противоречит правилу сиротства.</target>
        </trans-unit>
        <trans-unit id="ef37c27a4f0dd2645ce86c85a75eac6a77fa29d9" translate="yes" xml:space="preserve">
          <source>The reason is that types such as integers that have a known size at compile time are stored entirely on the stack, so copies of the actual values are quick to make. That means there&amp;rsquo;s no reason we would want to prevent &lt;code&gt;x&lt;/code&gt; from being valid after we create the variable &lt;code&gt;y&lt;/code&gt;. In other words, there&amp;rsquo;s no difference between deep and shallow copying here, so calling &lt;code&gt;clone&lt;/code&gt; wouldn&amp;rsquo;t do anything different from the usual shallow copying and we can leave it out.</source>
          <target state="translated">Причина в том, что такие типы, как целые числа, размер которых известен во время компиляции, полностью хранятся в стеке, поэтому копии фактических значений можно сделать быстро. Это означает, что нет причин, по которым мы хотели бы, чтобы &lt;code&gt;x&lt;/code&gt; не был действительным после создания переменной &lt;code&gt;y&lt;/code&gt; . Другими словами, здесь нет разницы между глубоким и поверхностным копированием, поэтому вызов &lt;code&gt;clone&lt;/code&gt; не будет делать ничего, отличного от обычного поверхностного копирования, и мы можем его не учитывать.</target>
        </trans-unit>
        <trans-unit id="5c1ca57165d895e7b5a9a07fb8f81dd8e653560f" translate="yes" xml:space="preserve">
          <source>The reason is that you&amp;rsquo;re missing some crucial information: a description and license are required so people will know what your crate does and under what terms they can use it. To rectify this error, you need to include this information in the &lt;em&gt;Cargo.toml&lt;/em&gt; file.</source>
          <target state="translated">Причина в том, что вам не хватает важной информации: требуется описание и лицензия, чтобы люди знали, что делает ваш ящик, и на каких условиях они могут его использовать. Чтобы исправить эту ошибку, вам необходимо включить эту информацию в файл &lt;em&gt;Cargo.toml&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="87dec969a1d8a7fd52229930c681793b58499b7c" translate="yes" xml:space="preserve">
          <source>The reason is that, in the first example, there are many possible types that &lt;code&gt;!&lt;/code&gt; could coerce to, because many types implement &lt;code&gt;Add&amp;lt;u32&amp;gt;&lt;/code&gt;. However, in the second example, the &lt;code&gt;else&lt;/code&gt; branch returns a &lt;code&gt;0&lt;/code&gt;, which the compiler infers from the return type to be of type &lt;code&gt;u32&lt;/code&gt;. Since &lt;code&gt;u32&lt;/code&gt; is a concrete type, &lt;code&gt;!&lt;/code&gt; can and will be coerced to it. See issue &lt;a href=&quot;https://github.com/rust-lang/rust/issues/36375&quot;&gt;#36375&lt;/a&gt; for more information on this quirk of &lt;code&gt;!&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="725753993f38910ecfb713203cf3afe96ff590f2" translate="yes" xml:space="preserve">
          <source>The reason that this matter is that the type &lt;code&gt;fn(S)&lt;/code&gt; is not specific to any particular function: it's a function &lt;em&gt;pointer&lt;/em&gt;. So calling &lt;code&gt;x()&lt;/code&gt; results in a virtual call, whereas &lt;code&gt;foo()&lt;/code&gt; is statically dispatched, because the type of &lt;code&gt;foo&lt;/code&gt; tells us precisely what function is being called.</source>
          <target state="translated">Причина этого в том, что тип &lt;code&gt;fn(S)&lt;/code&gt; не является специфическим для какой-либо конкретной функции: это &lt;em&gt;указатель&lt;/em&gt; на функцию . Таким образом, вызов &lt;code&gt;x()&lt;/code&gt; приводит к виртуальному вызову, тогда как &lt;code&gt;foo()&lt;/code&gt; отправляется статически, потому что тип &lt;code&gt;foo&lt;/code&gt; точно сообщает нам, какая функция вызывается.</target>
        </trans-unit>
        <trans-unit id="2f71ddaa6e32a7d6efaff9da8a4ddd4766615cbe" translate="yes" xml:space="preserve">
          <source>The reason the &lt;code&gt;deref&lt;/code&gt; method returns a reference to a value, and that the plain dereference outside the parentheses in &lt;code&gt;*(y.deref())&lt;/code&gt; is still necessary, is the ownership system. If the &lt;code&gt;deref&lt;/code&gt; method returned the value directly instead of a reference to the value, the value would be moved out of &lt;code&gt;self&lt;/code&gt;. We don&amp;rsquo;t want to take ownership of the inner value inside &lt;code&gt;MyBox&amp;lt;T&amp;gt;&lt;/code&gt; in this case or in most cases where we use the dereference operator.</source>
          <target state="translated">Причина, по &lt;code&gt;deref&lt;/code&gt; метод deref возвращает ссылку на значение, и что простое разыменование вне скобок в &lt;code&gt;*(y.deref())&lt;/code&gt; все еще необходимо, - это система владения. Если метод &lt;code&gt;deref&lt;/code&gt; вернул значение напрямую, а не ссылку на значение, значение будет перемещено из &lt;code&gt;self&lt;/code&gt; . Мы не хотим брать на себя ответственность за внутреннее значение внутри &lt;code&gt;MyBox&amp;lt;T&amp;gt;&lt;/code&gt; в этом случае или в большинстве случаев, когда мы используем оператор разыменования.</target>
        </trans-unit>
        <trans-unit id="1d62bb1a32655921533dae07c7931836afe25a19" translate="yes" xml:space="preserve">
          <source>The reason this function compiles without lifetime annotations is historical: in early versions (pre-1.0) of Rust, this code wouldn&amp;rsquo;t have compiled because every reference needed an explicit lifetime. At that time, the function signature would have been written like this:</source>
          <target state="translated">Причина, по которой эта функция компилируется без аннотаций времени жизни, является исторической: в ранних версиях (до 1.0) Rust этот код не скомпилировался, потому что каждая ссылка требовала явного времени жизни. В то время сигнатура функции была бы записана так:</target>
        </trans-unit>
        <trans-unit id="bedb5e3116e5d92919b43a452878e5db1b96099b" translate="yes" xml:space="preserve">
          <source>The reason we&amp;rsquo;re able to use &lt;code&gt;&amp;amp;s2&lt;/code&gt; in the call to &lt;code&gt;add&lt;/code&gt; is that the compiler can &lt;em&gt;coerce&lt;/em&gt; the &lt;code&gt;&amp;amp;String&lt;/code&gt; argument into a &lt;code&gt;&amp;amp;str&lt;/code&gt;. When we call the &lt;code&gt;add&lt;/code&gt; method, Rust uses a &lt;em&gt;deref coercion&lt;/em&gt;, which here turns &lt;code&gt;&amp;amp;s2&lt;/code&gt; into &lt;code&gt;&amp;amp;s2[..]&lt;/code&gt;. We&amp;rsquo;ll discuss deref coercion in more depth in Chapter 15. Because &lt;code&gt;add&lt;/code&gt; does not take ownership of the &lt;code&gt;s&lt;/code&gt; parameter, &lt;code&gt;s2&lt;/code&gt; will still be a valid &lt;code&gt;String&lt;/code&gt; after this operation.</source>
          <target state="translated">Причина мы можем использовать &lt;code&gt;&amp;amp;s2&lt;/code&gt; в вызове &lt;code&gt;add&lt;/code&gt; является то , что компилятор может &lt;em&gt;заставить &lt;/em&gt; &lt;code&gt;&amp;amp;String&lt;/code&gt; , аргумент в &lt;code&gt;&amp;amp;str&lt;/code&gt; . Когда мы вызываем метод &lt;code&gt;add&lt;/code&gt; , Rust использует приведение &lt;em&gt;deref&lt;/em&gt; , которое здесь превращает &lt;code&gt;&amp;amp;s2&lt;/code&gt; в &lt;code&gt;&amp;amp;s2[..]&lt;/code&gt; . Мы обсудим приведение deref более подробно в главе 15. Поскольку &lt;code&gt;add&lt;/code&gt; не принимает во владение параметр &lt;code&gt;s&lt;/code&gt; , после этой операции &lt;code&gt;s2&lt;/code&gt; по- прежнему будет действительной &lt;code&gt;String&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f3cfdfa90a10325648e4c2eb952b413419929140" translate="yes" xml:space="preserve">
          <source>The receiver of a method, or the current module.</source>
          <target state="translated">Приемник метода или текущего модуля.</target>
        </trans-unit>
        <trans-unit id="d73164a885c270ed79f7ee9c783984160bde564d" translate="yes" xml:space="preserve">
          <source>The receiving end of a channel has two useful methods: &lt;code&gt;recv&lt;/code&gt; and &lt;code&gt;try_recv&lt;/code&gt;. We&amp;rsquo;re using &lt;code&gt;recv&lt;/code&gt;, short for &lt;em&gt;receive&lt;/em&gt;, which will block the main thread&amp;rsquo;s execution and wait until a value is sent down the channel. Once a value is sent, &lt;code&gt;recv&lt;/code&gt; will return it in a &lt;code&gt;Result&amp;lt;T, E&amp;gt;&lt;/code&gt;. When the sending end of the channel closes, &lt;code&gt;recv&lt;/code&gt; will return an error to signal that no more values will be coming.</source>
          <target state="translated">На принимающей стороне канала есть два полезных метода: &lt;code&gt;recv&lt;/code&gt; и &lt;code&gt;try_recv&lt;/code&gt; . Мы используем &lt;code&gt;recv&lt;/code&gt; , сокращение от &lt;em&gt;приема&lt;/em&gt; , которое блокирует выполнение основного потока и ждет, пока значение не будет отправлено по каналу. После отправки значения &lt;code&gt;recv&lt;/code&gt; вернет его в &lt;code&gt;Result&amp;lt;T, E&amp;gt;&lt;/code&gt; . Когда отправляющий конец канала закрывается, &lt;code&gt;recv&lt;/code&gt; вернет ошибку, чтобы сигнализировать, что больше не будет приходить значений.</target>
        </trans-unit>
        <trans-unit id="bb4caae3b66529c5330d18c3a08329f2bc2f3deb" translate="yes" xml:space="preserve">
          <source>The receiving half of Rust's &lt;a href=&quot;fn.channel&quot;&gt;&lt;code&gt;channel&lt;/code&gt;&lt;/a&gt; (or &lt;a href=&quot;fn.sync_channel&quot;&gt;&lt;code&gt;sync_channel&lt;/code&gt;&lt;/a&gt;) type. This half can only be owned by one thread.</source>
          <target state="translated">Принимающая половина типа &lt;a href=&quot;fn.channel&quot;&gt; &lt;code&gt;channel&lt;/code&gt; &lt;/a&gt; (или &lt;a href=&quot;fn.sync_channel&quot;&gt; &lt;code&gt;sync_channel&lt;/code&gt; &lt;/a&gt; ) Rust . Эта половина может принадлежать только одному потоку.</target>
        </trans-unit>
        <trans-unit id="6ebe525b659c768099f112d22bb95117877daf2e" translate="yes" xml:space="preserve">
          <source>The reference count of the &lt;code&gt;Rc&amp;lt;List&amp;gt;&lt;/code&gt; instances in both &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; are 2 after we change the list in &lt;code&gt;a&lt;/code&gt; to point to &lt;code&gt;b&lt;/code&gt;. At the end of &lt;code&gt;main&lt;/code&gt;, Rust drops the variable &lt;code&gt;b&lt;/code&gt;, which decreases the reference count of the &lt;code&gt;Rc&amp;lt;List&amp;gt;&lt;/code&gt; instance from 2 to 1. The memory that &lt;code&gt;Rc&amp;lt;List&amp;gt;&lt;/code&gt; has on the heap won&amp;rsquo;t be dropped at this point, because its reference count is 1, not 0. Then Rust drops &lt;code&gt;a&lt;/code&gt;, which decreases the reference count of the &lt;code&gt;a&lt;/code&gt;&lt;code&gt;Rc&amp;lt;List&amp;gt;&lt;/code&gt; instance from 2 to 1 as well. This instance's memory can&amp;rsquo;t be dropped either, because the other &lt;code&gt;Rc&amp;lt;List&amp;gt;&lt;/code&gt; instance still refers to it. The memory allocated to the list will remain uncollected forever. To visualize this reference cycle, we&amp;rsquo;ve created a diagram in Figure 15-4.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8b2bfb185407e4c60c25d227a4ff77b2cda29f86" translate="yes" xml:space="preserve">
          <source>The reference count of the &lt;code&gt;Rc&amp;lt;List&amp;gt;&lt;/code&gt; instances in both &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; are 2 after we change the list in &lt;code&gt;a&lt;/code&gt; to point to &lt;code&gt;b&lt;/code&gt;. At the end of &lt;code&gt;main&lt;/code&gt;, Rust will try to drop &lt;code&gt;b&lt;/code&gt; first, which will decrease the count of the &lt;code&gt;Rc&amp;lt;List&amp;gt;&lt;/code&gt; instance in &lt;code&gt;b&lt;/code&gt; by 1.</source>
          <target state="translated">Счетчик ссылок экземпляров &lt;code&gt;Rc&amp;lt;List&amp;gt;&lt;/code&gt; как в &lt;code&gt;a&lt;/code&gt; ,так и в &lt;code&gt;b&lt;/code&gt; равен 2 после того, как мы изменим список в &lt;code&gt;a&lt;/code&gt; , чтобы он указывал на &lt;code&gt;b&lt;/code&gt; . В конце &lt;code&gt;main&lt;/code&gt; Rust попытается сначала сбросить &lt;code&gt;b&lt;/code&gt; , что уменьшит количество экземпляров &lt;code&gt;Rc&amp;lt;List&amp;gt;&lt;/code&gt; в &lt;code&gt;b&lt;/code&gt; на 1.</target>
        </trans-unit>
        <trans-unit id="ae6db410fc6a6a00a988df7e277d31526670b6dd" translate="yes" xml:space="preserve">
          <source>The reference to the moved key is provided so that cloning or copying the key is unnecessary, unlike with &lt;code&gt;.or_insert_with(|| ... )&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0309be91bd54044d4044342a0389163de0a934e4" translate="yes" xml:space="preserve">
          <source>The region of memory beginning at &lt;code&gt;src&lt;/code&gt; with a size of &lt;code&gt;count * size_of::&amp;lt;T&amp;gt;()&lt;/code&gt; bytes must &lt;em&gt;not&lt;/em&gt; overlap with the region of memory beginning at &lt;code&gt;dst&lt;/code&gt; with the same size.</source>
          <target state="translated">Область памяти, начинающаяся с &lt;code&gt;src&lt;/code&gt; и имеющая размер &lt;code&gt;count * size_of::&amp;lt;T&amp;gt;()&lt;/code&gt; байтов, &lt;em&gt;не&lt;/em&gt; должна перекрываться с областью памяти, начинающейся с &lt;code&gt;dst&lt;/code&gt; , с таким же размером.</target>
        </trans-unit>
        <trans-unit id="5dcc17f2dc1b8084d38071ff6ddcb2865d4ada36" translate="yes" xml:space="preserve">
          <source>The region of memory beginning at &lt;code&gt;x&lt;/code&gt; with a size of &lt;code&gt;count * size_of::&amp;lt;T&amp;gt;()&lt;/code&gt; bytes must &lt;em&gt;not&lt;/em&gt; overlap with the region of memory beginning at &lt;code&gt;y&lt;/code&gt; with the same size.</source>
          <target state="translated">Область памяти, начинающаяся с &lt;code&gt;x&lt;/code&gt; и имеющая размер &lt;code&gt;count * size_of::&amp;lt;T&amp;gt;()&lt;/code&gt; байт, &lt;em&gt;не&lt;/em&gt; должна перекрываться с областью памяти, начинающейся с &lt;code&gt;y&lt;/code&gt; , с таким же размером.</target>
        </trans-unit>
        <trans-unit id="6e24cbd3ed4b7a19863f8c010bc7cecf513544b8" translate="yes" xml:space="preserve">
          <source>The relative order of partitioned items is not maintained.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="27d262cc92a6d55445ae1cc06ba8d24d6a4bfc8a" translate="yes" xml:space="preserve">
          <source>The relevant &lt;code&gt;use&lt;/code&gt; statements</source>
          <target state="translated">Соответствующие заявления об &lt;code&gt;use&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="92055677c3977ae45c2e91b99d3cb2b7bc2e7a00" translate="yes" xml:space="preserve">
          <source>The remainder assignment operator &lt;code&gt;%=&lt;/code&gt;.</source>
          <target state="translated">Оператор присваивания остатка &lt;code&gt;%=&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7e1e6181542061352f1920b8d99d81207a670f7f" translate="yes" xml:space="preserve">
          <source>The remainder from the division of two floats.</source>
          <target state="translated">Остальное от деления на два поплавка.</target>
        </trans-unit>
        <trans-unit id="054039eee5819e5face98778f38bf1e0291c343e" translate="yes" xml:space="preserve">
          <source>The remainder has the same sign as the dividend and is computed as: &lt;code&gt;x - (x / y).trunc() * y&lt;/code&gt;.</source>
          <target state="translated">Остаток имеет тот же знак, что и делимое, и вычисляется как: &lt;code&gt;x - (x / y).trunc() * y&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5654d619adf6380504b572e1ea12d7691a4525f9" translate="yes" xml:space="preserve">
          <source>The remainder operator &lt;code&gt;%&lt;/code&gt;.</source>
          <target state="translated">Оператор остатка &lt;code&gt;%&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4b313ceee14929f12b1b754da920f2c480594a9a" translate="yes" xml:space="preserve">
          <source>The remaining characters are alphanumeric or &lt;code&gt;_&lt;/code&gt;.</source>
          <target state="translated">Остальные символы - буквенно-цифровые или &lt;code&gt;_&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="db31fc17b3b16891bdde4b2e11c17a8b55001a20" translate="yes" xml:space="preserve">
          <source>The removed element is replaced by the last element of the vector.</source>
          <target state="translated">Удаленный элемент заменяется последним элементом вектора.</target>
        </trans-unit>
        <trans-unit id="bdcb1bbcfc5506185f4dcdac6bb92b93d0ea27b3" translate="yes" xml:space="preserve">
          <source>The repeated fragment both matches and transcribes to the specified number of the fragment, separated by the separator token. Metavariables are matched to every repetition of their corresponding fragment. For instance, the &lt;code&gt;$( $i:ident ),*&lt;/code&gt; example above matches &lt;code&gt;$i&lt;/code&gt; to all of the identifiers in the list.</source>
          <target state="translated">Повторяющийся фрагмент соответствует указанному номеру фрагмента, разделенному токеном-разделителем, и транскрибируется с ним. Метапеременные сопоставляются с каждым повторением соответствующего им фрагмента. Например, в приведенном выше примере &lt;code&gt;$( $i:ident ),*&lt;/code&gt; &lt;code&gt;$i&lt;/code&gt; соответствует всем идентификаторам в списке.</target>
        </trans-unit>
        <trans-unit id="12103d0e7fb92d8d3b9ddae239cdf39dea7eeb65" translate="yes" xml:space="preserve">
          <source>The repetition operators are:</source>
          <target state="translated">Операторы повторов:</target>
        </trans-unit>
        <trans-unit id="bfcbf2851f89edd4f300f9b36ba95aadb203f98e" translate="yes" xml:space="preserve">
          <source>The representation does &lt;em&gt;not&lt;/em&gt; look like Figure 4-3, which is what memory would look like if Rust instead copied the heap data as well. If Rust did this, the operation &lt;code&gt;s2 = s1&lt;/code&gt; could be very expensive in terms of runtime performance if the data on the heap were large.</source>
          <target state="translated">Представление вовсе &lt;em&gt;не&lt;/em&gt; выглядят как показано на рисунке 4-3, что и память будет выглядеть, если Rust вместо копировали кучи данных , а также. Если бы Rust сделал это, операция &lt;code&gt;s2 = s1&lt;/code&gt; могла бы быть очень дорогой с точки зрения производительности во время выполнения, если бы данные в куче были большими.</target>
        </trans-unit>
        <trans-unit id="0b1df299f3611946c8ad866e3a9d4772fabb543c" translate="yes" xml:space="preserve">
          <source>The representation of a &lt;code&gt;repr(C)&lt;/code&gt; enum with fields is a &lt;code&gt;repr(C)&lt;/code&gt; struct with two fields, also called a &quot;tagged union&quot; in C:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a3948c1d71b2273d20d352ff100e99a529e9f18b" translate="yes" xml:space="preserve">
          <source>The representation of a primitive representation enum is a &lt;code&gt;repr(C)&lt;/code&gt; union of &lt;code&gt;repr(C)&lt;/code&gt; structs for each variant with a field. The first field of each struct in the union is the primitive representation version of the enum with all fields removed (&quot;the tag&quot;) and the remaining fields are the fields of that variant.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ef3b4092c2efea2b55e7548a736c3333a566aec1" translate="yes" xml:space="preserve">
          <source>The representation of a trait object like &lt;code&gt;&amp;amp;SomeTrait&lt;/code&gt;.</source>
          <target state="translated">Представление объекта-признака, такого как &lt;code&gt;&amp;amp;SomeTrait&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4110c125de481ad527206c93b01dbedc11c02bc7" translate="yes" xml:space="preserve">
          <source>The representation of a trait object like &lt;code&gt;&amp;amp;dyn SomeTrait&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="84fd9c512efc7dcedf9b018795fbba5c08fc5ad5" translate="yes" xml:space="preserve">
          <source>The representation of a type can be changed by applying the &lt;code&gt;repr&lt;/code&gt; attribute to it. The following example shows a struct with a &lt;code&gt;C&lt;/code&gt; representation.</source>
          <target state="translated">Представление типа можно изменить, применив к нему атрибут &lt;code&gt;repr&lt;/code&gt; . Следующий пример показывает - структуру с &lt;code&gt;C&lt;/code&gt; представлением.</target>
        </trans-unit>
        <trans-unit id="5a8aa6aa295a219e257360fdb9ca2113bb7bc323" translate="yes" xml:space="preserve">
          <source>The representation of a type can change the padding between fields, but does not change the layout of the fields themselves. For example, a struct with a &lt;code&gt;C&lt;/code&gt; representation that contains a struct &lt;code&gt;Inner&lt;/code&gt; with the default representation will not change the layout of &lt;code&gt;Inner&lt;/code&gt;.</source>
          <target state="translated">Представление типа может изменять отступы между полями, но не меняет макет самих полей. Например, структура с представлением &lt;code&gt;C&lt;/code&gt; , содержащая структуру &lt;code&gt;Inner&lt;/code&gt; с представлением по умолчанию, не изменит макет &lt;code&gt;Inner&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8de668564b1808c69c7a252869635782239a849b" translate="yes" xml:space="preserve">
          <source>The representation semantics of floating-point numbers are described in &lt;a href=&quot;types/numeric&quot;&gt;&quot;Machine Types&quot;&lt;/a&gt;.</source>
          <target state="translated">Семантика представления чисел с плавающей запятой описана в &lt;a href=&quot;types/numeric&quot;&gt;разделе &amp;laquo;Типы машин&amp;raquo;&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="568b4d39b3d684710e1069cdb58107435b4ee105" translate="yes" xml:space="preserve">
          <source>The requested ABI is unsupported by the current target.</source>
          <target state="translated">Запрошенная ПВБ не поддерживается текущей целью.</target>
        </trans-unit>
        <trans-unit id="6079a0a7d416189b9655a6ad531ff1787c361185" translate="yes" xml:space="preserve">
          <source>The required alignment of the referenced value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="48f41ba31da382f1ab342b312f6ebecf708e0a4f" translate="yes" xml:space="preserve">
          <source>The required inputs are these:</source>
          <target state="translated">Требуемые входы таковы:</target>
        </trans-unit>
        <trans-unit id="f6ffffcc1dc56ad2b07c96ba04b8dfcf628fd050" translate="yes" xml:space="preserve">
          <source>The requirements for this program haven&amp;rsquo;t been agreed upon yet, and we&amp;rsquo;re pretty sure the &lt;code&gt;Hello&lt;/code&gt; text at the beginning of the greeting will change. We decided we don&amp;rsquo;t want to have to update the test when the requirements change, so instead of checking for exact equality to the value returned from the &lt;code&gt;greeting&lt;/code&gt; function, we&amp;rsquo;ll just assert that the output contains the text of the input parameter.</source>
          <target state="translated">Требования к этой программе еще не согласованы, и мы уверены, что текст &lt;code&gt;Hello&lt;/code&gt; в начале приветствия изменится. Мы решили, что не хотим обновлять тест при изменении требований, поэтому вместо проверки точного равенства значению, возвращаемому функцией &lt;code&gt;greeting&lt;/code&gt; , мы просто утверждаем, что выходные данные содержат текст входного параметра.</target>
        </trans-unit>
        <trans-unit id="0cbf837e1937a12c606036644e82391851dc8756" translate="yes" xml:space="preserve">
          <source>The responsibilities that remain in the &lt;code&gt;main&lt;/code&gt; function after this process should be limited to the following:</source>
          <target state="translated">Обязанности, которые остаются в &lt;code&gt;main&lt;/code&gt; функции после этого процесса, должны быть ограничены следующим:</target>
        </trans-unit>
        <trans-unit id="fb88378aaf4cdd384feeec625a8c476a227f1fe6" translate="yes" xml:space="preserve">
          <source>The rest of the traits defined in the standard library can&amp;rsquo;t be implemented on your types using &lt;code&gt;derive&lt;/code&gt;. These traits don&amp;rsquo;t have sensible default behavior, so it&amp;rsquo;s up to you to implement them in the way that makes sense for what you&amp;rsquo;re trying to accomplish.</source>
          <target state="translated">Остальные черты, определенные в стандартной библиотеке, не могут быть реализованы в ваших типах с помощью &lt;code&gt;derive&lt;/code&gt; . Эти черты не имеют разумного поведения по умолчанию, поэтому вам решать, как реализовать их так, как это имеет смысл для того, что вы пытаетесь достичь.</target>
        </trans-unit>
        <trans-unit id="3a3c86e891d6ad8a6d17dd1936fd9bfccb1b62f4" translate="yes" xml:space="preserve">
          <source>The rest of this book uses commands that work in both &lt;em&gt;cmd.exe&lt;/em&gt; and PowerShell. If there are specific differences, we&amp;rsquo;ll explain which to use.</source>
          <target state="translated">В остальной части книги используются команды, которые работают как в &lt;em&gt;cmd.exe, так&lt;/em&gt; и в PowerShell. Если есть конкретные различия, мы объясним, что использовать.</target>
        </trans-unit>
        <trans-unit id="00dd9e9169ec993decc3de54bbe98c364e0e7806" translate="yes" xml:space="preserve">
          <source>The rest of this crate documentation is dedicated to pointing out notable features of The Rust Standard Library.</source>
          <target state="translated">Остальная документация ящика посвящена указанию на заметные особенности стандартной библиотеки Rust Standard Library.</target>
        </trans-unit>
        <trans-unit id="ac1c550b13307d7f1181fa4746cc5e5943901d94" translate="yes" xml:space="preserve">
          <source>The rest pattern is always irrefutable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b0cd0ab16fb284f9bcdd09aeae886a98592a2f2d" translate="yes" xml:space="preserve">
          <source>The result can be cast to a pointer of any kind. Ensure that the access is unique (no active references, mutable or not) when casting to &lt;code&gt;&amp;amp;mut T&lt;/code&gt;, and ensure that there are no mutations or mutable aliases going on when casting to &lt;code&gt;&amp;amp;T&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c54e546283bfd6f5bb35e08c8e91500e43fa3efb" translate="yes" xml:space="preserve">
          <source>The result is allocated on the heap.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9f60835a1f670fd1068b73e7310483f7414303f8" translate="yes" xml:space="preserve">
          <source>The result may not be correctly rounded owing to implementation details; &lt;code&gt;self.log2()&lt;/code&gt; can produce more accurate results for base 2, and &lt;code&gt;self.log10()&lt;/code&gt; can produce more accurate results for base 10.</source>
          <target state="translated">Результат может быть некорректно округлен из-за деталей реализации; &lt;code&gt;self.log2()&lt;/code&gt; может дать более точные результаты для базы 2, а &lt;code&gt;self.log10()&lt;/code&gt; может дать более точные результаты для базы 10.</target>
        </trans-unit>
        <trans-unit id="c4dbebfb961a1bddcfad953b06a027b749fbba28" translate="yes" xml:space="preserve">
          <source>The result of &lt;a href=&quot;expressions/operator-expr#the-dereference-operator&quot;&gt;dereferencing&lt;/a&gt; an expression with type &lt;a href=&quot;../std/boxed/struct.box&quot;&gt;&lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt; and that can also be moved out of.</source>
          <target state="translated">Результат &lt;a href=&quot;expressions/operator-expr#the-dereference-operator&quot;&gt;разыменования&lt;/a&gt; выражения с типом &lt;a href=&quot;../std/boxed/struct.box&quot;&gt; &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; &lt;/a&gt; которое также можно переместить.</target>
        </trans-unit>
        <trans-unit id="fe2526308745be82b19ed557143eb06c9172e9c2" translate="yes" xml:space="preserve">
          <source>The result of a generator resumption.</source>
          <target state="translated">Результат возобновления работы генератора.</target>
        </trans-unit>
        <trans-unit id="d471d20c06ef14c004fab8262f7528514deaa1c4" translate="yes" xml:space="preserve">
          <source>The result of casting a reference to a pointer is valid for as long as the underlying object is live and no reference (just raw pointers) is used to access the same memory.</source>
          <target state="translated">Результат приведения ссылки на указатель действителен до тех пор,пока объект,лежащий в основе,жив,и никакая ссылка (только необработанные указатели)не используется для доступа к той же самой памяти.</target>
        </trans-unit>
        <trans-unit id="ac56fae426229e4d543dba38661557fbee8bb52d" translate="yes" xml:space="preserve">
          <source>The result of the &lt;a href=&quot;../macro.format_args&quot;&gt;&lt;code&gt;format_args!&lt;/code&gt;&lt;/a&gt; macro is a value of type &lt;a href=&quot;struct.arguments&quot;&gt;&lt;code&gt;fmt::Arguments&lt;/code&gt;&lt;/a&gt;. This structure can then be passed to the &lt;a href=&quot;../macro.write&quot;&gt;&lt;code&gt;write&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../macro.format&quot;&gt;&lt;code&gt;format&lt;/code&gt;&lt;/a&gt; functions inside this module in order to process the format string. The goal of this macro is to even further prevent intermediate allocations when dealing with formatting strings.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="31cd246d6c4827dc128a4e9ac189ceccd07f4e85" translate="yes" xml:space="preserve">
          <source>The result of the &lt;a href=&quot;../macro.format_args&quot;&gt;&lt;code&gt;format_args!&lt;/code&gt;&lt;/a&gt; macro is a value of type &lt;a href=&quot;struct.arguments&quot;&gt;&lt;code&gt;fmt::Arguments&lt;/code&gt;&lt;/a&gt;. This structure can then be passed to the &lt;a href=&quot;fn.write&quot;&gt;&lt;code&gt;write&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;fn.format&quot;&gt;&lt;code&gt;format&lt;/code&gt;&lt;/a&gt; functions inside this module in order to process the format string. The goal of this macro is to even further prevent intermediate allocations when dealing formatting strings.</source>
          <target state="translated">Результат &lt;a href=&quot;../macro.format_args&quot;&gt; &lt;code&gt;format_args!&lt;/code&gt; &lt;/a&gt;макрос - это значение типа &lt;a href=&quot;struct.arguments&quot;&gt; &lt;code&gt;fmt::Arguments&lt;/code&gt; &lt;/a&gt; . Затем эту структуру можно передать функциям &lt;a href=&quot;fn.write&quot;&gt; &lt;code&gt;write&lt;/code&gt; &lt;/a&gt; и &lt;a href=&quot;fn.format&quot;&gt; &lt;code&gt;format&lt;/code&gt; &lt;/a&gt; внутри этого модуля для обработки строки формата. Цель этого макроса - еще больше предотвратить промежуточное выделение памяти при форматировании строк.</target>
        </trans-unit>
        <trans-unit id="1c32345d3d6f612f235d03a8cd84044465cbfeea" translate="yes" xml:space="preserve">
          <source>The result will represent the IP address &lt;code&gt;a:b:c:d:e:f:g:h&lt;/code&gt;.</source>
          <target state="translated">Результатом будет IP-адрес &lt;code&gt;a:b:c:d:e:f:g:h&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="99c7c63b15fc6ea4f165265a5fd114fc5db86d31" translate="yes" xml:space="preserve">
          <source>The result will represent the IP address &lt;code&gt;a&lt;/code&gt;.&lt;code&gt;b&lt;/code&gt;.&lt;code&gt;c&lt;/code&gt;.&lt;code&gt;d&lt;/code&gt;.</source>
          <target state="translated">Результатом будет IP-адрес &lt;code&gt;a&lt;/code&gt; . &lt;code&gt;b&lt;/code&gt; . &lt;code&gt;c&lt;/code&gt; . &lt;code&gt;d&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7373e6f7caa0a9dff8d78cf60558cf221157bd80" translate="yes" xml:space="preserve">
          <source>The resulting layout will be the same as that of a C struct containing two fields with the layouts of &lt;code&gt;self&lt;/code&gt; and &lt;code&gt;next&lt;/code&gt;, in that order.</source>
          <target state="translated">Результирующий макет будет таким же, как макет структуры C, содержащей два поля с макетами &lt;code&gt;self&lt;/code&gt; и &lt;code&gt;next&lt;/code&gt; в указанном порядке.</target>
        </trans-unit>
        <trans-unit id="99a0997f56bdadd8bd20428a4a2ef3bbae789fac" translate="yes" xml:space="preserve">
          <source>The resulting lifetime is bound to self so this behaves &quot;as if&quot; it were actually an instance of T that is getting borrowed. If a longer (unbound) lifetime is needed, use &lt;code&gt;&amp;amp;*my_ptr.as_ptr()&lt;/code&gt;.</source>
          <target state="translated">Результирующее время жизни привязано к self, поэтому он ведет себя &amp;laquo;так, как если бы&amp;raquo; на самом деле был заимствованным экземпляром T. Если требуется более длительное (несвязанное) время жизни, используйте &lt;code&gt;&amp;amp;*my_ptr.as_ptr()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f78e2e736259493757a0ced96e6b992b486267c6" translate="yes" xml:space="preserve">
          <source>The resulting lifetime is bound to self so this behaves &quot;as if&quot; it were actually an instance of T that is getting borrowed. If a longer (unbound) lifetime is needed, use &lt;code&gt;&amp;amp;mut *my_ptr.as_ptr()&lt;/code&gt;.</source>
          <target state="translated">Результирующее время жизни привязано к self, поэтому он ведет себя &amp;laquo;так, как если бы&amp;raquo; на самом деле был заимствованным экземпляром T. Если требуется более длительное (несвязанное) время жизни, используйте &lt;code&gt;&amp;amp;mut *my_ptr.as_ptr()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9220ca335fae6d1972b4901944a1126d0f38ae8e" translate="yes" xml:space="preserve">
          <source>The resulting pointer does not need to be in bounds, but it is potentially hazardous to dereference (which requires &lt;code&gt;unsafe&lt;/code&gt;).</source>
          <target state="translated">Результирующий указатель не обязательно должен находиться в границах, но он потенциально опасен для разыменования (что требует &lt;code&gt;unsafe&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="81b4f59283eb3ce773831a86dd58d26e19da85b4" translate="yes" xml:space="preserve">
          <source>The resulting pointer does not need to be in bounds, but it is potentially hazardous to dereference (which requires &lt;code&gt;unsafe&lt;/code&gt;). In particular, the resulting pointer may &lt;em&gt;not&lt;/em&gt; be used to access a different allocated object than the one &lt;code&gt;self&lt;/code&gt; points to. In other words, &lt;code&gt;x.wrapping_offset(y.wrapping_offset_from(x))&lt;/code&gt; is &lt;em&gt;not&lt;/em&gt; the same as &lt;code&gt;y&lt;/code&gt;, and dereferencing it is undefined behavior unless &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; point into the same allocated object.</source>
          <target state="translated">Результирующий указатель не обязательно должен находиться в границах, но он потенциально опасен для разыменования (что требует &lt;code&gt;unsafe&lt;/code&gt; ). В частности, результирующий указатель может &lt;em&gt;не&lt;/em&gt; использоваться для доступа к другому выделенный объект , чем тот , &lt;code&gt;self&lt;/code&gt; указывает. Другими словами, &lt;code&gt;x.wrapping_offset(y.wrapping_offset_from(x))&lt;/code&gt; является &lt;em&gt;не&lt;/em&gt; такой же , как &lt;code&gt;y&lt;/code&gt; , и разыменовании его поведение не определено , если &lt;code&gt;x&lt;/code&gt; и &lt;code&gt;y&lt;/code&gt; точки в ту же выделенного объекта.</target>
        </trans-unit>
        <trans-unit id="52dcba8fc55d983793d49be111c09fcb50eb3b76" translate="yes" xml:space="preserve">
          <source>The resulting pointer will have provenance of &lt;code&gt;val&lt;/code&gt;, i.e., for a fat pointer, this operation is semantically the same as creating a new fat pointer with the data pointer value of &lt;code&gt;val&lt;/code&gt; but the metadata of &lt;code&gt;self&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="277fa9ca5234a7d85c4310d360b586b5679536d7" translate="yes" xml:space="preserve">
          <source>The resulting type after applying the &lt;code&gt;!&lt;/code&gt; operator.</source>
          <target state="translated">Результирующий тип после применения &lt;code&gt;!&lt;/code&gt; оператор.</target>
        </trans-unit>
        <trans-unit id="e0fff7e85f4e0422c5e3edd89994815fd0fa33fe" translate="yes" xml:space="preserve">
          <source>The resulting type after applying the &lt;code&gt;%&lt;/code&gt; operator.</source>
          <target state="translated">Результирующий тип после применения оператора &lt;code&gt;%&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="bb2df529c05fcb3e3ae1db4ab5bf5c9f054fbf92" translate="yes" xml:space="preserve">
          <source>The resulting type after applying the &lt;code&gt;&amp;amp;&lt;/code&gt; operator.</source>
          <target state="translated">Результирующий тип после применения оператора &lt;code&gt;&amp;amp;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="36522abccd158f4a83c30f6cbe7b1f733a467a76" translate="yes" xml:space="preserve">
          <source>The resulting type after applying the &lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt; operator.</source>
          <target state="translated">Результирующий тип после применения оператора &lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1fe31e03010cc02b7a70dec74838acc1bf92f653" translate="yes" xml:space="preserve">
          <source>The resulting type after applying the &lt;code&gt;&amp;lt;&amp;lt;&lt;/code&gt; operator.</source>
          <target state="translated">Результирующий тип после применения оператора &lt;code&gt;&amp;lt;&amp;lt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="49f0b7e4d4d9571dc029b144b407d2d00db70bde" translate="yes" xml:space="preserve">
          <source>The resulting type after applying the &lt;code&gt;*&lt;/code&gt; operator.</source>
          <target state="translated">Результирующий тип после применения оператора &lt;code&gt;*&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5440b4202f92f92a6ad5f44ab02bb1836dc990f2" translate="yes" xml:space="preserve">
          <source>The resulting type after applying the &lt;code&gt;+&lt;/code&gt; operator.</source>
          <target state="translated">Результирующий тип после применения оператора &lt;code&gt;+&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4a8bf360ec637ebc225332beb0f574739bca97a7" translate="yes" xml:space="preserve">
          <source>The resulting type after applying the &lt;code&gt;-&lt;/code&gt; operator.</source>
          <target state="translated">Результирующий тип после применения оператора &lt;code&gt;-&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="541f705e1fd40afef0d79bd7f0f4268fa7398a27" translate="yes" xml:space="preserve">
          <source>The resulting type after applying the &lt;code&gt;/&lt;/code&gt; operator.</source>
          <target state="translated">Результирующий тип после применения оператора &lt;code&gt;/&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5fff5e225b75cdf382af9bb7542d50be9c4363ed" translate="yes" xml:space="preserve">
          <source>The resulting type after applying the &lt;code&gt;^&lt;/code&gt; operator.</source>
          <target state="translated">Результирующий тип после применения оператора &lt;code&gt;^&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="fee8ba95ad793c2c7dda2e8911dcb02800ab8ed4" translate="yes" xml:space="preserve">
          <source>The resulting type after applying the &lt;code&gt;|&lt;/code&gt; operator.</source>
          <target state="translated">Результирующий тип после применения &lt;code&gt;|&lt;/code&gt; оператор.</target>
        </trans-unit>
        <trans-unit id="0473503cf115b2a975e15da3f35244db7bce3d66" translate="yes" xml:space="preserve">
          <source>The resulting type after concatenation</source>
          <target state="translated">Результирующий тип после конкатенирования</target>
        </trans-unit>
        <trans-unit id="dbf5bd29abfe066aae072317675dfaca543c15fe" translate="yes" xml:space="preserve">
          <source>The resulting type after dereferencing.</source>
          <target state="translated">Результирующий тип после разыменования.</target>
        </trans-unit>
        <trans-unit id="76a4c8bb9eba17c026c554fa00db407a4ed92a09" translate="yes" xml:space="preserve">
          <source>The resulting type after obtaining ownership.</source>
          <target state="translated">Результирующий тип после получения права собственности.</target>
        </trans-unit>
        <trans-unit id="04c53e531d342d2fc7cb2f6812bb0980d9b695cc" translate="yes" xml:space="preserve">
          <source>The resulting vector can be converted back into a box via &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt;'s &lt;code&gt;into_boxed_slice&lt;/code&gt; method.</source>
          <target state="translated">Полученный вектор может быть преобразован обратно в коробку через &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; &amp;laquo;ы &lt;code&gt;into_boxed_slice&lt;/code&gt; метода.</target>
        </trans-unit>
        <trans-unit id="c631dfaa5b94e5b7afa0d3baba880ecf32c3c788" translate="yes" xml:space="preserve">
          <source>The return type in the desugaring is assumed to capture all lifetime parameters from the &lt;code&gt;async fn&lt;/code&gt; declaration. This can be seen in the desugared example above, which explicitly outlives, and hence captures, &lt;code&gt;'a&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8b3c91f66fb428df18fd8a3b968cf270fb22e4f6" translate="yes" xml:space="preserve">
          <source>The return type isn&amp;rsquo;t &lt;code&gt;Self&lt;/code&gt;.</source>
          <target state="translated">Тип возвращаемого значения не является &lt;code&gt;Self&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="87f17fcd6dd95b0936e246de85107f7f76aa4067" translate="yes" xml:space="preserve">
          <source>The return type of &lt;a href=&quot;../primitive.str#method.escape_debug&quot;&gt;&lt;code&gt;str::escape_debug&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Тип возвращаемого значения &lt;a href=&quot;../primitive.str#method.escape_debug&quot;&gt; &lt;code&gt;str::escape_debug&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="db39743b7e18afb4b0cbc402d05c64c31d6c2284" translate="yes" xml:space="preserve">
          <source>The return type of &lt;a href=&quot;../primitive.str#method.escape_default&quot;&gt;&lt;code&gt;str::escape_default&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Тип возвращаемого значения &lt;a href=&quot;../primitive.str#method.escape_default&quot;&gt; &lt;code&gt;str::escape_default&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="0d7f1d5c28f55e7c46b28c80bf7c947a04177ba0" translate="yes" xml:space="preserve">
          <source>The return type of &lt;a href=&quot;../primitive.str#method.escape_unicode&quot;&gt;&lt;code&gt;str::escape_unicode&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Тип возвращаемого значения &lt;a href=&quot;../primitive.str#method.escape_unicode&quot;&gt; &lt;code&gt;str::escape_unicode&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="46984a9d3d93237d6af0b4171b9091187f1fd40f" translate="yes" xml:space="preserve">
          <source>The return type of &lt;code&gt;read_input()&lt;/code&gt;, &lt;a href=&quot;type.result&quot;&gt;&lt;code&gt;io::Result&amp;lt;()&amp;gt;&lt;/code&gt;&lt;/a&gt;, is a very common type for functions which don't have a 'real' return value, but do want to return errors if they happen. In this case, the only purpose of this function is to read the line and print it, so we use &lt;code&gt;()&lt;/code&gt;.</source>
          <target state="translated">Тип возврата &lt;code&gt;read_input()&lt;/code&gt; , &lt;a href=&quot;type.result&quot;&gt; &lt;code&gt;io::Result&amp;lt;()&amp;gt;&lt;/code&gt; &lt;/a&gt; , является очень распространенным типом для функций, которые не имеют &amp;laquo;реального&amp;raquo; возвращаемого значения, но хотят возвращать ошибки, если они произошли. В этом случае единственная цель этой функции - прочитать строку и распечатать ее, поэтому мы используем &lt;code&gt;()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="dc8688a274902ed01a0ecc5033bf35069d5bb391" translate="yes" xml:space="preserve">
          <source>The return value is a result indicating whether the new value was written and containing the previous value. On success this value is guaranteed to be equal to &lt;code&gt;current&lt;/code&gt;.</source>
          <target state="translated">Возвращаемое значение - это результат, показывающий, было ли записано новое значение и содержит ли предыдущее значение. В случае успеха это значение гарантированно будет равно &lt;code&gt;current&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6b1ea39b856b2d5fee30e6b97044d7752b536c14" translate="yes" xml:space="preserve">
          <source>The return value is always the previous value. If it is equal to &lt;code&gt;current&lt;/code&gt;, then the value was updated.</source>
          <target state="translated">Возвращаемое значение всегда является предыдущим значением. Если он равен &lt;code&gt;current&lt;/code&gt; , значит, значение было обновлено.</target>
        </trans-unit>
        <trans-unit id="fc0a38af017feefeb9d3ecc2b64620f7588f7e32" translate="yes" xml:space="preserve">
          <source>The return value may change depending on the compiler version and unsafe code may not rely on the result of this function for soundness. It is suggested to only use this function for performance optimizations where spurious &lt;code&gt;false&lt;/code&gt; return values by this function do not affect the outcome, but just the performance. The consequences of using this method to make runtime and compile-time code behave differently have not been explored. This method should not be used to introduce such differences, and it should also not be stabilized before we have a better understanding of this issue.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8bec0cf03017a322224afce0dc723c8da3b1c3f8" translate="yes" xml:space="preserve">
          <source>The return value of this function has no meaning if &lt;code&gt;align&lt;/code&gt; is not a power-of-two.</source>
          <target state="translated">Возвращаемое значение этой функции не имеет значения, если &lt;code&gt;align&lt;/code&gt; не является степенью двойки.</target>
        </trans-unit>
        <trans-unit id="60b397a9e27c756600834e9e8bc999da0f2e38e6" translate="yes" xml:space="preserve">
          <source>The returned 64-bit value is equivalent to a &lt;a href=&quot;https://docs.microsoft.com/en-us/windows/win32/api/minwinbase/ns-minwinbase-filetime&quot;&gt;&lt;code&gt;FILETIME&lt;/code&gt;&lt;/a&gt; struct, which represents the number of 100-nanosecond intervals since January 1, 1601 (UTC). The struct is automatically converted to a &lt;code&gt;u64&lt;/code&gt; value, as that is the recommended way to use it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9b9e4888166c03a2354c980d922cf25c13eb44d0" translate="yes" xml:space="preserve">
          <source>The returned 64-bit value is equivalent to a &lt;a href=&quot;https://msdn.microsoft.com/en-us/library/windows/desktop/ms724284.aspx&quot;&gt;&lt;code&gt;FILETIME&lt;/code&gt;&lt;/a&gt; struct, which represents the number of 100-nanosecond intervals since January 1, 1601 (UTC). The struct is automatically converted to a &lt;code&gt;u64&lt;/code&gt; value, as that is the recommended way to use it.</source>
          <target state="translated">Возвращаемое 64-битное значение эквивалентно структуре &lt;a href=&quot;https://msdn.microsoft.com/en-us/library/windows/desktop/ms724284.aspx&quot;&gt; &lt;code&gt;FILETIME&lt;/code&gt; &lt;/a&gt; , которая представляет количество 100-наносекундных интервалов с 1 января 1601 года (UTC). Структура автоматически преобразуется в значение &lt;code&gt;u64&lt;/code&gt; , так как это рекомендуемый способ ее использования.</target>
        </trans-unit>
        <trans-unit id="f17e579c0925b04170923132b19bbc2e328718e7" translate="yes" xml:space="preserve">
          <source>The returned &lt;a href=&quot;struct.range&quot;&gt;&lt;code&gt;Range&lt;/code&gt;&lt;/a&gt; is safe to pass to &lt;a href=&quot;../primitive.slice#method.get_unchecked&quot;&gt;&lt;code&gt;slice::get_unchecked&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../primitive.slice#method.get_unchecked_mut&quot;&gt;&lt;code&gt;slice::get_unchecked_mut&lt;/code&gt;&lt;/a&gt; for slices of the given length.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7e9caf07f01ab2822f3d6ed99758b9360c5c26af" translate="yes" xml:space="preserve">
          <source>The returned &lt;a href=&quot;struct.tcplistener&quot;&gt;&lt;code&gt;TcpListener&lt;/code&gt;&lt;/a&gt; is a reference to the same socket that this object references. Both handles can be used to accept incoming connections and options set on one listener will affect the other.</source>
          <target state="translated">Возвращается &lt;a href=&quot;struct.tcplistener&quot;&gt; &lt;code&gt;TcpListener&lt;/code&gt; &lt;/a&gt; является ссылкой на тот же сокет , что этот объект ссылки. Оба дескриптора можно использовать для приема входящих подключений, а параметры, установленные для одного слушателя, будут влиять на другой.</target>
        </trans-unit>
        <trans-unit id="ded74a0ee30df2ab90178bc7d8c79f6560c92452" translate="yes" xml:space="preserve">
          <source>The returned &lt;a href=&quot;struct.waittimeoutresult&quot;&gt;&lt;code&gt;WaitTimeoutResult&lt;/code&gt;&lt;/a&gt; value indicates if the timeout is known to have elapsed without the condition being met.</source>
          <target state="translated">Возвращенный &lt;a href=&quot;struct.waittimeoutresult&quot;&gt; &lt;code&gt;WaitTimeoutResult&lt;/code&gt; &lt;/a&gt; значение указывает , если тайм - аут , как известно, прошло без условия выполняются.</target>
        </trans-unit>
        <trans-unit id="38736111afdf682fcdb07c273e755038e1599f59" translate="yes" xml:space="preserve">
          <source>The returned &lt;a href=&quot;struct.waittimeoutresult&quot;&gt;&lt;code&gt;WaitTimeoutResult&lt;/code&gt;&lt;/a&gt; value indicates if the timeout is known to have elapsed.</source>
          <target state="translated">Возвращенный &lt;a href=&quot;struct.waittimeoutresult&quot;&gt; &lt;code&gt;WaitTimeoutResult&lt;/code&gt; &lt;/a&gt; значение указывает , если тайм - аут , как известно, прошло.</target>
        </trans-unit>
        <trans-unit id="a4d3afc22fc51194d42ebf97c4d4c71d6cf8d193" translate="yes" xml:space="preserve">
          <source>The returned &lt;code&gt;Read&lt;/code&gt; instance will first read all bytes from this object until EOF is encountered. Afterwards the output is equivalent to the output of &lt;code&gt;next&lt;/code&gt;.</source>
          <target state="translated">Возвращенный &lt;code&gt;Read&lt;/code&gt; экземпляр будет сначала прочитать все байты от этого объекта до EOF не встречается. После этого вывод будет эквивалентен выводу &lt;code&gt;next&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c46cae45e911aa3ffb2e82c2b8df4d3f09691f8b" translate="yes" xml:space="preserve">
          <source>The returned &lt;code&gt;TcpStream&lt;/code&gt; is a reference to the same stream that this object references. Both handles will read and write the same stream of data, and options set on one stream will be propagated to the other stream.</source>
          <target state="translated">Возвращается &lt;code&gt;TcpStream&lt;/code&gt; является ссылкой на тот же поток , что этот объект ссылки. Оба дескриптора будут читать и записывать один и тот же поток данных, а параметры, установленные для одного потока, будут распространяться на другой поток.</target>
        </trans-unit>
        <trans-unit id="f1bab9e66e16ee3bc6f8eaaaaca9a4320b7da4d4" translate="yes" xml:space="preserve">
          <source>The returned &lt;code&gt;UdpSocket&lt;/code&gt; is a reference to the same socket that this object references. Both handles will read and write the same port, and options set on one socket will be propagated to the other.</source>
          <target state="translated">Возвращается &lt;code&gt;UdpSocket&lt;/code&gt; является ссылкой на тот же сокет , что этот объект ссылки. Оба дескриптора будут читать и записывать один и тот же порт, а параметры, установленные для одного сокета, будут распространяться на другой.</target>
        </trans-unit>
        <trans-unit id="c1a563924be47f2135363b13913bddb8d81845c6" translate="yes" xml:space="preserve">
          <source>The returned &lt;code&gt;UnixDatagram&lt;/code&gt; is a reference to the same socket that this object references. Both handles can be used to accept incoming connections and options set on one side will affect the other.</source>
          <target state="translated">Возвращается &lt;code&gt;UnixDatagram&lt;/code&gt; является ссылкой на тот же сокет , что этот объект ссылки. Оба дескриптора могут использоваться для приема входящих соединений, а параметры, установленные на одной стороне, будут влиять на другую.</target>
        </trans-unit>
        <trans-unit id="3a69722b38c150ace8c17a0ad6c7500758c624a4" translate="yes" xml:space="preserve">
          <source>The returned &lt;code&gt;UnixListener&lt;/code&gt; is a reference to the same socket that this object references. Both handles can be used to accept incoming connections and options set on one listener will affect the other.</source>
          <target state="translated">Возвращается &lt;code&gt;UnixListener&lt;/code&gt; является ссылкой на тот же сокет , что этот объект ссылки. Оба дескриптора можно использовать для приема входящих подключений, а параметры, установленные для одного слушателя, будут влиять на другой.</target>
        </trans-unit>
        <trans-unit id="144b7ef360f6249426bb7be199321625b6985707" translate="yes" xml:space="preserve">
          <source>The returned &lt;code&gt;UnixStream&lt;/code&gt; is a reference to the same stream that this object references. Both handles will read and write the same stream of data, and options set on one stream will be propagated to the other stream.</source>
          <target state="translated">Возвращается &lt;code&gt;UnixStream&lt;/code&gt; является ссылкой на тот же поток , что этот объект ссылки. Оба дескриптора будут читать и записывать один и тот же поток данных, а параметры, установленные для одного потока, будут распространяться на другой поток.</target>
        </trans-unit>
        <trans-unit id="cb880b11df63d1e3077076bea22bb8b51ec8054d" translate="yes" xml:space="preserve">
          <source>The returned adaptor also implements &lt;code&gt;AllocRef&lt;/code&gt; and will simply borrow this.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4ae8d8d70f6a5dbf383ce8f90712add3666ba1c3" translate="yes" xml:space="preserve">
          <source>The returned adaptor also implements &lt;code&gt;Allocator&lt;/code&gt; and will simply borrow this.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e3560a746a4c0e2ffb1141c7abaa941ae137d7b4" translate="yes" xml:space="preserve">
          <source>The returned adaptor also implements &lt;code&gt;Read&lt;/code&gt; and will simply borrow this current reader.</source>
          <target state="translated">Возвращенный адаптер также реализует &lt;code&gt;Read&lt;/code&gt; и просто заимствует текущий читатель.</target>
        </trans-unit>
        <trans-unit id="facac298df7b4792f8b8fe4cbcbc0a4967c70852" translate="yes" xml:space="preserve">
          <source>The returned adaptor also implements &lt;code&gt;Write&lt;/code&gt; and will simply borrow this current writer.</source>
          <target state="translated">Возвращенный адаптер также реализует &lt;code&gt;Write&lt;/code&gt; и просто заимствует текущий модуль записи.</target>
        </trans-unit>
        <trans-unit id="e389b4884c363b3fc760ebd7d93cdcb95de946c0" translate="yes" xml:space="preserve">
          <source>The returned block is suitable for passing to the &lt;code&gt;alloc&lt;/code&gt;/&lt;code&gt;realloc&lt;/code&gt; methods of this allocator.</source>
          <target state="translated">Возвращаются блок подходит для перехода к &lt;code&gt;alloc&lt;/code&gt; / &lt;code&gt;realloc&lt;/code&gt; методы этого распределителя.</target>
        </trans-unit>
        <trans-unit id="c91d87a8c74843f84b212121082c194e485a54b8" translate="yes" xml:space="preserve">
          <source>The returned block may have a larger size than specified by &lt;code&gt;layout.size()&lt;/code&gt;, and may or may not have its contents initialized.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b4d367aab1faeec6de58c9c9955a240781bdbe40" translate="yes" xml:space="preserve">
          <source>The returned block of storage may or may not have its contents initialized. (Extension subtraits might restrict this behavior, e.g., to ensure initialization to particular sets of bit patterns.)</source>
          <target state="translated">Возвращаемый блок хранения может быть инициализирован или не инициализирован.(Подтрейты расширения могут ограничивать это поведение,например,для обеспечения инициализации определенных наборов битовых паттернов).</target>
        </trans-unit>
        <trans-unit id="ba2ebcfc4f605284f02edd68881e9753988594f5" translate="yes" xml:space="preserve">
          <source>The returned boolean is &lt;code&gt;false&lt;/code&gt; only if the timeout is known to have elapsed.</source>
          <target state="translated">Возвращаемое логическое значение является &lt;code&gt;false&lt;/code&gt; только если известно, что время ожидания истекло.</target>
        </trans-unit>
        <trans-unit id="ef190a0092cd801a89bd32ca6438155668c7c711" translate="yes" xml:space="preserve">
          <source>The returned buffer does &lt;strong&gt;not&lt;/strong&gt; contain the trailing nul terminator, and it is guaranteed to not have any interior nul bytes.</source>
          <target state="translated">Возвращаемый буфер &lt;strong&gt;не&lt;/strong&gt; содержит завершающего нулевого терминатора, и он гарантированно не имеет внутренних нулевых байтов.</target>
        </trans-unit>
        <trans-unit id="c21f9df3ca074ffdfcc498df18bd9b3644edeb21" translate="yes" xml:space="preserve">
          <source>The returned iterator contains a snapshot of the process's environment variables at the time of this invocation. Modifications to environment variables afterwards will not be reflected in the returned iterator.</source>
          <target state="translated">Возвращаемый итератор содержит снимок переменных окружения процесса на момент вызова.Модификации переменных окружения впоследствии не будут отражены в возвращаемом итераторе.</target>
        </trans-unit>
        <trans-unit id="94742684e4e1a0a940d70b49afd50e4db443fbed" translate="yes" xml:space="preserve">
          <source>The returned iterator may not actually yield any values depending on the outcome of any resolution performed.</source>
          <target state="translated">Возвращаемый итератор может фактически не давать никаких значений в зависимости от результата любого выполненного разрешения.</target>
        </trans-unit>
        <trans-unit id="2aad97e80249c67281fd50b9abdb7bf4c0bc39de" translate="yes" xml:space="preserve">
          <source>The returned iterator might panic if the to-be-returned index would overflow a &lt;a href=&quot;../primitive.usize&quot;&gt;&lt;code&gt;usize&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;../primitive.usize&quot;&gt; &lt;code&gt;usize&lt;/code&gt; &lt;/a&gt; итератор может вызвать панику, если возвращаемый индекс переполнит usize .</target>
        </trans-unit>
        <trans-unit id="3f6e0a2276ef2ac22ba60fa606f31e8d0538ab17" translate="yes" xml:space="preserve">
          <source>The returned iterator requires that the pattern supports a reverse search, and it will be a &lt;a href=&quot;../iter/trait.doubleendediterator&quot;&gt;&lt;code&gt;DoubleEndedIterator&lt;/code&gt;&lt;/a&gt; if a forward/reverse search yields the same elements.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="212e83558d8f38fe873f76d6ab8c409b36c6c1ca" translate="yes" xml:space="preserve">
          <source>The returned iterator requires that the pattern supports a reverse search, and it will be a &lt;a href=&quot;iter/trait.doubleendediterator&quot;&gt;&lt;code&gt;DoubleEndedIterator&lt;/code&gt;&lt;/a&gt; if a forward/reverse search yields the same elements.</source>
          <target state="translated">&lt;a href=&quot;iter/trait.doubleendediterator&quot;&gt; &lt;code&gt;DoubleEndedIterator&lt;/code&gt; &lt;/a&gt; итератор требует, чтобы шаблон поддерживал обратный поиск, и это будет DoubleEndedIterator, если прямой / обратный поиск дает те же элементы.</target>
        </trans-unit>
        <trans-unit id="0a192fbaedef699058263c6cf3d017b9555c1581" translate="yes" xml:space="preserve">
          <source>The returned iterator requires that the pattern supports a reverse search, and it will be double ended if a forward/reverse search yields the same elements.</source>
          <target state="translated">Возвращаемый итератор требует,чтобы шаблон поддерживал обратный поиск,и он будет двойным,если при прямом/обратном поиске будут получены одни и те же элементы.</target>
        </trans-unit>
        <trans-unit id="31cf06022e130c2b8e694b6f17ab8cbe9626501c" translate="yes" xml:space="preserve">
          <source>The returned iterator will be a &lt;a href=&quot;../iter/trait.doubleendediterator&quot;&gt;&lt;code&gt;DoubleEndedIterator&lt;/code&gt;&lt;/a&gt; if the pattern allows a reverse search and forward/reverse search yields the same elements. This is true for, e.g., &lt;a href=&quot;../primitive.char&quot;&gt;&lt;code&gt;char&lt;/code&gt;&lt;/a&gt;, but not for &lt;code&gt;&amp;amp;str&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4543e6c97747a65b55c800608ca5f7c928ee84b5" translate="yes" xml:space="preserve">
          <source>The returned iterator will be a &lt;a href=&quot;iter/trait.doubleendediterator&quot;&gt;&lt;code&gt;DoubleEndedIterator&lt;/code&gt;&lt;/a&gt; if the pattern allows a reverse search and forward/reverse search yields the same elements. This is true for, e.g., &lt;a href=&quot;../char/index&quot;&gt;&lt;code&gt;char&lt;/code&gt;&lt;/a&gt;, but not for &lt;code&gt;&amp;amp;str&lt;/code&gt;.</source>
          <target state="translated">&lt;a href=&quot;iter/trait.doubleendediterator&quot;&gt; &lt;code&gt;DoubleEndedIterator&lt;/code&gt; &lt;/a&gt; итератором будет DoubleEndedIterator, если шаблон допускает обратный поиск, а прямой / обратный поиск дает те же элементы. Это верно, например, для &lt;a href=&quot;../char/index&quot;&gt; &lt;code&gt;char&lt;/code&gt; &lt;/a&gt; , но не для &lt;code&gt;&amp;amp;str&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="fcd14ee368ff1244ad97f001dc72e74042b0095f" translate="yes" xml:space="preserve">
          <source>The returned iterator will be a &lt;a href=&quot;iter/trait.doubleendediterator&quot;&gt;&lt;code&gt;DoubleEndedIterator&lt;/code&gt;&lt;/a&gt; if the pattern allows a reverse search and forward/reverse search yields the same elements. This is true for, e.g., &lt;a href=&quot;char/index&quot;&gt;&lt;code&gt;char&lt;/code&gt;&lt;/a&gt;, but not for &lt;code&gt;&amp;amp;str&lt;/code&gt;.</source>
          <target state="translated">&lt;a href=&quot;iter/trait.doubleendediterator&quot;&gt; &lt;code&gt;DoubleEndedIterator&lt;/code&gt; &lt;/a&gt; итератором будет DoubleEndedIterator, если шаблон допускает обратный поиск, а прямой / обратный поиск дает те же элементы. Это верно, например, для &lt;a href=&quot;char/index&quot;&gt; &lt;code&gt;char&lt;/code&gt; &lt;/a&gt; , но не для &lt;code&gt;&amp;amp;str&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="fb1179f626056fe35d781c0e7e7072fe8a2697c8" translate="yes" xml:space="preserve">
          <source>The returned iterator will be a &lt;a href=&quot;iter/trait.doubleendediterator&quot;&gt;&lt;code&gt;DoubleEndedIterator&lt;/code&gt;&lt;/a&gt; if the pattern allows a reverse search and forward/reverse search yields the same elements. This is true for, e.g., &lt;a href=&quot;primitive.char&quot;&gt;&lt;code&gt;char&lt;/code&gt;&lt;/a&gt;, but not for &lt;code&gt;&amp;amp;str&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="45e7ec844babb660dc32f9f713ab552f258e8f9a" translate="yes" xml:space="preserve">
          <source>The returned iterator will never return &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt; and will also not yield the peer's &lt;a href=&quot;enum.socketaddr&quot;&gt;&lt;code&gt;SocketAddr&lt;/code&gt;&lt;/a&gt; structure. Iterating over it is equivalent to calling &lt;a href=&quot;#method.accept&quot;&gt;&lt;code&gt;accept&lt;/code&gt;&lt;/a&gt; in a loop.</source>
          <target state="translated">Возвращенный итератор никогда не вернет &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt; &lt;code&gt;None&lt;/code&gt; ,&lt;/a&gt; а также не &lt;a href=&quot;enum.socketaddr&quot;&gt; &lt;code&gt;SocketAddr&lt;/code&gt; &lt;/a&gt; структуру SocketAddr партнера . Итерация по нему эквивалентна вызову &lt;a href=&quot;#method.accept&quot;&gt; &lt;code&gt;accept&lt;/code&gt; &lt;/a&gt; в цикле.</target>
        </trans-unit>
        <trans-unit id="40daaaf435dcc6bfd52a2f60c0016a88fb0c4d52" translate="yes" xml:space="preserve">
          <source>The returned iterator will never return &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt; and will also not yield the peer's &lt;a href=&quot;enum.socketaddr&quot;&gt;&lt;code&gt;SocketAddr&lt;/code&gt;&lt;/a&gt; structure. Iterating over it is equivalent to calling &lt;a href=&quot;struct.tcplistener#method.accept&quot;&gt;&lt;code&gt;TcpListener::accept&lt;/code&gt;&lt;/a&gt; in a loop.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3cacc276ab85a92453bcb875fe7d5c79fd6233ed" translate="yes" xml:space="preserve">
          <source>The returned iterator will not be double ended, because it is not efficient to support.</source>
          <target state="translated">Возвращаемый итератор не будет двойным,потому что он не эффективен для поддержки.</target>
        </trans-unit>
        <trans-unit id="6626efd84bc65ae6d8cabe4bc5b2e309e23cd9ee" translate="yes" xml:space="preserve">
          <source>The returned iterator will panic during iteration if any argument to the process is not valid unicode. If this is not desired, use the &lt;a href=&quot;fn.args_os&quot;&gt;&lt;code&gt;args_os&lt;/code&gt;&lt;/a&gt; function instead.</source>
          <target state="translated">Возвращенный итератор будет паниковать во время итерации, если какой-либо аргумент процесса не является допустимым Unicode. Если это нежелательно, используйте вместо этого функцию &lt;a href=&quot;fn.args_os&quot;&gt; &lt;code&gt;args_os&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="48642a85c9b9785eaffc2d69f306f5a44a684795" translate="yes" xml:space="preserve">
          <source>The returned iterator yields only the &lt;code&gt;value&lt;/code&gt;s for which the supplied closure returns &lt;code&gt;Some(value)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8c4abf6a88076e830a1096ad48a0fcbdcd010f5d" translate="yes" xml:space="preserve">
          <source>The returned lifetime is not guaranteed to be the actual lifetime of &lt;code&gt;ptr&lt;/code&gt;.</source>
          <target state="translated">Не гарантируется, что возвращаемое время жизни будет фактическим временем жизни &lt;code&gt;ptr&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="dd646ddea405b753233bb6eb50b8340613c5b51f" translate="yes" xml:space="preserve">
          <source>The returned listener is ready for accepting connections.</source>
          <target state="translated">Возвращаемый слушатель готов к приему соединений.</target>
        </trans-unit>
        <trans-unit id="32a2e5d176a9d291f17213749b86ae928f9a79fd" translate="yes" xml:space="preserve">
          <source>The returned name refers to a source path on the compiling system, but it isn't valid to represent this directly as a &lt;code&gt;&amp;amp;Path&lt;/code&gt;. The compiled code may run on a different system with a different &lt;code&gt;Path&lt;/code&gt; implementation than the system providing the contents and this library does not currently have a different &quot;host path&quot; type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bd3776d88d1ca8845ec6b1038a3cef52ddd6c1ee" translate="yes" xml:space="preserve">
          <source>The returned object can be used for error recovery, such as re-inspecting the buffer.</source>
          <target state="translated">Возвращаемый объект можно использовать для устранения ошибок,например,для повторного осмотра буфера.</target>
        </trans-unit>
        <trans-unit id="d094ca8efdcd1c477cd38db568c96ab96a8083f1" translate="yes" xml:space="preserve">
          <source>The returned pointer is read-only; writing to it (including passing it to C code that writes to it) causes undefined behavior.</source>
          <target state="translated">Возвращаемый указатель доступен только для чтения;запись на него (в том числе и передача в код C,который на него пишет)приводит к неопределенному поведению.</target>
        </trans-unit>
        <trans-unit id="9b9b68320305244b712b6eba3fb78b4a32d8f345" translate="yes" xml:space="preserve">
          <source>The returned pointer will be valid for as long as &lt;code&gt;self&lt;/code&gt; is, and points to a contiguous region of memory terminated with a 0 byte to represent the end of the string.</source>
          <target state="translated">Возвращенный указатель будет действителен до тех пор, пока есть &lt;code&gt;self&lt;/code&gt; , и указывает на непрерывную область памяти, оканчивающуюся байтом 0, представляющим конец строки.</target>
        </trans-unit>
        <trans-unit id="d1d3044eae78ae415d38e3ebb8ef901b44a28df4" translate="yes" xml:space="preserve">
          <source>The returned range is half-open, which means that the end pointer points &lt;em&gt;one past&lt;/em&gt; the last element of the slice. This way, an empty slice is represented by two equal pointers, and the difference between the two pointers represents the size of the slice.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1c27af8743c2ff7ed690feb622313cb681b2d0e2" translate="yes" xml:space="preserve">
          <source>The returned slice can be used to fill the vector with data (e.g. by reading from a file) before marking the data as initialized using the &lt;a href=&quot;struct.vec#method.set_len&quot;&gt;&lt;code&gt;set_len&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bf0c4a80af7569dc2827892f37e1cf7abb925f27" translate="yes" xml:space="preserve">
          <source>The returned slice does &lt;strong&gt;not&lt;/strong&gt; contain the trailing nul terminator, and it is guaranteed to not have any interior nul bytes. If you need the nul terminator, use &lt;a href=&quot;#method.as_bytes_with_nul&quot;&gt;&lt;code&gt;as_bytes_with_nul&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">Возвращенный фрагмент &lt;strong&gt;не&lt;/strong&gt; содержит завершающего нулевого терминатора, и он гарантированно не имеет внутренних нулевых байтов. Если вам нужен терминатор nul, используйте вместо него &lt;a href=&quot;#method.as_bytes_with_nul&quot;&gt; &lt;code&gt;as_bytes_with_nul&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="0a368474e9b2e8c2f52646dd2d7918f986464f59" translate="yes" xml:space="preserve">
          <source>The returned slice does &lt;strong&gt;not&lt;/strong&gt; contain the trailing nul terminator, and it is guaranteed to not have any interior nul bytes. If you need the nul terminator, use &lt;a href=&quot;struct.cstring#method.as_bytes_with_nul&quot;&gt;&lt;code&gt;CString::as_bytes_with_nul&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="23c2a4410e35e072d95d91733db13ddd5bf58ad1" translate="yes" xml:space="preserve">
          <source>The returned slice will &lt;strong&gt;not&lt;/strong&gt; contain the trailing nul terminator that this C string has.</source>
          <target state="translated">Возвращенный фрагмент &lt;strong&gt;не&lt;/strong&gt; будет содержать завершающего нулевого терминатора, который есть в этой строке C.</target>
        </trans-unit>
        <trans-unit id="a46b9c2f552385dbbfeb1cece6cdbcca5271f43e" translate="yes" xml:space="preserve">
          <source>The returned string must not be considered to be a unique identifier of a type as multiple types may map to the same type name. Similarly, there is no guarantee that all parts of a type will appear in the returned string: for example, lifetime specifiers are currently not included. In addition, the output may change between versions of the compiler.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ca6695d62fb3138a05ebea6941a15916ea38fd70" translate="yes" xml:space="preserve">
          <source>The returned type after indexing.</source>
          <target state="translated">Возвращаемый тип после индексирования.</target>
        </trans-unit>
        <trans-unit id="323e9e5f7457b4d404421a53102d137f9784ffb2" translate="yes" xml:space="preserve">
          <source>The returned type after the call operator is used.</source>
          <target state="translated">Возвращаемый тип после использования оператора связи.</target>
        </trans-unit>
        <trans-unit id="2d5978ed3eb5e45dd0ed7362549dedf897ab386a" translate="yes" xml:space="preserve">
          <source>The returned type implements &lt;a href=&quot;../iter/trait.iterator&quot;&gt;&lt;code&gt;Iterator&lt;/code&gt;&lt;/a&gt; where the &lt;code&gt;Item&lt;/code&gt; is &lt;a href=&quot;../result/enum.result&quot;&gt;&lt;code&gt;Result&lt;/code&gt;&lt;/a&gt;&lt;code&gt;&amp;lt;&lt;/code&gt;&lt;a href=&quot;../primitive.u8&quot;&gt;&lt;code&gt;u8&lt;/code&gt;&lt;/a&gt;&lt;code&gt;, &lt;/code&gt;&lt;a href=&quot;struct.error&quot;&gt;&lt;code&gt;io::Error&lt;/code&gt;&lt;/a&gt;&lt;code&gt;&amp;gt;&lt;/code&gt;. The yielded item is &lt;a href=&quot;../result/enum.result#variant.Ok&quot;&gt;&lt;code&gt;Ok&lt;/code&gt;&lt;/a&gt; if a byte was successfully read and &lt;a href=&quot;../result/enum.result#variant.Err&quot;&gt;&lt;code&gt;Err&lt;/code&gt;&lt;/a&gt; otherwise. EOF is mapped to returning &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt; from this iterator.</source>
          <target state="translated">Возвращаемый тип реализует &lt;a href=&quot;../iter/trait.iterator&quot;&gt; &lt;code&gt;Iterator&lt;/code&gt; ,&lt;/a&gt; где &lt;code&gt;Item&lt;/code&gt; имеет значение &lt;a href=&quot;../result/enum.result&quot;&gt; &lt;code&gt;Result&lt;/code&gt; &lt;/a&gt; &lt;code&gt;&amp;lt;&lt;/code&gt; &lt;a href=&quot;../primitive.u8&quot;&gt; &lt;code&gt;u8&lt;/code&gt; &lt;/a&gt; &lt;code&gt;, &lt;/code&gt; &lt;a href=&quot;struct.error&quot;&gt; &lt;code&gt;io::Error&lt;/code&gt; &lt;/a&gt; &lt;code&gt;&amp;gt;&lt;/code&gt; . Полученный элемент является &lt;a href=&quot;../result/enum.result#variant.Ok&quot;&gt; &lt;code&gt;Ok&lt;/code&gt; ,&lt;/a&gt; если байт был успешно прочитан, и &lt;a href=&quot;../result/enum.result#variant.Err&quot;&gt; &lt;code&gt;Err&lt;/code&gt; в&lt;/a&gt; противном случае. EOF сопоставляется с возвращением &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt; &lt;code&gt;None&lt;/code&gt; &lt;/a&gt; от этого итератора.</target>
        </trans-unit>
        <trans-unit id="94490bb5f034be81aa72ad51da07b198637a8c28" translate="yes" xml:space="preserve">
          <source>The returned type implements &lt;a href=&quot;../iter/trait.iterator&quot;&gt;&lt;code&gt;Iterator&lt;/code&gt;&lt;/a&gt; where the &lt;code&gt;Item&lt;/code&gt; is &lt;a href=&quot;../result/enum.result&quot;&gt;&lt;code&gt;Result&lt;/code&gt;&lt;/a&gt;&lt;code&gt;&amp;lt;&lt;/code&gt;&lt;a href=&quot;https://doc.rust-lang.org/nightly/std/primitive.u8.html&quot;&gt;&lt;code&gt;u8&lt;/code&gt;&lt;/a&gt;&lt;code&gt;, &lt;/code&gt;&lt;a href=&quot;struct.error&quot;&gt;&lt;code&gt;io::Error&lt;/code&gt;&lt;/a&gt;&lt;code&gt;&amp;gt;&lt;/code&gt;. The yielded item is &lt;a href=&quot;../result/enum.result#variant.Ok&quot;&gt;&lt;code&gt;Ok&lt;/code&gt;&lt;/a&gt; if a byte was successfully read and &lt;a href=&quot;../result/enum.result#variant.Err&quot;&gt;&lt;code&gt;Err&lt;/code&gt;&lt;/a&gt; otherwise. EOF is mapped to returning &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt; from this iterator.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a0b4fa361f895a3f7a940a0df4cc75d5065e98e6" translate="yes" xml:space="preserve">
          <source>The returned value corresponds to the &lt;code&gt;atime&lt;/code&gt; field of &lt;code&gt;stat&lt;/code&gt; on Unix platforms and the &lt;code&gt;ftLastAccessTime&lt;/code&gt; field on Windows platforms.</source>
          <target state="translated">Возвращаемое значение соответствует полю &lt;code&gt;atime&lt;/code&gt; в &lt;code&gt;stat&lt;/code&gt; на платформах Unix и полю &lt;code&gt;ftLastAccessTime&lt;/code&gt; на платформах Windows.</target>
        </trans-unit>
        <trans-unit id="ab7615b505b03838f921f8936a1701e974958831" translate="yes" xml:space="preserve">
          <source>The returned value corresponds to the &lt;code&gt;birthtime&lt;/code&gt; field of &lt;code&gt;stat&lt;/code&gt; on Unix platforms and the &lt;code&gt;ftCreationTime&lt;/code&gt; field on Windows platforms.</source>
          <target state="translated">Возвращаемое значение соответствует &lt;code&gt;birthtime&lt;/code&gt; области &lt;code&gt;stat&lt;/code&gt; на Unix платформах и &lt;code&gt;ftCreationTime&lt;/code&gt; поле на платформах Windows.</target>
        </trans-unit>
        <trans-unit id="2eef349b822dea9863943a97049788d8df72cce1" translate="yes" xml:space="preserve">
          <source>The returned value corresponds to the &lt;code&gt;btime&lt;/code&gt; field of &lt;code&gt;statx&lt;/code&gt; on Linux kernel starting from to 4.11, the &lt;code&gt;birthtime&lt;/code&gt; field of &lt;code&gt;stat&lt;/code&gt; on other Unix platforms, and the &lt;code&gt;ftCreationTime&lt;/code&gt; field on Windows platforms.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c5896159de75927b2d1b622cfd587f254e9fed43" translate="yes" xml:space="preserve">
          <source>The returned value corresponds to the &lt;code&gt;mtime&lt;/code&gt; field of &lt;code&gt;stat&lt;/code&gt; on Unix platforms and the &lt;code&gt;ftLastWriteTime&lt;/code&gt; field on Windows platforms.</source>
          <target state="translated">Возвращаемое значение соответствует полю &lt;code&gt;mtime&lt;/code&gt; &lt;code&gt;stat&lt;/code&gt; на платформах Unix и полю &lt;code&gt;ftLastWriteTime&lt;/code&gt; на платформах Windows.</target>
        </trans-unit>
        <trans-unit id="a0ea9c14c32dc6d6e0d323b13279abc6935b1d15" translate="yes" xml:space="preserve">
          <source>The returned value does include the fractional (nanosecond) part of the duration.</source>
          <target state="translated">Возвращаемое значение включает в себя дробную (наносекунду)часть продолжительности.</target>
        </trans-unit>
        <trans-unit id="ff15d0950ff1afde3f0762acc64a9f002a6a04c1" translate="yes" xml:space="preserve">
          <source>The returned value does not have meaning for directories.</source>
          <target state="translated">Возвращаемое значение не имеет значения для каталогов.</target>
        </trans-unit>
        <trans-unit id="e8c08d63d79b2a138a0f12bb7a91ea3ec23dcec7" translate="yes" xml:space="preserve">
          <source>The returned value does not include the fractional (nanosecond) part of the duration, which can be obtained using &lt;a href=&quot;#method.subsec_nanos&quot;&gt;&lt;code&gt;subsec_nanos&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Возвращаемое значение не включает дробную (наносекундную) часть длительности, которую можно получить с помощью &lt;a href=&quot;#method.subsec_nanos&quot;&gt; &lt;code&gt;subsec_nanos&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="1bfa4d7247e116de4261b1e09435dc9dcadacc45" translate="yes" xml:space="preserve">
          <source>The returned value does not include the fractional (nanosecond) part of the duration, which can be obtained using &lt;a href=&quot;struct.duration#method.subsec_nanos&quot;&gt;&lt;code&gt;subsec_nanos&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1e5135e5751b93b5d235f37608301c3018208e63" translate="yes" xml:space="preserve">
          <source>The returned value is the number of &lt;strong&gt;elements&lt;/strong&gt;, not the number of bytes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="70d2d5505f46c3741e892512e8371427a53745d7" translate="yes" xml:space="preserve">
          <source>The right shift assignment operator &lt;code&gt;&amp;gt;&amp;gt;=&lt;/code&gt;.</source>
          <target state="translated">Оператор присваивания сдвига вправо &lt;code&gt;&amp;gt;&amp;gt;=&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e00fa6358174afd137529285f589695abe7555ab" translate="yes" xml:space="preserve">
          <source>The right shift operator &lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt;. Note that because this trait is implemented for all integer types with multiple right-hand-side types, Rust's type checker has special handling for &lt;code&gt;_ &amp;gt;&amp;gt; _&lt;/code&gt;, setting the result type for integer operations to the type of the left-hand-side operand. This means that though &lt;code&gt;a &amp;gt;&amp;gt; b&lt;/code&gt; and &lt;code&gt;a.shr(b)&lt;/code&gt; are one and the same from an evaluation standpoint, they are different when it comes to type inference.</source>
          <target state="translated">Оператор сдвига вправо &lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt; . Обратите внимание, что, поскольку эта черта реализована для всех целочисленных типов с несколькими типами с правой стороны, средство проверки типов в Rust имеет специальную обработку для &lt;code&gt;_ &amp;gt;&amp;gt; _&lt;/code&gt; , устанавливая тип результата для целочисленных операций на тип левого операнда. . Это означает, что хотя &lt;code&gt;a &amp;gt;&amp;gt; b&lt;/code&gt; и &lt;code&gt;a.shr(b)&lt;/code&gt; - одно и то же с точки зрения оценки, они различаются, когда дело доходит до вывода типов.</target>
        </trans-unit>
        <trans-unit id="4bed85e5cf48df182fbdc5f50e1999ffc9d50cbb" translate="yes" xml:space="preserve">
          <source>The right way to suppress the warning is to actually write error handling, but because you just want to crash this program when a problem occurs, you can use &lt;code&gt;expect&lt;/code&gt;. You&amp;rsquo;ll learn about recovering from errors in Chapter 9.</source>
          <target state="translated">Правильный способ подавить предупреждение - это написать обработку ошибок, но поскольку вы просто хотите вывести эту программу из строя при возникновении проблемы, вы можете использовать &lt;code&gt;expect&lt;/code&gt; . Вы узнаете о восстановлении после ошибок в главе 9.</target>
        </trans-unit>
        <trans-unit id="93b14b29a7aed966fc23a390a9832d3b882cc69b" translate="yes" xml:space="preserve">
          <source>The root directory component, appears after any prefix and before anything else.</source>
          <target state="translated">Компонент корневого каталога,появляется после любого префикса и перед чем-либо еще.</target>
        </trans-unit>
        <trans-unit id="a168d72d668df499616b725b5ca80c1ff007a04a" translate="yes" xml:space="preserve">
          <source>The rules for &lt;a href=&quot;../special-types-and-traits#send&quot;&gt;&lt;code&gt;Send&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../special-types-and-traits#sync&quot;&gt;&lt;code&gt;Sync&lt;/code&gt;&lt;/a&gt; match those for normal struct types, while &lt;a href=&quot;../special-types-and-traits#clone&quot;&gt;&lt;code&gt;Clone&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../special-types-and-traits#copy&quot;&gt;&lt;code&gt;Copy&lt;/code&gt;&lt;/a&gt; behave as if &lt;a href=&quot;../attributes/derive&quot;&gt;derived&lt;/a&gt;. For &lt;a href=&quot;../special-types-and-traits#clone&quot;&gt;&lt;code&gt;Clone&lt;/code&gt;&lt;/a&gt;, the order of cloning of the captured variables is left unspecified.</source>
          <target state="translated">Правила для &lt;a href=&quot;../special-types-and-traits#send&quot;&gt; &lt;code&gt;Send&lt;/code&gt; &lt;/a&gt; и &lt;a href=&quot;../special-types-and-traits#sync&quot;&gt; &lt;code&gt;Sync&lt;/code&gt; &lt;/a&gt; соответствуют правилам для обычных типов структур, в то время как &lt;a href=&quot;../special-types-and-traits#clone&quot;&gt; &lt;code&gt;Clone&lt;/code&gt; &lt;/a&gt; и &lt;a href=&quot;../special-types-and-traits#copy&quot;&gt; &lt;code&gt;Copy&lt;/code&gt; &lt;/a&gt; ведут себя как &lt;a href=&quot;../attributes/derive&quot;&gt;производные&lt;/a&gt; . Для &lt;a href=&quot;../special-types-and-traits#clone&quot;&gt; &lt;code&gt;Clone&lt;/code&gt; &lt;/a&gt; порядок клонирования захваченных переменных не указывается.</target>
        </trans-unit>
        <trans-unit id="3563595879dbbd21c6c2906f7bd54a9b3679529d" translate="yes" xml:space="preserve">
          <source>The rust compiler cannot link to an external library if you don't give it its name. Example:</source>
          <target state="translated">Компилятор ржавчины не может ссылаться на внешнюю библиотеку,если не указать ее имя.Пример:</target>
        </trans-unit>
        <trans-unit id="54065002f88e1cb544dc442e2b3686e62225bf94" translate="yes" xml:space="preserve">
          <source>The rust compiler maintains for each target a blacklist of ABIs unsupported on that target. If an ABI is present in such a list this usually means that the target / ABI combination is currently unsupported by llvm.</source>
          <target state="translated">Компилятор ржавчины поддерживает для каждой цели черный список ABI,не поддерживаемых на этой цели.Если ABI присутствует в таком списке,то это обычно означает,что комбинация целевой/ABI в настоящее время не поддерживается llvm.</target>
        </trans-unit>
        <trans-unit id="e602506551cf00543c3919704a07e8c114c13f33" translate="yes" xml:space="preserve">
          <source>The rust compiler maintains for each target a list of unsupported ABIs on that target. If an ABI is present in such a list this usually means that the target / ABI combination is currently unsupported by llvm.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d8dcfff8659995d9c806c4ff5bfe72343be6d124" translate="yes" xml:space="preserve">
          <source>The rustfix tool is included with Rust installations and can automatically fix some compiler warnings. If you&amp;rsquo;ve written code in Rust, you&amp;rsquo;ve probably seen compiler warnings. For example, consider this code:</source>
          <target state="translated">Инструмент rustfix включен в установку Rust и может автоматически исправлять некоторые предупреждения компилятора. Если вы написали код на Rust, вы, вероятно, видели предупреждения компилятора. Например, рассмотрим этот код:</target>
        </trans-unit>
        <trans-unit id="d95e676c8653714db7acc846f5781f129f187994" translate="yes" xml:space="preserve">
          <source>The safety and conciseness of &lt;code&gt;for&lt;/code&gt; loops make them the most commonly used loop construct in Rust. Even in situations in which you want to run some code a certain number of times, as in the countdown example that used a &lt;code&gt;while&lt;/code&gt; loop in Listing 3-3, most Rustaceans would use a &lt;code&gt;for&lt;/code&gt; loop. The way to do that would be to use a &lt;code&gt;Range&lt;/code&gt;, which is a type provided by the standard library that generates all numbers in sequence starting from one number and ending before another number.</source>
          <target state="translated">Безопасность и лаконичность циклов &lt;code&gt;for&lt;/code&gt; делают их наиболее часто используемой конструкцией циклов в Rust. Даже в тех ситуациях , в которых вы хотите запустить код определенное число раз, как в примере , обратный отсчет , который использовал &lt;code&gt;while&lt;/code&gt; цикл в листинге 3-3, большинство Rustaceans будет использовать &lt;code&gt;for&lt;/code&gt; петли. Способ сделать это - использовать &lt;code&gt;Range&lt;/code&gt; , тип, предоставляемый стандартной библиотекой, который генерирует все числа в последовательности, начиная с одного числа и заканчивая другим числом.</target>
        </trans-unit>
        <trans-unit id="8de5417b2f4455bae199197d09ad86c5d8b15755" translate="yes" xml:space="preserve">
          <source>The safety conditions are described in the &lt;a href=&quot;index#memory-layout&quot;&gt;memory layout&lt;/a&gt; section.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="34c5f02c44747e09b58d1ec500165079e9867619" translate="yes" xml:space="preserve">
          <source>The same applies to transmutes to &lt;code&gt;*mut fn()&lt;/code&gt;, which were observed in practice. Note though that use of this type is generally incorrect. The intention is typically to describe a function pointer, but just &lt;code&gt;fn()&lt;/code&gt; alone suffices for that. &lt;code&gt;*mut fn()&lt;/code&gt; is a pointer to a fn pointer. (Since these values are typically just passed to C code, however, this rarely makes a difference in practice.)</source>
          <target state="translated">То же самое относится к преобразованиям в &lt;code&gt;*mut fn()&lt;/code&gt; , которые наблюдались на практике. Однако учтите, что использование этого типа обычно неверно. Обычно целью является описание указателя на функцию, но для этого достаточно только &lt;code&gt;fn()&lt;/code&gt; . &lt;code&gt;*mut fn()&lt;/code&gt; - указатель на указатель fn. (Поскольку эти значения обычно просто передаются в код C, однако на практике это редко имеет значение.)</target>
        </trans-unit>
        <trans-unit id="a7f4b342720ddcec9a49dfb2ca6daf016843320d" translate="yes" xml:space="preserve">
          <source>The same as &lt;a href=&quot;../../../iter/trait.iterator#method.fold&quot;&gt;&lt;code&gt;fold()&lt;/code&gt;&lt;/a&gt;, but uses the first element in the iterator as the initial value, folding every subsequent element into it. If the iterator is empty, return &lt;a href=&quot;../../../option/enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt;; otherwise, return the result of the fold. &lt;a href=&quot;../../../iter/trait.iterator#method.fold_first&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c676ce454b9f3ef8b4d42559af1943bf2b7913d9" translate="yes" xml:space="preserve">
          <source>The same as &lt;a href=&quot;../../iter/trait.iterator#method.fold&quot;&gt;&lt;code&gt;fold()&lt;/code&gt;&lt;/a&gt;, but uses the first element in the iterator as the initial value, folding every subsequent element into it. If the iterator is empty, return &lt;a href=&quot;../../option/enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt;; otherwise, return the result of the fold. &lt;a href=&quot;../../iter/trait.iterator#method.fold_first&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fb7e4f0db03c726bc5bd7452fa0f56591b66e33d" translate="yes" xml:space="preserve">
          <source>The same as &lt;a href=&quot;../iter/trait.iterator#method.fold&quot;&gt;&lt;code&gt;fold()&lt;/code&gt;&lt;/a&gt;, but uses the first element in the iterator as the initial value, folding every subsequent element into it. If the iterator is empty, return &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt;; otherwise, return the result of the fold. &lt;a href=&quot;../iter/trait.iterator#method.fold_first&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dcf7a6ad9f8fb40e4ba7caca628efe6809216b4f" translate="yes" xml:space="preserve">
          <source>The same as &lt;a href=&quot;../iter/trait.iterator#method.fold&quot;&gt;&lt;code&gt;fold()&lt;/code&gt;&lt;/a&gt;, but uses the first element in the iterator as the initial value, folding every subsequent element into it. If the iterator is empty, return &lt;a href=&quot;enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt;; otherwise, return the result of the fold. &lt;a href=&quot;../iter/trait.iterator#method.fold_first&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f1ae9b3d116905ba91635f77fa80dd3badbdd424" translate="yes" xml:space="preserve">
          <source>The same as &lt;a href=&quot;iter/trait.iterator#method.fold&quot;&gt;&lt;code&gt;fold()&lt;/code&gt;&lt;/a&gt;, but uses the first element in the iterator as the initial value, folding every subsequent element into it. If the iterator is empty, return &lt;a href=&quot;option/enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt;; otherwise, return the result of the fold. &lt;a href=&quot;iter/trait.iterator#method.fold_first&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3f595892b4fea20450f05cddbe7763f0e003caa0" translate="yes" xml:space="preserve">
          <source>The same as &lt;a href=&quot;trait.iterator#method.fold&quot;&gt;&lt;code&gt;fold()&lt;/code&gt;&lt;/a&gt;, but uses the first element in the iterator as the initial value, folding every subsequent element into it. If the iterator is empty, return &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt;; otherwise, return the result of the fold.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f5b129096713d6e93f0f6771f5a02e553c2efcf3" translate="yes" xml:space="preserve">
          <source>The same as &lt;a href=&quot;trait.iterator#method.fold&quot;&gt;&lt;code&gt;fold()&lt;/code&gt;&lt;/a&gt;, but uses the first element in the iterator as the initial value, folding every subsequent element into it. If the iterator is empty, return &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt;; otherwise, return the result of the fold. &lt;a href=&quot;trait.iterator#method.fold_first&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="902a2b25118315948a58ef98f0d17bd457899153" translate="yes" xml:space="preserve">
          <source>The same goes for doc comments:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2e8159833047b3772ef09e1ff09bc6721b1345cc" translate="yes" xml:space="preserve">
          <source>The same restrictions of accessing the target of the pointer as with &lt;a href=&quot;struct.weak#method.as_ptr&quot;&gt;&lt;code&gt;as_ptr&lt;/code&gt;&lt;/a&gt; apply.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2bc57fcef5c1050ba1f9373a34844306a6911e2e" translate="yes" xml:space="preserve">
          <source>The same restrictions of accessing the target of the pointer as with &lt;a href=&quot;struct.weak#method.as_raw&quot;&gt;&lt;code&gt;as_raw&lt;/code&gt;&lt;/a&gt; apply.</source>
          <target state="translated">&lt;a href=&quot;struct.weak#method.as_raw&quot;&gt; &lt;code&gt;as_raw&lt;/code&gt; &lt;/a&gt; же ограничения на доступ к цели указателя, что и для as_raw .</target>
        </trans-unit>
        <trans-unit id="e53c2cdb1077121198b1a8746e267d3b3a805b0e" translate="yes" xml:space="preserve">
          <source>The scope in which the variable &lt;code&gt;s&lt;/code&gt; is valid is the same as any function parameter&amp;rsquo;s scope, but we don&amp;rsquo;t drop what the reference points to when it goes out of scope because we don&amp;rsquo;t have ownership. When functions have references as parameters instead of the actual values, we won&amp;rsquo;t need to return the values in order to give back ownership, because we never had ownership.</source>
          <target state="translated">Область действия, в которой допустима переменная &lt;code&gt;s&lt;/code&gt; , такая же, как и область действия любого параметра функции, но мы не отбрасываем то, на что указывает ссылка, когда она выходит за пределы области действия, потому что мы не владеем ею. Когда функции имеют ссылки в качестве параметров вместо фактических значений, нам не нужно возвращать значения, чтобы вернуть право собственности, потому что мы никогда не владели.</target>
        </trans-unit>
        <trans-unit id="2c0f9db762db77543e23786689d772ed7e180cf6" translate="yes" xml:space="preserve">
          <source>The scopes of the immutable references &lt;code&gt;r1&lt;/code&gt; and &lt;code&gt;r2&lt;/code&gt; end after the &lt;code&gt;println!&lt;/code&gt; where they are last used, which is before the mutable reference &lt;code&gt;r3&lt;/code&gt; is created. These scopes don&amp;rsquo;t overlap, so this code is allowed.</source>
          <target state="translated">Области неизменяемых ссылок &lt;code&gt;r1&lt;/code&gt; и &lt;code&gt;r2&lt;/code&gt; заканчиваются после &lt;code&gt;println!&lt;/code&gt; где они использовались в последний раз, то есть до создания изменяемой ссылки &lt;code&gt;r3&lt;/code&gt; . Эти области не пересекаются, поэтому этот код разрешен.</target>
        </trans-unit>
        <trans-unit id="547c47e37f57601f738482d42256219a9633dd7e" translate="yes" xml:space="preserve">
          <source>The search path to be used may be controlled by setting the &lt;code&gt;PATH&lt;/code&gt; environment variable on the Command, but this has some implementation limitations on Windows (see issue #37519).</source>
          <target state="translated">Используемый путь поиска можно контролировать, задав &lt;code&gt;PATH&lt;/code&gt; среды PATH в команде, но это имеет некоторые ограничения реализации в Windows (см. Проблему № 37519).</target>
        </trans-unit>
        <trans-unit id="3a555019f8dcc01c39b7fc4a4df1fa78e901c698" translate="yes" xml:space="preserve">
          <source>The second case example is a bit particular: the main function must always have this definition:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="02a1a4dab2732977e1598d466f79a0132530331a" translate="yes" xml:space="preserve">
          <source>The second form of macros is &lt;em&gt;procedural macros&lt;/em&gt;, which act more like functions (and are a type of procedure). Procedural macros accept some code as an input, operate on that code, and produce some code as an output rather than matching against patterns and replacing the code with other code as declarative macros do.</source>
          <target state="translated">Вторая форма макросов - это &lt;em&gt;процедурные макросы&lt;/em&gt; , которые действуют больше как функции (и являются разновидностью процедуры). Процедурные макросы принимают некоторый код в качестве входных данных, работают с этим кодом и создают некоторый код в качестве выходных данных, а не сопоставляют его с шаблонами и заменяют код другим кодом, как это делают декларативные макросы.</target>
        </trans-unit>
        <trans-unit id="014f5e70707fe70de5f920ceaf6bbf6f00b7acd7" translate="yes" xml:space="preserve">
          <source>The second half of the tuple that is returned is an &lt;a href=&quot;../option/enum.option&quot;&gt;&lt;code&gt;Option&lt;/code&gt;&lt;/a&gt;&lt;code&gt;&amp;lt;&lt;/code&gt;&lt;a href=&quot;../primitive.usize&quot;&gt;&lt;code&gt;usize&lt;/code&gt;&lt;/a&gt;&lt;code&gt;&amp;gt;&lt;/code&gt;. A &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt; here means that either there is no known upper bound, or the upper bound is larger than &lt;a href=&quot;../primitive.usize&quot;&gt;&lt;code&gt;usize&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Вторая половина возвращаемого кортежа - это &lt;a href=&quot;../option/enum.option&quot;&gt; &lt;code&gt;Option&lt;/code&gt; &lt;/a&gt; &lt;code&gt;&amp;lt;&lt;/code&gt; &lt;a href=&quot;../primitive.usize&quot;&gt; &lt;code&gt;usize&lt;/code&gt; &lt;/a&gt; &lt;code&gt;&amp;gt;&lt;/code&gt; . &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt; &lt;code&gt;None&lt;/code&gt; &lt;/a&gt; в данном случае означает , что либо не известны верхняя не связаны, или верхняя граница больше , чем &lt;a href=&quot;../primitive.usize&quot;&gt; &lt;code&gt;usize&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="4961749eb1f24345f8436cc7b35d0ebccb81384a" translate="yes" xml:space="preserve">
          <source>The second invariant says that a separated complex NT must use a separator token that is part of the predetermined follow set for the internal contents of the NT. This ensures that a legal macro definition will continue to parse an input fragment into the same delimited sequence of &lt;code&gt;tt ...&lt;/code&gt;'s, even as new syntactic forms are added to the language.</source>
          <target state="translated">Второй инвариант говорит, что разделенный сложный NT должен использовать токен-разделитель, который является частью заранее определенного последующего набора для внутреннего содержимого NT. Это гарантирует, что допустимое определение макроса будет продолжать анализировать входной фрагмент в той же последовательности &lt;code&gt;tt ...&lt;/code&gt; с разделителями , даже если к языку добавляются новые синтаксические формы.</target>
        </trans-unit>
        <trans-unit id="3069a4f51af6a3b6633b4d681ece722a85d63fa2" translate="yes" xml:space="preserve">
          <source>The second is mutable references. They can be created from &lt;code&gt;mut&lt;/code&gt; variables and must be unique: no other variables can have a mutable reference, nor a shared reference.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3f2dca747a6f3fa79f2291ae843df5963e36bbc5" translate="yes" xml:space="preserve">
          <source>The second is that it is the offset in bytes between successive elements in an array with that item type.</source>
          <target state="translated">Второе-это смещение в байтах между последовательными элементами в массиве с таким типом элемента.</target>
        </trans-unit>
        <trans-unit id="a1e02e9dcee081f5b8c19c27d767e65c0ff37f76" translate="yes" xml:space="preserve">
          <source>The second is to generally improve your knowledge of a facet of the language. In that case, just browse the table of contents until you see something you want to know more about, and just start reading. If a link looks interesting, click it, and read about that section.</source>
          <target state="translated">Второе-это в целом улучшение знаний о гранях языка.В этом случае просто просматривайте оглавление,пока не увидите то,о чем вы хотите узнать больше,и просто начните читать.Если ссылка выглядит интересной,кликните по ней и прочитайте об этом разделе.</target>
        </trans-unit>
        <trans-unit id="df5949936d6a2cd7eaf61fe27eb1fac54cf960fb" translate="yes" xml:space="preserve">
          <source>The second line that we added to the middle of the code prints the secret number. This is useful while we&amp;rsquo;re developing the program to be able to test it, but we&amp;rsquo;ll delete it from the final version. It&amp;rsquo;s not much of a game if the program prints the answer as soon as it starts!</source>
          <target state="translated">Вторая строка, которую мы добавили в середину кода, печатает секретное число. Это полезно, пока мы разрабатываем программу, чтобы иметь возможность ее протестировать, но мы удалим ее из окончательной версии. Это не такая уж игра, если программа выводит ответ при запуске!</target>
        </trans-unit>
        <trans-unit id="c1f82d829df68033c418a80c29f6453df31bb3f7" translate="yes" xml:space="preserve">
          <source>The second operand of a &lt;a href=&quot;expressions/operator-expr#lazy-boolean-operators&quot;&gt;lazy boolean expression&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="57bb822113e197cd1e10145a43fbd748bc848a6a" translate="yes" xml:space="preserve">
          <source>The second problem with the current &lt;code&gt;Cacher&lt;/code&gt; implementation is that it only accepts closures that take one parameter of type &lt;code&gt;u32&lt;/code&gt; and return a &lt;code&gt;u32&lt;/code&gt;. We might want to cache the results of closures that take a string slice and return &lt;code&gt;usize&lt;/code&gt; values, for example. To fix this issue, try introducing more generic parameters to increase the flexibility of the &lt;code&gt;Cacher&lt;/code&gt; functionality.</source>
          <target state="translated">Вторая проблема с текущей реализацией &lt;code&gt;Cacher&lt;/code&gt; заключается в том, что она принимает только замыкания, которые принимают один параметр типа &lt;code&gt;u32&lt;/code&gt; и возвращают &lt;code&gt;u32&lt;/code&gt; . Например, мы могли бы захотеть кэшировать результаты замыканий, которые берут строковый фрагмент и возвращают значения &lt;code&gt;usize&lt;/code&gt; . Чтобы решить эту проблему, попробуйте ввести более общие параметры, чтобы повысить гибкость функциональности &lt;code&gt;Cacher&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="92462e612674a20cc7e3c63f701740ce5bea5c75" translate="yes" xml:space="preserve">
          <source>The second rule applies because there is exactly one input lifetime. The second rule specifies that the lifetime of the one input parameter gets assigned to the output lifetime, so the signature is now this:</source>
          <target state="translated">Второе правило применяется потому,что существует ровно одно входное время жизни.Второе правило определяет,что время жизни одного входного параметра присваивается выходному времени жизни,поэтому сигнатура теперь такая:</target>
        </trans-unit>
        <trans-unit id="66815e0776a29457690bd505c60d2e19937fa654" translate="yes" xml:space="preserve">
          <source>The second rule is if there is exactly one input lifetime parameter, that lifetime is assigned to all output lifetime parameters: &lt;code&gt;fn foo&amp;lt;'a&amp;gt;(x: &amp;amp;'a i32) -&amp;gt; &amp;amp;'a i32&lt;/code&gt;.</source>
          <target state="translated">Второе правило заключается в том, что если существует ровно один входной параметр времени жизни, это время жизни назначается всем выходным параметрам времени жизни: &lt;code&gt;fn foo&amp;lt;'a&amp;gt;(x: &amp;amp;'a i32) -&amp;gt; &amp;amp;'a i32&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="aedd96f8435bb44ce30001804fbe27f5473ed0ee" translate="yes" xml:space="preserve">
          <source>The second time we call &lt;code&gt;add_to_waitlist&lt;/code&gt; in &lt;code&gt;eat_at_restaurant&lt;/code&gt;, we use a relative path. The path starts with &lt;code&gt;front_of_house&lt;/code&gt;, the name of the module defined at the same level of the module tree as &lt;code&gt;eat_at_restaurant&lt;/code&gt;. Here the filesystem equivalent would be using the path &lt;code&gt;front_of_house/hosting/add_to_waitlist&lt;/code&gt;. Starting with a name means that the path is relative.</source>
          <target state="translated">Во второй раз, когда мы вызываем &lt;code&gt;add_to_waitlist&lt;/code&gt; в &lt;code&gt;eat_at_restaurant&lt;/code&gt; , мы используем относительный путь. Путь начинается с &lt;code&gt;front_of_house&lt;/code&gt; , имени модуля, определенного на том же уровне дерева модулей, что и &lt;code&gt;eat_at_restaurant&lt;/code&gt; . Здесь эквивалент файловой системы будет использовать путь &lt;code&gt;front_of_house/hosting/add_to_waitlist&lt;/code&gt; . Начало с имени означает, что путь относительный.</target>
        </trans-unit>
        <trans-unit id="6719785aa3871b4c2a2d425aeb686279358fe018" translate="yes" xml:space="preserve">
          <source>The second trait important to the smart pointer pattern is &lt;code&gt;Drop&lt;/code&gt;, which lets you customize what happens when a value is about to go out of scope. You can provide an implementation for the &lt;code&gt;Drop&lt;/code&gt; trait on any type, and the code you specify can be used to release resources like files or network connections. We&amp;rsquo;re introducing &lt;code&gt;Drop&lt;/code&gt; in the context of smart pointers because the functionality of the &lt;code&gt;Drop&lt;/code&gt; trait is almost always used when implementing a smart pointer. For example, &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; customizes &lt;code&gt;Drop&lt;/code&gt; to deallocate the space on the heap that the box points to.</source>
          <target state="translated">Вторая особенность, важная для шаблона интеллектуального указателя, - это &lt;code&gt;Drop&lt;/code&gt; , которая позволяет вам настроить, что происходит, когда значение собирается выйти за пределы области видимости. Вы можете предоставить реализацию признака &lt;code&gt;Drop&lt;/code&gt; для любого типа, а указанный вами код можно использовать для освобождения ресурсов, таких как файлы или сетевые соединения. Мы представляем &lt;code&gt;Drop&lt;/code&gt; в контексте интеллектуальных указателей, потому что функциональность трейта &lt;code&gt;Drop&lt;/code&gt; почти всегда используется при реализации интеллектуального указателя. Например, &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; настраивает &lt;code&gt;Drop&lt;/code&gt; , чтобы освободить место в куче, на которое указывает поле.</target>
        </trans-unit>
        <trans-unit id="445effcb8001016422ef7635d91738ff3683b61e" translate="yes" xml:space="preserve">
          <source>The second trait important to the smart pointer pattern is &lt;code&gt;Drop&lt;/code&gt;, which lets you customize what happens when a value is about to go out of scope. You can provide an implementation for the &lt;code&gt;Drop&lt;/code&gt; trait on any type, and the code you specify can be used to release resources like files or network connections. We&amp;rsquo;re introducing &lt;code&gt;Drop&lt;/code&gt; in the context of smart pointers because the functionality of the &lt;code&gt;Drop&lt;/code&gt; trait is almost always used when implementing a smart pointer. For example, when a &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; is dropped it will deallocate the space on the heap that the box points to.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b9253951b95bdbecdb3d6ee784fab1524db5c9af" translate="yes" xml:space="preserve">
          <source>The second type of operation that requires an unsafe block is calls to unsafe functions. Unsafe functions and methods look exactly like regular functions and methods, but they have an extra &lt;code&gt;unsafe&lt;/code&gt; before the rest of the definition. The &lt;code&gt;unsafe&lt;/code&gt; keyword in this context indicates the function has requirements we need to uphold when we call this function, because Rust can&amp;rsquo;t guarantee we&amp;rsquo;ve met these requirements. By calling an unsafe function within an &lt;code&gt;unsafe&lt;/code&gt; block, we&amp;rsquo;re saying that we&amp;rsquo;ve read this function&amp;rsquo;s documentation and take responsibility for upholding the function&amp;rsquo;s contracts.</source>
          <target state="translated">Второй тип операций, для которых требуется небезопасный блок, - это вызовы небезопасных функций. Небезопасные функции и методы выглядят точно так же, как обычные функции и методы, но перед остальной частью определения у них есть дополнительная &lt;code&gt;unsafe&lt;/code&gt; . &lt;code&gt;unsafe&lt;/code&gt; ключевое слово в этом контексте показывает , что функция имеет требование , мы должны соблюдать , когда мы называем эту функцию, потому что ржавчина не может гарантировать , что мы встречались эти требования. Вызывая небезопасную функцию в &lt;code&gt;unsafe&lt;/code&gt; блоке, мы говорим, что прочитали документацию по этой функции и берем на себя ответственность за соблюдение контрактов функции.</target>
        </trans-unit>
        <trans-unit id="3b5790cbd3c99b8bfcd34f57b9dbfe5e2b8bc741" translate="yes" xml:space="preserve">
          <source>The second-to-last line of the output shows the location and the name of the installed binary, which in the case of &lt;code&gt;ripgrep&lt;/code&gt; is &lt;code&gt;rg&lt;/code&gt;. As long as the installation directory is in your &lt;code&gt;$PATH&lt;/code&gt;, as mentioned previously, you can then run &lt;code&gt;rg --help&lt;/code&gt; and start using a faster, rustier tool for searching files!</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="599ddbb55a436b4b2320e8d917bb378c0d788288" translate="yes" xml:space="preserve">
          <source>The semantics for passing a value to a function are similar to those for assigning a value to a variable. Passing a variable to a function will move or copy, just as assignment does. Listing 4-3 has an example with some annotations showing where variables go into and out of scope.</source>
          <target state="translated">Семантика передачи значения в функцию аналогична семантике присвоения значения переменной.Передача переменной в функцию будет перемещаться или копироваться так же,как и присваивание.В списке 4-3 есть пример с некоторыми примечаниями,показывающими,куда переменные входят и выходят из области видимости.</target>
        </trans-unit>
        <trans-unit id="0ebf78e0ec598941096cd9f3613dea835a20177d" translate="yes" xml:space="preserve">
          <source>The semantics of this function are equivalent to &lt;a href=&quot;#method.wait&quot;&gt;&lt;code&gt;wait&lt;/code&gt;&lt;/a&gt; except that the thread will be blocked for roughly no longer than &lt;code&gt;dur&lt;/code&gt;. This method should not be used for precise timing due to anomalies such as preemption or platform differences that may not cause the maximum amount of time waited to be precisely &lt;code&gt;dur&lt;/code&gt;.</source>
          <target state="translated">Семантика этой функции эквивалентна &lt;a href=&quot;#method.wait&quot;&gt; &lt;code&gt;wait&lt;/code&gt; ,&lt;/a&gt; за исключением того, что поток будет заблокирован примерно не дольше &lt;code&gt;dur&lt;/code&gt; . Этот метод не следует использовать для точного отсчета времени из-за аномалий, таких как приоритетное прерывание или различия платформ, которые могут не привести к тому, что максимальное время ожидания будет точно &lt;code&gt;dur&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9f8ab2e3b0b43343b07ba616db0d9b83ddc1ec9a" translate="yes" xml:space="preserve">
          <source>The semantics of this function are equivalent to &lt;a href=&quot;#method.wait&quot;&gt;&lt;code&gt;wait&lt;/code&gt;&lt;/a&gt; except that the thread will be blocked for roughly no longer than &lt;code&gt;ms&lt;/code&gt; milliseconds. This method should not be used for precise timing due to anomalies such as preemption or platform differences that may not cause the maximum amount of time waited to be precisely &lt;code&gt;ms&lt;/code&gt;.</source>
          <target state="translated">Семантика этой функции эквивалентна &lt;a href=&quot;#method.wait&quot;&gt; &lt;code&gt;wait&lt;/code&gt; &lt;/a&gt; за исключением того, что поток будет заблокирован примерно не более чем на &lt;code&gt;ms&lt;/code&gt; миллисекунд. Этот метод не следует использовать для точного определения времени из-за аномалий, таких как приоритетное прерывание или различия платформ, которые могут не привести к тому, что максимальное время ожидания будет точно &lt;code&gt;ms&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="10369644dc806ec3584f4bc1cd00c1b37924dd8f" translate="yes" xml:space="preserve">
          <source>The semantics of this function are equivalent to &lt;a href=&quot;#method.wait_until&quot;&gt;&lt;code&gt;wait_until&lt;/code&gt;&lt;/a&gt; except that the thread will be blocked for roughly no longer than &lt;code&gt;dur&lt;/code&gt;. This method should not be used for precise timing due to anomalies such as preemption or platform differences that may not cause the maximum amount of time waited to be precisely &lt;code&gt;dur&lt;/code&gt;.</source>
          <target state="translated">Семантика этой функции эквивалентна &lt;a href=&quot;#method.wait_until&quot;&gt; &lt;code&gt;wait_until&lt;/code&gt; ,&lt;/a&gt; за исключением того, что поток будет заблокирован примерно не дольше &lt;code&gt;dur&lt;/code&gt; . Этот метод не следует использовать для точного отсчета времени из-за аномалий, таких как приоритетное прерывание или различия платформ, которые могут не привести к тому, что максимальное время ожидания будет точно &lt;code&gt;dur&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="599bdbbdba24d3dd39b2e820e78610be901175cf" translate="yes" xml:space="preserve">
          <source>The semantics of this function are equivalent to &lt;a href=&quot;fn.park&quot;&gt;&lt;code&gt;park&lt;/code&gt;&lt;/a&gt; except that the thread will be blocked for roughly no longer than &lt;code&gt;dur&lt;/code&gt;. This method should not be used for precise timing due to anomalies such as preemption or platform differences that may not cause the maximum amount of time waited to be precisely &lt;code&gt;dur&lt;/code&gt; long.</source>
          <target state="translated">Семантика этой функции эквивалентна &lt;a href=&quot;fn.park&quot;&gt; &lt;code&gt;park&lt;/code&gt; ,&lt;/a&gt; за исключением того, что поток будет заблокирован примерно не дольше &lt;code&gt;dur&lt;/code&gt; . Этот метод не следует использовать для точного отсчета времени из-за аномалий, таких как приоритетное прерывание или различия платформ, которые могут не привести к тому, что максимальное количество времени ожидания будет точно &lt;code&gt;dur&lt;/code&gt; long.</target>
        </trans-unit>
        <trans-unit id="9563714599dd3161cea050e5c59d88f3adc62446" translate="yes" xml:space="preserve">
          <source>The semantics of this function are equivalent to &lt;a href=&quot;fn.park&quot;&gt;&lt;code&gt;park&lt;/code&gt;&lt;/a&gt; except that the thread will be blocked for roughly no longer than &lt;code&gt;dur&lt;/code&gt;. This method should not be used for precise timing due to anomalies such as preemption or platform differences that may not cause the maximum amount of time waited to be precisely &lt;code&gt;ms&lt;/code&gt; long.</source>
          <target state="translated">Семантика этой функции эквивалентна &lt;a href=&quot;fn.park&quot;&gt; &lt;code&gt;park&lt;/code&gt; ,&lt;/a&gt; за исключением того, что поток будет заблокирован примерно не дольше &lt;code&gt;dur&lt;/code&gt; . Этот метод не следует использовать для точной синхронизации из-за аномалий, таких как приоритетное прерывание или различия платформ, которые могут не привести к тому, что максимальное время ожидания будет точно равным &lt;code&gt;ms&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8ace657d10944a484e642331ec94fc1a6e6161be" translate="yes" xml:space="preserve">
          <source>The semantics of this function are equivalent to &lt;a href=&quot;struct.condvar#method.wait&quot;&gt;&lt;code&gt;wait&lt;/code&gt;&lt;/a&gt; except that the thread will be blocked for roughly no longer than &lt;code&gt;dur&lt;/code&gt;. This method should not be used for precise timing due to anomalies such as preemption or platform differences that may not cause the maximum amount of time waited to be precisely &lt;code&gt;dur&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d3371efd221cedf557721fc9ee15bda8759a39a9" translate="yes" xml:space="preserve">
          <source>The semantics of this function are equivalent to &lt;a href=&quot;struct.condvar#method.wait&quot;&gt;&lt;code&gt;wait&lt;/code&gt;&lt;/a&gt; except that the thread will be blocked for roughly no longer than &lt;code&gt;ms&lt;/code&gt; milliseconds. This method should not be used for precise timing due to anomalies such as preemption or platform differences that may not cause the maximum amount of time waited to be precisely &lt;code&gt;ms&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6e595d1de9f2e3618f10b608ff234b6ad2944f66" translate="yes" xml:space="preserve">
          <source>The semantics of this function are equivalent to &lt;a href=&quot;struct.condvar#method.wait_while&quot;&gt;&lt;code&gt;wait_while&lt;/code&gt;&lt;/a&gt; except that the thread will be blocked for roughly no longer than &lt;code&gt;dur&lt;/code&gt;. This method should not be used for precise timing due to anomalies such as preemption or platform differences that may not cause the maximum amount of time waited to be precisely &lt;code&gt;dur&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9ce3d66bfcd3164df001d8c8d3ea53b374782f46" translate="yes" xml:space="preserve">
          <source>The semicolon &lt;code&gt;;&lt;/code&gt; can be used to discard the result of an expression at the end of a block, making the expression (and thus the block) evaluate to &lt;code&gt;()&lt;/code&gt;. For example,</source>
          <target state="translated">Точка с запятой &lt;code&gt;;&lt;/code&gt; может использоваться для отбрасывания результата выражения в конце блока, в результате чего выражение (и, следовательно, блок) оценивается как &lt;code&gt;()&lt;/code&gt; . Например,</target>
        </trans-unit>
        <trans-unit id="bb5601bddd79e71c2b7b66e9a5ead92eff60bcdd" translate="yes" xml:space="preserve">
          <source>The send and receive operations on channels will all return a &lt;a href=&quot;../../result/enum.result&quot;&gt;&lt;code&gt;Result&lt;/code&gt;&lt;/a&gt; indicating whether the operation succeeded or not. An unsuccessful operation is normally indicative of the other half of a channel having &quot;hung up&quot; by being dropped in its corresponding thread.</source>
          <target state="translated">Все операции отправки и получения на каналах будут возвращать &lt;a href=&quot;../../result/enum.result&quot;&gt; &lt;code&gt;Result&lt;/code&gt; &lt;/a&gt; указывающий, была ли операция успешной или нет. Неудачная операция обычно указывает на то, что другая половина канала &quot;зависла&quot;, будучи отброшенной в соответствующий поток.</target>
        </trans-unit>
        <trans-unit id="ea8d26ff0d36fb568a938927807eafbc1ae6f29d" translate="yes" xml:space="preserve">
          <source>The sending-half of Rust's asynchronous &lt;a href=&quot;fn.channel&quot;&gt;&lt;code&gt;channel&lt;/code&gt;&lt;/a&gt; type. This half can only be owned by one thread, but it can be cloned to send to other threads.</source>
          <target state="translated">Половина-отправитель типа асинхронного &lt;a href=&quot;fn.channel&quot;&gt; &lt;code&gt;channel&lt;/code&gt; &lt;/a&gt; Rust . Эта половина может принадлежать только одному потоку, но ее можно клонировать для отправки другим потокам.</target>
        </trans-unit>
        <trans-unit id="52ce535fefd9bc68502a1a5978b6409a82fd1bcb" translate="yes" xml:space="preserve">
          <source>The sending-half of Rust's synchronous &lt;a href=&quot;fn.sync_channel&quot;&gt;&lt;code&gt;sync_channel&lt;/code&gt;&lt;/a&gt; type.</source>
          <target state="translated">Половина-отправитель синхронного типа &lt;a href=&quot;fn.sync_channel&quot;&gt; &lt;code&gt;sync_channel&lt;/code&gt; &lt;/a&gt; в Rust .</target>
        </trans-unit>
        <trans-unit id="937e495e6de5b225295fc788a2b8a9723c5d12e3" translate="yes" xml:space="preserve">
          <source>The sequential nature of the tuple applies to its implementations of various traits. For example, in &lt;code&gt;PartialOrd&lt;/code&gt; and &lt;code&gt;Ord&lt;/code&gt;, the elements are compared sequentially until the first non-equal set is found.</source>
          <target state="translated">Последовательный характер кортежа применим к его реализациям различных свойств. Например, в &lt;code&gt;PartialOrd&lt;/code&gt; и &lt;code&gt;Ord&lt;/code&gt; элементы сравниваются последовательно, пока не будет найден первый неравный набор.</target>
        </trans-unit>
        <trans-unit id="faf864ad82a0182728e07d76ebfb5f1fdf6dc8f4" translate="yes" xml:space="preserve">
          <source>The signed two's complement integer types consist of:</source>
          <target state="translated">В число целых чисел,состоящих из знаковых двух,входят целые числа:</target>
        </trans-unit>
        <trans-unit id="0a593fcbffb90fbe9434a8bd0cd231a38381ce34" translate="yes" xml:space="preserve">
          <source>The simplest Rust programs, like the one we&amp;rsquo;ve written so far, don&amp;rsquo;t have any dependencies. So if we had built the &amp;ldquo;Hello, world!&amp;rdquo; project with Cargo, it would only use the part of Cargo that handles building your code. As you write more complex Rust programs, you&amp;rsquo;ll add dependencies, and if you start a project using Cargo, adding dependencies will be much easier to do.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0dca1ad1ce59bbb51cae453b849e2d3bd139c7cf" translate="yes" xml:space="preserve">
          <source>The simplest Rust programs, like the one we&amp;rsquo;ve written so far, don&amp;rsquo;t have any dependencies. So if we had built the Hello, world! project with Cargo, it would only use the part of Cargo that handles building your code. As you write more complex Rust programs, you&amp;rsquo;ll add dependencies, and if you start a project using Cargo, adding dependencies will be much easier to do.</source>
          <target state="translated">Самые простые программы на Rust, подобные той, что мы написали до сих пор, не имеют никаких зависимостей. Итак, если бы мы построили Hello, world! проект с Cargo, он будет использовать только ту часть Cargo, которая занимается сборкой вашего кода. По мере написания более сложных программ на Rust вы будете добавлять зависимости, а если вы начнете проект с использованием Cargo, добавление зависимостей будет намного проще.</target>
        </trans-unit>
        <trans-unit id="cc9fb663ff26b10b3b0480942ea72891d7b9e8a8" translate="yes" xml:space="preserve">
          <source>The single-address property of statics is required.</source>
          <target state="translated">Требуется одноадресное свойство статики.</target>
        </trans-unit>
        <trans-unit id="019cb91a15aad53bc6628eee08e1df33b769b170" translate="yes" xml:space="preserve">
          <source>The size and offset of fields is determined by the following algorithm.</source>
          <target state="translated">Размер и смещение полей определяется следующим алгоритмом.</target>
        </trans-unit>
        <trans-unit id="cd076db2ed4f4f71100b51cbd80768553b1f9904" translate="yes" xml:space="preserve">
          <source>The size of a &lt;code&gt;SocketAddr&lt;/code&gt; instance may vary depending on the target operating system.</source>
          <target state="translated">Размер экземпляра &lt;code&gt;SocketAddr&lt;/code&gt; может варьироваться в зависимости от целевой операционной системы.</target>
        </trans-unit>
        <trans-unit id="36d5ae29044e3939345f3681fd2eee4951ec1d94" translate="yes" xml:space="preserve">
          <source>The size of a &lt;code&gt;SocketAddrV4&lt;/code&gt; struct may vary depending on the target operating system.</source>
          <target state="translated">Размер структуры &lt;code&gt;SocketAddrV4&lt;/code&gt; может варьироваться в зависимости от целевой операционной системы.</target>
        </trans-unit>
        <trans-unit id="aa0a80c41eafe63e764438582cea6579e34fa99a" translate="yes" xml:space="preserve">
          <source>The size of a &lt;code&gt;SocketAddrV6&lt;/code&gt; struct may vary depending on the target operating system.</source>
          <target state="translated">Размер структуры &lt;code&gt;SocketAddrV6&lt;/code&gt; может варьироваться в зависимости от целевой операционной системы.</target>
        </trans-unit>
        <trans-unit id="e8de810002bae6a69cc3fd5fc7b805d907b3e5fa" translate="yes" xml:space="preserve">
          <source>The size of a &lt;code&gt;SystemTime&lt;/code&gt; struct may vary depending on the target operating system.</source>
          <target state="translated">Размер структуры &lt;code&gt;SystemTime&lt;/code&gt; может варьироваться в зависимости от целевой операционной системы.</target>
        </trans-unit>
        <trans-unit id="5b0dd86b903ec8c3b54b21a61cbefcfccd34c7a3" translate="yes" xml:space="preserve">
          <source>The size of a recursive type must be finite; in other words the recursive fields of the type must be &lt;a href=&quot;types/pointer&quot;&gt;pointer types&lt;/a&gt;.</source>
          <target state="translated">Размер рекурсивного типа должен быть конечным; другими словами, рекурсивные поля типа должны быть &lt;a href=&quot;types/pointer&quot;&gt;типами указателей&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="c26f5c42f6a164861e02ed67750e160fcf8f0712" translate="yes" xml:space="preserve">
          <source>The size of a symbolic link is the length of the pathname it contains, without a terminating null byte.</source>
          <target state="translated">Размер символической ссылки-это длина содержащегося в ней патнамента,без прерывистого нулевого байта.</target>
        </trans-unit>
        <trans-unit id="e1eaacf69ef80cbba3a3f01cf2e10bd4a9a5fca5" translate="yes" xml:space="preserve">
          <source>The size of a type in bytes.</source>
          <target state="translated">Размер типа в байтах.</target>
        </trans-unit>
        <trans-unit id="96cd8943bd738b362434700faacd7dc900194564" translate="yes" xml:space="preserve">
          <source>The size of a union is the size of its largest field.</source>
          <target state="translated">Размер союза-это размер его самого большого поля.</target>
        </trans-unit>
        <trans-unit id="b7e7e7e0bae0750a49867bf9a72696378b080c09" translate="yes" xml:space="preserve">
          <source>The size of a value has two definitions.</source>
          <target state="translated">Размер значения имеет два определения.</target>
        </trans-unit>
        <trans-unit id="5e402a67efb4a62fa553a5f1394c869ac08acac0" translate="yes" xml:space="preserve">
          <source>The size of an &lt;code&gt;Instant&lt;/code&gt; struct may vary depending on the target operating system.</source>
          <target state="translated">Размер &lt;code&gt;Instant&lt;/code&gt; структуры может варьироваться в зависимости от целевой операционной системы.</target>
        </trans-unit>
        <trans-unit id="ba89d7b73eb9567f0b0c3196e6cf2e84c9f4c35c" translate="yes" xml:space="preserve">
          <source>The size of an &lt;code&gt;IpAddr&lt;/code&gt; instance may vary depending on the target operating system.</source>
          <target state="translated">Размер экземпляра &lt;code&gt;IpAddr&lt;/code&gt; может варьироваться в зависимости от целевой операционной системы.</target>
        </trans-unit>
        <trans-unit id="64ef5aa718e0f2a4fb9998a036169d75f54db6df" translate="yes" xml:space="preserve">
          <source>The size of an &lt;code&gt;Ipv4Addr&lt;/code&gt; struct may vary depending on the target operating system.</source>
          <target state="translated">Размер структуры &lt;code&gt;Ipv4Addr&lt;/code&gt; может варьироваться в зависимости от целевой операционной системы.</target>
        </trans-unit>
        <trans-unit id="b28d6468d140c4a12bab4e35b4415d244e5f859a" translate="yes" xml:space="preserve">
          <source>The size of an &lt;code&gt;Ipv6Addr&lt;/code&gt; struct may vary depending on the target operating system.</source>
          <target state="translated">Размер структуры &lt;code&gt;Ipv6Addr&lt;/code&gt; может варьироваться в зависимости от целевой операционной системы.</target>
        </trans-unit>
        <trans-unit id="a01d57dab257711e2df9579c72d88d59028c40dc" translate="yes" xml:space="preserve">
          <source>The size of most primitives is given in this table.</source>
          <target state="translated">Размер большинства примитивов приведен в этой таблице.</target>
        </trans-unit>
        <trans-unit id="5a098a792b06569a6bb6f2b7d98cf8797dcd4ec6" translate="yes" xml:space="preserve">
          <source>The size of the referenced value in bytes.</source>
          <target state="translated">Размер ссылочного значения в байтах.</target>
        </trans-unit>
        <trans-unit id="62333b23a5b2b89de3b055144daa334820b9c575" translate="yes" xml:space="preserve">
          <source>The size of this integer type in bits.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7c1fbeb1b5be430f1bc9e3a92e1dadba4b4fdb71" translate="yes" xml:space="preserve">
          <source>The size of this primitive is how many bytes it takes to reference any location in memory. For example, on a 32 bit target, this is 4 bytes and on a 64 bit target, this is 8 bytes.</source>
          <target state="translated">Размер этого примитива-это сколько байт нужно,чтобы обратиться к любому месту в памяти.Например,на 32-битной мишени это 4 байта,а на 64-битной мишени это 8 байт.</target>
        </trans-unit>
        <trans-unit id="eaea58fd5debec4469854dd4c0d7e96ee309fa5f" translate="yes" xml:space="preserve">
          <source>The slice is assumed to be partitioned according to the given predicate. This means that all elements for which the predicate returns true are at the start of the slice and all elements for which the predicate returns false are at the end. For example, [7, 15, 3, 5, 4, 12, 6] is a partitioned under the predicate x % 2 != 0 (all odd numbers are at the start, all even at the end).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8e51743ff7cd79535af677e289113dcff07dbe9c" translate="yes" xml:space="preserve">
          <source>The slice used to create a &lt;a href=&quot;struct.cstr&quot;&gt;&lt;code&gt;CStr&lt;/code&gt;&lt;/a&gt; must have one and only one nul byte at the end of the slice.</source>
          <target state="translated">Срез, используемый для создания &lt;a href=&quot;struct.cstr&quot;&gt; &lt;code&gt;CStr&lt;/code&gt; ,&lt;/a&gt; должен иметь один и только один нулевой байт в конце среза.</target>
        </trans-unit>
        <trans-unit id="06c3ab06faa47dfc08256f59e9e6b62a827af728" translate="yes" xml:space="preserve">
          <source>The slice used to create a &lt;a href=&quot;struct.cstr&quot;&gt;&lt;code&gt;CStr&lt;/code&gt;&lt;/a&gt; must have one and only one nul byte, positioned at the end.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ad56ccc65a97d6c0192795237bde8dc8a187bcc7" translate="yes" xml:space="preserve">
          <source>The slices implement &lt;code&gt;IntoIterator&lt;/code&gt;. The iterator yields references to the slice elements.</source>
          <target state="translated">Срезы реализуют &lt;code&gt;IntoIterator&lt;/code&gt; . Итератор возвращает ссылки на элементы среза.</target>
        </trans-unit>
        <trans-unit id="4d54f29cfdc5fb0b14c6bc3d825908235a2d1e62" translate="yes" xml:space="preserve">
          <source>The smallest value that can be represented by this integer type.</source>
          <target state="translated">Наименьшее значение,которое может быть представлено этим целочисленным типом.</target>
        </trans-unit>
        <trans-unit id="2ed21758c259b01204be09a1e5a970a7587f0275" translate="yes" xml:space="preserve">
          <source>The smallest value that can be represented by this integer type. Use &lt;a href=&quot;../primitive.i128#associatedconstant.MIN&quot;&gt;&lt;code&gt;i128::MIN&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b5a50b28fc392edeb96ae6e8bbc1f3f65f1879e9" translate="yes" xml:space="preserve">
          <source>The smallest value that can be represented by this integer type. Use &lt;a href=&quot;../primitive.i16#associatedconstant.MIN&quot;&gt;&lt;code&gt;i16::MIN&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fab5eaa27a5d1f357d4d2bc91b9af02383caede4" translate="yes" xml:space="preserve">
          <source>The smallest value that can be represented by this integer type. Use &lt;a href=&quot;../primitive.i32#associatedconstant.MIN&quot;&gt;&lt;code&gt;i32::MIN&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fc283863a8f984dedbdb2f90ee6338a2b682ff86" translate="yes" xml:space="preserve">
          <source>The smallest value that can be represented by this integer type. Use &lt;a href=&quot;../primitive.i64#associatedconstant.MIN&quot;&gt;&lt;code&gt;i64::MIN&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="da8fcd8d47309d686d033e491c707f9a8e4582c1" translate="yes" xml:space="preserve">
          <source>The smallest value that can be represented by this integer type. Use &lt;a href=&quot;../primitive.i8#associatedconstant.MIN&quot;&gt;&lt;code&gt;i8::MIN&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="124d5af779df7e9ad406378d4ae95baeff0f8e12" translate="yes" xml:space="preserve">
          <source>The smallest value that can be represented by this integer type. Use &lt;a href=&quot;../primitive.isize#associatedconstant.MIN&quot;&gt;&lt;code&gt;isize::MIN&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d7283dc0e8aef63acf9dd8ecc15410819b62a917" translate="yes" xml:space="preserve">
          <source>The smallest value that can be represented by this integer type. Use &lt;a href=&quot;../primitive.u128#associatedconstant.MIN&quot;&gt;&lt;code&gt;u128::MIN&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4e1d26d88d80abad9936f065a519a8e6dae555c2" translate="yes" xml:space="preserve">
          <source>The smallest value that can be represented by this integer type. Use &lt;a href=&quot;../primitive.u16#associatedconstant.MIN&quot;&gt;&lt;code&gt;u16::MIN&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3c5170dcabff61b3cd439cd574c1475742baecf6" translate="yes" xml:space="preserve">
          <source>The smallest value that can be represented by this integer type. Use &lt;a href=&quot;../primitive.u32#associatedconstant.MIN&quot;&gt;&lt;code&gt;u32::MIN&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0709e957f7976c853e280aae68478111e39066d5" translate="yes" xml:space="preserve">
          <source>The smallest value that can be represented by this integer type. Use &lt;a href=&quot;../primitive.u64#associatedconstant.MIN&quot;&gt;&lt;code&gt;u64::MIN&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fa14915f9b53a3b041d9be135f24e5f469a12ccc" translate="yes" xml:space="preserve">
          <source>The smallest value that can be represented by this integer type. Use &lt;a href=&quot;../primitive.u8#associatedconstant.MIN&quot;&gt;&lt;code&gt;u8::MIN&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="275bb49ca6506b300934116c83ccd1ff11d81477" translate="yes" xml:space="preserve">
          <source>The smallest value that can be represented by this integer type. Use &lt;a href=&quot;../primitive.usize#associatedconstant.MIN&quot;&gt;&lt;code&gt;usize::MIN&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c371b87930b46855075594aef0b191a2dcbb6afc" translate="yes" xml:space="preserve">
          <source>The smart pointer &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; is also not &lt;code&gt;Sync&lt;/code&gt; for the same reasons that it&amp;rsquo;s not &lt;code&gt;Send&lt;/code&gt;. The &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt; type (which we talked about in Chapter 15) and the family of related &lt;code&gt;Cell&amp;lt;T&amp;gt;&lt;/code&gt; types are not &lt;code&gt;Sync&lt;/code&gt;. The implementation of borrow checking that &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt; does at runtime is not thread-safe. The smart pointer &lt;code&gt;Mutex&amp;lt;T&amp;gt;&lt;/code&gt; is &lt;code&gt;Sync&lt;/code&gt; and can be used to share access with multiple threads as you saw in the &lt;a href=&quot;ch16-03-shared-state#sharing-a-mutext-between-multiple-threads&quot;&gt;&amp;ldquo;Sharing a &lt;code&gt;Mutex&amp;lt;T&amp;gt;&lt;/code&gt; Between Multiple Threads&amp;rdquo;&lt;/a&gt; section.</source>
          <target state="translated">Интеллектуальный указатель &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; также не &lt;code&gt;Sync&lt;/code&gt; по тем же причинам, что и не &lt;code&gt;Send&lt;/code&gt; . Тип &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt; (о котором мы говорили в главе 15) и семейство связанных типов &lt;code&gt;Cell&amp;lt;T&amp;gt;&lt;/code&gt; не являются &lt;code&gt;Sync&lt;/code&gt; . Реализация проверки заимствования, которую &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt; выполняет во время выполнения, не является потокобезопасной. Интеллектуальный указатель &lt;code&gt;Mutex&amp;lt;T&amp;gt;&lt;/code&gt; является &lt;code&gt;Sync&lt;/code&gt; и может использоваться для совместного использования доступа с несколькими потоками, как вы видели в разделе &lt;a href=&quot;ch16-03-shared-state#sharing-a-mutext-between-multiple-threads&quot;&gt;&amp;laquo;Совместное использование &lt;code&gt;Mutex&amp;lt;T&amp;gt;&lt;/code&gt; между несколькими потоками&amp;raquo;&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="348ea7c78b50388dc12ad8afa807cfbceb141e14" translate="yes" xml:space="preserve">
          <source>The socket will be closed when the value is dropped.</source>
          <target state="translated">Гнездо будет закрыто,когда значение будет опущено.</target>
        </trans-unit>
        <trans-unit id="26c3406d4e79e978c77c7f71fb4706519f7ecd96" translate="yes" xml:space="preserve">
          <source>The solution here is to return the &lt;code&gt;String&lt;/code&gt; directly:</source>
          <target state="translated">Решение здесь - напрямую вернуть &lt;code&gt;String&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="b153caaa35f5e55b36f6162bb71df5061ac16716" translate="yes" xml:space="preserve">
          <source>The solution is to choose a different name that doesn't conflict with any external crate imported into the current module.</source>
          <target state="translated">Решение заключается в выборе другого имени,не конфликтующего ни с каким внешним ящиком,импортированным в текущий модуль.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
