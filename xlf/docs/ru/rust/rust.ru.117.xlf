<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ru" datatype="htmlbody" original="rust">
    <body>
      <group id="rust">
        <trans-unit id="2c5134e463153b73435701f263a503592ab3d53a" translate="yes" xml:space="preserve">
          <source>Go into the &lt;em&gt;hello_cargo&lt;/em&gt; directory and list the files. You&amp;rsquo;ll see that Cargo has generated two files and one directory for us: a &lt;em&gt;Cargo.toml&lt;/em&gt; file and a &lt;em&gt;src&lt;/em&gt; directory with a &lt;em&gt;main.rs&lt;/em&gt; file inside. It has also initialized a new Git repository along with a &lt;em&gt;.gitignore&lt;/em&gt; file.</source>
          <target state="translated">Перейдите в каталог &lt;em&gt;hello_cargo&lt;/em&gt; и перечислите файлы. Вы увидите, что Cargo сгенерировал для нас два файла и один каталог: файл &lt;em&gt;Cargo.toml&lt;/em&gt; и каталог &lt;em&gt;src&lt;/em&gt; с файлом &lt;em&gt;main.rs&lt;/em&gt; внутри. Он также инициализировал новый репозиторий Git вместе с файлом &lt;em&gt;.gitignore&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="50e6889164bb8054d882b924cda71582b6d6d180" translate="yes" xml:space="preserve">
          <source>Going finite with &lt;a href=&quot;trait.iterator#method.take&quot;&gt;&lt;code&gt;Iterator::take()&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b6849789947c3320fec7645aaddce84614976c34" translate="yes" xml:space="preserve">
          <source>Going finite with &lt;a href=&quot;trait.iterator#method.take&quot;&gt;&lt;code&gt;take&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">Идет конечный с &lt;a href=&quot;trait.iterator#method.take&quot;&gt; &lt;code&gt;take&lt;/code&gt; &lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="62320f24d2e67e3a996b5eb69a47e8e61772abe1" translate="yes" xml:space="preserve">
          <source>Graceful Shutdown and Cleanup</source>
          <target state="translated">Грациозное выключение и очистка</target>
        </trans-unit>
        <trans-unit id="14b567b853879017732fc7e6b51b1225fb2590d3" translate="yes" xml:space="preserve">
          <source>Gradual initialization of an &lt;code&gt;UnsafeCell&lt;/code&gt; requires &lt;code&gt;raw_get&lt;/code&gt;, as calling &lt;code&gt;get&lt;/code&gt; would require creating a reference to uninitialized data:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dd17342cb47b948d64f169d73cfeec3f8b3e3f31" translate="yes" xml:space="preserve">
          <source>Grammar</source>
          <target state="translated">Grammar</target>
        </trans-unit>
        <trans-unit id="78e61d853fc7dbe21e195185b06132c0a0b3267c" translate="yes" xml:space="preserve">
          <source>Great! The code read and then printed the contents of the file. But the code has a few flaws. The &lt;code&gt;main&lt;/code&gt; function has multiple responsibilities: generally, functions are clearer and easier to maintain if each function is responsible for only one idea. The other problem is that we&amp;rsquo;re not handling errors as well as we could. The program is still small, so these flaws aren&amp;rsquo;t a big problem, but as the program grows, it will be harder to fix them cleanly. It&amp;rsquo;s good practice to begin refactoring early on when developing a program, because it&amp;rsquo;s much easier to refactor smaller amounts of code. We&amp;rsquo;ll do that next.</source>
          <target state="translated">Большой! Код прочитал и распечатал содержимое файла. Но в коде есть несколько недостатков. &lt;code&gt;main&lt;/code&gt; функция имеет несколько функций: как правило, функции понятнее и проще в обслуживании , если каждая функция отвечает только одна идея. Другая проблема в том, что мы не так хорошо обрабатываем ошибки, как могли бы. Программа все еще мала, поэтому эти недостатки не являются большой проблемой, но по мере роста программы будет все труднее их исправить. Рекомендуется начинать рефакторинг на ранней стадии разработки программы, потому что гораздо проще рефакторировать меньшие объемы кода. Мы сделаем это дальше.</target>
        </trans-unit>
        <trans-unit id="24a6854de536fe8272a59608dce7cfe696deeaaa" translate="yes" xml:space="preserve">
          <source>Great! They passed. Now, let&amp;rsquo;s call the new &lt;code&gt;search_case_insensitive&lt;/code&gt; function from the &lt;code&gt;run&lt;/code&gt; function. First, we&amp;rsquo;ll add a configuration option to the &lt;code&gt;Config&lt;/code&gt; struct to switch between case-sensitive and case-insensitive search. Adding this field will cause compiler errors because we aren&amp;rsquo;t initializing this field anywhere yet:</source>
          <target state="translated">Большой! Они прошли. Теперь давайте вызовем новую функцию &lt;code&gt;search_case_insensitive&lt;/code&gt; из функции &lt;code&gt;run&lt;/code&gt; . Во-первых, мы добавим параметр &lt;code&gt;Config&lt;/code&gt; структуру Config для переключения между поиском с учетом регистра и без учета регистра. Добавление этого поля вызовет ошибки компилятора, потому что мы еще нигде не инициализируем это поле:</target>
        </trans-unit>
        <trans-unit id="64d373f5a71955e4f9210539868f04851ae696bb" translate="yes" xml:space="preserve">
          <source>Great! This error tells us we need a &lt;code&gt;ThreadPool&lt;/code&gt; type or module, so we&amp;rsquo;ll build one now. Our &lt;code&gt;ThreadPool&lt;/code&gt; implementation will be independent of the kind of work our web server is doing. So, let&amp;rsquo;s switch the &lt;code&gt;hello&lt;/code&gt; crate from a binary crate to a library crate to hold our &lt;code&gt;ThreadPool&lt;/code&gt; implementation. After we change to a library crate, we could also use the separate thread pool library for any work we want to do using a thread pool, not just for serving web requests.</source>
          <target state="translated">Большой! Эта ошибка говорит нам, что нам нужен тип или модуль &lt;code&gt;ThreadPool&lt;/code&gt; , поэтому мы создадим его сейчас. Наша реализация &lt;code&gt;ThreadPool&lt;/code&gt; не будет зависеть от того, какую работу выполняет наш веб-сервер. Итак, давайте переключим ящик &lt;code&gt;hello&lt;/code&gt; с двоичного ящика на ящик библиотеки, в котором будет храниться наша реализация &lt;code&gt;ThreadPool&lt;/code&gt; . После того, как мы перейдем на контейнер с библиотекой, мы также сможем использовать отдельную библиотеку пула потоков для любой работы, которую мы хотим выполнять с использованием пула потоков, а не только для обслуживания веб-запросов.</target>
        </trans-unit>
        <trans-unit id="99b891e6f196f47f49f63f0b20ce223eaba55683" translate="yes" xml:space="preserve">
          <source>Great! This output is much friendlier for our users.</source>
          <target state="translated">Здорово! Этот выход гораздо более дружелюбен для наших пользователей.</target>
        </trans-unit>
        <trans-unit id="2929f4d3537f13046a6a6654b391acff14ad5b53" translate="yes" xml:space="preserve">
          <source>Great, the program is working! The values of the arguments we need are being saved into the right variables. Later we&amp;rsquo;ll add some error handling to deal with certain potential erroneous situations, such as when the user provides no arguments; for now, we&amp;rsquo;ll ignore that situation and work on adding file-reading capabilities instead.</source>
          <target state="translated">Отлично, программа работает! Значения необходимых нам аргументов сохраняются в правильных переменных. Позже мы добавим некоторую обработку ошибок, чтобы иметь дело с некоторыми потенциально ошибочными ситуациями, например, когда пользователь не предоставляет аргументов; пока мы проигнорируем эту ситуацию и вместо этого поработаем над добавлением возможностей чтения файлов.</target>
        </trans-unit>
        <trans-unit id="c5f93da0af9ef56fee44e82925405c317fbf7afc" translate="yes" xml:space="preserve">
          <source>Great, the test fails, exactly as we expected. Let&amp;rsquo;s get the test to pass!</source>
          <target state="translated">Отлично, тест не прошел, как мы и ожидали. Давайте пройдем тест!</target>
        </trans-unit>
        <trans-unit id="599294f23ef04a992bc69ba465066344c3c7cf34" translate="yes" xml:space="preserve">
          <source>Greater than</source>
          <target state="translated">Больше чем</target>
        </trans-unit>
        <trans-unit id="cc21fdb8f5e4e1d5b5c729ed455db20a348682c5" translate="yes" xml:space="preserve">
          <source>Greater than comparison</source>
          <target state="translated">Больше чем для сравнения</target>
        </trans-unit>
        <trans-unit id="a2919540599e9df0beb579ca8d46bdc142657611" translate="yes" xml:space="preserve">
          <source>Greater than or equal to</source>
          <target state="translated">Больше или равно</target>
        </trans-unit>
        <trans-unit id="17e61387621cb5a7a3632ffc26d2a8ab3f16e769" translate="yes" xml:space="preserve">
          <source>Greater than or equal to comparison</source>
          <target state="translated">Больше или равнозначно сравнению</target>
        </trans-unit>
        <trans-unit id="d667800b5ed7b98aa0dde326047666b10d805fc3" translate="yes" xml:space="preserve">
          <source>Greater-than comparison for two &lt;code&gt;Arc&lt;/code&gt;s.</source>
          <target state="translated">Превосходное сравнение для двух &lt;code&gt;Arc&lt;/code&gt; s.</target>
        </trans-unit>
        <trans-unit id="3f06e7136cc69760b0d1c2aa5adb37088b0a0311" translate="yes" xml:space="preserve">
          <source>Greater-than comparison for two &lt;code&gt;Rc&lt;/code&gt;s.</source>
          <target state="translated">Превосходное сравнение для двух &lt;code&gt;Rc&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f464c4ed26773e9c5252581a89a104e8de23d490" translate="yes" xml:space="preserve">
          <source>Greek letters &quot;&amp;alpha;&quot; &quot;&amp;beta;&quot; &quot;&amp;gamma;&quot; &quot;&amp;delta;&quot; stand for potentially empty token-tree sequences. (However, the Greek letter &quot;&amp;epsilon;&quot; (epsilon) has a special role in the presentation and does not stand for a token-tree sequence.)</source>
          <target state="translated">Греческие буквы &amp;laquo;&amp;alpha;&amp;raquo; &amp;laquo;&amp;beta;&amp;raquo; &amp;laquo;&amp;gamma;&amp;raquo; &amp;laquo;&amp;delta;&amp;raquo; обозначают потенциально пустые последовательности дерева лексем. (Однако греческая буква &amp;laquo;&amp;epsilon;&amp;raquo; (эпсилон) играет особую роль в представлении и не обозначает последовательность дерева лексем.)</target>
        </trans-unit>
        <trans-unit id="90accf7e4de3f988bebb9b0fcc656094cc41c05f" translate="yes" xml:space="preserve">
          <source>Group expression attributes</source>
          <target state="translated">Атрибуты группового выражения</target>
        </trans-unit>
        <trans-unit id="ef7a9bb1a692431ae6d8dff02418977a8053e1b7" translate="yes" xml:space="preserve">
          <source>Grouped expressions</source>
          <target state="translated">Сгруппированные выражения</target>
        </trans-unit>
        <trans-unit id="13970f54032da4ae14dbff0318664d8c8f7ae9de" translate="yes" xml:space="preserve">
          <source>Grouped patterns</source>
          <target state="translated">Сгруппированные шаблоны</target>
        </trans-unit>
        <trans-unit id="990b2d14bf2da723821496eca71bc9a4f287e41e" translate="yes" xml:space="preserve">
          <source>Grouping Configuration Values</source>
          <target state="translated">Группировка значений конфигурации</target>
        </trans-unit>
        <trans-unit id="ad08922b155e0f0ecfa878359b6bdba11de6fcc5" translate="yes" xml:space="preserve">
          <source>Groups items</source>
          <target state="translated">Пункты групп</target>
        </trans-unit>
        <trans-unit id="1dee13ac09a18c736a85fb7212501ca3f0535655" translate="yes" xml:space="preserve">
          <source>Gt</source>
          <target state="translated">Gt</target>
        </trans-unit>
        <trans-unit id="e72af43a28130c6f52db641d01a37aabf78c282e" translate="yes" xml:space="preserve">
          <source>Guarantees</source>
          <target state="translated">Guarantees</target>
        </trans-unit>
        <trans-unit id="643a27fb6062be0d6499f01fc4bde0f4334880b4" translate="yes" xml:space="preserve">
          <source>Guidance on which license is appropriate for your project is beyond the scope of this book. Many people in the Rust community license their projects in the same way as Rust by using a dual license of &lt;code&gt;MIT OR Apache-2.0&lt;/code&gt;. This practice demonstrates that you can also specify multiple license identifiers separated by &lt;code&gt;OR&lt;/code&gt; to have multiple licenses for your project.</source>
          <target state="translated">Рекомендации по выбору лицензии, подходящей для вашего проекта, выходят за рамки этой книги. Многие люди в сообществе Rust лицензируют свои проекты так же, как Rust, используя двойную лицензию &lt;code&gt;MIT OR Apache-2.0&lt;/code&gt; . Эта практика демонстрирует, что вы также можете указать несколько идентификаторов лицензий, разделенных оператором &lt;code&gt;OR&lt;/code&gt; чтобы получить несколько лицензий для вашего проекта.</target>
        </trans-unit>
        <trans-unit id="bf073fae640ded81eeb7a4cee70faff4a623c16c" translate="yes" xml:space="preserve">
          <source>Guide</source>
          <target state="translated">Guide</target>
        </trans-unit>
        <trans-unit id="5662999f81a9d63d43963dff643c8f2e0db48c56" translate="yes" xml:space="preserve">
          <source>Guidelines for Error Handling</source>
          <target state="translated">Руководство по обработке ошибок</target>
        </trans-unit>
        <trans-unit id="0b19d1e1b8a5918571f9c9d135638b9f04547d8f" translate="yes" xml:space="preserve">
          <source>HANDLE</source>
          <target state="translated">HANDLE</target>
        </trans-unit>
        <trans-unit id="1a486ce8f36726233061ec65b3f6bda493fd48c9" translate="yes" xml:space="preserve">
          <source>HEX_DIGIT : [&lt;code&gt;0&lt;/code&gt;-&lt;code&gt;9&lt;/code&gt;&lt;code&gt;a&lt;/code&gt;-&lt;code&gt;f&lt;/code&gt;&lt;code&gt;A&lt;/code&gt;-&lt;code&gt;F&lt;/code&gt;]</source>
          <target state="translated">HEX_DIGIT: [ &lt;code&gt;0&lt;/code&gt; - &lt;code&gt;9&lt;/code&gt; - &lt;code&gt;f&lt;/code&gt; - &lt;code&gt;F&lt;/code&gt; ] &lt;code&gt;a&lt;/code&gt; &lt;code&gt;A&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="e195a9555456bea0e92fe340c3ae06ff639810c6" translate="yes" xml:space="preserve">
          <source>HEX_DIGIT&lt;sup&gt;1..6&lt;/sup&gt;</source>
          <target state="translated">HEX_DIGIT&lt;sup&gt;1..6&lt;/sup&gt;</target>
        </trans-unit>
        <trans-unit id="5f9c36747e4699e63511061195cedb992801b9d3" translate="yes" xml:space="preserve">
          <source>HEX_LITERAL :</source>
          <target state="translated">HEX_LITERAL :</target>
        </trans-unit>
        <trans-unit id="85b770e7ec266276f5de99706626234eb555c7b0" translate="yes" xml:space="preserve">
          <source>HTTP is a text-based protocol, and a request takes this format:</source>
          <target state="translated">HTTP является текстовым протоколом,и запрос принимает этот формат:</target>
        </trans-unit>
        <trans-unit id="3c47a723a85c131d97bf2d4bd392d2947fe77f70" translate="yes" xml:space="preserve">
          <source>Had &lt;code&gt;path&lt;/code&gt; contained invalid unicode, the &lt;code&gt;to_string_lossy&lt;/code&gt; call might have returned &lt;code&gt;&quot;fo�.txt&quot;&lt;/code&gt;.</source>
          <target state="translated">Если бы &lt;code&gt;path&lt;/code&gt; содержал недопустимый Unicode, вызов &lt;code&gt;to_string_lossy&lt;/code&gt; мог бы вернуть &lt;code&gt;&quot;fo�.txt&quot;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2ee4aa46e82881f4a75375987b71c3131634f94f" translate="yes" xml:space="preserve">
          <source>Handling Errors Returned from &lt;code id=&quot;handling-errors-returned-from-run-in-main&quot;&gt;run&lt;/code&gt; in &lt;code&gt;main&lt;/code&gt;</source>
          <target state="translated">Обработка ошибок, возвращаемых из &lt;code id=&quot;handling-errors-returned-from-run-in-main&quot;&gt;run&lt;/code&gt; в &lt;code&gt;main&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="187689d6fbeb450bd6ea4e652dae8dbfd0f10e3e" translate="yes" xml:space="preserve">
          <source>Handling I/O</source>
          <target state="translated">Обработка ввода/вывода</target>
        </trans-unit>
        <trans-unit id="f85b58414971efcc7eee439597523a8f745698cd" translate="yes" xml:space="preserve">
          <source>Handling Invalid Input</source>
          <target state="translated">Обработка неверного ввода</target>
        </trans-unit>
        <trans-unit id="99ae89ce9129c070f0e68c272cb53e5ebe7623fe" translate="yes" xml:space="preserve">
          <source>Handling Multiple Conditions with &lt;code id=&quot;handling-multiple-conditions-with-else-if&quot;&gt;else if&lt;/code&gt;</source>
          <target state="translated">Обработка нескольких условий с помощью &lt;code id=&quot;handling-multiple-conditions-with-else-if&quot;&gt;else if&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="59aadebe3071fa59f50f2105cef14ad03fb21914" translate="yes" xml:space="preserve">
          <source>Handling Potential Failure with the &lt;code id=&quot;handling-potential-failure-with-the-result-type&quot;&gt;Result&lt;/code&gt; Type</source>
          <target state="translated">Обработка потенциального отказа с помощью типа &lt;code id=&quot;handling-potential-failure-with-the-result-type&quot;&gt;Result&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="90b8d168f939ff8e48ed694781964a3efae61546" translate="yes" xml:space="preserve">
          <source>Handling concurrent programming safely and efficiently is another of Rust&amp;rsquo;s major goals. &lt;em&gt;Concurrent programming&lt;/em&gt;, where different parts of a program execute independently, and &lt;em&gt;parallel programming&lt;/em&gt;, where different parts of a program execute at the same time, are becoming increasingly important as more computers take advantage of their multiple processors. Historically, programming in these contexts has been difficult and error prone: Rust hopes to change that.</source>
          <target state="translated">Безопасная и эффективная обработка параллельного программирования - еще одна основная цель Rust. &lt;em&gt;Параллельное программирование&lt;/em&gt; , когда разные части программы выполняются независимо, и &lt;em&gt;параллельное программирование&lt;/em&gt; , когда разные части программы выполняются одновременно, становятся все более важными, поскольку все больше компьютеров используют преимущества своих нескольких процессоров. Исторически программирование в этих контекстах было трудным и подверженным ошибкам: Rust надеется изменить это.</target>
        </trans-unit>
        <trans-unit id="8f7b16e3844bb9bbaa86ba42b5bf793b3b5747f5" translate="yes" xml:space="preserve">
          <source>Handling errors (&lt;a href=&quot;ch09-00-error-handling&quot;&gt;Chapter 9&lt;/a&gt;)</source>
          <target state="translated">Обработка ошибок ( &lt;a href=&quot;ch09-00-error-handling&quot;&gt;Глава 9&lt;/a&gt; )</target>
        </trans-unit>
        <trans-unit id="a8a516b582d8ee827caa06b852f0927dd7ea1aa9" translate="yes" xml:space="preserve">
          <source>Handling the error if &lt;code&gt;run&lt;/code&gt; returns an error</source>
          <target state="translated">Обработка ошибки, если при &lt;code&gt;run&lt;/code&gt; возвращается ошибка</target>
        </trans-unit>
        <trans-unit id="9779c3f0bfcc6c7bd84ac8dc1d7d0faaf0886246" translate="yes" xml:space="preserve">
          <source>Has no effect and returns &lt;code&gt;None&lt;/code&gt; if the &lt;code&gt;OnceCell&lt;/code&gt; hasn't been initialized.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="59701e203928fde4afc37f856c0fe1389efbf77a" translate="yes" xml:space="preserve">
          <source>Has no effect and returns &lt;code&gt;None&lt;/code&gt; if the &lt;code&gt;SyncOnceCell&lt;/code&gt; hasn't been initialized.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="605c9af0dc3550ddfefeee4d42138a7f1adc2bd1" translate="yes" xml:space="preserve">
          <source>Has the effects of both &lt;a href=&quot;enum.ordering#variant.Acquire&quot;&gt;&lt;code&gt;Acquire&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;enum.ordering#variant.Release&quot;&gt;&lt;code&gt;Release&lt;/code&gt;&lt;/a&gt; together: For loads it uses &lt;a href=&quot;enum.ordering#variant.Acquire&quot;&gt;&lt;code&gt;Acquire&lt;/code&gt;&lt;/a&gt; ordering. For stores it uses the &lt;a href=&quot;enum.ordering#variant.Release&quot;&gt;&lt;code&gt;Release&lt;/code&gt;&lt;/a&gt; ordering.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="72f36c92a5a7396e8365dbdfe793e5eef4ad9431" translate="yes" xml:space="preserve">
          <source>Has the effects of both &lt;a href=&quot;https://llvm.org/docs/Atomics.html#acquire&quot;&gt;&lt;code&gt;Acquire&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;https://llvm.org/docs/Atomics.html#release&quot;&gt;&lt;code&gt;Release&lt;/code&gt;&lt;/a&gt; together: For loads it uses &lt;a href=&quot;https://llvm.org/docs/Atomics.html#acquire&quot;&gt;&lt;code&gt;Acquire&lt;/code&gt;&lt;/a&gt; ordering. For stores it uses the &lt;a href=&quot;https://llvm.org/docs/Atomics.html#release&quot;&gt;&lt;code&gt;Release&lt;/code&gt;&lt;/a&gt; ordering.</source>
          <target state="translated">Обладает одновременным действием как &lt;a href=&quot;https://llvm.org/docs/Atomics.html#acquire&quot;&gt; &lt;code&gt;Acquire&lt;/code&gt; ,так&lt;/a&gt; и &lt;a href=&quot;https://llvm.org/docs/Atomics.html#release&quot;&gt; &lt;code&gt;Release&lt;/code&gt; &lt;/a&gt; : для нагрузок используется упорядочение &lt;a href=&quot;https://llvm.org/docs/Atomics.html#acquire&quot;&gt; &lt;code&gt;Acquire&lt;/code&gt; &lt;/a&gt; . Для магазинов используется порядок &lt;a href=&quot;https://llvm.org/docs/Atomics.html#release&quot;&gt; &lt;code&gt;Release&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="873507a022b58de26a88deae87268cbd8d6af5b1" translate="yes" xml:space="preserve">
          <source>Hash</source>
          <target state="translated">Hash</target>
        </trans-unit>
        <trans-unit id="d16b2d08d75092ccdbc53063c23e2c3fe71d7f34" translate="yes" xml:space="preserve">
          <source>Hash Maps and Ownership</source>
          <target state="translated">Хэш-Карты и собственность</target>
        </trans-unit>
        <trans-unit id="49d09ebb7291bff93c80ac3f381f55fe8a3c4cbf" translate="yes" xml:space="preserve">
          <source>Hash a raw pointer.</source>
          <target state="translated">Есть сырая указка.</target>
        </trans-unit>
        <trans-unit id="6c5bfe7d7f5d3cec7864d666ab67d3faebb741c0" translate="yes" xml:space="preserve">
          <source>Hash maps are useful when you want to look up data not by using an index, as you can with vectors, but by using a key that can be of any type. For example, in a game, you could keep track of each team&amp;rsquo;s score in a hash map in which each key is a team&amp;rsquo;s name and the values are each team&amp;rsquo;s score. Given a team name, you can retrieve its score.</source>
          <target state="translated">Карты хеширования полезны, когда вы хотите искать данные не с помощью индекса, как с векторами, а с помощью ключа, который может быть любого типа. Например, в игре вы можете отслеживать счет каждой команды в хэш-карте, в которой каждый ключ представляет собой название команды, а значения - счет каждой команды. По названию команды вы можете узнать ее счет.</target>
        </trans-unit>
        <trans-unit id="f26fb9fba1361d959b70bbd8e0907090c8a67651" translate="yes" xml:space="preserve">
          <source>Hash memoization</source>
          <target state="translated">Хэш-память</target>
        </trans-unit>
        <trans-unit id="1ca569e43628039695db4d117d37cb0433c51032" translate="yes" xml:space="preserve">
          <source>Hash::hash</source>
          <target state="translated">Hash::hash</target>
        </trans-unit>
        <trans-unit id="bac71fb916a479ac2558a2194819bf301931ca8b" translate="yes" xml:space="preserve">
          <source>Hash::hash_slice</source>
          <target state="translated">Hash::hash_slice</target>
        </trans-unit>
        <trans-unit id="ba62d7b8d0b157f714c6a6132554b38789c6ada5" translate="yes" xml:space="preserve">
          <source>HashMap</source>
          <target state="translated">HashMap</target>
        </trans-unit>
        <trans-unit id="fb7d8a23eadd1e4ece9d9a20a984c6c31289cb8b" translate="yes" xml:space="preserve">
          <source>HashMap::borrow</source>
          <target state="translated">HashMap::borrow</target>
        </trans-unit>
        <trans-unit id="610c174a39c8908fe163a07919237940fc37c1ca" translate="yes" xml:space="preserve">
          <source>HashMap::borrow_mut</source>
          <target state="translated">HashMap::borrow_mut</target>
        </trans-unit>
        <trans-unit id="5b073a19c1d948d2ff7ea181c3e6faa47ac950b7" translate="yes" xml:space="preserve">
          <source>HashMap::capacity</source>
          <target state="translated">HashMap::capacity</target>
        </trans-unit>
        <trans-unit id="290ef182063e668dbc9d6f81f0f99bd696eaa3ad" translate="yes" xml:space="preserve">
          <source>HashMap::clear</source>
          <target state="translated">HashMap::clear</target>
        </trans-unit>
        <trans-unit id="4504d7762629b3f09d106b8b2c49316387f83111" translate="yes" xml:space="preserve">
          <source>HashMap::clone</source>
          <target state="translated">HashMap::clone</target>
        </trans-unit>
        <trans-unit id="755ecc8e2fe0d53bf8d40f09d15dc41f5c72dee3" translate="yes" xml:space="preserve">
          <source>HashMap::clone_from</source>
          <target state="translated">HashMap::clone_from</target>
        </trans-unit>
        <trans-unit id="18149fd5a2f0ddb0a754ee5b20ae060122824af4" translate="yes" xml:space="preserve">
          <source>HashMap::clone_into</source>
          <target state="translated">HashMap::clone_into</target>
        </trans-unit>
        <trans-unit id="c981dd589a66a9541ad1bd942f956a943a21c776" translate="yes" xml:space="preserve">
          <source>HashMap::contains_key</source>
          <target state="translated">HashMap::contains_key</target>
        </trans-unit>
        <trans-unit id="6790c064706283f72985a00fd5d63757494362ee" translate="yes" xml:space="preserve">
          <source>HashMap::default</source>
          <target state="translated">HashMap::default</target>
        </trans-unit>
        <trans-unit id="ef89e29aa59c76930b39d07bb7c27f4f62ca4bc9" translate="yes" xml:space="preserve">
          <source>HashMap::drain</source>
          <target state="translated">HashMap::drain</target>
        </trans-unit>
        <trans-unit id="5c70bb5f39da25e4a3243cd372f9722cdd0aaa06" translate="yes" xml:space="preserve">
          <source>HashMap::entry</source>
          <target state="translated">HashMap::entry</target>
        </trans-unit>
        <trans-unit id="16580b886dde904eb2189a50aaa2ec8e66754a76" translate="yes" xml:space="preserve">
          <source>HashMap::eq</source>
          <target state="translated">HashMap::eq</target>
        </trans-unit>
        <trans-unit id="006972122bed4c52275751aaa6b1a76aa26a72f6" translate="yes" xml:space="preserve">
          <source>HashMap::extend</source>
          <target state="translated">HashMap::extend</target>
        </trans-unit>
        <trans-unit id="eef27e5aeaaee7ca97ef32c4174c3b7aefbfc638" translate="yes" xml:space="preserve">
          <source>HashMap::fmt</source>
          <target state="translated">HashMap::fmt</target>
        </trans-unit>
        <trans-unit id="2bac685119eec98678bcc3e2df09e34b76b251fb" translate="yes" xml:space="preserve">
          <source>HashMap::from</source>
          <target state="translated">HashMap::from</target>
        </trans-unit>
        <trans-unit id="23702b4af8c6608c05d1fc72b700af47889b23e4" translate="yes" xml:space="preserve">
          <source>HashMap::from_iter</source>
          <target state="translated">HashMap::from_iter</target>
        </trans-unit>
        <trans-unit id="688fd04b9fb0128d305e248d2f3d8f8222392c9c" translate="yes" xml:space="preserve">
          <source>HashMap::get</source>
          <target state="translated">HashMap::get</target>
        </trans-unit>
        <trans-unit id="ecd394b5e97d505b5180c88396d32eb04f7a2ef5" translate="yes" xml:space="preserve">
          <source>HashMap::get_key_value</source>
          <target state="translated">HashMap::get_key_value</target>
        </trans-unit>
        <trans-unit id="59fd726634d31c7b61261668c05f7485bf9decb1" translate="yes" xml:space="preserve">
          <source>HashMap::get_mut</source>
          <target state="translated">HashMap::get_mut</target>
        </trans-unit>
        <trans-unit id="9e2f5e352b69c23e1f8634441216dbbc589410a2" translate="yes" xml:space="preserve">
          <source>HashMap::hasher</source>
          <target state="translated">HashMap::hasher</target>
        </trans-unit>
        <trans-unit id="977407424016d1150ed5a54f71aa720d8b5fc1e0" translate="yes" xml:space="preserve">
          <source>HashMap::index</source>
          <target state="translated">HashMap::index</target>
        </trans-unit>
        <trans-unit id="575b9b99b8b6536e98f82916772ec179324759de" translate="yes" xml:space="preserve">
          <source>HashMap::insert</source>
          <target state="translated">HashMap::insert</target>
        </trans-unit>
        <trans-unit id="4241974ff3713d57ec86ed4fb2960fb964b4c28f" translate="yes" xml:space="preserve">
          <source>HashMap::into</source>
          <target state="translated">HashMap::into</target>
        </trans-unit>
        <trans-unit id="2ee397e85e03d2df5163ed8c1f36f63a8275c934" translate="yes" xml:space="preserve">
          <source>HashMap::into_iter</source>
          <target state="translated">HashMap::into_iter</target>
        </trans-unit>
        <trans-unit id="a649d7141d86759b290a9b727d47ad161b114361" translate="yes" xml:space="preserve">
          <source>HashMap::is_empty</source>
          <target state="translated">HashMap::is_empty</target>
        </trans-unit>
        <trans-unit id="cfdbb20825a41950e4f6625ab41ffc0a12e6cfd4" translate="yes" xml:space="preserve">
          <source>HashMap::iter</source>
          <target state="translated">HashMap::iter</target>
        </trans-unit>
        <trans-unit id="2bfca7b0b17c04d487077c012bec3c640635d95c" translate="yes" xml:space="preserve">
          <source>HashMap::iter_mut</source>
          <target state="translated">HashMap::iter_mut</target>
        </trans-unit>
        <trans-unit id="15748fe38a254ba57dde931f14941b25230915de" translate="yes" xml:space="preserve">
          <source>HashMap::keys</source>
          <target state="translated">HashMap::keys</target>
        </trans-unit>
        <trans-unit id="013a2db0fc0510df2be8bb9a81336355dd6c81f5" translate="yes" xml:space="preserve">
          <source>HashMap::len</source>
          <target state="translated">HashMap::len</target>
        </trans-unit>
        <trans-unit id="bbd14da0450a45b2de193fcab5c00bb0eb5903d6" translate="yes" xml:space="preserve">
          <source>HashMap::ne</source>
          <target state="translated">HashMap::ne</target>
        </trans-unit>
        <trans-unit id="7a43b41cd29931fa0443de6420eab17418a5775e" translate="yes" xml:space="preserve">
          <source>HashMap::new</source>
          <target state="translated">HashMap::new</target>
        </trans-unit>
        <trans-unit id="292e274cb26beafe87f9986cd7a69d6e80f0d70e" translate="yes" xml:space="preserve">
          <source>HashMap::raw_entry</source>
          <target state="translated">HashMap::raw_entry</target>
        </trans-unit>
        <trans-unit id="ddac1348f5646998be5c764f10f7f59d986ae24a" translate="yes" xml:space="preserve">
          <source>HashMap::raw_entry_mut</source>
          <target state="translated">HashMap::raw_entry_mut</target>
        </trans-unit>
        <trans-unit id="eb7e68ea1cad35b4a180ddda2294c0954904ff9c" translate="yes" xml:space="preserve">
          <source>HashMap::remove</source>
          <target state="translated">HashMap::remove</target>
        </trans-unit>
        <trans-unit id="daa065a9f2946c9de97f049237fe61d1096fd3ad" translate="yes" xml:space="preserve">
          <source>HashMap::remove_entry</source>
          <target state="translated">HashMap::remove_entry</target>
        </trans-unit>
        <trans-unit id="0121bfc051e62887774fc3f9ec592514d686885b" translate="yes" xml:space="preserve">
          <source>HashMap::reserve</source>
          <target state="translated">HashMap::reserve</target>
        </trans-unit>
        <trans-unit id="88a2076f3660ecd79e0adb0243f0e9d4a8862721" translate="yes" xml:space="preserve">
          <source>HashMap::retain</source>
          <target state="translated">HashMap::retain</target>
        </trans-unit>
        <trans-unit id="f4991ea8c7797b408f7805334922bf7e0c8d10d6" translate="yes" xml:space="preserve">
          <source>HashMap::shrink_to</source>
          <target state="translated">HashMap::shrink_to</target>
        </trans-unit>
        <trans-unit id="dc8f377e69db6a1e9ed141ae6bf011880bd42c53" translate="yes" xml:space="preserve">
          <source>HashMap::shrink_to_fit</source>
          <target state="translated">HashMap::shrink_to_fit</target>
        </trans-unit>
        <trans-unit id="bab5c2ac135dfe90b9b32c652153883ceeee3b33" translate="yes" xml:space="preserve">
          <source>HashMap::to_owned</source>
          <target state="translated">HashMap::to_owned</target>
        </trans-unit>
        <trans-unit id="391acc19f610e927b497bb4e11b352a7b2af949e" translate="yes" xml:space="preserve">
          <source>HashMap::try_from</source>
          <target state="translated">HashMap::try_from</target>
        </trans-unit>
        <trans-unit id="2893c51bf9c281d2ca7aba047803684d9a1aa860" translate="yes" xml:space="preserve">
          <source>HashMap::try_into</source>
          <target state="translated">HashMap::try_into</target>
        </trans-unit>
        <trans-unit id="9e7015c3cc0d5bc1003d09ff24337d2b0ad55c7b" translate="yes" xml:space="preserve">
          <source>HashMap::try_reserve</source>
          <target state="translated">HashMap::try_reserve</target>
        </trans-unit>
        <trans-unit id="b2ebec04fba53bc16fb11b0073bb6cc66af50890" translate="yes" xml:space="preserve">
          <source>HashMap::type_id</source>
          <target state="translated">HashMap::type_id</target>
        </trans-unit>
        <trans-unit id="d17a786e030134db4f1882f47a85dce856cb6c49" translate="yes" xml:space="preserve">
          <source>HashMap::values</source>
          <target state="translated">HashMap::values</target>
        </trans-unit>
        <trans-unit id="162e585c9055d46d3b3067b924bb60d67e948304" translate="yes" xml:space="preserve">
          <source>HashMap::values_mut</source>
          <target state="translated">HashMap::values_mut</target>
        </trans-unit>
        <trans-unit id="01bde569a6ca247f70b925283ac4eabf1fae164b" translate="yes" xml:space="preserve">
          <source>HashMap::with_capacity</source>
          <target state="translated">HashMap::with_capacity</target>
        </trans-unit>
        <trans-unit id="c95ee5e43e53e6378ec649a9c2e69ab43598f8fb" translate="yes" xml:space="preserve">
          <source>HashMap::with_capacity_and_hasher</source>
          <target state="translated">HashMap::with_capacity_and_hasher</target>
        </trans-unit>
        <trans-unit id="e7c4071d4f77cdf1820942e0c1ab3de0a91ed2cf" translate="yes" xml:space="preserve">
          <source>HashMap::with_hasher</source>
          <target state="translated">HashMap::with_hasher</target>
        </trans-unit>
        <trans-unit id="cac17f9bdb6febebe0052a72f2ab8a6828d20944" translate="yes" xml:space="preserve">
          <source>HashSet</source>
          <target state="translated">HashSet</target>
        </trans-unit>
        <trans-unit id="b68646e63dfce36d83be9cbaa54a303ef6a007af" translate="yes" xml:space="preserve">
          <source>HashSet::bitand</source>
          <target state="translated">HashSet::bitand</target>
        </trans-unit>
        <trans-unit id="1ab81639812d7d4b62dc39b7419600230fdcf25f" translate="yes" xml:space="preserve">
          <source>HashSet::bitor</source>
          <target state="translated">HashSet::bitor</target>
        </trans-unit>
        <trans-unit id="8075cc2581f90ca9a8938fc5f82b21b6e3d28edf" translate="yes" xml:space="preserve">
          <source>HashSet::bitxor</source>
          <target state="translated">HashSet::bitxor</target>
        </trans-unit>
        <trans-unit id="c77b68f5068bcecde6e8ffd8572dfb041513399a" translate="yes" xml:space="preserve">
          <source>HashSet::borrow</source>
          <target state="translated">HashSet::borrow</target>
        </trans-unit>
        <trans-unit id="03d0b56c31db1f8ba8c12e20646074ec753d52c9" translate="yes" xml:space="preserve">
          <source>HashSet::borrow_mut</source>
          <target state="translated">HashSet::borrow_mut</target>
        </trans-unit>
        <trans-unit id="bdd5342708fbc173156c0ad0e7ccdcf72b87bbec" translate="yes" xml:space="preserve">
          <source>HashSet::capacity</source>
          <target state="translated">HashSet::capacity</target>
        </trans-unit>
        <trans-unit id="b496a7fc22db5dfee5a71eb5501bd54af27226af" translate="yes" xml:space="preserve">
          <source>HashSet::clear</source>
          <target state="translated">HashSet::clear</target>
        </trans-unit>
        <trans-unit id="f6f7e84776c0a1492c95ca329cccd559dae22239" translate="yes" xml:space="preserve">
          <source>HashSet::clone</source>
          <target state="translated">HashSet::clone</target>
        </trans-unit>
        <trans-unit id="ad872e535653208fd311ddac1851f60e92c27461" translate="yes" xml:space="preserve">
          <source>HashSet::clone_from</source>
          <target state="translated">HashSet::clone_from</target>
        </trans-unit>
        <trans-unit id="30071df27bb602cc36f2524cd6272f86cf175d82" translate="yes" xml:space="preserve">
          <source>HashSet::clone_into</source>
          <target state="translated">HashSet::clone_into</target>
        </trans-unit>
        <trans-unit id="e9929a76352b9c6c4517057784d174ca502e4659" translate="yes" xml:space="preserve">
          <source>HashSet::contains</source>
          <target state="translated">HashSet::contains</target>
        </trans-unit>
        <trans-unit id="ee9499c5d925a80b927374f5fc18c8cf7acba286" translate="yes" xml:space="preserve">
          <source>HashSet::default</source>
          <target state="translated">HashSet::default</target>
        </trans-unit>
        <trans-unit id="c5666651d6d13e045665faaee91da5ee35aefa99" translate="yes" xml:space="preserve">
          <source>HashSet::difference</source>
          <target state="translated">HashSet::difference</target>
        </trans-unit>
        <trans-unit id="559bf337908631f9dc2cd3ab1c34c4b7158b1609" translate="yes" xml:space="preserve">
          <source>HashSet::drain</source>
          <target state="translated">HashSet::drain</target>
        </trans-unit>
        <trans-unit id="f25e9846b65f287b930b9d456cbbec8f01e240e9" translate="yes" xml:space="preserve">
          <source>HashSet::eq</source>
          <target state="translated">HashSet::eq</target>
        </trans-unit>
        <trans-unit id="6a91f6923c3310862ee3596940ed5b097a1bf087" translate="yes" xml:space="preserve">
          <source>HashSet::extend</source>
          <target state="translated">HashSet::extend</target>
        </trans-unit>
        <trans-unit id="8be48241f0d314ab0acacea29d3d926070bb5fa9" translate="yes" xml:space="preserve">
          <source>HashSet::fmt</source>
          <target state="translated">HashSet::fmt</target>
        </trans-unit>
        <trans-unit id="b4f60277034657d60f3728ccd3956ff96b1819e2" translate="yes" xml:space="preserve">
          <source>HashSet::from</source>
          <target state="translated">HashSet::from</target>
        </trans-unit>
        <trans-unit id="60f387d38899e1b57c8d30e798c352963e26a097" translate="yes" xml:space="preserve">
          <source>HashSet::from_iter</source>
          <target state="translated">HashSet::from_iter</target>
        </trans-unit>
        <trans-unit id="33cae8d46ad9832e17073c4a9f1abb51a6504d81" translate="yes" xml:space="preserve">
          <source>HashSet::get</source>
          <target state="translated">HashSet::get</target>
        </trans-unit>
        <trans-unit id="6c7ba6a45c151f970088dcc70a1b7618e6395baf" translate="yes" xml:space="preserve">
          <source>HashSet::get_or_insert</source>
          <target state="translated">HashSet::get_or_insert</target>
        </trans-unit>
        <trans-unit id="3c9bf791b1bc89ff50ed8e094f3d77efdc799512" translate="yes" xml:space="preserve">
          <source>HashSet::get_or_insert_with</source>
          <target state="translated">HashSet::get_or_insert_with</target>
        </trans-unit>
        <trans-unit id="01c1744d870244b7145beb071040d269b906cc15" translate="yes" xml:space="preserve">
          <source>HashSet::hasher</source>
          <target state="translated">HashSet::hasher</target>
        </trans-unit>
        <trans-unit id="6f9a670d4aa69b73fdbaf199b1f0dd8253423bff" translate="yes" xml:space="preserve">
          <source>HashSet::insert</source>
          <target state="translated">HashSet::insert</target>
        </trans-unit>
        <trans-unit id="5c5bf765bc94406fc16ab265fee5caf8d4d6d147" translate="yes" xml:space="preserve">
          <source>HashSet::intersection</source>
          <target state="translated">HashSet::intersection</target>
        </trans-unit>
        <trans-unit id="1847c872f1c798ce2ed7fda1f927b3db87be02ae" translate="yes" xml:space="preserve">
          <source>HashSet::into</source>
          <target state="translated">HashSet::into</target>
        </trans-unit>
        <trans-unit id="06dc65fe61329213ae7394dadf80b120758e58bf" translate="yes" xml:space="preserve">
          <source>HashSet::into_iter</source>
          <target state="translated">HashSet::into_iter</target>
        </trans-unit>
        <trans-unit id="67c6eb738c50bfb089cc9e9dd3c556b76c5e5a19" translate="yes" xml:space="preserve">
          <source>HashSet::is_disjoint</source>
          <target state="translated">HashSet::is_disjoint</target>
        </trans-unit>
        <trans-unit id="9463f6acefaba610600eb7b086516e06a56e7415" translate="yes" xml:space="preserve">
          <source>HashSet::is_empty</source>
          <target state="translated">HashSet::is_empty</target>
        </trans-unit>
        <trans-unit id="3494ecfcdfcc0fd49b4716ada245492c590484c8" translate="yes" xml:space="preserve">
          <source>HashSet::is_subset</source>
          <target state="translated">HashSet::is_subset</target>
        </trans-unit>
        <trans-unit id="5a5bed7c64ac7bd90ff2fd3978bbf37d738addfa" translate="yes" xml:space="preserve">
          <source>HashSet::is_superset</source>
          <target state="translated">HashSet::is_superset</target>
        </trans-unit>
        <trans-unit id="d4aa44a96215a84918fccfb358fa46f4343aa9e3" translate="yes" xml:space="preserve">
          <source>HashSet::iter</source>
          <target state="translated">HashSet::iter</target>
        </trans-unit>
        <trans-unit id="e772fc3259c95bf6f1d149e4fe5b58f7beb84957" translate="yes" xml:space="preserve">
          <source>HashSet::len</source>
          <target state="translated">HashSet::len</target>
        </trans-unit>
        <trans-unit id="9d950bd82fcd2e87760e296232658decf6487907" translate="yes" xml:space="preserve">
          <source>HashSet::ne</source>
          <target state="translated">HashSet::ne</target>
        </trans-unit>
        <trans-unit id="faff6aa961e961cb5d0e5be8b0c1765f5a91c089" translate="yes" xml:space="preserve">
          <source>HashSet::new</source>
          <target state="translated">HashSet::new</target>
        </trans-unit>
        <trans-unit id="ab12b0529a6e1a5dea72839456e2d81f89fbb648" translate="yes" xml:space="preserve">
          <source>HashSet::remove</source>
          <target state="translated">HashSet::remove</target>
        </trans-unit>
        <trans-unit id="11dfa3918fa59c9dba2c405236023985e68113d1" translate="yes" xml:space="preserve">
          <source>HashSet::replace</source>
          <target state="translated">HashSet::replace</target>
        </trans-unit>
        <trans-unit id="f3111bd9bb9284dd24b994e9c70b335390828fac" translate="yes" xml:space="preserve">
          <source>HashSet::reserve</source>
          <target state="translated">HashSet::reserve</target>
        </trans-unit>
        <trans-unit id="ce64d74e2bc22c15cfa1eaba2edb312838993eda" translate="yes" xml:space="preserve">
          <source>HashSet::retain</source>
          <target state="translated">HashSet::retain</target>
        </trans-unit>
        <trans-unit id="029a9cdc9ae9ee65ed460a0ec02d113e093964b2" translate="yes" xml:space="preserve">
          <source>HashSet::shrink_to</source>
          <target state="translated">HashSet::shrink_to</target>
        </trans-unit>
        <trans-unit id="3aba29e196a563c0a26e6c5d67e4388b6713cebf" translate="yes" xml:space="preserve">
          <source>HashSet::shrink_to_fit</source>
          <target state="translated">HashSet::shrink_to_fit</target>
        </trans-unit>
        <trans-unit id="137d5ee967421f3423450e1436080f3b38640647" translate="yes" xml:space="preserve">
          <source>HashSet::sub</source>
          <target state="translated">HashSet::sub</target>
        </trans-unit>
        <trans-unit id="39cf21ce1dee41e9b1e7cb0c554d9ccf20702455" translate="yes" xml:space="preserve">
          <source>HashSet::symmetric_difference</source>
          <target state="translated">HashSet::symmetric_difference</target>
        </trans-unit>
        <trans-unit id="b78b12fa7d65d7ed557c2e12c743c86bcbc88775" translate="yes" xml:space="preserve">
          <source>HashSet::take</source>
          <target state="translated">HashSet::take</target>
        </trans-unit>
        <trans-unit id="93138236c5609c2dee4b1e913e9fcc9e3e9fdf44" translate="yes" xml:space="preserve">
          <source>HashSet::to_owned</source>
          <target state="translated">HashSet::to_owned</target>
        </trans-unit>
        <trans-unit id="96f13425b733a2e08673b87dffc523aee111609b" translate="yes" xml:space="preserve">
          <source>HashSet::try_from</source>
          <target state="translated">HashSet::try_from</target>
        </trans-unit>
        <trans-unit id="85d076b1561829592d046d057f0210cf9a4ff355" translate="yes" xml:space="preserve">
          <source>HashSet::try_into</source>
          <target state="translated">HashSet::try_into</target>
        </trans-unit>
        <trans-unit id="a9c0b3c82611415705e046ee581719e01be9eecc" translate="yes" xml:space="preserve">
          <source>HashSet::try_reserve</source>
          <target state="translated">HashSet::try_reserve</target>
        </trans-unit>
        <trans-unit id="105a18b817256119cb17af97da897c56eba29e40" translate="yes" xml:space="preserve">
          <source>HashSet::type_id</source>
          <target state="translated">HashSet::type_id</target>
        </trans-unit>
        <trans-unit id="685fa7682d344986ee2f2ae55086a7531364bc35" translate="yes" xml:space="preserve">
          <source>HashSet::union</source>
          <target state="translated">HashSet::union</target>
        </trans-unit>
        <trans-unit id="c3204331b41dcd6ae424437b8e36081a10f0c506" translate="yes" xml:space="preserve">
          <source>HashSet::with_capacity</source>
          <target state="translated">HashSet::with_capacity</target>
        </trans-unit>
        <trans-unit id="6bb25440ddefbed0a8db0d432f23f0ca38d089d8" translate="yes" xml:space="preserve">
          <source>HashSet::with_capacity_and_hasher</source>
          <target state="translated">HashSet::with_capacity_and_hasher</target>
        </trans-unit>
        <trans-unit id="550d3800dfa4eb2bdb493d733dabf4b1ffabf984" translate="yes" xml:space="preserve">
          <source>HashSet::with_hasher</source>
          <target state="translated">HashSet::with_hasher</target>
        </trans-unit>
        <trans-unit id="fc0f48d98ae0d2092a247d5cee9ccdb867d1d001" translate="yes" xml:space="preserve">
          <source>Hasher</source>
          <target state="translated">Hasher</target>
        </trans-unit>
        <trans-unit id="e9a193bcbf138ba881c64b5b1a29eba015da6009" translate="yes" xml:space="preserve">
          <source>Hasher::finish</source>
          <target state="translated">Hasher::finish</target>
        </trans-unit>
        <trans-unit id="2b1c79f133b4285e8cbe820d3b0dbaa110a81b6c" translate="yes" xml:space="preserve">
          <source>Hasher::write</source>
          <target state="translated">Hasher::write</target>
        </trans-unit>
        <trans-unit id="aea45433ea07ad24495217b0093e410e9770ebb6" translate="yes" xml:space="preserve">
          <source>Hasher::write_i128</source>
          <target state="translated">Hasher::write_i128</target>
        </trans-unit>
        <trans-unit id="f97466e2fd5ec3a618a0b518a5dd39118b1b15e0" translate="yes" xml:space="preserve">
          <source>Hasher::write_i16</source>
          <target state="translated">Hasher::write_i16</target>
        </trans-unit>
        <trans-unit id="10de8ddcd6d092ee0ae793c2f146d59545948d06" translate="yes" xml:space="preserve">
          <source>Hasher::write_i32</source>
          <target state="translated">Hasher::write_i32</target>
        </trans-unit>
        <trans-unit id="fa2e80124215b4059a687baa99ddde7e8adc899d" translate="yes" xml:space="preserve">
          <source>Hasher::write_i64</source>
          <target state="translated">Hasher::write_i64</target>
        </trans-unit>
        <trans-unit id="fe5b0947dfe31def847c17d1e11ec3d408a4124c" translate="yes" xml:space="preserve">
          <source>Hasher::write_i8</source>
          <target state="translated">Hasher::write_i8</target>
        </trans-unit>
        <trans-unit id="53164f3f3dd297fb85292187a041f87e1d16695e" translate="yes" xml:space="preserve">
          <source>Hasher::write_isize</source>
          <target state="translated">Hasher::write_isize</target>
        </trans-unit>
        <trans-unit id="e477fb5169da10ce163639bd122b949d5314f471" translate="yes" xml:space="preserve">
          <source>Hasher::write_u128</source>
          <target state="translated">Hasher::write_u128</target>
        </trans-unit>
        <trans-unit id="05c5de3720de3f253e1541c3b244cb58450b4be2" translate="yes" xml:space="preserve">
          <source>Hasher::write_u16</source>
          <target state="translated">Hasher::write_u16</target>
        </trans-unit>
        <trans-unit id="1cf90d27fda48a3335fb25c8aa60e25c50bc3767" translate="yes" xml:space="preserve">
          <source>Hasher::write_u32</source>
          <target state="translated">Hasher::write_u32</target>
        </trans-unit>
        <trans-unit id="420bdb25cc27d8fac4c5399c4359ccee510eacbd" translate="yes" xml:space="preserve">
          <source>Hasher::write_u64</source>
          <target state="translated">Hasher::write_u64</target>
        </trans-unit>
        <trans-unit id="82a921392efa7001c790d5b80024db7be281f9cb" translate="yes" xml:space="preserve">
          <source>Hasher::write_u8</source>
          <target state="translated">Hasher::write_u8</target>
        </trans-unit>
        <trans-unit id="d1a0408c2f79ae7c9f420468772c41716a5e1a04" translate="yes" xml:space="preserve">
          <source>Hasher::write_usize</source>
          <target state="translated">Hasher::write_usize</target>
        </trans-unit>
        <trans-unit id="461629db972167b8f4c1f8c130db9885c4944304" translate="yes" xml:space="preserve">
          <source>Hashing Functions</source>
          <target state="translated">Функции фиксации</target>
        </trans-unit>
        <trans-unit id="baf48f49b04e2fe65712d113e9024e4c5a00d1bc" translate="yes" xml:space="preserve">
          <source>Haskell (GHC): typeclasses, type families</source>
          <target state="translated">Хаскелл (GHC):шрифтовые классы,семейства типов.</target>
        </trans-unit>
        <trans-unit id="0561de3a6257f6d36364146fd6581f1315dd2333" translate="yes" xml:space="preserve">
          <source>Having &lt;code&gt;common&lt;/code&gt; appear in the test results with &lt;code&gt;running 0 tests&lt;/code&gt; displayed for it is not what we wanted. We just wanted to share some code with the other integration test files.</source>
          <target state="translated">Имея &lt;code&gt;common&lt;/code&gt; в результатах тестов с &lt;code&gt;running 0 tests&lt;/code&gt; , отображаемых для него не то , что мы хотели. Мы просто хотели поделиться кодом с другими файлами интеграционных тестов.</target>
        </trans-unit>
        <trans-unit id="11f087b15a668ce62e66a014863909ef9d55cd94" translate="yes" xml:space="preserve">
          <source>Having Multiple Owners of Mutable Data by Combining &lt;code id=&quot;having-multiple-owners-of-mutable-data-by-combining-rct-and-refcellt&quot;&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; and &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt;</source>
          <target state="translated">Наличие нескольких владельцев изменяемых данных за счет объединения &lt;code id=&quot;having-multiple-owners-of-mutable-data-by-combining-rct-and-refcellt&quot;&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; и &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="b3039ad6abf86928bcfdadaa49d3256f9e624f29" translate="yes" xml:space="preserve">
          <source>Having multiple relaxed default bounds is unsupported.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6b19652c5d2b3e9984ece4975d1cc403d1ab4a0a" translate="yes" xml:space="preserve">
          <source>Having one mutable reference (&lt;code&gt;&amp;amp;mut T&lt;/code&gt;) to the object (also known as &lt;strong&gt;mutability&lt;/strong&gt;).</source>
          <target state="translated">Имея одну изменяемой ссылки ( &lt;code&gt;&amp;amp;mut T&lt;/code&gt; ) к объекту (также известному как &lt;strong&gt;мутабильность&lt;/strong&gt; ).</target>
        </trans-unit>
        <trans-unit id="08041929016b8a695800e1c093d6357eb61d9428" translate="yes" xml:space="preserve">
          <source>Having several immutable references (&lt;code&gt;&amp;amp;T&lt;/code&gt;) to the object (also known as &lt;strong&gt;aliasing&lt;/strong&gt;).</source>
          <target state="translated">Наличие нескольких неизменяемых ссылок ( &lt;code&gt;&amp;amp;T&lt;/code&gt; ) на объект (также известное как &lt;strong&gt;псевдоним&lt;/strong&gt; ).</target>
        </trans-unit>
        <trans-unit id="89c8fa1c2c4d0b146e76f764a7dc959cbfc87737" translate="yes" xml:space="preserve">
          <source>Having to worry about the index in &lt;code&gt;word&lt;/code&gt; getting out of sync with the data in &lt;code&gt;s&lt;/code&gt; is tedious and error prone! Managing these indices is even more brittle if we write a &lt;code&gt;second_word&lt;/code&gt; function. Its signature would have to look like this:</source>
          <target state="translated">Беспокойство о том, что индекс в &lt;code&gt;word&lt;/code&gt; не синхронизируется с данными в &lt;code&gt;s&lt;/code&gt; , утомительно и чревато ошибками! Управление этими индексами станет еще более хрупким, если мы напишем функцию &lt;code&gt;second_word&lt;/code&gt; . Его подпись должна была выглядеть так:</target>
        </trans-unit>
        <trans-unit id="257810d9a0b57b3d3f2b083b4e88460a9ed6c299" translate="yes" xml:space="preserve">
          <source>Hello, Cargo!</source>
          <target state="translated">Привет,Грузовик!</target>
        </trans-unit>
        <trans-unit id="0a0a9f2a6772942557ab5355d76af442f8f65e01" translate="yes" xml:space="preserve">
          <source>Hello, World!</source>
          <target state="translated">Привет,Ворлд!</target>
        </trans-unit>
        <trans-unit id="d9d2b1e388fd73fa4e7cc0203db99342ed1255e1" translate="yes" xml:space="preserve">
          <source>Helper struct for safely printing paths with &lt;a href=&quot;../macro.format&quot;&gt;&lt;code&gt;format!&lt;/code&gt;&lt;/a&gt; and &lt;code&gt;{}&lt;/code&gt;.</source>
          <target state="translated">Вспомогательная структура для безопасной печати путей с &lt;a href=&quot;../macro.format&quot;&gt; &lt;code&gt;format!&lt;/code&gt; &lt;/a&gt;и &lt;code&gt;{}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e8498955fde08da370bacddfd1434e8493282db8" translate="yes" xml:space="preserve">
          <source>Helper trait for &lt;a href=&quot;../primitive.slice#method.concat&quot;&gt;&lt;code&gt;[T]::concat&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bbdd82587ac5843ce3d9f6e79bf40efba742c5a2" translate="yes" xml:space="preserve">
          <source>Helper trait for &lt;a href=&quot;../primitive.slice#method.join&quot;&gt;&lt;code&gt;[T]::join&lt;/code&gt;&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d8870a3f309d445b4b67cf35abad15e6e3e773d8" translate="yes" xml:space="preserve">
          <source>Here &lt;code&gt;T&lt;/code&gt; is a trait object with two explicit lifetime bounds, 'a and 'b.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5c4fbb21f9ed5068758832ea51d122515fab93c7" translate="yes" xml:space="preserve">
          <source>Here &lt;code&gt;X&lt;/code&gt; will have already been specified the discriminant 0 by the time &lt;code&gt;Y&lt;/code&gt; is encountered, so a conflict occurs.</source>
          <target state="translated">Здесь &lt;code&gt;X&lt;/code&gt; уже будет указан дискриминант 0 к моменту встречи &lt;code&gt;Y&lt;/code&gt; , поэтому возникает конфликт.</target>
        </trans-unit>
        <trans-unit id="b3f6e00f3163ec48a9acfd477c8ec87919fc2c8c" translate="yes" xml:space="preserve">
          <source>Here are a couple examples of this error:</source>
          <target state="translated">Приведем пару примеров этой ошибки:</target>
        </trans-unit>
        <trans-unit id="8ff34494ac843686469f6f02e338741820201079" translate="yes" xml:space="preserve">
          <source>Here are examples of the comparison operators being used.</source>
          <target state="translated">Приведем примеры используемых операторов сравнения.</target>
        </trans-unit>
        <trans-unit id="bca374bff5c3dac21037ded7599cd1fe12249f7d" translate="yes" xml:space="preserve">
          <source>Here are examples of these operators being used.</source>
          <target state="translated">Приведем примеры использования этих операторов.</target>
        </trans-unit>
        <trans-unit id="07272e166a1d2e40b130f94ad3a0aa3df774ca3b" translate="yes" xml:space="preserve">
          <source>Here are similar examples but now for LAST.</source>
          <target state="translated">Вот похожие примеры,но теперь для LAST.</target>
        </trans-unit>
        <trans-unit id="0a1abd5c7569db9404cdcd75f1cc6cdc0c6dca93" translate="yes" xml:space="preserve">
          <source>Here are some example of these operators</source>
          <target state="translated">Вот несколько примеров таких операторов</target>
        </trans-unit>
        <trans-unit id="4684b015ded3bc0731a2cef8198e5596403f6b07" translate="yes" xml:space="preserve">
          <source>Here are some examples of elision errors:</source>
          <target state="translated">Приведем несколько примеров ошибок elision:</target>
        </trans-unit>
        <trans-unit id="4bcc69e7a08f9cc053bd0cff82d93712f586660e" translate="yes" xml:space="preserve">
          <source>Here are some examples where expressions don't have extended temporary scopes:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c92962597dc4ffea4ff897a85b4d5e4dec6ca581" translate="yes" xml:space="preserve">
          <source>Here are some examples where expressions have extended temporary scopes:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0931022beea83b3afc095873234631b7243eeca4" translate="yes" xml:space="preserve">
          <source>Here are some examples:</source>
          <target state="translated">Вот несколько примеров:</target>
        </trans-unit>
        <trans-unit id="51de71d79af0f5165810b64b8288dc0e2f418033" translate="yes" xml:space="preserve">
          <source>Here are some examples: a reference to an &lt;code&gt;i32&lt;/code&gt; without a lifetime parameter, a reference to an &lt;code&gt;i32&lt;/code&gt; that has a lifetime parameter named &lt;code&gt;'a&lt;/code&gt;, and a mutable reference to an &lt;code&gt;i32&lt;/code&gt; that also has the lifetime &lt;code&gt;'a&lt;/code&gt;.</source>
          <target state="translated">Вот несколько примеров: ссылка на &lt;code&gt;i32&lt;/code&gt; без параметра времени жизни, ссылка на &lt;code&gt;i32&lt;/code&gt; , у которого есть параметр времени жизни с именем &lt;code&gt;'a&lt;/code&gt; , и изменяемая ссылка на &lt;code&gt;i32&lt;/code&gt; , у которого также есть время жизни &lt;code&gt;'a&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="20d5c7a1de98768721ba1e4861f1afaf92322548" translate="yes" xml:space="preserve">
          <source>Here are some of the things this module contains:</source>
          <target state="translated">Вот некоторые из вещей,которые содержатся в этом модуле:</target>
        </trans-unit>
        <trans-unit id="2a92602de41a70e7040e9f2a4fb9598c573570c2" translate="yes" xml:space="preserve">
          <source>Here are some simple examples of where you'll run into this error:</source>
          <target state="translated">Вот несколько простых примеров,где вы столкнетесь с этой ошибкой:</target>
        </trans-unit>
        <trans-unit id="3a02d5c5d61bf51906767acca68761775d677fe8" translate="yes" xml:space="preserve">
          <source>Here are the abilities Unsafe Rust has in addition to Safe Rust:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5b8f26110eb51a4ab181ea0b693d59c927775bab" translate="yes" xml:space="preserve">
          <source>Here are the topics we&amp;rsquo;ll cover in this chapter:</source>
          <target state="translated">Вот темы, которые мы рассмотрим в этой главе:</target>
        </trans-unit>
        <trans-unit id="bc16616a997e1c54d6f12cfc92a13207a77b9160" translate="yes" xml:space="preserve">
          <source>Here are the two primary ways in which &lt;code&gt;entry&lt;/code&gt; is used. First, a simple example where the logic performed on the values is trivial.</source>
          <target state="translated">Вот два основных способа , в которых &lt;code&gt;entry&lt;/code&gt; используется. Во-первых, простой пример, в котором логика, выполняемая над значениями, тривиальна.</target>
        </trans-unit>
        <trans-unit id="8d3de595e318046b488878fdfd592e24474accd6" translate="yes" xml:space="preserve">
          <source>Here executing &lt;code&gt;x = None&lt;/code&gt; would modify the value being matched and require us to go &quot;back in time&quot; to the &lt;code&gt;None&lt;/code&gt; arm.</source>
          <target state="translated">Здесь выполнение &lt;code&gt;x = None&lt;/code&gt; изменит сопоставляемое значение и потребует от нас вернуться &amp;laquo;назад во времени&amp;raquo; в руку &lt;code&gt;None&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b54fff02e5e3fe8139f3151b798d2ca6781ef79d" translate="yes" xml:space="preserve">
          <source>Here executing &lt;code&gt;x = None&lt;/code&gt; would modify the value being matched and require us to go &quot;back in time&quot; to the &lt;code&gt;None&lt;/code&gt; arm. To fix it, change the value in the match arm:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="87b503ee6f76be5b3f344961161f897b4c2e8a33" translate="yes" xml:space="preserve">
          <source>Here is a basic example:</source>
          <target state="translated">Вот основной пример:</target>
        </trans-unit>
        <trans-unit id="40d986bccf61bb4616c6b2d5e45138cb6f650868" translate="yes" xml:space="preserve">
          <source>Here is a recap of the reasons to choose &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt;, &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt;, or &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt;:</source>
          <target state="translated">Вот краткое изложение причин выбрать &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; , &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; или &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="2fd70c4f72651018616cf4fae80bda013db29aef" translate="yes" xml:space="preserve">
          <source>Here is a variation on the previous example, showing that no further elements are taken from &lt;code&gt;iter&lt;/code&gt; after the first &lt;code&gt;Err&lt;/code&gt;.</source>
          <target state="translated">Вот вариант предыдущего примера, показывающий, что никакие дополнительные элементы не берутся из &lt;code&gt;iter&lt;/code&gt; после первого &lt;code&gt;Err&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f2d33e000bef3fae0bc1e18459c72a6974d4c8ec" translate="yes" xml:space="preserve">
          <source>Here is a variation on the previous example, showing that no further elements are taken from &lt;code&gt;iter&lt;/code&gt; after the first &lt;code&gt;None&lt;/code&gt;.</source>
          <target state="translated">Вот вариант предыдущего примера, показывающий, что никакие дополнительные элементы не берутся из &lt;code&gt;iter&lt;/code&gt; после первого &lt;code&gt;None&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="64fa9f151e952c55124309eb57d3e7e04cdb27ce" translate="yes" xml:space="preserve">
          <source>Here is an example of the same &lt;code&gt;Point&lt;/code&gt; struct implementing the &lt;code&gt;Add&lt;/code&gt; trait using generics.</source>
          <target state="translated">Вот пример той же структуры &lt;code&gt;Point&lt;/code&gt; , реализующей свойство &lt;code&gt;Add&lt;/code&gt; с использованием универсальных шаблонов.</target>
        </trans-unit>
        <trans-unit id="f4eeb15c7a7b93e1eb2dc6a8750be5fd94bbc8b2" translate="yes" xml:space="preserve">
          <source>Here is an example of the same &lt;code&gt;Point&lt;/code&gt; struct implementing the &lt;code&gt;Sub&lt;/code&gt; trait using generics.</source>
          <target state="translated">Вот пример той же структуры &lt;code&gt;Point&lt;/code&gt; , реализующей свойство &lt;code&gt;Sub&lt;/code&gt; с использованием универсальных шаблонов.</target>
        </trans-unit>
        <trans-unit id="e2a455b6868a34c4c660661290fdc27380049549" translate="yes" xml:space="preserve">
          <source>Here is an example response that uses HTTP version 1.1, has a status code of 200, an OK reason phrase, no headers, and no body:</source>
          <target state="translated">Вот пример ответа,который использует HTTP версии 1.1,имеет код статуса 200,фразу &quot;ОК&quot;,без заголовков и без тела:</target>
        </trans-unit>
        <trans-unit id="8d3dccad44a11aba4a0bfd15fb7b2845992244bd" translate="yes" xml:space="preserve">
          <source>Here is an example showcasing how to soundly mutate the contents of an &lt;code&gt;UnsafeCell&amp;lt;_&amp;gt;&lt;/code&gt; despite there being multiple references aliasing the cell:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f7c4ae388ef10758f9c1ee112d05af3dedb5a8c1" translate="yes" xml:space="preserve">
          <source>Here is an example that demonstrates the error:</source>
          <target state="translated">Вот пример,демонстрирующий ошибку:</target>
        </trans-unit>
        <trans-unit id="eb168180e8af601284ef4a6f97cd122e9d48a93f" translate="yes" xml:space="preserve">
          <source>Here is an example using ranges of &lt;code&gt;char&lt;/code&gt; values:</source>
          <target state="translated">Вот пример использования диапазонов значений &lt;code&gt;char&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="2190806deeaf3eb0d2b99ddd8ded1889adb9e2dc" translate="yes" xml:space="preserve">
          <source>Here is an example where the third lifetime elision rule applies:</source>
          <target state="translated">Вот пример,где применяется правило третьей элизии жизни:</target>
        </trans-unit>
        <trans-unit id="8be714949bc61ee0dfb58dd8b6d077f499efa300" translate="yes" xml:space="preserve">
          <source>Here is an example which increments every integer in a vector, checking for overflow:</source>
          <target state="translated">Приведем пример,который увеличивает каждое целое число в векторе,проверяя на переполнение:</target>
        </trans-unit>
        <trans-unit id="b8d2a1ec18a168b45aede187d064b1d87d98387f" translate="yes" xml:space="preserve">
          <source>Here is an example which increments every integer in a vector. We use the checked variant of &lt;code&gt;add&lt;/code&gt; that returns &lt;code&gt;None&lt;/code&gt; when the calculation would result in an overflow.</source>
          <target state="translated">Вот пример, который увеличивает каждое целое число в векторе. Мы используем проверенный вариант &lt;code&gt;add&lt;/code&gt; который возвращает &lt;code&gt;None&lt;/code&gt; , когда вычисление приведет к переполнению.</target>
        </trans-unit>
        <trans-unit id="540ee2aaf7182c6dfc449b18e5accb694e3b0894" translate="yes" xml:space="preserve">
          <source>Here is an example:</source>
          <target state="translated">Вот пример:</target>
        </trans-unit>
        <trans-unit id="669e450458761957293db53fc0e8c919ba0f5a7a" translate="yes" xml:space="preserve">
          <source>Here is an unsafe function named &lt;code&gt;dangerous&lt;/code&gt; that doesn&amp;rsquo;t do anything in its body:</source>
          <target state="translated">Вот небезопасная функция с именем &lt;code&gt;dangerous&lt;/code&gt; , которая ничего не делает в своем теле:</target>
        </trans-unit>
        <trans-unit id="d9606eca0f59289409929077841f751f72b656be" translate="yes" xml:space="preserve">
          <source>Here is another example that tries to subtract one from another list of integers, this time checking for underflow:</source>
          <target state="translated">Вот еще один пример,который пытается вычесть одно из другого списка целых чисел,на этот раз проверяя на недолив:</target>
        </trans-unit>
        <trans-unit id="967e8f702b29651ccfd3eff162bdd1236f185e1b" translate="yes" xml:space="preserve">
          <source>Here is how you would define and use a &lt;code&gt;calculate_length&lt;/code&gt; function that has a reference to an object as a parameter instead of taking ownership of the value:</source>
          <target state="translated">Вот как вы могли бы определить и использовать функцию &lt;code&gt;calculate_length&lt;/code&gt; , которая имеет ссылку на объект в качестве параметра вместо того, чтобы владеть значением:</target>
        </trans-unit>
        <trans-unit id="853cb0e889b6e921d08e41239a16f75171fa3cf1" translate="yes" xml:space="preserve">
          <source>Here is that same example again, with some explanatory comments:</source>
          <target state="translated">И снова этот же пример с некоторыми пояснительными комментариями:</target>
        </trans-unit>
        <trans-unit id="183c940df02f2ac1c7e0b320aa5e4607c7fd14f0" translate="yes" xml:space="preserve">
          <source>Here is the error we get when we compile this code:</source>
          <target state="translated">Вот ошибка,которую мы получаем при компиляции этого кода:</target>
        </trans-unit>
        <trans-unit id="20e589c1d30a718b69866f0e87eb12f8b53bb806" translate="yes" xml:space="preserve">
          <source>Here is the plan to build the web server:</source>
          <target state="translated">Вот план по созданию веб-сервера:</target>
        </trans-unit>
        <trans-unit id="c50f83c6cf619c1c5fb8951e5f26cafe1c807151" translate="yes" xml:space="preserve">
          <source>Here is the previous example again, with the correct order:</source>
          <target state="translated">Вот снова предыдущий пример,с правильным порядком:</target>
        </trans-unit>
        <trans-unit id="c6b6ce6ac56caf7839b74c32ae618de3ed902bea" translate="yes" xml:space="preserve">
          <source>Here is this algorithm described in pseudocode.</source>
          <target state="translated">Вот этот алгоритм,описанный в псевдокоде.</target>
        </trans-unit>
        <trans-unit id="5ade7d43a649a8f35a37c5c4df50d404ac17d264" translate="yes" xml:space="preserve">
          <source>Here the &lt;code&gt;Apple&lt;/code&gt; variant has two fields, and should be matched against like so:</source>
          <target state="translated">Здесь вариант &lt;code&gt;Apple&lt;/code&gt; имеет два поля, и его следует сопоставить следующим образом:</target>
        </trans-unit>
        <trans-unit id="847a36b4e8f5bc18d0a990ee9501fe6c952a3db3" translate="yes" xml:space="preserve">
          <source>Here the type &lt;code&gt;T&lt;/code&gt; cannot have a relaxed bound for multiple default traits (&lt;code&gt;Sized&lt;/code&gt; and &lt;code&gt;Send&lt;/code&gt;). This can be fixed by only using one relaxed bound.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="77492962523ab1872ec0db64f3e31206c8e37741" translate="yes" xml:space="preserve">
          <source>Here we create &lt;code&gt;Status::Value&lt;/code&gt; instances using each &lt;code&gt;u32&lt;/code&gt; value in the range that &lt;code&gt;map&lt;/code&gt; is called on by using the initializer function of &lt;code&gt;Status::Value&lt;/code&gt;. Some people prefer this style, and some people prefer to use closures. They compile to the same code, so use whichever style is clearer to you.</source>
          <target state="translated">Здесь мы создаем экземпляры &lt;code&gt;Status::Value&lt;/code&gt; используя каждое значение &lt;code&gt;u32&lt;/code&gt; в диапазоне, в котором вызывается &lt;code&gt;map&lt;/code&gt; , с помощью функции инициализатора &lt;code&gt;Status::Value&lt;/code&gt; . Кто-то предпочитает этот стиль, а кто-то предпочитает закрытие. Они компилируются в один и тот же код, поэтому используйте тот стиль, который вам понятнее.</target>
        </trans-unit>
        <trans-unit id="ab78b83024b9be055a5f592dcee8323d7eae1a44" translate="yes" xml:space="preserve">
          <source>Here we get a warning about not using the variable &lt;code&gt;y&lt;/code&gt;, but we don&amp;rsquo;t get a warning about not using the variable preceded by the underscore.</source>
          <target state="translated">Здесь мы получаем предупреждение о том, что не используется переменная &lt;code&gt;y&lt;/code&gt; , но мы не получаем предупреждение о том, что не используется переменная, перед которой стоит знак подчеркивания.</target>
        </trans-unit>
        <trans-unit id="c5caa2018a964f99eaa055d4bd09b35c0163bd0e" translate="yes" xml:space="preserve">
          <source>Here we have an addition of &lt;code&gt;d&lt;/code&gt; and &lt;code&gt;n.into()&lt;/code&gt;. Hence, &lt;code&gt;n.into()&lt;/code&gt; can return any type &lt;code&gt;T&lt;/code&gt; where &lt;code&gt;u64: Add&amp;lt;T&amp;gt;&lt;/code&gt;. On the other hand, the &lt;code&gt;into&lt;/code&gt; method can return any type where &lt;code&gt;u32: Into&amp;lt;T&amp;gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e6c5079a1585dd8c6aa581475ab7d948402fef68" translate="yes" xml:space="preserve">
          <source>Here we have an iterator &lt;code&gt;results&lt;/code&gt; over &lt;code&gt;Result&amp;lt;bool, ()&amp;gt;&lt;/code&gt;. Hence, &lt;code&gt;results.collect()&lt;/code&gt; can return any type implementing &lt;code&gt;FromIterator&amp;lt;Result&amp;lt;bool, ()&amp;gt;&amp;gt;&lt;/code&gt;. On the other hand, the &lt;code&gt;?&lt;/code&gt; operator can accept any type implementing &lt;code&gt;Try&lt;/code&gt;.</source>
          <target state="translated">Здесь мы имеем итератор &lt;code&gt;results&lt;/code&gt; над &lt;code&gt;Result&amp;lt;bool, ()&amp;gt;&lt;/code&gt; . Следовательно, &lt;code&gt;results.collect()&lt;/code&gt; может возвращать любой тип, реализующий &lt;code&gt;FromIterator&amp;lt;Result&amp;lt;bool, ()&amp;gt;&amp;gt;&lt;/code&gt; . С другой стороны &lt;code&gt;?&lt;/code&gt; оператор может принимать любой тип, реализующий &lt;code&gt;Try&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="cb5b6fe6a43391cbaff0a797a1749d4999cf682c" translate="yes" xml:space="preserve">
          <source>Here we have declared a string literal, also known as a string slice. String literals have a static lifetime, which means the string &lt;code&gt;hello_world&lt;/code&gt; is guaranteed to be valid for the duration of the entire program. We can explicitly specify &lt;code&gt;hello_world&lt;/code&gt;'s lifetime as well:</source>
          <target state="translated">Здесь мы объявили строковый литерал, также известный как строковый срез. Строковые литералы имеют статическое время жизни, что означает, что строка &lt;code&gt;hello_world&lt;/code&gt; гарантированно будет действительна на протяжении всей программы. Мы также можем явно указать &lt;code&gt;hello_world&lt;/code&gt; жизни hello_world :</target>
        </trans-unit>
        <trans-unit id="4f6025ae753da089e1d8586a3532b960124e6dc6" translate="yes" xml:space="preserve">
          <source>Here we have used the &lt;code&gt;continue&lt;/code&gt; keyword incorrectly. As we have seen above that &lt;code&gt;continue&lt;/code&gt; pointing to a labeled block.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c6a5e69251fb02d97a8da5895df070cb741e7a14" translate="yes" xml:space="preserve">
          <source>Here we see that &lt;code&gt;flatten()&lt;/code&gt; does not perform a &quot;deep&quot; flatten. Instead, only one level of nesting is removed. That is, if you &lt;code&gt;flatten()&lt;/code&gt; a three-dimensional array the result will be two-dimensional and not one-dimensional. To get a one-dimensional structure, you have to &lt;code&gt;flatten()&lt;/code&gt; again.</source>
          <target state="translated">Здесь мы видим, что &lt;code&gt;flatten()&lt;/code&gt; не выполняет &amp;laquo;глубокого&amp;raquo; сглаживания. Вместо этого удаляется только один уровень вложенности. То есть, если вы &lt;code&gt;flatten()&lt;/code&gt; трехмерный массив, результат будет двумерным, а не одномерным. Чтобы получить одномерную структуру, вам нужно снова &lt;code&gt;flatten()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="72ccb25410f6e8d0ac401f0e115875ab4db2e28c" translate="yes" xml:space="preserve">
          <source>Here we tell Rust that when the result is &lt;code&gt;Ok&lt;/code&gt;, return the inner &lt;code&gt;file&lt;/code&gt; value out of the &lt;code&gt;Ok&lt;/code&gt; variant, and we then assign that file handle value to the variable &lt;code&gt;f&lt;/code&gt;. After the &lt;code&gt;match&lt;/code&gt;, we can use the file handle for reading or writing.</source>
          <target state="translated">Здесь мы говорим Rust, что когда результат &lt;code&gt;Ok&lt;/code&gt; , вернуть внутреннее значение &lt;code&gt;file&lt;/code&gt; из варианта &lt;code&gt;Ok&lt;/code&gt; , а затем мы присваиваем это значение дескриптора файла переменной &lt;code&gt;f&lt;/code&gt; . После &lt;code&gt;match&lt;/code&gt; мы можем использовать дескриптор файла для чтения или записи.</target>
        </trans-unit>
        <trans-unit id="80012795e5bb9f7fa353370133e88ca78ecd6ec8" translate="yes" xml:space="preserve">
          <source>Here we&amp;rsquo;re calling the &lt;code&gt;hello&lt;/code&gt; function with the argument &lt;code&gt;&amp;amp;m&lt;/code&gt;, which is a reference to a &lt;code&gt;MyBox&amp;lt;String&amp;gt;&lt;/code&gt; value. Because we implemented the &lt;code&gt;Deref&lt;/code&gt; trait on &lt;code&gt;MyBox&amp;lt;T&amp;gt;&lt;/code&gt; in Listing 15-10, Rust can turn &lt;code&gt;&amp;amp;MyBox&amp;lt;String&amp;gt;&lt;/code&gt; into &lt;code&gt;&amp;amp;String&lt;/code&gt; by calling &lt;code&gt;deref&lt;/code&gt;. The standard library provides an implementation of &lt;code&gt;Deref&lt;/code&gt; on &lt;code&gt;String&lt;/code&gt; that returns a string slice, and this is in the API documentation for &lt;code&gt;Deref&lt;/code&gt;. Rust calls &lt;code&gt;deref&lt;/code&gt; again to turn the &lt;code&gt;&amp;amp;String&lt;/code&gt; into &lt;code&gt;&amp;amp;str&lt;/code&gt;, which matches the &lt;code&gt;hello&lt;/code&gt; function&amp;rsquo;s definition.</source>
          <target state="translated">Здесь мы вызываем функцию &lt;code&gt;hello&lt;/code&gt; с аргументом &lt;code&gt;&amp;amp;m&lt;/code&gt; , который является ссылкой на значение &lt;code&gt;MyBox&amp;lt;String&amp;gt;&lt;/code&gt; . Поскольку в листинге 15-10 мы реализовали &lt;code&gt;Deref&lt;/code&gt; для &lt;code&gt;MyBox&amp;lt;T&amp;gt;&lt;/code&gt; , Rust может превратить &lt;code&gt;&amp;amp;MyBox&amp;lt;String&amp;gt;&lt;/code&gt; в &lt;code&gt;&amp;amp;String&lt;/code&gt; , вызвав &lt;code&gt;deref&lt;/code&gt; . Стандартная библиотека предоставляет реализацию &lt;code&gt;Deref&lt;/code&gt; on &lt;code&gt;String&lt;/code&gt; , которая возвращает фрагмент строки, и это находится в документации API для &lt;code&gt;Deref&lt;/code&gt; . Rust снова вызывает &lt;code&gt;deref&lt;/code&gt; , чтобы превратить &lt;code&gt;&amp;amp;String&lt;/code&gt; в &lt;code&gt;&amp;amp;str&lt;/code&gt; , что соответствует &lt;code&gt;hello&lt;/code&gt; определение функции.</target>
        </trans-unit>
        <trans-unit id="466e3552c39fe3a92c2d4c054173a56d883575cc" translate="yes" xml:space="preserve">
          <source>Here we&amp;rsquo;ve defined a struct and named it &lt;code&gt;Rectangle&lt;/code&gt;. Inside the curly brackets, we defined the fields as &lt;code&gt;width&lt;/code&gt; and &lt;code&gt;height&lt;/code&gt;, both of which have type &lt;code&gt;u32&lt;/code&gt;. Then in &lt;code&gt;main&lt;/code&gt;, we created a particular instance of &lt;code&gt;Rectangle&lt;/code&gt; that has a width of 30 and a height of 50.</source>
          <target state="translated">Здесь мы определили структуру и назвали ее &lt;code&gt;Rectangle&lt;/code&gt; . Внутри фигурных скобок мы определили поля как &lt;code&gt;width&lt;/code&gt; и &lt;code&gt;height&lt;/code&gt; , оба из которых имеют тип &lt;code&gt;u32&lt;/code&gt; . Затем в &lt;code&gt;main&lt;/code&gt; мы создали конкретный экземпляр &lt;code&gt;Rectangle&lt;/code&gt; , который имеет ширину 30 и высоту 50.</target>
        </trans-unit>
        <trans-unit id="817f9efff3a295f34cca74e6a4819cd4626be8b2" translate="yes" xml:space="preserve">
          <source>Here&amp;rsquo;s a simple comment:</source>
          <target state="translated">Вот простой комментарий:</target>
        </trans-unit>
        <trans-unit id="539936e83a01369f912b07f9a46070e22c533c8a" translate="yes" xml:space="preserve">
          <source>Here&amp;rsquo;s a small programming problem: write a function that takes a string and returns the first word it finds in that string. If the function doesn&amp;rsquo;t find a space in the string, the whole string must be one word, so the entire string should be returned.</source>
          <target state="translated">Вот небольшая проблема программирования: напишите функцию, которая принимает строку и возвращает первое слово, которое она находит в этой строке. Если функция не находит пробела в строке, вся строка должна состоять из одного слова, поэтому должна быть возвращена вся строка.</target>
        </trans-unit>
        <trans-unit id="7f3b7e87f399f43770545cc13990ab6cc8dd6c83" translate="yes" xml:space="preserve">
          <source>Here&amp;rsquo;s an example of a constant declaration where the constant&amp;rsquo;s name is &lt;code&gt;MAX_POINTS&lt;/code&gt; and its value is set to 100,000. (Rust&amp;rsquo;s naming convention for constants is to use all uppercase with underscores between words, and underscores can be inserted in numeric literals to improve readability):</source>
          <target state="translated">Вот пример объявления константы, где имя константы &lt;code&gt;MAX_POINTS&lt;/code&gt; , а ее значение установлено на 100000. (Соглашение Rust об именах констант заключается в использовании всего верхнего регистра с подчеркиванием между словами, а подчеркивания можно вставлять в числовые литералы для улучшения читаемости):</target>
        </trans-unit>
        <trans-unit id="0e399b9c3b58dba78ca66c0c45518f8657e4f783" translate="yes" xml:space="preserve">
          <source>Here&amp;rsquo;s an example of how the development and release process works: let&amp;rsquo;s assume that the Rust team is working on the release of Rust 1.5. That release happened in December of 2015, but it will provide us with realistic version numbers. A new feature is added to Rust: a new commit lands on the &lt;code&gt;master&lt;/code&gt; branch. Each night, a new nightly version of Rust is produced. Every day is a release day, and these releases are created by our release infrastructure automatically. So as time passes, our releases look like this, once a night:</source>
          <target state="translated">Вот пример того, как работает процесс разработки и выпуска: предположим, что команда Rust работает над выпуском Rust 1.5. Этот выпуск произошел в декабре 2015 года, но он предоставит нам реалистичные номера версий. В Rust добавлена ​​новая функция: новый коммит попадает в &lt;code&gt;master&lt;/code&gt; ветку. Каждую ночь создается новая ночная версия Rust. Каждый день - это день выпуска, и эти выпуски создаются нашей инфраструктурой выпуска автоматически. По прошествии времени наши релизы выглядят так, раз в ночь:</target>
        </trans-unit>
        <trans-unit id="dd2c057fc04f01fae93788be5795a76d18a55fe9" translate="yes" xml:space="preserve">
          <source>Here&amp;rsquo;s an example of the &lt;code&gt;clone&lt;/code&gt; method in action:</source>
          <target state="translated">Вот пример использования метода &lt;code&gt;clone&lt;/code&gt; в действии:</target>
        </trans-unit>
        <trans-unit id="01162de636320bfb3aac73f8ee64a4ca8f8b3f36" translate="yes" xml:space="preserve">
          <source>Here&amp;rsquo;s an example that shows floating-point numbers in action:</source>
          <target state="translated">Вот пример, показывающий в действии числа с плавающей запятой:</target>
        </trans-unit>
        <trans-unit id="b756692957834549ddc1e80ed843e1c05120a8e7" translate="yes" xml:space="preserve">
          <source>Here&amp;rsquo;s how it works: when you call a method with &lt;code&gt;object.something()&lt;/code&gt;, Rust automatically adds in &lt;code&gt;&amp;amp;&lt;/code&gt;, &lt;code&gt;&amp;amp;mut&lt;/code&gt;, or &lt;code&gt;*&lt;/code&gt; so &lt;code&gt;object&lt;/code&gt; matches the signature of the method. In other words, the following are the same:</source>
          <target state="translated">Вот как это работает: когда вы вызываете метод с помощью &lt;code&gt;object.something()&lt;/code&gt; , Rust автоматически добавляет &lt;code&gt;&amp;amp;&lt;/code&gt; , &lt;code&gt;&amp;amp;mut&lt;/code&gt; или &lt;code&gt;*&lt;/code&gt; , чтобы &lt;code&gt;object&lt;/code&gt; соответствовал сигнатуре метода. Другими словами, это то же самое:</target>
        </trans-unit>
        <trans-unit id="bbfc2aa9173a426f43e60848a0174bac37b702fe" translate="yes" xml:space="preserve">
          <source>Here&amp;rsquo;s the compiler error:</source>
          <target state="translated">Вот ошибка компилятора:</target>
        </trans-unit>
        <trans-unit id="7ba4bf6763c0003ca703ce8f7299229f35cbda9a" translate="yes" xml:space="preserve">
          <source>Here&amp;rsquo;s the error:</source>
          <target state="translated">Вот ошибка:</target>
        </trans-unit>
        <trans-unit id="916eb038e9d9b0f05a6d2dec1a88d2849aef616b" translate="yes" xml:space="preserve">
          <source>Here&amp;rsquo;s the full code for reference:</source>
          <target state="translated">Вот полный код для справки:</target>
        </trans-unit>
        <trans-unit id="815ea8397604a0309cd918e79463e69ce092e31e" translate="yes" xml:space="preserve">
          <source>Here&amp;rsquo;s the resulting compilation error:</source>
          <target state="translated">Вот итоговая ошибка компиляции:</target>
        </trans-unit>
        <trans-unit id="0221cef214e9504c84ca1c9204c7ee34f36785b0" translate="yes" xml:space="preserve">
          <source>Here&amp;rsquo;s the scenario we&amp;rsquo;ll test: we&amp;rsquo;ll create a library that tracks a value against a maximum value and sends messages based on how close to the maximum value the current value is. This library could be used to keep track of a user&amp;rsquo;s quota for the number of API calls they&amp;rsquo;re allowed to make, for example.</source>
          <target state="translated">Вот сценарий, который мы протестируем: мы создадим библиотеку, которая отслеживает значение по отношению к максимальному значению и отправляет сообщения в зависимости от того, насколько близко к максимальному значению текущее значение. Эту библиотеку можно использовать, например, для отслеживания квоты пользователя на количество разрешенных им вызовов API.</target>
        </trans-unit>
        <trans-unit id="3d29162aaec04ffdbb58bf12aa825c48d5666dd6" translate="yes" xml:space="preserve">
          <source>Here&amp;rsquo;s what the countdown would look like using a &lt;code&gt;for&lt;/code&gt; loop and another method we&amp;rsquo;ve not yet talked about, &lt;code&gt;rev&lt;/code&gt;, to reverse the range:</source>
          <target state="translated">Вот как будет выглядеть обратный отсчет с использованием цикла &lt;code&gt;for&lt;/code&gt; и другого метода, о котором мы еще не говорили, &lt;code&gt;rev&lt;/code&gt; , для изменения диапазона:</target>
        </trans-unit>
        <trans-unit id="d3bb7457d5469dff80002a12eb2b6537482105f8" translate="yes" xml:space="preserve">
          <source>Here's an example of a program which exemplifies the three cases outlined above:</source>
          <target state="translated">Приведем пример программы,иллюстрирующий три вышеописанных случая:</target>
        </trans-unit>
        <trans-unit id="8f4d98d4c0a8996c7a0518c8611a7d795ca5c7fb" translate="yes" xml:space="preserve">
          <source>Here's an example of a struct that has this problem:</source>
          <target state="translated">Вот пример структуры,у которой есть эта проблема:</target>
        </trans-unit>
        <trans-unit id="38707ff87f1d5297f1ba77c802780450fd07e571" translate="yes" xml:space="preserve">
          <source>Here's an example of how a collection might make use of &lt;code&gt;needs_drop&lt;/code&gt;:</source>
          <target state="translated">Вот пример того, как коллекция может использовать &lt;code&gt;needs_drop&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="6b4165c575ea75c83f4faaec0830fc7c979ed3b7" translate="yes" xml:space="preserve">
          <source>Here's an example of some in-progress code. We have a trait &lt;code&gt;Foo&lt;/code&gt;:</source>
          <target state="translated">Вот пример незавершенного кода. У нас есть черта &lt;code&gt;Foo&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="f441ef09b0ea3aff9bb06d2bb0621baad2037ee9" translate="yes" xml:space="preserve">
          <source>Here's an example of this error:</source>
          <target state="translated">Вот пример этой ошибки:</target>
        </trans-unit>
        <trans-unit id="c9ee387ebc736d2db87034681c5da1089287c37d" translate="yes" xml:space="preserve">
          <source>Here's an example where you want to sort people by height only, disregarding &lt;code&gt;id&lt;/code&gt; and &lt;code&gt;name&lt;/code&gt;:</source>
          <target state="translated">Вот пример, в котором вы хотите отсортировать людей только по росту, без учета &lt;code&gt;id&lt;/code&gt; и &lt;code&gt;name&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="51e85e4e8113fb3e1f07e1727e78d73f5f0043e6" translate="yes" xml:space="preserve">
          <source>Here's an example:</source>
          <target state="translated">Вот пример:</target>
        </trans-unit>
        <trans-unit id="4cce1c09bcbbaec9487020ee6e7f8025e34bed6b" translate="yes" xml:space="preserve">
          <source>Here's another example but here we do not try and return an expression:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="52eb68597e531c606446cb2bd5c17dccc5e369fd" translate="yes" xml:space="preserve">
          <source>Here's another example that will fail:</source>
          <target state="translated">Вот еще один пример,который провалится:</target>
        </trans-unit>
        <trans-unit id="cb729976f0325910542c6a857a3758115eda6f00" translate="yes" xml:space="preserve">
          <source>Here's one example of this error:</source>
          <target state="translated">Вот один пример этой ошибки:</target>
        </trans-unit>
        <trans-unit id="4919036b58ea25eeee47e5a5bbcefebd8f5446fd" translate="yes" xml:space="preserve">
          <source>Here's the same example, but with &lt;a href=&quot;#method.filter&quot;&gt;&lt;code&gt;filter&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#method.map&quot;&gt;&lt;code&gt;map&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">Вот тот же пример, но с &lt;a href=&quot;#method.filter&quot;&gt; &lt;code&gt;filter&lt;/code&gt; &lt;/a&gt; и &lt;a href=&quot;#method.map&quot;&gt; &lt;code&gt;map&lt;/code&gt; &lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="f461dd8cfe66dce3c71bb1a0db34025a57dc2b4e" translate="yes" xml:space="preserve">
          <source>Here's the same example, but with &lt;a href=&quot;trait.iterator#method.filter&quot;&gt;&lt;code&gt;filter&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;trait.iterator#method.map&quot;&gt;&lt;code&gt;map&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b538038816d2b9d80e3095023dd492b1ae3c134a" translate="yes" xml:space="preserve">
          <source>Here's the same example, but with &lt;a href=&quot;trait.iterator#method.take_while&quot;&gt;&lt;code&gt;take_while&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;trait.iterator#method.map&quot;&gt;&lt;code&gt;map&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3adc3a6ab8335913c0c03d10dd56aa70986ccdbc" translate="yes" xml:space="preserve">
          <source>Here, &lt;code&gt;&amp;amp;mut fancy&lt;/code&gt; is mutable, but &lt;code&gt;&amp;amp;(&amp;amp;mut fancy)&lt;/code&gt; is not. Creating an immutable reference to a value borrows it immutably. There can be multiple references of type &lt;code&gt;&amp;amp;(&amp;amp;mut T)&lt;/code&gt; that point to the same value, so they must be immutable to prevent multiple mutable references to the same value.</source>
          <target state="translated">Здесь &lt;code&gt;&amp;amp;mut fancy&lt;/code&gt; является изменяемым, а &lt;code&gt;&amp;amp;(&amp;amp;mut fancy)&lt;/code&gt; - нет. Создание неизменной ссылки на значение неизменно заимствует ее. Может быть несколько ссылок типа &lt;code&gt;&amp;amp;(&amp;amp;mut T)&lt;/code&gt; которые указывают на одно и то же значение, поэтому они должны быть неизменными, чтобы предотвратить множественные изменяемые ссылки на одно и то же значение.</target>
        </trans-unit>
        <trans-unit id="ae9903eacaebe1bfadd3100f5d35d502f8c50279" translate="yes" xml:space="preserve">
          <source>Here, &lt;code&gt;Grams2&lt;/code&gt; is a not equivalent to &lt;code&gt;Grams&lt;/code&gt; -- the former transparently wraps a (non-transparent) struct containing a single float, while &lt;code&gt;Grams&lt;/code&gt; is a transparent wrapper around a float. This can make a difference for the ABI.</source>
          <target state="translated">Здесь &lt;code&gt;Grams2&lt;/code&gt; не эквивалент &lt;code&gt;Grams&lt;/code&gt; - первый прозрачно обертывает (непрозрачную) структуру, содержащую один float, а &lt;code&gt;Grams&lt;/code&gt; - это прозрачная оболочка вокруг float. Это может иметь значение для ABI.</target>
        </trans-unit>
        <trans-unit id="dc33c2bfb4ee352bfa1ddf50a16705d99896734f" translate="yes" xml:space="preserve">
          <source>Here, &lt;code&gt;demo&lt;/code&gt; tries to borrow the string data held within its argument &lt;code&gt;s&lt;/code&gt; and then return that borrow. However, &lt;code&gt;S&lt;/code&gt; is declared as implementing &lt;code&gt;Drop&lt;/code&gt;.</source>
          <target state="translated">Здесь &lt;code&gt;demo&lt;/code&gt; пытается заимствовать строковые данные, содержащиеся в его аргументе &lt;code&gt;s&lt;/code&gt; , а затем вернуть это заимствование. Однако &lt;code&gt;S&lt;/code&gt; объявлен как реализующий &lt;code&gt;Drop&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d42c53fe9a57832c14dca225308392012e6122d1" translate="yes" xml:space="preserve">
          <source>Here, &lt;code&gt;fancy_num&lt;/code&gt; is borrowed by &lt;code&gt;fancy_ref&lt;/code&gt; and so cannot be moved into the closure &lt;code&gt;x&lt;/code&gt;. There is no way to move a value into a closure while it is borrowed, as that would invalidate the borrow.</source>
          <target state="translated">Здесь &lt;code&gt;fancy_num&lt;/code&gt; заимствовано &lt;code&gt;fancy_ref&lt;/code&gt; , поэтому его нельзя переместить в замыкание &lt;code&gt;x&lt;/code&gt; . Невозможно переместить значение в закрытие, пока оно заимствовано, так как это сделало бы заем недействительным.</target>
        </trans-unit>
        <trans-unit id="125b181d950db988334868421de4a90fab534474" translate="yes" xml:space="preserve">
          <source>Here, &lt;code&gt;first&lt;/code&gt; has type &lt;code&gt;A&lt;/code&gt;, referring to &lt;code&gt;to_vec&lt;/code&gt;'s &lt;code&gt;A&lt;/code&gt; type parameter; and &lt;code&gt;rest&lt;/code&gt; has type &lt;code&gt;Vec&amp;lt;A&amp;gt;&lt;/code&gt;, a vector with element type &lt;code&gt;A&lt;/code&gt;.</source>
          <target state="translated">Здесь &lt;code&gt;first&lt;/code&gt; имеет тип &lt;code&gt;A&lt;/code&gt; , со ссылкой на &lt;code&gt;to_vec&lt;/code&gt; &amp;laquo;ы параметра типа; а &lt;code&gt;rest&lt;/code&gt; имеет тип &lt;code&gt;Vec&amp;lt;A&amp;gt;&lt;/code&gt; , вектор с элементом типа &lt;code&gt;A&lt;/code&gt; . &lt;code&gt;A&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="843f8d3cb9b3a29d042bd0b638e62192879181c8" translate="yes" xml:space="preserve">
          <source>Here, &lt;code&gt;i32&lt;/code&gt; is the type of each element. After the semicolon, the number &lt;code&gt;5&lt;/code&gt; indicates the array contains five elements.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="df5a4c41f4c7ffd30b5c670cb408c350a9013b94" translate="yes" xml:space="preserve">
          <source>Here, &lt;code&gt;i32&lt;/code&gt; is the type of each element. After the semicolon, the number &lt;code&gt;5&lt;/code&gt; indicates the element contains five items.</source>
          <target state="translated">Здесь &lt;code&gt;i32&lt;/code&gt; - это тип каждого элемента. Число &lt;code&gt;5&lt;/code&gt; после точки с запятой указывает на то, что элемент содержит пять элементов.</target>
        </trans-unit>
        <trans-unit id="1068c0619a68aa52935f67e1c63f9f6ef1422570" translate="yes" xml:space="preserve">
          <source>Here, &lt;code&gt;s&lt;/code&gt; will be a &lt;code&gt;&amp;amp;str&lt;/code&gt; that contains the first 4 bytes of the string. Earlier, we mentioned that each of these characters was 2 bytes, which means &lt;code&gt;s&lt;/code&gt; will be &lt;code&gt;Зд&lt;/code&gt;.</source>
          <target state="translated">Здесь &lt;code&gt;s&lt;/code&gt; будет &lt;code&gt;&amp;amp;str&lt;/code&gt; , содержащим первые 4 байта строки. Ранее мы упоминали, что каждый из этих символов был 2 байта, что означает, что &lt;code&gt;s&lt;/code&gt; будет &lt;code&gt;Зд&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="75b866d15247e93817fc99798a57f0ab2950be56" translate="yes" xml:space="preserve">
          <source>Here, &lt;code&gt;score&lt;/code&gt; will have the value that&amp;rsquo;s associated with the Blue team, and the result will be &lt;code&gt;Some(&amp;amp;10)&lt;/code&gt;. The result is wrapped in &lt;code&gt;Some&lt;/code&gt; because &lt;code&gt;get&lt;/code&gt; returns an &lt;code&gt;Option&amp;lt;&amp;amp;V&amp;gt;&lt;/code&gt;; if there&amp;rsquo;s no value for that key in the hash map, &lt;code&gt;get&lt;/code&gt; will return &lt;code&gt;None&lt;/code&gt;. The program will need to handle the &lt;code&gt;Option&lt;/code&gt; in one of the ways that we covered in Chapter 6.</source>
          <target state="translated">Здесь &lt;code&gt;score&lt;/code&gt; будет иметь значение, связанное с синей командой, а результатом будет &lt;code&gt;Some(&amp;amp;10)&lt;/code&gt; . Результат заключен в &lt;code&gt;Some&lt;/code&gt; , потому что &lt;code&gt;get&lt;/code&gt; возвращает &lt;code&gt;Option&amp;lt;&amp;amp;V&amp;gt;&lt;/code&gt; ; если для этого ключа в хэш-карте нет значения, &lt;code&gt;get&lt;/code&gt; вернет &lt;code&gt;None&lt;/code&gt; . Программа должна будет обработать &lt;code&gt;Option&lt;/code&gt; одним из способов, которые мы рассмотрели в главе 6.</target>
        </trans-unit>
        <trans-unit id="8bd05f4a31a90f3b6414a315addec81f40aa24ad" translate="yes" xml:space="preserve">
          <source>Here, &lt;code&gt;x&lt;/code&gt; has the lifetime &lt;code&gt;'b&lt;/code&gt;, which in this case is larger than &lt;code&gt;'a&lt;/code&gt;. This means &lt;code&gt;r&lt;/code&gt; can reference &lt;code&gt;x&lt;/code&gt; because Rust knows that the reference in &lt;code&gt;r&lt;/code&gt; will always be valid while &lt;code&gt;x&lt;/code&gt; is valid.</source>
          <target state="translated">Здесь &lt;code&gt;x&lt;/code&gt; имеет время жизни &lt;code&gt;'b&lt;/code&gt; , которое в данном случае больше &lt;code&gt;'a&lt;/code&gt; . Это означает, что &lt;code&gt;r&lt;/code&gt; может ссылаться на &lt;code&gt;x&lt;/code&gt; , потому что Rust знает, что ссылка в &lt;code&gt;r&lt;/code&gt; всегда действительна, пока действительна &lt;code&gt;x&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e10c369ea788e27a00713fc168a85308c89bf1c9" translate="yes" xml:space="preserve">
          <source>Here, &lt;code&gt;y&lt;/code&gt; is bound by-value in one case and by-reference in the other.</source>
          <target state="translated">Здесь &lt;code&gt;y&lt;/code&gt; привязано по значению в одном случае и по ссылке в другом.</target>
        </trans-unit>
        <trans-unit id="7d5607669abd7c37655a986b9a8d2fca66769741" translate="yes" xml:space="preserve">
          <source>Here, &lt;code&gt;y&lt;/code&gt; is bound to the contents of the &lt;code&gt;Some&lt;/code&gt; and can be used within the block corresponding to the match arm. However, in case &lt;code&gt;x&lt;/code&gt; is &lt;code&gt;None&lt;/code&gt;, we have not specified what &lt;code&gt;y&lt;/code&gt; is, and the block will use a nonexistent variable.</source>
          <target state="translated">Здесь &lt;code&gt;y&lt;/code&gt; привязан к содержимому &lt;code&gt;Some&lt;/code&gt; и может использоваться в блоке, соответствующем руке совпадения. Однако в случае, если &lt;code&gt;x&lt;/code&gt; равен &lt;code&gt;None&lt;/code&gt; , мы не указали, что такое &lt;code&gt;y&lt;/code&gt; , и блок будет использовать несуществующую переменную.</target>
        </trans-unit>
        <trans-unit id="a792c6d2920136f42b2c0328d50b11b4b1f68c36" translate="yes" xml:space="preserve">
          <source>Here, all types implementing &lt;code&gt;Foo&lt;/code&gt; must have a method &lt;code&gt;foo&amp;lt;T&amp;gt;(x: T)&lt;/code&gt; which can take any type &lt;code&gt;T&lt;/code&gt;. However, in the &lt;code&gt;impl&lt;/code&gt; for &lt;code&gt;bool&lt;/code&gt;, we have added an extra bound that &lt;code&gt;T&lt;/code&gt; is &lt;code&gt;Copy&lt;/code&gt;, which isn't compatible with the original trait.</source>
          <target state="translated">Здесь, все типы , реализующие &lt;code&gt;Foo&lt;/code&gt; должны иметь метод &lt;code&gt;foo&amp;lt;T&amp;gt;(x: T)&lt;/code&gt; , которые могут принимать любой тип &lt;code&gt;T&lt;/code&gt; . Однако в &lt;code&gt;impl&lt;/code&gt; для &lt;code&gt;bool&lt;/code&gt; мы добавили дополнительную границу, что &lt;code&gt;T&lt;/code&gt; равно &lt;code&gt;Copy&lt;/code&gt; , что несовместимо с исходной характеристикой.</target>
        </trans-unit>
        <trans-unit id="e86bf62ea38db4534581f774aebf9c330891b88f" translate="yes" xml:space="preserve">
          <source>Here, even though &lt;code&gt;x&lt;/code&gt; is not one of the parameters of &lt;code&gt;equal_to_x&lt;/code&gt;, the &lt;code&gt;equal_to_x&lt;/code&gt; closure is allowed to use the &lt;code&gt;x&lt;/code&gt; variable that&amp;rsquo;s defined in the same scope that &lt;code&gt;equal_to_x&lt;/code&gt; is defined in.</source>
          <target state="translated">Здесь, даже несмотря на то, что &lt;code&gt;x&lt;/code&gt; не является одним из параметров &lt;code&gt;equal_to_x&lt;/code&gt; , замыканию &lt;code&gt;equal_to_x&lt;/code&gt; разрешено использовать переменную &lt;code&gt;x&lt;/code&gt; , которая определена в той же области, в &lt;code&gt;equal_to_x&lt;/code&gt; определено equal_to_x .</target>
        </trans-unit>
        <trans-unit id="3efa2682153806eb1dbead68e3ef30ae590912ca" translate="yes" xml:space="preserve">
          <source>Here, even though we&amp;rsquo;ve specified a lifetime parameter &lt;code&gt;'a&lt;/code&gt; for the return type, this implementation will fail to compile because the return value lifetime is not related to the lifetime of the parameters at all. Here is the error message we get:</source>
          <target state="translated">Здесь, несмотря на то, что мы указали параметр времени жизни &lt;code&gt;'a&lt;/code&gt; для типа возвращаемого значения, эта реализация не будет скомпилирована, потому что время жизни возвращаемого значения вообще не связано со временем жизни параметров. Вот сообщение об ошибке, которое мы получаем:</target>
        </trans-unit>
        <trans-unit id="da2b63d2db9c34aa4fad7b681faf1cae153440c5" translate="yes" xml:space="preserve">
          <source>Here, our response has a status line with status code 404 and the reason phrase &lt;code&gt;NOT FOUND&lt;/code&gt;. We&amp;rsquo;re still not returning headers, and the body of the response will be the HTML in the file &lt;em&gt;404.html&lt;/em&gt;. You&amp;rsquo;ll need to create a &lt;em&gt;404.html&lt;/em&gt; file next to &lt;em&gt;hello.html&lt;/em&gt; for the error page; again feel free to use any HTML you want or use the example HTML in Listing 20-8.</source>
          <target state="translated">Здесь наш ответ содержит строку состояния с кодом состояния 404 и фразой причины &lt;code&gt;NOT FOUND&lt;/code&gt; . Мы по-прежнему не возвращаем заголовки, и основной частью ответа будет HTML- &lt;em&gt;код&lt;/em&gt; из файла &lt;em&gt;404.html&lt;/em&gt; . Вам нужно создать файл &lt;em&gt;404.html&lt;/em&gt; рядом с &lt;em&gt;hello.html&lt;/em&gt; для страницы с ошибкой; снова не стесняйтесь использовать любой HTML, какой хотите, или используйте пример HTML из Листинга 20-8.</target>
        </trans-unit>
        <trans-unit id="a2749e5eb8656bede400f4e0b8d184580a4d9adf" translate="yes" xml:space="preserve">
          <source>Here, the &lt;code&gt;BitAndAssign&lt;/code&gt; trait is implemented for a wrapper around &lt;code&gt;Vec&amp;lt;bool&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">Здесь свойство &lt;code&gt;BitAndAssign&lt;/code&gt; реализовано для оболочки вокруг &lt;code&gt;Vec&amp;lt;bool&amp;gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="73314800534c2c9290a895f1b2e09cd5c74b13fa" translate="yes" xml:space="preserve">
          <source>Here, the &lt;code&gt;nothing_is_true&lt;/code&gt; method takes the ownership of &lt;code&gt;self&lt;/code&gt;. However, &lt;code&gt;self&lt;/code&gt; cannot be moved because &lt;code&gt;.borrow()&lt;/code&gt; only provides an &lt;code&gt;&amp;amp;TheDarkKnight&lt;/code&gt;, which is a borrow of the content owned by the &lt;code&gt;RefCell&lt;/code&gt;. To fix this error, you have three choices:</source>
          <target state="translated">Здесь метод &lt;code&gt;nothing_is_true&lt;/code&gt; становится владельцем &lt;code&gt;self&lt;/code&gt; . Однако &lt;code&gt;self&lt;/code&gt; нельзя переместить, потому что &lt;code&gt;.borrow()&lt;/code&gt; предоставляет только &lt;code&gt;&amp;amp;TheDarkKnight&lt;/code&gt; , который является заимствованием содержимого, принадлежащего &lt;code&gt;RefCell&lt;/code&gt; . Чтобы исправить эту ошибку, у вас есть три варианта:</target>
        </trans-unit>
        <trans-unit id="9ecdeb34514236dc334d979e1fa6dac1a4f47ca1" translate="yes" xml:space="preserve">
          <source>Here, the &lt;code&gt;yield&lt;/code&gt; keyword is used in an &lt;code&gt;async&lt;/code&gt; block, which is not yet supported.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a5f1ad21d4790c6fa776cb2d79a7da13085bbb0b" translate="yes" xml:space="preserve">
          <source>Here, the code counts up through the elements in the array. It starts at index &lt;code&gt;0&lt;/code&gt;, and then loops until it reaches the final index in the array (that is, when &lt;code&gt;index &amp;lt; 5&lt;/code&gt; is no longer true). Running this code will print every element in the array:</source>
          <target state="translated">Здесь код выполняет подсчет элементов массива. Он начинается с индекса &lt;code&gt;0&lt;/code&gt; , а затем повторяется, пока не достигнет последнего индекса в массиве (то есть, когда &lt;code&gt;index &amp;lt; 5&lt;/code&gt; больше не истинно). Запуск этого кода распечатает каждый элемент массива:</target>
        </trans-unit>
        <trans-unit id="f6e9fdb531b1a1a673e70ab403c2068ef72bf3e1" translate="yes" xml:space="preserve">
          <source>Here, the expression &lt;code&gt;&amp;amp;foo()&lt;/code&gt; is borrowing the expression &lt;code&gt;foo()&lt;/code&gt;. As &lt;code&gt;foo()&lt;/code&gt; is a call to a function, and not the name of a variable, this creates a &lt;strong&gt;temporary&lt;/strong&gt; -- that temporary stores the return value from &lt;code&gt;foo()&lt;/code&gt; so that it can be borrowed. You could imagine that &lt;code&gt;let p = bar(&amp;amp;foo());&lt;/code&gt; is equivalent to this:</source>
          <target state="translated">Здесь выражение &lt;code&gt;&amp;amp;foo()&lt;/code&gt; заимствует выражение &lt;code&gt;foo()&lt;/code&gt; . Поскольку &lt;code&gt;foo()&lt;/code&gt; - это вызов функции, а не имя переменной, это создает &lt;strong&gt;временное&lt;/strong&gt; - которое временно сохраняет возвращаемое значение из &lt;code&gt;foo()&lt;/code&gt; чтобы его можно было заимствовать. Вы можете представить, что &lt;code&gt;let p = bar(&amp;amp;foo());&lt;/code&gt; эквивалентно этому:</target>
        </trans-unit>
        <trans-unit id="408c7fbfdfe961fb58eba63dc21b905f34fe6b5c" translate="yes" xml:space="preserve">
          <source>Here, the function &lt;code&gt;eat&lt;/code&gt; takes ownership of &lt;code&gt;x&lt;/code&gt;. However, &lt;code&gt;x&lt;/code&gt; cannot be moved because the borrow to &lt;code&gt;_ref_to_val&lt;/code&gt; needs to last till the function &lt;code&gt;borrow&lt;/code&gt;. To fix that you can do a few different things:</source>
          <target state="translated">Здесь функция &lt;code&gt;eat&lt;/code&gt; становится владельцем &lt;code&gt;x&lt;/code&gt; . Однако &lt;code&gt;x&lt;/code&gt; нельзя переместить, потому что заимствование в &lt;code&gt;_ref_to_val&lt;/code&gt; должно длиться до &lt;code&gt;borrow&lt;/code&gt; функции . Чтобы исправить это, вы можете сделать несколько разных вещей:</target>
        </trans-unit>
        <trans-unit id="34b4fc7688b4cc55dbce35a5cbba7cf5aa481597" translate="yes" xml:space="preserve">
          <source>Here, the function &lt;code&gt;foo&lt;/code&gt; returns a value of type &lt;code&gt;Cell&amp;lt;&amp;amp;'x u32&amp;gt;&lt;/code&gt;, which references the lifetime &lt;code&gt;'x&lt;/code&gt;. However, the return type is declared as &lt;code&gt;impl Trait&amp;lt;'y&amp;gt;&lt;/code&gt; -- this indicates that &lt;code&gt;foo&lt;/code&gt; returns &quot;some type that implements &lt;code&gt;Trait&amp;lt;'y&amp;gt;&lt;/code&gt;&quot;, but it also indicates that the return type &lt;strong&gt;only captures data referencing the lifetime &lt;code&gt;'y&lt;/code&gt;&lt;/strong&gt;. In this case, though, we are referencing data with lifetime &lt;code&gt;'x&lt;/code&gt;, so this function is in error.</source>
          <target state="translated">Здесь функция &lt;code&gt;foo&lt;/code&gt; возвращает значение типа &lt;code&gt;Cell&amp;lt;&amp;amp;'x u32&amp;gt;&lt;/code&gt; , которое ссылается на время жизни &lt;code&gt;'x&lt;/code&gt; . Однако тип возвращаемого значения объявлен как &lt;code&gt;impl Trait&amp;lt;'y&amp;gt;&lt;/code&gt; - это указывает на то, что &lt;code&gt;foo&lt;/code&gt; возвращает &amp;laquo;некоторый тип, реализующий &lt;code&gt;Trait&amp;lt;'y&amp;gt;&lt;/code&gt; &amp;raquo;, но также указывает, что тип возврата &lt;strong&gt;только захватывает данные, относящиеся к времени жизни &lt;code&gt;'y&lt;/code&gt; &lt;/strong&gt; . Однако в этом случае мы ссылаемся на данные с временем жизни &lt;code&gt;'x&lt;/code&gt; , поэтому эта функция ошибочна.</target>
        </trans-unit>
        <trans-unit id="89055a364d466030b4b32dbb99ee9d2965691a35" translate="yes" xml:space="preserve">
          <source>Here, the loop never ends, so &lt;code&gt;!&lt;/code&gt; is the value of the expression. However, this wouldn&amp;rsquo;t be true if we included a &lt;code&gt;break&lt;/code&gt;, because the loop would terminate when it got to the &lt;code&gt;break&lt;/code&gt;.</source>
          <target state="translated">Здесь цикл никогда не заканчивается, так что &lt;code&gt;!&lt;/code&gt; - значение выражения. Однако это было бы неверно, если бы мы включили &lt;code&gt;break&lt;/code&gt; , потому что цикл завершился бы, когда он дойдет до &lt;code&gt;break&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="df47ee6ed5cabbf7215bb10c59a544458415fee2" translate="yes" xml:space="preserve">
          <source>Here, the problem is that a reference type like &lt;code&gt;&amp;amp;'a T&lt;/code&gt; is only valid if all the data in T outlives the lifetime &lt;code&gt;'a&lt;/code&gt;. But this impl as written is applicable to any lifetime &lt;code&gt;'a&lt;/code&gt; and any type &lt;code&gt;T&lt;/code&gt; -- we have no guarantee that &lt;code&gt;T&lt;/code&gt; outlives &lt;code&gt;'a&lt;/code&gt;. To fix this, you can add a where clause like &lt;code&gt;where T: 'a&lt;/code&gt;.</source>
          <target state="translated">Здесь проблема в том, что ссылочный тип, такой как &lt;code&gt;&amp;amp;'a T&lt;/code&gt; действителен только в том случае, если все данные в T переживают время жизни &lt;code&gt;'a&lt;/code&gt; . Но это подразумеваемое, как написано, применимо к любому времени жизни &lt;code&gt;'a&lt;/code&gt; и любому типу &lt;code&gt;T&lt;/code&gt; - у нас нет гарантии, что &lt;code&gt;T&lt;/code&gt; переживет &lt;code&gt;'a&lt;/code&gt; . Чтобы исправить это, вы можете добавить предложение where, например &lt;code&gt;where T: 'a&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d0ef28f4a5284b6e2516b2e042ed2f018d33a029" translate="yes" xml:space="preserve">
          <source>Here, the problem is that the compiler cannot be sure that the &lt;code&gt;'b&lt;/code&gt; lifetime will live longer than &lt;code&gt;'a&lt;/code&gt;, which should be mandatory in order to be sure that &lt;code&gt;Trait::Out&lt;/code&gt; will always have a reference pointing to an existing type. So in this case, we just need to tell the compiler than &lt;code&gt;'b&lt;/code&gt; must outlive &lt;code&gt;'a&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="362d656c8582920eb1fa6e2f837dcd77621e2783" translate="yes" xml:space="preserve">
          <source>Here, the supertrait might have methods as follows:</source>
          <target state="translated">Здесь у супертрэта могут быть следующие методы:</target>
        </trans-unit>
        <trans-unit id="09d377b97ceff52f388bef9d69ecd4e08de82e8e" translate="yes" xml:space="preserve">
          <source>Here, the type of &lt;code&gt;bar&lt;/code&gt; isn't known; it could be a pointer to anything. Instead, specify a type for the pointer (preferably something that makes sense for the thing you're pointing to):</source>
          <target state="translated">Здесь тип &lt;code&gt;bar&lt;/code&gt; неизвестен; это может быть указатель на что угодно. Вместо этого укажите тип указателя (желательно то, что имеет смысл для того, на что вы указываете):</target>
        </trans-unit>
        <trans-unit id="6683d46fded95c67df0b49024b3446d80dd204a6" translate="yes" xml:space="preserve">
          <source>Here, the where clause &lt;code&gt;T: 'a&lt;/code&gt; that appears on the impl is not known to be satisfied on the struct. To make this example compile, you have to add a where-clause like &lt;code&gt;T: 'a&lt;/code&gt; to the struct definition:</source>
          <target state="translated">Здесь предложение where &lt;code&gt;T: 'a&lt;/code&gt; которое появляется в impl, не удовлетворяется в структуре. Чтобы этот пример компилировался, вы должны добавить предложение where, например &lt;code&gt;T: 'a&lt;/code&gt; к определению структуры:</target>
        </trans-unit>
        <trans-unit id="5f5bdb12ef17925552b810b20339fc4188e58923" translate="yes" xml:space="preserve">
          <source>Here, there's no need to allocate more memory inside the loop.</source>
          <target state="translated">Здесь нет необходимости выделять больше памяти внутри цикла.</target>
        </trans-unit>
        <trans-unit id="64f50e4beb0199dca819447bd86bfb2e950cfebb" translate="yes" xml:space="preserve">
          <source>Here, transmute is being used to convert the types of the fn arguments. This pattern is incorrect because, because the type of &lt;code&gt;foo&lt;/code&gt; is a function &lt;strong&gt;item&lt;/strong&gt; (&lt;code&gt;typeof(foo)&lt;/code&gt;), which is zero-sized, and the target type (&lt;code&gt;fn()&lt;/code&gt;) is a function pointer, which is not zero-sized. This pattern should be rewritten. There are a few possible ways to do this:</source>
          <target state="translated">Здесь transmute используется для преобразования типов аргументов fn. Этот шаблон неверен, потому что, поскольку тип &lt;code&gt;foo&lt;/code&gt; является &lt;strong&gt;элементом&lt;/strong&gt; функции ( &lt;code&gt;typeof(foo)&lt;/code&gt; ), который имеет нулевой размер, а целевой тип ( &lt;code&gt;fn()&lt;/code&gt; ) является указателем на функцию, который не имеет нулевого размера. Этот шаблон следует переписать. Есть несколько возможных способов сделать это:</target>
        </trans-unit>
        <trans-unit id="11f7e7a9427d5e270e6bb9180be033e23a1b7abb" translate="yes" xml:space="preserve">
          <source>Here, we are still borrowing &lt;code&gt;foo()&lt;/code&gt;, but as the borrow is assigned directly into a variable, the temporary will not be dropped until the end of the enclosing block. Similar rules apply when temporaries are stored into aggregate structures like a tuple or struct:</source>
          <target state="translated">Здесь мы по-прежнему заимствуем &lt;code&gt;foo()&lt;/code&gt; , но поскольку заимствование присваивается непосредственно переменной, временное значение не будет отброшено до конца включающего блока. Подобные правила применяются, когда временные объекты хранятся в агрегированных структурах, таких как кортеж или структура:</target>
        </trans-unit>
        <trans-unit id="2fe93444419186b520c70f702a92a3495d890ab8" translate="yes" xml:space="preserve">
          <source>Here, we create a new variable &lt;code&gt;case_sensitive&lt;/code&gt;. To set its value, we call the &lt;code&gt;env::var&lt;/code&gt; function and pass it the name of the &lt;code&gt;CASE_INSENSITIVE&lt;/code&gt; environment variable. The &lt;code&gt;env::var&lt;/code&gt; function returns a &lt;code&gt;Result&lt;/code&gt; that will be the successful &lt;code&gt;Ok&lt;/code&gt; variant that contains the value of the environment variable if the environment variable is set. It will return the &lt;code&gt;Err&lt;/code&gt; variant if the environment variable is not set.</source>
          <target state="translated">Здесь мы создаем новую переменную &lt;code&gt;case_sensitive&lt;/code&gt; . Чтобы установить его значение, мы вызываем функцию &lt;code&gt;env::var&lt;/code&gt; и передаем ей имя переменной окружения &lt;code&gt;CASE_INSENSITIVE&lt;/code&gt; . Функция &lt;code&gt;env::var&lt;/code&gt; возвращает &lt;code&gt;Result&lt;/code&gt; который будет успешным вариантом &lt;code&gt;Ok&lt;/code&gt; , который содержит значение переменной среды, если переменная среды установлена. Он вернет вариант &lt;code&gt;Err&lt;/code&gt; , если переменная среды не установлена.</target>
        </trans-unit>
        <trans-unit id="629de8d4fd404424f68755750d18203229995313" translate="yes" xml:space="preserve">
          <source>Here, we declare a trait using the &lt;code&gt;trait&lt;/code&gt; keyword and then the trait&amp;rsquo;s name, which is &lt;code&gt;Summary&lt;/code&gt; in this case. Inside the curly brackets, we declare the method signatures that describe the behaviors of the types that implement this trait, which in this case is &lt;code&gt;fn summarize(&amp;amp;self) -&amp;gt; String&lt;/code&gt;.</source>
          <target state="translated">Здесь мы объявляем признак, используя ключевое слово &lt;code&gt;trait&lt;/code&gt; а затем имя признака, которое в данном случае является &lt;code&gt;Summary&lt;/code&gt; . Внутри фигурных скобок мы объявляем сигнатуры методов, которые описывают поведение типов, реализующих эту черту, в данном случае &lt;code&gt;fn summarize(&amp;amp;self) -&amp;gt; String&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d5d31c7a816695d5663a1af214bdd61a0f312631" translate="yes" xml:space="preserve">
          <source>Here, we first call &lt;code&gt;lock&lt;/code&gt; on the &lt;code&gt;receiver&lt;/code&gt; to acquire the mutex, and then we call &lt;code&gt;unwrap&lt;/code&gt; to panic on any errors. Acquiring a lock might fail if the mutex is in a &lt;em&gt;poisoned&lt;/em&gt; state, which can happen if some other thread panicked while holding the lock rather than releasing the lock. In this situation, calling &lt;code&gt;unwrap&lt;/code&gt; to have this thread panic is the correct action to take. Feel free to change this &lt;code&gt;unwrap&lt;/code&gt; to an &lt;code&gt;expect&lt;/code&gt; with an error message that is meaningful to you.</source>
          <target state="translated">Здесь мы первый вызов &lt;code&gt;lock&lt;/code&gt; на &lt;code&gt;receiver&lt;/code&gt; получить мьютекс, а затем мы называем &lt;code&gt;unwrap&lt;/code&gt; паниковать на любые ошибки. Получение блокировки может завершиться неудачно, если мьютекс находится в &lt;em&gt;отравленном&lt;/em&gt; состоянии, что может произойти, если какой-то другой поток запаниковал, удерживая блокировку, а не снимая блокировку. В этой ситуации вызов &lt;code&gt;unwrap&lt;/code&gt; для паники потока является правильным действием. Не стесняйтесь изменить эту &lt;code&gt;unwrap&lt;/code&gt; на &lt;code&gt;expect&lt;/code&gt; с сообщением об ошибке, которое имеет для вас значение.</target>
        </trans-unit>
        <trans-unit id="90ed3acfd08d6add91c92898299f8f082c9b0a5d" translate="yes" xml:space="preserve">
          <source>Here, we give a description of what the &lt;code&gt;add_one&lt;/code&gt; function does, start a section with the heading &lt;code&gt;Examples&lt;/code&gt;, and then provide code that demonstrates how to use the &lt;code&gt;add_one&lt;/code&gt; function. We can generate the HTML documentation from this documentation comment by running &lt;code&gt;cargo doc&lt;/code&gt;. This command runs the &lt;code&gt;rustdoc&lt;/code&gt; tool distributed with Rust and puts the generated HTML documentation in the &lt;em&gt;target/doc&lt;/em&gt; directory.</source>
          <target state="translated">Здесь мы даем описание того, что &lt;code&gt;add_one&lt;/code&gt; функция add_one , начинаем раздел с заголовка &lt;code&gt;Examples&lt;/code&gt; , а затем предоставляем код, демонстрирующий, как использовать функцию &lt;code&gt;add_one&lt;/code&gt; . Мы можем сгенерировать HTML-документацию из этого комментария к документации, запустив &lt;code&gt;cargo doc&lt;/code&gt; . Эта команда запускает инструмент &lt;code&gt;rustdoc&lt;/code&gt; , поставляемый вместе с Rust, и помещает сгенерированную HTML-документацию в каталог &lt;em&gt;target / doc&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="509084bc1cc2854ecab3677678733d63bccc2260" translate="yes" xml:space="preserve">
          <source>Here, we have a package that only contains &lt;em&gt;src/main.rs&lt;/em&gt;, meaning it only contains a binary crate named &lt;code&gt;my-project&lt;/code&gt;. If a package contains &lt;em&gt;src/main.rs&lt;/em&gt; and &lt;em&gt;src/lib.rs&lt;/em&gt;, it has two crates: a library and a binary, both with the same name as the package. A package can have multiple binary crates by placing files in the &lt;em&gt;src/bin&lt;/em&gt; directory: each file will be a separate binary crate.</source>
          <target state="translated">Здесь у нас есть пакет, который содержит только &lt;em&gt;src / main.rs&lt;/em&gt; , то есть он содержит только двоичный ящик с именем &lt;code&gt;my-project&lt;/code&gt; . Если пакет содержит &lt;em&gt;src / main.rs&lt;/em&gt; и &lt;em&gt;src / lib.rs&lt;/em&gt; , у него есть два ящика: библиотека и двоичный файл, оба с тем же именем, что и пакет. Пакет может иметь несколько бинарных ящиков, помещая файлы в каталог &lt;em&gt;src / bin&lt;/em&gt; : каждый файл будет отдельным двоичным ящиком.</target>
        </trans-unit>
        <trans-unit id="214685b848acbf415bb3dbd9186c1466aa631aa7" translate="yes" xml:space="preserve">
          <source>Here, we have two parameters of type &lt;code&gt;TokenStream&lt;/code&gt;. The first is for the contents of the attribute: the &lt;code&gt;GET, &quot;/&quot;&lt;/code&gt; part. The second is the body of the item the attribute is attached to: in this case, &lt;code&gt;fn index() {}&lt;/code&gt; and the rest of the function&amp;rsquo;s body.</source>
          <target state="translated">Здесь у нас есть два параметра типа &lt;code&gt;TokenStream&lt;/code&gt; . Первый предназначен для содержимого атрибута: &lt;code&gt;GET, &quot;/&quot;&lt;/code&gt; . Второй - это тело элемента, к которому прикреплен атрибут: в данном случае это &lt;code&gt;fn index() {}&lt;/code&gt; и остальная часть тела функции.</target>
        </trans-unit>
        <trans-unit id="9da25d2edfbc8a834054d09a3a531a79272bf467" translate="yes" xml:space="preserve">
          <source>Here, we match a tuple against a pattern. Rust compares the value &lt;code&gt;(1, 2, 3)&lt;/code&gt; to the pattern &lt;code&gt;(x, y, z)&lt;/code&gt; and sees that the value matches the pattern, so Rust binds &lt;code&gt;1&lt;/code&gt; to &lt;code&gt;x&lt;/code&gt;, &lt;code&gt;2&lt;/code&gt; to &lt;code&gt;y&lt;/code&gt;, and &lt;code&gt;3&lt;/code&gt; to &lt;code&gt;z&lt;/code&gt;. You can think of this tuple pattern as nesting three individual variable patterns inside it.</source>
          <target state="translated">Здесь мы сопоставляем кортеж с шаблоном. Rust сравнивает значение &lt;code&gt;(1, 2, 3)&lt;/code&gt; с шаблоном &lt;code&gt;(x, y, z)&lt;/code&gt; и видит, что значение соответствует шаблону, поэтому Rust связывает &lt;code&gt;1&lt;/code&gt; с &lt;code&gt;x&lt;/code&gt; , &lt;code&gt;2&lt;/code&gt; с &lt;code&gt;y&lt;/code&gt; и &lt;code&gt;3&lt;/code&gt; с &lt;code&gt;z&lt;/code&gt; . Вы можете думать об этом шаблоне кортежа как о вложении в него трех отдельных шаблонов переменных.</target>
        </trans-unit>
        <trans-unit id="3807aec2b6a72b122da57a852fc8dc8b9b746c8b" translate="yes" xml:space="preserve">
          <source>Here, we tried to move a field out of a struct of type &lt;code&gt;DropStruct&lt;/code&gt; which implements the &lt;code&gt;Drop&lt;/code&gt; trait. However, a struct cannot be dropped if one or more of its fields have been moved.</source>
          <target state="translated">Здесь мы попытались переместить поле из структуры типа &lt;code&gt;DropStruct&lt;/code&gt; , которая реализует трейт &lt;code&gt;Drop&lt;/code&gt; . Однако структуру нельзя отбросить, если одно или несколько ее полей были перемещены.</target>
        </trans-unit>
        <trans-unit id="182fd49127f0c327471148134a76b7aecc6837c0" translate="yes" xml:space="preserve">
          <source>Here, we try to print &lt;code&gt;val&lt;/code&gt; after we&amp;rsquo;ve sent it down the channel via &lt;code&gt;tx.send&lt;/code&gt;. Allowing this would be a bad idea: once the value has been sent to another thread, that thread could modify or drop it before we try to use the value again. Potentially, the other thread&amp;rsquo;s modifications could cause errors or unexpected results due to inconsistent or nonexistent data. However, Rust gives us an error if we try to compile the code in Listing 16-9:</source>
          <target state="translated">Здесь мы пытаемся вывести &lt;code&gt;val&lt;/code&gt; после того, как отправили его по каналу через &lt;code&gt;tx.send&lt;/code&gt; . Допустить это было бы плохой идеей: после того, как значение было отправлено в другой поток, этот поток может изменить или отбросить его, прежде чем мы попытаемся снова использовать значение. Возможно, модификации другого потока могут вызвать ошибки или неожиданные результаты из-за несовместимых или несуществующих данных. Однако Rust выдает ошибку, если мы попытаемся скомпилировать код из Листинга 16-9:</target>
        </trans-unit>
        <trans-unit id="e6e942400049c5831b3b39dbc83c98fc061c7f27" translate="yes" xml:space="preserve">
          <source>Here, we&amp;rsquo;ll work up to a program that has one thread to generate values and send them down a channel, and another thread that will receive the values and print them out. We&amp;rsquo;ll be sending simple values between threads using a channel to illustrate the feature. Once you&amp;rsquo;re familiar with the technique, you could use channels to implement a chat system or a system where many threads perform parts of a calculation and send the parts to one thread that aggregates the results.</source>
          <target state="translated">Здесь мы перейдем к программе, в которой один поток генерирует значения и отправляет их по каналу, а другой поток будет получать значения и распечатывать их. Мы будем отправлять простые значения между потоками, используя канал, чтобы проиллюстрировать эту функцию. Когда вы познакомитесь с этой техникой, вы можете использовать каналы для реализации системы чата или системы, в которой многие потоки выполняют части вычислений и отправляют их в один поток, который объединяет результаты.</target>
        </trans-unit>
        <trans-unit id="2b30624caca04c6adde1f0c4c5c0896dda9444b6" translate="yes" xml:space="preserve">
          <source>Here, we&amp;rsquo;re attempting to access the 100th element of our vector (which is at index 99 because indexing starts at zero), but it has only 3 elements. In this situation, Rust will panic. Using &lt;code&gt;[]&lt;/code&gt; is supposed to return an element, but if you pass an invalid index, there&amp;rsquo;s no element that Rust could return here that would be correct.</source>
          <target state="translated">Здесь мы пытаемся получить доступ к сотому элементу нашего вектора (который имеет индекс 99, потому что индексирование начинается с нуля), но у него всего 3 элемента. В этой ситуации Rust запаникует. Предполагается, что использование &lt;code&gt;[]&lt;/code&gt; возвращает элемент, но если вы передадите неверный индекс, Rust не сможет вернуть здесь правильный элемент.</target>
        </trans-unit>
        <trans-unit id="5696f367dcde9c29280ed019893b8b93043b4ae3" translate="yes" xml:space="preserve">
          <source>Here, we&amp;rsquo;re calling the &lt;code&gt;do_something&lt;/code&gt; function 100 times, but we never use the variable &lt;code&gt;i&lt;/code&gt; in the body of the &lt;code&gt;for&lt;/code&gt; loop. Rust warns us about that:</source>
          <target state="translated">Здесь мы вызываем функцию &lt;code&gt;do_something&lt;/code&gt; 100 раз, но никогда не используем переменную &lt;code&gt;i&lt;/code&gt; в теле цикла &lt;code&gt;for&lt;/code&gt; . Об этом нас предупреждает Rust:</target>
        </trans-unit>
        <trans-unit id="0738694c0b9e33967ee0ed11850ca18af144e2e8" translate="yes" xml:space="preserve">
          <source>Here, we&amp;rsquo;re creating a new instance of the &lt;code&gt;User&lt;/code&gt; struct, which has a field named &lt;code&gt;email&lt;/code&gt;. We want to set the &lt;code&gt;email&lt;/code&gt; field&amp;rsquo;s value to the value in the &lt;code&gt;email&lt;/code&gt; parameter of the &lt;code&gt;build_user&lt;/code&gt; function. Because the &lt;code&gt;email&lt;/code&gt; field and the &lt;code&gt;email&lt;/code&gt; parameter have the same name, we only need to write &lt;code&gt;email&lt;/code&gt; rather than &lt;code&gt;email: email&lt;/code&gt;.</source>
          <target state="translated">Здесь мы создаем новый экземпляр структуры &lt;code&gt;User&lt;/code&gt; , в котором есть поле с именем &lt;code&gt;email&lt;/code&gt; . Мы хотим установить значение поля &lt;code&gt;email&lt;/code&gt; равным значению в параметре &lt;code&gt;email&lt;/code&gt; функции &lt;code&gt;build_user&lt;/code&gt; . Поскольку &lt;code&gt;email&lt;/code&gt; поле и &lt;code&gt;email&lt;/code&gt; параметр имеют то же имя, нам нужно только написать по &lt;code&gt;email&lt;/code&gt; , а не по &lt;code&gt;email: email&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e2e907cc8b08cfb8b71a6716a55c4e7e4751a1f7" translate="yes" xml:space="preserve">
          <source>Here, we&amp;rsquo;ve annotated the lifetime of &lt;code&gt;r&lt;/code&gt; with &lt;code&gt;'a&lt;/code&gt; and the lifetime of &lt;code&gt;x&lt;/code&gt; with &lt;code&gt;'b&lt;/code&gt;. As you can see, the inner &lt;code&gt;'b&lt;/code&gt; block is much smaller than the outer &lt;code&gt;'a&lt;/code&gt; lifetime block. At compile time, Rust compares the size of the two lifetimes and sees that &lt;code&gt;r&lt;/code&gt; has a lifetime of &lt;code&gt;'a&lt;/code&gt; but that it refers to memory with a lifetime of &lt;code&gt;'b&lt;/code&gt;. The program is rejected because &lt;code&gt;'b&lt;/code&gt; is shorter than &lt;code&gt;'a&lt;/code&gt;: the subject of the reference doesn&amp;rsquo;t live as long as the reference.</source>
          <target state="translated">Здесь мы аннотированные жизни &lt;code&gt;r&lt;/code&gt; с &lt;code&gt;'a&lt;/code&gt; и жизнь &lt;code&gt;x&lt;/code&gt; с &lt;code&gt;'b&lt;/code&gt; . Как вы можете видеть, внутренний &lt;code&gt;'b&lt;/code&gt; блок гораздо меньше , чем внешний &lt;code&gt;'a&lt;/code&gt; течение жизни блока. Во время компиляции Rust сравнивает размер двух времен жизни и видит, что у &lt;code&gt;r&lt;/code&gt; есть время жизни &lt;code&gt;'a&lt;/code&gt; , но что это относится к памяти со временем жизни &lt;code&gt;'b&lt;/code&gt; . Программа отклоняется, потому что &lt;code&gt;'b&lt;/code&gt; короче &lt;code&gt;'a&lt;/code&gt; : предмет ссылки не живет так долго, как ссылка.</target>
        </trans-unit>
        <trans-unit id="1d072835ae81d38506d756c212f27d937b407880" translate="yes" xml:space="preserve">
          <source>Here, we&amp;rsquo;ve defined a method named &lt;code&gt;x&lt;/code&gt; on &lt;code&gt;Point&amp;lt;T&amp;gt;&lt;/code&gt; that returns a reference to the data in the field &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="translated">Здесь мы определили метод с именем &lt;code&gt;x&lt;/code&gt; для &lt;code&gt;Point&amp;lt;T&amp;gt;&lt;/code&gt; который возвращает ссылку на данные в поле &lt;code&gt;x&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b22056ea03c2bfc7c7131245d47003a6d2f7232e" translate="yes" xml:space="preserve">
          <source>Here, we&amp;rsquo;ve defined a struct &lt;code&gt;IpAddr&lt;/code&gt; that has two fields: a &lt;code&gt;kind&lt;/code&gt; field that is of type &lt;code&gt;IpAddrKind&lt;/code&gt; (the enum we defined previously) and an &lt;code&gt;address&lt;/code&gt; field of type &lt;code&gt;String&lt;/code&gt;. We have two instances of this struct. The first, &lt;code&gt;home&lt;/code&gt;, has the value &lt;code&gt;IpAddrKind::V4&lt;/code&gt; as its &lt;code&gt;kind&lt;/code&gt; with associated address data of &lt;code&gt;127.0.0.1&lt;/code&gt;. The second instance, &lt;code&gt;loopback&lt;/code&gt;, has the other variant of &lt;code&gt;IpAddrKind&lt;/code&gt; as its &lt;code&gt;kind&lt;/code&gt; value, &lt;code&gt;V6&lt;/code&gt;, and has address &lt;code&gt;::1&lt;/code&gt; associated with it. We&amp;rsquo;ve used a struct to bundle the &lt;code&gt;kind&lt;/code&gt; and &lt;code&gt;address&lt;/code&gt; values together, so now the variant is associated with the value.</source>
          <target state="translated">Здесь мы определили на структуру &lt;code&gt;IpAddr&lt;/code&gt; , который имеет два поля: &lt;code&gt;kind&lt;/code&gt; поле , которое имеет тип &lt;code&gt;IpAddrKind&lt;/code&gt; (перечисления , которое мы определили ранее) и &lt;code&gt;address&lt;/code&gt; поля типа &lt;code&gt;String&lt;/code&gt; , . У нас есть два экземпляра этой структуры. Первый, &lt;code&gt;home&lt;/code&gt; , имеет значение &lt;code&gt;IpAddrKind::V4&lt;/code&gt; качестве своего &lt;code&gt;kind&lt;/code&gt; со связанными адресными данными &lt;code&gt;127.0.0.1&lt;/code&gt; . Второй экземпляр, &lt;code&gt;loopback&lt;/code&gt; , имеет другой вариант &lt;code&gt;IpAddrKind&lt;/code&gt; в качестве своего &lt;code&gt;kind&lt;/code&gt; значения, &lt;code&gt;V6&lt;/code&gt; , и имеет адрес &lt;code&gt;::1&lt;/code&gt; , связанный с ним. Мы использовали структуру для объединения &lt;code&gt;kind&lt;/code&gt; и &lt;code&gt;address&lt;/code&gt; значения вместе, поэтому теперь вариант связан со значением.</target>
        </trans-unit>
        <trans-unit id="046091a3f10b4e94cc5b7d93ba3518dfd24f4c0f" translate="yes" xml:space="preserve">
          <source>Here, we're saying that the implementation exists on Wrapper only when the wrapped type &lt;code&gt;T&lt;/code&gt; implements &lt;code&gt;Clone&lt;/code&gt;. The &lt;code&gt;where&lt;/code&gt; clause is important because some types will not implement &lt;code&gt;Clone&lt;/code&gt;, and thus will not get this method.</source>
          <target state="translated">Здесь мы говорим, что реализация существует в Wrapper только тогда, когда завернутый тип &lt;code&gt;T&lt;/code&gt; реализует &lt;code&gt;Clone&lt;/code&gt; . Предложение &lt;code&gt;where&lt;/code&gt; важно, потому что некоторые типы не будут реализовывать &lt;code&gt;Clone&lt;/code&gt; и, следовательно, не получат этот метод.</target>
        </trans-unit>
        <trans-unit id="84c52d06e43bddd068876e6b5771442213f18d2a" translate="yes" xml:space="preserve">
          <source>Here, you have used the inappropriate lifetime in the &lt;code&gt;impl Trait&lt;/code&gt;, The &lt;code&gt;impl Trait&lt;/code&gt; can only capture lifetimes bound at the fn or impl level.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2eb18b6c522d039c3c0dcd7089256c0ad6492059" translate="yes" xml:space="preserve">
          <source>Hex</source>
          <target state="translated">Hex</target>
        </trans-unit>
        <trans-unit id="91ed5d7ea6cd895e371f61ed45ccc686b068fc10" translate="yes" xml:space="preserve">
          <source>Hex integer</source>
          <target state="translated">шестнадцатеричное число</target>
        </trans-unit>
        <trans-unit id="df212c2ac8dde3b394685d24542d906c68321356" translate="yes" xml:space="preserve">
          <source>Higher-level synchronization objects</source>
          <target state="translated">Объекты синхронизации более высокого уровня</target>
        </trans-unit>
        <trans-unit id="7319d8cc88397a63e7ae82683fed6023e2ba482c" translate="yes" xml:space="preserve">
          <source>Higher-ranked lifetime bounds</source>
          <target state="translated">Высокопоставленные пожизненные рамки</target>
        </trans-unit>
        <trans-unit id="699f2601254a23df8fa1d5fed485a0da27f47873" translate="yes" xml:space="preserve">
          <source>Higher-ranked lifetimes may also be specified just before the trait, the only difference is the scope of the lifetime parameter, which extends only to the end of the following trait instead of the whole bound. This function is equivalent to the last one.</source>
          <target state="translated">Сроки жизни с более высокими значениями также могут быть указаны непосредственно перед трейтом,единственное отличие-это диапазон параметра жизни,который простирается только до конца следующего трейта,а не до конца всей границы.Эта функция эквивалентна последней.</target>
        </trans-unit>
        <trans-unit id="33df4c2b13cbd6c2495bdbed3c2c401ea9db0b73" translate="yes" xml:space="preserve">
          <source>Higher-ranked trait bounds</source>
          <target state="translated">Пределы высшей категории</target>
        </trans-unit>
        <trans-unit id="02d9e95b138a4fba666ec5899da0c73598dfb07a" translate="yes" xml:space="preserve">
          <source>Hints to compiler that affects how code should be emitted or optimized.</source>
          <target state="translated">Подсказки компилятору,которые влияют на то,как должен быть выпущен или оптимизирован код.</target>
        </trans-unit>
        <trans-unit id="410abe45925442482c6a1847631462e1f9e2aa9a" translate="yes" xml:space="preserve">
          <source>Hints to compiler that affects how code should be emitted or optimized. Hints may be compile time or runtime.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8fa3a5e1e29277a4a2b8f85784650b518cec2c19" translate="yes" xml:space="preserve">
          <source>Hints to the compiler that branch condition is likely to be false. Returns the value passed to it.</source>
          <target state="translated">Подсказки компилятору,что условие ветки,скорее всего,ложное.Возвращает переданное ему значение.</target>
        </trans-unit>
        <trans-unit id="97a557b0407c848d7b5a674a63e1f75673a72a22" translate="yes" xml:space="preserve">
          <source>Hints to the compiler that branch condition is likely to be true. Returns the value passed to it.</source>
          <target state="translated">Подсказки компилятору,что условие ветки,скорее всего,верно.Возвращает переданное ему значение.</target>
        </trans-unit>
        <trans-unit id="80fd9958e4052dae4a04ec25478352520d67b4b8" translate="yes" xml:space="preserve">
          <source>Hooray! Rust 1.5 is done! However, we&amp;rsquo;ve forgotten one thing: because the six weeks have gone by, we also need a new beta of the &lt;em&gt;next&lt;/em&gt; version of Rust, 1.6. So after &lt;code&gt;stable&lt;/code&gt; branches off of &lt;code&gt;beta&lt;/code&gt;, the next version of &lt;code&gt;beta&lt;/code&gt; branches off of &lt;code&gt;nightly&lt;/code&gt; again:</source>
          <target state="translated">Ура! Rust 1.5 готов! Однако мы забыли одну вещь: поскольку прошло шесть недель, нам также нужна новая бета- версия &lt;em&gt;следующей&lt;/em&gt; версии Rust, 1.6. Итак, после &lt;code&gt;stable&lt;/code&gt; перехода от &lt;code&gt;beta&lt;/code&gt; , следующая версия &lt;code&gt;beta&lt;/code&gt; версии снова отключается от &lt;code&gt;nightly&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="a341da978b3cbbea425da4874e79958a3be6b854" translate="yes" xml:space="preserve">
          <source>How Deref Coercion Interacts with Mutability</source>
          <target state="translated">Как Дереф Керсьон взаимодействует с подвижностью.</target>
        </trans-unit>
        <trans-unit id="d344cc5f79b7b6e913f964dbbc4e02bc173d4e92" translate="yes" xml:space="preserve">
          <source>How can I compare two different types?</source>
          <target state="translated">Как я могу сравнить два разных типа?</target>
        </trans-unit>
        <trans-unit id="b9691dd477ecb76d1a6f3d5bbee24f86998a66d9" translate="yes" xml:space="preserve">
          <source>How can I implement &lt;code&gt;Clone&lt;/code&gt;?</source>
          <target state="translated">Как я могу реализовать &lt;code&gt;Clone&lt;/code&gt; ?</target>
        </trans-unit>
        <trans-unit id="a983251965c63473a1e84135e053268152b20692" translate="yes" xml:space="preserve">
          <source>How can I implement &lt;code&gt;Copy&lt;/code&gt;?</source>
          <target state="translated">Как я могу реализовать &lt;code&gt;Copy&lt;/code&gt; ?</target>
        </trans-unit>
        <trans-unit id="90084b4cc636cc9404dd416f2e580ffcac6958d2" translate="yes" xml:space="preserve">
          <source>How can I implement &lt;code&gt;Default&lt;/code&gt;?</source>
          <target state="translated">Как я могу реализовать по &lt;code&gt;Default&lt;/code&gt; ?</target>
        </trans-unit>
        <trans-unit id="d8e36d59adc904734a7c5575517b6fe0eeceec60" translate="yes" xml:space="preserve">
          <source>How can I implement &lt;code&gt;Eq&lt;/code&gt;?</source>
          <target state="translated">Как я могу реализовать &lt;code&gt;Eq&lt;/code&gt; ?</target>
        </trans-unit>
        <trans-unit id="abe50871479611eca84afd8dcffaec7414f4b665" translate="yes" xml:space="preserve">
          <source>How can I implement &lt;code&gt;Ord&lt;/code&gt;?</source>
          <target state="translated">Как я могу реализовать &lt;code&gt;Ord&lt;/code&gt; ?</target>
        </trans-unit>
        <trans-unit id="a86f0c480a53af07a5339e4a6426e55601cb46dc" translate="yes" xml:space="preserve">
          <source>How can I implement &lt;code&gt;PartialEq&lt;/code&gt;?</source>
          <target state="translated">Как я могу реализовать &lt;code&gt;PartialEq&lt;/code&gt; ?</target>
        </trans-unit>
        <trans-unit id="a00e532c303bae49fb14eef74bc7c06484efea04" translate="yes" xml:space="preserve">
          <source>How can I implement &lt;code&gt;PartialOrd&lt;/code&gt;?</source>
          <target state="translated">Как я могу реализовать &lt;code&gt;PartialOrd&lt;/code&gt; ?</target>
        </trans-unit>
        <trans-unit id="8bcb70d690260ea744efd091583de3413f03f2d0" translate="yes" xml:space="preserve">
          <source>How can we define some default values? You can use &lt;code&gt;Default&lt;/code&gt;:</source>
          <target state="translated">Как мы можем определить некоторые значения по умолчанию? Вы можете использовать &lt;code&gt;Default&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="ac97bbda97cfacdb06a7fbecfd828bfbc649940c" translate="yes" xml:space="preserve">
          <source>How do we know &lt;code&gt;File::open&lt;/code&gt; returns a &lt;code&gt;Result&lt;/code&gt;? We could look at the &lt;a href=&quot;../std/index&quot;&gt;standard library API documentation&lt;/a&gt;, or we could ask the compiler! If we give &lt;code&gt;f&lt;/code&gt; a type annotation that we know is &lt;em&gt;not&lt;/em&gt; the return type of the function and then try to compile the code, the compiler will tell us that the types don&amp;rsquo;t match. The error message will then tell us what the type of &lt;code&gt;f&lt;/code&gt;&lt;em&gt;is&lt;/em&gt;. Let&amp;rsquo;s try it! We know that the return type of &lt;code&gt;File::open&lt;/code&gt; isn&amp;rsquo;t of type &lt;code&gt;u32&lt;/code&gt;, so let&amp;rsquo;s change the &lt;code&gt;let f&lt;/code&gt; statement to this:</source>
          <target state="translated">Как мы узнаем, что &lt;code&gt;File::open&lt;/code&gt; возвращает &lt;code&gt;Result&lt;/code&gt; ? Мы могли бы посмотреть &lt;a href=&quot;../std/index&quot;&gt;документацию по API стандартной библиотеки&lt;/a&gt; или спросить у компилятора! Если мы дадим &lt;code&gt;f&lt;/code&gt; аннотацию типа, который, как мы знаем, &lt;em&gt;не&lt;/em&gt; является возвращаемым типом функции, а затем попытаемся скомпилировать код, компилятор сообщит нам, что типы не совпадают. Сообщение об ошибке будет сказать нам , что тип &lt;code&gt;f&lt;/code&gt; &lt;em&gt;является&lt;/em&gt; . Давай попробуем! Мы знаем, что тип возвращаемого значения &lt;code&gt;File::open&lt;/code&gt; не является типом &lt;code&gt;u32&lt;/code&gt; , поэтому давайте изменим оператор &lt;code&gt;let f&lt;/code&gt; на это:</target>
        </trans-unit>
        <trans-unit id="c77df57666e7d061d1c5eeb6d1b1b4663f41398a" translate="yes" xml:space="preserve">
          <source>How to Use This Book</source>
          <target state="translated">Как использовать эту книгу</target>
        </trans-unit>
        <trans-unit id="9264c72068f4a42ab4bf1cb16708fbe650c704ec" translate="yes" xml:space="preserve">
          <source>How to Write Tests</source>
          <target state="translated">Как писать тесты</target>
        </trans-unit>
        <trans-unit id="fc0a5ea77505e42cd0dd485ee502c0a345de0fc4" translate="yes" xml:space="preserve">
          <source>How to Write a Custom &lt;code id=&quot;how-to-write-a-custom-derive-macro&quot;&gt;derive&lt;/code&gt; Macro</source>
          <target state="translated">Как написать собственный &lt;code id=&quot;how-to-write-a-custom-derive-macro&quot;&gt;derive&lt;/code&gt; макрос</target>
        </trans-unit>
        <trans-unit id="ad4a0038f92fbf9afa07ab6d269a6a337b56f053" translate="yes" xml:space="preserve">
          <source>How to combine the sub-expressions' values to obtain the value of the expression</source>
          <target state="translated">Как объединить значения подвыражений для получения значения выражения</target>
        </trans-unit>
        <trans-unit id="9a65f179439d735746c8cd2892082ebe3669f2c2" translate="yes" xml:space="preserve">
          <source>How to create threads to run multiple pieces of code at the same time</source>
          <target state="translated">Как создавать потоки для одновременного выполнения нескольких фрагментов кода</target>
        </trans-unit>
        <trans-unit id="62c635e88978649a0009198984dfd524bc6937d1" translate="yes" xml:space="preserve">
          <source>How to read this documentation</source>
          <target state="translated">Как прочитать эту документацию</target>
        </trans-unit>
        <trans-unit id="2ef34f8c5ce17d8eb29baa4d5f6535815ba4013f" translate="yes" xml:space="preserve">
          <source>How to use these two features to improve the I/O project in Chapter 12</source>
          <target state="translated">Как использовать эти две возможности для улучшения проекта ввода/вывода в Главе 12</target>
        </trans-unit>
        <trans-unit id="f5abcbd8d5f910274d31d405f70ebd71158dda69" translate="yes" xml:space="preserve">
          <source>However be careful: if you try to access an index which isn't in the &lt;code&gt;Vec&lt;/code&gt;, your software will panic! You cannot do this:</source>
          <target state="translated">Однако будьте осторожны: если вы попытаетесь получить доступ к индексу, которого нет в &lt;code&gt;Vec&lt;/code&gt; , ваше программное обеспечение запаникует! Ты не сможешь это сделать:</target>
        </trans-unit>
        <trans-unit id="9a3761438ee9135873d2d6c4d19984a1561781e6" translate="yes" xml:space="preserve">
          <source>However be cautious: this method expects &lt;code&gt;self&lt;/code&gt; to be mutable, which is generally not the case when using a &lt;code&gt;RefCell&lt;/code&gt;. Take a look at the &lt;a href=&quot;#method.borrow_mut&quot;&gt;&lt;code&gt;borrow_mut&lt;/code&gt;&lt;/a&gt; method instead if &lt;code&gt;self&lt;/code&gt; isn't mutable.</source>
          <target state="translated">Однако будьте осторожны: этот метод ожидает, что &lt;code&gt;self&lt;/code&gt; будет изменяемым, что обычно не происходит при использовании &lt;code&gt;RefCell&lt;/code&gt; . Взгляните на метод &lt;a href=&quot;#method.borrow_mut&quot;&gt; &lt;code&gt;borrow_mut&lt;/code&gt; &lt;/a&gt; вместо этого, если &lt;code&gt;self&lt;/code&gt; не изменяемый.</target>
        </trans-unit>
        <trans-unit id="98f7e0f867227ba5004f997a2d43f7281873ef09" translate="yes" xml:space="preserve">
          <source>However it remains possible to implement the others separately for types which do not have a total order. For example, for floating point numbers, &lt;code&gt;NaN &amp;lt; 0 == false&lt;/code&gt; and &lt;code&gt;NaN &amp;gt;= 0 == false&lt;/code&gt; (cf. IEEE 754-2008 section 5.11).</source>
          <target state="translated">Однако по-прежнему можно реализовать остальные по отдельности для типов, которые не имеют полного порядка. Например, для чисел с плавающей запятой &lt;code&gt;NaN &amp;lt; 0 == false&lt;/code&gt; и &lt;code&gt;NaN &amp;gt;= 0 == false&lt;/code&gt; (см. IEEE 754-2008 раздел 5.11).</target>
        </trans-unit>
        <trans-unit id="06b5f47175aeebdf26128c567eba8d39893966c4" translate="yes" xml:space="preserve">
          <source>However programmers will usually prefer to use &lt;a href=&quot;../sync/mpsc/index&quot;&gt;&lt;code&gt;channel&lt;/code&gt;&lt;/a&gt;s, &lt;a href=&quot;../sync/struct.condvar&quot;&gt;&lt;code&gt;Condvar&lt;/code&gt;&lt;/a&gt;s, &lt;a href=&quot;../sync/struct.mutex&quot;&gt;&lt;code&gt;Mutex&lt;/code&gt;&lt;/a&gt;es or &lt;a href=&quot;struct.joinhandle#method.join&quot;&gt;&lt;code&gt;join&lt;/code&gt;&lt;/a&gt; for their synchronization routines, as they avoid thinking about thread scheduling.</source>
          <target state="translated">Однако программисты, как правило , предпочитают использовать &lt;a href=&quot;../sync/mpsc/index&quot;&gt; &lt;code&gt;channel&lt;/code&gt; &lt;/a&gt; s, &lt;a href=&quot;../sync/struct.condvar&quot;&gt; &lt;code&gt;Condvar&lt;/code&gt; &lt;/a&gt; s, &lt;a href=&quot;../sync/struct.mutex&quot;&gt; &lt;code&gt;Mutex&lt;/code&gt; &lt;/a&gt; эс или &lt;a href=&quot;struct.joinhandle#method.join&quot;&gt; &lt;code&gt;join&lt;/code&gt; &lt;/a&gt; к их процедурам синхронизации, так как они не думать о планировании потоков.</target>
        </trans-unit>
        <trans-unit id="99de4c47e704419c664802a54254a42292d00132" translate="yes" xml:space="preserve">
          <source>However remember that a type &lt;em&gt;containing&lt;/em&gt; a &lt;code&gt;MaybeUninit&amp;lt;T&amp;gt;&lt;/code&gt; is not necessarily the same layout; Rust does not in general guarantee that the fields of a &lt;code&gt;Foo&amp;lt;T&amp;gt;&lt;/code&gt; have the same order as a &lt;code&gt;Foo&amp;lt;U&amp;gt;&lt;/code&gt; even if &lt;code&gt;T&lt;/code&gt; and &lt;code&gt;U&lt;/code&gt; have the same size and alignment. Furthermore because any bit value is valid for a &lt;code&gt;MaybeUninit&amp;lt;T&amp;gt;&lt;/code&gt; the compiler can't apply non-zero/niche-filling optimizations, potentially resulting in a larger size:</source>
          <target state="translated">Однако помните , что тип , &lt;em&gt;содержащий&lt;/em&gt; в &lt;code&gt;MaybeUninit&amp;lt;T&amp;gt;&lt;/code&gt; не обязательно такой же расклад; Rust в целом не гарантирует, что поля &lt;code&gt;Foo&amp;lt;T&amp;gt;&lt;/code&gt; имеют тот же порядок, что и &lt;code&gt;Foo&amp;lt;U&amp;gt;&lt;/code&gt; даже если &lt;code&gt;T&lt;/code&gt; и &lt;code&gt;U&lt;/code&gt; имеют одинаковый размер и выравнивание. Кроме того, поскольку для &lt;code&gt;MaybeUninit&amp;lt;T&amp;gt;&lt;/code&gt; допустимо любое битовое значение, компилятор не может применять оптимизацию, отличную от нуля / заполнения ниши, что потенциально может привести к большему размеру:</target>
        </trans-unit>
        <trans-unit id="78a2c549597916b72868a0675d936d5af7b87a27" translate="yes" xml:space="preserve">
          <source>However there is one case where &lt;code&gt;!&lt;/code&gt; syntax can be used before &lt;code&gt;!&lt;/code&gt; is stabilized as a full-fledged type: in the position of a function&amp;rsquo;s return type. Specifically, it is possible implementations for two different function pointer types:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cbb72443619bbca435164ca1a76cab29482ce889" translate="yes" xml:space="preserve">
          <source>However there is one case where &lt;code&gt;!&lt;/code&gt; syntax can be used before &lt;code&gt;!&lt;/code&gt; is stabilized as a full-fleged type: in the position of a function&amp;rsquo;s return type. Specifically, it is possible implementations for two different function pointer types:</source>
          <target state="translated">Однако есть один случай, когда &lt;code&gt;!&lt;/code&gt; синтаксис можно использовать раньше &lt;code&gt;!&lt;/code&gt; стабилизируется как полноценный тип: в позиции возвращаемого типа функции. В частности, возможны реализации для двух разных типов указателей на функции:</target>
        </trans-unit>
        <trans-unit id="d670e0e16c2745ec16c6eaa903327038d8c0e422" translate="yes" xml:space="preserve">
          <source>However there is one caveat: prior to the 2008 version of IEEE-754, how to interpret the NaN signaling bit wasn't actually specified. Most platforms (notably x86 and ARM) picked the interpretation that was ultimately standardized in 2008, but some didn't (notably MIPS). As a result, all signaling NaNs on MIPS are quiet NaNs on x86, and vice-versa.</source>
          <target state="translated">Однако есть одно предостережение:до версии IEEE-754 2008 года,как интерпретировать сигнальный бит NaN на самом деле не уточнялось.Большинство платформ (в частности,x86 и ARM)выбрали интерпретацию,которая в конечном итоге была стандартизирована в 2008 году,но некоторые не выбрали (в частности,MIPS).В результате все сигнальные NaN на MIPS-это тихие NaN на x86 и наоборот.</target>
        </trans-unit>
        <trans-unit id="0351e6925d735478389ca7fa9374b4cd22a63b09" translate="yes" xml:space="preserve">
          <source>However, &lt;a href=&quot;struct.pathbuf#method.push&quot;&gt;&lt;code&gt;push&lt;/code&gt;&lt;/a&gt; is best used for dynamic situations. This is a better way to do this when you know all of the components ahead of time:</source>
          <target state="translated">Однако &lt;a href=&quot;struct.pathbuf#method.push&quot;&gt; &lt;code&gt;push&lt;/code&gt; &lt;/a&gt; лучше всего использовать для динамических ситуаций. Это лучший способ сделать это, если вы заранее знаете все компоненты:</target>
        </trans-unit>
        <trans-unit id="3371f3c5522eaf5798eeaab8876eaa7be0179a80" translate="yes" xml:space="preserve">
          <source>However, &lt;code&gt;dyn Trait&lt;/code&gt; is likely to produce smaller code than &lt;code&gt;impl Trait&lt;/code&gt; / generic parameters as the method won't be duplicated for each concrete type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9e9143c027c4bd572f82aee5fcf41df94d158757" translate="yes" xml:space="preserve">
          <source>However, a better solution would be using fully explicit naming of type and trait:</source>
          <target state="translated">Однако,лучшим решением было бы использование полностью явного именования типа и признака:</target>
        </trans-unit>
        <trans-unit id="ee975de6dd0772652ad342b32f8653a59db9e61f" translate="yes" xml:space="preserve">
          <source>However, a single argument with a trailing comma will still not be treated as a tuple, following the convention of ignoring trailing commas in macro invocations. You can use a 1-tuple directly if you need one:</source>
          <target state="translated">Однако,единственный аргумент с трейлинговой запятой все равно не будет рассматриваться как кортеж,следуя конвенции об игнорировании трейлинговых запятых в макроинвенциях.Вы можете использовать 1-футовую запятую напрямую,если она вам нужна:</target>
        </trans-unit>
        <trans-unit id="b007fe5fc274829b5c0d27c599f3eea8f9ba132a" translate="yes" xml:space="preserve">
          <source>However, associated functions that are part of traits don&amp;rsquo;t have a &lt;code&gt;self&lt;/code&gt; parameter. When two types in the same scope implement that trait, Rust can&amp;rsquo;t figure out which type you mean unless you use &lt;em&gt;fully qualified syntax&lt;/em&gt;. For example, the &lt;code&gt;Animal&lt;/code&gt; trait in Listing 19-19 has the associated function &lt;code&gt;baby_name&lt;/code&gt;, the implementation of &lt;code&gt;Animal&lt;/code&gt; for the struct &lt;code&gt;Dog&lt;/code&gt;, and the associated function &lt;code&gt;baby_name&lt;/code&gt; defined on &lt;code&gt;Dog&lt;/code&gt; directly.</source>
          <target state="translated">Однако связанные функции, являющиеся частью трейтов, не имеют параметра &lt;code&gt;self&lt;/code&gt; . Когда два типа в одной области реализуют эту черту, Rust не может понять, какой тип вы имеете в виду, если вы не используете &lt;em&gt;полностью определенный синтаксис&lt;/em&gt; . Например, с характеристикой &lt;code&gt;Animal&lt;/code&gt; в листинге 19-19 связана функция &lt;code&gt;baby_name&lt;/code&gt; , реализация &lt;code&gt;Animal&lt;/code&gt; для структуры &lt;code&gt;Dog&lt;/code&gt; и связанная функция &lt;code&gt;baby_name&lt;/code&gt; , определенная непосредственно на &lt;code&gt;Dog&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a8a92146e9c361c007de32df04115100977209af" translate="yes" xml:space="preserve">
          <source>However, be careful when two types have a common associated type:</source>
          <target state="translated">Однако будьте осторожны,когда два типа имеют общий ассоциированный тип:</target>
        </trans-unit>
        <trans-unit id="7c05de5702d4d9921eaeead5a04ffacda460142d" translate="yes" xml:space="preserve">
          <source>However, because &lt;code&gt;a&lt;/code&gt; is still referencing the &lt;code&gt;Rc&amp;lt;List&amp;gt;&lt;/code&gt; that was in &lt;code&gt;b&lt;/code&gt;, that &lt;code&gt;Rc&amp;lt;List&amp;gt;&lt;/code&gt; has a count of 1 rather than 0, so the memory the &lt;code&gt;Rc&amp;lt;List&amp;gt;&lt;/code&gt; has on the heap won&amp;rsquo;t be dropped. The memory will just sit there with a count of 1, forever. To visualize this reference cycle, we&amp;rsquo;ve created a diagram in Figure 15-4.</source>
          <target state="translated">Однако, поскольку &lt;code&gt;a&lt;/code&gt; все еще ссылается на &lt;code&gt;Rc&amp;lt;List&amp;gt;&lt;/code&gt; который был в &lt;code&gt;b&lt;/code&gt; , этот &lt;code&gt;Rc&amp;lt;List&amp;gt;&lt;/code&gt; имеет счетчик 1, а не 0, поэтому память &lt;code&gt;Rc&amp;lt;List&amp;gt;&lt;/code&gt; в куче не будет удалена. Память будет стоять со счетом 1 навсегда. Чтобы визуализировать этот эталонный цикл, мы создали диаграмму на рис. 15-4.</target>
        </trans-unit>
        <trans-unit id="0161534a8ade8082b05e52cb4b19d957b4c686da" translate="yes" xml:space="preserve">
          <source>However, being able to represent this wide range of numbers comes at the cost of precision: floats can only represent some of the real numbers and calculation with floats round to a nearby representable number. For example, &lt;code&gt;5.0&lt;/code&gt; and &lt;code&gt;1.0&lt;/code&gt; can be exactly represented as &lt;code&gt;f32&lt;/code&gt;, but &lt;code&gt;1.0 / 5.0&lt;/code&gt; results in &lt;code&gt;0.20000000298023223876953125&lt;/code&gt; since &lt;code&gt;0.2&lt;/code&gt; cannot be exactly represented as &lt;code&gt;f32&lt;/code&gt;. Note however, that printing floats with &lt;code&gt;println&lt;/code&gt; and friends will often discard insignificant digits: &lt;code&gt;println!(&quot;{}&quot;, 1.0f32 / 5.0f32)&lt;/code&gt; will print &lt;code&gt;0.2&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bc86d5089c69372edd80eafac68df3ec0dbaefb7" translate="yes" xml:space="preserve">
          <source>However, being able to represent this wide range of numbers comes at the cost of precision: floats can only represent some of the real numbers and calculation with floats round to a nearby representable number. For example, &lt;code&gt;5.0&lt;/code&gt; and &lt;code&gt;1.0&lt;/code&gt; can be exactly represented as &lt;code&gt;f32&lt;/code&gt;, but &lt;code&gt;1.0 / 5.0&lt;/code&gt; results in &lt;code&gt;0.20000000298023223876953125&lt;/code&gt; since &lt;code&gt;0.2&lt;/code&gt; cannot be exactly represented as &lt;code&gt;f32&lt;/code&gt;. Note, however, that printing floats with &lt;code&gt;println&lt;/code&gt; and friends will often discard insignificant digits: &lt;code&gt;println!(&quot;{}&quot;, 1.0f32 / 5.0f32)&lt;/code&gt; will print &lt;code&gt;0.2&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a75f8c79454007f698be22ee125cb88b1db6c03c" translate="yes" xml:space="preserve">
          <source>However, for clients that do not wish to track the capacity returned by &lt;code&gt;alloc_excess&lt;/code&gt; locally, this method is likely to produce useful results.</source>
          <target state="translated">Однако для клиентов, которые не хотят отслеживать емкость, возвращаемую &lt;code&gt;alloc_excess&lt;/code&gt; локально, этот метод, вероятно, даст полезные результаты.</target>
        </trans-unit>
        <trans-unit id="c6f1d589fbc14406ddd7e944ec737df44d57ed77" translate="yes" xml:space="preserve">
          <source>However, having lots of error checks in all of your functions would be verbose and annoying. Fortunately, you can use Rust&amp;rsquo;s type system (and thus the type checking the compiler does) to do many of the checks for you. If your function has a particular type as a parameter, you can proceed with your code&amp;rsquo;s logic knowing that the compiler has already ensured you have a valid value. For example, if you have a type rather than an &lt;code&gt;Option&lt;/code&gt;, your program expects to have &lt;em&gt;something&lt;/em&gt; rather than &lt;em&gt;nothing&lt;/em&gt;. Your code then doesn&amp;rsquo;t have to handle two cases for the &lt;code&gt;Some&lt;/code&gt; and &lt;code&gt;None&lt;/code&gt; variants: it will only have one case for definitely having a value. Code trying to pass nothing to your function won&amp;rsquo;t even compile, so your function doesn&amp;rsquo;t have to check for that case at runtime. Another example is using an unsigned integer type such as &lt;code&gt;u32&lt;/code&gt;, which ensures the parameter is never negative.</source>
          <target state="translated">Однако наличие множества проверок ошибок во всех ваших функциях было бы многословным и раздражающим. К счастью, вы можете использовать систему типов Rust (и, следовательно, проверку типов, которую выполняет компилятор) для выполнения многих проверок за вас. Если ваша функция имеет в качестве параметра определенный тип, вы можете продолжить работу с логикой кода, зная, что компилятор уже обеспечил вам допустимое значение. Например, если у вас есть тип, а не &lt;code&gt;Option&lt;/code&gt; , ваша программа ожидает получить &lt;em&gt;что-то,&lt;/em&gt; а не &lt;em&gt;ничего&lt;/em&gt; . Тогда ваш код не должен обрабатывать два случая для &lt;code&gt;Some&lt;/code&gt; и &lt;code&gt;None&lt;/code&gt; варианты: у него будет только один случай, чтобы определенно иметь ценность. Код, пытающийся ничего не передать вашей функции, даже не компилируется, поэтому вашей функции не нужно проверять этот случай во время выполнения. Другой пример - использование целочисленного типа без знака, такого как &lt;code&gt;u32&lt;/code&gt; , который гарантирует, что параметр никогда не будет отрицательным.</target>
        </trans-unit>
        <trans-unit id="c47ddb353392208fbaf5c29553d62da521ea2e56" translate="yes" xml:space="preserve">
          <source>However, if a type implements &lt;code&gt;Copy&lt;/code&gt;, it instead has 'copy semantics':</source>
          <target state="translated">Однако, если тип реализует &lt;code&gt;Copy&lt;/code&gt; , вместо этого он имеет &amp;laquo;семантику копирования&amp;raquo;:</target>
        </trans-unit>
        <trans-unit id="601ae6aeca914c05ec96fb8df8c9c4178c5a0a78" translate="yes" xml:space="preserve">
          <source>However, if it derives from &lt;code&gt;Super&amp;lt;Self&amp;gt;&lt;/code&gt;, even though &lt;code&gt;Super&lt;/code&gt; is object safe, the method &lt;code&gt;get_a()&lt;/code&gt; would return an object of unknown type when called on the function. &lt;code&gt;Self&lt;/code&gt; type parameters let us make object safe traits no longer safe, so they are forbidden when specifying supertraits.</source>
          <target state="translated">Однако, если он является производным от &lt;code&gt;Super&amp;lt;Self&amp;gt;&lt;/code&gt; , даже если &lt;code&gt;Super&lt;/code&gt; является объектно-безопасным, метод &lt;code&gt;get_a()&lt;/code&gt; вернет объект неизвестного типа при вызове функции. &lt;code&gt;Self&lt;/code&gt; параметры типа давайте не будем делать объектные безопасные черты уже не безопасно, поэтому они запрещены при указании supertraits.</target>
        </trans-unit>
        <trans-unit id="7fad1dff57715fb5c533987e92e806ddbde896cc" translate="yes" xml:space="preserve">
          <source>However, if you still wish to use these types, you can achieve this by an unsafe wrapper:</source>
          <target state="translated">Однако,если вы все же хотите использовать эти типы,вы можете достичь этого с помощью небезопасной обертки:</target>
        </trans-unit>
        <trans-unit id="2f1b0df6bf40f54deee89e8870694822d74c8932" translate="yes" xml:space="preserve">
          <source>However, if you wanted to access a field of a struct check that the field name is spelled correctly. Example:</source>
          <target state="translated">Однако,если вы хотите получить доступ к полю структуры,проверьте правильность написания имени поля.Пример:</target>
        </trans-unit>
        <trans-unit id="692ecbc0723f2163cd918161474068cb36f04e45" translate="yes" xml:space="preserve">
          <source>However, one long line is difficult to read, so it&amp;rsquo;s best to divide it. Now let&amp;rsquo;s discuss what this line does.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="26830adb8373fabf090d221485ccd723186cf9b8" translate="yes" xml:space="preserve">
          <source>However, one long line is difficult to read, so it&amp;rsquo;s best to divide it: two lines for two method calls. Now let&amp;rsquo;s discuss what this line does.</source>
          <target state="translated">Однако одну длинную строку трудно прочитать, поэтому лучше разделить ее: две строки для двух вызовов методов. Теперь давайте обсудим, что делает эта строка.</target>
        </trans-unit>
        <trans-unit id="dd472996f3f286211f48a487c70490ad383642d1" translate="yes" xml:space="preserve">
          <source>However, our intention in this chapter is to help you learn, not to take the easy route. Because Rust is a systems programming language, we can choose the level of abstraction we want to work with and can go to a lower level than is possible or practical in other languages. We&amp;rsquo;ll write the basic HTTP server and thread pool manually so you can learn the general ideas and techniques behind the crates you might use in the future.</source>
          <target state="translated">Однако наша цель в этой главе - помочь вам учиться, а не идти легким путем. Поскольку Rust - это язык системного программирования, мы можем выбрать уровень абстракции, с которым хотим работать, и можем перейти на более низкий уровень, чем это возможно или практично в других языках. Мы напишем базовый HTTP-сервер и пул потоков вручную, чтобы вы могли изучить общие идеи и методы, лежащие в основе ящиков, которые вы могли бы использовать в будущем.</target>
        </trans-unit>
        <trans-unit id="a3c7769e69d54d27cbd8d165bbdf117ddc427c2b" translate="yes" xml:space="preserve">
          <source>However, please keep in mind that the first solution should be preferred.</source>
          <target state="translated">Однако,пожалуйста,имейте в виду,что первое решение должно быть предпочтительным.</target>
        </trans-unit>
        <trans-unit id="9e7ca595910d369d04059d59dd0f26ad24257742" translate="yes" xml:space="preserve">
          <source>However, some higher-level allocation methods (&lt;code&gt;alloc_one&lt;/code&gt;, &lt;code&gt;alloc_array&lt;/code&gt;) are well-defined on zero-sized types and can optionally support them: it is left up to the implementor whether to return &lt;code&gt;Err&lt;/code&gt;, or to return &lt;code&gt;Ok&lt;/code&gt; with some pointer.</source>
          <target state="translated">Однако некоторые высокоуровневые методы распределения ( &lt;code&gt;alloc_one&lt;/code&gt; , &lt;code&gt;alloc_array&lt;/code&gt; ) четко определены для типов нулевого размера и могут опционально их поддерживать: разработчику остается решать, вернуть ли &lt;code&gt;Err&lt;/code&gt; или вернуть &lt;code&gt;Ok&lt;/code&gt; с некоторым указателем.</target>
        </trans-unit>
        <trans-unit id="bb26cd270c81cacb615098ed7b7796b24ddb7cc6" translate="yes" xml:space="preserve">
          <source>However, sometimes we want our library user to be able to extend the set of types that are valid in a particular situation. To show how we might achieve this, we&amp;rsquo;ll create an example graphical user interface (GUI) tool that iterates through a list of items, calling a &lt;code&gt;draw&lt;/code&gt; method on each one to draw it to the screen&amp;mdash;a common technique for GUI tools. We&amp;rsquo;ll create a library crate called &lt;code&gt;gui&lt;/code&gt; that contains the structure of a GUI library. This crate might include some types for people to use, such as &lt;code&gt;Button&lt;/code&gt; or &lt;code&gt;TextField&lt;/code&gt;. In addition, &lt;code&gt;gui&lt;/code&gt; users will want to create their own types that can be drawn: for instance, one programmer might add an &lt;code&gt;Image&lt;/code&gt; and another might add a &lt;code&gt;SelectBox&lt;/code&gt;.</source>
          <target state="translated">Однако иногда мы хотим, чтобы пользователь нашей библиотеки имел возможность расширить набор типов, применимых в конкретной ситуации. Чтобы показать, как мы можем этого добиться, мы создадим пример инструмента с графическим интерфейсом пользователя (GUI), который выполняет итерацию по списку элементов, вызывая метод &lt;code&gt;draw&lt;/code&gt; для каждого из них, чтобы вывести его на экран - распространенный метод для инструментов GUI. Мы создадим ящик библиотеки под названием &lt;code&gt;gui&lt;/code&gt; , который будет содержать структуру библиотеки GUI. Этот ящик может включать в себя некоторые типы для использования людьми, такие как &lt;code&gt;Button&lt;/code&gt; или &lt;code&gt;TextField&lt;/code&gt; . Кроме того, &lt;code&gt;gui&lt;/code&gt; пользователи хотят создавать свои собственные типы , которые могут быть сделаны: например, один программист может добавить &lt;code&gt;Image&lt;/code&gt; и другие могут добавить &lt;code&gt;SelectBox&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="090c640dded64692c1c679520894484188072e98" translate="yes" xml:space="preserve">
          <source>However, structural pinning comes with a few extra requirements:</source>
          <target state="translated">Однако,структурное штифтовое соединение поставляется с несколькими дополнительными требованиями:</target>
        </trans-unit>
        <trans-unit id="6446591953c7036afa44804569e6b2a76fecb194" translate="yes" xml:space="preserve">
          <source>However, suffixes on literal tokens parsed as Rust code are restricted.</source>
          <target state="translated">Однако,суффиксы на буквальных маркерах,разобранных как код Rust,ограничены.</target>
        </trans-unit>
        <trans-unit id="fd97947a4cfc6a63fedbe7991de9dd273fb032fc" translate="yes" xml:space="preserve">
          <source>However, suffixes on literal tokens parsed as Rust code are restricted. Any suffixes are rejected on non-numeric literal tokens, and numeric literal tokens are accepted only with suffixes from the list below.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e53d985c5c53455719af4369d5bd75e2e43f4f1b" translate="yes" xml:space="preserve">
          <source>However, the &lt;code&gt;match&lt;/code&gt; expression can be a bit wordy in a situation in which we care about only &lt;em&gt;one&lt;/em&gt; of the cases. For this situation, Rust provides &lt;code&gt;if let&lt;/code&gt;.</source>
          <target state="translated">Тем не менее, &lt;code&gt;match&lt;/code&gt; выражение может быть немного многословным в ситуации , в которой мы заботимся о только &lt;em&gt;один&lt;/em&gt; из случаев. В этой ситуации Rust предоставляет, &lt;code&gt;if let&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a11b9e584ed4976bfbc4897d2baa5077bb7ad3ff" translate="yes" xml:space="preserve">
          <source>However, the code in Listing 2-4 won&amp;rsquo;t compile yet. Let&amp;rsquo;s try it:</source>
          <target state="translated">Однако код в листинге 2-4 еще не компилируется. Давай попробуем:</target>
        </trans-unit>
        <trans-unit id="5ff36d97f387c34f0e3f89e3b84848ea32f28366" translate="yes" xml:space="preserve">
          <source>However, the concept that null is trying to express is still a useful one: a null is a value that is currently invalid or absent for some reason.</source>
          <target state="translated">Однако понятие,которое пытается выразить ноль,все же является полезным:ноль-это значение,которое в настоящее время недействительно или отсутствует по каким-либо причинам.</target>
        </trans-unit>
        <trans-unit id="cda87a9e6a4c7e24911050c4147eddad9fb1a4fd" translate="yes" xml:space="preserve">
          <source>However, the pointer may not actually point to allocated memory. In particular, if you construct a &lt;code&gt;Vec&lt;/code&gt; with capacity 0 via &lt;a href=&quot;struct.vec#method.new&quot;&gt;&lt;code&gt;Vec::new&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../macro.vec&quot;&gt;&lt;code&gt;vec![]&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;struct.vec#method.with_capacity&quot;&gt;&lt;code&gt;Vec::with_capacity(0)&lt;/code&gt;&lt;/a&gt;, or by calling &lt;a href=&quot;struct.vec#method.shrink_to_fit&quot;&gt;&lt;code&gt;shrink_to_fit&lt;/code&gt;&lt;/a&gt; on an empty Vec, it will not allocate memory. Similarly, if you store zero-sized types inside a &lt;code&gt;Vec&lt;/code&gt;, it will not allocate space for them. &lt;em&gt;Note that in this case the &lt;code&gt;Vec&lt;/code&gt; may not report a &lt;a href=&quot;struct.vec#method.capacity&quot;&gt;&lt;code&gt;capacity&lt;/code&gt;&lt;/a&gt; of 0&lt;/em&gt;. &lt;code&gt;Vec&lt;/code&gt; will allocate if and only if &lt;a href=&quot;../mem/fn.size_of&quot;&gt;&lt;code&gt;mem::size_of::&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt;&lt;code&gt;() * capacity() &amp;gt; 0&lt;/code&gt;. In general, &lt;code&gt;Vec&lt;/code&gt;'s allocation details are very subtle &amp;mdash; if you intend to allocate memory using a &lt;code&gt;Vec&lt;/code&gt; and use it for something else (either to pass to unsafe code, or to build your own memory-backed collection), be sure to deallocate this memory by using &lt;code&gt;from_raw_parts&lt;/code&gt; to recover the &lt;code&gt;Vec&lt;/code&gt; and then dropping it.</source>
          <target state="translated">Однако указатель может не указывать на выделенную память. В частности, если вы создаете &lt;code&gt;Vec&lt;/code&gt; с емкостью 0 через &lt;a href=&quot;struct.vec#method.new&quot;&gt; &lt;code&gt;Vec::new&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;../macro.vec&quot;&gt; &lt;code&gt;vec![]&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;struct.vec#method.with_capacity&quot;&gt; &lt;code&gt;Vec::with_capacity(0)&lt;/code&gt; &lt;/a&gt; или путем вызова &lt;a href=&quot;struct.vec#method.shrink_to_fit&quot;&gt; &lt;code&gt;shrink_to_fit&lt;/code&gt; &lt;/a&gt; для пустого Vec, он не будет выделять память. Точно так же, если вы храните типы нулевого размера внутри &lt;code&gt;Vec&lt;/code&gt; , он не выделяет для них место. &lt;em&gt;Обратите внимание, что в этом случае &lt;code&gt;Vec&lt;/code&gt; может не сообщать о &lt;a href=&quot;struct.vec#method.capacity&quot;&gt; &lt;code&gt;capacity&lt;/code&gt; &lt;/a&gt; 0&lt;/em&gt; . &lt;code&gt;Vec&lt;/code&gt; будет выделять &lt;a href=&quot;../mem/fn.size_of&quot;&gt; &lt;code&gt;mem::size_of::&amp;lt;T&amp;gt;&lt;/code&gt; &lt;/a&gt; тогда и только тогда, когда mem :: size_of :: &amp;lt;T&amp;gt; &lt;code&gt;() * capacity() &amp;gt; 0&lt;/code&gt; . В общем, &lt;code&gt;Vec&lt;/code&gt; Детали распределения очень тонкие - если вы намереваетесь выделить память с помощью &lt;code&gt;Vec&lt;/code&gt; и использовать ее для чего-то еще (либо для перехода к небезопасному коду, либо для создания собственной коллекции с поддержкой памяти), обязательно освободите эту память, используя &lt;code&gt;from_raw_parts&lt;/code&gt; , чтобы восстановить &lt;code&gt;Vec&lt;/code&gt; , а затем сбросить его.</target>
        </trans-unit>
        <trans-unit id="71a07da2ac46a34c0d6bf7a73675b61fc8ad742b" translate="yes" xml:space="preserve">
          <source>However, the reverse is not true: not all valid &lt;a href=&quot;../primitive.u32&quot;&gt;&lt;code&gt;u32&lt;/code&gt;&lt;/a&gt;s are valid &lt;a href=&quot;../primitive.char&quot;&gt;&lt;code&gt;char&lt;/code&gt;&lt;/a&gt;s. &lt;code&gt;from_u32()&lt;/code&gt; will return &lt;code&gt;None&lt;/code&gt; if the input is not a valid value for a &lt;a href=&quot;../primitive.char&quot;&gt;&lt;code&gt;char&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Однако обратное неверно: не все действительные &lt;a href=&quot;../primitive.u32&quot;&gt; &lt;code&gt;u32&lt;/code&gt; &lt;/a&gt; s действительны &lt;a href=&quot;../primitive.char&quot;&gt; &lt;code&gt;char&lt;/code&gt; &lt;/a&gt; s. &lt;code&gt;from_u32()&lt;/code&gt; вернет &lt;code&gt;None&lt;/code&gt; , если введенное значение не является допустимым значением для &lt;a href=&quot;../primitive.char&quot;&gt; &lt;code&gt;char&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="627ab6996d8e9eb90f195c27a7e3d742a80e3b8e" translate="yes" xml:space="preserve">
          <source>However, the reverse is not true: not all valid &lt;a href=&quot;../primitive.u32&quot;&gt;&lt;code&gt;u32&lt;/code&gt;&lt;/a&gt;s are valid &lt;a href=&quot;../primitive.char&quot;&gt;&lt;code&gt;char&lt;/code&gt;&lt;/a&gt;s. &lt;code&gt;from_u32_unchecked()&lt;/code&gt; will ignore this, and blindly cast to &lt;a href=&quot;../primitive.char&quot;&gt;&lt;code&gt;char&lt;/code&gt;&lt;/a&gt;, possibly creating an invalid one.</source>
          <target state="translated">Однако обратное неверно: не все действительные &lt;a href=&quot;../primitive.u32&quot;&gt; &lt;code&gt;u32&lt;/code&gt; &lt;/a&gt; s действительны &lt;a href=&quot;../primitive.char&quot;&gt; &lt;code&gt;char&lt;/code&gt; &lt;/a&gt; s. &lt;code&gt;from_u32_unchecked()&lt;/code&gt; проигнорирует это и слепо переведет в &lt;a href=&quot;../primitive.char&quot;&gt; &lt;code&gt;char&lt;/code&gt; &lt;/a&gt; , возможно, создав недопустимый.</target>
        </trans-unit>
        <trans-unit id="3551f079ee4c6634be3812dc148413baa86b8300" translate="yes" xml:space="preserve">
          <source>However, the reverse is not true: not all valid &lt;a href=&quot;primitive.u32&quot;&gt;&lt;code&gt;u32&lt;/code&gt;&lt;/a&gt;s are valid &lt;code&gt;char&lt;/code&gt;s. &lt;code&gt;from_u32()&lt;/code&gt; will return &lt;code&gt;None&lt;/code&gt; if the input is not a valid value for a &lt;code&gt;char&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7eb7d7f1f319fa36dc03fb6cd45ffdc556ad5b67" translate="yes" xml:space="preserve">
          <source>However, the reverse is not true: not all valid &lt;a href=&quot;primitive.u32&quot;&gt;&lt;code&gt;u32&lt;/code&gt;&lt;/a&gt;s are valid &lt;code&gt;char&lt;/code&gt;s. &lt;code&gt;from_u32_unchecked()&lt;/code&gt; will ignore this, and blindly cast to &lt;code&gt;char&lt;/code&gt;, possibly creating an invalid one.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1f5612bf46edfe618e917ff01d32fb9bebb43312" translate="yes" xml:space="preserve">
          <source>However, the second part is different. In languages with a &lt;em&gt;garbage collector (GC)&lt;/em&gt;, the GC keeps track and cleans up memory that isn&amp;rsquo;t being used anymore, and we don&amp;rsquo;t need to think about it. Without a GC, it&amp;rsquo;s our responsibility to identify when memory is no longer being used and call code to explicitly return it, just as we did to request it. Doing this correctly has historically been a difficult programming problem. If we forget, we&amp;rsquo;ll waste memory. If we do it too early, we&amp;rsquo;ll have an invalid variable. If we do it twice, that&amp;rsquo;s a bug too. We need to pair exactly one &lt;code&gt;allocate&lt;/code&gt; with exactly one &lt;code&gt;free&lt;/code&gt;.</source>
          <target state="translated">Однако вторая часть отличается. В языках со &lt;em&gt;сборщиком мусора (GC)&lt;/em&gt; GC отслеживает и очищает память, которая больше не используется, и нам не нужно об этом думать. Без сборщика мусора мы обязаны определять, когда память больше не используется, и вызывать код для ее явного возврата, как мы это делали, чтобы запросить его. Исторически сделать это правильно было сложной проблемой программирования. Если мы забудем, мы тратим память. Если мы сделаем это слишком рано, у нас будет недействительная переменная. Если мы сделаем это дважды, это тоже ошибка. Нам нужно связать ровно один &lt;code&gt;allocate&lt;/code&gt; с ровно одним &lt;code&gt;free&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="af229bc0a48ef0630b724d21dd6f456c48e60c69" translate="yes" xml:space="preserve">
          <source>However, there are situations in which it would be useful for a value to mutate itself in its methods but appear immutable to other code. Code outside the value&amp;rsquo;s methods would not be able to mutate the value. Using &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt; is one way to get the ability to have interior mutability. But &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt; doesn&amp;rsquo;t get around the borrowing rules completely: the borrow checker in the compiler allows this interior mutability, and the borrowing rules are checked at runtime instead. If you violate the rules, you&amp;rsquo;ll get a &lt;code&gt;panic!&lt;/code&gt; instead of a compiler error.</source>
          <target state="translated">Однако бывают ситуации, в которых было бы полезно, чтобы значение изменялось в своих методах, но казалось неизменным для другого кода. Код вне методов значения не сможет изменить значение. Использование &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt; - это один из способов получить возможность внутренней изменчивости. Но &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt; не обходит полностью правила заимствования: средство проверки заимствований в компиляторе допускает эту внутреннюю изменчивость, и вместо этого правила заимствования проверяются во время выполнения. Если вы нарушите правила, то &lt;code&gt;panic!&lt;/code&gt; вместо ошибки компилятора.</target>
        </trans-unit>
        <trans-unit id="a0d46c846b73ae9a30e6ec8307068cbd57726662" translate="yes" xml:space="preserve">
          <source>However, there is a &lt;a href=&quot;../type-coercions&quot;&gt;coercion&lt;/a&gt; from function items to &lt;a href=&quot;function-pointer&quot;&gt;function pointers&lt;/a&gt; with the same signature, which is triggered not only when a function item is used when a function pointer is directly expected, but also when different function item types with the same signature meet in different arms of the same &lt;code&gt;if&lt;/code&gt; or &lt;code&gt;match&lt;/code&gt;:</source>
          <target state="translated">Тем не менее, есть &lt;a href=&quot;../type-coercions&quot;&gt;принуждение&lt;/a&gt; из элементов функции для &lt;a href=&quot;function-pointer&quot;&gt;указателей на функции&lt;/a&gt; с той же подписью, который срабатывает не только тогда , когда используется функция элемент , когда указатель функции непосредственно ожидается, но и при использовании различных типов функция пункт с одной и той же подписи встречаются в разных руки того же, &lt;code&gt;if&lt;/code&gt; или &lt;code&gt;match&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="a66a1dddad283613aaa962e121910c064ac30ef0" translate="yes" xml:space="preserve">
          <source>However, there&amp;rsquo;s one problem with this test, as shown here:</source>
          <target state="translated">Однако есть одна проблема с этим тестом, как показано здесь:</target>
        </trans-unit>
        <trans-unit id="18f90c271b4c818c9717e731f31d20c5d63240c8" translate="yes" xml:space="preserve">
          <source>However, they would need to write the implementation block for each type they wanted to use with &lt;code&gt;hello_macro&lt;/code&gt;; we want to spare them from having to do this work.</source>
          <target state="translated">Однако им нужно будет написать блок реализации для каждого типа, который они хотят использовать с &lt;code&gt;hello_macro&lt;/code&gt; ; мы хотим избавить их от этой работы.</target>
        </trans-unit>
        <trans-unit id="4c27a12b4f8451e9cc5839d83f04460a9e92623c" translate="yes" xml:space="preserve">
          <source>However, this &quot;zombie&quot; value should not be exposed to safe code, and this function should not be called more than once. To use a value after it's been dropped, or drop a value multiple times, can cause Undefined Behavior (depending on what &lt;code&gt;drop&lt;/code&gt; does). This is normally prevented by the type system, but users of &lt;code&gt;ManuallyDrop&lt;/code&gt; must uphold those guarantees without assistance from the compiler.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="313fc636d6ceb50d6fb43efb8c2726a3510a1c57" translate="yes" xml:space="preserve">
          <source>However, this extra power comes with extra responsibilities: it is now up to you to ensure soundness. The &lt;code&gt;unsafe&lt;/code&gt; keyword helps by clearly marking the pieces of code that need to worry about this.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d3b75e55302f15f6020a4b2831ab78b8a9cd134e" translate="yes" xml:space="preserve">
          <source>However, this is not an ideal solution: if it was absolutely critical that the program only operated on values between 1 and 100, and it had many functions with this requirement, having a check like this in every function would be tedious (and might impact performance).</source>
          <target state="translated">Однако это не идеальное решение:если бы было абсолютно критично,чтобы программа работала только со значениями от 1 до 100,и у нее было бы много функций с этим требованием,то иметь такую проверку в каждой функции было бы утомительно (и это могло бы повлиять на производительность).</target>
        </trans-unit>
        <trans-unit id="a824bb12ed66d349d925794b2e3920170b4c275c" translate="yes" xml:space="preserve">
          <source>However, this pattern is so common that Rust has a built-in language construct for it, called a &lt;code&gt;while&lt;/code&gt; loop. Listing 3-3 uses &lt;code&gt;while&lt;/code&gt;: the program loops three times, counting down each time, and then, after the loop, it prints another message and exits.</source>
          <target state="translated">Тем не менее, эта модель настолько часто , что ржавчина имеет встроенный язык конструкции для него, называется в &lt;code&gt;while&lt;/code&gt; цикл. В листинге 3-3 используется &lt;code&gt;while&lt;/code&gt; : программа выполняет три цикла, каждый раз считая в обратном порядке, а затем, после цикла, она печатает еще одно сообщение и завершает работу.</target>
        </trans-unit>
        <trans-unit id="ada98a89852cf14a520ca2427888843bc3fd0869" translate="yes" xml:space="preserve">
          <source>However, this won't:</source>
          <target state="translated">Однако,это не так:</target>
        </trans-unit>
        <trans-unit id="2ba8355a99e10032076801bb58aaec6886066a15" translate="yes" xml:space="preserve">
          <source>However, two concurrency concepts are embedded in the language: the &lt;code&gt;std::marker&lt;/code&gt; traits &lt;code&gt;Sync&lt;/code&gt; and &lt;code&gt;Send&lt;/code&gt;.</source>
          <target state="translated">Тем не менее, эти два понятия параллельности встраивается в языке: &lt;code&gt;std::marker&lt;/code&gt; признаки &lt;code&gt;Sync&lt;/code&gt; и &lt;code&gt;Send&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0fad3453f67fa7a8abf1de710cc99507cae5f79c" translate="yes" xml:space="preserve">
          <source>However, using &lt;code&gt;..&lt;/code&gt; must be unambiguous. If it is unclear which values are intended for matching and which should be ignored, Rust will give us an error. Listing 18-25 shows an example of using &lt;code&gt;..&lt;/code&gt; ambiguously, so it will not compile.</source>
          <target state="translated">Однако использование &lt;code&gt;..&lt;/code&gt; должно быть однозначным. Если неясно, какие значения предназначены для сопоставления, а какие следует игнорировать, Rust выдаст нам ошибку. В листинге 18-25 показан пример неоднозначного использования &lt;code&gt;..&lt;/code&gt; , поэтому он не будет компилироваться.</target>
        </trans-unit>
        <trans-unit id="f1a26fc372d073b9ed76f398473c3b964914605f" translate="yes" xml:space="preserve">
          <source>However, we&amp;rsquo;ve reintroduced one of the problems from Listing 13-3: we&amp;rsquo;re still calling the closure twice in the first &lt;code&gt;if&lt;/code&gt; block, which will call the expensive code twice and make the user wait twice as long as they need to. We could fix this problem by creating a variable local to that &lt;code&gt;if&lt;/code&gt; block to hold the result of calling the closure, but closures provide us with another solution. We&amp;rsquo;ll talk about that solution in a bit. But first let&amp;rsquo;s talk about why there aren&amp;rsquo;t type annotations in the closure definition and the traits involved with closures.</source>
          <target state="translated">Однако мы вновь представили одну из проблем из Листинга 13-3: мы по-прежнему дважды вызываем закрытие в первом блоке &lt;code&gt;if&lt;/code&gt; , который дважды вызовет дорогостоящий код и заставит пользователя ждать вдвое дольше, чем нужно. Мы могли бы решить эту проблему, создав переменную, локальную по отношению к блоку &lt;code&gt;if&lt;/code&gt; , для хранения результата вызова закрытия, но замыкания предоставляют нам другое решение. Мы поговорим об этом решении немного позже. Но сначала давайте поговорим о том, почему в определении замыкания нет аннотаций типов, и о свойствах, связанных с замыканиями.</target>
        </trans-unit>
        <trans-unit id="aeba4f050e04fdf1cf910571a9c79d642b8343c4" translate="yes" xml:space="preserve">
          <source>However, when failure is expected, it&amp;rsquo;s more appropriate to return a &lt;code&gt;Result&lt;/code&gt; than to make a &lt;code&gt;panic!&lt;/code&gt; call. Examples include a parser being given malformed data or an HTTP request returning a status that indicates you have hit a rate limit. In these cases, returning a &lt;code&gt;Result&lt;/code&gt; indicates that failure is an expected possibility that the calling code must decide how to handle.</source>
          <target state="translated">Однако, когда ожидается неудача, лучше вернуть &lt;code&gt;Result&lt;/code&gt; чем &lt;code&gt;panic!&lt;/code&gt; вызов. Примеры включают в себя синтаксический анализатор, которому передаются искаженные данные, или HTTP-запрос, возвращающий статус, который указывает, что вы достигли предела скорости. В этих случаях возврат &lt;code&gt;Result&lt;/code&gt; указывает на то, что ожидаемая вероятность сбоя, которую вызывающий код должен решить, как обрабатывать.</target>
        </trans-unit>
        <trans-unit id="bd1b29ca1d0594e55daa86076890956a32cf494f" translate="yes" xml:space="preserve">
          <source>However, with trait objects we have to make a table containing &lt;em&gt;every&lt;/em&gt; object that implements the trait. Now, if it has type parameters, we need to add implementations for every type that implements the trait, and there could theoretically be an infinite number of types.</source>
          <target state="translated">Однако с объектами признака мы должны составить таблицу, содержащую &lt;em&gt;каждый&lt;/em&gt; объект, реализующий признак. Теперь, если у него есть параметры типа, нам нужно добавить реализации для каждого типа, реализующего черту, и теоретически может быть бесконечное количество типов.</target>
        </trans-unit>
        <trans-unit id="c83a1e89e4828f4c8e8c03978096139099426f82" translate="yes" xml:space="preserve">
          <source>However, you can only use &lt;code&gt;impl Trait&lt;/code&gt; if you&amp;rsquo;re returning a single type. For example, this code that returns either a &lt;code&gt;NewsArticle&lt;/code&gt; or a &lt;code&gt;Tweet&lt;/code&gt; with the return type specified as &lt;code&gt;impl Summary&lt;/code&gt; wouldn&amp;rsquo;t work:</source>
          <target state="translated">Однако вы можете использовать &lt;code&gt;impl Trait&lt;/code&gt; только в том случае, если вы возвращаете один тип. Например, этот код, который возвращает либо &lt;code&gt;NewsArticle&lt;/code&gt; , либо &lt;code&gt;Tweet&lt;/code&gt; с типом возврата, указанным как &lt;code&gt;impl Summary&lt;/code&gt; , не будет работать:</target>
        </trans-unit>
        <trans-unit id="e2fcea022d94a9775aabc30c1a2c51d018156b80" translate="yes" xml:space="preserve">
          <source>Hundreds of companies, large and small, use Rust in production for a variety of tasks. Those tasks include command line tools, web services, DevOps tooling, embedded devices, audio and video analysis and transcoding, cryptocurrencies, bioinformatics, search engines, Internet of Things applications, machine learning, and even major parts of the Firefox web browser.</source>
          <target state="translated">Сотни компаний,больших и малых,используют ржавчину в производстве для решения различных задач.К таким задачам относятся инструменты командной строки,веб-сервисы,инструменты DevOps,встраиваемые устройства,анализ и транскодирование аудио-и видеоматериалов,криптокоррекция,биоинформатика,поисковые системы,приложения Internet of Things,машинное обучение и даже основные части веб-браузера Firefox.</target>
        </trans-unit>
        <trans-unit id="37906f8372f8c377be7b1e328309d3c4f609ea59" translate="yes" xml:space="preserve">
          <source>Hygiene</source>
          <target state="translated">Hygiene</target>
        </trans-unit>
        <trans-unit id="ad65c5b3b86039ac673217b5d774ea59d147e7b7" translate="yes" xml:space="preserve">
          <source>Hyperbolic cosine function.</source>
          <target state="translated">Гиперболическая косинусная функция.</target>
        </trans-unit>
        <trans-unit id="c686c752760e59aa04f64bbe28ff2dbeca59fd00" translate="yes" xml:space="preserve">
          <source>Hyperbolic sine function.</source>
          <target state="translated">Гиперболическая синусоидальная функция.</target>
        </trans-unit>
        <trans-unit id="78df70baad8c07fe855fe47101a5902c14b1e359" translate="yes" xml:space="preserve">
          <source>Hyperbolic tangent function.</source>
          <target state="translated">Функция гиперболического тангенса.</target>
        </trans-unit>
        <trans-unit id="bdf6cba1852f21a59de6863b8e6d7784db0851c8" translate="yes" xml:space="preserve">
          <source>I call it my billion-dollar mistake. At that time, I was designing the first comprehensive type system for references in an object-oriented language. My goal was to ensure that all use of references should be absolutely safe, with checking performed automatically by the compiler. But I couldn&amp;rsquo;t resist the temptation to put in a null reference, simply because it was so easy to implement. This has led to innumerable errors, vulnerabilities, and system crashes, which have probably caused a billion dollars of pain and damage in the last forty years.</source>
          <target state="translated">Я называю это своей ошибкой на миллиард долларов. В то время я разрабатывал первую комплексную систему типов для ссылок на объектно-ориентированном языке. Моя цель состояла в том, чтобы гарантировать, что любое использование ссылок должно быть абсолютно безопасным, с автоматической проверкой компилятором. Но я не мог устоять перед соблазном вставить пустую ссылку просто потому, что это было так легко реализовать. Это привело к бесчисленным ошибкам, уязвимостям и системным сбоям, которые, вероятно, нанесли миллиард долларов боли и ущерба за последние сорок лет.</target>
        </trans-unit>
        <trans-unit id="e7c23cd87ff8917afb8c94f0de55718d338f0dac" translate="yes" xml:space="preserve">
          <source>IDE Integration Using the Rust Language Server</source>
          <target state="translated">Интеграция IDE с использованием сервера ржавчины</target>
        </trans-unit>
        <trans-unit id="0e3b1f1fb38a7fe314d2f472da7f442366e6c3f3" translate="yes" xml:space="preserve">
          <source>IDENTIFIER</source>
          <target state="translated">IDENTIFIER</target>
        </trans-unit>
        <trans-unit id="55b1203af6cad8ae52e0d0a37f140db7910d8eda" translate="yes" xml:space="preserve">
          <source>IDENTIFIER :</source>
          <target state="translated">IDENTIFIER :</target>
        </trans-unit>
        <trans-unit id="c0fcd90425d895f40b307f4c7f56f5df18b1668f" translate="yes" xml:space="preserve">
          <source>IDENTIFIER_OR_KEYWORD :</source>
          <target state="translated">ИДЕНТИФИКАТОР_ИЛИ_КЛЮЧЕВОЕ СЛОВО :</target>
        </trans-unit>
        <trans-unit id="b8dae77b24288c011d2b9b755b9a1a42811917e3" translate="yes" xml:space="preserve">
          <source>IEEE-754 very precisely specifies the bit layout of floats.</source>
          <target state="translated">IEEE-754 очень точно определяет битовую компоновку поплавков.</target>
        </trans-unit>
        <trans-unit id="1852814b8596efd4647ef533b868ea9c6f371594" translate="yes" xml:space="preserve">
          <source>IETF RFC 4291 section 2.4</source>
          <target state="translated">IETF RFC 4291 раздел 2.4</target>
        </trans-unit>
        <trans-unit id="aa0c0f5169dc17cce987a2ba8ef3419dba45ba72" translate="yes" xml:space="preserve">
          <source>IETF RFC 4291 section 2.5.6</source>
          <target state="translated">IETF RFC 4291 раздел 2.5.6</target>
        </trans-unit>
        <trans-unit id="bb6e7841dba2c83d7f4685d9f749f0a969927ab9" translate="yes" xml:space="preserve">
          <source>INFINITY</source>
          <target state="translated">INFINITY</target>
        </trans-unit>
        <trans-unit id="a1a3b8cc81502982ba95837302feb61e65dd8a3d" translate="yes" xml:space="preserve">
          <source>INNER_BLOCK_DOC :</source>
          <target state="translated">INNER_BLOCK_DOC :</target>
        </trans-unit>
        <trans-unit id="53a0430947a0edbae0af7f9e49d8f2dfe4e9afb4" translate="yes" xml:space="preserve">
          <source>INNER_LINE_DOC :</source>
          <target state="translated">INNER_LINE_DOC :</target>
        </trans-unit>
        <trans-unit id="cfbd240cfc0633423b9847728303e0a704bcd5d5" translate="yes" xml:space="preserve">
          <source>INTEGER_LITERAL</source>
          <target state="translated">INTEGER_LITERAL</target>
        </trans-unit>
        <trans-unit id="3f9135bee30f70c629387b1f17caf9d0de0eb83e" translate="yes" xml:space="preserve">
          <source>INTEGER_LITERAL :</source>
          <target state="translated">ЦЕЛОЕ_ЛИТЕРАЛ :</target>
        </trans-unit>
        <trans-unit id="6371ddd611a0269a5bb8329b8b5ad2906b65b001" translate="yes" xml:space="preserve">
          <source>INTEGER_SUFFIX :</source>
          <target state="translated">ЦЕЛОЕ_СУФФИКС :</target>
        </trans-unit>
        <trans-unit id="11cbb1f84a9535024b6452829b5548dd25b90335" translate="yes" xml:space="preserve">
          <source>IPv4 addresses are defined as 32-bit integers in &lt;a href=&quot;https://tools.ietf.org/html/rfc791&quot;&gt;IETF RFC 791&lt;/a&gt;. They are usually represented as four octets.</source>
          <target state="translated">Адреса IPv4 определены как 32-битные целые числа в &lt;a href=&quot;https://tools.ietf.org/html/rfc791&quot;&gt;IETF RFC 791&lt;/a&gt; . Обычно они представлены четырьмя октетами.</target>
        </trans-unit>
        <trans-unit id="f61d67f908f166f992bd96ab7aae0433beeddddf" translate="yes" xml:space="preserve">
          <source>IPv4 socket addresses consist of an &lt;a href=&quot;struct.ipv4addr&quot;&gt;&lt;code&gt;IPv4&lt;/code&gt; address&lt;/a&gt; and a 16-bit port number, as stated in &lt;a href=&quot;https://tools.ietf.org/html/rfc793&quot;&gt;IETF RFC 793&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="125cc8de0dff730e4520fc003986c19a1b8554df" translate="yes" xml:space="preserve">
          <source>IPv4 socket addresses consist of an &lt;a href=&quot;struct.ipv4addr&quot;&gt;IPv4 address&lt;/a&gt; and a 16-bit port number, as stated in &lt;a href=&quot;https://tools.ietf.org/html/rfc793&quot;&gt;IETF RFC 793&lt;/a&gt;.</source>
          <target state="translated">Адреса сокетов IPv4 состоят из &lt;a href=&quot;struct.ipv4addr&quot;&gt;адреса IPv4&lt;/a&gt; и 16-битного номера порта, как указано в &lt;a href=&quot;https://tools.ietf.org/html/rfc793&quot;&gt;IETF RFC 793&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="0fb594a9f230f62a93a2d236d355fee291f5f0ed" translate="yes" xml:space="preserve">
          <source>IPv6 addresses are defined as 128-bit integers in &lt;a href=&quot;https://tools.ietf.org/html/rfc4291&quot;&gt;IETF RFC 4291&lt;/a&gt;. They are usually represented as eight 16-bit segments.</source>
          <target state="translated">Адреса IPv6 определены как 128-битные целые числа в &lt;a href=&quot;https://tools.ietf.org/html/rfc4291&quot;&gt;IETF RFC 4291&lt;/a&gt; . Обычно они представлены как восемь 16-битных сегментов.</target>
        </trans-unit>
        <trans-unit id="9506a43966237e091295db561358da8326a23b09" translate="yes" xml:space="preserve">
          <source>IPv6 socket addresses consist of an &lt;a href=&quot;struct.ipv6addr&quot;&gt;&lt;code&gt;IPv6&lt;/code&gt; address&lt;/a&gt;, a 16-bit port number, as well as fields containing the traffic class, the flow label, and a scope identifier (see &lt;a href=&quot;https://tools.ietf.org/html/rfc2553#section-3.3&quot;&gt;IETF RFC 2553, Section 3.3&lt;/a&gt; for more details).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3a88c8ad7ac15b70173172e130a9df32e2c85f47" translate="yes" xml:space="preserve">
          <source>IPv6 socket addresses consist of an &lt;a href=&quot;struct.ipv6addr&quot;&gt;Ipv6 address&lt;/a&gt;, a 16-bit port number, as well as fields containing the traffic class, the flow label, and a scope identifier (see &lt;a href=&quot;https://tools.ietf.org/html/rfc2553#section-3.3&quot;&gt;IETF RFC 2553, Section 3.3&lt;/a&gt; for more details).</source>
          <target state="translated">Адреса сокетов IPv6 состоят из &lt;a href=&quot;struct.ipv6addr&quot;&gt;адреса IPv6&lt;/a&gt; , 16-битного номера порта, а также полей, содержащих класс трафика, метку потока и идентификатор области (см. &lt;a href=&quot;https://tools.ietf.org/html/rfc2553#section-3.3&quot;&gt;IETF RFC 2553, раздел 3.3&lt;/a&gt; для более подробной информации).</target>
        </trans-unit>
        <trans-unit id="5e75cacea0fd3b6b14f0b4659c3bb43c233b1bc1" translate="yes" xml:space="preserve">
          <source>Identifier patterns</source>
          <target state="translated">Шаблоны идентификаторов</target>
        </trans-unit>
        <trans-unit id="2871ae9886988ebe4584f71645f1cfa54c50fb26" translate="yes" xml:space="preserve">
          <source>Identifier patterns are irrefutable if the &lt;code&gt;@&lt;/code&gt; subpattern is irrefutable or the subpattern is not specified.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b14c125598d88502f5133a3afc5b567be6c1a2d3" translate="yes" xml:space="preserve">
          <source>Identifier patterns bind the value they match to a variable. The identifier must be unique within the pattern. The variable will shadow any variables of the same name in scope. The scope of the new binding depends on the context of where the pattern is used (such as a &lt;code&gt;let&lt;/code&gt; binding or a &lt;code&gt;match&lt;/code&gt; arm).</source>
          <target state="translated">Шаблоны идентификаторов связывают значение, которое они соответствуют, с переменной. Идентификатор должен быть уникальным в пределах шаблона. Переменная затеняет любые переменные с тем же именем в области видимости. Объем новой привязки зависит от контекста, в котором используется шаблон (например, привязка &lt;code&gt;let&lt;/code&gt; или рука &lt;code&gt;match&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="649d2864df18704de32e689e69e63f2483e8b76e" translate="yes" xml:space="preserve">
          <source>Identifiers</source>
          <target state="translated">Identifiers</target>
        </trans-unit>
        <trans-unit id="a28f079910fa2727e597ae224c9f3f8cbc529307" translate="yes" xml:space="preserve">
          <source>Identify duplicate code.</source>
          <target state="translated">Идентифицируйте дубликат кода.</target>
        </trans-unit>
        <trans-unit id="9f0d27a694b397b392e1c0d4d2916d104a364051" translate="yes" xml:space="preserve">
          <source>If &amp;epsilon; &amp;isin; LAST(&lt;code&gt;uu ...&lt;/code&gt;), then LAST(M) = LAST(&lt;code&gt;tt&lt;/code&gt;) &amp;cup; (LAST(&lt;code&gt;uu ...&lt;/code&gt;) \ { &amp;epsilon; }).</source>
          <target state="translated">Если &amp;epsilon; &amp;isin; LAST ( &lt;code&gt;uu ...&lt;/code&gt; ), то LAST (M) = LAST ( &lt;code&gt;tt&lt;/code&gt; ) &amp;cup; (LAST ( &lt;code&gt;uu ...&lt;/code&gt; ) \ {&amp;epsilon;}).</target>
        </trans-unit>
        <trans-unit id="96acc5da5a6cbbd203437fa84771d338d67204aa" translate="yes" xml:space="preserve">
          <source>If &lt;a href=&quot;../struct.vecdeque#method.make_contiguous&quot;&gt;&lt;code&gt;make_contiguous&lt;/code&gt;&lt;/a&gt; was previously called, all elements of the &lt;code&gt;VecDeque&lt;/code&gt; will be in the first slice and the second slice will be empty.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ed811da5d2f26e42527abd7d7393051a81f9fad7" translate="yes" xml:space="preserve">
          <source>If &lt;a href=&quot;struct.path#method.extension&quot;&gt;&lt;code&gt;self.extension&lt;/code&gt;&lt;/a&gt; is &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt;, the extension is added; otherwise it is replaced.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e801c0aa2cecddf4c1a1f7baf739c356c501f4d3" translate="yes" xml:space="preserve">
          <source>If &lt;a href=&quot;struct.path#method.file_name&quot;&gt;&lt;code&gt;self.file_name&lt;/code&gt;&lt;/a&gt; was &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt;, this is equivalent to pushing &lt;code&gt;file_name&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="534c6252638c1abdb91099e943245185bc915d7e" translate="yes" xml:space="preserve">
          <source>If &lt;a href=&quot;struct.pathbuf#method.extension&quot;&gt;&lt;code&gt;self.extension&lt;/code&gt;&lt;/a&gt; is &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt;, the extension is added; otherwise it is replaced.</source>
          <target state="translated">Если &lt;a href=&quot;struct.pathbuf#method.extension&quot;&gt; &lt;code&gt;self.extension&lt;/code&gt; &lt;/a&gt; равен &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt; &lt;code&gt;None&lt;/code&gt; &lt;/a&gt; , расширение добавляется; в противном случае его заменяют.</target>
        </trans-unit>
        <trans-unit id="01a2757701a9695cb15304f9062c5f6fe543e1d0" translate="yes" xml:space="preserve">
          <source>If &lt;a href=&quot;struct.pathbuf#method.file_name&quot;&gt;&lt;code&gt;self.file_name&lt;/code&gt;&lt;/a&gt; was &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt;, this is equivalent to pushing &lt;code&gt;file_name&lt;/code&gt;.</source>
          <target state="translated">Если для &lt;a href=&quot;struct.pathbuf#method.file_name&quot;&gt; &lt;code&gt;self.file_name&lt;/code&gt; &lt;/a&gt; было &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt; &lt;code&gt;None&lt;/code&gt; &lt;/a&gt; , это эквивалентно нажатию &lt;code&gt;file_name&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="29376b60b0b5a1ec52b8a24373266c830da3ba88" translate="yes" xml:space="preserve">
          <source>If &lt;a href=&quot;struct.vecdeque#method.make_contiguous&quot;&gt;&lt;code&gt;make_contiguous&lt;/code&gt;&lt;/a&gt; was previously called, all elements of the &lt;code&gt;VecDeque&lt;/code&gt; will be in the first slice and the second slice will be empty.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4087b2407c0523ab27c22d69edd0438fe2e50815" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;'static&lt;/code&gt; is used for any lifetime bound then &lt;code&gt;'static&lt;/code&gt; is used.</source>
          <target state="translated">Если &lt;code&gt;'static&lt;/code&gt; используется для любого ограничения времени жизни, тогда &lt;code&gt;'static&lt;/code&gt; используется.</target>
        </trans-unit>
        <trans-unit id="2299b8f75754da8b24aff81fd36ddb6f9ef90ec2" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;..&lt;/code&gt; is not used, it is required to match all fields:</source>
          <target state="translated">Если &lt;code&gt;..&lt;/code&gt; не используется, необходимо сопоставить все поля:</target>
        </trans-unit>
        <trans-unit id="f3b5be9d19759c8147145d2b3c53249ad84a368f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;.create_new(true)&lt;/code&gt; is set, &lt;a href=&quot;#method.create&quot;&gt;&lt;code&gt;.create()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#method.truncate&quot;&gt;&lt;code&gt;.truncate()&lt;/code&gt;&lt;/a&gt; are ignored.</source>
          <target state="translated">Если установлено &lt;code&gt;.create_new(true)&lt;/code&gt; , &lt;a href=&quot;#method.create&quot;&gt; &lt;code&gt;.create()&lt;/code&gt; &lt;/a&gt; и &lt;a href=&quot;#method.truncate&quot;&gt; &lt;code&gt;.truncate()&lt;/code&gt; &lt;/a&gt; игнорируются.</target>
        </trans-unit>
        <trans-unit id="29bc21e0c15798e73a6dbc2093728d2f6a268b72" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;.create_new(true)&lt;/code&gt; is set, &lt;a href=&quot;struct.openoptions#method.create&quot;&gt;&lt;code&gt;.create()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;struct.openoptions#method.truncate&quot;&gt;&lt;code&gt;.truncate()&lt;/code&gt;&lt;/a&gt; are ignored.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2ad0cab5b7af8f6f0d802cf376de0871197cd2fb" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Complete&lt;/code&gt; is returned then the generator has completely finished with the value provided. It is invalid for the generator to be resumed again.</source>
          <target state="translated">Если возвращается &lt;code&gt;Complete&lt;/code&gt; , то генератор полностью завершил работу с предоставленным значением. Повторное возобновление работы генератора недопустимо.</target>
        </trans-unit>
        <trans-unit id="ac903d4e63c4f5e9053aaefd66eff84df6124016" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;ForeignTrait&lt;/code&gt; is a trait defined in some external crate &lt;code&gt;foo&lt;/code&gt;, then the following trait &lt;code&gt;impl&lt;/code&gt; is an error:</source>
          <target state="translated">Если &lt;code&gt;ForeignTrait&lt;/code&gt; - это черта, определенная во внешнем ящике &lt;code&gt;foo&lt;/code&gt; , то следующая черта &lt;code&gt;impl&lt;/code&gt; является ошибкой:</target>
        </trans-unit>
        <trans-unit id="c1fd05b3bcfcb4d8ea20c271d94557cb3d13d52d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Hello, world!&lt;/code&gt; did print, congratulations! You&amp;rsquo;ve officially written a Rust program. That makes you a Rust programmer&amp;mdash;welcome!</source>
          <target state="translated">Если &lt;code&gt;Hello, world!&lt;/code&gt; распечатал, поздравляю! Вы официально написали программу на Rust. Это делает вас программистом на Rust - добро пожаловать!</target>
        </trans-unit>
        <trans-unit id="7eb14007d446b8ddd9ae89463ae1a1d31374e8ad" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;N&lt;/code&gt; is greater than the size of the slice, it will return no windows.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="11ac605f741ebf773252ac24fa49e72ab712c9a3" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T: Drop&lt;/code&gt;, calling &lt;a href=&quot;../std/ops/trait.drop#tymethod.drop&quot;&gt;&lt;code&gt;&amp;lt;T as std::ops::Drop&amp;gt;::drop&lt;/code&gt;&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2c3c7b96cb91a4bbdb1b6896643ea9e9a3c22921" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; also implements &lt;code&gt;Eq&lt;/code&gt; (implying reflexivity of equality), two &lt;code&gt;Arc&lt;/code&gt;s that point to the same allocation are always equal.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eeac29050d6596e7248fbdb56f4b4514db570609" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; also implements &lt;code&gt;Eq&lt;/code&gt; (implying reflexivity of equality), two &lt;code&gt;Arc&lt;/code&gt;s that point to the same value are never unequal.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="37e2b122febd728f5d8f178462e020b9f40dc3b9" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; also implements &lt;code&gt;Eq&lt;/code&gt; (implying reflexivity of equality), two &lt;code&gt;Rc&lt;/code&gt;s that point to the same allocation are always equal.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="39a40f9d20e095dacb94b9b37bf7db5ad95d17e9" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; also implements &lt;code&gt;Eq&lt;/code&gt; (implying reflexivity of equality), two &lt;code&gt;Rc&lt;/code&gt;s that point to the same allocation are never unequal.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5b6043d2d9c915604d4623e46635d9a9a232a5d1" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; also implements &lt;code&gt;Eq&lt;/code&gt;, two &lt;code&gt;Arc&lt;/code&gt;s that point to the same value are always equal.</source>
          <target state="translated">Если &lt;code&gt;T&lt;/code&gt; также реализует &lt;code&gt;Eq&lt;/code&gt; , две &lt;code&gt;Arc&lt;/code&gt; , которые указывают на одно и то же значение, всегда равны.</target>
        </trans-unit>
        <trans-unit id="ec82a111c6092884516e8540e107bb1534de81bd" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; also implements &lt;code&gt;Eq&lt;/code&gt;, two &lt;code&gt;Arc&lt;/code&gt;s that point to the same value are never unequal.</source>
          <target state="translated">Если &lt;code&gt;T&lt;/code&gt; также реализует &lt;code&gt;Eq&lt;/code&gt; , две &lt;code&gt;Arc&lt;/code&gt; , указывающие на одно и то же значение, никогда не будут неравными.</target>
        </trans-unit>
        <trans-unit id="21cc57c8697439642e0504b016521d59698b000c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; also implements &lt;code&gt;Eq&lt;/code&gt;, two &lt;code&gt;Rc&lt;/code&gt;s that point to the same value are always equal.</source>
          <target state="translated">Если &lt;code&gt;T&lt;/code&gt; также реализует &lt;code&gt;Eq&lt;/code&gt; , два &lt;code&gt;Rc&lt;/code&gt; , которые указывают на одно и то же значение, всегда равны.</target>
        </trans-unit>
        <trans-unit id="79dd19ff096e35ccdc8e2994890606a0f2b80c5b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; also implements &lt;code&gt;Eq&lt;/code&gt;, two &lt;code&gt;Rc&lt;/code&gt;s that point to the same value are never unequal.</source>
          <target state="translated">Если &lt;code&gt;T&lt;/code&gt; также реализует &lt;code&gt;Eq&lt;/code&gt; , два &lt;code&gt;Rc&lt;/code&gt; , указывающие на одно и то же значение, никогда не будут равны.</target>
        </trans-unit>
        <trans-unit id="f0097c8e2ff22a2b90e167d6c061fa3e59f58a62" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; does not implement &lt;code&gt;Copy&lt;/code&gt;, use &lt;a href=&quot;#method.clone_from_slice&quot;&gt;&lt;code&gt;clone_from_slice&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="26c4dc3d013511006bc6b284a2d4db3c7148b968" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; implements &lt;code&gt;Copy&lt;/code&gt;, it can be more performant to use &lt;a href=&quot;#method.copy_from_slice&quot;&gt;&lt;code&gt;copy_from_slice&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2aad32f156303fc5a2bc63ee3fa5dad5cc0ca6bf" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; implements &lt;code&gt;Deref&amp;lt;Target = U&amp;gt;&lt;/code&gt;, and &lt;code&gt;x&lt;/code&gt; is a value of type &lt;code&gt;T&lt;/code&gt;, then:</source>
          <target state="translated">Если &lt;code&gt;T&lt;/code&gt; реализует &lt;code&gt;Deref&amp;lt;Target = U&amp;gt;&lt;/code&gt; , а &lt;code&gt;x&lt;/code&gt; является значением типа &lt;code&gt;T&lt;/code&gt; , то:</target>
        </trans-unit>
        <trans-unit id="95d72afe0884b2306850bd095670df15024528ce" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; implements &lt;code&gt;DerefMut&amp;lt;Target = U&amp;gt;&lt;/code&gt;, and &lt;code&gt;x&lt;/code&gt; is a value of type &lt;code&gt;T&lt;/code&gt;, then:</source>
          <target state="translated">Если &lt;code&gt;T&lt;/code&gt; реализует &lt;code&gt;DerefMut&amp;lt;Target = U&amp;gt;&lt;/code&gt; , а &lt;code&gt;x&lt;/code&gt; является значением типа &lt;code&gt;T&lt;/code&gt; , то:</target>
        </trans-unit>
        <trans-unit id="23971030fbeb1cad27f55d0399b6d51a892fe825" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; is &lt;code&gt;Sized&lt;/code&gt;, this function is always safe to call.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8b6c90a17aa05dcdf98932b5f27171dbd2de33f3" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; is FFI-safe, then so is &lt;code&gt;MaybeUninit&amp;lt;T&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">Если &lt;code&gt;T&lt;/code&gt; безопасен для FFI, то и &lt;code&gt;MaybeUninit&amp;lt;T&amp;gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="49964ef73f44405d2ac7053108ae2569108b6abf" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; is not an enum, calling this function will not result in undefined behavior, but the return value is unspecified.</source>
          <target state="translated">Если &lt;code&gt;T&lt;/code&gt; не является перечислением, вызов этой функции не приведет к неопределенному поведению, но возвращаемое значение не указано.</target>
        </trans-unit>
        <trans-unit id="8dca1b3ef01a1ffebdb81541f8580fb6c5190017" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; is not an enum, calling this function will not result in undefined behavior, but the return value is unspecified. Equally, if &lt;code&gt;T&lt;/code&gt; is an enum with more variants than &lt;code&gt;usize::MAX&lt;/code&gt; the return value is unspecified. Uninhabited variants will be counted.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="70442d0f7a75e13703c9f3f655e0ebf8ba235584" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Ti&lt;/code&gt; can be coerced to the current target type &lt;code&gt;T_t&lt;/code&gt;, then no change is made.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f81fb6d8ced60b0cd6b321f060ac68460468aa0c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;addr&lt;/code&gt; yields multiple addresses, &lt;code&gt;bind&lt;/code&gt; will be attempted with each of the addresses until one succeeds and returns the listener. If none of the addresses succeed in creating a listener, the error returned from the last attempt (the last address) is returned.</source>
          <target state="translated">Если &lt;code&gt;addr&lt;/code&gt; дает несколько адресов, будет предпринята попытка &lt;code&gt;bind&lt;/code&gt; с каждым из адресов, пока один из них не будет успешным и не вернет прослушиватель. Если ни по одному из адресов не удалось создать прослушиватель, возвращается ошибка, полученная при последней попытке (последний адрес).</target>
        </trans-unit>
        <trans-unit id="7f3c01a32008b38d419c728226a54e01a7d962fe" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;addr&lt;/code&gt; yields multiple addresses, &lt;code&gt;bind&lt;/code&gt; will be attempted with each of the addresses until one succeeds and returns the socket. If none of the addresses succeed in creating a socket, the error returned from the last attempt (the last address) is returned.</source>
          <target state="translated">Если &lt;code&gt;addr&lt;/code&gt; дает несколько адресов, будет предпринята попытка &lt;code&gt;bind&lt;/code&gt; с каждым из адресов, пока один из них не завершится успешно и не вернет сокет. Если ни один из адресов не смог создать сокет, возвращается ошибка, полученная при последней попытке (последний адрес).</target>
        </trans-unit>
        <trans-unit id="0c53eddc64c1e675eb29f0974efda41f4b33efd1" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;addr&lt;/code&gt; yields multiple addresses, &lt;code&gt;connect&lt;/code&gt; will be attempted with each of the addresses until a connection is successful. If none of the addresses result in a successful connection, the error returned from the last connection attempt (the last address) is returned.</source>
          <target state="translated">Если &lt;code&gt;addr&lt;/code&gt; дает несколько адресов, попытки &lt;code&gt;connect&lt;/code&gt; будут предприниматься с каждым из адресов до тех пор, пока соединение не будет успешным. Если ни один из адресов не приводит к успешному соединению, возвращается ошибка, полученная при последней попытке соединения (последний адрес).</target>
        </trans-unit>
        <trans-unit id="07f5c20249e5fa3260da27a7df45155885f3dd08" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;addr&lt;/code&gt; yields multiple addresses, &lt;code&gt;connect&lt;/code&gt; will be attempted with each of the addresses until the underlying OS function returns no error. Note that usually, a successful &lt;code&gt;connect&lt;/code&gt; call does not specify that there is a remote server listening on the port, rather, such an error would only be detected after the first send. If the OS returns an error for each of the specified addresses, the error returned from the last connection attempt (the last address) is returned.</source>
          <target state="translated">Если &lt;code&gt;addr&lt;/code&gt; дает несколько адресов, будет предпринята попытка &lt;code&gt;connect&lt;/code&gt; с каждым из адресов, пока базовая функция ОС не вернет ошибку. Обратите внимание, что обычно успешный вызов &lt;code&gt;connect&lt;/code&gt; не указывает, что есть удаленный сервер, прослушивающий порт, скорее, такая ошибка будет обнаружена только после первой отправки. Если ОС возвращает ошибку для каждого из указанных адресов, возвращается ошибка, полученная при последней попытке подключения (последний адрес).</target>
        </trans-unit>
        <trans-unit id="acfc45781f88c4761baec8897c0ca4cf03d5120d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;base&lt;/code&gt; is not a prefix of &lt;code&gt;self&lt;/code&gt; (i.e., &lt;a href=&quot;#method.starts_with&quot;&gt;&lt;code&gt;starts_with&lt;/code&gt;&lt;/a&gt; returns &lt;code&gt;false&lt;/code&gt;), returns &lt;a href=&quot;../result/enum.result#variant.Err&quot;&gt;&lt;code&gt;Err&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Если &lt;code&gt;base&lt;/code&gt; не является префиксом &lt;code&gt;self&lt;/code&gt; (т.е. &lt;a href=&quot;#method.starts_with&quot;&gt; &lt;code&gt;starts_with&lt;/code&gt; &lt;/a&gt; возвращает &lt;code&gt;false&lt;/code&gt; ), возвращает &lt;a href=&quot;../result/enum.result#variant.Err&quot;&gt; &lt;code&gt;Err&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="c33668a2d69ed6be4cc49feb7054f832229cf3a2" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;base&lt;/code&gt; is not a prefix of &lt;code&gt;self&lt;/code&gt; (i.e., &lt;a href=&quot;struct.path#method.starts_with&quot;&gt;&lt;code&gt;starts_with&lt;/code&gt;&lt;/a&gt; returns &lt;code&gt;false&lt;/code&gt;), returns &lt;a href=&quot;../result/enum.result#variant.Err&quot;&gt;&lt;code&gt;Err&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1b461fd46fdb1045defa6bb08692a4c2d8f4230a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;buffer&lt;/code&gt; does &lt;em&gt;not&lt;/em&gt; start with the bytes in &lt;code&gt;get&lt;/code&gt;, it means we&amp;rsquo;ve received some other request. We&amp;rsquo;ll add code to the &lt;code&gt;else&lt;/code&gt; block in a moment to respond to all other requests.</source>
          <target state="translated">Если &lt;code&gt;buffer&lt;/code&gt; никак &lt;em&gt;не&lt;/em&gt; начать с байтами в &lt;code&gt;get&lt;/code&gt; , это означает , что мы получили некоторый другой запрос. Мы добавим код в блок &lt;code&gt;else&lt;/code&gt; через мгновение, чтобы ответить на все остальные запросы.</target>
        </trans-unit>
        <trans-unit id="65de2dbca56069ac5ddb30aad7c8e3292f2e853a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;f&lt;/code&gt; panics, the panic is propagated to the caller, and the cell remains uninitialized.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f00643b3b6dd6ef6ea56050255f61c8e0b9bb9ce" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;func&lt;/code&gt; returns &lt;code&gt;true&lt;/code&gt; for the next value of this iterator, consume and return it. Otherwise, return &lt;code&gt;None&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bb805fab8234f3a9b02923cee55ae95cc32673cc" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;k&lt;/code&gt; is greater than &lt;code&gt;len()&lt;/code&gt;. Note that &lt;code&gt;k == len()&lt;/code&gt; does &lt;em&gt;not&lt;/em&gt; panic and is a no-op rotation.</source>
          <target state="translated">Если &lt;code&gt;k&lt;/code&gt; больше &lt;code&gt;len()&lt;/code&gt; . Обратите внимание, что &lt;code&gt;k == len()&lt;/code&gt; не вызывает паники и &lt;em&gt;не&lt;/em&gt; требует поворота.</target>
        </trans-unit>
        <trans-unit id="f9e7bcd447817a79430b03e0a66dfa67f1d0816a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;len&lt;/code&gt; is greater than the &lt;code&gt;VecDeque&lt;/code&gt;'s current length, this has no effect.</source>
          <target state="translated">Если &lt;code&gt;len&lt;/code&gt; больше, чем текущая длина &lt;code&gt;VecDeque&lt;/code&gt; , это не действует.</target>
        </trans-unit>
        <trans-unit id="3d4f7e3b9010f5f85b09ea6a7879139a55bd516a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;len&lt;/code&gt; is greater than the vector's current length, this has no effect.</source>
          <target state="translated">Если &lt;code&gt;len&lt;/code&gt; больше текущей длины вектора, это не действует.</target>
        </trans-unit>
        <trans-unit id="1cf8419e86a3170a30c5b069909ed1f0302b608f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;mid&lt;/code&gt; is greater than &lt;code&gt;len()&lt;/code&gt;. Note that &lt;code&gt;mid == len()&lt;/code&gt; does &lt;em&gt;not&lt;/em&gt; panic and is a no-op rotation.</source>
          <target state="translated">Если &lt;code&gt;mid&lt;/code&gt; больше, чем &lt;code&gt;len()&lt;/code&gt; . Обратите внимание , что в &lt;code&gt;mid == len()&lt;/code&gt; делает &lt;em&gt;не&lt;/em&gt; паниковать и вращение не-оп.</target>
        </trans-unit>
        <trans-unit id="5a6e0913f28771cf69b8d16954b1cc061c4e770a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;n&lt;/code&gt; substrings are returned, the last substring (the &lt;code&gt;n&lt;/code&gt;th substring) will contain the remainder of the string.</source>
          <target state="translated">Если возвращается &lt;code&gt;n&lt;/code&gt; подстрок, последняя подстрока ( &lt;code&gt;n&lt;/code&gt; - я подстрока) будет содержать остаток от строки.</target>
        </trans-unit>
        <trans-unit id="705ee37ce1f2981d5872c521c36f0e77f17b6dcb" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;new_len&lt;/code&gt; is greater than &lt;code&gt;len&lt;/code&gt;, the &lt;code&gt;Vec&lt;/code&gt; is extended by the difference, with each additional slot filled with &lt;a href=&quot;../default/trait.default#tymethod.default&quot;&gt;&lt;code&gt;Default::default()&lt;/code&gt;&lt;/a&gt;. If &lt;code&gt;new_len&lt;/code&gt; is less than &lt;code&gt;len&lt;/code&gt;, the &lt;code&gt;Vec&lt;/code&gt; is simply truncated.</source>
          <target state="translated">Если &lt;code&gt;new_len&lt;/code&gt; больше &lt;code&gt;len&lt;/code&gt; , &lt;code&gt;Vec&lt;/code&gt; расширяется на разницу, при этом каждый дополнительный слот заполняется &lt;a href=&quot;../default/trait.default#tymethod.default&quot;&gt; &lt;code&gt;Default::default()&lt;/code&gt; &lt;/a&gt; . Если &lt;code&gt;new_len&lt;/code&gt; меньше &lt;code&gt;len&lt;/code&gt; , &lt;code&gt;Vec&lt;/code&gt; просто усекается.</target>
        </trans-unit>
        <trans-unit id="ad28de2b804b7bf236f81edae0db607218d0ac6e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;new_len&lt;/code&gt; is greater than &lt;code&gt;len&lt;/code&gt;, the &lt;code&gt;Vec&lt;/code&gt; is extended by the difference, with each additional slot filled with &lt;code&gt;value&lt;/code&gt;. If &lt;code&gt;new_len&lt;/code&gt; is less than &lt;code&gt;len&lt;/code&gt;, the &lt;code&gt;Vec&lt;/code&gt; is simply truncated.</source>
          <target state="translated">Если &lt;code&gt;new_len&lt;/code&gt; больше &lt;code&gt;len&lt;/code&gt; , &lt;code&gt;Vec&lt;/code&gt; увеличивается на разность, при этом каждый дополнительный слот заполняется &lt;code&gt;value&lt;/code&gt; . Если &lt;code&gt;new_len&lt;/code&gt; меньше &lt;code&gt;len&lt;/code&gt; , &lt;code&gt;Vec&lt;/code&gt; просто усекается.</target>
        </trans-unit>
        <trans-unit id="c6a8aec540c240a392d0120d56829bf27ca15fcc" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;new_len&lt;/code&gt; is greater than &lt;code&gt;len&lt;/code&gt;, the &lt;code&gt;Vec&lt;/code&gt; is extended by the difference, with each additional slot filled with the result of calling the closure &lt;code&gt;f&lt;/code&gt;. The return values from &lt;code&gt;f&lt;/code&gt; will end up in the &lt;code&gt;Vec&lt;/code&gt; in the order they have been generated.</source>
          <target state="translated">Если &lt;code&gt;new_len&lt;/code&gt; больше &lt;code&gt;len&lt;/code&gt; , &lt;code&gt;Vec&lt;/code&gt; увеличивается на разность, и каждый дополнительный слот заполняется результатом вызова закрытия &lt;code&gt;f&lt;/code&gt; . Значения, возвращаемые из &lt;code&gt;f&lt;/code&gt; , попадут в &lt;code&gt;Vec&lt;/code&gt; в том порядке, в котором они были сгенерированы.</target>
        </trans-unit>
        <trans-unit id="57261354a67401e0b42f57fdd95ec00fffeda84c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;new_len&lt;/code&gt; is greater than the string's current length, this has no effect.</source>
          <target state="translated">Если &lt;code&gt;new_len&lt;/code&gt; больше текущей длины строки, это не действует.</target>
        </trans-unit>
        <trans-unit id="8e6148a2ee667e899f4bb89c993862e7efe20971" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;new_len&lt;/code&gt; is less than &lt;code&gt;len&lt;/code&gt;, the &lt;code&gt;Vec&lt;/code&gt; is simply truncated.</source>
          <target state="translated">Если &lt;code&gt;new_len&lt;/code&gt; меньше &lt;code&gt;len&lt;/code&gt; , &lt;code&gt;Vec&lt;/code&gt; просто усекается.</target>
        </trans-unit>
        <trans-unit id="abb4fe85675ce478754ece04841053fa5e5c6a3e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;num&lt;/code&gt; had been &lt;code&gt;Some(10)&lt;/code&gt; instead, the match guard in the first arm would have been false because 10 is not less than 5. Rust would then go to the second arm, which would match because the second arm doesn&amp;rsquo;t have a match guard and therefore matches any &lt;code&gt;Some&lt;/code&gt; variant.</source>
          <target state="translated">Если бы вместо &lt;code&gt;num&lt;/code&gt; было &lt;code&gt;Some(10)&lt;/code&gt; , спичка в первой руке была бы ложной, потому что 10 не меньше 5. Rust перешел бы на вторую руку, которая будет соответствовать, потому что вторая рука не имеет сопрягать охранник и , следовательно , соответствует любому &lt;code&gt;Some&lt;/code&gt; вариант.</target>
        </trans-unit>
        <trans-unit id="b32b62b97ea86132915f7572c0fc7127777250a3" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;parse&lt;/code&gt; is &lt;em&gt;not&lt;/em&gt; able to turn the string into a number, it will return an &lt;code&gt;Err&lt;/code&gt; value that contains more information about the error. The &lt;code&gt;Err&lt;/code&gt; value does not match the &lt;code&gt;Ok(num)&lt;/code&gt; pattern in the first &lt;code&gt;match&lt;/code&gt; arm, but it does match the &lt;code&gt;Err(_)&lt;/code&gt; pattern in the second arm. The underscore, &lt;code&gt;_&lt;/code&gt;, is a catchall value; in this example, we&amp;rsquo;re saying we want to match all &lt;code&gt;Err&lt;/code&gt; values, no matter what information they have inside them. So the program will execute the second arm&amp;rsquo;s code, &lt;code&gt;continue&lt;/code&gt;, which tells the program to go to the next iteration of the &lt;code&gt;loop&lt;/code&gt; and ask for another guess. So, effectively, the program ignores all errors that &lt;code&gt;parse&lt;/code&gt; might encounter!</source>
          <target state="translated">Если &lt;code&gt;parse&lt;/code&gt; является &lt;em&gt;не&lt;/em&gt; в состоянии превратить строку в число, он возвращает &lt;code&gt;Err&lt;/code&gt; значение , которое содержит более подробную информацию об ошибке. Значение &lt;code&gt;Err&lt;/code&gt; не соответствует шаблону &lt;code&gt;Ok(num)&lt;/code&gt; в первом ответвлении &lt;code&gt;match&lt;/code&gt; , но оно соответствует шаблону &lt;code&gt;Err(_)&lt;/code&gt; во втором плече. Знак подчеркивания &lt;code&gt;_&lt;/code&gt; является общим значением; в этом примере мы говорим, что хотим сопоставить все значения &lt;code&gt;Err&lt;/code&gt; , независимо от того, какая информация в них содержится. Таким образом, программа выполнит код второй руки, &lt;code&gt;continue&lt;/code&gt; , который сообщает программе перейти к следующей итерации &lt;code&gt;loop&lt;/code&gt; и попросите еще одну догадку. Таким образом, программа игнорирует все ошибки, с которыми может столкнуться &lt;code&gt;parse&lt;/code&gt; !</target>
        </trans-unit>
        <trans-unit id="40e42a10c4724a12b9d742d659e990cc0a90590e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;parse&lt;/code&gt; is able to successfully turn the string into a number, it will return an &lt;code&gt;Ok&lt;/code&gt; value that contains the resulting number. That &lt;code&gt;Ok&lt;/code&gt; value will match the first arm&amp;rsquo;s pattern, and the &lt;code&gt;match&lt;/code&gt; expression will just return the &lt;code&gt;num&lt;/code&gt; value that &lt;code&gt;parse&lt;/code&gt; produced and put inside the &lt;code&gt;Ok&lt;/code&gt; value. That number will end up right where we want it in the new &lt;code&gt;guess&lt;/code&gt; variable we&amp;rsquo;re creating.</source>
          <target state="translated">Если &lt;code&gt;parse&lt;/code&gt; может успешно преобразовать строку в число, он вернет значение &lt;code&gt;Ok&lt;/code&gt; , которое содержит полученное число. Это &lt;code&gt;Ok&lt;/code&gt; значение будет соответствовать шаблону первой руки, и &lt;code&gt;match&lt;/code&gt; выражение просто возвращает &lt;code&gt;num&lt;/code&gt; значение, &lt;code&gt;parse&lt;/code&gt; полученного и поставить внутри &lt;code&gt;Ok&lt;/code&gt; значение. Это число окажется именно там, где мы хотим, в новой переменной &lt;code&gt;guess&lt;/code&gt; которую мы создаем.</target>
        </trans-unit>
        <trans-unit id="a78bf9200d69e40c9e7de71399af9b041b718f05" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;path&lt;/code&gt; is absolute, it replaces the current path.</source>
          <target state="translated">Если &lt;code&gt;path&lt;/code&gt; абсолютный, он заменяет текущий путь.</target>
        </trans-unit>
        <trans-unit id="73e4e153f655353974f6e6f2c813b5b3915ef1cc" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;pointer&lt;/code&gt; dereferences to an &lt;code&gt;Unpin&lt;/code&gt; type, &lt;code&gt;Pin::new&lt;/code&gt; should be used instead.</source>
          <target state="translated">Если &lt;code&gt;pointer&lt;/code&gt; разыменовывается на тип &lt;code&gt;Unpin&lt;/code&gt; , вместо него следует использовать &lt;code&gt;Pin::new&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ac86606be8e832102840dbcc4086a1857a76012b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;program&lt;/code&gt; is not an absolute path, the &lt;code&gt;PATH&lt;/code&gt; will be searched in an OS-defined way.</source>
          <target state="translated">Если &lt;code&gt;program&lt;/code&gt; не является абсолютным путем, поиск по &lt;code&gt;PATH&lt;/code&gt; будет определяться ОС.</target>
        </trans-unit>
        <trans-unit id="a98fb4db9993bb6b25528d614208eeeedcf64c3a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;self &amp;lt;= other&lt;/code&gt;: &lt;code&gt;0:0&lt;/code&gt;</source>
          <target state="translated">Если &lt;code&gt;self &amp;lt;= other&lt;/code&gt; : &lt;code&gt;0:0&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="822bf36472f08b6c870c4a7eb729d5b79300c331" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;self.value&lt;/code&gt; is &lt;code&gt;None&lt;/code&gt;, the code calls the closure stored in &lt;code&gt;self.calculation&lt;/code&gt;, saves the result in &lt;code&gt;self.value&lt;/code&gt; for future use, and returns the value as well.</source>
          <target state="translated">Если &lt;code&gt;self.value&lt;/code&gt; равен &lt;code&gt;None&lt;/code&gt; , код вызывает закрытие, хранящееся в &lt;code&gt;self.calculation&lt;/code&gt; , сохраняет результат в &lt;code&gt;self.value&lt;/code&gt; для использования в будущем и также возвращает значение.</target>
        </trans-unit>
        <trans-unit id="0f62f6b36639e7064e0402d98d3c38179c58dd42" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;self&lt;/code&gt; already meets the prescribed alignment, then returns &lt;code&gt;self&lt;/code&gt;.</source>
          <target state="translated">Если &lt;code&gt;self&lt;/code&gt; уже соответствует заданному выравниванию, возвращается &lt;code&gt;self&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d19aaaae1a7aca6f98e6ea7cfd2e6a369fd25fbf" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;self&lt;/code&gt; is &lt;code&gt;Some(s)&lt;/code&gt; and &lt;code&gt;other&lt;/code&gt; is &lt;code&gt;Some(o)&lt;/code&gt;, this method returns &lt;code&gt;Some((s, o))&lt;/code&gt;. Otherwise, &lt;code&gt;None&lt;/code&gt; is returned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9687d508d768393d6014b090a450d643c5917f35" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;self&lt;/code&gt; is &lt;code&gt;Some(s)&lt;/code&gt; and &lt;code&gt;other&lt;/code&gt; is &lt;code&gt;Some(o)&lt;/code&gt;, this method returns &lt;code&gt;Some(f(s, o))&lt;/code&gt;. Otherwise, &lt;code&gt;None&lt;/code&gt; is returned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="14fb52988b52fdaf20fd6eb41395b17915e1caaa" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;self&lt;/code&gt; was created using &lt;a href=&quot;#method.new&quot;&gt;&lt;code&gt;Weak::new&lt;/code&gt;&lt;/a&gt;, this will return 0.</source>
          <target state="translated">Если &lt;code&gt;self&lt;/code&gt; был создан с использованием &lt;a href=&quot;#method.new&quot;&gt; &lt;code&gt;Weak::new&lt;/code&gt; &lt;/a&gt; , это вернет 0.</target>
        </trans-unit>
        <trans-unit id="ffe2ed689988d142674d1aa54b3aa925c7f0ceb1" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;self&lt;/code&gt; was created using &lt;a href=&quot;#method.new&quot;&gt;&lt;code&gt;Weak::new&lt;/code&gt;&lt;/a&gt;, this will return 0. If not, the returned value is at least 1, since &lt;code&gt;self&lt;/code&gt; still points to the value.</source>
          <target state="translated">Если &lt;code&gt;self&lt;/code&gt; был создан с использованием &lt;a href=&quot;#method.new&quot;&gt; &lt;code&gt;Weak::new&lt;/code&gt; &lt;/a&gt; , это вернет 0. Если нет, возвращаемое значение будет не менее 1, поскольку &lt;code&gt;self&lt;/code&gt; все еще указывает на значение.</target>
        </trans-unit>
        <trans-unit id="f7cf04a558af40a8692e8d38e72f630ad0f921d6" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;self&lt;/code&gt; was created using &lt;a href=&quot;#method.new&quot;&gt;&lt;code&gt;Weak::new&lt;/code&gt;&lt;/a&gt;, this will return &lt;code&gt;None&lt;/code&gt;. If not, the returned value is at least 1, since &lt;code&gt;self&lt;/code&gt; still points to the value.</source>
          <target state="translated">Если &lt;code&gt;self&lt;/code&gt; был создан с использованием &lt;a href=&quot;#method.new&quot;&gt; &lt;code&gt;Weak::new&lt;/code&gt; &lt;/a&gt; , это вернет &lt;code&gt;None&lt;/code&gt; . В противном случае возвращаемое значение равно как минимум 1, поскольку &lt;code&gt;self&lt;/code&gt; все еще указывает на значение.</target>
        </trans-unit>
        <trans-unit id="3bc7bb1c65b4b00e05db4f8ca6614cdf9fe6dd50" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;self&lt;/code&gt; was created using &lt;a href=&quot;struct.weak#method.new&quot;&gt;&lt;code&gt;Weak::new&lt;/code&gt;&lt;/a&gt;, or if there are no remaining strong pointers, this will return 0.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5cfa0b57fd172f30232192cc8919edcc309955f9" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;self&lt;/code&gt; was created using &lt;a href=&quot;struct.weak#method.new&quot;&gt;&lt;code&gt;Weak::new&lt;/code&gt;&lt;/a&gt;, this will return 0.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8ab90cc43346ebf820e0570ac8953d279713fad0" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;some_option_value&lt;/code&gt; was a &lt;code&gt;None&lt;/code&gt; value, it would fail to match the pattern &lt;code&gt;Some(x)&lt;/code&gt;, meaning the pattern is refutable. However, the &lt;code&gt;let&lt;/code&gt; statement can only accept an irrefutable pattern because there is nothing valid the code can do with a &lt;code&gt;None&lt;/code&gt; value. At compile time, Rust will complain that we&amp;rsquo;ve tried to use a refutable pattern where an irrefutable pattern is required:</source>
          <target state="translated">Если &lt;code&gt;some_option_value&lt;/code&gt; был значением &lt;code&gt;None&lt;/code&gt; , он не смог бы соответствовать шаблону &lt;code&gt;Some(x)&lt;/code&gt; , что означает, что шаблон опровергается. Однако оператор &lt;code&gt;let&lt;/code&gt; может принимать только неопровержимый шаблон, потому что код ничего не может сделать со значением &lt;code&gt;None&lt;/code&gt; . Во время компиляции Rust будет жаловаться на то, что мы пытались использовать опровергнутый паттерн, где требуется неопровержимый паттерн:</target>
        </trans-unit>
        <trans-unit id="7912a0b36bd857714b86c8f65975fd42323403e7" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;src&lt;/code&gt; does not implement &lt;code&gt;Copy&lt;/code&gt;, use &lt;a href=&quot;#method.clone_from_slice&quot;&gt;&lt;code&gt;clone_from_slice&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Если &lt;code&gt;src&lt;/code&gt; не реализует &lt;code&gt;Copy&lt;/code&gt; , используйте &lt;a href=&quot;#method.clone_from_slice&quot;&gt; &lt;code&gt;clone_from_slice&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="d89aaab24b69c1dc1835d5c53542bd5dee44e824" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;src&lt;/code&gt; implements &lt;code&gt;Copy&lt;/code&gt;, it can be more performant to use &lt;a href=&quot;#method.copy_from_slice&quot;&gt;&lt;code&gt;copy_from_slice&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Если &lt;code&gt;src&lt;/code&gt; реализует &lt;code&gt;Copy&lt;/code&gt; , может быть более производительным использовать &lt;a href=&quot;#method.copy_from_slice&quot;&gt; &lt;code&gt;copy_from_slice&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="f2fb513c03fabfd0da48ed321e5c2ec7c086217d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;src&lt;/code&gt; names a symbolic link, it is platform-specific whether the symbolic link is followed. On platforms where it's possible to not follow it, it is not followed, and the created hard link points to the symbolic link itself.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e2f26bdddcd85ded44fb8dcca9f30dea327428d6" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;x&lt;/code&gt; had been a &lt;code&gt;None&lt;/code&gt; value instead of &lt;code&gt;Some(5)&lt;/code&gt;, the patterns in the first two arms wouldn&amp;rsquo;t have matched, so the value would have matched to the underscore. We didn&amp;rsquo;t introduce the &lt;code&gt;x&lt;/code&gt; variable in the pattern of the underscore arm, so the &lt;code&gt;x&lt;/code&gt; in the expression is still the outer &lt;code&gt;x&lt;/code&gt; that hasn&amp;rsquo;t been shadowed. In this hypothetical case, the &lt;code&gt;match&lt;/code&gt; would print &lt;code&gt;Default case, x = None&lt;/code&gt;.</source>
          <target state="translated">Если бы &lt;code&gt;x&lt;/code&gt; был значением &lt;code&gt;None&lt;/code&gt; вместо &lt;code&gt;Some(5)&lt;/code&gt; , образцы в первых двух ветвях не совпадали бы, поэтому значение соответствовало бы подчеркиванию. Мы не ввели переменную &lt;code&gt;x&lt;/code&gt; в образец подчеркивания, поэтому &lt;code&gt;x&lt;/code&gt; в выражении по-прежнему является внешним &lt;code&gt;x&lt;/code&gt; , который не был затенен. В этом гипотетическом случае при &lt;code&gt;match&lt;/code&gt; будет выведен &lt;code&gt;Default case, x = None&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="18bf4b6aafae989a7516ceac94bb945e71eddb6d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;x&lt;/code&gt; is 1, 2, 3, 4, or 5, the first arm will match. This syntax is more convenient than using the &lt;code&gt;|&lt;/code&gt; operator to express the same idea; instead of &lt;code&gt;1...5&lt;/code&gt;, we would have to specify &lt;code&gt;1 | 2 | 3 | 4 | 5&lt;/code&gt; if we used &lt;code&gt;|&lt;/code&gt;. Specifying a range is much shorter, especially if we want to match, say, any number between 1 and 1,000!</source>
          <target state="translated">Если &lt;code&gt;x&lt;/code&gt; равно 1, 2, 3, 4 или 5, первая рука будет соответствовать. Этот синтаксис более удобен, чем использование &lt;code&gt;|&lt;/code&gt; оператор, чтобы выразить ту же идею; вместо &lt;code&gt;1...5&lt;/code&gt; нам нужно было бы указать &lt;code&gt;1 | 2 | 3 | 4 | 5&lt;/code&gt; , если мы использовали &lt;code&gt;|&lt;/code&gt; . Указание диапазона намного короче, особенно если мы хотим сопоставить, скажем, любое число от 1 до 1000!</target>
        </trans-unit>
        <trans-unit id="03b71537ced2e70a9ffd0edf12930fd86baf512b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;x&lt;/code&gt; is 1, 2, 3, 4, or 5, the first arm will match. This syntax is more convenient than using the &lt;code&gt;|&lt;/code&gt; operator to express the same idea; instead of &lt;code&gt;1..=5&lt;/code&gt;, we would have to specify &lt;code&gt;1 | 2 | 3 | 4 | 5&lt;/code&gt; if we used &lt;code&gt;|&lt;/code&gt;. Specifying a range is much shorter, especially if we want to match, say, any number between 1 and 1,000!</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0dff0302c86fb6267157aaf01cdfa14adc4d52ab" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;main.rs&lt;/em&gt; was your &amp;ldquo;Hello, world!&amp;rdquo; program, this line would print &lt;code&gt;Hello, world!&lt;/code&gt; to your terminal.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cb2cf548505fabb01a736215a09d7eb4359e58a1" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;main.rs&lt;/em&gt; was your Hello, world! program, this line would print &lt;code&gt;Hello, world!&lt;/code&gt; to your terminal.</source>
          <target state="translated">Если бы &lt;em&gt;main.rs&lt;/em&gt; был вашим Hello, world! программа, в этой строке будет напечатано &lt;code&gt;Hello, world!&lt;/code&gt; к вашему терминалу.</target>
        </trans-unit>
        <trans-unit id="d9079a0efb2b14490cdc2479436c152fdb5fa1c2" translate="yes" xml:space="preserve">
          <source>If Rust code &lt;em&gt;does&lt;/em&gt; need to look into those strings, it can convert them to valid UTF-8, possibly lossily, by substituting invalid sequences with &lt;a href=&quot;../../../char/constant.replacement_character&quot;&gt;&lt;code&gt;U+FFFD REPLACEMENT CHARACTER&lt;/code&gt;&lt;/a&gt;, as is conventionally done in other Rust APIs that deal with string encodings.</source>
          <target state="translated">Если код Rust &lt;em&gt;действительно&lt;/em&gt; должен изучить эти строки, он может преобразовать их в допустимый UTF-8, возможно, с потерями, путем замены недопустимых последовательностей на &lt;a href=&quot;../../../char/constant.replacement_character&quot;&gt; &lt;code&gt;U+FFFD REPLACEMENT CHARACTER&lt;/code&gt; &lt;/a&gt; , как это обычно делается в других API-интерфейсах Rust, которые работают с кодировками строк.</target>
        </trans-unit>
        <trans-unit id="197312fbd3b9939e66c78499e206ee75ae2c0258" translate="yes" xml:space="preserve">
          <source>If Rust didn&amp;rsquo;t implement deref coercion, we would have to write the code in Listing 15-13 instead of the code in Listing 15-12 to call &lt;code&gt;hello&lt;/code&gt; with a value of type &lt;code&gt;&amp;amp;MyBox&amp;lt;String&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">Если бы Rust не реализовал приведение deref, нам пришлось бы написать код из Листинга 15-13 вместо кода из Листинга 15-12 для вызова &lt;code&gt;hello&lt;/code&gt; со значением типа &lt;code&gt;&amp;amp;MyBox&amp;lt;String&amp;gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6b87cf1a5022226b7cc21cca4d2b0d16ec46dac6" translate="yes" xml:space="preserve">
          <source>If a &lt;code&gt;Read&lt;/code&gt;er does not override the default &lt;code&gt;read_vectored&lt;/code&gt; implementation, code using it may want to avoid the method all together and coalesce writes into a single buffer for higher performance.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="56ff52226d48b491c91c2959c2741fe1a5e96b46" translate="yes" xml:space="preserve">
          <source>If a &lt;code&gt;Read&lt;/code&gt;er guarantees that it can work properly with uninitialized memory, it should call &lt;a href=&quot;struct.initializer#method.nop&quot;&gt;&lt;code&gt;Initializer::nop()&lt;/code&gt;&lt;/a&gt;. See the documentation for &lt;a href=&quot;struct.initializer&quot;&gt;&lt;code&gt;Initializer&lt;/code&gt;&lt;/a&gt; for details.</source>
          <target state="translated">Если а &lt;code&gt;Read&lt;/code&gt; эр гарантирует , что он может работать должным образом с неинициализированной памятью, он должен вызвать &lt;a href=&quot;struct.initializer#method.nop&quot;&gt; &lt;code&gt;Initializer::nop()&lt;/code&gt; &lt;/a&gt; . Подробности см. В документации по &lt;a href=&quot;struct.initializer&quot;&gt; &lt;code&gt;Initializer&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="6f382719afa245fe22b4489961298212f0dd9d4d" translate="yes" xml:space="preserve">
          <source>If a &lt;code&gt;String&lt;/code&gt; has enough capacity, adding elements to it will not re-allocate. For example, consider this program:</source>
          <target state="translated">Если у &lt;code&gt;String&lt;/code&gt; достаточно емкости, добавление к ней элементов не приведет к перераспределению. Например, рассмотрим эту программу:</target>
        </trans-unit>
        <trans-unit id="9fa35bc4f2bce6280405afd54339a1d6674f6de7" translate="yes" xml:space="preserve">
          <source>If a &lt;code&gt;Vacant(entry)&lt;/code&gt; is yielded, then the key &lt;em&gt;was not&lt;/em&gt; found. In this case the only valid operation is to &lt;code&gt;insert&lt;/code&gt; a value into the entry. When this is done, the vacant entry is consumed and converted into a mutable reference to the value that was inserted. This allows for further manipulation of the value beyond the lifetime of the search itself. This is useful if complex logic needs to be performed on the value regardless of whether the value was just inserted.</source>
          <target state="translated">Если &lt;code&gt;Vacant(entry)&lt;/code&gt; , значит, ключ &lt;em&gt;не&lt;/em&gt; найден. В этом случае единственная допустимая операция - &lt;code&gt;insert&lt;/code&gt; значение в запись. Когда это будет сделано, пустая запись будет использована и преобразована в изменяемую ссылку на значение, которое было вставлено. Это позволяет дальнейшее манипулирование значением вне времени существования самого поиска. Это полезно, если необходимо выполнить сложную логику для значения независимо от того, было ли значение только что вставлено.</target>
        </trans-unit>
        <trans-unit id="cda87c5518b5b9027cd10d7cda1ac0257185a449" translate="yes" xml:space="preserve">
          <source>If a &lt;code&gt;Vec&lt;/code&gt;&lt;em&gt;has&lt;/em&gt; allocated memory, then the memory it points to is on the heap (as defined by the allocator Rust is configured to use by default), and its pointer points to &lt;a href=&quot;struct.vec#method.len&quot;&gt;&lt;code&gt;len&lt;/code&gt;&lt;/a&gt; initialized, contiguous elements in order (what you would see if you coerced it to a slice), followed by &lt;a href=&quot;struct.vec#method.capacity&quot;&gt;&lt;code&gt;capacity&lt;/code&gt;&lt;/a&gt;&lt;code&gt;-&lt;/code&gt;&lt;a href=&quot;struct.vec#method.len&quot;&gt;&lt;code&gt;len&lt;/code&gt;&lt;/a&gt; logically uninitialized, contiguous elements.</source>
          <target state="translated">Если &lt;code&gt;Vec&lt;/code&gt; &lt;em&gt;была&lt;/em&gt; выделена память, то память он указывает на куче (как определено распределителем Rust сконфигурирован для использования по умолчанию), и его указатель указывает на &lt;a href=&quot;struct.vec#method.len&quot;&gt; &lt;code&gt;len&lt;/code&gt; &lt;/a&gt; инициализации смежных элементов в порядке (то , что вы увидели бы , если вы привели его к фрагменту), за которым следует &lt;a href=&quot;struct.vec#method.capacity&quot;&gt; &lt;code&gt;capacity&lt;/code&gt; &lt;/a&gt; &lt;code&gt;-&lt;/code&gt; &lt;a href=&quot;struct.vec#method.len&quot;&gt; &lt;code&gt;len&lt;/code&gt; &lt;/a&gt; логически неинициализированные, смежные элементы.</target>
        </trans-unit>
        <trans-unit id="dd0874f4a42c7a12d138cfaedb4f719f3af9227c" translate="yes" xml:space="preserve">
          <source>If a &lt;code&gt;Write&lt;/code&gt;er does not override the default &lt;a href=&quot;trait.write#method.write_vectored&quot;&gt;&lt;code&gt;write_vectored&lt;/code&gt;&lt;/a&gt; implementation, code using it may want to avoid the method all together and coalesce writes into a single buffer for higher performance.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="887bcf39fbff642c3b328187978b79bee02328d7" translate="yes" xml:space="preserve">
          <source>If a &lt;code&gt;const&lt;/code&gt; item contains some type that does not implement this trait, then that type either (1.) does not implement &lt;code&gt;PartialEq&lt;/code&gt; (which means the constant will not provide that comparison method, which code generation assumes is available), or (2.) it implements &lt;em&gt;its own&lt;/em&gt; version of &lt;code&gt;PartialEq&lt;/code&gt; (which we assume does not conform to a structural-equality comparison).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7756c2df57a46e8ffe41d330e37036f813dca05f" translate="yes" xml:space="preserve">
          <source>If a &lt;code&gt;static&lt;/code&gt; item is declared with the &lt;a href=&quot;keyword.mut&quot;&gt;&lt;code&gt;mut&lt;/code&gt;&lt;/a&gt; keyword, then it is allowed to be modified by the program. However, accessing mutable &lt;code&gt;static&lt;/code&gt;s can cause undefined behavior in a number of ways, for example due to data races in a multithreaded context. As such, all accesses to mutable &lt;code&gt;static&lt;/code&gt;s require an &lt;a href=&quot;keyword.unsafe&quot;&gt;&lt;code&gt;unsafe&lt;/code&gt;&lt;/a&gt; block.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8c0ce05d92f7c594a3a90bea8f233df56be2f1d6" translate="yes" xml:space="preserve">
          <source>If a &lt;em&gt;new&lt;/em&gt; file is created because it does not yet exist and &lt;code&gt;.create(true)&lt;/code&gt; or &lt;code&gt;.create_new(true)&lt;/code&gt; are specified, the new file is given the attributes declared with &lt;code&gt;.attributes()&lt;/code&gt;.</source>
          <target state="translated">Если &lt;em&gt;новый&lt;/em&gt; файл создается, потому что он еще не существует и &lt;code&gt;.create(true)&lt;/code&gt; или &lt;code&gt;.create_new(true)&lt;/code&gt; , новому файлу присваиваются атрибуты, объявленные с помощью &lt;code&gt;.attributes()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="16c8daede20373077d8ff711c94e64a0b59b67bb" translate="yes" xml:space="preserve">
          <source>If a binding pattern does not explicitly have &lt;code&gt;ref&lt;/code&gt;, &lt;code&gt;ref mut&lt;/code&gt;, or &lt;code&gt;mut&lt;/code&gt;, then it uses the &lt;em&gt;default binding mode&lt;/em&gt; to determine how the variable is bound. The default binding mode starts in &quot;move&quot; mode which uses move semantics. When matching a pattern, the compiler starts from the outside of the pattern and works inwards. Each time a reference is matched using a non-reference pattern, it will automatically dereference the value and update the default binding mode. References will set the default binding mode to &lt;code&gt;ref&lt;/code&gt;. Mutable references will set the mode to &lt;code&gt;ref mut&lt;/code&gt; unless the mode is already &lt;code&gt;ref&lt;/code&gt; in which case it remains &lt;code&gt;ref&lt;/code&gt;. If the automatically dereferenced value is still a reference, it is dereferenced and this process repeats.</source>
          <target state="translated">Если в шаблоне привязки явно нет &lt;code&gt;ref&lt;/code&gt; , &lt;code&gt;ref mut&lt;/code&gt; или &lt;code&gt;mut&lt;/code&gt; , то он использует &lt;em&gt;режим привязки&lt;/em&gt; по &lt;em&gt;умолчанию,&lt;/em&gt; чтобы определить, как привязана переменная. Режим привязки по умолчанию начинается в режиме &amp;laquo;перемещения&amp;raquo;, который использует семантику перемещения. При сопоставлении с шаблоном компилятор запускается снаружи шаблона и работает внутрь. Каждый раз, когда ссылка сопоставляется с использованием шаблона, не являющегося ссылкой, она автоматически разыменует значение и обновляет режим привязки по умолчанию. Ссылки установят режим привязки по умолчанию на &lt;code&gt;ref&lt;/code&gt; . Изменяемые ссылки установят режим на &lt;code&gt;ref mut&lt;/code&gt; , если режим уже не является &lt;code&gt;ref&lt;/code&gt; ,и в этом случае он остается &lt;code&gt;ref&lt;/code&gt; . Если автоматически разыменованное значение все еще является ссылкой, оно разыменовывается, и этот процесс повторяется.</target>
        </trans-unit>
        <trans-unit id="9479998c1b13e05b48032e25e7379b48f06d377a" translate="yes" xml:space="preserve">
          <source>If a borrow, dereference, field, or tuple indexing expression has an extended temporary scope then so does its operand. If an indexing expression has an extended temporary scope then the indexed expression also has an extended temporary scope.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7cce383f10beb57ed085cf340ccb835736dad8de" translate="yes" xml:space="preserve">
          <source>If a character does not have a lowercase equivalent, the same character will be returned back by the iterator.</source>
          <target state="translated">Если символ не имеет строчного эквивалента,то этот же символ будет возвращен итератором.</target>
        </trans-unit>
        <trans-unit id="ef2f005976fec5c6467e7bb3fc454eb0cb7f06ed" translate="yes" xml:space="preserve">
          <source>If a character does not have an uppercase equivalent, the same character will be returned back by the iterator.</source>
          <target state="translated">Если символ не имеет заглавного эквивалента,то этот же символ будет возвращен итератором.</target>
        </trans-unit>
        <trans-unit id="d0d13af4b33d582574dec6432db47608e7a6fcac" translate="yes" xml:space="preserve">
          <source>If a clean shutdown is needed it is recommended to only call this function at a known point where there are no more destructors left to run.</source>
          <target state="translated">Если требуется чистое выключение,то рекомендуется вызывать эту функцию только в известной точке,где больше не осталось деструкторов для запуска.</target>
        </trans-unit>
        <trans-unit id="90545bafc06a46b5933ce2daa0969b441705a55d" translate="yes" xml:space="preserve">
          <source>If a const function is called outside a &lt;a href=&quot;../const_eval#const-context&quot;&gt;const context&lt;/a&gt;, it is indistinguishable from any other function. You can freely do anything with a const function that you can do with a regular function.</source>
          <target state="translated">Если константная функция вызывается вне &lt;a href=&quot;../const_eval#const-context&quot;&gt;константного контекста&lt;/a&gt; , она неотличима от любой другой функции. Вы можете свободно делать с константной функцией все, что вы можете делать с обычной функцией.</target>
        </trans-unit>
        <trans-unit id="ba510c5879ea4cc171f31422ae04de034d50983c" translate="yes" xml:space="preserve">
          <source>If a destructor must be run manually, such as when implementing your own smart pointer, &lt;a href=&quot;../std/ptr/fn.drop_in_place&quot;&gt;&lt;code&gt;std::ptr::drop_in_place&lt;/code&gt;&lt;/a&gt; can be used.</source>
          <target state="translated">Если деструктор необходимо запускать вручную, например, при реализации собственного интеллектуального указателя, можно использовать &lt;a href=&quot;../std/ptr/fn.drop_in_place&quot;&gt; &lt;code&gt;std::ptr::drop_in_place&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="aac87c21fcf6474549d65e03ca36c8ec59d12740" translate="yes" xml:space="preserve">
          <source>If a dynamic library or an executable that is being dynamically linked is being produced, then the compiler will attempt to reconcile the available dependencies in either the rlib or dylib format to create a final product.</source>
          <target state="translated">Если создается динамическая библиотека или исполняемый файл,который динамически компоновливается,то компилятор попытается согласовать доступные зависимости в формате rlib или dylib,чтобы создать конечный продукт.</target>
        </trans-unit>
        <trans-unit id="5cf3f34eab79e2589477387981185c179654267a" translate="yes" xml:space="preserve">
          <source>If a file is opened with both read and append access, beware that after opening, and after every write, the position for reading may be set at the end of the file. So, before writing, save the current position (using &lt;a href=&quot;../io/trait.seek#tymethod.seek&quot;&gt;&lt;code&gt;seek&lt;/code&gt;&lt;/a&gt;&lt;code&gt;(&lt;/code&gt;&lt;a href=&quot;../io/enum.seekfrom&quot;&gt;&lt;code&gt;SeekFrom&lt;/code&gt;&lt;/a&gt;&lt;code&gt;::&lt;/code&gt;&lt;a href=&quot;../io/enum.seekfrom#variant.Current&quot;&gt;&lt;code&gt;Current&lt;/code&gt;&lt;/a&gt;&lt;code&gt;(0))&lt;/code&gt;), and restore it before the next read.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b25b09268442abcdc7a1f9b2c36f533d27627828" translate="yes" xml:space="preserve">
          <source>If a file is opened with both read and append access, beware that after opening, and after every write, the position for reading may be set at the end of the file. So, before writing, save the current position (using &lt;a href=&quot;struct.file#method.seek&quot;&gt;&lt;code&gt;seek&lt;/code&gt;&lt;/a&gt;&lt;code&gt;(&lt;/code&gt;&lt;a href=&quot;../io/enum.seekfrom&quot;&gt;&lt;code&gt;SeekFrom&lt;/code&gt;&lt;/a&gt;&lt;code&gt;::&lt;/code&gt;&lt;a href=&quot;../io/enum.seekfrom#variant.Current&quot;&gt;&lt;code&gt;Current&lt;/code&gt;&lt;/a&gt;&lt;code&gt;(0))&lt;/code&gt;), and restore it before the next read.</source>
          <target state="translated">Если файл открывается с доступом как для чтения, так и для добавления, помните, что после открытия и после каждой записи позиция для чтения может быть установлена ​​в конце файла. Итак, перед записью сохраните текущую позицию (используя &lt;a href=&quot;struct.file#method.seek&quot;&gt; &lt;code&gt;seek&lt;/code&gt; &lt;/a&gt; &lt;code&gt;(&lt;/code&gt; &lt;a href=&quot;../io/enum.seekfrom&quot;&gt; &lt;code&gt;SeekFrom&lt;/code&gt; &lt;/a&gt; &lt;code&gt;::&lt;/code&gt; &lt;a href=&quot;../io/enum.seekfrom#variant.Current&quot;&gt; &lt;code&gt;Current&lt;/code&gt; &lt;/a&gt; &lt;code&gt;(0))&lt;/code&gt; ) и восстановите ее перед следующим чтением.</target>
        </trans-unit>
        <trans-unit id="7ae8e9b37b3fae0e90c2e27255beba504df5f00d" translate="yes" xml:space="preserve">
          <source>If a file is successfully opened with this option set it will truncate the file to 0 length if it already exists.</source>
          <target state="translated">При успешном открытии файла с данной опцией он будет усечен до длины 0,если он уже существует.</target>
        </trans-unit>
        <trans-unit id="d0abbc43e6eb90b8c51d1b76b304256ddf0362aa" translate="yes" xml:space="preserve">
          <source>If a floating-point type can be &lt;em&gt;uniquely&lt;/em&gt; determined from the surrounding program context, the unsuffixed floating-point literal has that type.</source>
          <target state="translated">Если тип с плавающей запятой можно &lt;em&gt;однозначно&lt;/em&gt; определить из окружающего программного контекста, литерал с плавающей запятой без суффиксов имеет этот тип.</target>
        </trans-unit>
        <trans-unit id="04efa2d88cc29b968e806cf715e0ee4d0b695c80" translate="yes" xml:space="preserve">
          <source>If a language must have inheritance to be an object-oriented language, then Rust is not one. There is no way to define a struct that inherits the parent struct&amp;rsquo;s fields and method implementations. However, if you&amp;rsquo;re used to having inheritance in your programming toolbox, you can use other solutions in Rust, depending on your reason for reaching for inheritance in the first place.</source>
          <target state="translated">Если язык должен иметь наследование, чтобы быть объектно-ориентированным языком, то Rust им не подходит. Невозможно определить структуру, которая наследует поля родительской структуры и реализации методов. Однако, если вы привыкли к наследованию в своем наборе инструментов для программирования, вы можете использовать другие решения в Rust, в зависимости от того, почему вы в первую очередь стремитесь к наследованию.</target>
        </trans-unit>
        <trans-unit id="442a02939139d9c59cef162a2647bac06f4e1997" translate="yes" xml:space="preserve">
          <source>If a method call fails in a test, you&amp;rsquo;d want the whole test to fail, even if that method isn&amp;rsquo;t the functionality under test. Because &lt;code&gt;panic!&lt;/code&gt; is how a test is marked as a failure, calling &lt;code&gt;unwrap&lt;/code&gt; or &lt;code&gt;expect&lt;/code&gt; is exactly what should happen.</source>
          <target state="translated">Если вызов метода не проходит в тесте, вы хотите, чтобы весь тест завершился неудачно, даже если этот метод не является тестируемой функциональностью. Потому что &lt;code&gt;panic!&lt;/code&gt; Это то, как тест помечается как неудачный, вызов &lt;code&gt;unwrap&lt;/code&gt; или &lt;code&gt;expect&lt;/code&gt; - это именно то, что должно произойти.</target>
        </trans-unit>
        <trans-unit id="9d96dca6a8141f4e31a24310383d3fa9b46a981c" translate="yes" xml:space="preserve">
          <source>If a new file is created as part of a &lt;code&gt;File::open_opts&lt;/code&gt; call then this specified &lt;code&gt;mode&lt;/code&gt; will be used as the permission bits for the new file. If no &lt;code&gt;mode&lt;/code&gt; is set, the default of &lt;code&gt;0o666&lt;/code&gt; will be used. The operating system masks out bits with the systems &lt;code&gt;umask&lt;/code&gt;, to produce the final permissions.</source>
          <target state="translated">Если новый файл создается как часть вызова &lt;code&gt;File::open_opts&lt;/code&gt; то этот указанный &lt;code&gt;mode&lt;/code&gt; будет использоваться в качестве битов прав доступа для нового файла. Если &lt;code&gt;mode&lt;/code&gt; не установлен, будет использоваться значение по умолчанию &lt;code&gt;0o666&lt;/code&gt; . Операционная система маскирует биты с помощью системной маски &lt;code&gt;umask&lt;/code&gt; для получения окончательных разрешений.</target>
        </trans-unit>
        <trans-unit id="29baa09d14f6cfea0e9d752b0246ef9148a54b0e" translate="yes" xml:space="preserve">
          <source>If a new file is created as part of an &lt;code&gt;OpenOptions::open&lt;/code&gt; call then this specified &lt;code&gt;mode&lt;/code&gt; will be used as the permission bits for the new file. If no &lt;code&gt;mode&lt;/code&gt; is set, the default of &lt;code&gt;0o666&lt;/code&gt; will be used. The operating system masks out bits with the system's &lt;code&gt;umask&lt;/code&gt;, to produce the final permissions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="58a088dab2a65affaf69dc6a26afc8c56ddf7d23" translate="yes" xml:space="preserve">
          <source>If a nul byte is present and not the last element or no nul bytes is present, an error will be returned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="edf29e89879313dc8e8b20d286c6fbf984a0c2ff" translate="yes" xml:space="preserve">
          <source>If a panic occurs in a named thread, the thread name will be printed in the panic message.</source>
          <target state="translated">Если в именованной нити возникает паника,имя нити будет напечатано в сообщении о панике.</target>
        </trans-unit>
        <trans-unit id="ae66f71517007a8faed7e8f14069d9743a8fc1d6" translate="yes" xml:space="preserve">
          <source>If a program contains arithmetic overflow, the programmer has made an error. In the following discussion, we maintain a distinction between arithmetic overflow and wrapping arithmetic. The first is erroneous, while the second is intentional.</source>
          <target state="translated">Если в программе присутствует арифметическое переполнение,то программист допустил ошибку.В последующем обсуждении мы сохраним различие между арифметическим переполнением и оберточной арифметикой.Первое-ошибочное,второе-преднамеренное.</target>
        </trans-unit>
        <trans-unit id="9ed92fa5e7088a3110b1cc9346594a14bbfacbbf" translate="yes" xml:space="preserve">
          <source>If a static item is declared with the &lt;code&gt;mut&lt;/code&gt; keyword, then it is allowed to be modified by the program. One of Rust's goals is to make concurrency bugs hard to run into, and this is obviously a very large source of race conditions or other bugs. For this reason, an &lt;code&gt;unsafe&lt;/code&gt; block is required when either reading or writing a mutable static variable. Care should be taken to ensure that modifications to a mutable static are safe with respect to other threads running in the same process.</source>
          <target state="translated">Если статический элемент объявлен с ключевым словом &lt;code&gt;mut&lt;/code&gt; , программа может его изменить. Одна из целей Rust - сделать так, чтобы ошибки параллелизма были трудными, и это, очевидно, является очень большим источником состояний гонки или других ошибок. По этой причине &lt;code&gt;unsafe&lt;/code&gt; блок требуется при чтении или записи изменяемой статической переменной. Следует позаботиться о том, чтобы модификации изменяемой статики были безопасными по отношению к другим потокам, выполняющимся в том же процессе.</target>
        </trans-unit>
        <trans-unit id="a1766ce77343ee3ad45def8d871224ac057e5320" translate="yes" xml:space="preserve">
          <source>If a static library is being produced, all upstream dependencies are required to be available in &lt;code&gt;rlib&lt;/code&gt; formats. This requirement stems from the reason that a dynamic library cannot be converted into a static format.</source>
          <target state="translated">Если создается статическая библиотека, все вышестоящие зависимости должны быть доступны в форматах &lt;code&gt;rlib&lt;/code&gt; . Это требование связано с тем, что динамическую библиотеку невозможно преобразовать в статический формат.</target>
        </trans-unit>
        <trans-unit id="7bac0e8b6805f499b0c443af2ab6fa54c5aa649c" translate="yes" xml:space="preserve">
          <source>If a step is reached where there is more than one possible method, such as where generic methods or traits are considered the same, then it is a compiler error. These cases require a &lt;a href=&quot;call-expr#disambiguating-function-calls&quot;&gt;disambiguating function call syntax&lt;/a&gt; for method and function invocation.</source>
          <target state="translated">Если достигнут шаг, на котором существует более одного возможного метода, например, когда общие методы или признаки считаются одинаковыми, то это ошибка компилятора. В этих случаях требуется &lt;a href=&quot;call-expr#disambiguating-function-calls&quot;&gt;устраняющий неоднозначность синтаксис вызова функции для вызова&lt;/a&gt; метода и функции.</target>
        </trans-unit>
        <trans-unit id="7f3fff7995601b35f7065fae1e640e2f2eeb6214" translate="yes" xml:space="preserve">
          <source>If a string contains multiple contiguous separators, you will end up with empty strings in the output:</source>
          <target state="translated">Если строка содержит несколько смежных разделителей,то на выходе вы получите пустые строки:</target>
        </trans-unit>
        <trans-unit id="4ab14222518e8fb43884627c81d597c32a8700e2" translate="yes" xml:space="preserve">
          <source>If a type &lt;code&gt;Item&lt;/code&gt; has an associated type &lt;code&gt;Assoc&lt;/code&gt; from a trait &lt;code&gt;Trait&lt;/code&gt;, then &lt;code&gt;&amp;lt;Item as Trait&amp;gt;::Assoc&lt;/code&gt; is a type that is an alias of the type specified in the associated type definition. Furthermore, if &lt;code&gt;Item&lt;/code&gt; is a type parameter, then &lt;code&gt;Item::Assoc&lt;/code&gt; can be used in type parameters.</source>
          <target state="translated">Если тип &lt;code&gt;Item&lt;/code&gt; имеет связанный тип &lt;code&gt;Assoc&lt;/code&gt; из свойства &lt;code&gt;Trait&lt;/code&gt; , то &lt;code&gt;&amp;lt;Item as Trait&amp;gt;::Assoc&lt;/code&gt; - это тип, который является псевдонимом типа, указанного в определении связанного типа. Кроме того, если &lt;code&gt;Item&lt;/code&gt; является параметром типа, то в параметрах типа можно использовать &lt;code&gt;Item::Assoc&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="98ce79152874ad30a4163310f54c79462c6fb1d7" translate="yes" xml:space="preserve">
          <source>If a type contains a &lt;code&gt;PhantomPinned&lt;/code&gt;, it will not implement &lt;code&gt;Unpin&lt;/code&gt; by default.</source>
          <target state="translated">Если тип содержит &lt;code&gt;PhantomPinned&lt;/code&gt; , он не будет осуществлять &lt;code&gt;Unpin&lt;/code&gt; по умолчанию.</target>
        </trans-unit>
        <trans-unit id="1433c5d355e130cd227bc3635eea7b7161e572f3" translate="yes" xml:space="preserve">
          <source>If all goes well, &lt;code&gt;Hello, world!&lt;/code&gt; should print to the terminal. Running &lt;code&gt;cargo build&lt;/code&gt; for the first time also causes Cargo to create a new file at the top level: &lt;em&gt;Cargo.lock&lt;/em&gt;. This file keeps track of the exact versions of dependencies in your project. This project doesn&amp;rsquo;t have dependencies, so the file is a bit sparse. You won&amp;rsquo;t ever need to change this file manually; Cargo manages its contents for you.</source>
          <target state="translated">Если все будет хорошо, &lt;code&gt;Hello, world!&lt;/code&gt; должен печатать на терминал. Запуск &lt;code&gt;cargo build&lt;/code&gt; в первый раз вызывает также Cargo создать новый файл на уровне верхнего: &lt;em&gt;Cargo.lock&lt;/em&gt; . Этот файл отслеживает точные версии зависимостей в вашем проекте. У этого проекта нет зависимостей, поэтому файл немного разрежен. Вам никогда не потребуется изменять этот файл вручную; Cargo управляет своим содержимым за вас.</target>
        </trans-unit>
        <trans-unit id="5ace79993641886b01cac522412b514b142053ea" translate="yes" xml:space="preserve">
          <source>If an &lt;code&gt;Alloc&lt;/code&gt; implementation chooses to return &lt;code&gt;Ok&lt;/code&gt; in this case (i.e., the pointer denotes a zero-sized inaccessible block) then that returned pointer must be considered &quot;currently allocated&quot;. On such an allocator, &lt;em&gt;all&lt;/em&gt; methods that take currently-allocated pointers as inputs must accept these zero-sized pointers, &lt;em&gt;without&lt;/em&gt; causing undefined behavior.</source>
          <target state="translated">Если реализация &lt;code&gt;Alloc&lt;/code&gt; решает вернуть &lt;code&gt;Ok&lt;/code&gt; в этом случае (т. Е. Указатель обозначает недоступный блок нулевого размера), то этот возвращенный указатель должен считаться &amp;laquo;выделенным в данный момент&amp;raquo;. В таком распределителе &lt;em&gt;все&lt;/em&gt; методы, которые принимают в качестве входных данных указатели, выделенные в данный момент, должны принимать эти указатели нулевого размера, &lt;em&gt;не&lt;/em&gt; вызывая неопределенного поведения.</target>
        </trans-unit>
        <trans-unit id="766a342529319b1e212f056deacbe904859bc648" translate="yes" xml:space="preserve">
          <source>If an &lt;code&gt;Err(e)&lt;/code&gt; result is returned, the value &lt;code&gt;e&lt;/code&gt; will be &quot;wrapped&quot; in the return type of the enclosing scope (which must itself implement &lt;code&gt;Try&lt;/code&gt;). Specifically, the value &lt;code&gt;X::from_error(From::from(e))&lt;/code&gt; is returned, where &lt;code&gt;X&lt;/code&gt; is the return type of the enclosing function.</source>
          <target state="translated">Если возвращается результат &lt;code&gt;Err(e)&lt;/code&gt; , значение &lt;code&gt;e&lt;/code&gt; будет &amp;laquo;завернуто&amp;raquo; в тип возвращаемого значения охватывающей области (которая должна сама реализовывать &lt;code&gt;Try&lt;/code&gt; ). В частности, &lt;code&gt;X::from_error(From::from(e))&lt;/code&gt; значение X :: from_error (From :: from (e)) , где &lt;code&gt;X&lt;/code&gt; - тип возвращаемого значения включающей функции.</target>
        </trans-unit>
        <trans-unit id="d07fb8a7b5eba0666b8e8c43c71f4a92c4cff59d" translate="yes" xml:space="preserve">
          <source>If an &lt;code&gt;Occupied(entry)&lt;/code&gt; is yielded, then the key &lt;em&gt;was&lt;/em&gt; found. In this case, the user has several options: they can &lt;code&gt;get&lt;/code&gt;, &lt;code&gt;insert&lt;/code&gt; or &lt;code&gt;remove&lt;/code&gt; the value of the occupied entry. Additionally, they can convert the occupied entry into a mutable reference to its value, providing symmetry to the vacant &lt;code&gt;insert&lt;/code&gt; case.</source>
          <target state="translated">Если &lt;code&gt;Occupied(entry)&lt;/code&gt; , значит, ключ &lt;em&gt;был&lt;/em&gt; найден. В этом случае у пользователя есть несколько вариантов: они могут &lt;code&gt;get&lt;/code&gt; , &lt;code&gt;insert&lt;/code&gt; или &lt;code&gt;remove&lt;/code&gt; значение занятой записи. Кроме того, они могут преобразовать занятую запись в изменяемую ссылку на ее значение, обеспечивая симметрию пустому &lt;code&gt;insert&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6496ceefd96285c8c2e145eb325b81df30982dd9" translate="yes" xml:space="preserve">
          <source>If an &lt;code&gt;rlib&lt;/code&gt; file is being produced, then there are no restrictions on what format the upstream dependencies are available in. It is simply required that all upstream dependencies be available for reading metadata from.</source>
          <target state="translated">Если &lt;code&gt;rlib&lt;/code&gt; файл rlib , то нет ограничений на то, в каком формате доступны восходящие зависимости. Просто требуется, чтобы все восходящие зависимости были доступны для чтения метаданных.</target>
        </trans-unit>
        <trans-unit id="c8e60161efc2f2d7cfcdc0d31414bc493321f65f" translate="yes" xml:space="preserve">
          <source>If an &lt;em&gt;existing&lt;/em&gt; file is opened with &lt;code&gt;.create(true).truncate(true)&lt;/code&gt;, its existing attributes are preserved and combined with the ones declared with &lt;code&gt;.attributes()&lt;/code&gt;.</source>
          <target state="translated">Если &lt;em&gt;существующий&lt;/em&gt; файл открывается с помощью &lt;code&gt;.create(true).truncate(true)&lt;/code&gt; , его существующие атрибуты сохраняются и объединяются с атрибутами, объявленными с помощью &lt;code&gt;.attributes()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f270e545d597563858cae4afcff9e37ad4508d2c" translate="yes" xml:space="preserve">
          <source>If an I/O error is encountered then all bytes read so far will be present in &lt;code&gt;buf&lt;/code&gt; and its length will have been adjusted appropriately.</source>
          <target state="translated">Если обнаружена ошибка ввода-вывода, тогда все прочитанные байты будут присутствовать в &lt;code&gt;buf&lt;/code&gt; , и его длина будет соответствующим образом скорректирована.</target>
        </trans-unit>
        <trans-unit id="ace1a7d9bf9ec54c3308257f201a03fece98ab35" translate="yes" xml:space="preserve">
          <source>If an executable is being produced and the &lt;code&gt;-C prefer-dynamic&lt;/code&gt; flag is not specified, then dependencies are first attempted to be found in the &lt;code&gt;rlib&lt;/code&gt; format. If some dependencies are not available in an rlib format, then dynamic linking is attempted (see below).</source>
          <target state="translated">Если исполняемый файл создается и флаг &lt;code&gt;-C prefer-dynamic&lt;/code&gt; не указан, то сначала предпринимаются попытки найти &lt;code&gt;rlib&lt;/code&gt; формате rlib . Если некоторые зависимости недоступны в формате rlib, выполняется попытка динамического связывания (см. Ниже).</target>
        </trans-unit>
        <trans-unit id="45d869ce1ba972ba36ff54baa74eb31c5112c34d" translate="yes" xml:space="preserve">
          <source>If an executor supports a cheaper way to wake without consuming the waker, it should override this method. By default, it clones the &lt;a href=&quot;../sync/struct.arc&quot;&gt;&lt;code&gt;Arc&lt;/code&gt;&lt;/a&gt; and calls &lt;code&gt;wake&lt;/code&gt; on the clone.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="246eecf3cfe47d66c6f45d4fd6c99d8afcbf27a5" translate="yes" xml:space="preserve">
          <source>If an impl has a generic parameter with the &lt;code&gt;#[may_dangle]&lt;/code&gt; attribute, then that impl must be declared as an &lt;code&gt;unsafe impl&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5e13abdce3cf8ba0eee5f3efa1352739a357002e" translate="yes" xml:space="preserve">
          <source>If an impl has a generic parameter with the &lt;code&gt;#[may_dangle]&lt;/code&gt; attribute, then that impl must be declared as an `unsafe impl.</source>
          <target state="translated">Если у impl есть общий параметр с атрибутом &lt;code&gt;#[may_dangle]&lt;/code&gt; , то этот impl должен быть объявлен как `unsafe impl.</target>
        </trans-unit>
        <trans-unit id="11945bca4b49d81520c3d9de6a4cbb63f81941bb" translate="yes" xml:space="preserve">
          <source>If an integer type can be &lt;em&gt;uniquely&lt;/em&gt; determined from the surrounding program context, the unsuffixed integer literal has that type.</source>
          <target state="translated">Если целочисленный тип может быть &lt;em&gt;однозначно&lt;/em&gt; определен из окружающего программного контекста, несуффиксированный целочисленный литерал имеет этот тип.</target>
        </trans-unit>
        <trans-unit id="8e63390dbf4949c326a2cfedfadab303b53fa34d" translate="yes" xml:space="preserve">
          <source>If an intrinsic is supposed to be used from a &lt;code&gt;const fn&lt;/code&gt; with a &lt;code&gt;rustc_const_stable&lt;/code&gt; attribute, the intrinsic's attribute must be &lt;code&gt;rustc_const_stable&lt;/code&gt;, too. Such a change should not be done without T-lang consultation, because it bakes a feature into the language that cannot be replicated in user code without compiler support.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="39805e5d14d8cab59f3ec2eabeee9744560e1fb2" translate="yes" xml:space="preserve">
          <source>If an item is private, it may be accessed by the current module and its descendants.</source>
          <target state="translated">Если элемент является приватным,то доступ к нему может быть получен текущим модулем и его потомками.</target>
        </trans-unit>
        <trans-unit id="727527b77e366466861dd6da815129cfeb9a9374" translate="yes" xml:space="preserve">
          <source>If an item is public, then it can be accessed externally from some module &lt;code&gt;m&lt;/code&gt; if you can access all the item's ancestor modules from &lt;code&gt;m&lt;/code&gt;. You can also potentially be able to name the item through re-exports. See below.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="07080131ca18f6d9e5b13a9d88dcf93cd9dc48cd" translate="yes" xml:space="preserve">
          <source>If an item is public, then it can be accessed externally from some module &lt;code&gt;m&lt;/code&gt; if you can access all the item's parent modules from &lt;code&gt;m&lt;/code&gt;. You can also potentially be able to name the item through re-exports. See below.</source>
          <target state="translated">Если элемент является общедоступным, то к нему можно получить доступ извне из некоторого модуля &lt;code&gt;m&lt;/code&gt; , если вы можете получить доступ ко всем родительским модулям элемента из &lt;code&gt;m&lt;/code&gt; . Вы также можете дать элементу имя с помощью реэкспорта. Увидеть ниже.</target>
        </trans-unit>
        <trans-unit id="d8864aae63bb3ba2da5620b13b08d971e5c9ff9b" translate="yes" xml:space="preserve">
          <source>If an iterator adapter panics, the iterator will be in an unspecified (but memory safe) state. This state is also not guaranteed to stay the same across versions of Rust, so you should avoid relying on the exact values returned by an iterator which panicked.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="63585324ac753447dc7a54f44e90a00d790fca2c" translate="yes" xml:space="preserve">
          <source>If another thread is active, the lock can still become poisoned at any time. You should not trust a &lt;code&gt;false&lt;/code&gt; value for program correctness without additional synchronization.</source>
          <target state="translated">Если активен другой поток, блокировка все равно может стать отравленной в любой момент. Не стоит доверять &lt;code&gt;false&lt;/code&gt; значению для корректности программы без дополнительной синхронизации.</target>
        </trans-unit>
        <trans-unit id="109588b2017fbb996d88327d5cc6be15dd8d4ba0" translate="yes" xml:space="preserve">
          <source>If another thread is active, the mutex can still become poisoned at any time. You should not trust a &lt;code&gt;false&lt;/code&gt; value for program correctness without additional synchronization.</source>
          <target state="translated">Если другой поток активен, мьютекс все еще может стать отравленным в любое время. Не стоит доверять &lt;code&gt;false&lt;/code&gt; значению для корректности программы без дополнительной синхронизации.</target>
        </trans-unit>
        <trans-unit id="78ea9516ec8ea7a6ed978cbfe197fc08ae18d0c1" translate="yes" xml:space="preserve">
          <source>If another user of this mutex panicked while holding the mutex, then this call will return an error if the mutex would otherwise be acquired.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e8114d3ac34051321d85f9acd763dd0f154fb356" translate="yes" xml:space="preserve">
          <source>If another user of this mutex panicked while holding the mutex, then this call will return an error instead.</source>
          <target state="translated">Если другой пользователь этого мьютекса запаниковал во время удержания мьютекса,то этот вызов вернет ошибку.</target>
        </trans-unit>
        <trans-unit id="937c1840433dcebbb1b2c20629e7140489485c5e" translate="yes" xml:space="preserve">
          <source>If another user of this mutex panicked while holding the mutex, then this call will return an error once the mutex is acquired.</source>
          <target state="translated">Если другой пользователь этого мьютекса запаниковал во время удержания мьютекса,то этот вызов вернет ошибку после получения мьютекса.</target>
        </trans-unit>
        <trans-unit id="94a8b260ae2fd91c20d30826f0ac290f20d42663" translate="yes" xml:space="preserve">
          <source>If another user of this mutex panicked while holding the mutex, then this call will return failure if the mutex would otherwise be acquired.</source>
          <target state="translated">Если другой пользователь этого мьютекса запаниковал во время удержания мьютекса,то этот вызов вернет сбой,если в противном случае мьютекс будет приобретен.</target>
        </trans-unit>
        <trans-unit id="b8a9fd6020c6344c3b4ec789d5cdc75685b6c76f" translate="yes" xml:space="preserve">
          <source>If any directory in the path specified by &lt;code&gt;path&lt;/code&gt; does not already exist and it could not be created otherwise. The specific error conditions for when a directory is being created (after it is determined to not exist) are outlined by &lt;a href=&quot;fn.create_dir&quot;&gt;&lt;code&gt;fs::create_dir&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Если какой-либо каталог по пути, указанному в &lt;code&gt;path&lt;/code&gt; , еще не существует и не может быть создан в противном случае. Конкретные условия ошибки, возникающие при создании каталога (после того, как он определен как несуществующий), описаны в &lt;a href=&quot;fn.create_dir&quot;&gt; &lt;code&gt;fs::create_dir&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="8c9733a4a8648c17f076f404425858c19e3e7e60" translate="yes" xml:space="preserve">
          <source>If any of the following conditions are violated, the result is Undefined Behavior:</source>
          <target state="translated">В случае нарушения любого из следующих условий,результатом является Неопределенное поведение:</target>
        </trans-unit>
        <trans-unit id="abfc6e25813ef681d155e66f1a056df288816b17" translate="yes" xml:space="preserve">
          <source>If any other read error is encountered then this function immediately returns. Any bytes which have already been read will be appended to &lt;code&gt;buf&lt;/code&gt;.</source>
          <target state="translated">Если обнаруживается какая-либо другая ошибка чтения, эта функция немедленно возвращается. Любые байты, которые уже были прочитаны, будут добавлены в &lt;code&gt;buf&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="dc672b538a09f0d8b7133f8175c1bdde7ae9dbbb" translate="yes" xml:space="preserve">
          <source>If any other read error is encountered then this function immediately returns. The contents of &lt;code&gt;buf&lt;/code&gt; are unspecified in this case.</source>
          <target state="translated">Если обнаруживается какая-либо другая ошибка чтения, эта функция немедленно возвращается. В этом случае содержимое &lt;code&gt;buf&lt;/code&gt; не указано.</target>
        </trans-unit>
        <trans-unit id="c60fca22bff6a233bf25c6e3874996a91aad3287" translate="yes" xml:space="preserve">
          <source>If both do not exist, &lt;a href=&quot;https://docs.microsoft.com/en-us/windows/win32/api/userenv/nf-userenv-getuserprofiledirectorya&quot;&gt;&lt;code&gt;GetUserProfileDirectory&lt;/code&gt;&lt;/a&gt; is used to return the path.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ddacadc60603d21344f24b6aa894045e4936178f" translate="yes" xml:space="preserve">
          <source>If both do not exist, &lt;a href=&quot;https://msdn.microsoft.com/en-us/library/windows/desktop/bb762280(v=vs.85).aspx&quot;&gt;&lt;code&gt;GetUserProfileDirectory&lt;/code&gt;&lt;/a&gt; is used to return the path.</source>
          <target state="translated">Если оба не существуют, &lt;a href=&quot;https://msdn.microsoft.com/en-us/library/windows/desktop/bb762280(v=vs.85).aspx&quot;&gt; &lt;code&gt;GetUserProfileDirectory&lt;/code&gt; &lt;/a&gt; используется для возврата пути.</target>
        </trans-unit>
        <trans-unit id="7fce57c290d26a88e07f0e0c3e4758aa4174e90c" translate="yes" xml:space="preserve">
          <source>If compiled as a dylib, the resulting .so could then be linked to from a C library, and the function could be used as if it was from any other library.</source>
          <target state="translated">Если она скомпилирована как dylib,то результирующий .so может быть скомпонован из библиотеки Си,и функция может быть использована,как если бы она была из любой другой библиотеки.</target>
        </trans-unit>
        <trans-unit id="e7b59b345b11e01a4787fa859ca6ad581aae3ad3" translate="yes" xml:space="preserve">
          <source>If either iterator returns &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;trait.iterator#tymethod.next&quot;&gt;&lt;code&gt;next&lt;/code&gt;&lt;/a&gt; from the zipped iterator will return &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt;. If the first iterator returns &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt;, &lt;code&gt;zip&lt;/code&gt; will short-circuit and &lt;code&gt;next&lt;/code&gt; will not be called on the second iterator.</source>
          <target state="translated">Если любой итератор возвращает &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt; &lt;code&gt;None&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;trait.iterator#tymethod.next&quot;&gt; &lt;code&gt;next&lt;/code&gt; &lt;/a&gt; из заархивированного итератора вернет &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt; &lt;code&gt;None&lt;/code&gt; &lt;/a&gt; . Если первый итератор вернет &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt; &lt;code&gt;None&lt;/code&gt; &lt;/a&gt; , произойдет короткое замыкание &lt;code&gt;zip&lt;/code&gt; , и &lt;code&gt;next&lt;/code&gt; не будет вызываться на втором итераторе.</target>
        </trans-unit>
        <trans-unit id="84103f8a5cb4506a8862655c59a4b3682ff15678" translate="yes" xml:space="preserve">
          <source>If enabled, multicast packets will be looped back to the local socket. Note that this may not have any affect on IPv6 sockets.</source>
          <target state="translated">Если эта функция включена,многоадресные пакеты будут зацикливаться обратно на локальное гнездо.Обратите внимание,что это может не повлиять на IPv6 сокеты.</target>
        </trans-unit>
        <trans-unit id="2ee8e080132486e2d1085bc2a52cb053b7cbc535" translate="yes" xml:space="preserve">
          <source>If enabled, multicast packets will be looped back to the local socket. Note that this may not have any effect on IPv6 sockets.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0fb4d55515faf0167f284803093db70ba6bdf600" translate="yes" xml:space="preserve">
          <source>If encapsulation is a required aspect for a language to be considered object oriented, then Rust meets that requirement. The option to use &lt;code&gt;pub&lt;/code&gt; or not for different parts of code enables encapsulation of implementation details.</source>
          <target state="translated">Если инкапсуляция является обязательным аспектом для того, чтобы язык считался объектно-ориентированным, то Rust соответствует этому требованию. Возможность использовать &lt;code&gt;pub&lt;/code&gt; или нет для разных частей кода позволяет инкапсулировать детали реализации.</target>
        </trans-unit>
        <trans-unit id="f88c3e80e7b4d154c2577f1e634c78e02c1c42d5" translate="yes" xml:space="preserve">
          <source>If every type inside a tuple implements one of the following traits, then a tuple itself also implements it.</source>
          <target state="translated">Если каждый тип внутри кортежа реализует один из следующих признаков,то кортеж сам также реализует его.</target>
        </trans-unit>
        <trans-unit id="b8129e0ab4f408174bb11267c05f089405b50c77" translate="yes" xml:space="preserve">
          <source>If generic code merely needs to work for all types that can provide a reference to related type &lt;code&gt;T&lt;/code&gt;, it is often better to use &lt;a href=&quot;../convert/trait.asref&quot;&gt;&lt;code&gt;AsRef&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt; as more types can safely implement it.</source>
          <target state="translated">Если общий код просто должен работать для всех типов, которые могут предоставлять ссылку на связанный тип &lt;code&gt;T&lt;/code&gt; , часто лучше использовать &lt;a href=&quot;../convert/trait.asref&quot;&gt; &lt;code&gt;AsRef&amp;lt;T&amp;gt;&lt;/code&gt; &lt;/a&gt; поскольку большее количество типов могут безопасно реализовать его.</target>
        </trans-unit>
        <trans-unit id="281313906bc5aa3fa055587412d6aee7b2eda929" translate="yes" xml:space="preserve">
          <source>If generic code merely needs to work for all types that can provide a reference to related type &lt;code&gt;T&lt;/code&gt;, it is often better to use [&lt;code&gt;AsRef&amp;lt;T&amp;gt;&lt;/code&gt;] as more types can safely implement it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="57c986c219a8db1074aab149e63ad254d155df91" translate="yes" xml:space="preserve">
          <source>If given a position, returns a reference to the element at that position or &lt;code&gt;None&lt;/code&gt; if out of bounds.</source>
          <target state="translated">Если задана позиция, возвращает ссылку на элемент в этой позиции или &lt;code&gt;None&lt;/code&gt; , если она выходит за пределы.</target>
        </trans-unit>
        <trans-unit id="0807d56f2c6d8607e36641ca45b2207a499de182" translate="yes" xml:space="preserve">
          <source>If given a range, returns the subslice corresponding to that range, or &lt;code&gt;None&lt;/code&gt; if out of bounds.</source>
          <target state="translated">Если задан диапазон, возвращает подсрез, соответствующий этому диапазону, или &lt;code&gt;None&lt;/code&gt; , если он выходит за границы.</target>
        </trans-unit>
        <trans-unit id="dfe4ffb9dd92d20a6a4139ebde5c4444a81b450b" translate="yes" xml:space="preserve">
          <source>If interpreted as the number of actual hardware threads, it may undercount on Windows systems with more than 64 hardware threads. If interpreted as the available concurrency for that process, it may overcount on Windows systems when limited by a process wide affinity mask or job object limitations, and it may overcount on Linux systems when limited by a process wide affinity mask or affected by cgroups limits.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c78c81075548342c17a3cb41f1d7c207afd16e82" translate="yes" xml:space="preserve">
          <source>If it does, add it to the list of values we&amp;rsquo;re returning.</source>
          <target state="translated">Если это так, добавьте его в список возвращаемых значений.</target>
        </trans-unit>
        <trans-unit id="6eb8349ae4604f3200e1b12d72175fa1292b930e" translate="yes" xml:space="preserve">
          <source>If it doesn&amp;rsquo;t, do nothing.</source>
          <target state="translated">Если нет, ничего не делайте.</target>
        </trans-unit>
        <trans-unit id="77f0c7f8e7e8804708118486c51110234f91b9ca" translate="yes" xml:space="preserve">
          <source>If it is not possible to align the pointer, the implementation returns &lt;code&gt;usize::MAX&lt;/code&gt;. It is permissible for the implementation to &lt;em&gt;always&lt;/em&gt; return &lt;code&gt;usize::MAX&lt;/code&gt;. Only your algorithm's performance can depend on getting a usable offset here, not its correctness.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9651a04b746a289895c0ff4ac7dbbd9c6c4bd1d9" translate="yes" xml:space="preserve">
          <source>If it is not possible to align the pointer, the implementation returns &lt;code&gt;usize::max_value()&lt;/code&gt;.</source>
          <target state="translated">Если выровнять указатель невозможно, реализация возвращает &lt;code&gt;usize::max_value()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="36c410707c8ca092b792e6807c748e0afad6b271" translate="yes" xml:space="preserve">
          <source>If it's possible, hand-monomorphize the code by writing the function for each possible type substitution. It's possible to use traits to do this cleanly, for example:</source>
          <target state="translated">Если это возможно,вручную мономорфизируйте код,написав функцию для каждой возможной подстановки типа.Можно использовать черты,чтобы сделать это чисто,например:</target>
        </trans-unit>
        <trans-unit id="8fae40cdb468d4e5d03de42a624dd09250a5c8c7" translate="yes" xml:space="preserve">
          <source>If less than &lt;code&gt;n&lt;/code&gt; elements are available, &lt;code&gt;take&lt;/code&gt; will limit itself to the size of the underlying iterator:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c0e5a61966add37320ef9414096df3e05db3ac2b" translate="yes" xml:space="preserve">
          <source>If more code were added between the construction of &lt;code&gt;String&lt;/code&gt; and the invocation of &lt;code&gt;mem::forget()&lt;/code&gt;, a panic within it would cause a double free because the same memory is handled by both &lt;code&gt;v&lt;/code&gt; and &lt;code&gt;s&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9fbc54548355fd2192a8ba719e27f659cd206c5b" translate="yes" xml:space="preserve">
          <source>If multiple patterns are used in the same arm for a &lt;code&gt;match&lt;/code&gt; expression, then an unspecified pattern will be used to determine the drop order.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8c4391f80fe19e3beba14af1b68f867a8deafde6" translate="yes" xml:space="preserve">
          <source>If necessary, you can circumvent this check using custom target specifications.</source>
          <target state="translated">При необходимости вы можете обойти эту проверку,используя пользовательские спецификации цели.</target>
        </trans-unit>
        <trans-unit id="7c94321a1ed561693d40d9b66f1f46aeaaecd3c4" translate="yes" xml:space="preserve">
          <source>If neither of the above env vars are set, then &lt;code&gt;Backtrace::capture&lt;/code&gt; will be disabled.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b8e62341b0bd62d9e8cebd223a1dae7b6e2b460b" translate="yes" xml:space="preserve">
          <source>If neither of those rules apply, then the bounds on the trait are used:</source>
          <target state="translated">Если ни одно из этих правил не применяется,то используются границы черты:</target>
        </trans-unit>
        <trans-unit id="f04e4c83d03462bae231d396fbd6bc133f04e581" translate="yes" xml:space="preserve">
          <source>If no custom hook is registered, the default hook will be returned.</source>
          <target state="translated">Если пользовательский крючок не зарегистрирован,будет возвращен крючок по умолчанию.</target>
        </trans-unit>
        <trans-unit id="3ea6cae08b251d423319bdb503b4761220cd47ba" translate="yes" xml:space="preserve">
          <source>If no explicit implementation or negative implementation is written out for an auto trait for a given type, then the compiler implements it automatically according to the following rules:</source>
          <target state="translated">Если явная реализация или отрицательная реализация не выписывается для автоматического трейта для данного типа,то компилятор реализует ее автоматически по следующим правилам:</target>
        </trans-unit>
        <trans-unit id="5d4b1cf8f992f711595955dfbd04de1463c70def" translate="yes" xml:space="preserve">
          <source>If no strong pointers remain, this will return zero.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8f530d6d6508b49e7ed96395312e1b09be42668f" translate="yes" xml:space="preserve">
          <source>If not, just run closures one at a time:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6f7fa92522a250a6d3be880c3209e2e00d855d4b" translate="yes" xml:space="preserve">
          <source>If not, try to compute a mutual supertype of &lt;code&gt;T_t&lt;/code&gt; and &lt;code&gt;Ti&lt;/code&gt;, which will become the new target type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="902fe9b3f2f74127ecf6007749394b452c7a24b7" translate="yes" xml:space="preserve">
          <source>If one of the arguments is NaN, then the other argument is returned.</source>
          <target state="translated">Если одним из аргументов является NaN,то возвращается другой.</target>
        </trans-unit>
        <trans-unit id="fd66bf5358b1619dbf93c578d3488d32d0c0fca1" translate="yes" xml:space="preserve">
          <source>If one sequence is a prefix of another, the shorter sequence is lexicographically less than the other.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7ae9dd3ada03870a6668bdcb11d4ca3933501dde" translate="yes" xml:space="preserve">
          <source>If only some methods aren't object-safe, you can add a &lt;code&gt;where Self: Sized&lt;/code&gt; bound on them to mark them as explicitly unavailable to trait objects. The functionality will still be available to all other implementers, including &lt;code&gt;Box&amp;lt;Trait&amp;gt;&lt;/code&gt; which is itself sized (assuming you &lt;code&gt;impl Trait for Box&amp;lt;Trait&amp;gt;&lt;/code&gt;).</source>
          <target state="translated">Если только некоторые методы не являются объектно-безопасными, вы можете добавить к ним &lt;code&gt;where Self: Sized&lt;/code&gt; чтобы пометить их как явно недоступные для объектов-признаков. Функциональность по-прежнему будет доступна для всех других разработчиков, включая &lt;code&gt;Box&amp;lt;Trait&amp;gt;&lt;/code&gt; , размер которого сам имеет размер (при условии, что вы &lt;code&gt;impl Trait for Box&amp;lt;Trait&amp;gt;&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="df3400bc60a85af8ff3ace18e07d7c2d1864912a" translate="yes" xml:space="preserve">
          <source>If our project is a binary crate that only contains a &lt;em&gt;src/main.rs&lt;/em&gt; file and doesn&amp;rsquo;t have a &lt;em&gt;src/lib.rs&lt;/em&gt; file, we can&amp;rsquo;t create integration tests in the &lt;em&gt;tests&lt;/em&gt; directory and bring functions defined in the &lt;em&gt;src/main.rs&lt;/em&gt; file into scope with a &lt;code&gt;use&lt;/code&gt; statement. Only library crates expose functions that other crates can use; binary crates are meant to be run on their own.</source>
          <target state="translated">Если наш проект представляет собой двоичный ящик, который содержит только файл &lt;em&gt;src / main.rs&lt;/em&gt; и не имеет файла &lt;em&gt;src / lib.rs&lt;/em&gt; , мы не можем создавать интеграционные тесты в каталоге &lt;em&gt;тестов&lt;/em&gt; и переносить функции, определенные в &lt;em&gt;src / main .rs&lt;/em&gt; файл в область видимости с &lt;code&gt;use&lt;/code&gt; оператора. Только ящики библиотек предоставляют функции, которые могут использовать другие ящики; бинарные крейты предназначены для самостоятельного запуска.</target>
        </trans-unit>
        <trans-unit id="e6324fa8ddd04d1618f1aebd83b3f76a15a2cd28" translate="yes" xml:space="preserve">
          <source>If our requirements change, and we also need to be able to traverse from &lt;code&gt;Owner&lt;/code&gt; to &lt;code&gt;Gadget&lt;/code&gt;, we will run into problems. An &lt;a href=&quot;struct.rc&quot;&gt;&lt;code&gt;Rc&lt;/code&gt;&lt;/a&gt; pointer from &lt;code&gt;Owner&lt;/code&gt; to &lt;code&gt;Gadget&lt;/code&gt; introduces a cycle between the values. This means that their reference counts can never reach 0, and the values will remain allocated forever: a memory leak. In order to get around this, we can use &lt;a href=&quot;struct.weak&quot;&gt;&lt;code&gt;Weak&lt;/code&gt;&lt;/a&gt; pointers.</source>
          <target state="translated">Если наши требования изменятся, и мы также должны иметь возможность переходить от &lt;code&gt;Owner&lt;/code&gt; к &lt;code&gt;Gadget&lt;/code&gt; , мы столкнемся с проблемами. &lt;a href=&quot;struct.rc&quot;&gt; &lt;code&gt;Rc&lt;/code&gt; &lt;/a&gt; указатель от &lt;code&gt;Owner&lt;/code&gt; к &lt;code&gt;Gadget&lt;/code&gt; представляет цикл между значениями. Это означает, что их счетчики ссылок никогда не могут достичь 0, а значения останутся распределенными навсегда: утечка памяти. Чтобы обойти это, мы можем использовать &lt;a href=&quot;struct.weak&quot;&gt; &lt;code&gt;Weak&lt;/code&gt; &lt;/a&gt; указатели.</target>
        </trans-unit>
        <trans-unit id="921a182084c11bc25c06cdc6fb33da8acc45c85b" translate="yes" xml:space="preserve">
          <source>If our requirements change, and we also need to be able to traverse from &lt;code&gt;Owner&lt;/code&gt; to &lt;code&gt;Gadget&lt;/code&gt;, we will run into problems. An &lt;a href=&quot;struct.rc&quot;&gt;&lt;code&gt;Rc&lt;/code&gt;&lt;/a&gt; pointer from &lt;code&gt;Owner&lt;/code&gt; to &lt;code&gt;Gadget&lt;/code&gt; introduces a cycle. This means that their reference counts can never reach 0, and the allocation will never be destroyed: a memory leak. In order to get around this, we can use &lt;a href=&quot;struct.weak&quot;&gt;&lt;code&gt;Weak&lt;/code&gt;&lt;/a&gt; pointers.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9b786199b10d931840d1086948f15c121bb97b51" translate="yes" xml:space="preserve">
          <source>If parsing succeeds, return the value inside &lt;a href=&quot;../result/enum.result#variant.Ok&quot;&gt;&lt;code&gt;Ok&lt;/code&gt;&lt;/a&gt;, otherwise when the string is ill-formatted return an error specific to the inside &lt;a href=&quot;../result/enum.result#variant.Err&quot;&gt;&lt;code&gt;Err&lt;/code&gt;&lt;/a&gt;. The error type is specific to implementation of the trait.</source>
          <target state="translated">Если синтаксический анализ успешен, верните значение внутри &lt;a href=&quot;../result/enum.result#variant.Ok&quot;&gt; &lt;code&gt;Ok&lt;/code&gt; &lt;/a&gt; , в противном случае, если строка неправильно отформатирована, верните ошибку, специфичную для внутренней &lt;a href=&quot;../result/enum.result#variant.Err&quot;&gt; &lt;code&gt;Err&lt;/code&gt; &lt;/a&gt; . Тип ошибки зависит от реализации признака.</target>
        </trans-unit>
        <trans-unit id="1260ea15bf2742af82873380ef5cdc057469a6e9" translate="yes" xml:space="preserve">
          <source>If set, this option disables the Nagle algorithm. This means that segments are always sent as soon as possible, even if there is only a small amount of data. When not set, data is buffered until there is a sufficient amount to send out, thereby avoiding the frequent sending of small packets.</source>
          <target state="translated">Если установлена,эта опция отключает алгоритм Nagle.Это означает,что сегменты всегда посылаются как можно быстрее,даже если есть только небольшой объем данных.Если параметр не установлен,данные буферизируются до тех пор,пока не будет отправлено достаточное количество данных,что позволяет избежать частой отправки маленьких пакетов.</target>
        </trans-unit>
        <trans-unit id="0161295a4165e472097a556bd12e3cb8153ce739" translate="yes" xml:space="preserve">
          <source>If several elements are equally maximum, the last element is returned. If the iterator is empty, &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt; is returned.</source>
          <target state="translated">Если несколько элементов одинаково максимальны, возвращается последний элемент. Если итератор пуст, возвращается &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt; &lt;code&gt;None&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="949e58f9ba98c6ec3b36a7ff32fc3bb4b305461a" translate="yes" xml:space="preserve">
          <source>If several elements are equally minimum, the first element is returned. If the iterator is empty, &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt; is returned.</source>
          <target state="translated">Если несколько элементов одинаково минимальны, возвращается первый элемент. Если итератор пуст, возвращается &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt; &lt;code&gt;None&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="b831b3eb60862f2e083acd74777a5de0ed02dd83" translate="yes" xml:space="preserve">
          <source>If someone calls your code and passes in values that don&amp;rsquo;t make sense, the best choice might be to call &lt;code&gt;panic!&lt;/code&gt; and alert the person using your library to the bug in their code so they can fix it during development. Similarly, &lt;code&gt;panic!&lt;/code&gt; is often appropriate if you&amp;rsquo;re calling external code that is out of your control and it returns an invalid state that you have no way of fixing.</source>
          <target state="translated">Если кто-то вызывает ваш код и передает значения, которые не имеют смысла, лучшим вариантом может быть вызов &lt;code&gt;panic!&lt;/code&gt; и предупредить человека, использующего вашу библиотеку, об ошибке в своем коде, чтобы он мог исправить ее во время разработки. Точно &lt;code&gt;panic!&lt;/code&gt; часто уместно, если вы вызываете внешний код, который находится вне вашего контроля, и он возвращает недопустимое состояние, которое у вас нет возможности исправить.</target>
        </trans-unit>
        <trans-unit id="acb94f3e0ba146c655ce1db4be8cf7e52d6ff088" translate="yes" xml:space="preserve">
          <source>If someone using our library decides to implement a &lt;code&gt;SelectBox&lt;/code&gt; struct that has &lt;code&gt;width&lt;/code&gt;, &lt;code&gt;height&lt;/code&gt;, and &lt;code&gt;options&lt;/code&gt; fields, they implement the &lt;code&gt;Draw&lt;/code&gt; trait on the &lt;code&gt;SelectBox&lt;/code&gt; type as well, as shown in Listing 17-8:</source>
          <target state="translated">Если кто - то использует нашу библиотеку решает реализовать &lt;code&gt;SelectBox&lt;/code&gt; структуру , которая имеет &lt;code&gt;width&lt;/code&gt; , &lt;code&gt;height&lt;/code&gt; и &lt;code&gt;options&lt;/code&gt; полей, они реализуют &lt;code&gt;Draw&lt;/code&gt; черту на &lt;code&gt;SelectBox&lt;/code&gt; типа , а также, как показаны в листинге 17-8:</target>
        </trans-unit>
        <trans-unit id="c3e301e4e887fd636487b5cc6eb192ded20f6d8f" translate="yes" xml:space="preserve">
          <source>If successful, &lt;a href=&quot;../result/enum.result#variant.Ok&quot;&gt;&lt;code&gt;Ok&lt;/code&gt;&lt;/a&gt;&lt;code&gt;(&lt;/code&gt;&lt;a href=&quot;struct.duration&quot;&gt;&lt;code&gt;Duration&lt;/code&gt;&lt;/a&gt;&lt;code&gt;)&lt;/code&gt; is returned where the duration represents the amount of time elapsed from the specified measurement to this one.</source>
          <target state="translated">В случае успеха возвращается &lt;a href=&quot;../result/enum.result#variant.Ok&quot;&gt; &lt;code&gt;Ok&lt;/code&gt; &lt;/a&gt; &lt;code&gt;(&lt;/code&gt; &lt;a href=&quot;struct.duration&quot;&gt; &lt;code&gt;Duration&lt;/code&gt; &lt;/a&gt; &lt;code&gt;)&lt;/code&gt; , где продолжительность представляет собой количество времени, прошедшее от указанного измерения до этого.</target>
        </trans-unit>
        <trans-unit id="89f232794c16a32779f42828429fca7b54b7471f" translate="yes" xml:space="preserve">
          <source>If successful, this function returns the number of bytes which were read and appended to &lt;code&gt;buf&lt;/code&gt;.</source>
          <target state="translated">В случае успеха эта функция возвращает количество байтов, которые были прочитаны и добавлены к &lt;code&gt;buf&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="dbb9443efd5c60b83bc142aff81add19921534e6" translate="yes" xml:space="preserve">
          <source>If successful, this function will return the total number of bytes read.</source>
          <target state="translated">В случае успеха эта функция вернет общее количество прочитанных байтов.</target>
        </trans-unit>
        <trans-unit id="8f3b4d7781f3d86f3d03470464550aa348524451" translate="yes" xml:space="preserve">
          <source>If taking ownership is not an option, using indices can work too:</source>
          <target state="translated">Если взять право собственности не является опцией,то использование индексов тоже может сработать:</target>
        </trans-unit>
        <trans-unit id="bf999049465c29583e4954eb5930504df7197d78" translate="yes" xml:space="preserve">
          <source>If that field has type &lt;code&gt;Bar&amp;lt;T&amp;gt;&lt;/code&gt;, then &lt;code&gt;Bar&amp;lt;T&amp;gt;&lt;/code&gt; implements &lt;code&gt;Unsized&amp;lt;Bar&amp;lt;U&amp;gt;&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">Если это поле имеет тип &lt;code&gt;Bar&amp;lt;T&amp;gt;&lt;/code&gt; , тогда &lt;code&gt;Bar&amp;lt;T&amp;gt;&lt;/code&gt; реализует &lt;code&gt;Unsized&amp;lt;Bar&amp;lt;U&amp;gt;&amp;gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9156e468bccd98925a16dabd42948c9bf77880b3" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;struct.receiver&quot;&gt;&lt;code&gt;Receiver&lt;/code&gt;&lt;/a&gt; is disconnected while trying to &lt;a href=&quot;struct.sender#method.send&quot;&gt;&lt;code&gt;send&lt;/code&gt;&lt;/a&gt; with the &lt;a href=&quot;struct.sender&quot;&gt;&lt;code&gt;Sender&lt;/code&gt;&lt;/a&gt;, the &lt;a href=&quot;struct.sender#method.send&quot;&gt;&lt;code&gt;send&lt;/code&gt;&lt;/a&gt; method will return a &lt;a href=&quot;struct.senderror&quot;&gt;&lt;code&gt;SendError&lt;/code&gt;&lt;/a&gt;. Similarly, if the &lt;a href=&quot;struct.sender&quot;&gt;&lt;code&gt;Sender&lt;/code&gt;&lt;/a&gt; is disconnected while trying to &lt;a href=&quot;struct.receiver#method.recv&quot;&gt;&lt;code&gt;recv&lt;/code&gt;&lt;/a&gt;, the &lt;a href=&quot;struct.receiver#method.recv&quot;&gt;&lt;code&gt;recv&lt;/code&gt;&lt;/a&gt; method will return a &lt;a href=&quot;struct.recverror&quot;&gt;&lt;code&gt;RecvError&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Если &lt;a href=&quot;struct.receiver&quot;&gt; &lt;code&gt;Receiver&lt;/code&gt; &lt;/a&gt; отключен при попытке &lt;a href=&quot;struct.sender#method.send&quot;&gt; &lt;code&gt;send&lt;/code&gt; &lt;/a&gt; с помощью &lt;a href=&quot;struct.sender&quot;&gt; &lt;code&gt;Sender&lt;/code&gt; &lt;/a&gt; , метод &lt;a href=&quot;struct.sender#method.send&quot;&gt; &lt;code&gt;send&lt;/code&gt; &lt;/a&gt; вернет &lt;a href=&quot;struct.senderror&quot;&gt; &lt;code&gt;SendError&lt;/code&gt; &lt;/a&gt; . Точно так же, если &lt;a href=&quot;struct.sender&quot;&gt; &lt;code&gt;Sender&lt;/code&gt; &lt;/a&gt; отключен во время попытки &lt;a href=&quot;struct.receiver#method.recv&quot;&gt; &lt;code&gt;recv&lt;/code&gt; &lt;/a&gt; , метод &lt;a href=&quot;struct.receiver#method.recv&quot;&gt; &lt;code&gt;recv&lt;/code&gt; &lt;/a&gt; вернет &lt;a href=&quot;struct.recverror&quot;&gt; &lt;code&gt;RecvError&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="84c875b11ce397c9d5300f965f6f873d7aacf46f" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;documentation&lt;/code&gt; environment variable is not defined, you'll get the following error:</source>
          <target state="translated">Если переменная среды &lt;code&gt;documentation&lt;/code&gt; не определена, вы получите следующую ошибку:</target>
        </trans-unit>
        <trans-unit id="772ba2d0efb42bb291361897234d8c41bb1fcad0" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;move&lt;/code&gt; keyword is used, then all captures are by move or, for &lt;code&gt;Copy&lt;/code&gt; types, by copy, regardless of whether a borrow would work. The &lt;code&gt;move&lt;/code&gt; keyword is usually used to allow the closure to outlive the captured values, such as if the closure is being returned or used to spawn a new thread.</source>
          <target state="translated">Если &lt;code&gt;move&lt;/code&gt; используется ключевое слово, то все захваты находятся на ходу или для &lt;code&gt;Copy&lt;/code&gt; типов, путем копирования, независимо от того, является ли позаимствовать будет работать. &lt;code&gt;move&lt;/code&gt; ключевое слово обычно используется , чтобы укупорочное пережить захваченные ценности, такие как , если замыкание возвращается или используется для создания нового потока.</target>
        </trans-unit>
        <trans-unit id="9d0e8d596c36d8fd761ca63dbd3e067a9bd6e058" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;panic!&lt;/code&gt; macro from the &lt;code&gt;core&lt;/code&gt; crate (not from &lt;code&gt;std&lt;/code&gt;) was used with a formatting string and some additional arguments, returns that message ready to be used for example with &lt;a href=&quot;../fmt/fn.write&quot;&gt;&lt;code&gt;fmt::write&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">Если &lt;code&gt;panic!&lt;/code&gt; макрос из &lt;code&gt;core&lt;/code&gt; ящика (не из &lt;code&gt;std&lt;/code&gt; ) использовался со строкой форматирования и некоторыми дополнительными аргументами, возвращает это сообщение, готовое к использованию, например, с помощью &lt;a href=&quot;../fmt/fn.write&quot;&gt; &lt;code&gt;fmt::write&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="1aa7728f06aa3a7a4db7dd1c33587c7078d8308d" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;push_str&lt;/code&gt; method took ownership of &lt;code&gt;s2&lt;/code&gt;, we wouldn&amp;rsquo;t be able to print its value on the last line. However, this code works as we&amp;rsquo;d expect!</source>
          <target state="translated">Если &lt;code&gt;push_str&lt;/code&gt; метод push_str стал владельцем &lt;code&gt;s2&lt;/code&gt; , мы не смогли бы напечатать его значение в последней строке. Однако этот код работает так, как мы и ожидали!</target>
        </trans-unit>
        <trans-unit id="dced1236ce3e008b86324aaba64ac8eb311fb832" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;self&lt;/code&gt; parameter is prefixed with &lt;code&gt;mut&lt;/code&gt;, it becomes a mutable variable, similar to regular parameters using a &lt;code&gt;mut&lt;/code&gt;&lt;a href=&quot;../patterns#identifier-patterns&quot;&gt;identifier pattern&lt;/a&gt;. For example:</source>
          <target state="translated">Если параметр &lt;code&gt;self&lt;/code&gt; имеет префикс &lt;code&gt;mut&lt;/code&gt; , он становится изменяемой переменной, аналогичной обычным параметрам, использующим &lt;a href=&quot;../patterns#identifier-patterns&quot;&gt;шаблон идентификатора &lt;/a&gt; &lt;code&gt;mut&lt;/code&gt; . Например:</target>
        </trans-unit>
        <trans-unit id="7d8f23d79fbc7e291c341b29a3b5a67aa2ad2d40" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;size&lt;/code&gt; is less than the current file's size, then the file will be shrunk. If it is greater than the current file's size, then the file will be extended to &lt;code&gt;size&lt;/code&gt; and have all of the intermediate data filled in with 0s.</source>
          <target state="translated">Если &lt;code&gt;size&lt;/code&gt; меньше, чем размер текущего файла, файл будет сжат. Если он больше, чем размер текущего файла, то файл будет увеличен до &lt;code&gt;size&lt;/code&gt; и все промежуточные данные будут заполнены нулями.</target>
        </trans-unit>
        <trans-unit id="d57ee1700b4eb4f8d7a231756f83fc0d2f0976ae" translate="yes" xml:space="preserve">
          <source>If the access could not be granted at this time, then &lt;code&gt;Err&lt;/code&gt; is returned. Otherwise, an RAII guard is returned which will release the shared access when it is dropped.</source>
          <target state="translated">Если доступ не может быть предоставлен в это время, возвращается &lt;code&gt;Err&lt;/code&gt; . В противном случае возвращается защита RAII, которая освобождает общий доступ, когда он отбрасывается.</target>
        </trans-unit>
        <trans-unit id="21bd5a18cb6b77fd8278b94aa3db19219a263b12" translate="yes" xml:space="preserve">
          <source>If the actual type neither requires drop glue nor implements &lt;code&gt;Copy&lt;/code&gt;, then may return &lt;code&gt;true&lt;/code&gt; or &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">Если фактический тип не требует drop glue и не реализует &lt;code&gt;Copy&lt;/code&gt; , то может вернуть &lt;code&gt;true&lt;/code&gt; или &lt;code&gt;false&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b0291a87b80d4892b3b8beac10c94678155d9e30" translate="yes" xml:space="preserve">
          <source>If the actual type neither requires drop glue nor implements &lt;code&gt;Copy&lt;/code&gt;, then the return value of this function is unspecified.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fc42b30b1c7732695b4b3457f14e9c116c60ba57" translate="yes" xml:space="preserve">
          <source>If the address different between the two pointers is not a multiple of &lt;code&gt;mem::size_of::&amp;lt;T&amp;gt;()&lt;/code&gt; then the result of the division is rounded towards zero.</source>
          <target state="translated">Если адрес, различающийся между двумя указателями, не кратен &lt;code&gt;mem::size_of::&amp;lt;T&amp;gt;()&lt;/code&gt; то результат деления округляется до нуля.</target>
        </trans-unit>
        <trans-unit id="521a07de2e3c6e68db23d9d0aa394b57d65a9c91" translate="yes" xml:space="preserve">
          <source>If the array has 32 or fewer elements (see above), you can also use the array reference's &lt;a href=&quot;iter/trait.intoiterator&quot;&gt;&lt;code&gt;IntoIterator&lt;/code&gt;&lt;/a&gt; implementation:</source>
          <target state="translated">Если в массиве 32 или меньше элементов (см. Выше), вы также можете использовать реализацию &lt;a href=&quot;iter/trait.intoiterator&quot;&gt; &lt;code&gt;IntoIterator&lt;/code&gt; &lt;/a&gt; ссылки на массив :</target>
        </trans-unit>
        <trans-unit id="cfb58ffddaf17c8830de11935999affae3277e66" translate="yes" xml:space="preserve">
          <source>If the author information that Cargo obtained from your environment is not correct, fix that in the file and save it again.</source>
          <target state="translated">Если авторская информация о Грузе,полученная из Вашего окружения,неверна,исправьте ее в файле и сохраните еще раз.</target>
        </trans-unit>
        <trans-unit id="ff4681586c0fae7d47f1330c0decf48c60236eb4" translate="yes" xml:space="preserve">
          <source>If the buffer contains no data, this will never call &lt;a href=&quot;trait.write#method.write_vectored&quot;&gt;&lt;code&gt;write_vectored&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9e707e84e6d9e2a09dcbe7b44964291bac9543c0" translate="yes" xml:space="preserve">
          <source>If the buffer contains no data, this will never call &lt;a href=&quot;trait.write#tymethod.write&quot;&gt;&lt;code&gt;write&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2baf63139a4a500a73ca143a78e4d4794de4fa4c" translate="yes" xml:space="preserve">
          <source>If the call to &lt;code&gt;poll&lt;/code&gt; returns &lt;a href=&quot;../../std/task/enum.poll#variant.Pending&quot;&gt;&lt;code&gt;Poll::Pending&lt;/code&gt;&lt;/a&gt;, then the future returns &lt;code&gt;Poll::Pending&lt;/code&gt;, suspending its state so that, when the surrounding async context is re-polled, execution returns to step 2;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="65f8dad0e6e0ed1617e67254f63f3538d64e8eee" translate="yes" xml:space="preserve">
          <source>If the capacity overflows &lt;code&gt;usize&lt;/code&gt;, or the allocator reports a failure, then an error is returned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a413f73c6a00e8ec27d7656a64c0041d810a18fb" translate="yes" xml:space="preserve">
          <source>If the capacity overflows, or the allocator reports a failure, then an error is returned.</source>
          <target state="translated">Если емкость переполняется или аллокатор сообщает о сбое,то возвращается ошибка.</target>
        </trans-unit>
        <trans-unit id="d22b2ac0a0ad8bf3c9d2af95eda6c6dcbfb7f5e8" translate="yes" xml:space="preserve">
          <source>If the child has exited, then &lt;code&gt;Ok(Some(status))&lt;/code&gt; is returned. If the exit status is not available at this time then &lt;code&gt;Ok(None)&lt;/code&gt; is returned. If an error occurs, then that error is returned.</source>
          <target state="translated">Если ребенок вышел, то возвращается &lt;code&gt;Ok(Some(status))&lt;/code&gt; . Если статус выхода недоступен в это время, возвращается &lt;code&gt;Ok(None)&lt;/code&gt; . Если возникает ошибка, возвращается эта ошибка.</target>
        </trans-unit>
        <trans-unit id="1f183ab05bb99521927fd36b3e847b7c523cd3b5" translate="yes" xml:space="preserve">
          <source>If the child thread panics, &lt;a href=&quot;../result/enum.result#variant.Err&quot;&gt;&lt;code&gt;Err&lt;/code&gt;&lt;/a&gt; is returned with the parameter given to &lt;a href=&quot;../macro.panic&quot;&gt;&lt;code&gt;panic!&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c11de405bba2eb95a67f5ddf98e8d367a826811a" translate="yes" xml:space="preserve">
          <source>If the child thread panics, &lt;a href=&quot;../result/enum.result#variant.Err&quot;&gt;&lt;code&gt;Err&lt;/code&gt;&lt;/a&gt; is returned with the parameter given to &lt;a href=&quot;../macro.panic&quot;&gt;&lt;code&gt;panic&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Если дочерний поток паникует, возвращается &lt;a href=&quot;../result/enum.result#variant.Err&quot;&gt; &lt;code&gt;Err&lt;/code&gt; &lt;/a&gt; с параметром, заданным для &lt;a href=&quot;../macro.panic&quot;&gt; &lt;code&gt;panic&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="611996f7840618a761ac96c392b8f31568d8ec31" translate="yes" xml:space="preserve">
          <source>If the closure can't outlive the value being moved, try using a reference rather than moving:</source>
          <target state="translated">Если закрытие не может перекрыть перемещаемое значение,попробуйте использовать ссылку,а не перемещать:</target>
        </trans-unit>
        <trans-unit id="0f3013a1be5e1908d0fd59aee1eeb2a1559501d9" translate="yes" xml:space="preserve">
          <source>If the closure returns &lt;a href=&quot;../option/enum.option#variant.Some&quot;&gt;&lt;code&gt;Some(element)&lt;/code&gt;&lt;/a&gt;, then that element is returned.</source>
          <target state="translated">Если замыкание возвращает &lt;a href=&quot;../option/enum.option#variant.Some&quot;&gt; &lt;code&gt;Some(element)&lt;/code&gt; &lt;/a&gt; , то возвращается этот элемент.</target>
        </trans-unit>
        <trans-unit id="1cc29c4e531aec77355dc3263edbde0e02717ace" translate="yes" xml:space="preserve">
          <source>If the closure returns true, the element is removed from the map and yielded. If the closure returns false, or panics, the element remains in the map and will not be yielded.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bb67b7c500cdec79f1ce3d7841c806209783608e" translate="yes" xml:space="preserve">
          <source>If the closure returns true, then the element is removed and yielded. If the closure returns false, the element will remain in the list and will not be yielded by the iterator.</source>
          <target state="translated">Если замыкание возвращает true,то элемент удаляется и выходит.Если значение параметра &quot;Закрытие&quot; равно false,то элемент останется в списке и не будет выдан итератором.</target>
        </trans-unit>
        <trans-unit id="6dd010d31dbb3764b4ed75ed86f6e32953c1d0d8" translate="yes" xml:space="preserve">
          <source>If the closure returns true, then the element is removed and yielded. If the closure returns false, the element will remain in the vector and will not be yielded by the iterator.</source>
          <target state="translated">Если замыкание возвращает true,то элемент удаляется и выходит.Если закрытие возвращает false,то элемент останется в векторе и не будет отдан итератором.</target>
        </trans-unit>
        <trans-unit id="2a139e146ec9f48fd19a95af86148618a4801924" translate="yes" xml:space="preserve">
          <source>If the closure returns true, then the value is removed and yielded. If the closure returns false, the value will remain in the list and will not be yielded by the iterator.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="214ba23b863f161492d3f9635dec38066733211c" translate="yes" xml:space="preserve">
          <source>If the contents of the &lt;code&gt;CStr&lt;/code&gt; are valid UTF-8 data, this function will return a &lt;a href=&quot;../borrow/enum.cow&quot;&gt;&lt;code&gt;Cow&lt;/code&gt;&lt;/a&gt;&lt;code&gt;::&lt;/code&gt;&lt;a href=&quot;../borrow/enum.cow#variant.Borrowed&quot;&gt;&lt;code&gt;Borrowed&lt;/code&gt;&lt;/a&gt;&lt;code&gt;(&lt;/code&gt;&lt;a href=&quot;https://doc.rust-lang.org/nightly/std/primitive.str.html&quot;&gt;&lt;code&gt;&amp;amp;str&lt;/code&gt;&lt;/a&gt;&lt;code&gt;)&lt;/code&gt; with the corresponding &lt;a href=&quot;https://doc.rust-lang.org/nightly/std/primitive.str.html&quot;&gt;&lt;code&gt;&amp;amp;str&lt;/code&gt;&lt;/a&gt; slice. Otherwise, it will replace any invalid UTF-8 sequences with &lt;a href=&quot;../char/constant.replacement_character&quot;&gt;&lt;code&gt;U+FFFD REPLACEMENT CHARACTER&lt;/code&gt;&lt;/a&gt; and return a &lt;a href=&quot;../borrow/enum.cow&quot;&gt;&lt;code&gt;Cow&lt;/code&gt;&lt;/a&gt;&lt;code&gt;::&lt;/code&gt;&lt;a href=&quot;../borrow/enum.cow#variant.Owned&quot;&gt;&lt;code&gt;Owned&lt;/code&gt;&lt;/a&gt;&lt;code&gt;(&lt;/code&gt;&lt;a href=&quot;../string/struct.string&quot;&gt;&lt;code&gt;String&lt;/code&gt;&lt;/a&gt;&lt;code&gt;)&lt;/code&gt; with the result.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="31dba64d7d22c597dfce03fd7cdb2b9f96c2ab94" translate="yes" xml:space="preserve">
          <source>If the contents of the &lt;code&gt;CStr&lt;/code&gt; are valid UTF-8 data, this function will return a &lt;a href=&quot;../borrow/enum.cow&quot;&gt;&lt;code&gt;Cow&lt;/code&gt;&lt;/a&gt;&lt;code&gt;::&lt;/code&gt;&lt;a href=&quot;../borrow/enum.cow#variant.Borrowed&quot;&gt;&lt;code&gt;Borrowed&lt;/code&gt;&lt;/a&gt;&lt;code&gt;(&lt;/code&gt;[&lt;code&gt;&amp;amp;str&lt;/code&gt;]&lt;code&gt;)&lt;/code&gt; with the corresponding [&lt;code&gt;&amp;amp;str&lt;/code&gt;] slice. Otherwise, it will replace any invalid UTF-8 sequences with &lt;a href=&quot;../char/constant.replacement_character&quot;&gt;&lt;code&gt;U+FFFD REPLACEMENT CHARACTER&lt;/code&gt;&lt;/a&gt; and return a &lt;a href=&quot;../borrow/enum.cow&quot;&gt;&lt;code&gt;Cow&lt;/code&gt;&lt;/a&gt;&lt;code&gt;::&lt;/code&gt;&lt;a href=&quot;../borrow/enum.cow#variant.Owned&quot;&gt;&lt;code&gt;Owned&lt;/code&gt;&lt;/a&gt;&lt;code&gt;(&lt;/code&gt;&lt;a href=&quot;../string/struct.string&quot;&gt;&lt;code&gt;String&lt;/code&gt;&lt;/a&gt;&lt;code&gt;)&lt;/code&gt; with the result.</source>
          <target state="translated">Если содержимое &lt;code&gt;CStr&lt;/code&gt; является действительными данными UTF-8, эта функция вернет &lt;a href=&quot;../borrow/enum.cow&quot;&gt; &lt;code&gt;Cow&lt;/code&gt; &lt;/a&gt; &lt;code&gt;::&lt;/code&gt; &lt;a href=&quot;../borrow/enum.cow#variant.Borrowed&quot;&gt; &lt;code&gt;Borrowed&lt;/code&gt; &lt;/a&gt; &lt;code&gt;(&lt;/code&gt; [ &lt;code&gt;&amp;amp;str&lt;/code&gt; ] &lt;code&gt;)&lt;/code&gt; с соответствующим срезом [ &lt;code&gt;&amp;amp;str&lt;/code&gt; ]. В противном случае он заменит любые недопустимые последовательности UTF-8 на &lt;a href=&quot;../char/constant.replacement_character&quot;&gt; &lt;code&gt;U+FFFD REPLACEMENT CHARACTER&lt;/code&gt; &lt;/a&gt; и вернет &lt;a href=&quot;../borrow/enum.cow&quot;&gt; &lt;code&gt;Cow&lt;/code&gt; &lt;/a&gt; &lt;code&gt;::&lt;/code&gt; &lt;a href=&quot;../borrow/enum.cow#variant.Owned&quot;&gt; &lt;code&gt;Owned&lt;/code&gt; &lt;/a&gt; &lt;code&gt;(&lt;/code&gt; &lt;a href=&quot;../string/struct.string&quot;&gt; &lt;code&gt;String&lt;/code&gt; &lt;/a&gt; &lt;code&gt;)&lt;/code&gt; с результатом.</target>
        </trans-unit>
        <trans-unit id="db9461413b5ee9b4f01c463f0ad906b75913f24c" translate="yes" xml:space="preserve">
          <source>If the contents of the &lt;code&gt;CStr&lt;/code&gt; are valid UTF-8 data, this function will return the corresponding &lt;a href=&quot;../primitive.str&quot;&gt;&lt;code&gt;&amp;amp;str&lt;/code&gt;&lt;/a&gt; slice. Otherwise, it will return an error with details of where UTF-8 validation failed.</source>
          <target state="translated">Если содержимое &lt;code&gt;CStr&lt;/code&gt; является допустимыми данными UTF-8, эта функция вернет соответствующий фрагмент &lt;a href=&quot;../primitive.str&quot;&gt; &lt;code&gt;&amp;amp;str&lt;/code&gt; &lt;/a&gt; . В противном случае он вернет ошибку с подробной информацией о том, где не удалось выполнить проверку UTF-8.</target>
        </trans-unit>
        <trans-unit id="baae7bb665c0286cfaf2cbea5e20bdf6cf34d67d" translate="yes" xml:space="preserve">
          <source>If the contents of the &lt;code&gt;CStr&lt;/code&gt; are valid UTF-8 data, this function will return the corresponding &lt;a href=&quot;https://doc.rust-lang.org/nightly/std/primitive.str.html&quot;&gt;&lt;code&gt;&amp;amp;str&lt;/code&gt;&lt;/a&gt; slice. Otherwise, it will return an error with details of where UTF-8 validation failed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="99bd91603a025b03597fd1f9cbdd0b5e23a815bb" translate="yes" xml:space="preserve">
          <source>If the corresponding &lt;a href=&quot;struct.sender&quot;&gt;&lt;code&gt;Sender&lt;/code&gt;&lt;/a&gt; has disconnected, or it disconnects while this call is blocking, this call will wake up and return &lt;a href=&quot;../../result/enum.result#variant.Err&quot;&gt;&lt;code&gt;Err&lt;/code&gt;&lt;/a&gt; to indicate that no more messages can ever be received on this channel. However, since channels are buffered, messages sent before the disconnect will still be properly received.</source>
          <target state="translated">Если соответствующий &lt;a href=&quot;struct.sender&quot;&gt; &lt;code&gt;Sender&lt;/code&gt; &lt;/a&gt; отключился или отключился, пока этот вызов блокируется, этот вызов проснется и вернет &lt;a href=&quot;../../result/enum.result#variant.Err&quot;&gt; &lt;code&gt;Err&lt;/code&gt; ,&lt;/a&gt; чтобы указать, что больше сообщений по этому каналу больше не будет. Однако, поскольку каналы буферизированы, сообщения, отправленные до отключения, все равно будут приниматься должным образом.</target>
        </trans-unit>
        <trans-unit id="91ebc4eb9040370bb60e1b55cb245ed551a2b766" translate="yes" xml:space="preserve">
          <source>If the cursor is currently pointing to the &quot;ghost&quot; non-element then no element is removed and &lt;code&gt;None&lt;/code&gt; is returned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4624b3463b579ff38cd7090e939e0664781afc4a" translate="yes" xml:space="preserve">
          <source>If the cursor is pointing at the &quot;ghost&quot; non-element then the entire contents of the &lt;code&gt;LinkedList&lt;/code&gt; are moved.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d335a3b2bd9233a3fbdf7c96e469f75d1c5e365d" translate="yes" xml:space="preserve">
          <source>If the cursor is pointing at the &quot;ghost&quot; non-element then the new element is inserted at the end of the &lt;code&gt;LinkedList&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="31375a5dbf525938d61772845c72aab093fab9cf" translate="yes" xml:space="preserve">
          <source>If the cursor is pointing at the &quot;ghost&quot; non-element then the new element is inserted at the front of the &lt;code&gt;LinkedList&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="58963dd2948fd819f86fd5e461e02e99ecc3a20a" translate="yes" xml:space="preserve">
          <source>If the cursor is pointing at the &quot;ghost&quot; non-element then the new elements are inserted at the end of the &lt;code&gt;LinkedList&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6f945e6d3050ed5d918eb8a5e109487061da86ff" translate="yes" xml:space="preserve">
          <source>If the cursor is pointing at the &quot;ghost&quot; non-element then the new elements are inserted at the start of the &lt;code&gt;LinkedList&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9708432e377fc3315ff2743a227e5ee6ae976fb7" translate="yes" xml:space="preserve">
          <source>If the cursor is pointing to the &quot;ghost&quot; non-element then this returns the first element of the &lt;code&gt;LinkedList&lt;/code&gt;. If it is pointing to the last element of the &lt;code&gt;LinkedList&lt;/code&gt; then this returns &lt;code&gt;None&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a515e2eb729ab1875351c8ecfe7942b25cd004cc" translate="yes" xml:space="preserve">
          <source>If the cursor is pointing to the &quot;ghost&quot; non-element then this returns the last element of the &lt;code&gt;LinkedList&lt;/code&gt;. If it is pointing to the first element of the &lt;code&gt;LinkedList&lt;/code&gt; then this returns &lt;code&gt;None&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a4bf96ffdc655962850c81ce839b17c859f11a67" translate="yes" xml:space="preserve">
          <source>If the cursor is pointing to the &quot;ghost&quot; non-element then this will move it to the first element of the &lt;code&gt;LinkedList&lt;/code&gt;. If it is pointing to the last element of the &lt;code&gt;LinkedList&lt;/code&gt; then this will move it to the &quot;ghost&quot; non-element.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="825c50dec4e26dcdffad5ec9a6866af450b9f9e9" translate="yes" xml:space="preserve">
          <source>If the cursor is pointing to the &quot;ghost&quot; non-element then this will move it to the last element of the &lt;code&gt;LinkedList&lt;/code&gt;. If it is pointing to the first element of the &lt;code&gt;LinkedList&lt;/code&gt; then this will move it to the &quot;ghost&quot; non-element.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c9097bc3fc6399fb3bc83c93071781dffb279d65" translate="yes" xml:space="preserve">
          <source>If the data in this stream is &lt;em&gt;not&lt;/em&gt; valid UTF-8 then an error is returned and &lt;code&gt;buf&lt;/code&gt; is unchanged.</source>
          <target state="translated">Если данные в этом потоке &lt;em&gt;недопустимы в&lt;/em&gt; кодировке UTF-8, возвращается ошибка, а &lt;code&gt;buf&lt;/code&gt; не изменяется.</target>
        </trans-unit>
        <trans-unit id="10754b248a576fdba9d5228dc71f26ade299f007" translate="yes" xml:space="preserve">
          <source>If the definition of &lt;code&gt;foo&lt;/code&gt; is under your control, the simplest solution is to capture the data mutably. This can be done by defining &lt;code&gt;foo&lt;/code&gt; to take FnMut rather than Fn:</source>
          <target state="translated">Если определение &lt;code&gt;foo&lt;/code&gt; находится под вашим контролем, самое простое решение - захватить данные изменчиво. Это можно сделать, определив &lt;code&gt;foo&lt;/code&gt; так, чтобы он принимал FnMut, а не Fn:</target>
        </trans-unit>
        <trans-unit id="42bdc1ae118555b88ae881099abace5a191c0219" translate="yes" xml:space="preserve">
          <source>If the destination type is not part of the current crate then you can't implement &lt;a href=&quot;trait.from&quot;&gt;&lt;code&gt;From&lt;/code&gt;&lt;/a&gt; directly. For example, take this code:</source>
          <target state="translated">Если целевой тип не является частью текущего ящика, вы не можете напрямую реализовать &lt;a href=&quot;trait.from&quot;&gt; &lt;code&gt;From&lt;/code&gt; &lt;/a&gt; . Например, возьмите этот код:</target>
        </trans-unit>
        <trans-unit id="587511482f256e8f952acfee186e5aefae6cf9ca" translate="yes" xml:space="preserve">
          <source>If the determination that the code is unreachable proves incorrect, the program immediately terminates with a &lt;a href=&quot;macro.panic&quot;&gt;&lt;code&gt;panic!&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Если определение, что код недоступен, оказывается неверным, программа немедленно завершает работу с &lt;a href=&quot;macro.panic&quot;&gt; &lt;code&gt;panic!&lt;/code&gt; &lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="4c5ab8621c8a741eb7e90c657432848573f050ef" translate="yes" xml:space="preserve">
          <source>If the element type of the iterator you need does not implement &lt;code&gt;Clone&lt;/code&gt;, or if you do not want to keep the repeated element in memory, you can instead use the &lt;a href=&quot;fn.repeat_with&quot;&gt;&lt;code&gt;repeat_with()&lt;/code&gt;&lt;/a&gt; function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="480ada98c1c5ece146ecdc077a3e40775d89fd0e" translate="yes" xml:space="preserve">
          <source>If the element type of the iterator you need does not implement &lt;code&gt;Clone&lt;/code&gt;, or if you do not want to keep the repeated element in memory, you can instead use the &lt;a href=&quot;fn.repeat_with&quot;&gt;&lt;code&gt;repeat_with&lt;/code&gt;&lt;/a&gt; function.</source>
          <target state="translated">Если тип элемента итератора, который вам нужен, не реализует &lt;code&gt;Clone&lt;/code&gt; , или если вы не хотите сохранять повторяющийся элемент в памяти, вы можете вместо этого использовать функцию &lt;a href=&quot;fn.repeat_with&quot;&gt; &lt;code&gt;repeat_with&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="156fcf0995b1088c12c501a80ad16ba6aab2c6f4" translate="yes" xml:space="preserve">
          <source>If the element type of the iterator you need implements &lt;a href=&quot;../clone/trait.clone&quot;&gt;&lt;code&gt;Clone&lt;/code&gt;&lt;/a&gt;, and it is OK to keep the source element in memory, you should instead use the &lt;a href=&quot;fn.repeat&quot;&gt;&lt;code&gt;repeat()&lt;/code&gt;&lt;/a&gt; function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3b5563e722ef79a66827ad237de3ff713088f72a" translate="yes" xml:space="preserve">
          <source>If the element type of the iterator you need implements &lt;code&gt;Clone&lt;/code&gt;, and it is OK to keep the source element in memory, you should instead use the &lt;a href=&quot;fn.repeat&quot;&gt;&lt;code&gt;repeat&lt;/code&gt;&lt;/a&gt; function.</source>
          <target state="translated">Если тип элемента итератора, который вам нужен, реализует &lt;code&gt;Clone&lt;/code&gt; , и можно оставить исходный элемент в памяти, вам следует вместо этого использовать функцию &lt;a href=&quot;fn.repeat&quot;&gt; &lt;code&gt;repeat&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="fdfbdf49a01ecb81ac4dd4acab163dbc68e7e8c0" translate="yes" xml:space="preserve">
          <source>If the environment variable is not defined, then a compilation error will be emitted. To not emit a compile error, use the &lt;a href=&quot;macro.option_env&quot;&gt;&lt;code&gt;option_env!&lt;/code&gt;&lt;/a&gt; macro instead.</source>
          <target state="translated">Если переменная среды не определена, будет выдана ошибка компиляции. Чтобы не &lt;a href=&quot;macro.option_env&quot;&gt; &lt;code&gt;option_env!&lt;/code&gt; &lt;/a&gt; ошибку компиляции, используйте option_env! макрос вместо этого.</target>
        </trans-unit>
        <trans-unit id="6e8972418288b27e60b8fafe88d7c99a7d59e984" translate="yes" xml:space="preserve">
          <source>If the executable was invoked through a symbolic link, some platforms will return the path of the symbolic link and other platforms will return the path of the symbolic link&amp;rsquo;s target.</source>
          <target state="translated">Если исполняемый файл был вызван через символическую ссылку, некоторые платформы вернут путь символьной ссылки, а другие платформы вернут путь к цели символической ссылки.</target>
        </trans-unit>
        <trans-unit id="fd55e486394dd1866434bdc5faf39742bfb2a2d4" translate="yes" xml:space="preserve">
          <source>If the expression in one of these coercion sites is a coercion-propagating expression, then the relevant sub-expressions in that expression are also coercion sites. Propagation recurses from these new coercion sites. Propagating expressions and their relevant sub-expressions are:</source>
          <target state="translated">Если выражение в одном из этих сайтов принуждения является выражением,распространяющим принуждение,то соответствующие подвыражения в этом выражении также являются сайтами принуждения.Распространение возвращается из этих новых сайтов принуждения.Распространение и их соответствующие подвыражения являются:</target>
        </trans-unit>
        <trans-unit id="da06749df21ae19d99c10837b4fef8698354acfb" translate="yes" xml:space="preserve">
          <source>If the feature is accepted, an issue is opened on the Rust repository, and someone can implement it. The person who implements it very well may not be the person who proposed the feature in the first place! When the implementation is ready, it lands on the &lt;code&gt;master&lt;/code&gt; branch behind a feature gate, as we discussed in the &lt;a href=&quot;#unstable-features&quot;&gt;&amp;ldquo;Unstable Features&amp;rdquo;&lt;/a&gt; section.</source>
          <target state="translated">Если функция будет принята, проблема будет открыта в репозитории Rust, и кто-то сможет ее реализовать. Человек, который очень хорошо ее реализует, может быть не человеком, который предложил эту функцию в первую очередь! Когда реализация готова, она попадает в &lt;code&gt;master&lt;/code&gt; ветвь за воротами функций, как мы обсуждали в разделе &lt;a href=&quot;#unstable-features&quot;&gt;&amp;laquo;Нестабильные функции&amp;raquo;&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="3414a33407bd3dac73209f0f3c8c87238661b1ca" translate="yes" xml:space="preserve">
          <source>If the file already exists, any write calls on it will overwrite its contents, without truncating it.</source>
          <target state="translated">Если файл уже существует,любой вызов записи на него перезапишет его содержимое,не усекая его.</target>
        </trans-unit>
        <trans-unit id="9132b3e3ab7219a34cb586c6f14321ce888d6773" translate="yes" xml:space="preserve">
          <source>If the first element is matched, an empty slice will be the first item returned by the iterator. Similarly, if the last element in the slice is matched, an empty slice will be the last item returned by the iterator:</source>
          <target state="translated">Если первый элемент совпадает,то первым возвращаемым итератором будет пустой кусок.Аналогично,если последний элемент в ломтике совпадает,пустой ломтик будет последним элементом,возвращенным итератором:</target>
        </trans-unit>
        <trans-unit id="a3fd11d96e62e4df934fdc1fa4662261ba86625c" translate="yes" xml:space="preserve">
          <source>If the given capacity is &lt;code&gt;0&lt;/code&gt;, no allocation will occur, and this method is identical to the &lt;a href=&quot;#method.new&quot;&gt;&lt;code&gt;new&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">Если заданная емкость равна &lt;code&gt;0&lt;/code&gt; , выделения не произойдет, и этот метод идентичен &lt;a href=&quot;#method.new&quot;&gt; &lt;code&gt;new&lt;/code&gt; &lt;/a&gt; методу.</target>
        </trans-unit>
        <trans-unit id="c71e4086428a9289ae6841638f980514baf4e1e2" translate="yes" xml:space="preserve">
          <source>If the given capacity is &lt;code&gt;0&lt;/code&gt;, no allocation will occur, and this method is identical to the &lt;a href=&quot;struct.string#method.new&quot;&gt;&lt;code&gt;new&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c23f42fcc2aeb440c3d587979f6b3a221b95c0ef" translate="yes" xml:space="preserve">
          <source>If the given closure recursively invokes &lt;code&gt;call_once&lt;/code&gt; on the same &lt;a href=&quot;struct.once&quot;&gt;&lt;code&gt;Once&lt;/code&gt;&lt;/a&gt; instance the exact behavior is not specified, allowed outcomes are a panic or a deadlock.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3e650fcb37c79e73b248840291059fa9ab82facc" translate="yes" xml:space="preserve">
          <source>If the given closure recursively invokes &lt;code&gt;call_once&lt;/code&gt; on the same &lt;code&gt;Once&lt;/code&gt; instance the exact behavior is not specified, allowed outcomes are a panic or a deadlock.</source>
          <target state="translated">Если данное закрытие рекурсивно вызывает &lt;code&gt;call_once&lt;/code&gt; в том же экземпляре &lt;code&gt;Once&lt;/code&gt; , точное поведение не указано, допустимые результаты - паника или тупик.</target>
        </trans-unit>
        <trans-unit id="82cd743013a3edab20be44d34d8b246c9798bdd1" translate="yes" xml:space="preserve">
          <source>If the input isn't NaN, then there is no portability concern.</source>
          <target state="translated">Если на входе нет NaN,значит,нет проблем с переносимостью.</target>
        </trans-unit>
        <trans-unit id="678a91cbb4ec06d73442b77832f91bad809fe51b" translate="yes" xml:space="preserve">
          <source>If the item is a function, you may use a closure:</source>
          <target state="translated">Если элемент является функцией,можно использовать закрытие:</target>
        </trans-unit>
        <trans-unit id="3955594d420a5299baca31b21b74e398d9cdcfd9" translate="yes" xml:space="preserve">
          <source>If the item is modified then the worst case time complexity is &lt;em&gt;O&lt;/em&gt;(log(&lt;em&gt;n&lt;/em&gt;)), otherwise it's &lt;em&gt;O&lt;/em&gt;(1).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4e29e02642c9eb9601c44c59f05b7d126f43b3f4" translate="yes" xml:space="preserve">
          <source>If the item is not defined in the current module, it must be imported using a &lt;code&gt;use&lt;/code&gt; statement, like so:</source>
          <target state="translated">Если элемент не определен в текущем модуле, он должен быть импортирован с &lt;code&gt;use&lt;/code&gt; оператора use , например:</target>
        </trans-unit>
        <trans-unit id="5030e30e9a190114fd41d37b0c1ba92d9eec8bbd" translate="yes" xml:space="preserve">
          <source>If the item you are importing is not defined in some super-module of the current module, then it must also be declared as public (e.g., &lt;code&gt;pub fn&lt;/code&gt;).</source>
          <target state="translated">Если элемент, который вы импортируете, не определен в каком-либо супермодуле текущего модуля, он также должен быть объявлен как общедоступный (например, &lt;code&gt;pub fn&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="719a1576fd9e7210e99462a559c7958169595ce7" translate="yes" xml:space="preserve">
          <source>If the iterator is only partially consumed or not consumed at all, each of the remaining elements will still be subjected to the closure and removed and dropped if it returns true.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e4d63a01b8d322a8870de0053bcaa4759ed12bae" translate="yes" xml:space="preserve">
          <source>If the iterator is only partially consumed or not consumed at all, each of the remaining values will still be subjected to the closure and removed and dropped if it returns true.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fc64622999ffaef4c074c0b3f6d2b93d8dbc840b" translate="yes" xml:space="preserve">
          <source>If the last element of the slice is matched, that element will be considered the terminator of the preceding slice. That slice will be the last item returned by the iterator.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="46e75edbffb14b1f9cbe211ae39152c93cbfb5b3" translate="yes" xml:space="preserve">
          <source>If the last element of the string is matched, that element will be considered the terminator of the preceding substring. That substring will be the last item returned by the iterator.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6c2eb24f388c4f9da46dc55e06c2973845737ad4" translate="yes" xml:space="preserve">
          <source>If the length doesn't match, the input comes back in &lt;code&gt;Err&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c7f0b78af6a1f2b8da54724cc60c89fb090afb8c" translate="yes" xml:space="preserve">
          <source>If the lifetime of a reference isn't enough, such as in the case of threading, consider using an &lt;code&gt;Arc&lt;/code&gt; to create a reference-counted value:</source>
          <target state="translated">Если времени жизни ссылки недостаточно, например, в случае многопоточности, рассмотрите возможность использования &lt;code&gt;Arc&lt;/code&gt; для создания значения с подсчетом ссылок:</target>
        </trans-unit>
        <trans-unit id="0e305a8484a9cd9dc5c8361f54c572219ec9804c" translate="yes" xml:space="preserve">
          <source>If the lock could not be acquired at this time, then &lt;a href=&quot;../result/enum.result#variant.Err&quot;&gt;&lt;code&gt;Err&lt;/code&gt;&lt;/a&gt; is returned. Otherwise, an RAII guard is returned. The lock will be unlocked when the guard is dropped.</source>
          <target state="translated">Если блокировку в это время получить не удалось, возвращается &lt;a href=&quot;../result/enum.result#variant.Err&quot;&gt; &lt;code&gt;Err&lt;/code&gt; &lt;/a&gt; . В противном случае возвращается защита RAII. Замок будет разблокирован при снятии ограждения.</target>
        </trans-unit>
        <trans-unit id="f8b222d65f3e5a011a407bdb03d5df29adfec456" translate="yes" xml:space="preserve">
          <source>If the lock could not be acquired at this time, then &lt;code&gt;Err&lt;/code&gt; is returned. Otherwise, an RAII guard is returned which will release the lock when it is dropped.</source>
          <target state="translated">Если блокировку в это время получить не удалось, возвращается &lt;code&gt;Err&lt;/code&gt; . В противном случае возвращается защита RAII, которая снимает блокировку при ее сбросе.</target>
        </trans-unit>
        <trans-unit id="ecf781a8afe2a0c63a1d40b96befbc6c4dce088d" translate="yes" xml:space="preserve">
          <source>If the main thread panics it will terminate all your threads and end your program with code &lt;code&gt;101&lt;/code&gt;.</source>
          <target state="translated">Если основной поток паникует, он завершит все ваши потоки и завершит вашу программу с кодом &lt;code&gt;101&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="fedf3b811ad1f7726933bad19dd231acecc809fc" translate="yes" xml:space="preserve">
          <source>If the map did have this key present, the value is updated, and the old value is returned. The key is not updated, though; this matters for types that can be &lt;code&gt;==&lt;/code&gt; without being identical. See the &lt;a href=&quot;../index#insert-and-complex-keys&quot;&gt;module-level documentation&lt;/a&gt; for more.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d96d894c9cb755e3982e02a5fa557e27c759b559" translate="yes" xml:space="preserve">
          <source>If the map did have this key present, the value is updated, and the old value is returned. The key is not updated, though; this matters for types that can be &lt;code&gt;==&lt;/code&gt; without being identical. See the &lt;a href=&quot;index#insert-and-complex-keys&quot;&gt;module-level documentation&lt;/a&gt; for more.</source>
          <target state="translated">Если на карте действительно присутствовал этот ключ, значение обновляется и возвращается старое значение. Однако ключ не обновляется; это имеет значение для типов, которые могут быть &lt;code&gt;==&lt;/code&gt; , но не идентичны. Дополнительную информацию см. В &lt;a href=&quot;index#insert-and-complex-keys&quot;&gt;документации&lt;/a&gt; на уровне модуля .</target>
        </trans-unit>
        <trans-unit id="a660d0d730c1d18357284ffbb42b24c56c1fea09" translate="yes" xml:space="preserve">
          <source>If the map did not have this key present, &lt;a href=&quot;../../option/enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt; is returned.</source>
          <target state="translated">Если на карте не было этого ключа, возвращается &lt;a href=&quot;../../option/enum.option#variant.None&quot;&gt; &lt;code&gt;None&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="22fc8ad8eb7527fa9d4557d1bcf87a2d2bd7edcb" translate="yes" xml:space="preserve">
          <source>If the map did not have this key present, &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt; is returned.</source>
          <target state="translated">Если на карте не было этого ключа, возвращается &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt; &lt;code&gt;None&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="ce6ece3326d8becac91cb49d0dcc5a346e703bba" translate="yes" xml:space="preserve">
          <source>If the map did not have this key present, &lt;code&gt;None&lt;/code&gt; is returned.</source>
          <target state="translated">Если на карте не было этого ключа, возвращается &lt;code&gt;None&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c00b93ea8ff90e66022ac61d150c9d932705572a" translate="yes" xml:space="preserve">
          <source>If the named environment variable is present at compile time, this will expand into an expression of type &lt;code&gt;Option&amp;lt;&amp;amp;'static str&amp;gt;&lt;/code&gt; whose value is &lt;code&gt;Some&lt;/code&gt; of the value of the environment variable. If the environment variable is not present, then this will expand to &lt;code&gt;None&lt;/code&gt;. See &lt;a href=&quot;option/enum.option&quot;&gt;&lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt; for more information on this type.</source>
          <target state="translated">Если переменная среды с именем присутствует во время компиляции, это будет расширяться в выражение типа &lt;code&gt;Option&amp;lt;&amp;amp;'static str&amp;gt;&lt;/code&gt; , значение которого &lt;code&gt;Some&lt;/code&gt; значения переменной окружения. Если переменная среды отсутствует, она будет заменена на &lt;code&gt;None&lt;/code&gt; . См. &lt;a href=&quot;option/enum.option&quot;&gt; &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt; &lt;/a&gt; для получения дополнительной информации об этом типе.</target>
        </trans-unit>
        <trans-unit id="a6575b526f3c9f6ff8f51c0abc90eb128dc80c26" translate="yes" xml:space="preserve">
          <source>If the number of elements in the pattern doesn&amp;rsquo;t match the number of elements in the tuple, the overall type won&amp;rsquo;t match and we&amp;rsquo;ll get a compiler error. For example, Listing 18-5 shows an attempt to destructure a tuple with three elements into two variables, which won&amp;rsquo;t work.</source>
          <target state="translated">Если количество элементов в шаблоне не соответствует количеству элементов в кортеже, общий тип не будет совпадать, и мы получим ошибку компилятора. Например, в листинге 18-5 показана попытка деструктурировать кортеж с тремя элементами на две переменные, которая не сработает.</target>
        </trans-unit>
        <trans-unit id="0d2c1202b42295052cad83d3a70ac58e5c8cc86e" translate="yes" xml:space="preserve">
          <source>If the number of hardware threads is not known for the target platform.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d5f255ea3f66f81885c9b2fd50418cdf94440a9b" translate="yes" xml:space="preserve">
          <source>If the number of nanoseconds is greater than 1 billion (the number of nanoseconds in a second), then it will carry over into the seconds provided.</source>
          <target state="translated">Если количество наносекунд больше 1 миллиарда (количество наносекунд в секунду),то оно переносится на предоставленные секунды.</target>
        </trans-unit>
        <trans-unit id="c7b893dcc899fca09569911e017ff49f116f8bab" translate="yes" xml:space="preserve">
          <source>If the option already contains a value, the old value is dropped.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7587948fbc56d5936df283dc95c30a87905bc378" translate="yes" xml:space="preserve">
          <source>If the path is a normal file, this is the file name. If it's the path of a directory, this is the directory name.</source>
          <target state="translated">Если путь-обычный файл,то это имя файла.Если это путь к директории,то это имя директории.</target>
        </trans-unit>
        <trans-unit id="a7ef120bc4e6081962026d321af347e6c4f9a831" translate="yes" xml:space="preserve">
          <source>If the pattern allows a reverse search but its results might differ from a forward search, the &lt;a href=&quot;#method.rmatch_indices&quot;&gt;&lt;code&gt;rmatch_indices&lt;/code&gt;&lt;/a&gt; method can be used.</source>
          <target state="translated">Если шаблон допускает обратный поиск, но его результаты могут отличаться от прямого поиска, можно использовать метод &lt;a href=&quot;#method.rmatch_indices&quot;&gt; &lt;code&gt;rmatch_indices&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="04680e781abdf689365df53a980b052d9694289c" translate="yes" xml:space="preserve">
          <source>If the pattern allows a reverse search but its results might differ from a forward search, the &lt;a href=&quot;#method.rmatches&quot;&gt;&lt;code&gt;rmatches&lt;/code&gt;&lt;/a&gt; method can be used.</source>
          <target state="translated">Если шаблон допускает обратный поиск, но его результаты могут отличаться от прямого поиска, можно использовать метод &lt;a href=&quot;#method.rmatches&quot;&gt; &lt;code&gt;rmatches&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="fdde1b4f273f0ed1e791a6fe885f57ab847c6655" translate="yes" xml:space="preserve">
          <source>If the pattern allows a reverse search but its results might differ from a forward search, the &lt;a href=&quot;#method.rsplit&quot;&gt;&lt;code&gt;rsplit&lt;/code&gt;&lt;/a&gt; method can be used.</source>
          <target state="translated">Если шаблон допускает обратный поиск, но его результаты могут отличаться от прямого поиска, можно использовать метод &lt;a href=&quot;#method.rsplit&quot;&gt; &lt;code&gt;rsplit&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="7628f0f92ea01c70ac165a6fae25950d70760fc1" translate="yes" xml:space="preserve">
          <source>If the pattern allows a reverse search but its results might differ from a forward search, the &lt;a href=&quot;#method.rsplit_terminator&quot;&gt;&lt;code&gt;rsplit_terminator&lt;/code&gt;&lt;/a&gt; method can be used.</source>
          <target state="translated">Если шаблон допускает обратный поиск, но его результаты могут отличаться от прямого поиска, можно использовать метод &lt;a href=&quot;#method.rsplit_terminator&quot;&gt; &lt;code&gt;rsplit_terminator&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="7b1dfc3434853d3f01995d02cf2021fd9cea4f38" translate="yes" xml:space="preserve">
          <source>If the pattern allows a reverse search but its results might differ from a forward search, the &lt;a href=&quot;../primitive.str#method.match_indices&quot;&gt;&lt;code&gt;rmatch_indices&lt;/code&gt;&lt;/a&gt; method can be used.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ec2b2d41067456cd5ce092b8da0d00cd9c018667" translate="yes" xml:space="preserve">
          <source>If the pattern allows a reverse search but its results might differ from a forward search, the &lt;a href=&quot;../primitive.str#method.matches&quot;&gt;&lt;code&gt;rmatches&lt;/code&gt;&lt;/a&gt; method can be used.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aa780fe3ad5330a6d715d8c1d30bd41ddfacfc03" translate="yes" xml:space="preserve">
          <source>If the pattern allows a reverse search but its results might differ from a forward search, the &lt;a href=&quot;../primitive.str#method.rsplit&quot;&gt;&lt;code&gt;rsplit&lt;/code&gt;&lt;/a&gt; method can be used.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4b8ae88e59c6bfa2a36b4a334a350ee9f55b8244" translate="yes" xml:space="preserve">
          <source>If the pattern allows a reverse search but its results might differ from a forward search, the &lt;a href=&quot;../primitive.str#method.rsplit_terminator&quot;&gt;&lt;code&gt;rsplit_terminator&lt;/code&gt;&lt;/a&gt; method can be used.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8bcaec8982083667c5c84f44fc799e4d051fed01" translate="yes" xml:space="preserve">
          <source>If the pattern allows a reverse search but its results might differ from a forward search, the &lt;a href=&quot;primitive.str#method.match_indices&quot;&gt;&lt;code&gt;rmatch_indices&lt;/code&gt;&lt;/a&gt; method can be used.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e9c97ecf08e8a57f300f06fbed8336fddc8673ad" translate="yes" xml:space="preserve">
          <source>If the pattern allows a reverse search but its results might differ from a forward search, the &lt;a href=&quot;primitive.str#method.matches&quot;&gt;&lt;code&gt;rmatches&lt;/code&gt;&lt;/a&gt; method can be used.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8b3f51e25e82602ab5224623c59019342d6d26f3" translate="yes" xml:space="preserve">
          <source>If the pattern allows a reverse search but its results might differ from a forward search, the &lt;a href=&quot;primitive.str#method.rsplit&quot;&gt;&lt;code&gt;rsplit&lt;/code&gt;&lt;/a&gt; method can be used.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="75ae87480dd359d1fa21ebc1f6510a38a90b5d25" translate="yes" xml:space="preserve">
          <source>If the pattern allows a reverse search but its results might differ from a forward search, the &lt;a href=&quot;primitive.str#method.rsplit_terminator&quot;&gt;&lt;code&gt;rsplit_terminator&lt;/code&gt;&lt;/a&gt; method can be used.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="02eda760b5bfe240d7c8b8f222a4d4b7100d666e" translate="yes" xml:space="preserve">
          <source>If the pattern allows a reverse search, the &lt;a href=&quot;#method.rsplitn&quot;&gt;&lt;code&gt;rsplitn&lt;/code&gt;&lt;/a&gt; method can be used.</source>
          <target state="translated">Если шаблон допускает обратный поиск, можно использовать метод &lt;a href=&quot;#method.rsplitn&quot;&gt; &lt;code&gt;rsplitn&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="13381a81af44ee23cac490ae25db16aaac796d46" translate="yes" xml:space="preserve">
          <source>If the pattern allows a reverse search, the &lt;a href=&quot;../primitive.str#method.rsplitn&quot;&gt;&lt;code&gt;rsplitn&lt;/code&gt;&lt;/a&gt; method can be used.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a0dc4aae442a85b53102b885d478be980f7d8acb" translate="yes" xml:space="preserve">
          <source>If the pattern allows a reverse search, the &lt;a href=&quot;primitive.str#method.rsplitn&quot;&gt;&lt;code&gt;rsplitn&lt;/code&gt;&lt;/a&gt; method can be used.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="41f3c654ebe17619521d5571a243149ab252e55c" translate="yes" xml:space="preserve">
          <source>If the pattern in a &lt;code&gt;let&lt;/code&gt; statement is an extending pattern then the temporary scope of the initializer expression is extended.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a9d4003e7c8cd37da9426d5d4d889d3aaff32c4e" translate="yes" xml:space="preserve">
          <source>If the predicate is true, the thing is rewritten to not have the &lt;code&gt;cfg&lt;/code&gt; attribute on it. If the predicate is false, the thing is removed from the source code.</source>
          <target state="translated">Если предикат истинен, вещь переписывается, чтобы на ней не было атрибута &lt;code&gt;cfg&lt;/code&gt; . Если предикат ложен, вещь удаляется из исходного кода.</target>
        </trans-unit>
        <trans-unit id="9ddbcce981c839ba50c36650f18e74f28c3996cc" translate="yes" xml:space="preserve">
          <source>If the process was terminated by a signal, returns that signal.</source>
          <target state="translated">Если процесс был прерван сигналом,возвращает этот сигнал.</target>
        </trans-unit>
        <trans-unit id="12b3054a5c2c9f1f42244cb5633baa4905430f09" translate="yes" xml:space="preserve">
          <source>If the program context over-constrains the type, it is considered a static type error.</source>
          <target state="translated">Если контекст программы переопределяет тип,то это считается статической ошибкой типа.</target>
        </trans-unit>
        <trans-unit id="0342ae828ad12df97309a477cf872adf919b1902" translate="yes" xml:space="preserve">
          <source>If the program context under-constrains the type, it defaults to &lt;code&gt;f64&lt;/code&gt;.</source>
          <target state="translated">Если контекст программы не ограничивает тип, по умолчанию используется &lt;code&gt;f64&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9c5273dc0a13c7cc0e077b4b3fa98da50edca969" translate="yes" xml:space="preserve">
          <source>If the program context under-constrains the type, it defaults to the signed 32-bit integer &lt;code&gt;i32&lt;/code&gt;.</source>
          <target state="translated">Если контекст программы не ограничивает тип, по умолчанию используется 32-битное целое число со &lt;code&gt;i32&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="46f99ab4b433b6230008eadc71e11c58b7b1e70b" translate="yes" xml:space="preserve">
          <source>If the program path is relative (e.g., &lt;code&gt;&quot;./script.sh&quot;&lt;/code&gt;), it's ambiguous whether it should be interpreted relative to the parent's working directory or relative to &lt;code&gt;current_dir&lt;/code&gt;. The behavior in this case is platform specific and unstable, and it's recommended to use &lt;a href=&quot;../fs/fn.canonicalize&quot;&gt;&lt;code&gt;canonicalize&lt;/code&gt;&lt;/a&gt; to get an absolute program path instead.</source>
          <target state="translated">Если путь к программе относительный (например, &lt;code&gt;&quot;./script.sh&quot;&lt;/code&gt; ), неясно, следует ли его интерпретировать относительно рабочего каталога родителя или относительно &lt;code&gt;current_dir&lt;/code&gt; . Поведение в этом случае зависит от платформы и нестабильно, и вместо этого рекомендуется использовать &lt;a href=&quot;../fs/fn.canonicalize&quot;&gt; &lt;code&gt;canonicalize&lt;/code&gt; ,&lt;/a&gt; чтобы получить абсолютный путь к программе.</target>
        </trans-unit>
        <trans-unit id="5f463c42ca012031b77b1b6ba6bda1bbf7d242ce" translate="yes" xml:space="preserve">
          <source>If the provided value is &lt;a href=&quot;../../../option/enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt;, then &lt;a href=&quot;#method.recv&quot;&gt;&lt;code&gt;recv&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#method.recv_from&quot;&gt;&lt;code&gt;recv_from&lt;/code&gt;&lt;/a&gt; calls will block indefinitely. An &lt;a href=&quot;../../../result/enum.result#variant.Err&quot;&gt;&lt;code&gt;Err&lt;/code&gt;&lt;/a&gt; is returned if the zero &lt;a href=&quot;../../../time/struct.duration&quot;&gt;&lt;code&gt;Duration&lt;/code&gt;&lt;/a&gt; is passed to this method.</source>
          <target state="translated">Если предоставлено значение &lt;a href=&quot;../../../option/enum.option#variant.None&quot;&gt; &lt;code&gt;None&lt;/code&gt; &lt;/a&gt; , вызовы &lt;a href=&quot;#method.recv&quot;&gt; &lt;code&gt;recv&lt;/code&gt; &lt;/a&gt; и &lt;a href=&quot;#method.recv_from&quot;&gt; &lt;code&gt;recv_from&lt;/code&gt; &lt;/a&gt; будут блокироваться на неопределенный срок. &lt;a href=&quot;../../../result/enum.result#variant.Err&quot;&gt; &lt;code&gt;Err&lt;/code&gt; &lt;/a&gt; возвращается , если нулевой &lt;a href=&quot;../../../time/struct.duration&quot;&gt; &lt;code&gt;Duration&lt;/code&gt; &lt;/a&gt; передается этому методу.</target>
        </trans-unit>
        <trans-unit id="27457ae3a7ce774b0ba53e72b68851ec71f67265" translate="yes" xml:space="preserve">
          <source>If the provided value is &lt;a href=&quot;../../../option/enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt;, then &lt;a href=&quot;#method.send&quot;&gt;&lt;code&gt;send&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#method.send_to&quot;&gt;&lt;code&gt;send_to&lt;/code&gt;&lt;/a&gt; calls will block indefinitely. An &lt;a href=&quot;../../../result/enum.result#Err.v&quot;&gt;&lt;code&gt;Err&lt;/code&gt;&lt;/a&gt; is returned if the zero &lt;a href=&quot;../../../time/struct.duration&quot;&gt;&lt;code&gt;Duration&lt;/code&gt;&lt;/a&gt; is passed to this method.</source>
          <target state="translated">Если предоставленное значение равно &lt;a href=&quot;../../../option/enum.option#variant.None&quot;&gt; &lt;code&gt;None&lt;/code&gt; &lt;/a&gt; , то вызовы &lt;a href=&quot;#method.send&quot;&gt; &lt;code&gt;send&lt;/code&gt; &lt;/a&gt; и &lt;a href=&quot;#method.send_to&quot;&gt; &lt;code&gt;send_to&lt;/code&gt; &lt;/a&gt; будут блокироваться на неопределенный срок. &lt;a href=&quot;../../../result/enum.result#Err.v&quot;&gt; &lt;code&gt;Err&lt;/code&gt; &lt;/a&gt; возвращается , если нулевой &lt;a href=&quot;../../../time/struct.duration&quot;&gt; &lt;code&gt;Duration&lt;/code&gt; &lt;/a&gt; передается этому методу.</target>
        </trans-unit>
        <trans-unit id="a1795e7946ced7825121511cc106a9015fd798ec" translate="yes" xml:space="preserve">
          <source>If the provided value is &lt;a href=&quot;../../../option/enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt;, then &lt;a href=&quot;../../../io/trait.read#tymethod.read&quot;&gt;&lt;code&gt;read&lt;/code&gt;&lt;/a&gt; calls will block indefinitely. An &lt;a href=&quot;../../../result/enum.result#variant.Err&quot;&gt;&lt;code&gt;Err&lt;/code&gt;&lt;/a&gt; is returned if the zero &lt;a href=&quot;../../../time/struct.duration&quot;&gt;&lt;code&gt;Duration&lt;/code&gt;&lt;/a&gt; is passed to this method.</source>
          <target state="translated">Если предоставленное значение - &lt;a href=&quot;../../../option/enum.option#variant.None&quot;&gt; &lt;code&gt;None&lt;/code&gt; &lt;/a&gt; , тогда вызовы &lt;a href=&quot;../../../io/trait.read#tymethod.read&quot;&gt; &lt;code&gt;read&lt;/code&gt; &lt;/a&gt; будут блокироваться на неопределенный срок. &lt;a href=&quot;../../../result/enum.result#variant.Err&quot;&gt; &lt;code&gt;Err&lt;/code&gt; &lt;/a&gt; возвращается , если нулевой &lt;a href=&quot;../../../time/struct.duration&quot;&gt; &lt;code&gt;Duration&lt;/code&gt; &lt;/a&gt; передается этому методу.</target>
        </trans-unit>
        <trans-unit id="e1ea6f1309304cb111df61243a566c96b67b3b82" translate="yes" xml:space="preserve">
          <source>If the provided value is &lt;a href=&quot;../../../option/enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt;, then &lt;a href=&quot;../../../io/trait.write#tymethod.write&quot;&gt;&lt;code&gt;write&lt;/code&gt;&lt;/a&gt; calls will block indefinitely. An &lt;a href=&quot;../../../result/enum.result#variant.Err&quot;&gt;&lt;code&gt;Err&lt;/code&gt;&lt;/a&gt; is returned if the zero &lt;a href=&quot;../../../time/struct.duration&quot;&gt;&lt;code&gt;Duration&lt;/code&gt;&lt;/a&gt; is passed to this method.</source>
          <target state="translated">Если предоставленное значение равно &lt;a href=&quot;../../../option/enum.option#variant.None&quot;&gt; &lt;code&gt;None&lt;/code&gt; &lt;/a&gt; , то вызовы &lt;a href=&quot;../../../io/trait.write#tymethod.write&quot;&gt; &lt;code&gt;write&lt;/code&gt; &lt;/a&gt; будут блокироваться на неопределенный срок. &lt;a href=&quot;../../../result/enum.result#variant.Err&quot;&gt; &lt;code&gt;Err&lt;/code&gt; &lt;/a&gt; возвращается , если нулевой &lt;a href=&quot;../../../time/struct.duration&quot;&gt; &lt;code&gt;Duration&lt;/code&gt; &lt;/a&gt; передается этому методу.</target>
        </trans-unit>
        <trans-unit id="3030eaafa081102fe45631b54a8872f8838c162b" translate="yes" xml:space="preserve">
          <source>If the provided value is &lt;a href=&quot;../../../option/enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt;, then &lt;a href=&quot;../../../macro.write&quot;&gt;&lt;code&gt;write&lt;/code&gt;&lt;/a&gt; calls will block indefinitely. An &lt;a href=&quot;../../../result/enum.result#variant.Err&quot;&gt;&lt;code&gt;Err&lt;/code&gt;&lt;/a&gt; is returned if the zero &lt;a href=&quot;../../../time/struct.duration&quot;&gt;&lt;code&gt;Duration&lt;/code&gt;&lt;/a&gt; is passed to this method.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8e6460df1e81820998680e8eea34159effdca0c0" translate="yes" xml:space="preserve">
          <source>If the provided value is &lt;a href=&quot;../../../option/enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt;, then &lt;a href=&quot;struct.unixdatagram#method.recv&quot;&gt;&lt;code&gt;recv&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;struct.unixdatagram#method.recv_from&quot;&gt;&lt;code&gt;recv_from&lt;/code&gt;&lt;/a&gt; calls will block indefinitely. An &lt;a href=&quot;../../../result/enum.result#variant.Err&quot;&gt;&lt;code&gt;Err&lt;/code&gt;&lt;/a&gt; is returned if the zero &lt;a href=&quot;../../../time/struct.duration&quot;&gt;&lt;code&gt;Duration&lt;/code&gt;&lt;/a&gt; is passed to this method.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6ee71bcd622cfb4833d8d1ba25909dd1554f21bc" translate="yes" xml:space="preserve">
          <source>If the provided value is &lt;a href=&quot;../../../option/enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt;, then &lt;a href=&quot;struct.unixdatagram#method.send&quot;&gt;&lt;code&gt;send&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;struct.unixdatagram#method.send_to&quot;&gt;&lt;code&gt;send_to&lt;/code&gt;&lt;/a&gt; calls will block indefinitely. An &lt;a href=&quot;../../../result/enum.result#variant.Err&quot;&gt;&lt;code&gt;Err&lt;/code&gt;&lt;/a&gt; is returned if the zero &lt;a href=&quot;../../../time/struct.duration&quot;&gt;&lt;code&gt;Duration&lt;/code&gt;&lt;/a&gt; is passed to this method.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="02ca5c816748f7e2bf4c21dd7d1f2eac8980aece" translate="yes" xml:space="preserve">
          <source>If the receiver has type &lt;code&gt;&amp;amp;Self&lt;/code&gt; or &lt;code&gt;&amp;amp;mut Self&lt;/code&gt;, then the lifetime of that reference to &lt;code&gt;Self&lt;/code&gt; is assigned to all elided output lifetime parameters.</source>
          <target state="translated">Если получатель имеет тип &lt;code&gt;&amp;amp;Self&lt;/code&gt; или &lt;code&gt;&amp;amp;mut Self&lt;/code&gt; , то время жизни этой ссылки на &lt;code&gt;Self&lt;/code&gt; присваивается всем исключенным параметрам времени жизни вывода.</target>
        </trans-unit>
        <trans-unit id="87acaebec96dcd891a49b70723f561ac4a00a2ef" translate="yes" xml:space="preserve">
          <source>If the repetition can match zero times (&lt;code&gt;*&lt;/code&gt; or &lt;code&gt;?&lt;/code&gt;), then whatever comes after must be able to follow whatever comes before.</source>
          <target state="translated">Если повторение может соответствовать нулю раз ( &lt;code&gt;*&lt;/code&gt; или &lt;code&gt;?&lt;/code&gt; ), То все, что идет после, должно иметь возможность следовать за тем, что было раньше.</target>
        </trans-unit>
        <trans-unit id="0c4e89c7ed58ca57a531d68235db3f5dd485fb44" translate="yes" xml:space="preserve">
          <source>If the repetition can repeat multiple times (&lt;code&gt;*&lt;/code&gt; or &lt;code&gt;+&lt;/code&gt;), then the contents must be able to follow themselves.</source>
          <target state="translated">Если повторение может повторяться несколько раз ( &lt;code&gt;*&lt;/code&gt; или &lt;code&gt;+&lt;/code&gt; ), тогда содержимое должно иметь возможность следовать за собой.</target>
        </trans-unit>
        <trans-unit id="f0a7f9f74244abd35ce8e1d2208c1f4bd4a178de" translate="yes" xml:space="preserve">
          <source>If the repetition includes a separator, that separator must be able to follow the contents of the repetition.</source>
          <target state="translated">Если в повторении присутствует разделитель,то этот разделитель должен быть способен следовать за содержанием повторения.</target>
        </trans-unit>
        <trans-unit id="93fda8c7280ac97a010f00a3edbfb2871f7e4163" translate="yes" xml:space="preserve">
          <source>If the results of this method are only manipulated by the same architecture that produced them, then there is no portability concern.</source>
          <target state="translated">Если результаты этого метода манипулируются только той же архитектурой,которая их создала,то никакого беспокойства по поводу переносимости нет.</target>
        </trans-unit>
        <trans-unit id="2714df80ed99e7f5046c9baa63d90d1d03b47084" translate="yes" xml:space="preserve">
          <source>If the return value is &lt;a href=&quot;../result/enum.result#variant.Ok&quot;&gt;&lt;code&gt;Ok(n)&lt;/code&gt;&lt;/a&gt; then it must be guaranteed that &lt;code&gt;0 &amp;lt;= n &amp;lt;= buf.len()&lt;/code&gt;. A return value of &lt;code&gt;0&lt;/code&gt; typically means that the underlying object is no longer able to accept bytes and will likely not be able to in the future as well, or that the buffer provided is empty.</source>
          <target state="translated">Если возвращаемое значение - &lt;a href=&quot;../result/enum.result#variant.Ok&quot;&gt; &lt;code&gt;Ok(n)&lt;/code&gt; &lt;/a&gt; тогда должно быть гарантировано, что &lt;code&gt;0 &amp;lt;= n &amp;lt;= buf.len()&lt;/code&gt; . Возвращаемое значение &lt;code&gt;0&lt;/code&gt; обычно означает, что базовый объект больше не может принимать байты и, скорее всего, не сможет это сделать и в будущем, или что предоставленный буфер пуст.</target>
        </trans-unit>
        <trans-unit id="d3bffaa154919c3b8c559f95a11e7d99a1c962cc" translate="yes" xml:space="preserve">
          <source>If the return value is &lt;a href=&quot;../result/enum.result#variant.Ok&quot;&gt;&lt;code&gt;Ok(n)&lt;/code&gt;&lt;/a&gt; then it must be guaranteed that &lt;code&gt;n &amp;lt;= buf.len()&lt;/code&gt;. A return value of &lt;code&gt;0&lt;/code&gt; typically means that the underlying object is no longer able to accept bytes and will likely not be able to in the future as well, or that the buffer provided is empty.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3d8a15b3b50cba05982491cd9452366b174a6982" translate="yes" xml:space="preserve">
          <source>If the return value of this method is &lt;a href=&quot;../result/enum.result#variant.Ok&quot;&gt;&lt;code&gt;Ok(n)&lt;/code&gt;&lt;/a&gt;, then it must be guaranteed that &lt;code&gt;0 &amp;lt;= n &amp;lt;= buf.len()&lt;/code&gt;. A nonzero &lt;code&gt;n&lt;/code&gt; value indicates that the buffer &lt;code&gt;buf&lt;/code&gt; has been filled in with &lt;code&gt;n&lt;/code&gt; bytes of data from this source. If &lt;code&gt;n&lt;/code&gt; is &lt;code&gt;0&lt;/code&gt;, then it can indicate one of two scenarios:</source>
          <target state="translated">Если возвращаемое значение этого метода - &lt;a href=&quot;../result/enum.result#variant.Ok&quot;&gt; &lt;code&gt;Ok(n)&lt;/code&gt; &lt;/a&gt; , то должно быть гарантировано, что &lt;code&gt;0 &amp;lt;= n &amp;lt;= buf.len()&lt;/code&gt; . Ненулевое значение &lt;code&gt;n&lt;/code&gt; указывает, что буфер &lt;code&gt;buf&lt;/code&gt; заполнен &lt;code&gt;n&lt;/code&gt; байтами данных из этого источника. Если &lt;code&gt;n&lt;/code&gt; равно &lt;code&gt;0&lt;/code&gt; , это может указывать на один из двух сценариев:</target>
        </trans-unit>
        <trans-unit id="ded67fe7a6c072a895832d05a296084ac3d461ad" translate="yes" xml:space="preserve">
          <source>If the seek operation completed successfully, this method returns the new position from the start of the stream. That position can be used later with &lt;a href=&quot;enum.seekfrom#variant.Start&quot;&gt;&lt;code&gt;SeekFrom::Start&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Если операция поиска завершилась успешно, этот метод возвращает новую позицию от начала потока. Эту позицию можно будет использовать позже с помощью &lt;a href=&quot;enum.seekfrom#variant.Start&quot;&gt; &lt;code&gt;SeekFrom::Start&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="40a290f3a15c2cd192fbe0ef4a0681d5f1afa2a2" translate="yes" xml:space="preserve">
          <source>If the set did have this value present, &lt;code&gt;false&lt;/code&gt; is returned, and the entry is not updated. See the &lt;a href=&quot;index#insert-and-complex-keys&quot;&gt;module-level documentation&lt;/a&gt; for more.</source>
          <target state="translated">Если в наборе действительно присутствует это значение, возвращается &lt;code&gt;false&lt;/code&gt; и запись не обновляется. Дополнительную информацию см. В &lt;a href=&quot;index#insert-and-complex-keys&quot;&gt;документации&lt;/a&gt; на уровне модуля .</target>
        </trans-unit>
        <trans-unit id="94e9a109c03e48a1d66a80ba76a8cd1667e1c88c" translate="yes" xml:space="preserve">
          <source>If the set did have this value present, &lt;code&gt;false&lt;/code&gt; is returned.</source>
          <target state="translated">Если в наборе действительно присутствует это значение, возвращается &lt;code&gt;false&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3bf8ca60d7471ccc5d2a042445134f6d59f07692" translate="yes" xml:space="preserve">
          <source>If the set did not have this value present, &lt;code&gt;true&lt;/code&gt; is returned.</source>
          <target state="translated">Если в наборе не было этого значения, возвращается &lt;code&gt;true&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6f392e4742f25190cbf5e3351752daf379a0be61" translate="yes" xml:space="preserve">
          <source>If the slice does not end with &lt;code&gt;suffix&lt;/code&gt;, returns &lt;code&gt;None&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d43a87008e53f4a6466f036fda4975d20f3ad011" translate="yes" xml:space="preserve">
          <source>If the slice does not start with &lt;code&gt;prefix&lt;/code&gt;, returns &lt;code&gt;None&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2ad3d774a6e0ccaa727d17e721cc10badd0ba8e6" translate="yes" xml:space="preserve">
          <source>If the slice ends with &lt;code&gt;suffix&lt;/code&gt;, returns the subslice before the suffix, wrapped in &lt;code&gt;Some&lt;/code&gt;. If &lt;code&gt;suffix&lt;/code&gt; is empty, simply returns the original slice.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f83ff10b230425401b084d2888a7c546a452e490" translate="yes" xml:space="preserve">
          <source>If the slice is shorter than &lt;code&gt;size&lt;/code&gt;:</source>
          <target state="translated">Если кусок короче &lt;code&gt;size&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="1412fa3c4897cefe27e1dd8f5c2bdb81e3843fe2" translate="yes" xml:space="preserve">
          <source>If the slice is sorted, the first returned slice contains no duplicates.</source>
          <target state="translated">Если ломтик отсортирован,то первый возвращенный ломтик не содержит дубликатов.</target>
        </trans-unit>
        <trans-unit id="c27d8278e5200cca20b3d013d5698cf10c18fe2f" translate="yes" xml:space="preserve">
          <source>If the slice starts with &lt;code&gt;prefix&lt;/code&gt;, returns the subslice after the prefix, wrapped in &lt;code&gt;Some&lt;/code&gt;. If &lt;code&gt;prefix&lt;/code&gt; is empty, simply returns the original slice.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a7500b2ee92288b054ccbb9cf159239611040c00" translate="yes" xml:space="preserve">
          <source>If the socket isn't connected, it will return a &lt;a href=&quot;../io/enum.errorkind#variant.NotConnected&quot;&gt;&lt;code&gt;NotConnected&lt;/code&gt;&lt;/a&gt; error.</source>
          <target state="translated">Если сокет не подключен, он вернет ошибку &lt;a href=&quot;../io/enum.errorkind#variant.NotConnected&quot;&gt; &lt;code&gt;NotConnected&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="49c9a191f32deb0b74107f0ae0391ae8d0b43b7a" translate="yes" xml:space="preserve">
          <source>If the source and destination will &lt;em&gt;never&lt;/em&gt; overlap, &lt;a href=&quot;../ptr/fn.copy_nonoverlapping&quot;&gt;&lt;code&gt;copy_nonoverlapping&lt;/code&gt;&lt;/a&gt; can be used instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="78527ed1205c7d745b52b60ade93722ffae3f052" translate="yes" xml:space="preserve">
          <source>If the source and destination will &lt;em&gt;never&lt;/em&gt; overlap, &lt;a href=&quot;fn.copy_nonoverlapping&quot;&gt;&lt;code&gt;copy_nonoverlapping&lt;/code&gt;&lt;/a&gt; can be used instead.</source>
          <target state="translated">Если источник и место назначения &lt;em&gt;никогда не&lt;/em&gt; будут перекрываться, &lt;a href=&quot;fn.copy_nonoverlapping&quot;&gt; &lt;code&gt;copy_nonoverlapping&lt;/code&gt; &lt;/a&gt; можно использовать copy_nonoverlapping .</target>
        </trans-unit>
        <trans-unit id="4361232c2009840823276ea8357ba262f43a3b14" translate="yes" xml:space="preserve">
          <source>If the string does not end with &lt;code&gt;suffix&lt;/code&gt;, &lt;code&gt;None&lt;/code&gt; is returned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="00699a6c688425007189014e64bb10c087e7cc42" translate="yes" xml:space="preserve">
          <source>If the string does not end with &lt;code&gt;suffix&lt;/code&gt;, returns &lt;code&gt;None&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5fd5dbdb681a59cb1a332e76b0649dd3b10de31e" translate="yes" xml:space="preserve">
          <source>If the string does not start with &lt;code&gt;prefix&lt;/code&gt;, &lt;code&gt;None&lt;/code&gt; is returned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b4c5d3aa960799aefa6afdc31361ee8f07d50151" translate="yes" xml:space="preserve">
          <source>If the string does not start with &lt;code&gt;prefix&lt;/code&gt;, returns &lt;code&gt;None&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="39245347359d8114b8b3a102418b227e0b5a250d" translate="yes" xml:space="preserve">
          <source>If the string ends with the pattern &lt;code&gt;suffix&lt;/code&gt;, &lt;code&gt;Some&lt;/code&gt; is returned with the substring where the suffix is removed. Unlike &lt;code&gt;trim_end_matches&lt;/code&gt;, this method removes the suffix exactly once.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="73e6ef23293e24078530c7881fe300a2cd50dbd2" translate="yes" xml:space="preserve">
          <source>If the string ends with the pattern &lt;code&gt;suffix&lt;/code&gt;, returns the substring before the suffix, wrapped in &lt;code&gt;Some&lt;/code&gt;. Unlike &lt;code&gt;trim_end_matches&lt;/code&gt;, this method removes the suffix exactly once.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="daa8bca77eb9444573d0ec6c5903975dcf9aaa55" translate="yes" xml:space="preserve">
          <source>If the string starts with the pattern &lt;code&gt;prefix&lt;/code&gt;, &lt;code&gt;Some&lt;/code&gt; is returned with the substring where the prefix is removed. Unlike &lt;code&gt;trim_start_matches&lt;/code&gt;, this method removes the prefix exactly once.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b2971983ae4e5fda25d513b0c8f02476f9d89865" translate="yes" xml:space="preserve">
          <source>If the string starts with the pattern &lt;code&gt;prefix&lt;/code&gt;, returns substring after the prefix, wrapped in &lt;code&gt;Some&lt;/code&gt;. Unlike &lt;code&gt;trim_start_matches&lt;/code&gt;, this method removes the prefix exactly once.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ddcbef4bcc4007d5bd1893bc755dafa184d9df1c" translate="yes" xml:space="preserve">
          <source>If the timeout is &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt;, then &lt;a href=&quot;../io/trait.read#tymethod.read&quot;&gt;&lt;code&gt;read&lt;/code&gt;&lt;/a&gt; calls will block indefinitely.</source>
          <target state="translated">Если тайм-аут равен &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt; &lt;code&gt;None&lt;/code&gt; &lt;/a&gt; , то вызовы &lt;a href=&quot;../io/trait.read#tymethod.read&quot;&gt; &lt;code&gt;read&lt;/code&gt; &lt;/a&gt; будут блокироваться на неопределенный срок.</target>
        </trans-unit>
        <trans-unit id="071f9fdeaf91e92bcf2267f9e0f60277f6bcc97e" translate="yes" xml:space="preserve">
          <source>If the timeout is &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt;, then &lt;a href=&quot;../io/trait.write#tymethod.write&quot;&gt;&lt;code&gt;write&lt;/code&gt;&lt;/a&gt; calls will block indefinitely.</source>
          <target state="translated">Если тайм-аут равен &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt; &lt;code&gt;None&lt;/code&gt; &lt;/a&gt; , то вызовы &lt;a href=&quot;../io/trait.write#tymethod.write&quot;&gt; &lt;code&gt;write&lt;/code&gt; &lt;/a&gt; будут блокироваться на неопределенный срок.</target>
        </trans-unit>
        <trans-unit id="86ffa0ca9fede5aea50d7e731aa1e556c2cfcb06" translate="yes" xml:space="preserve">
          <source>If the trait &lt;code&gt;Foo&lt;/code&gt; was deriving from something like &lt;code&gt;Super&amp;lt;String&amp;gt;&lt;/code&gt; or &lt;code&gt;Super&amp;lt;T&amp;gt;&lt;/code&gt; (where &lt;code&gt;Foo&lt;/code&gt; itself is &lt;code&gt;Foo&amp;lt;T&amp;gt;&lt;/code&gt;), this is okay, because given a type &lt;code&gt;get_a()&lt;/code&gt; will definitely return an object of that type.</source>
          <target state="translated">Если черта &lt;code&gt;Foo&lt;/code&gt; была получена из чего-то вроде &lt;code&gt;Super&amp;lt;String&amp;gt;&lt;/code&gt; или &lt;code&gt;Super&amp;lt;T&amp;gt;&lt;/code&gt; (где сам &lt;code&gt;Foo&lt;/code&gt; - это &lt;code&gt;Foo&amp;lt;T&amp;gt;&lt;/code&gt; ), это нормально, потому что при заданном типе &lt;code&gt;get_a()&lt;/code&gt; обязательно вернет объект этого типа.</target>
        </trans-unit>
        <trans-unit id="59d15c0755f3a894e4c73cfbee908b72296e216e" translate="yes" xml:space="preserve">
          <source>If the trait &lt;code&gt;Trait&lt;/code&gt; was deriving from something like &lt;code&gt;Super&amp;lt;String&amp;gt;&lt;/code&gt; or &lt;code&gt;Super&amp;lt;T&amp;gt;&lt;/code&gt; (where &lt;code&gt;Foo&lt;/code&gt; itself is &lt;code&gt;Foo&amp;lt;T&amp;gt;&lt;/code&gt;), this is okay, because given a type &lt;code&gt;get_a()&lt;/code&gt; will definitely return an object of that type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f3977c8ff69bc736e667f7951c5a2e7ce42dc78b" translate="yes" xml:space="preserve">
          <source>If the trait has no lifetime bounds, then the lifetime is inferred in expressions and is &lt;code&gt;'static&lt;/code&gt; outside of expressions.</source>
          <target state="translated">Если у признака нет границ времени жизни, то время жизни выводится в выражениях и является &lt;code&gt;'static&lt;/code&gt; вне выражений.</target>
        </trans-unit>
        <trans-unit id="91f2e745c85e0029a493a85d365496779bca0a85" translate="yes" xml:space="preserve">
          <source>If the trait is defined with a single lifetime &lt;em&gt;bound&lt;/em&gt; then that bound is used.</source>
          <target state="translated">Если признак определен с одной &lt;em&gt;границей&lt;/em&gt; времени жизни, то используется эта граница.</target>
        </trans-unit>
        <trans-unit id="357e0325de10f1713bb7e2ce24ee991bac9ba465" translate="yes" xml:space="preserve">
          <source>If the trait object is used as a type argument of a generic type then the containing type is first used to try to infer a bound.</source>
          <target state="translated">Если объект трейта используется в качестве аргумента типа родового типа,то содержащий тип сначала используется для попытки вывести границу.</target>
        </trans-unit>
        <trans-unit id="560d3597e83d956d002972f4abc002a7d2adb557" translate="yes" xml:space="preserve">
          <source>If the type of the &lt;code&gt;self&lt;/code&gt; parameter is specified, it is limited to one of the following types:</source>
          <target state="translated">Если указан тип параметра &lt;code&gt;self&lt;/code&gt; , он ограничен одним из следующих типов:</target>
        </trans-unit>
        <trans-unit id="9d09dbe4faca02efaba3f848374123e962d67442" translate="yes" xml:space="preserve">
          <source>If the type of the &lt;code&gt;self&lt;/code&gt; parameter is specified, it is limited to types resolving to one generated by the following grammar (where &lt;code&gt;'lt&lt;/code&gt; denotes some arbitrary lifetime):</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ce48e604713fdd5d1a45036f133935186dfa1172" translate="yes" xml:space="preserve">
          <source>If the type parameter was included by mistake, this error can be fixed by simply removing the type parameter, as shown below:</source>
          <target state="translated">Если типовой параметр был включен по ошибке,то эту ошибку можно исправить,просто удалив типовой параметр,как показано ниже:</target>
        </trans-unit>
        <trans-unit id="518ddacd66d25987845bcd6f93021680b5c6a782" translate="yes" xml:space="preserve">
          <source>If the underlying data is &lt;a href=&quot;../marker/trait.unpin&quot;&gt;&lt;code&gt;Unpin&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#method.into_inner&quot;&gt;&lt;code&gt;Pin::into_inner&lt;/code&gt;&lt;/a&gt; should be used instead.</source>
          <target state="translated">Если анализируемые данные &lt;a href=&quot;../marker/trait.unpin&quot;&gt; &lt;code&gt;Unpin&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#method.into_inner&quot;&gt; &lt;code&gt;Pin::into_inner&lt;/code&gt; &lt;/a&gt; следует использовать вместо этого.</target>
        </trans-unit>
        <trans-unit id="d7db2f45fba2c01ea8e6f00a55427c1ac62329ce" translate="yes" xml:space="preserve">
          <source>If the underlying data is &lt;a href=&quot;../marker/trait.unpin&quot;&gt;&lt;code&gt;Unpin&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;struct.pin#method.into_inner&quot;&gt;&lt;code&gt;Pin::into_inner&lt;/code&gt;&lt;/a&gt; should be used instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d6a64661df18427c960804044729f48ac301ae02" translate="yes" xml:space="preserve">
          <source>If the underlying data is &lt;code&gt;Unpin&lt;/code&gt;, &lt;code&gt;Pin::get_mut&lt;/code&gt; should be used instead.</source>
          <target state="translated">Если анализируемые данные &lt;code&gt;Unpin&lt;/code&gt; , &lt;code&gt;Pin::get_mut&lt;/code&gt; следует использовать вместо этого.</target>
        </trans-unit>
        <trans-unit id="8405b8ad332b999aa219670b74caa5f46b181830" translate="yes" xml:space="preserve">
          <source>If the underlying filesystem does not support creation time, the returned value is 0.</source>
          <target state="translated">Если базовая файловая система не поддерживает время создания,возвращаемое значение равно 0.</target>
        </trans-unit>
        <trans-unit id="413f9b68289dcc8297528df41e0f0feb6ddb8349" translate="yes" xml:space="preserve">
          <source>If the underlying filesystem does not support last access time, the returned value is 0.</source>
          <target state="translated">Если базовая файловая система не поддерживает последнее время доступа,возвращаемое значение равно 0.</target>
        </trans-unit>
        <trans-unit id="fb7130f0e0ffc326e8ffb3bb43790b19856655f3" translate="yes" xml:space="preserve">
          <source>If the underlying filesystem does not support the last write time, the returned value is 0.</source>
          <target state="translated">Если базовая файловая система не поддерживает последнее время записи,возвращаемое значение равно 0.</target>
        </trans-unit>
        <trans-unit id="4282d187fb807509a1857f1a4d0e25b41883c729" translate="yes" xml:space="preserve">
          <source>If the unsized tail of &lt;code&gt;T&lt;/code&gt; is:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2800f0b4e13fb2d5eedd5490b06177fdb31e9a98" translate="yes" xml:space="preserve">
          <source>If the user specifies a favorite color, that color is the background color. If today is Tuesday, the background color is green. If the user specifies their age as a string and we can parse it as a number successfully, the color is either purple or orange depending on the value of the number. If none of these conditions apply, the background color is blue.</source>
          <target state="translated">Если пользователь указывает любимый цвет,то этот цвет является цветом фона.Если сегодня вторник,то цвет фона-зеленый.Если пользователь задает свой возраст в виде строки и мы можем успешно разобрать его как число,то цвет будет либо фиолетовым,либо оранжевым в зависимости от значения числа.Если ни одно из этих условий не применяется,то цвет фона-синий.</target>
        </trans-unit>
        <trans-unit id="e4dd9bc072921d826fb4feb5e2064cc014699b96" translate="yes" xml:space="preserve">
          <source>If the user wants a high-intensity workout, there&amp;rsquo;s some additional logic: if the value of the random number generated by the app happens to be 3, the app will recommend a break and hydration. If not, the user will get a number of minutes of running based on the complex algorithm.</source>
          <target state="translated">Если пользователь хочет тренировку высокой интенсивности, есть дополнительная логика: если значение случайного числа, сгенерированного приложением, оказывается равным 3, приложение порекомендует перерыв и гидратацию. В противном случае пользователь получит несколько минут работы на основе сложного алгоритма.</target>
        </trans-unit>
        <trans-unit id="de326f90242f044e38821476a3f1590bb4fba9d2" translate="yes" xml:space="preserve">
          <source>If the value has to be borrowed and then moved, try limiting the lifetime of the borrow using a scoped block:</source>
          <target state="translated">Если необходимо заимствовать и затем перемещать стоимость,попробуйте ограничить срок службы заимствования с помощью сканированного блока:</target>
        </trans-unit>
        <trans-unit id="439bfb205198efd0a4754651bf5aae96ad735451" translate="yes" xml:space="preserve">
          <source>If the value has to be borrowed, try limiting the lifetime of the borrow using a scoped block:</source>
          <target state="translated">Если необходимо заимствовать стоимость,попробуйте ограничить срок действия заимствования с помощью скопированного блока:</target>
        </trans-unit>
        <trans-unit id="f9c557d25b585efde62c6ddbcee6fee7ec33bf65" translate="yes" xml:space="preserve">
          <source>If the value is found then &lt;a href=&quot;../../result/enum.result#variant.Ok&quot;&gt;&lt;code&gt;Result::Ok&lt;/code&gt;&lt;/a&gt; is returned, containing the index of the matching element. If there are multiple matches, then any one of the matches could be returned. If the value is not found then &lt;a href=&quot;../../result/enum.result#variant.Err&quot;&gt;&lt;code&gt;Result::Err&lt;/code&gt;&lt;/a&gt; is returned, containing the index where a matching element could be inserted while maintaining sorted order.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8d1fe880a09ab231c6fd293521ee6addfe1a6459" translate="yes" xml:space="preserve">
          <source>If the value is found then &lt;a href=&quot;../result/enum.result#Ok.v&quot;&gt;&lt;code&gt;Result::Ok&lt;/code&gt;&lt;/a&gt; is returned, containing the index of the matching element. If there are multiple matches, then any one of the matches could be returned. If the value is not found then &lt;a href=&quot;../result/enum.result#Err.v&quot;&gt;&lt;code&gt;Result::Err&lt;/code&gt;&lt;/a&gt; is returned, containing the index where a matching element could be inserted while maintaining sorted order.</source>
          <target state="translated">Если значение найдено, возвращается &lt;a href=&quot;../result/enum.result#Ok.v&quot;&gt; &lt;code&gt;Result::Ok&lt;/code&gt; &lt;/a&gt; , содержащий индекс соответствующего элемента. Если есть несколько совпадений, то может быть возвращено любое из совпадений. Если значение не найдено, возвращается &lt;a href=&quot;../result/enum.result#Err.v&quot;&gt; &lt;code&gt;Result::Err&lt;/code&gt; &lt;/a&gt; , содержащий индекс, в который может быть вставлен соответствующий элемент, сохраняя отсортированный порядок.</target>
        </trans-unit>
        <trans-unit id="cf626e78bb4fbb4f09006ad988abe5836977b7bd" translate="yes" xml:space="preserve">
          <source>If the value is found then &lt;a href=&quot;../result/enum.result#variant.Ok&quot;&gt;&lt;code&gt;Result::Ok&lt;/code&gt;&lt;/a&gt; is returned, containing the index of the matching element. If there are multiple matches, then any one of the matches could be returned. If the value is not found then &lt;a href=&quot;../result/enum.result#variant.Err&quot;&gt;&lt;code&gt;Result::Err&lt;/code&gt;&lt;/a&gt; is returned, containing the index where a matching element could be inserted while maintaining sorted order.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="50a46bb743147d3eacb03edd963a4e09c15c1d2d" translate="yes" xml:space="preserve">
          <source>If the value is found then &lt;a href=&quot;result/enum.result#Ok.v&quot;&gt;&lt;code&gt;Result::Ok&lt;/code&gt;&lt;/a&gt; is returned, containing the index of the matching element. If there are multiple matches, then any one of the matches could be returned. If the value is not found then &lt;a href=&quot;result/enum.result#Err.v&quot;&gt;&lt;code&gt;Result::Err&lt;/code&gt;&lt;/a&gt; is returned, containing the index where a matching element could be inserted while maintaining sorted order.</source>
          <target state="translated">Если значение найдено, возвращается &lt;a href=&quot;result/enum.result#Ok.v&quot;&gt; &lt;code&gt;Result::Ok&lt;/code&gt; &lt;/a&gt; , содержащий индекс соответствующего элемента. Если есть несколько совпадений, то может быть возвращено любое из совпадений. Если значение не найдено, возвращается &lt;a href=&quot;result/enum.result#Err.v&quot;&gt; &lt;code&gt;Result::Err&lt;/code&gt; &lt;/a&gt; , содержащий индекс, в который может быть вставлен соответствующий элемент, сохраняя отсортированный порядок.</target>
        </trans-unit>
        <trans-unit id="d91c83f96183a0d83c776c950c730bfea58d4c7b" translate="yes" xml:space="preserve">
          <source>If the value is found then &lt;a href=&quot;result/enum.result#variant.Ok&quot;&gt;&lt;code&gt;Result::Ok&lt;/code&gt;&lt;/a&gt; is returned, containing the index of the matching element. If there are multiple matches, then any one of the matches could be returned. If the value is not found then &lt;a href=&quot;result/enum.result#variant.Err&quot;&gt;&lt;code&gt;Result::Err&lt;/code&gt;&lt;/a&gt; is returned, containing the index where a matching element could be inserted while maintaining sorted order.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3d22ef5ff5dbc4cc40b70616ba2e0f0190b53527" translate="yes" xml:space="preserve">
          <source>If the value specified is &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt;, then &lt;a href=&quot;../io/trait.read#tymethod.read&quot;&gt;&lt;code&gt;read&lt;/code&gt;&lt;/a&gt; calls will block indefinitely. An &lt;a href=&quot;../result/enum.result#variant.Err&quot;&gt;&lt;code&gt;Err&lt;/code&gt;&lt;/a&gt; is returned if the zero &lt;a href=&quot;../time/struct.duration&quot;&gt;&lt;code&gt;Duration&lt;/code&gt;&lt;/a&gt; is passed to this method.</source>
          <target state="translated">Если указано значение &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt; &lt;code&gt;None&lt;/code&gt; &lt;/a&gt; , тогда вызовы &lt;a href=&quot;../io/trait.read#tymethod.read&quot;&gt; &lt;code&gt;read&lt;/code&gt; &lt;/a&gt; будут блокироваться на неопределенный срок. &lt;a href=&quot;../result/enum.result#variant.Err&quot;&gt; &lt;code&gt;Err&lt;/code&gt; &lt;/a&gt; возвращается , если нулевой &lt;a href=&quot;../time/struct.duration&quot;&gt; &lt;code&gt;Duration&lt;/code&gt; &lt;/a&gt; передается этому методу.</target>
        </trans-unit>
        <trans-unit id="29067101ad21459828f0c00fe18eef137fbe68c7" translate="yes" xml:space="preserve">
          <source>If the value specified is &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt;, then &lt;a href=&quot;../io/trait.write#tymethod.write&quot;&gt;&lt;code&gt;write&lt;/code&gt;&lt;/a&gt; calls will block indefinitely. An &lt;a href=&quot;../result/enum.result#variant.Err&quot;&gt;&lt;code&gt;Err&lt;/code&gt;&lt;/a&gt; is returned if the zero &lt;a href=&quot;../time/struct.duration&quot;&gt;&lt;code&gt;Duration&lt;/code&gt;&lt;/a&gt; is passed to this method.</source>
          <target state="translated">Если указано значение &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt; &lt;code&gt;None&lt;/code&gt; &lt;/a&gt; , то вызовы &lt;a href=&quot;../io/trait.write#tymethod.write&quot;&gt; &lt;code&gt;write&lt;/code&gt; &lt;/a&gt; будут блокироваться на неопределенный срок. &lt;a href=&quot;../result/enum.result#variant.Err&quot;&gt; &lt;code&gt;Err&lt;/code&gt; &lt;/a&gt; возвращается , если нулевой &lt;a href=&quot;../time/struct.duration&quot;&gt; &lt;code&gt;Duration&lt;/code&gt; &lt;/a&gt; передается этому методу.</target>
        </trans-unit>
        <trans-unit id="181ed969af7558ba19cf6745f45eb52729d76a52" translate="yes" xml:space="preserve">
          <source>If the value will be consumed in the pattern guard, using its clone will not move its ownership, so the code works.</source>
          <target state="translated">Если значение будет потребляться в защитной оболочке шаблона,то использование его клона не сдвинет его владельца,поэтому код работает.</target>
        </trans-unit>
        <trans-unit id="fcea84573a8b7607a7187659bdbb55dd1d39b19b" translate="yes" xml:space="preserve">
          <source>If the vector is sorted, this removes all duplicates.</source>
          <target state="translated">Если вектор отсортировать,то все дубликаты будут удалены.</target>
        </trans-unit>
        <trans-unit id="cef9f1c43befa45dbf980aee6fe9d718a1e963db" translate="yes" xml:space="preserve">
          <source>If there are multiple types involved, the only way you care to interact with them is through the trait's interface, and having to rely on dynamic dispatch is acceptable, then you can use &lt;a href=&quot;book/ch17-02-trait-objects#using-trait-objects-that-allow-for-values-of-different-types&quot;&gt;trait objects&lt;/a&gt; with &lt;code&gt;Box&lt;/code&gt;, or other container types like &lt;code&gt;Rc&lt;/code&gt; or &lt;code&gt;Arc&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="abef88012cadeaf10ba437a95f5fb3e15155b1f7" translate="yes" xml:space="preserve">
          <source>If there are no other &lt;code&gt;Rc&lt;/code&gt; pointers to this allocation, then &lt;a href=&quot;struct.weak&quot;&gt;&lt;code&gt;Weak&lt;/code&gt;&lt;/a&gt; pointers to this allocation will be disassociated.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ff03d8563fa4e1bf22eab63535da2e3b71548d3f" translate="yes" xml:space="preserve">
          <source>If there are no other &lt;code&gt;Rc&lt;/code&gt; pointers to this value, then &lt;a href=&quot;struct.weak&quot;&gt;&lt;code&gt;Weak&lt;/code&gt;&lt;/a&gt; pointers to this value will be dissassociated.</source>
          <target state="translated">Если других указателей &lt;code&gt;Rc&lt;/code&gt; на это значение нет, то &lt;a href=&quot;struct.weak&quot;&gt; &lt;code&gt;Weak&lt;/code&gt; &lt;/a&gt; указатели на это значение будут отсоединены.</target>
        </trans-unit>
        <trans-unit id="95b57c72705e9580ae96b3d9b9bde30bb6b6ab81" translate="yes" xml:space="preserve">
          <source>If there are other &lt;code&gt;Arc&lt;/code&gt; or &lt;a href=&quot;struct.weak&quot;&gt;&lt;code&gt;Weak&lt;/code&gt;&lt;/a&gt; pointers to the same allocation, then &lt;code&gt;make_mut&lt;/code&gt; will create a new allocation and invoke &lt;a href=&quot;../clone/trait.clone#tymethod.clone&quot;&gt;&lt;code&gt;clone&lt;/code&gt;&lt;/a&gt; on the inner value to ensure unique ownership. This is also referred to as clone-on-write.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4f600b6c8aaa0b5d77a10aa7a739f040bbc9e0c6" translate="yes" xml:space="preserve">
          <source>If there are other &lt;code&gt;Arc&lt;/code&gt; or &lt;a href=&quot;struct.weak&quot;&gt;&lt;code&gt;Weak&lt;/code&gt;&lt;/a&gt; pointers to the same value, then &lt;code&gt;make_mut&lt;/code&gt; will invoke &lt;a href=&quot;../clone/trait.clone#tymethod.clone&quot;&gt;&lt;code&gt;clone&lt;/code&gt;&lt;/a&gt; on the inner value to ensure unique ownership. This is also referred to as clone-on-write.</source>
          <target state="translated">Если есть другие указатели &lt;code&gt;Arc&lt;/code&gt; или &lt;a href=&quot;struct.weak&quot;&gt; &lt;code&gt;Weak&lt;/code&gt; &lt;/a&gt; на то же значение, &lt;code&gt;make_mut&lt;/code&gt; вызовет &lt;a href=&quot;../clone/trait.clone#tymethod.clone&quot;&gt; &lt;code&gt;clone&lt;/code&gt; &lt;/a&gt; внутреннего значения, чтобы гарантировать уникальное владение. Это также называется клонированием при записи.</target>
        </trans-unit>
        <trans-unit id="0fe3cddf6aeb04744aa2425c22a909112782196d" translate="yes" xml:space="preserve">
          <source>If there are other &lt;code&gt;Rc&lt;/code&gt; pointers to the same allocation, then &lt;code&gt;make_mut&lt;/code&gt; will &lt;a href=&quot;../clone/trait.clone#tymethod.clone&quot;&gt;&lt;code&gt;clone&lt;/code&gt;&lt;/a&gt; the inner value to a new allocation to ensure unique ownership. This is also referred to as clone-on-write.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f863941a685dbb092b44959406a2b7b73529caaa" translate="yes" xml:space="preserve">
          <source>If there are other &lt;code&gt;Rc&lt;/code&gt; pointers to the same value, then &lt;code&gt;make_mut&lt;/code&gt; will &lt;a href=&quot;../clone/trait.clone#tymethod.clone&quot;&gt;&lt;code&gt;clone&lt;/code&gt;&lt;/a&gt; the inner value to ensure unique ownership. This is also referred to as clone-on-write.</source>
          <target state="translated">Если есть другие &lt;code&gt;Rc&lt;/code&gt; указатели на ту же величину, то &lt;code&gt;make_mut&lt;/code&gt; будет &lt;a href=&quot;../clone/trait.clone#tymethod.clone&quot;&gt; &lt;code&gt;clone&lt;/code&gt; &lt;/a&gt; внутреннее значение , чтобы обеспечить уникальное владение. Это также называется клонированием при записи.</target>
        </trans-unit>
        <trans-unit id="dea40bb57bee20622d3883c554a725db6e6aee3b" translate="yes" xml:space="preserve">
          <source>If there is a blocked thread on this condition variable, then it will be woken up from its call to &lt;a href=&quot;#method.wait&quot;&gt;&lt;code&gt;wait&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#method.wait_timeout&quot;&gt;&lt;code&gt;wait_timeout&lt;/code&gt;&lt;/a&gt;. Calls to &lt;code&gt;notify_one&lt;/code&gt; are not buffered in any way.</source>
          <target state="translated">Если для этой переменной состояния есть заблокированный поток, он будет разбужен от своего вызова для &lt;a href=&quot;#method.wait&quot;&gt; &lt;code&gt;wait&lt;/code&gt; &lt;/a&gt; или &lt;a href=&quot;#method.wait_timeout&quot;&gt; &lt;code&gt;wait_timeout&lt;/code&gt; &lt;/a&gt; . Вызовы &lt;code&gt;notify_one&lt;/code&gt; никоим образом не буферизуются.</target>
        </trans-unit>
        <trans-unit id="e0a267348680246d2e17aaf9a40bcf577009d4e9" translate="yes" xml:space="preserve">
          <source>If there is a blocked thread on this condition variable, then it will be woken up from its call to &lt;a href=&quot;struct.condvar#method.wait&quot;&gt;&lt;code&gt;wait&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;struct.condvar#method.wait_timeout&quot;&gt;&lt;code&gt;wait_timeout&lt;/code&gt;&lt;/a&gt;. Calls to &lt;code&gt;notify_one&lt;/code&gt; are not buffered in any way.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="985d82ded8f795b4c5a05301fea06f8c8f8410be" translate="yes" xml:space="preserve">
          <source>If there is a single type involved, you can use &lt;a href=&quot;book/ch10-02-traits#returning-types-that-implement-traits&quot;&gt;&lt;code&gt;impl Trait&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bee2363bd2a2c8c97c0aa8c6f834b6380ae23a5d" translate="yes" xml:space="preserve">
          <source>If there is a unique bound from the containing type then that is the default</source>
          <target state="translated">Если есть уникальная привязка от содержащего типа,то по умолчанию это -</target>
        </trans-unit>
        <trans-unit id="352f58ee146eece567c530e6f6054aff283c53ea" translate="yes" xml:space="preserve">
          <source>If there is exactly one lifetime used in the parameters (elided or not), that lifetime is assigned to &lt;em&gt;all&lt;/em&gt; elided output lifetimes.</source>
          <target state="translated">Если в параметрах используется ровно одно время жизни (исключено или нет), это время жизни присваивается &lt;em&gt;всем&lt;/em&gt; исключенным временам жизни выхода.</target>
        </trans-unit>
        <trans-unit id="05c8d9cff8b4cacded32e768ce8c1fe1b9bf7b05" translate="yes" xml:space="preserve">
          <source>If there is more than one bound from the containing type then an explicit bound must be specified</source>
          <target state="translated">Если имеется более одной привязки от содержащего типа,то должна быть указана явная привязка</target>
        </trans-unit>
        <trans-unit id="3635b90aa1ac5e9d56b967f455ea5a68c64aa12a" translate="yes" xml:space="preserve">
          <source>If there is no data attached to &lt;em&gt;any&lt;/em&gt; of the variants of an enumeration, then the discriminant can be directly chosen and accessed.</source>
          <target state="translated">Если ни к &lt;em&gt;одному&lt;/em&gt; из вариантов перечисления не прикреплены данные , то можно напрямую выбрать дискриминант и получить к нему доступ.</target>
        </trans-unit>
        <trans-unit id="5a74422fbdc8c963cd6dd0e8d60bffef84d0d7d1" translate="yes" xml:space="preserve">
          <source>If there's still a partial line in the buffer when the &lt;code&gt;LineWriter&lt;/code&gt; is dropped, it will flush those contents.</source>
          <target state="translated">Если при &lt;code&gt;LineWriter&lt;/code&gt; в буфере все еще есть неполная строка , он сбрасывает это содержимое.</target>
        </trans-unit>
        <trans-unit id="e49a0ab914289e14797d67f14458c53775df1443" translate="yes" xml:space="preserve">
          <source>If this &lt;a href=&quot;struct.error&quot;&gt;&lt;code&gt;Error&lt;/code&gt;&lt;/a&gt; was constructed via &lt;a href=&quot;struct.error#method.last_os_error&quot;&gt;&lt;code&gt;last_os_error&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;struct.error#method.from_raw_os_error&quot;&gt;&lt;code&gt;from_raw_os_error&lt;/code&gt;&lt;/a&gt;, then this function will return &lt;a href=&quot;../option/enum.option#variant.Some&quot;&gt;&lt;code&gt;Some&lt;/code&gt;&lt;/a&gt;, otherwise it will return &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8eaa98dea050ef5ef34b38731584cb22e203de6c" translate="yes" xml:space="preserve">
          <source>If this &lt;a href=&quot;struct.error&quot;&gt;&lt;code&gt;Error&lt;/code&gt;&lt;/a&gt; was constructed via &lt;a href=&quot;struct.error#method.new&quot;&gt;&lt;code&gt;new&lt;/code&gt;&lt;/a&gt; then this function will return &lt;a href=&quot;../option/enum.option#variant.Some&quot;&gt;&lt;code&gt;Some&lt;/code&gt;&lt;/a&gt;, otherwise it will return &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="abb98d91de395055f4edd70094a7b8dcc7dd5d8b" translate="yes" xml:space="preserve">
          <source>If this &lt;code&gt;Error&lt;/code&gt; was constructed via &lt;code&gt;last_os_error&lt;/code&gt; or &lt;code&gt;from_raw_os_error&lt;/code&gt;, then this function will return &lt;code&gt;Some&lt;/code&gt;, otherwise it will return &lt;code&gt;None&lt;/code&gt;.</source>
          <target state="translated">Если эта &lt;code&gt;Error&lt;/code&gt; была создана с помощью &lt;code&gt;last_os_error&lt;/code&gt; или &lt;code&gt;from_raw_os_error&lt;/code&gt; , то эта функция вернет &lt;code&gt;Some&lt;/code&gt; , иначе она вернет &lt;code&gt;None&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d6ffccf610cd6b37d68c88255675f6191805f967" translate="yes" xml:space="preserve">
          <source>If this &lt;code&gt;Error&lt;/code&gt; was constructed via &lt;code&gt;new&lt;/code&gt; then this function will return &lt;code&gt;Some&lt;/code&gt;, otherwise it will return &lt;code&gt;None&lt;/code&gt;.</source>
          <target state="translated">Если эта &lt;code&gt;Error&lt;/code&gt; была создана с помощью &lt;code&gt;new&lt;/code&gt; , тогда эта функция вернет &lt;code&gt;Some&lt;/code&gt; , иначе она вернет &lt;code&gt;None&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="972ece54d9b74d11c408e1f298396f497ba6449a" translate="yes" xml:space="preserve">
          <source>If this &lt;code&gt;char&lt;/code&gt; does not have a lowercase mapping, the iterator yields the same &lt;code&gt;char&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="58c79af0f9cc118b1977a59ee7eda23560b0caa9" translate="yes" xml:space="preserve">
          <source>If this &lt;code&gt;char&lt;/code&gt; does not have a uppercase mapping, the iterator yields the same &lt;code&gt;char&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="829eac6176dbda0779cc96fbc600b1df90d4e4bc" translate="yes" xml:space="preserve">
          <source>If this &lt;code&gt;char&lt;/code&gt; has a one-to-one lowercase mapping given by the &lt;a href=&quot;https://www.unicode.org/reports/tr44/&quot;&gt;Unicode Character Database&lt;/a&gt;&lt;a href=&quot;https://www.unicode.org/Public/UCD/latest/ucd/UnicodeData.txt&quot;&gt;&lt;code&gt;UnicodeData.txt&lt;/code&gt;&lt;/a&gt;, the iterator yields that &lt;code&gt;char&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8172678f4c99b3f0dc7b848aa7a176d18218ceb4" translate="yes" xml:space="preserve">
          <source>If this &lt;code&gt;char&lt;/code&gt; has a one-to-one uppercase mapping given by the &lt;a href=&quot;https://www.unicode.org/reports/tr44/&quot;&gt;Unicode Character Database&lt;/a&gt;&lt;a href=&quot;https://www.unicode.org/Public/UCD/latest/ucd/UnicodeData.txt&quot;&gt;&lt;code&gt;UnicodeData.txt&lt;/code&gt;&lt;/a&gt;, the iterator yields that &lt;code&gt;char&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="89a8c0c082c5779306df0c22e5cf142b946f6c4e" translate="yes" xml:space="preserve">
          <source>If this &lt;code&gt;char&lt;/code&gt; requires special considerations (e.g. multiple &lt;code&gt;char&lt;/code&gt;s) the iterator yields the &lt;code&gt;char&lt;/code&gt;(s) given by &lt;a href=&quot;https://www.unicode.org/Public/UCD/latest/ucd/SpecialCasing.txt&quot;&gt;&lt;code&gt;SpecialCasing.txt&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="548965be0bbc95fe2de47e9f63883d2758d88ca6" translate="yes" xml:space="preserve">
          <source>If this chapter has piqued your interest and you want to implement your own smart pointers, check out &lt;a href=&quot;https://doc.rust-lang.org/nomicon/index.html&quot;&gt;&amp;ldquo;The Rustonomicon&amp;rdquo;&lt;/a&gt; for more useful information.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b584e3b971153b633a07eca679cded17a1c1b693" translate="yes" xml:space="preserve">
          <source>If this chapter has piqued your interest and you want to implement your own smart pointers, check out &lt;a href=&quot;https://doc.rust-lang.org/stable/nomicon/index.html&quot;&gt;&amp;ldquo;The Rustonomicon&amp;rdquo;&lt;/a&gt; for more useful information.</source>
          <target state="translated">Если эта глава вызвала у вас интерес и вы хотите реализовать свои собственные интеллектуальные указатели, посмотрите &lt;a href=&quot;https://doc.rust-lang.org/stable/nomicon/index.html&quot;&gt;&amp;laquo;Растономикон&amp;raquo;&lt;/a&gt; для получения более полезной информации.</target>
        </trans-unit>
        <trans-unit id="0ddae77e0fadbaabd5b7dbc95fb35e2d525819bd" translate="yes" xml:space="preserve">
          <source>If this function encounters an &quot;end of file&quot; before completely filling the buffer, it returns an error of the kind &lt;a href=&quot;../../../io/enum.errorkind#variant.UnexpectedEof&quot;&gt;&lt;code&gt;ErrorKind::UnexpectedEof&lt;/code&gt;&lt;/a&gt;. The contents of &lt;code&gt;buf&lt;/code&gt; are unspecified in this case.</source>
          <target state="translated">Если эта функция обнаруживает &amp;laquo;конец файла&amp;raquo; до полного заполнения буфера, она возвращает ошибку типа &lt;a href=&quot;../../../io/enum.errorkind#variant.UnexpectedEof&quot;&gt; &lt;code&gt;ErrorKind::UnexpectedEof&lt;/code&gt; &lt;/a&gt; . В этом случае содержимое &lt;code&gt;buf&lt;/code&gt; не указано.</target>
        </trans-unit>
        <trans-unit id="dd91d7afe70f171b1effa9750344f0fa576225f4" translate="yes" xml:space="preserve">
          <source>If this function encounters an &quot;end of file&quot; before completely filling the buffer, it returns an error of the kind &lt;a href=&quot;../../../io/enum.errorkind#variant.UnexpectedEof&quot;&gt;&lt;code&gt;io::ErrorKind::UnexpectedEof&lt;/code&gt;&lt;/a&gt;. The contents of &lt;code&gt;buf&lt;/code&gt; are unspecified in this case.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="38d7508026f8cac220a71afe0772cc2be9708eb8" translate="yes" xml:space="preserve">
          <source>If this function encounters an &quot;end of file&quot; before completely filling the buffer, it returns an error of the kind &lt;a href=&quot;enum.errorkind#variant.UnexpectedEof&quot;&gt;&lt;code&gt;ErrorKind::UnexpectedEof&lt;/code&gt;&lt;/a&gt;. The contents of &lt;code&gt;buf&lt;/code&gt; are unspecified in this case.</source>
          <target state="translated">Если эта функция обнаруживает &amp;laquo;конец файла&amp;raquo; до полного заполнения буфера, она возвращает ошибку типа &lt;a href=&quot;enum.errorkind#variant.UnexpectedEof&quot;&gt; &lt;code&gt;ErrorKind::UnexpectedEof&lt;/code&gt; &lt;/a&gt; . В этом случае содержимое &lt;code&gt;buf&lt;/code&gt; не указано.</target>
        </trans-unit>
        <trans-unit id="bb4e1045443cca4084567ed8afb7d4a2bc6c922a" translate="yes" xml:space="preserve">
          <source>If this function encounters an error of the kind &lt;a href=&quot;../../../io/enum.errorkind#variant.Interrupted&quot;&gt;&lt;code&gt;ErrorKind::Interrupted&lt;/code&gt;&lt;/a&gt; then the error is ignored and the operation will continue.</source>
          <target state="translated">Если эта функция обнаруживает ошибку типа &lt;a href=&quot;../../../io/enum.errorkind#variant.Interrupted&quot;&gt; &lt;code&gt;ErrorKind::Interrupted&lt;/code&gt; &lt;/a&gt; тогда ошибка игнорируется и операция будет продолжена.</target>
        </trans-unit>
        <trans-unit id="a8875047b32226ad3b08a483cfff719e7d61c887" translate="yes" xml:space="preserve">
          <source>If this function encounters an error of the kind &lt;a href=&quot;../../../io/enum.errorkind#variant.Interrupted&quot;&gt;&lt;code&gt;io::ErrorKind::Interrupted&lt;/code&gt;&lt;/a&gt; then the error is ignored and the operation will continue.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3b6df35b215478f7f7741d3182fb05937f86e727" translate="yes" xml:space="preserve">
          <source>If this function encounters an error of the kind &lt;a href=&quot;enum.errorkind#variant.Interrupted&quot;&gt;&lt;code&gt;ErrorKind::Interrupted&lt;/code&gt;&lt;/a&gt; then the error is ignored and the operation will continue.</source>
          <target state="translated">Если эта функция обнаруживает ошибку типа &lt;a href=&quot;enum.errorkind#variant.Interrupted&quot;&gt; &lt;code&gt;ErrorKind::Interrupted&lt;/code&gt; &lt;/a&gt; тогда ошибка игнорируется и операция будет продолжена.</target>
        </trans-unit>
        <trans-unit id="14f9d7ca930e810af603a93101162a569a3ddf35" translate="yes" xml:space="preserve">
          <source>If this function encounters any form of I/O or other error, an error variant will be returned. If an error is returned then it must be guaranteed that no bytes were read.</source>
          <target state="translated">Если эта функция столкнется с какой-либо формой ввода/вывода или другой ошибкой,будет возвращен вариант ошибки.Если возвращается ошибка,то необходимо гарантировать,что не было прочитано ни одного байта.</target>
        </trans-unit>
        <trans-unit id="a8d408c5e61a9b54abca8856c432fb48776f9a75" translate="yes" xml:space="preserve">
          <source>If this function returns &lt;a href=&quot;../result/enum.result#variant.Ok&quot;&gt;&lt;code&gt;Ok(0)&lt;/code&gt;&lt;/a&gt;, the stream has reached EOF.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c8a07da1b0668efaf930a01d9ed7e8496400a4f8" translate="yes" xml:space="preserve">
          <source>If this function returns &lt;code&gt;Ok(0)&lt;/code&gt;, the stream has reached EOF.</source>
          <target state="translated">Если эта функция возвращает &lt;code&gt;Ok(0)&lt;/code&gt; , поток достиг EOF.</target>
        </trans-unit>
        <trans-unit id="32100a1ba4be6bddcd14becf4ad19ac4def99416" translate="yes" xml:space="preserve">
          <source>If this function returns an error, it is unspecified how many bytes it has read, but it will never read more than would be necessary to completely fill the buffer.</source>
          <target state="translated">Если эта функция возвращает ошибку,то неизвестно,сколько байт она прочитала,но она никогда не прочитает больше,чем нужно для полного заполнения буфера.</target>
        </trans-unit>
        <trans-unit id="87d71722719a13aad250b3e972be1f6616e469cd" translate="yes" xml:space="preserve">
          <source>If this is a buffered channel, then the buffer is full at this time. If this is not a buffered channel, then there is no &lt;a href=&quot;struct.receiver&quot;&gt;&lt;code&gt;Receiver&lt;/code&gt;&lt;/a&gt; available to acquire the data.</source>
          <target state="translated">Если это буферизованный канал, то в это время буфер заполнен. Если это не буферизованный канал, значит, &lt;a href=&quot;struct.receiver&quot;&gt; &lt;code&gt;Receiver&lt;/code&gt; &lt;/a&gt; недоступен для сбора данных.</target>
        </trans-unit>
        <trans-unit id="91184bf48d3bff1e231691842c160f41d0aa37b7" translate="yes" xml:space="preserve">
          <source>If this is not an option, consider replacing the type parameter with another trait object (e.g., if &lt;code&gt;T: OtherTrait&lt;/code&gt;, use &lt;code&gt;on: Box&amp;lt;OtherTrait&amp;gt;&lt;/code&gt;). If the number of types you intend to feed to this method is limited, consider manually listing out the methods of different types.</source>
          <target state="translated">Если это не вариант, рассмотрите возможность замены параметра типа другим признаком (например, если &lt;code&gt;T: OtherTrait&lt;/code&gt; , используйте &lt;code&gt;on: Box&amp;lt;OtherTrait&amp;gt;&lt;/code&gt; ). Если количество типов, которые вы собираетесь использовать для этого метода, ограничено, рассмотрите возможность вручную перечислить методы разных типов.</target>
        </trans-unit>
        <trans-unit id="5c02bd6638372b67d88f3ddd5d1f383f3787bce7" translate="yes" xml:space="preserve">
          <source>If this is your first time, the documentation for the standard library is written to be casually perused. Clicking on interesting things should generally lead you to interesting places. Still, there are important bits you don't want to miss, so read on for a tour of the standard library and its documentation!</source>
          <target state="translated">Если это ваш первый раз,то документация для стандартной библиотеки будет написана для случайного использования.Нажатие на интересные вещи,как правило,должно привести вас в интересные места.Тем не менее,есть важные биты,которые вы не хотите пропустить,так что читайте дальше для ознакомления со стандартной библиотекой и ее документацией!</target>
        </trans-unit>
        <trans-unit id="9676dae75a055d60a25e6ce7412236743ae6ea02" translate="yes" xml:space="preserve">
          <source>If this method returns &lt;code&gt;Err&lt;/code&gt;, then ownership of the memory block has not been transferred to this allocator, and the contents of the memory block are unaltered.</source>
          <target state="translated">Если этот метод возвращает &lt;code&gt;Err&lt;/code&gt; , то право собственности на блок памяти не было передано этому распределителю, и содержимое блока памяти не изменилось.</target>
        </trans-unit>
        <trans-unit id="01b48a2a055f0e9e221863ae53b5df15b8890a45" translate="yes" xml:space="preserve">
          <source>If this method returns an &lt;code&gt;Ok(addr)&lt;/code&gt;, then the &lt;code&gt;addr&lt;/code&gt; returned will be non-null address pointing to a block of storage suitable for holding an instance of &lt;code&gt;layout&lt;/code&gt;.</source>
          <target state="translated">Если этот метод возвращает &lt;code&gt;Ok(addr)&lt;/code&gt; , то возвращаемый &lt;code&gt;addr&lt;/code&gt; будет ненулевым адресом, указывающим на блок памяти, подходящий для хранения экземпляра &lt;code&gt;layout&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="57431fcdddc5fa976aeed322cde258661b0155ef" translate="yes" xml:space="preserve">
          <source>If this method returns null, then ownership of the memory block has not been transferred to this allocator, and the contents of the memory block are unaltered.</source>
          <target state="translated">Если этот метод возвращает ноль,то право собственности на блок памяти не передается этому аллокатору,а содержимое блока памяти не изменяется.</target>
        </trans-unit>
        <trans-unit id="0ffa302b9d10d74aa11c3e8a0d25a30c1712822c" translate="yes" xml:space="preserve">
          <source>If this results in multiple possible candidates, then it is an error, and the receiver must be &lt;a href=&quot;call-expr#disambiguating-function-calls&quot;&gt;converted&lt;/a&gt; to an appropriate receiver type to make the method call.</source>
          <target state="translated">Если это приводит к появлению нескольких возможных кандидатов, то это ошибка, и получатель должен быть &lt;a href=&quot;call-expr#disambiguating-function-calls&quot;&gt;преобразован&lt;/a&gt; в соответствующий тип получателя, чтобы вызвать метод.</target>
        </trans-unit>
        <trans-unit id="09145f758f25c9eb35661be01cc46455e17d7df0" translate="yes" xml:space="preserve">
          <source>If this returns &lt;code&gt;Err&lt;/code&gt;, then the memory block is considered to still represent the original (larger) &lt;code&gt;layout&lt;/code&gt;. None of the block has been carved off for reuse elsewhere, ownership of the memory block has not been transferred, and the contents of the memory block are unaltered.</source>
          <target state="translated">Если это возвращает &lt;code&gt;Err&lt;/code&gt; , тогда считается, что блок памяти по-прежнему представляет исходный (больший) &lt;code&gt;layout&lt;/code&gt; . Ни один из блоков не был вырезан для повторного использования где-либо еще, право собственности на блок памяти не было передано, и содержимое блока памяти не изменилось.</target>
        </trans-unit>
        <trans-unit id="7b6bef076ebe49dc4a2edbad684a0b757b358554" translate="yes" xml:space="preserve">
          <source>If this returns &lt;code&gt;Ok&lt;/code&gt;, then ownership of the memory block referenced by &lt;code&gt;ptr&lt;/code&gt; has been transferred to this allocator. The memory may or may not have been freed, and should be considered unusable (unless of course it was transferred back to the caller again via the return value of this method).</source>
          <target state="translated">Если это возвращает &lt;code&gt;Ok&lt;/code&gt; , значит, право собственности на блок памяти, на который ссылается &lt;code&gt;ptr&lt;/code&gt; , было передано этому распределителю. Память может быть освобождена, а может и не быть, и ее следует рассматривать как непригодную для использования (если, конечно, она не была снова передана вызывающей стороне через возвращаемое значение этого метода).</target>
        </trans-unit>
        <trans-unit id="d418fdb16ac3dec6f2998c32246199d93bd8ccd1" translate="yes" xml:space="preserve">
          <source>If this returns &lt;code&gt;Ok&lt;/code&gt;, then ownership of the memory block referenced by &lt;code&gt;ptr&lt;/code&gt; has been transferred to this allocator. The memory may or may not have been freed, and should be considered unusable unless it was transferred back to the caller again via the return value of this method.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b07b65f6bada4aa52d604e0c09ea706a071d0221" translate="yes" xml:space="preserve">
          <source>If this returns &lt;code&gt;Ok&lt;/code&gt;, then the allocator has asserted that the memory block referenced by &lt;code&gt;ptr&lt;/code&gt; now fits &lt;code&gt;new_size&lt;/code&gt;, and thus can be used to carry data of a layout of that size and same alignment as &lt;code&gt;layout&lt;/code&gt;. (The allocator is allowed to expend effort to accomplish this, such as extending the memory block to include successor blocks, or virtual memory tricks.)</source>
          <target state="translated">Если это возвращает &lt;code&gt;Ok&lt;/code&gt; , то распределитель утверждал, что блок памяти, на который ссылается &lt;code&gt;ptr&lt;/code&gt; , теперь соответствует &lt;code&gt;new_size&lt;/code&gt; и, таким образом, может использоваться для переноса данных макета такого размера и того же выравнивания, что и &lt;code&gt;layout&lt;/code&gt; . (Распределителю разрешено прилагать усилия для достижения этой цели, например, расширять блок памяти для включения последующих блоков или уловки с виртуальной памятью.)</target>
        </trans-unit>
        <trans-unit id="265c1e3719888af4af19b397644a5084b5b82f03" translate="yes" xml:space="preserve">
          <source>If this returns &lt;code&gt;Ok&lt;/code&gt;, then the allocator has asserted that the memory block referenced by &lt;code&gt;ptr&lt;/code&gt; now fits &lt;code&gt;new_size&lt;/code&gt;, and thus can only be used to carry data of that smaller layout. (The allocator is allowed to take advantage of this, carving off portions of the block for reuse elsewhere.) The truncated contents of the block within the smaller layout are unaltered, and ownership of block has not been transferred.</source>
          <target state="translated">Если это возвращает &lt;code&gt;Ok&lt;/code&gt; , то распределитель утверждает, что блок памяти, на который ссылается &lt;code&gt;ptr&lt;/code&gt; , теперь соответствует &lt;code&gt;new_size&lt;/code&gt; и, таким образом, может использоваться только для переноса данных этого меньшего макета. (Распределитель может воспользоваться этим, вырезая части блока для повторного использования в другом месте.) Усеченное содержимое блока внутри меньшего макета не изменяется, и право собственности на блок не передается.</target>
        </trans-unit>
        <trans-unit id="1e21899c81274a7e69e0d33ce177abd176697388" translate="yes" xml:space="preserve">
          <source>If this returns a non-null pointer, then ownership of the memory block referenced by &lt;code&gt;ptr&lt;/code&gt; has been transferred to this allocator. The memory may or may not have been deallocated, and should be considered unusable (unless of course it was transferred back to the caller again via the return value of this method).</source>
          <target state="translated">Если это возвращает ненулевой указатель, то право собственности на блок памяти, на который ссылается &lt;code&gt;ptr&lt;/code&gt; , было передано этому распределителю. Память может быть освобождена, а может и не быть, и ее следует считать непригодной для использования (если, конечно, она не была снова передана вызывающей стороне через возвращаемое значение этого метода).</target>
        </trans-unit>
        <trans-unit id="8d4043cdbda910f0ad6a1a1cd5c98aae741eec3c" translate="yes" xml:space="preserve">
          <source>If this returns a non-null pointer, then ownership of the memory block referenced by &lt;code&gt;ptr&lt;/code&gt; has been transferred to this allocator. The memory may or may not have been deallocated, and should be considered unusable (unless of course it was transferred back to the caller again via the return value of this method). The new memory block is allocated with &lt;code&gt;layout&lt;/code&gt;, but with the &lt;code&gt;size&lt;/code&gt; updated to &lt;code&gt;new_size&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7d52bbe20c5aac68705e76e7c5e6b2bad9de5e10" translate="yes" xml:space="preserve">
          <source>If this slice is not partitioned, the returned result is unspecified and meaningless, as this method performs a kind of binary search.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2533e7aaf9faf4802db49c2aac243e2b2261233a" translate="yes" xml:space="preserve">
          <source>If this syntax is used, then the number of characters to print precedes the actual object being formatted, and the number of characters must have the type &lt;a href=&quot;../primitive.usize&quot;&gt;&lt;code&gt;usize&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Если используется этот синтаксис, то количество символов для печати предшествует фактическому форматируемому объекту, а количество символов должно иметь тип &lt;a href=&quot;../primitive.usize&quot;&gt; &lt;code&gt;usize&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="64b179337be99298379500e406a343560aae2c69" translate="yes" xml:space="preserve">
          <source>If this would overflow the range of values supported by &lt;code&gt;Self&lt;/code&gt;, returns &lt;code&gt;None&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4b27728b02e3e78c5d0c38db43dde768cdde4959" translate="yes" xml:space="preserve">
          <source>If this would overflow the range of values supported by &lt;code&gt;Self&lt;/code&gt;, this function is allowed to panic, wrap, or saturate. The suggested behavior is to panic when debug assertions are enabled, and to wrap or saturate otherwise.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d0df7d71ccb9fef6722d0478c8d5e8fc86939d3f" translate="yes" xml:space="preserve">
          <source>If two matched elements are directly adjacent, an empty slice will be present between them:</source>
          <target state="translated">Если два совпадающих элемента находятся непосредственно рядом,то между ними будет присутствовать пустой кусок:</target>
        </trans-unit>
        <trans-unit id="aba72b6261d8cf54f8817ecf4602e9f657125528" translate="yes" xml:space="preserve">
          <source>If two sequence have equivalent elements and are of the same length, then the sequences are lexicographically equal.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e3d45eebf9b7ed122af4ed423facfc2fe8966ab8" translate="yes" xml:space="preserve">
          <source>If we &lt;em&gt;do&lt;/em&gt; want to deeply copy the heap data of the &lt;code&gt;String&lt;/code&gt;, not just the stack data, we can use a common method called &lt;code&gt;clone&lt;/code&gt;. We&amp;rsquo;ll discuss method syntax in Chapter 5, but because methods are a common feature in many programming languages, you&amp;rsquo;ve probably seen them before.</source>
          <target state="translated">Если мы &lt;em&gt;действительно&lt;/em&gt; хотим глубоко скопировать данные кучи &lt;code&gt;String&lt;/code&gt; , а не только данные стека, мы можем использовать общий метод, называемый &lt;code&gt;clone&lt;/code&gt; . Мы обсудим синтаксис методов в главе 5, но поскольку методы являются общей особенностью многих языков программирования, вы, вероятно, видели их раньше.</target>
        </trans-unit>
        <trans-unit id="401dbe72f6e067cf29a630716f3d3b23f7eb7742" translate="yes" xml:space="preserve">
          <source>If we compile this code right now, we&amp;rsquo;ll get this error:</source>
          <target state="translated">Если мы скомпилируем этот код прямо сейчас, мы получим такую ​​ошибку:</target>
        </trans-unit>
        <trans-unit id="47e134e66136b075454568cd0131337b49150e26" translate="yes" xml:space="preserve">
          <source>If we continue reading the errors, we&amp;rsquo;ll find this helpful note:</source>
          <target state="translated">Если мы продолжим читать ошибки, мы найдем это полезное примечание:</target>
        </trans-unit>
        <trans-unit id="d42c7d1da5d982e675dccc0a9e2a41b79cecc88f" translate="yes" xml:space="preserve">
          <source>If we control the definition of a type, we can implement &lt;code&gt;Clone&lt;/code&gt; on it ourselves with &lt;code&gt;#[derive(Clone)]&lt;/code&gt;.</source>
          <target state="translated">Если мы управляем определением типа, мы можем реализовать для него &lt;code&gt;Clone&lt;/code&gt; самостоятельно с помощью &lt;code&gt;#[derive(Clone)]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="87e3953b2e8c7c5293b9804529d84ebcbc0b39fd" translate="yes" xml:space="preserve">
          <source>If we don&amp;rsquo;t add the type annotation here, Rust will display the following error, which means the compiler needs more information from us to know which type we want to use:</source>
          <target state="translated">Если мы не добавим здесь аннотацию типа, Rust отобразит следующую ошибку, что означает, что компилятору требуется дополнительная информация от нас, чтобы узнать, какой тип мы хотим использовать:</target>
        </trans-unit>
        <trans-unit id="64f181d4acc8150a490f15e9bd18aaaa910dbc02" translate="yes" xml:space="preserve">
          <source>If we don&amp;rsquo;t want to restrict the &lt;code&gt;largest&lt;/code&gt; function to the types that implement the &lt;code&gt;Copy&lt;/code&gt; trait, we could specify that &lt;code&gt;T&lt;/code&gt; has the trait bound &lt;code&gt;Clone&lt;/code&gt; instead of &lt;code&gt;Copy&lt;/code&gt;. Then we could clone each value in the slice when we want the &lt;code&gt;largest&lt;/code&gt; function to have ownership. Using the &lt;code&gt;clone&lt;/code&gt; function means we&amp;rsquo;re potentially making more heap allocations in the case of types that own heap data like &lt;code&gt;String&lt;/code&gt;, and heap allocations can be slow if we&amp;rsquo;re working with large amounts of data.</source>
          <target state="translated">Если мы не хотим ограничивать самую &lt;code&gt;largest&lt;/code&gt; функцию типами, реализующими черту &lt;code&gt;Copy&lt;/code&gt; , мы могли бы указать, что &lt;code&gt;T&lt;/code&gt; имеет привязку свойства &lt;code&gt;Clone&lt;/code&gt; вместо &lt;code&gt;Copy&lt;/code&gt; . Затем мы могли бы клонировать каждое значение в срезе, когда мы хотим, чтобы самая &lt;code&gt;largest&lt;/code&gt; функция имела право собственности. Использование функции &lt;code&gt;clone&lt;/code&gt; означает, что мы потенциально можем выделять больше кучи в случае типов, которые владеют данными кучи, такими как &lt;code&gt;String&lt;/code&gt; , и распределение кучи может быть медленным, если мы работаем с большими объемами данных.</target>
        </trans-unit>
        <trans-unit id="9f4e2a91ce5b3d093909a51433f578b35d100485" translate="yes" xml:space="preserve">
          <source>If we forget the lifetime annotations and try to compile this function, we&amp;rsquo;ll get this error:</source>
          <target state="translated">Если мы забудем аннотации времени жизни и попытаемся скомпилировать эту функцию, мы получим такую ​​ошибку:</target>
        </trans-unit>
        <trans-unit id="d50142aed73fdab3ce99830192ece11c222bce36" translate="yes" xml:space="preserve">
          <source>If we get the lock on the mutex, we call &lt;code&gt;recv&lt;/code&gt; to receive a &lt;code&gt;Job&lt;/code&gt; from the channel. A final &lt;code&gt;unwrap&lt;/code&gt; moves past any errors here as well, which might occur if the thread holding the sending side of the channel has shut down, similar to how the &lt;code&gt;send&lt;/code&gt; method returns &lt;code&gt;Err&lt;/code&gt; if the receiving side shuts down.</source>
          <target state="translated">Если мы получаем блокировку мьютекса, мы вызываем &lt;code&gt;recv&lt;/code&gt; , чтобы получить &lt;code&gt;Job&lt;/code&gt; из канала. Окончательная &lt;code&gt;unwrap&lt;/code&gt; проходит мимо любых ошибок, которые могут возникнуть, если поток, удерживающий отправляющую сторону канала, отключился, аналогично тому, как метод &lt;code&gt;send&lt;/code&gt; возвращает &lt;code&gt;Err&lt;/code&gt; , если принимающая сторона завершает работу.</target>
        </trans-unit>
        <trans-unit id="0fca700376fa2044b0a30ebcc11fb4a985b05812" translate="yes" xml:space="preserve">
          <source>If we hadn&amp;rsquo;t listed the &lt;code&gt;use std::io&lt;/code&gt; line at the beginning of the program, we could have written this function call as &lt;code&gt;std::io::stdin&lt;/code&gt;. The &lt;code&gt;stdin&lt;/code&gt; function returns an instance of &lt;a href=&quot;../std/io/struct.stdin&quot;&gt;&lt;code&gt;std::io::Stdin&lt;/code&gt;&lt;/a&gt;, which is a type that represents a handle to the standard input for your terminal.</source>
          <target state="translated">Если бы мы не указали строку &lt;code&gt;use std::io&lt;/code&gt; в начале программы, мы могли бы записать этот вызов функции как &lt;code&gt;std::io::stdin&lt;/code&gt; . Функция &lt;code&gt;stdin&lt;/code&gt; возвращает экземпляр &lt;a href=&quot;../std/io/struct.stdin&quot;&gt; &lt;code&gt;std::io::Stdin&lt;/code&gt; &lt;/a&gt; , который представляет собой тип, представляющий дескриптор стандартного ввода для вашего терминала.</target>
        </trans-unit>
        <trans-unit id="04a189966ad80f06981ca07607a5760233b03d38" translate="yes" xml:space="preserve">
          <source>If we hadn&amp;rsquo;t put the &lt;code&gt;use std::io&lt;/code&gt; line at the beginning of the program, we could have written this function call as &lt;code&gt;std::io::stdin&lt;/code&gt;. The &lt;code&gt;stdin&lt;/code&gt; function returns an instance of &lt;a href=&quot;../std/io/struct.stdin&quot;&gt;&lt;code&gt;std::io::Stdin&lt;/code&gt;&lt;/a&gt;, which is a type that represents a handle to the standard input for your terminal.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="86bab42cdbe16f85be0625509956004f41556e40" translate="yes" xml:space="preserve">
          <source>If we have a more complex key, calls to &lt;code&gt;insert&lt;/code&gt; will not update the value of the key. For example:</source>
          <target state="translated">Если у нас есть более сложный ключ, вызовы &lt;code&gt;insert&lt;/code&gt; не будут обновлять значение ключа. Например:</target>
        </trans-unit>
        <trans-unit id="3e6f59e85b3f49aeec8c0c885c1d87959b650a9b" translate="yes" xml:space="preserve">
          <source>If we have a string slice, we can pass that directly. If we have a &lt;code&gt;String&lt;/code&gt;, we can pass a slice of the entire &lt;code&gt;String&lt;/code&gt;. Defining a function to take a string slice instead of a reference to a &lt;code&gt;String&lt;/code&gt; makes our API more general and useful without losing any functionality:</source>
          <target state="translated">Если у нас есть фрагмент строки, мы можем передать его напрямую. Если у нас есть &lt;code&gt;String&lt;/code&gt; , мы можем передать часть всей &lt;code&gt;String&lt;/code&gt; . Определение функции для получения фрагмента строки вместо ссылки на &lt;code&gt;String&lt;/code&gt; делает наш API более общим и полезным без потери функциональности:</target>
        </trans-unit>
        <trans-unit id="ac138ffa3b0aa3b072eefcab1045b74eb7d1fd32" translate="yes" xml:space="preserve">
          <source>If we insert a key and a value into a hash map and then insert that same key with a different value, the value associated with that key will be replaced. Even though the code in Listing 8-24 calls &lt;code&gt;insert&lt;/code&gt; twice, the hash map will only contain one key/value pair because we&amp;rsquo;re inserting the value for the Blue team&amp;rsquo;s key both times.</source>
          <target state="translated">Если мы вставим ключ и значение в хэш-карту, а затем вставим тот же ключ с другим значением, значение, связанное с этим ключом, будет заменено. Несмотря на то, что код в листинге 8-24 вызывает &lt;code&gt;insert&lt;/code&gt; дважды, хеш-карта будет содержать только одну пару ключ / значение, потому что мы вставляем значение для ключа синей команды оба раза.</target>
        </trans-unit>
        <trans-unit id="543a3a170d1010f43b117fa4c1442ab0b46b4495" translate="yes" xml:space="preserve">
          <source>If we insert references to values into the hash map, the values won&amp;rsquo;t be moved into the hash map. The values that the references point to must be valid for at least as long as the hash map is valid. We&amp;rsquo;ll talk more about these issues in the &lt;a href=&quot;ch10-03-lifetime-syntax#validating-references-with-lifetimes&quot;&gt;&amp;ldquo;Validating References with Lifetimes&amp;rdquo;&lt;/a&gt; section in Chapter 10.</source>
          <target state="translated">Если мы вставим ссылки на значения в хеш-карту, значения не будут перемещены в хеш-карту. Значения, на которые указывают ссылки, должны быть действительными, по крайней мере, пока действительна хэш-карта. Подробнее об этих проблемах мы поговорим в разделе &lt;a href=&quot;ch10-03-lifetime-syntax#validating-references-with-lifetimes&quot;&gt;&amp;laquo;Проверка ссылок с помощью времени жизни&amp;raquo;&lt;/a&gt; в главе 10.</target>
        </trans-unit>
        <trans-unit id="48b30993a53ec7ab3753fc22f9cfc6b10c4026a3" translate="yes" xml:space="preserve">
          <source>If we look at the Hindi word &amp;ldquo;नमस्ते&amp;rdquo; written in the Devanagari script, it is stored as a vector of &lt;code&gt;u8&lt;/code&gt; values that looks like this:</source>
          <target state="translated">Если мы посмотрим на слово &amp;laquo;&amp;raquo; на хинди, написанное в сценарии Деванагари, оно хранится как вектор значений &lt;code&gt;u8&lt;/code&gt; , который выглядит следующим образом:</target>
        </trans-unit>
        <trans-unit id="ceefcf2e8fb61a92a19892547650cfb486bbbfbc" translate="yes" xml:space="preserve">
          <source>If we need to concatenate multiple strings, the behavior of the &lt;code&gt;+&lt;/code&gt; operator gets unwieldy:</source>
          <target state="translated">Если нам нужно объединить несколько строк, поведение оператора &lt;code&gt;+&lt;/code&gt; становится громоздким:</target>
        </trans-unit>
        <trans-unit id="bef4e363e9355203a78ff831eeab87691d89132c" translate="yes" xml:space="preserve">
          <source>If we run the tests without passing any arguments, as we saw earlier, all the tests will run in parallel:</source>
          <target state="translated">Если мы запустим тесты,не передавая никаких аргументов,как мы видели ранее,то все тесты будут выполняться параллельно:</target>
        </trans-unit>
        <trans-unit id="ef6509c394cc9b5a25c62c835728d6447e229bde" translate="yes" xml:space="preserve">
          <source>If we run this code without a &lt;em&gt;hello.txt&lt;/em&gt; file, we&amp;rsquo;ll see an error message from the &lt;code&gt;panic!&lt;/code&gt; call that the &lt;code&gt;unwrap&lt;/code&gt; method makes:</source>
          <target state="translated">Если мы запустим этот код без файла &lt;em&gt;hello.txt&lt;/em&gt; , мы увидим сообщение об ошибке из-за &lt;code&gt;panic!&lt;/code&gt; вызов, который делает метод &lt;code&gt;unwrap&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="411b71603dc821df269f0168d402fe39b58175ea" translate="yes" xml:space="preserve">
          <source>If we run this code, we get an error message like this:</source>
          <target state="translated">Если мы запустим этот код,то получим такое сообщение об ошибке:</target>
        </trans-unit>
        <trans-unit id="9a30a99adbc91389f388f95d8ce88be5cc567df1" translate="yes" xml:space="preserve">
          <source>If we tried to use &lt;code&gt;s&lt;/code&gt; after the call to &lt;code&gt;takes_ownership&lt;/code&gt;, Rust would throw a compile-time error. These static checks protect us from mistakes. Try adding code to &lt;code&gt;main&lt;/code&gt; that uses &lt;code&gt;s&lt;/code&gt; and &lt;code&gt;x&lt;/code&gt; to see where you can use them and where the ownership rules prevent you from doing so.</source>
          <target state="translated">Если мы попытаемся использовать &lt;code&gt;s&lt;/code&gt; после вызова &lt;code&gt;takes_ownership&lt;/code&gt; , Rust выдаст ошибку времени компиляции. Эти статические проверки защищают нас от ошибок. Попробуйте добавить в &lt;code&gt;main&lt;/code&gt; код, который использует &lt;code&gt;s&lt;/code&gt; и &lt;code&gt;x&lt;/code&gt; , чтобы увидеть, где вы можете их использовать, а где правила владения не позволяют это сделать.</target>
        </trans-unit>
        <trans-unit id="5b3d2369c0d31316ed024d7ec48406786e9f748a" translate="yes" xml:space="preserve">
          <source>If we tried to write &lt;code&gt;assert_eq!(5, y);&lt;/code&gt; instead, we would get this compilation error:</source>
          <target state="translated">Если бы мы попытались написать &lt;code&gt;assert_eq!(5, y);&lt;/code&gt; вместо этого мы получим эту ошибку компиляции:</target>
        </trans-unit>
        <trans-unit id="d0808380a836c64109f92b188e2221162883a939" translate="yes" xml:space="preserve">
          <source>If we try to access the parent of &lt;code&gt;leaf&lt;/code&gt; after the end of the scope, we&amp;rsquo;ll get &lt;code&gt;None&lt;/code&gt; again. At the end of the program, the &lt;code&gt;Rc&amp;lt;Node&amp;gt;&lt;/code&gt; in &lt;code&gt;leaf&lt;/code&gt; has a strong count of 1 and a weak count of 0, because the variable &lt;code&gt;leaf&lt;/code&gt; is now the only reference to the &lt;code&gt;Rc&amp;lt;Node&amp;gt;&lt;/code&gt; again.</source>
          <target state="translated">Если мы попытаемся получить доступ к родительскому элементу &lt;code&gt;leaf&lt;/code&gt; после окончания области видимости, мы снова получим &lt;code&gt;None&lt;/code&gt; . В конце программы &lt;code&gt;Rc&amp;lt;Node&amp;gt;&lt;/code&gt; в &lt;code&gt;leaf&lt;/code&gt; имеет сильный счетчик 1 и слабый счетчик 0, потому что теперь &lt;code&gt;leaf&lt;/code&gt; переменной снова является единственной ссылкой на &lt;code&gt;Rc&amp;lt;Node&amp;gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="dbfc404f11392f04791b1e2ab5a9b874585793ff" translate="yes" xml:space="preserve">
          <source>If we try to call the &lt;code&gt;Drop&lt;/code&gt; trait&amp;rsquo;s &lt;code&gt;drop&lt;/code&gt; method manually by modifying the &lt;code&gt;main&lt;/code&gt; function from Listing 15-14, as shown in Listing 15-15, we&amp;rsquo;ll get a compiler error:</source>
          <target state="translated">Если мы попытаемся вызвать метод &lt;code&gt;Drop&lt;/code&gt; трейта &lt;code&gt;drop&lt;/code&gt; вручную, изменив функцию &lt;code&gt;main&lt;/code&gt; из листинга 15-14, как показано в листинге 15-15, мы получим ошибку компилятора:</target>
        </trans-unit>
        <trans-unit id="508b7cd6a86a635fd3e7f2924e5c92cb610d409e" translate="yes" xml:space="preserve">
          <source>If we try to compile the code in Listing 15-3, we get the error shown in Listing 15-4:</source>
          <target state="translated">Если мы попытаемся скомпилировать код в Листинге 15-3,то получим ошибку,показанную в Листинге 15-4:</target>
        </trans-unit>
        <trans-unit id="356aa3ddcc40c463be6fae51bd6d2da9e98de1a0" translate="yes" xml:space="preserve">
          <source>If we try to implement the &lt;code&gt;longest&lt;/code&gt; function as shown in Listing 10-21, it won&amp;rsquo;t compile.</source>
          <target state="translated">Если мы попытаемся реализовать самую &lt;code&gt;longest&lt;/code&gt; функцию, как показано в Листинге 10-21, она не будет компилироваться.</target>
        </trans-unit>
        <trans-unit id="4115f2934de822135b29f8084e1ef304be3b3698" translate="yes" xml:space="preserve">
          <source>If we try to violate these rules, rather than getting a compiler error as we would with references, the implementation of &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt; will panic at runtime. Listing 15-23 shows a modification of the implementation of &lt;code&gt;send&lt;/code&gt; in Listing 15-22. We&amp;rsquo;re deliberately trying to create two mutable borrows active for the same scope to illustrate that &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt; prevents us from doing this at runtime.</source>
          <target state="translated">Если мы попытаемся нарушить эти правила, вместо того, чтобы получить ошибку компилятора, как в случае со ссылками, реализация &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt; вызовет панику во время выполнения. Листинг 15-23 показывает модификацию реализации &lt;code&gt;send&lt;/code&gt; из Листинга 15-22. Мы намеренно пытаемся создать два изменяемых заимствования, активных для одной и той же области, чтобы проиллюстрировать, что &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt; позволяет нам сделать это во время выполнения.</target>
        </trans-unit>
        <trans-unit id="33490125b250fc49578a0df8c40853722c24e45b" translate="yes" xml:space="preserve">
          <source>If we use &lt;code&gt;None&lt;/code&gt; rather than &lt;code&gt;Some&lt;/code&gt;, we need to tell Rust what type of &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt; we have, because the compiler can&amp;rsquo;t infer the type that the &lt;code&gt;Some&lt;/code&gt; variant will hold by looking only at a &lt;code&gt;None&lt;/code&gt; value.</source>
          <target state="translated">Если мы используем &lt;code&gt;None&lt;/code&gt; , а не &lt;code&gt;Some&lt;/code&gt; , нам нужно сообщить Rust, какой тип &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt; у нас есть, потому что компилятор не может вывести тип, который будет содержать вариант &lt;code&gt;Some&lt;/code&gt; , глядя только на значение &lt;code&gt;None&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="db89280f9463246331f861bb20b0b44756cbd59b" translate="yes" xml:space="preserve">
          <source>If we want to access each element in a vector in turn, we can iterate through all of the elements rather than use indices to access one at a time. Listing 8-8 shows how to use a &lt;code&gt;for&lt;/code&gt; loop to get immutable references to each element in a vector of &lt;code&gt;i32&lt;/code&gt; values and print them.</source>
          <target state="translated">Если мы хотим получить доступ к каждому элементу вектора по очереди, мы можем перебирать все элементы, а не использовать индексы для доступа по одному за раз. В листинге 8-8 показано, как использовать цикл &lt;code&gt;for&lt;/code&gt; для получения неизменяемых ссылок на каждый элемент в векторе значений &lt;code&gt;i32&lt;/code&gt; и их печати.</target>
        </trans-unit>
        <trans-unit id="59b1ce32c14325e5555ecb1473306e5c2ee4df8e" translate="yes" xml:space="preserve">
          <source>If we want to bring &lt;em&gt;all&lt;/em&gt; public items defined in a path into scope, we can specify that path followed by &lt;code&gt;*&lt;/code&gt;, the glob operator:</source>
          <target state="translated">Если мы хотим перенести &lt;em&gt;все&lt;/em&gt; общедоступные элементы, определенные в пути, в область видимости, мы можем указать этот путь, за которым следует &lt;code&gt;*&lt;/code&gt; , оператор glob:</target>
        </trans-unit>
        <trans-unit id="ecacd2ec61672bd426d468428f535112c37b0728" translate="yes" xml:space="preserve">
          <source>If we want to see printed values for passing tests as well, we can disable the output capture behavior by using the &lt;code&gt;--nocapture&lt;/code&gt; flag:</source>
          <target state="translated">Если мы хотим видеть напечатанные значения для прохождения тестов, мы можем отключить поведение захвата вывода с помощью флага &lt;code&gt;--nocapture&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="05c7ba5ef2e7723af5524e8b4d89c5b4dc32b80d" translate="yes" xml:space="preserve">
          <source>If we want to see printed values for passing tests as well, we can tell Rust to also show the output of successful tests at the end with &lt;code&gt;--show-output&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8a582928a24dff1951656692ced5e56692b89dd3" translate="yes" xml:space="preserve">
          <source>If we wanted this function to allow &lt;code&gt;item1&lt;/code&gt; and &lt;code&gt;item2&lt;/code&gt; to have different types, using &lt;code&gt;impl Trait&lt;/code&gt; would be appropriate (as long as both types implement &lt;code&gt;Summary&lt;/code&gt;). If we wanted to force both parameters to have the same type, that&amp;rsquo;s only possible to express using a trait bound, like this:</source>
          <target state="translated">Если бы мы хотели, чтобы эта функция позволяла &lt;code&gt;item1&lt;/code&gt; и &lt;code&gt;item2&lt;/code&gt; иметь разные типы, было бы уместно использовать &lt;code&gt;impl Trait&lt;/code&gt; (если оба типа реализуют &lt;code&gt;Summary&lt;/code&gt; ). Если бы мы хотели заставить оба параметра иметь один и тот же тип, это можно было бы выразить только с помощью привязки трейта, например:</target>
        </trans-unit>
        <trans-unit id="081b049808c06cb466640ee9a7514dc2c103759d" translate="yes" xml:space="preserve">
          <source>If we wanted to ignore one or more of the values in the tuple, we could use &lt;code&gt;_&lt;/code&gt; or &lt;code&gt;..&lt;/code&gt;, as you&amp;rsquo;ll see in the &lt;a href=&quot;ch18-03-pattern-syntax#ignoring-values-in-a-pattern&quot;&gt;&amp;ldquo;Ignoring Values in a Pattern&amp;rdquo;&lt;/a&gt; section. If the problem is that we have too many variables in the pattern, the solution is to make the types match by removing variables so the number of variables equals the number of elements in the tuple.</source>
          <target state="translated">Если мы хотим игнорировать одно или несколько значений в кортеже, мы могли бы использовать &lt;code&gt;_&lt;/code&gt; или &lt;code&gt;..&lt;/code&gt; , как вы увидите в разделе &lt;a href=&quot;ch18-03-pattern-syntax#ignoring-values-in-a-pattern&quot;&gt;&amp;laquo;Игнорирование значений в шаблоне&amp;raquo;&lt;/a&gt; . Если проблема в том, что у нас слишком много переменных в шаблоне, решение состоит в том, чтобы согласовать типы, удалив переменные, чтобы количество переменных равнялось количеству элементов в кортеже.</target>
        </trans-unit>
        <trans-unit id="43509b2eb6e52b66cb9ff0f7f464bfc498c6c385" translate="yes" xml:space="preserve">
          <source>If we were allowed to run this code, there&amp;rsquo;s a possibility the spawned thread would be immediately put in the background without running at all. The spawned thread has a reference to &lt;code&gt;v&lt;/code&gt; inside, but the main thread immediately drops &lt;code&gt;v&lt;/code&gt;, using the &lt;code&gt;drop&lt;/code&gt; function we discussed in Chapter 15. Then, when the spawned thread starts to execute, &lt;code&gt;v&lt;/code&gt; is no longer valid, so a reference to it is also invalid. Oh no!</source>
          <target state="translated">Если бы нам разрешили запускать этот код, есть вероятность, что порожденный поток будет немедленно переведен в фоновый режим без запуска. Созданный поток имеет ссылку на &lt;code&gt;v&lt;/code&gt; внутри, но основной поток немедленно отбрасывает &lt;code&gt;v&lt;/code&gt; , используя функцию &lt;code&gt;drop&lt;/code&gt; мы обсуждали в главе 15. Затем, когда порожденный поток начинает выполняться, &lt;code&gt;v&lt;/code&gt; больше не действителен, поэтому ссылка на него также недействителен. о нет!</target>
        </trans-unit>
        <trans-unit id="800a58868e2237c8fac619c4b8e2c0a22bb50724" translate="yes" xml:space="preserve">
          <source>If we were to call &lt;code&gt;value_in_cents(Coin::Quarter(UsState::Alaska))&lt;/code&gt;, &lt;code&gt;coin&lt;/code&gt; would be &lt;code&gt;Coin::Quarter(UsState::Alaska)&lt;/code&gt;. When we compare that value with each of the match arms, none of them match until we reach &lt;code&gt;Coin::Quarter(state)&lt;/code&gt;. At that point, the binding for &lt;code&gt;state&lt;/code&gt; will be the value &lt;code&gt;UsState::Alaska&lt;/code&gt;. We can then use that binding in the &lt;code&gt;println!&lt;/code&gt; expression, thus getting the inner state value out of the &lt;code&gt;Coin&lt;/code&gt; enum variant for &lt;code&gt;Quarter&lt;/code&gt;.</source>
          <target state="translated">Если бы мы вызывали &lt;code&gt;value_in_cents(Coin::Quarter(UsState::Alaska))&lt;/code&gt; , &lt;code&gt;coin&lt;/code&gt; была бы &lt;code&gt;Coin::Quarter(UsState::Alaska)&lt;/code&gt; . Когда мы сравниваем это значение с каждой из совпадающих ветвей, ни одно из них не соответствует, пока мы не достигнем &lt;code&gt;Coin::Quarter(state)&lt;/code&gt; . В этот момент привязкой для &lt;code&gt;state&lt;/code&gt; будет значение &lt;code&gt;UsState::Alaska&lt;/code&gt; . Затем мы можем использовать эту привязку в &lt;code&gt;println!&lt;/code&gt; выражение, таким образом получая значение внутреннего состояния из варианта перечисления &lt;code&gt;Coin&lt;/code&gt; для &lt;code&gt;Quarter&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="24bb7707d39d3c3128c279561fde2df4d9c496d5" translate="yes" xml:space="preserve">
          <source>If we were to create an alternative implementation that didn&amp;rsquo;t use the state pattern, we might instead use &lt;code&gt;match&lt;/code&gt; expressions in the methods on &lt;code&gt;Post&lt;/code&gt; or even in the &lt;code&gt;main&lt;/code&gt; code that checks the state of the post and changes behavior in those places. That would mean we would have to look in several places to understand all the implications of a post being in the published state! This would only increase the more states we added: each of those &lt;code&gt;match&lt;/code&gt; expressions would need another arm.</source>
          <target state="translated">Если бы мы должны были создать альтернативную реализацию, не использовать государственную картину, мы могли бы использовать вместо &lt;code&gt;match&lt;/code&gt; выражений в методах на &lt;code&gt;Post&lt;/code&gt; или даже в &lt;code&gt;main&lt;/code&gt; коде , который проверяет состояние должности и изменений поведения в этих местах. Это означало бы, что нам нужно было бы поискать в нескольких местах, чтобы понять все последствия нахождения сообщения в опубликованном состоянии! Это только увеличит больше состояний , мы добавили: каждый из этих &lt;code&gt;match&lt;/code&gt; выражений будет нужна еще одна рука.</target>
        </trans-unit>
        <trans-unit id="75317df9fc9654e5dff79b3ede765cb275596098" translate="yes" xml:space="preserve">
          <source>If we&amp;rsquo;re using multiple items defined in the same crate or same module, listing each item on its own line can take up a lot of vertical space in our files. For example, these two &lt;code&gt;use&lt;/code&gt; statements we had in the Guessing Game in Listing 2-4 bring items from &lt;code&gt;std&lt;/code&gt; into scope:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8c510fe09c79d935a20cfb821edcb59eeece4e5e" translate="yes" xml:space="preserve">
          <source>If we&amp;rsquo;re using multiple items defined in the same package or same module, listing each item on its own line can take up a lot of vertical space in our files. For example, these two &lt;code&gt;use&lt;/code&gt; statements we had in Listing 2-4 in the Guessing Game bring items from &lt;code&gt;std&lt;/code&gt; into scope:</source>
          <target state="translated">Если мы используем несколько элементов, определенных в одном пакете или одном модуле, перечисление каждого элемента в отдельной строке может занять много места по вертикали в наших файлах. Например, эти два оператора &lt;code&gt;use&lt;/code&gt; ,которые мы использовали в листинге 2-4 в игре &amp;laquo;Угадайка&amp;raquo;, переносят элементы из &lt;code&gt;std&lt;/code&gt; в область видимости:</target>
        </trans-unit>
        <trans-unit id="1e5c7c085207b2b3646e21a3cf1669e6a93ba6f6" translate="yes" xml:space="preserve">
          <source>If you &lt;em&gt;do&lt;/em&gt; write that in Rust, the compiler will give you a warning (by default, controlled by the &lt;code&gt;unused_must_use&lt;/code&gt; lint).</source>
          <target state="translated">Если вы &lt;em&gt;делаете&lt;/em&gt; запись , что в Русте, компилятор выдаст вам предупреждение (по умолчанию, контролируемое &lt;code&gt;unused_must_use&lt;/code&gt; пух).</target>
        </trans-unit>
        <trans-unit id="0b6f4208cc3cd5d0efb30ee565f817f70bd28255" translate="yes" xml:space="preserve">
          <source>If you already know the name of what you are looking for, the fastest way to find it is to use the search bar at the top of the page.</source>
          <target state="translated">Если вы уже знаете название того,что ищете,то самый быстрый способ найти его-воспользоваться поисковой панелью в верхней части страницы.</target>
        </trans-unit>
        <trans-unit id="6ecce765aae2c5dfe3bf74974f6a9aa5e5412c0c" translate="yes" xml:space="preserve">
          <source>If you are defining your own smart pointer type and would like to enable conversion from a sized to an unsized type with the &lt;a href=&quot;https://github.com/rust-lang/rfcs/blob/master/text/0982-dst-coercion.md&quot;&gt;DST coercion system&lt;/a&gt;, use &lt;a href=&quot;std/ops/trait.coerceunsized&quot;&gt;&lt;code&gt;CoerceUnsized&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">Если вы определяете свой собственный тип интеллектуального указателя и хотите разрешить преобразование из размера в тип без размера с помощью системы приведения &lt;a href=&quot;https://github.com/rust-lang/rfcs/blob/master/text/0982-dst-coercion.md&quot;&gt;DST&lt;/a&gt; , используйте вместо этого &lt;a href=&quot;std/ops/trait.coerceunsized&quot;&gt; &lt;code&gt;CoerceUnsized&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="66477a0847de02b7542626d1278a3f568234bcb5" translate="yes" xml:space="preserve">
          <source>If you are good at thinking in types, you can think of &lt;code&gt;map()&lt;/code&gt; like this: If you have an iterator that gives you elements of some type &lt;code&gt;A&lt;/code&gt;, and you want an iterator of some other type &lt;code&gt;B&lt;/code&gt;, you can use &lt;code&gt;map()&lt;/code&gt;, passing a closure that takes an &lt;code&gt;A&lt;/code&gt; and returns a &lt;code&gt;B&lt;/code&gt;.</source>
          <target state="translated">Если вы умеете мыслить типами, вы можете думать о &lt;code&gt;map()&lt;/code&gt; следующим образом: если у вас есть итератор, который дает вам элементы некоторого типа &lt;code&gt;A&lt;/code&gt; , и вам нужен итератор другого типа &lt;code&gt;B&lt;/code&gt; , вы можете использовать &lt;code&gt;map()&lt;/code&gt; , проходя замыкание , который принимает &lt;code&gt;A&lt;/code&gt; и возвращает &lt;code&gt;B&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3dcd4a0e63a2a163e2870bf93d8878778590c39f" translate="yes" xml:space="preserve">
          <source>If you are sure that the byte slice is valid UTF-8, and you don't want to incur the overhead of the conversion, there is an unsafe version of this function, &lt;a href=&quot;struct.string#method.from_utf8_unchecked&quot;&gt;&lt;code&gt;from_utf8_unchecked&lt;/code&gt;&lt;/a&gt;, which has the same behavior but skips the checks.</source>
          <target state="translated">Если вы уверены, что байтовый фрагмент является допустимым UTF-8, и не хотите нести накладные расходы на преобразование, существует небезопасная версия этой функции &lt;a href=&quot;struct.string#method.from_utf8_unchecked&quot;&gt; &lt;code&gt;from_utf8_unchecked&lt;/code&gt; &lt;/a&gt; , которая имеет то же поведение, но пропускает проверки.</target>
        </trans-unit>
        <trans-unit id="70a26cf07cad3d4651db91a560fa471c2d93cbb7" translate="yes" xml:space="preserve">
          <source>If you are sure that the byte slice is valid UTF-8, and you don't want to incur the overhead of the validity check, there is an unsafe version of this function, &lt;a href=&quot;fn.from_utf8_unchecked&quot;&gt;&lt;code&gt;from_utf8_unchecked&lt;/code&gt;&lt;/a&gt;, which has the same behavior but skips the check.</source>
          <target state="translated">Если вы уверены, что байтовый фрагмент является допустимым UTF-8, и не хотите нести накладные расходы на проверку действительности, существует небезопасная версия этой функции &lt;a href=&quot;fn.from_utf8_unchecked&quot;&gt; &lt;code&gt;from_utf8_unchecked&lt;/code&gt; &lt;/a&gt; , которая имеет такое же поведение, но пропускает проверку.</target>
        </trans-unit>
        <trans-unit id="72764b3fde213adc88d425dd4be37c972ecfcc18" translate="yes" xml:space="preserve">
          <source>If you are sure that the byte slice is valid UTF-8, and you don't want to incur the overhead of the validity check, there is an unsafe version of this function, &lt;a href=&quot;struct.string#method.from_utf8_unchecked&quot;&gt;&lt;code&gt;from_utf8_unchecked&lt;/code&gt;&lt;/a&gt;, which has the same behavior but skips the check.</source>
          <target state="translated">Если вы уверены, что байтовый фрагмент является допустимым UTF-8, и не хотите нести накладные расходы на проверку действительности, существует небезопасная версия этой функции &lt;a href=&quot;struct.string#method.from_utf8_unchecked&quot;&gt; &lt;code&gt;from_utf8_unchecked&lt;/code&gt; &lt;/a&gt; , которая имеет такое же поведение, но пропускает проверку.</target>
        </trans-unit>
        <trans-unit id="ec9b3e217ed7bc91bb00c80e7f9d1bd56da37e45" translate="yes" xml:space="preserve">
          <source>If you are sure the pointer can never be null and are looking for some kind of &lt;code&gt;as_mut_unchecked&lt;/code&gt; that returns the &lt;code&gt;&amp;amp;mut T&lt;/code&gt; instead of &lt;code&gt;Option&amp;lt;&amp;amp;mut T&amp;gt;&lt;/code&gt;, know that you can dereference the pointer directly.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4e4c7437a6a564088a56f1865abca59f4d577976" translate="yes" xml:space="preserve">
          <source>If you are sure the pointer can never be null and are looking for some kind of &lt;code&gt;as_ref_unchecked&lt;/code&gt; that returns the &lt;code&gt;&amp;amp;T&lt;/code&gt; instead of &lt;code&gt;Option&amp;lt;&amp;amp;T&amp;gt;&lt;/code&gt;, know that you can dereference the pointer directly.</source>
          <target state="translated">Если вы уверены, что указатель никогда не может быть нулевым, и ищете какой-то &lt;code&gt;as_ref_unchecked&lt;/code&gt; , который возвращает &lt;code&gt;&amp;amp;T&lt;/code&gt; вместо &lt;code&gt;Option&amp;lt;&amp;amp;T&amp;gt;&lt;/code&gt; , знайте, что вы можете разыменовать указатель напрямую.</target>
        </trans-unit>
        <trans-unit id="a8aa6751d5dba0ca9b5b9835bc110d6acd1e850e" translate="yes" xml:space="preserve">
          <source>If you are trying to cast a numeric type to a bool, you can compare it with zero instead:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d1b515d34e658e3eaec145f92af8986a5d9085c3" translate="yes" xml:space="preserve">
          <source>If you are using shorthand field patterns but want to refer to the struct field by a different name, you should rename it explicitly.</source>
          <target state="translated">Если вы используете шаблоны коротких полей,но хотите ссылаться на поле структуры под другим именем,то следует явно переименовать его.</target>
        </trans-unit>
        <trans-unit id="667b81601454358fbbba0b10884eb54779935f54" translate="yes" xml:space="preserve">
          <source>If you are using shorthand field patterns but want to refer to the struct field by a different name, you should rename it explicitly. Struct fields are identified by the name used before the colon &lt;code&gt;:&lt;/code&gt; so struct patterns should resemble the declaration of the struct type being matched.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="52d98e4ed274b2f1754b60874045cd81c4a04b5d" translate="yes" xml:space="preserve">
          <source>If you are writing a program that will process an existing file format, check what that format's definition of whitespace is before using this function.</source>
          <target state="translated">Если вы пишете программу,которая будет обрабатывать существующий формат файла,проверьте определение пробела в этом формате,прежде чем использовать эту функцию.</target>
        </trans-unit>
        <trans-unit id="3049570361a92b7df46a925de03339dbac72cca9" translate="yes" xml:space="preserve">
          <source>If you cannot access the directory containing the file, e.g., because of a permission error, this will return &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">Если вы не можете получить доступ к каталогу, содержащему файл, например, из-за ошибки разрешения, это вернет &lt;code&gt;false&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="458a7fb4ac06186fc13af81b6a29de1ace17f81e" translate="yes" xml:space="preserve">
          <source>If you cannot use the &lt;code&gt;derive&lt;/code&gt; strategy, specify that your type implements &lt;code&gt;Eq&lt;/code&gt;, which has no methods:</source>
          <target state="translated">Если вы не можете использовать стратегию &lt;code&gt;derive&lt;/code&gt; , укажите, что ваш тип реализует &lt;code&gt;Eq&lt;/code&gt; , у которого нет методов:</target>
        </trans-unit>
        <trans-unit id="d0466a77e31d18684a221949891d87548a998d3f" translate="yes" xml:space="preserve">
          <source>If you create a safe reference with lifetime &lt;code&gt;'a&lt;/code&gt; (either a &lt;code&gt;&amp;amp;T&lt;/code&gt; or &lt;code&gt;&amp;amp;mut T&lt;/code&gt; reference) that is accessible by safe code (for example, because you returned it), then you must not access the data in any way that contradicts that reference for the remainder of &lt;code&gt;'a&lt;/code&gt;. For example, this means that if you take the &lt;code&gt;*mut T&lt;/code&gt; from an &lt;code&gt;UnsafeCell&amp;lt;T&amp;gt;&lt;/code&gt; and cast it to an &lt;code&gt;&amp;amp;T&lt;/code&gt;, then the data in &lt;code&gt;T&lt;/code&gt; must remain immutable (modulo any &lt;code&gt;UnsafeCell&lt;/code&gt; data found within &lt;code&gt;T&lt;/code&gt;, of course) until that reference's lifetime expires. Similarly, if you create a &lt;code&gt;&amp;amp;mut T&lt;/code&gt; reference that is released to safe code, then you must not access the data within the &lt;code&gt;UnsafeCell&lt;/code&gt; until that reference expires.</source>
          <target state="translated">Если вы создаете безопасную ссылку с временем жизни &lt;code&gt;'a&lt;/code&gt; ( ссылка на &lt;code&gt;&amp;amp;T&lt;/code&gt; или &lt;code&gt;&amp;amp;mut T&lt;/code&gt; ), которая доступна для безопасного кода (например, потому что вы ее вернули), то вы не должны обращаться к данным каким-либо образом, который противоречит этой ссылке для остаток от &lt;code&gt;'a&lt;/code&gt; . Например, это означает, что если вы берете &lt;code&gt;*mut T&lt;/code&gt; из &lt;code&gt;UnsafeCell&amp;lt;T&amp;gt;&lt;/code&gt; и преобразуете его в &lt;code&gt;&amp;amp;T&lt;/code&gt; , то данные в &lt;code&gt;T&lt;/code&gt; должны оставаться неизменными ( &lt;code&gt;UnsafeCell&lt;/code&gt; по модулю любых данных UnsafeCell, найденных в &lt;code&gt;T&lt;/code&gt; ) до тех пор, пока эта ссылка не истечет. истекает. Аналогично, если вы создадите &lt;code&gt;&amp;amp;mut T&lt;/code&gt; ссылка, выпущенная в безопасный код, то вы не должны обращаться к данным в &lt;code&gt;UnsafeCell&lt;/code&gt; , пока эта ссылка не истечет.</target>
        </trans-unit>
        <trans-unit id="0185ed1fba59b251fe1857608aaa4660006fe514" translate="yes" xml:space="preserve">
          <source>If you create a variable but don&amp;rsquo;t use it anywhere, Rust will usually issue a warning because that could be a bug. But sometimes it&amp;rsquo;s useful to create a variable you won&amp;rsquo;t use yet, such as when you&amp;rsquo;re prototyping or just starting a project. In this situation, you can tell Rust not to warn you about the unused variable by starting the name of the variable with an underscore. In Listing 18-20, we create two unused variables, but when we run this code, we should only get a warning about one of them.</source>
          <target state="translated">Если вы создаете переменную, но нигде ее не используете, Rust обычно выдает предупреждение, потому что это может быть ошибкой. Но иногда полезно создать переменную, которую вы еще не будете использовать, например, когда вы создаете прототип или только начинаете проект. В этой ситуации вы можете указать Rust не предупреждать вас о неиспользуемой переменной, начав имя переменной с подчеркивания. В листинге 18-20 мы создаем две неиспользуемые переменные, но когда мы запускаем этот код, мы должны получить предупреждение только об одной из них.</target>
        </trans-unit>
        <trans-unit id="53d962e32cf41eea1b88858329905f991b93fcaa" translate="yes" xml:space="preserve">
          <source>If you decide to use trait objects, be aware that these rely on &lt;a href=&quot;book/ch17-02-trait-objects#trait-objects-perform-dynamic-dispatch&quot;&gt;dynamic dispatch&lt;/a&gt;, which has performance implications, as the compiler needs to emit code that will figure out which method to call &lt;em&gt;at runtime&lt;/em&gt; instead of during compilation. Using trait objects we are trading flexibility for performance.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="495358664585a670e9065e75b0da97e6c9808c60" translate="yes" xml:space="preserve">
          <source>If you do not have an &lt;code&gt;&amp;amp;T&lt;/code&gt;, but just an &lt;code&gt;&amp;amp;U&lt;/code&gt; such that &lt;code&gt;T: Borrow&amp;lt;U&amp;gt;&lt;/code&gt; (e.g. &lt;code&gt;String: Borrow&amp;lt;str&amp;gt;&lt;/code&gt;), you can use &lt;code&gt;iter().any&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="05624f4cd79d0d50c7459fc7a7809ab013e516d2" translate="yes" xml:space="preserve">
          <source>If you do not want this &quot;at least&quot; behavior, see the &lt;a href=&quot;struct.string#method.reserve_exact&quot;&gt;&lt;code&gt;reserve_exact&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">Если вам не нужно такое поведение &amp;laquo;по крайней мере&amp;raquo;, см. Метод &lt;a href=&quot;struct.string#method.reserve_exact&quot;&gt; &lt;code&gt;reserve_exact&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="3fa75551a6e58e68f711ab2f03a9cc21a66d738a" translate="yes" xml:space="preserve">
          <source>If you don&amp;rsquo;t call &lt;code&gt;expect&lt;/code&gt;, the program will compile, but you&amp;rsquo;ll get a warning:</source>
          <target state="translated">Если вы не вызовете &lt;code&gt;expect&lt;/code&gt; , программа скомпилируется, но вы получите предупреждение:</target>
        </trans-unit>
        <trans-unit id="aa9b352f2a9ad676e75ebea1e09ea589739aa744" translate="yes" xml:space="preserve">
          <source>If you don&amp;rsquo;t want to run the tests in parallel or if you want more fine-grained control over the number of threads used, you can send the &lt;code&gt;--test-threads&lt;/code&gt; flag and the number of threads you want to use to the test binary. Take a look at the following example:</source>
          <target state="translated">Если вы не хотите запускать тесты параллельно или хотите более детальный контроль над количеством используемых потоков, вы можете отправить флаг &lt;code&gt;--test-threads&lt;/code&gt; и количество потоков, которые вы хотите использовать, в тест. двоичный. Взгляните на следующий пример:</target>
        </trans-unit>
        <trans-unit id="8dc704dcbb9c3ebe8a328db6c83f459b5ea12df0" translate="yes" xml:space="preserve">
          <source>If you don't care about signaling-ness (very likely), then there is no portability concern.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="03f408e5bb66764d7ffd1cc87bf60d44d2f11a95" translate="yes" xml:space="preserve">
          <source>If you don't care about signalingness (very likely), then there is no portability concern.</source>
          <target state="translated">Если вас не волнует сигнальность (очень вероятно),то нет никакого беспокойства о переносимости.</target>
        </trans-unit>
        <trans-unit id="eccfed5b1fccd97fad68aa10ed7d3af7af7893a9" translate="yes" xml:space="preserve">
          <source>If you don't know the basics of Rust, you can go look to the Rust Book to get started: https://doc.rust-lang.org/book/</source>
          <target state="translated">Если вы не знаете основ ржавчины,вы можете пойти посмотреть &quot;Книгу ржавчины&quot;,чтобы начать:https://doc.rust-lang.org/book/.</target>
        </trans-unit>
        <trans-unit id="e26edf9b7f412dd5926032771fa72456da3e35ef" translate="yes" xml:space="preserve">
          <source>If you don't know the basics of Rust, you can look at the &lt;a href=&quot;index&quot;&gt;Rust Book&lt;/a&gt; to get started.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bf6d5abeee91a58bb08b86aab21ccdd70a1f28d4" translate="yes" xml:space="preserve">
          <source>If you don't qualify the names, the code will bind new variables named &quot;GET&quot; and &quot;POST&quot; instead. This behavior is likely not what you want, so &lt;code&gt;rustc&lt;/code&gt; warns when that happens.</source>
          <target state="translated">Если вы не уточняете имена, код вместо этого связывает новые переменные с именами &amp;laquo;GET&amp;raquo; и &amp;laquo;POST&amp;raquo;. Такое поведение, скорее всего, не то, что вам нужно, поэтому &lt;code&gt;rustc&lt;/code&gt; предупреждает, когда это происходит.</target>
        </trans-unit>
        <trans-unit id="30e1c43099f6397f247562dd2f5b6571eda814ad" translate="yes" xml:space="preserve">
          <source>If you encounter this error you must alter your patterns so that every possible value of the input type is matched. For types with a small number of variants (like enums) you should probably cover all cases explicitly. Alternatively, the underscore &lt;code&gt;_&lt;/code&gt; wildcard pattern can be added after all other patterns to match &quot;anything else&quot;. Example:</source>
          <target state="translated">Если вы столкнулись с этой ошибкой, вы должны изменить свои шаблоны так, чтобы все возможные значения типа ввода совпадали. Для типов с небольшим количеством вариантов (например, перечислений) вам, вероятно, следует явно охватить все случаи. В качестве альтернативы, шаблон подстановочного знака подчеркивания &lt;code&gt;_&lt;/code&gt; может быть добавлен после всех других шаблонов, чтобы соответствовать &amp;laquo;чему-либо еще&amp;raquo;. Пример:</target>
        </trans-unit>
        <trans-unit id="c99fe79ebb0d8c77c7785b8167d26f6b602a1b29" translate="yes" xml:space="preserve">
          <source>If you encounter this error you probably need to use a &lt;code&gt;match&lt;/code&gt; or &lt;code&gt;if let&lt;/code&gt; to deal with the possibility of failure. Example:</source>
          <target state="translated">Если вы столкнулись с этой ошибкой, вам, вероятно, нужно использовать &lt;code&gt;match&lt;/code&gt; или &lt;code&gt;if let&lt;/code&gt; устранить возможность сбоя. Пример:</target>
        </trans-unit>
        <trans-unit id="289fc8ad6bfff7525b7f4a843265b14e717b2af6" translate="yes" xml:space="preserve">
          <source>If you have a C or C++ background, you&amp;rsquo;ll notice that this is similar to &lt;code&gt;gcc&lt;/code&gt; or &lt;code&gt;clang&lt;/code&gt;. After compiling successfully, Rust outputs a binary executable.</source>
          <target state="translated">Если у вас есть опыт работы с C или C ++, вы заметите, что это похоже на &lt;code&gt;gcc&lt;/code&gt; или &lt;code&gt;clang&lt;/code&gt; . После успешной компиляции Rust выводит двоичный исполняемый файл.</target>
        </trans-unit>
        <trans-unit id="49d7cea9bb89d7aa1e9d9d998c1c8d8fd8ff2825" translate="yes" xml:space="preserve">
          <source>If you have a list of &lt;a href=&quot;../result/enum.result&quot;&gt;&lt;code&gt;Result&amp;lt;T, E&amp;gt;&lt;/code&gt;&lt;/a&gt;s, you can use &lt;code&gt;collect()&lt;/code&gt; to see if any of them failed:</source>
          <target state="translated">Если у вас есть список &lt;a href=&quot;../result/enum.result&quot;&gt; &lt;code&gt;Result&amp;lt;T, E&amp;gt;&lt;/code&gt; &lt;/a&gt; s, вы можете использовать &lt;code&gt;collect()&lt;/code&gt; чтобы узнать, не сработал ли какой-либо из них:</target>
        </trans-unit>
        <trans-unit id="dbb6609dcc94bde15a6614f094acb0b0abfc28f2" translate="yes" xml:space="preserve">
          <source>If you have a reference &lt;code&gt;&amp;amp;SomeStruct&lt;/code&gt;, then normally in Rust all fields of &lt;code&gt;SomeStruct&lt;/code&gt; are immutable. The compiler makes optimizations based on the knowledge that &lt;code&gt;&amp;amp;T&lt;/code&gt; is not mutably aliased or mutated, and that &lt;code&gt;&amp;amp;mut T&lt;/code&gt; is unique. &lt;code&gt;UnsafeCell&amp;lt;T&amp;gt;&lt;/code&gt; is the only core language feature to work around the restriction that &lt;code&gt;&amp;amp;T&lt;/code&gt; may not be mutated. All other types that allow internal mutability, such as &lt;code&gt;Cell&amp;lt;T&amp;gt;&lt;/code&gt; and &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt;, use &lt;code&gt;UnsafeCell&lt;/code&gt; to wrap their internal data. There is &lt;em&gt;no&lt;/em&gt; legal way to obtain aliasing &lt;code&gt;&amp;amp;mut&lt;/code&gt;, not even with &lt;code&gt;UnsafeCell&amp;lt;T&amp;gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="603c68300fca461a298a423a92a14317f38dd713" translate="yes" xml:space="preserve">
          <source>If you have a reference &lt;code&gt;&amp;amp;SomeStruct&lt;/code&gt;, then normally in Rust all fields of &lt;code&gt;SomeStruct&lt;/code&gt; are immutable. The compiler makes optimizations based on the knowledge that &lt;code&gt;&amp;amp;T&lt;/code&gt; is not mutably aliased or mutated, and that &lt;code&gt;&amp;amp;mut T&lt;/code&gt; is unique. &lt;code&gt;UnsafeCell&amp;lt;T&amp;gt;&lt;/code&gt; is the only core language feature to work around this restriction. All other types that allow internal mutability, such as &lt;code&gt;Cell&amp;lt;T&amp;gt;&lt;/code&gt; and &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt;, use &lt;code&gt;UnsafeCell&lt;/code&gt; to wrap their internal data.</source>
          <target state="translated">Если у вас есть ссылка &lt;code&gt;&amp;amp;SomeStruct&lt;/code&gt; , то обычно в Rust все поля &lt;code&gt;SomeStruct&lt;/code&gt; неизменяемы. Компилятор выполняет оптимизацию, зная, что &lt;code&gt;&amp;amp;T&lt;/code&gt; не имеет псевдонимов или мутаций, а &lt;code&gt;&amp;amp;mut T&lt;/code&gt; уникален. &lt;code&gt;UnsafeCell&amp;lt;T&amp;gt;&lt;/code&gt; - единственная функция основного языка, позволяющая обойти это ограничение. Все другие типы, допускающие внутреннюю изменчивость, такие как &lt;code&gt;Cell&amp;lt;T&amp;gt;&lt;/code&gt; и &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt; , используют &lt;code&gt;UnsafeCell&lt;/code&gt; для обертывания своих внутренних данных.</target>
        </trans-unit>
        <trans-unit id="edf1169c29b5f18e94ef5bfa0ce80d44e6e0e706" translate="yes" xml:space="preserve">
          <source>If you have a situation in which your program has logic that is too verbose to express using a &lt;code&gt;match&lt;/code&gt;, remember that &lt;code&gt;if let&lt;/code&gt; is in your Rust toolbox as well.</source>
          <target state="translated">Если у вас есть ситуация, в которой ваша программа имеет слишком подробную логику, чтобы выразить ее с помощью &lt;code&gt;match&lt;/code&gt; , помните, что &lt;code&gt;if let&lt;/code&gt; также есть в вашем наборе инструментов Rust.</target>
        </trans-unit>
        <trans-unit id="4d514f69487626541e99f2f08d0b5ef4bda3e112" translate="yes" xml:space="preserve">
          <source>If you have a vector of UTF-8 bytes, you can create a &lt;code&gt;String&lt;/code&gt; from it with the &lt;a href=&quot;#method.from_utf8&quot;&gt;&lt;code&gt;from_utf8&lt;/code&gt;&lt;/a&gt; method:</source>
          <target state="translated">Если у вас есть вектор байтов UTF-8, вы можете создать из него &lt;code&gt;String&lt;/code&gt; с &lt;a href=&quot;#method.from_utf8&quot;&gt; &lt;code&gt;from_utf8&lt;/code&gt; &lt;/a&gt; метода from_utf8 :</target>
        </trans-unit>
        <trans-unit id="628f5229655ec7d34ffefb0c482b9ec478191d5b" translate="yes" xml:space="preserve">
          <source>If you have a vector of UTF-8 bytes, you can create a &lt;code&gt;String&lt;/code&gt; from it with the &lt;a href=&quot;struct.string#method.from_utf8&quot;&gt;&lt;code&gt;from_utf8&lt;/code&gt;&lt;/a&gt; method:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="594422b6f37e612f2fe4809f8c9021e17bddb83c" translate="yes" xml:space="preserve">
          <source>If you have a vector of valid UTF-8 bytes, you can make a &lt;a href=&quot;struct.string&quot;&gt;&lt;code&gt;String&lt;/code&gt;&lt;/a&gt; out of it. You can do the reverse too.</source>
          <target state="translated">Если у вас есть вектор действительных байтов UTF-8, вы можете сделать из него &lt;a href=&quot;struct.string&quot;&gt; &lt;code&gt;String&lt;/code&gt; &lt;/a&gt; . Вы можете сделать и обратное.</target>
        </trans-unit>
        <trans-unit id="09514694f23f12c4005f6c9a94a1355114b933e9" translate="yes" xml:space="preserve">
          <source>If you have ownership of the &lt;code&gt;MaybeUninit&lt;/code&gt;, you can use &lt;a href=&quot;union.maybeuninit#method.assume_init&quot;&gt;&lt;code&gt;assume_init&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f6ce7a19cbb44d746f329213322cf181c479880e" translate="yes" xml:space="preserve">
          <source>If you have ownership of the container, you can use &lt;a href=&quot;#method.into_inner&quot;&gt;&lt;code&gt;ManuallyDrop::into_inner&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">Если у вас есть владелец контейнера, вы можете вместо этого использовать &lt;a href=&quot;#method.into_inner&quot;&gt; &lt;code&gt;ManuallyDrop::into_inner&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="25db03dcaf36d059be68f895db3dece722d76812" translate="yes" xml:space="preserve">
          <source>If you have ownership of the value, you can use &lt;a href=&quot;#method.into_inner&quot;&gt;&lt;code&gt;ManuallyDrop::into_inner&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">Если вы &lt;a href=&quot;#method.into_inner&quot;&gt; &lt;code&gt;ManuallyDrop::into_inner&lt;/code&gt; &lt;/a&gt; значением, вы можете вместо этого использовать ManuallyDrop :: into_inner .</target>
        </trans-unit>
        <trans-unit id="b2ef31901106431a912012e61b6ed669627013f2" translate="yes" xml:space="preserve">
          <source>If you have ownership of the value, you can use &lt;a href=&quot;struct.manuallydrop#method.into_inner&quot;&gt;&lt;code&gt;ManuallyDrop::into_inner&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cbcd3198f789fbc8cbdd096a8ff06c5c6dfc54d9" translate="yes" xml:space="preserve">
          <source>If you have something that implements &lt;a href=&quot;trait.read&quot;&gt;&lt;code&gt;Read&lt;/code&gt;&lt;/a&gt;, you can use the &lt;a href=&quot;struct.bufreader&quot;&gt;&lt;code&gt;BufReader&lt;/code&gt; type&lt;/a&gt; to turn it into a &lt;code&gt;BufRead&lt;/code&gt;.</source>
          <target state="translated">Если у вас есть что-то, что реализует &lt;a href=&quot;trait.read&quot;&gt; &lt;code&gt;Read&lt;/code&gt; &lt;/a&gt; , вы можете использовать &lt;a href=&quot;struct.bufreader&quot;&gt;тип &lt;/a&gt; &lt;code&gt;BufReader&lt;/code&gt; , чтобы превратить его в &lt;code&gt;BufRead&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="26025a7b33e21d0ed3af5941205257def877195b" translate="yes" xml:space="preserve">
          <source>If you immediately run &lt;code&gt;cargo build&lt;/code&gt; again without making any changes, you won&amp;rsquo;t get any output aside from the &lt;code&gt;Finished&lt;/code&gt; line. Cargo knows it has already downloaded and compiled the dependencies, and you haven&amp;rsquo;t changed anything about them in your &lt;em&gt;Cargo.toml&lt;/em&gt; file. Cargo also knows that you haven&amp;rsquo;t changed anything about your code, so it doesn&amp;rsquo;t recompile that either. With nothing to do, it simply exits.</source>
          <target state="translated">Если вы сразу же снова запустите &lt;code&gt;cargo build&lt;/code&gt; не внося никаких изменений, вы не получите никаких результатов, кроме строки &lt;code&gt;Finished&lt;/code&gt; . Cargo знает, что он уже загрузил и скомпилировал зависимости, и вы ничего не изменили о них в своем файле &lt;em&gt;Cargo.toml&lt;/em&gt; . Cargo также знает, что вы ничего не меняли в своем коде, поэтому не перекомпилирует его. Если нечего делать, он просто выходит.</target>
        </trans-unit>
        <trans-unit id="aead6d9073f2963585c85964dbd5fd9f72b085e1" translate="yes" xml:space="preserve">
          <source>If you need a &lt;a href=&quot;../primitive.str&quot;&gt;&lt;code&gt;&amp;amp;str&lt;/code&gt;&lt;/a&gt; instead of a &lt;code&gt;String&lt;/code&gt;, consider &lt;a href=&quot;../str/fn.from_utf8&quot;&gt;&lt;code&gt;str::from_utf8&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Если вам нужен &lt;a href=&quot;../primitive.str&quot;&gt; &lt;code&gt;&amp;amp;str&lt;/code&gt; &lt;/a&gt; вместо &lt;code&gt;String&lt;/code&gt; , рассмотрите &lt;a href=&quot;../str/fn.from_utf8&quot;&gt; &lt;code&gt;str::from_utf8&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="fadf8ed3eb8dc56d2e21bd202aa9d97fad2da2e5" translate="yes" xml:space="preserve">
          <source>If you need a &lt;code&gt;&amp;amp;[&lt;/code&gt;&lt;a href=&quot;../primitive.u8&quot;&gt;&lt;code&gt;u8&lt;/code&gt;&lt;/a&gt;&lt;code&gt;]&lt;/code&gt; slice &lt;em&gt;with&lt;/em&gt; the nul terminator, you can use &lt;a href=&quot;#method.as_bytes_with_nul&quot;&gt;&lt;code&gt;as_bytes_with_nul&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">Если вам нужен фрагмент &lt;code&gt;&amp;amp;[&lt;/code&gt; &lt;a href=&quot;../primitive.u8&quot;&gt; &lt;code&gt;u8&lt;/code&gt; &lt;/a&gt; &lt;code&gt;]&lt;/code&gt; &lt;em&gt;с&lt;/em&gt; терминатором nul, вы можете использовать вместо него &lt;a href=&quot;#method.as_bytes_with_nul&quot;&gt; &lt;code&gt;as_bytes_with_nul&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="8859e0e13ac4a2988b7250ce45ef124efe28cd7a" translate="yes" xml:space="preserve">
          <source>If you need a &lt;code&gt;&amp;amp;[&lt;/code&gt;&lt;a href=&quot;https://doc.rust-lang.org/nightly/std/primitive.u8.html&quot;&gt;&lt;code&gt;u8&lt;/code&gt;&lt;/a&gt;&lt;code&gt;]&lt;/code&gt; slice &lt;em&gt;with&lt;/em&gt; the nul terminator, you can use &lt;a href=&quot;struct.cstring#method.as_bytes_with_nul&quot;&gt;&lt;code&gt;CString::as_bytes_with_nul&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7efefa0d5ccda958764237a619135366f98b28d8" translate="yes" xml:space="preserve">
          <source>If you need a &lt;code&gt;String&lt;/code&gt; instead of a &lt;code&gt;&amp;amp;str&lt;/code&gt;, consider &lt;a href=&quot;../string/struct.string#method.from_utf8&quot;&gt;&lt;code&gt;String::from_utf8&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Если вам нужна &lt;code&gt;String&lt;/code&gt; вместо &lt;code&gt;&amp;amp;str&lt;/code&gt; , рассмотрите &lt;a href=&quot;../string/struct.string#method.from_utf8&quot;&gt; &lt;code&gt;String::from_utf8&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="45013794627f8d7d5a958593854bff018239ef49" translate="yes" xml:space="preserve">
          <source>If you need a reference to the &lt;code&gt;OccupiedEntry&lt;/code&gt; that may outlive the destruction of the &lt;code&gt;Entry&lt;/code&gt; value, see &lt;a href=&quot;#method.into_mut&quot;&gt;&lt;code&gt;into_mut&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Если вам нужна ссылка на &lt;code&gt;OccupiedEntry&lt;/code&gt; , которая может пережить уничтожение значения &lt;code&gt;Entry&lt;/code&gt; , см. &lt;a href=&quot;#method.into_mut&quot;&gt; &lt;code&gt;into_mut&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="219941c8b5f5991f98f925058a19ec303a64916f" translate="yes" xml:space="preserve">
          <source>If you need a reference to the &lt;code&gt;OccupiedEntry&lt;/code&gt; that may outlive the destruction of the &lt;code&gt;Entry&lt;/code&gt; value, see &lt;a href=&quot;struct.occupiedentry#method.into_mut&quot;&gt;&lt;code&gt;into_mut&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="76f640be80a9e8c1bdad2ee8c022f44a0a1aaaf8" translate="yes" xml:space="preserve">
          <source>If you need a reference to the &lt;code&gt;OccupiedEntry&lt;/code&gt; which may outlive the destruction of the &lt;code&gt;Entry&lt;/code&gt; value, see &lt;a href=&quot;#method.into_mut&quot;&gt;&lt;code&gt;into_mut&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Если вам нужна ссылка на &lt;code&gt;OccupiedEntry&lt;/code&gt; , которая может пережить уничтожение значения &lt;code&gt;Entry&lt;/code&gt; , см. &lt;a href=&quot;#method.into_mut&quot;&gt; &lt;code&gt;into_mut&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="0102aa221685138b4538e7bcf99473f525d3ae0b" translate="yes" xml:space="preserve">
          <source>If you need a reference to the &lt;code&gt;OccupiedEntry&lt;/code&gt; which may outlive the destruction of the &lt;code&gt;Entry&lt;/code&gt; value, see &lt;a href=&quot;struct.occupiedentry#method.into_mut&quot;&gt;&lt;code&gt;into_mut&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a60e3312521d167a8398684f23a8bda2cd769f2d" translate="yes" xml:space="preserve">
          <source>If you need more control over how a value is hashed, you can of course implement the &lt;code&gt;Hash&lt;/code&gt; trait yourself:</source>
          <target state="translated">Если вам нужен больший контроль над хешированием значения, вы, конечно, можете реализовать свойство &lt;code&gt;Hash&lt;/code&gt; самостоятельно:</target>
        </trans-unit>
        <trans-unit id="efc0a9fb0d5d442c54eae5e0575801419c0ddc5b" translate="yes" xml:space="preserve">
          <source>If you need more control over how a value is hashed, you need to implement the &lt;a href=&quot;trait.hash&quot;&gt;&lt;code&gt;Hash&lt;/code&gt;&lt;/a&gt; trait:</source>
          <target state="translated">Если вам нужен больший контроль над тем, как хешируется значение, вам необходимо реализовать черту &lt;a href=&quot;trait.hash&quot;&gt; &lt;code&gt;Hash&lt;/code&gt; &lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="0241681a3d3ab7483e993964ada28ea51777d3f5" translate="yes" xml:space="preserve">
          <source>If you need multiple references to the &lt;code&gt;OccupiedEntry&lt;/code&gt;, see &lt;a href=&quot;#method.get_mut&quot;&gt;&lt;code&gt;get_mut&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Если вам нужно несколько ссылок на &lt;code&gt;OccupiedEntry&lt;/code&gt; , см. &lt;a href=&quot;#method.get_mut&quot;&gt; &lt;code&gt;get_mut&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="c038d740f3ac229d9b9c028c5b74e72acefec36c" translate="yes" xml:space="preserve">
          <source>If you need multiple references to the &lt;code&gt;OccupiedEntry&lt;/code&gt;, see &lt;a href=&quot;struct.occupiedentry#method.get_mut&quot;&gt;&lt;code&gt;get_mut&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="40ade792259bb48c52c18a2f2d1b3c073ea1c7a1" translate="yes" xml:space="preserve">
          <source>If you need the feature, make sure to use a nightly release of the compiler (but be warned that the feature may be removed or altered in the future).</source>
          <target state="translated">Если вам нужна эта возможность,обязательно используйте ночной релиз компилятора (но будьте предупреждены,что в будущем эта возможность может быть удалена или изменена).</target>
        </trans-unit>
        <trans-unit id="8d959103a15d2de9826ef517fc6c5926c4dc9c0f" translate="yes" xml:space="preserve">
          <source>If you need this, there's a good chance you're doing something wrong. Keep in mind that Rust doesn't guarantee much about the layout of different structs (even two structs with identical declarations may have different layouts). If there is a solution that avoids the transmute entirely, try it instead.</source>
          <target state="translated">Если тебе это нужно,есть большая вероятность,что ты делаешь что-то не так.Имейте в виду,что Rust не дает больших гарантий насчет раскладки различных структур (даже две структуры с одинаковыми объявлениями могут иметь разную раскладку).Если есть решение,которое полностью исключает трансмутацию,попробуйте вместо этого.</target>
        </trans-unit>
        <trans-unit id="18db342a00e23c3779573ca28794a36c6f8d6e91" translate="yes" xml:space="preserve">
          <source>If you need to cross object boundaries, cast the pointer to an integer and do the arithmetic there.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5d12ddc464aa8618d85b99bead398fd46eff9e38" translate="yes" xml:space="preserve">
          <source>If you need to obtain the length of &lt;em&gt;many&lt;/em&gt; streams and you don't care about the seek position afterwards, you can reduce the number of seek operations by simply calling &lt;code&gt;seek(SeekFrom::End(0))&lt;/code&gt; and using its return value (it is also the stream length).</source>
          <target state="translated">Если вам нужно получить длину &lt;em&gt;многих&lt;/em&gt; потоков, и вы не заботитесь о позиции поиска впоследствии, вы можете уменьшить количество операций поиска, просто вызвав &lt;code&gt;seek(SeekFrom::End(0))&lt;/code&gt; и используя его возвращаемое значение (it также длина потока).</target>
        </trans-unit>
        <trans-unit id="35592f144aa64ae5ca74cce00e23680445e57820" translate="yes" xml:space="preserve">
          <source>If you need to perform operations on individual Unicode scalar values, the best way to do so is to use the &lt;code&gt;chars&lt;/code&gt; method. Calling &lt;code&gt;chars&lt;/code&gt; on &amp;ldquo;नमस्ते&amp;rdquo; separates out and returns six values of type &lt;code&gt;char&lt;/code&gt;, and you can iterate over the result to access each element:</source>
          <target state="translated">Если вам нужно выполнить операции с отдельными скалярными значениями Unicode, лучший способ сделать это - использовать метод &lt;code&gt;chars&lt;/code&gt; . Вызов &lt;code&gt;chars&lt;/code&gt; &amp;laquo;नमस्ते&amp;raquo; отделяет и возвращает шесть значений типа &lt;code&gt;char&lt;/code&gt; , и вы можете перебирать результат для доступа к каждому элементу:</target>
        </trans-unit>
        <trans-unit id="601e2909b73af510ea23340b158c3431ac0b2075" translate="yes" xml:space="preserve">
          <source>If you only want to import the namespace, do so directly:</source>
          <target state="translated">Если вы хотите импортировать только пространство имён,сделайте это напрямую:</target>
        </trans-unit>
        <trans-unit id="f0344a16618dba921a326e3422d6b25ac64c22ba" translate="yes" xml:space="preserve">
          <source>If you open up the &lt;em&gt;src/main.rs&lt;/em&gt; file, make a trivial change, and then save it and build again, you&amp;rsquo;ll only see two lines of output:</source>
          <target state="translated">Если вы &lt;em&gt;откроете&lt;/em&gt; файл &lt;em&gt;src / main.rs&lt;/em&gt; , сделаете тривиальное изменение, а затем сохраните его и построите заново, вы увидите только две строки вывода:</target>
        </trans-unit>
        <trans-unit id="acc3c2bbba4fb91bf96f0af82ae7667a7148e8e6" translate="yes" xml:space="preserve">
          <source>If you prefer, feel free to download the script and inspect it before running it.</source>
          <target state="translated">Если вы предпочитаете,не стесняйтесь,скачайте сценарий и осмотрите его перед запуском.</target>
        </trans-unit>
        <trans-unit id="b0bfb1242185bbb2e23ce66c3dc2f4aa29788236" translate="yes" xml:space="preserve">
          <source>If you publish the crates in the workspace to &lt;a href=&quot;https://crates.io/&quot;&gt;crates.io&lt;/a&gt;, each crate in the workspace will need to be published separately. The &lt;code&gt;cargo publish&lt;/code&gt; command does not have an &lt;code&gt;--all&lt;/code&gt; flag or a &lt;code&gt;-p&lt;/code&gt; flag, so you must change to each crate&amp;rsquo;s directory and run &lt;code&gt;cargo publish&lt;/code&gt; on each crate in the workspace to publish the crates.</source>
          <target state="translated">Если вы публикуете ящики в рабочей области на &lt;a href=&quot;https://crates.io/&quot;&gt;crates.io&lt;/a&gt; , каждый ящик в рабочей области нужно будет публиковать отдельно. Команда &lt;code&gt;cargo publish&lt;/code&gt; не имеет флага &lt;code&gt;--all&lt;/code&gt; или &lt;code&gt;-p&lt;/code&gt; , поэтому вы должны перейти в каталог каждого ящика и запустить &lt;code&gt;cargo publish&lt;/code&gt; Cargo для каждого ящика в рабочей области, чтобы опубликовать ящики.</target>
        </trans-unit>
        <trans-unit id="f1a5e7e0b8234558c676e94b23a0846e7e9f1bdc" translate="yes" xml:space="preserve">
          <source>If you really want global mutable state, try using &lt;code&gt;static mut&lt;/code&gt; or a global &lt;code&gt;UnsafeCell&lt;/code&gt;.</source>
          <target state="translated">Если вам действительно нужно глобальное изменяемое состояние, попробуйте использовать &lt;code&gt;static mut&lt;/code&gt; или глобальный &lt;code&gt;UnsafeCell&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="62a69dfd70472a3083a61e19bd21f1bf21495b51" translate="yes" xml:space="preserve">
          <source>If you run this code and only see output from the main thread, or don&amp;rsquo;t see any overlap, try increasing the numbers in the ranges to create more opportunities for the operating system to switch between the threads.</source>
          <target state="translated">Если вы запускаете этот код и видите только вывод из основного потока или не видите никакого перекрытия, попробуйте увеличить числа в диапазонах, чтобы создать больше возможностей для операционной системы переключаться между потоками.</target>
        </trans-unit>
        <trans-unit id="9b13bcfddcd9ed188e7606569deda5313f2555de" translate="yes" xml:space="preserve">
          <source>If you see a version number, you have it! If you see an error, such as &lt;code&gt;command not found&lt;/code&gt;, look at the documentation for your method of installation to determine how to install Cargo separately.</source>
          <target state="translated">Если вы видите номер версии, значит, она у вас есть! Если вы видите ошибку, такую ​​как &lt;code&gt;command not found&lt;/code&gt; , посмотрите документацию по вашему методу установки, чтобы определить, как установить Cargo отдельно.</target>
        </trans-unit>
        <trans-unit id="ca1a3838ab344cfca748fd158d2f145d4ad1816e" translate="yes" xml:space="preserve">
          <source>If you see this information, you have installed Rust successfully! If you don&amp;rsquo;t see this information and you&amp;rsquo;re on Windows, check that Rust is in your &lt;code&gt;%PATH%&lt;/code&gt; system variable. If that&amp;rsquo;s all correct and Rust still isn&amp;rsquo;t working, there are a number of places you can get help. The easiest is the #beginners channel on &lt;a href=&quot;https://discord.gg/rust-lang&quot;&gt;the official Rust Discord&lt;/a&gt;. There, you can chat with other Rustaceans (a silly nickname we call ourselves) who can help you out. Other great resources include &lt;a href=&quot;https://users.rust-lang.org/&quot;&gt;the Users forum&lt;/a&gt; and &lt;a href=&quot;http://stackoverflow.com/questions/tagged/rust&quot;&gt;Stack Overflow&lt;/a&gt;.</source>
          <target state="translated">Если вы видите эту информацию, вы успешно установили Rust! Если вы не видите эту информацию и работаете в Windows, убедитесь, что Rust находится в вашей системной переменной &lt;code&gt;%PATH%&lt;/code&gt; . Если все в порядке, а Rust по-прежнему не работает, есть несколько мест, где вы можете получить помощь. Самый простой - канал #beginners на &lt;a href=&quot;https://discord.gg/rust-lang&quot;&gt;официальном Discord Rust&lt;/a&gt; . Там вы можете поговорить с другими Rustaceans (глупое прозвище, которое мы называем сами), которые могут вам помочь. Другие полезные ресурсы включают &lt;a href=&quot;https://users.rust-lang.org/&quot;&gt;форум пользователей&lt;/a&gt; и &lt;a href=&quot;http://stackoverflow.com/questions/tagged/rust&quot;&gt;Stack Overflow&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="af95d793530f81bcda528d6176e0d39ead994b28" translate="yes" xml:space="preserve">
          <source>If you see this information, you have installed Rust successfully! If you don&amp;rsquo;t see this information and you&amp;rsquo;re on Windows, check that Rust is in your &lt;code&gt;%PATH%&lt;/code&gt; system variable. If that&amp;rsquo;s all correct and Rust still isn&amp;rsquo;t working, there are a number of places you can get help. The easiest is the #beginners channel on &lt;a href=&quot;https://discord.gg/rust-lang&quot;&gt;the official Rust Discord&lt;/a&gt;. There, you can chat with other Rustaceans (a silly nickname we call ourselves) who can help you out. Other great resources include &lt;a href=&quot;https://users.rust-lang.org/&quot;&gt;the Users forum&lt;/a&gt; and &lt;a href=&quot;https://stackoverflow.com/questions/tagged/rust&quot;&gt;Stack Overflow&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a0b39f9cc59d35c45bd9b2beb8d8d98394272d63" translate="yes" xml:space="preserve">
          <source>If you started a project that doesn&amp;rsquo;t use Cargo, as we did with the &amp;ldquo;Hello, world!&amp;rdquo; project, you can convert it to a project that does use Cargo. Move the project code into the &lt;em&gt;src&lt;/em&gt; directory and create an appropriate &lt;em&gt;Cargo.toml&lt;/em&gt; file.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6d31b977744193df180d9786073117d4f248efa6" translate="yes" xml:space="preserve">
          <source>If you started a project that doesn&amp;rsquo;t use Cargo, as we did with the Hello, world! project, you can convert it to a project that does use Cargo. Move the project code into the &lt;em&gt;src&lt;/em&gt; directory and create an appropriate &lt;em&gt;Cargo.toml&lt;/em&gt; file.</source>
          <target state="translated">Если вы начали проект, который не использует Cargo, как мы это сделали с Hello, world! project, вы можете преобразовать его в проект, который действительно использует Cargo. Переместите код проекта в каталог &lt;em&gt;src&lt;/em&gt; и создайте соответствующий файл &lt;em&gt;Cargo.toml&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="eb46c5a7ea5d3810ebecfc87299120cce00be773" translate="yes" xml:space="preserve">
          <source>If you still want to implement &lt;code&gt;Default&lt;/code&gt; on your enum, you'll have to do it &quot;by hand&quot;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f5c951c0594854e5d5c8e44057a2f94e7bdb34b3" translate="yes" xml:space="preserve">
          <source>If you tried to compile this code, you&amp;rsquo;d get the following error:</source>
          <target state="translated">Если вы попытаетесь скомпилировать этот код, вы получите следующую ошибку:</target>
        </trans-unit>
        <trans-unit id="5cf70a0009bb0e1db5e453e3370fec24dd9aef5e" translate="yes" xml:space="preserve">
          <source>If you tried to use a module from an external crate and are using Rust 2015, you may have missed the &lt;code&gt;extern crate&lt;/code&gt; declaration (which is usually placed in the crate root):</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8f1e8e43bae6ab3a4aca1d32515bf332a0c95245" translate="yes" xml:space="preserve">
          <source>If you try to implement &lt;code&gt;Copy&lt;/code&gt; on a struct or enum containing non-&lt;code&gt;Copy&lt;/code&gt; data, you will get the error &lt;a href=&quot;../../error-index#E0204&quot;&gt;E0204&lt;/a&gt;.</source>
          <target state="translated">Если вы попытаетесь реализовать &lt;code&gt;Copy&lt;/code&gt; для структуры или перечисления, содержащих данные, &lt;a href=&quot;../../error-index#E0204&quot;&gt;отличные от &lt;/a&gt; &lt;code&gt;Copy&lt;/code&gt; , вы получите ошибку E0204 .</target>
        </trans-unit>
        <trans-unit id="9a662d7b675ef788169c5956b5c9a92931774165" translate="yes" xml:space="preserve">
          <source>If you uncomment the last &lt;code&gt;println!&lt;/code&gt; and run the program, Rust will try to print this cycle with &lt;code&gt;a&lt;/code&gt; pointing to &lt;code&gt;b&lt;/code&gt; pointing to &lt;code&gt;a&lt;/code&gt; and so forth until it overflows the stack.</source>
          <target state="translated">Если вы раскомментируете последний &lt;code&gt;println!&lt;/code&gt; и запустить программу, Rust будет пытаться напечатать этот цикл с &lt;code&gt;a&lt;/code&gt; указывающим на &lt;code&gt;b&lt;/code&gt; , указывающий и так далее , пока она не переполняется стек. &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a14a926ed132d09c491a177cd2b2d9e55f1e2bdf" translate="yes" xml:space="preserve">
          <source>If you want different behavior from that provided by the &lt;code&gt;derive&lt;/code&gt; attribute, consult the &lt;a href=&quot;../std/index&quot;&gt;standard library documentation&lt;/a&gt; for each trait for details of how to manually implement them.</source>
          <target state="translated">Если вы хотите, чтобы поведение отличалось от того, которое обеспечивается атрибутом &lt;code&gt;derive&lt;/code&gt; , обратитесь к &lt;a href=&quot;../std/index&quot;&gt;документации стандартной библиотеки&lt;/a&gt; для каждой характеристики, чтобы узнать, как их реализовать вручную.</target>
        </trans-unit>
        <trans-unit id="da45b590331746dc88457283dc0cfa0a00ed8210" translate="yes" xml:space="preserve">
          <source>If you want others to be able to import variants from your module directly, use &lt;code&gt;pub use&lt;/code&gt;:</source>
          <target state="translated">Если вы хотите, чтобы другие могли напрямую импортировать варианты из вашего модуля, используйте &lt;code&gt;pub use&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="25e1ad087ce44bfb4ab6681d137bc6701595a370" translate="yes" xml:space="preserve">
          <source>If you want to access this field, you have two options:</source>
          <target state="translated">Если вы хотите получить доступ к этому полю,у вас есть два варианта:</target>
        </trans-unit>
        <trans-unit id="e54440276aac79fc98a847cf2428e9933e1917a0" translate="yes" xml:space="preserve">
          <source>If you want to dispose of a value properly, running its destructor, see &lt;a href=&quot;fn.drop&quot;&gt;&lt;code&gt;mem::drop&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Если вы хотите правильно &lt;a href=&quot;fn.drop&quot;&gt; &lt;code&gt;mem::drop&lt;/code&gt; &lt;/a&gt; значение, запустив его деструктор, см. Mem :: drop .</target>
        </trans-unit>
        <trans-unit id="9768a2ab3e4f7c290cb7e9ced37ea2ca5de6e479" translate="yes" xml:space="preserve">
          <source>If you want to force the closure to take ownership of the values it uses in the environment, you can use the &lt;code&gt;move&lt;/code&gt; keyword before the parameter list. This technique is mostly useful when passing a closure to a new thread to move the data so it&amp;rsquo;s owned by the new thread.</source>
          <target state="translated">Если вы хотите, чтобы закрытие перешло во владение значениями, которые оно использует в среде, вы можете использовать ключевое слово &lt;code&gt;move&lt;/code&gt; перед списком параметров. Этот метод в основном полезен при передаче закрытия новому потоку для перемещения данных, чтобы они принадлежали новому потоку.</target>
        </trans-unit>
        <trans-unit id="80acd43e0370273ccef8254a4e57d1f60b0bc413" translate="yes" xml:space="preserve">
          <source>If you want to get command-line arguments, use &lt;code&gt;std::env::args&lt;/code&gt;. To exit with a specified exit code, use &lt;code&gt;std::process::exit&lt;/code&gt;.</source>
          <target state="translated">Если вы хотите получить аргументы командной строки, используйте &lt;code&gt;std::env::args&lt;/code&gt; . Чтобы выйти с указанным кодом выхода, используйте &lt;code&gt;std::process::exit&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9c9a2ec635fa6b00d5880ff9292416d8dca9a7fc" translate="yes" xml:space="preserve">
          <source>If you want to insert an item to a sorted &lt;code&gt;VecDeque&lt;/code&gt;, while maintaining sort order:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0acc8dd0f308905dd135a12c1b3dd9fcb9493376" translate="yes" xml:space="preserve">
          <source>If you want to insert an item to a sorted vector, while maintaining sort order:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9b0f51a38399c4a2f70e6ceafe1a91c955b3ae7a" translate="yes" xml:space="preserve">
          <source>If you want to keep using the first &lt;code&gt;String&lt;/code&gt;, you can clone it and append to the clone instead:</source>
          <target state="translated">Если вы хотите продолжать использовать первую &lt;code&gt;String&lt;/code&gt; , вы можете клонировать ее и вместо этого добавить к клону:</target>
        </trans-unit>
        <trans-unit id="61d387167097c227de2b74d46c810a6f48988800" translate="yes" xml:space="preserve">
          <source>If you want to leak memory, see &lt;a href=&quot;../boxed/struct.box#method.leak&quot;&gt;&lt;code&gt;Box::leak&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Если вы хотите утечку памяти, см. &lt;a href=&quot;../boxed/struct.box#method.leak&quot;&gt; &lt;code&gt;Box::leak&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="96909eb09d644dffe9876e98f5676019fe4cca01" translate="yes" xml:space="preserve">
          <source>If you want to match against a &lt;code&gt;static&lt;/code&gt;, consider using a guard instead:</source>
          <target state="translated">Если вы хотите сопоставить со &lt;code&gt;static&lt;/code&gt; , рассмотрите возможность использования взамен защиты:</target>
        </trans-unit>
        <trans-unit id="5dd2ed8224f86c5b9637dc361ab843ced67e5d10" translate="yes" xml:space="preserve">
          <source>If you want to match against a value returned by a method, you need to bind the value first:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2d1a047e7f9af156ca480104309f128f398877a3" translate="yes" xml:space="preserve">
          <source>If you want to obtain a raw pointer to the memory, see &lt;a href=&quot;../boxed/struct.box#method.into_raw&quot;&gt;&lt;code&gt;Box::into_raw&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Если вы хотите получить необработанный указатель на память, см. &lt;a href=&quot;../boxed/struct.box#method.into_raw&quot;&gt; &lt;code&gt;Box::into_raw&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="af2b12bea50ff4e3f56fd90fac941705dc1d40f8" translate="yes" xml:space="preserve">
          <source>If you want to obtain the maximum value in one step, you can use the following:</source>
          <target state="translated">Если вы хотите получить максимальное значение за один шаг,вы можете использовать следующее:</target>
        </trans-unit>
        <trans-unit id="aa75a1d98c5a72deacc062c764e53ed6e0e651fd" translate="yes" xml:space="preserve">
          <source>If you want to obtain the minimum value in one step, you can use the following:</source>
          <target state="translated">Если вы хотите получить минимальное значение за один шаг,вы можете использовать следующее:</target>
        </trans-unit>
        <trans-unit id="cfd0b8d443659aca7120d5cc8d6a3c8166b35c1d" translate="yes" xml:space="preserve">
          <source>If you want to omit the current error and only use its sources, use &lt;code&gt;skip(1)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="926fba741a818eca51e737d7fa3523921dbd4a71" translate="yes" xml:space="preserve">
          <source>If you want to omit the initial error and only process its sources, use &lt;code&gt;skip(1)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1e4b997d351ad9a525cf19f543e85c5da006d9c7" translate="yes" xml:space="preserve">
          <source>If you want to override a particular option, but still retain the other defaults:</source>
          <target state="translated">Если вы хотите переопределить определенный параметр,но при этом сохранить другие параметры по умолчанию:</target>
        </trans-unit>
        <trans-unit id="651cc5caec5314245c67d0f62c5870f23101d920" translate="yes" xml:space="preserve">
          <source>If you want to replace the values of two variables, see &lt;a href=&quot;fn.swap&quot;&gt;&lt;code&gt;swap&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c6af86f0661e2c9a64c8c625b38f0956d4f284ae" translate="yes" xml:space="preserve">
          <source>If you want to replace with a default value, see &lt;a href=&quot;fn.take&quot;&gt;&lt;code&gt;take&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6bfdbf254f5b63f82b216ed7084a2deb7f3dca85" translate="yes" xml:space="preserve">
          <source>If you want to replace with a passed value instead of the default value, see &lt;a href=&quot;fn.replace&quot;&gt;&lt;code&gt;replace&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1373af912652b0c7e66f623e887c5b41f2472fcc" translate="yes" xml:space="preserve">
          <source>If you want to swap with a default or dummy value, see &lt;a href=&quot;fn.take&quot;&gt;&lt;code&gt;take&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="efa2ff7053e1b87144c40e113ce37c56691cc7f2" translate="yes" xml:space="preserve">
          <source>If you want to swap with a passed value, returning the old value, see &lt;a href=&quot;fn.replace&quot;&gt;&lt;code&gt;replace&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="18f006db9a3676ab2ada8ccb85ca3e9d0996d340" translate="yes" xml:space="preserve">
          <source>If you want to use a license that doesn&amp;rsquo;t appear in the SPDX, you need to place the text of that license in a file, include the file in your project, and then use &lt;code&gt;license-file&lt;/code&gt; to specify the name of that file instead of using the &lt;code&gt;license&lt;/code&gt; key.</source>
          <target state="translated">Если вы хотите использовать лицензию, которая не отображается в SPDX, вам необходимо поместить текст этой лицензии в файл, включить файл в свой проект, а затем использовать &lt;code&gt;license-file&lt;/code&gt; чтобы указать имя этого файла. использования &lt;code&gt;license&lt;/code&gt; ключа.</target>
        </trans-unit>
        <trans-unit id="9090aa9e8ad232d87792cb945b3e00a6429cd6aa" translate="yes" xml:space="preserve">
          <source>If you want to use a method, add &lt;code&gt;()&lt;/code&gt; after it:</source>
          <target state="translated">Если вы хотите использовать метод, добавьте после него &lt;code&gt;()&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="51277c9215e04719281555a263f500118558534d" translate="yes" xml:space="preserve">
          <source>If you wanted to use &lt;code&gt;rand&lt;/code&gt; version &lt;code&gt;0.4.0&lt;/code&gt; or any version in the &lt;code&gt;0.4.x&lt;/code&gt; series, you&amp;rsquo;d have to update the &lt;em&gt;Cargo.toml&lt;/em&gt; file to look like this instead:</source>
          <target state="translated">Если вы хотите использовать &lt;code&gt;rand&lt;/code&gt; версии &lt;code&gt;0.4.0&lt;/code&gt; или любую версию из серии &lt;code&gt;0.4.x&lt;/code&gt; , вам придется обновить файл &lt;em&gt;Cargo.toml,&lt;/em&gt; чтобы он выглядел следующим образом:</target>
        </trans-unit>
        <trans-unit id="8c50d781b9647450248f78ab145ade0f4a366fe2" translate="yes" xml:space="preserve">
          <source>If you wanted to use &lt;code&gt;rand&lt;/code&gt; version &lt;code&gt;0.6.0&lt;/code&gt; or any version in the &lt;code&gt;0.6.x&lt;/code&gt; series, you&amp;rsquo;d have to update the &lt;em&gt;Cargo.toml&lt;/em&gt; file to look like this instead:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1701a67103b86d7651d634397fe65d313d58f55d" translate="yes" xml:space="preserve">
          <source>If you wish to apply this attribute to all methods in an impl, manually annotate each method; it is not possible to annotate the entire impl with an &lt;code&gt;#[inline]&lt;/code&gt; attribute.</source>
          <target state="translated">Если вы хотите применить этот атрибут ко всем методам в impl, вручную аннотируйте каждый метод; невозможно аннотировать весь impl атрибутом &lt;code&gt;#[inline]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5d397e83dcd0f1559792d3e0a89cf887adf0bfaa" translate="yes" xml:space="preserve">
          <source>If you wish to learn more about ownership in Rust, start with the &lt;a href=&quot;book/ch04-00-understanding-ownership&quot;&gt;Understanding Ownership&lt;/a&gt; chapter in the Book.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="87899c4a4d606a4f4020452b11cba149b8345c16" translate="yes" xml:space="preserve">
          <source>If you wish to learn more about ownership in Rust, start with the chapter in the Book:</source>
          <target state="translated">Если вы хотите узнать больше о владении Ржавчиной,начните с главы в Книге:</target>
        </trans-unit>
        <trans-unit id="3e41aae8d663fd217f0f3e9bae5f0ce51dac4bca" translate="yes" xml:space="preserve">
          <source>If you work with Windows API, you may wish to convert &lt;a href=&quot;../ffi/struct.osstr&quot;&gt;&lt;code&gt;OsStr&lt;/code&gt;&lt;/a&gt; to &lt;code&gt;Vec&amp;lt;u16&amp;gt;&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="78eac0234db79506b991eda9c4b9c36157e1c9b6" translate="yes" xml:space="preserve">
          <source>If you would like to import all exported macros, write &lt;code&gt;macro_use&lt;/code&gt; with no arguments.</source>
          <target state="translated">Если вы хотите импортировать все экспортированные макросы, напишите &lt;code&gt;macro_use&lt;/code&gt; без аргументов.</target>
        </trans-unit>
        <trans-unit id="ed1dda05d27b4d27cb9305c801cdb5137665995d" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;re more familiar with a dynamic language, such as Ruby, Python, or JavaScript, you might not be used to compiling and running a program as separate steps. Rust is an &lt;em&gt;ahead-of-time compiled&lt;/em&gt; language, meaning you can compile a program and give the executable to someone else, and they can run it even without having Rust installed. If you give someone a &lt;em&gt;.rb&lt;/em&gt;, &lt;em&gt;.py&lt;/em&gt;, or &lt;em&gt;.js&lt;/em&gt; file, they need to have a Ruby, Python, or JavaScript implementation installed (respectively). But in those languages, you only need one command to compile and run your program. Everything is a trade-off in language design.</source>
          <target state="translated">Если вы более знакомы с динамическим языком, таким как Ruby, Python или JavaScript, возможно, вы не привыкли компилировать и запускать программу как отдельные шаги. Rust - это &lt;em&gt;скомпилированный&lt;/em&gt; язык с &lt;em&gt;опережением времени&lt;/em&gt; , что означает, что вы можете скомпилировать программу и передать исполняемый файл кому-то другому, и они могут запускать его даже без установки Rust. Если вы дадите кому-либо &lt;em&gt;файл .rb&lt;/em&gt; , &lt;em&gt;.py&lt;/em&gt; или &lt;em&gt;.js&lt;/em&gt; , у него должна быть установлена ​​реализация Ruby, Python или JavaScript (соответственно). Но на этих языках вам нужна только одна команда для компиляции и запуска вашей программы. В языковом дизайне все - компромисс.</target>
        </trans-unit>
        <trans-unit id="7e490007e6b65d7d7858801f6aacf713c1c91404" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;re up for a challenge, try implementing these changes on your own before looking at the code in Listing 20-15.</source>
          <target state="translated">Если вы готовы принять вызов, попробуйте реализовать эти изменения самостоятельно, прежде чем смотреть на код в листинге 20-15.</target>
        </trans-unit>
        <trans-unit id="503925e7f62154ea6178c580b761e23a80e387e3" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;re using Linux or macOS, open a terminal and enter the following command:</source>
          <target state="translated">Если вы используете Linux или macOS, откройте терминал и введите следующую команду:</target>
        </trans-unit>
        <trans-unit id="98942c95131204f993cffde6931d1582fa280610" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;re using PowerShell, you will need to set the environment variable and run the program in two commands rather than one:</source>
          <target state="translated">Если вы используете PowerShell, вам нужно будет установить переменную среды и запустить программу двумя командами, а не одной:</target>
        </trans-unit>
        <trans-unit id="10222b367fb9120d22d60ff135277a5cc297aae4" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;re using a beta or stable release of Rust, you can&amp;rsquo;t use any feature flags. This is the key that allows us to get practical use with new features before we declare them stable forever. Those who wish to opt into the bleeding edge can do so, and those who want a rock-solid experience can stick with stable and know that their code won&amp;rsquo;t break. Stability without stagnation.</source>
          <target state="translated">Если вы используете бета-версию или стабильную версию Rust, вы не можете использовать какие-либо флаги функций. Это ключ, который позволяет нам на практике использовать новые функции, прежде чем мы объявим их стабильными навсегда. Те, кто хочет использовать передовые технологии, могут это сделать, а те, кто хочет получить надежный опыт, могут придерживаться стабильной версии и знать, что их код не сломается. Стабильность без застоя.</target>
        </trans-unit>
        <trans-unit id="da77f918478283fad1f198de108fa4f8ef398fc0" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;re wanting to copy the contents of one file to another and you&amp;rsquo;re working with &lt;a href=&quot;struct.file&quot;&gt;&lt;code&gt;File&lt;/code&gt;&lt;/a&gt;s, see the &lt;a href=&quot;../io/fn.copy&quot;&gt;&lt;code&gt;io::copy&lt;/code&gt;&lt;/a&gt; function.</source>
          <target state="translated">Если вы хотите скопировать содержимое одного файла в другой и работаете с &lt;a href=&quot;struct.file&quot;&gt; &lt;code&gt;File&lt;/code&gt; &lt;/a&gt; s, см. Функцию &lt;a href=&quot;../io/fn.copy&quot;&gt; &lt;code&gt;io::copy&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="2a58c6f07d04f7dc7feddd58a27cebcc6f22ddd7" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;re wanting to copy the contents of one file to another and you&amp;rsquo;re working with filesystem paths, see the &lt;a href=&quot;../fs/fn.copy&quot;&gt;&lt;code&gt;fs::copy&lt;/code&gt;&lt;/a&gt; function.</source>
          <target state="translated">Если вы хотите скопировать содержимое одного файла в другой и работаете с путями файловой системы, см. Функцию &lt;a href=&quot;../fs/fn.copy&quot;&gt; &lt;code&gt;fs::copy&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="6ecddb0b505fd4dff9fe47fcf13cd242249940e4" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;ve heard the terms &lt;em&gt;shallow copy&lt;/em&gt; and &lt;em&gt;deep copy&lt;/em&gt; while working with other languages, the concept of copying the pointer, length, and capacity without copying the data probably sounds like making a shallow copy. But because Rust also invalidates the first variable, instead of being called a shallow copy, it&amp;rsquo;s known as a &lt;em&gt;move&lt;/em&gt;. In this example, we would say that &lt;code&gt;s1&lt;/code&gt; was &lt;em&gt;moved&lt;/em&gt; into &lt;code&gt;s2&lt;/code&gt;. So what actually happens is shown in Figure 4-4.</source>
          <target state="translated">Если вы слышали термины &lt;em&gt;мелкая копия&lt;/em&gt; и &lt;em&gt;глубокая копия&lt;/em&gt; , работая с другими языками, концепция копирования указателя, длины и емкости без копирования данных, вероятно, звучит как создание неглубокой копии. Но поскольку Rust также делает недействительной первую переменную, вместо того, чтобы называться поверхностной копией, это называется &lt;em&gt;перемещением&lt;/em&gt; . В этом примере мы бы сказали, что &lt;code&gt;s1&lt;/code&gt; был &lt;em&gt;перемещен&lt;/em&gt; в &lt;code&gt;s2&lt;/code&gt; . То, что происходит на самом деле, показано на рисунке 4-4.</target>
        </trans-unit>
        <trans-unit id="7a247142750d6b996e14a5e30ade8f9e7fae56a4" translate="yes" xml:space="preserve">
          <source>If you'd like explicitly call the destructor of a value, &lt;a href=&quot;../mem/fn.drop&quot;&gt;&lt;code&gt;mem::drop&lt;/code&gt;&lt;/a&gt; can be used instead.</source>
          <target state="new"/>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
