<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ru" datatype="htmlbody" original="rust">
    <body>
      <group id="rust">
        <trans-unit id="d4945a59276bcf1f4830f2a8c1b3defd3c68cde5" translate="yes" xml:space="preserve">
          <source>Namespace path</source>
          <target state="translated">Путь пространства имён</target>
        </trans-unit>
        <trans-unit id="59cb29ad5b08231ec027d2b58b07b4db4094a48e" translate="yes" xml:space="preserve">
          <source>Naming hardcoded values used throughout your program as constants is useful in conveying the meaning of that value to future maintainers of the code. It also helps to have only one place in your code you would need to change if the hardcoded value needed to be updated in the future.</source>
          <target state="translated">Именование жестко закодированных значений,используемых в вашей программе в качестве констант,полезно для передачи значения этого значения будущим мейнтейнерам кода.Это также помогает иметь только одно место в вашем коде,которое вам нужно будет изменить,если в будущем значение в жестком коде нужно будет обновлять.</target>
        </trans-unit>
        <trans-unit id="4ea0a808e9b003709a882c3eda3364c5952aaed6" translate="yes" xml:space="preserve">
          <source>Naming threads</source>
          <target state="translated">Нитки для наименований</target>
        </trans-unit>
        <trans-unit id="2773f0d2f9f4e7e59e9c30b201b04dd1a5c30189" translate="yes" xml:space="preserve">
          <source>Native threads.</source>
          <target state="translated">Родные нити.</target>
        </trans-unit>
        <trans-unit id="f736bf35e196e5f8a2152cf612783a7b401c2cad" translate="yes" xml:space="preserve">
          <source>Ne</source>
          <target state="translated">Ne</target>
        </trans-unit>
        <trans-unit id="ad9041802b2ad5cd647573800f68f895c77cc8fe" translate="yes" xml:space="preserve">
          <source>Neg</source>
          <target state="translated">Neg</target>
        </trans-unit>
        <trans-unit id="64377c7ff3fff06094951f56bcf30132ee73161a" translate="yes" xml:space="preserve">
          <source>Neg::neg</source>
          <target state="translated">Neg::neg</target>
        </trans-unit>
        <trans-unit id="2133424c311abcb51295591d17f0ab0ae52b1f1a" translate="yes" xml:space="preserve">
          <source>Negates self in an overflowing fashion.</source>
          <target state="translated">Отрекается от себя в переполненном виде.</target>
        </trans-unit>
        <trans-unit id="163f10b84a51abc2d56ad3b9131ea073b011f340" translate="yes" xml:space="preserve">
          <source>Negates self, overflowing if this is equal to the minimum value.</source>
          <target state="translated">Отрицает себя,переполнение,если оно равно минимальному значению.</target>
        </trans-unit>
        <trans-unit id="24048c04eba343a323fecac37d642445c66f6c28" translate="yes" xml:space="preserve">
          <source>Negation</source>
          <target state="translated">Negation</target>
        </trans-unit>
        <trans-unit id="f43c19cc20dec09f56a336941f1748c0f4c49844" translate="yes" xml:space="preserve">
          <source>Negation operators</source>
          <target state="translated">операторы отказов</target>
        </trans-unit>
        <trans-unit id="17843c0405b3d56c0f1f2a9c5762b3ce7f769007" translate="yes" xml:space="preserve">
          <source>Negation*</source>
          <target state="translated">Negation*</target>
        </trans-unit>
        <trans-unit id="b07705471769113a1673291a380e793691cb93d8" translate="yes" xml:space="preserve">
          <source>Negative implementations are a promise that the trait will never be implemented for the given types. Therefore, both cannot exists at the same time.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3b31bd178b9fc5ff620f5314f9aa5aa57ccd4286" translate="yes" xml:space="preserve">
          <source>Negative impls are not allowed to have any items. Negative impls declare that a trait is &lt;strong&gt;not&lt;/strong&gt; implemented (and never will be) and hence there is no need to specify the values for trait methods or other items.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e113717082f98a849bcb00740af62ca1b508554b" translate="yes" xml:space="preserve">
          <source>Negative impls are only allowed for auto traits. For more information see the &lt;a href=&quot;https://github.com/rust-lang/rfcs/blob/master/text/0019-opt-in-builtin-traits.md&quot;&gt;opt-in builtin traits RFC&lt;/a&gt;.</source>
          <target state="translated">Отрицательные импликации разрешены только для авто-трейтов. Дополнительные сведения см. В &lt;a href=&quot;https://github.com/rust-lang/rfcs/blob/master/text/0019-opt-in-builtin-traits.md&quot;&gt;RFC встроенных свойств opt-in&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="0615e40800cad75c4988298cdebe16d2bc992b36" translate="yes" xml:space="preserve">
          <source>Negative impls cannot be default impls. A default impl supplies default values for the items within to be used by other impls, whereas a negative impl declares that there are no other impls. Combining it does not make sense.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="075388f0e224328f0ef13d31f89995f6f2c54896" translate="yes" xml:space="preserve">
          <source>Negative infinity</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bb6b7b244457f2bc0330b32b4347438278828967" translate="yes" xml:space="preserve">
          <source>Negative infinity (&amp;minus;&amp;infin;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="31031ada08602da6a93f5f5a6962d2039849eda8" translate="yes" xml:space="preserve">
          <source>Negative infinity (&amp;minus;&amp;infin;). Use &lt;a href=&quot;../primitive.f32#associatedconstant.NEG_INFINITY&quot;&gt;&lt;code&gt;f32::NEG_INFINITY&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f342b4f8475b808f61b1967602254bedfcdc5688" translate="yes" xml:space="preserve">
          <source>Negative infinity (&amp;minus;&amp;infin;). Use &lt;a href=&quot;../primitive.f64#associatedconstant.NEG_INFINITY&quot;&gt;&lt;code&gt;f64::NEG_INFINITY&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f0bc318765f26abdc2b2efb29b7106a82fb8fb4b" translate="yes" xml:space="preserve">
          <source>Negative infinity (-&amp;infin;).</source>
          <target state="translated">Отрицательная бесконечность (-&amp;infin;).</target>
        </trans-unit>
        <trans-unit id="0b247e3c8355086599e15be9efdc87a68cb4c92b" translate="yes" xml:space="preserve">
          <source>Negative numbers</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="72021c01935802b94d4bcd9c9615be5e2c464ac9" translate="yes" xml:space="preserve">
          <source>Negative quiet NaN</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3bb8a4159eba393bec0f206dd4b2eb1942475e21" translate="yes" xml:space="preserve">
          <source>Negative signaling NaN</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="16ee7bf9e7ed5622172a82905b10c817e30e7444" translate="yes" xml:space="preserve">
          <source>Negative subnormal numbers</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dbee361595328b1b81f0564c184162939e173b0f" translate="yes" xml:space="preserve">
          <source>Negative zero</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ecf5959ac45ac960a39abb26044226e763422de4" translate="yes" xml:space="preserve">
          <source>Neither value is dropped.</source>
          <target state="translated">Ни одно из значений не опускается.</target>
        </trans-unit>
        <trans-unit id="4826200965c37ead358d19d4ff8ed0153fd42955" translate="yes" xml:space="preserve">
          <source>Neither will this, which is a syntax error:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="665ede9ba12690daf481e44869ce86ddcafb335a" translate="yes" xml:space="preserve">
          <source>Nesting groups of the previous features multiple times, such as &lt;code&gt;use a::b::{self as ab, c, d::{*, e::f}};&lt;/code&gt;</source>
          <target state="translated">Многократное вложение групп предыдущих функций, например &lt;code&gt;use a::b::{self as ab, c, d::{*, e::f}};&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="c4245fc09474f28a0f0142b9ff14b33a73b77c8f" translate="yes" xml:space="preserve">
          <source>Networking primitives for TCP/UDP communication.</source>
          <target state="translated">Сетевые примитивы для связи TCP/UDP.</target>
        </trans-unit>
        <trans-unit id="0512d9d610f7bd86dbd1ca707603a7ad85ac4816" translate="yes" xml:space="preserve">
          <source>Never type</source>
          <target state="translated">Никогда не печатать</target>
        </trans-unit>
        <trans-unit id="34989675de773cc2985533af4611fcdec5ac0eea" translate="yes" xml:space="preserve">
          <source>New instances of a &lt;code&gt;struct&lt;/code&gt; can be constructed with a &lt;a href=&quot;../expressions/struct-expr&quot;&gt;struct expression&lt;/a&gt;.</source>
          <target state="translated">Новые экземпляры &lt;code&gt;struct&lt;/code&gt; могут быть созданы с помощью &lt;a href=&quot;../expressions/struct-expr&quot;&gt;выражения структуры&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="474d969a41224d27a052b2157645ae6ea6fdc69d" translate="yes" xml:space="preserve">
          <source>New instances of an &lt;code&gt;enum&lt;/code&gt; can be constructed in an &lt;a href=&quot;../expressions/enum-variant-expr&quot;&gt;enumeration variant expression&lt;/a&gt;.</source>
          <target state="translated">Новые экземпляры &lt;code&gt;enum&lt;/code&gt; могут быть созданы в &lt;a href=&quot;../expressions/enum-variant-expr&quot;&gt;выражении варианта перечисления&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="83c2612a110d45187eac1c39a648ac614b8c7d56" translate="yes" xml:space="preserve">
          <source>New versions of Unicode are released regularly and subsequently all methods in the standard library depending on Unicode are updated. Therefore the behavior of some &lt;code&gt;char&lt;/code&gt; and &lt;code&gt;str&lt;/code&gt; methods and the value of this constant changes over time. This is &lt;em&gt;not&lt;/em&gt; considered to be a breaking change.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d706a7f27906e3a8bf4f4fed0f9c3d7edc4a240a" translate="yes" xml:space="preserve">
          <source>Newline</source>
          <target state="translated">Newline</target>
        </trans-unit>
        <trans-unit id="d783d54db2abcb54d1f3f2d8b19273a6830adb8c" translate="yes" xml:space="preserve">
          <source>Newsqueak, Alef, Limbo: channels, concurrency</source>
          <target state="translated">Ньюсквик,Алеф,Лимбо:каналы,параллелизм</target>
        </trans-unit>
        <trans-unit id="9000cfe362fe35a00622dc16de8a42fe71435817" translate="yes" xml:space="preserve">
          <source>Newtypes can also hide internal implementation. For example, we could provide a &lt;code&gt;People&lt;/code&gt; type to wrap a &lt;code&gt;HashMap&amp;lt;i32, String&amp;gt;&lt;/code&gt; that stores a person&amp;rsquo;s ID associated with their name. Code using &lt;code&gt;People&lt;/code&gt; would only interact with the public API we provide, such as a method to add a name string to the &lt;code&gt;People&lt;/code&gt; collection; that code wouldn&amp;rsquo;t need to know that we assign an &lt;code&gt;i32&lt;/code&gt; ID to names internally. The newtype pattern is a lightweight way to achieve encapsulation to hide implementation details, which we discussed in the &lt;a href=&quot;ch17-01-what-is-oo#encapsulation-that-hides-implementation-details&quot;&gt;&amp;ldquo;Encapsulation that Hides Implementation Details&amp;rdquo;&lt;/a&gt; section of Chapter 17.</source>
          <target state="translated">Новые типы также могут скрывать внутреннюю реализацию. Например, мы могли бы предоставить тип &lt;code&gt;People&lt;/code&gt; для обертывания &lt;code&gt;HashMap&amp;lt;i32, String&amp;gt;&lt;/code&gt; котором хранится идентификатор человека, связанный с его именем. Код, использующий &lt;code&gt;People&lt;/code&gt; , будет взаимодействовать только с предоставляемым нами общедоступным API, например с методом добавления строки имени в коллекцию &lt;code&gt;People&lt;/code&gt; ; этому коду не нужно было бы знать, что мы внутренне присваиваем &lt;code&gt;i32&lt;/code&gt; идентификатор i32 . Шаблон newtype - это легкий способ добиться инкапсуляции, чтобы скрыть детали реализации, которые мы обсуждали в разделе &lt;a href=&quot;ch17-01-what-is-oo#encapsulation-that-hides-implementation-details&quot;&gt;&amp;laquo;Инкапсуляция,&lt;/a&gt; скрывающая детали реализации&amp;raquo; главы 17.</target>
        </trans-unit>
        <trans-unit id="7bae91cced3da7b704f84e06989b7947e80e541e" translate="yes" xml:space="preserve">
          <source>Next are the &lt;code&gt;match&lt;/code&gt; arms. An arm has two parts: a pattern and some code. The first arm here has a pattern that is the value &lt;code&gt;Coin::Penny&lt;/code&gt; and then the &lt;code&gt;=&amp;gt;&lt;/code&gt; operator that separates the pattern and the code to run. The code in this case is just the value &lt;code&gt;1&lt;/code&gt;. Each arm is separated from the next with a comma.</source>
          <target state="translated">Далее идут &lt;code&gt;match&lt;/code&gt; . Рука состоит из двух частей: рисунка и кода. Первая рука здесь имеет шаблон, который представляет собой значение &lt;code&gt;Coin::Penny&lt;/code&gt; а затем оператор &lt;code&gt;=&amp;gt;&lt;/code&gt; , который разделяет шаблон и код для запуска. Код в этом случае - это просто значение &lt;code&gt;1&lt;/code&gt; . Каждая рука отделяется от следующей запятой.</target>
        </trans-unit>
        <trans-unit id="bf7420cff34f7205e5c081be758df804f4a3397f" translate="yes" xml:space="preserve">
          <source>Next is the &lt;code&gt;main&lt;/code&gt; function, which contains the parts of the workout app important for this example. This function represents the code that the app will call when a user asks for a workout plan. Because the interaction with the app&amp;rsquo;s frontend isn&amp;rsquo;t relevant to the use of closures, we&amp;rsquo;ll hardcode values representing inputs to our program and print the outputs.</source>
          <target state="translated">Далее идет &lt;code&gt;main&lt;/code&gt; функция, которая содержит части приложения для тренировки, важные для этого примера. Эта функция представляет собой код, который приложение будет вызывать, когда пользователь запрашивает план тренировки. Поскольку взаимодействие с интерфейсом приложения не имеет отношения к использованию замыканий, мы жестко закодируем значения, представляющие входные данные для нашей программы, и распечатаем выходные данные.</target>
        </trans-unit>
        <trans-unit id="c65bbe969462e1bc44ee3000579ab22fe481fd4c" translate="yes" xml:space="preserve">
          <source>Next, for the penultimate chapter of the book, we&amp;rsquo;ll look at some advanced aspects of a variety of Rust&amp;rsquo;s features.</source>
          <target state="translated">Далее, в предпоследней главе книги, мы рассмотрим некоторые дополнительные аспекты различных возможностей Rust.</target>
        </trans-unit>
        <trans-unit id="52208e82490358e0e353201224729d0b32e9211f" translate="yes" xml:space="preserve">
          <source>Next, in the &lt;em&gt;add&lt;/em&gt; directory, we create the &lt;em&gt;Cargo.toml&lt;/em&gt; file that will configure the entire workspace. This file won&amp;rsquo;t have a &lt;code&gt;[package]&lt;/code&gt; section or the metadata we&amp;rsquo;ve seen in other &lt;em&gt;Cargo.toml&lt;/em&gt; files. Instead, it will start with a &lt;code&gt;[workspace]&lt;/code&gt; section that will allow us to add members to the workspace by specifying the path to our binary crate; in this case, that path is &lt;em&gt;adder&lt;/em&gt;:</source>
          <target state="translated">Затем в каталоге &lt;em&gt;добавления&lt;/em&gt; мы создаем файл &lt;em&gt;Cargo.toml&lt;/em&gt; , который настроит всю рабочую область. В этом файле не будет раздела &lt;code&gt;[package]&lt;/code&gt; или метаданных, которые мы видели в других файлах &lt;em&gt;Cargo.toml&lt;/em&gt; . Вместо этого он начнется с раздела &lt;code&gt;[workspace]&lt;/code&gt; , который позволит нам добавлять участников в рабочую область, указав путь к нашему двоичному ящику; в данном случае это &lt;em&gt;сумматор&lt;/em&gt; :</target>
        </trans-unit>
        <trans-unit id="cf3583fbb6ba42fdef61381eb0f22f26cc65cb4c" translate="yes" xml:space="preserve">
          <source>Next, in the &lt;em&gt;add&lt;/em&gt; directory, we create the &lt;em&gt;Cargo.toml&lt;/em&gt; file that will configure the entire workspace. This file won&amp;rsquo;t have a &lt;code&gt;[package]&lt;/code&gt; section or the metadata we&amp;rsquo;ve seen in other &lt;em&gt;Cargo.toml&lt;/em&gt; files. Instead, it will start with a &lt;code&gt;[workspace]&lt;/code&gt; section that will allow us to add members to the workspace by specifying the path to the package with our binary crate; in this case, that path is &lt;em&gt;adder&lt;/em&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4d5673d4c0782df5e2ab93b6ac7b7285949caf0a" translate="yes" xml:space="preserve">
          <source>Next, let&amp;rsquo;s create another member crate in the workspace and call it &lt;code&gt;add-one&lt;/code&gt;. Change the top-level &lt;em&gt;Cargo.toml&lt;/em&gt; to specify the &lt;em&gt;add-one&lt;/em&gt; path in the &lt;code&gt;members&lt;/code&gt; list:</source>
          <target state="translated">Затем давайте создадим еще один ящик для участников в рабочей области и назовем его &lt;code&gt;add-one&lt;/code&gt; . Измените &lt;em&gt;Cargo.toml&lt;/em&gt; верхнего уровня, чтобы указать &lt;em&gt;путь&lt;/em&gt; для &lt;em&gt;добавления&lt;/em&gt; в список &lt;code&gt;members&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="9b3259a6676f65921f501e882bdad69e2021df7f" translate="yes" xml:space="preserve">
          <source>Next, let&amp;rsquo;s create another member package in the workspace and call it &lt;code&gt;add-one&lt;/code&gt;. Change the top-level &lt;em&gt;Cargo.toml&lt;/em&gt; to specify the &lt;em&gt;add-one&lt;/em&gt; path in the &lt;code&gt;members&lt;/code&gt; list:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1ba0c012105d9f7e5a4cb08c9812f147ef92fc3f" translate="yes" xml:space="preserve">
          <source>Next, let&amp;rsquo;s explore how the other kinds of procedural macros differ from custom derive macros.</source>
          <target state="translated">Затем давайте исследуем, чем другие виды процедурных макросов отличаются от макросов пользовательского получения.</target>
        </trans-unit>
        <trans-unit id="7388ce6c4f87a59e05725876ec1ba13ab5a6c132" translate="yes" xml:space="preserve">
          <source>Next, let&amp;rsquo;s look at macros!</source>
          <target state="translated">Далее давайте посмотрим на макросы!</target>
        </trans-unit>
        <trans-unit id="a41ab1aeb6ce0234b517ca6ca3124ad3db811d40" translate="yes" xml:space="preserve">
          <source>Next, let&amp;rsquo;s try an example that shows that the lifetime of the reference in &lt;code&gt;result&lt;/code&gt; must be the smaller lifetime of the two arguments. We&amp;rsquo;ll move the declaration of the &lt;code&gt;result&lt;/code&gt; variable outside the inner scope but leave the assignment of the value to the &lt;code&gt;result&lt;/code&gt; variable inside the scope with &lt;code&gt;string2&lt;/code&gt;. Then we&amp;rsquo;ll move the &lt;code&gt;println!&lt;/code&gt; that uses &lt;code&gt;result&lt;/code&gt; outside the inner scope, after the inner scope has ended. The code in Listing 10-24 will not compile.</source>
          <target state="translated">Затем давайте попробуем пример, который показывает, что время жизни ссылки в &lt;code&gt;result&lt;/code&gt; должно быть меньшим временем жизни двух аргументов. Мы переместим объявление переменной &lt;code&gt;result&lt;/code&gt; за пределы внутренней области видимости, но оставим присвоение значения переменной &lt;code&gt;result&lt;/code&gt; внутри области с помощью &lt;code&gt;string2&lt;/code&gt; . Затем мы переместим &lt;code&gt;println!&lt;/code&gt; который использует &lt;code&gt;result&lt;/code&gt; за пределами внутренней области, после того, как внутренняя область видимости закончилась. Код в Листинге 10-24 не компилируется.</target>
        </trans-unit>
        <trans-unit id="4cd72ee75b765bce66036759ad44f05bffbba3a1" translate="yes" xml:space="preserve">
          <source>Next, let&amp;rsquo;s use the &lt;code&gt;add_one&lt;/code&gt; function from the &lt;code&gt;add-one&lt;/code&gt; crate in the &lt;code&gt;adder&lt;/code&gt; crate. Open the &lt;em&gt;adder/src/main.rs&lt;/em&gt; file and add a &lt;code&gt;use&lt;/code&gt; line at the top to bring the new &lt;code&gt;add-one&lt;/code&gt; library crate into scope. Then change the &lt;code&gt;main&lt;/code&gt; function to call the &lt;code&gt;add_one&lt;/code&gt; function, as in Listing 14-7.</source>
          <target state="translated">Далее, давайте использовать &lt;code&gt;add_one&lt;/code&gt; функции из &lt;code&gt;add-one&lt;/code&gt; ящика в &lt;code&gt;adder&lt;/code&gt; обрешетке. Открыть &lt;em&gt;/ Src сумматор / main.rs&lt;/em&gt; файл и добавьте &lt;code&gt;use&lt;/code&gt; строку в верхней части , чтобы принести новую &lt;code&gt;add-one&lt;/code&gt; библиотеки клети в область видимости. Затем измените &lt;code&gt;main&lt;/code&gt; функцию, чтобы вызвать функцию &lt;code&gt;add_one&lt;/code&gt; , как в листинге 14-7.</target>
        </trans-unit>
        <trans-unit id="e1fe2a2a98ce9e857e8667aa0e6390f716cb1d28" translate="yes" xml:space="preserve">
          <source>Next, make a new source file and call it &lt;em&gt;main.rs&lt;/em&gt;. Rust files always end with the &lt;em&gt;.rs&lt;/em&gt; extension. If you&amp;rsquo;re using more than one word in your filename, use an underscore to separate them. For example, use &lt;em&gt;hello_world.rs&lt;/em&gt; rather than &lt;em&gt;helloworld.rs&lt;/em&gt;.</source>
          <target state="translated">Далее создайте новый файл и назовите его &lt;em&gt;main.rs&lt;/em&gt; . Файлы Rust всегда имеют расширение &lt;em&gt;.rs&lt;/em&gt; . Если вы используете более одного слова в своем имени файла, используйте подчеркивание для их разделения. Например, используйте &lt;em&gt;hello_world.rs,&lt;/em&gt; а не &lt;em&gt;helloworld.rs&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="03d3c37a590f1ae7381c9279be8f7a97b6800076" translate="yes" xml:space="preserve">
          <source>Next, we add a call to &lt;code&gt;to_lowercase&lt;/code&gt; on each &lt;code&gt;line&lt;/code&gt; before we check whether it contains &lt;code&gt;query&lt;/code&gt; to lowercase all characters. Now that we&amp;rsquo;ve converted &lt;code&gt;line&lt;/code&gt; and &lt;code&gt;query&lt;/code&gt; to lowercase, we&amp;rsquo;ll find matches no matter what the case of the query is.</source>
          <target state="translated">Затем мы добавляем вызов &lt;code&gt;to_lowercase&lt;/code&gt; в каждую &lt;code&gt;line&lt;/code&gt; прежде чем проверять, содержит ли он &lt;code&gt;query&lt;/code&gt; на строчные буквы всех символов. Теперь, когда мы преобразовали &lt;code&gt;line&lt;/code&gt; и &lt;code&gt;query&lt;/code&gt; в нижний регистр, мы найдем совпадения вне зависимости от того, в каком регистре находится запрос.</target>
        </trans-unit>
        <trans-unit id="8e52d9272848f0823ca640fddf0b693b0608206b" translate="yes" xml:space="preserve">
          <source>Next, we create an iterator over the array of bytes using the &lt;code&gt;iter&lt;/code&gt; method:</source>
          <target state="translated">Затем мы создаем итератор по массиву байтов, используя метод &lt;code&gt;iter&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="fbb5669be934c8d9daa09d2fb6f075709e7fa5e2" translate="yes" xml:space="preserve">
          <source>Next, we implement a method named &lt;code&gt;value&lt;/code&gt; that borrows &lt;code&gt;self&lt;/code&gt;, doesn&amp;rsquo;t have any other parameters, and returns an &lt;code&gt;i32&lt;/code&gt;. This kind of method is sometimes called a &lt;em&gt;getter&lt;/em&gt;, because its purpose is to get some data from its fields and return it. This public method is necessary because the &lt;code&gt;value&lt;/code&gt; field of the &lt;code&gt;Guess&lt;/code&gt; struct is private. It&amp;rsquo;s important that the &lt;code&gt;value&lt;/code&gt; field be private so code using the &lt;code&gt;Guess&lt;/code&gt; struct is not allowed to set &lt;code&gt;value&lt;/code&gt; directly: code outside the module &lt;em&gt;must&lt;/em&gt; use the &lt;code&gt;Guess::new&lt;/code&gt; function to create an instance of &lt;code&gt;Guess&lt;/code&gt;, thereby ensuring there&amp;rsquo;s no way for a &lt;code&gt;Guess&lt;/code&gt; to have a &lt;code&gt;value&lt;/code&gt; that hasn&amp;rsquo;t been checked by the conditions in the &lt;code&gt;Guess::new&lt;/code&gt; function.</source>
          <target state="translated">Затем мы реализуем метод с именем &lt;code&gt;value&lt;/code&gt; , который заимствует &lt;code&gt;self&lt;/code&gt; , не имеет других параметров и возвращает &lt;code&gt;i32&lt;/code&gt; . Такой метод иногда называют &lt;em&gt;геттером&lt;/em&gt; , потому что его цель - получить некоторые данные из своих полей и вернуть их. Этот открытый метод необходим, потому что поле &lt;code&gt;value&lt;/code&gt; структуры &lt;code&gt;Guess&lt;/code&gt; является закрытым. Важно, чтобы поле &lt;code&gt;value&lt;/code&gt; было закрытым, поэтому коду, использующему структуру &lt;code&gt;Guess&lt;/code&gt; , не разрешается устанавливать &lt;code&gt;value&lt;/code&gt; напрямую: код вне модуля &lt;em&gt;должен&lt;/em&gt; использовать функцию &lt;code&gt;Guess::new&lt;/code&gt; для создания экземпляра &lt;code&gt;Guess&lt;/code&gt; ., таким образом гарантируя, что у &lt;code&gt;Guess&lt;/code&gt; нет возможности иметь &lt;code&gt;value&lt;/code&gt; , которое не было проверено условиями в функции &lt;code&gt;Guess::new&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="605d6de7987c12e157a0df6ee5c1a07b22d453f2" translate="yes" xml:space="preserve">
          <source>Next, we implement the &lt;code&gt;FnBox&lt;/code&gt; trait for any type &lt;code&gt;F&lt;/code&gt; that implements the &lt;code&gt;FnOnce()&lt;/code&gt; trait. Effectively, this means that any &lt;code&gt;FnOnce()&lt;/code&gt; closures can use our &lt;code&gt;call_box&lt;/code&gt; method. The implementation of &lt;code&gt;call_box&lt;/code&gt; uses &lt;code&gt;(*self)()&lt;/code&gt; to move the closure out of the &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; and call the closure.</source>
          <target state="translated">Затем мы реализуем &lt;code&gt;FnBox&lt;/code&gt; для любого типа &lt;code&gt;F&lt;/code&gt; , который реализует &lt;code&gt;FnOnce()&lt;/code&gt; . Фактически это означает, что любые &lt;code&gt;FnOnce()&lt;/code&gt; могут использовать наш метод &lt;code&gt;call_box&lt;/code&gt; . Реализация &lt;code&gt;call_box&lt;/code&gt; использует &lt;code&gt;(*self)()&lt;/code&gt; , чтобы переместить закрытие из &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; и вызвать закрытие.</target>
        </trans-unit>
        <trans-unit id="813cf7c3c4cb11a394f89f5d5322e12f202af557" translate="yes" xml:space="preserve">
          <source>Next, we need to actually read from the stream. We do this in two steps: first, we declare a &lt;code&gt;buffer&lt;/code&gt; on the stack to hold the data that is read in. We&amp;rsquo;ve made the buffer 1024 bytes in size, which is big enough to hold the data of a basic request and sufficient for our purposes in this chapter. If we wanted to handle requests of an arbitrary size, buffer management would need to be more complicated; we&amp;rsquo;ll keep it simple for now. We pass the buffer to &lt;code&gt;stream.read&lt;/code&gt;, which will read bytes from the &lt;code&gt;TcpStream&lt;/code&gt; and put them in the buffer.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7cc7c952c5d6180788b66b960a497f1bbb0d5cfe" translate="yes" xml:space="preserve">
          <source>Next, we need to actually read from the stream. We do this in two steps: first, we declare a &lt;code&gt;buffer&lt;/code&gt; on the stack to hold the data that is read in. We&amp;rsquo;ve made the buffer 512 bytes in size, which is big enough to hold the data of a basic request and sufficient for our purposes in this chapter. If we wanted to handle requests of an arbitrary size, buffer management would need to be more complicated; we&amp;rsquo;ll keep it simple for now. We pass the buffer to &lt;code&gt;stream.read&lt;/code&gt;, which will read bytes from the &lt;code&gt;TcpStream&lt;/code&gt; and put them in the buffer.</source>
          <target state="translated">Далее нам нужно фактически прочитать из потока. Мы делаем это в два этапа: во-первых, мы объявляем &lt;code&gt;buffer&lt;/code&gt; в стеке для хранения считываемых данных. Мы сделали буфер размером 512 байт, что достаточно для хранения данных базового запроса и достаточно. для наших целей в этой главе. Если мы хотим обрабатывать запросы произвольного размера, управление буфером должно быть более сложным; пока будем проще. Мы передаем буфер в &lt;code&gt;stream.read&lt;/code&gt; , который считывает байты из &lt;code&gt;TcpStream&lt;/code&gt; и помещает их в буфер.</target>
        </trans-unit>
        <trans-unit id="76351bb871037a13a112e6c874825b1ebb4611c8" translate="yes" xml:space="preserve">
          <source>Next, we need to add functionality to request a review of a post, which should change its state from &lt;code&gt;Draft&lt;/code&gt; to &lt;code&gt;PendingReview&lt;/code&gt;. Listing 17-15 shows this code:</source>
          <target state="translated">Затем нам нужно добавить функциональность для запроса проверки публикации, которая должна изменить свое состояние с &lt;code&gt;Draft&lt;/code&gt; на &lt;code&gt;PendingReview&lt;/code&gt; . В листинге 17-15 показан этот код:</target>
        </trans-unit>
        <trans-unit id="92e1faec54108ffc0dae30cd9cc0b93fd8d1895e" translate="yes" xml:space="preserve">
          <source>Next, we need to generate a secret number that the user will try to guess. The secret number should be different every time so the game is fun to play more than once. Let&amp;rsquo;s use a random number between 1 and 100 so the game isn&amp;rsquo;t too difficult. Rust doesn&amp;rsquo;t yet include random number functionality in its standard library. However, the Rust team does provide a &lt;a href=&quot;https://crates.io/crates/rand&quot;&gt;&lt;code&gt;rand&lt;/code&gt; crate&lt;/a&gt;.</source>
          <target state="translated">Далее нам нужно сгенерировать секретное число, которое пользователь попытается угадать. Секретный номер должен каждый раз отличаться, чтобы в игру было интересно играть более одного раза. Давайте использовать случайное число от 1 до 100, чтобы игра не была слишком сложной. Rust еще не включает функцию случайных чисел в свою стандартную библиотеку. Тем не менее, команда Rust предоставляет &lt;a href=&quot;https://crates.io/crates/rand&quot;&gt; &lt;code&gt;rand&lt;/code&gt; ящик&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="b3048ae1981e29d8fc7bb24867dd28498448fb02" translate="yes" xml:space="preserve">
          <source>Next, we need to update the definition of &lt;code&gt;Config::new&lt;/code&gt;. In your I/O project&amp;rsquo;s &lt;em&gt;src/lib.rs&lt;/em&gt; file, let&amp;rsquo;s change the signature of &lt;code&gt;Config::new&lt;/code&gt; to look like Listing 13-26. This still won&amp;rsquo;t compile because we need to update the function body.</source>
          <target state="translated">Затем нам нужно обновить определение &lt;code&gt;Config::new&lt;/code&gt; . В файле &lt;em&gt;src / lib.rs&lt;/em&gt; вашего проекта ввода-вывода изменим подпись &lt;code&gt;Config::new&lt;/code&gt; чтобы она выглядела как листинг 13-26. Это все равно не скомпилируется, потому что нам нужно обновить тело функции.</target>
        </trans-unit>
        <trans-unit id="f7002fc97279e473d70d4660362de14f1e116f1c" translate="yes" xml:space="preserve">
          <source>Next, we use &lt;code&gt;format!&lt;/code&gt; to add the file&amp;rsquo;s contents as the body of the success response.</source>
          <target state="translated">Далее мы используем &lt;code&gt;format!&lt;/code&gt; чтобы добавить содержимое файла как тело ответа об успешном завершении.</target>
        </trans-unit>
        <trans-unit id="5f1848680d22a75c771965dd71d24a16003163fc" translate="yes" xml:space="preserve">
          <source>Next, we use &lt;code&gt;format!&lt;/code&gt; to add the file&amp;rsquo;s contents as the body of the success response. To ensure a valid HTTP response, we add the &lt;code&gt;Content-Length&lt;/code&gt; header which is set to the size of our response body, in this case the size of &lt;code&gt;hello.html&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e1cb8822a67321b8c02da9e7e8c260dc9c0b608d" translate="yes" xml:space="preserve">
          <source>Next, we want to enable a request for a review of the post, and we want &lt;code&gt;content&lt;/code&gt; to return an empty string while waiting for the review. When the post receives approval, it should get published, meaning the text of the post will be returned when &lt;code&gt;content&lt;/code&gt; is called.</source>
          <target state="translated">Затем мы хотим включить запрос на проверку публикации, и мы хотим, чтобы &lt;code&gt;content&lt;/code&gt; возвращал пустую строку во время ожидания обзора. Когда сообщение получит одобрение, оно должно быть опубликовано, то есть текст сообщения будет возвращен при вызове &lt;code&gt;content&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="dc0c1d1b57e4826864a1d45c2ceee72d00bff7d9" translate="yes" xml:space="preserve">
          <source>Next, we&amp;rsquo;ll check whether the current line contains our query string. Fortunately, strings have a helpful method named &lt;code&gt;contains&lt;/code&gt; that does this for us! Add a call to the &lt;code&gt;contains&lt;/code&gt; method in the &lt;code&gt;search&lt;/code&gt; function, as shown in Listing 12-18. Note this still won&amp;rsquo;t compile yet.</source>
          <target state="translated">Затем мы проверим, содержит ли текущая строка нашу строку запроса. К счастью, у строк есть полезный метод с именем &lt;code&gt;contains&lt;/code&gt; , который делает это за нас! Добавьте вызов метода &lt;code&gt;contains&lt;/code&gt; в функцию &lt;code&gt;search&lt;/code&gt; , как показано в листинге 12-18. Обратите внимание, что это еще не компилируется.</target>
        </trans-unit>
        <trans-unit id="5ac1479b99a85012a6bea69ba1759d1f7cc3ad30" translate="yes" xml:space="preserve">
          <source>Next, we&amp;rsquo;ll create a place to store the user input, like this:</source>
          <target state="translated">Затем мы создадим место для хранения пользовательского ввода, например:</target>
        </trans-unit>
        <trans-unit id="e5a328539b3bbff608c05675d0f98ba529495a33" translate="yes" xml:space="preserve">
          <source>Next, we&amp;rsquo;ll create a raw pointer whose validity we can&amp;rsquo;t be so certain of. Listing 19-2 shows how to create a raw pointer to an arbitrary location in memory. Trying to use arbitrary memory is undefined: there might be data at that address or there might not, the compiler might optimize the code so there is no memory access, or the program might error with a segmentation fault. Usually, there is no good reason to write code like this, but it is possible.</source>
          <target state="translated">Затем мы создадим необработанный указатель, в достоверности которого мы не можем быть уверены. В листинге 19-2 показано, как создать необработанный указатель на произвольное место в памяти. Попытка использовать произвольную память не определена: по этому адресу могут быть данные, а может и нет, компилятор может оптимизировать код, чтобы не было доступа к памяти, или программа может вывести ошибку из-за ошибки сегментации. Обычно нет веских причин писать такой код, но это возможно.</target>
        </trans-unit>
        <trans-unit id="629644a5201c55cb9634591304da90b26a4571c8" translate="yes" xml:space="preserve">
          <source>Next, we&amp;rsquo;ll create the &lt;code&gt;adder&lt;/code&gt; binary crate by running &lt;code&gt;cargo new&lt;/code&gt; within the &lt;em&gt;add&lt;/em&gt; directory:</source>
          <target state="translated">Затем мы создадим бинарный ящик &lt;code&gt;adder&lt;/code&gt; , запустив &lt;code&gt;cargo new&lt;/code&gt; в каталоге &lt;em&gt;добавления&lt;/em&gt; :</target>
        </trans-unit>
        <trans-unit id="4c8171dc56214044bf871f6ef39d7d39bc7a5954" translate="yes" xml:space="preserve">
          <source>Next, we&amp;rsquo;ll define the &lt;code&gt;HelloMacro&lt;/code&gt; trait and its associated function:</source>
          <target state="translated">Затем мы определим &lt;code&gt;HelloMacro&lt;/code&gt; и связанную с ним функцию:</target>
        </trans-unit>
        <trans-unit id="a47fb6ac34c3efb030b781d2a69ff8c26654e8b7" translate="yes" xml:space="preserve">
          <source>Next, we&amp;rsquo;ll explore some Rust features that were influenced by functional languages: closures and iterators.</source>
          <target state="translated">Далее мы исследуем некоторые особенности Rust, на которые повлияли функциональные языки: замыкания и итераторы.</target>
        </trans-unit>
        <trans-unit id="de89b671f67de5d1f170a1b7712e3f2c4f2d52b0" translate="yes" xml:space="preserve">
          <source>Next, we&amp;rsquo;ll explore some advanced features related to functions and closures, which include function pointers and returning closures.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="df380b1f8d3c4226cb4356e67a4308029f7b04af" translate="yes" xml:space="preserve">
          <source>Next, we&amp;rsquo;ll fix the body of &lt;code&gt;Config::new&lt;/code&gt;. The standard library documentation also mentions that &lt;code&gt;std::env::Args&lt;/code&gt; implements the &lt;code&gt;Iterator&lt;/code&gt; trait, so we know we can call the &lt;code&gt;next&lt;/code&gt; method on it! Listing 13-27 updates the code from Listing 12-23 to use the &lt;code&gt;next&lt;/code&gt; method:</source>
          <target state="translated">Далее мы исправим тело &lt;code&gt;Config::new&lt;/code&gt; . В документации стандартной библиотеки также упоминается, что &lt;code&gt;std::env::Args&lt;/code&gt; реализует трейт &lt;code&gt;Iterator&lt;/code&gt; , поэтому мы знаем, что можем вызвать для него &lt;code&gt;next&lt;/code&gt; метод! В листинге 13-27 обновлен код из листинга 12-23 для использования &lt;code&gt;next&lt;/code&gt; метода:</target>
        </trans-unit>
        <trans-unit id="3a19f54b1a11fc876360a8c3cf621da7fa07cef6" translate="yes" xml:space="preserve">
          <source>Next, we&amp;rsquo;ll implement the &lt;code&gt;Iterator&lt;/code&gt; trait for our &lt;code&gt;Counter&lt;/code&gt; type by defining the body of the &lt;code&gt;next&lt;/code&gt; method to specify what we want to happen when this iterator is used, as shown in Listing 13-21:</source>
          <target state="translated">Затем мы реализуем &lt;code&gt;Iterator&lt;/code&gt; для нашего типа &lt;code&gt;Counter&lt;/code&gt; , определив тело &lt;code&gt;next&lt;/code&gt; метода, чтобы указать, что мы хотим, чтобы происходило при использовании этого итератора, как показано в листинге 13-21:</target>
        </trans-unit>
        <trans-unit id="8192333a1969b9548e0a4b704aec1d71dbd5da8d" translate="yes" xml:space="preserve">
          <source>Next, we&amp;rsquo;ll look at a different kind of reference: slices.</source>
          <target state="translated">Далее мы рассмотрим другой вид ссылок: срезы.</target>
        </trans-unit>
        <trans-unit id="4634a5dae53b28ce905455154ee2c8f9020614d5" translate="yes" xml:space="preserve">
          <source>Next, we&amp;rsquo;ll look at patterns, which are another of Rust&amp;rsquo;s features that enable lots of flexibility. We&amp;rsquo;ve looked at them briefly throughout the book but haven&amp;rsquo;t seen their full capability yet. Let&amp;rsquo;s go!</source>
          <target state="translated">Далее мы рассмотрим шаблоны, которые являются еще одной особенностью Rust, обеспечивающей большую гибкость. Мы вкратце изучали их на протяжении всей книги, но еще не видели их всех возможностей. Пошли!</target>
        </trans-unit>
        <trans-unit id="c7d28f3c2f2542f898d8da87d4a31466a385d3a6" translate="yes" xml:space="preserve">
          <source>Next, we&amp;rsquo;ll put everything we&amp;rsquo;ve discussed throughout the book into practice and do one more project!</source>
          <target state="translated">Далее мы применим на практике все, что мы обсуждали в книге, и сделаем еще один проект!</target>
        </trans-unit>
        <trans-unit id="b241e1c5f37c0baa3f70582a9ac2883d59e35af5" translate="yes" xml:space="preserve">
          <source>Next, we&amp;rsquo;ll talk about concurrency in Rust. You&amp;rsquo;ll even learn about a few new smart pointers.</source>
          <target state="translated">Далее мы поговорим о параллелизме в Rust. Вы даже узнаете о нескольких новых умных указателях.</target>
        </trans-unit>
        <trans-unit id="03a59d930c382bd744dde7a012f05351047ee5cc" translate="yes" xml:space="preserve">
          <source>Next, we&amp;rsquo;ll talk about functions and closures!</source>
          <target state="translated">Далее поговорим о функциях и замыканиях!</target>
        </trans-unit>
        <trans-unit id="1fde554107211f23cac1a0bbf25be3203f7855d9" translate="yes" xml:space="preserve">
          <source>Next, we&amp;rsquo;ll talk about idiomatic ways to model problems and structure solutions as your Rust programs get bigger. In addition, we&amp;rsquo;ll discuss how Rust&amp;rsquo;s idioms relate to those you might be familiar with from object-oriented programming.</source>
          <target state="translated">Далее мы поговорим об идиоматических способах моделирования проблем и структурирования решений по мере того, как ваши программы на Rust становятся больше. Кроме того, мы обсудим, как идиомы Rust соотносятся с идиомами, с которыми вы, возможно, знакомы по объектно-ориентированному программированию.</target>
        </trans-unit>
        <trans-unit id="12c381a078ea586c1a6dde5139c1770828ccdb51" translate="yes" xml:space="preserve">
          <source>Next, we&amp;rsquo;ll use our struct definition and create one &lt;code&gt;Node&lt;/code&gt; instance named &lt;code&gt;leaf&lt;/code&gt; with the value 3 and no children, and another instance named &lt;code&gt;branch&lt;/code&gt; with the value 5 and &lt;code&gt;leaf&lt;/code&gt; as one of its children, as shown in Listing 15-27:</source>
          <target state="translated">Затем мы воспользуемся нашим определением структуры и создадим один экземпляр &lt;code&gt;Node&lt;/code&gt; именем &lt;code&gt;leaf&lt;/code&gt; со значением 3 и без дочерних элементов , а другой экземпляр с именем &lt;code&gt;branch&lt;/code&gt; со значением 5 и &lt;code&gt;leaf&lt;/code&gt; качестве одного из его дочерних элементов, как показано в листинге 15-27:</target>
        </trans-unit>
        <trans-unit id="49cce52cf3729ef44c726e5a417fc215b857117b" translate="yes" xml:space="preserve">
          <source>Next, we&amp;rsquo;ll use these same steps with generics to reduce code duplication in different ways. In the same way that the function body can operate on an abstract &lt;code&gt;list&lt;/code&gt; instead of specific values, generics allow code to operate on abstract types.</source>
          <target state="translated">Затем мы будем использовать те же шаги с универсальными шаблонами, чтобы по-разному уменьшить дублирование кода. Точно так же, как тело функции может работать с абстрактным &lt;code&gt;list&lt;/code&gt; вместо определенных значений, универсальные шаблоны позволяют коду работать с абстрактными типами.</target>
        </trans-unit>
        <trans-unit id="05f6878762b08e453ff7c9c981e816c32f84aa8d" translate="yes" xml:space="preserve">
          <source>Next, we&amp;rsquo;re adding two lines in the middle. The &lt;code&gt;rand::thread_rng&lt;/code&gt; function will give us the particular random number generator that we&amp;rsquo;re going to use: one that is local to the current thread of execution and seeded by the operating system. Then we call the &lt;code&gt;gen_range&lt;/code&gt; method on the random number generator. This method is defined by the &lt;code&gt;Rng&lt;/code&gt; trait that we brought into scope with the &lt;code&gt;use rand::Rng&lt;/code&gt; statement. The &lt;code&gt;gen_range&lt;/code&gt; method takes two numbers as arguments and generates a random number between them. It&amp;rsquo;s inclusive on the lower bound but exclusive on the upper bound, so we need to specify &lt;code&gt;1&lt;/code&gt; and &lt;code&gt;101&lt;/code&gt; to request a number between 1 and 100.</source>
          <target state="translated">Затем мы добавляем две линии посередине. Функция &lt;code&gt;rand::thread_rng&lt;/code&gt; предоставит нам конкретный генератор случайных чисел, который мы собираемся использовать: тот, который является локальным по отношению к текущему потоку выполнения и заполняется операционной системой. Затем мы вызываем метод &lt;code&gt;gen_range&lt;/code&gt; генератора случайных чисел. Этот метод определяется чертой &lt;code&gt;Rng&lt;/code&gt; , которую мы ввели в область видимости с &lt;code&gt;use rand::Rng&lt;/code&gt; оператора use rand :: Rng . Метод &lt;code&gt;gen_range&lt;/code&gt; принимает два числа в качестве аргументов и генерирует между ними случайное число. Он включает нижнюю границу, но исключает верхнюю границу, поэтому нам нужно указать &lt;code&gt;1&lt;/code&gt; и &lt;code&gt;101&lt;/code&gt; , чтобы запросить число от 1 до 100.</target>
        </trans-unit>
        <trans-unit id="188a1831aead9f2050d9903c88b40256b8d0ba24" translate="yes" xml:space="preserve">
          <source>Nice! Even though spaces were added before the guess, the program still figured out that the user guessed 76. Run the program a few times to verify the different behavior with different kinds of input: guess the number correctly, guess a number that is too high, and guess a number that is too low.</source>
          <target state="translated">Здорово! Несмотря на то,что пробелы были добавлены до догадки,программа все равно выяснила,что пользователь угадал 76.Запустите программу несколько раз,чтобы проверить разное поведение с разными типами ввода:правильно угадать число,угадать число,которое слишком высоко,и угадать число,которое слишком низко.</target>
        </trans-unit>
        <trans-unit id="41d756e582a9b7133fefe3aba97d94609533d175" translate="yes" xml:space="preserve">
          <source>Nice! It&amp;rsquo;s not the prettiest output, but it shows the values of all the fields for this instance, which would definitely help during debugging. When we have larger structs, it&amp;rsquo;s useful to have output that&amp;rsquo;s a bit easier to read; in those cases, we can use &lt;code&gt;{:#?}&lt;/code&gt; instead of &lt;code&gt;{:?}&lt;/code&gt; in the &lt;code&gt;println!&lt;/code&gt; string. When we use the &lt;code&gt;{:#?}&lt;/code&gt; style in the example, the output will look like this:</source>
          <target state="translated">Ницца! Это не самый красивый вывод, но он показывает значения всех полей для этого экземпляра, что определенно поможет во время отладки. Когда у нас есть большие структуры, полезно иметь вывод, который немного легче читать; в этих случаях мы можем использовать &lt;code&gt;{:#?}&lt;/code&gt; вместо &lt;code&gt;{:?}&lt;/code&gt; в &lt;code&gt;println!&lt;/code&gt; строка. Когда мы используем стиль &lt;code&gt;{:#?}&lt;/code&gt; В примере, результат будет выглядеть следующим образом:</target>
        </trans-unit>
        <trans-unit id="c9e429b1798d0142b8b31e82c1f9da5d8e0c9420" translate="yes" xml:space="preserve">
          <source>Nightly</source>
          <target state="translated">Nightly</target>
        </trans-unit>
        <trans-unit id="0e61ca1796e0a674ec697f05ff94882071738de7" translate="yes" xml:space="preserve">
          <source>No &lt;a href=&quot;../glossary#uncovered-type&quot;&gt;uncovered type&lt;/a&gt; parameters &lt;code&gt;P1..=Pn&lt;/code&gt; may appear in &lt;code&gt;T0..Ti&lt;/code&gt; (excluding &lt;code&gt;Ti&lt;/code&gt;)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6dabebe1f19f9827a4f8cf661fd813509cd607c6" translate="yes" xml:space="preserve">
          <source>No &lt;code&gt;main&lt;/code&gt; function was found in a binary crate.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3334d46bace193a18342fe23d9ec73cf45eeee44" translate="yes" xml:space="preserve">
          <source>No &lt;code&gt;main&lt;/code&gt; function was found in a binary crate. To fix this error, add a &lt;code&gt;main&lt;/code&gt; function. For example:</source>
          <target state="translated">В бинарном ящике не обнаружено никаких &lt;code&gt;main&lt;/code&gt; функций. Чтобы исправить эту ошибку, добавьте &lt;code&gt;main&lt;/code&gt; функцию. Например:</target>
        </trans-unit>
        <trans-unit id="40e9183fb0e170dc10c265ea9f5ac313b7e7824e" translate="yes" xml:space="preserve">
          <source>No arguments to the program</source>
          <target state="translated">Никаких аргументов в пользу программы</target>
        </trans-unit>
        <trans-unit id="86e59c19b9b6a6d88fc2db18875d3bedb5eeda2c" translate="yes" xml:space="preserve">
          <source>No code is generated for this intrinsic, but the optimizer will try to preserve it (and its condition) between passes, which may interfere with optimization of surrounding code and reduce performance. It should not be used if the invariant can be discovered by the optimizer on its own, or if it does not enable any significant optimizations.</source>
          <target state="translated">Для этого внутреннего кода код не генерируется,но оптимизатор постарается сохранить его (и его состояние)между проходами,что может помешать оптимизации окружающего кода и снизить производительность.Его не следует использовать,если инвариант может быть обнаружен оптимизатором самостоятельно,или если он не позволяет проводить сколько-нибудь значимую оптимизацию.</target>
        </trans-unit>
        <trans-unit id="6d24aa51295019d1b05b76a7e56a3b4b701ef15c" translate="yes" xml:space="preserve">
          <source>No data is allocated on the heap.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b940936fa4a1fc768ca623a652084963506c1c89" translate="yes" xml:space="preserve">
          <source>No file is allowed to exist at the target location, also no (dangling) symlink. In this way, if the call succeeds, the file returned is guaranteed to be new.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bd44839870a9b58128d358fce877ecbaa11fd40a" translate="yes" xml:space="preserve">
          <source>No formal timeline for turning the warnings into errors has been set. See &lt;a href=&quot;https://github.com/rust-lang/rust/issues/58781&quot;&gt;GitHub issue 58781&lt;/a&gt; for more information.</source>
          <target state="translated">Никаких формальных сроков для превращения предупреждений в ошибки не установлено. См. &lt;a href=&quot;https://github.com/rust-lang/rust/issues/58781&quot;&gt;Выпуск 58781 GitHub&lt;/a&gt; для получения дополнительной информации.</target>
        </trans-unit>
        <trans-unit id="f506aac03a59ef1406f6d0689bfcd0dc4c05822a" translate="yes" xml:space="preserve">
          <source>No guarantees are provided about the contents of &lt;code&gt;buf&lt;/code&gt; when this function is called, implementations cannot rely on any property of the contents of &lt;code&gt;buf&lt;/code&gt; being true. It is recommended that &lt;em&gt;implementations&lt;/em&gt; only write data to &lt;code&gt;buf&lt;/code&gt; instead of reading its contents.</source>
          <target state="translated">Никаких гарантий относительно содержимого &lt;code&gt;buf&lt;/code&gt; при вызове этой функции не дается , реализации не могут полагаться на то, что какое-либо свойство содержимого &lt;code&gt;buf&lt;/code&gt; является истинным. Рекомендуется, чтобы &lt;em&gt;реализации&lt;/em&gt; записывали данные в &lt;code&gt;buf&lt;/code&gt; , а не читали его содержимое.</target>
        </trans-unit>
        <trans-unit id="4f0a95bf47b8945eb4629fd1207fec71669b8c5c" translate="yes" xml:space="preserve">
          <source>No guarantees are provided about the contents of &lt;code&gt;buf&lt;/code&gt; when this function is called, implementations cannot rely on any property of the contents of &lt;code&gt;buf&lt;/code&gt; being true. It is recommended that implementations only write data to &lt;code&gt;buf&lt;/code&gt; instead of reading its contents.</source>
          <target state="translated">Никаких гарантий относительно содержимого &lt;code&gt;buf&lt;/code&gt; при вызове этой функции не дается , реализации не могут полагаться на то, что какое-либо свойство содержимого &lt;code&gt;buf&lt;/code&gt; является истинным. Рекомендуется, чтобы реализации записывали данные в &lt;code&gt;buf&lt;/code&gt; , а не читали его содержимое.</target>
        </trans-unit>
        <trans-unit id="44c3fb55dfa5ac1ea3e6cc8751e2f98b499318f5" translate="yes" xml:space="preserve">
          <source>No guarantees are provided about the contents of &lt;code&gt;buf&lt;/code&gt; when this function is called, implementations cannot rely on any property of the contents of &lt;code&gt;buf&lt;/code&gt; being true. It is recommended that implementations only write data to &lt;code&gt;buf&lt;/code&gt; instead of reading its contents. The documentation on &lt;a href=&quot;trait.read#tymethod.read&quot;&gt;&lt;code&gt;read&lt;/code&gt;&lt;/a&gt; has a more detailed explanation on this subject.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ce0692c18a626152270d81a21a828cf37a6f5e5b" translate="yes" xml:space="preserve">
          <source>No matter whether or not you think Rust is an object-oriented language after reading this chapter, you now know that you can use trait objects to get some object-oriented features in Rust. Dynamic dispatch can give your code some flexibility in exchange for a bit of runtime performance. You can use this flexibility to implement object-oriented patterns that can help your code&amp;rsquo;s maintainability. Rust also has other features, like ownership, that object-oriented languages don&amp;rsquo;t have. An object-oriented pattern won&amp;rsquo;t always be the best way to take advantage of Rust&amp;rsquo;s strengths, but is an available option.</source>
          <target state="translated">Независимо от того, считаете ли вы Rust объектно-ориентированным языком после прочтения этой главы, теперь вы знаете, что можете использовать типажные объекты для получения некоторых объектно-ориентированных функций в Rust. Динамическая отправка может дать вашему коду некоторую гибкость в обмен на небольшую производительность во время выполнения. Вы можете использовать эту гибкость для реализации объектно-ориентированных шаблонов, которые могут улучшить ремонтопригодность вашего кода. У Rust есть и другие особенности, такие как право собственности, которых нет в объектно-ориентированных языках. Объектно-ориентированный шаблон не всегда будет лучшим способом использовать сильные стороны Rust, но он доступен.</target>
        </trans-unit>
        <trans-unit id="11ac1612603c0c3d5163e13082f76411af9ee697" translate="yes" xml:space="preserve">
          <source>No ordering constraints, only atomic operations.</source>
          <target state="translated">Никаких ограничений на заказ,только атомные операции.</target>
        </trans-unit>
        <trans-unit id="2d3c73825e4a8031f1bb82e1a976c1ab255294e6" translate="yes" xml:space="preserve">
          <source>No truncation occurs when &lt;code&gt;len&lt;/code&gt; is greater than the vector's current length:</source>
          <target state="translated">Усечение не происходит, если &lt;code&gt;len&lt;/code&gt; больше текущей длины вектора:</target>
        </trans-unit>
        <trans-unit id="9d9d7a3fa61acc7fab275007c75a11f20d8c99c2" translate="yes" xml:space="preserve">
          <source>No uncovered type parameters &lt;code&gt;P1..=Pm&lt;/code&gt; may appear in &lt;code&gt;T0..Ti&lt;/code&gt; (excluding &lt;code&gt;Ti&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1d402441c3b972c1257d41a23a0cf7d56800bfb6" translate="yes" xml:space="preserve">
          <source>No value</source>
          <target state="translated">Нет стоимости</target>
        </trans-unit>
        <trans-unit id="b8b9f1367ad6269845f5ec54d66262066092883f" translate="yes" xml:space="preserve">
          <source>No.</source>
          <target state="translated">No.</target>
        </trans-unit>
        <trans-unit id="e1e00ea722ddcc62dfc3b69613fb2a2d565490a9" translate="yes" xml:space="preserve">
          <source>Nominal types</source>
          <target state="translated">Номинальные типы</target>
        </trans-unit>
        <trans-unit id="cdb02ce94d87fb6259e95b77d6deab219ecd04ba" translate="yes" xml:space="preserve">
          <source>Nominal types &amp;mdash; &lt;a href=&quot;types/struct&quot;&gt;structs&lt;/a&gt;, &lt;a href=&quot;types/enum&quot;&gt;enumerations&lt;/a&gt; and &lt;a href=&quot;types/union&quot;&gt;unions&lt;/a&gt; &amp;mdash; may be recursive. That is, each &lt;code&gt;enum&lt;/code&gt; variant or &lt;code&gt;struct&lt;/code&gt; or &lt;code&gt;union&lt;/code&gt; field may refer, directly or indirectly, to the enclosing &lt;code&gt;enum&lt;/code&gt; or &lt;code&gt;struct&lt;/code&gt; type itself. Such recursion has restrictions:</source>
          <target state="translated">Номинальные типы - &lt;a href=&quot;types/struct&quot;&gt;структуры&lt;/a&gt; , &lt;a href=&quot;types/enum&quot;&gt;перечисления&lt;/a&gt; и &lt;a href=&quot;types/union&quot;&gt;объединения&lt;/a&gt; - могут быть рекурсивными. То есть каждый вариант &lt;code&gt;enum&lt;/code&gt; или &lt;code&gt;struct&lt;/code&gt; или поле &lt;code&gt;union&lt;/code&gt; может прямо или косвенно ссылаться на включающее &lt;code&gt;enum&lt;/code&gt; или сам тип &lt;code&gt;struct&lt;/code&gt; . У такой рекурсии есть ограничения:</target>
        </trans-unit>
        <trans-unit id="f4149c46b37e254e72be155dd7b9caf947125984" translate="yes" xml:space="preserve">
          <source>Nominal types &amp;mdash; &lt;a href=&quot;types/struct&quot;&gt;structs&lt;/a&gt;, &lt;a href=&quot;types/enum&quot;&gt;enumerations&lt;/a&gt;, and &lt;a href=&quot;types/union&quot;&gt;unions&lt;/a&gt; &amp;mdash; may be recursive. That is, each &lt;code&gt;enum&lt;/code&gt; variant or &lt;code&gt;struct&lt;/code&gt; or &lt;code&gt;union&lt;/code&gt; field may refer, directly or indirectly, to the enclosing &lt;code&gt;enum&lt;/code&gt; or &lt;code&gt;struct&lt;/code&gt; type itself. Such recursion has restrictions:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b2b8571666155408fb60b3d7bfe218ca438c97ed" translate="yes" xml:space="preserve">
          <source>Nominal types without a &lt;code&gt;repr&lt;/code&gt; attribute have the default representation. Informally, this representation is also called the &lt;code&gt;rust&lt;/code&gt; representation.</source>
          <target state="translated">Номинальные типы без атрибута &lt;code&gt;repr&lt;/code&gt; имеют представление по умолчанию. Неформально это представление также называют представлением &lt;code&gt;rust&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5059fea19d0d88b99facd98e04beb3723c567878" translate="yes" xml:space="preserve">
          <source>Non capturing closures to &lt;code&gt;fn&lt;/code&gt; pointers</source>
          <target state="translated">Не захватывающие замыкания в указатели &lt;code&gt;fn&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a51a0d057519ba84abe774072805e81677bec4c4" translate="yes" xml:space="preserve">
          <source>Non-&lt;code&gt;mut&lt;/code&gt; static items that contain a type that is not &lt;a href=&quot;../interior-mutability&quot;&gt;interior mutable&lt;/a&gt; may be placed in read-only memory.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1983af4c53629f3985aabae2faea197763bce6d6" translate="yes" xml:space="preserve">
          <source>Non-UTF-8 byte sequences in a &lt;code&gt;str&lt;/code&gt;.</source>
          <target state="translated">Последовательности байтов, отличных от UTF-8, в &lt;code&gt;str&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c7afa6ec3e9abfb77b76d7813a424b3a22eeb6a6" translate="yes" xml:space="preserve">
          <source>Non-allocating substring search.</source>
          <target state="translated">Поиск нераспределяемой подстроки.</target>
        </trans-unit>
        <trans-unit id="918c67058d00d25e0f0f3d637bc930eba67e9f26" translate="yes" xml:space="preserve">
          <source>Non-ascii can be used as module names if it is inlined or if a &lt;code&gt;#[path]&lt;/code&gt; attribute is specified. For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3dcd44915e2ff9a86c47e1f5d9c641f6ca3a035b" translate="yes" xml:space="preserve">
          <source>Non-doc comments</source>
          <target state="translated">Недокументарные комментарии</target>
        </trans-unit>
        <trans-unit id="824440476584993bab7b4958488eb74ef1df4ce3" translate="yes" xml:space="preserve">
          <source>Non-doc comments are interpreted as a form of whitespace.</source>
          <target state="translated">Недокументарные комментарии интерпретируются как форма пробела.</target>
        </trans-unit>
        <trans-unit id="aa21851a9f906887214ca347fd6a9f54a7e9f855" translate="yes" xml:space="preserve">
          <source>Non-exhaustive enums could have additional variants added in future. Therefore, when matching against variants of non-exhaustive enums, an extra wildcard arm must be added to account for any future variants.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="10cecc28192fc5e84850b4a3c1cd7bbfd836407b" translate="yes" xml:space="preserve">
          <source>Non-exhaustive enums could have additional variants added in future. Therefore, when matching against variants of non-exhaustive enums, an extra wildcard arm must be added to account for any future variants.&lt;span id=&quot;variant.Empty&quot;&gt;&lt;code id=&quot;Empty.v&quot;&gt;Empty&lt;/code&gt;&lt;/span&gt;</source>
          <target state="translated">В неполные перечисления в будущем могут быть добавлены дополнительные варианты. Следовательно, при сопоставлении с вариантами неполных перечислений необходимо добавить дополнительную ветвь с подстановочными знаками для учета любых будущих вариантов. &lt;span id=&quot;variant.Empty&quot;&gt; &lt;code id=&quot;Empty.v&quot;&gt;Empty&lt;/code&gt; &lt;/span&gt;</target>
        </trans-unit>
        <trans-unit id="c2d926eda1237eaff90e4752c522197b25cce1b5" translate="yes" xml:space="preserve">
          <source>Non-exhaustive enums could have additional variants added in future. Therefore, when matching against variants of non-exhaustive enums, an extra wildcard arm must be added to account for any future variants.&lt;span id=&quot;variant.NotFound&quot;&gt;&lt;code id=&quot;NotFound.v&quot;&gt;NotFound&lt;/code&gt;&lt;/span&gt;</source>
          <target state="translated">В неполные перечисления в будущем могут быть добавлены дополнительные варианты. Следовательно, при сопоставлении с вариантами неполных перечислений необходимо добавить дополнительную ветвь с подстановочными знаками для учета любых будущих вариантов. &lt;span id=&quot;variant.NotFound&quot;&gt; &lt;code id=&quot;NotFound.v&quot;&gt;NotFound&lt;/code&gt; &lt;/span&gt;</target>
        </trans-unit>
        <trans-unit id="9ffc5a4a3c3cd6c9da0af373638cb3d4d5bda691" translate="yes" xml:space="preserve">
          <source>Non-exhaustive enums could have additional variants added in future. Therefore, when matching against variants of non-exhaustive enums, an extra wildcard arm must be added to account for any future variants.&lt;span id=&quot;variant.Relaxed&quot;&gt;&lt;code id=&quot;Relaxed.v&quot;&gt;Relaxed&lt;/code&gt;&lt;/span&gt;</source>
          <target state="translated">В неполные перечисления в будущем могут быть добавлены дополнительные варианты. Следовательно, при сопоставлении с вариантами неполных перечислений необходимо добавить дополнительную ветвь с подстановочными знаками для учета любых будущих вариантов. &lt;span id=&quot;variant.Relaxed&quot;&gt; &lt;code id=&quot;Relaxed.v&quot;&gt;Relaxed&lt;/code&gt; &lt;/span&gt;</target>
        </trans-unit>
        <trans-unit id="0eb9bd2ad410dc2a883c07d5cdc83ffe0afd40df" translate="yes" xml:space="preserve">
          <source>Non-exhaustive types are always considered inhabited in downstream crates.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0c1a6b0df00b9143148ae426e200b78dbd7fb89f" translate="yes" xml:space="preserve">
          <source>Non-exhaustive types cannot be constructed outside of the defining crate:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f438ec02f71051c0a40ce9311998d29382298836" translate="yes" xml:space="preserve">
          <source>Non-exhaustive variants (&lt;a href=&quot;../items/structs&quot;&gt;&lt;code&gt;struct&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;../items/enumerations&quot;&gt;&lt;code&gt;enum&lt;/code&gt; variant&lt;/a&gt;) cannot be constructed with a &lt;a href=&quot;../expressions/struct-expr&quot;&gt;&lt;em&gt;StructExpression&lt;/em&gt;&lt;/a&gt; (including with &lt;a href=&quot;../expressions/struct-expr#functional-update-syntax&quot;&gt;functional update syntax&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="677ced73d5856aaca0b6f678eabc91c14dca818b" translate="yes" xml:space="preserve">
          <source>Non-operator Symbols</source>
          <target state="translated">Символы без оператора</target>
        </trans-unit>
        <trans-unit id="4e30c9c45a102a66eb26f8221fcbff4ef463e321" translate="yes" xml:space="preserve">
          <source>NonNull</source>
          <target state="translated">NonNull</target>
        </trans-unit>
        <trans-unit id="4406dddaf8fa2617ceb6cc8c44402048c8cf820a" translate="yes" xml:space="preserve">
          <source>NonNull::as_mut</source>
          <target state="translated">NonNull::as_mut</target>
        </trans-unit>
        <trans-unit id="2114c5e9abc5430a075844ac84cde8dc1be1fea6" translate="yes" xml:space="preserve">
          <source>NonNull::as_ptr</source>
          <target state="translated">NonNull::as_ptr</target>
        </trans-unit>
        <trans-unit id="1cabae6d82425bb900a0d474f79596c63d831307" translate="yes" xml:space="preserve">
          <source>NonNull::as_ref</source>
          <target state="translated">NonNull::as_ref</target>
        </trans-unit>
        <trans-unit id="6ed17b6bc3c37842c56b35d303eedea6a7299966" translate="yes" xml:space="preserve">
          <source>NonNull::borrow</source>
          <target state="translated">NonNull::borrow</target>
        </trans-unit>
        <trans-unit id="7e334211ca12677d4c793a4a4f5aff0a42317022" translate="yes" xml:space="preserve">
          <source>NonNull::borrow_mut</source>
          <target state="translated">NonNull::borrow_mut</target>
        </trans-unit>
        <trans-unit id="d14ea41704eb3153152593ae4083750dca37c043" translate="yes" xml:space="preserve">
          <source>NonNull::cast</source>
          <target state="translated">NonNull::cast</target>
        </trans-unit>
        <trans-unit id="898faa9b1446e51151d3471366dee5a575326bb3" translate="yes" xml:space="preserve">
          <source>NonNull::clamp</source>
          <target state="translated">NonNull::clamp</target>
        </trans-unit>
        <trans-unit id="bf5ade412290b7a0e9f887083d2f7add59f5a5fc" translate="yes" xml:space="preserve">
          <source>NonNull::clone</source>
          <target state="translated">NonNull::clone</target>
        </trans-unit>
        <trans-unit id="d26e757d1bc68cfc66ec9cac7468feab54ad3bf1" translate="yes" xml:space="preserve">
          <source>NonNull::clone_from</source>
          <target state="translated">NonNull::clone_from</target>
        </trans-unit>
        <trans-unit id="ec88376a17645ec47ad005ff58328f13df7dd535" translate="yes" xml:space="preserve">
          <source>NonNull::clone_into</source>
          <target state="translated">NonNull::clone_into</target>
        </trans-unit>
        <trans-unit id="fd33327c1c03c18157e310949eb3ee49adc1b771" translate="yes" xml:space="preserve">
          <source>NonNull::cmp</source>
          <target state="translated">NonNull::cmp</target>
        </trans-unit>
        <trans-unit id="987e425f6d75ea2d5d6595ecf927bb4ee065890c" translate="yes" xml:space="preserve">
          <source>NonNull::dangling</source>
          <target state="translated">NonNull::dangling</target>
        </trans-unit>
        <trans-unit id="c22e4114ed2e98fa57926d0f979b5e4f67cb57d4" translate="yes" xml:space="preserve">
          <source>NonNull::eq</source>
          <target state="translated">NonNull::eq</target>
        </trans-unit>
        <trans-unit id="d00b2d876766572056074e351b4e54188d623d2b" translate="yes" xml:space="preserve">
          <source>NonNull::fmt</source>
          <target state="translated">NonNull::fmt</target>
        </trans-unit>
        <trans-unit id="920d1fd41b172fec04d2e45bb2bdef697e4fe777" translate="yes" xml:space="preserve">
          <source>NonNull::from</source>
          <target state="translated">NonNull::from</target>
        </trans-unit>
        <trans-unit id="e069f30f0197691ef84cfb150cfed51e68e388e1" translate="yes" xml:space="preserve">
          <source>NonNull::ge</source>
          <target state="translated">NonNull::ge</target>
        </trans-unit>
        <trans-unit id="c04dde85527ee18200a552eae552b457a7f99bd6" translate="yes" xml:space="preserve">
          <source>NonNull::gt</source>
          <target state="translated">NonNull::gt</target>
        </trans-unit>
        <trans-unit id="1962f7d627fcf30051ef24ad505c0bc5f914d525" translate="yes" xml:space="preserve">
          <source>NonNull::hash</source>
          <target state="translated">NonNull::hash</target>
        </trans-unit>
        <trans-unit id="947f5524bfbda623a81d3a1c8013f457968a7a86" translate="yes" xml:space="preserve">
          <source>NonNull::hash_slice</source>
          <target state="translated">NonNull::hash_slice</target>
        </trans-unit>
        <trans-unit id="389c43bbeacefc5b6764890179f4b9b2032438f2" translate="yes" xml:space="preserve">
          <source>NonNull::into</source>
          <target state="translated">NonNull::into</target>
        </trans-unit>
        <trans-unit id="47e7802874702c46a2e861846c1495c139c4c850" translate="yes" xml:space="preserve">
          <source>NonNull::le</source>
          <target state="translated">NonNull::le</target>
        </trans-unit>
        <trans-unit id="9345c04e2a031789eec4e0c10625a029c4ae6f61" translate="yes" xml:space="preserve">
          <source>NonNull::lt</source>
          <target state="translated">NonNull::lt</target>
        </trans-unit>
        <trans-unit id="7a29d42be85ea3d359fc0499cfc787631cbd8fc5" translate="yes" xml:space="preserve">
          <source>NonNull::max</source>
          <target state="translated">NonNull::max</target>
        </trans-unit>
        <trans-unit id="61df043b4cb69b06e977ed45aa61b72a55c0c1a7" translate="yes" xml:space="preserve">
          <source>NonNull::min</source>
          <target state="translated">NonNull::min</target>
        </trans-unit>
        <trans-unit id="abded46d5ba3ed8a510f52a6c525d34081184868" translate="yes" xml:space="preserve">
          <source>NonNull::ne</source>
          <target state="translated">NonNull::ne</target>
        </trans-unit>
        <trans-unit id="28098f7280cb4f6eb94dfb98674503d36042312c" translate="yes" xml:space="preserve">
          <source>NonNull::new</source>
          <target state="translated">NonNull::new</target>
        </trans-unit>
        <trans-unit id="faebd85a1d1a684a9974b3cced67816fb864d3e2" translate="yes" xml:space="preserve">
          <source>NonNull::new_unchecked</source>
          <target state="translated">NonNull::new_unchecked</target>
        </trans-unit>
        <trans-unit id="daad03caa96878a899bd74268cdf22f8762238fc" translate="yes" xml:space="preserve">
          <source>NonNull::partial_cmp</source>
          <target state="translated">NonNull::partial_cmp</target>
        </trans-unit>
        <trans-unit id="4a54ca911ffa7ae9c156cb290778a55bb5102986" translate="yes" xml:space="preserve">
          <source>NonNull::to_owned</source>
          <target state="translated">NonNull::to_owned</target>
        </trans-unit>
        <trans-unit id="9c8c974cd30a86ae9347bdcc34e89477c2ec64af" translate="yes" xml:space="preserve">
          <source>NonNull::try_from</source>
          <target state="translated">NonNull::try_from</target>
        </trans-unit>
        <trans-unit id="cbe36570c4b5d03cc4de672aa3768cec6ff79fc7" translate="yes" xml:space="preserve">
          <source>NonNull::try_into</source>
          <target state="translated">NonNull::try_into</target>
        </trans-unit>
        <trans-unit id="5c4656d738141e414301ef5f2fc675edf57dbe67" translate="yes" xml:space="preserve">
          <source>NonNull::type_id</source>
          <target state="translated">NonNull::type_id</target>
        </trans-unit>
        <trans-unit id="3551d2c727366d003ebd8c642167f4ef9debfb26" translate="yes" xml:space="preserve">
          <source>NonZeroI128</source>
          <target state="translated">NonZeroI128</target>
        </trans-unit>
        <trans-unit id="f7717a5e03944c9f7da8d5810a2b468333e1dd38" translate="yes" xml:space="preserve">
          <source>NonZeroI128::borrow</source>
          <target state="translated">NonZeroI128::borrow</target>
        </trans-unit>
        <trans-unit id="f964efe706788bf3868121236c120eec56d477d3" translate="yes" xml:space="preserve">
          <source>NonZeroI128::borrow_mut</source>
          <target state="translated">NonZeroI128::borrow_mut</target>
        </trans-unit>
        <trans-unit id="5ff8443b26f494de74b190931a04e5ad0a0f8bce" translate="yes" xml:space="preserve">
          <source>NonZeroI128::clamp</source>
          <target state="translated">NonZeroI128::clamp</target>
        </trans-unit>
        <trans-unit id="b41821f2bbc6d793e496bf8cf8e0961c8c6cf20e" translate="yes" xml:space="preserve">
          <source>NonZeroI128::clone</source>
          <target state="translated">NonZeroI128::clone</target>
        </trans-unit>
        <trans-unit id="86b0e71b93cf7cfc8d3f88502fefd684a7508a83" translate="yes" xml:space="preserve">
          <source>NonZeroI128::clone_from</source>
          <target state="translated">NonZeroI128::clone_from</target>
        </trans-unit>
        <trans-unit id="e87976c36fbb769fdf82eb4fc79b3850621b2d11" translate="yes" xml:space="preserve">
          <source>NonZeroI128::clone_into</source>
          <target state="translated">NonZeroI128::clone_into</target>
        </trans-unit>
        <trans-unit id="1fbab26faccad65c9594c9912db60595257c834d" translate="yes" xml:space="preserve">
          <source>NonZeroI128::cmp</source>
          <target state="translated">NonZeroI128::cmp</target>
        </trans-unit>
        <trans-unit id="e40f0ecb53bba7364d61eeddde211916e2de23b0" translate="yes" xml:space="preserve">
          <source>NonZeroI128::eq</source>
          <target state="translated">NonZeroI128::eq</target>
        </trans-unit>
        <trans-unit id="06203fb0241e3db251fdbeb37b55ecf55bc73b90" translate="yes" xml:space="preserve">
          <source>NonZeroI128::fmt</source>
          <target state="translated">NonZeroI128::fmt</target>
        </trans-unit>
        <trans-unit id="0fc860ac20708b78eba2f88aebf4c0cae43f1b01" translate="yes" xml:space="preserve">
          <source>NonZeroI128::from</source>
          <target state="translated">NonZeroI128::from</target>
        </trans-unit>
        <trans-unit id="e9225e88cc3a187fc6e8da37813f50d8aace8352" translate="yes" xml:space="preserve">
          <source>NonZeroI128::from_str</source>
          <target state="translated">NonZeroI128::from_str</target>
        </trans-unit>
        <trans-unit id="1060cfd82a1c5a4f9319951b3ccf33667960e338" translate="yes" xml:space="preserve">
          <source>NonZeroI128::ge</source>
          <target state="translated">NonZeroI128::ge</target>
        </trans-unit>
        <trans-unit id="1174fff40e9915f0fddc11dc5e858638caff1eb7" translate="yes" xml:space="preserve">
          <source>NonZeroI128::get</source>
          <target state="translated">NonZeroI128::get</target>
        </trans-unit>
        <trans-unit id="6360aa3b732a77c2367a197d6649d264398a3733" translate="yes" xml:space="preserve">
          <source>NonZeroI128::gt</source>
          <target state="translated">NonZeroI128::gt</target>
        </trans-unit>
        <trans-unit id="74c9ab59cffa5d7149b9a4669f4269b74eeb9074" translate="yes" xml:space="preserve">
          <source>NonZeroI128::hash</source>
          <target state="translated">NonZeroI128::hash</target>
        </trans-unit>
        <trans-unit id="683d8b9cc521cc55c631921795be0979d992e3f0" translate="yes" xml:space="preserve">
          <source>NonZeroI128::hash_slice</source>
          <target state="translated">NonZeroI128::hash_slice</target>
        </trans-unit>
        <trans-unit id="aa52174afecb1310862de00467bdc35c65937a26" translate="yes" xml:space="preserve">
          <source>NonZeroI128::into</source>
          <target state="translated">NonZeroI128::into</target>
        </trans-unit>
        <trans-unit id="148aa4d7eea87fc4622065d40fb8f2ec58899a47" translate="yes" xml:space="preserve">
          <source>NonZeroI128::le</source>
          <target state="translated">NonZeroI128::le</target>
        </trans-unit>
        <trans-unit id="4cab526460d9eafdf6e790d31dfeefc0f6385568" translate="yes" xml:space="preserve">
          <source>NonZeroI128::lt</source>
          <target state="translated">NonZeroI128::lt</target>
        </trans-unit>
        <trans-unit id="c0e0f0d6f1984e61de46b50df3dd15bb2c3be699" translate="yes" xml:space="preserve">
          <source>NonZeroI128::max</source>
          <target state="translated">NonZeroI128::max</target>
        </trans-unit>
        <trans-unit id="afd96d69d525973449f87aee12afd0af77bb90ff" translate="yes" xml:space="preserve">
          <source>NonZeroI128::min</source>
          <target state="translated">NonZeroI128::min</target>
        </trans-unit>
        <trans-unit id="246cde0659cbc3a878d28d1aa05929c570deac33" translate="yes" xml:space="preserve">
          <source>NonZeroI128::ne</source>
          <target state="translated">NonZeroI128::ne</target>
        </trans-unit>
        <trans-unit id="8673425a72ca5491b6fece38839c045e52eb4d36" translate="yes" xml:space="preserve">
          <source>NonZeroI128::new</source>
          <target state="translated">NonZeroI128::new</target>
        </trans-unit>
        <trans-unit id="83c86c3acc20bd4fdf03572b0722c1f12370f0bb" translate="yes" xml:space="preserve">
          <source>NonZeroI128::new_unchecked</source>
          <target state="translated">NonZeroI128::new_unchecked</target>
        </trans-unit>
        <trans-unit id="7d31a0e09cd71a4a287a5059ffc925fb40c7ce05" translate="yes" xml:space="preserve">
          <source>NonZeroI128::partial_cmp</source>
          <target state="translated">NonZeroI128::partial_cmp</target>
        </trans-unit>
        <trans-unit id="608c27b25bdd1b009cc3a24d8a6782000bd55a1c" translate="yes" xml:space="preserve">
          <source>NonZeroI128::to_owned</source>
          <target state="translated">NonZeroI128::to_owned</target>
        </trans-unit>
        <trans-unit id="744cd6d60888a33636a82b0368460edf2109a4f4" translate="yes" xml:space="preserve">
          <source>NonZeroI128::to_string</source>
          <target state="translated">NonZeroI128::to_string</target>
        </trans-unit>
        <trans-unit id="ac99be0bfb14a319fad21b69b5e280921b9604e7" translate="yes" xml:space="preserve">
          <source>NonZeroI128::try_from</source>
          <target state="translated">NonZeroI128::try_from</target>
        </trans-unit>
        <trans-unit id="2abe344dbf2f82320c3d223157d57b6766d23549" translate="yes" xml:space="preserve">
          <source>NonZeroI128::try_into</source>
          <target state="translated">NonZeroI128::try_into</target>
        </trans-unit>
        <trans-unit id="10a577a305c3efc3499cc94da566386465669213" translate="yes" xml:space="preserve">
          <source>NonZeroI128::type_id</source>
          <target state="translated">NonZeroI128::type_id</target>
        </trans-unit>
        <trans-unit id="36f429958b2bd2e0923475b148a0c1f6e808e911" translate="yes" xml:space="preserve">
          <source>NonZeroI16</source>
          <target state="translated">NonZeroI16</target>
        </trans-unit>
        <trans-unit id="18b48de75cdc24dca01c5ee1c28e20115a7eb2a1" translate="yes" xml:space="preserve">
          <source>NonZeroI16::borrow</source>
          <target state="translated">NonZeroI16::borrow</target>
        </trans-unit>
        <trans-unit id="bdbca21815164e23bce622eb47091fb5f9f2176c" translate="yes" xml:space="preserve">
          <source>NonZeroI16::borrow_mut</source>
          <target state="translated">NonZeroI16::borrow_mut</target>
        </trans-unit>
        <trans-unit id="2541826a258687d3b644073478113268e63c74af" translate="yes" xml:space="preserve">
          <source>NonZeroI16::clamp</source>
          <target state="translated">NonZeroI16::clamp</target>
        </trans-unit>
        <trans-unit id="115ee98eb9f17414d1638645fa06af3167003827" translate="yes" xml:space="preserve">
          <source>NonZeroI16::clone</source>
          <target state="translated">NonZeroI16::clone</target>
        </trans-unit>
        <trans-unit id="0278b33294858e10f554d1971ffc6f87bb8f5b09" translate="yes" xml:space="preserve">
          <source>NonZeroI16::clone_from</source>
          <target state="translated">NonZeroI16::clone_from</target>
        </trans-unit>
        <trans-unit id="c7c71d2e0fcced1b160e7459dff80d6f48dcbc4f" translate="yes" xml:space="preserve">
          <source>NonZeroI16::clone_into</source>
          <target state="translated">NonZeroI16::clone_into</target>
        </trans-unit>
        <trans-unit id="850888fdd17f8d9104362438c1677057b27654a4" translate="yes" xml:space="preserve">
          <source>NonZeroI16::cmp</source>
          <target state="translated">NonZeroI16::cmp</target>
        </trans-unit>
        <trans-unit id="f05c890da588a6175c01f462a0b77681853ea3b1" translate="yes" xml:space="preserve">
          <source>NonZeroI16::eq</source>
          <target state="translated">NonZeroI16::eq</target>
        </trans-unit>
        <trans-unit id="afd24843e5add4461be3e24eb291a9cc7627956c" translate="yes" xml:space="preserve">
          <source>NonZeroI16::fmt</source>
          <target state="translated">NonZeroI16::fmt</target>
        </trans-unit>
        <trans-unit id="4858ff995b8e659abd51265d63ea466463440d7f" translate="yes" xml:space="preserve">
          <source>NonZeroI16::from</source>
          <target state="translated">NonZeroI16::from</target>
        </trans-unit>
        <trans-unit id="e029bc06979cac03c696126c7078fc97b9d215f8" translate="yes" xml:space="preserve">
          <source>NonZeroI16::from_str</source>
          <target state="translated">NonZeroI16::from_str</target>
        </trans-unit>
        <trans-unit id="bafd6163144db642a0a88ae9a0d1f67a9aa327c8" translate="yes" xml:space="preserve">
          <source>NonZeroI16::ge</source>
          <target state="translated">NonZeroI16::ge</target>
        </trans-unit>
        <trans-unit id="8aabc8e5c65d44f1317cc2c944b8544a7d7743b4" translate="yes" xml:space="preserve">
          <source>NonZeroI16::get</source>
          <target state="translated">NonZeroI16::get</target>
        </trans-unit>
        <trans-unit id="f4bd402ef0cb908aeee7f003297047e0d4730ffe" translate="yes" xml:space="preserve">
          <source>NonZeroI16::gt</source>
          <target state="translated">NonZeroI16::gt</target>
        </trans-unit>
        <trans-unit id="eea24fe60c2ee511de571b916e274e0b8b9953ea" translate="yes" xml:space="preserve">
          <source>NonZeroI16::hash</source>
          <target state="translated">NonZeroI16::hash</target>
        </trans-unit>
        <trans-unit id="2072b7c0817666ffd6461a331c7f56a7e3159241" translate="yes" xml:space="preserve">
          <source>NonZeroI16::hash_slice</source>
          <target state="translated">NonZeroI16::hash_slice</target>
        </trans-unit>
        <trans-unit id="609c336f653a5586992a687fdc21a4e12e0e5bfc" translate="yes" xml:space="preserve">
          <source>NonZeroI16::into</source>
          <target state="translated">NonZeroI16::into</target>
        </trans-unit>
        <trans-unit id="dcd26dca67e989e320ea7d8ce4a6b4b2f5a19253" translate="yes" xml:space="preserve">
          <source>NonZeroI16::le</source>
          <target state="translated">NonZeroI16::le</target>
        </trans-unit>
        <trans-unit id="764441ce7cfb74845e4e5601e7c04d15cb44d34d" translate="yes" xml:space="preserve">
          <source>NonZeroI16::lt</source>
          <target state="translated">NonZeroI16::lt</target>
        </trans-unit>
        <trans-unit id="ba011aa8171b9001b2fd20e4d332efc5ad115b12" translate="yes" xml:space="preserve">
          <source>NonZeroI16::max</source>
          <target state="translated">NonZeroI16::max</target>
        </trans-unit>
        <trans-unit id="a323327b77c7bebd588241f8e49fcd0eb80d98c1" translate="yes" xml:space="preserve">
          <source>NonZeroI16::min</source>
          <target state="translated">NonZeroI16::min</target>
        </trans-unit>
        <trans-unit id="2ea2360fbbb5c24f384364e47a1ccf667fabf208" translate="yes" xml:space="preserve">
          <source>NonZeroI16::ne</source>
          <target state="translated">NonZeroI16::ne</target>
        </trans-unit>
        <trans-unit id="8a2d9c5311b2f8e5e740b1521cf3f032afe2075a" translate="yes" xml:space="preserve">
          <source>NonZeroI16::new</source>
          <target state="translated">NonZeroI16::new</target>
        </trans-unit>
        <trans-unit id="d31ab8bc0d5d31927c609f1a69be30fb3accda97" translate="yes" xml:space="preserve">
          <source>NonZeroI16::new_unchecked</source>
          <target state="translated">NonZeroI16::new_unchecked</target>
        </trans-unit>
        <trans-unit id="9f248594130914dc8c1850b1503ca6a5baa9ab10" translate="yes" xml:space="preserve">
          <source>NonZeroI16::partial_cmp</source>
          <target state="translated">NonZeroI16::partial_cmp</target>
        </trans-unit>
        <trans-unit id="e47f6505b2ad746102f22ad01953cb709a47b9ca" translate="yes" xml:space="preserve">
          <source>NonZeroI16::to_owned</source>
          <target state="translated">NonZeroI16::to_owned</target>
        </trans-unit>
        <trans-unit id="9e491563b10305c5dc822fc5b251f24741e46929" translate="yes" xml:space="preserve">
          <source>NonZeroI16::to_string</source>
          <target state="translated">NonZeroI16::to_string</target>
        </trans-unit>
        <trans-unit id="f4ff4d972a8c42fa8c0abaffc2f1e2b76fcb4197" translate="yes" xml:space="preserve">
          <source>NonZeroI16::try_from</source>
          <target state="translated">NonZeroI16::try_from</target>
        </trans-unit>
        <trans-unit id="63b8ff5cf42ec223a0adb54868428b7e995a5c22" translate="yes" xml:space="preserve">
          <source>NonZeroI16::try_into</source>
          <target state="translated">NonZeroI16::try_into</target>
        </trans-unit>
        <trans-unit id="c06a21dec83a42f8edb2e0d6693bc0ed2ab66da7" translate="yes" xml:space="preserve">
          <source>NonZeroI16::type_id</source>
          <target state="translated">NonZeroI16::type_id</target>
        </trans-unit>
        <trans-unit id="e97bcb5feaee0189523545e2b1d1eaf6c4e683e0" translate="yes" xml:space="preserve">
          <source>NonZeroI32</source>
          <target state="translated">NonZeroI32</target>
        </trans-unit>
        <trans-unit id="54c92b19f0c002e52d95b9a54c687cabaec7d0c3" translate="yes" xml:space="preserve">
          <source>NonZeroI32::borrow</source>
          <target state="translated">NonZeroI32::borrow</target>
        </trans-unit>
        <trans-unit id="6269e913feb8c230d29ea7ab62da579bdbf5a4eb" translate="yes" xml:space="preserve">
          <source>NonZeroI32::borrow_mut</source>
          <target state="translated">NonZeroI32::borrow_mut</target>
        </trans-unit>
        <trans-unit id="1224c3cd7e71ba3386431b31298d37d70f8c5b82" translate="yes" xml:space="preserve">
          <source>NonZeroI32::clamp</source>
          <target state="translated">NonZeroI32::clamp</target>
        </trans-unit>
        <trans-unit id="84582bf1efcf9bffacf576b2dc9d228ded21783f" translate="yes" xml:space="preserve">
          <source>NonZeroI32::clone</source>
          <target state="translated">NonZeroI32::clone</target>
        </trans-unit>
        <trans-unit id="6d253c4ffdb7629f523cd7bb9f9e369a62759084" translate="yes" xml:space="preserve">
          <source>NonZeroI32::clone_from</source>
          <target state="translated">NonZeroI32::clone_from</target>
        </trans-unit>
        <trans-unit id="1193f158b2ad7d7a268d3f866cb7f7b1315214d1" translate="yes" xml:space="preserve">
          <source>NonZeroI32::clone_into</source>
          <target state="translated">NonZeroI32::clone_into</target>
        </trans-unit>
        <trans-unit id="4b603b1e9d2c2afaaf494daaf899ac95dbaaf60d" translate="yes" xml:space="preserve">
          <source>NonZeroI32::cmp</source>
          <target state="translated">NonZeroI32::cmp</target>
        </trans-unit>
        <trans-unit id="36ea7e2e5a4bb27588581579d297e2d75bde8c04" translate="yes" xml:space="preserve">
          <source>NonZeroI32::eq</source>
          <target state="translated">NonZeroI32::eq</target>
        </trans-unit>
        <trans-unit id="1edda6e591f89ce442f2cb26f60edda071d57e45" translate="yes" xml:space="preserve">
          <source>NonZeroI32::fmt</source>
          <target state="translated">NonZeroI32::fmt</target>
        </trans-unit>
        <trans-unit id="ddd4914f74fdfcbf44e61dac8ed824dc7daf8835" translate="yes" xml:space="preserve">
          <source>NonZeroI32::from</source>
          <target state="translated">NonZeroI32::from</target>
        </trans-unit>
        <trans-unit id="40c6ed7e5bb0241e56fda5056b11bd5c06468ef7" translate="yes" xml:space="preserve">
          <source>NonZeroI32::from_str</source>
          <target state="translated">NonZeroI32::from_str</target>
        </trans-unit>
        <trans-unit id="ade03fa8f0e3d00c9d57318b69563c321a5de2eb" translate="yes" xml:space="preserve">
          <source>NonZeroI32::ge</source>
          <target state="translated">NonZeroI32::ge</target>
        </trans-unit>
        <trans-unit id="1d06e8a039855892a9b222f01348adf7e49edc4d" translate="yes" xml:space="preserve">
          <source>NonZeroI32::get</source>
          <target state="translated">NonZeroI32::get</target>
        </trans-unit>
        <trans-unit id="fa60ed7434a0539f3d9490e5fd97303495e8e4c6" translate="yes" xml:space="preserve">
          <source>NonZeroI32::gt</source>
          <target state="translated">NonZeroI32::gt</target>
        </trans-unit>
        <trans-unit id="f8325277d4aaaad37e3f8e3f7eea57d33a82b14d" translate="yes" xml:space="preserve">
          <source>NonZeroI32::hash</source>
          <target state="translated">NonZeroI32::hash</target>
        </trans-unit>
        <trans-unit id="15d30eee444980fbb702c19bb0e763a3a3edcf54" translate="yes" xml:space="preserve">
          <source>NonZeroI32::hash_slice</source>
          <target state="translated">NonZeroI32::hash_slice</target>
        </trans-unit>
        <trans-unit id="803e758732aa4ff1933498c8c223c849e07ecb60" translate="yes" xml:space="preserve">
          <source>NonZeroI32::into</source>
          <target state="translated">NonZeroI32::into</target>
        </trans-unit>
        <trans-unit id="790804224c71a8a913941fd99262449cfc4eae1f" translate="yes" xml:space="preserve">
          <source>NonZeroI32::le</source>
          <target state="translated">NonZeroI32::le</target>
        </trans-unit>
        <trans-unit id="67201699a9447f0b39d54ba4f84c3b95336721f4" translate="yes" xml:space="preserve">
          <source>NonZeroI32::lt</source>
          <target state="translated">NonZeroI32::lt</target>
        </trans-unit>
        <trans-unit id="ed55b8cb9ce6596e0102020b3149699afc739afa" translate="yes" xml:space="preserve">
          <source>NonZeroI32::max</source>
          <target state="translated">NonZeroI32::max</target>
        </trans-unit>
        <trans-unit id="ea9de8a6d3342c8565ee626a42eaee51ddecb252" translate="yes" xml:space="preserve">
          <source>NonZeroI32::min</source>
          <target state="translated">NonZeroI32::min</target>
        </trans-unit>
        <trans-unit id="b4954c9a76b0d358e8ac80094df9a4364fff4cb7" translate="yes" xml:space="preserve">
          <source>NonZeroI32::ne</source>
          <target state="translated">NonZeroI32::ne</target>
        </trans-unit>
        <trans-unit id="6049048c2192264cafbbf66dce8946d4e59179cf" translate="yes" xml:space="preserve">
          <source>NonZeroI32::new</source>
          <target state="translated">NonZeroI32::new</target>
        </trans-unit>
        <trans-unit id="fffc2d80845e3795deaddee315cce1ed09540038" translate="yes" xml:space="preserve">
          <source>NonZeroI32::new_unchecked</source>
          <target state="translated">NonZeroI32::new_unchecked</target>
        </trans-unit>
        <trans-unit id="da01db7b3738e2a15dd55235e9cf2517c43505ad" translate="yes" xml:space="preserve">
          <source>NonZeroI32::partial_cmp</source>
          <target state="translated">NonZeroI32::partial_cmp</target>
        </trans-unit>
        <trans-unit id="86e152a0c12749dda033dd64bbf2468b20925901" translate="yes" xml:space="preserve">
          <source>NonZeroI32::to_owned</source>
          <target state="translated">NonZeroI32::to_owned</target>
        </trans-unit>
        <trans-unit id="c8e2c1746dcaaf891c7f0924e2a7d50565492f1c" translate="yes" xml:space="preserve">
          <source>NonZeroI32::to_string</source>
          <target state="translated">NonZeroI32::to_string</target>
        </trans-unit>
        <trans-unit id="55a921f848a7b22a94032abe096e9e693c57d8c2" translate="yes" xml:space="preserve">
          <source>NonZeroI32::try_from</source>
          <target state="translated">NonZeroI32::try_from</target>
        </trans-unit>
        <trans-unit id="153dc660977b7dbd63100838a1c1f00c97814fda" translate="yes" xml:space="preserve">
          <source>NonZeroI32::try_into</source>
          <target state="translated">NonZeroI32::try_into</target>
        </trans-unit>
        <trans-unit id="d326f8bf5b1e05bd3e854148e764814dfa31fec6" translate="yes" xml:space="preserve">
          <source>NonZeroI32::type_id</source>
          <target state="translated">NonZeroI32::type_id</target>
        </trans-unit>
        <trans-unit id="47326afc55d69221c5bab6f6fc50b489aa6e615c" translate="yes" xml:space="preserve">
          <source>NonZeroI64</source>
          <target state="translated">NonZeroI64</target>
        </trans-unit>
        <trans-unit id="dc475e1ce0d61071c86badb53c4876f712060aa4" translate="yes" xml:space="preserve">
          <source>NonZeroI64::borrow</source>
          <target state="translated">NonZeroI64::borrow</target>
        </trans-unit>
        <trans-unit id="b34344f17d4f0c2fd181fff34ce7e309683eb1f9" translate="yes" xml:space="preserve">
          <source>NonZeroI64::borrow_mut</source>
          <target state="translated">NonZeroI64::borrow_mut</target>
        </trans-unit>
        <trans-unit id="ed2423a4aa70c798c0ab5645f6d832bd412161f6" translate="yes" xml:space="preserve">
          <source>NonZeroI64::clamp</source>
          <target state="translated">NonZeroI64::clamp</target>
        </trans-unit>
        <trans-unit id="f5d711fdbab29c1437fb83b2a0f49dcbcc2c895c" translate="yes" xml:space="preserve">
          <source>NonZeroI64::clone</source>
          <target state="translated">NonZeroI64::clone</target>
        </trans-unit>
        <trans-unit id="267a861768f4cde9358a3ce3dea2c45f82d2d70c" translate="yes" xml:space="preserve">
          <source>NonZeroI64::clone_from</source>
          <target state="translated">NonZeroI64::clone_from</target>
        </trans-unit>
        <trans-unit id="5cb0bd8479d4a4e335894c67e9f47406638b985a" translate="yes" xml:space="preserve">
          <source>NonZeroI64::clone_into</source>
          <target state="translated">NonZeroI64::clone_into</target>
        </trans-unit>
        <trans-unit id="62c821c3e10a9bc5dda6564e62e097e6d1aaded4" translate="yes" xml:space="preserve">
          <source>NonZeroI64::cmp</source>
          <target state="translated">NonZeroI64::cmp</target>
        </trans-unit>
        <trans-unit id="69e086a251f574f1bcd8ddeee49f798091de65ae" translate="yes" xml:space="preserve">
          <source>NonZeroI64::eq</source>
          <target state="translated">NonZeroI64::eq</target>
        </trans-unit>
        <trans-unit id="4628e95346886a1385b96213a08e94cab6a3e3ec" translate="yes" xml:space="preserve">
          <source>NonZeroI64::fmt</source>
          <target state="translated">NonZeroI64::fmt</target>
        </trans-unit>
        <trans-unit id="fa74211c65ed03702df0d7fec92011a00e46da4e" translate="yes" xml:space="preserve">
          <source>NonZeroI64::from</source>
          <target state="translated">NonZeroI64::from</target>
        </trans-unit>
        <trans-unit id="374c31c818806d2d53cf7d6521ef765de951d640" translate="yes" xml:space="preserve">
          <source>NonZeroI64::from_str</source>
          <target state="translated">NonZeroI64::from_str</target>
        </trans-unit>
        <trans-unit id="716f09379283859a96964aa90f9488fffda7f930" translate="yes" xml:space="preserve">
          <source>NonZeroI64::ge</source>
          <target state="translated">NonZeroI64::ge</target>
        </trans-unit>
        <trans-unit id="2826557154d33d398abcd879206752804a2bdf65" translate="yes" xml:space="preserve">
          <source>NonZeroI64::get</source>
          <target state="translated">NonZeroI64::get</target>
        </trans-unit>
        <trans-unit id="c03423dc02e1ef948358b0f5f0ef5c13016b5d96" translate="yes" xml:space="preserve">
          <source>NonZeroI64::gt</source>
          <target state="translated">NonZeroI64::gt</target>
        </trans-unit>
        <trans-unit id="7c084405e2fa1d7847475c21cc64bd06540a721b" translate="yes" xml:space="preserve">
          <source>NonZeroI64::hash</source>
          <target state="translated">NonZeroI64::hash</target>
        </trans-unit>
        <trans-unit id="bb8f897598ee6dc20d33aa36af3c10e2b97e157a" translate="yes" xml:space="preserve">
          <source>NonZeroI64::hash_slice</source>
          <target state="translated">NonZeroI64::hash_slice</target>
        </trans-unit>
        <trans-unit id="ef8da458756764d04abbf9c4bf5a7d43687e9799" translate="yes" xml:space="preserve">
          <source>NonZeroI64::into</source>
          <target state="translated">NonZeroI64::into</target>
        </trans-unit>
        <trans-unit id="361205d1a32febcfc1190394e636de20cf9980ff" translate="yes" xml:space="preserve">
          <source>NonZeroI64::le</source>
          <target state="translated">NonZeroI64::le</target>
        </trans-unit>
        <trans-unit id="bfa76864905ebec51d3cd7370cb21f3b8325bc2a" translate="yes" xml:space="preserve">
          <source>NonZeroI64::lt</source>
          <target state="translated">NonZeroI64::lt</target>
        </trans-unit>
        <trans-unit id="d05fd485f6f48cbcf9797f21c7f72b7da774ef73" translate="yes" xml:space="preserve">
          <source>NonZeroI64::max</source>
          <target state="translated">NonZeroI64::max</target>
        </trans-unit>
        <trans-unit id="4445fa7cd5899e3dddfe813b834bacaadd0b1f16" translate="yes" xml:space="preserve">
          <source>NonZeroI64::min</source>
          <target state="translated">NonZeroI64::min</target>
        </trans-unit>
        <trans-unit id="0e8b97484e878d06b6ee68465379752feed3cd3d" translate="yes" xml:space="preserve">
          <source>NonZeroI64::ne</source>
          <target state="translated">NonZeroI64::ne</target>
        </trans-unit>
        <trans-unit id="bde2e9f1fb06520bab485b2e3afb4e80b33dba82" translate="yes" xml:space="preserve">
          <source>NonZeroI64::new</source>
          <target state="translated">NonZeroI64::new</target>
        </trans-unit>
        <trans-unit id="f82a0245493af04b7985ed399fa466dc4edc8ced" translate="yes" xml:space="preserve">
          <source>NonZeroI64::new_unchecked</source>
          <target state="translated">NonZeroI64::new_unchecked</target>
        </trans-unit>
        <trans-unit id="ff0c4a829e7306aac0aa333126abf09bbe21f706" translate="yes" xml:space="preserve">
          <source>NonZeroI64::partial_cmp</source>
          <target state="translated">NonZeroI64::partial_cmp</target>
        </trans-unit>
        <trans-unit id="12b3dd3db76faeb57eec7254b2c1977c25f88349" translate="yes" xml:space="preserve">
          <source>NonZeroI64::to_owned</source>
          <target state="translated">NonZeroI64::to_owned</target>
        </trans-unit>
        <trans-unit id="898927cce217ffb93b1463253607e0954996b3fd" translate="yes" xml:space="preserve">
          <source>NonZeroI64::to_string</source>
          <target state="translated">NonZeroI64::to_string</target>
        </trans-unit>
        <trans-unit id="2d19979b95b66165d9cce2a874b5b50774c07fee" translate="yes" xml:space="preserve">
          <source>NonZeroI64::try_from</source>
          <target state="translated">NonZeroI64::try_from</target>
        </trans-unit>
        <trans-unit id="a50be005ecf5a07bc843f676f748462b8adca096" translate="yes" xml:space="preserve">
          <source>NonZeroI64::try_into</source>
          <target state="translated">NonZeroI64::try_into</target>
        </trans-unit>
        <trans-unit id="0134deb92dae159c2082bceaef595cfc9df55dce" translate="yes" xml:space="preserve">
          <source>NonZeroI64::type_id</source>
          <target state="translated">NonZeroI64::type_id</target>
        </trans-unit>
        <trans-unit id="de2b631972cf994d47d76eac38bd59ef1aa6e707" translate="yes" xml:space="preserve">
          <source>NonZeroI8</source>
          <target state="translated">NonZeroI8</target>
        </trans-unit>
        <trans-unit id="02a97b1be1b57111983e0f301eaade35ec979636" translate="yes" xml:space="preserve">
          <source>NonZeroI8::borrow</source>
          <target state="translated">NonZeroI8::borrow</target>
        </trans-unit>
        <trans-unit id="585184585d76b6d884767a1ba1173bf3fdcf9087" translate="yes" xml:space="preserve">
          <source>NonZeroI8::borrow_mut</source>
          <target state="translated">NonZeroI8::borrow_mut</target>
        </trans-unit>
        <trans-unit id="61d82766a6745e76c9a921124d58b68ee8622344" translate="yes" xml:space="preserve">
          <source>NonZeroI8::clamp</source>
          <target state="translated">NonZeroI8::clamp</target>
        </trans-unit>
        <trans-unit id="9639aa6f98547170260a0dbed71fe42368a45037" translate="yes" xml:space="preserve">
          <source>NonZeroI8::clone</source>
          <target state="translated">NonZeroI8::clone</target>
        </trans-unit>
        <trans-unit id="69bea805436f5d9faeecb421d3ad1efbed040ab0" translate="yes" xml:space="preserve">
          <source>NonZeroI8::clone_from</source>
          <target state="translated">NonZeroI8::clone_from</target>
        </trans-unit>
        <trans-unit id="f79563630b90126fa16369923d147a8e6ffaf90f" translate="yes" xml:space="preserve">
          <source>NonZeroI8::clone_into</source>
          <target state="translated">NonZeroI8::clone_into</target>
        </trans-unit>
        <trans-unit id="2e5b078a7705aaa646d49606a0e296d4af0f1acd" translate="yes" xml:space="preserve">
          <source>NonZeroI8::cmp</source>
          <target state="translated">NonZeroI8::cmp</target>
        </trans-unit>
        <trans-unit id="cdfffa6f6db5c090ca460987b1da2d174ad3dd70" translate="yes" xml:space="preserve">
          <source>NonZeroI8::eq</source>
          <target state="translated">NonZeroI8::eq</target>
        </trans-unit>
        <trans-unit id="303fe1ff3066af96ac1869cf4c4fcfeeee433dc7" translate="yes" xml:space="preserve">
          <source>NonZeroI8::fmt</source>
          <target state="translated">NonZeroI8::fmt</target>
        </trans-unit>
        <trans-unit id="77bf7d94ae999f9b201e336425c9ca11763912ae" translate="yes" xml:space="preserve">
          <source>NonZeroI8::from</source>
          <target state="translated">NonZeroI8::from</target>
        </trans-unit>
        <trans-unit id="058ab838a9faa626f87b01a68a1ab8af9ceffa5e" translate="yes" xml:space="preserve">
          <source>NonZeroI8::from_str</source>
          <target state="translated">NonZeroI8::from_str</target>
        </trans-unit>
        <trans-unit id="5ffec8af45e4b9e098c857beafee4bb4710502df" translate="yes" xml:space="preserve">
          <source>NonZeroI8::ge</source>
          <target state="translated">NonZeroI8::ge</target>
        </trans-unit>
        <trans-unit id="39931bb71d49054bdf1fb8e4a5d156766e03a349" translate="yes" xml:space="preserve">
          <source>NonZeroI8::get</source>
          <target state="translated">NonZeroI8::get</target>
        </trans-unit>
        <trans-unit id="47babee6888e0103956b5d6fb324645bab23db7a" translate="yes" xml:space="preserve">
          <source>NonZeroI8::gt</source>
          <target state="translated">NonZeroI8::gt</target>
        </trans-unit>
        <trans-unit id="93874d53399c77a41bf9531800d5f0fa474a4cda" translate="yes" xml:space="preserve">
          <source>NonZeroI8::hash</source>
          <target state="translated">NonZeroI8::hash</target>
        </trans-unit>
        <trans-unit id="29013108ddf40e18600983e97e9034bd5257369c" translate="yes" xml:space="preserve">
          <source>NonZeroI8::hash_slice</source>
          <target state="translated">NonZeroI8::hash_slice</target>
        </trans-unit>
        <trans-unit id="037dc348d54512f4eac4bc525c27d1f766b25a1a" translate="yes" xml:space="preserve">
          <source>NonZeroI8::into</source>
          <target state="translated">NonZeroI8::into</target>
        </trans-unit>
        <trans-unit id="0515501fa1d050e6a321477214d1c4d9c56b0a91" translate="yes" xml:space="preserve">
          <source>NonZeroI8::le</source>
          <target state="translated">NonZeroI8::le</target>
        </trans-unit>
        <trans-unit id="7cad17cf5fce8924f80e26fc0cc84eaa9e833005" translate="yes" xml:space="preserve">
          <source>NonZeroI8::lt</source>
          <target state="translated">NonZeroI8::lt</target>
        </trans-unit>
        <trans-unit id="90330e65e0da907071c3c4c3d6a116bb84c932c4" translate="yes" xml:space="preserve">
          <source>NonZeroI8::max</source>
          <target state="translated">NonZeroI8::max</target>
        </trans-unit>
        <trans-unit id="e20ad8db00b5d962f11dd424a9bc3a6c8e774305" translate="yes" xml:space="preserve">
          <source>NonZeroI8::min</source>
          <target state="translated">NonZeroI8::min</target>
        </trans-unit>
        <trans-unit id="73e8e9fd3f901d81ee2336d6e8ea9cf220fba88b" translate="yes" xml:space="preserve">
          <source>NonZeroI8::ne</source>
          <target state="translated">NonZeroI8::ne</target>
        </trans-unit>
        <trans-unit id="af45d6c29f79e266eb5d7ab85309f358f8208a69" translate="yes" xml:space="preserve">
          <source>NonZeroI8::new</source>
          <target state="translated">NonZeroI8::new</target>
        </trans-unit>
        <trans-unit id="81a02f698c1e4f2332bb4e3e7c3edf4ff27a1c50" translate="yes" xml:space="preserve">
          <source>NonZeroI8::new_unchecked</source>
          <target state="translated">NonZeroI8::new_unchecked</target>
        </trans-unit>
        <trans-unit id="2686fbb343af79a855c02e59fa60522e101b42ae" translate="yes" xml:space="preserve">
          <source>NonZeroI8::partial_cmp</source>
          <target state="translated">NonZeroI8::partial_cmp</target>
        </trans-unit>
        <trans-unit id="cd75ff5beac899fb4e419778f9513cbe1ad0b2a5" translate="yes" xml:space="preserve">
          <source>NonZeroI8::to_owned</source>
          <target state="translated">NonZeroI8::to_owned</target>
        </trans-unit>
        <trans-unit id="2b4fc6493819df1f404760f50612536b8bbfc7bd" translate="yes" xml:space="preserve">
          <source>NonZeroI8::to_string</source>
          <target state="translated">NonZeroI8::to_string</target>
        </trans-unit>
        <trans-unit id="44995331a911be947ba3e877e13ce380ef4d9378" translate="yes" xml:space="preserve">
          <source>NonZeroI8::try_from</source>
          <target state="translated">NonZeroI8::try_from</target>
        </trans-unit>
        <trans-unit id="c6edd8a860f42d4c84935088ebf51ade98d95115" translate="yes" xml:space="preserve">
          <source>NonZeroI8::try_into</source>
          <target state="translated">NonZeroI8::try_into</target>
        </trans-unit>
        <trans-unit id="694926ab4cd6b261f66a7c4ea43bd5a538ca07a5" translate="yes" xml:space="preserve">
          <source>NonZeroI8::type_id</source>
          <target state="translated">NonZeroI8::type_id</target>
        </trans-unit>
        <trans-unit id="39eb2a5ae94e10b055d94f86300fae4bd3a2c861" translate="yes" xml:space="preserve">
          <source>NonZeroIsize</source>
          <target state="translated">NonZeroIsize</target>
        </trans-unit>
        <trans-unit id="4075b4a43affee6576128660a15087ef7d46f01c" translate="yes" xml:space="preserve">
          <source>NonZeroIsize::borrow</source>
          <target state="translated">NonZeroIsize::borrow</target>
        </trans-unit>
        <trans-unit id="ec545959e67fee5329d2293a10abf7982b0e5d27" translate="yes" xml:space="preserve">
          <source>NonZeroIsize::borrow_mut</source>
          <target state="translated">NonZeroIsize::borrow_mut</target>
        </trans-unit>
        <trans-unit id="a61bacb1affb3b3a864b9054448b3c878abd8923" translate="yes" xml:space="preserve">
          <source>NonZeroIsize::clamp</source>
          <target state="translated">NonZeroIsize::clamp</target>
        </trans-unit>
        <trans-unit id="191e1ee11e03e2904eddf99c3224190191357bac" translate="yes" xml:space="preserve">
          <source>NonZeroIsize::clone</source>
          <target state="translated">NonZeroIsize::clone</target>
        </trans-unit>
        <trans-unit id="5dc48b7609417f7ce614e10e63d58e556492bcf9" translate="yes" xml:space="preserve">
          <source>NonZeroIsize::clone_from</source>
          <target state="translated">NonZeroIsize::clone_from</target>
        </trans-unit>
        <trans-unit id="d38a3dead1294ded03ccb72c57ad049cf009cb60" translate="yes" xml:space="preserve">
          <source>NonZeroIsize::clone_into</source>
          <target state="translated">NonZeroIsize::clone_into</target>
        </trans-unit>
        <trans-unit id="ca7ed6d7cb5393e8a7ba6e95fd43e5b4d5bb7809" translate="yes" xml:space="preserve">
          <source>NonZeroIsize::cmp</source>
          <target state="translated">NonZeroIsize::cmp</target>
        </trans-unit>
        <trans-unit id="2fe615f032ce982861bba71b45a232958641a0cd" translate="yes" xml:space="preserve">
          <source>NonZeroIsize::eq</source>
          <target state="translated">NonZeroIsize::eq</target>
        </trans-unit>
        <trans-unit id="d9ec29b8a341c99081d89a3bd91dc15ff5f6812f" translate="yes" xml:space="preserve">
          <source>NonZeroIsize::fmt</source>
          <target state="translated">NonZeroIsize::fmt</target>
        </trans-unit>
        <trans-unit id="817a465d80d81fe1b61c88aca0859799182b0ced" translate="yes" xml:space="preserve">
          <source>NonZeroIsize::from</source>
          <target state="translated">NonZeroIsize::from</target>
        </trans-unit>
        <trans-unit id="d2cfcb21d317b6fab455622f5d899c19b4caab20" translate="yes" xml:space="preserve">
          <source>NonZeroIsize::from_str</source>
          <target state="translated">NonZeroIsize::from_str</target>
        </trans-unit>
        <trans-unit id="955b4cb4cf6dd3e94857ccb753d3fe4d1fb111bb" translate="yes" xml:space="preserve">
          <source>NonZeroIsize::ge</source>
          <target state="translated">NonZeroIsize::ge</target>
        </trans-unit>
        <trans-unit id="94dfb4eb2acf5d4199e2494aa3141f234b7ec552" translate="yes" xml:space="preserve">
          <source>NonZeroIsize::get</source>
          <target state="translated">NonZeroIsize::get</target>
        </trans-unit>
        <trans-unit id="ee800c8db94226df90984d0310a1c3b583e90f13" translate="yes" xml:space="preserve">
          <source>NonZeroIsize::gt</source>
          <target state="translated">NonZeroIsize::gt</target>
        </trans-unit>
        <trans-unit id="36fffe56efef4816a331398e4562a265e92bfb10" translate="yes" xml:space="preserve">
          <source>NonZeroIsize::hash</source>
          <target state="translated">NonZeroIsize::hash</target>
        </trans-unit>
        <trans-unit id="cf00fd8ca399a52d34e9a8feac17a1b26fe0bcee" translate="yes" xml:space="preserve">
          <source>NonZeroIsize::hash_slice</source>
          <target state="translated">NonZeroIsize::hash_slice</target>
        </trans-unit>
        <trans-unit id="882f34faf603e4c98fc372332977f902076ab5a0" translate="yes" xml:space="preserve">
          <source>NonZeroIsize::into</source>
          <target state="translated">NonZeroIsize::into</target>
        </trans-unit>
        <trans-unit id="0d24785358cfb27caebb3a32bf5c7678cb2e30ee" translate="yes" xml:space="preserve">
          <source>NonZeroIsize::le</source>
          <target state="translated">NonZeroIsize::le</target>
        </trans-unit>
        <trans-unit id="f8f7c7c85f4aab3786722bfd2d7aefb8b686bd6e" translate="yes" xml:space="preserve">
          <source>NonZeroIsize::lt</source>
          <target state="translated">NonZeroIsize::lt</target>
        </trans-unit>
        <trans-unit id="19c94dc6fa11f95d35e7c7c4f115e86acb80fc00" translate="yes" xml:space="preserve">
          <source>NonZeroIsize::max</source>
          <target state="translated">NonZeroIsize::max</target>
        </trans-unit>
        <trans-unit id="9bf079159116a040501bb2bee238b98de390d6b7" translate="yes" xml:space="preserve">
          <source>NonZeroIsize::min</source>
          <target state="translated">NonZeroIsize::min</target>
        </trans-unit>
        <trans-unit id="78420580500ef47e7d9c63e510686240542d08c3" translate="yes" xml:space="preserve">
          <source>NonZeroIsize::ne</source>
          <target state="translated">NonZeroIsize::ne</target>
        </trans-unit>
        <trans-unit id="9b5caea647537e28a582a1b68216f403a92bdea7" translate="yes" xml:space="preserve">
          <source>NonZeroIsize::new</source>
          <target state="translated">NonZeroIsize::new</target>
        </trans-unit>
        <trans-unit id="f92bdba42fa66b6909fc4ad5b38b7d0a8808cced" translate="yes" xml:space="preserve">
          <source>NonZeroIsize::new_unchecked</source>
          <target state="translated">NonZeroIsize::new_unchecked</target>
        </trans-unit>
        <trans-unit id="2b55347d5d71b451caf945bb5b1b4cacc28afc98" translate="yes" xml:space="preserve">
          <source>NonZeroIsize::partial_cmp</source>
          <target state="translated">NonZeroIsize::partial_cmp</target>
        </trans-unit>
        <trans-unit id="717d7fcf3dd2db66a5b657bdcd5df3b72e3ca14d" translate="yes" xml:space="preserve">
          <source>NonZeroIsize::to_owned</source>
          <target state="translated">NonZeroIsize::to_owned</target>
        </trans-unit>
        <trans-unit id="1a88ee49d5b8865561ef951ccbe17add31975cf3" translate="yes" xml:space="preserve">
          <source>NonZeroIsize::to_string</source>
          <target state="translated">NonZeroIsize::to_string</target>
        </trans-unit>
        <trans-unit id="aeed335ba630cd0f02972d3792f625986e0da579" translate="yes" xml:space="preserve">
          <source>NonZeroIsize::try_from</source>
          <target state="translated">NonZeroIsize::try_from</target>
        </trans-unit>
        <trans-unit id="3b703381eaac2b4d7c2b865c4b56d5e07385cb0d" translate="yes" xml:space="preserve">
          <source>NonZeroIsize::try_into</source>
          <target state="translated">NonZeroIsize::try_into</target>
        </trans-unit>
        <trans-unit id="cfd236d892fc65a9056aca980b3c2a0c1b08fc90" translate="yes" xml:space="preserve">
          <source>NonZeroIsize::type_id</source>
          <target state="translated">NonZeroIsize::type_id</target>
        </trans-unit>
        <trans-unit id="0044d6a252510995bf93ecb1dd199ad6280b0298" translate="yes" xml:space="preserve">
          <source>NonZeroU128</source>
          <target state="translated">NonZeroU128</target>
        </trans-unit>
        <trans-unit id="d33cdcef0f6bce3ae4d1c100820f29fb8e8de6be" translate="yes" xml:space="preserve">
          <source>NonZeroU128::borrow</source>
          <target state="translated">NonZeroU128::borrow</target>
        </trans-unit>
        <trans-unit id="3f647fdd084e34cb19c62fa95a5df0d0b02f7830" translate="yes" xml:space="preserve">
          <source>NonZeroU128::borrow_mut</source>
          <target state="translated">NonZeroU128::borrow_mut</target>
        </trans-unit>
        <trans-unit id="6dd84c262632c4ce99cd20fd6d4cce46ad766f6c" translate="yes" xml:space="preserve">
          <source>NonZeroU128::clamp</source>
          <target state="translated">NonZeroU128::clamp</target>
        </trans-unit>
        <trans-unit id="54a6620faedc0c0d7296506b17b24167c833f343" translate="yes" xml:space="preserve">
          <source>NonZeroU128::clone</source>
          <target state="translated">NonZeroU128::clone</target>
        </trans-unit>
        <trans-unit id="361f908936891415e62dbb126d73b91cdd535809" translate="yes" xml:space="preserve">
          <source>NonZeroU128::clone_from</source>
          <target state="translated">NonZeroU128::clone_from</target>
        </trans-unit>
        <trans-unit id="95b289a7b3408284866f730f49c7cefc4940ea32" translate="yes" xml:space="preserve">
          <source>NonZeroU128::clone_into</source>
          <target state="translated">NonZeroU128::clone_into</target>
        </trans-unit>
        <trans-unit id="939d6fc64a58c3aad5a29fd29b5cb1ddf18ffa03" translate="yes" xml:space="preserve">
          <source>NonZeroU128::cmp</source>
          <target state="translated">NonZeroU128::cmp</target>
        </trans-unit>
        <trans-unit id="e3d76ecf73e9d2bddfdc690dd3583c65cb4e8c6b" translate="yes" xml:space="preserve">
          <source>NonZeroU128::eq</source>
          <target state="translated">NonZeroU128::eq</target>
        </trans-unit>
        <trans-unit id="cf1f402d3b803071978d5c02ef20145ad5e75f93" translate="yes" xml:space="preserve">
          <source>NonZeroU128::fmt</source>
          <target state="translated">NonZeroU128::fmt</target>
        </trans-unit>
        <trans-unit id="1cb47e3de5cf28c31000e229db50c161ce7a7c28" translate="yes" xml:space="preserve">
          <source>NonZeroU128::from</source>
          <target state="translated">NonZeroU128::from</target>
        </trans-unit>
        <trans-unit id="04a3a610d61c54fe04e5c4fb7dc3736c9608563d" translate="yes" xml:space="preserve">
          <source>NonZeroU128::from_str</source>
          <target state="translated">NonZeroU128::from_str</target>
        </trans-unit>
        <trans-unit id="b8dacf31071a7dcf6913c1d5f60e1467a0c7b52c" translate="yes" xml:space="preserve">
          <source>NonZeroU128::ge</source>
          <target state="translated">NonZeroU128::ge</target>
        </trans-unit>
        <trans-unit id="bc070e9b4c11812f956c2c3942dbeeb60e1907d7" translate="yes" xml:space="preserve">
          <source>NonZeroU128::get</source>
          <target state="translated">NonZeroU128::get</target>
        </trans-unit>
        <trans-unit id="bf61b92a5979f684a74d24d35e7223a980f74915" translate="yes" xml:space="preserve">
          <source>NonZeroU128::gt</source>
          <target state="translated">NonZeroU128::gt</target>
        </trans-unit>
        <trans-unit id="66888226d70c2e49258374545510affc0bdd95ec" translate="yes" xml:space="preserve">
          <source>NonZeroU128::hash</source>
          <target state="translated">NonZeroU128::hash</target>
        </trans-unit>
        <trans-unit id="11f423a193c168fdc5ff7611f300ac57dfd70171" translate="yes" xml:space="preserve">
          <source>NonZeroU128::hash_slice</source>
          <target state="translated">NonZeroU128::hash_slice</target>
        </trans-unit>
        <trans-unit id="b29bc2e8eba682c97ef473e0bd889b9b87439b43" translate="yes" xml:space="preserve">
          <source>NonZeroU128::into</source>
          <target state="translated">NonZeroU128::into</target>
        </trans-unit>
        <trans-unit id="dd97daae9ce7a0b9ab85c6cf73bd03826d2dacad" translate="yes" xml:space="preserve">
          <source>NonZeroU128::le</source>
          <target state="translated">NonZeroU128::le</target>
        </trans-unit>
        <trans-unit id="4c5ffedb155e243e75eb535bd12d40831e3c5755" translate="yes" xml:space="preserve">
          <source>NonZeroU128::lt</source>
          <target state="translated">NonZeroU128::lt</target>
        </trans-unit>
        <trans-unit id="cefe09ff65521779b9f59c83b8f0425d577bc41f" translate="yes" xml:space="preserve">
          <source>NonZeroU128::max</source>
          <target state="translated">NonZeroU128::max</target>
        </trans-unit>
        <trans-unit id="66bc9dddfd54e67077a2f3098f5b87831d049d31" translate="yes" xml:space="preserve">
          <source>NonZeroU128::min</source>
          <target state="translated">NonZeroU128::min</target>
        </trans-unit>
        <trans-unit id="1af4ac1a95b7f36c718aa21d748fb13ce2e824ee" translate="yes" xml:space="preserve">
          <source>NonZeroU128::ne</source>
          <target state="translated">NonZeroU128::ne</target>
        </trans-unit>
        <trans-unit id="774e6ffc8823e6223f1ffa87fab102416ea1637d" translate="yes" xml:space="preserve">
          <source>NonZeroU128::new</source>
          <target state="translated">NonZeroU128::new</target>
        </trans-unit>
        <trans-unit id="80588590ec2ef5a265edf292dba20ca05ed9ff1d" translate="yes" xml:space="preserve">
          <source>NonZeroU128::new_unchecked</source>
          <target state="translated">NonZeroU128::new_unchecked</target>
        </trans-unit>
        <trans-unit id="4f33be7cbf8c678c8187f371f4f5d027a69d0647" translate="yes" xml:space="preserve">
          <source>NonZeroU128::partial_cmp</source>
          <target state="translated">NonZeroU128::partial_cmp</target>
        </trans-unit>
        <trans-unit id="3dea4243dcea470ba4d4f180f81f6eecca14e04e" translate="yes" xml:space="preserve">
          <source>NonZeroU128::to_owned</source>
          <target state="translated">NonZeroU128::to_owned</target>
        </trans-unit>
        <trans-unit id="24acde94eff6342ff2fba2e9d267a2fdb25acd94" translate="yes" xml:space="preserve">
          <source>NonZeroU128::to_string</source>
          <target state="translated">NonZeroU128::to_string</target>
        </trans-unit>
        <trans-unit id="b21ef37ea8ca3269318a2c852c86163df43432be" translate="yes" xml:space="preserve">
          <source>NonZeroU128::try_from</source>
          <target state="translated">NonZeroU128::try_from</target>
        </trans-unit>
        <trans-unit id="6c546400526ea1ed6ea89201862535a6549699f1" translate="yes" xml:space="preserve">
          <source>NonZeroU128::try_into</source>
          <target state="translated">NonZeroU128::try_into</target>
        </trans-unit>
        <trans-unit id="5b4b31430f7adfc4f26872a558ae35d43d7da9ff" translate="yes" xml:space="preserve">
          <source>NonZeroU128::type_id</source>
          <target state="translated">NonZeroU128::type_id</target>
        </trans-unit>
        <trans-unit id="70d9b595abe5e850f484266bc477e3d70b58c790" translate="yes" xml:space="preserve">
          <source>NonZeroU16</source>
          <target state="translated">NonZeroU16</target>
        </trans-unit>
        <trans-unit id="a2e830bdc612e459ecbf94a5d900db9adf22d552" translate="yes" xml:space="preserve">
          <source>NonZeroU16::borrow</source>
          <target state="translated">NonZeroU16::borrow</target>
        </trans-unit>
        <trans-unit id="84a81450427618c9efd99c6046bdcfcb15a8f7bb" translate="yes" xml:space="preserve">
          <source>NonZeroU16::borrow_mut</source>
          <target state="translated">NonZeroU16::borrow_mut</target>
        </trans-unit>
        <trans-unit id="4eb94e8343ecdde314f21ae1472878c2e5be4f43" translate="yes" xml:space="preserve">
          <source>NonZeroU16::clamp</source>
          <target state="translated">NonZeroU16::clamp</target>
        </trans-unit>
        <trans-unit id="4f9cad5198a59312536b10433f5195716121d4f5" translate="yes" xml:space="preserve">
          <source>NonZeroU16::clone</source>
          <target state="translated">NonZeroU16::clone</target>
        </trans-unit>
        <trans-unit id="d8ef4ec4d957a02aaa882335c6f3d0a67035a3c7" translate="yes" xml:space="preserve">
          <source>NonZeroU16::clone_from</source>
          <target state="translated">NonZeroU16::clone_from</target>
        </trans-unit>
        <trans-unit id="3808aec2130dc48a153e5a520294b26744b3e702" translate="yes" xml:space="preserve">
          <source>NonZeroU16::clone_into</source>
          <target state="translated">NonZeroU16::clone_into</target>
        </trans-unit>
        <trans-unit id="9d0062487248621e89b96fe5bf643abe821bb17a" translate="yes" xml:space="preserve">
          <source>NonZeroU16::cmp</source>
          <target state="translated">NonZeroU16::cmp</target>
        </trans-unit>
        <trans-unit id="41a2d5bd4797b2d1eb6b20161786347a9f0dd370" translate="yes" xml:space="preserve">
          <source>NonZeroU16::eq</source>
          <target state="translated">NonZeroU16::eq</target>
        </trans-unit>
        <trans-unit id="4e58083d69fb5df5404d73e024559cb858948a6f" translate="yes" xml:space="preserve">
          <source>NonZeroU16::fmt</source>
          <target state="translated">NonZeroU16::fmt</target>
        </trans-unit>
        <trans-unit id="f40fdab8202fbcb58f6fbdbc2b16303b0de2f1ee" translate="yes" xml:space="preserve">
          <source>NonZeroU16::from</source>
          <target state="translated">NonZeroU16::from</target>
        </trans-unit>
        <trans-unit id="97bb49319fe5098129502422bda785cd16c5234a" translate="yes" xml:space="preserve">
          <source>NonZeroU16::from_str</source>
          <target state="translated">NonZeroU16::from_str</target>
        </trans-unit>
        <trans-unit id="12e676e778fbbdbfffb5d2b98fabd5a4306c10e5" translate="yes" xml:space="preserve">
          <source>NonZeroU16::ge</source>
          <target state="translated">NonZeroU16::ge</target>
        </trans-unit>
        <trans-unit id="1313691aadbfef04a5d2c70132da7c9072b9834a" translate="yes" xml:space="preserve">
          <source>NonZeroU16::get</source>
          <target state="translated">NonZeroU16::get</target>
        </trans-unit>
        <trans-unit id="e4a7103dfe5dfdaccf5405172a6bfb6564cbb39e" translate="yes" xml:space="preserve">
          <source>NonZeroU16::gt</source>
          <target state="translated">NonZeroU16::gt</target>
        </trans-unit>
        <trans-unit id="4843257888dce95e20cf1eaff515263fe997bf35" translate="yes" xml:space="preserve">
          <source>NonZeroU16::hash</source>
          <target state="translated">NonZeroU16::hash</target>
        </trans-unit>
        <trans-unit id="b9c900dd5aa52134650740a33c407b05339dc782" translate="yes" xml:space="preserve">
          <source>NonZeroU16::hash_slice</source>
          <target state="translated">NonZeroU16::hash_slice</target>
        </trans-unit>
        <trans-unit id="83aabdee7d487ec9cb728178e573f802394226b4" translate="yes" xml:space="preserve">
          <source>NonZeroU16::into</source>
          <target state="translated">NonZeroU16::into</target>
        </trans-unit>
        <trans-unit id="7970d0eb118d83ab0b72df82542034727ba2a453" translate="yes" xml:space="preserve">
          <source>NonZeroU16::le</source>
          <target state="translated">NonZeroU16::le</target>
        </trans-unit>
        <trans-unit id="2e5e858925d50659f9b1b6d9aae3740085d6d25b" translate="yes" xml:space="preserve">
          <source>NonZeroU16::lt</source>
          <target state="translated">NonZeroU16::lt</target>
        </trans-unit>
        <trans-unit id="5d3b1652b96c8f150360a583d2605f47b1963560" translate="yes" xml:space="preserve">
          <source>NonZeroU16::max</source>
          <target state="translated">NonZeroU16::max</target>
        </trans-unit>
        <trans-unit id="1e4034b09df30190832a52072bcf8af6041bbf4d" translate="yes" xml:space="preserve">
          <source>NonZeroU16::min</source>
          <target state="translated">NonZeroU16::min</target>
        </trans-unit>
        <trans-unit id="815e8d53bff937d8e0463d3319f42f6179bc0760" translate="yes" xml:space="preserve">
          <source>NonZeroU16::ne</source>
          <target state="translated">NonZeroU16::ne</target>
        </trans-unit>
        <trans-unit id="23ac83515dc8fab41df4280bc33fe4bc456b4ff2" translate="yes" xml:space="preserve">
          <source>NonZeroU16::new</source>
          <target state="translated">NonZeroU16::new</target>
        </trans-unit>
        <trans-unit id="bb140336d169ad21d933a68a3d8746b26d1b8b72" translate="yes" xml:space="preserve">
          <source>NonZeroU16::new_unchecked</source>
          <target state="translated">NonZeroU16::new_unchecked</target>
        </trans-unit>
        <trans-unit id="d8dd3cac934926e6de446e12a7408c3a4890b68e" translate="yes" xml:space="preserve">
          <source>NonZeroU16::partial_cmp</source>
          <target state="translated">NonZeroU16::partial_cmp</target>
        </trans-unit>
        <trans-unit id="93b1877253643b0a75cda9a47fc455fc67b284f7" translate="yes" xml:space="preserve">
          <source>NonZeroU16::to_owned</source>
          <target state="translated">NonZeroU16::to_owned</target>
        </trans-unit>
        <trans-unit id="450d0b2017abf1787e4b40c9180053f5f1c5d6b5" translate="yes" xml:space="preserve">
          <source>NonZeroU16::to_string</source>
          <target state="translated">NonZeroU16::to_string</target>
        </trans-unit>
        <trans-unit id="565d7bfa4f368119e8eb8c597666eee168d3ec36" translate="yes" xml:space="preserve">
          <source>NonZeroU16::try_from</source>
          <target state="translated">NonZeroU16::try_from</target>
        </trans-unit>
        <trans-unit id="c9ffda0c65ec9d2c6dac8e1259fd7cb09818b7a4" translate="yes" xml:space="preserve">
          <source>NonZeroU16::try_into</source>
          <target state="translated">NonZeroU16::try_into</target>
        </trans-unit>
        <trans-unit id="35a3919e55cf0455983744e7e8ab659cda957d3b" translate="yes" xml:space="preserve">
          <source>NonZeroU16::type_id</source>
          <target state="translated">NonZeroU16::type_id</target>
        </trans-unit>
        <trans-unit id="027b94edf209f9b339fcc3f9fcbe95bea73b0fff" translate="yes" xml:space="preserve">
          <source>NonZeroU32</source>
          <target state="translated">NonZeroU32</target>
        </trans-unit>
        <trans-unit id="19103157b2dd994e271093d37a26558f253c1df5" translate="yes" xml:space="preserve">
          <source>NonZeroU32::borrow</source>
          <target state="translated">NonZeroU32::borrow</target>
        </trans-unit>
        <trans-unit id="d5900a35010072cf8f8a0e31e3295500e147138f" translate="yes" xml:space="preserve">
          <source>NonZeroU32::borrow_mut</source>
          <target state="translated">NonZeroU32::borrow_mut</target>
        </trans-unit>
        <trans-unit id="a3d0eea5bcf469a951789307713538f7dd48cc64" translate="yes" xml:space="preserve">
          <source>NonZeroU32::clamp</source>
          <target state="translated">NonZeroU32::clamp</target>
        </trans-unit>
        <trans-unit id="ca9c328d071b73e6fec77d280d2dec16c6afe8be" translate="yes" xml:space="preserve">
          <source>NonZeroU32::clone</source>
          <target state="translated">NonZeroU32::clone</target>
        </trans-unit>
        <trans-unit id="4d0cce4f0af9fe9b58667070ea3aae8608af18fc" translate="yes" xml:space="preserve">
          <source>NonZeroU32::clone_from</source>
          <target state="translated">NonZeroU32::clone_from</target>
        </trans-unit>
        <trans-unit id="beeb1f8a7db4e17dce219e3b75ed85a27a214ce6" translate="yes" xml:space="preserve">
          <source>NonZeroU32::clone_into</source>
          <target state="translated">NonZeroU32::clone_into</target>
        </trans-unit>
        <trans-unit id="66de3d60d49a5fd2460c7fce4fc4af569dea2ea8" translate="yes" xml:space="preserve">
          <source>NonZeroU32::cmp</source>
          <target state="translated">NonZeroU32::cmp</target>
        </trans-unit>
        <trans-unit id="b9a64d225fbd880a1d363e7928600204954c435d" translate="yes" xml:space="preserve">
          <source>NonZeroU32::eq</source>
          <target state="translated">NonZeroU32::eq</target>
        </trans-unit>
        <trans-unit id="d198043d6e6b2dcbdbd140d6e9a9832d41ef00b0" translate="yes" xml:space="preserve">
          <source>NonZeroU32::fmt</source>
          <target state="translated">NonZeroU32::fmt</target>
        </trans-unit>
        <trans-unit id="f99dcfdc314e32f70a453660a94f7ab9fd67185e" translate="yes" xml:space="preserve">
          <source>NonZeroU32::from</source>
          <target state="translated">NonZeroU32::from</target>
        </trans-unit>
        <trans-unit id="298799838c58c16143fcd9e2418534b329517ba2" translate="yes" xml:space="preserve">
          <source>NonZeroU32::from_str</source>
          <target state="translated">NonZeroU32::from_str</target>
        </trans-unit>
        <trans-unit id="6cd1cc0b365f1d3d480575dcbc2de54dae6a1d17" translate="yes" xml:space="preserve">
          <source>NonZeroU32::ge</source>
          <target state="translated">NonZeroU32::ge</target>
        </trans-unit>
        <trans-unit id="1dbe40ea77f784440de6e51cfcfb8778482bc067" translate="yes" xml:space="preserve">
          <source>NonZeroU32::get</source>
          <target state="translated">NonZeroU32::get</target>
        </trans-unit>
        <trans-unit id="e88628f83bc918c532752959c92d4ac82adbf0fd" translate="yes" xml:space="preserve">
          <source>NonZeroU32::gt</source>
          <target state="translated">NonZeroU32::gt</target>
        </trans-unit>
        <trans-unit id="7104f6c9a14d29e93513632fa9934f8edd1d6e95" translate="yes" xml:space="preserve">
          <source>NonZeroU32::hash</source>
          <target state="translated">NonZeroU32::hash</target>
        </trans-unit>
        <trans-unit id="ed57c71253659bc0210251e89d76fbd4f29b25de" translate="yes" xml:space="preserve">
          <source>NonZeroU32::hash_slice</source>
          <target state="translated">NonZeroU32::hash_slice</target>
        </trans-unit>
        <trans-unit id="708299fe453aae6d855b8d5980451e3d6fa01e3f" translate="yes" xml:space="preserve">
          <source>NonZeroU32::into</source>
          <target state="translated">NonZeroU32::into</target>
        </trans-unit>
        <trans-unit id="18cade9c6a5784c63e5e9e3cd947c01187616ffa" translate="yes" xml:space="preserve">
          <source>NonZeroU32::le</source>
          <target state="translated">NonZeroU32::le</target>
        </trans-unit>
        <trans-unit id="258acfab28050bc7bb168cbfd4ef30a6d48665c5" translate="yes" xml:space="preserve">
          <source>NonZeroU32::lt</source>
          <target state="translated">NonZeroU32::lt</target>
        </trans-unit>
        <trans-unit id="030aea2e6963a8f4da13cbc262733cb19ce4afc3" translate="yes" xml:space="preserve">
          <source>NonZeroU32::max</source>
          <target state="translated">NonZeroU32::max</target>
        </trans-unit>
        <trans-unit id="ec7f1e7d4f631759d2fa095faa8ca43552f8684a" translate="yes" xml:space="preserve">
          <source>NonZeroU32::min</source>
          <target state="translated">NonZeroU32::min</target>
        </trans-unit>
        <trans-unit id="1339b30fe6c5981bffbab3f00e68cdd9c9f8a0bc" translate="yes" xml:space="preserve">
          <source>NonZeroU32::ne</source>
          <target state="translated">NonZeroU32::ne</target>
        </trans-unit>
        <trans-unit id="0d42ac2122a8ce6e542130048262c73787d65cfa" translate="yes" xml:space="preserve">
          <source>NonZeroU32::new</source>
          <target state="translated">NonZeroU32::new</target>
        </trans-unit>
        <trans-unit id="53b766be632e74846603297c0e0ac6f9ccfdb9cc" translate="yes" xml:space="preserve">
          <source>NonZeroU32::new_unchecked</source>
          <target state="translated">NonZeroU32::new_unchecked</target>
        </trans-unit>
        <trans-unit id="8d058b61ea076257a2a74125c037a43db242bed9" translate="yes" xml:space="preserve">
          <source>NonZeroU32::partial_cmp</source>
          <target state="translated">NonZeroU32::partial_cmp</target>
        </trans-unit>
        <trans-unit id="daeb2592a753cbd5361feb58a583b78797b11fc9" translate="yes" xml:space="preserve">
          <source>NonZeroU32::to_owned</source>
          <target state="translated">NonZeroU32::to_owned</target>
        </trans-unit>
        <trans-unit id="60aaf34cff920dc42256dc10eec23c5ea806feec" translate="yes" xml:space="preserve">
          <source>NonZeroU32::to_string</source>
          <target state="translated">NonZeroU32::to_string</target>
        </trans-unit>
        <trans-unit id="73f9e4f2ad5073070910a47ac63d54b649f8d6e8" translate="yes" xml:space="preserve">
          <source>NonZeroU32::try_from</source>
          <target state="translated">NonZeroU32::try_from</target>
        </trans-unit>
        <trans-unit id="63d1c4723bc8f38b153bb0f2590c96abef27a5d0" translate="yes" xml:space="preserve">
          <source>NonZeroU32::try_into</source>
          <target state="translated">NonZeroU32::try_into</target>
        </trans-unit>
        <trans-unit id="97923d854095a52b24576bacbd79fc9ba83145d4" translate="yes" xml:space="preserve">
          <source>NonZeroU32::type_id</source>
          <target state="translated">NonZeroU32::type_id</target>
        </trans-unit>
        <trans-unit id="ff9af574bd71ecdb8a94e5c11d8cb03c995c903e" translate="yes" xml:space="preserve">
          <source>NonZeroU64</source>
          <target state="translated">NonZeroU64</target>
        </trans-unit>
        <trans-unit id="9174928c781d84aa02c125b176a43aa320ff0a5d" translate="yes" xml:space="preserve">
          <source>NonZeroU64::borrow</source>
          <target state="translated">NonZeroU64::borrow</target>
        </trans-unit>
        <trans-unit id="84bb893e16a6e53a0c100c76ec3f68a95e3e668d" translate="yes" xml:space="preserve">
          <source>NonZeroU64::borrow_mut</source>
          <target state="translated">NonZeroU64::borrow_mut</target>
        </trans-unit>
        <trans-unit id="fcf340d75d4265672f320969bda5046bdb409e81" translate="yes" xml:space="preserve">
          <source>NonZeroU64::clamp</source>
          <target state="translated">NonZeroU64::clamp</target>
        </trans-unit>
        <trans-unit id="183552bd8482c37ff61fe2a742c9ddb1ea0ca355" translate="yes" xml:space="preserve">
          <source>NonZeroU64::clone</source>
          <target state="translated">NonZeroU64::clone</target>
        </trans-unit>
        <trans-unit id="0eb415342585f28f35047e6cd3c2974cdbbe66bd" translate="yes" xml:space="preserve">
          <source>NonZeroU64::clone_from</source>
          <target state="translated">NonZeroU64::clone_from</target>
        </trans-unit>
        <trans-unit id="6ab29e679c166bbe4bda6532e91d9eeb91acad3c" translate="yes" xml:space="preserve">
          <source>NonZeroU64::clone_into</source>
          <target state="translated">NonZeroU64::clone_into</target>
        </trans-unit>
        <trans-unit id="a63a17006148383604de4d3fcb995f84d18aaa77" translate="yes" xml:space="preserve">
          <source>NonZeroU64::cmp</source>
          <target state="translated">NonZeroU64::cmp</target>
        </trans-unit>
        <trans-unit id="9de4084186275b67715c01bdf2631108a20373b3" translate="yes" xml:space="preserve">
          <source>NonZeroU64::eq</source>
          <target state="translated">NonZeroU64::eq</target>
        </trans-unit>
        <trans-unit id="f701376286f75acabb93bc338425e6cae42fdba1" translate="yes" xml:space="preserve">
          <source>NonZeroU64::fmt</source>
          <target state="translated">NonZeroU64::fmt</target>
        </trans-unit>
        <trans-unit id="e6c78a21f2934d9a2da92dd578a35b8157419529" translate="yes" xml:space="preserve">
          <source>NonZeroU64::from</source>
          <target state="translated">NonZeroU64::from</target>
        </trans-unit>
        <trans-unit id="546bd47a252bfe7b85af380602d87da22806650f" translate="yes" xml:space="preserve">
          <source>NonZeroU64::from_str</source>
          <target state="translated">NonZeroU64::from_str</target>
        </trans-unit>
        <trans-unit id="9aadba2a2b721871fd6af482b4623eee945bd2ca" translate="yes" xml:space="preserve">
          <source>NonZeroU64::ge</source>
          <target state="translated">NonZeroU64::ge</target>
        </trans-unit>
        <trans-unit id="23badb59c2bf64bbfd600b89c65d6464f288c34e" translate="yes" xml:space="preserve">
          <source>NonZeroU64::get</source>
          <target state="translated">NonZeroU64::get</target>
        </trans-unit>
        <trans-unit id="70ba0bfc2ee5de3dc8d77e5c800ac26d942aad60" translate="yes" xml:space="preserve">
          <source>NonZeroU64::gt</source>
          <target state="translated">NonZeroU64::gt</target>
        </trans-unit>
        <trans-unit id="1be0d3fa424fa8f1c9033db1563822faa87d86bc" translate="yes" xml:space="preserve">
          <source>NonZeroU64::hash</source>
          <target state="translated">NonZeroU64::hash</target>
        </trans-unit>
        <trans-unit id="9ef89b20cd332d28440efb1ab8c800e464dbc0c5" translate="yes" xml:space="preserve">
          <source>NonZeroU64::hash_slice</source>
          <target state="translated">NonZeroU64::hash_slice</target>
        </trans-unit>
        <trans-unit id="9cf4c75c1bac7fde4346dcdbc35fda963e585282" translate="yes" xml:space="preserve">
          <source>NonZeroU64::into</source>
          <target state="translated">NonZeroU64::into</target>
        </trans-unit>
        <trans-unit id="7376c3fefec318f3031bdc950d6f8f2a3089d974" translate="yes" xml:space="preserve">
          <source>NonZeroU64::le</source>
          <target state="translated">NonZeroU64::le</target>
        </trans-unit>
        <trans-unit id="9c3837210065694f326259c4c009fcf151ab8938" translate="yes" xml:space="preserve">
          <source>NonZeroU64::lt</source>
          <target state="translated">NonZeroU64::lt</target>
        </trans-unit>
        <trans-unit id="e88a4e86bb9a247b011285115d5e4adc34155d05" translate="yes" xml:space="preserve">
          <source>NonZeroU64::max</source>
          <target state="translated">NonZeroU64::max</target>
        </trans-unit>
        <trans-unit id="3ca2447656d5c5bf7e39124b2a8d6630ff253464" translate="yes" xml:space="preserve">
          <source>NonZeroU64::min</source>
          <target state="translated">NonZeroU64::min</target>
        </trans-unit>
        <trans-unit id="bf2706867bfa59da3e12e574c1c7a042c0c7fa0a" translate="yes" xml:space="preserve">
          <source>NonZeroU64::ne</source>
          <target state="translated">NonZeroU64::ne</target>
        </trans-unit>
        <trans-unit id="2fb761a04a1a28848d5bbb8c94562514f64738e6" translate="yes" xml:space="preserve">
          <source>NonZeroU64::new</source>
          <target state="translated">NonZeroU64::new</target>
        </trans-unit>
        <trans-unit id="a84ebe37c16ccdf34c145d075dd2d1ae8e718fd7" translate="yes" xml:space="preserve">
          <source>NonZeroU64::new_unchecked</source>
          <target state="translated">NonZeroU64::new_unchecked</target>
        </trans-unit>
        <trans-unit id="424d3fd0d71ac1783106c5f073cedfafd2433e33" translate="yes" xml:space="preserve">
          <source>NonZeroU64::partial_cmp</source>
          <target state="translated">NonZeroU64::partial_cmp</target>
        </trans-unit>
        <trans-unit id="689c6172e5e5fa7d743f6d9ea54feb2a2c45360e" translate="yes" xml:space="preserve">
          <source>NonZeroU64::to_owned</source>
          <target state="translated">NonZeroU64::to_owned</target>
        </trans-unit>
        <trans-unit id="0f770ca97d17ac208580e4663b1cb35d1585cd0a" translate="yes" xml:space="preserve">
          <source>NonZeroU64::to_string</source>
          <target state="translated">NonZeroU64::to_string</target>
        </trans-unit>
        <trans-unit id="b3edffffa9ccb083ef6dc98f9a91d2ee62a6a140" translate="yes" xml:space="preserve">
          <source>NonZeroU64::try_from</source>
          <target state="translated">NonZeroU64::try_from</target>
        </trans-unit>
        <trans-unit id="2309bbba28296004c54d80642075d1ce6e4cf120" translate="yes" xml:space="preserve">
          <source>NonZeroU64::try_into</source>
          <target state="translated">NonZeroU64::try_into</target>
        </trans-unit>
        <trans-unit id="ddce3cce76f837592f485e87ab5ddde6cfce8cd0" translate="yes" xml:space="preserve">
          <source>NonZeroU64::type_id</source>
          <target state="translated">NonZeroU64::type_id</target>
        </trans-unit>
        <trans-unit id="93acae18872d78f1044f122c7fa386b8e0790d18" translate="yes" xml:space="preserve">
          <source>NonZeroU8</source>
          <target state="translated">NonZeroU8</target>
        </trans-unit>
        <trans-unit id="6ff1a3cea907e661f3495c1cde07624988c92d18" translate="yes" xml:space="preserve">
          <source>NonZeroU8::borrow</source>
          <target state="translated">NonZeroU8::borrow</target>
        </trans-unit>
        <trans-unit id="63abe3b6e90de29270a227a14eb1cd95090ba8b5" translate="yes" xml:space="preserve">
          <source>NonZeroU8::borrow_mut</source>
          <target state="translated">NonZeroU8::borrow_mut</target>
        </trans-unit>
        <trans-unit id="803a11a99b517fd90ac23a43eefbdfca5457f48a" translate="yes" xml:space="preserve">
          <source>NonZeroU8::clamp</source>
          <target state="translated">NonZeroU8::clamp</target>
        </trans-unit>
        <trans-unit id="5c11d86db1fbb6b9b9c0d8f7f4a28a4bf6afbb24" translate="yes" xml:space="preserve">
          <source>NonZeroU8::clone</source>
          <target state="translated">NonZeroU8::clone</target>
        </trans-unit>
        <trans-unit id="670ad8364fc1871b9629299e869bcbacc5da96b2" translate="yes" xml:space="preserve">
          <source>NonZeroU8::clone_from</source>
          <target state="translated">NonZeroU8::clone_from</target>
        </trans-unit>
        <trans-unit id="6c6784a6e074a57a017f865c39fe9469883e2de8" translate="yes" xml:space="preserve">
          <source>NonZeroU8::clone_into</source>
          <target state="translated">NonZeroU8::clone_into</target>
        </trans-unit>
        <trans-unit id="693fb00ea40fa5aabc302b79d7c8e3718e6c8088" translate="yes" xml:space="preserve">
          <source>NonZeroU8::cmp</source>
          <target state="translated">NonZeroU8::cmp</target>
        </trans-unit>
        <trans-unit id="2158bd65bbc659ddb6d6412bd01916cb5d982ed3" translate="yes" xml:space="preserve">
          <source>NonZeroU8::eq</source>
          <target state="translated">NonZeroU8::eq</target>
        </trans-unit>
        <trans-unit id="3c80d10814d815cf1d99f1b13a12df65b0875877" translate="yes" xml:space="preserve">
          <source>NonZeroU8::fmt</source>
          <target state="translated">NonZeroU8::fmt</target>
        </trans-unit>
        <trans-unit id="7deaab84759c8ba54fbc5d91e72a59bd1aeb6577" translate="yes" xml:space="preserve">
          <source>NonZeroU8::from</source>
          <target state="translated">NonZeroU8::from</target>
        </trans-unit>
        <trans-unit id="2756bc8cdd2a9198a79f5cf73b9e1d572f0f1491" translate="yes" xml:space="preserve">
          <source>NonZeroU8::from_str</source>
          <target state="translated">NonZeroU8::from_str</target>
        </trans-unit>
        <trans-unit id="96e3274a26e461fa91c098ddcfa2558cac9c4747" translate="yes" xml:space="preserve">
          <source>NonZeroU8::ge</source>
          <target state="translated">NonZeroU8::ge</target>
        </trans-unit>
        <trans-unit id="922117f87c8142145cb8b8abbabb7402b5e2bc53" translate="yes" xml:space="preserve">
          <source>NonZeroU8::get</source>
          <target state="translated">NonZeroU8::get</target>
        </trans-unit>
        <trans-unit id="9d9dcce691d917ac54e2661132eb0950cc45d9a7" translate="yes" xml:space="preserve">
          <source>NonZeroU8::gt</source>
          <target state="translated">NonZeroU8::gt</target>
        </trans-unit>
        <trans-unit id="86ed98098229a654859aa731e5195157190e73cb" translate="yes" xml:space="preserve">
          <source>NonZeroU8::hash</source>
          <target state="translated">NonZeroU8::hash</target>
        </trans-unit>
        <trans-unit id="cb3adb90e777f04027a60a7879f9d135f08d1607" translate="yes" xml:space="preserve">
          <source>NonZeroU8::hash_slice</source>
          <target state="translated">NonZeroU8::hash_slice</target>
        </trans-unit>
        <trans-unit id="b79391b251df236d1d6289790b5260179dbdacc9" translate="yes" xml:space="preserve">
          <source>NonZeroU8::into</source>
          <target state="translated">NonZeroU8::into</target>
        </trans-unit>
        <trans-unit id="349980dfec87decceb14ada089c45ad6b63c099a" translate="yes" xml:space="preserve">
          <source>NonZeroU8::le</source>
          <target state="translated">NonZeroU8::le</target>
        </trans-unit>
        <trans-unit id="d736ad9511ba8ef5fa21ea6939ea1822c7d2dcb0" translate="yes" xml:space="preserve">
          <source>NonZeroU8::lt</source>
          <target state="translated">NonZeroU8::lt</target>
        </trans-unit>
        <trans-unit id="a284bcab69108d0fe7e56d5c4b3448e94a95b9b7" translate="yes" xml:space="preserve">
          <source>NonZeroU8::max</source>
          <target state="translated">NonZeroU8::max</target>
        </trans-unit>
        <trans-unit id="5a9a87bf0c351a8fa498461781bb9417c3bc85f9" translate="yes" xml:space="preserve">
          <source>NonZeroU8::min</source>
          <target state="translated">NonZeroU8::min</target>
        </trans-unit>
        <trans-unit id="950681f0c85136301d4d8bc7bd384530cbe0ad13" translate="yes" xml:space="preserve">
          <source>NonZeroU8::ne</source>
          <target state="translated">NonZeroU8::ne</target>
        </trans-unit>
        <trans-unit id="32bcfbfa6acfd6ddd32e20022619e9223f40a94f" translate="yes" xml:space="preserve">
          <source>NonZeroU8::new</source>
          <target state="translated">NonZeroU8::new</target>
        </trans-unit>
        <trans-unit id="c65bae8471e01bcbc9a0141783aef01900f64a4c" translate="yes" xml:space="preserve">
          <source>NonZeroU8::new_unchecked</source>
          <target state="translated">NonZeroU8::new_unchecked</target>
        </trans-unit>
        <trans-unit id="60e3a745d7919f9cebc4387f60a9049fdd9960a9" translate="yes" xml:space="preserve">
          <source>NonZeroU8::partial_cmp</source>
          <target state="translated">NonZeroU8::partial_cmp</target>
        </trans-unit>
        <trans-unit id="814facf57cfd7397aa0ec4ff5934741dc1504d0a" translate="yes" xml:space="preserve">
          <source>NonZeroU8::to_owned</source>
          <target state="translated">NonZeroU8::to_owned</target>
        </trans-unit>
        <trans-unit id="b5e9e73145a1a10790ac2c4b4ee56c85d1e6f97f" translate="yes" xml:space="preserve">
          <source>NonZeroU8::to_string</source>
          <target state="translated">NonZeroU8::to_string</target>
        </trans-unit>
        <trans-unit id="2b735ce2d45697df8d25226cb8808f268d9dad27" translate="yes" xml:space="preserve">
          <source>NonZeroU8::try_from</source>
          <target state="translated">NonZeroU8::try_from</target>
        </trans-unit>
        <trans-unit id="2b02b5ef9beb40480c74f9952d3ce821f4d69911" translate="yes" xml:space="preserve">
          <source>NonZeroU8::try_into</source>
          <target state="translated">NonZeroU8::try_into</target>
        </trans-unit>
        <trans-unit id="8c0fc32ec166f66886b38f57ea7d3cb7a7835fe2" translate="yes" xml:space="preserve">
          <source>NonZeroU8::type_id</source>
          <target state="translated">NonZeroU8::type_id</target>
        </trans-unit>
        <trans-unit id="b35788d3f6ffc592ab0774878cef29486e7e5bd4" translate="yes" xml:space="preserve">
          <source>NonZeroUsize</source>
          <target state="translated">NonZeroUsize</target>
        </trans-unit>
        <trans-unit id="c419d78f65ceafa9adf9a16c8a0459bf66be0bb0" translate="yes" xml:space="preserve">
          <source>NonZeroUsize::borrow</source>
          <target state="translated">NonZeroUsize::borrow</target>
        </trans-unit>
        <trans-unit id="c7ac97a8de687d7597163c213da2788ada2700d7" translate="yes" xml:space="preserve">
          <source>NonZeroUsize::borrow_mut</source>
          <target state="translated">NonZeroUsize::borrow_mut</target>
        </trans-unit>
        <trans-unit id="d423dc3c41f93a9c06c0e4ce6ae7fc621e805056" translate="yes" xml:space="preserve">
          <source>NonZeroUsize::clamp</source>
          <target state="translated">NonZeroUsize::clamp</target>
        </trans-unit>
        <trans-unit id="47e7faa665db9da3adc8893ed9e5dcaa815fe4b2" translate="yes" xml:space="preserve">
          <source>NonZeroUsize::clone</source>
          <target state="translated">NonZeroUsize::clone</target>
        </trans-unit>
        <trans-unit id="cb938c36bd0b3049477f6ad99f18c0d0ed6bf26f" translate="yes" xml:space="preserve">
          <source>NonZeroUsize::clone_from</source>
          <target state="translated">NonZeroUsize::clone_from</target>
        </trans-unit>
        <trans-unit id="030e5620dfbf55afbbfe2d9c96c1e322152959d2" translate="yes" xml:space="preserve">
          <source>NonZeroUsize::clone_into</source>
          <target state="translated">NonZeroUsize::clone_into</target>
        </trans-unit>
        <trans-unit id="a38099d022e9104d990e7e4e2d00982504357f0e" translate="yes" xml:space="preserve">
          <source>NonZeroUsize::cmp</source>
          <target state="translated">NonZeroUsize::cmp</target>
        </trans-unit>
        <trans-unit id="57469c189c9f0d01b944369669232584fcab48be" translate="yes" xml:space="preserve">
          <source>NonZeroUsize::eq</source>
          <target state="translated">NonZeroUsize::eq</target>
        </trans-unit>
        <trans-unit id="a3e007978854dfec2ea17781a918799b74afb325" translate="yes" xml:space="preserve">
          <source>NonZeroUsize::fmt</source>
          <target state="translated">NonZeroUsize::fmt</target>
        </trans-unit>
        <trans-unit id="f78a5853c07aa978500a70738e411232664860cc" translate="yes" xml:space="preserve">
          <source>NonZeroUsize::from</source>
          <target state="translated">NonZeroUsize::from</target>
        </trans-unit>
        <trans-unit id="7712061538648151dde34c4415be3b5d61f5877b" translate="yes" xml:space="preserve">
          <source>NonZeroUsize::from_str</source>
          <target state="translated">NonZeroUsize::from_str</target>
        </trans-unit>
        <trans-unit id="f4728f09de22bd70d445970426411f10a0225b43" translate="yes" xml:space="preserve">
          <source>NonZeroUsize::ge</source>
          <target state="translated">NonZeroUsize::ge</target>
        </trans-unit>
        <trans-unit id="b1cdf6cf2409f8c0f48ff7b3ba56ccc5ce5115e9" translate="yes" xml:space="preserve">
          <source>NonZeroUsize::get</source>
          <target state="translated">NonZeroUsize::get</target>
        </trans-unit>
        <trans-unit id="a20bd2dec9d5657f43798c2c990e62953392115c" translate="yes" xml:space="preserve">
          <source>NonZeroUsize::gt</source>
          <target state="translated">NonZeroUsize::gt</target>
        </trans-unit>
        <trans-unit id="801d8bc95574bf029e7d684d2cf3f771b60cd725" translate="yes" xml:space="preserve">
          <source>NonZeroUsize::hash</source>
          <target state="translated">NonZeroUsize::hash</target>
        </trans-unit>
        <trans-unit id="6e0922eea57f8699c098adb3c035a1605d38f3df" translate="yes" xml:space="preserve">
          <source>NonZeroUsize::hash_slice</source>
          <target state="translated">NonZeroUsize::hash_slice</target>
        </trans-unit>
        <trans-unit id="fb7586f1fe5330ac7ebbf29da06f142f1a81f679" translate="yes" xml:space="preserve">
          <source>NonZeroUsize::into</source>
          <target state="translated">NonZeroUsize::into</target>
        </trans-unit>
        <trans-unit id="2236d0a73fe65fdff9ad7360c0db597b0672828c" translate="yes" xml:space="preserve">
          <source>NonZeroUsize::le</source>
          <target state="translated">NonZeroUsize::le</target>
        </trans-unit>
        <trans-unit id="9347ed4b41dd70587e1703f7c2e07851b56cb2e9" translate="yes" xml:space="preserve">
          <source>NonZeroUsize::lt</source>
          <target state="translated">NonZeroUsize::lt</target>
        </trans-unit>
        <trans-unit id="751ac4d697954b225e6f1616e4b4e0881bb6a41f" translate="yes" xml:space="preserve">
          <source>NonZeroUsize::max</source>
          <target state="translated">NonZeroUsize::max</target>
        </trans-unit>
        <trans-unit id="00f9ea1a8ab80868d5583ca29a5d8f2c152f6d4b" translate="yes" xml:space="preserve">
          <source>NonZeroUsize::min</source>
          <target state="translated">NonZeroUsize::min</target>
        </trans-unit>
        <trans-unit id="a3adc830a3d6e8e1f76b36c1da867853c22f3352" translate="yes" xml:space="preserve">
          <source>NonZeroUsize::ne</source>
          <target state="translated">NonZeroUsize::ne</target>
        </trans-unit>
        <trans-unit id="b482e2411d650436386f31aaaee9d529c27faf6c" translate="yes" xml:space="preserve">
          <source>NonZeroUsize::new</source>
          <target state="translated">NonZeroUsize::new</target>
        </trans-unit>
        <trans-unit id="0a63ca14c98c0ba3afecce88c1ee164dbbe678b5" translate="yes" xml:space="preserve">
          <source>NonZeroUsize::new_unchecked</source>
          <target state="translated">NonZeroUsize::new_unchecked</target>
        </trans-unit>
        <trans-unit id="d2e829a9fc8b73a5ec3a806953ba65e782b63e4f" translate="yes" xml:space="preserve">
          <source>NonZeroUsize::partial_cmp</source>
          <target state="translated">NonZeroUsize::partial_cmp</target>
        </trans-unit>
        <trans-unit id="0fc32bf985ee7be65f7708751121df22adec3ee2" translate="yes" xml:space="preserve">
          <source>NonZeroUsize::to_owned</source>
          <target state="translated">NonZeroUsize::to_owned</target>
        </trans-unit>
        <trans-unit id="368109929572f9725530c9b5e66c0770d0254f6c" translate="yes" xml:space="preserve">
          <source>NonZeroUsize::to_string</source>
          <target state="translated">NonZeroUsize::to_string</target>
        </trans-unit>
        <trans-unit id="87d57ca9ccbaaeab13b116376180c23efda524d3" translate="yes" xml:space="preserve">
          <source>NonZeroUsize::try_from</source>
          <target state="translated">NonZeroUsize::try_from</target>
        </trans-unit>
        <trans-unit id="f36d6ccda72162b66595cff5afa6abcccb3ef47a" translate="yes" xml:space="preserve">
          <source>NonZeroUsize::try_into</source>
          <target state="translated">NonZeroUsize::try_into</target>
        </trans-unit>
        <trans-unit id="661478a23cc64b875358e2c7f6262c9eb208bcf8" translate="yes" xml:space="preserve">
          <source>NonZeroUsize::type_id</source>
          <target state="translated">NonZeroUsize::type_id</target>
        </trans-unit>
        <trans-unit id="36aa77cbc45a62a558a375b317bc9b3804badfce" translate="yes" xml:space="preserve">
          <source>NoneError</source>
          <target state="translated">NoneError</target>
        </trans-unit>
        <trans-unit id="8def7b12f8f65fd01050dafd05df50f8287c0655" translate="yes" xml:space="preserve">
          <source>NoneError::borrow</source>
          <target state="translated">NoneError::borrow</target>
        </trans-unit>
        <trans-unit id="411f23ffccc2c350e97a02f83bb00bb04a9c1832" translate="yes" xml:space="preserve">
          <source>NoneError::borrow_mut</source>
          <target state="translated">NoneError::borrow_mut</target>
        </trans-unit>
        <trans-unit id="a4d6154b1c340d1443c5a20d251329f398af2e11" translate="yes" xml:space="preserve">
          <source>NoneError::clamp</source>
          <target state="translated">NoneError::clamp</target>
        </trans-unit>
        <trans-unit id="555a6fa6139d1928ed4e7fa787af07b254f8f631" translate="yes" xml:space="preserve">
          <source>NoneError::clone</source>
          <target state="translated">NoneError::clone</target>
        </trans-unit>
        <trans-unit id="b7be3f1dfae027d0e36e44675d36fbd402d1e26e" translate="yes" xml:space="preserve">
          <source>NoneError::clone_from</source>
          <target state="translated">NoneError::clone_from</target>
        </trans-unit>
        <trans-unit id="dc67355563b52eb89e32ff38b5504d3dd52d77c9" translate="yes" xml:space="preserve">
          <source>NoneError::clone_into</source>
          <target state="translated">NoneError::clone_into</target>
        </trans-unit>
        <trans-unit id="65e99ec3e2a6e151575264b82499d7f2e38008ff" translate="yes" xml:space="preserve">
          <source>NoneError::cmp</source>
          <target state="translated">NoneError::cmp</target>
        </trans-unit>
        <trans-unit id="0611d16ae0dbf1df9ec05c20e45d31816b7a33e3" translate="yes" xml:space="preserve">
          <source>NoneError::eq</source>
          <target state="translated">NoneError::eq</target>
        </trans-unit>
        <trans-unit id="ddc77b796895a55df93a0b820a464b4aa338d41d" translate="yes" xml:space="preserve">
          <source>NoneError::fmt</source>
          <target state="translated">NoneError::fmt</target>
        </trans-unit>
        <trans-unit id="f69f3c5a7bc9e57ba1c80a5b7f03fced9bacf61f" translate="yes" xml:space="preserve">
          <source>NoneError::from</source>
          <target state="translated">NoneError::from</target>
        </trans-unit>
        <trans-unit id="ea4b13c4f12ac04af5fe2cbffa33fc963c8d5a26" translate="yes" xml:space="preserve">
          <source>NoneError::ge</source>
          <target state="translated">NoneError::ge</target>
        </trans-unit>
        <trans-unit id="80a0b1216e8cf201b9e9391df5c095172374f508" translate="yes" xml:space="preserve">
          <source>NoneError::gt</source>
          <target state="translated">NoneError::gt</target>
        </trans-unit>
        <trans-unit id="3cade823dfb903a695b6582abf8a0356daee7927" translate="yes" xml:space="preserve">
          <source>NoneError::hash</source>
          <target state="translated">NoneError::hash</target>
        </trans-unit>
        <trans-unit id="2c1acaeb04c59b2f4a9a10620721a7a1d4aa42f7" translate="yes" xml:space="preserve">
          <source>NoneError::hash_slice</source>
          <target state="translated">NoneError::hash_slice</target>
        </trans-unit>
        <trans-unit id="46b77ff1d8e23b12f242a6cf68b6e7dd11a9e430" translate="yes" xml:space="preserve">
          <source>NoneError::into</source>
          <target state="translated">NoneError::into</target>
        </trans-unit>
        <trans-unit id="ba9c0b7fd1b90ee18de8e25f5e5340671555fa67" translate="yes" xml:space="preserve">
          <source>NoneError::le</source>
          <target state="translated">NoneError::le</target>
        </trans-unit>
        <trans-unit id="41e697d230de0c7c6e3ccd553c26214e3ef30472" translate="yes" xml:space="preserve">
          <source>NoneError::lt</source>
          <target state="translated">NoneError::lt</target>
        </trans-unit>
        <trans-unit id="02bc1b16e164540afd825f0ab014879760deedcf" translate="yes" xml:space="preserve">
          <source>NoneError::max</source>
          <target state="translated">NoneError::max</target>
        </trans-unit>
        <trans-unit id="03ed85d18288e8c6efca69c28f3c605bc8004901" translate="yes" xml:space="preserve">
          <source>NoneError::min</source>
          <target state="translated">NoneError::min</target>
        </trans-unit>
        <trans-unit id="0cf87dcf59fc2d8f60cce9e0913e3c5ea01c71c6" translate="yes" xml:space="preserve">
          <source>NoneError::ne</source>
          <target state="translated">NoneError::ne</target>
        </trans-unit>
        <trans-unit id="88b27454a88f2b6d19dafb3a30b27e9e4799a66b" translate="yes" xml:space="preserve">
          <source>NoneError::partial_cmp</source>
          <target state="translated">NoneError::partial_cmp</target>
        </trans-unit>
        <trans-unit id="d76800607ec208e0e9251b9a3a41ceabc49a331f" translate="yes" xml:space="preserve">
          <source>NoneError::to_owned</source>
          <target state="translated">NoneError::to_owned</target>
        </trans-unit>
        <trans-unit id="a3e3b0d2121e13d536f0151b0514e0d6c2c50efe" translate="yes" xml:space="preserve">
          <source>NoneError::try_from</source>
          <target state="translated">NoneError::try_from</target>
        </trans-unit>
        <trans-unit id="b6f9326f4f9275b1c9ee9bf38430eb240361bf0b" translate="yes" xml:space="preserve">
          <source>NoneError::try_into</source>
          <target state="translated">NoneError::try_into</target>
        </trans-unit>
        <trans-unit id="2ed007421edc30616530d31dc1a9b886d8f905b6" translate="yes" xml:space="preserve">
          <source>NoneError::type_id</source>
          <target state="translated">NoneError::type_id</target>
        </trans-unit>
        <trans-unit id="59bdf32f963e32403610f535ed38d94ab9fa57b3" translate="yes" xml:space="preserve">
          <source>Nonequality comparison</source>
          <target state="translated">Нет сравнения качества</target>
        </trans-unit>
        <trans-unit id="aa380f41959815056bfdd3029c1845bf486477df" translate="yes" xml:space="preserve">
          <source>Nor can you use direct field access to do field-by-field gradual initialization:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="19eddb0e70179b2e619be3068cd8376966632800" translate="yes" xml:space="preserve">
          <source>Nor will this:</source>
          <target state="translated">И это тоже:</target>
        </trans-unit>
        <trans-unit id="9b417a21d4e30df48f9cabc1eb07b9ff439a8913" translate="yes" xml:space="preserve">
          <source>Normally, here, one would use &lt;a href=&quot;#method.clear&quot;&gt;&lt;code&gt;clear&lt;/code&gt;&lt;/a&gt; instead to correctly drop the contents and thus not leak memory.</source>
          <target state="translated">Обычно здесь можно использовать &lt;a href=&quot;#method.clear&quot;&gt; &lt;code&gt;clear&lt;/code&gt; ,&lt;/a&gt; чтобы правильно удалить содержимое и, таким образом, избежать утечки памяти.</target>
        </trans-unit>
        <trans-unit id="5084dc27f957de7bc8c196b5f20cd9275d3c3a4f" translate="yes" xml:space="preserve">
          <source>Normally, here, one would use &lt;a href=&quot;struct.vec#method.clear&quot;&gt;&lt;code&gt;clear&lt;/code&gt;&lt;/a&gt; instead to correctly drop the contents and thus not leak memory.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ca1dd39379254ab3f3c73dbffb0d03d628b27d20" translate="yes" xml:space="preserve">
          <source>Not</source>
          <target state="translated">Not</target>
        </trans-unit>
        <trans-unit id="7531cdd8037edc1069a4fd743641ffecf0edfa83" translate="yes" xml:space="preserve">
          <source>Not Equal</source>
          <target state="translated">Не равный</target>
        </trans-unit>
        <trans-unit id="f8548a3657bfc32a33e876b215b140f301134c05" translate="yes" xml:space="preserve">
          <source>Not a Number (NaN).</source>
          <target state="translated">Не Номер (NaN).</target>
        </trans-unit>
        <trans-unit id="d52a965ff185906c6e9fb5c36534475faa112b26" translate="yes" xml:space="preserve">
          <source>Not a Number (NaN). Use &lt;a href=&quot;../primitive.f32#associatedconstant.NAN&quot;&gt;&lt;code&gt;f32::NAN&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bd484bf7d113fac0a06fa50cec141b09e01e967e" translate="yes" xml:space="preserve">
          <source>Not a Number (NaN). Use &lt;a href=&quot;../primitive.f64#associatedconstant.NAN&quot;&gt;&lt;code&gt;f64::NAN&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="64507e89e4bdf04e8f9c77f8ac34253ff22412a5" translate="yes" xml:space="preserve">
          <source>Not all platforms that libstd compiles for support capturing backtraces. Some platforms simply do nothing when capturing a backtrace. To check whether the platform supports capturing backtraces you can consult the &lt;code&gt;BacktraceStatus&lt;/code&gt; enum as a result of &lt;code&gt;Backtrace::status&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="736e9bdbdcdd4b04a6c46d181f239630b7b9a187" translate="yes" xml:space="preserve">
          <source>Not all uses of &lt;code&gt;unsafe&lt;/code&gt; are equivalent: some are here to mark the existence of a contract the programmer must check, others are to say &quot;I have checked the contract, go ahead and do this&quot;. The following &lt;a href=&quot;https://internals.rust-lang.org/t/what-does-unsafe-mean/6696&quot;&gt;discussion on Rust Internals&lt;/a&gt; has more in-depth explanations about this but here is a summary of the main points:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f2508d67aae4fe16b65d89f08837d02c03c4df29" translate="yes" xml:space="preserve">
          <source>Not be &lt;code&gt;NaN&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d13ee2c7e4ca985d57b930eb6ea7f0b33421d3e0" translate="yes" xml:space="preserve">
          <source>Not be infinite</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6eb5b8bcff17673aebb4af5a3aeb0b4ab1932316" translate="yes" xml:space="preserve">
          <source>Not equal</source>
          <target state="translated">Не равный</target>
        </trans-unit>
        <trans-unit id="a2b674143c807a9d4d57ac721ad16bfa7f8e15e8" translate="yes" xml:space="preserve">
          <source>Not finding the pattern:</source>
          <target state="translated">Не нахожу закономерности:</target>
        </trans-unit>
        <trans-unit id="ba8cbd3db6c5866f33c337f17d9969faf64a68a8" translate="yes" xml:space="preserve">
          <source>Not have any type parameters (although lifetime parameters are allowed), and</source>
          <target state="translated">Не имеют параметров типа (хотя параметры времени жизни разрешены),и</target>
        </trans-unit>
        <trans-unit id="fcaef0deabf89559da493cc8fdbfb1b73c922bc5" translate="yes" xml:space="preserve">
          <source>Not having to worry about incorrectly assuming a not-null value helps you to be more confident in your code. In order to have a value that can possibly be null, you must explicitly opt in by making the type of that value &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt;. Then, when you use that value, you are required to explicitly handle the case when the value is null. Everywhere that a value has a type that isn&amp;rsquo;t an &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt;, you &lt;em&gt;can&lt;/em&gt; safely assume that the value isn&amp;rsquo;t null. This was a deliberate design decision for Rust to limit null&amp;rsquo;s pervasiveness and increase the safety of Rust code.</source>
          <target state="translated">Отсутствие необходимости беспокоиться о неправильном принятии ненулевого значения помогает вам быть более уверенным в своем коде. Чтобы иметь значение, которое может быть нулевым, вы должны явным образом согласиться, указав тип этого значения &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt; . Затем, когда вы используете это значение, вам необходимо явно обрабатывать случай, когда значение равно null. Везде, где значение имеет тип, отличный от &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt; , вы &lt;em&gt;можете с&lt;/em&gt; уверенностью предположить, что значение не равно null. Это было преднамеренное дизайнерское решение для Rust, чтобы ограничить распространение null и повысить безопасность кода Rust.</target>
        </trans-unit>
        <trans-unit id="c51294854fb6314b2caed8c3d6d50e7adbd261e2" translate="yes" xml:space="preserve">
          <source>Not running destructors</source>
          <target state="translated">Не работающие деструкторы</target>
        </trans-unit>
        <trans-unit id="b24fd225d5f013f2fa70d00cf4c24dafb25feaf7" translate="yes" xml:space="preserve">
          <source>Not running destructors in Rust is safe even if it has a type that isn't &lt;code&gt;'static&lt;/code&gt;. &lt;a href=&quot;../std/mem/struct.manuallydrop&quot;&gt;&lt;code&gt;std::mem::ManuallyDrop&lt;/code&gt;&lt;/a&gt; provides a wrapper to prevent a variable or field from being dropped automatically.</source>
          <target state="translated">Не запускать деструкторы в Rust безопасно, даже если у него не &lt;code&gt;'static&lt;/code&gt; тип . &lt;a href=&quot;../std/mem/struct.manuallydrop&quot;&gt; &lt;code&gt;std::mem::ManuallyDrop&lt;/code&gt; &lt;/a&gt; предоставляет оболочку для предотвращения автоматического удаления переменной или поля.</target>
        </trans-unit>
        <trans-unit id="0c7cc856a7f3d9cb5a50a65d04097b3b7b8538aa" translate="yes" xml:space="preserve">
          <source>Not that this function returns NaN if the initial value was NaN as well.</source>
          <target state="translated">Не то,чтобы эта функция возвращала NaN,если начальное значение также было NaN.</target>
        </trans-unit>
        <trans-unit id="c78919f021b1d754a66fe9891819ec98d0a80ddf" translate="yes" xml:space="preserve">
          <source>Not::not</source>
          <target state="translated">Not::not</target>
        </trans-unit>
        <trans-unit id="67e3ba0677bb45d7937c81385c061373c31498a8" translate="yes" xml:space="preserve">
          <source>Notable exception is made for situations where any of the directories specified in the &lt;code&gt;path&lt;/code&gt; could not be created as it was being created concurrently. Such cases are considered to be successful. That is, calling &lt;code&gt;create_dir_all&lt;/code&gt; concurrently from multiple threads or processes is guaranteed not to fail due to a race condition with itself.</source>
          <target state="translated">Заметное исключение делается для ситуаций, когда любой из каталогов, указанных в &lt;code&gt;path&lt;/code&gt; не может быть создан, поскольку он создавался одновременно. Такие дела считаются успешными. То есть одновременный вызов &lt;code&gt;create_dir_all&lt;/code&gt; из нескольких потоков или процессов гарантированно не завершится ошибкой из-за состояния гонки с самим собой.</target>
        </trans-unit>
        <trans-unit id="23a734e9b17de37ddc28f39d989ac717c3bd9ad8" translate="yes" xml:space="preserve">
          <source>Notable features that const contexts have, but const fn haven't are:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="215a4bdf475a8ec68726e515897b581b10444b3f" translate="yes" xml:space="preserve">
          <source>Notable traits for &amp;amp;'_ [u8]</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d369df1510ca517b58a49f8cd6e6bb0e489ca52a" translate="yes" xml:space="preserve">
          <source>Notable traits for &amp;amp;'_ mut F</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5e37dfc133bc97ebdeab9c07032473d9272189b3" translate="yes" xml:space="preserve">
          <source>Notable traits for &amp;amp;'_ mut I</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6cb09acdfe424fff47bc90762c736658052520f0" translate="yes" xml:space="preserve">
          <source>Notable traits for Ancestors&amp;lt;'a&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="49884a82c86f5e2dcfd40b1838c34bab8f05e373" translate="yes" xml:space="preserve">
          <source>Notable traits for ArrayChunks&amp;lt;'a, T, N&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0cd325ab96ff06257d643a3909af2cf159e2fa33" translate="yes" xml:space="preserve">
          <source>Notable traits for ArrayChunksMut&amp;lt;'a, T, N&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8e4c4055a5d727f7480702b2cc7fa22ff495757b" translate="yes" xml:space="preserve">
          <source>Notable traits for ArrayWindows&amp;lt;'a, T, N&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a8627fe98c009205a399c633908682c9a3e1ee4d" translate="yes" xml:space="preserve">
          <source>Notable traits for Box&amp;lt;F&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b9870581aecb430500b110feb6009781a8a35709" translate="yes" xml:space="preserve">
          <source>Notable traits for Box&amp;lt;F, A&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="01102f0879a5c2ca5c62809ffff0c0b0bad939d6" translate="yes" xml:space="preserve">
          <source>Notable traits for BufReader&amp;lt;R&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bcafa8b1481fa65c646affea37accfbcf24f6580" translate="yes" xml:space="preserve">
          <source>Notable traits for BufWriter&amp;lt;W&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="73e8f6f48862fb0efc8b91d4c920e5075c8f689b" translate="yes" xml:space="preserve">
          <source>Notable traits for Bytes&amp;lt;'_&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="be95aee73944208a8cbfa7ffa1a48d80537a439d" translate="yes" xml:space="preserve">
          <source>Notable traits for Bytes&amp;lt;R&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e3aa0ca54ac23d2115ba17da930b0b2c7d22ecc0" translate="yes" xml:space="preserve">
          <source>Notable traits for Chain&amp;lt;'a&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="425c2e101149bb0adbc3f3833b4e9a88563fb4a0" translate="yes" xml:space="preserve">
          <source>Notable traits for Chain&amp;lt;A, B&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2a7e1c82210baf0b46d0937fbf969162cf98c76c" translate="yes" xml:space="preserve">
          <source>Notable traits for Chain&amp;lt;T, U&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cd4d751abd8ab3ab6e55826ec326c6f4c431564f" translate="yes" xml:space="preserve">
          <source>Notable traits for CharIndices&amp;lt;'a&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="08171c5effb66b03601f395559057c5c02e5ba5f" translate="yes" xml:space="preserve">
          <source>Notable traits for Chars&amp;lt;'a&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f9df882063622aa637c014b3eaf06c558ffb8da5" translate="yes" xml:space="preserve">
          <source>Notable traits for Chunks&amp;lt;'a, T&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7e432bd66d3f874ed890c86d21283df436f2bbd0" translate="yes" xml:space="preserve">
          <source>Notable traits for ChunksExact&amp;lt;'a, T&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="584a1b10a62ffb190941baeea973451d496428d5" translate="yes" xml:space="preserve">
          <source>Notable traits for ChunksExactMut&amp;lt;'a, T&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="95cc072812a01dbd66f6d2c5f3918fc1eecb2a25" translate="yes" xml:space="preserve">
          <source>Notable traits for ChunksMut&amp;lt;'a, T&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fefa79cd49091a7a7a4ec1ce49b7dc2c3e8635da" translate="yes" xml:space="preserve">
          <source>Notable traits for Cloned&amp;lt;I&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ae1c1d71ecdd9048c788733f05c8ee9170150c39" translate="yes" xml:space="preserve">
          <source>Notable traits for CommandArgs&amp;lt;'a&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d1d93748b1b05464de3995712c8cd56c0fc09338" translate="yes" xml:space="preserve">
          <source>Notable traits for CommandEnvs&amp;lt;'a&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a97de3ec8fdabeefc703a8e7d7547f9f3496a716" translate="yes" xml:space="preserve">
          <source>Notable traits for Components&amp;lt;'a&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d315c976ebb90a2389ef7743e81e7feecc3a3a82" translate="yes" xml:space="preserve">
          <source>Notable traits for Copied&amp;lt;I&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="baf59bdb6fb943dc984c5feb9e03a98364bc20d8" translate="yes" xml:space="preserve">
          <source>Notable traits for Cursor&amp;lt;T&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d59f29f61cd42c0f0ff909de6d45f9e90f184a20" translate="yes" xml:space="preserve">
          <source>Notable traits for Cycle&amp;lt;I&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c53b4ea31bf598b85ea40c284bdb3c0198881f8c" translate="yes" xml:space="preserve">
          <source>Notable traits for DecodeUtf16&amp;lt;I&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b5127544158054e8bfb051274dd2021f84d9c3e7" translate="yes" xml:space="preserve">
          <source>Notable traits for Difference&amp;lt;'a, T&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="49894b4bfbcd9313cd8e1fca37fff62b0d5fe327" translate="yes" xml:space="preserve">
          <source>Notable traits for Difference&amp;lt;'a, T, S&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7bc7c96c5bc0e2db809df1de91687bd4053c4024" translate="yes" xml:space="preserve">
          <source>Notable traits for Drain&amp;lt;'_&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f0c298a9ee76878fdf90e4aa0fdba569c9110023" translate="yes" xml:space="preserve">
          <source>Notable traits for Drain&amp;lt;'_, T&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bfff38769221a3bcf19fc3461189daa684992a6d" translate="yes" xml:space="preserve">
          <source>Notable traits for Drain&amp;lt;'a, K&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="958272eb22af639d41c1f50e43d47fb61a6b14ef" translate="yes" xml:space="preserve">
          <source>Notable traits for Drain&amp;lt;'a, K, V&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0daba3253b1d0ae9af8dc2745c8744b02b11222b" translate="yes" xml:space="preserve">
          <source>Notable traits for DrainFilter&amp;lt;'_, K, F&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2385be6e59fcef027951939bd378844cfa66cc4e" translate="yes" xml:space="preserve">
          <source>Notable traits for DrainFilter&amp;lt;'_, K, V, F&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="830f76c13044b7581905cb940dcf417e291d507b" translate="yes" xml:space="preserve">
          <source>Notable traits for DrainFilter&amp;lt;'_, T, F&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="304a6f343623430e09952339820090a6a8ba207e" translate="yes" xml:space="preserve">
          <source>Notable traits for DrainSorted&amp;lt;'_, T&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ac510d8e5089a326a2eb18feaee192a8adc0a137" translate="yes" xml:space="preserve">
          <source>Notable traits for Empty&amp;lt;T&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f3573695011deffd446de805daa200465e4ba04e" translate="yes" xml:space="preserve">
          <source>Notable traits for EncodeUtf16&amp;lt;'a&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e43fb28465d3894c2c42629f7fcac035e497cddd" translate="yes" xml:space="preserve">
          <source>Notable traits for EncodeWide&amp;lt;'a&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f89d4ae7f36a369049ddb4e7f3c8216010d3419d" translate="yes" xml:space="preserve">
          <source>Notable traits for Enumerate&amp;lt;I&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="df3db15928fc8d95aa51b8ec8568ffb5eabd15ff" translate="yes" xml:space="preserve">
          <source>Notable traits for EscapeDebug</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4c8ea88e979fa0c14d5d9cdbbd9d161b88b39045" translate="yes" xml:space="preserve">
          <source>Notable traits for EscapeDebug&amp;lt;'a&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="098a62e8683b0a13c0908e723720ee9c6810fedc" translate="yes" xml:space="preserve">
          <source>Notable traits for EscapeDefault</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1190462f1941cfb82dacec2de3ad04f7c9541203" translate="yes" xml:space="preserve">
          <source>Notable traits for EscapeDefault&amp;lt;'a&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ac599426120513bc277a63e47f672a5774b2c3d2" translate="yes" xml:space="preserve">
          <source>Notable traits for EscapeUnicode</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8024ca6f7e281ae2b2c49427386c5bf3564e02b9" translate="yes" xml:space="preserve">
          <source>Notable traits for EscapeUnicode&amp;lt;'a&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="09f685f90ec7f2abae36adf82f3e91f906928c37" translate="yes" xml:space="preserve">
          <source>Notable traits for File</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c974ed1aff38ed15c92fd39174e5a139046f0e34" translate="yes" xml:space="preserve">
          <source>Notable traits for Filter&amp;lt;I, P&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0176f9f85bf66bf907565450c64018c10c6cb978" translate="yes" xml:space="preserve">
          <source>Notable traits for FilterMap&amp;lt;I, F&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6bcdf064b818fb335120a0a13f2aad0c77345394" translate="yes" xml:space="preserve">
          <source>Notable traits for FlatMap&amp;lt;I, U, F&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1073550fde927671db722e47a13215279dc8806e" translate="yes" xml:space="preserve">
          <source>Notable traits for Flatten&amp;lt;I&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c3bb84e817e2df7af3ebf4adf8af3eae4361fbed" translate="yes" xml:space="preserve">
          <source>Notable traits for FromFn&amp;lt;F&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dab5351ad5f13713d82cab1221966fc7e75e9d94" translate="yes" xml:space="preserve">
          <source>Notable traits for Fuse&amp;lt;I&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="98b96e5efed1886b8e4bb59473b0f591f83aa189" translate="yes" xml:space="preserve">
          <source>Notable traits for Incoming&amp;lt;'a&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="69f0a4d3c756c850a0608c731279e5ac5c5ca49c" translate="yes" xml:space="preserve">
          <source>Notable traits for Inspect&amp;lt;I, F&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9f01a7c49836f7656e92d546f4185d1aefd357b8" translate="yes" xml:space="preserve">
          <source>Notable traits for Intersection&amp;lt;'a, T&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="20846e5c04b975b9bee849726ac0019c4f7b197d" translate="yes" xml:space="preserve">
          <source>Notable traits for Intersection&amp;lt;'a, T, S&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4917b9b001be9af84b1ad65c2d45310be0927721" translate="yes" xml:space="preserve">
          <source>Notable traits for IntoIter&amp;lt;A&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1104b62a63a5899e12eeb37d5678f9df68b057f0" translate="yes" xml:space="preserve">
          <source>Notable traits for IntoIter&amp;lt;K&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1b19c0d62a927883656bbd747f944a9ce1ae1de8" translate="yes" xml:space="preserve">
          <source>Notable traits for IntoIter&amp;lt;K, V&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5480768feb968b4174c1ae6ddf0dcc0e359f66ea" translate="yes" xml:space="preserve">
          <source>Notable traits for IntoIter&amp;lt;T&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3722bff12524c5b2d2d05cda59ba23d190ce3bfe" translate="yes" xml:space="preserve">
          <source>Notable traits for IntoIter&amp;lt;T, N&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8c2d3479bd2162e028960fa1d767fb2598f2f013" translate="yes" xml:space="preserve">
          <source>Notable traits for IntoIterSorted&amp;lt;T&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5ad4c5fe36c7d254f4808dae95121b2bb0b54801" translate="yes" xml:space="preserve">
          <source>Notable traits for IntoKeys&amp;lt;K, V&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="da31fc5c3cf56bab8c815369c2547a6911c833ba" translate="yes" xml:space="preserve">
          <source>Notable traits for IntoValues&amp;lt;K, V&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="80895d49113bdb3cb86cfb4506bc6ebd9cd990ad" translate="yes" xml:space="preserve">
          <source>Notable traits for Iter&amp;lt;'a&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d36ae4aeecd3653ca01fd74624e132869451eaf4" translate="yes" xml:space="preserve">
          <source>Notable traits for Iter&amp;lt;'a, A&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6d5c2ab959e5631dfaa0a10009806935497b8c43" translate="yes" xml:space="preserve">
          <source>Notable traits for Iter&amp;lt;'a, K&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6b3bc881963ccadbe18c6746d9bbee3015f5abf1" translate="yes" xml:space="preserve">
          <source>Notable traits for Iter&amp;lt;'a, K, V&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="00b543ae90963f05f96f4dd377980b1713d5159b" translate="yes" xml:space="preserve">
          <source>Notable traits for Iter&amp;lt;'a, T&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2b070bfb60176569efaa6c1a4d324dc380b18332" translate="yes" xml:space="preserve">
          <source>Notable traits for IterMut&amp;lt;'a, A&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c915012f89d1a99c63f545f2ebffcef019fb4f2d" translate="yes" xml:space="preserve">
          <source>Notable traits for IterMut&amp;lt;'a, K, V&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c7bfb298a8fa281946d7580611e184273523102f" translate="yes" xml:space="preserve">
          <source>Notable traits for IterMut&amp;lt;'a, T&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9e5811113cb7885323072cf61d5667a2b362dde2" translate="yes" xml:space="preserve">
          <source>Notable traits for Keys&amp;lt;'a, K, V&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="99c669d87d53a9eb6f676c0605066d307d9e6144" translate="yes" xml:space="preserve">
          <source>Notable traits for LineWriter&amp;lt;W&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6228658663ccbd3f41a5107629651e3c2771c99b" translate="yes" xml:space="preserve">
          <source>Notable traits for Lines&amp;lt;'a&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9213f8c618faa944ed6f22753d61edcc9d4ecdf2" translate="yes" xml:space="preserve">
          <source>Notable traits for Lines&amp;lt;B&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f6a5e49b0d0ee24c230282dd8f08580ff2f4ffb7" translate="yes" xml:space="preserve">
          <source>Notable traits for LinesAny&amp;lt;'a&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b99d80dc293caeb573cce051072ed906b6f15c5e" translate="yes" xml:space="preserve">
          <source>Notable traits for Map&amp;lt;I, F&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="172f87d0793ddf7da88be709a2311741cbd4b363" translate="yes" xml:space="preserve">
          <source>Notable traits for MapWhile&amp;lt;I, P&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="64729c888eeabe7cf12e1842e01480ed82b337ff" translate="yes" xml:space="preserve">
          <source>Notable traits for MatchIndices&amp;lt;'a, P&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b0d2b75e66e9e050b8169e3218de5ee791479721" translate="yes" xml:space="preserve">
          <source>Notable traits for Matches&amp;lt;'a, P&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="25ae519d64a28536d279768ad769256299621686" translate="yes" xml:space="preserve">
          <source>Notable traits for Once&amp;lt;T&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f8b307122c682ff77253a547508bfd2ee6faae04" translate="yes" xml:space="preserve">
          <source>Notable traits for OnceWith&amp;lt;F&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ed7b3a034e2d225ecfcc33f32f2f83f5b7d3d90b" translate="yes" xml:space="preserve">
          <source>Notable traits for Peekable&amp;lt;I&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6b8f81a496f377f17826b87b054d41b9d3f6cb71" translate="yes" xml:space="preserve">
          <source>Notable traits for Pending&amp;lt;T&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="74be0fa24b2449c87cf0033da73af99abb038226" translate="yes" xml:space="preserve">
          <source>Notable traits for Pin&amp;lt;P&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cf6ce59e954214088a5388d7abe14ace680afd30" translate="yes" xml:space="preserve">
          <source>Notable traits for RChunks&amp;lt;'a, T&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ff0549023d3e07da72d7eaec8fd8c7d3b1bfc8bb" translate="yes" xml:space="preserve">
          <source>Notable traits for RChunksExact&amp;lt;'a, T&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1891d732a25cb1a2d6470e2f1e61d90d79932069" translate="yes" xml:space="preserve">
          <source>Notable traits for RChunksExactMut&amp;lt;'a, T&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="272511b477fb6f4d7e66f455a8927b6aa68fd2ce" translate="yes" xml:space="preserve">
          <source>Notable traits for RChunksMut&amp;lt;'a, T&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4bc67e64b7ea3bfd3fc10ece7ec2491353da6e9d" translate="yes" xml:space="preserve">
          <source>Notable traits for RMatchIndices&amp;lt;'a, P&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ae7b6da19243fedcfa70bfd82f4cf8717d322f80" translate="yes" xml:space="preserve">
          <source>Notable traits for RMatches&amp;lt;'a, P&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3aa09ee60858aa32b9e0f1689cc4891931af0d24" translate="yes" xml:space="preserve">
          <source>Notable traits for RSplit&amp;lt;'a, P&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a0fe88a7318fe9810ff3810f98339d43244a6877" translate="yes" xml:space="preserve">
          <source>Notable traits for RSplit&amp;lt;'a, T, P&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="70be06d4120000b8b8b94371aec7e2580c6b381b" translate="yes" xml:space="preserve">
          <source>Notable traits for RSplitMut&amp;lt;'a, T, P&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7b31a8c9c6cb2046e7ec9e536ce72d0609e4c5c4" translate="yes" xml:space="preserve">
          <source>Notable traits for RSplitN&amp;lt;'a, P&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="19040f24ad7c9687e49caaeab46d848dc263b5ea" translate="yes" xml:space="preserve">
          <source>Notable traits for RSplitN&amp;lt;'a, T, P&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1988fde6a09875d4b04a7b9e55d197b9d9a90765" translate="yes" xml:space="preserve">
          <source>Notable traits for RSplitNMut&amp;lt;'a, T, P&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="907edfb9c1524174e07ccbc24ecb37a8cbb06d65" translate="yes" xml:space="preserve">
          <source>Notable traits for RSplitTerminator&amp;lt;'a, P&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9198631706611f9de2afa1f3a5e4389cd7cb8e7a" translate="yes" xml:space="preserve">
          <source>Notable traits for Range&amp;lt;'a, K, V&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3d3fe2b23ebaced9425f58daf076814b8c0291d9" translate="yes" xml:space="preserve">
          <source>Notable traits for Range&amp;lt;'a, T&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0614892f74433d616b37d2ae04d67fe7f14ad105" translate="yes" xml:space="preserve">
          <source>Notable traits for Range&amp;lt;A&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="beebcbfc8cc5133e5166a3028ebbd90ecdb7055f" translate="yes" xml:space="preserve">
          <source>Notable traits for RangeFrom&amp;lt;A&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f744d9434a4d9b5c37c99f5c97d2b2cc90b13077" translate="yes" xml:space="preserve">
          <source>Notable traits for RangeInclusive&amp;lt;A&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0a4e925f094b7a69f246e42e8b50c5128f8129c7" translate="yes" xml:space="preserve">
          <source>Notable traits for RangeMut&amp;lt;'a, K, V&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="abd184a89bc10bea6baedba72d627209bea1056f" translate="yes" xml:space="preserve">
          <source>Notable traits for Ready&amp;lt;T&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="64702f1280547e388d11ff5ae890bb729b733d36" translate="yes" xml:space="preserve">
          <source>Notable traits for Repeat&amp;lt;A&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="49a3b2a3770cc905b8da25f64e140b4ab80c6ffe" translate="yes" xml:space="preserve">
          <source>Notable traits for RepeatWith&amp;lt;F&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b0ad194cda463ad2c6dd1506daf0367114be5c8e" translate="yes" xml:space="preserve">
          <source>Notable traits for Rev&amp;lt;I&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1ff8f63be235b7ea2055383c2e9b72b84c7bd07e" translate="yes" xml:space="preserve">
          <source>Notable traits for Scan&amp;lt;I, St, F&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="985d073dbfe88a46f9a5d9a064d7c96c1a9ddbdb" translate="yes" xml:space="preserve">
          <source>Notable traits for Skip&amp;lt;I&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4f0eaba444b8b7b51819626fe7d8a57f993cdf9a" translate="yes" xml:space="preserve">
          <source>Notable traits for SkipWhile&amp;lt;I, P&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ca8f82912aa693cda641dbb9a8f2619f7e15ddea" translate="yes" xml:space="preserve">
          <source>Notable traits for Splice&amp;lt;'_, I&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ef399e09acd6419098e7cfcabf45df6744dbfbc6" translate="yes" xml:space="preserve">
          <source>Notable traits for Split&amp;lt;'a, P&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e1f967c2a861c03dbdc5cf356551e97bb60b084f" translate="yes" xml:space="preserve">
          <source>Notable traits for Split&amp;lt;'a, T, P&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e39a8c3f513e0738a443ac406858d3b7bc026953" translate="yes" xml:space="preserve">
          <source>Notable traits for Split&amp;lt;B&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d1d5f710d040b4a11a5d716baa68dcf2d617217b" translate="yes" xml:space="preserve">
          <source>Notable traits for SplitAsciiWhitespace&amp;lt;'a&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fb7865e840a56b3e0895b5ec1bdbc829b951351d" translate="yes" xml:space="preserve">
          <source>Notable traits for SplitInclusive&amp;lt;'a, T, P&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9818f4f1fdfe2d933ac6655c5c4953e8aff5a7e1" translate="yes" xml:space="preserve">
          <source>Notable traits for SplitInclusiveMut&amp;lt;'a, T, P&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0838dd01ca950ce33cd2058b8d0ff4fd43821113" translate="yes" xml:space="preserve">
          <source>Notable traits for SplitMut&amp;lt;'a, T, P&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e5880f295f9b58cf5125e602e8fae3c01c02bfbe" translate="yes" xml:space="preserve">
          <source>Notable traits for SplitN&amp;lt;'a, P&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7599a2d009c0938be30293d468e1a75ce65377d5" translate="yes" xml:space="preserve">
          <source>Notable traits for SplitN&amp;lt;'a, T, P&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="37e0cb911750681c09ba0b190a9557e42adc2590" translate="yes" xml:space="preserve">
          <source>Notable traits for SplitNMut&amp;lt;'a, T, P&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f48dc2915683e916503c8dcf3e59f491126656bf" translate="yes" xml:space="preserve">
          <source>Notable traits for SplitTerminator&amp;lt;'a, P&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d707147c6fab5cc551e32ce5467c609e374e4f50" translate="yes" xml:space="preserve">
          <source>Notable traits for SplitWhitespace&amp;lt;'a&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="437caeb56851568308dca5cb78609789356f0853" translate="yes" xml:space="preserve">
          <source>Notable traits for StderrLock&amp;lt;'_&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="48c194fa1f0bd2541f390bd24896165b0c23c7e5" translate="yes" xml:space="preserve">
          <source>Notable traits for StdinLock&amp;lt;'_&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ee33f3797cb0a601933ebede73fe50f827c75b6e" translate="yes" xml:space="preserve">
          <source>Notable traits for StdoutLock&amp;lt;'_&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3e0ae991bfa5ac7c9c453dec86d28b7d72d47073" translate="yes" xml:space="preserve">
          <source>Notable traits for StepBy&amp;lt;I&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="83f5fe0a710de90155479f39d5f77c153488c0a5" translate="yes" xml:space="preserve">
          <source>Notable traits for Successors&amp;lt;T, F&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="647ebf3b1fc10e80b4ce476f35a75fa114a5fab1" translate="yes" xml:space="preserve">
          <source>Notable traits for SymmetricDifference&amp;lt;'a, T&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5e0deb017937ef51088c94bb895f3902110ffe16" translate="yes" xml:space="preserve">
          <source>Notable traits for SymmetricDifference&amp;lt;'a, T, S&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6b271862886a9e625b5ac46fc4e49bcce91334f9" translate="yes" xml:space="preserve">
          <source>Notable traits for Take&amp;lt;I&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8d1491004df1c3cd73af985e7889ffe06072d374" translate="yes" xml:space="preserve">
          <source>Notable traits for Take&amp;lt;T&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8c484c47892ef31d80e9449405b6a45f7812a953" translate="yes" xml:space="preserve">
          <source>Notable traits for TakeWhile&amp;lt;I, P&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ce43b5e8ae4c3d3abba449747c3b74da4e5cf5b2" translate="yes" xml:space="preserve">
          <source>Notable traits for TcpStream</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0e1590902cedb9997418d686f3b41f48a7faa5a8" translate="yes" xml:space="preserve">
          <source>Notable traits for ToLowercase</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="71cea9ba6a0245158a668390fdcdb390b3ee3a95" translate="yes" xml:space="preserve">
          <source>Notable traits for ToUppercase</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2bc316517c095ef6246876fb36dafafef8842df0" translate="yes" xml:space="preserve">
          <source>Notable traits for TryIter&amp;lt;'a, T&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="36cd3ac7d99db311332b377e21251e4fba5322ec" translate="yes" xml:space="preserve">
          <source>Notable traits for Union&amp;lt;'a, T&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a1623bf8aee40498694e04160abcc7cc94e51160" translate="yes" xml:space="preserve">
          <source>Notable traits for Union&amp;lt;'a, T, S&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="41fbaa40eb7f00c2be283feaa1fbb38e29701e83" translate="yes" xml:space="preserve">
          <source>Notable traits for UnixStream</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9c50d1662883c24d433db05a688c0aa44526ac2e" translate="yes" xml:space="preserve">
          <source>Notable traits for Values&amp;lt;'a, K, V&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="58c872469ad3d287548b76d4b848eba9a4a4c7d9" translate="yes" xml:space="preserve">
          <source>Notable traits for ValuesMut&amp;lt;'a, K, V&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="34aac67be859564d9e8c0c60e00e2a029f471028" translate="yes" xml:space="preserve">
          <source>Notable traits for Vec&amp;lt;u8&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3f1ce7df300d5a68156470029c1320d12946032a" translate="yes" xml:space="preserve">
          <source>Notable traits for Windows&amp;lt;'a, T&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a8ed148e4a8689fea1373b25b6f60ce6eb17047c" translate="yes" xml:space="preserve">
          <source>Notable traits for Zip&amp;lt;A, B&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f8f7449873c705105af159faa9949fb17717e319" translate="yes" xml:space="preserve">
          <source>Notably this function ignores the &lt;code&gt;flag&lt;/code&gt; parameters.</source>
          <target state="translated">Примечательно, что эта функция игнорирует параметры &lt;code&gt;flag&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0a8a9d000182248a3513e5a205741807831d1022" translate="yes" xml:space="preserve">
          <source>Notably: &lt;a href=&quot;variables&quot;&gt;variables&lt;/a&gt;, function parameters, &lt;a href=&quot;items/constant-items&quot;&gt;const&lt;/a&gt; and &lt;a href=&quot;items/static-items&quot;&gt;static&lt;/a&gt; items must be &lt;code&gt;Sized&lt;/code&gt;.</source>
          <target state="translated">В частности: &lt;a href=&quot;variables&quot;&gt;переменные&lt;/a&gt; , параметры функций, &lt;a href=&quot;items/constant-items&quot;&gt;константные&lt;/a&gt; и &lt;a href=&quot;items/static-items&quot;&gt;статические&lt;/a&gt; элементы должны иметь &lt;code&gt;Sized&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9f3163ffda0d3418a1866865fdb1ef76cb2dbf4b" translate="yes" xml:space="preserve">
          <source>Notation</source>
          <target state="translated">Notation</target>
        </trans-unit>
        <trans-unit id="2c924e3088204ee77ba681f72be3444357932fca" translate="yes" xml:space="preserve">
          <source>Note</source>
          <target state="translated">Note</target>
        </trans-unit>
        <trans-unit id="c3fe4ddff5db29b0cb1f0eb2b355940acc3e474c" translate="yes" xml:space="preserve">
          <source>Note 1: The element range is removed even if the iterator is not consumed until the end.</source>
          <target state="translated">Примечание 1:Диапазон элементов снимается,даже если итератор потребляется не до конца.</target>
        </trans-unit>
        <trans-unit id="73bad292ab0326c274afe69e790430a32b7dd7b6" translate="yes" xml:space="preserve">
          <source>Note 1: The element range is removed even if the iterator is only partially consumed or not consumed at all.</source>
          <target state="translated">Примечание 1:Диапазон элементов снимается,даже если итератор потребляется только частично или не потребляется вообще.</target>
        </trans-unit>
        <trans-unit id="375f6bc156b4954ecc954926534e181389ad6af2" translate="yes" xml:space="preserve">
          <source>Note 1: The first element of the iterator will always be returned, regardless of the step given.</source>
          <target state="translated">Примечание 1:Первый элемент итератора всегда возвращается независимо от заданного шага.</target>
        </trans-unit>
        <trans-unit id="0b81032a73d39d946d8d288ed04acdd88cf53ecf" translate="yes" xml:space="preserve">
          <source>Note 2: It is unspecified how many elements are removed from the deque, if the &lt;code&gt;Drain&lt;/code&gt; value is not dropped, but the borrow it holds expires (e.g., due to &lt;code&gt;mem::forget&lt;/code&gt;).</source>
          <target state="translated">Примечание 2: не указано, сколько элементов удаляется из двухсторонней очереди, если значение &lt;code&gt;Drain&lt;/code&gt; не сбрасывается, но срок заимствования истекает (например, из-за &lt;code&gt;mem::forget&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="2ad2f022b2009c4ce2fc1713a74b64ee404e87d1" translate="yes" xml:space="preserve">
          <source>Note 2: It is unspecified how many elements are removed from the vector if the &lt;code&gt;Drain&lt;/code&gt; value is leaked.</source>
          <target state="translated">Примечание 2: не указано, сколько элементов удаляется из вектора, если значение &lt;code&gt;Drain&lt;/code&gt; утекло.</target>
        </trans-unit>
        <trans-unit id="506d02500f5463906be1bc26ef13102642229ab6" translate="yes" xml:space="preserve">
          <source>Note 2: The time at which ignored elements are pulled is not fixed. &lt;code&gt;StepBy&lt;/code&gt; behaves like the sequence &lt;code&gt;next(), nth(step-1), nth(step-1), &amp;hellip;&lt;/code&gt;, but is also free to behave like the sequence &lt;code&gt;advance_n_and_return_first(step), advance_n_and_return_first(step), &amp;hellip;&lt;/code&gt; Which way is used may change for some iterators for performance reasons. The second way will advance the iterator earlier and may consume more items.</source>
          <target state="translated">Примечание 2: время вытягивания игнорируемых элементов не фиксировано. &lt;code&gt;StepBy&lt;/code&gt; ведет себя как последовательность &lt;code&gt;next(), nth(step-1), nth(step-1), &amp;hellip;&lt;/code&gt; , но также может вести себя как последовательность &lt;code&gt;advance_n_and_return_first(step), advance_n_and_return_first(step), &amp;hellip;&lt;/code&gt; Какой путь используется, может изменить некоторые итераторы по соображениям производительности. Второй способ продвинет итератор раньше и может потреблять больше элементов.</target>
        </trans-unit>
        <trans-unit id="3276127b29ca84c8dd6a3e6919af65a48a707afa" translate="yes" xml:space="preserve">
          <source>Note also that in Listing 19-1 and 19-3, we created &lt;code&gt;*const i32&lt;/code&gt; and &lt;code&gt;*mut i32&lt;/code&gt; raw pointers that both pointed to the same memory location, where &lt;code&gt;num&lt;/code&gt; is stored. If we instead tried to create an immutable and a mutable reference to &lt;code&gt;num&lt;/code&gt;, the code would not have compiled because Rust&amp;rsquo;s ownership rules don&amp;rsquo;t allow a mutable reference at the same time as any immutable references. With raw pointers, we can create a mutable pointer and an immutable pointer to the same location and change data through the mutable pointer, potentially creating a data race. Be careful!</source>
          <target state="translated">Также обратите внимание, что в листингах 19-1 и 19-3 мы создали необработанные указатели &lt;code&gt;*const i32&lt;/code&gt; и &lt;code&gt;*mut i32&lt;/code&gt; , которые оба указывают на одну и ту же ячейку памяти, где хранится &lt;code&gt;num&lt;/code&gt; . Если бы мы вместо этого попытались создать неизменяемую и изменяемую ссылку на &lt;code&gt;num&lt;/code&gt; , код не был бы скомпилирован, потому что правила владения Rust не допускают изменяемую ссылку одновременно с любыми неизменяемыми ссылками. С помощью необработанных указателей мы можем создать изменяемый указатель и неизменяемый указатель на одно и то же место и изменять данные с помощью изменяемого указателя, потенциально создавая гонку данных. Быть осторожен!</target>
        </trans-unit>
        <trans-unit id="6de37aeaf259b01294052b110f1c5546480ac1df" translate="yes" xml:space="preserve">
          <source>Note also that in the context of this formalism, the term &quot;token&quot; generally &lt;em&gt;includes&lt;/em&gt; simple NTs.</source>
          <target state="translated">Также обратите внимание, что в контексте этого формализма термин &amp;laquo;токен&amp;raquo; обычно &lt;em&gt;включает&lt;/em&gt; простые NT.</target>
        </trans-unit>
        <trans-unit id="ddbcd5d0f2ca8f557f88753b63844e194aa420bc" translate="yes" xml:space="preserve">
          <source>Note however that:</source>
          <target state="translated">Обратите внимание,однако:</target>
        </trans-unit>
        <trans-unit id="ac8dc1e3e610d665d4339a3068108ed3e4e3d7f2" translate="yes" xml:space="preserve">
          <source>Note however, that &lt;code&gt;black_box&lt;/code&gt; is only (and can only be) provided on a &quot;best-effort&quot; basis. The extent to which it can block optimisations may vary depending upon the platform and code-gen backend used. Programs cannot rely on &lt;code&gt;black_box&lt;/code&gt; for &lt;em&gt;correctness&lt;/em&gt; in any way.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="09b6433b842ad661442a50c48f705bbda92a3877" translate="yes" xml:space="preserve">
          <source>Note on locale</source>
          <target state="translated">Примечание на месте</target>
        </trans-unit>
        <trans-unit id="6dac41f357fcb628dff23b9354a4451a8f0457e9" translate="yes" xml:space="preserve">
          <source>Note that &amp;amp;Any is limited to testing whether a value is of a specified concrete type, and cannot be used to test whether a type implements a trait.</source>
          <target state="translated">Обратите внимание, что &amp;amp; Any ограничено проверкой того, принадлежит ли значение указанному конкретному типу, и не может использоваться для проверки того, реализует ли тип признак.</target>
        </trans-unit>
        <trans-unit id="57e530ae79447e200db1291082ac88c201431874" translate="yes" xml:space="preserve">
          <source>Note that &lt;a href=&quot;../ptr/fn.drop_in_place&quot;&gt;&lt;code&gt;drop_in_place&lt;/code&gt;&lt;/a&gt; already performs this check, so if your workload can be reduced to some small number of &lt;a href=&quot;../ptr/fn.drop_in_place&quot;&gt;&lt;code&gt;drop_in_place&lt;/code&gt;&lt;/a&gt; calls, using this is unnecessary. In particular note that you can &lt;a href=&quot;../ptr/fn.drop_in_place&quot;&gt;&lt;code&gt;drop_in_place&lt;/code&gt;&lt;/a&gt; a slice, and that will do a single needs_drop check for all the values.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9bf762ffc91bdd3eff38c069a4a949827e702fcc" translate="yes" xml:space="preserve">
          <source>Note that &lt;a href=&quot;../sync/mpsc/index&quot;&gt;&lt;code&gt;channel&lt;/code&gt;&lt;/a&gt;s for example are implemented using this primitive. Indeed when you call &lt;code&gt;send&lt;/code&gt; or &lt;code&gt;recv&lt;/code&gt;, which are blocking, they will yield if the channel is not available.</source>
          <target state="translated">Обратите внимание, что, например , &lt;a href=&quot;../sync/mpsc/index&quot;&gt; &lt;code&gt;channel&lt;/code&gt; &lt;/a&gt; реализованы с использованием этого примитива. Действительно, когда вы вызываете &lt;code&gt;send&lt;/code&gt; или &lt;code&gt;recv&lt;/code&gt; , которые блокируются, они будут уступать, если канал недоступен.</target>
        </trans-unit>
        <trans-unit id="b25a38a73d437340101dfed415d44fe9cc8bfeca" translate="yes" xml:space="preserve">
          <source>Note that &lt;a href=&quot;struct.childstderr&quot;&gt;&lt;code&gt;ChildStderr&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;struct.childstdout&quot;&gt;&lt;code&gt;ChildStdout&lt;/code&gt;&lt;/a&gt; implement &lt;a href=&quot;../io/trait.read&quot;&gt;&lt;code&gt;Read&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;struct.childstdin&quot;&gt;&lt;code&gt;ChildStdin&lt;/code&gt;&lt;/a&gt; implements &lt;a href=&quot;../io/trait.write&quot;&gt;&lt;code&gt;Write&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">Обратите внимание, что &lt;a href=&quot;struct.childstderr&quot;&gt; &lt;code&gt;ChildStderr&lt;/code&gt; &lt;/a&gt; и &lt;a href=&quot;struct.childstdout&quot;&gt; &lt;code&gt;ChildStdout&lt;/code&gt; &lt;/a&gt; реализуют &lt;a href=&quot;../io/trait.read&quot;&gt; &lt;code&gt;Read&lt;/code&gt; ,&lt;/a&gt; а &lt;a href=&quot;struct.childstdin&quot;&gt; &lt;code&gt;ChildStdin&lt;/code&gt; &lt;/a&gt; реализует &lt;a href=&quot;../io/trait.write&quot;&gt; &lt;code&gt;Write&lt;/code&gt; &lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="cb54b0f71bbcbfc437ecfe318e92da06296ef44e" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;&amp;amp;dyn Any&lt;/code&gt; is limited to testing whether a value is of a specified concrete type, and cannot be used to test whether a type implements a trait.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="40772281e6e9e65973c825aa35cf8a449645ff88" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;(T,)&lt;/code&gt; always denotes the type of a 1-tuple containing an element of type &lt;code&gt;T&lt;/code&gt;. The comma is necessary for syntactic disambiguation.</source>
          <target state="translated">Следует отметить , что &lt;code&gt;(T,)&lt;/code&gt; всегда обозначает тип 1-кортежа , содержащего элемент типа &lt;code&gt;T&lt;/code&gt; . Запятая необходима для устранения синтаксической неоднозначности.</target>
        </trans-unit>
        <trans-unit id="83c24ee2be7e8854e259c9b6dfc4dd85416ed0a7" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;CoerceUnsized&lt;/code&gt; is mainly used by smart pointers like &lt;code&gt;Box&lt;/code&gt;, &lt;code&gt;Rc&lt;/code&gt; and &lt;code&gt;Arc&lt;/code&gt; to be able to mark that they can coerce unsized types that they are pointing at.</source>
          <target state="translated">Обратите внимание, что &lt;code&gt;CoerceUnsized&lt;/code&gt; в основном используется интеллектуальными указателями, такими как &lt;code&gt;Box&lt;/code&gt; , &lt;code&gt;Rc&lt;/code&gt; и &lt;code&gt;Arc&lt;/code&gt; , чтобы иметь возможность отмечать, что они могут приводить к безразмерным типам, на которые они указывают.</target>
        </trans-unit>
        <trans-unit id="67f3e9957b8f2c4f460edc12ad2bfe3cbc26e031" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; is only for use in single-threaded scenarios. When we discuss concurrency in Chapter 16, we&amp;rsquo;ll cover how to do reference counting in multithreaded programs.</source>
          <target state="translated">Обратите внимание, что &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; предназначен только для использования в однопоточных сценариях. Обсуждая параллелизм в главе 16, мы рассмотрим, как выполнять подсчет ссылок в многопоточных программах.</target>
        </trans-unit>
        <trans-unit id="5d99e9077b96e1db0f895f5becbb122b93be4c0b" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;Rhs&lt;/code&gt; is &lt;code&gt;Self&lt;/code&gt; by default, but this is not mandatory.</source>
          <target state="translated">Обратите внимание, что по умолчанию &lt;code&gt;Rhs&lt;/code&gt; имеет значение &lt;code&gt;Self&lt;/code&gt; , но это не обязательно.</target>
        </trans-unit>
        <trans-unit id="2200d088885b3a3d42f0732955184ac9e811ecb3" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;Rhs&lt;/code&gt; is &lt;code&gt;Self&lt;/code&gt; by default, but this is not mandatory. For example, &lt;a href=&quot;../time/struct.systemtime&quot;&gt;&lt;code&gt;std::time::SystemTime&lt;/code&gt;&lt;/a&gt; implements &lt;code&gt;Add&amp;lt;Duration&amp;gt;&lt;/code&gt;, which permits operations of the form &lt;code&gt;SystemTime = SystemTime + Duration&lt;/code&gt;.</source>
          <target state="translated">Обратите внимание, что по умолчанию &lt;code&gt;Rhs&lt;/code&gt; имеет значение &lt;code&gt;Self&lt;/code&gt; , но это не обязательно. Например, &lt;a href=&quot;../time/struct.systemtime&quot;&gt; &lt;code&gt;std::time::SystemTime&lt;/code&gt; &lt;/a&gt; реализует &lt;code&gt;Add&amp;lt;Duration&amp;gt;&lt;/code&gt; , который разрешает операции формы &lt;code&gt;SystemTime = SystemTime + Duration&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6326c7ae251a36c65278ccf6246055e8e4c505f9" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;Rhs&lt;/code&gt; is &lt;code&gt;Self&lt;/code&gt; by default, but this is not mandatory. For example, &lt;a href=&quot;../time/struct.systemtime&quot;&gt;&lt;code&gt;std::time::SystemTime&lt;/code&gt;&lt;/a&gt; implements &lt;code&gt;Sub&amp;lt;Duration&amp;gt;&lt;/code&gt;, which permits operations of the form &lt;code&gt;SystemTime = SystemTime - Duration&lt;/code&gt;.</source>
          <target state="translated">Обратите внимание, что по умолчанию &lt;code&gt;Rhs&lt;/code&gt; имеет значение &lt;code&gt;Self&lt;/code&gt; , но это не обязательно. Например, &lt;a href=&quot;../time/struct.systemtime&quot;&gt; &lt;code&gt;std::time::SystemTime&lt;/code&gt; &lt;/a&gt; реализует &lt;code&gt;Sub&amp;lt;Duration&amp;gt;&lt;/code&gt; , который разрешает операции формы &lt;code&gt;SystemTime = SystemTime - Duration&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5d4b833ed91bb546ce7e87843871f8e854946fd3" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;T&lt;/code&gt; does not necessarily implement &lt;a href=&quot;../clone/trait.clone&quot;&gt;&lt;code&gt;Clone&lt;/code&gt;&lt;/a&gt;, so it can't even clone and reset &lt;code&gt;self.buf&lt;/code&gt;. But &lt;code&gt;replace&lt;/code&gt; can be used to disassociate the original value of &lt;code&gt;self.buf&lt;/code&gt; from &lt;code&gt;self&lt;/code&gt;, allowing it to be returned:</source>
          <target state="translated">Обратите внимание, что &lt;code&gt;T&lt;/code&gt; не обязательно реализует &lt;a href=&quot;../clone/trait.clone&quot;&gt; &lt;code&gt;Clone&lt;/code&gt; &lt;/a&gt; , поэтому он не может даже клонировать и сбрасывать &lt;code&gt;self.buf&lt;/code&gt; . Но &lt;code&gt;replace&lt;/code&gt; можно использовать, чтобы отделить исходное значение &lt;code&gt;self.buf&lt;/code&gt; от &lt;code&gt;self&lt;/code&gt; , позволяя вернуть его:</target>
        </trans-unit>
        <trans-unit id="ce9900f79b589dea762e357b371f9431cba99bba" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;T&lt;/code&gt; does not necessarily implement &lt;a href=&quot;../clone/trait.clone&quot;&gt;&lt;code&gt;Clone&lt;/code&gt;&lt;/a&gt;, so it can't even clone and reset &lt;code&gt;self.buf&lt;/code&gt;. But &lt;code&gt;take&lt;/code&gt; can be used to disassociate the original value of &lt;code&gt;self.buf&lt;/code&gt; from &lt;code&gt;self&lt;/code&gt;, allowing it to be returned:</source>
          <target state="translated">Обратите внимание, что &lt;code&gt;T&lt;/code&gt; не обязательно реализует &lt;a href=&quot;../clone/trait.clone&quot;&gt; &lt;code&gt;Clone&lt;/code&gt; &lt;/a&gt; , поэтому он не может даже клонировать и сбрасывать &lt;code&gt;self.buf&lt;/code&gt; . Но &lt;code&gt;take&lt;/code&gt; можно использовать, чтобы отделить исходное значение &lt;code&gt;self.buf&lt;/code&gt; от &lt;code&gt;self&lt;/code&gt; , позволяя вернуть его:</target>
        </trans-unit>
        <trans-unit id="ac00b6421a53f1cb355d37f763df7d0ab6908815" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;T&lt;/code&gt; does not necessarily implement &lt;a href=&quot;../clone/trait.clone&quot;&gt;&lt;code&gt;Clone&lt;/code&gt;&lt;/a&gt;, so we can't even clone &lt;code&gt;self.buf[i]&lt;/code&gt; to avoid the move. But &lt;code&gt;replace&lt;/code&gt; can be used to disassociate the original value at that index from &lt;code&gt;self&lt;/code&gt;, allowing it to be returned:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a7210db58c23cf5014deeb9448717499ab480d12" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;a &amp;lt;= b&lt;/code&gt; does &lt;em&gt;not&lt;/em&gt; imply &lt;code&gt;steps_between(&amp;amp;a, &amp;amp;b) != None&lt;/code&gt;; this is the case when it would require more than &lt;code&gt;usize::MAX&lt;/code&gt; steps to get to &lt;code&gt;b&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d217a13df9cefce26828e70c341f97e6fe273cac" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;drain_filter&lt;/code&gt; also lets you mutate every element in the filter closure, regardless of whether you choose to keep or remove it.</source>
          <target state="translated">Обратите внимание, что &lt;code&gt;drain_filter&lt;/code&gt; также позволяет вам изменять каждый элемент в закрытии фильтра, независимо от того, хотите ли вы оставить его или удалить.</target>
        </trans-unit>
        <trans-unit id="98dacb5f160d6bac2dc7474d61b47f1366bd10c0" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;drain_filter&lt;/code&gt; lets you mutate every element in the filter closure, regardless of whether you choose to keep or remove it.</source>
          <target state="translated">Обратите внимание, что &lt;code&gt;drain_filter&lt;/code&gt; позволяет вам изменять каждый элемент в закрытии фильтра, независимо от того, хотите ли вы оставить его или удалить.</target>
        </trans-unit>
        <trans-unit id="5c2297eec650eb177080c75bea870e375a760bc0" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;drain_filter&lt;/code&gt; lets you mutate every value in the filter closure, regardless of whether you choose to keep or remove it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="900305edc91345ae356f030caba1b6142733f009" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;iter.filter(f).next()&lt;/code&gt; is equivalent to &lt;code&gt;iter.find(f)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b7d482051dadae6146f69f3e213d64c34dd92558" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;iter.find(f)&lt;/code&gt; is equivalent to &lt;code&gt;iter.filter(f).next()&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3a3d7e41ea7c72a3b5b7e84cc631a89a603d2cd0" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;ptr::drop_in_place&lt;/code&gt; already performs this check, so if your workload can be reduced to some small number of drop_in_place calls, using this is unnecessary. In particular note that you can drop_in_place a slice, and that will do a single needs_drop check for all the values.</source>
          <target state="translated">Обратите внимание, что &lt;code&gt;ptr::drop_in_place&lt;/code&gt; уже выполняет эту проверку, поэтому, если ваша рабочая нагрузка может быть уменьшена до небольшого количества вызовов drop_in_place, в этом нет необходимости. В частности, обратите внимание, что вы можете drop_in_place срез, и это выполнит единственную проверку needs_drop для всех значений.</target>
        </trans-unit>
        <trans-unit id="437bc8fdeeb2ba2175b3e963d9a28d86c8a4a21f" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;query&lt;/code&gt; is now a &lt;code&gt;String&lt;/code&gt; rather than a string slice, because calling &lt;code&gt;to_lowercase&lt;/code&gt; creates new data rather than referencing existing data. Say the query is &lt;code&gt;&quot;rUsT&quot;&lt;/code&gt;, as an example: that string slice doesn&amp;rsquo;t contain a lowercase &lt;code&gt;u&lt;/code&gt; or &lt;code&gt;t&lt;/code&gt; for us to use, so we have to allocate a new &lt;code&gt;String&lt;/code&gt; containing &lt;code&gt;&quot;rust&quot;&lt;/code&gt;. When we pass &lt;code&gt;query&lt;/code&gt; as an argument to the &lt;code&gt;contains&lt;/code&gt; method now, we need to add an ampersand because the signature of &lt;code&gt;contains&lt;/code&gt; is defined to take a string slice.</source>
          <target state="translated">Обратите внимание, что &lt;code&gt;query&lt;/code&gt; теперь представляет собой &lt;code&gt;String&lt;/code&gt; а не фрагмент строки, потому что вызов &lt;code&gt;to_lowercase&lt;/code&gt; создает новые данные, а не ссылается на существующие данные. Скажем, запрос - это &lt;code&gt;&quot;rUsT&quot;&lt;/code&gt; , в качестве примера: этот строковый фрагмент не содержит строчные буквы &lt;code&gt;u&lt;/code&gt; или &lt;code&gt;t&lt;/code&gt; ,которые мы могли бы использовать, поэтому мы должны выделить новую &lt;code&gt;String&lt;/code&gt; содержащую &lt;code&gt;&quot;rust&quot;&lt;/code&gt; . Теперь, когда мы передаем &lt;code&gt;query&lt;/code&gt; в качестве аргумента методу &lt;code&gt;contains&lt;/code&gt; , нам нужно добавить амперсанд, потому что подпись &lt;code&gt;contains&lt;/code&gt; определена для получения фрагмента строки.</target>
        </trans-unit>
        <trans-unit id="d0952252c7abd133f9767b9cae9e5576b814cc56" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;std::env::args&lt;/code&gt; will panic if any argument contains invalid Unicode. If your program needs to accept arguments containing invalid Unicode, use &lt;code&gt;std::env::args_os&lt;/code&gt; instead. That function returns an iterator that produces &lt;code&gt;OsString&lt;/code&gt; values instead of &lt;code&gt;String&lt;/code&gt; values. We&amp;rsquo;ve chosen to use &lt;code&gt;std::env::args&lt;/code&gt; here for simplicity, because &lt;code&gt;OsString&lt;/code&gt; values differ per platform and are more complex to work with than &lt;code&gt;String&lt;/code&gt; values.</source>
          <target state="translated">Обратите внимание, что &lt;code&gt;std::env::args&lt;/code&gt; вызовет панику, если какой-либо аргумент содержит недопустимый Unicode. Если ваша программа должна принимать аргументы, содержащие недопустимый Unicode, используйте вместо этого &lt;code&gt;std::env::args_os&lt;/code&gt; . Эта функция возвращает итератор, который производит значения &lt;code&gt;OsString&lt;/code&gt; вместо значений &lt;code&gt;String&lt;/code&gt; . Мы решили использовать здесь &lt;code&gt;std::env::args&lt;/code&gt; для простоты, потому &lt;code&gt;OsString&lt;/code&gt; значения OsString различаются для разных платформ и с ними сложнее работать, чем со значениями &lt;code&gt;String&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="46299fa0ac2a6d6905de493039f518d4e56af3e6" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;zip&lt;/code&gt; produces only four pairs; the theoretical fifth pair &lt;code&gt;(5, None)&lt;/code&gt; is never produced because &lt;code&gt;zip&lt;/code&gt; returns &lt;code&gt;None&lt;/code&gt; when either of its input iterators return &lt;code&gt;None&lt;/code&gt;.</source>
          <target state="translated">Обратите внимание, что на &lt;code&gt;zip&lt;/code&gt; получается всего четыре пары; теоретическая пятая пара &lt;code&gt;(5, None)&lt;/code&gt; никогда не создается, потому что &lt;code&gt;zip&lt;/code&gt; возвращает &lt;code&gt;None&lt;/code&gt; , когда любой из его итераторов ввода возвращает &lt;code&gt;None&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="df23fedf4cb715b65ef5d705d642f0cedf378647" translate="yes" xml:space="preserve">
          <source>Note that Rust does not have a notion of optional function arguments or variadic functions (except for its C-FFI).</source>
          <target state="translated">Обратите внимание,что в Rust нет понятия необязательных аргументов функций или вариадических функций (за исключением его C-FFI).</target>
        </trans-unit>
        <trans-unit id="9dba02396ec6e8b7b0a98dc4c9d2e9628008b426" translate="yes" xml:space="preserve">
          <source>Note that a &quot;best effort&quot; is made to ensure that destructors for types stored in thread local storage are run, but not all platforms can guarantee that destructors will be run for all types in thread local storage. For example, there are a number of known caveats where destructors are not run:</source>
          <target state="translated">Обратите внимание,что &quot;прилагаются все усилия&quot;,чтобы деструкторы для типов,хранящихся в потоковом локальном хранилище,были запущены,но не все платформы могут гарантировать,что деструкторы будут запущены для всех типов в потоковом локальном хранилище.Например,известен ряд предостережений,в которых деструкторы не запускаются:</target>
        </trans-unit>
        <trans-unit id="aa61dce391cdbcb5b806d9a3fb49147f0dba491d" translate="yes" xml:space="preserve">
          <source>Note that a &lt;code&gt;()&lt;/code&gt;-returning &lt;code&gt;main&lt;/code&gt; implicitly results in a successful termination, so there's no need to return this from &lt;code&gt;main&lt;/code&gt; unless you're also returning other possible codes.</source>
          <target state="translated">Обратите внимание, что &lt;code&gt;()&lt;/code&gt; -возврат из &lt;code&gt;main&lt;/code&gt; неявно приводит к успешному завершению, поэтому нет необходимости возвращать это из &lt;code&gt;main&lt;/code&gt; , если вы также не возвращаете другие возможные коды.</target>
        </trans-unit>
        <trans-unit id="8c3f037daacb11aa4c63650c08cd568774329dcc" translate="yes" xml:space="preserve">
          <source>Note that a capture will either move or borrow a variable, but in this situation, the closure is borrowing the variable. Take a look at http://rustbyexample.com/fn/closures/capture.html for more information about capturing.</source>
          <target state="translated">Обратите внимание,что захват либо передвигает,либо заимствует переменную,но в этой ситуации закрытие заимствует переменную.Дополнительную информацию о захвате можно найти на сайте http://rustbyexample.com/fn/closures/capture.html.</target>
        </trans-unit>
        <trans-unit id="d28236ceeda3d941466d94520f9be31d9496ffc8" translate="yes" xml:space="preserve">
          <source>Note that a capture will either move or borrow a variable, but in this situation, the closure is borrowing the variable. Take a look at the chapter on &lt;a href=&quot;https://doc.rust-lang.org/stable/rust-by-example/fn/closures/capture.html&quot;&gt;Capturing&lt;/a&gt; in Rust By Example for more information.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b647009da3543b51ed32c9ce05f0008653d4bcc6" translate="yes" xml:space="preserve">
          <source>Note that a matcher is merely a token tree. A &quot;simple NT&quot;, as mentioned above, is an meta-variable NT; thus it is a non-repetition. For example, &lt;code&gt;$foo:ty&lt;/code&gt; is a simple NT but &lt;code&gt;$($foo:ty)+&lt;/code&gt; is a complex NT.</source>
          <target state="translated">Обратите внимание, что сопоставитель - это просто дерево токенов. &amp;laquo;Простая NT&amp;raquo;, как упоминалось выше, является NT метапеременной; таким образом, это неповторение. Например, &lt;code&gt;$foo:ty&lt;/code&gt; - это простая NT, а &lt;code&gt;$($foo:ty)+&lt;/code&gt; - сложная NT.</target>
        </trans-unit>
        <trans-unit id="166c645f512c5060e3e63517e9e2f60db5770e99" translate="yes" xml:space="preserve">
          <source>Note that a reference&amp;rsquo;s scope starts from where it is introduced and continues through the last time that reference is used. For instance, this code will compile because the last usage of the immutable references occurs before the mutable reference is introduced:</source>
          <target state="translated">Обратите внимание, что область действия ссылки начинается с того места, где она была введена, и продолжается до последнего использования этой ссылки. Например, этот код будет компилироваться, потому что последнее использование неизменяемых ссылок происходит до введения изменяемой ссылки:</target>
        </trans-unit>
        <trans-unit id="f3f4807c52376e81ba95b7f4b622c918a83cf1d4" translate="yes" xml:space="preserve">
          <source>Note that a successful send does &lt;em&gt;not&lt;/em&gt; guarantee that the receiver will ever see the data if there is a buffer on this channel. Items may be enqueued in the internal buffer for the receiver to receive at a later time. If the buffer size is 0, however, the channel becomes a rendezvous channel and it guarantees that the receiver has indeed received the data if this function returns success.</source>
          <target state="translated">Обратите внимание, что успешная отправка &lt;em&gt;не&lt;/em&gt; гарантирует, что получатель когда-либо увидит данные, если на этом канале есть буфер. Элементы могут быть помещены в очередь во внутреннем буфере, чтобы получатель мог получить их позже. Однако, если размер буфера равен 0, канал становится каналом рандеву и гарантирует, что получатель действительно получил данные, если эта функция возвращает успех.</target>
        </trans-unit>
        <trans-unit id="1f0335bd5206c4df046874965f0d18fc2183ed51" translate="yes" xml:space="preserve">
          <source>Note that accessing the value inside a &lt;code&gt;ManuallyDrop&amp;lt;T&amp;gt;&lt;/code&gt; is safe. This means that a &lt;code&gt;ManuallyDrop&amp;lt;T&amp;gt;&lt;/code&gt; whose content has been dropped must not be exposed through a public safe API. Correspondingly, &lt;code&gt;ManuallyDrop::drop&lt;/code&gt; is unsafe.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5885b8aa2d181f8795166dedd7f6344e9a60f6b3" translate="yes" xml:space="preserve">
          <source>Note that alignment may not be implemented by some types. In particular, it is not generally implemented for the &lt;code&gt;Debug&lt;/code&gt; trait. A good way to ensure padding is applied is to format your input, then pad this resulting string to obtain your output:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e3a19fce9bb891c546eeeb563b1b7a91ed25675f" translate="yes" xml:space="preserve">
          <source>Note that alignment may not be implemented by some types. In particular, it is not generally implemented for the &lt;code&gt;Debug&lt;/code&gt; trait. A good way to ensure padding is applied is to format your input, then use this resulting string to pad your output.</source>
          <target state="translated">Обратите внимание, что некоторые типы могут не выполнять выравнивание. В частности, это обычно не реализуется для трейта &lt;code&gt;Debug&lt;/code&gt; . Хороший способ обеспечить применение отступов - отформатировать ввод, а затем использовать полученную строку для дополнения вывода.</target>
        </trans-unit>
        <trans-unit id="76db1b0ab7636a80673dac1a141ed05d052cb403" translate="yes" xml:space="preserve">
          <source>Note that all &lt;a href=&quot;../primitive.char&quot;&gt;&lt;code&gt;char&lt;/code&gt;&lt;/a&gt;s are valid &lt;a href=&quot;../primitive.u32&quot;&gt;&lt;code&gt;u32&lt;/code&gt;&lt;/a&gt;s, and can be cast to one with &lt;code&gt;as&lt;/code&gt;:</source>
          <target state="translated">Обратите внимание , что все &lt;a href=&quot;../primitive.char&quot;&gt; &lt;code&gt;char&lt;/code&gt; &lt;/a&gt; s действительны &lt;a href=&quot;../primitive.u32&quot;&gt; &lt;code&gt;u32&lt;/code&gt; &lt;/a&gt; s, и могут быть приведены к одному с , &lt;code&gt;as&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="516c2ce158a14ccb1ab369bf0a62cbade5443e81" translate="yes" xml:space="preserve">
          <source>Note that all &lt;code&gt;char&lt;/code&gt;s are valid &lt;a href=&quot;primitive.u32&quot;&gt;&lt;code&gt;u32&lt;/code&gt;&lt;/a&gt;s, and can be cast to one with &lt;code&gt;as&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f0494b2e843f4a073b41bb1890333a63fc3eaceb" translate="yes" xml:space="preserve">
          <source>Note that all elements between the end and the returned element will be consumed, including the returned element. This also means that calling &lt;code&gt;nth_back(0)&lt;/code&gt; multiple times on the same iterator will return different elements.</source>
          <target state="translated">Обратите внимание, что все элементы между концом и возвращенным элементом будут использованы, включая возвращенный элемент. Это также означает, что вызов &lt;code&gt;nth_back(0)&lt;/code&gt; несколько раз на одном и том же итераторе вернет разные элементы.</target>
        </trans-unit>
        <trans-unit id="50ea5f0e3ab7dc58cad2b538ddb240e9c4984ee9" translate="yes" xml:space="preserve">
          <source>Note that all preceding elements, as well as the returned element, will be consumed from the iterator. That means that the preceding elements will be discarded, and also that calling &lt;code&gt;nth(0)&lt;/code&gt; multiple times on the same iterator will return different elements.</source>
          <target state="translated">Обратите внимание, что все предыдущие элементы, а также возвращаемый элемент будут использованы итератором. Это означает, что предыдущие элементы будут отброшены, а также что многократный вызов &lt;code&gt;nth(0)&lt;/code&gt; на одном и том же итераторе вернет разные элементы.</target>
        </trans-unit>
        <trans-unit id="491da8d1616c74f297c93c3f76ed9c42830ffa59" translate="yes" xml:space="preserve">
          <source>Note that any code in earlier iterations of &lt;em&gt;The Rust Programming Language&lt;/em&gt; that compiled will continue to compile without &lt;code&gt;edition=&quot;2018&quot;&lt;/code&gt; in the project&amp;rsquo;s &lt;em&gt;Cargo.toml&lt;/em&gt;, even as you update the Rust compiler version you&amp;rsquo;re using. That&amp;rsquo;s Rust&amp;rsquo;s backward compatibility guarantees at work!</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8557ae8a9f894db68722639fc1170d53ad338fd1" translate="yes" xml:space="preserve">
          <source>Note that any code in the first printing of &lt;em&gt;The Rust Programming Language&lt;/em&gt; that compiled will continue to compile without &lt;code&gt;edition=&quot;2018&quot;&lt;/code&gt; in the project&amp;rsquo;s &lt;em&gt;Cargo.toml&lt;/em&gt;, even as you update the Rust compiler version you&amp;rsquo;re using. That&amp;rsquo;s Rust&amp;rsquo;s backward compatibility guarantees at work!</source>
          <target state="translated">Обратите внимание, что любой скомпилированный код в первом &lt;code&gt;edition=&quot;2018&quot;&lt;/code&gt; &lt;em&gt;языка программирования Rust&lt;/em&gt; будет продолжать компилироваться без edition = &quot;2018&quot; в &lt;em&gt;Cargo.toml&lt;/em&gt; проекта , даже если вы обновите версию компилятора Rust, которую используете. Это гарантии обратной совместимости Rust в действии!</target>
        </trans-unit>
        <trans-unit id="816a2f31fb1f17b4e41f02fda3eaa37e852b4d6e" translate="yes" xml:space="preserve">
          <source>Note that any leftover data in the internal buffer is lost.</source>
          <target state="translated">Обратите внимание,что все оставшиеся данные во внутреннем буфере теряются.</target>
        </trans-unit>
        <trans-unit id="2a041883f7bee5eb6e6f55708c727c8ab3a3ed00" translate="yes" xml:space="preserve">
          <source>Note that any leftover data in the internal buffer is lost. Therefore, a following read from the underlying reader may lead to data loss.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="45719b2fc23ab9d812a1864bec0c46011337290e" translate="yes" xml:space="preserve">
          <source>Note that because this function never returns, and that it terminates the process, no destructors on the current stack or any other thread's stack will be run.</source>
          <target state="translated">Обратите внимание,что из-за того,что эта функция никогда не возвращается,а также из-за того,что она завершает процесс,ни деструкторы на текущем стеке,ни любой другой стек потока не будут запущены.</target>
        </trans-unit>
        <trans-unit id="8ee637b0f22097f2447433c9e30b0952e702b8b7" translate="yes" xml:space="preserve">
          <source>Note that because this function never returns, and that it terminates the process, no destructors on the current stack or any other thread's stack will be run. If a clean shutdown is needed it is recommended to only call this function at a known point where there are no more destructors left to run.</source>
          <target state="translated">Обратите внимание,что из-за того,что эта функция никогда не возвращается,а также из-за того,что она завершает процесс,ни деструкторы на текущем стеке,ни любой другой стек потока не будут запущены.Если требуется чистое выключение,рекомендуется вызывать эту функцию только в известной точке,где больше не осталось деструкторов для выполнения.</target>
        </trans-unit>
        <trans-unit id="25d3aa7c2b95febeff16d7f5e6ce36387044d531" translate="yes" xml:space="preserve">
          <source>Note that because we defined the &lt;code&gt;Summary&lt;/code&gt; trait and the &lt;code&gt;NewsArticle&lt;/code&gt; and &lt;code&gt;Tweet&lt;/code&gt; types in the same &lt;em&gt;lib.rs&lt;/em&gt; in Listing 10-13, they&amp;rsquo;re all in the same scope. Let&amp;rsquo;s say this &lt;em&gt;lib.rs&lt;/em&gt; is for a crate we&amp;rsquo;ve called &lt;code&gt;aggregator&lt;/code&gt; and someone else wants to use our crate&amp;rsquo;s functionality to implement the &lt;code&gt;Summary&lt;/code&gt; trait on a struct defined within their library&amp;rsquo;s scope. They would need to bring the trait into their scope first. They would do so by specifying &lt;code&gt;use aggregator::Summary;&lt;/code&gt;, which then would enable them to implement &lt;code&gt;Summary&lt;/code&gt; for their type. The &lt;code&gt;Summary&lt;/code&gt; trait would also need to be a public trait for another crate to implement it, which it is because we put the &lt;code&gt;pub&lt;/code&gt; keyword before &lt;code&gt;trait&lt;/code&gt; in Listing 10-12.</source>
          <target state="translated">Заметим , что , поскольку мы определили &lt;code&gt;Summary&lt;/code&gt; черту и &lt;code&gt;NewsArticle&lt;/code&gt; и &lt;code&gt;Tweet&lt;/code&gt; типы в одних и тех же &lt;em&gt;lib.rs&lt;/em&gt; в листинге 10-13, все они в той же области. Допустим, этот &lt;em&gt;lib.rs&lt;/em&gt; предназначен для ящика, который мы назвали &lt;code&gt;aggregator&lt;/code&gt; и кто-то еще хочет использовать функциональность нашего ящика для реализации трейта &lt;code&gt;Summary&lt;/code&gt; в структуре, определенной в пределах их библиотеки. Им нужно будет сначала включить эту черту в свою область видимости. Они сделали бы это, указав &lt;code&gt;use aggregator::Summary;&lt;/code&gt; , что затем позволит им реализовать &lt;code&gt;Summary&lt;/code&gt; для своего типа. &lt;code&gt;Summary&lt;/code&gt; trait также должен быть общедоступным для другого ящика, чтобы реализовать его, потому что мы поместили ключевое слово &lt;code&gt;pub&lt;/code&gt; перед &lt;code&gt;trait&lt;/code&gt; в листинге 10-12.</target>
        </trans-unit>
        <trans-unit id="5c2746c98858012c4f3f702901d1b8fef09f722f" translate="yes" xml:space="preserve">
          <source>Note that because we&amp;rsquo;ve used only one generic type to define &lt;code&gt;Point&amp;lt;T&amp;gt;&lt;/code&gt;, this definition says that the &lt;code&gt;Point&amp;lt;T&amp;gt;&lt;/code&gt; struct is generic over some type &lt;code&gt;T&lt;/code&gt;, and the fields &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; are &lt;em&gt;both&lt;/em&gt; that same type, whatever that type may be. If we create an instance of a &lt;code&gt;Point&amp;lt;T&amp;gt;&lt;/code&gt; that has values of different types, as in Listing 10-7, our code won&amp;rsquo;t compile.</source>
          <target state="translated">Обратите внимание: поскольку мы использовали только один универсальный тип для определения &lt;code&gt;Point&amp;lt;T&amp;gt;&lt;/code&gt; , это определение говорит, что структура &lt;code&gt;Point&amp;lt;T&amp;gt;&lt;/code&gt; является универсальной для некоторого типа &lt;code&gt;T&lt;/code&gt; , а поля &lt;code&gt;x&lt;/code&gt; и &lt;code&gt;y&lt;/code&gt; имеют один &lt;em&gt;и&lt;/em&gt; тот же тип, независимо от этого типа. может быть. Если мы создадим экземпляр &lt;code&gt;Point&amp;lt;T&amp;gt;&lt;/code&gt; который имеет значения разных типов, как в листинге 10-7, наш код не будет компилироваться.</target>
        </trans-unit>
        <trans-unit id="ee83d2a98a726eb4d0819a08ff35a51d203bcc33" translate="yes" xml:space="preserve">
          <source>Note that capturing a backtrace can be an expensive operation on some platforms, so this should be used with caution in performance-sensitive parts of code.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8b44ef6f5d455a7524a366399e247106ccce266f" translate="yes" xml:space="preserve">
          <source>Note that dropping a &lt;code&gt;MaybeUninit&amp;lt;T&amp;gt;&lt;/code&gt; will never call &lt;code&gt;T&lt;/code&gt;'s drop code. It is your responsibility to make sure &lt;code&gt;T&lt;/code&gt; gets dropped if it got initialized.</source>
          <target state="translated">Обратите внимание, что удаление &lt;code&gt;MaybeUninit&amp;lt;T&amp;gt;&lt;/code&gt; никогда не вызовет код отбрасывания &lt;code&gt;T&lt;/code&gt; .Вы несете ответственность за то, чтобы &lt;code&gt;T&lt;/code&gt; был сброшен, если он был инициализирован.</target>
        </trans-unit>
        <trans-unit id="1ca6aa2552d35e463ab42d6ea3dc8e136eb4776f" translate="yes" xml:space="preserve">
          <source>Note that due to method call deref coercion, simply calling a trait method will act like they work on references as well as they do on owned values! The implementations described here are meant for generic contexts, where the final type &lt;code&gt;T&lt;/code&gt; is a type parameter or otherwise not locally known.</source>
          <target state="translated">Обратите внимание, что из-за принуждения deref вызова метода простой вызов метода черты будет действовать так, как будто они работают со ссылками так же, как и с собственными значениями! Описанные здесь реализации предназначены для общих контекстов, где последний тип &lt;code&gt;T&lt;/code&gt; является параметром типа или иным образом не известен локально.</target>
        </trans-unit>
        <trans-unit id="1de74eaeec2a2aa72b741e1bb4ba4ee5991fbccf" translate="yes" xml:space="preserve">
          <source>Note that empty arrays &lt;code&gt;[T; 0]&lt;/code&gt; have the same alignment requirement as the element type &lt;code&gt;T&lt;/code&gt;. Also note that the error is conservatively reported even when the alignment of the zero-sized type is less than or equal to the data field's alignment.</source>
          <target state="translated">Обратите внимание, что пустые массивы &lt;code&gt;[T; 0]&lt;/code&gt; имеют то же требование выравнивания в качестве типа элемента &lt;code&gt;T&lt;/code&gt; . Также обратите внимание, что об ошибке сообщается консервативно, даже если выравнивание типа нулевого размера меньше или равно выравниванию поля данных.</target>
        </trans-unit>
        <trans-unit id="03aca4023a1e7014a85e0b59db326c1054412c53" translate="yes" xml:space="preserve">
          <source>Note that environment variable names are case-insensitive (but case-preserving) on Windows, and case-sensitive on all other platforms.</source>
          <target state="translated">Обратите внимание,что имена переменных окружения не чувствительны к регистру (но сохраняют регистр)на Windows,и чувствительны к регистру на всех других платформах.</target>
        </trans-unit>
        <trans-unit id="af3176ad62da7d96f31254f9c337151434d91850" translate="yes" xml:space="preserve">
          <source>Note that even if &lt;code&gt;T&lt;/code&gt; has size &lt;code&gt;0&lt;/code&gt;, the pointer must be non-NULL and properly aligned.</source>
          <target state="translated">Обратите внимание, что даже если &lt;code&gt;T&lt;/code&gt; имеет размер &lt;code&gt;0&lt;/code&gt; , указатель не должен быть NULL и правильно выровнен.</target>
        </trans-unit>
        <trans-unit id="58d2d77f2d5d331bda29fe5d0af29fd62177b001" translate="yes" xml:space="preserve">
          <source>Note that even if &lt;code&gt;T&lt;/code&gt; has size &lt;code&gt;0&lt;/code&gt;, the pointer must be non-NULL.</source>
          <target state="translated">Обратите внимание, что даже если &lt;code&gt;T&lt;/code&gt; имеет размер &lt;code&gt;0&lt;/code&gt; , указатель не должен быть NULL.</target>
        </trans-unit>
        <trans-unit id="aca2272e34501c47a8d86a387930c81a45160055" translate="yes" xml:space="preserve">
          <source>Note that even if &lt;code&gt;T&lt;/code&gt; has size &lt;code&gt;0&lt;/code&gt;, the pointers must be non-NULL and properly aligned.</source>
          <target state="translated">Обратите внимание, что даже если &lt;code&gt;T&lt;/code&gt; имеет размер &lt;code&gt;0&lt;/code&gt; , указатели не должны быть NULL и правильно выровнены.</target>
        </trans-unit>
        <trans-unit id="9806a4590799343d8c64ae41117a4958b8386ffa" translate="yes" xml:space="preserve">
          <source>Note that even if the effectively copied size (&lt;code&gt;count * size_of::&amp;lt;T&amp;gt;()&lt;/code&gt;) is &lt;code&gt;0&lt;/code&gt;, the pointer must be non-NULL and properly aligned.</source>
          <target state="translated">Обратите внимание, что даже если эффективно скопированный размер ( &lt;code&gt;count * size_of::&amp;lt;T&amp;gt;()&lt;/code&gt; ) равен &lt;code&gt;0&lt;/code&gt; , указатель должен быть не NULL и правильно выровнен.</target>
        </trans-unit>
        <trans-unit id="851cd0d9eb90b03ed21845664c6d4ace9ece4acd" translate="yes" xml:space="preserve">
          <source>Note that even if the effectively copied size (&lt;code&gt;count * size_of::&amp;lt;T&amp;gt;()&lt;/code&gt;) is &lt;code&gt;0&lt;/code&gt;, the pointers must be non-NULL and properly aligned.</source>
          <target state="translated">Обратите внимание, что даже если эффективно скопированный размер ( &lt;code&gt;count * size_of::&amp;lt;T&amp;gt;()&lt;/code&gt; ) равен &lt;code&gt;0&lt;/code&gt; , указатели не должны быть NULL и правильно выровнены.</target>
        </trans-unit>
        <trans-unit id="6c1ad3562574888b0c8c8e999ed33eff7030ffcd" translate="yes" xml:space="preserve">
          <source>Note that even if this panics, the value is considered to be dropped; you must not cause &lt;code&gt;drop&lt;/code&gt; to be called again. This is normally automatically handled by the compiler, but when using unsafe code, can sometimes occur unintentionally, particularly when using &lt;a href=&quot;../ptr/fn.drop_in_place&quot;&gt;&lt;code&gt;ptr::drop_in_place&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e70094585dad750582f0b20dfaa8a3722d32400a" translate="yes" xml:space="preserve">
          <source>Note that even though the standard library contains a definition for &lt;code&gt;IpAddr&lt;/code&gt;, we can still create and use our own definition without conflict because we haven&amp;rsquo;t brought the standard library&amp;rsquo;s definition into our scope. We&amp;rsquo;ll talk more about bringing types into scope in Chapter 7.</source>
          <target state="translated">Обратите внимание, что даже несмотря на то, что стандартная библиотека содержит определение для &lt;code&gt;IpAddr&lt;/code&gt; , мы все равно можем создавать и использовать собственное определение без конфликтов, поскольку мы не добавили определение стандартной библиотеки в нашу область видимости. Подробнее о включении типов в область видимости мы поговорим в главе 7.</target>
        </trans-unit>
        <trans-unit id="31c2c0947f08a70cf66a5f5539b0e2dc387b144b" translate="yes" xml:space="preserve">
          <source>Note that future platforms may be added that also do not have support for some atomic operations. Maximally portable code will want to be careful about which atomic types are used. &lt;code&gt;AtomicUsize&lt;/code&gt; and &lt;code&gt;AtomicIsize&lt;/code&gt; are generally the most portable, but even then they're not available everywhere. For reference, the &lt;code&gt;std&lt;/code&gt; library requires pointer-sized atomics, although &lt;code&gt;core&lt;/code&gt; does not.</source>
          <target state="translated">Обратите внимание, что в будущем могут быть добавлены платформы, которые также не поддерживают некоторые атомарные операции. Максимально переносимый код должен быть осторожен с тем, какие атомарные типы используются. &lt;code&gt;AtomicUsize&lt;/code&gt; и &lt;code&gt;AtomicIsize&lt;/code&gt; , как правило, наиболее переносимы, но даже тогда они доступны не везде. Для справки: библиотека &lt;code&gt;std&lt;/code&gt; требует атомики размером с указатель, а &lt;code&gt;core&lt;/code&gt; - нет.</target>
        </trans-unit>
        <trans-unit id="59fbfedac3227479331b23c365329ce5aabd1a1b" translate="yes" xml:space="preserve">
          <source>Note that generic arguments for enum variant constructors go after the variant, not after the enum. For example, you would write &lt;code&gt;Option::None::&amp;lt;u32&amp;gt;&lt;/code&gt;, rather than &lt;code&gt;Option::&amp;lt;u32&amp;gt;::None&lt;/code&gt;.</source>
          <target state="translated">Обратите внимание, что общие аргументы для конструкторов вариантов перечисления идут после варианта, а не после перечисления. Например, вы должны написать &lt;code&gt;Option::None::&amp;lt;u32&amp;gt;&lt;/code&gt; , а не &lt;code&gt;Option::&amp;lt;u32&amp;gt;::None&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b6e3284112fc89aa89918b12b076295886a2da9b" translate="yes" xml:space="preserve">
          <source>Note that here the call to &lt;a href=&quot;mem/fn.drop&quot;&gt;&lt;code&gt;drop&lt;/code&gt;&lt;/a&gt; is for clarity - it indicates that we are done with the given value and it should be destroyed.</source>
          <target state="translated">Обратите внимание, что здесь вызов &lt;a href=&quot;mem/fn.drop&quot;&gt; &lt;code&gt;drop&lt;/code&gt; &lt;/a&gt; сделан для ясности - он указывает, что мы закончили с заданным значением, и его следует уничтожить.</target>
        </trans-unit>
        <trans-unit id="0753b6373f6f1d65a2eb747fb24056dce4b9d211" translate="yes" xml:space="preserve">
          <source>Note that if &lt;code&gt;Self::Item&lt;/code&gt; is only &lt;code&gt;PartialOrd&lt;/code&gt;, but not &lt;code&gt;Ord&lt;/code&gt;, the above definition implies that this function returns &lt;code&gt;false&lt;/code&gt; if any two consecutive items are not comparable.</source>
          <target state="translated">Обратите внимание, что если &lt;code&gt;Self::Item&lt;/code&gt; имеет значение только &lt;code&gt;PartialOrd&lt;/code&gt; , но не &lt;code&gt;Ord&lt;/code&gt; , приведенное выше определение подразумевает, что эта функция возвращает &lt;code&gt;false&lt;/code&gt; , если любые два последовательных элемента не сопоставимы.</target>
        </trans-unit>
        <trans-unit id="b91bc8063fbfefef1d18b41e7b347e2c6fec2abd" translate="yes" xml:space="preserve">
          <source>Note that if &lt;code&gt;from&lt;/code&gt; and &lt;code&gt;to&lt;/code&gt; both point to the same file, then the file will likely get truncated by this operation.</source>
          <target state="translated">Обратите внимание: если &lt;code&gt;from&lt;/code&gt; и &lt;code&gt;to&lt;/code&gt; оба указывают на один и тот же файл, то файл, скорее всего, будет усечен этой операцией.</target>
        </trans-unit>
        <trans-unit id="9d3e37ab6666f6f897eee8b56db717458b005ac3" translate="yes" xml:space="preserve">
          <source>Note that if a function takes multiple type arguments but you want the compiler to infer some of them, you can use type placeholders:</source>
          <target state="translated">Обратите внимание,что если функция принимает несколько аргументов типа,но вы хотите,чтобы компилятор сделал вывод о некоторых из них,вы можете использовать плейсхолдеры типов:</target>
        </trans-unit>
        <trans-unit id="cd535d6f6d4b53f3c244d297f7914a6181acf961" translate="yes" xml:space="preserve">
          <source>Note that if the &lt;code&gt;static&lt;/code&gt; or &lt;code&gt;const&lt;/code&gt; items include function or closure references, which themselves include references, the compiler will first try the standard elision rules. If it is unable to resolve the lifetimes by its usual rules, then it will error. By way of example:</source>
          <target state="translated">Обратите внимание, что если &lt;code&gt;static&lt;/code&gt; или &lt;code&gt;const&lt;/code&gt; элементы включают ссылки на функции или замыкания, которые сами включают ссылки, компилятор сначала попробует стандартные правила исключения. Если он не может определить время жизни по обычным правилам, он выдаст ошибку. В качестве примера:</target>
        </trans-unit>
        <trans-unit id="9ef199153d75a42174c42cff6fb7c6c1476957fd" translate="yes" xml:space="preserve">
          <source>Note that implementations do not necessarily have to provide access to the inner-most source of a pipeline. A stateful intermediate adapter might eagerly evaluate a part of the pipeline and expose its internal storage as source.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c0702815af49297e37a4e0bb02d65562e392c8a7" translate="yes" xml:space="preserve">
          <source>Note that in Rust, structs can only contain an unsized type if the field containing the unsized type is the last and only unsized type field in the struct.</source>
          <target state="translated">Обратите внимание,что в Rust структуры могут содержать тип unsized только в том случае,если поле,содержащее тип unsized,является последним и единственным полем типа unsized в структуре.</target>
        </trans-unit>
        <trans-unit id="523c7fb2b8819c356a6b0490b2a0d8371495e11f" translate="yes" xml:space="preserve">
          <source>Note that in some languages and test frameworks, the parameters to the functions that assert two values are equal are called &lt;code&gt;expected&lt;/code&gt; and &lt;code&gt;actual&lt;/code&gt;, and the order in which we specify the arguments matters. However, in Rust, they&amp;rsquo;re called &lt;code&gt;left&lt;/code&gt; and &lt;code&gt;right&lt;/code&gt;, and the order in which we specify the value we expect and the value that the code under test produces doesn&amp;rsquo;t matter. We could write the assertion in this test as &lt;code&gt;assert_eq!(add_two(2), 4)&lt;/code&gt;, which would result in a failure message that displays &lt;code&gt;assertion failed: `(left == right)`&lt;/code&gt; and that &lt;code&gt;left&lt;/code&gt; was &lt;code&gt;5&lt;/code&gt; and &lt;code&gt;right&lt;/code&gt; was &lt;code&gt;4&lt;/code&gt;.</source>
          <target state="translated">Обратите внимание, что в некоторых языках и платформах тестирования параметры функций, которые утверждают, что два значения равны, называются &lt;code&gt;expected&lt;/code&gt; и &lt;code&gt;actual&lt;/code&gt; , и порядок, в котором мы указываем аргументы, имеет значение. Однако в Rust они называются &lt;code&gt;left&lt;/code&gt; и &lt;code&gt;right&lt;/code&gt; , и порядок, в котором мы указываем ожидаемое значение и значение, которое генерирует тестируемый код, не имеет значения. Мы могли бы записать утверждение в этом тесте как &lt;code&gt;assert_eq!(add_two(2), 4)&lt;/code&gt; , что приведет к сообщению об ошибке , отображающему &lt;code&gt;assertion failed: `(left == right)`&lt;/code&gt; , где &lt;code&gt;left&lt;/code&gt; было &lt;code&gt;5&lt;/code&gt; , а &lt;code&gt;right&lt;/code&gt; было &lt;code&gt;4&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="bd234e5e31b58a835a7427c6ccb9ea99860e96d4" translate="yes" xml:space="preserve">
          <source>Note that introducing another &lt;code&gt;struct&lt;/code&gt; just to have a place for the other attributes may have unintended side effects on the representation:</source>
          <target state="translated">Обратите внимание, что введение другой &lt;code&gt;struct&lt;/code&gt; только для того, чтобы иметь место для других атрибутов, может иметь непреднамеренные побочные эффекты на представление:</target>
        </trans-unit>
        <trans-unit id="6abfc6c98c1133dd19e39dfc110c77706058a67e" translate="yes" xml:space="preserve">
          <source>Note that it is impossible to link in native dynamic dependencies to a static library, and in this case warnings will be printed about all unlinked native dynamic dependencies.</source>
          <target state="translated">Обратите внимание,что в родных динамических зависимостях невозможно связать со статической библиотекой,и в этом случае будут выведены предупреждения обо всех несвязанных родных динамических зависимостях.</target>
        </trans-unit>
        <trans-unit id="213f52c82816211eed8a84af1c6306ce11d2042d" translate="yes" xml:space="preserve">
          <source>Note that it isn&amp;rsquo;t possible to call the default implementation from an overriding implementation of that same method.</source>
          <target state="translated">Обратите внимание, что невозможно вызвать реализацию по умолчанию из замещающей реализации того же метода.</target>
        </trans-unit>
        <trans-unit id="431dfb333d11627033bd73c3c12aac0f9ce02166" translate="yes" xml:space="preserve">
          <source>Note that length of a stream can change over time (for example, when data is appended to a file). So calling this method multiple times does not necessarily return the same length each time.</source>
          <target state="translated">Обратите внимание,что длина потока может меняться со временем (например,когда данные добавляются в файл).Поэтому многократный вызов этого метода не обязательно каждый раз возвращает одну и ту же длину.</target>
        </trans-unit>
        <trans-unit id="313ba1495decd5683c08865a1c2d8bbad489994a" translate="yes" xml:space="preserve">
          <source>Note that negating any positive integer will overflow.</source>
          <target state="translated">Обратите внимание,что при отрицании любого положительного целого переполнится.</target>
        </trans-unit>
        <trans-unit id="0310d257cad5180cd2a5706628685feb28fa8baa" translate="yes" xml:space="preserve">
          <source>Note that no other normalization takes place; in particular, &lt;code&gt;a/c&lt;/code&gt; and &lt;code&gt;a/b/../c&lt;/code&gt; are distinct, to account for the possibility that &lt;code&gt;b&lt;/code&gt; is a symbolic link (so its parent isn't &lt;code&gt;a&lt;/code&gt;).</source>
          <target state="translated">Обратите внимание, что никакой другой нормализации не происходит; в частности, &lt;code&gt;a/c&lt;/code&gt; и &lt;code&gt;a/b/../c&lt;/code&gt; различны, чтобы учесть возможность того, что &lt;code&gt;b&lt;/code&gt; является символической ссылкой (поэтому ее родительский &lt;code&gt;a&lt;/code&gt; не является a ).</target>
        </trans-unit>
        <trans-unit id="0f36d8aec30ccdcaddeba64d187fcf335e3e550e" translate="yes" xml:space="preserve">
          <source>Note that not all errors contain a &lt;code&gt;Backtrace&lt;/code&gt;. Also note that a &lt;code&gt;Backtrace&lt;/code&gt; may actually be empty. For more information consult the &lt;code&gt;Backtrace&lt;/code&gt; type itself.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6048f485eb4e07bdf2aa23e3dab346aa63dbf7f5" translate="yes" xml:space="preserve">
          <source>Note that not all platforms will keep this field update in a file's metadata, for example Windows has an option to disable updating this time when files are accessed and Linux similarly has &lt;code&gt;noatime&lt;/code&gt;.</source>
          <target state="translated">Обратите внимание , что не все платформы будут держать это обновление поля в метаданных файла, например , Windows , имеет возможность отключить обновления на этот раз , когда файлы доступны и Linux так же имеет &lt;code&gt;noatime&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d5ed45efedb5980a8a1a6af222c209c849963838" translate="yes" xml:space="preserve">
          <source>Note that nowhere in this output do we see &lt;code&gt;I got the value 4&lt;/code&gt;, which is what is printed when the test that passes runs. That output has been captured. The output from the test that failed, &lt;code&gt;I got the value 8&lt;/code&gt;, appears in the section of the test summary output, which also shows the cause of the test failure.</source>
          <target state="translated">Обратите внимание, что нигде в этом выводе мы не видим, что &lt;code&gt;I got the value 4&lt;/code&gt; , которое печатается при выполнении пройденного теста. Этот вывод был записан. Результат неудачного теста, &lt;code&gt;I got the value 8&lt;/code&gt; , появляется в разделе итоговых результатов теста, который также показывает причину неудачного теста.</target>
        </trans-unit>
        <trans-unit id="5a80c5201601b7cd22253cd99d33bff329ba0af9" translate="yes" xml:space="preserve">
          <source>Note that on multiple calls to &lt;code&gt;poll&lt;/code&gt;, only the &lt;a href=&quot;../task/struct.waker&quot;&gt;&lt;code&gt;Waker&lt;/code&gt;&lt;/a&gt; from the &lt;a href=&quot;../task/struct.context&quot;&gt;&lt;code&gt;Context&lt;/code&gt;&lt;/a&gt; passed to the most recent call should be scheduled to receive a wakeup.</source>
          <target state="translated">Обратите внимание, что при нескольких вызовах для &lt;code&gt;poll&lt;/code&gt; только &lt;a href=&quot;../task/struct.waker&quot;&gt; &lt;code&gt;Waker&lt;/code&gt; &lt;/a&gt; из &lt;a href=&quot;../task/struct.context&quot;&gt; &lt;code&gt;Context&lt;/code&gt; &lt;/a&gt; переданный последнему вызову, должен быть запланирован для получения пробуждения.</target>
        </trans-unit>
        <trans-unit id="55bd215fbbafcd54535dc669556609d05462d431" translate="yes" xml:space="preserve">
          <source>Note that one cannot pass &lt;code&gt;CannotReallocInPlace&lt;/code&gt; to the &lt;code&gt;handle_alloc_error&lt;/code&gt; function; clients are expected either to be able to recover from &lt;code&gt;grow_in_place&lt;/code&gt; failures without aborting, or to fall back on another reallocation method before resorting to an abort.</source>
          <target state="translated">Обратите внимание , что один не может пройти &lt;code&gt;CannotReallocInPlace&lt;/code&gt; к &lt;code&gt;handle_alloc_error&lt;/code&gt; функции; Ожидается, что клиенты либо смогут восстанавливаться &lt;code&gt;grow_in_place&lt;/code&gt; сбоев grow_in_place без прерывания, либо прибегнут к другому методу перераспределения, прежде чем прибегать к прерыванию.</target>
        </trans-unit>
        <trans-unit id="b9605ecaf6269fd2f9ec9b6cd8fec45c27c798c5" translate="yes" xml:space="preserve">
          <source>Note that one cannot pass &lt;code&gt;CannotReallocInPlace&lt;/code&gt; to the &lt;code&gt;handle_alloc_error&lt;/code&gt; function; clients are expected either to be able to recover from &lt;code&gt;shrink_in_place&lt;/code&gt; failures without aborting, or to fall back on another reallocation method before resorting to an abort.</source>
          <target state="translated">Обратите внимание , что один не может пройти &lt;code&gt;CannotReallocInPlace&lt;/code&gt; к &lt;code&gt;handle_alloc_error&lt;/code&gt; функции; Ожидается, что клиенты смогут либо восстанавливаться &lt;code&gt;shrink_in_place&lt;/code&gt; сбоев shrink_in_place без прерывания, либо прибегнуть к другому методу перераспределения, прежде чем прибегать к прерыванию.</target>
        </trans-unit>
        <trans-unit id="b6bbee529e21d8d6f27eb0394a352b9a59dfbecb" translate="yes" xml:space="preserve">
          <source>Note that panics in Rust are not always implemented via unwinding, but they may be implemented by aborting the process. If this function is called when panics are implemented this way then this function will abort the process, not trigger an unwind.</source>
          <target state="translated">Обратите внимание,что паники в Rust не всегда реализуются через разматывание,но они могут быть реализованы путем прерывания процесса.Если эта функция вызывается при реализации паники таким образом,то она прерывает процесс,а не запускает размотку.</target>
        </trans-unit>
        <trans-unit id="5e3c061738b40532446b85ef7e5e80f755eaa54c" translate="yes" xml:space="preserve">
          <source>Note that parts of this block are in use:</source>
          <target state="translated">Обратите внимание,что части этого блока используются:</target>
        </trans-unit>
        <trans-unit id="fff05e35d755803ade4b50f50d29c987f0007787" translate="yes" xml:space="preserve">
          <source>Note that pinning and &lt;a href=&quot;../marker/trait.unpin&quot;&gt;&lt;code&gt;Unpin&lt;/code&gt;&lt;/a&gt; only affect the pointed-to type &lt;code&gt;P::Target&lt;/code&gt;, not the pointer type &lt;code&gt;P&lt;/code&gt; itself that got wrapped in &lt;a href=&quot;struct.pin&quot;&gt;&lt;code&gt;Pin&amp;lt;P&amp;gt;&lt;/code&gt;&lt;/a&gt;. For example, whether or not &lt;a href=&quot;../boxed/struct.box&quot;&gt;&lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt; is &lt;a href=&quot;../marker/trait.unpin&quot;&gt;&lt;code&gt;Unpin&lt;/code&gt;&lt;/a&gt; has no effect on the behavior of &lt;a href=&quot;struct.pin&quot;&gt;&lt;code&gt;Pin&lt;/code&gt;&lt;/a&gt;&lt;code&gt;&amp;lt;&lt;/code&gt;&lt;a href=&quot;../boxed/struct.box&quot;&gt;&lt;code&gt;Box&lt;/code&gt;&lt;/a&gt;&lt;code&gt;&amp;lt;T&amp;gt;&amp;gt;&lt;/code&gt; (here, &lt;code&gt;T&lt;/code&gt; is the pointed-to type).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8df6e9ecf182c2febaad6a991ebf5bacd1fab01f" translate="yes" xml:space="preserve">
          <source>Note that pinning and &lt;code&gt;Unpin&lt;/code&gt; only affect the pointed-to type &lt;code&gt;P::Target&lt;/code&gt;, not the pointer type &lt;code&gt;P&lt;/code&gt; itself that got wrapped in &lt;code&gt;Pin&amp;lt;P&amp;gt;&lt;/code&gt;. For example, whether or not &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; is &lt;code&gt;Unpin&lt;/code&gt; has no effect on the behavior of &lt;code&gt;Pin&amp;lt;Box&amp;lt;T&amp;gt;&amp;gt;&lt;/code&gt; (here, &lt;code&gt;T&lt;/code&gt; is the pointed-to type).</source>
          <target state="translated">Обратите внимание, что закрепление и &lt;code&gt;Unpin&lt;/code&gt; влияют только на указываемый тип &lt;code&gt;P::Target&lt;/code&gt; , а не на сам тип указателя &lt;code&gt;P&lt;/code&gt; , заключенный в &lt;code&gt;Pin&amp;lt;P&amp;gt;&lt;/code&gt; . Например, нерафинированные или &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; является &lt;code&gt;Unpin&lt;/code&gt; не оказывает никакого влияния на поведение &lt;code&gt;Pin&amp;lt;Box&amp;lt;T&amp;gt;&amp;gt;&lt;/code&gt; (здесь, &lt;code&gt;T&lt;/code&gt; является заостренный к типу).</target>
        </trans-unit>
        <trans-unit id="2fe7274dabcb32334d2b65bc1dce4238c4a816f1" translate="yes" xml:space="preserve">
          <source>Note that reading updates the slice to point to the yet unread part. The slice will be empty when EOF is reached.</source>
          <target state="translated">Обратите внимание,что чтение обновляет ломтик,указывая на еще не прочитанную часть.При достижении EOF ломтик будет пустым.</target>
        </trans-unit>
        <trans-unit id="4175de8081524003025f4bfc586324edc516ca55" translate="yes" xml:space="preserve">
          <source>Note that similar to &lt;a href=&quot;../../../fs/struct.file#method.read&quot;&gt;&lt;code&gt;File::read&lt;/code&gt;&lt;/a&gt;, it is not an error to return with a short read.</source>
          <target state="translated">Обратите внимание, что, как и в случае с &lt;a href=&quot;../../../fs/struct.file#method.read&quot;&gt; &lt;code&gt;File::read&lt;/code&gt; &lt;/a&gt; , возврат с коротким чтением не является ошибкой.</target>
        </trans-unit>
        <trans-unit id="78d8286e3fe0bd2fe84e388fefe8408d278761d1" translate="yes" xml:space="preserve">
          <source>Note that similar to &lt;a href=&quot;../../../fs/struct.file#method.write&quot;&gt;&lt;code&gt;File::write&lt;/code&gt;&lt;/a&gt;, it is not an error to return a short write.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="18a21f083a37ce3c0667ef89806f56b48c052291" translate="yes" xml:space="preserve">
          <source>Note that similar to &lt;a href=&quot;../../../fs/struct.file#write.v&quot;&gt;&lt;code&gt;File::write&lt;/code&gt;&lt;/a&gt;, it is not an error to return a short write.</source>
          <target state="translated">Обратите внимание, что, как и в случае с &lt;a href=&quot;../../../fs/struct.file#write.v&quot;&gt; &lt;code&gt;File::write&lt;/code&gt; &lt;/a&gt; , возврат короткой записи не является ошибкой.</target>
        </trans-unit>
        <trans-unit id="c9ab4b26c6a7bf726c988738e7c68f1f0c9fa972" translate="yes" xml:space="preserve">
          <source>Note that similar to &lt;code&gt;File::read&lt;/code&gt;, it is not an error to return with a short read. When returning from such a short read, the file pointer is still updated.</source>
          <target state="translated">Обратите внимание, что, как и в случае с &lt;code&gt;File::read&lt;/code&gt; , возврат с коротким чтением не является ошибкой. При возврате из такого короткого чтения указатель файла все еще обновляется.</target>
        </trans-unit>
        <trans-unit id="1f1bfbbca00b5726c71935536de215a864a82741" translate="yes" xml:space="preserve">
          <source>Note that similar to &lt;code&gt;File::write&lt;/code&gt;, it is not an error to return a short write. When returning from such a short write, the file pointer is still updated.</source>
          <target state="translated">Обратите внимание, что, как и в случае с &lt;code&gt;File::write&lt;/code&gt; , возврат короткой записи не является ошибкой. При возврате из такой короткой записи указатель файла все еще обновляется.</target>
        </trans-unit>
        <trans-unit id="eea44851a548460d198f033df0aa2c78011af765" translate="yes" xml:space="preserve">
          <source>Note that some platforms may simply implement this in terms of &lt;a href=&quot;struct.file#method.sync_all&quot;&gt;&lt;code&gt;sync_all&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Обратите внимание, что некоторые платформы могут просто реализовать это в терминах &lt;a href=&quot;struct.file#method.sync_all&quot;&gt; &lt;code&gt;sync_all&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="903a64802e8ba87174caa993876c0922efd29b51" translate="yes" xml:space="preserve">
          <source>Note that stdout is frequently line-buffered by default so it may be necessary to use &lt;a href=&quot;io/trait.write#tymethod.flush&quot;&gt;&lt;code&gt;io::stdout().flush()&lt;/code&gt;&lt;/a&gt; to ensure the output is emitted immediately.</source>
          <target state="translated">Обратите внимание, что stdout часто по умолчанию буферизуется по строкам, поэтому может потребоваться использовать &lt;a href=&quot;io/trait.write#tymethod.flush&quot;&gt; &lt;code&gt;io::stdout().flush()&lt;/code&gt; &lt;/a&gt; чтобы обеспечить немедленную выдачу вывода.</target>
        </trans-unit>
        <trans-unit id="b78b962ade7d55d80fe60c36c51b53741b559cf7" translate="yes" xml:space="preserve">
          <source>Note that thanks to Rust's safety guarantees, accessing global (static) variables requires &lt;code&gt;unsafe&lt;/code&gt; code, assuming we don't use any of the synchronization primitives in this module.</source>
          <target state="translated">Обратите внимание, что благодаря гарантиям безопасности Rust для доступа к глобальным (статическим) переменным требуется &lt;code&gt;unsafe&lt;/code&gt; код, если мы не используем какие-либо примитивы синхронизации в этом модуле.</target>
        </trans-unit>
        <trans-unit id="7e334bbf7d2932e1e0dab50b1bbb42d3e778d93e" translate="yes" xml:space="preserve">
          <source>Note that the &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; and &lt;code&gt;||&lt;/code&gt; operators short-circuit, i.e., they only evaluate their second operand if it contributes to the result. Since this behavior is not enforceable by traits, &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; and &lt;code&gt;||&lt;/code&gt; are not supported as overloadable operators.</source>
          <target state="translated">Обратите внимание, что &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; и &lt;code&gt;||&lt;/code&gt; операторы сокращают замыкание, т. е. они оценивают свой второй операнд только в том случае, если он влияет на результат. Так как это поведение не может быть обеспечено с помощью трейтов, &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; и &lt;code&gt;||&lt;/code&gt; не поддерживаются как перегружаемые операторы.</target>
        </trans-unit>
        <trans-unit id="eabb54c531ee493a23016d47151401e59c37e082" translate="yes" xml:space="preserve">
          <source>Note that the &lt;code&gt;*&lt;/code&gt; operator is replaced with a call to the &lt;code&gt;deref&lt;/code&gt; method and then a call to the &lt;code&gt;*&lt;/code&gt; operator just once, each time we use a &lt;code&gt;*&lt;/code&gt; in our code. Because the substitution of the &lt;code&gt;*&lt;/code&gt; operator does not recurse infinitely, we end up with data of type &lt;code&gt;i32&lt;/code&gt;, which matches the &lt;code&gt;5&lt;/code&gt; in &lt;code&gt;assert_eq!&lt;/code&gt; in Listing 15-9.</source>
          <target state="translated">Обратите внимание, что оператор &lt;code&gt;*&lt;/code&gt; заменяется вызовом метода &lt;code&gt;deref&lt;/code&gt; , а затем вызовом оператора &lt;code&gt;*&lt;/code&gt; только один раз, каждый раз, когда мы используем &lt;code&gt;*&lt;/code&gt; в нашем коде. Поскольку подстановка оператора &lt;code&gt;*&lt;/code&gt; не повторяется бесконечно, мы получаем данные типа &lt;code&gt;i32&lt;/code&gt; , которые соответствуют &lt;code&gt;5&lt;/code&gt; в &lt;code&gt;assert_eq!&lt;/code&gt; в Листинге 15-9.</target>
        </trans-unit>
        <trans-unit id="42a41979051d804f1901f27167063da0694efa1d" translate="yes" xml:space="preserve">
          <source>Note that the &lt;code&gt;Backtrace::force_capture&lt;/code&gt; function can be used to ignore these environment variables. Also note that the state of environment variables is cached once the first backtrace is created, so altering &lt;code&gt;RUST_LIB_BACKTRACE&lt;/code&gt; or &lt;code&gt;RUST_BACKTRACE&lt;/code&gt; at runtime may not actually change how backtraces are captured.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2c6dbff824203032252330e130f2e622a82a7979" translate="yes" xml:space="preserve">
          <source>Note that the &lt;code&gt;FromFn&lt;/code&gt; iterator doesn&amp;rsquo;t make assumptions about the behavior of the closure, and therefore conservatively does not implement &lt;a href=&quot;trait.fusediterator&quot;&gt;&lt;code&gt;FusedIterator&lt;/code&gt;&lt;/a&gt;, or override &lt;a href=&quot;trait.iterator#method.size_hint&quot;&gt;&lt;code&gt;Iterator::size_hint()&lt;/code&gt;&lt;/a&gt; from its default &lt;code&gt;(0, None)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8f63b935f8ce4492cffe03bd17e920a6c5bccf71" translate="yes" xml:space="preserve">
          <source>Note that the &lt;code&gt;FromFn&lt;/code&gt; iterator doesn&amp;rsquo;t make assumptions about the behavior of the closure, and therefore conservatively does not implement &lt;a href=&quot;trait.fusediterator&quot;&gt;&lt;code&gt;FusedIterator&lt;/code&gt;&lt;/a&gt;, or override &lt;a href=&quot;trait.iterator#method.size_hint&quot;&gt;&lt;code&gt;Iterator::size_hint&lt;/code&gt;&lt;/a&gt; from its default &lt;code&gt;(0, None)&lt;/code&gt;.</source>
          <target state="translated">Обратите внимание, что итератор &lt;code&gt;FromFn&lt;/code&gt; не делает предположений о поведении замыкания и поэтому консервативно не реализует &lt;a href=&quot;trait.fusediterator&quot;&gt; &lt;code&gt;FusedIterator&lt;/code&gt; &lt;/a&gt; и не переопределяет &lt;a href=&quot;trait.iterator#method.size_hint&quot;&gt; &lt;code&gt;Iterator::size_hint&lt;/code&gt; &lt;/a&gt; умолчанию &lt;code&gt;(0, None)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="bea015d687dff2009a1239b5a7393bd8adb473e8" translate="yes" xml:space="preserve">
          <source>Note that the &lt;code&gt;PrimaryColor&lt;/code&gt; and &lt;code&gt;SecondaryColor&lt;/code&gt; types aren&amp;rsquo;t listed on the front page, nor is the &lt;code&gt;mix&lt;/code&gt; function. We have to click &lt;code&gt;kinds&lt;/code&gt; and &lt;code&gt;utils&lt;/code&gt; to see them.</source>
          <target state="translated">Обратите внимание, что &lt;code&gt;PrimaryColor&lt;/code&gt; и &lt;code&gt;SecondaryColor&lt;/code&gt; не указаны на первой странице, как и функция &lt;code&gt;mix&lt;/code&gt; . Чтобы увидеть их, нужно щелкнуть по &lt;code&gt;kinds&lt;/code&gt; и &lt;code&gt;utils&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8f49c43ce4bf9debfde5b04db98c0212ba6c8e15" translate="yes" xml:space="preserve">
          <source>Note that the &lt;code&gt;SOME_PROPERTY&lt;/code&gt; associated constant would not compile, as its type &lt;code&gt;bool&lt;/code&gt; refers to the struct, rather than to the primitive bool type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="659da6617a0c6362038e0166dcdb0fdd380d7b37" translate="yes" xml:space="preserve">
          <source>Note that the &lt;code&gt;black&lt;/code&gt; and &lt;code&gt;origin&lt;/code&gt; values are different types, because they&amp;rsquo;re instances of different tuple structs. Each struct you define is its own type, even though the fields within the struct have the same types. For example, a function that takes a parameter of type &lt;code&gt;Color&lt;/code&gt; cannot take a &lt;code&gt;Point&lt;/code&gt; as an argument, even though both types are made up of three &lt;code&gt;i32&lt;/code&gt; values. Otherwise, tuple struct instances behave like tuples: you can destructure them into their individual pieces, you can use a &lt;code&gt;.&lt;/code&gt; followed by the index to access an individual value, and so on.</source>
          <target state="translated">Обратите внимание, что значения &lt;code&gt;black&lt;/code&gt; и &lt;code&gt;origin&lt;/code&gt; относятся к разным типам, потому что они являются экземплярами разных структур кортежей. Каждая определяемая вами структура имеет собственный тип, даже если поля в структуре имеют одинаковые типы. Например, функция, которая принимает параметр типа &lt;code&gt;Color&lt;/code&gt; , не может принимать &lt;code&gt;Point&lt;/code&gt; в качестве аргумента, даже если оба типа состоят из трех значений &lt;code&gt;i32&lt;/code&gt; . В противном случае экземпляры структуры кортежа ведут себя как кортежи: вы можете разложить их на отдельные части, вы можете использовать файл &lt;code&gt;.&lt;/code&gt; за которым следует индекс для доступа к отдельному значению и т. д.</target>
        </trans-unit>
        <trans-unit id="7585cdf9a53bb6203f72700ad7d5c4700090428d" translate="yes" xml:space="preserve">
          <source>Note that the &lt;code&gt;internal_adder&lt;/code&gt; function is not marked as &lt;code&gt;pub&lt;/code&gt;, but because tests are just Rust code and the &lt;code&gt;tests&lt;/code&gt; module is just another module, you can bring &lt;code&gt;internal_adder&lt;/code&gt; into a test&amp;rsquo;s scope and call it. If you don&amp;rsquo;t think private functions should be tested, there&amp;rsquo;s nothing in Rust that will compel you to do so.</source>
          <target state="translated">Обратите внимание, что функция &lt;code&gt;internal_adder&lt;/code&gt; не помечена как &lt;code&gt;pub&lt;/code&gt; , но поскольку тесты - это просто код Rust, а модуль &lt;code&gt;tests&lt;/code&gt; - просто еще один модуль, вы можете перенести &lt;code&gt;internal_adder&lt;/code&gt; в область проверки и вызвать его. Если вы не думаете, что частные функции следует тестировать, в Rust нет ничего, что заставило бы вас это делать.</target>
        </trans-unit>
        <trans-unit id="1dfcc45249eab2386a4a77c00ed86344264ef031" translate="yes" xml:space="preserve">
          <source>Note that the &lt;code&gt;mod common;&lt;/code&gt; declaration is the same as the module declaration we demonstrated in Listing 7-21. Then in the test function, we can call the &lt;code&gt;common::setup()&lt;/code&gt; function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2416a0788bd332296b9d3351af29231165e12f7f" translate="yes" xml:space="preserve">
          <source>Note that the &lt;code&gt;mod common;&lt;/code&gt; declaration is the same as the module declaration we demonstrated in Listing 7-25. Then in the test function, we can call the &lt;code&gt;common::setup()&lt;/code&gt; function.</source>
          <target state="translated">Обратите внимание, что &lt;code&gt;mod common;&lt;/code&gt; объявление такое же, как объявление модуля, которое мы продемонстрировали в листинге 7-25. Затем в тестовой функции мы можем вызвать функцию &lt;code&gt;common::setup()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3b202266f93986284846e418aa656da415bb5e7b" translate="yes" xml:space="preserve">
          <source>Note that the &lt;code&gt;pub use crate::front_of_house::hosting&lt;/code&gt; statement in &lt;em&gt;src/lib.rs&lt;/em&gt; also hasn&amp;rsquo;t changed, nor does &lt;code&gt;use&lt;/code&gt; have any impact on what files are compiled as part of the crate. The &lt;code&gt;mod&lt;/code&gt; keyword declares modules, and Rust looks in a file with the same name as the module for the code that goes into that module.</source>
          <target state="translated">Обратите внимание, что оператор &lt;code&gt;pub use crate::front_of_house::hosting&lt;/code&gt; в &lt;em&gt;src / lib.rs&lt;/em&gt; также не изменился, и при этом &lt;code&gt;use&lt;/code&gt; не влияет на то, какие файлы компилируются как часть ящика. &lt;code&gt;mod&lt;/code&gt; ключевое слово объявляет модули, и Руст смотрит в файл с тем же именем, что и модуль для кода , который входит в этот модуль.</target>
        </trans-unit>
        <trans-unit id="ebf0b34b8114310255f844126e635bca0217f44d" translate="yes" xml:space="preserve">
          <source>Note that the Rust syntax considers &lt;code&gt;-1i8&lt;/code&gt; as an application of the &lt;a href=&quot;expressions/operator-expr#negation-operators&quot;&gt;unary minus operator&lt;/a&gt; to an integer literal &lt;code&gt;1i8&lt;/code&gt;, rather than a single integer literal.</source>
          <target state="translated">Обратите внимание, что синтаксис Rust рассматривает &lt;code&gt;-1i8&lt;/code&gt; как приложение &lt;a href=&quot;expressions/operator-expr#negation-operators&quot;&gt;унарного оператора минус&lt;/a&gt; к целочисленному &lt;code&gt;1i8&lt;/code&gt; , а не к одному целочисленному литералу .</target>
        </trans-unit>
        <trans-unit id="56aae01ce79d910a619efda10dafe9ed6c6133a8" translate="yes" xml:space="preserve">
          <source>Note that the alignment of the resulting layout will be the maximum of those of &lt;code&gt;self&lt;/code&gt; and &lt;code&gt;next&lt;/code&gt;, in order to ensure alignment of both parts.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d7d6c6c7cc7587fa146a6b97e717ca83d5839bcb" translate="yes" xml:space="preserve">
          <source>Note that the allocator may give the collection more space than it requests. Therefore capacity can not be relied upon to be precisely minimal. Prefer &lt;a href=&quot;#method.reserve&quot;&gt;&lt;code&gt;reserve&lt;/code&gt;&lt;/a&gt; if future insertions are expected.</source>
          <target state="translated">Обратите внимание, что распределитель может предоставить коллекции больше места, чем она запрашивает. Поэтому нельзя полагаться на то, что мощность будет точно минимальной. Предпочтите &lt;a href=&quot;#method.reserve&quot;&gt; &lt;code&gt;reserve&lt;/code&gt; &lt;/a&gt; если ожидаются будущие вставки.</target>
        </trans-unit>
        <trans-unit id="3c27c4a17236d84a273debe0206e2acee86fe4f0" translate="yes" xml:space="preserve">
          <source>Note that the allocator may give the collection more space than it requests. Therefore capacity can not be relied upon to be precisely minimal. Prefer &lt;a href=&quot;../struct.binaryheap#method.reserve&quot;&gt;&lt;code&gt;reserve&lt;/code&gt;&lt;/a&gt; if future insertions are expected.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0b0700ca055cbce179ecc3d9a30bb5baa7a6c28e" translate="yes" xml:space="preserve">
          <source>Note that the allocator may give the collection more space than it requests. Therefore capacity can not be relied upon to be precisely minimal. Prefer &lt;a href=&quot;../struct.vecdeque#method.reserve&quot;&gt;&lt;code&gt;reserve&lt;/code&gt;&lt;/a&gt; if future insertions are expected.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="088614193a26ec5fa144e1468834aa2d40a502e0" translate="yes" xml:space="preserve">
          <source>Note that the allocator may give the collection more space than it requests. Therefore capacity can not be relied upon to be precisely minimal. Prefer &lt;a href=&quot;struct.binaryheap#method.reserve&quot;&gt;&lt;code&gt;reserve&lt;/code&gt;&lt;/a&gt; if future insertions are expected.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e71fe50cc784bf479a83f567c5fb33ac0db88d1d" translate="yes" xml:space="preserve">
          <source>Note that the allocator may give the collection more space than it requests. Therefore capacity can not be relied upon to be precisely minimal. Prefer &lt;a href=&quot;struct.vecdeque#method.reserve&quot;&gt;&lt;code&gt;reserve&lt;/code&gt;&lt;/a&gt; if future insertions are expected.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e47a0cb986bfab2cf7630c87b9673550639fc541" translate="yes" xml:space="preserve">
          <source>Note that the allocator may give the collection more space than it requests. Therefore, capacity can not be relied upon to be precisely minimal. Prefer &lt;code&gt;reserve&lt;/code&gt; if future insertions are expected.</source>
          <target state="translated">Обратите внимание, что распределитель может предоставить коллекции больше места, чем она запрашивает. Таким образом, нельзя полагаться на то, что мощность будет минимальной. Предпочтите &lt;code&gt;reserve&lt;/code&gt; если ожидаются будущие вставки.</target>
        </trans-unit>
        <trans-unit id="a8effc4910252eded99b791d1c4a5c812a34bdf2" translate="yes" xml:space="preserve">
          <source>Note that the allocator may give the collection more space than it requests. Therefore, capacity can not be relied upon to be precisely minimal. Prefer reserve if future insertions are expected.</source>
          <target state="translated">Обратите внимание,что аллокатор может предоставить коллекции больше места,чем она запрашивает.Поэтому на вместимость нельзя полагаться,чтобы она была точно минимальной.Предпочтителено резервирование,если ожидаются будущие вставки.</target>
        </trans-unit>
        <trans-unit id="08c862951a6a3b03e0330454b0efc29b2b754947" translate="yes" xml:space="preserve">
          <source>Note that the argument is not passed through a shell, but given literally to the program. This means that shell syntax like quotes, escaped characters, word splitting, glob patterns, substitution, etc. have no effect.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ba0769350c5d5d78015e993d43a239511a252097" translate="yes" xml:space="preserve">
          <source>Note that the arguments are not passed through a shell, but given literally to the program. This means that shell syntax like quotes, escaped characters, word splitting, glob patterns, substitution, etc. have no effect.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e7c41ef52ce2694587693c73f46ceb1c3c96783c" translate="yes" xml:space="preserve">
          <source>Note that the best effort is made to ensure that the time waited is measured with a monotonic clock, and not affected by the changes made to the system time.</source>
          <target state="translated">Обратите внимание,что максимальные усилия прилагаются для того,чтобы ожидаемое время измерялось с помощью монотонных часов,и на него не влияли изменения,вносимые в системное время.</target>
        </trans-unit>
        <trans-unit id="0ef4b3d8d9fa38a1ed8bb900aa8106bdb93d4e77" translate="yes" xml:space="preserve">
          <source>Note that the best effort is made to ensure that the time waited is measured with a monotonic clock, and not affected by the changes made to the system time. This function is susceptible to spurious wakeups. Condition variables normally have a boolean predicate associated with them, and the predicate must always be checked each time this function returns to protect against spurious wakeups. Additionally, it is typically desirable for the time-out to not exceed some duration in spite of spurious wakes, thus the sleep-duration is decremented by the amount slept. Alternatively, use the &lt;code&gt;wait_timeout_until&lt;/code&gt; method to wait until a condition is met with a total time-out regardless of spurious wakes.</source>
          <target state="translated">Обратите внимание, что прилагаются все усилия, чтобы гарантировать, что время ожидания измеряется с помощью монотонных часов и не зависит от изменений, внесенных в системное время. Эта функция подвержена ложным срабатываниям. Переменные условия обычно имеют связанный с ними логический предикат, и этот предикат всегда должен проверяться каждый раз, когда эта функция возвращается, чтобы защитить от ложного пробуждения. Кроме того, обычно желательно, чтобы тайм-аут не превышал некоторой продолжительности, несмотря на ложные пробуждения, таким образом, продолжительность сна уменьшается на количество сна. В качестве альтернативы можно использовать метод &lt;code&gt;wait_timeout_until&lt;/code&gt; , чтобы дождаться выполнения условия с общим тайм-аутом, независимо от ложных пробуждений.</target>
        </trans-unit>
        <trans-unit id="a6a58cc27a5e657fb0a670643552701080e58296" translate="yes" xml:space="preserve">
          <source>Note that the best effort is made to ensure that the time waited is measured with a monotonic clock, and not affected by the changes made to the system time. This function is susceptible to spurious wakeups. Condition variables normally have a boolean predicate associated with them, and the predicate must always be checked each time this function returns to protect against spurious wakeups. Additionally, it is typically desirable for the timeout to not exceed some duration in spite of spurious wakes, thus the sleep-duration is decremented by the amount slept. Alternatively, use the &lt;code&gt;wait_timeout_while&lt;/code&gt; method to wait with a timeout while a predicate is true.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4f53fcb70ba490adf24ce12bac9972be4901a158" translate="yes" xml:space="preserve">
          <source>Note that the capacity of &lt;code&gt;self&lt;/code&gt; does not change.</source>
          <target state="translated">Обратите внимание, что способность к &lt;code&gt;self&lt;/code&gt; не меняется.</target>
        </trans-unit>
        <trans-unit id="e939a8d32c47b3615c351b8f5ecdfdb4467cf4dc" translate="yes" xml:space="preserve">
          <source>Note that the entire instance must be mutable; Rust doesn&amp;rsquo;t allow us to mark only certain fields as mutable. As with any expression, we can construct a new instance of the struct as the last expression in the function body to implicitly return that new instance.</source>
          <target state="translated">Обратите внимание, что весь экземпляр должен быть изменяемым; Rust не позволяет нам помечать только определенные поля как изменяемые. Как и в случае с любым выражением, мы можем создать новый экземпляр структуры в качестве последнего выражения в теле функции, чтобы неявно вернуть этот новый экземпляр.</target>
        </trans-unit>
        <trans-unit id="893d3a404a478f2bef24f1a4da4b0eecf6cccd02" translate="yes" xml:space="preserve">
          <source>Note that the error here is in the definition of the generic function: Although we only call it with a parameter that does implement &lt;code&gt;Debug&lt;/code&gt;, the compiler still rejects the function: It must work with all possible input types. In order to make this example compile, we need to restrict the generic type we're accepting:</source>
          <target state="translated">Обратите внимание, что ошибка здесь в определении универсальной функции: хотя мы вызываем ее только с параметром, реализующим &lt;code&gt;Debug&lt;/code&gt; , компилятор все равно отклоняет функцию: она должна работать со всеми возможными типами ввода. Чтобы скомпилировать этот пример, нам нужно ограничить общий тип, который мы принимаем:</target>
        </trans-unit>
        <trans-unit id="06b34748b35f43179a334f500ab5063640caf614" translate="yes" xml:space="preserve">
          <source>Note that the expanded results of the input tokens may change in the future. You should be careful if you rely on the output.</source>
          <target state="translated">Обратите внимание,что расширенные результаты маркеров ввода могут измениться в будущем.Вы должны быть осторожны,если полагаетесь на результат.</target>
        </trans-unit>
        <trans-unit id="b4d3e131a7a31ae2f39a3a9a0dd9a292fd33ee3f" translate="yes" xml:space="preserve">
          <source>Note that the innermost object sets the bound, so &lt;code&gt;&amp;amp;'a Box&amp;lt;dyn Foo&amp;gt;&lt;/code&gt; is still &lt;code&gt;&amp;amp;'a Box&amp;lt;dyn Foo + 'static&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">Обратите внимание, что самый внутренний объект устанавливает границу, поэтому &lt;code&gt;&amp;amp;'a Box&amp;lt;dyn Foo&amp;gt;&lt;/code&gt; по-прежнему &lt;code&gt;&amp;amp;'a Box&amp;lt;dyn Foo + 'static&amp;gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="20accbf3ad080e6a83efff23cbdda0ba37be7c3a" translate="yes" xml:space="preserve">
          <source>Note that the lowercase dotted 'i' is the same as the Latin. Therefore:</source>
          <target state="translated">Обратите внимание,что строчная точка &quot;i&quot; совпадает с латиницей.Поэтому:</target>
        </trans-unit>
        <trans-unit id="0529503c0b783f1fa295149899ee5a9048a3f3e4" translate="yes" xml:space="preserve">
          <source>Note that the macro is intended as a debugging tool and therefore you should avoid having uses of it in version control for long periods. Use cases involving debug output that should be added to version control are better served by macros such as &lt;a href=&quot;https://docs.rs/log/*/log/macro.debug.html&quot;&gt;&lt;code&gt;debug!&lt;/code&gt;&lt;/a&gt; from the &lt;a href=&quot;https://crates.io/crates/log&quot;&gt;&lt;code&gt;log&lt;/code&gt;&lt;/a&gt; crate.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="33af38a46c0f54bbd2f36a31035d5f75fa5f8705" translate="yes" xml:space="preserve">
          <source>Note that the macro is intended as a debugging tool and therefore you should avoid having uses of it in version control for longer periods. Use cases involving debug output that should be added to version control are better served by macros such as &lt;a href=&quot;https://docs.rs/log/*/log/macro.debug.html&quot;&gt;&lt;code&gt;debug!&lt;/code&gt;&lt;/a&gt; from the &lt;a href=&quot;https://crates.io/crates/log&quot;&gt;&lt;code&gt;log&lt;/code&gt;&lt;/a&gt; crate.</source>
          <target state="translated">Обратите внимание, что макрос предназначен как средство отладки, и поэтому вам следует избегать его использования в системе контроля версий в течение длительного времени. Сценарии использования, включающие вывод отладки, которые следует добавить в систему контроля версий, лучше обслуживаются макросами, такими как &lt;a href=&quot;https://docs.rs/log/*/log/macro.debug.html&quot;&gt; &lt;code&gt;debug!&lt;/code&gt; &lt;/a&gt;из &lt;a href=&quot;https://crates.io/crates/log&quot;&gt; &lt;code&gt;log&lt;/code&gt; &lt;/a&gt; обрешетки.</target>
        </trans-unit>
        <trans-unit id="f68f549dc0f6cc4029741bd007637b70e59d35a0" translate="yes" xml:space="preserve">
          <source>Note that the output for the tests and the test results are interleaved; the reason is that the tests are running in parallel, as we talked about in the previous section. Try using the &lt;code&gt;--test-threads=1&lt;/code&gt; option and the &lt;code&gt;--nocapture&lt;/code&gt; flag, and see what the output looks like then!</source>
          <target state="translated">Обратите внимание, что выходные данные тестов и результаты тестов чередуются; причина в том, что тесты выполняются параллельно, о чем мы говорили в предыдущем разделе. Попробуйте использовать параметр &lt;code&gt;--test-threads=1&lt;/code&gt; и флаг &lt;code&gt;--nocapture&lt;/code&gt; , и посмотрите, как будет выглядеть результат!</target>
        </trans-unit>
        <trans-unit id="a844a8727324231842256b1e8aa12a2943bbaceb" translate="yes" xml:space="preserve">
          <source>Note that the pointer value may potentially represent a valid pointer to a &lt;code&gt;T&lt;/code&gt;, which means this must not be used as a &quot;not yet initialized&quot; sentinel value. Types that lazily allocate must track initialization by some other means.</source>
          <target state="translated">Обратите внимание, что значение указателя потенциально может представлять действительный указатель на &lt;code&gt;T&lt;/code&gt; , что означает, что его нельзя использовать как &amp;laquo;еще не инициализированное&amp;raquo; контрольное значение. Типы, которые распределяются лениво, должны отслеживать инициализацию другими способами.</target>
        </trans-unit>
        <trans-unit id="219a901fc4bbd905770e11b959092de46ce1a4b3" translate="yes" xml:space="preserve">
          <source>Note that the pointer value may potentially represent a valid pointer, which means this must not be used as a &quot;not yet initialized&quot; sentinel value. Types that lazily allocate must track initialization by some other means.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3e42d22c3d181aaaed5a33c43a08345afdbe2126" translate="yes" xml:space="preserve">
          <source>Note that the stack size of the main thread is &lt;em&gt;not&lt;/em&gt; determined by Rust.</source>
          <target state="translated">Обратите внимание, что размер стека основного потока &lt;em&gt;не&lt;/em&gt; определяется Rust.</target>
        </trans-unit>
        <trans-unit id="5317fa424b787d9e3193b4c178e1e274e73ebdb4" translate="yes" xml:space="preserve">
          <source>Note that the standard library (&lt;code&gt;std&lt;/code&gt;) is also a crate that&amp;rsquo;s external to our package. Because the standard library is shipped with the Rust language, we don&amp;rsquo;t need to change &lt;em&gt;Cargo.toml&lt;/em&gt; to include &lt;code&gt;std&lt;/code&gt;. But we do need to refer to it with &lt;code&gt;use&lt;/code&gt; to bring items from there into our package&amp;rsquo;s scope. For example, with &lt;code&gt;HashMap&lt;/code&gt; we would use this line:</source>
          <target state="translated">Обратите внимание, что стандартная библиотека ( &lt;code&gt;std&lt;/code&gt; ) также является ящиком, внешним по отношению к нашему пакету. Поскольку стандартная библиотека поставляется с языком Rust, нам не нужно изменять &lt;em&gt;Cargo.toml&lt;/em&gt; для включения &lt;code&gt;std&lt;/code&gt; . Но нам действительно нужно обращаться к нему с &lt;code&gt;use&lt;/code&gt; чтобы переносить элементы оттуда в область действия нашего пакета. Например, с &lt;code&gt;HashMap&lt;/code&gt; мы могли бы использовать эту строку:</target>
        </trans-unit>
        <trans-unit id="81d14f271d71ceb8a4e63a395e2c2b18f3026e6e" translate="yes" xml:space="preserve">
          <source>Note that the traits &lt;a href=&quot;../convert/trait.asref&quot;&gt;&lt;code&gt;AsRef&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../convert/trait.asmut&quot;&gt;&lt;code&gt;AsMut&lt;/code&gt;&lt;/a&gt; provide similar methods for types that may not be fixed-size arrays. Implementors should prefer those traits instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="405821d50e551ea851eed49e6fdd0bf01f98b46a" translate="yes" xml:space="preserve">
          <source>Note that the traits AsRef and AsMut provide similar methods for types that may not be fixed-size arrays. Implementors should prefer those traits instead.</source>
          <target state="translated">Обратите внимание,что трейты AsRef и AsMut предоставляют схожие методы для типов,которые не могут быть массивами фиксированного размера.Реализаторы должны предпочитать эти трейты.</target>
        </trans-unit>
        <trans-unit id="6289f32f721dc9ae628a24b212ad3154b1e5c872" translate="yes" xml:space="preserve">
          <source>Note that the type of &lt;code&gt;v&lt;/code&gt; can now be inferred from the type of &lt;code&gt;temp&lt;/code&gt;.</source>
          <target state="translated">Обратите внимание, что тип &lt;code&gt;v&lt;/code&gt; теперь можно определить по типу &lt;code&gt;temp&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6cb7f36bf472ae404403c7eb996727201edfc32d" translate="yes" xml:space="preserve">
          <source>Note that the underlying iterator is still advanced when &lt;a href=&quot;struct.peekable#method.peek&quot;&gt;&lt;code&gt;peek&lt;/code&gt;&lt;/a&gt; is called for the first time: In order to retrieve the next element, &lt;a href=&quot;trait.iterator#tymethod.next&quot;&gt;&lt;code&gt;next&lt;/code&gt;&lt;/a&gt; is called on the underlying iterator, hence any side effects (i.e. anything other than fetching the next value) of the &lt;a href=&quot;trait.iterator#tymethod.next&quot;&gt;&lt;code&gt;next&lt;/code&gt;&lt;/a&gt; method will occur.</source>
          <target state="translated">Обратите внимание, что базовый итератор по-прежнему расширяется, когда &lt;a href=&quot;struct.peekable#method.peek&quot;&gt; &lt;code&gt;peek&lt;/code&gt; &lt;/a&gt; вызывается в первый раз: чтобы получить следующий элемент, &lt;a href=&quot;trait.iterator#tymethod.next&quot;&gt; &lt;code&gt;next&lt;/code&gt; &lt;/a&gt; вызывается на базовом итераторе, следовательно, любые побочные эффекты (т. Е. Все, кроме выборки следующего значения) &lt;a href=&quot;trait.iterator#tymethod.next&quot;&gt; &lt;code&gt;next&lt;/code&gt; &lt;/a&gt; метод произойдет.</target>
        </trans-unit>
        <trans-unit id="5e9890cf8ac181c5bdc0d2e127263d39bf20f96f" translate="yes" xml:space="preserve">
          <source>Note that the utility of the returned value requires &lt;code&gt;align&lt;/code&gt; to be less than or equal to the alignment of the starting address for the whole allocated block of memory. One way to satisfy this constraint is to ensure &lt;code&gt;align &amp;lt;= self.align()&lt;/code&gt;.</source>
          <target state="translated">Обратите внимание, что полезность возвращаемого значения требует, чтобы &lt;code&gt;align&lt;/code&gt; было меньше или равно выравниванию начального адреса для всего выделенного блока памяти. Один из способов удовлетворить это ограничение - обеспечить &lt;code&gt;align &amp;lt;= self.align()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2d911cb36c04dcf8463355e9c033efd2983dc723" translate="yes" xml:space="preserve">
          <source>Note that the variants of the enum are namespaced under its identifier, and we use a double colon to separate the two. The reason this is useful is that now both values &lt;code&gt;IpAddrKind::V4&lt;/code&gt; and &lt;code&gt;IpAddrKind::V6&lt;/code&gt; are of the same type: &lt;code&gt;IpAddrKind&lt;/code&gt;. We can then, for instance, define a function that takes any &lt;code&gt;IpAddrKind&lt;/code&gt;:</source>
          <target state="translated">Обратите внимание, что варианты перечисления помещены в пространство имен под его идентификатором, и мы используем двойное двоеточие для их разделения. Причина, по которой это полезно, заключается в том, что теперь оба значения &lt;code&gt;IpAddrKind::V4&lt;/code&gt; и &lt;code&gt;IpAddrKind::V6&lt;/code&gt; имеют один и тот же тип: &lt;code&gt;IpAddrKind&lt;/code&gt; . Затем мы можем, например, определить функцию, которая принимает любой &lt;code&gt;IpAddrKind&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="16c052a3290e3d52e2b4ef43bfa0c661287a1967" translate="yes" xml:space="preserve">
          <source>Note that there is a subtle difference between using only &lt;code&gt;_&lt;/code&gt; and using a name that starts with an underscore. The syntax &lt;code&gt;_x&lt;/code&gt; still binds the value to the variable, whereas &lt;code&gt;_&lt;/code&gt; doesn&amp;rsquo;t bind at all. To show a case where this distinction matters, Listing 18-21 will provide us with an error.</source>
          <target state="translated">Обратите внимание, что есть небольшая разница между использованием только &lt;code&gt;_&lt;/code&gt; и использованием имени, которое начинается с подчеркивания. Синтаксис &lt;code&gt;_x&lt;/code&gt; по- прежнему связывает значение с переменной, тогда как &lt;code&gt;_&lt;/code&gt; не связывает вообще. Чтобы показать случай, когда это различие имеет значение, в листинге 18-21 содержится ошибка.</target>
        </trans-unit>
        <trans-unit id="a9f69008c63ee1bbbd3dca68ce2579a7f11ccac4" translate="yes" xml:space="preserve">
          <source>Note that there is no guarantee that the file is immediately deleted (e.g., depending on platform, other open file descriptors may prevent immediate removal).</source>
          <target state="translated">Обратите внимание,что нет гарантии,что файл будет немедленно удален (например,в зависимости от платформы,другие открытые дескрипторы файлов могут препятствовать немедленному удалению).</target>
        </trans-unit>
        <trans-unit id="c1d60a1d35c01b7a3e982971929136941cc6d773" translate="yes" xml:space="preserve">
          <source>Note that there might be more than one &lt;code&gt;Reject&lt;/code&gt; between two &lt;code&gt;Match&lt;/code&gt;es, there is no requirement for them to be combined into one.</source>
          <target state="translated">Обратите внимание, что между двумя &lt;code&gt;Match&lt;/code&gt; может быть более одного &lt;code&gt;Reject&lt;/code&gt; их необязательно объединять в одно.</target>
        </trans-unit>
        <trans-unit id="66991018cda906aad5fc546c336b3be880291e4b" translate="yes" xml:space="preserve">
          <source>Note that these outputs are stackable in the sense that if multiple are specified, then the compiler will produce each form of output at once without having to recompile. However, this only applies for outputs specified by the same method. If only &lt;code&gt;crate_type&lt;/code&gt; attributes are specified, then they will all be built, but if one or more &lt;code&gt;--crate-type&lt;/code&gt; command line flags are specified, then only those outputs will be built.</source>
          <target state="translated">Обратите внимание, что эти выходные данные можно наращивать в том смысле, что, если указано несколько, компилятор будет создавать каждую форму вывода сразу без необходимости перекомпиляции. Однако это применимо только к выходам, указанным тем же методом. Если &lt;code&gt;crate_type&lt;/code&gt; только атрибуты crate_type , тогда все они будут построены, но если &lt;code&gt;--crate-type&lt;/code&gt; один или несколько флагов командной строки --crate-type , то будут построены только эти выходные данные.</target>
        </trans-unit>
        <trans-unit id="68d9fc76dd03b0153bd61663810434ccc46dcc2c" translate="yes" xml:space="preserve">
          <source>Note that these requirements mean that the trait itself must be implemented symmetrically and transitively: if &lt;code&gt;T: PartialEq&amp;lt;U&amp;gt;&lt;/code&gt; and &lt;code&gt;U: PartialEq&amp;lt;V&amp;gt;&lt;/code&gt; then &lt;code&gt;U: PartialEq&amp;lt;T&amp;gt;&lt;/code&gt; and &lt;code&gt;T: PartialEq&amp;lt;V&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">Обратите внимание, что эти требования означают, что сам &lt;code&gt;T: PartialEq&amp;lt;U&amp;gt;&lt;/code&gt; должен быть реализован симметрично и транзитивно: если T: PartialEq &amp;lt;U&amp;gt; и &lt;code&gt;U: PartialEq&amp;lt;V&amp;gt;&lt;/code&gt; то &lt;code&gt;U: PartialEq&amp;lt;T&amp;gt;&lt;/code&gt; и &lt;code&gt;T: PartialEq&amp;lt;V&amp;gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="68c8d8134a3ad3fb6c3b8c1e1d2d42e5a3391556" translate="yes" xml:space="preserve">
          <source>Note that these requirements mean that the trait itself must be implemented symmetrically and transitively: if &lt;code&gt;T: PartialOrd&amp;lt;U&amp;gt;&lt;/code&gt; and &lt;code&gt;U: PartialOrd&amp;lt;V&amp;gt;&lt;/code&gt; then &lt;code&gt;U: PartialOrd&amp;lt;T&amp;gt;&lt;/code&gt; and &lt;code&gt;T: PartialOrd&amp;lt;V&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">Обратите внимание, что эти требования означают, что сам &lt;code&gt;T: PartialOrd&amp;lt;U&amp;gt;&lt;/code&gt; должен быть реализован симметрично и транзитивно: если T: PartialOrd &amp;lt;U&amp;gt; и &lt;code&gt;U: PartialOrd&amp;lt;V&amp;gt;&lt;/code&gt; то &lt;code&gt;U: PartialOrd&amp;lt;T&amp;gt;&lt;/code&gt; и &lt;code&gt;T: PartialOrd&amp;lt;V&amp;gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0a875078880a05f44d1479047dbce85f081dc8bf" translate="yes" xml:space="preserve">
          <source>Note that this &lt;code&gt;let&lt;/code&gt; statement means &lt;code&gt;expensive_closure&lt;/code&gt; contains the &lt;em&gt;definition&lt;/em&gt; of an anonymous function, not the &lt;em&gt;resulting value&lt;/em&gt; of calling the anonymous function. Recall that we&amp;rsquo;re using a closure because we want to define the code to call at one point, store that code, and call it at a later point; the code we want to call is now stored in &lt;code&gt;expensive_closure&lt;/code&gt;.</source>
          <target state="translated">Обратите внимание на то, что этот оператор &lt;code&gt;let&lt;/code&gt; означает, что &amp;laquo; &lt;code&gt;expensive_closure&lt;/code&gt; содержит &lt;em&gt;определение&lt;/em&gt; анонимной функции, а не &lt;em&gt;результирующее значение&lt;/em&gt; вызова анонимной функции. Напомним, что мы используем замыкание, потому что хотим определить код для вызова в одной точке, сохранить этот код и вызвать его позже; код, который мы хотим вызвать, теперь хранится в &lt;code&gt;expensive_closure&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f79a43777883bf04ed897be6d605f1d017ef8797" translate="yes" xml:space="preserve">
          <source>Note that this approach needs a reference to S with lifetime &lt;code&gt;'a&lt;/code&gt;. Nothing shorter than &lt;code&gt;'a&lt;/code&gt; will suffice: a shorter lifetime would imply that after &lt;code&gt;demo&lt;/code&gt; finishes executing, something else (such as the destructor!) could access &lt;code&gt;s.data&lt;/code&gt; after the end of that shorter lifetime, which would again violate the &lt;code&gt;&amp;amp;mut&lt;/code&gt;-borrow's exclusive access.</source>
          <target state="translated">Обратите внимание, что этот подход требует ссылки на S со временем жизни &lt;code&gt;'a&lt;/code&gt; . Ничего короче, чем &lt;code&gt;'a&lt;/code&gt; , будет достаточно: более короткое время жизни будет означать, что после завершения &lt;code&gt;demo&lt;/code&gt; что-то еще (например, деструктор!) &lt;code&gt;s.data&lt;/code&gt; получить доступ к s.data после окончания этого более короткого времени жизни, что снова нарушит исключительное свойство &lt;code&gt;&amp;amp;mut&lt;/code&gt; -borrow. доступ.</target>
        </trans-unit>
        <trans-unit id="c27fe5a5d1e022b605f9e160ee6f188847c0730a" translate="yes" xml:space="preserve">
          <source>Note that this behavior is a consequence of the desugaring to a function that returns an &lt;code&gt;impl Future&lt;/code&gt; -- in this case, the function we desugar to is an &lt;code&gt;unsafe&lt;/code&gt; function, but the return value remains the same.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d559316d5513a320d9bd5dde1c5db0aa4a3ef581" translate="yes" xml:space="preserve">
          <source>Note that this differs from the behavior of &lt;a href=&quot;../rc/struct.rc#method.make_mut&quot;&gt;&lt;code&gt;Rc::make_mut&lt;/code&gt;&lt;/a&gt; which disassociates any remaining &lt;code&gt;Weak&lt;/code&gt; pointers.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3192c9f3997431085906a96d26c01c024cf3788d" translate="yes" xml:space="preserve">
          <source>Note that this does &lt;strong&gt;not&lt;/strong&gt; return the number of bytes in the string in OS string form.</source>
          <target state="translated">Обратите внимание, что это &lt;strong&gt;не&lt;/strong&gt; возвращает количество байтов в строке в строковой форме ОС.</target>
        </trans-unit>
        <trans-unit id="80ff79baf2f49c9d290848de9fb000d654394ab7" translate="yes" xml:space="preserve">
          <source>Note that this does not move &lt;code&gt;v&lt;/code&gt; (unlike &lt;code&gt;transmute&lt;/code&gt;), and may need a call to &lt;code&gt;mem::forget(v)&lt;/code&gt; in case you want to avoid destructors being called.</source>
          <target state="translated">Обратите внимание, что это не перемещает &lt;code&gt;v&lt;/code&gt; (в отличие от &lt;code&gt;transmute&lt;/code&gt; ), и может потребоваться вызов &lt;code&gt;mem::forget(v)&lt;/code&gt; в случае, если вы хотите избежать вызова деструкторов.</target>
        </trans-unit>
        <trans-unit id="7810f8cddc029bde853e42fc348f1144623db2c4" translate="yes" xml:space="preserve">
          <source>Note that this example uses &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; and not &lt;code&gt;Arc&amp;lt;T&amp;gt;&lt;/code&gt;. &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt;s are for single-threaded scenarios. Consider using &lt;code&gt;RwLock&amp;lt;T&amp;gt;&lt;/code&gt; or &lt;code&gt;Mutex&amp;lt;T&amp;gt;&lt;/code&gt; if you need shared mutability in a multi-threaded situation.</source>
          <target state="translated">Обратите внимание, что в этом примере используется &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; а не &lt;code&gt;Arc&amp;lt;T&amp;gt;&lt;/code&gt; . &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt; предназначены для однопоточных сценариев. Рассмотрите возможность использования &lt;code&gt;RwLock&amp;lt;T&amp;gt;&lt;/code&gt; или &lt;code&gt;Mutex&amp;lt;T&amp;gt;&lt;/code&gt; если вам нужна общая изменчивость в многопоточной ситуации.</target>
        </trans-unit>
        <trans-unit id="cdd8e4eb74f462e708e2264904eba6fd4dc6a6a0" translate="yes" xml:space="preserve">
          <source>Note that this example won&amp;rsquo;t compile just yet; we&amp;rsquo;ll explain why in a bit.</source>
          <target state="translated">Обратите внимание, что этот пример пока не компилируется; мы объясним почему позже.</target>
        </trans-unit>
        <trans-unit id="5bd9e1731fac8ae0cac27d3b3c2a1bac0e799687" translate="yes" xml:space="preserve">
          <source>Note that this function &lt;strong&gt;may not catch all panics&lt;/strong&gt; in Rust. A panic in Rust is not always implemented via unwinding, but can be implemented by aborting the process as well. This function &lt;em&gt;only&lt;/em&gt; catches unwinding panics, not those that abort the process.</source>
          <target state="translated">Обратите внимание, что эта функция &lt;strong&gt;может не улавливать все паники&lt;/strong&gt; в Rust. Паника в Rust не всегда реализуется через раскручивание, но также может быть реализована путем прерывания процесса. Эта функция перехватывает &lt;em&gt;только&lt;/em&gt; панику при раскручивании, но не прерывание процесса.</target>
        </trans-unit>
        <trans-unit id="d3651367d7bc20ea65e217082fe9e78b8f819776" translate="yes" xml:space="preserve">
          <source>Note that this function does not always agree with the &lt;a href=&quot;cmp/trait.partialord&quot;&gt;&lt;code&gt;PartialOrd&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;cmp/trait.partialeq&quot;&gt;&lt;code&gt;PartialEq&lt;/code&gt;&lt;/a&gt; implementations of &lt;code&gt;f32&lt;/code&gt;. In particular, they regard negative and positive zero as equal, while &lt;code&gt;total_cmp&lt;/code&gt; doesn't.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2d6a1415dd489b9fd2f261b68de74159561b45e0" translate="yes" xml:space="preserve">
          <source>Note that this function does not always agree with the &lt;a href=&quot;cmp/trait.partialord&quot;&gt;&lt;code&gt;PartialOrd&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;cmp/trait.partialeq&quot;&gt;&lt;code&gt;PartialEq&lt;/code&gt;&lt;/a&gt; implementations of &lt;code&gt;f64&lt;/code&gt;. In particular, they regard negative and positive zero as equal, while &lt;code&gt;total_cmp&lt;/code&gt; doesn't.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="19f0a1a5449c981a5e246c3b5e6a9fcf303b7fa2" translate="yes" xml:space="preserve">
          <source>Note that this function is distinct from &lt;code&gt;as&lt;/code&gt; casting, which attempts to preserve the &lt;em&gt;numeric&lt;/em&gt; value, and not the bitwise value.</source>
          <target state="translated">Обратите внимание , что эта функция отличается от , &lt;code&gt;as&lt;/code&gt; отливки, которая пытается сохранить &lt;em&gt;числовое&lt;/em&gt; значение, а не значение побитового.</target>
        </trans-unit>
        <trans-unit id="d63eb9d4a24784000530071fbe51104de3bf3f2c" translate="yes" xml:space="preserve">
          <source>Note that this function is same as &lt;a href=&quot;#method.extend&quot;&gt;&lt;code&gt;extend&lt;/code&gt;&lt;/a&gt; except that it is specialized to work with slices instead. If and when Rust gets specialization this function will likely be deprecated (but still available).</source>
          <target state="translated">Обратите внимание, что эта функция аналогична &lt;a href=&quot;#method.extend&quot;&gt; &lt;code&gt;extend&lt;/code&gt; &lt;/a&gt; за исключением того, что она специализируется на работе с срезами. Если и когда Rust получит специализацию, эта функция, вероятно, станет устаревшей (но все еще будет доступна).</target>
        </trans-unit>
        <trans-unit id="0f406b6d417033b808228cce14b8dbb1120d5c7d" translate="yes" xml:space="preserve">
          <source>Note that this function is same as &lt;a href=&quot;struct.vec#method.extend&quot;&gt;&lt;code&gt;extend&lt;/code&gt;&lt;/a&gt; except that it is specialized to work with slices instead. If and when Rust gets specialization this function will likely be deprecated (but still available).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="65def495fd9076c99d32e3ed9abc467516100c9b" translate="yes" xml:space="preserve">
          <source>Note that this function is susceptible to spurious wakeups. Condition variables normally have a boolean predicate associated with them, and the predicate must always be checked each time this function returns to protect against spurious wakeups.</source>
          <target state="translated">Обратите внимание,что эта функция подвержена поддельным пробуждениям.Переменные условий обычно имеют связанный с ними булевый предикат,и предикат всегда должен проверяться каждый раз,когда эта функция возвращается для защиты от поддельных пробуждений.</target>
        </trans-unit>
        <trans-unit id="313e92b88c0b90cea2623eaa38278951f5c4defe" translate="yes" xml:space="preserve">
          <source>Note that this function may block the current thread while resolution is performed.</source>
          <target state="translated">Обратите внимание,что эта функция может блокировать текущий поток при выполнении разрешения.</target>
        </trans-unit>
        <trans-unit id="380b102b57d47b1e80ead440741eb736cbc5acae" translate="yes" xml:space="preserve">
          <source>Note that this function returns NaN if the initial value was NaN as well.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="041273b62662865c4b0b3972fa9f215d6a183216" translate="yes" xml:space="preserve">
          <source>Note that this is &lt;em&gt;also&lt;/em&gt; different from Windows-1252 a.k.a. code page 1252, which is a superset ISO/IEC 8859-1 that assigns some (not all!) blanks to punctuation and various Latin characters.</source>
          <target state="translated">Обратите внимание, что это &lt;em&gt;также&lt;/em&gt; отличается от Windows-1252 или кодовой страницы 1252, которая представляет собой расширенный набор ISO / IEC 8859-1, который назначает некоторые (не все!) Пробелы знакам пунктуации и различным латинским символам.</target>
        </trans-unit>
        <trans-unit id="c12e3030c3946db5f00ad56e92693e7a60e9d4f4" translate="yes" xml:space="preserve">
          <source>Note that this is &lt;em&gt;not&lt;/em&gt; the same as a rotate-left; the RHS of a wrapping shift-left is restricted to the range of the type, rather than the bits shifted out of the LHS being returned to the other end. The primitive integer types all implement a &lt;a href=&quot;#method.rotate_left&quot;&gt;&lt;code&gt;rotate_left&lt;/code&gt;&lt;/a&gt; function, which may be what you want instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d05d921ff847b716a1e90578f4bb30e691402415" translate="yes" xml:space="preserve">
          <source>Note that this is &lt;em&gt;not&lt;/em&gt; the same as a rotate-left; the RHS of a wrapping shift-left is restricted to the range of the type, rather than the bits shifted out of the LHS being returned to the other end. The primitive integer types all implement a &lt;code&gt;[&lt;/code&gt;rotate_left`](#method.rotate_left) function, which may be what you want instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b16eb422b8b7fd380457bb98366ee9e32e4eb27b" translate="yes" xml:space="preserve">
          <source>Note that this is &lt;em&gt;not&lt;/em&gt; the same as a rotate-left; the RHS of a wrapping shift-left is restricted to the range of the type, rather than the bits shifted out of the LHS being returned to the other end. The primitive integer types all implement a &lt;code&gt;rotate_left&lt;/code&gt; function, which may be what you want instead.</source>
          <target state="translated">Обратите внимание, что это &lt;em&gt;не&lt;/em&gt; то же самое, что поворот влево; правая часть оборачивающего сдвига влево ограничена диапазоном типа, а не биты, сдвинутые из LHS, возвращаемые на другой конец. Все примитивные целочисленные типы реализуют функцию &lt;code&gt;rotate_left&lt;/code&gt; , которая может быть тем, что вам нужно.</target>
        </trans-unit>
        <trans-unit id="3efbf7b6ffbe371fa44b1cbc24ab53cb5dc43bf3" translate="yes" xml:space="preserve">
          <source>Note that this is &lt;em&gt;not&lt;/em&gt; the same as a rotate-right; the RHS of a wrapping shift-right is restricted to the range of the type, rather than the bits shifted out of the LHS being returned to the other end. The primitive integer types all implement a &lt;a href=&quot;#method.rotate_right&quot;&gt;&lt;code&gt;rotate_right&lt;/code&gt;&lt;/a&gt; function, which may be what you want instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3e2418939b1c8a1ff22ccadf416147fa70a3f1d3" translate="yes" xml:space="preserve">
          <source>Note that this is &lt;em&gt;not&lt;/em&gt; the same as a rotate-right; the RHS of a wrapping shift-right is restricted to the range of the type, rather than the bits shifted out of the LHS being returned to the other end. The primitive integer types all implement a &lt;code&gt;rotate_right&lt;/code&gt; function, which may be what you want instead.</source>
          <target state="translated">Обратите внимание, что это &lt;em&gt;не&lt;/em&gt; то же самое, что поворот вправо; Правая часть оборачивающего сдвига вправо ограничена диапазоном типа, а не биты, сдвинутые из LHS, возвращаются на другой конец. Все примитивные целочисленные типы реализуют функцию &lt;code&gt;rotate_right&lt;/code&gt; , которая может быть тем, что вам нужно.</target>
        </trans-unit>
        <trans-unit id="5e7c41ce1c84929477918f04b930178589599b47" translate="yes" xml:space="preserve">
          <source>Note that this is different from ISO/IEC 8859-1 a.k.a. ISO 8859-1 (with one less hyphen), which leaves some &quot;blanks&quot;, byte values that are not assigned to any character. ISO-8859-1 (the IANA one) assigns them to the C0 and C1 control codes.</source>
          <target state="translated">Обратите внимание,что это отличается от ISO/IEC 8859-1,также известного как ISO 8859-1 (с одним дефисом меньше),что оставляет некоторые &quot;пробелы&quot;,байтовые значения,которые не присваиваются ни одному символу.ISO-8859-1 (IANA)присваивает их контрольным кодам С0 и С1.</target>
        </trans-unit>
        <trans-unit id="8c4108681b9fe84accc050cbc8f424a5d8e729f9" translate="yes" xml:space="preserve">
          <source>Note that this is not fully supported yet.</source>
          <target state="translated">Обратите внимание,что это еще не полностью поддерживается.</target>
        </trans-unit>
        <trans-unit id="f63d3c3ade69b60f12aa852f379afa06c0c1f9ef" translate="yes" xml:space="preserve">
          <source>Note that this list may get tweaked over time as clarifications are made in the future.</source>
          <target state="translated">Обратите внимание,что этот список может со временем меняться по мере того,как в будущем будут вноситься уточнения.</target>
        </trans-unit>
        <trans-unit id="03886768677567c6f0e7dd2acec0f3c2f274c587" translate="yes" xml:space="preserve">
          <source>Note that this may not have any affect on IPv6 sockets.</source>
          <target state="translated">Обратите внимание,что это может никак не повлиять на IPv6 сокеты.</target>
        </trans-unit>
        <trans-unit id="75b3dfc6f40c762d7bf2bac499b7412fe6b10302" translate="yes" xml:space="preserve">
          <source>Note that this may not have any effect on IPv6 sockets.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2dd32cd539a7711b8e3e1fa20fa744535b499c0b" translate="yes" xml:space="preserve">
          <source>Note that this method alters the content of the underlying file, even though it takes &lt;code&gt;&amp;amp;self&lt;/code&gt; rather than &lt;code&gt;&amp;amp;mut self&lt;/code&gt;.</source>
          <target state="translated">Обратите внимание, что этот метод изменяет содержимое базового файла, даже если он принимает &lt;code&gt;&amp;amp;self&lt;/code&gt; а не &lt;code&gt;&amp;amp;mut self&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="108aecbc7f980094cc29f71b2bba33a5524e868d" translate="yes" xml:space="preserve">
          <source>Note that this method alters the permissions of the underlying file, even though it takes &lt;code&gt;&amp;amp;self&lt;/code&gt; rather than &lt;code&gt;&amp;amp;mut self&lt;/code&gt;.</source>
          <target state="translated">Обратите внимание, что этот метод изменяет права доступа к базовому файлу, даже если он принимает &lt;code&gt;&amp;amp;self&lt;/code&gt; а не &lt;code&gt;&amp;amp;mut self&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e2935aad8d6fdca6a365f84d6feb6723528101b9" translate="yes" xml:space="preserve">
          <source>Note that this method does not add any padding to the overall size, regardless of whether the returned layout has a different alignment. In other words, if &lt;code&gt;K&lt;/code&gt; has size 16, &lt;code&gt;K.align_to(32)&lt;/code&gt; will &lt;em&gt;still&lt;/em&gt; have size 16.</source>
          <target state="translated">Обратите внимание, что этот метод не добавляет никаких отступов к общему размеру, независимо от того, имеет ли возвращаемый макет другое выравнивание. Другими словами, если &lt;code&gt;K&lt;/code&gt; имеет размер 16, &lt;code&gt;K.align_to(32)&lt;/code&gt; все &lt;em&gt;равно&lt;/em&gt; будет иметь размер 16.</target>
        </trans-unit>
        <trans-unit id="be7d3b69a88f7138cbd894fa652fd4db3b576956" translate="yes" xml:space="preserve">
          <source>Note that this method has no effect on the allocated capacity of the string</source>
          <target state="translated">Обратите внимание,что этот метод не влияет на выделенную емкость строки</target>
        </trans-unit>
        <trans-unit id="c7737d7dae93fa9ff008b32d416192e1953f17cf" translate="yes" xml:space="preserve">
          <source>Note that this method has no effect on the allocated capacity of the vector.</source>
          <target state="translated">Обратите внимание,что этот метод не влияет на выделенную емкость вектора.</target>
        </trans-unit>
        <trans-unit id="89e693fcdc5244de65fc2d6120edee9bdcd4b3ee" translate="yes" xml:space="preserve">
          <source>Note that this structure is &lt;strong&gt;not&lt;/strong&gt;&lt;code&gt;repr(C)&lt;/code&gt; and is not recommended to be placed in the signatures of FFI functions. Instead, safe wrappers of FFI functions may leverage the unsafe &lt;a href=&quot;#method.from_ptr&quot;&gt;&lt;code&gt;from_ptr&lt;/code&gt;&lt;/a&gt; constructor to provide a safe interface to other consumers.</source>
          <target state="translated">Обратите внимание, что эта структура &lt;strong&gt;не&lt;/strong&gt; является &lt;code&gt;repr(C)&lt;/code&gt; и ее не рекомендуется помещать в подписи функций FFI. Вместо этого безопасные оболочки функций FFI могут использовать небезопасный конструктор &lt;a href=&quot;#method.from_ptr&quot;&gt; &lt;code&gt;from_ptr&lt;/code&gt; ,&lt;/a&gt; чтобы обеспечить безопасный интерфейс для других потребителей.</target>
        </trans-unit>
        <trans-unit id="9aac27458abae34c90a97df1aff42a3fdeee40a4" translate="yes" xml:space="preserve">
          <source>Note that this structure is &lt;strong&gt;not&lt;/strong&gt;&lt;code&gt;repr(C)&lt;/code&gt; and is not recommended to be placed in the signatures of FFI functions. Instead, safe wrappers of FFI functions may leverage the unsafe &lt;a href=&quot;struct.cstr#method.from_ptr&quot;&gt;&lt;code&gt;CStr::from_ptr&lt;/code&gt;&lt;/a&gt; constructor to provide a safe interface to other consumers.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f5da6d2d2aa3f48414658a9bcd539c6d50d1d673" translate="yes" xml:space="preserve">
          <source>Note that this technique can also be used in the arms of a match expression:</source>
          <target state="translated">Обратите внимание,что эта техника также может быть использована в выражениях на руках матча:</target>
        </trans-unit>
        <trans-unit id="b13210c5a5854d88abb024233653585819c00385" translate="yes" xml:space="preserve">
          <source>Note that this will drop any excess capacity.</source>
          <target state="translated">Обратите внимание,что это приведет к снижению любой избыточной мощности.</target>
        </trans-unit>
        <trans-unit id="6affebf246a6b9323b472569ce7b0d2dca1b6504" translate="yes" xml:space="preserve">
          <source>Note that unlike &lt;a href=&quot;trait.iterator#method.take_while&quot;&gt;&lt;code&gt;take_while&lt;/code&gt;&lt;/a&gt; this iterator is &lt;strong&gt;not&lt;/strong&gt; fused. It is also not specified what this iterator returns after the first&lt;code&gt; None&lt;/code&gt; is returned. If you need fused iterator, use &lt;a href=&quot;trait.iterator#method.fuse&quot;&gt;&lt;code&gt;fuse&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4d98fb91c14420919b7eff367a1230b8f150b713" translate="yes" xml:space="preserve">
          <source>Note that unlike &lt;code&gt;wait&lt;/code&gt;, this function will not attempt to drop stdin.</source>
          <target state="translated">Обратите внимание, что в отличие от &lt;code&gt;wait&lt;/code&gt; эта функция не будет пытаться сбросить стандартный ввод.</target>
        </trans-unit>
        <trans-unit id="cb34ec44c63eee46c533ae8549230c0956f06438" translate="yes" xml:space="preserve">
          <source>Note that unlike array expressions this syntax supports all elements which implement &lt;a href=&quot;clone/trait.clone&quot;&gt;&lt;code&gt;Clone&lt;/code&gt;&lt;/a&gt; and the number of elements doesn't have to be a constant.</source>
          <target state="translated">Обратите внимание, что в отличие от выражений массива этот синтаксис поддерживает все элементы, которые реализуют &lt;a href=&quot;clone/trait.clone&quot;&gt; &lt;code&gt;Clone&lt;/code&gt; &lt;/a&gt; и количество элементов не обязательно должно быть константой.</target>
        </trans-unit>
        <trans-unit id="09bd0257d3adc41b553ee0c1fba837b27ed6d43d" translate="yes" xml:space="preserve">
          <source>Note that unsized types have many possible null pointers, as only the raw data pointer is considered, not their length, vtable, etc. Therefore, two pointers that are null may still not compare equal to each other.</source>
          <target state="translated">Обратите внимание,что неразмерные типы имеют много возможных нулевых указателей,так как учитывается только указатель на необработанные данные,а не их длина,табуляция и т.д.Поэтому два нулевых указателя все равно могут не сравниваться друг с другом.</target>
        </trans-unit>
        <trans-unit id="1f2131c92cffd468fb8e9760cfdc9ed5b9347fe9" translate="yes" xml:space="preserve">
          <source>Note that using &lt;code&gt;self&lt;/code&gt; in this way might not be necessary in the future; it&amp;rsquo;s an inconsistency in the language that Rust developers are working to eliminate.</source>
          <target state="translated">Обратите внимание, что использование &lt;code&gt;self&lt;/code&gt; таким образом может не понадобиться в будущем; это несоответствие языка, над которым работают разработчики Rust.</target>
        </trans-unit>
        <trans-unit id="d0ff9c8a29cb263c7447b50b428f4e5035b7a3bd" translate="yes" xml:space="preserve">
          <source>Note that using the &lt;code&gt;type&lt;/code&gt; keyword does not work here because &lt;code&gt;type&lt;/code&gt; only introduces a type alias:</source>
          <target state="translated">Обратите внимание, что использование ключевого слова &lt;code&gt;type&lt;/code&gt; здесь не работает, потому что &lt;code&gt;type&lt;/code&gt; вводит только псевдоним типа:</target>
        </trans-unit>
        <trans-unit id="bb6b42394e9bea5f3f448212418ce1a68b9d76c5" translate="yes" xml:space="preserve">
          <source>Note that using these trait methods will result in a heap allocation per-function-call. This is not a significant cost for the vast majority of applications, but should be considered when deciding whether to use this functionality in the public API of a low-level function that is expected to be called millions of times a second.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="96eb45dab421603d86bba0634bd20e8a1fa6f567" translate="yes" xml:space="preserve">
          <source>Note that variants without a manually specified discriminant are numbered from top to bottom starting from 0, so clashes can occur with seemingly unrelated variants.</source>
          <target state="translated">Обратите внимание,что варианты без вручную заданного дискриминанта нумеруются сверху вниз,начиная с 0,поэтому столкновения могут происходить с кажущимися несвязанными между собой вариантами.</target>
        </trans-unit>
        <trans-unit id="76fed75fcc53f6083929938f0584d1d34ef49d4d" translate="yes" xml:space="preserve">
          <source>Note that we added a type annotation here. Because we aren&amp;rsquo;t inserting any values into this vector, Rust doesn&amp;rsquo;t know what kind of elements we intend to store. This is an important point. Vectors are implemented using generics; we&amp;rsquo;ll cover how to use generics with your own types in Chapter 10. For now, know that the &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; type provided by the standard library can hold any type, and when a specific vector holds a specific type, the type is specified within angle brackets. In Listing 8-1, we&amp;rsquo;ve told Rust that the &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; in &lt;code&gt;v&lt;/code&gt; will hold elements of the &lt;code&gt;i32&lt;/code&gt; type.</source>
          <target state="translated">Обратите внимание, что здесь мы добавили аннотацию типа. Поскольку мы не вставляем никаких значений в этот вектор, Rust не знает, какие элементы мы собираемся хранить. Это важный момент. Векторы реализованы с использованием дженериков; мы рассмотрим, как использовать обобщенные типы с вашими собственными типами в главе 10. На данный момент знайте, что тип &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; предоставляемый стандартной библиотекой, может содержать любой тип, а когда конкретный вектор содержит определенный тип, тип будет указаны в угловых скобках. В листинге 8-1 мы сообщили Rust, что &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; в &lt;code&gt;v&lt;/code&gt; будет содержать элементы типа &lt;code&gt;i32&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2c79056cb286ed85ac028f7264150a40f531f9d9" translate="yes" xml:space="preserve">
          <source>Note that we added the &lt;code&gt;case_sensitive&lt;/code&gt; field that holds a Boolean. Next, we need the &lt;code&gt;run&lt;/code&gt; function to check the &lt;code&gt;case_sensitive&lt;/code&gt; field&amp;rsquo;s value and use that to decide whether to call the &lt;code&gt;search&lt;/code&gt; function or the &lt;code&gt;search_case_insensitive&lt;/code&gt; function, as shown in Listing 12-22. Note this still won&amp;rsquo;t compile yet.</source>
          <target state="translated">Обратите внимание, что мы добавили поле &lt;code&gt;case_sensitive&lt;/code&gt; , содержащее логическое значение. Затем нам нужна функция &lt;code&gt;run&lt;/code&gt; , чтобы проверить &lt;code&gt;case_sensitive&lt;/code&gt; поля case_sensitive и использовать его, чтобы решить, вызывать ли функцию &lt;code&gt;search&lt;/code&gt; или функцию &lt;code&gt;search_case_insensitive&lt;/code&gt; , как показано в Листинге 12-22. Обратите внимание, что это еще не компилируется.</target>
        </trans-unit>
        <trans-unit id="d033b37f19d17a68bf9778f4a3805418777a67e9" translate="yes" xml:space="preserve">
          <source>Note that we don&amp;rsquo;t need to mark the resulting &lt;code&gt;split_at_mut&lt;/code&gt; function as &lt;code&gt;unsafe&lt;/code&gt;, and we can call this function from safe Rust. We&amp;rsquo;ve created a safe abstraction to the unsafe code with an implementation of the function that uses &lt;code&gt;unsafe&lt;/code&gt; code in a safe way, because it creates only valid pointers from the data this function has access to.</source>
          <target state="translated">Обратите внимание, что нам не нужно отмечать результирующую функцию &lt;code&gt;split_at_mut&lt;/code&gt; как &lt;code&gt;unsafe&lt;/code&gt; , и мы можем вызвать эту функцию из безопасного Rust. Мы создали безопасную абстракцию небезопасного кода с реализацией функции, которая использует &lt;code&gt;unsafe&lt;/code&gt; код безопасным способом, потому что она создает только действительные указатели из данных, к которым эта функция имеет доступ.</target>
        </trans-unit>
        <trans-unit id="79f8d5116fd5bb5dc0c20baa33c391d983b3d588" translate="yes" xml:space="preserve">
          <source>Note that we have to declare &lt;code&gt;T&lt;/code&gt; just after &lt;code&gt;impl&lt;/code&gt; so we can use it to specify that we&amp;rsquo;re implementing methods on the type &lt;code&gt;Point&amp;lt;T&amp;gt;&lt;/code&gt;. By declaring &lt;code&gt;T&lt;/code&gt; as a generic type after &lt;code&gt;impl&lt;/code&gt;, Rust can identify that the type in the angle brackets in &lt;code&gt;Point&lt;/code&gt; is a generic type rather than a concrete type.</source>
          <target state="translated">Обратите внимание, что мы должны объявить &lt;code&gt;T&lt;/code&gt; сразу после &lt;code&gt;impl&lt;/code&gt; , чтобы мы могли использовать его, чтобы указать, что мы реализуем методы для типа &lt;code&gt;Point&amp;lt;T&amp;gt;&lt;/code&gt; . Объявляя &lt;code&gt;T&lt;/code&gt; как универсальный тип после &lt;code&gt;impl&lt;/code&gt; , Rust может определить, что тип в угловых скобках в &lt;code&gt;Point&lt;/code&gt; является универсальным типом, а не конкретным типом.</target>
        </trans-unit>
        <trans-unit id="21933f931bffb1331e5d307d3ac351285280040d" translate="yes" xml:space="preserve">
          <source>Note that we must use the fully qualified syntax that we talked about earlier in the &lt;a href=&quot;ch19-03-advanced-traits#advanced-traits&quot;&gt;&amp;ldquo;Advanced Traits&amp;rdquo;&lt;/a&gt; section because there are multiple functions available named &lt;code&gt;to_string&lt;/code&gt;. Here, we&amp;rsquo;re using the &lt;code&gt;to_string&lt;/code&gt; function defined in the &lt;code&gt;ToString&lt;/code&gt; trait, which the standard library has implemented for any type that implements &lt;code&gt;Display&lt;/code&gt;.</source>
          <target state="translated">Обратите внимание, что мы должны использовать полностью определенный синтаксис, о котором мы говорили ранее в разделе &lt;a href=&quot;ch19-03-advanced-traits#advanced-traits&quot;&gt;&amp;laquo;Расширенные свойства&amp;raquo;,&lt;/a&gt; потому что доступно несколько функций с именем &lt;code&gt;to_string&lt;/code&gt; . Здесь мы используем функцию &lt;code&gt;to_string&lt;/code&gt; , определенную в трейте &lt;code&gt;ToString&lt;/code&gt; , который стандартная библиотека реализовала для любого типа, реализующего &lt;code&gt;Display&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="096f913e45816f67a5f4300a1107c11162218bda" translate="yes" xml:space="preserve">
          <source>Note that we need lifetime annotations on this method, as we discussed in Chapter 10. We&amp;rsquo;re taking a reference to a &lt;code&gt;post&lt;/code&gt; as an argument and returning a reference to part of that &lt;code&gt;post&lt;/code&gt;, so the lifetime of the returned reference is related to the lifetime of the &lt;code&gt;post&lt;/code&gt; argument.</source>
          <target state="translated">Обратите внимание, что нам нужны аннотации времени жизни для этого метода, как мы обсуждали в главе 10. Мы берем ссылку на &lt;code&gt;post&lt;/code&gt; в качестве аргумента и возвращаем ссылку на часть этого &lt;code&gt;post&lt;/code&gt; , поэтому время жизни возвращенной ссылки связано с время жизни аргумента &lt;code&gt;post&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0a3ac30cf1c59aeb030a71d5cf7a71a2b0dfbcb7" translate="yes" xml:space="preserve">
          <source>Note that we need to first &lt;code&gt;use&lt;/code&gt; the &lt;code&gt;HashMap&lt;/code&gt; from the collections portion of the standard library. Of our three common collections, this one is the least often used, so it&amp;rsquo;s not included in the features brought into scope automatically in the prelude. Hash maps also have less support from the standard library; there&amp;rsquo;s no built-in macro to construct them, for example.</source>
          <target state="translated">Обратите внимание , что мы должны сначала &lt;code&gt;use&lt;/code&gt; в &lt;code&gt;HashMap&lt;/code&gt; из части коллекций стандартной библиотеки. Из трех наших общих коллекций эта используется реже всего, поэтому она не включается в функции, автоматически включенные в область видимости в прелюдии. Хеш-карты также менее поддерживаются стандартной библиотекой; например, нет встроенного макроса для их создания.</target>
        </trans-unit>
        <trans-unit id="5da3fc4decf52dc450c6e612f0f2c00362fc9669" translate="yes" xml:space="preserve">
          <source>Note that we needed the &lt;code&gt;: Vec&amp;lt;i32&amp;gt;&lt;/code&gt; on the left-hand side. This is because we could collect into, for example, a &lt;a href=&quot;../collections/struct.vecdeque&quot;&gt;&lt;code&gt;VecDeque&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt; instead:</source>
          <target state="translated">Обратите внимание, что нам нужен &lt;code&gt;: Vec&amp;lt;i32&amp;gt;&lt;/code&gt; с левой стороны. Это потому, что вместо этого мы могли бы собрать, например, &lt;a href=&quot;../collections/struct.vecdeque&quot;&gt; &lt;code&gt;VecDeque&amp;lt;T&amp;gt;&lt;/code&gt; &lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="75b55fff64dcfe7729e494e2a0b5e033941b67c8" translate="yes" xml:space="preserve">
          <source>Note that we needed to make &lt;code&gt;v1_iter&lt;/code&gt; mutable: calling the &lt;code&gt;next&lt;/code&gt; method on an iterator changes internal state that the iterator uses to keep track of where it is in the sequence. In other words, this code &lt;em&gt;consumes&lt;/em&gt;, or uses up, the iterator. Each call to &lt;code&gt;next&lt;/code&gt; eats up an item from the iterator. We didn&amp;rsquo;t need to make &lt;code&gt;v1_iter&lt;/code&gt; mutable when we used a &lt;code&gt;for&lt;/code&gt; loop because the loop took ownership of &lt;code&gt;v1_iter&lt;/code&gt; and made it mutable behind the scenes.</source>
          <target state="translated">Обратите внимание, что нам нужно было сделать &lt;code&gt;v1_iter&lt;/code&gt; изменяемым: вызов &lt;code&gt;next&lt;/code&gt; метода на итераторе изменяет внутреннее состояние, которое итератор использует для отслеживания того, где он находится в последовательности. Другими словами, этот код &lt;em&gt;потребляет&lt;/em&gt; или использует итератор. Каждый вызов &lt;code&gt;next&lt;/code&gt; съедает элемент из итератора. Нам не нужно было делать &lt;code&gt;v1_iter&lt;/code&gt; изменяемым, когда мы использовали цикл &lt;code&gt;for&lt;/code&gt; , потому что цикл стал владельцем &lt;code&gt;v1_iter&lt;/code&gt; и сделал его изменяемым за кулисами.</target>
        </trans-unit>
        <trans-unit id="5994cd1512c44aaad650a1803fdb7c349136ad1d" translate="yes" xml:space="preserve">
          <source>Note that we want the function to take string slices, which are references, because we don&amp;rsquo;t want the &lt;code&gt;longest&lt;/code&gt; function to take ownership of its parameters. Refer to the &lt;a href=&quot;ch04-03-slices#string-slices-as-parameters&quot;&gt;&amp;ldquo;String Slices as Parameters&amp;rdquo;&lt;/a&gt; section in Chapter 4 for more discussion about why the parameters we use in Listing 10-20 are the ones we want.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5ee6c1ea883902ac8da8cc6969cf6510f9cd8cc8" translate="yes" xml:space="preserve">
          <source>Note that we want the function to take string slices, which are references, because we don&amp;rsquo;t want the &lt;code&gt;longest&lt;/code&gt; function to take ownership of its parameters. We want to allow the function to accept slices of a &lt;code&gt;String&lt;/code&gt; (the type stored in the variable &lt;code&gt;string1&lt;/code&gt;) as well as string literals (which is what variable &lt;code&gt;string2&lt;/code&gt; contains).</source>
          <target state="translated">Обратите внимание, что мы хотим, чтобы функция принимала строковые фрагменты, которые являются ссылками, потому что мы не хотим, чтобы самая &lt;code&gt;longest&lt;/code&gt; функция стала владеть своими параметрами. Мы хотим, чтобы функция могла принимать фрагменты &lt;code&gt;String&lt;/code&gt; (тип, хранящийся в переменной &lt;code&gt;string1&lt;/code&gt; ), а также строковые литералы (которые и содержатся в переменной &lt;code&gt;string2&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="f37dca568a2a5ec6c0b22f134958fd92838997bb" translate="yes" xml:space="preserve">
          <source>Note that we&amp;rsquo;ve added a new line inside the &lt;code&gt;tests&lt;/code&gt; module: &lt;code&gt;use super::*;&lt;/code&gt;. The &lt;code&gt;tests&lt;/code&gt; module is a regular module that follows the usual visibility rules we covered in Chapter 7 in the &lt;a href=&quot;ch07-02-defining-modules-to-control-scope-and-privacy&quot;&gt;&amp;ldquo;Modules as the Privacy Boundary&amp;rdquo;&lt;/a&gt; section. Because the &lt;code&gt;tests&lt;/code&gt; module is an inner module, we need to bring the code under test in the outer module into the scope of the inner module. We use a glob here so anything we define in the outer module is available to this &lt;code&gt;tests&lt;/code&gt; module.</source>
          <target state="translated">Обратите внимание, что мы добавили новую строку в модуль &lt;code&gt;tests&lt;/code&gt; : &lt;code&gt;use super::*;&lt;/code&gt; . Модуль &lt;code&gt;tests&lt;/code&gt; - это обычный модуль, который следует обычным правилам видимости, которые мы рассмотрели в главе 7 в разделе &lt;a href=&quot;ch07-02-defining-modules-to-control-scope-and-privacy&quot;&gt;&amp;laquo;Модули как граница конфиденциальности&amp;raquo;&lt;/a&gt; . Поскольку модуль &lt;code&gt;tests&lt;/code&gt; является внутренним модулем, нам нужно перенести тестируемый код во внешнем модуле в область видимости внутреннего модуля. Здесь мы используем глобус, поэтому все, что мы определяем во внешнем модуле, доступно этому модулю &lt;code&gt;tests&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8e05c11c9aa8615f8372dccd3f7625301eed4295" translate="yes" xml:space="preserve">
          <source>Note that we&amp;rsquo;ve added a new line inside the &lt;code&gt;tests&lt;/code&gt; module: &lt;code&gt;use super::*;&lt;/code&gt;. The &lt;code&gt;tests&lt;/code&gt; module is a regular module that follows the usual visibility rules we covered in Chapter 7 in the &lt;a href=&quot;ch07-03-paths-for-referring-to-an-item-in-the-module-tree&quot;&gt;&amp;ldquo;Paths for Referring to an Item in the Module Tree&amp;rdquo;&lt;/a&gt; section. Because the &lt;code&gt;tests&lt;/code&gt; module is an inner module, we need to bring the code under test in the outer module into the scope of the inner module. We use a glob here so anything we define in the outer module is available to this &lt;code&gt;tests&lt;/code&gt; module.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="26a0be4b24350107b09144aaaa2ad0fb91731191" translate="yes" xml:space="preserve">
          <source>Note that we&amp;rsquo;ve edited the old test&amp;rsquo;s &lt;code&gt;contents&lt;/code&gt; too. We&amp;rsquo;ve added a new line with the text &lt;code&gt;&quot;Duct tape.&quot;&lt;/code&gt; using a capital D that shouldn&amp;rsquo;t match the query &lt;code&gt;&quot;duct&quot;&lt;/code&gt; when we&amp;rsquo;re searching in a case-sensitive manner. Changing the old test in this way helps ensure that we don&amp;rsquo;t accidentally break the case-sensitive search functionality that we&amp;rsquo;ve already implemented. This test should pass now and should continue to pass as we work on the case-insensitive search.</source>
          <target state="translated">Обратите внимание, что мы редактировали и &lt;code&gt;contents&lt;/code&gt; старого теста . Мы добавили новую строку с текстом &lt;code&gt;&quot;Duct tape.&quot;&lt;/code&gt; использование заглавной буквы D, которая не должна соответствовать запросу &lt;code&gt;&quot;duct&quot;&lt;/code&gt; при поиске с учетом регистра. Такое изменение старого теста гарантирует, что мы случайно не нарушим уже реализованную нами функцию поиска с учетом регистра. Этот тест должен пройти сейчас и должен продолжаться, пока мы работаем над поиском без учета регистра.</target>
        </trans-unit>
        <trans-unit id="2e87959963706a5a2e57c9724a365d2a982bba5d" translate="yes" xml:space="preserve">
          <source>Note that when the wildcard &lt;code&gt;*&lt;/code&gt; is used on a type, it does not import its methods (though for &lt;code&gt;enum&lt;/code&gt;s it imports the variants, as shown in the example below).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2b7bbbf14e1bc0dbc3662e9181bd406f83393130" translate="yes" xml:space="preserve">
          <source>Note that where ties occur, &lt;a href=&quot;../vec/struct.vec&quot;&gt;&lt;code&gt;Vec&lt;/code&gt;&lt;/a&gt; is generally going to be faster than &lt;a href=&quot;struct.vecdeque&quot;&gt;&lt;code&gt;VecDeque&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;struct.vecdeque&quot;&gt;&lt;code&gt;VecDeque&lt;/code&gt;&lt;/a&gt; is generally going to be faster than &lt;a href=&quot;struct.linkedlist&quot;&gt;&lt;code&gt;LinkedList&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Обратите внимание, что там, где возникают связи, &lt;a href=&quot;../vec/struct.vec&quot;&gt; &lt;code&gt;Vec&lt;/code&gt; &lt;/a&gt; обычно будет быстрее, чем &lt;a href=&quot;struct.vecdeque&quot;&gt; &lt;code&gt;VecDeque&lt;/code&gt; &lt;/a&gt; , а &lt;a href=&quot;struct.vecdeque&quot;&gt; &lt;code&gt;VecDeque&lt;/code&gt; &lt;/a&gt; обычно будет быстрее, чем &lt;a href=&quot;struct.linkedlist&quot;&gt; &lt;code&gt;LinkedList&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="b62f50352e9e786c961cd72638314895b5c9fdfc" translate="yes" xml:space="preserve">
          <source>Note that while concurrent access to environment variables is safe in Rust, some platforms only expose inherently unsafe non-threadsafe APIs for inspecting the environment. As a result extra care needs to be taken when auditing calls to unsafe external FFI functions to ensure that any external environment accesses are properly synchronized with accesses in Rust.</source>
          <target state="translated">Обратите внимание,что хотя параллельный доступ к переменным окружения безопасен в Rust,на некоторых платформах для проверки окружения могут использоваться только небезопасные,по своей сути,не-потокобезопасные API.В результате,при проверке вызовов небезопасных внешних FFI-функций необходимо проявлять дополнительную осторожность,чтобы убедиться в том,что любой доступ к внешней среде корректно синхронизирован с доступом в Rust.</target>
        </trans-unit>
        <trans-unit id="d3954c01ae7015c1edc03c422ae6922dcf56ba11" translate="yes" xml:space="preserve">
          <source>Note that while concurrent access to environment variables is safe in Rust, some platforms only expose inherently unsafe non-threadsafe APIs for inspecting the environment. As a result, extra care needs to be taken when auditing calls to unsafe external FFI functions to ensure that any external environment accesses are properly synchronized with accesses in Rust.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="324300377b3c3f353b3f11bc282603959b1e1422" translate="yes" xml:space="preserve">
          <source>Note that while mutating or mutably aliasing the contents of an &lt;code&gt;&amp;amp;UnsafeCell&amp;lt;T&amp;gt;&lt;/code&gt; is ok (provided you enforce the invariants some other way), it is still undefined behavior to have multiple &lt;code&gt;&amp;amp;mut UnsafeCell&amp;lt;T&amp;gt;&lt;/code&gt; aliases.</source>
          <target state="translated">Обратите внимание, что при изменении или изменяемом псевдониме содержимого &lt;code&gt;&amp;amp;UnsafeCell&amp;lt;T&amp;gt;&lt;/code&gt; все в порядке (при условии, что вы принудительно применяете инварианты каким-либо другим способом), наличие нескольких псевдонимов &lt;code&gt;&amp;amp;mut UnsafeCell&amp;lt;T&amp;gt;&lt;/code&gt; прежнему является неопределенным поведением .</target>
        </trans-unit>
        <trans-unit id="9eb90457458f8170cc06094675d04f9c0e8116dd" translate="yes" xml:space="preserve">
          <source>Note that whilst mutating the contents of an &lt;code&gt;&amp;amp;UnsafeCell&amp;lt;T&amp;gt;&lt;/code&gt; (even while other &lt;code&gt;&amp;amp;UnsafeCell&amp;lt;T&amp;gt;&lt;/code&gt; references alias the cell) is ok (provided you enforce the above invariants some other way), it is still undefined behavior to have multiple &lt;code&gt;&amp;amp;mut UnsafeCell&amp;lt;T&amp;gt;&lt;/code&gt; aliases. That is, &lt;code&gt;UnsafeCell&lt;/code&gt; is a wrapper designed to have a special interaction with &lt;em&gt;shared&lt;/em&gt; accesses (&lt;em&gt;i.e.&lt;/em&gt;, through an &lt;code&gt;&amp;amp;UnsafeCell&amp;lt;_&amp;gt;&lt;/code&gt; reference); there is no magic whatsoever when dealing with &lt;em&gt;exclusive&lt;/em&gt; accesses (&lt;em&gt;e.g.&lt;/em&gt;, through an &lt;code&gt;&amp;amp;mut UnsafeCell&amp;lt;_&amp;gt;&lt;/code&gt;): neither the cell nor the wrapped value may be aliased for the duration of that &lt;code&gt;&amp;amp;mut&lt;/code&gt; borrow. This is showcased by the &lt;a href=&quot;struct.unsafecell#method.get_mut&quot;&gt;&lt;code&gt;.get_mut()&lt;/code&gt;&lt;/a&gt; accessor, which is a non-&lt;code&gt;unsafe&lt;/code&gt; getter that yields a &lt;code&gt;&amp;amp;mut T&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7ea0c44d2eb4a19014b1a6e779035e8b52686247" translate="yes" xml:space="preserve">
          <source>Note that with this function, the new thread will be stopped when the main thread ends, whether or not it has finished running. The output from this program might be a little different every time, but it will look similar to the following:</source>
          <target state="translated">Обратите внимание,что с помощью этой функции новый поток будет остановлен,когда основной поток завершит свою работу,независимо от того,завершился он или нет.Выходная информация из этой программы может каждый раз немного отличаться,но она будет выглядеть так,как показано ниже:</target>
        </trans-unit>
        <trans-unit id="499913d6f995a629a9ad09275a1ae60af65eff00" translate="yes" xml:space="preserve">
          <source>Note that writing updates the slice to point to the yet unwritten part. The slice will be empty when it has been completely overwritten.</source>
          <target state="translated">Обратите внимание,что запись обновляет фрагмент,указывая на еще не написанную часть.Кусок будет пустым,когда он будет полностью переписан.</target>
        </trans-unit>
        <trans-unit id="30da6e410f76967402353bb250335b332eb88eb5" translate="yes" xml:space="preserve">
          <source>Note that you cannot use the &lt;a href=&quot;../../book/appendix-02-operators&quot;&gt;&lt;code&gt;?&lt;/code&gt; operator&lt;/a&gt; in functions that do not return a &lt;a href=&quot;../result/enum.result&quot;&gt;&lt;code&gt;Result&amp;lt;T, E&amp;gt;&lt;/code&gt;&lt;/a&gt;. Instead, you can call &lt;a href=&quot;../result/enum.result#method.unwrap&quot;&gt;&lt;code&gt;.unwrap()&lt;/code&gt;&lt;/a&gt; or &lt;code&gt;match&lt;/code&gt; on the return value to catch any possible errors:</source>
          <target state="translated">Обратите внимание, что вы не можете использовать &lt;a href=&quot;../../book/appendix-02-operators&quot;&gt; &lt;code&gt;?&lt;/code&gt; оператор&lt;/a&gt; в функциях, которые не возвращают &lt;a href=&quot;../result/enum.result&quot;&gt; &lt;code&gt;Result&amp;lt;T, E&amp;gt;&lt;/code&gt; &lt;/a&gt; . Вместо этого вы можете вызвать &lt;a href=&quot;../result/enum.result#method.unwrap&quot;&gt; &lt;code&gt;.unwrap()&lt;/code&gt; &lt;/a&gt; или &lt;code&gt;match&lt;/code&gt; возвращаемое значение, чтобы отловить любые возможные ошибки:</target>
        </trans-unit>
        <trans-unit id="8cd9969c1871eeacc0200593b93cdcffbccf3e66" translate="yes" xml:space="preserve">
          <source>Note that, although read and write methods require a &lt;code&gt;&amp;amp;mut File&lt;/code&gt;, because of the interfaces for &lt;a href=&quot;../io/trait.read&quot;&gt;&lt;code&gt;Read&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../io/trait.write&quot;&gt;&lt;code&gt;Write&lt;/code&gt;&lt;/a&gt;, the holder of a &lt;code&gt;&amp;amp;File&lt;/code&gt; can still modify the file, either through methods that take &lt;code&gt;&amp;amp;File&lt;/code&gt; or by retrieving the underlying OS object and modifying the file that way. Additionally, many operating systems allow concurrent modification of files by different processes. Avoid assuming that holding a &lt;code&gt;&amp;amp;File&lt;/code&gt; means that the file will not change.</source>
          <target state="translated">Обратите внимание, что хотя для методов чтения и записи требуется &lt;code&gt;&amp;amp;mut File&lt;/code&gt; , из-за интерфейсов для &lt;a href=&quot;../io/trait.read&quot;&gt; &lt;code&gt;Read&lt;/code&gt; &lt;/a&gt; и &lt;a href=&quot;../io/trait.write&quot;&gt; &lt;code&gt;Write&lt;/code&gt; &lt;/a&gt; владелец &lt;code&gt;&amp;amp;File&lt;/code&gt; может по-прежнему изменять файл либо с помощью методов, которые принимают &lt;code&gt;&amp;amp;File&lt;/code&gt; либо путем извлечения базового объекта ОС и изменения файла. туда. Кроме того, многие операционные системы допускают одновременное изменение файлов разными процессами. Не предполагайте, что наличие &lt;code&gt;&amp;amp;File&lt;/code&gt; означает, что файл не изменится.</target>
        </trans-unit>
        <trans-unit id="1d0cf8461e762586f36c776928c774ad1d9122e5" translate="yes" xml:space="preserve">
          <source>Note that, because &lt;code&gt;$crate&lt;/code&gt; refers to the current crate, it must be used with a fully qualified module path when referring to non-macro items:</source>
          <target state="translated">Обратите внимание, что, поскольку &lt;code&gt;$crate&lt;/code&gt; относится к текущему ящику, он должен использоваться с полным путем к модулю при обращении к элементам, не относящимся к макросам:</target>
        </trans-unit>
        <trans-unit id="160864ae0e83232cc21d9f02b2b16fec0e686a4e" translate="yes" xml:space="preserve">
          <source>Note that, like the &lt;code&gt;Option&lt;/code&gt; enum, the &lt;code&gt;Result&lt;/code&gt; enum and its variants have been brought into scope by the prelude, so we don&amp;rsquo;t need to specify &lt;code&gt;Result::&lt;/code&gt; before the &lt;code&gt;Ok&lt;/code&gt; and &lt;code&gt;Err&lt;/code&gt; variants in the &lt;code&gt;match&lt;/code&gt; arms.</source>
          <target state="translated">Обратите внимание, что, как и перечисление &lt;code&gt;Option&lt;/code&gt; , перечисление &lt;code&gt;Result&lt;/code&gt; и его варианты были включены в область действия прелюдией, поэтому нам не нужно указывать &lt;code&gt;Result::&lt;/code&gt; перед вариантами &lt;code&gt;Ok&lt;/code&gt; и &lt;code&gt;Err&lt;/code&gt; в ответвлениях &lt;code&gt;match&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="669f2ea820772978e72d4c3d94e7389c9756f1a1" translate="yes" xml:space="preserve">
          <source>Note that, this &lt;a href=&quot;../io/index#platform-specific-behavior&quot;&gt;may change in the future&lt;/a&gt;.</source>
          <target state="translated">Обратите внимание, что это &lt;a href=&quot;../io/index#platform-specific-behavior&quot;&gt;может измениться в будущем&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="169cf16d0a1c963eafd20679aea07a420f4eaf39" translate="yes" xml:space="preserve">
          <source>Note that, unlike &lt;code&gt;repeat&lt;/code&gt;, &lt;code&gt;repeat_packed&lt;/code&gt; does not guarantee that the repeated instances of &lt;code&gt;self&lt;/code&gt; will be properly aligned, even if a given instance of &lt;code&gt;self&lt;/code&gt; is properly aligned. In other words, if the layout returned by &lt;code&gt;repeat_packed&lt;/code&gt; is used to allocate an array, it is not guaranteed that all elements in the array will be properly aligned.</source>
          <target state="translated">Обратите внимание, что, в отличие от &lt;code&gt;repeat&lt;/code&gt; , &lt;code&gt;repeat_packed&lt;/code&gt; не гарантирует, что повторяющиеся экземпляры &lt;code&gt;self&lt;/code&gt; будут правильно выровнены, даже если данный экземпляр &lt;code&gt;self&lt;/code&gt; правильно выровнен. Другими словами, если макет, возвращаемый &lt;code&gt;repeat_packed&lt;/code&gt; , используется для выделения массива, не гарантируется, что все элементы в массиве будут правильно выровнены.</target>
        </trans-unit>
        <trans-unit id="285f98e8d01e4962eff6724b78a3c6724d0931e6" translate="yes" xml:space="preserve">
          <source>Note that:</source>
          <target state="translated">Обратите внимание:</target>
        </trans-unit>
        <trans-unit id="fc7308ef65a4b47d9c6953435d548f4e965b07bd" translate="yes" xml:space="preserve">
          <source>Note the documentation for the primitives &lt;a href=&quot;https://doc.rust-lang.org/nightly/std/primitive.str.html&quot;&gt;&lt;code&gt;str&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;slice/index&quot;&gt;&lt;code&gt;[T]&lt;/code&gt;&lt;/a&gt; (also called 'slice'). Many method calls on &lt;a href=&quot;string/struct.string&quot;&gt;&lt;code&gt;String&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;vec/struct.vec&quot;&gt;&lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt; are actually calls to methods on &lt;a href=&quot;https://doc.rust-lang.org/nightly/std/primitive.str.html&quot;&gt;&lt;code&gt;str&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;slice/index&quot;&gt;&lt;code&gt;[T]&lt;/code&gt;&lt;/a&gt; respectively, via &lt;a href=&quot;../book/ch15-02-deref#implicit-deref-coercions-with-functions-and-methods&quot;&gt;deref coercions&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d6d8fcef27cc36a94771021effc9ea114018af44" translate="yes" xml:space="preserve">
          <source>Note the documentation for the primitives &lt;a href=&quot;primitive.str&quot;&gt;&lt;code&gt;str&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;primitive.slice&quot;&gt;&lt;code&gt;[T]&lt;/code&gt;&lt;/a&gt; (also called 'slice'). Many method calls on &lt;a href=&quot;string/struct.string&quot;&gt;&lt;code&gt;String&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;vec/index&quot;&gt;&lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt; are actually calls to methods on &lt;a href=&quot;primitive.str&quot;&gt;&lt;code&gt;str&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;primitive.slice&quot;&gt;&lt;code&gt;[T]&lt;/code&gt;&lt;/a&gt; respectively, via &lt;a href=&quot;../book/ch15-02-deref#implicit-deref-coercions-with-functions-and-methods&quot;&gt;deref coercions&lt;/a&gt;.</source>
          <target state="translated">Обратите внимание на документацию для примитивов &lt;a href=&quot;primitive.str&quot;&gt; &lt;code&gt;str&lt;/code&gt; &lt;/a&gt; и &lt;a href=&quot;primitive.slice&quot;&gt; &lt;code&gt;[T]&lt;/code&gt; &lt;/a&gt; (также называемых &amp;laquo;срез&amp;raquo;). Многие вызовы методов на &lt;a href=&quot;string/struct.string&quot;&gt; &lt;code&gt;String&lt;/code&gt; &lt;/a&gt; и &lt;a href=&quot;vec/index&quot;&gt; &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; &lt;/a&gt; на самом деле являются вызовами методов на &lt;a href=&quot;primitive.str&quot;&gt; &lt;code&gt;str&lt;/code&gt; &lt;/a&gt; и &lt;a href=&quot;primitive.slice&quot;&gt; &lt;code&gt;[T]&lt;/code&gt; &lt;/a&gt; соответственно посредством приведения &lt;a href=&quot;../book/ch15-02-deref#implicit-deref-coercions-with-functions-and-methods&quot;&gt;deref&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="9ca3cd3caadb8f1bb227db05f6c5c7202e5bbf2b" translate="yes" xml:space="preserve">
          <source>Note to Implementors</source>
          <target state="translated">Примечание для исполнителей</target>
        </trans-unit>
        <trans-unit id="c4cf4c3bcaeb43c85321fdb977bbc1c650a58e54" translate="yes" xml:space="preserve">
          <source>Note to implementors: If this returns &lt;code&gt;Ok(ptr)&lt;/code&gt;, then &lt;code&gt;ptr&lt;/code&gt; must be considered &quot;currently allocated&quot; and must be acceptable input to methods such as &lt;code&gt;realloc&lt;/code&gt; or &lt;code&gt;dealloc&lt;/code&gt;, &lt;em&gt;even if&lt;/em&gt;&lt;code&gt;T&lt;/code&gt; is a zero-sized type. In other words, if your &lt;code&gt;Alloc&lt;/code&gt; implementation overrides this method in a manner that can return a zero-sized &lt;code&gt;ptr&lt;/code&gt;, then all reallocation and deallocation methods need to be similarly overridden to accept such values as input.</source>
          <target state="translated">Примечание для разработчиков: если это возвращает &lt;code&gt;Ok(ptr)&lt;/code&gt; , тогда &lt;code&gt;ptr&lt;/code&gt; должен считаться &amp;laquo;выделенным в данный момент&amp;raquo; и должен быть приемлемым вводом для таких методов, как &lt;code&gt;realloc&lt;/code&gt; или &lt;code&gt;dealloc&lt;/code&gt; , &lt;em&gt;даже если &lt;/em&gt; &lt;code&gt;T&lt;/code&gt; является типом нулевого размера. Другими словами, если ваша реализация &lt;code&gt;Alloc&lt;/code&gt; переопределяет этот метод таким образом, чтобы он мог возвращать &lt;code&gt;ptr&lt;/code&gt; нулевого размера , то все методы перераспределения и освобождения должны быть аналогичным образом переопределены, чтобы принимать такие значения в качестве входных.</target>
        </trans-unit>
        <trans-unit id="eb0cc1533f57d8d34b3b5bb324e9cedcd986a56b" translate="yes" xml:space="preserve">
          <source>Note two details here. First, we use the index value of &lt;code&gt;2&lt;/code&gt; to get the third element: vectors are indexed by number, starting at zero. Second, the two ways to get the third element are by using &lt;code&gt;&amp;amp;&lt;/code&gt; and &lt;code&gt;[]&lt;/code&gt;, which gives us a reference, or by using the &lt;code&gt;get&lt;/code&gt; method with the index passed as an argument, which gives us an &lt;code&gt;Option&amp;lt;&amp;amp;T&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">Обратите внимание на две детали здесь. Во-первых, мы используем значение индекса &lt;code&gt;2&lt;/code&gt; , чтобы получить третий элемент: векторы индексируются по номерам, начиная с нуля. Во-вторых, получить третий элемент можно двумя способами: с помощью &lt;code&gt;&amp;amp;&lt;/code&gt; и &lt;code&gt;[]&lt;/code&gt; , что дает нам ссылку, или с помощью метода &lt;code&gt;get&lt;/code&gt; с индексом, переданным в качестве аргумента, который дает нам &lt;code&gt;Option&amp;lt;&amp;amp;T&amp;gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3c6f9d9871d6089da68d73e5351d58428691fe43" translate="yes" xml:space="preserve">
          <source>Note, &lt;code&gt;OsString&lt;/code&gt; and &lt;a href=&quot;struct.osstr&quot;&gt;&lt;code&gt;OsStr&lt;/code&gt;&lt;/a&gt; internally do not necessarily hold strings in the form native to the platform; While on Unix, strings are stored as a sequence of 8-bit values, on Windows, where strings are 16-bit value based as just discussed, strings are also actually stored as a sequence of 8-bit values, encoded in a less-strict variant of UTF-8. This is useful to understand when handling capacity and length values.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c01e48a0e7e3eba8ed1aa3834f9c910b228bd638" translate="yes" xml:space="preserve">
          <source>Note, &lt;code&gt;OsString&lt;/code&gt; and &lt;code&gt;OsStr&lt;/code&gt; internally do not necessarily hold strings in the form native to the platform; While on Unix, strings are stored as a sequence of 8-bit values, on Windows, where strings are 16-bit value based as just discussed, strings are also actually stored as a sequence of 8-bit values, encoded in a less-strict variant of UTF-8. This is useful to understand when handling capacity and length values.</source>
          <target state="translated">Обратите внимание, что &lt;code&gt;OsString&lt;/code&gt; и &lt;code&gt;OsStr&lt;/code&gt; внутри не обязательно содержат строки в форме , присущей платформе; В то время как в Unix строки хранятся как последовательность 8-битных значений, в Windows, где строки представляют собой 16-битные значения на основе, как только что обсуждалось, строки также фактически хранятся как последовательность 8-битных значений, закодированных в менее строгий вариант UTF-8. Это полезно понимать при работе со значениями емкости и длины.</target>
        </trans-unit>
        <trans-unit id="1b6562c6a35d081cb513ca527b316f894645e45c" translate="yes" xml:space="preserve">
          <source>Note, however, that instants are not guaranteed to be &lt;strong&gt;steady&lt;/strong&gt;. In other words, each tick of the underlying clock may not be the same length (e.g. some seconds may be longer than others). An instant may jump forwards or experience time dilation (slow down or speed up), but it will never go backwards.</source>
          <target state="translated">Однако следует отметить, что моменты не гарантированно &lt;strong&gt;устойчивым&lt;/strong&gt; . Другими словами, каждый тик базовых часов может быть разной длины (например, некоторые секунды могут быть длиннее других). Мгновение может перескочить вперед или испытать замедление времени (замедление или ускорение), но оно никогда не вернется назад.</target>
        </trans-unit>
        <trans-unit id="9fd9dfc12db2bc0dbc56fcf4d3cda55381327924" translate="yes" xml:space="preserve">
          <source>Note, however, that items with the same name are allowed for inherent &lt;code&gt;impl&lt;/code&gt; blocks that don't overlap:</source>
          <target state="translated">Обратите внимание, однако, что элементы с тем же именем разрешены для &lt;code&gt;impl&lt;/code&gt; блоков impl, которые не перекрываются:</target>
        </trans-unit>
        <trans-unit id="bba68cd3cf8ae8ea0e35e174666c8e34f0cdd55c" translate="yes" xml:space="preserve">
          <source>Note, however, that this is not an unsafe trait, so there is not a succinct contract that this trait is providing. Instead it is intended as more of a &quot;speed bump&quot; to alert users of &lt;code&gt;catch_unwind&lt;/code&gt; that broken invariants may be witnessed and may need to be accounted for.</source>
          <target state="translated">Обратите внимание, однако, что это не небезопасная черта, поэтому не существует краткого контракта, предоставляемого этой чертой. Вместо этого он предназначен скорее как &amp;laquo; &lt;code&gt;catch_unwind&lt;/code&gt; &amp;raquo;, чтобы предупредить пользователей catch_unwind о том, что нарушенные инварианты могут быть засвидетельствованы и, возможно, необходимо учитывать.</target>
        </trans-unit>
        <trans-unit id="d9f40e0b31d5319e2e2946733cad557830f8c197" translate="yes" xml:space="preserve">
          <source>Note, in many cases, the &lt;code&gt;.parse()&lt;/code&gt; method on &lt;code&gt;str&lt;/code&gt; is more proper.</source>
          <target state="translated">Обратите внимание, что во многих случаях метод &lt;code&gt;.parse()&lt;/code&gt; для &lt;code&gt;str&lt;/code&gt; является более подходящим.</target>
        </trans-unit>
        <trans-unit id="83423c198b6099edba08f185f940042d5dba3b79" translate="yes" xml:space="preserve">
          <source>Note:</source>
          <target state="translated">Note:</target>
        </trans-unit>
        <trans-unit id="74d10a535a759833af93c81cb97d5c0957382347" translate="yes" xml:space="preserve">
          <source>Note: &lt;code&gt;Pin&lt;/code&gt; also implements &lt;code&gt;Deref&lt;/code&gt; to the target, which can be used to access the inner value. However, &lt;code&gt;Deref&lt;/code&gt; only provides a reference that lives for as long as the borrow of the &lt;code&gt;Pin&lt;/code&gt;, not the lifetime of the &lt;code&gt;Pin&lt;/code&gt; itself. This method allows turning the &lt;code&gt;Pin&lt;/code&gt; into a reference with the same lifetime as the original &lt;code&gt;Pin&lt;/code&gt;.</source>
          <target state="translated">Примечание: &lt;code&gt;Pin&lt;/code&gt; также реализует &lt;code&gt;Deref&lt;/code&gt; для цели, которая может использоваться для доступа к внутреннему значению. Однако &lt;code&gt;Deref&lt;/code&gt; предоставляет только ссылку, которая живет до тех пор, пока заимствована &lt;code&gt;Pin&lt;/code&gt; , а не время жизни самого &lt;code&gt;Pin&lt;/code&gt; . Этот метод позволяет превратить &lt;code&gt;Pin&lt;/code&gt; в ссылку с таким же сроком службы, что и исходный &lt;code&gt;Pin&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e10aafb3dc6afa8d8827646e5b1be7126b35103b" translate="yes" xml:space="preserve">
          <source>Note: &lt;code&gt;Pin&lt;/code&gt; also implements &lt;code&gt;DerefMut&lt;/code&gt; to the data, which can be used to access the inner value. However, &lt;code&gt;DerefMut&lt;/code&gt; only provides a reference that lives for as long as the borrow of the &lt;code&gt;Pin&lt;/code&gt;, not the lifetime of the &lt;code&gt;Pin&lt;/code&gt; itself. This method allows turning the &lt;code&gt;Pin&lt;/code&gt; into a reference with the same lifetime as the original &lt;code&gt;Pin&lt;/code&gt;.</source>
          <target state="translated">Примечание. &lt;code&gt;Pin&lt;/code&gt; также реализует &lt;code&gt;DerefMut&lt;/code&gt; для данных, которые можно использовать для доступа к внутреннему значению. Однако &lt;code&gt;DerefMut&lt;/code&gt; предоставляет только ссылку, которая живет до тех пор, пока заимствована &lt;code&gt;Pin&lt;/code&gt; , а не время жизни самого &lt;code&gt;Pin&lt;/code&gt; . Этот метод позволяет превратить &lt;code&gt;Pin&lt;/code&gt; в ссылку с таким же сроком службы, что и исходный &lt;code&gt;Pin&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="fe08fa35bb3e2ac30191647bef4f566cd6842a4b" translate="yes" xml:space="preserve">
          <source>Note: &lt;code&gt;core&lt;/code&gt; provides &lt;a href=&quot;https://doc.rust-lang.org/core/panic/struct.Location.html#method.caller&quot;&gt;&lt;code&gt;core::panic::Location::caller&lt;/code&gt;&lt;/a&gt; for observing caller locations. It wraps the &lt;a href=&quot;https://doc.rust-lang.org/core/intrinsics/fn.caller_location.html&quot;&gt;&lt;code&gt;core::intrinsics::caller_location&lt;/code&gt;&lt;/a&gt; intrinsic implemented by &lt;code&gt;rustc&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="da175d20fbd0f82cb13b82934a46d444a5435526" translate="yes" xml:space="preserve">
          <source>Note: &lt;code&gt;fold()&lt;/code&gt;, and similar methods that traverse the entire iterator, may not terminate for infinite iterators, even on traits for which a result is determinable in finite time.</source>
          <target state="translated">Примечание: &lt;code&gt;fold()&lt;/code&gt; и аналогичные методы, которые проходят через весь итератор, могут не завершаться для бесконечных итераторов, даже для признаков, для которых результат можно определить за конечное время.</target>
        </trans-unit>
        <trans-unit id="e47db031d7d5048ad3ea3101c6bbce09857b0d75" translate="yes" xml:space="preserve">
          <source>Note: &lt;code&gt;move&lt;/code&gt; closures may still implement &lt;a href=&quot;../../std/ops/trait.fn&quot;&gt;&lt;code&gt;Fn&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;../../std/ops/trait.fnmut&quot;&gt;&lt;code&gt;FnMut&lt;/code&gt;&lt;/a&gt;, even though they capture variables by move. This is because the traits implemented by a closure type are determined by what the closure does with captured values, not how it captures them.</source>
          <target state="translated">Примечание: замыкания &lt;code&gt;move&lt;/code&gt; могут по-прежнему реализовывать &lt;a href=&quot;../../std/ops/trait.fn&quot;&gt; &lt;code&gt;Fn&lt;/code&gt; &lt;/a&gt; или &lt;a href=&quot;../../std/ops/trait.fnmut&quot;&gt; &lt;code&gt;FnMut&lt;/code&gt; &lt;/a&gt; , даже если они захватывают переменные перемещением. Это связано с тем, что свойства, реализуемые типом замыкания, определяются тем, что замыкание делает с захваченными значениями, а не тем, как оно их захватывает.</target>
        </trans-unit>
        <trans-unit id="ddaee189fcb99b6fc9ed6acd8de34bd62f953e86" translate="yes" xml:space="preserve">
          <source>Note: &lt;code&gt;move&lt;/code&gt; closures may still implement &lt;a href=&quot;ops/trait.fn&quot;&gt;&lt;code&gt;Fn&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;ops/trait.fnmut&quot;&gt;&lt;code&gt;FnMut&lt;/code&gt;&lt;/a&gt;, even though they capture variables by &lt;code&gt;move&lt;/code&gt;. This is because the traits implemented by a closure type are determined by &lt;em&gt;what&lt;/em&gt; the closure does with captured values, not &lt;em&gt;how&lt;/em&gt; it captures them:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="690213e0deea1a6806299e07c579a3daee97b81a" translate="yes" xml:space="preserve">
          <source>Note: &lt;code&gt;rustc&lt;/code&gt; currently recognizes the tools &quot;clippy&quot; and &quot;rustfmt&quot;.</source>
          <target state="translated">Примечание: в настоящее время &lt;code&gt;rustc&lt;/code&gt; распознает инструменты clippy и rustfmt.</target>
        </trans-unit>
        <trans-unit id="16697ad37b7a39052ef81a40c40ae4ac1a88fc27" translate="yes" xml:space="preserve">
          <source>Note: &lt;code&gt;rustc&lt;/code&gt; has a default set of features enabled for each target and CPU. The CPU may be chosen with the &lt;a href=&quot;https://doc.rust-lang.org/rustc/codegen-options/index.html#target-cpu&quot;&gt;&lt;code&gt;-C target-cpu&lt;/code&gt;&lt;/a&gt; flag. Individual features may be enabled or disabled for an entire crate with the &lt;a href=&quot;https://doc.rust-lang.org/rustc/codegen-options/index.html#target-feature&quot;&gt;&lt;code&gt;-C target-feature&lt;/code&gt;&lt;/a&gt; flag.</source>
          <target state="translated">Примечание: &lt;code&gt;rustc&lt;/code&gt; имеет набор функций по умолчанию, включенных для каждой цели и процессора. ЦП можно выбрать с помощью флага &lt;a href=&quot;https://doc.rust-lang.org/rustc/codegen-options/index.html#target-cpu&quot;&gt; &lt;code&gt;-C target-cpu&lt;/code&gt; &lt;/a&gt; . Отдельные функции могут быть включены или отключены для всего ящика с помощью флага &lt;a href=&quot;https://doc.rust-lang.org/rustc/codegen-options/index.html#target-feature&quot;&gt; &lt;code&gt;-C target-feature&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="3f9c395bf29ddc7654449b79d4dc0411e7becef5" translate="yes" xml:space="preserve">
          <source>Note: &lt;code&gt;str&lt;/code&gt; in &lt;code&gt;Concat&amp;lt;str&amp;gt;&lt;/code&gt; is not meaningful here. This type parameter of the trait only exists to enable another impl.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c0d79cac345f205a82618d9422d71b4ef0b8bd13" translate="yes" xml:space="preserve">
          <source>Note: &lt;code&gt;union&lt;/code&gt;s with non-&lt;code&gt;Copy&lt;/code&gt; fields are unstable, see &lt;a href=&quot;https://github.com/rust-lang/rust/issues/55149&quot;&gt;55149&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="03f067cb5c2a75451afd3b78affad51470bfd979" translate="yes" xml:space="preserve">
          <source>Note: A saying you might hear about languages with strict compilers, such as Haskell and Rust, is &amp;ldquo;if the code compiles, it works.&amp;rdquo; But this saying is not universally true. Our project compiles, but it does absolutely nothing! If we were building a real, complete project, this would be a good time to start writing unit tests to check that the code compiles &lt;em&gt;and&lt;/em&gt; has the behavior we want.</source>
          <target state="translated">Примечание. О языках со строгими компиляторами, таких как Haskell и Rust, можно услышать поговорку: &amp;laquo;Если код компилируется, он работает&amp;raquo;. Но это высказывание не всегда верно. Наш проект компилируется, но ничего не делает! Если бы мы создавали настоящий, законченный проект, это было бы хорошее время, чтобы начать писать модульные тесты, чтобы проверить, компилируется ли код &lt;em&gt;и&lt;/em&gt; имеет ли он желаемое поведение.</target>
        </trans-unit>
        <trans-unit id="84c66645b448fa01124ab16b053b24421063478c" translate="yes" xml:space="preserve">
          <source>Note: Although Rust, like any other language, can be implemented by an interpreter as well as a compiler, the only existing implementation is a compiler, and the language has always been designed to be compiled. For these reasons, this section assumes a compiler.</source>
          <target state="translated">Замечание:Хотя Rust,как и любой другой язык,может быть реализован как интерпретатором,так и компилятором,единственная существующая реализация-это компилятор,и язык всегда разрабатывался для компиляции.По этим причинам в данном разделе предполагается компилятор.</target>
        </trans-unit>
        <trans-unit id="549bd43e93414c7d2e6a9dbfe6f61cd7449ba2c8" translate="yes" xml:space="preserve">
          <source>Note: As a consequence of the representation being an attribute on the item, the representation does not depend on generic parameters. Any two types with the same name have the same representation. For example, &lt;code&gt;Foo&amp;lt;Bar&amp;gt;&lt;/code&gt; and &lt;code&gt;Foo&amp;lt;Baz&amp;gt;&lt;/code&gt; both have the same representation.</source>
          <target state="translated">Примечание. Поскольку представление является атрибутом элемента, представление не зависит от общих параметров. Любые два типа с одинаковым именем имеют одинаковое представление. Например, &lt;code&gt;Foo&amp;lt;Bar&amp;gt;&lt;/code&gt; и &lt;code&gt;Foo&amp;lt;Baz&amp;gt;&lt;/code&gt; имеют одинаковое представление.</target>
        </trans-unit>
        <trans-unit id="4eecc607640ace8103d5bc0d89cfb23325aabecd" translate="yes" xml:space="preserve">
          <source>Note: As a control flow expression, if a block expression is the outer expression of an expression statement, the expected type is &lt;code&gt;()&lt;/code&gt; unless it is followed immediately by a semicolon.</source>
          <target state="translated">Примечание. В качестве выражения потока управления, если выражение блока является внешним выражением оператора выражения, ожидаемым типом является &lt;code&gt;()&lt;/code&gt; , если сразу после него не ставится точка с запятой.</target>
        </trans-unit>
        <trans-unit id="09b47fffa556007259b32260e62d1512eb70865a" translate="yes" xml:space="preserve">
          <source>Note: Due to the representation of &lt;code&gt;repr(C)&lt;/code&gt; structs and unions, if a variant has a single field there is no difference between putting that field directly in the union or wrapping it in a struct; any system which wishes to manipulate such an &lt;code&gt;enum&lt;/code&gt;'s representation may therefore use whichever form is more convenient or consistent for them.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4faa88d09ab8f796d3c14502d5099ff92578c5dd" translate="yes" xml:space="preserve">
          <source>Note: Except for lints, it is idiomatic to only use outer attributes on function items.</source>
          <target state="translated">Примечание:За исключением линтов,идиоматически использовать внешние атрибуты только на элементах функций.</target>
        </trans-unit>
        <trans-unit id="6b662a83fcf6e331b5fc245d3658b8a2a3115d43" translate="yes" xml:space="preserve">
          <source>Note: For clarity, it is recommended to always use the &lt;code&gt;dyn&lt;/code&gt; keyword on your trait objects unless your codebase supports compiling with Rust 1.26 or lower.</source>
          <target state="translated">Примечание: для ясности рекомендуется всегда использовать ключевое слово &lt;code&gt;dyn&lt;/code&gt; в ваших объектах признаков, если ваша кодовая база не поддерживает компиляцию с Rust 1.26 или ниже.</target>
        </trans-unit>
        <trans-unit id="1aaba7d58782adfa40a3a8e21596376db2da64ca" translate="yes" xml:space="preserve">
          <source>Note: For more on the implementation details of the &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; type, see &amp;ldquo;The Rustonomicon&amp;rdquo; at https://doc.rust-lang.org/stable/nomicon/vec.html.</source>
          <target state="translated">Примечание. Для получения дополнительных сведений о реализации типа &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; см. &amp;laquo;Rustonomicon&amp;raquo; на https://doc.rust-lang.org/stable/nomicon/vec.html.</target>
        </trans-unit>
        <trans-unit id="12ed0cecef028f179120e48d11efd24c874bfd2d" translate="yes" xml:space="preserve">
          <source>Note: For more on the implementation details of the &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; type, see &lt;a href=&quot;https://doc.rust-lang.org/nomicon/vec.html&quot;&gt;&amp;ldquo;The Rustonomicon&amp;rdquo;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0e05c47a1f80ea2f9b4aa153e205bdf1032d2902" translate="yes" xml:space="preserve">
          <source>Note: For simplicity&amp;rsquo;s sake, we&amp;rsquo;ll refer to many of the problems as &lt;em&gt;concurrent&lt;/em&gt; rather than being more precise by saying &lt;em&gt;concurrent and/or parallel&lt;/em&gt;. If this book were about concurrency and/or parallelism, we&amp;rsquo;d be more specific. For this chapter, please mentally substitute &lt;em&gt;concurrent and/or parallel&lt;/em&gt; whenever we use &lt;em&gt;concurrent&lt;/em&gt;.</source>
          <target state="translated">Примечание. Для простоты мы будем называть многие проблемы &lt;em&gt;параллельными,&lt;/em&gt; а не точнее говорить о &lt;em&gt;параллельных и / или параллельных&lt;/em&gt; . Если бы эта книга была о параллелизме и / или параллелизме, мы были бы более конкретными. В этой главе, пожалуйста, мысленно заменяйте &lt;em&gt;concurrent и / или parallel&lt;/em&gt; всякий раз, когда мы используем &lt;em&gt;concurrent&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="f2bcd0ee14b84ad9b9e572efa4f60a2cdc02453c" translate="yes" xml:space="preserve">
          <source>Note: Functions can implement all three of the &lt;code&gt;Fn&lt;/code&gt; traits too. If what we want to do doesn&amp;rsquo;t require capturing a value from the environment, we can use a function rather than a closure where we need something that implements an &lt;code&gt;Fn&lt;/code&gt; trait.</source>
          <target state="translated">Примечание. Функции также могут реализовывать все три черты &lt;code&gt;Fn&lt;/code&gt; . Если то, что мы хотим сделать, не требует захвата значения из среды, мы можем использовать функцию, а не замыкание, когда нам нужно что-то, реализующее черту &lt;code&gt;Fn&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7d3096da378822b99ae4c5c058d93a4ddaf9860b" translate="yes" xml:space="preserve">
          <source>Note: Git is a common version control system. You can change &lt;code&gt;cargo new&lt;/code&gt; to use a different version control system or no version control system by using the &lt;code&gt;--vcs&lt;/code&gt; flag. Run &lt;code&gt;cargo new --help&lt;/code&gt; to see the available options.</source>
          <target state="translated">Примечание. Git - это распространенная система контроля версий. Вы можете изменить &lt;code&gt;cargo new&lt;/code&gt; для использования другой системы контроля версий или отсутствия системы контроля версий с помощью флага &lt;code&gt;--vcs&lt;/code&gt; . Запустите &lt;code&gt;cargo new --help&lt;/code&gt; чтобы увидеть доступные параметры.</target>
        </trans-unit>
        <trans-unit id="0df14a643f96169ae07176fb1e5faadaf3d41970" translate="yes" xml:space="preserve">
          <source>Note: Historically, place expressions were called &lt;em&gt;lvalues&lt;/em&gt; and value expressions were called &lt;em&gt;rvalues&lt;/em&gt;.</source>
          <target state="translated">Примечание: Исторически выражения места назывались &lt;em&gt;lvalues,&lt;/em&gt; а выражения значений - &lt;em&gt;rvalues&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="95d17fa37d73d94b4ba6d7a45e2dff4566bcf95b" translate="yes" xml:space="preserve">
          <source>Note: If the &lt;code&gt;PeekMut&lt;/code&gt; value is leaked, the heap may be in an inconsistent state.</source>
          <target state="translated">Примечание. Если значение &lt;code&gt;PeekMut&lt;/code&gt; просочилось, куча может находиться в несогласованном состоянии.</target>
        </trans-unit>
        <trans-unit id="b84582c8d2e5caf9e744d83f9c53f4f316f3938a" translate="yes" xml:space="preserve">
          <source>Note: If you prefer not to use &lt;code&gt;rustup&lt;/code&gt; for some reason, please see &lt;a href=&quot;https://www.rust-lang.org/tools/install&quot;&gt;the Rust installation page&lt;/a&gt; for other options.</source>
          <target state="translated">Примечание: если вы по &lt;code&gt;rustup&lt;/code&gt; то причине предпочитаете не использовать rustup , пожалуйста, посетите &lt;a href=&quot;https://www.rust-lang.org/tools/install&quot;&gt;страницу установки Rust&lt;/a&gt; , чтобы узнать о других вариантах.</target>
        </trans-unit>
        <trans-unit id="0d58c0919378a7a1e84f8dd3400503ede165358e" translate="yes" xml:space="preserve">
          <source>Note: In C++, this pattern of deallocating resources at the end of an item&amp;rsquo;s lifetime is sometimes called &lt;em&gt;Resource Acquisition Is Initialization (RAII)&lt;/em&gt;. The &lt;code&gt;drop&lt;/code&gt; function in Rust will be familiar to you if you&amp;rsquo;ve used RAII patterns.</source>
          <target state="translated">Примечание. В C ++ этот шаблон освобождения ресурсов в конце жизненного цикла элемента иногда называется &lt;em&gt;инициализацией получения ресурсов (RAII)&lt;/em&gt; . Функция &lt;code&gt;drop&lt;/code&gt; в Rust будет вам знакома, если вы использовали шаблоны RAII.</target>
        </trans-unit>
        <trans-unit id="54b56211cde322330df3d7c8028b1e66317b030b" translate="yes" xml:space="preserve">
          <source>Note: In general, you should not use &lt;code&gt;FusedIterator&lt;/code&gt; in generic bounds if you need a fused iterator. Instead, you should just call &lt;a href=&quot;trait.iterator#method.fuse&quot;&gt;&lt;code&gt;Iterator::fuse()&lt;/code&gt;&lt;/a&gt; on the iterator. If the iterator is already fused, the additional &lt;a href=&quot;struct.fuse&quot;&gt;&lt;code&gt;Fuse&lt;/code&gt;&lt;/a&gt; wrapper will be a no-op with no performance penalty.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="de232dc8ccf3ad3cf06506f2846d4c5ae30df0ce" translate="yes" xml:space="preserve">
          <source>Note: In general, you should not use &lt;code&gt;FusedIterator&lt;/code&gt; in generic bounds if you need a fused iterator. Instead, you should just call &lt;a href=&quot;trait.iterator#method.fuse&quot;&gt;&lt;code&gt;Iterator::fuse&lt;/code&gt;&lt;/a&gt; on the iterator. If the iterator is already fused, the additional &lt;a href=&quot;struct.fuse&quot;&gt;&lt;code&gt;Fuse&lt;/code&gt;&lt;/a&gt; wrapper will be a no-op with no performance penalty.</source>
          <target state="translated">Примечание. В общем случае не следует использовать &lt;code&gt;FusedIterator&lt;/code&gt; в общих границах, если вам нужен объединенный итератор. Вместо этого вы должны просто вызвать &lt;a href=&quot;trait.iterator#method.fuse&quot;&gt; &lt;code&gt;Iterator::fuse&lt;/code&gt; &lt;/a&gt; на итераторе. Если итератор уже объединен, дополнительная оболочка &lt;a href=&quot;struct.fuse&quot;&gt; &lt;code&gt;Fuse&lt;/code&gt; не&lt;/a&gt; будет работать без потери производительности.</target>
        </trans-unit>
        <trans-unit id="30cece00231291046dd06875e4aca4bb16fbdc74" translate="yes" xml:space="preserve">
          <source>Note: In the edge case where you're seeking with &lt;a href=&quot;enum.seekfrom#variant.Current&quot;&gt;&lt;code&gt;SeekFrom::Current&lt;/code&gt;&lt;/a&gt;&lt;code&gt;(n)&lt;/code&gt; where &lt;code&gt;n&lt;/code&gt; minus the internal buffer length overflows an &lt;code&gt;i64&lt;/code&gt;, two seeks will be performed instead of one. If the second seek returns &lt;a href=&quot;../result/enum.result#variant.Err&quot;&gt;&lt;code&gt;Err&lt;/code&gt;&lt;/a&gt;, the underlying reader will be left at the same position it would have if you called &lt;code&gt;seek&lt;/code&gt; with &lt;a href=&quot;enum.seekfrom#variant.Current&quot;&gt;&lt;code&gt;SeekFrom::Current&lt;/code&gt;&lt;/a&gt;&lt;code&gt;(0)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
