<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ru" datatype="htmlbody" original="rust">
    <body>
      <group id="rust">
        <trans-unit id="fe9cf4a133a88b8bc470c4394f4eb8cf3b306e68" translate="yes" xml:space="preserve">
          <source>This is an alias to &lt;a href=&quot;../fs/fn.read_dir&quot;&gt;&lt;code&gt;fs::read_dir&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Это псевдоним для &lt;a href=&quot;../fs/fn.read_dir&quot;&gt; &lt;code&gt;fs::read_dir&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="f461dafd60906d9babd38850b381951321bafa0a" translate="yes" xml:space="preserve">
          <source>This is an alias to &lt;a href=&quot;../fs/fn.read_link&quot;&gt;&lt;code&gt;fs::read_link&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Это псевдоним для &lt;a href=&quot;../fs/fn.read_link&quot;&gt; &lt;code&gt;fs::read_link&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="8a772f821d093dc45f53501fe5deb3218dd74356" translate="yes" xml:space="preserve">
          <source>This is an alias to &lt;a href=&quot;../fs/fn.symlink_metadata&quot;&gt;&lt;code&gt;fs::symlink_metadata&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Это псевдоним для &lt;a href=&quot;../fs/fn.symlink_metadata&quot;&gt; &lt;code&gt;fs::symlink_metadata&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="d34ac7564172d2ff8117857aff9df3320c42fae5" translate="yes" xml:space="preserve">
          <source>This is an associated function that needs to be used as &lt;code&gt;Ref::clone(...)&lt;/code&gt;. A &lt;code&gt;Clone&lt;/code&gt; implementation or a method would interfere with the widespread use of &lt;code&gt;r.borrow().clone()&lt;/code&gt; to clone the contents of a &lt;code&gt;RefCell&lt;/code&gt;.</source>
          <target state="translated">Это связанная функция, которую нужно использовать как &lt;code&gt;Ref::clone(...)&lt;/code&gt; . &lt;code&gt;Clone&lt;/code&gt; реализации или метод будет препятствовать широкому использованию &lt;code&gt;r.borrow().clone()&lt;/code&gt; , чтобы клонировать содержимое &lt;code&gt;RefCell&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0de597cdfc25d4b695eb376a8a0838157803d015" translate="yes" xml:space="preserve">
          <source>This is an associated function that needs to be used as &lt;code&gt;Ref::leak(...)&lt;/code&gt;. A method would interfere with methods of the same name on the contents of a &lt;code&gt;RefCell&lt;/code&gt; used through &lt;code&gt;Deref&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f83e3e547dadb3f845f93bfeaf6231ee030e91c8" translate="yes" xml:space="preserve">
          <source>This is an associated function that needs to be used as &lt;code&gt;Ref::map(...)&lt;/code&gt;. A method would interfere with methods of the same name on the contents of a &lt;code&gt;RefCell&lt;/code&gt; used through &lt;code&gt;Deref&lt;/code&gt;.</source>
          <target state="translated">Это связанная функция, которую нужно использовать как &lt;code&gt;Ref::map(...)&lt;/code&gt; . Метод будет мешать одноименным методам содержимого &lt;code&gt;RefCell&lt;/code&gt; , используемого через &lt;code&gt;Deref&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2f18aedd0b02030c35b1012078adf973833d874e" translate="yes" xml:space="preserve">
          <source>This is an associated function that needs to be used as &lt;code&gt;Ref::map_split(...)&lt;/code&gt;. A method would interfere with methods of the same name on the contents of a &lt;code&gt;RefCell&lt;/code&gt; used through &lt;code&gt;Deref&lt;/code&gt;.</source>
          <target state="translated">Это связанная функция, которую нужно использовать как &lt;code&gt;Ref::map_split(...)&lt;/code&gt; . Метод будет мешать одноименным методам содержимого &lt;code&gt;RefCell&lt;/code&gt; , используемого через &lt;code&gt;Deref&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b9124c09eb61044a9051beed91e77bd6ffcbf176" translate="yes" xml:space="preserve">
          <source>This is an associated function that needs to be used as &lt;code&gt;RefMut::leak(...)&lt;/code&gt;. A method would interfere with methods of the same name on the contents of a &lt;code&gt;RefCell&lt;/code&gt; used through &lt;code&gt;Deref&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="14ab5139ea01a60d2224bebc358fd7f5a09aee7b" translate="yes" xml:space="preserve">
          <source>This is an associated function that needs to be used as &lt;code&gt;RefMut::map(...)&lt;/code&gt;. A method would interfere with methods of the same name on the contents of a &lt;code&gt;RefCell&lt;/code&gt; used through &lt;code&gt;Deref&lt;/code&gt;.</source>
          <target state="translated">Это связанная функция, которую нужно использовать как &lt;code&gt;RefMut::map(...)&lt;/code&gt; . Метод будет мешать одноименным методам содержимого &lt;code&gt;RefCell&lt;/code&gt; , используемого через &lt;code&gt;Deref&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="202f23e551bc61ba34f51a486b60ddfce30150ab" translate="yes" xml:space="preserve">
          <source>This is an associated function that needs to be used as &lt;code&gt;RefMut::map_split(...)&lt;/code&gt;. A method would interfere with methods of the same name on the contents of a &lt;code&gt;RefCell&lt;/code&gt; used through &lt;code&gt;Deref&lt;/code&gt;.</source>
          <target state="translated">Это связанная функция, которую нужно использовать как &lt;code&gt;RefMut::map_split(...)&lt;/code&gt; . Метод будет мешать одноименным методам содержимого &lt;code&gt;RefCell&lt;/code&gt; , используемого через &lt;code&gt;Deref&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="fb3bd037be08bb82591900e7ddf468637a2b8c80" translate="yes" xml:space="preserve">
          <source>This is appropriate for initializing uninitialized memory, or overwriting memory that has previously been &lt;a href=&quot;fn.read&quot;&gt;&lt;code&gt;read&lt;/code&gt;&lt;/a&gt; from.</source>
          <target state="translated">Это подходит для инициализации неинициализированной памяти или перезаписи памяти, из которой ранее было выполнено &lt;a href=&quot;fn.read&quot;&gt; &lt;code&gt;read&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="856709efbf0ee049257184bc9760c0b3d18a43eb" translate="yes" xml:space="preserve">
          <source>This is appropriate for initializing uninitialized memory, or overwriting memory that has previously been read with &lt;a href=&quot;fn.read_unaligned&quot;&gt;&lt;code&gt;read_unaligned&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Это подходит для инициализации неинициализированной памяти или перезаписи памяти, которая ранее была прочитана с помощью &lt;a href=&quot;fn.read_unaligned&quot;&gt; &lt;code&gt;read_unaligned&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="9049d14f9f0cb6f47694e4f8dd6256baa32e595c" translate="yes" xml:space="preserve">
          <source>This is based on &lt;code&gt;malloc&lt;/code&gt; on Unix platforms and &lt;code&gt;HeapAlloc&lt;/code&gt; on Windows, plus related functions.</source>
          <target state="translated">Это основано на &lt;code&gt;malloc&lt;/code&gt; на платформах Unix и на &lt;code&gt;HeapAlloc&lt;/code&gt; на Windows, а также на связанных функциях.</target>
        </trans-unit>
        <trans-unit id="d9e17b1971fcc8ebac923ca9bdcdbe86fd7ccc27" translate="yes" xml:space="preserve">
          <source>This is because &lt;code&gt;AddAssign&lt;/code&gt; is not automatically implemented, so you need to manually implement it for your type.</source>
          <target state="translated">Это связано с тем, что &lt;code&gt;AddAssign&lt;/code&gt; не реализуется автоматически, поэтому вам необходимо вручную реализовать его для вашего типа.</target>
        </trans-unit>
        <trans-unit id="5c0cfc8e697e9e04f2ac8988522860bd36ed371a" translate="yes" xml:space="preserve">
          <source>This is because cell types do operations that are not thread-safe. Due to this, they don't implement Sync and thus can't be placed in statics.</source>
          <target state="translated">Это связано с тем,что типы ячеек выполняют операции,которые не являются потокобезопасными.Из-за этого они не реализуют Sync и,следовательно,не могут быть размещены в статике.</target>
        </trans-unit>
        <trans-unit id="43247ccf0e7189f6826d62c195b63176c827f652" translate="yes" xml:space="preserve">
          <source>This is because of a type mismatch between the associated type of some trait (e.g., &lt;code&gt;T::Bar&lt;/code&gt;, where &lt;code&gt;T&lt;/code&gt; implements &lt;code&gt;trait Quux { type Bar; }&lt;/code&gt;) and another type &lt;code&gt;U&lt;/code&gt; that is required to be equal to &lt;code&gt;T::Bar&lt;/code&gt;, but is not. Examples follow.</source>
          <target state="translated">Это происходит из-за несоответствия типов между ассоциированным типом некоторого признака (например, &lt;code&gt;T::Bar&lt;/code&gt; , где &lt;code&gt;T&lt;/code&gt; реализует &lt;code&gt;trait Quux { type Bar; }&lt;/code&gt; ) и другим типом &lt;code&gt;U&lt;/code&gt; , который должен быть равен &lt;code&gt;T::Bar&lt;/code&gt; , но не является. Примеры приведены ниже.</target>
        </trans-unit>
        <trans-unit id="0e543293d9c4cb900df2afb34a1c801950192149" translate="yes" xml:space="preserve">
          <source>This is because there could exist &lt;code&gt;V&lt;/code&gt; types with multiple &lt;code&gt;Borrow&amp;lt;[_]&amp;gt;&lt;/code&gt; impls, such that multiple &lt;code&gt;T&lt;/code&gt; types would apply:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a641717e833808f9f0bc4f5f362a54b6a1faff5b" translate="yes" xml:space="preserve">
          <source>This is borrow-generalized version of &lt;code&gt;Clone::clone_from&lt;/code&gt;.</source>
          <target state="translated">Это обобщенная версия &lt;code&gt;Clone::clone_from&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="834216017331c86ca1e125eb990783c9079a99f6" translate="yes" xml:space="preserve">
          <source>This is called the &amp;ldquo;train model&amp;rdquo; because every six weeks, a release &amp;ldquo;leaves the station&amp;rdquo;, but still has to take a journey through the beta channel before it arrives as a stable release.</source>
          <target state="translated">Это называется &amp;laquo;поездной моделью&amp;raquo;, потому что каждые шесть недель релиз &amp;laquo;покидает станцию&amp;raquo;, но все равно должен пройти через бета-канал, прежде чем он станет стабильным.</target>
        </trans-unit>
        <trans-unit id="d83e7e82097d376958eb95d5e51d98e6719f2542" translate="yes" xml:space="preserve">
          <source>This is catastrophic, it means we can first pin the content of the &lt;a href=&quot;../cell/struct.refcell&quot;&gt;&lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt; (using &lt;code&gt;RefCell::get_pin_mut&lt;/code&gt;) and then move that content using the mutable reference we got later.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a9e339d64ba30c9973394f6282049233c7be4f71" translate="yes" xml:space="preserve">
          <source>This is catastrophic, it means we can first pin the content of the &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt; (using &lt;code&gt;RefCell::get_pin_mut&lt;/code&gt;) and then move that content using the mutable reference we got later.</source>
          <target state="translated">Это катастрофа, это означает, что мы можем сначала закрепить содержимое &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt; (используя &lt;code&gt;RefCell::get_pin_mut&lt;/code&gt; ), а затем переместить это содержимое, используя изменяемую ссылку, которую мы получили позже.</target>
        </trans-unit>
        <trans-unit id="9ed19556018375489742916bfb6ea73b08918fbf" translate="yes" xml:space="preserve">
          <source>This is commonly used to adapt a single value generator into a &lt;a href=&quot;trait.iterator#method.chain&quot;&gt;&lt;code&gt;chain()&lt;/code&gt;&lt;/a&gt; of other kinds of iteration. Maybe you have an iterator that covers almost everything, but you need an extra special case. Maybe you have a function which works on iterators, but you only need to process one value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="67913f9219472099fcca84773f5f227006ffbcce" translate="yes" xml:space="preserve">
          <source>This is commonly used to adapt a single value generator into a &lt;a href=&quot;trait.iterator#method.chain&quot;&gt;&lt;code&gt;chain&lt;/code&gt;&lt;/a&gt; of other kinds of iteration. Maybe you have an iterator that covers almost everything, but you need an extra special case. Maybe you have a function which works on iterators, but you only need to process one value.</source>
          <target state="translated">Это обычно используется для адаптации одного генератора значений к &lt;a href=&quot;trait.iterator#method.chain&quot;&gt; &lt;code&gt;chain&lt;/code&gt; &lt;/a&gt; других видов итераций. Возможно, у вас есть итератор, который охватывает почти все, но вам нужен особый случай. Возможно, у вас есть функция, которая работает с итераторами, но вам нужно обработать только одно значение.</target>
        </trans-unit>
        <trans-unit id="507d399d0caa748ec0f687d63827f62d38ea93b1" translate="yes" xml:space="preserve">
          <source>This is commonly used to adapt a single value into a &lt;a href=&quot;trait.iterator#method.chain&quot;&gt;&lt;code&gt;chain()&lt;/code&gt;&lt;/a&gt; of other kinds of iteration. Maybe you have an iterator that covers almost everything, but you need an extra special case. Maybe you have a function which works on iterators, but you only need to process one value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="764e0240ad7ec9a9585ed8305ceb8e8099f2723d" translate="yes" xml:space="preserve">
          <source>This is commonly used to adapt a single value into a &lt;a href=&quot;trait.iterator#method.chain&quot;&gt;&lt;code&gt;chain&lt;/code&gt;&lt;/a&gt; of other kinds of iteration. Maybe you have an iterator that covers almost everything, but you need an extra special case. Maybe you have a function which works on iterators, but you only need to process one value.</source>
          <target state="translated">Это обычно используется для адаптации одного значения в &lt;a href=&quot;trait.iterator#method.chain&quot;&gt; &lt;code&gt;chain&lt;/code&gt; &lt;/a&gt; других видов итераций. Возможно, у вас есть итератор, который охватывает почти все, но вам нужен особый случай. Возможно, у вас есть функция, которая работает с итераторами, но вам нужно обработать только одно значение.</target>
        </trans-unit>
        <trans-unit id="f239b530d28c30ec1070f1658b16620a287e3251" translate="yes" xml:space="preserve">
          <source>This is correct (explicit):</source>
          <target state="translated">Это верно (прямо):</target>
        </trans-unit>
        <trans-unit id="7d6342cfa6f9200a801992dcf925b5cee5be4a5b" translate="yes" xml:space="preserve">
          <source>This is currently identical to &lt;code&gt;transmute::&amp;lt;f32, u32&amp;gt;(self)&lt;/code&gt; on all platforms.</source>
          <target state="translated">В настоящее время это идентично &lt;code&gt;transmute::&amp;lt;f32, u32&amp;gt;(self)&lt;/code&gt; на всех платформах.</target>
        </trans-unit>
        <trans-unit id="a48f92d085d1c5423be432a065e6504acd5a4a36" translate="yes" xml:space="preserve">
          <source>This is currently identical to &lt;code&gt;transmute::&amp;lt;f64, u64&amp;gt;(self)&lt;/code&gt; on all platforms.</source>
          <target state="translated">В настоящее время это идентично &lt;code&gt;transmute::&amp;lt;f64, u64&amp;gt;(self)&lt;/code&gt; на всех платформах.</target>
        </trans-unit>
        <trans-unit id="918c5990ef12f35794f26c0b83e42a5d2ef0c694" translate="yes" xml:space="preserve">
          <source>This is currently identical to &lt;code&gt;transmute::&amp;lt;u32, f32&amp;gt;(v)&lt;/code&gt; on all platforms. It turns out this is incredibly portable, for two reasons:</source>
          <target state="translated">В настоящее время это идентично &lt;code&gt;transmute::&amp;lt;u32, f32&amp;gt;(v)&lt;/code&gt; на всех платформах. Оказывается, это невероятно портативно по двум причинам:</target>
        </trans-unit>
        <trans-unit id="00309d71e504692e129d008c7a1eff96961c44fc" translate="yes" xml:space="preserve">
          <source>This is currently identical to &lt;code&gt;transmute::&amp;lt;u64, f64&amp;gt;(v)&lt;/code&gt; on all platforms. It turns out this is incredibly portable, for two reasons:</source>
          <target state="translated">В настоящее время это идентично &lt;code&gt;transmute::&amp;lt;u64, f64&amp;gt;(v)&lt;/code&gt; на всех платформах. Оказывается, это невероятно портативно по двум причинам:</target>
        </trans-unit>
        <trans-unit id="de7179edea4813efbd79fdfefd23f0fcc07d0700" translate="yes" xml:space="preserve">
          <source>This is defined in &lt;a href=&quot;https://tools.ietf.org/html/rfc5737&quot;&gt;IETF RFC 5737&lt;/a&gt;:</source>
          <target state="translated">Это определено в &lt;a href=&quot;https://tools.ietf.org/html/rfc5737&quot;&gt;IETF RFC 5737&lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="59a6ad6e6ae513088e0c1bb8ed9888b474a9dbba" translate="yes" xml:space="preserve">
          <source>This is designed to be used in conjunction with &lt;a href=&quot;fn.catch_unwind&quot;&gt;&lt;code&gt;catch_unwind&lt;/code&gt;&lt;/a&gt; to, for example, carry a panic across a layer of C code.</source>
          <target state="translated">Это предназначено для использования в сочетании с &lt;a href=&quot;fn.catch_unwind&quot;&gt; &lt;code&gt;catch_unwind&lt;/code&gt; &lt;/a&gt; , например, для передачи паники через слой кода C.</target>
        </trans-unit>
        <trans-unit id="5fdeff8202418046160b5ede029f4ae17e4cb706" translate="yes" xml:space="preserve">
          <source>This is different than the &lt;code&gt;C&lt;/code&gt; representation because a struct with the &lt;code&gt;C&lt;/code&gt; representation will always have the ABI of a &lt;code&gt;C&lt;/code&gt;&lt;code&gt;struct&lt;/code&gt; while, for example, a struct with the &lt;code&gt;transparent&lt;/code&gt; representation with a primitive field will have the ABI of the primitive field.</source>
          <target state="translated">Это отличается от представления &lt;code&gt;C&lt;/code&gt; , потому что структура с представлением &lt;code&gt;C&lt;/code&gt; всегда будет иметь ABI &lt;code&gt;struct&lt;/code&gt; &lt;code&gt;C&lt;/code&gt; ,в то время как, например, структура с &lt;code&gt;transparent&lt;/code&gt; представлением с примитивным полем будет иметь ABI примитивного поля.</target>
        </trans-unit>
        <trans-unit id="f40a48629593c80076df828df6524a31bbb5832c" translate="yes" xml:space="preserve">
          <source>This is done as if by the Euclidean division algorithm -- given &lt;code&gt;r = self.rem_euclid(rhs)&lt;/code&gt;, &lt;code&gt;self = rhs * self.div_euclid(rhs) + r&lt;/code&gt;, and &lt;code&gt;0 &amp;lt;= r &amp;lt; abs(rhs)&lt;/code&gt;.</source>
          <target state="translated">Это делается, как если бы по алгоритму евклидова деления - задано &lt;code&gt;r = self.rem_euclid(rhs)&lt;/code&gt; , &lt;code&gt;self = rhs * self.div_euclid(rhs) + r&lt;/code&gt; и &lt;code&gt;0 &amp;lt;= r &amp;lt; abs(rhs)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="261341fb7dbde0853cc1e229f30dada63a712ac0" translate="yes" xml:space="preserve">
          <source>This is enforced by the Rust compiler. However, there are situations where this rule is not flexible enough. Sometimes it is required to have multiple references to an object and yet mutate it.</source>
          <target state="translated">Это предписано компилятором Rust.Однако бывают ситуации,когда это правило не является достаточно гибким.Иногда требуется иметь несколько ссылок на объект и при этом мутировать его.</target>
        </trans-unit>
        <trans-unit id="1a48a3285621637ef35ee331d4de4979ad866379" translate="yes" xml:space="preserve">
          <source>This is equivalent to &lt;code&gt;self.seek(SeekFrom::Current(0))&lt;/code&gt;.</source>
          <target state="translated">Это эквивалентно &lt;code&gt;self.seek(SeekFrom::Current(0))&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ea3c08c47d3f2c239e1b0612d35fd093489ce76f" translate="yes" xml:space="preserve">
          <source>This is equivalent to &lt;code&gt;to_ascii_lowercase(a) == to_ascii_lowercase(b)&lt;/code&gt;.</source>
          <target state="translated">Это эквивалентно &lt;code&gt;to_ascii_lowercase(a) == to_ascii_lowercase(b)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a97a7d1bcb8cd7cc77582edff43cedf5b5f9e7ec" translate="yes" xml:space="preserve">
          <source>This is equivalent to adding the result of &lt;code&gt;padding_needed_for&lt;/code&gt; to the layout's current size.</source>
          <target state="translated">Это эквивалентно добавлению результата &lt;code&gt;padding_needed_for&lt;/code&gt; к текущему размеру макета.</target>
        </trans-unit>
        <trans-unit id="cd40c4706f12ddab3deeab19ddffb1056c56c24a" translate="yes" xml:space="preserve">
          <source>This is equivalent to casting &lt;code&gt;self&lt;/code&gt; to &lt;code&gt;*const T&lt;/code&gt;, but more type-safe.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b1cc6c65ebdd0a382483c4dc8c7f13d29cc10dc3" translate="yes" xml:space="preserve">
          <source>This is equivalent to casting &lt;code&gt;self&lt;/code&gt; to &lt;code&gt;*mut T&lt;/code&gt;, but more type-safe.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f6cc1d085b275d07a515f10b6c1293ccce68e246" translate="yes" xml:space="preserve">
          <source>This is equivalent to sending a SIGKILL on Unix platforms.</source>
          <target state="translated">Это эквивалентно отправке SIGKILL на платформах Unix.</target>
        </trans-unit>
        <trans-unit id="f985a290d8b35439e1509532b1f307ab14186afb" translate="yes" xml:space="preserve">
          <source>This is equivalent to the &lt;code&gt;Deref&lt;/code&gt; impl, but is explicit.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dbb80b753a6a285f62ca3be46d0ca7ebb71f7211" translate="yes" xml:space="preserve">
          <source>This is equivalent to using a &lt;a href=&quot;../../book/ch03-05-control-flow#looping-through-a-collection-with-for&quot;&gt;&lt;code&gt;for&lt;/code&gt;&lt;/a&gt; loop on the iterator, although &lt;code&gt;break&lt;/code&gt; and &lt;code&gt;continue&lt;/code&gt; are not possible from a closure. It's generally more idiomatic to use a &lt;code&gt;for&lt;/code&gt; loop, but &lt;code&gt;for_each&lt;/code&gt; may be more legible when processing items at the end of longer iterator chains. In some cases &lt;code&gt;for_each&lt;/code&gt; may also be faster than a loop, because it will use internal iteration on adaptors like &lt;code&gt;Chain&lt;/code&gt;.</source>
          <target state="translated">Это эквивалентно использованию цикла &lt;a href=&quot;../../book/ch03-05-control-flow#looping-through-a-collection-with-for&quot;&gt; &lt;code&gt;for&lt;/code&gt; &lt;/a&gt; в итераторе, хотя &lt;code&gt;break&lt;/code&gt; и &lt;code&gt;continue&lt;/code&gt; невозможны из закрытия. Как правило, более идиоматично использовать цикл &lt;code&gt;for&lt;/code&gt; , но &lt;code&gt;for_each&lt;/code&gt; может быть более разборчивым при обработке элементов в конце более длинных цепочек итераторов. В некоторых случаях &lt;code&gt;for_each&lt;/code&gt; также может быть быстрее цикла, потому что он будет использовать внутреннюю итерацию на адаптерах, таких как &lt;code&gt;Chain&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="85aa708c3c4c286a53847d7118e6789eccd018b1" translate="yes" xml:space="preserve">
          <source>This is essentially the reversed version of &lt;a href=&quot;trait.iterator#method.nth&quot;&gt;&lt;code&gt;Iterator::nth()&lt;/code&gt;&lt;/a&gt;. Although like most indexing operations, the count starts from zero, so &lt;code&gt;nth_back(0)&lt;/code&gt; returns the first value from the end, &lt;code&gt;nth_back(1)&lt;/code&gt; the second, and so on.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0d5fc7a87669eb5a575d2a14569feb14339d998c" translate="yes" xml:space="preserve">
          <source>This is essentially the reversed version of &lt;a href=&quot;trait.iterator#method.nth&quot;&gt;&lt;code&gt;nth&lt;/code&gt;&lt;/a&gt;. Although like most indexing operations, the count starts from zero, so &lt;code&gt;nth_back(0)&lt;/code&gt; returns the first value fro the end, &lt;code&gt;nth_back(1)&lt;/code&gt; the second, and so on.</source>
          <target state="translated">По сути, это перевернутая версия &lt;a href=&quot;trait.iterator#method.nth&quot;&gt; &lt;code&gt;nth&lt;/code&gt; &lt;/a&gt; . Хотя, как и большинство операций индексирования, счет начинается с нуля, поэтому &lt;code&gt;nth_back(0)&lt;/code&gt; возвращает первое значение из конца, &lt;code&gt;nth_back(1)&lt;/code&gt; - второе и так далее.</target>
        </trans-unit>
        <trans-unit id="da357ed847b3be924604524d54de90650dc840c5" translate="yes" xml:space="preserve">
          <source>This is exactly the kind of guarantee that the intrusive linked list from the previous section needs to function correctly.</source>
          <target state="translated">Это как раз та гарантия,что навязчивый связанный список из предыдущего раздела должен корректно функционировать.</target>
        </trans-unit>
        <trans-unit id="bb45c58beba541079b29f983c2bd8c56db26b71e" translate="yes" xml:space="preserve">
          <source>This is exploited by the compiler for various optimizations, such as eliding run-time checks and optimizing &lt;code&gt;enum&lt;/code&gt; layout.</source>
          <target state="translated">Это используется компилятором для различных оптимизаций, таких как исключение проверок времени выполнения и оптимизация компоновки &lt;code&gt;enum&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2800cba431c3f0317ff7290328c22feda7e8a245" translate="yes" xml:space="preserve">
          <source>This is fixed by declaring the impl block like this:</source>
          <target state="translated">Это фиксируется путем объявления блока имплантата таким образом:</target>
        </trans-unit>
        <trans-unit id="7800b5b60ece10a2bb3977b34790a457f9ba1d9b" translate="yes" xml:space="preserve">
          <source>This is generally created by methods like &lt;a href=&quot;struct.mutex#method.lock&quot;&gt;&lt;code&gt;Mutex::lock&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;struct.rwlock#method.read&quot;&gt;&lt;code&gt;RwLock::read&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Обычно это создается такими методами, как &lt;a href=&quot;struct.mutex#method.lock&quot;&gt; &lt;code&gt;Mutex::lock&lt;/code&gt; &lt;/a&gt; или &lt;a href=&quot;struct.rwlock#method.read&quot;&gt; &lt;code&gt;RwLock::read&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="d04e3acde7f8ef92dfb6b7b52b3e3c3811cad1e0" translate="yes" xml:space="preserve">
          <source>This is generally not recommended, use with caution! For a safe alternative see &lt;a href=&quot;#method.get&quot;&gt;&lt;code&gt;get&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Как правило, это не рекомендуется, используйте с осторожностью! Для получения более безопасной альтернативы см. &lt;a href=&quot;#method.get&quot;&gt; &lt;code&gt;get&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="4bd5c92d6bc3bc69b3d544b464184377050cce05" translate="yes" xml:space="preserve">
          <source>This is generally not recommended, use with caution! For a safe alternative see &lt;a href=&quot;#method.get_mut&quot;&gt;&lt;code&gt;get_mut&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Как правило, это не рекомендуется, используйте с осторожностью! Для безопасной альтернативы см. &lt;a href=&quot;#method.get_mut&quot;&gt; &lt;code&gt;get_mut&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="1be3a48c43f2cbe9f66bb8b317aa83c1345f1b36" translate="yes" xml:space="preserve">
          <source>This is generally not recommended, use with caution! For a safe alternative see &lt;a href=&quot;../primitive.str&quot;&gt;&lt;code&gt;str&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../ops/trait.index&quot;&gt;&lt;code&gt;Index&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="60f2e569769a80d9853e1327c13dd3289346f0be" translate="yes" xml:space="preserve">
          <source>This is generally not recommended, use with caution! For a safe alternative see &lt;a href=&quot;primitive.str&quot;&gt;&lt;code&gt;str&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;ops/trait.index&quot;&gt;&lt;code&gt;Index&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Как правило, это не рекомендуется, используйте с осторожностью! Для более безопасной альтернативы см. &lt;a href=&quot;primitive.str&quot;&gt; &lt;code&gt;str&lt;/code&gt; &lt;/a&gt; и &lt;a href=&quot;ops/trait.index&quot;&gt; &lt;code&gt;Index&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="5835397a3648f1790072b1697b1686de073dd8a5" translate="yes" xml:space="preserve">
          <source>This is highly unsafe, due to the number of invariants that aren't checked:</source>
          <target state="translated">Это крайне небезопасно из-за количества инвариантов,которые не проверяются:</target>
        </trans-unit>
        <trans-unit id="75907ab0f8297b43f4704528d57293015e32b770" translate="yes" xml:space="preserve">
          <source>This is implemented as an intrinsic to avoid converting to and from an integer, since the conversion inhibits certain optimizations.</source>
          <target state="translated">Это реализовано как неотъемлемая часть,чтобы избежать преобразования в целое число и из него,так как преобразование препятствует некоторым оптимизациям.</target>
        </trans-unit>
        <trans-unit id="11f5a22e0c8092b2e830a298d3f000dd528e1ac9" translate="yes" xml:space="preserve">
          <source>This is implemented as an intrinsic to avoid converting to and from an integer, since the conversion would throw away aliasing information.</source>
          <target state="translated">Это реализовано как неотъемлемая часть,чтобы избежать преобразования в целое число и из него,поскольку преобразование будет выбрасывать информацию о псевдонимах.</target>
        </trans-unit>
        <trans-unit id="0d148f9608c961194f7d8d82b9462e528bb48245" translate="yes" xml:space="preserve">
          <source>This is in contrast to the default behaviour of &lt;a href=&quot;../macro.panic&quot;&gt;&lt;code&gt;panic!&lt;/code&gt;&lt;/a&gt; which unwinds the current thread's stack and calls all destructors. When &lt;code&gt;panic=&quot;abort&quot;&lt;/code&gt; is set, either as an argument to &lt;code&gt;rustc&lt;/code&gt; or in a crate's Cargo.toml, &lt;a href=&quot;../macro.panic&quot;&gt;&lt;code&gt;panic!&lt;/code&gt;&lt;/a&gt; and &lt;code&gt;abort&lt;/code&gt; are similar. However, &lt;a href=&quot;../macro.panic&quot;&gt;&lt;code&gt;panic!&lt;/code&gt;&lt;/a&gt; will still call the &lt;a href=&quot;../panic/fn.set_hook&quot;&gt;panic hook&lt;/a&gt; while &lt;code&gt;abort&lt;/code&gt; will not.</source>
          <target state="translated">Это отличается от поведения &lt;a href=&quot;../macro.panic&quot;&gt; &lt;code&gt;panic!&lt;/code&gt; &lt;/a&gt; по умолчанию ! который раскручивает стек текущего потока и вызывает все деструкторы. Когда &lt;code&gt;panic=&quot;abort&quot;&lt;/code&gt; установлен в качестве аргумента для &lt;code&gt;rustc&lt;/code&gt; или в Cargo.toml ящика, &lt;a href=&quot;../macro.panic&quot;&gt; &lt;code&gt;panic!&lt;/code&gt; &lt;/a&gt;и &lt;code&gt;abort&lt;/code&gt; аналогичны. Однако &lt;a href=&quot;../macro.panic&quot;&gt; &lt;code&gt;panic!&lt;/code&gt; &lt;/a&gt;будет по-прежнему вызывать &lt;a href=&quot;../panic/fn.set_hook&quot;&gt;панику,&lt;/a&gt; а &lt;code&gt;abort&lt;/code&gt; - нет.</target>
        </trans-unit>
        <trans-unit id="4ae8371c0715e2fc1f945296e51fa6a1f4eac55c" translate="yes" xml:space="preserve">
          <source>This is intended for diagnostic use. The exact contents and format of the string are not specified, other than being a best-effort description of the type. For example, &lt;code&gt;type_name_of_val::&amp;lt;Option&amp;lt;String&amp;gt;&amp;gt;(None)&lt;/code&gt; could return &lt;code&gt;&quot;Option&amp;lt;String&amp;gt;&quot;&lt;/code&gt; or &lt;code&gt;&quot;std::option::Option&amp;lt;std::string::String&amp;gt;&quot;&lt;/code&gt;, but not &lt;code&gt;&quot;foobar&quot;&lt;/code&gt;. In addition, the output may change between versions of the compiler.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f8ec787ed30362b911645f3b84c9e12d95cf9472" translate="yes" xml:space="preserve">
          <source>This is intended for diagnostic use. The exact contents and format of the string returned are not specified, other than being a best-effort description of the type. For example, amongst the strings that &lt;code&gt;type_name::&amp;lt;Option&amp;lt;String&amp;gt;&amp;gt;()&lt;/code&gt; might return are &lt;code&gt;&quot;Option&amp;lt;String&amp;gt;&quot;&lt;/code&gt; and &lt;code&gt;&quot;std::option::Option&amp;lt;std::string::String&amp;gt;&quot;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="abc319fa8d54bb7f30ec3fbd3c75a33f269dda0d" translate="yes" xml:space="preserve">
          <source>This is intended for use cases that must synchronize content, but don't need the metadata on disk. The goal of this method is to reduce disk operations.</source>
          <target state="translated">Это предназначено для случаев,когда необходимо синхронизировать содержимое,но при этом не нужны метаданные на диске.Цель этого метода-уменьшить количество операций на диске.</target>
        </trans-unit>
        <trans-unit id="b4baa659f5df3a480bf1bbe9b4f50e4e5030b61c" translate="yes" xml:space="preserve">
          <source>This is lossless: calling &lt;a href=&quot;trait.osstrext#tymethod.encode_wide&quot;&gt;&lt;code&gt;OsStrExt::encode_wide&lt;/code&gt;&lt;/a&gt; on the resulting string will always return the original code units.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8a817bf3dc422e9202ff238105af54d744a0e12d" translate="yes" xml:space="preserve">
          <source>This is lossless: calling &lt;a href=&quot;trait.osstrext#tymethod.encode_wide&quot;&gt;&lt;code&gt;encode_wide&lt;/code&gt;&lt;/a&gt; on the resulting string will always return the original code units.</source>
          <target state="translated">Это без потерь: вызов &lt;a href=&quot;trait.osstrext#tymethod.encode_wide&quot;&gt; &lt;code&gt;encode_wide&lt;/code&gt; &lt;/a&gt; для результирующей строки всегда будет возвращать исходные единицы кода.</target>
        </trans-unit>
        <trans-unit id="628dc171fde34c2da2657493d9e0d1f50a03e413" translate="yes" xml:space="preserve">
          <source>This is lossless: calling &lt;a href=&quot;trait.osstringext#tymethod.from_wide&quot;&gt;&lt;code&gt;OsString::from_wide&lt;/code&gt;&lt;/a&gt; and then &lt;code&gt;encode_wide&lt;/code&gt; on the result will yield the original code units. Note that the encoding does not add a final null terminator.</source>
          <target state="translated">Это без потерь: вызов &lt;a href=&quot;trait.osstringext#tymethod.from_wide&quot;&gt; &lt;code&gt;OsString::from_wide&lt;/code&gt; &lt;/a&gt; а затем &lt;code&gt;encode_wide&lt;/code&gt; для результата даст исходные единицы кода. Обратите внимание, что кодировка не добавляет окончательный нулевой терминатор.</target>
        </trans-unit>
        <trans-unit id="77e982184c9ea4360d1954dd63bc884090bdd324" translate="yes" xml:space="preserve">
          <source>This is lossless: calling &lt;a href=&quot;trait.osstringext#tymethod.from_wide&quot;&gt;&lt;code&gt;OsStringExt::from_wide&lt;/code&gt;&lt;/a&gt; and then &lt;code&gt;encode_wide&lt;/code&gt; on the result will yield the original code units. Note that the encoding does not add a final null terminator.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0151e5762979bf36757d9fa68f187e7676c048da" translate="yes" xml:space="preserve">
          <source>This is more useful when combined with higher-level abstractions, like collecting to a &lt;code&gt;Result&amp;lt;(), E&amp;gt;&lt;/code&gt; where you only care about errors:</source>
          <target state="translated">Это более полезно в сочетании с абстракциями более высокого уровня, такими как сбор в &lt;code&gt;Result&amp;lt;(), E&amp;gt;&lt;/code&gt; где вас интересуют только ошибки:</target>
        </trans-unit>
        <trans-unit id="10329d9d786a635bdda96b8986fb374a569f8990" translate="yes" xml:space="preserve">
          <source>This is normally only useful in macro generated code.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e2fe1510c25bad6c81eb0b6402e2bd1a4066b7f9" translate="yes" xml:space="preserve">
          <source>This is not currently supported: &lt;code&gt;v&lt;/code&gt; should be defined as &lt;code&gt;Vec&amp;lt;&amp;amp;str&amp;gt;&lt;/code&gt;. Parentheses are currently only used with generic types when defining parameters for &lt;code&gt;Fn&lt;/code&gt;-family traits.</source>
          <target state="translated">В настоящее время это не поддерживается: &lt;code&gt;v&lt;/code&gt; следует определять как &lt;code&gt;Vec&amp;lt;&amp;amp;str&amp;gt;&lt;/code&gt; . Скобки в настоящее время используются только с универсальными типами при определении параметров для признаков &lt;code&gt;Fn&lt;/code&gt; - семейства.</target>
        </trans-unit>
        <trans-unit id="711ce4ce5401a3c09d45281217695490f1c55a87" translate="yes" xml:space="preserve">
          <source>This is often the correct thing to use when building data structures using raw pointers, but is ultimately more dangerous to use because of its additional properties. If you're not sure if you should use &lt;code&gt;NonNull&amp;lt;T&amp;gt;&lt;/code&gt;, just use &lt;code&gt;*mut T&lt;/code&gt;!</source>
          <target state="translated">Часто это правильный выбор при построении структур данных с использованием необработанных указателей, но, в конечном итоге, его использование более опасно из-за его дополнительных свойств. Если вы не уверены, следует ли использовать &lt;code&gt;NonNull&amp;lt;T&amp;gt;&lt;/code&gt; , просто используйте &lt;code&gt;*mut T&lt;/code&gt; !</target>
        </trans-unit>
        <trans-unit id="fa820eea81b725c2fa4febe2a3901035a1fc9e49" translate="yes" xml:space="preserve">
          <source>This is one of the reasons Rust projects that provide a binary have a straightforward &lt;em&gt;src/main.rs&lt;/em&gt; file that calls logic that lives in the &lt;em&gt;src/lib.rs&lt;/em&gt; file. Using that structure, integration tests &lt;em&gt;can&lt;/em&gt; test the library crate with &lt;code&gt;use&lt;/code&gt; to make the important functionality available. If the important functionality works, the small amount of code in the &lt;em&gt;src/main.rs&lt;/em&gt; file will work as well, and that small amount of code doesn&amp;rsquo;t need to be tested.</source>
          <target state="translated">Это одна из причин, по которой проекты Rust, которые предоставляют двоичный файл, имеют простой файл &lt;em&gt;src / main.rs&lt;/em&gt; , вызывающий логику, которая находится в файле &lt;em&gt;src / lib.rs. &lt;/em&gt;Используя эту структуру, интеграционные тесты &lt;em&gt;могут&lt;/em&gt; проверить библиотеку клеть с &lt;code&gt;use&lt;/code&gt; , чтобы сделать важные функциональные возможности, доступные. Если важная функциональность работает, небольшой объем кода в файле &lt;em&gt;src / main.rs также&lt;/em&gt; будет работать, и этот небольшой объем кода не нужно тестировать.</target>
        </trans-unit>
        <trans-unit id="73e2aa9ae5cc887b643d8522a473733b99e09722" translate="yes" xml:space="preserve">
          <source>This is only available on unix platforms and must be imported in order to call the method. Windows platforms have a corresponding &lt;code&gt;AsRawHandle&lt;/code&gt; and &lt;code&gt;AsRawSocket&lt;/code&gt; set of traits.</source>
          <target state="translated">Это доступно только на платформах unix и должно быть импортировано для вызова метода. Платформы Windows имеют соответствующий набор свойств &lt;code&gt;AsRawHandle&lt;/code&gt; и &lt;code&gt;AsRawSocket&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b95758d57810f70a3e0dda910c113e0c41898398" translate="yes" xml:space="preserve">
          <source>This is only possible if the iterator has an end, so &lt;code&gt;rev()&lt;/code&gt; only works on &lt;a href=&quot;trait.doubleendediterator&quot;&gt;&lt;code&gt;DoubleEndedIterator&lt;/code&gt;&lt;/a&gt;s.</source>
          <target state="translated">Это возможно только в том случае, если итератор имеет конец, поэтому &lt;code&gt;rev()&lt;/code&gt; работает только с &lt;a href=&quot;trait.doubleendediterator&quot;&gt; &lt;code&gt;DoubleEndedIterator&lt;/code&gt; &lt;/a&gt; s.</target>
        </trans-unit>
        <trans-unit id="3a074412ade07f77d614925409e4080a4208783e" translate="yes" xml:space="preserve">
          <source>This is optimal if:</source>
          <target state="translated">Это оптимально,если:</target>
        </trans-unit>
        <trans-unit id="37e51cab1c9ec8f6780dbae6b990b1f230875324" translate="yes" xml:space="preserve">
          <source>This is primarily due to ABI incompatibilities between the two attributes. See &lt;a href=&quot;https://github.com/rust-lang/rfcs/blob/master/text/2091-inline-semantic.md&quot;&gt;RFC 2091&lt;/a&gt; for details on this and other limitations.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d34b82a0a85b619783fe065420d506ce185b6196" translate="yes" xml:space="preserve">
          <source>This is purely an optimization hint, and may be implemented conservatively: it may return &lt;code&gt;true&lt;/code&gt; for types that don't actually need to be dropped. As such always returning &lt;code&gt;true&lt;/code&gt; would be a valid implementation of this function. However if this function actually returns &lt;code&gt;false&lt;/code&gt;, then you can be certain dropping &lt;code&gt;T&lt;/code&gt; has no side effect.</source>
          <target state="translated">Это чисто оптимизационная подсказка, и ее можно реализовать консервативно: она может возвращать &lt;code&gt;true&lt;/code&gt; для типов, которые на самом деле не нужно отбрасывать. Таким образом, всегда возвращаемое значение &lt;code&gt;true&lt;/code&gt; было бы допустимой реализацией этой функции. Однако, если эта функция действительно возвращает &lt;code&gt;false&lt;/code&gt; , вы можете быть уверены, что отбрасывание &lt;code&gt;T&lt;/code&gt; не имеет побочных эффектов.</target>
        </trans-unit>
        <trans-unit id="5e7810a8956ac37cd206f449b307f75cea11f52b" translate="yes" xml:space="preserve">
          <source>This is returned in a Result by either the &lt;a href=&quot;struct.command#method.output&quot;&gt;&lt;code&gt;output&lt;/code&gt;&lt;/a&gt; method of a &lt;a href=&quot;struct.command&quot;&gt;&lt;code&gt;Command&lt;/code&gt;&lt;/a&gt;, or the &lt;a href=&quot;struct.child#method.wait_with_output&quot;&gt;&lt;code&gt;wait_with_output&lt;/code&gt;&lt;/a&gt; method of a &lt;a href=&quot;struct.child&quot;&gt;&lt;code&gt;Child&lt;/code&gt;&lt;/a&gt; process.</source>
          <target state="translated">Это возвращается в результате либо на &lt;a href=&quot;struct.command#method.output&quot;&gt; &lt;code&gt;output&lt;/code&gt; &lt;/a&gt; методом &lt;a href=&quot;struct.command&quot;&gt; &lt;code&gt;Command&lt;/code&gt; &lt;/a&gt; , или &lt;a href=&quot;struct.child#method.wait_with_output&quot;&gt; &lt;code&gt;wait_with_output&lt;/code&gt; &lt;/a&gt; методом &lt;a href=&quot;struct.child&quot;&gt; &lt;code&gt;Child&lt;/code&gt; &lt;/a&gt; процесса.</target>
        </trans-unit>
        <trans-unit id="b6ad57d3243660eeae5c83dc6d6e37580997866e" translate="yes" xml:space="preserve">
          <source>This is safe because it is not possible to move out of a shared reference. It may seem like there is an issue here with interior mutability: in fact, it &lt;em&gt;is&lt;/em&gt; possible to move a &lt;code&gt;T&lt;/code&gt; out of a &lt;code&gt;&amp;amp;RefCell&amp;lt;T&amp;gt;&lt;/code&gt;. However, this is not a problem as long as there does not also exist a &lt;code&gt;Pin&amp;lt;&amp;amp;T&amp;gt;&lt;/code&gt; pointing to the same data, and &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt; does not let you create a pinned reference to its contents. See the discussion on &lt;a href=&quot;index#projections-and-structural-pinning&quot;&gt;&quot;pinning projections&quot;&lt;/a&gt; for further details.</source>
          <target state="translated">Это безопасно, потому что невозможно выйти из общей ссылки. Может показаться , что есть проблема здесь с внутренней изменчивостью: в самом деле, &lt;em&gt;это&lt;/em&gt; можно переместить &lt;code&gt;T&lt;/code&gt; из &lt;code&gt;&amp;amp;RefCell&amp;lt;T&amp;gt;&lt;/code&gt; . Однако это не проблема, пока не существует &lt;code&gt;Pin&amp;lt;&amp;amp;T&amp;gt;&lt;/code&gt; указывающий на те же данные, а &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt; не позволяет создавать закрепленную ссылку на их содержимое. См. Обсуждение &lt;a href=&quot;index#projections-and-structural-pinning&quot;&gt;&amp;laquo;закрепления проекций&amp;raquo;&lt;/a&gt; для получения дополнительной информации.</target>
        </trans-unit>
        <trans-unit id="559d85299736482aa3edc92867921c11931dac34" translate="yes" xml:space="preserve">
          <source>This is safe because passing &lt;code&gt;self&lt;/code&gt; by value guarantees that no other threads are concurrently accessing the atomic data.</source>
          <target state="translated">Это безопасно, потому что передача &lt;code&gt;self&lt;/code&gt; по значению гарантирует, что никакие другие потоки не будут одновременно обращаться к атомарным данным.</target>
        </trans-unit>
        <trans-unit id="fdcd86e75de03ac238cab2145da08762d1c1fa0e" translate="yes" xml:space="preserve">
          <source>This is safe because the mutable reference guarantees that no other threads are concurrently accessing the atomic data.</source>
          <target state="translated">Это безопасно,так как мутирующая ссылка гарантирует,что никакие другие потоки не будут одновременно обращаться к атомным данным.</target>
        </trans-unit>
        <trans-unit id="a603b8208d8f49fcc985893385a8e118d832cdea" translate="yes" xml:space="preserve">
          <source>This is safe, because &lt;code&gt;T&lt;/code&gt; is borrowed for the &lt;code&gt;'static&lt;/code&gt; lifetime, which never ends.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="62f1c9ceb59d3f4f94d3d3fedf2ebcb7110ae8d6" translate="yes" xml:space="preserve">
          <source>This is semantically equivalent to calling &lt;a href=&quot;../ptr/fn.read&quot;&gt;&lt;code&gt;ptr::read&lt;/code&gt;&lt;/a&gt; and discarding the result, but has the following advantages:</source>
          <target state="translated">Это семантически эквивалентно вызову &lt;a href=&quot;../ptr/fn.read&quot;&gt; &lt;code&gt;ptr::read&lt;/code&gt; &lt;/a&gt; и отбрасыванию результата, но имеет следующие преимущества:</target>
        </trans-unit>
        <trans-unit id="f8249e0d4f2746bf5b8aa8a678e0e1e5a321179d" translate="yes" xml:space="preserve">
          <source>This is semantically equivalent to calling &lt;a href=&quot;fn.read&quot;&gt;&lt;code&gt;ptr::read&lt;/code&gt;&lt;/a&gt; and discarding the result, but has the following advantages:</source>
          <target state="translated">Это семантически эквивалентно вызову &lt;a href=&quot;fn.read&quot;&gt; &lt;code&gt;ptr::read&lt;/code&gt; &lt;/a&gt; и отбрасыванию результата, но имеет следующие преимущества:</target>
        </trans-unit>
        <trans-unit id="fb69e9b77c8f67d2dd23964f55732bc6174eb1f3" translate="yes" xml:space="preserve">
          <source>This is similar to &lt;a href=&quot;struct.mutex#poisoning&quot;&gt;poisoning with mutexes&lt;/a&gt;.</source>
          <target state="translated">Это похоже на &lt;a href=&quot;struct.mutex#poisoning&quot;&gt;отравление мьютексами&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="323433898b799fb03eed09fdd2d727e9828c9a3d" translate="yes" xml:space="preserve">
          <source>This is similar to &lt;code&gt;wake&lt;/code&gt;, but may be slightly less efficient in the case where an owned &lt;code&gt;Waker&lt;/code&gt; is available. This method should be preferred to calling &lt;code&gt;waker.clone().wake()&lt;/code&gt;.</source>
          <target state="translated">Это похоже на &lt;code&gt;wake&lt;/code&gt; , но может быть немного менее эффективным в случае, если доступен собственный &lt;code&gt;Waker&lt;/code&gt; . Этот метод следует предпочесть вызову &lt;code&gt;waker.clone().wake()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="67ff9ed313be1a208e09d5213c1e87906d1b8ae8" translate="yes" xml:space="preserve">
          <source>This is similar to taking a reference to the whole &lt;code&gt;String&lt;/code&gt; but with the extra &lt;code&gt;[0..5]&lt;/code&gt; bit. Rather than a reference to the entire &lt;code&gt;String&lt;/code&gt;, it&amp;rsquo;s a reference to a portion of the &lt;code&gt;String&lt;/code&gt;.</source>
          <target state="translated">Это похоже на ссылку на всю &lt;code&gt;String&lt;/code&gt; но с дополнительным битом &lt;code&gt;[0..5]&lt;/code&gt; . Вместо ссылки на всю &lt;code&gt;String&lt;/code&gt; , это ссылка на часть &lt;code&gt;String&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8e7a7ddaef0be30145306f6816d2b3ff35a14d32" translate="yes" xml:space="preserve">
          <source>This is similar to the second sub-error, but subtler. It happens in situations like the following:</source>
          <target state="translated">Это похоже на второй субтеррор,но более тонкий.Это происходит в таких ситуациях,как следующие:</target>
        </trans-unit>
        <trans-unit id="7512abd4f4f8baf21d2fa3f6cea905e84ac77b34" translate="yes" xml:space="preserve">
          <source>This is simply a special - but common - case of the previous: hiding mutability for operations that appear to be immutable. The &lt;code&gt;clone&lt;/code&gt; method is expected to not change the source value, and is declared to take &lt;code&gt;&amp;amp;self&lt;/code&gt;, not &lt;code&gt;&amp;amp;mut self&lt;/code&gt;. Therefore, any mutation that happens in the &lt;code&gt;clone&lt;/code&gt; method must use cell types. For example, &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; maintains its reference counts within a &lt;code&gt;Cell&amp;lt;T&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">Это просто частный, но частый случай предыдущего: сокрытие изменчивости для операций, которые кажутся неизменными. Ожидается, что метод &lt;code&gt;clone&lt;/code&gt; не изменит исходное значение и объявлен как принимает &lt;code&gt;&amp;amp;self&lt;/code&gt; , а не &lt;code&gt;&amp;amp;mut self&lt;/code&gt; . Следовательно, любая мутация, которая происходит в методе &lt;code&gt;clone&lt;/code&gt; должна использовать типы клеток. Например, &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; поддерживает счетчики ссылок в &lt;code&gt;Cell&amp;lt;T&amp;gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="022f67943cd560f4bdb5afc8c97b7f6c6d3167eb" translate="yes" xml:space="preserve">
          <source>This is sometimes done as part of an FFI:</source>
          <target state="translated">Иногда это делается в рамках ФФИ:</target>
        </trans-unit>
        <trans-unit id="ce79f7fec51f65c567a6d4b960b891ab223ea0af" translate="yes" xml:space="preserve">
          <source>This is supported on Linux only.</source>
          <target state="translated">Поддерживается только под Linux.</target>
        </trans-unit>
        <trans-unit id="5d02662201a60807bdb13970d8ae5dbd58d92a03" translate="yes" xml:space="preserve">
          <source>This is supported on Unix only.</source>
          <target state="translated">Поддерживается только на Unix.</target>
        </trans-unit>
        <trans-unit id="fe81960399abac0748704c3a05349d9cd7f1ac2c" translate="yes" xml:space="preserve">
          <source>This is supported on Windows only.</source>
          <target state="translated">Поддерживается только в Windows.</target>
        </trans-unit>
        <trans-unit id="7dbd409e3c209511b0279195cd6826fb5e1a2b3b" translate="yes" xml:space="preserve">
          <source>This is the &lt;code&gt;longest&lt;/code&gt; function from Listing 10-22 that returns the longer of two string slices. But now it has an extra parameter named &lt;code&gt;ann&lt;/code&gt; of the generic type &lt;code&gt;T&lt;/code&gt;, which can be filled in by any type that implements the &lt;code&gt;Display&lt;/code&gt; trait as specified by the &lt;code&gt;where&lt;/code&gt; clause. This extra parameter will be printed before the function compares the lengths of the string slices, which is why the &lt;code&gt;Display&lt;/code&gt; trait bound is necessary. Because lifetimes are a type of generic, the declarations of the lifetime parameter &lt;code&gt;'a&lt;/code&gt; and the generic type parameter &lt;code&gt;T&lt;/code&gt; go in the same list inside the angle brackets after the function name.</source>
          <target state="translated">Это самая &lt;code&gt;longest&lt;/code&gt; функция из Листинга 10-22, которая возвращает более длинный из двух строковых фрагментов. Но теперь у него есть дополнительный параметр с именем &lt;code&gt;ann&lt;/code&gt; общего типа &lt;code&gt;T&lt;/code&gt; , который может быть заполнен любым типом, реализующим черту &lt;code&gt;Display&lt;/code&gt; , как указано в предложении &lt;code&gt;where&lt;/code&gt; . Этот дополнительный параметр будет напечатан до того, как функция сравнит длины фрагментов строки, поэтому необходима граница свойства &lt;code&gt;Display&lt;/code&gt; . Поскольку время жизни является типом универсального, объявления параметра времени жизни &lt;code&gt;'a&lt;/code&gt; и параметра универсального типа &lt;code&gt;T&lt;/code&gt; помещаются в один и тот же список в угловых скобках после имени функции.</target>
        </trans-unit>
        <trans-unit id="771b5400b1697f2e03b3ff52d8994e98c72fb56e" translate="yes" xml:space="preserve">
          <source>This is the alignment used for struct fields. It may be smaller than the preferred alignment.</source>
          <target state="translated">Это выравнивание используется для полей структуры.Оно может быть меньше,чем предпочтительное выравнивание.</target>
        </trans-unit>
        <trans-unit id="d7e12ec340db516b6de450f2a63092abb536959d" translate="yes" xml:space="preserve">
          <source>This is the const generic equivalent of &lt;a href=&quot;#method.windows&quot;&gt;&lt;code&gt;windows&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9ea5fa4cdf245151000dcd8208cd57fa7396ef40" translate="yes" xml:space="preserve">
          <source>This is the correct syntax:</source>
          <target state="translated">Это правильный синтаксис:</target>
        </trans-unit>
        <trans-unit id="8a3edb9de97e0819d33135bbb50051a98c123c3a" translate="yes" xml:space="preserve">
          <source>This is the difference between &lt;code&gt;1.0&lt;/code&gt; and the next larger representable number.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="540ad0b8406b1727e0f455b9b013663295117df7" translate="yes" xml:space="preserve">
          <source>This is the difference between &lt;code&gt;1.0&lt;/code&gt; and the next largest representable number.</source>
          <target state="translated">В этом разница между &lt;code&gt;1.0&lt;/code&gt; и следующим по величине представимым числом.</target>
        </trans-unit>
        <trans-unit id="c620ac5f199d804600d9e6fa867d20d7e4f16f11" translate="yes" xml:space="preserve">
          <source>This is the first example of Rust&amp;rsquo;s safety principles in action. In many low-level languages, this kind of check is not done, and when you provide an incorrect index, invalid memory can be accessed. Rust protects you against this kind of error by immediately exiting instead of allowing the memory access and continuing. Chapter 9 discusses more of Rust&amp;rsquo;s error handling.</source>
          <target state="translated">Это первый пример применения принципов безопасности Rust. Во многих низкоуровневых языках такая проверка не выполняется, и когда вы указываете неверный индекс, может быть получен доступ к недействительной памяти. Rust защищает вас от такого рода ошибок, немедленно завершая работу, вместо того, чтобы разрешить доступ к памяти и продолжить. В главе 9 более подробно рассматривается обработка ошибок в Rust.</target>
        </trans-unit>
        <trans-unit id="96d082bf8459464d47b35442a1fa45813a325a53" translate="yes" xml:space="preserve">
          <source>This is the main iterator trait. For more about the concept of iterators generally, please see the &lt;a href=&quot;index&quot;&gt;module-level documentation&lt;/a&gt;. In particular, you may want to know how to &lt;a href=&quot;index#implementing-iterator&quot;&gt;implement &lt;code&gt;Iterator&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Это основная черта итератора. Дополнительные сведения о концепции итераторов в целом см. В &lt;a href=&quot;index&quot;&gt;документации на уровне модуля&lt;/a&gt; . В частности, вы можете узнать, как &lt;a href=&quot;index#implementing-iterator&quot;&gt;реализовать &lt;code&gt;Iterator&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="b386764c4159d37f683e85f4c4afa8c88d4fe909" translate="yes" xml:space="preserve">
          <source>This is the non-panicking alternative to indexing the &lt;code&gt;str&lt;/code&gt;. Returns &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt; whenever equivalent indexing operation would panic.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="289f1434eafb60316aca77ad31a00e3c0eb9323a" translate="yes" xml:space="preserve">
          <source>This is the non-panicking alternative to indexing the &lt;code&gt;str&lt;/code&gt;. Returns &lt;a href=&quot;option/enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt; whenever equivalent indexing operation would panic.</source>
          <target state="translated">Это безупречная альтернатива индексации &lt;code&gt;str&lt;/code&gt; . Возвращает &lt;a href=&quot;option/enum.option#variant.None&quot;&gt; &lt;code&gt;None&lt;/code&gt; ,&lt;/a&gt; если эквивалентная операция индексирования вызовет панику.</target>
        </trans-unit>
        <trans-unit id="759018d521d201d38bc076c0727a5d9a6e429fac" translate="yes" xml:space="preserve">
          <source>This is the non-panicking variant of &lt;a href=&quot;#method.borrow&quot;&gt;&lt;code&gt;borrow&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Это вариант &lt;a href=&quot;#method.borrow&quot;&gt; &lt;code&gt;borrow&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="70fed40b0a485aa104ed49c92498ff0b436cf03b" translate="yes" xml:space="preserve">
          <source>This is the non-panicking variant of &lt;a href=&quot;#method.borrow_mut&quot;&gt;&lt;code&gt;borrow_mut&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Это вариант &lt;a href=&quot;#method.borrow_mut&quot;&gt; &lt;code&gt;borrow_mut&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="ccd5e95eaa2f4ad9676aca34c8e9ba1ff21b3015" translate="yes" xml:space="preserve">
          <source>This is the reverse version of &lt;a href=&quot;../../iter/trait.iterator#method.try_fold&quot;&gt;&lt;code&gt;Iterator::try_fold()&lt;/code&gt;&lt;/a&gt;: it takes elements starting from the back of the iterator. &lt;a href=&quot;../../iter/trait.doubleendediterator#method.try_rfold&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fd0528fc88151b305168bd5debfa38b6c659b612" translate="yes" xml:space="preserve">
          <source>This is the reverse version of &lt;a href=&quot;../iter/trait.iterator#method.try_fold&quot;&gt;&lt;code&gt;Iterator::try_fold()&lt;/code&gt;&lt;/a&gt;: it takes elements starting from the back of the iterator. &lt;a href=&quot;../iter/trait.doubleendediterator#method.try_rfold&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d0fe748271e612bae240bf98e735a830b559c459" translate="yes" xml:space="preserve">
          <source>This is the reverse version of &lt;a href=&quot;iter/trait.iterator#method.try_fold&quot;&gt;&lt;code&gt;Iterator::try_fold()&lt;/code&gt;&lt;/a&gt;: it takes elements starting from the back of the iterator. &lt;a href=&quot;iter/trait.doubleendediterator#method.try_rfold&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1d3a0dba802b6e4f6285d94d4683f5056846f9fd" translate="yes" xml:space="preserve">
          <source>This is the reverse version of &lt;a href=&quot;trait.iterator#method.fold&quot;&gt;&lt;code&gt;Iterator::fold()&lt;/code&gt;&lt;/a&gt;: it takes elements starting from the back of the iterator.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cce445e189c1252f0055062d54b89751ff0fb729" translate="yes" xml:space="preserve">
          <source>This is the reverse version of &lt;a href=&quot;trait.iterator#method.fold&quot;&gt;&lt;code&gt;fold()&lt;/code&gt;&lt;/a&gt;: it takes elements starting from the back of the iterator.</source>
          <target state="translated">Это обратная версия функции &lt;a href=&quot;trait.iterator#method.fold&quot;&gt; &lt;code&gt;fold()&lt;/code&gt; &lt;/a&gt; : она принимает элементы, начиная с задней части итератора.</target>
        </trans-unit>
        <trans-unit id="bc1780a770503660513f01fa15c1efc71fef0175" translate="yes" xml:space="preserve">
          <source>This is the reverse version of &lt;a href=&quot;trait.iterator#method.try_fold&quot;&gt;&lt;code&gt;Iterator::try_fold()&lt;/code&gt;&lt;/a&gt;: it takes elements starting from the back of the iterator.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fe6ff5d62e332d4883802b0cf8675d53b663b171" translate="yes" xml:space="preserve">
          <source>This is the reverse version of &lt;a href=&quot;trait.iterator#method.try_fold&quot;&gt;&lt;code&gt;Iterator::try_fold()&lt;/code&gt;&lt;/a&gt;: it takes elements starting from the back of the iterator. &lt;a href=&quot;trait.doubleendediterator#method.try_rfold&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="53f33f9266690c3f1f82aab587ca29e140daa7ab" translate="yes" xml:space="preserve">
          <source>This is the reverse version of &lt;a href=&quot;trait.iterator#method.try_fold&quot;&gt;&lt;code&gt;try_fold()&lt;/code&gt;&lt;/a&gt;: it takes elements starting from the back of the iterator.</source>
          <target state="translated">Это обратная версия &lt;a href=&quot;trait.iterator#method.try_fold&quot;&gt; &lt;code&gt;try_fold()&lt;/code&gt; &lt;/a&gt; : она принимает элементы, начиная с задней части итератора.</target>
        </trans-unit>
        <trans-unit id="d46122a89a465fda704ceb8118ba4c1126be2832" translate="yes" xml:space="preserve">
          <source>This is the reverse version of [&lt;code&gt;try_fold()&lt;/code&gt;]: it takes elements starting from the back of the iterator. &lt;a href=&quot;../../iter/trait.doubleendediterator#method.try_rfold&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">Это обратная версия [ &lt;code&gt;try_fold()&lt;/code&gt; ]: она принимает элементы, начиная с задней части итератора. &lt;a href=&quot;../../iter/trait.doubleendediterator#method.try_rfold&quot;&gt;Читать далее&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="f495531f8eacf0a1680dc0219ed83707197faddd" translate="yes" xml:space="preserve">
          <source>This is the reverse version of [&lt;code&gt;try_fold()&lt;/code&gt;]: it takes elements starting from the back of the iterator. &lt;a href=&quot;../iter/trait.doubleendediterator#method.try_rfold&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">Это обратная версия [ &lt;code&gt;try_fold()&lt;/code&gt; ]: она принимает элементы, начиная с задней части итератора. &lt;a href=&quot;../iter/trait.doubleendediterator#method.try_rfold&quot;&gt;Читать далее&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="0ec81940d41390cbbcb80997a4e3d957d2b9a317" translate="yes" xml:space="preserve">
          <source>This is the reverse version of [&lt;code&gt;try_fold()&lt;/code&gt;]: it takes elements starting from the back of the iterator. &lt;a href=&quot;iter/trait.doubleendediterator#method.try_rfold&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">Это обратная версия [ &lt;code&gt;try_fold()&lt;/code&gt; ]: она принимает элементы, начиная с задней части итератора. &lt;a href=&quot;iter/trait.doubleendediterator#method.try_rfold&quot;&gt;Читать далее&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="5ff3fa51ad38f312277040719826a7c977bbcd8a" translate="yes" xml:space="preserve">
          <source>This is the reverse version of [&lt;code&gt;try_fold()&lt;/code&gt;]: it takes elements starting from the back of the iterator. &lt;a href=&quot;trait.doubleendediterator#method.try_rfold&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">Это обратная версия [ &lt;code&gt;try_fold()&lt;/code&gt; ]: она принимает элементы, начиная с задней части итератора. &lt;a href=&quot;trait.doubleendediterator#method.try_rfold&quot;&gt;Читать далее&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="383e94e01b1343c9d6bcfb23e7f045e384d94336" translate="yes" xml:space="preserve">
          <source>This is the same as using the &lt;code&gt;==&lt;/code&gt; operator, but less generic: the arguments have to be &lt;code&gt;*const T&lt;/code&gt; raw pointers, not anything that implements &lt;code&gt;PartialEq&lt;/code&gt;.</source>
          <target state="translated">Это то же самое, что и использование оператора &lt;code&gt;==&lt;/code&gt; , но менее общее: аргументы должны быть необработанными указателями &lt;code&gt;*const T&lt;/code&gt; , а не чем-либо, что реализует &lt;code&gt;PartialEq&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="22b2f39cdef64a09df83167c24366e9e24591fdf" translate="yes" xml:space="preserve">
          <source>This is the unchecked alternative to indexing the &lt;code&gt;str&lt;/code&gt;.</source>
          <target state="translated">Это непроверенная альтернатива индексации &lt;code&gt;str&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="589a4243aa6d42e7fc5ac36f0baed5a47e1de444" translate="yes" xml:space="preserve">
          <source>This is used for object safety, to check that a method's receiver type can be dispatched on.</source>
          <target state="translated">Это используется для безопасности объекта,чтобы проверить,что тип приемника метода может быть отправлен на.</target>
        </trans-unit>
        <trans-unit id="9aea807f1415223ad9d946b1ace7fbf6d55fe5aa" translate="yes" xml:space="preserve">
          <source>This is used when the programmer knows that the thread will have nothing to do for some time, and thus avoid wasting computing time.</source>
          <target state="translated">Это используется,когда программист знает,что в течение некоторого времени потоку нечего будет делать,и,таким образом,избегает траты времени на вычисления.</target>
        </trans-unit>
        <trans-unit id="5ce1e416198eb464ee0a2977f8013c35c0e89565" translate="yes" xml:space="preserve">
          <source>This is useful any time that the compiler can't determine that some code is unreachable. For example:</source>
          <target state="translated">Это полезно в любой момент,когда компилятор не может определить,что какой-то код недоступен.Например:</target>
        </trans-unit>
        <trans-unit id="85e4c5ffc08236fd25e25201dcbaaa8757900c78" translate="yes" xml:space="preserve">
          <source>This is useful for</source>
          <target state="translated">Это полезно для</target>
        </trans-unit>
        <trans-unit id="a885d8fe460e46c9230b0d468a457bef6acf54a6" translate="yes" xml:space="preserve">
          <source>This is useful for a flavor of &quot;optimistic check&quot; before deciding to block on a receiver.</source>
          <target state="translated">Это полезно для привкуса &quot;оптимистической проверки&quot; перед принятием решения о блокировке на приемнике.</target>
        </trans-unit>
        <trans-unit id="79e1d9086d9f417d98c9a3f1df01e78fe0db96d9" translate="yes" xml:space="preserve">
          <source>This is useful for initializing types which lazily allocate, like &lt;code&gt;Vec::new&lt;/code&gt; does.</source>
          <target state="translated">Это полезно для инициализации типов, которые лениво распределяются, как это делает &lt;code&gt;Vec::new&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="08ec962229a27774cdabf85bddcaa5d6f625b9ff" translate="yes" xml:space="preserve">
          <source>This is useful to allow applying iterator adaptors while still retaining ownership of the original iterator.</source>
          <target state="translated">Это позволяет применять адаптеры итератора,сохраняя при этом право собственности на оригинальный итератор.</target>
        </trans-unit>
        <trans-unit id="920763b96fccf7eb85a93a16a5bdd675d6fd634c" translate="yes" xml:space="preserve">
          <source>This is useful when the ownership of the underlying resource was previously transferred to code outside of Rust, for example by transmitting the raw file descriptor to C code.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c983c1aa2c476c3f346d2a87a469f6be7bac78d1" translate="yes" xml:space="preserve">
          <source>This is useful when you are doing a type conversion that may trivially succeed but may also need special handling. For example, there is no way to convert an &lt;a href=&quot;../primitive.i64&quot;&gt;&lt;code&gt;i64&lt;/code&gt;&lt;/a&gt; into an &lt;a href=&quot;../primitive.i32&quot;&gt;&lt;code&gt;i32&lt;/code&gt;&lt;/a&gt; using the &lt;a href=&quot;trait.from&quot;&gt;&lt;code&gt;From&lt;/code&gt;&lt;/a&gt; trait, because an &lt;a href=&quot;../primitive.i64&quot;&gt;&lt;code&gt;i64&lt;/code&gt;&lt;/a&gt; may contain a value that an &lt;a href=&quot;../primitive.i32&quot;&gt;&lt;code&gt;i32&lt;/code&gt;&lt;/a&gt; cannot represent and so the conversion would lose data. This might be handled by truncating the &lt;a href=&quot;../primitive.i64&quot;&gt;&lt;code&gt;i64&lt;/code&gt;&lt;/a&gt; to an &lt;a href=&quot;../primitive.i32&quot;&gt;&lt;code&gt;i32&lt;/code&gt;&lt;/a&gt; (essentially giving the &lt;a href=&quot;../primitive.i64&quot;&gt;&lt;code&gt;i64&lt;/code&gt;&lt;/a&gt;'s value modulo &lt;a href=&quot;../i32/constant.max&quot;&gt;&lt;code&gt;i32::MAX&lt;/code&gt;&lt;/a&gt;) or by simply returning &lt;a href=&quot;../i32/constant.max&quot;&gt;&lt;code&gt;i32::MAX&lt;/code&gt;&lt;/a&gt;, or by some other method. The &lt;a href=&quot;trait.from&quot;&gt;&lt;code&gt;From&lt;/code&gt;&lt;/a&gt; trait is intended for perfect conversions, so the &lt;code&gt;TryFrom&lt;/code&gt; trait informs the programmer when a type conversion could go bad and lets them decide how to handle it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="63ccb84e9a4faa353cb290ddc5e855748a76c17b" translate="yes" xml:space="preserve">
          <source>This is useful when you are doing a type conversion that may trivially succeed but may also need special handling. For example, there is no way to convert an &lt;code&gt;i64&lt;/code&gt; into an &lt;code&gt;i32&lt;/code&gt; using the &lt;a href=&quot;trait.from&quot;&gt;&lt;code&gt;From&lt;/code&gt;&lt;/a&gt; trait, because an &lt;code&gt;i64&lt;/code&gt; may contain a value that an &lt;code&gt;i32&lt;/code&gt; cannot represent and so the conversion would lose data. This might be handled by truncating the &lt;code&gt;i64&lt;/code&gt; to an &lt;code&gt;i32&lt;/code&gt; (essentially giving the &lt;code&gt;i64&lt;/code&gt;'s value modulo &lt;code&gt;i32::MAX&lt;/code&gt;) or by simply returning &lt;code&gt;i32::MAX&lt;/code&gt;, or by some other method. The &lt;code&gt;From&lt;/code&gt; trait is intended for perfect conversions, so the &lt;code&gt;TryFrom&lt;/code&gt; trait informs the programmer when a type conversion could go bad and lets them decide how to handle it.</source>
          <target state="translated">Это полезно, когда вы выполняете преобразование типа, которое может быть тривиально успешным, но также может потребовать особой обработки. Например, невозможно преобразовать &lt;code&gt;i64&lt;/code&gt; в &lt;code&gt;i32&lt;/code&gt; с помощью трейта &lt;a href=&quot;trait.from&quot;&gt; &lt;code&gt;From&lt;/code&gt; &lt;/a&gt; , потому что &lt;code&gt;i64&lt;/code&gt; может содержать значение, которое &lt;code&gt;i32&lt;/code&gt; не может представлять, и поэтому преобразование приведет к потере данных. Это может быть обработано усечения &lt;code&gt;i64&lt;/code&gt; к &lt;code&gt;i32&lt;/code&gt; ( по существу , давая &lt;code&gt;i64&lt;/code&gt; &amp;laquo;s значение по модулю &lt;code&gt;i32::MAX&lt;/code&gt; ) или просто возвращение &lt;code&gt;i32::MAX&lt;/code&gt; , или каким - либо другим способом. &lt;code&gt;From&lt;/code&gt; признака предназначен для совершенных переходов, поэтому &lt;code&gt;TryFrom&lt;/code&gt; trait сообщает программисту, когда преобразование типа может пойти не так, и позволяет им решить, как с этим справиться.</target>
        </trans-unit>
        <trans-unit id="878335df341d736b2b477f7d269d41d041479a70" translate="yes" xml:space="preserve">
          <source>This is useful when you have an iterator of iterators or an iterator of things that can be turned into iterators and you want to remove one level of indirection.</source>
          <target state="translated">Это полезно,когда у вас есть итератор итераторов или итератор вещей,которые можно превратить в итераторы,и вы хотите удалить один уровень идирекции.</target>
        </trans-unit>
        <trans-unit id="bc06069272831e3fab63600d60da8286a4aa9faf" translate="yes" xml:space="preserve">
          <source>This is useful when you have an iterator over &lt;code&gt;&amp;amp;T&lt;/code&gt;, but you need an iterator over &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">Это полезно , когда у вас есть итератор &lt;code&gt;&amp;amp;T&lt;/code&gt; , но вам нужен итератор &lt;code&gt;T&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="28c350dd4bfc1f4f50a6db4a558fce8f481fa714" translate="yes" xml:space="preserve">
          <source>This is useful when you wish to output a formatted list of items as a part of your &lt;a href=&quot;trait.debug#tymethod.fmt&quot;&gt;&lt;code&gt;Debug::fmt&lt;/code&gt;&lt;/a&gt; implementation.</source>
          <target state="translated">Это полезно, когда вы хотите вывести отформатированный список элементов как часть вашей реализации &lt;a href=&quot;trait.debug#tymethod.fmt&quot;&gt; &lt;code&gt;Debug::fmt&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="023c37d743c95a28f62cb66dc28c6981840e275e" translate="yes" xml:space="preserve">
          <source>This is useful when you wish to output a formatted map as a part of your &lt;a href=&quot;trait.debug#tymethod.fmt&quot;&gt;&lt;code&gt;Debug::fmt&lt;/code&gt;&lt;/a&gt; implementation.</source>
          <target state="translated">Это полезно, если вы хотите вывести отформатированную карту как часть реализации &lt;a href=&quot;trait.debug#tymethod.fmt&quot;&gt; &lt;code&gt;Debug::fmt&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="5a019c845f0ac55c26e73d5fc98b9e29c14a5266" translate="yes" xml:space="preserve">
          <source>This is useful when you wish to output a formatted set of items as a part of your &lt;a href=&quot;trait.debug#tymethod.fmt&quot;&gt;&lt;code&gt;Debug::fmt&lt;/code&gt;&lt;/a&gt; implementation.</source>
          <target state="translated">Это полезно, когда вы хотите вывести отформатированный набор элементов как часть вашей реализации &lt;a href=&quot;trait.debug#tymethod.fmt&quot;&gt; &lt;code&gt;Debug::fmt&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="742e4efaa0964cab1a9b13d64aa3f1ee505fbe93" translate="yes" xml:space="preserve">
          <source>This is useful when you wish to output a formatted struct as a part of your &lt;a href=&quot;trait.debug#tymethod.fmt&quot;&gt;&lt;code&gt;Debug::fmt&lt;/code&gt;&lt;/a&gt; implementation.</source>
          <target state="translated">Это полезно, когда вы хотите вывести отформатированную структуру как часть реализации &lt;a href=&quot;trait.debug#tymethod.fmt&quot;&gt; &lt;code&gt;Debug::fmt&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="7450774ae735743f9affac51ccc2935a02180916" translate="yes" xml:space="preserve">
          <source>This is useful when you wish to output a formatted tuple as a part of your &lt;a href=&quot;trait.debug#tymethod.fmt&quot;&gt;&lt;code&gt;Debug::fmt&lt;/code&gt;&lt;/a&gt; implementation.</source>
          <target state="translated">Это полезно, если вы хотите вывести отформатированный кортеж как часть реализации &lt;a href=&quot;trait.debug#tymethod.fmt&quot;&gt; &lt;code&gt;Debug::fmt&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="678189b9778744d56a77a9ddbd180a89dff66dd0" translate="yes" xml:space="preserve">
          <source>This is usually not needed when writing safe code, as &lt;a href=&quot;../sync/struct.mutex&quot;&gt;&lt;code&gt;Mutex&lt;/code&gt;es&lt;/a&gt; already poison themselves when a thread panics while holding the lock.</source>
          <target state="translated">Это, как правило , не требуется при написании безопасного кода, так как &lt;a href=&quot;../sync/struct.mutex&quot;&gt; &lt;code&gt;Mutex&lt;/code&gt; эс&lt;/a&gt; уже травить себя , когда поток паникует, удерживая блокировку.</target>
        </trans-unit>
        <trans-unit id="73513599023f5ddb254ee6ed0d00bccac264c338" translate="yes" xml:space="preserve">
          <source>This is usually the same as &lt;code&gt;size_of::&amp;lt;T&amp;gt;()&lt;/code&gt;. However, when &lt;code&gt;T&lt;/code&gt;&lt;em&gt;has&lt;/em&gt; no statically-known size, e.g., a slice &lt;a href=&quot;../primitive.slice&quot;&gt;&lt;code&gt;[T]&lt;/code&gt;&lt;/a&gt; or a &lt;a href=&quot;../../book/ch17-02-trait-objects&quot;&gt;trait object&lt;/a&gt;, then &lt;code&gt;size_of_val&lt;/code&gt; can be used to get the dynamically-known size.</source>
          <target state="translated">Обычно это то же самое, что и &lt;code&gt;size_of::&amp;lt;T&amp;gt;()&lt;/code&gt; . Однако, когда &lt;code&gt;T&lt;/code&gt; &lt;em&gt;не&lt;/em&gt; имеет статически известного размера, например, среза &lt;a href=&quot;../primitive.slice&quot;&gt; &lt;code&gt;[T]&lt;/code&gt; &lt;/a&gt; или &lt;a href=&quot;../../book/ch17-02-trait-objects&quot;&gt;объекта-признака&lt;/a&gt; , то &lt;code&gt;size_of_val&lt;/code&gt; может использоваться для получения динамически известного размера.</target>
        </trans-unit>
        <trans-unit id="8b96a4f28b82d88010bb7132ad9ee35ef317464c" translate="yes" xml:space="preserve">
          <source>This is usually the same as &lt;code&gt;size_of::&amp;lt;T&amp;gt;()&lt;/code&gt;. However, when &lt;code&gt;T&lt;/code&gt;&lt;em&gt;has&lt;/em&gt; no statically-known size, e.g., a slice &lt;a href=&quot;../primitive.slice&quot;&gt;&lt;code&gt;[T]&lt;/code&gt;&lt;/a&gt; or a &lt;a href=&quot;../../book/ch17-02-trait-objects&quot;&gt;trait object&lt;/a&gt;, then &lt;code&gt;size_of_val_raw&lt;/code&gt; can be used to get the dynamically-known size.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8abe6d863c59136664f0a7528f19c0cd3ff2fed7" translate="yes" xml:space="preserve">
          <source>This isn&amp;rsquo;t the exact signature that&amp;rsquo;s in the standard library: in the standard library, &lt;code&gt;add&lt;/code&gt; is defined using generics. Here, we&amp;rsquo;re looking at the signature of &lt;code&gt;add&lt;/code&gt; with concrete types substituted for the generic ones, which is what happens when we call this method with &lt;code&gt;String&lt;/code&gt; values. We&amp;rsquo;ll discuss generics in Chapter 10. This signature gives us the clues we need to understand the tricky bits of the &lt;code&gt;+&lt;/code&gt; operator.</source>
          <target state="translated">Это не точная сигнатура в стандартной библиотеке: в стандартной библиотеке &lt;code&gt;add&lt;/code&gt; определяется с помощью универсальных шаблонов. Здесь мы смотрим на сигнатуру &lt;code&gt;add&lt;/code&gt; с конкретными типами, заменяющими общие, что происходит, когда мы вызываем этот метод со значениями &lt;code&gt;String&lt;/code&gt; . Мы обсудим обобщенные типы в главе 10. Эта сигнатура дает нам подсказки, необходимые для понимания сложных битов оператора &lt;code&gt;+&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="677e3e0ad58a3857efcf5b71bd28f251f1ad71c2" translate="yes" xml:space="preserve">
          <source>This isn&amp;rsquo;t the last you&amp;rsquo;ll see of concurrency in this book: the project in Chapter 20 will use the concepts in this chapter in a more realistic situation than the smaller examples discussed here.</source>
          <target state="translated">Это не последний случай параллелизма, который вы увидите в этой книге: проект в главе 20 будет использовать концепции этой главы в более реалистичной ситуации, чем рассматриваемые здесь более мелкие примеры.</target>
        </trans-unit>
        <trans-unit id="c724cabc6d2e28a46495b5e9f7308161c3ff4773" translate="yes" xml:space="preserve">
          <source>This isn't allowed, but using a trait to implement a method is a good solution. Example:</source>
          <target state="translated">Это не разрешено,но использование признака для реализации метода является хорошим решением.Пример:</target>
        </trans-unit>
        <trans-unit id="c15fbb2556c65982174521dc6e82a15681dc164d" translate="yes" xml:space="preserve">
          <source>This isn't typically the method you want; these addresses don't typically function on modern systems. Use &lt;code&gt;to_ipv6_mapped&lt;/code&gt; instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ca75bc59c45502aa721dfcf6b2008b560ce93b8c" translate="yes" xml:space="preserve">
          <source>This issue also ties into the second problem: although &lt;code&gt;query&lt;/code&gt; and &lt;code&gt;filename&lt;/code&gt; are configuration variables to our program, variables like &lt;code&gt;contents&lt;/code&gt; are used to perform the program&amp;rsquo;s logic. The longer &lt;code&gt;main&lt;/code&gt; becomes, the more variables we&amp;rsquo;ll need to bring into scope; the more variables we have in scope, the harder it will be to keep track of the purpose of each. It&amp;rsquo;s best to group the configuration variables into one structure to make their purpose clear.</source>
          <target state="translated">Эта проблема также связана со второй проблемой: хотя &lt;code&gt;query&lt;/code&gt; и &lt;code&gt;filename&lt;/code&gt; являются переменными конфигурации для нашей программы, такие переменные, как &lt;code&gt;contents&lt;/code&gt; , используются для выполнения логики программы. Чем длиннее становится &lt;code&gt;main&lt;/code&gt; , тем больше переменных нам нужно включить в область видимости; чем больше переменных у нас есть в области видимости, тем сложнее будет отслеживать назначение каждой из них. Лучше всего сгруппировать переменные конфигурации в одну структуру, чтобы прояснить их назначение.</target>
        </trans-unit>
        <trans-unit id="f6ff2f3673f7e2d10b1136073892f6a7e26909fe" translate="yes" xml:space="preserve">
          <source>This iterator is &lt;a href=&quot;../iter/trait.fusediterator&quot;&gt;fused&lt;/a&gt;, but the specific values of &lt;code&gt;start&lt;/code&gt; and &lt;code&gt;end&lt;/code&gt; after iteration has finished are &lt;strong&gt;unspecified&lt;/strong&gt; other than that &lt;a href=&quot;#method.is_empty&quot;&gt;&lt;code&gt;.is_empty()&lt;/code&gt;&lt;/a&gt; will return &lt;code&gt;true&lt;/code&gt; once no more values will be produced.</source>
          <target state="translated">Этот итератор &lt;a href=&quot;../iter/trait.fusediterator&quot;&gt;слит&lt;/a&gt; , но конкретные значения &lt;code&gt;start&lt;/code&gt; и &lt;code&gt;end&lt;/code&gt; после того, как итерации закончил это &lt;strong&gt;не определены&lt;/strong&gt; , кроме того &lt;a href=&quot;#method.is_empty&quot;&gt; &lt;code&gt;.is_empty()&lt;/code&gt; &lt;/a&gt; будет возвращать &lt;code&gt;true&lt;/code&gt; , как только значений больше нет будут выпускаться.</target>
        </trans-unit>
        <trans-unit id="b1db674404809b8384b33fb85e1f59e9aa55c87a" translate="yes" xml:space="preserve">
          <source>This iterator is &lt;a href=&quot;../iter/trait.fusediterator&quot;&gt;fused&lt;/a&gt;, but the specific values of &lt;code&gt;start&lt;/code&gt; and &lt;code&gt;end&lt;/code&gt; after iteration has finished are &lt;strong&gt;unspecified&lt;/strong&gt; other than that &lt;a href=&quot;struct.rangeinclusive#method.is_empty&quot;&gt;&lt;code&gt;.is_empty()&lt;/code&gt;&lt;/a&gt; will return &lt;code&gt;true&lt;/code&gt; once no more values will be produced.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="22ff5b740b07569a5d9914bbdea6a0fe28474b82" translate="yes" xml:space="preserve">
          <source>This iterator is returned from the &lt;a href=&quot;fn.read_dir&quot;&gt;&lt;code&gt;read_dir&lt;/code&gt;&lt;/a&gt; function of this module and will yield instances of &lt;a href=&quot;../io/type.result&quot;&gt;&lt;code&gt;io::Result&lt;/code&gt;&lt;/a&gt;&lt;code&gt;&amp;lt;&lt;/code&gt;&lt;a href=&quot;struct.direntry&quot;&gt;&lt;code&gt;DirEntry&lt;/code&gt;&lt;/a&gt;&lt;code&gt;&amp;gt;&lt;/code&gt;. Through a &lt;a href=&quot;struct.direntry&quot;&gt;&lt;code&gt;DirEntry&lt;/code&gt;&lt;/a&gt; information like the entry's path and possibly other metadata can be learned.</source>
          <target state="translated">Этот итератор возвращается из функции &lt;a href=&quot;fn.read_dir&quot;&gt; &lt;code&gt;read_dir&lt;/code&gt; &lt;/a&gt; этого модуля и дает экземпляры &lt;a href=&quot;../io/type.result&quot;&gt; &lt;code&gt;io::Result&lt;/code&gt; &lt;/a&gt; &lt;code&gt;&amp;lt;&lt;/code&gt; &lt;a href=&quot;struct.direntry&quot;&gt; &lt;code&gt;DirEntry&lt;/code&gt; &lt;/a&gt; &lt;code&gt;&amp;gt;&lt;/code&gt; . Через &lt;a href=&quot;struct.direntry&quot;&gt; &lt;code&gt;DirEntry&lt;/code&gt; можно&lt;/a&gt; узнать такую информацию, как путь к записи и, возможно, другие метаданные.</target>
        </trans-unit>
        <trans-unit id="039cfdd22f7232d788dc3924aaf58e6af89b9b42" translate="yes" xml:space="preserve">
          <source>This iterator will block whenever &lt;a href=&quot;../../iter/trait.iterator#tymethod.next&quot;&gt;&lt;code&gt;next&lt;/code&gt;&lt;/a&gt; is called, waiting for a new message, and &lt;a href=&quot;../../option/enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt; will be returned if the corresponding channel has hung up.</source>
          <target state="translated">Этот итератор будет блокироваться всякий раз, когда вызывается &lt;a href=&quot;../../iter/trait.iterator#tymethod.next&quot;&gt; &lt;code&gt;next&lt;/code&gt; &lt;/a&gt; , ожидая нового сообщения, и &lt;a href=&quot;../../option/enum.option#variant.None&quot;&gt; &lt;code&gt;None&lt;/code&gt; &lt;/a&gt; будет возвращен, если соответствующий канал повесил трубку.</target>
        </trans-unit>
        <trans-unit id="47622e0905704752b067e8fb130b53a4d875da6d" translate="yes" xml:space="preserve">
          <source>This iterator will block whenever &lt;a href=&quot;../../iter/trait.iterator#tymethod.next&quot;&gt;&lt;code&gt;next&lt;/code&gt;&lt;/a&gt; is called, waiting for a new message, and &lt;a href=&quot;../../option/enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt; will be returned when the corresponding channel has hung up.</source>
          <target state="translated">Этот итератор будет блокироваться всякий раз, когда вызывается &lt;a href=&quot;../../iter/trait.iterator#tymethod.next&quot;&gt; &lt;code&gt;next&lt;/code&gt; &lt;/a&gt; , ожидая нового сообщения, и &lt;a href=&quot;../../option/enum.option#variant.None&quot;&gt; &lt;code&gt;None&lt;/code&gt; &lt;/a&gt; будет возвращен, когда соответствующий канал повесит трубку.</target>
        </trans-unit>
        <trans-unit id="3d5f1a4f383a40c5608e98cdb7f233b0d0bd50b4" translate="yes" xml:space="preserve">
          <source>This iterator will never block the caller in order to wait for data to become available. Instead, it will return &lt;a href=&quot;../../option/enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Этот итератор никогда не будет блокировать вызывающего, чтобы дождаться, пока данные станут доступны. Вместо этого он вернет &lt;a href=&quot;../../option/enum.option#variant.None&quot;&gt; &lt;code&gt;None&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="2ded90014878b45a9d1013952a0eeccef1815fa3" translate="yes" xml:space="preserve">
          <source>This iterator yields mutable references to the slice's elements, so while the element type of the slice is &lt;code&gt;i32&lt;/code&gt;, the element type of the iterator is &lt;code&gt;&amp;amp;mut i32&lt;/code&gt;.</source>
          <target state="translated">Этот итератор дает изменяемые ссылки на элементы среза, поэтому, хотя тип элемента среза - &lt;code&gt;i32&lt;/code&gt; , тип элемента итератора - &lt;code&gt;&amp;amp;mut i32&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f11293328eb4e550149e3eb11d18b4b99dadeb4a" translate="yes" xml:space="preserve">
          <source>This key uses the fastest possible implementation available to it for the target platform. It is instantiated with the &lt;a href=&quot;../macro.thread_local&quot;&gt;&lt;code&gt;thread_local!&lt;/code&gt;&lt;/a&gt; macro and the primary method is the &lt;a href=&quot;struct.localkey#method.with&quot;&gt;&lt;code&gt;with&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">Этот ключ использует максимально быструю реализацию, доступную для целевой платформы. Он &lt;a href=&quot;../macro.thread_local&quot;&gt; &lt;code&gt;thread_local!&lt;/code&gt; &lt;/a&gt; с помощью thread_local! макрос, а основным методом является метод &lt;a href=&quot;struct.localkey#method.with&quot;&gt; &lt;code&gt;with&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="8ba72c9f8d060c616c313ff46104db0834e023c2" translate="yes" xml:space="preserve">
          <source>This kind of reordering is handled transparently by the CPU.</source>
          <target state="translated">Такого рода переупорядочивание выполняется прозрачно центральным процессором.</target>
        </trans-unit>
        <trans-unit id="01e9e67a62e244fe3547a3a6a38b452018a02bd0" translate="yes" xml:space="preserve">
          <source>This kind of string &lt;em&gt;can&lt;/em&gt; be mutated:</source>
          <target state="translated">Эта строка &lt;em&gt;может&lt;/em&gt; быть видоизменена:</target>
        </trans-unit>
        <trans-unit id="a40000b09a25d1541d4b670c6d1a695e653d4397" translate="yes" xml:space="preserve">
          <source>This last example is different because it is not possible to use the suffix syntax with a floating point literal ending in a period. &lt;code&gt;2.f64&lt;/code&gt; would attempt to call a method named &lt;code&gt;f64&lt;/code&gt; on &lt;code&gt;2&lt;/code&gt;.</source>
          <target state="translated">Этот последний пример отличается тем, что невозможно использовать синтаксис суффикса с литералом с плавающей запятой, оканчивающимся точкой. &lt;code&gt;2.f64&lt;/code&gt; попытается вызвать метод с именем &lt;code&gt;f64&lt;/code&gt; на &lt;code&gt;2&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d48b41e91473a0fe92d3d1ed63ecf51de63aefff" translate="yes" xml:space="preserve">
          <source>This length is in bytes, not &lt;a href=&quot;../char/index&quot;&gt;&lt;code&gt;char&lt;/code&gt;&lt;/a&gt;s or graphemes. In other words, it may not be what a human considers the length of the string.</source>
          <target state="translated">Эта длина указывается в байтах, а не в &lt;a href=&quot;../char/index&quot;&gt; &lt;code&gt;char&lt;/code&gt; &lt;/a&gt; или графемах. Другими словами, это может быть не то, что человек считает длиной строки.</target>
        </trans-unit>
        <trans-unit id="73dde2c319f588f84c6b8fc0596849d35bbf8b64" translate="yes" xml:space="preserve">
          <source>This length is in bytes, not &lt;a href=&quot;../primitive.char&quot;&gt;&lt;code&gt;char&lt;/code&gt;&lt;/a&gt;s or graphemes. In other words, it may not be what a human considers the length of the string.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="903d848487fc64b3813a8038fcea8db3d845066a" translate="yes" xml:space="preserve">
          <source>This length is in bytes, not &lt;a href=&quot;char/index&quot;&gt;&lt;code&gt;char&lt;/code&gt;&lt;/a&gt;s or graphemes. In other words, it may not be what a human considers the length of the string.</source>
          <target state="translated">Эта длина указывается в байтах, а не в &lt;a href=&quot;char/index&quot;&gt; &lt;code&gt;char&lt;/code&gt; &lt;/a&gt; или графемах. Другими словами, это может быть не то, что человек считает длиной строки.</target>
        </trans-unit>
        <trans-unit id="7b4fe84d99fc580ad8ef75775e9a6a1acf338c01" translate="yes" xml:space="preserve">
          <source>This length is in bytes, not &lt;a href=&quot;primitive.char&quot;&gt;&lt;code&gt;char&lt;/code&gt;&lt;/a&gt;s or graphemes. In other words, it may not be what a human considers the length of the string.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2f8980a7dcbb36debff75ad398d722c2e476b435" translate="yes" xml:space="preserve">
          <source>This limitation may be removed in a future version of Rust.</source>
          <target state="translated">Это ограничение может быть снято в будущей версии Rust.</target>
        </trans-unit>
        <trans-unit id="65d7d6e48995b9a8b70ff571d23a4947777c0d68" translate="yes" xml:space="preserve">
          <source>This limitation on the size &lt;code&gt;N&lt;/code&gt; exists because Rust does not yet support code that is generic over the size of an array type. &lt;code&gt;[Foo; 3]&lt;/code&gt; and &lt;code&gt;[Bar; 3]&lt;/code&gt; are instances of same generic type &lt;code&gt;[T; 3]&lt;/code&gt;, but &lt;code&gt;[Foo; 3]&lt;/code&gt; and &lt;code&gt;[Foo; 5]&lt;/code&gt; are entirely different types. As a stopgap, trait implementations are statically generated up to size 32.</source>
          <target state="translated">Это ограничение на размер &lt;code&gt;N&lt;/code&gt; существует, потому что Rust еще не поддерживает код, который является универсальным для размера типа массива. &lt;code&gt;[Foo; 3]&lt;/code&gt; и &lt;code&gt;[Bar; 3]&lt;/code&gt; являются экземплярами одного и того же универсального типа &lt;code&gt;[T; 3]&lt;/code&gt; , но &lt;code&gt;[Foo; 3]&lt;/code&gt; и &lt;code&gt;[Foo; 5]&lt;/code&gt; совершенно разные типы. В качестве временной меры реализации трейтов статически генерируются до размера 32.</target>
        </trans-unit>
        <trans-unit id="08204384af7f77c5b07543f234ee809fc102751e" translate="yes" xml:space="preserve">
          <source>This line brings &lt;code&gt;std::io&lt;/code&gt; and &lt;code&gt;std::io::Write&lt;/code&gt; into scope.</source>
          <target state="translated">Эта строка переносит &lt;code&gt;std::io&lt;/code&gt; и &lt;code&gt;std::io::Write&lt;/code&gt; в область видимости.</target>
        </trans-unit>
        <trans-unit id="c84219e32c60c562866367e57dce5465f094cc72" translate="yes" xml:space="preserve">
          <source>This line creates a new empty string called &lt;code&gt;s&lt;/code&gt;, which we can then load data into. Often, we&amp;rsquo;ll have some initial data that we want to start the string with. For that, we use the &lt;code&gt;to_string&lt;/code&gt; method, which is available on any type that implements the &lt;code&gt;Display&lt;/code&gt; trait, as string literals do. Listing 8-12 shows two examples.</source>
          <target state="translated">Эта строка создает новую пустую строку с именем &lt;code&gt;s&lt;/code&gt; , в которую мы можем затем загружать данные. Часто у нас есть некоторые исходные данные, с которых мы хотим начать строку. Для этого мы используем метод &lt;code&gt;to_string&lt;/code&gt; , который доступен для любого типа, реализующего признак &lt;code&gt;Display&lt;/code&gt; , как это делают строковые литералы. В листинге 8-12 показаны два примера.</target>
        </trans-unit>
        <trans-unit id="c6d1af215b1b045e01e47bacfa1ae42f66655d33" translate="yes" xml:space="preserve">
          <source>This line creates a new variable named &lt;code&gt;foo&lt;/code&gt; and binds it to the value of the &lt;code&gt;bar&lt;/code&gt; variable. In Rust, variables are immutable by default. We&amp;rsquo;ll be discussing this concept in detail in the &lt;a href=&quot;ch03-01-variables-and-mutability#variables-and-mutability&quot;&gt;&amp;ldquo;Variables and Mutability&amp;rdquo;&lt;/a&gt; section in Chapter 3. The following example shows how to use &lt;code&gt;mut&lt;/code&gt; before the variable name to make a variable mutable:</source>
          <target state="translated">Эта строка создает новую переменную с именем &lt;code&gt;foo&lt;/code&gt; и связывает ее со значением переменной &lt;code&gt;bar&lt;/code&gt; . В Rust переменные по умолчанию неизменяемы. Мы подробно обсудим эту концепцию в разделе &lt;a href=&quot;ch03-01-variables-and-mutability#variables-and-mutability&quot;&gt;&amp;laquo;Переменные и изменчивость&amp;raquo;&lt;/a&gt; в главе 3. В следующем примере показано, как использовать &lt;code&gt;mut&lt;/code&gt; перед именем переменной, чтобы сделать переменную изменяемой:</target>
        </trans-unit>
        <trans-unit id="f414052fdd19a240f8f368c285f45f2ce792b467" translate="yes" xml:space="preserve">
          <source>This line does all the work in this little program: it prints text to the screen. There are four important details to notice here.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5d9eacc9407c12ec62c5abf0aec26e9081e77d6a" translate="yes" xml:space="preserve">
          <source>This line does all the work in this little program: it prints text to the screen. There are four important details to notice here. First, Rust style is to indent with four spaces, not a tab.</source>
          <target state="translated">Эта строка выполняет всю работу в этой маленькой программе:она печатает текст на экран.Здесь можно заметить четыре важные детали.Во-первых,стиль &quot;Ржавчина&quot;-это отступ с четырьмя пробелами,а не табуляция.</target>
        </trans-unit>
        <trans-unit id="6bb12529672d4d91a104d1b5e1346fffbd28c07c" translate="yes" xml:space="preserve">
          <source>This line prints the string we saved the user&amp;rsquo;s input in. The set of curly brackets, &lt;code&gt;{}&lt;/code&gt;, is a placeholder: think of &lt;code&gt;{}&lt;/code&gt; as little crab pincers that hold a value in place. You can print more than one value using curly brackets: the first set of curly brackets holds the first value listed after the format string, the second set holds the second value, and so on. Printing multiple values in one call to &lt;code&gt;println!&lt;/code&gt; would look like this:</source>
          <target state="translated">В этой строке печатается строка, в которой мы сохранили ввод пользователя. Набор фигурных скобок, &lt;code&gt;{}&lt;/code&gt; , является заполнителем: думайте о &lt;code&gt;{}&lt;/code&gt; как о маленьких клешнях, которые удерживают значение на месте. Вы можете напечатать более одного значения, используя фигурные скобки: первый набор фигурных скобок содержит первое значение, указанное после строки формата, второй набор содержит второе значение и так далее. Печать нескольких значений за один вызов &lt;code&gt;println!&lt;/code&gt; будет выглядеть так:</target>
        </trans-unit>
        <trans-unit id="250f132a4cd3e14f1923c5e6c25a460649fabde4" translate="yes" xml:space="preserve">
          <source>This list is intended to grow over time and it is not recommended to exhaustively match against it.</source>
          <target state="translated">Этот список предназначен для того,чтобы расти со временем,и не рекомендуется исчерпывающе сопоставлять его с ним.</target>
        </trans-unit>
        <trans-unit id="308882c8bb15621452c72c71d1e862ba6ca42816" translate="yes" xml:space="preserve">
          <source>This longer form is equivalent to the example in the previous section but is more verbose. We place trait bounds with the declaration of the generic type parameter after a colon and inside angle brackets.</source>
          <target state="translated">Эта более длинная форма эквивалентна примеру в предыдущем разделе,но более многословна.Мы помещаем границы трейта с объявлением общего параметра типа после двоеточия и внутри угловых скобок.</target>
        </trans-unit>
        <trans-unit id="cc7e694b75fd14e7d2942129d96e2363378281a2" translate="yes" xml:space="preserve">
          <source>This looks very similar to the previous code, so we might assume that the way it works would be the same: that is, the second line would make a copy of the value in &lt;code&gt;s1&lt;/code&gt; and bind it to &lt;code&gt;s2&lt;/code&gt;. But this isn&amp;rsquo;t quite what happens.</source>
          <target state="translated">Это выглядит очень похоже на предыдущий код, поэтому мы можем предположить, что способ его работы будет таким же: то есть вторая строка сделает копию значения в &lt;code&gt;s1&lt;/code&gt; и привяжет его к &lt;code&gt;s2&lt;/code&gt; . Но это не совсем то, что происходит.</target>
        </trans-unit>
        <trans-unit id="1be98a7c6692df395b8bd9dd115eb38bb55be823" translate="yes" xml:space="preserve">
          <source>This macro accepts a 'writer', a format string, and a list of arguments. Arguments will be formatted according to the specified format string and the result will be passed to the writer. The writer may be any value with a &lt;code&gt;write_fmt&lt;/code&gt; method; generally this comes from an implementation of either the &lt;a href=&quot;fmt/trait.write&quot;&gt;&lt;code&gt;fmt::Write&lt;/code&gt;&lt;/a&gt; or the &lt;a href=&quot;io/trait.write&quot;&gt;&lt;code&gt;io::Write&lt;/code&gt;&lt;/a&gt; trait. The macro returns whatever the &lt;code&gt;write_fmt&lt;/code&gt; method returns; commonly a &lt;a href=&quot;fmt/type.result&quot;&gt;&lt;code&gt;fmt::Result&lt;/code&gt;&lt;/a&gt;, or an &lt;a href=&quot;io/type.result&quot;&gt;&lt;code&gt;io::Result&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3025eb870ba9e5f6ef770103ab20b04b0f42de4f" translate="yes" xml:space="preserve">
          <source>This macro accepts a format string, a list of arguments, and a 'writer'. Arguments will be formatted according to the specified format string and the result will be passed to the writer. The writer may be any value with a &lt;code&gt;write_fmt&lt;/code&gt; method; generally this comes from an implementation of either the &lt;a href=&quot;fmt/trait.write&quot;&gt;&lt;code&gt;fmt::Write&lt;/code&gt;&lt;/a&gt; or the &lt;a href=&quot;io/trait.write&quot;&gt;&lt;code&gt;io::Write&lt;/code&gt;&lt;/a&gt; trait. The macro returns whatever the &lt;code&gt;write_fmt&lt;/code&gt; method returns; commonly a &lt;a href=&quot;fmt/type.result&quot;&gt;&lt;code&gt;fmt::Result&lt;/code&gt;&lt;/a&gt;, or an &lt;a href=&quot;io/type.result&quot;&gt;&lt;code&gt;io::Result&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e9c26f6e16b6bec90033e045df684b9983904c03" translate="yes" xml:space="preserve">
          <source>This macro accepts a format string, a list of arguments, and a 'writer'. Arguments will be formatted according to the specified format string and the result will be passed to the writer. The writer may be any value with a &lt;code&gt;write_fmt&lt;/code&gt; method; generally this comes from an implementation of either the &lt;a href=&quot;fmt/trait.write&quot;&gt;&lt;code&gt;std::fmt::Write&lt;/code&gt;&lt;/a&gt; or the &lt;a href=&quot;io/trait.write&quot;&gt;&lt;code&gt;std::io::Write&lt;/code&gt;&lt;/a&gt; trait. The macro returns whatever the &lt;code&gt;write_fmt&lt;/code&gt; method returns; commonly a &lt;a href=&quot;fmt/type.result&quot;&gt;&lt;code&gt;std::fmt::Result&lt;/code&gt;&lt;/a&gt;, or an &lt;a href=&quot;io/type.result&quot;&gt;&lt;code&gt;io::Result&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Этот макрос принимает строку формата, список аргументов и &amp;laquo;писатель&amp;raquo;. Аргументы будут отформатированы в соответствии с указанной строкой формата, и результат будет передан автору записи. Писателем может быть любое значение с методом &lt;code&gt;write_fmt&lt;/code&gt; ; обычно это происходит из-за реализации признака &lt;a href=&quot;fmt/trait.write&quot;&gt; &lt;code&gt;std::fmt::Write&lt;/code&gt; &lt;/a&gt; или &lt;a href=&quot;io/trait.write&quot;&gt; &lt;code&gt;std::io::Write&lt;/code&gt; &lt;/a&gt; . Макрос возвращает все, что возвращает метод &lt;code&gt;write_fmt&lt;/code&gt; ; обычно &lt;a href=&quot;fmt/type.result&quot;&gt; &lt;code&gt;std::fmt::Result&lt;/code&gt; &lt;/a&gt; или &lt;a href=&quot;io/type.result&quot;&gt; &lt;code&gt;io::Result&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="80d761ee9febd1152f2043eb4792d1bde7232938" translate="yes" xml:space="preserve">
          <source>This macro bakes in propagation of &lt;code&gt;Pending&lt;/code&gt; signals by returning early.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9104464c61f2440f3d22798d14bf9b51373598ab" translate="yes" xml:space="preserve">
          <source>This macro functions by taking a formatting string literal containing &lt;code&gt;{}&lt;/code&gt; for each additional argument passed. &lt;code&gt;format_args!&lt;/code&gt; prepares the additional parameters to ensure the output can be interpreted as a string and canonicalizes the arguments into a single type. Any value that implements the &lt;a href=&quot;fmt/trait.display&quot;&gt;&lt;code&gt;Display&lt;/code&gt;&lt;/a&gt; trait can be passed to &lt;code&gt;format_args!&lt;/code&gt;, as can any &lt;a href=&quot;fmt/trait.debug&quot;&gt;&lt;code&gt;Debug&lt;/code&gt;&lt;/a&gt; implementation be passed to a &lt;code&gt;{:?}&lt;/code&gt; within the formatting string.</source>
          <target state="translated">Этот макрос работает, принимая строковый литерал форматирования, содержащий &lt;code&gt;{}&lt;/code&gt; для каждого переданного дополнительного аргумента. &lt;code&gt;format_args!&lt;/code&gt; подготавливает дополнительные параметры, чтобы выходные данные можно было интерпретировать как строку, и преобразует аргументы в один тип. Любое значение, реализующее свойство &lt;a href=&quot;fmt/trait.display&quot;&gt; &lt;code&gt;Display&lt;/code&gt; ,&lt;/a&gt; можно передать в &lt;code&gt;format_args!&lt;/code&gt; , как и любая реализация &lt;a href=&quot;fmt/trait.debug&quot;&gt; &lt;code&gt;Debug&lt;/code&gt; &lt;/a&gt; может быть передана в &lt;code&gt;{:?}&lt;/code&gt; в строке форматирования.</target>
        </trans-unit>
        <trans-unit id="c0f46ebdcffb6d5939dcac636e4ba0ac8074178d" translate="yes" xml:space="preserve">
          <source>This macro has a second form, where a custom panic message can be provided with or without arguments for formatting. See &lt;a href=&quot;fmt/index&quot;&gt;&lt;code&gt;std::fmt&lt;/code&gt;&lt;/a&gt; for syntax for this form.</source>
          <target state="translated">Этот макрос имеет вторую форму, в которой пользовательское сообщение о панике может быть предоставлено с аргументами для форматирования или без них. См. &lt;a href=&quot;fmt/index&quot;&gt; &lt;code&gt;std::fmt&lt;/code&gt; &lt;/a&gt; для синтаксиса этой формы.</target>
        </trans-unit>
        <trans-unit id="1cb7c87fdbeb8a27a8d17493d87d56c13827aded" translate="yes" xml:space="preserve">
          <source>This macro has a second form, where a custom panic message can be provided with or without arguments for formatting. See &lt;a href=&quot;https://doc.rust-lang.org/core/fmt/index.html&quot;&gt;&lt;code&gt;std::fmt&lt;/code&gt;&lt;/a&gt; for syntax for this form.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4b5986245d717af402afebe47105d05cdf22c051" translate="yes" xml:space="preserve">
          <source>This macro is provided in the standard library and will detect at runtime whether the specified CPU feature is detected. This does &lt;strong&gt;not&lt;/strong&gt; resolve at compile time unless the specified feature is already enabled for the entire crate. Runtime detection currently relies mostly on the &lt;code&gt;cpuid&lt;/code&gt; instruction.</source>
          <target state="translated">Этот макрос предоставляется в стандартной библиотеке и будет определять во время выполнения, обнаружена ли указанная функция ЦП. Это &lt;strong&gt;не&lt;/strong&gt; разрешается во время компиляции, если указанная функция уже не включена для всего ящика. В настоящее время определение времени выполнения в основном полагается на инструкцию &lt;code&gt;cpuid&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9c76b02a9e85e30ad24e030882216f3064330d6d" translate="yes" xml:space="preserve">
          <source>This macro is the perfect way to assert conditions in example code and in tests. &lt;code&gt;panic!&lt;/code&gt; is closely tied with the &lt;code&gt;unwrap&lt;/code&gt; method of both &lt;a href=&quot;option/enum.option#method.unwrap&quot;&gt;&lt;code&gt;Option&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;result/enum.result#method.unwrap&quot;&gt;&lt;code&gt;Result&lt;/code&gt;&lt;/a&gt; enums. Both implementations call &lt;code&gt;panic!&lt;/code&gt; when they are set to &lt;a href=&quot;option/enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;result/enum.result#variant.Err&quot;&gt;&lt;code&gt;Err&lt;/code&gt;&lt;/a&gt; variants.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="80d199c9b2bbee396aca26a7f3417fd4e87ff814" translate="yes" xml:space="preserve">
          <source>This macro is the perfect way to assert conditions in example code and in tests. &lt;code&gt;panic!&lt;/code&gt; is closely tied with the &lt;code&gt;unwrap&lt;/code&gt; method of both &lt;a href=&quot;option/enum.option#method.unwrap&quot;&gt;&lt;code&gt;Option&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;result/enum.result#method.unwrap&quot;&gt;&lt;code&gt;Result&lt;/code&gt;&lt;/a&gt; enums. Both implementations call &lt;code&gt;panic!&lt;/code&gt; when they are set to None or Err variants.</source>
          <target state="translated">Этот макрос - идеальный способ утверждения условий в примере кода и в тестах. &lt;code&gt;panic!&lt;/code&gt; тесно связан с методом &lt;code&gt;unwrap&lt;/code&gt; перечислений &lt;a href=&quot;option/enum.option#method.unwrap&quot;&gt; &lt;code&gt;Option&lt;/code&gt; &lt;/a&gt; и &lt;a href=&quot;result/enum.result#method.unwrap&quot;&gt; &lt;code&gt;Result&lt;/code&gt; &lt;/a&gt; . Обе реализации вызывают &lt;code&gt;panic!&lt;/code&gt; когда для них установлено значение None или Err.</target>
        </trans-unit>
        <trans-unit id="d0ebce932633e1b0cd797b4ddeb6ac5a11d9e6f7" translate="yes" xml:space="preserve">
          <source>This macro is used to inject panic into a Rust thread, causing the thread to panic entirely. Each thread's panic can be reaped as the &lt;a href=&quot;boxed/struct.box&quot;&gt;&lt;code&gt;Box&lt;/code&gt;&lt;/a&gt;&lt;code&gt;&amp;lt;&lt;/code&gt;&lt;a href=&quot;any/trait.any&quot;&gt;&lt;code&gt;Any&lt;/code&gt;&lt;/a&gt;&lt;code&gt;&amp;gt;&lt;/code&gt; type, and the single-argument form of the &lt;code&gt;panic!&lt;/code&gt; macro will be the value which is transmitted.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cf0774da3df0d29e08106daf482fff334bcea403" translate="yes" xml:space="preserve">
          <source>This macro is used to inject panic into a Rust thread, causing the thread to panic entirely. Each thread's panic can be reaped as the &lt;code&gt;Box&amp;lt;Any&amp;gt;&lt;/code&gt; type, and the single-argument form of the &lt;code&gt;panic!&lt;/code&gt; macro will be the value which is transmitted.</source>
          <target state="translated">Этот макрос используется для внедрения паники в поток Rust, вызывая полную панику потока. Паника каждого потока может быть обработана как тип &lt;code&gt;Box&amp;lt;Any&amp;gt;&lt;/code&gt; , так и форма &lt;code&gt;panic!&lt;/code&gt; с одним аргументом ! макрос будет значением, которое передается.</target>
        </trans-unit>
        <trans-unit id="e7802aaf0db102edbab92f402c03063ff3b73be4" translate="yes" xml:space="preserve">
          <source>This macro only takes one argument which is a string literal of the feature being tested for. The feature names supported are the lowercase versions of the ones defined by Intel in &lt;a href=&quot;https://software.intel.com/sites/landingpage/IntrinsicsGuide&quot;&gt;their documentation&lt;/a&gt;.</source>
          <target state="translated">Этот макрос принимает только один аргумент, который представляет собой строковый литерал проверяемой функции. Поддерживаемые имена функций - это строчные версии тех, которые определены Intel в &lt;a href=&quot;https://software.intel.com/sites/landingpage/IntrinsicsGuide&quot;&gt;их документации&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="4bd8a54709ee381edf667e1b754c2dd4776028dd" translate="yes" xml:space="preserve">
          <source>This macro produces a value of type &lt;a href=&quot;fmt/struct.arguments&quot;&gt;&lt;code&gt;fmt::Arguments&lt;/code&gt;&lt;/a&gt;. This value can be passed to the macros within &lt;a href=&quot;fmt/index&quot;&gt;&lt;code&gt;std::fmt&lt;/code&gt;&lt;/a&gt; for performing useful redirection. All other formatting macros (&lt;a href=&quot;macro.format&quot;&gt;&lt;code&gt;format!&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;macro.write&quot;&gt;&lt;code&gt;write!&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;macro.println&quot;&gt;&lt;code&gt;println!&lt;/code&gt;&lt;/a&gt;, etc) are proxied through this one. &lt;code&gt;format_args!&lt;/code&gt;, unlike its derived macros, avoids heap allocations.</source>
          <target state="translated">Этот макрос создает значение типа &lt;a href=&quot;fmt/struct.arguments&quot;&gt; &lt;code&gt;fmt::Arguments&lt;/code&gt; &lt;/a&gt; . Это значение можно передать макросам в &lt;a href=&quot;fmt/index&quot;&gt; &lt;code&gt;std::fmt&lt;/code&gt; &lt;/a&gt; для выполнения полезного перенаправления. Все остальные макросы форматирования ( &lt;a href=&quot;macro.format&quot;&gt; &lt;code&gt;format!&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;macro.write&quot;&gt; &lt;code&gt;write!&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;macro.println&quot;&gt; &lt;code&gt;println!&lt;/code&gt; &lt;/a&gt; И т.д.) являются проксированными через это. &lt;code&gt;format_args!&lt;/code&gt; в отличие от производных от него макросов избегает выделения кучи.</target>
        </trans-unit>
        <trans-unit id="209265c4eb72c5eca06cd095d36df90048938379" translate="yes" xml:space="preserve">
          <source>This macro produces a value of type &lt;a href=&quot;fmt/struct.arguments&quot;&gt;&lt;code&gt;fmt::Arguments&lt;/code&gt;&lt;/a&gt;. This value can be passed to the macros within &lt;a href=&quot;https://doc.rust-lang.org/core/fmt/index.html&quot;&gt;&lt;code&gt;std::fmt&lt;/code&gt;&lt;/a&gt; for performing useful redirection. All other formatting macros (&lt;a href=&quot;macro.format&quot;&gt;&lt;code&gt;format!&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;macro.write&quot;&gt;&lt;code&gt;write!&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;macro.println&quot;&gt;&lt;code&gt;println!&lt;/code&gt;&lt;/a&gt;, etc) are proxied through this one. &lt;code&gt;format_args!&lt;/code&gt;, unlike its derived macros, avoids heap allocations.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1d449e18cd48bf8c444aeabc9c847abf69b5ab8d" translate="yes" xml:space="preserve">
          <source>This macro should be used when a crate uses a conditional compilation strategy to provide better error messages for erroneous conditions. It's the compiler-level form of &lt;a href=&quot;macro.panic&quot;&gt;&lt;code&gt;panic!&lt;/code&gt;&lt;/a&gt;, but emits an error during &lt;em&gt;compilation&lt;/em&gt; rather than at &lt;em&gt;runtime&lt;/em&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d49c196cc9f23d7594245f1cc87a1f518746592e" translate="yes" xml:space="preserve">
          <source>This macro should be used when a crate uses a conditional compilation strategy to provide better error messages for erroneous conditions. It's the compiler-level form of &lt;a href=&quot;macro.panic&quot;&gt;&lt;code&gt;panic!&lt;/code&gt;&lt;/a&gt;, which emits an error at &lt;em&gt;runtime&lt;/em&gt;, rather than during compilation.</source>
          <target state="translated">Этот макрос следует использовать, когда ящик использует стратегию условной компиляции, чтобы предоставлять более точные сообщения об ошибках для ошибочных условий. Это форма &lt;a href=&quot;macro.panic&quot;&gt; &lt;code&gt;panic!&lt;/code&gt; &lt;/a&gt; уровне компилятора ! , который выдает ошибку во &lt;em&gt;время выполнения&lt;/em&gt; , а не во время компиляции.</target>
        </trans-unit>
        <trans-unit id="68d15cf83524f34dd8d8be7a2a8e7bed6740e783" translate="yes" xml:space="preserve">
          <source>This macro supports the same names that &lt;code&gt;#[target_feature]&lt;/code&gt; supports. Unlike &lt;code&gt;#[target_feature]&lt;/code&gt;, however, this macro does not support names separated with a comma. Instead testing for multiple features must be done through separate macro invocations for now.</source>
          <target state="translated">Этот макрос поддерживает те же имена, что и &lt;code&gt;#[target_feature]&lt;/code&gt; . Однако, в отличие от &lt;code&gt;#[target_feature]&lt;/code&gt; , этот макрос не поддерживает имена, разделенные запятыми. Вместо этого тестирование нескольких функций на данный момент должно выполняться с помощью отдельных вызовов макросов.</target>
        </trans-unit>
        <trans-unit id="fefc6add454f34259443790785050840eebbeb57" translate="yes" xml:space="preserve">
          <source>This macro takes any number of comma-separated identifiers, and concatenates them all into one, yielding an expression which is a new identifier. Note that hygiene makes it such that this macro cannot capture local variables. Also, as a general rule, macros are only allowed in item, statement or expression position. That means while you may use this macro for referring to existing variables, functions or modules etc, you cannot define a new one with it.</source>
          <target state="translated">Данный макрос берет любое количество идентификаторов,разделенных запятыми,и объединяет их все в один,в результате чего получается выражение,являющееся новым идентификатором.Обратите внимание,что гигиена такова,что данный макрос не может перехватывать локальные переменные.Также,как правило,макросы разрешены только в позиции элемента,оператора или выражения.Это означает,что,хотя вы можете использовать данный макрос для обращения к существующим переменным,функциям или модулям и т.д.,вы не можете определить новый макрос с его помощью.</target>
        </trans-unit>
        <trans-unit id="a79ce9bb3fa69012483f80e7a1a2541065700d68" translate="yes" xml:space="preserve">
          <source>This macro takes any number of comma-separated literals, yielding an expression of type &lt;code&gt;&amp;amp;'static str&lt;/code&gt; which represents all of the literals concatenated left-to-right.</source>
          <target state="translated">Этот макрос принимает любое количество литералов, разделенных запятыми, что дает выражение типа &lt;code&gt;&amp;amp;'static str&lt;/code&gt; которое представляет все литералы, объединенные слева направо.</target>
        </trans-unit>
        <trans-unit id="79fc3c2904becf8aa3c820c279472de0fe3a1f68" translate="yes" xml:space="preserve">
          <source>This macro will expand to the value of the named environment variable at compile time, yielding an expression of type &lt;code&gt;&amp;amp;'static str&lt;/code&gt;.</source>
          <target state="translated">Этот макрос будет расширяться до значения указанной переменной среды во время компиляции, давая выражение типа &lt;code&gt;&amp;amp;'static str&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="95e973b1ebc33842358cee19e0dba22c8a81f994" translate="yes" xml:space="preserve">
          <source>This macro will yield an expression of type &lt;code&gt;&amp;amp;'static [u8; N]&lt;/code&gt; which is the contents of the file.</source>
          <target state="translated">Этот макрос даст выражение типа &lt;code&gt;&amp;amp;'static [u8; N]&lt;/code&gt; который является содержимым файла.</target>
        </trans-unit>
        <trans-unit id="9cdb0bb59a3aefac2ea084695df47352b8cc7f18" translate="yes" xml:space="preserve">
          <source>This macro will yield an expression of type &lt;code&gt;&amp;amp;'static str&lt;/code&gt; which is the contents of the file.</source>
          <target state="translated">Этот макрос даст выражение типа &lt;code&gt;&amp;amp;'static str&lt;/code&gt; которое является содержимым файла.</target>
        </trans-unit>
        <trans-unit id="8d3907f6b0e9a61a4bdb55de9a362a92915237c3" translate="yes" xml:space="preserve">
          <source>This macro will yield an expression of type &lt;code&gt;&amp;amp;'static str&lt;/code&gt; which is the stringification of all the tokens passed to the macro. No restrictions are placed on the syntax of the macro invocation itself.</source>
          <target state="translated">Этот макрос приведет к выражению типа &lt;code&gt;&amp;amp;'static str&lt;/code&gt; которое является строковым преобразованием всех токенов, переданных в макрос. На синтаксис самого вызова макроса нет ограничений.</target>
        </trans-unit>
        <trans-unit id="96f8e740156b1fe8242bb1857eb516b34c772e7e" translate="yes" xml:space="preserve">
          <source>This macro would parse the SQL statement inside it and check that it&amp;rsquo;s syntactically correct, which is much more complex processing than a &lt;code&gt;macro_rules!&lt;/code&gt; macro can do. The &lt;code&gt;sql!&lt;/code&gt; macro would be defined like this:</source>
          <target state="translated">Этот макрос будет анализировать внутри него оператор SQL и проверять его синтаксическую правильность, что является гораздо более сложной обработкой, чем &lt;code&gt;macro_rules!&lt;/code&gt; макрос может сделать. &lt;code&gt;sql!&lt;/code&gt; макрос будет определяться так:</target>
        </trans-unit>
        <trans-unit id="f58f7dcc462ef7387fceff17b5cae04e3cbcbf04" translate="yes" xml:space="preserve">
          <source>This makes the trait implemented on all types in the scope. So if you try to implement it on another one after that, the implementations will conflict. Example:</source>
          <target state="translated">Это делает черту реализованной на всех типах в области видимости.Поэтому,если после этого попытаться реализовать его на другом типе,реализации будут конфликтовать.Пример:</target>
        </trans-unit>
        <trans-unit id="dafc2f14b4f56d8dc5d075ff34c826a36e387880" translate="yes" xml:space="preserve">
          <source>This may not actually increase the capacity:</source>
          <target state="translated">Это может фактически не увеличить мощность:</target>
        </trans-unit>
        <trans-unit id="af903b6fc00acf0d280f6c29b1e0e8d3aeb94082" translate="yes" xml:space="preserve">
          <source>This may only be called by &lt;code&gt;Read&lt;/code&gt;ers which guarantee that they will not read from buffers passed to &lt;code&gt;Read&lt;/code&gt; methods, and that the return value of the method accurately reflects the number of bytes that have been written to the head of the buffer.</source>
          <target state="translated">Это может быть вызвано только объектами &lt;code&gt;Read&lt;/code&gt; которые гарантируют, что они не будут читать из буферов, переданных методам &lt;code&gt;Read&lt;/code&gt; , и что возвращаемое значение метода точно отражает количество байтов, которые были записаны в заголовок буфера.</target>
        </trans-unit>
        <trans-unit id="14a8a7c42cf833272747226b7446d6fe81b3ec47" translate="yes" xml:space="preserve">
          <source>This may require additional type hints in the function body.</source>
          <target state="translated">Это может потребовать дополнительных подсказок типа в теле функции.</target>
        </trans-unit>
        <trans-unit id="ac8b21b0f73b2747acf512efef8390bcec866c71" translate="yes" xml:space="preserve">
          <source>This means iterator adapters can rely on the source not changing during iteration but they cannot rely on it in their Drop implementations.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b07ba109060bf875c034ba50fdb9ffdabfec4929" translate="yes" xml:space="preserve">
          <source>This means that &lt;code&gt;&amp;lt;T: 'a + ?Sized&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;T: 'b + Sized&amp;gt;&lt;/code&gt; and &lt;code&gt;&amp;lt;T&amp;gt;&lt;/code&gt; are all permitted.</source>
          <target state="translated">Это означает, что разрешены &lt;code&gt;&amp;lt;T: 'a + ?Sized&amp;gt;&lt;/code&gt; , &lt;code&gt;&amp;lt;T: 'b + Sized&amp;gt;&lt;/code&gt; и &lt;code&gt;&amp;lt;T&amp;gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7a8c1c98c2b07fe7a77662bf8cf1e31aa75a3d05" translate="yes" xml:space="preserve">
          <source>This means that any external crate referencing &lt;code&gt;implementation::api::f&lt;/code&gt; would receive a privacy violation, while the path &lt;code&gt;api::f&lt;/code&gt; would be allowed.</source>
          <target state="translated">Это означает, что любой внешний ящик, ссылающийся на &lt;code&gt;implementation::api::f&lt;/code&gt; , получит нарушение конфиденциальности, в то время как путь &lt;code&gt;api::f&lt;/code&gt; будет разрешен.</target>
        </trans-unit>
        <trans-unit id="be2e4dfa333e1a56bbed2f9ca40e5f02293eda70" translate="yes" xml:space="preserve">
          <source>This means that perhaps some of the preceding patterns are too general, this one is too specific or the ordering is incorrect.</source>
          <target state="translated">Это означает,что,возможно,некоторые из предшествующих деталей слишком общие,слишком специфичные или неправильное упорядочение.</target>
        </trans-unit>
        <trans-unit id="3a6a30f5c049c4edc23b7fd66710a9051982b10a" translate="yes" xml:space="preserve">
          <source>This means that someone can specify such a function:</source>
          <target state="translated">Это означает,что кто-то может указать такую функцию:</target>
        </trans-unit>
        <trans-unit id="cb26a69e23fbbf1b07ba0d9979e852887a91fd3d" translate="yes" xml:space="preserve">
          <source>This means that the contents of the first string above &lt;em&gt;will&lt;/em&gt; fit into a &lt;code&gt;char&lt;/code&gt; while the contents of the second string &lt;em&gt;will not&lt;/em&gt;. Trying to create a &lt;code&gt;char&lt;/code&gt; literal with the contents of the second string gives an error:</source>
          <target state="translated">Это означает , что содержимое первой строки выше &lt;em&gt;будет&lt;/em&gt; вписываться в &lt;code&gt;char&lt;/code&gt; , а содержимое второй строки &lt;em&gt;не будет&lt;/em&gt; . Попытка создать &lt;code&gt;char&lt;/code&gt; литерал с содержимым второй строки дает ошибку:</target>
        </trans-unit>
        <trans-unit id="f9131c9dc6b963db63fbff2769fe5ceda6bacdcc" translate="yes" xml:space="preserve">
          <source>This means that the operands don't have to be moved out of.</source>
          <target state="translated">Это значит,что операндов не нужно вывозить.</target>
        </trans-unit>
        <trans-unit id="b2ca51239acb100a6dd5efb03e14c814a0a94286" translate="yes" xml:space="preserve">
          <source>This means that when &lt;code&gt;s&lt;/code&gt; reaches the end of &lt;code&gt;demo&lt;/code&gt;, its destructor gets exclusive access to its &lt;code&gt;&amp;amp;mut&lt;/code&gt;-borrowed string data. allowing another borrow of that string data (&lt;code&gt;p&lt;/code&gt;), to exist across the drop of &lt;code&gt;s&lt;/code&gt; would be a violation of the principle that &lt;code&gt;&amp;amp;mut&lt;/code&gt;-borrows have exclusive, unaliased access to their referenced data.</source>
          <target state="translated">Это означает, что когда &lt;code&gt;s&lt;/code&gt; достигает конца &lt;code&gt;demo&lt;/code&gt; , его деструктор получает эксклюзивный доступ к своим строковым данным, заимствованным &lt;code&gt;&amp;amp;mut&lt;/code&gt; . разрешить другому заимствованию этих строковых данных ( &lt;code&gt;p&lt;/code&gt; ) существовать через отбрасывание &lt;code&gt;s&lt;/code&gt; было бы нарушением принципа, согласно которому &lt;code&gt;&amp;amp;mut&lt;/code&gt; -borrows имеют эксклюзивный, неэлисированный доступ к своим ссылочным данным.</target>
        </trans-unit>
        <trans-unit id="9b50029fc42e472fbad4bc857af78f98f36c748f" translate="yes" xml:space="preserve">
          <source>This means that, for example, the padding byte in &lt;code&gt;(u8, u16)&lt;/code&gt; is not necessarily zeroed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="382ebf724244bccd694c658a6e7769ce6b7c071d" translate="yes" xml:space="preserve">
          <source>This means, that in addition to &lt;code&gt;a == b&lt;/code&gt; and &lt;code&gt;a != b&lt;/code&gt; being strict inverses, the equality must be (for all &lt;code&gt;a&lt;/code&gt;, &lt;code&gt;b&lt;/code&gt; and &lt;code&gt;c&lt;/code&gt;):</source>
          <target state="translated">Это означает, что помимо того, что &lt;code&gt;a == b&lt;/code&gt; и &lt;code&gt;a != b&lt;/code&gt; являются строго обратными, должно быть равенство (для всех &lt;code&gt;a&lt;/code&gt; , &lt;code&gt;b&lt;/code&gt; и &lt;code&gt;c&lt;/code&gt; ):</target>
        </trans-unit>
        <trans-unit id="30330510a00e9290fc18b35d20dbe32f6afe0cd7" translate="yes" xml:space="preserve">
          <source>This method always returns &lt;code&gt;false&lt;/code&gt; after iteration has finished:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f2cb7c4ca14739fd7d110ae41517acd9e412a5c2" translate="yes" xml:space="preserve">
          <source>This method by itself is safe, but using it correctly requires extra care. Another thread can change the strong count at any time, including potentially between calling this method and acting on the result.</source>
          <target state="translated">Этот метод сам по себе безопасен,но его правильное использование требует дополнительной осторожности.Другой поток в любой момент может изменить сильный счет,в том числе и между вызовом этого метода и действием на результат.</target>
        </trans-unit>
        <trans-unit id="949f62fcaa7fc2070951a1bf81357a1eb29cd126" translate="yes" xml:space="preserve">
          <source>This method by itself is safe, but using it correctly requires extra care. Another thread can change the weak count at any time, including potentially between calling this method and acting on the result.</source>
          <target state="translated">Этот метод сам по себе безопасен,но его правильное использование требует дополнительной осторожности.Другой поток в любой момент может изменить слабый счет,в том числе и между вызовом этого метода и действием на результат.</target>
        </trans-unit>
        <trans-unit id="3282baf6619178b04f6e093d59df95e6b50b4f0b" translate="yes" xml:space="preserve">
          <source>This method can be used for string data that is &lt;em&gt;terminated&lt;/em&gt;, rather than &lt;em&gt;separated&lt;/em&gt; by a pattern.</source>
          <target state="translated">Этот метод можно использовать для строковых данных, которые &lt;em&gt;завершаются&lt;/em&gt; , а не &lt;em&gt;разделены&lt;/em&gt; шаблоном.</target>
        </trans-unit>
        <trans-unit id="3369ccac8ace2a653ec652b1d0a5f9f1bd24f346" translate="yes" xml:space="preserve">
          <source>This method can be used to reverse a comparison:</source>
          <target state="translated">Этот метод может быть использован для обратного сравнения:</target>
        </trans-unit>
        <trans-unit id="9f13cbe122409bed70a7bfa8652dd2b252fa340b" translate="yes" xml:space="preserve">
          <source>This method can be useful for situations in which the vector is serving as a buffer for other code, particularly over FFI:</source>
          <target state="translated">Этот метод может быть полезен в ситуациях,когда вектор служит буфером для другого кода,в частности для FFI:</target>
        </trans-unit>
        <trans-unit id="ce975c1398d44efbe8c10a5c85f55c0075a45068" translate="yes" xml:space="preserve">
          <source>This method can only succeed if the entire byte slice was successfully written, and this method will not return until all data has been written or an error occurs.</source>
          <target state="translated">Этот метод может быть успешным только в том случае,если был успешно записан весь срез байта,и этот метод не вернется до тех пор,пока не будут записаны все данные или не произойдет ошибка.</target>
        </trans-unit>
        <trans-unit id="e42e806090a8aa6caab77166483a1eda09b5296d" translate="yes" xml:space="preserve">
          <source>This method can only succeed if the entire string slice was successfully written, and this method will not return until all data has been written or an error occurs.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b1f7d3cdb0bfa41dd91aa3d1bf03416a16ee48f3" translate="yes" xml:space="preserve">
          <source>This method differs from &lt;a href=&quot;struct.syncsender#method.send&quot;&gt;&lt;code&gt;send&lt;/code&gt;&lt;/a&gt; by returning immediately if the channel's buffer is full or no receiver is waiting to acquire some data. Compared with &lt;a href=&quot;struct.syncsender#method.send&quot;&gt;&lt;code&gt;send&lt;/code&gt;&lt;/a&gt;, this function has two failure cases instead of one (one for disconnection, one for a full buffer).</source>
          <target state="translated">Этот метод отличается от &lt;a href=&quot;struct.syncsender#method.send&quot;&gt; &lt;code&gt;send&lt;/code&gt; &lt;/a&gt; тем, что возвращается немедленно, если буфер канала заполнен или ни один получатель не ожидает получения некоторых данных. По сравнению с &lt;a href=&quot;struct.syncsender#method.send&quot;&gt; &lt;code&gt;send&lt;/code&gt; &lt;/a&gt; , у этой функции есть два случая отказа вместо одного (один для отключения, один для полного буфера).</target>
        </trans-unit>
        <trans-unit id="028002d34f3fafd7bc54cd77bcaa912497a3b074" translate="yes" xml:space="preserve">
          <source>This method does &lt;strong&gt;not&lt;/strong&gt; pass ownership of the raw file descriptor to the caller. The descriptor is only guaranteed to be valid while the original object has not yet been destroyed.</source>
          <target state="translated">Этот метод &lt;strong&gt;не&lt;/strong&gt; передает право собственности на дескриптор необработанного файла вызывающей стороне. Дескриптор гарантированно действителен только тогда, когда исходный объект еще не был уничтожен.</target>
        </trans-unit>
        <trans-unit id="5fd9fa51612a49edd496cd80117e23b29a509eb6" translate="yes" xml:space="preserve">
          <source>This method does &lt;strong&gt;not&lt;/strong&gt; return the length of the duration when represented by microseconds. The returned number always represents a fractional portion of a second (i.e., it is less than one million).</source>
          <target state="translated">Этот метод &lt;strong&gt;не&lt;/strong&gt; возвращает длину продолжительности, если она представлена ​​микросекундами. Возвращаемое число всегда представляет собой дробную часть секунды (т. Е. Меньше одного миллиона).</target>
        </trans-unit>
        <trans-unit id="d3a3c1cf0cc150bd1c72971205d2190e708b8d2b" translate="yes" xml:space="preserve">
          <source>This method does &lt;strong&gt;not&lt;/strong&gt; return the length of the duration when represented by milliseconds. The returned number always represents a fractional portion of a second (i.e., it is less than one thousand).</source>
          <target state="translated">Этот метод &lt;strong&gt;не&lt;/strong&gt; возвращает длину продолжительности, если она представлена ​​в миллисекундах. Возвращаемое число всегда представляет собой дробную часть секунды (т.е. меньше одной тысячи).</target>
        </trans-unit>
        <trans-unit id="e8135547d5a3a3a5006fe1cbd5d76d770ff2a7a9" translate="yes" xml:space="preserve">
          <source>This method does &lt;strong&gt;not&lt;/strong&gt; return the length of the duration when represented by nanoseconds. The returned number always represents a fractional portion of a second (i.e., it is less than one billion).</source>
          <target state="translated">Этот метод &lt;strong&gt;не&lt;/strong&gt; возвращает длину продолжительности, если она представлена ​​в наносекундах. Возвращаемое число всегда представляет собой дробную часть секунды (т. Е. Меньше одного миллиарда).</target>
        </trans-unit>
        <trans-unit id="ac2e63056cc906cac74875b70f6f9009af31f73d" translate="yes" xml:space="preserve">
          <source>This method does not allocate and does not change the order of the inserted elements. As it returns a mutable slice, this can be used to sort a deque.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bdc4e2ef2ed35366fa011a172b72477b2d16bbd4" translate="yes" xml:space="preserve">
          <source>This method does not allocate and does not change the order of the inserted elements. As it returns a mutable slice, this can be used to sort or binary search a deque.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="16f6f5d172fff1f1f8e9b8bb728e19c58e51b4b5" translate="yes" xml:space="preserve">
          <source>This method doesn't produce a value, but the write may fail. It's crucial to handle the error case, and &lt;em&gt;not&lt;/em&gt; write something like this:</source>
          <target state="translated">Этот метод не дает значения, но запись может завершиться ошибкой. Крайне важно обрабатывать случай ошибки, а &lt;em&gt;не&lt;/em&gt; писать что-то вроде этого:</target>
        </trans-unit>
        <trans-unit id="0b024448d5d7228119631ad22266fba4066f9577" translate="yes" xml:space="preserve">
          <source>This method has a default implementation using &lt;a href=&quot;trait.exactsizeiterator#method.len&quot;&gt;&lt;code&gt;ExactSizeIterator::len()&lt;/code&gt;&lt;/a&gt;, so you don't need to implement it yourself.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="803e98a2b6e5f0d6a98c75881fdb55c1597f80f0" translate="yes" xml:space="preserve">
          <source>This method has a default implementation using &lt;code&gt;self.len()&lt;/code&gt;, so you don't need to implement it yourself.</source>
          <target state="translated">Этот метод имеет реализацию по умолчанию с использованием &lt;code&gt;self.len()&lt;/code&gt; , поэтому вам не нужно реализовывать его самостоятельно.</target>
        </trans-unit>
        <trans-unit id="02fc3c4c098f9a864e6c45270c0a8ae6ffc408ef" translate="yes" xml:space="preserve">
          <source>This method has a default implementation, so you usually should not implement it directly. However, if you can provide a more efficient implementation, you can do so. See the &lt;a href=&quot;trait.exactsizeiterator&quot;&gt;trait-level&lt;/a&gt; docs for an example.</source>
          <target state="translated">Этот метод имеет реализацию по умолчанию, поэтому вам обычно не следует реализовывать его напрямую. Однако, если вы можете обеспечить более эффективную реализацию, вы сможете это сделать. См. Пример в документации на &lt;a href=&quot;trait.exactsizeiterator&quot;&gt;уровне признаков&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="89f3649aa28c1d3c90be74ebfb70d517cce77458" translate="yes" xml:space="preserve">
          <source>This method has no purpose when either input element &lt;code&gt;T&lt;/code&gt; or output element &lt;code&gt;U&lt;/code&gt; are zero-sized and will return the original slice without splitting anything.</source>
          <target state="translated">Этот метод бесполезен, если входной элемент &lt;code&gt;T&lt;/code&gt; или выходной элемент &lt;code&gt;U&lt;/code&gt; имеют нулевой размер и вернут исходный срез, ничего не разделяя.</target>
        </trans-unit>
        <trans-unit id="08ef0643ebf0dc48a599dc8d5b289675edb9e0a3" translate="yes" xml:space="preserve">
          <source>This method is called implicitly when the value goes out of scope, and cannot be called explicitly (this is compiler error &lt;a href=&quot;../../error-index#E0040&quot;&gt;E0040&lt;/a&gt;). However, the &lt;a href=&quot;../mem/fn.drop&quot;&gt;&lt;code&gt;mem::drop&lt;/code&gt;&lt;/a&gt; function in the prelude can be used to call the argument's &lt;code&gt;Drop&lt;/code&gt; implementation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="37d2a8db1a00abc88d21d10b6113bf279aaebd51" translate="yes" xml:space="preserve">
          <source>This method is called implicitly when the value goes out of scope, and cannot be called explicitly (this is compiler error &lt;a href=&quot;../../error-index#E0040&quot;&gt;E0040&lt;/a&gt;). However, the &lt;a href=&quot;../mem/fn.drop&quot;&gt;&lt;code&gt;std::mem::drop&lt;/code&gt;&lt;/a&gt; function in the prelude can be used to call the argument's &lt;code&gt;Drop&lt;/code&gt; implementation.</source>
          <target state="translated">Этот метод вызывается неявно, когда значение выходит за пределы области видимости, и не может быть вызван явно (это ошибка компилятора &lt;a href=&quot;../../error-index#E0040&quot;&gt;E0040&lt;/a&gt; ). Однако функцию &lt;a href=&quot;../mem/fn.drop&quot;&gt; &lt;code&gt;std::mem::drop&lt;/code&gt; &lt;/a&gt; в прелюдии можно использовать для вызова реализации &lt;code&gt;Drop&lt;/code&gt; аргумента .</target>
        </trans-unit>
        <trans-unit id="0b2c9d3aaaa76ea8e330a8973b644085bc25e3bb" translate="yes" xml:space="preserve">
          <source>This method is carefully constructed to avoid allocation. It will consume the error, moving out the bytes, so that a copy of the bytes does not need to be made.</source>
          <target state="translated">Этот метод тщательно продуман,чтобы избежать распределения.Он будет потреблять ошибку,перемещая байты,так что нет необходимости делать копию байтов.</target>
        </trans-unit>
        <trans-unit id="ef9d0891851c4c2229a94b62e2e2cf59a2fd15db" translate="yes" xml:space="preserve">
          <source>This method is deprecated in favor of the identically-named inherent methods on &lt;code&gt;u8&lt;/code&gt;, &lt;code&gt;char&lt;/code&gt;, &lt;code&gt;[u8]&lt;/code&gt; and &lt;code&gt;str&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="84886aa1dad1934a5c9bdd981667f36e45fab018" translate="yes" xml:space="preserve">
          <source>This method is equivalent to &lt;a href=&quot;#method.new&quot;&gt;&lt;code&gt;new&lt;/code&gt;&lt;/a&gt; except that no runtime assertion is made that &lt;code&gt;v&lt;/code&gt; contains no 0 bytes, and it requires an actual byte vector, not anything that can be converted to one with Into.</source>
          <target state="translated">Этот метод эквивалентен &lt;a href=&quot;#method.new&quot;&gt; &lt;code&gt;new&lt;/code&gt; ,&lt;/a&gt; за исключением того, что во время выполнения не делается никаких заявлений о том, что &lt;code&gt;v&lt;/code&gt; не содержит 0 байтов, и для него требуется фактический вектор байтов, а не что-либо, что можно преобразовать в один с помощью Into.</target>
        </trans-unit>
        <trans-unit id="38f2c8e8e67faa398a8a8adc0a46e90cd363606b" translate="yes" xml:space="preserve">
          <source>This method is equivalent to &lt;a href=&quot;struct.cstring#method.new&quot;&gt;&lt;code&gt;CString::new&lt;/code&gt;&lt;/a&gt; except that no runtime assertion is made that &lt;code&gt;v&lt;/code&gt; contains no 0 bytes, and it requires an actual byte vector, not anything that can be converted to one with Into.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0358b021b2254c197a04c16c02e67b7c9901af56" translate="yes" xml:space="preserve">
          <source>This method is essentially a &lt;code&gt;transmute&lt;/code&gt; with respect to the elements in the returned middle slice, so all the usual caveats pertaining to &lt;code&gt;transmute::&amp;lt;T, U&amp;gt;&lt;/code&gt; also apply here.</source>
          <target state="translated">Этот метод, по сути, является &lt;code&gt;transmute&lt;/code&gt; элементов в возвращенном среднем срезе, поэтому здесь также применимы все обычные предостережения, касающиеся &lt;code&gt;transmute::&amp;lt;T, U&amp;gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="dd229ccab2f3fea46c41c098065dd891d877a2e6" translate="yes" xml:space="preserve">
          <source>This method is identical to &lt;a href=&quot;struct.builder#method.spawn&quot;&gt;&lt;code&gt;thread::Builder::spawn&lt;/code&gt;&lt;/a&gt;, except for the relaxed lifetime bounds, which render it unsafe. For a more complete documentation see &lt;a href=&quot;fn.spawn&quot;&gt;&lt;code&gt;thread::spawn&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Этот метод идентичен &lt;a href=&quot;struct.builder#method.spawn&quot;&gt; &lt;code&gt;thread::Builder::spawn&lt;/code&gt; &lt;/a&gt; , за исключением ослабленных границ времени жизни, которые делают его небезопасным. Для более полной документации см. &lt;a href=&quot;fn.spawn&quot;&gt; &lt;code&gt;thread::spawn&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="0bc2506b00444cfc62462ac1af4908c0bbe44456" translate="yes" xml:space="preserve">
          <source>This method is implemented using up to three seek operations. If this method returns successfully, the seek position is unchanged (i.e. the position before calling this method is the same as afterwards). However, if this method returns an error, the seek position is unspecified.</source>
          <target state="translated">Этот метод реализуется с использованием до трех операций поиска.При успешном возвращении этого метода позиция поиска остается неизменной (т.е.позиция до вызова этого метода такая же,как и после).Однако,если этот метод возвращает ошибку,позиция поиска остается неуказанной.</target>
        </trans-unit>
        <trans-unit id="f531cfc3a2c409d73bd0f5c2e2364c282b1a69bd" translate="yes" xml:space="preserve">
          <source>This method is primarily intended for moving out values in drop. Instead of using &lt;a href=&quot;#method.drop&quot;&gt;&lt;code&gt;ManuallyDrop::drop&lt;/code&gt;&lt;/a&gt; to manually drop the value, you can use this method to take the value and use it however desired. &lt;code&gt;Drop&lt;/code&gt; will be invoked on the returned value following normal end-of-scope rules.</source>
          <target state="translated">Этот метод в первую очередь предназначен для удаления значений по каплям. Вместо использования &lt;a href=&quot;#method.drop&quot;&gt; &lt;code&gt;ManuallyDrop::drop&lt;/code&gt; &lt;/a&gt; для ручного удаления значения вы можете использовать этот метод, чтобы взять значение и использовать его по своему усмотрению. &lt;code&gt;Drop&lt;/code&gt; будет вызываться для возвращаемого значения в соответствии с обычными правилами конца области действия.</target>
        </trans-unit>
        <trans-unit id="ff2d30c02e4e3426a2eb2e0e84eb302b53b0327c" translate="yes" xml:space="preserve">
          <source>This method is primarily intended for moving out values in drop. Instead of using &lt;a href=&quot;struct.manuallydrop#method.drop&quot;&gt;&lt;code&gt;ManuallyDrop::drop&lt;/code&gt;&lt;/a&gt; to manually drop the value, you can use this method to take the value and use it however desired.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="923fe0c4f9dba0ad8dc8e37a00ed66b6a9da0759" translate="yes" xml:space="preserve">
          <source>This method is primarily used to interface with the &lt;a href=&quot;../macro.format_args&quot;&gt;&lt;code&gt;format_args!&lt;/code&gt;&lt;/a&gt; macro, but it is rare that this should explicitly be called. The &lt;a href=&quot;../macro.write&quot;&gt;&lt;code&gt;write!&lt;/code&gt;&lt;/a&gt; macro should be favored to invoke this method instead.</source>
          <target state="translated">Этот метод в основном используется для взаимодействия с &lt;a href=&quot;../macro.format_args&quot;&gt; &lt;code&gt;format_args!&lt;/code&gt; &lt;/a&gt;макрос, но он редко должен вызываться явно. &lt;a href=&quot;../macro.write&quot;&gt; &lt;code&gt;write!&lt;/code&gt; &lt;/a&gt;макрос следует использовать для вызова этого метода.</target>
        </trans-unit>
        <trans-unit id="80fc60d5306ac7d19519f64033eaf35397e48023" translate="yes" xml:space="preserve">
          <source>This method is soft-deprecated. &lt;a href=&quot;../../error/trait.error#method.description&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">Этот метод считается устаревшим. &lt;a href=&quot;../../error/trait.error#method.description&quot;&gt;Читать далее&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="7e4625fa8bf128959917fb79c2180bb0bb7de232" translate="yes" xml:space="preserve">
          <source>This method is soft-deprecated. &lt;a href=&quot;../error/trait.error#method.description&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">Этот метод считается устаревшим. &lt;a href=&quot;../error/trait.error#method.description&quot;&gt;Читать далее&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="6a9beb6c54e6c8b198cf2df220314195725bd7bb" translate="yes" xml:space="preserve">
          <source>This method is soft-deprecated. &lt;a href=&quot;error/trait.error#method.description&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">Этот метод считается устаревшим. &lt;a href=&quot;error/trait.error#method.description&quot;&gt;Читать далее&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="5490d12dcf25f9008acb9584a8ddf0c95e1664f2" translate="yes" xml:space="preserve">
          <source>This method is stable and usable, but it should be unsafe. To fix that, it got deprecated in favor of the unsafe &lt;a href=&quot;#tymethod.pre_exec&quot;&gt;&lt;code&gt;pre_exec&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Этот метод стабилен и применим, но не должен быть безопасным. Чтобы исправить это, он устарел в пользу небезопасного &lt;a href=&quot;#tymethod.pre_exec&quot;&gt; &lt;code&gt;pre_exec&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="6a040da9f6f49ab3965186c9b54eab70d6aecfa7" translate="yes" xml:space="preserve">
          <source>This method is stable and usable, but it should be unsafe. To fix that, it got deprecated in favor of the unsafe &lt;a href=&quot;trait.commandext#tymethod.pre_exec&quot;&gt;&lt;code&gt;pre_exec&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="428465480a8425bf96628f818ad9aad9c7155318" translate="yes" xml:space="preserve">
          <source>This method is the const generic equivalent of &lt;a href=&quot;#method.chunks_exact&quot;&gt;&lt;code&gt;chunks_exact&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d5d24cf3a26d22530ab9cc10e498dc43f87c776a" translate="yes" xml:space="preserve">
          <source>This method is the const generic equivalent of &lt;a href=&quot;#method.chunks_exact_mut&quot;&gt;&lt;code&gt;chunks_exact_mut&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="881a668b22b8af1fbfcb4abff65037dd8a73fd44" translate="yes" xml:space="preserve">
          <source>This method is unsafe because a &lt;code&gt;Read&lt;/code&gt;er could otherwise return a non-zeroing &lt;code&gt;Initializer&lt;/code&gt; from another &lt;code&gt;Read&lt;/code&gt; type without an &lt;code&gt;unsafe&lt;/code&gt; block.</source>
          <target state="translated">Этот метод небезопасен, поскольку в противном случае &lt;code&gt;Read&lt;/code&gt; er мог бы вернуть ненулевой &lt;code&gt;Initializer&lt;/code&gt; из другого типа &lt;code&gt;Read&lt;/code&gt; без &lt;code&gt;unsafe&lt;/code&gt; блока.</target>
        </trans-unit>
        <trans-unit id="272d98e018b9a74f9a82d093db1b7d2de5f94a24" translate="yes" xml:space="preserve">
          <source>This method is useful when doing multiple calls to functions that consume the pinned type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b649b72cfd66bc53cdd1236dc499f467fbbbfc65" translate="yes" xml:space="preserve">
          <source>This method requires &lt;a href=&quot;../clone/trait.clone&quot;&gt;&lt;code&gt;Clone&lt;/code&gt;&lt;/a&gt; to be able clone the passed value. If you need more flexibility (or want to rely on &lt;a href=&quot;../default/trait.default&quot;&gt;&lt;code&gt;Default&lt;/code&gt;&lt;/a&gt; instead of &lt;a href=&quot;../clone/trait.clone&quot;&gt;&lt;code&gt;Clone&lt;/code&gt;&lt;/a&gt;), use &lt;a href=&quot;#method.resize_with&quot;&gt;&lt;code&gt;resize_with&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Этот метод требует, чтобы &lt;a href=&quot;../clone/trait.clone&quot;&gt; &lt;code&gt;Clone&lt;/code&gt; &lt;/a&gt; мог клонировать переданное значение. Если вам нужна большая гибкость (или вы хотите полагаться на &lt;a href=&quot;../default/trait.default&quot;&gt; &lt;code&gt;Default&lt;/code&gt; &lt;/a&gt; вместо &lt;a href=&quot;../clone/trait.clone&quot;&gt; &lt;code&gt;Clone&lt;/code&gt; &lt;/a&gt; ), используйте &lt;a href=&quot;#method.resize_with&quot;&gt; &lt;code&gt;resize_with&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="fe86d6b287ee66b5bfe82d8d97c6de5a30a28fea" translate="yes" xml:space="preserve">
          <source>This method requires &lt;code&gt;T&lt;/code&gt; to implement &lt;a href=&quot;../clone/trait.clone&quot;&gt;&lt;code&gt;Clone&lt;/code&gt;&lt;/a&gt;, in order to be able to clone the passed value. If you need more flexibility (or want to rely on &lt;a href=&quot;../default/trait.default&quot;&gt;&lt;code&gt;Default&lt;/code&gt;&lt;/a&gt; instead of &lt;a href=&quot;../clone/trait.clone&quot;&gt;&lt;code&gt;Clone&lt;/code&gt;&lt;/a&gt;), use &lt;a href=&quot;struct.vec#method.resize_with&quot;&gt;&lt;code&gt;Vec::resize_with&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d9a3bfc3f1c3963b065d50d6828d4da511aead6e" translate="yes" xml:space="preserve">
          <source>This method returns &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt; if slice does not end with &lt;code&gt;suffix&lt;/code&gt;. Also it returns the original slice if &lt;code&gt;suffix&lt;/code&gt; is an empty slice</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b59bebec2345a5a01479f3be93783390bba5fe3b" translate="yes" xml:space="preserve">
          <source>This method returns &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt; if slice does not start with &lt;code&gt;prefix&lt;/code&gt;. Also it returns the original slice if &lt;code&gt;prefix&lt;/code&gt; is an empty slice.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b95f081db21ce8cf4e6f46e10880425784f2765c" translate="yes" xml:space="preserve">
          <source>This method returns &lt;a href=&quot;../primitive.bool&quot;&gt;&lt;code&gt;true&lt;/code&gt;&lt;/a&gt; for addresses in the range reserved by [RFC 4291 section 2.4], i.e. addresses with the following format:</source>
          <target state="translated">Этот метод возвращает &lt;a href=&quot;../primitive.bool&quot;&gt; &lt;code&gt;true&lt;/code&gt; &lt;/a&gt; для адресов в диапазоне, зарезервированном [RFC 4291 раздел 2.4], то есть для адресов в следующем формате:</target>
        </trans-unit>
        <trans-unit id="14217d50c79e4eb45c163835b69cd4e673a45e20" translate="yes" xml:space="preserve">
          <source>This method returns &lt;a href=&quot;../primitive.bool&quot;&gt;&lt;code&gt;true&lt;/code&gt;&lt;/a&gt; for site-local addresses as per &lt;a href=&quot;https://tools.ietf.org/html/rfc4291#section-2.5.7&quot;&gt;RFC 4291 section 2.5.7&lt;/a&gt;</source>
          <target state="translated">Этот метод возвращает значение &lt;a href=&quot;../primitive.bool&quot;&gt; &lt;code&gt;true&lt;/code&gt; &lt;/a&gt; для локальных адресов в соответствии с &lt;a href=&quot;https://tools.ietf.org/html/rfc4291#section-2.5.7&quot;&gt;RFC 4291, раздел 2.5.7.&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="c067946f55e22970a3dc70591f782f7bfd3be70c" translate="yes" xml:space="preserve">
          <source>This method returns &lt;a href=&quot;https://doc.rust-lang.org/nightly/std/primitive.bool.html&quot;&gt;&lt;code&gt;true&lt;/code&gt;&lt;/a&gt; for addresses in the range reserved by [RFC 4291 section 2.4], i.e. addresses with the following format:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1ac7dcf5283432feb1c671ca5dfa7bc7104e0a1d" translate="yes" xml:space="preserve">
          <source>This method returns &lt;a href=&quot;https://doc.rust-lang.org/nightly/std/primitive.bool.html&quot;&gt;&lt;code&gt;true&lt;/code&gt;&lt;/a&gt; for site-local addresses as per &lt;a href=&quot;https://tools.ietf.org/html/rfc4291#section-2.5.7&quot;&gt;RFC 4291 section 2.5.7&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="48c542fa498c19ba50cecb51c023284b67bf89ad" translate="yes" xml:space="preserve">
          <source>This method returns &lt;a href=&quot;option/enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt; if slice does not end with &lt;code&gt;suffix&lt;/code&gt;. Also it returns the original slice if &lt;code&gt;suffix&lt;/code&gt; is an empty slice</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="da5bb928bae82aca5b2fc0bf565da6017cb0d4d8" translate="yes" xml:space="preserve">
          <source>This method returns &lt;a href=&quot;option/enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt; if slice does not start with &lt;code&gt;prefix&lt;/code&gt;. Also it returns the original slice if &lt;code&gt;prefix&lt;/code&gt; is an empty slice.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8678f0273a7a7e566a6f4ee8c92fbd30439ee626" translate="yes" xml:space="preserve">
          <source>This method returns &lt;code&gt;Ok(())&lt;/code&gt; if the cell was empty and &lt;code&gt;Err(value)&lt;/code&gt; if it was full.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1fe438568aa64ab40ad3ae63a4e80c06e5f2d121" translate="yes" xml:space="preserve">
          <source>This method returns &lt;code&gt;true&lt;/code&gt; after iteration has finished:</source>
          <target state="translated">Этот метод возвращает &lt;code&gt;true&lt;/code&gt; после завершения итерации:</target>
        </trans-unit>
        <trans-unit id="a10727aefe2c0619a67b5c808cec5f4b8a1e7af5" translate="yes" xml:space="preserve">
          <source>This method returns an &lt;a href=&quot;../../cmp/enum.ordering&quot;&gt;&lt;code&gt;Ordering&lt;/code&gt;&lt;/a&gt; between &lt;code&gt;self&lt;/code&gt; and &lt;code&gt;other&lt;/code&gt;. &lt;a href=&quot;../../cmp/trait.ord#tymethod.cmp&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="553b97aa02f0558b1b0de2b63742a555e1d788b0" translate="yes" xml:space="preserve">
          <source>This method returns an &lt;a href=&quot;../cmp/enum.ordering&quot;&gt;&lt;code&gt;Ordering&lt;/code&gt;&lt;/a&gt; between &lt;code&gt;self&lt;/code&gt; and &lt;code&gt;other&lt;/code&gt;. &lt;a href=&quot;../cmp/trait.ord#tymethod.cmp&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1fe70a42b371f1df3da8be36396abdc2eaf19453" translate="yes" xml:space="preserve">
          <source>This method returns an &lt;a href=&quot;cmp/enum.ordering&quot;&gt;&lt;code&gt;Ordering&lt;/code&gt;&lt;/a&gt; between &lt;code&gt;self&lt;/code&gt; and &lt;code&gt;other&lt;/code&gt;. &lt;a href=&quot;cmp/trait.ord#tymethod.cmp&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="36badfc81f37e8dd9893bdb06702e1f5b7aef202" translate="yes" xml:space="preserve">
          <source>This method returns an &lt;a href=&quot;enum.ordering&quot;&gt;&lt;code&gt;Ordering&lt;/code&gt;&lt;/a&gt; between &lt;code&gt;self&lt;/code&gt; and &lt;code&gt;other&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c319c899ab4990e562735b3d21d0f6cd464c7156" translate="yes" xml:space="preserve">
          <source>This method returns an &lt;a href=&quot;enum.ordering&quot;&gt;&lt;code&gt;Ordering&lt;/code&gt;&lt;/a&gt; between &lt;code&gt;self&lt;/code&gt; and &lt;code&gt;other&lt;/code&gt;. &lt;a href=&quot;trait.ord#tymethod.cmp&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="da8759d1633206733343524980d7a489afd16956" translate="yes" xml:space="preserve">
          <source>This method returns an &lt;code&gt;Ordering&lt;/code&gt; between &lt;code&gt;self&lt;/code&gt; and &lt;code&gt;other&lt;/code&gt;.</source>
          <target state="translated">Этот метод возвращает &lt;code&gt;Ordering&lt;/code&gt; между &lt;code&gt;self&lt;/code&gt; и &lt;code&gt;other&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9f3bbc3554d60688630609ad13846c405e876fac" translate="yes" xml:space="preserve">
          <source>This method returns an &lt;code&gt;Ordering&lt;/code&gt; between &lt;code&gt;self&lt;/code&gt; and &lt;code&gt;other&lt;/code&gt;. &lt;a href=&quot;../../cmp/trait.ord#tymethod.cmp&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">Этот метод возвращает &lt;code&gt;Ordering&lt;/code&gt; между &lt;code&gt;self&lt;/code&gt; и &lt;code&gt;other&lt;/code&gt; . &lt;a href=&quot;../../cmp/trait.ord#tymethod.cmp&quot;&gt;Читать далее&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="e875552f6e4025920ca5a71d7c281b1fbfaaa2a8" translate="yes" xml:space="preserve">
          <source>This method returns an &lt;code&gt;Ordering&lt;/code&gt; between &lt;code&gt;self&lt;/code&gt; and &lt;code&gt;other&lt;/code&gt;. &lt;a href=&quot;../cmp/trait.ord#tymethod.cmp&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">Этот метод возвращает &lt;code&gt;Ordering&lt;/code&gt; между &lt;code&gt;self&lt;/code&gt; и &lt;code&gt;other&lt;/code&gt; . &lt;a href=&quot;../cmp/trait.ord#tymethod.cmp&quot;&gt;Читать далее&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="400399c6db28cb18bc3db2944eff105cd4fca3da" translate="yes" xml:space="preserve">
          <source>This method returns an &lt;code&gt;Ordering&lt;/code&gt; between &lt;code&gt;self&lt;/code&gt; and &lt;code&gt;other&lt;/code&gt;. &lt;a href=&quot;cmp/trait.ord#tymethod.cmp&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">Этот метод возвращает &lt;code&gt;Ordering&lt;/code&gt; между &lt;code&gt;self&lt;/code&gt; и &lt;code&gt;other&lt;/code&gt; . &lt;a href=&quot;cmp/trait.ord#tymethod.cmp&quot;&gt;Читать далее&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="1a47b24f63b5fe410c6da12441f9c98d2fe17c15" translate="yes" xml:space="preserve">
          <source>This method returns an &lt;code&gt;Ordering&lt;/code&gt; between &lt;code&gt;self&lt;/code&gt; and &lt;code&gt;other&lt;/code&gt;. &lt;a href=&quot;trait.ord#tymethod.cmp&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">Этот метод возвращает &lt;code&gt;Ordering&lt;/code&gt; между &lt;code&gt;self&lt;/code&gt; и &lt;code&gt;other&lt;/code&gt; . &lt;a href=&quot;trait.ord#tymethod.cmp&quot;&gt;Читать далее&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="c3cf087c16e29fe754de64f334036b96fe0b3931" translate="yes" xml:space="preserve">
          <source>This method returns an ordering between &lt;code&gt;self&lt;/code&gt; and &lt;code&gt;other&lt;/code&gt; values if one exists.</source>
          <target state="translated">Этот метод возвращает порядок между значениями &lt;code&gt;self&lt;/code&gt; и &lt;code&gt;other&lt;/code&gt; значениями, если они существуют.</target>
        </trans-unit>
        <trans-unit id="eb17b52a796e0693ad06487790fde93b26d1d781" translate="yes" xml:space="preserve">
          <source>This method returns an ordering between &lt;code&gt;self&lt;/code&gt; and &lt;code&gt;other&lt;/code&gt; values if one exists. &lt;a href=&quot;../../cmp/trait.partialord#tymethod.partial_cmp&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">Этот метод возвращает порядок между значениями &lt;code&gt;self&lt;/code&gt; и &lt;code&gt;other&lt;/code&gt; значениями, если они существуют. &lt;a href=&quot;../../cmp/trait.partialord#tymethod.partial_cmp&quot;&gt;Читать далее&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="39953b189e90eb45e12641b5213bac17fb6a067f" translate="yes" xml:space="preserve">
          <source>This method returns an ordering between &lt;code&gt;self&lt;/code&gt; and &lt;code&gt;other&lt;/code&gt; values if one exists. &lt;a href=&quot;../cmp/trait.partialord#tymethod.partial_cmp&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">Этот метод возвращает порядок между значениями &lt;code&gt;self&lt;/code&gt; и &lt;code&gt;other&lt;/code&gt; значениями, если они существуют. &lt;a href=&quot;../cmp/trait.partialord#tymethod.partial_cmp&quot;&gt;Читать далее&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="a426df736d2450e1483768eb842876560c3cb8d7" translate="yes" xml:space="preserve">
          <source>This method returns an ordering between &lt;code&gt;self&lt;/code&gt; and &lt;code&gt;other&lt;/code&gt; values if one exists. &lt;a href=&quot;cmp/trait.partialord#tymethod.partial_cmp&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">Этот метод возвращает порядок между значениями &lt;code&gt;self&lt;/code&gt; и &lt;code&gt;other&lt;/code&gt; значениями, если они существуют. &lt;a href=&quot;cmp/trait.partialord#tymethod.partial_cmp&quot;&gt;Читать далее&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="d64233d3af8194ec0eefc11c727f80c62d14630a" translate="yes" xml:space="preserve">
          <source>This method returns an ordering between &lt;code&gt;self&lt;/code&gt; and &lt;code&gt;other&lt;/code&gt; values if one exists. &lt;a href=&quot;trait.partialord#tymethod.partial_cmp&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">Этот метод возвращает порядок между значениями &lt;code&gt;self&lt;/code&gt; и &lt;code&gt;other&lt;/code&gt; значениями, если они существуют. &lt;a href=&quot;trait.partialord#tymethod.partial_cmp&quot;&gt;Читать далее&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="edb583eeb291a512bd3d2447d1fbe080bc3b9dce" translate="yes" xml:space="preserve">
          <source>This method should generally not be invoked manually, but rather through the &lt;a href=&quot;../macro.write&quot;&gt;&lt;code&gt;write!&lt;/code&gt;&lt;/a&gt; macro itself.</source>
          <target state="translated">Этот метод, как правило, следует вызывать не вручную, а через команду &lt;a href=&quot;../macro.write&quot;&gt; &lt;code&gt;write!&lt;/code&gt; &lt;/a&gt;сам макрос.</target>
        </trans-unit>
        <trans-unit id="d7174476c42e976c470e5d3d833837447fe7b624" translate="yes" xml:space="preserve">
          <source>This method splits the slice into three distinct slices: prefix, correctly aligned middle slice of a new type, and the suffix slice. The method does a best effort to make the middle slice the greatest length possible for a given type and input slice, but only your algorithm's performance should depend on that, not its correctness.</source>
          <target state="translated">Этот метод разделяет фрагмент на три различных фрагмента:префикс,правильно выровненный средний фрагмент нового типа и суффиксный фрагмент.Метод делает все возможное,чтобы средний срез имел наибольшую возможную длину для данного типа и входного среза,но от этого должна зависеть только производительность Вашего алгоритма,а не его корректность.</target>
        </trans-unit>
        <trans-unit id="a7dca763f7ea1b34a0cad9b954868418d78e506c" translate="yes" xml:space="preserve">
          <source>This method splits the slice into three distinct slices: prefix, correctly aligned middle slice of a new type, and the suffix slice. The method may make the middle slice the greatest length possible for a given type and input slice, but only your algorithm's performance should depend on that, not its correctness. It is permissible for all of the input data to be returned as the prefix or suffix slice.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8000abb209a936f78ade63de708f2749dd5748c7" translate="yes" xml:space="preserve">
          <source>This method tests for &lt;code&gt;!=&lt;/code&gt;.</source>
          <target state="translated">Этот метод проверяет &lt;code&gt;!=&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3639f2a22177e5f40d5314d575e638c54018960a" translate="yes" xml:space="preserve">
          <source>This method tests for &lt;code&gt;self&lt;/code&gt; and &lt;code&gt;other&lt;/code&gt; values to be equal, and is used by &lt;code&gt;==&lt;/code&gt;.</source>
          <target state="translated">Этот метод проверяет равенство значений &lt;code&gt;self&lt;/code&gt; и &lt;code&gt;other&lt;/code&gt; значений и используется &lt;code&gt;==&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e3ea7ba813a098b9b6ae43b0aee731d0092913bf" translate="yes" xml:space="preserve">
          <source>This method tests for &lt;code&gt;self&lt;/code&gt; and &lt;code&gt;other&lt;/code&gt; values to be equal, and is used by &lt;code&gt;==&lt;/code&gt;. &lt;a href=&quot;../../../cmp/trait.partialeq#tymethod.eq&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f00abfa17fbf62bab913260c77c4736307dd6b08" translate="yes" xml:space="preserve">
          <source>This method tests for &lt;code&gt;self&lt;/code&gt; and &lt;code&gt;other&lt;/code&gt; values to be equal, and is used by &lt;code&gt;==&lt;/code&gt;. &lt;a href=&quot;../../cmp/trait.partialeq#tymethod.eq&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">Этот метод проверяет равенство значений &lt;code&gt;self&lt;/code&gt; и &lt;code&gt;other&lt;/code&gt; значений и используется &lt;code&gt;==&lt;/code&gt; . &lt;a href=&quot;../../cmp/trait.partialeq#tymethod.eq&quot;&gt;Читать далее&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="c257c51217cc2c43c24273fbc2f10164037dd5b1" translate="yes" xml:space="preserve">
          <source>This method tests for &lt;code&gt;self&lt;/code&gt; and &lt;code&gt;other&lt;/code&gt; values to be equal, and is used by &lt;code&gt;==&lt;/code&gt;. &lt;a href=&quot;../cmp/trait.partialeq#tymethod.eq&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">Этот метод проверяет равенство значений &lt;code&gt;self&lt;/code&gt; и &lt;code&gt;other&lt;/code&gt; значений и используется &lt;code&gt;==&lt;/code&gt; . &lt;a href=&quot;../cmp/trait.partialeq#tymethod.eq&quot;&gt;Читать далее&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="34550195d18fa1542599bef9324d74efad99aeb1" translate="yes" xml:space="preserve">
          <source>This method tests for &lt;code&gt;self&lt;/code&gt; and &lt;code&gt;other&lt;/code&gt; values to be equal, and is used by &lt;code&gt;==&lt;/code&gt;. &lt;a href=&quot;cmp/trait.partialeq#tymethod.eq&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">Этот метод проверяет равенство значений &lt;code&gt;self&lt;/code&gt; и &lt;code&gt;other&lt;/code&gt; значений и используется &lt;code&gt;==&lt;/code&gt; . &lt;a href=&quot;cmp/trait.partialeq#tymethod.eq&quot;&gt;Читать далее&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="d32084f8ce776d9a529be0f1da6ec9ca22e44396" translate="yes" xml:space="preserve">
          <source>This method tests for &lt;code&gt;self&lt;/code&gt; and &lt;code&gt;other&lt;/code&gt; values to be equal, and is used by &lt;code&gt;==&lt;/code&gt;. &lt;a href=&quot;trait.partialeq#tymethod.eq&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">Этот метод проверяет равенство значений &lt;code&gt;self&lt;/code&gt; и &lt;code&gt;other&lt;/code&gt; значений и используется &lt;code&gt;==&lt;/code&gt; . &lt;a href=&quot;trait.partialeq#tymethod.eq&quot;&gt;Читать далее&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="9893b74b381c1707e88afd0a7ed6401e06b38424" translate="yes" xml:space="preserve">
          <source>This method tests greater than (for &lt;code&gt;self&lt;/code&gt; and &lt;code&gt;other&lt;/code&gt;) and is used by the &lt;code&gt;&amp;gt;&lt;/code&gt; operator.</source>
          <target state="translated">Этот метод проверяет больше чем (для &lt;code&gt;self&lt;/code&gt; и &lt;code&gt;other&lt;/code&gt; ) и используется оператором &lt;code&gt;&amp;gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9be75e39e05fc52a961a6f8a30bebafa3abc619e" translate="yes" xml:space="preserve">
          <source>This method tests greater than (for &lt;code&gt;self&lt;/code&gt; and &lt;code&gt;other&lt;/code&gt;) and is used by the &lt;code&gt;&amp;gt;&lt;/code&gt; operator. &lt;a href=&quot;../../cmp/trait.partialord#method.gt&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">Этот метод проверяет больше чем (для &lt;code&gt;self&lt;/code&gt; и &lt;code&gt;other&lt;/code&gt; ) и используется оператором &lt;code&gt;&amp;gt;&lt;/code&gt; . &lt;a href=&quot;../../cmp/trait.partialord#method.gt&quot;&gt;Читать далее&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="8b084733b90b43f4725bbd31294cb1f36404ce0a" translate="yes" xml:space="preserve">
          <source>This method tests greater than (for &lt;code&gt;self&lt;/code&gt; and &lt;code&gt;other&lt;/code&gt;) and is used by the &lt;code&gt;&amp;gt;&lt;/code&gt; operator. &lt;a href=&quot;../cmp/trait.partialord#method.gt&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">Этот метод проверяет больше чем (для &lt;code&gt;self&lt;/code&gt; и &lt;code&gt;other&lt;/code&gt; ) и используется оператором &lt;code&gt;&amp;gt;&lt;/code&gt; . &lt;a href=&quot;../cmp/trait.partialord#method.gt&quot;&gt;Читать далее&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="44184bc5bd845c73d3a6bdc521b7927b64cd5369" translate="yes" xml:space="preserve">
          <source>This method tests greater than (for &lt;code&gt;self&lt;/code&gt; and &lt;code&gt;other&lt;/code&gt;) and is used by the &lt;code&gt;&amp;gt;&lt;/code&gt; operator. &lt;a href=&quot;cmp/trait.partialord#method.gt&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">Этот метод проверяет больше чем (для &lt;code&gt;self&lt;/code&gt; и &lt;code&gt;other&lt;/code&gt; ) и используется оператором &lt;code&gt;&amp;gt;&lt;/code&gt; . &lt;a href=&quot;cmp/trait.partialord#method.gt&quot;&gt;Читать далее&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="8eec657a4246dd487288b986e3d57dfd9657b208" translate="yes" xml:space="preserve">
          <source>This method tests greater than (for &lt;code&gt;self&lt;/code&gt; and &lt;code&gt;other&lt;/code&gt;) and is used by the &lt;code&gt;&amp;gt;&lt;/code&gt; operator. &lt;a href=&quot;trait.partialord#method.gt&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">Этот метод проверяет больше чем (для &lt;code&gt;self&lt;/code&gt; и &lt;code&gt;other&lt;/code&gt; ) и используется оператором &lt;code&gt;&amp;gt;&lt;/code&gt; . &lt;a href=&quot;trait.partialord#method.gt&quot;&gt;Читать далее&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="0eabc442f100ec2b7e353c049aaaf4ca623d1f2c" translate="yes" xml:space="preserve">
          <source>This method tests greater than or equal to (for &lt;code&gt;self&lt;/code&gt; and &lt;code&gt;other&lt;/code&gt;) and is used by the &lt;code&gt;&amp;gt;=&lt;/code&gt; operator.</source>
          <target state="translated">Этот метод проверяет больше или равно (для &lt;code&gt;self&lt;/code&gt; и &lt;code&gt;other&lt;/code&gt; ) и используется оператором &lt;code&gt;&amp;gt;=&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4194eb24934481036250e733ab18937ab48da677" translate="yes" xml:space="preserve">
          <source>This method tests greater than or equal to (for &lt;code&gt;self&lt;/code&gt; and &lt;code&gt;other&lt;/code&gt;) and is used by the &lt;code&gt;&amp;gt;=&lt;/code&gt; operator. &lt;a href=&quot;../../cmp/trait.partialord#method.ge&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">Этот метод проверяет больше или равно (для &lt;code&gt;self&lt;/code&gt; и &lt;code&gt;other&lt;/code&gt; ) и используется оператором &lt;code&gt;&amp;gt;=&lt;/code&gt; . &lt;a href=&quot;../../cmp/trait.partialord#method.ge&quot;&gt;Читать далее&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="219eec29ea3645fe37ee0a3de43c26a2abe5b61f" translate="yes" xml:space="preserve">
          <source>This method tests greater than or equal to (for &lt;code&gt;self&lt;/code&gt; and &lt;code&gt;other&lt;/code&gt;) and is used by the &lt;code&gt;&amp;gt;=&lt;/code&gt; operator. &lt;a href=&quot;../cmp/trait.partialord#method.ge&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">Этот метод проверяет больше или равно (для &lt;code&gt;self&lt;/code&gt; и &lt;code&gt;other&lt;/code&gt; ) и используется оператором &lt;code&gt;&amp;gt;=&lt;/code&gt; . &lt;a href=&quot;../cmp/trait.partialord#method.ge&quot;&gt;Читать далее&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="a7907168214aeaea1aa4db413b937e0f747bd41c" translate="yes" xml:space="preserve">
          <source>This method tests greater than or equal to (for &lt;code&gt;self&lt;/code&gt; and &lt;code&gt;other&lt;/code&gt;) and is used by the &lt;code&gt;&amp;gt;=&lt;/code&gt; operator. &lt;a href=&quot;cmp/trait.partialord#method.ge&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">Этот метод проверяет больше или равно (для &lt;code&gt;self&lt;/code&gt; и &lt;code&gt;other&lt;/code&gt; ) и используется оператором &lt;code&gt;&amp;gt;=&lt;/code&gt; . &lt;a href=&quot;cmp/trait.partialord#method.ge&quot;&gt;Читать далее&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="e579d59fed2657492555041f61545aa7206f59b6" translate="yes" xml:space="preserve">
          <source>This method tests greater than or equal to (for &lt;code&gt;self&lt;/code&gt; and &lt;code&gt;other&lt;/code&gt;) and is used by the &lt;code&gt;&amp;gt;=&lt;/code&gt; operator. &lt;a href=&quot;trait.partialord#method.ge&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">Этот метод проверяет больше или равно (для &lt;code&gt;self&lt;/code&gt; и &lt;code&gt;other&lt;/code&gt; ) и используется оператором &lt;code&gt;&amp;gt;=&lt;/code&gt; . &lt;a href=&quot;trait.partialord#method.ge&quot;&gt;Читать далее&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="c0e789163efc5086c683b5a1f62c9a3bb50e4538" translate="yes" xml:space="preserve">
          <source>This method tests less than (for &lt;code&gt;self&lt;/code&gt; and &lt;code&gt;other&lt;/code&gt;) and is used by the &lt;code&gt;&amp;lt;&lt;/code&gt; operator.</source>
          <target state="translated">Этот метод проверяет меньше чем (для &lt;code&gt;self&lt;/code&gt; и &lt;code&gt;other&lt;/code&gt; ) и используется оператором &lt;code&gt;&amp;lt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a9a38093c98e8f8478fc7a4cb9a47c1ad908df47" translate="yes" xml:space="preserve">
          <source>This method tests less than (for &lt;code&gt;self&lt;/code&gt; and &lt;code&gt;other&lt;/code&gt;) and is used by the &lt;code&gt;&amp;lt;&lt;/code&gt; operator. &lt;a href=&quot;../../cmp/trait.partialord#method.lt&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">Этот метод проверяет меньше чем (для &lt;code&gt;self&lt;/code&gt; и &lt;code&gt;other&lt;/code&gt; ) и используется оператором &lt;code&gt;&amp;lt;&lt;/code&gt; . &lt;a href=&quot;../../cmp/trait.partialord#method.lt&quot;&gt;Читать далее&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="d167afca39913e71e4062a05ae7a9d99838896ab" translate="yes" xml:space="preserve">
          <source>This method tests less than (for &lt;code&gt;self&lt;/code&gt; and &lt;code&gt;other&lt;/code&gt;) and is used by the &lt;code&gt;&amp;lt;&lt;/code&gt; operator. &lt;a href=&quot;../cmp/trait.partialord#method.lt&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">Этот метод проверяет меньше чем (для &lt;code&gt;self&lt;/code&gt; и &lt;code&gt;other&lt;/code&gt; ) и используется оператором &lt;code&gt;&amp;lt;&lt;/code&gt; . &lt;a href=&quot;../cmp/trait.partialord#method.lt&quot;&gt;Читать далее&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="8ebc7cc22118ac04d1f984d545d5be0d85818a1e" translate="yes" xml:space="preserve">
          <source>This method tests less than (for &lt;code&gt;self&lt;/code&gt; and &lt;code&gt;other&lt;/code&gt;) and is used by the &lt;code&gt;&amp;lt;&lt;/code&gt; operator. &lt;a href=&quot;cmp/trait.partialord#method.lt&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">Этот метод проверяет меньше чем (для &lt;code&gt;self&lt;/code&gt; и &lt;code&gt;other&lt;/code&gt; ) и используется оператором &lt;code&gt;&amp;lt;&lt;/code&gt; . &lt;a href=&quot;cmp/trait.partialord#method.lt&quot;&gt;Читать далее&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="54945ad3f8cac4a154fb7b9e35518b30ae999d4d" translate="yes" xml:space="preserve">
          <source>This method tests less than (for &lt;code&gt;self&lt;/code&gt; and &lt;code&gt;other&lt;/code&gt;) and is used by the &lt;code&gt;&amp;lt;&lt;/code&gt; operator. &lt;a href=&quot;trait.partialord#method.lt&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">Этот метод проверяет меньше чем (для &lt;code&gt;self&lt;/code&gt; и &lt;code&gt;other&lt;/code&gt; ) и используется оператором &lt;code&gt;&amp;lt;&lt;/code&gt; . &lt;a href=&quot;trait.partialord#method.lt&quot;&gt;Читать далее&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="d161a6ff3e691349ec054ac0d4002d49a30e7893" translate="yes" xml:space="preserve">
          <source>This method tests less than or equal to (for &lt;code&gt;self&lt;/code&gt; and &lt;code&gt;other&lt;/code&gt;) and is used by the &lt;code&gt;&amp;lt;=&lt;/code&gt; operator.</source>
          <target state="translated">Этот метод проверяет значение, меньшее или равное (для &lt;code&gt;self&lt;/code&gt; и &lt;code&gt;other&lt;/code&gt; ) и используется оператором &lt;code&gt;&amp;lt;=&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="aadf89f483a504081f46ca5ef3749d0af43a4387" translate="yes" xml:space="preserve">
          <source>This method tests less than or equal to (for &lt;code&gt;self&lt;/code&gt; and &lt;code&gt;other&lt;/code&gt;) and is used by the &lt;code&gt;&amp;lt;=&lt;/code&gt; operator. &lt;a href=&quot;../../cmp/trait.partialord#method.le&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">Этот метод проверяет значение, меньшее или равное (для &lt;code&gt;self&lt;/code&gt; и &lt;code&gt;other&lt;/code&gt; ) и используется оператором &lt;code&gt;&amp;lt;=&lt;/code&gt; . &lt;a href=&quot;../../cmp/trait.partialord#method.le&quot;&gt;Читать далее&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="ddb1ab74197bbadea31b206cbb3f4c8f2c4d9f37" translate="yes" xml:space="preserve">
          <source>This method tests less than or equal to (for &lt;code&gt;self&lt;/code&gt; and &lt;code&gt;other&lt;/code&gt;) and is used by the &lt;code&gt;&amp;lt;=&lt;/code&gt; operator. &lt;a href=&quot;../cmp/trait.partialord#method.le&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">Этот метод проверяет значение, меньшее или равное (для &lt;code&gt;self&lt;/code&gt; и &lt;code&gt;other&lt;/code&gt; ) и используется оператором &lt;code&gt;&amp;lt;=&lt;/code&gt; . &lt;a href=&quot;../cmp/trait.partialord#method.le&quot;&gt;Читать далее&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="db00fc514ef8b2e5769c8d739b13605dcfb91f42" translate="yes" xml:space="preserve">
          <source>This method tests less than or equal to (for &lt;code&gt;self&lt;/code&gt; and &lt;code&gt;other&lt;/code&gt;) and is used by the &lt;code&gt;&amp;lt;=&lt;/code&gt; operator. &lt;a href=&quot;cmp/trait.partialord#method.le&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">Этот метод проверяет значение, меньшее или равное (для &lt;code&gt;self&lt;/code&gt; и &lt;code&gt;other&lt;/code&gt; ) и используется оператором &lt;code&gt;&amp;lt;=&lt;/code&gt; . &lt;a href=&quot;cmp/trait.partialord#method.le&quot;&gt;Читать далее&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="bca462ad1eb0c753d442b14b7fe002228f03d1ee" translate="yes" xml:space="preserve">
          <source>This method tests less than or equal to (for &lt;code&gt;self&lt;/code&gt; and &lt;code&gt;other&lt;/code&gt;) and is used by the &lt;code&gt;&amp;lt;=&lt;/code&gt; operator. &lt;a href=&quot;trait.partialord#method.le&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">Этот метод проверяет значение, меньшее или равное (для &lt;code&gt;self&lt;/code&gt; и &lt;code&gt;other&lt;/code&gt; ) и используется оператором &lt;code&gt;&amp;lt;=&lt;/code&gt; . &lt;a href=&quot;trait.partialord#method.le&quot;&gt;Читать далее&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="5f2ae443e73d5f88ef06a1d6b529c7d18527f78a" translate="yes" xml:space="preserve">
          <source>This method uses &lt;a href=&quot;../default/trait.default&quot;&gt;&lt;code&gt;Default&lt;/code&gt;&lt;/a&gt; to create new values on every push. If you'd rather &lt;a href=&quot;../clone/trait.clone&quot;&gt;&lt;code&gt;Clone&lt;/code&gt;&lt;/a&gt; a given value, use &lt;a href=&quot;#method.resize&quot;&gt;&lt;code&gt;resize&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Этот метод использует &lt;a href=&quot;../default/trait.default&quot;&gt; &lt;code&gt;Default&lt;/code&gt; &lt;/a&gt; для создания новых значений при каждом нажатии. Если вы предпочитаете &lt;a href=&quot;../clone/trait.clone&quot;&gt; &lt;code&gt;Clone&lt;/code&gt; &lt;/a&gt; заданное значение, используйте &lt;a href=&quot;#method.resize&quot;&gt; &lt;code&gt;resize&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="1dc00be165ac3a4a63601e65e376c360363d264c" translate="yes" xml:space="preserve">
          <source>This method uses &lt;a href=&quot;../default/trait.default&quot;&gt;&lt;code&gt;Default&lt;/code&gt;&lt;/a&gt; to create new values on every push. If you'd rather &lt;a href=&quot;../clone/trait.clone&quot;&gt;&lt;code&gt;Clone&lt;/code&gt;&lt;/a&gt; a given value, use &lt;a href=&quot;struct.vec#method.resize&quot;&gt;&lt;code&gt;resize&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a5ffc4fb20de54f6e75ded6f37d7e6542ba4dcb3" translate="yes" xml:space="preserve">
          <source>This method uses a closure to create new values on every push. If you'd rather &lt;a href=&quot;../clone/trait.clone&quot;&gt;&lt;code&gt;Clone&lt;/code&gt;&lt;/a&gt; a given value, use &lt;a href=&quot;#method.resize&quot;&gt;&lt;code&gt;resize&lt;/code&gt;&lt;/a&gt;. If you want to use the &lt;a href=&quot;../default/trait.default&quot;&gt;&lt;code&gt;Default&lt;/code&gt;&lt;/a&gt; trait to generate values, you can pass &lt;a href=&quot;../default/trait.default#tymethod.default&quot;&gt;&lt;code&gt;Default::default()&lt;/code&gt;&lt;/a&gt; as the second argument.</source>
          <target state="translated">Этот метод использует закрытие для создания новых значений при каждом нажатии. Если вы предпочитаете &lt;a href=&quot;../clone/trait.clone&quot;&gt; &lt;code&gt;Clone&lt;/code&gt; &lt;/a&gt; заданное значение, используйте &lt;a href=&quot;#method.resize&quot;&gt; &lt;code&gt;resize&lt;/code&gt; &lt;/a&gt; . Если вы хотите использовать свойство &lt;a href=&quot;../default/trait.default&quot;&gt; &lt;code&gt;Default&lt;/code&gt; &lt;/a&gt; для генерации значений, вы можете передать &lt;a href=&quot;../default/trait.default#tymethod.default&quot;&gt; &lt;code&gt;Default::default()&lt;/code&gt; &lt;/a&gt; в качестве второго аргумента.</target>
        </trans-unit>
        <trans-unit id="94cb38be3cc225054f996a63889a25410328f00e" translate="yes" xml:space="preserve">
          <source>This method uses a closure to create new values on every push. If you'd rather &lt;a href=&quot;../clone/trait.clone&quot;&gt;&lt;code&gt;Clone&lt;/code&gt;&lt;/a&gt; a given value, use &lt;a href=&quot;struct.vec#method.resize&quot;&gt;&lt;code&gt;Vec::resize&lt;/code&gt;&lt;/a&gt;. If you want to use the &lt;a href=&quot;../default/trait.default&quot;&gt;&lt;code&gt;Default&lt;/code&gt;&lt;/a&gt; trait to generate values, you can pass &lt;a href=&quot;../default/trait.default#tymethod.default&quot;&gt;&lt;code&gt;Default::default&lt;/code&gt;&lt;/a&gt; as the second argument.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6e8aba760b1e58965c26c5247df8d78a97a2b7d9" translate="yes" xml:space="preserve">
          <source>This method validates the format defined in the RFC and won't recognize the following addresses such as &lt;code&gt;fe80:0:0:1::&lt;/code&gt; or &lt;code&gt;fe81::&lt;/code&gt; as unicast link-local addresses for example. If you need a less strict validation use &lt;a href=&quot;struct.ipv6addr#method.is_unicast_link_local&quot;&gt;&lt;code&gt;Ipv6Addr::is_unicast_link_local()&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="57f44223f055f4bc85ef6eebc9a26838b98e07df" translate="yes" xml:space="preserve">
          <source>This method validates the format defined in the RFC and won't recognize the following addresses such as &lt;code&gt;fe80:0:0:1::&lt;/code&gt; or &lt;code&gt;fe81::&lt;/code&gt; as unicast link-local addresses for example. If you need a less strict validation use &lt;a href=&quot;struct.ipv6addr#method.is_unicast_link_local&quot;&gt;&lt;code&gt;is_unicast_link_local()&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">Этот метод проверяет формат, определенный в RFC, и не распознает следующие адреса, такие как &lt;code&gt;fe80:0:0:1::&lt;/code&gt; или &lt;code&gt;fe81::&lt;/code&gt; как локальные для одноадресной передачи адреса, например. Если вам нужна менее строгая проверка, используйте вместо &lt;a href=&quot;struct.ipv6addr#method.is_unicast_link_local&quot;&gt; &lt;code&gt;is_unicast_link_local()&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="34a9aeb12096c73821e3d3f2146e3bcd68d312a7" translate="yes" xml:space="preserve">
          <source>This method will be deprecated in favor of the identically-named inherent methods on &lt;code&gt;u8&lt;/code&gt;, &lt;code&gt;char&lt;/code&gt;, &lt;code&gt;[u8]&lt;/code&gt; and &lt;code&gt;str&lt;/code&gt;.</source>
          <target state="translated">Этот метод будет устаревшим и будет &lt;code&gt;u8&lt;/code&gt; внутренними методами с одинаковыми именами в u8 , &lt;code&gt;char&lt;/code&gt; , &lt;code&gt;[u8]&lt;/code&gt; и &lt;code&gt;str&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="71c3fa499cb951e39a31bf79d7f47ca94405dd75" translate="yes" xml:space="preserve">
          <source>This method will be removed soon.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dab63bf4ac92d7a8265610c22503839aea1e5938" translate="yes" xml:space="preserve">
          <source>This method will block the calling thread if another initialization routine is currently running.</source>
          <target state="translated">Этот метод будет блокировать вызывающий поток,если в данный момент выполняется другая инициализационная рутина.</target>
        </trans-unit>
        <trans-unit id="fd65ab04cca83f42050b2936debdcfa64855e2e3" translate="yes" xml:space="preserve">
          <source>This method will call &lt;a href=&quot;trait.iterator#tymethod.next&quot;&gt;&lt;code&gt;next&lt;/code&gt;&lt;/a&gt; repeatedly until &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt; is encountered, returning the number of times it saw &lt;a href=&quot;../option/enum.option#variant.Some&quot;&gt;&lt;code&gt;Some&lt;/code&gt;&lt;/a&gt;. Note that &lt;a href=&quot;trait.iterator#tymethod.next&quot;&gt;&lt;code&gt;next&lt;/code&gt;&lt;/a&gt; has to be called at least once even if the iterator does not have any elements.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4dcd7df93995d5669f9a19d9090b19b5d2473592" translate="yes" xml:space="preserve">
          <source>This method will continuously call &lt;a href=&quot;#tymethod.write&quot;&gt;&lt;code&gt;write&lt;/code&gt;&lt;/a&gt; until there is no more data to be written or an error of non-&lt;a href=&quot;enum.errorkind#variant.Interrupted&quot;&gt;&lt;code&gt;ErrorKind::Interrupted&lt;/code&gt;&lt;/a&gt; kind is returned. This method will not return until the entire buffer has been successfully written or such an error occurs. The first error that is not of &lt;a href=&quot;enum.errorkind#variant.Interrupted&quot;&gt;&lt;code&gt;ErrorKind::Interrupted&lt;/code&gt;&lt;/a&gt; kind generated from this method will be returned.</source>
          <target state="translated">Этот метод будет постоянно вызывать &lt;a href=&quot;#tymethod.write&quot;&gt; &lt;code&gt;write&lt;/code&gt; &lt;/a&gt; до тех пор, пока не закончатся данные для записи или не будет возвращена ошибка не &lt;a href=&quot;enum.errorkind#variant.Interrupted&quot;&gt; &lt;code&gt;ErrorKind::Interrupted&lt;/code&gt; &lt;/a&gt; . Этот метод не вернется, пока не будет успешно записан весь буфер или пока не возникнет такая ошибка. Будет возвращена первая ошибка не типа &lt;a href=&quot;enum.errorkind#variant.Interrupted&quot;&gt; &lt;code&gt;ErrorKind::Interrupted&lt;/code&gt; &lt;/a&gt; сгенерированная этим методом.</target>
        </trans-unit>
        <trans-unit id="0bf4855a0328106cbe0baa3671aad93298aa630b" translate="yes" xml:space="preserve">
          <source>This method will continuously call &lt;a href=&quot;#tymethod.write_at&quot;&gt;&lt;code&gt;write_at&lt;/code&gt;&lt;/a&gt; until there is no more data to be written or an error of non-&lt;a href=&quot;../../../io/enum.errorkind#variant.Interrupted&quot;&gt;&lt;code&gt;ErrorKind::Interrupted&lt;/code&gt;&lt;/a&gt; kind is returned. This method will not return until the entire buffer has been successfully written or such an error occurs. The first error that is not of &lt;a href=&quot;../../../io/enum.errorkind#variant.Interrupted&quot;&gt;&lt;code&gt;ErrorKind::Interrupted&lt;/code&gt;&lt;/a&gt; kind generated from this method will be returned.</source>
          <target state="translated">Этот метод будет постоянно вызывать &lt;a href=&quot;#tymethod.write_at&quot;&gt; &lt;code&gt;write_at&lt;/code&gt; &lt;/a&gt; до тех пор, пока не закончатся данные для записи или не будет возвращена ошибка не &lt;a href=&quot;../../../io/enum.errorkind#variant.Interrupted&quot;&gt; &lt;code&gt;ErrorKind::Interrupted&lt;/code&gt; &lt;/a&gt; . Этот метод не вернется, пока не будет успешно записан весь буфер или пока не возникнет такая ошибка. Будет возвращена первая ошибка не типа &lt;a href=&quot;../../../io/enum.errorkind#variant.Interrupted&quot;&gt; &lt;code&gt;ErrorKind::Interrupted&lt;/code&gt; &lt;/a&gt; сгенерированная этим методом.</target>
        </trans-unit>
        <trans-unit id="34bd7dd9f2f6fd228fe4ece502dea492de39f939" translate="yes" xml:space="preserve">
          <source>This method will continuously call &lt;a href=&quot;trait.fileext#tymethod.write_at&quot;&gt;&lt;code&gt;write_at&lt;/code&gt;&lt;/a&gt; until there is no more data to be written or an error of non-&lt;a href=&quot;../../../io/enum.errorkind#variant.Interrupted&quot;&gt;&lt;code&gt;io::ErrorKind::Interrupted&lt;/code&gt;&lt;/a&gt; kind is returned. This method will not return until the entire buffer has been successfully written or such an error occurs. The first error that is not of &lt;a href=&quot;../../../io/enum.errorkind#variant.Interrupted&quot;&gt;&lt;code&gt;io::ErrorKind::Interrupted&lt;/code&gt;&lt;/a&gt; kind generated from this method will be returned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="59d4273ac7a3ba1d7a87ecc5115120efa61d6d44" translate="yes" xml:space="preserve">
          <source>This method will continuously call &lt;a href=&quot;trait.write#method.write_vectored&quot;&gt;&lt;code&gt;write_vectored&lt;/code&gt;&lt;/a&gt; until there is no more data to be written or an error of non-&lt;a href=&quot;enum.errorkind#variant.Interrupted&quot;&gt;&lt;code&gt;ErrorKind::Interrupted&lt;/code&gt;&lt;/a&gt; kind is returned. This method will not return until all buffers have been successfully written or such an error occurs. The first error that is not of &lt;a href=&quot;enum.errorkind#variant.Interrupted&quot;&gt;&lt;code&gt;ErrorKind::Interrupted&lt;/code&gt;&lt;/a&gt; kind generated from this method will be returned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d3edbd42d79d3d4c4b13caf2b0a59c3d785c0e55" translate="yes" xml:space="preserve">
          <source>This method will continuously call &lt;a href=&quot;trait.write#tymethod.write&quot;&gt;&lt;code&gt;write&lt;/code&gt;&lt;/a&gt; until there is no more data to be written or an error of non-&lt;a href=&quot;enum.errorkind#variant.Interrupted&quot;&gt;&lt;code&gt;ErrorKind::Interrupted&lt;/code&gt;&lt;/a&gt; kind is returned. This method will not return until the entire buffer has been successfully written or such an error occurs. The first error that is not of &lt;a href=&quot;enum.errorkind#variant.Interrupted&quot;&gt;&lt;code&gt;ErrorKind::Interrupted&lt;/code&gt;&lt;/a&gt; kind generated from this method will be returned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b531b20d0eb83c8a34e8a69001999cab52351ebf" translate="yes" xml:space="preserve">
          <source>This method will currently always return &lt;a href=&quot;../option/enum.option#variant.Some&quot;&gt;&lt;code&gt;Some&lt;/code&gt;&lt;/a&gt;, but this may change in future versions.</source>
          <target state="translated">В настоящее время этот метод всегда будет возвращать &lt;a href=&quot;../option/enum.option#variant.Some&quot;&gt; &lt;code&gt;Some&lt;/code&gt; &lt;/a&gt; , но это может измениться в будущих версиях.</target>
        </trans-unit>
        <trans-unit id="f5ce2db6ab8281674bdcae7d5e2f97235788a1d6" translate="yes" xml:space="preserve">
          <source>This method will eagerly skip &lt;code&gt;n&lt;/code&gt; elements by calling &lt;a href=&quot;trait.iterator#tymethod.next&quot;&gt;&lt;code&gt;next&lt;/code&gt;&lt;/a&gt; up to &lt;code&gt;n&lt;/code&gt; times until &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt; is encountered.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2170c54e7e7e211e3d0e2c65e377ae8bcaea7ac1" translate="yes" xml:space="preserve">
          <source>This method will ensure that any current waiters on the condition variable are awoken. Calls to &lt;code&gt;notify_all()&lt;/code&gt; are not buffered in any way.</source>
          <target state="translated">Этот метод гарантирует, что все текущие ожидающие в переменной состояния будут разбужены. Вызовы &lt;code&gt;notify_all()&lt;/code&gt; никаким образом не буферизуются.</target>
        </trans-unit>
        <trans-unit id="149968b75a735130b9e849f252f39d4aeeb3370e" translate="yes" xml:space="preserve">
          <source>This method will evaluate the iterator until it returns &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt;. While doing so, it keeps track of the current element. After &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt; is returned, &lt;code&gt;last()&lt;/code&gt; will then return the last element it saw.</source>
          <target state="translated">Этот метод будет оценивать итератор, пока он не вернет &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt; &lt;code&gt;None&lt;/code&gt; &lt;/a&gt; . При этом он отслеживает текущий элемент. После возврата &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt; &lt;code&gt;None&lt;/code&gt; &lt;/a&gt; &lt;code&gt;last()&lt;/code&gt; вернет последний элемент, который он видел.</target>
        </trans-unit>
        <trans-unit id="60132e29639954faf0b02a7c1a61ca490fca81f1" translate="yes" xml:space="preserve">
          <source>This method will evaluate the iterator until its &lt;a href=&quot;#tymethod.next&quot;&gt;&lt;code&gt;next&lt;/code&gt;&lt;/a&gt; returns &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt;. Once &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt; is encountered, &lt;code&gt;count()&lt;/code&gt; returns the number of times it called &lt;a href=&quot;#tymethod.next&quot;&gt;&lt;code&gt;next&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Этот метод будет оценивать итератор, пока его &lt;a href=&quot;#tymethod.next&quot;&gt; &lt;code&gt;next&lt;/code&gt; &lt;/a&gt; результат &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt; &lt;code&gt;None&lt;/code&gt; &lt;/a&gt; вернет None . После обнаружения &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt; &lt;code&gt;None&lt;/code&gt; &lt;/a&gt; функция &lt;code&gt;count()&lt;/code&gt; возвращает количество &lt;a href=&quot;#tymethod.next&quot;&gt; &lt;code&gt;next&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="430231e1c82b4b198abc958a7fd105f7b17a6eb0" translate="yes" xml:space="preserve">
          <source>This method will fail if the socket is not connected. The &lt;code&gt;connect&lt;/code&gt; method will connect this socket to a remote address.</source>
          <target state="translated">Этот метод не сработает, если сокет не подключен. Метод &lt;code&gt;connect&lt;/code&gt; подключит этот сокет к удаленному адресу.</target>
        </trans-unit>
        <trans-unit id="99d3a71bbe68b832fc3370a5188434c797f36ae5" translate="yes" xml:space="preserve">
          <source>This method will never block the caller in order to wait for data to become available. Instead, this will always return immediately with a possible option of pending data on the channel.</source>
          <target state="translated">Этот метод никогда не будет блокировать вызывающего абонента,чтобы он ждал,пока данные станут доступны.Вместо этого,он всегда будет возвращаться немедленно с возможной опцией отложенных данных по каналу.</target>
        </trans-unit>
        <trans-unit id="cbdaac7e9262e1ca34c4fe476a690d8dd791b78c" translate="yes" xml:space="preserve">
          <source>This method will never block the current thread.</source>
          <target state="translated">Этот метод никогда не будет блокировать текущий поток.</target>
        </trans-unit>
        <trans-unit id="46d2c9fdd8f22af9ddb09186941e568038365eb2" translate="yes" xml:space="preserve">
          <source>This method will panic if result is not finite, negative or overflows &lt;code&gt;Duration&lt;/code&gt;.</source>
          <target state="translated">Этот метод вызовет панику, если результат не является конечным, отрицательным или превышает &lt;code&gt;Duration&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="361fc3f209ee1e7f236b4d7adeffb54823eee70f" translate="yes" xml:space="preserve">
          <source>This method will take care to not copy the vector, for efficiency's sake.</source>
          <target state="translated">Этот метод позаботится о том,чтобы не копировать вектор,ради эффективности.</target>
        </trans-unit>
        <trans-unit id="086f7043b4f8a7fd4a6336d78995f0e85e9d5744" translate="yes" xml:space="preserve">
          <source>This method, together with &lt;code&gt;key&lt;/code&gt;, is an alternative to &lt;code&gt;entry&lt;/code&gt; that can be used when the complete entry isn't known upfront. Prefer the &lt;code&gt;entry&lt;/code&gt; method when it's possible to use.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8e6fca229e267292b225ded4f3ea56dd1917d4dd" translate="yes" xml:space="preserve">
          <source>This method, together with &lt;code&gt;value&lt;/code&gt;, is an alternative to &lt;code&gt;entry&lt;/code&gt; that can be used when the complete entry isn't known upfront. Prefer the &lt;code&gt;entry&lt;/code&gt; method when it's possible to use.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="15bda4a4da4275b96ba5bd1843478dd37908d7e9" translate="yes" xml:space="preserve">
          <source>This module also provides an implementation of thread-local storage for Rust programs. Thread-local storage is a method of storing data into a global variable that each thread in the program will have its own copy of. Threads do not share this data, so accesses do not need to be synchronized.</source>
          <target state="translated">Этот модуль также обеспечивает реализацию потоколокального хранения для программ Rust.Потоковое хранилище-это способ хранения данных в глобальной переменной,копия которой будет иметься у каждого потока в программе.Потоки не обмениваются этими данными,поэтому доступ к ним не требуется синхронизировать.</target>
        </trans-unit>
        <trans-unit id="a618e47bcd778e6fbdbebc05ca474e36092d34bf" translate="yes" xml:space="preserve">
          <source>This module contains basic methods to manipulate the contents of the local filesystem. All methods in this module represent cross-platform filesystem operations. Extra platform-specific functionality can be found in the extension traits of &lt;code&gt;std::os::$platform&lt;/code&gt;.</source>
          <target state="translated">Этот модуль содержит основные методы для управления содержимым локальной файловой системы. Все методы в этом модуле представляют кросс-платформенные операции файловой системы. Дополнительные функции, зависящие от платформы, можно найти в признаках расширения &lt;code&gt;std::os::$platform&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="facf45454888eb2d77ede3ccdd2076d5cf487a0e" translate="yes" xml:space="preserve">
          <source>This module contains functions for querying the size and alignment of types, initializing and manipulating memory.</source>
          <target state="translated">Данный модуль содержит функции для запроса размера и выравнивания типов,инициализации и манипулирования памятью.</target>
        </trans-unit>
        <trans-unit id="2408b577206af618721c013114d9c06e429f800a" translate="yes" xml:space="preserve">
          <source>This module contains functions to inspect various aspects such as environment variables, process arguments, the current directory, and various other important directories.</source>
          <target state="translated">Этот модуль содержит функции для проверки различных аспектов,таких как переменные окружения,аргументы процесса,текущий каталог и различные другие важные каталоги.</target>
        </trans-unit>
        <trans-unit id="493f5d09dd437f62e48924cee92d925e5c7d2ef1" translate="yes" xml:space="preserve">
          <source>This module contains the &lt;a href=&quot;struct.string&quot;&gt;&lt;code&gt;String&lt;/code&gt;&lt;/a&gt; type, a trait for converting &lt;a href=&quot;trait.tostring&quot;&gt;&lt;code&gt;ToString&lt;/code&gt;&lt;/a&gt;s, and several error types that may result from working with &lt;a href=&quot;struct.string&quot;&gt;&lt;code&gt;String&lt;/code&gt;&lt;/a&gt;s.</source>
          <target state="translated">Этот модуль содержит тип &lt;a href=&quot;struct.string&quot;&gt; &lt;code&gt;String&lt;/code&gt; &lt;/a&gt; , свойство преобразования &lt;a href=&quot;trait.tostring&quot;&gt; &lt;code&gt;ToString&lt;/code&gt; &lt;/a&gt; s и несколько типов ошибок, которые могут возникнуть в результате работы со &lt;a href=&quot;struct.string&quot;&gt; &lt;code&gt;String&lt;/code&gt; &lt;/a&gt; s.</target>
        </trans-unit>
        <trans-unit id="0a09e5de88124067a8f4a272146af1f58ce6f16e" translate="yes" xml:space="preserve">
          <source>This module contains the &lt;a href=&quot;struct.string&quot;&gt;&lt;code&gt;String&lt;/code&gt;&lt;/a&gt; type, the &lt;a href=&quot;trait.tostring&quot;&gt;&lt;code&gt;ToString&lt;/code&gt;&lt;/a&gt; trait for converting to strings, and several error types that may result from working with &lt;a href=&quot;struct.string&quot;&gt;&lt;code&gt;String&lt;/code&gt;&lt;/a&gt;s.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a15bad5d969fcb97693f6f0bc38018fba7343164" translate="yes" xml:space="preserve">
          <source>This module contains the runtime support for the &lt;a href=&quot;../macro.format&quot;&gt;&lt;code&gt;format!&lt;/code&gt;&lt;/a&gt; syntax extension. This macro is implemented in the compiler to emit calls to this module in order to format arguments at runtime into strings.</source>
          <target state="translated">Этот модуль содержит поддержку &lt;a href=&quot;../macro.format&quot;&gt; &lt;code&gt;format!&lt;/code&gt; &lt;/a&gt; во время выполнения ! расширение синтаксиса. Этот макрос реализован в компиляторе для отправки вызовов этому модулю для форматирования аргументов во время выполнения в строки.</target>
        </trans-unit>
        <trans-unit id="12f15aefb562d878bda21e27716658fa02862f93" translate="yes" xml:space="preserve">
          <source>This module contains the support necessary to capture a stack backtrace of a running OS thread from the OS thread itself. The &lt;code&gt;Backtrace&lt;/code&gt; type supports capturing a stack trace via the &lt;code&gt;Backtrace::capture&lt;/code&gt; and &lt;code&gt;Backtrace::force_capture&lt;/code&gt; functions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fe75678b9da36500f1155d5a63660783d7b96c49" translate="yes" xml:space="preserve">
          <source>This module contains various tools for ordering and comparing values. In summary:</source>
          <target state="translated">Этот модуль содержит различные инструменты для заказа и сравнения значений.Подводя итог:</target>
        </trans-unit>
        <trans-unit id="5526cfdf674b75dda2276399dbf95bab9061f815" translate="yes" xml:space="preserve">
          <source>This module defines atomic versions of a select number of primitive types, including &lt;a href=&quot;struct.atomicbool&quot;&gt;&lt;code&gt;AtomicBool&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;struct.atomicisize&quot;&gt;&lt;code&gt;AtomicIsize&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;struct.atomicusize&quot;&gt;&lt;code&gt;AtomicUsize&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;struct.atomici8&quot;&gt;&lt;code&gt;AtomicI8&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;struct.atomicu16&quot;&gt;&lt;code&gt;AtomicU16&lt;/code&gt;&lt;/a&gt;, etc. Atomic types present operations that, when used correctly, synchronize updates between threads.</source>
          <target state="translated">Этот модуль определяет атомарные версии определенного количества примитивных типов, включая &lt;a href=&quot;struct.atomicbool&quot;&gt; &lt;code&gt;AtomicBool&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;struct.atomicisize&quot;&gt; &lt;code&gt;AtomicIsize&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;struct.atomicusize&quot;&gt; &lt;code&gt;AtomicUsize&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;struct.atomici8&quot;&gt; &lt;code&gt;AtomicI8&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;struct.atomicu16&quot;&gt; &lt;code&gt;AtomicU16&lt;/code&gt; &lt;/a&gt; и т. Д. Атомарные типы представляют операции, которые при правильном использовании синхронизируют обновления между потоками.</target>
        </trans-unit>
        <trans-unit id="69b6d67047755d0189ccf8e0dd69886ba1af9f48" translate="yes" xml:space="preserve">
          <source>This module exists for technical reasons, the primary documentation for &lt;code&gt;char&lt;/code&gt; is directly on &lt;a href=&quot;../primitive.char&quot;&gt;the &lt;code&gt;char&lt;/code&gt; primitive type&lt;/a&gt; itself.</source>
          <target state="translated">Этот модуль существует по техническим причинам, основная документация для &lt;code&gt;char&lt;/code&gt; находится непосредственно на &lt;a href=&quot;../primitive.char&quot;&gt;самом примитивном типе &lt;code&gt;char&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="0c05c40f88eef085aa06e135cdea7a637a633c60" translate="yes" xml:space="preserve">
          <source>This module implements the &lt;code&gt;Any&lt;/code&gt; trait, which enables dynamic typing of any &lt;code&gt;'static&lt;/code&gt; type through runtime reflection.</source>
          <target state="translated">Этот модуль реализует типаж &lt;code&gt;Any&lt;/code&gt; , который позволяет динамическую типизацию любого &lt;code&gt;'static&lt;/code&gt; типа посредством отражения во время выполнения.</target>
        </trans-unit>
        <trans-unit id="a2779c978566f8d66cd98dfb5457c45d53a57fb6" translate="yes" xml:space="preserve">
          <source>This module is largely organized by type:</source>
          <target state="translated">Этот модуль в основном организован по типам:</target>
        </trans-unit>
        <trans-unit id="5be07f93f33ed08d424575dcac18854b8631d380" translate="yes" xml:space="preserve">
          <source>This module is mostly concerned with spawning and interacting with child processes, but it also provides &lt;a href=&quot;fn.abort&quot;&gt;&lt;code&gt;abort&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;fn.exit&quot;&gt;&lt;code&gt;exit&lt;/code&gt;&lt;/a&gt; for terminating the current process.</source>
          <target state="translated">Этот модуль в основном занимается созданием дочерних процессов и взаимодействием с ними, но он также обеспечивает &lt;a href=&quot;fn.abort&quot;&gt; &lt;code&gt;abort&lt;/code&gt; &lt;/a&gt; и &lt;a href=&quot;fn.exit&quot;&gt; &lt;code&gt;exit&lt;/code&gt; &lt;/a&gt; для завершения текущего процесса.</target>
        </trans-unit>
        <trans-unit id="288daae4ba933c2cf1c52332e7aec01da8baaf15" translate="yes" xml:space="preserve">
          <source>This module is the home of the iterator implementations for the iterators implemented on &lt;code&gt;char&lt;/code&gt;, as well as some useful constants and conversion functions that convert various types to &lt;code&gt;char&lt;/code&gt;.</source>
          <target state="translated">Этот модуль является домом для реализаций итераторов для итераторов, реализованных на &lt;code&gt;char&lt;/code&gt; , а также некоторых полезных констант и функций преобразования, которые преобразуют различные типы в &lt;code&gt;char&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="55568ed1c38eacf7d09bc4bc93efa4b457d73318" translate="yes" xml:space="preserve">
          <source>This module only currently provides one bit of information, &lt;a href=&quot;struct.permissions#method.readonly&quot;&gt;&lt;code&gt;Permissions::readonly&lt;/code&gt;&lt;/a&gt;, which is exposed on all currently supported platforms. Unix-specific functionality, such as mode bits, is available through the &lt;a href=&quot;../os/unix/fs/trait.permissionsext&quot;&gt;&lt;code&gt;PermissionsExt&lt;/code&gt;&lt;/a&gt; trait.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="16223be8f664aa8af7792fdf4f8c15d5b579360d" translate="yes" xml:space="preserve">
          <source>This module only currently provides one bit of information, &lt;a href=&quot;struct.permissions#method.readonly&quot;&gt;&lt;code&gt;readonly&lt;/code&gt;&lt;/a&gt;, which is exposed on all currently supported platforms. Unix-specific functionality, such as mode bits, is available through the &lt;a href=&quot;../os/unix/fs/trait.permissionsext&quot;&gt;&lt;code&gt;PermissionsExt&lt;/code&gt;&lt;/a&gt; trait.</source>
          <target state="translated">Этот модуль в настоящее время предоставляет только один бит информации, только для &lt;a href=&quot;struct.permissions#method.readonly&quot;&gt; &lt;code&gt;readonly&lt;/code&gt; &lt;/a&gt; , который доступен на всех поддерживаемых в настоящее время платформах. Специфичные для Unix функции, такие как биты режима, доступны через свойство &lt;a href=&quot;../os/unix/fs/trait.permissionsext&quot;&gt; &lt;code&gt;PermissionsExt&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="72abc30b878e9efe98c4c560589176b50cfcfb02" translate="yes" xml:space="preserve">
          <source>This module provides a generic way to compute the hash of a value. The simplest way to make a type hashable is to use &lt;code&gt;#[derive(Hash)]&lt;/code&gt;:</source>
          <target state="translated">Этот модуль предоставляет общий способ вычисления хеш-функции значения. Самый простой способ сделать тип хешируемым - использовать &lt;code&gt;#[derive(Hash)]&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="8f6357e74fc7527ed8e55102f82ccb8843f20d51" translate="yes" xml:space="preserve">
          <source>This module provides constants which are specific to the implementation of the &lt;code&gt;f32&lt;/code&gt; floating point data type.</source>
          <target state="translated">Этот модуль предоставляет константы, специфичные для реализации типа данных с плавающей запятой &lt;code&gt;f32&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="87f0d2ad3a049e2ea757e82944e2e6b1d2f310c4" translate="yes" xml:space="preserve">
          <source>This module provides constants which are specific to the implementation of the &lt;code&gt;f64&lt;/code&gt; floating point data type.</source>
          <target state="translated">Этот модуль предоставляет константы, специфичные для реализации типа данных с плавающей запятой &lt;code&gt;f64&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4dd1d432064e6f3e28ac8c1d81caf06446f388ba" translate="yes" xml:space="preserve">
          <source>This module provides message-based communication over channels, concretely defined among three types:</source>
          <target state="translated">Этот модуль обеспечивает коммуникацию на основе сообщений по каналам,конкретно определенным между тремя типами:</target>
        </trans-unit>
        <trans-unit id="bfedf6f4f14d905a894526b273dfe17f7e7c03dc" translate="yes" xml:space="preserve">
          <source>This module provides networking functionality for the Transmission Control and User Datagram Protocols, as well as types for IP and socket addresses.</source>
          <target state="translated">Данный модуль обеспечивает сетевую функциональность для протоколов управления передачей и пользовательской датаграммы,а также типы для IP-адресов и адресов сокетов.</target>
        </trans-unit>
        <trans-unit id="fcfa8dfe7aed9682173752b15b6103829ea655a1" translate="yes" xml:space="preserve">
          <source>This module provides some extra types that are useful when doing numerical work. See the individual documentation for each piece for more information.</source>
          <target state="translated">Этот модуль предоставляет некоторые дополнительные типы,которые полезны при выполнении численных работ.Дополнительную информацию см.в индивидуальной документации к каждому экземпляру.</target>
        </trans-unit>
        <trans-unit id="b42dc453d74574a22f838766ed6a6210b7719f9b" translate="yes" xml:space="preserve">
          <source>This module provides two types, &lt;a href=&quot;struct.pathbuf&quot;&gt;&lt;code&gt;PathBuf&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;struct.path&quot;&gt;&lt;code&gt;Path&lt;/code&gt;&lt;/a&gt; (akin to &lt;a href=&quot;../string/struct.string&quot;&gt;&lt;code&gt;String&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../primitive.str&quot;&gt;&lt;code&gt;str&lt;/code&gt;&lt;/a&gt;), for working with paths abstractly. These types are thin wrappers around &lt;a href=&quot;../ffi/struct.osstring&quot;&gt;&lt;code&gt;OsString&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../ffi/struct.osstr&quot;&gt;&lt;code&gt;OsStr&lt;/code&gt;&lt;/a&gt; respectively, meaning that they work directly on strings according to the local platform's path syntax.</source>
          <target state="translated">Этот модуль предоставляет два типа, &lt;a href=&quot;struct.pathbuf&quot;&gt; &lt;code&gt;PathBuf&lt;/code&gt; &lt;/a&gt; и &lt;a href=&quot;struct.path&quot;&gt; &lt;code&gt;Path&lt;/code&gt; &lt;/a&gt; (аналогично &lt;a href=&quot;../string/struct.string&quot;&gt; &lt;code&gt;String&lt;/code&gt; &lt;/a&gt; и &lt;a href=&quot;../primitive.str&quot;&gt; &lt;code&gt;str&lt;/code&gt; &lt;/a&gt; ), для абстрактной работы с путями. Эти типы представляют собой тонкие оболочки вокруг &lt;a href=&quot;../ffi/struct.osstring&quot;&gt; &lt;code&gt;OsString&lt;/code&gt; &lt;/a&gt; и &lt;a href=&quot;../ffi/struct.osstr&quot;&gt; &lt;code&gt;OsStr&lt;/code&gt; &lt;/a&gt; соответственно, что означает, что они работают непосредственно со строками в соответствии с синтаксисом пути локальной платформы.</target>
        </trans-unit>
        <trans-unit id="a9add5ffa74ddef61504588ae8fe02f3fc02034e" translate="yes" xml:space="preserve">
          <source>This module provides two types, &lt;a href=&quot;struct.pathbuf&quot;&gt;&lt;code&gt;PathBuf&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;struct.path&quot;&gt;&lt;code&gt;Path&lt;/code&gt;&lt;/a&gt; (akin to &lt;a href=&quot;../string/struct.string&quot;&gt;&lt;code&gt;String&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;https://doc.rust-lang.org/nightly/std/primitive.str.html&quot;&gt;&lt;code&gt;str&lt;/code&gt;&lt;/a&gt;), for working with paths abstractly. These types are thin wrappers around &lt;a href=&quot;../ffi/struct.osstring&quot;&gt;&lt;code&gt;OsString&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../ffi/struct.osstr&quot;&gt;&lt;code&gt;OsStr&lt;/code&gt;&lt;/a&gt; respectively, meaning that they work directly on strings according to the local platform's path syntax.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f2fe72f6bcf1faf654e10546253a992773369d18" translate="yes" xml:space="preserve">
          <source>This module provides utilities to handle data across non-Rust interfaces, like other programming languages and the underlying operating system. It is mainly of use for FFI (Foreign Function Interface) bindings and code that needs to exchange C-like strings with other languages.</source>
          <target state="translated">Этот модуль предоставляет утилиты для работы с данными через не ржавые интерфейсы,такие как другие языки программирования и базовая операционная система.В основном он используется для привязки FFI (Foreign Function Interface)и кода,который должен обмениваться C-подобными строками с другими языками.</target>
        </trans-unit>
        <trans-unit id="523a58a1796e44e7bd8c46d95ef23447cedfbc5f" translate="yes" xml:space="preserve">
          <source>This module reexports the primitive types to allow usage that is not possibly shadowed by other declared types.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2bfbd1c67f1485adce8aa9ca96b08fda6c8d21af" translate="yes" xml:space="preserve">
          <source>This mutex will block threads waiting for the lock to become available. The mutex can also be statically initialized or created via a &lt;a href=&quot;#method.new&quot;&gt;&lt;code&gt;new&lt;/code&gt;&lt;/a&gt; constructor. Each mutex has a type parameter which represents the data that it is protecting. The data can only be accessed through the RAII guards returned from &lt;a href=&quot;#method.lock&quot;&gt;&lt;code&gt;lock&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#method.try_lock&quot;&gt;&lt;code&gt;try_lock&lt;/code&gt;&lt;/a&gt;, which guarantees that the data is only ever accessed when the mutex is locked.</source>
          <target state="translated">Этот мьютекс будет блокировать потоки, ожидающие, пока блокировка станет доступной. Мьютекс также можно статически инициализировать или создать с помощью &lt;a href=&quot;#method.new&quot;&gt; &lt;code&gt;new&lt;/code&gt; &lt;/a&gt; конструктора. Каждый мьютекс имеет параметр типа, который представляет данные, которые он защищает. Доступ к данным возможен только через защиту RAII, возвращаемую из &lt;a href=&quot;#method.lock&quot;&gt; &lt;code&gt;lock&lt;/code&gt; &lt;/a&gt; и &lt;a href=&quot;#method.try_lock&quot;&gt; &lt;code&gt;try_lock&lt;/code&gt; &lt;/a&gt; , что гарантирует, что данные будут доступны только тогда, когда мьютекс заблокирован.</target>
        </trans-unit>
        <trans-unit id="37c35fdf98665e8061d3ede706452fcafbf6bf45" translate="yes" xml:space="preserve">
          <source>This mutex will block threads waiting for the lock to become available. The mutex can also be statically initialized or created via a &lt;a href=&quot;struct.mutex#method.new&quot;&gt;&lt;code&gt;new&lt;/code&gt;&lt;/a&gt; constructor. Each mutex has a type parameter which represents the data that it is protecting. The data can only be accessed through the RAII guards returned from &lt;a href=&quot;struct.mutex#method.lock&quot;&gt;&lt;code&gt;lock&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;struct.mutex#method.try_lock&quot;&gt;&lt;code&gt;try_lock&lt;/code&gt;&lt;/a&gt;, which guarantees that the data is only ever accessed when the mutex is locked.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c6bb4ef8774a69f40318879a20a2f5485ae10af2" translate="yes" xml:space="preserve">
          <source>This never needs to re-allocate, but does need to do &lt;em&gt;O&lt;/em&gt;(&lt;em&gt;n&lt;/em&gt;) data movement if the circular buffer doesn't happen to be at the beginning of the allocation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="56f3b065f3863bd74d78c00a2522270062418669" translate="yes" xml:space="preserve">
          <source>This never needs to re-allocate, but does need to do O(n) data movement if the circular buffer doesn't happen to be at the beginning of the allocation.</source>
          <target state="translated">Перераспределение никогда не требуется,но требуется перемещение данных O(n),если циркулярный буфер случайно не находится в начале распределения.</target>
        </trans-unit>
        <trans-unit id="d28b87d734ed0d5315fcb74f17b2994ec84a38d2" translate="yes" xml:space="preserve">
          <source>This new slice goes from &lt;code&gt;begin&lt;/code&gt; to &lt;code&gt;end&lt;/code&gt;, including &lt;code&gt;begin&lt;/code&gt; but excluding &lt;code&gt;end&lt;/code&gt;.</source>
          <target state="translated">Этот новый фрагмент идет от &lt;code&gt;begin&lt;/code&gt; до &lt;code&gt;end&lt;/code&gt; , включая &lt;code&gt;begin&lt;/code&gt; но исключая &lt;code&gt;end&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c5e5d3eaf75778ffc4640687e8cefa2e10e75497" translate="yes" xml:space="preserve">
          <source>This next example calls a supertrait method on a generic parameter.</source>
          <target state="translated">В следующем примере вызывается метод супертрейта на общем параметре.</target>
        </trans-unit>
        <trans-unit id="9f7ad17f03d80b97ecff41fe1815f8dca0918d1f" translate="yes" xml:space="preserve">
          <source>This next example gives &lt;code&gt;radius&lt;/code&gt; a default implementation using the &lt;code&gt;area&lt;/code&gt; function from &lt;code&gt;Shape&lt;/code&gt;.</source>
          <target state="translated">В следующем примере &lt;code&gt;radius&lt;/code&gt; реализуется по умолчанию с использованием функции &lt;code&gt;area&lt;/code&gt; из &lt;code&gt;Shape&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="50d4d7072a1ea5b824d1df9626f273fc9c52a75a" translate="yes" xml:space="preserve">
          <source>This number is a lower bound; the &lt;code&gt;HashMap&amp;lt;K, V&amp;gt;&lt;/code&gt; might be able to hold more, but is guaranteed to be able to hold at least this many.</source>
          <target state="translated">Это число является нижней границей; &lt;code&gt;HashMap&amp;lt;K, V&amp;gt;&lt;/code&gt; может быть в состоянии держать больше, но гарантированно иметь возможность проводить по крайней мере , это много.</target>
        </trans-unit>
        <trans-unit id="75625b78a6cc53054a38dc48c604ece0622bfe30" translate="yes" xml:space="preserve">
          <source>This number is simply useful for passing to other methods, like &lt;a href=&quot;struct.osstring#method.with_capacity&quot;&gt;&lt;code&gt;OsString::with_capacity&lt;/code&gt;&lt;/a&gt; to avoid reallocations.</source>
          <target state="translated">Это число просто полезно для передачи другим методам, например &lt;a href=&quot;struct.osstring#method.with_capacity&quot;&gt; &lt;code&gt;OsString::with_capacity&lt;/code&gt; &lt;/a&gt; чтобы избежать перераспределения.</target>
        </trans-unit>
        <trans-unit id="1f022d625542e31d83b61a7cfb496898fc698f8a" translate="yes" xml:space="preserve">
          <source>This only differs from the previous &lt;code&gt;impl&lt;/code&gt; in that the parameters &lt;code&gt;T&lt;/code&gt; and &lt;code&gt;MyType&amp;lt;T&amp;gt;&lt;/code&gt; for &lt;code&gt;ForeignTrait2&lt;/code&gt; have been swapped. This example does &lt;em&gt;not&lt;/em&gt; violate the orphan rule; it is permitted.</source>
          <target state="translated">Он отличается от предыдущего &lt;code&gt;impl&lt;/code&gt; тем, что параметры &lt;code&gt;T&lt;/code&gt; и &lt;code&gt;MyType&amp;lt;T&amp;gt;&lt;/code&gt; для &lt;code&gt;ForeignTrait2&lt;/code&gt; поменялись местами. Этот пример &lt;em&gt;не&lt;/em&gt; нарушает правила сиротства; это разрешено.</target>
        </trans-unit>
        <trans-unit id="1833c0a27c1d09954fa6a057a5eb72b9706f31ec" translate="yes" xml:space="preserve">
          <source>This only includes environment variables explicitly set with &lt;a href=&quot;struct.command#method.env&quot;&gt;&lt;code&gt;Command::env&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;struct.command#method.envs&quot;&gt;&lt;code&gt;Command::envs&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;struct.command#method.env_remove&quot;&gt;&lt;code&gt;Command::env_remove&lt;/code&gt;&lt;/a&gt;. It does not include environment variables that will be inherited by the child process.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="123296246acbbeb137b9c0c76f971008749a56bb" translate="yes" xml:space="preserve">
          <source>This operation does &lt;strong&gt;not&lt;/strong&gt; modify the filesystem. To modify the filesystem use the &lt;a href=&quot;fn.set_permissions&quot;&gt;&lt;code&gt;fs::set_permissions&lt;/code&gt;&lt;/a&gt; function.</source>
          <target state="translated">Эта операция &lt;strong&gt;не&lt;/strong&gt; изменяет файловую систему. Чтобы изменить файловую систему, используйте функцию &lt;a href=&quot;fn.set_permissions&quot;&gt; &lt;code&gt;fs::set_permissions&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="7036bf2f2a1e56b239ac49dd49a90706f4ff18c2" translate="yes" xml:space="preserve">
          <source>This operation does &lt;strong&gt;not&lt;/strong&gt; modify the filesystem. To modify the filesystem use the &lt;a href=&quot;fn.set_permissions&quot;&gt;&lt;code&gt;set_permissions&lt;/code&gt;&lt;/a&gt; function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0c0bbc4d892938033fbacd4684ea2a287c924f8c" translate="yes" xml:space="preserve">
          <source>This operation is &lt;code&gt;O(1)&lt;/code&gt;.</source>
          <target state="translated">Эта операция &lt;code&gt;O(1)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="dd1a487434fc87832e2f1a787954854ff60dfa9b" translate="yes" xml:space="preserve">
          <source>This operation is &lt;em&gt;O&lt;/em&gt;(1).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1fdec81639aa08f036b813714ac253cba45f17ed" translate="yes" xml:space="preserve">
          <source>This operation is sometimes called 'reduce' or 'inject'.</source>
          <target state="translated">Эта операция иногда называется &quot;уменьшить&quot; или &quot;впрыснуть&quot;.</target>
        </trans-unit>
        <trans-unit id="c8451edf8bf7bc5bb1bf0555fcc9a5705a25da14" translate="yes" xml:space="preserve">
          <source>This operation performs an unconditional mapping without tailoring. That is, the conversion is independent of context and language.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e2fd1d86e77ef341cc160d32009392653fd89ec1" translate="yes" xml:space="preserve">
          <source>This operation rounds towards zero, truncating any fractional part of the exact result.</source>
          <target state="translated">Эта операция округляется до нуля,усекая любую часть точного результата.</target>
        </trans-unit>
        <trans-unit id="77029037758bda804fd792f27ba1f29cea457a7e" translate="yes" xml:space="preserve">
          <source>This operation satisfies &lt;code&gt;n % d == n - (n / d) * d&lt;/code&gt;. The result has the same sign as the left operand.</source>
          <target state="translated">Эта операция удовлетворяет &lt;code&gt;n % d == n - (n / d) * d&lt;/code&gt; . Результат имеет тот же знак, что и левый операнд.</target>
        </trans-unit>
        <trans-unit id="bdbe7ca28eb7e43951e771605b8bd474b48c29e7" translate="yes" xml:space="preserve">
          <source>This operation should compute in &lt;em&gt;O&lt;/em&gt;(1) time and &lt;em&gt;O&lt;/em&gt;(1) memory.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="43df87c6439b0a85582f9e67d3c1fce146118f3d" translate="yes" xml:space="preserve">
          <source>This operation should compute in &lt;em&gt;O&lt;/em&gt;(1) time.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0d494ef70142bea4ddf2b4f6d9f09545f47dd54e" translate="yes" xml:space="preserve">
          <source>This operation should compute in &lt;em&gt;O&lt;/em&gt;(&lt;em&gt;n&lt;/em&gt;) time.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="48c9bdd59dbbaca42da37bc9d33eec68b2af8961" translate="yes" xml:space="preserve">
          <source>This operation should compute in O(1) time and O(1) memory.</source>
          <target state="translated">Эта операция должна вычисляться во времени O(1)и памяти O(1).</target>
        </trans-unit>
        <trans-unit id="fc7c0f50f52c35ea7e364b7e26d103277ce95b38" translate="yes" xml:space="preserve">
          <source>This operation should compute in O(1) time.</source>
          <target state="translated">Эта операция должна вычисляться во времени O(1).</target>
        </trans-unit>
        <trans-unit id="a13a41f53da524732e21aa1da4b3958def62f00f" translate="yes" xml:space="preserve">
          <source>This operation should compute in O(n) time.</source>
          <target state="translated">Эта операция должна вычисляться во времени O(n).</target>
        </trans-unit>
        <trans-unit id="4da5d428cc5f4bb1f1eadb7b45f2669f2c6be87e" translate="yes" xml:space="preserve">
          <source>This operation was interrupted.</source>
          <target state="translated">Эта операция была прервана.</target>
        </trans-unit>
        <trans-unit id="e5b25bf34db3082fbebf881dd2f3b63132ce24a9" translate="yes" xml:space="preserve">
          <source>This operation wraps around on overflow.</source>
          <target state="translated">Эта операция обернется переполнением.</target>
        </trans-unit>
        <trans-unit id="513292ffc7d15c4c6459299bf349f4e8ef41bcc6" translate="yes" xml:space="preserve">
          <source>This option defaults to &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">По умолчанию этот параметр равен &lt;code&gt;false&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="07732c105324f285891b421be7b1897cf45eb1a8" translate="yes" xml:space="preserve">
          <source>This option indicates whether a new file will be created if the file does not yet already exist.</source>
          <target state="translated">Эта опция указывает,будет ли создан новый файл,если он еще не существует.</target>
        </trans-unit>
        <trans-unit id="2ab719a36168121ae6911773d2659e3887ae7b87" translate="yes" xml:space="preserve">
          <source>This option indicates whether a new file will be created. No file is allowed to exist at the target location, also no (dangling) symlink.</source>
          <target state="translated">Эта опция указывает,будет ли создан новый файл.Никакой файл не может существовать в целевом месте,также отсутствует (висящая)сим-ссылка.</target>
        </trans-unit>
        <trans-unit id="1997355865e9c95bba24957f07adb48aa7900b34" translate="yes" xml:space="preserve">
          <source>This option is useful because it is atomic. Otherwise between checking whether a file exists and creating a new one, the file may have been created by another process (a TOCTOU race condition / attack).</source>
          <target state="translated">Этот вариант полезен,потому что он атомарный.В противном случае,между проверкой существования файла и созданием нового,файл мог быть создан другим процессом (состояние гонки TOCTOU/атака).</target>
        </trans-unit>
        <trans-unit id="4d1d1f446736eda75bb94ad6c4911fc032b1110f" translate="yes" xml:space="preserve">
          <source>This option, when true, means that writes will append to a file instead of overwriting previous contents. Note that setting &lt;code&gt;.write(true).append(true)&lt;/code&gt; has the same effect as setting only &lt;code&gt;.append(true)&lt;/code&gt;.</source>
          <target state="translated">Если этот параметр имеет значение true, это означает, что записи будут добавляться к файлу вместо перезаписи предыдущего содержимого. Обратите внимание, что установка &lt;code&gt;.write(true).append(true)&lt;/code&gt; имеет тот же эффект, что и установка только &lt;code&gt;.append(true)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="279fd5d225ffc9cf4a6694f03d2272dc1973056a" translate="yes" xml:space="preserve">
          <source>This option, when true, will indicate that the file should be &lt;code&gt;read&lt;/code&gt;-able if opened.</source>
          <target state="translated">Если эта опция истинна, это означает, что файл должен быть доступен для &lt;code&gt;read&lt;/code&gt; при открытии.</target>
        </trans-unit>
        <trans-unit id="2aa691cde7b75893eb561d3865c9d79612f73f71" translate="yes" xml:space="preserve">
          <source>This option, when true, will indicate that the file should be &lt;code&gt;write&lt;/code&gt;-able if opened.</source>
          <target state="translated">Если эта опция истинна, это будет означать, что файл должен быть доступен для &lt;code&gt;write&lt;/code&gt; при открытии.</target>
        </trans-unit>
        <trans-unit id="42af0ae9cc5372b7ccd519ad313f0abe9e0cfe15" translate="yes" xml:space="preserve">
          <source>This ordering is only applicable for operations that can perform a load.</source>
          <target state="translated">Данный заказ применим только для операций,которые могут выполнять нагрузку.</target>
        </trans-unit>
        <trans-unit id="20a3da5b9e12d0ccdf3e64c2e589466b4721fced" translate="yes" xml:space="preserve">
          <source>This ordering is only applicable for operations that can perform a store.</source>
          <target state="translated">Этот заказ применим только для операций,которые могут выполнить магазин.</target>
        </trans-unit>
        <trans-unit id="ea76b31c997f4d8a61f17e8560093311b945344f" translate="yes" xml:space="preserve">
          <source>This ordering is only applicable for operations that combine both loads and stores.</source>
          <target state="translated">Данный заказ применим только для операций,сочетающих в себе как грузы,так и запасы.</target>
        </trans-unit>
        <trans-unit id="a87804f30fcdf78425015d26ec12efca3e1a08c7" translate="yes" xml:space="preserve">
          <source>This output is better: we now have a reasonable error message. However, we also have extraneous information we don&amp;rsquo;t want to give to our users. Perhaps using the technique we used in Listing 9-10 isn&amp;rsquo;t the best to use here: a call to &lt;code&gt;panic!&lt;/code&gt; is more appropriate for a programming problem than a usage problem, &lt;a href=&quot;ch09-03-to-panic-or-not-to-panic#guidelines-for-error-handling&quot;&gt;as discussed in Chapter 9&lt;/a&gt;. Instead, we can use the other technique you learned about in Chapter 9&amp;mdash;&lt;a href=&quot;ch09-02-recoverable-errors-with-result&quot;&gt;returning a &lt;code&gt;Result&lt;/code&gt;&lt;/a&gt; that indicates either success or an error.</source>
          <target state="translated">Этот вывод лучше: теперь у нас есть разумное сообщение об ошибке. Однако у нас также есть посторонняя информация, которую мы не хотим передавать нашим пользователям. Возможно, использование техники, которую мы использовали в листинге 9-10, здесь не лучший вариант: призыв к &lt;code&gt;panic!&lt;/code&gt; более подходит для проблемы программирования, чем для проблемы использования, &lt;a href=&quot;ch09-03-to-panic-or-not-to-panic#guidelines-for-error-handling&quot;&gt;как описано в главе 9&lt;/a&gt; . Вместо этого мы можем использовать другую технику, о которой вы узнали в главе 9, - &lt;a href=&quot;ch09-02-recoverable-errors-with-result&quot;&gt;возврат &lt;code&gt;Result&lt;/code&gt; &lt;/a&gt; который указывает либо на успех, либо на ошибку.</target>
        </trans-unit>
        <trans-unit id="04051f730c7eeba40e7dd9250f9fd3ae55f310b9" translate="yes" xml:space="preserve">
          <source>This output isn&amp;rsquo;t what we wanted. We want to call the &lt;code&gt;baby_name&lt;/code&gt; function that is part of the &lt;code&gt;Animal&lt;/code&gt; trait that we implemented on &lt;code&gt;Dog&lt;/code&gt; so the code prints &lt;code&gt;A baby dog is called a puppy&lt;/code&gt;. The technique of specifying the trait name that we used in Listing 19-18 doesn&amp;rsquo;t help here; if we change &lt;code&gt;main&lt;/code&gt; to the code in Listing 19-20, we&amp;rsquo;ll get a compilation error.</source>
          <target state="translated">Это не то, что мы хотели. Мы хотим вызвать функцию &lt;code&gt;baby_name&lt;/code&gt; , которая является частью трейта &lt;code&gt;Animal&lt;/code&gt; , который мы реализовали в &lt;code&gt;Dog&lt;/code&gt; , чтобы код печатал &lt;code&gt;A baby dog is called a puppy&lt;/code&gt; . Техника указания имени трейта, которую мы использовали в листинге 19-18, здесь не помогает; если мы изменим &lt;code&gt;main&lt;/code&gt; на код из Листинга 19-20, мы получим ошибку компиляции.</target>
        </trans-unit>
        <trans-unit id="66b4788ea5425d4692dd1ffafd058fec8508d60c" translate="yes" xml:space="preserve">
          <source>This output shows &lt;code&gt;cargo test&lt;/code&gt; only ran the tests for the &lt;code&gt;add-one&lt;/code&gt; crate and didn&amp;rsquo;t run the &lt;code&gt;adder&lt;/code&gt; crate tests.</source>
          <target state="translated">Эти выходные данные показывают, что в &lt;code&gt;cargo test&lt;/code&gt; только для &lt;code&gt;add-one&lt;/code&gt; но не для контейнера для &lt;code&gt;adder&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f91d4073e1806ac4e46d9be9407b7439ade530c5" translate="yes" xml:space="preserve">
          <source>This outputs:</source>
          <target state="translated">Это выходит:</target>
        </trans-unit>
        <trans-unit id="220a338b4d08066eba2a22fb127e73c40665ebcb" translate="yes" xml:space="preserve">
          <source>This overwrites pinned data, but that is okay: its destructor gets run before being overwritten, so no pinning guarantee is violated.</source>
          <target state="translated">Это перезаписывает пиннинговые данные,но это нормально:его деструктор запускается до перезаписи,поэтому гарантия пиннинга не нарушается.</target>
        </trans-unit>
        <trans-unit id="05caefb888af241727a56b286e8ae483a7d9633f" translate="yes" xml:space="preserve">
          <source>This page documents the formal specification of the follow rules for &lt;a href=&quot;macros-by-example&quot;&gt;Macros By Example&lt;/a&gt;. They were originally specified in &lt;a href=&quot;https://github.com/rust-lang/rfcs/blob/master/text/0550-macro-future-proofing.html&quot;&gt;RFC 550&lt;/a&gt;, from which the bulk of this text is copied, and expanded upon in subsequent RFCs.</source>
          <target state="translated">Эта страница документирует формальную спецификацию следующих правил для &lt;a href=&quot;macros-by-example&quot;&gt;макросов по примеру&lt;/a&gt; . Первоначально они были указаны в &lt;a href=&quot;https://github.com/rust-lang/rfcs/blob/master/text/0550-macro-future-proofing.html&quot;&gt;RFC 550&lt;/a&gt; , из которого скопирована большая часть этого текста, и расширены в последующих RFC.</target>
        </trans-unit>
        <trans-unit id="3b9633b5692298146f03a49947c6dcff6df1f7b9" translate="yes" xml:space="preserve">
          <source>This page documents the formal specification of the follow rules for &lt;a href=&quot;macros-by-example&quot;&gt;Macros By Example&lt;/a&gt;. They were originally specified in &lt;a href=&quot;https://github.com/rust-lang/rfcs/blob/master/text/0550-macro-future-proofing.md&quot;&gt;RFC 550&lt;/a&gt;, from which the bulk of this text is copied, and expanded upon in subsequent RFCs.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f87b1d9607de86149c082e3d8de19453e0048df2" translate="yes" xml:space="preserve">
          <source>This pattern has a profound impact on the way Rust code is written. It may seem simple right now, but the behavior of code can be unexpected in more complicated situations when we want to have multiple variables use the data we&amp;rsquo;ve allocated on the heap. Let&amp;rsquo;s explore some of those situations now.</source>
          <target state="translated">Этот шаблон оказывает глубокое влияние на способ написания кода Rust. Сейчас это может показаться простым, но поведение кода может быть неожиданным в более сложных ситуациях, когда мы хотим, чтобы несколько переменных использовали данные, которые мы разместили в куче. Давайте теперь рассмотрим некоторые из этих ситуаций.</target>
        </trans-unit>
        <trans-unit id="ebae1cd81adce77daea1f3e37e663633c554fab5" translate="yes" xml:space="preserve">
          <source>This pattern is about separating concerns: &lt;em&gt;main.rs&lt;/em&gt; handles running the program, and &lt;em&gt;lib.rs&lt;/em&gt; handles all the logic of the task at hand. Because you can&amp;rsquo;t test the &lt;code&gt;main&lt;/code&gt; function directly, this structure lets you test all of your program&amp;rsquo;s logic by moving it into functions in &lt;em&gt;lib.rs&lt;/em&gt;. The only code that remains in &lt;em&gt;main.rs&lt;/em&gt; will be small enough to verify its correctness by reading it. Let&amp;rsquo;s rework our program by following this process.</source>
          <target state="translated">Этот шаблон предназначен для разделения задач: &lt;em&gt;main.rs&lt;/em&gt; обрабатывает запуск программы, а &lt;em&gt;lib.rs&lt;/em&gt; обрабатывает всю логику задачи. Потому что вы не можете проверить &lt;code&gt;main&lt;/code&gt; функцию непосредственно, эта структура позволяет тестировать все логики вашей программы, перемещая его в функцию в &lt;em&gt;lib.rs&lt;/em&gt; . Единственный код, который останется в &lt;em&gt;main.rs,&lt;/em&gt; будет достаточно маленьким, чтобы проверить его правильность, прочитав его. Давайте переработаем нашу программу, выполнив этот процесс.</target>
        </trans-unit>
        <trans-unit id="4f7fef1aec609824d9a98cbd4986f806fb8112f5" translate="yes" xml:space="preserve">
          <source>This pattern is refutable when one of its subpatterns is refutable.</source>
          <target state="translated">Этот образец является возвращаемым,когда одна из его подмастерн является возвращаемой.</target>
        </trans-unit>
        <trans-unit id="8e7824ffc5e192a74a0014b97fd199a69a9bbad1" translate="yes" xml:space="preserve">
          <source>This pattern of propagating errors is so common in Rust that Rust provides the question mark operator &lt;code&gt;?&lt;/code&gt; to make this easier.</source>
          <target state="translated">Этот шаблон распространения ошибок настолько распространен в Rust, что в Rust есть оператор вопросительного знака &lt;code&gt;?&lt;/code&gt; чтобы сделать это проще.</target>
        </trans-unit>
        <trans-unit id="be8e420bedd2fafb3e2ace598d4c2a4fc61a219a" translate="yes" xml:space="preserve">
          <source>This performs complex unconditional mappings with no tailoring: it maps one Unicode character to its lowercase equivalent according to the &lt;a href=&quot;ftp://ftp.unicode.org/Public/UNIDATA/UnicodeData.txt&quot;&gt;Unicode database&lt;/a&gt; and the additional complex mappings &lt;a href=&quot;ftp://ftp.unicode.org/Public/UNIDATA/SpecialCasing.txt&quot;&gt;&lt;code&gt;SpecialCasing.txt&lt;/code&gt;&lt;/a&gt;. Conditional mappings (based on context or language) are not considered here.</source>
          <target state="translated">Это выполняет сложные безусловные сопоставления без адаптации: он сопоставляет один символ Unicode его эквиваленту в нижнем регистре в соответствии с &lt;a href=&quot;ftp://ftp.unicode.org/Public/UNIDATA/UnicodeData.txt&quot;&gt;базой данных Unicode&lt;/a&gt; и дополнительными сложными сопоставлениями &lt;a href=&quot;ftp://ftp.unicode.org/Public/UNIDATA/SpecialCasing.txt&quot;&gt; &lt;code&gt;SpecialCasing.txt&lt;/code&gt; &lt;/a&gt; . Условные сопоставления (основанные на контексте или языке) здесь не рассматриваются.</target>
        </trans-unit>
        <trans-unit id="2bedef26ecd391020afcece167562372d74e3b11" translate="yes" xml:space="preserve">
          <source>This performs complex unconditional mappings with no tailoring: it maps one Unicode character to its uppercase equivalent according to the &lt;a href=&quot;ftp://ftp.unicode.org/Public/UNIDATA/UnicodeData.txt&quot;&gt;Unicode database&lt;/a&gt; and the additional complex mappings &lt;a href=&quot;ftp://ftp.unicode.org/Public/UNIDATA/SpecialCasing.txt&quot;&gt;&lt;code&gt;SpecialCasing.txt&lt;/code&gt;&lt;/a&gt;. Conditional mappings (based on context or language) are not considered here.</source>
          <target state="translated">Это выполняет сложные безусловные сопоставления без адаптации: он сопоставляет один символ Unicode с его эквивалентом в верхнем регистре в соответствии с &lt;a href=&quot;ftp://ftp.unicode.org/Public/UNIDATA/UnicodeData.txt&quot;&gt;базой данных Unicode&lt;/a&gt; и дополнительными сложными сопоставлениями &lt;a href=&quot;ftp://ftp.unicode.org/Public/UNIDATA/SpecialCasing.txt&quot;&gt; &lt;code&gt;SpecialCasing.txt&lt;/code&gt; &lt;/a&gt; . Условные сопоставления (основанные на контексте или языке) здесь не рассматриваются.</target>
        </trans-unit>
        <trans-unit id="367fd59cc7a5ce52d6910a709b90bfcbe81a7ab5" translate="yes" xml:space="preserve">
          <source>This piece of Rust history is relevant because it&amp;rsquo;s possible that more deterministic patterns will emerge and be added to the compiler. In the future, even fewer lifetime annotations might be required.</source>
          <target state="translated">Этот фрагмент истории Rust важен, потому что возможно появление более детерминированных шаблонов, которые будут добавлены в компилятор. В будущем может потребоваться еще меньше аннотаций времени жизни.</target>
        </trans-unit>
        <trans-unit id="4d1e98917aa47fb301eb32dc85055855554e0b37" translate="yes" xml:space="preserve">
          <source>This pinned future is then polled by calling the &lt;a href=&quot;../../std/future/trait.future#tymethod.poll&quot;&gt;&lt;code&gt;Future::poll&lt;/code&gt;&lt;/a&gt; method and passing it the current &lt;a href=&quot;#task-context&quot;&gt;task context&lt;/a&gt;;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ce7cedc5fc51216f120f0eb8fae3379dc963620e" translate="yes" xml:space="preserve">
          <source>This prints output like:</source>
          <target state="translated">Это печатает выходные данные,как:</target>
        </trans-unit>
        <trans-unit id="ff9f7a5e1d4525cd7d8438461ac9c53da48b455e" translate="yes" xml:space="preserve">
          <source>This prints to &lt;a href=&quot;https://en.wikipedia.org/wiki/Standard_streams#Standard_error_(stderr)&quot;&gt;stderr&lt;/a&gt;:</source>
          <target state="translated">Это печатает в &lt;a href=&quot;https://en.wikipedia.org/wiki/Standard_streams#Standard_error_(stderr)&quot;&gt;stderr&lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="3c9f3b33a54ec1f8657331a04066cc462bed4e33" translate="yes" xml:space="preserve">
          <source>This problem can be solved by specifying from which trait we want to use the &lt;code&gt;Bar&lt;/code&gt; type:</source>
          <target state="translated">Эту проблему можно решить, указав, из какого трейта мы хотим использовать тип &lt;code&gt;Bar&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="fc4e53a566f64cd7b3bd5c8e48b6dab0075560d7" translate="yes" xml:space="preserve">
          <source>This process does not take into account the mutability or lifetime of the receiver, or whether a method is &lt;code&gt;unsafe&lt;/code&gt;. Once a method is looked up, if it can't be called for one (or more) of those reasons, the result is a compiler error.</source>
          <target state="translated">Этот процесс не принимает во внимание изменчивость или время жизни получателя, а также то, является ли метод &lt;code&gt;unsafe&lt;/code&gt; . Если после поиска метода он не может быть вызван по одной (или нескольким) из этих причин, результатом будет ошибка компилятора.</target>
        </trans-unit>
        <trans-unit id="1ff3edc7107794fccb9370413ce9f2edb3d33555" translate="yes" xml:space="preserve">
          <source>This process is just one of many ways to write software, but TDD can help drive code design as well. Writing the test before you write the code that makes the test pass helps to maintain high test coverage throughout the process.</source>
          <target state="translated">Этот процесс-всего лишь один из многих способов написания программного обеспечения,но TDD может помочь и в проектировании кода накопителя.Написание теста перед тем,как писать код,который делает тест пройденным,помогает поддерживать высокое тестовое покрытие на протяжении всего процесса.</target>
        </trans-unit>
        <trans-unit id="2a5870cc6149419aa4b701948d1d720f8c2eb21c" translate="yes" xml:space="preserve">
          <source>This program compiles without any errors and would also do so if we used &lt;code&gt;word&lt;/code&gt; after calling &lt;code&gt;s.clear()&lt;/code&gt;. Because &lt;code&gt;word&lt;/code&gt; isn&amp;rsquo;t connected to the state of &lt;code&gt;s&lt;/code&gt; at all, &lt;code&gt;word&lt;/code&gt; still contains the value &lt;code&gt;5&lt;/code&gt;. We could use that value &lt;code&gt;5&lt;/code&gt; with the variable &lt;code&gt;s&lt;/code&gt; to try to extract the first word out, but this would be a bug because the contents of &lt;code&gt;s&lt;/code&gt; have changed since we saved &lt;code&gt;5&lt;/code&gt; in &lt;code&gt;word&lt;/code&gt;.</source>
          <target state="translated">Эта программа компилируется без каких-либо ошибок, а также, если бы мы использовали &lt;code&gt;word&lt;/code&gt; после вызова &lt;code&gt;s.clear()&lt;/code&gt; . Поскольку &lt;code&gt;word&lt;/code&gt; вообще не связано с состоянием &lt;code&gt;s&lt;/code&gt; , &lt;code&gt;word&lt;/code&gt; прежнему содержит значение &lt;code&gt;5&lt;/code&gt; . Мы могли бы использовать это значение &lt;code&gt;5&lt;/code&gt; с переменной &lt;code&gt;s&lt;/code&gt; , чтобы попытаться извлечь первое слово, но это будет ошибкой, потому что содержимое &lt;code&gt;s&lt;/code&gt; изменилось с тех пор, как мы сохранили &lt;code&gt;5&lt;/code&gt; в &lt;code&gt;word&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a1a216c5bb2240db271ccf5242339067640e2983" translate="yes" xml:space="preserve">
          <source>This program creates a tuple, &lt;code&gt;x&lt;/code&gt;, and then makes new variables for each element by using their index. As with most programming languages, the first index in a tuple is 0.</source>
          <target state="translated">Эта программа создает кортеж &lt;code&gt;x&lt;/code&gt; , а затем создает новые переменные для каждого элемента, используя их индекс. Как и в большинстве языков программирования, первый индекс в кортеже равен 0.</target>
        </trans-unit>
        <trans-unit id="a953795409deaf59d9e6550cf24f5329cf86ee13" translate="yes" xml:space="preserve">
          <source>This program creates a tuple, &lt;code&gt;x&lt;/code&gt;, and then makes new variables for each element by using their respective indices. As with most programming languages, the first index in a tuple is 0.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="052f0899e565e8d2644e743be0e56bf26e6e1767" translate="yes" xml:space="preserve">
          <source>This program first binds &lt;code&gt;x&lt;/code&gt; to a value of &lt;code&gt;5&lt;/code&gt;. Then it shadows &lt;code&gt;x&lt;/code&gt; by repeating &lt;code&gt;let x =&lt;/code&gt;, taking the original value and adding &lt;code&gt;1&lt;/code&gt; so the value of &lt;code&gt;x&lt;/code&gt; is then &lt;code&gt;6&lt;/code&gt;. The third &lt;code&gt;let&lt;/code&gt; statement also shadows &lt;code&gt;x&lt;/code&gt;, multiplying the previous value by &lt;code&gt;2&lt;/code&gt; to give &lt;code&gt;x&lt;/code&gt; a final value of &lt;code&gt;12&lt;/code&gt;. When we run this program, it will output the following:</source>
          <target state="translated">Эта программа сначала связывает &lt;code&gt;x&lt;/code&gt; со значением &lt;code&gt;5&lt;/code&gt; . Затем он затеняет &lt;code&gt;x&lt;/code&gt; , повторяя &lt;code&gt;let x =&lt;/code&gt; , принимая исходное значение и добавляя &lt;code&gt;1&lt;/code&gt; , так что значение &lt;code&gt;x&lt;/code&gt; тогда равно &lt;code&gt;6&lt;/code&gt; . Третий оператор &lt;code&gt;let&lt;/code&gt; также затеняет &lt;code&gt;x&lt;/code&gt; , умножая предыдущее значение на &lt;code&gt;2&lt;/code&gt; , чтобы получить окончательное значение &lt;code&gt;x&lt;/code&gt; , равное &lt;code&gt;12&lt;/code&gt; . Когда мы запустим эту программу, она выдаст следующее:</target>
        </trans-unit>
        <trans-unit id="e37eff19d0df592c13224ef2e32fd74387b55f9e" translate="yes" xml:space="preserve">
          <source>This program first creates a tuple and binds it to the variable &lt;code&gt;tup&lt;/code&gt;. It then uses a pattern with &lt;code&gt;let&lt;/code&gt; to take &lt;code&gt;tup&lt;/code&gt; and turn it into three separate variables, &lt;code&gt;x&lt;/code&gt;, &lt;code&gt;y&lt;/code&gt;, and &lt;code&gt;z&lt;/code&gt;. This is called &lt;em&gt;destructuring&lt;/em&gt;, because it breaks the single tuple into three parts. Finally, the program prints the value of &lt;code&gt;y&lt;/code&gt;, which is &lt;code&gt;6.4&lt;/code&gt;.</source>
          <target state="translated">Эта программа сначала создает кортеж и связывает его с переменной &lt;code&gt;tup&lt;/code&gt; . Затем он использует шаблон с &lt;code&gt;let&lt;/code&gt; , чтобы взять &lt;code&gt;tup&lt;/code&gt; и превратить его в три отдельные переменные: &lt;code&gt;x&lt;/code&gt; , &lt;code&gt;y&lt;/code&gt; и &lt;code&gt;z&lt;/code&gt; . Это называется &lt;em&gt;деструктуризацией&lt;/em&gt; , поскольку она разбивает единый кортеж на три части. Наконец, программа выводит значение &lt;code&gt;y&lt;/code&gt; , равное &lt;code&gt;6.4&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e68e59981686f4d6d9628e4a0f06c39a18431f20" translate="yes" xml:space="preserve">
          <source>This program has four possible paths it can take. After running it, you should see the following output:</source>
          <target state="translated">У этой программы есть четыре возможных пути,которые она может использовать.После ее запуска вы должны увидеть следующий вывод:</target>
        </trans-unit>
        <trans-unit id="c268368ea9194ea4e99d8e793596c3443d5a9397" translate="yes" xml:space="preserve">
          <source>This project was a hands-on way to introduce you to many new Rust concepts: &lt;code&gt;let&lt;/code&gt;, &lt;code&gt;match&lt;/code&gt;, methods, associated functions, the use of external crates, and more. In the next few chapters, you&amp;rsquo;ll learn about these concepts in more detail. Chapter 3 covers concepts that most programming languages have, such as variables, data types, and functions, and shows how to use them in Rust. Chapter 4 explores ownership, a feature that makes Rust different from other languages. Chapter 5 discusses structs and method syntax, and Chapter 6 explains how enums work.</source>
          <target state="translated">Этот проект был практическим способом познакомить вас со многими новыми концепциями Rust: &lt;code&gt;let&lt;/code&gt; , &lt;code&gt;match&lt;/code&gt; , методы, связанные функции, использование внешних ящиков и многое другое. В следующих нескольких главах вы узнаете об этих концепциях более подробно. В главе 3 рассматриваются концепции, которые есть в большинстве языков программирования, такие как переменные, типы данных и функции, и показано, как их использовать в Rust. В главе 4 исследуется право собственности - функция, которая отличает Rust от других языков. В главе 5 обсуждаются структуры и синтаксис методов, а в главе 6 объясняется, как работают перечисления.</target>
        </trans-unit>
        <trans-unit id="9ce38c4decb31cc4f3034ac7fae7c79d93e80f53" translate="yes" xml:space="preserve">
          <source>This property cannot be checked by the compiler, and therefore &lt;code&gt;Eq&lt;/code&gt; implies &lt;a href=&quot;trait.partialeq&quot;&gt;&lt;code&gt;PartialEq&lt;/code&gt;&lt;/a&gt;, and has no extra methods.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ab41f4f49ac9b596f3ff341e670c3c513d2c2a1e" translate="yes" xml:space="preserve">
          <source>This property cannot be checked by the compiler, and therefore &lt;code&gt;Eq&lt;/code&gt; implies &lt;code&gt;PartialEq&lt;/code&gt;, and has no extra methods.</source>
          <target state="translated">Это свойство не может быть проверено компилятором, поэтому &lt;code&gt;Eq&lt;/code&gt; подразумевает &lt;code&gt;PartialEq&lt;/code&gt; и не имеет дополнительных методов.</target>
        </trans-unit>
        <trans-unit id="1608442363fd58986072b46f4e6a650827d3385c" translate="yes" xml:space="preserve">
          <source>This property is defined by &lt;a href=&quot;https://tools.ietf.org/html/rfc1122&quot;&gt;IETF RFC 1122&lt;/a&gt;.</source>
          <target state="translated">Это свойство определено &lt;a href=&quot;https://tools.ietf.org/html/rfc1122&quot;&gt;IETF RFC 1122&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="25a4736ccf9a4ba3c3e3dac30177800bc1f743c9" translate="yes" xml:space="preserve">
          <source>This property is defined by &lt;a href=&quot;https://tools.ietf.org/html/rfc3927&quot;&gt;IETF RFC 3927&lt;/a&gt;.</source>
          <target state="translated">Это свойство определено &lt;a href=&quot;https://tools.ietf.org/html/rfc3927&quot;&gt;IETF RFC 3927&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="2cdf66b6082611e25a822825249d22e6f28f1917" translate="yes" xml:space="preserve">
          <source>This property is defined by &lt;a href=&quot;https://tools.ietf.org/html/rfc4291&quot;&gt;IETF RFC 4291&lt;/a&gt;.</source>
          <target state="translated">Это свойство определено &lt;a href=&quot;https://tools.ietf.org/html/rfc4291&quot;&gt;IETF RFC 4291&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="93af0d07e68cafd035375823424d1e725ddb07d1" translate="yes" xml:space="preserve">
          <source>This property is defined in &lt;a href=&quot;https://tools.ietf.org/html/rfc3849&quot;&gt;IETF RFC 3849&lt;/a&gt;.</source>
          <target state="translated">Это свойство определено в &lt;a href=&quot;https://tools.ietf.org/html/rfc3849&quot;&gt;IETF RFC 3849&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="85df454e96ffa6c63ed8ab37d8086b690c9dba86" translate="yes" xml:space="preserve">
          <source>This property is defined in &lt;a href=&quot;https://tools.ietf.org/html/rfc4193&quot;&gt;IETF RFC 4193&lt;/a&gt;.</source>
          <target state="translated">Это свойство определено в &lt;a href=&quot;https://tools.ietf.org/html/rfc4193&quot;&gt;IETF RFC 4193&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="9d5a4dec1164aed352e96ad9af690b1a3591dc76" translate="yes" xml:space="preserve">
          <source>This property is defined in &lt;a href=&quot;https://tools.ietf.org/html/rfc4291&quot;&gt;IETF RFC 4291&lt;/a&gt;.</source>
          <target state="translated">Это свойство определено в &lt;a href=&quot;https://tools.ietf.org/html/rfc4291&quot;&gt;IETF RFC 4291&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="c731a3c6e670f4842c76f756fa1e0f4c4f1cfae6" translate="yes" xml:space="preserve">
          <source>This property is defined in &lt;em&gt;UNIX Network Programming, Second Edition&lt;/em&gt;, W. Richard Stevens, p. 891; see also &lt;a href=&quot;http://man7.org/linux/man-pages/man7/ip.7.html&quot;&gt;ip7&lt;/a&gt;.</source>
          <target state="translated">Это свойство определено в &lt;em&gt;UNIX Network Programming, Second Edition&lt;/em&gt; , W. Richard Stevens, p. 891; см. также &lt;a href=&quot;http://man7.org/linux/man-pages/man7/ip.7.html&quot;&gt;ip7&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="19926d7df32802514fef095810b287a92fa4b874" translate="yes" xml:space="preserve">
          <source>This queue has &lt;code&gt;O(1)&lt;/code&gt; amortized inserts and removals from both ends of the container. It also has &lt;code&gt;O(1)&lt;/code&gt; indexing like a vector. The contained elements are not required to be copyable, and the queue will be sendable if the contained type is sendable.</source>
          <target state="translated">Эта очередь имеет &lt;code&gt;O(1)&lt;/code&gt; амортизированных вставок и удалений с обоих концов контейнера. Он также имеет индексацию &lt;code&gt;O(1)&lt;/code&gt; как вектор. Содержащиеся элементы не обязательно должны быть копируемыми, и очередь будет доступна для отправки, если содержащийся тип является отправляемым.</target>
        </trans-unit>
        <trans-unit id="f222b6950bf888a7c8ce05739a640f15b3f1b84f" translate="yes" xml:space="preserve">
          <source>This queue has &lt;em&gt;O&lt;/em&gt;(1) amortized inserts and removals from both ends of the container. It also has &lt;em&gt;O&lt;/em&gt;(1) indexing like a vector. The contained elements are not required to be copyable, and the queue will be sendable if the contained type is sendable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ae16a9ff1b9b0bb4dc2773f7faab160bd7347257" translate="yes" xml:space="preserve">
          <source>This reader has reached its &quot;end of file&quot; and will likely no longer be able to produce bytes. Note that this does not mean that the reader will &lt;em&gt;always&lt;/em&gt; no longer be able to produce bytes.</source>
          <target state="translated">Этот считыватель достиг &amp;laquo;конца файла&amp;raquo; и, скорее всего, больше не сможет создавать байты. Обратите внимание , что это не значит , что читатель будет &lt;em&gt;всегда&lt;/em&gt; больше не будет в состоянии производить байт.</target>
        </trans-unit>
        <trans-unit id="eabbe1cac74b5970cf00777c8a04a9b08b503051" translate="yes" xml:space="preserve">
          <source>This reordering has the additional property that any value at position &lt;code&gt;i &amp;lt; index&lt;/code&gt; will be less than or equal to any value at a position &lt;code&gt;j &amp;gt; index&lt;/code&gt; using the comparator function. Additionally, this reordering is unstable (i.e. any number of equal elements may end up at position &lt;code&gt;index&lt;/code&gt;), in-place (i.e. does not allocate), and &lt;code&gt;O(n)&lt;/code&gt; worst-case. This function is also known as &quot;kth element&quot; in other libraries. It returns a triplet of the following values: all elements less than the one at the given index, the value at the given index, and all elements greater than the one at the given index, using the provided comparator function.</source>
          <target state="translated">Это переупорядочение имеет дополнительное свойство: любое значение в позиции &lt;code&gt;i &amp;lt; index&lt;/code&gt; будет меньше или равно любому значению в позиции &lt;code&gt;j &amp;gt; index&lt;/code&gt; с использованием функции компаратора. Кроме того, это переупорядочение является нестабильным (т.е. любое количество одинаковых элементов может оказаться в &lt;code&gt;index&lt;/code&gt; позиции ), на месте (то есть не распределяется) и в худшем случае &lt;code&gt;O(n)&lt;/code&gt; . Эта функция также известна как &amp;laquo;k-й элемент&amp;raquo; в других библиотеках. Он возвращает тройку следующих значений: все элементы, меньшие, чем один в данном индексе, значение в данном индексе и все элементы больше, чем один в данном индексе, с использованием предоставленной функции компаратора.</target>
        </trans-unit>
        <trans-unit id="5a5e3f81a187820f825f4369ca83b2c286d9273d" translate="yes" xml:space="preserve">
          <source>This reordering has the additional property that any value at position &lt;code&gt;i &amp;lt; index&lt;/code&gt; will be less than or equal to any value at a position &lt;code&gt;j &amp;gt; index&lt;/code&gt; using the comparator function. Additionally, this reordering is unstable (i.e. any number of equal elements may end up at position &lt;code&gt;index&lt;/code&gt;), in-place (i.e. does not allocate), and &lt;em&gt;O&lt;/em&gt;(&lt;em&gt;n&lt;/em&gt;) worst-case. This function is also known as &quot;kth element&quot; in other libraries. It returns a triplet of the following values: all elements less than the one at the given index, the value at the given index, and all elements greater than the one at the given index, using the provided comparator function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="58333e6fd2204efb6d059b5e0ebaa3ad2ae11cea" translate="yes" xml:space="preserve">
          <source>This reordering has the additional property that any value at position &lt;code&gt;i &amp;lt; index&lt;/code&gt; will be less than or equal to any value at a position &lt;code&gt;j &amp;gt; index&lt;/code&gt; using the key extraction function. Additionally, this reordering is unstable (i.e. any number of equal elements may end up at position &lt;code&gt;index&lt;/code&gt;), in-place (i.e. does not allocate), and &lt;code&gt;O(n)&lt;/code&gt; worst-case. This function is also known as &quot;kth element&quot; in other libraries. It returns a triplet of the following values: all elements less than the one at the given index, the value at the given index, and all elements greater than the one at the given index, using the provided key extraction function.</source>
          <target state="translated">Это переупорядочение имеет дополнительное свойство: любое значение в позиции &lt;code&gt;i &amp;lt; index&lt;/code&gt; будет меньше или равно любому значению в позиции &lt;code&gt;j &amp;gt; index&lt;/code&gt; с использованием функции извлечения ключа. Кроме того, это переупорядочение является нестабильным (т.е. любое количество одинаковых элементов может оказаться в &lt;code&gt;index&lt;/code&gt; позиции ), на месте (то есть не распределяется) и в худшем случае &lt;code&gt;O(n)&lt;/code&gt; . Эта функция также известна как &amp;laquo;k-й элемент&amp;raquo; в других библиотеках. Он возвращает триплет из следующих значений: все элементы, меньшие, чем один в данном индексе, значение в данном индексе и все элементы, большие, чем один в данном индексе, с использованием предоставленной функции извлечения ключа.</target>
        </trans-unit>
        <trans-unit id="c83a0af8a141703ce8a894f271d81b6b5d0d2d99" translate="yes" xml:space="preserve">
          <source>This reordering has the additional property that any value at position &lt;code&gt;i &amp;lt; index&lt;/code&gt; will be less than or equal to any value at a position &lt;code&gt;j &amp;gt; index&lt;/code&gt; using the key extraction function. Additionally, this reordering is unstable (i.e. any number of equal elements may end up at position &lt;code&gt;index&lt;/code&gt;), in-place (i.e. does not allocate), and &lt;em&gt;O&lt;/em&gt;(&lt;em&gt;n&lt;/em&gt;) worst-case. This function is also known as &quot;kth element&quot; in other libraries. It returns a triplet of the following values: all elements less than the one at the given index, the value at the given index, and all elements greater than the one at the given index, using the provided key extraction function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="18b0ecb2451beab6446b7792a5f32ac5b93e64f7" translate="yes" xml:space="preserve">
          <source>This reordering has the additional property that any value at position &lt;code&gt;i &amp;lt; index&lt;/code&gt; will be less than or equal to any value at a position &lt;code&gt;j &amp;gt; index&lt;/code&gt;. Additionally, this reordering is unstable (i.e. any number of equal elements may end up at position &lt;code&gt;index&lt;/code&gt;), in-place (i.e. does not allocate), and &lt;code&gt;O(n)&lt;/code&gt; worst-case. This function is also/ known as &quot;kth element&quot; in other libraries. It returns a triplet of the following values: all elements less than the one at the given index, the value at the given index, and all elements greater than the one at the given index.</source>
          <target state="translated">Это переупорядочение имеет дополнительное свойство: любое значение в позиции &lt;code&gt;i &amp;lt; index&lt;/code&gt; будет меньше или равно любому значению в позиции &lt;code&gt;j &amp;gt; index&lt;/code&gt; . Кроме того, это переупорядочение является нестабильным (т.е. любое количество одинаковых элементов может оказаться в &lt;code&gt;index&lt;/code&gt; позиции ), на месте (то есть не распределяется) и в худшем случае &lt;code&gt;O(n)&lt;/code&gt; . Эта функция также известна как &amp;laquo;k-й элемент&amp;raquo; в других библиотеках. Он возвращает тройку следующих значений: все элементы, меньшие, чем один в данном индексе, значение в данном индексе и все элементы, большие, чем один в данном индексе.</target>
        </trans-unit>
        <trans-unit id="3d259af27d2572df43e2afe02e6f4d51f6ff06a9" translate="yes" xml:space="preserve">
          <source>This reordering has the additional property that any value at position &lt;code&gt;i &amp;lt; index&lt;/code&gt; will be less than or equal to any value at a position &lt;code&gt;j &amp;gt; index&lt;/code&gt;. Additionally, this reordering is unstable (i.e. any number of equal elements may end up at position &lt;code&gt;index&lt;/code&gt;), in-place (i.e. does not allocate), and &lt;em&gt;O&lt;/em&gt;(&lt;em&gt;n&lt;/em&gt;) worst-case. This function is also/ known as &quot;kth element&quot; in other libraries. It returns a triplet of the following values: all elements less than the one at the given index, the value at the given index, and all elements greater than the one at the given index.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6a44d46360998129b78ed15d687f727979c543e5" translate="yes" xml:space="preserve">
          <source>This representation can be applied to structs, unions, and enums.</source>
          <target state="translated">Это представительство может быть применено к структурам,союзам и переписям.</target>
        </trans-unit>
        <trans-unit id="c79281349d10df09672689425c0c484e6ef587c0" translate="yes" xml:space="preserve">
          <source>This representation can be applied to structs, unions, and enums. The exception is &lt;a href=&quot;items/enumerations#zero-variant-enums&quot;&gt;zero-variant enums&lt;/a&gt; for which the &lt;code&gt;C&lt;/code&gt; representation is an error.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="54d003da75e5c18c6d78ec752d4c5ea2c1005e03" translate="yes" xml:space="preserve">
          <source>This requires that the data inside this &lt;code&gt;Pin&lt;/code&gt; is &lt;a href=&quot;../marker/trait.unpin&quot;&gt;&lt;code&gt;Unpin&lt;/code&gt;&lt;/a&gt; so that we can ignore the pinning invariants when unwrapping it.</source>
          <target state="translated">Это требует, чтобы данные внутри этого &lt;code&gt;Pin&lt;/code&gt; является &lt;a href=&quot;../marker/trait.unpin&quot;&gt; &lt;code&gt;Unpin&lt;/code&gt; &lt;/a&gt; , так что мы можем игнорировать пиннинга инварианты при разворачивая его.</target>
        </trans-unit>
        <trans-unit id="84a024e08861a138f89bc49f72665722f5345893" translate="yes" xml:space="preserve">
          <source>This requires that the data inside this &lt;code&gt;Pin&lt;/code&gt; is &lt;code&gt;Unpin&lt;/code&gt;.</source>
          <target state="translated">Это требует, чтобы данные внутри этого &lt;code&gt;Pin&lt;/code&gt; является &lt;code&gt;Unpin&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="bb8049ba5b3a969809828fb6b20b4c6f803c243a" translate="yes" xml:space="preserve">
          <source>This restriction allows for mutation but in a very controlled fashion. It&amp;rsquo;s something that new Rustaceans struggle with, because most languages let you mutate whenever you&amp;rsquo;d like.</source>
          <target state="translated">Это ограничение допускает мутацию, но очень контролируемым образом. Это то, с чем борются новые Rustaceans, потому что большинство языков позволяют мутировать, когда захотите.</target>
        </trans-unit>
        <trans-unit id="b9005ee922bd85c1b8cdd5bf9e647bc71bc7e1d1" translate="yes" xml:space="preserve">
          <source>This restricts us to a &lt;code&gt;Screen&lt;/code&gt; instance that has a list of components all of type &lt;code&gt;Button&lt;/code&gt; or all of type &lt;code&gt;TextField&lt;/code&gt;. If you&amp;rsquo;ll only ever have homogeneous collections, using generics and trait bounds is preferable because the definitions will be monomorphized at compile time to use the concrete types.</source>
          <target state="translated">Это ограничивает нас экземпляром &lt;code&gt;Screen&lt;/code&gt; , который имеет список компонентов типа &lt;code&gt;Button&lt;/code&gt; или всех типов &lt;code&gt;TextField&lt;/code&gt; . Если у вас когда-либо будут только однородные коллекции, предпочтительнее использовать обобщенные типы и границы признаков, поскольку определения будут мономорфизированы во время компиляции для использования конкретных типов.</target>
        </trans-unit>
        <trans-unit id="fef61557094c53c94d8f4b9c87d239c1c4ddf6a3" translate="yes" xml:space="preserve">
          <source>This result just indicates that the assertion failed and which line the assertion is on. A more useful failure message in this case would print the value we got from the &lt;code&gt;greeting&lt;/code&gt; function. Let&amp;rsquo;s change the test function, giving it a custom failure message made from a format string with a placeholder filled in with the actual value we got from the &lt;code&gt;greeting&lt;/code&gt; function:</source>
          <target state="translated">Этот результат просто указывает на то, что утверждение не выполнено и на какой строке находится утверждение. Более полезное сообщение об ошибке в этом случае будет выводить значение, которое мы получили от функции &lt;code&gt;greeting&lt;/code&gt; . Давайте изменим тестовую функцию, предоставив ей настраиваемое сообщение об ошибке, созданное из строки формата с заполнителем, заполненным фактическим значением, полученным от функции &lt;code&gt;greeting&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="0886cd5bf439fbbc8be3535b3d5401de7c87877b" translate="yes" xml:space="preserve">
          <source>This return type means the call to &lt;code&gt;File::open&lt;/code&gt; might succeed and return a file handle that we can read from or write to. The function call also might fail: for example, the file might not exist, or we might not have permission to access the file. The &lt;code&gt;File::open&lt;/code&gt; function needs to have a way to tell us whether it succeeded or failed and at the same time give us either the file handle or error information. This information is exactly what the &lt;code&gt;Result&lt;/code&gt; enum conveys.</source>
          <target state="translated">Этот тип возврата означает, что вызов &lt;code&gt;File::open&lt;/code&gt; может быть успешным и вернуть дескриптор файла, из которого мы можем читать или писать. Вызов функции также может завершиться ошибкой: например, файл может не существовать или у нас может не быть разрешения на доступ к файлу. Функция &lt;code&gt;File::open&lt;/code&gt; должна иметь способ сообщить нам, удалась она или нет, и в то же время предоставить нам либо дескриптор файла, либо информацию об ошибке. Именно эту информацию передает перечисление &lt;code&gt;Result&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6e6467b9314c67467a583133eaf79a55bec1323c" translate="yes" xml:space="preserve">
          <source>This returns &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt; if the working directory will not be changed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c7256f6dfb124c4206009cc4970395f092ae3141" translate="yes" xml:space="preserve">
          <source>This returns &lt;code&gt;None&lt;/code&gt; if the cursor is currently pointing to the &quot;ghost&quot; non-element.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2b3770e7d2efd1b08fe66eb571f2a780fb54e25f" translate="yes" xml:space="preserve">
          <source>This returns a numeric identifier for the thread identified by this &lt;code&gt;ThreadId&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="368beec57f1181b8799a91ee73ada8b4184da78e" translate="yes" xml:space="preserve">
          <source>This reuses all the nodes from &lt;code&gt;other&lt;/code&gt; and moves them into &lt;code&gt;self&lt;/code&gt;. After this operation, &lt;code&gt;other&lt;/code&gt; becomes empty.</source>
          <target state="translated">Это повторно использует все узлы из &lt;code&gt;other&lt;/code&gt; и перемещает их в &lt;code&gt;self&lt;/code&gt; . После этой операции &lt;code&gt;other&lt;/code&gt; становится пустым.</target>
        </trans-unit>
        <trans-unit id="7730271090bac7f074841851b1b821f9fc7fca43" translate="yes" xml:space="preserve">
          <source>This rework may seem like overkill for our small program, but we&amp;rsquo;re refactoring in small, incremental steps. After making this change, run the program again to verify that the argument parsing still works. It&amp;rsquo;s good to check your progress often, to help identify the cause of problems when they occur.</source>
          <target state="translated">Эта переделка может показаться излишней для нашей небольшой программы, но мы проводим рефакторинг небольшими, постепенными шагами. После внесения этого изменения запустите программу еще раз, чтобы убедиться, что синтаксический анализ аргументов все еще работает. Полезно часто проверять свой прогресс, чтобы определять причину проблем, когда они возникают.</target>
        </trans-unit>
        <trans-unit id="c68a9d1019f31cc86d07a97f90c903ea86167b11" translate="yes" xml:space="preserve">
          <source>This rule also applies to type parameters of impl blocks that contain const methods</source>
          <target state="translated">Это правило распространяется также на типовые параметры блоков имплантатов,которые содержат методы const</target>
        </trans-unit>
        <trans-unit id="c9e400474c407c09b7fb37164368bcd30fbe8830" translate="yes" xml:space="preserve">
          <source>This runs the code in &lt;em&gt;adder/src/main.rs&lt;/em&gt;, which depends on the &lt;code&gt;add-one&lt;/code&gt; crate.</source>
          <target state="translated">Это запускает код в &lt;em&gt;adder / src / main.rs&lt;/em&gt; , который зависит от &lt;em&gt;контейнера &lt;/em&gt; &lt;code&gt;add-one&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e6b2224800e73c42ee25267c2896a776ab41e710" translate="yes" xml:space="preserve">
          <source>This section documents features that affect the ABI of the compiled output of a crate.</source>
          <target state="translated">В этом разделе описаны особенности,влияющие на ABI скомпилированного вывода ящика.</target>
        </trans-unit>
        <trans-unit id="7dc2765b02ef149354a7a9ee16a696edf0827240" translate="yes" xml:space="preserve">
          <source>This section documents features that define some aspects of the Rust runtime.</source>
          <target state="translated">В этом разделе описаны функции,определяющие некоторые аспекты выполнения Rust.</target>
        </trans-unit>
        <trans-unit id="f7c12226b9e0c0ca24fa6bdd6239b023bf8ef3a4" translate="yes" xml:space="preserve">
          <source>This should only ever be called with a pointer that was earlier obtained by calling &lt;a href=&quot;#method.into_raw&quot;&gt;&lt;code&gt;into_raw&lt;/code&gt;&lt;/a&gt; on a &lt;code&gt;CString&lt;/code&gt;. Other usage (e.g., trying to take ownership of a string that was allocated by foreign code) is likely to lead to undefined behavior or allocator corruption.</source>
          <target state="translated">Это должно вызываться только с указателем, который был ранее получен путем вызова &lt;a href=&quot;#method.into_raw&quot;&gt; &lt;code&gt;into_raw&lt;/code&gt; &lt;/a&gt; для &lt;code&gt;CString&lt;/code&gt; . Другое использование (например, попытка стать владельцем строки, выделенной внешним кодом) может привести к неопределенному поведению или повреждению распределителя.</target>
        </trans-unit>
        <trans-unit id="bb13fd72f340b7885313dcc12025456f86beff96" translate="yes" xml:space="preserve">
          <source>This should only ever be called with a pointer that was earlier obtained by calling &lt;a href=&quot;struct.cstring#method.into_raw&quot;&gt;&lt;code&gt;CString::into_raw&lt;/code&gt;&lt;/a&gt;. Other usage (e.g., trying to take ownership of a string that was allocated by foreign code) is likely to lead to undefined behavior or allocator corruption.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6de4781e84fd1ffb8326c915806ff4604cbf7406" translate="yes" xml:space="preserve">
          <source>This shows the source code file with the &lt;em&gt;.rs&lt;/em&gt; extension, the executable file (&lt;em&gt;main.exe&lt;/em&gt; on Windows, but &lt;em&gt;main&lt;/em&gt; on all other platforms), and, when using Windows, a file containing debugging information with the &lt;em&gt;.pdb&lt;/em&gt; extension. From here, you run the &lt;em&gt;main&lt;/em&gt; or &lt;em&gt;main.exe&lt;/em&gt; file, like this:</source>
          <target state="translated">Здесь показаны файл исходного кода с расширением &lt;em&gt;.rs&lt;/em&gt; , исполняемый файл ( &lt;em&gt;main.exe&lt;/em&gt; в Windows, но &lt;em&gt;main&lt;/em&gt; на всех других платформах) и, при использовании Windows, файл, содержащий отладочную информацию с расширением &lt;em&gt;.pdb&lt;/em&gt; . Отсюда вы запускаете файл &lt;em&gt;main&lt;/em&gt; или &lt;em&gt;main.exe&lt;/em&gt; , например:</target>
        </trans-unit>
        <trans-unit id="9575f8046ce99c60fbe347fdb162c3debc44c697" translate="yes" xml:space="preserve">
          <source>This slice has the type &lt;code&gt;&amp;amp;[i32]&lt;/code&gt;. It works the same way as string slices do, by storing a reference to the first element and a length. You&amp;rsquo;ll use this kind of slice for all sorts of other collections. We&amp;rsquo;ll discuss these collections in detail when we talk about vectors in Chapter 8.</source>
          <target state="translated">Этот фрагмент имеет тип &lt;code&gt;&amp;amp;[i32]&lt;/code&gt; . Он работает так же, как и строковые фрагменты, сохраняя ссылку на первый элемент и длину. Вы будете использовать этот вид среза для множества других коллекций. Мы обсудим эти коллекции подробно, когда будем говорить о векторах в главе 8.</target>
        </trans-unit>
        <trans-unit id="d65fb4bd24471a81f14e38e503058f70c64833b3" translate="yes" xml:space="preserve">
          <source>This sort is stable (i.e., does not reorder equal elements) and &lt;code&gt;O(m * n * log(n))&lt;/code&gt; worst-case, where the key function is &lt;code&gt;O(m)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b5c9c4b26823864ca42f73d970b5f61574652362" translate="yes" xml:space="preserve">
          <source>This sort is stable (i.e., does not reorder equal elements) and &lt;code&gt;O(m * n + n * log(n))&lt;/code&gt; worst-case, where the key function is &lt;code&gt;O(m)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b3fe498c20a11bda205dc93f4390f850884c310c" translate="yes" xml:space="preserve">
          <source>This sort is stable (i.e., does not reorder equal elements) and &lt;code&gt;O(m n + n log n)&lt;/code&gt; worst-case, where the key function is &lt;code&gt;O(m)&lt;/code&gt;.</source>
          <target state="translated">Эта сортировка является стабильной (т. Е. Не переупорядочивает одинаковые элементы) и &lt;code&gt;O(m n + n log n)&lt;/code&gt; худшем случае, когда ключевой функцией является &lt;code&gt;O(m)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="04ff5f9e434224075f07c47221408f586ed69430" translate="yes" xml:space="preserve">
          <source>This sort is stable (i.e., does not reorder equal elements) and &lt;code&gt;O(m n log(m n))&lt;/code&gt; worst-case, where the key function is &lt;code&gt;O(m)&lt;/code&gt;.</source>
          <target state="translated">Эта сортировка является стабильной (т. Е. Не переупорядочивает одинаковые элементы) и &lt;code&gt;O(m n log(m n))&lt;/code&gt; худшем случае, когда ключевой функцией является &lt;code&gt;O(m)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="13defa388ad16a8832cba0851748fe2d9c59598b" translate="yes" xml:space="preserve">
          <source>This sort is stable (i.e., does not reorder equal elements) and &lt;code&gt;O(n * log(n))&lt;/code&gt; worst-case.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="29bb618262e9818d4542507320a836e4faf4b56f" translate="yes" xml:space="preserve">
          <source>This sort is stable (i.e., does not reorder equal elements) and &lt;code&gt;O(n log n)&lt;/code&gt; worst-case.</source>
          <target state="translated">Эта сортировка является стабильной (т. Е. Не переупорядочивает одинаковые элементы) и &lt;code&gt;O(n log n)&lt;/code&gt; худшем случае.</target>
        </trans-unit>
        <trans-unit id="342fc35a79498863eed086153ecf4de54d803470" translate="yes" xml:space="preserve">
          <source>This sort is stable (i.e., does not reorder equal elements) and &lt;em&gt;O&lt;/em&gt;(&lt;em&gt;m&lt;/em&gt; * &lt;em&gt;n&lt;/em&gt; * log(&lt;em&gt;n&lt;/em&gt;)) worst-case, where the key function is &lt;em&gt;O&lt;/em&gt;(&lt;em&gt;m&lt;/em&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b9e6ed2e7770cad1c08fcd52e4c75266e91bca66" translate="yes" xml:space="preserve">
          <source>This sort is stable (i.e., does not reorder equal elements) and &lt;em&gt;O&lt;/em&gt;(&lt;em&gt;m&lt;/em&gt; * &lt;em&gt;n&lt;/em&gt; + &lt;em&gt;n&lt;/em&gt; * log(&lt;em&gt;n&lt;/em&gt;)) worst-case, where the key function is &lt;em&gt;O&lt;/em&gt;(&lt;em&gt;m&lt;/em&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b0fa553880d5f214b25277a39b204d8402684264" translate="yes" xml:space="preserve">
          <source>This sort is stable (i.e., does not reorder equal elements) and &lt;em&gt;O&lt;/em&gt;(&lt;em&gt;n&lt;/em&gt; * log(&lt;em&gt;n&lt;/em&gt;)) worst-case.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f8094b9acbcdfe817a2beca8fbbfd03d36adf019" translate="yes" xml:space="preserve">
          <source>This sort is unstable (i.e., may reorder equal elements), in-place (i.e., does not allocate), and &lt;code&gt;O(m n log(m n))&lt;/code&gt; worst-case, where the key function is &lt;code&gt;O(m)&lt;/code&gt;.</source>
          <target state="translated">Эта сортировка является нестабильной (т. Е. Может переупорядочивать одинаковые элементы), на месте (т. Е. Не выделяет) и в худшем случае &lt;code&gt;O(m n log(m n))&lt;/code&gt; , где ключевой функцией является &lt;code&gt;O(m)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2e852a79da20e649bf213cb6826ee95c589ae984" translate="yes" xml:space="preserve">
          <source>This sort is unstable (i.e., may reorder equal elements), in-place (i.e., does not allocate), and &lt;code&gt;O(n log n)&lt;/code&gt; worst-case.</source>
          <target state="translated">Эта сортировка является нестабильной (т. Е. Может переупорядочивать одинаковые элементы), на месте (т. Е. Не выделяет) и в худшем случае &lt;code&gt;O(n log n)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3d7156d28541cb0cabeaa7410dd06cdaa9199652" translate="yes" xml:space="preserve">
          <source>This sort is unstable (i.e., may reorder equal elements), in-place (i.e., does not allocate), and &lt;em&gt;O&lt;/em&gt;(&lt;em&gt;n&lt;/em&gt; * log(&lt;em&gt;n&lt;/em&gt;)) worst-case.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b3e0c73c0881bd5d99646c6bd52683bfabd1a90e" translate="yes" xml:space="preserve">
          <source>This sort is unstable (i.e., may reorder equal elements), in-place (i.e., does not allocate), and &lt;em&gt;O&lt;/em&gt;(m * &lt;em&gt;n&lt;/em&gt; * log(&lt;em&gt;n&lt;/em&gt;)) worst-case, where the key function is &lt;em&gt;O&lt;/em&gt;(&lt;em&gt;m&lt;/em&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7b9136d07194a4e8e43750309da02e688255bd47" translate="yes" xml:space="preserve">
          <source>This sort of behavior has been known to &lt;a href=&quot;https://securityvulns.com/Wdocument183.html&quot;&gt;lead to privilege escalation&lt;/a&gt; when used incorrectly.</source>
          <target state="translated">Известно, что такое поведение при неправильном использовании &lt;a href=&quot;https://securityvulns.com/Wdocument183.html&quot;&gt;приводит к повышению привилегий&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="4609a563600ff8952232a98685a394486b72fb56" translate="yes" xml:space="preserve">
          <source>This state indicates that a generator has been suspended, and typically corresponds to a &lt;code&gt;yield&lt;/code&gt; statement. The value provided in this variant corresponds to the expression passed to &lt;code&gt;yield&lt;/code&gt; and allows generators to provide a value each time they yield.</source>
          <target state="translated">Это состояние указывает, что генератор приостановлен, и обычно соответствует оператору &lt;code&gt;yield&lt;/code&gt; . Значение, указанное в этом варианте, соответствует выражению, переданному в &lt;code&gt;yield&lt;/code&gt; , и позволяет генераторам предоставлять значение каждый раз, когда они возвращают результат.</target>
        </trans-unit>
        <trans-unit id="90c88a5ca708244c3219f050c7309e58bf365755" translate="yes" xml:space="preserve">
          <source>This state indicates that a generator has finished execution with the provided value. Once a generator has returned &lt;code&gt;Complete&lt;/code&gt; it is considered a programmer error to call &lt;code&gt;resume&lt;/code&gt; again.</source>
          <target state="translated">Это состояние указывает на то, что генератор завершил выполнение с предоставленным значением. После того, как генератор вернул &lt;code&gt;Complete&lt;/code&gt; повторный вызов &lt;code&gt;resume&lt;/code&gt; считается ошибкой программиста .</target>
        </trans-unit>
        <trans-unit id="7be578f8354e75e786ae7f8a72194e570efdeae6" translate="yes" xml:space="preserve">
          <source>This stream will be ignored. This is the equivalent of attaching the stream to &lt;code&gt;/dev/null&lt;/code&gt;</source>
          <target state="translated">Этот поток будет проигнорирован. Это эквивалент присоединения потока к &lt;code&gt;/dev/null&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="86aaaf1ade8618d076dfddfcf43a493fbd9d9208" translate="yes" xml:space="preserve">
          <source>This stream will be ignored. This is the equivalent of attaching the stream to &lt;code&gt;/dev/null&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="047e86b07f343619951ab342d709e9864cc54c3d" translate="yes" xml:space="preserve">
          <source>This struct has one field, &lt;code&gt;part&lt;/code&gt;, that holds a string slice, which is a reference. As with generic data types, we declare the name of the generic lifetime parameter inside angle brackets after the name of the struct so we can use the lifetime parameter in the body of the struct definition. This annotation means an instance of &lt;code&gt;ImportantExcerpt&lt;/code&gt; can&amp;rsquo;t outlive the reference it holds in its &lt;code&gt;part&lt;/code&gt; field.</source>
          <target state="translated">Эта структура имеет одно поле, &lt;code&gt;part&lt;/code&gt; , которое содержит фрагмент строки, который является ссылкой. Как и в случае с универсальными типами данных, мы объявляем имя универсального параметра времени жизни в угловых скобках после имени структуры, чтобы мы могли использовать параметр времени жизни в теле определения структуры. Эта аннотация означает, что экземпляр &lt;code&gt;ImportantExcerpt&lt;/code&gt; не может пережить ссылку, содержащуюся в его поле &lt;code&gt;part&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="035a190c93ffcb98a162f4a1c124850fba76f70b" translate="yes" xml:space="preserve">
          <source>This struct has the same layout as types like &lt;code&gt;&amp;amp;SomeTrait&lt;/code&gt; and &lt;code&gt;Box&amp;lt;dyn AnotherTrait&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">Эта структура имеет тот же макет, что и типы, такие как &lt;code&gt;&amp;amp;SomeTrait&lt;/code&gt; и &lt;code&gt;Box&amp;lt;dyn AnotherTrait&amp;gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8bcde4812fcc7ef55a0760fedbc39c027f9accb6" translate="yes" xml:space="preserve">
          <source>This struct has the same layout as types like &lt;code&gt;&amp;amp;dyn SomeTrait&lt;/code&gt; and &lt;code&gt;Box&amp;lt;dyn AnotherTrait&amp;gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="78fc6455134464feceba11cc2db121b5a8d643b0" translate="yes" xml:space="preserve">
          <source>This struct is a helper to be used with functions like &lt;a href=&quot;../vec/struct.vec#method.sort_by_key&quot;&gt;&lt;code&gt;Vec::sort_by_key&lt;/code&gt;&lt;/a&gt; and can be used to reverse order a part of a key.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="698bb1f1506a6aa8b90b6f64dc7e32c0c5091a12" translate="yes" xml:space="preserve">
          <source>This struct is a helper to be used with functions like &lt;code&gt;Vec::sort_by_key&lt;/code&gt; and can be used to reverse order a part of a key.</source>
          <target state="translated">Эта структура является помощником для использования с такими функциями, как &lt;code&gt;Vec::sort_by_key&lt;/code&gt; и может использоваться для изменения порядка части ключа.</target>
        </trans-unit>
        <trans-unit id="84ced59217a045f0ae6136d2f9bd0162d392046f" translate="yes" xml:space="preserve">
          <source>This struct is created by &lt;a href=&quot;fn.args&quot;&gt;&lt;code&gt;env::args()&lt;/code&gt;&lt;/a&gt;. See its documentation for more.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="421112f55866033bf937c2c2104c004765f83d6c" translate="yes" xml:space="preserve">
          <source>This struct is created by &lt;a href=&quot;fn.args_os&quot;&gt;&lt;code&gt;env::args_os()&lt;/code&gt;&lt;/a&gt;. See its documentation for more.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6d98990c007f08843ac1df1a07fad048ba02e034" translate="yes" xml:space="preserve">
          <source>This struct is created by &lt;a href=&quot;struct.command#method.get_args&quot;&gt;&lt;code&gt;Command::get_args&lt;/code&gt;&lt;/a&gt;. See its documentation for more.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c34405b53d7303b0dec8e54e6aa5a0abefbaa23c" translate="yes" xml:space="preserve">
          <source>This struct is created by &lt;a href=&quot;struct.command#method.get_envs&quot;&gt;&lt;code&gt;Command::get_envs&lt;/code&gt;&lt;/a&gt;. See its documentation for more.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2147718c894a448fcb5bace3573d8c66021b6ecf" translate="yes" xml:space="preserve">
          <source>This struct is created by &lt;a href=&quot;struct.vec#method.drain_filter&quot;&gt;&lt;code&gt;Vec::drain_filter&lt;/code&gt;&lt;/a&gt;. See its documentation for more.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3b56bd91b0140c9f3d261bb2e7de1a84ee87136c" translate="yes" xml:space="preserve">
          <source>This struct is created by &lt;a href=&quot;struct.vec#method.splice&quot;&gt;&lt;code&gt;Vec::splice()&lt;/code&gt;&lt;/a&gt;. See its documentation for more.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3b94fdb25d3a1999fbb00df483466c3f3ad93974" translate="yes" xml:space="preserve">
          <source>This struct is created by the &lt;a href=&quot;../iter/trait.intoiterator#tymethod.into_iter&quot;&gt;&lt;code&gt;into_iter&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;enum.result&quot;&gt;&lt;code&gt;Result&lt;/code&gt;&lt;/a&gt; (provided by the &lt;a href=&quot;../iter/trait.intoiterator&quot;&gt;&lt;code&gt;IntoIterator&lt;/code&gt;&lt;/a&gt; trait).</source>
          <target state="translated">Эта структура создается методом &lt;a href=&quot;../iter/trait.intoiterator#tymethod.into_iter&quot;&gt; &lt;code&gt;into_iter&lt;/code&gt; &lt;/a&gt; для &lt;a href=&quot;enum.result&quot;&gt; &lt;code&gt;Result&lt;/code&gt; &lt;/a&gt; (предоставляется &lt;a href=&quot;../iter/trait.intoiterator&quot;&gt; &lt;code&gt;IntoIterator&lt;/code&gt; &lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="0f993739b1a6e12d97f61853ab3a7aeead8ab4b9" translate="yes" xml:space="preserve">
          <source>This struct is created by the &lt;a href=&quot;../primitive.slice#method.array_chunks&quot;&gt;&lt;code&gt;array_chunks&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;../primitive.slice&quot;&gt;slices&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="306d58f57f3d10dc00f2031814b48c48929d8df3" translate="yes" xml:space="preserve">
          <source>This struct is created by the &lt;a href=&quot;../primitive.slice#method.array_chunks_mut&quot;&gt;&lt;code&gt;array_chunks_mut&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;../primitive.slice&quot;&gt;slices&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0f3c9f948ac0eb252b070770390b8ad86aa3b895" translate="yes" xml:space="preserve">
          <source>This struct is created by the &lt;a href=&quot;../primitive.slice#method.array_windows&quot;&gt;&lt;code&gt;array_windows&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;../primitive.slice&quot;&gt;slices&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1dd8330957d499a2a2bc9ec6116864588108859d" translate="yes" xml:space="preserve">
          <source>This struct is created by the &lt;a href=&quot;../primitive.slice#method.chunks&quot;&gt;&lt;code&gt;chunks&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;../primitive.slice&quot;&gt;slices&lt;/a&gt;.</source>
          <target state="translated">Эта структура создается методом &lt;a href=&quot;../primitive.slice#method.chunks&quot;&gt; &lt;code&gt;chunks&lt;/code&gt; &lt;/a&gt; на &lt;a href=&quot;../primitive.slice&quot;&gt;срезах&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="4f546acf131aa1e22a602b9ef3fb82d4387eee8e" translate="yes" xml:space="preserve">
          <source>This struct is created by the &lt;a href=&quot;../primitive.slice#method.chunks_exact&quot;&gt;&lt;code&gt;chunks_exact&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;../primitive.slice&quot;&gt;slices&lt;/a&gt;.</source>
          <target state="translated">Эта структура создается методом &lt;a href=&quot;../primitive.slice#method.chunks_exact&quot;&gt; &lt;code&gt;chunks_exact&lt;/code&gt; &lt;/a&gt; на &lt;a href=&quot;../primitive.slice&quot;&gt;срезах&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="e45db796c91b4ce48eb20085844caa57f6053703" translate="yes" xml:space="preserve">
          <source>This struct is created by the &lt;a href=&quot;../primitive.slice#method.chunks_exact_mut&quot;&gt;&lt;code&gt;chunks_exact_mut&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;../primitive.slice&quot;&gt;slices&lt;/a&gt;.</source>
          <target state="translated">Эта структура создается методом &lt;a href=&quot;../primitive.slice#method.chunks_exact_mut&quot;&gt; &lt;code&gt;chunks_exact_mut&lt;/code&gt; &lt;/a&gt; на &lt;a href=&quot;../primitive.slice&quot;&gt;срезах&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="4164f449a467d7ed1b48f5a88a1f8a74fb26a190" translate="yes" xml:space="preserve">
          <source>This struct is created by the &lt;a href=&quot;../primitive.slice#method.chunks_mut&quot;&gt;&lt;code&gt;chunks_mut&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;../primitive.slice&quot;&gt;slices&lt;/a&gt;.</source>
          <target state="translated">Эта структура создается методом &lt;a href=&quot;../primitive.slice#method.chunks_mut&quot;&gt; &lt;code&gt;chunks_mut&lt;/code&gt; &lt;/a&gt; на &lt;a href=&quot;../primitive.slice&quot;&gt;срезах&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="76b48770dc5ec192ca6962e1d7faa3bd68e942ab" translate="yes" xml:space="preserve">
          <source>This struct is created by the &lt;a href=&quot;../primitive.slice#method.iter&quot;&gt;&lt;code&gt;iter&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;../primitive.slice&quot;&gt;slices&lt;/a&gt;.</source>
          <target state="translated">Эта структура создается методом &lt;a href=&quot;../primitive.slice#method.iter&quot;&gt; &lt;code&gt;iter&lt;/code&gt; &lt;/a&gt; на &lt;a href=&quot;../primitive.slice&quot;&gt;срезах&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="7681a887be4ac8a42d7f0ef28706aee3c6323619" translate="yes" xml:space="preserve">
          <source>This struct is created by the &lt;a href=&quot;../primitive.slice#method.iter_mut&quot;&gt;&lt;code&gt;iter_mut&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;../primitive.slice&quot;&gt;slices&lt;/a&gt;.</source>
          <target state="translated">Эта структура создается методом &lt;a href=&quot;../primitive.slice#method.iter_mut&quot;&gt; &lt;code&gt;iter_mut&lt;/code&gt; &lt;/a&gt; на &lt;a href=&quot;../primitive.slice&quot;&gt;срезах&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="523facc9e10029a951175d54b1f37f2671749ed6" translate="yes" xml:space="preserve">
          <source>This struct is created by the &lt;a href=&quot;../primitive.slice#method.rchunks&quot;&gt;&lt;code&gt;rchunks&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;../primitive.slice&quot;&gt;slices&lt;/a&gt;.</source>
          <target state="translated">Эта структура создается методом &lt;a href=&quot;../primitive.slice#method.rchunks&quot;&gt; &lt;code&gt;rchunks&lt;/code&gt; &lt;/a&gt; на &lt;a href=&quot;../primitive.slice&quot;&gt;срезах&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="7743c6e4ca6fc913a9f4d37b6de12a320056fa8b" translate="yes" xml:space="preserve">
          <source>This struct is created by the &lt;a href=&quot;../primitive.slice#method.rchunks_exact&quot;&gt;&lt;code&gt;rchunks_exact&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;../primitive.slice&quot;&gt;slices&lt;/a&gt;.</source>
          <target state="translated">Эта структура создается методом &lt;a href=&quot;../primitive.slice#method.rchunks_exact&quot;&gt; &lt;code&gt;rchunks_exact&lt;/code&gt; &lt;/a&gt; на &lt;a href=&quot;../primitive.slice&quot;&gt;срезах&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="82404af50a38a848751818c48976a9a56b795818" translate="yes" xml:space="preserve">
          <source>This struct is created by the &lt;a href=&quot;../primitive.slice#method.rchunks_exact_mut&quot;&gt;&lt;code&gt;rchunks_exact_mut&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;../primitive.slice&quot;&gt;slices&lt;/a&gt;.</source>
          <target state="translated">Эта структура создается методом &lt;a href=&quot;../primitive.slice#method.rchunks_exact_mut&quot;&gt; &lt;code&gt;rchunks_exact_mut&lt;/code&gt; &lt;/a&gt; на &lt;a href=&quot;../primitive.slice&quot;&gt;срезах&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="711c0f689f1d3a75f7b5a1b1833bc925f8986127" translate="yes" xml:space="preserve">
          <source>This struct is created by the &lt;a href=&quot;../primitive.slice#method.rchunks_mut&quot;&gt;&lt;code&gt;rchunks_mut&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;../primitive.slice&quot;&gt;slices&lt;/a&gt;.</source>
          <target state="translated">Эта структура создается методом &lt;a href=&quot;../primitive.slice#method.rchunks_mut&quot;&gt; &lt;code&gt;rchunks_mut&lt;/code&gt; &lt;/a&gt; на &lt;a href=&quot;../primitive.slice&quot;&gt;срезах&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="5ffea197c31595a869becf274e9c9ef3509b405a" translate="yes" xml:space="preserve">
          <source>This struct is created by the &lt;a href=&quot;../primitive.slice#method.rsplit&quot;&gt;&lt;code&gt;rsplit&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;../primitive.slice&quot;&gt;slices&lt;/a&gt;.</source>
          <target state="translated">Эта структура создается методом &lt;a href=&quot;../primitive.slice#method.rsplit&quot;&gt; &lt;code&gt;rsplit&lt;/code&gt; &lt;/a&gt; на &lt;a href=&quot;../primitive.slice&quot;&gt;срезах&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="a28e12c215b6246a69d2f856da858d720de99619" translate="yes" xml:space="preserve">
          <source>This struct is created by the &lt;a href=&quot;../primitive.slice#method.rsplit_mut&quot;&gt;&lt;code&gt;rsplit_mut&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;../primitive.slice&quot;&gt;slices&lt;/a&gt;.</source>
          <target state="translated">Эта структура создается методом &lt;a href=&quot;../primitive.slice#method.rsplit_mut&quot;&gt; &lt;code&gt;rsplit_mut&lt;/code&gt; &lt;/a&gt; на &lt;a href=&quot;../primitive.slice&quot;&gt;срезах&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="e1ddb16a3352ab0f837d4fac934c98e22db158e5" translate="yes" xml:space="preserve">
          <source>This struct is created by the &lt;a href=&quot;../primitive.slice#method.rsplitn&quot;&gt;&lt;code&gt;rsplitn&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;../primitive.slice&quot;&gt;slices&lt;/a&gt;.</source>
          <target state="translated">Эта структура создается методом &lt;a href=&quot;../primitive.slice#method.rsplitn&quot;&gt; &lt;code&gt;rsplitn&lt;/code&gt; &lt;/a&gt; на &lt;a href=&quot;../primitive.slice&quot;&gt;срезах&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="2305be064f2e36144fd442bf726fd4dd5a160216" translate="yes" xml:space="preserve">
          <source>This struct is created by the &lt;a href=&quot;../primitive.slice#method.rsplitn_mut&quot;&gt;&lt;code&gt;rsplitn_mut&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;../primitive.slice&quot;&gt;slices&lt;/a&gt;.</source>
          <target state="translated">Эта структура создается методом &lt;a href=&quot;../primitive.slice#method.rsplitn_mut&quot;&gt; &lt;code&gt;rsplitn_mut&lt;/code&gt; &lt;/a&gt; на &lt;a href=&quot;../primitive.slice&quot;&gt;срезах&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="9d2c4405dee882e98a94c3681ae8ce615cfcc3f7" translate="yes" xml:space="preserve">
          <source>This struct is created by the &lt;a href=&quot;../primitive.slice#method.split&quot;&gt;&lt;code&gt;split&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;../primitive.slice&quot;&gt;slices&lt;/a&gt;.</source>
          <target state="translated">Эта структура создается методом &lt;a href=&quot;../primitive.slice#method.split&quot;&gt; &lt;code&gt;split&lt;/code&gt; &lt;/a&gt; на &lt;a href=&quot;../primitive.slice&quot;&gt;срезах&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="abdc8d3421db5241b7ca4544a7b51d6159d67e49" translate="yes" xml:space="preserve">
          <source>This struct is created by the &lt;a href=&quot;../primitive.slice#method.split_mut&quot;&gt;&lt;code&gt;split_mut&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;../primitive.slice&quot;&gt;slices&lt;/a&gt;.</source>
          <target state="translated">Эта структура создается методом &lt;a href=&quot;../primitive.slice#method.split_mut&quot;&gt; &lt;code&gt;split_mut&lt;/code&gt; &lt;/a&gt; на &lt;a href=&quot;../primitive.slice&quot;&gt;срезах&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="b850789ebec6b616db674ca7582ef014921e3e50" translate="yes" xml:space="preserve">
          <source>This struct is created by the &lt;a href=&quot;../primitive.slice#method.splitn&quot;&gt;&lt;code&gt;splitn&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;../primitive.slice&quot;&gt;slices&lt;/a&gt;.</source>
          <target state="translated">Эта структура создается методом &lt;a href=&quot;../primitive.slice#method.splitn&quot;&gt; &lt;code&gt;splitn&lt;/code&gt; &lt;/a&gt; на &lt;a href=&quot;../primitive.slice&quot;&gt;срезах&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="fcbac1aabe82a2c466b31106e57bd4691b6a4588" translate="yes" xml:space="preserve">
          <source>This struct is created by the &lt;a href=&quot;../primitive.slice#method.splitn_mut&quot;&gt;&lt;code&gt;splitn_mut&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;../primitive.slice&quot;&gt;slices&lt;/a&gt;.</source>
          <target state="translated">Эта структура создается методом &lt;a href=&quot;../primitive.slice#method.splitn_mut&quot;&gt; &lt;code&gt;splitn_mut&lt;/code&gt; &lt;/a&gt; на &lt;a href=&quot;../primitive.slice&quot;&gt;срезах&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="4faa0b9911c89c4588e753ca1891a11cb9aac5c2" translate="yes" xml:space="preserve">
          <source>This struct is created by the &lt;a href=&quot;../primitive.slice#method.windows&quot;&gt;&lt;code&gt;windows&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;../primitive.slice&quot;&gt;slices&lt;/a&gt;.</source>
          <target state="translated">Эта структура создается методом &lt;a href=&quot;../primitive.slice#method.windows&quot;&gt; &lt;code&gt;windows&lt;/code&gt; &lt;/a&gt; на &lt;a href=&quot;../primitive.slice&quot;&gt;срезах&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="972c0f2531dd3e046ad902a7f6f569ef9de9571e" translate="yes" xml:space="preserve">
          <source>This struct is created by the &lt;a href=&quot;../primitive.str#method.bytes&quot;&gt;&lt;code&gt;bytes&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;../primitive.str&quot;&gt;&lt;code&gt;str&lt;/code&gt;&lt;/a&gt;. See its documentation for more.</source>
          <target state="translated">Эта структура создается методом &lt;a href=&quot;../primitive.str#method.bytes&quot;&gt; &lt;code&gt;bytes&lt;/code&gt; &lt;/a&gt; на &lt;a href=&quot;../primitive.str&quot;&gt; &lt;code&gt;str&lt;/code&gt; &lt;/a&gt; . См. Его документацию для получения дополнительной информации.</target>
        </trans-unit>
        <trans-unit id="9dc716c653425077e3bf50725d3ddc775e25fe94" translate="yes" xml:space="preserve">
          <source>This struct is created by the &lt;a href=&quot;../primitive.str#method.char_indices&quot;&gt;&lt;code&gt;char_indices&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;../primitive.str&quot;&gt;&lt;code&gt;str&lt;/code&gt;&lt;/a&gt;. See its documentation for more.</source>
          <target state="translated">Эта структура создается методом &lt;a href=&quot;../primitive.str#method.char_indices&quot;&gt; &lt;code&gt;char_indices&lt;/code&gt; &lt;/a&gt; на &lt;a href=&quot;../primitive.str&quot;&gt; &lt;code&gt;str&lt;/code&gt; &lt;/a&gt; . См. Его документацию для получения дополнительной информации.</target>
        </trans-unit>
        <trans-unit id="607ded9325aedcb5c140c227e32c8ad28d5439d9" translate="yes" xml:space="preserve">
          <source>This struct is created by the &lt;a href=&quot;../primitive.str#method.chars&quot;&gt;&lt;code&gt;chars&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;../primitive.str&quot;&gt;&lt;code&gt;str&lt;/code&gt;&lt;/a&gt;. See its documentation for more.</source>
          <target state="translated">Эта структура создается методом &lt;a href=&quot;../primitive.str#method.chars&quot;&gt; &lt;code&gt;chars&lt;/code&gt; &lt;/a&gt; на &lt;a href=&quot;../primitive.str&quot;&gt; &lt;code&gt;str&lt;/code&gt; &lt;/a&gt; . См. Его документацию для получения дополнительной информации.</target>
        </trans-unit>
        <trans-unit id="eb31472d0cae7541e173fe527a7087a142820c04" translate="yes" xml:space="preserve">
          <source>This struct is created by the &lt;a href=&quot;../primitive.str#method.encode_utf16&quot;&gt;&lt;code&gt;encode_utf16&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;../primitive.str&quot;&gt;&lt;code&gt;str&lt;/code&gt;&lt;/a&gt;. See its documentation for more.</source>
          <target state="translated">Эта структура создается методом &lt;a href=&quot;../primitive.str#method.encode_utf16&quot;&gt; &lt;code&gt;encode_utf16&lt;/code&gt; &lt;/a&gt; на &lt;a href=&quot;../primitive.str&quot;&gt; &lt;code&gt;str&lt;/code&gt; &lt;/a&gt; . См. Его документацию для получения дополнительной информации.</target>
        </trans-unit>
        <trans-unit id="e7c273a10bb61ef5da70d27b34dc57f12929254d" translate="yes" xml:space="preserve">
          <source>This struct is created by the &lt;a href=&quot;../primitive.str#method.split_ascii_whitespace&quot;&gt;&lt;code&gt;split_ascii_whitespace&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;../primitive.str&quot;&gt;&lt;code&gt;str&lt;/code&gt;&lt;/a&gt;. See its documentation for more.</source>
          <target state="translated">Эта структура создается методом &lt;a href=&quot;../primitive.str#method.split_ascii_whitespace&quot;&gt; &lt;code&gt;split_ascii_whitespace&lt;/code&gt; &lt;/a&gt; на &lt;a href=&quot;../primitive.str&quot;&gt; &lt;code&gt;str&lt;/code&gt; &lt;/a&gt; . См. Его документацию для получения дополнительной информации.</target>
        </trans-unit>
        <trans-unit id="e335f4d066241eacb01d34cbc9797fdfc696dc6b" translate="yes" xml:space="preserve">
          <source>This struct is created by the &lt;a href=&quot;../primitive.str#method.split_whitespace&quot;&gt;&lt;code&gt;split_whitespace&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;../primitive.str&quot;&gt;&lt;code&gt;str&lt;/code&gt;&lt;/a&gt;. See its documentation for more.</source>
          <target state="translated">Эта структура создается методом &lt;a href=&quot;../primitive.str#method.split_whitespace&quot;&gt; &lt;code&gt;split_whitespace&lt;/code&gt; &lt;/a&gt; на &lt;a href=&quot;../primitive.str&quot;&gt; &lt;code&gt;str&lt;/code&gt; &lt;/a&gt; . См. Его документацию для получения дополнительной информации.</target>
        </trans-unit>
        <trans-unit id="f9cd50ffb5bf76be59d59fc2f81ddf738ff0464b" translate="yes" xml:space="preserve">
          <source>This struct is created by the &lt;a href=&quot;fn.args&quot;&gt;&lt;code&gt;std::env::args&lt;/code&gt;&lt;/a&gt; function. See its documentation for more.</source>
          <target state="translated">Эта структура создается функцией &lt;a href=&quot;fn.args&quot;&gt; &lt;code&gt;std::env::args&lt;/code&gt; &lt;/a&gt; . См. Его документацию для получения дополнительной информации.</target>
        </trans-unit>
        <trans-unit id="0ec39f7b0daa2776e166f7fac0653e5c7c5e4333" translate="yes" xml:space="preserve">
          <source>This struct is created by the &lt;a href=&quot;fn.args_os&quot;&gt;&lt;code&gt;std::env::args_os&lt;/code&gt;&lt;/a&gt; function. See its documentation for more.</source>
          <target state="translated">Эта структура создается функцией &lt;a href=&quot;fn.args_os&quot;&gt; &lt;code&gt;std::env::args_os&lt;/code&gt; &lt;/a&gt; . См. Его документацию для получения дополнительной информации.</target>
        </trans-unit>
        <trans-unit id="d49df01529faa1803ee9ac5934efa956bfb59ca5" translate="yes" xml:space="preserve">
          <source>This struct is created by the &lt;a href=&quot;struct.string#method.drain&quot;&gt;&lt;code&gt;drain&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;struct.string&quot;&gt;&lt;code&gt;String&lt;/code&gt;&lt;/a&gt;. See its documentation for more.</source>
          <target state="translated">Эта структура создается методом &lt;a href=&quot;struct.string#method.drain&quot;&gt; &lt;code&gt;drain&lt;/code&gt; &lt;/a&gt; в &lt;a href=&quot;struct.string&quot;&gt; &lt;code&gt;String&lt;/code&gt; &lt;/a&gt; . См. Его документацию для получения дополнительной информации.</target>
        </trans-unit>
        <trans-unit id="7821d89ece3dc45805333802521c4ece28a6ec77" translate="yes" xml:space="preserve">
          <source>This struct is created by the &lt;a href=&quot;struct.vec#method.splice&quot;&gt;&lt;code&gt;splice()&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;struct.vec&quot;&gt;&lt;code&gt;Vec&lt;/code&gt;&lt;/a&gt;. See its documentation for more.</source>
          <target state="translated">Эта структура создается методом &lt;a href=&quot;struct.vec#method.splice&quot;&gt; &lt;code&gt;splice()&lt;/code&gt; &lt;/a&gt; в &lt;a href=&quot;struct.vec&quot;&gt; &lt;code&gt;Vec&lt;/code&gt; &lt;/a&gt; . См. Его документацию для получения дополнительной информации.</target>
        </trans-unit>
        <trans-unit id="df074a53b5359b4dd926d5ab8c21cb3fdb8391e4" translate="yes" xml:space="preserve">
          <source>This struct is created with the &lt;a href=&quot;../primitive.str#method.lines&quot;&gt;&lt;code&gt;lines&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;../primitive.str&quot;&gt;&lt;code&gt;str&lt;/code&gt;&lt;/a&gt;. See its documentation for more.</source>
          <target state="translated">Эта структура создается с помощью метода &lt;a href=&quot;../primitive.str#method.lines&quot;&gt; &lt;code&gt;lines&lt;/code&gt; &lt;/a&gt; на &lt;a href=&quot;../primitive.str&quot;&gt; &lt;code&gt;str&lt;/code&gt; &lt;/a&gt; . См. Его документацию для получения дополнительной информации.</target>
        </trans-unit>
        <trans-unit id="5a1492f5f04561e29bfe6f623f2dc30782a50bbf" translate="yes" xml:space="preserve">
          <source>This struct is generally created by calling &lt;a href=&quot;fn.empty&quot;&gt;&lt;code&gt;empty()&lt;/code&gt;&lt;/a&gt;. Please see the documentation of &lt;a href=&quot;fn.empty&quot;&gt;&lt;code&gt;empty()&lt;/code&gt;&lt;/a&gt; for more details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8df7525ac9b1331bb51b51ca2c5df8a11c0a1c0e" translate="yes" xml:space="preserve">
          <source>This struct is generally created by calling &lt;a href=&quot;fn.empty&quot;&gt;&lt;code&gt;empty&lt;/code&gt;&lt;/a&gt;. Please see the documentation of &lt;a href=&quot;fn.empty&quot;&gt;&lt;code&gt;empty()&lt;/code&gt;&lt;/a&gt; for more details.</source>
          <target state="translated">Эта структура обычно создается путем вызова &lt;a href=&quot;fn.empty&quot;&gt; &lt;code&gt;empty&lt;/code&gt; &lt;/a&gt; . Пожалуйста, смотрите документацию &lt;a href=&quot;fn.empty&quot;&gt; &lt;code&gt;empty()&lt;/code&gt; &lt;/a&gt; для более подробной информации.</target>
        </trans-unit>
        <trans-unit id="8dc7e6b8159c36d037a08968dd41820bb2c65481" translate="yes" xml:space="preserve">
          <source>This struct is generally created by calling &lt;a href=&quot;fn.repeat&quot;&gt;&lt;code&gt;repeat()&lt;/code&gt;&lt;/a&gt;. Please see the documentation of &lt;a href=&quot;fn.repeat&quot;&gt;&lt;code&gt;repeat()&lt;/code&gt;&lt;/a&gt; for more details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4d0cc773f4b725ed1f190beeb33e3f1817949265" translate="yes" xml:space="preserve">
          <source>This struct is generally created by calling &lt;a href=&quot;fn.repeat&quot;&gt;&lt;code&gt;repeat&lt;/code&gt;&lt;/a&gt;. Please see the documentation of &lt;code&gt;repeat()&lt;/code&gt; for more details.</source>
          <target state="translated">Эта структура обычно создается путем вызова &lt;a href=&quot;fn.repeat&quot;&gt; &lt;code&gt;repeat&lt;/code&gt; &lt;/a&gt; . Пожалуйста, смотрите документацию на &lt;code&gt;repeat()&lt;/code&gt; для более подробной информации.</target>
        </trans-unit>
        <trans-unit id="24b0eaa40ab28907590f0749ecb8c76a4046ae2e" translate="yes" xml:space="preserve">
          <source>This struct is generally created by calling &lt;a href=&quot;fn.sink&quot;&gt;&lt;code&gt;sink&lt;/code&gt;&lt;/a&gt;. Please see the documentation of &lt;a href=&quot;fn.sink&quot;&gt;&lt;code&gt;sink()&lt;/code&gt;&lt;/a&gt; for more details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dc05dce26bdc09f8fc488132c92d5215b0e0bb48" translate="yes" xml:space="preserve">
          <source>This struct is generally created by calling &lt;a href=&quot;fn.sink&quot;&gt;&lt;code&gt;sink&lt;/code&gt;&lt;/a&gt;. Please see the documentation of &lt;code&gt;sink()&lt;/code&gt; for more details.</source>
          <target state="translated">Эта структура обычно создается путем вызова &lt;a href=&quot;fn.sink&quot;&gt; &lt;code&gt;sink&lt;/code&gt; &lt;/a&gt; . Пожалуйста, см. Документацию к &lt;code&gt;sink()&lt;/code&gt; для более подробной информации.</target>
        </trans-unit>
        <trans-unit id="6405be6b1dfbc1fabe9afe38ed753782ffca52fa" translate="yes" xml:space="preserve">
          <source>This struct is generally created by calling &lt;a href=&quot;trait.bufread#method.lines&quot;&gt;&lt;code&gt;lines&lt;/code&gt;&lt;/a&gt; on a &lt;code&gt;BufRead&lt;/code&gt;. Please see the documentation of &lt;a href=&quot;trait.bufread#method.lines&quot;&gt;&lt;code&gt;lines&lt;/code&gt;&lt;/a&gt; for more details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5a732d552fb11922cbdd232738709d5ceaab3ab0" translate="yes" xml:space="preserve">
          <source>This struct is generally created by calling &lt;a href=&quot;trait.bufread#method.lines&quot;&gt;&lt;code&gt;lines&lt;/code&gt;&lt;/a&gt; on a &lt;code&gt;BufRead&lt;/code&gt;. Please see the documentation of &lt;code&gt;lines()&lt;/code&gt; for more details.</source>
          <target state="translated">Эта структура обычно создается путем вызова &lt;a href=&quot;trait.bufread#method.lines&quot;&gt; &lt;code&gt;lines&lt;/code&gt; &lt;/a&gt; в &lt;code&gt;BufRead&lt;/code&gt; . Пожалуйста, смотрите документацию по &lt;code&gt;lines()&lt;/code&gt; для более подробной информации.</target>
        </trans-unit>
        <trans-unit id="f6120cd0b709f995e698179414e725d511642b6c" translate="yes" xml:space="preserve">
          <source>This struct is generally created by calling &lt;a href=&quot;trait.bufread#method.split&quot;&gt;&lt;code&gt;split&lt;/code&gt;&lt;/a&gt; on a &lt;code&gt;BufRead&lt;/code&gt;. Please see the documentation of &lt;a href=&quot;trait.bufread#method.split&quot;&gt;&lt;code&gt;split&lt;/code&gt;&lt;/a&gt; for more details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="57521da9d072a5a75b7ef81a11e1941632c07769" translate="yes" xml:space="preserve">
          <source>This struct is generally created by calling &lt;a href=&quot;trait.bufread#method.split&quot;&gt;&lt;code&gt;split&lt;/code&gt;&lt;/a&gt; on a &lt;code&gt;BufRead&lt;/code&gt;. Please see the documentation of &lt;code&gt;split()&lt;/code&gt; for more details.</source>
          <target state="translated">Эта структура обычно создается путем вызова &lt;a href=&quot;trait.bufread#method.split&quot;&gt; &lt;code&gt;split&lt;/code&gt; &lt;/a&gt; для &lt;code&gt;BufRead&lt;/code&gt; . Пожалуйста, см. Документацию &lt;code&gt;split()&lt;/code&gt; для получения более подробной информации.</target>
        </trans-unit>
        <trans-unit id="e1deb8df82a06cf7e25723eca2d9b3c3500c212f" translate="yes" xml:space="preserve">
          <source>This struct is generally created by calling &lt;a href=&quot;trait.read#method.bytes&quot;&gt;&lt;code&gt;bytes&lt;/code&gt;&lt;/a&gt; on a reader. Please see the documentation of &lt;a href=&quot;trait.read#method.bytes&quot;&gt;&lt;code&gt;bytes&lt;/code&gt;&lt;/a&gt; for more details.</source>
          <target state="translated">Эта структура обычно создается путем вызова &lt;a href=&quot;trait.read#method.bytes&quot;&gt; &lt;code&gt;bytes&lt;/code&gt; &lt;/a&gt; в читателе. Пожалуйста, смотрите документацию по &lt;a href=&quot;trait.read#method.bytes&quot;&gt; &lt;code&gt;bytes&lt;/code&gt; &lt;/a&gt; для более подробной информации.</target>
        </trans-unit>
        <trans-unit id="137e3be8282a7112c63c8d5b6052cbdcefad663e" translate="yes" xml:space="preserve">
          <source>This struct is generally created by calling &lt;a href=&quot;trait.read#method.chain&quot;&gt;&lt;code&gt;chain&lt;/code&gt;&lt;/a&gt; on a reader. Please see the documentation of &lt;a href=&quot;trait.read#method.chain&quot;&gt;&lt;code&gt;chain&lt;/code&gt;&lt;/a&gt; for more details.</source>
          <target state="translated">Эта структура обычно создается путем вызова &lt;a href=&quot;trait.read#method.chain&quot;&gt; &lt;code&gt;chain&lt;/code&gt; &lt;/a&gt; на читателе. Пожалуйста, смотрите документацию &lt;a href=&quot;trait.read#method.chain&quot;&gt; &lt;code&gt;chain&lt;/code&gt; &lt;/a&gt; для более подробной информации.</target>
        </trans-unit>
        <trans-unit id="047a4ebdecfd5e2897b79c73996497448f62e8a9" translate="yes" xml:space="preserve">
          <source>This struct is generally created by calling &lt;a href=&quot;trait.read#method.take&quot;&gt;&lt;code&gt;take&lt;/code&gt;&lt;/a&gt; on a reader. Please see the documentation of &lt;a href=&quot;trait.read#method.take&quot;&gt;&lt;code&gt;take&lt;/code&gt;&lt;/a&gt; for more details.</source>
          <target state="translated">Эта структура обычно создается путем вызова &lt;a href=&quot;trait.read#method.take&quot;&gt; &lt;code&gt;take&lt;/code&gt; &lt;/a&gt; для читателя. Пожалуйста, смотрите документацию &lt;a href=&quot;trait.read#method.take&quot;&gt; &lt;code&gt;take&lt;/code&gt; &lt;/a&gt; для получения более подробной информации.</target>
        </trans-unit>
        <trans-unit id="a7395af01bd4a50c6dfb48da98c0430b70139ec6" translate="yes" xml:space="preserve">
          <source>This struct is used in the &lt;a href=&quot;struct.child#structfield.stderr&quot;&gt;&lt;code&gt;stderr&lt;/code&gt;&lt;/a&gt; field on &lt;a href=&quot;struct.child&quot;&gt;&lt;code&gt;Child&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Эта структура используется в поле &lt;a href=&quot;struct.child#structfield.stderr&quot;&gt; &lt;code&gt;stderr&lt;/code&gt; &lt;/a&gt; в &lt;a href=&quot;struct.child&quot;&gt; &lt;code&gt;Child&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="45d9e2d1a8753395175acd043fb98b742fa0c7b1" translate="yes" xml:space="preserve">
          <source>This struct is used in the &lt;a href=&quot;struct.child#structfield.stdin&quot;&gt;&lt;code&gt;stdin&lt;/code&gt;&lt;/a&gt; field on &lt;a href=&quot;struct.child&quot;&gt;&lt;code&gt;Child&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Эта структура используется в поле &lt;a href=&quot;struct.child#structfield.stdin&quot;&gt; &lt;code&gt;stdin&lt;/code&gt; &lt;/a&gt; в &lt;a href=&quot;struct.child&quot;&gt; &lt;code&gt;Child&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="a0e77c1cd6c1d6c1011116ad5fd2720b269732ff" translate="yes" xml:space="preserve">
          <source>This struct is used in the &lt;a href=&quot;struct.child#structfield.stdout&quot;&gt;&lt;code&gt;stdout&lt;/code&gt;&lt;/a&gt; field on &lt;a href=&quot;struct.child&quot;&gt;&lt;code&gt;Child&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Эта структура используется в поле &lt;a href=&quot;struct.child#structfield.stdout&quot;&gt; &lt;code&gt;stdout&lt;/code&gt; &lt;/a&gt; в &lt;a href=&quot;struct.child&quot;&gt; &lt;code&gt;Child&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="c78ae69a32ba5f8bbcb17b7abd5cf067694229aa" translate="yes" xml:space="preserve">
          <source>This structure is created by &lt;a href=&quot;fn.split_paths&quot;&gt;&lt;code&gt;env::split_paths()&lt;/code&gt;&lt;/a&gt;. See its documentation for more.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c446cff104f615e56344282bb3df53e735cf1fdb" translate="yes" xml:space="preserve">
          <source>This structure is created by &lt;a href=&quot;fn.vars&quot;&gt;&lt;code&gt;env::vars()&lt;/code&gt;&lt;/a&gt;. See its documentation for more.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="64b2bbf5e29e3f661a1f1f7db6c4d0d2f77172fd" translate="yes" xml:space="preserve">
          <source>This structure is created by &lt;a href=&quot;fn.vars_os&quot;&gt;&lt;code&gt;env::vars_os()&lt;/code&gt;&lt;/a&gt;. See its documentation for more.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="31822658b6e7064c66c1754cfb13fa7a6a0cb6b1" translate="yes" xml:space="preserve">
          <source>This structure is created by &lt;a href=&quot;struct.panicinfo#method.location&quot;&gt;&lt;code&gt;PanicInfo::location()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5c3b3caed2d7f9ef42e3b6090d38c4f7a8f595c9" translate="yes" xml:space="preserve">
          <source>This structure is created by the &lt;a href=&quot;fn.split_paths&quot;&gt;&lt;code&gt;std::env::split_paths&lt;/code&gt;&lt;/a&gt; function. See its documentation for more.</source>
          <target state="translated">Эта структура создается функцией &lt;a href=&quot;fn.split_paths&quot;&gt; &lt;code&gt;std::env::split_paths&lt;/code&gt; &lt;/a&gt; . См. Его документацию для получения дополнительной информации.</target>
        </trans-unit>
        <trans-unit id="763fd05613c0342afc387ef243d7b2fcab0e70ec" translate="yes" xml:space="preserve">
          <source>This structure is created by the &lt;a href=&quot;fn.vars&quot;&gt;&lt;code&gt;std::env::vars&lt;/code&gt;&lt;/a&gt; function. See its documentation for more.</source>
          <target state="translated">Эта структура создается функцией &lt;a href=&quot;fn.vars&quot;&gt; &lt;code&gt;std::env::vars&lt;/code&gt; &lt;/a&gt; . См. Его документацию для получения дополнительной информации.</target>
        </trans-unit>
        <trans-unit id="aeb9c6eb7e34424ffff3b1a0d353cc1e7da71bbe" translate="yes" xml:space="preserve">
          <source>This structure is created by the &lt;a href=&quot;fn.vars_os&quot;&gt;&lt;code&gt;std::env::vars_os&lt;/code&gt;&lt;/a&gt; function. See its documentation for more.</source>
          <target state="translated">Эта структура создается функцией &lt;a href=&quot;fn.vars_os&quot;&gt; &lt;code&gt;std::env::vars_os&lt;/code&gt; &lt;/a&gt; . См. Его документацию для получения дополнительной информации.</target>
        </trans-unit>
        <trans-unit id="49ca05175d2c16657b8d4f1e47558a6913b20cd1" translate="yes" xml:space="preserve">
          <source>This structure is created by the &lt;a href=&quot;struct.mutex#method.lock&quot;&gt;&lt;code&gt;lock&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;struct.mutex#method.try_lock&quot;&gt;&lt;code&gt;try_lock&lt;/code&gt;&lt;/a&gt; methods on &lt;a href=&quot;struct.mutex&quot;&gt;&lt;code&gt;Mutex&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Эта структура создается методами &lt;a href=&quot;struct.mutex#method.lock&quot;&gt; &lt;code&gt;lock&lt;/code&gt; &lt;/a&gt; и &lt;a href=&quot;struct.mutex#method.try_lock&quot;&gt; &lt;code&gt;try_lock&lt;/code&gt; &lt;/a&gt; на &lt;a href=&quot;struct.mutex&quot;&gt; &lt;code&gt;Mutex&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="4a6f95cf45a5bcc128684cebfbd05d3880902f8d" translate="yes" xml:space="preserve">
          <source>This structure is created by the &lt;a href=&quot;struct.panicinfo#method.location&quot;&gt;&lt;code&gt;location&lt;/code&gt;&lt;/a&gt; method of &lt;a href=&quot;struct.panicinfo&quot;&gt;&lt;code&gt;PanicInfo&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Эта структура создается &lt;a href=&quot;struct.panicinfo#method.location&quot;&gt; &lt;code&gt;location&lt;/code&gt; &lt;/a&gt; методом &lt;a href=&quot;struct.panicinfo&quot;&gt; &lt;code&gt;PanicInfo&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="0ba43b358d72c0f70633e8ff8edbb3820ba26ae8" translate="yes" xml:space="preserve">
          <source>This structure is created by the &lt;a href=&quot;struct.rwlock#method.read&quot;&gt;&lt;code&gt;read&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;struct.rwlock#method.try_read&quot;&gt;&lt;code&gt;try_read&lt;/code&gt;&lt;/a&gt; methods on &lt;a href=&quot;struct.rwlock&quot;&gt;&lt;code&gt;RwLock&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Эта структура создается методами &lt;a href=&quot;struct.rwlock#method.read&quot;&gt; &lt;code&gt;read&lt;/code&gt; &lt;/a&gt; и &lt;a href=&quot;struct.rwlock#method.try_read&quot;&gt; &lt;code&gt;try_read&lt;/code&gt; &lt;/a&gt; на &lt;a href=&quot;struct.rwlock&quot;&gt; &lt;code&gt;RwLock&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="37c48c912f9cb67a5286393a48bcb5981e2a346b" translate="yes" xml:space="preserve">
          <source>This structure is created by the &lt;a href=&quot;struct.rwlock#method.write&quot;&gt;&lt;code&gt;write&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;struct.rwlock#method.try_write&quot;&gt;&lt;code&gt;try_write&lt;/code&gt;&lt;/a&gt; methods on &lt;a href=&quot;struct.rwlock&quot;&gt;&lt;code&gt;RwLock&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Эта структура создается методами &lt;a href=&quot;struct.rwlock#method.write&quot;&gt; &lt;code&gt;write&lt;/code&gt; &lt;/a&gt; и &lt;a href=&quot;struct.rwlock#method.try_write&quot;&gt; &lt;code&gt;try_write&lt;/code&gt; &lt;/a&gt; в &lt;a href=&quot;struct.rwlock&quot;&gt; &lt;code&gt;RwLock&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="e1b64e1281a00cf103b0dc5f24e83df69f16eb4c" translate="yes" xml:space="preserve">
          <source>This structure is returned from the &lt;a href=&quot;fn.metadata&quot;&gt;&lt;code&gt;metadata&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;fn.symlink_metadata&quot;&gt;&lt;code&gt;symlink_metadata&lt;/code&gt;&lt;/a&gt; function or method and represents known metadata about a file such as its permissions, size, modification times, etc.</source>
          <target state="translated">Эта структура возвращается из &lt;a href=&quot;fn.metadata&quot;&gt; &lt;code&gt;metadata&lt;/code&gt; &lt;/a&gt; или функции или метода &lt;a href=&quot;fn.symlink_metadata&quot;&gt; &lt;code&gt;symlink_metadata&lt;/code&gt; &lt;/a&gt; и представляет известные метаданные о файле, такие как его разрешения, размер, время модификации и т. Д.</target>
        </trans-unit>
        <trans-unit id="a90c6bba494b412af840afa94f3d4327e4e6ac5c" translate="yes" xml:space="preserve">
          <source>This structure is used to represent and manage child processes. A child process is created via the &lt;a href=&quot;struct.command&quot;&gt;&lt;code&gt;Command&lt;/code&gt;&lt;/a&gt; struct, which configures the spawning process and can itself be constructed using a builder-style interface.</source>
          <target state="translated">Эта структура используется для представления дочерних процессов и управления ими. Дочерний процесс создается через структуру &lt;a href=&quot;struct.command&quot;&gt; &lt;code&gt;Command&lt;/code&gt; &lt;/a&gt; , которая настраивает процесс порождения и может быть сконструирована с использованием интерфейса в стиле построителя.</target>
        </trans-unit>
        <trans-unit id="21f163fe5401a35062783545bd12a7fe23e7c94b" translate="yes" xml:space="preserve">
          <source>This structure represents a safely precompiled version of a format string and its arguments. This cannot be generated at runtime because it cannot safely be done, so no constructors are given and the fields are private to prevent modification.</source>
          <target state="translated">Эта структура представляет собой безопасную прекомпилированную версию строки форматирования и ее аргументов.Она не может быть сгенерирована во время выполнения,так как не может быть безопасно выполнена,поэтому конструкторы не задаются,а поля являются закрытыми,чтобы предотвратить модификацию.</target>
        </trans-unit>
        <trans-unit id="0adc11971ab38c810ebf2248ed011aa51008e125" translate="yes" xml:space="preserve">
          <source>This suffers the same restrictions and reasoning as implementing &lt;a href=&quot;trait.into&quot;&gt;&lt;code&gt;Into&lt;/code&gt;&lt;/a&gt;, see there for details.</source>
          <target state="translated">Это страдает теми же ограничениями и аргументами, что и реализация &lt;a href=&quot;trait.into&quot;&gt; &lt;code&gt;Into&lt;/code&gt; &lt;/a&gt; , подробности см. Там.</target>
        </trans-unit>
        <trans-unit id="6f2d7a21c40fec745cf07aea5a678e00b27d1d6d" translate="yes" xml:space="preserve">
          <source>This sums up every integer in a vector, rejecting the sum if a negative element is encountered:</source>
          <target state="translated">При этом суммируется каждое целое число в векторе,отвергая сумму,если встречается отрицательный элемент:</target>
        </trans-unit>
        <trans-unit id="3b38ed7b25f08579fef293fd7b9ae8fd73fe03b3" translate="yes" xml:space="preserve">
          <source>This sums up the position of the character 'a' in a vector of strings, if a word did not have the character 'a' the operation returns &lt;code&gt;None&lt;/code&gt;:</source>
          <target state="translated">Это суммирует позицию символа 'a' в векторе строк, если слово не имеет символа 'a', операция возвращает &lt;code&gt;None&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="b7b5e0845ef8959eb8d683ea0316747264243c8d" translate="yes" xml:space="preserve">
          <source>This syntax seems comparable to that of generics. So why not just define the &lt;code&gt;Iterator&lt;/code&gt; trait with generics, as shown in Listing 19-13?</source>
          <target state="translated">Этот синтаксис кажется сопоставимым с синтаксисом дженериков. Так почему бы просто не определить &lt;code&gt;Iterator&lt;/code&gt; с помощью обобщений, как показано в листинге 19-13?</target>
        </trans-unit>
        <trans-unit id="2e389d45d6848629d7d0a8141a0d2eefc943d3d3" translate="yes" xml:space="preserve">
          <source>This syntax should look familiar from our discussions on how to define traits in Chapter 10. Next comes some new syntax: Listing 17-4 defines a struct named &lt;code&gt;Screen&lt;/code&gt; that holds a vector named &lt;code&gt;components&lt;/code&gt;. This vector is of type &lt;code&gt;Box&amp;lt;dyn Draw&amp;gt;&lt;/code&gt;, which is a trait object; it&amp;rsquo;s a stand-in for any type inside a &lt;code&gt;Box&lt;/code&gt; that implements the &lt;code&gt;Draw&lt;/code&gt; trait.</source>
          <target state="translated">Этот синтаксис должен показаться знакомым из наших обсуждений того, как определять черты в главе 10. Затем следует новый синтаксис: в листинге 17-4 определяется структура с именем &lt;code&gt;Screen&lt;/code&gt; , которая содержит вектор с именем &lt;code&gt;components&lt;/code&gt; . Этот вектор относится к типу &lt;code&gt;Box&amp;lt;dyn Draw&amp;gt;&lt;/code&gt; , который является объектом признака; это замена для любого типа внутри &lt;code&gt;Box&lt;/code&gt; , который реализует &lt;code&gt;Draw&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="157ddb41dd66b7335f1aa23c99d8dc3500848966" translate="yes" xml:space="preserve">
          <source>This syntax specifies that we want the X type from MyTrait, as made concrete in MyStruct. The reason that we cannot simply use &lt;code&gt;MyStruct::X&lt;/code&gt; is that MyStruct might implement two different traits with identically-named associated types. This syntax allows disambiguation between the two.</source>
          <target state="translated">Этот синтаксис указывает, что нам нужен тип X из MyTrait, как конкретизировано в MyStruct. Причина, по которой мы не можем просто использовать &lt;code&gt;MyStruct::X&lt;/code&gt; заключается в том, что MyStruct может реализовывать два разных трейта с одинаково названными связанными типами. Этот синтаксис позволяет устранить неоднозначность между ними.</target>
        </trans-unit>
        <trans-unit id="6be1eead3ada3953477a6dbe51c912612a272761" translate="yes" xml:space="preserve">
          <source>This technique is just one of many ways to improve the throughput of a web server. Other options you might explore are the fork/join model and the single-threaded async I/O model. If you&amp;rsquo;re interested in this topic, you can read more about other solutions and try to implement them in Rust; with a low-level language like Rust, all of these options are possible.</source>
          <target state="translated">Этот метод - лишь один из многих способов повысить пропускную способность веб-сервера. Другие варианты, которые вы можете изучить, - это модель fork / join и однопоточная модель асинхронного ввода-вывода. Если вам интересна эта тема, вы можете узнать больше о других решениях и попробовать реализовать их в Rust; с языком низкого уровня, таким как Rust, все эти варианты возможны.</target>
        </trans-unit>
        <trans-unit id="731e8ea356524b34210881afc68de295a0e37bff" translate="yes" xml:space="preserve">
          <source>This technique is pretty neat! By using &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt;, we have an outwardly immutable &lt;code&gt;List&lt;/code&gt; value. But we can use the methods on &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt; that provide access to its interior mutability so we can modify our data when we need to. The runtime checks of the borrowing rules protect us from data races, and it&amp;rsquo;s sometimes worth trading a bit of speed for this flexibility in our data structures.</source>
          <target state="translated">Это довольно изящная техника! Используя &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt; , мы получаем внешне неизменяемое значение &lt;code&gt;List&lt;/code&gt; . Но мы можем использовать методы &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt; которые обеспечивают доступ к его внутренней изменчивости, чтобы мы могли изменять наши данные, когда нам это нужно. Проверки правил заимствования во время выполнения защищают нас от гонок данных, и иногда стоит потратить немного скорости ради этой гибкости в наших структурах данных.</target>
        </trans-unit>
        <trans-unit id="9283a8a2efae9e1f40a1d640e7fbf1f6c7025c52" translate="yes" xml:space="preserve">
          <source>This tells us the return type of the &lt;code&gt;File::open&lt;/code&gt; function is a &lt;code&gt;Result&amp;lt;T, E&amp;gt;&lt;/code&gt;. The generic parameter &lt;code&gt;T&lt;/code&gt; has been filled in here with the type of the success value, &lt;code&gt;std::fs::File&lt;/code&gt;, which is a file handle. The type of &lt;code&gt;E&lt;/code&gt; used in the error value is &lt;code&gt;std::io::Error&lt;/code&gt;.</source>
          <target state="translated">Это говорит нам, что тип возвращаемого значения функции &lt;code&gt;File::open&lt;/code&gt; - это &lt;code&gt;Result&amp;lt;T, E&amp;gt;&lt;/code&gt; . Общий параметр &lt;code&gt;T&lt;/code&gt; был заполнен здесь типом значения успеха &lt;code&gt;std::fs::File&lt;/code&gt; , которое является дескриптором файла. Тип &lt;code&gt;E&lt;/code&gt; , используемый в значении ошибки, - &lt;code&gt;std::io::Error&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1369ebc6a80c7328fbe0b2bd897392d17a8945de" translate="yes" xml:space="preserve">
          <source>This test code defines a &lt;code&gt;MockMessenger&lt;/code&gt; struct that has a &lt;code&gt;sent_messages&lt;/code&gt; field with a &lt;code&gt;Vec&lt;/code&gt; of &lt;code&gt;String&lt;/code&gt; values to keep track of the messages it&amp;rsquo;s told to send. We also define an associated function &lt;code&gt;new&lt;/code&gt; to make it convenient to create new &lt;code&gt;MockMessenger&lt;/code&gt; values that start with an empty list of messages. We then implement the &lt;code&gt;Messenger&lt;/code&gt; trait for &lt;code&gt;MockMessenger&lt;/code&gt; so we can give a &lt;code&gt;MockMessenger&lt;/code&gt; to a &lt;code&gt;LimitTracker&lt;/code&gt;. In the definition of the &lt;code&gt;send&lt;/code&gt; method, we take the message passed in as a parameter and store it in the &lt;code&gt;MockMessenger&lt;/code&gt; list of &lt;code&gt;sent_messages&lt;/code&gt;.</source>
          <target state="translated">Этот тестовый код определяет &lt;code&gt;MockMessenger&lt;/code&gt; структуру , которая имеет &lt;code&gt;sent_messages&lt;/code&gt; поле с &lt;code&gt;Vec&lt;/code&gt; из &lt;code&gt;String&lt;/code&gt; значений , чтобы отслеживать сообщения , которые он сказал , чтобы отправить. Мы также определяем связанную функцию &lt;code&gt;new&lt;/code&gt; , чтобы было удобно создавать новые значения &lt;code&gt;MockMessenger&lt;/code&gt; , которые начинаются с пустого списка сообщений. Затем мы реализуем &lt;code&gt;MockMessenger&lt;/code&gt; &lt;code&gt;Messenger&lt;/code&gt; для MockMessenger, чтобы мы могли передать &lt;code&gt;MockMessenger&lt;/code&gt; в &lt;code&gt;LimitTracker&lt;/code&gt; . В определении метода &lt;code&gt;send&lt;/code&gt; мы берем переданное сообщение как параметр и сохраняем его в списке &lt;code&gt;MockMessenger&lt;/code&gt; . &lt;code&gt;sent_messages&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="cf7bdfe2c080bcfbd294561ba32984ed7b6655c2" translate="yes" xml:space="preserve">
          <source>This test creates a new &lt;code&gt;Cacher&lt;/code&gt; instance with a closure that returns the value passed into it. We call the &lt;code&gt;value&lt;/code&gt; method on this &lt;code&gt;Cacher&lt;/code&gt; instance with an &lt;code&gt;arg&lt;/code&gt; value of 1 and then an &lt;code&gt;arg&lt;/code&gt; value of 2, and we expect the call to &lt;code&gt;value&lt;/code&gt; with the &lt;code&gt;arg&lt;/code&gt; value of 2 to return 2.</source>
          <target state="translated">Этот тест создает новый экземпляр &lt;code&gt;Cacher&lt;/code&gt; с закрытием, которое возвращает переданное в него значение. Мы вызываем метод &lt;code&gt;value&lt;/code&gt; для этого экземпляра &lt;code&gt;Cacher&lt;/code&gt; со значением &lt;code&gt;arg&lt;/code&gt; , равным 1, а затем со значением &lt;code&gt;arg&lt;/code&gt; , равным 2, и ожидаем, что вызов &lt;code&gt;value&lt;/code&gt; со значением &lt;code&gt;arg&lt;/code&gt; 2 вернет 2.</target>
        </trans-unit>
        <trans-unit id="72299afca54f19e85015cb228f6cdc67fc73f999" translate="yes" xml:space="preserve">
          <source>This test creates a new &lt;code&gt;Counter&lt;/code&gt; instance in the &lt;code&gt;counter&lt;/code&gt; variable and then calls &lt;code&gt;next&lt;/code&gt; repeatedly, verifying that we have implemented the behavior we want this iterator to have: returning the values from 1 to 5.</source>
          <target state="translated">Этот тест создает новый экземпляр &lt;code&gt;Counter&lt;/code&gt; в переменной &lt;code&gt;counter&lt;/code&gt; , а затем повторно вызывает &lt;code&gt;next&lt;/code&gt; , проверяя, что мы реализовали поведение, которое мы хотим, чтобы этот итератор имел: возвращение значений от 1 до 5.</target>
        </trans-unit>
        <trans-unit id="05dea38628c56d1ac2dee0da9506b8c1998c15fa" translate="yes" xml:space="preserve">
          <source>This test searches for the string &lt;code&gt;&quot;duct&quot;&lt;/code&gt;. The text we&amp;rsquo;re searching is three lines, only one of which contains &lt;code&gt;&quot;duct&quot;&lt;/code&gt;. We assert that the value returned from the &lt;code&gt;search&lt;/code&gt; function contains only the line we expect.</source>
          <target state="translated">Этот тест ищет строку &lt;code&gt;&quot;duct&quot;&lt;/code&gt; . Текст, который мы ищем, состоит из трех строк, только одна из которых содержит &lt;code&gt;&quot;duct&quot;&lt;/code&gt; . Мы утверждаем, что значение, возвращаемое функцией &lt;code&gt;search&lt;/code&gt; содержит только ожидаемую строку.</target>
        </trans-unit>
        <trans-unit id="ddca2fdf5e68d60216a77aaaba507a1415303561" translate="yes" xml:space="preserve">
          <source>This test will pass because the value we put in the &lt;code&gt;should_panic&lt;/code&gt; attribute&amp;rsquo;s &lt;code&gt;expected&lt;/code&gt; parameter is a substring of the message that the &lt;code&gt;Guess::new&lt;/code&gt; function panics with. We could have specified the entire panic message that we expect, which in this case would be &lt;code&gt;Guess value must be less than or equal to 100, got 200.&lt;/code&gt; What you choose to specify in the expected parameter for &lt;code&gt;should_panic&lt;/code&gt; depends on how much of the panic message is unique or dynamic and how precise you want your test to be. In this case, a substring of the panic message is enough to ensure that the code in the test function executes the &lt;code&gt;else if value &amp;gt; 100&lt;/code&gt; case.</source>
          <target state="translated">Этот тест будет &lt;code&gt;should_panic&lt;/code&gt; потому что значение, которое мы помещаем в &lt;code&gt;expected&lt;/code&gt; параметр атрибута should_panic , является подстрокой сообщения, вызывающего панику функции &lt;code&gt;Guess::new&lt;/code&gt; . Мы могли бы указаны все сообщение паники , что мы ожидаем, что в данном случае было бы &lt;code&gt;Guess value must be less than or equal to 100, got 200.&lt;/code&gt; То , что вы хотите указать в ожидаемом для параметра &lt;code&gt;should_panic&lt;/code&gt; зависит от того , сколько паники сообщение уникально или динамично и насколько точным должен быть ваш тест. В этом случае подстроки сообщения о панике достаточно, чтобы гарантировать, что код в тестовой функции выполняет &lt;code&gt;else if value &amp;gt; 100&lt;/code&gt; case.</target>
        </trans-unit>
        <trans-unit id="bbe227be9e7db744874fde49a6fb7f9f9cde2ed8" translate="yes" xml:space="preserve">
          <source>This text is available in &lt;a href=&quot;https://nostarch.com/rust&quot;&gt;paperback and ebook format from No Starch Press&lt;/a&gt;.</source>
          <target state="translated">Этот текст доступен в &lt;a href=&quot;https://nostarch.com/rust&quot;&gt;мягкой обложке и в формате электронной книги от No Starch Press&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="abaa655d972948c0991360be1b3331d77edb5df2" translate="yes" xml:space="preserve">
          <source>This time when we compile the code, we get a different set of errors:</source>
          <target state="translated">На этот раз,когда мы компилируем код,мы получаем другой набор ошибок:</target>
        </trans-unit>
        <trans-unit id="ef45f877ddb3c6c79878e62a645c0f1bb5d754ab" translate="yes" xml:space="preserve">
          <source>This time when we run the &lt;code&gt;should_panic&lt;/code&gt; test, it will fail:</source>
          <target state="translated">На этот раз, когда мы &lt;code&gt;should_panic&lt;/code&gt; тест should_panic , он потерпит неудачу:</target>
        </trans-unit>
        <trans-unit id="927ffba8c6b861ab1b3ffedb0e60fa4989110409" translate="yes" xml:space="preserve">
          <source>This time, before we create the first spawned thread, we call &lt;code&gt;clone&lt;/code&gt; on the sending end of the channel. This will give us a new sending handle we can pass to the first spawned thread. We pass the original sending end of the channel to a second spawned thread. This gives us two threads, each sending different messages to the receiving end of the channel.</source>
          <target state="translated">На этот раз, прежде чем мы создадим первый порожденный поток, мы вызываем &lt;code&gt;clone&lt;/code&gt; на отправляющем конце канала. Это даст нам новый дескриптор отправки, который мы можем передать первому порожденному потоку. Мы передаем исходный отправляющий конец канала второму порожденному потоку. Это дает нам два потока, каждый из которых отправляет разные сообщения на принимающую сторону канала.</target>
        </trans-unit>
        <trans-unit id="03b02e99d0c7b36f56fe77cf1bc6781836989a07" translate="yes" xml:space="preserve">
          <source>This time, the spawned thread has a vector of strings that we want to send to the main thread. We iterate over them, sending each individually, and pause between each by calling the &lt;code&gt;thread::sleep&lt;/code&gt; function with a &lt;code&gt;Duration&lt;/code&gt; value of 1 second.</source>
          <target state="translated">На этот раз порожденный поток имеет вектор строк, который мы хотим отправить в основной поток. Мы перебираем их, отправляя каждый по отдельности, и делаем паузу между ними, вызывая функцию &lt;code&gt;thread::sleep&lt;/code&gt; со значением &lt;code&gt;Duration&lt;/code&gt; , равным 1 секунде.</target>
        </trans-unit>
        <trans-unit id="704e60202fcb30892563c7bc7f66fbb6decda49f" translate="yes" xml:space="preserve">
          <source>This trait allows constructing network objects like &lt;a href=&quot;struct.tcpstream&quot;&gt;&lt;code&gt;TcpStream&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;struct.udpsocket&quot;&gt;&lt;code&gt;UdpSocket&lt;/code&gt;&lt;/a&gt; easily with values of various types for the bind/connection address. It is needed because sometimes one type is more appropriate than the other: for simple uses a string like &lt;code&gt;&quot;localhost:12345&quot;&lt;/code&gt; is much nicer than manual construction of the corresponding &lt;a href=&quot;enum.socketaddr&quot;&gt;&lt;code&gt;SocketAddr&lt;/code&gt;&lt;/a&gt;, but sometimes &lt;a href=&quot;enum.socketaddr&quot;&gt;&lt;code&gt;SocketAddr&lt;/code&gt;&lt;/a&gt; value is &lt;em&gt;the&lt;/em&gt; main source of the address, and converting it to some other type (e.g., a string) just for it to be converted back to &lt;a href=&quot;enum.socketaddr&quot;&gt;&lt;code&gt;SocketAddr&lt;/code&gt;&lt;/a&gt; in constructor methods is pointless.</source>
          <target state="translated">Эта черта позволяет легко создавать сетевые объекты, такие как &lt;a href=&quot;struct.tcpstream&quot;&gt; &lt;code&gt;TcpStream&lt;/code&gt; &lt;/a&gt; или &lt;a href=&quot;struct.udpsocket&quot;&gt; &lt;code&gt;UdpSocket&lt;/code&gt; ,&lt;/a&gt; со значениями различных типов для адреса привязки / подключения. Это необходимо , потому что иногда один тип является более подходящим , чем другие: для простого использования строки , как &lt;code&gt;&quot;localhost:12345&quot;&lt;/code&gt; намного лучше , чем ручное построение соответствующего &lt;a href=&quot;enum.socketaddr&quot;&gt; &lt;code&gt;SocketAddr&lt;/code&gt; &lt;/a&gt; , но иногда &lt;a href=&quot;enum.socketaddr&quot;&gt; &lt;code&gt;SocketAddr&lt;/code&gt; &lt;/a&gt; значения основного источника адреса и преобразование его в какой-то другой тип (например, строку) только для того, чтобы преобразовать обратно в &lt;a href=&quot;enum.socketaddr&quot;&gt; &lt;code&gt;SocketAddr&lt;/code&gt; &lt;/a&gt; в методах конструктора, бессмысленно.&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="f4c03571c99fa2a4a0d6d2bd73efa6856a353a75" translate="yes" xml:space="preserve">
          <source>This trait allows for partial equality, for types that do not have a full equivalence relation. For example, in floating point numbers &lt;code&gt;NaN != NaN&lt;/code&gt;, so floating point types implement &lt;code&gt;PartialEq&lt;/code&gt; but not &lt;a href=&quot;trait.eq&quot;&gt;&lt;code&gt;Eq&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6796333a1773b86bb39aa9af35062f79738f2038" translate="yes" xml:space="preserve">
          <source>This trait allows for partial equality, for types that do not have a full equivalence relation. For example, in floating point numbers &lt;code&gt;NaN != NaN&lt;/code&gt;, so floating point types implement &lt;code&gt;PartialEq&lt;/code&gt; but not &lt;a href=&quot;trait.partialeq#tymethod.eq&quot;&gt;&lt;code&gt;Eq&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1802ac1cfe1536c265ef2f2bdbe3a05ea51c03f9" translate="yes" xml:space="preserve">
          <source>This trait allows for partial equality, for types that do not have a full equivalence relation. For example, in floating point numbers &lt;code&gt;NaN != NaN&lt;/code&gt;, so floating point types implement &lt;code&gt;PartialEq&lt;/code&gt; but not &lt;code&gt;Eq&lt;/code&gt;.</source>
          <target state="translated">Эта черта допускает частичное равенство для типов, не имеющих отношения полной эквивалентности. Например, в числах с плавающей запятой &lt;code&gt;NaN != NaN&lt;/code&gt; , поэтому типы с плавающей запятой реализуют &lt;code&gt;PartialEq&lt;/code&gt; , но не &lt;code&gt;Eq&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ff1d61ee8b274d07d29615e751a57961b3d97e97" translate="yes" xml:space="preserve">
          <source>This trait can be used to create a &lt;a href=&quot;struct.waker&quot;&gt;&lt;code&gt;Waker&lt;/code&gt;&lt;/a&gt;. An executor can define an implementation of this trait, and use that to construct a Waker to pass to the tasks that are executed on that executor.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7bebce9a7c84fca1499f5aca86035aeb53d64365" translate="yes" xml:space="preserve">
          <source>This trait can be used to implement other traits on fixed-size arrays without causing much metadata bloat.</source>
          <target state="translated">Этот признак может быть использован для реализации других признаков на массивах с фиксированным размером без значительного раздувания метаданных.</target>
        </trans-unit>
        <trans-unit id="45737752ce770a5a32320c65da9b598f29acafd8" translate="yes" xml:space="preserve">
          <source>This trait can be used with &lt;code&gt;#[derive]&lt;/code&gt; if all fields are &lt;code&gt;Clone&lt;/code&gt;. The &lt;code&gt;derive&lt;/code&gt;d implementation of &lt;a href=&quot;trait.clone#tymethod.clone&quot;&gt;&lt;code&gt;Clone&lt;/code&gt;&lt;/a&gt; calls &lt;a href=&quot;trait.clone#tymethod.clone&quot;&gt;&lt;code&gt;clone&lt;/code&gt;&lt;/a&gt; on each field.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5800007da2c584795de3c7fc5ff71b96b272866c" translate="yes" xml:space="preserve">
          <source>This trait can be used with &lt;code&gt;#[derive]&lt;/code&gt; if all fields are &lt;code&gt;Clone&lt;/code&gt;. The &lt;code&gt;derive&lt;/code&gt;d implementation of &lt;a href=&quot;trait.clone#tymethod.clone&quot;&gt;&lt;code&gt;clone&lt;/code&gt;&lt;/a&gt; calls &lt;a href=&quot;trait.clone#tymethod.clone&quot;&gt;&lt;code&gt;clone&lt;/code&gt;&lt;/a&gt; on each field.</source>
          <target state="translated">Эта черта может использоваться с &lt;code&gt;#[derive]&lt;/code&gt; , если все поля - &lt;code&gt;Clone&lt;/code&gt; . Реализация &lt;code&gt;derive&lt;/code&gt; d &lt;a href=&quot;trait.clone#tymethod.clone&quot;&gt; &lt;code&gt;clone&lt;/code&gt; &lt;/a&gt; вызывает &lt;a href=&quot;trait.clone#tymethod.clone&quot;&gt; &lt;code&gt;clone&lt;/code&gt; &lt;/a&gt; для каждого поля.</target>
        </trans-unit>
        <trans-unit id="e6a77474d17602cdca329051113afe871aed6794" translate="yes" xml:space="preserve">
          <source>This trait can be used with &lt;code&gt;#[derive]&lt;/code&gt; if all fields implement &lt;code&gt;Debug&lt;/code&gt;. When &lt;code&gt;derive&lt;/code&gt;d for structs, it will use the name of the &lt;code&gt;struct&lt;/code&gt;, then &lt;code&gt;{&lt;/code&gt;, then a comma-separated list of each field's name and &lt;code&gt;Debug&lt;/code&gt; value, then &lt;code&gt;}&lt;/code&gt;. For &lt;code&gt;enum&lt;/code&gt;s, it will use the name of the variant and, if applicable, &lt;code&gt;(&lt;/code&gt;, then the &lt;code&gt;Debug&lt;/code&gt; values of the fields, then &lt;code&gt;)&lt;/code&gt;.</source>
          <target state="translated">Эту черту можно использовать с &lt;code&gt;#[derive]&lt;/code&gt; , если все поля реализуют &lt;code&gt;Debug&lt;/code&gt; . При &lt;code&gt;derive&lt;/code&gt; d для структур будет использоваться имя &lt;code&gt;struct&lt;/code&gt; , затем &lt;code&gt;{&lt;/code&gt; , затем список разделенных запятыми имен каждого поля и значения &lt;code&gt;Debug&lt;/code&gt; , затем &lt;code&gt;}&lt;/code&gt; . Для &lt;code&gt;enum&lt;/code&gt; s будет использоваться имя варианта и, если применимо, &lt;code&gt;(&lt;/code&gt; затем значения полей &lt;code&gt;Debug&lt;/code&gt; , затем &lt;code&gt;)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a1a45e25757830b253d95a2bc878b147cc25a79e" translate="yes" xml:space="preserve">
          <source>This trait can be used with &lt;code&gt;#[derive]&lt;/code&gt; if all of the type's fields implement &lt;code&gt;Default&lt;/code&gt;. When &lt;code&gt;derive&lt;/code&gt;d, it will use the default value for each field's type.</source>
          <target state="translated">Эта черта может использоваться с &lt;code&gt;#[derive]&lt;/code&gt; , если все поля типа реализуют &lt;code&gt;Default&lt;/code&gt; . При &lt;code&gt;derive&lt;/code&gt; d он будет использовать значение по умолчанию для каждого типа поля.</target>
        </trans-unit>
        <trans-unit id="2676a9e67ccce40e213776c8079ad50bcc6e9ebc" translate="yes" xml:space="preserve">
          <source>This trait can be used with &lt;code&gt;#[derive]&lt;/code&gt;. When &lt;code&gt;derive&lt;/code&gt;d on structs, it will produce a &lt;a href=&quot;https://en.wikipedia.org/wiki/Lexicographic_order&quot;&gt;lexicographic&lt;/a&gt; ordering based on the top-to-bottom declaration order of the struct's members. When &lt;code&gt;derive&lt;/code&gt;d on enums, variants are ordered by their top-to-bottom discriminant order.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f09d6ff7ae1d14cf4065033999ff08ecaa8a87ff" translate="yes" xml:space="preserve">
          <source>This trait can be used with &lt;code&gt;#[derive]&lt;/code&gt;. When &lt;code&gt;derive&lt;/code&gt;d on structs, it will produce a lexicographic ordering based on the top-to-bottom declaration order of the struct's members. When &lt;code&gt;derive&lt;/code&gt;d on enums, variants are ordered by their top-to-bottom declaration order.</source>
          <target state="translated">Эта черта может использоваться с &lt;code&gt;#[derive]&lt;/code&gt; . При &lt;code&gt;derive&lt;/code&gt; d на структурах он создает лексикографический порядок, основанный на порядке объявления элементов структуры сверху вниз. При &lt;code&gt;derive&lt;/code&gt; d на перечислениях варианты упорядочиваются по порядку объявления сверху вниз.</target>
        </trans-unit>
        <trans-unit id="9c8b40d33d991fc237bdd0ad2e6af05e65ea6f04" translate="yes" xml:space="preserve">
          <source>This trait can be used with &lt;code&gt;#[derive]&lt;/code&gt;. When &lt;code&gt;derive&lt;/code&gt;d on structs, it will produce a lexicographic ordering based on the top-to-bottom declaration order of the struct's members. When &lt;code&gt;derive&lt;/code&gt;d on enums, variants are ordered by their top-to-bottom discriminant order.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="86c69254ea90ce1d6926208560c4e9d29d5a8ded" translate="yes" xml:space="preserve">
          <source>This trait can be used with &lt;code&gt;#[derive]&lt;/code&gt;. When &lt;code&gt;derive&lt;/code&gt;d on structs, two instances are equal if all fields are equal, and not equal if any fields are not equal. When &lt;code&gt;derive&lt;/code&gt;d on enums, each variant is equal to itself and not equal to the other variants.</source>
          <target state="translated">Эта черта может использоваться с &lt;code&gt;#[derive]&lt;/code&gt; . При &lt;code&gt;derive&lt;/code&gt; d для структур два экземпляра равны, если все поля равны, и не равны, если какие-либо поля не равны. При &lt;code&gt;derive&lt;/code&gt; d на перечислениях каждый вариант равен самому себе и не равен другим вариантам.</target>
        </trans-unit>
        <trans-unit id="d52b5ae617172e107648185da3f817960014bc61" translate="yes" xml:space="preserve">
          <source>This trait can be used with &lt;code&gt;#[derive]&lt;/code&gt;. When &lt;code&gt;derive&lt;/code&gt;d, because &lt;code&gt;Eq&lt;/code&gt; has no extra methods, it is only informing the compiler that this is an equivalence relation rather than a partial equivalence relation. Note that the &lt;code&gt;derive&lt;/code&gt; strategy requires all fields are &lt;code&gt;Eq&lt;/code&gt;, which isn't always desired.</source>
          <target state="translated">Эта черта может использоваться с &lt;code&gt;#[derive]&lt;/code&gt; . При &lt;code&gt;derive&lt;/code&gt; d, поскольку &lt;code&gt;Eq&lt;/code&gt; не имеет дополнительных методов, он только сообщает компилятору, что это отношение эквивалентности, а не отношение частичной эквивалентности. Обратите внимание, что стратегия &lt;code&gt;derive&lt;/code&gt; требует, чтобы все поля были &lt;code&gt;Eq&lt;/code&gt; , что не всегда желательно.</target>
        </trans-unit>
        <trans-unit id="7f803568cc6e1099a89a4940b9eb35200f2785e5" translate="yes" xml:space="preserve">
          <source>This trait is &lt;code&gt;unsafe&lt;/code&gt; because its implementation must be correct for the safety of &lt;code&gt;unsafe trait TrustedLen&lt;/code&gt; implementations, and the results of using this trait can otherwise be trusted by &lt;code&gt;unsafe&lt;/code&gt; code to be correct and fulfill the listed obligations.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4ec116d7c92b2e4ed9689a8552deb9b1c3c9f209" translate="yes" xml:space="preserve">
          <source>This trait is a memory-safe and ergonomic alternative to constructing a &lt;a href=&quot;struct.rawwaker&quot;&gt;&lt;code&gt;RawWaker&lt;/code&gt;&lt;/a&gt;. It supports the common executor design in which the data used to wake up a task is stored in an &lt;a href=&quot;../sync/struct.arc&quot;&gt;&lt;code&gt;Arc&lt;/code&gt;&lt;/a&gt;. Some executors (especially those for embedded systems) cannot use this API, which is why &lt;a href=&quot;struct.rawwaker&quot;&gt;&lt;code&gt;RawWaker&lt;/code&gt;&lt;/a&gt; exists as an alternative for those systems.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0b8679bc430feac142d06128a89f1af63473e460" translate="yes" xml:space="preserve">
          <source>This trait is automatically implemented for almost every type.</source>
          <target state="translated">Этот признак автоматически реализуется практически для каждого типа.</target>
        </trans-unit>
        <trans-unit id="ce8cc586f2666a5f5f3d6650a18ec09e61d24a39" translate="yes" xml:space="preserve">
          <source>This trait is automatically implemented for any type which implements the &lt;a href=&quot;../fmt/trait.display&quot;&gt;&lt;code&gt;Display&lt;/code&gt;&lt;/a&gt; trait. As such, &lt;code&gt;ToString&lt;/code&gt; shouldn't be implemented directly: &lt;a href=&quot;../fmt/trait.display&quot;&gt;&lt;code&gt;Display&lt;/code&gt;&lt;/a&gt; should be implemented instead, and you get the &lt;code&gt;ToString&lt;/code&gt; implementation for free.</source>
          <target state="translated">Эта черта автоматически реализуется для любого типа, который реализует черту &lt;a href=&quot;../fmt/trait.display&quot;&gt; &lt;code&gt;Display&lt;/code&gt; &lt;/a&gt; . Таким образом, &lt;code&gt;ToString&lt;/code&gt; не следует реализовывать напрямую: вместо этого следует реализовать &lt;a href=&quot;../fmt/trait.display&quot;&gt; &lt;code&gt;Display&lt;/code&gt; &lt;/a&gt; , и вы получаете реализацию &lt;code&gt;ToString&lt;/code&gt; бесплатно.</target>
        </trans-unit>
        <trans-unit id="82a06decfe065900879f7436e10b252705283acf" translate="yes" xml:space="preserve">
          <source>This trait is automatically implemented for every type and does not add any guarantees to &lt;a href=&quot;../mem/struct.discriminant&quot;&gt;&lt;code&gt;mem::Discriminant&lt;/code&gt;&lt;/a&gt;. It is &lt;strong&gt;undefined behavior&lt;/strong&gt; to transmute between &lt;code&gt;DiscriminantKind::Discriminant&lt;/code&gt; and &lt;code&gt;mem::Discriminant&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5e3b32607a26276b7eeb2dc3f257150496699a30" translate="yes" xml:space="preserve">
          <source>This trait is automatically implemented when the compiler determines it's appropriate.</source>
          <target state="translated">Этот признак реализуется автоматически,когда компилятор определяет его целесообразность.</target>
        </trans-unit>
        <trans-unit id="494ae62c6025e3f79bcb3a8e54a1efc9a121264f" translate="yes" xml:space="preserve">
          <source>This trait is implemented by default for many types and behaves similarly in terms of inference of implementation to the &lt;a href=&quot;../marker/trait.send&quot;&gt;&lt;code&gt;Send&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../marker/trait.sync&quot;&gt;&lt;code&gt;Sync&lt;/code&gt;&lt;/a&gt; traits. The purpose of this trait is to encode what types are safe to cross a &lt;a href=&quot;fn.catch_unwind&quot;&gt;&lt;code&gt;catch_unwind&lt;/code&gt;&lt;/a&gt; boundary with no fear of unwind safety.</source>
          <target state="translated">Эта черта реализована по умолчанию для многих типов и ведет себя аналогичным образом с точки зрения логического вывода реализации для черт &lt;a href=&quot;../marker/trait.send&quot;&gt; &lt;code&gt;Send&lt;/code&gt; &lt;/a&gt; и &lt;a href=&quot;../marker/trait.sync&quot;&gt; &lt;code&gt;Sync&lt;/code&gt; &lt;/a&gt; . Цель этой черты - кодировать, какие типы могут безопасно пересекать границу &lt;a href=&quot;fn.catch_unwind&quot;&gt; &lt;code&gt;catch_unwind&lt;/code&gt; ,&lt;/a&gt; не опасаясь безопасности при раскручивании.</target>
        </trans-unit>
        <trans-unit id="6fb1b7be6434ef1f997fff7cbfd045083e8560fe" translate="yes" xml:space="preserve">
          <source>This trait is namely not implemented by &lt;a href=&quot;../cell/struct.unsafecell&quot;&gt;&lt;code&gt;UnsafeCell&lt;/code&gt;&lt;/a&gt;, the root of all interior mutability.</source>
          <target state="translated">Эта черта не реализована &lt;a href=&quot;../cell/struct.unsafecell&quot;&gt; &lt;code&gt;UnsafeCell&lt;/code&gt; &lt;/a&gt; , корнем всей внутренней изменчивости.</target>
        </trans-unit>
        <trans-unit id="1d0c0de184f4ceb6563275bbcba7c14bd0a8edcc" translate="yes" xml:space="preserve">
          <source>This trait is similar to &lt;a href=&quot;trait.asmut&quot;&gt;&lt;code&gt;AsMut&lt;/code&gt;&lt;/a&gt; which is used for converting between mutable references. If you need to do a costly conversion it is better to implement &lt;a href=&quot;trait.from&quot;&gt;&lt;code&gt;From&lt;/code&gt;&lt;/a&gt; with type &lt;code&gt;&amp;amp;T&lt;/code&gt; or write a custom function.</source>
          <target state="translated">Эта черта похожа на &lt;a href=&quot;trait.asmut&quot;&gt; &lt;code&gt;AsMut&lt;/code&gt; ,&lt;/a&gt; который используется для преобразования между изменяемыми ссылками. Если вам нужно выполнить дорогостоящее преобразование, лучше реализовать &lt;a href=&quot;trait.from&quot;&gt; &lt;code&gt;From&lt;/code&gt; &lt;/a&gt; с типом &lt;code&gt;&amp;amp;T&lt;/code&gt; или написать собственную функцию.</target>
        </trans-unit>
        <trans-unit id="72c951714ee4a3342d70f41b91f0921e7e49ebf0" translate="yes" xml:space="preserve">
          <source>This trait is similar to &lt;a href=&quot;trait.asref&quot;&gt;&lt;code&gt;AsRef&lt;/code&gt;&lt;/a&gt; but used for converting between mutable references. If you need to do a costly conversion it is better to implement &lt;a href=&quot;trait.from&quot;&gt;&lt;code&gt;From&lt;/code&gt;&lt;/a&gt; with type &lt;code&gt;&amp;amp;mut T&lt;/code&gt; or write a custom function.</source>
          <target state="translated">Эта черта похожа на &lt;a href=&quot;trait.asref&quot;&gt; &lt;code&gt;AsRef&lt;/code&gt; ,&lt;/a&gt; но используется для преобразования между изменяемыми ссылками. Если вам нужно выполнить дорогостоящее преобразование, лучше реализовать &lt;a href=&quot;trait.from&quot;&gt; &lt;code&gt;From&lt;/code&gt; &lt;/a&gt; с типом &lt;code&gt;&amp;amp;mut T&lt;/code&gt; или написать собственную функцию.</target>
        </trans-unit>
        <trans-unit id="1a731da3b36000bb0e86dfbd3105e49bf55c952e" translate="yes" xml:space="preserve">
          <source>This trait is the type which this modules requires when formatting information. This is similar to the standard library's &lt;a href=&quot;../io/trait.write&quot;&gt;&lt;code&gt;io::Write&lt;/code&gt;&lt;/a&gt; trait, but it is only intended for use in libcore.</source>
          <target state="translated">Эта черта является типом, который требуется этим модулям при форматировании информации. Это похоже на свойство стандартной библиотеки &lt;a href=&quot;../io/trait.write&quot;&gt; &lt;code&gt;io::Write&lt;/code&gt; &lt;/a&gt; , но предназначено только для использования в libcore.</target>
        </trans-unit>
        <trans-unit id="0b733d2267c635d65e2675dc57b25279df45e854" translate="yes" xml:space="preserve">
          <source>This trait is used for generic address resolution when constructing network objects. By default it is implemented for the following types:</source>
          <target state="translated">Этот признак используется для общего разрешения адресов при построении сетевых объектов.По умолчанию он реализован для следующих типов:</target>
        </trans-unit>
        <trans-unit id="1e3fe626c5ddea26b813fe813b589bf866e90fcc" translate="yes" xml:space="preserve">
          <source>This trait is used to implement the &lt;a href=&quot;trait.product#tymethod.product&quot;&gt;&lt;code&gt;product()&lt;/code&gt;&lt;/a&gt; method on iterators. Types which implement the trait can be generated by the &lt;a href=&quot;trait.product#tymethod.product&quot;&gt;&lt;code&gt;product()&lt;/code&gt;&lt;/a&gt; method. Like &lt;a href=&quot;trait.fromiterator&quot;&gt;&lt;code&gt;FromIterator&lt;/code&gt;&lt;/a&gt; this trait should rarely be called directly and instead interacted with through &lt;a href=&quot;trait.iterator#method.product&quot;&gt;&lt;code&gt;Iterator::product()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d670e5f44288c65ae601422a01219d930136f211" translate="yes" xml:space="preserve">
          <source>This trait is used to implement the &lt;a href=&quot;trait.product#tymethod.product&quot;&gt;&lt;code&gt;product&lt;/code&gt;&lt;/a&gt; method on iterators. Types which implement the trait can be generated by the &lt;a href=&quot;trait.product#tymethod.product&quot;&gt;&lt;code&gt;product&lt;/code&gt;&lt;/a&gt; method. Like &lt;a href=&quot;trait.fromiterator&quot;&gt;&lt;code&gt;FromIterator&lt;/code&gt;&lt;/a&gt; this trait should rarely be called directly and instead interacted with through &lt;a href=&quot;trait.iterator#method.product&quot;&gt;&lt;code&gt;Iterator::product&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Эта черта используется для реализации метода &lt;a href=&quot;trait.product#tymethod.product&quot;&gt; &lt;code&gt;product&lt;/code&gt; &lt;/a&gt; на итераторах. Типы, реализующие признак, могут быть сгенерированы методом &lt;a href=&quot;trait.product#tymethod.product&quot;&gt; &lt;code&gt;product&lt;/code&gt; &lt;/a&gt; . Как и &lt;a href=&quot;trait.fromiterator&quot;&gt; &lt;code&gt;FromIterator&lt;/code&gt; ,&lt;/a&gt; этот трейт редко следует вызывать напрямую, а вместо этого следует взаимодействовать с ним через &lt;a href=&quot;trait.iterator#method.product&quot;&gt; &lt;code&gt;Iterator::product&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="45f3e129667be9feede25a178448a0d3c4ddec5b" translate="yes" xml:space="preserve">
          <source>This trait is used to implement the &lt;a href=&quot;trait.sum#tymethod.sum&quot;&gt;&lt;code&gt;sum()&lt;/code&gt;&lt;/a&gt; method on iterators. Types which implement the trait can be generated by the &lt;a href=&quot;trait.sum#tymethod.sum&quot;&gt;&lt;code&gt;sum()&lt;/code&gt;&lt;/a&gt; method. Like &lt;a href=&quot;trait.fromiterator&quot;&gt;&lt;code&gt;FromIterator&lt;/code&gt;&lt;/a&gt; this trait should rarely be called directly and instead interacted with through &lt;a href=&quot;trait.iterator#method.sum&quot;&gt;&lt;code&gt;Iterator::sum()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f91608e2b2b005f5d3b20c487cd2efcf273838ce" translate="yes" xml:space="preserve">
          <source>This trait is used to implement the &lt;a href=&quot;trait.sum#tymethod.sum&quot;&gt;&lt;code&gt;sum&lt;/code&gt;&lt;/a&gt; method on iterators. Types which implement the trait can be generated by the &lt;a href=&quot;trait.sum#tymethod.sum&quot;&gt;&lt;code&gt;sum&lt;/code&gt;&lt;/a&gt; method. Like &lt;a href=&quot;trait.fromiterator&quot;&gt;&lt;code&gt;FromIterator&lt;/code&gt;&lt;/a&gt; this trait should rarely be called directly and instead interacted with through &lt;a href=&quot;trait.iterator#method.sum&quot;&gt;&lt;code&gt;Iterator::sum&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Эта черта используется для реализации метода &lt;a href=&quot;trait.sum#tymethod.sum&quot;&gt; &lt;code&gt;sum&lt;/code&gt; &lt;/a&gt; на итераторах. Типы, реализующие признак, могут быть сгенерированы методом &lt;a href=&quot;trait.sum#tymethod.sum&quot;&gt; &lt;code&gt;sum&lt;/code&gt; &lt;/a&gt; . Как и &lt;a href=&quot;trait.fromiterator&quot;&gt; &lt;code&gt;FromIterator&lt;/code&gt; ,&lt;/a&gt; этот трейт редко следует вызывать напрямую, а вместо этого следует взаимодействовать с ним через &lt;a href=&quot;trait.iterator#method.sum&quot;&gt; &lt;code&gt;Iterator::sum&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="b392534a7b8b5e656825847e787994b0e838f382" translate="yes" xml:space="preserve">
          <source>This trait must only be implemented when the contract is upheld. Consumers of this trait must inspect &lt;a href=&quot;trait.iterator#method.size_hint&quot;&gt;&lt;code&gt;.size_hint&lt;/code&gt;&lt;/a&gt;&amp;rsquo;s upper bound.</source>
          <target state="translated">Эта черта может быть реализована только при соблюдении контракта. Потребители этой черты должны проверить верхнюю границу &lt;a href=&quot;trait.iterator#method.size_hint&quot;&gt; &lt;code&gt;.size_hint&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="6d78a10342907305049d898a7fef5c559c08564a" translate="yes" xml:space="preserve">
          <source>This trait must only be implemented when the contract is upheld. Consumers of this trait must inspect &lt;a href=&quot;trait.iterator#method.size_hint&quot;&gt;&lt;code&gt;Iterator::size_hint()&lt;/code&gt;&lt;/a&gt;&amp;rsquo;s upper bound.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f26cbb7d217e71e5e8a2a5d99b20ac95a15952a0" translate="yes" xml:space="preserve">
          <source>This trait only accepts UTF-8&amp;ndash;encoded data and is not &lt;a href=&quot;../io/trait.write#tymethod.flush&quot;&gt;flushable&lt;/a&gt;. If you only want to accept Unicode and you don't need flushing, you should implement this trait; otherwise you should implement &lt;a href=&quot;../io/trait.write&quot;&gt;&lt;code&gt;std::io::Write&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="92b09db877c076776794822e006bb3f0094cf13d" translate="yes" xml:space="preserve">
          <source>This trait provides methods for searching for non-overlapping matches of a pattern starting from the back (right) of a string.</source>
          <target state="translated">Этот признак предоставляет методы поиска неперекрывающихся совпадений шаблона,начиная с обратной стороны (справа)строки.</target>
        </trans-unit>
        <trans-unit id="581e031865e09ba379141c2883157c1d8acecf2b" translate="yes" xml:space="preserve">
          <source>This trait provides methods for searching for non-overlapping matches of a pattern starting from the front (left) of a string.</source>
          <target state="translated">Этот признак предоставляет методы поиска неперекрывающихся совпадений шаблона,начиная с передней (левой)части строки.</target>
        </trans-unit>
        <trans-unit id="577d84c8d58ef48b8ffaf1a01ef5ed3b028f5279" translate="yes" xml:space="preserve">
          <source>This trait provides transitive access to source-stage in an interator-adapter pipeline under the conditions that</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7d02b91849e023371b70419d209ec71d8ae7432d" translate="yes" xml:space="preserve">
          <source>This trait should generally not be implemented by consumers of the standard library. The &lt;a href=&quot;../macro.write&quot;&gt;&lt;code&gt;write!&lt;/code&gt;&lt;/a&gt; macro accepts an instance of &lt;a href=&quot;../io/trait.write&quot;&gt;&lt;code&gt;io::Write&lt;/code&gt;&lt;/a&gt;, and the &lt;a href=&quot;../io/trait.write&quot;&gt;&lt;code&gt;io::Write&lt;/code&gt;&lt;/a&gt; trait is favored over implementing this trait.</source>
          <target state="translated">Эта черта обычно не должна реализовываться потребителями стандартной библиотеки. &lt;a href=&quot;../macro.write&quot;&gt; &lt;code&gt;write!&lt;/code&gt; &lt;/a&gt;Макрос принимает экземпляр &lt;a href=&quot;../io/trait.write&quot;&gt; &lt;code&gt;io::Write&lt;/code&gt; &lt;/a&gt; , и признак &lt;a href=&quot;../io/trait.write&quot;&gt; &lt;code&gt;io::Write&lt;/code&gt; &lt;/a&gt; предпочтительнее реализации этого признака.</target>
        </trans-unit>
        <trans-unit id="6159bc779b64f1381d56daf00e89fd123440f35d" translate="yes" xml:space="preserve">
          <source>This tree shows how some of the modules nest inside one another (for example, &lt;code&gt;hosting&lt;/code&gt; nests inside &lt;code&gt;front_of_house&lt;/code&gt;). The tree also shows that some modules are &lt;em&gt;siblings&lt;/em&gt; to each other, meaning they&amp;rsquo;re defined in the same module (&lt;code&gt;hosting&lt;/code&gt; and &lt;code&gt;serving&lt;/code&gt; are defined within &lt;code&gt;front_of_house&lt;/code&gt;). To continue the family metaphor, if module A is contained inside module B, we say that module A is the &lt;em&gt;child&lt;/em&gt; of module B and that module B is the &lt;em&gt;parent&lt;/em&gt; of module A. Notice that the entire module tree is rooted under the implicit module named &lt;code&gt;crate&lt;/code&gt;.</source>
          <target state="translated">Это дерево показывает , как некоторые из гнезда модулей внутри друг друга (например, &lt;code&gt;hosting&lt;/code&gt; гнезда внутри &lt;code&gt;front_of_house&lt;/code&gt; ). Дерево также показывает, что некоторые модули являются &lt;em&gt;родственниками&lt;/em&gt; друг друга, то есть они определены в одном модуле ( &lt;code&gt;hosting&lt;/code&gt; и &lt;code&gt;serving&lt;/code&gt; определяются в &lt;code&gt;front_of_house&lt;/code&gt; ). Чтобы продолжить семейную метафору, если модуль A содержится внутри модуля B, мы говорим, что модуль A является &lt;em&gt;дочерним&lt;/em&gt; по отношению к модулю B, а модуль B является &lt;em&gt;родительским&lt;/em&gt; для модуля A. Обратите внимание, что все дерево модулей укоренено в неявном модуле с именем &lt;code&gt;crate&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6a2a59de8ad5e3abf90b08ea27feb4c5c9564363" translate="yes" xml:space="preserve">
          <source>This trick is very sneaky and complicated. Don&amp;rsquo;t worry if it doesn&amp;rsquo;t make perfect sense; someday, it will be completely unnecessary.</source>
          <target state="translated">Этот трюк очень хитрый и сложный. Не волнуйтесь, если это не имеет смысла; когда-нибудь это станет совершенно ненужным.</target>
        </trans-unit>
        <trans-unit id="e51c9b4abf7ac4d9724545d7cabc828636bce6da" translate="yes" xml:space="preserve">
          <source>This type can represent a wide range of decimal numbers, like &lt;code&gt;3.5&lt;/code&gt;, &lt;code&gt;27&lt;/code&gt;, &lt;code&gt;-113.75&lt;/code&gt;, &lt;code&gt;0.0078125&lt;/code&gt;, &lt;code&gt;34359738368&lt;/code&gt;, &lt;code&gt;0&lt;/code&gt;, &lt;code&gt;-1&lt;/code&gt;. So unlike integer types (such as &lt;code&gt;i32&lt;/code&gt;), floating point types can represent non-integer numbers, too.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b151d516c842037f13cd18d29f046aea06e0121e" translate="yes" xml:space="preserve">
          <source>This type cannot have a well-defined size, because it needs to be arbitrarily large (since we would be able to nest &lt;code&gt;ListNode&lt;/code&gt;s to any depth). Specifically,</source>
          <target state="translated">Этот тип не может иметь четко определенного размера, потому что он должен быть произвольно большим (поскольку мы могли бы &lt;code&gt;ListNode&lt;/code&gt; на любую глубину). В частности,</target>
        </trans-unit>
        <trans-unit id="84f5f45f7092418ba53ffa588ed49cf6c55b3005" translate="yes" xml:space="preserve">
          <source>This type does not support transmission of an error other than that an error occurred. Any extra information must be arranged to be transmitted through some other means.</source>
          <target state="translated">Этот тип не поддерживает передачу ошибки,кроме того,что произошла ошибка.Любая дополнительная информация должна быть организована для передачи другими способами.</target>
        </trans-unit>
        <trans-unit id="ca06708cb31886f20e9999f83e4a96bd88513b09" translate="yes" xml:space="preserve">
          <source>This type has the same in-memory representation as a &lt;a href=&quot;../../primitive.bool&quot;&gt;&lt;code&gt;bool&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Этот тип имеет то же представление в памяти, что и &lt;a href=&quot;../../primitive.bool&quot;&gt; &lt;code&gt;bool&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="7ed5168f106b9ae49d6a5ac8c4fbf062da809a4c" translate="yes" xml:space="preserve">
          <source>This type has the same in-memory representation as a &lt;code&gt;*mut T&lt;/code&gt;.</source>
          <target state="translated">Этот тип имеет такое же представление в памяти как &lt;code&gt;*mut T&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="bde0ba16d9d2a17d2da79db3c616fd2db5d4b738" translate="yes" xml:space="preserve">
          <source>This type has the same in-memory representation as the underlying integer type, &lt;a href=&quot;../../primitive.i16&quot;&gt;&lt;code&gt;i16&lt;/code&gt;&lt;/a&gt;. For more about the differences between atomic types and non-atomic types as well as information about the portability of this type, please see the &lt;a href=&quot;index&quot;&gt;module-level documentation&lt;/a&gt;.</source>
          <target state="translated">Этот тип имеет то же представление в памяти, что и базовый целочисленный тип &lt;a href=&quot;../../primitive.i16&quot;&gt; &lt;code&gt;i16&lt;/code&gt; &lt;/a&gt; . Дополнительные сведения о различиях между атомарными и неатомарными типами, а также информацию о переносимости этого типа см. В &lt;a href=&quot;index&quot;&gt;документации уровня модуля&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="11fe8d9ef82cc58363e607b1900488902f96b062" translate="yes" xml:space="preserve">
          <source>This type has the same in-memory representation as the underlying integer type, &lt;a href=&quot;../../primitive.i32&quot;&gt;&lt;code&gt;i32&lt;/code&gt;&lt;/a&gt;. For more about the differences between atomic types and non-atomic types as well as information about the portability of this type, please see the &lt;a href=&quot;index&quot;&gt;module-level documentation&lt;/a&gt;.</source>
          <target state="translated">Этот тип имеет то же представление в памяти, что и базовый целочисленный тип &lt;a href=&quot;../../primitive.i32&quot;&gt; &lt;code&gt;i32&lt;/code&gt; &lt;/a&gt; . Дополнительные сведения о различиях между атомарными и неатомарными типами, а также информацию о переносимости этого типа см. В &lt;a href=&quot;index&quot;&gt;документации уровня модуля&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="ae2c41e53be3c451cd7fe9d715ded32f7f324930" translate="yes" xml:space="preserve">
          <source>This type has the same in-memory representation as the underlying integer type, &lt;a href=&quot;../../primitive.i64&quot;&gt;&lt;code&gt;i64&lt;/code&gt;&lt;/a&gt;. For more about the differences between atomic types and non-atomic types as well as information about the portability of this type, please see the &lt;a href=&quot;index&quot;&gt;module-level documentation&lt;/a&gt;.</source>
          <target state="translated">Этот тип имеет то же представление в памяти, что и базовый целочисленный тип &lt;a href=&quot;../../primitive.i64&quot;&gt; &lt;code&gt;i64&lt;/code&gt; &lt;/a&gt; . Дополнительные сведения о различиях между атомарными и неатомарными типами, а также информацию о переносимости этого типа см. В &lt;a href=&quot;index&quot;&gt;документации уровня модуля&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="8709735902527f53136366bbc4da81e059b1cf29" translate="yes" xml:space="preserve">
          <source>This type has the same in-memory representation as the underlying integer type, &lt;a href=&quot;../../primitive.i8&quot;&gt;&lt;code&gt;i8&lt;/code&gt;&lt;/a&gt;. For more about the differences between atomic types and non-atomic types as well as information about the portability of this type, please see the &lt;a href=&quot;index&quot;&gt;module-level documentation&lt;/a&gt;.</source>
          <target state="translated">Этот тип имеет то же представление в памяти, что и базовый целочисленный тип &lt;a href=&quot;../../primitive.i8&quot;&gt; &lt;code&gt;i8&lt;/code&gt; &lt;/a&gt; . Дополнительные сведения о различиях между атомарными и неатомарными типами, а также информацию о переносимости этого типа см. В &lt;a href=&quot;index&quot;&gt;документации уровня модуля&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="22a2662795b52aff8d9d5db4f32fbfd5a6eae45b" translate="yes" xml:space="preserve">
          <source>This type has the same in-memory representation as the underlying integer type, &lt;a href=&quot;../../primitive.isize&quot;&gt;&lt;code&gt;isize&lt;/code&gt;&lt;/a&gt;. For more about the differences between atomic types and non-atomic types as well as information about the portability of this type, please see the &lt;a href=&quot;index&quot;&gt;module-level documentation&lt;/a&gt;.</source>
          <target state="translated">Этот тип имеет то же представление в памяти, что и базовый целочисленный тип &lt;a href=&quot;../../primitive.isize&quot;&gt; &lt;code&gt;isize&lt;/code&gt; &lt;/a&gt; . Дополнительные сведения о различиях между атомарными и неатомарными типами, а также информацию о переносимости этого типа см. В &lt;a href=&quot;index&quot;&gt;документации уровня модуля&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="b0e9d5aecbbcb90f5394cd93afd041c8660e20d3" translate="yes" xml:space="preserve">
          <source>This type has the same in-memory representation as the underlying integer type, &lt;a href=&quot;../../primitive.u16&quot;&gt;&lt;code&gt;u16&lt;/code&gt;&lt;/a&gt;. For more about the differences between atomic types and non-atomic types as well as information about the portability of this type, please see the &lt;a href=&quot;index&quot;&gt;module-level documentation&lt;/a&gt;.</source>
          <target state="translated">Этот тип имеет то же представление в памяти, что и базовый целочисленный тип &lt;a href=&quot;../../primitive.u16&quot;&gt; &lt;code&gt;u16&lt;/code&gt; &lt;/a&gt; . Дополнительные сведения о различиях между атомарными и неатомарными типами, а также информацию о переносимости этого типа см. В &lt;a href=&quot;index&quot;&gt;документации уровня модуля&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="c2b9ce184354cce38ff31805f5b9e99cf85271c3" translate="yes" xml:space="preserve">
          <source>This type has the same in-memory representation as the underlying integer type, &lt;a href=&quot;../../primitive.u32&quot;&gt;&lt;code&gt;u32&lt;/code&gt;&lt;/a&gt;. For more about the differences between atomic types and non-atomic types as well as information about the portability of this type, please see the &lt;a href=&quot;index&quot;&gt;module-level documentation&lt;/a&gt;.</source>
          <target state="translated">Этот тип имеет то же представление в памяти, что и базовый целочисленный тип &lt;a href=&quot;../../primitive.u32&quot;&gt; &lt;code&gt;u32&lt;/code&gt; &lt;/a&gt; . Дополнительные сведения о различиях между атомарными и неатомарными типами, а также информацию о переносимости этого типа см. В &lt;a href=&quot;index&quot;&gt;документации уровня модуля&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="4f3b430d11ed80e34dede1d2fe612c5e93a3e75e" translate="yes" xml:space="preserve">
          <source>This type has the same in-memory representation as the underlying integer type, &lt;a href=&quot;../../primitive.u64&quot;&gt;&lt;code&gt;u64&lt;/code&gt;&lt;/a&gt;. For more about the differences between atomic types and non-atomic types as well as information about the portability of this type, please see the &lt;a href=&quot;index&quot;&gt;module-level documentation&lt;/a&gt;.</source>
          <target state="translated">Этот тип имеет то же представление в памяти, что и базовый целочисленный тип &lt;a href=&quot;../../primitive.u64&quot;&gt; &lt;code&gt;u64&lt;/code&gt; &lt;/a&gt; . Дополнительные сведения о различиях между атомарными и неатомарными типами, а также информацию о переносимости этого типа см. В &lt;a href=&quot;index&quot;&gt;документации уровня модуля&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="da5885bb51df1018c63942e6cd581107a9d67b99" translate="yes" xml:space="preserve">
          <source>This type has the same in-memory representation as the underlying integer type, &lt;a href=&quot;../../primitive.u8&quot;&gt;&lt;code&gt;u8&lt;/code&gt;&lt;/a&gt;. For more about the differences between atomic types and non-atomic types as well as information about the portability of this type, please see the &lt;a href=&quot;index&quot;&gt;module-level documentation&lt;/a&gt;.</source>
          <target state="translated">Этот тип имеет то же представление в памяти, что и базовый целочисленный тип &lt;a href=&quot;../../primitive.u8&quot;&gt; &lt;code&gt;u8&lt;/code&gt; &lt;/a&gt; . Дополнительные сведения о различиях между атомарными и неатомарными типами, а также информацию о переносимости этого типа см. В &lt;a href=&quot;index&quot;&gt;документации уровня модуля&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="1494d8fbdc9903b4f7f4ce3473fbf110556d56ce" translate="yes" xml:space="preserve">
          <source>This type has the same in-memory representation as the underlying integer type, &lt;a href=&quot;../../primitive.usize&quot;&gt;&lt;code&gt;usize&lt;/code&gt;&lt;/a&gt;. For more about the differences between atomic types and non-atomic types as well as information about the portability of this type, please see the &lt;a href=&quot;index&quot;&gt;module-level documentation&lt;/a&gt;.</source>
          <target state="translated">Этот тип имеет то же представление в памяти, что и базовый целочисленный тип &lt;a href=&quot;../../primitive.usize&quot;&gt; &lt;code&gt;usize&lt;/code&gt; &lt;/a&gt; . Дополнительные сведения о различиях между атомарными и неатомарными типами, а также информацию о переносимости этого типа см. В &lt;a href=&quot;index&quot;&gt;документации уровня модуля&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="fd773ba06290a2ef0eb43046e43b15b9753a1b01" translate="yes" xml:space="preserve">
          <source>This type implements the &lt;a href=&quot;trait.alloc&quot;&gt;&lt;code&gt;Alloc&lt;/code&gt;&lt;/a&gt; trait by forwarding calls to the allocator registered with the &lt;code&gt;#[global_allocator]&lt;/code&gt; attribute if there is one, or the &lt;code&gt;std&lt;/code&gt; crate&amp;rsquo;s default.</source>
          <target state="translated">Этот тип реализует черту &lt;a href=&quot;trait.alloc&quot;&gt; &lt;code&gt;Alloc&lt;/code&gt; &lt;/a&gt; , перенаправляя вызовы распределителю, зарегистрированному с атрибутом &lt;code&gt;#[global_allocator]&lt;/code&gt; , если он есть, или стандартным ящиком &lt;code&gt;std&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0d10c935129b21e89e6454b38394b060ce3b284b" translate="yes" xml:space="preserve">
          <source>This type implements the &lt;a href=&quot;trait.allocref&quot;&gt;&lt;code&gt;AllocRef&lt;/code&gt;&lt;/a&gt; trait by forwarding calls to the allocator registered with the &lt;code&gt;#[global_allocator]&lt;/code&gt; attribute if there is one, or the &lt;code&gt;std&lt;/code&gt; crate&amp;rsquo;s default.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1acd93eca07f0189a95b444e7590b0d811f50e31" translate="yes" xml:space="preserve">
          <source>This type implements the &lt;code&gt;GlobalAlloc&lt;/code&gt; trait and Rust programs by default work as if they had this definition:</source>
          <target state="translated">Этот тип реализует &lt;code&gt;GlobalAlloc&lt;/code&gt; и программы Rust по умолчанию работают так, как если бы они имели это определение:</target>
        </trans-unit>
        <trans-unit id="58e8fa6622de2c31c9adb96ad4ef78c440c610d0" translate="yes" xml:space="preserve">
          <source>This type is a thread-safe &lt;code&gt;Lazy&lt;/code&gt;, and can be used in statics.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c766a6dd40937d2b1bee433cf315fc82a362370f" translate="yes" xml:space="preserve">
          <source>This type is a thread-safe &lt;code&gt;OnceCell&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="466a15ddbbbf930acad97c2c30afa51f3b95564c" translate="yes" xml:space="preserve">
          <source>This type is broadly used across &lt;a href=&quot;index&quot;&gt;&lt;code&gt;std::io&lt;/code&gt;&lt;/a&gt; for any operation which may produce an error.</source>
          <target state="translated">Этот тип широко используется в &lt;a href=&quot;index&quot;&gt; &lt;code&gt;std::io&lt;/code&gt; &lt;/a&gt; для любой операции, которая может вызвать ошибку.</target>
        </trans-unit>
        <trans-unit id="37345f83ba0c67385672d5daf1593634da8686e6" translate="yes" xml:space="preserve">
          <source>This type is the error type for the &lt;a href=&quot;struct.string#method.from_utf16&quot;&gt;&lt;code&gt;from_utf16&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;struct.string&quot;&gt;&lt;code&gt;String&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Этот тип является типом ошибки для метода &lt;a href=&quot;struct.string#method.from_utf16&quot;&gt; &lt;code&gt;from_utf16&lt;/code&gt; &lt;/a&gt; в &lt;a href=&quot;struct.string&quot;&gt; &lt;code&gt;String&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="8498c071c2463be5580b4f49150396661778b8bc" translate="yes" xml:space="preserve">
          <source>This type is the error type for the &lt;a href=&quot;struct.string#method.from_utf8&quot;&gt;&lt;code&gt;from_utf8&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;struct.string&quot;&gt;&lt;code&gt;String&lt;/code&gt;&lt;/a&gt;. It is designed in such a way to carefully avoid reallocations: the &lt;a href=&quot;struct.fromutf8error#method.into_bytes&quot;&gt;&lt;code&gt;into_bytes&lt;/code&gt;&lt;/a&gt; method will give back the byte vector that was used in the conversion attempt.</source>
          <target state="translated">Этот тип является типом ошибки для метода &lt;a href=&quot;struct.string#method.from_utf8&quot;&gt; &lt;code&gt;from_utf8&lt;/code&gt; &lt;/a&gt; в &lt;a href=&quot;struct.string&quot;&gt; &lt;code&gt;String&lt;/code&gt; &lt;/a&gt; . Он разработан таким образом, чтобы тщательно избегать перераспределения: метод &lt;a href=&quot;struct.fromutf8error#method.into_bytes&quot;&gt; &lt;code&gt;into_bytes&lt;/code&gt; &lt;/a&gt; возвращает вектор байтов, который использовался при попытке преобразования.</target>
        </trans-unit>
        <trans-unit id="d92453a7345aece96356ae2979efa1f42765d4ea" translate="yes" xml:space="preserve">
          <source>This type is very similar to &lt;a href=&quot;https://doc.rust-lang.org/nightly/std/primitive.f32.html&quot;&gt;&lt;code&gt;f32&lt;/code&gt;&lt;/a&gt;, but has increased precision by using twice as many bits. Please see &lt;a href=&quot;https://doc.rust-lang.org/nightly/std/primitive.f32.html&quot;&gt;the documentation for &lt;code&gt;f32&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;https://en.wikipedia.org/wiki/Double-precision_floating-point_format&quot;&gt;Wikipedia on double precision values&lt;/a&gt; for more information.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="63b84d2000b910b8457b4220e8938add88b701b5" translate="yes" xml:space="preserve">
          <source>This type of lock allows a number of readers or at most one writer at any point in time. The write portion of this lock typically allows modification of the underlying data (exclusive access) and the read portion of this lock typically allows for read-only access (shared access).</source>
          <target state="translated">Этот тип блокировки позволяет несколько читателей или максимум один пишущий файл в любой момент времени.Записывающая часть этой блокировки,как правило,позволяет модифицировать базовые данные (эксклюзивный доступ),а читающая часть этой блокировки,как правило,позволяет доступ только на чтение (общий доступ).</target>
        </trans-unit>
        <trans-unit id="c6101d6dc5e2fd547d5ca4f8075c490b739700a9" translate="yes" xml:space="preserve">
          <source>This type provides methods like &lt;a href=&quot;struct.pathbuf#method.push&quot;&gt;&lt;code&gt;push&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;struct.pathbuf#method.set_extension&quot;&gt;&lt;code&gt;set_extension&lt;/code&gt;&lt;/a&gt; that mutate the path in place. It also implements &lt;a href=&quot;../ops/trait.deref&quot;&gt;&lt;code&gt;Deref&lt;/code&gt;&lt;/a&gt; to &lt;a href=&quot;struct.path&quot;&gt;&lt;code&gt;Path&lt;/code&gt;&lt;/a&gt;, meaning that all methods on &lt;a href=&quot;struct.path&quot;&gt;&lt;code&gt;Path&lt;/code&gt;&lt;/a&gt; slices are available on &lt;code&gt;PathBuf&lt;/code&gt; values as well.</source>
          <target state="translated">Этот тип предоставляет такие методы, как &lt;a href=&quot;struct.pathbuf#method.push&quot;&gt; &lt;code&gt;push&lt;/code&gt; &lt;/a&gt; и &lt;a href=&quot;struct.pathbuf#method.set_extension&quot;&gt; &lt;code&gt;set_extension&lt;/code&gt; ,&lt;/a&gt; которые изменяют путь на месте. Он также реализует &lt;a href=&quot;../ops/trait.deref&quot;&gt; &lt;code&gt;Deref&lt;/code&gt; &lt;/a&gt; to &lt;a href=&quot;struct.path&quot;&gt; &lt;code&gt;Path&lt;/code&gt; &lt;/a&gt; , что означает, что все методы срезов &lt;a href=&quot;struct.path&quot;&gt; &lt;code&gt;Path&lt;/code&gt; &lt;/a&gt; также доступны &lt;code&gt;PathBuf&lt;/code&gt; значений PathBuf .</target>
        </trans-unit>
        <trans-unit id="e5c0f0dd2b187cb6784df147ee7001123c8936c0" translate="yes" xml:space="preserve">
          <source>This type represents a borrowed reference to a nul-terminated array of bytes. It can be constructed safely from a &lt;code&gt;&amp;amp;[&lt;/code&gt;&lt;a href=&quot;../primitive.u8&quot;&gt;&lt;code&gt;u8&lt;/code&gt;&lt;/a&gt;&lt;code&gt;]&lt;/code&gt; slice, or unsafely from a raw &lt;code&gt;*const c_char&lt;/code&gt;. It can then be converted to a Rust &lt;a href=&quot;../primitive.str&quot;&gt;&lt;code&gt;&amp;amp;str&lt;/code&gt;&lt;/a&gt; by performing UTF-8 validation, or into an owned &lt;a href=&quot;struct.cstring&quot;&gt;&lt;code&gt;CString&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Этот тип представляет собой заимствованную ссылку на массив байтов с завершающим нулем. Его можно безопасно построить из фрагмента &lt;code&gt;&amp;amp;[&lt;/code&gt; &lt;a href=&quot;../primitive.u8&quot;&gt; &lt;code&gt;u8&lt;/code&gt; &lt;/a&gt; &lt;code&gt;]&lt;/code&gt; или небезопасно из необработанного &lt;code&gt;*const c_char&lt;/code&gt; . Затем его можно преобразовать в Rust &lt;a href=&quot;../primitive.str&quot;&gt; &lt;code&gt;&amp;amp;str&lt;/code&gt; &lt;/a&gt; , выполнив проверку UTF-8, или в собственный &lt;a href=&quot;struct.cstring&quot;&gt; &lt;code&gt;CString&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="020b3bfb2ee1251c34f42849931a1e6222269e82" translate="yes" xml:space="preserve">
          <source>This type represents a borrowed reference to a nul-terminated array of bytes. It can be constructed safely from a &lt;code&gt;&amp;amp;[&lt;/code&gt;&lt;a href=&quot;https://doc.rust-lang.org/nightly/std/primitive.u8.html&quot;&gt;&lt;code&gt;u8&lt;/code&gt;&lt;/a&gt;&lt;code&gt;]&lt;/code&gt; slice, or unsafely from a raw &lt;code&gt;*const c_char&lt;/code&gt;. It can then be converted to a Rust &lt;a href=&quot;https://doc.rust-lang.org/nightly/std/primitive.str.html&quot;&gt;&lt;code&gt;&amp;amp;str&lt;/code&gt;&lt;/a&gt; by performing UTF-8 validation, or into an owned &lt;a href=&quot;struct.cstring&quot;&gt;&lt;code&gt;CString&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1e18df5bb8ad819c600cd4afb1d82afc59b7f998" translate="yes" xml:space="preserve">
          <source>This type represents a borrowed reference to a string in the operating system's preferred representation.</source>
          <target state="translated">Этот тип представляет собой заимствованную ссылку на строку в предпочтительном представлении операционной системы.</target>
        </trans-unit>
        <trans-unit id="6142b61fe2d2c68dea4ad8a85d9dc10ccc2f98b3" translate="yes" xml:space="preserve">
          <source>This type represents a stack backtrace for an OS thread captured at a previous point in time. In some instances the &lt;code&gt;Backtrace&lt;/code&gt; type may internally be empty due to configuration. For more information see &lt;code&gt;Backtrace::capture&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6b774085d693678b6b309fbc90af8e885fb4742c" translate="yes" xml:space="preserve">
          <source>This type represents the status code a process can return to its parent under normal termination.</source>
          <target state="translated">Этот тип представляет собой код статуса,который процесс может вернуть родителю при нормальном завершении.</target>
        </trans-unit>
        <trans-unit id="8b966cfbeebcefe7f0330e7e9f54f7098bf1152f" translate="yes" xml:space="preserve">
          <source>This type serves the purpose of being able to safely generate a C-compatible string from a Rust byte slice or vector. An instance of this type is a static guarantee that the underlying bytes contain no interior 0 bytes (&quot;nul characters&quot;) and that the final byte is 0 (&quot;nul terminator&quot;).</source>
          <target state="translated">Этот тип служит для безопасной генерации C-совместимой строки из байтового среза Rust или вектора.Примером этого типа является статическая гарантия того,что лежащие в основе байты не содержат внутренних 0 байтов (&quot;nul символов&quot;)и что конечный байт равен 0 (&quot;nul terminator&quot;).</target>
        </trans-unit>
        <trans-unit id="7d87337ad285058ac7367e471ff8622a41dfdd71" translate="yes" xml:space="preserve">
          <source>This type supports a number of operations for inspecting a path, including breaking the path into its components (separated by &lt;code&gt;/&lt;/code&gt; on Unix and by either &lt;code&gt;/&lt;/code&gt; or  on Windows), extracting the file name, determining whether the path is absolute, and so on.</source>
          <target state="translated">Этот тип поддерживает ряд операций для проверки пути, включая разбиение пути на его компоненты (разделенные &lt;code&gt;/&lt;/code&gt; в Unix и либо &lt;code&gt;/&lt;/code&gt; или в Windows), извлечение имени файла, определение абсолютного пути и т. Д.</target>
        </trans-unit>
        <trans-unit id="5d992ca66aeeffa4346515aab9e07f94a5a7aea4" translate="yes" xml:space="preserve">
          <source>This type supports a number of operations for inspecting a path, including breaking the path into its components (separated by &lt;code&gt;/&lt;/code&gt; on Unix and by either &lt;code&gt;/&lt;/code&gt; or &lt;code&gt;\&lt;/code&gt; on Windows), extracting the file name, determining whether the path is absolute, and so on.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f22ec26e83b1f093f0fa10a8ffd75ef588107911" translate="yes" xml:space="preserve">
          <source>This type will almost always be &lt;a href=&quot;../../primitive.f32&quot;&gt;&lt;code&gt;f32&lt;/code&gt;&lt;/a&gt;, which is guaranteed to be an &lt;a href=&quot;https://en.wikipedia.org/wiki/IEEE_754&quot;&gt;IEEE-754 single-precision float&lt;/a&gt; in Rust. That said, the standard technically only guarantees that it be a floating-point number, and it may have less precision than &lt;code&gt;f32&lt;/code&gt; or not follow the IEEE-754 standard at all.</source>
          <target state="translated">Этот тип почти всегда будет &lt;a href=&quot;../../primitive.f32&quot;&gt; &lt;code&gt;f32&lt;/code&gt; &lt;/a&gt; , что гарантированно будет &lt;a href=&quot;https://en.wikipedia.org/wiki/IEEE_754&quot;&gt;float одинарной точности IEEE-754&lt;/a&gt; в Rust. Тем не менее, стандарт технически гарантирует только то, что это число с плавающей запятой, и он может иметь меньшую точность, чем &lt;code&gt;f32&lt;/code&gt; , или вообще не соответствовать стандарту IEEE-754.</target>
        </trans-unit>
        <trans-unit id="b34eb94d33cfcd2b81be054dc12a48e0b5f8dc2f" translate="yes" xml:space="preserve">
          <source>This type will almost always be &lt;a href=&quot;../../primitive.f64&quot;&gt;&lt;code&gt;f64&lt;/code&gt;&lt;/a&gt;, which is guaranteed to be an &lt;a href=&quot;https://en.wikipedia.org/wiki/IEEE_754&quot;&gt;IEEE-754 double-precision float&lt;/a&gt; in Rust. That said, the standard technically only guarantees that it be a floating-point number with at least the precision of a &lt;a href=&quot;type.c_float&quot;&gt;&lt;code&gt;float&lt;/code&gt;&lt;/a&gt;, and it may be &lt;code&gt;f32&lt;/code&gt; or something entirely different from the IEEE-754 standard.</source>
          <target state="translated">Этот тип почти всегда будет &lt;a href=&quot;../../primitive.f64&quot;&gt; &lt;code&gt;f64&lt;/code&gt; &lt;/a&gt; , который гарантированно будет &lt;a href=&quot;https://en.wikipedia.org/wiki/IEEE_754&quot;&gt;float двойной точности IEEE-754&lt;/a&gt; в Rust. Тем не менее, стандарт технически гарантирует только то, что это число с плавающей запятой, по крайней мере, с точностью до числа с &lt;a href=&quot;type.c_float&quot;&gt; &lt;code&gt;float&lt;/code&gt; &lt;/a&gt; , и это может быть &lt;code&gt;f32&lt;/code&gt; или что-то совершенно отличное от стандарта IEEE-754.</target>
        </trans-unit>
        <trans-unit id="2713919b8810fb3f44c86782b09415ed3b59cda3" translate="yes" xml:space="preserve">
          <source>This type will almost always be &lt;a href=&quot;../../primitive.i16&quot;&gt;&lt;code&gt;i16&lt;/code&gt;&lt;/a&gt;, but may differ on some esoteric systems. The C standard technically only requires that this type be a signed integer with at least 16 bits; some systems may define it as &lt;code&gt;i32&lt;/code&gt;, for example.</source>
          <target state="translated">Этот тип почти всегда будет &lt;a href=&quot;../../primitive.i16&quot;&gt; &lt;code&gt;i16&lt;/code&gt; &lt;/a&gt; , но может отличаться в некоторых эзотерических системах. Стандарт C технически требует, чтобы этот тип был целым числом со знаком не менее 16 бит; некоторые системы могут определять его , например, как &lt;code&gt;i32&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c0d84326d8675408ac530de354cda2d1a8ac7eb3" translate="yes" xml:space="preserve">
          <source>This type will almost always be &lt;a href=&quot;../../primitive.i32&quot;&gt;&lt;code&gt;i32&lt;/code&gt;&lt;/a&gt;, but may differ on some esoteric systems. The C standard technically only requires that this type be a signed integer that is at least the size of a &lt;a href=&quot;type.c_short&quot;&gt;&lt;code&gt;short&lt;/code&gt;&lt;/a&gt;; some systems define it as an &lt;a href=&quot;../../primitive.i16&quot;&gt;&lt;code&gt;i16&lt;/code&gt;&lt;/a&gt;, for example.</source>
          <target state="translated">Этот тип почти всегда будет &lt;a href=&quot;../../primitive.i32&quot;&gt; &lt;code&gt;i32&lt;/code&gt; &lt;/a&gt; , но может отличаться в некоторых эзотерических системах. Стандарт C технически требует только, чтобы этот тип был целым числом со знаком, по крайней мере размером с &lt;a href=&quot;type.c_short&quot;&gt; &lt;code&gt;short&lt;/code&gt; &lt;/a&gt; ; некоторые системы определяют его , например, как &lt;a href=&quot;../../primitive.i16&quot;&gt; &lt;code&gt;i16&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="ab581f0ea98e052030c778602ef0ca98c399648d" translate="yes" xml:space="preserve">
          <source>This type will almost always be &lt;a href=&quot;../../primitive.i64&quot;&gt;&lt;code&gt;i64&lt;/code&gt;&lt;/a&gt;, but may differ on some systems. The C standard technically only requires that this type be a signed integer that is at least 64 bits and at least the size of a &lt;a href=&quot;type.c_int&quot;&gt;&lt;code&gt;long&lt;/code&gt;&lt;/a&gt;, although in practice, no system would have a &lt;code&gt;long long&lt;/code&gt; that is not an &lt;code&gt;i64&lt;/code&gt;, as most systems do not have a standardised &lt;a href=&quot;../../primitive.i128&quot;&gt;&lt;code&gt;i128&lt;/code&gt;&lt;/a&gt; type.</source>
          <target state="translated">Этот тип почти всегда будет &lt;a href=&quot;../../primitive.i64&quot;&gt; &lt;code&gt;i64&lt;/code&gt; &lt;/a&gt; , но может отличаться в некоторых системах. Стандарт C технически требует только, чтобы этот тип был целым числом со &lt;code&gt;i64&lt;/code&gt; , имеющим не менее 64 бита и размер &lt;a href=&quot;type.c_int&quot;&gt; &lt;code&gt;long&lt;/code&gt; &lt;/a&gt; , хотя на практике ни одна система не будет иметь &lt;code&gt;long long&lt;/code&gt; , кроме i64 , поскольку большинство систем не имеют стандартизированный тип &lt;a href=&quot;../../primitive.i128&quot;&gt; &lt;code&gt;i128&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="15b5edcf451c79ce2991144552b8f569664ab769" translate="yes" xml:space="preserve">
          <source>This type will almost always be &lt;a href=&quot;../../primitive.u16&quot;&gt;&lt;code&gt;u16&lt;/code&gt;&lt;/a&gt;, but may differ on some esoteric systems. The C standard technically only requires that this type be an unsigned integer with the same size as a &lt;a href=&quot;type.c_short&quot;&gt;&lt;code&gt;short&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Этот тип почти всегда будет &lt;a href=&quot;../../primitive.u16&quot;&gt; &lt;code&gt;u16&lt;/code&gt; &lt;/a&gt; , но может отличаться в некоторых эзотерических системах. Стандарт C технически требует, чтобы этот тип был беззнаковым целым числом того же размера, что и &lt;a href=&quot;type.c_short&quot;&gt; &lt;code&gt;short&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="8ba1b7005ffb5ad84714cb0adcd9cce8dfd29a44" translate="yes" xml:space="preserve">
          <source>This type will almost always be &lt;a href=&quot;../../primitive.u32&quot;&gt;&lt;code&gt;u32&lt;/code&gt;&lt;/a&gt;, but may differ on some esoteric systems. The C standard technically only requires that this type be an unsigned integer with the same size as an &lt;a href=&quot;type.c_int&quot;&gt;&lt;code&gt;int&lt;/code&gt;&lt;/a&gt;; some systems define it as a &lt;a href=&quot;../../primitive.u16&quot;&gt;&lt;code&gt;u16&lt;/code&gt;&lt;/a&gt;, for example.</source>
          <target state="translated">Этот тип почти всегда будет &lt;a href=&quot;../../primitive.u32&quot;&gt; &lt;code&gt;u32&lt;/code&gt; &lt;/a&gt; , но может отличаться в некоторых эзотерических системах. Стандарт C технически требует только, чтобы этот тип был беззнаковым целым числом того же размера, что и &lt;a href=&quot;type.c_int&quot;&gt; &lt;code&gt;int&lt;/code&gt; &lt;/a&gt; ; некоторые системы определяют его , например, как &lt;a href=&quot;../../primitive.u16&quot;&gt; &lt;code&gt;u16&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="10f7763a2c07ba8b71ea9cbe73fe235f098f6f03" translate="yes" xml:space="preserve">
          <source>This type will almost always be &lt;a href=&quot;../../primitive.u64&quot;&gt;&lt;code&gt;u64&lt;/code&gt;&lt;/a&gt;, but may differ on some systems. The C standard technically only requires that this type be an unsigned integer with the size of a &lt;a href=&quot;type.c_longlong&quot;&gt;&lt;code&gt;long long&lt;/code&gt;&lt;/a&gt;, although in practice, no system would have a &lt;code&gt;long long&lt;/code&gt; that is not a &lt;code&gt;u64&lt;/code&gt;, as most systems do not have a standardised &lt;a href=&quot;../../primitive.u128&quot;&gt;&lt;code&gt;u128&lt;/code&gt;&lt;/a&gt; type.</source>
          <target state="translated">Этот тип почти всегда будет &lt;a href=&quot;../../primitive.u64&quot;&gt; &lt;code&gt;u64&lt;/code&gt; &lt;/a&gt; , но может отличаться в некоторых системах. Стандарт C технически требует, чтобы этот тип был целым числом без знака с размером &lt;a href=&quot;type.c_longlong&quot;&gt; &lt;code&gt;long long&lt;/code&gt; &lt;/a&gt; , хотя на практике ни одна система не имела бы &lt;code&gt;long long&lt;/code&gt; , &lt;code&gt;u64&lt;/code&gt; , поскольку большинство систем не имеют стандартизованного типа &lt;a href=&quot;../../primitive.u128&quot;&gt; &lt;code&gt;u128&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="62b8bfd925dec29031c9f9af8d15530118a5f2ce" translate="yes" xml:space="preserve">
          <source>This type will almost always be &lt;a href=&quot;https://doc.rust-lang.org/nightly/std/primitive.f32.html&quot;&gt;&lt;code&gt;f32&lt;/code&gt;&lt;/a&gt;, which is guaranteed to be an &lt;a href=&quot;https://en.wikipedia.org/wiki/IEEE_754&quot;&gt;IEEE-754 single-precision float&lt;/a&gt; in Rust. That said, the standard technically only guarantees that it be a floating-point number, and it may have less precision than &lt;code&gt;f32&lt;/code&gt; or not follow the IEEE-754 standard at all.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c674b282d61f34daea9ef2ee13aae39fb8505b63" translate="yes" xml:space="preserve">
          <source>This type will almost always be &lt;a href=&quot;https://doc.rust-lang.org/nightly/std/primitive.f64.html&quot;&gt;&lt;code&gt;f64&lt;/code&gt;&lt;/a&gt;, which is guaranteed to be an &lt;a href=&quot;https://en.wikipedia.org/wiki/IEEE_754&quot;&gt;IEEE-754 double-precision float&lt;/a&gt; in Rust. That said, the standard technically only guarantees that it be a floating-point number with at least the precision of a &lt;a href=&quot;type.c_float&quot;&gt;&lt;code&gt;float&lt;/code&gt;&lt;/a&gt;, and it may be &lt;code&gt;f32&lt;/code&gt; or something entirely different from the IEEE-754 standard.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ea8042a19bb3c7392d0a03d8aac515052ed54c02" translate="yes" xml:space="preserve">
          <source>This type will almost always be &lt;a href=&quot;https://doc.rust-lang.org/nightly/std/primitive.i16.html&quot;&gt;&lt;code&gt;i16&lt;/code&gt;&lt;/a&gt;, but may differ on some esoteric systems. The C standard technically only requires that this type be a signed integer with at least 16 bits; some systems may define it as &lt;code&gt;i32&lt;/code&gt;, for example.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1f5a6e28ddb1307caa7a25d8ee94ecc741d04f02" translate="yes" xml:space="preserve">
          <source>This type will almost always be &lt;a href=&quot;https://doc.rust-lang.org/nightly/std/primitive.i32.html&quot;&gt;&lt;code&gt;i32&lt;/code&gt;&lt;/a&gt;, but may differ on some esoteric systems. The C standard technically only requires that this type be a signed integer that is at least the size of a &lt;a href=&quot;type.c_short&quot;&gt;&lt;code&gt;short&lt;/code&gt;&lt;/a&gt;; some systems define it as an &lt;a href=&quot;https://doc.rust-lang.org/nightly/std/primitive.i16.html&quot;&gt;&lt;code&gt;i16&lt;/code&gt;&lt;/a&gt;, for example.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2ab7786704bfcc1276eecf70ffb134c89a7de414" translate="yes" xml:space="preserve">
          <source>This type will almost always be &lt;a href=&quot;https://doc.rust-lang.org/nightly/std/primitive.i64.html&quot;&gt;&lt;code&gt;i64&lt;/code&gt;&lt;/a&gt;, but may differ on some systems. The C standard technically only requires that this type be a signed integer that is at least 64 bits and at least the size of a &lt;a href=&quot;type.c_int&quot;&gt;&lt;code&gt;long&lt;/code&gt;&lt;/a&gt;, although in practice, no system would have a &lt;code&gt;long long&lt;/code&gt; that is not an &lt;code&gt;i64&lt;/code&gt;, as most systems do not have a standardised &lt;a href=&quot;https://doc.rust-lang.org/nightly/std/primitive.i128.html&quot;&gt;&lt;code&gt;i128&lt;/code&gt;&lt;/a&gt; type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="89d3f0d1d67d74135ffdd410a290383d90e8fe31" translate="yes" xml:space="preserve">
          <source>This type will almost always be &lt;a href=&quot;https://doc.rust-lang.org/nightly/std/primitive.u16.html&quot;&gt;&lt;code&gt;u16&lt;/code&gt;&lt;/a&gt;, but may differ on some esoteric systems. The C standard technically only requires that this type be an unsigned integer with the same size as a &lt;a href=&quot;type.c_short&quot;&gt;&lt;code&gt;short&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="202dca95d3eb592c40ce655fef3c1ec8be90922f" translate="yes" xml:space="preserve">
          <source>This type will almost always be &lt;a href=&quot;https://doc.rust-lang.org/nightly/std/primitive.u32.html&quot;&gt;&lt;code&gt;u32&lt;/code&gt;&lt;/a&gt;, but may differ on some esoteric systems. The C standard technically only requires that this type be an unsigned integer with the same size as an &lt;a href=&quot;type.c_int&quot;&gt;&lt;code&gt;int&lt;/code&gt;&lt;/a&gt;; some systems define it as a &lt;a href=&quot;https://doc.rust-lang.org/nightly/std/primitive.u16.html&quot;&gt;&lt;code&gt;u16&lt;/code&gt;&lt;/a&gt;, for example.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="469cb3e6510770c6f62e6ffb0ed8eda80a71067d" translate="yes" xml:space="preserve">
          <source>This type will almost always be &lt;a href=&quot;https://doc.rust-lang.org/nightly/std/primitive.u64.html&quot;&gt;&lt;code&gt;u64&lt;/code&gt;&lt;/a&gt;, but may differ on some systems. The C standard technically only requires that this type be an unsigned integer with the size of a &lt;a href=&quot;type.c_longlong&quot;&gt;&lt;code&gt;long long&lt;/code&gt;&lt;/a&gt;, although in practice, no system would have a &lt;code&gt;long long&lt;/code&gt; that is not a &lt;code&gt;u64&lt;/code&gt;, as most systems do not have a standardised &lt;a href=&quot;https://doc.rust-lang.org/nightly/std/primitive.u128.html&quot;&gt;&lt;code&gt;u128&lt;/code&gt;&lt;/a&gt; type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cf97ad06e74edf68697dac1b4dcee83cfa2a22b5" translate="yes" xml:space="preserve">
          <source>This type will always be &lt;a href=&quot;../../primitive.i32&quot;&gt;&lt;code&gt;i32&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;../../primitive.i64&quot;&gt;&lt;code&gt;i64&lt;/code&gt;&lt;/a&gt;. Most notably, many Linux-based systems assume an &lt;code&gt;i64&lt;/code&gt;, but Windows assumes &lt;code&gt;i32&lt;/code&gt;. The C standard technically only requires that this type be a signed integer that is at least 32 bits and at least the size of an &lt;a href=&quot;type.c_int&quot;&gt;&lt;code&gt;int&lt;/code&gt;&lt;/a&gt;, although in practice, no system would have a &lt;code&gt;long&lt;/code&gt; that is neither an &lt;code&gt;i32&lt;/code&gt; nor &lt;code&gt;i64&lt;/code&gt;.</source>
          <target state="translated">Этот тип всегда будет &lt;a href=&quot;../../primitive.i32&quot;&gt; &lt;code&gt;i32&lt;/code&gt; &lt;/a&gt; или &lt;a href=&quot;../../primitive.i64&quot;&gt; &lt;code&gt;i64&lt;/code&gt; &lt;/a&gt; . В частности, многие системы на базе Linux предполагают &lt;code&gt;i64&lt;/code&gt; , но Windows предполагает &lt;code&gt;i32&lt;/code&gt; . Стандарт C технически требует только, чтобы этот тип был целым числом со &lt;code&gt;i32&lt;/code&gt; не менее 32 бита и размером не менее &lt;a href=&quot;type.c_int&quot;&gt; &lt;code&gt;int&lt;/code&gt; &lt;/a&gt; , хотя на практике ни одна система не будет иметь &lt;code&gt;long&lt;/code&gt; , которое не является ни i32, ни &lt;code&gt;i64&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7164487891e0a7833d4edf15c16beda44c3572d5" translate="yes" xml:space="preserve">
          <source>This type will always be &lt;a href=&quot;../../primitive.i8&quot;&gt;&lt;code&gt;i8&lt;/code&gt;&lt;/a&gt;, but is included for completeness. It is defined as being a signed integer the same size as a C &lt;a href=&quot;type.c_char&quot;&gt;&lt;code&gt;char&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Этот тип всегда будет &lt;a href=&quot;../../primitive.i8&quot;&gt; &lt;code&gt;i8&lt;/code&gt; &lt;/a&gt; , но включен для полноты картины. Он определяется как целое число со знаком того же размера, что и C &lt;a href=&quot;type.c_char&quot;&gt; &lt;code&gt;char&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="9ffb84596c9e59eea63cf919456fbd81bc2d5347" translate="yes" xml:space="preserve">
          <source>This type will always be &lt;a href=&quot;../../primitive.u32&quot;&gt;&lt;code&gt;u32&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;../../primitive.u64&quot;&gt;&lt;code&gt;u64&lt;/code&gt;&lt;/a&gt;. Most notably, many Linux-based systems assume an &lt;code&gt;u64&lt;/code&gt;, but Windows assumes &lt;code&gt;u32&lt;/code&gt;. The C standard technically only requires that this type be an unsigned integer with the size of a &lt;a href=&quot;type.c_long&quot;&gt;&lt;code&gt;long&lt;/code&gt;&lt;/a&gt;, although in practice, no system would have a &lt;code&gt;ulong&lt;/code&gt; that is neither a &lt;code&gt;u32&lt;/code&gt; nor &lt;code&gt;u64&lt;/code&gt;.</source>
          <target state="translated">Этот тип всегда будет &lt;a href=&quot;../../primitive.u32&quot;&gt; &lt;code&gt;u32&lt;/code&gt; &lt;/a&gt; или &lt;a href=&quot;../../primitive.u64&quot;&gt; &lt;code&gt;u64&lt;/code&gt; &lt;/a&gt; . В частности, многие системы на базе Linux предполагают &lt;code&gt;u64&lt;/code&gt; , но Windows предполагает &lt;code&gt;u32&lt;/code&gt; . Стандарт C технически требует только, чтобы этот тип был целым числом без знака с размером &lt;a href=&quot;type.c_long&quot;&gt; &lt;code&gt;long&lt;/code&gt; &lt;/a&gt; , хотя на практике ни одна система не имеет &lt;code&gt;ulong&lt;/code&gt; , который не является ни &lt;code&gt;u32&lt;/code&gt; , ни &lt;code&gt;u64&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="702c3c35c3eb36099eb087128d0090cf4cdc5cb9" translate="yes" xml:space="preserve">
          <source>This type will always be &lt;a href=&quot;../../primitive.u8&quot;&gt;&lt;code&gt;u8&lt;/code&gt;&lt;/a&gt;, but is included for completeness. It is defined as being an unsigned integer the same size as a C &lt;a href=&quot;type.c_char&quot;&gt;&lt;code&gt;char&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Этим типом всегда будет &lt;a href=&quot;../../primitive.u8&quot;&gt; &lt;code&gt;u8&lt;/code&gt; &lt;/a&gt; , но он включен для полноты картины . Он определяется как целое число без знака того же размера, что и C &lt;a href=&quot;type.c_char&quot;&gt; &lt;code&gt;char&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="3bd4e6f17c1fadac181d74e7c6fccf81e88a4338" translate="yes" xml:space="preserve">
          <source>This type will always be &lt;a href=&quot;https://doc.rust-lang.org/nightly/std/primitive.i32.html&quot;&gt;&lt;code&gt;i32&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;https://doc.rust-lang.org/nightly/std/primitive.i64.html&quot;&gt;&lt;code&gt;i64&lt;/code&gt;&lt;/a&gt;. Most notably, many Linux-based systems assume an &lt;code&gt;i64&lt;/code&gt;, but Windows assumes &lt;code&gt;i32&lt;/code&gt;. The C standard technically only requires that this type be a signed integer that is at least 32 bits and at least the size of an &lt;a href=&quot;type.c_int&quot;&gt;&lt;code&gt;int&lt;/code&gt;&lt;/a&gt;, although in practice, no system would have a &lt;code&gt;long&lt;/code&gt; that is neither an &lt;code&gt;i32&lt;/code&gt; nor &lt;code&gt;i64&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6d40fc3671ec7ae824bd7929d61ce78e74ef07a2" translate="yes" xml:space="preserve">
          <source>This type will always be &lt;a href=&quot;https://doc.rust-lang.org/nightly/std/primitive.i8.html&quot;&gt;&lt;code&gt;i8&lt;/code&gt;&lt;/a&gt;, but is included for completeness. It is defined as being a signed integer the same size as a C &lt;a href=&quot;type.c_char&quot;&gt;&lt;code&gt;char&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9a9f45d2d1c5aca56d0bed11f4011cece6101639" translate="yes" xml:space="preserve">
          <source>This type will always be &lt;a href=&quot;https://doc.rust-lang.org/nightly/std/primitive.u32.html&quot;&gt;&lt;code&gt;u32&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;https://doc.rust-lang.org/nightly/std/primitive.u64.html&quot;&gt;&lt;code&gt;u64&lt;/code&gt;&lt;/a&gt;. Most notably, many Linux-based systems assume an &lt;code&gt;u64&lt;/code&gt;, but Windows assumes &lt;code&gt;u32&lt;/code&gt;. The C standard technically only requires that this type be an unsigned integer with the size of a &lt;a href=&quot;type.c_long&quot;&gt;&lt;code&gt;long&lt;/code&gt;&lt;/a&gt;, although in practice, no system would have a &lt;code&gt;ulong&lt;/code&gt; that is neither a &lt;code&gt;u32&lt;/code&gt; nor &lt;code&gt;u64&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fb106d3debd5b58c7a1ae3e283c55499cf8e5484" translate="yes" xml:space="preserve">
          <source>This type will always be &lt;a href=&quot;https://doc.rust-lang.org/nightly/std/primitive.u8.html&quot;&gt;&lt;code&gt;u8&lt;/code&gt;&lt;/a&gt;, but is included for completeness. It is defined as being an unsigned integer the same size as a C &lt;a href=&quot;type.c_char&quot;&gt;&lt;code&gt;char&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4424cbb3fbb90751454ec3bf9577dceb9d9a320d" translate="yes" xml:space="preserve">
          <source>This typedef is generally used to avoid writing out &lt;a href=&quot;struct.error&quot;&gt;&lt;code&gt;io::Error&lt;/code&gt;&lt;/a&gt; directly and is otherwise a direct mapping to &lt;a href=&quot;../result/enum.result&quot;&gt;&lt;code&gt;Result&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Этот typedef обычно используется, чтобы избежать прямой записи &lt;a href=&quot;struct.error&quot;&gt; &lt;code&gt;io::Error&lt;/code&gt; &lt;/a&gt; а в противном случае является прямым отображением на &lt;a href=&quot;../result/enum.result&quot;&gt; &lt;code&gt;Result&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="9571d5615d4085a615ed7c5ad4cadc1ded956713" translate="yes" xml:space="preserve">
          <source>This typically means that an operation could only succeed if it read a particular number of bytes but only a smaller number of bytes could be read.</source>
          <target state="translated">Обычно это означает,что операция может быть успешной только в том случае,если она прочитает определенное количество байтов,но только меньшее количество байтов может быть прочитано.</target>
        </trans-unit>
        <trans-unit id="692f047748f56fd7b6dd085f2d1ee90a117e619a" translate="yes" xml:space="preserve">
          <source>This typically means that an operation could only succeed if it wrote a particular number of bytes but only a smaller number of bytes could be written.</source>
          <target state="translated">Обычно это означает,что операция может быть успешной только в том случае,если будет записано определенное количество байтов,но может быть записано только меньшее количество байтов.</target>
        </trans-unit>
        <trans-unit id="066666922981580e3c6ec7b57246e05ce6d242d4" translate="yes" xml:space="preserve">
          <source>This usage of &lt;a href=&quot;enum.option&quot;&gt;&lt;code&gt;Option&lt;/code&gt;&lt;/a&gt; to create safe nullable pointers is so common that Rust does special optimizations to make the representation of &lt;a href=&quot;enum.option&quot;&gt;&lt;code&gt;Option&lt;/code&gt;&lt;/a&gt;&lt;code&gt;&amp;lt;&lt;/code&gt;&lt;a href=&quot;../boxed/struct.box&quot;&gt;&lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt;&lt;code&gt;&amp;gt;&lt;/code&gt; a single pointer. Optional pointers in Rust are stored as efficiently as any other pointer type.</source>
          <target state="translated">Такое использование &lt;a href=&quot;enum.option&quot;&gt; &lt;code&gt;Option&lt;/code&gt; &lt;/a&gt; для создания безопасных NULLABLE указателей настолько распространено , что Руст делает специальные оптимизации , чтобы сделать представление &lt;a href=&quot;enum.option&quot;&gt; &lt;code&gt;Option&lt;/code&gt; &lt;/a&gt; &lt;code&gt;&amp;lt;&lt;/code&gt; &lt;a href=&quot;../boxed/struct.box&quot;&gt; &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; &lt;/a&gt; &lt;code&gt;&amp;gt;&lt;/code&gt; один указателем. Необязательные указатели в Rust хранятся так же эффективно, как и любой другой тип указателя.</target>
        </trans-unit>
        <trans-unit id="3473dac5d293883be110e74db63b95a407d1ea5c" translate="yes" xml:space="preserve">
          <source>This usage of &lt;code&gt;extern&lt;/code&gt; does not require &lt;code&gt;unsafe&lt;/code&gt;.</source>
          <target state="translated">Такое использование &lt;code&gt;extern&lt;/code&gt; не требует &lt;code&gt;unsafe&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d52ccca3efa09c9ce1760baf0a04fa97e3aed552" translate="yes" xml:space="preserve">
          <source>This use of a &lt;code&gt;where&lt;/code&gt; clause is strange - a more common usage would look something like the following:</source>
          <target state="translated">Такое использование предложения &lt;code&gt;where&lt;/code&gt; странно - более распространенное использование могло бы выглядеть примерно так:</target>
        </trans-unit>
        <trans-unit id="3ee77b0606c712a9409edf4f68e92618c8d2ee4a" translate="yes" xml:space="preserve">
          <source>This value is not suitable for passing to &lt;code&gt;Path::new&lt;/code&gt; or similar constructors when the host platform and target platform differ.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ededb49250daf0db79bbb927c06d879d238521da" translate="yes" xml:space="preserve">
          <source>This value sets the time-to-live field that is used in every packet sent from this socket.</source>
          <target state="translated">Это значение задает поле &quot;Время жизни&quot;,которое используется в каждом пакете,отправленном из этого сокета.</target>
        </trans-unit>
        <trans-unit id="75beec589ecae6a039a7d01c52fb4b4aea8d427f" translate="yes" xml:space="preserve">
          <source>This value should be considered only a hint.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d769cb0769d945ca70d65f4d25befb01295f124d" translate="yes" xml:space="preserve">
          <source>This variant is also constructed when a &lt;code&gt;+&lt;/code&gt; or &lt;code&gt;-&lt;/code&gt; is misplaced within a string either on its own or in the middle of a number.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="413d9b4dc5521012c4ffcf2dbef4c140f61e2a52" translate="yes" xml:space="preserve">
          <source>This variant is the most common one, it represents references to files or directories.</source>
          <target state="translated">Этот вариант является наиболее распространенным,он представляет собой ссылки на файлы или каталоги.</target>
        </trans-unit>
        <trans-unit id="8ad9c1ff17fcdcd8bc09eee76d183971a27c0cfe" translate="yes" xml:space="preserve">
          <source>This variant will be emitted when the parsing string has a value of zero, which would be illegal for non-zero types.</source>
          <target state="translated">Этот вариант будет выдаваться,когда строка разбора имеет значение ноль,что было бы противозаконно для ненулевых типов.</target>
        </trans-unit>
        <trans-unit id="f262b16f3428e356cf4b0dde5dbe8613ec4091d5" translate="yes" xml:space="preserve">
          <source>This version of the text assumes you&amp;rsquo;re using Rust 1.41.0 or later with &lt;code&gt;edition=&quot;2018&quot;&lt;/code&gt; in &lt;em&gt;Cargo.toml&lt;/em&gt; of all projects to use Rust 2018 Edition idioms. See the &lt;a href=&quot;book/ch01-01-installation&quot;&gt;&amp;ldquo;Installation&amp;rdquo; section of Chapter 1&lt;/a&gt; to install or update Rust, and see the new &lt;a href=&quot;book/appendix-05-editions&quot;&gt;Appendix E&lt;/a&gt; for information on editions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2e89485f5fe729fa0419251d6d1b6a0bc0fb1791" translate="yes" xml:space="preserve">
          <source>This version of the text assumes you&amp;rsquo;re using Rust 1.41.0 or later with &lt;code&gt;edition=&quot;2018&quot;&lt;/code&gt; in &lt;em&gt;Cargo.toml&lt;/em&gt; of all projects to use Rust 2018 Edition idioms. See the &lt;a href=&quot;ch01-01-installation&quot;&gt;&amp;ldquo;Installation&amp;rdquo; section of Chapter 1&lt;/a&gt; to install or update Rust, and see the new &lt;a href=&quot;appendix-05-editions&quot;&gt;Appendix E&lt;/a&gt; for information on editions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="676fb636ec3ef59315a4dc9ef64f5fbe3403351d" translate="yes" xml:space="preserve">
          <source>This way, the lifetime of the &lt;a href=&quot;struct.cstring&quot;&gt;&lt;code&gt;CString&lt;/code&gt;&lt;/a&gt; in &lt;code&gt;hello&lt;/code&gt; encompasses the lifetime of &lt;code&gt;ptr&lt;/code&gt; and the &lt;code&gt;unsafe&lt;/code&gt; block.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0051a5a0c2153685b22e3e481253428438ae9b0d" translate="yes" xml:space="preserve">
          <source>This way, the lifetime of the &lt;code&gt;CString&lt;/code&gt; in &lt;code&gt;hello&lt;/code&gt; encompasses the lifetime of &lt;code&gt;ptr&lt;/code&gt; and the &lt;code&gt;unsafe&lt;/code&gt; block.</source>
          <target state="translated">Таким образом, время жизни &lt;code&gt;CString&lt;/code&gt; в &lt;code&gt;hello&lt;/code&gt; включает время жизни &lt;code&gt;ptr&lt;/code&gt; и &lt;code&gt;unsafe&lt;/code&gt; блока.</target>
        </trans-unit>
        <trans-unit id="6a66e53cbccdcf1dd0b129068e28220aa1da407b" translate="yes" xml:space="preserve">
          <source>This will allocate as many times as needed for constructing the &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; and then it will allocate once for turning the &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; into the &lt;code&gt;Arc&amp;lt;[T]&amp;gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="be23e02db6f58e9303929f35bcf996dc6954c461" translate="yes" xml:space="preserve">
          <source>This will allocate as many times as needed for constructing the &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; and then it will allocate once for turning the &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; into the &lt;code&gt;Rc&amp;lt;[T]&amp;gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c87576c37932e7e920719c7c3053295204953101" translate="yes" xml:space="preserve">
          <source>This will always &lt;a href=&quot;macro.panic&quot;&gt;&lt;code&gt;panic!&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">Это всегда вызовет &lt;a href=&quot;macro.panic&quot;&gt; &lt;code&gt;panic!&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="1c37af121800fff05f23ea7195ec86eae7b112d6" translate="yes" xml:space="preserve">
          <source>This will always &lt;a href=&quot;macro.panic&quot;&gt;panic!&lt;/a&gt;</source>
          <target state="translated">Это всегда вызовет &lt;a href=&quot;macro.panic&quot;&gt;панику!&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="f7ba30b4423020d7c6174593849644ce672a970c" translate="yes" xml:space="preserve">
          <source>This will always &lt;a href=&quot;macro.panic&quot;&gt;panic!&lt;/a&gt; because &lt;code&gt;unimplemented!&lt;/code&gt; is just a shorthand for &lt;code&gt;panic!&lt;/code&gt; with a fixed, specific message.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ca9dc67930c6219a678b4690efb3c9a2b4b3cc3e" translate="yes" xml:space="preserve">
          <source>This will be a max-heap.</source>
          <target state="translated">Это будет максимальная куча.</target>
        </trans-unit>
        <trans-unit id="835f899ffcb476aee6b318f9e24a76f9e21b8043" translate="yes" xml:space="preserve">
          <source>This will be allowed at some point in the future, but the implementation is not yet complete. See the &lt;a href=&quot;https://github.com/rust-lang/rust/issues/61949&quot;&gt;issue-61949&lt;/a&gt; for this limitation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="850691bcf932c0c55cd89eb4535ca90e22acf61f" translate="yes" xml:space="preserve">
          <source>This will be allowed at some point in the future, but the implementation is not yet complete. See the tracking issue for &lt;a href=&quot;https://github.com/rust-lang/rust/issues/49146&quot;&gt;conditionals&lt;/a&gt; or &lt;a href=&quot;https://github.com/rust-lang/rust/issues/52000&quot;&gt;loops&lt;/a&gt; in a const context for the current status.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4fffbe8e22b797d8b6890d54d873414453d3490a" translate="yes" xml:space="preserve">
          <source>This will cause an error:</source>
          <target state="translated">Это приведет к ошибке:</target>
        </trans-unit>
        <trans-unit id="5b06471f77c7403c58187c73c7a664a50663e032" translate="yes" xml:space="preserve">
          <source>This will commonly, but not always, be a &lt;code&gt;&amp;amp;'static str&lt;/code&gt; or &lt;a href=&quot;../string/struct.string&quot;&gt;&lt;code&gt;String&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Обычно, но не всегда, это &lt;code&gt;&amp;amp;'static str&lt;/code&gt; &lt;a href=&quot;../string/struct.string&quot;&gt; &lt;code&gt;String&lt;/code&gt; &lt;/a&gt; &amp;amp; или String .</target>
        </trans-unit>
        <trans-unit id="1a8b17614cf7c240a7a1eb116da8eea5f59c7b71" translate="yes" xml:space="preserve">
          <source>This will compile, because it has the constraint on the type parameter:</source>
          <target state="translated">Это будет скомпилировано,так как имеет ограничение на параметр типа:</target>
        </trans-unit>
        <trans-unit id="3520fed49c822ab60288ef2f8f669d15b4a41e6f" translate="yes" xml:space="preserve">
          <source>This will compile:</source>
          <target state="translated">Это будет собрано:</target>
        </trans-unit>
        <trans-unit id="49cc821a81b4f339dbb259efc2d82e6ee470759f" translate="yes" xml:space="preserve">
          <source>This will create a &lt;a href=&quot;../primitive.str&quot;&gt;&lt;code&gt;&amp;amp;str&lt;/code&gt;&lt;/a&gt; from the &lt;code&gt;String&lt;/code&gt; and pass it in. This conversion is very inexpensive, and so generally, functions will accept &lt;a href=&quot;../primitive.str&quot;&gt;&lt;code&gt;&amp;amp;str&lt;/code&gt;&lt;/a&gt;s as arguments unless they need a &lt;code&gt;String&lt;/code&gt; for some specific reason.</source>
          <target state="translated">Это создаст &lt;a href=&quot;../primitive.str&quot;&gt; &lt;code&gt;&amp;amp;str&lt;/code&gt; &lt;/a&gt; из &lt;code&gt;String&lt;/code&gt; и передаст его. Это преобразование очень недорогое, и поэтому обычно функции принимают &lt;a href=&quot;../primitive.str&quot;&gt; &lt;code&gt;&amp;amp;str&lt;/code&gt; &lt;/a&gt; качестве аргументов, если им не нужна &lt;code&gt;String&lt;/code&gt; по какой-либо конкретной причине.</target>
        </trans-unit>
        <trans-unit id="1b5cc9b9f228f1bae8ee73a71afeed4d549dd793" translate="yes" xml:space="preserve">
          <source>This will create a thread using default parameters of &lt;a href=&quot;struct.builder&quot;&gt;&lt;code&gt;Builder&lt;/code&gt;&lt;/a&gt;, if you want to specify the stack size or the name of the thread, use this API instead.</source>
          <target state="translated">Это создаст поток с использованием параметров &lt;a href=&quot;struct.builder&quot;&gt; &lt;code&gt;Builder&lt;/code&gt; &lt;/a&gt; по умолчанию , если вы хотите указать размер стека или имя потока, используйте вместо этого этот API.</target>
        </trans-unit>
        <trans-unit id="e391cc107c46641450ffa0654fcfb8cbca70a73b" translate="yes" xml:space="preserve">
          <source>This will decrement the strong reference count. If the strong reference count reaches zero then the only other references (if any) are &lt;a href=&quot;../rc/struct.weak&quot;&gt;&lt;code&gt;Weak&lt;/code&gt;&lt;/a&gt;, so we &lt;code&gt;drop&lt;/code&gt; the inner value.</source>
          <target state="translated">Это уменьшит количество сильных ссылок. Если счетчик сильных ссылок достигает нуля, тогда единственные другие ссылки (если есть) являются &lt;a href=&quot;../rc/struct.weak&quot;&gt; &lt;code&gt;Weak&lt;/code&gt; &lt;/a&gt; , поэтому мы &lt;code&gt;drop&lt;/code&gt; внутреннее значение.</target>
        </trans-unit>
        <trans-unit id="97b7f84f70f9d3f5d6303968924e2733780bc78b" translate="yes" xml:space="preserve">
          <source>This will decrement the strong reference count. If the strong reference count reaches zero then the only other references (if any) are &lt;a href=&quot;../sync/struct.weak&quot;&gt;&lt;code&gt;Weak&lt;/code&gt;&lt;/a&gt;, so we &lt;code&gt;drop&lt;/code&gt; the inner value.</source>
          <target state="translated">Это уменьшит количество сильных ссылок. Если счетчик сильных ссылок достигает нуля, тогда единственные другие ссылки (если есть) являются &lt;a href=&quot;../sync/struct.weak&quot;&gt; &lt;code&gt;Weak&lt;/code&gt; &lt;/a&gt; , поэтому мы &lt;code&gt;drop&lt;/code&gt; внутреннее значение.</target>
        </trans-unit>
        <trans-unit id="b917396cbcb63b72ec008aadc499d642c7abbf61" translate="yes" xml:space="preserve">
          <source>This will decrement the strong reference count. If the strong reference count reaches zero then the only other references (if any) are &lt;a href=&quot;struct.weak&quot;&gt;&lt;code&gt;Weak&lt;/code&gt;&lt;/a&gt;, so we &lt;code&gt;drop&lt;/code&gt; the inner value.</source>
          <target state="translated">Это уменьшит количество сильных ссылок. Если счетчик сильных ссылок достигает нуля, тогда единственные другие ссылки (если есть) являются &lt;a href=&quot;struct.weak&quot;&gt; &lt;code&gt;Weak&lt;/code&gt; &lt;/a&gt; , поэтому мы &lt;code&gt;drop&lt;/code&gt; внутреннее значение.</target>
        </trans-unit>
        <trans-unit id="0e9819c7b2177172935ef1092ecc4f74eaf1578f" translate="yes" xml:space="preserve">
          <source>This will drop any excess capacity.</source>
          <target state="translated">Это снизит любую избыточную мощность.</target>
        </trans-unit>
        <trans-unit id="354a015dbdb2ab35ae4e0b061d1f50f5025f7cbe" translate="yes" xml:space="preserve">
          <source>This will escape characters with the Rust syntax of the form &lt;code&gt;\u{NNNNNN}&lt;/code&gt; where &lt;code&gt;NNNNNN&lt;/code&gt; is a hexadecimal representation.</source>
          <target state="translated">Это позволит избежать символов с синтаксисом Rust в форме &lt;code&gt;\u{NNNNNN}&lt;/code&gt; где &lt;code&gt;NNNNNN&lt;/code&gt; - шестнадцатеричное представление.</target>
        </trans-unit>
        <trans-unit id="c51882eef9b6927fb20dc2b079d5f33d822ffcef" translate="yes" xml:space="preserve">
          <source>This will escape the characters similar to the &lt;code&gt;Debug&lt;/code&gt; implementations of &lt;code&gt;str&lt;/code&gt; or &lt;code&gt;char&lt;/code&gt;.</source>
          <target state="translated">Это позволит избежать символов, аналогичных реализациям &lt;code&gt;Debug&lt;/code&gt; &lt;code&gt;str&lt;/code&gt; или &lt;code&gt;char&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7463a3fbad059d7822b7a64865f64ec71f56ca6c" translate="yes" xml:space="preserve">
          <source>This will fail because the compiler does not know which instance of &lt;code&gt;Foo&lt;/code&gt; to call &lt;code&gt;bar&lt;/code&gt; on. Change &lt;code&gt;Foo::bar()&lt;/code&gt; to &lt;code&gt;Foo::&amp;lt;T&amp;gt;::bar()&lt;/code&gt; to resolve the error.</source>
          <target state="translated">Это не удастся, потому что компилятор не знает, какой экземпляр &lt;code&gt;Foo&lt;/code&gt; вызывать &lt;code&gt;bar&lt;/code&gt; . Измените &lt;code&gt;Foo::bar()&lt;/code&gt; на &lt;code&gt;Foo::&amp;lt;T&amp;gt;::bar()&lt;/code&gt; чтобы устранить ошибку.</target>
        </trans-unit>
        <trans-unit id="b95565727f175f666e1822f4733ae91ef6a1780e" translate="yes" xml:space="preserve">
          <source>This will fail to compile because we cannot implement a trait for a type if both the trait and the type are not defined by the current crate. This is due to Rust's orphaning rules. To bypass this, you can implement &lt;a href=&quot;trait.into&quot;&gt;&lt;code&gt;Into&lt;/code&gt;&lt;/a&gt; directly:</source>
          <target state="translated">Это не будет скомпилировано, потому что мы не сможем реализовать трейт для типа, если и трейт, и тип не определены текущим ящиком. Это связано с правилами Rust по поводу сиротства. Чтобы обойти это, вы можете напрямую реализовать &lt;a href=&quot;trait.into&quot;&gt; &lt;code&gt;Into&lt;/code&gt; &lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="8648eb6ea2730446e0cfb046319d740aba54d8bb" translate="yes" xml:space="preserve">
          <source>This will fail to compile in older versions of the language because Rust's orphaning rules used to be a little bit more strict. To bypass this, you could implement &lt;a href=&quot;trait.into&quot;&gt;&lt;code&gt;Into&lt;/code&gt;&lt;/a&gt; directly:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5c41f14d1e2c5310aaa0b927129f701a7031c03a" translate="yes" xml:space="preserve">
          <source>This will invoke the &lt;a href=&quot;macro.panic&quot;&gt;&lt;code&gt;panic!&lt;/code&gt;&lt;/a&gt; macro if the provided expression cannot be evaluated to &lt;code&gt;true&lt;/code&gt; at runtime.</source>
          <target state="translated">Это вызовет &lt;a href=&quot;macro.panic&quot;&gt; &lt;code&gt;panic!&lt;/code&gt; &lt;/a&gt;макрос, если предоставленное выражение не может быть оценено как &lt;code&gt;true&lt;/code&gt; во время выполнения.</target>
        </trans-unit>
        <trans-unit id="2deb5f847f234caa59a2e70f4ab65edaeb2fdead" translate="yes" xml:space="preserve">
          <source>This will lazily initialize the value if this thread has not referenced this key yet.</source>
          <target state="translated">Это позволит лениво инициализировать значение,если данный поток еще не ссылался на этот ключ.</target>
        </trans-unit>
        <trans-unit id="2be746d77ee47101c5a961aeebfbec50b6101d49" translate="yes" xml:space="preserve">
          <source>This will lazily initialize the value if this thread has not referenced this key yet. If the key has been destroyed (which may happen if this is called in a destructor), this function will return an &lt;a href=&quot;struct.accesserror&quot;&gt;&lt;code&gt;AccessError&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Это будет лениво инициализировать значение, если этот поток еще не ссылался на этот ключ. Если ключ был уничтожен (что может произойти, если он вызывается в деструкторе), эта функция вернет &lt;a href=&quot;struct.accesserror&quot;&gt; &lt;code&gt;AccessError&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="3800eafd69cf59aa81eb6bb72cb9493004b5c43e" translate="yes" xml:space="preserve">
          <source>This will make &lt;code&gt;CASE_INSENSITIVE&lt;/code&gt; persist for the remainder of your shell session. It can be unset with the &lt;code&gt;Remove-Item&lt;/code&gt; cmdlet:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4b457d7ac05dde73ffae7dfa5283d452dba90a68" translate="yes" xml:space="preserve">
          <source>This will not print any values, as we only created an iterator, rather than using it. The compiler will warn us about this kind of behavior:</source>
          <target state="translated">При этом не будут печататься никакие значения,так как мы только создали итератор,а не используем его.Компилятор предупредит нас о подобном поведении:</target>
        </trans-unit>
        <trans-unit id="7884f03c74d608aa53fe96a0fe19b6f01fc64a4e" translate="yes" xml:space="preserve">
          <source>This will not work if the new name is on a different mount point.</source>
          <target state="translated">Это не будет работать,если новое имя находится в другой точке крепления.</target>
        </trans-unit>
        <trans-unit id="29502fa64160996ff78f02e55cbb4b83b39e3b0d" translate="yes" xml:space="preserve">
          <source>This will not:</source>
          <target state="translated">Этого не случится:</target>
        </trans-unit>
        <trans-unit id="b5b85ab1e962bdcb10ff35cb96c42d807c436122" translate="yes" xml:space="preserve">
          <source>This will output the following:</source>
          <target state="translated">В результате будет выдано следующее:</target>
        </trans-unit>
        <trans-unit id="01e646d50274ee113a75cb82fc9f837874518988" translate="yes" xml:space="preserve">
          <source>This will override the &lt;code&gt;read&lt;/code&gt;, &lt;code&gt;write&lt;/code&gt;, and &lt;code&gt;append&lt;/code&gt; flags on the &lt;code&gt;OpenOptions&lt;/code&gt; structure. This method provides fine-grained control over the permissions to read, write and append data, attributes (like hidden and system), and extended attributes.</source>
          <target state="translated">Это переопределит флаги &lt;code&gt;read&lt;/code&gt; , &lt;code&gt;write&lt;/code&gt; и &lt;code&gt;append&lt;/code&gt; в структуре &lt;code&gt;OpenOptions&lt;/code&gt; . Этот метод обеспечивает детальный контроль над разрешениями на чтение, запись и добавление данных, атрибутов (например, скрытых и системных) и расширенных атрибутов.</target>
        </trans-unit>
        <trans-unit id="2ed7ee1155828d2b2b40b29d755792b670ff1874" translate="yes" xml:space="preserve">
          <source>This will print</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="475997c398cd5b2921c0cb8cd3f062a1e5e787e7" translate="yes" xml:space="preserve">
          <source>This will print &quot;('a', 1), ('b', 2), ('c', 3)&quot;.</source>
          <target state="translated">Это напечатает &quot;('a',1),('b',2),('c',3)&quot;.</target>
        </trans-unit>
        <trans-unit id="3a5f8c78def77453ab00074a3cd30ff4dd27218b" translate="yes" xml:space="preserve">
          <source>This will print &lt;code&gt;1&lt;/code&gt; through &lt;code&gt;5&lt;/code&gt;, each on their own line.</source>
          <target state="translated">Это напечатает от &lt;code&gt;1&lt;/code&gt; до &lt;code&gt;5&lt;/code&gt; , каждый в отдельной строке.</target>
        </trans-unit>
        <trans-unit id="45cc5d4168a6948db8686b2c0a8d37fbb64175cc" translate="yes" xml:space="preserve">
          <source>This will print &lt;code&gt;Cons(1, Cons(2, Nil))&lt;/code&gt;.</source>
          <target state="translated">Это напечатает &lt;code&gt;Cons(1, Cons(2, Nil))&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="fa3cd6bbcdf4b75c4bbd0f80ed7b9518ac88ecb8" translate="yes" xml:space="preserve">
          <source>This will print the numbers &lt;code&gt;0&lt;/code&gt; through &lt;code&gt;4&lt;/code&gt;, each on their own line.</source>
          <target state="translated">Это напечатает числа от &lt;code&gt;0&lt;/code&gt; до &lt;code&gt;4&lt;/code&gt; , каждое в отдельной строке.</target>
        </trans-unit>
        <trans-unit id="a40fac0ea22a56e98579c9cc97554e4f4a65b5bb" translate="yes" xml:space="preserve">
          <source>This will print the numbers one through five, each on their own line. But you'll notice something here: we never called anything on our vector to produce an iterator. What gives?</source>
          <target state="translated">Это выведет цифры с первого по пятый,каждая на свою линию.Но здесь вы заметите кое-что:мы никогда ничего не вызывали по нашему вектору для создания итератора.Что дает?</target>
        </trans-unit>
        <trans-unit id="6e363eb5c9d1e189e7877f05521713cb961f9afe" translate="yes" xml:space="preserve">
          <source>This will print:</source>
          <target state="translated">Это напечатает:</target>
        </trans-unit>
        <trans-unit id="e3f9d6eebc7d0a9c3006485e1bf2fe9250c18991" translate="yes" xml:space="preserve">
          <source>This will result in &lt;code&gt;read&lt;/code&gt;, &lt;code&gt;write&lt;/code&gt;, &lt;code&gt;recv&lt;/code&gt; and &lt;code&gt;send&lt;/code&gt; operations becoming nonblocking, i.e., immediately returning from their calls. If the IO operation is successful, &lt;code&gt;Ok&lt;/code&gt; is returned and no further action is required. If the IO operation could not be completed and needs to be retried, an error with kind &lt;a href=&quot;../io/enum.errorkind#variant.WouldBlock&quot;&gt;&lt;code&gt;io::ErrorKind::WouldBlock&lt;/code&gt;&lt;/a&gt; is returned.</source>
          <target state="translated">Это приведет &lt;code&gt;read&lt;/code&gt; , &lt;code&gt;write&lt;/code&gt; , &lt;code&gt;recv&lt;/code&gt; и &lt;code&gt;send&lt;/code&gt; операций становится неблокируемым, то есть, сразу же возвращаясь из своих звонков. Если операция ввода-вывода прошла успешно, возвращается &lt;code&gt;Ok&lt;/code&gt; и никаких дальнейших действий не требуется. Если операция ввода-вывода не может быть завершена и ее необходимо &lt;a href=&quot;../io/enum.errorkind#variant.WouldBlock&quot;&gt; &lt;code&gt;io::ErrorKind::WouldBlock&lt;/code&gt; &lt;/a&gt; , возвращается ошибка вида io :: ErrorKind :: wouldBlock .</target>
        </trans-unit>
        <trans-unit id="4b3da21af1f8f50bfb5fb08b425cfbfeb0c3196a" translate="yes" xml:space="preserve">
          <source>This will result in &lt;code&gt;recv&lt;/code&gt;, &lt;code&gt;recv_from&lt;/code&gt;, &lt;code&gt;send&lt;/code&gt;, and &lt;code&gt;send_to&lt;/code&gt; operations becoming nonblocking, i.e., immediately returning from their calls. If the IO operation is successful, &lt;code&gt;Ok&lt;/code&gt; is returned and no further action is required. If the IO operation could not be completed and needs to be retried, an error with kind &lt;a href=&quot;../io/enum.errorkind#variant.WouldBlock&quot;&gt;&lt;code&gt;io::ErrorKind::WouldBlock&lt;/code&gt;&lt;/a&gt; is returned.</source>
          <target state="translated">Это приведет к тому , что &lt;code&gt;recv_from&lt;/code&gt; &lt;code&gt;recv&lt;/code&gt; , recv_from , &lt;code&gt;send&lt;/code&gt; и &lt;code&gt;send_to&lt;/code&gt; станут неблокирующими, т. Е. Немедленно вернутся из своих вызовов. Если операция ввода-вывода прошла успешно, возвращается &lt;code&gt;Ok&lt;/code&gt; и никаких дальнейших действий не требуется. Если операция ввода-вывода не может быть завершена и ее необходимо &lt;a href=&quot;../io/enum.errorkind#variant.WouldBlock&quot;&gt; &lt;code&gt;io::ErrorKind::WouldBlock&lt;/code&gt; &lt;/a&gt; , возвращается ошибка вида io :: ErrorKind :: wouldBlock .</target>
        </trans-unit>
        <trans-unit id="5f9e536d8780a7dfeadd69ff71cc712be79eb591" translate="yes" xml:space="preserve">
          <source>This will result in the &lt;code&gt;accept&lt;/code&gt; operation becoming nonblocking, i.e., immediately returning from their calls. If the IO operation is successful, &lt;code&gt;Ok&lt;/code&gt; is returned and no further action is required. If the IO operation could not be completed and needs to be retried, an error with kind &lt;a href=&quot;../../../io/enum.errorkind#variant.WouldBlock&quot;&gt;&lt;code&gt;io::ErrorKind::WouldBlock&lt;/code&gt;&lt;/a&gt; is returned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="62e7ab507f523fe704d7f615781e7105b958a139" translate="yes" xml:space="preserve">
          <source>This will result in the &lt;code&gt;accept&lt;/code&gt; operation becoming nonblocking, i.e., immediately returning from their calls. If the IO operation is successful, &lt;code&gt;Ok&lt;/code&gt; is returned and no further action is required. If the IO operation could not be completed and needs to be retried, an error with kind &lt;a href=&quot;../io/enum.errorkind#variant.WouldBlock&quot;&gt;&lt;code&gt;io::ErrorKind::WouldBlock&lt;/code&gt;&lt;/a&gt; is returned.</source>
          <target state="translated">Это приведет к &lt;code&gt;accept&lt;/code&gt; операция accept станет неблокирующей, т. Е. Немедленно вернется из своих вызовов. Если операция ввода-вывода прошла успешно, возвращается &lt;code&gt;Ok&lt;/code&gt; и никаких дальнейших действий не требуется. Если операция ввода-вывода не может быть завершена и ее необходимо &lt;a href=&quot;../io/enum.errorkind#variant.WouldBlock&quot;&gt; &lt;code&gt;io::ErrorKind::WouldBlock&lt;/code&gt; &lt;/a&gt; , возвращается ошибка вида io :: ErrorKind :: wouldBlock .</target>
        </trans-unit>
        <trans-unit id="b55e73be7a2382bca6297d35304f77d90844f6fa" translate="yes" xml:space="preserve">
          <source>This will retrieve the stored error in the underlying socket, clearing the field in the process. This can be useful for checking errors between calls.</source>
          <target state="translated">При этом будет восстановлена сохраненная ошибка в базовом разъеме,а поле в процессе очистки будет очищено.Это может быть полезно для проверки ошибок между вызовами.</target>
        </trans-unit>
        <trans-unit id="88ce8a4d0f2f6725fab10313d205fd945723d024" translate="yes" xml:space="preserve">
          <source>This will return &lt;code&gt;None&lt;/code&gt; if the &lt;code&gt;Metadata&lt;/code&gt; instance was created from a call to &lt;code&gt;DirEntry::metadata&lt;/code&gt;. If this &lt;code&gt;Metadata&lt;/code&gt; was created by using &lt;code&gt;fs::metadata&lt;/code&gt; or &lt;code&gt;File::metadata&lt;/code&gt;, then this will return &lt;code&gt;Some&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3f194e7c7453fbebb97c4d612baa72decde0dd60" translate="yes" xml:space="preserve">
          <source>This will return an error when the IP version of the local socket does not match that returned from &lt;a href=&quot;trait.tosocketaddrs&quot;&gt;&lt;code&gt;ToSocketAddrs&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Это вернет ошибку, если IP-версия локального сокета не совпадает с &lt;a href=&quot;trait.tosocketaddrs&quot;&gt; &lt;code&gt;ToSocketAddrs&lt;/code&gt; &lt;/a&gt; , возвращенной ToSocketAddrs .</target>
        </trans-unit>
        <trans-unit id="fc0cdcc30572aec7d1df1cbb47d079cf5a14ac66" translate="yes" xml:space="preserve">
          <source>This will succeed even if there are outstanding weak references.</source>
          <target state="translated">Это удастся,даже если есть невыполненные слабые рекомендации.</target>
        </trans-unit>
        <trans-unit id="2bd1f4c0ae47dc79d8ec8c7bba4ba6b5d8664eba" translate="yes" xml:space="preserve">
          <source>This will use &lt;code&gt;clone&lt;/code&gt; to duplicate an expression, so one should be careful using this with types having a nonstandard &lt;code&gt;Clone&lt;/code&gt; implementation. For example, &lt;code&gt;vec![Rc::new(1); 5]&lt;/code&gt; will create a vector of five references to the same boxed integer value, not five references pointing to independently boxed integers.</source>
          <target state="translated">Это будет использовать &lt;code&gt;clone&lt;/code&gt; для дублирования выражения, поэтому следует быть осторожным, используя это с типами, имеющими нестандартную реализацию &lt;code&gt;Clone&lt;/code&gt; . Например, &lt;code&gt;vec![Rc::new(1); 5]&lt;/code&gt; создаст вектор из пяти ссылок на одно и то же целое число в рамке, а не из пяти ссылок, указывающих на независимо упакованные целые числа.</target>
        </trans-unit>
        <trans-unit id="1af0f8715542d97c1e40ad188906242d9ebb10f7" translate="yes" xml:space="preserve">
          <source>This works because &lt;code&gt;Box&lt;/code&gt; is a pointer, so its size is well-known.</source>
          <target state="translated">Это работает, потому что &lt;code&gt;Box&lt;/code&gt; является указателем, поэтому его размер хорошо известен.</target>
        </trans-unit>
        <trans-unit id="e6ae7145b95212826784b081e816d005693796fd" translate="yes" xml:space="preserve">
          <source>This works differently from defining a struct that uses a generic type parameter with trait bounds. A generic type parameter can only be substituted with one concrete type at a time, whereas trait objects allow for multiple concrete types to fill in for the trait object at runtime. For example, we could have defined the &lt;code&gt;Screen&lt;/code&gt; struct using a generic type and a trait bound as in Listing 17-6:</source>
          <target state="translated">Это работает иначе, чем определение структуры, которая использует параметр универсального типа с границами характеристик. Параметр универсального типа может быть заменен только одним конкретным типом за раз, тогда как объекты признаков позволяют нескольким конкретным типам заменять объект признака во время выполнения. Например, мы могли бы определить структуру &lt;code&gt;Screen&lt;/code&gt; , используя общий тип и привязку характеристики, как в листинге 17-6:</target>
        </trans-unit>
        <trans-unit id="a99f3af5ecd17821d147ce27f764af7ca400396e" translate="yes" xml:space="preserve">
          <source>This works fine, but when the method gains generic parameters, we can have a problem.</source>
          <target state="translated">Это хорошо работает,но когда метод получает общие параметры,у нас может возникнуть проблема.</target>
        </trans-unit>
        <trans-unit id="d71531129bdd4b29a09ed683d862d9540e2e5d1c" translate="yes" xml:space="preserve">
          <source>This works just fine and explicitly produces the behavior shown in Figure 4-3, where the heap data &lt;em&gt;does&lt;/em&gt; get copied.</source>
          <target state="translated">Это прекрасно работает и явно производит поведение показано на рисунке 4-3, где данные кучи &lt;em&gt;действительно&lt;/em&gt; копируются.</target>
        </trans-unit>
        <trans-unit id="bfbfb994099b13008a48f4d00df577d26e30661c" translate="yes" xml:space="preserve">
          <source>This works without any problems. Ownership is moved out, and nothing is deallocated.</source>
          <target state="translated">Это работает без проблем.Собственность вывозится,и ничего не перераспределяется.</target>
        </trans-unit>
        <trans-unit id="6c438e4eca96ad10f658e6fd464bdd00bbab9e0b" translate="yes" xml:space="preserve">
          <source>This wrapper helps with explicitly documenting the drop order dependencies between fields of the type:</source>
          <target state="translated">Эта обертка помогает явно документировать зависимости порядка падения между полями типа:</target>
        </trans-unit>
        <trans-unit id="77c94458816b78e926120564c533b185a38f9981" translate="yes" xml:space="preserve">
          <source>This wrapper is 0-cost.</source>
          <target state="translated">Эта обёртка стоит 0.</target>
        </trans-unit>
        <trans-unit id="bb9a9b150cc6f7bfa7d25085c5da29bd09b9aebf" translate="yes" xml:space="preserve">
          <source>This zero-sized type &lt;em&gt;coerces&lt;/em&gt; to a regular function pointer. For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8adf6fbbeb84fc23d69997d38f588cc8535a0a6a" translate="yes" xml:space="preserve">
          <source>Though they both have scary names, &lt;code&gt;PhantomData&lt;/code&gt; and 'phantom types' are related, but not identical. A phantom type parameter is simply a type parameter which is never used. In Rust, this often causes the compiler to complain, and the solution is to add a &quot;dummy&quot; use by way of &lt;code&gt;PhantomData&lt;/code&gt;.</source>
          <target state="translated">Хотя у них обоих устрашающие имена, &lt;code&gt;PhantomData&lt;/code&gt; и &amp;laquo;фантомные типы&amp;raquo; связаны, но не идентичны. Параметр фантомного типа - это просто параметр типа, который никогда не используется. В Rust это часто вызывает недовольство компилятора, и решение состоит в том, чтобы добавить &amp;laquo;фиктивное&amp;raquo; использование посредством &lt;code&gt;PhantomData&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="394004c26aaecc036ffcf91c8fc18935b18646a0" translate="yes" xml:space="preserve">
          <source>Though this example seems innocuous and easy to solve, the problem becomes clear when it encounters functions which consume the value:</source>
          <target state="translated">Хотя этот пример кажется безобидным и легко решаемым,проблема становится понятной,когда она сталкивается с функциями,которые потребляют значение:</target>
        </trans-unit>
        <trans-unit id="68fc8c5fcce31dacdf37236f648493191d2504be" translate="yes" xml:space="preserve">
          <source>Though this method is safe for any two pointers, note that its result will be mostly useless if the two pointers aren't into the same allocated object, for example if they point to two different local variables.</source>
          <target state="translated">Хотя этот метод безопасен для любых двух указателей,обратите внимание,что его результат будет в основном бесполезен,если эти два указателя не находятся в одном и том же выделенном объекте,например,если они указывают на две различные локальные переменные.</target>
        </trans-unit>
        <trans-unit id="7863f7503e5377891a3b7452c7d6cc377d443fe7" translate="yes" xml:space="preserve">
          <source>Thread</source>
          <target state="translated">Thread</target>
        </trans-unit>
        <trans-unit id="b66b6cbe04365929e922b75680e179e46127f3a3" translate="yes" xml:space="preserve">
          <source>Thread Safety</source>
          <target state="translated">Безопасность резьбы</target>
        </trans-unit>
        <trans-unit id="8acbe8abc881f5530528aa5ba52eb0a3d5f4e21c" translate="yes" xml:space="preserve">
          <source>Thread factory, which can be used in order to configure the properties of a new thread.</source>
          <target state="translated">Завод-изготовитель нитей,который может быть использован для настройки свойств нового потока.</target>
        </trans-unit>
        <trans-unit id="3f259cba637903dc7da0506c4d921b66c4b2c1d2" translate="yes" xml:space="preserve">
          <source>Thread with a specified name:</source>
          <target state="translated">Нить с указанным именем:</target>
        </trans-unit>
        <trans-unit id="ccd9cecfbe050ef8f7199536919145c98a9ee01e" translate="yes" xml:space="preserve">
          <source>Thread-local storage</source>
          <target state="translated">Резьбовое хранилище</target>
        </trans-unit>
        <trans-unit id="031ccc205829651d22cb916d91b65f0a8f208375" translate="yes" xml:space="preserve">
          <source>Thread::borrow</source>
          <target state="translated">Thread::borrow</target>
        </trans-unit>
        <trans-unit id="c95c792ba6b184afddca7a8e36aefd1fbf1d6ade" translate="yes" xml:space="preserve">
          <source>Thread::borrow_mut</source>
          <target state="translated">Thread::borrow_mut</target>
        </trans-unit>
        <trans-unit id="dbb6daabaec761c7c46cdca4426de7d2af20b09f" translate="yes" xml:space="preserve">
          <source>Thread::clone</source>
          <target state="translated">Thread::clone</target>
        </trans-unit>
        <trans-unit id="e27a758e7d203684411b93372f7af767f3888a92" translate="yes" xml:space="preserve">
          <source>Thread::clone_from</source>
          <target state="translated">Thread::clone_from</target>
        </trans-unit>
        <trans-unit id="21aa2dd81c0fa05128232b310f0bc9892cddef0b" translate="yes" xml:space="preserve">
          <source>Thread::clone_into</source>
          <target state="translated">Thread::clone_into</target>
        </trans-unit>
        <trans-unit id="070b95410e1e4362fb02748c2208a536c3a47c62" translate="yes" xml:space="preserve">
          <source>Thread::fmt</source>
          <target state="translated">Thread::fmt</target>
        </trans-unit>
        <trans-unit id="15bec62911f03b003cb69d406b3848ca01770f8f" translate="yes" xml:space="preserve">
          <source>Thread::from</source>
          <target state="translated">Thread::from</target>
        </trans-unit>
        <trans-unit id="4a91eeba81f613beaaf6029aae0e32dad80d38b8" translate="yes" xml:space="preserve">
          <source>Thread::id</source>
          <target state="translated">Thread::id</target>
        </trans-unit>
        <trans-unit id="b2a4ffaaac236ade773000faaa7bef3c1f0cc8f6" translate="yes" xml:space="preserve">
          <source>Thread::into</source>
          <target state="translated">Thread::into</target>
        </trans-unit>
        <trans-unit id="344f7d7a1faf3f99cb05399e695391adc35f7d18" translate="yes" xml:space="preserve">
          <source>Thread::name</source>
          <target state="translated">Thread::name</target>
        </trans-unit>
        <trans-unit id="2dcbcae4f337ba144bfa61f602dbf53a215ffbaa" translate="yes" xml:space="preserve">
          <source>Thread::to_owned</source>
          <target state="translated">Thread::to_owned</target>
        </trans-unit>
        <trans-unit id="08e8a562777dded639d27f7f44cfadcf3bf00a5e" translate="yes" xml:space="preserve">
          <source>Thread::try_from</source>
          <target state="translated">Thread::try_from</target>
        </trans-unit>
        <trans-unit id="ea003eda575d811cf577619ef02836592885180a" translate="yes" xml:space="preserve">
          <source>Thread::try_into</source>
          <target state="translated">Thread::try_into</target>
        </trans-unit>
        <trans-unit id="ee3875fc112ad5bc121f3e391fcecb3da4daa377" translate="yes" xml:space="preserve">
          <source>Thread::type_id</source>
          <target state="translated">Thread::type_id</target>
        </trans-unit>
        <trans-unit id="a2b67a0f80271fce8e8b3bd5ec25f2445ebea8c7" translate="yes" xml:space="preserve">
          <source>Thread::unpark</source>
          <target state="translated">Thread::unpark</target>
        </trans-unit>
        <trans-unit id="cd1b87b64abdd5b00fbed5a0cf0c46e8cabde3e0" translate="yes" xml:space="preserve">
          <source>ThreadId</source>
          <target state="translated">ThreadId</target>
        </trans-unit>
        <trans-unit id="e1f6247a7eef6633e4e5d83608be9b3187e0c969" translate="yes" xml:space="preserve">
          <source>ThreadId::borrow</source>
          <target state="translated">ThreadId::borrow</target>
        </trans-unit>
        <trans-unit id="22f5c0c99a3c51f5db8e51f093d172c44439f9bc" translate="yes" xml:space="preserve">
          <source>ThreadId::borrow_mut</source>
          <target state="translated">ThreadId::borrow_mut</target>
        </trans-unit>
        <trans-unit id="f272ac73f50e66007497d727840b4334ee1f128b" translate="yes" xml:space="preserve">
          <source>ThreadId::clone</source>
          <target state="translated">ThreadId::clone</target>
        </trans-unit>
        <trans-unit id="6c35d53945f00e081a8257913c3ad292495b0c89" translate="yes" xml:space="preserve">
          <source>ThreadId::clone_from</source>
          <target state="translated">ThreadId::clone_from</target>
        </trans-unit>
        <trans-unit id="9abe12a7685c82abc8d5bcbb6509a690fccefb0b" translate="yes" xml:space="preserve">
          <source>ThreadId::clone_into</source>
          <target state="translated">ThreadId::clone_into</target>
        </trans-unit>
        <trans-unit id="1fcd1d752fe2d53f1b3acff5f74fcaa56fbea5a4" translate="yes" xml:space="preserve">
          <source>ThreadId::eq</source>
          <target state="translated">ThreadId::eq</target>
        </trans-unit>
        <trans-unit id="02c70e2223708a5777dae53420e0c974498720e0" translate="yes" xml:space="preserve">
          <source>ThreadId::fmt</source>
          <target state="translated">ThreadId::fmt</target>
        </trans-unit>
        <trans-unit id="b838b903c39a24240409358be89ed6329a9df09a" translate="yes" xml:space="preserve">
          <source>ThreadId::from</source>
          <target state="translated">ThreadId::from</target>
        </trans-unit>
        <trans-unit id="ddc023441f52408bece6bf2ff774b50209750066" translate="yes" xml:space="preserve">
          <source>ThreadId::hash</source>
          <target state="translated">ThreadId::hash</target>
        </trans-unit>
        <trans-unit id="8244a05f09ebefd9016fbce0f8394db6f762584b" translate="yes" xml:space="preserve">
          <source>ThreadId::hash_slice</source>
          <target state="translated">ThreadId::hash_slice</target>
        </trans-unit>
        <trans-unit id="fd5bfcfa29d7d00b83774a3201acbc0e51fa4872" translate="yes" xml:space="preserve">
          <source>ThreadId::into</source>
          <target state="translated">ThreadId::into</target>
        </trans-unit>
        <trans-unit id="a87f4470467c3e753de867438c3b5d2edf68e527" translate="yes" xml:space="preserve">
          <source>ThreadId::ne</source>
          <target state="translated">ThreadId::ne</target>
        </trans-unit>
        <trans-unit id="3cd41ae993fc3fddaa9fb843d50a8938bb01dd02" translate="yes" xml:space="preserve">
          <source>ThreadId::to_owned</source>
          <target state="translated">ThreadId::to_owned</target>
        </trans-unit>
        <trans-unit id="c7ce06f7b4875caccd8b2ef7310bb3589387aaa7" translate="yes" xml:space="preserve">
          <source>ThreadId::try_from</source>
          <target state="translated">ThreadId::try_from</target>
        </trans-unit>
        <trans-unit id="1723d15638b0712b0610f447b496de925bf9fce1" translate="yes" xml:space="preserve">
          <source>ThreadId::try_into</source>
          <target state="translated">ThreadId::try_into</target>
        </trans-unit>
        <trans-unit id="586fd641683540c80a212ba3dd698b0a2d8e64c3" translate="yes" xml:space="preserve">
          <source>ThreadId::type_id</source>
          <target state="translated">ThreadId::type_id</target>
        </trans-unit>
        <trans-unit id="c8f829eec28b00e160b939476f6112a322b89854" translate="yes" xml:space="preserve">
          <source>Threads are able to have associated names for identification purposes. By default, spawned threads are unnamed. To specify a name for a thread, build the thread with &lt;a href=&quot;struct.builder&quot;&gt;&lt;code&gt;Builder&lt;/code&gt;&lt;/a&gt; and pass the desired thread name to &lt;a href=&quot;struct.builder#method.name&quot;&gt;&lt;code&gt;Builder::name&lt;/code&gt;&lt;/a&gt;. To retrieve the thread name from within the thread, use &lt;a href=&quot;struct.thread#method.name&quot;&gt;&lt;code&gt;Thread::name&lt;/code&gt;&lt;/a&gt;. A couple examples of where the name of a thread gets used:</source>
          <target state="translated">Потоки могут иметь связанные имена для целей идентификации. По умолчанию порожденные потоки не имеют имени. Чтобы указать имя для потока, создайте поток с помощью &lt;a href=&quot;struct.builder&quot;&gt; &lt;code&gt;Builder&lt;/code&gt; &lt;/a&gt; и передайте желаемое имя потока в &lt;a href=&quot;struct.builder#method.name&quot;&gt; &lt;code&gt;Builder::name&lt;/code&gt; &lt;/a&gt; . Чтобы получить имя потока из потока, используйте &lt;a href=&quot;struct.thread#method.name&quot;&gt; &lt;code&gt;Thread::name&lt;/code&gt; &lt;/a&gt; . Пара примеров использования имени потока:</target>
        </trans-unit>
        <trans-unit id="fac19ffa706cd7f7c61cd4298da14db7d3225341" translate="yes" xml:space="preserve">
          <source>Threads are represented via the &lt;a href=&quot;struct.thread&quot;&gt;&lt;code&gt;Thread&lt;/code&gt;&lt;/a&gt; type, which you can get in one of two ways:</source>
          <target state="translated">Потоки представлены через тип &lt;a href=&quot;struct.thread&quot;&gt; &lt;code&gt;Thread&lt;/code&gt; &lt;/a&gt; , который можно получить одним из двух способов:</target>
        </trans-unit>
        <trans-unit id="dfac2e4a30b24c7a0b51fc7ce730d2b041ad7fac" translate="yes" xml:space="preserve">
          <source>Threads are represented via the &lt;code&gt;Thread&lt;/code&gt; type, which you can get in one of two ways:</source>
          <target state="translated">Потоки представлены через тип &lt;code&gt;Thread&lt;/code&gt; , который можно получить одним из двух способов:</target>
        </trans-unit>
        <trans-unit id="61ca9f4a8a357e814dec07995e4960f9fb1789c1" translate="yes" xml:space="preserve">
          <source>Threads by default have no name specified:</source>
          <target state="translated">Нитки по умолчанию не имеют указанного имени:</target>
        </trans-unit>
        <trans-unit id="968a06f03211a8e28589507e83ecbad68bacd321" translate="yes" xml:space="preserve">
          <source>Three examples of &lt;code&gt;extern crate&lt;/code&gt; declarations:</source>
          <target state="translated">Три примера объявлений &lt;code&gt;extern crate&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="adf3f084c350f9e4e1af9b596fea76609465c5c2" translate="yes" xml:space="preserve">
          <source>Throughout the book, you&amp;rsquo;ve seen examples of many kinds of patterns. In this section, we gather all the syntax valid in patterns and discuss why you might want to use each one.</source>
          <target state="translated">На протяжении всей книги вы видели примеры самых разных шаблонов. В этом разделе мы собираем весь синтаксис, действующий в шаблонах, и обсуждаем, почему вы можете захотеть использовать каждый из них.</target>
        </trans-unit>
        <trans-unit id="60bf7601d61de03ae0783bd8d23bcd9c972360eb" translate="yes" xml:space="preserve">
          <source>Throughout the documentation, we will follow a few conventions. For all operations, the collection's size is denoted by n. If another collection is involved in the operation, it contains m elements. Operations which have an &lt;em&gt;amortized&lt;/em&gt; cost are suffixed with a &lt;code&gt;*&lt;/code&gt;. Operations with an &lt;em&gt;expected&lt;/em&gt; cost are suffixed with a &lt;code&gt;~&lt;/code&gt;.</source>
          <target state="translated">В документации мы будем придерживаться нескольких соглашений. Для всех операций размер коллекции обозначается n. Если в операции участвует другая коллекция, она содержит m элементов. Операции, имеющие &lt;em&gt;амортизированную&lt;/em&gt; стоимость , обозначаются знаком &lt;code&gt;*&lt;/code&gt; . Операции с &lt;em&gt;ожидаемой&lt;/em&gt; стоимостью помечаются суффиксом &lt;code&gt;~&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="238f30330684e8f9c133d5faa32478b32bb7092d" translate="yes" xml:space="preserve">
          <source>Throughout this book, we&amp;rsquo;ve used &lt;code&gt;let&lt;/code&gt; like this hundreds of times, and although you might not have realized it, you were using patterns! More formally, a &lt;code&gt;let&lt;/code&gt; statement looks like this:</source>
          <target state="translated">На протяжении всей книги мы использовали &lt;code&gt;let&lt;/code&gt; как это сотни раз, и хотя вы могли этого не осознавать, вы использовали шаблоны! Более формально оператор &lt;code&gt;let&lt;/code&gt; выглядит так:</target>
        </trans-unit>
        <trans-unit id="3b79edbe5b3429757c6a6c5658f9e500a2a9f5f8" translate="yes" xml:space="preserve">
          <source>Thus the pattern of &lt;code&gt;yield&lt;/code&gt;ing after a failed poll is rather common when implementing low-level shared resources or synchronization primitives.</source>
          <target state="translated">Таким образом, модель &lt;code&gt;yield&lt;/code&gt; после неудачного опроса довольно распространена при реализации низкоуровневых общих ресурсов или примитивов синхронизации.</target>
        </trans-unit>
        <trans-unit id="821dfcf79b1432754988865d9447fbfdba546e04" translate="yes" xml:space="preserve">
          <source>Thus, &lt;code&gt;ref&lt;/code&gt; is not something that is being matched against. Its objective is exclusively to make the matched binding a reference, instead of potentially copying or moving what was matched.</source>
          <target state="translated">Таким образом, &lt;code&gt;ref&lt;/code&gt; - это не то, с чем сравниваются. Его цель состоит исключительно в том, чтобы сделать сопоставленную привязку ссылкой, вместо того, чтобы потенциально копировать или перемещать сопоставленные.</target>
        </trans-unit>
        <trans-unit id="f25396ffdb747466e5fd6748ffb6e2945d105f98" translate="yes" xml:space="preserve">
          <source>Thus, a sensible way to handle a thread panic is to either:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bbe716d48d812e780f5d0c025cd7d8e8d137e139" translate="yes" xml:space="preserve">
          <source>Thus:</source>
          <target state="translated">Thus:</target>
        </trans-unit>
        <trans-unit id="667c88e4323d998577ae614b3d0f0d63105deed4" translate="yes" xml:space="preserve">
          <source>Time complexity</source>
          <target state="translated">Сложность во времени</target>
        </trans-unit>
        <trans-unit id="87e54a385b9de69cf35ac4ab359d69ed9aa1950a" translate="yes" xml:space="preserve">
          <source>To &lt;code id=&quot;to-panic-or-not-to-panic&quot;&gt;panic!&lt;/code&gt; or Not to &lt;code&gt;panic!&lt;/code&gt;</source>
          <target state="translated">Для &lt;code id=&quot;to-panic-or-not-to-panic&quot;&gt;panic!&lt;/code&gt; или не &lt;code&gt;panic!&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="6c0ba38264d0a297ae9df50179b24027837bbba6" translate="yes" xml:space="preserve">
          <source>To add &lt;code&gt;Millimeters&lt;/code&gt; and &lt;code&gt;Meters&lt;/code&gt;, we specify &lt;code&gt;impl Add&amp;lt;Meters&amp;gt;&lt;/code&gt; to set the value of the &lt;code&gt;RHS&lt;/code&gt; type parameter instead of using the default of &lt;code&gt;Self&lt;/code&gt;.</source>
          <target state="translated">Чтобы добавить &lt;code&gt;Millimeters&lt;/code&gt; и &lt;code&gt;Meters&lt;/code&gt; , мы указываем &lt;code&gt;impl Add&amp;lt;Meters&amp;gt;&lt;/code&gt; для установки значения параметра типа &lt;code&gt;RHS&lt;/code&gt; вместо использования значения по умолчанию &lt;code&gt;Self&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="cba3d2f6052bb257fd3b265e03522cd76a90182d" translate="yes" xml:space="preserve">
          <source>To add &lt;code&gt;Millimeters&lt;/code&gt; and &lt;code&gt;Meters&lt;/code&gt;, we specify &lt;code&gt;impl Add&amp;lt;Meters&amp;gt;&lt;/code&gt; to set the value of the &lt;code&gt;Rhs&lt;/code&gt; type parameter instead of using the default of &lt;code&gt;Self&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="48e27f28761495c993b1d146a55214b33393a503" translate="yes" xml:space="preserve">
          <source>To allow customization in specific cases most users won&amp;rsquo;t need</source>
          <target state="translated">Чтобы разрешить настройку в определенных случаях, большинству пользователей не понадобится</target>
        </trans-unit>
        <trans-unit id="b1d5c30e2acf4bd68628daf0a08fcdb7d03b4380" translate="yes" xml:space="preserve">
          <source>To assist with proper design, the following scenarios are explicitly declared legal for single-threaded code:</source>
          <target state="translated">Для помощи в правильном проектировании следующие сценарии однопоточного кода явным образом объявляются законными:</target>
        </trans-unit>
        <trans-unit id="3ff5f80d30f1f493faf134bdcac7192bc4fe0c89" translate="yes" xml:space="preserve">
          <source>To avoid a memory leak the pointer must be converted back to an &lt;code&gt;Arc&lt;/code&gt; using &lt;a href=&quot;struct.arc#method.from_raw&quot;&gt;&lt;code&gt;Arc::from_raw&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Чтобы избежать утечки памяти, указатель необходимо преобразовать обратно в &lt;code&gt;Arc&lt;/code&gt; с помощью &lt;a href=&quot;struct.arc#method.from_raw&quot;&gt; &lt;code&gt;Arc::from_raw&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="c1e40b418899dc58e251a0e3e3662f5034b84fa8" translate="yes" xml:space="preserve">
          <source>To avoid a memory leak the pointer must be converted back to an &lt;code&gt;Rc&lt;/code&gt; using &lt;a href=&quot;struct.rc#method.from_raw&quot;&gt;&lt;code&gt;Rc::from_raw&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Чтобы избежать утечки памяти, указатель должен быть преобразован обратно в &lt;code&gt;Rc&lt;/code&gt; с помощью &lt;a href=&quot;struct.rc#method.from_raw&quot;&gt; &lt;code&gt;Rc::from_raw&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="4a5ee855a608ecd864fa2e7b73853f23dfbb067b" translate="yes" xml:space="preserve">
          <source>To avoid creating &lt;code&gt;&amp;amp;mut [T]&lt;/code&gt; references that alias, the returned slice borrows its lifetime from the iterator the method is applied on.</source>
          <target state="translated">Чтобы избежать создания ссылок &lt;code&gt;&amp;amp;mut [T]&lt;/code&gt; на этот псевдоним, возвращаемый фрагмент заимствует свое время жизни у итератора, к которому применяется метод.</target>
        </trans-unit>
        <trans-unit id="ffa0cd99296c4663ce93793ddad7c9407847a5e2" translate="yes" xml:space="preserve">
          <source>To avoid creating &lt;code&gt;&amp;amp;mut&lt;/code&gt; references that alias, this is forced to consume the iterator.</source>
          <target state="translated">Чтобы избежать создания ссылок &lt;code&gt;&amp;amp;mut&lt;/code&gt; на этот псевдоним, он вынужден использовать итератор.</target>
        </trans-unit>
        <trans-unit id="1aefc821eaa401be8625ea8100fecfc992fdeed8" translate="yes" xml:space="preserve">
          <source>To avoid having &lt;code&gt;common&lt;/code&gt; appear in the test output, instead of creating &lt;em&gt;tests/common.rs&lt;/em&gt;, we&amp;rsquo;ll create &lt;em&gt;tests/common/mod.rs&lt;/em&gt;. This is an alternate naming convention that Rust also understands. Naming the file this way tells Rust not to treat the &lt;code&gt;common&lt;/code&gt; module as an integration test file. When we move the &lt;code&gt;setup&lt;/code&gt; function code into &lt;em&gt;tests/common/mod.rs&lt;/em&gt; and delete the &lt;em&gt;tests/common.rs&lt;/em&gt; file, the section in the test output will no longer appear. Files in subdirectories of the &lt;em&gt;tests&lt;/em&gt; directory don&amp;rsquo;t get compiled as separate crates or have sections in the test output.</source>
          <target state="translated">Для того, чтобы избежать &lt;code&gt;common&lt;/code&gt; в выводе теста, вместо того чтобы создавать &lt;em&gt;тесты / common.rs&lt;/em&gt; , мы будем создавать &lt;em&gt;тесты / Common / mod.rs&lt;/em&gt; . Это альтернативное соглашение об именах, которое также понимает Rust. Такое имя файла говорит Rust не рассматривать &lt;code&gt;common&lt;/code&gt; модуль как тестовый файл интеграции. Когда мы перемещаем код функции &lt;code&gt;setup&lt;/code&gt; в &lt;em&gt;tests / common / mod.rs&lt;/em&gt; и удаляем файл &lt;em&gt;tests / common.rs&lt;/em&gt; , раздел в выходных данных теста больше не появляется. Файлы в подкаталогах каталога &lt;em&gt;тестов&lt;/em&gt; не компилируются как отдельные ящики и не имеют разделов в выходных данных теста.</target>
        </trans-unit>
        <trans-unit id="3621c2a13fc7da454e2221c729cf687e93b1bda8" translate="yes" xml:space="preserve">
          <source>To avoid it, you have to replace the non-constant value:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ea7a1a1787370230342d01e7d26cc5eb0fdaf231" translate="yes" xml:space="preserve">
          <source>To avoid the error there are a couple of options.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1645dd8754fa06f0f760253ea0a8f05162d861bf" translate="yes" xml:space="preserve">
          <source>To avoid this error, first bind the temporary to a named local variable:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="97ceede3cc5738536ea015edb67ed85c3d3dcd2e" translate="yes" xml:space="preserve">
          <source>To avoid this error, you have to keep only one of them and remove the others. So let's take our example and fix it:</source>
          <target state="translated">Чтобы избежать этой ошибки,необходимо оставить только одну из них и удалить остальные.Так что давайте возьмем наш пример и исправим его:</target>
        </trans-unit>
        <trans-unit id="a30b99a191595831b8cb7e0383bc895012a3666a" translate="yes" xml:space="preserve">
          <source>To avoid this kind of error, ensure that at least one local type is referenced by the &lt;code&gt;impl&lt;/code&gt;:</source>
          <target state="translated">Чтобы избежать такого рода ошибок, убедитесь, что по крайней мере на один локальный тип ссылается &lt;code&gt;impl&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="a83579bf275c61511e259b0f6a5393712638d88c" translate="yes" xml:space="preserve">
          <source>To avoid those issues, you have to make the types match correctly. So we can fix the previous examples like this:</source>
          <target state="translated">Чтобы избежать этих проблем,необходимо сделать так,чтобы типы соответствовали друг другу.Таким образом,мы можем исправить предыдущие примеры:</target>
        </trans-unit>
        <trans-unit id="8cca79e59af2d0e450f9f7893d8b74973a17a0c1" translate="yes" xml:space="preserve">
          <source>To be able to index into a type it needs to implement the &lt;code&gt;std::ops::Index&lt;/code&gt; trait. Example:</source>
          <target state="translated">Чтобы иметь возможность индексировать в тип, необходимо реализовать черту &lt;code&gt;std::ops::Index&lt;/code&gt; . Пример:</target>
        </trans-unit>
        <trans-unit id="e0c4569eca23f12e74ce8e43ea0b16ae30221104" translate="yes" xml:space="preserve">
          <source>To be clear: most features will be available on all editions. Developers using any Rust edition will continue to see improvements as new stable releases are made. However, in some cases, mainly when new keywords are added, some new features might only be available in later editions. You will need to switch editions if you want to take advantage of such features.</source>
          <target state="translated">Чтобы было понятно:большинство функций будет доступно во всех редакциях.Разработчики,использующие любую версию Rust,будут продолжать видеть улучшения по мере выпуска новых стабильных релизов.Однако в некоторых случаях,в основном при добавлении новых ключевых слов,некоторые новые возможности могут быть доступны только в более поздних редакциях.Если вы хотите воспользоваться такими возможностями,вам нужно будет поменять редакции.</target>
        </trans-unit>
        <trans-unit id="28519d7825ab9ef768276a220fcc5248c6cfd08d" translate="yes" xml:space="preserve">
          <source>To be valid, a matcher must meet the following three invariants. The definitions of FIRST and FOLLOW are described later.</source>
          <target state="translated">Чтобы быть действительным,матчер должен соответствовать следующим трем инвариантам.Определения ПЕРВЫЙ и ПЕРВЫЙ описаны ниже.</target>
        </trans-unit>
        <trans-unit id="4dcb6216e57dabede5c512636b8402fc6577f67d" translate="yes" xml:space="preserve">
          <source>To better understand how these work in Rust, read the &lt;a href=&quot;book/ch13-01-closures&quot;&gt;Closures&lt;/a&gt; chapter of the Book.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d27f02149ea4da378573490ec467ba6b8b5c842f" translate="yes" xml:space="preserve">
          <source>To better understand why we need two separate loops, imagine a scenario with two workers. If we used a single loop to iterate through each worker, on the first iteration a terminate message would be sent down the channel and &lt;code&gt;join&lt;/code&gt; called on the first worker&amp;rsquo;s thread. If that first worker was busy processing a request at that moment, the second worker would pick up the terminate message from the channel and shut down. We would be left waiting on the first worker to shut down, but it never would because the second thread picked up the terminate message. Deadlock!</source>
          <target state="translated">Чтобы лучше понять, зачем нам нужны два отдельных цикла, представьте сценарий с двумя рабочими. Если бы мы использовали один цикл для итерации каждого рабочего потока , на первой итерации сообщение о завершении было бы отправлено по каналу, и &lt;code&gt;join&lt;/code&gt; вызвало бы первый рабочий поток. Если этот первый рабочий процесс был занят обработкой запроса в тот момент, второй рабочий забрал бы сообщение о завершении из канала и отключился. Нам оставалось бы ждать, пока завершится первый рабочий процесс, но этого не произойдет, потому что второй поток принял сообщение о завершении. Тупик!</target>
        </trans-unit>
        <trans-unit id="a92bd1b796549d070a95e516f74d8da028284983" translate="yes" xml:space="preserve">
          <source>To bind the matched value of a pattern to a variable, use the syntax &lt;code&gt;variable @ subpattern&lt;/code&gt;. For example, the following binds the value 2 to &lt;code&gt;e&lt;/code&gt; (not the entire range: the range here is a range subpattern).</source>
          <target state="translated">Чтобы привязать совпадающее значение шаблона к переменной, используйте синтаксис &lt;code&gt;variable @ subpattern&lt;/code&gt; . Например, следующее связывает значение 2 с &lt;code&gt;e&lt;/code&gt; (не весь диапазон: диапазон здесь является подшаблоном диапазона).</target>
        </trans-unit>
        <trans-unit id="b830c9413c38579d4ef7795bcf7bbde269208939" translate="yes" xml:space="preserve">
          <source>To build or modify paths, use &lt;a href=&quot;struct.pathbuf&quot;&gt;&lt;code&gt;PathBuf&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">Для создания или изменения путей используйте &lt;a href=&quot;struct.pathbuf&quot;&gt; &lt;code&gt;PathBuf&lt;/code&gt; &lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="bfa1e223892bc7e4bd4f7e711edfd1f7972be85d" translate="yes" xml:space="preserve">
          <source>To calculate the layout of a &lt;code&gt;#[repr(C)]&lt;/code&gt; structure and the offsets of the fields from its fields' layouts:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a716f5c06d1b56904d9c9ecdfaef8a89e71a7435" translate="yes" xml:space="preserve">
          <source>To calculate the value of &lt;code&gt;prediction&lt;/code&gt;, this code iterates through each of the 12 values in &lt;code&gt;coefficients&lt;/code&gt; and uses the &lt;code&gt;zip&lt;/code&gt; method to pair the coefficient values with the previous 12 values in &lt;code&gt;buffer&lt;/code&gt;. Then, for each pair, we multiply the values together, sum all the results, and shift the bits in the sum &lt;code&gt;qlp_shift&lt;/code&gt; bits to the right.</source>
          <target state="translated">Чтобы вычислить значение &lt;code&gt;prediction&lt;/code&gt; , этот код выполняет итерацию по каждому из 12 значений в &lt;code&gt;coefficients&lt;/code&gt; и использует метод &lt;code&gt;zip&lt;/code&gt; для объединения значений коэффициента с предыдущими 12 значениями в &lt;code&gt;buffer&lt;/code&gt; . Затем для каждой пары мы умножаем значения вместе, суммируем все результаты и сдвигаем биты в сумме &lt;code&gt;qlp_shift&lt;/code&gt; битов вправо.</target>
        </trans-unit>
        <trans-unit id="e1e36c60ac0b0cf3c0b11863470e32d28a059d98" translate="yes" xml:space="preserve">
          <source>To call the &lt;code&gt;fly&lt;/code&gt; methods from either the &lt;code&gt;Pilot&lt;/code&gt; trait or the &lt;code&gt;Wizard&lt;/code&gt; trait, we need to use more explicit syntax to specify which &lt;code&gt;fly&lt;/code&gt; method we mean. Listing 19-18 demonstrates this syntax.</source>
          <target state="translated">Чтобы вызвать методы &lt;code&gt;fly&lt;/code&gt; из черты &lt;code&gt;Pilot&lt;/code&gt; или &lt;code&gt;Wizard&lt;/code&gt; , нам нужно использовать более явный синтаксис, чтобы указать, какой метод &lt;code&gt;fly&lt;/code&gt; мы имеем в виду. Перечисление 19-18 демонстрирует этот синтаксис.</target>
        </trans-unit>
        <trans-unit id="5c07c5eaca75954c044b220e0d9378c6ce45b1a4" translate="yes" xml:space="preserve">
          <source>To call this associated function, we use the &lt;code&gt;::&lt;/code&gt; syntax with the struct name; &lt;code&gt;let sq = Rectangle::square(3);&lt;/code&gt; is an example. This function is namespaced by the struct: the &lt;code&gt;::&lt;/code&gt; syntax is used for both associated functions and namespaces created by modules. We&amp;rsquo;ll discuss modules in Chapter 7.</source>
          <target state="translated">Чтобы вызвать эту связанную функцию, мы используем синтаксис &lt;code&gt;::&lt;/code&gt; с именем структуры; &lt;code&gt;let sq = Rectangle::square(3);&lt;/code&gt; это пример. Пространство имен этой функции определяется структурой: синтаксис &lt;code&gt;::&lt;/code&gt; используется как для связанных функций, так и для пространств имен, созданных модулями. Мы обсудим модули в главе 7.</target>
        </trans-unit>
        <trans-unit id="191c93d8beeacd6897f106d1c47af3f257c7dd5f" translate="yes" xml:space="preserve">
          <source>To call this code with only those types that implement the &lt;code&gt;Copy&lt;/code&gt; trait, we can add &lt;code&gt;Copy&lt;/code&gt; to the trait bounds of &lt;code&gt;T&lt;/code&gt;! Listing 10-15 shows the complete code of a generic &lt;code&gt;largest&lt;/code&gt; function that will compile as long as the types of the values in the slice that we pass into the function implement the &lt;code&gt;PartialOrd&lt;/code&gt;&lt;em&gt;and&lt;/em&gt;&lt;code&gt;Copy&lt;/code&gt; traits, like &lt;code&gt;i32&lt;/code&gt; and &lt;code&gt;char&lt;/code&gt; do.</source>
          <target state="translated">Чтобы вызвать этот код только с теми типами, которые реализуют трейт &lt;code&gt;Copy&lt;/code&gt; , мы можем добавить &lt;code&gt;Copy&lt;/code&gt; к границам трейта &lt;code&gt;T&lt;/code&gt; ! В листинге 10-15 показан полный код универсальной &lt;code&gt;largest&lt;/code&gt; функции, которая будет компилироваться до тех пор, пока типы значений в срезе, который мы передаем в функцию, реализуют черты &lt;code&gt;PartialOrd&lt;/code&gt; &lt;em&gt;и &lt;/em&gt; &lt;code&gt;Copy&lt;/code&gt; , как это &lt;code&gt;i32&lt;/code&gt; и &lt;code&gt;char&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2ae7caef9479d77c77a3d3a0a7f430defd27a454" translate="yes" xml:space="preserve">
          <source>To change the value that the mutable reference refers to, we have to use the dereference operator (&lt;code&gt;*&lt;/code&gt;) to get to the value in &lt;code&gt;i&lt;/code&gt; before we can use the &lt;code&gt;+=&lt;/code&gt; operator. We&amp;rsquo;ll talk more about the dereference operator in the &lt;a href=&quot;ch15-02-deref#following-the-pointer-to-the-value-with-the-dereference-operator&quot;&gt;&amp;ldquo;Following the Pointer to the Value with the Dereference Operator&amp;rdquo;&lt;/a&gt; section of Chapter 15.</source>
          <target state="translated">Чтобы изменить значение, на которое ссылается изменяемая ссылка, мы должны использовать оператор разыменования ( &lt;code&gt;*&lt;/code&gt; ), чтобы получить значение в &lt;code&gt;i&lt;/code&gt; , прежде чем мы сможем использовать оператор &lt;code&gt;+=&lt;/code&gt; . Подробнее об операторе разыменования мы поговорим в разделе &lt;a href=&quot;ch15-02-deref#following-the-pointer-to-the-value-with-the-dereference-operator&quot;&gt;&amp;laquo;Следование указателю на значение с помощью оператора разыменования&amp;raquo;&lt;/a&gt; главы 15.</target>
        </trans-unit>
        <trans-unit id="8d0f5fc712b1dc8e53a799fd7ad61e2d58ce4f6e" translate="yes" xml:space="preserve">
          <source>To check the type for the return type of a function with multiple return statements.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ff93ea5d521caed491ca6edf931b71effa3ca726" translate="yes" xml:space="preserve">
          <source>To check whether you have Rust installed correctly, open a shell and enter this line:</source>
          <target state="translated">Чтобы проверить,правильно ли установлен Rust,откройте оболочку и введите эту строку:</target>
        </trans-unit>
        <trans-unit id="b81a5a29868dab97f44f48c2bd716ec3edc16d7e" translate="yes" xml:space="preserve">
          <source>To combine &lt;code&gt;repr(transparent)&lt;/code&gt; with type parameters, &lt;code&gt;PhantomData&lt;/code&gt; may be useful:</source>
          <target state="translated">Чтобы объединить &lt;code&gt;repr(transparent)&lt;/code&gt; с параметрами типа, &lt;code&gt;PhantomData&lt;/code&gt; может быть полезен:</target>
        </trans-unit>
        <trans-unit id="ac3f03b22205947cc54e2019b2f0993969841a80" translate="yes" xml:space="preserve">
          <source>To confuse things further, &lt;a href=&quot;https://encoding.spec.whatwg.org/&quot;&gt;on the Web&lt;/a&gt;&lt;code&gt;ascii&lt;/code&gt;, &lt;code&gt;iso-8859-1&lt;/code&gt;, and &lt;code&gt;windows-1252&lt;/code&gt; are all aliases for a superset of Windows-1252 that fills the remaining blanks with corresponding C0 and C1 control codes.</source>
          <target state="translated">Чтобы еще больше запутать ситуацию, &lt;a href=&quot;https://encoding.spec.whatwg.org/&quot;&gt;в Интернете &lt;/a&gt; &lt;code&gt;ascii&lt;/code&gt; , &lt;code&gt;iso-8859-1&lt;/code&gt; и &lt;code&gt;windows-1252&lt;/code&gt; - это псевдонимы для расширенного набора Windows-1252, который заполняет оставшиеся пробелы соответствующими управляющими кодами C0 и C1.</target>
        </trans-unit>
        <trans-unit id="9e961e97b1bab5bb4d05da5fe7c2fc74357a8b93" translate="yes" xml:space="preserve">
          <source>To consume the old state, the &lt;code&gt;request_review&lt;/code&gt; method needs to take ownership of the state value. This is where the &lt;code&gt;Option&lt;/code&gt; in the &lt;code&gt;state&lt;/code&gt; field of &lt;code&gt;Post&lt;/code&gt; comes in: we call the &lt;code&gt;take&lt;/code&gt; method to take the &lt;code&gt;Some&lt;/code&gt; value out of the &lt;code&gt;state&lt;/code&gt; field and leave a &lt;code&gt;None&lt;/code&gt; in its place, because Rust doesn&amp;rsquo;t let us have unpopulated fields in structs. This lets us move the &lt;code&gt;state&lt;/code&gt; value out of &lt;code&gt;Post&lt;/code&gt; rather than borrowing it. Then we&amp;rsquo;ll set the post&amp;rsquo;s &lt;code&gt;state&lt;/code&gt; value to the result of this operation.</source>
          <target state="translated">Чтобы использовать старое состояние, метод &lt;code&gt;request_review&lt;/code&gt; должен стать владельцем значения состояния. Это где &lt;code&gt;Option&lt;/code&gt; в &lt;code&gt;state&lt;/code&gt; сфере &lt;code&gt;Post&lt;/code&gt; приходит в: мы называем &lt;code&gt;take&lt;/code&gt; метод принять &lt;code&gt;Some&lt;/code&gt; значения из &lt;code&gt;state&lt;/code&gt; поля и не оставить &lt;code&gt;None&lt;/code&gt; в своем месте, потому что ржавчина не давайте безлюдные поля в структурах. Это позволяет нам вынести значение &lt;code&gt;state&lt;/code&gt; из &lt;code&gt;Post&lt;/code&gt; , а не заимствовать его. Затем мы установим значение &lt;code&gt;state&lt;/code&gt; поста на результат этой операции.</target>
        </trans-unit>
        <trans-unit id="f337e083c37a19b6c9f78383e9d486a4274f1380" translate="yes" xml:space="preserve">
          <source>To control whether interfaces can be used across modules, Rust checks each use of an item to see whether it should be allowed or not. This is where privacy warnings are generated, or otherwise &quot;you used a private item of another module and weren't allowed to.&quot;</source>
          <target state="translated">Чтобы контролировать,могут ли интерфейсы использоваться между модулями,Rust проверяет каждое использование элемента,чтобы определить,должен ли он быть разрешен или нет.В этом случае выдаются предупреждения о конфиденциальности,или иным образом &quot;вы использовали личный элемент другого модуля и не были разрешены&quot;.</target>
        </trans-unit>
        <trans-unit id="ba21f5abea5c571067a1a7d57de3d3aa5bc54641" translate="yes" xml:space="preserve">
          <source>To convert a single value to a string, use the &lt;a href=&quot;../string/trait.tostring&quot;&gt;&lt;code&gt;to_string&lt;/code&gt;&lt;/a&gt; method. This will use the &lt;a href=&quot;trait.display&quot;&gt;&lt;code&gt;Display&lt;/code&gt;&lt;/a&gt; formatting trait.</source>
          <target state="translated">Чтобы преобразовать одиночное значение в строку, используйте метод &lt;a href=&quot;../string/trait.tostring&quot;&gt; &lt;code&gt;to_string&lt;/code&gt; &lt;/a&gt; . Это будет использовать свойство форматирования &lt;a href=&quot;trait.display&quot;&gt; &lt;code&gt;Display&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="3cb338cb9ed195af952f18624a8d65c1ca64787f" translate="yes" xml:space="preserve">
          <source>To convert a single value to a string, use the &lt;a href=&quot;string/trait.tostring&quot;&gt;&lt;code&gt;to_string&lt;/code&gt;&lt;/a&gt; method. This will use the &lt;a href=&quot;fmt/trait.display&quot;&gt;&lt;code&gt;Display&lt;/code&gt;&lt;/a&gt; formatting trait.</source>
          <target state="translated">Чтобы преобразовать одиночное значение в строку, используйте метод &lt;a href=&quot;string/trait.tostring&quot;&gt; &lt;code&gt;to_string&lt;/code&gt; &lt;/a&gt; . Это будет использовать свойство форматирования &lt;a href=&quot;fmt/trait.display&quot;&gt; &lt;code&gt;Display&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="015234ea3f6220712aedf5ea26711d734042f76e" translate="yes" xml:space="preserve">
          <source>To create a &lt;code&gt;match&lt;/code&gt; expression that compares the values of the outer &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt;, rather than introducing a shadowed variable, we would need to use a match guard conditional instead. We&amp;rsquo;ll talk about match guards later in the &lt;a href=&quot;#extra-conditionals-with-match-guards&quot;&gt;&amp;ldquo;Extra Conditionals with Match Guards&amp;rdquo;&lt;/a&gt; section.</source>
          <target state="translated">Для создания &lt;code&gt;match&lt;/code&gt; выражения , которое сравнивает значения внешних &lt;code&gt;x&lt;/code&gt; и &lt;code&gt;y&lt;/code&gt; , а не вводить затененную переменный, мы должны были бы использовать спички сторожевой Условные вместо этого. Мы поговорим об охранниках матча позже в разделе &lt;a href=&quot;#extra-conditionals-with-match-guards&quot;&gt;&amp;laquo;Дополнительные условия с охранниками матча&amp;raquo;&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="d6a361bf034a44065bf4d983adf9bd5159e505a7" translate="yes" xml:space="preserve">
          <source>To create a new thread, we call the &lt;code&gt;thread::spawn&lt;/code&gt; function and pass it a closure (we talked about closures in Chapter 13) containing the code we want to run in the new thread. The example in Listing 16-1 prints some text from a main thread and other text from a new thread:</source>
          <target state="translated">Чтобы создать новый поток, мы вызываем функцию &lt;code&gt;thread::spawn&lt;/code&gt; и передаем ей замыкание (о замыканиях мы говорили в главе 13), содержащее код, который мы хотим запустить в новом потоке. Пример в листинге 16-1 печатает некоторый текст из основного потока и другой текст из нового потока:</target>
        </trans-unit>
        <trans-unit id="aa89b2295fcdc6f9c080aa3a4a8e8468c77980e1" translate="yes" xml:space="preserve">
          <source>To create a new, empty vector, we can call the &lt;code&gt;Vec::new&lt;/code&gt; function, as shown in Listing 8-1.</source>
          <target state="translated">Чтобы создать новый пустой вектор, мы можем вызвать функцию &lt;code&gt;Vec::new&lt;/code&gt; , как показано в Листинге 8-1.</target>
        </trans-unit>
        <trans-unit id="1a88aa76c7ad4f90214c55053637e980f11dd3a9" translate="yes" xml:space="preserve">
          <source>To create a vector and then add elements to it, we can use the &lt;code&gt;push&lt;/code&gt; method, as shown in Listing 8-3.</source>
          <target state="translated">Чтобы создать вектор и затем добавить к нему элементы, мы можем использовать метод &lt;code&gt;push&lt;/code&gt; , как показано в Листинге 8-3.</target>
        </trans-unit>
        <trans-unit id="00c0015adacecd8350d6133979871ae1b1edfe94" translate="yes" xml:space="preserve">
          <source>To define a &lt;code&gt;Point&lt;/code&gt; struct where &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; are both generics but could have different types, we can use multiple generic type parameters. For example, in Listing 10-8, we can change the definition of &lt;code&gt;Point&lt;/code&gt; to be generic over types &lt;code&gt;T&lt;/code&gt; and &lt;code&gt;U&lt;/code&gt; where &lt;code&gt;x&lt;/code&gt; is of type &lt;code&gt;T&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; is of type &lt;code&gt;U&lt;/code&gt;.</source>
          <target state="translated">Чтобы определить структуру &lt;code&gt;Point&lt;/code&gt; , где &lt;code&gt;x&lt;/code&gt; и &lt;code&gt;y&lt;/code&gt; являются универсальными, но могут иметь разные типы, мы можем использовать несколько параметров универсального типа. Например, в листинге 10-8, мы можем изменить определение &lt;code&gt;Point&lt;/code&gt; , чтобы быть универсальным над типами &lt;code&gt;T&lt;/code&gt; и &lt;code&gt;U&lt;/code&gt; , где &lt;code&gt;x&lt;/code&gt; имеет тип &lt;code&gt;T&lt;/code&gt; и &lt;code&gt;y&lt;/code&gt; имеет тип &lt;code&gt;U&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="48e3d6adfbf70e45f3b29de0115bced82f45c8ba" translate="yes" xml:space="preserve">
          <source>To define a macro, you use the &lt;code&gt;macro_rules!&lt;/code&gt; construct. Let&amp;rsquo;s explore how to use &lt;code&gt;macro_rules!&lt;/code&gt; by looking at how the &lt;code&gt;vec!&lt;/code&gt; macro is defined. Chapter 8 covered how we can use the &lt;code&gt;vec!&lt;/code&gt; macro to create a new vector with particular values. For example, the following macro creates a new vector containing three integers:</source>
          <target state="translated">Чтобы определить макрос, вы используете &lt;code&gt;macro_rules!&lt;/code&gt; построить. Давайте посмотрим, как использовать &lt;code&gt;macro_rules!&lt;/code&gt; посмотрев, как работает &lt;code&gt;vec!&lt;/code&gt; макрос определен. В главе 8 рассказывается, как мы можем использовать &lt;code&gt;vec!&lt;/code&gt; макрос для создания нового вектора с определенными значениями. Например, следующий макрос создает новый вектор, содержащий три целых числа:</target>
        </trans-unit>
        <trans-unit id="0305c11d131bdcb2f62d25c1e047d31c7b279a29" translate="yes" xml:space="preserve">
          <source>To define a struct, we enter the keyword &lt;code&gt;struct&lt;/code&gt; and name the entire struct. A struct&amp;rsquo;s name should describe the significance of the pieces of data being grouped together. Then, inside curly brackets, we define the names and types of the pieces of data, which we call &lt;em&gt;fields&lt;/em&gt;. For example, Listing 5-1 shows a struct that stores information about a user account.</source>
          <target state="translated">Чтобы определить структуру, мы вводим ключевое слово &lt;code&gt;struct&lt;/code&gt; и называем всю структуру. Имя структуры должно описывать значимость группируемых частей данных. Затем в фигурных скобках мы определяем имена и типы фрагментов данных, которые мы называем &lt;em&gt;полями&lt;/em&gt; . Например, в листинге 5-1 показана структура, в которой хранится информация об учетной записи пользователя.</target>
        </trans-unit>
        <trans-unit id="8f9b83d2cc8d6fc88b967504ac913c99c3032360" translate="yes" xml:space="preserve">
          <source>To define a tuple struct, start with the &lt;code&gt;struct&lt;/code&gt; keyword and the struct name followed by the types in the tuple. For example, here are definitions and usages of two tuple structs named &lt;code&gt;Color&lt;/code&gt; and &lt;code&gt;Point&lt;/code&gt;:</source>
          <target state="translated">Чтобы определить структуру кортежа, начните с ключевого слова &lt;code&gt;struct&lt;/code&gt; и имени структуры, за которыми следуют типы в кортеже. Например, вот определения и использование двух структур кортежей с именами &lt;code&gt;Color&lt;/code&gt; и &lt;code&gt;Point&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="bf22e9ab26d9ba6ee6b2e46fe0b19d5124fc0343" translate="yes" xml:space="preserve">
          <source>To define the function within the context of &lt;code&gt;Rectangle&lt;/code&gt;, we start an &lt;code&gt;impl&lt;/code&gt; (implementation) block. Then we move the &lt;code&gt;area&lt;/code&gt; function within the &lt;code&gt;impl&lt;/code&gt; curly brackets and change the first (and in this case, only) parameter to be &lt;code&gt;self&lt;/code&gt; in the signature and everywhere within the body. In &lt;code&gt;main&lt;/code&gt;, where we called the &lt;code&gt;area&lt;/code&gt; function and passed &lt;code&gt;rect1&lt;/code&gt; as an argument, we can instead use &lt;em&gt;method syntax&lt;/em&gt; to call the &lt;code&gt;area&lt;/code&gt; method on our &lt;code&gt;Rectangle&lt;/code&gt; instance. The method syntax goes after an instance: we add a dot followed by the method name, parentheses, and any arguments.</source>
          <target state="translated">Чтобы определить функцию в контексте &lt;code&gt;Rectangle&lt;/code&gt; , мы запускаем блок &lt;code&gt;impl&lt;/code&gt; (реализация). Затем мы перемещаем функцию &lt;code&gt;area&lt;/code&gt; в &lt;code&gt;impl&lt;/code&gt; фигурные скобки и меняем первый (и в данном случае единственный) параметр на &lt;code&gt;self&lt;/code&gt; в подписи и везде в теле. В &lt;code&gt;main&lt;/code&gt; , где мы вызвали функцию &lt;code&gt;area&lt;/code&gt; и передали &lt;code&gt;rect1&lt;/code&gt; в качестве аргумента, вместо этого мы можем использовать &lt;em&gt;синтаксис метода&lt;/em&gt; для вызова метода &lt;code&gt;area&lt;/code&gt; в нашем экземпляре &lt;code&gt;Rectangle&lt;/code&gt; . Синтаксис метода идет после экземпляра: мы добавляем точку, за которой следует имя метода, круглые скобки и любые аргументы.</target>
        </trans-unit>
        <trans-unit id="2de6b544c44b76668f6d2936d8d501f7f9f3abad" translate="yes" xml:space="preserve">
          <source>To demonstrate how to run a subset of tests, we&amp;rsquo;ll create three tests for our &lt;code&gt;add_two&lt;/code&gt; function, as shown in Listing 11-11, and choose which ones to run.</source>
          <target state="translated">Чтобы продемонстрировать, как запускать подмножество тестов, мы создадим три теста для нашей функции &lt;code&gt;add_two&lt;/code&gt; , как показано в листинге 11-11, и выберем, какие из них запускать.</target>
        </trans-unit>
        <trans-unit id="e75dc3dfe6b153a0ceea282766b5c4d1615452e1" translate="yes" xml:space="preserve">
          <source>To demonstrate, let&amp;rsquo;s create an iterator that will only ever count from 1 to 5. First, we&amp;rsquo;ll create a struct to hold some values. Then we&amp;rsquo;ll make this struct into an iterator by implementing the &lt;code&gt;Iterator&lt;/code&gt; trait and using the values in that implementation.</source>
          <target state="translated">Для демонстрации давайте создадим итератор, который будет считать только от 1 до 5. Сначала мы создадим структуру для хранения некоторых значений. Затем мы превратим эту структуру в итератор, реализуя черту &lt;code&gt;Iterator&lt;/code&gt; и используя значения в этой реализации.</target>
        </trans-unit>
        <trans-unit id="b6b548838142d67d34f12bfbc64f7cdb12a47cc6" translate="yes" xml:space="preserve">
          <source>To determine how much space to allocate for a &lt;code&gt;Message&lt;/code&gt; value, Rust goes through each of the variants to see which variant needs the most space. Rust sees that &lt;code&gt;Message::Quit&lt;/code&gt; doesn&amp;rsquo;t need any space, &lt;code&gt;Message::Move&lt;/code&gt; needs enough space to store two &lt;code&gt;i32&lt;/code&gt; values, and so forth. Because only one variant will be used, the most space a &lt;code&gt;Message&lt;/code&gt; value will need is the space it would take to store the largest of its variants.</source>
          <target state="translated">Чтобы определить, сколько места выделить для значения &lt;code&gt;Message&lt;/code&gt; , Rust просматривает каждый из вариантов, чтобы увидеть, какой вариант требует больше всего места. Rust видит, что &lt;code&gt;Message::Quit&lt;/code&gt; не требует места, &lt;code&gt;Message::Move&lt;/code&gt; нужно достаточно места для хранения двух значений &lt;code&gt;i32&lt;/code&gt; и так далее. Поскольку будет использоваться только один вариант, наибольшее пространство, которое потребуется значению &lt;code&gt;Message&lt;/code&gt; , - это пространство, которое потребуется для хранения самого большого из его вариантов.</target>
        </trans-unit>
        <trans-unit id="375df8edff8c14a24952e9e1d54e255a42b357a9" translate="yes" xml:space="preserve">
          <source>To determine if a &lt;code&gt;T&lt;/code&gt; is &lt;code&gt;Foo&lt;/code&gt;, we need to check if &lt;code&gt;Bar&amp;lt;T&amp;gt;&lt;/code&gt; is &lt;code&gt;Foo&lt;/code&gt;. However, to do this check, we need to determine that &lt;code&gt;Bar&amp;lt;Bar&amp;lt;T&amp;gt;&amp;gt;&lt;/code&gt; is &lt;code&gt;Foo&lt;/code&gt;. To determine this, we check if &lt;code&gt;Bar&amp;lt;Bar&amp;lt;Bar&amp;lt;T&amp;gt;&amp;gt;&amp;gt;&lt;/code&gt; is &lt;code&gt;Foo&lt;/code&gt;, and so on. This is clearly a recursive requirement that can't be resolved directly.</source>
          <target state="translated">Для того, чтобы определить , является ли &lt;code&gt;T&lt;/code&gt; является &lt;code&gt;Foo&lt;/code&gt; , нам нужно проверить , если &lt;code&gt;Bar&amp;lt;T&amp;gt;&lt;/code&gt; является &lt;code&gt;Foo&lt;/code&gt; . Однако для выполнения этой проверки нам нужно определить, что &lt;code&gt;Bar&amp;lt;Bar&amp;lt;T&amp;gt;&amp;gt;&lt;/code&gt; имеет значение &lt;code&gt;Foo&lt;/code&gt; . Чтобы определить это, мы проверяем , если &lt;code&gt;Bar&amp;lt;Bar&amp;lt;Bar&amp;lt;T&amp;gt;&amp;gt;&amp;gt;&lt;/code&gt; является &lt;code&gt;Foo&lt;/code&gt; , и так далее. Это явно рекурсивное требование, которое нельзя решить напрямую.</target>
        </trans-unit>
        <trans-unit id="b8666f35753eb530d957bee0ef54848c41571aca" translate="yes" xml:space="preserve">
          <source>To determine the total number of seconds represented by the &lt;code&gt;Duration&lt;/code&gt;, use &lt;code&gt;as_secs&lt;/code&gt; in combination with &lt;a href=&quot;#method.subsec_nanos&quot;&gt;&lt;code&gt;subsec_nanos&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">Чтобы определить общее количество секунд, представленное &lt;code&gt;Duration&lt;/code&gt; , используйте &lt;code&gt;as_secs&lt;/code&gt; в сочетании с &lt;a href=&quot;#method.subsec_nanos&quot;&gt; &lt;code&gt;subsec_nanos&lt;/code&gt; &lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="08d2c31864b299072e74b4018700dfb17575ecb3" translate="yes" xml:space="preserve">
          <source>To determine the total number of seconds represented by the &lt;code&gt;Duration&lt;/code&gt;, use &lt;code&gt;as_secs&lt;/code&gt; in combination with &lt;a href=&quot;struct.duration#method.subsec_nanos&quot;&gt;&lt;code&gt;subsec_nanos&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1c73fc588227a5e5b304d8e85115a9b2d547b13e" translate="yes" xml:space="preserve">
          <source>To determine whether to use loops or iterators, you need to know which version of our &lt;code&gt;search&lt;/code&gt; functions is faster: the version with an explicit &lt;code&gt;for&lt;/code&gt; loop or the version with iterators.</source>
          <target state="translated">Чтобы определить, использовать ли циклы или итераторы, вам необходимо знать, какая версия наших функций &lt;code&gt;search&lt;/code&gt; работает быстрее: версия с явным циклом &lt;code&gt;for&lt;/code&gt; или версия с итераторами.</target>
        </trans-unit>
        <trans-unit id="235f6ddc8fb93b9bc27bd450e93516c6f056381f" translate="yes" xml:space="preserve">
          <source>To disambiguate and tell Rust that we want to use the implementation of &lt;code&gt;Animal&lt;/code&gt; for &lt;code&gt;Dog&lt;/code&gt;, we need to use fully qualified syntax. Listing 19-21 demonstrates how to use fully qualified syntax.</source>
          <target state="translated">Чтобы устранить неоднозначность и сообщить Rust, что мы хотим использовать реализацию &lt;code&gt;Animal&lt;/code&gt; for &lt;code&gt;Dog&lt;/code&gt; , нам нужно использовать полностью определенный синтаксис. В листинге 19-21 показано, как использовать полностью определенный синтаксис.</target>
        </trans-unit>
        <trans-unit id="f6bc5e83e5f978fc7521ec1ad0ec48fc0bc1e6d4" translate="yes" xml:space="preserve">
          <source>To do this in a language with inheritance, we might define a class named &lt;code&gt;Component&lt;/code&gt; that has a method named &lt;code&gt;draw&lt;/code&gt; on it. The other classes, such as &lt;code&gt;Button&lt;/code&gt;, &lt;code&gt;Image&lt;/code&gt;, and &lt;code&gt;SelectBox&lt;/code&gt;, would inherit from &lt;code&gt;Component&lt;/code&gt; and thus inherit the &lt;code&gt;draw&lt;/code&gt; method. They could each override the &lt;code&gt;draw&lt;/code&gt; method to define their custom behavior, but the framework could treat all of the types as if they were &lt;code&gt;Component&lt;/code&gt; instances and call &lt;code&gt;draw&lt;/code&gt; on them. But because Rust doesn&amp;rsquo;t have inheritance, we need another way to structure the &lt;code&gt;gui&lt;/code&gt; library to allow users to extend it with new types.</source>
          <target state="translated">Чтобы сделать это на языке с наследованием, мы могли бы определить класс с именем &lt;code&gt;Component&lt;/code&gt; , у которого есть метод с именем &lt;code&gt;draw&lt;/code&gt; . Другие классы, такие как &lt;code&gt;Button&lt;/code&gt; , &lt;code&gt;Image&lt;/code&gt; и &lt;code&gt;SelectBox&lt;/code&gt; , унаследуют от &lt;code&gt;Component&lt;/code&gt; и, таким образом, унаследуют метод &lt;code&gt;draw&lt;/code&gt; . Каждый из них может переопределить метод &lt;code&gt;draw&lt;/code&gt; чтобы определить свое настраиваемое поведение, но платформа может обрабатывать все типы, как если бы они были экземплярами &lt;code&gt;Component&lt;/code&gt; и вызывать для них &lt;code&gt;draw&lt;/code&gt; . Но поскольку в Rust нет наследования, нам нужен другой способ структурирования библиотеки &lt;code&gt;gui&lt;/code&gt; , чтобы пользователи могли расширять ее новыми типами.</target>
        </trans-unit>
        <trans-unit id="4978131923d35532be220aa91636f57efe0f7f12" translate="yes" xml:space="preserve">
          <source>To easily implement the Clone trait, you can also use &lt;code&gt;#[derive(Clone)]&lt;/code&gt;. Example:</source>
          <target state="translated">Чтобы легко реализовать трейт Clone, вы также можете использовать &lt;code&gt;#[derive(Clone)]&lt;/code&gt; . Пример:</target>
        </trans-unit>
        <trans-unit id="d0cd2dd965d6ad9f646e83059dd95c728c0a97cf" translate="yes" xml:space="preserve">
          <source>To eliminate this duplication, we can create an abstraction by defining a function that operates on any list of integers given to it in a parameter. This solution makes our code clearer and lets us express the concept of finding the largest number in a list abstractly.</source>
          <target state="translated">Чтобы устранить это дублирование,можно создать абстракцию,определив функцию,которая оперирует любым списком целых чисел,заданным ей в параметре.Это решение делает наш код более понятным и позволяет абстрактно выразить понятие нахождения наибольшего числа в списке.</target>
        </trans-unit>
        <trans-unit id="29cf48fa5d156f2e83366c6a4eab852452303d3f" translate="yes" xml:space="preserve">
          <source>To enable &lt;code&gt;minigrep&lt;/code&gt; to read the values of command line arguments we pass to it, we&amp;rsquo;ll need a function provided in Rust&amp;rsquo;s standard library, which is &lt;code&gt;std::env::args&lt;/code&gt;. This function returns an iterator of the command line arguments that were given to &lt;code&gt;minigrep&lt;/code&gt;. We&amp;rsquo;ll cover iterators fully in &lt;a href=&quot;ch13-00-functional-features&quot;&gt;Chapter 13&lt;/a&gt;. For now, you only need to know two details about iterators: iterators produce a series of values, and we can call the &lt;code&gt;collect&lt;/code&gt; method on an iterator to turn it into a collection, such as a vector, containing all the elements the iterator produces.</source>
          <target state="translated">Чтобы позволить &lt;code&gt;minigrep&lt;/code&gt; читать значения аргументов командной строки, которые мы ему передаем, нам понадобится функция, предоставленная в стандартной библиотеке Rust, которая называется &lt;code&gt;std::env::args&lt;/code&gt; . Эта функция возвращает итератор аргументов командной строки, переданных &lt;code&gt;minigrep&lt;/code&gt; . Мы полностью рассмотрим итераторы в &lt;a href=&quot;ch13-00-functional-features&quot;&gt;главе 13&lt;/a&gt; . На данный момент вам нужно знать только две детали об итераторах: итераторы создают серию значений, и мы можем вызвать метод &lt;code&gt;collect&lt;/code&gt; на итераторе, чтобы превратить его в коллекцию, такую ​​как вектор, содержащую все элементы, создаваемые итератором.</target>
        </trans-unit>
        <trans-unit id="ad43deb7c3d4847ed4f9b3c47149e285bd2d149c" translate="yes" xml:space="preserve">
          <source>To enable multiple ownership, Rust has a type called &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt;, which is an abbreviation for &lt;em&gt;reference counting&lt;/em&gt;. The &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; type keeps track of the number of references to a value which determines whether or not a value is still in use. If there are zero references to a value, the value can be cleaned up without any references becoming invalid.</source>
          <target state="translated">Чтобы разрешить множественное владение, в Rust есть тип под названием &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; , который является сокращением для &lt;em&gt;подсчета ссылок&lt;/em&gt; . Тип &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; отслеживает количество ссылок на значение, которое определяет, используется ли значение по-прежнему. Если есть нулевые ссылки на значение, значение может быть очищено, и никакие ссылки не станут недействительными.</target>
        </trans-unit>
        <trans-unit id="e59e1050701d5494b23014e46f9317fad2eac0b0" translate="yes" xml:space="preserve">
          <source>To enable this feature on a nightly version of rustc, add the &lt;code&gt;const_fn&lt;/code&gt; feature flag:</source>
          <target state="translated">Чтобы включить эту функцию в ночной версии rustc, добавьте &lt;code&gt;const_fn&lt;/code&gt; функции const_fn :</target>
        </trans-unit>
        <trans-unit id="d24a8c41c8e51812d2f6a3d4df4d4bc30f42fd94" translate="yes" xml:space="preserve">
          <source>To ensure memory safety, there&amp;rsquo;s one more detail to what happens in this situation in Rust. Instead of trying to copy the allocated memory, Rust considers &lt;code&gt;s1&lt;/code&gt; to no longer be valid and, therefore, Rust doesn&amp;rsquo;t need to free anything when &lt;code&gt;s1&lt;/code&gt; goes out of scope. Check out what happens when you try to use &lt;code&gt;s1&lt;/code&gt; after &lt;code&gt;s2&lt;/code&gt; is created; it won&amp;rsquo;t work:</source>
          <target state="translated">Чтобы обеспечить безопасность памяти, есть еще одна деталь о том, что происходит в этой ситуации в Rust. Вместо того, чтобы пытаться скопировать выделенную память, Rust считает &lt;code&gt;s1&lt;/code&gt; недействительным и, следовательно, Rust не нужно ничего освобождать, когда &lt;code&gt;s1&lt;/code&gt; выходит за рамки. Посмотрите, что происходит, когда вы пытаетесь использовать &lt;code&gt;s1&lt;/code&gt; после создания &lt;code&gt;s2&lt;/code&gt; ; это не сработает:</target>
        </trans-unit>
        <trans-unit id="44d8c4aeacd237bf73174a5745772ccb9ea1f421" translate="yes" xml:space="preserve">
          <source>To ensure soundness, Safe Rust is restricted enough that it can be automatically checked. Sometimes, however, it is necessary to write code that is correct for reasons which are too clever for the compiler to understand. In those cases, you need to use Unsafe Rust.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8ccd9133d33f00e1b04fd5409b4bd62ab4182d4d" translate="yes" xml:space="preserve">
          <source>To extend a type without breaking existing code</source>
          <target state="translated">Для расширения типа без взлома существующего кода</target>
        </trans-unit>
        <trans-unit id="7b84fa9a4a555e1a74d29f79dcd3abb8731f5940" translate="yes" xml:space="preserve">
          <source>To find the common type for a series of if branches.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f27ddccf4caea85a4bf8ac030a69155b2d937a94" translate="yes" xml:space="preserve">
          <source>To find the common type for a series of match arms.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cd607b32ed771d3a582f20b6ce2e41a23d6c8021" translate="yes" xml:space="preserve">
          <source>To find the common type for array elements.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="986aa5a06f6c7eab4fbf8758ab21e34c28998b7b" translate="yes" xml:space="preserve">
          <source>To find the largest number in two different lists of numbers, we can duplicate the code in Listing 10-1 and use the same logic at two different places in the program, as shown in Listing 10-2.</source>
          <target state="translated">Чтобы найти наибольшее число в двух разных списках номеров,мы можем продублировать код в Листинге 10-1 и использовать одну и ту же логику в двух разных местах в программе,как показано в Листинге 10-2.</target>
        </trans-unit>
        <trans-unit id="886ceb6ce4fcd41c44c60891b1e238be8050a3e5" translate="yes" xml:space="preserve">
          <source>To find the type for the return type of a closure with multiple return statements.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="05412e512ad05fb982373163c001384a6dc6dc41" translate="yes" xml:space="preserve">
          <source>To fix such code, put them in an extern &quot;C&quot; block:</source>
          <target state="translated">Чтобы исправить такой код,поместите их в блок extern &quot;C&quot;:</target>
        </trans-unit>
        <trans-unit id="3f641101a15aa5663f425af7eca864860358c2b4" translate="yes" xml:space="preserve">
          <source>To fix the compiler error in Listing 16-3, we can use the error message&amp;rsquo;s advice:</source>
          <target state="translated">Чтобы исправить ошибку компилятора в листинге 16-3, мы можем использовать совет сообщения об ошибке:</target>
        </trans-unit>
        <trans-unit id="35eb0225e4203818949db81d35253471e9bc1946" translate="yes" xml:space="preserve">
          <source>To fix the issue, remove patterns (&lt;code&gt;_&lt;/code&gt; is allowed though). Example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ea4b2f5b453763912d29b2bc8e5d29a39885b8b2" translate="yes" xml:space="preserve">
          <source>To fix the issue, remove the duplicate declaration:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a982630d24bce9f0c2bacf99524398a473cc7ece" translate="yes" xml:space="preserve">
          <source>To fix the previous code example, we derive &lt;code&gt;PartialEq&lt;/code&gt; and &lt;code&gt;Eq&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9a70249adaf4eb50343b8e3cb8c112aee0c4394d" translate="yes" xml:space="preserve">
          <source>To fix the problem where we have a refutable pattern where an irrefutable pattern is needed, we can change the code that uses the pattern: instead of using &lt;code&gt;let&lt;/code&gt;, we can use &lt;code&gt;if let&lt;/code&gt;. Then if the pattern doesn&amp;rsquo;t match, the code will just skip the code in the curly brackets, giving it a way to continue validly. Listing 18-9 shows how to fix the code in Listing 18-8.</source>
          <target state="translated">Чтобы решить проблему, когда у нас есть опровергнутый шаблон, где требуется неопровержимый шаблон, мы можем изменить код, который использует этот шаблон: вместо использования &lt;code&gt;let&lt;/code&gt; мы можем использовать &lt;code&gt;if let&lt;/code&gt; . Затем, если шаблон не совпадает, код просто пропустит код в фигурных скобках, давая возможность продолжить работу. В листинге 18-9 показано, как исправить код в листинге 18-8.</target>
        </trans-unit>
        <trans-unit id="3d38f12fb6a882b38564fce2f1f7c9cb9d1796dd" translate="yes" xml:space="preserve">
          <source>To fix the problem, either remove the unknown meta item, or rename it if you provided the wrong name.</source>
          <target state="translated">Чтобы решить проблему,либо удалите неизвестный мета-элемент,либо переименуйте его,если вы указали неверное имя.</target>
        </trans-unit>
        <trans-unit id="ff15ef440d8fd65fc53847fcd7d27134b37684e0" translate="yes" xml:space="preserve">
          <source>To fix the problem, remove all but one of the meta items with the same key.</source>
          <target state="translated">Чтобы устранить проблему,удалите все мета-элементы,кроме одного,одним и тем же ключом.</target>
        </trans-unit>
        <trans-unit id="ea6969ed4bf2de9ff5e1987bde2a5974361798c0" translate="yes" xml:space="preserve">
          <source>To fix this and consume the iterator, we&amp;rsquo;ll use the &lt;code&gt;collect&lt;/code&gt; method, which we used in Chapter 12 with &lt;code&gt;env::args&lt;/code&gt; in Listing 12-1. This method consumes the iterator and collects the resulting values into a collection data type.</source>
          <target state="translated">Чтобы исправить это и использовать итератор, мы будем использовать метод &lt;code&gt;collect&lt;/code&gt; , который мы использовали в главе 12 с &lt;code&gt;env::args&lt;/code&gt; в листинге 12-1. Этот метод использует итератор и собирает полученные значения в тип данных коллекции.</target>
        </trans-unit>
        <trans-unit id="7ddafefb4eada6e20a8873619c096afec9d9e821" translate="yes" xml:space="preserve">
          <source>To fix this error we need to spell out &lt;code&gt;Self&lt;/code&gt; to &lt;code&gt;S&amp;lt;'a&amp;gt;&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d00f739419dcbd64823b1ea3abe0a10a9be4cbba" translate="yes" xml:space="preserve">
          <source>To fix this error, add a &lt;code&gt;main&lt;/code&gt; function:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b190c393f2e104afe11b9ff6d75785abc13b4fac" translate="yes" xml:space="preserve">
          <source>To fix this error, add the missing digits:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="74f9240b7df9e2cdcc942864074f152c08f49afd" translate="yes" xml:space="preserve">
          <source>To fix this error, add the missing double quote at the end of the string:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b2a45c1a4916fd6685c913af98c59a6ca44a92d9" translate="yes" xml:space="preserve">
          <source>To fix this error, add the missing quote:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="14bc23db223a3a7adb6fd2ea01135a7a51e21b23" translate="yes" xml:space="preserve">
          <source>To fix this error, check that you didn't misspell the field's name or that the field actually exists. Example:</source>
          <target state="translated">Чтобы исправить эту ошибку,проверьте,что вы не неправильно написали имя поля или что поле действительно существует.Пример:</target>
        </trans-unit>
        <trans-unit id="75b750ac4b7d89ba0d9d76afc4c969c263359a34" translate="yes" xml:space="preserve">
          <source>To fix this error, compile your code for a Rust target that supports the TrustZone-M extension. The current possible targets are:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a7f0d68c9258ec3385682a9e7888b4d82a961453" translate="yes" xml:space="preserve">
          <source>To fix this error, declare &lt;code&gt;ss&lt;/code&gt; as mutable by using the &lt;code&gt;mut&lt;/code&gt; keyword:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9a10ae82ce30bea6273b20c3ae88287f346a01ba" translate="yes" xml:space="preserve">
          <source>To fix this error, declare your entry function with a C ABI, using &lt;code&gt;extern &quot;C&quot;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ec4c03a79b5dd9aa983287afa6ca9be17b72579d" translate="yes" xml:space="preserve">
          <source>To fix this error, don't try to cast directly between thin and fat pointers.</source>
          <target state="translated">Чтобы исправить эту ошибку,не пытайтесь бросать прямо между тонкими и толстыми указками.</target>
        </trans-unit>
        <trans-unit id="851cef01fbc24aa508b07321c6a80e736f5740f3" translate="yes" xml:space="preserve">
          <source>To fix this error, either lessen the expected lifetime or find a way to not have to use this reference outside of its current scope (by running the code directly in the same block for example?):</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2cf449e499fd02815621561773f0782493f1f5ff" translate="yes" xml:space="preserve">
          <source>To fix this error, either split into multiple match arms:</source>
          <target state="translated">Чтобы исправить эту ошибку,либо разделитесь на несколько спичечных рук:</target>
        </trans-unit>
        <trans-unit id="4a625dc9e5fa99f625b4f36ca500334a72e9f93e" translate="yes" xml:space="preserve">
          <source>To fix this error, ensure that each field from the struct's definition is mentioned in the pattern, or use &lt;code&gt;..&lt;/code&gt; to ignore unwanted fields. Example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="59d5e036d18215af29bf5d6026ec79c924cc4630" translate="yes" xml:space="preserve">
          <source>To fix this error, ensure that you don't have any other references to the variable before trying to access it mutably:</source>
          <target state="translated">Чтобы исправить эту ошибку,убедитесь,что у вас нет других ссылок на переменную,прежде чем пытаться получить к ней мутильный доступ:</target>
        </trans-unit>
        <trans-unit id="c41c6753158354db97000bee3e6d1e71d162a5c2" translate="yes" xml:space="preserve">
          <source>To fix this error, ensure the match arm kind is the same as the expression matched.</source>
          <target state="translated">Чтобы исправить эту ошибку,убедитесь,что тип совпадающего плеча совпадает с выражением.</target>
        </trans-unit>
        <trans-unit id="0e0f8c883662f36aaeadf872304efd94871b85a2" translate="yes" xml:space="preserve">
          <source>To fix this error, just change the binding's name in order to avoid shadowing one of the following:</source>
          <target state="translated">Чтобы исправить эту ошибку,достаточно изменить имя привязки,чтобы избежать затенения одного из следующих пунктов:</target>
        </trans-unit>
        <trans-unit id="547cd595fdb912c2692881e0fc69f7e09c4e06b4" translate="yes" xml:space="preserve">
          <source>To fix this error, just specify the type of the variable. Example:</source>
          <target state="translated">Для исправления ошибки достаточно указать тип переменной.Пример:</target>
        </trans-unit>
        <trans-unit id="ac9826f4a5f0aca5be2cbd8435bee957e2a23961" translate="yes" xml:space="preserve">
          <source>To fix this error, just use the same mode in both cases. Generally using &lt;code&gt;ref&lt;/code&gt; or &lt;code&gt;ref mut&lt;/code&gt; where not already used will fix this:</source>
          <target state="translated">Чтобы исправить эту ошибку, просто используйте один и тот же режим в обоих случаях. Обычно это исправляет использование &lt;code&gt;ref&lt;/code&gt; или &lt;code&gt;ref mut&lt;/code&gt; там, где они еще не использовались:</target>
        </trans-unit>
        <trans-unit id="f5f3bd9b98cede2f9883569f89f15b8f146e95f8" translate="yes" xml:space="preserve">
          <source>To fix this error, please be sure that the module is in scope:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="130e6cb76ab8ba2e39f9316003d15648f16e824e" translate="yes" xml:space="preserve">
          <source>To fix this error, please check that this type implements this binary operation. Example:</source>
          <target state="translated">Для исправления этой ошибки проверьте,что этот тип реализует эту двоичную операцию.Пример:</target>
        </trans-unit>
        <trans-unit id="5f8bccc6c37b14540562ff31ba77c03a4a691b62" translate="yes" xml:space="preserve">
          <source>To fix this error, please ensure that all the fields of the struct are public, or implement a function for easy instantiation. Examples:</source>
          <target state="translated">Чтобы исправить эту ошибку,пожалуйста,убедитесь,что все поля структуры являются общедоступными,или реализуйте функцию для легкой конкретизации.Примеры:</target>
        </trans-unit>
        <trans-unit id="342e8c2f7a1ada9b484baabdc9d06d406ca80a54" translate="yes" xml:space="preserve">
          <source>To fix this error, please implement a trait on the type or wrap it in a struct. Example:</source>
          <target state="translated">Для исправления этой ошибки необходимо реализовать трейт на типе или обернуть его в структуру.Пример:</target>
        </trans-unit>
        <trans-unit id="befadb1ed4ec4a8c074944e9002910bb635c2bda" translate="yes" xml:space="preserve">
          <source>To fix this error, please remove the visibility qualifier when it is not required. Example:</source>
          <target state="translated">Для исправления этой ошибки,пожалуйста,удалите квалификатор видимости,когда он не требуется.Пример:</target>
        </trans-unit>
        <trans-unit id="dd5bba6de2aa5f4e39e98433e92b409c0d3ccac5" translate="yes" xml:space="preserve">
          <source>To fix this error, please replace the value with a constant. Example:</source>
          <target state="translated">Для исправления этой ошибки,пожалуйста,замените значение на константу.Пример:</target>
        </trans-unit>
        <trans-unit id="29332719480b2d3d455368380fd1815d30eebf29" translate="yes" xml:space="preserve">
          <source>To fix this error, please verify that the method name wasn't misspelled and verify that you are indeed implementing the correct trait items. Example:</source>
          <target state="translated">Чтобы исправить эту ошибку,пожалуйста,проверьте,что имя метода не было неправильно написано,и убедитесь,что вы действительно реализуете правильные элементы трейта.Пример:</target>
        </trans-unit>
        <trans-unit id="d6526d13f1c406efebc4022cedccc7bfc1d5dbc7" translate="yes" xml:space="preserve">
          <source>To fix this error, please verify you didn't misspell the type name, you did declare it or imported it into the scope. Examples:</source>
          <target state="translated">Чтобы исправить эту ошибку,пожалуйста,убедитесь,что вы не неправильно написали имя типа,вы его декларировали или импортировали в область видимости.Примеры:</target>
        </trans-unit>
        <trans-unit id="e76357808cad4720013a780f0b9c4aca40fe0097" translate="yes" xml:space="preserve">
          <source>To fix this error, remove the null characters:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1b0aa8ad2a46bb3a87624f0ae14dc2151334230f" translate="yes" xml:space="preserve">
          <source>To fix this error, replace the pattern argument with a regular one. Example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5459bb70fc45530a8171a7e09df41fa4c970e0d5" translate="yes" xml:space="preserve">
          <source>To fix this error, use a concrete type for the const parameter:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ca68924d905d97b9f1af1bea1e0a2d8cf16561fb" translate="yes" xml:space="preserve">
          <source>To fix this error, we need to move the &lt;code&gt;Shark&lt;/code&gt; struct inside the &lt;code&gt;Sea&lt;/code&gt; module:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="140824e6ec67ac2a81b7a4c3bb6daa38bc47f6d7" translate="yes" xml:space="preserve">
          <source>To fix this error, you can declare &lt;code&gt;create_some&lt;/code&gt; as a constant function:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6da3993819cb20099d5b634dd66120eb7048a481" translate="yes" xml:space="preserve">
          <source>To fix this error, you can finish using the closure before using the captured variable:</source>
          <target state="translated">Чтобы исправить эту ошибку,можно закончить использование закрытия,прежде чем использовать захваченную переменную:</target>
        </trans-unit>
        <trans-unit id="271f576e3469a4d5c3d47381caa4c74a644868c6" translate="yes" xml:space="preserve">
          <source>To fix this error, you can use the tuple pattern:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b3282af9d0d83b5725d812a840935cf798392f05" translate="yes" xml:space="preserve">
          <source>To fix this error, you have to move &lt;code&gt;yield&lt;/code&gt; out of the &lt;code&gt;async&lt;/code&gt; block:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="62676a2c0346704243e5e296c782b376a8f848ca" translate="yes" xml:space="preserve">
          <source>To fix this error, you have two solutions:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d18371bc4c07ba0c41f6206f4861a5d76f0f6e55" translate="yes" xml:space="preserve">
          <source>To fix this error, you need to mark all the parent implementations as default. Example:</source>
          <target state="translated">Чтобы исправить эту ошибку,необходимо по умолчанию отметить все родительские реализации.Пример:</target>
        </trans-unit>
        <trans-unit id="cf4fd1eefb95ff6d8562a2c0c639ea77e8a69e6e" translate="yes" xml:space="preserve">
          <source>To fix this issue, either use the lifetime in the arguments, or use &lt;code&gt;'static&lt;/code&gt;. Example:</source>
          <target state="translated">Чтобы устранить эту проблему, либо используйте время жизни в аргументах, либо используйте &lt;code&gt;'static&lt;/code&gt; . Пример:</target>
        </trans-unit>
        <trans-unit id="9bc21023f3e82d02ae5ca480adede6bb29ef608c" translate="yes" xml:space="preserve">
          <source>To fix this issue, either use the lifetime in the arguments, or use the &lt;code&gt;'static&lt;/code&gt; lifetime. Example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bb2e9d61c37258f8ed9cce9fe2929803d6d2313b" translate="yes" xml:space="preserve">
          <source>To fix this issue, either use the lifetime in the inputs, or use &lt;code&gt;'static&lt;/code&gt;. Example:</source>
          <target state="translated">Чтобы решить эту проблему, либо используйте время жизни во входных данных, либо используйте &lt;code&gt;'static&lt;/code&gt; . Пример:</target>
        </trans-unit>
        <trans-unit id="1c9273cf829edc7ecc1d2ffb40566c6ec5264a53" translate="yes" xml:space="preserve">
          <source>To fix this issue, just remove the generics:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="47d656f4427ec08945a130e9ab24f44d356e73c6" translate="yes" xml:space="preserve">
          <source>To fix this issue, just remove the return keyword or move the expression into a function. Example:</source>
          <target state="translated">Чтобы исправить эту проблему,просто удалите возвращаемое ключевое слово или переместите выражение в функцию.Пример:</target>
        </trans-unit>
        <trans-unit id="f7f17c649ffe42ea1218c2db05314ba8b680b067" translate="yes" xml:space="preserve">
          <source>To fix this issue, just remove the super trait:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6045b449bd1ac38773b2f91ba227f233a40af26b" translate="yes" xml:space="preserve">
          <source>To fix this issue, the lifetime in the const generic need to be changed to &lt;code&gt;'static&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9924221c408a112fe763d167c1b4a29e5c450e04" translate="yes" xml:space="preserve">
          <source>To fix this issue, you have to rename at least one of the two imports. Example:</source>
          <target state="translated">Чтобы исправить эту проблему,необходимо переименовать хотя бы один из двух импортов.Пример:</target>
        </trans-unit>
        <trans-unit id="8b92f6f0312b161fc6e42dd1de00eb946169f081" translate="yes" xml:space="preserve">
          <source>To fix this problem, we&amp;rsquo;ll modify the threads so they listen for either a &lt;code&gt;Job&lt;/code&gt; to run or a signal that they should stop listening and exit the infinite loop. Instead of &lt;code&gt;Job&lt;/code&gt; instances, our channel will send one of these two enum variants.</source>
          <target state="translated">Чтобы решить эту проблему, мы изменим потоки, чтобы они слушали либо выполнение &lt;code&gt;Job&lt;/code&gt; либо сигнал о том, что им следует прекратить прослушивание и выйти из бесконечного цикла. Вместо экземпляров &lt;code&gt;Job&lt;/code&gt; наш канал будет отправлять один из этих двух вариантов перечисления.</target>
        </trans-unit>
        <trans-unit id="c3ddf887a4b5f979d5c4754fbe5d3842c28e8398" translate="yes" xml:space="preserve">
          <source>To fix this problem, you can do either of these things:</source>
          <target state="translated">Чтобы решить эту проблему,вы можете сделать любую из этих вещей:</target>
        </trans-unit>
        <trans-unit id="d1040dc78ad7b42b1b39bcb93179f38486776a0b" translate="yes" xml:space="preserve">
          <source>To fix this problem, you need to create a local variable to store the value in rather than relying on a temporary. For example, you might change the original program to the following:</source>
          <target state="translated">Для исправления этой проблемы необходимо создать локальную переменную,в которой будет храниться значение,а не полагаться на временную.Например,вы можете изменить исходную программу на следующую:</target>
        </trans-unit>
        <trans-unit id="038c4ea9697da9d94b0b431c704689f74be084b1" translate="yes" xml:space="preserve">
          <source>To fix this we have to define the lifetime at the function or impl level and use that lifetime in the &lt;code&gt;impl Trait&lt;/code&gt;. For example you can define the lifetime at the function:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="396fe77bfe601f99ac29d2d6217b45f0b4c303c2" translate="yes" xml:space="preserve">
          <source>To fix this we have to use the labeled block properly. For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="360a9b00506f1addbb3267f917ea23dd8584e790" translate="yes" xml:space="preserve">
          <source>To fix this, add a label specifying which loop is being broken out of:</source>
          <target state="translated">Чтобы это исправить,добавьте метку,указывающую,из какого цикла происходит разрыв:</target>
        </trans-unit>
        <trans-unit id="4f4f5291163064ff6fda56abd889a7618c40d282" translate="yes" xml:space="preserve">
          <source>To fix this, add an implementation for each default method from the trait:</source>
          <target state="translated">Чтобы исправить это,добавьте реализацию для каждого метода по умолчанию из трейта:</target>
        </trans-unit>
        <trans-unit id="56a92651d517e6a1850a1ad3d4745e7b392eba21" translate="yes" xml:space="preserve">
          <source>To fix this, edit the &lt;em&gt;Cargo.toml&lt;/em&gt; file for the &lt;code&gt;adder&lt;/code&gt; crate and indicate that &lt;code&gt;rand&lt;/code&gt; is a dependency for that crate as well. Building the &lt;code&gt;adder&lt;/code&gt; crate will add &lt;code&gt;rand&lt;/code&gt; to the list of dependencies for &lt;code&gt;adder&lt;/code&gt; in &lt;em&gt;Cargo.lock&lt;/em&gt;, but no additional copies of &lt;code&gt;rand&lt;/code&gt; will be downloaded. Cargo has ensured that every crate in the workspace using the &lt;code&gt;rand&lt;/code&gt; crate will be using the same version. Using the same version of &lt;code&gt;rand&lt;/code&gt; across the workspace saves space because we won&amp;rsquo;t have multiple copies and ensures that the crates in the workspace will be compatible with each other.</source>
          <target state="translated">Чтобы исправить это, отредактируйте файл &lt;em&gt;Cargo.toml&lt;/em&gt; для ящика &lt;code&gt;adder&lt;/code&gt; и укажите, что &lt;code&gt;rand&lt;/code&gt; также является зависимостью для этого ящика. Сборка ящика &lt;code&gt;adder&lt;/code&gt; добавит &lt;code&gt;rand&lt;/code&gt; в список зависимостей &lt;code&gt;adder&lt;/code&gt; в &lt;em&gt;Cargo.lock&lt;/em&gt; , но никакие дополнительные копии &lt;code&gt;rand&lt;/code&gt; не будут загружены. Cargo позаботился о том, чтобы каждый ящик в рабочей области, в котором использовался ящик &lt;code&gt;rand&lt;/code&gt; , имел одну и ту же версию. Использование одной и той же версии &lt;code&gt;rand&lt;/code&gt; в рабочей области экономит место, потому что у нас не будет нескольких копий, и гарантирует, что ящики в рабочей области будут совместимы друг с другом.</target>
        </trans-unit>
        <trans-unit id="9d9a4693a46d51eb0d6120d0488c70fc938ea0de" translate="yes" xml:space="preserve">
          <source>To fix this, edit the &lt;em&gt;Cargo.toml&lt;/em&gt; file for the &lt;code&gt;adder&lt;/code&gt; package and indicate that &lt;code&gt;rand&lt;/code&gt; is a dependency for it as well. Building the &lt;code&gt;adder&lt;/code&gt; package will add &lt;code&gt;rand&lt;/code&gt; to the list of dependencies for &lt;code&gt;adder&lt;/code&gt; in &lt;em&gt;Cargo.lock&lt;/em&gt;, but no additional copies of &lt;code&gt;rand&lt;/code&gt; will be downloaded. Cargo has ensured that every crate in every package in the workspace using the &lt;code&gt;rand&lt;/code&gt; package will be using the same version. Using the same version of &lt;code&gt;rand&lt;/code&gt; across the workspace saves space because we won&amp;rsquo;t have multiple copies and ensures that the crates in the workspace will be compatible with each other.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9dd753bd45e01fa10b5929e59eda068f06c82e05" translate="yes" xml:space="preserve">
          <source>To fix this, either remove the outer reference:</source>
          <target state="translated">Чтобы это исправить,либо удалите внешнюю ссылку:</target>
        </trans-unit>
        <trans-unit id="cb0074c2565e11e981fa6efe9e6d5af9f075e607" translate="yes" xml:space="preserve">
          <source>To fix this, ensure that any declared variables are initialized before being used. Example:</source>
          <target state="translated">Чтобы исправить это,убедитесь,что все объявленные переменные инициализированы перед использованием.Пример:</target>
        </trans-unit>
        <trans-unit id="437601cd4925a7106ff21615c74bc484d85aef14" translate="yes" xml:space="preserve">
          <source>To fix this, ensure that the name was correctly spelled, and that the correct form of initializer was used.</source>
          <target state="translated">Чтобы это исправить,убедитесь,что имя было правильно написано,и что была использована правильная форма инициализатора.</target>
        </trans-unit>
        <trans-unit id="890f488bd89f18960203be014ab27fb39dfc6d22" translate="yes" xml:space="preserve">
          <source>To fix this, it is suggested to use a &lt;code&gt;where Self: Sized&lt;/code&gt; bound similar to the fix for the sub-error above if you do not intend to call the method with type parameters:</source>
          <target state="translated">Чтобы исправить это, предлагается использовать &lt;code&gt;where Self: Sized&lt;/code&gt; аналогичную исправлению для под-ошибки выше, если вы не собираетесь вызывать метод с параметрами типа:</target>
        </trans-unit>
        <trans-unit id="c7b0cc36b1cf18605167b9e261109b879dd0c485" translate="yes" xml:space="preserve">
          <source>To fix this, please set manually the next enum value or put the enum variant with the maximum value at the end of the enum. Examples:</source>
          <target state="translated">Для исправления этого,пожалуйста,установите вручную следующее значение перечисления или поставьте вариант перечисления с максимальным значением в конце перечисления.Примеры:</target>
        </trans-unit>
        <trans-unit id="fa4bb08fcba49cd98aef8848abbf20a6a3f3bfcb" translate="yes" xml:space="preserve">
          <source>To fix this, replace the generic parameter with the specializations that you need:</source>
          <target state="translated">Чтобы это исправить,замените общий параметр на нужные вам специализации:</target>
        </trans-unit>
        <trans-unit id="0f9e6f402abcaecb02615cbeb4f9eaf1b18503a7" translate="yes" xml:space="preserve">
          <source>To fix this, the value can be extracted as a const and then used:</source>
          <target state="translated">Чтобы это исправить,значение может быть извлечено как константа,а затем использовано:</target>
        </trans-unit>
        <trans-unit id="34e96f574d6d4b3f0139f4794453e1b644fdb7fa" translate="yes" xml:space="preserve">
          <source>To fix this, we implement &lt;code&gt;Display&lt;/code&gt; on &lt;code&gt;Point&lt;/code&gt; and satisfy the constraint that &lt;code&gt;OutlinePrint&lt;/code&gt; requires, like so:</source>
          <target state="translated">Чтобы исправить это, мы реализуем &lt;code&gt;Display&lt;/code&gt; on &lt;code&gt;Point&lt;/code&gt; и удовлетворяем ограничению, &lt;code&gt;OutlinePrint&lt;/code&gt; требует OutlinePrint , например:</target>
        </trans-unit>
        <trans-unit id="1afba8b0958bf7d54c00a1e357d6112f94820fbc" translate="yes" xml:space="preserve">
          <source>To fix this, you must reference the lifetime &lt;code&gt;'x&lt;/code&gt; from the return type. For example, changing the return type to &lt;code&gt;impl Trait&amp;lt;'y&amp;gt; + 'x&lt;/code&gt; would work:</source>
          <target state="translated">Чтобы исправить это, вы должны указать время жизни &lt;code&gt;'x&lt;/code&gt; ' из возвращаемого типа. Например, изменение типа возвращаемого значения на &lt;code&gt;impl Trait&amp;lt;'y&amp;gt; + 'x&lt;/code&gt; будет работать:</target>
        </trans-unit>
        <trans-unit id="7f876767b17c3198e0a111feeef857c2ed3d8806" translate="yes" xml:space="preserve">
          <source>To forcibly capture a backtrace regardless of environment variables, use the &lt;code&gt;Backtrace::force_capture&lt;/code&gt; function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b2c5b5034aa90905612a009b913793af12d3e3ac" translate="yes" xml:space="preserve">
          <source>To further refine the game&amp;rsquo;s behavior, rather than crashing the program when the user inputs a non-number, let&amp;rsquo;s make the game ignore a non-number so the user can continue guessing. We can do that by altering the line where &lt;code&gt;guess&lt;/code&gt; is converted from a &lt;code&gt;String&lt;/code&gt; to a &lt;code&gt;u32&lt;/code&gt;, as shown in Listing 2-5.</source>
          <target state="translated">Чтобы еще больше улучшить поведение игры, вместо того, чтобы приводить к сбою программы, когда пользователь вводит нечисловое значение, давайте заставим игру игнорировать нечисловое число, чтобы пользователь мог продолжать угадывать. Мы можем сделать это, изменив строку, в которой &lt;code&gt;guess&lt;/code&gt; преобразуется из &lt;code&gt;String&lt;/code&gt; в &lt;code&gt;u32&lt;/code&gt; , как показано в листинге 2-5.</target>
        </trans-unit>
        <trans-unit id="bea9207f63bde7916694d159ff6b4254f0892dc5" translate="yes" xml:space="preserve">
          <source>To get a mutable string slice instead, see the &lt;a href=&quot;#method.slice_mut_unchecked&quot;&gt;&lt;code&gt;slice_mut_unchecked&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">Чтобы вместо этого получить изменяемый строковый фрагмент, см. Метод &lt;a href=&quot;#method.slice_mut_unchecked&quot;&gt; &lt;code&gt;slice_mut_unchecked&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="baed129549ca4f37d13996fe220fb567ab069ac8" translate="yes" xml:space="preserve">
          <source>To get a mutable string slice instead, see the &lt;a href=&quot;../primitive.str#method.slice_mut_unchecked&quot;&gt;&lt;code&gt;slice_mut_unchecked&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8139e232eb226615d326fd45327940952c09f923" translate="yes" xml:space="preserve">
          <source>To get a mutable string slice instead, see the &lt;a href=&quot;primitive.str#method.slice_mut_unchecked&quot;&gt;&lt;code&gt;slice_mut_unchecked&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0238d96367a691acb632dbf4d73cc5fd2a706ad9" translate="yes" xml:space="preserve">
          <source>To get a pointer to a boxed value, dereference the box:</source>
          <target state="translated">Чтобы получить указатель на ячейку,разыменуйте ячейку:</target>
        </trans-unit>
        <trans-unit id="8f1e8a2f8899e777c3546c1b586cd81156849069" translate="yes" xml:space="preserve">
          <source>To get a specific value from a struct, we can use dot notation. If we wanted just this user&amp;rsquo;s email address, we could use &lt;code&gt;user1.email&lt;/code&gt; wherever we wanted to use this value. If the instance is mutable, we can change a value by using the dot notation and assigning into a particular field. Listing 5-3 shows how to change the value in the &lt;code&gt;email&lt;/code&gt; field of a mutable &lt;code&gt;User&lt;/code&gt; instance.</source>
          <target state="translated">Чтобы получить конкретное значение из структуры, мы можем использовать точечную нотацию. Если бы нам нужен был только адрес электронной почты этого пользователя, мы могли бы использовать &lt;code&gt;user1.email&lt;/code&gt; везде, где хотели бы использовать это значение. Если экземпляр является изменяемым, мы можем изменить значение, используя точечную нотацию и присвоение определенному полю. В листинге 5-3 показано, как изменить значение в поле &lt;code&gt;email&lt;/code&gt; изменяемого экземпляра &lt;code&gt;User&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ffd19be588eb8df1e329d2bc1905f6d517e8c370" translate="yes" xml:space="preserve">
          <source>To get an immutable string slice instead, see the &lt;a href=&quot;#method.slice_unchecked&quot;&gt;&lt;code&gt;slice_unchecked&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">Чтобы вместо этого получить неизменяемый строковый фрагмент, см. Метод &lt;a href=&quot;#method.slice_unchecked&quot;&gt; &lt;code&gt;slice_unchecked&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="4160b8923a79d4ccc00d36a66c387740f16ca557" translate="yes" xml:space="preserve">
          <source>To get an immutable string slice instead, see the &lt;a href=&quot;../primitive.str#method.slice_unchecked&quot;&gt;&lt;code&gt;slice_unchecked&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7ce6e3247525a78442e0ee3f76231a67e813fe82" translate="yes" xml:space="preserve">
          <source>To get an immutable string slice instead, see the &lt;a href=&quot;primitive.str#method.slice_unchecked&quot;&gt;&lt;code&gt;slice_unchecked&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="29270bb604499679be31005db9630fdff3a329f3" translate="yes" xml:space="preserve">
          <source>To get immutable string slices instead, see the &lt;a href=&quot;#method.split_at&quot;&gt;&lt;code&gt;split_at&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">Чтобы вместо этого получить неизменяемые фрагменты строки, см. Метод &lt;a href=&quot;#method.split_at&quot;&gt; &lt;code&gt;split_at&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="1773350f816d14b08d14b8fc6f4503505910e146" translate="yes" xml:space="preserve">
          <source>To get immutable string slices instead, see the &lt;a href=&quot;../primitive.str#method.split_at&quot;&gt;&lt;code&gt;split_at&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="130eb39bd47cd566af1912b3ccb9f5e133aeacd3" translate="yes" xml:space="preserve">
          <source>To get immutable string slices instead, see the &lt;a href=&quot;primitive.str#method.split_at&quot;&gt;&lt;code&gt;split_at&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d6bbcb0bb220df37e8c688ef821b8733765b09b5" translate="yes" xml:space="preserve">
          <source>To get mutable string slices instead, see the &lt;a href=&quot;#method.split_at_mut&quot;&gt;&lt;code&gt;split_at_mut&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">Чтобы вместо этого получить изменяемые фрагменты строки, см. Метод &lt;a href=&quot;#method.split_at_mut&quot;&gt; &lt;code&gt;split_at_mut&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="7b8786ffc3edfea977e5fb933b851cad79af05d7" translate="yes" xml:space="preserve">
          <source>To get mutable string slices instead, see the &lt;a href=&quot;../primitive.str#method.split_at_mut&quot;&gt;&lt;code&gt;split_at_mut&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="46f032d280d4b30ddfbcd15e779b494aafdce282" translate="yes" xml:space="preserve">
          <source>To get mutable string slices instead, see the &lt;a href=&quot;primitive.str#method.split_at_mut&quot;&gt;&lt;code&gt;split_at_mut&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2a0349cd0d37a5287741f4237e8c49df43c4e0c6" translate="yes" xml:space="preserve">
          <source>To get this out of the way: you should probably just use &lt;a href=&quot;../vec/struct.vec&quot;&gt;&lt;code&gt;Vec&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;struct.hashmap&quot;&gt;&lt;code&gt;HashMap&lt;/code&gt;&lt;/a&gt;. These two collections cover most use cases for generic data storage and processing. They are exceptionally good at doing what they do. All the other collections in the standard library have specific use cases where they are the optimal choice, but these cases are borderline &lt;em&gt;niche&lt;/em&gt; in comparison. Even when &lt;code&gt;Vec&lt;/code&gt; and &lt;code&gt;HashMap&lt;/code&gt; are technically suboptimal, they're probably a good enough choice to get started.</source>
          <target state="translated">Чтобы избежать этого: вам, вероятно, следует просто использовать &lt;a href=&quot;../vec/struct.vec&quot;&gt; &lt;code&gt;Vec&lt;/code&gt; &lt;/a&gt; или &lt;a href=&quot;struct.hashmap&quot;&gt; &lt;code&gt;HashMap&lt;/code&gt; &lt;/a&gt; . Эти две коллекции охватывают большинство вариантов использования для хранения и обработки общих данных. Они исключительно хороши в том, что делают. Все остальные коллекции в стандартной библиотеке имеют определенные варианты использования, в которых они являются оптимальным выбором, но по сравнению с ними эти случаи являются пограничной &lt;em&gt;нишей&lt;/em&gt; . Даже когда &lt;code&gt;Vec&lt;/code&gt; и &lt;code&gt;HashMap&lt;/code&gt; технически неоптимальны, они, вероятно, достаточно хороший выбор для начала.</target>
        </trans-unit>
        <trans-unit id="18773042303056fd8c79476f3616f355ff443a51" translate="yes" xml:space="preserve">
          <source>To handle the error case and print a user-friendly message, we need to update &lt;code&gt;main&lt;/code&gt; to handle the &lt;code&gt;Result&lt;/code&gt; being returned by &lt;code&gt;Config::new&lt;/code&gt;, as shown in Listing 12-10. We&amp;rsquo;ll also take the responsibility of exiting the command line tool with a nonzero error code from &lt;code&gt;panic!&lt;/code&gt; and implement it by hand. A nonzero exit status is a convention to signal to the process that called our program that the program exited with an error state.</source>
          <target state="translated">Чтобы обработать случай ошибки и напечатать удобное для пользователя сообщение, нам нужно обновить &lt;code&gt;main&lt;/code&gt; для обработки &lt;code&gt;Result&lt;/code&gt; , возвращаемого &lt;code&gt;Config::new&lt;/code&gt; , как показано в листинге 12-10. Мы также берем на себя ответственность выйти из инструмента командной строки с ненулевым кодом ошибки из &lt;code&gt;panic!&lt;/code&gt; и реализуем вручную. Ненулевой статус выхода - это соглашение, сигнализирующее процессу, вызвавшему нашу программу, о том, что программа завершилась с ошибкой.</target>
        </trans-unit>
        <trans-unit id="482ebf3be5fe8298225b2e8f09ccc5e7f7c51bf1" translate="yes" xml:space="preserve">
          <source>To help IDE integration, the Rust project distributes the &lt;em&gt;Rust Language Server&lt;/em&gt; (&lt;code&gt;rls&lt;/code&gt;). This tool speaks the &lt;a href=&quot;http://langserver.org/&quot;&gt;Language Server Protocol&lt;/a&gt;, which is a specification for IDEs and programming languages to communicate with each other. Different clients can use the &lt;code&gt;rls&lt;/code&gt;, such as &lt;a href=&quot;https://marketplace.visualstudio.com/items?itemName=rust-lang.rust&quot;&gt;the Rust plug-in for Visual Studio Code&lt;/a&gt;.</source>
          <target state="translated">Чтобы помочь интеграции IDE, проект Rust распространяет &lt;em&gt;Rust Language Server&lt;/em&gt; ( &lt;code&gt;rls&lt;/code&gt; ). Этот инструмент использует &lt;a href=&quot;http://langserver.org/&quot;&gt;протокол языкового сервера&lt;/a&gt; , который является спецификацией для IDE и языков программирования для взаимодействия друг с другом. Различные клиенты могут использовать &lt;code&gt;rls&lt;/code&gt; , например &lt;a href=&quot;https://marketplace.visualstudio.com/items?itemName=rust-lang.rust&quot;&gt;подключаемый модуль Rust для Visual Studio Code&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="20b8f11e3eb504aaf128f283d04500f6915052b5" translate="yes" xml:space="preserve">
          <source>To illustrate situations where closures that can capture their environment are useful as function parameters, let&amp;rsquo;s move on to our next topic: iterators.</source>
          <target state="translated">Чтобы проиллюстрировать ситуации, когда замыкания, которые могут захватывать свою среду, полезны в качестве параметров функции, давайте перейдем к нашей следующей теме: итераторам.</target>
        </trans-unit>
        <trans-unit id="6bb8bf87527987f23e438b1c1bc78391e818826e" translate="yes" xml:space="preserve">
          <source>To illustrate the rules of ownership, we need a data type that is more complex than the ones we covered in the &lt;a href=&quot;ch03-02-data-types#data-types&quot;&gt;&amp;ldquo;Data Types&amp;rdquo;&lt;/a&gt; section of Chapter 3. The types covered previously are all stored on the stack and popped off the stack when their scope is over, but we want to look at data that is stored on the heap and explore how Rust knows when to clean up that data.</source>
          <target state="translated">Чтобы проиллюстрировать правила владения, нам нужен более сложный тип данных, чем те, которые мы рассмотрели в разделе &lt;a href=&quot;ch03-02-data-types#data-types&quot;&gt;&amp;laquo;Типы данных&amp;raquo;&lt;/a&gt; главы 3. Типы, рассмотренные ранее, все хранятся в стеке и извлекаются из стека, когда их область видимости закончился, но мы хотим посмотреть на данные, которые хранятся в куче, и выяснить, как Rust знает, когда нужно очистить эти данные.</target>
        </trans-unit>
        <trans-unit id="60712450a97e23097bf6dbe8ed26e2265884e8b7" translate="yes" xml:space="preserve">
          <source>To implement the behavior we want &lt;code&gt;gui&lt;/code&gt; to have, we&amp;rsquo;ll define a trait named &lt;code&gt;Draw&lt;/code&gt; that will have one method named &lt;code&gt;draw&lt;/code&gt;. Then we can define a vector that takes a &lt;em&gt;trait object&lt;/em&gt;. A trait object points to both an instance of a type implementing our specified trait as well as a table used to look up trait methods on that type at runtime. We create a trait object by specifying some sort of pointer, such as a &lt;code&gt;&amp;amp;&lt;/code&gt; reference or a &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; smart pointer, then the &lt;code&gt;dyn&lt;/code&gt; keyword, and then specifying the relevant trait. (We&amp;rsquo;ll talk about the reason trait objects must use a pointer in Chapter 19 in the section &lt;a href=&quot;ch19-04-advanced-types#dynamically-sized-types-and-the-sized-trait&quot;&gt;&amp;ldquo;Dynamically Sized Types and the &lt;code&gt;Sized&lt;/code&gt; Trait.&amp;rdquo;&lt;/a&gt;) We can use trait objects in place of a generic or concrete type. Wherever we use a trait object, Rust&amp;rsquo;s type system will ensure at compile time that any value used in that context will implement the trait object&amp;rsquo;s trait. Consequently, we don&amp;rsquo;t need to know all the possible types at compile time.</source>
          <target state="translated">Чтобы реализовать поведение, которое мы хотим, чтобы &lt;code&gt;gui&lt;/code&gt; имел, мы определим трейт с именем &lt;code&gt;Draw&lt;/code&gt; , который будет иметь один метод с именем &lt;code&gt;draw&lt;/code&gt; . Затем мы можем определить вектор, который принимает &lt;em&gt;объект-признак&lt;/em&gt; . Объект признака указывает как на экземпляр типа, реализующего нашу указанную особенность, так и на таблицу, используемую для поиска методов признака этого типа во время выполнения. Мы создаем объект признака, указывая какой-то указатель, такой как &lt;code&gt;&amp;amp;&lt;/code&gt; ссылка или умный указатель &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; , затем ключевое слово &lt;code&gt;dyn&lt;/code&gt; и затем определяя соответствующий признак. (О причинах, по которым типажные объекты должны использовать указатель, мы поговорим в главе 19 в разделе &lt;a href=&quot;ch19-04-advanced-types#dynamically-sized-types-and-the-sized-trait&quot;&gt;&amp;laquo;Типы с динамическим размером и &lt;code&gt;Sized&lt;/code&gt; Черта.&quot; &lt;/a&gt;) Мы можем использовать типажные объекты вместо общего или конкретного типа. Везде, где мы используем объект-признак, система типов Rust гарантирует во время компиляции, что любое значение, используемое в этом контексте, будет реализовывать признак объекта-признака. Следовательно, нам не нужно знать все возможные типы во время компиляции.</target>
        </trans-unit>
        <trans-unit id="f5e8a5c28a454d1f90112a6c60c0f8aea2b5196d" translate="yes" xml:space="preserve">
          <source>To improve our program, we&amp;rsquo;ll fix four problems that have to do with the program&amp;rsquo;s structure and how it&amp;rsquo;s handling potential errors.</source>
          <target state="translated">Чтобы улучшить нашу программу, мы исправим четыре проблемы, которые связаны со структурой программы и тем, как она обрабатывает потенциальные ошибки.</target>
        </trans-unit>
        <trans-unit id="bf9b4462d1a02f4d70e5d13cf8540c79a5e14d1a" translate="yes" xml:space="preserve">
          <source>To incorporate the &lt;code&gt;Message&lt;/code&gt; enum, we need to change &lt;code&gt;Job&lt;/code&gt; to &lt;code&gt;Message&lt;/code&gt; in two places: the definition of &lt;code&gt;ThreadPool&lt;/code&gt; and the signature of &lt;code&gt;Worker::new&lt;/code&gt;. The &lt;code&gt;execute&lt;/code&gt; method of &lt;code&gt;ThreadPool&lt;/code&gt; needs to send jobs wrapped in the &lt;code&gt;Message::NewJob&lt;/code&gt; variant. Then, in &lt;code&gt;Worker::new&lt;/code&gt; where a &lt;code&gt;Message&lt;/code&gt; is received from the channel, the job will be processed if the &lt;code&gt;NewJob&lt;/code&gt; variant is received, and the thread will break out of the loop if the &lt;code&gt;Terminate&lt;/code&gt; variant is received.</source>
          <target state="translated">Чтобы включить перечисление &lt;code&gt;Message&lt;/code&gt; , нам нужно изменить &lt;code&gt;Job&lt;/code&gt; на &lt;code&gt;Message&lt;/code&gt; в двух местах: в определении &lt;code&gt;ThreadPool&lt;/code&gt; и в подписи &lt;code&gt;Worker::new&lt;/code&gt; . &lt;code&gt;execute&lt;/code&gt; метод &lt;code&gt;ThreadPool&lt;/code&gt; необходим для отправки заданий , завернутых в &lt;code&gt;Message::NewJob&lt;/code&gt; варианта. Затем в &lt;code&gt;Worker::new&lt;/code&gt; где &lt;code&gt;Message&lt;/code&gt; получено из канала, задание будет обработано, если &lt;code&gt;NewJob&lt;/code&gt; вариант NewJob , и поток выйдет из цикла, если получен вариант &lt;code&gt;Terminate&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0f9206704ddf29e2ebea715304ccfd9e3f3ba5f3" translate="yes" xml:space="preserve">
          <source>To install &lt;code&gt;rustfmt&lt;/code&gt;, enter the following:</source>
          <target state="translated">Чтобы установить &lt;code&gt;rustfmt&lt;/code&gt; , введите следующее:</target>
        </trans-unit>
        <trans-unit id="35fe5fa9574aed79cc4c533785f5e0d142e0e320" translate="yes" xml:space="preserve">
          <source>To install Clippy, enter the following:</source>
          <target state="translated">Чтобы установить Clippy,введите следующее:</target>
        </trans-unit>
        <trans-unit id="44d584ca391c2045c83ab8a58e67b2e401ab33be" translate="yes" xml:space="preserve">
          <source>To install the &lt;code&gt;rls&lt;/code&gt;, enter the following:</source>
          <target state="translated">Чтобы установить &lt;code&gt;rls&lt;/code&gt; , введите следующее:</target>
        </trans-unit>
        <trans-unit id="71a54c2518d0f86ead8ba016e32755cf1ca226ed" translate="yes" xml:space="preserve">
          <source>To interact with a &lt;code&gt;Formatter&lt;/code&gt;, you'll call various methods to change the various options related to formatting. For examples, please see the documentation of the methods defined on &lt;code&gt;Formatter&lt;/code&gt; below.</source>
          <target state="translated">Для взаимодействия с &lt;code&gt;Formatter&lt;/code&gt; вы вызовете различные методы, чтобы изменить различные параметры, связанные с форматированием. Примеры см. В документации методов, определенных в &lt;code&gt;Formatter&lt;/code&gt; ниже.</target>
        </trans-unit>
        <trans-unit id="b498caa788bb95865cf7ae29f319574a69dd854b" translate="yes" xml:space="preserve">
          <source>To isolate unsafe code as much as possible, it&amp;rsquo;s best to enclose unsafe code within a safe abstraction and provide a safe API, which we&amp;rsquo;ll discuss later in the chapter when we examine unsafe functions and methods. Parts of the standard library are implemented as safe abstractions over unsafe code that has been audited. Wrapping unsafe code in a safe abstraction prevents uses of &lt;code&gt;unsafe&lt;/code&gt; from leaking out into all the places that you or your users might want to use the functionality implemented with &lt;code&gt;unsafe&lt;/code&gt; code, because using a safe abstraction is safe.</source>
          <target state="translated">Чтобы максимально изолировать небезопасный код, лучше всего заключить небезопасный код в безопасную абстракцию и предоставить безопасный API, который мы обсудим позже в этой главе, когда мы исследуем небезопасные функции и методы. Части стандартной библиотеки реализованы как безопасные абстракции над небезопасным кодом, который прошел аудит. Обертывание небезопасного кода в безопасной абстракции препятствует использованию &lt;code&gt;unsafe&lt;/code&gt; от утечки во все места , которые вы или ваши пользователи могли бы хотеть , чтобы использовать функциональные возможности реализованы с &lt;code&gt;unsafe&lt;/code&gt; кодом, потому что с помощью безопасной абстракции является безопасным.</target>
        </trans-unit>
        <trans-unit id="a6753382b748af96b119a035edd05c7a836b948d" translate="yes" xml:space="preserve">
          <source>To learn about the other kinds of collections provided by the standard library, see &lt;a href=&quot;../std/collections/index&quot;&gt;the documentation&lt;/a&gt;.</source>
          <target state="translated">Чтобы узнать о других типах коллекций, предоставляемых стандартной библиотекой, см. &lt;a href=&quot;../std/collections/index&quot;&gt;Документацию&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="0dbbd03b2e667a7e6b225ed1de228878e32e5817" translate="yes" xml:space="preserve">
          <source>To learn more about allowing access, see the documentation for the &lt;a href=&quot;keyword.pub&quot;&gt;&lt;code&gt;pub&lt;/code&gt;&lt;/a&gt; keyword.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c2736d1e6ef2a3faad24038e53f6bde645f76d87" translate="yes" xml:space="preserve">
          <source>To lowercase ASCII characters in addition to non-ASCII characters, use &lt;a href=&quot;#method.to_lowercase&quot;&gt;&lt;code&gt;to_lowercase&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Чтобы строчные символы ASCII в дополнение к символам не-ASCII, используйте &lt;a href=&quot;#method.to_lowercase&quot;&gt; &lt;code&gt;to_lowercase&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="e94e0d4cfd63a504442f11c93df0afa614a2f0d4" translate="yes" xml:space="preserve">
          <source>To lowercase ASCII characters in addition to non-ASCII characters, use &lt;a href=&quot;../primitive.str#method.to_lowercase&quot;&gt;&lt;code&gt;str::to_lowercase&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Для строчных символов ASCII в дополнение к символам, отличным от ASCII, используйте &lt;a href=&quot;../primitive.str#method.to_lowercase&quot;&gt; &lt;code&gt;str::to_lowercase&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="63a5fbbc07007136d2c958a62c0c4ca27bbb449c" translate="yes" xml:space="preserve">
          <source>To lowercase ASCII characters in addition to non-ASCII characters, use &lt;a href=&quot;https://doc.rust-lang.org/nightly/std/primitive.str.html#method.to_lowercase&quot;&gt;&lt;code&gt;str::to_lowercase&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5ab2513e3de2d60d109900818fb2429fd91b99d2" translate="yes" xml:space="preserve">
          <source>To lowercase the value in-place, use &lt;a href=&quot;#method.make_ascii_lowercase&quot;&gt;&lt;code&gt;make_ascii_lowercase&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Чтобы &lt;a href=&quot;#method.make_ascii_lowercase&quot;&gt; &lt;code&gt;make_ascii_lowercase&lt;/code&gt; &lt;/a&gt; значение на месте, используйте make_ascii_lowercase .</target>
        </trans-unit>
        <trans-unit id="ef146744579c27e21ed699daf39b3a3250767c77" translate="yes" xml:space="preserve">
          <source>To lowercase the value in-place, use &lt;a href=&quot;#tymethod.make_ascii_lowercase&quot;&gt;&lt;code&gt;make_ascii_lowercase&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Чтобы &lt;a href=&quot;#tymethod.make_ascii_lowercase&quot;&gt; &lt;code&gt;make_ascii_lowercase&lt;/code&gt; &lt;/a&gt; значение на месте, используйте make_ascii_lowercase .</target>
        </trans-unit>
        <trans-unit id="67608258687aa72b226fb9d75937d3aa5583b343" translate="yes" xml:space="preserve">
          <source>To lowercase the value in-place, use &lt;a href=&quot;../primitive.str#method.make_ascii_lowercase&quot;&gt;&lt;code&gt;make_ascii_lowercase&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0c6481a0667301c8cf17a1fc74a4e7ea446e2ab9" translate="yes" xml:space="preserve">
          <source>To lowercase the value in-place, use &lt;a href=&quot;../primitive.u8#method.make_ascii_lowercase&quot;&gt;&lt;code&gt;make_ascii_lowercase&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6a33f76160389c879809056277f95cb426933c88" translate="yes" xml:space="preserve">
          <source>To lowercase the value in-place, use &lt;a href=&quot;primitive.str#method.make_ascii_lowercase&quot;&gt;&lt;code&gt;make_ascii_lowercase&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="13cfe6c801715fff699dce762afc98ca7e8ff1fa" translate="yes" xml:space="preserve">
          <source>To lowercase the value in-place, use &lt;a href=&quot;primitive.u8#method.make_ascii_lowercase&quot;&gt;&lt;code&gt;make_ascii_lowercase&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4a0549668b9dec3f8fe6cc76087d773d360d9c8f" translate="yes" xml:space="preserve">
          <source>To lowercase the value in-place, use &lt;a href=&quot;struct.osstr#method.make_ascii_lowercase&quot;&gt;&lt;code&gt;OsStr::make_ascii_lowercase&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dd861f60ceee6cd011393e0efbd8975fcac733a1" translate="yes" xml:space="preserve">
          <source>To lowercase the value in-place, use &lt;a href=&quot;trait.asciiext#tymethod.make_ascii_lowercase&quot;&gt;&lt;code&gt;make_ascii_lowercase&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="21e4a3f169edf0cfb32c3841ee2bea7479d1a5e1" translate="yes" xml:space="preserve">
          <source>To make a struct that holds a closure, we need to specify the type of the closure, because a struct definition needs to know the types of each of its fields. Each closure instance has its own unique anonymous type: that is, even if two closures have the same signature, their types are still considered different. To define structs, enums, or function parameters that use closures, we use generics and trait bounds, as we discussed in Chapter 10.</source>
          <target state="translated">Для того чтобы сделать структуру,удерживающую закрытие,нам необходимо указать тип закрытия,потому что определение структуры должно знать типы каждого из ее полей.Каждый экземпляр закрытия имеет свой уникальный анонимный тип:то есть,даже если два закрытия имеют одну и ту же сигнатуру,их типы все равно считаются разными.Для определения структур,перечислений или параметров функций,использующих замыкание,мы используем генерические и трейтовые границы,как мы обсуждали в главе 10.</target>
        </trans-unit>
        <trans-unit id="f551bbd5751f05a17c69a727dd31a7a20561b4f8" translate="yes" xml:space="preserve">
          <source>To make it valid, write the following:</source>
          <target state="translated">Чтобы сделать его действительным,напишите следующее:</target>
        </trans-unit>
        <trans-unit id="11b284dcb2ba4ceac9f02b253f7b17b9698ddf3b" translate="yes" xml:space="preserve">
          <source>To make struct &lt;code&gt;Bar&lt;/code&gt; only visible in module &lt;code&gt;foo&lt;/code&gt; the &lt;code&gt;in&lt;/code&gt; keyword should be used:</source>
          <target state="translated">Для того, чтобы структура &lt;code&gt;Bar&lt;/code&gt; отображается только в модуле &lt;code&gt;foo&lt;/code&gt; &lt;code&gt;in&lt;/code&gt; ключевом слове должно быть использовано:</target>
        </trans-unit>
        <trans-unit id="fc2021393a94974377e271f291f7d97ada3aa985" translate="yes" xml:space="preserve">
          <source>To make the child node aware of its parent, we need to add a &lt;code&gt;parent&lt;/code&gt; field to our &lt;code&gt;Node&lt;/code&gt; struct definition. The trouble is in deciding what the type of &lt;code&gt;parent&lt;/code&gt; should be. We know it can&amp;rsquo;t contain an &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt;, because that would create a reference cycle with &lt;code&gt;leaf.parent&lt;/code&gt; pointing to &lt;code&gt;branch&lt;/code&gt; and &lt;code&gt;branch.children&lt;/code&gt; pointing to &lt;code&gt;leaf&lt;/code&gt;, which would cause their &lt;code&gt;strong_count&lt;/code&gt; values to never be 0.</source>
          <target state="translated">Чтобы дочерний узел знал о своем родителе, нам нужно добавить &lt;code&gt;parent&lt;/code&gt; поле к нашему определению структуры &lt;code&gt;Node&lt;/code&gt; . Проблема в том, чтобы решить, каким должен быть &lt;code&gt;parent&lt;/code&gt; . Мы знаем, что он не может содержать &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; , потому что это создаст ссылочный цикл с &lt;code&gt;leaf.parent&lt;/code&gt; , указывающим на &lt;code&gt;branch&lt;/code&gt; и &lt;code&gt;branch.children&lt;/code&gt; , указывающим на &lt;code&gt;leaf&lt;/code&gt; , что приведет к тому, что их значения &lt;code&gt;strong_count&lt;/code&gt; никогда не будут равны 0.</target>
        </trans-unit>
        <trans-unit id="d22320c45b662fb11c8113dfcbe82f4c5091e1e8" translate="yes" xml:space="preserve">
          <source>To make this work, every element has pointers to its predecessor and successor in the list. Elements can only be added when they are pinned, because moving the elements around would invalidate the pointers. Moreover, the &lt;a href=&quot;../ops/trait.drop#tymethod.drop&quot;&gt;&lt;code&gt;Drop&lt;/code&gt;&lt;/a&gt; implementation of a linked list element will patch the pointers of its predecessor and successor to remove itself from the list.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b7b483d37995579653b3a66a999867efa81ab8f9" translate="yes" xml:space="preserve">
          <source>To make this work, every element has pointers to its predecessor and successor in the list. Elements can only be added when they are pinned, because moving the elements around would invalidate the pointers. Moreover, the &lt;code&gt;Drop&lt;/code&gt; implementation of a linked list element will patch the pointers of its predecessor and successor to remove itself from the list.</source>
          <target state="translated">Чтобы это работало, каждый элемент имеет указатели на своего предшественника и преемника в списке. Элементы могут быть добавлены только тогда, когда они закреплены, потому что перемещение элементов сделает указатели недействительными. Более того, реализация &lt;code&gt;Drop&lt;/code&gt; элемента связанного списка исправит указатели своего предшественника и преемника, чтобы удалить себя из списка.</target>
        </trans-unit>
        <trans-unit id="addd7b5a3eab2bcc498269d4b5030ddd2652429e" translate="yes" xml:space="preserve">
          <source>To many people, polymorphism is synonymous with inheritance. But it&amp;rsquo;s actually a more general concept that refers to code that can work with data of multiple types. For inheritance, those types are generally subclasses.</source>
          <target state="translated">Для многих полиморфизм является синонимом наследования. Но на самом деле это более общая концепция, относящаяся к коду, который может работать с данными нескольких типов. Для наследования эти типы обычно являются подклассами.</target>
        </trans-unit>
        <trans-unit id="e542c92de7f2ff8b0e65e4059a685882563b6c24" translate="yes" xml:space="preserve">
          <source>To measure elapsed time reliably, use &lt;a href=&quot;struct.instant&quot;&gt;&lt;code&gt;Instant&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c1808ba5fbc9308fb8282df842ce731348ff5abf" translate="yes" xml:space="preserve">
          <source>To model pointers to opaque types in FFI, until &lt;code&gt;extern type&lt;/code&gt; is stabilized, it is recommended to use a newtype wrapper around an empty byte array. See the &lt;a href=&quot;https://doc.rust-lang.org/nomicon/ffi.html#representing-opaque-structs&quot;&gt;Nomicon&lt;/a&gt; for details.</source>
          <target state="translated">Для моделирования указателей на непрозрачные типы в FFI, пока &lt;code&gt;extern type&lt;/code&gt; не стабилизируется, рекомендуется использовать оболочку newtype вокруг пустого байтового массива. Подробности см. В &lt;a href=&quot;https://doc.rust-lang.org/nomicon/ffi.html#representing-opaque-structs&quot;&gt;Nomicon&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="92f1c0826630a6e44e7c7249d92c4a26d91785e3" translate="yes" xml:space="preserve">
          <source>To obtain error description as a string, use &lt;code&gt;to_string()&lt;/code&gt;.</source>
          <target state="translated">Чтобы получить описание ошибки в виде строки, используйте &lt;code&gt;to_string()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0354419a51c55b7a4f425ab3291d7b635b1d30c9" translate="yes" xml:space="preserve">
          <source>To parameterize the types in the new function we&amp;rsquo;ll define, we need to name the type parameter, just as we do for the value parameters to a function. You can use any identifier as a type parameter name. But we&amp;rsquo;ll use &lt;code&gt;T&lt;/code&gt; because, by convention, parameter names in Rust are short, often just a letter, and Rust&amp;rsquo;s type-naming convention is CamelCase. Short for &amp;ldquo;type,&amp;rdquo; &lt;code&gt;T&lt;/code&gt; is the default choice of most Rust programmers.</source>
          <target state="translated">Чтобы параметризовать типы в новой функции, которую мы определим, нам нужно назвать параметр типа, как мы делаем это для параметров значения функции. В качестве имени параметра типа можно использовать любой идентификатор. Но мы будем использовать &lt;code&gt;T&lt;/code&gt; , потому что по соглашению имена параметров в Rust короткие, часто всего лишь буква, а соглашение об именах типов в Rust - CamelCase. Сокращенно от &amp;laquo;type&amp;raquo;, &lt;code&gt;T&lt;/code&gt; - это выбор по умолчанию большинства программистов на Rust.</target>
        </trans-unit>
        <trans-unit id="075fa626d389c13dd84df398e2b600267ba414fd" translate="yes" xml:space="preserve">
          <source>To parse a path, you can create a &lt;a href=&quot;struct.path&quot;&gt;&lt;code&gt;Path&lt;/code&gt;&lt;/a&gt; slice from a &lt;a href=&quot;../primitive.str&quot;&gt;&lt;code&gt;str&lt;/code&gt;&lt;/a&gt; slice and start asking questions:</source>
          <target state="translated">Чтобы проанализировать путь, вы можете создать срез &lt;a href=&quot;struct.path&quot;&gt; &lt;code&gt;Path&lt;/code&gt; &lt;/a&gt; из среза &lt;a href=&quot;../primitive.str&quot;&gt; &lt;code&gt;str&lt;/code&gt; &lt;/a&gt; и начать задавать вопросы:</target>
        </trans-unit>
        <trans-unit id="a91f9eb8a09ec43223d4a3a69ca02691cc9a5535" translate="yes" xml:space="preserve">
          <source>To parse a path, you can create a &lt;a href=&quot;struct.path&quot;&gt;&lt;code&gt;Path&lt;/code&gt;&lt;/a&gt; slice from a &lt;a href=&quot;https://doc.rust-lang.org/nightly/std/primitive.str.html&quot;&gt;&lt;code&gt;str&lt;/code&gt;&lt;/a&gt; slice and start asking questions:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f7f45d830d337ce8a4f493ea8b6014f97c0fb6eb" translate="yes" xml:space="preserve">
          <source>To pass a single argument see &lt;a href=&quot;#method.arg&quot;&gt;&lt;code&gt;arg&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Чтобы передать один аргумент, см. &lt;a href=&quot;#method.arg&quot;&gt; &lt;code&gt;arg&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="30a7bace681f793e8820181cf7574f94401b280d" translate="yes" xml:space="preserve">
          <source>To pass a single argument see &lt;a href=&quot;struct.command#method.arg&quot;&gt;&lt;code&gt;arg&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2f3d970a69fb7cac0396fffe3d7483eb856d59e9" translate="yes" xml:space="preserve">
          <source>To pass multiple arguments see &lt;a href=&quot;#method.args&quot;&gt;&lt;code&gt;args&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Чтобы передать несколько аргументов, см. &lt;a href=&quot;#method.args&quot;&gt; &lt;code&gt;args&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="f24e6cb8e923f8cee5441a6183ab318931f04cf1" translate="yes" xml:space="preserve">
          <source>To pass multiple arguments see &lt;a href=&quot;struct.command#method.args&quot;&gt;&lt;code&gt;args&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cdc2c49e6f2624612dfa9af5bb72c9d5988a62aa" translate="yes" xml:space="preserve">
          <source>To perform async recursion, the &lt;code&gt;async fn&lt;/code&gt; needs to be desugared such that the &lt;code&gt;Future&lt;/code&gt; is explicit in the return type:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="af6d76d570505ba666bcda7baecd5871dcf2d3a2" translate="yes" xml:space="preserve">
          <source>To prevent this scenario, we first put all of our &lt;code&gt;Terminate&lt;/code&gt; messages on the channel in one loop; then we join on all the threads in another loop. Each worker will stop receiving requests on the channel once it gets a terminate message. So, we can be sure that if we send the same number of terminate messages as there are workers, each worker will receive a terminate message before &lt;code&gt;join&lt;/code&gt; is called on its thread.</source>
          <target state="translated">Чтобы предотвратить этот сценарий, мы сначала помещаем все наши сообщения &lt;code&gt;Terminate&lt;/code&gt; в канал в один цикл; затем мы объединяем все потоки в другой цикл. Каждый рабочий перестанет получать запросы на канале, как только получит сообщение о завершении. Таким образом, мы можем быть уверены , что если мы посылаем такое же количество заканчивающихся сообщений, есть рабочие, каждый работник получит сообщение , прежде чем прекратить &lt;code&gt;join&lt;/code&gt; называется на своей нити.</target>
        </trans-unit>
        <trans-unit id="add5b6cf5a307a5e6af227f8cc2b7b101db763e7" translate="yes" xml:space="preserve">
          <source>To protect your program from this sort of vulnerability, if you try to read an element at an index that doesn&amp;rsquo;t exist, Rust will stop execution and refuse to continue. Let&amp;rsquo;s try it and see:</source>
          <target state="translated">Чтобы защитить вашу программу от такой уязвимости, если вы попытаетесь прочитать элемент по несуществующему индексу, Rust остановит выполнение и откажется продолжить. Попробуем и увидим:</target>
        </trans-unit>
        <trans-unit id="fb3ab9d085bae205d404a7ba202d1b27f55784c2" translate="yes" xml:space="preserve">
          <source>To recover from a poisoned mutex:</source>
          <target state="translated">Чтобы оправиться от отравленного мьютекса:</target>
        </trans-unit>
        <trans-unit id="e0f842e4093b64f03623cd49c1c17718cfbe95dc" translate="yes" xml:space="preserve">
          <source>To remove the internal organization from the public API, we can modify the &lt;code&gt;art&lt;/code&gt; crate code in Listing 14-3 to add &lt;code&gt;pub use&lt;/code&gt; statements to re-export the items at the top level, as shown in Listing 14-5:</source>
          <target state="translated">Чтобы удалить внутреннюю организацию из общедоступного API, мы можем изменить код &lt;code&gt;art&lt;/code&gt; ящика в Листинге 14-3, чтобы добавить операторы &lt;code&gt;pub use&lt;/code&gt; для повторного экспорта элементов на верхнем уровне, как показано в Листинге 14-5:</target>
        </trans-unit>
        <trans-unit id="5b0280b8819ec3479f9646e558c6310c8632f058" translate="yes" xml:space="preserve">
          <source>To resolve the ambiguity, the programmer may refer to their desired method or function using more specific paths, types, or traits.</source>
          <target state="translated">Для устранения неоднозначности,программист может обратиться к желаемому методу или функции,используя более специфические пути,типы или черты.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
