<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ru" datatype="htmlbody" original="rust">
    <body>
      <group id="rust">
        <trans-unit id="8c62b63ef24786f929500cd4f0e354183f51728d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Copy&lt;/code&gt; trait is rarely required; types that implement &lt;code&gt;Copy&lt;/code&gt; have optimizations available, meaning you don&amp;rsquo;t have to call &lt;code&gt;clone&lt;/code&gt;, which makes the code more concise.</source>
          <target state="translated">&lt;code&gt;Copy&lt;/code&gt; черт редко требуется; Для типов, реализующих &lt;code&gt;Copy&lt;/code&gt; , доступна оптимизация, то есть вам не нужно вызывать &lt;code&gt;clone&lt;/code&gt; , что делает код более лаконичным.</target>
        </trans-unit>
        <trans-unit id="19e60de5e2cec4f66ffc273d83b18ba133a29961" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Copy&lt;/code&gt; trait was implemented on a type which contains a field that doesn't implement the &lt;code&gt;Copy&lt;/code&gt; trait.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5bc1853088c8596ec738b63d0b306b0f2a10680d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Copy&lt;/code&gt; trait was implemented on a type which is neither a struct nor an enum.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="23cc8d6ab49e3b2451486ee83ff4fdc2f0dab312" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Copy&lt;/code&gt; trait was implemented on a type with a &lt;code&gt;Drop&lt;/code&gt; implementation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7a2c2f0333db2747594fc8c5736d8f8e947ab10e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Counter&lt;/code&gt; struct has one field named &lt;code&gt;count&lt;/code&gt;. This field holds a &lt;code&gt;u32&lt;/code&gt; value that will keep track of where we are in the process of iterating from 1 to 5. The &lt;code&gt;count&lt;/code&gt; field is private because we want the implementation of &lt;code&gt;Counter&lt;/code&gt; to manage its value. The &lt;code&gt;new&lt;/code&gt; function enforces the behavior of always starting new instances with a value of 0 in the &lt;code&gt;count&lt;/code&gt; field.</source>
          <target state="translated">В структуре &lt;code&gt;Counter&lt;/code&gt; есть одно поле с именем &lt;code&gt;count&lt;/code&gt; . Это поле содержит значение &lt;code&gt;u32&lt;/code&gt; , которое будет отслеживать, где мы находимся в процессе итерации от 1 до 5. Поле &lt;code&gt;count&lt;/code&gt; является частным, потому что мы хотим, чтобы реализация &lt;code&gt;Counter&lt;/code&gt; управляла его значением. &lt;code&gt;new&lt;/code&gt; функция усиливает поведение всегда начиная новые экземпляры со значением 0 в &lt;code&gt;count&lt;/code&gt; поля.</target>
        </trans-unit>
        <trans-unit id="e402bbce82e84dd539cf1e138daa2856a0613786" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Debug&lt;/code&gt; trait allows you to print instances of a type for debugging purposes, so you and other programmers using your type can inspect an instance at a particular point in a program&amp;rsquo;s execution.</source>
          <target state="translated">Свойство &lt;code&gt;Debug&lt;/code&gt; позволяет печатать экземпляры типа для целей отладки, чтобы вы и другие программисты, использующие ваш тип, могли проверять экземпляр в определенной точке выполнения программы.</target>
        </trans-unit>
        <trans-unit id="853b42f22ba0be46a6e5cd03ba34756814292e76" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Debug&lt;/code&gt; trait enables debug formatting in format strings, which you indicate by adding &lt;code&gt;:?&lt;/code&gt; within &lt;code&gt;{}&lt;/code&gt; placeholders.</source>
          <target state="translated">Свойство &lt;code&gt;Debug&lt;/code&gt; включает форматирование отладки в строках формата, которые вы указываете, добавляя &lt;code&gt;:?&lt;/code&gt; в пределах &lt;code&gt;{}&lt;/code&gt; заполнителей.</target>
        </trans-unit>
        <trans-unit id="6967ae462b0a2a18036d993e8418edd4a969bd40" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Debug&lt;/code&gt; trait is required, for example, in use of the &lt;code&gt;assert_eq!&lt;/code&gt; macro. This macro prints the values of instances given as arguments if the equality assertion fails so programmers can see why the two instances weren&amp;rsquo;t equal.</source>
          <target state="translated">&lt;code&gt;Debug&lt;/code&gt; черта не требуется, например, при использовании &lt;code&gt;assert_eq!&lt;/code&gt; макрос. Этот макрос печатает значения экземпляров, заданных в качестве аргументов, если утверждение равенства не выполняется, чтобы программисты могли понять, почему два экземпляра не были равны.</target>
        </trans-unit>
        <trans-unit id="aba43f90e22e0dfd98100913cb543e02752ca675" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Default::default&lt;/code&gt; function is commonly used in combination with the struct update syntax discussed in the &lt;a href=&quot;ch05-01-defining-structs#creating-instances-from-other-instances-with-struct-update-syntax&quot;&gt;&amp;ldquo;Creating Instances From Other Instances With Struct Update Syntax&amp;rdquo;&lt;/a&gt; section in Chapter 5. You can customize a few fields of a struct and then set and use a default value for the rest of the fields by using &lt;code&gt;..Default::default()&lt;/code&gt;.</source>
          <target state="translated">Функция &lt;code&gt;Default::default&lt;/code&gt; обычно используется в сочетании с синтаксисом обновления структуры, обсуждаемым в разделе &lt;a href=&quot;ch05-01-defining-structs#creating-instances-from-other-instances-with-struct-update-syntax&quot;&gt;&amp;laquo;Создание экземпляров из других экземпляров с синтаксисом обновления структуры&amp;raquo;&lt;/a&gt; в главе 5. Вы можете настроить несколько полей структуры, а затем установить и использовать значение по умолчанию для остальных полей с помощью &lt;code&gt;..Default::default()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4f7be30b5dee7044de3817ca4c87b66ab54682e4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Default&lt;/code&gt; cannot be derived on an enum for the simple reason that the compiler doesn't know which value to pick by default whereas it can for a struct as long as all its fields implement the &lt;code&gt;Default&lt;/code&gt; trait as well.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="155c03f436324748d5a47629042098342e63a6ce" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Default&lt;/code&gt; trait allows you to create a default value for a type. Deriving &lt;code&gt;Default&lt;/code&gt; implements the &lt;code&gt;default&lt;/code&gt; function. The derived implementation of the &lt;code&gt;default&lt;/code&gt; function calls the &lt;code&gt;default&lt;/code&gt; function on each part of the type, meaning all fields or values in the type must also implement &lt;code&gt;Default&lt;/code&gt; to derive &lt;code&gt;Default&lt;/code&gt;.</source>
          <target state="translated">Свойство &lt;code&gt;Default&lt;/code&gt; позволяет вам создать значение по умолчанию для типа. Получение значения по &lt;code&gt;Default&lt;/code&gt; реализует функцию по &lt;code&gt;default&lt;/code&gt; . Производная реализация функции по &lt;code&gt;default&lt;/code&gt; вызывает функцию по &lt;code&gt;default&lt;/code&gt; для каждой части типа, то есть все поля или значения в типе также должны реализовывать &lt;code&gt;Default&lt;/code&gt; для получения &lt;code&gt;Default&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="417d240e17ea189069372338520fb02d077b097b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Default&lt;/code&gt; trait for types which may have meaningful default values.</source>
          <target state="translated">Характеристика &lt;code&gt;Default&lt;/code&gt; для типов, которые могут иметь значимые значения по умолчанию.</target>
        </trans-unit>
        <trans-unit id="e9ffe8630d56067e177ef382279c1fa4ad4f3ea3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Default&lt;/code&gt; trait is required when you use the method &lt;code&gt;unwrap_or_default&lt;/code&gt; on &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt; instances, for example. If the &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt; is &lt;code&gt;None&lt;/code&gt;, the method &lt;code&gt;unwrap_or_default&lt;/code&gt; will return the result of &lt;code&gt;Default::default&lt;/code&gt; for the type &lt;code&gt;T&lt;/code&gt; stored in the &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Default&lt;/code&gt; черта требуется при использовании метода &lt;code&gt;unwrap_or_default&lt;/code&gt; на &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt; экземпляры, например. Если &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt; - &lt;code&gt;None&lt;/code&gt; , метод &lt;code&gt;unwrap_or_default&lt;/code&gt; вернет результат &lt;code&gt;Default::default&lt;/code&gt; для типа &lt;code&gt;T&lt;/code&gt; , хранящегося в &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="faec1eafc86ec050669e657d677254ae1cc5eb09" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Default&lt;/code&gt; trait was derived on an enum.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3bac5d0a36fa049d2b9d797796c56dde34fe6945" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;DispatchFromDyn&lt;/code&gt; trait currently can only be implemented for builtin pointer types and structs that are newtype wrappers around them &amp;mdash; that is, the struct must have only one field (except for&lt;code&gt;PhantomData&lt;/code&gt;), and that field must itself implement &lt;code&gt;DispatchFromDyn&lt;/code&gt;.</source>
          <target state="translated">В настоящее время черта &lt;code&gt;DispatchFromDyn&lt;/code&gt; может быть реализована только для типов встроенных указателей и структур, которые являются оболочками newtype вокруг них, то есть структура должна иметь только одно поле (кроме &lt;code&gt;PhantomData&lt;/code&gt; ), и это поле должно само реализовывать &lt;code&gt;DispatchFromDyn&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f4511d27b8bd2f5f7b72a8b815a18a15df561075" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;DispatchFromDyn&lt;/code&gt; trait was implemented on something which is not a pointer or a newtype wrapper around a pointer.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b6986e696b5a0b081bb4012a05eb9e1b65dcc35b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;DraftPost&lt;/code&gt; struct has an &lt;code&gt;add_text&lt;/code&gt; method, so we can add text to &lt;code&gt;content&lt;/code&gt; as before, but note that &lt;code&gt;DraftPost&lt;/code&gt; does not have a &lt;code&gt;content&lt;/code&gt; method defined! So now the program ensures all posts start as draft posts, and draft posts don&amp;rsquo;t have their content available for display. Any attempt to get around these constraints will result in a compiler error.</source>
          <target state="translated">Структура &lt;code&gt;DraftPost&lt;/code&gt; имеет метод &lt;code&gt;add_text&lt;/code&gt; , поэтому мы можем добавлять текст к &lt;code&gt;content&lt;/code&gt; как и раньше, но обратите внимание, что &lt;code&gt;DraftPost&lt;/code&gt; не имеет определенного метода &lt;code&gt;content&lt;/code&gt; ! Итак, теперь программа гарантирует, что все сообщения начинаются как черновики сообщений, а содержимое черновиков сообщений не доступно для отображения. Любая попытка обойти эти ограничения приведет к ошибке компилятора.</target>
        </trans-unit>
        <trans-unit id="b1de117663cb2f27f8306ea33629038001aac2df" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Drop&lt;/code&gt; trait is included in the prelude, so we don&amp;rsquo;t need to bring it into scope. We implement the &lt;code&gt;Drop&lt;/code&gt; trait on &lt;code&gt;CustomSmartPointer&lt;/code&gt; and provide an implementation for the &lt;code&gt;drop&lt;/code&gt; method that calls &lt;code&gt;println!&lt;/code&gt;. The body of the &lt;code&gt;drop&lt;/code&gt; function is where you would place any logic that you wanted to run when an instance of your type goes out of scope. We&amp;rsquo;re printing some text here to demonstrate when Rust will call &lt;code&gt;drop&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Drop&lt;/code&gt; черта входит в прелюдии, поэтому нам не нужно , чтобы привести его в рамки. Мы реализуем &lt;code&gt;CustomSmartPointer&lt;/code&gt; &lt;code&gt;Drop&lt;/code&gt; на CustomSmartPointer и предоставляем реализацию для метода &lt;code&gt;drop&lt;/code&gt; , который вызывает &lt;code&gt;println!&lt;/code&gt; . Тело функции &lt;code&gt;drop&lt;/code&gt; - это место, где вы должны разместить любую логику, которую хотите запустить, когда экземпляр вашего типа выходит за пределы области видимости. Мы печатаем здесь текст, чтобы продемонстрировать, когда Rust вызовет &lt;code&gt;drop&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a67a7efec93a37792cb31993e146b2f7a5f7bc09" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Eq&lt;/code&gt; trait has no methods. Its purpose is to signal that for every value of the annotated type, the value is equal to itself. The &lt;code&gt;Eq&lt;/code&gt; trait can only be applied to types that also implement &lt;code&gt;PartialEq&lt;/code&gt;, although not all types that implement &lt;code&gt;PartialEq&lt;/code&gt; can implement &lt;code&gt;Eq&lt;/code&gt;. One example of this is floating point number types: the implementation of floating point numbers states that two instances of the not-a-number (&lt;code&gt;NaN&lt;/code&gt;) value are not equal to each other.</source>
          <target state="translated">У трейта &lt;code&gt;Eq&lt;/code&gt; нет методов. Его цель - сообщить, что для каждого значения аннотированного типа значение равно самому себе. Свойство &lt;code&gt;Eq&lt;/code&gt; можно применять только к типам, которые также реализуют &lt;code&gt;PartialEq&lt;/code&gt; , хотя не все типы, реализующие &lt;code&gt;PartialEq&lt;/code&gt; , могут реализовать &lt;code&gt;Eq&lt;/code&gt; . Одним из примеров этого являются типы чисел с плавающей запятой: реализация чисел с плавающей запятой заявляет, что два экземпляра значения не числа ( &lt;code&gt;NaN&lt;/code&gt; ) не равны друг другу.</target>
        </trans-unit>
        <trans-unit id="339e508d8f9f4467a3c3de396b4c7c19141c661f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;F&lt;/code&gt; type parameter also has the trait bound &lt;code&gt;Send&lt;/code&gt; and the lifetime bound &lt;code&gt;'static&lt;/code&gt;, which are useful in our situation: we need &lt;code&gt;Send&lt;/code&gt; to transfer the closure from one thread to another and &lt;code&gt;'static&lt;/code&gt; because we don&amp;rsquo;t know how long the thread will take to execute. Let&amp;rsquo;s create an &lt;code&gt;execute&lt;/code&gt; method on &lt;code&gt;ThreadPool&lt;/code&gt; that will take a generic parameter of type &lt;code&gt;F&lt;/code&gt; with these bounds:</source>
          <target state="translated">Параметр типа &lt;code&gt;F&lt;/code&gt; также имеет привязку признака &lt;code&gt;Send&lt;/code&gt; и привязку времени жизни &lt;code&gt;'static&lt;/code&gt; , которые полезны в нашей ситуации: нам нужно &lt;code&gt;Send&lt;/code&gt; закрытие из одного потока в другой и &lt;code&gt;'static&lt;/code&gt; потому что мы не знаем, как долго поток будет взять на исполнение. Давайте создадим метод &lt;code&gt;execute&lt;/code&gt; в &lt;code&gt;ThreadPool&lt;/code&gt; , который будет принимать универсальный параметр типа &lt;code&gt;F&lt;/code&gt; с этими границами:</target>
        </trans-unit>
        <trans-unit id="44f286163600e21778b5e8ddc538f3f66c2c5215" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;F&lt;/code&gt; type parameter is the one we&amp;rsquo;re concerned with here; the &lt;code&gt;T&lt;/code&gt; type parameter is related to the return value, and we&amp;rsquo;re not concerned with that. We can see that &lt;code&gt;spawn&lt;/code&gt; uses &lt;code&gt;FnOnce&lt;/code&gt; as the trait bound on &lt;code&gt;F&lt;/code&gt;. This is probably what we want as well, because we&amp;rsquo;ll eventually pass the argument we get in &lt;code&gt;execute&lt;/code&gt; to &lt;code&gt;spawn&lt;/code&gt;. We can be further confident that &lt;code&gt;FnOnce&lt;/code&gt; is the trait we want to use because the thread for running a request will only execute that request&amp;rsquo;s closure one time, which matches the &lt;code&gt;Once&lt;/code&gt; in &lt;code&gt;FnOnce&lt;/code&gt;.</source>
          <target state="translated">Здесь нас интересует параметр типа &lt;code&gt;F&lt;/code&gt; ; &lt;code&gt;T&lt;/code&gt; параметр типа связан с возвращаемым значением, и мы не связаны с этим. Мы можем видеть , что &lt;code&gt;spawn&lt;/code&gt; использует &lt;code&gt;FnOnce&lt;/code&gt; в качестве признака , связанного на &lt;code&gt;F&lt;/code&gt; . Вероятно, это то, что мы хотим, потому что в конечном итоге мы передадим аргумент, который мы получаем в &lt;code&gt;execute&lt;/code&gt; , для &lt;code&gt;spawn&lt;/code&gt; . Мы также можем быть уверены, что &lt;code&gt;FnOnce&lt;/code&gt; - это черта, которую мы хотим использовать, потому что поток для выполнения запроса будет выполнять закрытие этого запроса только один раз, что соответствует &lt;code&gt;Once&lt;/code&gt; in &lt;code&gt;FnOnce&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2cc0c55739bb91f91d10f706c9cab70e100723e2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Fn&lt;/code&gt; traits are provided by the standard library. All closures implement at least one of the traits: &lt;code&gt;Fn&lt;/code&gt;, &lt;code&gt;FnMut&lt;/code&gt;, or &lt;code&gt;FnOnce&lt;/code&gt;. We&amp;rsquo;ll discuss the difference between these traits in the &lt;a href=&quot;#capturing-the-environment-with-closures&quot;&gt;&amp;ldquo;Capturing the Environment with Closures&amp;rdquo;&lt;/a&gt; section; in this example, we can use the &lt;code&gt;Fn&lt;/code&gt; trait.</source>
          <target state="translated">В &lt;code&gt;Fn&lt;/code&gt; черты обеспечиваются стандартной библиотекой. Все замыкания реализуют по крайней мере одну из черт: &lt;code&gt;Fn&lt;/code&gt; , &lt;code&gt;FnMut&lt;/code&gt; или &lt;code&gt;FnOnce&lt;/code&gt; . Мы обсудим разницу между этими чертами в разделе &lt;a href=&quot;#capturing-the-environment-with-closures&quot;&gt;&amp;laquo;Захват среды с помощью замыканий&amp;raquo;&lt;/a&gt; ; в этом примере мы можем использовать черту &lt;code&gt;Fn&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="851722264534e1910cdc1ef4f424b4a4414f9688" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;From&lt;/code&gt; is also very useful when performing error handling. When constructing a function that is capable of failing, the return type will generally be of the form &lt;code&gt;Result&amp;lt;T, E&amp;gt;&lt;/code&gt;. The &lt;code&gt;From&lt;/code&gt; trait simplifies error handling by allowing a function to return a single error type that encapsulate multiple error types. See the &quot;Examples&quot; section and &lt;a href=&quot;../../book/ch09-00-error-handling&quot;&gt;the book&lt;/a&gt; for more details.</source>
          <target state="translated">&lt;code&gt;From&lt;/code&gt; также очень полезен при выполнении обработки ошибок. При создании функции, способной дать сбой, тип возвращаемого значения обычно имеет вид &lt;code&gt;Result&amp;lt;T, E&amp;gt;&lt;/code&gt; . &lt;code&gt;From&lt;/code&gt; черта упрощает обработку ошибок, позволяя функции возвращать один тип ошибки , который инкапсулирует несколько типов ошибок. См. Раздел &amp;laquo;Примеры&amp;raquo; и &lt;a href=&quot;../../book/ch09-00-error-handling&quot;&gt;книгу&lt;/a&gt; для более подробной информации.</target>
        </trans-unit>
        <trans-unit id="924c96483cec1214b829647e918270a4c12cbe49" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;GeneratorState&lt;/code&gt; enum returned from this function indicates what state the generator is in upon returning. If the &lt;code&gt;Yielded&lt;/code&gt; variant is returned then the generator has reached a suspension point and a value has been yielded out. Generators in this state are available for resumption at a later point.</source>
          <target state="translated">&lt;code&gt;GeneratorState&lt;/code&gt; перечисление вернулся из этой функции указывает на то, в каком состоянии генератор находится в по возвращении. Если &lt;code&gt;Yielded&lt;/code&gt; вариант &amp;laquo; Урожайный&amp;raquo;, то генератор достиг точки приостановки и значение было выдано. Генераторы в этом состоянии доступны для возобновления позже.</target>
        </trans-unit>
        <trans-unit id="93144a0b07feb0dfc814fce370a7ec1878fc8518" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;GlobalAlloc&lt;/code&gt; trait is an &lt;code&gt;unsafe&lt;/code&gt; trait for a number of reasons, and implementors must ensure that they adhere to these contracts:</source>
          <target state="translated">&lt;code&gt;GlobalAlloc&lt;/code&gt; черта является &lt;code&gt;unsafe&lt;/code&gt; чертой для целого ряда причин, и реализаторы должны гарантировать , что они придерживаются этих договоров:</target>
        </trans-unit>
        <trans-unit id="ac746bf118e800d6204d1b9be35a781fccfa8fc0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Hash&lt;/code&gt; trait allows you to take an instance of a type of arbitrary size and map that instance to a value of fixed size using a hash function. Deriving &lt;code&gt;Hash&lt;/code&gt; implements the &lt;code&gt;hash&lt;/code&gt; method. The derived implementation of the &lt;code&gt;hash&lt;/code&gt; method combines the result of calling &lt;code&gt;hash&lt;/code&gt; on each of the parts of the type, meaning all fields or values must also implement &lt;code&gt;Hash&lt;/code&gt; to derive &lt;code&gt;Hash&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Hash&lt;/code&gt; черта позволяет взять экземпляр типа произвольного размера и сопоставить этот экземпляр до значения фиксированного размера с использованием хэш - функции. Получение &lt;code&gt;Hash&lt;/code&gt; реализует &lt;code&gt;hash&lt;/code&gt; метод. Производная реализация метода &lt;code&gt;hash&lt;/code&gt; объединяет результат вызова &lt;code&gt;hash&lt;/code&gt; для каждой из частей типа, что означает, что все поля или значения также должны реализовывать &lt;code&gt;Hash&lt;/code&gt; для получения &lt;code&gt;Hash&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="cc2c322c74118357f702bcbb43acd3519194cb4e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Iterator&lt;/code&gt; trait has a number of different methods with default implementations provided by the standard library; you can find out about these methods by looking in the standard library API documentation for the &lt;code&gt;Iterator&lt;/code&gt; trait. Some of these methods call the &lt;code&gt;next&lt;/code&gt; method in their definition, which is why you&amp;rsquo;re required to implement the &lt;code&gt;next&lt;/code&gt; method when implementing the &lt;code&gt;Iterator&lt;/code&gt; trait.</source>
          <target state="translated">У &lt;code&gt;Iterator&lt;/code&gt; есть несколько различных методов, реализация которых по умолчанию предоставляется стандартной библиотекой; вы можете узнать об этих методах, просмотрев документацию API стандартной библиотеки для &lt;code&gt;Iterator&lt;/code&gt; . Некоторые из этих методов вызывают &lt;code&gt;next&lt;/code&gt; метод в своем определении, поэтому вам необходимо реализовать &lt;code&gt;next&lt;/code&gt; метод при реализации трейта &lt;code&gt;Iterator&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d7674b68a4f6af8a05d48508e05e8b51cf5d1646" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Iterator&lt;/code&gt; trait only requires implementors to define one method: the &lt;code&gt;next&lt;/code&gt; method, which returns one item of the iterator at a time wrapped in &lt;code&gt;Some&lt;/code&gt; and, when iteration is over, returns &lt;code&gt;None&lt;/code&gt;.</source>
          <target state="translated">Для &lt;code&gt;Iterator&lt;/code&gt; требуется, чтобы разработчики определяли только один метод: метод &lt;code&gt;next&lt;/code&gt; , который возвращает один элемент итератора за раз, заключенный в &lt;code&gt;Some&lt;/code&gt; , и, когда итерация завершена, возвращает &lt;code&gt;None&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f9025083930c31cf7871ed20937306b52f26761a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;LinkedList&lt;/code&gt; allows pushing and popping elements at either end in constant time.</source>
          <target state="translated">&lt;code&gt;LinkedList&lt;/code&gt; позволяет нажимать и выскакивают элементы на обоих концах в постоянное время.</target>
        </trans-unit>
        <trans-unit id="4baf38aed9bf1ffe36a931bbfb0cb77e6aa0a43b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;LowerExp&lt;/code&gt; trait should format its output in scientific notation with a lower-case &lt;code&gt;e&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;LowerExp&lt;/code&gt; черта должна форматировать свой вывод в научной нотации с строчным &lt;code&gt;e&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="dc66d9062a365376bc4e9ff4cb202550c7cc32a7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;LowerHex&lt;/code&gt; trait should format its output as a number in hexadecimal, with &lt;code&gt;a&lt;/code&gt; through &lt;code&gt;f&lt;/code&gt; in lower case.</source>
          <target state="translated">&lt;code&gt;LowerHex&lt;/code&gt; черта должна форматировать свой выход как число в шестнадцатеричной системе , с через &lt;code&gt;f&lt;/code&gt; в нижнем регистре. &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="3b321c2a56af633f328bf4b8ba254ce361d7a954" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Octal&lt;/code&gt; trait should format its output as a number in base-8.</source>
          <target state="translated">Свойство &lt;code&gt;Octal&lt;/code&gt; должно форматировать свой вывод как число с основанием 8.</target>
        </trans-unit>
        <trans-unit id="eb10a578affd8a62e12f3ef265b344e167e3dcf6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt; enum is so useful that it&amp;rsquo;s even included in the prelude; you don&amp;rsquo;t need to bring it into scope explicitly. In addition, so are its variants: you can use &lt;code&gt;Some&lt;/code&gt; and &lt;code&gt;None&lt;/code&gt; directly without the &lt;code&gt;Option::&lt;/code&gt; prefix. The &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt; enum is still just a regular enum, and &lt;code&gt;Some(T)&lt;/code&gt; and &lt;code&gt;None&lt;/code&gt; are still variants of type &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt; перечисление настолько полезно , что он даже включен в прелюдии; вам не нужно явно вводить его в область видимости. Кроме того, таковы его варианты: вы можете использовать &lt;code&gt;Some&lt;/code&gt; и &lt;code&gt;None&lt;/code&gt; напрямую без префикса &lt;code&gt;Option::&lt;/code&gt; . &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt; перечисление еще только регулярные перечисления, а &lt;code&gt;Some(T)&lt;/code&gt; и &lt;code&gt;None&lt;/code&gt; еще варианты типа &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="757a8b38147115f7267a95ffaa6fac00dcad6a55" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Option&lt;/code&gt; type. See &lt;a href=&quot;index&quot;&gt;the module level documentation&lt;/a&gt; for more.</source>
          <target state="translated">Тип &lt;code&gt;Option&lt;/code&gt; . Дополнительную информацию см. &lt;a href=&quot;index&quot;&gt;В документации уровня модуля&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="6ec87aec96d36200bb49beb7ba67c5c626bb7aad" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Ord&lt;/code&gt; trait allows you to know that for any two values of the annotated type, a valid ordering will exist. The &lt;code&gt;Ord&lt;/code&gt; trait implements the &lt;code&gt;cmp&lt;/code&gt; method, which returns an &lt;code&gt;Ordering&lt;/code&gt; rather than an &lt;code&gt;Option&amp;lt;Ordering&amp;gt;&lt;/code&gt; because a valid ordering will always be possible. You can only apply the &lt;code&gt;Ord&lt;/code&gt; trait to types that also implement &lt;code&gt;PartialOrd&lt;/code&gt; and &lt;code&gt;Eq&lt;/code&gt; (and &lt;code&gt;Eq&lt;/code&gt; requires &lt;code&gt;PartialEq&lt;/code&gt;). When derived on structs and enums, &lt;code&gt;cmp&lt;/code&gt; behaves the same way as the derived implementation for &lt;code&gt;partial_cmp&lt;/code&gt; does with &lt;code&gt;PartialOrd&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Ord&lt;/code&gt; черта позволяет знать , что для любых двух значений аннотированного типа, действующий порядок будет существовать. &lt;code&gt;Ord&lt;/code&gt; черта реализует &lt;code&gt;cmp&lt;/code&gt; метод, который возвращает &lt;code&gt;Ordering&lt;/code&gt; , а не &lt;code&gt;Option&amp;lt;Ordering&amp;gt;&lt;/code&gt; , так как действительный заказ всегда будет возможно. &lt;code&gt;PartialOrd&lt;/code&gt; &lt;code&gt;Ord&lt;/code&gt; можно применять только к типам, которые также реализуют PartialOrd и &lt;code&gt;Eq&lt;/code&gt; (а &lt;code&gt;Eq&lt;/code&gt; требует &lt;code&gt;PartialEq&lt;/code&gt; ). Будучи производным от структур и перечислений, &lt;code&gt;cmp&lt;/code&gt; ведет себя так же, как производная реализация для &lt;code&gt;partial_cmp&lt;/code&gt; с &lt;code&gt;PartialOrd&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="711a8eb9ad73721345ff8b7d5d49057eb05ba2c2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Orphan Check&lt;/code&gt; states that every trait implementation must meet either of the following conditions:</source>
          <target state="translated">В &lt;code&gt;Orphan Check&lt;/code&gt; состояния , что каждая реализация черты должна соответствовать одному из следующих условий:</target>
        </trans-unit>
        <trans-unit id="c00d178bf6b2317cc12ea4871792b476ee2d6ac7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;PartialEq&lt;/code&gt; trait allows you to compare instances of a type to check for equality and enables use of the &lt;code&gt;==&lt;/code&gt; and &lt;code&gt;!=&lt;/code&gt; operators.</source>
          <target state="translated">&lt;code&gt;PartialEq&lt;/code&gt; черта позволяет сравнивать экземпляры типа для проверки равенства и разрешает использование &lt;code&gt;==&lt;/code&gt; и &lt;code&gt;!=&lt;/code&gt; Операторов.</target>
        </trans-unit>
        <trans-unit id="43e89dc3eb492904f3da074b02b2cf97b105430c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;PartialEq&lt;/code&gt; trait is required, for example, with the use of the &lt;code&gt;assert_eq!&lt;/code&gt; macro, which needs to be able to compare two instances of a type for equality.</source>
          <target state="translated">&lt;code&gt;PartialEq&lt;/code&gt; черта требуется, например, с использованием &lt;code&gt;assert_eq!&lt;/code&gt; макрос, который должен иметь возможность сравнивать два экземпляра типа на равенство.</target>
        </trans-unit>
        <trans-unit id="a3b5763e3772b503d126748c966660daf7b02e86" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;PartialOrd&lt;/code&gt; trait allows you to compare instances of a type for sorting purposes. A type that implements &lt;code&gt;PartialOrd&lt;/code&gt; can be used with the &lt;code&gt;&amp;lt;&lt;/code&gt;, &lt;code&gt;&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;=&lt;/code&gt;, and &lt;code&gt;&amp;gt;=&lt;/code&gt; operators. You can only apply the &lt;code&gt;PartialOrd&lt;/code&gt; trait to types that also implement &lt;code&gt;PartialEq&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;PartialOrd&lt;/code&gt; черта позволяет сравнивать экземпляры типа для сортировки целей. Тип, реализующий &lt;code&gt;PartialOrd&lt;/code&gt; , можно использовать с операторами &lt;code&gt;&amp;lt;&lt;/code&gt; , &lt;code&gt;&amp;gt;&lt;/code&gt; , &lt;code&gt;&amp;lt;=&lt;/code&gt; и &lt;code&gt;&amp;gt;=&lt;/code&gt; . &lt;code&gt;PartialOrd&lt;/code&gt; можно применять только к типам, которые также реализуют &lt;code&gt;PartialEq&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d44604638bc3e14fe0790aae9645322a35831c38" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;PartialOrd&lt;/code&gt; trait is required, for example, for the &lt;code&gt;gen_range&lt;/code&gt; method from the &lt;code&gt;rand&lt;/code&gt; crate that generates a random value in the range specified by a low value and a high value.</source>
          <target state="translated">&lt;code&gt;PartialOrd&lt;/code&gt; черта не требуется, например, для &lt;code&gt;gen_range&lt;/code&gt; метода из &lt;code&gt;rand&lt;/code&gt; ящика , который генерирует случайное значение в диапазоне , заданный низкое значением и высокой стоимостью.</target>
        </trans-unit>
        <trans-unit id="aa9b33d349ddf99a4aba8a405103bf7fb4c6e253" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Pointer&lt;/code&gt; trait should format its output as a memory location. This is commonly presented as hexadecimal.</source>
          <target state="translated">Свойство &lt;code&gt;Pointer&lt;/code&gt; должно форматировать свой вывод как ячейку памяти. Обычно это представляется в шестнадцатеричном формате.</target>
        </trans-unit>
        <trans-unit id="ab8bbad2b08fc48ec0e5ed2730d22da62501a267" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Range&lt;/code&gt;&lt;code&gt;start..end&lt;/code&gt; contains all values with &lt;code&gt;x &amp;gt;= start&lt;/code&gt; and &lt;code&gt;x &amp;lt; end&lt;/code&gt;. It is empty unless &lt;code&gt;start &amp;lt; end&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Range&lt;/code&gt; &lt;code&gt;start..end&lt;/code&gt; содержит все значения с &lt;code&gt;x &amp;gt;= start&lt;/code&gt; и &lt;code&gt;x &amp;lt; end&lt;/code&gt; . Он пуст, если только &lt;code&gt;start &amp;lt; end&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b2aa0761be84214baf72bdc665e4aaa54d88ab96" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;RangeFrom&lt;/code&gt;&lt;code&gt;start..&lt;/code&gt; contains all values with &lt;code&gt;x &amp;gt;= start&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;RangeFrom&lt;/code&gt; &lt;code&gt;start..&lt;/code&gt; содержит все значения с &lt;code&gt;x &amp;gt;= start&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="73c149dd90366bce823890f694cf867f1bb0a225" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;RangeInclusive&lt;/code&gt;&lt;code&gt;start..=end&lt;/code&gt; contains all values with &lt;code&gt;x &amp;gt;= start&lt;/code&gt; and &lt;code&gt;x &amp;lt;= end&lt;/code&gt;. It is empty unless &lt;code&gt;start &amp;lt;= end&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;RangeInclusive&lt;/code&gt; &lt;code&gt;start..=end&lt;/code&gt; содержит все значения с &lt;code&gt;x &amp;gt;= start&lt;/code&gt; и &lt;code&gt;x &amp;lt;= end&lt;/code&gt; . Он пуст, если только &lt;code&gt;start &amp;lt;= end&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0cec61b7c44a745e689ab10fff029089cd54c5d0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;RangeTo&lt;/code&gt;&lt;code&gt;..end&lt;/code&gt; contains all values with &lt;code&gt;x &amp;lt; end&lt;/code&gt;. It cannot serve as an &lt;a href=&quot;../iter/trait.intoiterator&quot;&gt;&lt;code&gt;Iterator&lt;/code&gt;&lt;/a&gt; because it doesn't have a starting point.</source>
          <target state="translated">&lt;code&gt;RangeTo&lt;/code&gt; &lt;code&gt;..end&lt;/code&gt; содержит все значения с &lt;code&gt;x &amp;lt; end&lt;/code&gt; . Он не может служить &lt;a href=&quot;../iter/trait.intoiterator&quot;&gt; &lt;code&gt;Iterator&lt;/code&gt; &lt;/a&gt; потому что у него нет отправной точки.</target>
        </trans-unit>
        <trans-unit id="0de78a1c773797166ef937a052ccd5e9331c867f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;RangeTo&lt;/code&gt;&lt;code&gt;..end&lt;/code&gt; contains all values with &lt;code&gt;x &amp;lt; end&lt;/code&gt;. It cannot serve as an &lt;a href=&quot;../iter/trait.iterator&quot;&gt;&lt;code&gt;Iterator&lt;/code&gt;&lt;/a&gt; because it doesn't have a starting point.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8e2d4326e8450b1f620c09e80702de680708776b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;RangeToInclusive&lt;/code&gt;&lt;code&gt;..=end&lt;/code&gt; contains all values with &lt;code&gt;x &amp;lt;= end&lt;/code&gt;. It cannot serve as an &lt;a href=&quot;../iter/trait.intoiterator&quot;&gt;&lt;code&gt;Iterator&lt;/code&gt;&lt;/a&gt; because it doesn't have a starting point.</source>
          <target state="translated">&lt;code&gt;RangeToInclusive&lt;/code&gt; &lt;code&gt;..=end&lt;/code&gt; содержит все значения с &lt;code&gt;x &amp;lt;= end&lt;/code&gt; . Он не может служить &lt;a href=&quot;../iter/trait.intoiterator&quot;&gt; &lt;code&gt;Iterator&lt;/code&gt; &lt;/a&gt; потому что у него нет отправной точки.</target>
        </trans-unit>
        <trans-unit id="0729997e88bb0119e0af233dfbcdefc61396cf4d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;RangeToInclusive&lt;/code&gt;&lt;code&gt;..=end&lt;/code&gt; contains all values with &lt;code&gt;x &amp;lt;= end&lt;/code&gt;. It cannot serve as an &lt;a href=&quot;../iter/trait.iterator&quot;&gt;&lt;code&gt;Iterator&lt;/code&gt;&lt;/a&gt; because it doesn't have a starting point.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ebdc80637c460a3fe51040149db057ee546f653a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Rc::clone(&amp;amp;from)&lt;/code&gt; syntax is the most idiomatic because it conveys more explicitly the meaning of the code. In the example above, this syntax makes it easier to see that this code is creating a new reference rather than copying the whole content of foo.</source>
          <target state="translated">&lt;code&gt;Rc::clone(&amp;amp;from)&lt;/code&gt; синтаксис наиболее идиоматических , поскольку она передает более явно значение кода. В приведенном выше примере этот синтаксис помогает увидеть, что этот код создает новую ссылку, а не копирует все содержимое foo.</target>
        </trans-unit>
        <trans-unit id="d18566a4555f118c35b2f7296c41294a80e62f05" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Read&lt;/code&gt; trait allows for reading bytes from a source.</source>
          <target state="translated">&lt;code&gt;Read&lt;/code&gt; черта позволяет для чтения байтов из источника.</target>
        </trans-unit>
        <trans-unit id="167de79249a0cb690644cc2f30f26fd674ac84c4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt; keeps track of how many &lt;code&gt;Ref&amp;lt;T&amp;gt;&lt;/code&gt; and &lt;code&gt;RefMut&amp;lt;T&amp;gt;&lt;/code&gt; smart pointers are currently active. Every time we call &lt;code&gt;borrow&lt;/code&gt;, the &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt; increases its count of how many immutable borrows are active. When a &lt;code&gt;Ref&amp;lt;T&amp;gt;&lt;/code&gt; value goes out of scope, the count of immutable borrows goes down by one. Just like the compile-time borrowing rules, &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt; lets us have many immutable borrows or one mutable borrow at any point in time.</source>
          <target state="translated">&lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt; отслеживает , сколько &lt;code&gt;Ref&amp;lt;T&amp;gt;&lt;/code&gt; и &lt;code&gt;RefMut&amp;lt;T&amp;gt;&lt;/code&gt; смарт - указатели в настоящее время активны. Каждый раз, когда мы вызываем &lt;code&gt;borrow&lt;/code&gt; , &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt; увеличивает количество активных неизменяемых заимствований. Когда значение &lt;code&gt;Ref&amp;lt;T&amp;gt;&lt;/code&gt; выходит за пределы области видимости, количество неизменяемых заимствований уменьшается на единицу. Как и правила заимствования во время компиляции, &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt; позволяет нам иметь множество неизменяемых заимствований или одно изменяемое заимствование в любой момент времени.</target>
        </trans-unit>
        <trans-unit id="2e6771afd6b14e03fc38f6d16106ee1f97bd4cbd" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;RefCell&lt;/code&gt; is already immutably borrowed, so this cannot fail.</source>
          <target state="translated">&lt;code&gt;RefCell&lt;/code&gt; уже непреложно заимствованные, так что это не может потерпеть неудачу.</target>
        </trans-unit>
        <trans-unit id="c305974ea6149ae71e2c43fcd219e993594dd96e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;RefCell&lt;/code&gt; is already mutably borrowed, so this cannot fail.</source>
          <target state="translated">&lt;code&gt;RefCell&lt;/code&gt; уже mutably заимствованные, так что это не может потерпеть неудачу.</target>
        </trans-unit>
        <trans-unit id="52b1edfc20b8e3433cc429a2a34dab08626e2ce2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Result&amp;lt;..., Error&amp;gt;&lt;/code&gt; is repeated a lot. As such, &lt;code&gt;std::io&lt;/code&gt; has this type of alias declaration:</source>
          <target state="translated">&lt;code&gt;Result&amp;lt;..., Error&amp;gt;&lt;/code&gt; повторяется много. Таким образом, &lt;code&gt;std::io&lt;/code&gt; имеет такой тип объявления псевдонима:</target>
        </trans-unit>
        <trans-unit id="1e71572578c618ddeccc701e84d14574b4552896" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Result&lt;/code&gt; enum is generic over two types, &lt;code&gt;T&lt;/code&gt; and &lt;code&gt;E&lt;/code&gt;, and has two variants: &lt;code&gt;Ok&lt;/code&gt;, which holds a value of type &lt;code&gt;T&lt;/code&gt;, and &lt;code&gt;Err&lt;/code&gt;, which holds a value of type &lt;code&gt;E&lt;/code&gt;. This definition makes it convenient to use the &lt;code&gt;Result&lt;/code&gt; enum anywhere we have an operation that might succeed (return a value of some type &lt;code&gt;T&lt;/code&gt;) or fail (return an error of some type &lt;code&gt;E&lt;/code&gt;). In fact, this is what we used to open a file in Listing 9-3, where &lt;code&gt;T&lt;/code&gt; was filled in with the type &lt;code&gt;std::fs::File&lt;/code&gt; when the file was opened successfully and &lt;code&gt;E&lt;/code&gt; was filled in with the type &lt;code&gt;std::io::Error&lt;/code&gt; when there were problems opening the file.</source>
          <target state="translated">&lt;code&gt;Result&lt;/code&gt; перечисление является общим более двумя типов, &lt;code&gt;T&lt;/code&gt; и &lt;code&gt;E&lt;/code&gt; , и имеет два варианта: &lt;code&gt;Ok&lt;/code&gt; , который содержит значение типа &lt;code&gt;T&lt;/code&gt; , и &lt;code&gt;Err&lt;/code&gt; , который содержит значение типа &lt;code&gt;E&lt;/code&gt; . Это определение позволяет использовать перечисление &lt;code&gt;Result&lt;/code&gt; везде, где есть операция, которая может завершиться успешно (вернуть значение некоторого типа &lt;code&gt;T&lt;/code&gt; ) или потерпеть неудачу (вернуть ошибку некоторого типа &lt;code&gt;E&lt;/code&gt; ). Фактически, это то, что мы использовали для открытия файла в листинге 9-3, где &lt;code&gt;T&lt;/code&gt; был заполнен типом &lt;code&gt;std::fs::File&lt;/code&gt; когда файл был успешно открыт, а &lt;code&gt;E&lt;/code&gt; был заполнен типом &lt;code&gt;std::io::Error&lt;/code&gt; когда возникали проблемы с открытием файла.</target>
        </trans-unit>
        <trans-unit id="67d17ec2155cc71f4cbd159b4631b04d17855080" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Result&lt;/code&gt; types are &lt;a href=&quot;ch06-00-enums&quot;&gt;&lt;em&gt;enumerations&lt;/em&gt;&lt;/a&gt;, often referred to as &lt;em&gt;enums&lt;/em&gt;. An enumeration is a type that can have a fixed set of values, and those values are called the enum&amp;rsquo;s &lt;em&gt;variants&lt;/em&gt;. Chapter 6 will cover enums in more detail.</source>
          <target state="translated">В &lt;code&gt;Result&lt;/code&gt; типов &lt;a href=&quot;ch06-00-enums&quot;&gt;&lt;em&gt;перечисления&lt;/em&gt;&lt;/a&gt; , которые часто называют &lt;em&gt;перечислениями&lt;/em&gt; . Перечисление - это тип, который может иметь фиксированный набор значений, и эти значения называются &lt;em&gt;вариантами&lt;/em&gt; перечисления . В главе 6 перечисления рассматриваются более подробно.</target>
        </trans-unit>
        <trans-unit id="64d4c779a9a53da0609d26369514238e751f0a8e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Seek&lt;/code&gt; trait provides a cursor which can be moved within a stream of bytes.</source>
          <target state="translated">Свойство &lt;code&gt;Seek&lt;/code&gt; предоставляет курсор, который можно перемещать в потоке байтов.</target>
        </trans-unit>
        <trans-unit id="45132395a8da1a9af17f15db9b29d073d0c74c5d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Self&lt;/code&gt; keyword is an alias for the type we&amp;rsquo;re implementing the traits or methods on. Trait objects must be object safe because once you&amp;rsquo;ve used a trait object, Rust no longer knows the concrete type that&amp;rsquo;s implementing that trait. If a trait method returns the concrete &lt;code&gt;Self&lt;/code&gt; type, but a trait object forgets the exact type that &lt;code&gt;Self&lt;/code&gt; is, there is no way the method can use the original concrete type. The same is true of generic type parameters that are filled in with concrete type parameters when the trait is used: the concrete types become part of the type that implements the trait. When the type is forgotten through the use of a trait object, there is no way to know what types to fill in the generic type parameters with.</source>
          <target state="translated">&lt;code&gt;Self&lt;/code&gt; ключевое слово является псевдонимом типа мы реализующей черты или методы на. Объекты-черты должны быть объектно-безопасными, потому что после того, как вы использовали объект-черту, Rust больше не знает конкретный тип, реализующий эту черту. Если метод признака возвращает конкретный тип &lt;code&gt;Self&lt;/code&gt; , но объект признака забывает точный тип, которым является &lt;code&gt;Self&lt;/code&gt; , метод не может использовать исходный конкретный тип. То же самое верно для параметров универсального типа, которые заполняются параметрами конкретного типа при использовании признака: конкретные типы становятся частью типа, реализующего признак. Когда тип забывается из-за использования объекта-признака, невозможно узнать, какими типами заполнять параметры универсального типа.</target>
        </trans-unit>
        <trans-unit id="90a76b71efb75f391d26231783f81feb6c797a7f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Self&lt;/code&gt; keyword represents the current type, which explains why it can only be used inside an impl, trait, or type definition. It gives access to the associated items of a type:</source>
          <target state="translated">&lt;code&gt;Self&lt;/code&gt; ключевое слово представляет текущий тип, который объясняет , почему он может быть использован только внутри осущий, признак или определений типа. Он дает доступ к связанным элементам типа:</target>
        </trans-unit>
        <trans-unit id="a02332e854d71300403fa93482ff8605d97eadb6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Self&lt;/code&gt; keyword was used outside an impl, trait, or type definition.</source>
          <target state="translated">&lt;code&gt;Self&lt;/code&gt; ключевое слово использовалось за пределами осущ, признака или определения типа.</target>
        </trans-unit>
        <trans-unit id="6a3c6ecd1deb9539342b4b667c8f7da5207114d0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Self&lt;/code&gt; term can be replaced with the type being implemented.</source>
          <target state="translated">&lt;code&gt;Self&lt;/code&gt; термин может быть заменен на тип реализуется.</target>
        </trans-unit>
        <trans-unit id="268068ec98ee8d589f1d0d25a4fa87cb52fefae1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Self&lt;/code&gt; terminal in this grammar denotes a type resolving to the implementing type. This can also include the contextual type alias &lt;code&gt;Self&lt;/code&gt;, other type aliases, or associated type projections resolving to the implementing type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5d50619fe26b234beecf764a55ec164440b77b3f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Send&lt;/code&gt; marker trait indicates that ownership of the type implementing &lt;code&gt;Send&lt;/code&gt; can be transferred between threads. Almost every Rust type is &lt;code&gt;Send&lt;/code&gt;, but there are some exceptions, including &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt;: this cannot be &lt;code&gt;Send&lt;/code&gt; because if you cloned an &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; value and tried to transfer ownership of the clone to another thread, both threads might update the reference count at the same time. For this reason, &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; is implemented for use in single-threaded situations where you don&amp;rsquo;t want to pay the thread-safe performance penalty.</source>
          <target state="translated">Характеристика маркера &lt;code&gt;Send&lt;/code&gt; указывает, что владение типом, реализующим &lt;code&gt;Send&lt;/code&gt; может передаваться между потоками. Почти каждый тип Rust - это &lt;code&gt;Send&lt;/code&gt; , но есть некоторые исключения, в том числе &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; : это не может быть &lt;code&gt;Send&lt;/code&gt; , потому что если вы клонировали значение &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; и попытались передать право собственности на клон другому потоку, оба потока могут обновить количество ссылок одновременно. По этой причине &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; реализован для использования в однопоточных ситуациях, когда вы не хотите платить за поточно-безопасную производительность.</target>
        </trans-unit>
        <trans-unit id="da7504f8cf4ba12a9f166abe295fe49d0cc29f7f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Sized&lt;/code&gt; trait is a special trait built-in to the compiler for types with a constant size known at compile-time. This trait is automatically implemented for types as needed by the compiler, and it is currently disallowed to explicitly implement it for a type.</source>
          <target state="translated">&lt;code&gt;Sized&lt;/code&gt; черта является особой чертой , встроенной в компилятор для типов с постоянным размером , известным во время компиляции. Эта черта автоматически реализуется для типов по мере необходимости компилятора, и в настоящее время запрещено явно реализовывать ее для типа.</target>
        </trans-unit>
        <trans-unit id="faed9283b4f09789ea3439cf47c62be8b01765b4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Sized&lt;/code&gt; trait was implemented explicitly.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="57ed07b6ec3a8248f3dbedbfe819f564dab9a89c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Some(5)&lt;/code&gt; value doesn&amp;rsquo;t match the pattern &lt;code&gt;None&lt;/code&gt;, so we continue to the next arm.</source>
          <target state="translated">Значение &lt;code&gt;Some(5)&lt;/code&gt; не соответствует шаблону &lt;code&gt;None&lt;/code&gt; , поэтому мы переходим к следующей руке.</target>
        </trans-unit>
        <trans-unit id="5cf7d1bcd1b02d8684f384aeb150bd3c1fada36f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;State&lt;/code&gt; trait defines the behavior shared by different post states, and the &lt;code&gt;Draft&lt;/code&gt;, &lt;code&gt;PendingReview&lt;/code&gt;, and &lt;code&gt;Published&lt;/code&gt; states will all implement the &lt;code&gt;State&lt;/code&gt; trait. For now, the trait doesn&amp;rsquo;t have any methods, and we&amp;rsquo;ll start by defining just the &lt;code&gt;Draft&lt;/code&gt; state because that is the state we want a post to start in.</source>
          <target state="translated">&lt;code&gt;State&lt;/code&gt; черт определяет поведение совместно различными почтовые государствами, и &lt;code&gt;Draft&lt;/code&gt; , &lt;code&gt;PendingReview&lt;/code&gt; и &lt;code&gt;Published&lt;/code&gt; государства будут все реализовать &lt;code&gt;State&lt;/code&gt; черту. На данный момент у трейта нет никаких методов, и мы начнем с определения только состояния &lt;code&gt;Draft&lt;/code&gt; , потому что это состояние, в котором мы хотим, чтобы публикация начиналась.</target>
        </trans-unit>
        <trans-unit id="a99c80ac2ff235e2978574f670cbd4660bb61703" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;String&lt;/code&gt; type implements the &lt;code&gt;Clone&lt;/code&gt; trait, and when we call the &lt;code&gt;clone&lt;/code&gt; method on an instance of &lt;code&gt;String&lt;/code&gt; we get back an instance of &lt;code&gt;String&lt;/code&gt;. Similarly, if we call &lt;code&gt;clone&lt;/code&gt; on an instance of &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt;, we get back an instance of &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt;. The signature of &lt;code&gt;clone&lt;/code&gt; needs to know what type will stand in for &lt;code&gt;Self&lt;/code&gt;, because that&amp;rsquo;s the return type.</source>
          <target state="translated">Тип &lt;code&gt;String&lt;/code&gt; реализует черту &lt;code&gt;Clone&lt;/code&gt; , и когда мы вызываем метод &lt;code&gt;clone&lt;/code&gt; для экземпляра &lt;code&gt;String&lt;/code&gt; , мы получаем обратно экземпляр &lt;code&gt;String&lt;/code&gt; . Точно так же, если мы вызываем &lt;code&gt;clone&lt;/code&gt; для экземпляра &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; , мы возвращаем экземпляр &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; . Сигнатура &lt;code&gt;clone&lt;/code&gt; должна знать, какой тип будет заменять &lt;code&gt;Self&lt;/code&gt; , потому что это тип возвращаемого значения.</target>
        </trans-unit>
        <trans-unit id="ce3a0f98cdb5c97fe7ff53bab286ef96b0a0614f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;String&lt;/code&gt; type is the most common string type that has ownership over the contents of the string. It has a close relationship with its borrowed counterpart, the primitive &lt;a href=&quot;../primitive.str&quot;&gt;&lt;code&gt;str&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Тип &lt;code&gt;String&lt;/code&gt; является наиболее распространенным типом строки, который владеет содержимым строки. Он имеет тесную связь со своим заимствованным аналогом, примитивной &lt;a href=&quot;../primitive.str&quot;&gt; &lt;code&gt;str&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="75cb7ba1e6deab5f4a0c4ef1dddcb7ea6d8d2520" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;String&lt;/code&gt; type, which is provided by Rust&amp;rsquo;s standard library rather than coded into the core language, is a growable, mutable, owned, UTF-8 encoded string type. When Rustaceans refer to &amp;ldquo;strings&amp;rdquo; in Rust, they usually mean the &lt;code&gt;String&lt;/code&gt; and the string slice &lt;code&gt;&amp;amp;str&lt;/code&gt; types, not just one of those types. Although this section is largely about &lt;code&gt;String&lt;/code&gt;, both types are used heavily in Rust&amp;rsquo;s standard library, and both &lt;code&gt;String&lt;/code&gt; and string slices are UTF-8 encoded.</source>
          <target state="translated">Тип &lt;code&gt;String&lt;/code&gt; , который предоставляется стандартной библиотекой Rust, а не закодирован на базовом языке, является растущим, изменяемым, принадлежащим типом строки в кодировке UTF-8. Когда Rustaceans ссылаются на &amp;laquo;строки&amp;raquo; в Rust, они обычно имеют в виду типы &lt;code&gt;String&lt;/code&gt; и string slice &lt;code&gt;&amp;amp;str&lt;/code&gt; , а не только один из этих типов. Хотя этот раздел в основном посвящен &lt;code&gt;String&lt;/code&gt; , оба типа широко используются в стандартной библиотеке Rust, и как &lt;code&gt;String&lt;/code&gt; ,так и строковые срезы имеют кодировку UTF-8.</target>
        </trans-unit>
        <trans-unit id="e2f29f1c300ba36b21c6a01062d991f47ee83fd6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Sync&lt;/code&gt; and &lt;code&gt;Send&lt;/code&gt; traits, which extend Rust&amp;rsquo;s concurrency guarantees to user-defined types as well as types provided by the standard library</source>
          <target state="translated">В &lt;code&gt;Sync&lt;/code&gt; и &lt;code&gt;Send&lt;/code&gt; черты, которые расширяют параллелизм гарантии Ржавчина на определяемые пользователем типы, а также видов предоставляемых стандартной библиотеки</target>
        </trans-unit>
        <trans-unit id="546dfd59f5dde2a2d3bad5396a6d76cbe9696aee" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Sync&lt;/code&gt; marker trait indicates that it is safe for the type implementing &lt;code&gt;Sync&lt;/code&gt; to be referenced from multiple threads. In other words, any type &lt;code&gt;T&lt;/code&gt; is &lt;code&gt;Sync&lt;/code&gt; if &lt;code&gt;&amp;amp;T&lt;/code&gt; (a reference to &lt;code&gt;T&lt;/code&gt;) is &lt;code&gt;Send&lt;/code&gt;, meaning the reference can be sent safely to another thread. Similar to &lt;code&gt;Send&lt;/code&gt;, primitive types are &lt;code&gt;Sync&lt;/code&gt;, and types composed entirely of types that are &lt;code&gt;Sync&lt;/code&gt; are also &lt;code&gt;Sync&lt;/code&gt;.</source>
          <target state="translated">Характеристика &lt;code&gt;Sync&lt;/code&gt; marker указывает, что для типа, реализующего &lt;code&gt;Sync&lt;/code&gt; , можно безопасно ссылаться из нескольких потоков. Другими словами, любой тип &lt;code&gt;T&lt;/code&gt; - это &lt;code&gt;Sync&lt;/code&gt; , если &lt;code&gt;&amp;amp;T&lt;/code&gt; (ссылка на &lt;code&gt;T&lt;/code&gt; ) - это &lt;code&gt;Send&lt;/code&gt; , что означает, что ссылку можно безопасно отправить в другой поток. Подобно &lt;code&gt;Send&lt;/code&gt; , примитивные типы - это &lt;code&gt;Sync&lt;/code&gt; , а типы, полностью состоящие из типов, которые являются &lt;code&gt;Sync&lt;/code&gt; , также являются &lt;code&gt;Sync&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="646e9a46a3198e5aae6cea0647712ac157d7125f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;T&lt;/code&gt; and &lt;code&gt;E&lt;/code&gt; are generic type parameters: we&amp;rsquo;ll discuss generics in more detail in Chapter 10. What you need to know right now is that &lt;code&gt;T&lt;/code&gt; represents the type of the value that will be returned in a success case within the &lt;code&gt;Ok&lt;/code&gt; variant, and &lt;code&gt;E&lt;/code&gt; represents the type of the error that will be returned in a failure case within the &lt;code&gt;Err&lt;/code&gt; variant. Because &lt;code&gt;Result&lt;/code&gt; has these generic type parameters, we can use the &lt;code&gt;Result&lt;/code&gt; type and the functions that the standard library has defined on it in many different situations where the successful value and error value we want to return may differ.</source>
          <target state="translated">&lt;code&gt;T&lt;/code&gt; и &lt;code&gt;E&lt;/code&gt; являются общими параметрами типа: мы обсудим дженерик более подробно в главе 10. То , что вы должны знать , прямо сейчас, что &lt;code&gt;T&lt;/code&gt; представляет тип значения , которое будет возвращено в случае успеха в &lt;code&gt;Ok&lt;/code&gt; варианта, и &lt;code&gt;E&lt;/code&gt; представляет тип ошибки, которая будет возвращена в случае сбоя в варианте &lt;code&gt;Err&lt;/code&gt; . Поскольку &lt;code&gt;Result&lt;/code&gt; имеет эти параметры универсального типа, мы можем использовать тип &lt;code&gt;Result&lt;/code&gt; и функции, определенные для него стандартной библиотекой, во многих различных ситуациях, когда успешное значение и значение ошибки, которые мы хотим вернуть, могут отличаться.</target>
        </trans-unit>
        <trans-unit id="cb756122c49feafba4692e36792c9ec503818ac1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Thread&lt;/code&gt; type</source>
          <target state="translated">&lt;code&gt;Thread&lt;/code&gt; типа</target>
        </trans-unit>
        <trans-unit id="fadb7c71117e778367444a0d18f0442e8249124b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ThreadPool&lt;/code&gt; will create a channel and hold on to the sending side of the channel.</source>
          <target state="translated">&lt;code&gt;ThreadPool&lt;/code&gt; создаст канал и удерживать на передающей стороне канала.</target>
        </trans-unit>
        <trans-unit id="e48c39ae08cbb88aef00b305b9017512b2fc007b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;UnsafeCell&lt;/code&gt; API itself is technically very simple: &lt;a href=&quot;struct.unsafecell#method.get&quot;&gt;&lt;code&gt;.get()&lt;/code&gt;&lt;/a&gt; gives you a raw pointer &lt;code&gt;*mut T&lt;/code&gt; to its contents. It is up to &lt;em&gt;you&lt;/em&gt; as the abstraction designer to use that raw pointer correctly.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6a5cd0207b32d758dbbf9a6159c66155c77acce0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;UnsafeCell&lt;/code&gt; API itself is technically very simple: it gives you a raw pointer &lt;code&gt;*mut T&lt;/code&gt; to its contents. It is up to &lt;em&gt;you&lt;/em&gt; as the abstraction designer to use that raw pointer correctly.</source>
          <target state="translated">Сам API &lt;code&gt;UnsafeCell&lt;/code&gt; технически очень прост: он дает вам необработанный указатель &lt;code&gt;*mut T&lt;/code&gt; на его содержимое. Правильное использование этого необработанного указателя зависит от &lt;em&gt;вас&lt;/em&gt; как разработчика абстракции.</target>
        </trans-unit>
        <trans-unit id="0a41c6aadefabb63fa74ac6fccd4136ec47ca08f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;UpperExp&lt;/code&gt; trait should format its output in scientific notation with an upper-case &lt;code&gt;E&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;UpperExp&lt;/code&gt; черта должна форматировать свой выход в научной записи с прописной &lt;code&gt;E&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c532f0150ba601cb070b0fc006c6b873d809aeda" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;UpperHex&lt;/code&gt; trait should format its output as a number in hexadecimal, with &lt;code&gt;A&lt;/code&gt; through &lt;code&gt;F&lt;/code&gt; in upper case.</source>
          <target state="translated">Свойство &lt;code&gt;UpperHex&lt;/code&gt; должно форматировать свой вывод как шестнадцатеричное число с буквами от &lt;code&gt;A&lt;/code&gt; до &lt;code&gt;F&lt;/code&gt; в верхнем регистре.</target>
        </trans-unit>
        <trans-unit id="1692dc51a2dd0859a66b3a15d1e8df4859265ffa" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Vec&lt;/code&gt; type allows to access values by index, because it implements the &lt;a href=&quot;../ops/trait.index&quot;&gt;&lt;code&gt;Index&lt;/code&gt;&lt;/a&gt; trait. An example will be more explicit:</source>
          <target state="translated">Тип &lt;code&gt;Vec&lt;/code&gt; позволяет получить доступ к значениям по индексу, поскольку он реализует трейт &lt;a href=&quot;../ops/trait.index&quot;&gt; &lt;code&gt;Index&lt;/code&gt; &lt;/a&gt; . Пример будет более явным:</target>
        </trans-unit>
        <trans-unit id="fdf15f1d79f5be8a81ff6d7d469c446ffbe09215" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;_&lt;/code&gt; pattern will match any value. By putting it after our other arms, the &lt;code&gt;_&lt;/code&gt; will match all the possible cases that aren&amp;rsquo;t specified before it. The &lt;code&gt;()&lt;/code&gt; is just the unit value, so nothing will happen in the &lt;code&gt;_&lt;/code&gt; case. As a result, we can say that we want to do nothing for all the possible values that we don&amp;rsquo;t list before the &lt;code&gt;_&lt;/code&gt; placeholder.</source>
          <target state="translated">&lt;code&gt;_&lt;/code&gt; Шаблон будет соответствовать любому значению. Помещая его после других наших ответвлений, &lt;code&gt;_&lt;/code&gt; будет соответствовать всем возможным случаям, которые не указаны перед ним. &lt;code&gt;()&lt;/code&gt; Только стоимость единицы, так что ничего не произойдет в &lt;code&gt;_&lt;/code&gt; случае. В результате мы можем сказать, что мы не хотим ничего делать для всех возможных значений, которые мы не указываем перед заполнителем &lt;code&gt;_&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d4f623218e4e907b6db896a6ba8ba2e0737f6051" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;abort&lt;/code&gt; function terminates the process, so the destructor will not get run on the example below:</source>
          <target state="translated">Функция &lt;code&gt;abort&lt;/code&gt; завершает процесс, поэтому деструктор не запускается в приведенном ниже примере:</target>
        </trans-unit>
        <trans-unit id="1da31d2d7b88dbadae1ea02224cc02bf279c6b4e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;add&lt;/code&gt; method adds the &lt;code&gt;x&lt;/code&gt; values of two &lt;code&gt;Point&lt;/code&gt; instances and the &lt;code&gt;y&lt;/code&gt; values of two &lt;code&gt;Point&lt;/code&gt; instances to create a new &lt;code&gt;Point&lt;/code&gt;. The &lt;code&gt;Add&lt;/code&gt; trait has an associated type named &lt;code&gt;Output&lt;/code&gt; that determines the type returned from the &lt;code&gt;add&lt;/code&gt; method.</source>
          <target state="translated">Метод &lt;code&gt;add&lt;/code&gt; добавляет значения &lt;code&gt;x&lt;/code&gt; двух экземпляров &lt;code&gt;Point&lt;/code&gt; и значения &lt;code&gt;y&lt;/code&gt; двух экземпляров &lt;code&gt;Point&lt;/code&gt; для создания новой &lt;code&gt;Point&lt;/code&gt; . Свойство &lt;code&gt;Add&lt;/code&gt; имеет связанный тип с именем &lt;code&gt;Output&lt;/code&gt; , который определяет тип, возвращаемый методом &lt;code&gt;add&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6b4f66cfe4d8578da648c05ce2a1d295046eb19d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;add_text&lt;/code&gt; method takes a mutable reference to &lt;code&gt;self&lt;/code&gt;, because we&amp;rsquo;re changing the &lt;code&gt;Post&lt;/code&gt; instance that we&amp;rsquo;re calling &lt;code&gt;add_text&lt;/code&gt; on. We then call &lt;code&gt;push_str&lt;/code&gt; on the &lt;code&gt;String&lt;/code&gt; in &lt;code&gt;content&lt;/code&gt; and pass the &lt;code&gt;text&lt;/code&gt; argument to add to the saved &lt;code&gt;content&lt;/code&gt;. This behavior doesn&amp;rsquo;t depend on the state the post is in, so it&amp;rsquo;s not part of the state pattern. The &lt;code&gt;add_text&lt;/code&gt; method doesn&amp;rsquo;t interact with the &lt;code&gt;state&lt;/code&gt; field at all, but it is part of the behavior we want to support.</source>
          <target state="translated">Метод &lt;code&gt;add_text&lt;/code&gt; принимает изменяемую ссылку на &lt;code&gt;self&lt;/code&gt; , потому что мы меняем экземпляр &lt;code&gt;Post&lt;/code&gt; , для которого вызываем &lt;code&gt;add_text&lt;/code&gt; . Затем мы вызываем &lt;code&gt;push_str&lt;/code&gt; для &lt;code&gt;String&lt;/code&gt; в &lt;code&gt;content&lt;/code&gt; и передаем &lt;code&gt;text&lt;/code&gt; аргумент для добавления к сохраненному &lt;code&gt;content&lt;/code&gt; . Это поведение не зависит от состояния сообщения, поэтому оно не является частью шаблона состояния. Метод &lt;code&gt;add_text&lt;/code&gt; вообще не взаимодействует с полем &lt;code&gt;state&lt;/code&gt; , но это часть поведения, которое мы хотим поддерживать.</target>
        </trans-unit>
        <trans-unit id="2c3ad15ad6826ff34548cd3374a6a4eed3efc204" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;align&lt;/code&gt; and &lt;code&gt;packed&lt;/code&gt; modifiers can be used to respectively raise or lower the alignment of &lt;code&gt;struct&lt;/code&gt;s and &lt;code&gt;union&lt;/code&gt;s. &lt;code&gt;packed&lt;/code&gt; may also alter the padding between fields.</source>
          <target state="translated">&lt;code&gt;align&lt;/code&gt; и &lt;code&gt;packed&lt;/code&gt; модификаторы могут быть использованы , чтобы соответственно поднять или опустить выравнивание &lt;code&gt;struct&lt;/code&gt; с и &lt;code&gt;union&lt;/code&gt; с. &lt;code&gt;packed&lt;/code&gt; также может изменять заполнение между полями.</target>
        </trans-unit>
        <trans-unit id="0e0634e43790fec0970517f968c2cdaea9942a64" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;align&lt;/code&gt; and &lt;code&gt;packed&lt;/code&gt; modifiers cannot be applied on the same type and a &lt;code&gt;packed&lt;/code&gt; type cannot transitively contain another &lt;code&gt;align&lt;/code&gt;ed type. &lt;code&gt;align&lt;/code&gt; and &lt;code&gt;packed&lt;/code&gt; may only be applied to the &lt;a href=&quot;#the-default-representation&quot;&gt;default&lt;/a&gt; and &lt;a href=&quot;#the-c-representation&quot;&gt;&lt;code&gt;C&lt;/code&gt;&lt;/a&gt; representations.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ba365c1b081658cee386344e9e2a04962a51bb04" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;align&lt;/code&gt; and &lt;code&gt;packed&lt;/code&gt; modifiers cannot be applied on the same type and a &lt;code&gt;packed&lt;/code&gt; type cannot transitively contain another &lt;code&gt;align&lt;/code&gt;ed type. &lt;code&gt;align&lt;/code&gt; and &lt;code&gt;packed&lt;/code&gt; may only be applied to the &lt;a href=&quot;type-layout#the-default-representation&quot;&gt;default&lt;/a&gt; and &lt;a href=&quot;type-layout#the-c-representation&quot;&gt;&lt;code&gt;C&lt;/code&gt;&lt;/a&gt; representations.</source>
          <target state="translated">В &lt;code&gt;align&lt;/code&gt; и &lt;code&gt;packed&lt;/code&gt; модификаторы не могут быть применены на тот же тип и &lt;code&gt;packed&lt;/code&gt; тип не может содержать другой транзитивно &lt;code&gt;align&lt;/code&gt; типа изда. &lt;code&gt;align&lt;/code&gt; и &lt;code&gt;packed&lt;/code&gt; могут быть применены только к &lt;a href=&quot;type-layout#the-default-representation&quot;&gt;умолчанию&lt;/a&gt; и &lt;a href=&quot;type-layout#the-c-representation&quot;&gt; &lt;code&gt;C&lt;/code&gt; &lt;/a&gt; представлений.</target>
        </trans-unit>
        <trans-unit id="53e65577e1cfa4684ae0b49bee71e8da03a67fa1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;align&lt;/code&gt; modifier can also be applied on an &lt;code&gt;enum&lt;/code&gt;. When it is, the effect on the &lt;code&gt;enum&lt;/code&gt;'s alignment is the same as if the &lt;code&gt;enum&lt;/code&gt; was wrapped in a newtype &lt;code&gt;struct&lt;/code&gt; with the same &lt;code&gt;align&lt;/code&gt; modifier.</source>
          <target state="translated">&lt;code&gt;align&lt;/code&gt; модификатор также может быть применен на &lt;code&gt;enum&lt;/code&gt; . Когда это так, эффект на выравнивание &lt;code&gt;enum&lt;/code&gt; такой же, как если бы &lt;code&gt;enum&lt;/code&gt; было заключено в &lt;code&gt;struct&lt;/code&gt; newtype с тем же модификатором &lt;code&gt;align&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6ad8df46a380899eaf26791f29aae33e2b0b76bb" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;amt&lt;/code&gt; must be &lt;code&gt;&amp;lt;=&lt;/code&gt; the number of bytes in the buffer returned by &lt;a href=&quot;#tymethod.fill_buf&quot;&gt;&lt;code&gt;fill_buf&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;amt&lt;/code&gt; должен быть &lt;code&gt;&amp;lt;=&lt;/code&gt; число байтов в буфере , возвращаемый &lt;a href=&quot;#tymethod.fill_buf&quot;&gt; &lt;code&gt;fill_buf&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="6cdd430203e5d1bc8171135295b8e6a12c3f9ccb" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;amt&lt;/code&gt; must be &lt;code&gt;&amp;lt;=&lt;/code&gt; the number of bytes in the buffer returned by &lt;a href=&quot;trait.bufread#tymethod.fill_buf&quot;&gt;&lt;code&gt;fill_buf&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="45b714d09b6da61ea117e3601d5d1e5fd89a8774" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;approve&lt;/code&gt; method will be similar to the &lt;code&gt;request_review&lt;/code&gt; method: it will set &lt;code&gt;state&lt;/code&gt; to the value that the current state says it should have when that state is approved, as shown in Listing 17-16:</source>
          <target state="translated">Метод &lt;code&gt;approve&lt;/code&gt; будет аналогичен методу &lt;code&gt;request_review&lt;/code&gt; : он установит для &lt;code&gt;state&lt;/code&gt; значение, которое, согласно текущему состоянию, должно быть у него при утверждении этого состояния, как показано в листинге 17-16:</target>
        </trans-unit>
        <trans-unit id="0d99e2697c98f4ee00d53c8602d75f85424ebe1a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;area&lt;/code&gt; function accesses the &lt;code&gt;width&lt;/code&gt; and &lt;code&gt;height&lt;/code&gt; fields of the &lt;code&gt;Rectangle&lt;/code&gt; instance. Our function signature for &lt;code&gt;area&lt;/code&gt; now says exactly what we mean: calculate the area of &lt;code&gt;Rectangle&lt;/code&gt;, using its &lt;code&gt;width&lt;/code&gt; and &lt;code&gt;height&lt;/code&gt; fields. This conveys that the width and height are related to each other, and it gives descriptive names to the values rather than using the tuple index values of &lt;code&gt;0&lt;/code&gt; and &lt;code&gt;1&lt;/code&gt;. This is a win for clarity.</source>
          <target state="translated">Функция &lt;code&gt;area&lt;/code&gt; обращается к полям &lt;code&gt;width&lt;/code&gt; и &lt;code&gt;height&lt;/code&gt; экземпляра &lt;code&gt;Rectangle&lt;/code&gt; . Наша сигнатура функции для &lt;code&gt;area&lt;/code&gt; теперь говорит именно то, что мы имеем в виду: вычислить площадь &lt;code&gt;Rectangle&lt;/code&gt; , используя его поля &lt;code&gt;width&lt;/code&gt; и &lt;code&gt;height&lt;/code&gt; . Это означает, что ширина и высота связаны друг с другом, и дает описательные имена для значений вместо использования значений индекса кортежа &lt;code&gt;0&lt;/code&gt; и &lt;code&gt;1&lt;/code&gt; . Это выигрыш для ясности.</target>
        </trans-unit>
        <trans-unit id="f0f4d5c245d843fc107cb0d995f1cc0cbaafe380" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;area&lt;/code&gt; function is supposed to calculate the area of one rectangle, but the function we wrote has two parameters. The parameters are related, but that&amp;rsquo;s not expressed anywhere in our program. It would be more readable and more manageable to group width and height together. We&amp;rsquo;ve already discussed one way we might do that in &lt;a href=&quot;ch03-02-data-types#the-tuple-type&quot;&gt;&amp;ldquo;The Tuple Type&amp;rdquo;&lt;/a&gt; section of Chapter 3: by using tuples.</source>
          <target state="translated">Функция &lt;code&gt;area&lt;/code&gt; должна вычислять площадь одного прямоугольника, но написанная нами функция имеет два параметра. Параметры связаны, но это нигде в нашей программе не выражено. Было бы легче сгруппировать ширину и высоту вместе. Мы уже обсуждали один из способов сделать это в разделе &lt;a href=&quot;ch03-02-data-types#the-tuple-type&quot;&gt;&amp;laquo;Тип&lt;/a&gt; кортежа &amp;raquo; главы 3: с помощью кортежей.</target>
        </trans-unit>
        <trans-unit id="03663b761515431ad66c10f38033078682c6e595" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;art&lt;/code&gt; crate users can still see and use the internal structure from Listing 14-3 as demonstrated in Listing 14-4, or they can use the more convenient structure in Listing 14-5, as shown in Listing 14-6:</source>
          <target state="translated">Пользователи &lt;code&gt;art&lt;/code&gt; ящика могут по-прежнему видеть и использовать внутреннюю структуру из листинга 14-3, как показано в листинге 14-4, или они могут использовать более удобную структуру из листинга 14-5, как показано в листинге 14-6:</target>
        </trans-unit>
        <trans-unit id="e825da57c4a60047ea61533b7c1bd5bca8251591" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;as&lt;/code&gt; keyword can be used to change what the crate is referred to as in your project. If a crate name includes a dash, it is implicitly imported with the dashes replaced by underscores.</source>
          <target state="translated">&lt;code&gt;as&lt;/code&gt; можно использовать ключевое слово , чтобы изменить то , что обрешетка упоминается как в вашем проекте. Если имя ящика включает тире, оно неявно импортируется с заменой тире на подчеркивание.</target>
        </trans-unit>
        <trans-unit id="2dd2463e89570fe4f3bb6f6203a6c56b03267f94" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;assert!&lt;/code&gt; macro, provided by the standard library, is useful when you want to ensure that some condition in a test evaluates to &lt;code&gt;true&lt;/code&gt;. We give the &lt;code&gt;assert!&lt;/code&gt; macro an argument that evaluates to a Boolean. If the value is &lt;code&gt;true&lt;/code&gt;, &lt;code&gt;assert!&lt;/code&gt; does nothing and the test passes. If the value is &lt;code&gt;false&lt;/code&gt;, the &lt;code&gt;assert!&lt;/code&gt; macro calls the &lt;code&gt;panic!&lt;/code&gt; macro, which causes the test to fail. Using the &lt;code&gt;assert!&lt;/code&gt; macro helps us check that our code is functioning in the way we intend.</source>
          <target state="translated">Утверждение &lt;code&gt;assert!&lt;/code&gt; Макрос, предоставляемый стандартной библиотекой, полезен, когда вы хотите убедиться, что какое-то условие в тесте оценивается как &lt;code&gt;true&lt;/code&gt; . Даем &lt;code&gt;assert!&lt;/code&gt; макрос аргумент, вычисляемый как логическое. Если значение &lt;code&gt;true&lt;/code&gt; , &lt;code&gt;assert!&lt;/code&gt; ничего не делает, и тест проходит. Если значение равно &lt;code&gt;false&lt;/code&gt; , &lt;code&gt;assert!&lt;/code&gt; макрос вызывает &lt;code&gt;panic!&lt;/code&gt; макрос, который приводит к сбою теста. Используя &lt;code&gt;assert!&lt;/code&gt; макрос помогает нам проверить, работает ли наш код так, как мы предполагаем.</target>
        </trans-unit>
        <trans-unit id="95f1355f51c209910ea66191ec2fc57f92344bfc" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;assert_ne!&lt;/code&gt; macro will pass if the two values we give it are not equal and fail if they&amp;rsquo;re equal. This macro is most useful for cases when we&amp;rsquo;re not sure what a value &lt;em&gt;will&lt;/em&gt; be, but we know what the value definitely &lt;em&gt;won&amp;rsquo;t&lt;/em&gt; be if our code is functioning as we intend. For example, if we&amp;rsquo;re testing a function that is guaranteed to change its input in some way, but the way in which the input is changed depends on the day of the week that we run our tests, the best thing to assert might be that the output of the function is not equal to the input.</source>
          <target state="translated">&lt;code&gt;assert_ne!&lt;/code&gt; макрос будет проходить, если два значения, которые мы даем ему, не равны, и завершится ошибкой, если они равны. Этот макрос наиболее полезен в случаях, когда мы не уверены, какое значение &lt;em&gt;будет&lt;/em&gt; , но мы знаем, каким &lt;em&gt;будет&lt;/em&gt; значение определенно &lt;em&gt;,&lt;/em&gt; если наш код работает так, как мы предполагали. Например, если мы тестируем функцию, которая гарантированно изменяет свой ввод каким-либо образом, но способ изменения ввода зависит от дня недели, в который мы запускаем наши тесты, лучше всего утверждать, что что выход функции не равен входу.</target>
        </trans-unit>
        <trans-unit id="bf35e012d7004404479ddec49cb6abc4ee90bc1a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;bind&lt;/code&gt; function in this scenario works like the &lt;code&gt;new&lt;/code&gt; function in that it will return a new &lt;code&gt;TcpListener&lt;/code&gt; instance. The reason the function is called &lt;code&gt;bind&lt;/code&gt; is that in networking, connecting to a port to listen to is known as &amp;ldquo;binding to a port.&amp;rdquo;</source>
          <target state="translated">Функция &lt;code&gt;bind&lt;/code&gt; в этом сценарии работает так же, как &lt;code&gt;new&lt;/code&gt; функция, в том &lt;code&gt;TcpListener&lt;/code&gt; что она возвращает новый экземпляр TcpListener . Причина, по которой функция называется &lt;code&gt;bind&lt;/code&gt; , состоит в том, что в сети подключение к порту для прослушивания известно как &amp;laquo;привязка к порту&amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="3a9db4154e7cfc914c7af74a70f78787dc149e27" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;bind&lt;/code&gt; function returns a &lt;code&gt;Result&amp;lt;T, E&amp;gt;&lt;/code&gt;, which indicates that binding might fail. For example, connecting to port 80 requires administrator privileges (nonadministrators can listen only on ports higher than 1024), so if we tried to connect to port 80 without being an administrator, binding wouldn&amp;rsquo;t work. As another example, binding wouldn&amp;rsquo;t work if we ran two instances of our program and so had two programs listening to the same port. Because we&amp;rsquo;re writing a basic server just for learning purposes, we won&amp;rsquo;t worry about handling these kinds of errors; instead, we use &lt;code&gt;unwrap&lt;/code&gt; to stop the program if errors happen.</source>
          <target state="translated">Функция &lt;code&gt;bind&lt;/code&gt; возвращает &lt;code&gt;Result&amp;lt;T, E&amp;gt;&lt;/code&gt; , который указывает, что привязка может завершиться неудачно. Например, для подключения к порту 80 требуются права администратора (неадминистраторы могут прослушивать только порты выше 1024), поэтому, если мы попытаемся подключиться к порту 80, не будучи администратором, привязка не сработает. В качестве другого примера, привязка не будет работать, если мы запустили два экземпляра нашей программы и, следовательно, две программы будут прослушивать один и тот же порт. Поскольку мы пишем базовый сервер только для обучения, мы не будем беспокоиться об обработке таких ошибок; вместо этого мы используем &lt;code&gt;unwrap&lt;/code&gt; , чтобы остановить программу в случае возникновения ошибок.</target>
        </trans-unit>
        <trans-unit id="86e869ec27553a2645d530ee9b57e980ad085326" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;bool&lt;/code&gt; represents a value, which could only be either &lt;code&gt;true&lt;/code&gt; or &lt;code&gt;false&lt;/code&gt;. If you cast a &lt;code&gt;bool&lt;/code&gt; into an integer, &lt;code&gt;true&lt;/code&gt; will be 1 and &lt;code&gt;false&lt;/code&gt; will be 0.</source>
          <target state="translated">&lt;code&gt;bool&lt;/code&gt; представляет собой значение, которое может быть только либо &lt;code&gt;true&lt;/code&gt; или &lt;code&gt;false&lt;/code&gt; . Если вы приведете &lt;code&gt;bool&lt;/code&gt; к целому числу, &lt;code&gt;true&lt;/code&gt; будет 1, а &lt;code&gt;false&lt;/code&gt; будет 0.</target>
        </trans-unit>
        <trans-unit id="d4311662fb8a13303491e364af26bcbe8200bef8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;bool&lt;/code&gt; type is a datatype which can be either &lt;code&gt;true&lt;/code&gt; or &lt;code&gt;false&lt;/code&gt;. The boolean type uses one byte of memory. It is used in comparisons and bitwise operations like &lt;code&gt;&amp;amp;&lt;/code&gt;, &lt;code&gt;|&lt;/code&gt;, and &lt;code&gt;!&lt;/code&gt;.</source>
          <target state="translated">Тип &lt;code&gt;bool&lt;/code&gt; - это тип данных, который может иметь значение &lt;code&gt;true&lt;/code&gt; или &lt;code&gt;false&lt;/code&gt; . Логический тип использует один байт памяти. Он используется в сравнениях и побитовых операциях, таких как &lt;code&gt;&amp;amp;&lt;/code&gt; , &lt;code&gt;|&lt;/code&gt; , и &lt;code&gt;!&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="71b45beaeed4f4e8bb8cb42d1eee7255c7dfda23" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;break&lt;/code&gt; statement can take an argument (which will be the value of the loop expression if the &lt;code&gt;break&lt;/code&gt; statement is executed) in &lt;code&gt;loop&lt;/code&gt; loops, but not &lt;code&gt;for&lt;/code&gt;, &lt;code&gt;while&lt;/code&gt;, or &lt;code&gt;while let&lt;/code&gt; loops.</source>
          <target state="translated">Оператор &lt;code&gt;break&lt;/code&gt; может принимать аргумент (который будет значением выражения цикла, если оператор &lt;code&gt;break&lt;/code&gt; выполняется) в циклах &lt;code&gt;loop&lt;/code&gt; , но не в циклах &lt;code&gt;for&lt;/code&gt; , &lt;code&gt;while&lt;/code&gt; или &lt;code&gt;while let&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d4fc4821431bbe2f5d7ca950ef58b031fb001379" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;bytes&lt;/code&gt; method returns each raw byte, which might be appropriate for your domain:</source>
          <target state="translated">Метод &lt;code&gt;bytes&lt;/code&gt; возвращает каждый необработанный байт, который может быть подходящим для вашего домена:</target>
        </trans-unit>
        <trans-unit id="0c67d48bb9bf16df95a3dc50a92dbdfe313c2a09" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;can_hold&lt;/code&gt; method returns a Boolean, which means it&amp;rsquo;s a perfect use case for the &lt;code&gt;assert!&lt;/code&gt; macro. In Listing 11-6, we write a test that exercises the &lt;code&gt;can_hold&lt;/code&gt; method by creating a &lt;code&gt;Rectangle&lt;/code&gt; instance that has a width of 8 and a height of 7 and asserting that it can hold another &lt;code&gt;Rectangle&lt;/code&gt; instance that has a width of 5 and a height of 1.</source>
          <target state="translated">Метод &lt;code&gt;can_hold&lt;/code&gt; возвращает логическое значение, что означает, что это идеальный вариант использования &lt;code&gt;assert!&lt;/code&gt; макрос. В листинге 11-6 мы пишем тест, который &lt;code&gt;can_hold&lt;/code&gt; метод can_hold , создавая экземпляр &lt;code&gt;Rectangle&lt;/code&gt; с шириной 8 и высотой 7 и утверждая, что он может содержать другой экземпляр &lt;code&gt;Rectangle&lt;/code&gt; с шириной 5 и высотой 1.</target>
        </trans-unit>
        <trans-unit id="5a25b55443c783de850a8f716e7e98dd68745de2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;cargo install&lt;/code&gt; command allows you to install and use binary crates locally. This isn&amp;rsquo;t intended to replace system packages; it&amp;rsquo;s meant to be a convenient way for Rust developers to install tools that others have shared on &lt;a href=&quot;https://crates.io/&quot;&gt;crates.io&lt;/a&gt;. Note that you can only install packages that have binary targets. A &lt;em&gt;binary target&lt;/em&gt; is the runnable program that is created if the crate has a &lt;em&gt;src/main.rs&lt;/em&gt; file or another file specified as a binary, as opposed to a library target that isn&amp;rsquo;t runnable on its own but is suitable for including within other programs. Usually, crates have information in the &lt;em&gt;README&lt;/em&gt; file about whether a crate is a library, has a binary target, or both.</source>
          <target state="translated">Команда &lt;code&gt;cargo install&lt;/code&gt; позволяет устанавливать и использовать бинарные крейты локально. Это не предназначено для замены системных пакетов; Это должно быть удобным способом для разработчиков Rust устанавливать инструменты, которыми другие поделились на &lt;a href=&quot;https://crates.io/&quot;&gt;crates.io&lt;/a&gt; . Обратите внимание, что вы можете устанавливать только пакеты с двоичными целями. &lt;em&gt;Бинарная мишенью&lt;/em&gt; является исполняемой программой , которая создается , если клеть имеет &lt;em&gt;SRC / main.rs&lt;/em&gt; файл или другой файл , указанный в качестве двоичного файла, в отличии от целевой библиотеки , которая не является исполняемой самой по себе , но подходит для включения в других программы. Обычно ящики содержат информацию в файле &lt;em&gt;README&lt;/em&gt; о том, является ли ящик библиотекой, имеет двоичную цель или и то, и другое.</target>
        </trans-unit>
        <trans-unit id="2664dcbe5273c6722a5b153d876b9b792f2ada2f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;cargo test&lt;/code&gt; command runs all tests in our project, as shown in Listing 11-2.</source>
          <target state="translated">Команда &lt;code&gt;cargo test&lt;/code&gt; запускает все тесты в нашем проекте, как показано в листинге 11-2.</target>
        </trans-unit>
        <trans-unit id="375baaee400dee61b2707b887bd9af56fe2bc128" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;cfg&lt;/code&gt; attribute</source>
          <target state="translated">&lt;code&gt;cfg&lt;/code&gt; атрибут</target>
        </trans-unit>
        <trans-unit id="3c6c79dbe0366f164760e8fbd149ca95e0429eec" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;cfg&lt;/code&gt; attribute is allowed anywhere attributes are allowed.</source>
          <target state="translated">&lt;code&gt;cfg&lt;/code&gt; атрибут разрешен атрибуты нигде не допускаются.</target>
        </trans-unit>
        <trans-unit id="c1be4a466f7709a98c138b8664fae5693d56dd2b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;cfg&lt;/code&gt; attribute supports only three kinds of predicates:</source>
          <target state="translated">В &lt;code&gt;cfg&lt;/code&gt; атрибут поддерживает только три типа сказуемых:</target>
        </trans-unit>
        <trans-unit id="28422790bd7081a79bb025fb9d66e378219a525d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;cfg&lt;/code&gt; macro</source>
          <target state="translated">&lt;code&gt;cfg&lt;/code&gt; макро</target>
        </trans-unit>
        <trans-unit id="fde18a15c12045ccc5f862ad4d07ffff9bb790a4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;cfg&lt;/code&gt;&lt;a href=&quot;attributes&quot;&gt;attribute&lt;/a&gt; conditionally includes the thing it is attached to based on a configuration predicate.</source>
          <target state="translated">&lt;code&gt;cfg&lt;/code&gt; &lt;a href=&quot;attributes&quot;&gt;атрибут&lt;/a&gt; условно включает в себя вещь оно прикреплено к основано на конфигурации предиката.</target>
        </trans-unit>
        <trans-unit id="2223835f7d8034d74bbb5846af6ec97de49a67f5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;cfg_attr&lt;/code&gt; attribute</source>
          <target state="translated">&lt;code&gt;cfg_attr&lt;/code&gt; атрибут</target>
        </trans-unit>
        <trans-unit id="76546526e7489be649c0d74ada78ee80e5e85965" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;cfg_attr&lt;/code&gt; attribute is allowed anywhere attributes are allowed.</source>
          <target state="translated">&lt;code&gt;cfg_attr&lt;/code&gt; атрибут разрешен атрибуты нигде не допускаются.</target>
        </trans-unit>
        <trans-unit id="548a83f876de36acae9e81967a808fe451cf7938" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;cfg_attr&lt;/code&gt;&lt;a href=&quot;attributes&quot;&gt;attribute&lt;/a&gt; conditionally includes &lt;a href=&quot;attributes&quot;&gt;attributes&lt;/a&gt; based on a configuration predicate.</source>
          <target state="translated">&lt;code&gt;cfg_attr&lt;/code&gt; &lt;a href=&quot;attributes&quot;&gt;атрибут&lt;/a&gt; условно включает в себя &lt;a href=&quot;attributes&quot;&gt;атрибуты&lt;/a&gt; на основе конфигурации предиката.</target>
        </trans-unit>
        <trans-unit id="85a19bbf37eb56f0525c8c2436505adedd691250" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;char&lt;/code&gt; type represents a single character. More specifically, since 'character' isn't a well-defined concept in Unicode, &lt;code&gt;char&lt;/code&gt; is a '&lt;a href=&quot;http://www.unicode.org/glossary/#unicode_scalar_value&quot;&gt;Unicode scalar value&lt;/a&gt;', which is similar to, but not the same as, a '&lt;a href=&quot;http://www.unicode.org/glossary/#code_point&quot;&gt;Unicode code point&lt;/a&gt;'.</source>
          <target state="translated">Тип &lt;code&gt;char&lt;/code&gt; представляет собой один символ. Более конкретно, поскольку &amp;laquo;символ&amp;raquo; не является четко определенным понятием в Unicode, &lt;code&gt;char&lt;/code&gt; - это &amp;laquo; &lt;a href=&quot;http://www.unicode.org/glossary/#unicode_scalar_value&quot;&gt;скалярное значение Unicode&lt;/a&gt; &amp;raquo;, которое похоже на &amp;laquo; &lt;a href=&quot;http://www.unicode.org/glossary/#code_point&quot;&gt;кодовую точку Unicode&amp;raquo;&lt;/a&gt; , но не то же самое .</target>
        </trans-unit>
        <trans-unit id="b73bedd4705331ddde92b218ee42ae14fd783b1a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;cold&lt;/code&gt; and &lt;code&gt;inline&lt;/code&gt;&lt;a href=&quot;../attributes&quot;&gt;attributes&lt;/a&gt; give suggestions to generate code in a way that may be faster than what it would do without the hint. The attributes are only hints, and may be ignored.</source>
          <target state="translated">&lt;code&gt;cold&lt;/code&gt; и &lt;code&gt;inline&lt;/code&gt; &lt;a href=&quot;../attributes&quot;&gt;атрибуты&lt;/a&gt; дают предложения для генерации коды таким образом , что может быть быстрее , чем это было бы обойтись без намека. Атрибуты являются только подсказками, и их можно игнорировать.</target>
        </trans-unit>
        <trans-unit id="5e443e8933fc7022a9fff52a5391c70d8fc736a1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;cold&lt;/code&gt; attribute</source>
          <target state="translated">&lt;code&gt;cold&lt;/code&gt; атрибут</target>
        </trans-unit>
        <trans-unit id="f187d03d0870d5f7cf8d911158a2ad4bf8bfb1f1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;const&lt;/code&gt; keyword is also used in raw pointers in combination with &lt;code&gt;mut&lt;/code&gt;, as seen in &lt;code&gt;*const T&lt;/code&gt; and &lt;code&gt;*mut T&lt;/code&gt;. More about &lt;code&gt;const&lt;/code&gt; as used in raw pointers can be read at the Rust docs for the &lt;a href=&quot;primitive.pointer&quot;&gt;pointer primitive&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c647cbb39e778e9b3fee3b9f221a846f5e10198a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;const&lt;/code&gt; keyword is also used in raw pointers in combination with &lt;code&gt;mut&lt;/code&gt;, as seen in &lt;code&gt;*const T&lt;/code&gt; and &lt;code&gt;*mut T&lt;/code&gt;. More about that can be read at the &lt;a href=&quot;primitive.pointer&quot;&gt;pointer&lt;/a&gt; primitive part of the Rust docs.</source>
          <target state="translated">&lt;code&gt;const&lt;/code&gt; Ключевое слово также используется в сырых указателей в комбинации с &lt;code&gt;mut&lt;/code&gt; , как видно из &lt;code&gt;*const T&lt;/code&gt; и &lt;code&gt;*mut T&lt;/code&gt; . Подробнее об этом можно прочитать в части, посвященной &lt;a href=&quot;primitive.pointer&quot;&gt;указателям,&lt;/a&gt; в документации Rust.</target>
        </trans-unit>
        <trans-unit id="90ef70a34f1bf7aa0febc79627f67bbce0e1d9d3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;core&lt;/code&gt; crate is always added to the extern prelude. The &lt;code&gt;std&lt;/code&gt; crate is added as long as the &lt;a href=&quot;../crates-and-source-files#preludes-and-no_std&quot;&gt;&lt;code&gt;no_std&lt;/code&gt;&lt;/a&gt; attribute is not specified in the crate root.</source>
          <target state="translated">&lt;code&gt;core&lt;/code&gt; клеть всегда добавляется к экстерном прелюдии. &lt;code&gt;std&lt;/code&gt; обрешетка добавляют до тех пор , как &lt;a href=&quot;../crates-and-source-files#preludes-and-no_std&quot;&gt; &lt;code&gt;no_std&lt;/code&gt; &lt;/a&gt; атрибут не указан в корне клети.</target>
        </trans-unit>
        <trans-unit id="38acae0d6ab176e191a45e1f1b54faccd4c7f448" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;crate_name&lt;/code&gt; attribute</source>
          <target state="translated">&lt;code&gt;crate_name&lt;/code&gt; атрибут</target>
        </trans-unit>
        <trans-unit id="ef2c8badee302cb0baefa21db745a07eb79b3acf" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;data&lt;/code&gt; pointer can be used to store arbitrary data as required by the executor. This could be e.g. a type-erased pointer to an &lt;code&gt;Arc&lt;/code&gt; that is associated with the task. The value of this poiner will get passed to all functions that are part of the &lt;code&gt;vtable&lt;/code&gt; as the first parameter.</source>
          <target state="translated">&lt;code&gt;data&lt;/code&gt; указатель может быть использован для хранения произвольных данных в соответствии с требованиями исполнителя. Это может быть, например, стираемый указатель на &lt;code&gt;Arc&lt;/code&gt; , связанную с задачей. Значение этого указателя будет передано всем функциям, которые являются частью &lt;code&gt;vtable&lt;/code&gt; , в качестве первого параметра.</target>
        </trans-unit>
        <trans-unit id="9e90fa7bb07af3f80ba061dbc0af88db5a79ba76" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;data&lt;/code&gt; pointer can be used to store arbitrary data as required by the executor. This could be e.g. a type-erased pointer to an &lt;code&gt;Arc&lt;/code&gt; that is associated with the task. The value of this pointer will get passed to all functions that are part of the &lt;code&gt;vtable&lt;/code&gt; as the first parameter.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a7af61314557c2255ce30f13387bf574343b8476" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;dbg!(..)&lt;/code&gt; macro moves the input:</source>
          <target state="translated">&lt;code&gt;dbg!(..)&lt;/code&gt; Макрос перемещает вход:</target>
        </trans-unit>
        <trans-unit id="b7a4dd4c094bb75a82ed633489f0ec96c82a6296" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;dbg!&lt;/code&gt; macro works exactly the same in release builds. This is useful when debugging issues that only occur in release builds or when debugging in release mode is significantly faster.</source>
          <target state="translated">&lt;code&gt;dbg!&lt;/code&gt; макрос работает точно так же в сборках релизов. Это полезно при отладке проблем, которые возникают только в сборках выпуска, или когда отладка в режиме выпуска выполняется значительно быстрее.</target>
        </trans-unit>
        <trans-unit id="5a03c825d089a243f66f60fd9869adfb4b5c6857" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;deprecated&lt;/code&gt; attribute</source>
          <target state="translated">&lt;code&gt;deprecated&lt;/code&gt; атрибут</target>
        </trans-unit>
        <trans-unit id="8b0ffc1f78b8eb9694b4e7509ecdd919acc0c0cf" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;deprecated&lt;/code&gt; attribute can only be present &lt;strong&gt;once&lt;/strong&gt; on an item.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4c348bd3f38f8d7b286030ed2d1f972d4a02706b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;deprecated&lt;/code&gt; attribute has several forms:</source>
          <target state="translated">&lt;code&gt;deprecated&lt;/code&gt; атрибут имеет несколько форм:</target>
        </trans-unit>
        <trans-unit id="44c311ce3d12b2d5a8a0632c6cd020f999b4ee16" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;deprecated&lt;/code&gt; attribute may be applied to any &lt;a href=&quot;../items&quot;&gt;item&lt;/a&gt;, &lt;a href=&quot;../items/traits&quot;&gt;trait item&lt;/a&gt;, &lt;a href=&quot;../items/enumerations&quot;&gt;enum variant&lt;/a&gt;, &lt;a href=&quot;../items/structs&quot;&gt;struct field&lt;/a&gt;, &lt;a href=&quot;../items/external-blocks&quot;&gt;external block item&lt;/a&gt;, or &lt;a href=&quot;../macros-by-example&quot;&gt;macro definition&lt;/a&gt;. It cannot be applied to &lt;a href=&quot;../items/implementations#trait-implementations&quot;&gt;trait implementation items&lt;/a&gt;. When applied to an item containing other items, such as a &lt;a href=&quot;../items/modules&quot;&gt;module&lt;/a&gt; or &lt;a href=&quot;../items/implementations&quot;&gt;implementation&lt;/a&gt;, all child items inherit the deprecation attribute.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f1d23eb4050e4bb4bd6008dd3e0216cd81ba2cd1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;deprecated&lt;/code&gt; attribute may be applied to any &lt;a href=&quot;../items&quot;&gt;item&lt;/a&gt;, &lt;a href=&quot;../items/traits&quot;&gt;trait item&lt;/a&gt;, &lt;a href=&quot;../items/enumerations&quot;&gt;enum variant&lt;/a&gt;, &lt;a href=&quot;../items/structs&quot;&gt;struct field&lt;/a&gt;, or &lt;a href=&quot;../items/external-blocks&quot;&gt;external block item&lt;/a&gt;. It cannot be applied to &lt;a href=&quot;../items/implementations#trait-implementations&quot;&gt;trait implementation items&lt;/a&gt;. When applied to an item containing other items, such as a &lt;a href=&quot;../items/modules&quot;&gt;module&lt;/a&gt; or &lt;a href=&quot;../items/implementations&quot;&gt;implementation&lt;/a&gt;, all child items inherit the deprecation attribute.</source>
          <target state="translated">&lt;code&gt;deprecated&lt;/code&gt; атрибут может быть применен к любому &lt;a href=&quot;../items&quot;&gt;пункту&lt;/a&gt; , &lt;a href=&quot;../items/traits&quot;&gt;признак элемента&lt;/a&gt; , &lt;a href=&quot;../items/enumerations&quot;&gt;перечисление варианта&lt;/a&gt; , &lt;a href=&quot;../items/structs&quot;&gt;полю структуры&lt;/a&gt; или &lt;a href=&quot;../items/external-blocks&quot;&gt;внешнему элементу блока&lt;/a&gt; . Его нельзя применить к &lt;a href=&quot;../items/implementations#trait-implementations&quot;&gt;элементам реализации трейта&lt;/a&gt; . При применении к элементу, содержащему другие элементы, например &lt;a href=&quot;../items/modules&quot;&gt;модулю&lt;/a&gt; или &lt;a href=&quot;../items/implementations&quot;&gt;реализации&lt;/a&gt; , все дочерние элементы наследуют атрибут устаревания.</target>
        </trans-unit>
        <trans-unit id="6e7f4030e080734f98683be5c8344d101d0992db" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;dev&lt;/code&gt; and &lt;code&gt;release&lt;/code&gt; shown in this build output indicate that the compiler is using different profiles.</source>
          <target state="translated">&lt;code&gt;dev&lt;/code&gt; и &lt;code&gt;release&lt;/code&gt; показано на этом выходе сборки указывают на то , что компилятор использует различные профили.</target>
        </trans-unit>
        <trans-unit id="2bcbec4aff44a7472a393bc8eca9c7c00034401d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;drop&lt;/code&gt; method is called when &lt;code&gt;_x&lt;/code&gt; goes out of scope, and therefore &lt;code&gt;main&lt;/code&gt; prints &lt;code&gt;Dropping!&lt;/code&gt;.</source>
          <target state="translated">Метод &lt;code&gt;drop&lt;/code&gt; вызывается, когда &lt;code&gt;_x&lt;/code&gt; выходит за пределы области видимости, и поэтому &lt;code&gt;main&lt;/code&gt; печатает &lt;code&gt;Dropping!&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="aa3edbdb8ad85c4d37e55b2e809f2f18d6f4e045" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;dst&lt;/code&gt; path will be a directory symbolic link pointing to the &lt;code&gt;src&lt;/code&gt; path.</source>
          <target state="translated">Путь &lt;code&gt;dst&lt;/code&gt; будет символической ссылкой каталога, указывающей на путь &lt;code&gt;src&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f8ab040b8a001ca82f66534b2d20a3b8892fd2dc" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;dst&lt;/code&gt; path will be a file symbolic link pointing to the &lt;code&gt;src&lt;/code&gt; path.</source>
          <target state="translated">Путь &lt;code&gt;dst&lt;/code&gt; будет символической ссылкой файла, указывающей на путь &lt;code&gt;src&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f0ecd1a2ccd0de8765e1ce7cbb8fab53800f6ce6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;dst&lt;/code&gt; path will be a link pointing to the &lt;code&gt;src&lt;/code&gt; path. Note that systems often require these two paths to both be located on the same filesystem.</source>
          <target state="translated">Путь &lt;code&gt;dst&lt;/code&gt; будет ссылкой, указывающей на путь &lt;code&gt;src&lt;/code&gt; . Обратите внимание, что системы часто требуют, чтобы эти два пути находились в одной файловой системе.</target>
        </trans-unit>
        <trans-unit id="b0f3651131fc6e4c0e98108eb60e32485bb1899b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;dst&lt;/code&gt; path will be a symbolic link pointing to the &lt;code&gt;src&lt;/code&gt; path.</source>
          <target state="translated">Путь &lt;code&gt;dst&lt;/code&gt; будет символической ссылкой, указывающей на путь &lt;code&gt;src&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3c07e52fcb5c94a3c499bbc6e95804ccd5a8bfc6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;dst&lt;/code&gt; path will be a symbolic link pointing to the &lt;code&gt;src&lt;/code&gt; path. On Windows, this will be a file symlink, not a directory symlink; for this reason, the platform-specific &lt;a href=&quot;../os/unix/fs/fn.symlink&quot;&gt;&lt;code&gt;std::os::unix::fs::symlink&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../os/windows/fs/fn.symlink_file&quot;&gt;&lt;code&gt;std::os::windows::fs::symlink_file&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;../os/windows/fs/fn.symlink_dir&quot;&gt;&lt;code&gt;symlink_dir&lt;/code&gt;&lt;/a&gt; should be used instead to make the intent explicit.</source>
          <target state="translated">Путь &lt;code&gt;dst&lt;/code&gt; будет символической ссылкой, указывающей на путь &lt;code&gt;src&lt;/code&gt; . В Windows это будет символическая ссылка на файл, а не на каталог; по этой причине для &lt;a href=&quot;../os/windows/fs/fn.symlink_file&quot;&gt; &lt;code&gt;std::os::windows::fs::symlink_file&lt;/code&gt; &lt;/a&gt;&lt;a href=&quot;../os/windows/fs/fn.symlink_dir&quot;&gt; &lt;code&gt;symlink_dir&lt;/code&gt; &lt;/a&gt; следует использовать зависящие от платформы &lt;a href=&quot;../os/unix/fs/fn.symlink&quot;&gt; &lt;code&gt;std::os::unix::fs::symlink&lt;/code&gt; &lt;/a&gt; и std :: os :: windows :: fs :: symlink_file или symlink_dir .</target>
        </trans-unit>
        <trans-unit id="fce5aa6e4c6fe0d2a117a0ec0a2f7f52bfd2748e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;dyn&lt;/code&gt; keyword is used to highlight that calls to methods on the associated &lt;code&gt;Trait&lt;/code&gt; are dynamically dispatched. To use the trait this way, it must be 'object safe'.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f31eeeb70d8a71f4b93bd89156c38bf0e5709ff2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;edition&lt;/code&gt; key in &lt;em&gt;Cargo.toml&lt;/em&gt; indicates which edition the compiler should use for your code. If the key doesn&amp;rsquo;t exist, Rust uses &lt;code&gt;2015&lt;/code&gt; as the edition value for backward compatibility reasons.</source>
          <target state="translated">&lt;code&gt;edition&lt;/code&gt; ключ в &lt;em&gt;Cargo.toml&lt;/em&gt; указывает , какой выпуск компилятор должен использовать для вашего кода. Если ключ не существует, Rust использует &lt;code&gt;2015&lt;/code&gt; в качестве значения выпуска по причинам обратной совместимости.</target>
        </trans-unit>
        <trans-unit id="d4302d0f2edafc20c30c1bca4c608a973532a107" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;else&lt;/code&gt; block of an &lt;code&gt;if&lt;/code&gt; expression.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="25d57c60dcf697c3f5bb61f1ff343393baeeb72f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;entry&lt;/code&gt; API is intended to provide an efficient mechanism for manipulating the contents of a map conditionally on the presence of a key or not. The primary motivating use case for this is to provide efficient accumulator maps. For instance, if one wishes to maintain a count of the number of times each key has been seen, they will have to perform some conditional logic on whether this is the first time the key has been seen or not. Normally, this would require a &lt;code&gt;find&lt;/code&gt; followed by an &lt;code&gt;insert&lt;/code&gt;, effectively duplicating the search effort on each insertion.</source>
          <target state="translated">&lt;code&gt;entry&lt;/code&gt; API предназначен для обеспечения эффективного механизма для манипулирования содержимого карты условно на наличии ключа или нет. Основной мотивирующий вариант использования для этого - предоставление эффективных карт аккумуляторов. Например, если кто-то хочет вести подсчет количества раз, когда каждый ключ был замечен, он должен будет выполнить некоторую условную логику, определяющую, был ли это первый раз, когда ключ был замечен или нет. Обычно это требует &lt;code&gt;find&lt;/code&gt; за которым следует &lt;code&gt;insert&lt;/code&gt; , эффективно дублируя усилия поиска при каждой вставке.</target>
        </trans-unit>
        <trans-unit id="f625c5b9aa8efa15984a630e2609a8460845d869" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;enum&lt;/code&gt; type is analogous to a &lt;code&gt;data&lt;/code&gt; constructor declaration in ML, or a &lt;em&gt;pick ADT&lt;/em&gt; in Limbo.</source>
          <target state="translated">Тип &lt;code&gt;enum&lt;/code&gt; аналогичен объявлению конструктора &lt;code&gt;data&lt;/code&gt; в ML или &lt;em&gt;ADT выбора&lt;/em&gt; в Limbo.</target>
        </trans-unit>
        <trans-unit id="a4c06e2ed2dc5ac68975592625d2fc4a6fa31065" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;env::args&lt;/code&gt; function returns an iterator! Rather than collecting the iterator values into a vector and then passing a slice to &lt;code&gt;Config::new&lt;/code&gt;, now we&amp;rsquo;re passing ownership of the iterator returned from &lt;code&gt;env::args&lt;/code&gt; to &lt;code&gt;Config::new&lt;/code&gt; directly.</source>
          <target state="translated">Функция &lt;code&gt;env::args&lt;/code&gt; возвращает итератор! Вместо того, чтобы собирать значения итератора в вектор и затем передавать срез в &lt;code&gt;Config::new&lt;/code&gt; , теперь мы напрямую передаем право собственности на итератор, возвращенный из &lt;code&gt;env::args&lt;/code&gt; в &lt;code&gt;Config::new&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8c4edba08b3e0cbdebf585d9d18019162245f0c1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;execute&lt;/code&gt; method will send the job it wants to execute down the sending side of the channel.</source>
          <target state="translated">Метод &lt;code&gt;execute&lt;/code&gt; отправит задание, которое он хочет выполнить, по отправляющей стороне канала.</target>
        </trans-unit>
        <trans-unit id="f04efaa242b2b0657b1281616eed7892b34b84f3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;expensive_test&lt;/code&gt; function is listed as &lt;code&gt;ignored&lt;/code&gt;. If we want to run only the ignored tests, we can use &lt;code&gt;cargo test -- --ignored&lt;/code&gt;:</source>
          <target state="translated">Функция &lt;code&gt;expensive_test&lt;/code&gt; указана как &lt;code&gt;ignored&lt;/code&gt; . Если мы хотим запускать только игнорируемые тесты, мы можем использовать &lt;code&gt;cargo test -- --ignored&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="b3f7670e25e83de589c198657dfe09fdc1e175dc" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;export_name&lt;/code&gt; attribute</source>
          <target state="translated">&lt;code&gt;export_name&lt;/code&gt; атрибут</target>
        </trans-unit>
        <trans-unit id="71ce9eba53db805fddc2d08a297018a65234c4f3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;extern&lt;/code&gt; function qualifier allows providing function &lt;em&gt;definitions&lt;/em&gt; that can be called with a particular ABI:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="40efbff38e084ea29f3140f45238b8f3a1480902" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;extern&lt;/code&gt; keyword is used in two places in Rust. One is in conjunction with the &lt;a href=&quot;index&quot;&gt;&lt;code&gt;crate&lt;/code&gt;&lt;/a&gt; keyword to make your Rust code aware of other Rust crates in your project, i.e., &lt;code&gt;extern crate lazy_static;&lt;/code&gt;. The other use is in foreign function interfaces (FFI).</source>
          <target state="translated">&lt;code&gt;extern&lt;/code&gt; ключевое слово используется в двух местах в Русте. Один из них используется в сочетании с ключевым словом &lt;a href=&quot;index&quot;&gt; &lt;code&gt;crate&lt;/code&gt; ,&lt;/a&gt; чтобы ваш код Rust знал о других ящиках Rust в вашем проекте, то есть &lt;code&gt;extern crate lazy_static;&lt;/code&gt; . Другое использование - в интерфейсах внешних функций (FFI).</target>
        </trans-unit>
        <trans-unit id="e4b4130d453476128e8ae98130baa92b7675ca5c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;extern&lt;/code&gt; keyword is used in two places in Rust. One is in conjunction with the &lt;a href=&quot;keyword.crate&quot;&gt;&lt;code&gt;crate&lt;/code&gt;&lt;/a&gt; keyword to make your Rust code aware of other Rust crates in your project, i.e., &lt;code&gt;extern crate lazy_static;&lt;/code&gt;. The other use is in foreign function interfaces (FFI).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="80a6e01d93b27f65515594890e0091001ba7b217" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;feature&lt;/code&gt; attribute only accept a &quot;feature flag&quot; and can only be used on nightly. Example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="36584ecca666e59936c11f071bcfcb0da92fd4b7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;feature&lt;/code&gt; attribute was badly formed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="424a7adcc55a187f305df277831d5dda5afa7154" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ffi_const&lt;/code&gt; attribute can only be used on foreign function declarations which have no side effects except for their return value:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f9fac3c8fa0259e175ffb5e9aab803c7bd9140ac" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ffi_const&lt;/code&gt; attribute was used on something other than a foreign function declaration.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bfe6d270783e8b73023767bbcd8ed3a773bacf0d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ffi_pure&lt;/code&gt; attribute can only be used on foreign functions which do not have side effects or infinite loops:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="883b8dfd3c5fc179185e1d061b052f5f3e0fb52a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ffi_pure&lt;/code&gt; attribute was used on a non-foreign function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e96870e73ec5eb32cc1bdf8256711d63dccde7e0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;fix_incorrect_order&lt;/code&gt; function is in the &lt;code&gt;back_of_house&lt;/code&gt; module, so we can use &lt;code&gt;super&lt;/code&gt; to go to the parent module of &lt;code&gt;back_of_house&lt;/code&gt;, which in this case is &lt;code&gt;crate&lt;/code&gt;, the root. From there, we look for &lt;code&gt;serve_order&lt;/code&gt; and find it. Success! We think the &lt;code&gt;back_of_house&lt;/code&gt; module and the &lt;code&gt;serve_order&lt;/code&gt; function are likely to stay in the same relationship to each other and get moved together should we decide to reorganize the crate&amp;rsquo;s module tree. Therefore, we used &lt;code&gt;super&lt;/code&gt; so we&amp;rsquo;ll have fewer places to update code in the future if this code gets moved to a different module.</source>
          <target state="translated">Функция &lt;code&gt;fix_incorrect_order&lt;/code&gt; находится в модуле &lt;code&gt;back_of_house&lt;/code&gt; , поэтому мы можем использовать &lt;code&gt;super&lt;/code&gt; для перехода к родительскому модулю &lt;code&gt;back_of_house&lt;/code&gt; , которым в данном случае является &lt;code&gt;crate&lt;/code&gt; , корень. Оттуда мы ищем &lt;code&gt;serve_order&lt;/code&gt; и находим его. Успех! Мы считаем , что &lt;code&gt;back_of_house&lt;/code&gt; модуль и &lt;code&gt;serve_order&lt;/code&gt; функция, вероятно, останутся в том же отношении друг к другу и перемещаются вместе должны мы решили реорганизовать модуль дерева ящика в. Поэтому мы использовали &lt;code&gt;super&lt;/code&gt; , поэтому у нас будет меньше мест для обновления кода в будущем, если этот код будет перемещен в другой модуль.</target>
        </trans-unit>
        <trans-unit id="8941a23b194692ed51f3b950de07285880e660a7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;fn&lt;/code&gt; syntax declares a new function, the parentheses, &lt;code&gt;()&lt;/code&gt;, indicate there are no parameters, and the curly bracket, &lt;code&gt;{&lt;/code&gt;, starts the body of the function.</source>
          <target state="translated">&lt;code&gt;fn&lt;/code&gt; синтаксис объявляет новую функцию, круглые скобки, &lt;code&gt;()&lt;/code&gt; , указывать нет никаких параметров, и фигурные скобки, &lt;code&gt;{&lt;/code&gt; , начинается тело функции.</target>
        </trans-unit>
        <trans-unit id="2ec5406eba98b65177f08bb6b301125802a344f0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;for&lt;/code&gt; keyword is used in many syntactic locations:</source>
          <target state="translated">&lt;code&gt;for&lt;/code&gt; ключевого слова используются во многих синтаксических местах:</target>
        </trans-unit>
        <trans-unit id="f09d76fe1ac31bb0c6ea4013cf20271ea27e1d4e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;for&lt;/code&gt; loop variable is now named &lt;code&gt;_i&lt;/code&gt;, and the warning no longer appears.</source>
          <target state="translated">&lt;code&gt;for&lt;/code&gt; переменного цикла не теперь называется &lt;code&gt;_i&lt;/code&gt; , и больше не появляется предупреждение.</target>
        </trans-unit>
        <trans-unit id="05236db55a3c27bea79ddd94d4c11b4238339e3a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;forbid&lt;/code&gt; lint setting, like &lt;code&gt;deny&lt;/code&gt;, turns the corresponding compiler warning into a hard error. Unlike &lt;code&gt;deny&lt;/code&gt;, &lt;code&gt;forbid&lt;/code&gt; prevents itself from being overridden by inner attributes.</source>
          <target state="translated">Настройка &lt;code&gt;forbid&lt;/code&gt; lint, как и &lt;code&gt;deny&lt;/code&gt; , превращает соответствующее предупреждение компилятора в серьезную ошибку. В отличие от &lt;code&gt;deny&lt;/code&gt; , &lt;code&gt;forbid&lt;/code&gt; запрещает переопределение внутренними атрибутами.</target>
        </trans-unit>
        <trans-unit id="4235fdb48267c248121e84a51ecfc4901ad84de8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;format&lt;/code&gt; function takes an &lt;a href=&quot;struct.arguments&quot;&gt;&lt;code&gt;Arguments&lt;/code&gt;&lt;/a&gt; struct and returns the resulting formatted string.</source>
          <target state="translated">Функция &lt;code&gt;format&lt;/code&gt; принимает структуру &lt;a href=&quot;struct.arguments&quot;&gt; &lt;code&gt;Arguments&lt;/code&gt; &lt;/a&gt; и возвращает результирующую отформатированную строку.</target>
        </trans-unit>
        <trans-unit id="d0e2c1abc11834d5ec0f9413abedb6a8d1f2b1d6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;from&lt;/code&gt; file does not exist.</source>
          <target state="translated">&lt;code&gt;from&lt;/code&gt; файла не существует.</target>
        </trans-unit>
        <trans-unit id="0c95afec6a5645bced705f13162ada21e2af597c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;from&lt;/code&gt; path is not a file.</source>
          <target state="translated">Путь &lt;code&gt;from&lt;/code&gt; не является файлом.</target>
        </trans-unit>
        <trans-unit id="6acb8d35118f04b02cccbeee4ae943f064bc37b5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;global_allocator&lt;/code&gt; attribute</source>
          <target state="translated">&lt;code&gt;global_allocator&lt;/code&gt; атрибут</target>
        </trans-unit>
        <trans-unit id="ae2c6463795dadd5e649f9eb12f49008495df3a0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;hash_builder&lt;/code&gt; passed should implement the &lt;a href=&quot;../../hash/trait.buildhasher&quot;&gt;&lt;code&gt;BuildHasher&lt;/code&gt;&lt;/a&gt; trait for the HashMap to be useful, see its documentation for details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5b0ca98b2928cdd13f0ccd74c40e39e4e68ec9cc" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;hash_builder&lt;/code&gt; passed should implement the &lt;a href=&quot;../hash/trait.buildhasher&quot;&gt;&lt;code&gt;BuildHasher&lt;/code&gt;&lt;/a&gt; trait for the HashMap to be useful, see its documentation for details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c35c9498a5a0a48423b3c0138b12569234cd1c61" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;hello_macro_derive&lt;/code&gt; function first converts the &lt;code&gt;input&lt;/code&gt; from a &lt;code&gt;TokenStream&lt;/code&gt; to a data structure that we can then interpret and perform operations on. This is where &lt;code&gt;syn&lt;/code&gt; comes into play. The &lt;code&gt;parse&lt;/code&gt; function in &lt;code&gt;syn&lt;/code&gt; takes a &lt;code&gt;TokenStream&lt;/code&gt; and returns a &lt;code&gt;DeriveInput&lt;/code&gt; struct representing the parsed Rust code. Listing 19-32 shows the relevant parts of the &lt;code&gt;DeriveInput&lt;/code&gt; struct we get from parsing the &lt;code&gt;struct Pancakes;&lt;/code&gt; string:</source>
          <target state="translated">Функция &lt;code&gt;hello_macro_derive&lt;/code&gt; сначала преобразует &lt;code&gt;input&lt;/code&gt; из &lt;code&gt;TokenStream&lt;/code&gt; в структуру данных, которую мы затем можем интерпретировать и выполнять операции. Это где &lt;code&gt;syn&lt;/code&gt; входит в игру. &lt;code&gt;parse&lt;/code&gt; функция в &lt;code&gt;syn&lt;/code&gt; принимает &lt;code&gt;TokenStream&lt;/code&gt; и возвращает &lt;code&gt;DeriveInput&lt;/code&gt; структуры , представляющая проанализированный код ржавчины. В листинге 19-32 показаны соответствующие части структуры &lt;code&gt;DeriveInput&lt;/code&gt; ,которые мы получаем в результате синтаксического анализа &lt;code&gt;struct Pancakes;&lt;/code&gt; строка:</target>
        </trans-unit>
        <trans-unit id="004c835aa77c1c8e124a5716a58b7a6bffdd04f8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;hello_macro_derive&lt;/code&gt; function will be called when a user of our library specifies &lt;code&gt;#[derive(HelloMacro)]&lt;/code&gt; on a type. This is possible because we&amp;rsquo;ve annotated the &lt;code&gt;hello_macro_derive&lt;/code&gt; function here with &lt;code&gt;proc_macro_derive&lt;/code&gt; and specified the name, &lt;code&gt;HelloMacro&lt;/code&gt;, which matches our trait name; this is the convention most procedural macros follow.</source>
          <target state="translated">Функция &lt;code&gt;hello_macro_derive&lt;/code&gt; будет вызываться, когда пользователь нашей библиотеки указывает &lt;code&gt;#[derive(HelloMacro)]&lt;/code&gt; для типа. Это возможно, потому что мы аннотировали функцию &lt;code&gt;hello_macro_derive&lt;/code&gt; здесь с помощью &lt;code&gt;proc_macro_derive&lt;/code&gt; и указали имя &lt;code&gt;HelloMacro&lt;/code&gt; , которое соответствует нашему имени признака; это соглашение, которому следует большинство процедурных макросов.</target>
        </trans-unit>
        <trans-unit id="f6187e2c81223b9029c3a44a9c821bc39754afaa" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;if let&lt;/code&gt; syntax lets you combine &lt;code&gt;if&lt;/code&gt; and &lt;code&gt;let&lt;/code&gt; into a less verbose way to handle values that match one pattern while ignoring the rest. Consider the program in Listing 6-6 that matches on an &lt;code&gt;Option&amp;lt;u8&amp;gt;&lt;/code&gt; value but only wants to execute code if the value is 3.</source>
          <target state="translated">&lt;code&gt;if let&lt;/code&gt; синтаксис позволяет объединить , &lt;code&gt;if&lt;/code&gt; и &lt;code&gt;let&lt;/code&gt; в менее многословным способ значений дескрипторов , которые соответствуют одному шаблону, игнорируя все остальное. Рассмотрим программу в листинге 6-6, которая соответствует значению &lt;code&gt;Option&amp;lt;u8&amp;gt;&lt;/code&gt; но хочет выполнить код, только если значение равно 3.</target>
        </trans-unit>
        <trans-unit id="4dd0a50c18a24fd3e6c3d1653fdf8d2add1e5c54" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;if&lt;/code&gt; condition evaluates to a value of &lt;code&gt;3&lt;/code&gt; this time, and Rust throws an error:</source>
          <target state="translated">На этот &lt;code&gt;if&lt;/code&gt; условие if имеет значение &lt;code&gt;3&lt;/code&gt; , и Rust выдает ошибку:</target>
        </trans-unit>
        <trans-unit id="3b97788abf2717f652bd87cae2841d2689fe301c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;if&lt;/code&gt; expression checks whether our value is out of range, tells the user about the problem, and calls &lt;code&gt;continue&lt;/code&gt; to start the next iteration of the loop and ask for another guess. After the &lt;code&gt;if&lt;/code&gt; expression, we can proceed with the comparisons between &lt;code&gt;guess&lt;/code&gt; and the secret number knowing that &lt;code&gt;guess&lt;/code&gt; is between 1 and 100.</source>
          <target state="translated">В &lt;code&gt;if&lt;/code&gt; выражение проверяет , является ли наше значение вне диапазона, сообщает пользователю о проблеме, и призывает &lt;code&gt;continue&lt;/code&gt; , чтобы начать следующую итерацию цикла и попросить другого предположения. После выражения &lt;code&gt;if&lt;/code&gt; мы можем приступить к сравнению &lt;code&gt;guess&lt;/code&gt; и секретного числа, зная, что &lt;code&gt;guess&lt;/code&gt; находится между 1 и 100.</target>
        </trans-unit>
        <trans-unit id="21d4200f741c0e5d495167ba918e66c0fa127463" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;if&lt;/code&gt; keyword is used in one other place in Rust, namely as a part of pattern matching itself, allowing patterns such as &lt;code&gt;Some(x) if x &amp;gt; 200&lt;/code&gt; to be used.</source>
          <target state="translated">&lt;code&gt;if&lt;/code&gt; используется ключевое слово в одном другом месте в Русте, а именно в качестве части шаблону себя, позволяя модели , такие как &lt;code&gt;Some(x) if x &amp;gt; 200&lt;/code&gt; , который будет использоваться.</target>
        </trans-unit>
        <trans-unit id="60fa964e136b0f0fd7616e520f7abaf2ebfa7111" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ignore&lt;/code&gt; attribute</source>
          <target state="translated">&lt;code&gt;ignore&lt;/code&gt; атрибут</target>
        </trans-unit>
        <trans-unit id="1f363aa597e809eee39b1326a49009f8ed22190d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ignore&lt;/code&gt; attribute may optionally be written with the &lt;a href=&quot;../attributes#meta-item-attribute-syntax&quot;&gt;&lt;em&gt;MetaNameValueStr&lt;/em&gt;&lt;/a&gt; syntax to specify a reason why the test is ignored.</source>
          <target state="translated">&lt;code&gt;ignore&lt;/code&gt; атрибут необязательно может быть записан с &lt;a href=&quot;../attributes#meta-item-attribute-syntax&quot;&gt;&lt;em&gt;MetaNameValueStr&lt;/em&gt;&lt;/a&gt; синтаксиса , чтобы указать причину , почему тест игнорируется.</target>
        </trans-unit>
        <trans-unit id="db8fdc6685b8fc701d318f4f3dec52f0b9a4e868" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;impl Trait&lt;/code&gt; return type captures lifetime parameters that do not appear within the &lt;code&gt;impl Trait&lt;/code&gt; itself.</source>
          <target state="translated">В &lt;code&gt;impl Trait&lt;/code&gt; возвращаемые параметры захваты типа прижизненные , которые не появляются в &lt;code&gt;impl Trait&lt;/code&gt; сам.</target>
        </trans-unit>
        <trans-unit id="c9150ca2fdc92a2e0f4ccf4f986d692afa5493d6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;impl Trait&lt;/code&gt; syntax is convenient and makes for more concise code in simple cases. The trait bound syntax can express more complexity in other cases. For example, we can have two parameters that implement &lt;code&gt;Summary&lt;/code&gt;. Using the &lt;code&gt;impl Trait&lt;/code&gt; syntax looks like this:</source>
          <target state="translated">&lt;code&gt;impl Trait&lt;/code&gt; синтаксис удобен и делает для более краткого кода в простых случаях. Синтаксис с привязкой к признаку может выражать большую сложность в других случаях. Например, у нас может быть два параметра, реализующих &lt;code&gt;Summary&lt;/code&gt; . Использование синтаксиса &lt;code&gt;impl Trait&lt;/code&gt; выглядит так:</target>
        </trans-unit>
        <trans-unit id="778ea7a6b81f5bfa7d87e34cfb75fde414639934" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;impl Trait&lt;/code&gt; syntax works for straightforward cases but is actually syntax sugar for a longer form, which is called a &lt;em&gt;trait bound&lt;/em&gt;; it looks like this:</source>
          <target state="translated">&lt;code&gt;impl Trait&lt;/code&gt; синтаксис работает для простых случаев , но на самом деле синтаксис для более длинной формы, которая называется &lt;em&gt;признаком , связанный&lt;/em&gt; ; это выглядит так:</target>
        </trans-unit>
        <trans-unit id="2ffdcc0f4b373da2777f00eb0b778b9205836471" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;impl&lt;/code&gt; keyword is primarily used to define implementations on types. Inherent implementations are standalone, while trait implementations are used to implement traits for types, or other traits.</source>
          <target state="translated">&lt;code&gt;impl&lt;/code&gt; ключевое слово используется в основном для определения реализации по типам. Собственные реализации являются автономными, в то время как реализации трейтов используются для реализации трейтов для типов или других трейтов.</target>
        </trans-unit>
        <trans-unit id="49b529510ff41b8ce0e4f03d01af2d0795d82946" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;incoming&lt;/code&gt; method on &lt;code&gt;TcpListener&lt;/code&gt; returns an iterator that gives us a sequence of streams (more specifically, streams of type &lt;code&gt;TcpStream&lt;/code&gt;). A single &lt;em&gt;stream&lt;/em&gt; represents an open connection between the client and the server. A &lt;em&gt;connection&lt;/em&gt; is the name for the full request and response process in which a client connects to the server, the server generates a response, and the server closes the connection. As such, &lt;code&gt;TcpStream&lt;/code&gt; will read from itself to see what the client sent and then allow us to write our response to the stream. Overall, this &lt;code&gt;for&lt;/code&gt; loop will process each connection in turn and produce a series of streams for us to handle.</source>
          <target state="translated">&lt;code&gt;incoming&lt;/code&gt; метод на &lt;code&gt;TcpListener&lt;/code&gt; возвращает итератор , который дает нам последовательность потоков (более конкретно, потоки типа &lt;code&gt;TcpStream&lt;/code&gt; ). Один &lt;em&gt;поток&lt;/em&gt; представляет собой открытое соединение между клиентом и сервером. &lt;em&gt;Соединение&lt;/em&gt; является именем для полного запроса и ответ процесса , в котором клиент подключается к серверу, сервер генерирует ответ, и сервер закрывает соединение. Таким образом, &lt;code&gt;TcpStream&lt;/code&gt; будет читать из самого себя, чтобы увидеть, что отправил клиент, а затем позволяет нам записать наш ответ в поток. В целом, этот цикл &lt;code&gt;for&lt;/code&gt; будет обрабатывать каждое соединение по очереди и создавать серию потоков, которые мы будем обрабатывать.</target>
        </trans-unit>
        <trans-unit id="3ae3f99054fefa43fcfe679af5b3d84ea2c62ac1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;inline&lt;/code&gt; attribute</source>
          <target state="translated">&lt;code&gt;inline&lt;/code&gt; атрибут</target>
        </trans-unit>
        <trans-unit id="f0d784eef56974f3daef0d597995f18b5e5f8afb" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;inline&lt;/code&gt; attribute only supports two arguments:</source>
          <target state="translated">&lt;code&gt;inline&lt;/code&gt; атрибут поддерживает только два аргумента:</target>
        </trans-unit>
        <trans-unit id="bc1a141c850728d98b956fd0716ebc10f9ffb6e7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;inline&lt;/code&gt; attribute was malformed.</source>
          <target state="translated">&lt;code&gt;inline&lt;/code&gt; атрибут был неправильно сформирован.</target>
        </trans-unit>
        <trans-unit id="91c34dfeac33c0fc72de6d1c1ac619e7a9084ef1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;instruction_set&lt;/code&gt; attribute only supports two arguments currently:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="65492eab1824c51df92e478cb44c3823042f292f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;instruction_set&lt;/code&gt; attribute was malformed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4788ad11ac891125e5295255c9d02cd7b36750e0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;isize&lt;/code&gt; type is a signed integer type with the same number of bits as the platform's pointer type. The theoretical upper bound on object and array size is the maximum &lt;code&gt;isize&lt;/code&gt; value. This ensures that &lt;code&gt;isize&lt;/code&gt; can be used to calculate differences between pointers into an object or array and can address every byte within an object along with one byte past the end.</source>
          <target state="translated">Тип &lt;code&gt;isize&lt;/code&gt; - это целочисленный тип со знаком с тем же количеством битов, что и тип указателя платформы. Теоретическая верхняя граница размера объекта и массива - это максимальное значение &lt;code&gt;isize&lt;/code&gt; . Это гарантирует, что &lt;code&gt;isize&lt;/code&gt; можно использовать для вычисления различий между указателями на объект или массив и может адресовать каждый байт в объекте вместе с одним байтом после конца.</target>
        </trans-unit>
        <trans-unit id="7d599bd6c4aa9e941662680b3c4cf55e952c7777" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;it_works&lt;/code&gt; function now has a return type, &lt;code&gt;Result&amp;lt;(), String&amp;gt;&lt;/code&gt;. In the body of the function, rather than calling the &lt;code&gt;assert_eq!&lt;/code&gt; macro, we return &lt;code&gt;Ok(())&lt;/code&gt; when the test passes and an &lt;code&gt;Err&lt;/code&gt; with a &lt;code&gt;String&lt;/code&gt; inside when the test fails.</source>
          <target state="translated">Функция &lt;code&gt;it_works&lt;/code&gt; теперь имеет возвращаемый тип &lt;code&gt;Result&amp;lt;(), String&amp;gt;&lt;/code&gt; . В теле функции вместо вызова &lt;code&gt;assert_eq!&lt;/code&gt; макрос, мы возвращаем &lt;code&gt;Ok(())&lt;/code&gt; когда тест проходит, и &lt;code&gt;Err&lt;/code&gt; со &lt;code&gt;String&lt;/code&gt; внутри, когда тест не проходит.</target>
        </trans-unit>
        <trans-unit id="d7cf351f8d0a069e43102c73f4dd09e2f7958bd2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;largest&lt;/code&gt; function has a parameter called &lt;code&gt;list&lt;/code&gt;, which represents any concrete slice of &lt;code&gt;i32&lt;/code&gt; values that we might pass into the function. As a result, when we call the function, the code runs on the specific values that we pass in.</source>
          <target state="translated">Самая &lt;code&gt;largest&lt;/code&gt; функция имеет параметр с именем &lt;code&gt;list&lt;/code&gt; , который представляет любой конкретный фрагмент значений &lt;code&gt;i32&lt;/code&gt; , который мы можем передать в функцию. В результате, когда мы вызываем функцию, код работает с конкретными значениями, которые мы передаем.</target>
        </trans-unit>
        <trans-unit id="29c272390da5b69d23c340bb06b514ca355b63f0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;largest_i32&lt;/code&gt; function is the one we extracted in Listing 10-3 that finds the largest &lt;code&gt;i32&lt;/code&gt; in a slice. The &lt;code&gt;largest_char&lt;/code&gt; function finds the largest &lt;code&gt;char&lt;/code&gt; in a slice. The function bodies have the same code, so let&amp;rsquo;s eliminate the duplication by introducing a generic type parameter in a single function.</source>
          <target state="translated">Самую &lt;code&gt;largest_i32&lt;/code&gt; функцию i32 мы извлекли в листинге 10-3, которая находит самый большой &lt;code&gt;i32&lt;/code&gt; в срезе. Функция &lt;code&gt;largest_char&lt;/code&gt; находит самый большой &lt;code&gt;char&lt;/code&gt; в срезе. Тела функций имеют один и тот же код, поэтому давайте устраним дублирование, введя параметр универсального типа в одну функцию.</target>
        </trans-unit>
        <trans-unit id="d1c6673a10646101d9e252f3f63c9d87dc9cd482" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;len&lt;/code&gt; argument is the number of &lt;strong&gt;elements&lt;/strong&gt;, not the number of bytes.</source>
          <target state="translated">&lt;code&gt;len&lt;/code&gt; аргумент число &lt;strong&gt;элементов&lt;/strong&gt; , а не число байтов.</target>
        </trans-unit>
        <trans-unit id="eabd24b648d02186aedafa8c6e64a26cd4789b21" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;let y = 6&lt;/code&gt; statement does not return a value, so there isn&amp;rsquo;t anything for &lt;code&gt;x&lt;/code&gt; to bind to. This is different from what happens in other languages, such as C and Ruby, where the assignment returns the value of the assignment. In those languages, you can write &lt;code&gt;x = y = 6&lt;/code&gt; and have both &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; have the value &lt;code&gt;6&lt;/code&gt;; that is not the case in Rust.</source>
          <target state="translated">Оператор &lt;code&gt;let y = 6&lt;/code&gt; не возвращает значения, поэтому &lt;code&gt;x&lt;/code&gt; не к чему привязываться. Это отличается от того, что происходит в других языках, таких как C и Ruby, где присваивание возвращает значение присваивания. На этих языках вы можете написать &lt;code&gt;x = y = 6&lt;/code&gt; и указать, что &lt;code&gt;x&lt;/code&gt; и &lt;code&gt;y&lt;/code&gt; имеют значение &lt;code&gt;6&lt;/code&gt; ; в Rust дело обстоит иначе.</target>
        </trans-unit>
        <trans-unit id="38e40fe06999fccdbadcd0aed2907afe5c6e93b4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;lines&lt;/code&gt; method returns an iterator. We&amp;rsquo;ll talk about iterators in depth in &lt;a href=&quot;ch13-02-iterators&quot;&gt;Chapter 13&lt;/a&gt;, but recall that you saw this way of using an iterator in &lt;a href=&quot;ch03-05-control-flow#looping-through-a-collection-with-for&quot;&gt;Listing 3-5&lt;/a&gt;, where we used a &lt;code&gt;for&lt;/code&gt; loop with an iterator to run some code on each item in a collection.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eb368f642161e00040244b9fcf42bf09c020466c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;lines&lt;/code&gt; method returns an iterator. We&amp;rsquo;ll talk about iterators in depth in [Chapter 13][ch13], but recall that you saw this way of using an iterator in &lt;a href=&quot;ch03-05-control-flow#looping-through-a-collection-with-for&quot;&gt;Listing 3-5&lt;/a&gt;, where we used a &lt;code&gt;for&lt;/code&gt; loop with an iterator to run some code on each item in a collection.</source>
          <target state="translated">Метод &lt;code&gt;lines&lt;/code&gt; возвращает итератор. Мы подробно поговорим об итераторах в [Глава 13] [ch13], но помните, что вы видели этот способ использования итератора в &lt;a href=&quot;ch03-05-control-flow#looping-through-a-collection-with-for&quot;&gt;листинге 3-5&lt;/a&gt; , где мы использовали цикл &lt;code&gt;for&lt;/code&gt; с итератором для выполнения некоторого кода для каждого элемента. в коллекции.</target>
        </trans-unit>
        <trans-unit id="eb1d841506acd030675c6922085c83e81e995a8f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;link&lt;/code&gt; attribute</source>
          <target state="translated">&lt;code&gt;link&lt;/code&gt; атрибут</target>
        </trans-unit>
        <trans-unit id="49ce3813b3cc29f6621eed5040dfcafe494f7af6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;link_name&lt;/code&gt; attribute</source>
          <target state="translated">&lt;code&gt;link_name&lt;/code&gt; атрибут</target>
        </trans-unit>
        <trans-unit id="affa85dfaaac9c19595e178102133ab86d473f6f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;link_name&lt;/code&gt; attribute may be specified on declarations inside an &lt;code&gt;extern&lt;/code&gt; block to indicate the symbol to import for the given function or static. It uses the &lt;a href=&quot;../attributes#meta-item-attribute-syntax&quot;&gt;&lt;em&gt;MetaNameValueStr&lt;/em&gt;&lt;/a&gt; syntax to specify the name of the symbol.</source>
          <target state="translated">&lt;code&gt;link_name&lt;/code&gt; атрибут может быть указан деклараций внутри &lt;code&gt;extern&lt;/code&gt; блока , чтобы указать символ для импорта для данной функции или статической. Он использует синтаксис &lt;a href=&quot;../attributes#meta-item-attribute-syntax&quot;&gt;&lt;em&gt;MetaNameValueStr&lt;/em&gt;&lt;/a&gt; для указания имени символа.</target>
        </trans-unit>
        <trans-unit id="76e0be66315f639652150dfe37a31422ede56b88" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;link_section&lt;/code&gt; attribute</source>
          <target state="translated">&lt;code&gt;link_section&lt;/code&gt; атрибут</target>
        </trans-unit>
        <trans-unit id="5d3ac97ce0e51b7500958397678a0747500d6a86" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;locality&lt;/code&gt; argument must be a constant integer and is a temporal locality specifier ranging from (0) - no locality, to (3) - extremely local keep in cache</source>
          <target state="translated">&lt;code&gt;locality&lt;/code&gt; аргумент должен быть постоянным целым числом и временная локальность спецификатор в пределах от (0) - нет населенного пункта, в (3) - исключительно локальные иметь в кэше</target>
        </trans-unit>
        <trans-unit id="08d3f68a2cf00952341cb92b2cabeabf4f7aad60" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;locality&lt;/code&gt; argument must be a constant integer and is a temporal locality specifier ranging from (0) - no locality, to (3) - extremely local keep in cache.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ef1c91d4a25bd321565ee99def8880c9e7e661ee" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;loop&lt;/code&gt; keyword creates an infinite loop. We&amp;rsquo;ll add that now to give users more chances at guessing the number:</source>
          <target state="translated">&lt;code&gt;loop&lt;/code&gt; ключевое слово создает бесконечный цикл. Мы добавим это сейчас, чтобы дать пользователям больше шансов угадать число:</target>
        </trans-unit>
        <trans-unit id="ebe9e1bcc2f0843b5208a2b5109915be71857732" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;loop&lt;/code&gt; keyword tells Rust to execute a block of code over and over again forever or until you explicitly tell it to stop.</source>
          <target state="translated">&lt;code&gt;loop&lt;/code&gt; ключевое слово говорит Rust, чтобы выполнить блок кода снова и снова навсегда или пока вы явно сказать ему , чтобы остановить.</target>
        </trans-unit>
        <trans-unit id="9910971bdcb643aec0b768364519db2f99d5aff4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;macro_use&lt;/code&gt; attribute</source>
          <target state="translated">&lt;code&gt;macro_use&lt;/code&gt; атрибут</target>
        </trans-unit>
        <trans-unit id="c25fb9655125d01a5a1e9d67f7f0780bc361281a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;main&lt;/code&gt; function here creates an instance of the &lt;code&gt;ImportantExcerpt&lt;/code&gt; struct that holds a reference to the first sentence of the &lt;code&gt;String&lt;/code&gt; owned by the variable &lt;code&gt;novel&lt;/code&gt;. The data in &lt;code&gt;novel&lt;/code&gt; exists before the &lt;code&gt;ImportantExcerpt&lt;/code&gt; instance is created. In addition, &lt;code&gt;novel&lt;/code&gt; doesn&amp;rsquo;t go out of scope until after the &lt;code&gt;ImportantExcerpt&lt;/code&gt; goes out of scope, so the reference in the &lt;code&gt;ImportantExcerpt&lt;/code&gt; instance is valid.</source>
          <target state="translated">Здесь &lt;code&gt;main&lt;/code&gt; функция создает экземпляр структуры &lt;code&gt;ImportantExcerpt&lt;/code&gt; , которая содержит ссылку на первое предложение &lt;code&gt;String&lt;/code&gt; принадлежащей переменной &lt;code&gt;novel&lt;/code&gt; . Данные в &lt;code&gt;novel&lt;/code&gt; существуют до создания экземпляра &lt;code&gt;ImportantExcerpt&lt;/code&gt; . Кроме того, &lt;code&gt;novel&lt;/code&gt; не выходит за пределы области действия до тех пор, пока не выходит за пределы области действия &lt;code&gt;ImportantExcerpt&lt;/code&gt; , поэтому ссылка в экземпляре &lt;code&gt;ImportantExcerpt&lt;/code&gt; действительна.</target>
        </trans-unit>
        <trans-unit id="db5fe1609c8c74f709a4f1880a24bb8f27550e1d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;main&lt;/code&gt; function is special, and there are restrictions on what its return type must be. One valid return type for main is &lt;code&gt;()&lt;/code&gt;, and conveniently, another valid return type is &lt;code&gt;Result&amp;lt;T, E&amp;gt;&lt;/code&gt;, as shown here:</source>
          <target state="translated">Функция &lt;code&gt;main&lt;/code&gt; особенная, и существуют ограничения на ее возвращаемый тип. Один допустимый тип возврата для main - &lt;code&gt;()&lt;/code&gt; , а другой допустимый тип возврата - &lt;code&gt;Result&amp;lt;T, E&amp;gt;&lt;/code&gt; , как показано здесь:</target>
        </trans-unit>
        <trans-unit id="df8be9695315286ea699a84bc57bf274e0dcbb5a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;main&lt;/code&gt; function prototype should never take arguments. Example:</source>
          <target state="translated">&lt;code&gt;main&lt;/code&gt; прототип функции не должен принимать аргументы. Пример:</target>
        </trans-unit>
        <trans-unit id="db6afd48cca2e467a026116d5334792843766266" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;main&lt;/code&gt; function was defined with generic parameters.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b77f7c754f9c38d3041a1e299a31ef7eeecfa144" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;main&lt;/code&gt; function was incorrectly declared.</source>
          <target state="translated">&lt;code&gt;main&lt;/code&gt; функция была неправильно объявлена.</target>
        </trans-unit>
        <trans-unit id="43e2fa6b27c55d262177050d71a4a20b71217bb8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;move&lt;/code&gt; closure is often used alongside &lt;code&gt;thread::spawn&lt;/code&gt; because it allows you to use data from one thread in another thread.</source>
          <target state="translated">&lt;code&gt;move&lt;/code&gt; закрытие часто используется вместе с &lt;code&gt;thread::spawn&lt;/code&gt; , потому что позволяет использовать данные из одного потока в другой нити.</target>
        </trans-unit>
        <trans-unit id="619f2d182d04cd2437b9280f0034a655e725227f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;mpsc::channel&lt;/code&gt; function returns a tuple, the first element of which is the sending end and the second element is the receiving end. The abbreviations &lt;code&gt;tx&lt;/code&gt; and &lt;code&gt;rx&lt;/code&gt; are traditionally used in many fields for &lt;em&gt;transmitter&lt;/em&gt; and &lt;em&gt;receiver&lt;/em&gt; respectively, so we name our variables as such to indicate each end. We&amp;rsquo;re using a &lt;code&gt;let&lt;/code&gt; statement with a pattern that destructures the tuples; we&amp;rsquo;ll discuss the use of patterns in &lt;code&gt;let&lt;/code&gt; statements and destructuring in Chapter 18. Using a &lt;code&gt;let&lt;/code&gt; statement this way is a convenient approach to extract the pieces of the tuple returned by &lt;code&gt;mpsc::channel&lt;/code&gt;.</source>
          <target state="translated">Функция &lt;code&gt;mpsc::channel&lt;/code&gt; возвращает кортеж, первый элемент которого является передающей стороной, а второй - принимающей стороной. Сокращения &lt;code&gt;tx&lt;/code&gt; и &lt;code&gt;rx&lt;/code&gt; традиционно используются во многих полях для &lt;em&gt;передатчика&lt;/em&gt; и &lt;em&gt;приемника&lt;/em&gt; соответственно, поэтому мы называем наши переменные как таковые, чтобы указать каждый конец. Мы используем оператор &lt;code&gt;let&lt;/code&gt; с шаблоном, который разрушает кортежи; мы обсудим использование шаблонов в операторах &lt;code&gt;let&lt;/code&gt; и деструктурирование в главе 18. Использование оператора &lt;code&gt;let&lt;/code&gt; таким образом является удобным подходом для извлечения частей кортежа, возвращаемого &lt;code&gt;mpsc::channel&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0a5adaf35abd6fb52abc875dfd1ff8ace4487057" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;must_use&lt;/code&gt; attribute</source>
          <target state="translated">&lt;code&gt;must_use&lt;/code&gt; атрибут</target>
        </trans-unit>
        <trans-unit id="4dc21fbdabdadeb25794ca5fcb0a8eb690cc55f3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;must_use&lt;/code&gt; attribute may include a message by using the &lt;a href=&quot;../attributes#meta-item-attribute-syntax&quot;&gt;&lt;em&gt;MetaNameValueStr&lt;/em&gt;&lt;/a&gt; syntax such as &lt;code&gt;#[must_use = &quot;example message&quot;]&lt;/code&gt;. The message will be given alongside the warning.</source>
          <target state="translated">&lt;code&gt;must_use&lt;/code&gt; атрибут может включать в себя сообщение, используя &lt;a href=&quot;../attributes#meta-item-attribute-syntax&quot;&gt;&lt;em&gt;MetaNameValueStr&lt;/em&gt;&lt;/a&gt; синтаксиса , такие как &lt;code&gt;#[must_use = &quot;example message&quot;]&lt;/code&gt; . Сообщение будет отображаться вместе с предупреждением.</target>
        </trans-unit>
        <trans-unit id="fa08dd7bde9ed9336c6bf68b835c76ace5a2b281" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;name&lt;/code&gt; key must be included if &lt;code&gt;kind&lt;/code&gt; is specified.</source>
          <target state="translated">&lt;code&gt;name&lt;/code&gt; ключ должен быть включен , если &lt;code&gt;kind&lt;/code&gt; указан.</target>
        </trans-unit>
        <trans-unit id="4f5d61c5238b80d1372117cdc9301f7c5a015909" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;no_builtins&lt;/code&gt; attribute</source>
          <target state="translated">&lt;code&gt;no_builtins&lt;/code&gt; атрибут</target>
        </trans-unit>
        <trans-unit id="0e25b9ca8aa17342df965438e7d8b3912387ac96" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;no_link&lt;/code&gt; attribute</source>
          <target state="translated">&lt;code&gt;no_link&lt;/code&gt; атрибут</target>
        </trans-unit>
        <trans-unit id="4c0b9a2602cdb8c2f59fe6476a9d0299ede88a3c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;no_main&lt;/code&gt; attribute</source>
          <target state="translated">&lt;code&gt;no_main&lt;/code&gt; атрибут</target>
        </trans-unit>
        <trans-unit id="63ed748c3f1f47aec501358b0494a62e8e33119a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;no_mangle&lt;/code&gt; attribute</source>
          <target state="translated">&lt;code&gt;no_mangle&lt;/code&gt; атрибут</target>
        </trans-unit>
        <trans-unit id="3db3cdb5f8ea826a09ba97c6a8d286d70aec5a65" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;non_exhaustive&lt;/code&gt; attribute uses the &lt;a href=&quot;../attributes#meta-item-attribute-syntax&quot;&gt;&lt;em&gt;MetaWord&lt;/em&gt;&lt;/a&gt; syntax and thus does not take any inputs.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f6746e3c0ec6ce06b907e0392a7e5f26c1647e02" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;not&lt;/code&gt; cfg-predicate was malformed.</source>
          <target state="translated">&lt;code&gt;not&lt;/code&gt; CFG-предикат был неправильно сформирован.</target>
        </trans-unit>
        <trans-unit id="522f2fe5c8ca134ded384cd8e598baad904cbb06" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;not&lt;/code&gt; predicate expects one cfg-pattern. Example:</source>
          <target state="translated">&lt;code&gt;not&lt;/code&gt; предикатные ожидает один CFG-шаблон. Пример:</target>
        </trans-unit>
        <trans-unit id="b32d84af66b0734455999894598a8249aed66fbb" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;number&lt;/code&gt; variable will be bound to a value based on the outcome of the &lt;code&gt;if&lt;/code&gt; expression. Run this code to see what happens:</source>
          <target state="translated">&lt;code&gt;number&lt;/code&gt; переменная будет связана со значением , основанной на результатах , &lt;code&gt;if&lt;/code&gt; выражение. Запустите этот код, чтобы увидеть, что происходит:</target>
        </trans-unit>
        <trans-unit id="60fb1fa966c95caff6ec3f67558fb81ff746c1d4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;op_string_ref&lt;/code&gt; binding has type &lt;code&gt;&amp;amp;Option&amp;lt;&amp;amp;String&amp;gt;&lt;/code&gt; in both cases.</source>
          <target state="translated">&lt;code&gt;op_string_ref&lt;/code&gt; связывания имеет типа &lt;code&gt;&amp;amp;Option&amp;lt;&amp;amp;String&amp;gt;&lt;/code&gt; , в обеих случаях.</target>
        </trans-unit>
        <trans-unit id="2d0c9a8f467995322cb26a15b43a2ed10bd928bc" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;opt-level&lt;/code&gt; setting controls the number of optimizations Rust will apply to your code, with a range of 0 to 3. Applying more optimizations extends compiling time, so if you&amp;rsquo;re in development and compiling your code often, you&amp;rsquo;ll want faster compiling even if the resulting code runs slower. That is the reason the default &lt;code&gt;opt-level&lt;/code&gt; for &lt;code&gt;dev&lt;/code&gt; is &lt;code&gt;0&lt;/code&gt;. When you&amp;rsquo;re ready to release your code, it&amp;rsquo;s best to spend more time compiling. You&amp;rsquo;ll only compile in release mode once, but you&amp;rsquo;ll run the compiled program many times, so release mode trades longer compile time for code that runs faster. That is why the default &lt;code&gt;opt-level&lt;/code&gt; for the &lt;code&gt;release&lt;/code&gt; profile is &lt;code&gt;3&lt;/code&gt;.</source>
          <target state="translated">Параметр &lt;code&gt;opt-level&lt;/code&gt; управляет количеством оптимизаций, которые Rust применит к вашему коду, в диапазоне от 0 до 3. Применение большего количества оптимизаций увеличивает время компиляции, поэтому, если вы разрабатываете и часто компилируете свой код, вам нужно быстрее компиляция, даже если результирующий код работает медленнее. По этой причине &lt;code&gt;opt-level&lt;/code&gt; по умолчанию для &lt;code&gt;dev&lt;/code&gt; равен &lt;code&gt;0&lt;/code&gt; . Когда вы будете готовы выпустить свой код, лучше потратить больше времени на компиляцию. Вы скомпилируете в режиме выпуска только один раз, но вы будете запускать скомпилированную программу много раз, поэтому в режиме выпуска увеличивается время компиляции для кода, который выполняется быстрее. Вот почему &lt;code&gt;opt-level&lt;/code&gt; по умолчанию для профиля &lt;code&gt;release&lt;/code&gt; - &lt;code&gt;3&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6a0e04095b896f42634e32e5783ee8a2f1b36521" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;or_insert&lt;/code&gt; method on &lt;code&gt;Entry&lt;/code&gt; is defined to return a mutable reference to the value for the corresponding &lt;code&gt;Entry&lt;/code&gt; key if that key exists, and if not, inserts the parameter as the new value for this key and returns a mutable reference to the new value. This technique is much cleaner than writing the logic ourselves and, in addition, plays more nicely with the borrow checker.</source>
          <target state="translated">Метод &lt;code&gt;or_insert&lt;/code&gt; в &lt;code&gt;Entry&lt;/code&gt; определен для возврата изменяемой ссылки на значение для соответствующего ключа &lt;code&gt;Entry&lt;/code&gt; , если этот ключ существует, а если нет, вставляет параметр как новое значение для этого ключа и возвращает изменяемую ссылку на новое значение. Этот метод намного чище, чем написание логики самостоятельно, и, кроме того, лучше работает с программой проверки заимствований.</target>
        </trans-unit>
        <trans-unit id="6774c9469b6011fbcb32c16aad7d03e8b6f6c4d5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;panic_handler&lt;/code&gt; attribute</source>
          <target state="translated">&lt;code&gt;panic_handler&lt;/code&gt; атрибут</target>
        </trans-unit>
        <trans-unit id="a6291890b4261d452b074ebd1ea09861364cf569" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;path&lt;/code&gt; attribute</source>
          <target state="translated">&lt;code&gt;path&lt;/code&gt; атрибут</target>
        </trans-unit>
        <trans-unit id="eca9cdb5a96c8de323e434d012e339f61d08ae9a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;path&lt;/code&gt; points at a non-directory file.</source>
          <target state="translated">В &lt;code&gt;path&lt;/code&gt; указывает на файл , не являющийся каталогом.</target>
        </trans-unit>
        <trans-unit id="34ed0df01305ce0f75ec5fd43922003af97a525e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;poll&lt;/code&gt; function is not called repeatedly in a tight loop -- instead, it should only be called when the future indicates that it is ready to make progress (by calling &lt;code&gt;wake()&lt;/code&gt;). If you're familiar with the &lt;code&gt;poll(2)&lt;/code&gt; or &lt;code&gt;select(2)&lt;/code&gt; syscalls on Unix it's worth noting that futures typically do &lt;em&gt;not&lt;/em&gt; suffer the same problems of &quot;all wakeups must poll all events&quot;; they are more like &lt;code&gt;epoll(4)&lt;/code&gt;.</source>
          <target state="translated">Функция &lt;code&gt;poll&lt;/code&gt; не вызывается повторно в замкнутом цикле - вместо этого ее следует вызывать только тогда, когда будущее указывает, что она готова к прогрессу (путем вызова &lt;code&gt;wake()&lt;/code&gt; ). Если вы знакомы с системными вызовами &lt;code&gt;poll(2)&lt;/code&gt; или &lt;code&gt;select(2)&lt;/code&gt; в Unix, стоит отметить, что фьючерсы обычно &lt;em&gt;не&lt;/em&gt; страдают теми же проблемами, что &amp;laquo;все пробуждения должны опрашивать все события&amp;raquo;; они больше похожи на &lt;code&gt;epoll(4)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a4cdf57409266ff4ceaefa41a5aa6a9d06ca0f60" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;poll&lt;/code&gt; method</source>
          <target state="translated">&lt;code&gt;poll&lt;/code&gt; методом</target>
        </trans-unit>
        <trans-unit id="f69f8390bb6f3d4deb2545de4fdfa29877369556" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;prefetch&lt;/code&gt; intrinsic is a hint to the code generator to insert a prefetch instruction if supported; otherwise, it is a no-op. Prefetches have no effect on the behavior of the program but can change its performance characteristics.</source>
          <target state="translated">Внутренняя &lt;code&gt;prefetch&lt;/code&gt; является подсказкой генератору кода для вставки инструкции предварительной выборки, если она поддерживается; в противном случае это не работает. Предварительная выборка не влияет на поведение программы, но может изменить ее характеристики производительности.</target>
        </trans-unit>
        <trans-unit id="fa7fa9cd2241a28cad4fa12a2f135f7ef3c12daf" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;println!&lt;/code&gt; function is only capable of printing to standard output, so we have to use something else to print to standard error.</source>
          <target state="translated">&lt;code&gt;println!&lt;/code&gt; функция может печатать только на стандартный вывод, поэтому нам нужно использовать что-то еще, чтобы распечатать стандартную ошибку.</target>
        </trans-unit>
        <trans-unit id="f554c0d8cd003f0dac64077248339772aef74465" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;println!&lt;/code&gt; macro can do many kinds of formatting, and by default, the curly brackets tell &lt;code&gt;println!&lt;/code&gt; to use formatting known as &lt;code&gt;Display&lt;/code&gt;: output intended for direct end user consumption. The primitive types we&amp;rsquo;ve seen so far implement &lt;code&gt;Display&lt;/code&gt; by default, because there&amp;rsquo;s only one way you&amp;rsquo;d want to show a &lt;code&gt;1&lt;/code&gt; or any other primitive type to a user. But with structs, the way &lt;code&gt;println!&lt;/code&gt; should format the output is less clear because there are more display possibilities: Do you want commas or not? Do you want to print the curly brackets? Should all the fields be shown? Due to this ambiguity, Rust doesn&amp;rsquo;t try to guess what we want, and structs don&amp;rsquo;t have a provided implementation of &lt;code&gt;Display&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;println!&lt;/code&gt; макрос может выполнять множество видов форматирования, и по умолчанию фигурные скобки сообщают &lt;code&gt;println!&lt;/code&gt; использовать форматирование, известное как &lt;code&gt;Display&lt;/code&gt; : вывод, предназначенный для непосредственного использования конечным пользователем. Примитивные типы, которые мы видели до сих пор, по умолчанию реализуют &lt;code&gt;Display&lt;/code&gt; , потому что есть только один способ показать пользователю &lt;code&gt;1&lt;/code&gt; или любой другой примитивный тип. Но со структурами способ &lt;code&gt;println!&lt;/code&gt; следует форматировать вывод менее четким, потому что есть больше возможностей отображения: вы хотите запятые или нет? Хотите распечатать фигурные скобки? Должны ли быть показаны все поля? Из-за этой двусмысленности Rust не пытается угадать, что мы хотим, а у структур нет предоставленной реализации &lt;code&gt;Display&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="02931ec361bbc5f61952272ead50c2b1cc721cb3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;println!&lt;/code&gt; macro is only capable of printing to standard output, so we have to use something else to print to standard error.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="df3a7253c874e9c54aed370b97b0410e823ccbd2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;proc_macro&lt;/code&gt; crate</source>
          <target state="translated">&lt;code&gt;proc_macro&lt;/code&gt; клеть</target>
        </trans-unit>
        <trans-unit id="0ebc19fdeafa41e303e045832093f26b01f1011c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;pub&lt;/code&gt; keyword was used inside a function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a4aeb159d9e69df04b16b32d0a540b4e48d1c2ba" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;pub&lt;/code&gt; keyword was used inside a function. Erroneous code example:</source>
          <target state="translated">&lt;code&gt;pub&lt;/code&gt; ключевое слово используется внутри функции. Пример ошибочного кода:</target>
        </trans-unit>
        <trans-unit id="b670fe1e664ec6db0ea27f497b8f300d96565afa" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;pub&lt;/code&gt; keyword was used inside a public enum.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d36ebedc5c61f3368fb308364706ea53f77e634b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;pub&lt;/code&gt; keyword was used inside a public enum. Erroneous code example:</source>
          <target state="translated">&lt;code&gt;pub&lt;/code&gt; ключевое слово было использовано в публичном перечислении. Пример ошибочного кода:</target>
        </trans-unit>
        <trans-unit id="855c30613293c5803da1be19530bcff46d089f73" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;push&lt;/code&gt; method takes a single character as a parameter and adds it to the &lt;code&gt;String&lt;/code&gt;. Listing 8-17 shows code that adds the letter &lt;em&gt;l&lt;/em&gt; to a &lt;code&gt;String&lt;/code&gt; using the &lt;code&gt;push&lt;/code&gt; method.</source>
          <target state="translated">Метод &lt;code&gt;push&lt;/code&gt; принимает один символ в качестве параметра и добавляет его в &lt;code&gt;String&lt;/code&gt; . В листинге 8-17 показан код, который добавляет букву &lt;em&gt;l&lt;/em&gt; в &lt;code&gt;String&lt;/code&gt; с &lt;code&gt;push&lt;/code&gt; метода push .</target>
        </trans-unit>
        <trans-unit id="e7c0b086ee3b65e9ef7299c70cf8f6fd0c56999e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;quote!&lt;/code&gt; macro also provides some very cool templating mechanics: we can enter &lt;code&gt;#name&lt;/code&gt;, and &lt;code&gt;quote!&lt;/code&gt; will replace it with the value in the variable &lt;code&gt;name&lt;/code&gt;. You can even do some repetition similar to the way regular macros work. Check out &lt;a href=&quot;https://docs.rs/quote&quot;&gt;the &lt;code&gt;quote&lt;/code&gt; crate&amp;rsquo;s docs&lt;/a&gt; for a thorough introduction.</source>
          <target state="translated">&lt;code&gt;quote!&lt;/code&gt; макрос также предоставляет очень интересную механику создания шаблонов: мы можем ввести &lt;code&gt;#name&lt;/code&gt; и &lt;code&gt;quote!&lt;/code&gt; заменит его значение в переменной &lt;code&gt;name&lt;/code&gt; . Вы даже можете делать некоторые повторения, как в обычных макросах. Проверьте &lt;a href=&quot;https://docs.rs/quote&quot;&gt;в &lt;code&gt;quote&lt;/code&gt; документов Crate в&lt;/a&gt; течение полного введения.</target>
        </trans-unit>
        <trans-unit id="62ab310a7862369bfdb3998e805adaae0cd4f2e7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;quote!&lt;/code&gt; macro lets us define the Rust code that we want to return. The compiler expects something different to the direct result of the &lt;code&gt;quote!&lt;/code&gt; macro&amp;rsquo;s execution, so we need to convert it to a &lt;code&gt;TokenStream&lt;/code&gt;. We do this by calling the &lt;code&gt;into&lt;/code&gt; method, which consumes this intermediate representation and returns a value of the required &lt;code&gt;TokenStream&lt;/code&gt; type.</source>
          <target state="translated">&lt;code&gt;quote!&lt;/code&gt; макрос позволяет нам определить код Rust, который мы хотим вернуть. Компилятор ожидает чего-то отличного от прямого результата &lt;code&gt;quote!&lt;/code&gt; макроса, поэтому нам нужно преобразовать его в &lt;code&gt;TokenStream&lt;/code&gt; . Мы делаем это, вызывая метод &lt;code&gt;into&lt;/code&gt; , который использует это промежуточное представление и возвращает значение требуемого типа &lt;code&gt;TokenStream&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="53ae9c1c1e33423bee13e403e332e75689959214" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ready!&lt;/code&gt; call expands to:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b83941e960f12671a681a1df28d6d59cb442a02e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;recursion_limit&lt;/code&gt; attribute</source>
          <target state="translated">&lt;code&gt;recursion_limit&lt;/code&gt; атрибут</target>
        </trans-unit>
        <trans-unit id="7fd3ec074e9dd99ae0db784fdf399ea43dd43516" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ref&lt;/code&gt; and/or &lt;code&gt;mut&lt;/code&gt;&lt;em&gt;IDENTIFIER&lt;/em&gt; syntax matches any value and binds it to a variable with the same name as the given field.</source>
          <target state="translated">&lt;code&gt;ref&lt;/code&gt; и / или &lt;code&gt;mut&lt;/code&gt; &lt;em&gt;ИДЕНТИФИКАТОР&lt;/em&gt; синтаксис соответствует любому значению и связывает его с переменной с тем же именем, что и данной области.</target>
        </trans-unit>
        <trans-unit id="a07e646920bfd0169ef8462620bb6bf857e50545" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;repeat()&lt;/code&gt; function repeats a single value over and over again.</source>
          <target state="translated">Функция &lt;code&gt;repeat()&lt;/code&gt; повторяет одно значение снова и снова.</target>
        </trans-unit>
        <trans-unit id="ca6b7fab269378f975039696a9d029f43743fe55" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;repeat_with()&lt;/code&gt; function calls the repeater over and over again.</source>
          <target state="translated">Функция &lt;code&gt;repeat_with()&lt;/code&gt; вызывает повторитель снова и снова.</target>
        </trans-unit>
        <trans-unit id="203b4d4e0f959a4e516770bf1c8acd411f9645d3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;request_review&lt;/code&gt; and &lt;code&gt;approve&lt;/code&gt; methods take ownership of &lt;code&gt;self&lt;/code&gt;, thus consuming the &lt;code&gt;DraftPost&lt;/code&gt; and &lt;code&gt;PendingReviewPost&lt;/code&gt; instances and transforming them into a &lt;code&gt;PendingReviewPost&lt;/code&gt; and a published &lt;code&gt;Post&lt;/code&gt;, respectively. This way, we won&amp;rsquo;t have any lingering &lt;code&gt;DraftPost&lt;/code&gt; instances after we&amp;rsquo;ve called &lt;code&gt;request_review&lt;/code&gt; on them, and so forth. The &lt;code&gt;PendingReviewPost&lt;/code&gt; struct doesn&amp;rsquo;t have a &lt;code&gt;content&lt;/code&gt; method defined on it, so attempting to read its content results in a compiler error, as with &lt;code&gt;DraftPost&lt;/code&gt;. Because the only way to get a published &lt;code&gt;Post&lt;/code&gt; instance that does have a &lt;code&gt;content&lt;/code&gt; method defined is to call the &lt;code&gt;approve&lt;/code&gt; method on a &lt;code&gt;PendingReviewPost&lt;/code&gt;, and the only way to get a &lt;code&gt;PendingReviewPost&lt;/code&gt; is to call the &lt;code&gt;request_review&lt;/code&gt; method on a &lt;code&gt;DraftPost&lt;/code&gt;, we&amp;rsquo;ve now encoded the blog post workflow into the type system.</source>
          <target state="translated">&lt;code&gt;request_review&lt;/code&gt; и &lt;code&gt;approve&lt;/code&gt; методы взять на себя ответственность &lt;code&gt;self&lt;/code&gt; , таким образом , потребляя &lt;code&gt;DraftPost&lt;/code&gt; и &lt;code&gt;PendingReviewPost&lt;/code&gt; экземпляры и преобразующие их в &lt;code&gt;PendingReviewPost&lt;/code&gt; и опубликованное &lt;code&gt;Post&lt;/code&gt; , соответственно. Таким образом, у нас не будет никаких &lt;code&gt;DraftPost&lt;/code&gt; экземпляров DraftPost после того, как мы вызовем для них &lt;code&gt;request_review&lt;/code&gt; и т. Д. Для структуры &lt;code&gt;PendingReviewPost&lt;/code&gt; не определен метод &lt;code&gt;content&lt;/code&gt; , поэтому попытка прочитать ее содержимое приводит к ошибке компилятора, как и в случае с &lt;code&gt;DraftPost&lt;/code&gt; . Потому что единственный способ получить опубликованный &lt;code&gt;Post&lt;/code&gt; Экземпляр, в котором определен метод &lt;code&gt;content&lt;/code&gt; - это вызвать метод &lt;code&gt;approve&lt;/code&gt; в &lt;code&gt;PendingReviewPost&lt;/code&gt; , а единственный способ получить &lt;code&gt;PendingReviewPost&lt;/code&gt; - вызвать метод &lt;code&gt;request_review&lt;/code&gt; в &lt;code&gt;DraftPost&lt;/code&gt; , теперь мы закодировали рабочий процесс публикации в блоге в систему типов.</target>
        </trans-unit>
        <trans-unit id="14e654a0e6edb832d7ec2e9f01e2cec2e8fc8293" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;request_review&lt;/code&gt; method on &lt;code&gt;Draft&lt;/code&gt; needs to return a new, boxed instance of a new &lt;code&gt;PendingReview&lt;/code&gt; struct, which represents the state when a post is waiting for a review. The &lt;code&gt;PendingReview&lt;/code&gt; struct also implements the &lt;code&gt;request_review&lt;/code&gt; method but doesn&amp;rsquo;t do any transformations. Rather, it returns itself, because when we request a review on a post already in the &lt;code&gt;PendingReview&lt;/code&gt; state, it should stay in the &lt;code&gt;PendingReview&lt;/code&gt; state.</source>
          <target state="translated">&lt;code&gt;request_review&lt;/code&gt; метод по &lt;code&gt;Draft&lt;/code&gt; должен вернуть новый коробочный экземпляр нового &lt;code&gt;PendingReview&lt;/code&gt; структуры, которая представляет собой состояние , когда пост ждет обзора. Структура &lt;code&gt;PendingReview&lt;/code&gt; также реализует метод &lt;code&gt;request_review&lt;/code&gt; , но не выполняет никаких преобразований. Скорее, он возвращается сам, потому что, когда мы запрашиваем рецензию на публикацию, уже &lt;code&gt;PendingReview&lt;/code&gt; состоянии PendingReview , она должна оставаться в состоянии &lt;code&gt;PendingReview&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e74e1506742074d3eac6be2b7d8e21235520da47" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;run&lt;/code&gt; command comes in handy when you need to rapidly iterate on a project, as we&amp;rsquo;ll do in this game, quickly testing each iteration before moving on to the next one.</source>
          <target state="translated">Команда &lt;code&gt;run&lt;/code&gt; пригодится, когда вам нужно быстро выполнить итерацию проекта, как мы это сделаем в этой игре, быстро тестируя каждую итерацию, прежде чем переходить к следующей.</target>
        </trans-unit>
        <trans-unit id="46e85b1a08cc19eee77379933feec0b53082268f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;run&lt;/code&gt; function definition</source>
          <target state="translated">Определение функции &lt;code&gt;run&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="5e5f409e03a8829700c6b7a5a46ab61b65379877" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;run&lt;/code&gt; function now contains all the remaining logic from &lt;code&gt;main&lt;/code&gt;, starting from reading the file. The &lt;code&gt;run&lt;/code&gt; function takes the &lt;code&gt;Config&lt;/code&gt; instance as an argument.</source>
          <target state="translated">Функция &lt;code&gt;run&lt;/code&gt; теперь содержит всю оставшуюся логику из &lt;code&gt;main&lt;/code&gt; , начиная с чтения файла. Функция &lt;code&gt;run&lt;/code&gt; принимает в качестве аргумента экземпляр &lt;code&gt;Config&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6fc1541b8f6585c0ffe5cd745827dfb79f574e45" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;rustfmt&lt;/code&gt; tool reformats your code according to the community code style. Many collaborative projects use &lt;code&gt;rustfmt&lt;/code&gt; to prevent arguments about which style to use when writing Rust: everyone formats their code using the tool.</source>
          <target state="translated">Инструмент &lt;code&gt;rustfmt&lt;/code&gt; переформатирует ваш код в соответствии со стилем кода сообщества. Многие совместные проекты используют &lt;code&gt;rustfmt&lt;/code&gt; для предотвращения споров о том, какой стиль использовать при написании Rust: каждый форматирует свой код с помощью этого инструмента.</target>
        </trans-unit>
        <trans-unit id="f41fbdae4087d677734daccb36bd68168ac22c54" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;same_bucket&lt;/code&gt; function is passed references to two elements from the slice and must determine if the elements compare equal. The elements are passed in opposite order from their order in the slice, so if &lt;code&gt;same_bucket(a, b)&lt;/code&gt; returns &lt;code&gt;true&lt;/code&gt;, &lt;code&gt;a&lt;/code&gt; is moved at the end of the slice.</source>
          <target state="translated">В функцию &lt;code&gt;same_bucket&lt;/code&gt; передаются ссылки на два элемента из среза, и она должна определять, равны ли элементы при сравнении. Элементы передаются в порядке, обратном их порядку в срезе, поэтому, если &lt;code&gt;same_bucket(a, b)&lt;/code&gt; возвращает &lt;code&gt;true&lt;/code&gt; , &lt;code&gt;a&lt;/code&gt; перемещается в конец среза.</target>
        </trans-unit>
        <trans-unit id="51106981f7e1a09193991d8a2ebd9672888c0e0a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;same_bucket&lt;/code&gt; function is passed references to two elements from the vector and must determine if the elements compare equal. The elements are passed in opposite order from their order in the slice, so if &lt;code&gt;same_bucket(a, b)&lt;/code&gt; returns &lt;code&gt;true&lt;/code&gt;, &lt;code&gt;a&lt;/code&gt; is removed.</source>
          <target state="translated">Функция &lt;code&gt;same_bucket&lt;/code&gt; передает ссылки на два элемента из вектора и должна определять, равны ли элементы при сравнении. Элементы передаются в порядке, противоположном их порядку в срезе, поэтому, если &lt;code&gt;same_bucket(a, b)&lt;/code&gt; возвращает &lt;code&gt;true&lt;/code&gt; , &lt;code&gt;a&lt;/code&gt; удаляется.</target>
        </trans-unit>
        <trans-unit id="a14ee345d1496dff6fbc5e218ae3b33c17f09dd5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;search_case_insensitive&lt;/code&gt; function, shown in Listing 12-21, will be almost the same as the &lt;code&gt;search&lt;/code&gt; function. The only difference is that we&amp;rsquo;ll lowercase the &lt;code&gt;query&lt;/code&gt; and each &lt;code&gt;line&lt;/code&gt; so whatever the case of the input arguments, they&amp;rsquo;ll be the same case when we check whether the line contains the query.</source>
          <target state="translated">Функция &lt;code&gt;search_case_insensitive&lt;/code&gt; , показанная в Листинге 12-21, будет почти такой же, как функция &lt;code&gt;search&lt;/code&gt; . Единственное отличие состоит в том, что мы будем строчными буквами &lt;code&gt;query&lt;/code&gt; и каждую &lt;code&gt;line&lt;/code&gt; так что независимо от случая входных аргументов, они будут одинаковыми, когда мы проверяем, содержит ли строка запрос.</target>
        </trans-unit>
        <trans-unit id="bbcc387564e51cca06178b88f2766991af78a4d0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;self&lt;/code&gt; crate may be imported which creates a binding to the current crate. In this case the &lt;code&gt;as&lt;/code&gt; clause must be used to specify the name to bind it to.</source>
          <target state="translated">&lt;code&gt;self&lt;/code&gt; обрешетка может быть импортирована , которая создает привязку к текущему обрешетке. В этом случае предложение &lt;code&gt;as&lt;/code&gt; должно использоваться для указания имени для его привязки.</target>
        </trans-unit>
        <trans-unit id="5df3512b09c8677b58f509f70a4092543dbb8630" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;self&lt;/code&gt; import appears more than once in the list.</source>
          <target state="translated">&lt;code&gt;self&lt;/code&gt; импорта появляется более одного раза в списке.</target>
        </trans-unit>
        <trans-unit id="776137337eaf5141c6cf75f1ef731869806d23fc" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;self&lt;/code&gt; keyword can only be used inside methods, which are associated functions (functions defined inside of a &lt;code&gt;trait&lt;/code&gt; or &lt;code&gt;impl&lt;/code&gt; block) that have a &lt;code&gt;self&lt;/code&gt; receiver as its first parameter, like &lt;code&gt;self&lt;/code&gt;, &lt;code&gt;&amp;amp;self&lt;/code&gt;, &lt;code&gt;&amp;amp;mut self&lt;/code&gt; or &lt;code&gt;self: &amp;amp;mut Pin&amp;lt;Self&amp;gt;&lt;/code&gt; (this last one is an example of an &lt;a href=&quot;https://github.com/rust-lang/rust/issues/44874&quot;&gt;&quot;abitrary &lt;code&gt;self&lt;/code&gt; type&quot;&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="31848a0c1be52494be53b5a9553dbe8630cef51b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;self&lt;/code&gt; keyword can only be used inside methods, which are associated functions (functions defined inside of a &lt;code&gt;trait&lt;/code&gt; or &lt;code&gt;impl&lt;/code&gt; block) that have a &lt;code&gt;self&lt;/code&gt; receiver as its first parameter, like &lt;code&gt;self&lt;/code&gt;, &lt;code&gt;&amp;amp;self&lt;/code&gt;, &lt;code&gt;&amp;amp;mut self&lt;/code&gt; or &lt;code&gt;self: &amp;amp;mut Pin&amp;lt;Self&amp;gt;&lt;/code&gt; (this last one is an example of an &lt;a href=&quot;https://github.com/rust-lang/rust/issues/44874&quot;&gt;&quot;arbitrary &lt;code&gt;self&lt;/code&gt; type&quot;&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ca20974e52a0607307348bb19d0d894eb2389060" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;self&lt;/code&gt; keyword cannot appear alone as the last segment in a &lt;code&gt;use&lt;/code&gt; declaration.</source>
          <target state="translated">&lt;code&gt;self&lt;/code&gt; ключевое слово не может появляться в одиночку , как последний сегмент в &lt;code&gt;use&lt;/code&gt; декларации.</target>
        </trans-unit>
        <trans-unit id="3baa95a2b4735c8ad9eb06f47e895376f593ffa3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;self&lt;/code&gt; keyword was used in a static method.</source>
          <target state="translated">&lt;code&gt;self&lt;/code&gt; ключевое слово было использовано в методе статической.</target>
        </trans-unit>
        <trans-unit id="a9568dcdfe3a23be1dee117543923d717013ab13" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;self&lt;/code&gt; keyword was used inside of an associated function without a &quot;&lt;code&gt;self&lt;/code&gt; receiver&quot; parameter.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f67620c2fbc5330097742f848b2b9886ad0ef4ee" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;self&lt;/code&gt; parameter in a method has an invalid &quot;receiver type&quot;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="71e55d8484323ba680a4d79f359c6a8e4726809e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;sent_messages&lt;/code&gt; field is now of type &lt;code&gt;RefCell&amp;lt;Vec&amp;lt;String&amp;gt;&amp;gt;&lt;/code&gt; instead of &lt;code&gt;Vec&amp;lt;String&amp;gt;&lt;/code&gt;. In the &lt;code&gt;new&lt;/code&gt; function, we create a new &lt;code&gt;RefCell&amp;lt;Vec&amp;lt;String&amp;gt;&amp;gt;&lt;/code&gt; instance around the empty vector.</source>
          <target state="translated">Поле &lt;code&gt;sent_messages&lt;/code&gt; теперь имеет тип &lt;code&gt;RefCell&amp;lt;Vec&amp;lt;String&amp;gt;&amp;gt;&lt;/code&gt; вместо &lt;code&gt;Vec&amp;lt;String&amp;gt;&lt;/code&gt; . В &lt;code&gt;new&lt;/code&gt; функции мы создаем новый &lt;code&gt;RefCell&amp;lt;Vec&amp;lt;String&amp;gt;&amp;gt;&lt;/code&gt; вокруг пустого вектора.</target>
        </trans-unit>
        <trans-unit id="337c62942744e545dcf717c6319edbedc18f313b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;shoes_in_my_size&lt;/code&gt; function takes ownership of a vector of shoes and a shoe size as parameters. It returns a vector containing only shoes of the specified size.</source>
          <target state="translated">Функция &lt;code&gt;shoes_in_my_size&lt;/code&gt; принимает в качестве параметров вектор обуви и размер обуви. Он возвращает вектор, содержащий только туфли указанного размера.</target>
        </trans-unit>
        <trans-unit id="16a60caa064b42a78f27eb4d74ff02e2b3b32b36" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;should_panic&lt;/code&gt; attribute</source>
          <target state="translated">&lt;code&gt;should_panic&lt;/code&gt; атрибут</target>
        </trans-unit>
        <trans-unit id="639f1b128b2e8340c54ba2df925fcc505b0aa67b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;should_panic&lt;/code&gt; attribute may optionally take an input string that must appear within the panic message. If the string is not found in the message, then the test will fail. The string may be passed using the &lt;a href=&quot;../attributes#meta-item-attribute-syntax&quot;&gt;&lt;em&gt;MetaNameValueStr&lt;/em&gt;&lt;/a&gt; syntax or the &lt;a href=&quot;../attributes#meta-item-attribute-syntax&quot;&gt;&lt;em&gt;MetaListNameValueStr&lt;/em&gt;&lt;/a&gt; syntax with an &lt;code&gt;expected&lt;/code&gt; field.</source>
          <target state="translated">&lt;code&gt;should_panic&lt;/code&gt; атрибут может необязательно принимать входную строку , которая должна отображаться в сообщении паники. Если строка не найдена в сообщении, тест не пройден. Строку можно передать с использованием синтаксиса &lt;a href=&quot;../attributes#meta-item-attribute-syntax&quot;&gt;&lt;em&gt;MetaNameValueStr&lt;/em&gt;&lt;/a&gt; или синтаксиса &lt;a href=&quot;../attributes#meta-item-attribute-syntax&quot;&gt;&lt;em&gt;MetaListNameValueStr&lt;/em&gt;&lt;/a&gt; с &lt;code&gt;expected&lt;/code&gt; полем.</target>
        </trans-unit>
        <trans-unit id="47db49dacc0e9fe0c5ab4b84de0a525fbcc167ce" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;simd_shuffle&lt;/code&gt; function needs the length of the array passed as last parameter in its name. Example:</source>
          <target state="translated">Функция &lt;code&gt;simd_shuffle&lt;/code&gt; требует длины массива, переданного в качестве последнего параметра в ее имени. Пример:</target>
        </trans-unit>
        <trans-unit id="1728894948cd279e5a554b1af44ad631d3c73ca8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;spawn&lt;/code&gt; function returns a &lt;code&gt;JoinHandle&amp;lt;T&amp;gt;&lt;/code&gt;, where &lt;code&gt;T&lt;/code&gt; is the type that the closure returns. Let&amp;rsquo;s try using &lt;code&gt;JoinHandle&lt;/code&gt; too and see what happens. In our case, the closures we&amp;rsquo;re passing to the thread pool will handle the connection and not return anything, so &lt;code&gt;T&lt;/code&gt; will be the unit type &lt;code&gt;()&lt;/code&gt;.</source>
          <target state="translated">Функция &lt;code&gt;spawn&lt;/code&gt; возвращает &lt;code&gt;JoinHandle&amp;lt;T&amp;gt;&lt;/code&gt; , где &lt;code&gt;T&lt;/code&gt; - это тип, возвращаемый замыканием. Давайте также попробуем использовать &lt;code&gt;JoinHandle&lt;/code&gt; и посмотрим, что произойдет. В нашем случае замыкания, которые мы передаем пулу потоков, будут обрабатывать соединение и ничего не возвращать, поэтому &lt;code&gt;T&lt;/code&gt; будет типом модуля &lt;code&gt;()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="566807adf1a1b2e0676b75e750b724f0403f4cce" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;src&lt;/code&gt; path is not a file or doesn't exist.</source>
          <target state="translated">Путь к &lt;code&gt;src&lt;/code&gt; не является файлом или не существует.</target>
        </trans-unit>
        <trans-unit id="8b80b9ca4d5b5301222f74ba4e7cb474c1a9b0c3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;start..&lt;/code&gt; syntax is a &lt;code&gt;RangeFrom&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d29bbe16c04fa990f15f7ad6e1fd231be48fb8e5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;start..=end&lt;/code&gt; syntax is a &lt;code&gt;RangeInclusive&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f551a983bf25bb9ca332d4bf79a3c5ffe5eff531" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;start..end&lt;/code&gt; syntax is a &lt;code&gt;Range&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="07635229348f3268d25fca1958c374b441ce892b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;start&lt;/code&gt; function was defined with a where clause.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a73480c4afd7847e00e31fe3aafec20a20c54b25" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;static&lt;/code&gt; keyword, on the other hand, guarantees a fixed location in memory. This does not always mean that the value is constant. For example, a global mutex can be declared &lt;code&gt;static&lt;/code&gt; as well.</source>
          <target state="translated">&lt;code&gt;static&lt;/code&gt; ключевое слово, с другой стороны, гарантирует фиксированное место в памяти. Это не всегда означает, что значение постоянное. Например, глобальный мьютекс также может быть объявлен &lt;code&gt;static&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d33afa111381148e1c91bd2523fbea89118180e9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;std::env&lt;/code&gt; module contains many more useful features for dealing with environment variables: check out its documentation to see what is available.</source>
          <target state="translated">Модуль &lt;code&gt;std::env&lt;/code&gt; содержит гораздо больше полезных функций для работы с переменными среды: ознакомьтесь с его документацией, чтобы узнать, что доступно.</target>
        </trans-unit>
        <trans-unit id="bcaf28a16adceb8447193d5235bef5d8bd3335ac" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;std::io&lt;/code&gt; module contains a number of common things you'll need when doing input and output. The most core part of this module is the &lt;a href=&quot;trait.read&quot;&gt;&lt;code&gt;Read&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;trait.write&quot;&gt;&lt;code&gt;Write&lt;/code&gt;&lt;/a&gt; traits, which provide the most general interface for reading and writing input and output.</source>
          <target state="translated">Модуль &lt;code&gt;std::io&lt;/code&gt; содержит ряд общих вещей, которые вам понадобятся при вводе и выводе. Самая основная часть этого модуля - &lt;a href=&quot;trait.read&quot;&gt; &lt;code&gt;Read&lt;/code&gt; &lt;/a&gt; и &lt;a href=&quot;trait.write&quot;&gt; &lt;code&gt;Write&lt;/code&gt; &lt;/a&gt; , которые обеспечивают наиболее общий интерфейс для чтения и записи ввода и вывода.</target>
        </trans-unit>
        <trans-unit id="4a54af6bd4d1bf95ed93c13cd61787ff3a49ae58" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;std::mem::drop&lt;/code&gt; function is different from the &lt;code&gt;drop&lt;/code&gt; method in the &lt;code&gt;Drop&lt;/code&gt; trait. We call it by passing the value we want to force to be dropped early as an argument. The function is in the prelude, so we can modify &lt;code&gt;main&lt;/code&gt; in Listing 15-15 to call the &lt;code&gt;drop&lt;/code&gt; function, as shown in Listing 15-16:</source>
          <target state="translated">Функция &lt;code&gt;std::mem::drop&lt;/code&gt; отличается от метода &lt;code&gt;drop&lt;/code&gt; в &lt;code&gt;Drop&lt;/code&gt; . Мы вызываем это, передавая значение, которое мы хотим принудительно отбросить в качестве аргумента. Функция находится в прелюдии, поэтому мы можем изменить &lt;code&gt;main&lt;/code&gt; в листинге 15-15, чтобы вызвать функцию &lt;code&gt;drop&lt;/code&gt; , как показано в листинге 15-16:</target>
        </trans-unit>
        <trans-unit id="964c58feb2d7a0e4b6c63c315388a37636bb2ffa" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;steps_between&lt;/code&gt; function provides a way to efficiently compare two &lt;code&gt;Step&lt;/code&gt; objects.</source>
          <target state="translated">Функция &lt;code&gt;steps_between&lt;/code&gt; позволяет эффективно сравнивать два объекта &lt;code&gt;Step&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3d6948e046aa3d769d70c7d7f5831db7b61d283e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;str&lt;/code&gt; type, also called a 'string slice', is the most primitive string type. It is usually seen in its borrowed form, &lt;code&gt;&amp;amp;str&lt;/code&gt;. It is also the type of string literals, &lt;code&gt;&amp;amp;'static str&lt;/code&gt;.</source>
          <target state="translated">Тип &lt;code&gt;str&lt;/code&gt; , также называемый &amp;laquo;строковым срезом&amp;raquo;, является наиболее примитивным строковым типом. Обычно встречается в заимствованной форме, &lt;code&gt;&amp;amp;str&lt;/code&gt; . Это также тип строковых литералов &lt;code&gt;&amp;amp;'static str&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4ea4c33d08beaf7c17c84c4930138d5a7a1f80fa" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;stringify!&lt;/code&gt; macro used here is built into Rust. It takes a Rust expression, such as &lt;code&gt;1 + 2&lt;/code&gt;, and at compile time turns the expression into a string literal, such as &lt;code&gt;&quot;1 + 2&quot;&lt;/code&gt;. This is different than &lt;code&gt;format!&lt;/code&gt; or &lt;code&gt;println!&lt;/code&gt;, macros which evaluate the expression and then turn the result into a &lt;code&gt;String&lt;/code&gt;. There is a possibility that the &lt;code&gt;#name&lt;/code&gt; input might be an expression to print literally, so we use &lt;code&gt;stringify!&lt;/code&gt;. Using &lt;code&gt;stringify!&lt;/code&gt; also saves an allocation by converting &lt;code&gt;#name&lt;/code&gt; to a string literal at compile time.</source>
          <target state="translated">&lt;code&gt;stringify!&lt;/code&gt; Используемый здесь макрос встроен в Rust. Он принимает выражение Rust, например &lt;code&gt;1 + 2&lt;/code&gt; , и во время компиляции превращает выражение в строковый литерал, например &lt;code&gt;&quot;1 + 2&quot;&lt;/code&gt; . Это отличается от &lt;code&gt;format!&lt;/code&gt; или &lt;code&gt;println!&lt;/code&gt; , макросы, которые оценивают выражение и затем преобразуют результат в &lt;code&gt;String&lt;/code&gt; . Существует вероятность того, что ввод &lt;code&gt;#name&lt;/code&gt; может быть выражением для печати буквально, поэтому мы используем &lt;code&gt;stringify!&lt;/code&gt; . Используя &lt;code&gt;stringify!&lt;/code&gt; также сохраняет выделение путем преобразования &lt;code&gt;#name&lt;/code&gt; в строковый литерал во время компиляции.</target>
        </trans-unit>
        <trans-unit id="5e2bbf89c9d53502f02966909193300b8b8e39a1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;syn&lt;/code&gt; crate parses Rust code from a string into a data structure that we can perform operations on. The &lt;code&gt;quote&lt;/code&gt; crate turns &lt;code&gt;syn&lt;/code&gt; data structures back into Rust code. These crates make it much simpler to parse any sort of Rust code we might want to handle: writing a full parser for Rust code is no simple task.</source>
          <target state="translated">&lt;code&gt;syn&lt;/code&gt; обрешетка разбирает Rust код из строки в структуру данных , которые мы можем выполнить операции. &lt;code&gt;quote&lt;/code&gt; Crate по очереди &lt;code&gt;syn&lt;/code&gt; структуры данных обратно в Rust код. Эти ящики значительно упрощают синтаксический анализ любого кода Rust, который мы можем захотеть обработать: написание полного парсера для кода Rust - непростая задача.</target>
        </trans-unit>
        <trans-unit id="4c2f6cfbefda1dc3521b2af3bf1923ea6ba12d89" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;take&lt;/code&gt; method is defined in the &lt;code&gt;Iterator&lt;/code&gt; trait and limits the iteration to the first two items at most. The &lt;code&gt;ThreadPool&lt;/code&gt; will go out of scope at the end of &lt;code&gt;main&lt;/code&gt;, and the &lt;code&gt;drop&lt;/code&gt; implementation will run.</source>
          <target state="translated">Метод &lt;code&gt;take&lt;/code&gt; определен в &lt;code&gt;Iterator&lt;/code&gt; и ограничивает итерацию максимум двумя первыми элементами. &lt;code&gt;ThreadPool&lt;/code&gt; будет выходить за рамки в конце &lt;code&gt;main&lt;/code&gt; , а &lt;code&gt;drop&lt;/code&gt; реализации будет работать.</target>
        </trans-unit>
        <trans-unit id="f4261b148ae0a22c8791698e09a2d9939e795de1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;target_feature&lt;/code&gt; attribute</source>
          <target state="translated">&lt;code&gt;target_feature&lt;/code&gt; атрибут</target>
        </trans-unit>
        <trans-unit id="0bfa2ee4e02addd4c71ab19bd1f7c85cc21dadfe" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;test&lt;/code&gt; attribute</source>
          <target state="translated">&lt;code&gt;test&lt;/code&gt; атрибут</target>
        </trans-unit>
        <trans-unit id="c6b28a9d1db605fca4af25fdaf7d2f63f3f4ff7d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;track_caller&lt;/code&gt; attribute may be applied to any function with &lt;a href=&quot;../items/external-blocks#abi&quot;&gt;&lt;code&gt;&quot;Rust&quot;&lt;/code&gt; ABI&lt;/a&gt; with the exception of the entry point &lt;code&gt;fn main&lt;/code&gt;. When applied to functions and methods in trait declarations, the attribute applies to all implementations. If the trait provides a default implementation with the attribute, then the attribute also applies to override implementations.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dbbce8f10ed8de46d53a88134091400a4cad8f24" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;transparent&lt;/code&gt; Representation</source>
          <target state="translated">&lt;code&gt;transparent&lt;/code&gt; Представление</target>
        </trans-unit>
        <trans-unit id="16cfac7d668a26094fafdea930dd55dadb7672de" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;transparent&lt;/code&gt; representation can only be used on &lt;code&gt;struct&lt;/code&gt;s that have a single non-zero sized field and any number of zero-sized fields, including &lt;a href=&quot;special-types-and-traits#phantomdatat&quot;&gt;&lt;code&gt;PhantomData&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;transparent&lt;/code&gt; представление может быть использовано только на &lt;code&gt;struct&lt;/code&gt; с , которые имеют одну ненулевого размер поля и любое количество нулевых размеров полеев, в том числе &lt;a href=&quot;special-types-and-traits#phantomdatat&quot;&gt; &lt;code&gt;PhantomData&amp;lt;T&amp;gt;&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="811b48cd1ea2c8f7773b17e401a6ef4a6664ee6e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;transparent&lt;/code&gt; representation can only be used on a &lt;a href=&quot;items/structs&quot;&gt;&lt;code&gt;struct&lt;/code&gt;&lt;/a&gt; or an &lt;a href=&quot;items/enumerations&quot;&gt;&lt;code&gt;enum&lt;/code&gt;&lt;/a&gt; with a single variant that has:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="01d7d7afaf943b9e9b10757db03a01818240c2c9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;try_recv&lt;/code&gt; method doesn&amp;rsquo;t block, but will instead return a &lt;code&gt;Result&amp;lt;T, E&amp;gt;&lt;/code&gt; immediately: an &lt;code&gt;Ok&lt;/code&gt; value holding a message if one is available and an &lt;code&gt;Err&lt;/code&gt; value if there aren&amp;rsquo;t any messages this time. Using &lt;code&gt;try_recv&lt;/code&gt; is useful if this thread has other work to do while waiting for messages: we could write a loop that calls &lt;code&gt;try_recv&lt;/code&gt; every so often, handles a message if one is available, and otherwise does other work for a little while until checking again.</source>
          <target state="translated">Метод &lt;code&gt;try_recv&lt;/code&gt; не блокируется, но вместо этого немедленно возвращает &lt;code&gt;Result&amp;lt;T, E&amp;gt;&lt;/code&gt; : значение &lt;code&gt;Ok&lt;/code&gt; , содержащее сообщение, если оно доступно, и значение &lt;code&gt;Err&lt;/code&gt; , если на этот раз сообщений нет. Использование &lt;code&gt;try_recv&lt;/code&gt; полезно, если у этого потока есть другая работа в ожидании сообщений: мы могли бы написать цикл, который время от времени вызывает &lt;code&gt;try_recv&lt;/code&gt; , обрабатывает сообщение, если оно доступно, и в противном случае некоторое время выполняет другую работу до повторной проверки.</target>
        </trans-unit>
        <trans-unit id="1c06a34327e19720b6fdb343c408e7c55dd84e16" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;type Target = T;&lt;/code&gt; syntax defines an associated type for the &lt;code&gt;Deref&lt;/code&gt; trait to use. Associated types are a slightly different way of declaring a generic parameter, but you don&amp;rsquo;t need to worry about them for now; we&amp;rsquo;ll cover them in more detail in Chapter 19.</source>
          <target state="translated">&lt;code&gt;type Target = T;&lt;/code&gt; синтаксис определяет связанный тип для использования &lt;code&gt;Deref&lt;/code&gt; . Связанные типы - это немного другой способ объявления универсального параметра, но вам пока не нужно о них беспокоиться; мы рассмотрим их более подробно в главе 19.</target>
        </trans-unit>
        <trans-unit id="ed8f6c9e0893fd91a5e6d611722172ed9ef6f6c2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;type_length_limit&lt;/code&gt; attribute</source>
          <target state="translated">&lt;code&gt;type_length_limit&lt;/code&gt; атрибут</target>
        </trans-unit>
        <trans-unit id="88b76f9ce33c0af8e240ed6b37ada9e83ea43da5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;typeof&lt;/code&gt; keyword is currently reserved but unimplemented.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7495ddf8e7dd908218ee8fe0115f879a8fb5ec94" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;typeof&lt;/code&gt; keyword is currently reserved but unimplemented. Erroneous code example:</source>
          <target state="translated">&lt;code&gt;typeof&lt;/code&gt; ключевое слово в настоящее время зарезервирован , но неосуществленными. Пример ошибочного кода:</target>
        </trans-unit>
        <trans-unit id="dd3cfc211f63708e7ec9409ea2198c30928717cb" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;unsafe&lt;/code&gt; keyword has two uses: to declare the existence of contracts the compiler can't check (&lt;code&gt;unsafe fn&lt;/code&gt; and &lt;code&gt;unsafe trait&lt;/code&gt;), and to declare that a programmer has checked that these contracts have been upheld (&lt;code&gt;unsafe {}&lt;/code&gt; and &lt;code&gt;unsafe impl&lt;/code&gt;, but also &lt;code&gt;unsafe fn&lt;/code&gt; -- see below). They are not mutually exclusive, as can be seen in &lt;code&gt;unsafe fn&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b3bcdab50b34b5e5716db8fd4a0ee45ad2abea8d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;unsafe&lt;/code&gt; keyword is syntactically allowed to appear before the &lt;code&gt;extern&lt;/code&gt; keyword, but it is rejected at a semantic level. This allows macros to consume the syntax and make use of the &lt;code&gt;unsafe&lt;/code&gt; keyword, before removing it from the token stream.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="205e3b2923533eb22d4e09801e3f784e668f24fa" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;unsafe&lt;/code&gt; keyword is syntactically allowed to appear before the &lt;code&gt;mod&lt;/code&gt; keyword, but it is rejected at a semantic level. This allows macros to consume the syntax and make use of the &lt;code&gt;unsafe&lt;/code&gt; keyword, before removing it from the token stream.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a346e1081bfa2911e1aa0fde6117ab4a081928a4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;unsafe&lt;/code&gt; qualifier indicates that the type's value is an &lt;a href=&quot;../unsafe-functions&quot;&gt;unsafe function&lt;/a&gt;, and the &lt;code&gt;extern&lt;/code&gt; qualifier indicates it is an &lt;a href=&quot;../items/functions#extern-function-qualifier&quot;&gt;extern function&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="994e471fd3da940319d1417edcfca60d6a3db828" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;unsafe&lt;/code&gt; qualifier indicates that the type's value is an &lt;a href=&quot;../unsafe-functions&quot;&gt;unsafe function&lt;/a&gt;, and the &lt;code&gt;extern&lt;/code&gt; qualifier indicates it is an &lt;a href=&quot;../items/functions#extern-functions&quot;&gt;extern function&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;unsafe&lt;/code&gt; классификатор указывает на то, что значение типа в является &lt;a href=&quot;../unsafe-functions&quot;&gt;небезопасным функцией&lt;/a&gt; , а &lt;code&gt;extern&lt;/code&gt; классификатор указывает , что это &lt;a href=&quot;../items/functions#extern-functions&quot;&gt;ехЬегп функция&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="78ba9e0cc65cc7840eaadd16f98f7cca440cd4f4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;unwind&lt;/code&gt; attribute was malformed.</source>
          <target state="translated">&lt;code&gt;unwind&lt;/code&gt; атрибут был неправильно сформирован.</target>
        </trans-unit>
        <trans-unit id="a60fd78a94b551f1746c4a391dd52899994edd99" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;used&lt;/code&gt; attribute</source>
          <target state="translated">&lt;code&gt;used&lt;/code&gt; атрибут</target>
        </trans-unit>
        <trans-unit id="762cbbe7d454d7148fa1b85ecdd6dd222c5646ce" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;usize&lt;/code&gt; type is an unsigned integer type with the same number of bits as the platform's pointer type. It can represent every memory address in the process.</source>
          <target state="translated">Тип &lt;code&gt;usize&lt;/code&gt; - это целочисленный тип без знака с тем же количеством битов, что и тип указателя платформы. Он может представлять каждый адрес памяти в процессе.</target>
        </trans-unit>
        <trans-unit id="ca7074c2679596c96e2d40f1a9e7060f1f83b71a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;value&lt;/code&gt; field is of type &lt;code&gt;Option&amp;lt;u32&amp;gt;&lt;/code&gt;. Before we execute the closure, &lt;code&gt;value&lt;/code&gt; will be &lt;code&gt;None&lt;/code&gt;. When code using a &lt;code&gt;Cacher&lt;/code&gt; asks for the &lt;em&gt;result&lt;/em&gt; of the closure, the &lt;code&gt;Cacher&lt;/code&gt; will execute the closure at that time and store the result within a &lt;code&gt;Some&lt;/code&gt; variant in the &lt;code&gt;value&lt;/code&gt; field. Then if the code asks for the result of the closure again, instead of executing the closure again, the &lt;code&gt;Cacher&lt;/code&gt; will return the result held in the &lt;code&gt;Some&lt;/code&gt; variant.</source>
          <target state="translated">Поле &lt;code&gt;value&lt;/code&gt; имеет тип &lt;code&gt;Option&amp;lt;u32&amp;gt;&lt;/code&gt; . Прежде чем мы выполним закрытие, &lt;code&gt;value&lt;/code&gt; будет &lt;code&gt;None&lt;/code&gt; . Когда код, использующий &lt;code&gt;Cacher&lt;/code&gt; , запрашивает &lt;em&gt;результат&lt;/em&gt; закрытия, &lt;code&gt;Cacher&lt;/code&gt; выполнит закрытие в это время и сохранит результат в варианте &lt;code&gt;Some&lt;/code&gt; в поле &lt;code&gt;value&lt;/code&gt; . Затем, если код снова запрашивает результат закрытия, вместо повторного выполнения закрытия &lt;code&gt;Cacher&lt;/code&gt; вернет результат, содержащийся в варианте &lt;code&gt;Some&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5defa2a7e24b93d29be444c6bce3655062b73aee" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;vtable&lt;/code&gt; customizes the behavior of a &lt;code&gt;Waker&lt;/code&gt; which gets created from a &lt;code&gt;RawWaker&lt;/code&gt;. For each operation on the &lt;code&gt;Waker&lt;/code&gt;, the associated function in the &lt;code&gt;vtable&lt;/code&gt; of the underlying &lt;code&gt;RawWaker&lt;/code&gt; will be called.</source>
          <target state="translated">Таблица &lt;code&gt;vtable&lt;/code&gt; настраивает поведение &lt;code&gt;Waker&lt;/code&gt; , созданного из &lt;code&gt;RawWaker&lt;/code&gt; . Для каждой операции на &lt;code&gt;Waker&lt;/code&gt; будет вызываться соответствующая функция в &lt;code&gt;RawWaker&lt;/code&gt; &lt;code&gt;vtable&lt;/code&gt; базового RawWaker .</target>
        </trans-unit>
        <trans-unit id="58deddf572f1c05716c0aff255109ee68c618f77" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;wasm_import_module&lt;/code&gt; key may be used to specify the &lt;a href=&quot;https://webassembly.github.io/spec/core/syntax/modules.html&quot;&gt;WebAssembly module&lt;/a&gt; name for the items within an &lt;code&gt;extern&lt;/code&gt; block when importing symbols from the host environment. The default module name is &lt;code&gt;env&lt;/code&gt; if &lt;code&gt;wasm_import_module&lt;/code&gt; is not specified.</source>
          <target state="translated">&lt;code&gt;wasm_import_module&lt;/code&gt; ключ может быть использован для определения &lt;a href=&quot;https://webassembly.github.io/spec/core/syntax/modules.html&quot;&gt;модуля WebAssembly&lt;/a&gt; имени для элементов внутри &lt;code&gt;extern&lt;/code&gt; блока при импорте символов из принимающей среды. Имя модуля по умолчанию - &lt;code&gt;env&lt;/code&gt; , если &lt;code&gt;wasm_import_module&lt;/code&gt; не указан.</target>
        </trans-unit>
        <trans-unit id="03b2e1ae71fdcbd9ffac8eca408ab8d4e8472f94" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;width&lt;/code&gt;, &lt;code&gt;height&lt;/code&gt;, and &lt;code&gt;label&lt;/code&gt; fields on &lt;code&gt;Button&lt;/code&gt; will differ from the fields on other components, such as a &lt;code&gt;TextField&lt;/code&gt; type, that might have those fields plus a &lt;code&gt;placeholder&lt;/code&gt; field instead. Each of the types we want to draw on the screen will implement the &lt;code&gt;Draw&lt;/code&gt; trait but will use different code in the &lt;code&gt;draw&lt;/code&gt; method to define how to draw that particular type, as &lt;code&gt;Button&lt;/code&gt; has here (without the actual GUI code, which is beyond the scope of this chapter). The &lt;code&gt;Button&lt;/code&gt; type, for instance, might have an additional &lt;code&gt;impl&lt;/code&gt; block containing methods related to what happens when a user clicks the button. These kinds of methods won&amp;rsquo;t apply to types like &lt;code&gt;TextField&lt;/code&gt;.</source>
          <target state="translated">В &lt;code&gt;width&lt;/code&gt; , &lt;code&gt;height&lt;/code&gt; и &lt;code&gt;label&lt;/code&gt; поля на &lt;code&gt;Button&lt;/code&gt; будет отличаться от полей на другие компоненты, такие как &lt;code&gt;TextField&lt;/code&gt; типа, которые могли бы иметь эти поля плюс &lt;code&gt;placeholder&lt;/code&gt; поля вместо. Каждый из типов, которые мы хотим нарисовать на экране, будет реализовывать черту &lt;code&gt;Draw&lt;/code&gt; , но будет использовать другой код в методе &lt;code&gt;draw&lt;/code&gt; чтобы определить, как рисовать этот конкретный тип, как здесь имеет &lt;code&gt;Button&lt;/code&gt; (без фактического кода GUI, который выходит за рамки этой главы). &lt;code&gt;Button&lt;/code&gt; типа, например, может иметь дополнительный &lt;code&gt;impl&lt;/code&gt; блок, содержащий методы, связанные с тем, что происходит, когда пользователь нажимает кнопку. Такие методы не применимы к таким типам, как &lt;code&gt;TextField&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="49fef96b0756f10c5fd5c7fedcccb9ee963b501d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;windows_subsystem&lt;/code&gt; attribute</source>
          <target state="translated">&lt;code&gt;windows_subsystem&lt;/code&gt; атрибут</target>
        </trans-unit>
        <trans-unit id="fe674a5495eedc22d7ae598194abec96fa238a33" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;write&lt;/code&gt; function takes an output stream, and an &lt;code&gt;Arguments&lt;/code&gt; struct that can be precompiled with the &lt;code&gt;format_args!&lt;/code&gt; macro.</source>
          <target state="translated">Функция &lt;code&gt;write&lt;/code&gt; принимает выходной поток и структуру &lt;code&gt;Arguments&lt;/code&gt; , которую можно предварительно скомпилировать с помощью &lt;code&gt;format_args!&lt;/code&gt; макрос.</target>
        </trans-unit>
        <trans-unit id="5644d7245fdec36266e15ee66f56202b01bc587d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;x&lt;/code&gt; part is a pattern! As we did with &lt;code&gt;let&lt;/code&gt;, we could match a tuple in a function&amp;rsquo;s arguments to the pattern. Listing 18-7 splits the values in a tuple as we pass it to a function.</source>
          <target state="translated">Часть &lt;code&gt;x&lt;/code&gt; - это узор! Как и с &lt;code&gt;let&lt;/code&gt; , мы можем сопоставить кортеж в аргументах функции с шаблоном. Листинг 18-7 разделяет значения в кортеже, когда мы передаем его функции.</target>
        </trans-unit>
        <trans-unit id="90c7cb6860c6df5927660a73f110e2f9166750a3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;x&lt;/code&gt; value is moved into the closure when the closure is defined, because we added the &lt;code&gt;move&lt;/code&gt; keyword. The closure then has ownership of &lt;code&gt;x&lt;/code&gt;, and &lt;code&gt;main&lt;/code&gt; isn&amp;rsquo;t allowed to use &lt;code&gt;x&lt;/code&gt; anymore in the &lt;code&gt;println!&lt;/code&gt; statement. Removing &lt;code&gt;println!&lt;/code&gt; will fix this example.</source>
          <target state="translated">Значение &lt;code&gt;x&lt;/code&gt; перемещается в замыкание, когда замыкание определяется, потому что мы добавили ключевое слово &lt;code&gt;move&lt;/code&gt; . В этом случае замыкание становится владельцем &lt;code&gt;x&lt;/code&gt; , и &lt;code&gt;main&lt;/code&gt; больше не может использовать &lt;code&gt;x&lt;/code&gt; в &lt;code&gt;println!&lt;/code&gt; заявление. Удаление &lt;code&gt;println!&lt;/code&gt; исправлю этот пример.</target>
        </trans-unit>
        <trans-unit id="693d3b957625a8e3df8f4384a832c7be5cfa15d0" translate="yes" xml:space="preserve">
          <source>The &lt;em id=&quot;the-tests-directory&quot;&gt;tests&lt;/em&gt; Directory</source>
          <target state="translated">&lt;em id=&quot;the-tests-directory&quot;&gt;Тесты&lt;/em&gt; каталог</target>
        </trans-unit>
        <trans-unit id="2382217293f35827ef839ef57a6e0636f3faa56f" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;&lt;code&gt;automatically_derived&lt;/code&gt; attribute&lt;/em&gt; is automatically added to &lt;a href=&quot;../items/implementations&quot;&gt;implementations&lt;/a&gt; created by the &lt;code&gt;derive&lt;/code&gt; attribute for built-in traits. It has no direct effect, but it may be used by tools and diagnostic lints to detect these automatically generated implementations.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7d372f8b0a676dc2ae354b920b56c31e1ed0230f" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;&lt;code&gt;cold&lt;/code&gt; &lt;a href=&quot;../attributes&quot;&gt;attribute&lt;/a&gt;&lt;/em&gt; suggests that the attributed function is unlikely to be called.</source>
          <target state="translated">&lt;em&gt; &lt;code&gt;cold&lt;/code&gt; &lt;a href=&quot;../attributes&quot;&gt;атрибут&lt;/a&gt;&lt;/em&gt; показывает , что приписывали функция вряд ли можно назвать.</target>
        </trans-unit>
        <trans-unit id="c8dd94fd6bb692bd54e04ee95744533de367bad8" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;&lt;code&gt;crate_name&lt;/code&gt; &lt;a href=&quot;attributes&quot;&gt;attribute&lt;/a&gt;&lt;/em&gt; may be applied at the crate level to specify the name of the crate with the &lt;a href=&quot;attributes#meta-item-attribute-syntax&quot;&gt;&lt;em&gt;MetaNameValueStr&lt;/em&gt;&lt;/a&gt; syntax.</source>
          <target state="translated">&lt;em&gt; &lt;code&gt;crate_name&lt;/code&gt; &lt;a href=&quot;attributes&quot;&gt;атрибут&lt;/a&gt;&lt;/em&gt; может быть применен на уровне клети , чтобы указать имя ящика с &lt;a href=&quot;attributes#meta-item-attribute-syntax&quot;&gt;&lt;em&gt;MetaNameValueStr&lt;/em&gt;&lt;/a&gt; синтаксисом.</target>
        </trans-unit>
        <trans-unit id="2db8e6439808a243c5fa24e648c2e0fab8ef4d83" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;&lt;code&gt;deprecated&lt;/code&gt; attribute&lt;/em&gt; marks an item as deprecated. &lt;code&gt;rustc&lt;/code&gt; will issue warnings on usage of &lt;code&gt;#[deprecated]&lt;/code&gt; items. &lt;code&gt;rustdoc&lt;/code&gt; will show item deprecation, including the &lt;code&gt;since&lt;/code&gt; version and &lt;code&gt;note&lt;/code&gt;, if available.</source>
          <target state="translated">В &lt;em&gt; &lt;code&gt;deprecated&lt;/code&gt; атрибутах&lt;/em&gt; метка элемент , как осуждаются. &lt;code&gt;rustc&lt;/code&gt; выдаст предупреждения об использовании &lt;code&gt;#[deprecated]&lt;/code&gt; элементов. &lt;code&gt;rustdoc&lt;/code&gt; покажет устаревшие элементы, включая версию &lt;code&gt;since&lt;/code&gt; и &lt;code&gt;note&lt;/code&gt; , если они доступны.</target>
        </trans-unit>
        <trans-unit id="fa15bab6a083f19d9ae9cd7eaa338e697eaf4832" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;&lt;code&gt;derive&lt;/code&gt; attribute&lt;/em&gt; allows new &lt;a href=&quot;../items&quot;&gt;items&lt;/a&gt; to be automatically generated for data structures. It uses the &lt;a href=&quot;../attributes#meta-item-attribute-syntax&quot;&gt;&lt;em&gt;MetaListPaths&lt;/em&gt;&lt;/a&gt; syntax to specify a list of traits to implement or paths to &lt;a href=&quot;../procedural-macros#derive-macros&quot;&gt;derive macros&lt;/a&gt; to process.</source>
          <target state="translated">&lt;em&gt; &lt;code&gt;derive&lt;/code&gt; атрибут&lt;/em&gt; позволяет использовать новые &lt;a href=&quot;../items&quot;&gt;элементы&lt;/a&gt; , которые будут автоматически генерироваться для структур данных. Он использует синтаксис &lt;a href=&quot;../attributes#meta-item-attribute-syntax&quot;&gt;&lt;em&gt;MetaListPaths,&lt;/em&gt;&lt;/a&gt; чтобы указать список признаков для реализации или путей для &lt;a href=&quot;../procedural-macros#derive-macros&quot;&gt;получения макросов&lt;/a&gt; для обработки.</target>
        </trans-unit>
        <trans-unit id="a97c3213ab817ab892d8f6e5c3157736e74b3b32" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;&lt;code&gt;export_name&lt;/code&gt; attribute&lt;/em&gt; specifies the name of the symbol that will be exported on a &lt;a href=&quot;items/functions&quot;&gt;function&lt;/a&gt; or &lt;a href=&quot;items/static-items&quot;&gt;static&lt;/a&gt;. It uses the &lt;a href=&quot;attributes#meta-item-attribute-syntax&quot;&gt;&lt;em&gt;MetaNameValueStr&lt;/em&gt;&lt;/a&gt; syntax to specify the symbol name.</source>
          <target state="translated">&lt;em&gt; &lt;code&gt;export_name&lt;/code&gt; атрибут&lt;/em&gt; определяет имя символа , который будет экспортироваться на &lt;a href=&quot;items/functions&quot;&gt;функцию&lt;/a&gt; или &lt;a href=&quot;items/static-items&quot;&gt;статическими&lt;/a&gt; . Он использует синтаксис &lt;a href=&quot;attributes#meta-item-attribute-syntax&quot;&gt;&lt;em&gt;MetaNameValueStr&lt;/em&gt;&lt;/a&gt; для указания имени символа.</target>
        </trans-unit>
        <trans-unit id="9d1fbcf19af41adeefc0b92335ae4b007c4dadfa" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;&lt;code&gt;global_allocator&lt;/code&gt; attribute&lt;/em&gt; is used on a &lt;a href=&quot;items/static-items&quot;&gt;static item&lt;/a&gt; implementing the &lt;a href=&quot;https://doc.rust-lang.org/alloc/alloc/trait.GlobalAlloc.html&quot;&gt;&lt;code&gt;GlobalAlloc&lt;/code&gt;&lt;/a&gt; trait to set the global allocator.</source>
          <target state="translated">&lt;em&gt; &lt;code&gt;global_allocator&lt;/code&gt; атрибут&lt;/em&gt; используются на &lt;a href=&quot;items/static-items&quot;&gt;статическом элементе&lt;/a&gt; , реализующий &lt;a href=&quot;https://doc.rust-lang.org/alloc/alloc/trait.GlobalAlloc.html&quot;&gt; &lt;code&gt;GlobalAlloc&lt;/code&gt; &lt;/a&gt; черт установить глобальный аллокатор.</target>
        </trans-unit>
        <trans-unit id="eb4af8649334dd85e9ba7979a0a444e3961c900a" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;&lt;code&gt;inline&lt;/code&gt; &lt;a href=&quot;../attributes&quot;&gt;attribute&lt;/a&gt;&lt;/em&gt; suggests that a copy of the attributed function should be placed in the caller, rather than generating code to call the function where it is defined.</source>
          <target state="translated">&lt;em&gt; &lt;code&gt;inline&lt;/code&gt; &lt;a href=&quot;../attributes&quot;&gt;атрибут&lt;/a&gt;&lt;/em&gt; предполагает , что копия приписываемой функции должны быть помещены в вызывающем, а не генерации кода для вызова функции , где она определена.</target>
        </trans-unit>
        <trans-unit id="1d9a7b1456b98dca1d8fed53edde3318db90e4c5" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;&lt;code&gt;link&lt;/code&gt; attribute&lt;/em&gt; specifies the name of a native library that the compiler should link with for the items within an &lt;code&gt;extern&lt;/code&gt; block. It uses the &lt;a href=&quot;../attributes#meta-item-attribute-syntax&quot;&gt;&lt;em&gt;MetaListNameValueStr&lt;/em&gt;&lt;/a&gt; syntax to specify its inputs. The &lt;code&gt;name&lt;/code&gt; key is the name of the native library to link. The &lt;code&gt;kind&lt;/code&gt; key is an optional value which specifies the kind of library with the following possible values:</source>
          <target state="translated">&lt;em&gt; &lt;code&gt;link&lt;/code&gt; атрибут&lt;/em&gt; определяет имя родной библиотеки , которую компилятор должен связать с для элементов внутри &lt;code&gt;extern&lt;/code&gt; блока. Он использует синтаксис &lt;a href=&quot;../attributes#meta-item-attribute-syntax&quot;&gt;&lt;em&gt;MetaListNameValueStr&lt;/em&gt;&lt;/a&gt; для указания своих входных данных. &lt;code&gt;name&lt;/code&gt; ключа имя родной библиотеки по ссылке. &lt;code&gt;kind&lt;/code&gt; ключ является необязательным значением , которое определяет тип библиотеки со следующими возможными значениями:</target>
        </trans-unit>
        <trans-unit id="6603167a8a5aa9df2deb989c68e33b760144ac17" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;&lt;code&gt;link_section&lt;/code&gt; attribute&lt;/em&gt; specifies the section of the object file that a &lt;a href=&quot;items/functions&quot;&gt;function&lt;/a&gt; or &lt;a href=&quot;items/static-items&quot;&gt;static&lt;/a&gt;'s content will be placed into. It uses the &lt;a href=&quot;attributes#meta-item-attribute-syntax&quot;&gt;&lt;em&gt;MetaNameValueStr&lt;/em&gt;&lt;/a&gt; syntax to specify the section name.</source>
          <target state="translated">&lt;em&gt; &lt;code&gt;link_section&lt;/code&gt; атрибут&lt;/em&gt; указывает раздел файла объекта о том , что &lt;a href=&quot;items/functions&quot;&gt;Function&lt;/a&gt; или &lt;a href=&quot;items/static-items&quot;&gt;STATIC&lt;/a&gt; &amp;laquo;сек контент будет помещен в. Он использует синтаксис &lt;a href=&quot;attributes#meta-item-attribute-syntax&quot;&gt;&lt;em&gt;MetaNameValueStr&lt;/em&gt;&lt;/a&gt; для указания имени раздела.</target>
        </trans-unit>
        <trans-unit id="806935dfacd2a07be8b57f073dcdf39509c2b1f7" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;&lt;code&gt;macro_use&lt;/code&gt; attribute&lt;/em&gt; has two purposes. First, it can be used to make a module's macro scope not end when the module is closed, by applying it to a module:</source>
          <target state="translated">&lt;em&gt; &lt;code&gt;macro_use&lt;/code&gt; атрибут&lt;/em&gt; имеет две цели. Во-первых, его можно использовать для того, чтобы область макроса модуля не заканчивалась, когда модуль закрывается, применив его к модулю:</target>
        </trans-unit>
        <trans-unit id="05f0042fe91a37001bd65ea0d74fd9143e55659c" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;&lt;code&gt;must_use&lt;/code&gt; attribute&lt;/em&gt; is used to issue a diagnostic warning when a value is not &quot;used&quot;. It can be applied to user-defined composite types (&lt;a href=&quot;../items/structs&quot;&gt;&lt;code&gt;struct&lt;/code&gt;s&lt;/a&gt;, &lt;a href=&quot;../items/enumerations&quot;&gt;&lt;code&gt;enum&lt;/code&gt;s&lt;/a&gt;, and &lt;a href=&quot;../items/unions&quot;&gt;&lt;code&gt;union&lt;/code&gt;s&lt;/a&gt;), &lt;a href=&quot;../items/functions&quot;&gt;functions&lt;/a&gt;, and &lt;a href=&quot;../items/traits&quot;&gt;traits&lt;/a&gt;.</source>
          <target state="translated">&lt;em&gt; &lt;code&gt;must_use&lt;/code&gt; атрибут&lt;/em&gt; используется для выдачи диагностического предупреждения , когда не будет &amp;laquo;использоваться&amp;raquo; значение. Его можно применять к определяемым пользователем составным типам ( &lt;a href=&quot;../items/structs&quot;&gt; &lt;code&gt;struct&lt;/code&gt; s&lt;/a&gt; , &lt;a href=&quot;../items/enumerations&quot;&gt; &lt;code&gt;enum&lt;/code&gt; s&lt;/a&gt; и &lt;a href=&quot;../items/unions&quot;&gt; &lt;code&gt;union&lt;/code&gt; s&lt;/a&gt; ), &lt;a href=&quot;../items/functions&quot;&gt;функциям&lt;/a&gt; и &lt;a href=&quot;../items/traits&quot;&gt;трейтам&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="df0d5b935c63e0d5d09ad34649237d79db006af9" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;&lt;code&gt;no_builtins&lt;/code&gt; &lt;a href=&quot;../attributes&quot;&gt;attribute&lt;/a&gt;&lt;/em&gt; may be applied at the crate level to disable optimizing certain code patterns to invocations of library functions that are assumed to exist.</source>
          <target state="translated">&lt;em&gt; &lt;code&gt;no_builtins&lt;/code&gt; &lt;a href=&quot;../attributes&quot;&gt;атрибут&lt;/a&gt;&lt;/em&gt; может быть применен на уровне клети , чтобы отключить оптимизации определенных шаблоны коды на вызовы библиотечных функций, которые предположительно существует.</target>
        </trans-unit>
        <trans-unit id="1c5fb5c17e1ae5e93c491f3ff3864f7cf3700a82" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;&lt;code&gt;no_link&lt;/code&gt; attribute&lt;/em&gt; may be specified on an &lt;code&gt;extern crate&lt;/code&gt; item to prevent linking the crate into the output. This is commonly used to load a crate to access only its macros.</source>
          <target state="translated">&lt;em&gt; &lt;code&gt;no_link&lt;/code&gt; атрибут&lt;/em&gt; может быть указан на &lt;code&gt;extern crate&lt;/code&gt; элемента для предотвращения связывания клети на выход. Обычно это используется для загрузки ящика, чтобы получить доступ только к его макросам.</target>
        </trans-unit>
        <trans-unit id="a894d89850015842793e60fc8f351c2309ee5ef4" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;&lt;code&gt;no_main&lt;/code&gt; &lt;a href=&quot;attributes&quot;&gt;attribute&lt;/a&gt;&lt;/em&gt; may be applied at the crate level to disable emitting the &lt;code&gt;main&lt;/code&gt; symbol for an executable binary. This is useful when some other object being linked to defines &lt;code&gt;main&lt;/code&gt;.</source>
          <target state="translated">&lt;em&gt; &lt;code&gt;no_main&lt;/code&gt; &lt;a href=&quot;attributes&quot;&gt;атрибут&lt;/a&gt;&lt;/em&gt; может быть применен на уровне клети , чтобы отключить излучающие &lt;code&gt;main&lt;/code&gt; символ для исполняемого двоичного файла. Это полезно, когда какой-либо другой объект, с которым связывается, определяет &lt;code&gt;main&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f3bcfb88f5c979d523b3f1a38c5f5b56a611b895" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;&lt;code&gt;no_mangle&lt;/code&gt; attribute&lt;/em&gt; may be used on any &lt;a href=&quot;items&quot;&gt;item&lt;/a&gt; to disable standard symbol name mangling. The symbol for the item will be the identifier of the item's name.</source>
          <target state="translated">&lt;em&gt; &lt;code&gt;no_mangle&lt;/code&gt; атрибут&lt;/em&gt; может быть использован на любой &lt;a href=&quot;items&quot;&gt;пункт&lt;/a&gt; , чтобы отключить стандартное имя символа коверкая. Символ предмета будет идентификатором названия предмета.</target>
        </trans-unit>
        <trans-unit id="0bb656555b55ed7c2f8a3087c34efb6ed0ed4cf4" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;&lt;code&gt;non_exhaustive&lt;/code&gt; attribute&lt;/em&gt; indicates that a type or variant may have more fields or variants added in the future. It can be applied to &lt;a href=&quot;../items/structs&quot;&gt;&lt;code&gt;struct&lt;/code&gt;s&lt;/a&gt;, &lt;a href=&quot;../items/enumerations&quot;&gt;&lt;code&gt;enum&lt;/code&gt;s&lt;/a&gt;, and &lt;code&gt;enum&lt;/code&gt; variants.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="53a982d72d2f0894ccb0ac1653ff149a9b51224c" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;&lt;code&gt;panic_handler&lt;/code&gt; attribute&lt;/em&gt; can only be applied to a function with signature &lt;code&gt;fn(&amp;amp;PanicInfo) -&amp;gt; !&lt;/code&gt;. The function marked with this &lt;a href=&quot;attributes&quot;&gt;attribute&lt;/a&gt; defines the behavior of panics. The &lt;a href=&quot;https://doc.rust-lang.org/core/panic/struct.PanicInfo.html&quot;&gt;&lt;code&gt;PanicInfo&lt;/code&gt;&lt;/a&gt; struct contains information about the location of the panic. There must be a single &lt;code&gt;panic_handler&lt;/code&gt; function in the dependency graph of a binary, dylib or cdylib crate.</source>
          <target state="translated">&lt;em&gt; &lt;code&gt;panic_handler&lt;/code&gt; атрибут&lt;/em&gt; может быть применен только к функции с подписью &lt;code&gt;fn(&amp;amp;PanicInfo) -&amp;gt; !&lt;/code&gt; . Функция, отмеченная этим &lt;a href=&quot;attributes&quot;&gt;атрибутом,&lt;/a&gt; определяет поведение паники. Структура &lt;a href=&quot;https://doc.rust-lang.org/core/panic/struct.PanicInfo.html&quot;&gt; &lt;code&gt;PanicInfo&lt;/code&gt; &lt;/a&gt; содержит информацию о местоположении паники. Там должна быть одной &lt;code&gt;panic_handler&lt;/code&gt; функция в графе зависимостей бинарной, dylib или cdylib клети.</target>
        </trans-unit>
        <trans-unit id="12cdf01a779d8c77135d5a609c4b4e6849f40d6f" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;&lt;code&gt;recursion_limit&lt;/code&gt; attribute&lt;/em&gt; may be applied at the &lt;a href=&quot;../crates-and-source-files&quot;&gt;crate&lt;/a&gt; level to set the maximum depth for potentially infinitely-recursive compile-time operations like macro expansion or auto-dereference. It uses the &lt;a href=&quot;../attributes#meta-item-attribute-syntax&quot;&gt;&lt;em&gt;MetaNameValueStr&lt;/em&gt;&lt;/a&gt; syntax to specify the recursion depth.</source>
          <target state="translated">&lt;em&gt; &lt;code&gt;recursion_limit&lt;/code&gt; атрибут&lt;/em&gt; может быть применен на &lt;a href=&quot;../crates-and-source-files&quot;&gt;клеть&lt;/a&gt; уровне , чтобы установить глубину максимум для потенциально бесконечно рекурсивных операций во время компиляции , как макроподстановкам или авто-разыменования. Он использует синтаксис &lt;a href=&quot;../attributes#meta-item-attribute-syntax&quot;&gt;&lt;em&gt;MetaNameValueStr&lt;/em&gt;&lt;/a&gt; для указания глубины рекурсии.</target>
        </trans-unit>
        <trans-unit id="a7c71f7f4ce5a08ecec5e3cb423add9b9986d9b2" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;&lt;code&gt;target_feature&lt;/code&gt; &lt;a href=&quot;../attributes&quot;&gt;attribute&lt;/a&gt;&lt;/em&gt; may be applied to an &lt;a href=&quot;../unsafe-functions&quot;&gt;unsafe function&lt;/a&gt; to enable code generation of that function for specific platform architecture features. It uses the &lt;a href=&quot;../attributes#meta-item-attribute-syntax&quot;&gt;&lt;em&gt;MetaListNameValueStr&lt;/em&gt;&lt;/a&gt; syntax with a single key of &lt;code&gt;enable&lt;/code&gt; whose value is a string of comma-separated feature names to enable.</source>
          <target state="translated">&lt;em&gt; &lt;code&gt;target_feature&lt;/code&gt; &lt;a href=&quot;../attributes&quot;&gt;атрибут&lt;/a&gt;&lt;/em&gt; может быть применен к &lt;a href=&quot;../unsafe-functions&quot;&gt;небезопасным функции&lt;/a&gt; , чтобы включить генерацию кода этой функции для конкретных особенностей архитектуры платформы. Он использует синтаксис &lt;a href=&quot;../attributes#meta-item-attribute-syntax&quot;&gt;&lt;em&gt;MetaListNameValueStr&lt;/em&gt;&lt;/a&gt; с одним ключом &lt;code&gt;enable&lt;/code&gt; , значение которого представляет собой строку имен функций, разделенных запятыми, для включения.</target>
        </trans-unit>
        <trans-unit id="3aa1c2ce8a0a269a928c5414e9b6749a40da4909" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;&lt;code&gt;test&lt;/code&gt; attribute&lt;/em&gt; marks a function to be executed as a test. These functions are only compiled when in test mode. Test functions must be free, monomorphic functions that take no arguments, and the return type must be one of the following:</source>
          <target state="translated">В &lt;em&gt; &lt;code&gt;test&lt;/code&gt; атрибутов&lt;/em&gt; метки функцию , которая будет выполнена в качестве теста. Эти функции компилируются только в тестовом режиме. Тестовые функции должны быть свободными, мономорфными функциями, не принимающими аргументов, а возвращаемый тип должен быть одним из следующих:</target>
        </trans-unit>
        <trans-unit id="8e32e2a7306abe757340b9bbe77da987dbdce7fd" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;&lt;code&gt;type_length_limit&lt;/code&gt; attribute&lt;/em&gt; limits the maximum number of type substitutions made when constructing a concrete type during monomorphization. It is applied at the &lt;a href=&quot;../crates-and-source-files&quot;&gt;crate&lt;/a&gt; level, and uses the &lt;a href=&quot;../attributes#meta-item-attribute-syntax&quot;&gt;&lt;em&gt;MetaNameValueStr&lt;/em&gt;&lt;/a&gt; syntax to set the limit based on the number of type substitutions.</source>
          <target state="translated">&lt;em&gt; &lt;code&gt;type_length_limit&lt;/code&gt; атрибут&lt;/em&gt; ограничивает максимальное число типа замен , сделанных при построении типа бетона во monomorphization. Он применяется на уровне &lt;a href=&quot;../crates-and-source-files&quot;&gt;ящика&lt;/a&gt; и использует синтаксис &lt;a href=&quot;../attributes#meta-item-attribute-syntax&quot;&gt;&lt;em&gt;MetaNameValueStr&lt;/em&gt;&lt;/a&gt; для установки ограничения на основе количества замен типов.</target>
        </trans-unit>
        <trans-unit id="6e74f839ef9f1efad1a8f9c7c9bbeff2f9cc5cae" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;&lt;code&gt;used&lt;/code&gt; attribute&lt;/em&gt; can only be applied to &lt;a href=&quot;items/static-items&quot;&gt;&lt;code&gt;static&lt;/code&gt; items&lt;/a&gt;. This &lt;a href=&quot;attributes&quot;&gt;attribute&lt;/a&gt; forces the compiler to keep the variable in the output object file (.o, .rlib, etc. excluding final binaries) even if the variable is not used, or referenced, by any other item in the crate. However, the linker is still free to remove such an item.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f9f3929d821839852e44df6684413a39c02b618f" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;&lt;code&gt;used&lt;/code&gt; attribute&lt;/em&gt; can only be applied to &lt;a href=&quot;items/static-items&quot;&gt;&lt;code&gt;static&lt;/code&gt; items&lt;/a&gt;. This &lt;a href=&quot;attributes&quot;&gt;attribute&lt;/a&gt; forces the compiler to keep the variable in the output object file (.o, .rlib, etc.) even if the variable is not used, or referenced, by any other item in the crate.</source>
          <target state="translated">&lt;em&gt; &lt;code&gt;used&lt;/code&gt; атрибут&lt;/em&gt; может быть применен только к &lt;a href=&quot;items/static-items&quot;&gt; &lt;code&gt;static&lt;/code&gt; пунктам&lt;/a&gt; . Этот &lt;a href=&quot;attributes&quot;&gt;атрибут&lt;/a&gt; заставляет компилятор сохранять переменную в выходном объектном файле (.o, .rlib и т. Д.), Даже если переменная не используется или не упоминается каким-либо другим элементом в корзине.</target>
        </trans-unit>
        <trans-unit id="cabd9dd1fe1f065b8657354c25edb014ad53f468" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;&lt;code&gt;windows_subsystem&lt;/code&gt; attribute&lt;/em&gt; may be applied at the crate level to set the &lt;a href=&quot;https://msdn.microsoft.com/en-us/library/fcc1zstk.aspx&quot;&gt;subsystem&lt;/a&gt; when linking on a Windows target. It uses the &lt;a href=&quot;attributes#meta-item-attribute-syntax&quot;&gt;&lt;em&gt;MetaNameValueStr&lt;/em&gt;&lt;/a&gt; syntax to specify the subsystem with a value of either &lt;code&gt;console&lt;/code&gt; or &lt;code&gt;windows&lt;/code&gt;. This attribute is ignored on non-Windows targets, and for non-&lt;code&gt;bin&lt;/code&gt;&lt;a href=&quot;linkage&quot;&gt;crate types&lt;/a&gt;.</source>
          <target state="translated">&lt;em&gt; &lt;code&gt;windows_subsystem&lt;/code&gt; атрибут&lt;/em&gt; может быть применен на уровне клети , чтобы установить &lt;a href=&quot;https://msdn.microsoft.com/en-us/library/fcc1zstk.aspx&quot;&gt;подсистему&lt;/a&gt; при условии ссылки на целевом Windows. Он использует синтаксис &lt;a href=&quot;attributes#meta-item-attribute-syntax&quot;&gt;&lt;em&gt;MetaNameValueStr,&lt;/em&gt;&lt;/a&gt; чтобы указать подсистему со значением &lt;code&gt;console&lt;/code&gt; или &lt;code&gt;windows&lt;/code&gt; . Этот атрибут игнорируется для целей, отличных от Windows, и для &lt;a href=&quot;linkage&quot;&gt;типов ящиков,&lt;/a&gt; отличных от &lt;code&gt;bin&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="637d9dddc1ad4617a0c58ddffc3922ae87e9baab" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;alignment&lt;/em&gt; of a value specifies what addresses are valid to store the value at. A value of alignment &lt;code&gt;n&lt;/code&gt; must only be stored at an address that is a multiple of n. For example, a value with an alignment of 2 must be stored at an even address, while a value with an alignment of 1 can be stored at any address. Alignment is measured in bytes, and must be at least 1, and always a power of 2. The alignment of a value can be checked with the &lt;a href=&quot;../std/mem/fn.align_of_val&quot;&gt;&lt;code&gt;align_of_val&lt;/code&gt;&lt;/a&gt; function.</source>
          <target state="translated">&lt;em&gt;Выравнивание&lt;/em&gt; стоимостного определяет , какие адреса являются действительными для хранения значения в. Значение выравнивания &lt;code&gt;n&lt;/code&gt; должно храниться только по адресу, кратному n. Например, значение с выравниванием 2 должно храниться по четному адресу, а значение с выравниванием 1 может храниться по любому адресу. Выравнивание измеряется в байтах и ​​должно быть не менее 1 и всегда должно быть степенью 2. Выравнивание значения можно проверить с &lt;a href=&quot;../std/mem/fn.align_of_val&quot;&gt; &lt;code&gt;align_of_val&lt;/code&gt; &lt;/a&gt; функции align_of_val .</target>
        </trans-unit>
        <trans-unit id="caa4287ee2eae29f4b7097731528e2f984499328" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;at&lt;/em&gt; operator (&lt;code&gt;@&lt;/code&gt;) lets us create a variable that holds a value at the same time we&amp;rsquo;re testing that value to see whether it matches a pattern. Listing 18-29 shows an example where we want to test that a &lt;code&gt;Message::Hello&lt;/code&gt;&lt;code&gt;id&lt;/code&gt; field is within the range &lt;code&gt;3...7&lt;/code&gt;. But we also want to bind the value to the variable &lt;code&gt;id_variable&lt;/code&gt; so we can use it in the code associated with the arm. We could name this variable &lt;code&gt;id&lt;/code&gt;, the same as the field, but for this example we&amp;rsquo;ll use a different name.</source>
          <target state="translated">Оператор &lt;em&gt;at&lt;/em&gt; ( &lt;code&gt;@&lt;/code&gt; ) позволяет нам создать переменную, которая содержит значение, в то же время, когда мы проверяем это значение, чтобы увидеть, соответствует ли оно шаблону. В листинге 18-29 показан пример, в котором мы хотим проверить, находится ли поле &lt;code&gt;Message::Hello&lt;/code&gt; &lt;code&gt;id&lt;/code&gt; в диапазоне &lt;code&gt;3...7&lt;/code&gt; . Но мы также хотим привязать значение к переменной &lt;code&gt;id_variable&lt;/code&gt; , чтобы мы могли использовать его в коде, связанном с рукой. Мы могли бы назвать эту переменную &lt;code&gt;id&lt;/code&gt; так же, как поле, но для этого примера мы будем использовать другое имя.</target>
        </trans-unit>
        <trans-unit id="6fe3095ea3510353b505863afd4ade90995e4e2e" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;at&lt;/em&gt; operator (&lt;code&gt;@&lt;/code&gt;) lets us create a variable that holds a value at the same time we&amp;rsquo;re testing that value to see whether it matches a pattern. Listing 18-29 shows an example where we want to test that a &lt;code&gt;Message::Hello&lt;/code&gt;&lt;code&gt;id&lt;/code&gt; field is within the range &lt;code&gt;3..=7&lt;/code&gt;. But we also want to bind the value to the variable &lt;code&gt;id_variable&lt;/code&gt; so we can use it in the code associated with the arm. We could name this variable &lt;code&gt;id&lt;/code&gt;, the same as the field, but for this example we&amp;rsquo;ll use a different name.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="491e011fde2c63e7287e5968a958f99a0e0608ea" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;backslash escape&lt;/em&gt; is the character &lt;code&gt;U+005C&lt;/code&gt; (&lt;code&gt;\&lt;/code&gt;) which must be escaped in order to denote its ASCII encoding &lt;code&gt;0x5C&lt;/code&gt;.</source>
          <target state="translated">&lt;em&gt;Побег обратный слэш&lt;/em&gt; является символ &lt;code&gt;U+005C&lt;/code&gt; ( &lt;code&gt;\&lt;/code&gt; ) , которые должны быть экранированы, чтобы обозначить его ASCII кодирующего &lt;code&gt;0x5C&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e78bebf05e1ce9e264a960c4a634448ed6a163c1" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;backslash escape&lt;/em&gt; is the character &lt;code&gt;U+005C&lt;/code&gt; (&lt;code&gt;\&lt;/code&gt;) which must be escaped in order to denote itself.</source>
          <target state="translated">&lt;em&gt;Побег обратный слэш&lt;/em&gt; является символ &lt;code&gt;U+005C&lt;/code&gt; ( &lt;code&gt;\&lt;/code&gt; ) , которые должны быть экранированы, чтобы обозначить себя.</target>
        </trans-unit>
        <trans-unit id="863e56925d2ff8675a4dd9c4a460d825a809b69e" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;heap&lt;/em&gt; is a general term that describes boxes. The lifetime of an allocation in the heap depends on the lifetime of the box values pointing to it. Since box values may themselves be passed in and out of frames, or stored in the heap, heap allocations may outlive the frame they are allocated within. An allocation in the heap is guaranteed to reside at a single location in the heap for the whole lifetime of the allocation - it will never be relocated as a result of moving a box value.</source>
          <target state="translated">&lt;em&gt;Куча&lt;/em&gt; представляет собой общий термин , который описывает коробки. Время жизни выделения в куче зависит от времени жизни значений поля, указывающих на него. Поскольку значения блоков могут сами передаваться в кадры и из них или сохраняться в куче, выделения в куче могут переживать кадр, в котором они размещены. Выделение в куче гарантированно будет находиться в одном месте в куче в течение всего времени существования выделения - оно никогда не будет перемещено в результате перемещения значения блока.</target>
        </trans-unit>
        <trans-unit id="21ffe4f08baa3ee5d8fcae0ac2b2640039bc170b" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;items&lt;/em&gt; of a program are those functions, modules and types that have their value calculated at compile-time and stored uniquely in the memory image of the rust process. Items are neither dynamically allocated nor freed.</source>
          <target state="translated">В &lt;em&gt;детали&lt;/em&gt; из программы являются теми функциями, модулями и типов , которые их стоимость , рассчитанных во время компиляции и находятся однозначно в образе памяти процесса ржавчины. Элементы не выделяются и не освобождаются динамически.</target>
        </trans-unit>
        <trans-unit id="7f297b31862071391a99da1af535c50f23bb4ea5" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;items&lt;/em&gt; of a program are those functions, modules, and types that have their value calculated at compile-time and stored uniquely in the memory image of the rust process. Items are neither dynamically allocated nor freed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="867bacda5c963969dd78331f878c031b22f73cbb" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;null escape&lt;/em&gt; is the character &lt;code&gt;U+0030&lt;/code&gt; (&lt;code&gt;0&lt;/code&gt;) and denotes the Unicode value &lt;code&gt;U+0000&lt;/code&gt; (NUL).</source>
          <target state="translated">&lt;em&gt;Побег нуля&lt;/em&gt; является символом &lt;code&gt;U+0030&lt;/code&gt; ( &lt;code&gt;0&lt;/code&gt; ) и обозначает значение Unicode &lt;code&gt;U+0000&lt;/code&gt; (NUL).</target>
        </trans-unit>
        <trans-unit id="c0460a3f4832868522908bad2876d5f8fef36d49" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;null escape&lt;/em&gt; is the character &lt;code&gt;U+0030&lt;/code&gt; (&lt;code&gt;0&lt;/code&gt;) and denotes the byte value &lt;code&gt;0x00&lt;/code&gt; (ASCII NUL).</source>
          <target state="translated">&lt;em&gt;Побег нуля&lt;/em&gt; является символом &lt;code&gt;U+0030&lt;/code&gt; ( &lt;code&gt;0&lt;/code&gt; ) и обозначает значение байта &lt;code&gt;0x00&lt;/code&gt; (ASCII NUL).</target>
        </trans-unit>
        <trans-unit id="b4b356718e399f8a05dc4012731a26a28084f252" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;prelude&lt;/em&gt; is the list of things that Rust automatically imports into every Rust program. It's kept as small as possible, and is focused on things, particularly traits, which are used in almost every single Rust program.</source>
          <target state="translated">&lt;em&gt;Прелюдия&lt;/em&gt; список вещей , которые Руст автоматически импортирует в каждую программу Rust. Он минимален, насколько это возможно, и сосредоточен на вещах, особенно на чертах, которые используются почти в каждой программе на Rust.</target>
        </trans-unit>
        <trans-unit id="c5fc79bf9688aa8e786959c2742e411818e5d89a" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;primitive representations&lt;/em&gt; are the representations with the same names as the primitive integer types. That is: &lt;code&gt;u8&lt;/code&gt;, &lt;code&gt;u16&lt;/code&gt;, &lt;code&gt;u32&lt;/code&gt;, &lt;code&gt;u64&lt;/code&gt;, &lt;code&gt;u128&lt;/code&gt;, &lt;code&gt;usize&lt;/code&gt;, &lt;code&gt;i8&lt;/code&gt;, &lt;code&gt;i16&lt;/code&gt;, &lt;code&gt;i32&lt;/code&gt;, &lt;code&gt;i64&lt;/code&gt;, &lt;code&gt;i128&lt;/code&gt;, and &lt;code&gt;isize&lt;/code&gt;.</source>
          <target state="translated">Эти &lt;em&gt;примитивные представления&lt;/em&gt; являются представления с теми же именами, что и примитивных целочисленных типов. То есть: &lt;code&gt;u8&lt;/code&gt; , &lt;code&gt;u16&lt;/code&gt; , &lt;code&gt;u32&lt;/code&gt; , &lt;code&gt;u64&lt;/code&gt; , &lt;code&gt;u128&lt;/code&gt; , &lt;code&gt;usize&lt;/code&gt; , &lt;code&gt;i8&lt;/code&gt; , &lt;code&gt;i16&lt;/code&gt; , &lt;code&gt;i32&lt;/code&gt; , &lt;code&gt;i64&lt;/code&gt; , &lt;code&gt;i128&lt;/code&gt; и &lt;code&gt;isize&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a3ce8f949608b1daede8105623fa327eab5c410b" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;rest pattern&lt;/em&gt; (the &lt;code&gt;..&lt;/code&gt; token) acts as a variable-length pattern which matches zero or more elements that haven't been matched already before and after. It may only be used in &lt;a href=&quot;#tuple-patterns&quot;&gt;tuple&lt;/a&gt;, &lt;a href=&quot;#tuple-struct-patterns&quot;&gt;tuple struct&lt;/a&gt;, and &lt;a href=&quot;#slice-patterns&quot;&gt;slice&lt;/a&gt; patterns, and may only appear once as one of the elements in those patterns. It is also allowed in an &lt;a href=&quot;#identifier-patterns&quot;&gt;identifier pattern&lt;/a&gt; for &lt;a href=&quot;#slice-patterns&quot;&gt;slice patterns&lt;/a&gt; only.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4971362f3b5f40470a74c81b64c44c61022c0ae5" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;size&lt;/em&gt; of a value is the offset in bytes between successive elements in an array with that item type including alignment padding. The size of a value is always a multiple of its alignment. The size of a value can be checked with the &lt;a href=&quot;../std/mem/fn.size_of_val&quot;&gt;&lt;code&gt;size_of_val&lt;/code&gt;&lt;/a&gt; function.</source>
          <target state="translated">&lt;em&gt;Размер&lt;/em&gt; от значения является смещение в байтах между последовательными элементами в массиве с этим типом элемента , включая выравнивание заполнения. Размер значения всегда кратен его выравниванию. Размер значения можно проверить с &lt;a href=&quot;../std/mem/fn.size_of_val&quot;&gt; &lt;code&gt;size_of_val&lt;/code&gt; &lt;/a&gt; функции size_of_val .</target>
        </trans-unit>
        <trans-unit id="608607007d0795edd59e30f51aeabc80ca46b5f6" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;state pattern&lt;/em&gt; is an object-oriented design pattern. The crux of the pattern is that a value has some internal state, which is represented by a set of &lt;em&gt;state objects&lt;/em&gt;, and the value&amp;rsquo;s behavior changes based on the internal state. The state objects share functionality: in Rust, of course, we use structs and traits rather than objects and inheritance. Each state object is responsible for its own behavior and for governing when it should change into another state. The value that holds a state object knows nothing about the different behavior of the states or when to transition between states.</source>
          <target state="translated">&lt;em&gt;Состояние модель&lt;/em&gt; является объектно-ориентированным шаблоном дизайна. Суть шаблона состоит в том, что значение имеет некоторое внутреннее состояние, которое представлено набором &lt;em&gt;объектов состояния&lt;/em&gt; , а поведение значения изменяется в зависимости от внутреннего состояния. Объекты состояния имеют общую функциональность: в Rust, конечно, мы используем структуры и черты, а не объекты и наследование. Каждый объект состояния отвечает за свое поведение и определяет, когда он должен перейти в другое состояние. Значение, содержащее объект состояния, ничего не знает о различном поведении состояний или о том, когда переходить между состояниями.</target>
        </trans-unit>
        <trans-unit id="ec835310b404eed2cb3a60731c66a0fc7069cf96" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;successor&lt;/em&gt; operation moves towards values that compare greater. The &lt;em&gt;predecessor&lt;/em&gt; operation moves towards values that compare lesser.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="71b31d9fd96bdd059ab3da8b882ee0c455f89891" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;temporary scope&lt;/em&gt; of an expression is the scope that is used for the temporary variable that holds the result of that expression when used in a &lt;a href=&quot;expressions#place-expressions-and-value-expressions&quot;&gt;place context&lt;/a&gt;, unless it is &lt;a href=&quot;destructors#constant-promotion&quot;&gt;promoted&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="da892b01ccbdf152bb00bb5fb34ad8db3069d651" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;tuple type&lt;/em&gt; is a structural type&lt;sup&gt;&lt;a href=&quot;#1&quot;&gt;1&lt;/a&gt;&lt;/sup&gt; for heterogeneous lists of other types. Each entry in the list is an &lt;em&gt;element&lt;/em&gt;&lt;sup&gt;&lt;a href=&quot;#2&quot;&gt;2&lt;/a&gt;&lt;/sup&gt; of the tuple. The position of the element makes it the &lt;em&gt;nth element&lt;/em&gt; using zero (&lt;code&gt;0&lt;/code&gt;) as the initial index.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="50c8131f661492ad3eb04d5338d01ccf9f429562" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;wildcard pattern&lt;/em&gt; (an underscore symbol) matches any value. It is used to ignore values when they don't matter. Inside other patterns it matches a single data field (as opposed to the &lt;code&gt;..&lt;/code&gt; which matches the remaining fields). Unlike identifier patterns, it does not copy, move or borrow the value it matches.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2c707e6c38639fd82e39cc81120827bce74e177e" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;wildcard pattern&lt;/em&gt; matches any value. It is used to ignore values when they don't matter. Inside other patterns it matches a single data field (as opposed to the &lt;code&gt;..&lt;/code&gt; which matches the remaining fields). Unlike identifier patterns, it does not copy, move or borrow the value it matches.</source>
          <target state="translated">&lt;em&gt;Подстановочный шаблон&lt;/em&gt; соответствует любому значению. Он используется для игнорирования значений, когда они не имеют значения. Внутри других шаблонов он соответствует одному полю данных (в отличие от &lt;code&gt;..&lt;/code&gt; , который соответствует остальным полям). В отличие от шаблонов идентификаторов, он не копирует, не перемещает и не заимствует соответствующее значение.</target>
        </trans-unit>
        <trans-unit id="75f0595163c83b48141e476739787cd1006a8d33" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;channel&lt;/strong&gt;'s sending half has become disconnected, and there will never be any more data received on it.</source>
          <target state="translated">&lt;strong&gt;Канал&lt;/strong&gt; &amp;laquo;ы отправки половина отсоединены, и никогда не будет каких - либо дополнительных данных , полученных от него.</target>
        </trans-unit>
        <trans-unit id="7d020769b0b6d90680db8e09c6dc6e9b663dc909" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;compiler&lt;/strong&gt; reordering instructions: If the compiler can issue an instruction at an earlier point, it will try to do so. For example, it might hoist memory loads at the top of a code block, so that the CPU can start &lt;a href=&quot;https://en.wikipedia.org/wiki/Cache_prefetching&quot;&gt;prefetching&lt;/a&gt; the values from memory.</source>
          <target state="translated">&lt;strong&gt;Компилятор&lt;/strong&gt; переназначения инструкции: Если компилятор может выдать команду на более раннем этапе, он будет пытаться сделать это. Например, он может увеличить загрузку памяти в верхней части блока кода, чтобы ЦП мог начать &lt;a href=&quot;https://en.wikipedia.org/wiki/Cache_prefetching&quot;&gt;предварительную выборку&lt;/a&gt; значений из памяти.</target>
        </trans-unit>
        <trans-unit id="314b68cd7b660a21edb44d2117cd4a156ae245a5" translate="yes" xml:space="preserve">
          <source>The API documentation that &lt;code&gt;cargo doc&lt;/code&gt; generates for this crate will now list and link re-exports on the front page, as shown in Figure 14-4, making the &lt;code&gt;PrimaryColor&lt;/code&gt; and &lt;code&gt;SecondaryColor&lt;/code&gt; types and the &lt;code&gt;mix&lt;/code&gt; function easier to find.</source>
          <target state="translated">Документация API, которую создает документ &lt;code&gt;cargo doc&lt;/code&gt; для этого ящика, теперь будет содержать список реэкспортов и ссылки на них на главной странице, как показано на рис. 14-4, что &lt;code&gt;PrimaryColor&lt;/code&gt; типов PrimaryColor и &lt;code&gt;SecondaryColor&lt;/code&gt; и функции &lt;code&gt;mix&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="fe97d53a4341ff985473c7759453c7f0b6f51809" translate="yes" xml:space="preserve">
          <source>The API is typically used by acquiring a handle to the current thread, placing that handle in a shared data structure so that other threads can find it, and then &lt;code&gt;park&lt;/code&gt;ing in a loop. When some desired condition is met, another thread calls &lt;a href=&quot;struct.thread#method.unpark&quot;&gt;&lt;code&gt;unpark&lt;/code&gt;&lt;/a&gt; on the handle.</source>
          <target state="translated">API обычно используется путем получения дескриптора текущего потока, помещения этого дескриптора в общую структуру данных, чтобы другие потоки могли его найти, а затем &lt;code&gt;park&lt;/code&gt; в цикле. Когда некоторые желаемое условие выполняется, другой поток вызовов &lt;a href=&quot;struct.thread#method.unpark&quot;&gt; &lt;code&gt;unpark&lt;/code&gt; &lt;/a&gt; на ручке.</target>
        </trans-unit>
        <trans-unit id="bdef16eb0aad1c8443510daaf0eaf64f22da449f" translate="yes" xml:space="preserve">
          <source>The API of &lt;code id=&quot;the-api-of-mutext&quot;&gt;Mutex&amp;lt;T&amp;gt;&lt;/code&gt;</source>
          <target state="translated">API &lt;code id=&quot;the-api-of-mutext&quot;&gt;Mutex&amp;lt;T&amp;gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="da2fca5419425bb1dfeff3a19e5e6b522b71b9f7" translate="yes" xml:space="preserve">
          <source>The Anatomy of a Test Function</source>
          <target state="translated">Анатомия тестовой функции</target>
        </trans-unit>
        <trans-unit id="6ff9dd46af7ebe72f506f56aea2ffd15b7f82cfe" translate="yes" xml:space="preserve">
          <source>The Array Type</source>
          <target state="translated">Тип массива</target>
        </trans-unit>
        <trans-unit id="4c7fdb8a442bced7fcc6b743d86e4b178b1bc140" translate="yes" xml:space="preserve">
          <source>The Boolean Type</source>
          <target state="translated">Булевский тип</target>
        </trans-unit>
        <trans-unit id="7a47e0b8b6b1bfa40f74993b9ed02984c335782d" translate="yes" xml:space="preserve">
          <source>The Boolean type, &lt;code&gt;bool&lt;/code&gt;, with values &lt;code&gt;true&lt;/code&gt; and &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">Тип Boolean, &lt;code&gt;bool&lt;/code&gt; , со значениями &lt;code&gt;true&lt;/code&gt; и &lt;code&gt;false&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d554fe4c508301c7dd79586706f031038650a679" translate="yes" xml:space="preserve">
          <source>The Borrow Checker</source>
          <target state="translated">Проверка по кредиту</target>
        </trans-unit>
        <trans-unit id="706bc5bdd045092d3c34365727a87c607d4ff3a3" translate="yes" xml:space="preserve">
          <source>The C side must &lt;strong&gt;not&lt;/strong&gt; modify the length of the string (by writing a &lt;code&gt;NULL&lt;/code&gt; somewhere inside the string or removing the final one) before it makes it back into Rust using &lt;a href=&quot;struct.cstring#method.from_raw&quot;&gt;&lt;code&gt;CString::from_raw&lt;/code&gt;&lt;/a&gt;. See the safety section in &lt;a href=&quot;struct.cstring#method.from_raw&quot;&gt;&lt;code&gt;CString::from_raw&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="096fc2c3eb95fb5d0ee6aa092c0689c069929e6f" translate="yes" xml:space="preserve">
          <source>The C-main function only supports to return integers as return type. So, every type implementing the &lt;code&gt;Termination&lt;/code&gt; trait has to be converted to an integer.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="da6976366f57ccb20ad430117c89098f7fb1348a" translate="yes" xml:space="preserve">
          <source>The C-variadic type &lt;code&gt;...&lt;/code&gt; has been nested inside another type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="86641abf85c69d8c4f7c9c71c79144e3a2832005" translate="yes" xml:space="preserve">
          <source>The Character Type</source>
          <target state="translated">Тип персонажа</target>
        </trans-unit>
        <trans-unit id="35e39875eebfabcb5b0b8cd30288767fc0b6add8" translate="yes" xml:space="preserve">
          <source>The Clippy tool is a collection of lints to analyze your code so you can catch common mistakes and improve your Rust code.</source>
          <target state="translated">Инструмент Clippy представляет собой набор линков для анализа вашего кода,чтобы вы могли поймать распространенные ошибки и улучшить свой Rust код.</target>
        </trans-unit>
        <trans-unit id="bb08bad287d0caba2752b58d322b62f2942d38e6" translate="yes" xml:space="preserve">
          <source>The Default Representation</source>
          <target state="translated">Представительство по умолчанию</target>
        </trans-unit>
        <trans-unit id="f9e1a59444e395f067802b105261ac31a11eac66" translate="yes" xml:space="preserve">
          <source>The Difference Between Macros and Functions</source>
          <target state="translated">Разница между макросами и функциями...</target>
        </trans-unit>
        <trans-unit id="7241096a248faf0667959dae2f7e6a0390d29dce" translate="yes" xml:space="preserve">
          <source>The GID part of the peer credential. This is the effective GID of the process at the domain socket's endpoint.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="47f6987535ee435e225cb875fe024ba6f3b75e49" translate="yes" xml:space="preserve">
          <source>The Glob Operator</source>
          <target state="translated">Глобус-оператор</target>
        </trans-unit>
        <trans-unit id="a0a1aaf98c3bce57246183f1baadfe83da9b49cd" translate="yes" xml:space="preserve">
          <source>The HTML format is available online at &lt;a href=&quot;https://doc.rust-lang.org/stable/book/index.html&quot;&gt;https://doc.rust-lang.org/stable/book/&lt;/a&gt; and offline with installations of Rust made with &lt;code&gt;rustup&lt;/code&gt;; run &lt;code&gt;rustup docs --book&lt;/code&gt; to open.</source>
          <target state="translated">Формат HTML доступен онлайн по адресу &lt;a href=&quot;https://doc.rust-lang.org/stable/book/index.html&quot;&gt;https://doc.rust-lang.org/stable/book/&lt;/a&gt; и офлайн с установками Rust, сделанными с помощью &lt;code&gt;rustup&lt;/code&gt; ; запустите &lt;code&gt;rustup docs --book&lt;/code&gt; , чтобы открыть.</target>
        </trans-unit>
        <trans-unit id="00df77514c97d921fca4a972435309219a163a06" translate="yes" xml:space="preserve">
          <source>The I/O Prelude</source>
          <target state="translated">Прелюдия к вводу/выводу</target>
        </trans-unit>
        <trans-unit id="6979c051972c7d2da3658847fabbf6a31d84bdb5" translate="yes" xml:space="preserve">
          <source>The I/O operation's timeout expired, causing it to be canceled.</source>
          <target state="translated">Тайм-аут операции ввода-вывода истек,что привело к ее отмене.</target>
        </trans-unit>
        <trans-unit id="dc9c14a7eb4854c512e7ed69d5ba6a43f9c253aa" translate="yes" xml:space="preserve">
          <source>The IEEE 754-2008 &quot;binary32&quot; and &quot;binary64&quot; floating-point types are &lt;code&gt;f32&lt;/code&gt; and &lt;code&gt;f64&lt;/code&gt;, respectively.</source>
          <target state="translated">IEEE 754-2008 &amp;laquo;binary32&amp;raquo; и &amp;laquo;binary64&amp;raquo; типа с плавающей точкой &lt;code&gt;f32&lt;/code&gt; и &lt;code&gt;f64&lt;/code&gt; соответственно.</target>
        </trans-unit>
        <trans-unit id="a46bc695392f8c742f4e678a79ed2375790074cb" translate="yes" xml:space="preserve">
          <source>The Matcher Invariants</source>
          <target state="translated">Инварианты Мэтчера</target>
        </trans-unit>
        <trans-unit id="5eece4981b24083c68ecabd071b66fe17ba1ce62" translate="yes" xml:space="preserve">
          <source>The Never Type that Never Returns</source>
          <target state="translated">Тип &quot;Никогда&quot;,который никогда не возвращается</target>
        </trans-unit>
        <trans-unit id="388566f1f9117600ae22e2ebff51f82d448e95e2" translate="yes" xml:space="preserve">
          <source>The PID part of the peer credential. This field is optional because the PID part of the peer credentials is not supported on every platform. On platforms where the mechanism to discover the PID exists, this field will be populated to the PID of the process at the domain socket's endpoint. Otherwise, it will be set to None.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="41b8e7692f976fe91f0cb8053dcf33a7090a4f8c" translate="yes" xml:space="preserve">
          <source>The Pattern API provides a generic mechanism for using different pattern types when searching through a string.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ba8021c95f458659340856b34b5ce555bddda300" translate="yes" xml:space="preserve">
          <source>The RFC Process and Teams</source>
          <target state="translated">Процесс и команды КСФ</target>
        </trans-unit>
        <trans-unit id="667bd8e20b1ba8153f27c9ff6c220024562a73c6" translate="yes" xml:space="preserve">
          <source>The Rules of References</source>
          <target state="translated">Правила использования ссылок</target>
        </trans-unit>
        <trans-unit id="161ef3f14aee5229baf3e48cdbbdab5a784349b3" translate="yes" xml:space="preserve">
          <source>The Rust Language Server powers Integrated Development Environment (IDE) integration for code completion and inline error messages.</source>
          <target state="translated">Сервер Rust Language Server поддерживает интеграцию с интегрированной средой разработки (IDE)для завершения кода и сообщений об ошибках.</target>
        </trans-unit>
        <trans-unit id="efbadde43b4ea2876af269fef5bbeff660435dad" translate="yes" xml:space="preserve">
          <source>The Rust Prelude</source>
          <target state="translated">Прелюдия Ржавчины</target>
        </trans-unit>
        <trans-unit id="1e47c327d13b68cc315d8c0718500294854d4bd4" translate="yes" xml:space="preserve">
          <source>The Rust Prelude.</source>
          <target state="translated">Прелюдия Ржавчины.</target>
        </trans-unit>
        <trans-unit id="64d4853b323b63d9ca56f4771bf913212d9ace7a" translate="yes" xml:space="preserve">
          <source>The Rust Programming Language</source>
          <target state="translated">Язык программирования ржавчины</target>
        </trans-unit>
        <trans-unit id="0bb645ae646711df91105c5e5d03daf9c88ee91b" translate="yes" xml:space="preserve">
          <source>The Rust Standard Library</source>
          <target state="translated">Стандартная библиотека &quot;Ржавчина</target>
        </trans-unit>
        <trans-unit id="9c789ddc154274d796ddc2e963326017f63c2958" translate="yes" xml:space="preserve">
          <source>The Rust Standard Library is the foundation of portable Rust software, a set of minimal and battle-tested shared abstractions for the &lt;a href=&quot;https://crates.io&quot;&gt;broader Rust ecosystem&lt;/a&gt;. It offers core types, like &lt;a href=&quot;vec/index&quot;&gt;&lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;option/enum.option&quot;&gt;&lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt;, library-defined &lt;a href=&quot;#primitives&quot;&gt;operations on language primitives&lt;/a&gt;, &lt;a href=&quot;#macros&quot;&gt;standard macros&lt;/a&gt;, &lt;a href=&quot;io/index&quot;&gt;I/O&lt;/a&gt; and &lt;a href=&quot;thread/index&quot;&gt;multithreading&lt;/a&gt;, among &lt;a href=&quot;#what-is-in-the-standard-library-documentation&quot;&gt;many other things&lt;/a&gt;.</source>
          <target state="translated">Стандартная библиотека Rust - это основа портативного программного обеспечения Rust, набора минимальных и проверенных в боях общих абстракций для &lt;a href=&quot;https://crates.io&quot;&gt;более широкой экосистемы Rust&lt;/a&gt; . Он предлагает основные типы, такие как &lt;a href=&quot;vec/index&quot;&gt; &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; &lt;/a&gt; и &lt;a href=&quot;option/enum.option&quot;&gt; &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt; &lt;/a&gt; , определяемые библиотекой &lt;a href=&quot;#primitives&quot;&gt;операции с языковыми примитивами&lt;/a&gt; , &lt;a href=&quot;#macros&quot;&gt;стандартные макросы&lt;/a&gt; , &lt;a href=&quot;io/index&quot;&gt;ввод-вывод&lt;/a&gt; и &lt;a href=&quot;thread/index&quot;&gt;многопоточность&lt;/a&gt; , а также &lt;a href=&quot;#what-is-in-the-standard-library-documentation&quot;&gt;многое другое&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="4d3f2d23ee5d88e5e35ea9e8e79bcbc0fd6e3b11" translate="yes" xml:space="preserve">
          <source>The Rust Standard Library is the foundation of portable Rust software, a set of minimal and battle-tested shared abstractions for the &lt;a href=&quot;https://crates.io&quot;&gt;broader Rust ecosystem&lt;/a&gt;. It offers core types, like &lt;a href=&quot;vec/struct.vec&quot;&gt;&lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;option/enum.option&quot;&gt;&lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt;, library-defined &lt;a href=&quot;#primitives&quot;&gt;operations on language primitives&lt;/a&gt;, &lt;a href=&quot;#macros&quot;&gt;standard macros&lt;/a&gt;, &lt;a href=&quot;io/index&quot;&gt;I/O&lt;/a&gt; and &lt;a href=&quot;thread/index&quot;&gt;multithreading&lt;/a&gt;, among &lt;a href=&quot;#what-is-in-the-standard-library-documentation&quot;&gt;many other things&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5c3853d774e4956749b7c91653db336f2eec58d4" translate="yes" xml:space="preserve">
          <source>The Rust compiler does not consider the following behaviors &lt;em&gt;unsafe&lt;/em&gt;, though a programmer may (should) find them undesirable, unexpected, or erroneous.</source>
          <target state="translated">Компилятор Rust не считает следующее поведение &lt;em&gt;небезопасным&lt;/em&gt; , хотя программист может (должен) счесть их нежелательными, неожиданными или ошибочными.</target>
        </trans-unit>
        <trans-unit id="21b3dd0203ec587beb1963c1f4feb0c5c3e73b91" translate="yes" xml:space="preserve">
          <source>The Rust compiler has a &lt;em&gt;borrow checker&lt;/em&gt; that compares scopes to determine whether all borrows are valid. Listing 10-18 shows the same code as Listing 10-17 but with annotations showing the lifetimes of the variables.</source>
          <target state="translated">В компиляторе Rust есть средство &lt;em&gt;проверки заимствований,&lt;/em&gt; которое сравнивает объемы, чтобы определить, все ли заимствования действительны. В листинге 10-18 показан тот же код, что и в листинге 10-17, но с аннотациями, показывающими время жизни переменных.</target>
        </trans-unit>
        <trans-unit id="bac79421ac7e7f4a69670a43a87279fa1ea360c9" translate="yes" xml:space="preserve">
          <source>The Rust compiler is always invoked with a single source file as input, and always produces a single output crate. The processing of that source file may result in other source files being loaded as modules. Source files have the extension &lt;code&gt;.rs&lt;/code&gt;.</source>
          <target state="translated">Компилятор Rust всегда вызывается с одним исходным файлом в качестве ввода и всегда производит один выходной ящик. Обработка этого исходного файла может привести к загрузке других исходных файлов как модулей. Исходные файлы имеют расширение &lt;code&gt;.rs&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="edecdb50208b6b73bf12c25a96c41ebd3a559a66" translate="yes" xml:space="preserve">
          <source>The Rust language and compiler have a six-week release cycle, meaning users get a constant stream of new features. Other programming languages release larger changes less often; Rust releases smaller updates more frequently. After a while, all of these tiny changes add up. But from release to release, it can be difficult to look back and say, &amp;ldquo;Wow, between Rust 1.10 and Rust 1.31, Rust has changed a lot!&amp;rdquo;</source>
          <target state="translated">У языка и компилятора Rust шестинедельный цикл выпуска, что означает, что пользователи получают постоянный поток новых функций. Другие языки программирования реже выпускают более крупные изменения; Rust чаще выпускает небольшие обновления. Через некоторое время все эти крошечные изменения складываются. Но от выпуска к выпуску бывает трудно оглянуться назад и сказать: &amp;laquo;Ух ты, между Rust 1.10 и Rust 1.31 Rust сильно изменился!&amp;raquo;</target>
        </trans-unit>
        <trans-unit id="bb670b9e802863986c803bc2c279a2c3ad127d26" translate="yes" xml:space="preserve">
          <source>The Rust language has a set of &lt;em&gt;keywords&lt;/em&gt; that are reserved for use by the language only, much as in other languages. Keep in mind that you cannot use these words as names of variables or functions. Most of the keywords have special meanings, and you&amp;rsquo;ll be using them to do various tasks in your Rust programs; a few have no current functionality associated with them but have been reserved for functionality that might be added to Rust in the future. You can find a list of the keywords in &lt;a href=&quot;appendix-01-keywords&quot;&gt;Appendix A&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4db8a730c896d57ac8ae13218ced391891bc4c9e" translate="yes" xml:space="preserve">
          <source>The Rust language has a set of &lt;em&gt;keywords&lt;/em&gt; that are reserved for use by the language only, much as in other languages. Keep in mind that you cannot use these words as names of variables or functions. Most of the keywords have special meanings, and you&amp;rsquo;ll be using them to do various tasks in your Rust programs; a few have no current functionality associated with them but have been reserved for functionality that might be added to Rust in the future. You can find a list of the keywords in Appendix A.</source>
          <target state="translated">В языке Rust есть набор &lt;em&gt;ключевых слов&lt;/em&gt; , которые зарезервированы только для использования в этом языке, как и в других языках. Имейте в виду, что вы не можете использовать эти слова в качестве имен переменных или функций. Большинство ключевых слов имеют особое значение, и вы будете использовать их для выполнения различных задач в своих программах на Rust; некоторые из них не имеют связанных с ними текущих функций, но они зарезервированы для функций, которые могут быть добавлены в Rust в будущем. Вы можете найти список ключевых слов в Приложении A.</target>
        </trans-unit>
        <trans-unit id="5c421a36adf32e1316c136776ce05dd83536c6c8" translate="yes" xml:space="preserve">
          <source>The Rust language hopes to support many other users as well; those mentioned here are merely some of the biggest stakeholders. Overall, Rust&amp;rsquo;s greatest ambition is to eliminate the trade-offs that programmers have accepted for decades by providing safety &lt;em&gt;and&lt;/em&gt; productivity, speed &lt;em&gt;and&lt;/em&gt; ergonomics. Give Rust a try and see if its choices work for you.</source>
          <target state="translated">Язык Rust надеется поддержать и многих других пользователей; упомянутые здесь - лишь некоторые из крупнейших заинтересованных сторон. В целом, самая большая цель Rust - устранить компромиссы, на которые программисты шли десятилетиями, путем обеспечения безопасности &lt;em&gt;и&lt;/em&gt; производительности, скорости &lt;em&gt;и&lt;/em&gt; эргономики. Попробуйте Rust и посмотрите, работают ли его варианты для вас.</target>
        </trans-unit>
        <trans-unit id="596e2b7dbc791cd3cfc77236ae00a927665967e2" translate="yes" xml:space="preserve">
          <source>The Rust runtime</source>
          <target state="translated">Ржавчина</target>
        </trans-unit>
        <trans-unit id="6be65bd73ad861e62f3888e1cc3672c017c1636b" translate="yes" xml:space="preserve">
          <source>The Rust standard library provides channels for message passing and smart pointer types, such as &lt;code&gt;Mutex&amp;lt;T&amp;gt;&lt;/code&gt; and &lt;code&gt;Arc&amp;lt;T&amp;gt;&lt;/code&gt;, that are safe to use in concurrent contexts. The type system and the borrow checker ensure that the code using these solutions won&amp;rsquo;t end up with data races or invalid references. Once you get your code to compile, you can rest assured that it will happily run on multiple threads without the kinds of hard-to-track-down bugs common in other languages. Concurrent programming is no longer a concept to be afraid of: go forth and make your programs concurrent, fearlessly!</source>
          <target state="translated">Стандартная библиотека Rust предоставляет каналы для передачи сообщений и типы интеллектуальных указателей, такие как &lt;code&gt;Mutex&amp;lt;T&amp;gt;&lt;/code&gt; и &lt;code&gt;Arc&amp;lt;T&amp;gt;&lt;/code&gt; , которые можно безопасно использовать в параллельных контекстах. Система типов и средство проверки заимствований гарантируют, что код, использующий эти решения, не закончится гонкой данных или недопустимыми ссылками. После того, как вы скомпилируете свой код, вы можете быть уверены, что он будет успешно работать в нескольких потоках без сложных для отслеживания ошибок, характерных для других языков. Параллельное программирование больше не является концепцией, которой следует бояться: продолжайте и бесстрашно создавайте параллельные программы!</target>
        </trans-unit>
        <trans-unit id="ca0e948d58962dbdfe194b991ab15a2f509a074c" translate="yes" xml:space="preserve">
          <source>The Rust type system has some features that we&amp;rsquo;ve mentioned in this book but haven&amp;rsquo;t yet discussed. We&amp;rsquo;ll start by discussing newtypes in general as we examine why newtypes are useful as types. Then we&amp;rsquo;ll move on to type aliases, a feature similar to newtypes but with slightly different semantics. We&amp;rsquo;ll also discuss the &lt;code&gt;!&lt;/code&gt; type and dynamically sized types.</source>
          <target state="translated">Система типов Rust имеет некоторые особенности, которые мы упоминали в этой книге, но еще не обсуждали. Мы начнем с обсуждения новых типов в целом, поскольку мы исследуем, почему новые типы полезны как типы. Затем мы перейдем к псевдонимам типов - функции, аналогичной новым типам, но с немного другой семантикой. Мы также обсудим &lt;code&gt;!&lt;/code&gt; тип и типы с динамическим размером.</target>
        </trans-unit>
        <trans-unit id="1e24d83679bf4a662ce93151d4c79beb7bc3d976" translate="yes" xml:space="preserve">
          <source>The Slice Type</source>
          <target state="translated">Тип среза</target>
        </trans-unit>
        <trans-unit id="b60a9b411326be4b7b78e74a3c2736078d2cb936" translate="yes" xml:space="preserve">
          <source>The Stack and the Heap</source>
          <target state="translated">Штабель и куча</target>
        </trans-unit>
        <trans-unit id="ea9187c27f13ce2d0fda228c7804b1eacb2a7df4" translate="yes" xml:space="preserve">
          <source>The Static Lifetime</source>
          <target state="translated">Статическое время жизни</target>
        </trans-unit>
        <trans-unit id="dcc1bdcf64d9ba08b8c546b48a03373f9d896f1a" translate="yes" xml:space="preserve">
          <source>The Tests Module and &lt;code id=&quot;the-tests-module-and-cfgtest&quot;&gt;#[cfg(test)]&lt;/code&gt;</source>
          <target state="translated">Модуль &quot;Тесты&quot; и &lt;code id=&quot;the-tests-module-and-cfgtest&quot;&gt;#[cfg(test)]&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="43d375d205a43568d44e006351aba054a3a6df0e" translate="yes" xml:space="preserve">
          <source>The Trade-Offs of Using &lt;code id=&quot;the-trade-offs-of-using-clone&quot;&gt;clone&lt;/code&gt;</source>
          <target state="translated">Компромиссы использования &lt;code id=&quot;the-trade-offs-of-using-clone&quot;&gt;clone&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="874f680f597dff734725c0edb8d1cdbdc1c687fb" translate="yes" xml:space="preserve">
          <source>The Transmission Control Protocol is specified in &lt;a href=&quot;https://tools.ietf.org/html/rfc793&quot;&gt;IETF RFC 793&lt;/a&gt;.</source>
          <target state="translated">Протокол управления передачей указан в &lt;a href=&quot;https://tools.ietf.org/html/rfc793&quot;&gt;IETF RFC 793&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="6d2bc0207cf3386e89a8ff90f2a45c74d008dd6b" translate="yes" xml:space="preserve">
          <source>The Tuple Type</source>
          <target state="translated">Тип кортежа</target>
        </trans-unit>
        <trans-unit id="a1fe62622ad4944befb6b7cd3fbf5afe74512445" translate="yes" xml:space="preserve">
          <source>The UID part of the peer credential. This is the effective UID of the process at the domain socket's endpoint.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="720acae72ae852d88680bc6199aaf2a3185402bd" translate="yes" xml:space="preserve">
          <source>The Unsize trait should not be implemented directly. All implementations of Unsize are provided automatically by the compiler.</source>
          <target state="translated">Непосредственная реализация характеристики &quot;Unsize&quot; не должна быть осуществлена.Все реализации Unsize предоставляются компилятором автоматически.</target>
        </trans-unit>
        <trans-unit id="9d8c2343fd3b49fd50014f949ed7698cf46aba4f" translate="yes" xml:space="preserve">
          <source>The ability to return a type that is only specified by the trait it implements is especially useful in the context of closures and iterators, which we cover in Chapter 13. Closures and iterators create types that only the compiler knows or types that are very long to specify. The &lt;code&gt;impl Trait&lt;/code&gt; syntax lets you concisely specify that a function returns some type that implements the &lt;code&gt;Iterator&lt;/code&gt; trait without needing to write out a very long type.</source>
          <target state="translated">Возможность возвращать тип, который определяется только реализуемым им признаком, особенно полезен в контексте замыканий и итераторов, которые мы рассмотрим в главе 13. Замыкания и итераторы создают типы, которые знает только компилятор, или типы, которые очень длинные. уточнить. &lt;code&gt;impl Trait&lt;/code&gt; синтаксис позволяет лаконично определить , что функция возвращает некоторый тип , который реализует &lt;code&gt;Iterator&lt;/code&gt; Trait без необходимости выписывать очень длинный тип.</target>
        </trans-unit>
        <trans-unit id="8344955111fdc074c9729e11010ee2eab0af03c1" translate="yes" xml:space="preserve">
          <source>The above example can be resolved by either reducing the number of lifetime bounds to one or by making the trait object lifetime explicit, like so:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cde40ac9fea8ec2f55d9ca0d422fc89008496087" translate="yes" xml:space="preserve">
          <source>The above indirection is the additional runtime cost of calling a function on a &lt;code&gt;dyn Trait&lt;/code&gt;. Methods called by dynamic dispatch generally cannot be inlined by the compiler.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="deb20b7d624d1708cb7603af7f7d5931910cd966" translate="yes" xml:space="preserve">
          <source>The above is &lt;em&gt;still&lt;/em&gt; an expression but it will always evaluate to &lt;code&gt;()&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ede9c72b891dfc1d92b0b9fffc4f21007f9ae902" translate="yes" xml:space="preserve">
          <source>The absolute value of &lt;code&gt;i128::MIN&lt;/code&gt; cannot be represented as an &lt;code&gt;i128&lt;/code&gt;, and attempting to calculate it will cause an overflow. This means that code in debug mode will trigger a panic on this case and optimized code will return &lt;code&gt;i128::MIN&lt;/code&gt; without a panic.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e4ff7b2880604f74445f905b71fdee96836fc628" translate="yes" xml:space="preserve">
          <source>The absolute value of &lt;code&gt;i128::min_value()&lt;/code&gt; cannot be represented as an &lt;code&gt;i128&lt;/code&gt;, and attempting to calculate it will cause an overflow. This means that code in debug mode will trigger a panic on this case and optimized code will return &lt;code&gt;i128::min_value()&lt;/code&gt; without a panic.</source>
          <target state="translated">Абсолютное значение &lt;code&gt;i128::min_value()&lt;/code&gt; не может быть представлено как &lt;code&gt;i128&lt;/code&gt; , и попытка его вычисления вызовет переполнение. Это означает, что код в режиме отладки вызовет панику в этом случае, а оптимизированный код вернет &lt;code&gt;i128::min_value()&lt;/code&gt; без паники.</target>
        </trans-unit>
        <trans-unit id="68e6f1c95dcf27a099d3d4e155f55896bf8faf93" translate="yes" xml:space="preserve">
          <source>The absolute value of &lt;code&gt;i16::MIN&lt;/code&gt; cannot be represented as an &lt;code&gt;i16&lt;/code&gt;, and attempting to calculate it will cause an overflow. This means that code in debug mode will trigger a panic on this case and optimized code will return &lt;code&gt;i16::MIN&lt;/code&gt; without a panic.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c6634b50eb0aa3afe906f4e13b4800cc26454c92" translate="yes" xml:space="preserve">
          <source>The absolute value of &lt;code&gt;i16::min_value()&lt;/code&gt; cannot be represented as an &lt;code&gt;i16&lt;/code&gt;, and attempting to calculate it will cause an overflow. This means that code in debug mode will trigger a panic on this case and optimized code will return &lt;code&gt;i16::min_value()&lt;/code&gt; without a panic.</source>
          <target state="translated">Абсолютное значение &lt;code&gt;i16::min_value()&lt;/code&gt; не может быть представлено как &lt;code&gt;i16&lt;/code&gt; , и попытка его вычисления вызовет переполнение. Это означает, что код в режиме отладки вызовет панику в этом случае, а оптимизированный код вернет &lt;code&gt;i16::min_value()&lt;/code&gt; без паники.</target>
        </trans-unit>
        <trans-unit id="37e2f0833c2e3fce2e0d86c6e578d1435f9c3b8f" translate="yes" xml:space="preserve">
          <source>The absolute value of &lt;code&gt;i32::MIN&lt;/code&gt; cannot be represented as an &lt;code&gt;i32&lt;/code&gt;, and attempting to calculate it will cause an overflow. This means that code in debug mode will trigger a panic on this case and optimized code will return &lt;code&gt;i32::MIN&lt;/code&gt; without a panic.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="91a991a9b7dce7a35eefa5dff81ee4a280a7e4f1" translate="yes" xml:space="preserve">
          <source>The absolute value of &lt;code&gt;i32::min_value()&lt;/code&gt; cannot be represented as an &lt;code&gt;i32&lt;/code&gt;, and attempting to calculate it will cause an overflow. This means that code in debug mode will trigger a panic on this case and optimized code will return &lt;code&gt;i32::min_value()&lt;/code&gt; without a panic.</source>
          <target state="translated">Абсолютное значение &lt;code&gt;i32::min_value()&lt;/code&gt; не может быть представлено как &lt;code&gt;i32&lt;/code&gt; , и попытка его вычисления вызовет переполнение. Это означает, что код в режиме отладки вызовет панику в этом случае, а оптимизированный код вернет &lt;code&gt;i32::min_value()&lt;/code&gt; без паники.</target>
        </trans-unit>
        <trans-unit id="2ddae722d1b9330d37bd61655516374aae130695" translate="yes" xml:space="preserve">
          <source>The absolute value of &lt;code&gt;i64::MIN&lt;/code&gt; cannot be represented as an &lt;code&gt;i64&lt;/code&gt;, and attempting to calculate it will cause an overflow. This means that code in debug mode will trigger a panic on this case and optimized code will return &lt;code&gt;i64::MIN&lt;/code&gt; without a panic.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4c50c4d71fa72eabc1e0818c0a858ae1903c1c3c" translate="yes" xml:space="preserve">
          <source>The absolute value of &lt;code&gt;i64::min_value()&lt;/code&gt; cannot be represented as an &lt;code&gt;i64&lt;/code&gt;, and attempting to calculate it will cause an overflow. This means that code in debug mode will trigger a panic on this case and optimized code will return &lt;code&gt;i64::min_value()&lt;/code&gt; without a panic.</source>
          <target state="translated">Абсолютное значение &lt;code&gt;i64::min_value()&lt;/code&gt; не может быть представлено как &lt;code&gt;i64&lt;/code&gt; , и попытка его вычисления вызовет переполнение. Это означает, что код в режиме отладки вызовет панику в этом случае, а оптимизированный код вернет &lt;code&gt;i64::min_value()&lt;/code&gt; без паники.</target>
        </trans-unit>
        <trans-unit id="94540f2ba32a8d4e2123f1b683b0ff15f6511fa8" translate="yes" xml:space="preserve">
          <source>The absolute value of &lt;code&gt;i8::MIN&lt;/code&gt; cannot be represented as an &lt;code&gt;i8&lt;/code&gt;, and attempting to calculate it will cause an overflow. This means that code in debug mode will trigger a panic on this case and optimized code will return &lt;code&gt;i8::MIN&lt;/code&gt; without a panic.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5adbbbaac9cedf98e39759b8920bdb3431d04107" translate="yes" xml:space="preserve">
          <source>The absolute value of &lt;code&gt;i8::min_value()&lt;/code&gt; cannot be represented as an &lt;code&gt;i8&lt;/code&gt;, and attempting to calculate it will cause an overflow. This means that code in debug mode will trigger a panic on this case and optimized code will return &lt;code&gt;i8::min_value()&lt;/code&gt; without a panic.</source>
          <target state="translated">Абсолютное значение &lt;code&gt;i8::min_value()&lt;/code&gt; не может быть представлено как &lt;code&gt;i8&lt;/code&gt; , и попытка его вычислить вызовет переполнение. Это означает, что код в режиме отладки вызовет панику в этом случае, а оптимизированный код вернет &lt;code&gt;i8::min_value()&lt;/code&gt; без паники.</target>
        </trans-unit>
        <trans-unit id="f3616827787c274826d0feb8bc695ca0f90e8398" translate="yes" xml:space="preserve">
          <source>The absolute value of &lt;code&gt;isize::MIN&lt;/code&gt; cannot be represented as an &lt;code&gt;isize&lt;/code&gt;, and attempting to calculate it will cause an overflow. This means that code in debug mode will trigger a panic on this case and optimized code will return &lt;code&gt;isize::MIN&lt;/code&gt; without a panic.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5fa62dd0a50bd4c5554cb57272ae5164c2e1f601" translate="yes" xml:space="preserve">
          <source>The absolute value of &lt;code&gt;isize::min_value()&lt;/code&gt; cannot be represented as an &lt;code&gt;isize&lt;/code&gt;, and attempting to calculate it will cause an overflow. This means that code in debug mode will trigger a panic on this case and optimized code will return &lt;code&gt;isize::min_value()&lt;/code&gt; without a panic.</source>
          <target state="translated">Абсолютное значение &lt;code&gt;isize::min_value()&lt;/code&gt; не может быть представлено как &lt;code&gt;isize&lt;/code&gt; , и попытка его вычисления вызовет переполнение. Это означает, что код в режиме отладки вызовет панику в этом случае, а оптимизированный код вернет &lt;code&gt;isize::min_value()&lt;/code&gt; без паники.</target>
        </trans-unit>
        <trans-unit id="409fd764bcabc3595ffe004849ff8f4e30564756" translate="yes" xml:space="preserve">
          <source>The actual desugaring is more complex:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="88133b615f1381b0a02c487a3edbc253bc8ee09f" translate="yes" xml:space="preserve">
          <source>The actual stack size may be greater than this value if the platform specifies a minimal stack size.</source>
          <target state="translated">Реальный размер стека может быть больше этого значения,если платформа задает минимальный размер стека.</target>
        </trans-unit>
        <trans-unit id="e09eb4195a6425d3d0a7b968cb406d8968af9926" translate="yes" xml:space="preserve">
          <source>The addition assignment operator &lt;code&gt;+=&lt;/code&gt;.</source>
          <target state="translated">Оператор присваивания сложения &lt;code&gt;+=&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="097ca9dd7ade97007d85b522a25e6d04cefa5c67" translate="yes" xml:space="preserve">
          <source>The addition operator &lt;code&gt;+&lt;/code&gt;.</source>
          <target state="translated">Оператор сложения &lt;code&gt;+&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="161b60a028315218a44d6ebb4a0a56ea64addb73" translate="yes" xml:space="preserve">
          <source>The address of temporary value was taken.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="67b3b3b11425c46c946b0ed067dfaec63ac739cb" translate="yes" xml:space="preserve">
          <source>The address type can be any implementor of &lt;a href=&quot;trait.tosocketaddrs&quot;&gt;&lt;code&gt;ToSocketAddrs&lt;/code&gt;&lt;/a&gt; trait. See its documentation for concrete examples.</source>
          <target state="translated">Тип адреса может быть любым, реализующим признак &lt;a href=&quot;trait.tosocketaddrs&quot;&gt; &lt;code&gt;ToSocketAddrs&lt;/code&gt; &lt;/a&gt; . См. Его документацию для конкретных примеров.</target>
        </trans-unit>
        <trans-unit id="554a0871d5bd274c4e9a4646e480108243a7e12e" translate="yes" xml:space="preserve">
          <source>The advantage of checking the borrowing rules at runtime instead is that certain memory-safe scenarios are then allowed, whereas they are disallowed by the compile-time checks. Static analysis, like the Rust compiler, is inherently conservative. Some properties of code are impossible to detect by analyzing the code: the most famous example is the Halting Problem, which is beyond the scope of this book but is an interesting topic to research.</source>
          <target state="translated">Преимущество проверки правил заимствования во время выполнения заключается в том,что в этом случае разрешены определенные сценарии с сохранением памяти,в то время как при проверке во время компиляции они запрещаются.Статический анализ,как и компилятор Rust,по своей сути консервативен.Некоторые свойства кода невозможно обнаружить с помощью анализа кода:самым известным примером является Halting Problem,которая выходит за рамки данной книги,но является интересной темой для исследования.</target>
        </trans-unit>
        <trans-unit id="cf97cfec24f32bdc09751ee8bbb19e7117656381" translate="yes" xml:space="preserve">
          <source>The advantage of using trait objects and Rust&amp;rsquo;s type system to write code similar to code using duck typing is that we never have to check whether a value implements a particular method at runtime or worry about getting errors if a value doesn&amp;rsquo;t implement a method but we call it anyway. Rust won&amp;rsquo;t compile our code if the values don&amp;rsquo;t implement the traits that the trait objects need.</source>
          <target state="translated">Преимущество использования типажных объектов и системы типов Rust для написания кода, аналогичного коду, использующего утиную типизацию, заключается в том, что нам никогда не нужно проверять, реализует ли значение определенный метод во время выполнения, или беспокоиться о получении ошибок, если значение не реализует метод, но мы все равно называем это. Rust не будет компилировать наш код, если значения не реализуют черты, которые необходимы объектам черт.</target>
        </trans-unit>
        <trans-unit id="1f36aabbacdf9ecb5c08c91a08fabb8510a201b8" translate="yes" xml:space="preserve">
          <source>The advantages of checking the borrowing rules at compile time are that errors will be caught sooner in the development process, and there is no impact on runtime performance because all the analysis is completed beforehand. For those reasons, checking the borrowing rules at compile time is the best choice in the majority of cases, which is why this is Rust&amp;rsquo;s default.</source>
          <target state="translated">Преимущества проверки правил заимствования во время компиляции заключаются в том, что ошибки будут обнаружены раньше в процессе разработки, и это не повлияет на производительность во время выполнения, поскольку весь анализ завершается заранее. По этим причинам проверка правил заимствования во время компиляции является лучшим выбором в большинстве случаев, поэтому Rust используется по умолчанию.</target>
        </trans-unit>
        <trans-unit id="802cd88adc867c6ed95af7c7632a5b9312da114b" translate="yes" xml:space="preserve">
          <source>The alignment is specified as an integer parameter in the form of &lt;code&gt;#[repr(align(x))]&lt;/code&gt; or &lt;code&gt;#[repr(packed(x))]&lt;/code&gt;. The alignment value must be a power of two from 1 up to 2&lt;sup&gt;29&lt;/sup&gt;. For &lt;code&gt;packed&lt;/code&gt;, if no value is given, as in &lt;code&gt;#[repr(packed)]&lt;/code&gt;, then the value is 1.</source>
          <target state="translated">Выравнивание указывается как целочисленный параметр в форме &lt;code&gt;#[repr(align(x))]&lt;/code&gt; или &lt;code&gt;#[repr(packed(x))]&lt;/code&gt; . Значение выравнивания должно быть степенью двойки от 1 до 2 &lt;sup&gt;29&lt;/sup&gt; . Для &lt;code&gt;packed&lt;/code&gt; , если значение не задано, как в &lt;code&gt;#[repr(packed)]&lt;/code&gt; , тогда значение равно 1.</target>
        </trans-unit>
        <trans-unit id="4210b5f1c3a4d7626a8282b8b0091e3127367f26" translate="yes" xml:space="preserve">
          <source>The alignment may be raised or lowered with the &lt;code&gt;align&lt;/code&gt; and &lt;code&gt;packed&lt;/code&gt; modifiers respectively. They alter the representation specified in the attribute. If no representation is specified, the default one is altered.</source>
          <target state="translated">Выравнивания могут быть повышены или понижены с &lt;code&gt;align&lt;/code&gt; и &lt;code&gt;packed&lt;/code&gt; модификаторами соответственно. Они изменяют представление, указанное в атрибуте. Если представление не указано, изменяется значение по умолчанию.</target>
        </trans-unit>
        <trans-unit id="0bbd4814e74e1731ea096a3e29eb0e49a6112a9b" translate="yes" xml:space="preserve">
          <source>The alignment modifiers</source>
          <target state="translated">Модификаторы выравнивания</target>
        </trans-unit>
        <trans-unit id="9a801ec59d9d78b1342286bf3c47cdf72d8754c9" translate="yes" xml:space="preserve">
          <source>The alignment of a value specifies what addresses values are preferred to start at. Always a power of two. References to a value must be aligned. &lt;a href=&quot;type-layout#size-and-alignment&quot;&gt;More&lt;/a&gt;.</source>
          <target state="translated">Выравнивание значения указывает, с каких адресов предпочтительно начинать значения. Всегда степень двойки. Ссылки на значение должны быть выровнены. &lt;a href=&quot;type-layout#size-and-alignment&quot;&gt;Больше&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="d7d8131883a9466d9495401638572f0f7002cb80" translate="yes" xml:space="preserve">
          <source>The alignment of the struct is the alignment of the most-aligned field in it.</source>
          <target state="translated">Выравнивание структуры-это выравнивание наиболее выровненного в ней поля.</target>
        </trans-unit>
        <trans-unit id="cb2d786ce814f96269971824a7ca8c85b85a4a91" translate="yes" xml:space="preserve">
          <source>The allocated block of memory may or may not be initialized.</source>
          <target state="translated">Выделенный блок памяти может быть инициализирован или не инициализирован.</target>
        </trans-unit>
        <trans-unit id="a853460caf9660ad50bba38269de71834329efaf" translate="yes" xml:space="preserve">
          <source>The allocation error hook is a global resource.</source>
          <target state="translated">Крючок ошибки распределения является глобальным ресурсом.</target>
        </trans-unit>
        <trans-unit id="dd622480c0a0d020ad0c83e155629929c531f8bd" translate="yes" xml:space="preserve">
          <source>The allocation error hook is invoked when an infallible memory allocation fails, before the runtime aborts. The default hook prints a message to standard error, but this behavior can be customized with the &lt;a href=&quot;fn.set_alloc_error_hook&quot;&gt;&lt;code&gt;set_alloc_error_hook&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;fn.take_alloc_error_hook&quot;&gt;&lt;code&gt;take_alloc_error_hook&lt;/code&gt;&lt;/a&gt; functions.</source>
          <target state="translated">Ловушка ошибки распределения вызывается при сбое безошибочного выделения памяти перед прерыванием среды выполнения. Хук по умолчанию выводит сообщение об ошибке, но это поведение можно настроить с помощью &lt;a href=&quot;fn.set_alloc_error_hook&quot;&gt; &lt;code&gt;set_alloc_error_hook&lt;/code&gt; &lt;/a&gt; и &lt;a href=&quot;fn.take_alloc_error_hook&quot;&gt; &lt;code&gt;take_alloc_error_hook&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="460b0be997a504bd93f9a5f2102be17a4fe4f237" translate="yes" xml:space="preserve">
          <source>The alternate flag, &lt;code&gt;#&lt;/code&gt;, adds a &lt;code&gt;0b&lt;/code&gt; in front of the output.</source>
          <target state="translated">Альтернативный флаг &lt;code&gt;#&lt;/code&gt; добавляет &lt;code&gt;0b&lt;/code&gt; перед выводом.</target>
        </trans-unit>
        <trans-unit id="b053ed1e6052a16bbf0f4a89d40e16ee9bf6a88d" translate="yes" xml:space="preserve">
          <source>The alternate flag, &lt;code&gt;#&lt;/code&gt;, adds a &lt;code&gt;0o&lt;/code&gt; in front of the output.</source>
          <target state="translated">Альтернативный флаг &lt;code&gt;#&lt;/code&gt; добавляет &lt;code&gt;0o&lt;/code&gt; перед выводом.</target>
        </trans-unit>
        <trans-unit id="1a67677d2b4895bdc1fb6847161bf39c61cb99f4" translate="yes" xml:space="preserve">
          <source>The alternate flag, &lt;code&gt;#&lt;/code&gt;, adds a &lt;code&gt;0x&lt;/code&gt; in front of the output.</source>
          <target state="translated">Альтернативный флаг &lt;code&gt;#&lt;/code&gt; добавляет &lt;code&gt;0x&lt;/code&gt; перед выводом.</target>
        </trans-unit>
        <trans-unit id="11ba8acfe40883baf3a25418d4023d5eeae6eb43" translate="yes" xml:space="preserve">
          <source>The answer to this problem is the &lt;em&gt;Cargo.lock&lt;/em&gt; file, which was created the first time you ran &lt;code&gt;cargo build&lt;/code&gt; and is now in your &lt;em&gt;guessing_game&lt;/em&gt; directory. When you build a project for the first time, Cargo figures out all the versions of the dependencies that fit the criteria and then writes them to the &lt;em&gt;Cargo.lock&lt;/em&gt; file. When you build your project in the future, Cargo will see that the &lt;em&gt;Cargo.lock&lt;/em&gt; file exists and use the versions specified there rather than doing all the work of figuring out versions again. This lets you have a reproducible build automatically. In other words, your project will remain at &lt;code&gt;0.3.14&lt;/code&gt; until you explicitly upgrade, thanks to the &lt;em&gt;Cargo.lock&lt;/em&gt; file.</source>
          <target state="translated">Ответ на этот вопрос является &lt;em&gt;Cargo.lock&lt;/em&gt; файл, который был создан в первый раз , вы выбежали &lt;code&gt;cargo build&lt;/code&gt; и сейчас в вашем &lt;em&gt;guessing_game&lt;/em&gt; каталоге. Когда вы создаете проект впервые, Cargo определяет все версии зависимостей, которые соответствуют критериям, и затем записывает их в файл &lt;em&gt;Cargo.lock&lt;/em&gt; . Когда вы &lt;em&gt;создадите&lt;/em&gt; свой проект в будущем, Cargo увидит, что файл &lt;em&gt;Cargo.lock&lt;/em&gt; существует, и будет использовать указанные в нем версии, а не выполнять всю работу по определению версий снова. Это позволяет автоматически получать воспроизводимую сборку. Другими словами, ваш проект останется на уровне &lt;code&gt;0.3.14&lt;/code&gt; до тех пор, пока вы явно не обновите его, благодаря &lt;em&gt;Cargo.lock.&lt;/em&gt; файл.</target>
        </trans-unit>
        <trans-unit id="8fb95ccc8cbb2b44a80d4d0a731ecb5bea70e713" translate="yes" xml:space="preserve">
          <source>The answer to this problem is the &lt;em&gt;Cargo.lock&lt;/em&gt; file, which was created the first time you ran &lt;code&gt;cargo build&lt;/code&gt; and is now in your &lt;em&gt;guessing_game&lt;/em&gt; directory. When you build a project for the first time, Cargo figures out all the versions of the dependencies that fit the criteria and then writes them to the &lt;em&gt;Cargo.lock&lt;/em&gt; file. When you build your project in the future, Cargo will see that the &lt;em&gt;Cargo.lock&lt;/em&gt; file exists and use the versions specified there rather than doing all the work of figuring out versions again. This lets you have a reproducible build automatically. In other words, your project will remain at &lt;code&gt;0.5.5&lt;/code&gt; until you explicitly upgrade, thanks to the &lt;em&gt;Cargo.lock&lt;/em&gt; file.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c50839f5b75ebf2449202c65bd78e83e2a04633c" translate="yes" xml:space="preserve">
          <source>The argument order should be changed to match the parameter declaration order, as in the following:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ff3b9111423732cd0796ed3af4340d1aeaddff87" translate="yes" xml:space="preserve">
          <source>The argument to the &lt;code&gt;llvm_asm&lt;/code&gt; macro is not well-formed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0d5e37bb48121061d7a9d1253e50cf299206b8ed" translate="yes" xml:space="preserve">
          <source>The argument, &lt;code&gt;mid&lt;/code&gt;, should be a byte offset from the start of the string. It must also be on the boundary of a UTF-8 code point.</source>
          <target state="translated">Аргумент &lt;code&gt;mid&lt;/code&gt; должен быть байтовым смещением от начала строки. Он также должен находиться на границе кодовой точки UTF-8.</target>
        </trans-unit>
        <trans-unit id="843c167795952476fd4949d773d09e67f37bae5c" translate="yes" xml:space="preserve">
          <source>The arguments will be formatted according to the specified format string into the output stream provided.</source>
          <target state="translated">Аргументы будут отформатированы в соответствии с заданной строкой форматирования в предоставляемом выходном потоке.</target>
        </trans-unit>
        <trans-unit id="47d8ae2e6d2ad4b4b9256e9f4136431f5f0ee17f" translate="yes" xml:space="preserve">
          <source>The array index expression can be implemented for types other than arrays and slices by implementing the &lt;a href=&quot;../../std/ops/trait.index&quot;&gt;Index&lt;/a&gt; and &lt;a href=&quot;../../std/ops/trait.indexmut&quot;&gt;IndexMut&lt;/a&gt; traits.</source>
          <target state="translated">Выражение индекса массива может быть реализовано для типов, отличных от массивов и срезов, путем реализации признаков &lt;a href=&quot;../../std/ops/trait.index&quot;&gt;Index&lt;/a&gt; и &lt;a href=&quot;../../std/ops/trait.indexmut&quot;&gt;IndexMut&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="43b42b264d53f00eb4d50d966bdebfe503d9e502" translate="yes" xml:space="preserve">
          <source>The array named &lt;code&gt;a&lt;/code&gt; will contain &lt;code&gt;5&lt;/code&gt; elements that will all be set to the value &lt;code&gt;3&lt;/code&gt; initially. This is the same as writing &lt;code&gt;let a = [3, 3, 3, 3, 3];&lt;/code&gt; but in a more concise way.</source>
          <target state="translated">Массив с именем &lt;code&gt;a&lt;/code&gt; будет содержать &lt;code&gt;5&lt;/code&gt; элементов, для которых изначально будет установлено значение &lt;code&gt;3&lt;/code&gt; . Это то же самое, что писать &lt;code&gt;let a = [3, 3, 3, 3, 3];&lt;/code&gt; но более кратко.</target>
        </trans-unit>
        <trans-unit id="bda6f38466d2f9f90243514e2e1d1d622e872f82" translate="yes" xml:space="preserve">
          <source>The associated error which can be returned from parsing.</source>
          <target state="translated">Связанная с этим ошибка,которая может быть возвращена при разборе.</target>
        </trans-unit>
        <trans-unit id="264397f1a1d81bc0bfb862d1058ae5d080545332" translate="yes" xml:space="preserve">
          <source>The associated type used was not defined in the trait.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="95b071fe52a22a379b9072dba9b8116f1e91d5e0" translate="yes" xml:space="preserve">
          <source>The assumed lifetime of references held by a &lt;a href=&quot;types/trait-object&quot;&gt;trait object&lt;/a&gt; is called its &lt;em&gt;default object lifetime bound&lt;/em&gt;. These were defined in &lt;a href=&quot;https://github.com/rust-lang/rfcs/blob/master/text/0599-default-object-bound.md&quot;&gt;RFC 599&lt;/a&gt; and amended in &lt;a href=&quot;https://github.com/rust-lang/rfcs/blob/master/text/1156-adjust-default-object-bounds.md&quot;&gt;RFC 1156&lt;/a&gt;.</source>
          <target state="translated">Предполагаемое время жизни ссылок, содержащихся в &lt;a href=&quot;types/trait-object&quot;&gt;объекте-признаке,&lt;/a&gt; называется &lt;em&gt;пределом времени существования объекта по умолчанию&lt;/em&gt; . Они были определены в &lt;a href=&quot;https://github.com/rust-lang/rfcs/blob/master/text/0599-default-object-bound.md&quot;&gt;RFC 599&lt;/a&gt; и изменены в &lt;a href=&quot;https://github.com/rust-lang/rfcs/blob/master/text/1156-adjust-default-object-bounds.md&quot;&gt;RFC 1156&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="4a633a670846190d4e317682018f539e771650d4" translate="yes" xml:space="preserve">
          <source>The atomic intrinsics provide common atomic operations on machine words, with multiple possible memory orderings. They obey the same semantics as C++11. See the LLVM documentation on [&lt;a href=&quot;http://llvm.org/docs/Atomics.html&quot;&gt;atomics&lt;/a&gt;].</source>
          <target state="translated">Атомарные встроенные функции обеспечивают общие атомарные операции над машинными словами с несколькими возможными порядками памяти. Они подчиняются той же семантике, что и C ++ 11. См. Документацию LLVM на [ &lt;a href=&quot;http://llvm.org/docs/Atomics.html&quot;&gt;атомикс&lt;/a&gt; ].</target>
        </trans-unit>
        <trans-unit id="4eacfc8c255cb1ef132a6a65b58c2019ebea9baf" translate="yes" xml:space="preserve">
          <source>The atomic types in this module may not be available on all platforms. The atomic types here are all widely available, however, and can generally be relied upon existing. Some notable exceptions are:</source>
          <target state="translated">Атомные типы в этом модуле могут быть доступны не на всех платформах.Тем не менее,все типы атомов здесь широко доступны,и в целом на них можно положиться.Существуют некоторые примечательные исключения:</target>
        </trans-unit>
        <trans-unit id="71cc0f45759d249e1ba21744ede7b9ef7445260e" translate="yes" xml:space="preserve">
          <source>The attribute consists of a path to the attribute, followed by an optional delimited token tree whose interpretation is defined by the attribute. Attributes other than macro attributes also allow the input to be an equals sign (&lt;code&gt;=&lt;/code&gt;) followed by a literal expression. See the &lt;a href=&quot;#meta-item-attribute-syntax&quot;&gt;meta item syntax&lt;/a&gt; below for more details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c5f89ad9ce66636388cf7509f930392e52eeb867" translate="yes" xml:space="preserve">
          <source>The attribute consists of a path to the attribute, followed by an optional delimited token tree whose interpretation is defined by the attribute. Attributes other than macro attributes also allow the input to be an equals sign (&lt;code&gt;=&lt;/code&gt;) followed by a literal expression. See the &lt;a href=&quot;attributes#meta-item-attribute-syntax&quot;&gt;meta item syntax&lt;/a&gt; below for more details.</source>
          <target state="translated">Атрибут состоит из пути к атрибуту, за которым следует необязательное дерево токенов с разделителями, интерпретация которого определяется атрибутом. Атрибуты, отличные от атрибутов макроса, также позволяют вводить знак равенства ( &lt;code&gt;=&lt;/code&gt; ), за которым следует буквальное выражение. Подробнее см. &lt;a href=&quot;attributes#meta-item-attribute-syntax&quot;&gt;Синтаксис мета-элемента&lt;/a&gt; ниже.</target>
        </trans-unit>
        <trans-unit id="b79be106b3314bbccaaacf6171952db704c5419b" translate="yes" xml:space="preserve">
          <source>The attribute is used on a &lt;code&gt;static&lt;/code&gt; item whose type implements the &lt;a href=&quot;https://doc.rust-lang.org/core/alloc/trait.GlobalAlloc.html&quot;&gt;&lt;code&gt;GlobalAlloc&lt;/code&gt;&lt;/a&gt; trait. This type can be provided by an external library:</source>
          <target state="translated">Атрибут используется в &lt;code&gt;static&lt;/code&gt; элементе, тип которого реализует &lt;a href=&quot;https://doc.rust-lang.org/core/alloc/trait.GlobalAlloc.html&quot;&gt; &lt;code&gt;GlobalAlloc&lt;/code&gt; &lt;/a&gt; . Этот тип может быть предоставлен внешней библиотекой:</target>
        </trans-unit>
        <trans-unit id="638938ad1b96ca367b1ad29ad316e67748e69b45" translate="yes" xml:space="preserve">
          <source>The attribute is used on a &lt;code&gt;static&lt;/code&gt; item whose type implements the &lt;a href=&quot;trait.globalalloc&quot;&gt;&lt;code&gt;GlobalAlloc&lt;/code&gt;&lt;/a&gt; trait. This type can be provided by an external library:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="07001b94d9ec08710a57474a9ab6a5a7c57ed031" translate="yes" xml:space="preserve">
          <source>The attributes that have meaning on a block expression are &lt;a href=&quot;../conditional-compilation&quot;&gt;&lt;code&gt;cfg&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../attributes/diagnostics#lint-check-attributes&quot;&gt;the lint check attributes&lt;/a&gt;.</source>
          <target state="translated">Атрибуты, которые имеют значение в выражении блока, - это &lt;a href=&quot;../conditional-compilation&quot;&gt; &lt;code&gt;cfg&lt;/code&gt; &lt;/a&gt; и &lt;a href=&quot;../attributes/diagnostics#lint-check-attributes&quot;&gt;атрибуты lint check&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="db84623389bc5fe968094b478ac6446a9f7cd32b" translate="yes" xml:space="preserve">
          <source>The attributes that have meaning on a function are &lt;a href=&quot;../conditional-compilation&quot;&gt;&lt;code&gt;cfg&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../attributes/diagnostics#the-deprecated-attribute&quot;&gt;&lt;code&gt;deprecated&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://doc.rust-lang.org/rustdoc/the-doc-attribute.html&quot;&gt;&lt;code&gt;doc&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../abi#the-export_name-attribute&quot;&gt;&lt;code&gt;export_name&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../abi#the-link_section-attribute&quot;&gt;&lt;code&gt;link_section&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../abi#the-no_mangle-attribute&quot;&gt;&lt;code&gt;no_mangle&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../attributes/diagnostics#lint-check-attributes&quot;&gt;the lint check attributes&lt;/a&gt;, &lt;a href=&quot;../attributes/diagnostics#the-must_use-attribute&quot;&gt;&lt;code&gt;must_use&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../procedural-macros&quot;&gt;the procedural macro attributes&lt;/a&gt;, &lt;a href=&quot;../attributes/testing&quot;&gt;the testing attributes&lt;/a&gt;, and &lt;a href=&quot;../attributes/codegen#optimization-hints&quot;&gt;the optimization hint attributes&lt;/a&gt;. Functions also accept attributes macros.</source>
          <target state="translated">Атрибуты , которые имеют смысл на функции являются &lt;a href=&quot;../conditional-compilation&quot;&gt; &lt;code&gt;cfg&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;../attributes/diagnostics#the-deprecated-attribute&quot;&gt; &lt;code&gt;deprecated&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;https://doc.rust-lang.org/rustdoc/the-doc-attribute.html&quot;&gt; &lt;code&gt;doc&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;../abi#the-export_name-attribute&quot;&gt; &lt;code&gt;export_name&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;../abi#the-link_section-attribute&quot;&gt; &lt;code&gt;link_section&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;../abi#the-no_mangle-attribute&quot;&gt; &lt;code&gt;no_mangle&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;../attributes/diagnostics#lint-check-attributes&quot;&gt;проверочные ворса атрибутов&lt;/a&gt; , &lt;a href=&quot;../attributes/diagnostics#the-must_use-attribute&quot;&gt; &lt;code&gt;must_use&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;../procedural-macros&quot;&gt;процедурные макро атрибутов&lt;/a&gt; , &lt;a href=&quot;../attributes/testing&quot;&gt;атрибуты тестирования&lt;/a&gt; , а также &lt;a href=&quot;../attributes/codegen#optimization-hints&quot;&gt;атрибуты оптимизации подсказки&lt;/a&gt; . Функции также принимают макросы атрибутов.</target>
        </trans-unit>
        <trans-unit id="622c3bad6ebce7dda9ab10b347056427bd42a746" translate="yes" xml:space="preserve">
          <source>The attributes that have meaning on a function are &lt;a href=&quot;../conditional-compilation#the-cfg-attribute&quot;&gt;&lt;code&gt;cfg&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../conditional-compilation#the-cfg_attr-attribute&quot;&gt;&lt;code&gt;cfg_attr&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../attributes/diagnostics#the-deprecated-attribute&quot;&gt;&lt;code&gt;deprecated&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://doc.rust-lang.org/rustdoc/the-doc-attribute.html&quot;&gt;&lt;code&gt;doc&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../abi#the-export_name-attribute&quot;&gt;&lt;code&gt;export_name&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../abi#the-link_section-attribute&quot;&gt;&lt;code&gt;link_section&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../abi#the-no_mangle-attribute&quot;&gt;&lt;code&gt;no_mangle&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../attributes/diagnostics#lint-check-attributes&quot;&gt;the lint check attributes&lt;/a&gt;, &lt;a href=&quot;../attributes/diagnostics#the-must_use-attribute&quot;&gt;&lt;code&gt;must_use&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../procedural-macros&quot;&gt;the procedural macro attributes&lt;/a&gt;, &lt;a href=&quot;../attributes/testing&quot;&gt;the testing attributes&lt;/a&gt;, and &lt;a href=&quot;../attributes/codegen#optimization-hints&quot;&gt;the optimization hint attributes&lt;/a&gt;. Functions also accept attributes macros.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a9286c2061446f78d1eb0dacb8ad2bed2198b3a3" translate="yes" xml:space="preserve">
          <source>The author of the code in Listing 14-4, which uses the &lt;code&gt;art&lt;/code&gt; crate, had to figure out that &lt;code&gt;PrimaryColor&lt;/code&gt; is in the &lt;code&gt;kinds&lt;/code&gt; module and &lt;code&gt;mix&lt;/code&gt; is in the &lt;code&gt;utils&lt;/code&gt; module. The module structure of the &lt;code&gt;art&lt;/code&gt; crate is more relevant to developers working on the &lt;code&gt;art&lt;/code&gt; crate than to developers using the &lt;code&gt;art&lt;/code&gt; crate. The internal structure that organizes parts of the crate into the &lt;code&gt;kinds&lt;/code&gt; module and the &lt;code&gt;utils&lt;/code&gt; module doesn&amp;rsquo;t contain any useful information for someone trying to understand how to use the &lt;code&gt;art&lt;/code&gt; crate. Instead, the &lt;code&gt;art&lt;/code&gt; crate&amp;rsquo;s module structure causes confusion because developers have to figure out where to look, and the structure is inconvenient because developers must specify the module names in the &lt;code&gt;use&lt;/code&gt; statements.</source>
          <target state="translated">Автор кода в листинге 14-4, который использует &lt;code&gt;art&lt;/code&gt; клеть, должен был выяснить , что &lt;code&gt;PrimaryColor&lt;/code&gt; находится в &lt;code&gt;kinds&lt;/code&gt; модуля и &lt;code&gt;mix&lt;/code&gt; находится в &lt;code&gt;utils&lt;/code&gt; модуле. Модульная структура &lt;code&gt;art&lt;/code&gt; ящика более актуальна для разработчиков, работающих над &lt;code&gt;art&lt;/code&gt; ящиком, чем для разработчиков, использующих &lt;code&gt;art&lt;/code&gt; ящик. Внутренняя структура, которая объединяет части ящика в модуль &lt;code&gt;kinds&lt;/code&gt; модуль &lt;code&gt;utils&lt;/code&gt; , не содержит никакой полезной информации для тех, кто пытается понять, как использовать ящик с &lt;code&gt;art&lt;/code&gt; . Вместо этого &lt;code&gt;art&lt;/code&gt; Структура модуля crate вызывает путаницу, потому что разработчики должны выяснить, где искать, а структура неудобна, потому что разработчики должны указывать имена модулей в операторах &lt;code&gt;use&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d8ebf8e3de6c2376fc1a32c2614c0e8023f7f60e" translate="yes" xml:space="preserve">
          <source>The author of this code probably wants &lt;code&gt;collect()&lt;/code&gt; to return a &lt;code&gt;Result&amp;lt;Vec&amp;lt;bool&amp;gt;, ()&amp;gt;&lt;/code&gt;, but the compiler can't be sure that there isn't another type &lt;code&gt;T&lt;/code&gt; implementing both &lt;code&gt;Try&lt;/code&gt; and &lt;code&gt;FromIterator&amp;lt;Result&amp;lt;bool, ()&amp;gt;&amp;gt;&lt;/code&gt; in scope such that &lt;code&gt;T::Ok == Vec&amp;lt;bool&amp;gt;&lt;/code&gt;. Hence, this code is ambiguous and an error is returned.</source>
          <target state="translated">Автор этого кода, вероятно, хочет, чтобы &lt;code&gt;collect()&lt;/code&gt; возвращал &lt;code&gt;Result&amp;lt;Vec&amp;lt;bool&amp;gt;, ()&amp;gt;&lt;/code&gt; , но компилятор не может быть уверен, что нет другого типа &lt;code&gt;T&lt;/code&gt; , реализующего как &lt;code&gt;Try&lt;/code&gt; ,так и &lt;code&gt;FromIterator&amp;lt;Result&amp;lt;bool, ()&amp;gt;&amp;gt;&lt;/code&gt; в такой области, что &lt;code&gt;T::Ok == Vec&amp;lt;bool&amp;gt;&lt;/code&gt; . Следовательно, этот код неоднозначен и возвращается ошибка.</target>
        </trans-unit>
        <trans-unit id="938569367b830c27a570a475e7cb23644f96b802" translate="yes" xml:space="preserve">
          <source>The author of this code probably wants &lt;code&gt;into()&lt;/code&gt; to return a &lt;code&gt;u64&lt;/code&gt;, but the compiler can't be sure that there isn't another type &lt;code&gt;T&lt;/code&gt; where both &lt;code&gt;u32: Into&amp;lt;T&amp;gt;&lt;/code&gt; and &lt;code&gt;u64: Add&amp;lt;T&amp;gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="946c3c8468dffe1ee08b57091aa458b31b356f72" translate="yes" xml:space="preserve">
          <source>The automatically generated &quot;drop glue&quot; which recursively calls the destructors of the all fields of this value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="442e142fa9a496c6c2ff3a02ee78aa50e228d6e4" translate="yes" xml:space="preserve">
          <source>The bad state is not something that&amp;rsquo;s &lt;em&gt;expected&lt;/em&gt; to happen occasionally.</source>
          <target state="translated">Плохое состояние - это не то, &lt;em&gt;что&lt;/em&gt; случается время от времени.</target>
        </trans-unit>
        <trans-unit id="1030d03bed1910f08091eb456180338b656dc0aa" translate="yes" xml:space="preserve">
          <source>The base of a &lt;a href=&quot;expressions/struct-expr#functional-update-syntax&quot;&gt;functional update&lt;/a&gt; struct expression.</source>
          <target state="translated">Основа &lt;a href=&quot;expressions/struct-expr#functional-update-syntax&quot;&gt;функционального&lt;/a&gt; выражения структуры обновления .</target>
        </trans-unit>
        <trans-unit id="1da424ed8fd790e722f71cc50f820022f89f696b" translate="yes" xml:space="preserve">
          <source>The behavior of the returned &lt;code&gt;Waker&lt;/code&gt; is undefined if the contract defined in &lt;a href=&quot;struct.rawwaker&quot;&gt;&lt;code&gt;RawWaker&lt;/code&gt;&lt;/a&gt;'s and &lt;a href=&quot;struct.rawwakervtable&quot;&gt;&lt;code&gt;RawWakerVTable&lt;/code&gt;&lt;/a&gt;'s documentation is not upheld. Therefore this method is unsafe.</source>
          <target state="translated">Поведение возвращенного &lt;code&gt;Waker&lt;/code&gt; не определено, если контракт, определенный в документации &lt;a href=&quot;struct.rawwaker&quot;&gt; &lt;code&gt;RawWaker&lt;/code&gt; &lt;/a&gt; и &lt;a href=&quot;struct.rawwakervtable&quot;&gt; &lt;code&gt;RawWakerVTable&lt;/code&gt; ,&lt;/a&gt; не поддерживается. Поэтому этот метод небезопасен.</target>
        </trans-unit>
        <trans-unit id="c7f5bfcda53c0f0ccac4fbf04091f03de55bc719" translate="yes" xml:space="preserve">
          <source>The behavior of this method must be independent of the state of the &lt;code&gt;Read&lt;/code&gt;er - the method only takes &lt;code&gt;&amp;amp;self&lt;/code&gt; so that it can be used through trait objects.</source>
          <target state="translated">Поведение этого метода не должно зависеть от состояния объекта &lt;code&gt;Read&lt;/code&gt; - метод принимает только &lt;code&gt;&amp;amp;self&lt;/code&gt; чтобы его можно было использовать через объекты-типажи.</target>
        </trans-unit>
        <trans-unit id="92a385c5078364ae9300fa907e25a19462c00810" translate="yes" xml:space="preserve">
          <source>The benefit of having this restriction is that Rust can prevent data races at compile time. A &lt;em&gt;data race&lt;/em&gt; is similar to a race condition and happens when these three behaviors occur:</source>
          <target state="translated">Преимущество этого ограничения заключается в том, что Rust может предотвратить скачки данных во время компиляции. &lt;em&gt;Гонки данных&lt;/em&gt; похожа на состояние гонки и происходит , когда эти три модели поведения:</target>
        </trans-unit>
        <trans-unit id="94345eda8bccf9faca124acc23e9dfc7f68245ec" translate="yes" xml:space="preserve">
          <source>The bits that define the access mode are masked out with &lt;code&gt;O_ACCMODE&lt;/code&gt;, to ensure they do not interfere with the access mode set by Rusts options.</source>
          <target state="translated">Биты, определяющие режим доступа, маскируются с помощью &lt;code&gt;O_ACCMODE&lt;/code&gt; , чтобы гарантировать, что они не мешают режиму доступа, установленному параметрами Rusts.</target>
        </trans-unit>
        <trans-unit id="eaa8e0a3053148a58d441c5d948ef0afd09016e9" translate="yes" xml:space="preserve">
          <source>The bitwise AND assignment operator &lt;code&gt;&amp;amp;=&lt;/code&gt;.</source>
          <target state="translated">Оператор побитового присваивания AND &lt;code&gt;&amp;amp;=&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1dd8ef8a8d73fdf98095248d6c0b2047cb203cf0" translate="yes" xml:space="preserve">
          <source>The bitwise AND operator &lt;code&gt;&amp;amp;&lt;/code&gt;.</source>
          <target state="translated">Поразрядный оператор И &lt;code&gt;&amp;amp;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2bfdab4f43dd337afc8fc0552897bf0d88f4fb0e" translate="yes" xml:space="preserve">
          <source>The bitwise OR assignment operator &lt;code&gt;|=&lt;/code&gt;.</source>
          <target state="translated">Оператор присваивания поразрядное ИЛИ &lt;code&gt;|=&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a78ed80e19856e33ead5257328ef19e1b110eb08" translate="yes" xml:space="preserve">
          <source>The bitwise OR operator &lt;code&gt;|&lt;/code&gt;.</source>
          <target state="translated">Побитовый оператор ИЛИ &lt;code&gt;|&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="eafeed4a6ad02f43abd1d07f62b4dea554b3a79c" translate="yes" xml:space="preserve">
          <source>The bitwise XOR assignment operator &lt;code&gt;^=&lt;/code&gt;.</source>
          <target state="translated">Оператор присваивания побитового XOR &lt;code&gt;^=&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e805a1bbc089611af418b7bd9e638939dac553c5" translate="yes" xml:space="preserve">
          <source>The bitwise XOR operator &lt;code&gt;^&lt;/code&gt;.</source>
          <target state="translated">Побитовый оператор XOR &lt;code&gt;^&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c9231fb12ba981aafd28f24ac7946a833b22a70e" translate="yes" xml:space="preserve">
          <source>The block must be allocated with the same alignment as &lt;a href=&quot;struct.layout#method.align&quot;&gt;&lt;code&gt;layout.align()&lt;/code&gt;&lt;/a&gt;, and</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="423b8775203e06b0ca354c4f4e97825a7d00a713" translate="yes" xml:space="preserve">
          <source>The block of a function is conceptually wrapped in a block that binds the argument patterns and then &lt;code&gt;return&lt;/code&gt;s the value of the function's block. This means that the tail expression of the block, if evaluated, ends up being returned to the caller. As usual, an explicit return expression within the body of the function will short-cut that implicit return, if reached.</source>
          <target state="translated">Блок функции концептуально заключен в блок, который связывает шаблоны аргументов и затем &lt;code&gt;return&lt;/code&gt; значение блока функции. Это означает, что заключительное выражение блока, если оно оценено, в конечном итоге возвращается вызывающей стороне. Как обычно, явное возвращаемое выражение в теле функции сокращает этот неявный возврат, если оно достигается.</target>
        </trans-unit>
        <trans-unit id="761ca0a326eb25085e5f1ebfbcef3b94f323b7c7" translate="yes" xml:space="preserve">
          <source>The block's size must fall in the range &lt;code&gt;[use_min, use_max]&lt;/code&gt;, where:</source>
          <target state="translated">Размер блока должен находиться в диапазоне &lt;code&gt;[use_min, use_max]&lt;/code&gt; , где:</target>
        </trans-unit>
        <trans-unit id="0d55dd5d42feb75840d81a2ee396cf125ff6a36f" translate="yes" xml:space="preserve">
          <source>The block's starting address must be aligned to &lt;code&gt;layout.align()&lt;/code&gt;.</source>
          <target state="translated">Начальный адрес блока должен быть выровнен с &lt;code&gt;layout.align()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6fb5efe10f486c51a18bce4f54350dd31c9d18ad" translate="yes" xml:space="preserve">
          <source>The bodies of the &lt;code&gt;if let&lt;/code&gt; and the &lt;code&gt;unwrap_or_else&lt;/code&gt; functions are the same in both cases: we print the error and exit.</source>
          <target state="translated">Тела функций &lt;code&gt;if let&lt;/code&gt; и &lt;code&gt;unwrap_or_else&lt;/code&gt; в обоих случаях одинаковы: мы печатаем ошибку и выходим.</target>
        </trans-unit>
        <trans-unit id="a084bd821dcd5af3bead7d20966da99b85c8d3d6" translate="yes" xml:space="preserve">
          <source>The body of a &lt;a href=&quot;expressions/if-expr#if-expressions&quot;&gt;&lt;code&gt;if&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;expressions/loop-expr#predicate-loops&quot;&gt;&lt;code&gt;while&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;expressions/loop-expr#infinite-loops&quot;&gt;&lt;code&gt;loop&lt;/code&gt;&lt;/a&gt; expression.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8d22837f9a0a24391528e1a0b3b2365c1d2579bc" translate="yes" xml:space="preserve">
          <source>The body of the function starts by calling the &lt;code&gt;File::open&lt;/code&gt; function. Then we handle the &lt;code&gt;Result&lt;/code&gt; value returned with a &lt;code&gt;match&lt;/code&gt; similar to the &lt;code&gt;match&lt;/code&gt; in Listing 9-4, only instead of calling &lt;code&gt;panic!&lt;/code&gt; in the &lt;code&gt;Err&lt;/code&gt; case, we return early from this function and pass the error value from &lt;code&gt;File::open&lt;/code&gt; back to the calling code as this function&amp;rsquo;s error value. If &lt;code&gt;File::open&lt;/code&gt; succeeds, we store the file handle in the variable &lt;code&gt;f&lt;/code&gt; and continue.</source>
          <target state="translated">Тело функции начинается с вызова функции &lt;code&gt;File::open&lt;/code&gt; . Затем мы обрабатываем возвращаемое значение &lt;code&gt;Result&lt;/code&gt; с &lt;code&gt;match&lt;/code&gt; аналогичным &lt;code&gt;match&lt;/code&gt; в листинге 9-4, только вместо вызова &lt;code&gt;panic!&lt;/code&gt; в случае &lt;code&gt;Err&lt;/code&gt; мы возвращаемся из этой функции раньше и передаем значение ошибки из &lt;code&gt;File::open&lt;/code&gt; обратно в вызывающий код в качестве значения ошибки этой функции. Если &lt;code&gt;File::open&lt;/code&gt; завершается успешно, мы сохраняем дескриптор файла в переменной &lt;code&gt;f&lt;/code&gt; и продолжаем.</target>
        </trans-unit>
        <trans-unit id="9ba4d0e4523a23a56b57272682f48b03a790c657" translate="yes" xml:space="preserve">
          <source>The body of the method would use &lt;code&gt;self&lt;/code&gt; to get the value that we called the method on. In this example, we&amp;rsquo;ve created a variable &lt;code&gt;m&lt;/code&gt; that has the value &lt;code&gt;Message::Write(String::from(&quot;hello&quot;))&lt;/code&gt;, and that is what &lt;code&gt;self&lt;/code&gt; will be in the body of the &lt;code&gt;call&lt;/code&gt; method when &lt;code&gt;m.call()&lt;/code&gt; runs.</source>
          <target state="translated">Тело метода будет использовать &lt;code&gt;self&lt;/code&gt; для получения значения, для которого мы вызвали метод. В этом примере мы создали переменную &lt;code&gt;m&lt;/code&gt; , которая имеет значение &lt;code&gt;Message::Write(String::from(&quot;hello&quot;))&lt;/code&gt; , и это то, чем &lt;code&gt;self&lt;/code&gt; будет в теле метода &lt;code&gt;call&lt;/code&gt; , когда &lt;code&gt;m.call()&lt;/code&gt; работает.</target>
        </trans-unit>
        <trans-unit id="9c00fd6128e2bdd1cc90bd415df84de85499f4fb" translate="yes" xml:space="preserve">
          <source>The book &lt;em&gt;Design Patterns: Elements of Reusable Object-Oriented Software&lt;/em&gt; by Erich Gamma, Richard Helm, Ralph Johnson, and John Vlissides (Addison-Wesley Professional, 1994) colloquially referred to as &lt;em&gt;The Gang of Four&lt;/em&gt; book, is a catalog of object-oriented design patterns. It defines OOP this way:</source>
          <target state="translated">Книга Эриха Гаммы, Ричарда Хелма, Ральфа Джонсона и Джона Влиссидеса &lt;em&gt;&quot;Шаблоны проектирования: элементы объектно-ориентированного программного обеспечения многократного использования&quot;&lt;/em&gt; (Addison-Wesley Professional, 1994), в просторечии именуемая книгой &quot; &lt;em&gt;Банда четырех&quot;&lt;/em&gt; , представляет собой каталог объектно-ориентированных программ. шаблоны проектирования. Он определяет ООП следующим образом:</target>
        </trans-unit>
        <trans-unit id="0ab81c05a8d6cbaec3e9dfb9c8caa2a16dab19bf" translate="yes" xml:space="preserve">
          <source>The boolean type.</source>
          <target state="translated">Булевого типа.</target>
        </trans-unit>
        <trans-unit id="06283747a377154700dbba912c9e77d60011a87e" translate="yes" xml:space="preserve">
          <source>The borrow lasts until the returned &lt;code&gt;Ref&lt;/code&gt; exits scope. Multiple immutable borrows can be taken out at the same time.</source>
          <target state="translated">Заимствование длится до тех пор, пока возвращенный &lt;code&gt;Ref&lt;/code&gt; не покинет область действия. Одновременно можно получить несколько неизменных займов.</target>
        </trans-unit>
        <trans-unit id="45376451530857b96a10ec4a5e20bb51cfc0ed12" translate="yes" xml:space="preserve">
          <source>The borrow lasts until the returned &lt;code&gt;RefMut&lt;/code&gt; or all &lt;code&gt;RefMut&lt;/code&gt;s derived from it exit scope. The value cannot be borrowed while this borrow is active.</source>
          <target state="translated">&lt;code&gt;RefMut&lt;/code&gt; длится до тех пор, пока возвращенный RefMut или все производные &lt;code&gt;RefMut&lt;/code&gt; не выйдут из области видимости. Стоимость не может быть заимствована, пока этот заем активен.</target>
        </trans-unit>
        <trans-unit id="f968733bf846dacfb002493e18e27a27864a5d95" translate="yes" xml:space="preserve">
          <source>The buffer is written out before returning the writer.</source>
          <target state="translated">Буфер переписывается перед возвращением записывающего устройства.</target>
        </trans-unit>
        <trans-unit id="8d2f5c9c4df44bd26200b02c526dd9675a0b62ea" translate="yes" xml:space="preserve">
          <source>The buffer specified was 0 bytes in length.</source>
          <target state="translated">Указанный буфер имел длину 0 байт.</target>
        </trans-unit>
        <trans-unit id="aac2e47b3535d051db39f7a14fa1dba18fc6a121" translate="yes" xml:space="preserve">
          <source>The built-in &lt;code&gt;cfg&lt;/code&gt; macro takes in a single configuration predicate and evaluates to the &lt;code&gt;true&lt;/code&gt; literal when the predicate is true and the &lt;code&gt;false&lt;/code&gt; literal when it is false.</source>
          <target state="translated">Встроенный макрос &lt;code&gt;cfg&lt;/code&gt; принимает один предикат конфигурации и вычисляет &lt;code&gt;true&lt;/code&gt; литерал, когда предикат истинен, и &lt;code&gt;false&lt;/code&gt; литерал, когда он ложен.</target>
        </trans-unit>
        <trans-unit id="87ae881f172e3eab463a1dba119d942ed8deaed7" translate="yes" xml:space="preserve">
          <source>The built-in attributes that have meaning on a function are &lt;a href=&quot;../conditional-compilation&quot;&gt;&lt;code&gt;cfg&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../attributes/diagnostics#the-deprecated-attribute&quot;&gt;&lt;code&gt;deprecated&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://doc.rust-lang.org/rustdoc/the-doc-attribute.html&quot;&gt;&lt;code&gt;doc&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../attributes/diagnostics#lint-check-attributes&quot;&gt;the lint check attributes&lt;/a&gt;, &lt;code&gt;path&lt;/code&gt;, and &lt;code&gt;no_implicit_prelude&lt;/code&gt;. Modules also accept macro attributes.</source>
          <target state="translated">Встроенные атрибуты, которые имеют значение для функции: &lt;a href=&quot;../conditional-compilation&quot;&gt; &lt;code&gt;cfg&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;../attributes/diagnostics#the-deprecated-attribute&quot;&gt; &lt;code&gt;deprecated&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;https://doc.rust-lang.org/rustdoc/the-doc-attribute.html&quot;&gt; &lt;code&gt;doc&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;../attributes/diagnostics#lint-check-attributes&quot;&gt;атрибуты lint check&lt;/a&gt; , &lt;code&gt;path&lt;/code&gt; и &lt;code&gt;no_implicit_prelude&lt;/code&gt; . Модули также принимают атрибуты макросов.</target>
        </trans-unit>
        <trans-unit id="0658caeac4e6cc6250807a10a1d1127da8f7b8cb" translate="yes" xml:space="preserve">
          <source>The built-in attributes that have meaning on a module are &lt;a href=&quot;../conditional-compilation&quot;&gt;&lt;code&gt;cfg&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../attributes/diagnostics#the-deprecated-attribute&quot;&gt;&lt;code&gt;deprecated&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://doc.rust-lang.org/rustdoc/the-doc-attribute.html&quot;&gt;&lt;code&gt;doc&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../attributes/diagnostics#lint-check-attributes&quot;&gt;the lint check attributes&lt;/a&gt;, &lt;code&gt;path&lt;/code&gt;, and &lt;code&gt;no_implicit_prelude&lt;/code&gt;. Modules also accept macro attributes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7917b1e20d5567c345241cec71cc654edebdd434" translate="yes" xml:space="preserve">
          <source>The built-in function traits are generic over a tuple of the function arguments. If one uses angle-bracket notation (&lt;code&gt;Fn&amp;lt;(T,), Output=U&amp;gt;&lt;/code&gt;) instead of parentheses (&lt;code&gt;Fn(T) -&amp;gt; U&lt;/code&gt;) to denote the function trait, the type parameter should be a tuple. Otherwise function call notation cannot be used and the trait will not be implemented by closures.</source>
          <target state="translated">Встроенные характеристики функции являются общими для кортежа аргументов функции. Если для обозначения признака функции используется угловая скобка ( &lt;code&gt;Fn&amp;lt;(T,), Output=U&amp;gt;&lt;/code&gt; ) вместо скобок ( &lt;code&gt;Fn(T) -&amp;gt; U&lt;/code&gt; ), параметр типа должен быть кортежем. В противном случае нельзя использовать нотацию вызова функции, и признак не будет реализован посредством замыканий.</target>
        </trans-unit>
        <trans-unit id="a9e1ef14ad9c5016cccb06e0dae0b41ca0441837" translate="yes" xml:space="preserve">
          <source>The c-main function only supports to return integers as return type. So, every type implementing the &lt;code&gt;Termination&lt;/code&gt; trait has to be converted to an integer.</source>
          <target state="translated">Функция c-main поддерживает только возвращение целых чисел в качестве возвращаемого типа. Таким образом, каждый тип, реализующий признак &lt;code&gt;Termination&lt;/code&gt; должен быть преобразован в целое число.</target>
        </trans-unit>
        <trans-unit id="98a1e057ef0866ad400391fbf23a2daa11b28012" translate="yes" xml:space="preserve">
          <source>The call to &lt;code&gt;lock&lt;/code&gt; would fail if another thread holding the lock panicked. In that case, no one would ever be able to get the lock, so we&amp;rsquo;ve chosen to &lt;code&gt;unwrap&lt;/code&gt; and have this thread panic if we&amp;rsquo;re in that situation.</source>
          <target state="translated">Вызов &lt;code&gt;lock&lt;/code&gt; завершится ошибкой, если другой поток, удерживающий блокировку, запаникует. В этом случае никто никогда не сможет получить блокировку, поэтому мы решили &lt;code&gt;unwrap&lt;/code&gt; и вызвать панику этого потока, если мы в такой ситуации.</target>
        </trans-unit>
        <trans-unit id="a399c55a0729e88865a33bb045bf002d26006429" translate="yes" xml:space="preserve">
          <source>The call to &lt;code&gt;panic!&lt;/code&gt; causes the error message contained in the last two lines. The first line shows our panic message and the place in our source code where the panic occurred: &lt;em&gt;src/main.rs:2:5&lt;/em&gt; indicates that it&amp;rsquo;s the second line, fifth character of our &lt;em&gt;src/main.rs&lt;/em&gt; file.</source>
          <target state="translated">Призыв к &lt;code&gt;panic!&lt;/code&gt; вызывает сообщение об ошибке, содержащееся в последних двух строках. Первая строка показывает наше сообщение о панике и место в нашем исходном коде, где возникла паника: &lt;em&gt;src / main.rs: 2: 5&lt;/em&gt; указывает, что это вторая строка, пятый символ нашего файла &lt;em&gt;src / main.rs.&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="76991560cfa9d5bcd0a2eea05c7ac9259a741680" translate="yes" xml:space="preserve">
          <source>The call to &lt;code&gt;parse&lt;/code&gt; could easily cause an error. If, for example, the string contained &lt;code&gt;A👍%&lt;/code&gt;, there would be no way to convert that to a number. Because it might fail, the &lt;code&gt;parse&lt;/code&gt; method returns a &lt;code&gt;Result&lt;/code&gt; type, much as the &lt;code&gt;read_line&lt;/code&gt; method does (discussed earlier in &lt;a href=&quot;#handling-potential-failure-with-the-result-type&quot;&gt;&amp;ldquo;Handling Potential Failure with the &lt;code&gt;Result&lt;/code&gt; Type&amp;rdquo;&lt;/a&gt;). We&amp;rsquo;ll treat this &lt;code&gt;Result&lt;/code&gt; the same way by using the &lt;code&gt;expect&lt;/code&gt; method again. If &lt;code&gt;parse&lt;/code&gt; returns an &lt;code&gt;Err&lt;/code&gt;&lt;code&gt;Result&lt;/code&gt; variant because it couldn&amp;rsquo;t create a number from the string, the &lt;code&gt;expect&lt;/code&gt; call will crash the game and print the message we give it. If &lt;code&gt;parse&lt;/code&gt; can successfully convert the string to a number, it will return the &lt;code&gt;Ok&lt;/code&gt; variant of &lt;code&gt;Result&lt;/code&gt;, and &lt;code&gt;expect&lt;/code&gt; will return the number that we want from the &lt;code&gt;Ok&lt;/code&gt; value.</source>
          <target state="translated">Вызов &lt;code&gt;parse&lt;/code&gt; легко может вызвать ошибку. Если, например, строка содержит &lt;code&gt;A👍%&lt;/code&gt; , преобразовать ее в число невозможно. Поскольку это может привести к сбою, метод &lt;code&gt;parse&lt;/code&gt; возвращает тип &lt;code&gt;Result&lt;/code&gt; , как и метод &lt;code&gt;read_line&lt;/code&gt; (который обсуждался ранее в разделе &lt;a href=&quot;#handling-potential-failure-with-the-result-type&quot;&gt;&amp;laquo;Обработка потенциального сбоя с помощью типа &lt;code&gt;Result&lt;/code&gt; &amp;raquo;&lt;/a&gt; ). Мы обработаем этот &lt;code&gt;Result&lt;/code&gt; таким же образом, снова используя метод &lt;code&gt;expect&lt;/code&gt; . Если &lt;code&gt;parse&lt;/code&gt; возвращает &lt;code&gt;Err&lt;/code&gt; &lt;code&gt;Result&lt;/code&gt; вариант , поскольку он не может создать ряд из строки, &lt;code&gt;expect&lt;/code&gt; call завершит игру и напечатает сообщение, которое мы ему дали. Если &lt;code&gt;parse&lt;/code&gt; может успешно преобразовать строку в число, он вернет вариант &lt;code&gt;Result&lt;/code&gt; &lt;code&gt;Ok&lt;/code&gt; , и &lt;code&gt;expect&lt;/code&gt; что вернет число, которое мы хотим из значения &lt;code&gt;Ok&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7b69e26d39a3f8839842ab3c559f82019ca9b310" translate="yes" xml:space="preserve">
          <source>The call to &lt;code&gt;recv&lt;/code&gt; blocks, so if there is no job yet, the current thread will wait until a job becomes available. The &lt;code&gt;Mutex&amp;lt;T&amp;gt;&lt;/code&gt; ensures that only one &lt;code&gt;Worker&lt;/code&gt; thread at a time is trying to request a job.</source>
          <target state="translated">Вызов &lt;code&gt;recv&lt;/code&gt; блокируется, поэтому, если задания еще нет, текущий поток будет ждать, пока задание не станет доступным. &lt;code&gt;Mutex&amp;lt;T&amp;gt;&lt;/code&gt; гарантирует , что только один &lt;code&gt;Worker&lt;/code&gt; поток одновременно пытается запросить работу.</target>
        </trans-unit>
        <trans-unit id="8993444f4968db6cec0c3f76e82220cf7def7574" translate="yes" xml:space="preserve">
          <source>The caller has to ensure that no references in the supplied thread closure or its return type can outlive the spawned thread's lifetime. This can be guaranteed in two ways:</source>
          <target state="translated">Звонящий должен удостовериться,что ни одна из ссылок в поставляемой резьбовой заглушке или в ее обратном типе не сможет пережить срок службы нерестовой резьбы.Это может быть гарантировано двумя способами:</target>
        </trans-unit>
        <trans-unit id="093036972d7bffcd0b16a57c6e2ba75deeb1dca1" translate="yes" xml:space="preserve">
          <source>The caller must also ensure that the memory the pointer (non-transitively) points to is never written to (except inside an &lt;code&gt;UnsafeCell&lt;/code&gt;) using this pointer or any pointer derived from it. If you need to mutate the contents of the slice, use &lt;a href=&quot;#method.as_mut_ptr&quot;&gt;&lt;code&gt;as_mut_ptr&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Вызывающая сторона также должна гарантировать, что память, на которую указывает указатель (непереходно), никогда не записывается (кроме как внутри &lt;code&gt;UnsafeCell&lt;/code&gt; ) с использованием этого указателя или любого указателя, производного от него. Если вам нужно изменить содержимое среза, используйте &lt;a href=&quot;#method.as_mut_ptr&quot;&gt; &lt;code&gt;as_mut_ptr&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="fbd8e378206e5ebe48537e21894c0d0196aa5c37" translate="yes" xml:space="preserve">
          <source>The caller must also ensure that the memory the pointer (non-transitively) points to is never written to (except inside an &lt;code&gt;UnsafeCell&lt;/code&gt;) using this pointer or any pointer derived from it. If you need to mutate the contents of the slice, use &lt;a href=&quot;struct.vec#method.as_mut_ptr&quot;&gt;&lt;code&gt;as_mut_ptr&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2daa4ea0adccac77e0ee2e5186b78bccb935a23d" translate="yes" xml:space="preserve">
          <source>The caller must ensure that the content of the slice is valid UTF-8 before the borrow ends and the underlying &lt;code&gt;str&lt;/code&gt; is used.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ac3ada34e0728cb1a740ac35a9a92bd4109e42c8" translate="yes" xml:space="preserve">
          <source>The caller must ensure that the returned pointer is never written to. If you need to mutate the contents of the string slice, use &lt;a href=&quot;#method.as_mut_ptr&quot;&gt;&lt;code&gt;as_mut_ptr&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Вызывающий должен гарантировать, что возвращаемый указатель никогда не записывается. Если вам нужно изменить содержимое строкового фрагмента, используйте &lt;a href=&quot;#method.as_mut_ptr&quot;&gt; &lt;code&gt;as_mut_ptr&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="0c95ecf028004da1510b460935745006e917bea1" translate="yes" xml:space="preserve">
          <source>The caller must ensure that the returned pointer is never written to. If you need to mutate the contents of the string slice, use &lt;a href=&quot;../primitive.str#method.as_mut_ptr&quot;&gt;&lt;code&gt;as_mut_ptr&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="de2dba4a5088d0450aaa1d7584230c3882b4aa0e" translate="yes" xml:space="preserve">
          <source>The caller must ensure that the returned pointer is never written to. If you need to mutate the contents of the string slice, use &lt;a href=&quot;primitive.str#method.as_mut_ptr&quot;&gt;&lt;code&gt;as_mut_ptr&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0392a3d2bc79f7cc36923d474ab5bb48f657c119" translate="yes" xml:space="preserve">
          <source>The caller must ensure that the slice outlives the pointer this function returns, or else it will end up pointing to garbage.</source>
          <target state="translated">Звонящий должен удостовериться,что ломтик пережит указатель,который возвращается этой функцией,иначе он укажет на мусор.</target>
        </trans-unit>
        <trans-unit id="bf480a8080607d02f4b53d9ea9e935964787c02b" translate="yes" xml:space="preserve">
          <source>The caller must ensure that the vector outlives the pointer this function returns, or else it will end up pointing to garbage. Modifying the vector may cause its buffer to be reallocated, which would also make any pointers to it invalid.</source>
          <target state="translated">Звонящий должен убедиться,что вектор пережит указатель,который возвращается этой функцией,иначе он укажет на мусор.Изменение вектора может привести к перераспределению его буфера,что также сделает любые указатели на него недействительными.</target>
        </trans-unit>
        <trans-unit id="09005f0066a1b73d30e33e09129bf20aee61c736" translate="yes" xml:space="preserve">
          <source>The calling thread will be blocked until there are no more writers which hold the lock. There may be other readers currently inside the lock when this method returns. This method does not provide any guarantees with respect to the ordering of whether contentious readers or writers will acquire the lock first.</source>
          <target state="translated">Вызовная нить будет заблокирована до тех пор,пока больше нет записывающих устройств,которые удерживают блокировку.Когда этот метод вернется,в блокировке могут быть и другие читатели.Этот метод не дает никаких гарантий в отношении того,что спорные читатели или записывающие устройства получат блокировку первыми.</target>
        </trans-unit>
        <trans-unit id="4c684d1da6df1a86528a2f3d33b0bb20fea3d352" translate="yes" xml:space="preserve">
          <source>The calls to &lt;code&gt;thread::sleep&lt;/code&gt; force a thread to stop its execution for a short duration, allowing a different thread to run. The threads will probably take turns, but that isn&amp;rsquo;t guaranteed: it depends on how your operating system schedules the threads. In this run, the main thread printed first, even though the print statement from the spawned thread appears first in the code. And even though we told the spawned thread to print until &lt;code&gt;i&lt;/code&gt; is 9, it only got to 5 before the main thread shut down.</source>
          <target state="translated">Вызовы &lt;code&gt;thread::sleep&lt;/code&gt; заставляют поток на короткое время останавливать свое выполнение, позволяя запускать другой поток. Потоки, вероятно, будут меняться, но это не гарантируется: это зависит от того, как ваша операционная система планирует потоки. В этом прогоне основной поток печатается первым, хотя оператор печати из порожденного потока появляется первым в коде. И хотя мы сказали порожденному потоку печатать до тех пор, пока &lt;code&gt;i&lt;/code&gt; не станет 9, он дошел только до 5, прежде чем основной поток завершился.</target>
        </trans-unit>
        <trans-unit id="c7560eebffb8ae3cdb259698d7be211bc4620b7e" translate="yes" xml:space="preserve">
          <source>The canonical ExitCode for successful termination on this platform.</source>
          <target state="translated">Канонический ExitCode для успешного завершения работы на этой платформе.</target>
        </trans-unit>
        <trans-unit id="8f6ef1b9ea50b970966541a96ea6f822d628893b" translate="yes" xml:space="preserve">
          <source>The canonical ExitCode for unsuccessful termination on this platform.</source>
          <target state="translated">Канонический ExitCode для неудачного завершения работы на этой платформе.</target>
        </trans-unit>
        <trans-unit id="edfe5292e463236ad7502b40af63d1dc3846bebd" translate="yes" xml:space="preserve">
          <source>The canonical path is only meaningful within a given crate. There is no global namespace across crates; an item's canonical path merely identifies it within the crate.</source>
          <target state="translated">Канонический путь имеет смысл только внутри данного ящика.В ящиках нет глобального пространства имён;канонический путь элемента лишь идентифицирует его внутри ящика.</target>
        </trans-unit>
        <trans-unit id="42b8d1ea1b4247711765802c026fc2d790b1362d" translate="yes" xml:space="preserve">
          <source>The canonical safe use of &lt;code&gt;mem::forget&lt;/code&gt; is to circumvent a value's destructor implemented by the &lt;code&gt;Drop&lt;/code&gt; trait. For example, this will leak a &lt;code&gt;File&lt;/code&gt;, i.e. reclaim the space taken by the variable but never close the underlying system resource:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1aa3ddcbed06fec001e59bb6f3f1f1da2ef18ef6" translate="yes" xml:space="preserve">
          <source>The capacity may be increased by more than &lt;code&gt;additional&lt;/code&gt; bytes if it chooses, to prevent frequent reallocations.</source>
          <target state="translated">Емкость может быть увеличена более чем на &lt;code&gt;additional&lt;/code&gt; байты, если это необходимо, чтобы предотвратить частое перераспределение.</target>
        </trans-unit>
        <trans-unit id="4e527152d8f3ca4ddc869842d5ee9ae2a46a82fb" translate="yes" xml:space="preserve">
          <source>The capacity of a vector is the amount of space allocated for any future elements that will be added onto the vector. This is not to be confused with the &lt;em&gt;length&lt;/em&gt; of a vector, which specifies the number of actual elements within the vector. If a vector's length exceeds its capacity, its capacity will automatically be increased, but its elements will have to be reallocated.</source>
          <target state="translated">Емкость вектора - это объем пространства, выделенного для любых будущих элементов, которые будут добавлены в вектор. Это не следует путать с &lt;em&gt;длиной&lt;/em&gt; вектора, которая определяет количество фактических элементов в векторе. Если длина вектора превышает его емкость, его емкость автоматически увеличивается, но его элементы придется перераспределить.</target>
        </trans-unit>
        <trans-unit id="a70fb21498dabd7b592b7614b4af0ad2efc52b05" translate="yes" xml:space="preserve">
          <source>The capacity will remain at least as large as both the length and the supplied value.</source>
          <target state="translated">Мощность останется,по меньшей мере,такой же,как и длина,и поставляемая величина.</target>
        </trans-unit>
        <trans-unit id="f2f4d42ff0e5eed287aac391d229f38ad7615e31" translate="yes" xml:space="preserve">
          <source>The captured values of a &lt;a href=&quot;types/closure&quot;&gt;closure&lt;/a&gt; are dropped in an unspecified order.</source>
          <target state="translated">Захваченные значения &lt;a href=&quot;types/closure&quot;&gt;замыкания&lt;/a&gt; отбрасываются в неопределенном порядке.</target>
        </trans-unit>
        <trans-unit id="138edd42fa740c68b92f8f2886d9a7cfd608a2f8" translate="yes" xml:space="preserve">
          <source>The changes we needed to make to &lt;code&gt;main&lt;/code&gt; to reassign &lt;code&gt;post&lt;/code&gt; mean that this implementation doesn&amp;rsquo;t quite follow the object-oriented state pattern anymore: the transformations between the states are no longer encapsulated entirely within the &lt;code&gt;Post&lt;/code&gt; implementation. However, our gain is that invalid states are now impossible because of the type system and the type checking that happens at compile time! This ensures that certain bugs, such as display of the content of an unpublished post, will be discovered before they make it to production.</source>
          <target state="translated">Изменения, которые нам нужно было внести в &lt;code&gt;main&lt;/code&gt; для переназначения &lt;code&gt;post&lt;/code&gt; означают, что эта реализация больше не полностью соответствует объектно-ориентированному шаблону состояний: преобразования между состояниями больше не инкапсулируются полностью в реализации &lt;code&gt;Post&lt;/code&gt; . Однако наше преимущество в том, что недопустимые состояния теперь невозможны из-за системы типов и проверки типов, которая происходит во время компиляции! Это гарантирует, что определенные ошибки, такие как отображение содержимого неопубликованного сообщения, будут обнаружены до того, как они попадут в рабочую среду.</target>
        </trans-unit>
        <trans-unit id="7c6978553f5d9c2a253b6007e164ab1e1253e787" translate="yes" xml:space="preserve">
          <source>The character represented by this escape</source>
          <target state="translated">Персонаж,представляющий этот побег</target>
        </trans-unit>
        <trans-unit id="444f11cad1e3ea489affb1093e4cfe00aec033b8" translate="yes" xml:space="preserve">
          <source>The character type, &lt;code&gt;char&lt;/code&gt;.</source>
          <target state="translated">Тип символа, &lt;code&gt;char&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a2ab8aadbe1c6203ddb8254dc62679ad2d0d6a50" translate="yes" xml:space="preserve">
          <source>The child inherits from the corresponding parent descriptor.</source>
          <target state="translated">Ребенок наследует от соответствующего родительского дескриптора.</target>
        </trans-unit>
        <trans-unit id="57f64da60a0aae4c7ca65b39d52634b157698777" translate="yes" xml:space="preserve">
          <source>The chunks are array references and do not overlap. If &lt;code&gt;N&lt;/code&gt; does not divide the length of the slice, then the last up to &lt;code&gt;N-1&lt;/code&gt; elements will be omitted and can be retrieved from the &lt;code&gt;remainder&lt;/code&gt; function of the iterator.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="15fa38fbe64a63fe95b52b94271d4ba554613043" translate="yes" xml:space="preserve">
          <source>The chunks are mutable array references and do not overlap. If &lt;code&gt;N&lt;/code&gt; does not divide the length of the slice, then the last up to &lt;code&gt;N-1&lt;/code&gt; elements will be omitted and can be retrieved from the &lt;code&gt;into_remainder&lt;/code&gt; function of the iterator.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="22f36eeee32622c7a505cef344bfce71a990d798" translate="yes" xml:space="preserve">
          <source>The chunks are mutable slices, and do not overlap. If &lt;code&gt;chunk_size&lt;/code&gt; does not divide the length of the slice, then the last chunk will not have length &lt;code&gt;chunk_size&lt;/code&gt;.</source>
          <target state="translated">Эти фрагменты являются изменяемыми фрагментами и не перекрываются. Если &lt;code&gt;chunk_size&lt;/code&gt; не делит длину среза, то последний чанк не будет иметь длину &lt;code&gt;chunk_size&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a56cc46096f73dcb9c3581ef24840c1b8a52d3e3" translate="yes" xml:space="preserve">
          <source>The chunks are mutable slices, and do not overlap. If &lt;code&gt;chunk_size&lt;/code&gt; does not divide the length of the slice, then the last up to &lt;code&gt;chunk_size-1&lt;/code&gt; elements will be omitted and can be retrieved from the &lt;code&gt;into_remainder&lt;/code&gt; function of the iterator.</source>
          <target state="translated">Эти фрагменты являются изменяемыми фрагментами и не перекрываются. Если &lt;code&gt;chunk_size&lt;/code&gt; не делит длину среза, то последние элементы вплоть до &lt;code&gt;chunk_size-1&lt;/code&gt; будут опущены и могут быть извлечены из функции &lt;code&gt;into_remainder&lt;/code&gt; итератора.</target>
        </trans-unit>
        <trans-unit id="b9b82e1f955649f5c987c92e4ad59440a3cb7655" translate="yes" xml:space="preserve">
          <source>The chunks are slices and do not overlap. If &lt;code&gt;chunk_size&lt;/code&gt; does not divide the length of the slice, then the last chunk will not have length &lt;code&gt;chunk_size&lt;/code&gt;.</source>
          <target state="translated">Куски представляют собой кусочки и не перекрываются. Если &lt;code&gt;chunk_size&lt;/code&gt; не делит длину среза, то последний чанк не будет иметь длину &lt;code&gt;chunk_size&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="93ee6025794c31565e33ecdc52225cb4e18501bf" translate="yes" xml:space="preserve">
          <source>The chunks are slices and do not overlap. If &lt;code&gt;chunk_size&lt;/code&gt; does not divide the length of the slice, then the last up to &lt;code&gt;chunk_size-1&lt;/code&gt; elements will be omitted and can be retrieved from the &lt;code&gt;remainder&lt;/code&gt; function of the iterator.</source>
          <target state="translated">Куски представляют собой кусочки и не перекрываются. Если &lt;code&gt;chunk_size&lt;/code&gt; не делит длину среза, то последние элементы вплоть до &lt;code&gt;chunk_size-1&lt;/code&gt; будут опущены и могут быть извлечены из функции &lt;code&gt;remainder&lt;/code&gt; итератора.</target>
        </trans-unit>
        <trans-unit id="5ab8cfd0030cc999866ad155de372dfc9a291653" translate="yes" xml:space="preserve">
          <source>The closure &lt;code&gt;f&lt;/code&gt; is yielded a &lt;a href=&quot;struct.oncestate&quot;&gt;&lt;code&gt;OnceState&lt;/code&gt;&lt;/a&gt; structure which can be used to query the poison status of the &lt;a href=&quot;struct.once&quot;&gt;&lt;code&gt;Once&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8464cb339a91ac7f9edf87e86826287afbdde678" translate="yes" xml:space="preserve">
          <source>The closure &lt;code&gt;f&lt;/code&gt; is yielded a &lt;a href=&quot;struct.oncestate&quot;&gt;&lt;code&gt;OnceState&lt;/code&gt;&lt;/a&gt; structure which can be used to query the poison status of the &lt;code&gt;Once&lt;/code&gt;.</source>
          <target state="translated">Замыкание &lt;code&gt;f&lt;/code&gt; дает структуру &lt;a href=&quot;struct.oncestate&quot;&gt; &lt;code&gt;OnceState&lt;/code&gt; ,&lt;/a&gt; которую можно использовать для запроса статуса яда &lt;code&gt;Once&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6122336d1e3dc25f0e6a48ca5c6617d72884ddeb" translate="yes" xml:space="preserve">
          <source>The closure &lt;code&gt;f&lt;/code&gt; will only be executed once if this is called concurrently amongst many threads. If that closure panics, however, then it will &lt;em&gt;poison&lt;/em&gt; this &lt;a href=&quot;struct.once&quot;&gt;&lt;code&gt;Once&lt;/code&gt;&lt;/a&gt; instance, causing all future invocations of &lt;code&gt;call_once&lt;/code&gt; to also panic.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1151c6060a40c30d933870c684e8f8c1c9ce7a79" translate="yes" xml:space="preserve">
          <source>The closure &lt;code&gt;f&lt;/code&gt; will only be executed once if this is called concurrently amongst many threads. If that closure panics, however, then it will &lt;em&gt;poison&lt;/em&gt; this &lt;code&gt;Once&lt;/code&gt; instance, causing all future invocations of &lt;code&gt;call_once&lt;/code&gt; to also panic.</source>
          <target state="translated">Замыкание &lt;code&gt;f&lt;/code&gt; будет выполнено только один раз, если оно вызывается одновременно из множества потоков. Однако, если это закрытие вызывает панику, оно &lt;em&gt;отравит&lt;/em&gt; этот экземпляр &lt;code&gt;Once&lt;/code&gt; , в результате чего все последующие вызовы &lt;code&gt;call_once&lt;/code&gt; также будут паниковать.</target>
        </trans-unit>
        <trans-unit id="9a9ae7f6f31f6430eeec94354c414e42d745c712" translate="yes" xml:space="preserve">
          <source>The closure can use captures and its environment to track state across iterations. Depending on how the iterator is used, this may require specifying the &lt;a href=&quot;../keyword.move&quot;&gt;&lt;code&gt;move&lt;/code&gt;&lt;/a&gt; keyword on the closure.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cbba645c0f92459c3e584dd2aad4e56b6422ddeb" translate="yes" xml:space="preserve">
          <source>The closure can use captures and its environment to track state across iterations. Depending on how the iterator is used, this may require specifying the &lt;code&gt;move&lt;/code&gt; keyword on the closure.</source>
          <target state="translated">Замыкание может использовать захваты и свою среду для отслеживания состояния в итерациях. В зависимости от того, как используется итератор, может потребоваться указать ключевое слово &lt;code&gt;move&lt;/code&gt; в закрытии.</target>
        </trans-unit>
        <trans-unit id="8e57e2087c6fad9eaa8a18bdb745b2ddd95bd84c" translate="yes" xml:space="preserve">
          <source>The closure captures the &lt;code&gt;shoe_size&lt;/code&gt; parameter from the environment and compares the value with each shoe&amp;rsquo;s size, keeping only shoes of the size specified. Finally, calling &lt;code&gt;collect&lt;/code&gt; gathers the values returned by the adapted iterator into a vector that&amp;rsquo;s returned by the function.</source>
          <target state="translated">Замыкание захватывает параметр &lt;code&gt;shoe_size&lt;/code&gt; из окружающей среды и сравнивает его значение с размером каждой обуви, оставляя только туфли указанного размера. Наконец, вызов &lt;code&gt;collect&lt;/code&gt; собирает значения, возвращаемые адаптированным итератором, в вектор, возвращаемый функцией.</target>
        </trans-unit>
        <trans-unit id="0112db2feb7312ad3c6512257c24783293514225" translate="yes" xml:space="preserve">
          <source>The closure definition comes after the &lt;code&gt;=&lt;/code&gt; to assign it to the variable &lt;code&gt;expensive_closure&lt;/code&gt;. To define a closure, we start with a pair of vertical pipes (&lt;code&gt;|&lt;/code&gt;), inside which we specify the parameters to the closure; this syntax was chosen because of its similarity to closure definitions in Smalltalk and Ruby. This closure has one parameter named &lt;code&gt;num&lt;/code&gt;: if we had more than one parameter, we would separate them with commas, like &lt;code&gt;|param1, param2|&lt;/code&gt;.</source>
          <target state="translated">Определение замыкания идет после &lt;code&gt;=&lt;/code&gt; , чтобы присвоить его переменной &lt;code&gt;expensive_closure&lt;/code&gt; . Чтобы определить замыкание, мы начинаем с пары вертикальных трубок ( &lt;code&gt;|&lt;/code&gt; ), внутри которых мы указываем параметры замыкания; этот синтаксис был выбран из-за его сходства с определениями замыкания в Smalltalk и Ruby. У этого замыкания есть один параметр с именем &lt;code&gt;num&lt;/code&gt; : если бы у нас было несколько параметров, мы бы разделяли их запятыми, например &lt;code&gt;|param1, param2|&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1b467eb6733245bc29dea650b68390c954774c96" translate="yes" xml:space="preserve">
          <source>The closure is allowed to return an I/O error whose OS error code will be communicated back to the parent and returned as an error from when the spawn was requested.</source>
          <target state="translated">Закрытие позволяет вернуть ошибку ввода/вывода,код ошибки операционной системы которой будет возвращен родителю и возвращен как ошибка,начиная с того момента,когда был запрошен нерест.</target>
        </trans-unit>
        <trans-unit id="2d07950c5510607459c97a1e9bf4b42e15a155b7" translate="yes" xml:space="preserve">
          <source>The closure must return &lt;code&gt;true&lt;/code&gt; or &lt;code&gt;false&lt;/code&gt;. &lt;code&gt;filter()&lt;/code&gt; creates an iterator which calls this closure on each element. If the closure returns &lt;code&gt;true&lt;/code&gt;, then the element is returned. If the closure returns &lt;code&gt;false&lt;/code&gt;, it will try again, and call the closure on the next element, seeing if it passes the test.</source>
          <target state="translated">Замыкание должно возвращать &lt;code&gt;true&lt;/code&gt; или &lt;code&gt;false&lt;/code&gt; . &lt;code&gt;filter()&lt;/code&gt; создает итератор, который вызывает это закрытие для каждого элемента. Если замыкание возвращает &lt;code&gt;true&lt;/code&gt; , то элемент возвращается. Если замыкание возвращает &lt;code&gt;false&lt;/code&gt; , он попытается еще раз и вызовет замыкание для следующего элемента, проверяя, проходит ли он проверку.</target>
        </trans-unit>
        <trans-unit id="0dfbb8ddc807c0ec7e308a6bcf0502df62203387" translate="yes" xml:space="preserve">
          <source>The closure must return an &lt;a href=&quot;../option/enum.option&quot;&gt;&lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt;. &lt;code&gt;filter_map&lt;/code&gt; creates an iterator which calls this closure on each element. If the closure returns &lt;a href=&quot;../option/enum.option#variant.Some&quot;&gt;&lt;code&gt;Some(element)&lt;/code&gt;&lt;/a&gt;, then that element is returned. If the closure returns &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt;, it will try again, and call the closure on the next element, seeing if it will return &lt;a href=&quot;../option/enum.option#variant.Some&quot;&gt;&lt;code&gt;Some&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Замыкание должно возвращать &lt;a href=&quot;../option/enum.option&quot;&gt; &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt; &lt;/a&gt; . &lt;code&gt;filter_map&lt;/code&gt; создает итератор, который вызывает это замыкание для каждого элемента. Если замыкание возвращает &lt;a href=&quot;../option/enum.option#variant.Some&quot;&gt; &lt;code&gt;Some(element)&lt;/code&gt; &lt;/a&gt; , то возвращается этот элемент. Если замыкание возвращает &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt; &lt;code&gt;None&lt;/code&gt; &lt;/a&gt; , оно попытается еще раз и вызовет замыкание для следующего элемента, чтобы посмотреть, вернет ли оно &lt;a href=&quot;../option/enum.option#variant.Some&quot;&gt; &lt;code&gt;Some&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="7a4c6af8980cc5834794f8ba584bb6cebd16567c" translate="yes" xml:space="preserve">
          <source>The closure provided is required to adhere to the &lt;a href=&quot;trait.unwindsafe&quot;&gt;&lt;code&gt;UnwindSafe&lt;/code&gt;&lt;/a&gt; trait to ensure that all captured variables are safe to cross this boundary. The purpose of this bound is to encode the concept of &lt;a href=&quot;https://github.com/rust-lang/rfcs/blob/master/text/1236-stabilize-catch-panic.md&quot;&gt;exception safety&lt;/a&gt; in the type system. Most usage of this function should not need to worry about this bound as programs are naturally unwind safe without &lt;code&gt;unsafe&lt;/code&gt; code. If it becomes a problem the &lt;a href=&quot;struct.assertunwindsafe&quot;&gt;&lt;code&gt;AssertUnwindSafe&lt;/code&gt;&lt;/a&gt; wrapper struct can be used to quickly assert that the usage here is indeed unwind safe.</source>
          <target state="translated">Предоставленное закрытие необходимо для соблюдения &lt;a href=&quot;trait.unwindsafe&quot;&gt; &lt;code&gt;UnwindSafe&lt;/code&gt; &lt;/a&gt; чтобы гарантировать, что все захваченные переменные могут безопасно пересечь эту границу. Цель этой привязки - закодировать концепцию &lt;a href=&quot;https://github.com/rust-lang/rfcs/blob/master/text/1236-stabilize-catch-panic.md&quot;&gt;безопасности исключений&lt;/a&gt; в системе типов. В большинстве случаев при использовании этой функции не следует беспокоиться об этом ограничении, поскольку программы, естественно, безопасны при раскручивании без &lt;code&gt;unsafe&lt;/code&gt; кода. Если это становится проблемой, можно использовать структуру оболочки &lt;a href=&quot;struct.assertunwindsafe&quot;&gt; &lt;code&gt;AssertUnwindSafe&lt;/code&gt; ,&lt;/a&gt; чтобы быстро утверждать, что использование здесь действительно безопасно.</target>
        </trans-unit>
        <trans-unit id="1db2515eb35827d3b48808ed11db89506d167098" translate="yes" xml:space="preserve">
          <source>The closure uses &lt;code&gt;v&lt;/code&gt;, so it will capture &lt;code&gt;v&lt;/code&gt; and make it part of the closure&amp;rsquo;s environment. Because &lt;code&gt;thread::spawn&lt;/code&gt; runs this closure in a new thread, we should be able to access &lt;code&gt;v&lt;/code&gt; inside that new thread. But when we compile this example, we get the following error:</source>
          <target state="translated">Замыкание использует &lt;code&gt;v&lt;/code&gt; , поэтому оно захватывает &lt;code&gt;v&lt;/code&gt; и делает его частью среды замыкания. Поскольку &lt;code&gt;thread::spawn&lt;/code&gt; запускает это закрытие в новом потоке, мы должны иметь доступ к &lt;code&gt;v&lt;/code&gt; внутри этого нового потока. Но когда мы компилируем этот пример, мы получаем следующую ошибку:</target>
        </trans-unit>
        <trans-unit id="d7aca11a6ac0f9ea5173acf1c9757981e77e687c" translate="yes" xml:space="preserve">
          <source>The code associated with each arm is an expression, and the resulting value of the expression in the matching arm is the value that gets returned for the entire &lt;code&gt;match&lt;/code&gt; expression.</source>
          <target state="translated">Код , связанный с каждым рычагом является выражением, и полученное значение выражения в согласующей руке этого значение , которое получает возвращается в течение всего &lt;code&gt;match&lt;/code&gt; выражения.</target>
        </trans-unit>
        <trans-unit id="86ec55efa28e5ccc120a1f5241fba708e750dd58" translate="yes" xml:space="preserve">
          <source>The code in Listing 13-17 doesn&amp;rsquo;t do anything; the closure we&amp;rsquo;ve specified never gets called. The warning reminds us why: iterator adaptors are lazy, and we need to consume the iterator here.</source>
          <target state="translated">Код в листинге 13-17 ничего не делает; указанное нами закрытие никогда не вызывается. Предупреждение напоминает нам, почему: адаптеры итератора ленивы, и здесь нам нужно использовать итератор.</target>
        </trans-unit>
        <trans-unit id="27595e3e42c890c6fdee5b82c7f1d2b1399713f0" translate="yes" xml:space="preserve">
          <source>The code in Listing 13-3 has multiple calls to the slow calculation function. The first &lt;code&gt;if&lt;/code&gt; block calls &lt;code&gt;simulated_expensive_calculation&lt;/code&gt; twice, the &lt;code&gt;if&lt;/code&gt; inside the outer &lt;code&gt;else&lt;/code&gt; doesn&amp;rsquo;t call it at all, and the code inside the second &lt;code&gt;else&lt;/code&gt; case calls it once.</source>
          <target state="translated">Код в листинге 13-3 содержит несколько вызовов функции медленных вычислений. Первый блок &lt;code&gt;if&lt;/code&gt; вызывает &lt;code&gt;simulated_expensive_calculation&lt;/code&gt; дважды, &lt;code&gt;if&lt;/code&gt; внутри внешнего &lt;code&gt;else&lt;/code&gt; не вызывает его вообще, а код во втором случае &lt;code&gt;else&lt;/code&gt; вызывает его один раз.</target>
        </trans-unit>
        <trans-unit id="984f7b754ab17440aa0c07b718b002aed1594b7a" translate="yes" xml:space="preserve">
          <source>The code in Listing 16-1 not only stops the spawned thread prematurely most of the time due to the main thread ending, but also can&amp;rsquo;t guarantee that the spawned thread will get to run at all. The reason is that there is no guarantee on the order in which threads run!</source>
          <target state="translated">Код в листинге 16-1 не только в большинстве случаев преждевременно останавливает порожденный поток из-за завершения основного потока, но также не может гарантировать, что порожденный поток вообще будет запущен. Причина в том, что нет никакой гарантии относительно порядка, в котором выполняются потоки!</target>
        </trans-unit>
        <trans-unit id="4d5adfd375cd377b4763e2eeee96a84687acf4e5" translate="yes" xml:space="preserve">
          <source>The code in Listing 16-8 compiled and ran, but it didn&amp;rsquo;t clearly show us that two separate threads were talking to each other over the channel. In Listing 16-10 we&amp;rsquo;ve made some modifications that will prove the code in Listing 16-8 is running concurrently: the spawned thread will now send multiple messages and pause for a second between each message.</source>
          <target state="translated">Код в листинге 16-8 скомпилирован и запущен, но он не показал нам, что два отдельных потока общаются друг с другом по каналу. В листинге 16-10 мы внесли некоторые изменения, которые докажут, что код из листинга 16-8 работает одновременно: теперь порожденный поток будет отправлять несколько сообщений и делать паузу на секунду между каждым сообщением.</target>
        </trans-unit>
        <trans-unit id="9e7e0566bf3de2c83a460b61c17bb70770c4b1c5" translate="yes" xml:space="preserve">
          <source>The code in Listing 18-1 shows a series of checks for several conditions that decide what the background color should be. For this example, we&amp;rsquo;ve created variables with hardcoded values that a real program might receive from user input.</source>
          <target state="translated">Код в Листинге 18-1 показывает серию проверок нескольких условий, которые определяют, каким должен быть цвет фона. В этом примере мы создали переменные с жестко запрограммированными значениями, которые реальная программа может получать от пользовательского ввода.</target>
        </trans-unit>
        <trans-unit id="c12405c78a2c0d83f529e2201871e22f52a8474e" translate="yes" xml:space="preserve">
          <source>The code in Listing 18-3 will print the following:</source>
          <target state="translated">Код в Списке 18-3 напечатает следующее:</target>
        </trans-unit>
        <trans-unit id="efe51698d475c0b9864955b57e12d5b79c9bbf35" translate="yes" xml:space="preserve">
          <source>The code in Listing 20-14 will compile but doesn&amp;rsquo;t create any threads yet. We&amp;rsquo;ve changed the definition of &lt;code&gt;ThreadPool&lt;/code&gt; to hold a vector of &lt;code&gt;thread::JoinHandle&amp;lt;()&amp;gt;&lt;/code&gt; instances, initialized the vector with a capacity of &lt;code&gt;size&lt;/code&gt;, set up a &lt;code&gt;for&lt;/code&gt; loop that will run some code to create the threads, and returned a &lt;code&gt;ThreadPool&lt;/code&gt; instance containing them.</source>
          <target state="translated">Код в листинге 20-14 компилируется, но пока не создает никаких потоков. Мы изменили определение &lt;code&gt;ThreadPool&lt;/code&gt; , чтобы он &lt;code&gt;thread::JoinHandle&amp;lt;()&amp;gt;&lt;/code&gt; вектор экземпляров thread :: JoinHandle &amp;lt;()&amp;gt; , инициализировал вектор с емкостью &lt;code&gt;size&lt;/code&gt; , настроил цикл &lt;code&gt;for&lt;/code&gt; , который будет запускать некоторый код для создания потоков, и вернул Экземпляр &lt;code&gt;ThreadPool&lt;/code&gt; , содержащий их.</target>
        </trans-unit>
        <trans-unit id="d3a6f7dff2487d4bcc7b7e0489bef3c4a5207416" translate="yes" xml:space="preserve">
          <source>The code in Listing 20-20 is responding to requests asynchronously through the use of a thread pool, as we intended. We get some warnings about the &lt;code&gt;workers&lt;/code&gt;, &lt;code&gt;id&lt;/code&gt;, and &lt;code&gt;thread&lt;/code&gt; fields that we&amp;rsquo;re not using in a direct way that reminds us we&amp;rsquo;re not cleaning up anything. When we use the less elegant ctrl-c method to halt the main thread, all other threads are stopped immediately as well, even if they&amp;rsquo;re in the middle of serving a request.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b9b3fdc249a44ebef0cd41734527cea5bbbbc841" translate="yes" xml:space="preserve">
          <source>The code in Listing 20-21 is responding to requests asynchronously through the use of a thread pool, as we intended. We get some warnings about the &lt;code&gt;workers&lt;/code&gt;, &lt;code&gt;id&lt;/code&gt;, and &lt;code&gt;thread&lt;/code&gt; fields that we&amp;rsquo;re not using in a direct way that reminds us we&amp;rsquo;re not cleaning up anything. When we use the less elegant ctrl-c method to halt the main thread, all other threads are stopped immediately as well, even if they&amp;rsquo;re in the middle of serving a request.</source>
          <target state="translated">Код в листинге 20-21 отвечает на запросы асинхронно с использованием пула потоков, как мы и предполагали. Мы получаем некоторые предупреждения о полях &lt;code&gt;workers&lt;/code&gt; , &lt;code&gt;id&lt;/code&gt; и &lt;code&gt;thread&lt;/code&gt; , которые мы не используем напрямую, которые напоминают нам, что мы ничего не очищаем. Когда мы используем менее элегантный метод ctrl-c для остановки основного потока, все остальные потоки также немедленно останавливаются, даже если они находятся в процессе обслуживания запроса.</target>
        </trans-unit>
        <trans-unit id="af00e0657ebb48c72ab0e8023da460e28c0f23c3" translate="yes" xml:space="preserve">
          <source>The code in Listing 5-7 also creates an instance in &lt;code&gt;user2&lt;/code&gt; that has a different value for &lt;code&gt;email&lt;/code&gt; and &lt;code&gt;username&lt;/code&gt; but has the same values for the &lt;code&gt;active&lt;/code&gt; and &lt;code&gt;sign_in_count&lt;/code&gt; fields from &lt;code&gt;user1&lt;/code&gt;.</source>
          <target state="translated">Код в листинге 5-7 также создает экземпляр в &lt;code&gt;user2&lt;/code&gt; , который имеет другое значение для &lt;code&gt;email&lt;/code&gt; и &lt;code&gt;username&lt;/code&gt; но имеет те же значения для полей &lt;code&gt;active&lt;/code&gt; и &lt;code&gt;sign_in_count&lt;/code&gt; из &lt;code&gt;user1&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0531b3f098e465468fd76e222f809f69ed8edfae" translate="yes" xml:space="preserve">
          <source>The code in Listing 8-7 might look like it should work: why should a reference to the first element care about what changes at the end of the vector? This error is due to the way vectors work: adding a new element onto the end of the vector might require allocating new memory and copying the old elements to the new space, if there isn&amp;rsquo;t enough room to put all the elements next to each other where the vector currently is. In that case, the reference to the first element would be pointing to deallocated memory. The borrowing rules prevent programs from ending up in that situation.</source>
          <target state="translated">Код в листинге 8-7 может выглядеть так, как будто он должен работать: почему ссылка на первый элемент должна заботиться о том, какие изменения в конце вектора? Эта ошибка связана с тем, как работают векторы: добавление нового элемента в конец вектора может потребовать выделения новой памяти и копирования старых элементов в новое пространство, если недостаточно места для размещения всех элементов рядом с каждым. другое, где сейчас находится вектор. В этом случае ссылка на первый элемент будет указывать на освобожденную память. Правила заимствования предотвращают попадание программ в такую ​​ситуацию.</target>
        </trans-unit>
        <trans-unit id="94cc2f51904c3f9ddd0cfd3520b820c4eb301ad4" translate="yes" xml:space="preserve">
          <source>The code in Listing 9-4 will &lt;code&gt;panic!&lt;/code&gt; no matter why &lt;code&gt;File::open&lt;/code&gt; failed. What we want to do instead is take different actions for different failure reasons: if &lt;code&gt;File::open&lt;/code&gt; failed because the file doesn&amp;rsquo;t exist, we want to create the file and return the handle to the new file. If &lt;code&gt;File::open&lt;/code&gt; failed for any other reason&amp;mdash;for example, because we didn&amp;rsquo;t have permission to open the file&amp;mdash;we still want the code to &lt;code&gt;panic!&lt;/code&gt; in the same way as it did in Listing 9-4. Look at Listing 9-5, which adds an inner &lt;code&gt;match&lt;/code&gt; expression.</source>
          <target state="translated">Код в листинге 9-4 вызовет &lt;code&gt;panic!&lt;/code&gt; независимо от того, почему &lt;code&gt;File::open&lt;/code&gt; не удалось. Вместо этого мы хотим предпринять разные действия по разным причинам сбоя: если &lt;code&gt;File::open&lt;/code&gt; не удалось, потому что файл не существует, мы хотим создать файл и вернуть дескриптор нового файла. Если &lt;code&gt;File::open&lt;/code&gt; завершился неудачно по какой-либо другой причине - например, из-за того, что у нас не было разрешения на открытие файла - мы все равно хотим, чтобы код &lt;code&gt;panic!&lt;/code&gt; таким же образом, как в листинге 9-4. Посмотрите на листинге 9-5, который добавляет внутренний &lt;code&gt;match&lt;/code&gt; выражение.</target>
        </trans-unit>
        <trans-unit id="e95fa13e369d6a99c35a00c2091e07ffadc180a6" translate="yes" xml:space="preserve">
          <source>The code is trying to pass &lt;code&gt;receiver&lt;/code&gt; to multiple &lt;code&gt;Worker&lt;/code&gt; instances. This won&amp;rsquo;t work, as you&amp;rsquo;ll recall from Chapter 16: the channel implementation that Rust provides is multiple &lt;em&gt;producer&lt;/em&gt;, single &lt;em&gt;consumer&lt;/em&gt;. This means we can&amp;rsquo;t just clone the consuming end of the channel to fix this code. Even if we could, that is not the technique we would want to use; instead, we want to distribute the jobs across threads by sharing the single &lt;code&gt;receiver&lt;/code&gt; among all the workers.</source>
          <target state="translated">Код пытается передать &lt;code&gt;receiver&lt;/code&gt; нескольким экземплярам &lt;code&gt;Worker&lt;/code&gt; . Это не сработает, как вы помните из главы 16: реализация канала, которую предоставляет Rust, - это несколько &lt;em&gt;производителей&lt;/em&gt; , один &lt;em&gt;потребитель&lt;/em&gt; . Это означает, что мы не можем просто клонировать потребляющий конец канала, чтобы исправить этот код. Даже если бы мы могли, это не та техника, которую мы хотели бы использовать; вместо этого мы хотим распределять задания по потокам, разделяя один &lt;code&gt;receiver&lt;/code&gt; между всеми рабочими.</target>
        </trans-unit>
        <trans-unit id="404cdeaf9f9f5734a0b6eb5da98e14aed6b8934d" translate="yes" xml:space="preserve">
          <source>The code refers to a trait that is not in scope.</source>
          <target state="translated">Код относится к признаку,который не входит в область видимости.</target>
        </trans-unit>
        <trans-unit id="f585d5dc0ef34cc30960f293fe10c97e69068fe3" translate="yes" xml:space="preserve">
          <source>The code that calls this code will then handle getting either an &lt;code&gt;Ok&lt;/code&gt; value that contains a username or an &lt;code&gt;Err&lt;/code&gt; value that contains an &lt;code&gt;io::Error&lt;/code&gt;. We don&amp;rsquo;t know what the calling code will do with those values. If the calling code gets an &lt;code&gt;Err&lt;/code&gt; value, it could call &lt;code&gt;panic!&lt;/code&gt; and crash the program, use a default username, or look up the username from somewhere other than a file, for example. We don&amp;rsquo;t have enough information on what the calling code is actually trying to do, so we propagate all the success or error information upward for it to handle appropriately.</source>
          <target state="translated">Затем код, вызывающий этот код, будет обрабатывать получение либо значения &lt;code&gt;Ok&lt;/code&gt; , содержащего имя пользователя, либо значения &lt;code&gt;Err&lt;/code&gt; , содержащего &lt;code&gt;io::Error&lt;/code&gt; . Мы не знаем, что вызывающий код будет делать с этими значениями. Если вызывающий код получает значение &lt;code&gt;Err&lt;/code&gt; , это может вызвать &lt;code&gt;panic!&lt;/code&gt; и завершите работу программы, используйте имя пользователя по умолчанию или найдите имя пользователя, например, не из файла. У нас недостаточно информации о том, что на самом деле пытается сделать вызывающий код, поэтому мы распространяем всю информацию об успехе или ошибке вверх, чтобы он обрабатывался должным образом.</target>
        </trans-unit>
        <trans-unit id="cfac4f190729188f4689af6ae5b0042be7b9afad" translate="yes" xml:space="preserve">
          <source>The collection may reserve more space to avoid frequent reallocations.</source>
          <target state="translated">В коллекции может быть зарезервировано больше места,чтобы избежать частых перераспределений.</target>
        </trans-unit>
        <trans-unit id="a921d34f1378e463d6297235d9b237b6a37c1373" translate="yes" xml:space="preserve">
          <source>The comma following &lt;code&gt;$()&lt;/code&gt; indicates that a literal comma separator character could optionally appear after the code that matches the code in &lt;code&gt;$()&lt;/code&gt;. The &lt;code&gt;*&lt;/code&gt; specifies that the pattern matches zero or more of whatever precedes the &lt;code&gt;*&lt;/code&gt;.</source>
          <target state="translated">Запятая, следующая за &lt;code&gt;$()&lt;/code&gt; указывает, что буквальный символ-разделитель запятой может опционально стоять после кода, который соответствует коду в &lt;code&gt;$()&lt;/code&gt; . В &lt;code&gt;*&lt;/code&gt; указывает , что шаблон соответствует нулю или более независимо предшествует &lt;code&gt;*&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1bacb24582ff767b21e31f4cc1ad3d6012f25a0b" translate="yes" xml:space="preserve">
          <source>The command downloads a script and starts the installation of the &lt;code&gt;rustup&lt;/code&gt; tool, which installs the latest stable version of Rust. You might be prompted for your password. If the install is successful, the following line will appear:</source>
          <target state="translated">Команда загружает сценарий и запускает установку инструмента &lt;code&gt;rustup&lt;/code&gt; , который устанавливает последнюю стабильную версию Rust. Вам может быть предложено ввести пароль. Если установка прошла успешно, появится следующая строка:</target>
        </trans-unit>
        <trans-unit id="73b43b32097905758197f28a5b18a2fd54ae6279" translate="yes" xml:space="preserve">
          <source>The common part of these two paths is &lt;code&gt;std::io&lt;/code&gt;, and that&amp;rsquo;s the complete first path. To merge these two paths into one &lt;code&gt;use&lt;/code&gt; statement, we can use &lt;code&gt;self&lt;/code&gt; in the nested path, as shown in Listing 7-20.</source>
          <target state="translated">Общая часть этих двух путей - это &lt;code&gt;std::io&lt;/code&gt; , и это полный первый путь. Чтобы объединить эти два пути в один оператор &lt;code&gt;use&lt;/code&gt; , мы можем использовать &lt;code&gt;self&lt;/code&gt; во вложенном пути, как показано в листинге 7-20.</target>
        </trans-unit>
        <trans-unit id="3e8778a56f7c16d517be41bfd502f5b861a15290" translate="yes" xml:space="preserve">
          <source>The comparator function must define a total ordering for the elements in the slice. If the ordering is not total, the order of the elements is unspecified. An order is a total order if it is (for all &lt;code&gt;a&lt;/code&gt;, &lt;code&gt;b&lt;/code&gt; and &lt;code&gt;c&lt;/code&gt;):</source>
          <target state="translated">Функция компаратора должна определять общий порядок элементов в срезе. Если порядок не является полным, порядок элементов не указан. Заказ является общим заказом, если он (для всех &lt;code&gt;a&lt;/code&gt; , &lt;code&gt;b&lt;/code&gt; и &lt;code&gt;c&lt;/code&gt; ):</target>
        </trans-unit>
        <trans-unit id="aebc23a2aec802159973c4b13320302322bbb426" translate="yes" xml:space="preserve">
          <source>The comparator function must define a total ordering for the elements in the slice. If the ordering is not total, the order of the elements is unspecified. An order is a total order if it is (for all a, b and c):</source>
          <target state="translated">Функция компаратора должна определить общий порядок заказа элементов на срезе.Если заказ не является полным,то порядок элементов не указывается.Порядок является суммарным,если он есть (для всех a,b и c):</target>
        </trans-unit>
        <trans-unit id="25646f45d8bc733d7759e265f95a900ae5f85f26" translate="yes" xml:space="preserve">
          <source>The comparator function should implement an order consistent with the sort order of the underlying &lt;code&gt;VecDeque&lt;/code&gt;, returning an order code that indicates whether its argument is &lt;code&gt;Less&lt;/code&gt;, &lt;code&gt;Equal&lt;/code&gt; or &lt;code&gt;Greater&lt;/code&gt; than the desired target.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="92ccf3fc61c0a63453fa6ca42d0beca2274f875f" translate="yes" xml:space="preserve">
          <source>The comparator function should implement an order consistent with the sort order of the underlying slice, returning an order code that indicates whether its argument is &lt;code&gt;Less&lt;/code&gt;, &lt;code&gt;Equal&lt;/code&gt; or &lt;code&gt;Greater&lt;/code&gt; the desired target.</source>
          <target state="translated">Функция компаратора должна реализовывать порядок, согласованный с порядком сортировки нижележащего среза, возвращая код заказа, который указывает, является ли его аргумент &lt;code&gt;Less&lt;/code&gt; , &lt;code&gt;Equal&lt;/code&gt; или &lt;code&gt;Greater&lt;/code&gt; желаемой цели.</target>
        </trans-unit>
        <trans-unit id="45e688bbffc9733765a7b6aca03992e2d5e377a5" translate="yes" xml:space="preserve">
          <source>The comparison must satisfy, for all &lt;code&gt;a&lt;/code&gt;, &lt;code&gt;b&lt;/code&gt; and &lt;code&gt;c&lt;/code&gt;:</source>
          <target state="translated">Сравнение должно удовлетворять для всех &lt;code&gt;a&lt;/code&gt; , &lt;code&gt;b&lt;/code&gt; и &lt;code&gt;c&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="0c2765074489dd525efeb165a25dbc97454a652e" translate="yes" xml:space="preserve">
          <source>The compilation didn&amp;rsquo;t produce any errors, but the program resulted in a &lt;em&gt;runtime&lt;/em&gt; error and didn&amp;rsquo;t exit successfully. When you attempt to access an element using indexing, Rust will check that the index you&amp;rsquo;ve specified is less than the array length. If the index is greater than or equal to the array length, Rust will panic.</source>
          <target state="translated">Компиляция не вызвала никаких ошибок, но программа вызвала ошибку &lt;em&gt;времени выполнения&lt;/em&gt; и не завершилась успешно. Когда вы пытаетесь получить доступ к элементу с помощью индексации, Rust проверяет, что указанный вами индекс меньше длины массива. Если индекс больше или равен длине массива, Rust запаникует.</target>
        </trans-unit>
        <trans-unit id="0a0cf1febd61e4c4aeb0165c7c721394953162c8" translate="yes" xml:space="preserve">
          <source>The compilation model centers on artifacts called &lt;em&gt;crates&lt;/em&gt;. Each compilation processes a single crate in source form, and if successful, produces a single crate in binary form: either an executable or some sort of library.&lt;sup&gt;&lt;a href=&quot;#cratesourcefile&quot;&gt;2&lt;/a&gt;&lt;/sup&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="25f0592827e30de97cacdd81a110584696dcea70" translate="yes" xml:space="preserve">
          <source>The compilation model centers on artifacts called &lt;em&gt;crates&lt;/em&gt;. Each compilation processes a single crate in source form, and if successful, produces a single crate in binary form: either an executable or some sort of library.&lt;sup&gt;&lt;a href=&quot;crates-and-source-files#cratesourcefile&quot;&gt;2&lt;/a&gt;&lt;/sup&gt;</source>
          <target state="translated">Модель компиляции основана на артефактах, называемых &lt;em&gt;ящиками&lt;/em&gt; . Каждая компиляция обрабатывает один ящик в исходной форме и в случае успеха создает один ящик в двоичной форме: либо исполняемый файл, либо какую-то библиотеку. &lt;sup&gt;&lt;a href=&quot;crates-and-source-files#cratesourcefile&quot;&gt;2&lt;/a&gt;&lt;/sup&gt;</target>
        </trans-unit>
        <trans-unit id="90596055b20c856dc417525ea133e8b1049b15fa" translate="yes" xml:space="preserve">
          <source>The compiler and standard library generally tries to ensure allocations never reach a size where an offset is a concern. For instance, &lt;code&gt;Vec&lt;/code&gt; and &lt;code&gt;Box&lt;/code&gt; ensure they never allocate more than &lt;code&gt;isize::MAX&lt;/code&gt; bytes, so &lt;code&gt;vec.as_ptr().add(vec.len()).sub(vec.len())&lt;/code&gt; is always safe.</source>
          <target state="translated">Компилятор и стандартная библиотека обычно стараются гарантировать, что выделения никогда не достигают размера, при котором смещение является проблемой. Например, &lt;code&gt;Vec&lt;/code&gt; и &lt;code&gt;Box&lt;/code&gt; гарантируют, что они никогда не выделяют больше, чем &lt;code&gt;isize::MAX&lt;/code&gt; байтов, поэтому &lt;code&gt;vec.as_ptr().add(vec.len()).sub(vec.len())&lt;/code&gt; всегда безопасен.</target>
        </trans-unit>
        <trans-unit id="59cbb1cc8a088f98671593c9041c2587a34ab70d" translate="yes" xml:space="preserve">
          <source>The compiler and standard library generally tries to ensure allocations never reach a size where an offset is a concern. For instance, &lt;code&gt;Vec&lt;/code&gt; and &lt;code&gt;Box&lt;/code&gt; ensure they never allocate more than &lt;code&gt;isize::MAX&lt;/code&gt; bytes, so &lt;code&gt;vec.as_ptr().add(vec.len())&lt;/code&gt; is always safe.</source>
          <target state="translated">Компилятор и стандартная библиотека обычно стараются гарантировать, что выделения никогда не достигают размера, при котором смещение является проблемой. Например, &lt;code&gt;Vec&lt;/code&gt; и &lt;code&gt;Box&lt;/code&gt; гарантируют, что они никогда не выделяют больше, чем &lt;code&gt;isize::MAX&lt;/code&gt; байтов, поэтому &lt;code&gt;vec.as_ptr().add(vec.len())&lt;/code&gt; всегда безопасен.</target>
        </trans-unit>
        <trans-unit id="5647f6303a746120d1bc013678162600f20688f8" translate="yes" xml:space="preserve">
          <source>The compiler and standard library generally try to ensure allocations never reach a size where an offset is a concern. For instance, &lt;code&gt;Vec&lt;/code&gt; and &lt;code&gt;Box&lt;/code&gt; ensure they never allocate more than &lt;code&gt;isize::MAX&lt;/code&gt; bytes, so &lt;code&gt;ptr_into_vec.offset_from(vec.as_ptr())&lt;/code&gt; is always safe.</source>
          <target state="translated">Компилятор и стандартная библиотека обычно стараются гарантировать, что выделения никогда не достигают размера, при котором смещение является проблемой. Например, &lt;code&gt;Vec&lt;/code&gt; и &lt;code&gt;Box&lt;/code&gt; гарантируют, что они никогда не выделяют больше, чем &lt;code&gt;isize::MAX&lt;/code&gt; байтов, поэтому &lt;code&gt;ptr_into_vec.offset_from(vec.as_ptr())&lt;/code&gt; всегда безопасен.</target>
        </trans-unit>
        <trans-unit id="d1adc5111740e7a8d58bceec3601a6e3d4ef92d4" translate="yes" xml:space="preserve">
          <source>The compiler could not infer a type and asked for a type annotation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="030993899960155dfaeaf56819f76523f90d8c36" translate="yes" xml:space="preserve">
          <source>The compiler currently implements no method of hinting what format a library should be linked with. When dynamically linking, the compiler will attempt to maximize dynamic dependencies while still allowing some dependencies to be linked in via an rlib.</source>
          <target state="translated">В настоящее время компилятор не реализует никакого метода подсказки,с каким форматом библиотеки следует компоновать.При динамическом компоновке компилятор будет пытаться максимизировать динамические зависимости,позволяя при этом компоновать некоторые из них через rlib.</target>
        </trans-unit>
        <trans-unit id="fe8298a5d8326c70ef926aa1826e7331454f6a26" translate="yes" xml:space="preserve">
          <source>The compiler doesn't know what method to call because more than one method has the same prototype.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1821ca1d85d61b39565f6e9976cc18b3afce261c" translate="yes" xml:space="preserve">
          <source>The compiler doesn't know what method to call because more than one method has the same prototype. Erroneous code example:</source>
          <target state="translated">Компилятор не знает,какой метод вызывать,так как несколько методов имеют один и тот же прототип.Пример ошибочного кода:</target>
        </trans-unit>
        <trans-unit id="1be1361775707ec1fbdcf50e883b1d7b1bdb5f0d" translate="yes" xml:space="preserve">
          <source>The compiler error is as follows:</source>
          <target state="translated">Ошибка компилятора заключается в следующем:</target>
        </trans-unit>
        <trans-unit id="b5655bf28c5aee029b50ebff36ecbfc08852001c" translate="yes" xml:space="preserve">
          <source>The compiler even reminds us that this only works with closures!</source>
          <target state="translated">Компилятор даже напоминает,что это работает только с замыканиями!</target>
        </trans-unit>
        <trans-unit id="b0cba35bf39af6cdfd6b56d4dbe10dbaf77ed516" translate="yes" xml:space="preserve">
          <source>The compiler found a function whose body contains a &lt;code&gt;return;&lt;/code&gt; statement but whose return type is not &lt;code&gt;()&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b08f603159dc0eecd0f21f28c07166cefeb69847" translate="yes" xml:space="preserve">
          <source>The compiler found a function whose body contains a &lt;code&gt;return;&lt;/code&gt; statement but whose return type is not &lt;code&gt;()&lt;/code&gt;. An example of this is:</source>
          <target state="translated">Компилятор нашел функцию, тело которой содержит &lt;code&gt;return;&lt;/code&gt; оператор, но возвращаемый тип которого не равен &lt;code&gt;()&lt;/code&gt; . Пример этого:</target>
        </trans-unit>
        <trans-unit id="3e4713e81e1fe06044671ee83362a3b9a0f5ad86" translate="yes" xml:space="preserve">
          <source>The compiler gives us this error:</source>
          <target state="translated">Компилятор выдает нам эту ошибку:</target>
        </trans-unit>
        <trans-unit id="b01feef52238a9b5f1daf51373c75b238f421fe8" translate="yes" xml:space="preserve">
          <source>The compiler is allowed to perform any combination of these optimizations, as long as the final optimized code, when executed, produces the same results as the one without optimizations.</source>
          <target state="translated">Компилятору разрешается выполнять любую комбинацию этих оптимизаций,если только конечный оптимизированный код при выполнении дает те же результаты,что и код без оптимизаций.</target>
        </trans-unit>
        <trans-unit id="ec5c1119f8e1ac4ec1c89254831939480c03edd7" translate="yes" xml:space="preserve">
          <source>The compiler may allow attributes for external tools where each tool resides in its own namespace. The first segment of the attribute path is the name of the tool, with one or more additional segments whose interpretation is up to the tool.</source>
          <target state="translated">Компилятор может разрешить атрибуты для внешних инструментов,где каждый инструмент находится в своем собственном пространстве имён.Первый сегмент пути атрибута-это имя инструмента,с одним или несколькими дополнительными сегментами,интерпретация которых зависит от инструмента.</target>
        </trans-unit>
        <trans-unit id="a7720aa4345b4147bab4d25831f37466e57d1fcc" translate="yes" xml:space="preserve">
          <source>The compiler prefers to capture a closed-over variable by immutable borrow, followed by unique immutable borrow (see below), by mutable borrow, and finally by move. It will pick the first choice of these that allows the closure to compile. The choice is made only with regards to the contents of the closure expression; the compiler does not take into account surrounding code, such as the lifetimes of involved variables.</source>
          <target state="translated">Компилятор предпочитает захватывать закрытую переменную неизменяемой заимствованием,затем уникальной неизменяемой заимствованием (см.ниже),мутируемой заимствованием и,наконец,перемещением.Он выберет первый из них,который позволит скомпилировать закрытую переменную.Выбор делается только в отношении содержимого закрывающего выражения;компилятор не учитывает окружающий код,например,время жизни задействованных переменных.</target>
        </trans-unit>
        <trans-unit id="5212bd9f30887e16d9c074bb9450838a12a0be2d" translate="yes" xml:space="preserve">
          <source>The compiler shouldn't change the relative order or number of volatile memory operations. However, volatile memory operations on zero-sized types (e.g., if a zero-sized type is passed to &lt;code&gt;read_volatile&lt;/code&gt;) are noops and may be ignored.</source>
          <target state="translated">Компилятор не должен изменять относительный порядок или количество операций с энергозависимой памятью. Однако операции с энергозависимой памятью для типов нулевого размера (например, если тип нулевого размера передается в &lt;code&gt;read_volatile&lt;/code&gt; ) являются пустыми действиями и могут игнорироваться.</target>
        </trans-unit>
        <trans-unit id="955e9c25a8bb7d2a1fb8b16fdbf5d5e19b107461" translate="yes" xml:space="preserve">
          <source>The compiler shouldn't change the relative order or number of volatile memory operations. However, volatile memory operations on zero-sized types (e.g., if a zero-sized type is passed to &lt;code&gt;write_volatile&lt;/code&gt;) are noops and may be ignored.</source>
          <target state="translated">Компилятор не должен изменять относительный порядок или количество операций с энергозависимой памятью. Однако операции с энергозависимой памятью для типов нулевого размера (например, если тип нулевого размера передается в &lt;code&gt;write_volatile&lt;/code&gt; ) являются пустыми действиями и могут игнорироваться.</target>
        </trans-unit>
        <trans-unit id="d348a40c0a7a1bd0e6bae37a48c29f90fc773ea5" translate="yes" xml:space="preserve">
          <source>The compiler supports various methods to link crates together both statically and dynamically. This section will explore the various methods to link crates together, and more information about native libraries can be found in the &lt;a href=&quot;https://doc.rust-lang.org/book/ffi.html&quot;&gt;FFI section of the book&lt;/a&gt;.</source>
          <target state="translated">Компилятор поддерживает различные методы статического и динамического связывания ящиков. В этом разделе будут рассмотрены различные методы соединения ящиков вместе, а дополнительную информацию о собственных библиотеках можно найти в &lt;a href=&quot;https://doc.rust-lang.org/book/ffi.html&quot;&gt;разделе книги&lt;/a&gt; о FFI .</target>
        </trans-unit>
        <trans-unit id="e6a5c185d40ba65d2c0863bc15ff86b37643834d" translate="yes" xml:space="preserve">
          <source>The compiler then knows to not make any incorrect assumptions or optimizations on this code.</source>
          <target state="translated">Тогда компилятор знает,что не следует делать некорректных предположений или оптимизаций по данному коду.</target>
        </trans-unit>
        <trans-unit id="4f49b0710fee284944c10fc8dd575c9f675cc65d" translate="yes" xml:space="preserve">
          <source>The compiler uses three rules to figure out what lifetimes references have when there aren&amp;rsquo;t explicit annotations. The first rule applies to input lifetimes, and the second and third rules apply to output lifetimes. If the compiler gets to the end of the three rules and there are still references for which it can&amp;rsquo;t figure out lifetimes, the compiler will stop with an error. These rules apply to &lt;code&gt;fn&lt;/code&gt; definitions as well as &lt;code&gt;impl&lt;/code&gt; blocks.</source>
          <target state="translated">Компилятор использует три правила, чтобы выяснить, какие ссылки на время жизни имеют, когда нет явных аннотаций. Первое правило применяется к срокам службы входных данных, а второе и третье правила применяются к срокам службы выходных данных. Если компилятор доходит до конца трех правил и все еще есть ссылки, для которых он не может определить время жизни, компилятор остановится с ошибкой. Эти правила применяются к определениям &lt;code&gt;fn&lt;/code&gt; , а также к блокам &lt;code&gt;impl&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="433b36c96c38bd66008e924fa1864ced83fcb794" translate="yes" xml:space="preserve">
          <source>The compiler will complain that it needs lifetime specifiers:</source>
          <target state="translated">Компилятор пожалуется,что ему нужны спецификаторы времени жизни:</target>
        </trans-unit>
        <trans-unit id="572859abb18057fb674dd21429d06414b40c8275" translate="yes" xml:space="preserve">
          <source>The compiler will determine which of the &lt;a href=&quot;../types/closure#call-traits-and-coercions&quot;&gt;closure traits&lt;/a&gt; the closure's type will implement by how it acts on its captured variables. The closure will also implement &lt;a href=&quot;../special-types-and-traits#send&quot;&gt;&lt;code&gt;Send&lt;/code&gt;&lt;/a&gt; and/or &lt;a href=&quot;../special-types-and-traits#sync&quot;&gt;&lt;code&gt;Sync&lt;/code&gt;&lt;/a&gt; if all of its captured types do. These traits allow functions to accept closures using generics, even though the exact types can't be named.</source>
          <target state="translated">Компилятор определит, какие из &lt;a href=&quot;../types/closure#call-traits-and-coercions&quot;&gt;признаков&lt;/a&gt; замыкания будет реализовывать тип замыкания, по тому, как он действует с захваченными переменными. Замыкание также реализует &lt;a href=&quot;../special-types-and-traits#send&quot;&gt; &lt;code&gt;Send&lt;/code&gt; &lt;/a&gt; и / или &lt;a href=&quot;../special-types-and-traits#sync&quot;&gt; &lt;code&gt;Sync&lt;/code&gt; &lt;/a&gt; если все его захваченные типы выполняются. Эти черты позволяют функциям принимать замыкания с использованием обобщений, даже если точные типы не могут быть названы.</target>
        </trans-unit>
        <trans-unit id="948f1a92a83b2e1e3378ae6b818bd73449ba504b" translate="yes" xml:space="preserve">
          <source>The compiler will indicate when you&amp;rsquo;re trying to do something that violates the rules of object safety in regard to trait objects. For example, let&amp;rsquo;s say we tried to implement the &lt;code&gt;Screen&lt;/code&gt; struct in Listing 17-4 to hold types that implement the &lt;code&gt;Clone&lt;/code&gt; trait instead of the &lt;code&gt;Draw&lt;/code&gt; trait, like this:</source>
          <target state="translated">Компилятор укажет, когда вы пытаетесь сделать что-то, что нарушает правила безопасности объекта в отношении объектов-признаков. Например, предположим, что мы пытались реализовать структуру &lt;code&gt;Screen&lt;/code&gt; в листинге 17-4 для хранения типов, которые реализуют черту &lt;code&gt;Clone&lt;/code&gt; вместо &lt;code&gt;Draw&lt;/code&gt; , например:</target>
        </trans-unit>
        <trans-unit id="0946476a608603480a8c85b783bae37331306e67" translate="yes" xml:space="preserve">
          <source>The compiler, in general, assumes that a variable is properly initialized according to the requirements of the variable's type. For example, a variable of reference type must be aligned and non-NULL. This is an invariant that must &lt;em&gt;always&lt;/em&gt; be upheld, even in unsafe code. As a consequence, zero-initializing a variable of reference type causes instantaneous &lt;a href=&quot;../../reference/behavior-considered-undefined&quot;&gt;undefined behavior&lt;/a&gt;, no matter whether that reference ever gets used to access memory:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a84c7a7769bfd766452d6377b59bc8d2e574c64c" translate="yes" xml:space="preserve">
          <source>The compiler, in general, assumes that variables are properly initialized at their respective type. For example, a variable of reference type must be aligned and non-NULL. This is an invariant that must &lt;em&gt;always&lt;/em&gt; be upheld, even in unsafe code. As a consequence, zero-initializing a variable of reference type causes instantaneous &lt;a href=&quot;../../reference/behavior-considered-undefined&quot;&gt;undefined behavior&lt;/a&gt;, no matter whether that reference ever gets used to access memory:</source>
          <target state="translated">Компилятор, как правило, предполагает, что переменные правильно инициализированы по соответствующему типу. Например, переменная ссылочного типа должна быть выровнена и отличаться от NULL. Это инвариант, который необходимо соблюдать &lt;em&gt;всегда&lt;/em&gt; , даже в небезопасном коде. Как следствие, инициализация нулевой переменной ссылочного типа вызывает мгновенное &lt;a href=&quot;../../reference/behavior-considered-undefined&quot;&gt;неопределенное поведение&lt;/a&gt; , независимо от того, используется ли эта ссылка для доступа к памяти:</target>
        </trans-unit>
        <trans-unit id="4ed049edf6523bee71aa6c2cc8dac47d3acb83f3" translate="yes" xml:space="preserve">
          <source>The computed offset cannot exceed &lt;code&gt;isize::MAX&lt;/code&gt;&lt;strong&gt;bytes&lt;/strong&gt;.</source>
          <target state="translated">Вычисленное смещение не может превышать &lt;code&gt;isize::MAX&lt;/code&gt; &lt;strong&gt;байтов&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="4f78f76fdf78ce465bd63ef1c725533fd764ba85" translate="yes" xml:space="preserve">
          <source>The computed offset, &lt;strong&gt;in bytes&lt;/strong&gt;, cannot overflow an &lt;code&gt;isize&lt;/code&gt;.</source>
          <target state="translated">Вычисленное смещение &lt;strong&gt;в байтах&lt;/strong&gt; не может &lt;code&gt;isize&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="63f5ab3561e8fa530abb7afbb885243679cbd27d" translate="yes" xml:space="preserve">
          <source>The concatenation &amp;alpha; &amp;beta; &amp;gamma; &amp;delta; is a parseable Rust program.</source>
          <target state="translated">Конкатенация &amp;alpha; &amp;beta; &amp;gamma; &amp;delta; представляет собой анализируемую программу на Rust.</target>
        </trans-unit>
        <trans-unit id="026ad0f5294d67f94938651fe3bfaacf62c15a89" translate="yes" xml:space="preserve">
          <source>The concept of lifetimes is somewhat different from tools in other programming languages, arguably making lifetimes Rust&amp;rsquo;s most distinctive feature. Although we won&amp;rsquo;t cover lifetimes in their entirety in this chapter, we&amp;rsquo;ll discuss common ways you might encounter lifetime syntax so you can become familiar with the concepts.</source>
          <target state="translated">Концепция времени жизни несколько отличается от инструментов других языков программирования, что, возможно, делает время жизни самой отличительной особенностью Rust. Хотя в этой главе мы не будем рассматривать время жизни полностью, мы обсудим общие способы, с помощью которых вы можете столкнуться с синтаксисом времени жизни, чтобы вы могли ознакомиться с концепциями.</target>
        </trans-unit>
        <trans-unit id="bf8b3cea5648a2c56269d845203de953f7dc58d3" translate="yes" xml:space="preserve">
          <source>The concepts of ownership, borrowing, and slices ensure memory safety in Rust programs at compile time. The Rust language gives you control over your memory usage in the same way as other systems programming languages, but having the owner of data automatically clean up that data when the owner goes out of scope means you don&amp;rsquo;t have to write and debug extra code to get this control.</source>
          <target state="translated">Концепции владения, заимствования и срезов обеспечивают безопасность памяти в программах Rust во время компиляции. Язык Rust дает вам контроль над использованием памяти так же, как и другие языки системного программирования, но если владелец данных автоматически очищает эти данные, когда владелец выходит за пределы области видимости, вам не нужно писать и отлаживать дополнительный код. чтобы получить этот контроль.</target>
        </trans-unit>
        <trans-unit id="5484608e7530a94c46507f1fbbbe29684e230d84" translate="yes" xml:space="preserve">
          <source>The condition can use variables created in the pattern. Listing 18-26 shows a &lt;code&gt;match&lt;/code&gt; where the first arm has the pattern &lt;code&gt;Some(x)&lt;/code&gt; and also has a match guard of &lt;code&gt;if x &amp;lt; 5&lt;/code&gt;.</source>
          <target state="translated">В условии могут использоваться переменные, созданные в шаблоне. В листинге 18-26 показано &lt;code&gt;match&lt;/code&gt; котором первая рука имеет шаблон &lt;code&gt;Some(x)&lt;/code&gt; а также имеет защиту совпадения &lt;code&gt;if x &amp;lt; 5&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c47359692fd118dbc5a64f61c4a95c135750d6d3" translate="yes" xml:space="preserve">
          <source>The condition expression of an &lt;code&gt;if&lt;/code&gt; or &lt;code&gt;while&lt;/code&gt; expression, or a &lt;code&gt;match&lt;/code&gt; guard.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="095096dc5e2804946ad94bae4f75159f2bd38855" translate="yes" xml:space="preserve">
          <source>The condition in an &lt;a href=&quot;keyword.if&quot;&gt;&lt;code&gt;if&lt;/code&gt;&lt;/a&gt; expression must be of type &lt;code&gt;bool&lt;/code&gt;. Whenever that condition evaluates to &lt;strong&gt;true&lt;/strong&gt;, the &lt;code&gt;if&lt;/code&gt; expression takes on the value of the first block. If however, the condition evaluates to &lt;code&gt;false&lt;/code&gt;, the expression takes on value of the &lt;code&gt;else&lt;/code&gt; block if there is one.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="75d37ae80df9e59cac39010c72ed606ee381207c" translate="yes" xml:space="preserve">
          <source>The condition we want to check in the inner match is whether the value returned by &lt;code&gt;error.kind()&lt;/code&gt; is the &lt;code&gt;NotFound&lt;/code&gt; variant of the &lt;code&gt;ErrorKind&lt;/code&gt; enum. If it is, we try to create the file with &lt;code&gt;File::create&lt;/code&gt;. However, because &lt;code&gt;File::create&lt;/code&gt; could also fail, we need a second arm in the inner &lt;code&gt;match&lt;/code&gt; expression. When the file can&amp;rsquo;t be created, a different error message is printed. The second arm of the outer &lt;code&gt;match&lt;/code&gt; stays the same, so the program panics on any error besides the missing file error.</source>
          <target state="translated">Условие, которое мы хотим проверить во внутреннем совпадении, заключается в том, является ли значение, возвращаемое &lt;code&gt;error.kind()&lt;/code&gt; , вариантом &lt;code&gt;NotFound&lt;/code&gt; перечисления &lt;code&gt;ErrorKind&lt;/code&gt; . Если это так, мы пытаемся создать файл с помощью &lt;code&gt;File::create&lt;/code&gt; . Однако, поскольку &lt;code&gt;File::create&lt;/code&gt; также может потерпеть неудачу, нам нужно второе плечо во внутреннем &lt;code&gt;match&lt;/code&gt; выражения. Если файл не может быть создан, печатается другое сообщение об ошибке. Вторая ветвь внешнего &lt;code&gt;match&lt;/code&gt; остается неизменной, поэтому программа паникует при любой ошибке, кроме ошибки отсутствия файла.</target>
        </trans-unit>
        <trans-unit id="6c5b1587da56cf50f7a60ae4167ed8ca12fc4a83" translate="yes" xml:space="preserve">
          <source>The conditions in which you&amp;rsquo;re allowed or not allowed to implement the trait</source>
          <target state="translated">Условия, при которых вам разрешено или не разрешено реализовать черту</target>
        </trans-unit>
        <trans-unit id="1fd449b5671c0c531048bf228bce50b5745274bb" translate="yes" xml:space="preserve">
          <source>The connection was aborted (terminated) by the remote server.</source>
          <target state="translated">Соединение было прервано (прервано)удаленным сервером.</target>
        </trans-unit>
        <trans-unit id="394cd4f1c44fd561007d2b956b477de854f22ebc" translate="yes" xml:space="preserve">
          <source>The connection was refused by the remote server.</source>
          <target state="translated">Соединение было прервано удаленным сервером.</target>
        </trans-unit>
        <trans-unit id="ee9eafc82d73396db6a743b750893f5328ee460c" translate="yes" xml:space="preserve">
          <source>The connection was reset by the remote server.</source>
          <target state="translated">Соединение было сброшено удаленным сервером.</target>
        </trans-unit>
        <trans-unit id="c5c0b8221782b43e8764b446a2f5d5156fcf8b34" translate="yes" xml:space="preserve">
          <source>The connection will be closed when the value is dropped. The reading and writing portions of the connection can also be shut down individually with the &lt;a href=&quot;#method.shutdown&quot;&gt;&lt;code&gt;shutdown&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">Соединение будет закрыто, когда значение будет сброшено. Части соединения для чтения и записи также могут быть отключены по отдельности с помощью метода &lt;a href=&quot;#method.shutdown&quot;&gt; &lt;code&gt;shutdown&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="ee6719cfaf61adca10461f2b171bde13e23a4a41" translate="yes" xml:space="preserve">
          <source>The connection will be closed when the value is dropped. The reading and writing portions of the connection can also be shut down individually with the &lt;a href=&quot;struct.tcpstream#method.shutdown&quot;&gt;&lt;code&gt;shutdown&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="98a1585e2f9a061b72de9d4f949a75a416a4fb56" translate="yes" xml:space="preserve">
          <source>The cons function concept has made its way into more general functional programming jargon: &amp;ldquo;to cons &lt;em&gt;x&lt;/em&gt; onto &lt;em&gt;y&lt;/em&gt;&amp;rdquo; informally means to construct a new container instance by putting the element &lt;em&gt;x&lt;/em&gt; at the start of this new container, followed by the container &lt;em&gt;y&lt;/em&gt;.</source>
          <target state="translated">Концепция функции cons перешла в более общий жаргон функционального программирования: &amp;laquo;преобразовать &lt;em&gt;x&lt;/em&gt; в &lt;em&gt;y&lt;/em&gt; &amp;raquo; неформально означает создать новый экземпляр контейнера, поместив элемент &lt;em&gt;x&lt;/em&gt; в начало этого нового контейнера, за которым следует контейнер &lt;em&gt;y&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="3946118b0e2f7f5ec1675cedbf82ccd7c8d576ce" translate="yes" xml:space="preserve">
          <source>The contents of &lt;em&gt;src/lib.rs&lt;/em&gt; should have the signatures shown in Listing 12-13 (we&amp;rsquo;ve omitted the bodies of the functions for brevity). Note that this won&amp;rsquo;t compile until we modify &lt;em&gt;src/main.rs&lt;/em&gt; in Listing 12-14.</source>
          <target state="translated">Содержимое &lt;em&gt;src / lib.rs&lt;/em&gt; должно иметь сигнатуры, показанные в листинге 12-13 (мы для краткости опускали тела функций). Обратите внимание, что это не будет компилироваться, пока мы не &lt;em&gt;изменим src / main.rs&lt;/em&gt; в листинге 12-14.</target>
        </trans-unit>
        <trans-unit id="4fb4cd20ff2b04a7f8f088847ce2546308d2b8ce" translate="yes" xml:space="preserve">
          <source>The contents of the &lt;em&gt;src/lib.rs&lt;/em&gt; file in your &lt;code&gt;adder&lt;/code&gt; library should look like Listing 11-1.</source>
          <target state="translated">Содержимое файла &lt;em&gt;src / lib.rs&lt;/em&gt; в вашей библиотеке &lt;code&gt;adder&lt;/code&gt; должно выглядеть как Листинг 11-1.</target>
        </trans-unit>
        <trans-unit id="1735f7c56c57e86fb0b029da9024a55f63cc6d92" translate="yes" xml:space="preserve">
          <source>The contents of the repetition must be able to follow whatever comes before, and whatever comes after must be able to follow the contents of the repetition.</source>
          <target state="translated">Содержание повторения должно быть в состоянии следовать тому,что приходит до,и тому,что приходит после,должно быть в состоянии следовать содержанию повторения.</target>
        </trans-unit>
        <trans-unit id="33e5fb5d650df50a2e77352564f0bccccceac217" translate="yes" xml:space="preserve">
          <source>The contents of the returned &lt;a href=&quot;../raw/struct.stat&quot;&gt;&lt;code&gt;stat&lt;/code&gt;&lt;/a&gt; are &lt;strong&gt;not&lt;/strong&gt; consistent across Unix platforms. The &lt;code&gt;os::unix::fs::MetadataExt&lt;/code&gt; trait contains the cross-Unix abstractions contained within the raw stat.</source>
          <target state="translated">Содержимое возвращенного &lt;a href=&quot;../raw/struct.stat&quot;&gt; &lt;code&gt;stat&lt;/code&gt; &lt;/a&gt; являются &lt;strong&gt;не&lt;/strong&gt; последовательно через Unix платформах. &lt;code&gt;os::unix::fs::MetadataExt&lt;/code&gt; признак содержит абстракции кросс-Unix , содержащихся в сыром стат.</target>
        </trans-unit>
        <trans-unit id="0770383d0616ee4e47049d055237250b7b2bfaef" translate="yes" xml:space="preserve">
          <source>The conversion allocates on the heap and moves &lt;code&gt;t&lt;/code&gt; from the stack into it.</source>
          <target state="translated">Преобразование выделяется в куче и перемещает &lt;code&gt;t&lt;/code&gt; из стека в нее.</target>
        </trans-unit>
        <trans-unit id="66e8c9afb284902c1e321d76aa570359994fd792" translate="yes" xml:space="preserve">
          <source>The conversion consumes the &lt;a href=&quot;../ffi/struct.cstring&quot;&gt;&lt;code&gt;CString&lt;/code&gt;&lt;/a&gt;, and removes the terminating NUL byte.</source>
          <target state="translated">Преобразование потребляет &lt;a href=&quot;../ffi/struct.cstring&quot;&gt; &lt;code&gt;CString&lt;/code&gt; &lt;/a&gt; и удаляет завершающий байт NUL.</target>
        </trans-unit>
        <trans-unit id="b49f9ee7f1f30037339c1daa1d1e1cd395843299" translate="yes" xml:space="preserve">
          <source>The conversion consumes the &lt;a href=&quot;struct.cstring&quot;&gt;&lt;code&gt;CString&lt;/code&gt;&lt;/a&gt;, and removes the terminating NUL byte.</source>
          <target state="translated">Преобразование потребляет &lt;a href=&quot;struct.cstring&quot;&gt; &lt;code&gt;CString&lt;/code&gt; &lt;/a&gt; и удаляет завершающий байт NUL.</target>
        </trans-unit>
        <trans-unit id="9ff60369ad0f3cbf8d85443d93a8bb4f7f1f7686" translate="yes" xml:space="preserve">
          <source>The conversion copies the data, and includes an allocation on the heap.</source>
          <target state="translated">Преобразование копирует данные и включает в себя распределение по куче.</target>
        </trans-unit>
        <trans-unit id="cbdea02b60597ccd54b5d9dbad9b3681336b3420" translate="yes" xml:space="preserve">
          <source>The core method of future, &lt;code&gt;poll&lt;/code&gt;, &lt;em&gt;attempts&lt;/em&gt; to resolve the future into a final value. This method does not block if the value is not ready. Instead, the current task is scheduled to be woken up when it's possible to make further progress by &lt;code&gt;poll&lt;/code&gt;ing again. The &lt;code&gt;context&lt;/code&gt; passed to the &lt;code&gt;poll&lt;/code&gt; method can provide a &lt;a href=&quot;../task/struct.waker&quot;&gt;&lt;code&gt;Waker&lt;/code&gt;&lt;/a&gt;, which is a handle for waking up the current task.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="af0586e1698754134d6653d1c35d55045868b007" translate="yes" xml:space="preserve">
          <source>The core method of future, &lt;code&gt;poll&lt;/code&gt;, &lt;em&gt;attempts&lt;/em&gt; to resolve the future into a final value. This method does not block if the value is not ready. Instead, the current task is scheduled to be woken up when it's possible to make further progress by &lt;code&gt;poll&lt;/code&gt;ing again. The &lt;code&gt;context&lt;/code&gt; passed to the &lt;code&gt;poll&lt;/code&gt; method can provide a &lt;code&gt;Waker&lt;/code&gt;, which is a handle for waking up the current task.</source>
          <target state="translated">Основной метод будущего - &lt;code&gt;poll&lt;/code&gt; - &lt;em&gt;пытается&lt;/em&gt; преобразовать будущее в окончательную ценность. Этот метод не блокируется, если значение не готово. Вместо этого планируется разбудить текущую задачу, когда можно будет добиться дальнейшего прогресса путем повторного &lt;code&gt;poll&lt;/code&gt; . &lt;code&gt;context&lt;/code&gt; передается в &lt;code&gt;poll&lt;/code&gt; метод может обеспечить &lt;code&gt;Waker&lt;/code&gt; , который является ручкой для пробуждения текущей задачи.</target>
        </trans-unit>
        <trans-unit id="7cb53e3d2cc08f8c1b0d6306a44e9e0ab47f9511" translate="yes" xml:space="preserve">
          <source>The core of the error states that there are &lt;em&gt;mismatched types&lt;/em&gt;. Rust has a strong, static type system. However, it also has type inference. When we wrote &lt;code&gt;let mut guess = String::new()&lt;/code&gt;, Rust was able to infer that &lt;code&gt;guess&lt;/code&gt; should be a &lt;code&gt;String&lt;/code&gt; and didn&amp;rsquo;t make us write the type. The &lt;code&gt;secret_number&lt;/code&gt;, on the other hand, is a number type. A few number types can have a value between 1 and 100: &lt;code&gt;i32&lt;/code&gt;, a 32-bit number; &lt;code&gt;u32&lt;/code&gt;, an unsigned 32-bit number; &lt;code&gt;i64&lt;/code&gt;, a 64-bit number; as well as others. Rust defaults to an &lt;code&gt;i32&lt;/code&gt;, which is the type of &lt;code&gt;secret_number&lt;/code&gt; unless you add type information elsewhere that would cause Rust to infer a different numerical type. The reason for the error is that Rust cannot compare a string and a number type.</source>
          <target state="translated">Суть ошибки заключается в том, что существуют &lt;em&gt;несовпадающие типы&lt;/em&gt; . Rust имеет сильную статическую систему типов. Однако он также имеет вывод типа. Когда мы написали &lt;code&gt;let mut guess = String::new()&lt;/code&gt; , Rust смог сделать вывод, что это &lt;code&gt;guess&lt;/code&gt; должно быть &lt;code&gt;String&lt;/code&gt; , и не заставил нас написать тип. С другой стороны, &lt;code&gt;secret_number&lt;/code&gt; - это числовой тип. Некоторые &lt;code&gt;i32&lt;/code&gt; типы могут иметь значение от 1 до 100: i32 , 32-битное число; &lt;code&gt;u32&lt;/code&gt; , 32-битное число без знака; &lt;code&gt;i64&lt;/code&gt; , 64-битное число; а также другие. По умолчанию в Rust используется &lt;code&gt;i32&lt;/code&gt; , который является типом &lt;code&gt;secret_number&lt;/code&gt; .если вы не добавите информацию о типе где-либо еще, что заставит Rust вывести другой числовой тип. Причина ошибки в том, что Rust не может сравнивать строковый и числовой типы.</target>
        </trans-unit>
        <trans-unit id="ddff64ad7c369ce0737f5b8b0b3f4b7511787cca" translate="yes" xml:space="preserve">
          <source>The core primitive for interior mutability in Rust.</source>
          <target state="translated">Ядро примитива для внутренней мутации в Ржавчине.</target>
        </trans-unit>
        <trans-unit id="e23a80c74457fb7f3e04241567981840f6b6a5f0" translate="yes" xml:space="preserve">
          <source>The corresponding definitions are in &lt;code&gt;compiler/rustc_codegen_llvm/src/intrinsic.rs&lt;/code&gt;. The corresponding const implementations are in &lt;code&gt;compiler/rustc_mir/src/interpret/intrinsics.rs&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="159b3bf04af466ed5bc13962fe870a560dd18283" translate="yes" xml:space="preserve">
          <source>The corresponding definitions are in &lt;code&gt;librustc_codegen_llvm/intrinsic.rs&lt;/code&gt;.</source>
          <target state="translated">Соответствующие определения находятся в &lt;code&gt;librustc_codegen_llvm/intrinsic.rs&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="46698ed84aa8c683839a27c0dd70bde9fa62d21c" translate="yes" xml:space="preserve">
          <source>The counts are not affected in any way and the &lt;code&gt;Arc&lt;/code&gt; is not consumed. The pointer is valid for as long as there are strong counts in the &lt;code&gt;Arc&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="77f706694dca621192d20fdc480b2fbc8fb70f49" translate="yes" xml:space="preserve">
          <source>The counts are not affected in any way and the &lt;code&gt;Rc&lt;/code&gt; is not consumed. The pointer is valid for as long there are strong counts in the &lt;code&gt;Rc&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5d69c16c8fa846f1af610002036c48591d43f28f" translate="yes" xml:space="preserve">
          <source>The crate name must not be empty, and must only contain &lt;a href=&quot;../std/primitive.char#method.is_alphanumeric&quot;&gt;Unicode alphanumeric&lt;/a&gt; or &lt;code&gt;-&lt;/code&gt; (U+002D) characters.</source>
          <target state="translated">Имя ящика не должно быть пустым и должно содержать только &lt;a href=&quot;../std/primitive.char#method.is_alphanumeric&quot;&gt;буквенно-цифровые символы Unicode&lt;/a&gt; или символы &lt;code&gt;-&lt;/code&gt; (U + 002D).</target>
        </trans-unit>
        <trans-unit id="be4dd5125e77acafd163c79956b21bce0b41caf8" translate="yes" xml:space="preserve">
          <source>The created map has the default initial capacity.</source>
          <target state="translated">Созданная карта имеет начальную емкость по умолчанию.</target>
        </trans-unit>
        <trans-unit id="a9c04b6351b379cccf29eab61f8204218529d934" translate="yes" xml:space="preserve">
          <source>The current algorithm is an adaptive, iterative merge sort inspired by &lt;a href=&quot;https://en.wikipedia.org/wiki/Timsort&quot;&gt;timsort&lt;/a&gt;. It is designed to be very fast in cases where the slice is nearly sorted, or consists of two or more sorted sequences concatenated one after another.</source>
          <target state="translated">Текущий алгоритм представляет собой адаптивную итеративную сортировку слиянием, вдохновленную &lt;a href=&quot;https://en.wikipedia.org/wiki/Timsort&quot;&gt;timsort&lt;/a&gt; . Он разработан, чтобы быть очень быстрым в случаях, когда фрагмент почти отсортирован или состоит из двух или более отсортированных последовательностей, соединенных друг за другом.</target>
        </trans-unit>
        <trans-unit id="bf4d84cfe0f7a72eb4a521a3a9fe9d6ec790d19e" translate="yes" xml:space="preserve">
          <source>The current algorithm is based on &lt;a href=&quot;https://github.com/orlp/pdqsort&quot;&gt;pattern-defeating quicksort&lt;/a&gt; by Orson Peters, which combines the fast average case of randomized quicksort with the fast worst case of heapsort, while achieving linear time on slices with certain patterns. It uses some randomization to avoid degenerate cases, but with a fixed seed to always provide deterministic behavior.</source>
          <target state="translated">Текущий алгоритм основан на &lt;a href=&quot;https://github.com/orlp/pdqsort&quot;&gt;быстрой сортировке&lt;/a&gt; Орсона Петерса с уничтожением шаблонов, которая сочетает в себе быстрый средний случай рандомизированной быстрой сортировки с наихудшим быстрым случаем динамической сортировки при достижении линейного времени на срезах с определенными шаблонами. Он использует некоторую рандомизацию, чтобы избежать вырожденных случаев, но с фиксированным начальным значением, чтобы всегда обеспечивать детерминированное поведение.</target>
        </trans-unit>
        <trans-unit id="17185ac0ce099c141b9827d28f04ee4d12e294f8" translate="yes" xml:space="preserve">
          <source>The current algorithm is based on the quickselect portion of the same quicksort algorithm used for &lt;a href=&quot;#method.sort_unstable&quot;&gt;&lt;code&gt;sort_unstable&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Текущий алгоритм основан на части быстрого выбора того же алгоритма быстрой сортировки, который используется для &lt;a href=&quot;#method.sort_unstable&quot;&gt; &lt;code&gt;sort_unstable&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="593e3fc1b65f7b6d06f9c45167b067a1a762655b" translate="yes" xml:space="preserve">
          <source>The current file cursor is not affected by this function.</source>
          <target state="translated">Данная функция не влияет на курсор текущего файла.</target>
        </trans-unit>
        <trans-unit id="b3777ab23f3b1144c9a96d550ee493d6bc6e2d44" translate="yes" xml:space="preserve">
          <source>The current implementation uses the same infrastructure as compiler diagnostics and debuginfo, but this is not guaranteed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3346ba5eca8038cde57805738abeaa90cd6a63c6" translate="yes" xml:space="preserve">
          <source>The current module path can be thought of as the hierarchy of modules leading back up to the crate root. The first component of the path returned is the name of the crate currently being compiled.</source>
          <target state="translated">Текущий путь к модулю можно рассматривать как иерархию модулей,ведущую обратно к корню ящика.Первым компонентом возвращаемого пути является имя компилируемого в данный момент ящика.</target>
        </trans-unit>
        <trans-unit id="bdf915fa340c78bb10eee5926542917da6f9a74d" translate="yes" xml:space="preserve">
          <source>The current process does not have the permission rights to access &lt;code&gt;from&lt;/code&gt; or write &lt;code&gt;to&lt;/code&gt;.</source>
          <target state="translated">Текущий процесс не имеет право разрешения на доступ &lt;code&gt;from&lt;/code&gt; или записи &lt;code&gt;to&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1b9c6f166ff606296d138016ea8392f66f7ed63a" translate="yes" xml:space="preserve">
          <source>The current status of a backtrace, indicating whether it was captured or whether it is empty for some other reason.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aa1cdfe5525c9cd270fc9b5826bff19009fb273e" translate="yes" xml:space="preserve">
          <source>The current version of the prelude (version 1) lives in &lt;a href=&quot;v1/index&quot;&gt;&lt;code&gt;std::prelude::v1&lt;/code&gt;&lt;/a&gt;, and re-exports the following.</source>
          <target state="translated">Текущая версия prelude (версия 1) находится в &lt;a href=&quot;v1/index&quot;&gt; &lt;code&gt;std::prelude::v1&lt;/code&gt; &lt;/a&gt; и повторно экспортирует следующее.</target>
        </trans-unit>
        <trans-unit id="912528c0cfbd7646c08850f1e407245a6bf7145e" translate="yes" xml:space="preserve">
          <source>The cursor is pointing to the &quot;ghost&quot; non-element if the list is empty.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b9ad03e9a3edaaa56118f6fc3f2871f3d642b3c0" translate="yes" xml:space="preserve">
          <source>The data could not be sent on the &lt;a href=&quot;fn.sync_channel&quot;&gt;&lt;code&gt;sync_channel&lt;/code&gt;&lt;/a&gt; because it would require that the callee block to send the data.</source>
          <target state="translated">Данные не могут быть отправлены по &lt;a href=&quot;fn.sync_channel&quot;&gt; &lt;code&gt;sync_channel&lt;/code&gt; ,&lt;/a&gt; потому что это потребует, чтобы вызываемый блок отправлял данные.</target>
        </trans-unit>
        <trans-unit id="caac8e332d6bed98dbe6a446c232bbf7ded49130" translate="yes" xml:space="preserve">
          <source>The data members that this trait exposes correspond to the members of the &lt;a href=&quot;https://docs.microsoft.com/en-us/windows/win32/api/fileapi/ns-fileapi-by_handle_file_information&quot;&gt;&lt;code&gt;BY_HANDLE_FILE_INFORMATION&lt;/code&gt;&lt;/a&gt; structure.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="113312da9f41c00330f3f6a2627f87633cf51181" translate="yes" xml:space="preserve">
          <source>The data members that this trait exposes correspond to the members of the &lt;a href=&quot;https://msdn.microsoft.com/en-us/library/windows/desktop/aa363788.aspx&quot;&gt;&lt;code&gt;BY_HANDLE_FILE_INFORMATION&lt;/code&gt;&lt;/a&gt; structure.</source>
          <target state="translated">Члены данных, которые предоставляет эта характеристика, соответствуют членам структуры &lt;a href=&quot;https://msdn.microsoft.com/en-us/library/windows/desktop/aa363788.aspx&quot;&gt; &lt;code&gt;BY_HANDLE_FILE_INFORMATION&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="c9421f388aa0f6bda7993e70317be2c01ffcdb74" translate="yes" xml:space="preserve">
          <source>The data protected by the mutex can be accessed through this guard via its &lt;a href=&quot;../ops/trait.deref&quot;&gt;&lt;code&gt;Deref&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../ops/trait.derefmut&quot;&gt;&lt;code&gt;DerefMut&lt;/code&gt;&lt;/a&gt; implementations.</source>
          <target state="translated">Доступ к данным, защищенным мьютексом, можно получить через эту &lt;a href=&quot;../ops/trait.deref&quot;&gt; &lt;code&gt;Deref&lt;/code&gt; &lt;/a&gt; через его реализации Deref и &lt;a href=&quot;../ops/trait.derefmut&quot;&gt; &lt;code&gt;DerefMut&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="a8b69bce2135d478ffa031311b309f0dc7de4fc2" translate="yes" xml:space="preserve">
          <source>The data that the process wrote to stderr.</source>
          <target state="translated">Данные,которые процесс записал в stderr.</target>
        </trans-unit>
        <trans-unit id="5ad3bfb524d0ca744c539d652ec4054ab0b9dc35" translate="yes" xml:space="preserve">
          <source>The data that the process wrote to stdout.</source>
          <target state="translated">Данные,которые процесс записал в stdout.</target>
        </trans-unit>
        <trans-unit id="f0f62565562b0bbca1d9e555b1c167c8869cc294" translate="yes" xml:space="preserve">
          <source>The declaration of &lt;code&gt;another_function&lt;/code&gt; has one parameter named &lt;code&gt;x&lt;/code&gt;. The type of &lt;code&gt;x&lt;/code&gt; is specified as &lt;code&gt;i32&lt;/code&gt;. When &lt;code&gt;5&lt;/code&gt; is passed to &lt;code&gt;another_function&lt;/code&gt;, the &lt;code&gt;println!&lt;/code&gt; macro puts &lt;code&gt;5&lt;/code&gt; where the pair of curly brackets were in the format string.</source>
          <target state="translated">Объявление &lt;code&gt;another_function&lt;/code&gt; имеет один параметр с именем &lt;code&gt;x&lt;/code&gt; . Тип &lt;code&gt;x&lt;/code&gt; указан как &lt;code&gt;i32&lt;/code&gt; . Когда &lt;code&gt;5&lt;/code&gt; передается в &lt;code&gt;another_function&lt;/code&gt; , &lt;code&gt;println!&lt;/code&gt; макрос помещает &lt;code&gt;5&lt;/code&gt; там, где была пара фигурных скобок в строке формата.</target>
        </trans-unit>
        <trans-unit id="f3e2b77707e4042bb7d326cf080f9fda22d6fd02" translate="yes" xml:space="preserve">
          <source>The default &lt;a href=&quot;#fillalignment&quot;&gt;fill/alignment&lt;/a&gt; for non-numerics is a space and left-aligned. The default for numeric formatters is also a space character but with right-alignment. If the &lt;code&gt;0&lt;/code&gt; flag (see below) is specified for numerics, then the implicit fill character is &lt;code&gt;0&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6a4c3f3e9f4bf073db3de78ffdfd8f78a08679d0" translate="yes" xml:space="preserve">
          <source>The default &lt;a href=&quot;#fillalignment&quot;&gt;fill/alignment&lt;/a&gt; for non-numerics is a space and left-aligned. The defaults for numeric formatters is also a space but with right-alignment. If the &lt;code&gt;0&lt;/code&gt; flag is specified for numerics, then the implicit fill character is &lt;code&gt;0&lt;/code&gt;.</source>
          <target state="translated">Для нечисловых значений &lt;a href=&quot;#fillalignment&quot;&gt;заливка / выравнивание&lt;/a&gt; по умолчанию - это пробел с выравниванием по левому краю. По умолчанию для числовых форматеров также используется пробел, но с выравниванием по правому краю. Если для числовых значений указан флаг &lt;code&gt;0&lt;/code&gt; , то неявный символ заполнения равен &lt;code&gt;0&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e71d3da519e1259cb4d0ff052a4082fe544273e4" translate="yes" xml:space="preserve">
          <source>The default &lt;a href=&quot;../../hash/trait.hasher&quot;&gt;&lt;code&gt;Hasher&lt;/code&gt;&lt;/a&gt; used by &lt;a href=&quot;struct.randomstate&quot;&gt;&lt;code&gt;RandomState&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">По умолчанию &lt;a href=&quot;../../hash/trait.hasher&quot;&gt; &lt;code&gt;Hasher&lt;/code&gt; &lt;/a&gt; используется &lt;a href=&quot;struct.randomstate&quot;&gt; &lt;code&gt;RandomState&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="81a33ca44ce969a6a0433a7aff9f0392c46b2e52" translate="yes" xml:space="preserve">
          <source>The default behavior of this function is to print a message to standard error and abort the process. It can be replaced with &lt;a href=&quot;fn.set_alloc_error_hook&quot;&gt;&lt;code&gt;set_alloc_error_hook&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;fn.take_alloc_error_hook&quot;&gt;&lt;code&gt;take_alloc_error_hook&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">По умолчанию эта функция выводит сообщение об ошибке и прерывает процесс. Его можно заменить на &lt;a href=&quot;fn.set_alloc_error_hook&quot;&gt; &lt;code&gt;set_alloc_error_hook&lt;/code&gt; &lt;/a&gt; и &lt;a href=&quot;fn.take_alloc_error_hook&quot;&gt; &lt;code&gt;take_alloc_error_hook&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="1fe48c8009742af8ee8a3efe0842a923bc01bf9d" translate="yes" xml:space="preserve">
          <source>The default generic type in this code is within the &lt;code&gt;Add&lt;/code&gt; trait. Here is its definition:</source>
          <target state="translated">Универсальный тип по умолчанию в этом коде находится внутри признака &lt;code&gt;Add&lt;/code&gt; . Вот его определение:</target>
        </trans-unit>
        <trans-unit id="697b922437171b9fe1e8c84494c4b161d6fd03d3" translate="yes" xml:space="preserve">
          <source>The default hashing algorithm is currently SipHash 1-3, though this is subject to change at any point in the future. While its performance is very competitive for medium sized keys, other hashing algorithms will outperform it for small keys such as integers as well as large keys such as long strings, though those algorithms will typically &lt;em&gt;not&lt;/em&gt; protect against attacks such as HashDoS.</source>
          <target state="translated">Алгоритм хеширования по умолчанию в настоящее время SipHash 1-3, хотя он может быть изменен в любой момент в будущем. Хотя его производительность очень конкурентоспособна для ключей среднего размера, другие алгоритмы хеширования будут превосходить его для небольших ключей, таких как целые числа, а также для больших ключей, таких как длинные строки, хотя эти алгоритмы обычно &lt;em&gt;не&lt;/em&gt; защищают от атак, таких как HashDoS.</target>
        </trans-unit>
        <trans-unit id="80e587164750efd5907b562bcc2c0ec8621ca1dc" translate="yes" xml:space="preserve">
          <source>The default implementation calls &lt;a href=&quot;trait.write#tymethod.write&quot;&gt;&lt;code&gt;write&lt;/code&gt;&lt;/a&gt; with either the first nonempty buffer provided, or an empty one if none exists.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="73b38e69c912c9cd2a1d35da9b4cb8282e56833f" translate="yes" xml:space="preserve">
          <source>The default implementation calls &lt;code&gt;read&lt;/code&gt; with either the first nonempty buffer provided, or an empty one if none exists.</source>
          <target state="translated">Реализация по умолчанию вызывает &lt;code&gt;read&lt;/code&gt; либо с первым предоставленным непустым буфером, либо с пустым, если его нет.</target>
        </trans-unit>
        <trans-unit id="2e19ee8802e471056a9e27a45d3086893e133973" translate="yes" xml:space="preserve">
          <source>The default implementation calls &lt;code&gt;write&lt;/code&gt; with either the first nonempty buffer provided, or an empty one if none exists.</source>
          <target state="translated">Реализация по умолчанию вызывает &lt;code&gt;write&lt;/code&gt; либо с первым предоставленным непустым буфером, либо с пустым, если его нет.</target>
        </trans-unit>
        <trans-unit id="917b792910290b9f104f9e9bb1c1c376f6e62a1b" translate="yes" xml:space="preserve">
          <source>The default implementation does nothing.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cda4f183b9995aecf4b0037179612271bde1f6bd" translate="yes" xml:space="preserve">
          <source>The default implementation returns &lt;code&gt;(0, &lt;/code&gt;&lt;a href=&quot;../option/enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt;&lt;code&gt;)&lt;/code&gt; which is correct for any iterator.</source>
          <target state="translated">Реализация по умолчанию возвращает &lt;code&gt;(0, &lt;/code&gt; &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt; &lt;code&gt;None&lt;/code&gt; &lt;/a&gt; &lt;code&gt;)&lt;/code&gt; , что верно для любого итератора.</target>
        </trans-unit>
        <trans-unit id="e33ad58e76bb269caa1c45076544afb93bb1e40d" translate="yes" xml:space="preserve">
          <source>The default implementation returns &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="969fb25f2024192b2aecf3ee3a177be1b86acfb5" translate="yes" xml:space="preserve">
          <source>The default implementation returns an initializer which will zero buffers.</source>
          <target state="translated">Реализация по умолчанию возвращает инициализатор,который будет иметь нулевые буферы.</target>
        </trans-unit>
        <trans-unit id="bb3d803ebf5acd8c1abc49ce5f1cae9b36493095" translate="yes" xml:space="preserve">
          <source>The default implementations are returning &lt;code&gt;libc::EXIT_SUCCESS&lt;/code&gt; to indicate a successful execution. In case of a failure, &lt;code&gt;libc::EXIT_FAILURE&lt;/code&gt; is returned.</source>
          <target state="translated">Реализации по умолчанию возвращают &lt;code&gt;libc::EXIT_SUCCESS&lt;/code&gt; чтобы указать на успешное выполнение. В случае сбоя возвращается &lt;code&gt;libc::EXIT_FAILURE&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="31cdcfae6f2b31eff3f08e0d9f029eeb9ec7bee1" translate="yes" xml:space="preserve">
          <source>The default is chosen with a bias toward producing literals that are legal in a variety of languages, including C++11 and similar C-family languages. The exact rules are:</source>
          <target state="translated">По умолчанию выбирается с предубеждением к созданию литералов,легальных в различных языках,включая C++11 и аналогичные языки семейства C.Точные правила таковы:</target>
        </trans-unit>
        <trans-unit id="b02cae987658ffb74f03215f87762f2599f0c7eb" translate="yes" xml:space="preserve">
          <source>The default memory allocator provided by the operating system.</source>
          <target state="translated">Выделение памяти по умолчанию,предоставляемое операционной системой.</target>
        </trans-unit>
        <trans-unit id="1dd4678ade75055f3987aad761b36a01d2353c9f" translate="yes" xml:space="preserve">
          <source>The default stack size for spawned threads is 2 MiB, though this particular stack size is subject to change in the future. There are two ways to manually specify the stack size for spawned threads:</source>
          <target state="translated">По умолчанию размер стека для порожденных потоков составляет 2 Мб,хотя этот конкретный размер стека может измениться в будущем.Есть два способа вручную указать размер стека для порожденных потоков:</target>
        </trans-unit>
        <trans-unit id="0f91c7ab56b392b9e17d4e1e13452f2f412a7407" translate="yes" xml:space="preserve">
          <source>The definition for complex NTs deserves some justification. SEP_SET(M) defines the possibility that the separator could be a valid first token for M, which happens when there is a separator defined and the repeated fragment could be empty. ALPHA_SET(M) defines the possibility that the complex NT could be empty, meaning that M's valid first tokens are those of the following token-tree sequences &lt;code&gt;&amp;alpha;&lt;/code&gt;. This occurs when either &lt;code&gt;\*&lt;/code&gt; or &lt;code&gt;?&lt;/code&gt; is used, in which case there could be zero repetitions. In theory, this could also occur if &lt;code&gt;+&lt;/code&gt; was used with a potentially-empty repeating fragment, but this is forbidden by the third invariant.</source>
          <target state="translated">Определение сложных НТ заслуживает некоторого обоснования. SEP_SET (M) определяет возможность того, что разделитель может быть допустимым первым токеном для M, что происходит, когда определен разделитель и повторяющийся фрагмент может быть пустым. ALPHA_SET (M) определяет вероятность того, что сложный NT может быть пустым, что означает, что действительные первые токены M являются токенами следующих последовательностей дерева токенов &lt;code&gt;&amp;alpha;&lt;/code&gt; . Это происходит, когда либо &lt;code&gt;\*&lt;/code&gt; либо &lt;code&gt;?&lt;/code&gt; используется, и в этом случае может быть ноль повторов. Теоретически это может также произойти, если &lt;code&gt;+&lt;/code&gt; использовался с потенциально пустым повторяющимся фрагментом, но это запрещено третьим инвариантом.</target>
        </trans-unit>
        <trans-unit id="985a8049c57bbba61492d3048826a9b3471b56f7" translate="yes" xml:space="preserve">
          <source>The definition of &lt;code&gt;Config&lt;/code&gt;</source>
          <target state="translated">Определение &lt;code&gt;Config&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="830ab684e6b9340db4f9c07a73c12e27ccb95977" translate="yes" xml:space="preserve">
          <source>The dereference operator</source>
          <target state="translated">Оператор снятия с производства</target>
        </trans-unit>
        <trans-unit id="75ad44a3ef91af0a45f2841a370dda11b833e07f" translate="yes" xml:space="preserve">
          <source>The desired behavior of the &lt;code&gt;generate_workout&lt;/code&gt; function is to first check whether the user wants a low-intensity workout (indicated by a number less than 25) or a high-intensity workout (a number of 25 or greater).</source>
          <target state="translated">Желаемое поведение функции &lt;code&gt;generate_workout&lt;/code&gt; состоит в том, чтобы сначала проверить, хочет ли пользователь тренировку низкой интенсивности (обозначается числом меньше 25) или тренировкой высокой интенсивности (число 25 или больше).</target>
        </trans-unit>
        <trans-unit id="f11d06267e33f3ae0370e1b473dace96a1d49d65" translate="yes" xml:space="preserve">
          <source>The destructor of a type &lt;code&gt;T&lt;/code&gt; consists of:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="be2c8573e9de352b5e8e680cfa4b055e97512426" translate="yes" xml:space="preserve">
          <source>The destructor of a type consists of</source>
          <target state="translated">Деструктор типа состоит из</target>
        </trans-unit>
        <trans-unit id="c9c60944e1a21001c2063c93ac3b0f4cb46946e2" translate="yes" xml:space="preserve">
          <source>The destructor of the struct must not move structural fields out of its argument. This is the exact point that was raised in the &lt;a href=&quot;#drop-implementation&quot;&gt;previous section&lt;/a&gt;: &lt;code&gt;drop&lt;/code&gt; takes &lt;code&gt;&amp;amp;mut self&lt;/code&gt;, but the struct (and hence its fields) might have been pinned before. You have to guarantee that you do not move a field inside your &lt;a href=&quot;../ops/trait.drop#tymethod.drop&quot;&gt;&lt;code&gt;Drop&lt;/code&gt;&lt;/a&gt; implementation. In particular, as explained previously, this means that your struct must &lt;em&gt;not&lt;/em&gt; be &lt;code&gt;#[repr(packed)]&lt;/code&gt;. See that section for how to write &lt;a href=&quot;../ops/trait.drop#tymethod.drop&quot;&gt;&lt;code&gt;drop&lt;/code&gt;&lt;/a&gt; in a way that the compiler can help you not accidentally break pinning.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="30054f3bf420ad868745eedcb4cc73a1da34e82c" translate="yes" xml:space="preserve">
          <source>The destructor of the struct must not move structural fields out of its argument. This is the exact point that was raised in the &lt;a href=&quot;#drop-implementation&quot;&gt;previous section&lt;/a&gt;: &lt;code&gt;drop&lt;/code&gt; takes &lt;code&gt;&amp;amp;mut self&lt;/code&gt;, but the struct (and hence its fields) might have been pinned before. You have to guarantee that you do not move a field inside your &lt;code&gt;Drop&lt;/code&gt; implementation. In particular, as explained previously, this means that your struct must &lt;em&gt;not&lt;/em&gt; be &lt;code&gt;#[repr(packed)]&lt;/code&gt;. See that section for how to write &lt;code&gt;drop&lt;/code&gt; in a way that the compiler can help you not accidentally break pinning.</source>
          <target state="translated">Деструктор структуры не должен перемещать структурные поля из своего аргумента. Это точный момент, который был поднят в &lt;a href=&quot;#drop-implementation&quot;&gt;предыдущем разделе&lt;/a&gt; : &lt;code&gt;drop&lt;/code&gt; принимает &lt;code&gt;&amp;amp;mut self&lt;/code&gt; , но структура (и, следовательно, ее поля) могла быть закреплена раньше. Вы должны гарантировать, что не перемещаете поле внутри своей реализации &lt;code&gt;Drop&lt;/code&gt; . В частности, как объяснялось ранее, это означает, что ваша структура &lt;em&gt;не&lt;/em&gt; должна быть &lt;code&gt;#[repr(packed)]&lt;/code&gt; . В этом разделе рассказывается, как написать &lt;code&gt;drop&lt;/code&gt; , чтобы компилятор мог помочь вам случайно не нарушить закрепление.</target>
        </trans-unit>
        <trans-unit id="f85efc5c824a33e7773d4a9703af1abcf28610ef" translate="yes" xml:space="preserve">
          <source>The difference between 'the prelude' and these other preludes is that they are not automatically &lt;code&gt;use&lt;/code&gt;'d, and must be imported manually. This is still easier than importing all of their constituent components.</source>
          <target state="translated">Разница между прелюдией и другими прелюдиями в том, что они не &lt;code&gt;use&lt;/code&gt; автоматически d и должны быть импортированы вручную. Это все еще проще, чем импортировать все составляющие их компоненты.</target>
        </trans-unit>
        <trans-unit id="505a24f6c966bf30ebbdd0623555d0248f90c11b" translate="yes" xml:space="preserve">
          <source>The difference between &lt;a href=&quot;macro.unimplemented&quot;&gt;&lt;code&gt;unimplemented!&lt;/code&gt;&lt;/a&gt; and &lt;code&gt;todo!&lt;/code&gt; is that while &lt;code&gt;todo!&lt;/code&gt; conveys an intent of implementing the functionality later and the message is &quot;not yet implemented&quot;, &lt;code&gt;unimplemented!&lt;/code&gt; makes no such claims. Its message is &quot;not implemented&quot;. Also some IDEs will mark &lt;code&gt;todo!&lt;/code&gt;s.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="03297ced74ba958f935a37ee67580ef54eeb9a79" translate="yes" xml:space="preserve">
          <source>The difference between &lt;code&gt;unimplemented!&lt;/code&gt; and &lt;a href=&quot;macro.todo&quot;&gt;&lt;code&gt;todo!&lt;/code&gt;&lt;/a&gt; is that while &lt;code&gt;todo!&lt;/code&gt; conveys an intent of implementing the functionality later and the message is &quot;not yet implemented&quot;, &lt;code&gt;unimplemented!&lt;/code&gt; makes no such claims. Its message is &quot;not implemented&quot;. Also some IDEs will mark &lt;code&gt;todo!&lt;/code&gt;s.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3d53ebfe9f22c1eb14437a5afaa7bab7ac81b640" translate="yes" xml:space="preserve">
          <source>The difference is that when using generics, as in Listing 19-13, we must annotate the types in each implementation; because we can also implement &lt;code&gt;Iterator&amp;lt;String&amp;gt; for Counter&lt;/code&gt; or any other type, we could have multiple implementations of &lt;code&gt;Iterator&lt;/code&gt; for &lt;code&gt;Counter&lt;/code&gt;. In other words, when a trait has a generic parameter, it can be implemented for a type multiple times, changing the concrete types of the generic type parameters each time. When we use the &lt;code&gt;next&lt;/code&gt; method on &lt;code&gt;Counter&lt;/code&gt;, we would have to provide type annotations to indicate which implementation of &lt;code&gt;Iterator&lt;/code&gt; we want to use.</source>
          <target state="translated">Разница в том, что при использовании универсальных шаблонов, как в листинге 19-13, мы должны аннотировать типы в каждой реализации; поскольку мы также можем реализовать &lt;code&gt;Iterator&amp;lt;String&amp;gt; for Counter&lt;/code&gt; или любого другого типа, у нас может быть несколько реализаций &lt;code&gt;Iterator&lt;/code&gt; для &lt;code&gt;Counter&lt;/code&gt; . Другими словами, когда признак имеет универсальный параметр, он может быть реализован для типа несколько раз, каждый раз изменяя конкретные типы параметров универсального типа. Когда мы используем &lt;code&gt;next&lt;/code&gt; метод в &lt;code&gt;Counter&lt;/code&gt; , нам нужно будет предоставить аннотации типов, чтобы указать, какую реализацию &lt;code&gt;Iterator&lt;/code&gt; мы хотим использовать.</target>
        </trans-unit>
        <trans-unit id="5d4f5e1a47f10d66452650a5f161fd164ebd410d" translate="yes" xml:space="preserve">
          <source>The differences about paths and the &lt;code&gt;use&lt;/code&gt; keyword between the 2015 and 2018 editions can also be found in the &lt;a href=&quot;../reference/items/use-declarations&quot;&gt;Reference&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d9b61b2f901725762b56d16bf06bea0055df6804" translate="yes" xml:space="preserve">
          <source>The different behavior of files in the &lt;em&gt;tests&lt;/em&gt; directory is most noticeable when you have a set of helper functions that would be useful in multiple integration test files and you try to follow the steps in the &lt;a href=&quot;ch07-05-separating-modules-into-different-files&quot;&gt;&amp;ldquo;Separating Modules into Different Files&amp;rdquo;&lt;/a&gt; section of Chapter 7 to extract them into a common module. For example, if we create &lt;em&gt;tests/common.rs&lt;/em&gt; and place a function named &lt;code&gt;setup&lt;/code&gt; in it, we can add some code to &lt;code&gt;setup&lt;/code&gt; that we want to call from multiple test functions in multiple test files:</source>
          <target state="translated">Различное поведение файлов в каталоге &lt;em&gt;тестов&lt;/em&gt; наиболее заметно, когда у вас есть набор вспомогательных функций, которые могут быть полезны в нескольких файлах тестов интеграции, и вы пытаетесь выполнить шаги, описанные в разделе &lt;a href=&quot;ch07-05-separating-modules-into-different-files&quot;&gt;&amp;laquo;Разделение модулей на разные файлы&amp;raquo;&lt;/a&gt; главы 7, чтобы извлеките их в общий модуль. Например, если мы создадим &lt;em&gt;tests / common.rs&lt;/em&gt; и &lt;em&gt;поместим&lt;/em&gt; в него функцию с именем &lt;code&gt;setup&lt;/code&gt; , мы можем добавить в &lt;code&gt;setup&lt;/code&gt; код, который мы хотим вызвать из нескольких тестовых функций в нескольких тестовых файлах:</target>
        </trans-unit>
        <trans-unit id="d5be1c02c26fe5ef598a5696a274160d696e7977" translate="yes" xml:space="preserve">
          <source>The different meanings of &lt;code&gt;unsafe&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1fd895f49df6ac41f021206eb05bd5dfbc8e5ada" translate="yes" xml:space="preserve">
          <source>The directories and files used for loading external file modules can be influenced with the &lt;code&gt;path&lt;/code&gt; attribute.</source>
          <target state="translated">На каталоги и файлы, используемые для загрузки внешних файловых модулей, можно влиять с помощью атрибута &lt;code&gt;path&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1e92ecf8e1ea3e2a6e4c02654c525e112d825547" translate="yes" xml:space="preserve">
          <source>The directory isn't empty.</source>
          <target state="translated">Каталог не пуст.</target>
        </trans-unit>
        <trans-unit id="8e9718c5436468359091854f47e29ace6b258c73" translate="yes" xml:space="preserve">
          <source>The discriminant enum from the example &lt;a href=&quot;#reprc-enums-with-fields&quot;&gt;earlier&lt;/a&gt; then becomes:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5406bf9928b412a24605eecb2ec809ade9b2bfca" translate="yes" xml:space="preserve">
          <source>The discriminant of an enum variant may change if the enum definition changes. A discriminant of some variant will not change between compilations with the same compiler.</source>
          <target state="translated">Дискриминант варианта перечисления может измениться,если изменится определение перечисления.Дискриминант некоторого варианта не изменится между компиляциями с одним и тем же компилятором.</target>
        </trans-unit>
        <trans-unit id="e1e71495d678a5d4be21061931a65d8862bd4e7e" translate="yes" xml:space="preserve">
          <source>The distance being in bounds cannot rely on &quot;wrapping around&quot; the address space.</source>
          <target state="translated">Расстояние,находящееся в границах,не может полагаться на &quot;обертывание&quot; адресного пространства.</target>
        </trans-unit>
        <trans-unit id="6c785ac664fd8d2346ca1bb482fcd8b5593d6af3" translate="yes" xml:space="preserve">
          <source>The distance between the pointers, &lt;strong&gt;in bytes&lt;/strong&gt;, cannot overflow an &lt;code&gt;isize&lt;/code&gt;.</source>
          <target state="translated">Расстояние между указателями &lt;strong&gt;в байтах&lt;/strong&gt; не может &lt;code&gt;isize&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="bd1487c3b6f63cdfefd3896403e040d0a14037e5" translate="yes" xml:space="preserve">
          <source>The distance between the pointers, in bytes, must be an exact multiple of the size of &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">Расстояние между указателями, в байтах, должно быть точным кратным размером &lt;code&gt;T&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c85eee3f8fcb1e3d7acfa8c71113a8ed01e9b6ce" translate="yes" xml:space="preserve">
          <source>The division assignment operator &lt;code&gt;/=&lt;/code&gt;.</source>
          <target state="translated">Оператор присваивания деления &lt;code&gt;/=&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="fac0cbbb13a4ae4385140ac3ccea99961d57c224" translate="yes" xml:space="preserve">
          <source>The division operator &lt;code&gt;/&lt;/code&gt;.</source>
          <target state="translated">Оператор деления &lt;code&gt;/&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d4bae769945be3db52fcb8fef6b0f5ad9c54eef4" translate="yes" xml:space="preserve">
          <source>The documentation for this keyword is &lt;a href=&quot;https://github.com/rust-lang/rust/issues/34601&quot;&gt;not yet complete&lt;/a&gt;. Pull requests welcome!</source>
          <target state="translated">Документация по этому ключевому слову еще &lt;a href=&quot;https://github.com/rust-lang/rust/issues/34601&quot;&gt;не завершена&lt;/a&gt; . Запросы на вытягивание приветствуются!</target>
        </trans-unit>
        <trans-unit id="7092af2bcd91c441c2dfc4c8d572a11dfce60e91" translate="yes" xml:space="preserve">
          <source>The double colon (&lt;code&gt;::&lt;/code&gt;) is an operator that allows us to namespace this particular &lt;code&gt;from&lt;/code&gt; function under the &lt;code&gt;String&lt;/code&gt; type rather than using some sort of name like &lt;code&gt;string_from&lt;/code&gt;. We&amp;rsquo;ll discuss this syntax more in the &lt;a href=&quot;ch05-03-method-syntax#method-syntax&quot;&gt;&amp;ldquo;Method Syntax&amp;rdquo;&lt;/a&gt; section of Chapter 5 and when we talk about namespacing with modules in &lt;a href=&quot;ch07-03-paths-for-referring-to-an-item-in-the-module-tree&quot;&gt;&amp;ldquo;Paths for Referring to an Item in the Module Tree&amp;rdquo;&lt;/a&gt; in Chapter 7.</source>
          <target state="translated">Двойное двоеточие ( &lt;code&gt;::&lt;/code&gt; ) является оператором , который позволяет это пространство имен частности &lt;code&gt;from&lt;/code&gt; функции под &lt;code&gt;String&lt;/code&gt; типа , а не с помощью какой - то имя , как &lt;code&gt;string_from&lt;/code&gt; . Мы обсудим этот синтаксис более подробно в разделе &lt;a href=&quot;ch05-03-method-syntax#method-syntax&quot;&gt;&amp;laquo;Синтаксис метода&amp;raquo;&lt;/a&gt; главы 5 и когда мы будем говорить о пространстве имен с модулями в разделе &lt;a href=&quot;ch07-03-paths-for-referring-to-an-item-in-the-module-tree&quot;&gt;&amp;laquo;Пути для ссылки на элемент в дереве модулей&amp;raquo;&lt;/a&gt; в главе 7.</target>
        </trans-unit>
        <trans-unit id="27b2d1743e157ab144583c8c6b85ea9ad0092f0b" translate="yes" xml:space="preserve">
          <source>The downside of using &lt;code&gt;if let&lt;/code&gt; expressions is that the compiler doesn&amp;rsquo;t check exhaustiveness, whereas with &lt;code&gt;match&lt;/code&gt; expressions it does. If we omitted the last &lt;code&gt;else&lt;/code&gt; block and therefore missed handling some cases, the compiler would not alert us to the possible logic bug.</source>
          <target state="translated">Недостатком использования , &lt;code&gt;if let&lt;/code&gt; выражений является то , что компилятор не проверяет полноту, в то время как с &lt;code&gt;match&lt;/code&gt; выражениями он делает. Если мы пропустили последний блок &lt;code&gt;else&lt;/code&gt; и, следовательно, пропустили обработку некоторых случаев, компилятор не предупредит нас о возможной логической ошибке.</target>
        </trans-unit>
        <trans-unit id="e387e6a833f24807236bb7fd7266c18e39a1df6d" translate="yes" xml:space="preserve">
          <source>The downside of using this technique is that &lt;code&gt;Wrapper&lt;/code&gt; is a new type, so it doesn&amp;rsquo;t have the methods of the value it&amp;rsquo;s holding. We would have to implement all the methods of &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; directly on &lt;code&gt;Wrapper&lt;/code&gt; such that the methods delegate to &lt;code&gt;self.0&lt;/code&gt;, which would allow us to treat &lt;code&gt;Wrapper&lt;/code&gt; exactly like a &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt;. If we wanted the new type to have every method the inner type has, implementing the &lt;code&gt;Deref&lt;/code&gt; trait (discussed in Chapter 15 in the &lt;a href=&quot;ch15-02-deref#treating-smart-pointers-like-regular-references-with-the-deref-trait&quot;&gt;&amp;ldquo;Treating Smart Pointers Like Regular References with the &lt;code&gt;Deref&lt;/code&gt; Trait&amp;rdquo;&lt;/a&gt; section) on the &lt;code&gt;Wrapper&lt;/code&gt; to return the inner type would be a solution. If we don&amp;rsquo;t want the &lt;code&gt;Wrapper&lt;/code&gt; type to have all the methods of the inner type&amp;mdash;for example, to restrict the &lt;code&gt;Wrapper&lt;/code&gt; type&amp;rsquo;s behavior&amp;mdash;we would have to implement just the methods we do want manually.</source>
          <target state="translated">Обратной стороной использования этого метода является то, что &lt;code&gt;Wrapper&lt;/code&gt; - это новый тип, поэтому у него нет методов хранимого в нем значения. Нам пришлось бы реализовать все методы &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; непосредственно в &lt;code&gt;Wrapper&lt;/code&gt; , чтобы методы делегировали &lt;code&gt;self.0&lt;/code&gt; , что позволило бы нам обращаться с &lt;code&gt;Wrapper&lt;/code&gt; точно так же, как с &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; . Если бы мы хотели, чтобы новый тип имел все методы, которые есть у внутреннего типа, реализуя &lt;code&gt;Deref&lt;/code&gt; (обсуждаемый в главе 15 в разделе &lt;a href=&quot;ch15-02-deref#treating-smart-pointers-like-regular-references-with-the-deref-trait&quot;&gt;&amp;laquo;Обработка умных указателей как обычных ссылок с помощью &lt;code&gt;Deref&lt;/code&gt; &amp;raquo;&lt;/a&gt; ) в &lt;code&gt;Wrapper&lt;/code&gt; возвращение внутреннего типа было бы решением. Если мы не хотим, чтобы тип &lt;code&gt;Wrapper&lt;/code&gt; имел все методы внутреннего типа - например, для ограничения поведения типа &lt;code&gt;Wrapper&lt;/code&gt; - нам пришлось бы реализовать вручную только те методы, которые нам нужны.</target>
        </trans-unit>
        <trans-unit id="0e7aa88c59ccdb8f5ae43f1abe07297a4d7ace58" translate="yes" xml:space="preserve">
          <source>The downside to implementing a macro instead of a function is that macro definitions are more complex than function definitions because you&amp;rsquo;re writing Rust code that writes Rust code. Due to this indirection, macro definitions are generally more difficult to read, understand, and maintain than function definitions.</source>
          <target state="translated">Обратной стороной реализации макроса вместо функции является то, что определения макросов более сложны, чем определения функций, потому что вы пишете код Rust, который пишет код Rust. Из-за этого косвенного обращения определения макросов, как правило, труднее читать, понимать и поддерживать, чем определения функций.</target>
        </trans-unit>
        <trans-unit id="719fc8d49d59015d6dffe7ccc55e5816d1966b0e" translate="yes" xml:space="preserve">
          <source>The duration of one microsecond.</source>
          <target state="translated">Продолжительностью в одну микросекунду.</target>
        </trans-unit>
        <trans-unit id="e68beeeb11183a3ff18abb9e6896356e66b6200f" translate="yes" xml:space="preserve">
          <source>The duration of one millisecond.</source>
          <target state="translated">Продолжительностью в одну миллисекунду.</target>
        </trans-unit>
        <trans-unit id="e9d186359c1c80de39171fea4281a767f86db9c5" translate="yes" xml:space="preserve">
          <source>The duration of one nanosecond.</source>
          <target state="translated">Длительность в одну наносекунду.</target>
        </trans-unit>
        <trans-unit id="926b58a37c99c224d9cf0ad023e9e79f2bae5af3" translate="yes" xml:space="preserve">
          <source>The duration of one second.</source>
          <target state="translated">Продолжительность одной секунды.</target>
        </trans-unit>
        <trans-unit id="51e82336197f20c9062a20d4490259f940ada0fe" translate="yes" xml:space="preserve">
          <source>The easiest fix is to rewrite your closure into a top-level function, or into a method. In some cases, you may also be able to have your closure call itself by capturing a &lt;code&gt;&amp;amp;Fn()&lt;/code&gt; object or &lt;code&gt;fn()&lt;/code&gt; pointer that refers to itself. That is permitting, since the closure would be invoking itself via a virtual call, and hence does not directly reference its own &lt;em&gt;type&lt;/em&gt;.</source>
          <target state="translated">Самое простое решение - переписать замыкание в функцию верхнего уровня или в метод. В некоторых случаях вы также можете иметь сам вызов закрытия, захватив объект &lt;code&gt;&amp;amp;Fn()&lt;/code&gt; или указатель &lt;code&gt;fn()&lt;/code&gt; который ссылается на себя. Это допустимо, так как замыкание будет вызываться через виртуальный вызов и, следовательно, не будет напрямую ссылаться на свой собственный &lt;em&gt;тип&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="8b90152377c4d2fa6a58836b95414b3c64c66683" translate="yes" xml:space="preserve">
          <source>The easiest way to use &lt;code&gt;HashMap&lt;/code&gt; with a custom key type is to derive &lt;a href=&quot;../../cmp/trait.eq&quot;&gt;&lt;code&gt;Eq&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../../hash/trait.hash&quot;&gt;&lt;code&gt;Hash&lt;/code&gt;&lt;/a&gt;. We must also derive &lt;a href=&quot;../../cmp/trait.partialeq&quot;&gt;&lt;code&gt;PartialEq&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Самый простой способ использовать &lt;code&gt;HashMap&lt;/code&gt; с настраиваемым типом ключа - это получить &lt;a href=&quot;../../cmp/trait.eq&quot;&gt; &lt;code&gt;Eq&lt;/code&gt; &lt;/a&gt; и &lt;a href=&quot;../../hash/trait.hash&quot;&gt; &lt;code&gt;Hash&lt;/code&gt; &lt;/a&gt; . Мы также должны получить &lt;a href=&quot;../../cmp/trait.partialeq&quot;&gt; &lt;code&gt;PartialEq&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="8fdc4a2a7876216a8a5156bcc124c1c5c1d13c54" translate="yes" xml:space="preserve">
          <source>The easiest way to use &lt;code&gt;HashMap&lt;/code&gt; with a custom key type is to derive &lt;a href=&quot;../cmp/trait.eq&quot;&gt;&lt;code&gt;Eq&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../hash/trait.hash&quot;&gt;&lt;code&gt;Hash&lt;/code&gt;&lt;/a&gt;. We must also derive &lt;a href=&quot;../cmp/trait.partialeq&quot;&gt;&lt;code&gt;PartialEq&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Самый простой способ использовать &lt;code&gt;HashMap&lt;/code&gt; с настраиваемым типом ключа - это получить &lt;a href=&quot;../cmp/trait.eq&quot;&gt; &lt;code&gt;Eq&lt;/code&gt; &lt;/a&gt; и &lt;a href=&quot;../hash/trait.hash&quot;&gt; &lt;code&gt;Hash&lt;/code&gt; &lt;/a&gt; . Мы также должны получить &lt;a href=&quot;../cmp/trait.partialeq&quot;&gt; &lt;code&gt;PartialEq&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="2b835cd73ddea2cd4aee637c4f9c2cd855ee696f" translate="yes" xml:space="preserve">
          <source>The easiest way to use &lt;code&gt;HashSet&lt;/code&gt; with a custom type is to derive &lt;a href=&quot;../../cmp/trait.eq&quot;&gt;&lt;code&gt;Eq&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../../hash/trait.hash&quot;&gt;&lt;code&gt;Hash&lt;/code&gt;&lt;/a&gt;. We must also derive &lt;a href=&quot;../../cmp/trait.partialeq&quot;&gt;&lt;code&gt;PartialEq&lt;/code&gt;&lt;/a&gt;, this will in the future be implied by &lt;a href=&quot;../../cmp/trait.eq&quot;&gt;&lt;code&gt;Eq&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Самый простой способ использовать &lt;code&gt;HashSet&lt;/code&gt; с настраиваемым типом - это получить &lt;a href=&quot;../../cmp/trait.eq&quot;&gt; &lt;code&gt;Eq&lt;/code&gt; &lt;/a&gt; и &lt;a href=&quot;../../hash/trait.hash&quot;&gt; &lt;code&gt;Hash&lt;/code&gt; &lt;/a&gt; . Мы также должны вывести &lt;a href=&quot;../../cmp/trait.partialeq&quot;&gt; &lt;code&gt;PartialEq&lt;/code&gt; &lt;/a&gt; , это в будущем будет подразумеваться &lt;a href=&quot;../../cmp/trait.eq&quot;&gt; &lt;code&gt;Eq&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="bcd32a61d8029373ce3811b4c81b01b04e2fcd8a" translate="yes" xml:space="preserve">
          <source>The easiest way to use &lt;code&gt;HashSet&lt;/code&gt; with a custom type is to derive &lt;a href=&quot;../cmp/trait.eq&quot;&gt;&lt;code&gt;Eq&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../hash/trait.hash&quot;&gt;&lt;code&gt;Hash&lt;/code&gt;&lt;/a&gt;. We must also derive &lt;a href=&quot;../cmp/trait.partialeq&quot;&gt;&lt;code&gt;PartialEq&lt;/code&gt;&lt;/a&gt;, this will in the future be implied by &lt;a href=&quot;../cmp/trait.eq&quot;&gt;&lt;code&gt;Eq&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Самый простой способ использовать &lt;code&gt;HashSet&lt;/code&gt; с настраиваемым типом - это получить &lt;a href=&quot;../cmp/trait.eq&quot;&gt; &lt;code&gt;Eq&lt;/code&gt; &lt;/a&gt; и &lt;a href=&quot;../hash/trait.hash&quot;&gt; &lt;code&gt;Hash&lt;/code&gt; &lt;/a&gt; . Мы также должны вывести &lt;a href=&quot;../cmp/trait.partialeq&quot;&gt; &lt;code&gt;PartialEq&lt;/code&gt; &lt;/a&gt; , это в будущем будет подразумеваться &lt;a href=&quot;../cmp/trait.eq&quot;&gt; &lt;code&gt;Eq&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="4abca09eae529f079207e693c4204e4240160458" translate="yes" xml:space="preserve">
          <source>The element range is removed even if the iterator is not consumed until the end.</source>
          <target state="translated">Диапазон элементов снимается,даже если итератор не расходуется до конца.</target>
        </trans-unit>
        <trans-unit id="857f1367d5858bf310bc19ad475cfec76822e623" translate="yes" xml:space="preserve">
          <source>The element that was removed is returned, and the cursor is moved to point to the next element in the &lt;code&gt;LinkedList&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="17d488f8279ef9d0e051cac2f43dff0a68f18b2b" translate="yes" xml:space="preserve">
          <source>The elements are removed in arbitrary order.</source>
          <target state="translated">Элементы удаляются в произвольном порядке.</target>
        </trans-unit>
        <trans-unit id="5fe5f813b6a2f233abc73bad03a94ec158695239" translate="yes" xml:space="preserve">
          <source>The elements at &lt;code&gt;old_len..new_len&lt;/code&gt; must be initialized.</source>
          <target state="translated">Элементы в &lt;code&gt;old_len..new_len&lt;/code&gt; должны быть инициализированы.</target>
        </trans-unit>
        <trans-unit id="2bafc31dee9d33ba4d10ed67ef0f71ab38bfff69" translate="yes" xml:space="preserve">
          <source>The elements of an &lt;a href=&quot;types/array&quot;&gt;array&lt;/a&gt; or owned &lt;a href=&quot;types/array&quot;&gt;slice&lt;/a&gt; are dropped from the first element to the last. *</source>
          <target state="translated">Элементы &lt;a href=&quot;types/array&quot;&gt;массива&lt;/a&gt; или принадлежащего &lt;a href=&quot;types/array&quot;&gt;среза&lt;/a&gt; удаляются с первого элемента до последнего. *</target>
        </trans-unit>
        <trans-unit id="1e3e69cc26857f9c1293b40c529b047e54164338" translate="yes" xml:space="preserve">
          <source>The elements of an &lt;a href=&quot;types/array&quot;&gt;array&lt;/a&gt; or owned &lt;a href=&quot;types/slice&quot;&gt;slice&lt;/a&gt; are dropped from the first element to the last.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2aa9bb19de05cfdf90da669db74c8f4ff87b16d5" translate="yes" xml:space="preserve">
          <source>The elements yielded by &lt;code&gt;DoubleEndedIterator&lt;/code&gt;'s methods may differ from the ones yielded by &lt;a href=&quot;trait.iterator&quot;&gt;&lt;code&gt;Iterator&lt;/code&gt;&lt;/a&gt;'s methods:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="88efd616f1a1b2e8d8f2dcc3a848a8c623471404" translate="yes" xml:space="preserve">
          <source>The elision rules don&amp;rsquo;t provide full inference. If Rust deterministically applies the rules but there is still ambiguity as to what lifetimes the references have, the compiler won&amp;rsquo;t guess what the lifetime of the remaining references should be. In this case, instead of guessing, the compiler will give you an error that you can resolve by adding the lifetime annotations that specify how the references relate to each other.</source>
          <target state="translated">Правила исключения не обеспечивают полного вывода. Если Rust детерминированно применяет правила, но все еще остается неясность относительно того, какое время жизни имеют ссылки, компилятор не угадывает, каким должно быть время жизни оставшихся ссылок. В этом случае вместо того, чтобы угадывать, компилятор выдаст вам ошибку, которую вы можете решить, добавив аннотации времени жизни, которые определяют, как ссылки связаны друг с другом.</target>
        </trans-unit>
        <trans-unit id="3e3b658969dac70797ae99e22406a5919df5b0c6" translate="yes" xml:space="preserve">
          <source>The entire expression uses the given values for the fields that were specified and moves or copies the remaining fields from the base expression. As with all struct expressions, all of the fields of the struct must be &lt;a href=&quot;../visibility-and-privacy&quot;&gt;visible&lt;/a&gt;, even those not explicitly named.</source>
          <target state="translated">Все выражение использует данные значения для указанных полей и перемещает или копирует оставшиеся поля из базового выражения. Как и во всех выражениях структуры, все поля структуры должны быть &lt;a href=&quot;../visibility-and-privacy&quot;&gt;видимыми&lt;/a&gt; , даже те, которые явно не названы.</target>
        </trans-unit>
        <trans-unit id="a0574dfce03935016b1e7370699d140878e68385" translate="yes" xml:space="preserve">
          <source>The entire file name if the file name begins with &lt;code&gt;.&lt;/code&gt; and has no other &lt;code&gt;.&lt;/code&gt;s within;</source>
          <target state="translated">Полное имя файла, если имя файла начинается с &lt;code&gt;.&lt;/code&gt; и другого нет &lt;code&gt;.&lt;/code&gt; с внутри;</target>
        </trans-unit>
        <trans-unit id="e83cf0228defdcd6e7afea0984d3278d36eab74c" translate="yes" xml:space="preserve">
          <source>The entire file name if there is no embedded &lt;code&gt;.&lt;/code&gt;;</source>
          <target state="translated">Полное имя файла, если нет встроенного &lt;code&gt;.&lt;/code&gt; ;</target>
        </trans-unit>
        <trans-unit id="3fa274546f438640798ab62aae39ac18398db5cc" translate="yes" xml:space="preserve">
          <source>The entire function</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8a5d709e7f69a77cb8061cae38e47a941e97332f" translate="yes" xml:space="preserve">
          <source>The entire function body.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5c15c39c685d0906fec325e3d5c2bea1c6eb708a" translate="yes" xml:space="preserve">
          <source>The entire function scope is the outer most scope.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9b8eedec31f30287b3b74ad1f2675a525e2c3cf5" translate="yes" xml:space="preserve">
          <source>The entire hash map is generic over a key type &lt;code&gt;K&lt;/code&gt;. Because these keys are stored with the hash map, this type has to own the key&amp;rsquo;s data. When inserting a key-value pair, the map is given such a &lt;code&gt;K&lt;/code&gt; and needs to find the correct hash bucket and check if the key is already present based on that &lt;code&gt;K&lt;/code&gt;. It therefore requires &lt;code&gt;K: Hash + Eq&lt;/code&gt;.</source>
          <target state="translated">Вся хэш - карта является общей над ключевым типом &lt;code&gt;K&lt;/code&gt; . Поскольку эти ключи хранятся с хэш-картой, этот тип должен владеть данными ключа. При вставке пары ключ-значение, карта дается такое &lt;code&gt;K&lt;/code&gt; и потребности , чтобы найти правильный хэш ведро и проверить , если ключ уже присутствует на основе этого &lt;code&gt;K&lt;/code&gt; . Поэтому требуется &lt;code&gt;K: Hash + Eq&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0297c1c788a21e67f6b7fde15406ec3888485937" translate="yes" xml:space="preserve">
          <source>The entire memory range of this slice must be contained within a single allocated object! Slices can never span across multiple allocated objects.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d250d768cfabd095635656557072ab76a1e3cbad" translate="yes" xml:space="preserve">
          <source>The entire memory range of this slice must be contained within a single allocated object! Slices can never span across multiple allocated objects. See &lt;a href=&quot;#incorrect-usage&quot;&gt;below&lt;/a&gt; for an example incorrectly not taking this into account.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="97dea0260f138033ef7cf2f5ca57a634d6eea616" translate="yes" xml:space="preserve">
          <source>The entry point of the program was marked as &lt;code&gt;async&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="82f98df6718e5a9d6fd411d1cc853597af7467ed" translate="yes" xml:space="preserve">
          <source>The error and the note tell the story: Rust strings don&amp;rsquo;t support indexing. But why not? To answer that question, we need to discuss how Rust stores strings in memory.</source>
          <target state="translated">Ошибка и примечание рассказывают историю: строки Rust не поддерживают индексацию. Но почему нет? Чтобы ответить на этот вопрос, нам нужно обсудить, как Rust хранит строки в памяти.</target>
        </trans-unit>
        <trans-unit id="41a72aa86a9d9e55bed7f9841f1b9fdc25696e6c" translate="yes" xml:space="preserve">
          <source>The error happens on numeric literals and on numeric bindings without an identified concrete type:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1decc58ff466451824639b9b2033b046dfa94fee" translate="yes" xml:space="preserve">
          <source>The error happens on numeric literals:</source>
          <target state="translated">Ошибка происходит на цифровых буквах:</target>
        </trans-unit>
        <trans-unit id="39121a17de405ba30c8238c549d55b70becaf449" translate="yes" xml:space="preserve">
          <source>The error indicates that Rust expected a &lt;code&gt;bool&lt;/code&gt; but got an integer. Unlike languages such as Ruby and JavaScript, Rust will not automatically try to convert non-Boolean types to a Boolean. You must be explicit and always provide &lt;code&gt;if&lt;/code&gt; with a Boolean as its condition. If we want the &lt;code&gt;if&lt;/code&gt; code block to run only when a number is not equal to &lt;code&gt;0&lt;/code&gt;, for example, we can change the &lt;code&gt;if&lt;/code&gt; expression to the following:</source>
          <target state="translated">Ошибка указывает на то, что Rust ожидал &lt;code&gt;bool&lt;/code&gt; но получил целое число. В отличие от таких языков, как Ruby и JavaScript, Rust не будет автоматически пытаться преобразовать не-логические типы в логические. Вы должны быть явными и всегда указывать &lt;code&gt;if&lt;/code&gt; с логическим значением в качестве условия. Если мы хотим, &lt;code&gt;if&lt;/code&gt; блок кода if запускался, например, только тогда, когда число не равно &lt;code&gt;0&lt;/code&gt; , мы можем изменить выражение &lt;code&gt;if&lt;/code&gt; на следующее:</target>
        </trans-unit>
        <trans-unit id="82fe814b563c83c1ad42c2a44464d60e45abeb59" translate="yes" xml:space="preserve">
          <source>The error message indicates that the cause of the error is that you &lt;code&gt;cannot assign twice to immutable variable x&lt;/code&gt;, because you tried to assign a second value to the immutable &lt;code&gt;x&lt;/code&gt; variable.</source>
          <target state="translated">Сообщение об ошибке указывает, что причина ошибки в том, что вы &lt;code&gt;cannot assign twice to immutable variable x&lt;/code&gt; , потому что вы пытались присвоить второе значение неизменной переменной &lt;code&gt;x&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1acd99d552c691a91137d21fedf0cc394ac8a4d0" translate="yes" xml:space="preserve">
          <source>The error message states that the &lt;code&gt;counter&lt;/code&gt; value is moved into the closure and then captured when we call &lt;code&gt;lock&lt;/code&gt;. That description sounds like what we wanted, but it&amp;rsquo;s not allowed!</source>
          <target state="translated">В сообщении об ошибке указано, что значение &lt;code&gt;counter&lt;/code&gt; перемещается в замыкание, а затем фиксируется, когда мы вызываем &lt;code&gt;lock&lt;/code&gt; . Это описание звучит так, как мы хотели, но это запрещено!</target>
        </trans-unit>
        <trans-unit id="5bb7a0ad71457e0f1d6ce226ce7b55ec5697ceba" translate="yes" xml:space="preserve">
          <source>The error message states that the &lt;code&gt;counter&lt;/code&gt; value was moved in the previous iteration of the loop. So Rust is telling us that we can&amp;rsquo;t move the ownership of lock &lt;code&gt;counter&lt;/code&gt; into multiple threads. Let&amp;rsquo;s fix the compiler error with a multiple-ownership method we discussed in Chapter 15.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6326b5d7f5ddab487c6090e5e84a18d25a0a3db6" translate="yes" xml:space="preserve">
          <source>The error messages say that module &lt;code&gt;hosting&lt;/code&gt; is private. In other words, we have the correct paths for the &lt;code&gt;hosting&lt;/code&gt; module and the &lt;code&gt;add_to_waitlist&lt;/code&gt; function, but Rust won&amp;rsquo;t let us use them because it doesn&amp;rsquo;t have access to the private sections.</source>
          <target state="translated">В сообщениях об ошибках указано, что &lt;code&gt;hosting&lt;/code&gt; модуля является частным. Другими словами, у нас есть правильные пути для модуля &lt;code&gt;hosting&lt;/code&gt; и функции &lt;code&gt;add_to_waitlist&lt;/code&gt; , но Rust не позволит нам их использовать, потому что у него нет доступа к приватным разделам.</target>
        </trans-unit>
        <trans-unit id="8eb6e3e38ad85be87f507639136fdec21b108288" translate="yes" xml:space="preserve">
          <source>The error occurs because &lt;code&gt;foo&lt;/code&gt; accepts a closure that takes an &lt;code&gt;i32&lt;/code&gt; argument, but in &lt;code&gt;main&lt;/code&gt;, it is passed a closure with a &lt;code&gt;&amp;amp;str&lt;/code&gt; argument.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4df536d23e48c26eec2d844083fbc5169ab15de6" translate="yes" xml:space="preserve">
          <source>The error occurs because keyword &lt;code&gt;yield&lt;/code&gt; can only be used inside the generator literal. This can be fixed by constructing the generator correctly.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5bce45a967fbcca42003bd3fc6c351711632526a" translate="yes" xml:space="preserve">
          <source>The error references the &lt;code&gt;Sized&lt;/code&gt; trait again! Rust doesn&amp;rsquo;t know how much space it will need to store the closure. We saw a solution to this problem earlier. We can use a trait object:</source>
          <target state="translated">Ошибка снова ссылается на &lt;code&gt;Sized&lt;/code&gt; ! Rust не знает, сколько места потребуется для хранения укупорочного средства. Мы видели решение этой проблемы ранее. Мы можем использовать объект-признак:</target>
        </trans-unit>
        <trans-unit id="687172b839a6f9ace430c7922b4119fecbbc273c" translate="yes" xml:space="preserve">
          <source>The error says we&amp;rsquo;re not allowed to mutate a variable&amp;rsquo;s type:</source>
          <target state="translated">Ошибка говорит, что нам не разрешено изменять тип переменной:</target>
        </trans-unit>
        <trans-unit id="4c799801c95c3499262c7f795808c56dd04d3f03" translate="yes" xml:space="preserve">
          <source>The error shows that for &lt;code&gt;result&lt;/code&gt; to be valid for the &lt;code&gt;println!&lt;/code&gt; statement, &lt;code&gt;string2&lt;/code&gt; would need to be valid until the end of the outer scope. Rust knows this because we annotated the lifetimes of the function parameters and return values using the same lifetime parameter &lt;code&gt;'a&lt;/code&gt;.</source>
          <target state="translated">Ошибка показывает, что для того, чтобы &lt;code&gt;result&lt;/code&gt; был действительным для &lt;code&gt;println!&lt;/code&gt; оператор, &lt;code&gt;string2&lt;/code&gt; должна быть действительной до конца внешней области. Rust знает это, потому что мы аннотировали время жизни параметров функции и возвращаемые значения, используя один и тот же параметр времени жизни &lt;code&gt;'a&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="81dd6345e63f7b9b970ec324dc927c2a78ce87e8" translate="yes" xml:space="preserve">
          <source>The error shows that you can&amp;rsquo;t use the keyword &lt;code&gt;match&lt;/code&gt; as the function identifier. To use &lt;code&gt;match&lt;/code&gt; as a function name, you need to use the raw identifier syntax, like this:</source>
          <target state="translated">Ошибка показывает, что вы не можете использовать &lt;code&gt;match&lt;/code&gt; ключевого слова в качестве идентификатора функции. Чтобы использовать &lt;code&gt;match&lt;/code&gt; в качестве имени функции, вам необходимо использовать синтаксис необработанного идентификатора, например:</target>
        </trans-unit>
        <trans-unit id="17031b6288809d4b66c77a71348fe05200b2e1e5" translate="yes" xml:space="preserve">
          <source>The error shows this type &amp;ldquo;has infinite size.&amp;rdquo; The reason is that we&amp;rsquo;ve defined &lt;code&gt;List&lt;/code&gt; with a variant that is recursive: it holds another value of itself directly. As a result, Rust can&amp;rsquo;t figure out how much space it needs to store a &lt;code&gt;List&lt;/code&gt; value. Let&amp;rsquo;s break down why we get this error a bit. First, let&amp;rsquo;s look at how Rust decides how much space it needs to store a value of a non-recursive type.</source>
          <target state="translated">Ошибка показывает, что этот тип &amp;laquo;имеет бесконечный размер&amp;raquo;. Причина в том, что мы определили &lt;code&gt;List&lt;/code&gt; с рекурсивным вариантом: он напрямую содержит другое значение. В результате Rust не может определить, сколько места ему нужно для хранения значения &lt;code&gt;List&lt;/code&gt; . Давайте немного разберемся, почему мы получаем эту ошибку. Во-первых, давайте посмотрим, как Rust определяет, сколько места ему нужно для хранения значения нерекурсивного типа.</target>
        </trans-unit>
        <trans-unit id="ddd69ec9cc85fcc63997c43bed364cf16ee6b3f9" translate="yes" xml:space="preserve">
          <source>The error tells us we can&amp;rsquo;t call &lt;code&gt;join&lt;/code&gt; because we only have a mutable borrow of each &lt;code&gt;worker&lt;/code&gt; and &lt;code&gt;join&lt;/code&gt; takes ownership of its argument. To solve this issue, we need to move the thread out of the &lt;code&gt;Worker&lt;/code&gt; instance that owns &lt;code&gt;thread&lt;/code&gt; so &lt;code&gt;join&lt;/code&gt; can consume the thread. We did this in Listing 17-15: if &lt;code&gt;Worker&lt;/code&gt; holds an &lt;code&gt;Option&amp;lt;thread::JoinHandle&amp;lt;()&amp;gt;&amp;gt;&lt;/code&gt; instead, we can call the &lt;code&gt;take&lt;/code&gt; method on the &lt;code&gt;Option&lt;/code&gt; to move the value out of the &lt;code&gt;Some&lt;/code&gt; variant and leave a &lt;code&gt;None&lt;/code&gt; variant in its place. In other words, a &lt;code&gt;Worker&lt;/code&gt; that is running will have a &lt;code&gt;Some&lt;/code&gt; variant in &lt;code&gt;thread&lt;/code&gt;, and when we want to clean up a &lt;code&gt;Worker&lt;/code&gt;, we&amp;rsquo;ll replace &lt;code&gt;Some&lt;/code&gt; with &lt;code&gt;None&lt;/code&gt; so the &lt;code&gt;Worker&lt;/code&gt; doesn&amp;rsquo;t have a thread to run.</source>
          <target state="translated">Ошибка говорит нам, что мы не можем вызвать &lt;code&gt;join&lt;/code&gt; , потому что у нас есть только изменяемое заимствование каждого &lt;code&gt;worker&lt;/code&gt; и &lt;code&gt;join&lt;/code&gt; становится владельцем своего аргумента. Чтобы решить эту проблему, нам нужно переместить поток из экземпляра &lt;code&gt;Worker&lt;/code&gt; , которому принадлежит &lt;code&gt;thread&lt;/code&gt; чтобы &lt;code&gt;join&lt;/code&gt; могло потреблять поток. Мы сделали это в листинге 17-15: если вместо этого &lt;code&gt;Worker&lt;/code&gt; содержит &lt;code&gt;Option&amp;lt;thread::JoinHandle&amp;lt;()&amp;gt;&amp;gt;&lt;/code&gt; , мы можем вызвать метод &lt;code&gt;take&lt;/code&gt; для &lt;code&gt;Option&lt;/code&gt; , чтобы переместить значение из варианта &lt;code&gt;Some&lt;/code&gt; и оставить вариант &lt;code&gt;None&lt;/code&gt; в свое место. Другими словами, &lt;code&gt;Worker&lt;/code&gt; который выполняется, будет иметь вариант &lt;code&gt;Some&lt;/code&gt; в &lt;code&gt;thread&lt;/code&gt; , и когда мы хотим очистить &lt;code&gt;Worker&lt;/code&gt; , мы заменим &lt;code&gt;Some&lt;/code&gt; на &lt;code&gt;None&lt;/code&gt; , чтобы у &lt;code&gt;Worker&lt;/code&gt; не было потока для запуска.</target>
        </trans-unit>
        <trans-unit id="58b8d8f068cf467e7f55c896bbdf137f3a755bf5" translate="yes" xml:space="preserve">
          <source>The error type for &lt;code&gt;try_reserve&lt;/code&gt; methods.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="458fb320b83d2d5563146d6c64a5e9086c1cdbe5" translate="yes" xml:space="preserve">
          <source>The error type for I/O operations of the &lt;a href=&quot;trait.read&quot;&gt;&lt;code&gt;Read&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;trait.write&quot;&gt;&lt;code&gt;Write&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;trait.seek&quot;&gt;&lt;code&gt;Seek&lt;/code&gt;&lt;/a&gt;, and associated traits.</source>
          <target state="translated">Тип ошибки для операций ввода-вывода для свойств &lt;a href=&quot;trait.read&quot;&gt; &lt;code&gt;Read&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;trait.write&quot;&gt; &lt;code&gt;Write&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;trait.seek&quot;&gt; &lt;code&gt;Seek&lt;/code&gt; &lt;/a&gt; и связанных с ними.</target>
        </trans-unit>
        <trans-unit id="3e8c3a7432541c640c48492379ea610ecb40f6ae" translate="yes" xml:space="preserve">
          <source>The error type for errors that can never happen.</source>
          <target state="translated">Тип ошибки для ошибок,которые никогда не могут произойти.</target>
        </trans-unit>
        <trans-unit id="fdb319ec59d1f1964ec642ac851b7301cdf60e57" translate="yes" xml:space="preserve">
          <source>The error type for operations interacting with environment variables. Possibly returned from &lt;a href=&quot;fn.var&quot;&gt;&lt;code&gt;env::var()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="751842d7baf0779231030e01a15db69a4f03c6bc" translate="yes" xml:space="preserve">
          <source>The error type for operations interacting with environment variables. Possibly returned from the &lt;a href=&quot;fn.var&quot;&gt;&lt;code&gt;env::var&lt;/code&gt;&lt;/a&gt; function.</source>
          <target state="translated">Тип ошибки для операций, взаимодействующих с переменными среды. Возможно, возвращается из функции &lt;a href=&quot;fn.var&quot;&gt; &lt;code&gt;env::var&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="11ea1ae6c021101c095eab4ba4b755be8b16c063" translate="yes" xml:space="preserve">
          <source>The error type for operations on the &lt;code&gt;PATH&lt;/code&gt; variable. Possibly returned from &lt;a href=&quot;fn.join_paths&quot;&gt;&lt;code&gt;env::join_paths()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="04e8342895bd312f045a40780238aabb9ef5de36" translate="yes" xml:space="preserve">
          <source>The error type for operations on the &lt;code&gt;PATH&lt;/code&gt; variable. Possibly returned from the &lt;a href=&quot;fn.join_paths&quot;&gt;&lt;code&gt;env::join_paths&lt;/code&gt;&lt;/a&gt; function.</source>
          <target state="translated">Тип ошибки для операций с &lt;code&gt;PATH&lt;/code&gt; . Возможно, возвращено функцией &lt;a href=&quot;fn.join_paths&quot;&gt; &lt;code&gt;env::join_paths&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="92c7e92ce900890826a3bdc04f0bdb6f93a2ae4e" translate="yes" xml:space="preserve">
          <source>The error type returned when a checked integral type conversion fails.</source>
          <target state="translated">Тип ошибки возвращается при неудачном проверочном приведении интегрального типа.</target>
        </trans-unit>
        <trans-unit id="7c03030b0922657a2b23ad871594bf872bfa86e8" translate="yes" xml:space="preserve">
          <source>The error type returned when a conversion from a slice to an array fails.</source>
          <target state="translated">Тип ошибки возвращается при неудачном преобразовании среза в массив.</target>
        </trans-unit>
        <trans-unit id="5bd755e234651b9d8db0dad82d899820eb73c1c6" translate="yes" xml:space="preserve">
          <source>The error type returned when a conversion from u32 to char fails.</source>
          <target state="translated">Тип ошибки возвращается при неудачном преобразовании из u32 в char.</target>
        </trans-unit>
        <trans-unit id="74bd671788812266d70e1e6379cd71d68b83bdd8" translate="yes" xml:space="preserve">
          <source>The error type that results from applying the try operator (&lt;code&gt;?&lt;/code&gt;) to a &lt;code&gt;None&lt;/code&gt; value. If you wish to allow &lt;code&gt;x?&lt;/code&gt; (where &lt;code&gt;x&lt;/code&gt; is an &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt;) to be converted into your error type, you can implement &lt;code&gt;impl From&amp;lt;NoneError&amp;gt;&lt;/code&gt; for &lt;code&gt;YourErrorType&lt;/code&gt;. In that case, &lt;code&gt;x?&lt;/code&gt; within a function that returns &lt;code&gt;Result&amp;lt;_, YourErrorType&amp;gt;&lt;/code&gt; will translate a &lt;code&gt;None&lt;/code&gt; value into an &lt;code&gt;Err&lt;/code&gt; result.</source>
          <target state="translated">Тип ошибки, возникающий в результате применения оператора try ( &lt;code&gt;?&lt;/code&gt; ) К значению &lt;code&gt;None&lt;/code&gt; . Если вы хотите разрешить &lt;code&gt;x?&lt;/code&gt; (где &lt;code&gt;x&lt;/code&gt; - это &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt; ) для преобразования в ваш тип ошибки, вы можете реализовать &lt;code&gt;impl From&amp;lt;NoneError&amp;gt;&lt;/code&gt; для &lt;code&gt;YourErrorType&lt;/code&gt; . В таком случае &lt;code&gt;x?&lt;/code&gt; внутри функции, которая возвращает &lt;code&gt;Result&amp;lt;_, YourErrorType&amp;gt;&lt;/code&gt; преобразует значение &lt;code&gt;None&lt;/code&gt; в результат &lt;code&gt;Err&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="620e9e66f647e7af133c1492023ad78f941762d1" translate="yes" xml:space="preserve">
          <source>The error type which is returned from formatting a message into a stream.</source>
          <target state="translated">Тип ошибки,возвращаемой из форматирования сообщения в поток.</target>
        </trans-unit>
        <trans-unit id="d4672a685f085da2d7d7f62486ff4649fbce70a5" translate="yes" xml:space="preserve">
          <source>The errors in Listing 7-6 say that the &lt;code&gt;add_to_waitlist&lt;/code&gt; function is private. The privacy rules apply to structs, enums, functions, and methods as well as modules.</source>
          <target state="translated">Ошибки в листинге 7-6 говорят о том, &lt;code&gt;add_to_waitlist&lt;/code&gt; функция add_to_waitlist является частной. Правила конфиденциальности применяются к структурам, перечислениям, функциям и методам, а также к модулям.</target>
        </trans-unit>
        <trans-unit id="5c9b02894ffaf56c3eee190bd9f4d3e5a18ff962" translate="yes" xml:space="preserve">
          <source>The exact behavior on locking a mutex in the thread which already holds the lock is left unspecified. However, this function will not return on the second call (it might panic or deadlock, for example).</source>
          <target state="translated">Точное поведение при блокировке мьютекса в потоке,который уже держит блокировку,остается неуточненным.Однако эта функция не вернется при втором вызове (например,она может запаниковать или зайти в тупик).</target>
        </trans-unit>
        <trans-unit id="ec573024d9a369fea8772d4967a09d1e972fae0a" translate="yes" xml:space="preserve">
          <source>The exact character(s)</source>
          <target state="translated">Точный характер(ы)</target>
        </trans-unit>
        <trans-unit id="df2f57248767dbedd045941faa73ddbe53944b27" translate="yes" xml:space="preserve">
          <source>The exact order may be useful for tracking external state, like an index.</source>
          <target state="translated">Точный порядок может быть полезен для отслеживания внешнего состояния,например,индекса.</target>
        </trans-unit>
        <trans-unit id="8fe495e6414bd43e7bea5f0003cca50741a5b59b" translate="yes" xml:space="preserve">
          <source>The exact output printed by this macro should not be relied upon and is subject to future changes.</source>
          <target state="translated">На точный вывод,напечатанный с помощью этого макроса,полагаться не следует,и он может быть изменен в будущем.</target>
        </trans-unit>
        <trans-unit id="469498f0144088c9a82cccca15de67704811a8dd" translate="yes" xml:space="preserve">
          <source>The exact text, of course, depends on what files you have in &lt;code&gt;.&lt;/code&gt;.</source>
          <target state="translated">Точный текст, конечно, зависит от того, какие файлы у вас есть &lt;code&gt;.&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="395c851d3758c4daf594b9f6b458c5ca4cd7434f" translate="yes" xml:space="preserve">
          <source>The example in Listing 13-14 separates the creation of the iterator from the use of the iterator in the &lt;code&gt;for&lt;/code&gt; loop. The iterator is stored in the &lt;code&gt;v1_iter&lt;/code&gt; variable, and no iteration takes place at that time. When the &lt;code&gt;for&lt;/code&gt; loop is called using the iterator in &lt;code&gt;v1_iter&lt;/code&gt;, each element in the iterator is used in one iteration of the loop, which prints out each value.</source>
          <target state="translated">Пример в листинге 13-14 отделяет создание итератора от использования итератора в цикле &lt;code&gt;for&lt;/code&gt; . Итератор хранится в переменной &lt;code&gt;v1_iter&lt;/code&gt; , и в это время итерация не выполняется. Когда цикл &lt;code&gt;for&lt;/code&gt; вызывается с использованием итератора в &lt;code&gt;v1_iter&lt;/code&gt; , каждый элемент в итераторе используется в одной итерации цикла, которая выводит каждое значение.</target>
        </trans-unit>
        <trans-unit id="e88d69a7ee7e1056409be12e179c7703287290b1" translate="yes" xml:space="preserve">
          <source>The exception to this idiom is if we&amp;rsquo;re bringing two items with the same name into scope with &lt;code&gt;use&lt;/code&gt; statements, because Rust doesn&amp;rsquo;t allow that. Listing 7-15 shows how to bring two &lt;code&gt;Result&lt;/code&gt; types into scope that have the same name but different parent modules and how to refer to them.</source>
          <target state="translated">Исключением из этой идиомы является то, что мы переносим два элемента с одинаковым именем в область видимости с &lt;code&gt;use&lt;/code&gt; операторов use , потому что Rust этого не допускает. В листинге 7-15 показано, как &lt;code&gt;Result&lt;/code&gt; в область видимости два типа результатов, которые имеют одинаковое имя, но разные родительские модули, и как ссылаться на них.</target>
        </trans-unit>
        <trans-unit id="f9ff06ceaf161b4f26d0944c142b9739231935eb" translate="yes" xml:space="preserve">
          <source>The exception to this is the unit tuple (&lt;code&gt;()&lt;/code&gt;) which is guaranteed as a zero-sized type to have a size of 0 and an alignment of 1.</source>
          <target state="translated">Исключением является единичный кортеж ( &lt;code&gt;()&lt;/code&gt; ), который гарантированно имеет нулевой размер, размер 0 и выравнивание 1.</target>
        </trans-unit>
        <trans-unit id="3dc57cf649d183700b8e68c720c692cad27e1162" translate="yes" xml:space="preserve">
          <source>The expanded expression has type &lt;code&gt;&amp;amp;'static str&lt;/code&gt;, and the returned file is not the invocation of the &lt;code&gt;file!&lt;/code&gt; macro itself, but rather the first macro invocation leading up to the invocation of the &lt;code&gt;file!&lt;/code&gt; macro.</source>
          <target state="translated">Расширенное выражение имеет тип &lt;code&gt;&amp;amp;'static str&lt;/code&gt; , а возвращаемый файл не является его вызовом &lt;code&gt;file!&lt;/code&gt; макрос, а скорее первый вызов макроса, ведущий к вызову &lt;code&gt;file!&lt;/code&gt; макрос.</target>
        </trans-unit>
        <trans-unit id="2027bedff965dc7817b0dd952d1fc211920c5f6d" translate="yes" xml:space="preserve">
          <source>The expanded expression has type &lt;code&gt;u32&lt;/code&gt; and is 1-based, so the first column in each line evaluates to 1, the second to 2, etc. This is consistent with error messages by common compilers or popular editors. The returned column is &lt;em&gt;not necessarily&lt;/em&gt; the line of the &lt;code&gt;column!&lt;/code&gt; invocation itself, but rather the first macro invocation leading up to the invocation of the &lt;code&gt;column!&lt;/code&gt; macro.</source>
          <target state="translated">Расширенное выражение имеет тип &lt;code&gt;u32&lt;/code&gt; и начинается с 1, поэтому первый столбец в каждой строке оценивается как 1, второй - как 2 и т. Д. Это согласуется с сообщениями об ошибках от распространенных компиляторов или популярных редакторов. Возвращаемый столбец &lt;em&gt;не обязательно&lt;/em&gt; является строкой &lt;code&gt;column!&lt;/code&gt; сам вызов, а скорее первый вызов макроса, ведущий к вызову &lt;code&gt;column!&lt;/code&gt; макрос.</target>
        </trans-unit>
        <trans-unit id="b0b06f58ec99c372d86a17a34c7166fa5de08c27" translate="yes" xml:space="preserve">
          <source>The expanded expression has type &lt;code&gt;u32&lt;/code&gt; and is 1-based, so the first line in each file evaluates to 1, the second to 2, etc. This is consistent with error messages by common compilers or popular editors. The returned line is &lt;em&gt;not necessarily&lt;/em&gt; the line of the &lt;code&gt;line!&lt;/code&gt; invocation itself, but rather the first macro invocation leading up to the invocation of the &lt;code&gt;line!&lt;/code&gt; macro.</source>
          <target state="translated">Расширенное выражение имеет тип &lt;code&gt;u32&lt;/code&gt; и начинается с 1, поэтому первая строка в каждом файле оценивается как 1, вторая - как 2 и т. Д. Это согласуется с сообщениями об ошибках распространенных компиляторов или популярных редакторов. Возвращенная строка &lt;em&gt;не обязательно&lt;/em&gt; является строкой &lt;code&gt;line!&lt;/code&gt; сам вызов, а скорее первый вызов макроса, ведущий к вызову &lt;code&gt;line!&lt;/code&gt; макрос.</target>
        </trans-unit>
        <trans-unit id="6dec360ada9c00c421ed26b5b352f032e17122ed" translate="yes" xml:space="preserve">
          <source>The expected cost of &lt;code&gt;push&lt;/code&gt;, averaged over every possible ordering of the elements being pushed, and over a sufficiently large number of pushes, is &lt;em&gt;O&lt;/em&gt;(1). This is the most meaningful cost metric when pushing elements that are &lt;em&gt;not&lt;/em&gt; already in any sorted pattern.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="606b0f6565bb5e33a7e793c7978e5b02d8b8d28b" translate="yes" xml:space="preserve">
          <source>The expected cost of &lt;code&gt;push&lt;/code&gt;, averaged over every possible ordering of the elements being pushed, and over a sufficiently large number of pushes, is O(1). This is the most meaningful cost metric when pushing elements that are &lt;em&gt;not&lt;/em&gt; already in any sorted pattern.</source>
          <target state="translated">Ожидаемая стоимость &lt;code&gt;push&lt;/code&gt; , усредненная по каждому возможному порядку выталкиваемых элементов и за достаточно большое количество нажатий, составляет O (1). Это наиболее значимая метрика стоимости при отправке элементов, которые еще &lt;em&gt;не&lt;/em&gt; входят &lt;em&gt;ни&lt;/em&gt; в один отсортированный шаблон.</target>
        </trans-unit>
        <trans-unit id="a72ec7eef34f0a8ffd7d99e9cfce2da0536188e2" translate="yes" xml:space="preserve">
          <source>The expression above creates a value of type &lt;code&gt;MyUnion&lt;/code&gt; and initializes the storage using field &lt;code&gt;f1&lt;/code&gt;. The union can be accessed using the same syntax as struct fields:</source>
          <target state="translated">Выражение выше создает значение типа &lt;code&gt;MyUnion&lt;/code&gt; и инициализирует хранилище с помощью поля &lt;code&gt;f1&lt;/code&gt; . Доступ к объединению можно получить с помощью того же синтаксиса, что и для полей структуры:</target>
        </trans-unit>
        <trans-unit id="b5fa765f11cc060019641c8e75e38c695bdb1bda" translate="yes" xml:space="preserve">
          <source>The expression cannot be a &lt;a href=&quot;operator-expr#lazy-boolean-operators&quot;&gt;lazy boolean operator expression&lt;/a&gt;. Use of a lazy boolean operator is ambiguous with a planned feature change of the language (the implementation of if-let chains - see &lt;a href=&quot;https://github.com/rust-lang/rfcs/blob/master/text/2497-if-let-chains.md#rollout-plan-and-transitioning-to-rust-2018&quot;&gt;eRFC 2947&lt;/a&gt;). When lazy boolean operator expression is desired, this can be achieved by using parenthesis as below:</source>
          <target state="translated">Выражение не может быть &lt;a href=&quot;operator-expr#lazy-boolean-operators&quot;&gt;выражением ленивого логического оператора&lt;/a&gt; . Использование ленивого логического оператора неоднозначно с запланированным изменением функций языка (реализация цепочек if-let - см. &lt;a href=&quot;https://github.com/rust-lang/rfcs/blob/master/text/2497-if-let-chains.md#rollout-plan-and-transitioning-to-rust-2018&quot;&gt;ERFC 2947&lt;/a&gt; ). Когда требуется ленивое логическое выражение оператора, это может быть достигнуто с помощью скобок, как показано ниже:</target>
        </trans-unit>
        <trans-unit id="a608f321648c235bb5c3f09a506a153d6d9a7fa1" translate="yes" xml:space="preserve">
          <source>The expression for a match arm.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="edc402eeeb9a7639cb3c026b59f168e6cd732965" translate="yes" xml:space="preserve">
          <source>The expression immediately following &lt;code&gt;in&lt;/code&gt; must implement the &lt;a href=&quot;../book/ch13-04-performance&quot;&gt;&lt;code&gt;IntoIterator&lt;/code&gt;&lt;/a&gt; trait.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="64c3c13114c938924165b32b931fcfa0929a3dad" translate="yes" xml:space="preserve">
          <source>The expression in the &lt;code&gt;if&lt;/code&gt; block evaluates to an integer, and the expression in the &lt;code&gt;else&lt;/code&gt; block evaluates to a string. This won&amp;rsquo;t work because variables must have a single type. Rust needs to know at compile time what type the &lt;code&gt;number&lt;/code&gt; variable is, definitively, so it can verify at compile time that its type is valid everywhere we use &lt;code&gt;number&lt;/code&gt;. Rust wouldn&amp;rsquo;t be able to do that if the type of &lt;code&gt;number&lt;/code&gt; was only determined at runtime; the compiler would be more complex and would make fewer guarantees about the code if it had to keep track of multiple hypothetical types for any variable.</source>
          <target state="translated">Выражение в блоке &lt;code&gt;if&lt;/code&gt; оценивается как целое число, а выражение в блоке &lt;code&gt;else&lt;/code&gt; оценивается как строка. Это не сработает, потому что переменные должны иметь один тип. Во время компиляции Rust должен точно знать, к какому типу относится &lt;code&gt;number&lt;/code&gt; переменная, чтобы во время компиляции можно было проверить, что ее тип действителен везде, где мы используем &lt;code&gt;number&lt;/code&gt; . Rust не смог бы этого сделать, если бы тип &lt;code&gt;number&lt;/code&gt; определялся только во время выполнения; компилятор был бы более сложным и дал бы меньше гарантий в отношении кода, если бы ему приходилось отслеживать несколько гипотетических типов для любой переменной.</target>
        </trans-unit>
        <trans-unit id="7947155b0fa5fdbbf2d84b0fb9bff1298adf4bf1" translate="yes" xml:space="preserve">
          <source>The extension is:</source>
          <target state="translated">Расширение:</target>
        </trans-unit>
        <trans-unit id="ea39e7727f6084ef5165d4f9b888542528c3cc1d" translate="yes" xml:space="preserve">
          <source>The external crate is resolved to a specific &lt;code&gt;soname&lt;/code&gt; at compile time, and a runtime linkage requirement to that &lt;code&gt;soname&lt;/code&gt; is passed to the linker for loading at runtime. The &lt;code&gt;soname&lt;/code&gt; is resolved at compile time by scanning the compiler's library path and matching the optional &lt;code&gt;crateid&lt;/code&gt; provided against the &lt;code&gt;crateid&lt;/code&gt; attributes that were declared on the external crate when it was compiled. If no &lt;code&gt;crateid&lt;/code&gt; is provided, a default &lt;code&gt;name&lt;/code&gt; attribute is assumed, equal to the &lt;a href=&quot;../identifiers&quot;&gt;identifier&lt;/a&gt; given in the &lt;code&gt;extern crate&lt;/code&gt; declaration.</source>
          <target state="translated">Внешний ящик &lt;code&gt;soname&lt;/code&gt; в конкретное soname во время компиляции, и требование связывания времени выполнения с этим &lt;code&gt;soname&lt;/code&gt; передается компоновщику для загрузки во время выполнения. &lt;code&gt;soname&lt;/code&gt; разрешено во время компиляции путем сканирования библиотеки пути компилятора и соответствия дополнительного &lt;code&gt;crateid&lt;/code&gt; при условии против &lt;code&gt;crateid&lt;/code&gt; атрибутов , которые были признаны на внешнем ящике , когда он был собран. Если &lt;code&gt;crateid&lt;/code&gt; не указан , предполагается атрибут &lt;code&gt;name&lt;/code&gt; умолчанию , равный &lt;a href=&quot;../identifiers&quot;&gt;идентификатору,&lt;/a&gt; указанному в объявлении &lt;code&gt;extern crate&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2d4ff9b9a673e6ef5c73fd0d74de95c1584abb9d" translate="yes" xml:space="preserve">
          <source>The failure message indicates that this test did indeed panic as we expected, but the panic message did not include the expected string &lt;code&gt;'Guess value must be less than or equal to 100'&lt;/code&gt;. The panic message that we did get in this case was &lt;code&gt;Guess value must be greater than or equal to 1, got 200.&lt;/code&gt; Now we can start figuring out where our bug is!</source>
          <target state="translated">Сообщение об ошибке указывает на то, что этот тест действительно вызвал панику, как мы и ожидали, но сообщение о панике не включало ожидаемую строку &lt;code&gt;'Guess value must be less than or equal to 100'&lt;/code&gt; . Паническое сообщение, которое мы получили в этом случае, заключалось в том, что &lt;code&gt;Guess value must be greater than or equal to 1, got 200.&lt;/code&gt; Теперь мы можем начать выяснять, где находится наша ошибка!</target>
        </trans-unit>
        <trans-unit id="1264d4255ef5d1877747639a91dce97d95706422" translate="yes" xml:space="preserve">
          <source>The family of the operating system. Example value is &lt;code&gt;unix&lt;/code&gt;.</source>
          <target state="translated">Семейство операционной системы. Пример значения - &lt;code&gt;unix&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1f19a750b2fcc57343d113fae5c2d35cbbeabd61" translate="yes" xml:space="preserve">
          <source>The field names can be decimal integer values to specify indices for constructing tuple structs. This can be used with base structs to fill out the remaining indices not specified:</source>
          <target state="translated">Имена полей могут быть десятичными целыми значениями для указания индексов для построения структур кортежей.Это может быть использовано с базовыми структурами для заполнения оставшихся не указанными индексами:</target>
        </trans-unit>
        <trans-unit id="0bbc5c6747805ec7b206ff1d7bd4fc19a67e98d4" translate="yes" xml:space="preserve">
          <source>The fields of a &lt;a href=&quot;types/struct&quot;&gt;struct&lt;/a&gt; are dropped in declaration order.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c1e05fef4f32d53e63c8251d9d852a226e0b9d94" translate="yes" xml:space="preserve">
          <source>The fields of a &lt;a href=&quot;types/struct&quot;&gt;struct&lt;/a&gt;, &lt;a href=&quot;types/tuple&quot;&gt;tuple&lt;/a&gt; or &lt;a href=&quot;types/enum&quot;&gt;enum variant&lt;/a&gt; are dropped in declaration order. *</source>
          <target state="translated">Поля &lt;a href=&quot;types/enum&quot;&gt;варианта &lt;/a&gt;&lt;a href=&quot;types/struct&quot;&gt;структуры&lt;/a&gt; , &lt;a href=&quot;types/tuple&quot;&gt;кортежа&lt;/a&gt; или перечисления удаляются в порядке объявления. *</target>
        </trans-unit>
        <trans-unit id="ad3f74fe8b6e787f7b7254796fcea650c623bbf0" translate="yes" xml:space="preserve">
          <source>The fields of a &lt;a href=&quot;types/tuple&quot;&gt;tuple&lt;/a&gt; are dropped in order.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="985befbf65bb726fbdc7e8fa5788956f4d2e4bf1" translate="yes" xml:space="preserve">
          <source>The fields of a &lt;code&gt;struct&lt;/code&gt; may be qualified by &lt;a href=&quot;../visibility-and-privacy&quot;&gt;visibility modifiers&lt;/a&gt;, to allow access to data in a struct outside a module.</source>
          <target state="translated">Поля &lt;code&gt;struct&lt;/code&gt; могут быть &lt;a href=&quot;../visibility-and-privacy&quot;&gt;уточнены модификаторами видимости&lt;/a&gt; , чтобы разрешить доступ к данным в структуре вне модуля.</target>
        </trans-unit>
        <trans-unit id="d44253ff03665f86e16760d6d12a49f11125c4e2" translate="yes" xml:space="preserve">
          <source>The fields of the active &lt;a href=&quot;types/enum&quot;&gt;enum variant&lt;/a&gt; are dropped in declaration order.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="40ccc036f7a6ce305846dd9b315fdf1f96b15a3b" translate="yes" xml:space="preserve">
          <source>The fields of this struct show that the Rust code we&amp;rsquo;ve parsed is a unit struct with the &lt;code&gt;ident&lt;/code&gt; (identifier, meaning the name) of &lt;code&gt;Pancakes&lt;/code&gt;. There are more fields on this struct for describing all sorts of Rust code; check the &lt;a href=&quot;https://docs.rs/syn/0.14.4/syn/struct.DeriveInput.html&quot;&gt;&lt;code&gt;syn&lt;/code&gt; documentation for &lt;code&gt;DeriveInput&lt;/code&gt;&lt;/a&gt; for more information.</source>
          <target state="translated">Поля этой структуры показывают, что код Rust, который мы проанализировали, представляет собой единичную структуру с &lt;code&gt;ident&lt;/code&gt; (идентификатором, означающим имя) &lt;code&gt;Pancakes&lt;/code&gt; . В этой структуре есть больше полей для описания всех видов кода Rust; проверить &lt;a href=&quot;https://docs.rs/syn/0.14.4/syn/struct.DeriveInput.html&quot;&gt; &lt;code&gt;syn&lt;/code&gt; документацию для &lt;code&gt;DeriveInput&lt;/code&gt; &lt;/a&gt; для получения дополнительной информации.</target>
        </trans-unit>
        <trans-unit id="b0794c80e766c7ef30098e79990a99a126d86062" translate="yes" xml:space="preserve">
          <source>The fields of this struct show that the Rust code we&amp;rsquo;ve parsed is a unit struct with the &lt;code&gt;ident&lt;/code&gt; (identifier, meaning the name) of &lt;code&gt;Pancakes&lt;/code&gt;. There are more fields on this struct for describing all sorts of Rust code; check the &lt;a href=&quot;https://docs.rs/syn/1.0/syn/struct.DeriveInput.html&quot;&gt;&lt;code&gt;syn&lt;/code&gt; documentation for &lt;code&gt;DeriveInput&lt;/code&gt;&lt;/a&gt; for more information.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="41f21e4814cce1d92447f83c7dd9a65499d60626" translate="yes" xml:space="preserve">
          <source>The file doesn't exist.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c618b2bfdd921c07e86f2a30b8c3ccd4f98ae789" translate="yes" xml:space="preserve">
          <source>The file is located relative to the current file (similarly to how modules are found).</source>
          <target state="translated">Файл расположен относительно текущего файла (аналогично тому,как находятся модули).</target>
        </trans-unit>
        <trans-unit id="0630128fbb4da19cb239333b356fc43bbab7e18f" translate="yes" xml:space="preserve">
          <source>The file is located relative to the current file (similarly to how modules are found). The provided path is interpreted in a platform-specific way at compile time. So, for instance, an invocation with a Windows path containing backslashes &lt;code&gt;\&lt;/code&gt; would not compile correctly on Unix.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a1df7519bc8cdda06f6336bd152ecc0e5b1b6c7c" translate="yes" xml:space="preserve">
          <source>The file is located relative to the current file. (similarly to how modules are found)</source>
          <target state="translated">Файл расположен относительно текущего файла.(аналогично тому,как находятся модули)</target>
        </trans-unit>
        <trans-unit id="d6c5af6a5c60f4fa56d05a0fa81955ff57e694aa" translate="yes" xml:space="preserve">
          <source>The file must be opened with write access for truncate to work.</source>
          <target state="translated">Файл должен быть открыт с доступом на запись,чтобы он работал в усеченном виде.</target>
        </trans-unit>
        <trans-unit id="b64dc47988604588017060c77446efa88568cbbc" translate="yes" xml:space="preserve">
          <source>The file must be opened with write or append access in order to create a new file.</source>
          <target state="translated">Файл должен быть открыт с доступом на запись или приложением для создания нового файла.</target>
        </trans-unit>
        <trans-unit id="55a4d79c2d543091872b4da347b5d4b201da5902" translate="yes" xml:space="preserve">
          <source>The file's cursor isn't changed. In particular, if the cursor was at the end and the file is shrunk using this operation, the cursor will now be past the end.</source>
          <target state="translated">Курсор файла не изменился.В частности,если курсор был в конце,и файл был сжат с помощью этой операции,то теперь курсор будет проходить мимо конца.</target>
        </trans-unit>
        <trans-unit id="6c8ba754d920c70b815c96a59ae89e2ab19e9615" translate="yes" xml:space="preserve">
          <source>The fill character is provided normally in conjunction with the &lt;a href=&quot;#width&quot;&gt;&lt;code&gt;width&lt;/code&gt;&lt;/a&gt; parameter. This indicates that if the value being formatted is smaller than &lt;code&gt;width&lt;/code&gt; some extra characters will be printed around it. The extra characters are specified by &lt;code&gt;fill&lt;/code&gt;, and the alignment can be one of the following options:</source>
          <target state="translated">Символ заполнения обычно предоставляется вместе с параметром &lt;a href=&quot;#width&quot;&gt; &lt;code&gt;width&lt;/code&gt; &lt;/a&gt; . Это означает, что если форматируемое значение меньше &lt;code&gt;width&lt;/code&gt; вокруг него будут напечатаны дополнительные символы. Дополнительные символы указываются &lt;code&gt;fill&lt;/code&gt; , а выравнивание может быть одним из следующих вариантов:</target>
        </trans-unit>
        <trans-unit id="93dbdf12316da4d04bf621e9eb356e67a9dd2780" translate="yes" xml:space="preserve">
          <source>The final action that works only with &lt;code&gt;unsafe&lt;/code&gt; is implementing an unsafe trait. A trait is unsafe when at least one of its methods has some invariant that the compiler can&amp;rsquo;t verify. We can declare that a trait is &lt;code&gt;unsafe&lt;/code&gt; by adding the &lt;code&gt;unsafe&lt;/code&gt; keyword before &lt;code&gt;trait&lt;/code&gt; and marking the implementation of the trait as &lt;code&gt;unsafe&lt;/code&gt; too, as shown in Listing 19-11.</source>
          <target state="translated">Последнее действие, которое работает только с &lt;code&gt;unsafe&lt;/code&gt; - это реализация свойства unsafe. Признак небезопасен, если хотя бы один из его методов имеет инвариант, который компилятор не может проверить. Мы можем объявить трейт &lt;code&gt;unsafe&lt;/code&gt; , добавив ключевое слово &lt;code&gt;unsafe&lt;/code&gt; перед &lt;code&gt;trait&lt;/code&gt; и пометив реализацию трейта как &lt;code&gt;unsafe&lt;/code&gt; , как показано в листинге 19-11.</target>
        </trans-unit>
        <trans-unit id="49a4f7cf0e0e66e3c555d75f0978be5130fe5dec" translate="yes" xml:space="preserve">
          <source>The final expression of any extending &lt;a href=&quot;expressions/block-expr&quot;&gt;block expression&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5d305704a4fbc5372e6355348bdb324639855c0b" translate="yes" xml:space="preserve">
          <source>The final line ending is optional.</source>
          <target state="translated">Окончание последней строки необязательно.</target>
        </trans-unit>
        <trans-unit id="7bcad5659fa398bc4723e1a1e4ec534359f32934" translate="yes" xml:space="preserve">
          <source>The final line ending is optional. A string that ends with a final line ending will return the same lines as an otherwise identical string without a final line ending.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d405e4ac4031d3643938bc829210c93b1a171c2a" translate="yes" xml:space="preserve">
          <source>The final line ending isn't required:</source>
          <target state="translated">Окончание последней строки не требуется:</target>
        </trans-unit>
        <trans-unit id="c5271e27e91796af655967c8ffbfa429a17a75cb" translate="yes" xml:space="preserve">
          <source>The final result could be determined just by looking at the code at compile time, so &lt;a href=&quot;https://en.wikipedia.org/wiki/Constant_folding&quot;&gt;constant folding&lt;/a&gt; might turn the whole block into a simple &lt;code&gt;println!(&quot;7 4 4&quot;)&lt;/code&gt;.</source>
          <target state="translated">Конечный результат можно определить, просто взглянув на код во время компиляции, поэтому &lt;a href=&quot;https://en.wikipedia.org/wiki/Constant_folding&quot;&gt;сворачивание констант&lt;/a&gt; может превратить весь блок в простой &lt;code&gt;println!(&quot;7 4 4&quot;)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4e59d9d4ed7f661f21e1daf6cf7e1143fd8d7bfa" translate="yes" xml:space="preserve">
          <source>The first &lt;code&gt;Cons&lt;/code&gt; value holds &lt;code&gt;1&lt;/code&gt; and another &lt;code&gt;List&lt;/code&gt; value. This &lt;code&gt;List&lt;/code&gt; value is another &lt;code&gt;Cons&lt;/code&gt; value that holds &lt;code&gt;2&lt;/code&gt; and another &lt;code&gt;List&lt;/code&gt; value. This &lt;code&gt;List&lt;/code&gt; value is one more &lt;code&gt;Cons&lt;/code&gt; value that holds &lt;code&gt;3&lt;/code&gt; and a &lt;code&gt;List&lt;/code&gt; value, which is finally &lt;code&gt;Nil&lt;/code&gt;, the non-recursive variant that signals the end of the list.</source>
          <target state="translated">Первое значение &lt;code&gt;Cons&lt;/code&gt; содержит &lt;code&gt;1&lt;/code&gt; и другое значение &lt;code&gt;List&lt;/code&gt; . Это значение &lt;code&gt;List&lt;/code&gt; является еще одним значением &lt;code&gt;Cons&lt;/code&gt; , содержащим &lt;code&gt;2&lt;/code&gt; и еще одно значение &lt;code&gt;List&lt;/code&gt; . Это значение &lt;code&gt;List&lt;/code&gt; является еще одним значением &lt;code&gt;Cons&lt;/code&gt; , содержащим &lt;code&gt;3&lt;/code&gt; , и значением &lt;code&gt;List&lt;/code&gt; , которым, наконец, является &lt;code&gt;Nil&lt;/code&gt; , нерекурсивный вариант, который сигнализирует о конце списка.</target>
        </trans-unit>
        <trans-unit id="b8427aa75fccc52f421b7262b47d3cb66ca8ba99" translate="yes" xml:space="preserve">
          <source>The first &lt;code&gt;length&lt;/code&gt; bytes at &lt;code&gt;buf&lt;/code&gt; need to be valid UTF-8.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b2f6ee38297963ecf451ec169c5ecff0bb88450f" translate="yes" xml:space="preserve">
          <source>The first argument &lt;code&gt;format!&lt;/code&gt; receives is a format string. This must be a string literal. The power of the formatting string is in the &lt;code&gt;{}&lt;/code&gt;s contained.</source>
          <target state="translated">Формат первого аргумента &lt;code&gt;format!&lt;/code&gt; получает - это строка формата. Это должен быть строковый литерал. Мощность строки форматирования заключена в содержащихся &lt;code&gt;{}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="172d64775742c02b6a5a5317561d4368b0242e63" translate="yes" xml:space="preserve">
          <source>The first argument we gave to the &lt;code&gt;assert_eq!&lt;/code&gt; macro, &lt;code&gt;4&lt;/code&gt;, is equal to the result of calling &lt;code&gt;add_two(2)&lt;/code&gt;. The line for this test is &lt;code&gt;test tests::it_adds_two ... ok&lt;/code&gt;, and the &lt;code&gt;ok&lt;/code&gt; text indicates that our test passed!</source>
          <target state="translated">Первый аргумент &lt;code&gt;assert_eq!&lt;/code&gt; макрос, &lt;code&gt;4&lt;/code&gt; , равен результату вызова &lt;code&gt;add_two(2)&lt;/code&gt; . Строка для этого теста - &lt;code&gt;test tests::it_adds_two ... ok&lt;/code&gt; , а текст &lt;code&gt;ok&lt;/code&gt; указывает, что наш тест прошел!</target>
        </trans-unit>
        <trans-unit id="3de15e9c98b000a8208779afdf2f678b58acd245" translate="yes" xml:space="preserve">
          <source>The first arm will match any point that lies on the &lt;code&gt;x&lt;/code&gt; axis by specifying that the &lt;code&gt;y&lt;/code&gt; field matches if its value matches the literal &lt;code&gt;0&lt;/code&gt;. The pattern still creates an &lt;code&gt;x&lt;/code&gt; variable that we can use in the code for this arm.</source>
          <target state="translated">Первая рука будет соответствовать любой точке, которая лежит на оси &lt;code&gt;x&lt;/code&gt; , указав, что поле &lt;code&gt;y&lt;/code&gt; совпадает, если его значение совпадает с литералом &lt;code&gt;0&lt;/code&gt; . Шаблон по-прежнему создает переменную &lt;code&gt;x&lt;/code&gt; , которую мы можем использовать в коде для этой руки.</target>
        </trans-unit>
        <trans-unit id="0d5278ef07d533df9f2058795a528bf65f8762b5" translate="yes" xml:space="preserve">
          <source>The first character is &lt;code&gt;_&lt;/code&gt;.</source>
          <target state="translated">Первый символ - &lt;code&gt;_&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6995348ce355253fb2b3997cb5b666e8341177e1" translate="yes" xml:space="preserve">
          <source>The first character is a letter.</source>
          <target state="translated">Первый иероглиф-буква.</target>
        </trans-unit>
        <trans-unit id="a8c76b012fc5c6ec5d1d2757128af41ec43b821f" translate="yes" xml:space="preserve">
          <source>The first collection type we&amp;rsquo;ll look at is &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt;, also known as a &lt;em&gt;vector&lt;/em&gt;. Vectors allow you to store more than one value in a single data structure that puts all the values next to each other in memory. Vectors can only store values of the same type. They are useful when you have a list of items, such as the lines of text in a file or the prices of items in a shopping cart.</source>
          <target state="translated">Первый тип коллекции, который мы рассмотрим, - это &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; , также известный как &lt;em&gt;вектор&lt;/em&gt; . Векторы позволяют хранить более одного значения в одной структуре данных, которая помещает все значения рядом друг с другом в памяти. Векторы могут хранить значения только одного типа. Они полезны, когда у вас есть список товаров, например строки текста в файле или цены на товары в корзине.</target>
        </trans-unit>
        <trans-unit id="428cb6a8ac810de3963e02d4205a82867bb3d81a" translate="yes" xml:space="preserve">
          <source>The first command creates a new directory called &lt;em&gt;hello_cargo&lt;/em&gt;. We&amp;rsquo;ve named our project &lt;em&gt;hello_cargo&lt;/em&gt;, and Cargo creates its files in a directory of the same name.</source>
          <target state="translated">Первая команда создает новый каталог с именем &lt;em&gt;hello_cargo&lt;/em&gt; . Мы назвали наш проект &lt;em&gt;hello_cargo&lt;/em&gt; , и Cargo создает свои файлы в каталоге с тем же именем.</target>
        </trans-unit>
        <trans-unit id="63eaa7d21eca5ee74b5e72e48aed31081f441d50" translate="yes" xml:space="preserve">
          <source>The first command, &lt;code&gt;cargo new&lt;/code&gt;, takes the name of the project (&lt;code&gt;guessing_game&lt;/code&gt;) as the first argument. The second command changes to the new project&amp;rsquo;s directory.</source>
          <target state="translated">Первая команда, &lt;code&gt;cargo new&lt;/code&gt; , принимает имя проекта ( &lt;code&gt;guessing_game&lt;/code&gt; ) в качестве первого аргумента. Вторая команда переходит в каталог нового проекта.</target>
        </trans-unit>
        <trans-unit id="0041dd0d29e2c266e11aba3af3bc7df1a46ad21b" translate="yes" xml:space="preserve">
          <source>The first element is traditionally the path of the executable, but it can be set to arbitrary text, and it may not even exist, so this property should not be relied upon for security purposes.</source>
          <target state="translated">Первым элементом традиционно является путь исполняемого файла,но он может быть установлен в произвольный текст,и его может даже не существовать,поэтому на это свойство не следует полагаться в целях безопасности.</target>
        </trans-unit>
        <trans-unit id="d1fd88a9bd4f9b97a6544f441d40f72dd7a6a337" translate="yes" xml:space="preserve">
          <source>The first element is traditionally the path of the executable, but it can be set to arbitrary text, and may not even exist. This means this property should not be relied upon for security purposes.</source>
          <target state="translated">Первым элементом традиционно является путь исполняемого файла,но он может быть установлен в произвольный текст,а может даже и не существовать.Это означает,что на это свойство не следует полагаться в целях безопасности.</target>
        </trans-unit>
        <trans-unit id="57c13dc1f835e54c634e0d373f7f324807f9c426" translate="yes" xml:space="preserve">
          <source>The first element was moved out of the array, but this is not possible because &lt;code&gt;NonCopy&lt;/code&gt; does not implement the &lt;code&gt;Copy&lt;/code&gt; trait.</source>
          <target state="translated">Первый элемент был перемещен из массива, но это невозможно, потому что &lt;code&gt;NonCopy&lt;/code&gt; не реализует трейт &lt;code&gt;Copy&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7e08bb0a99fdc3cd6e428394eb70ec134e104b16" translate="yes" xml:space="preserve">
          <source>The first enum shown is the usual kind of enum you'd find in a C-style language. The second shows off a hypothetical example of something storing location data, with &lt;code&gt;Coord&lt;/code&gt; being any other type that's needed, for example a struct. The third example demonstrates the kind of data a variant can store, ranging from nothing, to a tuple, to an anonymous struct.</source>
          <target state="translated">Первое показанное перечисление - это обычный вид перечисления, который вы найдете в языке C-стиля. Второй демонстрирует гипотетический пример того, что что-то хранит данные о местоположении, причем &lt;code&gt;Coord&lt;/code&gt; является любым другим типом, который нужен, например, структурой. Третий пример демонстрирует, какие данные может хранить вариант: от нуля до кортежа и анонимной структуры.</target>
        </trans-unit>
        <trans-unit id="356931433c23df443c1df1a79c8ba26a23e35bf5" translate="yes" xml:space="preserve">
          <source>The first error is in our &lt;code&gt;Drop&lt;/code&gt; implementation. We mentioned earlier that we intended to call &lt;code&gt;take&lt;/code&gt; on the &lt;code&gt;Option&lt;/code&gt; value to move &lt;code&gt;thread&lt;/code&gt; out of &lt;code&gt;worker&lt;/code&gt;. The following changes will do so:</source>
          <target state="translated">Первая ошибка - в нашей реализации &lt;code&gt;Drop&lt;/code&gt; . Ранее мы упоминали, что намеревались вызвать &lt;code&gt;take&lt;/code&gt; для значения &lt;code&gt;Option&lt;/code&gt; , чтобы вывести &lt;code&gt;thread&lt;/code&gt; из &lt;code&gt;worker&lt;/code&gt; . Следующие изменения сделают это:</target>
        </trans-unit>
        <trans-unit id="65b1330f4d7e9b563ff90a9ab4bea0daa6bb9857" translate="yes" xml:space="preserve">
          <source>The first invariant says that whatever actual token that comes after a matcher, if any, must be somewhere in the predetermined follow set. This ensures that a legal macro definition will continue to assign the same determination as to where &lt;code&gt;... tt&lt;/code&gt; ends and &lt;code&gt;uu ...&lt;/code&gt; begins, even as new syntactic forms are added to the language.</source>
          <target state="translated">Первый инвариант говорит, что любой фактический токен, который идет после сопоставителя, если он есть, должен быть где-то в заранее определенном последующем наборе. Это гарантирует, что допустимое определение макроса будет продолжать назначать то же определение, где &lt;code&gt;... tt&lt;/code&gt; заканчивается и &lt;code&gt;uu ...&lt;/code&gt; начинается, даже если в язык добавляются новые синтаксические формы.</target>
        </trans-unit>
        <trans-unit id="5f19def176a50d6a90af45519ada69ee7f97eb7e" translate="yes" xml:space="preserve">
          <source>The first is that it is how much memory must be allocated to store that value.</source>
          <target state="translated">Во-первых,это то,сколько памяти должно быть выделено для хранения этого значения.</target>
        </trans-unit>
        <trans-unit id="beaa6fcb1bf59defe3de830f4f2763f9980dd889" translate="yes" xml:space="preserve">
          <source>The first is to answer a specific question. If you know which chapter answers that question, you can jump to that chapter in the table of contents. Otherwise, you can press &lt;code&gt;s&lt;/code&gt; or the click the magnifying glass on the top bar to search for keywords related to your question. For example, say you wanted to know when a temporary value created in a let statement is dropped. If you didn't already know that the &lt;a href=&quot;expressions#temporaries&quot;&gt;lifetime of temporaries&lt;/a&gt; is defined in the &lt;a href=&quot;expressions&quot;&gt;expressions chapter&lt;/a&gt;, you could search &quot;temporary let&quot; and the first search result will take you to that section.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6fc0f539a4da8814ced28ee34b9432e35dbaf3f6" translate="yes" xml:space="preserve">
          <source>The first is to answer a specific question. If you know which chapter answers that question, you can jump to that chapter in the table of contents. Otherwise, you can press &lt;code&gt;s&lt;/code&gt; or the click the magnifying glass on the top bar to search for keywords related to your question. For example, say you wanted to know when a temporary value created in a let statement is dropped. If you didn't already know that the &lt;a href=&quot;expressions#temporary-lifetimes&quot;&gt;lifetime of temporaries&lt;/a&gt; is defined in the &lt;a href=&quot;expressions&quot;&gt;expressions chapter&lt;/a&gt;, you could search &quot;temporary let&quot; and the first search result will take you to that section.</source>
          <target state="translated">Первый - ответить на конкретный вопрос. Если вы знаете, какая глава отвечает на этот вопрос, вы можете перейти к этой главе в оглавлении. В противном случае вы можете нажать &lt;code&gt;s&lt;/code&gt; или щелкнуть увеличительное стекло на верхней панели для поиска ключевых слов, связанных с вашим вопросом. Например, скажем, вы хотите знать, когда временное значение, созданное в инструкции let, удаляется. Если вы еще не знали, что время &lt;a href=&quot;expressions#temporary-lifetimes&quot;&gt;жизни временных&lt;/a&gt; файлов определено в &lt;a href=&quot;expressions&quot;&gt;главе&lt;/a&gt; о выражениях , вы можете выполнить поиск по запросу &amp;laquo;временный let&amp;raquo;, и первый результат поиска приведет вас к этому разделу.</target>
        </trans-unit>
        <trans-unit id="9d5da3096efb5359ed9929a25c1646ef8f4d3a16" translate="yes" xml:space="preserve">
          <source>The first line is a &lt;em&gt;status line&lt;/em&gt; that contains the HTTP version used in the response, a numeric status code that summarizes the result of the request, and a reason phrase that provides a text description of the status code. After the CRLF sequence are any headers, another CRLF sequence, and the body of the response.</source>
          <target state="translated">Первая строка - это &lt;em&gt;строка состояния,&lt;/em&gt; которая содержит версию HTTP, используемую в ответе, числовой код состояния, который суммирует результат запроса, и фразу причины, которая предоставляет текстовое описание кода состояния. После последовательности CRLF идут любые заголовки, другая последовательность CRLF и тело ответа.</target>
        </trans-unit>
        <trans-unit id="f9ee7ff7ce4ca8fcacdd1bbbd80ae645db3e5b9c" translate="yes" xml:space="preserve">
          <source>The first line is the &lt;em&gt;request line&lt;/em&gt; that holds information about what the client is requesting. The first part of the request line indicates the &lt;em&gt;method&lt;/em&gt; being used, such as &lt;code&gt;GET&lt;/code&gt; or &lt;code&gt;POST&lt;/code&gt;, which describes how the client is making this request. Our client used a &lt;code&gt;GET&lt;/code&gt; request.</source>
          <target state="translated">Первая строка - это &lt;em&gt;строка запроса&lt;/em&gt; , содержащая информацию о том, что запрашивает клиент. Первая часть строки запроса указывает используемый &lt;em&gt;метод&lt;/em&gt; , например &lt;code&gt;GET&lt;/code&gt; или &lt;code&gt;POST&lt;/code&gt; , который описывает, как клиент выполняет этот запрос. Наш клиент использовал запрос &lt;code&gt;GET&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="81a313a5dc649f34279e079a51051be71d71d911" translate="yes" xml:space="preserve">
          <source>The first line shows a function definition, and the second line shows a fully annotated closure definition. The third line removes the type annotations from the closure definition, and the fourth line removes the brackets, which are optional because the closure body has only one expression. These are all valid definitions that will produce the same behavior when they&amp;rsquo;re called.</source>
          <target state="translated">В первой строке показано определение функции, а во второй строке - полностью аннотированное определение замыкания. Третья строка удаляет аннотации типов из определения замыкания, а четвертая строка удаляет скобки, которые являются необязательными, поскольку тело замыкания имеет только одно выражение. Все это действительные определения, которые при вызове вызывают одинаковое поведение.</target>
        </trans-unit>
        <trans-unit id="ee8e9ca51bced15f598c9116a158790ff9d282d7" translate="yes" xml:space="preserve">
          <source>The first line shows a function definition, and the second line shows a fully annotated closure definition. The third line removes the type annotations from the closure definition, and the fourth line removes the brackets, which are optional because the closure body has only one expression. These are all valid definitions that will produce the same behavior when they&amp;rsquo;re called. Calling the closures is required for &lt;code&gt;add_one_v3&lt;/code&gt; and &lt;code&gt;add_one_v4&lt;/code&gt; to be able to compile because the types will be inferred from their usage.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="98148895ad25eccad7c245ba3595f3571d1d992c" translate="yes" xml:space="preserve">
          <source>The first line, &lt;code&gt;[package]&lt;/code&gt;, is a section heading that indicates that the following statements are configuring a package. As we add more information to this file, we&amp;rsquo;ll add other sections.</source>
          <target state="translated">Первая строка, &lt;code&gt;[package]&lt;/code&gt; , - это заголовок раздела, который указывает, что следующие операторы настраивают пакет. По мере добавления дополнительной информации в этот файл мы будем добавлять и другие разделы.</target>
        </trans-unit>
        <trans-unit id="b65c034b9a1653c1664e07497c1d14736ba472ab" translate="yes" xml:space="preserve">
          <source>The first mismatching element defines which sequence is lexicographically less or greater than the other.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8b310676b3019d119c9c467f577a365e7a655455" translate="yes" xml:space="preserve">
          <source>The first new bit here is another &lt;code&gt;use&lt;/code&gt; statement, bringing a type called &lt;code&gt;std::cmp::Ordering&lt;/code&gt; into scope from the standard library. Like &lt;code&gt;Result&lt;/code&gt;, &lt;code&gt;Ordering&lt;/code&gt; is another enum, but the variants for &lt;code&gt;Ordering&lt;/code&gt; are &lt;code&gt;Less&lt;/code&gt;, &lt;code&gt;Greater&lt;/code&gt;, and &lt;code&gt;Equal&lt;/code&gt;. These are the three outcomes that are possible when you compare two values.</source>
          <target state="translated">Первый новый бит здесь - это еще один оператор &lt;code&gt;use&lt;/code&gt; , &lt;code&gt;std::cmp::Ordering&lt;/code&gt; в область видимости тип std :: cmp :: Ordering из стандартной библиотеки. Как и &lt;code&gt;Result&lt;/code&gt; , &lt;code&gt;Ordering&lt;/code&gt; - это еще одно перечисление, но варианты &lt;code&gt;Ordering&lt;/code&gt; : &lt;code&gt;Less&lt;/code&gt; , &lt;code&gt;Greater&lt;/code&gt; и &lt;code&gt;Equal&lt;/code&gt; . Это три результата, которые возможны при сравнении двух значений.</target>
        </trans-unit>
        <trans-unit id="cc86c6e2624cc3af0cff65094ba89e9de1e68ebb" translate="yes" xml:space="preserve">
          <source>The first new line defines the &lt;code&gt;response&lt;/code&gt; variable that holds the success message&amp;rsquo;s data. Then we call &lt;code&gt;as_bytes&lt;/code&gt; on our &lt;code&gt;response&lt;/code&gt; to convert the string data to bytes. The &lt;code&gt;write&lt;/code&gt; method on &lt;code&gt;stream&lt;/code&gt; takes a &lt;code&gt;&amp;amp;[u8]&lt;/code&gt; and sends those bytes directly down the connection.</source>
          <target state="translated">Первая новая строка определяет переменную &lt;code&gt;response&lt;/code&gt; которая содержит данные сообщения об успешном завершении. Затем мы вызываем &lt;code&gt;as_bytes&lt;/code&gt; в нашем &lt;code&gt;response&lt;/code&gt; чтобы преобразовать строковые данные в байты. Метод &lt;code&gt;write&lt;/code&gt; в &lt;code&gt;stream&lt;/code&gt; принимает &lt;code&gt;&amp;amp;[u8]&lt;/code&gt; и отправляет эти байты напрямую по соединению.</target>
        </trans-unit>
        <trans-unit id="155e4331405457b07f19de5018b6f05e551344c8" translate="yes" xml:space="preserve">
          <source>The first one looks much cleaner. This automatic referencing behavior works because methods have a clear receiver&amp;mdash;the type of &lt;code&gt;self&lt;/code&gt;. Given the receiver and name of a method, Rust can figure out definitively whether the method is reading (&lt;code&gt;&amp;amp;self&lt;/code&gt;), mutating (&lt;code&gt;&amp;amp;mut self&lt;/code&gt;), or consuming (&lt;code&gt;self&lt;/code&gt;). The fact that Rust makes borrowing implicit for method receivers is a big part of making ownership ergonomic in practice.</source>
          <target state="translated">Первый выглядит намного чище. Такое поведение автоматической ссылки работает, потому что у методов есть четкий получатель - тип &lt;code&gt;self&lt;/code&gt; . Учитывая получателя и имя метода, Rust может окончательно определить, является ли метод считыванием ( &lt;code&gt;&amp;amp;self&lt;/code&gt; ), изменением ( &lt;code&gt;&amp;amp;mut self&lt;/code&gt; ) или потреблением ( &lt;code&gt;self&lt;/code&gt; ). Тот факт, что Rust делает заимствование неявным образом для приемников методов, является важной частью практической эргономичности владения.</target>
        </trans-unit>
        <trans-unit id="69774098a6b4b7c12621ff37f51e96103a8b7208" translate="yes" xml:space="preserve">
          <source>The first part of the guessing game program will ask for user input, process that input, and check that the input is in the expected form. To start, we&amp;rsquo;ll allow the player to input a guess. Enter the code in Listing 2-1 into &lt;em&gt;src/main.rs&lt;/em&gt;.</source>
          <target state="translated">Первая часть программы игры в угадайку будет запрашивать ввод пользователя, обрабатывать его и проверять, находится ли ввод в ожидаемой форме. Для начала мы позволим игроку ввести предположение. Введите код в листинге 2-1 в &lt;em&gt;SRC / main.rs&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="2750d61c6d5f6fdb7cf8539aba812571a959c619" translate="yes" xml:space="preserve">
          <source>The first parts of the module system we&amp;rsquo;ll cover are packages and crates. A crate is a binary or library. The &lt;em&gt;crate root&lt;/em&gt; is a source file that the Rust compiler starts from and makes up the root module of your crate (we&amp;rsquo;ll explain modules in depth in the &lt;a href=&quot;ch07-02-defining-modules-to-control-scope-and-privacy&quot;&gt;&amp;ldquo;Defining Modules to Control Scope and Privacy&amp;rdquo;&lt;/a&gt; section). A &lt;em&gt;package&lt;/em&gt; is one or more crates that provide a set of functionality. A package contains a &lt;em&gt;Cargo.toml&lt;/em&gt; file that describes how to build those crates.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="84c014079631c14ba610d8bbfcba357c51089179" translate="yes" xml:space="preserve">
          <source>The first parts of the module system we&amp;rsquo;ll cover are packages and crates. A crate is a binary or library. The &lt;em&gt;crate root&lt;/em&gt; is a source file that the Rust compiler starts from and makes up the root module of your crate (we&amp;rsquo;ll explain modules in depth in the &lt;a href=&quot;ch07-02-defining-modules-to-control-scope-and-privacy&quot;&gt;&amp;ldquo;Defining Modules to Control Scope and Privacy&amp;rdquo;&lt;/a&gt;) section. A &lt;em&gt;package&lt;/em&gt; is one or more crates that provide a set of functionality. A package contains a &lt;em&gt;Cargo.toml&lt;/em&gt; file that describes how to build those crates.</source>
          <target state="translated">Первыми частями модульной системы, которые мы рассмотрим, являются пакеты и ящики. Ящик - это двоичный файл или библиотека. &lt;em&gt;Корень клети&lt;/em&gt; является исходным файлом, компилятор Rust начинается и составляет корневой модуль вашего ящика (мы объясним модули в глубине в &lt;a href=&quot;ch07-02-defining-modules-to-control-scope-and-privacy&quot;&gt;&amp;laquo;Defining модули для контроля Scope и конфиденциальности&amp;raquo;&lt;/a&gt; ) раздел. &lt;em&gt;Пакет&lt;/em&gt; представляет собой один или несколько ящиков , которые предоставляют набор функциональных возможностей . Пакет содержит файл &lt;em&gt;Cargo.toml,&lt;/em&gt; который описывает, как &lt;em&gt;собирать&lt;/em&gt; эти ящики.</target>
        </trans-unit>
        <trans-unit id="af7ae34fc30a5ff985eeb202b31d100b9995dad4" translate="yes" xml:space="preserve">
          <source>The first problem is that a &lt;code&gt;Cacher&lt;/code&gt; instance assumes it will always get the same value for the parameter &lt;code&gt;arg&lt;/code&gt; to the &lt;code&gt;value&lt;/code&gt; method. That is, this test of &lt;code&gt;Cacher&lt;/code&gt; will fail:</source>
          <target state="translated">Первая проблема заключается в том , что &lt;code&gt;Cacher&lt;/code&gt; экземпляр предполагает , что он всегда будет получать такое же значение для параметра &lt;code&gt;arg&lt;/code&gt; к &lt;code&gt;value&lt;/code&gt; метода. То есть этот тест &lt;code&gt;Cacher&lt;/code&gt; не удастся:</target>
        </trans-unit>
        <trans-unit id="dafa36fcdade4f5ce81d7dee337248690a10ae6d" translate="yes" xml:space="preserve">
          <source>The first purpose is similar to the second but in reverse: if you want to add a type parameter to an existing trait, you can give it a default to allow extension of the functionality of the trait without breaking the existing implementation code.</source>
          <target state="translated">Первое назначение аналогично второму,но наоборот:если вы хотите добавить параметр типа в существующий трейт,вы можете дать ему по умолчанию разрешение на расширение функциональности трейта без разрыва существующего реализационного кода.</target>
        </trans-unit>
        <trans-unit id="5f5a900754c112ed82386f584763afdd02db421d" translate="yes" xml:space="preserve">
          <source>The first rule is that each parameter that is a reference gets its own lifetime parameter. In other words, a function with one parameter gets one lifetime parameter: &lt;code&gt;fn foo&amp;lt;'a&amp;gt;(x: &amp;amp;'a i32)&lt;/code&gt;; a function with two parameters gets two separate lifetime parameters: &lt;code&gt;fn foo&amp;lt;'a, 'b&amp;gt;(x: &amp;amp;'a i32, y: &amp;amp;'b i32)&lt;/code&gt;; and so on.</source>
          <target state="translated">Первое правило состоит в том, что каждый параметр, являющийся ссылкой, получает свой собственный параметр времени жизни. Другими словами, функция с одним параметром получает один параметр времени жизни: &lt;code&gt;fn foo&amp;lt;'a&amp;gt;(x: &amp;amp;'a i32)&lt;/code&gt; ; функция с двумя параметрами получает два отдельных параметра времени жизни: &lt;code&gt;fn foo&amp;lt;'a, 'b&amp;gt;(x: &amp;amp;'a i32, y: &amp;amp;'b i32)&lt;/code&gt; ; и так далее.</target>
        </trans-unit>
        <trans-unit id="d13f338beec8e6c884aee47f7c30a9f0bc21c5c9" translate="yes" xml:space="preserve">
          <source>The first section of the output shows that the &lt;code&gt;it_works&lt;/code&gt; test in the &lt;code&gt;add-one&lt;/code&gt; crate passed. The next section shows that zero tests were found in the &lt;code&gt;adder&lt;/code&gt; crate, and then the last section shows zero documentation tests were found in the &lt;code&gt;add-one&lt;/code&gt; crate. Running &lt;code&gt;cargo test&lt;/code&gt; in a workspace structured like this one will run the tests for all the crates in the workspace.</source>
          <target state="translated">Первый раздел выходных данных показывает, что тест &lt;code&gt;it_works&lt;/code&gt; в крейте &lt;code&gt;add-one&lt;/code&gt; прошел успешно . В следующем разделе показано, что в ящике &lt;code&gt;adder&lt;/code&gt; было обнаружено ни &lt;code&gt;add-one&lt;/code&gt; теста, а в последнем разделе показано, что в ящике дополнительного устройства не было найдено ни одного теста документации . Выполнение &lt;code&gt;cargo test&lt;/code&gt; в рабочей области со структурой, подобной этой, запустит тесты для всех ящиков в рабочей области.</target>
        </trans-unit>
        <trans-unit id="1aa6d921fdf65cd84a902ac9021b32a10817790a" translate="yes" xml:space="preserve">
          <source>The first step is to build a list of candidate receiver types. Obtain these by repeatedly &lt;a href=&quot;operator-expr#the-dereference-operator&quot;&gt;dereferencing&lt;/a&gt; the receiver expression's type, adding each type encountered to the list, then finally attempting an &lt;a href=&quot;../type-coercions#unsized-coercions&quot;&gt;unsized coercion&lt;/a&gt; at the end, and adding the result type if that is successful. Then, for each candidate &lt;code&gt;T&lt;/code&gt;, add &lt;code&gt;&amp;amp;T&lt;/code&gt; and &lt;code&gt;&amp;amp;mut T&lt;/code&gt; to the list immediately after &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">Первым шагом является создание списка возможных типов приемников. Получите их, многократно &lt;a href=&quot;operator-expr#the-dereference-operator&quot;&gt;разыменуя&lt;/a&gt; тип выражения получателя, добавляя каждый встреченный тип в список, затем, наконец, пытаясь выполнить &lt;a href=&quot;../type-coercions#unsized-coercions&quot;&gt;безразмерное приведение&lt;/a&gt; в конце и добавляя тип результата, если это успешно. Затем для каждого кандидата &lt;code&gt;T&lt;/code&gt; , добавьте &lt;code&gt;&amp;amp;T&lt;/code&gt; и &lt;code&gt;&amp;amp;mut T&lt;/code&gt; в список сразу после &lt;code&gt;T&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7046b8e80cd49555b791ba84b08e3a496f0ebd34" translate="yes" xml:space="preserve">
          <source>The first step is to install Rust. We&amp;rsquo;ll download Rust through &lt;code&gt;rustup&lt;/code&gt;, a command line tool for managing Rust versions and associated tools. You&amp;rsquo;ll need an internet connection for the download.</source>
          <target state="translated">Первый шаг - установить Rust. Мы &lt;code&gt;rustup&lt;/code&gt; Rust через rustup , инструмент командной строки для управления версиями Rust и соответствующими инструментами. Для загрузки вам потребуется подключение к Интернету.</target>
        </trans-unit>
        <trans-unit id="50ad5f65969d8efb886424560b9363334f047aa4" translate="yes" xml:space="preserve">
          <source>The first store to &lt;code&gt;C&lt;/code&gt; might be moved before the store to &lt;code&gt;A&lt;/code&gt; or &lt;code&gt;B&lt;/code&gt;, &lt;em&gt;as if&lt;/em&gt; we had written &lt;code&gt;C = 4; A = 3; B = 4&lt;/code&gt;.</source>
          <target state="translated">Первый магазин в &lt;code&gt;C&lt;/code&gt; может быть перемещен раньше, чем в &lt;code&gt;A&lt;/code&gt; или &lt;code&gt;B&lt;/code&gt; , &lt;em&gt;как если бы&lt;/em&gt; мы написали &lt;code&gt;C = 4; A = 3; B = 4&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0a6ba14d6296fbc087c2dbd538a2ed25e14b36c1" translate="yes" xml:space="preserve">
          <source>The first task is to make &lt;code&gt;minigrep&lt;/code&gt; accept its two command line arguments: the filename and a string to search for. That is, we want to be able to run our program with &lt;code&gt;cargo run&lt;/code&gt;, a string to search for, and a path to a file to search in, like so:</source>
          <target state="translated">Первая задача - заставить &lt;code&gt;minigrep&lt;/code&gt; принимать два аргумента командной строки: имя файла и строку для поиска. То есть мы хотим иметь возможность запускать нашу программу с &lt;code&gt;cargo run&lt;/code&gt; , строкой для поиска и путем к файлу для поиска, например:</target>
        </trans-unit>
        <trans-unit id="31729bd9aa0c04461ab01bb63b4c75c53baddad1" translate="yes" xml:space="preserve">
          <source>The first time we call &lt;code&gt;example_closure&lt;/code&gt; with the &lt;code&gt;String&lt;/code&gt; value, the compiler infers the type of &lt;code&gt;x&lt;/code&gt; and the return type of the closure to be &lt;code&gt;String&lt;/code&gt;. Those types are then locked in to the closure in &lt;code&gt;example_closure&lt;/code&gt;, and we get a type error if we try to use a different type with the same closure.</source>
          <target state="translated">В первый раз, когда мы вызываем &lt;code&gt;example_closure&lt;/code&gt; со значением &lt;code&gt;String&lt;/code&gt; , компилятор определяет тип &lt;code&gt;x&lt;/code&gt; и возвращаемый тип закрытия как &lt;code&gt;String&lt;/code&gt; . Затем эти типы привязаны к замыканию в &lt;code&gt;example_closure&lt;/code&gt; , и мы получим ошибку типа, если попытаемся использовать другой тип с таким же замыканием.</target>
        </trans-unit>
        <trans-unit id="bd2776b4ba26113bcf03f01d82d4cc2a793fc112" translate="yes" xml:space="preserve">
          <source>The first time we call the &lt;code&gt;add_to_waitlist&lt;/code&gt; function in &lt;code&gt;eat_at_restaurant&lt;/code&gt;, we use an absolute path. The &lt;code&gt;add_to_waitlist&lt;/code&gt; function is defined in the same crate as &lt;code&gt;eat_at_restaurant&lt;/code&gt;, which means we can use the &lt;code&gt;crate&lt;/code&gt; keyword to start an absolute path.</source>
          <target state="translated">Первый раз , когда мы называем &lt;code&gt;add_to_waitlist&lt;/code&gt; функции в &lt;code&gt;eat_at_restaurant&lt;/code&gt; , мы используем абсолютный путь. Функция &lt;code&gt;add_to_waitlist&lt;/code&gt; определена в том же ящике, что и &lt;code&gt;eat_at_restaurant&lt;/code&gt; , что означает, что мы можем использовать ключевое слово &lt;code&gt;crate&lt;/code&gt; для начала абсолютного пути.</target>
        </trans-unit>
        <trans-unit id="fcbd8f43979f6a3f91b2e8d0489ac836799ae483" translate="yes" xml:space="preserve">
          <source>The first two cases are the same except for mutability. The first case states that if you have a &lt;code&gt;&amp;amp;T&lt;/code&gt;, and &lt;code&gt;T&lt;/code&gt; implements &lt;code&gt;Deref&lt;/code&gt; to some type &lt;code&gt;U&lt;/code&gt;, you can get a &lt;code&gt;&amp;amp;U&lt;/code&gt; transparently. The second case states that the same deref coercion happens for mutable references.</source>
          <target state="translated">Первые два случая такие же, за исключением изменчивости. В первом случае говорится, что если у вас есть &lt;code&gt;&amp;amp;T&lt;/code&gt; , а &lt;code&gt;T&lt;/code&gt; реализует &lt;code&gt;Deref&lt;/code&gt; для некоторого типа &lt;code&gt;U&lt;/code&gt; , вы можете получить &lt;code&gt;&amp;amp;U&lt;/code&gt; прозрачно. Во втором случае говорится, что такое же принуждение deref происходит для изменяемых ссылок.</target>
        </trans-unit>
        <trans-unit id="286885295f7366f4af40320e50ad88bb3b1732e7" translate="yes" xml:space="preserve">
          <source>The first version of the prelude of The Rust Standard Library.</source>
          <target state="translated">Первая версия прелюдии &quot;Стандартная библиотека &quot;Ржавчина&quot;.</target>
        </trans-unit>
        <trans-unit id="2833ddd57d8c251f327110ae65b75e17455b9bb3" translate="yes" xml:space="preserve">
          <source>The first will contain all indices from &lt;code&gt;[0, mid)&lt;/code&gt; (excluding the index &lt;code&gt;mid&lt;/code&gt; itself) and the second will contain all indices from &lt;code&gt;[mid, len)&lt;/code&gt; (excluding the index &lt;code&gt;len&lt;/code&gt; itself).</source>
          <target state="translated">Первый будет содержать все индексы из &lt;code&gt;[0, mid)&lt;/code&gt; (за исключением самого индекса &lt;code&gt;mid&lt;/code&gt; ), а второй будет содержать все индексы из &lt;code&gt;[mid, len)&lt;/code&gt; (за исключением самого индекса &lt;code&gt;len&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="d13813ed09799c4deb40bb4b4bb042ae0365adde" translate="yes" xml:space="preserve">
          <source>The following &lt;a href=&quot;../attributes&quot;&gt;attributes&lt;/a&gt; affect compile-time limits.</source>
          <target state="translated">Следующие &lt;a href=&quot;../attributes&quot;&gt;атрибуты&lt;/a&gt; влияют на ограничения времени компиляции.</target>
        </trans-unit>
        <trans-unit id="1c0907607a038e19917ef67594e99ddd26567897" translate="yes" xml:space="preserve">
          <source>The following &lt;a href=&quot;../attributes&quot;&gt;attributes&lt;/a&gt; are used for changing how a type can be used.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="53b431e371001b409fc98d06f983cdb135709c0f" translate="yes" xml:space="preserve">
          <source>The following &lt;a href=&quot;../attributes&quot;&gt;attributes&lt;/a&gt; are used for controlling code generation.</source>
          <target state="translated">Следующие &lt;a href=&quot;../attributes&quot;&gt;атрибуты&lt;/a&gt; используются для управления генерацией кода.</target>
        </trans-unit>
        <trans-unit id="26da618b938f5c0f34421c8ac509923a988969a6" translate="yes" xml:space="preserve">
          <source>The following &lt;a href=&quot;../attributes&quot;&gt;attributes&lt;/a&gt; are used for controlling or generating diagnostic messages during compilation.</source>
          <target state="translated">Следующие &lt;a href=&quot;../attributes&quot;&gt;атрибуты&lt;/a&gt; используются для управления или генерации диагностических сообщений во время компиляции.</target>
        </trans-unit>
        <trans-unit id="a094c614790975d250927975ec0fe6928fcd7c3a" translate="yes" xml:space="preserve">
          <source>The following &lt;a href=&quot;../attributes&quot;&gt;attributes&lt;/a&gt; are used for specifying functions for performing tests. Compiling a crate in &quot;test&quot; mode enables building the test functions along with a test harness for executing the tests. Enabling the test mode also enables the &lt;a href=&quot;../conditional-compilation#test&quot;&gt;&lt;code&gt;test&lt;/code&gt; conditional compilation option&lt;/a&gt;.</source>
          <target state="translated">Следующие &lt;a href=&quot;../attributes&quot;&gt;атрибуты&lt;/a&gt; используются для определения функций для выполнения тестов. Компиляция ящика в &amp;laquo;тестовом&amp;raquo; режиме позволяет создавать тестовые функции вместе с тестовой оснасткой для выполнения тестов. Включение тестового режима также включает &lt;a href=&quot;../conditional-compilation#test&quot;&gt;опцию условной компиляции &lt;/a&gt; &lt;code&gt;test&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c6bd6f609f21755a5a941e395bd92f148b7a32a4" translate="yes" xml:space="preserve">
          <source>The following &lt;a href=&quot;../attributes&quot;&gt;attributes&lt;/a&gt; control the behavior of external blocks.</source>
          <target state="translated">Следующие &lt;a href=&quot;../attributes&quot;&gt;атрибуты&lt;/a&gt; управляют поведением внешних блоков.</target>
        </trans-unit>
        <trans-unit id="e4c3204613b4a8b1aeaa7e0d193d03d0b636c5e8" translate="yes" xml:space="preserve">
          <source>The following &lt;code&gt;join_slices&lt;/code&gt; function is &lt;strong&gt;unsound&lt;/strong&gt; ⚠️</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="34e28a9dda5b8f30dd258681b177c05e512cb9ec" translate="yes" xml:space="preserve">
          <source>The following are examples of struct expressions:</source>
          <target state="translated">Ниже приведены примеры структурных выражений:</target>
        </trans-unit>
        <trans-unit id="0cfa813f73eeb4b3df6024040cdcdc9bf704edb3" translate="yes" xml:space="preserve">
          <source>The following code tries to return a closure directly, but it won&amp;rsquo;t compile:</source>
          <target state="translated">Следующий код пытается вернуть закрытие напрямую, но не компилируется:</target>
        </trans-unit>
        <trans-unit id="9fdd790090c328b0bac332ac3bf94fd48a22d310" translate="yes" xml:space="preserve">
          <source>The following coercions are called &lt;code&gt;unsized coercions&lt;/code&gt;, since they relate to converting sized types to unsized types, and are permitted in a few cases where other coercions are not, as described above. They can still happen anywhere else a coercion can occur.</source>
          <target state="translated">Следующие ниже приведения называются &lt;code&gt;unsized coercions&lt;/code&gt; , поскольку они относятся к преобразованию размерных типов в безразмерные типы и разрешены в некоторых случаях, когда другие приведения - нет, как описано выше. Они все еще могут происходить везде, где может произойти принуждение.</target>
        </trans-unit>
        <trans-unit id="5faa68338d0213add2f9ec4c067dc00f82eb825f" translate="yes" xml:space="preserve">
          <source>The following contexts are &lt;em&gt;place expression&lt;/em&gt; contexts:</source>
          <target state="translated">Следующие контексты являются контекстами &lt;em&gt;выражения места&lt;/em&gt; :</target>
        </trans-unit>
        <trans-unit id="a03f434198c8f12dc538595d512c2779094f1534" translate="yes" xml:space="preserve">
          <source>The following example contains a circular dependency between two traits:</source>
          <target state="translated">Следующий пример содержит круговую зависимость между двумя признаками:</target>
        </trans-unit>
        <trans-unit id="19cc88ac0ce4f5388077204fb21e73c4ffb89f2d" translate="yes" xml:space="preserve">
          <source>The following example implements &lt;code&gt;Index&lt;/code&gt; on a read-only &lt;code&gt;NucleotideCount&lt;/code&gt; container, enabling individual counts to be retrieved with index syntax.</source>
          <target state="translated">В следующем примере &lt;code&gt;Index&lt;/code&gt; реализуется для контейнера &lt;code&gt;NucleotideCount&lt;/code&gt; , доступного только для чтения , что позволяет получать отдельные счетчики с помощью синтаксиса индекса.</target>
        </trans-unit>
        <trans-unit id="1e6d78aaf2b8415e3caf24e2fa8603dbd9c8a54c" translate="yes" xml:space="preserve">
          <source>The following example showcases the fact that exclusive access to an &lt;code&gt;UnsafeCell&amp;lt;T&amp;gt;&lt;/code&gt; implies exclusive access to its &lt;code&gt;T&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b79316b13dbff6d7faf92f7fbb6c36c3b4504a1c" translate="yes" xml:space="preserve">
          <source>The following example uses &lt;a href=&quot;enum.option&quot;&gt;&lt;code&gt;Option&lt;/code&gt;&lt;/a&gt; to create an optional box of &lt;a href=&quot;../primitive.i32&quot;&gt;&lt;code&gt;i32&lt;/code&gt;&lt;/a&gt;. Notice that in order to use the inner &lt;a href=&quot;../primitive.i32&quot;&gt;&lt;code&gt;i32&lt;/code&gt;&lt;/a&gt; value first, the &lt;code&gt;check_optional&lt;/code&gt; function needs to use pattern matching to determine whether the box has a value (i.e., it is &lt;a href=&quot;enum.option#variant.Some&quot;&gt;&lt;code&gt;Some(...)&lt;/code&gt;&lt;/a&gt;) or not (&lt;a href=&quot;enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">В следующем примере &lt;a href=&quot;enum.option&quot;&gt; &lt;code&gt;Option&lt;/code&gt; &lt;/a&gt; используется для создания дополнительного блока &lt;a href=&quot;../primitive.i32&quot;&gt; &lt;code&gt;i32&lt;/code&gt; &lt;/a&gt; . Обратите внимание , что для того , чтобы использовать внутреннюю &lt;a href=&quot;../primitive.i32&quot;&gt; &lt;code&gt;i32&lt;/code&gt; &lt;/a&gt; значение первого, то &lt;code&gt;check_optional&lt;/code&gt; потребности функции для использования сопоставления с образцом , чтобы определить , имеет ли поле значение (то есть, это не &lt;a href=&quot;enum.option#variant.Some&quot;&gt; &lt;code&gt;Some(...)&lt;/code&gt; &lt;/a&gt; ) или нет ( &lt;a href=&quot;enum.option#variant.None&quot;&gt; &lt;code&gt;None&lt;/code&gt; &lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="0098b757352995332c14af09f0677dc80f9a0b00" translate="yes" xml:space="preserve">
          <source>The following expressions are constant expressions, so long as any operands are also constant expressions and do not cause any &lt;a href=&quot;destructors&quot;&gt;&lt;code&gt;Drop::drop&lt;/code&gt;&lt;/a&gt; calls to be run.</source>
          <target state="translated">Следующие ниже выражения являются постоянными выражениями, если любые операнды также являются постоянными выражениями и не вызывают выполнения каких-либо вызовов &lt;a href=&quot;destructors&quot;&gt; &lt;code&gt;Drop::drop&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="a4fd2c18c35c909a948ecc39653105d7e64c5323" translate="yes" xml:space="preserve">
          <source>The following expressions are equivalent.</source>
          <target state="translated">Следующие выражения эквивалентны.</target>
        </trans-unit>
        <trans-unit id="f79e25578dbebf348320c4abf5b91615c4d5d3bd" translate="yes" xml:space="preserve">
          <source>The following expressions can be mutable place expression contexts:</source>
          <target state="translated">Следующие выражения могут быть изменяемыми контекстами выражения места:</target>
        </trans-unit>
        <trans-unit id="0e8e60bb585909210311dad5aced6fb1ca9a2411" translate="yes" xml:space="preserve">
          <source>The following illustrates how tokens can be directly matched after matching a &lt;code&gt;tt&lt;/code&gt; fragment:</source>
          <target state="translated">Ниже показано, как токены могут быть напрямую сопоставлены после сопоставления фрагмента &lt;code&gt;tt&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="4cba4cc8b1a51987e47e31e5a3e9298ced934caa" translate="yes" xml:space="preserve">
          <source>The following is a list of the available feature names.</source>
          <target state="translated">Ниже приведен список доступных названий функций.</target>
        </trans-unit>
        <trans-unit id="7bfbc404b57ece9100ac4d9b168ae9cc179de313" translate="yes" xml:space="preserve">
          <source>The following is an example of a derive macro. Instead of doing anything useful with its input, it just appends a function &lt;code&gt;answer&lt;/code&gt;.</source>
          <target state="translated">Ниже приведен пример макроса извлечения. Вместо того, чтобы делать что-нибудь полезное со своим вводом, он просто добавляет &lt;code&gt;answer&lt;/code&gt; функции .</target>
        </trans-unit>
        <trans-unit id="cb90a0db80f40417302eef01e3aacf14fbc10a30" translate="yes" xml:space="preserve">
          <source>The following is an example of declaring &lt;code&gt;Shape&lt;/code&gt; to be a supertrait of &lt;code&gt;Circle&lt;/code&gt;.</source>
          <target state="translated">Ниже приведен пример объявления &lt;code&gt;Shape&lt;/code&gt; надстройкой &lt;code&gt;Circle&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0bc86808e703044cc02c714fea381b5d6b4eb104" translate="yes" xml:space="preserve">
          <source>The following is an index of all built-in attributes.</source>
          <target state="translated">Ниже приведен индекс всех встроенных атрибутов.</target>
        </trans-unit>
        <trans-unit id="7cc1fc6a380ba45eaa1f4f2110280733486f387c" translate="yes" xml:space="preserve">
          <source>The following is an overview of the available synchronization objects:</source>
          <target state="translated">Ниже приведен обзор доступных объектов синхронизации:</target>
        </trans-unit>
        <trans-unit id="e77d4cd3fb5ca40ba38b2400787449b1eb8f401a" translate="yes" xml:space="preserve">
          <source>The following keywords are reserved beginning in the 2018 edition.</source>
          <target state="translated">Следующие ключевые слова зарезервированы начиная с издания 2018 года.</target>
        </trans-unit>
        <trans-unit id="88a73d4d23e456f05faa46221aa0e7b9298c7349" translate="yes" xml:space="preserve">
          <source>The following keywords currently have the functionality described.</source>
          <target state="translated">Следующие ключевые слова в настоящее время имеют описанную функциональность.</target>
        </trans-unit>
        <trans-unit id="b5d973323cad12bb72185383671304dcd5ab9469" translate="yes" xml:space="preserve">
          <source>The following keywords do not have any functionality but are reserved by Rust for potential future use.</source>
          <target state="translated">Следующие ключевые слова не имеют никакой функциональности,но зарезервированы Rust для потенциального использования в будущем.</target>
        </trans-unit>
        <trans-unit id="e441a28a0807978c7d9ce6b3cf8c4bd39296d4e8" translate="yes" xml:space="preserve">
          <source>The following keywords were added beginning in the 2018 edition.</source>
          <target state="translated">Начиная с издания 2018 года были добавлены следующие ключевые слова.</target>
        </trans-unit>
        <trans-unit id="7de22ffd047d06a2d94087f0583e69c5de3c8513" translate="yes" xml:space="preserve">
          <source>The following language level features cannot be used in the safe subset of Rust:</source>
          <target state="translated">В безопасном подмножестве &quot;Ржавчина&quot; нельзя использовать следующие языковые функции:</target>
        </trans-unit>
        <trans-unit id="fa4bbe49e1fb3a478a935beaddada675b665b643" translate="yes" xml:space="preserve">
          <source>The following list contains all non-letters that don&amp;rsquo;t function as operators; that is, they don&amp;rsquo;t behave like a function or method call.</source>
          <target state="translated">Следующий список содержит все небуквенные символы, которые не работают как операторы; то есть они не ведут себя как вызов функции или метода.</target>
        </trans-unit>
        <trans-unit id="35b04ccb391eee75aac9df7cb7f1bfc81254ebee" translate="yes" xml:space="preserve">
          <source>The following list contains keywords that are reserved for current or future use by the Rust language. As such, they cannot be used as identifiers (except as raw identifiers as we&amp;rsquo;ll discuss in the &amp;ldquo;&lt;a href=&quot;#raw-identifiers&quot;&gt;Raw Identifiers&lt;/a&gt;&amp;rdquo; section), including names of functions, variables, parameters, struct fields, modules, crates, constants, macros, static values, attributes, types, traits, or lifetimes.</source>
          <target state="translated">Следующий список содержит ключевые слова, которые зарезервированы для текущего или будущего использования языком Rust. Таким образом, они не могут использоваться в качестве идентификаторов (за исключением необработанных идентификаторов, как мы обсудим в разделе &amp;laquo; &lt;a href=&quot;#raw-identifiers&quot;&gt;Необработанные идентификаторы&lt;/a&gt; &amp;raquo;), включая имена функций, переменных, параметров, полей структуры, модулей, ящиков, констант, макросов, статических значений. , атрибуты, типы, черты или время жизни.</target>
        </trans-unit>
        <trans-unit id="92af89abc5b10810cac2bde7c4403090edbb5361" translate="yes" xml:space="preserve">
          <source>The following notations are used by the &lt;em&gt;Lexer&lt;/em&gt; and &lt;em&gt;Syntax&lt;/em&gt; grammar snippets:</source>
          <target state="translated">В фрагментах грамматики &lt;em&gt;Lexer&lt;/em&gt; и &lt;em&gt;Syntax&lt;/em&gt; используются следующие обозначения :</target>
        </trans-unit>
        <trans-unit id="6c611de22c83326f1c10498c47d838ad78c2827b" translate="yes" xml:space="preserve">
          <source>The following return &lt;a href=&quot;../primitive.bool&quot;&gt;&lt;code&gt;false&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">Следующее возвращает &lt;a href=&quot;../primitive.bool&quot;&gt; &lt;code&gt;false&lt;/code&gt; &lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="1c03f7174ac895e9b31fae2f8cfc928f6b6b192e" translate="yes" xml:space="preserve">
          <source>The following return &lt;a href=&quot;https://doc.rust-lang.org/nightly/std/primitive.bool.html&quot;&gt;&lt;code&gt;false&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="452576d6c51a73e57d8181671d67361d1616b8f6" translate="yes" xml:space="preserve">
          <source>The following return false:</source>
          <target state="translated">Следующий возврат ложный:</target>
        </trans-unit>
        <trans-unit id="b857efb8bb558af5cdfcfd53ef42f4d49fe84301" translate="yes" xml:space="preserve">
          <source>The following rewritten version of &lt;code&gt;another_function&lt;/code&gt; shows what parameters look like in Rust:</source>
          <target state="translated">Следующая переписанная версия &lt;code&gt;another_function&lt;/code&gt; показывает, как выглядят параметры в Rust:</target>
        </trans-unit>
        <trans-unit id="7befecdaf697f20709a802fcb20813e2f422fba6" translate="yes" xml:space="preserve">
          <source>The following sections contain reference material you may find useful in your Rust journey.</source>
          <target state="translated">Следующие разделы содержат справочные материалы,которые Вы можете найти полезными в Вашем путешествии по Ржавчине.</target>
        </trans-unit>
        <trans-unit id="5d4dd709d05236da16b69a96983ce9c67ce45124" translate="yes" xml:space="preserve">
          <source>The following steps install the latest stable version of the Rust compiler. Rust&amp;rsquo;s stability guarantees ensure that all the examples in the book that compile will continue to compile with newer Rust versions. The output might differ slightly between versions, because Rust often improves error messages and warnings. In other words, any newer, stable version of Rust you install using these steps should work as expected with the content of this book.</source>
          <target state="translated">Следующие шаги устанавливают последнюю стабильную версию компилятора Rust. Стабильность Rust гарантирует, что все примеры в книге, которые компилируются, будут продолжать компилироваться с более новыми версиями Rust. Вывод может немного отличаться в зависимости от версии, потому что Rust часто улучшает сообщения об ошибках и предупреждения. Другими словами, любая более новая стабильная версия Rust, которую вы устанавливаете с помощью этих шагов, должна работать должным образом с содержанием этой книги.</target>
        </trans-unit>
        <trans-unit id="d23c37bf8f18aef980fb1fbefe90db0a500a0719" translate="yes" xml:space="preserve">
          <source>The following table gives the size for primitives.</source>
          <target state="translated">В следующей таблице приведен размер для примитивов.</target>
        </trans-unit>
        <trans-unit id="3bc9c0126109b1bad1345c2a1d2c68127ed67d67" translate="yes" xml:space="preserve">
          <source>The following traits are implemented for all &lt;code&gt;&amp;amp;T&lt;/code&gt;, regardless of the type of its referent:</source>
          <target state="translated">Следующие черты реализованы для всех &lt;code&gt;&amp;amp;T&lt;/code&gt; , независимо от типа его референта:</target>
        </trans-unit>
        <trans-unit id="3e9fcf457a5e9ecd7495ab63bfd0f41db2476290" translate="yes" xml:space="preserve">
          <source>The following traits are implemented on &lt;code&gt;&amp;amp;T&lt;/code&gt; references if the underlying &lt;code&gt;T&lt;/code&gt; also implements that trait:</source>
          <target state="translated">Следующие трейты реализуются в ссылках &lt;code&gt;&amp;amp;T&lt;/code&gt; если базовый &lt;code&gt;T&lt;/code&gt; также реализует этот трейт:</target>
        </trans-unit>
        <trans-unit id="be48c1df52265e0b68ec35bc1f2481219af6ad7a" translate="yes" xml:space="preserve">
          <source>The following will print &quot;Custom panic hook&quot;:</source>
          <target state="translated">Далее будет напечатано &quot;Пользовательский панический крючок&quot;:</target>
        </trans-unit>
        <trans-unit id="882019462e8fd74a5df1bf54582eb004918743ba" translate="yes" xml:space="preserve">
          <source>The following will print &quot;Normal panic&quot;:</source>
          <target state="translated">Далее будет напечатано &quot;Нормальная паника&quot;:</target>
        </trans-unit>
        <trans-unit id="7ed71896f2a34a4014ac80c7f9efbde1c744961e" translate="yes" xml:space="preserve">
          <source>The form &lt;code&gt;(..)&lt;/code&gt; with a single &lt;a href=&quot;#rest-patterns&quot;&gt;&lt;em&gt;RestPattern&lt;/em&gt;&lt;/a&gt; is a special form that does not require a comma, and matches a tuple of any size.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2a310cc6ed2f47da18129871732d4b9900992d6f" translate="yes" xml:space="preserve">
          <source>The formal way of describing this behavior is that expressions of type &lt;code&gt;!&lt;/code&gt; can be coerced into any other type. We&amp;rsquo;re allowed to end this &lt;code&gt;match&lt;/code&gt; arm with &lt;code&gt;continue&lt;/code&gt; because &lt;code&gt;continue&lt;/code&gt; doesn&amp;rsquo;t return a value; instead, it moves control back to the top of the loop, so in the &lt;code&gt;Err&lt;/code&gt; case, we never assign a value to &lt;code&gt;guess&lt;/code&gt;.</source>
          <target state="translated">Формальный способ описания этого поведения - это выражения типа &lt;code&gt;!&lt;/code&gt; может быть принужден к любому другому типу. Нам разрешено закончить эту руку &lt;code&gt;match&lt;/code&gt; с помощью &lt;code&gt;continue&lt;/code&gt; , потому что &lt;code&gt;continue&lt;/code&gt; не возвращает значение; вместо этого он перемещает управление обратно в начало цикла, поэтому в случае &lt;code&gt;Err&lt;/code&gt; мы никогда не присваиваем значение для &lt;code&gt;guess&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="99bcb45d13b51e9ae5259463fdd2a32bb1c9a90e" translate="yes" xml:space="preserve">
          <source>The full circle constant (&amp;tau;)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cd8574fedd8387c0dcc9c1aeee32062dd23e8095" translate="yes" xml:space="preserve">
          <source>The full path is created by joining the original path to &lt;code&gt;read_dir&lt;/code&gt; with the filename of this entry.</source>
          <target state="translated">Полный путь создается путем соединения исходного пути к &lt;code&gt;read_dir&lt;/code&gt; с именем файла этой записи.</target>
        </trans-unit>
        <trans-unit id="32f32b59c17ac39e46a137b79b14f93e65ff40c1" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;inner_drop&lt;/code&gt; has the type that &lt;a href=&quot;../ops/trait.drop#tymethod.drop&quot;&gt;&lt;code&gt;drop&lt;/code&gt;&lt;/a&gt;&lt;em&gt;should&lt;/em&gt; have, so this makes sure that you do not accidentally use &lt;code&gt;self&lt;/code&gt;/&lt;code&gt;this&lt;/code&gt; in a way that is in conflict with pinning.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="41bd7d7e62e02a905d152c2bd99a0375a7ed8226" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;inner_drop&lt;/code&gt; has the type that &lt;code&gt;drop&lt;/code&gt;&lt;em&gt;should&lt;/em&gt; have, so this makes sure that you do not accidentally use &lt;code&gt;self&lt;/code&gt;/&lt;code&gt;this&lt;/code&gt; in a way that is in conflict with pinning.</source>
          <target state="translated">Функция &lt;code&gt;inner_drop&lt;/code&gt; имеет тип, который &lt;em&gt;должен&lt;/em&gt; иметь &lt;code&gt;drop&lt;/code&gt; , поэтому это гарантирует, что вы случайно не используете &lt;code&gt;self&lt;/code&gt; / &lt;code&gt;this&lt;/code&gt; таким образом, который противоречит закреплению.&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="cf14d5d5cd860e1137527a26dcf1970a6fdcd6cb" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;slice::from_raw_parts_mut&lt;/code&gt; is unsafe because it takes a raw pointer and must trust that this pointer is valid. The &lt;code&gt;add&lt;/code&gt; method on raw pointers is also unsafe, because it must trust that the offset location is also a valid pointer. Therefore, we had to put an &lt;code&gt;unsafe&lt;/code&gt; block around our calls to &lt;code&gt;slice::from_raw_parts_mut&lt;/code&gt; and &lt;code&gt;add&lt;/code&gt; so we could call them. By looking at the code and by adding the assertion that &lt;code&gt;mid&lt;/code&gt; must be less than or equal to &lt;code&gt;len&lt;/code&gt;, we can tell that all the raw pointers used within the &lt;code&gt;unsafe&lt;/code&gt; block will be valid pointers to data within the slice. This is an acceptable and appropriate use of &lt;code&gt;unsafe&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bcc8f276c3240e55b6476f93fee8521728c232e7" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;slice::from_raw_parts_mut&lt;/code&gt; is unsafe because it takes a raw pointer and must trust that this pointer is valid. The &lt;code&gt;offset&lt;/code&gt; method on raw pointers is also unsafe, because it must trust that the offset location is also a valid pointer. Therefore, we had to put an &lt;code&gt;unsafe&lt;/code&gt; block around our calls to &lt;code&gt;slice::from_raw_parts_mut&lt;/code&gt; and &lt;code&gt;offset&lt;/code&gt; so we could call them. By looking at the code and by adding the assertion that &lt;code&gt;mid&lt;/code&gt; must be less than or equal to &lt;code&gt;len&lt;/code&gt;, we can tell that all the raw pointers used within the &lt;code&gt;unsafe&lt;/code&gt; block will be valid pointers to data within the slice. This is an acceptable and appropriate use of &lt;code&gt;unsafe&lt;/code&gt;.</source>
          <target state="translated">Функция &lt;code&gt;slice::from_raw_parts_mut&lt;/code&gt; небезопасна, потому что она принимает необработанный указатель и должна доверять тому, что этот указатель действителен. Метод &lt;code&gt;offset&lt;/code&gt; для необработанных указателей также небезопасен, потому что он должен быть уверен, что местоположение смещения также является допустимым указателем. Следовательно, нам пришлось поместить &lt;code&gt;unsafe&lt;/code&gt; блок вокруг наших вызовов &lt;code&gt;slice::from_raw_parts_mut&lt;/code&gt; и &lt;code&gt;offset&lt;/code&gt; , чтобы мы могли их вызывать. Посмотрев на код и добавив утверждение, что &lt;code&gt;mid&lt;/code&gt; должно быть меньше или равно &lt;code&gt;len&lt;/code&gt; , мы можем сказать, что все исходные указатели, используемые в &lt;code&gt;unsafe&lt;/code&gt; блоке, будут действительными указателями на данные внутри среза. Это приемлемое и уместное использование &lt;code&gt;unsafe&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9e2ea4196275fb1f06fa7661da10e384c365aa9f" translate="yes" xml:space="preserve">
          <source>The function body block is contained within the scope of the entire function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2cd654b546be7671958f348149444656b0175877" translate="yes" xml:space="preserve">
          <source>The function body uses the &lt;code&gt;assert_eq!&lt;/code&gt; macro to assert that 2 + 2 equals 4. This assertion serves as an example of the format for a typical test. Let&amp;rsquo;s run it to see that this test passes.</source>
          <target state="translated">В теле функции используется &lt;code&gt;assert_eq!&lt;/code&gt; макрос, подтверждающий, что 2 + 2 равно 4. Это утверждение служит примером формата для типичного теста. Давайте запустим его, чтобы убедиться, что этот тест пройден.</target>
        </trans-unit>
        <trans-unit id="fce36fec5fc1977be02dde267db493eca3e79d7a" translate="yes" xml:space="preserve">
          <source>The function must be called with valid byte array &lt;code&gt;buf&lt;/code&gt; of sufficient size to hold the message bytes. If a message is too long to fit in the supplied buffer, excess bytes may be discarded.</source>
          <target state="translated">Функция должна быть вызвана с допустимым байтовым массивом &lt;code&gt;buf&lt;/code&gt; достаточного размера для хранения байтов сообщения. Если сообщение слишком длинное, чтобы поместиться в предоставленный буфер, лишние байты могут быть отброшены.</target>
        </trans-unit>
        <trans-unit id="e529ccf733a9b5ef8b1c476a20d42d70328c6fe4" translate="yes" xml:space="preserve">
          <source>The function panics if &lt;code&gt;align&lt;/code&gt; is not a power-of-two.</source>
          <target state="translated">Функция паникует, если &lt;code&gt;align&lt;/code&gt; не является степенью двойки.</target>
        </trans-unit>
        <trans-unit id="3c4c57538d04834ae5173c38a3f23dea7037d387" translate="yes" xml:space="preserve">
          <source>The function signature now tells Rust that for some lifetime &lt;code&gt;'a&lt;/code&gt;, the function takes two parameters, both of which are string slices that live at least as long as lifetime &lt;code&gt;'a&lt;/code&gt;. The function signature also tells Rust that the string slice returned from the function will live at least as long as lifetime &lt;code&gt;'a&lt;/code&gt;. In practice, it means that the lifetime of the reference returned by the &lt;code&gt;longest&lt;/code&gt; function is the same as the smaller of the lifetimes of the references passed in. These constraints are what we want Rust to enforce. Remember, when we specify the lifetime parameters in this function signature, we&amp;rsquo;re not changing the lifetimes of any values passed in or returned. Rather, we&amp;rsquo;re specifying that the borrow checker should reject any values that don&amp;rsquo;t adhere to these constraints. Note that the &lt;code&gt;longest&lt;/code&gt; function doesn&amp;rsquo;t need to know exactly how long &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; will live, only that some scope can be substituted for &lt;code&gt;'a&lt;/code&gt; that will satisfy this signature.</source>
          <target state="translated">Сигнатура функции теперь сообщает Rust, что в течение некоторого времени жизни &lt;code&gt;'a&lt;/code&gt; функция принимает два параметра, оба из которых являются строковыми срезами, которые живут как минимум столько же, сколько время жизни &lt;code&gt;'a&lt;/code&gt; . Сигнатура функции также сообщает Rust, что фрагмент строки, возвращаемый функцией, будет существовать по крайней мере столько же, сколько времени жизни &lt;code&gt;'a&lt;/code&gt; . На практике это означает, что время жизни ссылки, возвращаемой самой &lt;code&gt;longest&lt;/code&gt; это то же самое, что и меньшее время жизни переданных ссылок. Эти ограничения - это то, что мы хотим, чтобы Rust соблюдал. Помните, что когда мы указываем параметры времени жизни в этой сигнатуре функции, мы не меняем время жизни каких-либо переданных или возвращаемых значений. Скорее, мы указываем, что средство проверки заимствований должно отклонять любые значения, которые не соответствуют этим ограничениям. Обратите внимание, что самой &lt;code&gt;longest&lt;/code&gt; функции не нужно точно знать, как долго будут жить &lt;code&gt;x&lt;/code&gt; и &lt;code&gt;y&lt;/code&gt; , только то, что некоторая область видимости может быть заменена на &lt;code&gt;'a&lt;/code&gt; , которая удовлетворяет этой сигнатуре.</target>
        </trans-unit>
        <trans-unit id="bdcb7a1c11baa13711e61ba40d7e28572f624f97" translate="yes" xml:space="preserve">
          <source>The function that defines a procedural macro takes a &lt;code&gt;TokenStream&lt;/code&gt; as an input and produces a &lt;code&gt;TokenStream&lt;/code&gt; as an output. The &lt;code&gt;TokenStream&lt;/code&gt; type is defined by the &lt;code&gt;proc_macro&lt;/code&gt; crate that is included with Rust and represents a sequence of tokens. This is the core of the macro: the source code that the macro is operating on makes up the input &lt;code&gt;TokenStream&lt;/code&gt;, and the code the macro produces is the output &lt;code&gt;TokenStream&lt;/code&gt;. The function also has an attribute attached to it that specifies which kind of procedural macro we&amp;rsquo;re creating. We can have multiple kinds of procedural macros in the same crate.</source>
          <target state="translated">Функция, определяющая процедурный макрос, принимает &lt;code&gt;TokenStream&lt;/code&gt; в качестве входных данных и создает &lt;code&gt;TokenStream&lt;/code&gt; в качестве выходных данных. Тип &lt;code&gt;TokenStream&lt;/code&gt; определяется &lt;code&gt;proc_macro&lt;/code&gt; который включен в Rust и представляет собой последовательность токенов. Это ядро ​​макроса: исходный код, с которым работает макрос, составляет входной &lt;code&gt;TokenStream&lt;/code&gt; , а код, создаваемый макросом, является выходным &lt;code&gt;TokenStream&lt;/code&gt; . Функция также имеет прикрепленный к ней атрибут, который указывает, какой процедурный макрос мы создаем. У нас может быть несколько видов процедурных макросов в одном ящике.</target>
        </trans-unit>
        <trans-unit id="bf36f24b39c35b8342b2a6251cb9fb9f153537b5" translate="yes" xml:space="preserve">
          <source>The function will never return and will immediately terminate the current process in a platform specific &quot;abnormal&quot; manner.</source>
          <target state="translated">Функция никогда не вернется и немедленно завершит текущий процесс &quot;аномальным&quot; способом,характерным для платформы.</target>
        </trans-unit>
        <trans-unit id="0c78d2fcec6d6debbe4ef0124bd9c3f517852fce" translate="yes" xml:space="preserve">
          <source>The functional record update syntax is only allowed for structs (struct-like enum variants don't qualify, for example). To fix the previous code, rewrite the expression without functional record update syntax:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4265d286c4ebab2fa68494c58f7e5472bec6ff8e" translate="yes" xml:space="preserve">
          <source>The functional record update syntax is only allowed for structs. (Struct-like enum variants don't qualify, for example.)</source>
          <target state="translated">Синтаксис обновления функциональных записей разрешен только для структур.(Например,структурно-подобные варианты перечислений не удовлетворяют требованиям).</target>
        </trans-unit>
        <trans-unit id="771371fc3674c285662522a3ce8c91121a8eb8d5" translate="yes" xml:space="preserve">
          <source>The functional record update syntax was used on something other than a struct.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3064e7a399dc1562d735ddcb75b4d1c141aa6d18" translate="yes" xml:space="preserve">
          <source>The functionality and syntax of Rust can be extended with custom definitions called macros. They are given names, and invoked through a consistent syntax:&lt;code&gt;some_extension!(...)&lt;/code&gt;.</source>
          <target state="translated">Функциональность и синтаксис Rust можно расширить с помощью пользовательских определений, называемых макросами. Им присваиваются имена, и они вызываются через &lt;code&gt;some_extension!(...)&lt;/code&gt; синтаксис: some_extension! (...) .</target>
        </trans-unit>
        <trans-unit id="90f6e5d380880e28cc22176bc452d0a2cfb51f5f" translate="yes" xml:space="preserve">
          <source>The functions inside this struct are only intended be called on the &lt;code&gt;data&lt;/code&gt; pointer of a properly constructed &lt;a href=&quot;struct.rawwaker&quot;&gt;&lt;code&gt;RawWaker&lt;/code&gt;&lt;/a&gt; object from inside the &lt;a href=&quot;struct.rawwaker&quot;&gt;&lt;code&gt;RawWaker&lt;/code&gt;&lt;/a&gt; implementation. Calling one of the contained functions using any other &lt;code&gt;data&lt;/code&gt; pointer will cause undefined behavior.</source>
          <target state="translated">Функции внутри этой структуры предназначены только быть созваны по &lt;code&gt;data&lt;/code&gt; указателя правильно построенной &lt;a href=&quot;struct.rawwaker&quot;&gt; &lt;code&gt;RawWaker&lt;/code&gt; &lt;/a&gt; объекта изнутри &lt;a href=&quot;struct.rawwaker&quot;&gt; &lt;code&gt;RawWaker&lt;/code&gt; &lt;/a&gt; реализации. Вызов одной из содержащихся функций с использованием любого другого указателя &lt;code&gt;data&lt;/code&gt; приведет к неопределенному поведению.</target>
        </trans-unit>
        <trans-unit id="5d3fe931a60678fe761ffe2bfb5b03361ca50257" translate="yes" xml:space="preserve">
          <source>The functions inside this struct are only intended to be called on the &lt;code&gt;data&lt;/code&gt; pointer of a properly constructed &lt;a href=&quot;struct.rawwaker&quot;&gt;&lt;code&gt;RawWaker&lt;/code&gt;&lt;/a&gt; object from inside the &lt;a href=&quot;struct.rawwaker&quot;&gt;&lt;code&gt;RawWaker&lt;/code&gt;&lt;/a&gt; implementation. Calling one of the contained functions using any other &lt;code&gt;data&lt;/code&gt; pointer will cause undefined behavior.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="df0966ed788f9044d3bbbf28ed214b74382d234e" translate="yes" xml:space="preserve">
          <source>The general case</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="44389c2bb8540f5071dbf79b16d89782c82ab1a7" translate="yes" xml:space="preserve">
          <source>The general categories for numbers (&lt;code&gt;Nd&lt;/code&gt; for decimal digits, &lt;code&gt;Nl&lt;/code&gt; for letter-like numeric characters, and &lt;code&gt;No&lt;/code&gt; for other numeric characters) are specified in the &lt;a href=&quot;https://www.unicode.org/reports/tr44/&quot;&gt;Unicode Character Database&lt;/a&gt;&lt;a href=&quot;https://www.unicode.org/Public/UCD/latest/ucd/UnicodeData.txt&quot;&gt;&lt;code&gt;UnicodeData.txt&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3a1ceefd46a3c1a3651802a4204c4c589bc3c7f6" translate="yes" xml:space="preserve">
          <source>The generated &lt;code&gt;impl&lt;/code&gt; for &lt;code&gt;PartialEq&lt;/code&gt; is equivalent to</source>
          <target state="translated">Сгенерированный &lt;code&gt;impl&lt;/code&gt; для &lt;code&gt;PartialEq&lt;/code&gt; эквивалентен</target>
        </trans-unit>
        <trans-unit id="b683f5ed135731413c6d034116ca989acf594401" translate="yes" xml:space="preserve">
          <source>The generator completed with a return value.</source>
          <target state="translated">Генератор заполнен возвращаемым значением.</target>
        </trans-unit>
        <trans-unit id="156bc757a593c6f0753b493e20c7157ef75917ae" translate="yes" xml:space="preserve">
          <source>The generator suspended with a value.</source>
          <target state="translated">Генератор приостановлен со значением.</target>
        </trans-unit>
        <trans-unit id="cd45c192be4dc3d892b1ef2f0b632aaff12d6653" translate="yes" xml:space="preserve">
          <source>The generic type &lt;code&gt;T&lt;/code&gt; specified as the type of the &lt;code&gt;item1&lt;/code&gt; and &lt;code&gt;item2&lt;/code&gt; parameters constrains the function such that the concrete type of the value passed as an argument for &lt;code&gt;item1&lt;/code&gt; and &lt;code&gt;item2&lt;/code&gt; must be the same.</source>
          <target state="translated">&lt;code&gt;item2&lt;/code&gt; тип &lt;code&gt;T&lt;/code&gt; , указанный как тип параметров &lt;code&gt;item1&lt;/code&gt; и item2, ограничивает функцию таким образом, что конкретный тип значения, переданного в качестве аргумента для &lt;code&gt;item1&lt;/code&gt; и &lt;code&gt;item2&lt;/code&gt; , должен быть одинаковым.</target>
        </trans-unit>
        <trans-unit id="1bc01fb3a417f3ff749e03a42ff1490b6833bd43" translate="yes" xml:space="preserve">
          <source>The generic type has to be a SIMD type. Example:</source>
          <target state="translated">Общий тип должен быть типом SIMD.Пример:</target>
        </trans-unit>
        <trans-unit id="e58faf99c3204433210564e65725762b8514494f" translate="yes" xml:space="preserve">
          <source>The given &lt;a href=&quot;../vec/struct.vec&quot;&gt;&lt;code&gt;Vec&lt;/code&gt;&lt;/a&gt;&lt;strong&gt;must&lt;/strong&gt; have one nul byte as its last element. This means it cannot be empty nor have any other nul byte anywhere else.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b25fdf4b8d15b07b7d25cece8768d803831d5b3d" translate="yes" xml:space="preserve">
          <source>The given block must have been produced by this allocator, and must be suitable for storing a &lt;code&gt;T&lt;/code&gt; (in terms of alignment as well as minimum and maximum size); otherwise yields undefined behavior.</source>
          <target state="translated">Данный блок должен быть создан этим распределителем и подходить для хранения &lt;code&gt;T&lt;/code&gt; (с точки зрения выравнивания, а также минимального и максимального размера); в противном случае дает неопределенное поведение.</target>
        </trans-unit>
        <trans-unit id="3ef7afeafd2e9737676d96a4cbd3c7dc2e9ffdbc" translate="yes" xml:space="preserve">
          <source>The glob operator is often used when testing to bring everything under test into the &lt;code&gt;tests&lt;/code&gt; module; we&amp;rsquo;ll talk about that in the &lt;a href=&quot;ch11-01-writing-tests#how-to-write-tests&quot;&gt;&amp;ldquo;How to Write Tests&amp;rdquo;&lt;/a&gt; section in Chapter 11. The glob operator is also sometimes used as part of the prelude pattern: see &lt;a href=&quot;../std/prelude/index#other-preludes&quot;&gt;the standard library documentation&lt;/a&gt; for more information on that pattern.</source>
          <target state="translated">Оператор glob часто используется при тестировании, чтобы перенести все, что тестируется, в модуль &lt;code&gt;tests&lt;/code&gt; ; мы поговорим об этом в разделе &lt;a href=&quot;ch11-01-writing-tests#how-to-write-tests&quot;&gt;&amp;laquo;Как писать тесты&amp;raquo;&lt;/a&gt; в главе 11. Оператор glob также иногда используется как часть шаблона &lt;a href=&quot;../std/prelude/index#other-preludes&quot;&gt;вступления&lt;/a&gt; : дополнительную информацию об этом шаблоне см. в документации стандартной библиотеки .</target>
        </trans-unit>
        <trans-unit id="edae830710bf3e8598def4042b918afe98bc10c2" translate="yes" xml:space="preserve">
          <source>The global memory allocator.</source>
          <target state="translated">Глобальный аллокатор памяти.</target>
        </trans-unit>
        <trans-unit id="ec4646ba1a1fdd24f47203209a1bde5837e4ed73" translate="yes" xml:space="preserve">
          <source>The good news is that if the structure &lt;em&gt;isn&amp;rsquo;t&lt;/em&gt; convenient for others to use from another library, you don&amp;rsquo;t have to rearrange your internal organization: instead, you can re-export items to make a public structure that&amp;rsquo;s different from your private structure by using &lt;code&gt;pub use&lt;/code&gt;. Re-exporting takes a public item in one location and makes it public in another location, as if it were defined in the other location instead.</source>
          <target state="translated">Хорошая новость заключается в том, что если структура из другой библиотеки &lt;em&gt;не&lt;/em&gt; удобна для использования другими, вам не нужно реорганизовывать свою внутреннюю организацию: вместо этого вы можете реэкспортировать элементы, чтобы сделать общедоступную структуру, отличную от вашей частной структуры. используя &lt;code&gt;pub use&lt;/code&gt; . При повторном экспорте общедоступный элемент в одном месте становится общедоступным в другом месте, как если бы он был определен в другом месте.</target>
        </trans-unit>
        <trans-unit id="9e529cd967841dc9eed1fc815f3a4e6b886e5b38" translate="yes" xml:space="preserve">
          <source>The grammar and lexical structure is in blockquotes with either &quot;Lexer&quot; or &quot;Syntax&quot; in &lt;sup&gt;&lt;strong&gt;bold superscript&lt;/strong&gt;&lt;/sup&gt; as the first line.</source>
          <target state="translated">Грамматика и лексическая структура заключены в &lt;sup&gt;&lt;strong&gt;кавычки,&lt;/strong&gt;&lt;/sup&gt; а в первой строке &lt;sup&gt;&lt;strong&gt;жирным надстрочным шрифтом выделены&lt;/strong&gt;&lt;/sup&gt; либо &amp;laquo;Lexer&amp;raquo;, либо &amp;laquo;Syntax&amp;raquo; .</target>
        </trans-unit>
        <trans-unit id="1f36df1235888018fbfcd5153ebfed60de89aef3" translate="yes" xml:space="preserve">
          <source>The grammar production for reference patterns has to match the token &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; to match a reference to a reference because it is a token by itself, not two &lt;code&gt;&amp;amp;&lt;/code&gt; tokens.</source>
          <target state="translated">Грамматика для ссылочных шаблонов должна соответствовать токену &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; , чтобы соответствовать ссылке на ссылку, потому что это токен сам по себе, а не два токена &lt;code&gt;&amp;amp;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ecdb2fc042ccb9955819301d5b939d1fbe330ddf" translate="yes" xml:space="preserve">
          <source>The green-threading M:N model requires a larger language runtime to manage threads. As such, the Rust standard library only provides an implementation of 1:1 threading. Because Rust is such a low-level language, there are crates that implement M:N threading if you would rather trade overhead for aspects such as more control over which threads run when and lower costs of context switching, for example.</source>
          <target state="translated">Модель M:N,использующая зеленый поток,требует большего времени исполнения на языке для управления потоками.Таким образом,стандартная библиотека Rust предоставляет только реализацию многопоточности 1:1.Поскольку Rust является столь низкоуровневым языком,существуют ящики,реализующие многопотоковую модель M:N,если вы предпочитаете торговать накладными расходами на такие аспекты,как больший контроль над тем,какие потоки выполняются,например,когда и более низкие затраты на переключение контекста.</target>
        </trans-unit>
        <trans-unit id="ebee4d45f3971e13391e35d52c5a14b0340c1efd" translate="yes" xml:space="preserve">
          <source>The handle for reading from the child's standard error (stderr), if it has been captured.</source>
          <target state="translated">Ручка для чтения со стандартной ошибки ребенка (stderr),если она была захвачена.</target>
        </trans-unit>
        <trans-unit id="71a4cc891c9774ed993ea2778e2ec4e78d46aa4f" translate="yes" xml:space="preserve">
          <source>The handle for reading from the child's standard error (stderr), if it has been captured. You might find it helpful to do</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fbdaac9b24bb1d15aadc721c15a3031cb1337d9a" translate="yes" xml:space="preserve">
          <source>The handle for reading from the child's standard output (stdout), if it has been captured.</source>
          <target state="translated">Ручка для чтения со стандартного вывода ребенка (stdout),если он был захвачен.</target>
        </trans-unit>
        <trans-unit id="5b65d5fd43c0bfac48d483d2399323a0f40fd595" translate="yes" xml:space="preserve">
          <source>The handle for reading from the child's standard output (stdout), if it has been captured. You might find it helpful to do</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d208573c971bb153ba34475100ea53bd4242537e" translate="yes" xml:space="preserve">
          <source>The handle for writing to the child's standard input (stdin), if it has been captured.</source>
          <target state="translated">Ручка для записи на стандартный вход ребенка (stdin),если она была захвачена.</target>
        </trans-unit>
        <trans-unit id="1008f723c1fd717a94e8a77d7bc5c5ff92ef4700" translate="yes" xml:space="preserve">
          <source>The handle for writing to the child's standard input (stdin), if it has been captured. To avoid partially moving the &lt;code&gt;child&lt;/code&gt; and thus blocking yourself from calling functions on &lt;code&gt;child&lt;/code&gt; while using &lt;code&gt;stdin&lt;/code&gt;, you might find it helpful:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a9febcaaba526b722c76a7ab2b805ffd862b6652" translate="yes" xml:space="preserve">
          <source>The hash map is initially created with a capacity of 0, so it will not allocate until it is first inserted into.</source>
          <target state="translated">Хэш-карта изначально создается с емкостью 0,поэтому она не будет выделяться до тех пор,пока не будет вставлена в нее в первый раз.</target>
        </trans-unit>
        <trans-unit id="ee8ffcf3c4827d14350f3675ea8e7360ee55ee19" translate="yes" xml:space="preserve">
          <source>The hash map will be able to hold at least &lt;code&gt;capacity&lt;/code&gt; elements without reallocating. If &lt;code&gt;capacity&lt;/code&gt; is 0, the hash map will not allocate.</source>
          <target state="translated">Хеш-карта сможет содержать как минимум элементы &lt;code&gt;capacity&lt;/code&gt; без перераспределения. Если &lt;code&gt;capacity&lt;/code&gt; равна 0, хэш-карта не выделяется.</target>
        </trans-unit>
        <trans-unit id="0b56c1bdca2b1b95316afe0ecdd6afdabfe66713" translate="yes" xml:space="preserve">
          <source>The hash set is also created with the default initial capacity.</source>
          <target state="translated">Набор хэшей также создается с начальной емкостью по умолчанию.</target>
        </trans-unit>
        <trans-unit id="b637bd7a31fb790788f10cfb96ebb867cfd6151d" translate="yes" xml:space="preserve">
          <source>The hash set is initially created with a capacity of 0, so it will not allocate until it is first inserted into.</source>
          <target state="translated">Набор хэшей изначально создается емкостью 0,поэтому он не будет выделяться до тех пор,пока не будет вставлен в него в первый раз.</target>
        </trans-unit>
        <trans-unit id="7b099ba43b1ded8417cfcd0145835bc5cf64881f" translate="yes" xml:space="preserve">
          <source>The hash set will be able to hold at least &lt;code&gt;capacity&lt;/code&gt; elements without reallocating. If &lt;code&gt;capacity&lt;/code&gt; is 0, the hash set will not allocate.</source>
          <target state="translated">Хэш-набор сможет содержать как минимум элементы &lt;code&gt;capacity&lt;/code&gt; без перераспределения. Если &lt;code&gt;capacity&lt;/code&gt; равна 0, хэш-набор не выделяется.</target>
        </trans-unit>
        <trans-unit id="d8a4e0ea14c5f027cfeb61abdb7d26fe519f8ab6" translate="yes" xml:space="preserve">
          <source>The hash table implementation is a Rust port of Google's &lt;a href=&quot;https://abseil.io/blog/20180927-swisstables&quot;&gt;SwissTable&lt;/a&gt;. The original C++ version of SwissTable can be found &lt;a href=&quot;https://github.com/abseil/abseil-cpp/blob/master/absl/container/internal/raw_hash_set.h&quot;&gt;here&lt;/a&gt;, and this &lt;a href=&quot;https://www.youtube.com/watch?v=ncHmEUmJZf4&quot;&gt;CppCon talk&lt;/a&gt; gives an overview of how the algorithm works.</source>
          <target state="translated">Реализация хэш-таблицы - это порт Google &lt;a href=&quot;https://abseil.io/blog/20180927-swisstables&quot;&gt;SwissTable&lt;/a&gt; на Rust . Исходную версию SwissTable на C ++ можно найти &lt;a href=&quot;https://github.com/abseil/abseil-cpp/blob/master/absl/container/internal/raw_hash_set.h&quot;&gt;здесь&lt;/a&gt; , а в этом &lt;a href=&quot;https://www.youtube.com/watch?v=ncHmEUmJZf4&quot;&gt;выступлении на CppCon&lt;/a&gt; дается обзор того, как работает алгоритм.</target>
        </trans-unit>
        <trans-unit id="415bb7e03ead8b051422fe277c860425b7ebbf61" translate="yes" xml:space="preserve">
          <source>The hashing algorithm can be replaced on a per-&lt;code&gt;HashMap&lt;/code&gt; basis using the &lt;a href=&quot;#method.default&quot;&gt;&lt;code&gt;default&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#method.with_hasher&quot;&gt;&lt;code&gt;with_hasher&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;#method.with_capacity_and_hasher&quot;&gt;&lt;code&gt;with_capacity_and_hasher&lt;/code&gt;&lt;/a&gt; methods. Many alternative algorithms are available on crates.io, such as the &lt;a href=&quot;https://crates.io/crates/fnv&quot;&gt;&lt;code&gt;fnv&lt;/code&gt;&lt;/a&gt; crate.</source>
          <target state="translated">Алгоритм хеширования может быть заменен на ослабленный &lt;code&gt;HashMap&lt;/code&gt; основе с использованием по &lt;a href=&quot;#method.default&quot;&gt; &lt;code&gt;default&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#method.with_hasher&quot;&gt; &lt;code&gt;with_hasher&lt;/code&gt; &lt;/a&gt; и &lt;a href=&quot;#method.with_capacity_and_hasher&quot;&gt; &lt;code&gt;with_capacity_and_hasher&lt;/code&gt; &lt;/a&gt; методы. На crates.io доступно множество альтернативных алгоритмов, например, &lt;a href=&quot;https://crates.io/crates/fnv&quot;&gt; &lt;code&gt;fnv&lt;/code&gt; &lt;/a&gt; crate.</target>
        </trans-unit>
        <trans-unit id="142488b9261462c1e559bf3f2ad49337e31e2ac1" translate="yes" xml:space="preserve">
          <source>The hashing algorithm can be replaced on a per-&lt;code&gt;HashMap&lt;/code&gt; basis using the &lt;a href=&quot;../../default/trait.default#tymethod.default&quot;&gt;&lt;code&gt;default&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../struct.hashmap#method.with_hasher&quot;&gt;&lt;code&gt;with_hasher&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;../struct.hashmap#method.with_capacity_and_hasher&quot;&gt;&lt;code&gt;with_capacity_and_hasher&lt;/code&gt;&lt;/a&gt; methods. Many alternative algorithms are available on crates.io, such as the &lt;a href=&quot;https://crates.io/crates/fnv&quot;&gt;&lt;code&gt;fnv&lt;/code&gt;&lt;/a&gt; crate.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="417d67f06aec820d5f0416a0fabba770f0ab5392" translate="yes" xml:space="preserve">
          <source>The hashing algorithm can be replaced on a per-&lt;code&gt;HashMap&lt;/code&gt; basis using the &lt;a href=&quot;../default/trait.default#tymethod.default&quot;&gt;&lt;code&gt;default&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;struct.hashmap#method.with_hasher&quot;&gt;&lt;code&gt;with_hasher&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;struct.hashmap#method.with_capacity_and_hasher&quot;&gt;&lt;code&gt;with_capacity_and_hasher&lt;/code&gt;&lt;/a&gt; methods. Many alternative algorithms are available on crates.io, such as the &lt;a href=&quot;https://crates.io/crates/fnv&quot;&gt;&lt;code&gt;fnv&lt;/code&gt;&lt;/a&gt; crate.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="36e2055f1b7671fa46f87316bf9cf49547025536" translate="yes" xml:space="preserve">
          <source>The heart and soul of this module is the &lt;a href=&quot;trait.iterator&quot;&gt;&lt;code&gt;Iterator&lt;/code&gt;&lt;/a&gt; trait. The core of &lt;a href=&quot;trait.iterator&quot;&gt;&lt;code&gt;Iterator&lt;/code&gt;&lt;/a&gt; looks like this:</source>
          <target state="translated">Сердце и душа этого модуля - черта &lt;a href=&quot;trait.iterator&quot;&gt; &lt;code&gt;Iterator&lt;/code&gt; &lt;/a&gt; . Ядро &lt;a href=&quot;trait.iterator&quot;&gt; &lt;code&gt;Iterator&lt;/code&gt; &lt;/a&gt; выглядит так:</target>
        </trans-unit>
        <trans-unit id="f7cf9da11ff393d577012f24f0fd7f9d800c440a" translate="yes" xml:space="preserve">
          <source>The heart of the change is that where &lt;code&gt;&amp;amp;'a Box&amp;lt;SomeTrait&amp;gt;&lt;/code&gt; used to default to &lt;code&gt;&amp;amp;'a Box&amp;lt;SomeTrait+'a&amp;gt;&lt;/code&gt;, it now defaults to &lt;code&gt;&amp;amp;'a Box&amp;lt;SomeTrait+'static&amp;gt;&lt;/code&gt; (here, &lt;code&gt;SomeTrait&lt;/code&gt; is the name of some trait type). Note that the only types which are affected are references to boxes, like &lt;code&gt;&amp;amp;Box&amp;lt;SomeTrait&amp;gt;&lt;/code&gt; or &lt;code&gt;&amp;amp;[Box&amp;lt;SomeTrait&amp;gt;]&lt;/code&gt;. More common types like &lt;code&gt;&amp;amp;SomeTrait&lt;/code&gt; or &lt;code&gt;Box&amp;lt;SomeTrait&amp;gt;&lt;/code&gt; are unaffected.</source>
          <target state="translated">Суть изменения заключается в том, что если для &lt;code&gt;&amp;amp;'a Box&amp;lt;SomeTrait&amp;gt;&lt;/code&gt; по умолчанию использовался &lt;code&gt;&amp;amp;'a Box&amp;lt;SomeTrait+'a&amp;gt;&lt;/code&gt; , теперь по умолчанию используется &lt;code&gt;&amp;amp;'a Box&amp;lt;SomeTrait+'static&amp;gt;&lt;/code&gt; (здесь &lt;code&gt;SomeTrait&lt;/code&gt; - это имя какой-то тип черты). Обратите внимание, что затрагиваются только типы ссылок на блоки, например &lt;code&gt;&amp;amp;Box&amp;lt;SomeTrait&amp;gt;&lt;/code&gt; или &lt;code&gt;&amp;amp;[Box&amp;lt;SomeTrait&amp;gt;]&lt;/code&gt; . Более распространенные типы, такие как &lt;code&gt;&amp;amp;SomeTrait&lt;/code&gt; или &lt;code&gt;Box&amp;lt;SomeTrait&amp;gt;&lt;/code&gt; , не затрагиваются.</target>
        </trans-unit>
        <trans-unit id="8b80292943879aaefba4fcd89176f25fb4fe681b" translate="yes" xml:space="preserve">
          <source>The help text reveals that the return type needs a generic lifetime parameter on it because Rust can&amp;rsquo;t tell whether the reference being returned refers to &lt;code&gt;x&lt;/code&gt; or &lt;code&gt;y&lt;/code&gt;. Actually, we don&amp;rsquo;t know either, because the &lt;code&gt;if&lt;/code&gt; block in the body of this function returns a reference to &lt;code&gt;x&lt;/code&gt; and the &lt;code&gt;else&lt;/code&gt; block returns a reference to &lt;code&gt;y&lt;/code&gt;!</source>
          <target state="translated">Текст справки показывает, что возвращаемому типу нужен общий параметр времени жизни, потому что Rust не может определить, относится ли возвращаемая ссылка к &lt;code&gt;x&lt;/code&gt; или &lt;code&gt;y&lt;/code&gt; . На самом деле мы тоже не знаем, потому что блок &lt;code&gt;if&lt;/code&gt; в теле этой функции возвращает ссылку на &lt;code&gt;x&lt;/code&gt; , а блок &lt;code&gt;else&lt;/code&gt; возвращает ссылку на &lt;code&gt;y&lt;/code&gt; !</target>
        </trans-unit>
        <trans-unit id="d58a9f4bf1938432cc316db1e69ad2bfca3de5d4" translate="yes" xml:space="preserve">
          <source>The highest valid code point a &lt;code&gt;char&lt;/code&gt; can have.</source>
          <target state="translated">Наивысшая допустимая кодовая точка, которую может иметь &lt;code&gt;char&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2c0d414ff9adc0b33c0f3d50d800e4ef1b9ec6d2" translate="yes" xml:space="preserve">
          <source>The hook is provided with a &lt;code&gt;Layout&lt;/code&gt; struct which contains information about the allocation that failed.</source>
          <target state="translated">Перехватчик снабжен структурой &lt;code&gt;Layout&lt;/code&gt; которая содержит информацию об отказе выделения.</target>
        </trans-unit>
        <trans-unit id="c05a8db594383eaa649c0ea9f1230d31e2d9d207" translate="yes" xml:space="preserve">
          <source>The hook is provided with a &lt;code&gt;PanicInfo&lt;/code&gt; struct which contains information about the origin of the panic, including the payload passed to &lt;code&gt;panic!&lt;/code&gt; and the source code location from which the panic originated.</source>
          <target state="translated">Крюк снабжен &lt;code&gt;PanicInfo&lt;/code&gt; структурой , которая содержит информацию о происхождении паники, включая полезную нагрузку передается &lt;code&gt;panic!&lt;/code&gt; и местоположение исходного кода, из которого возникла паника.</target>
        </trans-unit>
        <trans-unit id="c5e73d7bf13606a783c42b98ca4eecc2c703d2de" translate="yes" xml:space="preserve">
          <source>The identifier is more than one character. &lt;code&gt;_&lt;/code&gt; alone is not an identifier.</source>
          <target state="translated">Идентификатор состоит из более чем одного символа. &lt;code&gt;_&lt;/code&gt; сам по себе не является идентификатором.</target>
        </trans-unit>
        <trans-unit id="714243f838efe98c2e10bdbb7f1411daa3ecd7a0" translate="yes" xml:space="preserve">
          <source>The identifier is the name of the constant used in the path. The type is the type that the definition has to implement.</source>
          <target state="translated">Идентификатор-это имя константы,используемой в пути.Тип-это тип,который должно быть реализовано в определении.</target>
        </trans-unit>
        <trans-unit id="3a2c9033b8c31ad61606f019cbc00c4420b891b9" translate="yes" xml:space="preserve">
          <source>The identifier is the name of the declared type alias. The optional trait bounds must be fulfilled by the implementations of the type alias.</source>
          <target state="translated">Идентификатором является имя объявленного псевдонима типа.Необязательные границы трейта должны выполняться реализациями псевдонима типа.</target>
        </trans-unit>
        <trans-unit id="1c83f053af5e622145b3145a7189cafa0c9167a0" translate="yes" xml:space="preserve">
          <source>The identifier is the name of the function. The generics, parameter list, return type, and where clause of the associated function must be the same as the associated function declarations's.</source>
          <target state="translated">Идентификатором является имя функции.Генерики,список параметров,тип возврата,а также место,где выражение ассоциированной функции должно совпадать с объявлениями ассоциированной функции.</target>
        </trans-unit>
        <trans-unit id="c54b94a826db4a7c6ce8d411476041b69555f1aa" translate="yes" xml:space="preserve">
          <source>The identity function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a0f93995f216b848984f480fd53d07ae2b2c30e6" translate="yes" xml:space="preserve">
          <source>The idiomatic way to write a &lt;a href=&quot;trait.iterator#method.map&quot;&gt;&lt;code&gt;map&lt;/code&gt;&lt;/a&gt; for its side effects is to use a &lt;code&gt;for&lt;/code&gt; loop instead:</source>
          <target state="translated">Идиоматический способ написать &lt;a href=&quot;trait.iterator#method.map&quot;&gt; &lt;code&gt;map&lt;/code&gt; &lt;/a&gt; для ее побочных эффектов - использовать вместо этого цикл &lt;code&gt;for&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="20b4ace5ebaf142e4e8addc0656248d8010dca32" translate="yes" xml:space="preserve">
          <source>The idiomatic way to write a &lt;a href=&quot;trait.iterator#method.map&quot;&gt;&lt;code&gt;map&lt;/code&gt;&lt;/a&gt; for its side effects is to use a &lt;code&gt;for&lt;/code&gt; loop or call the &lt;a href=&quot;trait.iterator#method.for_each&quot;&gt;&lt;code&gt;for_each&lt;/code&gt;&lt;/a&gt; method:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1dc3122c538d92098d293869587f4b3a0100941a" translate="yes" xml:space="preserve">
          <source>The implementation ensures that the iterator will return exactly &lt;code&gt;len()&lt;/code&gt; more times a &lt;a href=&quot;../option/enum.option#variant.Some&quot;&gt;&lt;code&gt;Some(T)&lt;/code&gt;&lt;/a&gt; value, before returning &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt;. This method has a default implementation, so you usually should not implement it directly. However, if you can provide a more efficient implementation, you can do so. See the &lt;a href=&quot;trait.exactsizeiterator&quot;&gt;trait-level&lt;/a&gt; docs for an example.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a17be86477c61cc7613b2ed105a5af337a27c206" translate="yes" xml:space="preserve">
          <source>The implementation of &lt;code&gt;Display&lt;/code&gt; uses &lt;code&gt;self.0&lt;/code&gt; to access the inner &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt;, because &lt;code&gt;Wrapper&lt;/code&gt; is a tuple struct and &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; is the item at index 0 in the tuple. Then we can use the functionality of the &lt;code&gt;Display&lt;/code&gt; type on &lt;code&gt;Wrapper&lt;/code&gt;.</source>
          <target state="translated">Реализация &lt;code&gt;Display&lt;/code&gt; использует &lt;code&gt;self.0&lt;/code&gt; для доступа к внутреннему &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; , потому что &lt;code&gt;Wrapper&lt;/code&gt; - это структура кортежа, а &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; - это элемент с индексом 0 в кортеже. Затем мы можем использовать функциональность типа &lt;code&gt;Display&lt;/code&gt; в &lt;code&gt;Wrapper&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="64d2ca9bc84ea7c438a453f8d81beffdb2cea48b" translate="yes" xml:space="preserve">
          <source>The implementation of &lt;code&gt;get&lt;/code&gt; relies in particular on identical implementations of &lt;code&gt;Hash&lt;/code&gt; by determining the key&amp;rsquo;s hash bucket by calling &lt;code&gt;Hash::hash&lt;/code&gt; on the &lt;code&gt;Q&lt;/code&gt; value even though it inserted the key based on the hash value calculated from the &lt;code&gt;K&lt;/code&gt; value.</source>
          <target state="translated">Реализация &lt;code&gt;get&lt;/code&gt; зависит, в частности, от идентичных реализаций &lt;code&gt;Hash&lt;/code&gt; путем определения хэш-корзины ключа путем вызова &lt;code&gt;Hash::hash&lt;/code&gt; для значения &lt;code&gt;Q&lt;/code&gt; , даже если он вставил ключ на основе значения хеш-функции, вычисленного из значения &lt;code&gt;K&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9ddcc339944cbb72b0b66f63ad73cbbefd5f13bf" translate="yes" xml:space="preserve">
          <source>The implementation of this function must make sure to release any resources that are associated with this instance of a &lt;a href=&quot;struct.rawwaker&quot;&gt;&lt;code&gt;RawWaker&lt;/code&gt;&lt;/a&gt; and associated task.</source>
          <target state="translated">Реализация этой функции должна гарантировать освобождение всех ресурсов, связанных с этим экземпляром &lt;a href=&quot;struct.rawwaker&quot;&gt; &lt;code&gt;RawWaker&lt;/code&gt; &lt;/a&gt; и связанной с ним задачей.</target>
        </trans-unit>
        <trans-unit id="b2b66f02783344ac4bc18a2fce3954484c2ba8e0" translate="yes" xml:space="preserve">
          <source>The implementation of this function must retain all resources that are required for this additional instance of a &lt;a href=&quot;struct.rawwaker&quot;&gt;&lt;code&gt;RawWaker&lt;/code&gt;&lt;/a&gt; and associated task. Calling &lt;code&gt;wake&lt;/code&gt; on the resulting &lt;a href=&quot;struct.rawwaker&quot;&gt;&lt;code&gt;RawWaker&lt;/code&gt;&lt;/a&gt; should result in a wakeup of the same task that would have been awoken by the original &lt;a href=&quot;struct.rawwaker&quot;&gt;&lt;code&gt;RawWaker&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Реализация этой функции должна сохранять все ресурсы, которые требуются для этого дополнительного экземпляра &lt;a href=&quot;struct.rawwaker&quot;&gt; &lt;code&gt;RawWaker&lt;/code&gt; &lt;/a&gt; и связанной задачи. Вызов &lt;code&gt;wake&lt;/code&gt; в результирующем &lt;a href=&quot;struct.rawwaker&quot;&gt; &lt;code&gt;RawWaker&lt;/code&gt; &lt;/a&gt; должен привести к пробуждению той же задачи, которая была бы пробуждена исходным &lt;a href=&quot;struct.rawwaker&quot;&gt; &lt;code&gt;RawWaker&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="497d98f3948b6fc88a56b8970a7685389e682fb3" translate="yes" xml:space="preserve">
          <source>The implementation of waking a task on an executor.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d439e7f4f40d7bfe18d46ea25d8affbdc7117648" translate="yes" xml:space="preserve">
          <source>The implementation using the state pattern is easy to extend to add more functionality. To see the simplicity of maintaining code that uses the state pattern, try a few of these suggestions:</source>
          <target state="translated">Реализация с использованием шаблона состояния легко расширяется для добавления дополнительной функциональности.Чтобы увидеть простоту сопровождения кода,использующего шаблон состояния,попробуйте несколько из этих предложений:</target>
        </trans-unit>
        <trans-unit id="57e5372af92c8ddd71806b33dbda4afe86f48e3e" translate="yes" xml:space="preserve">
          <source>The implementing type within a &lt;a href=&quot;keyword.trait&quot;&gt;&lt;code&gt;trait&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;keyword.impl&quot;&gt;&lt;code&gt;impl&lt;/code&gt;&lt;/a&gt; block, or the current type within a type definition.</source>
          <target state="translated">&lt;a href=&quot;keyword.impl&quot;&gt; &lt;code&gt;impl&lt;/code&gt; &lt;/a&gt; тип в блоке &lt;a href=&quot;keyword.trait&quot;&gt; &lt;code&gt;trait&lt;/code&gt; &lt;/a&gt; или impl или текущий тип в определении типа.</target>
        </trans-unit>
        <trans-unit id="9972687dbff5abd8f4ecb962303ef66ce3678542" translate="yes" xml:space="preserve">
          <source>The index ranges returned by this trait are not required to exactly match those of the forward search in reverse.</source>
          <target state="translated">Диапазоны индексов,возвращаемые этим признаком,не требуются для точного совпадения с диапазонами прямого поиска в обратном направлении.</target>
        </trans-unit>
        <trans-unit id="fb8e7f22599fed31a57edfd5bc4f1d4fe1de7766" translate="yes" xml:space="preserve">
          <source>The indexed operand of an array indexing expression.</source>
          <target state="translated">Индексированный операнд выражения индексации массива.</target>
        </trans-unit>
        <trans-unit id="8a276159145a3d291ba8902040d397309a6a3910" translate="yes" xml:space="preserve">
          <source>The inferred type asks the compiler to infer the type if possible based on the surrounding information available. It cannot be used in item signatures. It is often used in generic arguments:</source>
          <target state="translated">Выведенный тип запрашивает у компилятора выводить тип,если это возможно,на основе имеющейся сопутствующей информации.Он не может быть использован в сигнатурах элементов.Часто используется в общих аргументах:</target>
        </trans-unit>
        <trans-unit id="1b63924c7210ee52ef50642e7b6012f573489c1d" translate="yes" xml:space="preserve">
          <source>The inherent methods of &lt;code&gt;Rc&lt;/code&gt; are all associated functions, which means that you have to call them as e.g., &lt;a href=&quot;#method.get_mut&quot;&gt;&lt;code&gt;Rc::get_mut(&amp;amp;mut value)&lt;/code&gt;&lt;/a&gt; instead of &lt;code&gt;value.get_mut()&lt;/code&gt;. This avoids conflicts with methods of the inner type &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">Все присущие &lt;code&gt;Rc&lt;/code&gt; методы являются связанными функциями, что означает, что вы должны вызывать их, например, как &lt;a href=&quot;#method.get_mut&quot;&gt; &lt;code&gt;Rc::get_mut(&amp;amp;mut value)&lt;/code&gt; &lt;/a&gt; вместо &lt;code&gt;value.get_mut()&lt;/code&gt; . Это позволяет избежать конфликтов с методами внутреннего типа &lt;code&gt;T&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="cdd48be31dd031602338fabd7f9987080846befd" translate="yes" xml:space="preserve">
          <source>The inherent methods of &lt;code&gt;Rc&lt;/code&gt; are all associated functions, which means that you have to call them as e.g., &lt;a href=&quot;struct.rc#method.get_mut&quot;&gt;&lt;code&gt;Rc::get_mut(&amp;amp;mut value)&lt;/code&gt;&lt;/a&gt; instead of &lt;code&gt;value.get_mut()&lt;/code&gt;. This avoids conflicts with methods of the inner type &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e9a135c5b11a6bdd25cebdf7bee36ffe6f4a888e" translate="yes" xml:space="preserve">
          <source>The initial value is the value the accumulator will have on the first call.</source>
          <target state="translated">Начальное значение-это значение,которое аккумулятор будет иметь при первом вызове.</target>
        </trans-unit>
        <trans-unit id="05cd051eb5f45770d700d15bc2c291712fe7349d" translate="yes" xml:space="preserve">
          <source>The initial value is the value the accumulator will have on the first call. If applying the closure succeeded against every element of the iterator, &lt;code&gt;try_fold()&lt;/code&gt; returns the final accumulator as success.</source>
          <target state="translated">Начальное значение - это значение, которое аккумулятор будет иметь при первом вызове. Если закрытие успешно применяется к каждому элементу итератора, &lt;code&gt;try_fold()&lt;/code&gt; возвращает последний аккумулятор как успешный.</target>
        </trans-unit>
        <trans-unit id="3215ce085488e89e5b23ed55a5028caf27292850" translate="yes" xml:space="preserve">
          <source>The initializer expression.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="005959a16886789f6cb716c2b5dc5bbb0daa12f9" translate="yes" xml:space="preserve">
          <source>The initializer of</source>
          <target state="translated">Инициализатор</target>
        </trans-unit>
        <trans-unit id="37009e2d28047124f91d44e005708dbff225d4db" translate="yes" xml:space="preserve">
          <source>The initializer of a &lt;a href=&quot;statements#let-statements&quot;&gt;let statement&lt;/a&gt;.</source>
          <target state="translated">Инициализатор оператора &lt;a href=&quot;statements#let-statements&quot;&gt;let&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="b9db1fa1a8ca22dc3f22f48be8f2cc5fef02b51c" translate="yes" xml:space="preserve">
          <source>The input &lt;a href=&quot;https://doc.rust-lang.org/proc_macro/struct.TokenStream.html&quot;&gt;&lt;code&gt;TokenStream&lt;/code&gt;&lt;/a&gt; is the token stream of the item that has the &lt;code&gt;derive&lt;/code&gt; attribute on it. The output &lt;a href=&quot;https://doc.rust-lang.org/proc_macro/struct.TokenStream.html&quot;&gt;&lt;code&gt;TokenStream&lt;/code&gt;&lt;/a&gt; must be a set of items that are then appended to the &lt;a href=&quot;items/modules&quot;&gt;module&lt;/a&gt; or &lt;a href=&quot;expressions/block-expr&quot;&gt;block&lt;/a&gt; that the item from the input &lt;a href=&quot;https://doc.rust-lang.org/proc_macro/struct.TokenStream.html&quot;&gt;&lt;code&gt;TokenStream&lt;/code&gt;&lt;/a&gt; is in.</source>
          <target state="translated">Входной &lt;a href=&quot;https://doc.rust-lang.org/proc_macro/struct.TokenStream.html&quot;&gt; &lt;code&gt;TokenStream&lt;/code&gt; &lt;/a&gt; - это токен-поток элемента, имеющего атрибут &lt;code&gt;derive&lt;/code&gt; . Выходной &lt;a href=&quot;https://doc.rust-lang.org/proc_macro/struct.TokenStream.html&quot;&gt; &lt;code&gt;TokenStream&lt;/code&gt; &lt;/a&gt; должен быть набором элементов, которые затем добавляются к &lt;a href=&quot;items/modules&quot;&gt;модулю&lt;/a&gt; или &lt;a href=&quot;expressions/block-expr&quot;&gt;блоку&lt;/a&gt; , в котором находится элемент из входного &lt;a href=&quot;https://doc.rust-lang.org/proc_macro/struct.TokenStream.html&quot;&gt; &lt;code&gt;TokenStream&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="3584f2f431d39b47066e06bb0ba2d085c77c3d1e" translate="yes" xml:space="preserve">
          <source>The input iterator &lt;code&gt;replace_with&lt;/code&gt; is only consumed when the &lt;code&gt;Splice&lt;/code&gt; value is dropped.</source>
          <target state="translated">Итератор ввода &lt;code&gt;replace_with&lt;/code&gt; используется только при &lt;code&gt;Splice&lt;/code&gt; значения Splice .</target>
        </trans-unit>
        <trans-unit id="5b45dbdf7cc3adb9c8ff29ad732df76183eebf5c" translate="yes" xml:space="preserve">
          <source>The installation of Rust also includes a copy of the documentation locally, so you can read it offline. Run &lt;code&gt;rustup doc&lt;/code&gt; to open the local documentation in your browser.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c198c64d60547785c3da652e9852896f77fa00d7" translate="yes" xml:space="preserve">
          <source>The installation script automatically adds Rust to your system PATH after your next login. If you want to start using Rust right away instead of restarting your terminal, run the following command in your shell to add Rust to your system PATH manually:</source>
          <target state="translated">Скрипт установки автоматически добавляет Rust в ваш системный PATH после вашего следующего входа в систему.Если вы хотите сразу же начать использовать Rust вместо перезагрузки терминала,запустите следующую команду в оболочке,чтобы добавить Rust в системный PATH вручную:</target>
        </trans-unit>
        <trans-unit id="a382c15195dddde8bba4823548e75c4adc802c3c" translate="yes" xml:space="preserve">
          <source>The installer also includes a copy of the documentation locally, so you can read it offline. Run &lt;code&gt;rustup doc&lt;/code&gt; to open the local documentation in your browser.</source>
          <target state="translated">Установщик также включает локальную копию документации, поэтому вы можете читать ее в автономном режиме. Запустите &lt;code&gt;rustup doc&lt;/code&gt; , чтобы открыть локальную документацию в вашем браузере.</target>
        </trans-unit>
        <trans-unit id="eb4481a6d93414e0e2ed7586ff1e0910b51585be" translate="yes" xml:space="preserve">
          <source>The integral types provide inherent methods to allow programmers explicitly to perform wrapping arithmetic. For example, &lt;code&gt;i32::wrapping_add&lt;/code&gt; provides two's complement, wrapping addition.</source>
          <target state="translated">Целочисленные типы предоставляют встроенные методы, позволяющие программистам явно выполнять арифметические операции с оболочкой. Например, &lt;code&gt;i32::wrapping_add&lt;/code&gt; обеспечивает дополнение до двух, добавление оболочки .</target>
        </trans-unit>
        <trans-unit id="a2f153ef163d784268a26bcb041875def3bd700b" translate="yes" xml:space="preserve">
          <source>The integration tests section starts with the line &lt;code&gt;Running target/debug/deps/integration_test-ce99bcc2479f4607&lt;/code&gt; (the hash at the end of your output will be different). Next, there is a line for each test function in that integration test and a summary line for the results of the integration test just before the &lt;code&gt;Doc-tests adder&lt;/code&gt; section starts.</source>
          <target state="translated">Раздел интеграционных тестов начинается со строки &lt;code&gt;Running target/debug/deps/integration_test-ce99bcc2479f4607&lt;/code&gt; (хеш в конце вашего вывода будет другим). Далее идет строка для каждой тестовой функции в этом интеграционном тесте и итоговая строка для результатов интеграционного теста непосредственно перед &lt;code&gt;Doc-tests adder&lt;/code&gt; раздела сумматора Doc-tests .</target>
        </trans-unit>
        <trans-unit id="9c8b39dac0f0603ab0205cf2bfd1df712c7506c4" translate="yes" xml:space="preserve">
          <source>The intention is that the underlying data is only valid for the lifetime &lt;code&gt;'a&lt;/code&gt;, so &lt;code&gt;Slice&lt;/code&gt; should not outlive &lt;code&gt;'a&lt;/code&gt;. However, this intent is not expressed in the code, since there are no uses of the lifetime &lt;code&gt;'a&lt;/code&gt; and hence it is not clear what data it applies to. We can correct this by telling the compiler to act &lt;em&gt;as if&lt;/em&gt; the &lt;code&gt;Slice&lt;/code&gt; struct contained a reference &lt;code&gt;&amp;amp;'a T&lt;/code&gt;:</source>
          <target state="translated">Предполагается, что базовые данные действительны только в течение времени жизни &lt;code&gt;'a&lt;/code&gt; , поэтому &lt;code&gt;Slice&lt;/code&gt; не должен &lt;code&gt;'a&lt;/code&gt; дольше a . Однако это намерение не выражено в коде, поскольку время жизни &lt;code&gt;'a&lt;/code&gt; не используется, и поэтому неясно, к каким данным оно применяется. Мы можем исправить это, указав компилятору действовать так, &lt;em&gt;как если&lt;/em&gt; бы структура &lt;code&gt;Slice&lt;/code&gt; содержала ссылку &lt;code&gt;&amp;amp;'a T&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="c6ec3ee71b429b0c861d2949630c53c1d4103ef2" translate="yes" xml:space="preserve">
          <source>The internal algorithm is not specified, and so it and its hashes should not be relied upon over releases.</source>
          <target state="translated">Внутренний алгоритм не указан,поэтому на него и на его хэши не следует полагаться поверх релизов.</target>
        </trans-unit>
        <trans-unit id="c411eb080c209397146b14ba5a4bb34e75cec138" translate="yes" xml:space="preserve">
          <source>The internal buffer is written out before returning the writer.</source>
          <target state="translated">Внутренний буфер выписывается перед возвращением записывающего устройства.</target>
        </trans-unit>
        <trans-unit id="06716cd4a735b362271ebfeb2853eaa89b39ee1b" translate="yes" xml:space="preserve">
          <source>The internal iterator over the argument has not been advanced by the time the first &lt;code&gt;{}&lt;/code&gt; is seen, so it prints the first argument. Then upon reaching the second &lt;code&gt;{}&lt;/code&gt;, the iterator has advanced forward to the second argument. Essentially, parameters that explicitly name their argument do not affect parameters that do not name an argument in terms of positional specifiers.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ce78ff22afeda7a6f00a6ca8444175752d52c4ff" translate="yes" xml:space="preserve">
          <source>The internal iterator over the argument has not been advanced by the time the first &lt;code&gt;{}&lt;/code&gt; is seen, so it prints the first argument. Then upon reaching the second &lt;code&gt;{}&lt;/code&gt;, the iterator has advanced forward to the second argument. Essentially, parameters which explicitly name their argument do not affect parameters which do not name an argument in terms of positional specifiers.</source>
          <target state="translated">Внутренний итератор по аргументу не был продвинут к моменту появления первого &lt;code&gt;{}&lt;/code&gt; , поэтому он печатает первый аргумент. Затем, достигнув второго &lt;code&gt;{}&lt;/code&gt; , итератор перешел ко второму аргументу. По сути, параметры, которые явно называют свой аргумент, не влияют на параметры, которые не именуют аргумент в терминах позиционных спецификаторов.</target>
        </trans-unit>
        <trans-unit id="2c46dda1624f616f75baf2894d6d6e54ab12f317" translate="yes" xml:space="preserve">
          <source>The inverse of this method is &lt;a href=&quot;#method.from_utf8&quot;&gt;&lt;code&gt;from_utf8&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Обратный к этому методу - &lt;a href=&quot;#method.from_utf8&quot;&gt; &lt;code&gt;from_utf8&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="dbc762f2fb2ae9279c20887c42fbcb66ef8ed68d" translate="yes" xml:space="preserve">
          <source>The inverse of this method is &lt;a href=&quot;struct.string#method.as_bytes&quot;&gt;&lt;code&gt;as_bytes&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Обратный к этому методу - &lt;a href=&quot;struct.string#method.as_bytes&quot;&gt; &lt;code&gt;as_bytes&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="2ef5a2c8bf418a538796f28bdc7b3ed8b4214bec" translate="yes" xml:space="preserve">
          <source>The inverse of this method is &lt;a href=&quot;struct.string#method.from_utf8&quot;&gt;&lt;code&gt;from_utf8&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="00033d91f205bb0450cf7878d82bad2da288007b" translate="yes" xml:space="preserve">
          <source>The inverse of this method is &lt;a href=&quot;struct.string#method.into_bytes&quot;&gt;&lt;code&gt;into_bytes&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0d5754a49ec3bccb9874e0108120d01b2fee9ec9" translate="yes" xml:space="preserve">
          <source>The issue can be resolved by changing the associated type:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2057c4ad17ebd71c1902c8394bd83a7474bbd6d5" translate="yes" xml:space="preserve">
          <source>The issue in this case is that &lt;code&gt;foo&lt;/code&gt; is defined as accepting a &lt;code&gt;Fn&lt;/code&gt; with one argument of type &lt;code&gt;String&lt;/code&gt;, but the closure we attempted to pass to it requires one arguments of type &lt;code&gt;usize&lt;/code&gt;.</source>
          <target state="translated">Проблема в этом случае заключается в том, что &lt;code&gt;foo&lt;/code&gt; определяется как принимающий &lt;code&gt;Fn&lt;/code&gt; с одним аргументом типа &lt;code&gt;String&lt;/code&gt; , но закрытие, которое мы пытались передать ему, требует одного аргумента типа &lt;code&gt;usize&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c02789dc84a563007f1b001c6388d43c1756fd64" translate="yes" xml:space="preserve">
          <source>The issue with the tuple code in Listing 4-5 is that we have to return the &lt;code&gt;String&lt;/code&gt; to the calling function so we can still use the &lt;code&gt;String&lt;/code&gt; after the call to &lt;code&gt;calculate_length&lt;/code&gt;, because the &lt;code&gt;String&lt;/code&gt; was moved into &lt;code&gt;calculate_length&lt;/code&gt;.</source>
          <target state="translated">Проблема с кодом кортежа в листинге 4-5 заключается в том, что мы должны вернуть &lt;code&gt;String&lt;/code&gt; в вызывающую функцию, чтобы мы могли использовать &lt;code&gt;String&lt;/code&gt; после вызова метода &lt;code&gt;calculate_length&lt;/code&gt; , потому что &lt;code&gt;String&lt;/code&gt; была перемещена в &lt;code&gt;calculate_length&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1013a496d8eb9ca295e23a82f7ffaec17e1ba13a" translate="yes" xml:space="preserve">
          <source>The issue with this code is evident in the signature of &lt;code&gt;area&lt;/code&gt;:</source>
          <target state="translated">Проблема с этим кодом очевидна в подписи &lt;code&gt;area&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="e382444929f7f8a00ff868439efd08f11891e2df" translate="yes" xml:space="preserve">
          <source>The items of marker traits cannot be overridden, so there's no need to have them when they cannot be changed per-type anyway. If you wanted them for ergonomic reasons, consider making an extension trait instead.</source>
          <target state="translated">Элементы признаков маркера не могут быть переопределены,поэтому нет необходимости иметь их,когда они не могут быть изменены для каждого типа в любом случае.Если они нужны вам по эргономическим соображениям,подумайте о создании признака расширения.</target>
        </trans-unit>
        <trans-unit id="5e506ce8ee681f90bb70782d8bb4d2dad5bd0685" translate="yes" xml:space="preserve">
          <source>The iterator element type is &lt;a href=&quot;../path/struct.pathbuf&quot;&gt;&lt;code&gt;PathBuf&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Тип элемента итератора - &lt;a href=&quot;../path/struct.pathbuf&quot;&gt; &lt;code&gt;PathBuf&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="6824e2e2ab7393d35f45cbd58638289d41c35be1" translate="yes" xml:space="preserve">
          <source>The iterator must produce exactly the number of elements it reported or diverge before reaching the end.</source>
          <target state="translated">Итератор должен выдать точное количество элементов,о которых он сообщил,или отклониться от них,прежде чем достигнет конца.</target>
        </trans-unit>
        <trans-unit id="857086b346b7dd5e8adf55ad86cbe1dbbf8cbe54" translate="yes" xml:space="preserve">
          <source>The iterator pattern allows you to perform some task on a sequence of items in turn. An iterator is responsible for the logic of iterating over each item and determining when the sequence has finished. When you use iterators, you don&amp;rsquo;t have to reimplement that logic yourself.</source>
          <target state="translated">Шаблон итератора позволяет вам по очереди выполнять некоторые задачи над последовательностью элементов. Итератор отвечает за логику перебора каждого элемента и определения, когда последовательность закончилась. Когда вы используете итераторы, вам не нужно заново реализовывать эту логику.</target>
        </trans-unit>
        <trans-unit id="6db07328b493618fb3fe592624d4f327dc32ce7b" translate="yes" xml:space="preserve">
          <source>The iterator reports a size hint where it is either exact (lower bound is equal to upper bound), or the upper bound is &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt;. The upper bound must only be &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt; if the actual iterator length is larger than &lt;a href=&quot;../usize/constant.max&quot;&gt;&lt;code&gt;usize::MAX&lt;/code&gt;&lt;/a&gt;. In that case, the lower bound must be &lt;a href=&quot;../usize/constant.max&quot;&gt;&lt;code&gt;usize::MAX&lt;/code&gt;&lt;/a&gt;, resulting in a &lt;a href=&quot;trait.iterator#method.size_hint&quot;&gt;&lt;code&gt;.size_hint&lt;/code&gt;&lt;/a&gt; of &lt;code&gt;(usize::MAX, None)&lt;/code&gt;.</source>
          <target state="translated">Итератор сообщает подсказку о размере, где она либо точна (нижняя граница равна верхней), либо верхняя граница - &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt; &lt;code&gt;None&lt;/code&gt; &lt;/a&gt; . Верхняя граница должна быть &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt; &lt;code&gt;None&lt;/code&gt; &lt;/a&gt; только в том случае, если фактическая длина итератора больше, чем &lt;a href=&quot;../usize/constant.max&quot;&gt; &lt;code&gt;usize::MAX&lt;/code&gt; &lt;/a&gt; . В этом случае нижняя граница должна быть &lt;a href=&quot;../usize/constant.max&quot;&gt; &lt;code&gt;usize::MAX&lt;/code&gt; &lt;/a&gt; , в результате чего &lt;a href=&quot;trait.iterator#method.size_hint&quot;&gt; &lt;code&gt;.size_hint&lt;/code&gt; &lt;/a&gt; из &lt;code&gt;(usize::MAX, None)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="761f99bb11c75b1d69af8441ba4ad3812f9ffc53" translate="yes" xml:space="preserve">
          <source>The iterator reports a size hint where it is either exact (lower bound is equal to upper bound), or the upper bound is &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt;. The upper bound must only be &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt; if the actual iterator length is larger than &lt;a href=&quot;../usize/constant.max&quot;&gt;&lt;code&gt;usize::MAX&lt;/code&gt;&lt;/a&gt;. In that case, the lower bound must be &lt;a href=&quot;../usize/constant.max&quot;&gt;&lt;code&gt;usize::MAX&lt;/code&gt;&lt;/a&gt;, resulting in a &lt;a href=&quot;trait.iterator#method.size_hint&quot;&gt;&lt;code&gt;Iterator::size_hint()&lt;/code&gt;&lt;/a&gt; of &lt;code&gt;(usize::MAX, None)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f5b68d7a8101dc216e0d59f65c1ebaa471e720b2" translate="yes" xml:space="preserve">
          <source>The iterator returned from this function will return instances of &lt;a href=&quot;type.result&quot;&gt;&lt;code&gt;io::Result&lt;/code&gt;&lt;/a&gt;&lt;code&gt;&amp;lt;&lt;/code&gt;&lt;a href=&quot;../vec/struct.vec&quot;&gt;&lt;code&gt;Vec&amp;lt;u8&amp;gt;&lt;/code&gt;&lt;/a&gt;&lt;code&gt;&amp;gt;&lt;/code&gt;. Each vector returned will &lt;em&gt;not&lt;/em&gt; have the delimiter byte at the end.</source>
          <target state="translated">Итератор, возвращенный этой функцией, вернет экземпляры &lt;a href=&quot;type.result&quot;&gt; &lt;code&gt;io::Result&lt;/code&gt; &lt;/a&gt; &lt;code&gt;&amp;lt;&lt;/code&gt; &lt;a href=&quot;../vec/struct.vec&quot;&gt; &lt;code&gt;Vec&amp;lt;u8&amp;gt;&lt;/code&gt; &lt;/a&gt; &lt;code&gt;&amp;gt;&lt;/code&gt; . Каждый возвращаемый вектор &lt;em&gt;не&lt;/em&gt; будет иметь байта-разделителя в конце.</target>
        </trans-unit>
        <trans-unit id="43d518530c9a6385f97f5ea0cf3b95e6447ddfae" translate="yes" xml:space="preserve">
          <source>The iterator returned from this function will yield instances of &lt;a href=&quot;type.result&quot;&gt;&lt;code&gt;io::Result&lt;/code&gt;&lt;/a&gt;&lt;code&gt;&amp;lt;&lt;/code&gt;&lt;a href=&quot;../string/struct.string&quot;&gt;&lt;code&gt;String&lt;/code&gt;&lt;/a&gt;&lt;code&gt;&amp;gt;&lt;/code&gt;. Each string returned will &lt;em&gt;not&lt;/em&gt; have a newline byte (the 0xA byte) or CRLF (0xD, 0xA bytes) at the end.</source>
          <target state="translated">Итератор, возвращенный этой функцией, даст экземпляры &lt;a href=&quot;type.result&quot;&gt; &lt;code&gt;io::Result&lt;/code&gt; &lt;/a&gt; &lt;code&gt;&amp;lt;&lt;/code&gt; &lt;a href=&quot;../string/struct.string&quot;&gt; &lt;code&gt;String&lt;/code&gt; &lt;/a&gt; &lt;code&gt;&amp;gt;&lt;/code&gt; . Каждая возвращенная строка &lt;em&gt;не&lt;/em&gt; будет иметь в конце байта новой строки (байта 0xA) или CRLF (байта 0xD, 0xA).</target>
        </trans-unit>
        <trans-unit id="11be39dc954e81f8e71f68fa0b756ad22ee17df7" translate="yes" xml:space="preserve">
          <source>The iterator returned from this function will yield instances of &lt;a href=&quot;type.result&quot;&gt;&lt;code&gt;io::Result&lt;/code&gt;&lt;/a&gt;&lt;code&gt;&amp;lt;&lt;/code&gt;&lt;a href=&quot;../string/struct.string&quot;&gt;&lt;code&gt;String&lt;/code&gt;&lt;/a&gt;&lt;code&gt;&amp;gt;&lt;/code&gt;. Each string returned will &lt;em&gt;not&lt;/em&gt; have a newline byte (the &lt;code&gt;0xA&lt;/code&gt; byte) or &lt;code&gt;CRLF&lt;/code&gt; (&lt;code&gt;0xD&lt;/code&gt;, &lt;code&gt;0xA&lt;/code&gt; bytes) at the end.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d98222c90db1c99a084846a0ad925665e5230738" translate="yes" xml:space="preserve">
          <source>The iterator returned will return string slices that are sub-slices of the original string slice, separated by any amount of ASCII whitespace.</source>
          <target state="translated">Возвращаемый итератор вернет фрагменты строки,являющиеся субликами исходного фрагмента строки,разделенными любым количеством пробельных символов ASCII.</target>
        </trans-unit>
        <trans-unit id="406100c150ec04008e29a14c30e99aed0f63af21" translate="yes" xml:space="preserve">
          <source>The iterator returned will return string slices that are sub-slices of the original string slice, separated by any amount of whitespace.</source>
          <target state="translated">Возвращаемый итератор вернет фрагменты строки,являющиеся субликами исходного фрагмента строки,разделенными любым количеством пробельных символов.</target>
        </trans-unit>
        <trans-unit id="4221546e7793ded4aa41dc1718c0ee56c99339b5" translate="yes" xml:space="preserve">
          <source>The iterator returned yields pairs &lt;code&gt;(i, val)&lt;/code&gt;, where &lt;code&gt;i&lt;/code&gt; is the current index of iteration and &lt;code&gt;val&lt;/code&gt; is the value returned by the iterator.</source>
          <target state="translated">Возвращенный итератором возвращает пары &lt;code&gt;(i, val)&lt;/code&gt; , где &lt;code&gt;i&lt;/code&gt; - текущий индекс итерации, а &lt;code&gt;val&lt;/code&gt; - значение, возвращаемое итератором.</target>
        </trans-unit>
        <trans-unit id="0d65a2fef7d4c6664fcfb9659495ac349d06a758" translate="yes" xml:space="preserve">
          <source>The iterator starts with the given first item (if any) and calls the given &lt;code&gt;FnMut(&amp;amp;T) -&amp;gt; Option&amp;lt;T&amp;gt;&lt;/code&gt; closure to compute each item&amp;rsquo;s successor.</source>
          <target state="translated">Итератор начинается с данного первого элемента (если есть) и вызывает данное &lt;code&gt;FnMut(&amp;amp;T) -&amp;gt; Option&amp;lt;T&amp;gt;&lt;/code&gt; для вычисления преемника каждого элемента.</target>
        </trans-unit>
        <trans-unit id="fe7ef8d083d96a8372351bad5e0da1e04819839b" translate="yes" xml:space="preserve">
          <source>The iterator version was slightly faster! We won&amp;rsquo;t explain the benchmark code here, because the point is not to prove that the two versions are equivalent but to get a general sense of how these two implementations compare performance-wise.</source>
          <target state="translated">Версия итератора была немного быстрее! Мы не будем объяснять здесь тестовый код, потому что цель не в том, чтобы доказать, что две версии эквивалентны, а в том, чтобы получить общее представление о том, как эти две реализации сравниваются с точки зрения производительности.</target>
        </trans-unit>
        <trans-unit id="40a9eac2c27490989d9bce69b525d51e8393ef6d" translate="yes" xml:space="preserve">
          <source>The iterator will never return &lt;a href=&quot;../../../option/enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt; and will also not yield the peer's &lt;a href=&quot;struct.socketaddr&quot;&gt;&lt;code&gt;SocketAddr&lt;/code&gt;&lt;/a&gt; structure.</source>
          <target state="translated">Итератор никогда не вернет &lt;a href=&quot;../../../option/enum.option#variant.None&quot;&gt; &lt;code&gt;None&lt;/code&gt; ,&lt;/a&gt; а также не &lt;a href=&quot;struct.socketaddr&quot;&gt; &lt;code&gt;SocketAddr&lt;/code&gt; &lt;/a&gt; структуру SocketAddr партнера .</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
