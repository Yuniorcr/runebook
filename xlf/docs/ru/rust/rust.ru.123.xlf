<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ru" datatype="htmlbody" original="rust">
    <body>
      <group id="rust">
        <trans-unit id="3a4be906ba1df5fea075ac60c84354ab807a7ba2" translate="yes" xml:space="preserve">
          <source>Note: In the edge case where you're seeking with &lt;code&gt;SeekFrom::Current(n)&lt;/code&gt; where &lt;code&gt;n&lt;/code&gt; minus the internal buffer length overflows an &lt;code&gt;i64&lt;/code&gt;, two seeks will be performed instead of one. If the second seek returns &lt;code&gt;Err&lt;/code&gt;, the underlying reader will be left at the same position it would have if you called &lt;code&gt;seek&lt;/code&gt; with &lt;code&gt;SeekFrom::Current(0)&lt;/code&gt;.</source>
          <target state="translated">Примечание. В &lt;code&gt;SeekFrom::Current(n)&lt;/code&gt; случае, когда вы ищите с помощью SeekFrom :: Current (n), где &lt;code&gt;n&lt;/code&gt; минус длина внутреннего буфера переполняет &lt;code&gt;i64&lt;/code&gt; , будут выполняться два поиска вместо одного. Если второй поиск возвращает &lt;code&gt;Err&lt;/code&gt; , базовый считыватель останется в том же положении, что и при вызове &lt;code&gt;SeekFrom::Current(0)&lt;/code&gt; &lt;code&gt;seek&lt;/code&gt; с помощью SeekFrom :: Current (0) .</target>
        </trans-unit>
        <trans-unit id="ffeb95a03330faff30434eb464fab2ecfe395aa0" translate="yes" xml:space="preserve">
          <source>Note: It is idiomatic to use a &lt;a href=&quot;../statements#let-statements&quot;&gt;let statement&lt;/a&gt; with a pattern of &lt;code&gt;_&lt;/code&gt; when a must-used value is purposely discarded.</source>
          <target state="translated">Примечание. Идиоматично использовать оператор &lt;a href=&quot;../statements#let-statements&quot;&gt;let&lt;/a&gt; с шаблоном &lt;code&gt;_&lt;/code&gt; , когда обязательное значение намеренно отбрасывается.</target>
        </trans-unit>
        <trans-unit id="a98353ad4c2ea48db43b41e0a837834f6a8b30a0" translate="yes" xml:space="preserve">
          <source>Note: Lifetimes can be and usually are elided with this shorthand.</source>
          <target state="translated">Примечание:Скорость жизни может быть и,как правило,не учитывается при написании этого сокращения.</target>
        </trans-unit>
        <trans-unit id="9458a465758bdea1aa806edbdf38d0829ff7abbc" translate="yes" xml:space="preserve">
          <source>Note: Multiple matches using the &lt;code&gt;|&lt;/code&gt; operator can cause the pattern guard and the side effects it has to execute multiple times. For example:</source>
          <target state="translated">Примечание: множественные совпадения с использованием &lt;code&gt;|&lt;/code&gt; Оператор может вызвать защиту шаблона и побочные эффекты, которые он должен выполнять несколько раз. Например:</target>
        </trans-unit>
        <trans-unit id="b48aac9382dceff2ad2732e0844fc1d124e5afbe" translate="yes" xml:space="preserve">
          <source>Note: String slice range indices must occur at valid UTF-8 character boundaries. If you attempt to create a string slice in the middle of a multibyte character, your program will exit with an error. For the purposes of introducing string slices, we are assuming ASCII only in this section; a more thorough discussion of UTF-8 handling is in the &lt;a href=&quot;ch08-02-strings#storing-utf-8-encoded-text-with-strings&quot;&gt;&amp;ldquo;Storing UTF-8 Encoded Text with Strings&amp;rdquo;&lt;/a&gt; section of Chapter 8.</source>
          <target state="translated">Примечание. Индексы диапазона среза строки должны находиться на допустимой границе символа UTF-8. Если вы попытаетесь создать строковый фрагмент в середине многобайтового символа, ваша программа завершится с ошибкой. В целях представления строковых фрагментов мы предполагаем ASCII только в этом разделе; более подробное обсуждение обработки UTF-8 находится в разделе &lt;a href=&quot;ch08-02-strings#storing-utf-8-encoded-text-with-strings&quot;&gt;&amp;laquo;Сохранение текста в кодировке UTF-8 со строками&amp;raquo;&lt;/a&gt; главы 8.</target>
        </trans-unit>
        <trans-unit id="d0300d6a8e919cca08e1ab2c8db38b624e4574c2" translate="yes" xml:space="preserve">
          <source>Note: The &lt;a href=&quot;../../std/vec/struct.vec&quot;&gt;&lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt; standard library type provides a heap-allocated resizable array type.</source>
          <target state="translated">Примечание. Тип стандартной библиотеки &lt;a href=&quot;../../std/vec/struct.vec&quot;&gt; &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; &lt;/a&gt; предоставляет тип массива с изменяемым размером, размещенным в куче.</target>
        </trans-unit>
        <trans-unit id="29d2f706dbf0a3794fd072f42986f2a9c440ff62" translate="yes" xml:space="preserve">
          <source>Note: The &lt;code&gt;//&lt;/code&gt; syntax starts a comment that continues until the end of the line. Rust ignores everything in comments, which are discussed in more detail in Chapter 3.</source>
          <target state="translated">Примечание. Синтаксис &lt;code&gt;//&lt;/code&gt; запускает комментарий, который продолжается до конца строки. Rust игнорирует все, что есть в комментариях, которые более подробно обсуждаются в главе 3.</target>
        </trans-unit>
        <trans-unit id="187085942721c7c78a8ec180c1642f4ed13694fc" translate="yes" xml:space="preserve">
          <source>Note: The &lt;code&gt;2..=9&lt;/code&gt; is a &lt;a href=&quot;../patterns#range-patterns&quot;&gt;Range Pattern&lt;/a&gt;, not a &lt;a href=&quot;range-expr&quot;&gt;Range Expression&lt;/a&gt;. Thus, only those types of ranges supported by range patterns can be used in match arms.</source>
          <target state="translated">Примечание. &lt;code&gt;2..=9&lt;/code&gt; - это &lt;a href=&quot;../patterns#range-patterns&quot;&gt;шаблон диапазона&lt;/a&gt; , а не &lt;a href=&quot;range-expr&quot;&gt;выражение диапазона&lt;/a&gt; . Таким образом, в матчевых руках могут использоваться только те типы диапазонов, которые поддерживаются шаблонами диапазонов.</target>
        </trans-unit>
        <trans-unit id="f039047f79b4edcb39be10eb9b4e9a5ff0260001" translate="yes" xml:space="preserve">
          <source>Note: The actual definition of the &lt;code&gt;vec!&lt;/code&gt; macro in the standard library includes code to preallocate the correct amount of memory up front. That code is an optimization that we don&amp;rsquo;t include here to make the example simpler.</source>
          <target state="translated">Примечание. Фактическое определение &lt;code&gt;vec!&lt;/code&gt; макрос в стандартной библиотеке включает код для предварительного выделения правильного объема памяти. Этот код является оптимизацией, которую мы не включаем здесь, чтобы упростить пример.</target>
        </trans-unit>
        <trans-unit id="43e1990329df70de099fd02b501085a14776154b" translate="yes" xml:space="preserve">
          <source>Note: The aforementioned shim for function pointers is necessary because &lt;code&gt;rustc&lt;/code&gt; implements &lt;code&gt;track_caller&lt;/code&gt; in a codegen context by appending an implicit parameter to the function ABI, but this would be unsound for an indirect call because the parameter is not a part of the function's type and a given function pointer type may or may not refer to a function with the attribute. The creation of a shim hides the implicit parameter from callers of the function pointer, preserving soundness.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="130fc90f1f7559f295e76dc148708d583a3eb9e9" translate="yes" xml:space="preserve">
          <source>Note: The default in &lt;code&gt;rustc&lt;/code&gt; is 1048576.</source>
          <target state="translated">Примечание: значение по умолчанию в &lt;code&gt;rustc&lt;/code&gt; - 1048576.</target>
        </trans-unit>
        <trans-unit id="26390a0ab47722e2e502de5688756dbd639d3d95" translate="yes" xml:space="preserve">
          <source>Note: The default in &lt;code&gt;rustc&lt;/code&gt; is 128.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a3d9efde740053cef26656af7a7f6ab7316f24e6" translate="yes" xml:space="preserve">
          <source>Note: The default in &lt;code&gt;rustc&lt;/code&gt; is 64.</source>
          <target state="translated">Примечание: по умолчанию в &lt;code&gt;rustc&lt;/code&gt; установлено 64.</target>
        </trans-unit>
        <trans-unit id="8180c8df8ae11541f19b00a561591d13760a8ee6" translate="yes" xml:space="preserve">
          <source>Note: The element range is removed even if the iterator is not consumed until the end.</source>
          <target state="translated">Примечание:Диапазон элементов снимается,даже если итератор потребляется не до конца.</target>
        </trans-unit>
        <trans-unit id="9f4fea507ec4e68a49f42af2c77e67668a288392" translate="yes" xml:space="preserve">
          <source>Note: The enum representation in C is implementation defined, so this is really a &quot;best guess&quot;. In particular, this may be incorrect when the C code of interest is compiled with certain flags.</source>
          <target state="translated">Замечание:представление перечисления на C определено реализацией,так что это действительно &quot;лучшая догадка&quot;.В частности,это может быть некорректно,когда интересующий код на Си скомпилирован с определенными флагами.</target>
        </trans-unit>
        <trans-unit id="4cee4fb70834d29d39a99e3fa46a091ae845a20c" translate="yes" xml:space="preserve">
          <source>Note: The examples above used to be (erroneously) accepted by the compiler, but this was since corrected. See &lt;a href=&quot;https://github.com/rust-lang/rust/issues/33685&quot;&gt;issue #33685&lt;/a&gt; for more details.</source>
          <target state="translated">Примечание. Приведенные выше примеры (ошибочно) принимались компилятором, но с тех пор это было исправлено. Подробнее см. &lt;a href=&quot;https://github.com/rust-lang/rust/issues/33685&quot;&gt;Выпуск № 33685&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="daadbb2b1b33b48dcd9e6359e7eecc90c0e80c1e" translate="yes" xml:space="preserve">
          <source>Note: The examples in Listings 10-17, 10-18, and 10-24 declare variables without giving them an initial value, so the variable name exists in the outer scope. At first glance, this might appear to be in conflict with Rust&amp;rsquo;s having no null values. However, if we try to use a variable before giving it a value, we&amp;rsquo;ll get a compile-time error, which shows that Rust indeed does not allow null values.</source>
          <target state="translated">Примечание. В примерах в листингах 10-17, 10-18 и 10-24 переменные объявляются без присвоения им начального значения, поэтому имя переменной существует во внешней области. На первый взгляд может показаться, что это противоречит тому, что в Rust нет нулевых значений. Однако, если мы попытаемся использовать переменную перед присвоением ей значения, мы получим ошибку времени компиляции, которая показывает, что Rust действительно не допускает нулевых значений.</target>
        </trans-unit>
        <trans-unit id="50e01f1ed4a46f62a5d14f0b5fa9d8b4796d1c64" translate="yes" xml:space="preserve">
          <source>Note: The implementation of which return types are allowed is determined by the unstable &lt;a href=&quot;../../std/process/trait.termination&quot;&gt;&lt;code&gt;Termination&lt;/code&gt;&lt;/a&gt; trait.</source>
          <target state="translated">Примечание. Реализация разрешенных типов возвращаемых значений определяется трейтом нестабильное &lt;a href=&quot;../../std/process/trait.termination&quot;&gt; &lt;code&gt;Termination&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="788f6375fff581af876a714c5f38068ea6a94a60" translate="yes" xml:space="preserve">
          <source>Note: The implementation of which return types are allowed is determined by the unstable &lt;a href=&quot;../std/process/trait.termination&quot;&gt;&lt;code&gt;Termination&lt;/code&gt;&lt;/a&gt; trait.</source>
          <target state="translated">Примечание. Реализация разрешенных типов возвращаемых значений определяется трейтом нестабильное &lt;a href=&quot;../std/process/trait.termination&quot;&gt; &lt;code&gt;Termination&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="40b1e975f4973c7f7bd859ba82ec6ff70298303a" translate="yes" xml:space="preserve">
          <source>Note: The lint checks supported by &lt;code&gt;rustc&lt;/code&gt; can be found via &lt;code&gt;rustc -W help&lt;/code&gt;, along with their default settings and are documented in the &lt;a href=&quot;https://doc.rust-lang.org/rustc/lints/index.html&quot;&gt;rustc book&lt;/a&gt;.</source>
          <target state="translated">Примечание. Проверки линта, поддерживаемые &lt;code&gt;rustc&lt;/code&gt; , можно найти с помощью команды &lt;code&gt;rustc -W help&lt;/code&gt; вместе с их настройками по умолчанию, и они задокументированы в &lt;a href=&quot;https://doc.rust-lang.org/rustc/lints/index.html&quot;&gt;книге rustc&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="5df3cfb866cdb5ad3722ea9687c561d88d29727a" translate="yes" xml:space="preserve">
          <source>Note: The next section assumes you&amp;rsquo;ve read the earlier section &lt;a href=&quot;ch19-03-advanced-traits#using-the-newtype-pattern-to-implement-external-traits-on-external-types&quot;&gt;&amp;ldquo;Using the Newtype Pattern to Implement External Traits on External Types.&amp;rdquo;&lt;/a&gt;</source>
          <target state="translated">Примечание. В следующем разделе предполагается, что вы прочитали предыдущий раздел &lt;a href=&quot;ch19-03-advanced-traits#using-the-newtype-pattern-to-implement-external-traits-on-external-types&quot;&gt;&amp;laquo;Использование шаблона Newtype для реализации внешних признаков на внешних типах&amp;raquo;.&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="7007864547a1ff842641db1454a617feb860ba4c" translate="yes" xml:space="preserve">
          <source>Note: The opposite of referencing by using &lt;code&gt;&amp;amp;&lt;/code&gt; is &lt;em&gt;dereferencing&lt;/em&gt;, which is accomplished with the dereference operator, &lt;code&gt;*&lt;/code&gt;. We&amp;rsquo;ll see some uses of the dereference operator in Chapter 8 and discuss details of dereferencing in Chapter 15.</source>
          <target state="translated">Примечание. Противоположностью ссылки с помощью &lt;code&gt;&amp;amp;&lt;/code&gt; является &lt;em&gt;разыменование&lt;/em&gt; , которое выполняется с помощью оператора разыменования &lt;code&gt;*&lt;/code&gt; . Мы увидим некоторые варианты использования оператора разыменования в главе 8 и обсудим детали разыменования в главе 15.</target>
        </trans-unit>
        <trans-unit id="a0cacc6a55793cf1996cae56b2d43488d313d554" translate="yes" xml:space="preserve">
          <source>Note: The semicolon following a statement is not a part of the statement itself. They are invalid when using the &lt;code&gt;stmt&lt;/code&gt; macro matcher.</source>
          <target state="translated">Примечание. Точка с запятой после оператора не является частью самого оператора. Они недействительны при использовании сопоставления макросов &lt;code&gt;stmt&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ebd41440d85e280e6b8e0940e9eb1baf556c6663" translate="yes" xml:space="preserve">
          <source>Note: The test mode is enabled by passing the &lt;code&gt;--test&lt;/code&gt; argument to &lt;code&gt;rustc&lt;/code&gt; or using &lt;code&gt;cargo test&lt;/code&gt;.</source>
          <target state="translated">Примечание: Тестовый режим включен, передавая &lt;code&gt;--test&lt;/code&gt; аргумента &lt;code&gt;rustc&lt;/code&gt; или с помощью &lt;code&gt;cargo test&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="019655f819e73b6b959d0e74887282806fb3a878" translate="yes" xml:space="preserve">
          <source>Note: This algorithm can produce zero-sized structs. In C, an empty struct declaration like &lt;code&gt;struct Foo { }&lt;/code&gt; is illegal. However, both gcc and clang support options to enable such structs, and assign them size zero. C++, in contrast, gives empty structs a size of 1, unless they are inherited from or they are fields that have the &lt;code&gt;[[no_unique_address]]&lt;/code&gt; attribute, in which case they do not increase the overall size of the struct.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a7281566219ec90e2a7e767d6f73d5379e3c0db2" translate="yes" xml:space="preserve">
          <source>Note: This algorithm can produce zero-sized structs. This differs from C where structs without data still have a size of one byte.</source>
          <target state="translated">Примечание:Этот алгоритм может создавать структуры нулевого размера.Это отличается от C,где структуры без данных все еще имеют размер в один байт.</target>
        </trans-unit>
        <trans-unit id="84916df8964c95c521b7aa5c595fc0771cbfc9af" translate="yes" xml:space="preserve">
          <source>Note: This book assumes basic familiarity with the command line. Rust makes no specific demands about your editing or tooling or where your code lives, so if you prefer to use an integrated development environment (IDE) instead of the command line, feel free to use your favorite IDE. Many IDEs now have some degree of Rust support; check the IDE&amp;rsquo;s documentation for details. Recently, the Rust team has been focusing on enabling great IDE support, and progress has been made rapidly on that front!</source>
          <target state="translated">Примечание: эта книга предполагает базовое знакомство с командной строкой. Rust не предъявляет особых требований к вашему редактированию или инструментам, или где находится ваш код, поэтому, если вы предпочитаете использовать интегрированную среду разработки (IDE) вместо командной строки, не стесняйтесь использовать свою любимую IDE. Многие IDE теперь имеют некоторую поддержку Rust; подробности см. в документации IDE. В последнее время команда Rust сосредоточилась на обеспечении отличной поддержки IDE, и в этом направлении был достигнут быстрый прогресс!</target>
        </trans-unit>
        <trans-unit id="5ac1eb98b0f589191a31e26db76121648795b41e" translate="yes" xml:space="preserve">
          <source>Note: This edition of the book is the same as &lt;a href=&quot;https://nostarch.com/rust&quot;&gt;The Rust Programming Language&lt;/a&gt; available in print and ebook format from &lt;a href=&quot;https://nostarch.com/&quot;&gt;No Starch Press&lt;/a&gt;.</source>
          <target state="translated">Примечание: это издание книги такое же, как &lt;a href=&quot;https://nostarch.com/rust&quot;&gt;язык программирования Rust,&lt;/a&gt; доступное в печатном и электронном формате от &lt;a href=&quot;https://nostarch.com/&quot;&gt;No Starch Press&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="12f5db48053663ec58249f015893f0934fb3f9cb" translate="yes" xml:space="preserve">
          <source>Note: This example shows the internals of &lt;code&gt;&amp;amp;str&lt;/code&gt;. &lt;code&gt;unsafe&lt;/code&gt; should not be used to get a string slice under normal circumstances. Use &lt;code&gt;as_slice&lt;/code&gt; instead.</source>
          <target state="translated">Примечание. В этом примере показано внутреннее устройство &lt;code&gt;&amp;amp;str&lt;/code&gt; . &lt;code&gt;unsafe&lt;/code&gt; не следует использовать для получения отрезка строки при нормальных обстоятельствах. &lt;code&gt;as_slice&lt;/code&gt; этого используйте as_slice .</target>
        </trans-unit>
        <trans-unit id="98315c88f72bf459de14ba0cdd9324f6a6dfd072" translate="yes" xml:space="preserve">
          <source>Note: This example shows the internals of &lt;code&gt;&amp;amp;str&lt;/code&gt;. &lt;code&gt;unsafe&lt;/code&gt; should not be used to get a string slice under normal circumstances. Use &lt;code&gt;as_str&lt;/code&gt; instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="71c5367b5e1ca4ccf0bf834db2cd4b500fbdeb5c" translate="yes" xml:space="preserve">
          <source>Note: This is about the raw &lt;code&gt;[T]&lt;/code&gt; type, not pointers (&lt;code&gt;&amp;amp;[T]&lt;/code&gt;, &lt;code&gt;Box&amp;lt;[T]&amp;gt;&lt;/code&gt;, etc.) to slices.</source>
          <target state="translated">Примечание. Речь идет о необработанном типе &lt;code&gt;[T]&lt;/code&gt; , а не об указателях ( &lt;code&gt;&amp;amp;[T]&lt;/code&gt; , &lt;code&gt;Box&amp;lt;[T]&amp;gt;&lt;/code&gt; и т. Д.) На фрагменты.</target>
        </trans-unit>
        <trans-unit id="53274b0feb8252b3f7e0516cd656e66a12715d39" translate="yes" xml:space="preserve">
          <source>Note: This is about the raw trait object types, not pointers (&lt;code&gt;&amp;amp;Trait&lt;/code&gt;, &lt;code&gt;Box&amp;lt;Trait&amp;gt;&lt;/code&gt;, etc.) to trait objects.</source>
          <target state="translated">Примечание. Речь идет о необработанных типах объектов-признаков, а не указателях ( &lt;code&gt;&amp;amp;Trait&lt;/code&gt; , &lt;code&gt;Box&amp;lt;Trait&amp;gt;&lt;/code&gt; и т. Д.) На объекты-признаки.</target>
        </trans-unit>
        <trans-unit id="c578bc980d0061348761c9a476bec4981d2bea05" translate="yes" xml:space="preserve">
          <source>Note: This is about the raw trait object types, not pointers (&lt;code&gt;&amp;amp;dyn Trait&lt;/code&gt;, &lt;code&gt;Box&amp;lt;dyn Trait&amp;gt;&lt;/code&gt;, etc.) to trait objects.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3efbe622a99893d160a87ba1b5dbe54cdc04b646" translate="yes" xml:space="preserve">
          <source>Note: This is often called &quot;impl Trait in argument position&quot;.</source>
          <target state="translated">Примечание:Это часто называется &quot;импл трейт в позиции аргумента&quot;.</target>
        </trans-unit>
        <trans-unit id="ebd18dc0abe826773a124050720a5e27942c51e0" translate="yes" xml:space="preserve">
          <source>Note: This is often called &quot;impl Trait in return position&quot;.</source>
          <target state="translated">Примечание:Это часто называется &quot;трейт имплантата в обратной позиции&quot;.</target>
        </trans-unit>
        <trans-unit id="dcf4aae415a3e26a6bf431396708d40ea1b5d658" translate="yes" xml:space="preserve">
          <source>Note: This macro can be used in &lt;code&gt;no_std&lt;/code&gt; setups as well. In a &lt;code&gt;no_std&lt;/code&gt; setup you are responsible for the implementation details of the components.</source>
          <target state="translated">Примечание. Этот макрос также можно использовать в настройках &lt;code&gt;no_std&lt;/code&gt; . В настройке &lt;code&gt;no_std&lt;/code&gt; вы несете ответственность за детали реализации компонентов.</target>
        </trans-unit>
        <trans-unit id="3ba312fede1a13f53566373763f2cc827d3cc6a0" translate="yes" xml:space="preserve">
          <source>Note: This may call the function multiple times if the value has been changed from other threads in the meantime, as long as the function returns &lt;code&gt;Some(_)&lt;/code&gt;, but the function will have been applied but once to the stored value.</source>
          <target state="translated">Примечание: это может вызвать функцию несколько раз, если значение было изменено из других потоков тем временем, пока функция возвращает &lt;code&gt;Some(_)&lt;/code&gt; , но функция будет применена только один раз к сохраненному значению.</target>
        </trans-unit>
        <trans-unit id="859d3e3283a94e543f2b35839b775cd31f5e0f59" translate="yes" xml:space="preserve">
          <source>Note: This may call the function multiple times if the value has been changed from other threads in the meantime, as long as the function returns &lt;code&gt;Some(_)&lt;/code&gt;, but the function will have been applied only once to the stored value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="64c40b5289fbe1388c2536811cdec7566f0df820" translate="yes" xml:space="preserve">
          <source>Note: This representation is unchanged if the tag is given its own member in the union, should that make manipulation more clear for you (although to follow the C++ standard the tag member should be wrapped in a &lt;code&gt;struct&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="239a5948be38f752de16eb5b0ffe5444c5d1e29d" translate="yes" xml:space="preserve">
          <source>Note: This section is a placeholder for more comprehensive reference material.</source>
          <target state="translated">Примечание:Этот раздел является размещением для более подробных справочных материалов.</target>
        </trans-unit>
        <trans-unit id="5b012ed05fd45d1a0619d2a532517a96144ac5c9" translate="yes" xml:space="preserve">
          <source>Note: This section is described more in terms of the compiler than of the language.</source>
          <target state="translated">Замечание:Этот раздел описан больше с точки зрения компилятора,чем языка.</target>
        </trans-unit>
        <trans-unit id="3b7a991aa3513a216522c1b812051b6fd94ca027" translate="yes" xml:space="preserve">
          <source>Note: Though you should not rely on this, all pointers to</source>
          <target state="translated">Примечание:Хотя вы не должны полагаться на это,все указывает на то,что</target>
        </trans-unit>
        <trans-unit id="ccec92c826b382bbeb8d0f3b3ce8f2aff5320851" translate="yes" xml:space="preserve">
          <source>Note: Traits are similar to a feature often called &lt;em&gt;interfaces&lt;/em&gt; in other languages, although with some differences.</source>
          <target state="translated">Примечание. Черты похожи на функцию, которую на других языках часто называют &lt;em&gt;интерфейсами&lt;/em&gt; , хотя и с некоторыми отличиями.</target>
        </trans-unit>
        <trans-unit id="0ff8579bff78c963092559227a81a969d9708ad7" translate="yes" xml:space="preserve">
          <source>Note: Trivial no-op expressions containing the value will not violate the lint. Examples include wrapping the value in a type that does not implement &lt;a href=&quot;../special-types-and-traits#drop&quot;&gt;&lt;code&gt;Drop&lt;/code&gt;&lt;/a&gt; and then not using that type and being the final expression of a &lt;a href=&quot;../expressions/block-expr&quot;&gt;block expression&lt;/a&gt; that is not used.</source>
          <target state="translated">Примечание. Тривиальные выражения без операции, содержащие значение, не нарушат линта. Примеры включают перенос значения в тип, который не реализует &lt;a href=&quot;../special-types-and-traits#drop&quot;&gt; &lt;code&gt;Drop&lt;/code&gt; ,&lt;/a&gt; а затем не использование этого типа и окончательное выражение выражения &lt;a href=&quot;../expressions/block-expr&quot;&gt;блока&lt;/a&gt; , которое не используется.</target>
        </trans-unit>
        <trans-unit id="eb186d5904a6ce9b777e0cf94b3203a9889bfac8" translate="yes" xml:space="preserve">
          <source>Note: Using primitive values when a complex type would be more appropriate is an anti-pattern known as &lt;em&gt;primitive obsession&lt;/em&gt;.</source>
          <target state="translated">Примечание: использование примитивных значений, когда сложный тип был бы более подходящим, является анти-паттерном, известным как &lt;em&gt;примитивная одержимость&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="04993cf7d2f50288aed55f19ed2ebc1756b87d27" translate="yes" xml:space="preserve">
          <source>Note: We&amp;rsquo;re implementing a cons list that holds only &lt;code&gt;i32&lt;/code&gt; values for the purposes of this example. We could have implemented it using generics, as we discussed in Chapter 10, to define a cons list type that could store values of any type.</source>
          <target state="translated">Примечание: мы реализуем список недостатков, который содержит только значения &lt;code&gt;i32&lt;/code&gt; для целей этого примера. Мы могли бы реализовать его, используя обобщения, как мы обсуждали в главе 10, для определения типа списка cons, который может хранить значения любого типа.</target>
        </trans-unit>
        <trans-unit id="9a9063f50fe88aae84e6d578aa20b9af4873e66f" translate="yes" xml:space="preserve">
          <source>Note: While the definition of the unsized coercions and their implementation has been stabilized, the traits themselves are not yet stable and therefore can't be used directly in stable Rust.</source>
          <target state="translated">Примечание:Несмотря на то,что определение неразмерных принуждений и их реализация стабилизировались,сами черты еще не являются стабильными и поэтому не могут быть использованы непосредственно в стабильной ржавчине.</target>
        </trans-unit>
        <trans-unit id="2dfa6e64910004aadc24cb034a538f296b64dc2f" translate="yes" xml:space="preserve">
          <source>Note: Windows Portability Consideration</source>
          <target state="translated">Примечание:Учет переносимости Windows</target>
        </trans-unit>
        <trans-unit id="54ec2a3d57d83413137977409179cfe79c9797ac" translate="yes" xml:space="preserve">
          <source>Note: You won&amp;rsquo;t just know which traits to use and which methods and functions to call from a crate. Instructions for using a crate are in each crate&amp;rsquo;s documentation. Another neat feature of Cargo is that you can run the &lt;code&gt;cargo doc --open&lt;/code&gt; command, which will build documentation provided by all of your dependencies locally and open it in your browser. If you&amp;rsquo;re interested in other functionality in the &lt;code&gt;rand&lt;/code&gt; crate, for example, run &lt;code&gt;cargo doc --open&lt;/code&gt; and click &lt;code&gt;rand&lt;/code&gt; in the sidebar on the left.</source>
          <target state="translated">Примечание: вы не просто будете знать, какие черты использовать и какие методы и функции вызывать из ящика. Инструкции по использованию ящика есть в документации к каждому ящику. Еще одна интересная особенность Cargo заключается в том, что вы можете запустить команду &lt;code&gt;cargo doc --open&lt;/code&gt; , которая локально создаст документацию, предоставляемую всеми вашими зависимостями, и откроет ее в вашем браузере. Если вас интересуют другие функции ящика &lt;code&gt;rand&lt;/code&gt; , например, запустите &lt;code&gt;cargo doc --open&lt;/code&gt; и щелкните &lt;code&gt;rand&lt;/code&gt; на боковой панели слева.</target>
        </trans-unit>
        <trans-unit id="8dd21546f26b11f02ddb49b823b4ad3f527dfdac" translate="yes" xml:space="preserve">
          <source>Note: any changes to the constness of intrinsics should be discussed with the language team. This includes changes in the stability of the constness.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1377a2c8bb6dcbd807394d1b50fa3eae990de774" translate="yes" xml:space="preserve">
          <source>Note: because the resulting &lt;code&gt;Location&lt;/code&gt; is a hint, an implementation may halt its walk up the stack early. See &lt;a href=&quot;#limitations&quot;&gt;Limitations&lt;/a&gt; for important caveats.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fa7e98c548306a32db0bad3d57bbd3a5f699aa40" translate="yes" xml:space="preserve">
          <source>Note: if you open &lt;em&gt;/sleep&lt;/em&gt; in multiple browser windows simultaneously, they might load one at a time in 5 second intervals. Some web browsers execute multiple instances of the same request sequentially for caching reasons. This limitation is not caused by our web server.</source>
          <target state="translated">Примечание: если вы открываете &lt;em&gt;/ спите&lt;/em&gt; в нескольких окнах браузера одновременно, они могут загружаться по одному с 5-секундными интервалами. Некоторые веб-браузеры последовательно выполняют несколько экземпляров одного и того же запроса из соображений кеширования. Это ограничение не вызвано нашим веб-сервером.</target>
        </trans-unit>
        <trans-unit id="0f059d54c5a420d80b996d0b044829768d22d426" translate="yes" xml:space="preserve">
          <source>Note: in a future Rust version this method may become unnecessary when array literal syntax allows &lt;a href=&quot;https://github.com/rust-lang/rust/issues/49147&quot;&gt;repeating const expressions&lt;/a&gt;. The example below could then use &lt;code&gt;let mut buf = [MaybeUninit::&amp;lt;u8&amp;gt;::uninit(); 32];&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a67ae8b5976b293a38b572b260c03db2df6555be" translate="yes" xml:space="preserve">
          <source>Note: mathematical operations like &lt;a href=&quot;struct.instant#method.add&quot;&gt;&lt;code&gt;add&lt;/code&gt;&lt;/a&gt; may panic if the underlying structure cannot represent the new point in time.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="670b99fc8bc3c4e3e76a24aaf458d8652eb20452" translate="yes" xml:space="preserve">
          <source>Note: mathematical operations like &lt;a href=&quot;struct.systemtime#method.add&quot;&gt;&lt;code&gt;add&lt;/code&gt;&lt;/a&gt; may panic if the underlying structure cannot represent the new point in time.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="94be0b88d71e4f4b09ff423fbdb3966a642ec68a" translate="yes" xml:space="preserve">
          <source>Note: only extended grapheme codepoints that begin the string will be escaped.</source>
          <target state="translated">Замечание:только расширенные кодовые точки графем,которые начинают строку,будут экранированы.</target>
        </trans-unit>
        <trans-unit id="15aa3f25c0678e364c46087d4cf15cef24972d41" translate="yes" xml:space="preserve">
          <source>Note: the &lt;code&gt;Item&lt;/code&gt; type parameter is not used in this trait, but it allows impls to be more generic. Without it, we get this error:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="59ba94b4a0ce80567a5f66bf9563fcdf82240def" translate="yes" xml:space="preserve">
          <source>Note: the lookup is done for each type in order, which can occasionally lead to surprising results. The below code will print &quot;In trait impl!&quot;, because &lt;code&gt;&amp;amp;self&lt;/code&gt; methods are looked up first, the trait method is found before the struct's &lt;code&gt;&amp;amp;mut self&lt;/code&gt; method is found.</source>
          <target state="translated">Примечание: поиск выполняется для каждого типа по порядку, что иногда может приводить к неожиданным результатам. В приведенном ниже коде будет напечатано &amp;laquo;In trait impl!&amp;raquo;, Поскольку сначала ищутся методы &lt;code&gt;&amp;amp;self&lt;/code&gt; , метод trait обнаруживается до того, как будет найден метод struct &lt;code&gt;&amp;amp;mut self&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c7cb38696a69ae9af0ae23e81e9d982ddfe77188" translate="yes" xml:space="preserve">
          <source>Note: the value returned by this method is unspecified after the range has been iterated to exhaustion.</source>
          <target state="translated">Примечание:значение,возвращаемое этим методом,не уточняется после исчерпания диапазона.</target>
        </trans-unit>
        <trans-unit id="aa3e5b7333a9df0d2dc6ac8acfc43125fde51982" translate="yes" xml:space="preserve">
          <source>Note: there&amp;rsquo;s one big difference between the &lt;code&gt;MyBox&amp;lt;T&amp;gt;&lt;/code&gt; type we&amp;rsquo;re about to build and the real &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt;: our version will not store its data on the heap. We are focusing this example on &lt;code&gt;Deref&lt;/code&gt;, so where the data is actually stored is less important than the pointer-like behavior.</source>
          <target state="translated">Примечание: есть одно большое различие между &lt;code&gt;MyBox&amp;lt;T&amp;gt;&lt;/code&gt; мы собираемся создать, и настоящим &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; : наша версия не будет хранить свои данные в куче. В этом примере мы сосредоточили внимание на &lt;code&gt;Deref&lt;/code&gt; , поэтому место, где фактически хранятся данные, менее важно, чем поведение, подобное указателю.</target>
        </trans-unit>
        <trans-unit id="07525906ea71db41f7991cef8484c00c750f6dcb" translate="yes" xml:space="preserve">
          <source>Note: this error code is no longer emitted by the compiler</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0c580688b8d6e9090963bfacda97bc90a713c687" translate="yes" xml:space="preserve">
          <source>Note: this error code is no longer emitted by the compiler.</source>
          <target state="translated">Замечание:данный код ошибки больше не выдается компилятором.</target>
        </trans-unit>
        <trans-unit id="82b6db0c7e241e7e5bc0253c1ea4acf7f9b04451" translate="yes" xml:space="preserve">
          <source>Note: this is an associated function, which means that you have to call it as &lt;code&gt;Box::alloc_ref(&amp;amp;b)&lt;/code&gt; instead of &lt;code&gt;b.alloc_ref()&lt;/code&gt;. This is so that there is no conflict with a method on the inner type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="de79d60b5ae69ae8de10ccab3addf181d505537b" translate="yes" xml:space="preserve">
          <source>Note: this is an associated function, which means that you have to call it as &lt;code&gt;Box::into_raw(b)&lt;/code&gt; instead of &lt;code&gt;b.into_raw()&lt;/code&gt;. This is so that there is no conflict with a method on the inner type.</source>
          <target state="translated">Примечание: это связанная функция, а это значит, что вы должны вызывать ее как &lt;code&gt;Box::into_raw(b)&lt;/code&gt; вместо &lt;code&gt;b.into_raw()&lt;/code&gt; . Это сделано для того, чтобы не было конфликта с методом внутреннего типа.</target>
        </trans-unit>
        <trans-unit id="9801006a2ac0b25e680ddaebb4a6a97fc9bd8dc1" translate="yes" xml:space="preserve">
          <source>Note: this is an associated function, which means that you have to call it as &lt;code&gt;Box::into_raw_non_null(b)&lt;/code&gt; instead of &lt;code&gt;b.into_raw_non_null()&lt;/code&gt;. This is so that there is no conflict with a method on the inner type.</source>
          <target state="translated">Примечание: это связанная функция, а это означает, что вы должны вызывать ее как &lt;code&gt;Box::into_raw_non_null(b)&lt;/code&gt; вместо &lt;code&gt;b.into_raw_non_null()&lt;/code&gt; . Это сделано для того, чтобы не было конфликта с методом внутреннего типа.</target>
        </trans-unit>
        <trans-unit id="3ad7dd66ed2768898bcd615504f6e1f37abf0500" translate="yes" xml:space="preserve">
          <source>Note: this is an associated function, which means that you have to call it as &lt;code&gt;Box::into_raw_with_alloc(b)&lt;/code&gt; instead of &lt;code&gt;b.into_raw_with_alloc()&lt;/code&gt;. This is so that there is no conflict with a method on the inner type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b61290dcffaed8f71df5ea3435ea91289cbca703" translate="yes" xml:space="preserve">
          <source>Note: this is an associated function, which means that you have to call it as &lt;code&gt;Box::leak(b)&lt;/code&gt; instead of &lt;code&gt;b.leak()&lt;/code&gt;. This is so that there is no conflict with a method on the inner type.</source>
          <target state="translated">Примечание: это связанная функция, а это значит, что вы должны вызывать ее как &lt;code&gt;Box::leak(b)&lt;/code&gt; &lt;code&gt;b.leak()&lt;/code&gt; b) вместо b.leak () . Это сделано для того, чтобы не было конфликта с методом внутреннего типа.</target>
        </trans-unit>
        <trans-unit id="99cc9083edfe04d950b19fddc376275a0d86e32a" translate="yes" xml:space="preserve">
          <source>Note: while this type is unstable, the functionality it provides can be accessed through the &lt;a href=&quot;https://doc.rust-lang.org/alloc/alloc/index.html#functions&quot;&gt;free functions in &lt;code&gt;alloc&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="855408558daaf89b8b3b6445b95d7c1b8fc7ac9c" translate="yes" xml:space="preserve">
          <source>Note: while this type is unstable, the functionality it provides can be accessed through the &lt;a href=&quot;index#functions&quot;&gt;free functions in &lt;code&gt;alloc&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Примечание: хотя этот тип нестабилен, к предоставляемым им функциям можно получить доступ через &lt;a href=&quot;index#functions&quot;&gt;бесплатные функции в &lt;code&gt;alloc&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="70440046a3dc2e079f23ee1c57dfa76669b732aa" translate="yes" xml:space="preserve">
          <source>Notes</source>
          <target state="translated">Notes</target>
        </trans-unit>
        <trans-unit id="9ea884e20e19e59213993b5d483a5cae6c6deb6b" translate="yes" xml:space="preserve">
          <source>Notes about side effects</source>
          <target state="translated">Заметки о побочных эффектах</target>
        </trans-unit>
        <trans-unit id="0665801607b97f01a2cf09fef56752d404c94329" translate="yes" xml:space="preserve">
          <source>Notes and Safety</source>
          <target state="translated">Примечания и безопасность</target>
        </trans-unit>
        <trans-unit id="5367ad0070e3b4dc018a1e98ba396857c9a89c8b" translate="yes" xml:space="preserve">
          <source>Notes that contain useful information about the state of the book or point out useful, but mostly out of scope, information are in blockquotes that start with the word &quot;Note:&quot; in &lt;strong&gt;bold&lt;/strong&gt;.</source>
          <target state="translated">Примечания, которые содержат полезную информацию о состоянии книги или указывают на полезную, но в основном выходящую за рамки, информацию заключают в кавычки, которые начинаются со слова &amp;laquo;Примечание:&amp;raquo; &lt;strong&gt;жирным шрифтом&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="343e2ff0e712d5880f73c89d0629c959a0cbc677" translate="yes" xml:space="preserve">
          <source>Nothing in Rust prevents a trait from having a method with the same name as another trait&amp;rsquo;s method, nor does Rust prevent you from implementing both traits on one type. It&amp;rsquo;s also possible to implement a method directly on the type with the same name as methods from traits.</source>
          <target state="translated">Ничто в Rust не препятствует тому, чтобы у признака был метод с тем же именем, что и у метода другого признака, равно как и в Rust не мешает вам реализовать оба признака в одном типе. Также возможно реализовать метод непосредственно в типе с тем же именем, что и у методов из трейтов.</target>
        </trans-unit>
        <trans-unit id="85a8ab9caff8306933eb7dd48f9cd08900551077" translate="yes" xml:space="preserve">
          <source>Notice in Listing 16-1 that the closure we pass to &lt;code&gt;thread::spawn&lt;/code&gt; takes no arguments: we&amp;rsquo;re not using any data from the main thread in the spawned thread&amp;rsquo;s code. To use data from the main thread in the spawned thread, the spawned thread&amp;rsquo;s closure must capture the values it needs. Listing 16-3 shows an attempt to create a vector in the main thread and use it in the spawned thread. However, this won&amp;rsquo;t yet work, as you&amp;rsquo;ll see in a moment.</source>
          <target state="translated">Обратите внимание на листинг 16-1, что закрытие, которое мы передаем в &lt;code&gt;thread::spawn&lt;/code&gt; принимает аргументов: мы не используем никаких данных из основного потока в коде порожденного потока. Чтобы использовать данные из основного потока в порожденном потоке, закрытие порожденного потока должно захватывать требуемые значения. В листинге 16-3 показана попытка создать вектор в основном потоке и использовать его в порожденном потоке. Однако это пока не сработает, как вы вскоре увидите.</target>
        </trans-unit>
        <trans-unit id="753a2ed5c1b14367e2086b1d9e2763add33258b6" translate="yes" xml:space="preserve">
          <source>Notice one interesting aspect of this particular execution: the &lt;code&gt;ThreadPool&lt;/code&gt; sent the terminate messages down the channel, and before any worker received the messages, we tried to join worker 0. Worker 0 had not yet received the terminate message, so the main thread blocked waiting for worker 0 to finish. In the meantime, each of the workers received the termination messages. When worker 0 finished, the main thread waited for the rest of the workers to finish. At that point, they had all received the termination message and were able to shut down.</source>
          <target state="translated">Обратите внимание на один интересный аспект этого конкретного выполнения: &lt;code&gt;ThreadPool&lt;/code&gt; отправил сообщения о завершении по каналу, и до того, как какой-либо рабочий процесс получил сообщения, мы попытались присоединиться к рабочему процессу 0. Рабочий 0 еще не получил сообщение о завершении, поэтому основной поток заблокировал ожидание для рабочего 0 закончить. Тем временем каждый из рабочих получил сообщение о завершении. Когда рабочий 0 закончил, основной поток ждал завершения остальных рабочих. В этот момент все они получили сообщение о завершении и смогли завершить работу.</target>
        </trans-unit>
        <trans-unit id="d88bd61c5288b6b4a4fab344b4f64355a8809dd2" translate="yes" xml:space="preserve">
          <source>Notice that &lt;code&gt;NonNull&amp;lt;T&amp;gt;&lt;/code&gt; has a &lt;code&gt;From&lt;/code&gt; instance for &lt;code&gt;&amp;amp;T&lt;/code&gt;. However, this does not change the fact that mutating through a (pointer derived from a) shared reference is undefined behavior unless the mutation happens inside an &lt;a href=&quot;../cell/struct.unsafecell&quot;&gt;&lt;code&gt;UnsafeCell&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt;. The same goes for creating a mutable reference from a shared reference. When using this &lt;code&gt;From&lt;/code&gt; instance without an &lt;code&gt;UnsafeCell&amp;lt;T&amp;gt;&lt;/code&gt;, it is your responsibility to ensure that &lt;code&gt;as_mut&lt;/code&gt; is never called, and &lt;code&gt;as_ptr&lt;/code&gt; is never used for mutation.</source>
          <target state="translated">Обратите внимание , что &lt;code&gt;NonNull&amp;lt;T&amp;gt;&lt;/code&gt; имеет &lt;code&gt;From&lt;/code&gt; экземпляра для &lt;code&gt;&amp;amp;T&lt;/code&gt; . Однако это не меняет того факта, что изменение с помощью (указателя, полученного из) общей ссылки является неопределенным поведением, если только изменение не происходит внутри &lt;a href=&quot;../cell/struct.unsafecell&quot;&gt; &lt;code&gt;UnsafeCell&amp;lt;T&amp;gt;&lt;/code&gt; &lt;/a&gt; . То же самое касается создания изменяемой ссылки из общей ссылки. При использовании этого экземпляра &lt;code&gt;From&lt;/code&gt; без &lt;code&gt;UnsafeCell&amp;lt;T&amp;gt;&lt;/code&gt; вы должны убедиться, что &lt;code&gt;as_mut&lt;/code&gt; никогда не вызывается, а &lt;code&gt;as_ptr&lt;/code&gt; никогда не используется для мутации.</target>
        </trans-unit>
        <trans-unit id="a4555814d84e265a1a37b6f84e64a162ac1d207e" translate="yes" xml:space="preserve">
          <source>Notice that &lt;code&gt;x&lt;/code&gt; is stack-allocated by &lt;code&gt;foo()&lt;/code&gt;. By default, Rust captures closed-over data by reference. This means that once &lt;code&gt;foo()&lt;/code&gt; returns, &lt;code&gt;x&lt;/code&gt; no longer exists. An attempt to access &lt;code&gt;x&lt;/code&gt; within the closure would thus be unsafe.</source>
          <target state="translated">Обратите внимание, что &lt;code&gt;x&lt;/code&gt; выделяется в стеке функцией &lt;code&gt;foo()&lt;/code&gt; . По умолчанию Rust захватывает закрытые данные по ссылке. Это означает, что после возврата из &lt;code&gt;foo()&lt;/code&gt; &lt;code&gt;x&lt;/code&gt; больше не существует. Таким образом, попытка доступа к &lt;code&gt;x&lt;/code&gt; внутри замыкания была бы небезопасной.</target>
        </trans-unit>
        <trans-unit id="0e90ccdac3be23d4ae5fee41e5c9c069831f7aa8" translate="yes" xml:space="preserve">
          <source>Notice that being unblocked does not imply any synchronization with someone that unparked this thread, it could also be spurious. For example, it would be a valid, but inefficient, implementation to make both &lt;a href=&quot;fn.park&quot;&gt;&lt;code&gt;park&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;struct.thread#method.unpark&quot;&gt;&lt;code&gt;unpark&lt;/code&gt;&lt;/a&gt; return immediately without doing anything.</source>
          <target state="translated">Обратите внимание, что разблокировка не подразумевает никакой синхронизации с кем-то, кто разблокировал этот поток, это также может быть ложным. Например, было бы допустимым, но неэффективным вариантом реализации немедленного возврата и &lt;a href=&quot;fn.park&quot;&gt; &lt;code&gt;park&lt;/code&gt; &lt;/a&gt; и &lt;a href=&quot;struct.thread#method.unpark&quot;&gt; &lt;code&gt;unpark&lt;/code&gt; &lt;/a&gt;парковки, ничего не делая.</target>
        </trans-unit>
        <trans-unit id="6dc4ada24330684cf56181017076bf6667acd63e" translate="yes" xml:space="preserve">
          <source>Notice that in the case of &lt;code&gt;compare_and_swap&lt;/code&gt;, it is possible that the operation ends up not performing any store and hence it has just &lt;a href=&quot;enum.ordering#variant.Acquire&quot;&gt;&lt;code&gt;Acquire&lt;/code&gt;&lt;/a&gt; ordering. However, &lt;code&gt;AcqRel&lt;/code&gt; will never perform &lt;a href=&quot;enum.ordering#variant.Relaxed&quot;&gt;&lt;code&gt;Relaxed&lt;/code&gt;&lt;/a&gt; accesses.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a7aa95fb880edfba626d059a08ec359fcae43db0" translate="yes" xml:space="preserve">
          <source>Notice that in the case of &lt;code&gt;compare_and_swap&lt;/code&gt;, it is possible that the operation ends up not performing any store and hence it has just &lt;a href=&quot;https://llvm.org/docs/Atomics.html#acquire&quot;&gt;&lt;code&gt;Acquire&lt;/code&gt;&lt;/a&gt; ordering. However, &lt;a href=&quot;https://llvm.org/docs/Atomics.html#acquirerelease&quot;&gt;&lt;code&gt;AcqRel&lt;/code&gt;&lt;/a&gt; will never perform &lt;a href=&quot;https://llvm.org/docs/Atomics.html#monotonic&quot;&gt;&lt;code&gt;Relaxed&lt;/code&gt;&lt;/a&gt; accesses.</source>
          <target state="translated">Обратите внимание, что в случае &lt;code&gt;compare_and_swap&lt;/code&gt; вполне возможно, что операция не выполняет никакого сохранения и, следовательно, имеет только порядок &lt;a href=&quot;https://llvm.org/docs/Atomics.html#acquire&quot;&gt; &lt;code&gt;Acquire&lt;/code&gt; &lt;/a&gt; . Однако, &lt;a href=&quot;https://llvm.org/docs/Atomics.html#acquirerelease&quot;&gt; &lt;code&gt;AcqRel&lt;/code&gt; &lt;/a&gt; никогда не будет выполнять &lt;a href=&quot;https://llvm.org/docs/Atomics.html#monotonic&quot;&gt; &lt;code&gt;Relaxed&lt;/code&gt; &lt;/a&gt; доступов.</target>
        </trans-unit>
        <trans-unit id="d68951af70c1b2b14c8581375aa37ef775c2c882" translate="yes" xml:space="preserve">
          <source>Notice that the code panicked with the message &lt;code&gt;already borrowed: BorrowMutError&lt;/code&gt;. This is how &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt; handles violations of the borrowing rules at runtime.</source>
          <target state="translated">Обратите внимание, что код запаниковал с &lt;code&gt;already borrowed: BorrowMutError&lt;/code&gt; сообщением : BorrowMutError . Вот как &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt; обрабатывает нарушения правил заимствования во время выполнения.</target>
        </trans-unit>
        <trans-unit id="e6e01b202ce551c042845c38802ff1f31e6bfcd1" translate="yes" xml:space="preserve">
          <source>Notice that the compiler performs this copy automatically when dropping packed structs, i.e., you do not usually have to worry about such issues unless you call &lt;code&gt;drop_in_place&lt;/code&gt; manually.</source>
          <target state="translated">Обратите внимание, что компилятор выполняет эту копию автоматически при отбрасывании упакованных структур, т. &lt;code&gt;drop_in_place&lt;/code&gt; Вам обычно не нужно беспокоиться о таких проблемах, если вы не вызываете drop_in_place вручную.</target>
        </trans-unit>
        <trans-unit id="90e25cc098640b84fbba68a414a9fbb480dff45c" translate="yes" xml:space="preserve">
          <source>Notice that the first value in the vector is &lt;code&gt;&quot;target/debug/minigrep&quot;&lt;/code&gt;, which is the name of our binary. This matches the behavior of the arguments list in C, letting programs use the name by which they were invoked in their execution. It&amp;rsquo;s often convenient to have access to the program name in case you want to print it in messages or change behavior of the program based on what command line alias was used to invoke the program. But for the purposes of this chapter, we&amp;rsquo;ll ignore it and save only the two arguments we need.</source>
          <target state="translated">Обратите внимание, что первое значение в векторе - &lt;code&gt;&quot;target/debug/minigrep&quot;&lt;/code&gt; , что является именем нашего двоичного файла . Это соответствует поведению списка аргументов в C, позволяя программам использовать имя, под которым они были вызваны при их выполнении. Часто бывает удобно иметь доступ к имени программы, если вы хотите напечатать его в сообщениях или изменить поведение программы в зависимости от того, какой псевдоним командной строки использовался для вызова программы. Но для целей этой главы мы проигнорируем его и сохраним только два необходимых нам аргумента.</target>
        </trans-unit>
        <trans-unit id="a69330b1430c6944224f92b74bbe0967131daf2e" translate="yes" xml:space="preserve">
          <source>Notice that the only type we&amp;rsquo;re interacting with from the crate is the &lt;code&gt;Post&lt;/code&gt; type. This type will use the state pattern and will hold a value that will be one of three state objects representing the various states a post can be in&amp;mdash;draft, waiting for review, or published. Changing from one state to another will be managed internally within the &lt;code&gt;Post&lt;/code&gt; type. The states change in response to the methods called by our library&amp;rsquo;s users on the &lt;code&gt;Post&lt;/code&gt; instance, but they don&amp;rsquo;t have to manage the state changes directly. Also, users can&amp;rsquo;t make a mistake with the states, like publishing a post before it&amp;rsquo;s reviewed.</source>
          <target state="translated">Обратите внимание, что единственный тип, с которым мы взаимодействуем из ящика, - это тип &lt;code&gt;Post&lt;/code&gt; . Этот тип будет использовать шаблон состояния и будет содержать значение, которое будет одним из трех объектов состояния, представляющих различные состояния, в которых может находиться сообщение - черновик, ожидающий проверки или опубликованный. Управление переходом из одного состояния в другое осуществляется внутри типа &lt;code&gt;Post&lt;/code&gt; . Состояния изменяются в ответ на методы, вызываемые пользователями нашей библиотеки в экземпляре &lt;code&gt;Post&lt;/code&gt; , но им не нужно напрямую управлять изменениями состояния. Кроме того, пользователи не могут ошибиться с состояниями, например, опубликовать сообщение до его проверки.</target>
        </trans-unit>
        <trans-unit id="a7d5a7d44a98e57a3adf5c0193845ed9098d4a93" translate="yes" xml:space="preserve">
          <source>Notice that the workspace has only one &lt;em&gt;Cargo.lock&lt;/em&gt; file at the top level of the workspace rather than having a &lt;em&gt;Cargo.lock&lt;/em&gt; in each crate&amp;rsquo;s directory. This ensures that all crates are using the same version of all dependencies. If we add the &lt;code&gt;rand&lt;/code&gt; crate to the &lt;em&gt;adder/Cargo.toml&lt;/em&gt; and &lt;em&gt;add-one/Cargo.toml&lt;/em&gt; files, Cargo will resolve both of those to one version of &lt;code&gt;rand&lt;/code&gt; and record that in the one &lt;em&gt;Cargo.lock&lt;/em&gt;. Making all crates in the workspace use the same dependencies means the crates in the workspace will always be compatible with each other. Let&amp;rsquo;s add the &lt;code&gt;rand&lt;/code&gt; crate to the &lt;code&gt;[dependencies]&lt;/code&gt; section in the &lt;em&gt;add-one/Cargo.toml&lt;/em&gt; file to be able to use the &lt;code&gt;rand&lt;/code&gt; crate in the &lt;code&gt;add-one&lt;/code&gt; crate:</source>
          <target state="translated">Обратите внимание, что в рабочем пространстве есть только один файл &lt;em&gt;Cargo.lock&lt;/em&gt; на верхнем уровне рабочего пространства, а не в &lt;em&gt;каталоге&lt;/em&gt; каждого ящика &lt;em&gt;Cargo.lock&lt;/em&gt; . Это гарантирует, что все ящики используют одну и ту же версию всех зависимостей. Если мы добавим ящик &lt;code&gt;rand&lt;/code&gt; в &lt;em&gt;файлы adder / Cargo.toml&lt;/em&gt; и &lt;em&gt;add-one / Cargo.toml&lt;/em&gt; , Cargo разрешит оба из них в одной версии &lt;code&gt;rand&lt;/code&gt; и запишет это в один &lt;em&gt;Cargo.lock&lt;/em&gt; . Использование одинаковых зависимостей для всех ящиков в рабочей области означает, что ящики в рабочей области всегда будут совместимы друг с другом. Давайте добавим ящик &lt;code&gt;rand&lt;/code&gt; в раздел &lt;code&gt;[dependencies]&lt;/code&gt; в&lt;em&gt;add-one / Cargo.toml,&lt;/em&gt; чтобы иметь возможность использовать ящик &lt;code&gt;rand&lt;/code&gt; в &lt;em&gt;контейнере &lt;/em&gt; &lt;code&gt;add-one&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="43f89d0af380f75c1edd764ee3eac2d94a06cd6c" translate="yes" xml:space="preserve">
          <source>Notice that the workspace has only one &lt;em&gt;Cargo.lock&lt;/em&gt; file at the top level of the workspace rather than having a &lt;em&gt;Cargo.lock&lt;/em&gt; in each crate&amp;rsquo;s directory. This ensures that all crates are using the same version of all dependencies. If we add the &lt;code&gt;rand&lt;/code&gt; package to the &lt;em&gt;adder/Cargo.toml&lt;/em&gt; and &lt;em&gt;add-one/Cargo.toml&lt;/em&gt; files, Cargo will resolve both of those to one version of &lt;code&gt;rand&lt;/code&gt; and record that in the one &lt;em&gt;Cargo.lock&lt;/em&gt;. Making all crates in the workspace use the same dependencies means the crates in the workspace will always be compatible with each other. Let&amp;rsquo;s add the &lt;code&gt;rand&lt;/code&gt; crate to the &lt;code&gt;[dependencies]&lt;/code&gt; section in the &lt;em&gt;add-one/Cargo.toml&lt;/em&gt; file to be able to use the &lt;code&gt;rand&lt;/code&gt; crate in the &lt;code&gt;add-one&lt;/code&gt; crate:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aa6a1647ef2a65fa35dd0dfd2179008c8845ec9d" translate="yes" xml:space="preserve">
          <source>Notice that this guarantee does &lt;em&gt;not&lt;/em&gt; mean that memory does not leak! It is still completely okay not ever to call &lt;a href=&quot;../ops/trait.drop#tymethod.drop&quot;&gt;&lt;code&gt;drop&lt;/code&gt;&lt;/a&gt; on a pinned element (e.g., you can still call &lt;a href=&quot;../mem/fn.forget&quot;&gt;&lt;code&gt;mem::forget&lt;/code&gt;&lt;/a&gt; on a &lt;a href=&quot;struct.pin&quot;&gt;&lt;code&gt;Pin&lt;/code&gt;&lt;/a&gt;&lt;code&gt;&amp;lt;&lt;/code&gt;&lt;a href=&quot;../boxed/struct.box&quot;&gt;&lt;code&gt;Box&lt;/code&gt;&lt;/a&gt;&lt;code&gt;&amp;lt;T&amp;gt;&amp;gt;&lt;/code&gt;). In the example of the doubly-linked list, that element would just stay in the list. However you may not free or reuse the storage &lt;em&gt;without calling &lt;a href=&quot;../ops/trait.drop#tymethod.drop&quot;&gt;&lt;code&gt;drop&lt;/code&gt;&lt;/a&gt;&lt;/em&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d099748c8a2369f6e0484b9fb1916260cb072d44" translate="yes" xml:space="preserve">
          <source>Notice that this guarantee does &lt;em&gt;not&lt;/em&gt; mean that memory does not leak! It is still completely okay not ever to call &lt;code&gt;drop&lt;/code&gt; on a pinned element (e.g., you can still call &lt;a href=&quot;../mem/fn.forget&quot;&gt;&lt;code&gt;mem::forget&lt;/code&gt;&lt;/a&gt; on a &lt;code&gt;Pin&amp;lt;Box&amp;lt;T&amp;gt;&amp;gt;&lt;/code&gt;). In the example of the doubly-linked list, that element would just stay in the list. However you may not free or reuse the storage &lt;em&gt;without calling &lt;code&gt;drop&lt;/code&gt;&lt;/em&gt;.</source>
          <target state="translated">Обратите внимание, что эта гарантия &lt;em&gt;не&lt;/em&gt; означает, что память не протекает! По-прежнему совершенно нормально никогда не вызывать &lt;code&gt;drop&lt;/code&gt; для закрепленного элемента (например, вы все еще можете вызывать &lt;a href=&quot;../mem/fn.forget&quot;&gt; &lt;code&gt;mem::forget&lt;/code&gt; &lt;/a&gt; для &lt;code&gt;Pin&amp;lt;Box&amp;lt;T&amp;gt;&amp;gt;&lt;/code&gt; ). В примере с двусвязным списком этот элемент просто останется в списке. Однако вы не можете освободить или повторно использовать хранилище &lt;em&gt;без вызова &lt;code&gt;drop&lt;/code&gt; &lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="e8e96d92ae370594b0a23d663a0a9b44ba5cff77" translate="yes" xml:space="preserve">
          <source>Notice that this time we didn&amp;rsquo;t see output indicating that Cargo was compiling &lt;code&gt;hello_cargo&lt;/code&gt;. Cargo figured out that the files hadn&amp;rsquo;t changed, so it just ran the binary. If you had modified your source code, Cargo would have rebuilt the project before running it, and you would have seen this output:</source>
          <target state="translated">Обратите внимание, что на этот раз мы не увидели вывода, указывающего на то, что Cargo компилирует &lt;code&gt;hello_cargo&lt;/code&gt; . Cargo выяснил, что файлы не изменились, поэтому просто запустил двоичный файл. Если бы вы изменили исходный код, Cargo пересобирал бы проект перед его запуском, и вы бы увидели такой вывод:</target>
        </trans-unit>
        <trans-unit id="75afd928e1d9d07e8e8783b4a4c896142a3ef3bd" translate="yes" xml:space="preserve">
          <source>Notice that using this ordering for an operation that combines loads and stores leads to a &lt;a href=&quot;enum.ordering#variant.Relaxed&quot;&gt;&lt;code&gt;Relaxed&lt;/code&gt;&lt;/a&gt; load operation!</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bc0d2528578bd301fdbec6c6a7d80185cfd20062" translate="yes" xml:space="preserve">
          <source>Notice that using this ordering for an operation that combines loads and stores leads to a &lt;a href=&quot;enum.ordering#variant.Relaxed&quot;&gt;&lt;code&gt;Relaxed&lt;/code&gt;&lt;/a&gt; store operation!</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6af1b53e3b0f26b23d98afe8cfa1fff0e78676da" translate="yes" xml:space="preserve">
          <source>Notice that using this ordering for an operation that combines loads and stores leads to a &lt;a href=&quot;https://llvm.org/docs/Atomics.html#monotonic&quot;&gt;&lt;code&gt;Relaxed&lt;/code&gt;&lt;/a&gt; load operation!</source>
          <target state="translated">Обратите внимание, что использование этого порядка для операции, объединяющей загрузки и сохранения, приводит к операции &lt;a href=&quot;https://llvm.org/docs/Atomics.html#monotonic&quot;&gt; &lt;code&gt;Relaxed&lt;/code&gt; &lt;/a&gt; загрузки!</target>
        </trans-unit>
        <trans-unit id="a34cbcc2842b5a9803de21bbd3cea40bd2f9faf2" translate="yes" xml:space="preserve">
          <source>Notice that using this ordering for an operation that combines loads and stores leads to a &lt;a href=&quot;https://llvm.org/docs/Atomics.html#monotonic&quot;&gt;&lt;code&gt;Relaxed&lt;/code&gt;&lt;/a&gt; store operation!</source>
          <target state="translated">Обратите внимание, что использование этого порядка для операции, которая объединяет загрузки и сохранения, приводит к операции &lt;a href=&quot;https://llvm.org/docs/Atomics.html#monotonic&quot;&gt; &lt;code&gt;Relaxed&lt;/code&gt; &lt;/a&gt; хранения!</target>
        </trans-unit>
        <trans-unit id="1648ed9eef01e81103715c2fb558bce27eedcadf" translate="yes" xml:space="preserve">
          <source>Notice that we don&amp;rsquo;t include the &lt;code&gt;unsafe&lt;/code&gt; keyword in this code. We can create raw pointers in safe code; we just can&amp;rsquo;t dereference raw pointers outside an unsafe block, as you&amp;rsquo;ll see in a bit.</source>
          <target state="translated">Обратите внимание, что мы не включаем ключевое слово &lt;code&gt;unsafe&lt;/code&gt; в этот код. Мы можем создавать необработанные указатели в безопасном коде; мы просто не можем разыменовать необработанные указатели вне небезопасного блока, как вы вскоре увидите.</target>
        </trans-unit>
        <trans-unit id="111ab81f0256d10482ec4d240e310c1571a40527" translate="yes" xml:space="preserve">
          <source>Notice that we need an explicit lifetime &lt;code&gt;'a&lt;/code&gt; defined in the signature of &lt;code&gt;search&lt;/code&gt; and used with the &lt;code&gt;contents&lt;/code&gt; argument and the return value. Recall in &lt;a href=&quot;ch10-03-lifetime-syntax&quot;&gt;Chapter 10&lt;/a&gt; that the lifetime parameters specify which argument lifetime is connected to the lifetime of the return value. In this case, we indicate that the returned vector should contain string slices that reference slices of the argument &lt;code&gt;contents&lt;/code&gt; (rather than the argument &lt;code&gt;query&lt;/code&gt;).</source>
          <target state="translated">Обратите внимание, что нам нужно явное время жизни &lt;code&gt;'a&lt;/code&gt; определенное в сигнатуре &lt;code&gt;search&lt;/code&gt; и используемое с аргументом &lt;code&gt;contents&lt;/code&gt; и возвращаемым значением. Напомним, что в &lt;a href=&quot;ch10-03-lifetime-syntax&quot;&gt;главе 10&lt;/a&gt; параметры времени жизни указывают, какое время жизни аргумента связано со временем жизни возвращаемого значения. В этом случае мы указываем, что возвращаемый вектор должен содержать фрагменты строки, которые ссылаются на фрагменты &lt;code&gt;contents&lt;/code&gt; аргумента (а не &lt;code&gt;query&lt;/code&gt; аргумента ).</target>
        </trans-unit>
        <trans-unit id="fd9233164b7146f50abe145b0977e2ddba8ac9ff" translate="yes" xml:space="preserve">
          <source>Notice that we&amp;rsquo;ve split the code into the &lt;code&gt;hello_macro_derive&lt;/code&gt; function, which is responsible for parsing the &lt;code&gt;TokenStream&lt;/code&gt;, and the &lt;code&gt;impl_hello_macro&lt;/code&gt; function, which is responsible for transforming the syntax tree: this makes writing a procedural macro more convenient. The code in the outer function (&lt;code&gt;hello_macro_derive&lt;/code&gt; in this case) will be the same for almost every procedural macro crate you see or create. The code you specify in the body of the inner function (&lt;code&gt;impl_hello_macro&lt;/code&gt; in this case) will be different depending on your procedural macro&amp;rsquo;s purpose.</source>
          <target state="translated">Обратите внимание, что мы разделили код на функцию &lt;code&gt;hello_macro_derive&lt;/code&gt; , которая отвечает за синтаксический анализ &lt;code&gt;TokenStream&lt;/code&gt; , и функцию &lt;code&gt;impl_hello_macro&lt;/code&gt; , которая отвечает за преобразование синтаксического дерева: это делает написание процедурного макроса более удобным. Код во внешней функции ( в данном случае &lt;code&gt;hello_macro_derive&lt;/code&gt; ) будет одинаковым почти для всех процедурных ящиков макросов, которые вы видите или создаете. Код, который вы указываете в теле внутренней функции ( в данном случае &lt;code&gt;impl_hello_macro&lt;/code&gt; ), будет отличаться в зависимости от цели вашего процедурного макроса.</target>
        </trans-unit>
        <trans-unit id="8966a5e7726edf21a4dc24ce7e3b95ed94980ac9" translate="yes" xml:space="preserve">
          <source>Notice there isn&amp;rsquo;t any code after the last line that begins with &lt;code&gt;//!&lt;/code&gt;. Because we started the comments with &lt;code&gt;//!&lt;/code&gt; instead of &lt;code&gt;///&lt;/code&gt;, we&amp;rsquo;re documenting the item that contains this comment rather than an item that follows this comment. In this case, the item that contains this comment is the &lt;em&gt;src/lib.rs&lt;/em&gt; file, which is the crate root. These comments describe the entire crate.</source>
          <target state="translated">Обратите внимание, что после последней строки, начинающейся с &lt;code&gt;//!&lt;/code&gt; нет кода ! . Потому что мы начали комментарии с &lt;code&gt;//!&lt;/code&gt; вместо &lt;code&gt;///&lt;/code&gt; мы документируем элемент, содержащий этот комментарий, а не элемент, следующий за этим комментарием. В этом случае элементом, содержащим этот комментарий, является файл &lt;em&gt;src / lib.rs&lt;/em&gt; , который является корнем ящика. Эти комментарии описывают весь ящик.</target>
        </trans-unit>
        <trans-unit id="fcd0fb110f9fe32ec66824d300336739072d5b34" translate="yes" xml:space="preserve">
          <source>Notice this definition uses some new syntax: &lt;code&gt;type Item&lt;/code&gt; and &lt;code&gt;Self::Item&lt;/code&gt;, which are defining an &lt;em&gt;associated type&lt;/em&gt; with this trait. We&amp;rsquo;ll talk about associated types in depth in Chapter 19. For now, all you need to know is that this code says implementing the &lt;code&gt;Iterator&lt;/code&gt; trait requires that you also define an &lt;code&gt;Item&lt;/code&gt; type, and this &lt;code&gt;Item&lt;/code&gt; type is used in the return type of the &lt;code&gt;next&lt;/code&gt; method. In other words, the &lt;code&gt;Item&lt;/code&gt; type will be the type returned from the iterator.</source>
          <target state="translated">Обратите внимание, что в этом определении используется новый синтаксис: &lt;code&gt;type Item&lt;/code&gt; и &lt;code&gt;Self::Item&lt;/code&gt; , которые определяют &lt;em&gt;связанный тип&lt;/em&gt; с этой характеристикой. Мы подробно поговорим о связанных типах в главе 19. На данный момент все, что вам нужно знать, это то, что в этом коде говорится, что для реализации трейта &lt;code&gt;Iterator&lt;/code&gt; необходимо также определить тип &lt;code&gt;Item&lt;/code&gt; , и этот тип &lt;code&gt;Item&lt;/code&gt; используется в типе возвращаемого значения &lt;code&gt;next&lt;/code&gt; метод. Другими словами, тип &lt;code&gt;Item&lt;/code&gt; будет типом, возвращаемым итератором.</target>
        </trans-unit>
        <trans-unit id="e0aa323f0e9e9e9d80a8d3d6a7b2a9db9ba76843" translate="yes" xml:space="preserve">
          <source>Now all the instances of &lt;code&gt;Point&lt;/code&gt; shown are allowed! You can use as many generic type parameters in a definition as you want, but using more than a few makes your code hard to read. When you need lots of generic types in your code, it could indicate that your code needs restructuring into smaller pieces.</source>
          <target state="translated">Теперь все показанные экземпляры &lt;code&gt;Point&lt;/code&gt; разрешены! Вы можете использовать в определении столько параметров универсального типа, сколько захотите, но использование большего количества параметров затрудняет чтение вашего кода. Когда вам нужно много общих типов в вашем коде, это может указывать на то, что ваш код нуждается в реструктуризации на более мелкие части.</target>
        </trans-unit>
        <trans-unit id="23eaa14436421a3e3cff4560bf4fb71eb52f11da" translate="yes" xml:space="preserve">
          <source>Now all the references in this function signature have lifetimes, and the compiler can continue its analysis without needing the programmer to annotate the lifetimes in this function signature.</source>
          <target state="translated">Теперь все ссылки в сигнатуре этой функции имеют пожизненный срок службы,и компилятор может продолжить свой анализ,не требуя от программиста аннотации пожизненного срока службы в сигнатуре этой функции.</target>
        </trans-unit>
        <trans-unit id="6e1a1d010dc9ab9a0953fedbe299c3c77ffa1062" translate="yes" xml:space="preserve">
          <source>Now an example of &lt;code&gt;bool&lt;/code&gt; cast to integer type:</source>
          <target state="translated">Теперь пример приведения &lt;code&gt;bool&lt;/code&gt; к целочисленному типу:</target>
        </trans-unit>
        <trans-unit id="d65b9b0f422f439e94c8e42e9b963ca1e3008607" translate="yes" xml:space="preserve">
          <source>Now consider this twist where we add a call to &lt;code&gt;rev&lt;/code&gt;. This version will print &lt;code&gt;('c', 1), ('b', 2), ('a', 3)&lt;/code&gt;. Note that the letters are reversed, but the values of the counter still go in order. This is because &lt;code&gt;map()&lt;/code&gt; is still being called lazily on each item, but we are popping items off the back of the vector now, instead of shifting them from the front.</source>
          <target state="translated">Теперь рассмотрим этот поворот, когда мы добавляем вызов в &lt;code&gt;rev&lt;/code&gt; . Эта версия напечатает &lt;code&gt;('c', 1), ('b', 2), ('a', 3)&lt;/code&gt; . Обратите внимание, что буквы поменяны местами, но значения счетчика по-прежнему идут по порядку. Это потому, что &lt;code&gt;map()&lt;/code&gt; по-прежнему лениво вызывается для каждого элемента, но теперь мы выталкиваем элементы с обратной стороны вектора, а не смещаем их спереди.</target>
        </trans-unit>
        <trans-unit id="3a875ba4bda66efea86acc1d83b8c4cd40356ff2" translate="yes" xml:space="preserve">
          <source>Now enter the code in Listing 20-1 in &lt;em&gt;src/main.rs&lt;/em&gt; to start. This code will listen at the address &lt;code&gt;127.0.0.1:7878&lt;/code&gt; for incoming TCP streams. When it gets an incoming stream, it will print &lt;code&gt;Connection established!&lt;/code&gt;.</source>
          <target state="translated">Теперь введите код из Листинга 20-1 в &lt;em&gt;src / main.rs,&lt;/em&gt; чтобы начать. Этот код будет прослушивать по адресу &lt;code&gt;127.0.0.1:7878&lt;/code&gt; входящие потоки TCP. Когда он получит входящий поток, он напечатает &amp;laquo; &lt;code&gt;Connection established!&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="dc71b87d7408d245b3b0aa3a92982cb74fc6ac9f" translate="yes" xml:space="preserve">
          <source>Now everything in the program should work as expected. Let&amp;rsquo;s try it:</source>
          <target state="translated">Теперь все в программе должно работать как положено. Давай попробуем:</target>
        </trans-unit>
        <trans-unit id="d7f4763863038d188ed1914c2142e2e561d22201" translate="yes" xml:space="preserve">
          <source>Now if we change either the function or the example so the &lt;code&gt;assert_eq!&lt;/code&gt; in the example panics and run &lt;code&gt;cargo test&lt;/code&gt; again, we&amp;rsquo;ll see that the doc tests catch that the example and the code are out of sync with each other!</source>
          <target state="translated">Теперь, если мы изменим либо функцию, либо пример так, чтобы &lt;code&gt;assert_eq!&lt;/code&gt; в примере паникает и снова запускается &lt;code&gt;cargo test&lt;/code&gt; , мы увидим, что тесты документации обнаруживают, что пример и код не синхронизированы друг с другом!</target>
        </trans-unit>
        <trans-unit id="2e5aa4ec7130600ff4ecc4d4f5150848ff00d36e" translate="yes" xml:space="preserve">
          <source>Now it's possible to create at least one instance of &lt;code&gt;Foo&lt;/code&gt;: &lt;code&gt;Foo { x: None }&lt;/code&gt;.</source>
          <target state="translated">Теперь можно создать хотя бы один экземпляр &lt;code&gt;Foo&lt;/code&gt; : &lt;code&gt;Foo { x: None }&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="57dee911ce426e019e30db0fccc486981ac3d8d4" translate="yes" xml:space="preserve">
          <source>Now let&amp;rsquo;s add the code in Listing 20-7 to the &lt;code&gt;else&lt;/code&gt; block to return a response with the status code 404, which signals that the content for the request was not found. We&amp;rsquo;ll also return some HTML for a page to render in the browser indicating the response to the end user.</source>
          <target state="translated">Теперь давайте добавим код из листинга 20-7 в блок &lt;code&gt;else&lt;/code&gt; , чтобы вернуть ответ с кодом состояния 404, который сигнализирует, что контент для запроса не был найден. Мы также вернем HTML-код для страницы, отображаемой в браузере, с указанием ответа конечному пользователю.</target>
        </trans-unit>
        <trans-unit id="82511279c647b8b87ee818b8d44458ab76617b1f" translate="yes" xml:space="preserve">
          <source>Now let&amp;rsquo;s compile this &amp;ldquo;Hello, world!&amp;rdquo; program and run it in the same step using the &lt;code&gt;cargo run&lt;/code&gt; command:</source>
          <target state="translated">Теперь давайте скомпилируем это &amp;laquo;Hello, world!&amp;raquo; программу и запустите ее на том же этапе, используя команду &lt;code&gt;cargo run&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="8863ee5075a8246e730bfe40012862faba75a02b" translate="yes" xml:space="preserve">
          <source>Now let&amp;rsquo;s consider the second call of &lt;code&gt;plus_one&lt;/code&gt; in Listing 6-5, where &lt;code&gt;x&lt;/code&gt; is &lt;code&gt;None&lt;/code&gt;. We enter the &lt;code&gt;match&lt;/code&gt; and compare to the first arm.</source>
          <target state="translated">Теперь давайте рассмотрим второй вызов &lt;code&gt;plus_one&lt;/code&gt; в листинге 6-5, где &lt;code&gt;x&lt;/code&gt; - &lt;code&gt;None&lt;/code&gt; . Входим в &lt;code&gt;match&lt;/code&gt; и сравниваем с первой рукой.</target>
        </trans-unit>
        <trans-unit id="b8300b290a67f9ed128322c21050dab12f2d0aa0" translate="yes" xml:space="preserve">
          <source>Now let&amp;rsquo;s examine lifetime annotations in the context of the &lt;code&gt;longest&lt;/code&gt; function. As with generic type parameters, we need to declare generic lifetime parameters inside angle brackets between the function name and the parameter list. The constraint we want to express in this signature is that all the references in the parameters and the return value must have the same lifetime. We&amp;rsquo;ll name the lifetime &lt;code&gt;'a&lt;/code&gt; and then add it to each reference, as shown in Listing 10-22.</source>
          <target state="translated">Теперь давайте рассмотрим аннотации времени жизни в контексте самой &lt;code&gt;longest&lt;/code&gt; функции. Как и в случае с параметрами универсального типа, нам необходимо объявить параметры универсального времени в угловых скобках между именем функции и списком параметров. Ограничение, которое мы хотим выразить в этой сигнатуре, состоит в том, что все ссылки в параметрах и возвращаемом значении должны иметь одинаковое время жизни. Мы назовем время жизни &lt;code&gt;'a&lt;/code&gt; и затем добавим его к каждой ссылке, как показано в Листинге 10-22.</target>
        </trans-unit>
        <trans-unit id="4d1d28eae4c7f65ed347f71ad22936c83ed0eb43" translate="yes" xml:space="preserve">
          <source>Now let&amp;rsquo;s lean on the compiler to find the other places that need to change. Checking this code, we get two errors:</source>
          <target state="translated">Теперь давайте опираемся на компилятор, чтобы найти другие места, которые нужно изменить. Проверяя этот код, получаем две ошибки:</target>
        </trans-unit>
        <trans-unit id="89a2cc6c6da74e574a540dd470febae8d113a245" translate="yes" xml:space="preserve">
          <source>Now let&amp;rsquo;s look at the &lt;code&gt;String&lt;/code&gt; version:</source>
          <target state="translated">Теперь посмотрим на версию &lt;code&gt;String&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="aaee68df203c11b18152dd8afe26709ec73580c1" translate="yes" xml:space="preserve">
          <source>Now let&amp;rsquo;s look at the pattern in the body of the code associated with this arm: &lt;code&gt;temp_vec.push()&lt;/code&gt; within &lt;code&gt;$()*&lt;/code&gt; is generated for each part that matches &lt;code&gt;$()&lt;/code&gt; in the pattern zero or more times depending on how many times the pattern matches. The &lt;code&gt;$x&lt;/code&gt; is replaced with each expression matched. When we call this macro with &lt;code&gt;vec![1, 2, 3];&lt;/code&gt;, the code generated that replaces this macro call will be the following:</source>
          <target state="translated">Теперь давайте посмотрим на шаблон в теле кода, связанного с этой рукой: &lt;code&gt;temp_vec.push()&lt;/code&gt; внутри &lt;code&gt;$()*&lt;/code&gt; создается для каждой части, которая соответствует &lt;code&gt;$()&lt;/code&gt; в шаблоне ноль или более раз, в зависимости от того, сколько раз совпадение шаблонов. &lt;code&gt;$x&lt;/code&gt; заменяется с каждым выражением согласованной. Когда мы вызываем этот макрос с помощью &lt;code&gt;vec![1, 2, 3];&lt;/code&gt; , сгенерированный код, заменяющий этот вызов макроса, будет следующим:</target>
        </trans-unit>
        <trans-unit id="c4243cfe8f9ac10ec246b38ad823287bb3f58d73" translate="yes" xml:space="preserve">
          <source>Now let&amp;rsquo;s look at what&amp;rsquo;s different when we build and run the &amp;ldquo;Hello, world!&amp;rdquo; program with Cargo! From your &lt;em&gt;hello_cargo&lt;/em&gt; directory, build your project by entering the following command:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="80b98c3dc4276471e5dedcfc50a6872d575390db" translate="yes" xml:space="preserve">
          <source>Now let&amp;rsquo;s look at what&amp;rsquo;s different when we build and run the Hello, world! program with Cargo! From your &lt;em&gt;hello_cargo&lt;/em&gt; directory, build your project by entering the following command:</source>
          <target state="translated">Теперь давайте посмотрим, что изменилось при создании и запуске Hello, world! программа с Cargo! В каталоге &lt;em&gt;hello_cargo&lt;/em&gt; создайте проект, введя следующую команду:</target>
        </trans-unit>
        <trans-unit id="5b581411bc505a7c21b9a362d12d054fb0134b63" translate="yes" xml:space="preserve">
          <source>Now let&amp;rsquo;s run the test:</source>
          <target state="translated">Теперь запустим тест:</target>
        </trans-unit>
        <trans-unit id="f0501637a3932ce5ddf54dd291b5e0f5788b9a63" translate="yes" xml:space="preserve">
          <source>Now open &lt;em&gt;src/main.rs&lt;/em&gt; and take a look:</source>
          <target state="translated">Теперь откройте &lt;em&gt;src / main.rs&lt;/em&gt; и посмотрите:</target>
        </trans-unit>
        <trans-unit id="b399f29f23b6c286984286dd9b48d3e844228cb4" translate="yes" xml:space="preserve">
          <source>Now open the &lt;em&gt;main.rs&lt;/em&gt; file you just created and enter the code in Listing 1-1.</source>
          <target state="translated">Теперь откройте только что &lt;em&gt;созданный&lt;/em&gt; файл &lt;em&gt;main.rs&lt;/em&gt; и введите код из Листинга 1-1.</target>
        </trans-unit>
        <trans-unit id="d981ccfedbc387139591c6429e1ab6bbb51ae547" translate="yes" xml:space="preserve">
          <source>Now our code more clearly conveys that &lt;code&gt;query&lt;/code&gt; and &lt;code&gt;filename&lt;/code&gt; are related and that their purpose is to configure how the program will work. Any code that uses these values knows to find them in the &lt;code&gt;config&lt;/code&gt; instance in the fields named for their purpose.</source>
          <target state="translated">Теперь наш код более четко передает, что &lt;code&gt;query&lt;/code&gt; и &lt;code&gt;filename&lt;/code&gt; связаны, и что их цель - настроить работу программы. Любой код, использующий эти значения, знает, как найти их в экземпляре &lt;code&gt;config&lt;/code&gt; в полях, названных в соответствии с их назначением.</target>
        </trans-unit>
        <trans-unit id="e98906bcddd6edae414bc05f0060b41c04becc18" translate="yes" xml:space="preserve">
          <source>Now run &lt;code&gt;cargo test&lt;/code&gt; in the top-level &lt;em&gt;add&lt;/em&gt; directory:</source>
          <target state="translated">Теперь запустите &lt;code&gt;cargo test&lt;/code&gt; в каталоге &lt;em&gt;добавления&lt;/em&gt; верхнего уровня :</target>
        </trans-unit>
        <trans-unit id="d7999991a01bc3db0ab51179e8f7d5b7ea1e4709" translate="yes" xml:space="preserve">
          <source>Now that the &lt;code&gt;search&lt;/code&gt; function is working and tested, we need to call &lt;code&gt;search&lt;/code&gt; from our &lt;code&gt;run&lt;/code&gt; function. We need to pass the &lt;code&gt;config.query&lt;/code&gt; value and the &lt;code&gt;contents&lt;/code&gt; that &lt;code&gt;run&lt;/code&gt; reads from the file to the &lt;code&gt;search&lt;/code&gt; function. Then &lt;code&gt;run&lt;/code&gt; will print each line returned from &lt;code&gt;search&lt;/code&gt;:</source>
          <target state="translated">Теперь, когда функция &lt;code&gt;search&lt;/code&gt; работает и протестирована, нам нужно вызвать &lt;code&gt;search&lt;/code&gt; из нашей функции &lt;code&gt;run&lt;/code&gt; . Нам нужно передать значение &lt;code&gt;config.query&lt;/code&gt; и &lt;code&gt;contents&lt;/code&gt; которое &lt;code&gt;run&lt;/code&gt; чтение из файла, в функцию &lt;code&gt;search&lt;/code&gt; . Затем &lt;code&gt;run&lt;/code&gt; напечатает каждую строку, полученную при &lt;code&gt;search&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="03229adf31a42bdb64eb9cba521d26f0154223d5" translate="yes" xml:space="preserve">
          <source>Now that the closure has its own copy of the data, there's no need to worry about safety.</source>
          <target state="translated">Теперь,когда у закрытия есть своя копия данных,нет необходимости беспокоиться о безопасности.</target>
        </trans-unit>
        <trans-unit id="80c8ae661a453d666a29851514f9590667d50328" translate="yes" xml:space="preserve">
          <source>Now that we have a library crate in the workspace, we can have the binary crate &lt;code&gt;adder&lt;/code&gt; depend on the library crate &lt;code&gt;add-one&lt;/code&gt;. First, we&amp;rsquo;ll need to add a path dependency on &lt;code&gt;add-one&lt;/code&gt; to &lt;em&gt;adder/Cargo.toml&lt;/em&gt;.</source>
          <target state="translated">Теперь, когда у нас есть ящик с библиотекой в ​​рабочей области, мы можем сделать так, чтобы двоичный &lt;code&gt;adder&lt;/code&gt; ящиков зависел от &lt;code&gt;add-one&lt;/code&gt; библиотеки . Во-первых, нам нужно добавить зависимость пути от &lt;code&gt;add-one&lt;/code&gt; в &lt;em&gt;adder / Cargo.toml&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="e1d03746f7af11550c4dab530f554fdd12c9b9be" translate="yes" xml:space="preserve">
          <source>Now that we have a way to know we have a valid number of threads to store in the pool, we can create those threads and store them in the &lt;code&gt;ThreadPool&lt;/code&gt; struct before returning it. But how do we &amp;ldquo;store&amp;rdquo; a thread? Let&amp;rsquo;s take another look at the &lt;code&gt;thread::spawn&lt;/code&gt; signature:</source>
          <target state="translated">Теперь, когда у нас есть способ узнать, что у нас есть допустимое количество потоков для хранения в пуле, мы можем создать эти потоки и сохранить их в структуре &lt;code&gt;ThreadPool&lt;/code&gt; перед ее возвратом. Но как нам &amp;laquo;хранить&amp;raquo; нить? Давайте еще раз посмотрим на подпись &lt;code&gt;thread::spawn&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="bda29c679c337b77198a68eb0c281ffe77fd4dfe" translate="yes" xml:space="preserve">
          <source>Now that we have an external dependency, Cargo fetches the latest versions of everything from the &lt;em&gt;registry&lt;/em&gt;, which is a copy of data from &lt;a href=&quot;https://crates.io/&quot;&gt;Crates.io&lt;/a&gt;. Crates.io is where people in the Rust ecosystem post their open source Rust projects for others to use.</source>
          <target state="translated">Теперь, когда у нас есть внешняя зависимость, Cargo извлекает последние версии всего из &lt;em&gt;реестра&lt;/em&gt; , который является копией данных из &lt;a href=&quot;https://crates.io/&quot;&gt;Crates.io&lt;/a&gt; . Crates.io - это место, где люди в экосистеме Rust публикуют свои проекты на Rust с открытым исходным кодом для использования другими.</target>
        </trans-unit>
        <trans-unit id="b1ccc08848b1ba0169c7f988c879a0f190ff1fea" translate="yes" xml:space="preserve">
          <source>Now that we have another package in the workspace, we can have the &lt;code&gt;adder&lt;/code&gt; package with our binary depend on the &lt;code&gt;add-one&lt;/code&gt; package, that has our library. First, we&amp;rsquo;ll need to add a path dependency on &lt;code&gt;add-one&lt;/code&gt; to &lt;em&gt;adder/Cargo.toml&lt;/em&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3228f1351fbe40c57701ca17a80dd025a6bfe94f" translate="yes" xml:space="preserve">
          <source>Now that we have the code to turn the annotated Rust code from a &lt;code&gt;TokenStream&lt;/code&gt; into a &lt;code&gt;DeriveInput&lt;/code&gt; instance, let&amp;rsquo;s generate the code that implements the &lt;code&gt;HelloMacro&lt;/code&gt; trait on the annotated type, as shown in Listing 19-33.</source>
          <target state="translated">Теперь, когда у нас есть код для &lt;code&gt;TokenStream&lt;/code&gt; аннотированного кода Rust из TokenStream в экземпляр &lt;code&gt;DeriveInput&lt;/code&gt; , давайте сгенерируем код, который реализует черту &lt;code&gt;HelloMacro&lt;/code&gt; для аннотированного типа, как показано в Листинге 19-33.</target>
        </trans-unit>
        <trans-unit id="a05d1adf4441c02b17aff2e4ed6b1b6d76dccfa3" translate="yes" xml:space="preserve">
          <source>Now that we have the context, let&amp;rsquo;s get to the algorithm. The function &lt;code&gt;generate_workout&lt;/code&gt; in Listing 13-3 contains the business logic of the app that we&amp;rsquo;re most concerned with in this example. The rest of the code changes in this example will be made to this function.</source>
          <target state="translated">Теперь, когда у нас есть контекст, давайте перейдем к алгоритму. Функция &lt;code&gt;generate_workout&lt;/code&gt; в листинге 13-3 содержит бизнес-логику приложения, которое нас больше всего интересует в этом примере. Остальные изменения кода в этом примере будут внесены в эту функцию.</target>
        </trans-unit>
        <trans-unit id="d0d7185e0fbe1a274eebe89e5b39be3986c2db0a" translate="yes" xml:space="preserve">
          <source>Now that we have user input and a random number, we can compare them. That step is shown in Listing 2-4. Note that this code won&amp;rsquo;t compile quite yet, as we will explain.</source>
          <target state="translated">Теперь, когда у нас есть вводимые пользователем данные и случайное число, мы можем их сравнить. Этот шаг показан в листинге 2-4. Обратите внимание, что этот код еще не компилируется, как мы объясним.</target>
        </trans-unit>
        <trans-unit id="38f50db14e5d3025086efbe8bea15a9ba8ef6b08" translate="yes" xml:space="preserve">
          <source>Now that we know what the browser is asking for, let&amp;rsquo;s send back some data!</source>
          <target state="translated">Теперь, когда мы знаем, что запрашивает браузер, давайте вернем некоторые данные!</target>
        </trans-unit>
        <trans-unit id="e92484795e9a806e19045c8bd7479798242a92b0" translate="yes" xml:space="preserve">
          <source>Now that we&amp;rsquo;ve defined the desired behavior using the &lt;code&gt;Summary&lt;/code&gt; trait, we can implement it on the types in our media aggregator. Listing 10-13 shows an implementation of the &lt;code&gt;Summary&lt;/code&gt; trait on the &lt;code&gt;NewsArticle&lt;/code&gt; struct that uses the headline, the author, and the location to create the return value of &lt;code&gt;summarize&lt;/code&gt;. For the &lt;code&gt;Tweet&lt;/code&gt; struct, we define &lt;code&gt;summarize&lt;/code&gt; as the username followed by the entire text of the tweet, assuming that tweet content is already limited to 280 characters.</source>
          <target state="translated">Теперь, когда мы определили желаемое поведение с помощью трейта &lt;code&gt;Summary&lt;/code&gt; , мы можем реализовать его для типов в нашем агрегаторе мультимедиа. В листинге 10-13 показана реализация трейта &lt;code&gt;Summary&lt;/code&gt; в структуре &lt;code&gt;NewsArticle&lt;/code&gt; , которая использует заголовок, автора и местоположение для создания возвращаемого значения &lt;code&gt;summarize&lt;/code&gt; . Для &lt;code&gt;Tweet&lt;/code&gt; структуры, мы определяем &lt;code&gt;summarize&lt;/code&gt; , как имя пользователя , а затем весь текст чирикать, при условии , что содержание твит уже ограничена 280 символами.</target>
        </trans-unit>
        <trans-unit id="847c864456f96a628c83e8df1e38c081c9008635" translate="yes" xml:space="preserve">
          <source>Now that we&amp;rsquo;ve defined threads in Rust, let&amp;rsquo;s explore how to use the thread-related API provided by the standard library.</source>
          <target state="translated">Теперь, когда мы определили потоки в Rust, давайте рассмотрим, как использовать связанный с потоками API, предоставляемый стандартной библиотекой.</target>
        </trans-unit>
        <trans-unit id="4bba9ff87fd1d7a113978a70c232f211dcf89ab4" translate="yes" xml:space="preserve">
          <source>Now that we&amp;rsquo;ve discussed some of the most common ways to use vectors, be sure to review &lt;a href=&quot;../std/vec/struct.vec&quot;&gt;the API documentation&lt;/a&gt; for all the many useful methods defined on &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; by the standard library. For example, in addition to &lt;code&gt;push&lt;/code&gt;, a &lt;code&gt;pop&lt;/code&gt; method removes and returns the last element. Let&amp;rsquo;s move on to the next collection type: &lt;code&gt;String&lt;/code&gt;!</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="87dd1868af24eb68dc999a15f4b71b72a52c4914" translate="yes" xml:space="preserve">
          <source>Now that we&amp;rsquo;ve discussed some of the most common ways to use vectors, be sure to review the API documentation for all the many useful methods defined on &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; by the standard library. For example, in addition to &lt;code&gt;push&lt;/code&gt;, a &lt;code&gt;pop&lt;/code&gt; method removes and returns the last element. Let&amp;rsquo;s move on to the next collection type: &lt;code&gt;String&lt;/code&gt;!</source>
          <target state="translated">Теперь, когда мы обсудили некоторые из наиболее распространенных способов использования векторов, обязательно просмотрите документацию по API для всех многих полезных методов, определенных в &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; стандартной библиотекой. Например, помимо &lt;code&gt;push&lt;/code&gt; , метод &lt;code&gt;pop&lt;/code&gt; удаляет и возвращает последний элемент. Перейдем к следующему типу коллекции: &lt;code&gt;String&lt;/code&gt; !</target>
        </trans-unit>
        <trans-unit id="2ec4c24a317d3f7bc3c352fa146805708f0bd185" translate="yes" xml:space="preserve">
          <source>Now that we&amp;rsquo;ve discussed the details of calling &lt;code&gt;panic!&lt;/code&gt; or returning &lt;code&gt;Result&lt;/code&gt;, let&amp;rsquo;s return to the topic of how to decide which is appropriate to use in which cases.</source>
          <target state="translated">Теперь, когда мы обсудили детали вызова &lt;code&gt;panic!&lt;/code&gt; или возвращая &lt;code&gt;Result&lt;/code&gt; , давайте вернемся к теме о том, как решить, что подходит для использования в каких случаях.</target>
        </trans-unit>
        <trans-unit id="dcf9675ca650b7816e93bbac61987240fde0e1c1" translate="yes" xml:space="preserve">
          <source>Now that we&amp;rsquo;ve examined &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; and some of the characteristics of smart pointers, let&amp;rsquo;s look at a few other smart pointers defined in the standard library.</source>
          <target state="translated">Теперь, когда мы изучили &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; и некоторые характеристики интеллектуальных указателей, давайте посмотрим на несколько других интеллектуальных указателей, определенных в стандартной библиотеке.</target>
        </trans-unit>
        <trans-unit id="1275cf5c5193957df5e8d9870d52448402e96389" translate="yes" xml:space="preserve">
          <source>Now that we&amp;rsquo;ve explored how variables work, let&amp;rsquo;s look at more data types they can have.</source>
          <target state="translated">Теперь, когда мы изучили, как работают переменные, давайте рассмотрим другие типы данных, которые они могут иметь.</target>
        </trans-unit>
        <trans-unit id="b53e79d7c3785836a15f4ecfc6aac9abee118b76" translate="yes" xml:space="preserve">
          <source>Now that we&amp;rsquo;ve extracted the logic into &lt;em&gt;src/lib.rs&lt;/em&gt; and left the argument collecting and error handling in &lt;em&gt;src/main.rs&lt;/em&gt;, it&amp;rsquo;s much easier to write tests for the core functionality of our code. We can call functions directly with various arguments and check return values without having to call our binary from the command line. Feel free to write some tests for the functionality in the &lt;code&gt;Config::new&lt;/code&gt; and &lt;code&gt;run&lt;/code&gt; functions on your own.</source>
          <target state="translated">Теперь, когда мы извлекли логику в &lt;em&gt;src / lib.rs&lt;/em&gt; и оставили сбор аргументов и обработку ошибок в &lt;em&gt;src / main.rs&lt;/em&gt; , стало намного проще писать тесты для основных функций нашего кода. Мы можем вызывать функции напрямую с различными аргументами и проверять возвращаемые значения без необходимости вызывать наш двоичный файл из командной строки. Не стесняйтесь писать несколько тестов для функциональности в &lt;code&gt;Config::new&lt;/code&gt; и &lt;code&gt;run&lt;/code&gt; функции самостоятельно.</target>
        </trans-unit>
        <trans-unit id="2a08eff4bb167e5da1e95f954b1304af56f21965" translate="yes" xml:space="preserve">
          <source>Now that we&amp;rsquo;ve finished refactoring the configuration parsing, let&amp;rsquo;s turn to the program&amp;rsquo;s logic. As we stated in &lt;a href=&quot;#separation-of-concerns-for-binary-projects&quot;&gt;&amp;ldquo;Separation of Concerns for Binary Projects&amp;rdquo;&lt;/a&gt;, we&amp;rsquo;ll extract a function named &lt;code&gt;run&lt;/code&gt; that will hold all the logic currently in the &lt;code&gt;main&lt;/code&gt; function that isn&amp;rsquo;t involved with setting up configuration or handling errors. When we&amp;rsquo;re done, &lt;code&gt;main&lt;/code&gt; will be concise and easy to verify by inspection, and we&amp;rsquo;ll be able to write tests for all the other logic.</source>
          <target state="translated">Теперь, когда мы закончили рефакторинг парсинга конфигурации, перейдем к логике программы. Как мы заявляли в &lt;a href=&quot;#separation-of-concerns-for-binary-projects&quot;&gt;разделе &amp;laquo;Разделение проблем для двоичных проектов&amp;raquo;&lt;/a&gt; , мы извлечем функцию с именем &lt;code&gt;run&lt;/code&gt; , которая будет содержать всю логику, которая в настоящее время находится в &lt;code&gt;main&lt;/code&gt; функции, которая не связана с настройкой конфигурации или обработкой ошибок. Когда мы закончим, &lt;code&gt;main&lt;/code&gt; будет кратким и легко проверяемым, и мы сможем писать тесты для всей остальной логики.</target>
        </trans-unit>
        <trans-unit id="67636ff52e1a7401207e61d89497c3656085f595" translate="yes" xml:space="preserve">
          <source>Now that we&amp;rsquo;ve improved the expressiveness of our I/O project, let&amp;rsquo;s look at some more features of &lt;code&gt;cargo&lt;/code&gt; that will help us share the project with the world.</source>
          <target state="translated">Теперь, когда мы улучшили выразительность нашего проекта ввода-вывода, давайте рассмотрим еще несколько функций &lt;code&gt;cargo&lt;/code&gt; , которые помогут нам поделиться проектом со всем миром.</target>
        </trans-unit>
        <trans-unit id="f8c732cbf77e2073635c5b38e31310fafb9b6c1e" translate="yes" xml:space="preserve">
          <source>Now that we&amp;rsquo;ve introduced iterators, we can demonstrate a common use of closures that capture their environment by using the &lt;code&gt;filter&lt;/code&gt; iterator adaptor. The &lt;code&gt;filter&lt;/code&gt; method on an iterator takes a closure that takes each item from the iterator and returns a Boolean. If the closure returns &lt;code&gt;true&lt;/code&gt;, the value will be included in the iterator produced by &lt;code&gt;filter&lt;/code&gt;. If the closure returns &lt;code&gt;false&lt;/code&gt;, the value won&amp;rsquo;t be included in the resulting iterator.</source>
          <target state="translated">Теперь, когда мы ввели итераторы, мы можем продемонстрировать обычное использование замыканий, которые захватывают их среду, с помощью адаптера &lt;code&gt;filter&lt;/code&gt; итератора. Метод &lt;code&gt;filter&lt;/code&gt; на итераторе принимает замыкание, которое берет каждый элемент из итератора и возвращает логическое значение. Если замыкание возвращает &lt;code&gt;true&lt;/code&gt; , значение будет включено в итератор, созданный &lt;code&gt;filter&lt;/code&gt; . Если замыкание возвращает &lt;code&gt;false&lt;/code&gt; , значение не будет включено в итоговый итератор.</target>
        </trans-unit>
        <trans-unit id="0f5c8cc4166bf098c054b91aa56eafdd80a280aa" translate="yes" xml:space="preserve">
          <source>Now that we&amp;rsquo;ve looked at how channels work, let&amp;rsquo;s look at a different method of concurrency.</source>
          <target state="translated">Теперь, когда мы рассмотрели, как работают каналы, давайте рассмотрим другой метод параллелизма.</target>
        </trans-unit>
        <trans-unit id="67653a6049372ba09d60cbd375a44f6c3cccaf9a" translate="yes" xml:space="preserve">
          <source>Now that we've got an idea of what unwind safety is in Rust, it's also important to understand what this trait represents. As mentioned above, one way to witness broken invariants is through the &lt;code&gt;catch_unwind&lt;/code&gt; function in this module as it allows catching a panic and then re-using the environment of the closure.</source>
          <target state="translated">Теперь, когда мы получили представление о том, что такое размоточная безопасность в Rust, также важно понять, что представляет собой эта черта. Как упоминалось выше, один из способов увидеть нарушенные инварианты - &lt;code&gt;catch_unwind&lt;/code&gt; функцию catch_unwind в этом модуле, поскольку она позволяет поймать панику и затем повторно использовать среду закрытия.</target>
        </trans-unit>
        <trans-unit id="d02969884890c4347910c461b721cc439357c5a4" translate="yes" xml:space="preserve">
          <source>Now that you have an account, let&amp;rsquo;s say you have a crate you want to publish. Before publishing, you&amp;rsquo;ll need to add some metadata to your crate by adding it to the &lt;code&gt;[package]&lt;/code&gt; section of the crate&amp;rsquo;s &lt;em&gt;Cargo.toml&lt;/em&gt; file.</source>
          <target state="translated">Теперь, когда у вас есть учетная запись, допустим, у вас есть ящик, который вы хотите опубликовать. Перед публикацией вам необходимо добавить некоторые метаданные в ваш ящик, добавив их в раздел &lt;code&gt;[package]&lt;/code&gt; файла &lt;em&gt;Cargo.toml&lt;/em&gt; ящика .</target>
        </trans-unit>
        <trans-unit id="09f54035802dcb8ec1dd44caa3ea32209f58c20d" translate="yes" xml:space="preserve">
          <source>Now that you know how to create, update, and destroy vectors, knowing how to read their contents is a good next step. There are two ways to reference a value stored in a vector. In the examples, we&amp;rsquo;ve annotated the types of the values that are returned from these functions for extra clarity.</source>
          <target state="translated">Теперь, когда вы знаете, как создавать, обновлять и уничтожать векторы, умение читать их содержимое - хороший следующий шаг. Есть два способа ссылаться на значение, хранящееся в векторе. В примерах мы аннотировали типы значений, возвращаемых этими функциями, для большей ясности.</target>
        </trans-unit>
        <trans-unit id="81f4f18161b98344a0f7e41a60ca860036728be7" translate="yes" xml:space="preserve">
          <source>Now that you know how to define and implement traits, we can explore how to use traits to define functions that accept many different types.</source>
          <target state="translated">Теперь,когда вы знаете,как определять и реализовывать трейты,мы можем изучить,как использовать трейты для определения функций,которые принимают множество различных типов.</target>
        </trans-unit>
        <trans-unit id="abb4d086b7b2c677929b00ae06d7123ecd180a15" translate="yes" xml:space="preserve">
          <source>Now that you know how to specify the behavior you want to use using the generic type parameter&amp;rsquo;s bounds, let&amp;rsquo;s return to Listing 10-5 to fix the definition of the &lt;code&gt;largest&lt;/code&gt; function that uses a generic type parameter! Last time we tried to run that code, we received this error:</source>
          <target state="translated">Теперь, когда вы знаете, как указать поведение, которое хотите использовать, используя границы параметра универсального типа, давайте вернемся к листингу 10-5, чтобы исправить определение самой &lt;code&gt;largest&lt;/code&gt; функции, использующей параметр универсального типа! В прошлый раз, когда мы пытались запустить этот код, мы получили эту ошибку:</target>
        </trans-unit>
        <trans-unit id="e396981103292f81034753c73fe592831d9392a8" translate="yes" xml:space="preserve">
          <source>Now that you know several ways to write tests, let&amp;rsquo;s look at what is happening when we run our tests and explore the different options we can use with &lt;code&gt;cargo test&lt;/code&gt;.</source>
          <target state="translated">Теперь, когда вы знаете несколько способов написания тестов, давайте посмотрим, что происходит, когда мы запускаем наши тесты, и исследуем различные варианты, которые мы можем использовать с &lt;code&gt;cargo test&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e62f4573546a99a0fd5e85dde630775910ab5fc8" translate="yes" xml:space="preserve">
          <source>Now that you know where the lifetimes of references are and how Rust analyzes lifetimes to ensure references will always be valid, let&amp;rsquo;s explore generic lifetimes of parameters and return values in the context of functions.</source>
          <target state="translated">Теперь, когда вы знаете, где находится время жизни ссылок и как Rust анализирует время жизни, чтобы гарантировать, что ссылки всегда будут действительными, давайте рассмотрим общие времена жизни параметров и возвращаемых значений в контексте функций.</target>
        </trans-unit>
        <trans-unit id="30a6477678dd7180d7e0d481486280f7e98fefae" translate="yes" xml:space="preserve">
          <source>Now that you know where to use patterns and the difference between refutable and irrefutable patterns, let&amp;rsquo;s cover all the syntax we can use to create patterns.</source>
          <target state="translated">Теперь, когда вы знаете, где использовать шаблоны и разницу между опровержимыми и неопровержимыми шаблонами, давайте рассмотрим весь синтаксис, который мы можем использовать для создания шаблонов.</target>
        </trans-unit>
        <trans-unit id="31528a068a5d3a841cff61741fee15a1c0b2479f" translate="yes" xml:space="preserve">
          <source>Now that you&amp;rsquo;ve added the &lt;code&gt;rand&lt;/code&gt; crate to &lt;em&gt;Cargo.toml&lt;/em&gt;, let&amp;rsquo;s start using &lt;code&gt;rand&lt;/code&gt;. The next step is to update &lt;em&gt;src/main.rs&lt;/em&gt;, as shown in Listing 2-3.</source>
          <target state="translated">Теперь, когда вы добавили ящик &lt;code&gt;rand&lt;/code&gt; в &lt;em&gt;Cargo.toml&lt;/em&gt; , давайте начнем использовать &lt;code&gt;rand&lt;/code&gt; . Следующим шагом является обновление &lt;em&gt;src / main.rs&lt;/em&gt; , как показано в листинге 2-3.</target>
        </trans-unit>
        <trans-unit id="25f40b5e485b1b15ed8e4d216ebb9b698b979c06" translate="yes" xml:space="preserve">
          <source>Now that you&amp;rsquo;ve created an account, saved your API token, chosen a name for your crate, and specified the required metadata, you&amp;rsquo;re ready to publish! Publishing a crate uploads a specific version to &lt;a href=&quot;https://crates.io/&quot;&gt;crates.io&lt;/a&gt; for others to use.</source>
          <target state="translated">Теперь, когда вы создали учетную запись, сохранили токен API, выбрали имя для своего ящика и указали необходимые метаданные, вы готовы к публикации! Публикация ящика загружает определенную версию на &lt;a href=&quot;https://crates.io/&quot;&gt;crates.io,&lt;/a&gt; чтобы ее могли использовать другие.</target>
        </trans-unit>
        <trans-unit id="920c59c826e17db818f515c07dfec7c798d59ee0" translate="yes" xml:space="preserve">
          <source>Now that you&amp;rsquo;ve installed Rust, let&amp;rsquo;s write your first Rust program. It&amp;rsquo;s traditional when learning a new language to write a little program that prints the text &lt;code&gt;Hello, world!&lt;/code&gt; to the screen, so we&amp;rsquo;ll do the same here!</source>
          <target state="translated">Теперь, когда вы установили Rust, давайте напишем вашу первую программу на Rust. При изучении нового языка принято писать небольшую программу, которая печатает текст &lt;code&gt;Hello, world!&lt;/code&gt; на экран, так что и здесь мы сделаем то же самое!</target>
        </trans-unit>
        <trans-unit id="da83ac95984492a0d09f569c59cd96503f2138e1" translate="yes" xml:space="preserve">
          <source>Now that you&amp;rsquo;ve seen how to use &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt;, let&amp;rsquo;s dig into how it works!</source>
          <target state="translated">Теперь, когда вы &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt; как использовать RefCell &amp;lt;T&amp;gt; , давайте рассмотрим, как это работает!</target>
        </trans-unit>
        <trans-unit id="3226e5056b022a9871764bceba61de34cf95da11" translate="yes" xml:space="preserve">
          <source>Now that you&amp;rsquo;ve seen useful ways that the standard library uses generics with the &lt;code&gt;Option&lt;/code&gt; and &lt;code&gt;Result&lt;/code&gt; enums, we&amp;rsquo;ll talk about how generics work and how you can use them in your code.</source>
          <target state="translated">Теперь, когда вы увидели полезные способы использования универсальных шаблонов в стандартной библиотеке с перечислениями &lt;code&gt;Option&lt;/code&gt; и &lt;code&gt;Result&lt;/code&gt; , мы поговорим о том, как работают универсальные шаблоны и как вы можете использовать их в своем коде.</target>
        </trans-unit>
        <trans-unit id="c62551adf3df866d6c2e2a8e1a359461a03ffa45" translate="yes" xml:space="preserve">
          <source>Now that you&amp;rsquo;ve seen what the test results look like in different scenarios, let&amp;rsquo;s look at some macros other than &lt;code&gt;panic!&lt;/code&gt; that are useful in tests.</source>
          <target state="translated">Теперь, когда вы увидели, как выглядят результаты теста в различных сценариях, давайте рассмотрим некоторые макросы, кроме &lt;code&gt;panic!&lt;/code&gt; которые полезны в тестах.</target>
        </trans-unit>
        <trans-unit id="b7ef50d26b9af16e9b7dc94b8c74f1d0f89a5d4f" translate="yes" xml:space="preserve">
          <source>Now the &lt;code&gt;if&lt;/code&gt; and &lt;code&gt;else&lt;/code&gt; blocks only return the appropriate values for the status line and filename in a tuple; we then use destructuring to assign these two values to &lt;code&gt;status_line&lt;/code&gt; and &lt;code&gt;filename&lt;/code&gt; using a pattern in the &lt;code&gt;let&lt;/code&gt; statement, as discussed in Chapter 18.</source>
          <target state="translated">Теперь блоки &lt;code&gt;if&lt;/code&gt; и &lt;code&gt;else&lt;/code&gt; возвращают только соответствующие значения для строки состояния и имени файла в кортеже; Затем мы используем деструктурирование, чтобы присвоить эти два значения &lt;code&gt;status_line&lt;/code&gt; и &lt;code&gt;filename&lt;/code&gt; , используя шаблон в операторе &lt;code&gt;let&lt;/code&gt; , как описано в главе 18.</target>
        </trans-unit>
        <trans-unit id="4c7125187714db67fed394d49d485e2e00abd4cb" translate="yes" xml:space="preserve">
          <source>Now the &lt;code&gt;search&lt;/code&gt; function should return only the lines that contain &lt;code&gt;query&lt;/code&gt;, and our test should pass. Let&amp;rsquo;s run the test:</source>
          <target state="translated">Теперь функция &lt;code&gt;search&lt;/code&gt; должна возвращать только строки, содержащие &lt;code&gt;query&lt;/code&gt; , и наш тест должен пройти. Запустим тест:</target>
        </trans-unit>
        <trans-unit id="522023e5be1135a608b1cd7f8c8337b4cfc43235" translate="yes" xml:space="preserve">
          <source>Now the code will compile! Let&amp;rsquo;s look at the absolute and the relative path and double-check why adding the &lt;code&gt;pub&lt;/code&gt; keyword lets us use these paths in &lt;code&gt;add_to_waitlist&lt;/code&gt; with respect to the privacy rules.</source>
          <target state="translated">Теперь код скомпилируется! Давайте посмотрим на абсолютный и относительный пути и дважды проверим, почему добавление ключевого слова &lt;code&gt;pub&lt;/code&gt; позволяет нам использовать эти пути в &lt;code&gt;add_to_waitlist&lt;/code&gt; с учетом правил конфиденциальности.</target>
        </trans-unit>
        <trans-unit id="9b0d5ba9ad57069914ace4b7ba7c228161663abb" translate="yes" xml:space="preserve">
          <source>Now the entire program should work! Let&amp;rsquo;s try it out, first with a word that should return exactly one line from the Emily Dickinson poem, &amp;ldquo;frog&amp;rdquo;:</source>
          <target state="translated">Теперь вся программа должна работать! Давайте попробуем, сначала со словом, которое должно возвращать ровно одну строку из стихотворения Эмили Дикинсон &amp;laquo;лягушка&amp;raquo;:</target>
        </trans-unit>
        <trans-unit id="acdcf552dc404df4d014e75904c60498b68c4c55" translate="yes" xml:space="preserve">
          <source>Now the error occurs because we don&amp;rsquo;t have an &lt;code&gt;execute&lt;/code&gt; method on &lt;code&gt;ThreadPool&lt;/code&gt;. Recall from the &lt;a href=&quot;#creating-a-similar-interface-for-a-finite-number-of-threads&quot;&gt;&amp;ldquo;Creating a Similar Interface for a Finite Number of Threads&amp;rdquo;&lt;/a&gt; section that we decided our thread pool should have an interface similar to &lt;code&gt;thread::spawn&lt;/code&gt;. In addition, we&amp;rsquo;ll implement the &lt;code&gt;execute&lt;/code&gt; function so it takes the closure it&amp;rsquo;s given and gives it to an idle thread in the pool to run.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="14d34886bdb2d79a108c1eb310a74fea56db9de1" translate="yes" xml:space="preserve">
          <source>Now the expensive calculation is called in only one place, and we&amp;rsquo;re only executing that code where we need the results.</source>
          <target state="translated">Теперь дорогостоящие вычисления вызываются только в одном месте, и мы выполняем этот код только там, где нам нужны результаты.</target>
        </trans-unit>
        <trans-unit id="e22993365c1cb308452dac73cf5565235b2c67e8" translate="yes" xml:space="preserve">
          <source>Now the program is getting interesting! There&amp;rsquo;s a lot going on in this little line. Notice that this is a &lt;code&gt;let&lt;/code&gt; statement, which is used to create a &lt;em&gt;variable&lt;/em&gt;. Here&amp;rsquo;s another example:</source>
          <target state="translated">Теперь программа становится интереснее! В этой маленькой строке много чего происходит. Обратите внимание, что это оператор &lt;code&gt;let&lt;/code&gt; , который используется для создания &lt;em&gt;переменной&lt;/em&gt; . Вот еще один пример:</target>
        </trans-unit>
        <trans-unit id="9b5e26741b88a54ad8284d61f9e2e51ca7f82268" translate="yes" xml:space="preserve">
          <source>Now the signature indicates that the function data borrowed from either &lt;code&gt;x&lt;/code&gt; or &lt;code&gt;y&lt;/code&gt;. Alternatively, you could change the body to not return data from &lt;code&gt;y&lt;/code&gt;:</source>
          <target state="translated">Теперь подпись указывает, что данные функции заимствованы из &lt;code&gt;x&lt;/code&gt; или &lt;code&gt;y&lt;/code&gt; . В качестве альтернативы вы можете изменить тело, чтобы не возвращать данные из &lt;code&gt;y&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="c1198ca2a8c86240e1af84c3d28743f89fded1ad" translate="yes" xml:space="preserve">
          <source>Now we can start seeing the advantages of the state pattern: the &lt;code&gt;request_review&lt;/code&gt; method on &lt;code&gt;Post&lt;/code&gt; is the same no matter its &lt;code&gt;state&lt;/code&gt; value. Each state is responsible for its own rules.</source>
          <target state="translated">Теперь мы можем начать видеть преимущества шаблона состояний: метод &lt;code&gt;request_review&lt;/code&gt; в &lt;code&gt;Post&lt;/code&gt; одинаков, независимо от его значения &lt;code&gt;state&lt;/code&gt; . Каждое государство отвечает за свои правила.</target>
        </trans-unit>
        <trans-unit id="0ea1cd6e6626b68365f6c8947fa55d16ff141954" translate="yes" xml:space="preserve">
          <source>Now we get a warning and an error. Ignoring the warning for a moment, the error occurs because we don&amp;rsquo;t have an &lt;code&gt;execute&lt;/code&gt; method on &lt;code&gt;ThreadPool&lt;/code&gt;. Recall from the &lt;a href=&quot;#creating-a-similar-interface-for-a-finite-number-of-threads&quot;&gt;&amp;ldquo;Creating a Similar Interface for a Finite Number of Threads&amp;rdquo;&lt;/a&gt; section that we decided our thread pool should have an interface similar to &lt;code&gt;thread::spawn&lt;/code&gt;. In addition, we&amp;rsquo;ll implement the &lt;code&gt;execute&lt;/code&gt; function so it takes the closure it&amp;rsquo;s given and gives it to an idle thread in the pool to run.</source>
          <target state="translated">Теперь получаем предупреждение и ошибку. Если на мгновение игнорировать предупреждение, ошибка возникает из-за того, что у нас нет метода &lt;code&gt;execute&lt;/code&gt; в &lt;code&gt;ThreadPool&lt;/code&gt; . Вспомните из раздела &lt;a href=&quot;#creating-a-similar-interface-for-a-finite-number-of-threads&quot;&gt;&amp;laquo;Создание&lt;/a&gt; подобного интерфейса для конечного числа потоков&amp;raquo;, что мы решили, что наш пул потоков должен иметь интерфейс, аналогичный &lt;code&gt;thread::spawn&lt;/code&gt; . Кроме того, мы реализуем функцию &lt;code&gt;execute&lt;/code&gt; , чтобы она принимала заданное закрытие и передавала его для запуска незанятому потоку в пуле.</target>
        </trans-unit>
        <trans-unit id="d7705a7f1894fbc9d3a536be0dfea4d6af32a807" translate="yes" xml:space="preserve">
          <source>Now we need to bring the code we moved to &lt;em&gt;src/lib.rs&lt;/em&gt; into the scope of the binary crate in &lt;em&gt;src/main.rs&lt;/em&gt;, as shown in Listing 12-14.</source>
          <target state="translated">Теперь нам нужно перенести код, который мы переместили в &lt;em&gt;src / lib.rs,&lt;/em&gt; в область видимости двоичного &lt;em&gt;контейнера&lt;/em&gt; в &lt;em&gt;src / main.rs&lt;/em&gt; , как показано в листинге 12-14.</target>
        </trans-unit>
        <trans-unit id="b54fd4c3b5f78dc6afcacc14a208e5f25a781f43" translate="yes" xml:space="preserve">
          <source>Now we need to update the &lt;code&gt;content&lt;/code&gt; method on &lt;code&gt;Post&lt;/code&gt;: if the state is &lt;code&gt;Published&lt;/code&gt;, we want to return the value in the post&amp;rsquo;s &lt;code&gt;content&lt;/code&gt; field; otherwise, we want to return an empty string slice, as shown in Listing 17-17:</source>
          <target state="translated">Теперь нам нужно обновить метод &lt;code&gt;content&lt;/code&gt; в &lt;code&gt;Post&lt;/code&gt; : если состояние &lt;code&gt;Published&lt;/code&gt; , мы хотим вернуть значение в поле &lt;code&gt;content&lt;/code&gt; ; в противном случае мы хотим вернуть пустой фрагмент строки, как показано в листинге 17-17:</target>
        </trans-unit>
        <trans-unit id="6174f1c624d6e6d6e079aee3674396394f363d5b" translate="yes" xml:space="preserve">
          <source>Now we see the error onscreen and &lt;em&gt;output.txt&lt;/em&gt; contains nothing, which is the behavior we expect of command line programs.</source>
          <target state="translated">Теперь мы видим ошибку на экране, а &lt;em&gt;файл output.txt&lt;/em&gt; ничего не содержит, чего мы ожидаем от программ командной строки.</target>
        </trans-unit>
        <trans-unit id="cdda59c39165af59e97381c7390ecfef3d12a8f6" translate="yes" xml:space="preserve">
          <source>Now we&amp;rsquo;ll add functionality to read the file that is specified in the &lt;code&gt;filename&lt;/code&gt; command line argument. First, we need a sample file to test it with: the best kind of file to use to make sure &lt;code&gt;minigrep&lt;/code&gt; is working is one with a small amount of text over multiple lines with some repeated words. Listing 12-3 has an Emily Dickinson poem that will work well! Create a file called &lt;em&gt;poem.txt&lt;/em&gt; at the root level of your project, and enter the poem &amp;ldquo;I&amp;rsquo;m Nobody! Who are you?&amp;rdquo;</source>
          <target state="translated">Теперь мы добавим функциональность для чтения файла, указанного в аргументе командной строки &lt;code&gt;filename&lt;/code&gt; . Во-первых, нам нужен образец файла для его тестирования: лучший тип файла для проверки &lt;code&gt;minigrep&lt;/code&gt; - это файл с небольшим количеством текста на нескольких строках с некоторыми повторяющимися словами. В листинге 12-3 есть стихотворение Эмили Дикинсон, которое подойдет! Создайте файл под названием &lt;em&gt;poem.txt&lt;/em&gt; на корневом уровне вашего проекта и введите стихотворение &amp;laquo;Я никто! Кто ты?&quot;</target>
        </trans-unit>
        <trans-unit id="dd1d31103e62a1ec520be0bcddbbbdb89e976849" translate="yes" xml:space="preserve">
          <source>Now we&amp;rsquo;ll add some types that implement the &lt;code&gt;Draw&lt;/code&gt; trait. We&amp;rsquo;ll provide the &lt;code&gt;Button&lt;/code&gt; type. Again, actually implementing a GUI library is beyond the scope of this book, so the &lt;code&gt;draw&lt;/code&gt; method won&amp;rsquo;t have any useful implementation in its body. To imagine what the implementation might look like, a &lt;code&gt;Button&lt;/code&gt; struct might have fields for &lt;code&gt;width&lt;/code&gt;, &lt;code&gt;height&lt;/code&gt;, and &lt;code&gt;label&lt;/code&gt;, as shown in Listing 17-7:</source>
          <target state="translated">Теперь мы добавим несколько типов, реализующих &lt;code&gt;Draw&lt;/code&gt; . Мы предоставим тип &lt;code&gt;Button&lt;/code&gt; . Опять же, реализация библиотеки GUI выходит за рамки этой книги, поэтому метод &lt;code&gt;draw&lt;/code&gt; не будет иметь какой-либо полезной реализации в своем теле. Чтобы представить, как может выглядеть реализация, структура &lt;code&gt;Button&lt;/code&gt; может иметь поля для &lt;code&gt;width&lt;/code&gt; , &lt;code&gt;height&lt;/code&gt; и &lt;code&gt;label&lt;/code&gt; , как показано в листинге 17-7:</target>
        </trans-unit>
        <trans-unit id="e57698dd0ca960cc0b20cbcaaf7560d2276dfedc" translate="yes" xml:space="preserve">
          <source>Now we&amp;rsquo;ll implement sending data in response to a client request. Responses have the following format:</source>
          <target state="translated">Теперь реализуем отправку данных в ответ на запрос клиента. Ответы имеют следующий формат:</target>
        </trans-unit>
        <trans-unit id="faa7223d94f8959f76182c7251992c3581bab825" translate="yes" xml:space="preserve">
          <source>Now we&amp;rsquo;ll implement the &lt;code&gt;Drop&lt;/code&gt; trait to call &lt;code&gt;join&lt;/code&gt; on each of the threads in the pool so they can finish the requests they&amp;rsquo;re working on before closing. Then we&amp;rsquo;ll implement a way to tell the threads they should stop accepting new requests and shut down. To see this code in action, we&amp;rsquo;ll modify our server to accept only two requests before gracefully shutting down its thread pool.</source>
          <target state="translated">Теперь мы реализуем &lt;code&gt;Drop&lt;/code&gt; для вызова &lt;code&gt;join&lt;/code&gt; для каждого из потоков в пуле, чтобы они могли завершить запросы, над которыми они работают, до закрытия. Затем мы реализуем способ сообщить потокам, что они должны прекратить прием новых запросов и завершить работу. Чтобы увидеть этот код в действии, мы изменим наш сервер так, чтобы он принимал только два запроса, прежде чем корректно закрыть его пул потоков.</target>
        </trans-unit>
        <trans-unit id="f36ce7a9b5e2c1e7eedfaeab844cfb65b78a49c0" translate="yes" xml:space="preserve">
          <source>Now we&amp;rsquo;ll tackle the problem that the closures given to &lt;code&gt;thread::spawn&lt;/code&gt; do absolutely nothing. Currently, we get the closure we want to execute in the &lt;code&gt;execute&lt;/code&gt; method. But we need to give &lt;code&gt;thread::spawn&lt;/code&gt; a closure to run when we create each &lt;code&gt;Worker&lt;/code&gt; during the creation of the &lt;code&gt;ThreadPool&lt;/code&gt;.</source>
          <target state="translated">Теперь мы решим проблему, заключающуюся в том, что замыкания, данные для &lt;code&gt;thread::spawn&lt;/code&gt; , абсолютно ничего не делают. В настоящее время мы получаем закрытие, которое хотим выполнить в методе &lt;code&gt;execute&lt;/code&gt; . Но нам нужно дать &lt;code&gt;thread::spawn&lt;/code&gt; закрытие для запуска при создании каждого &lt;code&gt;Worker&lt;/code&gt; во время создания &lt;code&gt;ThreadPool&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0ff72d33ea4877ceb607d0497b7819ecb5fe8345" translate="yes" xml:space="preserve">
          <source>Now we&amp;rsquo;ll work on fixing our error handling. Recall that attempting to access the values in the &lt;code&gt;args&lt;/code&gt; vector at index 1 or index 2 will cause the program to panic if the vector contains fewer than three items. Try running the program without any arguments; it will look like this:</source>
          <target state="translated">Теперь мы будем работать над исправлением нашей обработки ошибок. Напомним, что попытка доступа к значениям в векторе &lt;code&gt;args&lt;/code&gt; по индексу 1 или 2 вызовет панику программы, если вектор содержит менее трех элементов. Попробуйте запустить программу без аргументов; это будет выглядеть так:</target>
        </trans-unit>
        <trans-unit id="13208408fb234a6274c662e0cea2839eb0d4df4f" translate="yes" xml:space="preserve">
          <source>Now we&amp;rsquo;re tracking a starting &lt;em&gt;and&lt;/em&gt; an ending index, and we have even more values that were calculated from data in a particular state but aren&amp;rsquo;t tied to that state at all. We now have three unrelated variables floating around that need to be kept in sync.</source>
          <target state="translated">Теперь мы отслеживаем начальный &lt;em&gt;и&lt;/em&gt; конечный индексы, и у нас есть еще больше значений, которые были рассчитаны на основе данных в определенном состоянии, но совершенно не привязаны к этому состоянию. Теперь у нас есть три несвязанные переменные, которые необходимо синхронизировать.</target>
        </trans-unit>
        <trans-unit id="e2c6d85ff7e11c55ebfacf4a5ea15b76883f9037" translate="yes" xml:space="preserve">
          <source>Now when we call &lt;code&gt;first_word&lt;/code&gt;, we get back a single value that is tied to the underlying data. The value is made up of a reference to the starting point of the slice and the number of elements in the slice.</source>
          <target state="translated">Теперь, когда мы вызываем &lt;code&gt;first_word&lt;/code&gt; , мы получаем одно значение, привязанное к базовым данным. Значение состоит из ссылки на начальную точку среза и количества элементов в срезе.</target>
        </trans-unit>
        <trans-unit id="ae56f18fed45d04e5e1b1341584607fec330d0c6" translate="yes" xml:space="preserve">
          <source>Now when we run the program, we won&amp;rsquo;t get any errors, and we&amp;rsquo;ll see the following output:</source>
          <target state="translated">Теперь, когда мы запустим программу, мы не получим никаких ошибок и увидим следующий результат:</target>
        </trans-unit>
        <trans-unit id="a1e40e49d7c93a75ee26e23465f603f6bbef3e57" translate="yes" xml:space="preserve">
          <source>Now when we run the test, we&amp;rsquo;ll get a more informative error message:</source>
          <target state="translated">Теперь, когда мы запустим тест, мы получим более информативное сообщение об ошибке:</target>
        </trans-unit>
        <trans-unit id="77f2a1a56e2b0bc8d28e09777d58b6d63d25bdc8" translate="yes" xml:space="preserve">
          <source>Now you know how the newtype pattern is used in relation to traits; it&amp;rsquo;s also a useful pattern even when traits are not involved. Let&amp;rsquo;s switch focus and look at some advanced ways to interact with Rust&amp;rsquo;s type system.</source>
          <target state="translated">Теперь вы знаете, как паттерн newtype используется по отношению к признакам; это также полезный паттерн, даже если черты не задействованы. Давайте сменим фокус и рассмотрим некоторые продвинутые способы взаимодействия с системой типов Rust.</target>
        </trans-unit>
        <trans-unit id="698e184c44b77b78a4f0259358fd0568a9ef42f1" translate="yes" xml:space="preserve">
          <source>Now, &lt;code&gt;foo()&lt;/code&gt; can no longer be called on a trait object, but you will now be allowed to make a trait object, and that will be able to call any object-safe methods. With such a bound, one can still call &lt;code&gt;foo()&lt;/code&gt; on types implementing that trait that aren't behind trait objects.</source>
          <target state="translated">Теперь &lt;code&gt;foo()&lt;/code&gt; больше не может вызываться для объекта-признака, но теперь вам будет разрешено создавать объект-признак, и он сможет вызывать любые объектно-безопасные методы. С такой привязкой можно по-прежнему вызывать &lt;code&gt;foo()&lt;/code&gt; для типов, реализующих эту черту, которые не находятся за объектами черт.</target>
        </trans-unit>
        <trans-unit id="e2eab767e7fabf7d41783d8a69e9cbea73a62c87" translate="yes" xml:space="preserve">
          <source>Now, every time you call &lt;code&gt;rustc&lt;/code&gt; or &lt;code&gt;cargo&lt;/code&gt; inside of &lt;em&gt;~/projects/needs-nightly&lt;/em&gt;, &lt;code&gt;rustup&lt;/code&gt; will make sure that you are using nightly Rust, rather than your default of stable Rust. This comes in handy when you have a lot of Rust projects!</source>
          <target state="translated">Теперь, каждый раз, когда вы вызываете &lt;code&gt;rustc&lt;/code&gt; или &lt;code&gt;cargo&lt;/code&gt; внутри &lt;em&gt;~ / projects / needs- &lt;/em&gt; &lt;code&gt;rustup&lt;/code&gt; , rustup будет следить за тем, чтобы вы использовали ночной Rust, а не стабильный Rust по умолчанию. Это пригодится, когда у вас много проектов на Rust!</target>
        </trans-unit>
        <trans-unit id="e79236607753f413c66ac854a24fa640c09a981f" translate="yes" xml:space="preserve">
          <source>Now, if we have the following code:</source>
          <target state="translated">Теперь,если у нас есть следующий код:</target>
        </trans-unit>
        <trans-unit id="8bfc390ee5863dbfd9bc2b1fac71150d32bafb63" translate="yes" xml:space="preserve">
          <source>Now, let&amp;rsquo;s try to share a value between multiple threads using &lt;code&gt;Mutex&amp;lt;T&amp;gt;&lt;/code&gt;. We&amp;rsquo;ll spin up 10 threads and have them each increment a counter value by 1, so the counter goes from 0 to 10. Note that the next few examples will have compiler errors, and we&amp;rsquo;ll use those errors to learn more about using &lt;code&gt;Mutex&amp;lt;T&amp;gt;&lt;/code&gt; and how Rust helps us use it correctly. Listing 16-13 has our starting example:</source>
          <target state="translated">Теперь давайте попробуем разделить значение между несколькими потоками с помощью &lt;code&gt;Mutex&amp;lt;T&amp;gt;&lt;/code&gt; . Мы развернем 10 потоков, и каждый из них будет увеличивать значение счетчика на 1, поэтому счетчик переходит от 0 до 10. Обратите внимание, что в следующих нескольких примерах будут ошибки компилятора, и мы будем использовать эти ошибки, чтобы узнать больше об использовании &lt;code&gt;Mutex&amp;lt;T&amp;gt;&lt;/code&gt; и как Rust помогает нам правильно его использовать. В листинге 16-13 приведен наш начальный пример:</target>
        </trans-unit>
        <trans-unit id="12a0ede889bbdab76f8ecdca9c8b3f108a1224a8" translate="yes" xml:space="preserve">
          <source>Now, let&amp;rsquo;s try to share a value between multiple threads using &lt;code&gt;Mutex&amp;lt;T&amp;gt;&lt;/code&gt;. We&amp;rsquo;ll spin up 10 threads and have them each increment a counter value by 1, so the counter goes from 0 to 10. The next example in Listing 16-13 will have a compiler error, and we&amp;rsquo;ll use that error to learn more about using &lt;code&gt;Mutex&amp;lt;T&amp;gt;&lt;/code&gt; and how Rust helps us use it correctly.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4684dc088b34ae2083e2057208489a24262c5c09" translate="yes" xml:space="preserve">
          <source>Now, run this program using &lt;code&gt;cargo run&lt;/code&gt;:</source>
          <target state="translated">Теперь запустите эту программу, используя &lt;code&gt;cargo run&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="5f63a9b785af57bd0365b9cf3f0ad0d87a3314b8" translate="yes" xml:space="preserve">
          <source>Now, the alias &lt;code&gt;Kilometers&lt;/code&gt; is a &lt;em&gt;synonym&lt;/em&gt; for &lt;code&gt;i32&lt;/code&gt;; unlike the &lt;code&gt;Millimeters&lt;/code&gt; and &lt;code&gt;Meters&lt;/code&gt; types we created in Listing 19-15, &lt;code&gt;Kilometers&lt;/code&gt; is not a separate, new type. Values that have the type &lt;code&gt;Kilometers&lt;/code&gt; will be treated the same as values of type &lt;code&gt;i32&lt;/code&gt;:</source>
          <target state="translated">Теперь, псевдоним &lt;code&gt;Kilometers&lt;/code&gt; является &lt;em&gt;синонимом&lt;/em&gt; для &lt;code&gt;i32&lt;/code&gt; ; В отличие от типов &lt;code&gt;Millimeters&lt;/code&gt; и &lt;code&gt;Meters&lt;/code&gt; , которые мы создали в Листинге 19-15, &lt;code&gt;Kilometers&lt;/code&gt; не является отдельным новым типом. Значения типа &amp;laquo; &lt;code&gt;Kilometers&lt;/code&gt; будут обрабатываться так же, как значения типа &lt;code&gt;i32&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="89254150c2be7dc87d0a9f78d979708d51af3c47" translate="yes" xml:space="preserve">
          <source>Now, we can go further. Here are some erroneous code examples:</source>
          <target state="translated">Теперь мы можем пойти дальше.Вот несколько ошибочных примеров кода:</target>
        </trans-unit>
        <trans-unit id="0a10d92135d2873e2b02f8fce9c6f1692a0cbb60" translate="yes" xml:space="preserve">
          <source>Now, we can use &lt;code&gt;?&lt;/code&gt; instead of &lt;code&gt;match&lt;/code&gt;, and the return type makes a lot more sense: if the loop ever stops, it means that an error occurred. We don't even have to wrap the loop in an &lt;code&gt;Ok&lt;/code&gt; because &lt;code&gt;!&lt;/code&gt; coerces to &lt;code&gt;Result&amp;lt;!, ConnectionError&amp;gt;&lt;/code&gt; automatically.</source>
          <target state="translated">Теперь мы можем использовать &lt;code&gt;?&lt;/code&gt; вместо &lt;code&gt;match&lt;/code&gt; , и тип возвращаемого значения имеет гораздо больше смысла: если цикл когда-либо останавливается, это означает, что произошла ошибка. Нам даже не нужно заключать цикл в &lt;code&gt;Ok&lt;/code&gt; потому что &lt;code&gt;!&lt;/code&gt; автоматически приводит к &lt;code&gt;Result&amp;lt;!, ConnectionError&amp;gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="00574ee534bf3b794cc8e985f367f79be7646f65" translate="yes" xml:space="preserve">
          <source>Now, when the server disconnects, we exit the loop with an error instead of panicking. While it might be intuitive to simply return the error, we might want to wrap it in a &lt;a href=&quot;result/enum.result&quot;&gt;&lt;code&gt;Result&amp;lt;!, E&amp;gt;&lt;/code&gt;&lt;/a&gt; instead:</source>
          <target state="translated">Теперь, когда сервер отключается, мы выходим из цикла с ошибкой вместо паники. Хотя может показаться интуитивно понятным просто вернуть ошибку, мы могли бы вместо этого заключить ее в &lt;a href=&quot;result/enum.result&quot;&gt; &lt;code&gt;Result&amp;lt;!, E&amp;gt;&lt;/code&gt; &lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="63f5d491af12e32408bf602e1dfb4af7a20ca44f" translate="yes" xml:space="preserve">
          <source>Now, without changing any of the code, let&amp;rsquo;s build the project, as shown in Listing 2-2.</source>
          <target state="translated">Теперь, не меняя код, создадим проект, как показано в листинге 2-2.</target>
        </trans-unit>
        <trans-unit id="335506e2ff8a4e3e39e5a5e2b3fc6bf1463c0bb5" translate="yes" xml:space="preserve">
          <source>Now, you get all of the default values. Rust implements &lt;code&gt;Default&lt;/code&gt; for various primitives types.</source>
          <target state="translated">Теперь вы получите все значения по умолчанию. Rust реализует &lt;code&gt;Default&lt;/code&gt; для различных типов примитивов.</target>
        </trans-unit>
        <trans-unit id="019a7808328d4c7ef510130b49858e7cc7a93df4" translate="yes" xml:space="preserve">
          <source>NulError</source>
          <target state="translated">NulError</target>
        </trans-unit>
        <trans-unit id="0cb22fef16057827ecc4973a05f1f48159ecfb08" translate="yes" xml:space="preserve">
          <source>NulError::borrow</source>
          <target state="translated">NulError::borrow</target>
        </trans-unit>
        <trans-unit id="093c6ad11b2674276a386aef18e019c41e18c73d" translate="yes" xml:space="preserve">
          <source>NulError::borrow_mut</source>
          <target state="translated">NulError::borrow_mut</target>
        </trans-unit>
        <trans-unit id="2212c8b5028758465c03e3f70e4f2b53155ddf4f" translate="yes" xml:space="preserve">
          <source>NulError::cause</source>
          <target state="translated">NulError::cause</target>
        </trans-unit>
        <trans-unit id="29768f5bfd32a963dcb296b9cb20f40a82c74df5" translate="yes" xml:space="preserve">
          <source>NulError::clone</source>
          <target state="translated">NulError::clone</target>
        </trans-unit>
        <trans-unit id="11102afce6dc8292dc39655665283f8191fb13f1" translate="yes" xml:space="preserve">
          <source>NulError::clone_from</source>
          <target state="translated">NulError::clone_from</target>
        </trans-unit>
        <trans-unit id="f533f8602af54aaa16eff696d1575d42e14848a1" translate="yes" xml:space="preserve">
          <source>NulError::clone_into</source>
          <target state="translated">NulError::clone_into</target>
        </trans-unit>
        <trans-unit id="dbdb7cc3a8e4e6691a99909b0fc53de13cd8f2d3" translate="yes" xml:space="preserve">
          <source>NulError::description</source>
          <target state="translated">NulError::description</target>
        </trans-unit>
        <trans-unit id="90a567cb98b0dcdd50aff9ea97e9fff9eaab566d" translate="yes" xml:space="preserve">
          <source>NulError::eq</source>
          <target state="translated">NulError::eq</target>
        </trans-unit>
        <trans-unit id="5a4bafcb93f1795790aaa47109d1e73bf1dc48ee" translate="yes" xml:space="preserve">
          <source>NulError::fmt</source>
          <target state="translated">NulError::fmt</target>
        </trans-unit>
        <trans-unit id="fea70f345cef208acafc3c691d14a34ddbaffb2c" translate="yes" xml:space="preserve">
          <source>NulError::from</source>
          <target state="translated">NulError::from</target>
        </trans-unit>
        <trans-unit id="c667a60cc8a552cdd2774d6820e70ba3a6f7fa11" translate="yes" xml:space="preserve">
          <source>NulError::into</source>
          <target state="translated">NulError::into</target>
        </trans-unit>
        <trans-unit id="30b7683d9cdd43993a6fc1126ff7ee715887f7b2" translate="yes" xml:space="preserve">
          <source>NulError::into_vec</source>
          <target state="translated">NulError::into_vec</target>
        </trans-unit>
        <trans-unit id="0a051a00c0c437269ea80583c284491216e4bda7" translate="yes" xml:space="preserve">
          <source>NulError::ne</source>
          <target state="translated">NulError::ne</target>
        </trans-unit>
        <trans-unit id="2853d8c78438f77254b0a497c86fde1fc17dc043" translate="yes" xml:space="preserve">
          <source>NulError::nul_position</source>
          <target state="translated">NulError::nul_position</target>
        </trans-unit>
        <trans-unit id="266ad98111087a4df9e19e655c096e1306270de2" translate="yes" xml:space="preserve">
          <source>NulError::source</source>
          <target state="translated">NulError::source</target>
        </trans-unit>
        <trans-unit id="5a34a4566a411696ebf16a2b9ec49441272c8c0b" translate="yes" xml:space="preserve">
          <source>NulError::to_owned</source>
          <target state="translated">NulError::to_owned</target>
        </trans-unit>
        <trans-unit id="657290a7e7bc42a0480eee65c34175ba47172560" translate="yes" xml:space="preserve">
          <source>NulError::to_string</source>
          <target state="translated">NulError::to_string</target>
        </trans-unit>
        <trans-unit id="d1202df6e66660732652af8ec880ff1ae89ff7c3" translate="yes" xml:space="preserve">
          <source>NulError::try_from</source>
          <target state="translated">NulError::try_from</target>
        </trans-unit>
        <trans-unit id="1d16960d944bfade9db6cf467b0e67afd7e5faaf" translate="yes" xml:space="preserve">
          <source>NulError::try_into</source>
          <target state="translated">NulError::try_into</target>
        </trans-unit>
        <trans-unit id="1f3e1c8599374779dd8128ca0f06731901b2e4e4" translate="yes" xml:space="preserve">
          <source>NulError::type_id</source>
          <target state="translated">NulError::type_id</target>
        </trans-unit>
        <trans-unit id="109085beaaa80ac89858b283a64f7c75d7e5bb12" translate="yes" xml:space="preserve">
          <source>Null</source>
          <target state="translated">Null</target>
        </trans-unit>
        <trans-unit id="a7321f8049c14a666fefc1ca42149346db408d7b" translate="yes" xml:space="preserve">
          <source>Null-unchecked version</source>
          <target state="translated">Нулевая версия</target>
        </trans-unit>
        <trans-unit id="2276df81ba459368e74bc9d4361d3c8cfd09f1df" translate="yes" xml:space="preserve">
          <source>Nullable pointers</source>
          <target state="translated">Накладные указатели</target>
        </trans-unit>
        <trans-unit id="c25cad253b19d0908d73f07b038e8b9aad37e183" translate="yes" xml:space="preserve">
          <source>Number literals</source>
          <target state="translated">Числовые буквы</target>
        </trans-unit>
        <trans-unit id="bcec75d4dad01d7ef8298e79673d17da682b5ff9" translate="yes" xml:space="preserve">
          <source>Number of significant digits in base 2.</source>
          <target state="translated">Количество значащих цифр в базе 2.</target>
        </trans-unit>
        <trans-unit id="2805eca363fc3f5bc17c10d2663c97e212a66b12" translate="yes" xml:space="preserve">
          <source>Number of significant digits in base 2. Use &lt;a href=&quot;../primitive.f32#associatedconstant.MANTISSA_DIGITS&quot;&gt;&lt;code&gt;f32::MANTISSA_DIGITS&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="12801815bc7acefa87d6f150e6c4da3f8cfc4e2c" translate="yes" xml:space="preserve">
          <source>Number of significant digits in base 2. Use &lt;a href=&quot;../primitive.f64#associatedconstant.MANTISSA_DIGITS&quot;&gt;&lt;code&gt;f64::MANTISSA_DIGITS&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7e53821f70ae16079c4a6a64c52a91fae645bc5f" translate="yes" xml:space="preserve">
          <source>Numbers</source>
          <target state="translated">Numbers</target>
        </trans-unit>
        <trans-unit id="21e67f90f74a7a640f48c34557cd9804c3bb16bf" translate="yes" xml:space="preserve">
          <source>Numeric Operations</source>
          <target state="translated">Числовые операции</target>
        </trans-unit>
        <trans-unit id="46e7eddaee58aa04d38eef7cd137db7696751094" translate="yes" xml:space="preserve">
          <source>Numeric cast</source>
          <target state="translated">числовой кастинг</target>
        </trans-unit>
        <trans-unit id="5fc7eba5de8d1ad8c7f788326b72adec568ef6c6" translate="yes" xml:space="preserve">
          <source>Numeric literal of specific type</source>
          <target state="translated">числовой букварь конкретного типа</target>
        </trans-unit>
        <trans-unit id="1569010f07b1014b3cf4df2495e2025b598353cd" translate="yes" xml:space="preserve">
          <source>Numeric type</source>
          <target state="translated">числовой тип</target>
        </trans-unit>
        <trans-unit id="d74de684582cb87f5abe203c6987280191b1e915" translate="yes" xml:space="preserve">
          <source>Numeric types</source>
          <target state="translated">Числовые типы</target>
        </trans-unit>
        <trans-unit id="448f04fec46467e790879ea8707bb67f916a6de0" translate="yes" xml:space="preserve">
          <source>Numeric values used in this type don't have portable meanings, and different platforms may mask different amounts of them.</source>
          <target state="translated">Числовые значения,используемые в этом типе,не имеют переносимых значений,и разные платформы могут маскировать разные их количества.</target>
        </trans-unit>
        <trans-unit id="6c69dc5bbeb314ef78589c0047ce04c8e5006432" translate="yes" xml:space="preserve">
          <source>O(1)</source>
          <target state="translated">O(1)</target>
        </trans-unit>
        <trans-unit id="41a98fdd88fe9c4cdb77aa3ef162d2e340554b26" translate="yes" xml:space="preserve">
          <source>O(1)~</source>
          <target state="translated">O(1)~</target>
        </trans-unit>
        <trans-unit id="aae47a530dc867303fbce9c5d00c60595dd72df2" translate="yes" xml:space="preserve">
          <source>O(1)~*</source>
          <target state="translated">O(1)~*</target>
        </trans-unit>
        <trans-unit id="21c63d891edf29bd0dc5694a68dc0fe5e6523174" translate="yes" xml:space="preserve">
          <source>O(log n)</source>
          <target state="translated">O(log n)</target>
        </trans-unit>
        <trans-unit id="e74f9c141120b2be3e1dcb28f8561ddce1e8fcd1" translate="yes" xml:space="preserve">
          <source>O(log(n))</source>
          <target state="translated">O(log(n))</target>
        </trans-unit>
        <trans-unit id="eed5a0c9d789f93df61247fbcb2bb3a3c20ad0c2" translate="yes" xml:space="preserve">
          <source>O(m)*</source>
          <target state="translated">O(m)*</target>
        </trans-unit>
        <trans-unit id="0a498ed9d22d1c99ae0662d3eb2e582169c852e2" translate="yes" xml:space="preserve">
          <source>O(min(i, n-i))</source>
          <target state="translated">O(min(i,n-i)).</target>
        </trans-unit>
        <trans-unit id="dede0f12fa78bfb74f3fa2188214d44df32644d9" translate="yes" xml:space="preserve">
          <source>O(min(i, n-i))*</source>
          <target state="translated">O(min(i,n-i))*</target>
        </trans-unit>
        <trans-unit id="1eb19fcfc5873ac1d44e4d58ddd8518a66a4491a" translate="yes" xml:space="preserve">
          <source>O(n+m)</source>
          <target state="translated">O(n+m)</target>
        </trans-unit>
        <trans-unit id="c8fadbf37575cb84317acb6f8d4f3d46463f8753" translate="yes" xml:space="preserve">
          <source>O(n-i)</source>
          <target state="translated">O(n-i)</target>
        </trans-unit>
        <trans-unit id="cc8b4f2a60d0d1f3741e6ca4292cce74adf6d07a" translate="yes" xml:space="preserve">
          <source>O(n-i)*</source>
          <target state="translated">O(n-i)*</target>
        </trans-unit>
        <trans-unit id="40df041793dd78f66b71a0840b6daf38640d0a3a" translate="yes" xml:space="preserve">
          <source>OCT_DIGIT : [&lt;code&gt;0&lt;/code&gt;-&lt;code&gt;7&lt;/code&gt;]</source>
          <target state="translated">OCT_DIGIT: [ &lt;code&gt;0&lt;/code&gt; - &lt;code&gt;7&lt;/code&gt; ]</target>
        </trans-unit>
        <trans-unit id="2458dc9d400f320af963a0c090896d1bb8a3eafb" translate="yes" xml:space="preserve">
          <source>OCT_LITERAL :</source>
          <target state="translated">OCT_LITERAL :</target>
        </trans-unit>
        <trans-unit id="7eefb54fc6fa85bcfd8cad8fd3e002943372f832" translate="yes" xml:space="preserve">
          <source>ONCE_INIT</source>
          <target state="translated">ONCE_INIT</target>
        </trans-unit>
        <trans-unit id="de8aa86286dbb8eb74d2748c7b6d4486d0458203" translate="yes" xml:space="preserve">
          <source>OS</source>
          <target state="translated">OS</target>
        </trans-unit>
        <trans-unit id="7367af2af477750e5937879b87fd589c058636c7" translate="yes" xml:space="preserve">
          <source>OS-specific behaviors</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c616ed05e5cb0d4373e277ab3e8348ce34b627e9" translate="yes" xml:space="preserve">
          <source>OS-specific extensions to &lt;a href=&quot;../../../fs/struct.metadata&quot;&gt;&lt;code&gt;fs::Metadata&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Расширения для конкретной ОС для &lt;a href=&quot;../../../fs/struct.metadata&quot;&gt; &lt;code&gt;fs::Metadata&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="d40770bb8444e5820c3f38469b205f65cc11cae4" translate="yes" xml:space="preserve">
          <source>OS-specific functionality.</source>
          <target state="translated">Функциональность,специфичная для операционной системы.</target>
        </trans-unit>
        <trans-unit id="a6c434024b24606a906b9f03f39592fffa3be309" translate="yes" xml:space="preserve">
          <source>OUTER_BLOCK_DOC :</source>
          <target state="translated">OUTER_BLOCK_DOC :</target>
        </trans-unit>
        <trans-unit id="0bb940376a39f5fb9ff8c9b1c3a635c5bc777eb9" translate="yes" xml:space="preserve">
          <source>OUTER_LINE_DOC :</source>
          <target state="translated">OUTER_LINE_DOC :</target>
        </trans-unit>
        <trans-unit id="497044c1c5d284e50b6c69945072ebc9add34281" translate="yes" xml:space="preserve">
          <source>Object Oriented Programming Features of Rust</source>
          <target state="translated">Объектно-ориентированное программирование Особенности ржавчины</target>
        </trans-unit>
        <trans-unit id="1cd60d3a8e30cd469c24d35e86095d88eed38ea9" translate="yes" xml:space="preserve">
          <source>Object Safety</source>
          <target state="translated">Безопасность объектов</target>
        </trans-unit>
        <trans-unit id="907637cc210857e2030448d19632670732a6954a" translate="yes" xml:space="preserve">
          <source>Object Safety Is Required for Trait Objects</source>
          <target state="translated">Безопасность объектов является обязательным требованием для объектов,предназначенных для эксплуатации.</target>
        </trans-unit>
        <trans-unit id="bca6b9d231b55a9e6e8a10f5e5322c009f386439" translate="yes" xml:space="preserve">
          <source>Object safe traits</source>
          <target state="translated">Безопасные черты объекта</target>
        </trans-unit>
        <trans-unit id="c0123c00fdac3367f93d574c1f48635a32708f0d" translate="yes" xml:space="preserve">
          <source>Object safe traits can be the base trait of a &lt;a href=&quot;../types/trait-object&quot;&gt;trait object&lt;/a&gt;. A trait is &lt;em&gt;object safe&lt;/em&gt; if it has the following qualities (defined in &lt;a href=&quot;https://github.com/rust-lang/rfcs/blob/master/text/0255-object-safety.md&quot;&gt;RFC 255&lt;/a&gt;):</source>
          <target state="translated">Безопасные для объекта черты могут быть базовой &lt;a href=&quot;../types/trait-object&quot;&gt;чертой объекта-признака&lt;/a&gt; . Признак является &lt;em&gt;объектно-безопасным,&lt;/em&gt; если он имеет следующие качества (определенные в &lt;a href=&quot;https://github.com/rust-lang/rfcs/blob/master/text/0255-object-safety.md&quot;&gt;RFC 255&lt;/a&gt; ):</target>
        </trans-unit>
        <trans-unit id="23297e036939da16d72f8c944d8900bfb5bf3104" translate="yes" xml:space="preserve">
          <source>Object-oriented programming (OOP) is a way of modeling programs. Objects came from Simula in the 1960s. Those objects influenced Alan Kay&amp;rsquo;s programming architecture in which objects pass messages to each other. He coined the term &lt;em&gt;object-oriented programming&lt;/em&gt; in 1967 to describe this architecture. Many competing definitions describe what OOP is; some definitions would classify Rust as object oriented, but other definitions would not. In this chapter, we&amp;rsquo;ll explore certain characteristics that are commonly considered object oriented and how those characteristics translate to idiomatic Rust. We&amp;rsquo;ll then show you how to implement an object-oriented design pattern in Rust and discuss the trade-offs of doing so versus implementing a solution using some of Rust&amp;rsquo;s strengths instead.</source>
          <target state="translated">Объектно-ориентированное программирование (ООП) - это способ моделирования программ. Объекты пришли из Simula в 1960-х. Эти объекты повлияли на архитектуру программирования Алана Кея, в которой объекты передают сообщения друг другу. Он ввел термин &lt;em&gt;объектно-ориентированное программирование&lt;/em&gt; в 1967 году для описания этой архитектуры. Многие конкурирующие определения описывают, что такое ООП; некоторые определения классифицируют Rust как объектно-ориентированный, а другие нет. В этой главе мы исследуем некоторые характеристики, которые обычно считаются объектно-ориентированными, и то, как эти характеристики переводятся в идиоматический Rust. Затем мы покажем вам, как реализовать объектно-ориентированный шаблон проектирования в Rust, и обсудим компромиссы этого по сравнению с реализацией решения с использованием вместо этого некоторых сильных сторон Rust.</target>
        </trans-unit>
        <trans-unit id="93a2f7998a1b0abd936ff0b0c2f570cbbedd6635" translate="yes" xml:space="preserve">
          <source>Object-oriented programs are made up of objects. An &lt;em&gt;object&lt;/em&gt; packages both data and the procedures that operate on that data. The procedures are typically called &lt;em&gt;methods&lt;/em&gt; or &lt;em&gt;operations&lt;/em&gt;.</source>
          <target state="translated">Объектно-ориентированные программы состоят из объектов. An &lt;em&gt;объект&lt;/em&gt; пакеты как данные , так и процедуры , которые работают на этих данных. Процедуры обычно называются &lt;em&gt;методами&lt;/em&gt; или &lt;em&gt;операциями&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="69fa88294fcaac54902a4347d53a07e91ef5771c" translate="yes" xml:space="preserve">
          <source>Objects Contain Data and Behavior</source>
          <target state="translated">Объекты содержат данные и поведение</target>
        </trans-unit>
        <trans-unit id="d206d3fa18be5581f351f10db48f9bf4a1014628" translate="yes" xml:space="preserve">
          <source>Objects that can be stepped over in both directions.</source>
          <target state="translated">Объекты,которые могут быть перешагнуты в обоих направлениях.</target>
        </trans-unit>
        <trans-unit id="c6ec1c4f32b6ec8b2dd6c5acb228ddee1480f8b1" translate="yes" xml:space="preserve">
          <source>Objects that have a notion of &lt;em&gt;successor&lt;/em&gt; and &lt;em&gt;predecessor&lt;/em&gt; operations.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b899f01274e7bc44fb14d411dd765a15a7787c5f" translate="yes" xml:space="preserve">
          <source>Occasionally it may be desirable not to expose in an API that there is mutation happening &quot;under the hood&quot;. This may be because logically the operation is immutable, but e.g., caching forces the implementation to perform mutation; or because you must employ mutation to implement a trait method that was originally defined to take &lt;code&gt;&amp;amp;self&lt;/code&gt;.</source>
          <target state="translated">Иногда может быть желательно не раскрывать в API, что мутация происходит &amp;laquo;под капотом&amp;raquo;. Это может быть связано с тем, что логически операция неизменна, но, например, кеширование заставляет реализацию выполнять мутацию; или потому, что вы должны использовать мутацию для реализации метода черты, который изначально был определен как take &lt;code&gt;&amp;amp;self&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="473e728a2f59da64c670799897819b1d614ba35f" translate="yes" xml:space="preserve">
          <source>OccupiedEntry</source>
          <target state="translated">OccupiedEntry</target>
        </trans-unit>
        <trans-unit id="9d9953ee64c9a9ed960498f1a51e79c8aae9c8dd" translate="yes" xml:space="preserve">
          <source>Occurrences of &lt;code&gt;.&lt;/code&gt; are normalized away, except if they are at the beginning of the path. For example, &lt;code&gt;a/./b&lt;/code&gt;, &lt;code&gt;a/b/&lt;/code&gt;, &lt;code&gt;a/b/.&lt;/code&gt; and &lt;code&gt;a/b&lt;/code&gt; all have &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; as components, but &lt;code&gt;./a/b&lt;/code&gt; starts with an additional &lt;a href=&quot;enum.component#variant.CurDir&quot;&gt;&lt;code&gt;CurDir&lt;/code&gt;&lt;/a&gt; component.</source>
          <target state="translated">Появления &lt;code&gt;.&lt;/code&gt; нормализованы, кроме случаев, когда они находятся в начале пути. Например, &lt;code&gt;a/./b&lt;/code&gt; , &lt;code&gt;a/b/&lt;/code&gt; , &lt;code&gt;a/b/.&lt;/code&gt; и &lt;code&gt;a/b&lt;/code&gt; имеют &lt;code&gt;a&lt;/code&gt; качестве компонентов a и &lt;code&gt;b&lt;/code&gt; , но &lt;code&gt;./a/b&lt;/code&gt; начинается с дополнительного компонента &lt;a href=&quot;enum.component#variant.CurDir&quot;&gt; &lt;code&gt;CurDir&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="10500e54805775e3d661be35724e87f0b1dbc4c9" translate="yes" xml:space="preserve">
          <source>Octal</source>
          <target state="translated">Octal</target>
        </trans-unit>
        <trans-unit id="e6f02e23e2b227ac6699b92be300da464d475a6e" translate="yes" xml:space="preserve">
          <source>Octal integer</source>
          <target state="translated">целое октября</target>
        </trans-unit>
        <trans-unit id="d04577406c042a11b4da7bb39486816308c607a6" translate="yes" xml:space="preserve">
          <source>Octal::fmt</source>
          <target state="translated">Octal::fmt</target>
        </trans-unit>
        <trans-unit id="615b20b5b110a1806177c985ebbca57031daa785" translate="yes" xml:space="preserve">
          <source>Of course, knowing which collection is the right one for the job doesn't instantly permit you to use it correctly. Here are some quick tips for efficient and correct usage of the standard collections in general. If you're interested in how to use a specific collection in particular, consult its documentation for detailed discussion and code examples.</source>
          <target state="translated">Конечно,знание того,какая коллекция подходит для данной работы,не сразу позволяет правильно ее использовать.Вот несколько быстрых советов по эффективному и правильному использованию стандартных коллекций в целом.Если вас интересует,как использовать конкретную коллекцию в частности,проконсультируйтесь с ее документацией для подробного обсуждения и примеров кода.</target>
        </trans-unit>
        <trans-unit id="2cbe09e34f3d1d91d444d3537b55bb92b3326aea" translate="yes" xml:space="preserve">
          <source>Of course, using &lt;a href=&quot;fn.stdout&quot;&gt;&lt;code&gt;io::stdout&lt;/code&gt;&lt;/a&gt; directly is less common than something like &lt;a href=&quot;../macro.println&quot;&gt;&lt;code&gt;println!&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Конечно, прямое использование &lt;a href=&quot;fn.stdout&quot;&gt; &lt;code&gt;io::stdout&lt;/code&gt; &lt;/a&gt; менее распространено, чем что-то вроде &lt;a href=&quot;../macro.println&quot;&gt; &lt;code&gt;println!&lt;/code&gt; &lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="35c2f4d3ee9ba6ff467650c366d5a389ebdd0812" translate="yes" xml:space="preserve">
          <source>Of course, you can do it as long as the module you're referring to is an ancestor:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="35d478ea3e054425d68cac2b881bb4303c629df5" translate="yes" xml:space="preserve">
          <source>Often, you&amp;rsquo;ll want to combine two existing strings. One way is to use the &lt;code&gt;+&lt;/code&gt; operator, as shown in Listing 8-18.</source>
          <target state="translated">Часто вам нужно объединить две существующие строки. Один из способов - использовать оператор &lt;code&gt;+&lt;/code&gt; , как показано в листинге 8-18.</target>
        </trans-unit>
        <trans-unit id="3894dea4e557c370e601b5214f719623a770bfec" translate="yes" xml:space="preserve">
          <source>On &lt;code&gt;packed&lt;/code&gt; structs</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6b1d4e18544489b4eaf442b238d12d6d0846066b" translate="yes" xml:space="preserve">
          <source>On Linux systems, if this is compiled as &lt;code&gt;foo&lt;/code&gt;:</source>
          <target state="translated">В системах Linux, если это скомпилировано как &lt;code&gt;foo&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="81c83f6982dcc0359616815ff2d1c2e0f9aa8bfa" translate="yes" xml:space="preserve">
          <source>On Linux, macOS, and PowerShell on Windows, you can see the executable by entering the &lt;code&gt;ls&lt;/code&gt; command in your shell. On Linux and macOS, you&amp;rsquo;ll see two files. With PowerShell on Windows, you&amp;rsquo;ll see the same three files that you would see using CMD.</source>
          <target state="translated">В Linux, macOS и PowerShell в Windows вы можете увидеть исполняемый файл, введя команду &lt;code&gt;ls&lt;/code&gt; в своей оболочке. В Linux и macOS вы увидите два файла. С PowerShell в Windows вы увидите те же три файла, что и при использовании CMD.</target>
        </trans-unit>
        <trans-unit id="7fc3d52902162d74f8ed313c5de739bb86f3a25d" translate="yes" xml:space="preserve">
          <source>On Linux:</source>
          <target state="translated">На Linux:</target>
        </trans-unit>
        <trans-unit id="28f964279968ee11e024ad4734a1849f6d567b40" translate="yes" xml:space="preserve">
          <source>On Redox this always returns &lt;code&gt;None&lt;/code&gt;.</source>
          <target state="translated">В Redox это всегда возвращает &lt;code&gt;None&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2c27c55a04c34d1416124c71c1487f965daf5e2b" translate="yes" xml:space="preserve">
          <source>On Unix</source>
          <target state="translated">На Unix</target>
        </trans-unit>
        <trans-unit id="f580d63739e00a5c78d3db723e0a54f4eebdec61" translate="yes" xml:space="preserve">
          <source>On Unix platforms, calling this method corresponds to calling &lt;code&gt;fcntl&lt;/code&gt;&lt;code&gt;FIONBIO&lt;/code&gt;. On Windows calling this method corresponds to calling &lt;code&gt;ioctlsocket&lt;/code&gt;&lt;code&gt;FIONBIO&lt;/code&gt;.</source>
          <target state="translated">На платформах Unix вызов этого метода соответствует вызову &lt;code&gt;fcntl&lt;/code&gt; &lt;code&gt;FIONBIO&lt;/code&gt; . В Windows вызов этого метода соответствует вызову &lt;code&gt;ioctlsocket&lt;/code&gt; &lt;code&gt;FIONBIO&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="368e8ed37eeed58c150496b19476b91dc7031ee8" translate="yes" xml:space="preserve">
          <source>On Unix platforms, the underlying syscall may be interrupted by a spurious wakeup or signal handler. To ensure the sleep occurs for at least the specified duration, this function may invoke that system call multiple times.</source>
          <target state="translated">На Unix-платформах базовый системный вызов может быть прерван поддельным пробуждением или обработчиком сигнала.Чтобы гарантировать,что сон происходит как минимум в течение заданной продолжительности,эта функция может вызвать системный вызов несколько раз.</target>
        </trans-unit>
        <trans-unit id="5d8d403cb28547a9afda373b97085e009420f7cc" translate="yes" xml:space="preserve">
          <source>On Unix platforms, the underlying syscall may be interrupted by a spurious wakeup or signal handler. To ensure the sleep occurs for at least the specified duration, this function may invoke that system call multiple times. Platforms which do not support nanosecond precision for sleeping will have &lt;code&gt;dur&lt;/code&gt; rounded up to the nearest granularity of time they can sleep for.</source>
          <target state="translated">На платформах Unix базовый системный вызов может быть прерван ложным пробуждением или обработчиком сигнала. Чтобы гарантировать, что сон продолжается по крайней мере на указанную продолжительность, эта функция может вызывать этот системный вызов несколько раз. Платформы , которые не поддерживают точность наносекунд для сна будет иметь &lt;code&gt;dur&lt;/code&gt; округляются до ближайшей зернистости времени они могут спать на.</target>
        </trans-unit>
        <trans-unit id="f15b383f304eefe4931d61a084a59f34627760f4" translate="yes" xml:space="preserve">
          <source>On Unix systems shell usually expands unquoted arguments with glob patterns (such as &lt;code&gt;*&lt;/code&gt; and &lt;code&gt;?&lt;/code&gt;). On Windows this is not done, and such arguments are passed as-is.</source>
          <target state="translated">В системах Unix оболочка обычно расширяет аргументы без кавычек с помощью глобальных шаблонов (таких как &lt;code&gt;*&lt;/code&gt; и &lt;code&gt;?&lt;/code&gt; ). В Windows этого не происходит, и такие аргументы передаются как есть.</target>
        </trans-unit>
        <trans-unit id="35aecf3282b41109feea97145ac8fcf33e5a85c0" translate="yes" xml:space="preserve">
          <source>On Unix systems the shell usually expands unquoted arguments with glob patterns (such as &lt;code&gt;*&lt;/code&gt; and &lt;code&gt;?&lt;/code&gt;). On Windows this is not done, and such arguments are passed as-is.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="73ed9ce935220230672af1ba06994403c22fd01d" translate="yes" xml:space="preserve">
          <source>On Unix systems when pthread-based TLS is being used, destructors will not be run for TLS values on the main thread when it exits. Note that the application will exit immediately after the main thread exits as well.</source>
          <target state="translated">На Unix-системах при использовании pthread-based TLS деструкторы не будут запускаться для значений TLS на главном потоке при его выходе.Обратите внимание,что приложение также выйдет сразу после выхода основного потока.</target>
        </trans-unit>
        <trans-unit id="fb3ee6950e481b93ea06bd207e97b8f1a208a9e6" translate="yes" xml:space="preserve">
          <source>On Unix systems, strings are often arbitrary sequences of non-zero bytes, in many cases interpreted as UTF-8.</source>
          <target state="translated">На Unix-системах строки часто представляют собой произвольные последовательности ненулевых байтов,во многих случаях интерпретируемые как UTF-8.</target>
        </trans-unit>
        <trans-unit id="ade1ebaf1f97bbb67b44937124b853209f01a0de" translate="yes" xml:space="preserve">
          <source>On Unix, &lt;a href=&quot;struct.osstr&quot;&gt;&lt;code&gt;OsStr&lt;/code&gt;&lt;/a&gt; implements the &lt;code&gt;std::os::unix::ffi::&lt;/code&gt;&lt;a href=&quot;../os/unix/ffi/trait.osstrext&quot;&gt;&lt;code&gt;OsStrExt&lt;/code&gt;&lt;/a&gt; trait, which augments it with two methods, &lt;a href=&quot;../os/unix/ffi/trait.osstrext#tymethod.from_bytes&quot;&gt;&lt;code&gt;from_bytes&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../os/unix/ffi/trait.osstrext#tymethod.as_bytes&quot;&gt;&lt;code&gt;as_bytes&lt;/code&gt;&lt;/a&gt;. These do inexpensive conversions from and to UTF-8 byte slices.</source>
          <target state="translated">В Unix &lt;a href=&quot;struct.osstr&quot;&gt; &lt;code&gt;OsStr&lt;/code&gt; &lt;/a&gt; реализует трейт &lt;code&gt;std::os::unix::ffi::&lt;/code&gt; &lt;a href=&quot;../os/unix/ffi/trait.osstrext&quot;&gt; &lt;code&gt;OsStrExt&lt;/code&gt; &lt;/a&gt; :: OsStrExt , который дополняет его двумя методами, &lt;a href=&quot;../os/unix/ffi/trait.osstrext#tymethod.from_bytes&quot;&gt; &lt;code&gt;from_bytes&lt;/code&gt; &lt;/a&gt; и &lt;a href=&quot;../os/unix/ffi/trait.osstrext#tymethod.as_bytes&quot;&gt; &lt;code&gt;as_bytes&lt;/code&gt; &lt;/a&gt; . Они делают недорогие преобразования из и в байтовые сегменты UTF-8.</target>
        </trans-unit>
        <trans-unit id="947b55450ee1839446a5472dd42bc83b983d60aa" translate="yes" xml:space="preserve">
          <source>On Unix, a path has a root if it begins with &lt;code&gt;/&lt;/code&gt;.</source>
          <target state="translated">В Unix у пути есть корень, если он начинается с &lt;code&gt;/&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3bd3b4c86524e4799caf099ecd37af36c6672deb" translate="yes" xml:space="preserve">
          <source>On Unix, a path is absolute if it starts with the root, so &lt;code&gt;is_absolute&lt;/code&gt; and &lt;a href=&quot;#method.has_root&quot;&gt;&lt;code&gt;has_root&lt;/code&gt;&lt;/a&gt; are equivalent.</source>
          <target state="translated">В Unix путь является абсолютным, если он начинается с корня, поэтому &lt;code&gt;is_absolute&lt;/code&gt; и &lt;a href=&quot;#method.has_root&quot;&gt; &lt;code&gt;has_root&lt;/code&gt; &lt;/a&gt; эквивалентны.</target>
        </trans-unit>
        <trans-unit id="c1d8cd80a5b3e4b5d2416174dfc8848e290d79c0" translate="yes" xml:space="preserve">
          <source>On Unix, a path is absolute if it starts with the root, so &lt;code&gt;is_absolute&lt;/code&gt; and &lt;a href=&quot;struct.path#method.has_root&quot;&gt;&lt;code&gt;has_root&lt;/code&gt;&lt;/a&gt; are equivalent.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8c49b23a9e8913d5f28e887403c1dd64ea25f5f0" translate="yes" xml:space="preserve">
          <source>On Unix, this will return &lt;code&gt;None&lt;/code&gt; if the process was terminated by a signal; &lt;code&gt;std::os::unix&lt;/code&gt; provides an extension trait for extracting the signal and other details from the &lt;code&gt;ExitStatus&lt;/code&gt;.</source>
          <target state="translated">В Unix это вернет &lt;code&gt;None&lt;/code&gt; , если процесс был завершен сигналом; &lt;code&gt;std::os::unix&lt;/code&gt; предоставляет свойство расширения для извлечения сигнала и других деталей из &lt;code&gt;ExitStatus&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="08103bc8083664f610de1cd76da40c7342e367bf" translate="yes" xml:space="preserve">
          <source>On Windows</source>
          <target state="translated">On Windows</target>
        </trans-unit>
        <trans-unit id="340634e7ba37ae9abb46e394a10f468ca07b5406" translate="yes" xml:space="preserve">
          <source>On Windows and most Unix platforms this function is free (no extra system calls needed), but some Unix platforms may require the equivalent call to &lt;code&gt;symlink_metadata&lt;/code&gt; to learn about the target file type.</source>
          <target state="translated">В Windows и большинстве платформ Unix эта функция бесплатна (дополнительные системные вызовы не требуются), но на некоторых платформах Unix может потребоваться эквивалентный вызов &lt;code&gt;symlink_metadata&lt;/code&gt; , чтобы узнать о целевом типе файла.</target>
        </trans-unit>
        <trans-unit id="dc05b2580f0d12742976994a81fdd3a92daa9627" translate="yes" xml:space="preserve">
          <source>On Windows this function is cheap to call (no extra system calls needed), but on Unix platforms this function is the equivalent of calling &lt;code&gt;symlink_metadata&lt;/code&gt; on the path.</source>
          <target state="translated">В Windows эту функцию дешево вызывать (дополнительные системные вызовы не требуются), но на платформах Unix эта функция эквивалентна вызову &lt;code&gt;symlink_metadata&lt;/code&gt; на пути.</target>
        </trans-unit>
        <trans-unit id="96488f7f2e398f8d620db102c3767404f52cec35" translate="yes" xml:space="preserve">
          <source>On Windows, &lt;a href=&quot;struct.osstr&quot;&gt;&lt;code&gt;OsStr&lt;/code&gt;&lt;/a&gt; implements the &lt;code&gt;std::os::windows::ffi::&lt;/code&gt;&lt;a href=&quot;../os/windows/ffi/trait.osstrext&quot;&gt;&lt;code&gt;OsStrExt&lt;/code&gt;&lt;/a&gt; trait, which provides an &lt;a href=&quot;../os/windows/ffi/trait.osstrext#tymethod.encode_wide&quot;&gt;&lt;code&gt;encode_wide&lt;/code&gt;&lt;/a&gt; method. This provides an iterator that can be &lt;a href=&quot;../iter/trait.iterator#method.collect&quot;&gt;&lt;code&gt;collect&lt;/code&gt;&lt;/a&gt;ed into a vector of &lt;a href=&quot;../primitive.u16&quot;&gt;&lt;code&gt;u16&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">В Windows &lt;a href=&quot;struct.osstr&quot;&gt; &lt;code&gt;OsStr&lt;/code&gt; &lt;/a&gt; реализует трейт &lt;code&gt;std::os::windows::ffi::&lt;/code&gt; &lt;a href=&quot;../os/windows/ffi/trait.osstrext&quot;&gt; &lt;code&gt;OsStrExt&lt;/code&gt; &lt;/a&gt; :: OsStrExt , который предоставляет метод &lt;a href=&quot;../os/windows/ffi/trait.osstrext#tymethod.encode_wide&quot;&gt; &lt;code&gt;encode_wide&lt;/code&gt; &lt;/a&gt; . Это обеспечивает итератор, который можно &lt;a href=&quot;../iter/trait.iterator#method.collect&quot;&gt; &lt;code&gt;collect&lt;/code&gt; &lt;/a&gt; в вектор &lt;a href=&quot;../primitive.u16&quot;&gt; &lt;code&gt;u16&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="354971d9fc4cf41d4726d0f246b8a7efa90a20dd" translate="yes" xml:space="preserve">
          <source>On Windows, &lt;a href=&quot;struct.osstr&quot;&gt;&lt;code&gt;OsStr&lt;/code&gt;&lt;/a&gt; implements the &lt;code&gt;std::os::windows::ffi::&lt;/code&gt;&lt;a href=&quot;../os/windows/ffi/trait.osstrext&quot;&gt;&lt;code&gt;OsStrExt&lt;/code&gt;&lt;/a&gt; trait, which provides an &lt;a href=&quot;../os/windows/ffi/trait.osstrext#tymethod.encode_wide&quot;&gt;&lt;code&gt;encode_wide&lt;/code&gt;&lt;/a&gt; method. This provides an iterator that can be &lt;a href=&quot;../iter/trait.iterator#method.collect&quot;&gt;&lt;code&gt;collect&lt;/code&gt;&lt;/a&gt;ed into a vector of &lt;a href=&quot;https://doc.rust-lang.org/nightly/std/primitive.u16.html&quot;&gt;&lt;code&gt;u16&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9af64d7ebac16f152870c457029381910a90ad98" translate="yes" xml:space="preserve">
          <source>On Windows, a path has a root if it:</source>
          <target state="translated">В Windows путь имеет корень,если он есть:</target>
        </trans-unit>
        <trans-unit id="23aad31490e7c68a187977dea619fd53f62cad2c" translate="yes" xml:space="preserve">
          <source>On Windows, a path is absolute if it has a prefix and starts with the root: &lt;code&gt;c:\windows&lt;/code&gt; is absolute, while &lt;code&gt;c:temp&lt;/code&gt; and &lt;code&gt;\temp&lt;/code&gt; are not.</source>
          <target state="translated">В Windows путь является абсолютным, если он имеет префикс и начинается с корня: &lt;code&gt;c:\windows&lt;/code&gt; является абсолютным, а &lt;code&gt;c:temp&lt;/code&gt; и &lt;code&gt;\temp&lt;/code&gt; - нет.</target>
        </trans-unit>
        <trans-unit id="76c59bd2f582fcbc4571a1c46e5718df63ea4def" translate="yes" xml:space="preserve">
          <source>On Windows, a symbolic link knows whether it is a file or directory.</source>
          <target state="translated">В Windows символическая ссылка знает,является ли она файлом или каталогом.</target>
        </trans-unit>
        <trans-unit id="21bc0d515b3e6fb7f3d9412e9a760b756bd52140" translate="yes" xml:space="preserve">
          <source>On Windows, enter the command &lt;code&gt;.\main.exe&lt;/code&gt; instead of &lt;code&gt;./main&lt;/code&gt;:</source>
          <target state="translated">В Windows введите команду &lt;code&gt;.\main.exe&lt;/code&gt; вместо &lt;code&gt;./main&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="a5430ea74797e1304f80750653012edbeaab36ca" translate="yes" xml:space="preserve">
          <source>On Windows, go to &lt;a href=&quot;https://www.rust-lang.org/tools/install&quot;&gt;https://www.rust-lang.org/tools/install&lt;/a&gt; and follow the instructions for installing Rust. At some point in the installation, you&amp;rsquo;ll receive a message explaining that you&amp;rsquo;ll also need the C++ build tools for Visual Studio 2013 or later. The easiest way to acquire the build tools is to install &lt;a href=&quot;https://visualstudio.microsoft.com/visual-cpp-build-tools/&quot;&gt;Build Tools for Visual Studio 2019&lt;/a&gt;. When asked which workloads to install make sure &quot;C++ build tools&quot; is selected and that the Windows 10 SDK and the English language pack components are included.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bd7a73ca0a18d815fd6e51cfa03502575932403d" translate="yes" xml:space="preserve">
          <source>On Windows, go to &lt;a href=&quot;https://www.rust-lang.org/tools/install&quot;&gt;https://www.rust-lang.org/tools/install&lt;/a&gt; and follow the instructions for installing Rust. At some point in the installation, you&amp;rsquo;ll receive a message explaining that you&amp;rsquo;ll also need the C++ build tools for Visual Studio 2013 or later. The easiest way to acquire the build tools is to install &lt;a href=&quot;https://www.visualstudio.com/downloads/#build-tools-for-visual-studio-2019&quot;&gt;Build Tools for Visual Studio 2019&lt;/a&gt;. The tools are in the Other Tools and Frameworks section.</source>
          <target state="translated">В Windows перейдите по &lt;a href=&quot;https://www.rust-lang.org/tools/install&quot;&gt;адресу https://www.rust-lang.org/tools/install&lt;/a&gt; и следуйте инструкциям по установке Rust. В какой-то момент установки вы получите сообщение о том, что вам также понадобятся инструменты сборки C ++ для Visual Studio 2013 или более поздней версии. Самый простой способ получить инструменты сборки - установить &lt;a href=&quot;https://www.visualstudio.com/downloads/#build-tools-for-visual-studio-2019&quot;&gt;Build Tools for Visual Studio 2019&lt;/a&gt; . Инструменты находятся в разделе &amp;laquo;Другие инструменты и платформы&amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="f9e96b3ce49cbd593ce10eba431579916c1beb4e" translate="yes" xml:space="preserve">
          <source>On Windows, strings are often arbitrary sequences of non-zero 16-bit values, interpreted as UTF-16 when it is valid to do so.</source>
          <target state="translated">В Windows строки часто представляют собой произвольные последовательности ненулевых 16-битных значений,интерпретируемых как UTF-16,когда это допустимо.</target>
        </trans-unit>
        <trans-unit id="4d87cfdfbe26beaf98d7cabde9343985e270cf11" translate="yes" xml:space="preserve">
          <source>On Windows, this converts the path to use &lt;a href=&quot;https://docs.microsoft.com/en-us/windows/win32/fileio/naming-a-file&quot;&gt;extended length path&lt;/a&gt; syntax, which allows your program to use longer path names, but means you can only join backslash-delimited paths to it, and it may be incompatible with other applications (if passed to the application on the command-line, or written to a file another application may read).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e57ac5776aebf69e1a4091e5f62bdd9bd9a59609" translate="yes" xml:space="preserve">
          <source>On Windows, this converts the path to use &lt;a href=&quot;https://msdn.microsoft.com/en-us/library/windows/desktop/aa365247(v=vs.85).aspx#maxpath&quot;&gt;extended length path&lt;/a&gt; syntax, which allows your program to use longer path names, but means you can only join backslash-delimited paths to it, and it may be incompatible with other applications (if passed to the application on the command-line, or written to a file another application may read).</source>
          <target state="translated">В Windows это преобразует путь для использования синтаксиса &lt;a href=&quot;https://msdn.microsoft.com/en-us/library/windows/desktop/aa365247(v=vs.85).aspx#maxpath&quot;&gt;расширенного пути&lt;/a&gt; , что позволяет вашей программе использовать более длинные имена путей, но означает, что вы можете присоединять к нему только пути, разделенные обратными косыми чертами, и он может быть несовместим с другими приложениями (если передан приложение в командной строке или записанный в файл, который может прочитать другое приложение).</target>
        </trans-unit>
        <trans-unit id="22cfd134aef9e5447e4029c33c01913e82dca29d" translate="yes" xml:space="preserve">
          <source>On Windows, you must specify whether a symbolic link points to a file or directory. Use &lt;code&gt;os::windows::fs::symlink_file&lt;/code&gt; to create a symbolic link to a file, or &lt;code&gt;os::windows::fs::symlink_dir&lt;/code&gt; to create a symbolic link to a directory. Additionally, the process must have &lt;code&gt;SeCreateSymbolicLinkPrivilege&lt;/code&gt; in order to be able to create a symbolic link.</source>
          <target state="translated">В Windows необходимо указать, указывает ли символическая ссылка на файл или каталог. Используйте &lt;code&gt;os::windows::fs::symlink_file&lt;/code&gt; чтобы создать символьную ссылку на файл, или &lt;code&gt;os::windows::fs::symlink_dir&lt;/code&gt; чтобы создать символьную ссылку на каталог. Кроме того, процесс должен иметь &lt;code&gt;SeCreateSymbolicLinkPrivilege&lt;/code&gt; , чтобы иметь возможность создавать символическую ссылку.</target>
        </trans-unit>
        <trans-unit id="55b56364276b5f7e47e7f031287b139fc5b947d5" translate="yes" xml:space="preserve">
          <source>On Windows:</source>
          <target state="translated">На Windows:</target>
        </trans-unit>
        <trans-unit id="2d943049f7275605af2957c0729af75e15804644" translate="yes" xml:space="preserve">
          <source>On a struct pattern, the fields are referenced by name, index (in the case of tuple structs) or ignored by use of &lt;code&gt;..&lt;/code&gt;:</source>
          <target state="translated">В шаблоне структуры на поля ссылаются по имени, индексу (в случае кортежных структур) или игнорируются с помощью &lt;code&gt;..&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="bc5ae395985a077524b266fc2c058a9c41f9a6c9" translate="yes" xml:space="preserve">
          <source>On a technical level, Rust inserts</source>
          <target state="translated">На техническом уровне,ржавые вставки</target>
        </trans-unit>
        <trans-unit id="1b348ad01b675597a26bee9f6007707cf4e88f3f" translate="yes" xml:space="preserve">
          <source>On all platforms it's possible for TLS to re-initialize other TLS slots during destruction. Some platforms ensure that this cannot happen infinitely by preventing re-initialization of any slot that has been destroyed, but not all platforms have this guard. Those platforms that do not guard typically have a synthetic limit after which point no more destructors are run.</source>
          <target state="translated">На всех платформах TLS может повторно инициализировать другие слоты TLS во время разрушения.Некоторые платформы гарантируют,что это не может происходить бесконечно,предотвращая повторную инициализацию любого слота,который был уничтожен,но не на всех платформах есть такая защита.Те платформы,которые не защищают,обычно имеют синтетический лимит,после которого больше не запускаются деструкторы.</target>
        </trans-unit>
        <trans-unit id="037d4731f94d8fe39eb9b4a6879b2f19130604a0" translate="yes" xml:space="preserve">
          <source>On all platforms, the newline is the LINE FEED character (&lt;code&gt;\n&lt;/code&gt;/&lt;code&gt;U+000A&lt;/code&gt;) alone (no additional CARRIAGE RETURN (&lt;code&gt;\r&lt;/code&gt;/&lt;code&gt;U+000D&lt;/code&gt;)).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d799d2a3d45a2a27a645560d44031039269d8400" translate="yes" xml:space="preserve">
          <source>On all platforms, the newline is the LINE FEED character (&lt;code&gt;\n&lt;/code&gt;/&lt;code&gt;U+000A&lt;/code&gt;) alone (no additional CARRIAGE RETURN (&lt;code&gt;\r&lt;/code&gt;/&lt;code&gt;U+000D&lt;/code&gt;).</source>
          <target state="translated">На всех платформах символ новой строки - это только символ LINE FEED ( &lt;code&gt;\n&lt;/code&gt; / &lt;code&gt;U+000A&lt;/code&gt; ) (без дополнительного ВОЗВРАТА ПЕРЕВОЗКИ ( &lt;code&gt;\r&lt;/code&gt; / &lt;code&gt;U+000D&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="8026d1566cfb33142845deb08dc55be0e48c8b84" translate="yes" xml:space="preserve">
          <source>On arithmetic overflow, returns &lt;code&gt;LayoutErr&lt;/code&gt;.</source>
          <target state="translated">При арифметическом переполнении возвращает &lt;code&gt;LayoutErr&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="62056a56ee350ef2ac48d7878ee0e8c05c6cdab9" translate="yes" xml:space="preserve">
          <source>On big endian this is a no-op. On little endian the bytes are swapped.</source>
          <target state="translated">На большом эндиане это &quot;нет-оп&quot;.На маленьком эндиане байты меняются.</target>
        </trans-unit>
        <trans-unit id="3209db243d37f470d1d7cfe42ce3d766b7bc29ef" translate="yes" xml:space="preserve">
          <source>On failure, ownership of the original &lt;code&gt;CString&lt;/code&gt; is returned.</source>
          <target state="translated">В случае ошибки право собственности на исходный &lt;code&gt;CString&lt;/code&gt; возвращается.</target>
        </trans-unit>
        <trans-unit id="4c9afd72e5fc07b12e4a58aab05b5a861ccfe991" translate="yes" xml:space="preserve">
          <source>On failure, ownership of the original &lt;code&gt;OsString&lt;/code&gt; is returned.</source>
          <target state="translated">В случае сбоя право собственности на исходную &lt;code&gt;OsString&lt;/code&gt; возвращается.</target>
        </trans-unit>
        <trans-unit id="259a9191e45f4405904adb74ccfbaecde8fac969" translate="yes" xml:space="preserve">
          <source>On glibc Linux systems, arguments are retrieved by placing a function in &quot;.init_array&quot;. Glibc passes argc, argv, and envp to functions in &quot;.init_array&quot;, as a non-standard extension. This allows &lt;code&gt;std::env::args&lt;/code&gt; to work even in a &lt;code&gt;cdylib&lt;/code&gt; or &lt;code&gt;staticlib&lt;/code&gt;, as it does on macOS and Windows.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d682d53e730f8107b6e28e70ea3aca1f2f84a3a2" translate="yes" xml:space="preserve">
          <source>On glibc Linux systems, arguments are retrieved by placing a function in &lt;code&gt;.init_array&lt;/code&gt;. Glibc passes &lt;code&gt;argc&lt;/code&gt;, &lt;code&gt;argv&lt;/code&gt;, and &lt;code&gt;envp&lt;/code&gt; to functions in &lt;code&gt;.init_array&lt;/code&gt;, as a non-standard extension. This allows &lt;code&gt;std::env::args&lt;/code&gt; to work even in a &lt;code&gt;cdylib&lt;/code&gt; or &lt;code&gt;staticlib&lt;/code&gt;, as it does on macOS and Windows.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3818a4eb5a3ae2432429a2be6f00d2b57327ad67" translate="yes" xml:space="preserve">
          <source>On iteration, the closure will be applied to each element of the iterator and the return value from the closure, an &lt;a href=&quot;../option/enum.option&quot;&gt;&lt;code&gt;Option&lt;/code&gt;&lt;/a&gt;, is yielded by the iterator.</source>
          <target state="translated">При итерации закрытие будет применено к каждому элементу итератора, и итератор выдает возвращаемое из замыкания значение &lt;a href=&quot;../option/enum.option&quot;&gt; &lt;code&gt;Option&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="7ac8ec0fd24d5e212f6e7881f085d7af49a49607" translate="yes" xml:space="preserve">
          <source>On little endian this is a no-op. On big endian the bytes are swapped.</source>
          <target state="translated">На маленьком эндиане это безумие.На большом эндиане байты меняются.</target>
        </trans-unit>
        <trans-unit id="5d4ddcfc8d324d93f4c94125de45c5742f4d5101" translate="yes" xml:space="preserve">
          <source>On non-pointer types &lt;code&gt;*x&lt;/code&gt; is equivalent to &lt;code&gt;*std::ops::Deref::deref(&amp;amp;x)&lt;/code&gt; in an &lt;a href=&quot;../expressions#mutability&quot;&gt;immutable place expression context&lt;/a&gt; and &lt;code&gt;*std::ops::DerefMut::deref_mut(&amp;amp;mut x)&lt;/code&gt; in a mutable place expression context.</source>
          <target state="translated">Для типов без указателей &lt;code&gt;*x&lt;/code&gt; эквивалентен &lt;code&gt;*std::ops::Deref::deref(&amp;amp;x)&lt;/code&gt; в &lt;a href=&quot;../expressions#mutability&quot;&gt;неизменяемом контексте выражения места&lt;/a&gt; и &lt;code&gt;*std::ops::DerefMut::deref_mut(&amp;amp;mut x)&lt;/code&gt; в изменяемом месте контекст выражения.</target>
        </trans-unit>
        <trans-unit id="152e667068d08065574b6f3ea75735b1ef22f81c" translate="yes" xml:space="preserve">
          <source>On panic, this macro will print the values of the expressions with their debug representations.</source>
          <target state="translated">В панике этот макрос выведет значения выражений с их отладочными представлениями.</target>
        </trans-unit>
        <trans-unit id="a0e8d873b690ac84365bcb6ce9a48ba9ac4a73cf" translate="yes" xml:space="preserve">
          <source>On some system, calling &lt;a href=&quot;#method.wait&quot;&gt;&lt;code&gt;wait&lt;/code&gt;&lt;/a&gt; or similar is necessary for the OS to release resources. A process that terminated but has not been waited on is still around as a &quot;zombie&quot;. Leaving too many zombies around may exhaust global resources (for example process IDs).</source>
          <target state="translated">В некоторых системах вызов &lt;a href=&quot;#method.wait&quot;&gt; &lt;code&gt;wait&lt;/code&gt; &lt;/a&gt; или аналогичный вызов необходим ОС для освобождения ресурсов. Процесс, который завершился, но не ожидался, все еще существует как &amp;laquo;зомби&amp;raquo;. Если оставить слишком много зомби, это может истощить глобальные ресурсы (например, идентификаторы процессов).</target>
        </trans-unit>
        <trans-unit id="8d680bbd1b29ac2bd7f1c4039cc2f034c2409b58" translate="yes" xml:space="preserve">
          <source>On some systems, calling &lt;a href=&quot;struct.child#method.wait&quot;&gt;&lt;code&gt;wait&lt;/code&gt;&lt;/a&gt; or similar is necessary for the OS to release resources. A process that terminated but has not been waited on is still around as a &quot;zombie&quot;. Leaving too many zombies around may exhaust global resources (for example process IDs).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f95b6f9f5ca3589fe7d076155399faa6b71dbbbe" translate="yes" xml:space="preserve">
          <source>On success this function will not return, and otherwise it will return an error indicating why the exec (or another part of the setup of the &lt;code&gt;Command&lt;/code&gt;) failed.</source>
          <target state="translated">В случае успеха эта функция не вернется, в противном случае она вернет ошибку, указывающую, почему не удалось выполнить exec (или другую часть настройки &lt;code&gt;Command&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="9dc3aca4d292aed062c338c543e13af0f74c89de" translate="yes" xml:space="preserve">
          <source>On success, returns a &lt;a href=&quot;../ptr/struct.nonnull&quot;&gt;&lt;code&gt;NonNull&amp;lt;[u8]&amp;gt;&lt;/code&gt;&lt;/a&gt; meeting the size and alignment guarantees of &lt;code&gt;layout&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="85ee4aa1b293e333458ae17de2dc9971adc5a07b" translate="yes" xml:space="preserve">
          <source>On success, returns the number of bytes read and the address from whence the data came.</source>
          <target state="translated">В случае успеха возвращает количество прочитанных байт и адрес,откуда пришли данные.</target>
        </trans-unit>
        <trans-unit id="4ea0ccaabe0c9b1fbc90341ab5a04d65215e560d" translate="yes" xml:space="preserve">
          <source>On success, returns the number of bytes read.</source>
          <target state="translated">При успешной работе возвращает количество прочитанных байт.</target>
        </trans-unit>
        <trans-unit id="bc5a49aba56a5b26329959ae0e37a7391cbb54ed" translate="yes" xml:space="preserve">
          <source>On success, returns the number of bytes written.</source>
          <target state="translated">При успехе возвращает количество написанных байтов.</target>
        </trans-unit>
        <trans-unit id="f9b7167ab1cb81802d4cc93ff38048bd7cd2f218" translate="yes" xml:space="preserve">
          <source>On success, the total number of bytes copied is returned and it is equal to the length of the &lt;code&gt;to&lt;/code&gt; file as reported by &lt;code&gt;metadata&lt;/code&gt;.</source>
          <target state="translated">В случае успеха, общее количество байт , скопированных возвращаются и она равна длиной &lt;code&gt;to&lt;/code&gt; файла , как сообщают &lt;code&gt;metadata&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a6bfa6f8c514698639a06b222dc94c1639495b9f" translate="yes" xml:space="preserve">
          <source>On success, the total number of bytes that were copied from &lt;code&gt;reader&lt;/code&gt; to &lt;code&gt;writer&lt;/code&gt; is returned.</source>
          <target state="translated">В случае успеха, общее количество байт, скопированных из &lt;code&gt;reader&lt;/code&gt; к &lt;code&gt;writer&lt;/code&gt; возвращается.</target>
        </trans-unit>
        <trans-unit id="43a00d4716ce2886f17dadaa3b0e2204d940167a" translate="yes" xml:space="preserve">
          <source>On the &lt;code&gt;Screen&lt;/code&gt; struct, we&amp;rsquo;ll define a method named &lt;code&gt;run&lt;/code&gt; that will call the &lt;code&gt;draw&lt;/code&gt; method on each of its &lt;code&gt;components&lt;/code&gt;, as shown in Listing 17-5:</source>
          <target state="translated">В структуре &lt;code&gt;Screen&lt;/code&gt; мы определим метод с именем &lt;code&gt;run&lt;/code&gt; , который будет вызывать метод &lt;code&gt;draw&lt;/code&gt; для каждого из своих &lt;code&gt;components&lt;/code&gt; , как показано в листинге 17-5:</target>
        </trans-unit>
        <trans-unit id="417a01b51fb2fc402d7ff9e7a38ed36ddb3ab97a" translate="yes" xml:space="preserve">
          <source>On the first line of &lt;code&gt;main&lt;/code&gt;, we call &lt;code&gt;env::args&lt;/code&gt;, and we immediately use &lt;code&gt;collect&lt;/code&gt; to turn the iterator into a vector containing all the values produced by the iterator. We can use the &lt;code&gt;collect&lt;/code&gt; function to create many kinds of collections, so we explicitly annotate the type of &lt;code&gt;args&lt;/code&gt; to specify that we want a vector of strings. Although we very rarely need to annotate types in Rust, &lt;code&gt;collect&lt;/code&gt; is one function you do often need to annotate because Rust isn&amp;rsquo;t able to infer the kind of collection you want.</source>
          <target state="translated">В первой строке &lt;code&gt;main&lt;/code&gt; мы вызываем &lt;code&gt;env::args&lt;/code&gt; и сразу же используем &lt;code&gt;collect&lt;/code&gt; , чтобы превратить итератор в вектор, содержащий все значения, созданные итератором. Мы можем использовать функцию &lt;code&gt;collect&lt;/code&gt; для создания множества видов коллекций, поэтому мы явно аннотируем тип &lt;code&gt;args&lt;/code&gt; чтобы указать, что нам нужен вектор строк. Хотя нам очень редко нужно аннотировать типы в Rust, &lt;code&gt;collect&lt;/code&gt; - это одна из функций, которую вам часто нужно аннотировать, потому что Rust не может вывести тип коллекции, которую вы хотите.</target>
        </trans-unit>
        <trans-unit id="9eddcffce559b2f4fd96faa276545d34f1b2fe9a" translate="yes" xml:space="preserve">
          <source>On the other hand, one trait which would not be appropriate to implement is &lt;a href=&quot;default/trait.default&quot;&gt;&lt;code&gt;Default&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">С другой стороны, одна черта, которую не следует реализовывать, - это &lt;a href=&quot;default/trait.default&quot;&gt; &lt;code&gt;Default&lt;/code&gt; &lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="c286483c8f6ceb616a180cf64f82c92b911d5676" translate="yes" xml:space="preserve">
          <source>On the other hand, this is correct:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8cf67f3b833240197b7f3967e7a28b88e1336e77" translate="yes" xml:space="preserve">
          <source>On the other hand, this will not compile because the &lt;code&gt;where 'b: 'a&lt;/code&gt; clause is missing: the &lt;code&gt;'b&lt;/code&gt; lifetime is not known to live at least as long as &lt;code&gt;'a&lt;/code&gt; which means this function cannot ensure it always returns a valid reference:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="09d6ad3b118e12286d44db37bda32a77e5392fde" translate="yes" xml:space="preserve">
          <source>On the other hand, when bringing in structs, enums, and other items with &lt;code&gt;use&lt;/code&gt;, it&amp;rsquo;s idiomatic to specify the full path. Listing 7-14 shows the idiomatic way to bring the standard library&amp;rsquo;s &lt;code&gt;HashMap&lt;/code&gt; struct into the scope of a binary crate.</source>
          <target state="translated">С другой стороны, при вводе структур, перечислений и других элементов с &lt;code&gt;use&lt;/code&gt; идиоматично указывать полный путь. В листинге 7-14 показан идиоматический способ переноса структуры &lt;code&gt;HashMap&lt;/code&gt; стандартной библиотеки в область видимости двоичного ящика.</target>
        </trans-unit>
        <trans-unit id="50d2f428f140a723a3dc474c3eb5d43ababe5b45" translate="yes" xml:space="preserve">
          <source>On the other hand, with the method using trait objects, one &lt;code&gt;Screen&lt;/code&gt; instance can hold a &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; that contains a &lt;code&gt;Box&amp;lt;Button&amp;gt;&lt;/code&gt; as well as a &lt;code&gt;Box&amp;lt;TextField&amp;gt;&lt;/code&gt;. Let&amp;rsquo;s look at how this works, and then we&amp;rsquo;ll talk about the runtime performance implications.</source>
          <target state="translated">С другой стороны, с методом, использующим типажные объекты, один экземпляр &lt;code&gt;Screen&lt;/code&gt; может содержать &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; который содержит &lt;code&gt;Box&amp;lt;Button&amp;gt;&lt;/code&gt; а также &lt;code&gt;Box&amp;lt;TextField&amp;gt;&lt;/code&gt; . Давайте посмотрим, как это работает, а затем поговорим о последствиях для производительности во время выполнения.</target>
        </trans-unit>
        <trans-unit id="05a08140d648b8eef0f62e5e0b016ae12318d58b" translate="yes" xml:space="preserve">
          <source>On the surface, &lt;code&gt;static&lt;/code&gt; items seem very similar to &lt;a href=&quot;keyword.const&quot;&gt;&lt;code&gt;const&lt;/code&gt;&lt;/a&gt;s: both contain a value, both require type annotations and both can only be initialized with constant functions and values. However, &lt;code&gt;static&lt;/code&gt;s are notably different in that they represent a location in memory. That means that you can have references to &lt;code&gt;static&lt;/code&gt; items and potentially even modify them, making them essentially global variables.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8593d2dddd7916b4461c2238bc4c5b8191583e5e" translate="yes" xml:space="preserve">
          <source>On top of that, all additional invariants of the type &lt;code&gt;T&lt;/code&gt; must be satisfied, as the &lt;code&gt;Drop&lt;/code&gt; implementation of &lt;code&gt;T&lt;/code&gt; (or its members) may rely on this. For example, a &lt;code&gt;1&lt;/code&gt;-initialized &lt;a href=&quot;../vec/struct.vec&quot;&gt;&lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt; is considered initialized (under the current implementation; this does not constitute a stable guarantee) because the only requirement the compiler knows about it is that the data pointer must be non-null. Dropping such a &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; however will cause undefined behaviour.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7d7c692a18f46234aa3957edc945a28ff83c44fe" translate="yes" xml:space="preserve">
          <source>On top of that, function pointers can vary based on what ABI they use. This is achieved by adding the &lt;code&gt;extern&lt;/code&gt; keyword before the type, followed by the ABI in question. The default ABI is &quot;Rust&quot;, i.e., &lt;code&gt;fn()&lt;/code&gt; is the exact same type as &lt;code&gt;extern &quot;Rust&quot; fn()&lt;/code&gt;. A pointer to a function with C ABI would have type &lt;code&gt;extern &quot;C&quot; fn()&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a7c793eb037e8ef3b7da8efa89ac452132495eae" translate="yes" xml:space="preserve">
          <source>On top of that, function pointers can vary based on what ABI they use. This is achieved by adding the &lt;code&gt;extern&lt;/code&gt; keyword to the type name, followed by the ABI in question. For example, &lt;code&gt;fn()&lt;/code&gt; is different from &lt;code&gt;extern &quot;C&quot; fn()&lt;/code&gt;, which itself is different from &lt;code&gt;extern &quot;stdcall&quot; fn()&lt;/code&gt;, and so on for the various ABIs that Rust supports. Non-&lt;code&gt;extern&lt;/code&gt; functions have an ABI of &lt;code&gt;&quot;Rust&quot;&lt;/code&gt;, and &lt;code&gt;extern&lt;/code&gt; functions without an explicit ABI have an ABI of &lt;code&gt;&quot;C&quot;&lt;/code&gt;. For more information, see &lt;a href=&quot;https://doc.rust-lang.org/nomicon/ffi.html#foreign-calling-conventions&quot;&gt;the nomicon's section on foreign calling conventions&lt;/a&gt;.</source>
          <target state="translated">Кроме того, указатели на функции могут различаться в зависимости от того, какой ABI они используют. Это достигается путем добавления ключевого слова &lt;code&gt;extern&lt;/code&gt; к имени типа, за которым следует рассматриваемый ABI. Например, &lt;code&gt;fn()&lt;/code&gt; отличается от &lt;code&gt;extern &quot;C&quot; fn()&lt;/code&gt; , который сам по себе отличается от &lt;code&gt;extern &quot;stdcall&quot; fn()&lt;/code&gt; , и так далее для различных ABI, поддерживаемых Rust. Не &lt;code&gt;extern&lt;/code&gt; функции имеют ABI &lt;code&gt;&quot;Rust&quot;&lt;/code&gt; , а &lt;code&gt;extern&lt;/code&gt; функции без явного ABI имеют ABI &lt;code&gt;&quot;C&quot;&lt;/code&gt; . Для получения дополнительной информации см. &lt;a href=&quot;https://doc.rust-lang.org/nomicon/ffi.html#foreign-calling-conventions&quot;&gt;Раздел nomicon, посвященный соглашениям о внешних вызовах&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="7b2aa688af42ea89b3fbf818f2d4bdeab6c73c4a" translate="yes" xml:space="preserve">
          <source>On top of that, remember that most types have additional invariants beyond merely being considered initialized at the type level. For example, a &lt;code&gt;1&lt;/code&gt;-initialized &lt;a href=&quot;../vec/struct.vec&quot;&gt;&lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt; is considered initialized (under the current implementation; this does not constitute a stable guarantee) because the only requirement the compiler knows about it is that the data pointer must be non-null. Creating such a &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; does not cause &lt;em&gt;immediate&lt;/em&gt; undefined behavior, but will cause undefined behavior with most safe operations (including dropping it).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="630c59f788be2f8b6b4b1ca247b245094c3530e8" translate="yes" xml:space="preserve">
          <source>On top of that, remember that most types have additional invariants beyond merely being considered initialized at the type level. For example, a &lt;code&gt;1&lt;/code&gt;-initialized &lt;a href=&quot;../vec/struct.vec&quot;&gt;&lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt; is considered initialized because the only requirement the compiler knows about it is that the data pointer must be non-null. Creating such a &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; does not cause &lt;em&gt;immediate&lt;/em&gt; undefined behavior, but will cause undefined behavior with most safe operations (including dropping it).</source>
          <target state="translated">Кроме того, помните, что большинство типов имеют дополнительные инварианты, помимо того, что они считаются инициализированными на уровне типа. Например, &lt;code&gt;1&lt;/code&gt; - инициализированный &lt;a href=&quot;../vec/struct.vec&quot;&gt; &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; &lt;/a&gt; считается инициализированным, потому что единственное требование, которое компилятор знает о нем, - это то, что указатель данных не должен быть нулевым. Создание такого &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; не вызывает &lt;em&gt;немедленного&lt;/em&gt; неопределенного поведения, но приведет к неопределенному поведению при большинстве безопасных операций (включая его удаление).</target>
        </trans-unit>
        <trans-unit id="d9c768782ea8653d485fb3b7f5aba21cb2ca7bf3" translate="yes" xml:space="preserve">
          <source>Once</source>
          <target state="translated">Once</target>
        </trans-unit>
        <trans-unit id="dde4e913efe3a7bb20d91e29731b497ad0b7ade2" translate="yes" xml:space="preserve">
          <source>Once &lt;code&gt;Config::new&lt;/code&gt; takes ownership of the iterator and stops using indexing operations that borrow, we can move the &lt;code&gt;String&lt;/code&gt; values from the iterator into &lt;code&gt;Config&lt;/code&gt; rather than calling &lt;code&gt;clone&lt;/code&gt; and making a new allocation.</source>
          <target state="translated">Как только &lt;code&gt;Config::new&lt;/code&gt; становится владельцем итератора и перестает использовать заимствованные операции индексации, мы можем переместить значения &lt;code&gt;String&lt;/code&gt; из итератора в &lt;code&gt;Config&lt;/code&gt; вместо вызова &lt;code&gt;clone&lt;/code&gt; и создания нового распределения.</target>
        </trans-unit>
        <trans-unit id="8b0de6bbc4d6a271545919a41560436f915e4647" translate="yes" xml:space="preserve">
          <source>Once a future has completed (returned &lt;code&gt;Ready&lt;/code&gt; from &lt;code&gt;poll&lt;/code&gt;), calling its &lt;code&gt;poll&lt;/code&gt; method again may panic, block forever, or cause other kinds of problems; the &lt;code&gt;Future&lt;/code&gt; trait places no requirements on the effects of such a call. However, as the &lt;code&gt;poll&lt;/code&gt; method is not marked &lt;code&gt;unsafe&lt;/code&gt;, Rust's usual rules apply: calls must never cause undefined behavior (memory corruption, incorrect use of &lt;code&gt;unsafe&lt;/code&gt; functions, or the like), regardless of the future's state.</source>
          <target state="translated">Как только будущее завершено (возвращается &lt;code&gt;Ready&lt;/code&gt; из &lt;code&gt;poll&lt;/code&gt; ), повторный вызов его метода &lt;code&gt;poll&lt;/code&gt; может вызвать панику, блокировку навсегда или вызвать другие виды проблем; &lt;code&gt;Future&lt;/code&gt; черта не накладывает какие - либо требований о последствиях такого вызова. Однако, поскольку метод &lt;code&gt;poll&lt;/code&gt; не помечен как &lt;code&gt;unsafe&lt;/code&gt; , применяются обычные правила Rust: вызовы никогда не должны вызывать неопределенное поведение (повреждение памяти, неправильное использование &lt;code&gt;unsafe&lt;/code&gt; функций и т.п.), независимо от состояния в будущем.</target>
        </trans-unit>
        <trans-unit id="472f512f503c00a7a3badf54bca4e8a984d78d81" translate="yes" xml:space="preserve">
          <source>Once a future has finished, clients should not &lt;code&gt;poll&lt;/code&gt; it again.</source>
          <target state="translated">Как только фьючерс закончен, клиенты не должны &lt;code&gt;poll&lt;/code&gt; его снова.</target>
        </trans-unit>
        <trans-unit id="52d66dce2b0cbeb3ef0b4a40c595411581c4bf47" translate="yes" xml:space="preserve">
          <source>Once a valid size is received, our &lt;code&gt;ThreadPool&lt;/code&gt; creates a new vector that can hold &lt;code&gt;size&lt;/code&gt; items. We haven&amp;rsquo;t used the &lt;code&gt;with_capacity&lt;/code&gt; function in this book yet, which performs the same task as &lt;code&gt;Vec::new&lt;/code&gt; but with an important difference: it preallocates space in the vector. Because we know we need to store &lt;code&gt;size&lt;/code&gt; elements in the vector, doing this allocation up front is slightly more efficient than using &lt;code&gt;Vec::new&lt;/code&gt;, which resizes itself as elements are inserted.</source>
          <target state="translated">После получения допустимого размера наш &lt;code&gt;ThreadPool&lt;/code&gt; создает новый вектор, который может содержать элементы &lt;code&gt;size&lt;/code&gt; . В этой книге мы еще не использовали функцию &lt;code&gt;with_capacity&lt;/code&gt; , которая выполняет ту же задачу, что и &lt;code&gt;Vec::new&lt;/code&gt; но с важным отличием: она предварительно выделяет пространство в векторе. Поскольку мы знаем, что нам нужно хранить элементы &lt;code&gt;size&lt;/code&gt; в векторе, выполнение этого распределения вперед немного более эффективно, чем использование &lt;code&gt;Vec::new&lt;/code&gt; , которое изменяет свои размеры при вставке элементов.</target>
        </trans-unit>
        <trans-unit id="b9c2a150a70fbfb0f86650e1f5cd73ca0f595c49" translate="yes" xml:space="preserve">
          <source>Once again we're using &lt;code&gt;!&lt;/code&gt;'s ability to coerce into any other type, in this case &lt;a href=&quot;fmt/type.result&quot;&gt;&lt;code&gt;fmt::Result&lt;/code&gt;&lt;/a&gt;. Since this method takes a &lt;code&gt;&amp;amp;!&lt;/code&gt; as an argument we know that it can never be called (because there is no value of type &lt;code&gt;!&lt;/code&gt; for it to be called with). Writing &lt;code&gt;*self&lt;/code&gt; essentially tells the compiler &quot;We know that this code can never be run, so just treat the entire function body as having type &lt;a href=&quot;fmt/type.result&quot;&gt;&lt;code&gt;fmt::Result&lt;/code&gt;&lt;/a&gt;&quot;. This pattern can be used a lot when implementing traits for &lt;code&gt;!&lt;/code&gt;. Generally, any trait which only has methods which take a &lt;code&gt;self&lt;/code&gt; parameter should have such an impl.</source>
          <target state="translated">Еще раз используем &lt;code&gt;!&lt;/code&gt; возможность принуждения к любому другому типу, в данном случае &lt;a href=&quot;fmt/type.result&quot;&gt; &lt;code&gt;fmt::Result&lt;/code&gt; &lt;/a&gt; . Поскольку этот метод принимает &lt;code&gt;&amp;amp;!&lt;/code&gt; в качестве аргумента мы знаем, что он никогда не может быть вызван (потому что нет значения типа &lt;code&gt;!&lt;/code&gt; , с которым он мог бы быть вызван). Написание &lt;code&gt;*self&lt;/code&gt; по существу сообщает компилятору: &amp;laquo;Мы знаем, что этот код никогда не может быть запущен, поэтому просто рассматривайте все тело функции как имеющее тип &lt;a href=&quot;fmt/type.result&quot;&gt; &lt;code&gt;fmt::Result&lt;/code&gt; &lt;/a&gt; &amp;raquo;. Этот шаблон можно часто использовать при реализации трейтов для &lt;code&gt;!&lt;/code&gt; . Как правило, любой трейт, у которого есть только методы, принимающие параметр &lt;code&gt;self&lt;/code&gt; , должен иметь такой impl.</target>
        </trans-unit>
        <trans-unit id="3c60f2098dcfc1948a1cd5eb57c13cccf48d2d00" translate="yes" xml:space="preserve">
          <source>Once again, we compile and get... different errors! The compiler is teaching us a lot.</source>
          <target state="translated">Еще раз,мы компилируем и получаем...разные ошибки! Компилятор нас многому учит.</target>
        </trans-unit>
        <trans-unit id="30ba447807ee16c40637ce8c42ca10892e8780ac" translate="yes" xml:space="preserve">
          <source>Once half of a channel has been deallocated, most operations can no longer continue to make progress, so &lt;a href=&quot;../../result/enum.result#variant.Err&quot;&gt;&lt;code&gt;Err&lt;/code&gt;&lt;/a&gt; will be returned. Many applications will continue to &lt;a href=&quot;../../result/enum.result#method.unwrap&quot;&gt;&lt;code&gt;unwrap&lt;/code&gt;&lt;/a&gt; the results returned from this module, instigating a propagation of failure among threads if one unexpectedly dies.</source>
          <target state="translated">После того, как половина канала освобождена, выполнение большинства операций больше не может продолжаться, поэтому будет возвращена &lt;a href=&quot;../../result/enum.result#variant.Err&quot;&gt; &lt;code&gt;Err&lt;/code&gt; &lt;/a&gt; . Многие приложения будут продолжать &lt;a href=&quot;../../result/enum.result#method.unwrap&quot;&gt; &lt;code&gt;unwrap&lt;/code&gt; &lt;/a&gt; результаты, возвращаемые этим модулем, инициируя распространение сбоя среди потоков, если один из них неожиданно умирает.</target>
        </trans-unit>
        <trans-unit id="a91c464fe4209e458222e2a75f2d92f1b46b0155" translate="yes" xml:space="preserve">
          <source>Once the internal storage is contiguous, the &lt;a href=&quot;../struct.vecdeque#method.as_slices&quot;&gt;&lt;code&gt;as_slices&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../struct.vecdeque#method.as_mut_slices&quot;&gt;&lt;code&gt;as_mut_slices&lt;/code&gt;&lt;/a&gt; methods will return the entire contents of the &lt;code&gt;VecDeque&lt;/code&gt; in a single slice.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6364bb4d426e3f0cecb2911427f26ed73152d755" translate="yes" xml:space="preserve">
          <source>Once the internal storage is contiguous, the &lt;a href=&quot;struct.vecdeque#method.as_slices&quot;&gt;&lt;code&gt;as_slices&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;struct.vecdeque#method.as_mut_slices&quot;&gt;&lt;code&gt;as_mut_slices&lt;/code&gt;&lt;/a&gt; methods will return the entire contents of the &lt;code&gt;VecDeque&lt;/code&gt; in a single slice.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7b36c9a4ffe1c545648e7557d44e1b469b4df260" translate="yes" xml:space="preserve">
          <source>Once this function returns, the contents of &lt;code&gt;bufs&lt;/code&gt; are unspecified, as this depends on how many calls to &lt;a href=&quot;trait.write#method.write_vectored&quot;&gt;&lt;code&gt;write_vectored&lt;/code&gt;&lt;/a&gt; were necessary. It is best to understand this function as taking ownership of &lt;code&gt;bufs&lt;/code&gt; and to not use &lt;code&gt;bufs&lt;/code&gt; afterwards. The underlying buffers, to which the &lt;a href=&quot;struct.ioslice&quot;&gt;&lt;code&gt;IoSlice&lt;/code&gt;&lt;/a&gt;s point (but not the &lt;a href=&quot;struct.ioslice&quot;&gt;&lt;code&gt;IoSlice&lt;/code&gt;&lt;/a&gt;s themselves), are unchanged and can be reused.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0fa4b20ac7b7c2a8a0f92535a2333b6aa807706f" translate="yes" xml:space="preserve">
          <source>Once we&amp;rsquo;ve created an iterator, we can use it in a variety of ways. In Listing 3-5 in Chapter 3, we used iterators with &lt;code&gt;for&lt;/code&gt; loops to execute some code on each item, although we glossed over what the call to &lt;code&gt;iter&lt;/code&gt; did until now.</source>
          <target state="translated">После того, как мы создали итератор, мы можем использовать его различными способами. В листинге 3-5 главы 3 мы использовали итераторы с циклами &lt;code&gt;for&lt;/code&gt; для выполнения некоторого кода для каждого элемента, хотя до сих пор мы не освещали то, что делал вызов &lt;code&gt;iter&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="58851a1903858c976f2730a714ae3f3f46765304" translate="yes" xml:space="preserve">
          <source>Once we&amp;rsquo;ve implemented the &lt;code&gt;Iterator&lt;/code&gt; trait, we have an iterator! Listing 13-22 shows a test demonstrating that we can use the iterator functionality of our &lt;code&gt;Counter&lt;/code&gt; struct by calling the &lt;code&gt;next&lt;/code&gt; method on it directly, just as we did with the iterator created from a vector in Listing 13-15.</source>
          <target state="translated">Как только мы реализовали &lt;code&gt;Iterator&lt;/code&gt; , у нас есть итератор! В листинге 13-22 показан тест, демонстрирующий, что мы можем использовать функциональные возможности итератора нашей структуры &lt;code&gt;Counter&lt;/code&gt; , напрямую вызывая на ней &lt;code&gt;next&lt;/code&gt; метод, точно так же, как мы это делали с итератором, созданным из вектора в листинге 13-15.</target>
        </trans-unit>
        <trans-unit id="84bcbd885f09e288fb3013478b1c1b345aab434e" translate="yes" xml:space="preserve">
          <source>Once you are familiar with the contents of the standard library you may begin to find the verbosity of the prose distracting. At this stage in your development you may want to press the &lt;code&gt;[-]&lt;/code&gt; button near the top of the page to collapse it into a more skimmable view.</source>
          <target state="translated">Как только вы ознакомитесь с содержимым стандартной библиотеки, вы, возможно, начнете находить, что многословие прозы отвлекает. На этом этапе разработки вы можете нажать кнопку &lt;code&gt;[-]&lt;/code&gt; в верхней части страницы, чтобы свернуть ее в более удобное для просмотра изображение.</target>
        </trans-unit>
        <trans-unit id="f9e4ff73fcbf2b9b71b1855afa48c76c6aa49139" translate="yes" xml:space="preserve">
          <source>Once you have the kind of slice you need (with or without a nul terminator), you can call the slice's own &lt;a href=&quot;../primitive.slice#method.as_ptr&quot;&gt;&lt;code&gt;as_ptr&lt;/code&gt;&lt;/a&gt; method to get a read-only raw pointer to pass to extern functions. See the documentation for that function for a discussion on ensuring the lifetime of the raw pointer.</source>
          <target state="translated">Как только у вас есть нужный вам фрагмент (с нулевым терминатором или без него), вы можете вызвать собственный метод &lt;a href=&quot;../primitive.slice#method.as_ptr&quot;&gt; &lt;code&gt;as_ptr&lt;/code&gt; фрагмента,&lt;/a&gt; чтобы получить доступный только для чтения необработанный указатель для перехода к внешним функциям. См. Документацию по этой функции для обсуждения обеспечения времени жизни необработанного указателя.</target>
        </trans-unit>
        <trans-unit id="ef776c26c7f6b2f89aaf4c349afba29be9ab2040" translate="yes" xml:space="preserve">
          <source>Once::all</source>
          <target state="translated">Once::all</target>
        </trans-unit>
        <trans-unit id="fa85c00dce196844734611fc55302ba498cdda9b" translate="yes" xml:space="preserve">
          <source>Once::any</source>
          <target state="translated">Once::any</target>
        </trans-unit>
        <trans-unit id="826f1ec43224196e7c0e18a9f4c8ba3d03de27f1" translate="yes" xml:space="preserve">
          <source>Once::borrow</source>
          <target state="translated">Once::borrow</target>
        </trans-unit>
        <trans-unit id="e53e91b8fe24cb0570a1a97b3316a02ec5d3ee03" translate="yes" xml:space="preserve">
          <source>Once::borrow_mut</source>
          <target state="translated">Once::borrow_mut</target>
        </trans-unit>
        <trans-unit id="c2f8e8374534fd9f5e2ff592398a6ffc6014fd99" translate="yes" xml:space="preserve">
          <source>Once::by_ref</source>
          <target state="translated">Once::by_ref</target>
        </trans-unit>
        <trans-unit id="28a72e0c985bccd2edce22b1340d3ed027a4ac1f" translate="yes" xml:space="preserve">
          <source>Once::call_once</source>
          <target state="translated">Once::call_once</target>
        </trans-unit>
        <trans-unit id="e0cfc1e91951cfca51a0190fd8a21d0b035190a9" translate="yes" xml:space="preserve">
          <source>Once::call_once_force</source>
          <target state="translated">Once::call_once_force</target>
        </trans-unit>
        <trans-unit id="1376857cb86f72af6eff74ad397cf00fcde6210e" translate="yes" xml:space="preserve">
          <source>Once::chain</source>
          <target state="translated">Once::chain</target>
        </trans-unit>
        <trans-unit id="190ff92b2c593bf6e13bca7abde87e505a3ec2bb" translate="yes" xml:space="preserve">
          <source>Once::clone</source>
          <target state="translated">Once::clone</target>
        </trans-unit>
        <trans-unit id="212f098b1763e1e51ae7f7bc19ffa302ddfe30a1" translate="yes" xml:space="preserve">
          <source>Once::clone_from</source>
          <target state="translated">Once::clone_from</target>
        </trans-unit>
        <trans-unit id="311f7aa02f0a54433f61dae481c3b3e4040d2495" translate="yes" xml:space="preserve">
          <source>Once::clone_into</source>
          <target state="translated">Once::clone_into</target>
        </trans-unit>
        <trans-unit id="19afa196b08d6f8f3b6f43f40d2d7cd3c50fbc8f" translate="yes" xml:space="preserve">
          <source>Once::cloned</source>
          <target state="translated">Once::cloned</target>
        </trans-unit>
        <trans-unit id="6b4930ea79c81962eae48dcaf70c7227f1aa12a7" translate="yes" xml:space="preserve">
          <source>Once::cmp</source>
          <target state="translated">Once::cmp</target>
        </trans-unit>
        <trans-unit id="5d169980cad74ac2c6880808ed94fb787b98960a" translate="yes" xml:space="preserve">
          <source>Once::collect</source>
          <target state="translated">Once::collect</target>
        </trans-unit>
        <trans-unit id="313d94ea32a51b1b516cb8b52850728efe9ae8b5" translate="yes" xml:space="preserve">
          <source>Once::copied</source>
          <target state="translated">Once::copied</target>
        </trans-unit>
        <trans-unit id="f98560cce6e4eadc3911ce81d61f52d107ea5142" translate="yes" xml:space="preserve">
          <source>Once::count</source>
          <target state="translated">Once::count</target>
        </trans-unit>
        <trans-unit id="2ef6bd0928aad3dcaf46fb7f0bdafb3492745ec4" translate="yes" xml:space="preserve">
          <source>Once::cycle</source>
          <target state="translated">Once::cycle</target>
        </trans-unit>
        <trans-unit id="8ad5b4150f82970fff0038e17ac64a51521d1924" translate="yes" xml:space="preserve">
          <source>Once::enumerate</source>
          <target state="translated">Once::enumerate</target>
        </trans-unit>
        <trans-unit id="23c903ad536fa2bd73035fce46787048ed4f628a" translate="yes" xml:space="preserve">
          <source>Once::eq</source>
          <target state="translated">Once::eq</target>
        </trans-unit>
        <trans-unit id="82879e4fcf39171c09b466e2bf43bc8f45af6822" translate="yes" xml:space="preserve">
          <source>Once::filter</source>
          <target state="translated">Once::filter</target>
        </trans-unit>
        <trans-unit id="095605951ca140555bd59e4149308c63f272478d" translate="yes" xml:space="preserve">
          <source>Once::filter_map</source>
          <target state="translated">Once::filter_map</target>
        </trans-unit>
        <trans-unit id="7ca070326207c327aa1bb557f657f2fac61b1c8a" translate="yes" xml:space="preserve">
          <source>Once::find</source>
          <target state="translated">Once::find</target>
        </trans-unit>
        <trans-unit id="f8cbae0491d42da2ee0b9caaa6d41cbeef0233e4" translate="yes" xml:space="preserve">
          <source>Once::find_map</source>
          <target state="translated">Once::find_map</target>
        </trans-unit>
        <trans-unit id="8f0358e16d2477b8dc5e572ca1dae6005b455b17" translate="yes" xml:space="preserve">
          <source>Once::flat_map</source>
          <target state="translated">Once::flat_map</target>
        </trans-unit>
        <trans-unit id="8580b5a613c1d1f4df99cede210bdc2e9fe3a843" translate="yes" xml:space="preserve">
          <source>Once::flatten</source>
          <target state="translated">Once::flatten</target>
        </trans-unit>
        <trans-unit id="c9a403b6a5f9f7ce825a2ce8e6b8fc78c53b4261" translate="yes" xml:space="preserve">
          <source>Once::fmt</source>
          <target state="translated">Once::fmt</target>
        </trans-unit>
        <trans-unit id="a4dbe0ef075896956284d0f6da5e3cf48dd08238" translate="yes" xml:space="preserve">
          <source>Once::fold</source>
          <target state="translated">Once::fold</target>
        </trans-unit>
        <trans-unit id="9129023999880ed84891680b4f8fd96dda590894" translate="yes" xml:space="preserve">
          <source>Once::for_each</source>
          <target state="translated">Once::for_each</target>
        </trans-unit>
        <trans-unit id="d64f18e6780e0faf671ed9d539a0b268b8174066" translate="yes" xml:space="preserve">
          <source>Once::from</source>
          <target state="translated">Once::from</target>
        </trans-unit>
        <trans-unit id="bbf7ace21ce049891d14dd08bdb7b81831f05411" translate="yes" xml:space="preserve">
          <source>Once::fuse</source>
          <target state="translated">Once::fuse</target>
        </trans-unit>
        <trans-unit id="6d843124e3a2669cb3c40cac626394b00fbd78a9" translate="yes" xml:space="preserve">
          <source>Once::ge</source>
          <target state="translated">Once::ge</target>
        </trans-unit>
        <trans-unit id="a9af56769b34f56c5ffcf89a8ea47ff768c6858a" translate="yes" xml:space="preserve">
          <source>Once::gt</source>
          <target state="translated">Once::gt</target>
        </trans-unit>
        <trans-unit id="52b97e5420ac6c5141f11b243b00d6a1d91a82aa" translate="yes" xml:space="preserve">
          <source>Once::inspect</source>
          <target state="translated">Once::inspect</target>
        </trans-unit>
        <trans-unit id="24c9670c06579750ad91802403773c861f00f73c" translate="yes" xml:space="preserve">
          <source>Once::into</source>
          <target state="translated">Once::into</target>
        </trans-unit>
        <trans-unit id="efb0afcea9cf69ad9f300407891f7cf24889abde" translate="yes" xml:space="preserve">
          <source>Once::into_iter</source>
          <target state="translated">Once::into_iter</target>
        </trans-unit>
        <trans-unit id="0608fd7f8eac14cce16ca80dbfd5613b14204122" translate="yes" xml:space="preserve">
          <source>Once::is_completed</source>
          <target state="translated">Once::is_completed</target>
        </trans-unit>
        <trans-unit id="7251c3dcf49fe3c4c5830d926dcb3f340b9a4518" translate="yes" xml:space="preserve">
          <source>Once::is_empty</source>
          <target state="translated">Once::is_empty</target>
        </trans-unit>
        <trans-unit id="4b0fbfe12c4a015929a04dd53407a0499a03410c" translate="yes" xml:space="preserve">
          <source>Once::is_sorted</source>
          <target state="translated">Once::is_sorted</target>
        </trans-unit>
        <trans-unit id="6f25e0f3331d93f4e5eb47652d49ab83abddd5c6" translate="yes" xml:space="preserve">
          <source>Once::is_sorted_by</source>
          <target state="translated">Once::is_sorted_by</target>
        </trans-unit>
        <trans-unit id="cb7a1da6af62c62d1c48e6f892b45246ff8fb722" translate="yes" xml:space="preserve">
          <source>Once::is_sorted_by_key</source>
          <target state="translated">Once::is_sorted_by_key</target>
        </trans-unit>
        <trans-unit id="12b8716333449d7ef6ccc84a866d8c71f4d4596a" translate="yes" xml:space="preserve">
          <source>Once::last</source>
          <target state="translated">Once::last</target>
        </trans-unit>
        <trans-unit id="14b21ec5ab3251444e0715d08a995824bf98046f" translate="yes" xml:space="preserve">
          <source>Once::le</source>
          <target state="translated">Once::le</target>
        </trans-unit>
        <trans-unit id="c7ec127a76b81f92cbddfa60f7e443869f07dfc3" translate="yes" xml:space="preserve">
          <source>Once::len</source>
          <target state="translated">Once::len</target>
        </trans-unit>
        <trans-unit id="5200802a32d08edabd28e77c8bfacda66faabb5f" translate="yes" xml:space="preserve">
          <source>Once::lt</source>
          <target state="translated">Once::lt</target>
        </trans-unit>
        <trans-unit id="f2976b7d4debc6f0c6faff19e72feb23c6da98c9" translate="yes" xml:space="preserve">
          <source>Once::map</source>
          <target state="translated">Once::map</target>
        </trans-unit>
        <trans-unit id="37c43ed9043bf5a1d86c776c7a83980f8e44b550" translate="yes" xml:space="preserve">
          <source>Once::max</source>
          <target state="translated">Once::max</target>
        </trans-unit>
        <trans-unit id="42f687a90cb8ae799fc923fe98bf332780e16e1a" translate="yes" xml:space="preserve">
          <source>Once::max_by</source>
          <target state="translated">Once::max_by</target>
        </trans-unit>
        <trans-unit id="f790fae0c1ab8520d2b3bb6dee8c10e0df61fb21" translate="yes" xml:space="preserve">
          <source>Once::max_by_key</source>
          <target state="translated">Once::max_by_key</target>
        </trans-unit>
        <trans-unit id="be86a53ca110f0c0f2e5f786db25770b11e8fb89" translate="yes" xml:space="preserve">
          <source>Once::min</source>
          <target state="translated">Once::min</target>
        </trans-unit>
        <trans-unit id="5b4c2bfd34d4ce8913a24cdbba40c903c58ba228" translate="yes" xml:space="preserve">
          <source>Once::min_by</source>
          <target state="translated">Once::min_by</target>
        </trans-unit>
        <trans-unit id="0ff4bd1f1edb9d1e53ee61824c45a6b65f4eafd0" translate="yes" xml:space="preserve">
          <source>Once::min_by_key</source>
          <target state="translated">Once::min_by_key</target>
        </trans-unit>
        <trans-unit id="6236fe088142c957857770ab09a2b6fc2f27b69e" translate="yes" xml:space="preserve">
          <source>Once::ne</source>
          <target state="translated">Once::ne</target>
        </trans-unit>
        <trans-unit id="7d6911dda1f2483e209159a8e136b2c52051e6bb" translate="yes" xml:space="preserve">
          <source>Once::new</source>
          <target state="translated">Once::new</target>
        </trans-unit>
        <trans-unit id="578bd116c5e7fde5716979b05be2a783abe2fcec" translate="yes" xml:space="preserve">
          <source>Once::next</source>
          <target state="translated">Once::next</target>
        </trans-unit>
        <trans-unit id="8af821c9e317f67614d97739eed7d7394a46629b" translate="yes" xml:space="preserve">
          <source>Once::next_back</source>
          <target state="translated">Once::next_back</target>
        </trans-unit>
        <trans-unit id="430bb3482a938ef6cd7fe977041d4fa3bbc1fc55" translate="yes" xml:space="preserve">
          <source>Once::nth</source>
          <target state="translated">Once::nth</target>
        </trans-unit>
        <trans-unit id="c55b0c5a25d6a4c7729b67045964bd182f6c743b" translate="yes" xml:space="preserve">
          <source>Once::nth_back</source>
          <target state="translated">Once::nth_back</target>
        </trans-unit>
        <trans-unit id="22c36618829e3a03fdefff9bbca40dbd8e473846" translate="yes" xml:space="preserve">
          <source>Once::partial_cmp</source>
          <target state="translated">Once::partial_cmp</target>
        </trans-unit>
        <trans-unit id="b7269ba05ed7753f4b47e7a0b54fad46c7fdfa25" translate="yes" xml:space="preserve">
          <source>Once::partition</source>
          <target state="translated">Once::partition</target>
        </trans-unit>
        <trans-unit id="a2a93318d906b75ba7d478b7d2053f09b5d47c8e" translate="yes" xml:space="preserve">
          <source>Once::peekable</source>
          <target state="translated">Once::peekable</target>
        </trans-unit>
        <trans-unit id="443ba5a518af1ceeeb00165b521452d07ea04e5b" translate="yes" xml:space="preserve">
          <source>Once::position</source>
          <target state="translated">Once::position</target>
        </trans-unit>
        <trans-unit id="aefb04c2392cc211f451d367f733cc6c65c3e11b" translate="yes" xml:space="preserve">
          <source>Once::product</source>
          <target state="translated">Once::product</target>
        </trans-unit>
        <trans-unit id="0bc9c08f73c34cac78d945ebc22d8397bbb66131" translate="yes" xml:space="preserve">
          <source>Once::rev</source>
          <target state="translated">Once::rev</target>
        </trans-unit>
        <trans-unit id="3c7856aff7c1c10689eb91760b905ac36a86fd8f" translate="yes" xml:space="preserve">
          <source>Once::rfind</source>
          <target state="translated">Once::rfind</target>
        </trans-unit>
        <trans-unit id="bb98b537fa90b815cfad245be9b6f8a9980c10ad" translate="yes" xml:space="preserve">
          <source>Once::rfold</source>
          <target state="translated">Once::rfold</target>
        </trans-unit>
        <trans-unit id="068dbc2b0446d02924974dc89dc2e5c0506be3c0" translate="yes" xml:space="preserve">
          <source>Once::rposition</source>
          <target state="translated">Once::rposition</target>
        </trans-unit>
        <trans-unit id="2f7d42081a9a3b1a18973e17303b804987f7c991" translate="yes" xml:space="preserve">
          <source>Once::scan</source>
          <target state="translated">Once::scan</target>
        </trans-unit>
        <trans-unit id="689e357b41f0be20a1862814b9c83d77ef8f1e70" translate="yes" xml:space="preserve">
          <source>Once::size_hint</source>
          <target state="translated">Once::size_hint</target>
        </trans-unit>
        <trans-unit id="cbf339d38d49468cb345d7cfb9cb77b78f365fd1" translate="yes" xml:space="preserve">
          <source>Once::skip</source>
          <target state="translated">Once::skip</target>
        </trans-unit>
        <trans-unit id="86fd91a24a1bbc66ca2ece695858498a65db16dd" translate="yes" xml:space="preserve">
          <source>Once::skip_while</source>
          <target state="translated">Once::skip_while</target>
        </trans-unit>
        <trans-unit id="6fe0f81f7153271dc977040947a6cad61882f9d1" translate="yes" xml:space="preserve">
          <source>Once::step_by</source>
          <target state="translated">Once::step_by</target>
        </trans-unit>
        <trans-unit id="033b2578f1615ee184814d95335d5fd74302c231" translate="yes" xml:space="preserve">
          <source>Once::sum</source>
          <target state="translated">Once::sum</target>
        </trans-unit>
        <trans-unit id="442e2927616d29972c328197ab646af0a109e0ac" translate="yes" xml:space="preserve">
          <source>Once::take</source>
          <target state="translated">Once::take</target>
        </trans-unit>
        <trans-unit id="e0055054cf1a45bf179b412f905b6b7b804fe427" translate="yes" xml:space="preserve">
          <source>Once::take_while</source>
          <target state="translated">Once::take_while</target>
        </trans-unit>
        <trans-unit id="1ff7fdb84e0ce09813e50c320654790d32c718fe" translate="yes" xml:space="preserve">
          <source>Once::to_owned</source>
          <target state="translated">Once::to_owned</target>
        </trans-unit>
        <trans-unit id="b045ee709dc7ad89b9c21500aecbcde1537d7e58" translate="yes" xml:space="preserve">
          <source>Once::try_fold</source>
          <target state="translated">Once::try_fold</target>
        </trans-unit>
        <trans-unit id="ca7011c5d5b35881f4391164193c191f7c91a8ed" translate="yes" xml:space="preserve">
          <source>Once::try_for_each</source>
          <target state="translated">Once::try_for_each</target>
        </trans-unit>
        <trans-unit id="145392f846fa35a3754a9cdb737cf3389c9b3bb1" translate="yes" xml:space="preserve">
          <source>Once::try_from</source>
          <target state="translated">Once::try_from</target>
        </trans-unit>
        <trans-unit id="36d585158ca953d0dbbe69c61419f1e9cfd5cbd0" translate="yes" xml:space="preserve">
          <source>Once::try_into</source>
          <target state="translated">Once::try_into</target>
        </trans-unit>
        <trans-unit id="bb47966988d0ea30157cfc9b32edfc0454ef3340" translate="yes" xml:space="preserve">
          <source>Once::try_rfold</source>
          <target state="translated">Once::try_rfold</target>
        </trans-unit>
        <trans-unit id="0e7005b30f23dbe8e521fbb090487b02e260839e" translate="yes" xml:space="preserve">
          <source>Once::type_id</source>
          <target state="translated">Once::type_id</target>
        </trans-unit>
        <trans-unit id="89b4b7dbbcd40342a9b06361de2f912cf9887391" translate="yes" xml:space="preserve">
          <source>Once::unzip</source>
          <target state="translated">Once::unzip</target>
        </trans-unit>
        <trans-unit id="9c587dbc5b4ada9eb96816888453bd9099854f2c" translate="yes" xml:space="preserve">
          <source>Once::zip</source>
          <target state="translated">Once::zip</target>
        </trans-unit>
        <trans-unit id="69dcb4de79e8a81381a0466b75f257a36ecf89cd" translate="yes" xml:space="preserve">
          <source>OnceCell</source>
          <target state="translated">OnceCell</target>
        </trans-unit>
        <trans-unit id="2db71cb543a4836972aba340022bf66c34ca9483" translate="yes" xml:space="preserve">
          <source>OnceState</source>
          <target state="translated">OnceState</target>
        </trans-unit>
        <trans-unit id="864b2494c0a17291fe44802d2dfa7280c6515a58" translate="yes" xml:space="preserve">
          <source>OnceState::borrow</source>
          <target state="translated">OnceState::borrow</target>
        </trans-unit>
        <trans-unit id="3ba03425574355acef161a03b37753e3dc3fce0d" translate="yes" xml:space="preserve">
          <source>OnceState::borrow_mut</source>
          <target state="translated">OnceState::borrow_mut</target>
        </trans-unit>
        <trans-unit id="137f612918b3ff9f01b5b2eed8a892cbbde080f1" translate="yes" xml:space="preserve">
          <source>OnceState::fmt</source>
          <target state="translated">OnceState::fmt</target>
        </trans-unit>
        <trans-unit id="cc9d74ec28c33e153d2d0894a6de5f14c5c9aabd" translate="yes" xml:space="preserve">
          <source>OnceState::from</source>
          <target state="translated">OnceState::from</target>
        </trans-unit>
        <trans-unit id="d968db4b631f42cce77d0ea2bff8656be4e57c06" translate="yes" xml:space="preserve">
          <source>OnceState::into</source>
          <target state="translated">OnceState::into</target>
        </trans-unit>
        <trans-unit id="5279da3ce88f5a2ebd344f9b9ae566f2cb009268" translate="yes" xml:space="preserve">
          <source>OnceState::poisoned</source>
          <target state="translated">OnceState::poisoned</target>
        </trans-unit>
        <trans-unit id="8447bc72e127b3443efef418a2e8188e3cc3f620" translate="yes" xml:space="preserve">
          <source>OnceState::try_from</source>
          <target state="translated">OnceState::try_from</target>
        </trans-unit>
        <trans-unit id="2a35fc55239b76803a74ad10688fe793f6102501" translate="yes" xml:space="preserve">
          <source>OnceState::try_into</source>
          <target state="translated">OnceState::try_into</target>
        </trans-unit>
        <trans-unit id="fcd8d541e6822fd809940974bebc8a81f8b16c8d" translate="yes" xml:space="preserve">
          <source>OnceState::type_id</source>
          <target state="translated">OnceState::type_id</target>
        </trans-unit>
        <trans-unit id="bac414ebd5a08ef0bd8f0f09a9b6b081da1540b4" translate="yes" xml:space="preserve">
          <source>OnceWith</source>
          <target state="translated">OnceWith</target>
        </trans-unit>
        <trans-unit id="9421b02fba334e65b31591c89d7fcfa34aea5e57" translate="yes" xml:space="preserve">
          <source>OnceWith::all</source>
          <target state="translated">OnceWith::all</target>
        </trans-unit>
        <trans-unit id="ec045f959571abb529fe845ffb143c5aa440d98a" translate="yes" xml:space="preserve">
          <source>OnceWith::any</source>
          <target state="translated">OnceWith::any</target>
        </trans-unit>
        <trans-unit id="1ef37dd0c57f299c431f6fc7296ed50225f08e1a" translate="yes" xml:space="preserve">
          <source>OnceWith::borrow</source>
          <target state="translated">OnceWith::borrow</target>
        </trans-unit>
        <trans-unit id="527f129227b962c7154dfbbc8fa56239753273a3" translate="yes" xml:space="preserve">
          <source>OnceWith::borrow_mut</source>
          <target state="translated">OnceWith::borrow_mut</target>
        </trans-unit>
        <trans-unit id="220386db15c3ac797f2d78a1fa6328e0e524bbaa" translate="yes" xml:space="preserve">
          <source>OnceWith::by_ref</source>
          <target state="translated">OnceWith::by_ref</target>
        </trans-unit>
        <trans-unit id="8cca4e55ae50dd0aee68afe79ea244d5bca99ced" translate="yes" xml:space="preserve">
          <source>OnceWith::chain</source>
          <target state="translated">OnceWith::chain</target>
        </trans-unit>
        <trans-unit id="69a3e8d814785ab85c33556c6a099c9cc6ea940e" translate="yes" xml:space="preserve">
          <source>OnceWith::clone</source>
          <target state="translated">OnceWith::clone</target>
        </trans-unit>
        <trans-unit id="18ada5e17d413555745065a07348ed90106c203d" translate="yes" xml:space="preserve">
          <source>OnceWith::clone_from</source>
          <target state="translated">OnceWith::clone_from</target>
        </trans-unit>
        <trans-unit id="840d6af9e9dfbf237e7af2ccf27dbd5ad69cee46" translate="yes" xml:space="preserve">
          <source>OnceWith::clone_into</source>
          <target state="translated">OnceWith::clone_into</target>
        </trans-unit>
        <trans-unit id="28fb35fd1901c33eee7b84b451b7753c7c867260" translate="yes" xml:space="preserve">
          <source>OnceWith::cloned</source>
          <target state="translated">OnceWith::cloned</target>
        </trans-unit>
        <trans-unit id="30d119dee0d9c070c3e61005d6831099ce8bd793" translate="yes" xml:space="preserve">
          <source>OnceWith::cmp</source>
          <target state="translated">OnceWith::cmp</target>
        </trans-unit>
        <trans-unit id="abe9447efe3162bb1b99fa4be3a78e85a49dc04b" translate="yes" xml:space="preserve">
          <source>OnceWith::collect</source>
          <target state="translated">OnceWith::collect</target>
        </trans-unit>
        <trans-unit id="4d6da14365d0d73a28c1b23f782a042915618b92" translate="yes" xml:space="preserve">
          <source>OnceWith::copied</source>
          <target state="translated">OnceWith::copied</target>
        </trans-unit>
        <trans-unit id="7016f9903cc220eec1b3d930f0d6d91062934899" translate="yes" xml:space="preserve">
          <source>OnceWith::count</source>
          <target state="translated">OnceWith::count</target>
        </trans-unit>
        <trans-unit id="addfc373b9df5fc305b9e5e6eb635cd2466d07d4" translate="yes" xml:space="preserve">
          <source>OnceWith::cycle</source>
          <target state="translated">OnceWith::cycle</target>
        </trans-unit>
        <trans-unit id="095f0dc0c2b642b81131fb698197ca6766b54a2e" translate="yes" xml:space="preserve">
          <source>OnceWith::enumerate</source>
          <target state="translated">OnceWith::enumerate</target>
        </trans-unit>
        <trans-unit id="7e9ec613a8f6c55d8eb6ea553ee7ebd7e6244ce6" translate="yes" xml:space="preserve">
          <source>OnceWith::eq</source>
          <target state="translated">OnceWith::eq</target>
        </trans-unit>
        <trans-unit id="f3f3ad0faefd45bbd859ece3bf3eef9075759214" translate="yes" xml:space="preserve">
          <source>OnceWith::filter</source>
          <target state="translated">OnceWith::filter</target>
        </trans-unit>
        <trans-unit id="ea81115d4b00890df3a160e9b9a84ff71ded3a01" translate="yes" xml:space="preserve">
          <source>OnceWith::filter_map</source>
          <target state="translated">OnceWith::filter_map</target>
        </trans-unit>
        <trans-unit id="04462b9dd7bbda24ad2bd90e2b7883781de4acd6" translate="yes" xml:space="preserve">
          <source>OnceWith::find</source>
          <target state="translated">OnceWith::find</target>
        </trans-unit>
        <trans-unit id="aca2dee92401221e00169ab44175f018d2db65f4" translate="yes" xml:space="preserve">
          <source>OnceWith::find_map</source>
          <target state="translated">OnceWith::find_map</target>
        </trans-unit>
        <trans-unit id="10d39de4f24d2dcddb78ea6874f21fecb0e42b39" translate="yes" xml:space="preserve">
          <source>OnceWith::flat_map</source>
          <target state="translated">OnceWith::flat_map</target>
        </trans-unit>
        <trans-unit id="6ff780249f2a51d00d5d95dcfd4610dadafd2bd8" translate="yes" xml:space="preserve">
          <source>OnceWith::flatten</source>
          <target state="translated">OnceWith::flatten</target>
        </trans-unit>
        <trans-unit id="e7394a8ea887cd043223fc687a97cc1f193256c1" translate="yes" xml:space="preserve">
          <source>OnceWith::fmt</source>
          <target state="translated">OnceWith::fmt</target>
        </trans-unit>
        <trans-unit id="5e004a4ea95a589f773f9befbef25abe72f46ba2" translate="yes" xml:space="preserve">
          <source>OnceWith::fold</source>
          <target state="translated">OnceWith::fold</target>
        </trans-unit>
        <trans-unit id="0826514ea858174b22832240424d387a6a62a698" translate="yes" xml:space="preserve">
          <source>OnceWith::for_each</source>
          <target state="translated">OnceWith::for_each</target>
        </trans-unit>
        <trans-unit id="6f44e41130791319e6c6d5e080615570ac91fa72" translate="yes" xml:space="preserve">
          <source>OnceWith::from</source>
          <target state="translated">OnceWith::from</target>
        </trans-unit>
        <trans-unit id="d991094123caac201e372f78da1221c72316dec1" translate="yes" xml:space="preserve">
          <source>OnceWith::fuse</source>
          <target state="translated">OnceWith::fuse</target>
        </trans-unit>
        <trans-unit id="491865c492a9358b9d74d7461f65fbb3c2ad3116" translate="yes" xml:space="preserve">
          <source>OnceWith::ge</source>
          <target state="translated">OnceWith::ge</target>
        </trans-unit>
        <trans-unit id="cb6cb84ba3cef039e288bea61f9e271654ca16b3" translate="yes" xml:space="preserve">
          <source>OnceWith::gt</source>
          <target state="translated">OnceWith::gt</target>
        </trans-unit>
        <trans-unit id="f9bca0dbc5eb1308057e3acda537f87ae5584bf0" translate="yes" xml:space="preserve">
          <source>OnceWith::inspect</source>
          <target state="translated">OnceWith::inspect</target>
        </trans-unit>
        <trans-unit id="130c0779f2fab716215af75fb82426f43a016224" translate="yes" xml:space="preserve">
          <source>OnceWith::into</source>
          <target state="translated">OnceWith::into</target>
        </trans-unit>
        <trans-unit id="e53104deb8174e788d926bdbaa53ed5840ec7390" translate="yes" xml:space="preserve">
          <source>OnceWith::into_iter</source>
          <target state="translated">OnceWith::into_iter</target>
        </trans-unit>
        <trans-unit id="57fb266c4456dcf8194282f31a9c9693a675f52f" translate="yes" xml:space="preserve">
          <source>OnceWith::is_empty</source>
          <target state="translated">OnceWith::is_empty</target>
        </trans-unit>
        <trans-unit id="35067e17a5dc55a4bb918b85dcd10ca948035cb7" translate="yes" xml:space="preserve">
          <source>OnceWith::is_sorted</source>
          <target state="translated">OnceWith::is_sorted</target>
        </trans-unit>
        <trans-unit id="fa54dbd797d14264ee865bf4783d41bbaaceb9bb" translate="yes" xml:space="preserve">
          <source>OnceWith::is_sorted_by</source>
          <target state="translated">OnceWith::is_sorted_by</target>
        </trans-unit>
        <trans-unit id="0805f33825aaffa765bd319b5f5123f28e25c541" translate="yes" xml:space="preserve">
          <source>OnceWith::is_sorted_by_key</source>
          <target state="translated">OnceWith::is_sorted_by_key</target>
        </trans-unit>
        <trans-unit id="b8642e0e6fa2a743b75cee962cacad7d55075240" translate="yes" xml:space="preserve">
          <source>OnceWith::last</source>
          <target state="translated">OnceWith::last</target>
        </trans-unit>
        <trans-unit id="93fa8fd9eba96e349d5cb407b64fe72f152eb5a8" translate="yes" xml:space="preserve">
          <source>OnceWith::le</source>
          <target state="translated">OnceWith::le</target>
        </trans-unit>
        <trans-unit id="7222c5552e670e1ab40e927a15a3bb3893a18137" translate="yes" xml:space="preserve">
          <source>OnceWith::len</source>
          <target state="translated">OnceWith::len</target>
        </trans-unit>
        <trans-unit id="115bc72442e41419d2748702b3dc2105c1045ca1" translate="yes" xml:space="preserve">
          <source>OnceWith::lt</source>
          <target state="translated">OnceWith::lt</target>
        </trans-unit>
        <trans-unit id="4a5a3ea857244c9e36891ebf8831e5ae98613302" translate="yes" xml:space="preserve">
          <source>OnceWith::map</source>
          <target state="translated">OnceWith::map</target>
        </trans-unit>
        <trans-unit id="e13117c44b319bc7f0f9709faa2a5544da1bccc4" translate="yes" xml:space="preserve">
          <source>OnceWith::max</source>
          <target state="translated">OnceWith::max</target>
        </trans-unit>
        <trans-unit id="5fe974dd4baeb92c36de177f1091466a40a950e9" translate="yes" xml:space="preserve">
          <source>OnceWith::max_by</source>
          <target state="translated">OnceWith::max_by</target>
        </trans-unit>
        <trans-unit id="4bced0b61c3c1cb8410f882718a68a33aeae5a9b" translate="yes" xml:space="preserve">
          <source>OnceWith::max_by_key</source>
          <target state="translated">OnceWith::max_by_key</target>
        </trans-unit>
        <trans-unit id="06568f09e719a331a84ceae60f4b66de6e9d0ea4" translate="yes" xml:space="preserve">
          <source>OnceWith::min</source>
          <target state="translated">OnceWith::min</target>
        </trans-unit>
        <trans-unit id="286481980c2d0b526534de52416aa1cce0683996" translate="yes" xml:space="preserve">
          <source>OnceWith::min_by</source>
          <target state="translated">OnceWith::min_by</target>
        </trans-unit>
        <trans-unit id="5dd37a258caeec2b0eb6451dca8a726b836a9a92" translate="yes" xml:space="preserve">
          <source>OnceWith::min_by_key</source>
          <target state="translated">OnceWith::min_by_key</target>
        </trans-unit>
        <trans-unit id="69f93b3a318af71379ddca4ec93fe8d140ce5f0f" translate="yes" xml:space="preserve">
          <source>OnceWith::ne</source>
          <target state="translated">OnceWith::ne</target>
        </trans-unit>
        <trans-unit id="ac26f725cccaf1526e5014347f9adea936f74ce7" translate="yes" xml:space="preserve">
          <source>OnceWith::next</source>
          <target state="translated">OnceWith::next</target>
        </trans-unit>
        <trans-unit id="e4330c855cf5f92fc7584c51cdee41319443487c" translate="yes" xml:space="preserve">
          <source>OnceWith::next_back</source>
          <target state="translated">OnceWith::next_back</target>
        </trans-unit>
        <trans-unit id="1527b9229bda86674b9d9102f7590dba88349ecd" translate="yes" xml:space="preserve">
          <source>OnceWith::nth</source>
          <target state="translated">OnceWith::nth</target>
        </trans-unit>
        <trans-unit id="52e0f2df5caf846213c666b22fff6456cda8a68f" translate="yes" xml:space="preserve">
          <source>OnceWith::nth_back</source>
          <target state="translated">OnceWith::nth_back</target>
        </trans-unit>
        <trans-unit id="2d124bbf09c7f2b80ff84f088c67f3f07ae5780b" translate="yes" xml:space="preserve">
          <source>OnceWith::partial_cmp</source>
          <target state="translated">OnceWith::partial_cmp</target>
        </trans-unit>
        <trans-unit id="cabc7165c7c9b316158511856e73e51b4305e89b" translate="yes" xml:space="preserve">
          <source>OnceWith::partition</source>
          <target state="translated">OnceWith::partition</target>
        </trans-unit>
        <trans-unit id="1cda021009cce16eced253abaf1a3a1b11566d18" translate="yes" xml:space="preserve">
          <source>OnceWith::peekable</source>
          <target state="translated">OnceWith::peekable</target>
        </trans-unit>
        <trans-unit id="03590b6367dd3bb1ba4d65b39afee2b09ca08df1" translate="yes" xml:space="preserve">
          <source>OnceWith::position</source>
          <target state="translated">OnceWith::position</target>
        </trans-unit>
        <trans-unit id="e1735abbbee6972dc130e89d570fd8fa919407fe" translate="yes" xml:space="preserve">
          <source>OnceWith::product</source>
          <target state="translated">OnceWith::product</target>
        </trans-unit>
        <trans-unit id="ec925c93a26e2eadc7d07e055f695e74c83d4c23" translate="yes" xml:space="preserve">
          <source>OnceWith::rev</source>
          <target state="translated">OnceWith::rev</target>
        </trans-unit>
        <trans-unit id="6243776ef017e4a1cf3d502a3968703e2ab8d6ed" translate="yes" xml:space="preserve">
          <source>OnceWith::rfind</source>
          <target state="translated">OnceWith::rfind</target>
        </trans-unit>
        <trans-unit id="aea12fd7d31659bccdee8c41ecdb4fb0f15444db" translate="yes" xml:space="preserve">
          <source>OnceWith::rfold</source>
          <target state="translated">OnceWith::rfold</target>
        </trans-unit>
        <trans-unit id="0c9e294cb61289d08c63ceca07aff5dfaea0261e" translate="yes" xml:space="preserve">
          <source>OnceWith::rposition</source>
          <target state="translated">OnceWith::rposition</target>
        </trans-unit>
        <trans-unit id="cef9b43e5eedf9af103faef7b1bbe4d12db9ab2f" translate="yes" xml:space="preserve">
          <source>OnceWith::scan</source>
          <target state="translated">OnceWith::scan</target>
        </trans-unit>
        <trans-unit id="cc6e5c82263a6bf9a575956ff17a327f6e8e1a12" translate="yes" xml:space="preserve">
          <source>OnceWith::size_hint</source>
          <target state="translated">OnceWith::size_hint</target>
        </trans-unit>
        <trans-unit id="eb30275a1bfcdf9e0075819a60e55de8140da973" translate="yes" xml:space="preserve">
          <source>OnceWith::skip</source>
          <target state="translated">OnceWith::skip</target>
        </trans-unit>
        <trans-unit id="d51df4ad9879230eee4b7d1f410130e26dd6a97e" translate="yes" xml:space="preserve">
          <source>OnceWith::skip_while</source>
          <target state="translated">OnceWith::skip_while</target>
        </trans-unit>
        <trans-unit id="13b1461f738d3541f7f825bf588919136b55d36d" translate="yes" xml:space="preserve">
          <source>OnceWith::step_by</source>
          <target state="translated">OnceWith::step_by</target>
        </trans-unit>
        <trans-unit id="74e43ad0cf8bc22a5af2d491f032ca5523c1d7b0" translate="yes" xml:space="preserve">
          <source>OnceWith::sum</source>
          <target state="translated">OnceWith::sum</target>
        </trans-unit>
        <trans-unit id="89cc6b13712f2c2ac536c3feb4e1809f1a6b5cc2" translate="yes" xml:space="preserve">
          <source>OnceWith::take</source>
          <target state="translated">OnceWith::take</target>
        </trans-unit>
        <trans-unit id="8c2cd8a3d3dfa6e2cb6f5f270f11cddff7173ce1" translate="yes" xml:space="preserve">
          <source>OnceWith::take_while</source>
          <target state="translated">OnceWith::take_while</target>
        </trans-unit>
        <trans-unit id="5a630013ba78b1577b011778f861dca34fdb6510" translate="yes" xml:space="preserve">
          <source>OnceWith::to_owned</source>
          <target state="translated">OnceWith::to_owned</target>
        </trans-unit>
        <trans-unit id="030ec595a21a12e03c641afa5fc2a0fbf3cfd96d" translate="yes" xml:space="preserve">
          <source>OnceWith::try_fold</source>
          <target state="translated">OnceWith::try_fold</target>
        </trans-unit>
        <trans-unit id="716d560ebaa2fa12887a04435f9271204fee9212" translate="yes" xml:space="preserve">
          <source>OnceWith::try_for_each</source>
          <target state="translated">OnceWith::try_for_each</target>
        </trans-unit>
        <trans-unit id="585e7e8b9f7e6990f4b13d54ca37d88a0bf70ca8" translate="yes" xml:space="preserve">
          <source>OnceWith::try_from</source>
          <target state="translated">OnceWith::try_from</target>
        </trans-unit>
        <trans-unit id="7cb93d634335cbd032ccfe91d14126a928250279" translate="yes" xml:space="preserve">
          <source>OnceWith::try_into</source>
          <target state="translated">OnceWith::try_into</target>
        </trans-unit>
        <trans-unit id="640ef41bdeff4cb6f8ee26085f02e8464a124452" translate="yes" xml:space="preserve">
          <source>OnceWith::try_rfold</source>
          <target state="translated">OnceWith::try_rfold</target>
        </trans-unit>
        <trans-unit id="100a64512cd2fe1b9fbd4ceea4850862b8f813b7" translate="yes" xml:space="preserve">
          <source>OnceWith::type_id</source>
          <target state="translated">OnceWith::type_id</target>
        </trans-unit>
        <trans-unit id="64fd105a0a6aa5f709a9477cafb3d6c01fd6cfb0" translate="yes" xml:space="preserve">
          <source>OnceWith::unzip</source>
          <target state="translated">OnceWith::unzip</target>
        </trans-unit>
        <trans-unit id="433df116ad00f74cb6d78ea83682ace23f21cb19" translate="yes" xml:space="preserve">
          <source>OnceWith::zip</source>
          <target state="translated">OnceWith::zip</target>
        </trans-unit>
        <trans-unit id="c04e60357eae6b0d2f646024db69bbf3bdb3f30b" translate="yes" xml:space="preserve">
          <source>One Rust community member, Andrew Gallant, has already created a fully featured, very fast version of &lt;code&gt;grep&lt;/code&gt;, called &lt;code&gt;ripgrep&lt;/code&gt;. By comparison, our version of &lt;code&gt;grep&lt;/code&gt; will be fairly simple, but this chapter will give you some of the background knowledge you need to understand a real-world project such as &lt;code&gt;ripgrep&lt;/code&gt;.</source>
          <target state="translated">Один из участников сообщества Rust, Эндрю Галлант, уже создал полнофункциональную, очень быструю версию &lt;code&gt;grep&lt;/code&gt; под названием &lt;code&gt;ripgrep&lt;/code&gt; . Для сравнения, наша версия &lt;code&gt;grep&lt;/code&gt; будет довольно простой, но эта глава даст вам некоторые &lt;code&gt;ripgrep&lt;/code&gt; знания, необходимые для понимания реального проекта, такого как ripgrep .</target>
        </trans-unit>
        <trans-unit id="6d8cb1de18a6c59ff63b7aa03082a18e5d9546ee" translate="yes" xml:space="preserve">
          <source>One benefit of implementing &lt;code&gt;IntoIterator&lt;/code&gt; is that your type will &lt;a href=&quot;index#for-loops-and-intoiterator&quot;&gt;work with Rust's &lt;code&gt;for&lt;/code&gt; loop syntax&lt;/a&gt;.</source>
          <target state="translated">Одним из преимуществ реализации &lt;code&gt;IntoIterator&lt;/code&gt; является то, что ваш тип будет &lt;a href=&quot;index#for-loops-and-intoiterator&quot;&gt;работать с синтаксисом цикла &lt;code&gt;for&lt;/code&gt; в Rust&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="1d5bdf955d9dc47b0601586e8217dda6094c541f" translate="yes" xml:space="preserve">
          <source>One character can become multiple:</source>
          <target state="translated">Один персонаж может стать многократным:</target>
        </trans-unit>
        <trans-unit id="9a0e2dea9fc38cc31adcbb6e264358edce5cb875" translate="yes" xml:space="preserve">
          <source>One could use &lt;code&gt;std::os::raw::c_void&lt;/code&gt; if they want to support old Rust compiler down to 1.1.0. After Rust 1.30.0, it was re-exported by this definition. For more information, please read &lt;a href=&quot;https://github.com/rust-lang/rfcs/blob/master/text/2521-c_void-reunification.md&quot;&gt;RFC 2521&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fa91f526636a9109f1e67616db8e82d52af8d580" translate="yes" xml:space="preserve">
          <source>One detail we didn&amp;rsquo;t discuss in the &lt;a href=&quot;ch04-02-references-and-borrowing#references-and-borrowing&quot;&gt;&amp;ldquo;References and Borrowing&amp;rdquo;&lt;/a&gt; section in Chapter 4 is that every reference in Rust has a &lt;em&gt;lifetime&lt;/em&gt;, which is the scope for which that reference is valid. Most of the time, lifetimes are implicit and inferred, just like most of the time, types are inferred. We must annotate types when multiple types are possible. In a similar way, we must annotate lifetimes when the lifetimes of references could be related in a few different ways. Rust requires us to annotate the relationships using generic lifetime parameters to ensure the actual references used at runtime will definitely be valid.</source>
          <target state="translated">Одна деталь, которую мы не обсуждали в разделе &lt;a href=&quot;ch04-02-references-and-borrowing#references-and-borrowing&quot;&gt;&amp;laquo;Ссылки и заимствование&amp;raquo;&lt;/a&gt; в главе 4, заключается в том, что каждая ссылка в Rust имеет время &lt;em&gt;жизни&lt;/em&gt; , которое является областью действия, для которой эта ссылка действительна. В большинстве случаев время жизни неявно и подразумевается, как и большую часть времени, предполагаются типы. Мы должны аннотировать типы, когда возможны несколько типов. Аналогичным образом мы должны аннотировать время жизни, когда время жизни ссылок может быть связано несколькими разными способами. Rust требует, чтобы мы аннотировали отношения, используя общие параметры времени жизни, чтобы гарантировать, что фактические ссылки, используемые во время выполнения, определенно будут действительными.</target>
        </trans-unit>
        <trans-unit id="d218cebb1b26aab7ac78425185eee65d682c0943" translate="yes" xml:space="preserve">
          <source>One downside of the state pattern is that, because the states implement the transitions between states, some of the states are coupled to each other. If we add another state between &lt;code&gt;PendingReview&lt;/code&gt; and &lt;code&gt;Published&lt;/code&gt;, such as &lt;code&gt;Scheduled&lt;/code&gt;, we would have to change the code in &lt;code&gt;PendingReview&lt;/code&gt; to transition to &lt;code&gt;Scheduled&lt;/code&gt; instead. It would be less work if &lt;code&gt;PendingReview&lt;/code&gt; didn&amp;rsquo;t need to change with the addition of a new state, but that would mean switching to another design pattern.</source>
          <target state="translated">Одним из недостатков паттерна состояний является то, что, поскольку состояния реализуют переходы между состояниями, некоторые состояния связаны друг с другом. Если мы добавим другое состояние между &lt;code&gt;PendingReview&lt;/code&gt; и &lt;code&gt;Published&lt;/code&gt; , например &lt;code&gt;Scheduled&lt;/code&gt; , нам придется изменить код в &lt;code&gt;PendingReview&lt;/code&gt; для перехода к &lt;code&gt;Scheduled&lt;/code&gt; . Было бы меньше работы, если бы &lt;code&gt;PendingReview&lt;/code&gt; не нужно было изменять с добавлением нового состояния, но это означало бы переключение на другой шаблон проектирования.</target>
        </trans-unit>
        <trans-unit id="79dab74a608a5fe55775f425d883e5609ea6484a" translate="yes" xml:space="preserve">
          <source>One example of a trait with an associated type is the &lt;code&gt;Iterator&lt;/code&gt; trait that the standard library provides. The associated type is named &lt;code&gt;Item&lt;/code&gt; and stands in for the type of the values the type implementing the &lt;code&gt;Iterator&lt;/code&gt; trait is iterating over. In &lt;a href=&quot;ch13-02-iterators#the-iterator-trait-and-the-next-method&quot;&gt;&amp;ldquo;The &lt;code&gt;Iterator&lt;/code&gt; Trait and the &lt;code&gt;next&lt;/code&gt; Method&amp;rdquo;&lt;/a&gt; section of Chapter 13, we mentioned that the definition of the &lt;code&gt;Iterator&lt;/code&gt; trait is as shown in Listing 19-12.</source>
          <target state="translated">Одним из примеров признака со связанным типом является признак &lt;code&gt;Iterator&lt;/code&gt; , предоставляемый стандартной библиотекой. Связанный тип называется &lt;code&gt;Item&lt;/code&gt; и заменяет тип значений, которые повторяет тип, реализующий свойство &lt;code&gt;Iterator&lt;/code&gt; . В разделе &lt;a href=&quot;ch13-02-iterators#the-iterator-trait-and-the-next-method&quot;&gt;&amp;laquo; &lt;code&gt;Iterator&lt;/code&gt; и &lt;code&gt;next&lt;/code&gt; метод&amp;raquo;&lt;/a&gt; главы 13 мы упоминали, что определение признака &lt;code&gt;Iterator&lt;/code&gt; показано в листинге 19-12.</target>
        </trans-unit>
        <trans-unit id="6e24d429d27b48134811a91f7546e1e6d93fd489" translate="yes" xml:space="preserve">
          <source>One final expression that has the type &lt;code&gt;!&lt;/code&gt; is a &lt;code&gt;loop&lt;/code&gt;:</source>
          <target state="translated">Последнее выражение, имеющее тип &lt;code&gt;!&lt;/code&gt; это &lt;code&gt;loop&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="08b7d5a5c0be732c550b04476aeb4d64ed0d9f34" translate="yes" xml:space="preserve">
          <source>One fix is to use &lt;code&gt;Option&lt;/code&gt;, like so:</source>
          <target state="translated">Одно из исправлений - использовать &lt;code&gt;Option&lt;/code&gt; , например:</target>
        </trans-unit>
        <trans-unit id="0404f28b47072e36d14ad36dc7e51fdfb00d1799" translate="yes" xml:space="preserve">
          <source>One fix may be to increase the recursion limit. Note that it is possible to create an infinite recursion of dereferencing, in which case the only fix is to somehow break the recursion.</source>
          <target state="translated">Одним из исправлений может быть увеличение предела рекурсии.Обратите внимание,что можно создать бесконечную рекурсию разыменования,в этом случае единственное исправление-это как-то прервать рекурсию.</target>
        </trans-unit>
        <trans-unit id="604777bf4c9ef568f65e74a5ef4770d9197bf0e4" translate="yes" xml:space="preserve">
          <source>One greater than the minimum possible normal power of 2 exponent.</source>
          <target state="translated">На один больше,чем минимально возможная нормальная мощность 2-х экспонентов.</target>
        </trans-unit>
        <trans-unit id="d1aad5d49e44c9e98dc9d596c60e87f16270d447" translate="yes" xml:space="preserve">
          <source>One greater than the minimum possible normal power of 2 exponent. Use &lt;a href=&quot;../primitive.f32#associatedconstant.MIN_EXP&quot;&gt;&lt;code&gt;f32::MIN_EXP&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="af913244c1df707f9c82d8aebefb4735e4abcae8" translate="yes" xml:space="preserve">
          <source>One greater than the minimum possible normal power of 2 exponent. Use &lt;a href=&quot;../primitive.f64#associatedconstant.MIN_EXP&quot;&gt;&lt;code&gt;f64::MIN_EXP&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d6888a831481b2df0737ae6067a1763cc0ae4b8b" translate="yes" xml:space="preserve">
          <source>One important part of this code is that the &lt;code&gt;Messenger&lt;/code&gt; trait has one method called &lt;code&gt;send&lt;/code&gt; that takes an immutable reference to &lt;code&gt;self&lt;/code&gt; and the text of the message. This is the interface our mock object needs to have. The other important part is that we want to test the behavior of the &lt;code&gt;set_value&lt;/code&gt; method on the &lt;code&gt;LimitTracker&lt;/code&gt;. We can change what we pass in for the &lt;code&gt;value&lt;/code&gt; parameter, but &lt;code&gt;set_value&lt;/code&gt; doesn&amp;rsquo;t return anything for us to make assertions on. We want to be able to say that if we create a &lt;code&gt;LimitTracker&lt;/code&gt; with something that implements the &lt;code&gt;Messenger&lt;/code&gt; trait and a particular value for &lt;code&gt;max&lt;/code&gt;, when we pass different numbers for &lt;code&gt;value&lt;/code&gt;, the messenger is told to send the appropriate messages.</source>
          <target state="translated">Одной из важных частей этого кода является то, что у черты &lt;code&gt;Messenger&lt;/code&gt; есть один метод, называемый &lt;code&gt;send&lt;/code&gt; , который принимает неизменяемую ссылку на &lt;code&gt;self&lt;/code&gt; и текст сообщения. Это интерфейс, который должен иметь наш фиктивный объект. Другой важной частью является то , что мы хотим , чтобы проверить поведение &lt;code&gt;set_value&lt;/code&gt; метода на &lt;code&gt;LimitTracker&lt;/code&gt; . Мы можем изменить то, что мы передаем в качестве параметра &lt;code&gt;value&lt;/code&gt; , но &lt;code&gt;set_value&lt;/code&gt; не возвращает нам ничего, на что мы могли бы делать утверждения. Мы хотим иметь возможность сказать, что если мы создадим &lt;code&gt;LimitTracker&lt;/code&gt; с чем-то, что реализует черту &lt;code&gt;Messenger&lt;/code&gt; и определенное значение для &lt;code&gt;max&lt;/code&gt; , когда мы передаем разные числа в качестве &lt;code&gt;value&lt;/code&gt; , мессенджеру предлагается отправить соответствующие сообщения.</target>
        </trans-unit>
        <trans-unit id="ded7cc38097138108681f22bf5306daeb4f49884" translate="yes" xml:space="preserve">
          <source>One increasingly popular approach to ensuring safe concurrency is &lt;em&gt;message passing&lt;/em&gt;, where threads or actors communicate by sending each other messages containing data. Here&amp;rsquo;s the idea in a slogan from &lt;a href=&quot;http://golang.org/doc/effective_go.html&quot;&gt;the Go language documentation&lt;/a&gt;: &amp;ldquo;Do not communicate by sharing memory; instead, share memory by communicating.&amp;rdquo;</source>
          <target state="translated">Одним из набирающих популярность подходов к обеспечению безопасного параллелизма является &lt;em&gt;передача сообщений&lt;/em&gt; , при которой потоки или субъекты взаимодействуют, отправляя друг другу сообщения, содержащие данные. Вот идея слогана из &lt;a href=&quot;http://golang.org/doc/effective_go.html&quot;&gt;документации по языку Go&lt;/a&gt; : &amp;laquo;Не общайтесь, разделяя память; вместо этого делитесь воспоминаниями, общаясь &amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="d3eaa18d42b0806c5f4bdf2e764c2ce7e402d5e8" translate="yes" xml:space="preserve">
          <source>One increasingly popular approach to ensuring safe concurrency is &lt;em&gt;message passing&lt;/em&gt;, where threads or actors communicate by sending each other messages containing data. Here&amp;rsquo;s the idea in a slogan from &lt;a href=&quot;https://golang.org/doc/effective_go.html#concurrency&quot;&gt;the Go language documentation&lt;/a&gt;: &amp;ldquo;Do not communicate by sharing memory; instead, share memory by communicating.&amp;rdquo;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d6b559b40224203447024d2ae45e68a9e1945eed" translate="yes" xml:space="preserve">
          <source>One last example:</source>
          <target state="translated">Последний пример:</target>
        </trans-unit>
        <trans-unit id="1ad534544463088b932bc112e0ba96d50acc9887" translate="yes" xml:space="preserve">
          <source>One lifetime annotation by itself doesn&amp;rsquo;t have much meaning, because the annotations are meant to tell Rust how generic lifetime parameters of multiple references relate to each other. For example, let&amp;rsquo;s say we have a function with the parameter &lt;code&gt;first&lt;/code&gt; that is a reference to an &lt;code&gt;i32&lt;/code&gt; with lifetime &lt;code&gt;'a&lt;/code&gt;. The function also has another parameter named &lt;code&gt;second&lt;/code&gt; that is another reference to an &lt;code&gt;i32&lt;/code&gt; that also has the lifetime &lt;code&gt;'a&lt;/code&gt;. The lifetime annotations indicate that the references &lt;code&gt;first&lt;/code&gt; and &lt;code&gt;second&lt;/code&gt; must both live as long as that generic lifetime.</source>
          <target state="translated">Одна аннотация времени жизни сама по себе не имеет особого значения, потому что аннотации предназначены для того, чтобы сообщить Rust, как общие параметры времени жизни нескольких ссылок связаны друг с другом. Например, предположим, что у нас есть функция с параметром &lt;code&gt;first&lt;/code&gt; который является ссылкой на &lt;code&gt;i32&lt;/code&gt; со временем жизни &lt;code&gt;'a&lt;/code&gt; . У функции также есть еще один параметр с именем &lt;code&gt;second&lt;/code&gt; , который является еще одной ссылкой на &lt;code&gt;i32&lt;/code&gt; , который также имеет время жизни &lt;code&gt;'a&lt;/code&gt; . Аннотации времени жизни указывают, что ссылки &lt;code&gt;first&lt;/code&gt; и &lt;code&gt;second&lt;/code&gt; должны существовать столько же, сколько и это общее время жизни.</target>
        </trans-unit>
        <trans-unit id="eb999aea4a6804c2aba22f0ab64c0d473a5cc357" translate="yes" xml:space="preserve">
          <source>One major tool Rust has for accomplishing message-sending concurrency is the &lt;em&gt;channel&lt;/em&gt;, a programming concept that Rust&amp;rsquo;s standard library provides an implementation of. You can imagine a channel in programming as being like a channel of water, such as a stream or a river. If you put something like a rubber duck or boat into a stream, it will travel downstream to the end of the waterway.</source>
          <target state="translated">Одним из основных инструментов Rust для обеспечения параллельной отправки сообщений является &lt;em&gt;канал&lt;/em&gt; , концепция программирования, реализацию которой предоставляет стандартная библиотека Rust. Вы можете представить канал в программировании как канал с водой, такой как ручей или река. Если вы поместите в ручей что-то вроде резиновой утки или лодку, она поплывет вниз по течению до конца водного пути.</target>
        </trans-unit>
        <trans-unit id="5a21bfbca68fd0fbb69da3809cb39488fd50f372" translate="yes" xml:space="preserve">
          <source>One maybe obvious note when using append-mode: make sure that all data that belongs together is written to the file in one operation. This can be done by concatenating strings before passing them to &lt;a href=&quot;../io/trait.write#tymethod.write&quot;&gt;&lt;code&gt;write()&lt;/code&gt;&lt;/a&gt;, or using a buffered writer (with a buffer of adequate size), and calling &lt;a href=&quot;../io/trait.write#tymethod.flush&quot;&gt;&lt;code&gt;flush()&lt;/code&gt;&lt;/a&gt; when the message is complete.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a100de9eac9101d503c874b2c73fc8e99b7771dc" translate="yes" xml:space="preserve">
          <source>One maybe obvious note when using append-mode: make sure that all data that belongs together is written to the file in one operation. This can be done by concatenating strings before passing them to &lt;a href=&quot;struct.file#method.write&quot;&gt;&lt;code&gt;write()&lt;/code&gt;&lt;/a&gt;, or using a buffered writer (with a buffer of adequate size), and calling &lt;a href=&quot;struct.file#method.flush&quot;&gt;&lt;code&gt;flush()&lt;/code&gt;&lt;/a&gt; when the message is complete.</source>
          <target state="translated">Одно очевидное замечание при использовании режима добавления: убедитесь, что все данные, которые принадлежат друг другу, записываются в файл за одну операцию. Это может быть выполнено путем объединения строк перед их передачей в &lt;a href=&quot;struct.file#method.write&quot;&gt; &lt;code&gt;write()&lt;/code&gt; &lt;/a&gt; или использования буферизованного модуля записи (с буфером соответствующего размера) и вызова &lt;a href=&quot;struct.file#method.flush&quot;&gt; &lt;code&gt;flush()&lt;/code&gt; &lt;/a&gt; после завершения сообщения.</target>
        </trans-unit>
        <trans-unit id="2650888f948816ac8a9838e1462a292b91d57e17" translate="yes" xml:space="preserve">
          <source>One of the keys to &lt;code&gt;collect()&lt;/code&gt;'s power is that many things you might not think of as 'collections' actually are. For example, a &lt;a href=&quot;../string/struct.string&quot;&gt;&lt;code&gt;String&lt;/code&gt;&lt;/a&gt; is a collection of &lt;a href=&quot;../primitive.char&quot;&gt;&lt;code&gt;char&lt;/code&gt;&lt;/a&gt;s. And a collection of &lt;a href=&quot;../result/enum.result&quot;&gt;&lt;code&gt;Result&amp;lt;T, E&amp;gt;&lt;/code&gt;&lt;/a&gt; can be thought of as single &lt;a href=&quot;../result/enum.result&quot;&gt;&lt;code&gt;Result&lt;/code&gt;&lt;/a&gt;&lt;code&gt;&amp;lt;Collection&amp;lt;T&amp;gt;, E&amp;gt;&lt;/code&gt;. See the examples below for more.</source>
          <target state="translated">Один из ключей к силе метода &lt;code&gt;collect()&lt;/code&gt; заключается в том, что многие вещи, которые вы, возможно, не воспринимали как &amp;laquo;коллекции&amp;raquo;, на самом деле являются. Например, &lt;a href=&quot;../string/struct.string&quot;&gt; &lt;code&gt;String&lt;/code&gt; &lt;/a&gt; - это набор &lt;a href=&quot;../primitive.char&quot;&gt; &lt;code&gt;char&lt;/code&gt; &lt;/a&gt; . А коллекцию &lt;a href=&quot;../result/enum.result&quot;&gt; &lt;code&gt;Result&amp;lt;T, E&amp;gt;&lt;/code&gt; &lt;/a&gt; можно рассматривать как один &lt;a href=&quot;../result/enum.result&quot;&gt; &lt;code&gt;Result&lt;/code&gt; &lt;/a&gt; &lt;code&gt;&amp;lt;Collection&amp;lt;T&amp;gt;, E&amp;gt;&lt;/code&gt; . См. Примеры ниже.</target>
        </trans-unit>
        <trans-unit id="c25ed3c3dc3acc46e3e6ecc55a7e68acca10b918" translate="yes" xml:space="preserve">
          <source>One of the uses of a &lt;code&gt;loop&lt;/code&gt; is to retry an operation you know might fail, such as checking whether a thread has completed its job. However, you might need to pass the result of that operation to the rest of your code. To do this, you can add the value you want returned after the &lt;code&gt;break&lt;/code&gt; expression you use to stop the loop; that value will be returned out of the loop so you can use it, as shown here:</source>
          <target state="translated">Одно из применений &lt;code&gt;loop&lt;/code&gt; - повторить операцию, которая, как вы знаете, может потерпеть неудачу, например, проверка того, завершил ли поток свое задание. Однако вам может потребоваться передать результат этой операции остальной части вашего кода. Для этого вы можете добавить значение, которое вы хотите вернуть, после выражения &lt;code&gt;break&lt;/code&gt; ,которое вы используете для остановки цикла; это значение будет возвращено из цикла, чтобы вы могли его использовать, как показано здесь:</target>
        </trans-unit>
        <trans-unit id="f31603daf9af84bcc62de6d02f7c02e0a197c236" translate="yes" xml:space="preserve">
          <source>One requirement for &lt;code&gt;match&lt;/code&gt; expressions is that they need to be &lt;em&gt;exhaustive&lt;/em&gt; in the sense that all possibilities for the value in the &lt;code&gt;match&lt;/code&gt; expression must be accounted for. One way to ensure you&amp;rsquo;ve covered every possibility is to have a catchall pattern for the last arm: for example, a variable name matching any value can never fail and thus covers every remaining case.</source>
          <target state="translated">Одно из требований для &lt;code&gt;match&lt;/code&gt; выражений является то , что они должны быть &lt;em&gt;исчерпывающими&lt;/em&gt; в том смысле , что все возможности для значения в &lt;code&gt;match&lt;/code&gt; выражении должны быть учтены. Один из способов убедиться, что вы охватили все возможности, - это иметь общий шаблон для последнего плеча: например, имя переменной, соответствующее любому значению, никогда не может дать сбой и, таким образом, охватывает все оставшиеся случаи.</target>
        </trans-unit>
        <trans-unit id="2015b7ca5d5d193e7b2cd1b845883b1560077b31" translate="yes" xml:space="preserve">
          <source>One restriction to note with trait implementations is that we can implement a trait on a type only if either the trait or the type is local to our crate. For example, we can implement standard library traits like &lt;code&gt;Display&lt;/code&gt; on a custom type like &lt;code&gt;Tweet&lt;/code&gt; as part of our &lt;code&gt;aggregator&lt;/code&gt; crate functionality, because the type &lt;code&gt;Tweet&lt;/code&gt; is local to our &lt;code&gt;aggregator&lt;/code&gt; crate. We can also implement &lt;code&gt;Summary&lt;/code&gt; on &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; in our &lt;code&gt;aggregator&lt;/code&gt; crate, because the trait &lt;code&gt;Summary&lt;/code&gt; is local to our &lt;code&gt;aggregator&lt;/code&gt; crate.</source>
          <target state="translated">Одно ограничение, которое следует отметить при реализации трейтов, заключается в том, что мы можем реализовать трейт для типа, только если трейт или тип являются локальными для нашего ящика. Например, мы можем реализовать стандартные библиотечные свойства, такие как &lt;code&gt;Display&lt;/code&gt; , в настраиваемом типе, таком как &lt;code&gt;Tweet&lt;/code&gt; , как часть функциональности нашего ящика &lt;code&gt;aggregator&lt;/code&gt; , поскольку тип &lt;code&gt;Tweet&lt;/code&gt; является локальным для нашего ящика &lt;code&gt;aggregator&lt;/code&gt; . Мы также можем реализовать &lt;code&gt;Summary&lt;/code&gt; на &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; в нашем ящике &lt;code&gt;aggregator&lt;/code&gt; , потому что свойство &lt;code&gt;Summary&lt;/code&gt; является локальным для нашего ящика &lt;code&gt;aggregator&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3ca14e0e855a4d320ac718d1dbab1d5658779f12" translate="yes" xml:space="preserve">
          <source>One should always prefer implementing &lt;code&gt;From&lt;/code&gt; over &lt;a href=&quot;trait.into&quot;&gt;&lt;code&gt;Into&lt;/code&gt;&lt;/a&gt; because implementing &lt;code&gt;From&lt;/code&gt; automatically provides one with a implementation of &lt;a href=&quot;trait.into&quot;&gt;&lt;code&gt;Into&lt;/code&gt;&lt;/a&gt; thanks to the blanket implementation in the standard library.</source>
          <target state="translated">Всегда следует предпочесть реализацию &lt;code&gt;From&lt;/code&gt; через &lt;a href=&quot;trait.into&quot;&gt; &lt;code&gt;Into&lt;/code&gt; ,&lt;/a&gt; потому что реализация &lt;code&gt;From&lt;/code&gt; автоматически обеспечивает реализацию &lt;a href=&quot;trait.into&quot;&gt; &lt;code&gt;Into&lt;/code&gt; &lt;/a&gt; благодаря общей реализации в стандартной библиотеке.</target>
        </trans-unit>
        <trans-unit id="721950a5dec28e319b3fc49a8295aa63db96bacc" translate="yes" xml:space="preserve">
          <source>One should always prefer implementing &lt;code&gt;From&lt;/code&gt; over &lt;a href=&quot;trait.into&quot;&gt;&lt;code&gt;Into&lt;/code&gt;&lt;/a&gt; because implementing &lt;code&gt;From&lt;/code&gt; automatically provides one with an implementation of &lt;a href=&quot;trait.into&quot;&gt;&lt;code&gt;Into&lt;/code&gt;&lt;/a&gt; thanks to the blanket implementation in the standard library.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bb98649134293913fe4a45ee10ddf0211b082fad" translate="yes" xml:space="preserve">
          <source>One should avoid implementing &lt;a href=&quot;trait.into&quot;&gt;&lt;code&gt;Into&lt;/code&gt;&lt;/a&gt; and implement &lt;a href=&quot;trait.from&quot;&gt;&lt;code&gt;From&lt;/code&gt;&lt;/a&gt; instead. Implementing &lt;a href=&quot;trait.from&quot;&gt;&lt;code&gt;From&lt;/code&gt;&lt;/a&gt; automatically provides one with an implementation of &lt;a href=&quot;trait.into&quot;&gt;&lt;code&gt;Into&lt;/code&gt;&lt;/a&gt; thanks to the blanket implementation in the standard library.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b9063035453c1b2c42529a52a82eaf086598016e" translate="yes" xml:space="preserve">
          <source>One should only implement &lt;a href=&quot;trait.into&quot;&gt;&lt;code&gt;Into&lt;/code&gt;&lt;/a&gt; if a conversion to a type outside the current crate is required. Otherwise one should always prefer implementing &lt;a href=&quot;trait.from&quot;&gt;&lt;code&gt;From&lt;/code&gt;&lt;/a&gt; over &lt;a href=&quot;trait.into&quot;&gt;&lt;code&gt;Into&lt;/code&gt;&lt;/a&gt; because implementing &lt;a href=&quot;trait.from&quot;&gt;&lt;code&gt;From&lt;/code&gt;&lt;/a&gt; automatically provides one with a implementation of &lt;a href=&quot;trait.into&quot;&gt;&lt;code&gt;Into&lt;/code&gt;&lt;/a&gt; thanks to the blanket implementation in the standard library. &lt;a href=&quot;trait.from&quot;&gt;&lt;code&gt;From&lt;/code&gt;&lt;/a&gt; cannot do these type of conversions because of Rust's orphaning rules.</source>
          <target state="translated">Следует реализовывать &lt;a href=&quot;trait.into&quot;&gt; &lt;code&gt;Into&lt;/code&gt; &lt;/a&gt; только в том случае, если требуется преобразование в тип вне текущего ящика. В противном случае всегда следует предпочесть реализацию &lt;a href=&quot;trait.from&quot;&gt; &lt;code&gt;From&lt;/code&gt; &lt;/a&gt; через &lt;a href=&quot;trait.into&quot;&gt; &lt;code&gt;Into&lt;/code&gt; ,&lt;/a&gt; потому что реализация &lt;a href=&quot;trait.from&quot;&gt; &lt;code&gt;From&lt;/code&gt; &lt;/a&gt; автоматически обеспечивает реализацию &lt;a href=&quot;trait.into&quot;&gt; &lt;code&gt;Into&lt;/code&gt; &lt;/a&gt; благодаря полной реализации в стандартной библиотеке. &lt;a href=&quot;trait.from&quot;&gt; &lt;code&gt;From&lt;/code&gt; &lt;/a&gt; не может выполнять такие преобразования из-за правил сиротства в Rust.</target>
        </trans-unit>
        <trans-unit id="1a1308a26b40990e2a9ab226282be34a9c0f3915" translate="yes" xml:space="preserve">
          <source>One special lifetime we need to discuss is &lt;code&gt;'static&lt;/code&gt;, which means that this reference &lt;em&gt;can&lt;/em&gt; live for the entire duration of the program. All string literals have the &lt;code&gt;'static&lt;/code&gt; lifetime, which we can annotate as follows:</source>
          <target state="translated">Одно особое время жизни, которое нам нужно обсудить, - &lt;code&gt;'static&lt;/code&gt; , что означает, что эта ссылка &lt;em&gt;может&lt;/em&gt; существовать в течение всего времени программы. Все строковые литералы имеют &lt;code&gt;'static&lt;/code&gt; время жизни, которое мы можем аннотировать следующим образом:</target>
        </trans-unit>
        <trans-unit id="b3c0e81ae8d50e16a5ef5685ec5ba7252876cd13" translate="yes" xml:space="preserve">
          <source>One way to do this would be to parse the guess as an &lt;code&gt;i32&lt;/code&gt; instead of only a &lt;code&gt;u32&lt;/code&gt; to allow potentially negative numbers, and then add a check for the number being in range, like so:</source>
          <target state="translated">Один из способов сделать это - проанализировать предположение как &lt;code&gt;i32&lt;/code&gt; , а не только &lt;code&gt;u32&lt;/code&gt; , чтобы разрешить потенциально отрицательные числа, а затем добавить проверку числа, находящегося в диапазоне, например:</target>
        </trans-unit>
        <trans-unit id="040e8b6c5e16e2eb7dbd8ea369897b2ed67939bb" translate="yes" xml:space="preserve">
          <source>One way to fix this is by wrapping &lt;code&gt;ListNode&lt;/code&gt; in a &lt;code&gt;Box&lt;/code&gt;, like so:</source>
          <target state="translated">Один из способов исправить это - обернуть &lt;code&gt;ListNode&lt;/code&gt; в &lt;code&gt;Box&lt;/code&gt; , например:</target>
        </trans-unit>
        <trans-unit id="7b55ce1dd92a000535e70271090068fe574bb882" translate="yes" xml:space="preserve">
          <source>One way to fix this is to remove the items in negative impls:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e58c5baae639d4247baa5d3c55a2e51c5fc2fcbf" translate="yes" xml:space="preserve">
          <source>One way to use &lt;code&gt;AssertUnwindSafe&lt;/code&gt; is to assert that the entire closure itself is unwind safe, bypassing all checks for all variables:</source>
          <target state="translated">Один из способов использования &lt;code&gt;AssertUnwindSafe&lt;/code&gt; - утверждать, что само закрытие является безопасным для раскрутки, минуя все проверки для всех переменных:</target>
        </trans-unit>
        <trans-unit id="1d8228fcb1896e7f726b443ff97084ceedc8b0d1" translate="yes" xml:space="preserve">
          <source>One way to work around this is to introduce a phantom type parameter into &lt;code&gt;FooMaker&lt;/code&gt;, like so:</source>
          <target state="translated">Один из способов обойти это - ввести параметр фантомного типа в &lt;code&gt;FooMaker&lt;/code&gt; , например:</target>
        </trans-unit>
        <trans-unit id="5d2a1cfc42a9afc1fe710bb8389ace0259e088eb" translate="yes" xml:space="preserve">
          <source>Only &lt;a href=&quot;struct.hashmap&quot;&gt;&lt;code&gt;HashMap&lt;/code&gt;&lt;/a&gt; has expected costs, due to the probabilistic nature of hashing. It is theoretically possible, though very unlikely, for &lt;a href=&quot;struct.hashmap&quot;&gt;&lt;code&gt;HashMap&lt;/code&gt;&lt;/a&gt; to experience worse performance.</source>
          <target state="translated">Только &lt;a href=&quot;struct.hashmap&quot;&gt; &lt;code&gt;HashMap&lt;/code&gt; &lt;/a&gt; имеет ожидаемые затраты из-за вероятностного характера хеширования. Теоретически возможно, хотя и очень маловероятно, что производительность &lt;a href=&quot;struct.hashmap&quot;&gt; &lt;code&gt;HashMap&lt;/code&gt; &lt;/a&gt; будет хуже.</target>
        </trans-unit>
        <trans-unit id="c64700ee184977494a32292609d647c2790da91d" translate="yes" xml:space="preserve">
          <source>Only &lt;code&gt;extern crate&lt;/code&gt; imports at the crate root level are allowed to import macros.</source>
          <target state="translated">Только &lt;code&gt;extern crate&lt;/code&gt; импорт ящика на корневом уровне ящика может импортировать макросы.</target>
        </trans-unit>
        <trans-unit id="0f1a591311049947010f4fb443dacb5d1227b8a1" translate="yes" xml:space="preserve">
          <source>Only Inserting a Value If the Key Has No Value</source>
          <target state="translated">Вставка значения выполняется только в том случае,если ключ не имеет значения.</target>
        </trans-unit>
        <trans-unit id="a86a2e98e34b9080a837979f0cd7c8a23bdc05cc" translate="yes" xml:space="preserve">
          <source>Only a higher-ranked bound can be used here as the lifetime of the reference is shorter than a lifetime parameter on the function:</source>
          <target state="translated">Здесь может быть использована только привязка с более высоким рейтингом,так как время жизни ссылки меньше,чем время жизни параметра функции:</target>
        </trans-unit>
        <trans-unit id="154f9dfbda3c7139a94a5be92a5a5842ea10cd7e" translate="yes" xml:space="preserve">
          <source>Only a single explicit lifetime bound is permitted on trait objects. To fix this error, consider removing one of the lifetime bounds:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1d9857467e96b586319b486e37d19a227573b8ef" translate="yes" xml:space="preserve">
          <source>Only considers whole path components to match.</source>
          <target state="translated">Считает только,что все компоненты пути совпадают.</target>
        </trans-unit>
        <trans-unit id="79d045850f7f84e6ac5788c792fcb946090d94ed" translate="yes" xml:space="preserve">
          <source>Only field-less enums can be cast to numerical primitives, so this attribute will not apply to structs.</source>
          <target state="translated">К числовым примитивам могут быть приведены только беспольные перечисления,поэтому данный атрибут не будет применяться к структурам.</target>
        </trans-unit>
        <trans-unit id="848279e3313c44734789a01608c8102412c68498" translate="yes" xml:space="preserve">
          <source>Only foreign functions can use the C-variadic type (&lt;code&gt;...&lt;/code&gt;). In such functions, &lt;code&gt;...&lt;/code&gt; may only occur non-nested. That is, &lt;code&gt;y: &amp;amp;'a ...&lt;/code&gt; is not allowed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="905a2eaaaa2de81962debc1768f8a3e80eac42bb" translate="yes" xml:space="preserve">
          <source>Only functions and methods can be called using &lt;code&gt;()&lt;/code&gt;. Example:</source>
          <target state="translated">С помощью &lt;code&gt;()&lt;/code&gt; можно вызывать только функции и методы . Пример:</target>
        </trans-unit>
        <trans-unit id="75a9ac98deeca6b24da630baa2c701b9504057f7" translate="yes" xml:space="preserve">
          <source>Only implement &lt;a href=&quot;trait.into&quot;&gt;&lt;code&gt;Into&lt;/code&gt;&lt;/a&gt; if a conversion to a type outside the current crate is required. &lt;code&gt;From&lt;/code&gt; cannot do these type of conversions because of Rust's orphaning rules. See &lt;a href=&quot;trait.into&quot;&gt;&lt;code&gt;Into&lt;/code&gt;&lt;/a&gt; for more details.</source>
          <target state="translated">Реализуйте &lt;a href=&quot;trait.into&quot;&gt; &lt;code&gt;Into&lt;/code&gt; &lt;/a&gt; только в том случае, если требуется преобразование в тип вне текущего ящика. &lt;code&gt;From&lt;/code&gt; не может выполнять такие преобразования из-за правил сиротства в Rust. См. Подробности в &lt;a href=&quot;trait.into&quot;&gt; &lt;code&gt;Into&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="9b305a83e8f3d0e4a37b5c57b23584e5d9862317" translate="yes" xml:space="preserve">
          <source>Only implement &lt;a href=&quot;trait.into&quot;&gt;&lt;code&gt;Into&lt;/code&gt;&lt;/a&gt; when targeting a version prior to Rust 1.41 and converting to a type outside the current crate. &lt;code&gt;From&lt;/code&gt; was not able to do these types of conversions in earlier versions because of Rust's orphaning rules. See &lt;a href=&quot;trait.into&quot;&gt;&lt;code&gt;Into&lt;/code&gt;&lt;/a&gt; for more details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="32f9fc3a3cbf2058b25d70080083b8cc212e6656" translate="yes" xml:space="preserve">
          <source>Only one argument can be passed per use. So instead of:</source>
          <target state="translated">На каждое использование может быть передан только один аргумент.Так что вместо этого:</target>
        </trans-unit>
        <trans-unit id="457e98acf3983b9b27751cc789092296edcc762f" translate="yes" xml:space="preserve">
          <source>Only one thread will have &lt;code&gt;true&lt;/code&gt; returned from their result, all other threads will have &lt;code&gt;false&lt;/code&gt; returned.</source>
          <target state="translated">Только один поток вернет &lt;code&gt;true&lt;/code&gt; из своего результата, все остальные потоки вернут &lt;code&gt;false&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="bc230d3e221cc5ba4ebb17173e6ee922e206f00e" translate="yes" xml:space="preserve">
          <source>Only paths to traits are allowed as argument inside &lt;code&gt;#[derive]&lt;/code&gt;. You can find more information about the &lt;code&gt;#[derive]&lt;/code&gt; attribute in the &lt;a href=&quot;book/appendix-03-derivable-traits&quot;&gt;Rust Book&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e3609d3dffa4fe7169c12045193a601a2a125a6f" translate="yes" xml:space="preserve">
          <source>Only primitive types can be cast into each other. Examples:</source>
          <target state="translated">Только примитивные типы могут быть вложены друг в друга.Примеры:</target>
        </trans-unit>
        <trans-unit id="ab9f48b23a6a48f0ef7b5f4e6bfbc32e252bb8f0" translate="yes" xml:space="preserve">
          <source>Only published blog posts return content to print, so unapproved posts can&amp;rsquo;t accidentally be published.</source>
          <target state="translated">Только опубликованные сообщения блога возвращают контент в печать, поэтому неутвержденные сообщения не могут быть случайно опубликованы.</target>
        </trans-unit>
        <trans-unit id="073ebf55d3884fb61165383e76a504c9d12cc4b5" translate="yes" xml:space="preserve">
          <source>Only structs and enums are permitted to impl Send, Sync, and other opt-out trait, and the struct or enum must be local to the current crate. So, for example, &lt;code&gt;unsafe impl Send for Rc&amp;lt;Foo&amp;gt;&lt;/code&gt; is not allowed.</source>
          <target state="translated">Только структуры и перечисления могут использовать Send, Sync и другие свойства отказа, а структура или перечисление должны быть локальными по отношению к текущему ящику. Так, например, &lt;code&gt;unsafe impl Send for Rc&amp;lt;Foo&amp;gt;&lt;/code&gt; не допускается.</target>
        </trans-unit>
        <trans-unit id="48b01a920bc2fb585e3535476a3e6dbbaef350e6" translate="yes" xml:space="preserve">
          <source>Only structural-match types (that is, types that derive &lt;code&gt;PartialEq&lt;/code&gt; and &lt;code&gt;Eq&lt;/code&gt;) may be used as the types of const generic parameters.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="51b0c3f2b71fcd0ea3442b5d718eb8c566a2296f" translate="yes" xml:space="preserve">
          <source>Only the appearance of &lt;em&gt;uncovered&lt;/em&gt; type parameters is restricted. Note that for the purposes of coherence, &lt;a href=&quot;../glossary#fundamental-type-constructors&quot;&gt;fundamental types&lt;/a&gt; are special. The &lt;code&gt;T&lt;/code&gt; in &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; is not considered covered, and &lt;code&gt;Box&amp;lt;LocalType&amp;gt;&lt;/code&gt; is considered local.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="62a5a90afa5fbb53aff61b9a8c2fc3d66d83b35e" translate="yes" xml:space="preserve">
          <source>Only the last field of &lt;code&gt;Foo&lt;/code&gt; has a type involving &lt;code&gt;T&lt;/code&gt;</source>
          <target state="translated">Только последнее поле &lt;code&gt;Foo&lt;/code&gt; имеет тип, включающий &lt;code&gt;T&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="aa278176dd71a6e098f1078a99115e300d8910ce" translate="yes" xml:space="preserve">
          <source>Only the test with the name &lt;code&gt;one_hundred&lt;/code&gt; ran; the other two tests didn&amp;rsquo;t match that name. The test output lets us know we had more tests than what this command ran by displaying &lt;code&gt;2 filtered out&lt;/code&gt; at the end of the summary line.</source>
          <target state="translated">&lt;code&gt;one_hundred&lt;/code&gt; только тест с названием one_hundred ; два других теста не соответствовали этому названию. Выходные данные теста позволяют нам узнать, что у нас было больше тестов, чем было выполнено этой командой, путем отображения &lt;code&gt;2 filtered out&lt;/code&gt; в конце итоговой строки.</target>
        </trans-unit>
        <trans-unit id="d609ff949d70f19612dfe2483b65eb476e7f69db" translate="yes" xml:space="preserve">
          <source>Only traits defined in the current crate can be implemented for arbitrary types.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="faa9f253f7801e4d949e62ca0dcb20642b072d46" translate="yes" xml:space="preserve">
          <source>Only types implementing &lt;code&gt;std::ops::Deref&lt;/code&gt; can be dereferenced (such as &lt;code&gt;&amp;amp;T&lt;/code&gt;). Example:</source>
          <target state="translated">&lt;code&gt;std::ops::Deref&lt;/code&gt; можно только типы, реализующие std :: ops :: Deref (например, &lt;code&gt;&amp;amp;T&lt;/code&gt; ). Пример:</target>
        </trans-unit>
        <trans-unit id="5b7cee0492b998101b493b89f7410ea880e0f8c8" translate="yes" xml:space="preserve">
          <source>Only use the item in the scope it has been defined:</source>
          <target state="translated">Используйте только тот элемент,который определен в области применения:</target>
        </trans-unit>
        <trans-unit id="737047a48ebff11c2ae87259e8e12b5a0ea9f000" translate="yes" xml:space="preserve">
          <source>Opaque type representing the discriminant of an enum.</source>
          <target state="translated">Непрозрачный тип,представляющий собой дискриминант переписи.</target>
        </trans-unit>
        <trans-unit id="3ba5a04eec7ab34d16390d75e26fc3fe98620cc4" translate="yes" xml:space="preserve">
          <source>Open &lt;em&gt;Cargo.toml&lt;/em&gt; in your text editor of choice. It should look similar to the code in Listing 1-2.</source>
          <target state="translated">Откройте &lt;em&gt;Cargo.toml&lt;/em&gt; в &lt;em&gt;любом&lt;/em&gt; текстовом редакторе. Он должен быть похож на код в листинге 1-2.</target>
        </trans-unit>
        <trans-unit id="0b3dfe100cddab4329734c9e3ee2eed64968e7db" translate="yes" xml:space="preserve">
          <source>Open Source Developers</source>
          <target state="translated">Разработчики с открытым исходным кодом</target>
        </trans-unit>
        <trans-unit id="9e593a95e08dd5f0164cac54edffcaa5d02e5a5e" translate="yes" xml:space="preserve">
          <source>Open a TCP connection to &lt;code&gt;127.0.0.1:8080&lt;/code&gt;. If the connection fails, open a TCP connection to &lt;code&gt;127.0.0.1:8081&lt;/code&gt;:</source>
          <target state="translated">Откройте TCP-соединение с &lt;code&gt;127.0.0.1:8080&lt;/code&gt; . В случае сбоя подключения откройте TCP-подключение к &lt;code&gt;127.0.0.1:8081&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="36758b7ca5d96a8abc3401009a4668433b033b74" translate="yes" xml:space="preserve">
          <source>Open a TCP connection to &lt;code&gt;127.0.0.1:8080&lt;/code&gt;:</source>
          <target state="translated">Откройте TCP-соединение с &lt;code&gt;127.0.0.1:8080&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="7e13d18d4e6433983fbb1efa54b9983d326c5ae6" translate="yes" xml:space="preserve">
          <source>Open a terminal and enter the following commands to make a &lt;em&gt;projects&lt;/em&gt; directory and a directory for the &amp;ldquo;Hello, world!&amp;rdquo; project within the &lt;em&gt;projects&lt;/em&gt; directory.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="65c15f3ba1726083fcf5e460a4e8e6321cd0586e" translate="yes" xml:space="preserve">
          <source>Open a terminal and enter the following commands to make a &lt;em&gt;projects&lt;/em&gt; directory and a directory for the Hello, world! project within the &lt;em&gt;projects&lt;/em&gt; directory.</source>
          <target state="translated">Откройте терминал и введите следующие команды, чтобы создать каталог &lt;em&gt;проектов&lt;/em&gt; и каталог для Hello, world! проект в каталоге &lt;em&gt;проектов&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="b4eb537f2a91bae055600573be45de77a27b9ed7" translate="yes" xml:space="preserve">
          <source>Open locally installed documentation</source>
          <target state="translated">Открытая локально установленная документация</target>
        </trans-unit>
        <trans-unit id="84587cdad70cebf6217908dcf7d0133574192d78" translate="yes" xml:space="preserve">
          <source>Open your I/O project&amp;rsquo;s &lt;em&gt;src/main.rs&lt;/em&gt; file, which should look like this:</source>
          <target state="translated">Откройте файл &lt;em&gt;src / main.rs&lt;/em&gt; вашего проекта ввода-вывода , который должен выглядеть так:</target>
        </trans-unit>
        <trans-unit id="aa0399eaec8c7efbd5c34bb50abdda7465b3ccba" translate="yes" xml:space="preserve">
          <source>OpenOptions</source>
          <target state="translated">OpenOptions</target>
        </trans-unit>
        <trans-unit id="8de57f288f4a4084e69c7c4b2aa9da0a06b4257d" translate="yes" xml:space="preserve">
          <source>OpenOptions::access_mode</source>
          <target state="translated">OpenOptions::access_mode</target>
        </trans-unit>
        <trans-unit id="b67e2c499284523d04746aeea5c1bfc24b967904" translate="yes" xml:space="preserve">
          <source>OpenOptions::append</source>
          <target state="translated">OpenOptions::append</target>
        </trans-unit>
        <trans-unit id="32e358709483fecc1c34aed91a515c84a061da75" translate="yes" xml:space="preserve">
          <source>OpenOptions::attributes</source>
          <target state="translated">OpenOptions::attributes</target>
        </trans-unit>
        <trans-unit id="e5c7a13c833ad959de5247957e258cf0746e21f9" translate="yes" xml:space="preserve">
          <source>OpenOptions::borrow</source>
          <target state="translated">OpenOptions::borrow</target>
        </trans-unit>
        <trans-unit id="0acab324be26d91ab189d61abdf16dc747c5192c" translate="yes" xml:space="preserve">
          <source>OpenOptions::borrow_mut</source>
          <target state="translated">OpenOptions::borrow_mut</target>
        </trans-unit>
        <trans-unit id="ebf38deb5d5125bd571ab2fbede6b16bab299f15" translate="yes" xml:space="preserve">
          <source>OpenOptions::clone</source>
          <target state="translated">OpenOptions::clone</target>
        </trans-unit>
        <trans-unit id="f31d22dcf8f9c141ab8ed3fbc1d9d368635388e2" translate="yes" xml:space="preserve">
          <source>OpenOptions::clone_from</source>
          <target state="translated">OpenOptions::clone_from</target>
        </trans-unit>
        <trans-unit id="b0b15f6e5b6b2ad70a686d3798f9b969c1be6e56" translate="yes" xml:space="preserve">
          <source>OpenOptions::clone_into</source>
          <target state="translated">OpenOptions::clone_into</target>
        </trans-unit>
        <trans-unit id="2924b17a8e2b9d34f65d2694a37b0e1b92b85fc1" translate="yes" xml:space="preserve">
          <source>OpenOptions::create</source>
          <target state="translated">OpenOptions::create</target>
        </trans-unit>
        <trans-unit id="518de4d4d480c6aa0ee355b7e8b68e44c261345e" translate="yes" xml:space="preserve">
          <source>OpenOptions::create_new</source>
          <target state="translated">OpenOptions::create_new</target>
        </trans-unit>
        <trans-unit id="5af121b8450a8bfc83582fafa544f257437f0c14" translate="yes" xml:space="preserve">
          <source>OpenOptions::custom_flags</source>
          <target state="translated">OpenOptions::custom_flags</target>
        </trans-unit>
        <trans-unit id="676df7a6e2a4b55c69a37308e4d1e8ab3f83cd3a" translate="yes" xml:space="preserve">
          <source>OpenOptions::fmt</source>
          <target state="translated">OpenOptions::fmt</target>
        </trans-unit>
        <trans-unit id="82f3b255624db61ae979a06d980867d5802d4709" translate="yes" xml:space="preserve">
          <source>OpenOptions::from</source>
          <target state="translated">OpenOptions::from</target>
        </trans-unit>
        <trans-unit id="96ad0ddadc43e2419e6227a5777a55351dd9ac83" translate="yes" xml:space="preserve">
          <source>OpenOptions::into</source>
          <target state="translated">OpenOptions::into</target>
        </trans-unit>
        <trans-unit id="8b77c907fad19cddc5960121fab1fa49b4431f22" translate="yes" xml:space="preserve">
          <source>OpenOptions::mode</source>
          <target state="translated">OpenOptions::mode</target>
        </trans-unit>
        <trans-unit id="1285fb69a9cc28fa9fdf3579b2f9690ab52069d7" translate="yes" xml:space="preserve">
          <source>OpenOptions::new</source>
          <target state="translated">OpenOptions::new</target>
        </trans-unit>
        <trans-unit id="aa320b137860771a593f171b8bca56f205bab7e2" translate="yes" xml:space="preserve">
          <source>OpenOptions::open</source>
          <target state="translated">OpenOptions::open</target>
        </trans-unit>
        <trans-unit id="add50a5d5957c658756ea3d2bf5f0dc20542a4ce" translate="yes" xml:space="preserve">
          <source>OpenOptions::read</source>
          <target state="translated">OpenOptions::read</target>
        </trans-unit>
        <trans-unit id="7e91e59a4c689bbc7efae946cf7ef51cecceeefe" translate="yes" xml:space="preserve">
          <source>OpenOptions::security_qos_flags</source>
          <target state="translated">OpenOptions::security_qos_flags</target>
        </trans-unit>
        <trans-unit id="90b2992d4cec48c28058dee872298370548406ec" translate="yes" xml:space="preserve">
          <source>OpenOptions::share_mode</source>
          <target state="translated">OpenOptions::share_mode</target>
        </trans-unit>
        <trans-unit id="48a692736f06da779873a596d6bb2424b9ad7161" translate="yes" xml:space="preserve">
          <source>OpenOptions::to_owned</source>
          <target state="translated">OpenOptions::to_owned</target>
        </trans-unit>
        <trans-unit id="46e980851a36d656e0daadb411e16ffdbbc2e1eb" translate="yes" xml:space="preserve">
          <source>OpenOptions::truncate</source>
          <target state="translated">OpenOptions::truncate</target>
        </trans-unit>
        <trans-unit id="5f197b60663b22df305247c4bfa1a457e5c0d835" translate="yes" xml:space="preserve">
          <source>OpenOptions::try_from</source>
          <target state="translated">OpenOptions::try_from</target>
        </trans-unit>
        <trans-unit id="747eda4c8e3b44e7c01f7e027a9bd03352e1f790" translate="yes" xml:space="preserve">
          <source>OpenOptions::try_into</source>
          <target state="translated">OpenOptions::try_into</target>
        </trans-unit>
        <trans-unit id="5058de688dcc60c90693a5096962f6405ea1f171" translate="yes" xml:space="preserve">
          <source>OpenOptions::type_id</source>
          <target state="translated">OpenOptions::type_id</target>
        </trans-unit>
        <trans-unit id="19a0518d3e6a36eb2eabd3b78700ce36d617b64d" translate="yes" xml:space="preserve">
          <source>OpenOptions::write</source>
          <target state="translated">OpenOptions::write</target>
        </trans-unit>
        <trans-unit id="6dc0ebb4fa3738b9bc9aac0db1fdc06f34fea9fc" translate="yes" xml:space="preserve">
          <source>OpenOptionsExt</source>
          <target state="translated">OpenOptionsExt</target>
        </trans-unit>
        <trans-unit id="45d6a023e7aaf3a8b617725a7efb650cf62cdf6c" translate="yes" xml:space="preserve">
          <source>Opening a file for both reading and writing, as well as creating it if it doesn't exist:</source>
          <target state="translated">Открытие файла как для чтения,так и для записи,а также его создание,если он не существует:</target>
        </trans-unit>
        <trans-unit id="d0521aae78e8ad155838f7de5e8f14d0ef7781f3" translate="yes" xml:space="preserve">
          <source>Opening a file to read:</source>
          <target state="translated">Открытие файла для чтения:</target>
        </trans-unit>
        <trans-unit id="d7d34b4c8e94f4c904313459b9fb9b442177d441" translate="yes" xml:space="preserve">
          <source>Opens a TCP connection to a remote host with a timeout.</source>
          <target state="translated">Открывает TCP-соединение с удаленным хостом с таймаутом.</target>
        </trans-unit>
        <trans-unit id="209d3641e1fce80e2ba36a03cac2a67f569fb4c6" translate="yes" xml:space="preserve">
          <source>Opens a TCP connection to a remote host.</source>
          <target state="translated">Открывает TCP-соединение с удаленным хостом.</target>
        </trans-unit>
        <trans-unit id="48dea963058d766cb37add48852fe3f445feaf08" translate="yes" xml:space="preserve">
          <source>Opens a file at &lt;code&gt;path&lt;/code&gt; with the options specified by &lt;code&gt;self&lt;/code&gt;.</source>
          <target state="translated">Открывает файл по &lt;code&gt;path&lt;/code&gt; с параметрами, указанными в &lt;code&gt;self&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1ebe50b26242826a11bca679d30a026d4444d1a2" translate="yes" xml:space="preserve">
          <source>Opens a file in write-only mode.</source>
          <target state="translated">Открывает файл в режиме только для записи.</target>
        </trans-unit>
        <trans-unit id="127d959111790c197f023d709985c8cb7e583159" translate="yes" xml:space="preserve">
          <source>Operand of the &lt;a href=&quot;expressions/operator-expr#the-dereference-operator&quot;&gt;dereference operator&lt;/a&gt; (&lt;code&gt;*&lt;/code&gt;).</source>
          <target state="translated">Операнд &lt;a href=&quot;expressions/operator-expr#the-dereference-operator&quot;&gt;оператора разыменования&lt;/a&gt; ( &lt;code&gt;*&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="a2b8c4621b34e3c27498c6c8832719e530f09634" translate="yes" xml:space="preserve">
          <source>Operands</source>
          <target state="translated">Operands</target>
        </trans-unit>
        <trans-unit id="3b28f00441a9534ad36bef8779425496277b4521" translate="yes" xml:space="preserve">
          <source>Operands of &lt;a href=&quot;expressions/operator-expr#comparison-operators&quot;&gt;comparison&lt;/a&gt;.</source>
          <target state="translated">Операнды &lt;a href=&quot;expressions/operator-expr#comparison-operators&quot;&gt;сравнения&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="796e9c6aba0ed5f7facb56a161b990345eb7dff2" translate="yes" xml:space="preserve">
          <source>Operations like &lt;code&gt;+&lt;/code&gt; on &lt;code&gt;u32&lt;/code&gt; values are intended to never overflow, and in some debug configurations overflow is detected and results in a panic. While most arithmetic falls into this category, some code explicitly expects and relies upon modular arithmetic (e.g., hashing).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fd7809a925050c789646447f7ccccf00c4e8608c" translate="yes" xml:space="preserve">
          <source>Operations like &lt;code&gt;+&lt;/code&gt; on &lt;code&gt;u32&lt;/code&gt; values is intended to never overflow, and in some debug configurations overflow is detected and results in a panic. While most arithmetic falls into this category, some code explicitly expects and relies upon modular arithmetic (e.g., hashing).</source>
          <target state="translated">Операции , как &lt;code&gt;+&lt;/code&gt; на &lt;code&gt;u32&lt;/code&gt; значениях предназначены для никогда переполнения, а в некоторых отладочных конфигурациях переполнения обнаружено и результатах в панике. Хотя большая часть арифметики попадает в эту категорию, некоторый код явно ожидает и полагается на модульную арифметику (например, хеширование).</target>
        </trans-unit>
        <trans-unit id="732a02d050941e6169a56caaf931604a39dfcf26" translate="yes" xml:space="preserve">
          <source>Operations on ASCII strings and characters.</source>
          <target state="translated">Операции со строками и символами ASCII.</target>
        </trans-unit>
        <trans-unit id="d0e687b079fb70f2208d1f8d2c75d64d74925496" translate="yes" xml:space="preserve">
          <source>Operator</source>
          <target state="translated">Operator</target>
        </trans-unit>
        <trans-unit id="e2cce0c9ff63663c1cea812414bb03fc6e974bec" translate="yes" xml:space="preserve">
          <source>Operator Traits</source>
          <target state="translated">Трейты оператора</target>
        </trans-unit>
        <trans-unit id="9cad0fd3139ef048c0168daf393a34c1807af1a2" translate="yes" xml:space="preserve">
          <source>Operator expressions</source>
          <target state="translated">Выражения оператора</target>
        </trans-unit>
        <trans-unit id="9ae1b0ed74ef02f2a20320b8054a76c10c592467" translate="yes" xml:space="preserve">
          <source>Operator/Expression</source>
          <target state="translated">Operator/Expression</target>
        </trans-unit>
        <trans-unit id="e90414358dbfff0a68e4eb5d68a16978cf197d5a" translate="yes" xml:space="preserve">
          <source>Operators</source>
          <target state="translated">Operators</target>
        </trans-unit>
        <trans-unit id="a48efc62628a97b690c020f8a1e8f8cb0bb0733d" translate="yes" xml:space="preserve">
          <source>Operators are defined for built in types by the Rust language. Many of the following operators can also be overloaded using traits in &lt;code&gt;std::ops&lt;/code&gt; or &lt;code&gt;std::cmp&lt;/code&gt;.</source>
          <target state="translated">Операторы для встроенных типов определены языком Rust. Многие из следующих операторов также могут быть перегружены с помощью трейтов в &lt;code&gt;std::ops&lt;/code&gt; или &lt;code&gt;std::cmp&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d7b5d154187c93c9da7d2603b606ea0b5d7ebfc3" translate="yes" xml:space="preserve">
          <source>Optimization hints</source>
          <target state="translated">Подсказки по оптимизации</target>
        </trans-unit>
        <trans-unit id="e31d972229de381b461860014dd710856361917a" translate="yes" xml:space="preserve">
          <source>Option</source>
          <target state="translated">Option</target>
        </trans-unit>
        <trans-unit id="9a8587bd4b256cb6bf9e533c046c7ec07658a2a8" translate="yes" xml:space="preserve">
          <source>Option::and</source>
          <target state="translated">Option::and</target>
        </trans-unit>
        <trans-unit id="ad6a1d3208211ea9f4a0bbc163a21ab722dcc207" translate="yes" xml:space="preserve">
          <source>Option::and_then</source>
          <target state="translated">Option::and_then</target>
        </trans-unit>
        <trans-unit id="3f27b9ef99923ea0d93a7d269559394c38b333c3" translate="yes" xml:space="preserve">
          <source>Option::as_mut</source>
          <target state="translated">Option::as_mut</target>
        </trans-unit>
        <trans-unit id="e2458bfdc527d230aa943b40bea1e47ef7c1716a" translate="yes" xml:space="preserve">
          <source>Option::as_pin_mut</source>
          <target state="translated">Option::as_pin_mut</target>
        </trans-unit>
        <trans-unit id="627cd8388f389dc8a414dc64f0bd2aeb93b8bdb8" translate="yes" xml:space="preserve">
          <source>Option::as_pin_ref</source>
          <target state="translated">Option::as_pin_ref</target>
        </trans-unit>
        <trans-unit id="9e1386f584a53f30c4efc9f16fd6a42d3d390020" translate="yes" xml:space="preserve">
          <source>Option::as_ref</source>
          <target state="translated">Option::as_ref</target>
        </trans-unit>
        <trans-unit id="7e71699a5e7a9d061403b6a9d9cd2031f35e7d57" translate="yes" xml:space="preserve">
          <source>Option::borrow</source>
          <target state="translated">Option::borrow</target>
        </trans-unit>
        <trans-unit id="5a2fc76bcd6cc7797b2fc8e79077c3b905ad253b" translate="yes" xml:space="preserve">
          <source>Option::borrow_mut</source>
          <target state="translated">Option::borrow_mut</target>
        </trans-unit>
        <trans-unit id="f8c7733356cc897d454d9d0b3ed5583a86a4fc0c" translate="yes" xml:space="preserve">
          <source>Option::clamp</source>
          <target state="translated">Option::clamp</target>
        </trans-unit>
        <trans-unit id="b2ed5b3da837f6c02fff44b90e9fcf28f2c92857" translate="yes" xml:space="preserve">
          <source>Option::clone</source>
          <target state="translated">Option::clone</target>
        </trans-unit>
        <trans-unit id="41a138cf124c5fbd9ab6a71d2a521b6f7b355bd9" translate="yes" xml:space="preserve">
          <source>Option::clone_from</source>
          <target state="translated">Option::clone_from</target>
        </trans-unit>
        <trans-unit id="428c2ed3ef54229edff7bb1c574b0bfd79b5c01e" translate="yes" xml:space="preserve">
          <source>Option::clone_into</source>
          <target state="translated">Option::clone_into</target>
        </trans-unit>
        <trans-unit id="7cd06b03e80642a3e13258da69f36190c57d76fe" translate="yes" xml:space="preserve">
          <source>Option::cloned</source>
          <target state="translated">Option::cloned</target>
        </trans-unit>
        <trans-unit id="7ea9e4985c5cd3b4ff11c4891148d8ba5e1cf7f3" translate="yes" xml:space="preserve">
          <source>Option::cmp</source>
          <target state="translated">Option::cmp</target>
        </trans-unit>
        <trans-unit id="0498a1a6447eab280dd5d4ffdbbf44f5e3cd0a3e" translate="yes" xml:space="preserve">
          <source>Option::copied</source>
          <target state="translated">Option::copied</target>
        </trans-unit>
        <trans-unit id="cb4ad142555a29053e45e10fc10d79edcbc2a96c" translate="yes" xml:space="preserve">
          <source>Option::default</source>
          <target state="translated">Option::default</target>
        </trans-unit>
        <trans-unit id="ba7eb304c78625b7673ed4fb2b20bafd2105ff7d" translate="yes" xml:space="preserve">
          <source>Option::deref</source>
          <target state="translated">Option::deref</target>
        </trans-unit>
        <trans-unit id="cb4668f98374c478c313d6124b78706cb9deedbc" translate="yes" xml:space="preserve">
          <source>Option::eq</source>
          <target state="translated">Option::eq</target>
        </trans-unit>
        <trans-unit id="76cfff0c978f7770807e24ce63e5dfca252d4367" translate="yes" xml:space="preserve">
          <source>Option::expect</source>
          <target state="translated">Option::expect</target>
        </trans-unit>
        <trans-unit id="6a0b764b6cbe10497b80db91840a28c114598907" translate="yes" xml:space="preserve">
          <source>Option::filter</source>
          <target state="translated">Option::filter</target>
        </trans-unit>
        <trans-unit id="560bd097e6d518e06d94482f4a9697ad398f15d0" translate="yes" xml:space="preserve">
          <source>Option::flatten</source>
          <target state="translated">Option::flatten</target>
        </trans-unit>
        <trans-unit id="d94a2e5f0e616513666e331c6d9144bddb878e9c" translate="yes" xml:space="preserve">
          <source>Option::fmt</source>
          <target state="translated">Option::fmt</target>
        </trans-unit>
        <trans-unit id="cbd7d776e3b699aac19b698f4ca1165601a486cb" translate="yes" xml:space="preserve">
          <source>Option::from</source>
          <target state="translated">Option::from</target>
        </trans-unit>
        <trans-unit id="e4ce8c942f648512db0f55fca12f5af00d0f8696" translate="yes" xml:space="preserve">
          <source>Option::from_error</source>
          <target state="translated">Option::from_error</target>
        </trans-unit>
        <trans-unit id="7e569e7075b5cfd328272103d6b5f8ce7d4d2194" translate="yes" xml:space="preserve">
          <source>Option::from_iter</source>
          <target state="translated">Option::from_iter</target>
        </trans-unit>
        <trans-unit id="a43b3b6ad08c70527052c24fb47f39fcaa4ebb0e" translate="yes" xml:space="preserve">
          <source>Option::from_ok</source>
          <target state="translated">Option::from_ok</target>
        </trans-unit>
        <trans-unit id="39c61b7ca243afc1e123c7964d51460ccf7ce39f" translate="yes" xml:space="preserve">
          <source>Option::ge</source>
          <target state="translated">Option::ge</target>
        </trans-unit>
        <trans-unit id="9b6edfb0a8e4a4f18c5a5177c880df9517534d89" translate="yes" xml:space="preserve">
          <source>Option::get_or_insert</source>
          <target state="translated">Option::get_or_insert</target>
        </trans-unit>
        <trans-unit id="998b5cc317f56f6b2107c170f3756fdcf6a6be39" translate="yes" xml:space="preserve">
          <source>Option::get_or_insert_with</source>
          <target state="translated">Option::get_or_insert_with</target>
        </trans-unit>
        <trans-unit id="ff18d337dd9fab1c83bb85ddea3fd7d94d3281c1" translate="yes" xml:space="preserve">
          <source>Option::gt</source>
          <target state="translated">Option::gt</target>
        </trans-unit>
        <trans-unit id="501ecb8b666b964e28da12f4615b48d3b7e450ee" translate="yes" xml:space="preserve">
          <source>Option::hash</source>
          <target state="translated">Option::hash</target>
        </trans-unit>
        <trans-unit id="8801dd069757ebf03df00700d2f0d8f4ca13be56" translate="yes" xml:space="preserve">
          <source>Option::hash_slice</source>
          <target state="translated">Option::hash_slice</target>
        </trans-unit>
        <trans-unit id="f71ce62ec4a3ad0f752a7c591ebba32d36455564" translate="yes" xml:space="preserve">
          <source>Option::into</source>
          <target state="translated">Option::into</target>
        </trans-unit>
        <trans-unit id="551bf0cc26ba2d59fc63fcbd70e362e1518cf5f4" translate="yes" xml:space="preserve">
          <source>Option::into_iter</source>
          <target state="translated">Option::into_iter</target>
        </trans-unit>
        <trans-unit id="acac2476c84bf169ea317554e6fccedcf73128cf" translate="yes" xml:space="preserve">
          <source>Option::into_result</source>
          <target state="translated">Option::into_result</target>
        </trans-unit>
        <trans-unit id="495a0a7509c9951579c075005e7b0266bf1a69f9" translate="yes" xml:space="preserve">
          <source>Option::is_none</source>
          <target state="translated">Option::is_none</target>
        </trans-unit>
        <trans-unit id="a5dbcd7af5f3480d6b9a0c381da167cc002b596c" translate="yes" xml:space="preserve">
          <source>Option::is_some</source>
          <target state="translated">Option::is_some</target>
        </trans-unit>
        <trans-unit id="da8976bc81fc53470a3fc8a5b2319faadd2e5469" translate="yes" xml:space="preserve">
          <source>Option::iter</source>
          <target state="translated">Option::iter</target>
        </trans-unit>
        <trans-unit id="4938dbe4f632b13fbb7938f29e586697061d0533" translate="yes" xml:space="preserve">
          <source>Option::iter_mut</source>
          <target state="translated">Option::iter_mut</target>
        </trans-unit>
        <trans-unit id="7b1a1684dd39ce6dd73cf515b242f23a85ff1b4b" translate="yes" xml:space="preserve">
          <source>Option::le</source>
          <target state="translated">Option::le</target>
        </trans-unit>
        <trans-unit id="488cf9c5fcceb69fb2b839af923c0fb53e272ed1" translate="yes" xml:space="preserve">
          <source>Option::lt</source>
          <target state="translated">Option::lt</target>
        </trans-unit>
        <trans-unit id="86dab5a9d3dc8266baf2ccd67588a2c19c44f695" translate="yes" xml:space="preserve">
          <source>Option::map</source>
          <target state="translated">Option::map</target>
        </trans-unit>
        <trans-unit id="9191b28fc19ae2afb4047d887913361af7f182b6" translate="yes" xml:space="preserve">
          <source>Option::map_or</source>
          <target state="translated">Option::map_or</target>
        </trans-unit>
        <trans-unit id="7de284a6d01f951e374aa763b2767eae6a3c5ccb" translate="yes" xml:space="preserve">
          <source>Option::map_or_else</source>
          <target state="translated">Option::map_or_else</target>
        </trans-unit>
        <trans-unit id="66654aab17a6b3aa6f143b9ae3fc8b7dca5dabd2" translate="yes" xml:space="preserve">
          <source>Option::max</source>
          <target state="translated">Option::max</target>
        </trans-unit>
        <trans-unit id="1adb57018df709f1877032a8ddcc892c8dac1998" translate="yes" xml:space="preserve">
          <source>Option::min</source>
          <target state="translated">Option::min</target>
        </trans-unit>
        <trans-unit id="eb7a9479460140930952934380e221ea1697242c" translate="yes" xml:space="preserve">
          <source>Option::ne</source>
          <target state="translated">Option::ne</target>
        </trans-unit>
        <trans-unit id="e51e9c41e5e117e0e07f5dfcd46ea7199497f649" translate="yes" xml:space="preserve">
          <source>Option::ok_or</source>
          <target state="translated">Option::ok_or</target>
        </trans-unit>
        <trans-unit id="d3009c3d13c96510f1ca710672d0c816ed55d018" translate="yes" xml:space="preserve">
          <source>Option::ok_or_else</source>
          <target state="translated">Option::ok_or_else</target>
        </trans-unit>
        <trans-unit id="dfb07ec794538d88d7c6482aed34a705f3390f21" translate="yes" xml:space="preserve">
          <source>Option::or</source>
          <target state="translated">Option::or</target>
        </trans-unit>
        <trans-unit id="197db9177edef17365dcd83807a4634b079ac530" translate="yes" xml:space="preserve">
          <source>Option::or_else</source>
          <target state="translated">Option::or_else</target>
        </trans-unit>
        <trans-unit id="47d22a5e34207ea66404113eba50209751121ad9" translate="yes" xml:space="preserve">
          <source>Option::partial_cmp</source>
          <target state="translated">Option::partial_cmp</target>
        </trans-unit>
        <trans-unit id="3e59f933c6766bd1ca8ae161c652e7b1f7df0e0f" translate="yes" xml:space="preserve">
          <source>Option::product</source>
          <target state="translated">Option::product</target>
        </trans-unit>
        <trans-unit id="43654d863e5a9272f5fcee9e6318f91e4ee0f0d7" translate="yes" xml:space="preserve">
          <source>Option::replace</source>
          <target state="translated">Option::replace</target>
        </trans-unit>
        <trans-unit id="33de023317fb385ec03a2bfdc37c470e03771088" translate="yes" xml:space="preserve">
          <source>Option::sum</source>
          <target state="translated">Option::sum</target>
        </trans-unit>
        <trans-unit id="1eb0b7661e8e838c0043a0e9891c68ec0fbe9581" translate="yes" xml:space="preserve">
          <source>Option::take</source>
          <target state="translated">Option::take</target>
        </trans-unit>
        <trans-unit id="281a61201db99ce270b59bd9978c0c4a876c16d2" translate="yes" xml:space="preserve">
          <source>Option::to_owned</source>
          <target state="translated">Option::to_owned</target>
        </trans-unit>
        <trans-unit id="3923e90861904a7d50dc82fa7bf9be53e14859da" translate="yes" xml:space="preserve">
          <source>Option::transpose</source>
          <target state="translated">Option::transpose</target>
        </trans-unit>
        <trans-unit id="29a44fa076b1666e1ed7b6e9a41abfa7aa142ab4" translate="yes" xml:space="preserve">
          <source>Option::try_from</source>
          <target state="translated">Option::try_from</target>
        </trans-unit>
        <trans-unit id="14385e832f6fb04b85656e914cf56c48e8369aff" translate="yes" xml:space="preserve">
          <source>Option::try_into</source>
          <target state="translated">Option::try_into</target>
        </trans-unit>
        <trans-unit id="a80b7a13a9d97e9cdb20ea081ae3532129b7ba72" translate="yes" xml:space="preserve">
          <source>Option::type_id</source>
          <target state="translated">Option::type_id</target>
        </trans-unit>
        <trans-unit id="fde8f7a5fc9d3f658b63f5e23bda1110f162ed70" translate="yes" xml:space="preserve">
          <source>Option::unwrap</source>
          <target state="translated">Option::unwrap</target>
        </trans-unit>
        <trans-unit id="3a5910b9b482b80f2d66da87c051adfb8d8bf61e" translate="yes" xml:space="preserve">
          <source>Option::unwrap_or</source>
          <target state="translated">Option::unwrap_or</target>
        </trans-unit>
        <trans-unit id="976c733f76ae18fb91e76013cca3578adab70346" translate="yes" xml:space="preserve">
          <source>Option::unwrap_or_default</source>
          <target state="translated">Option::unwrap_or_default</target>
        </trans-unit>
        <trans-unit id="f1995eada89f4dc6ecedad44f0c0c2330349c1bc" translate="yes" xml:space="preserve">
          <source>Option::unwrap_or_else</source>
          <target state="translated">Option::unwrap_or_else</target>
        </trans-unit>
        <trans-unit id="68786e698cfd6fd27d36f1fba3b6a686517fa05c" translate="yes" xml:space="preserve">
          <source>Option::xor</source>
          <target state="translated">Option::xor</target>
        </trans-unit>
        <trans-unit id="e3c9c006d7dd32e4af03ce0e476b71491a8d4b8a" translate="yes" xml:space="preserve">
          <source>Optional function arguments</source>
          <target state="translated">Дополнительные аргументы функции</target>
        </trans-unit>
        <trans-unit id="2e47febec66d688ce101287ee00d853516af2cfa" translate="yes" xml:space="preserve">
          <source>Optional struct fields</source>
          <target state="translated">Дополнительные поля структуры</target>
        </trans-unit>
        <trans-unit id="1a34f2c7171c8f888634b370538fba1e9d6296a5" translate="yes" xml:space="preserve">
          <source>Optional values.</source>
          <target state="translated">Дополнительные значения.</target>
        </trans-unit>
        <trans-unit id="77d6758103e11af5591d29f41814c8b3a39a2aa1" translate="yes" xml:space="preserve">
          <source>Optionally inspects an environment variable at compile time.</source>
          <target state="translated">Опционально проверяет переменную окружения во время компиляции.</target>
        </trans-unit>
        <trans-unit id="8c3b56b50deaba4f743a2a6fc1b83731273806d4" translate="yes" xml:space="preserve">
          <source>Optionally specified integer width that the output should be.</source>
          <target state="translated">Опционально заданная целочисленная ширина,которой должен быть выход.</target>
        </trans-unit>
        <trans-unit id="2048d6f0b11cf29779cd20fa71eaae6ce5ed3b2c" translate="yes" xml:space="preserve">
          <source>Optionally specified precision for numeric types.</source>
          <target state="translated">Опционально указанная точность для числовых типов.</target>
        </trans-unit>
        <trans-unit id="1485f5527557aac2d77bac994aa8db370179bdf0" translate="yes" xml:space="preserve">
          <source>Optionally specified precision for numeric types. Alternatively, the maximum width for string types.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="04373894adc677092b8d9a4d5813bcd7335dffdf" translate="yes" xml:space="preserve">
          <source>Optionally, we can also include an &lt;code&gt;else&lt;/code&gt; expression, which we chose to do here, to give the program an alternative block of code to execute should the condition evaluate to false. If you don&amp;rsquo;t provide an &lt;code&gt;else&lt;/code&gt; expression and the condition is false, the program will just skip the &lt;code&gt;if&lt;/code&gt; block and move on to the next bit of code.</source>
          <target state="translated">При желании мы также можем включить выражение &lt;code&gt;else&lt;/code&gt; , которое мы выбрали здесь, чтобы дать программе альтернативный блок кода для выполнения, если условие оценивается как ложное. Если вы не предоставите выражение &lt;code&gt;else&lt;/code&gt; и условие ложно, программа просто пропустит блок &lt;code&gt;if&lt;/code&gt; и перейдет к следующему биту кода.</target>
        </trans-unit>
        <trans-unit id="502d9e6ffaa61a4c673c37dfc595e040fc80f37d" translate="yes" xml:space="preserve">
          <source>Options and flags which can be used to configure how a file is opened.</source>
          <target state="translated">Опции и флаги,которые можно использовать для настройки способа открытия файла.</target>
        </trans-unit>
        <trans-unit id="2972721d46b095876455597aebeba50e3a239b32" translate="yes" xml:space="preserve">
          <source>Options and pointers (&quot;nullable&quot; pointers)</source>
          <target state="translated">Опции и указатели (&quot;недействительные&quot; указатели)</target>
        </trans-unit>
        <trans-unit id="e72184f55cc026514b7160d78c3c5aef63c2a050" translate="yes" xml:space="preserve">
          <source>Or</source>
          <target state="translated">Or</target>
        </trans-unit>
        <trans-unit id="3521d8b1e1c376b132968d2b9a34b13f5c378d81" translate="yes" xml:space="preserve">
          <source>Or as return types:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3bc6e013cee463ae97ecfa631a2e64cad8625c6a" translate="yes" xml:space="preserve">
          <source>Or by cloning &lt;code&gt;value&lt;/code&gt; before borrowing it:</source>
          <target state="translated">Или путем клонирования &lt;code&gt;value&lt;/code&gt; перед заимствованием:</target>
        </trans-unit>
        <trans-unit id="06b4e6d65f4c6512515713febc219b11096f10cd" translate="yes" xml:space="preserve">
          <source>Or by moving the reference into a function:</source>
          <target state="translated">Или переместив ссылку в функцию:</target>
        </trans-unit>
        <trans-unit id="b578c07095ed6ed46d6f153638a36e12535cf287" translate="yes" xml:space="preserve">
          <source>Or if you want to &lt;code&gt;break&lt;/code&gt; the labeled block:</source>
          <target state="translated">Или, если вы хотите &lt;code&gt;break&lt;/code&gt; помеченный блок:</target>
        </trans-unit>
        <trans-unit id="543cf658926daaaf4b0291516127021d4e7895e7" translate="yes" xml:space="preserve">
          <source>Or in a generic context, an erroneous code example would look like:</source>
          <target state="translated">Или в общем контексте будет выглядеть ошибочный пример кода:</target>
        </trans-unit>
        <trans-unit id="d25ee9f0412b435226c79f36ce66d89e6ad4a334" translate="yes" xml:space="preserve">
          <source>Or in the &lt;code&gt;where&lt;/code&gt; clause:</source>
          <target state="translated">Или в предложении &lt;code&gt;where&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="04b11240c2114782b42391bcc69fead4c1890df6" translate="yes" xml:space="preserve">
          <source>Or make the outer reference mutable:</source>
          <target state="translated">Или сделайте внешнюю ссылку мутирующей:</target>
        </trans-unit>
        <trans-unit id="f651c3b7a885d71e3753d367a44690ed57098104" translate="yes" xml:space="preserve">
          <source>Or maybe did you mean to unify? Consider using a guard:</source>
          <target state="translated">Или,может быть,вы хотели объединиться? Подумай об использовании охранника:</target>
        </trans-unit>
        <trans-unit id="c63cbe0fb14548b7cc3943b49c3283f01873fa23" translate="yes" xml:space="preserve">
          <source>Or propagate the error up the call stack with &lt;a href=&quot;../macro.try&quot;&gt;&lt;code&gt;?&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">Или распространить ошибку вверх по стеку вызовов с помощью &lt;a href=&quot;../macro.try&quot;&gt; &lt;code&gt;?&lt;/code&gt; &lt;/a&gt;:</target>
        </trans-unit>
        <trans-unit id="9d3b2a716e8d9c7848de5e61cb846ea61281c3e6" translate="yes" xml:space="preserve">
          <source>Or propagate the error up the call stack with &lt;a href=&quot;../ops/trait.try&quot;&gt;&lt;code&gt;?&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e0995f3133b7ba0da84026e83b875a8d8f53ccb9" translate="yes" xml:space="preserve">
          <source>Or put an end to your inclusive range:</source>
          <target state="translated">Или положите конец вашему всеохватывающему диапазону:</target>
        </trans-unit>
        <trans-unit id="7cd4277b9afe890f3408bbac80cb04dacb17b62d" translate="yes" xml:space="preserve">
          <source>Or replace the captured variable with a constant or a static item:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2a55f1def49ba2cf28edd04aebe0ae914d6adc01" translate="yes" xml:space="preserve">
          <source>Or this:</source>
          <target state="translated">Или это:</target>
        </trans-unit>
        <trans-unit id="9530c0225cb87d6d4bf8e3185c27b10d6c71d11a" translate="yes" xml:space="preserve">
          <source>Or use &lt;code&gt;if let&lt;/code&gt;:</source>
          <target state="translated">Или используйте &lt;code&gt;if let&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="273aeb6aa2ac245c7ceee53c519ceb04f6599128" translate="yes" xml:space="preserve">
          <source>Or we could name a function as the argument to &lt;code&gt;map&lt;/code&gt; instead of the closure, like this:</source>
          <target state="translated">Или мы могли бы назвать функцию в качестве аргумента для &lt;code&gt;map&lt;/code&gt; вместо закрытия, например:</target>
        </trans-unit>
        <trans-unit id="a52286981391759a88ba22e7a9a24f451bd18e85" translate="yes" xml:space="preserve">
          <source>Or we could use an &lt;code&gt;if let&lt;/code&gt; and &lt;code&gt;else&lt;/code&gt; expression like this:</source>
          <target state="translated">Или мы могли бы использовать выражения &lt;code&gt;if let&lt;/code&gt; и &lt;code&gt;else&lt;/code&gt; , например:</target>
        </trans-unit>
        <trans-unit id="b200a52a06b6557c28d7d5c924593515b39b57ed" translate="yes" xml:space="preserve">
          <source>Or we use only one lifetime:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e6bd34bc197da74a1c27a575e977239ccfe16684" translate="yes" xml:space="preserve">
          <source>Or you can pass the variable as a parameter to the closure:</source>
          <target state="translated">Или вы можете передать переменную в качестве параметра на закрытие:</target>
        </trans-unit>
        <trans-unit id="a0f7258ca7f4f4e82cbb45da80b92cb552d5cffe" translate="yes" xml:space="preserve">
          <source>Or you can reference the item with its parent:</source>
          <target state="translated">Или вы можете связать элемент с его родителем:</target>
        </trans-unit>
        <trans-unit id="a29edca74e59817dda05bb2e131ecfb108fa5284" translate="yes" xml:space="preserve">
          <source>Or, if the type implements the &lt;code&gt;Clone&lt;/code&gt; trait, you can clone it between closures:</source>
          <target state="translated">Или, если тип реализует черту &lt;code&gt;Clone&lt;/code&gt; , вы можете клонировать его между замыканиями:</target>
        </trans-unit>
        <trans-unit id="12dfe56e60634e928fd42ae5d599dda01263dc2d" translate="yes" xml:space="preserve">
          <source>Or, if you tried to use a module from an external crate, you may have missed the &lt;code&gt;extern crate&lt;/code&gt; declaration (which is usually placed in the crate root):</source>
          <target state="translated">Или, если вы пытались использовать модуль из внешнего ящика, вы могли пропустить объявление &lt;code&gt;extern crate&lt;/code&gt; (которое обычно помещается в корень ящика):</target>
        </trans-unit>
        <trans-unit id="00fcdda14949d42c1610edfba9ca80d41d59564f" translate="yes" xml:space="preserve">
          <source>Or:</source>
          <target state="translated">Or:</target>
        </trans-unit>
        <trans-unit id="756e00b4ce5e9d39383d2b108674676d2a5eb78e" translate="yes" xml:space="preserve">
          <source>OrEq</source>
          <target state="translated">OrEq</target>
        </trans-unit>
        <trans-unit id="564b40230868f4b78bca3166973a37e562d97dee" translate="yes" xml:space="preserve">
          <source>OrOr</source>
          <target state="translated">OrOr</target>
        </trans-unit>
        <trans-unit id="2813ca76372ef7834dbf7b83dd19ec3f7be3b60a" translate="yes" xml:space="preserve">
          <source>Ord</source>
          <target state="translated">Ord</target>
        </trans-unit>
        <trans-unit id="74b60f23ebce31b7a22a55c578f050bcee26fe5b" translate="yes" xml:space="preserve">
          <source>Ord::clamp</source>
          <target state="translated">Ord::clamp</target>
        </trans-unit>
        <trans-unit id="c1c60ff58cc75226de9806234302570046dbd8f5" translate="yes" xml:space="preserve">
          <source>Ord::cmp</source>
          <target state="translated">Ord::cmp</target>
        </trans-unit>
        <trans-unit id="5aac35ef704655ca052ef8370ff03afac6b470d9" translate="yes" xml:space="preserve">
          <source>Ord::max</source>
          <target state="translated">Ord::max</target>
        </trans-unit>
        <trans-unit id="44eb8ae78f7ff3385e9ae21dbb73540bf94e22db" translate="yes" xml:space="preserve">
          <source>Ord::min</source>
          <target state="translated">Ord::min</target>
        </trans-unit>
        <trans-unit id="d3ed86c1334d74f0ae883f47feef902d83b9d8c6" translate="yes" xml:space="preserve">
          <source>Ordering</source>
          <target state="translated">Ordering</target>
        </trans-unit>
        <trans-unit id="c8683d7a9b3cca82d5bfc4fb160497e659833355" translate="yes" xml:space="preserve">
          <source>Ordering::borrow</source>
          <target state="translated">Ordering::borrow</target>
        </trans-unit>
        <trans-unit id="2110fd32ceaf8e35714b9f4c770ee6cbc575392b" translate="yes" xml:space="preserve">
          <source>Ordering::borrow_mut</source>
          <target state="translated">Ordering::borrow_mut</target>
        </trans-unit>
        <trans-unit id="2d789d0561eb273919f31e5f66336ffda8097e51" translate="yes" xml:space="preserve">
          <source>Ordering::clamp</source>
          <target state="translated">Ordering::clamp</target>
        </trans-unit>
        <trans-unit id="6de6fd1c26e0555f07bc1925f3805557c3fda70f" translate="yes" xml:space="preserve">
          <source>Ordering::clone</source>
          <target state="translated">Ordering::clone</target>
        </trans-unit>
        <trans-unit id="eee5275789348dde36794118669be1ff7cd1bb4a" translate="yes" xml:space="preserve">
          <source>Ordering::clone_from</source>
          <target state="translated">Ordering::clone_from</target>
        </trans-unit>
        <trans-unit id="40853728568d4672aba47821accc24160a1b99f8" translate="yes" xml:space="preserve">
          <source>Ordering::clone_into</source>
          <target state="translated">Ordering::clone_into</target>
        </trans-unit>
        <trans-unit id="d214ed8406272d61a0d7c592025d6abf1f5d1473" translate="yes" xml:space="preserve">
          <source>Ordering::cmp</source>
          <target state="translated">Ordering::cmp</target>
        </trans-unit>
        <trans-unit id="6359dfdce4c6d799333d91033efe381426c22804" translate="yes" xml:space="preserve">
          <source>Ordering::eq</source>
          <target state="translated">Ordering::eq</target>
        </trans-unit>
        <trans-unit id="e55fb4de4f643ffa35cfa13e29a8d8ae17c99930" translate="yes" xml:space="preserve">
          <source>Ordering::fmt</source>
          <target state="translated">Ordering::fmt</target>
        </trans-unit>
        <trans-unit id="8223604ca595d0dc7d03ed1d15beee5d38176846" translate="yes" xml:space="preserve">
          <source>Ordering::from</source>
          <target state="translated">Ordering::from</target>
        </trans-unit>
        <trans-unit id="a579d7a090bb1dc3fd3d2f9a3e37ce7352737881" translate="yes" xml:space="preserve">
          <source>Ordering::ge</source>
          <target state="translated">Ordering::ge</target>
        </trans-unit>
        <trans-unit id="4618dec778641079f26c6e4998d38724ccd55bc3" translate="yes" xml:space="preserve">
          <source>Ordering::gt</source>
          <target state="translated">Ordering::gt</target>
        </trans-unit>
        <trans-unit id="efe1e62a68b71bab75ead05adff759d1187652f7" translate="yes" xml:space="preserve">
          <source>Ordering::hash</source>
          <target state="translated">Ordering::hash</target>
        </trans-unit>
        <trans-unit id="c05089412848f92294833568d422af5dbf1903b4" translate="yes" xml:space="preserve">
          <source>Ordering::hash_slice</source>
          <target state="translated">Ordering::hash_slice</target>
        </trans-unit>
        <trans-unit id="2250580789c212cd410023ce2ecb8bbc3f4ed5d2" translate="yes" xml:space="preserve">
          <source>Ordering::into</source>
          <target state="translated">Ordering::into</target>
        </trans-unit>
        <trans-unit id="70a87b5390eddefc5bd61055a8da6b411465a3b4" translate="yes" xml:space="preserve">
          <source>Ordering::le</source>
          <target state="translated">Ordering::le</target>
        </trans-unit>
        <trans-unit id="e07fd04110fe52e557d54608bb0d4cf4cd5af061" translate="yes" xml:space="preserve">
          <source>Ordering::lt</source>
          <target state="translated">Ordering::lt</target>
        </trans-unit>
        <trans-unit id="2da6624e13df6b2930a58d521c8512c0ee8d6a7b" translate="yes" xml:space="preserve">
          <source>Ordering::max</source>
          <target state="translated">Ordering::max</target>
        </trans-unit>
        <trans-unit id="9beab77e1fd3338267c9abb1b7bdf0317c0f161a" translate="yes" xml:space="preserve">
          <source>Ordering::min</source>
          <target state="translated">Ordering::min</target>
        </trans-unit>
        <trans-unit id="110f4e4f96d577bdee265f9f4c84f0bc5a9e62d9" translate="yes" xml:space="preserve">
          <source>Ordering::ne</source>
          <target state="translated">Ordering::ne</target>
        </trans-unit>
        <trans-unit id="932d7efe4223aad7b2447933dc9fc2df76690914" translate="yes" xml:space="preserve">
          <source>Ordering::partial_cmp</source>
          <target state="translated">Ordering::partial_cmp</target>
        </trans-unit>
        <trans-unit id="bd351c74f745da13de54fe0d9a1669cfb9e21ee6" translate="yes" xml:space="preserve">
          <source>Ordering::reverse</source>
          <target state="translated">Ordering::reverse</target>
        </trans-unit>
        <trans-unit id="8db4349ef9928c9f97e125860622b05714dc2737" translate="yes" xml:space="preserve">
          <source>Ordering::then</source>
          <target state="translated">Ordering::then</target>
        </trans-unit>
        <trans-unit id="ad25d15baa7a0275cbc02b73accdf10273dae875" translate="yes" xml:space="preserve">
          <source>Ordering::then_with</source>
          <target state="translated">Ordering::then_with</target>
        </trans-unit>
        <trans-unit id="5266204925b37c2e8fbeb44187ac5ae55ef0ceee" translate="yes" xml:space="preserve">
          <source>Ordering::to_owned</source>
          <target state="translated">Ordering::to_owned</target>
        </trans-unit>
        <trans-unit id="1021043cb17ea480cf742910888e38334eccb5e0" translate="yes" xml:space="preserve">
          <source>Ordering::try_from</source>
          <target state="translated">Ordering::try_from</target>
        </trans-unit>
        <trans-unit id="d7fda93cca2b35645e782a8cad0106bd8488e1ff" translate="yes" xml:space="preserve">
          <source>Ordering::try_into</source>
          <target state="translated">Ordering::try_into</target>
        </trans-unit>
        <trans-unit id="fcfc78161ff2a24d952d0059fa4182641cc917f9" translate="yes" xml:space="preserve">
          <source>Ordering::type_id</source>
          <target state="translated">Ordering::type_id</target>
        </trans-unit>
        <trans-unit id="519255ae1f74ffc5ddd29979295c7572f048ad81" translate="yes" xml:space="preserve">
          <source>Organization</source>
          <target state="translated">Organization</target>
        </trans-unit>
        <trans-unit id="5065a843766fd7080cee74229c5035721dfbaf44" translate="yes" xml:space="preserve">
          <source>Organize code into &lt;a href=&quot;../reference/items/modules&quot;&gt;modules&lt;/a&gt;.</source>
          <target state="translated">Организуйте код в &lt;a href=&quot;../reference/items/modules&quot;&gt;модули&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="6c037896c3d7d61ff179675edabd6484f44719e2" translate="yes" xml:space="preserve">
          <source>Organize large projects with workspaces</source>
          <target state="translated">Организация крупных проектов с рабочими местами</target>
        </trans-unit>
        <trans-unit id="c32c014eaf11ad9e4bbf5e85159bee172f2bd221" translate="yes" xml:space="preserve">
          <source>Organizing code (using what you learned about modules in &lt;a href=&quot;ch07-00-managing-growing-projects-with-packages-crates-and-modules&quot;&gt;Chapter 7&lt;/a&gt;)</source>
          <target state="translated">Организация кода (используя то, что вы узнали о модулях в &lt;a href=&quot;ch07-00-managing-growing-projects-with-packages-crates-and-modules&quot;&gt;главе 7&lt;/a&gt; )</target>
        </trans-unit>
        <trans-unit id="07e325e4f2f3d878f292564a3ecf710b5ee187df" translate="yes" xml:space="preserve">
          <source>Orphan rules</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ee41445c200801ea9fbf6274e97db6586289a236" translate="yes" xml:space="preserve">
          <source>OsStr</source>
          <target state="translated">OsStr</target>
        </trans-unit>
        <trans-unit id="ac78b45740efbd2536654e00fa8976f2de0098a2" translate="yes" xml:space="preserve">
          <source>OsStr::as_bytes</source>
          <target state="translated">OsStr::as_bytes</target>
        </trans-unit>
        <trans-unit id="f755c63dce374d2cd8123b73b1dd4de3e66ae36b" translate="yes" xml:space="preserve">
          <source>OsStr::as_ref</source>
          <target state="translated">OsStr::as_ref</target>
        </trans-unit>
        <trans-unit id="79eaad0b134d02d5a8a3b219fea43cf82505483f" translate="yes" xml:space="preserve">
          <source>OsStr::borrow</source>
          <target state="translated">OsStr::borrow</target>
        </trans-unit>
        <trans-unit id="bfa4d2525dd3bb64cf12c0c54ba0831b012c7cfd" translate="yes" xml:space="preserve">
          <source>OsStr::borrow_mut</source>
          <target state="translated">OsStr::borrow_mut</target>
        </trans-unit>
        <trans-unit id="2d969a374bcc571cff3bb654c0d2a624ed26d159" translate="yes" xml:space="preserve">
          <source>OsStr::clamp</source>
          <target state="translated">OsStr::clamp</target>
        </trans-unit>
        <trans-unit id="7f1396f2e8255fe6f5c9a4390d7098b8034c8699" translate="yes" xml:space="preserve">
          <source>OsStr::clone_into</source>
          <target state="translated">OsStr::clone_into</target>
        </trans-unit>
        <trans-unit id="569b89a072350ca831472f039e3799986d4f11db" translate="yes" xml:space="preserve">
          <source>OsStr::cmp</source>
          <target state="translated">OsStr::cmp</target>
        </trans-unit>
        <trans-unit id="02e4586950251d98cb8068b61addb477edffaa5f" translate="yes" xml:space="preserve">
          <source>OsStr::default</source>
          <target state="translated">OsStr::default</target>
        </trans-unit>
        <trans-unit id="1ca22c665e0765af3d1f73e68414935fa3b71420" translate="yes" xml:space="preserve">
          <source>OsStr::encode_wide</source>
          <target state="translated">OsStr::encode_wide</target>
        </trans-unit>
        <trans-unit id="fa5103a2532ae1fa374ed2927f602df85a454480" translate="yes" xml:space="preserve">
          <source>OsStr::eq</source>
          <target state="translated">OsStr::eq</target>
        </trans-unit>
        <trans-unit id="ef3f35d77c080423fa7da5fdd1ccb7cf95b71966" translate="yes" xml:space="preserve">
          <source>OsStr::fmt</source>
          <target state="translated">OsStr::fmt</target>
        </trans-unit>
        <trans-unit id="e3396244efc29b3316f86bd28df2f41d538010a9" translate="yes" xml:space="preserve">
          <source>OsStr::from</source>
          <target state="translated">OsStr::from</target>
        </trans-unit>
        <trans-unit id="9964c092761696f03f0660510726f34c37a101ba" translate="yes" xml:space="preserve">
          <source>OsStr::from_bytes</source>
          <target state="translated">OsStr::from_bytes</target>
        </trans-unit>
        <trans-unit id="20db41b61263f9037ce0775edf41bb748db52953" translate="yes" xml:space="preserve">
          <source>OsStr::ge</source>
          <target state="translated">OsStr::ge</target>
        </trans-unit>
        <trans-unit id="78612c827c884f24395b52a0e978a02ae1553397" translate="yes" xml:space="preserve">
          <source>OsStr::gt</source>
          <target state="translated">OsStr::gt</target>
        </trans-unit>
        <trans-unit id="320510460598d45269ce9bb2345c35feadc65354" translate="yes" xml:space="preserve">
          <source>OsStr::hash</source>
          <target state="translated">OsStr::hash</target>
        </trans-unit>
        <trans-unit id="2d1ef587fbe4200c7d4f9c12c46688036aba59bf" translate="yes" xml:space="preserve">
          <source>OsStr::hash_slice</source>
          <target state="translated">OsStr::hash_slice</target>
        </trans-unit>
        <trans-unit id="0020d09dec473595eec574f96d727910a223a8c2" translate="yes" xml:space="preserve">
          <source>OsStr::into_os_string</source>
          <target state="translated">OsStr::into_os_string</target>
        </trans-unit>
        <trans-unit id="03e0477c96addfca9b6c52bb8c2a51379c80e50b" translate="yes" xml:space="preserve">
          <source>OsStr::is_empty</source>
          <target state="translated">OsStr::is_empty</target>
        </trans-unit>
        <trans-unit id="9b6be64e74b26edd733b5abecea0d6e130bb8530" translate="yes" xml:space="preserve">
          <source>OsStr::le</source>
          <target state="translated">OsStr::le</target>
        </trans-unit>
        <trans-unit id="42ab8f4050f992b35836d4c6c791ac02ceb47de0" translate="yes" xml:space="preserve">
          <source>OsStr::len</source>
          <target state="translated">OsStr::len</target>
        </trans-unit>
        <trans-unit id="26a782a3c88c68f441ebbb7e07135b266f502a7e" translate="yes" xml:space="preserve">
          <source>OsStr::lt</source>
          <target state="translated">OsStr::lt</target>
        </trans-unit>
        <trans-unit id="96c41ae9f3f5a0afa117d7b0c1f0d8f14b6ad682" translate="yes" xml:space="preserve">
          <source>OsStr::max</source>
          <target state="translated">OsStr::max</target>
        </trans-unit>
        <trans-unit id="b6ada99738929e011cce58a8a1894064aa33f1c5" translate="yes" xml:space="preserve">
          <source>OsStr::min</source>
          <target state="translated">OsStr::min</target>
        </trans-unit>
        <trans-unit id="9779de4259895832c6000749300b1e884eaf3771" translate="yes" xml:space="preserve">
          <source>OsStr::ne</source>
          <target state="translated">OsStr::ne</target>
        </trans-unit>
        <trans-unit id="f62b92e58f40cddea76007419338471014c88556" translate="yes" xml:space="preserve">
          <source>OsStr::new</source>
          <target state="translated">OsStr::new</target>
        </trans-unit>
        <trans-unit id="69d32b580a0a7fc56f54834922e1ebc2ed90dd8f" translate="yes" xml:space="preserve">
          <source>OsStr::partial_cmp</source>
          <target state="translated">OsStr::partial_cmp</target>
        </trans-unit>
        <trans-unit id="71de02492654f161c7d616d82efe20f7246fff90" translate="yes" xml:space="preserve">
          <source>OsStr::to_os_string</source>
          <target state="translated">OsStr::to_os_string</target>
        </trans-unit>
        <trans-unit id="922c1b6b75bc73f9ec7e1ce34c75dd120595e71e" translate="yes" xml:space="preserve">
          <source>OsStr::to_owned</source>
          <target state="translated">OsStr::to_owned</target>
        </trans-unit>
        <trans-unit id="e32adb9e0e7fdfd7c025541e85d143ec5c74f1d0" translate="yes" xml:space="preserve">
          <source>OsStr::to_str</source>
          <target state="translated">OsStr::to_str</target>
        </trans-unit>
        <trans-unit id="bb2e4753fe627ce0f1bf0c683a900db127e08ec2" translate="yes" xml:space="preserve">
          <source>OsStr::to_string_lossy</source>
          <target state="translated">OsStr::to_string_lossy</target>
        </trans-unit>
        <trans-unit id="dbcbed83a2bb794dc501b27ebb739dedef369b66" translate="yes" xml:space="preserve">
          <source>OsStr::type_id</source>
          <target state="translated">OsStr::type_id</target>
        </trans-unit>
        <trans-unit id="1088f5a844b295ed089a98113972dbab8d734ea9" translate="yes" xml:space="preserve">
          <source>OsStrExt</source>
          <target state="translated">OsStrExt</target>
        </trans-unit>
        <trans-unit id="c3e4ec69b476c21a31135f26f6e1eb099354582b" translate="yes" xml:space="preserve">
          <source>OsString</source>
          <target state="translated">OsString</target>
        </trans-unit>
        <trans-unit id="859fe191dd2729e9636e923ce4c6010c065350e7" translate="yes" xml:space="preserve">
          <source>OsString::as_os_str</source>
          <target state="translated">OsString::as_os_str</target>
        </trans-unit>
        <trans-unit id="ae48ed668160d2660222446dc33130e3b99195f4" translate="yes" xml:space="preserve">
          <source>OsString::as_ref</source>
          <target state="translated">OsString::as_ref</target>
        </trans-unit>
        <trans-unit id="6c154a705bbfda0f8caa78dc3c83c688ceee4be3" translate="yes" xml:space="preserve">
          <source>OsString::borrow</source>
          <target state="translated">OsString::borrow</target>
        </trans-unit>
        <trans-unit id="d9285a7312a04823cbec150024a67d6051a0009c" translate="yes" xml:space="preserve">
          <source>OsString::borrow_mut</source>
          <target state="translated">OsString::borrow_mut</target>
        </trans-unit>
        <trans-unit id="8a8add6d5f7047dabf38c9708dbfcb9af76b753d" translate="yes" xml:space="preserve">
          <source>OsString::capacity</source>
          <target state="translated">OsString::capacity</target>
        </trans-unit>
        <trans-unit id="50f898a7828fada3d305d75a881fa7124881e2fb" translate="yes" xml:space="preserve">
          <source>OsString::clamp</source>
          <target state="translated">OsString::clamp</target>
        </trans-unit>
        <trans-unit id="fabd01818745e590afdeb16840705b296b4f807c" translate="yes" xml:space="preserve">
          <source>OsString::clear</source>
          <target state="translated">OsString::clear</target>
        </trans-unit>
        <trans-unit id="36e853d6cde946db2cccb29c4b429f832343aee2" translate="yes" xml:space="preserve">
          <source>OsString::clone</source>
          <target state="translated">OsString::clone</target>
        </trans-unit>
        <trans-unit id="6677d860d733e3ddcebb3f1bd2f72aa39598eb34" translate="yes" xml:space="preserve">
          <source>OsString::clone_from</source>
          <target state="translated">OsString::clone_from</target>
        </trans-unit>
        <trans-unit id="fd2ac952ffefdec51ff75b3d8c4bd391741ff1aa" translate="yes" xml:space="preserve">
          <source>OsString::clone_into</source>
          <target state="translated">OsString::clone_into</target>
        </trans-unit>
        <trans-unit id="315aba73fb5b2c6e23b4c97ac9884d2d33416e0c" translate="yes" xml:space="preserve">
          <source>OsString::cmp</source>
          <target state="translated">OsString::cmp</target>
        </trans-unit>
        <trans-unit id="997c73836512dc762004a3abdc5f64badf532f66" translate="yes" xml:space="preserve">
          <source>OsString::default</source>
          <target state="translated">OsString::default</target>
        </trans-unit>
        <trans-unit id="4e609361ff7ebe3dda2c2af92f6bf48fc86e09ed" translate="yes" xml:space="preserve">
          <source>OsString::deref</source>
          <target state="translated">OsString::deref</target>
        </trans-unit>
        <trans-unit id="a49ed3e5e5b9f62e906780fb5c5b78ac4a2a0b5c" translate="yes" xml:space="preserve">
          <source>OsString::eq</source>
          <target state="translated">OsString::eq</target>
        </trans-unit>
        <trans-unit id="5ff83c8f690658cf0d00115fedc8222c0236bcb8" translate="yes" xml:space="preserve">
          <source>OsString::fmt</source>
          <target state="translated">OsString::fmt</target>
        </trans-unit>
        <trans-unit id="d829d856e0a7a3deaac1d6966fc1b56a61c44355" translate="yes" xml:space="preserve">
          <source>OsString::from</source>
          <target state="translated">OsString::from</target>
        </trans-unit>
        <trans-unit id="8b016e304ada7a6de67311a8e7bd75a8a30eaf55" translate="yes" xml:space="preserve">
          <source>OsString::from_vec</source>
          <target state="translated">OsString::from_vec</target>
        </trans-unit>
        <trans-unit id="a2eb5354a38de73c95f950cccc782fb4d3776aee" translate="yes" xml:space="preserve">
          <source>OsString::from_wide</source>
          <target state="translated">OsString::from_wide</target>
        </trans-unit>
        <trans-unit id="977e48357172af9c7749af46184abf10a9947e2a" translate="yes" xml:space="preserve">
          <source>OsString::ge</source>
          <target state="translated">OsString::ge</target>
        </trans-unit>
        <trans-unit id="314983aa089e7916ba19eefbde10540d490c42ec" translate="yes" xml:space="preserve">
          <source>OsString::gt</source>
          <target state="translated">OsString::gt</target>
        </trans-unit>
        <trans-unit id="d83cedf1ea2574802fd81387a247eaac5739dc8f" translate="yes" xml:space="preserve">
          <source>OsString::hash</source>
          <target state="translated">OsString::hash</target>
        </trans-unit>
        <trans-unit id="6471585df89443f18cf65690eeb246e384a5afc1" translate="yes" xml:space="preserve">
          <source>OsString::hash_slice</source>
          <target state="translated">OsString::hash_slice</target>
        </trans-unit>
        <trans-unit id="a3083a37ba1b773dac91a510ae8576268b2f1358" translate="yes" xml:space="preserve">
          <source>OsString::index</source>
          <target state="translated">OsString::index</target>
        </trans-unit>
        <trans-unit id="df165c7ea6f9026088706c74d86435360f8329c2" translate="yes" xml:space="preserve">
          <source>OsString::into</source>
          <target state="translated">OsString::into</target>
        </trans-unit>
        <trans-unit id="7b6bb618d98ad820b98be022b6f7ab21e27f48a9" translate="yes" xml:space="preserve">
          <source>OsString::into_boxed_os_str</source>
          <target state="translated">OsString::into_boxed_os_str</target>
        </trans-unit>
        <trans-unit id="5fb180fdd023e0d002b850baebc43995b6922d6f" translate="yes" xml:space="preserve">
          <source>OsString::into_string</source>
          <target state="translated">OsString::into_string</target>
        </trans-unit>
        <trans-unit id="703c49b20d1d36582961bf46cf1aaf46d794f379" translate="yes" xml:space="preserve">
          <source>OsString::into_vec</source>
          <target state="translated">OsString::into_vec</target>
        </trans-unit>
        <trans-unit id="7a9071ad2ca6707ddd075812eb2d9bbf1fbd1754" translate="yes" xml:space="preserve">
          <source>OsString::is_empty</source>
          <target state="translated">OsString::is_empty</target>
        </trans-unit>
        <trans-unit id="a389a86add52b0902ca1ba2740d69696a8dddda5" translate="yes" xml:space="preserve">
          <source>OsString::le</source>
          <target state="translated">OsString::le</target>
        </trans-unit>
        <trans-unit id="3cb68f0936840ee30472030decd42b714beb3d76" translate="yes" xml:space="preserve">
          <source>OsString::len</source>
          <target state="translated">OsString::len</target>
        </trans-unit>
        <trans-unit id="56ef3320c0111ea02994b262a3cb861dbbb34f17" translate="yes" xml:space="preserve">
          <source>OsString::lt</source>
          <target state="translated">OsString::lt</target>
        </trans-unit>
        <trans-unit id="575270b5621cafd0101a5eb1bb050bc3b7e64b45" translate="yes" xml:space="preserve">
          <source>OsString::max</source>
          <target state="translated">OsString::max</target>
        </trans-unit>
        <trans-unit id="68564a48326d166c885a4ae2b7d3f0bad4e64da0" translate="yes" xml:space="preserve">
          <source>OsString::min</source>
          <target state="translated">OsString::min</target>
        </trans-unit>
        <trans-unit id="16abd935f98a70793180d4823ab08017279d0508" translate="yes" xml:space="preserve">
          <source>OsString::ne</source>
          <target state="translated">OsString::ne</target>
        </trans-unit>
        <trans-unit id="e6e8d533b010a6662c3913ad01078c70169e049a" translate="yes" xml:space="preserve">
          <source>OsString::new</source>
          <target state="translated">OsString::new</target>
        </trans-unit>
        <trans-unit id="9f53066685538b1d11ce53a4356dbcab1eb4a849" translate="yes" xml:space="preserve">
          <source>OsString::partial_cmp</source>
          <target state="translated">OsString::partial_cmp</target>
        </trans-unit>
        <trans-unit id="98f9021005b406d62879209d12b7a0b671d50c32" translate="yes" xml:space="preserve">
          <source>OsString::push</source>
          <target state="translated">OsString::push</target>
        </trans-unit>
        <trans-unit id="3d381aaee3f35c33f3658ad6121f892e6c693335" translate="yes" xml:space="preserve">
          <source>OsString::reserve</source>
          <target state="translated">OsString::reserve</target>
        </trans-unit>
        <trans-unit id="cc3d6518430a6da401547d4c22ea3d8cf229d297" translate="yes" xml:space="preserve">
          <source>OsString::reserve_exact</source>
          <target state="translated">OsString::reserve_exact</target>
        </trans-unit>
        <trans-unit id="7dcd71178aa021af3ef23a7f736f91a63dc04a08" translate="yes" xml:space="preserve">
          <source>OsString::shrink_to</source>
          <target state="translated">OsString::shrink_to</target>
        </trans-unit>
        <trans-unit id="a78619a63262a6398074a44d67d1e1c0055a9e42" translate="yes" xml:space="preserve">
          <source>OsString::shrink_to_fit</source>
          <target state="translated">OsString::shrink_to_fit</target>
        </trans-unit>
        <trans-unit id="e677a0fce97086e2dbd5116d8c73422a5b17335f" translate="yes" xml:space="preserve">
          <source>OsString::to_os_string</source>
          <target state="translated">OsString::to_os_string</target>
        </trans-unit>
        <trans-unit id="1e5d3ed2984e0c0a94e3614d04a4b6d1e5283af6" translate="yes" xml:space="preserve">
          <source>OsString::to_owned</source>
          <target state="translated">OsString::to_owned</target>
        </trans-unit>
        <trans-unit id="2010c47df96f790856e2a60e7f3995e78eada375" translate="yes" xml:space="preserve">
          <source>OsString::to_str</source>
          <target state="translated">OsString::to_str</target>
        </trans-unit>
        <trans-unit id="c5ab5192e0b8fd775bd3e8f9b3e0573d969f29b3" translate="yes" xml:space="preserve">
          <source>OsString::to_string_lossy</source>
          <target state="translated">OsString::to_string_lossy</target>
        </trans-unit>
        <trans-unit id="effa33ff4c0c0309f8ac54bad875e745daa055b5" translate="yes" xml:space="preserve">
          <source>OsString::try_from</source>
          <target state="translated">OsString::try_from</target>
        </trans-unit>
        <trans-unit id="fb369eb73b7652c7f64f7858a0ab00fb0d746ca4" translate="yes" xml:space="preserve">
          <source>OsString::try_into</source>
          <target state="translated">OsString::try_into</target>
        </trans-unit>
        <trans-unit id="2df035af1f5a524f1b084c9f6fb3b92ba6dc0ed1" translate="yes" xml:space="preserve">
          <source>OsString::type_id</source>
          <target state="translated">OsString::type_id</target>
        </trans-unit>
        <trans-unit id="5174f93493c600b6d13e517fcdf7e8efbdb14dca" translate="yes" xml:space="preserve">
          <source>OsString::with_capacity</source>
          <target state="translated">OsString::with_capacity</target>
        </trans-unit>
        <trans-unit id="746c2997c2de636223c1bd2e6ffbcac4d777ef7f" translate="yes" xml:space="preserve">
          <source>OsStringExt</source>
          <target state="translated">OsStringExt</target>
        </trans-unit>
        <trans-unit id="5bc9a5878701d6eea8963b31b0c3a5a1dc4ff057" translate="yes" xml:space="preserve">
          <source>Other Rust features, such as pattern matching and enums, which we&amp;rsquo;ve covered in other chapters, are influenced by the functional style as well. Mastering closures and iterators is an important part of writing idiomatic, fast Rust code, so we&amp;rsquo;ll devote this entire chapter to them.</source>
          <target state="translated">Другие возможности Rust, такие как сопоставление с образцом и перечисления, которые мы рассмотрели в других главах, также зависят от функционального стиля. Освоение замыканий и итераторов - важная часть написания идиоматического быстрого кода на Rust, поэтому мы посвятим им всю эту главу.</target>
        </trans-unit>
        <trans-unit id="78f4a1803901c79b472a31aac60c766c79e0cd1d" translate="yes" xml:space="preserve">
          <source>Other Slices</source>
          <target state="translated">Другие дольки</target>
        </trans-unit>
        <trans-unit id="7ebd492d99acb79e16a874d198f25fa4ea4ca260" translate="yes" xml:space="preserve">
          <source>Other duplication includes the similar implementations of the &lt;code&gt;request_review&lt;/code&gt; and &lt;code&gt;approve&lt;/code&gt; methods on &lt;code&gt;Post&lt;/code&gt;. Both methods delegate to the implementation of the same method on the value in the &lt;code&gt;state&lt;/code&gt; field of &lt;code&gt;Option&lt;/code&gt; and set the new value of the &lt;code&gt;state&lt;/code&gt; field to the result. If we had a lot of methods on &lt;code&gt;Post&lt;/code&gt; that followed this pattern, we might consider defining a macro to eliminate the repetition (see the &lt;a href=&quot;ch19-06-macros#macros&quot;&gt;&amp;ldquo;Macros&amp;rdquo;&lt;/a&gt; section in Chapter 19).</source>
          <target state="translated">Другое дублирование включает аналогичные реализации методов &lt;code&gt;request_review&lt;/code&gt; и &lt;code&gt;approve&lt;/code&gt; в &lt;code&gt;Post&lt;/code&gt; . Оба метода делегировать реализации одного и того же метода на величину в &lt;code&gt;state&lt;/code&gt; поле &lt;code&gt;Option&lt;/code&gt; и установить новое значение &lt;code&gt;state&lt;/code&gt; поля к результату. Если бы у нас было много методов в &lt;code&gt;Post&lt;/code&gt; , которые следовали этому шаблону, мы могли бы рассмотреть возможность определения макроса, чтобы исключить повторение (см. Раздел &lt;a href=&quot;ch19-06-macros#macros&quot;&gt;&amp;laquo;Макросы&amp;raquo;&lt;/a&gt; в главе 19).</target>
        </trans-unit>
        <trans-unit id="752d28b2015c4a5a9b75eaf4a1216f39bbdf32b1" translate="yes" xml:space="preserve">
          <source>Other languages, like C, will attempt to give you exactly what you asked for in this situation, even though it isn&amp;rsquo;t what you want: you&amp;rsquo;ll get whatever is at the location in memory that would correspond to that element in the vector, even though the memory doesn&amp;rsquo;t belong to the vector. This is called a &lt;em&gt;buffer overread&lt;/em&gt; and can lead to security vulnerabilities if an attacker is able to manipulate the index in such a way as to read data they shouldn&amp;rsquo;t be allowed to that is stored after the array.</source>
          <target state="translated">Другие языки, такие как C, будут пытаться дать вам именно то, что вы просили в этой ситуации, даже если это не то, что вы хотите: вы получите все, что находится в том месте в памяти, которое будет соответствовать этому элементу в векторе. , даже если память не принадлежит вектору. Это называется &lt;em&gt;переполнением буфера&lt;/em&gt; и может привести к уязвимостям безопасности, если злоумышленник может манипулировать индексом таким образом, чтобы читать данные, которые ему не должны быть разрешены, которые хранятся после массива.</target>
        </trans-unit>
        <trans-unit id="648ace77ed0f39aac89b4770e105e365ba693a3e" translate="yes" xml:space="preserve">
          <source>Other methods defined on the &lt;code&gt;Iterator&lt;/code&gt; trait, known as &lt;em&gt;iterator adaptors&lt;/em&gt;, allow you to change iterators into different kinds of iterators. You can chain multiple calls to iterator adaptors to perform complex actions in a readable way. But because all iterators are lazy, you have to call one of the consuming adaptor methods to get results from calls to iterator adaptors.</source>
          <target state="translated">Другие методы, определенные в &lt;code&gt;Iterator&lt;/code&gt; , известные как &lt;em&gt;адаптеры итераторов&lt;/em&gt; , позволяют вам преобразовывать итераторы в итераторы различных типов. Вы можете связать несколько вызовов адаптеров итераторов для выполнения сложных действий в удобочитаемом виде. Но поскольку все итераторы ленивы, вы должны вызвать один из методов адаптера-потребителя, чтобы получить результаты от вызовов адаптеров итераторов.</target>
        </trans-unit>
        <trans-unit id="2249508fdf94c149e36ab432d8b683b49f9e6995" translate="yes" xml:space="preserve">
          <source>Other places &lt;code&gt;as&lt;/code&gt; is used include as extra syntax for &lt;a href=&quot;keyword.crate&quot;&gt;&lt;code&gt;crate&lt;/code&gt;&lt;/a&gt; and &lt;code&gt;use&lt;/code&gt;, to change the name something is imported as.</source>
          <target state="translated">Другие места, &lt;code&gt;as&lt;/code&gt; используются, включают дополнительный синтаксис для &lt;a href=&quot;keyword.crate&quot;&gt; &lt;code&gt;crate&lt;/code&gt; &lt;/a&gt; and &lt;code&gt;use&lt;/code&gt; , чтобы изменить имя, как что-то импортируется.</target>
        </trans-unit>
        <trans-unit id="ca7f9932674bb9c25f134a0105ec09c2c00e169d" translate="yes" xml:space="preserve">
          <source>Other places the &lt;code&gt;let&lt;/code&gt; keyword is used include along with &lt;a href=&quot;keyword.if&quot;&gt;&lt;code&gt;if&lt;/code&gt;&lt;/a&gt;, in the form of &lt;code&gt;if let&lt;/code&gt; expressions. They're useful if the pattern being matched isn't exhaustive, such as with enumerations. &lt;code&gt;while let&lt;/code&gt; also exists, which runs a loop with a pattern matched value until that pattern can't be matched.</source>
          <target state="translated">Другие места, где используется ключевое слово &lt;code&gt;let&lt;/code&gt; , включают вместе с &lt;a href=&quot;keyword.if&quot;&gt; &lt;code&gt;if&lt;/code&gt; &lt;/a&gt; в форме выражений &lt;code&gt;if let&lt;/code&gt; . Они полезны, если сопоставляемый шаблон не является исчерпывающим, например, с перечислениями. &lt;code&gt;while let&lt;/code&gt; также существует let , который запускает цикл со значением, совпадающим с шаблоном, до тех пор, пока этот шаблон не будет совпадать.</target>
        </trans-unit>
        <trans-unit id="995a627762e880a789090e71c29696dd2233250e" translate="yes" xml:space="preserve">
          <source>Other preludes</source>
          <target state="translated">Другие прелюдии</target>
        </trans-unit>
        <trans-unit id="446bad3bff9defd3006cda2835a7a1319d8a35e5" translate="yes" xml:space="preserve">
          <source>Other programming languages don&amp;rsquo;t require you to connect arguments to return values in the signature. Although this might seem strange, it will get easier over time. You might want to compare this example with the &lt;a href=&quot;ch10-03-lifetime-syntax#validating-references-with-lifetimes&quot;&gt;&amp;ldquo;Validating References with Lifetimes&amp;rdquo;&lt;/a&gt; section in Chapter 10.</source>
          <target state="translated">Другие языки программирования не требуют, чтобы вы подключали аргументы для возврата значений в подписи. Хотя это может показаться странным, со временем станет легче. Вы можете сравнить этот пример с разделом &lt;a href=&quot;ch10-03-lifetime-syntax#validating-references-with-lifetimes&quot;&gt;&amp;laquo;Проверка ссылок с помощью времени жизни&amp;raquo;&lt;/a&gt; в главе 10.</target>
        </trans-unit>
        <trans-unit id="60eaf9cabcdeaacd84dda8af53312b70b5da796b" translate="yes" xml:space="preserve">
          <source>Other than that, attribute-like macros work the same way as custom derive macros: you create a crate with the &lt;code&gt;proc-macro&lt;/code&gt; crate type and implement a function that generates the code you want!</source>
          <target state="translated">В остальном макросы, подобные атрибутам, работают так же, как макросы пользовательского извлечения: вы создаете ящик с типом контейнера &lt;code&gt;proc-macro&lt;/code&gt; и реализуете функцию, которая генерирует нужный вам код!</target>
        </trans-unit>
        <trans-unit id="18d96cb86d3646fb81607f614e4ed101dbb61f72" translate="yes" xml:space="preserve">
          <source>Other traits</source>
          <target state="translated">Другие характеристики</target>
        </trans-unit>
        <trans-unit id="9112d41ffd7475a6522498133c87c82589bd20c2" translate="yes" xml:space="preserve">
          <source>Other types are return or parameter types for various methods in this module</source>
          <target state="translated">Другие типы являются типами возврата или типами параметров для различных методов в этом модуле.</target>
        </trans-unit>
        <trans-unit id="9a231351b0f4e7aeebda1053a5e76d13dcb380a5" translate="yes" xml:space="preserve">
          <source>Other types don't result in any further drops.</source>
          <target state="translated">Другие типы не приводят к дальнейшим падениям.</target>
        </trans-unit>
        <trans-unit id="7020ce2c6597276032beef17fd5a264945d38617" translate="yes" xml:space="preserve">
          <source>Other types with interior mutability can be created by using &lt;code&gt;UnsafeCell&amp;lt;T&amp;gt;&lt;/code&gt; as a field. The standard library provides a variety of types that provide safe interior mutability APIs. For example, &lt;a href=&quot;../std/cell/struct.refcell&quot;&gt;&lt;code&gt;std::cell::RefCell&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt; uses run-time borrow checks to ensure the usual rules around multiple references. The &lt;a href=&quot;../std/sync/atomic/index&quot;&gt;&lt;code&gt;std::sync::atomic&lt;/code&gt;&lt;/a&gt; module contains types that wrap a value that is only accessed with atomic operations, allowing the value to be shared and mutated across threads.</source>
          <target state="translated">Другие типы с внутренней изменчивостью могут быть созданы с использованием &lt;code&gt;UnsafeCell&amp;lt;T&amp;gt;&lt;/code&gt; в качестве поля. Стандартная библиотека предоставляет множество типов, которые обеспечивают безопасную внутреннюю изменчивость API. Например, &lt;a href=&quot;../std/cell/struct.refcell&quot;&gt; &lt;code&gt;std::cell::RefCell&amp;lt;T&amp;gt;&lt;/code&gt; &lt;/a&gt; использует проверки заимствования во время выполнения, чтобы гарантировать обычные правила для нескольких ссылок. Модуль &lt;a href=&quot;../std/sync/atomic/index&quot;&gt; &lt;code&gt;std::sync::atomic&lt;/code&gt; &lt;/a&gt; содержит типы, которые обертывают значение, доступ к которому осуществляется только с помощью атомарных операций, что позволяет использовать значение совместно и изменять его между потоками.</target>
        </trans-unit>
        <trans-unit id="599ae630fe84d3beb8513b4b711cd547079431cd" translate="yes" xml:space="preserve">
          <source>Other use-cases of &lt;code&gt;assert!&lt;/code&gt; include testing and enforcing run-time invariants in safe code (whose violation cannot result in unsafety).</source>
          <target state="translated">Другие варианты использования &lt;code&gt;assert!&lt;/code&gt; включать тестирование и обеспечение соблюдения инвариантов времени выполнения в безопасном коде (нарушение которого не может привести к небезопасности).</target>
        </trans-unit>
        <trans-unit id="137a49284667a8d8d78ea49224e1089ee25a5b67" translate="yes" xml:space="preserve">
          <source>Other uses of &lt;code&gt;const&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f8937a7fc4e72088623e287ce30c97cb2dfe7283" translate="yes" xml:space="preserve">
          <source>Otherwise it is equivalent to calling &lt;a href=&quot;struct.pathbuf#method.pop&quot;&gt;&lt;code&gt;pop&lt;/code&gt;&lt;/a&gt; and then pushing &lt;code&gt;file_name&lt;/code&gt;. The new path will be a sibling of the original path. (That is, it will have the same parent.)</source>
          <target state="translated">В противном случае это эквивалентно вызову &lt;a href=&quot;struct.pathbuf#method.pop&quot;&gt; &lt;code&gt;pop&lt;/code&gt; &lt;/a&gt; и последующему нажатию &lt;code&gt;file_name&lt;/code&gt; . Новый путь будет братом исходного пути. (То есть у него будет тот же родитель.)</target>
        </trans-unit>
        <trans-unit id="96540f88a556928131ba8d92a01693b0a2eeaf4d" translate="yes" xml:space="preserve">
          <source>Otherwise the call to &lt;code&gt;poll&lt;/code&gt; must have returned &lt;a href=&quot;../../std/task/enum.poll#variant.Ready&quot;&gt;&lt;code&gt;Poll::Ready&lt;/code&gt;&lt;/a&gt;, in which case the value contained in the &lt;a href=&quot;../../std/task/enum.poll#variant.Ready&quot;&gt;&lt;code&gt;Poll::Ready&lt;/code&gt;&lt;/a&gt; variant is used as the result of the &lt;code&gt;await&lt;/code&gt; expression itself.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b37fe747217886166ea371a631e142a031b6a7b7" translate="yes" xml:space="preserve">
          <source>Otherwise, M is a token-tree sequence starting with a complex NT: &lt;code&gt;M = $( tt ... ) OP &amp;alpha;&lt;/code&gt;, or &lt;code&gt;M = $( tt ... ) SEP OP &amp;alpha;&lt;/code&gt;, (where &lt;code&gt;&amp;alpha;&lt;/code&gt; is the (potentially empty) sequence of token trees for the rest of the matcher).</source>
          <target state="translated">В противном случае M - последовательность лексем-дерева, начинающаяся с комплексного NT: &lt;code&gt;M = $( tt ... ) OP &amp;alpha;&lt;/code&gt; , или &lt;code&gt;M = $( tt ... ) SEP OP &amp;alpha;&lt;/code&gt; , (где &lt;code&gt;&amp;alpha;&lt;/code&gt; - (потенциально пустой) последовательность деревьев токенов для остальной части сопоставителя).</target>
        </trans-unit>
        <trans-unit id="b3979bc5186a96b9165f258e5cf3641aa97f2109" translate="yes" xml:space="preserve">
          <source>Otherwise, a temporary vector is allocated and the tail is moved twice.</source>
          <target state="translated">В противном случае выделяется временный вектор и дважды перемещается хвост.</target>
        </trans-unit>
        <trans-unit id="924bccd077970d788135a7832dffedb5e19ed44b" translate="yes" xml:space="preserve">
          <source>Otherwise, an &lt;a href=&quot;../result/enum.result&quot;&gt;&lt;code&gt;Err&lt;/code&gt;&lt;/a&gt; is returned with the same &lt;code&gt;Arc&lt;/code&gt; that was passed in.</source>
          <target state="translated">В противном случае возвращается &lt;a href=&quot;../result/enum.result&quot;&gt; &lt;code&gt;Err&lt;/code&gt; &lt;/a&gt; с той же &lt;code&gt;Arc&lt;/code&gt; , которая была передана.</target>
        </trans-unit>
        <trans-unit id="46a74754ed30587d7524fb80829f9c67f0fd59f6" translate="yes" xml:space="preserve">
          <source>Otherwise, an &lt;a href=&quot;../result/enum.result&quot;&gt;&lt;code&gt;Err&lt;/code&gt;&lt;/a&gt; is returned with the same &lt;code&gt;Rc&lt;/code&gt; that was passed in.</source>
          <target state="translated">В противном случае возвращается &lt;a href=&quot;../result/enum.result&quot;&gt; &lt;code&gt;Err&lt;/code&gt; &lt;/a&gt; с тем же значением &lt;code&gt;Rc&lt;/code&gt; , которое было передано.</target>
        </trans-unit>
        <trans-unit id="a9eb5eed15b5d494937b924570de6ed9892756ab" translate="yes" xml:space="preserve">
          <source>Otherwise, an &lt;a href=&quot;../result/enum.result#variant.Err&quot;&gt;&lt;code&gt;Err&lt;/code&gt;&lt;/a&gt; is returned with the same &lt;code&gt;Arc&lt;/code&gt; that was passed in.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="076aed98362102b58857ec0dff921bab2bf57831" translate="yes" xml:space="preserve">
          <source>Otherwise, an &lt;a href=&quot;../result/enum.result#variant.Err&quot;&gt;&lt;code&gt;Err&lt;/code&gt;&lt;/a&gt; is returned with the same &lt;code&gt;Rc&lt;/code&gt; that was passed in.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="41af0b79355036082d1d8c65ff7faff1fc431650" translate="yes" xml:space="preserve">
          <source>Otherwise, check whether &lt;code&gt;T_t&lt;/code&gt; can be coerced to &lt;code&gt;Ti&lt;/code&gt;; if so, the &lt;code&gt;T_t&lt;/code&gt; is changed to &lt;code&gt;Ti&lt;/code&gt;. (This check is also conditioned on whether all of the source expressions considered thus far have implicit coercions.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2ea00676375cce55b25c24c3900ad8d91fe8b198" translate="yes" xml:space="preserve">
          <source>Otherwise, edit the code to pass the lint check, and remove the overruled attribute:</source>
          <target state="translated">В противном случае отредактируйте код,чтобы пройти проверку на ворс,и удалите отмененный атрибут:</target>
        </trans-unit>
        <trans-unit id="3e85707b79250bd8b856e5ae665d19d426f3f381" translate="yes" xml:space="preserve">
          <source>Otherwise, it tries to determine the home directory by invoking the &lt;code&gt;getpwuid_r&lt;/code&gt; function using the UID of the current user. An empty home directory field returned from the &lt;code&gt;getpwuid_r&lt;/code&gt; function is considered to be a valid value.</source>
          <target state="translated">В противном случае он пытается определить домашний каталог, вызывая функцию &lt;code&gt;getpwuid_r&lt;/code&gt; , используя UID текущего пользователя. Пустое поле домашнего каталога, возвращаемое функцией &lt;code&gt;getpwuid_r&lt;/code&gt; , считается допустимым значением.</target>
        </trans-unit>
        <trans-unit id="5085664d3dd97fdbb0b3f9d3d918e581e0986f55" translate="yes" xml:space="preserve">
          <source>Otherwise, returns the value of the 'USERPROFILE' environment variable if it is set (including to an empty string).</source>
          <target state="translated">В противном случае возвращает значение переменной окружения 'USERPROFILE',если она установлена (в том числе и в пустую строку).</target>
        </trans-unit>
        <trans-unit id="9a8101e7cf6341fccad86da30ddd075e4eab3ee5" translate="yes" xml:space="preserve">
          <source>Otherwise, the portion of the file name after the final &lt;code&gt;.&lt;/code&gt;</source>
          <target state="translated">В противном случае часть имени файла после финального &lt;code&gt;.&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="080897ebd41df30ce96e1487fbd29e58924856eb" translate="yes" xml:space="preserve">
          <source>Otherwise, the portion of the file name before the final &lt;code&gt;.&lt;/code&gt;</source>
          <target state="translated">В противном случае часть имени файла перед финальной &lt;code&gt;.&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="d86ad59ea40d5cf59b8de4ede8f6b7e49f58d63e" translate="yes" xml:space="preserve">
          <source>Otherwise, the sequence &lt;code&gt;uu ...&lt;/code&gt; must be non-empty; then LAST(M) = LAST(&lt;code&gt;uu ...&lt;/code&gt;).</source>
          <target state="translated">В противном случае последовательность &lt;code&gt;uu ...&lt;/code&gt; должна быть непустой; тогда ПОСЛЕДНИЙ (M) = ПОСЛЕДНИЙ ( &lt;code&gt;uu ...&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="5270e35ef24eac532a4d91eeaaf7988bb3731097" translate="yes" xml:space="preserve">
          <source>Otherwise, they work just like regular lint attributes:</source>
          <target state="translated">Иначе они работают как обычные атрибуты ворсинок:</target>
        </trans-unit>
        <trans-unit id="2e0d61497954041bb9b7946612d5835e3fcd762c" translate="yes" xml:space="preserve">
          <source>Otherwise, you may want to jump to one of these useful sections:</source>
          <target state="translated">В противном случае,вы можете захотеть перейти к одному из этих полезных разделов:</target>
        </trans-unit>
        <trans-unit id="7655b057b9db516628b6ec609cbbac4394a83302" translate="yes" xml:space="preserve">
          <source>Our &lt;code&gt;MyBox&amp;lt;T&amp;gt;&lt;/code&gt; type can&amp;rsquo;t be dereferenced because we haven&amp;rsquo;t implemented that ability on our type. To enable dereferencing with the &lt;code&gt;*&lt;/code&gt; operator, we implement the &lt;code&gt;Deref&lt;/code&gt; trait.</source>
          <target state="translated">Наш &lt;code&gt;MyBox&amp;lt;T&amp;gt;&lt;/code&gt; нельзя разыменовать, потому что мы не реализовали эту возможность для нашего типа. Чтобы включить разыменование с помощью оператора &lt;code&gt;*&lt;/code&gt; , мы реализуем &lt;code&gt;Deref&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a9207a8de5e841e4cc95ac4f3689ea87897da5c7" translate="yes" xml:space="preserve">
          <source>Our &lt;code&gt;area&lt;/code&gt; function is now defined with one parameter, which we&amp;rsquo;ve named &lt;code&gt;rectangle&lt;/code&gt;, whose type is an immutable borrow of a struct &lt;code&gt;Rectangle&lt;/code&gt; instance. As mentioned in Chapter 4, we want to borrow the struct rather than take ownership of it. This way, &lt;code&gt;main&lt;/code&gt; retains its ownership and can continue using &lt;code&gt;rect1&lt;/code&gt;, which is the reason we use the &lt;code&gt;&amp;amp;&lt;/code&gt; in the function signature and where we call the function.</source>
          <target state="translated">Наша функция &lt;code&gt;area&lt;/code&gt; теперь определена с одним параметром, который мы назвали &lt;code&gt;rectangle&lt;/code&gt; , тип которого является неизменным заимствованием экземпляра структуры &lt;code&gt;Rectangle&lt;/code&gt; . Как упоминалось в главе 4, мы хотим заимствовать структуру, а не брать ее на себя. Таким образом, &lt;code&gt;main&lt;/code&gt; сохраняет свое право собственности и может продолжать использовать &lt;code&gt;rect1&lt;/code&gt; , что является причиной того, что мы используем &lt;code&gt;&amp;amp;&lt;/code&gt; в сигнатуре функции и где мы вызываем функцию.</target>
        </trans-unit>
        <trans-unit id="e1a3bac1f2dca57cc73f9221b0cab7bd13107caf" translate="yes" xml:space="preserve">
          <source>Our &lt;code&gt;area&lt;/code&gt; function is very specific: it only computes the area of rectangles. It would be helpful to tie this behavior more closely to our &lt;code&gt;Rectangle&lt;/code&gt; struct, because it won&amp;rsquo;t work with any other type. Let&amp;rsquo;s look at how we can continue to refactor this code by turning the &lt;code&gt;area&lt;/code&gt; function into an &lt;code&gt;area&lt;/code&gt;&lt;em&gt;method&lt;/em&gt; defined on our &lt;code&gt;Rectangle&lt;/code&gt; type.</source>
          <target state="translated">Наша функция &lt;code&gt;area&lt;/code&gt; очень специфична: она вычисляет только площадь прямоугольников. Было бы полезно более тесно связать это поведение с нашей структурой &lt;code&gt;Rectangle&lt;/code&gt; , потому что оно не будет работать ни с одним другим типом. Давайте посмотрим, как мы можем продолжать реорганизовывать этот код, поворачивая &lt;code&gt;area&lt;/code&gt; функции в &lt;code&gt;area&lt;/code&gt; &lt;em&gt;метода&lt;/em&gt; , определенного на нашем &lt;code&gt;Rectangle&lt;/code&gt; типа.</target>
        </trans-unit>
        <trans-unit id="cfaad3af2e76dcb6534645f49f572bb14dcdc4f2" translate="yes" xml:space="preserve">
          <source>Our &lt;code&gt;grep&lt;/code&gt; project will combine a number of concepts you&amp;rsquo;ve learned so far:</source>
          <target state="translated">Наш проект &lt;code&gt;grep&lt;/code&gt; объединит в себе несколько концепций, которые вы уже изучили:</target>
        </trans-unit>
        <trans-unit id="f52a72cb6754c1fcd4ce1c66bc4693a888ef0a14" translate="yes" xml:space="preserve">
          <source>Our &lt;code&gt;minigrep&lt;/code&gt; project is looking good so far! Now we&amp;rsquo;ll split the &lt;em&gt;src/main.rs&lt;/em&gt; file and put some code into the &lt;em&gt;src/lib.rs&lt;/em&gt; file so we can test it and have a &lt;em&gt;src/main.rs&lt;/em&gt; file with fewer responsibilities.</source>
          <target state="translated">Наш &lt;code&gt;minigrep&lt;/code&gt; проект пока выглядит неплохо! Теперь мы &lt;em&gt;разделим&lt;/em&gt; файл &lt;em&gt;src / main.rs&lt;/em&gt; и поместим некоторый код в файл &lt;em&gt;src / lib.rs,&lt;/em&gt; чтобы мы могли его протестировать и получить файл &lt;em&gt;src / main.rs&lt;/em&gt; с меньшими обязанностями.</target>
        </trans-unit>
        <trans-unit id="1b5e063d7a3c760c57b190162bbd9b74d1a3d4d2" translate="yes" xml:space="preserve">
          <source>Our &lt;code&gt;new&lt;/code&gt; function now returns a &lt;code&gt;Result&lt;/code&gt; with a &lt;code&gt;Config&lt;/code&gt; instance in the success case and a &lt;code&gt;&amp;amp;'static str&lt;/code&gt; in the error case. Recall from &lt;a href=&quot;ch10-03-lifetime-syntax#the-static-lifetime&quot;&gt;&amp;ldquo;The Static Lifetime&amp;rdquo;&lt;/a&gt; section in Chapter 10 that &lt;code&gt;&amp;amp;'static str&lt;/code&gt; is the type of string literals, which is our error message type for now.</source>
          <target state="translated">Наша &lt;code&gt;new&lt;/code&gt; функция теперь возвращает &lt;code&gt;Result&lt;/code&gt; с экземпляром &lt;code&gt;Config&lt;/code&gt; в случае успеха и &lt;code&gt;&amp;amp;'static str&lt;/code&gt; в случае ошибки. Вспомните из раздела &lt;a href=&quot;ch10-03-lifetime-syntax#the-static-lifetime&quot;&gt;&amp;laquo;Статическое время жизни&amp;raquo;&lt;/a&gt; в главе 10, что &lt;code&gt;&amp;amp;'static str&lt;/code&gt; - это тип строковых литералов, которые на данный момент являются нашим типом сообщения об ошибке.</target>
        </trans-unit>
        <trans-unit id="efe671180d978c835b8f59ac0f3f67492ee61022" translate="yes" xml:space="preserve">
          <source>Our concurrency mistake has caused a compile time error. The &lt;code&gt;send&lt;/code&gt; function takes ownership of its parameter, and when the value is moved, the receiver takes ownership of it. This stops us from accidentally using the value again after sending it; the ownership system checks that everything is okay.</source>
          <target state="translated">Наша ошибка параллелизма вызвала ошибку времени компиляции. Функция &lt;code&gt;send&lt;/code&gt; становится владельцем своего параметра, а когда значение перемещается, получатель становится владельцем этого параметра. Это предохраняет нас от случайного повторного использования значения после его отправки; система собственности проверяет, что все в порядке.</target>
        </trans-unit>
        <trans-unit id="a4444c88cfb7348be7065a71b67411c38cf815d8" translate="yes" xml:space="preserve">
          <source>Our first example is presented in a tree structure to elaborate on how the analysis of the matcher composes. (Some of the simpler subtrees have been elided.)</source>
          <target state="translated">Наш первый пример представлен в древовидной структуре,чтобы подробнее рассказать о том,как составлен анализ матчера.(Некоторые из более простых поддеревьев были элидированы).</target>
        </trans-unit>
        <trans-unit id="03dc9c7158dfa2429d4c3d6b283a663461fb78f3" translate="yes" xml:space="preserve">
          <source>Our library will only provide the functionality of tracking how close to the maximum a value is and what the messages should be at what times. Applications that use our library will be expected to provide the mechanism for sending the messages: the application could put a message in the application, send an email, send a text message, or something else. The library doesn&amp;rsquo;t need to know that detail. All it needs is something that implements a trait we&amp;rsquo;ll provide called &lt;code&gt;Messenger&lt;/code&gt;. Listing 15-20 shows the library code:</source>
          <target state="translated">Наша библиотека предоставит только функцию отслеживания того, насколько близко к максимуму значение и какие сообщения должны быть в какое время. Ожидается, что приложения, использующие нашу библиотеку, предоставят механизм для отправки сообщений: приложение может поместить сообщение в приложение, отправить электронное письмо, отправить текстовое сообщение или что-то еще. Библиотеке не нужно знать эту деталь. Все, что ему нужно, это что-то, что реализует черту, которую мы предоставим, под названием &lt;code&gt;Messenger&lt;/code&gt; . В листинге 15-20 показан код библиотеки:</target>
        </trans-unit>
        <trans-unit id="5e4872fe1ff4af8ea372abc0eed84c5f2cc971ce" translate="yes" xml:space="preserve">
          <source>Our library&amp;rsquo;s user can now write their &lt;code&gt;main&lt;/code&gt; function to create a &lt;code&gt;Screen&lt;/code&gt; instance. To the &lt;code&gt;Screen&lt;/code&gt; instance, they can add a &lt;code&gt;SelectBox&lt;/code&gt; and a &lt;code&gt;Button&lt;/code&gt; by putting each in a &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; to become a trait object. They can then call the &lt;code&gt;run&lt;/code&gt; method on the &lt;code&gt;Screen&lt;/code&gt; instance, which will call &lt;code&gt;draw&lt;/code&gt; on each of the components. Listing 17-9 shows this implementation:</source>
          <target state="translated">Теперь пользователь нашей библиотеки может написать свою &lt;code&gt;main&lt;/code&gt; функцию для создания экземпляра &lt;code&gt;Screen&lt;/code&gt; . К экземпляру &lt;code&gt;Screen&lt;/code&gt; они могут добавить &lt;code&gt;SelectBox&lt;/code&gt; и &lt;code&gt;Button&lt;/code&gt; , поместив каждый из них в &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; чтобы они стали типичными объектами. Затем они могут вызвать метод &lt;code&gt;run&lt;/code&gt; в экземпляре &lt;code&gt;Screen&lt;/code&gt; , который вызовет &lt;code&gt;draw&lt;/code&gt; для каждого из компонентов. В листинге 17-9 показана эта реализация:</target>
        </trans-unit>
        <trans-unit id="8f97ecd7d9bde89d0ef157149e44feaabe641749" translate="yes" xml:space="preserve">
          <source>Our solution to this problem is what we call &amp;ldquo;stability without stagnation&amp;rdquo;, and our guiding principle is this: you should never have to fear upgrading to a new version of stable Rust. Each upgrade should be painless, but should also bring you new features, fewer bugs, and faster compile times.</source>
          <target state="translated">Наше решение этой проблемы - это то, что мы называем &amp;laquo;стабильность без застоя&amp;raquo;, и наш руководящий принцип таков: вам никогда не следует бояться обновления до новой версии стабильного Rust. Каждое обновление должно быть безболезненным, но оно также должно приносить вам новые функции, меньше ошибок и более быстрое время компиляции.</target>
        </trans-unit>
        <trans-unit id="97f7b86920d282f1c8d565f0454438b9d0c724e1" translate="yes" xml:space="preserve">
          <source>Our test caught the bug! The &lt;code&gt;it_adds_two&lt;/code&gt; test failed, displaying the message &lt;code&gt;assertion failed: `(left == right)`&lt;/code&gt; and showing that &lt;code&gt;left&lt;/code&gt; was &lt;code&gt;4&lt;/code&gt; and &lt;code&gt;right&lt;/code&gt; was &lt;code&gt;5&lt;/code&gt;. This message is useful and helps us start debugging: it means the &lt;code&gt;left&lt;/code&gt; argument to &lt;code&gt;assert_eq!&lt;/code&gt; was &lt;code&gt;4&lt;/code&gt; but the &lt;code&gt;right&lt;/code&gt; argument, where we had &lt;code&gt;add_two(2)&lt;/code&gt;, was &lt;code&gt;5&lt;/code&gt;.</source>
          <target state="translated">Наш тест обнаружил ошибку! Тест &lt;code&gt;it_adds_two&lt;/code&gt; завершился неудачно, &lt;code&gt;assertion failed: `(left == right)`&lt;/code&gt; сообщения не удалось отобразить : `(left == right)` и показать, что &lt;code&gt;left&lt;/code&gt; было &lt;code&gt;4&lt;/code&gt; , а &lt;code&gt;right&lt;/code&gt; было &lt;code&gt;5&lt;/code&gt; . Это сообщение полезно и помогает нам начать отладку: оно означает &lt;code&gt;left&lt;/code&gt; аргумент &lt;code&gt;assert_eq!&lt;/code&gt; было &lt;code&gt;4&lt;/code&gt; , но &lt;code&gt;right&lt;/code&gt; аргумент, где у нас было &lt;code&gt;add_two(2)&lt;/code&gt; , был &lt;code&gt;5&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="069f6f48b22dbba6f3aadbd66c65751d3e689873" translate="yes" xml:space="preserve">
          <source>Our test passed, so we know it works!</source>
          <target state="translated">Наш тест прошел,так что мы знаем,что он работает!</target>
        </trans-unit>
        <trans-unit id="c3fb5986f91b2dcdf4f3ae02d18ace519c5ef26d" translate="yes" xml:space="preserve">
          <source>Our tests caught the bug! Because &lt;code&gt;larger.width&lt;/code&gt; is 8 and &lt;code&gt;smaller.width&lt;/code&gt; is 5, the comparison of the widths in &lt;code&gt;can_hold&lt;/code&gt; now returns &lt;code&gt;false&lt;/code&gt;: 8 is not less than 5.</source>
          <target state="translated">Наши тесты обнаружили ошибку! Поскольку &lt;code&gt;larger.width&lt;/code&gt; равно 8, а &lt;code&gt;smaller.width&lt;/code&gt; равно 5, сравнение ширины в &lt;code&gt;can_hold&lt;/code&gt; теперь возвращает &lt;code&gt;false&lt;/code&gt; : 8 не меньше 5.</target>
        </trans-unit>
        <trans-unit id="932377194a3525a80fe9e2644ba7f5912ea2df25" translate="yes" xml:space="preserve">
          <source>Our two crates are tightly related, so we create the procedural macro crate within the directory of our &lt;code&gt;hello_macro&lt;/code&gt; crate. If we change the trait definition in &lt;code&gt;hello_macro&lt;/code&gt;, we&amp;rsquo;ll have to change the implementation of the procedural macro in &lt;code&gt;hello_macro_derive&lt;/code&gt; as well. The two crates will need to be published separately, and programmers using these crates will need to add both as dependencies and bring them both into scope. We could instead have the &lt;code&gt;hello_macro&lt;/code&gt; crate use &lt;code&gt;hello_macro_derive&lt;/code&gt; as a dependency and re-export the procedural macro code. However, the way we&amp;rsquo;ve structured the project makes it possible for programmers to use &lt;code&gt;hello_macro&lt;/code&gt; even if they don&amp;rsquo;t want the &lt;code&gt;derive&lt;/code&gt; functionality.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a456009a7c6e37690dc20c96fd3a00e2535e519a" translate="yes" xml:space="preserve">
          <source>Our two crates are tightly related, so we create the procedural macro crate within the directory of our &lt;code&gt;hello_macro&lt;/code&gt; crate. If we change the trait definition in &lt;code&gt;hello_macro&lt;/code&gt;, we&amp;rsquo;ll have to change the implementation of the procedural macro in &lt;code&gt;hello_macro_derive&lt;/code&gt; as well. The two crates will need to be published separately, and programmers using these crates will need to add both as dependencies and bring them both into scope. We could instead have the &lt;code&gt;hello_macro&lt;/code&gt; crate use &lt;code&gt;hello_macro_derive&lt;/code&gt; as a dependency and reexport the procedural macro code. However, the way we&amp;rsquo;ve structured the project makes it possible for programmers to use &lt;code&gt;hello_macro&lt;/code&gt; even if they don&amp;rsquo;t want the &lt;code&gt;derive&lt;/code&gt; functionality.</source>
          <target state="translated">Наши два ящика тесно связаны, поэтому мы создаем ящик процедурных макросов в каталоге нашего ящика &lt;code&gt;hello_macro&lt;/code&gt; . Если мы изменим определение трейта в &lt;code&gt;hello_macro&lt;/code&gt; , нам также придется изменить реализацию процедурного макроса в &lt;code&gt;hello_macro_derive&lt;/code&gt; . Два ящика необходимо будет опубликовать отдельно, и программисты, использующие эти ящики, должны будут добавить оба в качестве зависимостей и включить их в область видимости. Мы могли бы вместо того, чтобы иметь &lt;code&gt;hello_macro&lt;/code&gt; использовать клеть &lt;code&gt;hello_macro_derive&lt;/code&gt; как зависимость и реэкспорт процедурного кода макроса. Однако то, как мы структурировали проект, позволяет программистам использовать &lt;code&gt;hello_macro&lt;/code&gt; , даже если они не хотят &lt;code&gt;derive&lt;/code&gt; функциональность.</target>
        </trans-unit>
        <trans-unit id="d04d54136e7055f33bb3e1bbb4cb0ac4fca594a8" translate="yes" xml:space="preserve">
          <source>Our web server needs to listen to a TCP connection, so that&amp;rsquo;s the first part we&amp;rsquo;ll work on. The standard library offers a &lt;code&gt;std::net&lt;/code&gt; module that lets us do this. Let&amp;rsquo;s make a new project in the usual fashion:</source>
          <target state="translated">Нашему веб-серверу необходимо прослушивать TCP-соединение, так что это первая часть, над которой мы будем работать. Стандартная библиотека предлагает модуль &lt;code&gt;std::net&lt;/code&gt; который позволяет нам это делать. Сделаем новый проект обычным способом:</target>
        </trans-unit>
        <trans-unit id="17e421fbadb43b474b631f0045b2106bd87824cc" translate="yes" xml:space="preserve">
          <source>Out-of-order execution</source>
          <target state="translated">исполнение по заказу</target>
        </trans-unit>
        <trans-unit id="730dfeeb12a571e95bc1961c0b2230a903923296" translate="yes" xml:space="preserve">
          <source>Outer attribute</source>
          <target state="translated">Внешний признак</target>
        </trans-unit>
        <trans-unit id="2522054e66f17e8ce74357f93aa3d55cec3e5c37" translate="yes" xml:space="preserve">
          <source>Outer attributes are allowed on match arms. The only attributes that have meaning on match arms are &lt;a href=&quot;../conditional-compilation&quot;&gt;&lt;code&gt;cfg&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../attributes/codegen#the-cold-attribute&quot;&gt;&lt;code&gt;cold&lt;/code&gt;&lt;/a&gt;, and the &lt;a href=&quot;../attributes/diagnostics#lint-check-attributes&quot;&gt;lint check attributes&lt;/a&gt;.</source>
          <target state="translated">На спичечном оружии разрешены внешние атрибуты. Единственные атрибуты, которые имеют значение на &lt;a href=&quot;../conditional-compilation&quot;&gt; &lt;code&gt;cfg&lt;/code&gt; &lt;/a&gt; , - это &lt;a href=&quot;../attributes/diagnostics#lint-check-attributes&quot;&gt;атрибуты &lt;/a&gt;cfg , &lt;a href=&quot;../attributes/codegen#the-cold-attribute&quot;&gt; &lt;code&gt;cold&lt;/code&gt; &lt;/a&gt; и lint check .</target>
        </trans-unit>
        <trans-unit id="e17ac49e59e3c24f65b6eb7eb800c128e2d0327f" translate="yes" xml:space="preserve">
          <source>Outer block doc comment</source>
          <target state="translated">Внешний блок документальный комментарий</target>
        </trans-unit>
        <trans-unit id="49bb2a2dcd1d2f083a137acbbd937d73adfc4ddf" translate="yes" xml:space="preserve">
          <source>Outer line doc comment</source>
          <target state="translated">Внешняя строка документальный комментарий</target>
        </trans-unit>
        <trans-unit id="4bed336194a9a5c86b6a734f03b3570d2aae1a68" translate="yes" xml:space="preserve">
          <source>Output</source>
          <target state="translated">Output</target>
        </trans-unit>
        <trans-unit id="d1823c68a7e59aee497eaf6bcce7cab74d25109b" translate="yes" xml:space="preserve">
          <source>Output::borrow</source>
          <target state="translated">Output::borrow</target>
        </trans-unit>
        <trans-unit id="bd4894b30dacbb463e4f9b290aef62366ceaea5b" translate="yes" xml:space="preserve">
          <source>Output::borrow_mut</source>
          <target state="translated">Output::borrow_mut</target>
        </trans-unit>
        <trans-unit id="91e25cbffb5245c6c4c63c7f061f2d786fdb521f" translate="yes" xml:space="preserve">
          <source>Output::clone</source>
          <target state="translated">Output::clone</target>
        </trans-unit>
        <trans-unit id="6df4f0510aea77969aaaa10e205502ea42c93963" translate="yes" xml:space="preserve">
          <source>Output::clone_from</source>
          <target state="translated">Output::clone_from</target>
        </trans-unit>
        <trans-unit id="687e30cb7117f28eda51e39e7bab28b83cc9e405" translate="yes" xml:space="preserve">
          <source>Output::clone_into</source>
          <target state="translated">Output::clone_into</target>
        </trans-unit>
        <trans-unit id="3032d1424e084a9f76413e7e6788cdfd8a67b58a" translate="yes" xml:space="preserve">
          <source>Output::eq</source>
          <target state="translated">Output::eq</target>
        </trans-unit>
        <trans-unit id="865dec7fa701b8a9ca5f805a39100052bfe318b6" translate="yes" xml:space="preserve">
          <source>Output::fmt</source>
          <target state="translated">Output::fmt</target>
        </trans-unit>
        <trans-unit id="993990d97649b770ccd9d98ea8487d704986b6d9" translate="yes" xml:space="preserve">
          <source>Output::from</source>
          <target state="translated">Output::from</target>
        </trans-unit>
        <trans-unit id="5b9601c898cded464f2e06dadaf7ab7c9741cd5c" translate="yes" xml:space="preserve">
          <source>Output::into</source>
          <target state="translated">Output::into</target>
        </trans-unit>
        <trans-unit id="1c87bedb995cad24d365f47966cbd4346b591666" translate="yes" xml:space="preserve">
          <source>Output::ne</source>
          <target state="translated">Output::ne</target>
        </trans-unit>
        <trans-unit id="62c76b51d4718e2ffcbe3b7aa04ddda3b2b70e94" translate="yes" xml:space="preserve">
          <source>Output::to_owned</source>
          <target state="translated">Output::to_owned</target>
        </trans-unit>
        <trans-unit id="9a87d3e2cc9f1d250bfa315a36823fa4cbec36e3" translate="yes" xml:space="preserve">
          <source>Output::try_from</source>
          <target state="translated">Output::try_from</target>
        </trans-unit>
        <trans-unit id="5be92053871d2c9c72d6bad5e8965eb4276aed9e" translate="yes" xml:space="preserve">
          <source>Output::try_into</source>
          <target state="translated">Output::try_into</target>
        </trans-unit>
        <trans-unit id="a0027fc28599b52fba5b8c93b690e40203fbae0a" translate="yes" xml:space="preserve">
          <source>Output::type_id</source>
          <target state="translated">Output::type_id</target>
        </trans-unit>
        <trans-unit id="fc89893a1de62fd92a4d6c68804db741e3ea0dcd" translate="yes" xml:space="preserve">
          <source>Outputs the detailed cause of parsing an integer failing.</source>
          <target state="translated">Выводит подробную причину неудачного разбора целого числа.</target>
        </trans-unit>
        <trans-unit id="f456860c31542ff957a3adb8014b9119de57fc9b" translate="yes" xml:space="preserve">
          <source>Outside of the defining crate, types annotated with &lt;code&gt;non_exhaustive&lt;/code&gt; have limitations that preserve backwards compatibility when new fields or variants are added.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4da7bc9200c71949eae8135d4a25bb5b299cf7cc" translate="yes" xml:space="preserve">
          <source>Overflow</source>
          <target state="translated">Overflow</target>
        </trans-unit>
        <trans-unit id="3467b7b5de17cb6f124e7f7c4127e41ae85ffcdf" translate="yes" xml:space="preserve">
          <source>Overflow Behavior</source>
          <target state="translated">Поведение при переполнении</target>
        </trans-unit>
        <trans-unit id="91ff3d30af6aecf4f3bfff401ee0c4026a8aeafc" translate="yes" xml:space="preserve">
          <source>Overflow behavior</source>
          <target state="translated">Поведение при переполнении</target>
        </trans-unit>
        <trans-unit id="268ceeb8fd762749a7c0aa0e18a308d2a3e0eae9" translate="yes" xml:space="preserve">
          <source>Overflowing Euclidean remainder. Calculates &lt;code&gt;self.rem_euclid(rhs)&lt;/code&gt;.</source>
          <target state="translated">Превосходный евклидов остаток. Вычисляет &lt;code&gt;self.rem_euclid(rhs)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1a536f91d51d79c240c5d894b51ca7769b45b744" translate="yes" xml:space="preserve">
          <source>Overloadable operators.</source>
          <target state="translated">Перегружаемые операторы.</target>
        </trans-unit>
        <trans-unit id="40546cb9c881ab1291c600fcc0df156813d3befe" translate="yes" xml:space="preserve">
          <source>Overloadable?</source>
          <target state="translated">Overloadable?</target>
        </trans-unit>
        <trans-unit id="1541c7c02fe167096e792d52736b0810a9fb3cfa" translate="yes" xml:space="preserve">
          <source>Overloading Trait</source>
          <target state="translated">Перегрузочный канал</target>
        </trans-unit>
        <trans-unit id="76ecfec5f0e4ba427d318353841c4d754fd5e25f" translate="yes" xml:space="preserve">
          <source>Overloading Traits</source>
          <target state="translated">Перегрузочные пути</target>
        </trans-unit>
        <trans-unit id="39a5b884e85ec2d623399dce4a7f443948a467bd" translate="yes" xml:space="preserve">
          <source>Overloading method</source>
          <target state="translated">способ перегрузки</target>
        </trans-unit>
        <trans-unit id="2304de1bde1f4f91ef0e295fad1655647768d0a1" translate="yes" xml:space="preserve">
          <source>Overrides the &lt;code&gt;dwDesiredAccess&lt;/code&gt; argument to the call to &lt;a href=&quot;https://docs.microsoft.com/en-us/windows/win32/api/fileapi/nf-fileapi-createfilea&quot;&gt;&lt;code&gt;CreateFile&lt;/code&gt;&lt;/a&gt; with the specified value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5d6da6029474f8062969b88fdeb581d72daa0b18" translate="yes" xml:space="preserve">
          <source>Overrides the &lt;code&gt;dwDesiredAccess&lt;/code&gt; argument to the call to &lt;a href=&quot;https://docs.microsoft.com/en-us/windows/win32/api/fileapi/nf-fileapi-createfilea&quot;&gt;&lt;code&gt;CreateFile&lt;/code&gt;&lt;/a&gt; with the specified value. &lt;a href=&quot;../os/windows/fs/trait.openoptionsext#tymethod.access_mode&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bd333bcce81d89530a67062d3af83d0e05013841" translate="yes" xml:space="preserve">
          <source>Overrides the &lt;code&gt;dwDesiredAccess&lt;/code&gt; argument to the call to &lt;a href=&quot;https://msdn.microsoft.com/en-us/library/windows/desktop/aa363858.aspx&quot;&gt;&lt;code&gt;CreateFile&lt;/code&gt;&lt;/a&gt; with the specified value.</source>
          <target state="translated">Переопределяет аргумент &lt;code&gt;dwDesiredAccess&lt;/code&gt; для вызова &lt;a href=&quot;https://msdn.microsoft.com/en-us/library/windows/desktop/aa363858.aspx&quot;&gt; &lt;code&gt;CreateFile&lt;/code&gt; &lt;/a&gt; с указанным значением.</target>
        </trans-unit>
        <trans-unit id="6c959035dcdad00a6f6547d8f9d2286eb95a249a" translate="yes" xml:space="preserve">
          <source>Overrides the &lt;code&gt;dwDesiredAccess&lt;/code&gt; argument to the call to [&lt;code&gt;CreateFile&lt;/code&gt;] with the specified value. &lt;a href=&quot;../os/windows/fs/trait.openoptionsext#tymethod.access_mode&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">Переопределяет аргумент &lt;code&gt;dwDesiredAccess&lt;/code&gt; для вызова [ &lt;code&gt;CreateFile&lt;/code&gt; ] с указанным значением. &lt;a href=&quot;../os/windows/fs/trait.openoptionsext#tymethod.access_mode&quot;&gt;Читать далее&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="f75345eeea8107cdd449ddf381cab1978912715e" translate="yes" xml:space="preserve">
          <source>Overrides the &lt;code&gt;dwShareMode&lt;/code&gt; argument to the call to &lt;a href=&quot;https://docs.microsoft.com/en-us/windows/win32/api/fileapi/nf-fileapi-createfilea&quot;&gt;&lt;code&gt;CreateFile&lt;/code&gt;&lt;/a&gt; with the specified value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3e26cda912f98913d10a65d39724557408f3a607" translate="yes" xml:space="preserve">
          <source>Overrides the &lt;code&gt;dwShareMode&lt;/code&gt; argument to the call to &lt;a href=&quot;https://docs.microsoft.com/en-us/windows/win32/api/fileapi/nf-fileapi-createfilea&quot;&gt;&lt;code&gt;CreateFile&lt;/code&gt;&lt;/a&gt; with the specified value. &lt;a href=&quot;../os/windows/fs/trait.openoptionsext#tymethod.share_mode&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b87109866c9e881094fc3108cb2582359d9f6aa9" translate="yes" xml:space="preserve">
          <source>Overrides the &lt;code&gt;dwShareMode&lt;/code&gt; argument to the call to &lt;a href=&quot;https://msdn.microsoft.com/en-us/library/windows/desktop/aa363858.aspx&quot;&gt;&lt;code&gt;CreateFile&lt;/code&gt;&lt;/a&gt; with the specified value.</source>
          <target state="translated">Переопределяет аргумент &lt;code&gt;dwShareMode&lt;/code&gt; для вызова &lt;a href=&quot;https://msdn.microsoft.com/en-us/library/windows/desktop/aa363858.aspx&quot;&gt; &lt;code&gt;CreateFile&lt;/code&gt; &lt;/a&gt; с указанным значением.</target>
        </trans-unit>
        <trans-unit id="cf2d85760bd185994ef5bf2f175143dec9ca3909" translate="yes" xml:space="preserve">
          <source>Overrides the &lt;code&gt;dwShareMode&lt;/code&gt; argument to the call to [&lt;code&gt;CreateFile&lt;/code&gt;] with the specified value. &lt;a href=&quot;../os/windows/fs/trait.openoptionsext#tymethod.share_mode&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">Переопределяет аргумент &lt;code&gt;dwShareMode&lt;/code&gt; для вызова [ &lt;code&gt;CreateFile&lt;/code&gt; ] с указанным значением. &lt;a href=&quot;../os/windows/fs/trait.openoptionsext#tymethod.share_mode&quot;&gt;Читать далее&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="0efc2e6be4c23b9a513d7ce0dcff8ed80e8912e7" translate="yes" xml:space="preserve">
          <source>Overview</source>
          <target state="translated">Overview</target>
        </trans-unit>
        <trans-unit id="cd8f194e8d7e958260d7af2051984d8f3e683b51" translate="yes" xml:space="preserve">
          <source>Overwrites a memory location with the given value without reading or dropping the old value.</source>
          <target state="translated">Перезаписывает ячейку памяти с заданным значением без считывания или сброса старого значения.</target>
        </trans-unit>
        <trans-unit id="949a410afc355b96a7905ccc83a834749836d22c" translate="yes" xml:space="preserve">
          <source>Overwriting a Value</source>
          <target state="translated">Перезапись стоимости</target>
        </trans-unit>
        <trans-unit id="5ebf9d2abbf1cc7aae1c696ee32449969d19a22c" translate="yes" xml:space="preserve">
          <source>Owned data.</source>
          <target state="translated">Собственные данные.</target>
        </trans-unit>
        <trans-unit id="4fbf13be9f8b7616cdb154755370e6d320e7e90d" translate="yes" xml:space="preserve">
          <source>Ownership Rules</source>
          <target state="translated">Правила владения</target>
        </trans-unit>
        <trans-unit id="1340f6fc9cc4c2d08ca6cee78e483a7eadf7311f" translate="yes" xml:space="preserve">
          <source>Ownership affects how lots of other parts of Rust work, so we&amp;rsquo;ll talk about these concepts further throughout the rest of the book. Let&amp;rsquo;s move on to Chapter 5 and look at grouping pieces of data together in a &lt;code&gt;struct&lt;/code&gt;.</source>
          <target state="translated">Право собственности влияет на работу многих других частей Rust, поэтому мы будем говорить об этих концепциях далее в оставшейся части книги. Перейдем к главе 5 и посмотрим, как объединить фрагменты данных в &lt;code&gt;struct&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="061f3ef75cdf7d220844151ec65f84114fd6c667" translate="yes" xml:space="preserve">
          <source>Ownership and Functions</source>
          <target state="translated">Собственность и функции</target>
        </trans-unit>
        <trans-unit id="e783f9dc891702d006be5ffb27e982821fefa6e5" translate="yes" xml:space="preserve">
          <source>Ownership and the drop check</source>
          <target state="translated">Собственность и проверка на падение</target>
        </trans-unit>
        <trans-unit id="dd97430c54818d57ae7f4721676609e1836384c3" translate="yes" xml:space="preserve">
          <source>Ownership is Rust&amp;rsquo;s most unique feature, and it enables Rust to make memory safety guarantees without needing a garbage collector. Therefore, it&amp;rsquo;s important to understand how ownership works in Rust. In this chapter, we&amp;rsquo;ll talk about ownership as well as several related features: borrowing, slices, and how Rust lays data out in memory.</source>
          <target state="translated">Владение - это самая уникальная особенность Rust, и она позволяет Rust гарантировать безопасность памяти без использования сборщика мусора. Поэтому важно понимать, как работает владение в Rust. В этой главе мы поговорим о владении, а также о некоторых связанных функциях: заимствовании, срезах и о том, как Rust размещает данные в памяти.</target>
        </trans-unit>
        <trans-unit id="7bcd32d1ab543a47fbd7ea77937460f4ae2b2e40" translate="yes" xml:space="preserve">
          <source>Ownership of Struct Data</source>
          <target state="translated">Владение данными о структуре</target>
        </trans-unit>
        <trans-unit id="7d0b385e3bf746d2a40063b477100d32fc06fbb3" translate="yes" xml:space="preserve">
          <source>Ownership of the Returned Value</source>
          <target state="translated">Право собственности на возвращаемую стоимость</target>
        </trans-unit>
        <trans-unit id="fa7ff6fb00a7ace8d98cf880a492dc6c5ffc8ca7" translate="yes" xml:space="preserve">
          <source>PI</source>
          <target state="translated">PI</target>
        </trans-unit>
        <trans-unit id="99a088ed6d9619a992c784e598231666dc79ef59" translate="yes" xml:space="preserve">
          <source>Packages and Crates</source>
          <target state="translated">Пакеты и ящики</target>
        </trans-unit>
        <trans-unit id="d6664ac6a163b68baf85aa80b0de081ae92d3945" translate="yes" xml:space="preserve">
          <source>Panic support in the standard library.</source>
          <target state="translated">Поддержка паники в стандартной библиотеке.</target>
        </trans-unit>
        <trans-unit id="e69c39e691255780ecc80f46bb976506c1d6aca2" translate="yes" xml:space="preserve">
          <source>Panic the current thread with the given message as the panic payload.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="64750ba8905f79ec9b27121f796de54641de81e8" translate="yes" xml:space="preserve">
          <source>Panic-free bitwise shift-left; yields &lt;code&gt;self &amp;lt;&amp;lt; mask(rhs)&lt;/code&gt;, where &lt;code&gt;mask&lt;/code&gt; removes any high-order bits of &lt;code&gt;rhs&lt;/code&gt; that would cause the shift to exceed the bitwidth of the type.</source>
          <target state="translated">Побитовый сдвиг влево без паники; дает &lt;code&gt;self &amp;lt;&amp;lt; mask(rhs)&lt;/code&gt; , где &lt;code&gt;mask&lt;/code&gt; удаляет все старшие биты &lt;code&gt;rhs&lt;/code&gt; , которые могут привести к тому, что сдвиг превысит разрядность типа.</target>
        </trans-unit>
        <trans-unit id="8aa0a650679136bf5c6a5c931f1774da4aa63dd5" translate="yes" xml:space="preserve">
          <source>Panic-free bitwise shift-right; yields &lt;code&gt;self &amp;gt;&amp;gt; mask(rhs)&lt;/code&gt;, where &lt;code&gt;mask&lt;/code&gt; removes any high-order bits of &lt;code&gt;rhs&lt;/code&gt; that would cause the shift to exceed the bitwidth of the type.</source>
          <target state="translated">Побитовый сдвиг вправо без паники; дает &lt;code&gt;self &amp;gt;&amp;gt; mask(rhs)&lt;/code&gt; , где &lt;code&gt;mask&lt;/code&gt; удаляет все старшие биты &lt;code&gt;rhs&lt;/code&gt; , которые могут привести к тому, что сдвиг превысит разрядность типа.</target>
        </trans-unit>
        <trans-unit id="ab31f4ac9fc3c9e915343e6e27bd26eabe596bd8" translate="yes" xml:space="preserve">
          <source>PanicInfo</source>
          <target state="translated">PanicInfo</target>
        </trans-unit>
        <trans-unit id="643cc2152accd53993d549a5d958a2a8112c605d" translate="yes" xml:space="preserve">
          <source>PanicInfo::borrow</source>
          <target state="translated">PanicInfo::borrow</target>
        </trans-unit>
        <trans-unit id="6f87929cce7f37a4643cf9668cce7fd2a3c0a867" translate="yes" xml:space="preserve">
          <source>PanicInfo::borrow_mut</source>
          <target state="translated">PanicInfo::borrow_mut</target>
        </trans-unit>
        <trans-unit id="0627e71cb9d2ea5c4e376502d4b534944d95a2b5" translate="yes" xml:space="preserve">
          <source>PanicInfo::fmt</source>
          <target state="translated">PanicInfo::fmt</target>
        </trans-unit>
        <trans-unit id="a75f88ef036635c57bb6c3f294eb1864b080d92b" translate="yes" xml:space="preserve">
          <source>PanicInfo::from</source>
          <target state="translated">PanicInfo::from</target>
        </trans-unit>
        <trans-unit id="f5d51dd33ffc0fc2d5c8579f0762bbffa7356d33" translate="yes" xml:space="preserve">
          <source>PanicInfo::into</source>
          <target state="translated">PanicInfo::into</target>
        </trans-unit>
        <trans-unit id="1a5376f14ebb31aa62bb71354df743f4ab22d90f" translate="yes" xml:space="preserve">
          <source>PanicInfo::location</source>
          <target state="translated">PanicInfo::location</target>
        </trans-unit>
        <trans-unit id="f4f5b6dcf5ba5934d97c8506165f90b66a53635d" translate="yes" xml:space="preserve">
          <source>PanicInfo::message</source>
          <target state="translated">PanicInfo::message</target>
        </trans-unit>
        <trans-unit id="41ad71622e704da94b5ec33eec78cbe35e9d9051" translate="yes" xml:space="preserve">
          <source>PanicInfo::payload</source>
          <target state="translated">PanicInfo::payload</target>
        </trans-unit>
        <trans-unit id="0c5da16342c18730d19426fb04fb7d13e95927ef" translate="yes" xml:space="preserve">
          <source>PanicInfo::to_string</source>
          <target state="translated">PanicInfo::to_string</target>
        </trans-unit>
        <trans-unit id="128dfe7ed8ea9040dfa6b755a8f58a058809a754" translate="yes" xml:space="preserve">
          <source>PanicInfo::try_from</source>
          <target state="translated">PanicInfo::try_from</target>
        </trans-unit>
        <trans-unit id="124e8d1366dede099902e66296c0fd7c941d22c8" translate="yes" xml:space="preserve">
          <source>PanicInfo::try_into</source>
          <target state="translated">PanicInfo::try_into</target>
        </trans-unit>
        <trans-unit id="7d559bee200d64d9ed14e627440fc27efa09a6ed" translate="yes" xml:space="preserve">
          <source>PanicInfo::type_id</source>
          <target state="translated">PanicInfo::type_id</target>
        </trans-unit>
        <trans-unit id="b6d2a57e62de0b05a8e65f1687e4f544c18dd949" translate="yes" xml:space="preserve">
          <source>Panics</source>
          <target state="translated">Panics</target>
        </trans-unit>
        <trans-unit id="3f15b674a181b9dd8657cd84469dac52f9c96550" translate="yes" xml:space="preserve">
          <source>Panics if &lt;code&gt;N&lt;/code&gt; is 0. This check will most probably get changed to a compile time error before this method gets stabilized.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="45e26bbcde013da7d92e500c033afb14073380bf" translate="yes" xml:space="preserve">
          <source>Panics if &lt;code&gt;a&lt;/code&gt; or &lt;code&gt;b&lt;/code&gt; are out of bounds.</source>
          <target state="translated">Паникует, если &lt;code&gt;a&lt;/code&gt; или &lt;code&gt;b&lt;/code&gt; находятся за пределами поля.</target>
        </trans-unit>
        <trans-unit id="e3cf74e01d7358bfd9a5fe8f5999d1266efbbdf0" translate="yes" xml:space="preserve">
          <source>Panics if &lt;code&gt;at &amp;gt; len&lt;/code&gt;.</source>
          <target state="translated">Паника, если &lt;code&gt;at &amp;gt; len&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9a00b9bcb539cbd67965e71599dbb2232d727abe" translate="yes" xml:space="preserve">
          <source>Panics if &lt;code&gt;at&lt;/code&gt; is not on a &lt;code&gt;UTF-8&lt;/code&gt; code point boundary, or if it is beyond the last code point of the string.</source>
          <target state="translated">Паникает, если &lt;code&gt;at&lt;/code&gt; не находится на границе кодовой точки &lt;code&gt;UTF-8&lt;/code&gt; или находится за пределами последней кодовой точки строки.</target>
        </trans-unit>
        <trans-unit id="cc29dc108576e18e0990d54dd465b6a57e3a4505" translate="yes" xml:space="preserve">
          <source>Panics if &lt;code&gt;begin&lt;/code&gt; does not point to the starting byte offset of a character (as defined by &lt;code&gt;is_char_boundary&lt;/code&gt;), if &lt;code&gt;end&lt;/code&gt; does not point to the ending byte offset of a character (&lt;code&gt;end + 1&lt;/code&gt; is either a starting byte offset or equal to &lt;code&gt;len&lt;/code&gt;), if &lt;code&gt;begin &amp;gt; end&lt;/code&gt;, or if &lt;code&gt;end &amp;gt;= len&lt;/code&gt;.</source>
          <target state="translated">Паникает, если &lt;code&gt;begin&lt;/code&gt; не указывает на смещение начального байта символа (как определено &lt;code&gt;is_char_boundary&lt;/code&gt; ), если &lt;code&gt;end&lt;/code&gt; не указывает на смещение &lt;code&gt;end + 1&lt;/code&gt; байта символа ( end + 1 является либо смещением начального байта, либо равным &lt;code&gt;len&lt;/code&gt; ), если &lt;code&gt;begin &amp;gt; end&lt;/code&gt; , или если &lt;code&gt;end &amp;gt;= len&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="cdce63887d8794a1745f1a7cccaa08d82fd51111" translate="yes" xml:space="preserve">
          <source>Panics if &lt;code&gt;begin&lt;/code&gt; does not point to the starting byte offset of a character (as defined by &lt;code&gt;is_char_boundary&lt;/code&gt;), or if &lt;code&gt;begin &amp;gt; len&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d883f0070f09958226988ed7cfef750adf9a7212" translate="yes" xml:space="preserve">
          <source>Panics if &lt;code&gt;begin&lt;/code&gt; does not point to the starting byte offset of a character (as defined by &lt;code&gt;is_char_boundary&lt;/code&gt;), or if &lt;code&gt;begin &amp;gt;= len&lt;/code&gt;.</source>
          <target state="translated">Паникает, если &lt;code&gt;begin&lt;/code&gt; не указывает на смещение начального байта символа (как определено &lt;code&gt;is_char_boundary&lt;/code&gt; ) или если &lt;code&gt;begin &amp;gt;= len&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="227c67bc70f8605678180bb1c51bde64cbfc241f" translate="yes" xml:space="preserve">
          <source>Panics if &lt;code&gt;begin&lt;/code&gt; or &lt;code&gt;end&lt;/code&gt; does not point to the starting byte offset of a character (as defined by &lt;code&gt;is_char_boundary&lt;/code&gt;), if &lt;code&gt;begin &amp;gt; end&lt;/code&gt;, or if &lt;code&gt;end &amp;gt; len&lt;/code&gt;.</source>
          <target state="translated">Паникает, если &lt;code&gt;begin&lt;/code&gt; или &lt;code&gt;end&lt;/code&gt; не указывает на смещение начального байта символа (как определено &lt;code&gt;is_char_boundary&lt;/code&gt; ), если &lt;code&gt;begin &amp;gt; end&lt;/code&gt; или &lt;code&gt;end &amp;gt; len&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e87f5b8a7bcf907dca18470bd2c4295b8f82a333" translate="yes" xml:space="preserve">
          <source>Panics if &lt;code&gt;chunk_size&lt;/code&gt; is 0.</source>
          <target state="translated">&lt;code&gt;chunk_size&lt;/code&gt; если chunk_size равен 0.</target>
        </trans-unit>
        <trans-unit id="b26629f2e9cb257daf9479ce741e24d310ef11cc" translate="yes" xml:space="preserve">
          <source>Panics if &lt;code&gt;end&lt;/code&gt; does not point to the ending byte offset of a character (&lt;code&gt;end + 1&lt;/code&gt; is either a starting byte offset as defined by &lt;code&gt;is_char_boundary&lt;/code&gt;, or equal to &lt;code&gt;len&lt;/code&gt;), or if &lt;code&gt;end &amp;gt;= len&lt;/code&gt;.</source>
          <target state="translated">Паникает, если &lt;code&gt;end&lt;/code&gt; не указывает на смещение &lt;code&gt;end + 1&lt;/code&gt; байта символа ( end + 1 является либо смещением начального байта, как определено &lt;code&gt;is_char_boundary&lt;/code&gt; , либо равным &lt;code&gt;len&lt;/code&gt; ), или если &lt;code&gt;end &amp;gt;= len&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6581cda5b120f3ca8bd07261fc66544bbbb296d9" translate="yes" xml:space="preserve">
          <source>Panics if &lt;code&gt;end&lt;/code&gt; does not point to the starting byte offset of a character (as defined by &lt;code&gt;is_char_boundary&lt;/code&gt;), or if &lt;code&gt;end &amp;gt; len&lt;/code&gt;.</source>
          <target state="translated">Паникает, если &lt;code&gt;end&lt;/code&gt; не указывает на смещение начального байта символа (как определено &lt;code&gt;is_char_boundary&lt;/code&gt; ) или если &lt;code&gt;end &amp;gt; len&lt;/code&gt; .</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
