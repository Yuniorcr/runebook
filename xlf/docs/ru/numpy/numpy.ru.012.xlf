<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ru" datatype="htmlbody" original="numpy">
    <body>
      <group id="numpy">
        <trans-unit id="67373bb92cd7ecbf243edb9d60ad6f00f86a6052" translate="yes" xml:space="preserve">
          <source>See Also</source>
          <target state="translated">См.также</target>
        </trans-unit>
        <trans-unit id="2d8243a2c0e464492c9d563c4f92c56ae3421bcc" translate="yes" xml:space="preserve">
          <source>See also</source>
          <target state="translated">См.также</target>
        </trans-unit>
        <trans-unit id="1234129c54dee52191f9a009e54d14ba3cd7901d" translate="yes" xml:space="preserve">
          <source>See also the corresponding attribute of the derived class of interest.</source>
          <target state="translated">См.также соответствующий атрибут производного класса интереса.</target>
        </trans-unit>
        <trans-unit id="83750efeee588beded293ee3f9269da81e7c7a09" translate="yes" xml:space="preserve">
          <source>See the &lt;a href=&quot;generated/numpy.einsum#numpy.einsum&quot;&gt;&lt;code&gt;einsum&lt;/code&gt;&lt;/a&gt; function for more details.</source>
          <target state="translated">Подробнее см. &lt;a href=&quot;generated/numpy.einsum#numpy.einsum&quot;&gt; &lt;code&gt;einsum&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="b4f3fbbc86b01e081d4bf3029eeb047323af050f" translate="yes" xml:space="preserve">
          <source>See the class docstring for the number of bits returned.</source>
          <target state="translated">Количество возвращаемых битов указано в документации класса.</target>
        </trans-unit>
        <trans-unit id="c83ee6459f11d959cce47b344352f4193d454359" translate="yes" xml:space="preserve">
          <source>See the function &lt;a href=&quot;#c.PyArray_MinScalarType&quot;&gt;&lt;code&gt;PyArray_MinScalarType&lt;/code&gt;&lt;/a&gt; for an alternative mechanism introduced in NumPy 1.6.0.</source>
          <target state="translated">См. Функцию &lt;a href=&quot;#c.PyArray_MinScalarType&quot;&gt; &lt;code&gt;PyArray_MinScalarType&lt;/code&gt; &lt;/a&gt; для альтернативного механизма, представленного в NumPy 1.6.0.</target>
        </trans-unit>
        <trans-unit id="5b5e9065c0e163926104e92911bff64adedee471" translate="yes" xml:space="preserve">
          <source>See the function &lt;a href=&quot;#c.PyArray_ResultType&quot;&gt;&lt;code&gt;PyArray_ResultType&lt;/code&gt;&lt;/a&gt; for details of NumPy type promotion, updated in NumPy 1.6.0.</source>
          <target state="translated">См. Функцию &lt;a href=&quot;#c.PyArray_ResultType&quot;&gt; &lt;code&gt;PyArray_ResultType&lt;/code&gt; &lt;/a&gt; для получения подробной информации о продвижении типа NumPy, обновленной в NumPy 1.6.0.</target>
        </trans-unit>
        <trans-unit id="27b980b7065c19a238ed0ab9383f5a540a5d637c" translate="yes" xml:space="preserve">
          <source>See the more detailed documentation for &lt;code&gt;numpy.diagonal&lt;/code&gt; if you use this function to extract a diagonal and wish to write to the resulting array; whether it returns a copy or a view depends on what version of numpy you are using.</source>
          <target state="translated">См. Более подробную документацию для &lt;code&gt;numpy.diagonal&lt;/code&gt; , если вы используете эту функцию для извлечения диагонали и хотите записать в результирующий массив; возвращает ли он копию или представление, зависит от того, какую версию numpy вы используете.</target>
        </trans-unit>
        <trans-unit id="a367dbe20937470e410dfbea9585fd8048f1569d" translate="yes" xml:space="preserve">
          <source>See the notes and examples for clarification.</source>
          <target state="translated">См.примечания и примеры для пояснения.</target>
        </trans-unit>
        <trans-unit id="ed05825174e3134f290feabd650cdebd78790e5d" translate="yes" xml:space="preserve">
          <source>See the notes for an outline of the algorithm.</source>
          <target state="translated">Очертания алгоритма см.в примечаниях.</target>
        </trans-unit>
        <trans-unit id="2de41805fe60d43135ccbebaad2f5782594f2632" translate="yes" xml:space="preserve">
          <source>SeedSequence mixes sources of entropy in a reproducible way to set the initial state for independent and very probably non-overlapping BitGenerators.</source>
          <target state="translated">SeedSequence смешивает источники энтропии воспроизводимым способом,чтобы установить исходное состояние для независимых и,очень вероятно,не перекрывающихся BitGenerators.</target>
        </trans-unit>
        <trans-unit id="c837283b736981a9d882e30832f45d2c3a206514" translate="yes" xml:space="preserve">
          <source>SeedSequence spawning</source>
          <target state="translated">SeedSequence нерест</target>
        </trans-unit>
        <trans-unit id="28355ed4d1be051fdd750124cc876d1fa222f5c2" translate="yes" xml:space="preserve">
          <source>SeedSequence.entropy</source>
          <target state="translated">SeedSequence.entropy</target>
        </trans-unit>
        <trans-unit id="03d7f2826ccb833676fbe70c0022e77d2e2c9c55" translate="yes" xml:space="preserve">
          <source>SeedSequence.generate_state()</source>
          <target state="translated">SeedSequence.generate_state()</target>
        </trans-unit>
        <trans-unit id="c4d5a701757a2a9341845319c69171cb1c646cf5" translate="yes" xml:space="preserve">
          <source>SeedSequence.spawn()</source>
          <target state="translated">SeedSequence.spawn()</target>
        </trans-unit>
        <trans-unit id="9ba62987b34fe8fc63485d9dd7e815f3286c5601" translate="yes" xml:space="preserve">
          <source>SeedSequence.spawn_key</source>
          <target state="translated">SeedSequence.spawn_key</target>
        </trans-unit>
        <trans-unit id="8803a737a63e4b3f599d7264c369bdc58f640281" translate="yes" xml:space="preserve">
          <source>Seeding and Entropy</source>
          <target state="translated">Посев и энтропия</target>
        </trans-unit>
        <trans-unit id="e478fbf4bf9d911f2c366f8992866e1d7b083794" translate="yes" xml:space="preserve">
          <source>Seeding and State</source>
          <target state="translated">Посев и состояние</target>
        </trans-unit>
        <trans-unit id="37cd3865c006d959fb649d73b618699ccd761419" translate="yes" xml:space="preserve">
          <source>Seeds can be passed to any of the BitGenerators. The provided value is mixed via &lt;a href=&quot;bit_generators/generated/numpy.random.seedsequence#numpy.random.SeedSequence&quot;&gt;&lt;code&gt;SeedSequence&lt;/code&gt;&lt;/a&gt; to spread a possible sequence of seeds across a wider range of initialization states for the BitGenerator. Here &lt;a href=&quot;bit_generators/pcg64#numpy.random.pcg64.PCG64&quot;&gt;&lt;code&gt;PCG64&lt;/code&gt;&lt;/a&gt; is used and is wrapped with a &lt;a href=&quot;generator#numpy.random.Generator&quot;&gt;&lt;code&gt;Generator&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Семена могут быть переданы любому из BitGenerator. Предоставленное значение смешивается с помощью &lt;a href=&quot;bit_generators/generated/numpy.random.seedsequence#numpy.random.SeedSequence&quot;&gt; &lt;code&gt;SeedSequence&lt;/code&gt; &lt;/a&gt; для распределения возможной последовательности начальных значений по более широкому диапазону состояний инициализации для BitGenerator. Здесь используется &lt;a href=&quot;bit_generators/pcg64#numpy.random.pcg64.PCG64&quot;&gt; &lt;code&gt;PCG64&lt;/code&gt; ,&lt;/a&gt; заключенный в оболочку с &lt;a href=&quot;generator#numpy.random.Generator&quot;&gt; &lt;code&gt;Generator&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="befc8fb6b3706476b647851ec8b54ce3f110f269" translate="yes" xml:space="preserve">
          <source>Selection algorithm. Default is &amp;lsquo;introselect&amp;rsquo;</source>
          <target state="translated">Алгоритм выбора. По умолчанию - introselect.</target>
        </trans-unit>
        <trans-unit id="ad6f6961c3fd31b6fdfea3ebca7b48b26cade497" translate="yes" xml:space="preserve">
          <source>Selection algorithm. Default is &amp;lsquo;introselect&amp;rsquo;.</source>
          <target state="translated">Алгоритм выбора. По умолчанию - introselect.</target>
        </trans-unit>
        <trans-unit id="d113b695dceac1abca63d8057088ab91eda91dcc" translate="yes" xml:space="preserve">
          <source>Selects a subset of the single-dimensional entries in the shape. If an axis is selected with shape entry greater than one, an error is raised.</source>
          <target state="translated">Выбирает подмножество одномерных записей в форме.Если ось выбрана с вводом формы больше единицы,то ошибка возрастает.</target>
        </trans-unit>
        <trans-unit id="ce43c468d1865e00edb6873541f360679646ae28" translate="yes" xml:space="preserve">
          <source>Separator between array items for text output. If &amp;ldquo;&amp;rdquo; (empty), a binary file is written, equivalent to &lt;code&gt;file.write(a.tobytes())&lt;/code&gt;.</source>
          <target state="translated">Разделитель между элементами массива для вывода текста. Если &amp;laquo;&amp;raquo; (пусто), записывается двоичный файл, эквивалентный &lt;code&gt;file.write(a.tobytes())&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="69c3854cf2f97e2b89f4f88e15dea295b287e18d" translate="yes" xml:space="preserve">
          <source>Separator between items if file is a text file. Empty (&amp;ldquo;&amp;rdquo;) separator means the file should be treated as binary. Spaces (&amp;rdquo; &amp;ldquo;) in the separator match zero or more whitespace characters. A separator consisting only of spaces must match at least one whitespace.</source>
          <target state="translated">Разделитель между элементами, если файл является текстовым. Пустой (&amp;laquo;&amp;raquo;) разделитель означает, что файл следует рассматривать как двоичный. Пробелы (&quot;&quot;) в разделителе соответствуют нулю или более пробелов. Разделитель, состоящий только из пробелов, должен соответствовать хотя бы одному пробелу.</target>
        </trans-unit>
        <trans-unit id="58b5ef82070109089258d37935f6f8dd60465e83" translate="yes" xml:space="preserve">
          <source>Separator to split each string element in &lt;code&gt;a&lt;/code&gt;.</source>
          <target state="translated">Сепаратор для разделения каждого элемента строки в . &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="fda4d938e57bdf80fd45be4a4b9ed3293812c803" translate="yes" xml:space="preserve">
          <source>Sequence containing the roots.</source>
          <target state="translated">Последовательность,содержащая корни.</target>
        </trans-unit>
        <trans-unit id="577113b6ca2471336f20adea7da8449aa1b619c6" translate="yes" xml:space="preserve">
          <source>Sequence of Poly series coefficients. This routine fails for empty sequences.</source>
          <target state="translated">Последовательность коэффициентов ряда Poly.Эта рутина не работает для пустых последовательностей.</target>
        </trans-unit>
        <trans-unit id="0cd7f24fb8c01924663f200685435e6585e0483c" translate="yes" xml:space="preserve">
          <source>Sequence of title strings. An empty list can be used to leave titles out.</source>
          <target state="translated">Последовательность заглавных строк.Пустой список можно использовать для того,чтобы пропустить заголовки.</target>
        </trans-unit>
        <trans-unit id="e892733a57cfb8724fa5f063a8369bfa0e2ca384" translate="yes" xml:space="preserve">
          <source>Series basis polynomial of degree &lt;code&gt;deg&lt;/code&gt;.</source>
          <target state="translated">Базисный многочлен ряда степени &lt;code&gt;deg&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1337e50ba66491fb95c336fa496a5915ac327127" translate="yes" xml:space="preserve">
          <source>Series of representing the identity.</source>
          <target state="translated">Серия,представляющая личность.</target>
        </trans-unit>
        <trans-unit id="b63dd64982c7da79c8185bb27db51618398f47db" translate="yes" xml:space="preserve">
          <source>Series with the specified roots.</source>
          <target state="translated">Серия с указанными корнями.</target>
        </trans-unit>
        <trans-unit id="c58eeea00ccb981db5bb1976aef71852fd00d936" translate="yes" xml:space="preserve">
          <source>Set &lt;code&gt;a.flat[n] = values[n]&lt;/code&gt; for all &lt;code&gt;n&lt;/code&gt; in indices.</source>
          <target state="translated">Установите &lt;code&gt;a.flat[n] = values[n]&lt;/code&gt; для всех &lt;code&gt;n&lt;/code&gt; в индексах.</target>
        </trans-unit>
        <trans-unit id="77a70ae836628667e278cbc0920a320844fc2438" translate="yes" xml:space="preserve">
          <source>Set a Python function to be used when pretty printing arrays.</source>
          <target state="translated">Установите функцию Python,которая будет использоваться при печати красивых массивов.</target>
        </trans-unit>
        <trans-unit id="2c5db0d0b74f7205ac29d00dc0f28315d34810c2" translate="yes" xml:space="preserve">
          <source>Set a callback function for the &amp;lsquo;call&amp;rsquo; mode.</source>
          <target state="translated">Установите функцию обратного вызова для режима &amp;laquo;звонок&amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="b4dd0addc44a7c0a5f052f38a920a2396cfdd632" translate="yes" xml:space="preserve">
          <source>Set array flags WRITEABLE, ALIGNED, (WRITEBACKIFCOPY and UPDATEIFCOPY), respectively.</source>
          <target state="translated">Установите флаги массива WRITEABLE,ALIGNED,(WRITEBACKIFCOPY и UPDATEIFCOPY),соответственно.</target>
        </trans-unit>
        <trans-unit id="fe4f54f983d0fc0329e51cb812fc504ecf7d9aeb" translate="yes" xml:space="preserve">
          <source>Set how floating-point errors are handled.</source>
          <target state="translated">Укажите,как обрабатываются ошибки с плавающей запятой.</target>
        </trans-unit>
        <trans-unit id="39887c043db9f2506d3506245ce2f8a4950e71c8" translate="yes" xml:space="preserve">
          <source>Set item described by index. If value is masked, masks those locations.</source>
          <target state="translated">Элемент набора описан по индексу.Если значение маскируется,маскируются эти места.</target>
        </trans-unit>
        <trans-unit id="d43a840d83fb8f7ade894cbf5726d0d362e9206c" translate="yes" xml:space="preserve">
          <source>Set items 0 and 1 to their negative values:</source>
          <target state="translated">Установите пункты 0 и 1 на отрицательные значения:</target>
        </trans-unit>
        <trans-unit id="7e3313ed91d9ab09cbf1b02b801051fadfe61771" translate="yes" xml:space="preserve">
          <source>Set of strings or integers representing the positional or keyword arguments for which the function will not be vectorized. These will be passed directly to &lt;code&gt;pyfunc&lt;/code&gt; unmodified.</source>
          <target state="translated">Набор строк или целых чисел, представляющих позиционные или ключевые аргументы, для которых функция не будет векторизована. Они будут переданы непосредственно в &lt;code&gt;pyfunc&lt;/code&gt; без изменений.</target>
        </trans-unit>
        <trans-unit id="dd426fb4dd6e4754c713da93e729d89067e4bb9f" translate="yes" xml:space="preserve">
          <source>Set print options for the scope of the &lt;code&gt;with&lt;/code&gt; block, and restore the old options at the end. See &lt;a href=&quot;numpy.set_printoptions#numpy.set_printoptions&quot;&gt;&lt;code&gt;set_printoptions&lt;/code&gt;&lt;/a&gt; for the full description of available options.</source>
          <target state="translated">Задайте параметры печати для области блока &lt;code&gt;with&lt;/code&gt; и восстановите старые параметры в конце. Смотрите &lt;a href=&quot;numpy.set_printoptions#numpy.set_printoptions&quot;&gt; &lt;code&gt;set_printoptions&lt;/code&gt; &lt;/a&gt; для полного описания доступных опций.</target>
        </trans-unit>
        <trans-unit id="865d37322e223fb10d7a9b7ba6a65aa905f9c08b" translate="yes" xml:space="preserve">
          <source>Set printing options.</source>
          <target state="translated">Установите параметры печати.</target>
        </trans-unit>
        <trans-unit id="12d96b7d9d8a25110f724914dda75cc579f9b15b" translate="yes" xml:space="preserve">
          <source>Set routines</source>
          <target state="translated">Установить распорядок дня</target>
        </trans-unit>
        <trans-unit id="90e5a4de82b432cd6a08040a41846a8b484aa8bd" translate="yes" xml:space="preserve">
          <source>Set self[key] to value.</source>
          <target state="translated">Установите для себя [клавишу]значение.</target>
        </trans-unit>
        <trans-unit id="03a01981fda3953041f5032c2c1e545ec21542ec" translate="yes" xml:space="preserve">
          <source>Set storage-indexed locations to corresponding values.</source>
          <target state="translated">Установите индексированные места хранения на соответствующие значения.</target>
        </trans-unit>
        <trans-unit id="b78901915d1c3e355e6e7781fdabdcf49646d0cb" translate="yes" xml:space="preserve">
          <source>Set the &lt;em&gt;iterator&lt;/em&gt; index and dataptr to the location in the array indicated by the integer &lt;em&gt;index&lt;/em&gt; which points to an element in the C-styled flattened array.</source>
          <target state="translated">Установите индекс &lt;em&gt;итератора&lt;/em&gt; и dataptr в положение в массиве, указанное целочисленным &lt;em&gt;индексом,&lt;/em&gt; который указывает на элемент в уплощенном массиве в стиле C.</target>
        </trans-unit>
        <trans-unit id="4a1438d389936667e0dd90e958cbfcfc479a293a" translate="yes" xml:space="preserve">
          <source>Set the &lt;em&gt;iterator&lt;/em&gt; index, dataptr, and coordinates members to the location in the array indicated by the N-dimensional c-array, &lt;em&gt;destination&lt;/em&gt;, which must have size at least &lt;em&gt;iterator&lt;/em&gt; -&amp;gt;nd_m1+1.</source>
          <target state="translated">Установите индекс &lt;em&gt;итератора&lt;/em&gt; , dataptr и элементы координат в положение в массиве, указанном N-мерным c-массивом, &lt;em&gt;destination&lt;/em&gt; , который должен иметь размер как минимум &lt;em&gt;итератор&lt;/em&gt; -&amp;gt; nd_m1 + 1.</target>
        </trans-unit>
        <trans-unit id="9fda88468648975d476004e19b12d7764d8871eb" translate="yes" xml:space="preserve">
          <source>Set the divide by zero floating point exception</source>
          <target state="translated">Установите деление на исключение с плавающей точкой с нулевой точкой</target>
        </trans-unit>
        <trans-unit id="052e8b4098d433df163dbe5f239a55cbd55acd03" translate="yes" xml:space="preserve">
          <source>Set the filling value of a masked array.</source>
          <target state="translated">Задайте значение заполнения массива,замаскированного под маску.</target>
        </trans-unit>
        <trans-unit id="9db96c8032d2ad506db915a48cc3b65dec28661e" translate="yes" xml:space="preserve">
          <source>Set the filling value of a, if a is a masked array.</source>
          <target state="translated">Задайте значение заполнения a,если a является маскированным массивом.</target>
        </trans-unit>
        <trans-unit id="8edcc5a32149cac92ce5f5d9a420660866edfc9a" translate="yes" xml:space="preserve">
          <source>Set the floating-point error callback function or log object.</source>
          <target state="translated">Установите функцию обратного вызова ошибки с плавающей запятой или объект журнала.</target>
        </trans-unit>
        <trans-unit id="f50931261f78ae53e6d835ee44ec72ac16267946" translate="yes" xml:space="preserve">
          <source>Set the internal state of the generator from a tuple.</source>
          <target state="translated">Установите внутреннее состояние генератора из кортежа.</target>
        </trans-unit>
        <trans-unit id="b7c017b4e42e5916929d8c2729e2850e7861e4ad" translate="yes" xml:space="preserve">
          <source>Set the invalid floating point exception</source>
          <target state="translated">Установить недействительное исключение с плавающей запятой</target>
        </trans-unit>
        <trans-unit id="5fc1b5b3104040e069bf3d79bfbecde1de4a9774" translate="yes" xml:space="preserve">
          <source>Set the mask.</source>
          <target state="translated">Установите маску.</target>
        </trans-unit>
        <trans-unit id="ddcd09abf8029d03a1fc8a1db4814b795eb053c2" translate="yes" xml:space="preserve">
          <source>Set the object that defines floating-point error handling.</source>
          <target state="translated">Установите объект,определяющий обработку ошибок с плавающей запятой.</target>
        </trans-unit>
        <trans-unit id="e125e8e413edbc9d7b60464db9303d04e73186dc" translate="yes" xml:space="preserve">
          <source>Set the overflow floating point exception</source>
          <target state="translated">Установить исключение с плавающей точкой переполнения</target>
        </trans-unit>
        <trans-unit id="32771428ee3d4ac8ada5bdd6145886e45b552f86" translate="yes" xml:space="preserve">
          <source>Set the size of the buffer used in ufuncs.</source>
          <target state="translated">Установите размер буфера,используемого в ufuncs.</target>
        </trans-unit>
        <trans-unit id="0594a866f8a04edf46179a77822269ada171c654" translate="yes" xml:space="preserve">
          <source>Set the underflow floating point exception</source>
          <target state="translated">Установите исключение с плавающей запятой для недопотоков</target>
        </trans-unit>
        <trans-unit id="74d19ff83e70ffb68238d34c2f7bcf87b543941d" translate="yes" xml:space="preserve">
          <source>Set treatment for all types of floating-point errors at once:</source>
          <target state="translated">Установите обработку сразу для всех типов ошибок с плавающей запятой:</target>
        </trans-unit>
        <trans-unit id="3643bcad64c7deb0821dc34ea3dcd8232b0cde58" translate="yes" xml:space="preserve">
          <source>Sets &lt;code&gt;a.flat[n] = values[n]&lt;/code&gt; for each n where &lt;code&gt;mask.flat[n]==True&lt;/code&gt;.</source>
          <target state="translated">Устанавливает &lt;code&gt;a.flat[n] = values[n]&lt;/code&gt; для каждого n, где &lt;code&gt;mask.flat[n]==True&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4b6bbd22699cc5a44aa30f4688fb3d6f05291031" translate="yes" xml:space="preserve">
          <source>Sets self._data.flat[n] = values[n] for each n in indices. If &lt;code&gt;values&lt;/code&gt; is shorter than &lt;a href=&quot;numpy.ma.indices#numpy.ma.indices&quot;&gt;&lt;code&gt;indices&lt;/code&gt;&lt;/a&gt; then it will repeat. If &lt;code&gt;values&lt;/code&gt; has some masked values, the initial mask is updated in consequence, else the corresponding values are unmasked.</source>
          <target state="translated">Устанавливает self._data.flat [n] = values ​​[n] для каждого n в индексах. Если &lt;code&gt;values&lt;/code&gt; короче &lt;a href=&quot;numpy.ma.indices#numpy.ma.indices&quot;&gt; &lt;code&gt;indices&lt;/code&gt; &lt;/a&gt; то это повторится. Если &lt;code&gt;values&lt;/code&gt; имеют некоторые замаскированные значения, соответственно обновляется начальная маска, иначе соответствующие значения не маскируются.</target>
        </trans-unit>
        <trans-unit id="6e37f27c4b449514c6ac39ca56b186f5e999b75a" translate="yes" xml:space="preserve">
          <source>Sets the flag represented by &lt;code&gt;f&lt;/code&gt; of &lt;code&gt;a&lt;/code&gt;, assuming &lt;code&gt;a&lt;/code&gt; can be cast to a &lt;code&gt;PyArrayObject*&lt;/code&gt;.</source>
          <target state="translated">Устанавливает флаг, представленный &lt;code&gt;f&lt;/code&gt; для &lt;code&gt;a&lt;/code&gt; , при условии, что &lt;code&gt;a&lt;/code&gt; может быть приведено к &lt;code&gt;PyArrayObject*&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="adf72c83614ca687d6f697b1bf172e89b7086997" translate="yes" xml:space="preserve">
          <source>Setting and getting error handling</source>
          <target state="translated">Настройка и обработка ошибок</target>
        </trans-unit>
        <trans-unit id="a384be3e2e0c4f12be39cdfe96a41f79740f7b44" translate="yes" xml:space="preserve">
          <source>Setting the timezone to UTC shows the same information, but with a Z suffix</source>
          <target state="translated">Установка часового пояса по UTC показывает ту же самую информацию,но с Z-суффиксом</target>
        </trans-unit>
        <trans-unit id="cdd7bb2816b7a8f88bce0e47be39943bc369516b" translate="yes" xml:space="preserve">
          <source>Setup</source>
          <target state="translated">Setup</target>
        </trans-unit>
        <trans-unit id="c91695f6ab0af4734ea0166f05bdecf2943954de" translate="yes" xml:space="preserve">
          <source>Setup and teardown functions to functions and methods are known as &amp;ldquo;fixtures&amp;rdquo;, and their use is not encouraged.</source>
          <target state="translated">Функции установки и разрыва для функций и методов известны как &amp;laquo;приспособления&amp;raquo;, и их использование не приветствуется.</target>
        </trans-unit>
        <trans-unit id="badd1cce039672931750b6c398bce1ef82aaa01b" translate="yes" xml:space="preserve">
          <source>Several algorithms in NumPy work on arbitrarily strided arrays. However, some algorithms require single-segment arrays. When an irregularly strided array is passed in to such algorithms, a copy is automatically made.</source>
          <target state="translated">Несколько алгоритмов в NumPy работают на массивах с произвольным расширением.Однако некоторые алгоритмы требуют односегментных массивов.Когда в такие алгоритмы передается массив с нерегулярным распределением по сегментам,то автоматически происходит его копирование.</target>
        </trans-unit>
        <trans-unit id="feb6d874b888999df457d285f3a6f7b3c564b09d" translate="yes" xml:space="preserve">
          <source>Several kinds of strings can be converted. Recognized strings can be prepended with &lt;code&gt;'&amp;gt;'&lt;/code&gt; (&lt;a href=&quot;https://docs.scipy.org/doc/numpy-1.17.0/glossary.html#term-big-endian&quot;&gt;big-endian&lt;/a&gt;), &lt;code&gt;'&amp;lt;'&lt;/code&gt; (&lt;a href=&quot;https://docs.scipy.org/doc/numpy-1.17.0/glossary.html#term-little-endian&quot;&gt;little-endian&lt;/a&gt;), or &lt;code&gt;'='&lt;/code&gt; (hardware-native, the default), to specify the byte order.</source>
          <target state="translated">Можно преобразовать несколько видов строк. К распознанным строкам можно добавлять символы &lt;code&gt;'&amp;gt;'&lt;/code&gt; ( &lt;a href=&quot;https://docs.scipy.org/doc/numpy-1.17.0/glossary.html#term-big-endian&quot;&gt;обратный порядок байтов&lt;/a&gt; ), &lt;code&gt;'&amp;lt;'&lt;/code&gt; ( &lt;a href=&quot;https://docs.scipy.org/doc/numpy-1.17.0/glossary.html#term-little-endian&quot;&gt;прямой порядок байтов&lt;/a&gt; ) или &lt;code&gt;'='&lt;/code&gt; (аппаратный, по умолчанию), чтобы указать порядок байтов.</target>
        </trans-unit>
        <trans-unit id="ea3e5d75b76acbd893a6d1a1cc411aeb6e8d344d" translate="yes" xml:space="preserve">
          <source>Several new types are defined in the C-code. Most of these are accessible from Python, but a few are not exposed due to their limited use. Every new Python type has an associated &lt;a href=&quot;https://docs.python.org/dev/c-api/structures.html#c.PyObject&quot;&gt;&lt;code&gt;PyObject *&lt;/code&gt;&lt;/a&gt; with an internal structure that includes a pointer to a &amp;ldquo;method table&amp;rdquo; that defines how the new object behaves in Python. When you receive a Python object into C code, you always get a pointer to a &lt;a href=&quot;https://docs.python.org/dev/c-api/structures.html#c.PyObject&quot;&gt;&lt;code&gt;PyObject&lt;/code&gt;&lt;/a&gt; structure. Because a &lt;a href=&quot;https://docs.python.org/dev/c-api/structures.html#c.PyObject&quot;&gt;&lt;code&gt;PyObject&lt;/code&gt;&lt;/a&gt; structure is very generic and defines only &lt;a href=&quot;https://docs.python.org/dev/c-api/structures.html#c.PyObject_HEAD&quot;&gt;&lt;code&gt;PyObject_HEAD&lt;/code&gt;&lt;/a&gt;, by itself it is not very interesting. However, different objects contain more details after the &lt;a href=&quot;https://docs.python.org/dev/c-api/structures.html#c.PyObject_HEAD&quot;&gt;&lt;code&gt;PyObject_HEAD&lt;/code&gt;&lt;/a&gt; (but you have to cast to the correct type to access them &amp;mdash; or use accessor functions or macros).</source>
          <target state="translated">В C-коде определены несколько новых типов. Большинство из них доступны из Python, но некоторые из них недоступны из-за их ограниченного использования. Каждый новый тип Python имеет связанный &lt;a href=&quot;https://docs.python.org/dev/c-api/structures.html#c.PyObject&quot;&gt; &lt;code&gt;PyObject *&lt;/code&gt; &lt;/a&gt; с внутренней структурой, которая включает указатель на &amp;laquo;таблицу методов&amp;raquo;, которая определяет, как новый объект ведет себя в Python. Когда вы получаете объект Python в коде C, вы всегда получаете указатель на структуру &lt;a href=&quot;https://docs.python.org/dev/c-api/structures.html#c.PyObject&quot;&gt; &lt;code&gt;PyObject&lt;/code&gt; &lt;/a&gt; . Поскольку структура &lt;a href=&quot;https://docs.python.org/dev/c-api/structures.html#c.PyObject&quot;&gt; &lt;code&gt;PyObject&lt;/code&gt; &lt;/a&gt; является очень общей и определяет только &lt;a href=&quot;https://docs.python.org/dev/c-api/structures.html#c.PyObject_HEAD&quot;&gt; &lt;code&gt;PyObject_HEAD&lt;/code&gt; &lt;/a&gt; , сама по себе она не очень интересна. Однако различные объекты содержат более подробную информацию после &lt;a href=&quot;https://docs.python.org/dev/c-api/structures.html#c.PyObject_HEAD&quot;&gt; &lt;code&gt;PyObject_HEAD&lt;/code&gt; &lt;/a&gt; (но вы должны привести к правильному типу для доступа к ним - или использовать функции доступа или макросы).</target>
        </trans-unit>
        <trans-unit id="8baf8c262d837f958d6464df64e5309968744eec" translate="yes" xml:space="preserve">
          <source>Several of the linear algebra routines listed above are able to compute results for several matrices at once, if they are stacked into the same array.</source>
          <target state="translated">Некоторые из вышеперечисленных процедур линейной алгебры способны вычислять результаты сразу для нескольких матриц,если они укладываются в один и тот же массив.</target>
        </trans-unit>
        <trans-unit id="72b4a9a262fa7d17e9ac09d705cde6aa24c8773a" translate="yes" xml:space="preserve">
          <source>Several python types are equivalent to a corresponding array scalar when used to generate a &lt;a href=&quot;generated/numpy.dtype#numpy.dtype&quot;&gt;&lt;code&gt;dtype&lt;/code&gt;&lt;/a&gt; object:</source>
          <target state="translated">Некоторые типы Python эквивалентны соответствующему скаляру массива при использовании для создания объекта &lt;a href=&quot;generated/numpy.dtype#numpy.dtype&quot;&gt; &lt;code&gt;dtype&lt;/code&gt; &lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="6c3e28ff5f28439895ee75d4f683fd40b7b5c1c1" translate="yes" xml:space="preserve">
          <source>Shape (length along each transformed axis) to use from the input. (&lt;code&gt;s[0]&lt;/code&gt; refers to axis 0, &lt;code&gt;s[1]&lt;/code&gt; to axis 1, etc.). The final element of &lt;code&gt;s&lt;/code&gt; corresponds to &lt;code&gt;n&lt;/code&gt; for &lt;code&gt;rfft(x, n)&lt;/code&gt;, while for the remaining axes, it corresponds to &lt;code&gt;n&lt;/code&gt; for &lt;code&gt;fft(x, n)&lt;/code&gt;. Along any axis, if the given shape is smaller than that of the input, the input is cropped. If it is larger, the input is padded with zeros. if &lt;code&gt;s&lt;/code&gt; is not given, the shape of the input along the axes specified by &lt;code&gt;axes&lt;/code&gt; is used.</source>
          <target state="translated">Форма (длина по каждой преобразованной оси) для использования из входных данных. ( &lt;code&gt;s[0]&lt;/code&gt; относится к оси 0, &lt;code&gt;s[1]&lt;/code&gt; ] относится к оси 1 и т. д.). Последний элемент &lt;code&gt;s&lt;/code&gt; соответствует &lt;code&gt;n&lt;/code&gt; для &lt;code&gt;rfft(x, n)&lt;/code&gt; , тогда как для остальных осей он соответствует &lt;code&gt;n&lt;/code&gt; для &lt;code&gt;fft(x, n)&lt;/code&gt; . Вдоль любой оси, если заданная форма меньше, чем входная, входные данные обрезаются. Если он больше, ввод дополняется нулями. если &lt;code&gt;s&lt;/code&gt; не задано, используется форма ввода по осям, указанным &lt;code&gt;axes&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="25e97af4557ebd95034e25fa1946abe7364f73b7" translate="yes" xml:space="preserve">
          <source>Shape (length of each axis) of the output (&lt;code&gt;s[0]&lt;/code&gt; refers to axis 0, &lt;code&gt;s[1]&lt;/code&gt; to axis 1, etc.). This corresponds to &lt;code&gt;n&lt;/code&gt; for &lt;code&gt;ifft(x, n)&lt;/code&gt;. Along each axis, if the given shape is smaller than that of the input, the input is cropped. If it is larger, the input is padded with zeros. if &lt;code&gt;s&lt;/code&gt; is not given, the shape of the input along the axes specified by &lt;code&gt;axes&lt;/code&gt; is used. See notes for issue on &lt;a href=&quot;numpy.fft.ifft#numpy.fft.ifft&quot;&gt;&lt;code&gt;ifft&lt;/code&gt;&lt;/a&gt; zero padding.</source>
          <target state="translated">Форма (длина каждой оси) вывода ( &lt;code&gt;s[0]&lt;/code&gt; относится к оси 0, &lt;code&gt;s[1]&lt;/code&gt; к оси 1 и т. Д.). Это соответствует &lt;code&gt;n&lt;/code&gt; для &lt;code&gt;ifft(x, n)&lt;/code&gt; . Вдоль каждой оси, если заданная форма меньше, чем входная форма, входные данные обрезаются. Если он больше, ввод дополняется нулями. если &lt;code&gt;s&lt;/code&gt; не задано, используется форма ввода по осям, указанным &lt;code&gt;axes&lt;/code&gt; . Смотрите примечание к выпуску &lt;a href=&quot;numpy.fft.ifft#numpy.fft.ifft&quot;&gt; &lt;code&gt;ifft&lt;/code&gt; &lt;/a&gt; заполнения нулей.</target>
        </trans-unit>
        <trans-unit id="4f0274375e7f902c51299d209c86d1f430d2633d" translate="yes" xml:space="preserve">
          <source>Shape (length of each transformed axis) of the output (&lt;code&gt;s[0]&lt;/code&gt; refers to axis 0, &lt;code&gt;s[1]&lt;/code&gt; to axis 1, etc.). &lt;code&gt;s&lt;/code&gt; is also the number of input points used along this axis, except for the last axis, where &lt;code&gt;s[-1]//2+1&lt;/code&gt; points of the input are used. Along any axis, if the shape indicated by &lt;code&gt;s&lt;/code&gt; is smaller than that of the input, the input is cropped. If it is larger, the input is padded with zeros. If &lt;code&gt;s&lt;/code&gt; is not given, the shape of the input along the axes specified by &lt;code&gt;axes&lt;/code&gt; is used.</source>
          <target state="translated">Форма (длина каждой преобразованной оси) вывода ( &lt;code&gt;s[0]&lt;/code&gt; относится к оси 0, &lt;code&gt;s[1]&lt;/code&gt; к оси 1 и т. Д.). &lt;code&gt;s&lt;/code&gt; - это также количество входных точек, используемых вдоль этой оси, за исключением последней оси, где &lt;code&gt;s[-1]//2+1&lt;/code&gt; входные точки. Вдоль любой оси, если форма, обозначенная &lt;code&gt;s&lt;/code&gt; , меньше, чем форма ввода, ввод обрезается. Если он больше, ввод дополняется нулями. Если &lt;code&gt;s&lt;/code&gt; не задан, используется форма ввода по осям, указанным &lt;code&gt;axes&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="715197f23d8523982bbe5b136ca8694c043fdfe2" translate="yes" xml:space="preserve">
          <source>Shape (length of each transformed axis) of the output (&lt;code&gt;s[0]&lt;/code&gt; refers to axis 0, &lt;code&gt;s[1]&lt;/code&gt; to axis 1, etc.). This corresponds to &lt;code&gt;n&lt;/code&gt; for &lt;code&gt;fft(x, n)&lt;/code&gt;. Along any axis, if the given shape is smaller than that of the input, the input is cropped. If it is larger, the input is padded with zeros. if &lt;code&gt;s&lt;/code&gt; is not given, the shape of the input along the axes specified by &lt;code&gt;axes&lt;/code&gt; is used.</source>
          <target state="translated">Форма (длина каждой преобразованной оси) вывода ( &lt;code&gt;s[0]&lt;/code&gt; относится к оси 0, &lt;code&gt;s[1]&lt;/code&gt; к оси 1 и т. Д.). Это соответствует &lt;code&gt;n&lt;/code&gt; для &lt;code&gt;fft(x, n)&lt;/code&gt; . Вдоль любой оси, если заданная форма меньше, чем входная, входные данные обрезаются. Если он больше, ввод дополняется нулями. если &lt;code&gt;s&lt;/code&gt; не задано, используется форма ввода по осям, указанным &lt;code&gt;axes&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="911dd842dd5fbba1fec3b25f55cac11209b63564" translate="yes" xml:space="preserve">
          <source>Shape (length of each transformed axis) of the output (&lt;code&gt;s[0]&lt;/code&gt; refers to axis 0, &lt;code&gt;s[1]&lt;/code&gt; to axis 1, etc.). This corresponds to &lt;code&gt;n&lt;/code&gt; for &lt;code&gt;fft(x, n)&lt;/code&gt;. Along each axis, if the given shape is smaller than that of the input, the input is cropped. If it is larger, the input is padded with zeros. if &lt;code&gt;s&lt;/code&gt; is not given, the shape of the input along the axes specified by &lt;code&gt;axes&lt;/code&gt; is used.</source>
          <target state="translated">Форма (длина каждой преобразованной оси) вывода ( &lt;code&gt;s[0]&lt;/code&gt; относится к оси 0, &lt;code&gt;s[1]&lt;/code&gt; к оси 1 и т. Д.). Это соответствует &lt;code&gt;n&lt;/code&gt; для &lt;code&gt;fft(x, n)&lt;/code&gt; . Вдоль каждой оси, если заданная форма меньше, чем входная форма, входные данные обрезаются. Если он больше, ввод дополняется нулями. если &lt;code&gt;s&lt;/code&gt; не задано, используется форма ввода по осям, указанным &lt;code&gt;axes&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b17262b4844364ff0a648b69b2dd5889d0fd6ded" translate="yes" xml:space="preserve">
          <source>Shape (length of each transformed axis) of the output (&lt;code&gt;s[0]&lt;/code&gt; refers to axis 0, &lt;code&gt;s[1]&lt;/code&gt; to axis 1, etc.). This corresponds to &lt;code&gt;n&lt;/code&gt; for &lt;code&gt;ifft(x, n)&lt;/code&gt;. Along any axis, if the given shape is smaller than that of the input, the input is cropped. If it is larger, the input is padded with zeros. if &lt;code&gt;s&lt;/code&gt; is not given, the shape of the input along the axes specified by &lt;code&gt;axes&lt;/code&gt; is used. See notes for issue on &lt;a href=&quot;numpy.fft.ifft#numpy.fft.ifft&quot;&gt;&lt;code&gt;ifft&lt;/code&gt;&lt;/a&gt; zero padding.</source>
          <target state="translated">Форма (длина каждой преобразованной оси) вывода ( &lt;code&gt;s[0]&lt;/code&gt; относится к оси 0, &lt;code&gt;s[1]&lt;/code&gt; к оси 1 и т. Д.). Это соответствует &lt;code&gt;n&lt;/code&gt; для &lt;code&gt;ifft(x, n)&lt;/code&gt; . Вдоль любой оси, если заданная форма меньше, чем входная, входные данные обрезаются. Если он больше, ввод дополняется нулями. если &lt;code&gt;s&lt;/code&gt; не задано, используется форма ввода по осям, указанным &lt;code&gt;axes&lt;/code&gt; . Смотрите примечание к выпуску &lt;a href=&quot;numpy.fft.ifft#numpy.fft.ifft&quot;&gt; &lt;code&gt;ifft&lt;/code&gt; &lt;/a&gt; заполнения нулей.</target>
        </trans-unit>
        <trans-unit id="4ebeb877c0987d74b5cc7ea4944124e8bf55dfce" translate="yes" xml:space="preserve">
          <source>Shape Manipulation</source>
          <target state="translated">Манипуляция формой</target>
        </trans-unit>
        <trans-unit id="c9f4b98b8edf5592548ab5955c6e16a228f358cb" translate="yes" xml:space="preserve">
          <source>Shape consistent means they are either the same shape, or one input array can be broadcasted to create the same shape as the other one.</source>
          <target state="translated">Последовательность форм означает,что они либо одинаковые по форме,либо один входной массив может быть транслирован,чтобы создать такую же форму,как и другой.</target>
        </trans-unit>
        <trans-unit id="5f1d9e046d241980c89d8b9124d4eafb15b1ca52" translate="yes" xml:space="preserve">
          <source>Shape manipulation</source>
          <target state="translated">Форма манипуляции</target>
        </trans-unit>
        <trans-unit id="3b6ca0ce8b60b462e3cf99cb12bf59179d6a929d" translate="yes" xml:space="preserve">
          <source>Shape of broadcasted result.</source>
          <target state="translated">Форма транслируемого результата.</target>
        </trans-unit>
        <trans-unit id="bddad57d8d1388e963005420a02793b2da427fb5" translate="yes" xml:space="preserve">
          <source>Shape of created array.</source>
          <target state="translated">Форма созданного массива.</target>
        </trans-unit>
        <trans-unit id="6cd9e448195effa4bae30eb0f347906fc449b5d5" translate="yes" xml:space="preserve">
          <source>Shape of output array.</source>
          <target state="translated">Форма выходного массива.</target>
        </trans-unit>
        <trans-unit id="46e7814f1b68d56a7fb197281826d8c0d7e2f4af" translate="yes" xml:space="preserve">
          <source>Shape of resized array.</source>
          <target state="translated">Форма измененного массива.</target>
        </trans-unit>
        <trans-unit id="ee903849125469d0cd897ee6f3eb2ebe3bb658c4" translate="yes" xml:space="preserve">
          <source>Shape of the FFT.</source>
          <target state="translated">Форма БПФ.</target>
        </trans-unit>
        <trans-unit id="93a4d2c249aa77d74ddbee4b73894079d88c4f5d" translate="yes" xml:space="preserve">
          <source>Shape of the array.</source>
          <target state="translated">Форма массива.</target>
        </trans-unit>
        <trans-unit id="02877fc62d2c6f24e10d1abc3b67c8004f59d738" translate="yes" xml:space="preserve">
          <source>Shape of the distribution. Must be positive.</source>
          <target state="translated">Форма распределения.Должна быть положительной.</target>
        </trans-unit>
        <trans-unit id="f2d500bd962f41d17541e213ff6895cd13e0803e" translate="yes" xml:space="preserve">
          <source>Shape of the empty array, e.g., &lt;code&gt;(2, 3)&lt;/code&gt; or &lt;code&gt;2&lt;/code&gt;.</source>
          <target state="translated">Форма пустого массива, например &lt;code&gt;(2, 3)&lt;/code&gt; или &lt;code&gt;2&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="24ef6c437154658151fd05bcb5ba7d5668bdcc5d" translate="yes" xml:space="preserve">
          <source>Shape of the empty matrix.</source>
          <target state="translated">Форма пустой матрицы.</target>
        </trans-unit>
        <trans-unit id="655648f0fa12f5cdf873e10745fb89b0bd95696d" translate="yes" xml:space="preserve">
          <source>Shape of the inverse FFT.</source>
          <target state="translated">Форма обратной БПФ.</target>
        </trans-unit>
        <trans-unit id="3199c5dcca84fd372c42321d02949f1a124a4434" translate="yes" xml:space="preserve">
          <source>Shape of the matrix</source>
          <target state="translated">Форма матрицы</target>
        </trans-unit>
        <trans-unit id="c98d12cd91ff402d167f61e45930510176bc8db1" translate="yes" xml:space="preserve">
          <source>Shape of the new array, e.g., &lt;code&gt;(2, 3)&lt;/code&gt; or &lt;code&gt;2&lt;/code&gt;.</source>
          <target state="translated">Форма нового массива, например &lt;code&gt;(2, 3)&lt;/code&gt; или &lt;code&gt;2&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="011eae76336380495ec0325c87bbf97467274627" translate="yes" xml:space="preserve">
          <source>Shape of the output array, which also determines the shape of the coordinate arrays passed to &lt;code&gt;function&lt;/code&gt;.</source>
          <target state="translated">Форма выходного массива, который также определяет форму массивов координат, переданных в &lt;code&gt;function&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c07147cdf3a1896289324d57eac09581fa428dd6" translate="yes" xml:space="preserve">
          <source>Shape of the output. If given as N integers, each integer specifies the size of one dimension. If given as a tuple, this tuple gives the complete shape.</source>
          <target state="translated">Форма выхода.Если задано как N целых чисел,то каждое целое определяет размер одного измерения.Если задан кортеж,то этот кортеж дает полную форму.</target>
        </trans-unit>
        <trans-unit id="af9d8afd8fa749d8e52d9830aee69713b28d831e" translate="yes" xml:space="preserve">
          <source>Shape of the required MaskedArray.</source>
          <target state="translated">Форма требуемого MaskedArray.</target>
        </trans-unit>
        <trans-unit id="e290412db84643bfd2e4e9eaed5764c99448847e" translate="yes" xml:space="preserve">
          <source>Shape parameter for the distribution. Must be in the range (0, 1).</source>
          <target state="translated">Форма параметра распределения.Должен быть в диапазоне (0,1).</target>
        </trans-unit>
        <trans-unit id="83905d9bb159cfd69b777f36625de825a5e41d49" translate="yes" xml:space="preserve">
          <source>Shape parameter for window.</source>
          <target state="translated">Параметр Shape для окна.</target>
        </trans-unit>
        <trans-unit id="9b7a43cf04b72cc2f8a23566b289e4d0bd8ec177" translate="yes" xml:space="preserve">
          <source>Shape parameter of the distribution. Must be nonnegative.</source>
          <target state="translated">Форма параметра распределения.Должен быть неотрицательным.</target>
        </trans-unit>
        <trans-unit id="8e3c6edf56bb87890fd0d1cdb08c97f69b223d25" translate="yes" xml:space="preserve">
          <source>Shape tuple of the sub-array if this data type describes a sub-array, and &lt;code&gt;()&lt;/code&gt; otherwise.</source>
          <target state="translated">Формируйте кортеж подмассива, если этот тип данных описывает подмассив, и &lt;code&gt;()&lt;/code&gt; в противном случае.</target>
        </trans-unit>
        <trans-unit id="446e2a7d2369f9d1a3b2488394691efa0754afe6" translate="yes" xml:space="preserve">
          <source>Shape tuple, the shape of the iterator.</source>
          <target state="translated">Форма кортежа,форма итератора.</target>
        </trans-unit>
        <trans-unit id="553abfec4e1a448d4b14d3d81794f14b5ad2fe5b" translate="yes" xml:space="preserve">
          <source>Share status of the mask (read-only).</source>
          <target state="translated">Поделиться статусом маски (только для чтения).</target>
        </trans-unit>
        <trans-unit id="7c87de531eb450c69f475f1cc68cfb4c95a8aa3e" translate="yes" xml:space="preserve">
          <source>Shift the bits of an integer to the left.</source>
          <target state="translated">Сдвиньте биты целого числа влево.</target>
        </trans-unit>
        <trans-unit id="2f8deb45beae3abccb987abecafce17d01cca0db" translate="yes" xml:space="preserve">
          <source>Shift the bits of an integer to the right.</source>
          <target state="translated">Сдвиньте биты целого числа вправо.</target>
        </trans-unit>
        <trans-unit id="4b62e14d6acb41a9881dd5c7d1b632d11117bf42" translate="yes" xml:space="preserve">
          <source>Shift the zero-frequency component only along the second axis:</source>
          <target state="translated">Сдвигайте нулевую частотную составляющую только вдоль второй оси:</target>
        </trans-unit>
        <trans-unit id="dd4356118ce17af4ac61d8e18b734f9c851e6a93" translate="yes" xml:space="preserve">
          <source>Shift the zero-frequency component to the center of the spectrum.</source>
          <target state="translated">Сдвиньте нулевую частотную составляющую в центр спектра.</target>
        </trans-unit>
        <trans-unit id="5055dc1fca0e758173b975d01eb66d87f3cbb17c" translate="yes" xml:space="preserve">
          <source>Shift zero-frequency component to the center of the spectrum.</source>
          <target state="translated">Сдвиньте нулевую частотную составляющую в центр спектра.</target>
        </trans-unit>
        <trans-unit id="b180ab3848496fb12e866c104e23d82cd3b364fd" translate="yes" xml:space="preserve">
          <source>Shifts zero-frequency terms to centre of array</source>
          <target state="translated">Сдвигает нуль-частотные члены в центр массива</target>
        </trans-unit>
        <trans-unit id="277215a3b406656029fa8041449bf3521c519abc" translate="yes" xml:space="preserve">
          <source>Shifts zero-frequency terms to the center of the array. For two-dimensional input, swaps first and third quadrants, and second and fourth quadrants.</source>
          <target state="translated">Сдвигает нуль-частотные члены в центр массива.Для двумерного ввода меняет первый и третий квадранты,а также второй и четвертый квадранты.</target>
        </trans-unit>
        <trans-unit id="b762aac578ae466a940477f419de45f5524873a7" translate="yes" xml:space="preserve">
          <source>Short repeat rule</source>
          <target state="translated">Правило короткого повтора</target>
        </trans-unit>
        <trans-unit id="82df73654f5b2a3f44b1124d8173803e26dbe857" translate="yes" xml:space="preserve">
          <source>Shortcut to &lt;code&gt;masked_where&lt;/code&gt;, where &lt;code&gt;condition&lt;/code&gt; is True for &lt;code&gt;x&lt;/code&gt; inside the interval [v1,v2] (v1 &amp;lt;= x &amp;lt;= v2). The boundaries &lt;code&gt;v1&lt;/code&gt; and &lt;code&gt;v2&lt;/code&gt; can be given in either order.</source>
          <target state="translated">Ярлык для &lt;code&gt;masked_where&lt;/code&gt; , где &lt;code&gt;condition&lt;/code&gt; истинно для &lt;code&gt;x&lt;/code&gt; внутри интервала [v1, v2] (v1 &amp;lt;= x &amp;lt;= v2). Границы &lt;code&gt;v1&lt;/code&gt; и &lt;code&gt;v2&lt;/code&gt; можно указывать в любом порядке.</target>
        </trans-unit>
        <trans-unit id="2b41646ab781bb52f3ec916c5f5214e0562ccf8b" translate="yes" xml:space="preserve">
          <source>Shortcut to &lt;code&gt;masked_where&lt;/code&gt;, where &lt;code&gt;condition&lt;/code&gt; is True for &lt;code&gt;x&lt;/code&gt; outside the interval [v1,v2] (x &amp;lt; v1)|(x &amp;gt; v2). The boundaries &lt;code&gt;v1&lt;/code&gt; and &lt;code&gt;v2&lt;/code&gt; can be given in either order.</source>
          <target state="translated">Ярлык для &lt;code&gt;masked_where&lt;/code&gt; , где &lt;code&gt;condition&lt;/code&gt; истинно для &lt;code&gt;x&lt;/code&gt; вне интервала [v1, v2] (x &amp;lt;v1) | (x&amp;gt; v2). Границы &lt;code&gt;v1&lt;/code&gt; и &lt;code&gt;v2&lt;/code&gt; можно указывать в любом порядке.</target>
        </trans-unit>
        <trans-unit id="90a7ea5e6af4c7b7105e0bea7e0631a8b326d3c4" translate="yes" xml:space="preserve">
          <source>Show how an extreme value distribution can arise from a Gaussian process and compare to a Gaussian:</source>
          <target state="translated">Покажите,как распределение экстремальных значений может возникнуть в результате гауссовского процесса,и сравните его с гауссовским:</target>
        </trans-unit>
        <trans-unit id="19b965e86e175fb4e059f2686baef10d13deee7c" translate="yes" xml:space="preserve">
          <source>Show the coefficient of the k-th power in the polynomial (which is equivalent to &lt;code&gt;p.c[-(i+1)]&lt;/code&gt;):</source>
          <target state="translated">Покажите коэффициент при k-й степени полинома (что эквивалентно &lt;code&gt;p.c[-(i+1)]&lt;/code&gt; ):</target>
        </trans-unit>
        <trans-unit id="2dc1d2c7e18782c1b84edd4a515e52ecaf16ffe6" translate="yes" xml:space="preserve">
          <source>Show the coefficients:</source>
          <target state="translated">Покажи коэффициенты:</target>
        </trans-unit>
        <trans-unit id="196a4e0eff8a41440049d47c5b180f7f45132ca2" translate="yes" xml:space="preserve">
          <source>Show which elements are NaN.</source>
          <target state="translated">Покажите,какие элементы-NaN.</target>
        </trans-unit>
        <trans-unit id="c42d9c8bf1bc36b5a64f8cd7d6ec47959c633d86" translate="yes" xml:space="preserve">
          <source>Show which elements are not NaN or +/-inf.</source>
          <target state="translated">Показывать,какие элементы не являются NaN или +/-inf.</target>
        </trans-unit>
        <trans-unit id="1722f8e8697cd3b5c7fd5053f2fe5fc8ffff0c94" translate="yes" xml:space="preserve">
          <source>Showing the shape equivalence:</source>
          <target state="translated">Показывая эквивалентность формы:</target>
        </trans-unit>
        <trans-unit id="f7b90b8e09428e6e1e81258972869d09b4e3cfb5" translate="yes" xml:space="preserve">
          <source>Shows which elements are Not a Number (NaN).</source>
          <target state="translated">Показывает,какие элементы не являются номерами (NaN).</target>
        </trans-unit>
        <trans-unit id="fe897f37d53e4d88b6771d092e29d0cbef83871f" translate="yes" xml:space="preserve">
          <source>Shows which elements are finite (not NaN, not infinity)</source>
          <target state="translated">Показывает,какие элементы являются конечными (не NaN,не бесконечными).</target>
        </trans-unit>
        <trans-unit id="7baa9edf65ea714b6abdb42e0d551c9f633b7a31" translate="yes" xml:space="preserve">
          <source>Shows which elements are negative infinity.</source>
          <target state="translated">Показывает,какие элементы являются отрицательной бесконечностью.</target>
        </trans-unit>
        <trans-unit id="8a9af7136c0a378e79ffd9025ff0d52b52f3f5b3" translate="yes" xml:space="preserve">
          <source>Shows which elements are neither NaN nor infinity.</source>
          <target state="translated">Показывает,какие элементы не являются ни NaN,ни бесконечностью.</target>
        </trans-unit>
        <trans-unit id="b641e3652a21af65f93f39772715d39737df1101" translate="yes" xml:space="preserve">
          <source>Shows which elements are positive infinity.</source>
          <target state="translated">Показывает,какие элементы являются положительной бесконечностью.</target>
        </trans-unit>
        <trans-unit id="cae71eb0e9768c0464ac97199ab347f3e2d0b2fa" translate="yes" xml:space="preserve">
          <source>Shows which elements are positive or negative infinity.</source>
          <target state="translated">Показывает,какие элементы являются положительными или отрицательными бесконечностями.</target>
        </trans-unit>
        <trans-unit id="fb36ed0dc4329ccc9a4d63a4ab49050cba7729e3" translate="yes" xml:space="preserve">
          <source>Shrinking an array: array is flattened (in the order that the data are stored in memory), resized, and reshaped:</source>
          <target state="translated">Уменьшение массива:массив сглаживается (в порядке хранения данных в памяти),изменяется размер и форма:</target>
        </trans-unit>
        <trans-unit id="57d924a0266c81fc54add4584a1ccacbe3e83546" translate="yes" xml:space="preserve">
          <source>Signals to nose that this function is or is not a test.</source>
          <target state="translated">Сигналы к носу о том,что эта функция является или не является тестом.</target>
        </trans-unit>
        <trans-unit id="2f32be1dc74166373c988ec03b0bd86f0a576919" translate="yes" xml:space="preserve">
          <source>Signature</source>
          <target state="translated">Signature</target>
        </trans-unit>
        <trans-unit id="7931cda1fe427976dc0d85722ec095e3dd727c1d" translate="yes" xml:space="preserve">
          <source>Similar function which always returns ndarrays.</source>
          <target state="translated">Аналогичная функция,которая всегда возвращает ndarrays.</target>
        </trans-unit>
        <trans-unit id="3274df1aa677da58a67e936b08b6d01b18ae9bbb" translate="yes" xml:space="preserve">
          <source>Similar function which checks input for NaNs and Infs.</source>
          <target state="translated">Аналогичная функция,которая проверяет входные данные для NaN и Infs.</target>
        </trans-unit>
        <trans-unit id="5bfc139e101673a0040c4eaa29d6026a0cc4d777" translate="yes" xml:space="preserve">
          <source>Similar function which passes through subclasses.</source>
          <target state="translated">Аналогичная функция,которая проходит через подклассы.</target>
        </trans-unit>
        <trans-unit id="385cb8c7bac921aa96fc7c5b5e20aadf977c2b11" translate="yes" xml:space="preserve">
          <source>Similar to &lt;a href=&quot;#c.PyArray_FROM_O&quot;&gt;&lt;code&gt;PyArray_FROM_O&lt;/code&gt;&lt;/a&gt; except it can take an argument of &lt;em&gt;requirements&lt;/em&gt; indicating properties the resulting array must have. Available requirements that can be enforced are &lt;a href=&quot;#c.NPY_ARRAY_C_CONTIGUOUS&quot;&gt;&lt;code&gt;NPY_ARRAY_C_CONTIGUOUS&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#c.NPY_ARRAY_F_CONTIGUOUS&quot;&gt;&lt;code&gt;NPY_ARRAY_F_CONTIGUOUS&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#c.NPY_ARRAY_ALIGNED&quot;&gt;&lt;code&gt;NPY_ARRAY_ALIGNED&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#c.NPY_ARRAY_WRITEABLE&quot;&gt;&lt;code&gt;NPY_ARRAY_WRITEABLE&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#c.NPY_ARRAY_NOTSWAPPED&quot;&gt;&lt;code&gt;NPY_ARRAY_NOTSWAPPED&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#c.NPY_ARRAY_ENSURECOPY&quot;&gt;&lt;code&gt;NPY_ARRAY_ENSURECOPY&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#c.NPY_ARRAY_WRITEBACKIFCOPY&quot;&gt;&lt;code&gt;NPY_ARRAY_WRITEBACKIFCOPY&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#c.NPY_ARRAY_UPDATEIFCOPY&quot;&gt;&lt;code&gt;NPY_ARRAY_UPDATEIFCOPY&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#c.NPY_ARRAY_FORCECAST&quot;&gt;&lt;code&gt;NPY_ARRAY_FORCECAST&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;#c.NPY_ARRAY_ENSUREARRAY&quot;&gt;&lt;code&gt;NPY_ARRAY_ENSUREARRAY&lt;/code&gt;&lt;/a&gt;. Standard combinations of flags can also be used:</source>
          <target state="translated">Подобно &lt;a href=&quot;#c.PyArray_FROM_O&quot;&gt; &lt;code&gt;PyArray_FROM_O&lt;/code&gt; ,&lt;/a&gt; за исключением того, что он может принимать аргумент &lt;em&gt;требований,&lt;/em&gt; указывающий свойства, которые должен иметь результирующий массив. Доступные требования , которые могут быть насильственными являются &lt;a href=&quot;#c.NPY_ARRAY_C_CONTIGUOUS&quot;&gt; &lt;code&gt;NPY_ARRAY_C_CONTIGUOUS&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#c.NPY_ARRAY_F_CONTIGUOUS&quot;&gt; &lt;code&gt;NPY_ARRAY_F_CONTIGUOUS&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#c.NPY_ARRAY_ALIGNED&quot;&gt; &lt;code&gt;NPY_ARRAY_ALIGNED&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#c.NPY_ARRAY_WRITEABLE&quot;&gt; &lt;code&gt;NPY_ARRAY_WRITEABLE&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#c.NPY_ARRAY_NOTSWAPPED&quot;&gt; &lt;code&gt;NPY_ARRAY_NOTSWAPPED&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#c.NPY_ARRAY_ENSURECOPY&quot;&gt; &lt;code&gt;NPY_ARRAY_ENSURECOPY&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#c.NPY_ARRAY_WRITEBACKIFCOPY&quot;&gt; &lt;code&gt;NPY_ARRAY_WRITEBACKIFCOPY&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#c.NPY_ARRAY_UPDATEIFCOPY&quot;&gt; &lt;code&gt;NPY_ARRAY_UPDATEIFCOPY&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#c.NPY_ARRAY_FORCECAST&quot;&gt; &lt;code&gt;NPY_ARRAY_FORCECAST&lt;/code&gt; &lt;/a&gt; и &lt;a href=&quot;#c.NPY_ARRAY_ENSUREARRAY&quot;&gt; &lt;code&gt;NPY_ARRAY_ENSUREARRAY&lt;/code&gt; &lt;/a&gt; . Также могут использоваться стандартные комбинации флагов:</target>
        </trans-unit>
        <trans-unit id="34e63b3cec603aed4fdc223ab142b8582483ea26" translate="yes" xml:space="preserve">
          <source>Similar to &lt;a href=&quot;#c.PyArray_FROM_O&quot;&gt;&lt;code&gt;PyArray_FROM_O&lt;/code&gt;&lt;/a&gt; except it can take an argument of &lt;em&gt;typenum&lt;/em&gt; specifying the type-number the returned array.</source>
          <target state="translated">Подобно &lt;a href=&quot;#c.PyArray_FROM_O&quot;&gt; &lt;code&gt;PyArray_FROM_O&lt;/code&gt; ,&lt;/a&gt; за исключением того, что он может принимать аргумент типа &lt;em&gt;typenum,&lt;/em&gt; указывающий номер типа возвращаемого массива.</target>
        </trans-unit>
        <trans-unit id="9ab72ded5542baece20f259b6e4f2d1ffd7e40a6" translate="yes" xml:space="preserve">
          <source>Similar to &lt;a href=&quot;#c.PyArray_FromAny&quot;&gt;&lt;code&gt;PyArray_FromAny&lt;/code&gt;&lt;/a&gt; except the data-type is specified using a typenumber. &lt;a href=&quot;#c.PyArray_DescrFromType&quot;&gt;&lt;code&gt;PyArray_DescrFromType&lt;/code&gt;&lt;/a&gt; (&lt;em&gt;typenum&lt;/em&gt;) is passed directly to &lt;a href=&quot;#c.PyArray_FromAny&quot;&gt;&lt;code&gt;PyArray_FromAny&lt;/code&gt;&lt;/a&gt;. This macro also adds &lt;a href=&quot;#c.NPY_ARRAY_DEFAULT&quot;&gt;&lt;code&gt;NPY_ARRAY_DEFAULT&lt;/code&gt;&lt;/a&gt; to requirements if &lt;a href=&quot;#c.NPY_ARRAY_ENSURECOPY&quot;&gt;&lt;code&gt;NPY_ARRAY_ENSURECOPY&lt;/code&gt;&lt;/a&gt; is passed in as requirements.</source>
          <target state="translated">Подобно &lt;a href=&quot;#c.PyArray_FromAny&quot;&gt; &lt;code&gt;PyArray_FromAny&lt;/code&gt; ,&lt;/a&gt; за исключением того, что тип данных указывается с использованием типового номера. &lt;a href=&quot;#c.PyArray_DescrFromType&quot;&gt; &lt;code&gt;PyArray_DescrFromType&lt;/code&gt; &lt;/a&gt; ( &lt;em&gt;typenum&lt;/em&gt; ) передается непосредственно &lt;a href=&quot;#c.PyArray_FromAny&quot;&gt; &lt;code&gt;PyArray_FromAny&lt;/code&gt; &lt;/a&gt; . Этот макрос также добавляет &lt;a href=&quot;#c.NPY_ARRAY_DEFAULT&quot;&gt; &lt;code&gt;NPY_ARRAY_DEFAULT&lt;/code&gt; &lt;/a&gt; к требованиям, если &lt;a href=&quot;#c.NPY_ARRAY_ENSURECOPY&quot;&gt; &lt;code&gt;NPY_ARRAY_ENSURECOPY&lt;/code&gt; &lt;/a&gt; передается в качестве требований.</target>
        </trans-unit>
        <trans-unit id="b7795b78351922539b7bd3388bd15513fe09ab10" translate="yes" xml:space="preserve">
          <source>Similar to &lt;a href=&quot;#numpy.linspace&quot;&gt;&lt;code&gt;linspace&lt;/code&gt;&lt;/a&gt;, but uses a step size (instead of the number of samples).</source>
          <target state="translated">Подобно &lt;a href=&quot;#numpy.linspace&quot;&gt; &lt;code&gt;linspace&lt;/code&gt; &lt;/a&gt; , но использует размер шага (вместо количества выборок).</target>
        </trans-unit>
        <trans-unit id="61b73acdf7b4aeb554b76ddf529120fdd3244e4c" translate="yes" xml:space="preserve">
          <source>Similar to &lt;a href=&quot;#numpy.linspace&quot;&gt;&lt;code&gt;linspace&lt;/code&gt;&lt;/a&gt;, but with numbers spaced evenly on a log scale (a geometric progression).</source>
          <target state="translated">Подобно &lt;a href=&quot;#numpy.linspace&quot;&gt; &lt;code&gt;linspace&lt;/code&gt; &lt;/a&gt; , но с числами, расположенными равномерно по логарифмической шкале (геометрическая прогрессия).</target>
        </trans-unit>
        <trans-unit id="b7334b28a788c204f9b851a15f23e3dc83fbe028" translate="yes" xml:space="preserve">
          <source>Similar to &lt;a href=&quot;#numpy.ma.asanyarray&quot;&gt;&lt;code&gt;asanyarray&lt;/code&gt;&lt;/a&gt;, but does not conserve subclass.</source>
          <target state="translated">Аналогично &lt;a href=&quot;#numpy.ma.asanyarray&quot;&gt; &lt;code&gt;asanyarray&lt;/code&gt; &lt;/a&gt; , но не сохраняет подкласс.</target>
        </trans-unit>
        <trans-unit id="e0639724205f7208e357391aa44785bd18f6e10a" translate="yes" xml:space="preserve">
          <source>Similar to &lt;a href=&quot;#numpy.ma.asarray&quot;&gt;&lt;code&gt;asarray&lt;/code&gt;&lt;/a&gt;, but conserves subclasses.</source>
          <target state="translated">Подобно &lt;a href=&quot;#numpy.ma.asarray&quot;&gt; &lt;code&gt;asarray&lt;/code&gt; &lt;/a&gt; , но сохраняет подклассы.</target>
        </trans-unit>
        <trans-unit id="087902d07ba8ed25e8e25e39b41104a23371fa18" translate="yes" xml:space="preserve">
          <source>Similar to &lt;a href=&quot;#numpy.random.mtrand.RandomState.random_integers&quot;&gt;&lt;code&gt;random_integers&lt;/code&gt;&lt;/a&gt;, only for the half-open interval [&lt;code&gt;low&lt;/code&gt;, &lt;code&gt;high&lt;/code&gt;), and 0 is the lowest value if &lt;code&gt;high&lt;/code&gt; is omitted.</source>
          <target state="translated">Подобно &lt;a href=&quot;#numpy.random.mtrand.RandomState.random_integers&quot;&gt; &lt;code&gt;random_integers&lt;/code&gt; &lt;/a&gt; , только для полуоткрытого интервала [ &lt;code&gt;low&lt;/code&gt; , &lt;code&gt;high&lt;/code&gt; ), и 0 - это самое низкое значение, если &lt;code&gt;high&lt;/code&gt; опущено.</target>
        </trans-unit>
        <trans-unit id="4f32836393c39ad349545e85caa88d4f0b0d4f21" translate="yes" xml:space="preserve">
          <source>Similar to &lt;a href=&quot;numpy.geomspace#numpy.geomspace&quot;&gt;&lt;code&gt;geomspace&lt;/code&gt;&lt;/a&gt;, but with the end points specified as logarithms.</source>
          <target state="translated">Аналогично &lt;a href=&quot;numpy.geomspace#numpy.geomspace&quot;&gt; &lt;code&gt;geomspace&lt;/code&gt; &lt;/a&gt; , но с конечными точками, указанными как логарифмы.</target>
        </trans-unit>
        <trans-unit id="9f556182c8173073bc9575354a35bd7cdcf632ab" translate="yes" xml:space="preserve">
          <source>Similar to &lt;code&gt;np.copyto(arr, vals, where=mask)&lt;/code&gt;, the difference is that &lt;a href=&quot;#numpy.place&quot;&gt;&lt;code&gt;place&lt;/code&gt;&lt;/a&gt; uses the first N elements of &lt;code&gt;vals&lt;/code&gt;, where N is the number of True values in &lt;code&gt;mask&lt;/code&gt;, while &lt;a href=&quot;numpy.copyto#numpy.copyto&quot;&gt;&lt;code&gt;copyto&lt;/code&gt;&lt;/a&gt; uses the elements where &lt;code&gt;mask&lt;/code&gt; is True.</source>
          <target state="translated">Подобно &lt;code&gt;np.copyto(arr, vals, where=mask)&lt;/code&gt; , разница в том, что &lt;a href=&quot;#numpy.place&quot;&gt; &lt;code&gt;place&lt;/code&gt; &lt;/a&gt; использует первые N элементов &lt;code&gt;vals&lt;/code&gt; , где N - количество истинных значений в &lt;code&gt;mask&lt;/code&gt; , а &lt;a href=&quot;numpy.copyto#numpy.copyto&quot;&gt; &lt;code&gt;copyto&lt;/code&gt; &lt;/a&gt; использует элементы, где &lt;code&gt;mask&lt;/code&gt; имеет значение True.</target>
        </trans-unit>
        <trans-unit id="85182c2cf4636594ba4bb81df790d59ce12b4844" translate="yes" xml:space="preserve">
          <source>Similar to a Blackman</source>
          <target state="translated">Как у Блэкмена</target>
        </trans-unit>
        <trans-unit id="fda0ddbefcd9b950d1be64cfa40b8b4d44338564" translate="yes" xml:space="preserve">
          <source>Similar to a Hamming</source>
          <target state="translated">Как в Хэмминге</target>
        </trans-unit>
        <trans-unit id="e44711f2465ecfd9681ac18329e5511ea31ae57b" translate="yes" xml:space="preserve">
          <source>Similar to a Hanning</source>
          <target state="translated">Как у Ханнинга</target>
        </trans-unit>
        <trans-unit id="234d445a03f1aebf3ed4d77e0d02e9c11e9233b2" translate="yes" xml:space="preserve">
          <source>Similar to add_library, but the specified library is installed.</source>
          <target state="translated">Аналогично add_library,но указанная библиотека установлена.</target>
        </trans-unit>
        <trans-unit id="3dfdcd8111d1084fb95920b6488396d3e8d8a393" translate="yes" xml:space="preserve">
          <source>Similar to geomspace, but with arithmetic instead of geometric progression.</source>
          <target state="translated">Аналогично геометрии,но с арифметикой вместо геометрической прогрессии.</target>
        </trans-unit>
        <trans-unit id="33e0805e34847491157755893623c681d0de564b" translate="yes" xml:space="preserve">
          <source>Similar to geomspace, but with endpoints specified using log and base.</source>
          <target state="translated">Аналогично геопространству,но с конечными точками,заданными с помощью лога и базы.</target>
        </trans-unit>
        <trans-unit id="2e5b100f812a24f804b90138859e80b7ccf1d358" translate="yes" xml:space="preserve">
          <source>Similar to linspace, with the step size specified instead of the number of samples.</source>
          <target state="translated">Аналогично линейному пространству,с заданным размером шага вместо количества отсчетов.</target>
        </trans-unit>
        <trans-unit id="17805c407a9f09edaa3bff91c61279fe000f669b" translate="yes" xml:space="preserve">
          <source>Similar to linspace, with the step size specified instead of the number of samples. Note that, when used with a float endpoint, the endpoint may or may not be included.</source>
          <target state="translated">Аналогично линейному пространству,с заданным размером шага вместо количества отсчетов.Обратите внимание,что при использовании с плавающей конечной точкой,конечная точка может быть включена или не включена.</target>
        </trans-unit>
        <trans-unit id="376b7895ca7454ae515537b5c988798aa23f4981" translate="yes" xml:space="preserve">
          <source>Similar to logspace, but with endpoints specified directly.</source>
          <target state="translated">Аналогично лог-пространству,но с прямым указанием конечных точек.</target>
        </trans-unit>
        <trans-unit id="fb5e56ddf3f3d8bcd94b1df305f6991c2bdc0db5" translate="yes" xml:space="preserve">
          <source>Similar to logspace, but with the samples uniformly distributed in linear space, instead of log space.</source>
          <target state="translated">Аналогично бревенчатому пространству,но с образцами,равномерно распределенными в линейном пространстве,а не в бревенчатом.</target>
        </trans-unit>
        <trans-unit id="972ade8b6d212f3e2ece52621379958937336838" translate="yes" xml:space="preserve">
          <source>Similar, but takes a tuple as its argument.</source>
          <target state="translated">Похоже,но в качестве аргумента принимает кортеж.</target>
        </trans-unit>
        <trans-unit id="d90324501e9d6e49bd014963ecc43250f1eed84e" translate="yes" xml:space="preserve">
          <source>Similarly for methods:</source>
          <target state="translated">Аналогично для методов:</target>
        </trans-unit>
        <trans-unit id="8e9eeb8d7a147426a8015c3531ee3a6251c0e6fe" translate="yes" xml:space="preserve">
          <source>Similarly, &lt;code&gt;sqrt&lt;/code&gt;, other base logarithms, &lt;code&gt;power&lt;/code&gt; and trig functions are correctly handled. See their respective docstrings for specific examples.</source>
          <target state="translated">Точно так же правильно обрабатываются &lt;code&gt;sqrt&lt;/code&gt; , другие базовые логарифмы, функции &lt;code&gt;power&lt;/code&gt; и триггера. См. Их соответствующие строки документации для конкретных примеров.</target>
        </trans-unit>
        <trans-unit id="acf3895a0f3e8fb2433f49e7c933653b2955fa80" translate="yes" xml:space="preserve">
          <source>Simple Iteration Example</source>
          <target state="translated">Простой пример итерации</target>
        </trans-unit>
        <trans-unit id="4512383893712587e1eb27a74805a2a877a79b85" translate="yes" xml:space="preserve">
          <source>Simple Multi-Iteration Example</source>
          <target state="translated">Простой пример многократной итерации</target>
        </trans-unit>
        <trans-unit id="50416fe10bcfba1d097d2f78636e350c2106eb91" translate="yes" xml:space="preserve">
          <source>Simple example showing support of broadcasting</source>
          <target state="translated">Простой пример поддержки вещания</target>
        </trans-unit>
        <trans-unit id="ae19d7f5a896d028209ec76ca00e6ca839a5fe6f" translate="yes" xml:space="preserve">
          <source>Simple financial functions</source>
          <target state="translated">Простые финансовые функции</target>
        </trans-unit>
        <trans-unit id="d369dea603addc198cac2b7cf54d9f2f5da3fe8f" translate="yes" xml:space="preserve">
          <source>Simple random data</source>
          <target state="translated">Простые случайные данные</target>
        </trans-unit>
        <trans-unit id="1c8cdc6800aadf2bece7e4049099bee1ec8e07ce" translate="yes" xml:space="preserve">
          <source>Simulate from the complex normal distribution (&lt;code&gt;complex_normal&lt;/code&gt;)</source>
          <target state="translated">Моделировать из сложного нормального распределения ( &lt;code&gt;complex_normal&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="6c7cbba342c72a06adf163e32df8899d2552eb30" translate="yes" xml:space="preserve">
          <source>Simultaneous floor division and remainder.</source>
          <target state="translated">Одновременное деление на этаж и остаток.</target>
        </trans-unit>
        <trans-unit id="5bfc61180c73bf11bcf8e9a59d533a6dcbb10666" translate="yes" xml:space="preserve">
          <source>Since Numpy version 1.17.0 the Generator can be initialized with a number of different BitGenerators. It exposes many different probability distributions. See &lt;a href=&quot;https://www.numpy.org/neps/nep-0019-rng-policy.html&quot;&gt;NEP 19&lt;/a&gt; for context on the updated random Numpy number routines. The legacy &lt;a href=&quot;legacy#numpy.random.mtrand.RandomState&quot;&gt;&lt;code&gt;RandomState&lt;/code&gt;&lt;/a&gt; random number routines are still available, but limited to a single BitGenerator.</source>
          <target state="translated">Начиная с версии Numpy 1.17.0, генератор можно инициализировать с помощью ряда различных генераторов BitGenerator. Он предоставляет множество различных распределений вероятностей. См. &lt;a href=&quot;https://www.numpy.org/neps/nep-0019-rng-policy.html&quot;&gt;NEP 19&lt;/a&gt; для контекста обновленных подпрограмм случайных чисел Numpy. Унаследованные &lt;a href=&quot;legacy#numpy.random.mtrand.RandomState&quot;&gt; &lt;code&gt;RandomState&lt;/code&gt; &lt;/a&gt; случайного числа RandomState все еще доступны, но ограничены одним BitGenerator.</target>
        </trans-unit>
        <trans-unit id="0e5a09c913abb2d820fe3ca564fc0e41384dbaaf" translate="yes" xml:space="preserve">
          <source>Since all ufuncs can take output arguments, this will always be (at least) 1.</source>
          <target state="translated">Так как все ufuncs могут принимать выходные аргументы,это всегда будет (как минимум)1.</target>
        </trans-unit>
        <trans-unit id="2ed82f769a88b72358683adc7002539ca034c05e" translate="yes" xml:space="preserve">
          <source>Since concatenation happens along the last axis first, &lt;a href=&quot;#numpy.block&quot;&gt;&lt;code&gt;block&lt;/code&gt;&lt;/a&gt; is _not_ capable of producing the following directly:</source>
          <target state="translated">Поскольку конкатенация сначала происходит вдоль последней оси, &lt;a href=&quot;#numpy.block&quot;&gt; &lt;code&gt;block&lt;/code&gt; &lt;/a&gt; _не_ способен производить следующее напрямую:</target>
        </trans-unit>
        <trans-unit id="dbccad20cacee376129c1a8bbd5585811048a318" translate="yes" xml:space="preserve">
          <source>Single Array Iteration</source>
          <target state="translated">Одномассивная итерация</target>
        </trans-unit>
        <trans-unit id="1923a37e061c3d312b736626f7d4070c8dcabda6" translate="yes" xml:space="preserve">
          <source>Singular Value Decomposition.</source>
          <target state="translated">Разложение по единичному значению.</target>
        </trans-unit>
        <trans-unit id="be2751c62dbed56ddb419e417fca2d9511c5f595" translate="yes" xml:space="preserve">
          <source>Singular values of &lt;code&gt;a&lt;/code&gt;.</source>
          <target state="translated">Особые значения &lt;code&gt;a&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9f7ca2b11c805ad773c63eebb03a2a048382c59e" translate="yes" xml:space="preserve">
          <source>Size of a pointer on this platform (sizeof(void *)) (A macro defines NPY_SIZEOF_INTP as well.)</source>
          <target state="translated">Размер указателя на данной платформе (sizeof(void *))(Макрос также определяет NPY_SIZEOF_INTP).</target>
        </trans-unit>
        <trans-unit id="f19f296d7676df236287d76dbc5f75e14729bdc6" translate="yes" xml:space="preserve">
          <source>Size of buffer.</source>
          <target state="translated">Размер буфера.</target>
        </trans-unit>
        <trans-unit id="94f57e9139c081fd224904e8757bd108f6615f74" translate="yes" xml:space="preserve">
          <source>Size of spacing between samples.</source>
          <target state="translated">Размер промежутка между образцами.</target>
        </trans-unit>
        <trans-unit id="3de9e845a3b95a48f909e7b501dd8bf3a25f0227" translate="yes" xml:space="preserve">
          <source>Size of the data (how many bytes is in &lt;em&gt;e.g.&lt;/em&gt; the integer)</source>
          <target state="translated">Размер данных (сколько байтов, &lt;em&gt;например,&lt;/em&gt; целое число)</target>
        </trans-unit>
        <trans-unit id="69356099c1bda1de5732916fcc4b059a9e5e1e9d" translate="yes" xml:space="preserve">
          <source>Size of the data is in turn described by:</source>
          <target state="translated">Размер данных,в свою очередь,описывается:</target>
        </trans-unit>
        <trans-unit id="b7b677e8d293fb1fdabc56b0ddc443af48c5aeca" translate="yes" xml:space="preserve">
          <source>Size of the iterator.</source>
          <target state="translated">Размер итератора.</target>
        </trans-unit>
        <trans-unit id="9f5f50339fb8609920b44a4a178129be24577d29" translate="yes" xml:space="preserve">
          <source>Size of the pooled entropy to store. Default is 4 to give a 128-bit entropy pool. 8 (for 256 bits) is another reasonable choice if working with larger PRNGs, but there is very little to be gained by selecting another value.</source>
          <target state="translated">Размер объединенной энтропии для хранения.По умолчанию 4,чтобы дать 128-битный пул энтропии.8 (для 256 бит)-еще один разумный выбор при работе с большими ГПСЧ,но очень малое значение можно получить,выбрав другое.</target>
        </trans-unit>
        <trans-unit id="425427638096d8909ac722e80f2f8c0179bde19c" translate="yes" xml:space="preserve">
          <source>Size of the returned identity matrix.</source>
          <target state="translated">Размер возвращаемой матрицы личности.</target>
        </trans-unit>
        <trans-unit id="c4824192ad4385f49198eaabf9b1f747f0e02ed6" translate="yes" xml:space="preserve">
          <source>Size of ufunc buffer in bytes.</source>
          <target state="translated">Размер буфера ufunc в байтах.</target>
        </trans-unit>
        <trans-unit id="ad4bbd7cecbd939b77596b18a5178a89c143d6ba" translate="yes" xml:space="preserve">
          <source>Skip the first &lt;code&gt;skiprows&lt;/code&gt; lines, including comments; default: 0.</source>
          <target state="translated">&lt;code&gt;skiprows&lt;/code&gt; первые строки с пропуском строк, включая комментарии; по умолчанию: 0.</target>
        </trans-unit>
        <trans-unit id="ceefed34cafaf5b19edca282e41b54d0f46c4e35" translate="yes" xml:space="preserve">
          <source>Slicing creates a view, whose memory is shared with x:</source>
          <target state="translated">Нарезка создает вид,память которого совместно используется с x:</target>
        </trans-unit>
        <trans-unit id="68f51b4a2c9bfa7e4967d12fe3615173471a2867" translate="yes" xml:space="preserve">
          <source>Small results can be suppressed:</source>
          <target state="translated">Небольшие результаты могут быть подавлены:</target>
        </trans-unit>
        <trans-unit id="55c8d4062bb648b3be6e31f36bb0441eeb936269" translate="yes" xml:space="preserve">
          <source>Smallest (most negative) power of &lt;code&gt;ibeta&lt;/code&gt; consistent with there being no leading zeros in the mantissa.</source>
          <target state="translated">Наименьшая (самая отрицательная) степень &lt;code&gt;ibeta&lt;/code&gt; соответствующая отсутствию ведущих нулей в мантиссе.</target>
        </trans-unit>
        <trans-unit id="5723001a57f6b6652b2b21977d2b2710160cd8a8" translate="yes" xml:space="preserve">
          <source>Smallest (positive) power of &lt;code&gt;ibeta&lt;/code&gt; that causes overflow.</source>
          <target state="translated">Наименьшая (положительная) мощность &lt;code&gt;ibeta&lt;/code&gt; , вызывающая переполнение.</target>
        </trans-unit>
        <trans-unit id="77213ab3e24eed5431e4dc1329418d12eafeda49" translate="yes" xml:space="preserve">
          <source>Smallest size of user-settable internal buffers.</source>
          <target state="translated">Наименьший размер устанавливаемых пользователем внутренних буферов.</target>
        </trans-unit>
        <trans-unit id="5987afde50b9e89e0e7eef5d3f74c5e410d18d69" translate="yes" xml:space="preserve">
          <source>So if this is true, why not choose the index order that matches what you most expect? In particular, why not define row-ordered images to use the image convention? (This is sometimes referred to as the Fortran convention vs the C convention, thus the &amp;lsquo;C&amp;rsquo; and &amp;lsquo;FORTRAN&amp;rsquo; order options for array ordering in numpy.) The drawback of doing this is potential performance penalties. It&amp;rsquo;s common to access the data sequentially, either implicitly in array operations or explicitly by looping over rows of an image. When that is done, then the data will be accessed in non-optimal order. As the first index is incremented, what is actually happening is that elements spaced far apart in memory are being sequentially accessed, with usually poor memory access speeds. For example, for a two dimensional image &amp;lsquo;im&amp;rsquo; defined so that im[0, 10] represents the value at x=0, y=10. To be consistent with usual Python behavior then im[0] would represent a column at x=0. Yet that data would be spread over the whole array since the data are stored in row order. Despite the flexibility of numpy&amp;rsquo;s indexing, it can&amp;rsquo;t really paper over the fact basic operations are rendered inefficient because of data order or that getting contiguous subarrays is still awkward (e.g., im[:,0] for the first row, vs im[0]), thus one can&amp;rsquo;t use an idiom such as for row in im; for col in im does work, but doesn&amp;rsquo;t yield contiguous column data.</source>
          <target state="translated">Итак, если это правда, почему бы не выбрать порядок индекса, который соответствует вашим ожиданиям? В частности, почему бы не определить изображения с упорядочением по строкам, чтобы использовать соглашение об изображениях? (Это иногда называют соглашением Fortran по сравнению с соглашением C, таким образом, варианты порядка &amp;laquo;C&amp;raquo; и &amp;laquo;FORTRAN&amp;raquo; для упорядочивания массивов в numpy.) Недостатком этого является потенциальное снижение производительности. Обычно доступ к данным осуществляется последовательно, либо неявно в операциях с массивами, либо явно путем перебора строк изображения. Когда это будет сделано, доступ к данным будет осуществляться в неоптимальном порядке. По мере увеличения первого индекса на самом деле происходит то, что к элементам, расположенным далеко друг от друга в памяти, осуществляется последовательный доступ, обычно с низкой скоростью доступа к памяти. Например, для двумерного изображения 'im' определено так, что im [0, 10] представляет значение при x = 0,у = 10. Чтобы соответствовать обычному поведению Python, im [0] будет представлять столбец с x = 0. Однако эти данные будут распределены по всему массиву, поскольку данные хранятся в порядке строк. Несмотря на гибкость индексирования numpy, он не может скрыть тот факт, что основные операции оказываются неэффективными из-за порядка данных или того, что получение непрерывных подмассивов по-прежнему неудобно (например, im [:, 0] для первой строки, vs im [ 0]), поэтому нельзя использовать идиому, например, для строки в im; for col in im работает, но не дает данных непрерывного столбца.на самом деле он не может скрыть тот факт, что основные операции оказываются неэффективными из-за порядка данных или что получение непрерывных подмассивов все еще неудобно (например, im [:, 0] для первой строки, vs im [0]), поэтому можно не используйте идиому, например, для строки в im; for col in im работает, но не дает данных непрерывного столбца.на самом деле он не может скрыть тот факт, что основные операции оказываются неэффективными из-за порядка данных или что получение непрерывных подмассивов все еще неудобно (например, im [:, 0] для первой строки, vs im [0]), поэтому можно не используйте идиому, например, для строки в im; for col in im работает, но не дает данных непрерывного столбца.</target>
        </trans-unit>
        <trans-unit id="75338853856b7644da267b729869a79f35465ac8" translate="yes" xml:space="preserve">
          <source>So the p-value is about 0.009, which says the null hypothesis has a probability of about 99% of being true.</source>
          <target state="translated">Таким образом,р-значение составляет около 0.009,что говорит о том,что нулевая гипотеза имеет вероятность около 99% от истины.</target>
        </trans-unit>
        <trans-unit id="b22b13d407a40d9045527bdf90132a3a9fa96895" translate="yes" xml:space="preserve">
          <source>So there is about a 1% chance that the F statistic will exceed 7.62, the measured value is 36, so the null hypothesis is rejected at the 1% level.</source>
          <target state="translated">Таким образом,существует около 1% вероятность того,что статистика F превысит 7.62,измеренное значение 36,поэтому нулевая гипотеза отвергается на 1%-м уровне.</target>
        </trans-unit>
        <trans-unit id="a6530c806dc81f899a20b29f20f0a01aeaaaf38e" translate="yes" xml:space="preserve">
          <source>So, over 64 months would be required to pay off the loan.</source>
          <target state="translated">Таким образом,для погашения кредита потребуется более 64 месяцев.</target>
        </trans-unit>
        <trans-unit id="a5004dc1aab93010354b018bb188be79f920df9c" translate="yes" xml:space="preserve">
          <source>So, to end up with the same $15692.93 under the same $100 per month &amp;ldquo;savings plan,&amp;rdquo; for annual interest rates of 4% and 3%, one would need initial investments of $649.27 and $1273.79, respectively.</source>
          <target state="translated">Таким образом, чтобы получить те же 15692,93 доллара в рамках того же &amp;laquo;плана сбережений&amp;raquo; в 100 долларов в месяц при годовой процентной ставке 4% и 3%, потребуются первоначальные инвестиции в размере 649,27 долларов и 1273,79 долларов соответственно.</target>
        </trans-unit>
        <trans-unit id="6ebdb3e9e8d6757481f655d319b1afadf8dc01e9" translate="yes" xml:space="preserve">
          <source>Solution to the system a x = b. Returned shape is identical to &lt;code&gt;b&lt;/code&gt;.</source>
          <target state="translated">Решение системы ax = b. Возвращенная форма идентична &lt;code&gt;b&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="47cd45ea813008c51999b21afe4021732229d27d" translate="yes" xml:space="preserve">
          <source>Solve a linear matrix equation, or system of linear scalar equations.</source>
          <target state="translated">Решить линейное матричное уравнение,или систему линейных скалярных уравнений.</target>
        </trans-unit>
        <trans-unit id="f401130634f936a923b84a9e812b9c0958189ce8" translate="yes" xml:space="preserve">
          <source>Solve the system of equations &lt;code&gt;3 * x0 + x1 = 9&lt;/code&gt; and &lt;code&gt;x0 + 2 * x1 = 8&lt;/code&gt;:</source>
          <target state="translated">Решите систему уравнений &lt;code&gt;3 * x0 + x1 = 9&lt;/code&gt; и &lt;code&gt;x0 + 2 * x1 = 8&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="4fa6a62025edb0c24849f443aeee1762c51d4292" translate="yes" xml:space="preserve">
          <source>Solve the tensor equation &lt;code&gt;a x = b&lt;/code&gt; for x.</source>
          <target state="translated">Решите тензорное уравнение &lt;code&gt;a x = b&lt;/code&gt; относительно x.</target>
        </trans-unit>
        <trans-unit id="2662dd226f62ccee1e8db7abb4ac87cf33caa66b" translate="yes" xml:space="preserve">
          <source>Solves the equation</source>
          <target state="translated">Решает уравнение</target>
        </trans-unit>
        <trans-unit id="c7e1b491799507ad39ca1efa34833c4a45590d4c" translate="yes" xml:space="preserve">
          <source>Solving equations and inverting matrices</source>
          <target state="translated">Решение уравнений и инвертирующих матриц</target>
        </trans-unit>
        <trans-unit id="43b0492eef0c0518822e4513393b1d39235d0d0e" translate="yes" xml:space="preserve">
          <source>Some cases where uint and true alignment are different ()</source>
          <target state="translated">Некоторые случаи,когда вента и истинное выравнивание различаются ()</target>
        </trans-unit>
        <trans-unit id="d1019de292a3b48b30fff1374e4676305929bebd" translate="yes" xml:space="preserve">
          <source>Some cases where uint and true alignment are different (default gcc linux):</source>
          <target state="translated">Некоторые случаи,когда uint и истинное выравнивание отличаются (по умолчанию gcc linux):</target>
        </trans-unit>
        <trans-unit id="01706013cfdbcb0fc543d3c97784f3f4c235d630" translate="yes" xml:space="preserve">
          <source>Some examples:</source>
          <target state="translated">Несколько примеров:</target>
        </trans-unit>
        <trans-unit id="8c00107ac79c20e1a081f03fb6cbaba3191f960b" translate="yes" xml:space="preserve">
          <source>Some of the scalar types are essentially equivalent to fundamental Python types and therefore inherit from them as well as from the generic array scalar type:</source>
          <target state="translated">Некоторые из скалярных типов по существу эквивалентны фундаментальным типам питонов и поэтому наследуются как от них,так и от общего скалярного типа массива:</target>
        </trans-unit>
        <trans-unit id="c85e63aec45df025bea301bcb4bf6b89b178cf85" translate="yes" xml:space="preserve">
          <source>Some old Fortran codes need special compiler options in order to work correctly. In order to specify compiler options per source file, &lt;code&gt;numpy.distutils&lt;/code&gt; Fortran compiler looks for the following pattern:</source>
          <target state="translated">Некоторым старым кодам Fortran для правильной работы требуются специальные параметры компилятора. Чтобы указать параметры компилятора для каждого исходного файла, компилятор &lt;code&gt;numpy.distutils&lt;/code&gt; Fortran ищет следующий шаблон:</target>
        </trans-unit>
        <trans-unit id="b279d322696735803b77494e0d85658168ba5e97" translate="yes" xml:space="preserve">
          <source>Some spreadsheet programs calculate the &amp;ldquo;floor-towards-zero&amp;rdquo;, in other words &lt;code&gt;floor(-2.5) == -2&lt;/code&gt;. NumPy instead uses the definition of &lt;a href=&quot;#numpy.floor&quot;&gt;&lt;code&gt;floor&lt;/code&gt;&lt;/a&gt; where &lt;code&gt;floor(-2.5) == -3&lt;/code&gt;.</source>
          <target state="translated">Некоторые программы для работы с электронными таблицами вычисляют &amp;laquo;нижний предел&amp;raquo;, другими словами, &lt;code&gt;floor(-2.5) == -2&lt;/code&gt; . NumPy вместо этого использует определение &lt;a href=&quot;#numpy.floor&quot;&gt; &lt;code&gt;floor&lt;/code&gt; &lt;/a&gt; где &lt;code&gt;floor(-2.5) == -3&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e076ea295087ca8af80708dc44915c8314e4840f" translate="yes" xml:space="preserve">
          <source>Some useful aliases of the above types are</source>
          <target state="translated">Некоторые полезные псевдонимы вышеуказанных типов</target>
        </trans-unit>
        <trans-unit id="1671b95e5ffbf1238a81b8297939415d3fd1114c" translate="yes" xml:space="preserve">
          <source>Something like the following code can be used to support both &lt;code&gt;RandomState&lt;/code&gt; and &lt;code&gt;Generator&lt;/code&gt;, with the understanding that the interfaces are slightly different</source>
          <target state="translated">Что-то вроде следующего кода можно использовать для поддержки как &lt;code&gt;RandomState&lt;/code&gt; ,так и &lt;code&gt;Generator&lt;/code&gt; , при том понимании, что интерфейсы немного отличаются</target>
        </trans-unit>
        <trans-unit id="9467a0f0b915a6467304173ebaf28fafa38f3924" translate="yes" xml:space="preserve">
          <source>Sometimes it is useful to access a multidimensional array as a C-style multi-dimensional array so that algorithms can be implemented using C&amp;rsquo;s a[i][j][k] syntax. This routine returns a pointer, &lt;em&gt;ptr&lt;/em&gt;, that simulates this kind of C-style array, for 1-, 2-, and 3-d ndarrays.</source>
          <target state="translated">Иногда бывает полезно получить доступ к многомерному массиву как к многомерному массиву в стиле C, чтобы алгоритмы могли быть реализованы с использованием синтаксиса C a [i] [j] [k]. Эта процедура возвращает указатель &lt;em&gt;ptr&lt;/em&gt; , который имитирует этот тип массива в стиле C для 1-, 2- и 3-х мерных массивов.</target>
        </trans-unit>
        <trans-unit id="ec72337ff3c83f7940812234b3ba998c6f082e9e" translate="yes" xml:space="preserve">
          <source>Sometimes it may be useful to get the N-dimensional index while iterating. The ndenumerate iterator can achieve this.</source>
          <target state="translated">Иногда бывает полезно получить N-мерный индекс во время итерации.Итератор ndenumerate может достичь этого.</target>
        </trans-unit>
        <trans-unit id="0744d9126505450547757e296c542c0b00376d4c" translate="yes" xml:space="preserve">
          <source>Sometimes you might want to skip a test or mark it as a known failure, such as when the test suite is being written before the code it&amp;rsquo;s meant to test, or if a test only fails on a particular architecture.</source>
          <target state="translated">Иногда вам может потребоваться пропустить тест или пометить его как известный сбой, например, когда набор тестов пишется до кода, который он предназначен для тестирования, или если тест дает сбой только на определенной архитектуре.</target>
        </trans-unit>
        <trans-unit id="c295e72861adbd23ef6b2dcbfed6577dacefe499" translate="yes" xml:space="preserve">
          <source>Sometimes, the best approach is to use the &lt;code&gt;%extend&lt;/code&gt; directive to define new methods for your classes (or overload existing ones) that take a &lt;code&gt;PyObject*&lt;/code&gt; (that either is or can be converted to a &lt;code&gt;PyArrayObject*&lt;/code&gt;) instead of a pointer to a buffer. In this case, the helper routines in &lt;code&gt;numpy.i&lt;/code&gt; can be very useful.</source>
          <target state="translated">Иногда лучший подход - использовать директиву &lt;code&gt;%extend&lt;/code&gt; для определения новых методов для ваших классов (или перегрузки существующих), которые принимают &lt;code&gt;PyObject*&lt;/code&gt; (который либо является, либо может быть преобразован в &lt;code&gt;PyArrayObject*&lt;/code&gt; ) вместо указателя на буфер. . В этом случае могут быть очень полезны вспомогательные процедуры в &lt;code&gt;numpy.i&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="013e7e93c49d182f82742c8920c97f56d061e7e4" translate="yes" xml:space="preserve">
          <source>Somewhat more sophisticated example</source>
          <target state="translated">Несколько более сложный пример</target>
        </trans-unit>
        <trans-unit id="328b7438e36cdae2c28d64a3dd3bc7ddc0df1e77" translate="yes" xml:space="preserve">
          <source>Sort a complex array using the real part first, then the imaginary part.</source>
          <target state="translated">Сортируйте сложный массив,используя сначала реальную,а затем воображаемую часть.</target>
        </trans-unit>
        <trans-unit id="7703cef2dff0050a3552375a078ec7f70589b4bd" translate="yes" xml:space="preserve">
          <source>Sort an array in-place.</source>
          <target state="translated">Сортируйте массив на месте.</target>
        </trans-unit>
        <trans-unit id="758912cadfdc3e6db6c081dc567a966e86a886f3" translate="yes" xml:space="preserve">
          <source>Sort an array in-place. Refer to &lt;a href=&quot;numpy.sort#numpy.sort&quot;&gt;&lt;code&gt;numpy.sort&lt;/code&gt;&lt;/a&gt; for full documentation.</source>
          <target state="translated">Отсортируйте массив на месте. Обратитесь к &lt;a href=&quot;numpy.sort#numpy.sort&quot;&gt; &lt;code&gt;numpy.sort&lt;/code&gt; &lt;/a&gt; для получения полной документации.</target>
        </trans-unit>
        <trans-unit id="e971cf5812926cfacabdee56dc64c56ffada0b99" translate="yes" xml:space="preserve">
          <source>Sort by age, then height if ages are equal:</source>
          <target state="translated">Сортировать по возрасту,а затем по росту,если возраст одинаков:</target>
        </trans-unit>
        <trans-unit id="edf066d3ae816f3adbcc852b784794ee538b1cc5" translate="yes" xml:space="preserve">
          <source>Sort names: first by surname, then by name.</source>
          <target state="translated">Сортировочные имена:сначала по фамилии,потом по имени.</target>
        </trans-unit>
        <trans-unit id="c29b838e8a5ddeb05ab8f84b06787846a1a439df" translate="yes" xml:space="preserve">
          <source>Sort the array, in-place</source>
          <target state="translated">Сортировать массив,на месте</target>
        </trans-unit>
        <trans-unit id="b84eb35a33eb1b763dfde94c1db6ce2176107aa8" translate="yes" xml:space="preserve">
          <source>Sort two columns of numbers:</source>
          <target state="translated">Отсортируйте две колонки чисел:</target>
        </trans-unit>
        <trans-unit id="880e5dacaffdb29c387c406a9aa16d00ec9b6165" translate="yes" xml:space="preserve">
          <source>Sorted 1D array of common and unique elements.</source>
          <target state="translated">Сортированный 1D массив общих и уникальных элементов.</target>
        </trans-unit>
        <trans-unit id="2b58c607b5c87ff5c9488ade6840a7c97cabbe74" translate="yes" xml:space="preserve">
          <source>Sorted 1D array of unique values that are in only one of the input arrays.</source>
          <target state="translated">Сортировка 1D массива уникальных значений,которые находятся только в одном из входных массивов.</target>
        </trans-unit>
        <trans-unit id="378e9e163b7eecefadb4415cae533096e336c4ab" translate="yes" xml:space="preserve">
          <source>Sorting</source>
          <target state="translated">Sorting</target>
        </trans-unit>
        <trans-unit id="ba112ceba77d3fead905df9fb056b8ffb7481e25" translate="yes" xml:space="preserve">
          <source>Sorting algorithm. The default is &amp;lsquo;quicksort&amp;rsquo;. Note that both &amp;lsquo;stable&amp;rsquo; and &amp;lsquo;mergesort&amp;rsquo; use timsort or radix sort under the covers and, in general, the actual implementation will vary with data type. The &amp;lsquo;mergesort&amp;rsquo; option is retained for backwards compatibility.</source>
          <target state="translated">Алгоритм сортировки. По умолчанию используется &amp;laquo;быстрая сортировка&amp;raquo;. Обратите внимание, что как &amp;laquo;стабильная&amp;raquo;, так и &amp;laquo;сортировка слиянием&amp;raquo; используют временную или основную сортировку, и, как правило, фактическая реализация будет зависеть от типа данных. Параметр &amp;laquo;сортировка слиянием&amp;raquo; сохранен для обратной совместимости.</target>
        </trans-unit>
        <trans-unit id="0575bbf541bc6691bd2f441dd799bc35084ddbf2" translate="yes" xml:space="preserve">
          <source>Sorting algorithm. The default is &amp;lsquo;quicksort&amp;rsquo;. Note that both &amp;lsquo;stable&amp;rsquo; and &amp;lsquo;mergesort&amp;rsquo; use timsort under the covers and, in general, the actual implementation will vary with data type. The &amp;lsquo;mergesort&amp;rsquo; option is retained for backwards compatibility.</source>
          <target state="translated">Алгоритм сортировки. По умолчанию используется &amp;laquo;быстрая сортировка&amp;raquo;. Обратите внимание, что как &amp;laquo;стабильная&amp;raquo;, так и &amp;laquo;сортировка слиянием&amp;raquo; используют временную сортировку под прикрытием, и, как правило, фактическая реализация будет зависеть от типа данных. Параметр &amp;laquo;сортировка слиянием&amp;raquo; сохранен для обратной совместимости.</target>
        </trans-unit>
        <trans-unit id="2cdbbd83ff8697bca9c84ed001e2e5d899425b4f" translate="yes" xml:space="preserve">
          <source>Sorting algorithm. The default is &amp;lsquo;quicksort&amp;rsquo;. Note that both &amp;lsquo;stable&amp;rsquo; and &amp;lsquo;mergesort&amp;rsquo; use timsort under the covers and, in general, the actual implementation will vary with datatype. The &amp;lsquo;mergesort&amp;rsquo; option is retained for backwards compatibility.</source>
          <target state="translated">Алгоритм сортировки. По умолчанию используется &amp;laquo;быстрая сортировка&amp;raquo;. Обратите внимание, что как &amp;laquo;стабильная&amp;raquo;, так и &amp;laquo;сортировка слиянием&amp;raquo; используют временную сортировку под прикрытием, и, как правило, фактическая реализация будет зависеть от типа данных. Параметр &amp;laquo;сортировка слиянием&amp;raquo; сохранен для обратной совместимости.</target>
        </trans-unit>
        <trans-unit id="bdc99b8f2211c27e95a7ae2ea3c4e510c89721f9" translate="yes" xml:space="preserve">
          <source>Sorting with keys:</source>
          <target state="translated">Сортировка с помощью клавиш:</target>
        </trans-unit>
        <trans-unit id="26d009fe61cd6c804332028c785b29bfb52d084f" translate="yes" xml:space="preserve">
          <source>Sorting, searching, and counting</source>
          <target state="translated">Сортировка,поиск и подсчет</target>
        </trans-unit>
        <trans-unit id="6767832dfbb08054083a5a2806dbcbcc61e43981" translate="yes" xml:space="preserve">
          <source>Source array</source>
          <target state="translated">Массив источников</target>
        </trans-unit>
        <trans-unit id="f129cc36c0cc30f28b30e1834c4eba00a6a6b06e" translate="yes" xml:space="preserve">
          <source>Source of entropy. &amp;lsquo;system&amp;rsquo; uses system cryptographic pool. &amp;lsquo;fallback&amp;rsquo; uses a hash of the time and process id.</source>
          <target state="translated">Источник энтропии. 'system' использует системный криптографический пул. 'fallback' использует хэш времени и идентификатор процесса.</target>
        </trans-unit>
        <trans-unit id="dc1737b3b1fae12e4ca81687b7ce0c8d06e3bfa1" translate="yes" xml:space="preserve">
          <source>Spacing between f values. Default unitary spacing for all dimensions. Spacing can be specified using:</source>
          <target state="translated">Расстояние между f-значениями.Унитарное расстояние по умолчанию для всех размеров.Расстояние может быть задано с помощью:</target>
        </trans-unit>
        <trans-unit id="534a506bdd04ed14f369aaa8c5d2a5a1b475cf75" translate="yes" xml:space="preserve">
          <source>Spacing between values. For any output &lt;code&gt;out&lt;/code&gt;, this is the distance between two adjacent values, &lt;code&gt;out[i+1] - out[i]&lt;/code&gt;. The default step size is 1. If &lt;code&gt;step&lt;/code&gt; is specified as a position argument, &lt;code&gt;start&lt;/code&gt; must also be given.</source>
          <target state="translated">Расстояние между значениями. Для любого выхода &lt;code&gt;out&lt;/code&gt; это расстояние между двумя соседними значениями &lt;code&gt;out[i+1] - out[i]&lt;/code&gt; . Размер шага по умолчанию равен 1. Если &lt;code&gt;step&lt;/code&gt; указан в качестве аргумента позиции, также необходимо указать &lt;code&gt;start&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9b1c83ae389903de1c17429b8031bd633cfea38a" translate="yes" xml:space="preserve">
          <source>Spacing can be also specified with an array that represents the coordinates of the values F along the dimensions. For instance a uniform spacing:</source>
          <target state="translated">Расстояние также может быть задано с помощью массива,который представляет координаты значений F вдоль размеров.Например,равномерное расстояние:</target>
        </trans-unit>
        <trans-unit id="3c1452a3b0205f538f941fa6e2df87a5606ff452" translate="yes" xml:space="preserve">
          <source>Spacing of +- inf and NaN is NaN.</source>
          <target state="translated">Расстояние +-inf и NaN-NaN.</target>
        </trans-unit>
        <trans-unit id="23afed8ee1674d2a0d0a6b27d54e26458214a09b" translate="yes" xml:space="preserve">
          <source>Spawn a number of child &lt;a href=&quot;#numpy.random.SeedSequence&quot;&gt;&lt;code&gt;SeedSequence&lt;/code&gt;&lt;/a&gt; s by extending the &lt;a href=&quot;numpy.random.seedsequence.spawn_key#numpy.random.SeedSequence.spawn_key&quot;&gt;&lt;code&gt;spawn_key&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#numpy.random.SeedSequence&quot;&gt; &lt;code&gt;SeedSequence&lt;/code&gt; &lt;/a&gt; несколько дочерних SeedSequence , расширив &lt;a href=&quot;numpy.random.seedsequence.spawn_key#numpy.random.SeedSequence.spawn_key&quot;&gt; &lt;code&gt;spawn_key&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="91b21b0aabd8c374de6706b913967d168827f182" translate="yes" xml:space="preserve">
          <source>Spawn a number of child &lt;a href=&quot;numpy.random.seedsequence#numpy.random.SeedSequence&quot;&gt;&lt;code&gt;SeedSequence&lt;/code&gt;&lt;/a&gt; s by extending the &lt;a href=&quot;numpy.random.seedsequence.spawn_key#numpy.random.SeedSequence.spawn_key&quot;&gt;&lt;code&gt;spawn_key&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;numpy.random.seedsequence#numpy.random.SeedSequence&quot;&gt; &lt;code&gt;SeedSequence&lt;/code&gt; &lt;/a&gt; несколько дочерних SeedSequence , расширив &lt;a href=&quot;numpy.random.seedsequence.spawn_key#numpy.random.SeedSequence.spawn_key&quot;&gt; &lt;code&gt;spawn_key&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="3011c57bc17adfb34d1d5b7d2a537f2f42b61ecd" translate="yes" xml:space="preserve">
          <source>Spawn a number of child &lt;code&gt;SeedSequence&lt;/code&gt; s by extending the &lt;code&gt;spawn_key&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;SeedSequence&lt;/code&gt; несколько дочерних SeedSequence , расширив &lt;code&gt;spawn_key&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5bdcbf562b3722f869ecc22fc6f007711257a292" translate="yes" xml:space="preserve">
          <source>Special attributes and methods</source>
          <target state="translated">Специальные атрибуты и методы</target>
        </trans-unit>
        <trans-unit id="aed4a5ac93d537d2fee54607e067f0fcd734c2a7" translate="yes" xml:space="preserve">
          <source>Special case of &lt;a href=&quot;#c.PyArray_EquivTypes&quot;&gt;&lt;code&gt;PyArray_EquivTypes&lt;/code&gt;&lt;/a&gt; (&amp;hellip;) that does not accept flexible data types but may be easier to call.</source>
          <target state="translated">Особый случай &lt;a href=&quot;#c.PyArray_EquivTypes&quot;&gt; &lt;code&gt;PyArray_EquivTypes&lt;/code&gt; &lt;/a&gt; (&amp;hellip;), который не принимает гибкие типы данных, но может быть проще вызвать.</target>
        </trans-unit>
        <trans-unit id="1fe419ca9a2135cb73cdfe673bb644f8c5d089ef" translate="yes" xml:space="preserve">
          <source>Special case of &lt;a href=&quot;#c.PyArray_FromAny&quot;&gt;&lt;code&gt;PyArray_FromAny&lt;/code&gt;&lt;/a&gt; for when &lt;em&gt;op&lt;/em&gt; is already an array but it needs to be of a specific &lt;em&gt;newtype&lt;/em&gt; (including byte-order) or has certain &lt;em&gt;requirements&lt;/em&gt;.</source>
          <target state="translated">Особый случай &lt;a href=&quot;#c.PyArray_FromAny&quot;&gt; &lt;code&gt;PyArray_FromAny&lt;/code&gt; ,&lt;/a&gt; когда &lt;em&gt;op&lt;/em&gt; уже является массивом, но должен быть определенного &lt;em&gt;нового типа&lt;/em&gt; (включая порядок байтов) или иметь определенные &lt;em&gt;требования&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="60bf3781f7b69622f4280d80dab8f4e70529bfe8" translate="yes" xml:space="preserve">
          <source>Special functions for NPY_OBJECT</source>
          <target state="translated">Специальные функции для NPY_OBJECT</target>
        </trans-unit>
        <trans-unit id="b3dfcf123c0344e2a770caf2c6d80f585312a2df" translate="yes" xml:space="preserve">
          <source>Special hook for ufuncs.</source>
          <target state="translated">Специальный крючок для уфанков.</target>
        </trans-unit>
        <trans-unit id="93a7e480fca31e54d3a1bf415987f972c987379d" translate="yes" xml:space="preserve">
          <source>Special methods</source>
          <target state="translated">Специальные методики</target>
        </trans-unit>
        <trans-unit id="3002d8550adc7583b9e34c0e71be4f097501b6cb" translate="yes" xml:space="preserve">
          <source>Specific methods</source>
          <target state="translated">Конкретные методы</target>
        </trans-unit>
        <trans-unit id="cf2f0aad66d259134ba110faea6639bae5dba0cf" translate="yes" xml:space="preserve">
          <source>Specifies how indices outside &lt;code&gt;[0, n-1]&lt;/code&gt; will be treated:</source>
          <target state="translated">Определяет, как будут обрабатываться индексы вне &lt;code&gt;[0, n-1]&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="a7fddec5bc5d09611a6a6411474f1557bfcece40" translate="yes" xml:space="preserve">
          <source>Specifies how out-of-bounds indices are handled. Can specify either one mode or a tuple of modes, one mode per index.</source>
          <target state="translated">Указывает,как обрабатываются внебиржевые индексы.Может указывать один режим или кортеж режимов,один режим на индекс.</target>
        </trans-unit>
        <trans-unit id="bd5a8d9eaa67a4089d4d8ea6c9d2499b271531d4" translate="yes" xml:space="preserve">
          <source>Specifies how out-of-bounds indices will behave.</source>
          <target state="translated">Указывает,как будут вести себя внебиржевые индексы.</target>
        </trans-unit>
        <trans-unit id="0c82c7d4c03f4e3d40af4885f34fa55cd32452a2" translate="yes" xml:space="preserve">
          <source>Specifies how out-of-bounds indices will behave. &amp;lsquo;raise&amp;rsquo; : raise an error. &amp;lsquo;wrap&amp;rsquo; : wrap around. &amp;lsquo;clip&amp;rsquo; : clip to the range.</source>
          <target state="translated">Определяет, как будут вести себя индексы за пределами границ. &amp;laquo;поднять&amp;raquo;: вызвать ошибку. 'wrap': обернуть. 'clip': обрезать до диапазона.</target>
        </trans-unit>
        <trans-unit id="613844173fd200c8dfdc2aaedd515354fe3b2a25" translate="yes" xml:space="preserve">
          <source>Specifies how to handle encoding errors</source>
          <target state="translated">Указывает,как работать с ошибками кодирования</target>
        </trans-unit>
        <trans-unit id="9b982562ff1b137afe496fb00468655c2065dda1" translate="yes" xml:space="preserve">
          <source>Specifies the calculation iteration order/memory layout of the output array. Defaults to &amp;lsquo;K&amp;rsquo;. &amp;lsquo;C&amp;rsquo; means the output should be C-contiguous, &amp;lsquo;F&amp;rsquo; means F-contiguous, &amp;lsquo;A&amp;rsquo; means F-contiguous if the inputs are F-contiguous and not also not C-contiguous, C-contiguous otherwise, and &amp;lsquo;K&amp;rsquo; means to match the element ordering of the inputs as closely as possible.</source>
          <target state="translated">Задает порядок итерации вычислений / структуру памяти выходного массива. По умолчанию &amp;laquo;K&amp;raquo;. 'C' означает, что выходные данные должны быть C-смежными, 'F' означает F-смежными, 'A' означает F-смежными, если входы являются F-смежными, а не также C-смежными, C-смежными в противном случае и 'K 'означает как можно точнее соответствовать порядку элементов входных данных.</target>
        </trans-unit>
        <trans-unit id="050a737d589d7084aca709c1606453929922c13e" translate="yes" xml:space="preserve">
          <source>Specifies the minimum number of dimensions that the resulting array should have. Ones will be pre-pended to the shape as needed to meet this requirement.</source>
          <target state="translated">Указывает минимальное количество размеров,которое должен иметь результирующий массив.Объекты будут предустановлены на форму,необходимую для выполнения этого требования.</target>
        </trans-unit>
        <trans-unit id="1931e4d3fdc0bcca4a66f0fb2135dc85de6a0cb0" translate="yes" xml:space="preserve">
          <source>Specifies the subscripts for summation as comma separated list of subscript labels. An implicit (classical Einstein summation) calculation is performed unless the explicit indicator &amp;lsquo;-&amp;gt;&amp;rsquo; is included as well as subscript labels of the precise output form.</source>
          <target state="translated">Задает индексы для суммирования как список разделенных запятыми меток индексов. Неявное (классическое суммирование Эйнштейна) вычисление выполняется, если не включен явный индикатор '-&amp;gt;', а также нижние метки точной формы вывода.</target>
        </trans-unit>
        <trans-unit id="7ecc55fddab59538bed27df3a80b7134cf4b1452" translate="yes" xml:space="preserve">
          <source>Specifies the subscripts for summation.</source>
          <target state="translated">Определяет подписки для суммирования.</target>
        </trans-unit>
        <trans-unit id="dc782b605bddd3902febdfde45c4deaed380a257" translate="yes" xml:space="preserve">
          <source>Specifies whether the calculation is done with the lower triangular part of &lt;code&gt;a&lt;/code&gt; (&amp;lsquo;L&amp;rsquo;, default) or the upper triangular part (&amp;lsquo;U&amp;rsquo;). Irrespective of this value only the real parts of the diagonal will be considered in the computation to preserve the notion of a Hermitian matrix. It therefore follows that the imaginary part of the diagonal will always be treated as zero.</source>
          <target state="translated">Определяет , будет ли расчет делается с нижней треугольной части &lt;code&gt;a&lt;/code&gt; ( &amp;laquo;L&amp;raquo;, по умолчанию) или верхней треугольной части ( &amp;laquo;U&amp;raquo;). Независимо от этого значения только действительные части диагонали будут учитываться при вычислении, чтобы сохранить понятие эрмитовой матрицы. Отсюда следует, что мнимая часть диагонали всегда будет считаться нулем.</target>
        </trans-unit>
        <trans-unit id="84b53fe298f53e60bfe5c134c03be76d2e5954a6" translate="yes" xml:space="preserve">
          <source>Specify &lt;code&gt;count&lt;/code&gt; to improve performance. It allows &lt;code&gt;fromiter&lt;/code&gt; to pre-allocate the output array, instead of resizing it on demand.</source>
          <target state="translated">Укажите &lt;code&gt;count&lt;/code&gt; для повышения производительности. Это позволяет &lt;code&gt;fromiter&lt;/code&gt; предварительно выделять выходной массив вместо изменения его размера по запросу.</target>
        </trans-unit>
        <trans-unit id="a2559f8e80c3826a37d110b99c7697f1e76b2b76" translate="yes" xml:space="preserve">
          <source>Specify the memory layout of the array. If object is not an array, the newly created array will be in C order (row major) unless &amp;lsquo;F&amp;rsquo; is specified, in which case it will be in Fortran order (column major). If object is an array the following holds.</source>
          <target state="translated">Укажите структуру памяти массива. Если объект не является массивом, вновь созданный массив будет в порядке C (основная строка), если не указано &amp;laquo;F&amp;raquo;, и в этом случае он будет в порядке Fortran (основной столбец). Если объект является массивом, выполняется следующее.</target>
        </trans-unit>
        <trans-unit id="c44bd2c1faa32dfad2b525474c59d5dbcd2e61f5" translate="yes" xml:space="preserve">
          <source>Specify the order of the array. If order is &amp;lsquo;C&amp;rsquo; (default), then the array will be in C-contiguous order (last-index varies the fastest). If order is &amp;lsquo;F&amp;rsquo;, then the returned array will be in Fortran-contiguous order (first-index varies the fastest).</source>
          <target state="translated">Укажите порядок в массиве. Если порядок - &amp;laquo;C&amp;raquo; (по умолчанию), тогда массив будет в непрерывном порядке C (последний индекс изменяется быстрее всего). Если порядок равен &amp;laquo;F&amp;raquo;, то возвращаемый массив будет в непрерывном порядке Фортрана (первый индекс изменяется быстрее всего).</target>
        </trans-unit>
        <trans-unit id="8f0736b76ded7485aa40ce78476b297a664e4a9e" translate="yes" xml:space="preserve">
          <source>Specify the order of the array. If order is &amp;lsquo;C&amp;rsquo; (default), then the array will be in C-contiguous order (last-index varies the fastest). If order is &amp;lsquo;F&amp;rsquo;, then the returned array will be in Fortran-contiguous order (first-index varies the fastest). If order is &amp;lsquo;A&amp;rsquo;, then the returned array may be in any order (either C-, Fortran-contiguous, or even discontiguous).</source>
          <target state="translated">Укажите порядок массива. Если порядок - &amp;laquo;C&amp;raquo; (по умолчанию), тогда массив будет в непрерывном порядке C (последний индекс изменяется быстрее всего). Если порядок равен &amp;laquo;F&amp;raquo;, то возвращаемый массив будет в непрерывном порядке Фортрана (первый индекс изменяется быстрее всего). Если order равен &amp;laquo;A&amp;raquo;, то возвращаемый массив может быть в любом порядке (либо C-, Fortran-непрерывный, либо даже несмежный).</target>
        </trans-unit>
        <trans-unit id="21cff05ed82b999db4c7f573fea17c64f4478c68" translate="yes" xml:space="preserve">
          <source>Specify the order of the array. If order is &amp;lsquo;C&amp;rsquo;, then the array will be in C-contiguous order (last-index varies the fastest). If order is &amp;lsquo;F&amp;rsquo;, then the returned array will be in Fortran-contiguous order (first-index varies the fastest). If order is &amp;lsquo;A&amp;rsquo; (default), then the returned array may be in any order (either C-, Fortran-contiguous, or even discontiguous), unless a copy is required, in which case it will be C-contiguous.</source>
          <target state="translated">Укажите порядок массива. Если порядок - &amp;laquo;C&amp;raquo;, тогда массив будет в непрерывном порядке C (последний индекс изменяется быстрее всего). Если порядок равен &amp;laquo;F&amp;raquo;, то возвращаемый массив будет в непрерывном порядке Фортрана (первый индекс изменяется быстрее всего). Если порядок равен &amp;laquo;A&amp;raquo; (по умолчанию), то возвращаемый массив может быть в любом порядке (либо C-, Fortran-смежный, либо даже несмежный), если только не требуется копия, и в этом случае он будет C-смежным.</target>
        </trans-unit>
        <trans-unit id="b4bff2e865a836b411173470fe4113bf016b57f0" translate="yes" xml:space="preserve">
          <source>Specify the order of the ndarray memory layout: &lt;a href=&quot;https://docs.scipy.org/doc/numpy-1.17.0/glossary.html#term-row-major&quot;&gt;row-major&lt;/a&gt;, C-style or &lt;a href=&quot;https://docs.scipy.org/doc/numpy-1.17.0/glossary.html#term-column-major&quot;&gt;column-major&lt;/a&gt;, Fortran-style. This only has an effect if the shape is greater than 1-D. The default order is &amp;lsquo;C&amp;rsquo;.</source>
          <target state="translated">Укажите порядок расположения памяти ndarray: &lt;a href=&quot;https://docs.scipy.org/doc/numpy-1.17.0/glossary.html#term-row-major&quot;&gt;основная строка&lt;/a&gt; , стиль C или &lt;a href=&quot;https://docs.scipy.org/doc/numpy-1.17.0/glossary.html#term-column-major&quot;&gt;основной столбец&lt;/a&gt; , стиль Fortran. Это имеет эффект, только если форма больше 1-D. Порядок по умолчанию - &amp;laquo;C&amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="83ad629c93587e0e12f83328a8f66ad92721efa4" translate="yes" xml:space="preserve">
          <source>Specifying and constructing data types</source>
          <target state="translated">Определение и построение типов данных</target>
        </trans-unit>
        <trans-unit id="00b91ffde426d9b0a3c3899a390a47a2d221ddad" translate="yes" xml:space="preserve">
          <source>Specifying config_fc options for libraries in setup.py script</source>
          <target state="translated">Указание опций config_fc для библиотек в скрипте setup.py</target>
        </trans-unit>
        <trans-unit id="497ce53e1d016b8475e5f51d0ed03829af1fe8b7" translate="yes" xml:space="preserve">
          <source>Specifying dtype and names</source>
          <target state="translated">Указание типа и имен</target>
        </trans-unit>
        <trans-unit id="99c8805177de6129ae475f67ee264572110d40f8" translate="yes" xml:space="preserve">
          <source>Specifying just the month, but forcing a &amp;lsquo;days&amp;rsquo; unit:</source>
          <target state="translated">Указание только месяца, но принудительное использование единицы &amp;laquo;дни&amp;raquo;:</target>
        </trans-unit>
        <trans-unit id="b3dbb36c7df88f2134e58d3a13401955888547e5" translate="yes" xml:space="preserve">
          <source>Specifying the roots of a polynomial still leaves one degree of freedom, typically represented by an undetermined leading coefficient. &lt;a href=&quot;#r6c2ffae921d1-1&quot; id=&quot;id1&quot;&gt;[1]&lt;/a&gt; In the case of this function, that coefficient - the first one in the returned array - is always taken as one. (If for some reason you have one other point, the only automatic way presently to leverage that information is to use &lt;code&gt;polyfit&lt;/code&gt;.)</source>
          <target state="translated">Указание корней многочлена по-прежнему оставляет одну степень свободы, обычно представленную неопределенным старшим коэффициентом. &lt;a href=&quot;#r6c2ffae921d1-1&quot; id=&quot;id1&quot;&gt;[1]&lt;/a&gt; В случае этой функции этот коэффициент - первый в возвращаемом массиве - всегда принимается равным единице. (Если по какой-то причине у вас есть еще один момент, единственный автоматический способ в настоящее время использовать эту информацию - использовать &lt;code&gt;polyfit&lt;/code&gt; .)</target>
        </trans-unit>
        <trans-unit id="0b1f4aea2b38e05ca6cff4352833d4c2eead6bd1" translate="yes" xml:space="preserve">
          <source>Speeding up copy operations by using uint assignment in instead of memcpy</source>
          <target state="translated">Ускорение операций копирования с помощью назначения uint вместо memcpy</target>
        </trans-unit>
        <trans-unit id="76bb3aba19733547ddb8d57ed987b6a041161ff6" translate="yes" xml:space="preserve">
          <source>Spherical covariance (&lt;code&gt;cov&lt;/code&gt; is a multiple of the identity matrix)</source>
          <target state="translated">Сферическая ковариация ( &lt;code&gt;cov&lt;/code&gt; кратно единичной матрице)</target>
        </trans-unit>
        <trans-unit id="088d71f3f52d7346fd614d711bd267b4c39c4007" translate="yes" xml:space="preserve">
          <source>Split an array into multiple sub-arrays horizontally (column-wise).</source>
          <target state="translated">Разделите массив на несколько подмассивов по горизонтали (по столбцам).</target>
        </trans-unit>
        <trans-unit id="b5754126c144e79af24aefbc17318a87cc5f7fd2" translate="yes" xml:space="preserve">
          <source>Split an array into multiple sub-arrays of equal or near-equal size.</source>
          <target state="translated">Разделите массив на несколько подмассивов одинакового или почти одинакового размера.</target>
        </trans-unit>
        <trans-unit id="0cf080dcab286083ff1cc66a435eccc8025f3bbc" translate="yes" xml:space="preserve">
          <source>Split an array into multiple sub-arrays of equal or near-equal size. Does not raise an exception if an equal division cannot be made.</source>
          <target state="translated">Разделите массив на несколько подмассивов одинакового или почти одинакового размера.Не вызывает исключений,если равное деление невозможно.</target>
        </trans-unit>
        <trans-unit id="c6395892c45b206d6b99821cc909fe1d65570f05" translate="yes" xml:space="preserve">
          <source>Split an array into multiple sub-arrays of equal size.</source>
          <target state="translated">Разделите массив на несколько подмассивов одинакового размера.</target>
        </trans-unit>
        <trans-unit id="505aae82481059a2edd349c99b982eb22991f3d7" translate="yes" xml:space="preserve">
          <source>Split an array into multiple sub-arrays vertically (row-wise).</source>
          <target state="translated">Разделите массив на несколько подмассивов по вертикали (строками).</target>
        </trans-unit>
        <trans-unit id="0976bf6e914482518c948616b2a64bfe1f530549" translate="yes" xml:space="preserve">
          <source>Split an array into multiple sub-arrays.</source>
          <target state="translated">Разделите массив на несколько подмассивов.</target>
        </trans-unit>
        <trans-unit id="ffd00244dfa808ccdb1e357f445723b1de446321" translate="yes" xml:space="preserve">
          <source>Split array along second axis.</source>
          <target state="translated">Разделить массив вдоль второй оси.</target>
        </trans-unit>
        <trans-unit id="19f8340eb834a92f93fbe1b260b02dab12c9b437" translate="yes" xml:space="preserve">
          <source>Split array along third axis.</source>
          <target state="translated">Разделить массив вдоль третьей оси.</target>
        </trans-unit>
        <trans-unit id="abb8acff6e092f71fe2d7d85b72048053b4e0289" translate="yes" xml:space="preserve">
          <source>Split array into a list of multiple sub-arrays of equal size.</source>
          <target state="translated">Разделите массив на несколько подмассивов одинакового размера.</target>
        </trans-unit>
        <trans-unit id="eeb46fbf791ef3d6b7513aae13670bfd1d286c5f" translate="yes" xml:space="preserve">
          <source>Split array into a list of multiple sub-arrays vertically.</source>
          <target state="translated">Разделите массив на список из нескольких подмассивов по вертикали.</target>
        </trans-unit>
        <trans-unit id="08031d3c1e963e5e593f6077f8007bde4094d65a" translate="yes" xml:space="preserve">
          <source>Split array into multiple sub-arrays along the 3rd axis (depth).</source>
          <target state="translated">Разделите массив на несколько подмассивов вдоль 3-й оси (глубина).</target>
        </trans-unit>
        <trans-unit id="95260188435af534996db3e9c839aec2ec1973f1" translate="yes" xml:space="preserve">
          <source>Split array into multiple sub-arrays horizontally (column wise)</source>
          <target state="translated">Разбиение массива на несколько подмассивов по горизонтали (с учетом столбца).</target>
        </trans-unit>
        <trans-unit id="4a58d1a7c17bf5b26ef79c3a68ad7dfd39dc14fd" translate="yes" xml:space="preserve">
          <source>Split array into multiple sub-arrays horizontally (column-wise).</source>
          <target state="translated">Разделите массив на несколько подмассивов по горизонтали (по столбцам).</target>
        </trans-unit>
        <trans-unit id="aaa399416b95737d5812be5e3aafc40e1bde329d" translate="yes" xml:space="preserve">
          <source>Split array into multiple sub-arrays of equal size.</source>
          <target state="translated">Разделите массив на несколько подмассивов одинакового размера.</target>
        </trans-unit>
        <trans-unit id="32200fb547976d9cdce1bf0123e79ad3d01d45c6" translate="yes" xml:space="preserve">
          <source>Split array into multiple sub-arrays vertically (row wise)</source>
          <target state="translated">Разделите массив на несколько подмассивов по вертикали (с учетом строк).</target>
        </trans-unit>
        <trans-unit id="5e2072ff967b60fe048397bbdc922e037ef75e9d" translate="yes" xml:space="preserve">
          <source>Split array into multiple sub-arrays vertically (row wise).</source>
          <target state="translated">Разделите массив на несколько подмассивов по вертикали (с учетом строк).</target>
        </trans-unit>
        <trans-unit id="d638a6c0e1614240bc1fdb2bb9a33a3845eee28f" translate="yes" xml:space="preserve">
          <source>Splitting arrays</source>
          <target state="translated">Разделительные массивы</target>
        </trans-unit>
        <trans-unit id="4d58ebaf799f88b14e5a55e0738d2ff6431f8e7d" translate="yes" xml:space="preserve">
          <source>Square identity matrix.</source>
          <target state="translated">Квадратная матрица идентификации.</target>
        </trans-unit>
        <trans-unit id="3613d80d3881f6e72e0182c8791baa68e9f04486" translate="yes" xml:space="preserve">
          <source>Square root (of data size) estimator, used by Excel and other programs for its speed and simplicity.</source>
          <target state="translated">Квадратный корень (размера данных)оценщик,используемый Excel и другими программами для его скорости и простоты.</target>
        </trans-unit>
        <trans-unit id="a20f5de17a778177c1d20a924357600fac4e355d" translate="yes" xml:space="preserve">
          <source>Stack 1-D arrays as columns into a 2-D array.</source>
          <target state="translated">Стек 1-D массивов в виде столбцов в 2-D массив.</target>
        </trans-unit>
        <trans-unit id="22aff824a88fb9e372dada7709040605bdecb795" translate="yes" xml:space="preserve">
          <source>Stack a sequence of arrays along a new axis.</source>
          <target state="translated">Сложите последовательность массивов вдоль новой оси.</target>
        </trans-unit>
        <trans-unit id="b708f3f441cf8b7881ef5ae7003def9a89be1321" translate="yes" xml:space="preserve">
          <source>Stack along first axis.</source>
          <target state="translated">Стойка вдоль первой оси.</target>
        </trans-unit>
        <trans-unit id="4e6821d485f2c248408d2340ce48afc4638994d9" translate="yes" xml:space="preserve">
          <source>Stack along second axis.</source>
          <target state="translated">Стойка вдоль второй оси.</target>
        </trans-unit>
        <trans-unit id="654d38ec444eb1ee8c9c4cb4064b5c34d10ed04b" translate="yes" xml:space="preserve">
          <source>Stack arrays in sequence along a new dimension.</source>
          <target state="translated">Складывайте массивы последовательно по новому измерению.</target>
        </trans-unit>
        <trans-unit id="8075374116f55fd4a715fc7ce7ce68e6a94d1c6b" translate="yes" xml:space="preserve">
          <source>Stack arrays in sequence depth wise (along third axis).</source>
          <target state="translated">Массивы стека в последовательности по глубине (вдоль третьей оси).</target>
        </trans-unit>
        <trans-unit id="49771b17dcab7c55c17889eac7ab065c2d3411f8" translate="yes" xml:space="preserve">
          <source>Stack arrays in sequence depth wise (along third dimension)</source>
          <target state="translated">Массивы стека в последовательности по глубине (по третьему измерению)</target>
        </trans-unit>
        <trans-unit id="d03609f09d0072b17b53d7c9e81abc547dbe26af" translate="yes" xml:space="preserve">
          <source>Stack arrays in sequence depth wise (along third dimension).</source>
          <target state="translated">Массивы стекаются последовательно по глубине (по третьему измерению).</target>
        </trans-unit>
        <trans-unit id="9d4bdc812ef44d6a84449088558f278a7a04fd89" translate="yes" xml:space="preserve">
          <source>Stack arrays in sequence horizontally (column wise)</source>
          <target state="translated">Массивы стекаются последовательно по горизонтали (по столбцам)</target>
        </trans-unit>
        <trans-unit id="ab9d3847a31919c576029d377c5a503add8ffa12" translate="yes" xml:space="preserve">
          <source>Stack arrays in sequence horizontally (column wise).</source>
          <target state="translated">Массивы стекаются последовательно по горизонтали (по столбцам).</target>
        </trans-unit>
        <trans-unit id="6895241ba9b7ce75e412efb0b37cc740ec4c6f5a" translate="yes" xml:space="preserve">
          <source>Stack arrays in sequence vertically (row wise)</source>
          <target state="translated">Массивы стекаются последовательно по вертикали (с учетом строк)</target>
        </trans-unit>
        <trans-unit id="d3ccf82c78c83570433d65f4d8ae10b7fd8977b2" translate="yes" xml:space="preserve">
          <source>Stack arrays in sequence vertically (row wise).</source>
          <target state="translated">Массивы стекаются последовательно по вертикали (с учетом строк).</target>
        </trans-unit>
        <trans-unit id="8085e023a3bd83539ee52ab6920d2f5d11c78066" translate="yes" xml:space="preserve">
          <source>Stacks of matrices are broadcast together as if the matrices were elements, respecting the signature &lt;code&gt;(n,k),(k,m)-&amp;gt;(n,m)&lt;/code&gt;:</source>
          <target state="translated">Стеки матриц транслируются вместе, как если бы матрицы были элементами, соблюдая сигнатуру &lt;code&gt;(n,k),(k,m)-&amp;gt;(n,m)&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="d04797e8ae7899c2001f6f6340094625d64a3d75" translate="yes" xml:space="preserve">
          <source>Stacks of object matrices are not currently supported.</source>
          <target state="translated">Стеки объектных матриц в настоящее время не поддерживаются.</target>
        </trans-unit>
        <trans-unit id="67bfee426b8f29b7c1b147b264c4ea92422abbce" translate="yes" xml:space="preserve">
          <source>Stadlober, Ernst, &amp;ldquo;The ratio of uniforms approach for generating discrete random variates&amp;rdquo;, Journal of Computational and Applied Mathematics, 31, pp. 181-189 (1990).</source>
          <target state="translated">Штадлобер, Эрнст, &amp;laquo;Подход с использованием отношения униформ для генерации дискретных случайных величин&amp;raquo;, Журнал вычислительной и прикладной математики, 31, стр. 181-189 (1990).</target>
        </trans-unit>
        <trans-unit id="6555192e9f6da8cd095b33f3c4f7b71a9783ffae" translate="yes" xml:space="preserve">
          <source>Standard Exponentials (&lt;a href=&quot;generated/numpy.random.generator.standard_exponential#numpy.random.Generator.standard_exponential&quot;&gt;&lt;code&gt;standard_exponential&lt;/code&gt;&lt;/a&gt;)</source>
          <target state="translated">Стандартные экспоненты ( &lt;a href=&quot;generated/numpy.random.generator.standard_exponential#numpy.random.Generator.standard_exponential&quot;&gt; &lt;code&gt;standard_exponential&lt;/code&gt; &lt;/a&gt; )</target>
        </trans-unit>
        <trans-unit id="a76b8a339223d559651cacde3723ee6065b8680a" translate="yes" xml:space="preserve">
          <source>Standard FFTs</source>
          <target state="translated">Стандартные БПФ</target>
        </trans-unit>
        <trans-unit id="8a50b57204e2e599132c00b62a1be1df8baa7ef4" translate="yes" xml:space="preserve">
          <source>Standard Gammas (&lt;a href=&quot;generated/numpy.random.generator.standard_gamma#numpy.random.Generator.standard_gamma&quot;&gt;&lt;code&gt;standard_gamma&lt;/code&gt;&lt;/a&gt;)</source>
          <target state="translated">Стандартная гамма ( &lt;a href=&quot;generated/numpy.random.generator.standard_gamma#numpy.random.Generator.standard_gamma&quot;&gt; &lt;code&gt;standard_gamma&lt;/code&gt; &lt;/a&gt; )</target>
        </trans-unit>
        <trans-unit id="6acbc6354e507f6042f5f9e2e8ed73fc0f0df274" translate="yes" xml:space="preserve">
          <source>Standard array subclasses</source>
          <target state="translated">Стандартные массивы подклассов</target>
        </trans-unit>
        <trans-unit id="cc94a4125e37461a7eb45a58071de9b78020fdd7" translate="yes" xml:space="preserve">
          <source>Standard container class</source>
          <target state="translated">Стандартный класс контейнера</target>
        </trans-unit>
        <trans-unit id="d97a83beb388d3e9a736d669dd24314ad1c4c05d" translate="yes" xml:space="preserve">
          <source>Standard container-class for easy multiple-inheritance.</source>
          <target state="translated">Стандартный контейнерный класс для легкого многократного наследования.</target>
        </trans-unit>
        <trans-unit id="fd746f492ad659d3f7460598edb734faace83b3c" translate="yes" xml:space="preserve">
          <source>Standard deviation</source>
          <target state="translated">среднеквадратическое отклонение</target>
        </trans-unit>
        <trans-unit id="abfc13a248e3a8f054556e98e30f2c835c7640af" translate="yes" xml:space="preserve">
          <source>Standard deviation (spread or &amp;ldquo;width&amp;rdquo;) of the distribution. Must be non-negative.</source>
          <target state="translated">Стандартное отклонение (разброс или &amp;laquo;ширина&amp;raquo;) распределения. Должен быть неотрицательным.</target>
        </trans-unit>
        <trans-unit id="353ecc8b9a821fe897c9828f33c52edee66e1903" translate="yes" xml:space="preserve">
          <source>Standard deviation of the underlying normal distribution. Must be non-negative. Default is 1.</source>
          <target state="translated">Стандартное отклонение основного нормального распределения.Должно быть неотрицательным.По умолчанию 1.</target>
        </trans-unit>
        <trans-unit id="23af397f01a5349c3364864801bdaded9c9fd69b" translate="yes" xml:space="preserve">
          <source>Standard division.</source>
          <target state="translated">Стандартное деление.</target>
        </trans-unit>
        <trans-unit id="41e65f8d183f4a9b208031a1e27c9fa561f1fc26" translate="yes" xml:space="preserve">
          <source>Standard iterator method, returns the index tuple and array value.</source>
          <target state="translated">Стандартный метод итератора,возвращает значение индекса кортежа и массива.</target>
        </trans-unit>
        <trans-unit id="5dc1c8c87cf79f5d6e41fc7b3d5b58a53840de0c" translate="yes" xml:space="preserve">
          <source>Standard iterator method, updates the index and returns the index tuple.</source>
          <target state="translated">Стандартный метод итератора,обновляет индекс и возвращает кортеж индекса.</target>
        </trans-unit>
        <trans-unit id="df808e9a53d2f9ad1713cebd06d023de29058b1f" translate="yes" xml:space="preserve">
          <source>Start of interval. The interval includes this value. The default start value is 0.</source>
          <target state="translated">Начало интервала.Интервал включает в себя это значение.Начальное значение по умолчанию равно 0.</target>
        </trans-unit>
        <trans-unit id="e3d56ccfa43387f906331b5afa2c49c8c391ba34" translate="yes" xml:space="preserve">
          <source>Start reading buffer (&lt;code&gt;buf&lt;/code&gt;) from this offset onwards.</source>
          <target state="translated">Начните чтение буфера ( &lt;code&gt;buf&lt;/code&gt; ) начиная с этого смещения.</target>
        </trans-unit>
        <trans-unit id="8a8f60afc4e5d9508e376d3a267b217a51489d68" translate="yes" xml:space="preserve">
          <source>Start reading the buffer from this offset (in bytes); default: 0.</source>
          <target state="translated">Начать чтение буфера с этого смещения (в байтах);по умолчанию:0.</target>
        </trans-unit>
        <trans-unit id="ddcac8bcdcee9d908ef620776b7aaacfebecb3f8" translate="yes" xml:space="preserve">
          <source>Start search at this level.</source>
          <target state="translated">Начните поиск на этом уровне.</target>
        </trans-unit>
        <trans-unit id="1b68451d2955d61b15e001c6fdcdc0d7038975d3" translate="yes" xml:space="preserve">
          <source>Starting from numpy 1.3.0, we are working on separating the pure C, &amp;ldquo;computational&amp;rdquo; code from the python dependent code. The goal is twofolds: making the code cleaner, and enabling code reuse by other extensions outside numpy (scipy, etc&amp;hellip;).</source>
          <target state="translated">Начиная с numpy 1.3.0, мы работаем над отделением &amp;laquo;вычислительного&amp;raquo; кода на чистом C от кода, зависящего от Python. Задача двоякая: сделать код чище и разрешить повторное использование кода другими расширениями за пределами numpy (scipy и т. Д.).</target>
        </trans-unit>
        <trans-unit id="190bfe8a8e41d4d3adc0d8967b2fb6cda62c785e" translate="yes" xml:space="preserve">
          <source>Starting guess for solving the rate of interest, default 0.1</source>
          <target state="translated">Начальная догадка для решения процентной ставки,по умолчанию 0.1</target>
        </trans-unit>
        <trans-unit id="1998183b3f42c5d604f45eee6e025b0b95e779c9" translate="yes" xml:space="preserve">
          <source>Starting in NumPy 1.7, there are core array data types which natively support datetime functionality. The data type is called &amp;ldquo;datetime64&amp;rdquo;, so named because &amp;ldquo;datetime&amp;rdquo; is already taken by the datetime library included in Python.</source>
          <target state="translated">Начиная с NumPy 1.7, существуют типы данных массива ядра, которые изначально поддерживают функциональность datetime. Тип данных называется &amp;laquo;datetime64&amp;raquo;, потому что &amp;laquo;datetime&amp;raquo; уже используется библиотекой datetime, включенной в Python.</target>
        </trans-unit>
        <trans-unit id="e4430717cba93d1575e5d9028fa5b9735d7a5640" translate="yes" xml:space="preserve">
          <source>Starting in NumPy 1.9 it returns a read-only view on the original array. Attempting to write to the resulting array will produce an error.</source>
          <target state="translated">Начиная с NumPy 1.9,он возвращает вид только для чтения на исходном массиве.Попытка записи в результирующий массив приведет к ошибке.</target>
        </trans-unit>
        <trans-unit id="03579e07c4a86e15aa2daa8e0ee5d8b2de28c77b" translate="yes" xml:space="preserve">
          <source>Starting in NumPy 1.9, promote_types function now returns a valid string length when given an integer or float dtype as one argument and a string dtype as another argument. Previously it always returned the input string dtype, even if it wasn&amp;rsquo;t long enough to store the max integer/float value converted to a string.</source>
          <target state="translated">Начиная с NumPy 1.9, функция Promo_types теперь возвращает допустимую длину строки, если ей задано целое число или тип dtype с плавающей запятой в качестве одного аргумента и строку dtype в качестве другого аргумента. Раньше он всегда возвращал входную строку dtype, даже если ее было недостаточно для хранения максимального целочисленного / плавающего значения, преобразованного в строку.</target>
        </trans-unit>
        <trans-unit id="48acaf98f98fb538de8401c0548aec9b9591fd70" translate="yes" xml:space="preserve">
          <source>Starting value for the sum. See &lt;a href=&quot;numpy.ufunc.reduce#numpy.ufunc.reduce&quot;&gt;&lt;code&gt;reduce&lt;/code&gt;&lt;/a&gt; for details.</source>
          <target state="translated">Начальное значение суммы. Подробнее см. &lt;a href=&quot;numpy.ufunc.reduce#numpy.ufunc.reduce&quot;&gt; &lt;code&gt;reduce&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="a72502067518684f9deeec70cf119fd26326cd33" translate="yes" xml:space="preserve">
          <source>State</source>
          <target state="translated">State</target>
        </trans-unit>
        <trans-unit id="2086b21f8f49274138c38d476bee317a84a8aecc" translate="yes" xml:space="preserve">
          <source>Statistics</source>
          <target state="translated">Statistics</target>
        </trans-unit>
        <trans-unit id="55fdc4e46b10f8815926e76cd96fd99504aad94e" translate="yes" xml:space="preserve">
          <source>Store compressed data to disk, and load it again:</source>
          <target state="translated">Сохраните сжатые данные на диск и загрузите их снова:</target>
        </trans-unit>
        <trans-unit id="c40b4ecf74fcdef0fac2e2b3e7ed1b00b25b3fa6" translate="yes" xml:space="preserve">
          <source>Store data to disk, and load it again:</source>
          <target state="translated">Храните данные на диске и загружайте их снова:</target>
        </trans-unit>
        <trans-unit id="e1c52dc3262f206eabc8e2236b28e7c92720ec86" translate="yes" xml:space="preserve">
          <source>Stores all of the necessary information to reconstruct the array including shape and dtype on a machine of a different architecture. Both little-endian and big-endian arrays are supported, and a file with little-endian numbers will yield a little-endian array on any machine reading the file. The types are described in terms of their actual sizes. For example, if a machine with a 64-bit C &amp;ldquo;long int&amp;rdquo; writes out an array with &amp;ldquo;long ints&amp;rdquo;, a reading machine with 32-bit C &amp;ldquo;long ints&amp;rdquo; will yield an array with 64-bit integers.</source>
          <target state="translated">Хранит всю необходимую информацию для восстановления массива, включая форму и dtype, на машине с другой архитектурой. Поддерживаются массивы как с прямым порядком, так и с прямым порядком байтов, а файл с прямым порядком байтов будет давать массив с прямым порядком байтов на любой машине, читающей файл. Типы описаны в соответствии с их действительными размерами. Например, если машина с 64-битным C &amp;laquo;long int&amp;raquo; записывает массив с &amp;laquo;длинными целыми числами&amp;raquo;, то читающая машина с 32-битным C &amp;laquo;long int&amp;raquo; выдаст массив с 64-битными целыми числами.</target>
        </trans-unit>
        <trans-unit id="4be1432cfaeaa9150a93183cf4c2899fcef7c724" translate="yes" xml:space="preserve">
          <source>Stores object arrays, i.e. arrays containing elements that are arbitrary Python objects. Files with object arrays are not to be mmapable, but can be read and written to disk.</source>
          <target state="translated">Хранит массивы объектов,т.е.массивы,содержащие элементы,которые являются произвольными объектами Python.Файлы с массивами объектов не должны быть отображены на карте,но могут быть прочитаны и записаны на диск.</target>
        </trans-unit>
        <trans-unit id="f27167d2cff299e4b6bdced9e8ba574539ece3ec" translate="yes" xml:space="preserve">
          <source>Strided Loop</source>
          <target state="translated">Петля с перечеркнутым контуром</target>
        </trans-unit>
        <trans-unit id="0229721b8100825a2747d58dc18cba748992b615" translate="yes" xml:space="preserve">
          <source>Strided copy code: Here, &amp;ldquo;uint alignment&amp;rdquo; is used instead. If the itemsize of an array is equal to 1, 2, 4, 8 or 16 bytes and the array is uint aligned then instead numpy will do &lt;code&gt;*(uintN*)dst) = *(uintN*)src)&lt;/code&gt; for appropriate N. Otherwise numpy copies by doing &lt;code&gt;memcpy(dst, src, N)&lt;/code&gt;.</source>
          <target state="translated">Код копии с полосами: здесь вместо этого используется &amp;laquo;выравнивание по uint&amp;raquo;. Если размер элемента массива равен 1, 2, 4, 8 или 16 байтам и массив выровнен по uint, тогда вместо этого numpy выполнит &lt;code&gt;*(uintN*)dst) = *(uintN*)src)&lt;/code&gt; для соответствующего N. В противном случае numpy копирует, выполнив &lt;code&gt;memcpy(dst, src, N)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="416989873d1bb367de9329586677a513ca98acbb" translate="yes" xml:space="preserve">
          <source>Strides for the array (see &lt;a href=&quot;numpy.ndarray.strides#numpy.ndarray.strides&quot;&gt;&lt;code&gt;ndarray.strides&lt;/code&gt;&lt;/a&gt; for full description). Default is None.</source>
          <target state="translated">Шаги для массива ( полное описание см. В &lt;a href=&quot;numpy.ndarray.strides#numpy.ndarray.strides&quot;&gt; &lt;code&gt;ndarray.strides&lt;/code&gt; &lt;/a&gt; ). По умолчанию нет.</target>
        </trans-unit>
        <trans-unit id="abe83ed756895533bb0aacd0ff6c133f19d2f819" translate="yes" xml:space="preserve">
          <source>Strides for the array (see &lt;code&gt;ndarray.strides&lt;/code&gt; for full description). Default is None.</source>
          <target state="translated">Шаги для массива ( полное описание см. В &lt;code&gt;ndarray.strides&lt;/code&gt; ). По умолчанию нет.</target>
        </trans-unit>
        <trans-unit id="715d0f58588cad2551c57b871fab2907378f7743" translate="yes" xml:space="preserve">
          <source>Strides of data in memory.</source>
          <target state="translated">Шаги данных в памяти.</target>
        </trans-unit>
        <trans-unit id="4afc193de85ea729f32e1a7419493e9d11ac22a1" translate="yes" xml:space="preserve">
          <source>String (fixed-length sequence of char)</source>
          <target state="translated">Строка (последовательность символов фиксированной длины)</target>
        </trans-unit>
        <trans-unit id="f12af9aa3dd629be8a9ae33b8570944039c84f2e" translate="yes" xml:space="preserve">
          <source>String Parsing</source>
          <target state="translated">Разбор струн</target>
        </trans-unit>
        <trans-unit id="34123bf351844b619c4dbfc6727ace35b50b4db7" translate="yes" xml:space="preserve">
          <source>String containing words to look for.</source>
          <target state="translated">Строка,содержащая слова,которые нужно искать.</target>
        </trans-unit>
        <trans-unit id="4df4e94946ef158e4c1e5b716aaee91f272b4a7e" translate="yes" xml:space="preserve">
          <source>String formatting</source>
          <target state="translated">Строковое форматирование</target>
        </trans-unit>
        <trans-unit id="92531b336e4e7bb6a1d7d30a01f8111947fec115" translate="yes" xml:space="preserve">
          <source>String information</source>
          <target state="translated">Информация о строке</target>
        </trans-unit>
        <trans-unit id="c2b35fa4d37ee8a6b4bd38cea3798cc9fbf4cba7" translate="yes" xml:space="preserve">
          <source>String integers specify the axis to concatenate along or the minimum number of dimensions to force entries into.</source>
          <target state="translated">Целые числа строк указывают ось,на которую следует наложить конкатенцию,или минимальное количество размеров для принудительных записей.</target>
        </trans-unit>
        <trans-unit id="f501c85c352da3ec100086db122d9f22d122b32e" translate="yes" xml:space="preserve">
          <source>String of length &lt;code&gt;length&lt;/code&gt;.</source>
          <target state="translated">Строка длины &lt;code&gt;length&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="766f45c1227c8c7d13e31b3c8218c7c441dc99b1" translate="yes" xml:space="preserve">
          <source>String operations</source>
          <target state="translated">Струнные операции</target>
        </trans-unit>
        <trans-unit id="b92216b3243250ff57b76e23d2f013b608ec0972" translate="yes" xml:space="preserve">
          <source>String or character separating columns.</source>
          <target state="translated">Столбцы,разделяющие строки или символы.</target>
        </trans-unit>
        <trans-unit id="791d1bdb2ea8c1e1e2ac650ffdc82b6e091407c9" translate="yes" xml:space="preserve">
          <source>String or character separating lines.</source>
          <target state="translated">Строки или строки,разделяющие символы.</target>
        </trans-unit>
        <trans-unit id="070445e0a7bd458bdad35ce8dcb2d1d0173ff69e" translate="yes" xml:space="preserve">
          <source>String representation of &lt;code&gt;number&lt;/code&gt; in &lt;code&gt;base&lt;/code&gt; system.</source>
          <target state="translated">Строковое представление &lt;code&gt;number&lt;/code&gt; в &lt;code&gt;base&lt;/code&gt; системе.</target>
        </trans-unit>
        <trans-unit id="2e31e8b091806f3d1f281cc4ba782be9fda82868" translate="yes" xml:space="preserve">
          <source>String representation of floating point infinity (default inf).</source>
          <target state="translated">Строковое представление бесконечности с плавающей точкой (inf по умолчанию).</target>
        </trans-unit>
        <trans-unit id="01373c57fb8fe982545c8617e4790c9bba32d3bd" translate="yes" xml:space="preserve">
          <source>String representation of floating point not-a-number (default nan).</source>
          <target state="translated">Строковое представление числа с плавающей точкой не-а (по умолчанию nan).</target>
        </trans-unit>
        <trans-unit id="9f3842d201b21eb0e7888c9c3d9a2c881516b8c4" translate="yes" xml:space="preserve">
          <source>String representation of the array.</source>
          <target state="translated">Строковое представление массива.</target>
        </trans-unit>
        <trans-unit id="4db97d521f52ac6d93080543eb6b74577ba23cc3" translate="yes" xml:space="preserve">
          <source>String representations:</source>
          <target state="translated">Строковые представления:</target>
        </trans-unit>
        <trans-unit id="e0d061a82ce8af858bef95987cfb2e899639d475" translate="yes" xml:space="preserve">
          <source>String that will be prepended to the &lt;code&gt;header&lt;/code&gt; and &lt;code&gt;footer&lt;/code&gt; strings, to mark them as comments. Default: &amp;lsquo;# &amp;lsquo;, as expected by e.g. &lt;code&gt;numpy.loadtxt&lt;/code&gt;.</source>
          <target state="translated">Строка, которая будет добавлена ​​к строкам &lt;code&gt;header&lt;/code&gt; и &lt;code&gt;footer&lt;/code&gt; , чтобы пометить их как комментарии. По умолчанию: '#', как ожидается, например, &lt;code&gt;numpy.loadtxt&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="29161ee7a7a15a1abaf0f1612beb0eae4baa01d7" translate="yes" xml:space="preserve">
          <source>String that will be written at the beginning of the file.</source>
          <target state="translated">Строка,которая будет записана в начале файла.</target>
        </trans-unit>
        <trans-unit id="5c5d64e1c727d0403596e9c5ea3308951b6f9d69" translate="yes" xml:space="preserve">
          <source>String that will be written at the end of the file.</source>
          <target state="translated">Строка,которая будет записана в конце файла.</target>
        </trans-unit>
        <trans-unit id="65875ffed7d9c75f6fe284ddd93f194bd7eecd53" translate="yes" xml:space="preserve">
          <source>String used in lieu of missing data when a masked array is printed. By default, this string is &lt;code&gt;'--'&lt;/code&gt;.</source>
          <target state="translated">Строка, используемая вместо отсутствующих данных при печати замаскированного массива. По умолчанию это строка &lt;code&gt;'--'&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e619565781aeac87df5988755d8308bf2c9d2598" translate="yes" xml:space="preserve">
          <source>String with comma-separated fields</source>
          <target state="translated">Строка с полями,разделенными запятыми</target>
        </trans-unit>
        <trans-unit id="70f2192ce102bd881643cbec0959f90e05d94515" translate="yes" xml:space="preserve">
          <source>Strings are also a scalar type:</source>
          <target state="translated">Строки также являются скалярным типом:</target>
        </trans-unit>
        <trans-unit id="abee4933ed6df48a826b4ec24a053bf896cc2409" translate="yes" xml:space="preserve">
          <source>Structured arrays are sorted lexically by &lt;code&gt;argsort&lt;/code&gt;:</source>
          <target state="translated">Структурированные массивы лексически сортируются по &lt;code&gt;argsort&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="f15140621e0cd4e0f0fe72960c228d9f03950ae6" translate="yes" xml:space="preserve">
          <source>Structured data types are formed by creating a data type whose &lt;a href=&quot;https://docs.scipy.org/doc/numpy-1.17.0/glossary.html#term-field&quot;&gt;field&lt;/a&gt; contain other data types. Each field has a name by which it can be &lt;a href=&quot;arrays.indexing#arrays-indexing-fields&quot;&gt;accessed&lt;/a&gt;. The parent data type should be of sufficient size to contain all its fields; the parent is nearly always based on the &lt;code&gt;void&lt;/code&gt; type which allows an arbitrary item size. Structured data types may also contain nested structured sub-array data types in their fields.</source>
          <target state="translated">Структурированные типы данных формируются путем создания типа данных, &lt;a href=&quot;https://docs.scipy.org/doc/numpy-1.17.0/glossary.html#term-field&quot;&gt;поле&lt;/a&gt; которого содержит другие типы данных. У каждого поля есть имя, по которому к нему можно получить &lt;a href=&quot;arrays.indexing#arrays-indexing-fields&quot;&gt;доступ&lt;/a&gt; . Родительский тип данных должен быть достаточного размера, чтобы содержать все его поля; родительский элемент почти всегда основан на типе &lt;code&gt;void&lt;/code&gt; , который допускает произвольный размер элемента. Структурированные типы данных могут также содержать в своих полях вложенные типы данных структурированного подмассива.</target>
        </trans-unit>
        <trans-unit id="6624b07c38a844e59271b0a0c26ed454ac19dbe9" translate="yes" xml:space="preserve">
          <source>Structured type, one field name &amp;lsquo;f1&amp;rsquo;, containing int16:</source>
          <target state="translated">Структурированный тип, одно имя поля 'f1', содержащее int16:</target>
        </trans-unit>
        <trans-unit id="d2e117ca328d87720528f1cfaf8d8960167ffb11" translate="yes" xml:space="preserve">
          <source>Structured type, one field named &amp;lsquo;f1&amp;rsquo;, in itself containing a structured type with one field:</source>
          <target state="translated">Структурированный тип, одно поле с именем 'f1', само по себе содержит структурированный тип с одним полем:</target>
        </trans-unit>
        <trans-unit id="58f4a5191b04c275b13b1266e03ae0e69f92c2c1" translate="yes" xml:space="preserve">
          <source>Structured type, two fields: the first field contains an unsigned int, the second an int32:</source>
          <target state="translated">Структурный тип,два поля:первое поле содержит беззнаковый int,второе-int32:</target>
        </trans-unit>
        <trans-unit id="ca4456203ca66897ff0941bbafc31276906d7671" translate="yes" xml:space="preserve">
          <source>Structured view(s) of &lt;a href=&quot;numpy.nditer.operands#numpy.nditer.operands&quot;&gt;&lt;code&gt;operands&lt;/code&gt;&lt;/a&gt; in memory, matching the reordered and optimized iterator access pattern. Valid only before the iterator is closed.</source>
          <target state="translated">Структурированные представления &lt;a href=&quot;numpy.nditer.operands#numpy.nditer.operands&quot;&gt; &lt;code&gt;operands&lt;/code&gt; &lt;/a&gt; в памяти, соответствующие переупорядоченному и оптимизированному шаблону доступа итератора. Действует только до закрытия итератора.</target>
        </trans-unit>
        <trans-unit id="803fd087e54001bfefdde2c389864825258535d4" translate="yes" xml:space="preserve">
          <source>Sub-arrays always have a C-contiguous memory layout.</source>
          <target state="translated">Подмассивы всегда имеют С-сопряженную схему памяти.</target>
        </trans-unit>
        <trans-unit id="b5f988ec613aba03f62b8fb5c8cfc27a7a1a6d0f" translate="yes" xml:space="preserve">
          <source>Sub-optimal &lt;a href=&quot;#numpy.einsum&quot;&gt;&lt;code&gt;einsum&lt;/code&gt;&lt;/a&gt; (due to repeated path calculation time): ~330ms</source>
          <target state="translated">Суб-оптимальное &lt;a href=&quot;#numpy.einsum&quot;&gt; &lt;code&gt;einsum&lt;/code&gt; &lt;/a&gt; (из - за неоднократное время расчета пути): ~ 330ms</target>
        </trans-unit>
        <trans-unit id="fa0a23c0a00071a5375730590cb136590b810c95" translate="yes" xml:space="preserve">
          <source>Subclasses of &lt;code&gt;ndarray&lt;/code&gt; are preserved except for the &amp;lsquo;raw&amp;rsquo; mode. So if &lt;code&gt;a&lt;/code&gt; is of type &lt;code&gt;matrix&lt;/code&gt;, all the return values will be matrices too.</source>
          <target state="translated">Подклассы &lt;code&gt;ndarray&lt;/code&gt; сохраняются, за исключением &amp;laquo;сырого&amp;raquo; режима. Таким образом, если &lt;code&gt;a&lt;/code&gt; имеет тип &lt;code&gt;matrix&lt;/code&gt; , все возвращаемые значения также будут матрицами.</target>
        </trans-unit>
        <trans-unit id="9d147ab8047bc6066411af552791a9504b59a189" translate="yes" xml:space="preserve">
          <source>Subclassing a &lt;code&gt;numpy.ndarray&lt;/code&gt; is possible but if your goal is to create an array with &lt;em&gt;modified&lt;/em&gt; behavior, as do dask arrays for distributed computation and cupy arrays for GPU-based computation, subclassing is discouraged. Instead, using numpy&amp;rsquo;s &lt;a href=&quot;https://docs.scipy.org/doc/numpy-1.17.0/user/basics.dispatch.html#basics-dispatch&quot;&gt;dispatch mechanism&lt;/a&gt; is recommended.</source>
          <target state="translated">&lt;code&gt;numpy.ndarray&lt;/code&gt; подкласса numpy.ndarray возможно, но если ваша цель - создать массив с &lt;em&gt;измененным&lt;/em&gt; поведением, как это делают массивы dask для распределенных вычислений и массивы Cupy для вычислений на базе GPU, создание подклассов не рекомендуется. Вместо этого рекомендуется использовать &lt;a href=&quot;https://docs.scipy.org/doc/numpy-1.17.0/user/basics.dispatch.html#basics-dispatch&quot;&gt;механизм отправки&lt;/a&gt; numpy .</target>
        </trans-unit>
        <trans-unit id="33bc88cf96b41fa0646c461894f505af99f67ac1" translate="yes" xml:space="preserve">
          <source>Subclassing is preserved. This means that if, e.g., the data part of the masked array is a recarray, &lt;a href=&quot;numpy.ma.filled#numpy.ma.filled&quot;&gt;&lt;code&gt;filled&lt;/code&gt;&lt;/a&gt; returns a recarray:</source>
          <target state="translated">Подклассы сохранены. Это означает , что если, например, часть данных из замаскированного массива является recarray, &lt;a href=&quot;numpy.ma.filled#numpy.ma.filled&quot;&gt; &lt;code&gt;filled&lt;/code&gt; &lt;/a&gt; возвращает recarray:</target>
        </trans-unit>
        <trans-unit id="dcd026d87f16ab5d865099378d38748e1049d4d8" translate="yes" xml:space="preserve">
          <source>Subclassing ndarray</source>
          <target state="translated">Подкласс ndarray</target>
        </trans-unit>
        <trans-unit id="d9952117e8cb53d0fd7ca6ba7d99ad537965d8c9" translate="yes" xml:space="preserve">
          <source>Subdivide &lt;code&gt;int16&lt;/code&gt; into 2 &lt;code&gt;int8&lt;/code&gt;&amp;rsquo;s, called x and y. 0 and 1 are the offsets in bytes:</source>
          <target state="translated">Разделить &lt;code&gt;int16&lt;/code&gt; в 2 &lt;code&gt;int8&lt;/code&gt; &amp;laquo;с, называемых х и у. 0 и 1 - смещения в байтах:</target>
        </trans-unit>
        <trans-unit id="7cd760711c541e202c788fb098af0b33b391721e" translate="yes" xml:space="preserve">
          <source>Subsequence with trailing zeros removed. If the resulting sequence would be empty, return the first element. The returned sequence may or may not be a view.</source>
          <target state="translated">Последующая с удалением следящих нулей.Если результирующая последовательность будет пустой,верните первый элемент.Возвращаемая последовательность может быть или не быть просмотром.</target>
        </trans-unit>
        <trans-unit id="259ff26648e77d2b9a5ec16a4f186ec8e1c65753" translate="yes" xml:space="preserve">
          <source>Substitute a polynomial for x and expand the result. Here we substitute p in itself leading to a new polynomial of degree 4 after expansion. If the polynomials are regarded as functions this is composition of functions:</source>
          <target state="translated">Замените полиномию на х и увеличьте результат.Здесь мы заменяем р сам по себе,что приводит к появлению нового полинома 4-й степени после расширения.Если полиномы рассматриваются как функции,то это и есть состав функций:</target>
        </trans-unit>
        <trans-unit id="8d18e7a773fc8ec030ec151dbf7cd596c836697a" translate="yes" xml:space="preserve">
          <source>Substitution:</source>
          <target state="translated">Substitution:</target>
        </trans-unit>
        <trans-unit id="976370d3324e5eaaec19ed99a261ec090486b0fa" translate="yes" xml:space="preserve">
          <source>Subtract arguments, element-wise.</source>
          <target state="translated">Вычитайте аргументы,по элементам.</target>
        </trans-unit>
        <trans-unit id="8567fbb4d729f4cd5b7fbe5674c01c465635fa47" translate="yes" xml:space="preserve">
          <source>Subtract one Chebyshev series from another.</source>
          <target state="translated">Вычитайте одну чебышевскую серию из другой.</target>
        </trans-unit>
        <trans-unit id="a494f472ea255a2aaa4f1c8f52b90c62196690f5" translate="yes" xml:space="preserve">
          <source>Subtract one Hermite series from another.</source>
          <target state="translated">Вычитайте одну серию &quot;Эрмита&quot; из другой.</target>
        </trans-unit>
        <trans-unit id="60b31c93b32c6d82ec367e99b58e2a7fd1690435" translate="yes" xml:space="preserve">
          <source>Subtract one Laguerre series from another.</source>
          <target state="translated">Вычитайте одну серию Лагер из другой.</target>
        </trans-unit>
        <trans-unit id="09477810015d786e3a1ce0d9827bfd9d00039de6" translate="yes" xml:space="preserve">
          <source>Subtract one Legendre series from another.</source>
          <target state="translated">Вычитайте одну серию &quot;Легенды&quot; из другой.</target>
        </trans-unit>
        <trans-unit id="a2407a57a6647eba13b915586134c7e1d7534217" translate="yes" xml:space="preserve">
          <source>Subtract one polynomial from another.</source>
          <target state="translated">Вычитайте один полиноминал из другого.</target>
        </trans-unit>
        <trans-unit id="5de67be97d964e12a293477e154e8fa146741938" translate="yes" xml:space="preserve">
          <source>Subtract other from self in-place.</source>
          <target state="translated">Вычитайте другие из себя на месте.</target>
        </trans-unit>
        <trans-unit id="b3957443ea74659d4523c7bc9e466d304ba155cf" translate="yes" xml:space="preserve">
          <source>Subtract other from self, and return a new masked array.</source>
          <target state="translated">Извлеките другое из себя и верните новый замаскированный массив.</target>
        </trans-unit>
        <trans-unit id="6cf676697a4c117ec3074a618da8a2b0fca9cd14" translate="yes" xml:space="preserve">
          <source>Subtract self from other, and return a new masked array.</source>
          <target state="translated">Вычитайте себя из других и верните новый массив.</target>
        </trans-unit>
        <trans-unit id="d0b818b7784e48b243d98be89f763b62cb9fc7bd" translate="yes" xml:space="preserve">
          <source>Successfully tested on:</source>
          <target state="translated">Успешно протестирована:</target>
        </trans-unit>
        <trans-unit id="7f477dc5121884706ef8fed21e4d11c24e6db091" translate="yes" xml:space="preserve">
          <source>Sum across array propagating NaNs.</source>
          <target state="translated">Сумма по массиву,распространяющему NaN.</target>
        </trans-unit>
        <trans-unit id="b2cc82eaee79a7562889de3502bb827b013693aa" translate="yes" xml:space="preserve">
          <source>Sum along diagonals.</source>
          <target state="translated">Суммируй по диагоналям.</target>
        </trans-unit>
        <trans-unit id="b221abad8e52361732192c7acb9613f67b076ac3" translate="yes" xml:space="preserve">
          <source>Sum array elements.</source>
          <target state="translated">Суммируйте элементы массива.</target>
        </trans-unit>
        <trans-unit id="96c00e26cd369dd11b081a1035d4633225e7965d" translate="yes" xml:space="preserve">
          <source>Sum of array elements over a given axis.</source>
          <target state="translated">Сумма элементов массива по заданной оси.</target>
        </trans-unit>
        <trans-unit id="6302a8aa98d30db8a3e7186cb73eb9e4337d618b" translate="yes" xml:space="preserve">
          <source>Sum over an axis (requires explicit form):</source>
          <target state="translated">Сумма по оси (требует явной формы):</target>
        </trans-unit>
        <trans-unit id="1c979daf2b6e4cef98bd537ad236de258dbc0d5a" translate="yes" xml:space="preserve">
          <source>Sum over axes 0 and 2. The result has same number of dimensions as the original array:</source>
          <target state="translated">Сумма по осям 0 и 2.Результат имеет такое же количество размеров,что и исходный массив:</target>
        </trans-unit>
        <trans-unit id="1103f1f7acbd2c5b9349bcbddbb45121fae537eb" translate="yes" xml:space="preserve">
          <source>Sum products over arbitrary axes.</source>
          <target state="translated">Сумма продуктов по произвольным осям.</target>
        </trans-unit>
        <trans-unit id="12b71c3e0fe5f7c0b8d17cc03186e281412da4a8" translate="yes" xml:space="preserve">
          <source>Summary</source>
          <target state="translated">Summary</target>
        </trans-unit>
        <trans-unit id="bf661fd6213ae079ce34c2c9dd00db526c359e2b" translate="yes" xml:space="preserve">
          <source>Sums of residuals; squared Euclidean 2-norm for each column in &lt;code&gt;b - a*x&lt;/code&gt;. If the rank of &lt;code&gt;a&lt;/code&gt; is &amp;lt; N or M &amp;lt;= N, this is an empty array. If &lt;code&gt;b&lt;/code&gt; is 1-dimensional, this is a (1,) shape array. Otherwise the shape is (K,).</source>
          <target state="translated">Суммы остатков; квадрат евклидовой 2-нормы для каждого столбца в &lt;code&gt;b - a*x&lt;/code&gt; . Если ранг &lt;code&gt;a&lt;/code&gt; &amp;lt;N или M &amp;lt;= N, это пустой массив. Если &lt;code&gt;b&lt;/code&gt; одномерный, это массив формы (1,). В противном случае форма будет (K,).</target>
        </trans-unit>
        <trans-unit id="b6c71b95244ccde5ac8df906b9633b9278b04563" translate="yes" xml:space="preserve">
          <source>Sums, products, differences</source>
          <target state="translated">Суммы,продукты,различия</target>
        </trans-unit>
        <trans-unit id="56cedb0b6384ebe895f048d3113a97e19adce9ed" translate="yes" xml:space="preserve">
          <source>SunOS 5.9, Python 2.2, 2.3.2</source>
          <target state="translated">SunOS 5.9,Питон 2.2,2.3.2</target>
        </trans-unit>
        <trans-unit id="5732c875d678ed7bc376f8bdb01c865cd0e57b5f" translate="yes" xml:space="preserve">
          <source>Support for multiple insertions when &lt;code&gt;obj&lt;/code&gt; is a single scalar or a sequence with one element (similar to calling insert multiple times).</source>
          <target state="translated">Поддержка множественных вставок, когда &lt;code&gt;obj&lt;/code&gt; - это один скаляр или последовательность с одним элементом (аналогично вызову вставки несколько раз).</target>
        </trans-unit>
        <trans-unit id="6d95257e0d6b5ee52701ed6e60955d7b5cf2355f" translate="yes" xml:space="preserve">
          <source>Supported BitGenerators</source>
          <target state="translated">Поддерживаемые битгенераторы</target>
        </trans-unit>
        <trans-unit id="090678b79c24d0799aa7434df5ba4e013c0ea2ff" translate="yes" xml:space="preserve">
          <source>Supports Fortran-contiguous arrays directly.</source>
          <target state="translated">Поддерживает непосредственно сопрягаемые массивы Fortran.</target>
        </trans-unit>
        <trans-unit id="62c4a407a3644c899b58964ef70d8d5ea099dfdd" translate="yes" xml:space="preserve">
          <source>Supports full broadcasting of the inputs.</source>
          <target state="translated">Поддерживает полную трансляцию входов.</target>
        </trans-unit>
        <trans-unit id="12f46de9102cae348756a951378fba972f726b07" translate="yes" xml:space="preserve">
          <source>Supports rolling over multiple dimensions simultaneously.</source>
          <target state="translated">Поддерживает прокат по нескольким размерам одновременно.</target>
        </trans-unit>
        <trans-unit id="d97b0cce7cf0a1a8ea78834b26b7eaa1e93207d9" translate="yes" xml:space="preserve">
          <source>Supports the method &lt;a href=&quot;generated/numpy.random.pcg64.pcg64.advance#numpy.random.pcg64.PCG64.advance&quot;&gt;&lt;code&gt;advance&lt;/code&gt;&lt;/a&gt; to advance the RNG an arbitrary number of steps. The state of the PCG-64 RNG is represented by 2 128-bit unsigned integers.</source>
          <target state="translated">Поддерживает &lt;a href=&quot;generated/numpy.random.pcg64.pcg64.advance#numpy.random.pcg64.PCG64.advance&quot;&gt; &lt;code&gt;advance&lt;/code&gt; &lt;/a&gt; метода для продвижения ГСЧ на произвольное количество шагов. Состояние ГСЧ PCG-64 представлено 2 128-битными целыми числами без знака.</target>
        </trans-unit>
        <trans-unit id="34c5f00d14223115d609ab63804b8bf6dbd38059" translate="yes" xml:space="preserve">
          <source>Suppose &lt;code&gt;x.shape&lt;/code&gt; is (10,20,30) and &lt;code&gt;ind&lt;/code&gt; is a (2,3,4)-shaped indexing &lt;code&gt;intp&lt;/code&gt; array, then &lt;code&gt;result = x[...,ind,:]&lt;/code&gt; has shape (10,2,3,4,30) because the (20,)-shaped subspace has been replaced with a (2,3,4)-shaped broadcasted indexing subspace. If we let &lt;em&gt;i, j, k&lt;/em&gt; loop over the (2,3,4)-shaped subspace then &lt;code&gt;result[...,i,j,k,:] = x[...,ind[i,j,k],:]&lt;/code&gt;. This example produces the same result as &lt;a href=&quot;generated/numpy.ndarray.take#numpy.ndarray.take&quot;&gt;&lt;code&gt;x.take(ind, axis=-2)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Предположим, что &lt;code&gt;x.shape&lt;/code&gt; - это (10,20,30), а &lt;code&gt;ind&lt;/code&gt; - это (2,3,4) -образный индексирующий массив &lt;code&gt;intp&lt;/code&gt; , тогда &lt;code&gt;result = x[...,ind,:]&lt;/code&gt; имеет форму (10,2,3 , 4,30), потому что подпространство в форме (20,) было заменено подпространством широковещательной индексации в форме (2,3,4). Если мы позволим &lt;em&gt;i, j, k&lt;/em&gt; перебирать подпространство (2,3,4) -образной формы, то &lt;code&gt;result[...,i,j,k,:] = x[...,ind[i,j,k],:]&lt;/code&gt; . Этот пример дает тот же результат, что и &lt;a href=&quot;generated/numpy.ndarray.take#numpy.ndarray.take&quot;&gt; &lt;code&gt;x.take(ind, axis=-2)&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="ab6e03b971eeb9906907892d695f98f70c00c465" translate="yes" xml:space="preserve">
          <source>Suppose I have two files coolmodule.c and coolhelper.c which need to be compiled and linked into a single extension module. Suppose coolmodule.c contains the required initcool module initialization function (with the import_array() function called). Then, coolmodule.c would have at the top:</source>
          <target state="translated">Предположим,у меня есть два файла coolmodule.c и coolhelper.c,которые нужно скомпилировать и связать в один модуль расширения.Предположим,что в coolmodule.c содержится необходимая функция инициализации модуля initcool (с вызовом функции import_array()).Затем,coolmodule.c будет иметь в верхней части:</target>
        </trans-unit>
        <trans-unit id="1a06be2cc716b778d6a1c32b124922e42d2cce52" translate="yes" xml:space="preserve">
          <source>Suppose now that we wish to print that same data, but with the missing values replaced by the average value.</source>
          <target state="translated">Предположим,теперь мы хотим распечатать те же самые данные,но с пропущенными значениями,замененными на среднее значение.</target>
        </trans-unit>
        <trans-unit id="5dca6dc181cc53601add013bc2ada72709458943" translate="yes" xml:space="preserve">
          <source>Suppose the first operand is one dimensional and the second operand is two dimensional. The iterator will have three dimensions, so &lt;code&gt;op_axes&lt;/code&gt; will have two 3-element lists. The first list picks out the one axis of the first operand, and is -1 for the rest of the iterator axes, with a final result of [0, -1, -1]. The second list picks out the two axes of the second operand, but shouldn&amp;rsquo;t overlap with the axes picked out in the first operand. Its list is [-1, 0, 1]. The output operand maps onto the iterator axes in the standard manner, so we can provide None instead of constructing another list.</source>
          <target state="translated">Предположим, что первый операнд одномерный, а второй - двумерный. Итератор будет иметь три измерения, поэтому &lt;code&gt;op_axes&lt;/code&gt; будет иметь два списка из трех элементов. Первый список выбирает одну ось первого операнда и равен -1 для остальных осей итератора, с окончательным результатом [0, -1, -1]. Второй список выбирает две оси второго операнда, но не должен перекрываться с осями, выбранными в первом операнде. Его список [-1, 0, 1]. Выходной операнд отображается на оси итератора стандартным образом, поэтому мы можем предоставить None вместо создания другого списка.</target>
        </trans-unit>
        <trans-unit id="ffbff519fe81519b5859278de1db83d3776384bb" translate="yes" xml:space="preserve">
          <source>Suppose you have a SciPy module &lt;code&gt;scipy/xxx/yyy.py&lt;/code&gt; containing a function &lt;code&gt;zzz()&lt;/code&gt;. To test this function you would create a test module called &lt;code&gt;test_yyy.py&lt;/code&gt;. If you only need to test one aspect of &lt;code&gt;zzz&lt;/code&gt;, you can simply add a test function:</source>
          <target state="translated">Предположим, у вас есть модуль SciPy &lt;code&gt;scipy/xxx/yyy.py&lt;/code&gt; , содержащий функцию &lt;code&gt;zzz()&lt;/code&gt; . Чтобы протестировать эту функцию, вы должны создать тестовый модуль с именем &lt;code&gt;test_yyy.py&lt;/code&gt; . Если вам нужно протестировать только один аспект &lt;code&gt;zzz&lt;/code&gt; , вы можете просто добавить тестовую функцию:</target>
        </trans-unit>
        <trans-unit id="561e62ec5d03ac50c21e0a257548d3eb990ac028" translate="yes" xml:space="preserve">
          <source>Suppose you have an urn with 15 white and 15 black marbles. If you pull 15 marbles at random, how likely is it that 12 or more of them are one color?</source>
          <target state="translated">Предположим,у вас есть урна с 15 белыми и 15 черными шариками.Если Вы вытягиваете 15 шариков случайным образом,насколько вероятно,что 12 или более из них одного цвета?</target>
        </trans-unit>
        <trans-unit id="7c7cd36a0c21d430e2827a371600cad0b35b80b7" translate="yes" xml:space="preserve">
          <source>Suppress the rows and/or columns of a 2-D array that contain masked values.</source>
          <target state="translated">Подавление строк и/или столбцов 2-D массива,содержащих маскированные значения.</target>
        </trans-unit>
        <trans-unit id="00f54cf02ad98c4bd3014ede43830053636d4545" translate="yes" xml:space="preserve">
          <source>Suppress whole columns of a 2-D array that contain masked values.</source>
          <target state="translated">Подавление целых столбцов двухмерного массива,содержащего маскированные значения.</target>
        </trans-unit>
        <trans-unit id="685b0c43425911b6f904fe6d170e96c0345d4cbf" translate="yes" xml:space="preserve">
          <source>Suppress whole rows of a 2-D array that contain masked values.</source>
          <target state="translated">Подавление целых строк 2-D массива,содержащего маскированные значения.</target>
        </trans-unit>
        <trans-unit id="b11d9a95741366c39b17b9d4fd94445d808b15b4" translate="yes" xml:space="preserve">
          <source>Swap the bytes of the array elements</source>
          <target state="translated">Замена байт элементов массива</target>
        </trans-unit>
        <trans-unit id="bbdcf90ffec6f9d47a9ac51cf19b00a93a140fa9" translate="yes" xml:space="preserve">
          <source>Switch determining nature of return value. When it is False (the default) just the coefficients are returned, when True diagnostic information from the singular value decomposition is also returned.</source>
          <target state="translated">Переключатель определения характера возвращаемого значения.При False (по умолчанию)возвращаются только коэффициенты,когда также возвращается True диагностическая информация из сингулярного разложения значений.</target>
        </trans-unit>
        <trans-unit id="6b3384dea957229bd45073ab4c8cae823f791969" translate="yes" xml:space="preserve">
          <source>Switch determining the nature of the return value. When &lt;code&gt;False&lt;/code&gt; (the default) just the coefficients are returned; when &lt;code&gt;True&lt;/code&gt;, diagnostic information from the singular value decomposition (used to solve the fit&amp;rsquo;s matrix equation) is also returned.</source>
          <target state="translated">Переключатель, определяющий характер возвращаемого значения. Если &lt;code&gt;False&lt;/code&gt; (по умолчанию), возвращаются только коэффициенты; когда &lt;code&gt;True&lt;/code&gt; , также возвращается диагностическая информация из разложения по сингулярным значениям (используемого для решения матричного уравнения подгонки).</target>
        </trans-unit>
        <trans-unit id="7af38070c59fd5383f5319f90871324cb011240a" translate="yes" xml:space="preserve">
          <source>System Entropy</source>
          <target state="translated">система энтропии</target>
        </trans-unit>
        <trans-unit id="1b1430441b7b7dd5a90d83f42f914deacc5fd0e5" translate="yes" xml:space="preserve">
          <source>System configuration</source>
          <target state="translated">Системная конфигурация</target>
        </trans-unit>
        <trans-unit id="8e0d354392fe3fc9d2a5d83e7fd5a6f24a2b815a" translate="yes" xml:space="preserve">
          <source>TODO: Maybe it would be better to introduce a function &lt;code&gt;NpyIter_GetWrappedOutput&lt;/code&gt; and remove this flag?</source>
          <target state="translated">TODO: Может, лучше было бы ввести функцию &lt;code&gt;NpyIter_GetWrappedOutput&lt;/code&gt; и убрать этот флаг?</target>
        </trans-unit>
        <trans-unit id="c398f641b79127cbb5368a052c9c18ee4b191edd" translate="yes" xml:space="preserve">
          <source>TODO: This feature can be easily extended for Fortran 90 codes as well. Let us know if you would need such a feature.</source>
          <target state="translated">TODO:Эта функция может быть легко расширена и для кодов Fortran 90.Сообщите нам,если вам понадобится такая функция.</target>
        </trans-unit>
        <trans-unit id="d2bf59208074c19e062d597b69c91e24c1b3f65d" translate="yes" xml:space="preserve">
          <source>Take a sequence of 1-D arrays and stack them as columns to make a single 2-D array. 2-D arrays are stacked as-is, just like with &lt;a href=&quot;numpy.hstack#numpy.hstack&quot;&gt;&lt;code&gt;hstack&lt;/code&gt;&lt;/a&gt;. 1-D arrays are turned into 2-D columns first.</source>
          <target state="translated">Возьмите последовательность одномерных массивов и сложите их как столбцы, чтобы получился один двумерный массив. &lt;a href=&quot;numpy.hstack#numpy.hstack&quot;&gt; &lt;code&gt;hstack&lt;/code&gt; &lt;/a&gt; массивы складываются как есть, как и в случае с hstack . Сначала одномерные массивы преобразуются в двухмерные столбцы.</target>
        </trans-unit>
        <trans-unit id="a7063ff9c282b69776d4b6c1965ce5cc8d3d21f1" translate="yes" xml:space="preserve">
          <source>Take a sequence of 1-D arrays and stack them as columns to make a single 2-D array. 2-D arrays are stacked as-is, just like with &lt;a href=&quot;numpy.ma.hstack#numpy.ma.hstack&quot;&gt;&lt;code&gt;hstack&lt;/code&gt;&lt;/a&gt;. 1-D arrays are turned into 2-D columns first.</source>
          <target state="translated">Возьмите последовательность одномерных массивов и сложите их как столбцы, чтобы получился один двумерный массив. &lt;a href=&quot;numpy.ma.hstack#numpy.ma.hstack&quot;&gt; &lt;code&gt;hstack&lt;/code&gt; &lt;/a&gt; массивы складываются как есть, как и в случае с hstack . Сначала одномерные массивы преобразуются в двухмерные столбцы.</target>
        </trans-unit>
        <trans-unit id="948650b27c1b2b9784a79436cafe48d7d653c938" translate="yes" xml:space="preserve">
          <source>Take along an axis, using the same indices for every 1d slice</source>
          <target state="translated">Возьмите по оси,используя одни и те же индексы для каждого 1д среза.</target>
        </trans-unit>
        <trans-unit id="750d821c9fa304621f4be0f3b88564bf9278e152" translate="yes" xml:space="preserve">
          <source>Take elements by matching the array and the index arrays</source>
          <target state="translated">Взять элементы путем сопоставления массива и индексных массивов</target>
        </trans-unit>
        <trans-unit id="e11fd16230a195030272e04871b014d038eef9ab" translate="yes" xml:space="preserve">
          <source>Take elements from an array along an axis.</source>
          <target state="translated">Возьмите элементы из массива по оси.</target>
        </trans-unit>
        <trans-unit id="2bd0abec8d18fb4f628e5467a962eaf329bb6905" translate="yes" xml:space="preserve">
          <source>Take elements using a boolean mask</source>
          <target state="translated">Возьмите элементы с помощью булевой маски</target>
        </trans-unit>
        <trans-unit id="b8cd92f0049ea13b3db726f84fc3411287caeddf" translate="yes" xml:space="preserve">
          <source>Take the fields dictionary, &lt;em&gt;dict&lt;/em&gt;, such as the one attached to a data-type object and construct an ordered-list of field names such as is stored in the names field of the &lt;a href=&quot;c-api.types-and-structures#c.PyArray_Descr&quot;&gt;&lt;code&gt;PyArray_Descr&lt;/code&gt;&lt;/a&gt; object.</source>
          <target state="translated">Возьмите словарь полей, &lt;em&gt;dict&lt;/em&gt; , такой как тот, который прикреплен к объекту типа данных, и &lt;a href=&quot;c-api.types-and-structures#c.PyArray_Descr&quot;&gt; &lt;code&gt;PyArray_Descr&lt;/code&gt; &lt;/a&gt; упорядоченный список имен полей, который хранится в поле имен объекта PyArray_Descr .</target>
        </trans-unit>
        <trans-unit id="673397230d0da22f7147b4eeece871fd1294c5ff" translate="yes" xml:space="preserve">
          <source>Take values from the input array by matching 1d index and data slices</source>
          <target state="translated">Взять значения из входного массива путем сопоставления 1d индекса и срезов данных</target>
        </trans-unit>
        <trans-unit id="7f4b8f1ca46302f3d1aba5fbdc3749dad60f0480" translate="yes" xml:space="preserve">
          <source>Take values from the input array by matching 1d index and data slices.</source>
          <target state="translated">Взять значения из входного массива путем сопоставления 1d индекса и срезов данных.</target>
        </trans-unit>
        <trans-unit id="567aaaa85050a78f736c937e4e349477825e7c6c" translate="yes" xml:space="preserve">
          <source>Takes an arbitrary Python function and returns a NumPy ufunc.</source>
          <target state="translated">Принимает произвольную Python-функцию и возвращает NumPy ufunc.</target>
        </trans-unit>
        <trans-unit id="ad884a5ab2796ce61beab25497caa48a0c350a18" translate="yes" xml:space="preserve">
          <source>Takes an arbitrary Python function and returns a ufunc</source>
          <target state="translated">Принимает произвольную функцию питона и возвращает ufunc.</target>
        </trans-unit>
        <trans-unit id="4fe8421f7b4bac2910c2919a03e01d32f910e006" translate="yes" xml:space="preserve">
          <source>Taking an example cited in Wikipedia, this distribution can be used if one wanted to cut strings (each of initial length 1.0) into K pieces with different lengths, where each piece had, on average, a designated average length, but allowing some variation in the relative sizes of the pieces.</source>
          <target state="translated">Возьмем пример,приведенный в Википедии,это распределение может быть использовано,если нужно вырезать строки (каждая из начальной длины 1.0)на K штук разной длины,где каждая штука имеет,в среднем,обозначенную среднюю длину,но допускает некоторые вариации в относительных размерах штук.</target>
        </trans-unit>
        <trans-unit id="af1237aaefe517f485a7a53e6bb8a3bb8a86a6a4" translate="yes" xml:space="preserve">
          <source>Target array.</source>
          <target state="translated">Массив целей.</target>
        </trans-unit>
        <trans-unit id="51038a1a794fec6114fafbb47a8bce902f23294f" translate="yes" xml:space="preserve">
          <source>Target indices, interpreted as integers.</source>
          <target state="translated">Целевые индексы,интерпретируемые как целые числа.</target>
        </trans-unit>
        <trans-unit id="695f8bb0287f4fc300e17fa93e5262f0b53e9bb1" translate="yes" xml:space="preserve">
          <source>Temporary directories are deleted when the DataSource is deleted.</source>
          <target state="translated">Временные каталоги удаляются при удалении DataSource.</target>
        </trans-unit>
        <trans-unit id="6701dda5ea2a62c52d8395d7a5c8f390a0ab64df" translate="yes" xml:space="preserve">
          <source>Tensor contraction:</source>
          <target state="translated">Сокращение тензора:</target>
        </trans-unit>
        <trans-unit id="7e786b6ecaa33c3bfa2a663250579b348bbb6678" translate="yes" xml:space="preserve">
          <source>Tensor contractions, &lt;a href=&quot;numpy.tensordot#numpy.tensordot&quot;&gt;&lt;code&gt;numpy.tensordot&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Тензорные сокращения, &lt;a href=&quot;numpy.tensordot#numpy.tensordot&quot;&gt; &lt;code&gt;numpy.tensordot&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="8aa53899fcc2f4722e3aaa13b02a9f0c21a58b0c" translate="yes" xml:space="preserve">
          <source>Tensor to &amp;lsquo;invert&amp;rsquo;. Its shape must be &amp;lsquo;square&amp;rsquo;, i. e., &lt;code&gt;prod(a.shape[:ind]) == prod(a.shape[ind:])&lt;/code&gt;.</source>
          <target state="translated">Тензор для инвертирования. Его форма должна быть &amp;laquo;квадратной&amp;raquo;, то есть &lt;code&gt;prod(a.shape[:ind]) == prod(a.shape[ind:])&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5a7912060e7ae8d981d410c16692b658bc5a8653" translate="yes" xml:space="preserve">
          <source>Tensors to &amp;ldquo;dot&amp;rdquo;.</source>
          <target state="translated">Тензоры в &amp;laquo;точку&amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="71218d40834bc4913fe2fbb95e52de19a584b43a" translate="yes" xml:space="preserve">
          <source>Test Running</source>
          <target state="translated">Прогон тестов</target>
        </trans-unit>
        <trans-unit id="2ec99dbb44d0090912e3c4ddf71222f3cee61914" translate="yes" xml:space="preserve">
          <source>Test Support (&lt;code&gt;numpy.testing&lt;/code&gt;)</source>
          <target state="translated">Поддержка тестирования ( &lt;code&gt;numpy.testing&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="c35554b04739c6c6869f7c83d9841e0dda4c5073" translate="yes" xml:space="preserve">
          <source>Test Support (numpy.testing)</source>
          <target state="translated">Поддержка тестирования (numpy.testing)</target>
        </trans-unit>
        <trans-unit id="59afddee1692b59da457c30d92a5b65f5e31115a" translate="yes" xml:space="preserve">
          <source>Test element-wise for NaN and return result as a boolean array.</source>
          <target state="translated">Тестируйте по элементам для NaN и возвращайте результат в виде булевого массива.</target>
        </trans-unit>
        <trans-unit id="ed391a308f11ca7f40c17a765e9b20cc4e1035a2" translate="yes" xml:space="preserve">
          <source>Test element-wise for NaT (not a time) and return result as a boolean array.</source>
          <target state="translated">Тестируйте по элементам для NaT (не по времени)и возвращайте результат в виде булевого массива.</target>
        </trans-unit>
        <trans-unit id="9f34997c659f4457d18a667e13e9b54ff7ea7b5d" translate="yes" xml:space="preserve">
          <source>Test element-wise for finiteness (not infinity or not Not a Number).</source>
          <target state="translated">Тест на конечность (не бесконечность или не число).</target>
        </trans-unit>
        <trans-unit id="b73482f0dd7c13ea3e95362c875b37244def5b6c" translate="yes" xml:space="preserve">
          <source>Test element-wise for negative infinity, return result as bool array.</source>
          <target state="translated">Тест на отрицательную бесконечность по элементам,возвращает результат в виде массива bool.</target>
        </trans-unit>
        <trans-unit id="f441420173d81baeaa59a4fb443d5293972df75a" translate="yes" xml:space="preserve">
          <source>Test element-wise for positive infinity, return result as bool array.</source>
          <target state="translated">Тестируйте по элементам на положительную бесконечность,возвращайте результат в виде массива bool.</target>
        </trans-unit>
        <trans-unit id="f76286ad13fcd1d6939365b38ad9443c5711054b" translate="yes" xml:space="preserve">
          <source>Test element-wise for positive or negative infinity.</source>
          <target state="translated">Тест на положительную или отрицательную бесконечность по элементам.</target>
        </trans-unit>
        <trans-unit id="a54ae1b5fd87138bbeb065cc5056362be6e773bd" translate="yes" xml:space="preserve">
          <source>Test if &lt;code&gt;path&lt;/code&gt; exists as (and in this order):</source>
          <target state="translated">Проверьте, существует ли &lt;code&gt;path&lt;/code&gt; как (и в этом порядке):</target>
        </trans-unit>
        <trans-unit id="6db21c53daecd81068cb27c5716c17cf9ec8f853" translate="yes" xml:space="preserve">
          <source>Test if path exists.</source>
          <target state="translated">Проверьте,существует ли путь.</target>
        </trans-unit>
        <trans-unit id="ab9c97d91f47360ac72bf2e9386f7b26c75db7d2" translate="yes" xml:space="preserve">
          <source>Test if two strings are equal.</source>
          <target state="translated">Проверьте,равны ли две строки.</target>
        </trans-unit>
        <trans-unit id="90c99592ef3a4e369f5b8438543a142bc4a6d8c8" translate="yes" xml:space="preserve">
          <source>Test support</source>
          <target state="translated">Тестовая поддержка</target>
        </trans-unit>
        <trans-unit id="fe6e53750db930a15ff2a9eb0786f6b4b0dd49e8" translate="yes" xml:space="preserve">
          <source>Test whether &lt;code&gt;ary&lt;/code&gt; is contiguous. If so, return 1. Otherwise, set a Python error and return 0.</source>
          <target state="translated">Проверьте, является ли &lt;code&gt;ary&lt;/code&gt; смежной. Если да, верните 1. В противном случае установите ошибку Python и верните 0.</target>
        </trans-unit>
        <trans-unit id="e52099e2b541a96f27cc77aa438f266ac05e538f" translate="yes" xml:space="preserve">
          <source>Test whether all array elements along a given axis evaluate to True.</source>
          <target state="translated">Проверьте,все ли элементы массива вдоль заданной оси оцениваются в True.</target>
        </trans-unit>
        <trans-unit id="7d4c1c04414d7af36c37c81837979d62019dac75" translate="yes" xml:space="preserve">
          <source>Test whether all elements along a given axis evaluate to True.</source>
          <target state="translated">Проверьте,все ли элементы вдоль данной оси оцениваются в True.</target>
        </trans-unit>
        <trans-unit id="8dcb7ed405671230192b179ae33bab118c7f5996" translate="yes" xml:space="preserve">
          <source>Test whether all matrix elements along a given axis evaluate to True.</source>
          <target state="translated">Проверьте,все ли элементы матрицы вдоль заданной оси оцениваются в True.</target>
        </trans-unit>
        <trans-unit id="a8cd365e47952360dc676cadf55d3bc2ecae44b5" translate="yes" xml:space="preserve">
          <source>Test whether any array element along a given axis evaluates to True.</source>
          <target state="translated">Проверьте,оценивает ли какой-либо элемент массива вдоль заданной оси значение True.</target>
        </trans-unit>
        <trans-unit id="e54011a9e26f7c9e97e1ca23a771785990f7e7d4" translate="yes" xml:space="preserve">
          <source>Test whether any element along a given axis evaluates to True.</source>
          <target state="translated">Проверьте,оценивается ли какой-либо элемент вдоль данной оси в True.</target>
        </trans-unit>
        <trans-unit id="3c5d24b0586eac0954dbcb6d49897a1641c89d36" translate="yes" xml:space="preserve">
          <source>Test whether each element of a 1-D array is also present in a second array.</source>
          <target state="translated">Проверьте,присутствует ли каждый элемент 1-D массива во втором массиве.</target>
        </trans-unit>
        <trans-unit id="025a700084bfede250ccd79227b915c047f7f35d" translate="yes" xml:space="preserve">
          <source>Test whether input is an instance of MaskedArray.</source>
          <target state="translated">Проверьте,является ли входным параметром MaskedArray.</target>
        </trans-unit>
        <trans-unit id="43d2fa7f4fbc625f4df01f08ea6653e49f950cbd" translate="yes" xml:space="preserve">
          <source>Testing Guidelines</source>
          <target state="translated">Руководство по тестированию</target>
        </trans-unit>
        <trans-unit id="ef9606fae34bdb52d82ad257949ec42aea0b9b12" translate="yes" xml:space="preserve">
          <source>Testing Header Files</source>
          <target state="translated">Файлы тестовых заголовков</target>
        </trans-unit>
        <trans-unit id="d322a0e8fe52f19dbe7d5bd52156ee63071b90d8" translate="yes" xml:space="preserve">
          <source>Testing Organization</source>
          <target state="translated">Тестирующая организация</target>
        </trans-unit>
        <trans-unit id="e3148b0ff766bdb8347a198898838253aab4da96" translate="yes" xml:space="preserve">
          <source>Testing Python Scripts</source>
          <target state="translated">Тестирование питоновских сценариев</target>
        </trans-unit>
        <trans-unit id="8c3a61a48bb499744371cb7fc30761102d86f229" translate="yes" xml:space="preserve">
          <source>Testing SWIG Interface Files</source>
          <target state="translated">Тестирование файлов интерфейса SWIG</target>
        </trans-unit>
        <trans-unit id="34d08d85bddb11f11da76ad84dab43a94d74c7ed" translate="yes" xml:space="preserve">
          <source>Testing Source Files</source>
          <target state="translated">Файлы источников тестирования</target>
        </trans-unit>
        <trans-unit id="7704b172077f920ddd46d5adbcffe86730e58a19" translate="yes" xml:space="preserve">
          <source>Testing looks for module-level or class-level setup and teardown functions by name; thus:</source>
          <target state="translated">Тестирование ищет функции настройки на модульном или классовом уровне,а также функции по названию:</target>
        </trans-unit>
        <trans-unit id="45ece46e91d1fe305feeee99aed2fad182be7b30" translate="yes" xml:space="preserve">
          <source>Testing the numpy.i Typemaps</source>
          <target state="translated">Тестирование типовых карт numpy.i.</target>
        </trans-unit>
        <trans-unit id="417d130b240483956f423e540d6cb689832b6f9e" translate="yes" xml:space="preserve">
          <source>Tests on random data</source>
          <target state="translated">Тесты на случайных данных</target>
        </trans-unit>
        <trans-unit id="f3d72180c504c070f745ad049bd21c11042867d1" translate="yes" xml:space="preserve">
          <source>Tests on random data are good, but since test failures are meant to expose new bugs or regressions, a test that passes most of the time but fails occasionally with no code changes is not helpful. Make the random data deterministic by setting the random number seed before generating it. Use either Python&amp;rsquo;s &lt;code&gt;random.seed(some_number)&lt;/code&gt; or NumPy&amp;rsquo;s &lt;code&gt;numpy.random.seed(some_number)&lt;/code&gt;, depending on the source of random numbers.</source>
          <target state="translated">Тесты на случайных данных хороши, но поскольку сбои тестов предназначены для выявления новых ошибок или регрессий, тест, который проходит большую часть времени, но иногда терпит неудачу без изменений кода, бесполезен. Сделайте случайные данные детерминированными, установив начальное число случайных чисел перед их генерацией. Используйте либо Пайтон &lt;code&gt;random.seed(some_number)&lt;/code&gt; или Numpy в &lt;code&gt;numpy.random.seed(some_number)&lt;/code&gt; , в зависимости от источника случайных чисел.</target>
        </trans-unit>
        <trans-unit id="927f696caa5bf0529c4f0991bbe8b99afb2fa55b" translate="yes" xml:space="preserve">
          <source>Tests whether the half-precision float has a value equal to zero. This may be slightly faster than calling npy_half_eq(h, NPY_ZERO).</source>
          <target state="translated">Тестирует,имеет ли плавающий диск половинной точности значение,равное нулю.Это может быть несколько быстрее,чем вызов npy_half_eq(h,NPY_ZERO).</target>
        </trans-unit>
        <trans-unit id="b3be553d33f0513a6775eaa86f3391147a1aac09" translate="yes" xml:space="preserve">
          <source>Tests whether the half-precision float is a NaN.</source>
          <target state="translated">Проверяет,является ли поплавок половинной точности NaN.</target>
        </trans-unit>
        <trans-unit id="6424a62751d70065c8ad2d16d22d5e29e4d2e45c" translate="yes" xml:space="preserve">
          <source>Tests whether the half-precision float is finite (not NaN or Inf).</source>
          <target state="translated">Проверяет,является ли плавающий поплавок половинной точности конечным (не NaN или Inf).</target>
        </trans-unit>
        <trans-unit id="b796fd95ec3aee28c84902e310b3fcc5e87bd087" translate="yes" xml:space="preserve">
          <source>Tests whether the half-precision float is plus or minus Inf.</source>
          <target state="translated">Проверяет,является ли половинчатый поплавок плюс-минус Inf.</target>
        </trans-unit>
        <trans-unit id="9cad929af9630184e2ec9f960cd674271afcf718" translate="yes" xml:space="preserve">
          <source>Tests, that send messages to stderr, fail when executed from MSYS prompt because the messages are lost at some point.</source>
          <target state="translated">Тесты,которые посылают сообщения в stderr,терпят неудачу при выполнении из MSYS подсказки,потому что сообщения в какой-то момент теряются.</target>
        </trans-unit>
        <trans-unit id="0a988a505d4f9bd1f41a57f4c2458a2423baedc7" translate="yes" xml:space="preserve">
          <source>Text files</source>
          <target state="translated">Текстовые файлы</target>
        </trans-unit>
        <trans-unit id="4ba343aecd438b7c22876dbbd27f537f09be5607" translate="yes" xml:space="preserve">
          <source>Text formatting options</source>
          <target state="translated">Опции форматирования текста</target>
        </trans-unit>
        <trans-unit id="90e8faeace432448f3522160a796443560f628f2" translate="yes" xml:space="preserve">
          <source>That can be one of 12 different scalar types: &lt;code&gt;signed char&lt;/code&gt;, &lt;code&gt;unsigned char&lt;/code&gt;, &lt;code&gt;short&lt;/code&gt;, &lt;code&gt;unsigned short&lt;/code&gt;, &lt;code&gt;int&lt;/code&gt;, &lt;code&gt;unsigned int&lt;/code&gt;, &lt;code&gt;long&lt;/code&gt;, &lt;code&gt;unsigned long&lt;/code&gt;, &lt;code&gt;long long&lt;/code&gt;, &lt;code&gt;unsigned long long&lt;/code&gt;, &lt;code&gt;float&lt;/code&gt; and &lt;code&gt;double&lt;/code&gt;.</source>
          <target state="translated">Это может быть один из 12 различных скалярных типов: &lt;code&gt;signed char&lt;/code&gt; , &lt;code&gt;unsigned char&lt;/code&gt; , &lt;code&gt;short&lt;/code&gt; , &lt;code&gt;unsigned short&lt;/code&gt; , &lt;code&gt;int&lt;/code&gt; , &lt;code&gt;unsigned int&lt;/code&gt; , &lt;code&gt;long&lt;/code&gt; , &lt;code&gt;unsigned long&lt;/code&gt; , &lt;code&gt;long long&lt;/code&gt; , &lt;code&gt;unsigned long long&lt;/code&gt; , &lt;code&gt;float&lt;/code&gt; и &lt;code&gt;double&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="be4b72468f984c83d93633e8f8bf75388e94a047" translate="yes" xml:space="preserve">
          <source>That is a looser test than originally documented, but agrees with what the actual implementation did up to rounding vagaries. An exception is raised at shape mismatch or conflicting values. In contrast to the standard usage in numpy, NaNs are compared like numbers, no assertion is raised if both objects have NaNs in the same positions.</source>
          <target state="translated">Это более проигрышный тест,чем первоначально документированный,но согласуется с тем,что реальная реализация сделала с капризами округления.Исключение поднимается при несовпадении форм или противоречивых значениях.В отличие от стандартного использования в нумерации,NaNs сравниваются как числа,утверждение не поднимается,если оба объекта имеют NaNs в одних и тех же позициях.</target>
        </trans-unit>
        <trans-unit id="31ca174a88927a9e0e7f8f15283f8ce9b3459f51" translate="yes" xml:space="preserve">
          <source>That is a looser test than originally documented, but agrees with what the actual implementation in &lt;a href=&quot;numpy.testing.assert_array_almost_equal#numpy.testing.assert_array_almost_equal&quot;&gt;&lt;code&gt;assert_array_almost_equal&lt;/code&gt;&lt;/a&gt; did up to rounding vagaries. An exception is raised at conflicting values. For ndarrays this delegates to assert_array_almost_equal</source>
          <target state="translated">Это более свободный тест, чем изначально задокументированный, но он согласуется с тем, что было &lt;a href=&quot;numpy.testing.assert_array_almost_equal#numpy.testing.assert_array_almost_equal&quot;&gt; &lt;code&gt;assert_array_almost_equal&lt;/code&gt; &lt;/a&gt; в реальной реализации в assert_array_almost_equal , вплоть до капризов округления. Исключение возникает при противоречивых значениях. Для ndarrays это делегирует assert_array_almost_equal</target>
        </trans-unit>
        <trans-unit id="b5240cf478eeccab2d778da09495ef32dd780cc8" translate="yes" xml:space="preserve">
          <source>That support 74 different argument signatures for each data type, including:</source>
          <target state="translated">Поддерживаются 74 различные сигнатуры аргументов для каждого типа данных,в том числе:</target>
        </trans-unit>
        <trans-unit id="93ef0dd827103681fcee453b78be2ff14e1a261d" translate="yes" xml:space="preserve">
          <source>The</source>
          <target state="translated">The</target>
        </trans-unit>
        <trans-unit id="5c4c1c79691cc97764af36fe5679519dac98f423" translate="yes" xml:space="preserve">
          <source>The &amp;ldquo;busday&amp;rdquo; functions can additionally check a list of &amp;ldquo;holiday&amp;rdquo; dates, specific dates that are not valid days.</source>
          <target state="translated">Функции &amp;laquo;рабочий день&amp;raquo; могут дополнительно проверить список &amp;laquo;праздничных&amp;raquo; дат, определенных дат, которые не являются действительными днями.</target>
        </trans-unit>
        <trans-unit id="701df984a45b35c07efc7a2ab11dc3b2d9004e29" translate="yes" xml:space="preserve">
          <source>The &amp;ldquo;four quadrant&amp;rdquo; arctan of the angle formed by (&lt;code&gt;x&lt;/code&gt;, &lt;code&gt;y&lt;/code&gt;) and the positive &lt;code&gt;x&lt;/code&gt;-axis.</source>
          <target state="translated">&amp;laquo;Четырехквадрантный&amp;raquo; арктангенс угла, образованного ( &lt;code&gt;x&lt;/code&gt; , &lt;code&gt;y&lt;/code&gt; ) и положительной осью &lt;code&gt;x&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2adc5d4e116d43dd248737cacbfac03ed3ef63f9" translate="yes" xml:space="preserve">
          <source>The &amp;ldquo;y-intercept&amp;rdquo; and &amp;ldquo;slope&amp;rdquo; of the line, respectively.</source>
          <target state="translated">&amp;laquo;Y-точка пересечения&amp;raquo; и &amp;laquo;наклон&amp;raquo; линии соответственно.</target>
        </trans-unit>
        <trans-unit id="e4a0235cef14b392c275cecc105837cde82d5723" translate="yes" xml:space="preserve">
          <source>The &amp;lsquo;a&amp;rsquo; variable is unstripped from c[1] because whitespace leading.</source>
          <target state="translated">Переменная 'a' не отделена от c [1] из-за пробела.</target>
        </trans-unit>
        <trans-unit id="bda37a7da4e6885245e567c4fedb24dc646e8a1c" translate="yes" xml:space="preserve">
          <source>The &amp;lsquo;out&amp;rsquo; keyword argument is expected to be a tuple with one entry per output (which can be &lt;code&gt;None&lt;/code&gt; for arrays to be allocated by the ufunc). For ufuncs with a single output, passing a single array (instead of a tuple holding a single array) is also valid.</source>
          <target state="translated">Ожидается, что аргумент ключевого слова out будет кортежем с одной записью на каждый вывод (который может иметь значение &lt;code&gt;None&lt;/code&gt; для массивов, выделяемых ufunc). Для ufuncs с одним выходом также допустима передача одного массива (вместо кортежа, содержащего один массив).</target>
        </trans-unit>
        <trans-unit id="34701f78458bf915d5b828bf9386058d6824fbe4" translate="yes" xml:space="preserve">
          <source>The &amp;lsquo;per&amp;rsquo; variable represents the periods of the loan. Remember that financial equations start the period count at 1!</source>
          <target state="translated">Переменная &quot;per&quot; представляет периоды ссуды. Помните, что в финансовых уравнениях отсчет периода начинается с 1!</target>
        </trans-unit>
        <trans-unit id="cb090179fdd970838b19c1b214a4530cfcd16ee3" translate="yes" xml:space="preserve">
          <source>The (non-conjugated) transpose of the matrix.</source>
          <target state="translated">(несопряженная)транспозиция матрицы.</target>
        </trans-unit>
        <trans-unit id="2c0a3ac18c0e35ff547f3a4005419b0e018f9e8e" translate="yes" xml:space="preserve">
          <source>The 1.6 implementation of datetime does not convert between units correctly.:</source>
          <target state="translated">1.6 реализация даты не корректно конвертирует время между единицами..:</target>
        </trans-unit>
        <trans-unit id="f72725eb7318a896f41cd0cf447d8c91f324fb0d" translate="yes" xml:space="preserve">
          <source>The 1.6 implementation of datetime only works correctly for a small subset of arithmetic operations. Here we show some simple cases.:</source>
          <target state="translated">Реализация datetime 1.6 корректно работает только для небольшого подмножества арифметических операций.Здесь мы покажем несколько простых случаев:</target>
        </trans-unit>
        <trans-unit id="887cfe3b8a793575511e5fe48982dbd8c7813d6e" translate="yes" xml:space="preserve">
          <source>The 2-D output array.</source>
          <target state="translated">2-D выходной массив.</target>
        </trans-unit>
        <trans-unit id="8d40d72287619706da0622aa60cf9b527faa81be" translate="yes" xml:space="preserve">
          <source>The 24 built-in &lt;a href=&quot;arrays.scalars#arrays-scalars-built-in&quot;&gt;array scalar type objects&lt;/a&gt; all convert to an associated data-type object. This is true for their sub-classes as well.</source>
          <target state="translated">Все 24 &lt;a href=&quot;arrays.scalars#arrays-scalars-built-in&quot;&gt;объекта скалярного типа&lt;/a&gt; встроенного массива преобразуются в связанный объект типа данных. Это верно и для их подклассов.</target>
        </trans-unit>
        <trans-unit id="44abfc0b778e06539587a775fdc8b33ee9085231" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#c.NPY_ARRAY_C_CONTIGUOUS&quot;&gt;&lt;code&gt;NPY_ARRAY_C_CONTIGUOUS&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#c.NPY_ARRAY_ALIGNED&quot;&gt;&lt;code&gt;NPY_ARRAY_ALIGNED&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;#c.NPY_ARRAY_F_CONTIGUOUS&quot;&gt;&lt;code&gt;NPY_ARRAY_F_CONTIGUOUS&lt;/code&gt;&lt;/a&gt; array flags can be &amp;ldquo;calculated&amp;rdquo; from the array object itself. This routine updates one or more of these flags of &lt;em&gt;arr&lt;/em&gt; as specified in &lt;em&gt;flagmask&lt;/em&gt; by performing the required calculation.</source>
          <target state="translated">В &lt;a href=&quot;#c.NPY_ARRAY_C_CONTIGUOUS&quot;&gt; &lt;code&gt;NPY_ARRAY_C_CONTIGUOUS&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#c.NPY_ARRAY_ALIGNED&quot;&gt; &lt;code&gt;NPY_ARRAY_ALIGNED&lt;/code&gt; &lt;/a&gt; и &lt;a href=&quot;#c.NPY_ARRAY_F_CONTIGUOUS&quot;&gt; &lt;code&gt;NPY_ARRAY_F_CONTIGUOUS&lt;/code&gt; &lt;/a&gt; флаги массива могут быть &amp;laquo;вычислены&amp;raquo; от самого объекта массива. Эта процедура обновляет один или несколько из этих флагов &lt;em&gt;arr,&lt;/em&gt; как указано в &lt;em&gt;flagmask,&lt;/em&gt; путем выполнения необходимых вычислений.</target>
        </trans-unit>
        <trans-unit id="83e501c171dddeb86862ef16beddd704b5bc114a" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#c.PyArrayDescr_Type&quot;&gt;&lt;code&gt;PyArrayDescr_Type&lt;/code&gt;&lt;/a&gt; is the built-in type of the data-type-descriptor objects used to describe how the bytes comprising the array are to be interpreted. There are 21 statically-defined &lt;a href=&quot;#c.PyArray_Descr&quot;&gt;&lt;code&gt;PyArray_Descr&lt;/code&gt;&lt;/a&gt; objects for the built-in data-types. While these participate in reference counting, their reference count should never reach zero. There is also a dynamic table of user-defined &lt;a href=&quot;#c.PyArray_Descr&quot;&gt;&lt;code&gt;PyArray_Descr&lt;/code&gt;&lt;/a&gt; objects that is also maintained. Once a data-type-descriptor object is &amp;ldquo;registered&amp;rdquo; it should never be deallocated either. The function &lt;a href=&quot;c-api.array#c.PyArray_DescrFromType&quot;&gt;&lt;code&gt;PyArray_DescrFromType&lt;/code&gt;&lt;/a&gt; (&amp;hellip;) can be used to retrieve a &lt;a href=&quot;#c.PyArray_Descr&quot;&gt;&lt;code&gt;PyArray_Descr&lt;/code&gt;&lt;/a&gt; object from an enumerated type-number (either built-in or user- defined).</source>
          <target state="translated">&lt;a href=&quot;#c.PyArrayDescr_Type&quot;&gt; &lt;code&gt;PyArrayDescr_Type&lt;/code&gt; &lt;/a&gt; является встроенным типом данных для типа дескриптора объектов , используемый для описания , как байты , содержащие массив должны интерпретироваться. Есть 21 статически определенный &lt;a href=&quot;#c.PyArray_Descr&quot;&gt; &lt;code&gt;PyArray_Descr&lt;/code&gt; &lt;/a&gt; для встроенных типов данных. Хотя они участвуют в подсчете ссылок, их счетчик ссылок никогда не должен достигать нуля. Также поддерживается динамическая таблица определяемых &lt;a href=&quot;#c.PyArray_Descr&quot;&gt; &lt;code&gt;PyArray_Descr&lt;/code&gt; &lt;/a&gt; объектов PyArray_Descr . После того как объект дескриптора типа данных &amp;laquo;зарегистрирован&amp;raquo;, его также нельзя освобождать. Функцию &lt;a href=&quot;c-api.array#c.PyArray_DescrFromType&quot;&gt; &lt;code&gt;PyArray_DescrFromType&lt;/code&gt; &lt;/a&gt; (&amp;hellip;) можно использовать для получения объекта &lt;a href=&quot;#c.PyArray_Descr&quot;&gt; &lt;code&gt;PyArray_Descr&lt;/code&gt; &lt;/a&gt; из пронумерованного типа-номера (встроенного или определяемого пользователем).</target>
        </trans-unit>
        <trans-unit id="3bd6fb4bf6c794847df919e4e53f9f40e8a12e37" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#c.PyArrayInterface&quot;&gt;&lt;code&gt;PyArrayInterface&lt;/code&gt;&lt;/a&gt; structure is defined so that NumPy and other extension modules can use the rapid array interface protocol. The &lt;code&gt;__array_struct__&lt;/code&gt; method of an object that supports the rapid array interface protocol should return a &lt;code&gt;PyCObject&lt;/code&gt; that contains a pointer to a &lt;a href=&quot;#c.PyArrayInterface&quot;&gt;&lt;code&gt;PyArrayInterface&lt;/code&gt;&lt;/a&gt; structure with the relevant details of the array. After the new array is created, the attribute should be &lt;code&gt;DECREF&lt;/code&gt;&amp;rsquo;d which will free the &lt;a href=&quot;#c.PyArrayInterface&quot;&gt;&lt;code&gt;PyArrayInterface&lt;/code&gt;&lt;/a&gt; structure. Remember to &lt;code&gt;INCREF&lt;/code&gt; the object (whose &lt;code&gt;__array_struct__&lt;/code&gt; attribute was retrieved) and point the base member of the new &lt;a href=&quot;#c.PyArrayObject&quot;&gt;&lt;code&gt;PyArrayObject&lt;/code&gt;&lt;/a&gt; to this same object. In this way the memory for the array will be managed correctly.</source>
          <target state="translated">Структура &lt;a href=&quot;#c.PyArrayInterface&quot;&gt; &lt;code&gt;PyArrayInterface&lt;/code&gt; &lt;/a&gt; определена так, что NumPy и другие модули расширения могут использовать протокол интерфейса быстрого массива. Метод &lt;code&gt;__array_struct__&lt;/code&gt; объекта, который поддерживает протокол интерфейса быстрого массива, должен возвращать &lt;code&gt;PyCObject&lt;/code&gt; , содержащий указатель на структуру &lt;a href=&quot;#c.PyArrayInterface&quot;&gt; &lt;code&gt;PyArrayInterface&lt;/code&gt; &lt;/a&gt; с соответствующими деталями массива. После создания нового массива атрибут должен быть &lt;code&gt;DECREF&lt;/code&gt; 'd, который освободит структуру &lt;a href=&quot;#c.PyArrayInterface&quot;&gt; &lt;code&gt;PyArrayInterface&lt;/code&gt; &lt;/a&gt; . Не забудьте &lt;code&gt;INCREF&lt;/code&gt; объект (чей атрибут &lt;code&gt;__array_struct__&lt;/code&gt; был извлечен) и указать базовый член нового &lt;a href=&quot;#c.PyArrayObject&quot;&gt; &lt;code&gt;PyArrayObject&lt;/code&gt; &lt;/a&gt;к этому же объекту. Таким образом, память для массива будет управляться правильно.</target>
        </trans-unit>
        <trans-unit id="cd84e3bef1191839ce6ab3739e785dd2e1559188" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#c.PyArrayObject&quot;&gt;&lt;code&gt;PyArrayObject&lt;/code&gt;&lt;/a&gt; C-structure contains all of the required information for an array. All instances of an ndarray (and its subclasses) will have this structure. For future compatibility, these structure members should normally be accessed using the provided macros. If you need a shorter name, then you can make use of &lt;code&gt;NPY_AO&lt;/code&gt; (deprecated) which is defined to be equivalent to &lt;a href=&quot;#c.PyArrayObject&quot;&gt;&lt;code&gt;PyArrayObject&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#c.PyArrayObject&quot;&gt; &lt;code&gt;PyArrayObject&lt;/code&gt; &lt;/a&gt; С-структура содержит всю необходимую информацию для массива. Все экземпляры ndarray (и его подклассы) будут иметь эту структуру. Для будущей совместимости к этим элементам структуры обычно следует обращаться с помощью предоставленных макросов. Если вам нужно более короткое имя, вы можете использовать &lt;code&gt;NPY_AO&lt;/code&gt; (устаревший), который определен как эквивалент &lt;a href=&quot;#c.PyArrayObject&quot;&gt; &lt;code&gt;PyArrayObject&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="9d2c044849f6b8be8bb6f06a8ac4ced885f369cf" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#c.PyArray_Descr&quot;&gt;&lt;code&gt;PyArray_Descr&lt;/code&gt;&lt;/a&gt; structure lies at the heart of the &lt;a href=&quot;#c.PyArrayDescr_Type&quot;&gt;&lt;code&gt;PyArrayDescr_Type&lt;/code&gt;&lt;/a&gt;. While it is described here for completeness, it should be considered internal to NumPy and manipulated via &lt;code&gt;PyArrayDescr_*&lt;/code&gt; or &lt;code&gt;PyDataType*&lt;/code&gt; functions and macros. The size of this structure is subject to change across versions of NumPy. To ensure compatibility:</source>
          <target state="translated">Структура &lt;a href=&quot;#c.PyArray_Descr&quot;&gt; &lt;code&gt;PyArray_Descr&lt;/code&gt; &lt;/a&gt; лежит в основе &lt;a href=&quot;#c.PyArrayDescr_Type&quot;&gt; &lt;code&gt;PyArrayDescr_Type&lt;/code&gt; &lt;/a&gt; . Хотя он описан здесь для полноты, его следует рассматривать как внутренний для NumPy и управлять им с помощью функций и макросов &lt;code&gt;PyArrayDescr_*&lt;/code&gt; или &lt;code&gt;PyDataType*&lt;/code&gt; . Размер этой структуры может меняться в разных версиях NumPy. Для обеспечения совместимости:</target>
        </trans-unit>
        <trans-unit id="2e3e60e01ee7ee0a4514d09bc8a1e601d0467625" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#c.PyArray_Type&quot;&gt;&lt;code&gt;PyArray_Type&lt;/code&gt;&lt;/a&gt; typeobject implements many of the features of &lt;a href=&quot;https://docs.python.org/dev/c-api/type.html#c.PyTypeObject&quot;&gt;&lt;code&gt;Python objects&lt;/code&gt;&lt;/a&gt; including the &lt;a href=&quot;https://docs.python.org/dev/c-api/typeobj.html#c.PyTypeObject.tp_as_number&quot;&gt;&lt;code&gt;tp_as_number&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://docs.python.org/dev/c-api/typeobj.html#c.PyTypeObject.tp_as_sequence&quot;&gt;&lt;code&gt;tp_as_sequence&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://docs.python.org/dev/c-api/typeobj.html#c.PyTypeObject.tp_as_mapping&quot;&gt;&lt;code&gt;tp_as_mapping&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;https://docs.python.org/dev/c-api/typeobj.html#c.PyTypeObject.tp_as_buffer&quot;&gt;&lt;code&gt;tp_as_buffer&lt;/code&gt;&lt;/a&gt; interfaces. The &lt;a href=&quot;https://docs.python.org/dev/c-api/typeobj.html#c.richcmpfunc&quot;&gt;&lt;code&gt;rich comparison&lt;/code&gt;&lt;/a&gt;) is also used along with new-style attribute lookup for member (&lt;a href=&quot;https://docs.python.org/dev/c-api/typeobj.html#c.PyTypeObject.tp_members&quot;&gt;&lt;code&gt;tp_members&lt;/code&gt;&lt;/a&gt;) and properties (&lt;a href=&quot;https://docs.python.org/dev/c-api/typeobj.html#c.PyTypeObject.tp_getset&quot;&gt;&lt;code&gt;tp_getset&lt;/code&gt;&lt;/a&gt;). The &lt;a href=&quot;#c.PyArray_Type&quot;&gt;&lt;code&gt;PyArray_Type&lt;/code&gt;&lt;/a&gt; can also be sub-typed.</source>
          <target state="translated">В &lt;a href=&quot;#c.PyArray_Type&quot;&gt; &lt;code&gt;PyArray_Type&lt;/code&gt; &lt;/a&gt; typeobject реализует многие из особенностей &lt;a href=&quot;https://docs.python.org/dev/c-api/type.html#c.PyTypeObject&quot;&gt; &lt;code&gt;Python objects&lt;/code&gt; &lt;/a&gt; , в том числе &lt;a href=&quot;https://docs.python.org/dev/c-api/typeobj.html#c.PyTypeObject.tp_as_number&quot;&gt; &lt;code&gt;tp_as_number&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;https://docs.python.org/dev/c-api/typeobj.html#c.PyTypeObject.tp_as_sequence&quot;&gt; &lt;code&gt;tp_as_sequence&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;https://docs.python.org/dev/c-api/typeobj.html#c.PyTypeObject.tp_as_mapping&quot;&gt; &lt;code&gt;tp_as_mapping&lt;/code&gt; &lt;/a&gt; и &lt;a href=&quot;https://docs.python.org/dev/c-api/typeobj.html#c.PyTypeObject.tp_as_buffer&quot;&gt; &lt;code&gt;tp_as_buffer&lt;/code&gt; &lt;/a&gt; интерфейсы. Расширенное &lt;a href=&quot;https://docs.python.org/dev/c-api/typeobj.html#c.richcmpfunc&quot;&gt; &lt;code&gt;rich comparison&lt;/code&gt; &lt;/a&gt; ) также используется вместе с поиском атрибутов нового стиля для члена ( &lt;a href=&quot;https://docs.python.org/dev/c-api/typeobj.html#c.PyTypeObject.tp_members&quot;&gt; &lt;code&gt;tp_members&lt;/code&gt; &lt;/a&gt; ) и свойств ( &lt;a href=&quot;https://docs.python.org/dev/c-api/typeobj.html#c.PyTypeObject.tp_getset&quot;&gt; &lt;code&gt;tp_getset&lt;/code&gt; &lt;/a&gt; ). &lt;a href=&quot;#c.PyArray_Type&quot;&gt; &lt;code&gt;PyArray_Type&lt;/code&gt; &lt;/a&gt; также может быть суб-набран.</target>
        </trans-unit>
        <trans-unit id="f2f36b5d156bf75520af226984583d62ec445b7c" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#module-numpy.char&quot;&gt;&lt;code&gt;numpy.char&lt;/code&gt;&lt;/a&gt; module provides a set of vectorized string operations for arrays of type &lt;code&gt;numpy.string_&lt;/code&gt; or &lt;code&gt;numpy.unicode_&lt;/code&gt;. All of them are based on the string methods in the Python standard library.</source>
          <target state="translated">Модуль &lt;a href=&quot;#module-numpy.char&quot;&gt; &lt;code&gt;numpy.char&lt;/code&gt; &lt;/a&gt; предоставляет набор векторизованных строковых операций для массивов типа &lt;code&gt;numpy.string_&lt;/code&gt; или &lt;code&gt;numpy.unicode_&lt;/code&gt; . Все они основаны на строковых методах стандартной библиотеки Python.</target>
        </trans-unit>
        <trans-unit id="2314014335c763a38d9f2613dc7158883ea47e7a" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#module-numpy.ma&quot;&gt;&lt;code&gt;numpy.ma&lt;/code&gt;&lt;/a&gt; module can be used as an addition to &lt;a href=&quot;index#module-numpy&quot;&gt;&lt;code&gt;numpy&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">Модуль &lt;a href=&quot;#module-numpy.ma&quot;&gt; &lt;code&gt;numpy.ma&lt;/code&gt; &lt;/a&gt; можно использовать как дополнение к &lt;a href=&quot;index#module-numpy&quot;&gt; &lt;code&gt;numpy&lt;/code&gt; &lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="bc31921d14e06fe1077c1cf00e508c39081a2db7" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#module-numpy.ma&quot;&gt;&lt;code&gt;numpy.ma&lt;/code&gt;&lt;/a&gt; module comes with a specific implementation of most ufuncs. Unary and binary functions that have a validity domain (such as &lt;a href=&quot;generated/numpy.log#numpy.log&quot;&gt;&lt;code&gt;log&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;generated/numpy.divide#numpy.divide&quot;&gt;&lt;code&gt;divide&lt;/code&gt;&lt;/a&gt;) return the &lt;a href=&quot;maskedarray.baseclass#numpy.ma.masked&quot;&gt;&lt;code&gt;masked&lt;/code&gt;&lt;/a&gt; constant whenever the input is masked or falls outside the validity domain:</source>
          <target state="translated">Модуль &lt;a href=&quot;#module-numpy.ma&quot;&gt; &lt;code&gt;numpy.ma&lt;/code&gt; &lt;/a&gt; поставляется с конкретной реализацией большинства функций ufunc. Унарные и двоичные функции, у которых есть область допустимости (например, &lt;a href=&quot;generated/numpy.log#numpy.log&quot;&gt; &lt;code&gt;log&lt;/code&gt; &lt;/a&gt; или &lt;a href=&quot;generated/numpy.divide#numpy.divide&quot;&gt; &lt;code&gt;divide&lt;/code&gt; &lt;/a&gt; ), возвращают &lt;a href=&quot;maskedarray.baseclass#numpy.ma.masked&quot;&gt; &lt;code&gt;masked&lt;/code&gt; &lt;/a&gt; константу всякий раз, когда ввод замаскирован или выходит за пределы области допустимости:</target>
        </trans-unit>
        <trans-unit id="b2581729cb5a508c4225155bce5e9d0c211d34fc" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#numpy.char.chararray&quot;&gt;&lt;code&gt;chararray&lt;/code&gt;&lt;/a&gt; class exists for backwards compatibility with Numarray, it is not recommended for new development. Starting from numpy 1.4, if one needs arrays of strings, it is recommended to use arrays of &lt;a href=&quot;numpy.char.chararray.dtype#numpy.char.chararray.dtype&quot;&gt;&lt;code&gt;dtype&lt;/code&gt;&lt;/a&gt;&lt;code&gt;object_&lt;/code&gt;, &lt;code&gt;string_&lt;/code&gt; or &lt;code&gt;unicode_&lt;/code&gt;, and use the free functions in the &lt;a href=&quot;../routines.char#module-numpy.char&quot;&gt;&lt;code&gt;numpy.char&lt;/code&gt;&lt;/a&gt; module for fast vectorized string operations.</source>
          <target state="translated">Класс &lt;a href=&quot;#numpy.char.chararray&quot;&gt; &lt;code&gt;chararray&lt;/code&gt; &lt;/a&gt; существует для обратной совместимости с Numarray, он не рекомендуется для новых разработок. Начиная с numpy 1.4, если нужны массивы строк, рекомендуется использовать массивы &lt;a href=&quot;numpy.char.chararray.dtype#numpy.char.chararray.dtype&quot;&gt; &lt;code&gt;dtype&lt;/code&gt; &lt;/a&gt; &lt;code&gt;object_&lt;/code&gt; , &lt;code&gt;string_&lt;/code&gt; или &lt;code&gt;unicode_&lt;/code&gt; , а также использовать бесплатные функции в модуле &lt;a href=&quot;../routines.char#module-numpy.char&quot;&gt; &lt;code&gt;numpy.char&lt;/code&gt; &lt;/a&gt; для быстрых векторизованных строковых операций.</target>
        </trans-unit>
        <trans-unit id="bfd56b98bdff55bc0967f4255e8d608e0cada88c" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#numpy.char.chararray.flags&quot;&gt;&lt;code&gt;flags&lt;/code&gt;&lt;/a&gt; object can be accessed dictionary-like (as in &lt;code&gt;a.flags['WRITEABLE']&lt;/code&gt;), or by using lowercased attribute names (as in &lt;code&gt;a.flags.writeable&lt;/code&gt;). Short flag names are only supported in dictionary access.</source>
          <target state="translated">&lt;a href=&quot;#numpy.char.chararray.flags&quot;&gt; &lt;code&gt;flags&lt;/code&gt; &lt;/a&gt; объект может быть доступен по словарю , как (как в &lt;code&gt;a.flags['WRITEABLE']&lt;/code&gt; ), или с помощью строчных имен атрибутов (как в &lt;code&gt;a.flags.writeable&lt;/code&gt; ). Короткие имена флагов поддерживаются только при доступе к словарю.</target>
        </trans-unit>
        <trans-unit id="5b3e9186bfdffbf3c12bbb5a751b0411b0862a0b" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#numpy.chararray&quot;&gt;&lt;code&gt;chararray&lt;/code&gt;&lt;/a&gt; class exists for backwards compatibility with Numarray, it is not recommended for new development. Starting from numpy 1.4, if one needs arrays of strings, it is recommended to use arrays of &lt;a href=&quot;numpy.dtype#numpy.dtype&quot;&gt;&lt;code&gt;dtype&lt;/code&gt;&lt;/a&gt;&lt;code&gt;object_&lt;/code&gt;, &lt;code&gt;string_&lt;/code&gt; or &lt;code&gt;unicode_&lt;/code&gt;, and use the free functions in the &lt;a href=&quot;../routines.char#module-numpy.char&quot;&gt;&lt;code&gt;numpy.char&lt;/code&gt;&lt;/a&gt; module for fast vectorized string operations.</source>
          <target state="translated">Класс &lt;a href=&quot;#numpy.chararray&quot;&gt; &lt;code&gt;chararray&lt;/code&gt; &lt;/a&gt; существует для обратной совместимости с Numarray, он не рекомендуется для новых разработок. Начиная с numpy 1.4, если нужны массивы строк, рекомендуется использовать массивы &lt;a href=&quot;numpy.dtype#numpy.dtype&quot;&gt; &lt;code&gt;dtype&lt;/code&gt; &lt;/a&gt; &lt;code&gt;object_&lt;/code&gt; , &lt;code&gt;string_&lt;/code&gt; или &lt;code&gt;unicode_&lt;/code&gt; , а также использовать бесплатные функции в модуле &lt;a href=&quot;../routines.char#module-numpy.char&quot;&gt; &lt;code&gt;numpy.char&lt;/code&gt; &lt;/a&gt; для быстрых векторизованных строковых операций.</target>
        </trans-unit>
        <trans-unit id="3c48c115471617c80e93a7432dc970b4f61e8b90" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#numpy.ma.MaskedArray.data&quot;&gt;&lt;code&gt;data&lt;/code&gt;&lt;/a&gt;, as a regular &lt;a href=&quot;generated/numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;numpy.ndarray&lt;/code&gt;&lt;/a&gt; of any shape or datatype (the data).</source>
          <target state="translated">&lt;a href=&quot;#numpy.ma.MaskedArray.data&quot;&gt; &lt;code&gt;data&lt;/code&gt; &lt;/a&gt; , как обычный &lt;a href=&quot;generated/numpy.ndarray#numpy.ndarray&quot;&gt; &lt;code&gt;numpy.ndarray&lt;/code&gt; &lt;/a&gt; любой формы или типа данных (данные).</target>
        </trans-unit>
        <trans-unit id="a0df6452154474f3f899180d65ac301d22c1fea9" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#numpy.ma.MaskedArray.flags&quot;&gt;&lt;code&gt;flags&lt;/code&gt;&lt;/a&gt; object can be accessed dictionary-like (as in &lt;code&gt;a.flags['WRITEABLE']&lt;/code&gt;), or by using lowercased attribute names (as in &lt;code&gt;a.flags.writeable&lt;/code&gt;). Short flag names are only supported in dictionary access.</source>
          <target state="translated">&lt;a href=&quot;#numpy.ma.MaskedArray.flags&quot;&gt; &lt;code&gt;flags&lt;/code&gt; &lt;/a&gt; объект может быть доступен по словарю , как (как в &lt;code&gt;a.flags['WRITEABLE']&lt;/code&gt; ), или с помощью строчных имен атрибутов (как в &lt;code&gt;a.flags.writeable&lt;/code&gt; ). Короткие имена флагов поддерживаются только при доступе к словарю.</target>
        </trans-unit>
        <trans-unit id="768878a0d288c4cac805d022d60e3e5c74cdd571" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#numpy.ma.masked&quot;&gt;&lt;code&gt;masked&lt;/code&gt;&lt;/a&gt; constant is a special case of &lt;a href=&quot;#numpy.ma.MaskedArray&quot;&gt;&lt;code&gt;MaskedArray&lt;/code&gt;&lt;/a&gt;, with a float datatype and a null shape. It is used to test whether a specific entry of a masked array is masked, or to mask one or several entries of a masked array:</source>
          <target state="translated">&lt;a href=&quot;#numpy.ma.masked&quot;&gt; &lt;code&gt;masked&lt;/code&gt; &lt;/a&gt; константа представляет собой частный случай &lt;a href=&quot;#numpy.ma.MaskedArray&quot;&gt; &lt;code&gt;MaskedArray&lt;/code&gt; &lt;/a&gt; , с поплавком типом данными и формой нуля. Он используется для проверки того, замаскирована ли конкретная запись замаскированного массива, или для маскировки одной или нескольких записей замаскированного массива:</target>
        </trans-unit>
        <trans-unit id="146a5b50c3ebb2fb745630d24192949df345a171" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#numpy.matrix.flags&quot;&gt;&lt;code&gt;flags&lt;/code&gt;&lt;/a&gt; object can be accessed dictionary-like (as in &lt;code&gt;a.flags['WRITEABLE']&lt;/code&gt;), or by using lowercased attribute names (as in &lt;code&gt;a.flags.writeable&lt;/code&gt;). Short flag names are only supported in dictionary access.</source>
          <target state="translated">&lt;a href=&quot;#numpy.matrix.flags&quot;&gt; &lt;code&gt;flags&lt;/code&gt; &lt;/a&gt; объект может быть доступен по словарю , как (как в &lt;code&gt;a.flags['WRITEABLE']&lt;/code&gt; ), или с помощью строчных имен атрибутов (как в &lt;code&gt;a.flags.writeable&lt;/code&gt; ). Короткие имена флагов поддерживаются только при доступе к словарю.</target>
        </trans-unit>
        <trans-unit id="59336961ce31b9039ac38b42d5319606fa0f917b" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#numpy.ndarray.flags&quot;&gt;&lt;code&gt;flags&lt;/code&gt;&lt;/a&gt; object can be accessed dictionary-like (as in &lt;code&gt;a.flags['WRITEABLE']&lt;/code&gt;), or by using lowercased attribute names (as in &lt;code&gt;a.flags.writeable&lt;/code&gt;). Short flag names are only supported in dictionary access.</source>
          <target state="translated">&lt;a href=&quot;#numpy.ndarray.flags&quot;&gt; &lt;code&gt;flags&lt;/code&gt; &lt;/a&gt; объект может быть доступен по словарю , как (как в &lt;code&gt;a.flags['WRITEABLE']&lt;/code&gt; ), или с помощью строчных имен атрибутов (как в &lt;code&gt;a.flags.writeable&lt;/code&gt; ). Короткие имена флагов поддерживаются только при доступе к словарю.</target>
        </trans-unit>
        <trans-unit id="550894140eb6b413b0c8bb49cded0a5d50198b4c" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#numpy.random.Generator&quot;&gt;&lt;code&gt;Generator&lt;/code&gt;&lt;/a&gt; provides access to a wide range of distributions, and served as a replacement for &lt;code&gt;RandomState&lt;/code&gt;. The main difference between the two is that &lt;code&gt;Generator&lt;/code&gt; relies on an additional BitGenerator to manage state and generate the random bits, which are then transformed into random values from useful distributions. The default BitGenerator used by &lt;code&gt;Generator&lt;/code&gt; is &lt;code&gt;PCG64&lt;/code&gt;. The BitGenerator can be changed by passing an instantized BitGenerator to &lt;code&gt;Generator&lt;/code&gt;.</source>
          <target state="translated">&lt;a href=&quot;#numpy.random.Generator&quot;&gt; &lt;code&gt;Generator&lt;/code&gt; &lt;/a&gt; обеспечивает доступ к широкому спектру распределений, и служил в качестве замены для &lt;code&gt;RandomState&lt;/code&gt; . Основное различие между ними заключается в том, что &lt;code&gt;Generator&lt;/code&gt; полагается на дополнительный BitGenerator для управления состоянием и генерации случайных битов, которые затем преобразуются в случайные значения из полезных распределений. По умолчанию BitGenerator используется &lt;code&gt;Generator&lt;/code&gt; является &lt;code&gt;PCG64&lt;/code&gt; . BitGenerator можно изменить, передав экземпляр BitGenerator в &lt;code&gt;Generator&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c4a823e24105a263472e6db5aa11ef1abc5d69b0" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#numpy.random.mtrand.RandomState&quot;&gt;&lt;code&gt;RandomState&lt;/code&gt;&lt;/a&gt; provides access to legacy generators. This generator is considered frozen and will have no further improvements. It is guaranteed to produce the same values as the final point release of NumPy v1.16. These all depend on Box-Muller normals or inverse CDF exponentials or gammas. This class should only be used if it is essential to have randoms that are identical to what would have been produced by previous versions of NumPy.</source>
          <target state="translated">&lt;a href=&quot;#numpy.random.mtrand.RandomState&quot;&gt; &lt;code&gt;RandomState&lt;/code&gt; &lt;/a&gt; обеспечивает доступ к унаследованным генераторам. Этот генератор считается замороженным и не будет улучшаться. Гарантируется, что будут получены те же значения, что и в финальной версии NumPy v1.16. Все они зависят от нормалей Бокса-Мюллера или обратных экспонент или гамм CDF. Этот класс следует использовать только в том случае, если необходимо иметь случайные числа, идентичные тому, что было бы создано предыдущими версиями NumPy.</target>
        </trans-unit>
        <trans-unit id="81979ac862ad90b476e52b55f8477208f98b95b1" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#numpy.recarray.flags&quot;&gt;&lt;code&gt;flags&lt;/code&gt;&lt;/a&gt; object can be accessed dictionary-like (as in &lt;code&gt;a.flags['WRITEABLE']&lt;/code&gt;), or by using lowercased attribute names (as in &lt;code&gt;a.flags.writeable&lt;/code&gt;). Short flag names are only supported in dictionary access.</source>
          <target state="translated">&lt;a href=&quot;#numpy.recarray.flags&quot;&gt; &lt;code&gt;flags&lt;/code&gt; &lt;/a&gt; объект может быть доступен по словарю , как (как в &lt;code&gt;a.flags['WRITEABLE']&lt;/code&gt; ), или с помощью строчных имен атрибутов (как в &lt;code&gt;a.flags.writeable&lt;/code&gt; ). Короткие имена флагов поддерживаются только при доступе к словарю.</target>
        </trans-unit>
        <trans-unit id="84da36ced33272fa147152f5a355ea7313e10b52" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#numpy.sign&quot;&gt;&lt;code&gt;sign&lt;/code&gt;&lt;/a&gt; function returns &lt;code&gt;-1 if x &amp;lt; 0, 0 if x==0, 1 if x &amp;gt; 0&lt;/code&gt;. nan is returned for nan inputs.</source>
          <target state="translated">В &lt;a href=&quot;#numpy.sign&quot;&gt; &lt;code&gt;sign&lt;/code&gt; &lt;/a&gt; функция возвращает &lt;code&gt;-1 if x &amp;lt; 0, 0 if x==0, 1 if x &amp;gt; 0&lt;/code&gt; . nan возвращается для входов nan.</target>
        </trans-unit>
        <trans-unit id="c8f5bdf7e480a14edfbd94978da2fd35d2b6fd26" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#numpy.testing.decorators.deprecated&quot;&gt;&lt;code&gt;deprecated&lt;/code&gt;&lt;/a&gt; decorator itself.</source>
          <target state="translated">Сам &lt;a href=&quot;#numpy.testing.decorators.deprecated&quot;&gt; &lt;code&gt;deprecated&lt;/code&gt; &lt;/a&gt; декоратор.</target>
        </trans-unit>
        <trans-unit id="f00c158e6b19c749648df9ba6c6e65d03c7d496b" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#numpy.vectorize&quot;&gt;&lt;code&gt;vectorize&lt;/code&gt;&lt;/a&gt; function is provided primarily for convenience, not for performance. The implementation is essentially a for loop.</source>
          <target state="translated">Функция &lt;a href=&quot;#numpy.vectorize&quot;&gt; &lt;code&gt;vectorize&lt;/code&gt; &lt;/a&gt; предназначена в первую очередь для удобства, а не для повышения производительности. Реализация по сути представляет собой цикл for.</target>
        </trans-unit>
        <trans-unit id="5870961c86339efdff46c3532a51705af2f592f0" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;../arrays.datetime#arrays-dtypes-dateunits&quot;&gt;datetime unit&lt;/a&gt; on which this dtype is based.</source>
          <target state="translated">&lt;a href=&quot;../arrays.datetime#arrays-dtypes-dateunits&quot;&gt;DateTime модуль&lt;/a&gt; , на котором основан этот DTYPE.</target>
        </trans-unit>
        <trans-unit id="a98bd2e9d383259ba90aad2f3b46a4c0ddbbec99" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;../routines.testing#module-numpy.testing&quot;&gt;&lt;code&gt;numpy.testing&lt;/code&gt;&lt;/a&gt; module includes &lt;code&gt;import decorators as dec&lt;/code&gt;. A test can be decorated as slow like this:</source>
          <target state="translated">Модуль &lt;a href=&quot;../routines.testing#module-numpy.testing&quot;&gt; &lt;code&gt;numpy.testing&lt;/code&gt; &lt;/a&gt; включает &lt;code&gt;import decorators as dec&lt;/code&gt; . Тест можно оформить так медленно:</target>
        </trans-unit>
        <trans-unit id="c4d94d478ef39d11efc586cafc38818b04af19cb" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c-api.array#c.PyArray_Broadcast&quot;&gt;&lt;code&gt;PyArray_Broadcast&lt;/code&gt;&lt;/a&gt; function takes the iterators that have already been defined and uses them to determine the broadcast shape in each dimension (to create the iterators at the same time that broadcasting occurs then use the &lt;code&gt;PyMultiIter_New&lt;/code&gt; function). Then, the iterators are adjusted so that each iterator thinks it is iterating over an array with the broadcast size. This is done by adjusting the iterators number of dimensions, and the shape in each dimension. This works because the iterator strides are also adjusted. Broadcasting only adjusts (or adds) length-1 dimensions. For these dimensions, the strides variable is simply set to 0 so that the data-pointer for the iterator over that array doesn&amp;rsquo;t move as the broadcasting operation operates over the extended dimension.</source>
          <target state="translated">Функция &lt;a href=&quot;c-api.array#c.PyArray_Broadcast&quot;&gt; &lt;code&gt;PyArray_Broadcast&lt;/code&gt; &lt;/a&gt; принимает итераторы, которые уже были определены, и использует их для определения формы широковещательной передачи в каждом измерении (для создания итераторов одновременно с широковещательной передачей используйте функцию &lt;code&gt;PyMultiIter_New&lt;/code&gt; ). Затем итераторы настраиваются таким образом, чтобы каждый итератор считал, что выполняет итерацию по массиву с широковещательным размером. Это делается путем настройки количества измерений итераторов и формы в каждом измерении. Это работает, потому что шаги итератора также регулируются. Трансляция только корректирует (или добавляет) размерность длины 1. Для этих измерений переменная strides просто устанавливается в 0, чтобы указатель данных для итератора по этому массиву не перемещался, когда операция широковещательной передачи работает в расширенном измерении.</target>
        </trans-unit>
        <trans-unit id="d36f842f2997c8193b726b30df3debd673ecb729" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;constants#numpy.newaxis&quot;&gt;&lt;code&gt;newaxis&lt;/code&gt;&lt;/a&gt; object can be used in all slicing operations to create an axis of length one. &lt;a href=&quot;constants#numpy.newaxis&quot;&gt;&lt;code&gt;newaxis&lt;/code&gt;&lt;/a&gt; is an alias for &amp;lsquo;None&amp;rsquo;, and &amp;lsquo;None&amp;rsquo; can be used in place of this with the same result.</source>
          <target state="translated">Объект &lt;a href=&quot;constants#numpy.newaxis&quot;&gt; &lt;code&gt;newaxis&lt;/code&gt; &lt;/a&gt; можно использовать во всех операциях нарезки для создания оси длины один. &lt;a href=&quot;constants#numpy.newaxis&quot;&gt; &lt;code&gt;newaxis&lt;/code&gt; &lt;/a&gt; - это псевдоним для &amp;laquo;None&amp;raquo;, и &amp;laquo;None&amp;raquo; может использоваться вместо этого с тем же результатом.</target>
        </trans-unit>
        <trans-unit id="149f4058a1754093961b02f9ea6b9d5dd9c10925" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;generated/numpy.chararray#numpy.chararray&quot;&gt;&lt;code&gt;chararray&lt;/code&gt;&lt;/a&gt; class exists for backwards compatibility with Numarray, it is not recommended for new development. Starting from numpy 1.4, if one needs arrays of strings, it is recommended to use arrays of &lt;a href=&quot;generated/numpy.dtype#numpy.dtype&quot;&gt;&lt;code&gt;dtype&lt;/code&gt;&lt;/a&gt;&lt;code&gt;object_&lt;/code&gt;, &lt;code&gt;string_&lt;/code&gt; or &lt;code&gt;unicode_&lt;/code&gt;, and use the free functions in the &lt;a href=&quot;routines.char#module-numpy.char&quot;&gt;&lt;code&gt;numpy.char&lt;/code&gt;&lt;/a&gt; module for fast vectorized string operations.</source>
          <target state="translated">Класс &lt;a href=&quot;generated/numpy.chararray#numpy.chararray&quot;&gt; &lt;code&gt;chararray&lt;/code&gt; &lt;/a&gt; существует для обратной совместимости с Numarray, он не рекомендуется для новых разработок. Начиная с numpy 1.4, если нужны массивы строк, рекомендуется использовать массивы &lt;a href=&quot;generated/numpy.dtype#numpy.dtype&quot;&gt; &lt;code&gt;dtype&lt;/code&gt; &lt;/a&gt; &lt;code&gt;object_&lt;/code&gt; , &lt;code&gt;string_&lt;/code&gt; или &lt;code&gt;unicode_&lt;/code&gt; , а также использовать бесплатные функции в модуле &lt;a href=&quot;routines.char#module-numpy.char&quot;&gt; &lt;code&gt;numpy.char&lt;/code&gt; &lt;/a&gt; для быстрых векторизованных строковых операций.</target>
        </trans-unit>
        <trans-unit id="f9537bf435fae2ec4edc2520b8aeb23abd0ca21e" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;generated/numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;ndarray&lt;/code&gt;&lt;/a&gt; can be inherited from (in Python or in C) if desired. Therefore, it can form a foundation for many useful classes. Often whether to sub-class the array object or to simply use the core array component as an internal part of a new class is a difficult decision, and can be simply a matter of choice. NumPy has several tools for simplifying how your new object interacts with other array objects, and so the choice may not be significant in the end. One way to simplify the question is by asking yourself if the object you are interested in can be replaced as a single array or does it really require two or more arrays at its core.</source>
          <target state="translated">При &lt;a href=&quot;generated/numpy.ndarray#numpy.ndarray&quot;&gt; &lt;code&gt;ndarray&lt;/code&gt; &lt;/a&gt; может быть унаследован от (в Python или C). Следовательно, он может стать основой для многих полезных классов. Часто вопрос о том, следует ли подклассифицировать объект массива или просто использовать основной компонент массива как внутреннюю часть нового класса, является трудным решением и может быть просто вопросом выбора. В NumPy есть несколько инструментов для упрощения взаимодействия вашего нового объекта с другими объектами массива, поэтому в конечном итоге выбор может быть несущественным. Один из способов упростить вопрос - спросить себя, можно ли заменить интересующий вас объект как единый массив или действительно ли для этого требуется два или более массивов в своей основе.</target>
        </trans-unit>
        <trans-unit id="c0cd171dc2a149543f352698d4bc596e7f8afac8" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;generated/numpy.nditer#numpy.nditer&quot;&gt;&lt;code&gt;nditer&lt;/code&gt;&lt;/a&gt; will try to provide chunks that are as large as possible to the inner loop. By forcing &amp;lsquo;C&amp;rsquo; and &amp;lsquo;F&amp;rsquo; order, we get different external loop sizes. This mode is enabled by specifying an iterator flag.</source>
          <target state="translated">&lt;a href=&quot;generated/numpy.nditer#numpy.nditer&quot;&gt; &lt;code&gt;nditer&lt;/code&gt; &lt;/a&gt; будет пытаться обеспечить куски, которые как можно больше , чтобы внутренний цикл. Установив порядок &amp;laquo;C&amp;raquo; и &amp;laquo;F&amp;raquo;, мы получаем разные размеры внешних петель. Этот режим включается указанием флага итератора.</target>
        </trans-unit>
        <trans-unit id="f0287b2a9be936e86bf33e5d1e69557ad4042b14" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;generator#numpy.random.Generator&quot;&gt;&lt;code&gt;Generator&lt;/code&gt;&lt;/a&gt; is the user-facing object that is nearly identical to &lt;a href=&quot;legacy#numpy.random.mtrand.RandomState&quot;&gt;&lt;code&gt;RandomState&lt;/code&gt;&lt;/a&gt;. The canonical method to initialize a generator passes a &lt;a href=&quot;bit_generators/pcg64#numpy.random.pcg64.PCG64&quot;&gt;&lt;code&gt;PCG64&lt;/code&gt;&lt;/a&gt; bit generator as the sole argument.</source>
          <target state="translated">&lt;a href=&quot;generator#numpy.random.Generator&quot;&gt; &lt;code&gt;Generator&lt;/code&gt; &lt;/a&gt; является пользователем перед объектом , который почти идентичен &lt;a href=&quot;legacy#numpy.random.mtrand.RandomState&quot;&gt; &lt;code&gt;RandomState&lt;/code&gt; &lt;/a&gt; . Канонический метод инициализации генератора передает битовый генератор &lt;a href=&quot;bit_generators/pcg64#numpy.random.pcg64.PCG64&quot;&gt; &lt;code&gt;PCG64&lt;/code&gt; &lt;/a&gt; в качестве единственного аргумента.</target>
        </trans-unit>
        <trans-unit id="a44536d85a990a438123d796af5725162190334f" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;generator#numpy.random.Generator&quot;&gt;&lt;code&gt;random generator&lt;/code&gt;&lt;/a&gt; takes the bit generator-provided stream and transforms them into more useful distributions, e.g., simulated normal random values. This structure allows alternative bit generators to be used with little code duplication.</source>
          <target state="translated">&lt;a href=&quot;generator#numpy.random.Generator&quot;&gt; &lt;code&gt;random generator&lt;/code&gt; &lt;/a&gt; принимает поток разр дного генератора, при условии , и преобразует их в более полезные распределения, например, моделируемых нормальные случайные величины. Эта структура позволяет использовать альтернативные битовые генераторы с небольшим дублированием кода.</target>
        </trans-unit>
        <trans-unit id="f7f755efceb36d8200d20dc31c04e76cd3c9faf2" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;http://www.swig.org&quot;&gt;SWIG&lt;/a&gt; type checking and conversion system is a complicated combination of C macros, &lt;a href=&quot;http://www.swig.org&quot;&gt;SWIG&lt;/a&gt; macros, &lt;a href=&quot;http://www.swig.org&quot;&gt;SWIG&lt;/a&gt; typemaps and &lt;a href=&quot;http://www.swig.org&quot;&gt;SWIG&lt;/a&gt; fragments. Fragments are a way to conditionally insert code into your wrapper file if it is needed, and not insert it if not needed. If multiple typemaps require the same fragment, the fragment only gets inserted into your wrapper code once.</source>
          <target state="translated">&lt;a href=&quot;http://www.swig.org&quot;&gt;ГЛОТОК&lt;/a&gt; проверки типа и преобразования система представляет собой сложное сочетание макросов C, &lt;a href=&quot;http://www.swig.org&quot;&gt;Swig&lt;/a&gt; макросов, &lt;a href=&quot;http://www.swig.org&quot;&gt;Swig&lt;/a&gt; typemaps и &lt;a href=&quot;http://www.swig.org&quot;&gt;Swig&lt;/a&gt; фрагментов. Фрагменты - это способ условно вставить код в файл-оболочку, если он необходим, и не вставлять его, если он не нужен. Если для нескольких карт типов требуется один и тот же фрагмент, этот фрагмент вставляется в код оболочки только один раз.</target>
        </trans-unit>
        <trans-unit id="1a20426fc7bb4d929b1ae303283b379020fbc254" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;numpy.polynomial.polynomial.polynomial.fit#numpy.polynomial.polynomial.Polynomial.fit&quot;&gt;&lt;code&gt;Polynomial.fit&lt;/code&gt;&lt;/a&gt; class method is recommended for new code as it is more stable numerically. See the documentation of the method for more information.</source>
          <target state="translated">Для нового кода рекомендуется использовать метод класса &lt;a href=&quot;numpy.polynomial.polynomial.polynomial.fit#numpy.polynomial.polynomial.Polynomial.fit&quot;&gt; &lt;code&gt;Polynomial.fit&lt;/code&gt; ,&lt;/a&gt; поскольку он более стабилен численно. Дополнительную информацию см. В документации по методу.</target>
        </trans-unit>
        <trans-unit id="1ea1937064d555fd6f04fc2b57ae9e905ce9bf17" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;.npy&lt;/code&gt; format is the standard binary file format in NumPy for persisting a &lt;em&gt;single&lt;/em&gt; arbitrary NumPy array on disk. The format stores all of the shape and dtype information necessary to reconstruct the array correctly even on another machine with a different architecture. The format is designed to be as simple as possible while achieving its limited goals.</source>
          <target state="translated">Формат &lt;code&gt;.npy&lt;/code&gt; - это стандартный двоичный формат файла в NumPy для сохранения &lt;em&gt;одного&lt;/em&gt; произвольного массива NumPy на диске. Формат хранит всю информацию о форме и типе данных, необходимую для правильного восстановления массива даже на другом компьютере с другой архитектурой. Формат разработан так, чтобы быть максимально простым, но при этом достигать своих ограниченных целей.</target>
        </trans-unit>
        <trans-unit id="d25fde9120bc920bdf839700f32d6b700adf8720" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;.npy&lt;/code&gt; format, including motivation for creating it and a comparison of alternatives, is described in the &lt;a href=&quot;https://www.numpy.org/neps/nep-0001-npy-format.html&quot;&gt;&amp;ldquo;npy-format&amp;rdquo; NEP&lt;/a&gt;, however details have evolved with time and this document is more current.</source>
          <target state="translated">Формат &lt;code&gt;.npy&lt;/code&gt; , включая мотивацию для его создания и сравнение альтернатив, описан в &lt;a href=&quot;https://www.numpy.org/neps/nep-0001-npy-format.html&quot;&gt;&amp;laquo;npy-формате&amp;raquo; NEP&lt;/a&gt; , однако со временем детали изменились, и этот документ является более современным.</target>
        </trans-unit>
        <trans-unit id="22e53f126c53ee44cfae93fe323456796e3a7525" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;.npz&lt;/code&gt; file format is a zipped archive of files named after the variables they contain. The archive is compressed with &lt;code&gt;zipfile.ZIP_DEFLATED&lt;/code&gt; and each file in the archive contains one variable in &lt;code&gt;.npy&lt;/code&gt; format. For a description of the &lt;code&gt;.npy&lt;/code&gt; format, see &lt;a href=&quot;numpy.lib.format#module-numpy.lib.format&quot;&gt;&lt;code&gt;numpy.lib.format&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;.npz&lt;/code&gt; формат файла является Молнии архив файлов с именем после того, как переменные , которые они содержат. Архив сжимается с помощью &lt;code&gt;zipfile.ZIP_DEFLATED&lt;/code&gt; , и каждый файл в архиве содержит одну переменную в формате &lt;code&gt;.npy&lt;/code&gt; . Для описания &lt;code&gt;.npy&lt;/code&gt; формата см &lt;a href=&quot;numpy.lib.format#module-numpy.lib.format&quot;&gt; &lt;code&gt;numpy.lib.format&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="6b51e4d01309ff5a759f392af08bb39d1e99043e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;.npz&lt;/code&gt; file format is a zipped archive of files named after the variables they contain. The archive is not compressed and each file in the archive contains one variable in &lt;code&gt;.npy&lt;/code&gt; format. For a description of the &lt;code&gt;.npy&lt;/code&gt; format, see &lt;a href=&quot;numpy.lib.format#module-numpy.lib.format&quot;&gt;&lt;code&gt;numpy.lib.format&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;.npz&lt;/code&gt; формат файла является Молнии архив файлов с именем после того, как переменные , которые они содержат. Архив не сжимается, и каждый файл в архиве содержит одну переменную в формате &lt;code&gt;.npy&lt;/code&gt; . Для описания &lt;code&gt;.npy&lt;/code&gt; формата см &lt;a href=&quot;numpy.lib.format#module-numpy.lib.format&quot;&gt; &lt;code&gt;numpy.lib.format&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="a5c00dd2aa73f26e18024a200e3875179deacef9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;.npz&lt;/code&gt; format is the standard format for persisting &lt;em&gt;multiple&lt;/em&gt; NumPy arrays on disk. A &lt;code&gt;.npz&lt;/code&gt; file is a zip file containing multiple &lt;code&gt;.npy&lt;/code&gt; files, one for each array.</source>
          <target state="translated">Формат &lt;code&gt;.npz&lt;/code&gt; - это стандартный формат для хранения &lt;em&gt;нескольких&lt;/em&gt; массивов NumPy на диске. &lt;code&gt;.npz&lt;/code&gt; файл почтовый файл , содержащий несколько &lt;code&gt;.npy&lt;/code&gt; файлов, по одному для каждого массива.</target>
        </trans-unit>
        <trans-unit id="19658579206ac4f8753c064c0302ad76f2f72a46" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ALIGNED&lt;/code&gt; flag of an ndarray, computed in &lt;code&gt;IsAligned&lt;/code&gt; and checked by &lt;code&gt;PyArray_ISALIGNED&lt;/code&gt;. This is computed from &lt;code&gt;dtype.alignment&lt;/code&gt;. It is set to &lt;code&gt;True&lt;/code&gt; if every item in the array is at a memory location consistent with &lt;code&gt;dtype.alignment&lt;/code&gt;, which is the case if the data ptr and all strides of the array are multiples of that alignment.</source>
          <target state="translated">&lt;code&gt;ALIGNED&lt;/code&gt; флаг из ndarray, вычисленный в &lt;code&gt;IsAligned&lt;/code&gt; и проверяются &lt;code&gt;PyArray_ISALIGNED&lt;/code&gt; . Это вычисляется из &lt;code&gt;dtype.alignment&lt;/code&gt; . Для него установлено значение &lt;code&gt;True&lt;/code&gt; , если каждый элемент в массиве находится в ячейке памяти, согласованной с &lt;code&gt;dtype.alignment&lt;/code&gt; , что имеет место, если ptr данных и все шаги массива кратны этому выравниванию.</target>
        </trans-unit>
        <trans-unit id="85388f353d8827d53025cb4498ec7c4f7175db9d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;BitGenerator&lt;/code&gt; has a limited set of responsibilities. It manages state and provides functions to produce random doubles and random unsigned 32- and 64-bit values.</source>
          <target state="translated">&lt;code&gt;BitGenerator&lt;/code&gt; имеет ограниченный набор функций. Он управляет состоянием и предоставляет функции для создания случайных чисел двойной точности и случайных 32- и 64-битных значений без знака.</target>
        </trans-unit>
        <trans-unit id="29642d4a46e1b1f330f5d899a27d8931b3675855" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Configuration&lt;/code&gt; constructor has a fourth optional argument, &lt;code&gt;package_path&lt;/code&gt;, that can be used when package files are located in a different location than the directory of the &lt;code&gt;setup.py&lt;/code&gt; file.</source>
          <target state="translated">У конструктора &lt;code&gt;Configuration&lt;/code&gt; есть четвертый необязательный аргумент, &lt;code&gt;package_path&lt;/code&gt; , который можно использовать, когда файлы пакета расположены в другом месте, чем каталог файла &lt;code&gt;setup.py&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d942d62411c592ee85272583cee21a0d612eb9cd" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;MT19937&lt;/code&gt; state vector consists of a 624-element array of 32-bit unsigned integers plus a single integer value between 0 and 624 that indexes the current position within the main array.</source>
          <target state="translated">&lt;code&gt;MT19937&lt;/code&gt; вектор состояния состоит из 624-элемента массива в 32-битных целых чисел без знака плюс одно целое число от 0 до 624 , что индексы текущее положение внутри основного массива.</target>
        </trans-unit>
        <trans-unit id="a95fd45cabac9b94aa97772f024779835dc306b4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Makefile&lt;/code&gt; calls &lt;code&gt;swig&lt;/code&gt; to generate &lt;code&gt;Vector.py&lt;/code&gt; and &lt;code&gt;Vector_wrap.cxx&lt;/code&gt;, and also executes the &lt;code&gt;setup.py&lt;/code&gt; script that compiles &lt;code&gt;Vector_wrap.cxx&lt;/code&gt; and links together the extension module &lt;code&gt;_Vector.so&lt;/code&gt; or &lt;code&gt;_Vector.dylib&lt;/code&gt;, depending on the platform. This extension module and the proxy file &lt;code&gt;Vector.py&lt;/code&gt; are both placed in a subdirectory under the &lt;code&gt;build&lt;/code&gt; directory.</source>
          <target state="translated">В &lt;code&gt;Makefile&lt;/code&gt; звонки &lt;code&gt;swig&lt;/code&gt; генерировать &lt;code&gt;Vector.py&lt;/code&gt; и &lt;code&gt;Vector_wrap.cxx&lt;/code&gt; , а также выполняет &lt;code&gt;setup.py&lt;/code&gt; скрипт , который компилирует &lt;code&gt;Vector_wrap.cxx&lt;/code&gt; и ссылки вместе модуля расширения &lt;code&gt;_Vector.so&lt;/code&gt; или &lt;code&gt;_Vector.dylib&lt;/code&gt; , в зависимости от платформы. Этот модуль расширения и прокси-файл &lt;code&gt;Vector.py&lt;/code&gt; помещаются в подкаталог в каталоге &lt;code&gt;build&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a509290375510505b589158f3b8f2b07b506f6b0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;MaskedArray&lt;/code&gt; class</source>
          <target state="translated">&lt;code&gt;MaskedArray&lt;/code&gt; класс</target>
        </trans-unit>
        <trans-unit id="b55e755e6d26d2135c464a8b79f8ff9c154dcada" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;NPY_SIZEOF_{CTYPE}&lt;/code&gt; constants are defined so that sizeof information is available to the pre-processor.</source>
          <target state="translated">Константы &lt;code&gt;NPY_SIZEOF_{CTYPE}&lt;/code&gt; определены так, чтобы информация о размере была доступна препроцессору.</target>
        </trans-unit>
        <trans-unit id="d918fc830e6f124f45ecb19bab96030d1a7583a5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;PCG64&lt;/code&gt; state vector consists of 2 unsigned 128-bit values, which are represented externally as Python ints. One is the state of the PRNG, which is advanced by a linear congruential generator (LCG). The second is a fixed odd increment used in the LCG.</source>
          <target state="translated">&lt;code&gt;PCG64&lt;/code&gt; вектор состояния состоит из 2 -х без знака 128-битовых значений, которые представлены в виде целых чисел извне Python. Один из них - это состояние ГПСЧ, которое продвигается линейным конгруэнтным генератором (LCG). Второй - это фиксированное приращение нечетности, используемое в LCG.</target>
        </trans-unit>
        <trans-unit id="c1a90ac63bb863a062bb153b73df1e64c4857aff" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Philox&lt;/code&gt; state vector consists of a 256-bit value encoded as a 4-element uint64 array and a 128-bit value encoded as a 2-element uint64 array. The former is a counter which is incremented by 1 for every 4 64-bit randoms produced. The second is a key which determined the sequence produced. Using different keys produces independent sequences.</source>
          <target state="translated">&lt;code&gt;Philox&lt;/code&gt; вектор состояния состоит из 256-битового значения , закодированного как массив UInt64 4-элементной и 128-битное значение , кодируется как массив UInt64 2-элемента. Первый - это счетчик, который увеличивается на 1 для каждых 4 произведенных 64-битных случайных чисел. Второй - это ключ, определяющий производимую последовательность. Использование разных ключей дает независимые последовательности.</target>
        </trans-unit>
        <trans-unit id="4d1f94165781d8145f1fd80c467f6bd0f760f0b8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;SFC64&lt;/code&gt; state vector consists of 4 unsigned 64-bit values. The last is a 64-bit counter that increments by 1 each iteration.</source>
          <target state="translated">&lt;code&gt;SFC64&lt;/code&gt; вектор состояния состоит из 4 беззнаковых 64-битовых значений. Последний - это 64-битный счетчик, который увеличивается на 1 каждую итерацию.</target>
        </trans-unit>
        <trans-unit id="395b8858a352467f67b6a09c4a5fc424e26cfad2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;__init__.py&lt;/code&gt; file</source>
          <target state="translated">&lt;code&gt;__init__.py&lt;/code&gt; файл</target>
        </trans-unit>
        <trans-unit id="55e0b71eae2cfd6e566258a88d10c513a1a5a113" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;align&lt;/code&gt; keyword of the dtype constructor, which only affects structured arrays. If the structure&amp;rsquo;s field offsets are not manually provided numpy determines offsets automatically. In that case, &lt;code&gt;align=True&lt;/code&gt; pads the structure so that each field is &amp;ldquo;true&amp;rdquo; aligned in memory and sets &lt;code&gt;dtype.alignment&lt;/code&gt; to be the largest of the field &amp;ldquo;true&amp;rdquo; alignments. This is like what C-structs usually do. Otherwise if offsets or itemsize were manually provided &lt;code&gt;align=True&lt;/code&gt; simply checks that all the fields are &amp;ldquo;true&amp;rdquo; aligned and that the total itemsize is a multiple of the largest field alignment. In either case &lt;code&gt;dtype.isalignedstruct&lt;/code&gt; is also set to True.</source>
          <target state="translated">&lt;code&gt;align&lt;/code&gt; ключевых слов конструктора DTYPE, который влияет только на структурированные массивы. Если смещения полей структуры не указаны вручную, numpy определяет смещения автоматически. В этом случае &lt;code&gt;align=True&lt;/code&gt; дополняет структуру так, чтобы каждое поле было &amp;laquo;истинным&amp;raquo; выровненным в памяти, и устанавливает &lt;code&gt;dtype.alignment&lt;/code&gt; как наибольшее из &amp;laquo;истинных&amp;raquo; выравниваний поля. Это похоже на то, что обычно делают C-структуры. В противном случае, если смещения или размер элементов были предоставлены вручную, &lt;code&gt;align=True&lt;/code&gt; просто проверяет, что все поля выровнены &amp;laquo;истинно&amp;raquo; и что общий размер элементов является кратным максимальному выравниванию поля. В любом случае &lt;code&gt;dtype.isalignedstruct&lt;/code&gt; также имеет значение True.</target>
        </trans-unit>
        <trans-unit id="dd27c9fa716237737a1b850fd84a88e9e84db97b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;as&lt;/code&gt;-clause of the &lt;code&gt;with&lt;/code&gt;-statement gives the current print options:</source>
          <target state="translated">Предложение &lt;code&gt;as&lt;/code&gt; в выражении &lt;code&gt;with&lt;/code&gt; дает текущие параметры печати:</target>
        </trans-unit>
        <trans-unit id="caa858c948295450c18bcef4c572e68d7eda67a9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;axis&lt;/code&gt; keyword can be used to specify a subset of axes of which the gradient is calculated</source>
          <target state="translated">&lt;code&gt;axis&lt;/code&gt; ключевое слово может быть использовано , чтобы указать подмножество осей которых вычисляется градиент</target>
        </trans-unit>
        <trans-unit id="c68a2d64e2aeed4fdf4077c45259bb4b7c07822e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;axis&lt;/code&gt; parameter specifies the index of the new axis in the dimensions of the result. For example, if &lt;code&gt;axis=0&lt;/code&gt; it will be the first dimension and if &lt;code&gt;axis=-1&lt;/code&gt; it will be the last dimension.</source>
          <target state="translated">Параметр &lt;code&gt;axis&lt;/code&gt; указывает индекс новой оси в измерениях результата. Например, если &lt;code&gt;axis=0&lt;/code&gt; это будет первое измерение, а если &lt;code&gt;axis=-1&lt;/code&gt; это будет последнее измерение.</target>
        </trans-unit>
        <trans-unit id="7d4cb66724d02c13ff5f50a065c67d6d75a20a6a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;bool_&lt;/code&gt; data type is very similar to the Python &lt;code&gt;BooleanType&lt;/code&gt; but does not inherit from it because Python&amp;rsquo;s &lt;code&gt;BooleanType&lt;/code&gt; does not allow itself to be inherited from, and on the C-level the size of the actual bool data is not the same as a Python Boolean scalar.</source>
          <target state="translated">&lt;code&gt;bool_&lt;/code&gt; тип данных очень похож на Python &lt;code&gt;BooleanType&lt;/code&gt; , но не наследует от него , потому что в Python &lt;code&gt;BooleanType&lt;/code&gt; не позволяет себе быть унаследованы от, а на C-уровне размер фактических данных BOOL не то же самое , как Python Boolean скаляр.</target>
        </trans-unit>
        <trans-unit id="1a9ec4df6ec3fb7357baf90864b29d969f59440a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;bool_&lt;/code&gt; type is not a subclass of the &lt;code&gt;int_&lt;/code&gt; type (the &lt;code&gt;bool_&lt;/code&gt; is not even a number type). This is different than Python&amp;rsquo;s default implementation of &lt;a href=&quot;https://docs.python.org/dev/library/functions.html#bool&quot;&gt;&lt;code&gt;bool&lt;/code&gt;&lt;/a&gt; as a sub-class of int.</source>
          <target state="translated">Тип &lt;code&gt;bool_&lt;/code&gt; не является подклассом типа &lt;code&gt;int_&lt;/code&gt; ( &lt;code&gt;bool_&lt;/code&gt; даже не является числовым типом). Это отличается от реализации Python по умолчанию для &lt;a href=&quot;https://docs.python.org/dev/library/functions.html#bool&quot;&gt; &lt;code&gt;bool&lt;/code&gt; &lt;/a&gt; как подкласса int.</target>
        </trans-unit>
        <trans-unit id="3f5c3b6d52d4becfb53cc5a7dd0ae6b04cdb9085" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;chars&lt;/code&gt; argument is a string specifying the set of characters to be removed. If omitted or None, the &lt;code&gt;chars&lt;/code&gt; argument defaults to removing whitespace. The &lt;code&gt;chars&lt;/code&gt; argument is not a prefix or suffix; rather, all combinations of its values are stripped.</source>
          <target state="translated">&lt;code&gt;chars&lt;/code&gt; аргументом является строка , определяющая набор символов , которые будут удалены. Если опущено или None, аргумент &lt;code&gt;chars&lt;/code&gt; по умолчанию удаляет пробелы. &lt;code&gt;chars&lt;/code&gt; аргумент не префикс или суффикс; скорее, удаляются все комбинации его значений.</target>
        </trans-unit>
        <trans-unit id="44ca716c299a61027880c154634feb6b89178fc1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;chars&lt;/code&gt; argument is a string specifying the set of characters to be removed. If omitted or None, the &lt;code&gt;chars&lt;/code&gt; argument defaults to removing whitespace. The &lt;code&gt;chars&lt;/code&gt; argument is not a prefix; rather, all combinations of its values are stripped.</source>
          <target state="translated">&lt;code&gt;chars&lt;/code&gt; аргументом является строка , определяющая набор символов , которые будут удалены. Если опущено или None, аргумент &lt;code&gt;chars&lt;/code&gt; по умолчанию удаляет пробелы. &lt;code&gt;chars&lt;/code&gt; аргумент не префикс; скорее, удаляются все комбинации его значений.</target>
        </trans-unit>
        <trans-unit id="3ab81d1fe754db2126af526470043294b9859fdc" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;chars&lt;/code&gt; argument is a string specifying the set of characters to be removed. If omitted or None, the &lt;code&gt;chars&lt;/code&gt; argument defaults to removing whitespace. The &lt;code&gt;chars&lt;/code&gt; argument is not a suffix; rather, all combinations of its values are stripped.</source>
          <target state="translated">&lt;code&gt;chars&lt;/code&gt; аргументом является строка , определяющая набор символов , которые будут удалены. Если опущено или None, аргумент &lt;code&gt;chars&lt;/code&gt; по умолчанию удаляет пробелы. &lt;code&gt;chars&lt;/code&gt; аргумент не суффикс; скорее, удаляются все комбинации его значений.</target>
        </trans-unit>
        <trans-unit id="c5f33c0fec12debe8698b9f3d00999bb3fb759ea" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;dtype.alignment&lt;/code&gt; attribute (&lt;code&gt;descr-&amp;gt;alignment&lt;/code&gt; in C). This is meant to reflect the &amp;ldquo;true alignment&amp;rdquo; of the type. It has arch-dependent default values for all datatypes, with the exception of structured types created with &lt;code&gt;align=True&lt;/code&gt; as described below.</source>
          <target state="translated">&lt;code&gt;dtype.alignment&lt;/code&gt; атрибут ( &lt;code&gt;descr-&amp;gt;alignment&lt;/code&gt; в C). Это сделано для того, чтобы отразить &amp;laquo;истинное соответствие&amp;raquo; типа. Он имеет зависящие от архитектуры значения по умолчанию для всех типов данных, за исключением структурированных типов, созданных с помощью &lt;code&gt;align=True&lt;/code&gt; , как описано ниже.</target>
        </trans-unit>
        <trans-unit id="4e0428300bbf21ef1b533ffa3e86adb5ceddd8dd" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;dtype&lt;/code&gt; parameter defines the underlying data type.</source>
          <target state="translated">Параметр &lt;code&gt;dtype&lt;/code&gt; определяет базовый тип данных.</target>
        </trans-unit>
        <trans-unit id="93f7d511e2846b265125fabe4d5030e15709832e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;excluded&lt;/code&gt; argument can be used to prevent vectorizing over certain arguments. This can be useful for array-like arguments of a fixed length such as the coefficients for a polynomial as in &lt;a href=&quot;numpy.polyval#numpy.polyval&quot;&gt;&lt;code&gt;polyval&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">&lt;code&gt;excluded&lt;/code&gt; аргумент может быть использован для предотвращения векторизации над определенными аргументами. Это может быть полезно для аргументов, подобных массиву, фиксированной длины, таких как коэффициенты для многочлена, как в &lt;a href=&quot;numpy.polyval#numpy.polyval&quot;&gt; &lt;code&gt;polyval&lt;/code&gt; &lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="2beff53e54fda1bd096a7e81c4708f352287d275" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;flags&lt;/code&gt; attribute of the &lt;code&gt;PyArrayObject&lt;/code&gt; structure contains important information about the memory used by the array (pointed to by the data member) This flag information must be kept accurate or strange results and even segfaults may result.</source>
          <target state="translated">&lt;code&gt;flags&lt;/code&gt; атрибут &lt;code&gt;PyArrayObject&lt;/code&gt; структуры содержит важную информацию о памяти , используемой в массиве ( на который указывает элементу данных) Этот флаг информации должны храниться точные или странные результаты и даже может привести возвращает ошибку сегментации.</target>
        </trans-unit>
        <trans-unit id="8b08d522b6b1cfd800cd6bda4d86b04d644f1baf" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;int_&lt;/code&gt; type does &lt;strong&gt;not&lt;/strong&gt; inherit from the &lt;a href=&quot;https://docs.python.org/dev/library/functions.html#int&quot;&gt;&lt;code&gt;int&lt;/code&gt;&lt;/a&gt; built-in under Python 3, because type &lt;a href=&quot;https://docs.python.org/dev/library/functions.html#int&quot;&gt;&lt;code&gt;int&lt;/code&gt;&lt;/a&gt; is no longer a fixed-width integer type.</source>
          <target state="translated">&lt;code&gt;int_&lt;/code&gt; типа не имеет &lt;strong&gt;не&lt;/strong&gt; наследует от &lt;a href=&quot;https://docs.python.org/dev/library/functions.html#int&quot;&gt; &lt;code&gt;int&lt;/code&gt; &lt;/a&gt; встроенного под Python 3, поскольку типа &lt;a href=&quot;https://docs.python.org/dev/library/functions.html#int&quot;&gt; &lt;code&gt;int&lt;/code&gt; &lt;/a&gt; больше не является фиксированной шириной целого типа.</target>
        </trans-unit>
        <trans-unit id="5032550323e57bc7dec27d8af2d8f9df18642750" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;itershape&lt;/code&gt; parameter allows you to force the iterator to have a specific iteration shape. It is an array of length &lt;code&gt;oa_ndim&lt;/code&gt;. When an entry is negative, its value is determined from the operands. This parameter allows automatically allocated outputs to get additional dimensions which don&amp;rsquo;t match up with any dimension of an input.</source>
          <target state="translated">Параметр &lt;code&gt;itershape&lt;/code&gt; позволяет заставить итератор иметь определенную форму итерации. Это массив длиной &lt;code&gt;oa_ndim&lt;/code&gt; . Когда запись отрицательная, ее значение определяется операндами. Этот параметр позволяет автоматически назначенным выходам получать дополнительные измерения, которые не совпадают ни с одним из измерений входа.</target>
        </trans-unit>
        <trans-unit id="d1b139e99319cf8723f8471165f727072e0de12d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;k&lt;/code&gt; different &amp;ldquo;columns&amp;rdquo; to be sorted. The last column (or row if &lt;code&gt;keys&lt;/code&gt; is a 2D array) is the primary sort key.</source>
          <target state="translated">В &lt;code&gt;k&lt;/code&gt; разным &amp;laquo;столбцам&amp;raquo; для сортировки. Последний столбец (или строка, если &lt;code&gt;keys&lt;/code&gt; - это 2D-массив) - это первичный ключ сортировки.</target>
        </trans-unit>
        <trans-unit id="ab61433b884d13cbf28918d009f77e172c843e81" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;n&lt;/code&gt; arrays of indices corresponding to the locations where &lt;code&gt;mask_func(np.ones((n, n)), k)&lt;/code&gt; is True.</source>
          <target state="translated">В &lt;code&gt;n&lt;/code&gt; массивы индексов , соответствующих местах , где &lt;code&gt;mask_func(np.ones((n, n)), k)&lt;/code&gt; истинно.</target>
        </trans-unit>
        <trans-unit id="68dcfe0b1fdf3a267f300958e2039277e48ae02c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;new_order&lt;/code&gt; code can be any from the following:</source>
          <target state="translated">Код &lt;code&gt;new_order&lt;/code&gt; может быть любым из следующих:</target>
        </trans-unit>
        <trans-unit id="8693a0f592844bcf9978c5fbaa78f4621036206e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;nonzero&lt;/code&gt; method of the condition array can also be called.</source>
          <target state="translated">Также может быть вызван &lt;code&gt;nonzero&lt;/code&gt; метод массива условий.</target>
        </trans-unit>
        <trans-unit id="d18c665ad6cff39ded6fc90bc8648963ab9ee138" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;numpy.i&lt;/code&gt; file contains several macros and routines that it uses internally to build its typemaps. However, these functions may be useful elsewhere in your interface file. These macros and routines are implemented as fragments, which are described briefly in the previous section. If you try to use one or more of the following macros or functions, but your compiler complains that it does not recognize the symbol, then you need to force these fragments to appear in your code using:</source>
          <target state="translated">&lt;code&gt;numpy.i&lt;/code&gt; файл содержит несколько макросов и процедур , которые он использует внутренне строить свои typemaps. Однако эти функции могут быть полезны в другом месте вашего интерфейсного файла. Эти макросы и подпрограммы реализованы в виде фрагментов, которые кратко описаны в предыдущем разделе. Если вы пытаетесь использовать один или несколько из следующих макросов или функций, но ваш компилятор жалуется, что он не распознает символ, вам нужно заставить эти фрагменты появиться в вашем коде, используя:</target>
        </trans-unit>
        <trans-unit id="9f4cb37fdc51e8b1f5c2b248e5fd15fdd94aa9b6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;numpy.i&lt;/code&gt; file is currently located in the &lt;code&gt;tools/swig&lt;/code&gt; sub-directory under the &lt;code&gt;numpy&lt;/code&gt; installation directory. Typically, you will want to copy it to the directory where you are developing your wrappers.</source>
          <target state="translated">&lt;code&gt;numpy.i&lt;/code&gt; файл в настоящее время находится в &lt;code&gt;tools/swig&lt;/code&gt; подкаталоге под &lt;code&gt;numpy&lt;/code&gt; каталога установки. Как правило, вам нужно скопировать его в каталог, в котором вы разрабатываете свои оболочки.</target>
        </trans-unit>
        <trans-unit id="96831ff16133b13c87cfe870992604959917c570" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;numpy.i&lt;/code&gt; interface file also provides additional tools for wrapper developers, including:</source>
          <target state="translated">&lt;code&gt;numpy.i&lt;/code&gt; файл интерфейс также предоставляет дополнительные инструменты для разработчиков оболочек, в том числе:</target>
        </trans-unit>
        <trans-unit id="d04832f55eba99f2bc4cc0dceb3d718f68b6cac8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;numpy.i&lt;/code&gt; interface file does not support typemaps for output arrays, for several reasons. First, C/C++ return arguments are limited to a single value. This prevents obtaining dimension information in a general way. Second, arrays with hard-coded lengths are not permitted as return arguments. In other words:</source>
          <target state="translated">&lt;code&gt;numpy.i&lt;/code&gt; файл интерфейс не поддерживает typemaps для вывода массивов, по нескольким причинам. Во-первых, возвращаемые аргументы C / C ++ ограничены одним значением. Это предотвращает получение информации о размерах в общем виде. Во-вторых, массивы с жестко заданной длиной не допускаются в качестве возвращаемых аргументов. Другими словами:</target>
        </trans-unit>
        <trans-unit id="65e8b572ae6dc55c16aea9abc0f0766e897fe055" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;numpy.i&lt;/code&gt; interface file uses the &lt;code&gt;%numpy_typemaps&lt;/code&gt; macro to implement typemaps for the following C data types and &lt;code&gt;int&lt;/code&gt; dimension types:</source>
          <target state="translated">В &lt;code&gt;numpy.i&lt;/code&gt; интерфейса &lt;code&gt;%numpy_typemaps&lt;/code&gt; макрос % numpy_typemaps используется для реализации карт типов для следующих типов данных C и типов измерений &lt;code&gt;int&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="d99e0e96fa984690444350c5bb3087380beb5586" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;numpy.ma&lt;/code&gt; module</source>
          <target state="translated">&lt;code&gt;numpy.ma&lt;/code&gt; модуль</target>
        </trans-unit>
        <trans-unit id="4c8ade543f0e1c46d97cf061c562c3116b9639d4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;order&lt;/code&gt; keyword gives the index ordering both for &lt;em&gt;fetching&lt;/em&gt; the values from &lt;code&gt;a&lt;/code&gt;, and then &lt;em&gt;placing&lt;/em&gt; the values into the output array. For example, let&amp;rsquo;s say you have an array:</source>
          <target state="translated">&lt;code&gt;order&lt;/code&gt; ключевых слов дает индекс заказа как для &lt;em&gt;извлечения&lt;/em&gt; значений из , а затем &lt;em&gt;помещая&lt;/em&gt; значения в выходной массив. Например, допустим, у вас есть массив: &lt;code&gt;a&lt;/code&gt; &lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="022ed8cd0b6cf9d8c83ca5b8b482f20886ea6324" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;series&lt;/code&gt; is expected to be an instance of some polynomial series of one of the types supported by by the numpy.polynomial module, but could be some other class that supports the convert method.</source>
          <target state="translated">Ожидается, что эта &lt;code&gt;series&lt;/code&gt; будет экземпляром некоторой полиномиальной серии одного из типов, поддерживаемых модулем numpy.polynomial, но может быть другим классом, поддерживающим метод convert.</target>
        </trans-unit>
        <trans-unit id="f4910f2b9024b32efada1e65d4c1134f65374f1c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;setup.py&lt;/code&gt; file</source>
          <target state="translated">&lt;code&gt;setup.py&lt;/code&gt; файл</target>
        </trans-unit>
        <trans-unit id="0948550106d7d72b97910c4e4918bcddbe3d6d6b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;signature&lt;/code&gt; argument allows for vectorizing functions that act on non-scalar arrays of fixed length. For example, you can use it for a vectorized calculation of Pearson correlation coefficient and its p-value:</source>
          <target state="translated">&lt;code&gt;signature&lt;/code&gt; аргумент позволяет векторизации функции , которые действуют на нескалярных массивы фиксированной длины. Например, вы можете использовать его для векторизованного расчета коэффициента корреляции Пирсона и его p-значения:</target>
        </trans-unit>
        <trans-unit id="19cc10b9b9bd6104c6aeb8b9be441a8dc8445028" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;state&lt;/code&gt; argument must be a sequence that contains the following elements:</source>
          <target state="translated">&lt;code&gt;state&lt;/code&gt; аргумент должен быть последовательность , которая содержит следующие элементы:</target>
        </trans-unit>
        <trans-unit id="28db18b99085783cc1cb19c430887ae4c1bd2dc8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;state&lt;/code&gt; tuple has the following items:</source>
          <target state="translated">&lt;code&gt;state&lt;/code&gt; кортеж имеет следующие элементы:</target>
        </trans-unit>
        <trans-unit id="0e4c35736a2eec986972a33d172a5be16d326f7c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;tp_as_number&lt;/code&gt; methods use a generic approach to call whatever function has been registered for handling the operation. When the &lt;code&gt;_multiarray_umath module&lt;/code&gt; is imported, it sets the numeric operations for all arrays to the corresponding ufuncs. This choice can be changed with &lt;a href=&quot;c-api.ufunc#c.PyUFunc_ReplaceLoopBySignature&quot;&gt;&lt;code&gt;PyUFunc_ReplaceLoopBySignature&lt;/code&gt;&lt;/a&gt; The &lt;code&gt;tp_str&lt;/code&gt; and &lt;code&gt;tp_repr&lt;/code&gt; methods can also be altered using &lt;a href=&quot;c-api.array#c.PyArray_SetStringFunction&quot;&gt;&lt;code&gt;PyArray_SetStringFunction&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">В &lt;code&gt;tp_as_number&lt;/code&gt; методы используют общий подход для вызова любой функции были зарегистрирован для обработки операции. Когда &lt;code&gt;_multiarray_umath module&lt;/code&gt; импортируется, он устанавливает числовые операции для всех массивов в соответствующие ufuncs. Этот выбор можно изменить с помощью &lt;a href=&quot;c-api.ufunc#c.PyUFunc_ReplaceLoopBySignature&quot;&gt; &lt;code&gt;PyUFunc_ReplaceLoopBySignature&lt;/code&gt; &lt;/a&gt; . &lt;code&gt;tp_str&lt;/code&gt; и &lt;code&gt;tp_repr&lt;/code&gt; также можно изменить с помощью &lt;a href=&quot;c-api.array#c.PyArray_SetStringFunction&quot;&gt; &lt;code&gt;PyArray_SetStringFunction&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="88a54cde186ec5ee99014b55275737fd8ded4abc" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;bounds&lt;/em&gt; argument is expected to be a (2 * iter-&amp;gt;ao-&amp;gt;nd) arrays, such as the range bound[2*i]-&amp;gt;bounds[2*i+1] defines the range where to walk for dimension i (both bounds are included in the walked coordinates). The bounds should be ordered for each dimension (bounds[2*i] &amp;lt;= bounds[2*i+1]).</source>
          <target state="translated">Ожидается, что аргумент &lt;em&gt;bounds&lt;/em&gt; будет массивом (2 * iter-&amp;gt; ao-&amp;gt; nd), например, range bound [2 * i] -&amp;gt; bounds [2 * i + 1] определяет диапазон, по которому нужно пройти для измерения i. (обе границы включены в пройденные координаты). Границы должны быть упорядочены для каждого измерения (bounds [2 * i] &amp;lt;= bounds [2 * i + 1]).</target>
        </trans-unit>
        <trans-unit id="ea1fe523a0552e237800f38d8997bfcb72c8d0f5" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;func&lt;/em&gt;, &lt;em&gt;data&lt;/em&gt;, &lt;em&gt;types&lt;/em&gt;, &lt;em&gt;name&lt;/em&gt;, and &lt;em&gt;doc&lt;/em&gt; arguments are not copied by &lt;a href=&quot;#c.PyUFunc_FromFuncAndData&quot;&gt;&lt;code&gt;PyUFunc_FromFuncAndData&lt;/code&gt;&lt;/a&gt;. The caller must ensure that the memory used by these arrays is not freed as long as the ufunc object is alive.</source>
          <target state="translated">В &lt;em&gt;функ&lt;/em&gt; , &lt;em&gt;данные&lt;/em&gt; , &lt;em&gt;типы&lt;/em&gt; , &lt;em&gt;имя&lt;/em&gt; и &lt;em&gt;Дока&lt;/em&gt; аргументы не копируются &lt;a href=&quot;#c.PyUFunc_FromFuncAndData&quot;&gt; &lt;code&gt;PyUFunc_FromFuncAndData&lt;/code&gt; &lt;/a&gt; . Вызывающий должен гарантировать, что память, используемая этими массивами, не освобождена, пока жив объект ufunc.</target>
        </trans-unit>
        <trans-unit id="20c9d63d4d93167ef641a021fb26c115a182b092" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;itemsize&lt;/em&gt; key allows the total size of the dtype to be set, and must be an integer large enough so all the fields are within the dtype. If the dtype being constructed is aligned, the &lt;em&gt;itemsize&lt;/em&gt; must also be divisible by the struct alignment. Total dtype &lt;em&gt;itemsize&lt;/em&gt; is limited to &lt;a href=&quot;https://docs.python.org/dev/library/ctypes.html#ctypes.c_int&quot;&gt;&lt;code&gt;ctypes.c_int&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;em&gt;Itemsize&lt;/em&gt; ключ позволяет общий размер DTYPE быть множество, и должно быть целым числом достаточно большим , так что все поля находятся в пределах DTYPE. Если конструируемый dtype выровнен, &lt;em&gt;размер элемента&lt;/em&gt; также должен делиться на выравнивание структуры. Общий размер элементов &lt;em&gt;dtype&lt;/em&gt; ограничен &lt;a href=&quot;https://docs.python.org/dev/library/ctypes.html#ctypes.c_int&quot;&gt; &lt;code&gt;ctypes.c_int&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="2ed9f0881461d81b2f7af8ce5229589ca6d28abd" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;n&lt;/em&gt;-dimensional FFT of real input.</source>
          <target state="translated">&lt;em&gt;П&lt;/em&gt; - мерный FFT реального ввода.</target>
        </trans-unit>
        <trans-unit id="35066a9f7cb50260dfe6cd2d771163f62f1011ce" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;n&lt;/em&gt;-dimensional FFT.</source>
          <target state="translated">&lt;em&gt;П&lt;/em&gt; - мерный FFT.</target>
        </trans-unit>
        <trans-unit id="1f82e353fb8bee88c46f056efaf0e1b9b205e05a" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;out&lt;/em&gt; argument to &lt;a href=&quot;numpy.power#numpy.power&quot;&gt;&lt;code&gt;numpy.power&lt;/code&gt;&lt;/a&gt; is not supported, &lt;code&gt;third&lt;/code&gt; has to be None.</source>
          <target state="translated">&lt;em&gt;Из&lt;/em&gt; аргумента &lt;a href=&quot;numpy.power#numpy.power&quot;&gt; &lt;code&gt;numpy.power&lt;/code&gt; &lt;/a&gt; не поддерживается, &lt;code&gt;third&lt;/code&gt; имеют не должна быть ни один.</target>
        </trans-unit>
        <trans-unit id="17d0c90784f11b0394d45b1939c2a01c10fdf407" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;shape&lt;/em&gt; is the fixed shape of the sub-array described by this data type, and &lt;em&gt;item_dtype&lt;/em&gt; the data type of the array.</source>
          <target state="translated">&lt;em&gt;Форма&lt;/em&gt; представляет собой фиксированную форму суб-массива , описанного этим типом данных, и &lt;em&gt;item_dtype&lt;/em&gt; тип данных массива.</target>
        </trans-unit>
        <trans-unit id="e35e90d2e4f0ba849a49c1795babe3ab2a9f08fe" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;side&lt;/em&gt; argument indicates whether the index returned should be that of the first suitable location (if &lt;code&gt;NPY_SEARCHLEFT&lt;/code&gt;) or of the last (if &lt;code&gt;NPY_SEARCHRIGHT&lt;/code&gt;).</source>
          <target state="translated">&lt;em&gt;Сторона&lt;/em&gt; аргумент указывает ли индекс должен быть возвращен , что в первом подходящем месте (если &lt;code&gt;NPY_SEARCHLEFT&lt;/code&gt; ) или из последних (если &lt;code&gt;NPY_SEARCHRIGHT&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="099bc64f90d3db4f6c006d553b07493bf40349bd" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;sorter&lt;/em&gt; argument, if not &lt;code&gt;NULL&lt;/code&gt;, must be a 1D array of integer indices the same length as &lt;em&gt;self&lt;/em&gt;, that sorts it into ascending order. This is typically the result of a call to &lt;a href=&quot;#c.PyArray_ArgSort&quot;&gt;&lt;code&gt;PyArray_ArgSort&lt;/code&gt;&lt;/a&gt; (&amp;hellip;) Binary search is used to find the required insertion points.</source>
          <target state="translated">&lt;em&gt;Сортировщик&lt;/em&gt; аргумент, если не &lt;code&gt;NULL&lt;/code&gt; , должен быть массив 1D целочисленных индексов такой же длины , как и &lt;em&gt;я&lt;/em&gt; , что сортирует их в порядке возрастания. Обычно это результат вызова &lt;a href=&quot;#c.PyArray_ArgSort&quot;&gt; &lt;code&gt;PyArray_ArgSort&lt;/code&gt; &lt;/a&gt; (&amp;hellip;). Двоичный поиск используется для поиска необходимых точек вставки.</target>
        </trans-unit>
        <trans-unit id="7fad9b84d117a49a76f66aa7359451abb9299209" translate="yes" xml:space="preserve">
          <source>The API exposed by NumPy for third-party extensions has grown over years of releases, and has allowed programmers to directly access NumPy functionality from C. This API can be best described as &amp;ldquo;organic&amp;rdquo;. It has emerged from multiple competing desires and from multiple points of view over the years, strongly influenced by the desire to make it easy for users to move to NumPy from Numeric and Numarray. The core API originated with Numeric in 1995 and there are patterns such as the heavy use of macros written to mimic Python&amp;rsquo;s C-API as well as account for compiler technology of the late 90&amp;rsquo;s. There is also only a small group of volunteers who have had very little time to spend on improving this API.</source>
          <target state="translated">API, предоставляемый NumPy для сторонних расширений, вырос за годы выпусков и позволил программистам напрямую обращаться к функциям NumPy из C. Этот API лучше всего можно описать как &amp;laquo;органический&amp;raquo;. Он возник из множества конкурирующих желаний и с разных точек зрения на протяжении многих лет, под сильным влиянием желания облегчить пользователям переход на NumPy с Numeric и Numarray. Ядро API зародилось в Numeric в 1995 году, и есть такие закономерности, как интенсивное использование макросов, написанных для имитации C-API Python, а также с учетом технологии компиляторов конца 90-х. Также есть небольшая группа добровольцев, у которых было очень мало времени, чтобы потратить на улучшение этого API.</target>
        </trans-unit>
        <trans-unit id="00284168716cc312202174053f58f3f176efd9f0" translate="yes" xml:space="preserve">
          <source>The Array Interface</source>
          <target state="translated">Массивный интерфейс</target>
        </trans-unit>
        <trans-unit id="0126a67e2a45442b450ea70b10470e175bf968af" translate="yes" xml:space="preserve">
          <source>The Bartlett window is defined as</source>
          <target state="translated">Окно Бартлета определяется как</target>
        </trans-unit>
        <trans-unit id="937ca2e1b9d54c371bf73ce20e57493839ccf829" translate="yes" xml:space="preserve">
          <source>The Bartlett window is very similar to a triangular window, except that the end points are at zero. It is often used in signal processing for tapering a signal, without generating too much ripple in the frequency domain.</source>
          <target state="translated">Окно Бартлета очень похоже на треугольное окно,за исключением того,что конечные точки находятся на нуле.Оно часто используется при обработке сигнала для сужающегося сигнала,не создавая слишком большой пульсации в частотной области.</target>
        </trans-unit>
        <trans-unit id="9c87b609239622a7f33fd7054a79bbe3b69d99bf" translate="yes" xml:space="preserve">
          <source>The Beta distribution is a special case of the Dirichlet distribution, and is related to the Gamma distribution. It has the probability distribution function</source>
          <target state="translated">Бета-дистрибуция является особым случаем дирихлетского дистрибутива и связана с гамма-дистрибутивом.Оно имеет функцию вероятностного распределения</target>
        </trans-unit>
        <trans-unit id="b111fe41355b271c80f9d028d2e71b1df692e910" translate="yes" xml:space="preserve">
          <source>The BitGenerator can also be directly accessed using the members of the basic RNG structure.</source>
          <target state="translated">К BitGenerator можно получить прямой доступ,используя членов базовой структуры RNG.</target>
        </trans-unit>
        <trans-unit id="fe9a0ff0e1aba5f3307dd340548f412e309bd12d" translate="yes" xml:space="preserve">
          <source>The BitGenerators have been designed to be extendable using standard tools for high-performance Python &amp;ndash; numba and Cython. The &lt;a href=&quot;generator#numpy.random.Generator&quot;&gt;&lt;code&gt;Generator&lt;/code&gt;&lt;/a&gt; object can also be used with user-provided BitGenerators as long as these export a small set of required functions.</source>
          <target state="translated">BitGenerators были разработаны с возможностью расширения с использованием стандартных инструментов для высокопроизводительного Python - numba и Cython. Объект &lt;a href=&quot;generator#numpy.random.Generator&quot;&gt; &lt;code&gt;Generator&lt;/code&gt; &lt;/a&gt; также можно использовать с предоставленными пользователем BitGenerators, если они экспортируют небольшой набор необходимых функций.</target>
        </trans-unit>
        <trans-unit id="d038e7d7a9d5b6013d6bf710bb0f42c26b9ffb86" translate="yes" xml:space="preserve">
          <source>The Blackman window is a taper formed by using the first three terms of a summation of cosines. It was designed to have close to the minimal leakage possible. It is close to optimal, only slightly worse than a Kaiser window.</source>
          <target state="translated">Окно Blackman-это конус,образованный с помощью первых трех терминов суммирования косинусов.Оно было спроектировано таким образом,чтобы иметь почти минимальную утечку.Оно близко к оптимальному,только немного хуже,чем окно Кайзера.</target>
        </trans-unit>
        <trans-unit id="df8aff554aa2b04bd579ded0666721d3f45ae21e" translate="yes" xml:space="preserve">
          <source>The Blackman window is defined as</source>
          <target state="translated">Окно Blackman определяется как</target>
        </trans-unit>
        <trans-unit id="201133c822c73c7e6eedbd7735bf455db76c868e" translate="yes" xml:space="preserve">
          <source>The Box-Muller method used to produce NumPy&amp;rsquo;s normals is no longer available in &lt;a href=&quot;generator#numpy.random.Generator&quot;&gt;&lt;code&gt;Generator&lt;/code&gt;&lt;/a&gt;. It is not possible to reproduce the exact random values using &lt;code&gt;Generator&lt;/code&gt; for the normal distribution or any other distribution that relies on the normal such as the &lt;code&gt;gamma&lt;/code&gt; or &lt;code&gt;standard_t&lt;/code&gt;. If you require bitwise backward compatible streams, use &lt;code&gt;RandomState&lt;/code&gt;.</source>
          <target state="translated">Метод Бокса-Мюллера, используемый для создания нормалей NumPy, больше не доступен в &lt;a href=&quot;generator#numpy.random.Generator&quot;&gt; &lt;code&gt;Generator&lt;/code&gt; &lt;/a&gt; . Невозможно воспроизвести точные случайные значения с помощью &lt;code&gt;Generator&lt;/code&gt; для нормального распределения или любого другого распределения, которое полагается на нормальное, такое как &lt;code&gt;gamma&lt;/code&gt; или &lt;code&gt;standard_t&lt;/code&gt; . Если вам требуются побитовые потоки с обратной совместимостью, используйте &lt;code&gt;RandomState&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="530afb1a91925fe435a9294f8360e96b319ffb64" translate="yes" xml:space="preserve">
          <source>The Box-Muller method used to produce NumPy&amp;rsquo;s normals is no longer available in &lt;a href=&quot;generator#numpy.random.Generator&quot;&gt;&lt;code&gt;Generator&lt;/code&gt;&lt;/a&gt;. It is not possible to reproduce the exact random values using Generator for the normal distribution or any other distribution that relies on the normal such as the &lt;a href=&quot;generated/numpy.random.mtrand.randomstate.gamma#numpy.random.mtrand.RandomState.gamma&quot;&gt;&lt;code&gt;RandomState.gamma&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;generated/numpy.random.mtrand.randomstate.standard_t#numpy.random.mtrand.RandomState.standard_t&quot;&gt;&lt;code&gt;RandomState.standard_t&lt;/code&gt;&lt;/a&gt;. If you require bitwise backward compatible streams, use &lt;a href=&quot;legacy#numpy.random.mtrand.RandomState&quot;&gt;&lt;code&gt;RandomState&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Метод Бокса-Мюллера, используемый для создания нормалей NumPy, больше не доступен в &lt;a href=&quot;generator#numpy.random.Generator&quot;&gt; &lt;code&gt;Generator&lt;/code&gt; &lt;/a&gt; . Невозможно воспроизвести точные случайные значения с помощью генератора для нормального распределения или любого другого распределения, которое основывается на нормальном, например &lt;a href=&quot;generated/numpy.random.mtrand.randomstate.gamma#numpy.random.mtrand.RandomState.gamma&quot;&gt; &lt;code&gt;RandomState.gamma&lt;/code&gt; &lt;/a&gt; или &lt;a href=&quot;generated/numpy.random.mtrand.randomstate.standard_t#numpy.random.mtrand.RandomState.standard_t&quot;&gt; &lt;code&gt;RandomState.standard_t&lt;/code&gt; &lt;/a&gt; . Если вам требуются побитовые потоки с обратной совместимостью, используйте &lt;a href=&quot;legacy#numpy.random.mtrand.RandomState&quot;&gt; &lt;code&gt;RandomState&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="08ca8f1d4aa8ba16007dde802489e6ef41f52bf0" translate="yes" xml:space="preserve">
          <source>The Box-Muller method used to produce NumPy&amp;rsquo;s normals is no longer available.</source>
          <target state="translated">Метод Бокса-Мюллера, используемый для создания нормалей NumPy, больше не доступен.</target>
        </trans-unit>
        <trans-unit id="12c85becd504bcc9e1840ed9b25393915f66f319" translate="yes" xml:space="preserve">
          <source>The C code to be wrapped for argoutview arrays are characterized by pointers: pointers to the dimensions and double pointers to the data, so that these values can be passed back to the user. The argoutview typemap signatures are therefore</source>
          <target state="translated">Код на языке Си,который должен быть обернут для массивов argoutview,характеризуется указателями:указателями на размеры и двойными указателями на данные,так что эти значения могут быть переданы обратно пользователю.Следовательно,сигнатуры карты типов argoutview являются следующими</target>
        </trans-unit>
        <trans-unit id="3b86dcfa016c911d4342c93c728710eb6da34647" translate="yes" xml:space="preserve">
          <source>The C-API is actually an array of function pointers. This array is created (and pointed to by a global variable) by import_ufunc. The global variable is either statically defined or allowed to be seen by other files depending on the state of &lt;a href=&quot;#c.PY_UFUNC_UNIQUE_SYMBOL&quot;&gt;&lt;code&gt;PY_UFUNC_UNIQUE_SYMBOL&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#c.NO_IMPORT_UFUNC&quot;&gt;&lt;code&gt;NO_IMPORT_UFUNC&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">C-API на самом деле представляет собой массив указателей на функции. Этот массив создается (и указывается глобальной переменной) с помощью import_ufunc. Глобальная переменная либо определяется статически, либо может быть видна другим файлам в зависимости от состояния &lt;a href=&quot;#c.PY_UFUNC_UNIQUE_SYMBOL&quot;&gt; &lt;code&gt;PY_UFUNC_UNIQUE_SYMBOL&lt;/code&gt; &lt;/a&gt; и &lt;a href=&quot;#c.NO_IMPORT_UFUNC&quot;&gt; &lt;code&gt;NO_IMPORT_UFUNC&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="27ac48dd933ed72b23987767613d8001cf662454" translate="yes" xml:space="preserve">
          <source>The C-structure corresponding to an object of &lt;a href=&quot;#c.PyArrayIter_Type&quot;&gt;&lt;code&gt;PyArrayIter_Type&lt;/code&gt;&lt;/a&gt; is the &lt;a href=&quot;#c.PyArrayIterObject&quot;&gt;&lt;code&gt;PyArrayIterObject&lt;/code&gt;&lt;/a&gt;. The &lt;a href=&quot;#c.PyArrayIterObject&quot;&gt;&lt;code&gt;PyArrayIterObject&lt;/code&gt;&lt;/a&gt; is used to keep track of a pointer into an N-dimensional array. It contains associated information used to quickly march through the array. The pointer can be adjusted in three basic ways: 1) advance to the &amp;ldquo;next&amp;rdquo; position in the array in a C-style contiguous fashion, 2) advance to an arbitrary N-dimensional coordinate in the array, and 3) advance to an arbitrary one-dimensional index into the array. The members of the &lt;a href=&quot;#c.PyArrayIterObject&quot;&gt;&lt;code&gt;PyArrayIterObject&lt;/code&gt;&lt;/a&gt; structure are used in these calculations. Iterator objects keep their own dimension and strides information about an array. This can be adjusted as needed for &amp;ldquo;broadcasting,&amp;rdquo; or to loop over only specific dimensions.</source>
          <target state="translated">C-структура, соответствующая объекту &lt;a href=&quot;#c.PyArrayIter_Type&quot;&gt; &lt;code&gt;PyArrayIter_Type&lt;/code&gt; ,&lt;/a&gt; - это &lt;a href=&quot;#c.PyArrayIterObject&quot;&gt; &lt;code&gt;PyArrayIterObject&lt;/code&gt; &lt;/a&gt; . &lt;a href=&quot;#c.PyArrayIterObject&quot;&gt; &lt;code&gt;PyArrayIterObject&lt;/code&gt; &lt;/a&gt; используется для отслеживания указателя в N-мерный массив. Он содержит связанную информацию, используемую для быстрого перехода по массиву. Указатель можно настроить тремя основными способами: 1) перейти к &amp;laquo;следующей&amp;raquo; позиции в массиве непрерывным способом в стиле C, 2) перейти к произвольной N-мерной координате в массиве и 3) перейти к произвольный одномерный индекс в массив. Члены &lt;a href=&quot;#c.PyArrayIterObject&quot;&gt; &lt;code&gt;PyArrayIterObject&lt;/code&gt; &lt;/a&gt;структуры используются в этих расчетах. Объекты-итераторы сохраняют свое собственное измерение и передают информацию о массиве. Это можно отрегулировать по мере необходимости для &amp;laquo;широковещательной передачи&amp;raquo; или для обхода только определенных измерений.</target>
        </trans-unit>
        <trans-unit id="5b65035b5e2ef1f9ddd680e8269d8b6e8cd78edf" translate="yes" xml:space="preserve">
          <source>The C-structure corresponding to an object of &lt;a href=&quot;#c.PyArrayNeighborhoodIter_Type&quot;&gt;&lt;code&gt;PyArrayNeighborhoodIter_Type&lt;/code&gt;&lt;/a&gt; is the &lt;a href=&quot;#c.PyArrayNeighborhoodIterObject&quot;&gt;&lt;code&gt;PyArrayNeighborhoodIterObject&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">C-структура, соответствующая объекту &lt;a href=&quot;#c.PyArrayNeighborhoodIter_Type&quot;&gt; &lt;code&gt;PyArrayNeighborhoodIter_Type&lt;/code&gt; ,&lt;/a&gt; - это &lt;a href=&quot;#c.PyArrayNeighborhoodIterObject&quot;&gt; &lt;code&gt;PyArrayNeighborhoodIterObject&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="b70a592ea3e52c944c4250fca143b3a7150ee3c2" translate="yes" xml:space="preserve">
          <source>The Cauchy distribution arises in the solution to the driven harmonic oscillator problem, and also describes spectral line broadening. It also describes the distribution of values at which a line tilted at a random angle will cut the x axis.</source>
          <target state="translated">Распределение Коши возникает при решении задачи управляемого гармонического осциллятора,а также описывает расширение спектральных линий.Оно также описывает распределение значений,при котором линия,наклоненная под случайным углом,отрежет ось Х.</target>
        </trans-unit>
        <trans-unit id="7e16b7bac76fd95a18826e75104c29f03fcae229" translate="yes" xml:space="preserve">
          <source>The Chebyshev class provides the standard Python numerical methods &amp;lsquo;+&amp;rsquo;, &amp;lsquo;-&amp;lsquo;, &amp;lsquo;*&amp;rsquo;, &amp;lsquo;//&amp;rsquo;, &amp;lsquo;%&amp;rsquo;, &amp;lsquo;divmod&amp;rsquo;, &amp;lsquo;**&amp;rsquo;, and &amp;lsquo;()&amp;rsquo; as well as the methods listed below.</source>
          <target state="translated">Класс Чебышева предоставляет стандартные числовые методы Python '+', '-', '*', '//', '%', 'divmod', '**' и '()', а также перечисленные методы ниже.</target>
        </trans-unit>
        <trans-unit id="993466511b9f370f4f72797c543b0fe46fcac4af" translate="yes" xml:space="preserve">
          <source>The Chebyshev series basis polynomials aren&amp;rsquo;t powers of &lt;code&gt;x&lt;/code&gt; so the results of this function may seem unintuitive.</source>
          <target state="translated">Базисные полиномы ряда Чебышева не являются степенями &lt;code&gt;x&lt;/code&gt; , поэтому результаты этой функции могут показаться неинтуитивными.</target>
        </trans-unit>
        <trans-unit id="46d5d357969a2c2d8e943734dcd70f209f532e7d" translate="yes" xml:space="preserve">
          <source>The Cholesky decomposition is often used as a fast way of solving</source>
          <target state="translated">Разложение Холесского часто используется в качестве быстрого способа разложения</target>
        </trans-unit>
        <trans-unit id="7319ec02e3cbbaab7add308cd0a417516f369a3b" translate="yes" xml:space="preserve">
          <source>The DFT is defined, with the conventions used in this implementation, in the documentation for the &lt;a href=&quot;../routines.fft#module-numpy.fft&quot;&gt;&lt;code&gt;numpy.fft&lt;/code&gt;&lt;/a&gt; module.</source>
          <target state="translated">ДПФ определяется с использованием соглашений, используемых в этой реализации, в документации для модуля &lt;a href=&quot;../routines.fft#module-numpy.fft&quot;&gt; &lt;code&gt;numpy.fft&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="c850428d828f95dc2c92af14d3b7a369fbb6f873" translate="yes" xml:space="preserve">
          <source>The DFT is in general defined for complex inputs and outputs, and a single-frequency component at linear frequency</source>
          <target state="translated">DFT,как правило,определяется для сложных входов и выходов,а также одночастотной составляющей на линейной частоте.</target>
        </trans-unit>
        <trans-unit id="e1f0dbe8081449397bad0aa2cc6ad0fe41215d23" translate="yes" xml:space="preserve">
          <source>The Datetime and Timedelta data types support a large number of time units, as well as generic units which can be coerced into any of the other units based on input data.</source>
          <target state="translated">Типы данных Datetime и Timedelta поддерживают большое количество единиц времени,а также общие единицы,которые могут быть принудительно введены в любой из других блоков на основе входных данных.</target>
        </trans-unit>
        <trans-unit id="fcc8fbde1f068047c588e86f64b1d9bca100dc12" translate="yes" xml:space="preserve">
          <source>The Dirichlet distribution is a distribution over vectors</source>
          <target state="translated">Дирихлетское распределение-это распределение по векторам.</target>
        </trans-unit>
        <trans-unit id="a4edf1637ded5c0257b8e49c407baa1302046498" translate="yes" xml:space="preserve">
          <source>The Einstein summation convention can be used to compute many multi-dimensional, linear algebraic array operations. &lt;a href=&quot;#numpy.einsum&quot;&gt;&lt;code&gt;einsum&lt;/code&gt;&lt;/a&gt; provides a succinct way of representing these.</source>
          <target state="translated">Соглашение Эйнштейна о суммировании можно использовать для вычисления многих многомерных операций с линейными алгебраическими массивами. &lt;a href=&quot;#numpy.einsum&quot;&gt; &lt;code&gt;einsum&lt;/code&gt; &lt;/a&gt; предоставляет сжатый способ их представления.</target>
        </trans-unit>
        <trans-unit id="28b073ac0a61d366802edc13aac74cfca673e0d2" translate="yes" xml:space="preserve">
          <source>The Euler constant</source>
          <target state="translated">Константа Эйлера</target>
        </trans-unit>
        <trans-unit id="e516b8e0c93fdf83378c5af74b4c3f11ab8b2eec" translate="yes" xml:space="preserve">
          <source>The F statistic is used to compare in-group variances to between-group variances. Calculating the distribution depends on the sampling, and so it is a function of the respective degrees of freedom in the problem. The variable &lt;code&gt;dfnum&lt;/code&gt; is the number of samples minus one, the between-groups degrees of freedom, while &lt;code&gt;dfden&lt;/code&gt; is the within-groups degrees of freedom, the sum of the number of samples in each group minus the number of groups.</source>
          <target state="translated">Статистика F используется для сравнения внутригрупповых отклонений с межгрупповыми отклонениями. Расчет распределения зависит от выборки и, следовательно, является функцией соответствующих степеней свободы в задаче. Переменная &lt;code&gt;dfnum&lt;/code&gt; - это количество образцов минус один, степени свободы между группами, а &lt;code&gt;dfden&lt;/code&gt; - это степени свободы внутри групп, сумма количества образцов в каждой группе за вычетом количества групп.</target>
        </trans-unit>
        <trans-unit id="255611abe871551a6f0d10449c721d9ac320d3a5" translate="yes" xml:space="preserve">
          <source>The Frobenius norm is given by &lt;a href=&quot;#rac1c834adb66-1&quot; id=&quot;id1&quot;&gt;[1]&lt;/a&gt;:</source>
          <target state="translated">Норма Фробениуса дается формулой &lt;a href=&quot;#rac1c834adb66-1&quot; id=&quot;id1&quot;&gt;[1]&lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="7783b7563d5c19477bd0cec8f560b128f37ead00" translate="yes" xml:space="preserve">
          <source>The Gamma distribution is often used to model the times to failure of electronic components, and arises naturally in processes for which the waiting times between Poisson distributed events are relevant.</source>
          <target state="translated">Распределение Гаммы часто используется для моделирования времени до отказа электронных компонентов,и возникает естественным образом в процессах,для которых релевантно время ожидания между распределенными событиями Пуассона.</target>
        </trans-unit>
        <trans-unit id="9c990e445bfb7966adc1e3b9adac640f1e0e9113" translate="yes" xml:space="preserve">
          <source>The Generator&amp;rsquo;s normal, exponential and gamma functions use 256-step Ziggurat methods which are 2-10 times faster than NumPy&amp;rsquo;s Box-Muller or inverse CDF implementations.</source>
          <target state="translated">Нормальные, экспоненциальные и гамма-функции Генератора используют 256-шаговые методы Ziggurat, которые в 2-10 раз быстрее, чем реализация NumPy Box-Muller или обратная реализация CDF.</target>
        </trans-unit>
        <trans-unit id="5fd129bc188ef44c6bd32a38b068d9f3ddc783f7" translate="yes" xml:space="preserve">
          <source>The Gumbel (named for German mathematician Emil Julius Gumbel) was used very early in the hydrology literature, for modeling the occurrence of flood events. It is also used for modeling maximum wind speed and rainfall rates. It is a &amp;ldquo;fat-tailed&amp;rdquo; distribution - the probability of an event in the tail of the distribution is larger than if one used a Gaussian, hence the surprisingly frequent occurrence of 100-year floods. Floods were initially modeled as a Gaussian process, which underestimated the frequency of extreme events.</source>
          <target state="translated">Гумбель (названный в честь немецкого математика Эмиля Юлиуса Гумбеля) использовался очень рано в литературе по гидрологии для моделирования возникновения наводнений. Он также используется для моделирования максимальной скорости ветра и количества осадков. Это распределение с &amp;laquo;толстым хвостом&amp;raquo; - вероятность события в хвосте распределения выше, чем при использовании гауссианы, отсюда удивительно частое возникновение 100-летних наводнений. Первоначально наводнения моделировались как гауссовский процесс, который недооценивал частоту экстремальных явлений.</target>
        </trans-unit>
        <trans-unit id="aa1cbdb34f4d0d2f5ba482222c9284e53a83897b" translate="yes" xml:space="preserve">
          <source>The Gumbel (or Smallest Extreme Value (SEV) or the Smallest Extreme Value Type I) distribution is one of a class of Generalized Extreme Value (GEV) distributions used in modeling extreme value problems. The Gumbel is a special case of the Extreme Value Type I distribution for maximums from distributions with &amp;ldquo;exponential-like&amp;rdquo; tails.</source>
          <target state="translated">Распределение Гамбеля (или наименьшего экстремального значения (SEV) или наименьшего экстремального значения, тип I) является одним из класса распределений обобщенного экстремального значения (GEV), используемых при моделировании проблем экстремальных значений. Gumbel - это частный случай распределения типа I с экстремальным значением для максимумов из распределений с &amp;laquo;экспоненциальными&amp;raquo; хвостами.</target>
        </trans-unit>
        <trans-unit id="d38e3c533241c1cffef7a77e2fb316d839d0e953" translate="yes" xml:space="preserve">
          <source>The Hamming was named for R. W. Hamming, an associate of J. W. Tukey and is described in Blackman and Tukey. It was recommended for smoothing the truncated autocovariance function in the time domain. Most references to the Hamming window come from the signal processing literature, where it is used as one of many windowing functions for smoothing values. It is also known as an apodization (which means &amp;ldquo;removing the foot&amp;rdquo;, i.e. smoothing discontinuities at the beginning and end of the sampled signal) or tapering function.</source>
          <target state="translated">Хэмминг был назван в честь Р. У. Хэмминга, сотрудника Дж. У. Тьюки, и описан у Блэкмана и Тьюки. Он был рекомендован для сглаживания усеченной функции автоковариации во временной области. Большинство ссылок на окно Хэмминга происходит из литературы по обработке сигналов, где оно используется в качестве одной из многих оконных функций для сглаживания значений. Это также известно как аподизация (что означает &amp;laquo;удаление стопы&amp;raquo;, т. Е. Сглаживание разрывов в начале и конце дискретизированного сигнала) или функция сужения.</target>
        </trans-unit>
        <trans-unit id="f6f99a10c7b1d0ed496e360cabc47ad0e8b4f95f" translate="yes" xml:space="preserve">
          <source>The Hamming window is a taper formed by using a weighted cosine.</source>
          <target state="translated">Окно Hamming представляет собой конус,образованный с помощью утяжеленного косинуса.</target>
        </trans-unit>
        <trans-unit id="c543c8775de7884a498fb8d25199a6da7865f313" translate="yes" xml:space="preserve">
          <source>The Hamming window is defined as</source>
          <target state="translated">Окно Хамминга определяется как</target>
        </trans-unit>
        <trans-unit id="c53c036c06b914f30dfda36ac484fab584082b10" translate="yes" xml:space="preserve">
          <source>The Hanning was named for Julius von Hann, an Austrian meteorologist. It is also known as the Cosine Bell. Some authors prefer that it be called a Hann window, to help avoid confusion with the very similar Hamming window.</source>
          <target state="translated">Ханнинг был назван в честь Юлиуса фон Ханна,австрийского метеоролога.Он также известен как &quot;Косиновый колокол&quot;.Некоторые авторы предпочитают,чтобы его называли &quot;окном Ханна&quot;,чтобы избежать путаницы с очень похожим окном Хамминга.</target>
        </trans-unit>
        <trans-unit id="ff9ff54dbcac5fb28018a438cebbfd23097afaae" translate="yes" xml:space="preserve">
          <source>The Hanning window is a taper formed by using a weighted cosine.</source>
          <target state="translated">Окно Hanning-это конус,образованный с помощью утяжеленного косинуса.</target>
        </trans-unit>
        <trans-unit id="7063e81cb7e74fa0cdbf05d1c6333c059e7c5e09" translate="yes" xml:space="preserve">
          <source>The Hanning window is defined as</source>
          <target state="translated">Окно Hanning определяется как</target>
        </trans-unit>
        <trans-unit id="48a86546760e1edd4295f33a270bba0337fe9c75" translate="yes" xml:space="preserve">
          <source>The Heaviside step function is defined as:</source>
          <target state="translated">Функция шага Хевисайда определяется как:</target>
        </trans-unit>
        <trans-unit id="a4ab8a335073ed439b508ce34550cc0419ac6836" translate="yes" xml:space="preserve">
          <source>The Hermite class provides the standard Python numerical methods &amp;lsquo;+&amp;rsquo;, &amp;lsquo;-&amp;lsquo;, &amp;lsquo;*&amp;rsquo;, &amp;lsquo;//&amp;rsquo;, &amp;lsquo;%&amp;rsquo;, &amp;lsquo;divmod&amp;rsquo;, &amp;lsquo;**&amp;rsquo;, and &amp;lsquo;()&amp;rsquo; as well as the attributes and methods listed in the &lt;code&gt;ABCPolyBase&lt;/code&gt; documentation.</source>
          <target state="translated">Класс Hermite предоставляет стандартные числовые методы Python '+', '-', '*', '//', '%', 'divmod', '**' и '()', а также атрибуты и методы, перечисленные в документации &lt;code&gt;ABCPolyBase&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="18c51c2fe8d0823ca52707c91973d012f1770684" translate="yes" xml:space="preserve">
          <source>The Hermite series basis polynomials aren&amp;rsquo;t powers of &lt;code&gt;x&lt;/code&gt; so the results of this function may seem unintuitive.</source>
          <target state="translated">Базисные полиномы ряда Эрмита не являются степенями &lt;code&gt;x&lt;/code&gt; , поэтому результаты этой функции могут показаться неинтуитивными.</target>
        </trans-unit>
        <trans-unit id="29f886dede3063b00d8467b1f756a147bc393097" translate="yes" xml:space="preserve">
          <source>The HermiteE class provides the standard Python numerical methods &amp;lsquo;+&amp;rsquo;, &amp;lsquo;-&amp;lsquo;, &amp;lsquo;*&amp;rsquo;, &amp;lsquo;//&amp;rsquo;, &amp;lsquo;%&amp;rsquo;, &amp;lsquo;divmod&amp;rsquo;, &amp;lsquo;**&amp;rsquo;, and &amp;lsquo;()&amp;rsquo; as well as the attributes and methods listed in the &lt;code&gt;ABCPolyBase&lt;/code&gt; documentation.</source>
          <target state="translated">Класс HermiteE предоставляет стандартные числовые методы Python '+', '-', '*', '//', '%', 'divmod', '**' и '()', а также атрибуты и методы, перечисленные в документации &lt;code&gt;ABCPolyBase&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8cc8b1724a44c8d63d2cfd0d81bc585f17fc260c" translate="yes" xml:space="preserve">
          <source>The HermiteE series basis polynomials aren&amp;rsquo;t powers of &lt;code&gt;x&lt;/code&gt; so the results of this function may seem unintuitive.</source>
          <target state="translated">Базисные полиномы серии HermiteE не являются степенями &lt;code&gt;x&lt;/code&gt; , поэтому результаты этой функции могут показаться неинтуитивными.</target>
        </trans-unit>
        <trans-unit id="d4c697a75ca6fe93876f5946baa1a9463872c64a" translate="yes" xml:space="preserve">
          <source>The IRR is perhaps best understood through an example (illustrated using np.irr in the Examples section below). Suppose one invests 100 units and then makes the following withdrawals at regular (fixed) intervals: 39, 59, 55, 20. Assuming the ending value is 0, one&amp;rsquo;s 100 unit investment yields 173 units; however, due to the combination of compounding and the periodic withdrawals, the &amp;ldquo;average&amp;rdquo; rate of return is neither simply 0.73/4 nor (1.73)^0.25-1. Rather, it is the solution (for</source>
          <target state="translated">IRR, возможно, лучше всего понять на примере (проиллюстрированном с помощью np.irr в разделе &amp;laquo;Примеры&amp;raquo; ниже). Предположим, что кто-то инвестирует 100 единиц, а затем через регулярные (фиксированные) интервалы снимает следующие суммы: 39, 59, 55, 20. Предположим, что конечное значение равно 0, вложение 100 единиц дает 173 единицы; однако из-за комбинации начисления сложных процентов и периодического снятия средств &amp;laquo;средняя&amp;raquo; норма доходности не равна ни 0,73 / 4, ни (1,73) ^ 0,25-1. Скорее, это решение (для</target>
        </trans-unit>
        <trans-unit id="ddbfb62d79e442dbada344aa5b0b7d3f75bd62fd" translate="yes" xml:space="preserve">
          <source>The Kaiser can approximate many other windows by varying the beta parameter.</source>
          <target state="translated">Кайзер может приближаться ко многим другим окнам,изменяя параметр бета-версии.</target>
        </trans-unit>
        <trans-unit id="61a6a7b7c0a7a3c07a636b9187a5aa5c8ed22e80" translate="yes" xml:space="preserve">
          <source>The Kaiser was named for Jim Kaiser, who discovered a simple approximation to the DPSS window based on Bessel functions. The Kaiser window is a very good approximation to the Digital Prolate Spheroidal Sequence, or Slepian window, which is the transform which maximizes the energy in the main lobe of the window relative to total energy.</source>
          <target state="translated">Кайзер был назван в честь Джима Кайзера,который обнаружил простое приближение к окну DPSS,основанному на функциях Бесселя.Окно Кайзера является очень хорошим приближением к Цифровой Шаровидной последовательности,или Слепийскому окну,которое является преобразованием,которое максимизирует энергию в главной доле окна относительно полной энергии.</target>
        </trans-unit>
        <trans-unit id="3c47d6f84b8a7a5230ef01c3b24f485faf045505" translate="yes" xml:space="preserve">
          <source>The Kaiser window is a taper formed by using a Bessel function.</source>
          <target state="translated">Окно Кайзера представляет собой конус,образованный с помощью функции Бесселя.</target>
        </trans-unit>
        <trans-unit id="d40317952ac62ac63be6a7eb42d8bb031447a844" translate="yes" xml:space="preserve">
          <source>The Kaiser window is defined as</source>
          <target state="translated">Окно Кайзера определяется как</target>
        </trans-unit>
        <trans-unit id="de389ba4bc7accb91ca973f3199d4d09bb36d074" translate="yes" xml:space="preserve">
          <source>The Laguerre class provides the standard Python numerical methods &amp;lsquo;+&amp;rsquo;, &amp;lsquo;-&amp;lsquo;, &amp;lsquo;*&amp;rsquo;, &amp;lsquo;//&amp;rsquo;, &amp;lsquo;%&amp;rsquo;, &amp;lsquo;divmod&amp;rsquo;, &amp;lsquo;**&amp;rsquo;, and &amp;lsquo;()&amp;rsquo; as well as the attributes and methods listed in the &lt;code&gt;ABCPolyBase&lt;/code&gt; documentation.</source>
          <target state="translated">Класс Laguerre предоставляет стандартные числовые методы Python '+', '-', '*', '//', '%', 'divmod', '**' и '()', а также атрибуты и методы, перечисленные в документации &lt;code&gt;ABCPolyBase&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="673da347447c32096475798f43cd3eae37f1e962" translate="yes" xml:space="preserve">
          <source>The Laguerre series basis polynomials aren&amp;rsquo;t powers of &lt;code&gt;x&lt;/code&gt; so the results of this function may seem unintuitive.</source>
          <target state="translated">Базисные полиномы ряда Лагерра не являются степенями &lt;code&gt;x&lt;/code&gt; , поэтому результаты этой функции могут показаться неинтуитивными.</target>
        </trans-unit>
        <trans-unit id="beacaa427ac9dd11f90d057bc9c94b6f47608f00" translate="yes" xml:space="preserve">
          <source>The Laplace distribution is similar to the Gaussian/normal distribution, but is sharper at the peak and has fatter tails. It represents the difference between two independent, identically distributed exponential random variables.</source>
          <target state="translated">Распределение Лапласа аналогично гауссовскому/нормальному распределению,но острее на пике и имеет более толстые хвосты.Оно представляет собой разность между двумя независимыми,одинаково распределенными экспоненциальными случайными переменными.</target>
        </trans-unit>
        <trans-unit id="9f6965544802824fa340cc542a5a8e5ec41b1a8a" translate="yes" xml:space="preserve">
          <source>The Legendre class provides the standard Python numerical methods &amp;lsquo;+&amp;rsquo;, &amp;lsquo;-&amp;lsquo;, &amp;lsquo;*&amp;rsquo;, &amp;lsquo;//&amp;rsquo;, &amp;lsquo;%&amp;rsquo;, &amp;lsquo;divmod&amp;rsquo;, &amp;lsquo;**&amp;rsquo;, and &amp;lsquo;()&amp;rsquo; as well as the attributes and methods listed in the &lt;code&gt;ABCPolyBase&lt;/code&gt; documentation.</source>
          <target state="translated">Класс Legendre предоставляет стандартные числовые методы Python '+', '-', '*', '//', '%', 'divmod', '**' и '()', а также атрибуты и методы, перечисленные в документации &lt;code&gt;ABCPolyBase&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="083c119f1df4d844bfc4b2160deea854a1daea76" translate="yes" xml:space="preserve">
          <source>The Legendre series basis polynomials aren&amp;rsquo;t powers of &lt;code&gt;x&lt;/code&gt; so the results of this function may seem unintuitive.</source>
          <target state="translated">Базисные полиномы ряда Лежандра не являются степенями &lt;code&gt;x&lt;/code&gt; , поэтому результаты этой функции могут показаться неинтуитивными.</target>
        </trans-unit>
        <trans-unit id="191a6c01d66efbf4468b0c4b76d708edbb3efb30" translate="yes" xml:space="preserve">
          <source>The Logistic distribution is used in Extreme Value problems where it can act as a mixture of Gumbel distributions, in Epidemiology, and by the World Chess Federation (FIDE) where it is used in the Elo ranking system, assuming the performance of each player is a logistically distributed random variable.</source>
          <target state="translated">Логистическое распределение используется в задачах Extreme Value,где оно может действовать как смесь распределений Гумбеля,в Эпидемиологии и во Всемирной шахматной федерации (FIDE),где оно используется в системе ранжирования Эло,предполагая,что производительность каждого игрока является логистически распределенной случайной величиной.</target>
        </trans-unit>
        <trans-unit id="7e46f1b490ad93ea0aa4b70cea1c8217c1eeec4d" translate="yes" xml:space="preserve">
          <source>The Lomax or Pareto II distribution is a shifted Pareto distribution. The classical Pareto distribution can be obtained from the Lomax distribution by adding 1 and multiplying by the scale parameter &lt;code&gt;m&lt;/code&gt; (see Notes). The smallest value of the Lomax distribution is zero while for the classical Pareto distribution it is &lt;code&gt;mu&lt;/code&gt;, where the standard Pareto distribution has location &lt;code&gt;mu = 1&lt;/code&gt;. Lomax can also be considered as a simplified version of the Generalized Pareto distribution (available in SciPy), with the scale set to one and the location set to zero.</source>
          <target state="translated">Распределение Ломакса или Парето II является смещенным распределением Парето. Классическое распределение Парето может быть получено из распределения Ломакса путем добавления 1 и умножения на параметр масштаба &lt;code&gt;m&lt;/code&gt; (см. Примечания). Наименьшее значение распределения Ломакса равно нулю, в то время как для классического распределения Парето это &lt;code&gt;mu&lt;/code&gt; , где стандартное распределение Парето имеет местоположение &lt;code&gt;mu = 1&lt;/code&gt; . Lomax также можно рассматривать как упрощенную версию обобщенного распределения Парето (доступного в SciPy) с масштабом, установленным на единицу, и положением, установленным на ноль.</target>
        </trans-unit>
        <trans-unit id="913eec14ed443e489cdc77c2f2c24950a32724fd" translate="yes" xml:space="preserve">
          <source>The MATLAB &lt;code&gt;rem&lt;/code&gt; function and or the C &lt;code&gt;%&lt;/code&gt; operator which is the complement to &lt;code&gt;int(x1 / x2)&lt;/code&gt;.</source>
          <target state="translated">Функция MATLAB &lt;code&gt;rem&lt;/code&gt; и / или оператор C &lt;code&gt;%&lt;/code&gt; , который является дополнением к &lt;code&gt;int(x1 / x2)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="accc4f84d711af6e82c6efbbd034211d91d17fc7" translate="yes" xml:space="preserve">
          <source>The MaskedArray class</source>
          <target state="translated">Класс MaskedArray</target>
        </trans-unit>
        <trans-unit id="5110aa799914ad12dc0bd211beae0c5585bdbc96" translate="yes" xml:space="preserve">
          <source>The Matrix class</source>
          <target state="translated">Класс &quot;Матрица</target>
        </trans-unit>
        <trans-unit id="aae8587a9f8f2d6d760d4e3f9211a40fc1df3fef" translate="yes" xml:space="preserve">
          <source>The N-dimensional array (&lt;code&gt;ndarray&lt;/code&gt;)</source>
          <target state="translated">N-мерный массив ( &lt;code&gt;ndarray&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="ebbab7ca4ee7572bcfa080543866bf18ac7ca419" translate="yes" xml:space="preserve">
          <source>The N-dimensional array (ndarray)</source>
          <target state="translated">N-мерный массив (ndarray)</target>
        </trans-unit>
        <trans-unit id="9062ffe94800b2d5eac1ade12a3d3195e3fb90d9" translate="yes" xml:space="preserve">
          <source>The NPV of the input cash flow series &lt;code&gt;values&lt;/code&gt; at the discount &lt;a href=&quot;numpy.rate#numpy.rate&quot;&gt;&lt;code&gt;rate&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">NPV &lt;code&gt;values&lt;/code&gt; ряда входных денежных потоков по &lt;a href=&quot;numpy.rate#numpy.rate&quot;&gt; &lt;code&gt;rate&lt;/code&gt; &lt;/a&gt; дисконтирования .</target>
        </trans-unit>
        <trans-unit id="06341e3da348b45983c3d2e0a0cf15e91944f0fa" translate="yes" xml:space="preserve">
          <source>The NumPy 1.6 release includes a more primitive datetime data type than 1.7. This section documents many of the changes that have taken place.</source>
          <target state="translated">Релиз NumPy 1.6 включает более примитивный тип данных по дате,чем 1.7.В этом разделе документируются многие из произошедших изменений.</target>
        </trans-unit>
        <trans-unit id="22808a8257a77bd3771514110cd88913c8cbfe31" translate="yes" xml:space="preserve">
          <source>The NumPy linear algebra functions rely on BLAS and LAPACK to provide efficient low level implementations of standard linear algebra algorithms. Those libraries may be provided by NumPy itself using C versions of a subset of their reference implementations but, when possible, highly optimized libraries that take advantage of specialized processor functionality are preferred. Examples of such libraries are &lt;a href=&quot;https://www.openblas.net/&quot;&gt;OpenBLAS&lt;/a&gt;, MKL (TM), and ATLAS. Because those libraries are multithreaded and processor dependent, environmental variables and external packages such as &lt;a href=&quot;https://github.com/joblib/threadpoolctl&quot;&gt;threadpoolctl&lt;/a&gt; may be needed to control the number of threads or specify the processor architecture.</source>
          <target state="translated">Функции линейной алгебры NumPy полагаются на BLAS и LAPACK для обеспечения эффективных низкоуровневых реализаций стандартных алгоритмов линейной алгебры. Эти библиотеки могут быть предоставлены самим NumPy с использованием C-версий подмножества их эталонных реализаций, но, когда это возможно, предпочтительны высокооптимизированные библиотеки, которые используют преимущества специализированных функций процессора. Примерами таких библиотек являются &lt;a href=&quot;https://www.openblas.net/&quot;&gt;OpenBLAS&lt;/a&gt; , MKL &amp;trade; и ATLAS. Поскольку эти библиотеки являются многопоточными и зависят от процессора, могут потребоваться переменные среды и внешние пакеты, такие как &lt;a href=&quot;https://github.com/joblib/threadpoolctl&quot;&gt;threadpoolctl&lt;/a&gt; , для управления количеством потоков или определения архитектуры процессора.</target>
        </trans-unit>
        <trans-unit id="5abe575872513074969d9820a4d531c3d12a22f7" translate="yes" xml:space="preserve">
          <source>The Pareto distribution must be greater than zero, and is unbounded above. It is also known as the &amp;ldquo;80-20 rule&amp;rdquo;. In this distribution, 80 percent of the weights are in the lowest 20 percent of the range, while the other 20 percent fill the remaining 80 percent of the range.</source>
          <target state="translated">Распределение Парето должно быть больше нуля и не ограничено сверху. Это также известно как &amp;laquo;правило 80-20&amp;raquo;. В этом распределении 80 процентов весов относятся к нижним 20 процентам диапазона, а остальные 20 процентов заполняют оставшиеся 80 процентов диапазона.</target>
        </trans-unit>
        <trans-unit id="ed5b998678bc3c838f5d54a5f0beb5816b99470d" translate="yes" xml:space="preserve">
          <source>The Pareto distribution, named after the Italian economist Vilfredo Pareto, is a power law probability distribution useful in many real world problems. Outside the field of economics it is generally referred to as the Bradford distribution. Pareto developed the distribution to describe the distribution of wealth in an economy. It has also found use in insurance, web page access statistics, oil field sizes, and many other problems, including the download frequency for projects in Sourceforge &lt;a href=&quot;#r8689274e67cd-1&quot; id=&quot;id1&quot;&gt;[1]&lt;/a&gt;. It is one of the so-called &amp;ldquo;fat-tailed&amp;rdquo; distributions.</source>
          <target state="translated">Распределение Парето, названное в честь итальянского экономиста Вильфредо Парето, представляет собой степенное распределение вероятностей, которое можно использовать во многих реальных проблемах. За пределами области экономики его обычно называют распределением Брэдфорда. Парето разработал распределение для описания распределения богатства в экономике. Он также нашел применение в страховании, статистике доступа к веб-страницам, размерах нефтяных месторождений и во многих других задачах, включая частоту загрузки проектов в Sourceforge &lt;a href=&quot;#r8689274e67cd-1&quot; id=&quot;id1&quot;&gt;[1]&lt;/a&gt; . Это одно из так называемых распределений с толстым хвостом.</target>
        </trans-unit>
        <trans-unit id="2867a07ee69e6406fe64c658305fdda7fb7b8075" translate="yes" xml:space="preserve">
          <source>The Pareto distribution, named after the Italian economist Vilfredo Pareto, is a power law probability distribution useful in many real world problems. Outside the field of economics it is generally referred to as the Bradford distribution. Pareto developed the distribution to describe the distribution of wealth in an economy. It has also found use in insurance, web page access statistics, oil field sizes, and many other problems, including the download frequency for projects in Sourceforge &lt;a href=&quot;#rc338d9f74bfc-1&quot; id=&quot;id1&quot;&gt;[1]&lt;/a&gt;. It is one of the so-called &amp;ldquo;fat-tailed&amp;rdquo; distributions.</source>
          <target state="translated">Распределение Парето, названное в честь итальянского экономиста Вильфредо Парето, представляет собой степенное распределение вероятностей, которое можно использовать во многих реальных проблемах. За пределами области экономики его обычно называют распределением Брэдфорда. Парето разработал распределение для описания распределения богатства в экономике. Он также нашел применение в страховании, статистике доступа к веб-страницам, размерах нефтяных месторождений и во многих других задачах, включая частоту загрузки проектов в Sourceforge &lt;a href=&quot;#rc338d9f74bfc-1&quot; id=&quot;id1&quot;&gt;[1]&lt;/a&gt; . Это одно из так называемых распределений с толстым хвостом.</target>
        </trans-unit>
        <trans-unit id="8aa87161535a17c7b4517b9679a26277a14402b5" translate="yes" xml:space="preserve">
          <source>The Poisson distribution</source>
          <target state="translated">Распределение Пуассона</target>
        </trans-unit>
        <trans-unit id="0ebdde94b2528198e1aa6a1394f362ff4a94706c" translate="yes" xml:space="preserve">
          <source>The Poisson distribution is the limit of the binomial distribution for large N.</source>
          <target state="translated">Распределение Пуассона является пределом биномиального распределения для больших N.</target>
        </trans-unit>
        <trans-unit id="9280ad29766a65718d4060a0ccabd4c148a5c905" translate="yes" xml:space="preserve">
          <source>The Polynomial class provides the standard Python numerical methods &amp;lsquo;+&amp;rsquo;, &amp;lsquo;-&amp;lsquo;, &amp;lsquo;*&amp;rsquo;, &amp;lsquo;//&amp;rsquo;, &amp;lsquo;%&amp;rsquo;, &amp;lsquo;divmod&amp;rsquo;, &amp;lsquo;**&amp;rsquo;, and &amp;lsquo;()&amp;rsquo; as well as the attributes and methods listed in the &lt;code&gt;ABCPolyBase&lt;/code&gt; documentation.</source>
          <target state="translated">Класс Polynomial предоставляет стандартные числовые методы Python '+', '-', '*', '//', '%', 'divmod', '**' и '()', а также атрибуты и методы, перечисленные в документации &lt;code&gt;ABCPolyBase&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="827ba55564ba45b324c36aacf3e17c27674e9dcd" translate="yes" xml:space="preserve">
          <source>The PyArrayInterface structure had no descr member at the end (and therefore no flag ARR_HAS_DESCR)</source>
          <target state="translated">Структура PyArrayInterface не имела члена descr в конце (и,следовательно,флага ARR_HAS_DESCR).</target>
        </trans-unit>
        <trans-unit id="41d158f9c0cb59631db3742cfa40b5047248d25c" translate="yes" xml:space="preserve">
          <source>The PyArrayInterface structure is defined in &lt;code&gt;numpy/ndarrayobject.h&lt;/code&gt; as:</source>
          <target state="translated">Структура PyArrayInterface определяется в &lt;code&gt;numpy/ndarrayobject.h&lt;/code&gt; как:</target>
        </trans-unit>
        <trans-unit id="5f9e4e5af356a67d9cce5fec6bebfc002a3fe5b0" translate="yes" xml:space="preserve">
          <source>The Python exposure supplies two iteration interfaces, one which follows the Python iterator protocol, and another which mirrors the C-style do-while pattern. The native Python approach is better in most cases, but if you need the coordinates or index of an iterator, use the C-style pattern.</source>
          <target state="translated">Python экспозиция обеспечивает два итерационных интерфейса,один из которых следует протоколу итератора Python,и другой,который зеркально отображает картину в стиле C,тем временем.Нативный подход к Python в большинстве случаев лучше,но если вам нужны координаты или индекс итератора,используйте шаблон в стиле C.</target>
        </trans-unit>
        <trans-unit id="52c071d4e6dd56561ca8fc870ab3c5e829454e91" translate="yes" xml:space="preserve">
          <source>The Python function &lt;code&gt;max()&lt;/code&gt; will find the maximum over a one-dimensional array, but it will do so using a slower sequence interface. The reduce method of the maximum ufunc is much faster. Also, the &lt;code&gt;max()&lt;/code&gt; method will not give answers you might expect for arrays with greater than one dimension. The reduce method of minimum also allows you to compute a total minimum over an array.</source>
          <target state="translated">Функция Python &lt;code&gt;max()&lt;/code&gt; найдет максимум для одномерного массива, но сделает это с помощью более медленного интерфейса последовательности. Метод сокращения максимального ufunc намного быстрее. Кроме того, метод &lt;code&gt;max()&lt;/code&gt; не даст ответов, которые вы могли бы ожидать для массивов с более чем одним измерением. Метод уменьшения минимума также позволяет вам вычислять общий минимум по массиву.</target>
        </trans-unit>
        <trans-unit id="faf8bfa039d6b92e8c05db35a7f948162088fe3f" translate="yes" xml:space="preserve">
          <source>The Python interactive interpreter unfortunately prints out the values of expressions inside the while loop during each iteration of the loop. We have modified the output in the examples using this looping construct in order to be more readable.</source>
          <target state="translated">Интерактивный интерпретатор Python,к сожалению,распечатывает значения выражений внутри цикла while во время каждой итерации цикла.Мы изменили вывод в примерах,используя эту конструкцию петли,чтобы быть более читабельным.</target>
        </trans-unit>
        <trans-unit id="4b9b366242a59401489f5a3a46b627dbab76f505" translate="yes" xml:space="preserve">
          <source>The Python interface that we want is:</source>
          <target state="translated">Интерфейс Python,который нам нужен:</target>
        </trans-unit>
        <trans-unit id="a4e789fdc99a292c8a541209ecbc17b1d6c5f8c7" translate="yes" xml:space="preserve">
          <source>The Python iterator protocol doesn&amp;rsquo;t have a natural way to query these additional values from the iterator, so we introduce an alternate syntax for iterating with an &lt;a href=&quot;generated/numpy.nditer#numpy.nditer&quot;&gt;&lt;code&gt;nditer&lt;/code&gt;&lt;/a&gt;. This syntax explicitly works with the iterator object itself, so its properties are readily accessible during iteration. With this looping construct, the current value is accessible by indexing into the iterator, and the index being tracked is the property &lt;code&gt;index&lt;/code&gt; or &lt;code&gt;multi_index&lt;/code&gt; depending on what was requested.</source>
          <target state="translated">Протокол итератора Python не имеет естественного способа запрашивать эти дополнительные значения у итератора, поэтому мы вводим альтернативный синтаксис для итерации с помощью &lt;a href=&quot;generated/numpy.nditer#numpy.nditer&quot;&gt; &lt;code&gt;nditer&lt;/code&gt; &lt;/a&gt; . Этот синтаксис явно работает с самим объектом итератора, поэтому его свойства легко доступны во время итерации. С этой циклической конструкцией текущее значение доступно путем индексации в итераторе, а отслеживаемый индекс - это &lt;code&gt;index&lt;/code&gt; свойства или &lt;code&gt;multi_index&lt;/code&gt; в зависимости от того, что было запрошено.</target>
        </trans-unit>
        <trans-unit id="6867d7144d35416337495ca1b602061770d80f10" translate="yes" xml:space="preserve">
          <source>The Python list representation of the masked array.</source>
          <target state="translated">Представление списка Python массива по маске.</target>
        </trans-unit>
        <trans-unit id="10730a9ceb03252e7c33bf729de07821aa7c70e5" translate="yes" xml:space="preserve">
          <source>The Python object this chunk of memory comes from. Needed so that memory can be accounted for properly.</source>
          <target state="translated">Объект Python,откуда взялся этот кусок памяти.Нужно для того,чтобы память могла быть учтена правильно.</target>
        </trans-unit>
        <trans-unit id="8a0585dac865895f74c0e37d281119c6e2073a73" translate="yes" xml:space="preserve">
          <source>The Python stdlib module &amp;ldquo;random&amp;rdquo; also contains a Mersenne Twister pseudo-random number generator with a number of methods that are similar to the ones available in &lt;a href=&quot;#numpy.random.mtrand.RandomState&quot;&gt;&lt;code&gt;RandomState&lt;/code&gt;&lt;/a&gt;. &lt;a href=&quot;#numpy.random.mtrand.RandomState&quot;&gt;&lt;code&gt;RandomState&lt;/code&gt;&lt;/a&gt;, besides being NumPy-aware, has the advantage that it provides a much larger number of probability distributions to choose from.</source>
          <target state="translated">Модуль Python stdlib &amp;laquo;random&amp;raquo; также содержит генератор псевдослучайных чисел Mersenne Twister с рядом методов, аналогичных тем, которые доступны в &lt;a href=&quot;#numpy.random.mtrand.RandomState&quot;&gt; &lt;code&gt;RandomState&lt;/code&gt; &lt;/a&gt; . &lt;a href=&quot;#numpy.random.mtrand.RandomState&quot;&gt; &lt;code&gt;RandomState&lt;/code&gt; &lt;/a&gt; , помимо того, что он знает NumPy, имеет то преимущество, что он предоставляет гораздо большее количество распределений вероятностей на выбор.</target>
        </trans-unit>
        <trans-unit id="e2bba830daa553cb7faa782d38dcb55b1552bd1f" translate="yes" xml:space="preserve">
          <source>The Python stdlib module &amp;ldquo;random&amp;rdquo; also contains a Mersenne Twister pseudo-random number generator.</source>
          <target state="translated">Модуль Python stdlib &amp;laquo;random&amp;raquo; также содержит генератор псевдослучайных чисел Mersenne Twister.</target>
        </trans-unit>
        <trans-unit id="d16bb9351563ad26c9ac5328e3a25381d78f799b" translate="yes" xml:space="preserve">
          <source>The Python stdlib module &lt;a href=&quot;generated/numpy.random.generator.random#numpy.random.Generator.random&quot;&gt;&lt;code&gt;random&lt;/code&gt;&lt;/a&gt; contains pseudo-random number generator with a number of methods that are similar to the ones available in &lt;code&gt;Generator&lt;/code&gt;. It uses Mersenne Twister, and this bit generator can be accessed using &lt;code&gt;MT19937&lt;/code&gt;. &lt;code&gt;Generator&lt;/code&gt;, besides being NumPy-aware, has the advantage that it provides a much larger number of probability distributions to choose from.</source>
          <target state="translated">Модуль Python stdlib &lt;a href=&quot;generated/numpy.random.generator.random#numpy.random.Generator.random&quot;&gt; &lt;code&gt;random&lt;/code&gt; &lt;/a&gt; содержит генератор псевдослучайных чисел с рядом методов, аналогичных тем, которые доступны в &lt;code&gt;Generator&lt;/code&gt; . Он использует Mersenne Twister, и к этому генератору бит можно получить доступ с помощью &lt;code&gt;MT19937&lt;/code&gt; . &lt;code&gt;Generator&lt;/code&gt; , помимо того, что он поддерживает NumPy, имеет то преимущество, что он предоставляет гораздо большее количество распределений вероятностей на выбор.</target>
        </trans-unit>
        <trans-unit id="bbfe8c34ab4f057b17acc33f18a11bfdb2e17b46" translate="yes" xml:space="preserve">
          <source>The Python type of the ndarray is &lt;a href=&quot;#c.PyArray_Type&quot;&gt;&lt;code&gt;PyArray_Type&lt;/code&gt;&lt;/a&gt;. In C, every ndarray is a pointer to a &lt;a href=&quot;#c.PyArrayObject&quot;&gt;&lt;code&gt;PyArrayObject&lt;/code&gt;&lt;/a&gt; structure. The ob_type member of this structure contains a pointer to the &lt;a href=&quot;#c.PyArray_Type&quot;&gt;&lt;code&gt;PyArray_Type&lt;/code&gt;&lt;/a&gt; typeobject.</source>
          <target state="translated">Тип Python для ndarray - &lt;a href=&quot;#c.PyArray_Type&quot;&gt; &lt;code&gt;PyArray_Type&lt;/code&gt; &lt;/a&gt; . В C каждый ndarray является указателем на структуру &lt;a href=&quot;#c.PyArrayObject&quot;&gt; &lt;code&gt;PyArrayObject&lt;/code&gt; &lt;/a&gt; . Член ob_type этой структуры содержит указатель на &lt;a href=&quot;#c.PyArray_Type&quot;&gt; &lt;code&gt;PyArray_Type&lt;/code&gt; &lt;/a&gt; PyArray_Type.</target>
        </trans-unit>
        <trans-unit id="92e614f1f8b5e40429cf0717c65db8d5a132db4d" translate="yes" xml:space="preserve">
          <source>The Rayleigh distribution would arise, for example, if the East and North components of the wind velocity had identical zero-mean Gaussian distributions. Then the wind speed would have a Rayleigh distribution.</source>
          <target state="translated">Релевое распределение возникло бы,например,если бы восточная и северная компоненты скорости ветра имели одинаковые нулевые среднегауссовые распределения.Тогда бы скорость ветра имела релеевское распределение.</target>
        </trans-unit>
        <trans-unit id="0175f443d47358199cf2723ff7e49526482ab828" translate="yes" xml:space="preserve">
          <source>The Simple Wrapper and Interface Generator (or &lt;a href=&quot;http://www.swig.org&quot;&gt;SWIG&lt;/a&gt;) is a powerful tool for generating wrapper code for interfacing to a wide variety of scripting languages. &lt;a href=&quot;http://www.swig.org&quot;&gt;SWIG&lt;/a&gt; can parse header files, and using only the code prototypes, create an interface to the target language. But &lt;a href=&quot;http://www.swig.org&quot;&gt;SWIG&lt;/a&gt; is not omnipotent. For example, it cannot know from the prototype:</source>
          <target state="translated">Simple Wrapper and Interface Generator (или &lt;a href=&quot;http://www.swig.org&quot;&gt;SWIG&lt;/a&gt; ) - мощный инструмент для генерации кода оболочки для взаимодействия с широким спектром языков сценариев. &lt;a href=&quot;http://www.swig.org&quot;&gt;SWIG&lt;/a&gt; может анализировать файлы заголовков и, используя только прототипы кода, создавать интерфейс для целевого языка. Но &lt;a href=&quot;http://www.swig.org&quot;&gt;SWIG&lt;/a&gt; не всемогущ. Например, он не может узнать из прототипа:</target>
        </trans-unit>
        <trans-unit id="3486112e5f71acaa9b7cc7fff52d1dbfa7f50dd3" translate="yes" xml:space="preserve">
          <source>The Vandermonde matrix. The shape of the returned matrix is &lt;code&gt;x.shape + (deg + 1,)&lt;/code&gt;, where the last index is the power of &lt;code&gt;x&lt;/code&gt;. The dtype will be the same as the converted &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="translated">Матрица Вандермонда. Форма возвращаемой матрицы - &lt;code&gt;x.shape + (deg + 1,)&lt;/code&gt; , где последний индекс - это степень &lt;code&gt;x&lt;/code&gt; . Dtype будет таким же, как преобразованный &lt;code&gt;x&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="39a7c567f58b9f21ca516451a55bb90e053dd395" translate="yes" xml:space="preserve">
          <source>The Weibull (or Type III asymptotic extreme value distribution for smallest values, SEV Type III, or Rosin-Rammler distribution) is one of a class of Generalized Extreme Value (GEV) distributions used in modeling extreme value problems. This class includes the Gumbel and Frechet distributions.</source>
          <target state="translated">Распределение экстремальных значений Weibull (или асимптотическое распределение экстремальных значений типа III для наименьших значений,SEV Type III,или распределение Rosin-Rammler)является одним из классов обобщенных распределений экстремальных значений (GEV),используемых при моделировании задач с экстремальными значениями.Этот класс включает в себя распределения Гумбеля и Фреше.</target>
        </trans-unit>
        <trans-unit id="201b34b560ffa9f638b13b95cb2b860322d162bb" translate="yes" xml:space="preserve">
          <source>The Zipf distribution (also known as the zeta distribution) is a continuous probability distribution that satisfies Zipf&amp;rsquo;s law: the frequency of an item is inversely proportional to its rank in a frequency table.</source>
          <target state="translated">Распределение Ципфа (также известное как дзета-распределение) - это непрерывное распределение вероятностей, которое удовлетворяет закону Ципфа: частота элемента обратно пропорциональна его рангу в таблице частот.</target>
        </trans-unit>
        <trans-unit id="cb048510e93bd94f0172757e215cb9cb29cef573" translate="yes" xml:space="preserve">
          <source>The ability to be used as a context manager is new in NumPy v1.11.0.</source>
          <target state="translated">Возможность использования в качестве контекстного менеджера появилась в NumPy v1.11.0.</target>
        </trans-unit>
        <trans-unit id="10ff963859461b5262a67238fd0cc7b697172b26" translate="yes" xml:space="preserve">
          <source>The above does not hold for in-place operators, for which &lt;a href=&quot;generated/numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;ndarray&lt;/code&gt;&lt;/a&gt; never returns &lt;a href=&quot;https://docs.python.org/dev/library/constants.html#NotImplemented&quot;&gt;&lt;code&gt;NotImplemented&lt;/code&gt;&lt;/a&gt;. Hence, &lt;code&gt;arr += obj&lt;/code&gt; would always lead to a &lt;a href=&quot;https://docs.python.org/dev/library/exceptions.html#TypeError&quot;&gt;&lt;code&gt;TypeError&lt;/code&gt;&lt;/a&gt;. This is because for arrays in-place operations cannot generically be replaced by a simple reverse operation. (For instance, by default, &lt;code&gt;arr += obj&lt;/code&gt; would be translated to &lt;code&gt;arr =
arr + obj&lt;/code&gt;, i.e., &lt;code&gt;arr&lt;/code&gt; would be replaced, contrary to what is expected for in-place array operations.)</source>
          <target state="translated">Вышеупомянутое не относится к операторам на месте, для которых &lt;a href=&quot;generated/numpy.ndarray#numpy.ndarray&quot;&gt; &lt;code&gt;ndarray&lt;/code&gt; &lt;/a&gt; никогда не возвращает &lt;a href=&quot;https://docs.python.org/dev/library/constants.html#NotImplemented&quot;&gt; &lt;code&gt;NotImplemented&lt;/code&gt; &lt;/a&gt; . Следовательно, &lt;code&gt;arr += obj&lt;/code&gt; всегда будет приводить к &lt;a href=&quot;https://docs.python.org/dev/library/exceptions.html#TypeError&quot;&gt; &lt;code&gt;TypeError&lt;/code&gt; &lt;/a&gt; . Это связано с тем, что операции с массивами на месте в общем случае не могут быть заменены простой обратной операцией. (Например, по умолчанию &lt;code&gt;arr += obj&lt;/code&gt; будет преобразовано в &lt;code&gt;arr = arr + obj&lt;/code&gt; , то есть &lt;code&gt;arr&lt;/code&gt; будет заменено, в отличие от того, что ожидается для операций с массивами на месте.)</target>
        </trans-unit>
        <trans-unit id="68e86910bcee8988f5fee730ecb24162fd22e6a7" translate="yes" xml:space="preserve">
          <source>The above equation is not symmetric in &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt;, so that &lt;code&gt;allclose(a, b)&lt;/code&gt; might be different from &lt;code&gt;allclose(b, a)&lt;/code&gt; in some rare cases.</source>
          <target state="translated">Приведенное выше уравнение не является симметричным по &lt;code&gt;a&lt;/code&gt; и &lt;code&gt;b&lt;/code&gt; , поэтому &lt;code&gt;allclose(a, b)&lt;/code&gt; может отличаться от &lt;code&gt;allclose(b, a)&lt;/code&gt; в некоторых редких случаях.</target>
        </trans-unit>
        <trans-unit id="6185045f653324c861d3553f34d55db24911888b" translate="yes" xml:space="preserve">
          <source>The above is &lt;strong&gt;not&lt;/strong&gt; true for advanced indexing.</source>
          <target state="translated">Выше &lt;strong&gt;не&lt;/strong&gt; относится к расширенному индексации.</target>
        </trans-unit>
        <trans-unit id="21db79b1f2f5936ea0ef3cfbbfc9697c308c56be" translate="yes" xml:space="preserve">
          <source>The above rules may be clearer in the following template source example:</source>
          <target state="translated">Вышеприведенные правила могут быть более понятными в следующем примере источника шаблона:</target>
        </trans-unit>
        <trans-unit id="bbd30ffed27aefb02b7cc5cbecba164ede0884a8" translate="yes" xml:space="preserve">
          <source>The absolute tolerance parameter (see Notes).</source>
          <target state="translated">Абсолютный параметр допуска (см.Примечания).</target>
        </trans-unit>
        <trans-unit id="b410151dc56a82d87375b78c87d1aad1438a967a" translate="yes" xml:space="preserve">
          <source>The absolute values of &lt;code&gt;x&lt;/code&gt;, the returned values are always floats. This is a scalar if &lt;code&gt;x&lt;/code&gt; is a scalar.</source>
          <target state="translated">Абсолютные значения &lt;code&gt;x&lt;/code&gt; , возвращаемые значения всегда являются плавающими. Это скаляр, если &lt;code&gt;x&lt;/code&gt; - скаляр.</target>
        </trans-unit>
        <trans-unit id="a714cd42c4750db7daf108e375247bf95502ae46" translate="yes" xml:space="preserve">
          <source>The accumulate function is very similar to the reduce function in that the output and the second input both point to the output. The difference is that the second input points to memory one stride behind the current output pointer. Thus, the operation performed is</source>
          <target state="translated">Функция накопления очень похожа на функцию уменьшения в том,что выход и второй вход оба указывают на выход.Разница состоит в том,что второй вход указывает на память на один шаг позади текущего указателя выхода.Таким образом,выполняется операция</target>
        </trans-unit>
        <trans-unit id="09fde86411dc88385ee0c9001b20e47aa778341c" translate="yes" xml:space="preserve">
          <source>The accumulated values. If &lt;code&gt;out&lt;/code&gt; was supplied, &lt;code&gt;r&lt;/code&gt; is a reference to &lt;code&gt;out&lt;/code&gt;.</source>
          <target state="translated">Накопленные значения. Если был предоставлен &lt;code&gt;out&lt;/code&gt; , &lt;code&gt;r&lt;/code&gt; является ссылкой на &lt;code&gt;out&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ea47ba00873e187022bea737541efbc8a18ba099" translate="yes" xml:space="preserve">
          <source>The actual object to check.</source>
          <target state="translated">Фактический объект для проверки.</target>
        </trans-unit>
        <trans-unit id="2c2156efeae8cdcc13e079cd68ed8ee62442ae55" translate="yes" xml:space="preserve">
          <source>The actual testing takes place with a Python script named:</source>
          <target state="translated">Фактическое тестирование происходит с именем скрипта Python:</target>
        </trans-unit>
        <trans-unit id="e611ef52ce3f87e2cae1cb595f38cf187d2711d5" translate="yes" xml:space="preserve">
          <source>The advanced indexes are all next to each other. For example &lt;code&gt;x[..., arr1, arr2, :]&lt;/code&gt; but &lt;em&gt;not&lt;/em&gt;&lt;code&gt;x[arr1, :, 1]&lt;/code&gt; since &lt;code&gt;1&lt;/code&gt; is an advanced index in this regard.</source>
          <target state="translated">Все расширенные индексы расположены рядом друг с другом. Например, &lt;code&gt;x[..., arr1, arr2, :]&lt;/code&gt; но &lt;em&gt;не &lt;/em&gt; &lt;code&gt;x[arr1, :, 1]&lt;/code&gt; поскольку &lt;code&gt;1&lt;/code&gt; является расширенным индексом в этом отношении.</target>
        </trans-unit>
        <trans-unit id="31c1e1991e0db334efbc077fcf4425ba78851bf7" translate="yes" xml:space="preserve">
          <source>The advanced indexes are separated by a slice, &lt;code&gt;Ellipsis&lt;/code&gt; or &lt;a href=&quot;constants#numpy.newaxis&quot;&gt;&lt;code&gt;newaxis&lt;/code&gt;&lt;/a&gt;. For example &lt;code&gt;x[arr1, :, arr2]&lt;/code&gt;.</source>
          <target state="translated">Расширенные индексы разделяются срезом, &lt;code&gt;Ellipsis&lt;/code&gt; или &lt;a href=&quot;constants#numpy.newaxis&quot;&gt; &lt;code&gt;newaxis&lt;/code&gt; &lt;/a&gt; . Например, &lt;code&gt;x[arr1, :, arr2]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e14666a8704d081387416d669f25517240f5f545" translate="yes" xml:space="preserve">
          <source>The aim of this document is to describe how to add new tools to SciPy.</source>
          <target state="translated">Цель этого документа-описать,как добавлять новые инструменты в SciPy.</target>
        </trans-unit>
        <trans-unit id="ddbe83e4c507cabc5c6e4f89a6b5af846c612df5" translate="yes" xml:space="preserve">
          <source>The algorithm is carefully designed to eliminate a number of possible ways to collide. For example, if one only does one level of spawning, it is guaranteed that all states will be unique. But it&amp;rsquo;s easier to estimate the naive upper bound on a napkin and take comfort knowing that the probability is actually lower.</source>
          <target state="translated">Алгоритм тщательно разработан, чтобы исключить ряд возможных способов столкновения. Например, если выполняется только один уровень нереста, гарантируется, что все состояния будут уникальными. Но проще оценить наивную верхнюю границу на салфетке и успокоиться, зная, что вероятность на самом деле ниже.</target>
        </trans-unit>
        <trans-unit id="31b40688fb93dbcbc32e9b43e4ccf1abfa448a2d" translate="yes" xml:space="preserve">
          <source>The algorithm relies on computing the eigenvalues of the companion matrix &lt;a href=&quot;#r01a8f58ef25b-1&quot; id=&quot;id1&quot;&gt;[1]&lt;/a&gt;.</source>
          <target state="translated">Алгоритм основан на вычислении собственных значений сопутствующей матрицы &lt;a href=&quot;#r01a8f58ef25b-1&quot; id=&quot;id1&quot;&gt;[1]&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="ddd22305ce6ff69cc69c0e35a34dfdaaddbe6b6d" translate="yes" xml:space="preserve">
          <source>The algorithm works by first finding a &amp;ldquo;running dimension&amp;rdquo;, along which the blocks will be extracted. Given an array of dimensions &lt;code&gt;(d1, d2, ..., dn)&lt;/code&gt;, e.g. if &lt;code&gt;buf_size&lt;/code&gt; is smaller than &lt;code&gt;d1&lt;/code&gt;, the first dimension will be used. If, on the other hand, &lt;code&gt;d1 &amp;lt; buf_size &amp;lt; d1*d2&lt;/code&gt; the second dimension will be used, and so on. Blocks are extracted along this dimension, and when the last block is returned the process continues from the next dimension, until all elements have been read.</source>
          <target state="translated">Алгоритм работает, сначала находя &amp;laquo;бегущее измерение&amp;raquo;, по которому будут извлекаться блоки. Учитывая массив измерений &lt;code&gt;(d1, d2, ..., dn)&lt;/code&gt; , например, если &lt;code&gt;buf_size&lt;/code&gt; меньше &lt;code&gt;d1&lt;/code&gt; , будет использоваться первое измерение. Если, с другой стороны, &lt;code&gt;d1 &amp;lt; buf_size &amp;lt; d1*d2&lt;/code&gt; будет использоваться второе измерение и так далее. Блоки извлекаются по этому измерению, и когда возвращается последний блок, процесс продолжается со следующего измерения, пока не будут прочитаны все элементы.</target>
        </trans-unit>
        <trans-unit id="bddd09a9de7b4e7a6ce50c8c2ab936314f5f7ae0" translate="yes" xml:space="preserve">
          <source>The angle of the ray intersecting the unit circle at the given &lt;code&gt;x&lt;/code&gt;-coordinate in radians [0, pi]. This is a scalar if &lt;code&gt;x&lt;/code&gt; is a scalar.</source>
          <target state="translated">Угол луча, пересекающего единичный круг в данной координате &lt;code&gt;x&lt;/code&gt; , в радианах [0, pi]. Это скаляр, если &lt;code&gt;x&lt;/code&gt; - скаляр.</target>
        </trans-unit>
        <trans-unit id="a13da23a8343744c8c54019aa364c899333968f0" translate="yes" xml:space="preserve">
          <source>The anti-diagonal can be filled by reversing the order of elements using either &lt;a href=&quot;numpy.flipud#numpy.flipud&quot;&gt;&lt;code&gt;numpy.flipud&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;numpy.fliplr#numpy.fliplr&quot;&gt;&lt;code&gt;numpy.fliplr&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;numpy.flipud#numpy.flipud&quot;&gt; &lt;code&gt;numpy.flipud&lt;/code&gt; &lt;/a&gt; можно заполнить, изменив порядок элементов, используя numpy.flipud или &lt;a href=&quot;numpy.fliplr#numpy.fliplr&quot;&gt; &lt;code&gt;numpy.fliplr&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="900a13fc7d937db8f345df515885761fbb0acd80" translate="yes" xml:space="preserve">
          <source>The anti-diagonal can be obtained by reversing the order of elements using either &lt;a href=&quot;numpy.flipud#numpy.flipud&quot;&gt;&lt;code&gt;numpy.flipud&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;numpy.fliplr#numpy.fliplr&quot;&gt;&lt;code&gt;numpy.fliplr&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;numpy.flipud#numpy.flipud&quot;&gt; &lt;code&gt;numpy.flipud&lt;/code&gt; &lt;/a&gt; можно получить, изменив порядок элементов с помощью numpy.flipud или &lt;a href=&quot;numpy.fliplr#numpy.fliplr&quot;&gt; &lt;code&gt;numpy.fliplr&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="bdd6673496c6fd17d43bfb63694d67b1a23e7074" translate="yes" xml:space="preserve">
          <source>The approximate decimal resolution of this type, i.e., &lt;code&gt;10**-precision&lt;/code&gt;.</source>
          <target state="translated">Примерное десятичное разрешение этого типа, т. &lt;code&gt;10**-precision&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a6b2d49779da2fb225e5136c9ad3c68e119d3fee" translate="yes" xml:space="preserve">
          <source>The approximate number of decimal digits to which this kind of float is precise.</source>
          <target state="translated">Ориентировочное количество десятичных цифр,к которым точно относится этот вид поплавка.</target>
        </trans-unit>
        <trans-unit id="0fe8c5bbb5b2bd70ddad0ccf0217bddc268f6835" translate="yes" xml:space="preserve">
          <source>The arguments &lt;code&gt;ngood&lt;/code&gt; and &lt;code&gt;nbad&lt;/code&gt; each must be less than &lt;code&gt;10**9&lt;/code&gt;. For extremely large arguments, the algorithm that is used to compute the samples &lt;a href=&quot;#r688e4aa3bfc3-4&quot; id=&quot;id1&quot;&gt;[4]&lt;/a&gt; breaks down because of loss of precision in floating point calculations. For such large values, if &lt;code&gt;nsample&lt;/code&gt; is not also large, the distribution can be approximated with the binomial distribution, &lt;code&gt;binomial(n=nsample, p=ngood/(ngood + nbad))&lt;/code&gt;.</source>
          <target state="translated">Аргументы &lt;code&gt;ngood&lt;/code&gt; и &lt;code&gt;nbad&lt;/code&gt; каждый должен быть меньше , чем &lt;code&gt;10**9&lt;/code&gt; . Для чрезвычайно больших аргументов алгоритм, используемый для вычисления выборок &lt;a href=&quot;#r688e4aa3bfc3-4&quot; id=&quot;id1&quot;&gt;[4],&lt;/a&gt; не работает из-за потери точности вычислений с плавающей запятой. Для таких больших значений, если &lt;code&gt;nsample&lt;/code&gt; также не велик, распределение может быть аппроксимировано биномиальным распределением, &lt;code&gt;binomial(n=nsample, p=ngood/(ngood + nbad))&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2d355dbffda7b60d25c8fd14c77261de1c537b59" translate="yes" xml:space="preserve">
          <source>The arguments of the &lt;code&gt;configuration&lt;/code&gt; function specify the name of parent SciPy package (&lt;code&gt;parent_package&lt;/code&gt;) and the directory location of the main &lt;code&gt;setup.py&lt;/code&gt; script (&lt;code&gt;top_path&lt;/code&gt;). These arguments, along with the name of the current package, should be passed to the &lt;code&gt;Configuration&lt;/code&gt; constructor.</source>
          <target state="translated">Аргументы функции &lt;code&gt;configuration&lt;/code&gt; указывают имя родительского пакета SciPy ( &lt;code&gt;parent_package&lt;/code&gt; ) и расположение каталога основного скрипта &lt;code&gt;setup.py&lt;/code&gt; ( &lt;code&gt;top_path&lt;/code&gt; ). Эти аргументы вместе с именем текущего пакета следует передать конструктору &lt;code&gt;Configuration&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9b1212b40ba5f9b8205d7b64e2e9c20d35b415b3" translate="yes" xml:space="preserve">
          <source>The arithmetic mean is the sum of the elements along the axis divided by the number of elements.</source>
          <target state="translated">Среднее арифметическое-это сумма элементов вдоль оси,деленная на количество элементов.</target>
        </trans-unit>
        <trans-unit id="149dc5ada110e245afebc011f82badc7bfaf2c21" translate="yes" xml:space="preserve">
          <source>The arithmetic mean is the sum of the non-NaN elements along the axis divided by the number of non-NaN elements.</source>
          <target state="translated">Среднее арифметическое-это сумма не NaN-элементов вдоль оси,деленная на количество не NaN-элементов.</target>
        </trans-unit>
        <trans-unit id="a686d6fd794f1b48b235aeae1a3e22a10c775aa4" translate="yes" xml:space="preserve">
          <source>The array &lt;code&gt;v&lt;/code&gt; of eigenvectors may not be of maximum rank, that is, some of the columns may be linearly dependent, although round-off error may obscure that fact. If the eigenvalues are all different, then theoretically the eigenvectors are linearly independent. Likewise, the (complex-valued) matrix of eigenvectors &lt;code&gt;v&lt;/code&gt; is unitary if the matrix &lt;code&gt;a&lt;/code&gt; is normal, i.e., if &lt;code&gt;dot(a, a.H) = dot(a.H, a)&lt;/code&gt;, where &lt;code&gt;a.H&lt;/code&gt; denotes the conjugate transpose of &lt;code&gt;a&lt;/code&gt;.</source>
          <target state="translated">Массив &lt;code&gt;v&lt;/code&gt; собственных векторов может не иметь максимального ранга, то есть некоторые столбцы могут быть линейно зависимыми, хотя ошибка округления может скрыть этот факт. Если собственные значения все разные, то теоретически собственные векторы линейно независимы. Аналогично, (комплексная) матрица собственных векторов &lt;code&gt;v&lt;/code&gt; является унитарной, если матрица &lt;code&gt;a&lt;/code&gt; нормальна, т.е. если &lt;code&gt;dot(a, a.H) = dot(a.H, a)&lt;/code&gt; , где &lt;code&gt;a.H&lt;/code&gt; обозначает сопряженное транспонирование &lt;code&gt;a&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="539630988d5b7ef9eff53456e4a77b468fdbbd35" translate="yes" xml:space="preserve">
          <source>The array &lt;code&gt;x&lt;/code&gt; is prefilled with its filling value.</source>
          <target state="translated">Массив &lt;code&gt;x&lt;/code&gt; предварительно заполняется значением заполнения.</target>
        </trans-unit>
        <trans-unit id="048ae46227673b90cff5c0388062d4ed48f2b030" translate="yes" xml:space="preserve">
          <source>The array assembled from the given blocks.</source>
          <target state="translated">Массив,собранный из данных блоков.</target>
        </trans-unit>
        <trans-unit id="f6532b7ade94739e158787e37c1d9655afff859b" translate="yes" xml:space="preserve">
          <source>The array can be indexed using Python container-like syntax:</source>
          <target state="translated">Массив может быть проиндексирован с использованием контейнероподобного синтаксиса Python:</target>
        </trans-unit>
        <trans-unit id="a7b308d78b11f2c07c75c1db0756393dc3ae53a1" translate="yes" xml:space="preserve">
          <source>The array data-type or scalar for which the default fill value is returned.</source>
          <target state="translated">Тип данных массива или скаляр,для которого возвращается значение заполнения по умолчанию.</target>
        </trans-unit>
        <trans-unit id="3821c84ea0df179e936beb82ec9c4a845023032b" translate="yes" xml:space="preserve">
          <source>The array element of the current iteration.</source>
          <target state="translated">Элемент массива текущей итерации.</target>
        </trans-unit>
        <trans-unit id="930ed301b34bfc297be655fe9a537d3e2971d137" translate="yes" xml:space="preserve">
          <source>The array flags cannot be set arbitrarily:</source>
          <target state="translated">Флаги массива не могут быть установлены произвольно:</target>
        </trans-unit>
        <trans-unit id="67bdbd5d8bcbe5caab95cc4d4f8dabba43280775" translate="yes" xml:space="preserve">
          <source>The array for which the string representation of the pickle is returned.</source>
          <target state="translated">Массив,для которого возвращается строковое представление пикули.</target>
        </trans-unit>
        <trans-unit id="2a33c6111cdd8f36d42a5e94437f624d1b58746f" translate="yes" xml:space="preserve">
          <source>The array for which to count non-zeros.</source>
          <target state="translated">Массив,для которого нужно считать ненулевые.</target>
        </trans-unit>
        <trans-unit id="ceccbd318dae2746e4f8b98dac923588a6a52441" translate="yes" xml:space="preserve">
          <source>The array formed by stacking the given arrays, will be at least 2-D.</source>
          <target state="translated">Массив,формируемый путем суммирования данных массивов,будет не менее 2-D.</target>
        </trans-unit>
        <trans-unit id="2568bf2e437e715b60f945dc9695881ce8ef667f" translate="yes" xml:space="preserve">
          <source>The array formed by stacking the given arrays, will be at least 3-D.</source>
          <target state="translated">Массив,формируемый путем суммирования данных массивов,будет не менее 3-D.</target>
        </trans-unit>
        <trans-unit id="b2c061ec289a87d3c0d4e9e7c64e5126014d42ed" translate="yes" xml:space="preserve">
          <source>The array formed by stacking the given arrays.</source>
          <target state="translated">Массив,сформированный путем суммирования данных массивов.</target>
        </trans-unit>
        <trans-unit id="8e505b1ebbfcf9d9aa6a8f699f88f4ba40304f40" translate="yes" xml:space="preserve">
          <source>The array from which values are copied.</source>
          <target state="translated">Массив,из которого копируются значения.</target>
        </trans-unit>
        <trans-unit id="7c8fb39bbbe950fa5ba32f6dec4764ff1752adf1" translate="yes" xml:space="preserve">
          <source>The array h contains the Householder reflectors that generate q along with r. The tau array contains scaling factors for the reflectors. In the deprecated &amp;lsquo;economic&amp;rsquo; mode only h is returned.</source>
          <target state="translated">Массив h содержит отражатели Хаусхолдера, которые генерируют q вместе с r. Тау-массив содержит масштабные коэффициенты для отражателей. В устаревшем &amp;laquo;экономичном&amp;raquo; режиме возвращается только h.</target>
        </trans-unit>
        <trans-unit id="d2932d4203636051c0cde3cab914ac5caf308f90" translate="yes" xml:space="preserve">
          <source>The array interface (sometimes called array protocol) was created in 2005 as a means for array-like Python objects to re-use each other&amp;rsquo;s data buffers intelligently whenever possible. The homogeneous N-dimensional array interface is a default mechanism for objects to share N-dimensional array memory and information. The interface consists of a Python-side and a C-side using two attributes. Objects wishing to be considered an N-dimensional array in application code should support at least one of these attributes. Objects wishing to support an N-dimensional array in application code should look for at least one of these attributes and use the information provided appropriately.</source>
          <target state="translated">Интерфейс массива (иногда называемый протоколом массива) был создан в 2005 году для того, чтобы объекты Python, подобные массивам, могли разумно повторно использовать буферы данных друг друга, когда это возможно. Интерфейс однородного N-мерного массива - это механизм по умолчанию, позволяющий объектам совместно использовать память и информацию о N-мерном массиве. Интерфейс состоит из стороны Python и стороны C, использующих два атрибута. Объекты, которые должны рассматриваться в коде приложения как N-мерный массив, должны поддерживать хотя бы один из этих атрибутов. Объекты, желающие поддерживать N-мерный массив в коде приложения, должны искать хотя бы один из этих атрибутов и использовать предоставленную информацию соответствующим образом.</target>
        </trans-unit>
        <trans-unit id="3b7adbdac3eaf5c6305f1f61b91018f4287bec67" translate="yes" xml:space="preserve">
          <source>The array into which values are copied.</source>
          <target state="translated">Массив,в который копируются значения.</target>
        </trans-unit>
        <trans-unit id="8a281d694c98742955f6444ee26a08d74603ea7a" translate="yes" xml:space="preserve">
          <source>The array is filled with a fill value before the string conversion.</source>
          <target state="translated">Перед преобразованием строки массив заполняется значением fill.</target>
        </trans-unit>
        <trans-unit id="fba8708c42061e69f757d72f0e5d1d004653f4bc" translate="yes" xml:space="preserve">
          <source>The array is rotated in the plane defined by the axes. Axes must be different.</source>
          <target state="translated">Массив поворачивается в плоскости,определенной осями.Оси должны быть разными.</target>
        </trans-unit>
        <trans-unit id="9a1223a8243cbae9aaa7753c7ea500a550cf52c0" translate="yes" xml:space="preserve">
          <source>The array iterator encapsulates many of the key features in ufuncs, allowing user code to support features like output parameters, preservation of memory layouts, and buffering of data with the wrong alignment or type, without requiring difficult coding.</source>
          <target state="translated">Итератор массивов инкапсулирует многие ключевые функции в ufuncs,позволяя коду пользователя поддерживать такие функции,как выходные параметры,сохранение макетов памяти и буферизацию данных с неправильным выравниванием или типом,не требуя сложного кодирования.</target>
        </trans-unit>
        <trans-unit id="c6e1241b8c7d132ea91621f870c2bd3aaf572b4c" translate="yes" xml:space="preserve">
          <source>The array may be recreated via &lt;code&gt;a = np.array(a.tolist())&lt;/code&gt;, although this may sometimes lose precision.</source>
          <target state="translated">Массив можно воссоздать с помощью &lt;code&gt;a = np.array(a.tolist())&lt;/code&gt; , хотя иногда это может привести к потере точности.</target>
        </trans-unit>
        <trans-unit id="1eee9d9d69514705c81523ac5b902691363a28a0" translate="yes" xml:space="preserve">
          <source>The array of UTC timestamps to format.</source>
          <target state="translated">Массив UTC временных меток для форматирования.</target>
        </trans-unit>
        <trans-unit id="c75d57d539a00e02934380f0ab251d1c277b5e1c" translate="yes" xml:space="preserve">
          <source>The array of dates to process.</source>
          <target state="translated">Массив дат для обработки.</target>
        </trans-unit>
        <trans-unit id="cc2f192e213603a4bcf402844b3339c10f79380e" translate="yes" xml:space="preserve">
          <source>The array of numbers for which the absolute values are required. If &lt;code&gt;x&lt;/code&gt; is a scalar, the result &lt;code&gt;y&lt;/code&gt; will also be a scalar.</source>
          <target state="translated">Массив чисел, для которого требуются абсолютные значения. Если &lt;code&gt;x&lt;/code&gt; - скаляр, результат &lt;code&gt;y&lt;/code&gt; также будет скаляром.</target>
        </trans-unit>
        <trans-unit id="f9c4960d6bbbc8f2591cc039cfe68db4d8e24d90" translate="yes" xml:space="preserve">
          <source>The array of offsets, which is broadcast with &lt;code&gt;dates&lt;/code&gt;.</source>
          <target state="translated">Массив смещений, который транслируется с &lt;code&gt;dates&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2d674fe1383c12f697c52fd3b5198eb57b81bcb7" translate="yes" xml:space="preserve">
          <source>The array of rounded numbers</source>
          <target state="translated">Массив округленных чисел</target>
        </trans-unit>
        <trans-unit id="202adb7679573040b63e561db69df0e93b9eb75e" translate="yes" xml:space="preserve">
          <source>The array of the end dates for counting, which are excluded from the count themselves.</source>
          <target state="translated">Массив конечных дат для подсчета,которые исключаются из самого подсчета.</target>
        </trans-unit>
        <trans-unit id="f508cbbca81c78d6c3819b4c01ca29622bef56f6" translate="yes" xml:space="preserve">
          <source>The array of the first dates for counting.</source>
          <target state="translated">Массив первых дат для подсчета.</target>
        </trans-unit>
        <trans-unit id="a4e03a6eeebaef72c6a7e32f280b123bbf142ff2" translate="yes" xml:space="preserve">
          <source>The array or list to be shuffled.</source>
          <target state="translated">Массив или список,который нужно перетасовать.</target>
        </trans-unit>
        <trans-unit id="1f6abc9406bedaa275a3843a6290b585462b97a3" translate="yes" xml:space="preserve">
          <source>The array or matrix to be repeated.</source>
          <target state="translated">Массив или матрица,которую нужно повторить.</target>
        </trans-unit>
        <trans-unit id="53aead7fb32cb3de7311369b48d13d4953d0adc5" translate="yes" xml:space="preserve">
          <source>The array owns the memory it uses or borrows it from another object.</source>
          <target state="translated">Массив владеет памятью,которую он использует или заимствует у другого объекта.</target>
        </trans-unit>
        <trans-unit id="8abf01fdd64396d234195c26c60e850e4a12a8d7" translate="yes" xml:space="preserve">
          <source>The array scalar objects have an &lt;code&gt;array priority&lt;/code&gt; of &lt;a href=&quot;c-api.array#c.NPY_SCALAR_PRIORITY&quot;&gt;&lt;code&gt;NPY_SCALAR_PRIORITY&lt;/code&gt;&lt;/a&gt; (-1,000,000.0). They also do not (yet) have a &lt;a href=&quot;generated/numpy.ndarray.ctypes#numpy.ndarray.ctypes&quot;&gt;&lt;code&gt;ctypes&lt;/code&gt;&lt;/a&gt; attribute. Otherwise, they share the same attributes as arrays:</source>
          <target state="translated">Объекты массива скалярные имеют &lt;code&gt;array priority&lt;/code&gt; из &lt;a href=&quot;c-api.array#c.NPY_SCALAR_PRIORITY&quot;&gt; &lt;code&gt;NPY_SCALAR_PRIORITY&lt;/code&gt; &lt;/a&gt; (-1,000,000.0). У них также (пока) нет атрибута &lt;a href=&quot;generated/numpy.ndarray.ctypes#numpy.ndarray.ctypes&quot;&gt; &lt;code&gt;ctypes&lt;/code&gt; &lt;/a&gt; . В противном случае они имеют те же атрибуты, что и массивы:</target>
        </trans-unit>
        <trans-unit id="8c0162c81e2783b3bcbb0dd799de5c3ba91aba6a" translate="yes" xml:space="preserve">
          <source>The array scalars also offer the same methods and attributes as arrays with the intent that the same code can be used to support arbitrary dimensions (including 0-dimensions). The array scalars are read-only (immutable) with the exception of the void scalar which can also be written to so that structured array field setting works more naturally (a[0][&amp;lsquo;f1&amp;rsquo;] = &lt;code&gt;value&lt;/code&gt; ).</source>
          <target state="translated">Скаляры массива также предлагают те же методы и атрибуты, что и массивы, с намерением, что один и тот же код может использоваться для поддержки произвольных размеров (включая 0-размерности). Скаляры массива только для чтения (неизменный), за исключением пустот скаляра , которые также могут быть записаны так , что структурированные поля настройка массива работает более естественно (а [0] [ &amp;laquo;f1&amp;raquo;] = &lt;code&gt;value&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="d0afa5fdfdf427a8322c75c5712091eca91eabac" translate="yes" xml:space="preserve">
          <source>The array scalars offer a hierarchy of Python types that allow a one- to-one correspondence between the data-type stored in an array and the Python-type that is returned when an element is extracted from the array. An exception to this rule was made with object arrays. Object arrays are heterogeneous collections of arbitrary Python objects. When you select an item from an object array, you get back the original Python object (and not an object array scalar which does exist but is rarely used for practical purposes).</source>
          <target state="translated">Скаляры массивов предлагают иерархию типов Python,которая позволяет однозначное соответствие между типом данных,хранящимся в массиве,и типом Python,который возвращается,когда элемент извлекается из массива.Исключение из этого правила было сделано для объектных массивов.Массивы объектов представляют собой разнородные наборы произвольных объектов питоновского типа.При выделении элемента из объектного массива возвращается исходный объект Python (а не скаляр объектного массива,который существует,но редко используется для практических целей).</target>
        </trans-unit>
        <trans-unit id="4e947f26c0ecf6d9ff639e9f27b5b5f852135d7e" translate="yes" xml:space="preserve">
          <source>The array to act on.</source>
          <target state="translated">Массив для действий.</target>
        </trans-unit>
        <trans-unit id="7000ca786d20479930ea43aa17e050c42578abc2" translate="yes" xml:space="preserve">
          <source>The array to be pickled.</source>
          <target state="translated">Массив,который будет маринован.</target>
        </trans-unit>
        <trans-unit id="25694c63a056a35911c5654e87ce1708648d0cd3" translate="yes" xml:space="preserve">
          <source>The array to broadcast.</source>
          <target state="translated">Массив для трансляции.</target>
        </trans-unit>
        <trans-unit id="61fa35e69f8b8bb03ffef7462ad7cef9c9cdddeb" translate="yes" xml:space="preserve">
          <source>The array to mask. If not a MaskedArray instance (or if no array elements are masked). The result is a MaskedArray with &lt;code&gt;mask&lt;/code&gt; set to &lt;a href=&quot;../maskedarray.baseclass#numpy.ma.nomask&quot;&gt;&lt;code&gt;nomask&lt;/code&gt;&lt;/a&gt; (False). Must be a 2D array.</source>
          <target state="translated">Маскируемый массив. Если это не экземпляр MaskedArray (или если элементы массива не замаскированы). Результатом является MaskedArray с &lt;code&gt;mask&lt;/code&gt; установленной на &lt;a href=&quot;../maskedarray.baseclass#numpy.ma.nomask&quot;&gt; &lt;code&gt;nomask&lt;/code&gt; &lt;/a&gt; (False). Должен быть 2D-массив.</target>
        </trans-unit>
        <trans-unit id="9a0afda668850edc1a593d4069db9a58418e2d74" translate="yes" xml:space="preserve">
          <source>The array to operate on. If not a MaskedArray instance (or if no array elements are masked), &lt;code&gt;x&lt;/code&gt; is interpreted as a MaskedArray with &lt;code&gt;mask&lt;/code&gt; set to &lt;a href=&quot;../maskedarray.baseclass#numpy.ma.nomask&quot;&gt;&lt;code&gt;nomask&lt;/code&gt;&lt;/a&gt;. Must be a 2D array.</source>
          <target state="translated">Массив для работы. Если это не экземпляр MaskedArray (или если элементы массива не замаскированы), &lt;code&gt;x&lt;/code&gt; интерпретируется как MaskedArray с &lt;code&gt;mask&lt;/code&gt; установленной в &lt;a href=&quot;../maskedarray.baseclass#numpy.ma.nomask&quot;&gt; &lt;code&gt;nomask&lt;/code&gt; &lt;/a&gt; . Должен быть 2D-массив.</target>
        </trans-unit>
        <trans-unit id="da7df7a6420823a6b7e45bca218ba68631febc25" translate="yes" xml:space="preserve">
          <source>The array to pad.</source>
          <target state="translated">Массив на панель.</target>
        </trans-unit>
        <trans-unit id="8966af5b1934b124717f0c80ec9988807e784cf9" translate="yes" xml:space="preserve">
          <source>The array to perform in place operation on.</source>
          <target state="translated">Массив для выполнения операций на месте.</target>
        </trans-unit>
        <trans-unit id="1a2586a66b67a305c2797e7e06685302608f4ea4" translate="yes" xml:space="preserve">
          <source>The array whose axes should be reordered.</source>
          <target state="translated">Массив,оси которого должны быть переупорядочены.</target>
        </trans-unit>
        <trans-unit id="81f5ca8ebafc1afb8a9d51589c5e138b4b807e19" translate="yes" xml:space="preserve">
          <source>The array(s) to be iterated over. Valid only before the iterator is closed.</source>
          <target state="translated">Массив(ы),подлежащий итерации.Проверяется только перед закрытием итератора.</target>
        </trans-unit>
        <trans-unit id="8c52ea12181e4277b350926a7c51f79608004cd5" translate="yes" xml:space="preserve">
          <source>The array(s) to iterate over.</source>
          <target state="translated">Массив(ы)для выполнения итераций.</target>
        </trans-unit>
        <trans-unit id="ae34a0f5008cfcf7a204a6ae1b41350a0a8ffea9" translate="yes" xml:space="preserve">
          <source>The array-protocol typestring of this data-type object.</source>
          <target state="translated">Массив-протокол типизирует этот объект типа данных.</target>
        </trans-unit>
        <trans-unit id="342be16484b97c95949f88958c455899735a9596" translate="yes" xml:space="preserve">
          <source>The arrays all have exactly the same shape.</source>
          <target state="translated">Все массивы имеют одинаковую форму.</target>
        </trans-unit>
        <trans-unit id="d48d7d91bb3512b8a648b512669295a09d607ddf" translate="yes" xml:space="preserve">
          <source>The arrays all have the same number of dimensions and the length of each dimensions is either a common length or 1.</source>
          <target state="translated">Все массивы имеют одинаковое количество размеров,и длина каждого из них либо общая длина,либо 1.</target>
        </trans-unit>
        <trans-unit id="3b32b95e95ce590daa0a88406a7282f0b6f9ae1f" translate="yes" xml:space="preserve">
          <source>The arrays holding the elements to be compared. If &lt;code&gt;x1.shape != x2.shape&lt;/code&gt;, they must be broadcastable to a common shape (which becomes the shape of the output).</source>
          <target state="translated">Массивы, содержащие сравниваемые элементы. Если &lt;code&gt;x1.shape != x2.shape&lt;/code&gt; , они должны транслироваться в общую форму (которая становится формой вывода).</target>
        </trans-unit>
        <trans-unit id="b72974524c2659f265dc742386bd383e243bc4a6" translate="yes" xml:space="preserve">
          <source>The arrays must have the same shape along all but the first axis. 1-D arrays must have the same length.</source>
          <target state="translated">Массивы должны иметь одинаковую форму вдоль всех,кроме первой оси.1-D массивы должны иметь одинаковую длину.</target>
        </trans-unit>
        <trans-unit id="9548b85aa3e636c88bbbc65cfcdf4e6b5fff4585" translate="yes" xml:space="preserve">
          <source>The arrays must have the same shape along all but the second axis, except 1-D arrays which can be any length.</source>
          <target state="translated">Массивы должны иметь одинаковую форму вдоль всей,кроме второй,оси,за исключением 1-D массивов,которые могут иметь любую длину.</target>
        </trans-unit>
        <trans-unit id="34736140b85990281116cda8321b303d602cfb2e" translate="yes" xml:space="preserve">
          <source>The arrays must have the same shape along all but the third axis. 1-D or 2-D arrays must have the same shape.</source>
          <target state="translated">Массивы должны иметь одинаковую форму вдоль всех,кроме третьей оси.1-D или 2-D массивы должны иметь одинаковую форму.</target>
        </trans-unit>
        <trans-unit id="250d7318b7910004f5ade9c6bf7fa2a62b2d0aa6" translate="yes" xml:space="preserve">
          <source>The arrays must have the same shape, except in the dimension corresponding to &lt;code&gt;axis&lt;/code&gt; (the first, by default).</source>
          <target state="translated">Массивы должны иметь одинаковую форму, за исключением измерения, соответствующего &lt;code&gt;axis&lt;/code&gt; (первого по умолчанию).</target>
        </trans-unit>
        <trans-unit id="3650412314ab8d0d6cc595877979b22653a06cac" translate="yes" xml:space="preserve">
          <source>The arrays that have too few dimensions can have their shapes prepended with a dimension of length 1 to satisfy property 2.</source>
          <target state="translated">Массивы,которые имеют слишком малое количество размеров,могут иметь свои формы с размером длины 1,чтобы удовлетворить свойство 2.</target>
        </trans-unit>
        <trans-unit id="3c7fb6624c1c578e967064538473cd4324bc56b1" translate="yes" xml:space="preserve">
          <source>The arrays to be added. If &lt;code&gt;x1.shape != x2.shape&lt;/code&gt;, they must be broadcastable to a common shape (which becomes the shape of the output).</source>
          <target state="translated">Добавляемые массивы. Если &lt;code&gt;x1.shape != x2.shape&lt;/code&gt; , они должны транслироваться в общую форму (которая становится формой вывода).</target>
        </trans-unit>
        <trans-unit id="61831d63f8eb03ec54ea81f37b4edf92245e6861" translate="yes" xml:space="preserve">
          <source>The arrays to be subtracted from each other. If &lt;code&gt;x1.shape != x2.shape&lt;/code&gt;, they must be broadcastable to a common shape (which becomes the shape of the output).</source>
          <target state="translated">Массивы, которые нужно вычесть друг из друга. Если &lt;code&gt;x1.shape != x2.shape&lt;/code&gt; , они должны транслироваться в общую форму (которая становится формой вывода).</target>
        </trans-unit>
        <trans-unit id="b989bf28be4c34813d52a00110756329cfab3199" translate="yes" xml:space="preserve">
          <source>The arrays to broadcast.</source>
          <target state="translated">Массивы для трансляции.</target>
        </trans-unit>
        <trans-unit id="4bc127992ac15b346e5ebc50b22b2084cc253474" translate="yes" xml:space="preserve">
          <source>The available functions are defined in &amp;lt;numpy/npy_math.h&amp;gt; - please refer to this header when in doubt.</source>
          <target state="translated">Доступные функции определены в &amp;lt;numpy / npy_math.h&amp;gt; - пожалуйста, обратитесь к этому заголовку в случае сомнений.</target>
        </trans-unit>
        <trans-unit id="4c1200844d5256d1bf5c45cf0a767eb7723d9e5e" translate="yes" xml:space="preserve">
          <source>The average along the specified axis. When returned is &lt;code&gt;True&lt;/code&gt;, return a tuple with the average as the first element and the sum of the weights as the second element. The return type is &lt;code&gt;np.float64&lt;/code&gt; if &lt;code&gt;a&lt;/code&gt; is of integer type and floats smaller than &lt;code&gt;float64&lt;/code&gt;, or the input data-type, otherwise. If returned, &lt;code&gt;sum_of_weights&lt;/code&gt; is always &lt;code&gt;float64&lt;/code&gt;.</source>
          <target state="translated">Среднее значение по указанной оси. Если возвращено значение &lt;code&gt;True&lt;/code&gt; , вернуть кортеж со средним значением в качестве первого элемента и суммой весов в качестве второго элемента. Тип возврата - &lt;code&gt;np.float64&lt;/code&gt; , если &lt;code&gt;a&lt;/code&gt; имеет целочисленный тип и число с плавающей запятой меньше &lt;code&gt;float64&lt;/code&gt; , или тип входных данных, в противном случае. Если возвращается, &lt;code&gt;sum_of_weights&lt;/code&gt; всегда имеет значение &lt;code&gt;float64&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="542875b084a7c351a7a1f8a6d2d600675ca4d2a7" translate="yes" xml:space="preserve">
          <source>The average squared deviation is normally calculated as &lt;code&gt;x.sum() / N&lt;/code&gt;, where &lt;code&gt;N = len(x)&lt;/code&gt;. If, however, &lt;code&gt;ddof&lt;/code&gt; is specified, the divisor &lt;code&gt;N - ddof&lt;/code&gt; is used instead. In standard statistical practice, &lt;code&gt;ddof=1&lt;/code&gt; provides an unbiased estimator of the variance of the infinite population. &lt;code&gt;ddof=0&lt;/code&gt; provides a maximum likelihood estimate of the variance for normally distributed variables. The standard deviation computed in this function is the square root of the estimated variance, so even with &lt;code&gt;ddof=1&lt;/code&gt;, it will not be an unbiased estimate of the standard deviation per se.</source>
          <target state="translated">Среднее квадратическое отклонение обычно рассчитывается как &lt;code&gt;x.sum() / N&lt;/code&gt; , где &lt;code&gt;N = len(x)&lt;/code&gt; . Однако, &lt;code&gt;ddof&lt;/code&gt; указано &lt;code&gt;N - ddof&lt;/code&gt; вместо него используется делитель N - ddof . В стандартной статистической практике &lt;code&gt;ddof=1&lt;/code&gt; обеспечивает несмещенную оценку дисперсии бесконечной совокупности. &lt;code&gt;ddof=0&lt;/code&gt; обеспечивает оценку максимального правдоподобия дисперсии для нормально распределенных переменных. Стандартное отклонение, вычисленное в этой функции, является квадратным корнем из оцененной дисперсии, поэтому даже при &lt;code&gt;ddof=1&lt;/code&gt; это не будет несмещенной оценкой стандартного отклонения как таковой.</target>
        </trans-unit>
        <trans-unit id="21ebdcee890d352b954472165e15ea262b078aa8" translate="yes" xml:space="preserve">
          <source>The axes over which to compute the inverse fft. Default is the last two axes.</source>
          <target state="translated">Оси,по которым рассчитывается обратный ффт.По умолчанию это последние две оси.</target>
        </trans-unit>
        <trans-unit id="3f6da36d69c95a72b5592c0677dd407fdc9cfa2c" translate="yes" xml:space="preserve">
          <source>The axis along which &lt;code&gt;v&lt;/code&gt; are appended. If &lt;code&gt;axis&lt;/code&gt; is not given, both &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; are flattened before use.</source>
          <target state="translated">Ось, по которой добавляются буквы &lt;code&gt;v&lt;/code&gt; . Если &lt;code&gt;axis&lt;/code&gt; не указана, перед использованием выравниваются и &lt;code&gt;a&lt;/code&gt; , и &lt;code&gt;b&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="071585631d8d75cc42162ae0da0a1b91474572d1" translate="yes" xml:space="preserve">
          <source>The axis along which &lt;code&gt;values&lt;/code&gt; are appended. If &lt;code&gt;axis&lt;/code&gt; is not given, both &lt;code&gt;arr&lt;/code&gt; and &lt;code&gt;values&lt;/code&gt; are flattened before use.</source>
          <target state="translated">Ось, по которой добавляются &lt;code&gt;values&lt;/code&gt; . Если &lt;code&gt;axis&lt;/code&gt; не указана, перед использованием выравниваются и &lt;code&gt;arr&lt;/code&gt; , и &lt;code&gt;values&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d25eb0541fd006d52dcbebc548c80309c583cc52" translate="yes" xml:space="preserve">
          <source>The axis along which the arrays will be joined. Default is 0.</source>
          <target state="translated">Ось,вдоль которой будут соединяться массивы.По умолчанию 0.</target>
        </trans-unit>
        <trans-unit id="ab324f8b42b072f0ce80303066858390de817e59" translate="yes" xml:space="preserve">
          <source>The axis along which the arrays will be joined. If axis is None, arrays are flattened before use. Default is 0.</source>
          <target state="translated">Ось,вдоль которой будут соединяться массивы.Если ось Нет,то перед использованием массивы уплотняются.По умолчанию 0.</target>
        </trans-unit>
        <trans-unit id="b85856e591095eebb92c2f542dccaa68776b00c8" translate="yes" xml:space="preserve">
          <source>The axis along which the difference is taken, default is the last axis.</source>
          <target state="translated">Ось,вдоль которой берется разница,по умолчанию является последней осью.</target>
        </trans-unit>
        <trans-unit id="848f8430ea7a17384babb0b6d388a2e2e8bda711" translate="yes" xml:space="preserve">
          <source>The axis along which the selection is performed. The default, 0, selects by row.</source>
          <target state="translated">Ось,вдоль которой производится выделение.По умолчанию 0,выбирается по строке.</target>
        </trans-unit>
        <trans-unit id="db9105950615faa8709d8dba888767b4f466811c" translate="yes" xml:space="preserve">
          <source>The axis along which to apply the accumulation; default is zero.</source>
          <target state="translated">Ось,по которой следует применять накопление;по умолчанию равна нулю.</target>
        </trans-unit>
        <trans-unit id="b45496da67ff059714d0b1ae6911029e831dd2fd" translate="yes" xml:space="preserve">
          <source>The axis along which to apply the reduceat.</source>
          <target state="translated">Ось,вдоль которой следует применять редуктор.</target>
        </trans-unit>
        <trans-unit id="ef9dbd3a8e7509325fd10ad7183022f46facda83" translate="yes" xml:space="preserve">
          <source>The axis along which to delete the subarray defined by &lt;code&gt;obj&lt;/code&gt;. If &lt;code&gt;axis&lt;/code&gt; is None, &lt;code&gt;obj&lt;/code&gt; is applied to the flattened array.</source>
          <target state="translated">Ось, по которой следует удалить подмассив, определенный &lt;code&gt;obj&lt;/code&gt; . Если &lt;code&gt;axis&lt;/code&gt; None, &lt;code&gt;obj&lt;/code&gt; применяется к сглаженному массиву.</target>
        </trans-unit>
        <trans-unit id="5932d4cf836b6b58485bd9f15e2f20474363c36f" translate="yes" xml:space="preserve">
          <source>The axis along which to integrate.</source>
          <target state="translated">Ось,вдоль которой нужно интегрировать.</target>
        </trans-unit>
        <trans-unit id="0011917dec1b66b996673fed4476058c1c23ee6e" translate="yes" xml:space="preserve">
          <source>The axis along which to repeat values. By default, use the flattened input array, and return a flat output array.</source>
          <target state="translated">Ось,вдоль которой повторяются значения.По умолчанию используйте плоский входной массив и возвращайте плоский выходной массив.</target>
        </trans-unit>
        <trans-unit id="407371d3199afc3105f3e75619a63b4981063028" translate="yes" xml:space="preserve">
          <source>The axis along which to split, default is 0.</source>
          <target state="translated">По умолчанию ось,по которой происходит разделение,равна 0.</target>
        </trans-unit>
        <trans-unit id="40f4cb16df8166b16f689cc3f6a27ceb034ca2a8" translate="yes" xml:space="preserve">
          <source>The axis currently being calculated.</source>
          <target state="translated">Ось,которая в настоящее время рассчитывается.</target>
        </trans-unit>
        <trans-unit id="779396c94c96c008627d39cce908fca96b699246" translate="yes" xml:space="preserve">
          <source>The axis in the result array along which the input arrays are stacked.</source>
          <target state="translated">Ось в результирующем массиве,по которой укладываются входные массивы.</target>
        </trans-unit>
        <trans-unit id="f53c3f1c70993fc128dae4ee501fb80cbace06f6" translate="yes" xml:space="preserve">
          <source>The axis in the result to store the samples. Relevant only if start or stop are array-like. By default (0), the samples will be along a new axis inserted at the beginning. Use -1 to get an axis at the end.</source>
          <target state="translated">Ось в результатах для хранения образцов.Актуальна только в том случае,если старт или стоп являются массивами.По умолчанию (0),примеры будут располагаться вдоль новой вставленной в начало оси.Для получения оси в конце используйте -1.</target>
        </trans-unit>
        <trans-unit id="5d9b30084a3b37c792a839c94c54a5cdb7a8cfce" translate="yes" xml:space="preserve">
          <source>The axis is rolled until it lies before this position. The default, 0, results in a &amp;ldquo;complete&amp;rdquo; roll.</source>
          <target state="translated">Ось катится, пока она не окажется перед этим положением. Значение по умолчанию 0 означает &amp;laquo;полный&amp;raquo; бросок.</target>
        </trans-unit>
        <trans-unit id="bb67daef266f9ea49c20107e1bf4911d74a22608" translate="yes" xml:space="preserve">
          <source>The axis over which to select values. By default, the flattened input array is used.</source>
          <target state="translated">Ось,по которой выбираются значения.По умолчанию используется плоский входной массив.</target>
        </trans-unit>
        <trans-unit id="d0edfc48d57e03c356c790b28b9213c10fc98a8b" translate="yes" xml:space="preserve">
          <source>The axis to operate on. If None, &lt;code&gt;ar&lt;/code&gt; will be flattened. If an integer, the subarrays indexed by the given axis will be flattened and treated as the elements of a 1-D array with the dimension of the given axis, see the notes for more details. Object arrays or structured arrays that contain objects are not supported if the &lt;code&gt;axis&lt;/code&gt; kwarg is used. The default is None.</source>
          <target state="translated">Ось для работы. Если нет, &lt;code&gt;ar&lt;/code&gt; будет сплющен. Если это целое число, подмассивы, проиндексированные данной осью, будут сглажены и обработаны как элементы одномерного массива с размером данной оси, см. Примечания для более подробной информации. Массивы объектов или структурированные массивы, содержащие объекты, не поддерживаются, если используется &lt;code&gt;axis&lt;/code&gt; kwarg. По умолчанию - Нет.</target>
        </trans-unit>
        <trans-unit id="b9493a9f29cafe569828c852de6864aa7f5d0ff6" translate="yes" xml:space="preserve">
          <source>The axis to roll backwards. The positions of the other axes do not change relative to one another.</source>
          <target state="translated">Ось для отката назад.Позиции других осей не меняются относительно друг друга.</target>
        </trans-unit>
        <trans-unit id="340d3fc196833339a77972eea60efcdfd52ba73c" translate="yes" xml:space="preserve">
          <source>The axis to take 1d slices along. If axis is None, the destination array is treated as if a flattened 1d view had been created of it.</source>
          <target state="translated">Ось,чтобы взять 1d срезов вдоль.Если ось None,то массив назначения обрабатывается так,как если бы из него был создан плоский 1d вид.</target>
        </trans-unit>
        <trans-unit id="a049beb1044c250e5951941014a3acba639cb49d" translate="yes" xml:space="preserve">
          <source>The axis to take 1d slices along. If axis is None, the input array is treated as if it had first been flattened to 1d, for consistency with &lt;a href=&quot;numpy.sort#numpy.sort&quot;&gt;&lt;code&gt;sort&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;numpy.argsort#numpy.argsort&quot;&gt;&lt;code&gt;argsort&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Ось, по которой нужно брать 1d срезы. Если ось None, входной массив обрабатывается так, как если бы он сначала был сведен к 1d, для согласованности с &lt;a href=&quot;numpy.sort#numpy.sort&quot;&gt; &lt;code&gt;sort&lt;/code&gt; &lt;/a&gt; и &lt;a href=&quot;numpy.argsort#numpy.argsort&quot;&gt; &lt;code&gt;argsort&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="98787e1071b5327d0b2e07537c81bb27588db08e" translate="yes" xml:space="preserve">
          <source>The base case for this recursion is a 0D array:</source>
          <target state="translated">Базовым регистром для этой рекурсии является массив 0D:</target>
        </trans-unit>
        <trans-unit id="88d21dfd4e25736b7184078ba7f33b64bea753e0" translate="yes" xml:space="preserve">
          <source>The base of an array that owns its memory is None:</source>
          <target state="translated">Основой массива,которому принадлежит память,является None:</target>
        </trans-unit>
        <trans-unit id="074b16b582d8ec2099beaee8dcbc987839646a35" translate="yes" xml:space="preserve">
          <source>The base of the log space. The step size between the elements in &lt;code&gt;ln(samples) / ln(base)&lt;/code&gt; (or &lt;code&gt;log_base(samples)&lt;/code&gt;) is uniform. Default is 10.0.</source>
          <target state="translated">Основание бревенчатого пространства. Размер шага между элементами в &lt;code&gt;ln(samples) / ln(base)&lt;/code&gt; (или &lt;code&gt;log_base(samples)&lt;/code&gt; ) одинаков. По умолчанию 10.0.</target>
        </trans-unit>
        <trans-unit id="535897fba7f592c8b7dd04c68596d9a31edf2e11" translate="yes" xml:space="preserve">
          <source>The bases in &lt;code&gt;x1&lt;/code&gt; raised to the exponents in &lt;code&gt;x2&lt;/code&gt;. This is a scalar if both &lt;code&gt;x1&lt;/code&gt; and &lt;code&gt;x2&lt;/code&gt; are scalars.</source>
          <target state="translated">Основания в &lt;code&gt;x1&lt;/code&gt; возведены в степень в &lt;code&gt;x2&lt;/code&gt; . Это скаляр, если и &lt;code&gt;x1&lt;/code&gt; , и &lt;code&gt;x2&lt;/code&gt; являются скалярами.</target>
        </trans-unit>
        <trans-unit id="707f28b031c35e2bf30d29bbd42946a1e8c7dc8c" translate="yes" xml:space="preserve">
          <source>The bases.</source>
          <target state="translated">Базы.</target>
        </trans-unit>
        <trans-unit id="5bc92f7e413935d311df16000ae397f9e815d85b" translate="yes" xml:space="preserve">
          <source>The basic data element&amp;rsquo;s size in bytes</source>
          <target state="translated">Размер базового элемента данных в байтах</target>
        </trans-unit>
        <trans-unit id="68fe9eda4da762f1f4d04299c59c07412dcd5a69" translate="yes" xml:space="preserve">
          <source>The basic slice syntax is &lt;code&gt;i:j:k&lt;/code&gt; where &lt;em&gt;i&lt;/em&gt; is the starting index, &lt;em&gt;j&lt;/em&gt; is the stopping index, and &lt;em&gt;k&lt;/em&gt; is the step (</source>
          <target state="translated">Базовый синтаксис среза - &lt;code&gt;i:j:k&lt;/code&gt; , где &lt;em&gt;i&lt;/em&gt; - начальный индекс, &lt;em&gt;j&lt;/em&gt; - индекс остановки, а &lt;em&gt;k&lt;/em&gt; - шаг (</target>
        </trans-unit>
        <trans-unit id="aeeddb45e8f2002e147b881df220bd44abec802b" translate="yes" xml:space="preserve">
          <source>The basic type character codes are:</source>
          <target state="translated">Основные символьные коды типа:</target>
        </trans-unit>
        <trans-unit id="94f38793f86bdba698e5ca03402c847550f50738" translate="yes" xml:space="preserve">
          <source>The basis polynomials are scaled so that the companion matrix is symmetric when &lt;code&gt;c&lt;/code&gt; is a Chebyshev basis polynomial. This provides better eigenvalue estimates than the unscaled case and for basis polynomials the eigenvalues are guaranteed to be real if &lt;a href=&quot;numpy.linalg.eigvalsh#numpy.linalg.eigvalsh&quot;&gt;&lt;code&gt;numpy.linalg.eigvalsh&lt;/code&gt;&lt;/a&gt; is used to obtain them.</source>
          <target state="translated">Базисные полиномы масштабируются так, чтобы сопутствующая матрица была симметричной, когда &lt;code&gt;c&lt;/code&gt; является базисным полиномом Чебышева. Это обеспечивает лучшие оценки собственных значений, чем немасштабированный случай, и для базисных полиномов собственные значения гарантированно будут действительными, если для их получения используется &lt;a href=&quot;numpy.linalg.eigvalsh#numpy.linalg.eigvalsh&quot;&gt; &lt;code&gt;numpy.linalg.eigvalsh&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="fd443fcafad8cfc7235ab73b5edb8fa2361feb5f" translate="yes" xml:space="preserve">
          <source>The basis polynomials are scaled so that the companion matrix is symmetric when &lt;code&gt;c&lt;/code&gt; is an Hermite basis polynomial. This provides better eigenvalue estimates than the unscaled case and for basis polynomials the eigenvalues are guaranteed to be real if &lt;a href=&quot;numpy.linalg.eigvalsh#numpy.linalg.eigvalsh&quot;&gt;&lt;code&gt;numpy.linalg.eigvalsh&lt;/code&gt;&lt;/a&gt; is used to obtain them.</source>
          <target state="translated">Базисные полиномы масштабируются так, чтобы сопутствующая матрица была симметричной, когда &lt;code&gt;c&lt;/code&gt; является базисным полиномом Эрмита. Это обеспечивает лучшие оценки собственных значений, чем немасштабированный случай, и для базисных полиномов собственные значения гарантированно будут действительными, если для их получения используется &lt;a href=&quot;numpy.linalg.eigvalsh#numpy.linalg.eigvalsh&quot;&gt; &lt;code&gt;numpy.linalg.eigvalsh&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="e1520a86bfcd397936d59363e21a13733e7a71b7" translate="yes" xml:space="preserve">
          <source>The basis polynomials are scaled so that the companion matrix is symmetric when &lt;code&gt;c&lt;/code&gt; is an HermiteE basis polynomial. This provides better eigenvalue estimates than the unscaled case and for basis polynomials the eigenvalues are guaranteed to be real if &lt;a href=&quot;numpy.linalg.eigvalsh#numpy.linalg.eigvalsh&quot;&gt;&lt;code&gt;numpy.linalg.eigvalsh&lt;/code&gt;&lt;/a&gt; is used to obtain them.</source>
          <target state="translated">Базисные полиномы масштабируются так, чтобы сопутствующая матрица была симметричной, когда &lt;code&gt;c&lt;/code&gt; является базисным полиномом Эрмита. Это обеспечивает лучшие оценки собственных значений, чем немасштабированный случай, и для базисных полиномов собственные значения гарантированно будут действительными, если для их получения используется &lt;a href=&quot;numpy.linalg.eigvalsh#numpy.linalg.eigvalsh&quot;&gt; &lt;code&gt;numpy.linalg.eigvalsh&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="31e8496a7482cd5cd28cb680bd285957a80df61e" translate="yes" xml:space="preserve">
          <source>The basis polynomials are scaled so that the companion matrix is symmetric when &lt;code&gt;c&lt;/code&gt; is an Legendre basis polynomial. This provides better eigenvalue estimates than the unscaled case and for basis polynomials the eigenvalues are guaranteed to be real if &lt;a href=&quot;numpy.linalg.eigvalsh#numpy.linalg.eigvalsh&quot;&gt;&lt;code&gt;numpy.linalg.eigvalsh&lt;/code&gt;&lt;/a&gt; is used to obtain them.</source>
          <target state="translated">Базисные полиномы масштабируются так, чтобы сопутствующая матрица была симметричной, когда &lt;code&gt;c&lt;/code&gt; является базисным полиномом Лежандра. Это обеспечивает лучшие оценки собственных значений, чем немасштабированный случай, и для базисных полиномов собственные значения гарантированно будут действительными, если для их получения используется &lt;a href=&quot;numpy.linalg.eigvalsh#numpy.linalg.eigvalsh&quot;&gt; &lt;code&gt;numpy.linalg.eigvalsh&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="f437318ff72364f761b90a9b7cf38009e657db81" translate="yes" xml:space="preserve">
          <source>The behavior depends on the arguments in the following way.</source>
          <target state="translated">Поведение зависит от аргументов следующим образом.</target>
        </trans-unit>
        <trans-unit id="e2bdcfca6c07efc9e236b5653fc2391d3452350a" translate="yes" xml:space="preserve">
          <source>The best practice is to &lt;strong&gt;not&lt;/strong&gt; reseed a BitGenerator, rather to recreate a new one. This method is here for legacy reasons. This example demonstrates best practice.</source>
          <target state="translated">Лучше всего &lt;strong&gt;не&lt;/strong&gt; повторно загружать BitGenerator, а воссоздать новый. Этот метод используется по устаревшим причинам. Этот пример демонстрирует передовой опыт.</target>
        </trans-unit>
        <trans-unit id="b917d701e1031f727f4614d1e3412a655c750b99" translate="yes" xml:space="preserve">
          <source>The best way to become familiar with the iterator is to look at its usage within the NumPy codebase itself. For example, here is a slightly tweaked version of the code for &lt;a href=&quot;c-api.array#c.PyArray_CountNonzero&quot;&gt;&lt;code&gt;PyArray_CountNonzero&lt;/code&gt;&lt;/a&gt;, which counts the number of non-zero elements in an array.</source>
          <target state="translated">Лучший способ познакомиться с итератором - взглянуть на его использование в самой кодовой базе NumPy. Например, вот немного измененная версия кода &lt;a href=&quot;c-api.array#c.PyArray_CountNonzero&quot;&gt; &lt;code&gt;PyArray_CountNonzero&lt;/code&gt; &lt;/a&gt; , который подсчитывает количество ненулевых элементов в массиве.</target>
        </trans-unit>
        <trans-unit id="de71d7b03048d0ddf7e9d872a2d91138dd227be5" translate="yes" xml:space="preserve">
          <source>The best way to encode the options required to link against the specified C libraries is to use a &amp;ldquo;libname.ini&amp;rdquo; file, and use &lt;a href=&quot;#numpy.distutils.misc_util.Configuration.get_info&quot;&gt;&lt;code&gt;get_info&lt;/code&gt;&lt;/a&gt; to retrieve the required options (see &lt;a href=&quot;#numpy.distutils.misc_util.Configuration.add_npy_pkg_config&quot;&gt;&lt;code&gt;add_npy_pkg_config&lt;/code&gt;&lt;/a&gt; for more information).</source>
          <target state="translated">Лучший способ закодировать параметры, необходимые для компоновки с указанными библиотеками C, - это использовать файл &amp;laquo;libname.ini&amp;raquo; и использовать &lt;a href=&quot;#numpy.distutils.misc_util.Configuration.get_info&quot;&gt; &lt;code&gt;get_info&lt;/code&gt; &lt;/a&gt; для получения требуемых параметров (см. &lt;a href=&quot;#numpy.distutils.misc_util.Configuration.add_npy_pkg_config&quot;&gt; &lt;code&gt;add_npy_pkg_config&lt;/code&gt; &lt;/a&gt; для получения дополнительной информации).</target>
        </trans-unit>
        <trans-unit id="1969d49698b808b6d276d97e5d8d4c69483e3b58" translate="yes" xml:space="preserve">
          <source>The bi-dimensional histogram of samples &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt;. Values in &lt;code&gt;x&lt;/code&gt; are histogrammed along the first dimension and values in &lt;code&gt;y&lt;/code&gt; are histogrammed along the second dimension.</source>
          <target state="translated">Двумерная гистограмма выборок &lt;code&gt;x&lt;/code&gt; и &lt;code&gt;y&lt;/code&gt; . Значения в &lt;code&gt;x&lt;/code&gt; отображаются гистограммой по первому измерению, а значения по &lt;code&gt;y&lt;/code&gt; - по гистограмме по второму измерению.</target>
        </trans-unit>
        <trans-unit id="14050b2975e92118c403ebf94bd3985c0b813e9c" translate="yes" xml:space="preserve">
          <source>The bin edges along the first dimension.</source>
          <target state="translated">Края мусорного контейнера вдоль первого измерения.</target>
        </trans-unit>
        <trans-unit id="4350d5e237c7d985f1cac8ee28f6158f7c836a6a" translate="yes" xml:space="preserve">
          <source>The bin edges along the second dimension.</source>
          <target state="translated">Края мусорного контейнера вдоль второго измерения.</target>
        </trans-unit>
        <trans-unit id="a2867162a2727e5c2d9c039d549ef3ce42449ec8" translate="yes" xml:space="preserve">
          <source>The bin specification:</source>
          <target state="translated">Спецификация мусорного контейнера:</target>
        </trans-unit>
        <trans-unit id="60d93abeda71712ad2c6a79ef8adc26f40d2aa9b" translate="yes" xml:space="preserve">
          <source>The binwidth is proportional to the interquartile range (IQR) and inversely proportional to cube root of a.size. Can be too conservative for small datasets, but is quite good for large datasets. The IQR is very robust to outliers.</source>
          <target state="translated">Ширина полосы пропорциональна межквартильному диапазону (IQR)и обратно пропорциональна кубическому корню размера a.size.Может быть слишком консервативным для маленьких наборов данных,но довольно хорошим для больших наборов данных.IQR очень устойчив к отклонениям.</target>
        </trans-unit>
        <trans-unit id="fcdd8e437719df337fcbc4c74083d021a1773472" translate="yes" xml:space="preserve">
          <source>The binwidth is proportional to the standard deviation of the data and inversely proportional to cube root of &lt;code&gt;x.size&lt;/code&gt;. Can be too conservative for small datasets, but is quite good for large datasets. The standard deviation is not very robust to outliers. Values are very similar to the Freedman-Diaconis estimator in the absence of outliers.</source>
          <target state="translated">Ширина бина пропорциональна стандартному отклонению данных и обратно пропорциональна кубическому корню из &lt;code&gt;x.size&lt;/code&gt; . Может быть слишком консервативным для небольших наборов данных, но вполне подходит для больших наборов данных. Стандартное отклонение не очень устойчиво к выбросам. Значения очень похожи на оценку Фридмана-Диакониса при отсутствии выбросов.</target>
        </trans-unit>
        <trans-unit id="4bfe7be4cfb5e7ee31495fab431c2ade90ea37b4" translate="yes" xml:space="preserve">
          <source>The bit generator instance used by the generator</source>
          <target state="translated">Экземпляр генератора битов,используемый генератором</target>
        </trans-unit>
        <trans-unit id="c5d3462c76522066d7ff9beefce9a7effa7d1a7a" translate="yes" xml:space="preserve">
          <source>The bit generators can be used in downstream projects via &lt;a href=&quot;extending#randomgen-cython&quot;&gt;Cython&lt;/a&gt;.</source>
          <target state="translated">Генераторы битов можно использовать в последующих проектах через &lt;a href=&quot;extending#randomgen-cython&quot;&gt;Cython&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="bb60b63a1d593f422d320c08f605d5c913dee609" translate="yes" xml:space="preserve">
          <source>The bit generators can be used in downstream projects via Cython.</source>
          <target state="translated">Генераторы битов могут быть использованы в последующих проектах через Cython.</target>
        </trans-unit>
        <trans-unit id="6e4e6fbd0cb3401b8c573dd3679e44e3f4f81dbf" translate="yes" xml:space="preserve">
          <source>The bit-width names can also be used (e.g. &lt;a href=&quot;c-api.dtype#c.NPY_INT32&quot;&gt;&lt;code&gt;NPY_INT32&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;c-api.dtype#c.NPY_COMPLEX128&quot;&gt;&lt;code&gt;NPY_COMPLEX128&lt;/code&gt;&lt;/a&gt; ) if desired.</source>
          <target state="translated">При желании можно также использовать имена разрядности (например, &lt;a href=&quot;c-api.dtype#c.NPY_INT32&quot;&gt; &lt;code&gt;NPY_INT32&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;c-api.dtype#c.NPY_COMPLEX128&quot;&gt; &lt;code&gt;NPY_COMPLEX128&lt;/code&gt; &lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="81d10a070991358c5aabcf2c4a0f8549725777dd" translate="yes" xml:space="preserve">
          <source>The bit-wise operators &amp;amp; and | are the proper way to perform element-by-element array comparisons. Be sure you understand the operator precedence: &lt;code&gt;(a &amp;gt; 2) &amp;amp; (a &amp;lt; 5)&lt;/code&gt; is the proper syntax because &lt;code&gt;a &amp;gt; 2 &amp;amp; a &amp;lt; 5&lt;/code&gt; will result in an error due to the fact that &lt;code&gt;2 &amp;amp; a&lt;/code&gt; is evaluated first.</source>
          <target state="translated">Поразрядные операторы &amp;amp; и | являются подходящим способом для поэлементного сравнения массивов. Убедитесь, что вы понимаете приоритет оператора: &lt;code&gt;(a &amp;gt; 2) &amp;amp; (a &amp;lt; 5)&lt;/code&gt; - правильный синтаксис, потому что &lt;code&gt;a &amp;gt; 2 &amp;amp; a &amp;lt; 5&lt;/code&gt; приведет к ошибке из-за того, что &lt;code&gt;2 &amp;amp; a&lt;/code&gt; оцениваются первыми.</target>
        </trans-unit>
        <trans-unit id="023be86065ffa72daa5873059c9ec3d6c37210a4" translate="yes" xml:space="preserve">
          <source>The bits that are inherited for the parent data-type if these bits are set in any field of the data-type. Currently ( &lt;a href=&quot;#c.NPY_NEEDS_INIT&quot;&gt;&lt;code&gt;NPY_NEEDS_INIT&lt;/code&gt;&lt;/a&gt; | &lt;a href=&quot;#c.NPY_LIST_PICKLE&quot;&gt;&lt;code&gt;NPY_LIST_PICKLE&lt;/code&gt;&lt;/a&gt; | &lt;a href=&quot;#c.NPY_ITEM_REFCOUNT&quot;&gt;&lt;code&gt;NPY_ITEM_REFCOUNT&lt;/code&gt;&lt;/a&gt; | &lt;a href=&quot;#c.NPY_NEEDS_PYAPI&quot;&gt;&lt;code&gt;NPY_NEEDS_PYAPI&lt;/code&gt;&lt;/a&gt; ).</source>
          <target state="translated">Биты, которые наследуются для родительского типа данных, если эти биты установлены в любом поле этого типа данных. В настоящее время ( &lt;a href=&quot;#c.NPY_NEEDS_INIT&quot;&gt; &lt;code&gt;NPY_NEEDS_INIT&lt;/code&gt; &lt;/a&gt; | &lt;a href=&quot;#c.NPY_LIST_PICKLE&quot;&gt; &lt;code&gt;NPY_LIST_PICKLE&lt;/code&gt; &lt;/a&gt; | &lt;a href=&quot;#c.NPY_ITEM_REFCOUNT&quot;&gt; &lt;code&gt;NPY_ITEM_REFCOUNT&lt;/code&gt; &lt;/a&gt; | &lt;a href=&quot;#c.NPY_NEEDS_PYAPI&quot;&gt; &lt;code&gt;NPY_NEEDS_PYAPI&lt;/code&gt; &lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="4cdfeeb979f5beeacca8e8ed28ded2c7c6f59236" translate="yes" xml:space="preserve">
          <source>The buffer size. If &lt;code&gt;buf_size&lt;/code&gt; is supplied, the maximum amount of data that will be read into memory is &lt;code&gt;buf_size&lt;/code&gt; elements. Default is None, which will read as many element as possible into memory.</source>
          <target state="translated">Размер буфера. Если &lt;code&gt;buf_size&lt;/code&gt; , максимальный объем данных, который будет считан в память, - &lt;code&gt;buf_size&lt;/code&gt; элементы buf_size . По умолчанию - Нет, при этом в память будет прочитано как можно больше элементов.</target>
        </trans-unit>
        <trans-unit id="2e41256de81634e573afba6a93755e0b3e1dcc73" translate="yes" xml:space="preserve">
          <source>The built-in scalar types are shown below. Along with their (mostly) C-derived names, the integer, float, and complex data-types are also available using a bit-width convention so that an array of the right size can always be ensured (e.g. &lt;code&gt;int8&lt;/code&gt;, &lt;code&gt;float64&lt;/code&gt;, &lt;code&gt;complex128&lt;/code&gt;). Two aliases (&lt;code&gt;intp&lt;/code&gt; and &lt;code&gt;uintp&lt;/code&gt;) pointing to the integer type that is sufficiently large to hold a C pointer are also provided. The C-like names are associated with character codes, which are shown in the table. Use of the character codes, however, is discouraged.</source>
          <target state="translated">Встроенные скалярные типы показаны ниже. Наряду с их (в основном) именами, производными от C, целочисленные, float и сложные типы данных также доступны с использованием соглашения о ширине битов, так что всегда можно обеспечить массив правильного размера (например, &lt;code&gt;int8&lt;/code&gt; , &lt;code&gt;float64&lt;/code&gt; , &lt;code&gt;complex128&lt;/code&gt; ) . Также предоставляются два псевдонима ( &lt;code&gt;intp&lt;/code&gt; и &lt;code&gt;uintp&lt;/code&gt; ), указывающие на целочисленный тип, который достаточно велик, чтобы содержать указатель C. C-подобные имена связаны с кодами символов, которые показаны в таблице. Однако использование кодов символов не рекомендуется.</target>
        </trans-unit>
        <trans-unit id="c0f5f929adb8df8a6adc766b8c78557ffdeb6dfb" translate="yes" xml:space="preserve">
          <source>The byte offset of element &lt;code&gt;(i[0], i[1], ..., i[n])&lt;/code&gt; in an array &lt;code&gt;a&lt;/code&gt; is:</source>
          <target state="translated">Байтовое смещение элемента &lt;code&gt;(i[0], i[1], ..., i[n])&lt;/code&gt; в массиве &lt;code&gt;a&lt;/code&gt; равно:</target>
        </trans-unit>
        <trans-unit id="a157c5730d5626d8d468cb6666e1e8a306635908" translate="yes" xml:space="preserve">
          <source>The byte order of the data (which may not be the native byte order)</source>
          <target state="translated">Порядок байт данных (который может не быть родным порядком байт)</target>
        </trans-unit>
        <trans-unit id="54750603ecbabb9e0fbfb396fe440127b1696b3c" translate="yes" xml:space="preserve">
          <source>The byteswapped array. If &lt;code&gt;inplace&lt;/code&gt; is &lt;code&gt;True&lt;/code&gt;, this is a view to self.</source>
          <target state="translated">Массив с заменой байтов. Если &lt;code&gt;inplace&lt;/code&gt; имеет значение &lt;code&gt;True&lt;/code&gt; , это представление для себя.</target>
        </trans-unit>
        <trans-unit id="50ca95011c00b72a055aafd7f7fd748d3ee5666f" translate="yes" xml:space="preserve">
          <source>The calculation based on the Einstein summation convention.</source>
          <target state="translated">Расчет на основе конвенции об объединении Эйнштейна.</target>
        </trans-unit>
        <trans-unit id="f28022cc3c759ea7fff9649dace591b586e47f2a" translate="yes" xml:space="preserve">
          <source>The call function takes two arguments. The first is a string describing the type of error (such as &amp;ldquo;divide by zero&amp;rdquo;, &amp;ldquo;overflow&amp;rdquo;, &amp;ldquo;underflow&amp;rdquo;, or &amp;ldquo;invalid value&amp;rdquo;), and the second is the status flag. The flag is a byte, whose four least-significant bits indicate the type of error, one of &amp;ldquo;divide&amp;rdquo;, &amp;ldquo;over&amp;rdquo;, &amp;ldquo;under&amp;rdquo;, &amp;ldquo;invalid&amp;rdquo;:</source>
          <target state="translated">Функция вызова принимает два аргумента. Первая - это строка, описывающая тип ошибки (например, &amp;laquo;разделить на ноль&amp;raquo;, &amp;laquo;переполнение&amp;raquo;, &amp;laquo;потеря значимости&amp;raquo; или &amp;laquo;недопустимое значение&amp;raquo;), а вторая - это флаг состояния. Флаг представляет собой байт, четыре младших бита которого указывают тип ошибки: &amp;laquo;разделить&amp;raquo;, &amp;laquo;больше&amp;raquo;, &amp;laquo;меньше&amp;raquo;, &amp;laquo;недействительно&amp;raquo;:</target>
        </trans-unit>
        <trans-unit id="65bfb33c8f536eca2e334a181b45563504281f94" translate="yes" xml:space="preserve">
          <source>The callable to test.</source>
          <target state="translated">Призыв к тестированию.</target>
        </trans-unit>
        <trans-unit id="431e9b7795bdf48241d6bec5990fb4a0130d071a" translate="yes" xml:space="preserve">
          <source>The ceil of the scalar &lt;code&gt;x&lt;/code&gt; is the smallest integer &lt;code&gt;i&lt;/code&gt;, such that &lt;code&gt;i &amp;gt;= x&lt;/code&gt;. It is often denoted as</source>
          <target state="translated">Ceil скаляра &lt;code&gt;x&lt;/code&gt; - это наименьшее целое число &lt;code&gt;i&lt;/code&gt; такое, что &lt;code&gt;i &amp;gt;= x&lt;/code&gt; . Часто обозначается как</target>
        </trans-unit>
        <trans-unit id="e9d3cf326f9a7a53ec955615e43eb638c61eb8ef" translate="yes" xml:space="preserve">
          <source>The ceiling of each element in &lt;code&gt;x&lt;/code&gt;, with &lt;a href=&quot;https://docs.python.org/dev/library/functions.html#float&quot;&gt;&lt;code&gt;float&lt;/code&gt;&lt;/a&gt; dtype. This is a scalar if &lt;code&gt;x&lt;/code&gt; is a scalar.</source>
          <target state="translated">Потолок каждого элемента в &lt;code&gt;x&lt;/code&gt; , с &lt;a href=&quot;https://docs.python.org/dev/library/functions.html#float&quot;&gt; &lt;code&gt;float&lt;/code&gt; &lt;/a&gt; dtype. Это скаляр, если &lt;code&gt;x&lt;/code&gt; - скаляр.</target>
        </trans-unit>
        <trans-unit id="39a8dcb488a9fc6fc34cf5a558688abf07d39d3f" translate="yes" xml:space="preserve">
          <source>The character representing the minimum-size type that was found.</source>
          <target state="translated">Символ,представляющий найденный тип минимального размера.</target>
        </trans-unit>
        <trans-unit id="97cbe8e263bc4b6b77075dcb6bab028e565a01e7" translate="yes" xml:space="preserve">
          <source>The character to use for padding</source>
          <target state="translated">Символ,который нужно использовать для набивки</target>
        </trans-unit>
        <trans-unit id="6c4bf24ea0f35b24c677f85fded0fd7b09f23149" translate="yes" xml:space="preserve">
          <source>The character used to indicate the start of a comment. All the characters occurring on a line after a comment are discarded</source>
          <target state="translated">Символ,используемый для обозначения начала комментария.Все символы,встречающиеся в строке после комментария,отбрасываются.</target>
        </trans-unit>
        <trans-unit id="d85f382686a835461ae276491d1cc1f7d794fafc" translate="yes" xml:space="preserve">
          <source>The characteristic polynomial,</source>
          <target state="translated">Характерный полиномиальный,</target>
        </trans-unit>
        <trans-unit id="95fe0ca98cff261937758debf60dec87c78a570a" translate="yes" xml:space="preserve">
          <source>The characters or list of characters used to indicate the start of a comment. None implies no comments. For backwards compatibility, byte strings will be decoded as &amp;lsquo;latin1&amp;rsquo;. The default is &amp;lsquo;#&amp;rsquo;.</source>
          <target state="translated">Символы или список символов, используемых для обозначения начала комментария. Ни один не подразумевает никаких комментариев. Для обратной совместимости байтовые строки будут декодироваться как latin1. По умолчанию - &quot;#&quot;.</target>
        </trans-unit>
        <trans-unit id="5b3f50108009441cc91c801c6a0d50e7f118400f" translate="yes" xml:space="preserve">
          <source>The class defining the warning that &lt;code&gt;func&lt;/code&gt; is expected to throw.</source>
          <target state="translated">Класс, определяющий предупреждение, которое, как ожидается , &lt;code&gt;func&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3182c5f9b369539a27f1bc7716b92f10416add66" translate="yes" xml:space="preserve">
          <source>The code does a case-insensitive check on the first letter of &lt;code&gt;new_order&lt;/code&gt; for these alternatives. For example, any of &amp;lsquo;&amp;gt;&amp;rsquo; or &amp;lsquo;B&amp;rsquo; or &amp;lsquo;b&amp;rsquo; or &amp;lsquo;brian&amp;rsquo; are valid to specify big-endian.</source>
          <target state="translated">Код проверяет первую букву &lt;code&gt;new_order&lt;/code&gt; без учета регистра для этих альтернатив. Например, любое из '&amp;gt;', 'B', 'b' или 'brian' допустимо для указания прямого порядка байтов.</target>
        </trans-unit>
        <trans-unit id="3d7fde77cc6d2864c99d7d852dc9654a8a2c232a" translate="yes" xml:space="preserve">
          <source>The coefficient array representing their sum.</source>
          <target state="translated">Массив коэффициентов,представляющий их сумму.</target>
        </trans-unit>
        <trans-unit id="8877be945db0e0267ce25ed710aea10434e74470" translate="yes" xml:space="preserve">
          <source>The coefficient matrix of the coefficients &lt;code&gt;p&lt;/code&gt; is a Vandermonde matrix.</source>
          <target state="translated">Матрица коэффициентов коэффициентов &lt;code&gt;p&lt;/code&gt; является матрицей Вандермонда.</target>
        </trans-unit>
        <trans-unit id="1749ca10e1fd82b0f81734b8e3040c222ba10138" translate="yes" xml:space="preserve">
          <source>The coefficient of the last term is 1 for monic polynomials in this form.</source>
          <target state="translated">Коэффициент последнего члена для монических полиномов в этой форме равен 1.</target>
        </trans-unit>
        <trans-unit id="7f518b8b3d036f3e65aa1004d0ce4c9fe4f469f2" translate="yes" xml:space="preserve">
          <source>The coefficient of the last term is not generally 1 for monic polynomials in Chebyshev form.</source>
          <target state="translated">Коэффициент последнего члена обычно не равен 1 для монических многочленов в чебышевской форме.</target>
        </trans-unit>
        <trans-unit id="c6e27aff7bd03298a7abe7cdd24c2851e78ffc19" translate="yes" xml:space="preserve">
          <source>The coefficient of the last term is not generally 1 for monic polynomials in Hermite form.</source>
          <target state="translated">Коэффициент последнего члена обычно не равен 1 для монических полиномов в эрмитарной форме.</target>
        </trans-unit>
        <trans-unit id="d8180193920e1d179284839e524518471959f55d" translate="yes" xml:space="preserve">
          <source>The coefficient of the last term is not generally 1 for monic polynomials in HermiteE form.</source>
          <target state="translated">Коэффициент последнего члена для монических полиномов в форме HermiteE обычно не равен 1.</target>
        </trans-unit>
        <trans-unit id="870417532aa77b335abb3ff61d44b3280649b54a" translate="yes" xml:space="preserve">
          <source>The coefficient of the last term is not generally 1 for monic polynomials in Laguerre form.</source>
          <target state="translated">Коэффициент последнего члена,как правило,не является 1 для монических полиномов в форме Лагера.</target>
        </trans-unit>
        <trans-unit id="d2eb9fcb4c7fc816e015e2f1263164865a84ea2c" translate="yes" xml:space="preserve">
          <source>The coefficient of the last term is not generally 1 for monic polynomials in Legendre form.</source>
          <target state="translated">Коэффициент последнего члена обычно не равен 1 для монических полиномов в форме Легенды.</target>
        </trans-unit>
        <trans-unit id="c0eab4462e93f35863c8383ff656ddde3733b00b" translate="yes" xml:space="preserve">
          <source>The coefficients are determined by multiplying together linear factors of the form &lt;code&gt;(x - r_i)&lt;/code&gt;, i.e.</source>
          <target state="translated">Коэффициенты определяются путем умножения линейных коэффициентов вида &lt;code&gt;(x - r_i)&lt;/code&gt; , т.е.</target>
        </trans-unit>
        <trans-unit id="96b42532f49d3b3a4358a0737c1292c860f167f7" translate="yes" xml:space="preserve">
          <source>The column &lt;code&gt;v[:, i]&lt;/code&gt; is the normalized eigenvector corresponding to the eigenvalue &lt;code&gt;w[i]&lt;/code&gt;. Will return a matrix object if &lt;code&gt;a&lt;/code&gt; is a matrix object.</source>
          <target state="translated">Столбец &lt;code&gt;v[:, i]&lt;/code&gt; - это нормализованный собственный вектор, соответствующий собственному значению &lt;code&gt;w[i]&lt;/code&gt; . Вернет объект матрицы, если &lt;code&gt;a&lt;/code&gt; является объектом матрицы.</target>
        </trans-unit>
        <trans-unit id="05afae6f6316038b8a077ed2d79753233c9700ab" translate="yes" xml:space="preserve">
          <source>The column dimension of the arrays for which the returned arrays will be valid. By default &lt;code&gt;m&lt;/code&gt; is taken equal to &lt;code&gt;n&lt;/code&gt;.</source>
          <target state="translated">Размер столбца массивов, для которых будут действительны возвращаемые массивы. По умолчанию &lt;code&gt;m&lt;/code&gt; принимается равным &lt;code&gt;n&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="049227627bd4dfed2d2a3d0a02023afddf2ece4d" translate="yes" xml:space="preserve">
          <source>The columns of the output matrix are powers of the input vector. The order of the powers is determined by the &lt;code&gt;increasing&lt;/code&gt; boolean argument. Specifically, when &lt;code&gt;increasing&lt;/code&gt; is False, the &lt;code&gt;i&lt;/code&gt;-th output column is the input vector raised element-wise to the power of &lt;code&gt;N - i - 1&lt;/code&gt;. Such a matrix with a geometric progression in each row is named for Alexandre- Theophile Vandermonde.</source>
          <target state="translated">Столбцы выходной матрицы являются степенями входного вектора. Порядок степеней определяется &lt;code&gt;increasing&lt;/code&gt; логическим аргументом. В частности, когда &lt;code&gt;increasing&lt;/code&gt; имеет значение Ложь, &lt;code&gt;i&lt;/code&gt; -й выходной столбец представляет собой входной вектор, поэтапно возведенный в степень &lt;code&gt;N - i - 1&lt;/code&gt; . Такая матрица с геометрической прогрессией в каждой строке названа в честь Александра-Теофиля Вандермонда.</target>
        </trans-unit>
        <trans-unit id="fd5ff7ed1e1b0436ec4f4722206a381ca973b853" translate="yes" xml:space="preserve">
          <source>The command &lt;code&gt;make test&lt;/code&gt; will ensure that all of the test software is built and then run all three test scripts.</source>
          <target state="translated">Команда &lt;code&gt;make test&lt;/code&gt; гарантирует, что все тестовое программное обеспечение создано, а затем запускает все три тестовых сценария.</target>
        </trans-unit>
        <trans-unit id="24aa155f0fb452987333532fc0871b6b96e25258" translate="yes" xml:space="preserve">
          <source>The common data type, which is the maximum of &lt;code&gt;array_types&lt;/code&gt; ignoring &lt;code&gt;scalar_types&lt;/code&gt;, unless the maximum of &lt;code&gt;scalar_types&lt;/code&gt; is of a different kind (&lt;a href=&quot;numpy.dtype.kind#numpy.dtype.kind&quot;&gt;&lt;code&gt;dtype.kind&lt;/code&gt;&lt;/a&gt;). If the kind is not understood, then None is returned.</source>
          <target state="translated">Общий тип данных, который представляет собой максимум из &lt;code&gt;array_types&lt;/code&gt; , игнорируя &lt;code&gt;scalar_types&lt;/code&gt; , если только максимум &lt;code&gt;scalar_types&lt;/code&gt; не имеет другого типа ( &lt;a href=&quot;numpy.dtype.kind#numpy.dtype.kind&quot;&gt; &lt;code&gt;dtype.kind&lt;/code&gt; &lt;/a&gt; ). Если вид не понят, возвращается None.</target>
        </trans-unit>
        <trans-unit id="6557c9bc2aa7a334ee156279cd2e6ed26882b290" translate="yes" xml:space="preserve">
          <source>The common fill value, or None.</source>
          <target state="translated">Общее заполняющее значение,или Нет.</target>
        </trans-unit>
        <trans-unit id="c7c4929011c41aa057f46d2bc4e51aaccf9a85a1" translate="yes" xml:space="preserve">
          <source>The companion matrix for power series cannot be made symmetric by scaling the basis, so this function differs from those for the orthogonal polynomials.</source>
          <target state="translated">Матрица-сопутствующая для силовых рядов не может быть симметричной при масштабировании базиса,поэтому эта функция отличается от матрицы для ортогональных полиномов.</target>
        </trans-unit>
        <trans-unit id="50728cc7411772baf0d23ae9dab7a04fd085919c" translate="yes" xml:space="preserve">
          <source>The comparison of &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; uses standard broadcasting, which means that &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; need not have the same shape in order for &lt;code&gt;allclose(a, b)&lt;/code&gt; to evaluate to True. The same is true for &lt;a href=&quot;numpy.equal#numpy.equal&quot;&gt;&lt;code&gt;equal&lt;/code&gt;&lt;/a&gt; but not &lt;a href=&quot;numpy.array_equal#numpy.array_equal&quot;&gt;&lt;code&gt;array_equal&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">При сравнении &lt;code&gt;a&lt;/code&gt; и &lt;code&gt;b&lt;/code&gt; используется стандартная широковещательная передача, а это означает, что &lt;code&gt;a&lt;/code&gt; и &lt;code&gt;b&lt;/code&gt; не обязательно должны иметь одинаковую форму, чтобы &lt;code&gt;allclose(a, b)&lt;/code&gt; оценивался как True. То же самое верно для &lt;a href=&quot;numpy.equal#numpy.equal&quot;&gt; &lt;code&gt;equal&lt;/code&gt; ,&lt;/a&gt; но не для &lt;a href=&quot;numpy.array_equal#numpy.array_equal&quot;&gt; &lt;code&gt;array_equal&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="ed9a376f5659e4753c56a46ffbea586e1c5b762b" translate="yes" xml:space="preserve">
          <source>The complex conjugate of &lt;code&gt;x&lt;/code&gt;, with same dtype as &lt;code&gt;y&lt;/code&gt;. This is a scalar if &lt;code&gt;x&lt;/code&gt; is a scalar.</source>
          <target state="translated">Комплексное сопряжение &lt;code&gt;x&lt;/code&gt; с тем же dtype, что и &lt;code&gt;y&lt;/code&gt; . Это скаляр, если &lt;code&gt;x&lt;/code&gt; - скаляр.</target>
        </trans-unit>
        <trans-unit id="d1ca0ff74dd3394813701dd385de23f306fa9c69" translate="yes" xml:space="preserve">
          <source>The complex conjugate of a complex number is obtained by changing the sign of its imaginary part.</source>
          <target state="translated">Комплексный конъюгат комплексного числа получается путем изменения знака его воображаемой части.</target>
        </trans-unit>
        <trans-unit id="41eb6fa093181f73897902c7f0874292edf29e51" translate="yes" xml:space="preserve">
          <source>The compressed array.</source>
          <target state="translated">Сжатый массив.</target>
        </trans-unit>
        <trans-unit id="5eb5823a400c379807aed8ab125dee97f320721d" translate="yes" xml:space="preserve">
          <source>The concatenated array with any masked entries preserved.</source>
          <target state="translated">Сокращенный массив с любыми маскированными записями сохраняется.</target>
        </trans-unit>
        <trans-unit id="a37868502a5a0d6add95945d1a64803e757adeaa" translate="yes" xml:space="preserve">
          <source>The concatenated array.</source>
          <target state="translated">Конкатенированный массив.</target>
        </trans-unit>
        <trans-unit id="3af59c1bb124d9d3dff66fb6d58de527a5027e82" translate="yes" xml:space="preserve">
          <source>The concept of a behaved segment is used in the description of the function pointers. A behaved segment is one that is aligned and in native machine byte-order for the data-type. The &lt;code&gt;nonzero&lt;/code&gt;, &lt;code&gt;copyswap&lt;/code&gt;, &lt;code&gt;copyswapn&lt;/code&gt;, &lt;code&gt;getitem&lt;/code&gt;, and &lt;code&gt;setitem&lt;/code&gt; functions can (and must) deal with mis-behaved arrays. The other functions require behaved memory segments.</source>
          <target state="translated">В описании указателей на функции используется понятие управляемого сегмента. Сегмент с поведением - это сегмент, который выровнен и имеет собственный машинный порядок байтов для типа данных. В &lt;code&gt;nonzero&lt;/code&gt; , &lt;code&gt;copyswap&lt;/code&gt; , &lt;code&gt;copyswapn&lt;/code&gt; , &lt;code&gt;getitem&lt;/code&gt; и &lt;code&gt;setitem&lt;/code&gt; функции могут (и должны) иметь дело с неправильно вели себя массивы. Для других функций требуются сегменты памяти с управляемым поведением.</target>
        </trans-unit>
        <trans-unit id="46e686c81ff0f33a7ee42cbdb148b2206e722231" translate="yes" xml:space="preserve">
          <source>The condition number of &lt;code&gt;x&lt;/code&gt; is defined as the norm of &lt;code&gt;x&lt;/code&gt; times the norm of the inverse of &lt;code&gt;x&lt;/code&gt;&lt;a href=&quot;#r611900c44d60-1&quot; id=&quot;id1&quot;&gt;[1]&lt;/a&gt;; the norm can be the usual L2-norm (root-of-sum-of-squares) or one of a number of other matrix norms.</source>
          <target state="translated">Число обусловленности &lt;code&gt;x&lt;/code&gt; определяется как норма &lt;code&gt;x&lt;/code&gt; , умноженная на норму, обратную &lt;code&gt;x&lt;/code&gt; &lt;a href=&quot;#r611900c44d60-1&quot; id=&quot;id1&quot;&gt;[1]&lt;/a&gt; ; норма может быть обычной L2-нормой (корень из суммы квадратов) или одной из ряда других матричных норм.</target>
        </trans-unit>
        <trans-unit id="7ed508e4defcab357510ceacda28d2924496cd06" translate="yes" xml:space="preserve">
          <source>The condition number of the matrix. May be infinite.</source>
          <target state="translated">Номер условия матрицы.Может быть бесконечным.</target>
        </trans-unit>
        <trans-unit id="c901451fe41cf6f1482465c84b6a4c739cbccbff" translate="yes" xml:space="preserve">
          <source>The config file generated from &lt;code&gt;template&lt;/code&gt; is installed in the given install directory, using &lt;code&gt;subst_dict&lt;/code&gt; for variable substitution.</source>
          <target state="translated">Файл конфигурации, созданный из &lt;code&gt;template&lt;/code&gt; , устанавливается в указанном каталоге установки с использованием &lt;code&gt;subst_dict&lt;/code&gt; для подстановки переменных.</target>
        </trans-unit>
        <trans-unit id="2fe0070d6ccb31708b92b4e4ed2caabdfe3d249d" translate="yes" xml:space="preserve">
          <source>The constants &lt;strong&gt;NPY_INTP&lt;/strong&gt; and &lt;strong&gt;NPY_UINTP&lt;/strong&gt; refer to an enumerated integer type that is large enough to hold a pointer on the platform. Index arrays should always be converted to &lt;strong&gt;NPY_INTP&lt;/strong&gt; , because the dimension of the array is of type npy_intp.</source>
          <target state="translated">Константы &lt;strong&gt;NPY_INTP&lt;/strong&gt; и &lt;strong&gt;NPY_UINTP&lt;/strong&gt; относятся к перечислимому целочисленному типу, который достаточно велик, чтобы содержать указатель на платформе. Индексные массивы всегда следует преобразовывать в &lt;strong&gt;NPY_INTP&lt;/strong&gt; , поскольку размерность массива имеет тип npy_intp.</target>
        </trans-unit>
        <trans-unit id="fd8a200b77c06e1513f552e8d61858be6438182d" translate="yes" xml:space="preserve">
          <source>The constructed array.</source>
          <target state="translated">Построенный массив.</target>
        </trans-unit>
        <trans-unit id="6f12164e316c899cbeec8a520db14b994fa35a8e" translate="yes" xml:space="preserve">
          <source>The contiguous constraint applies only to the inner loop, successive inner loops may have arbitrary pointer changes.</source>
          <target state="translated">Сопряженное ограничение относится только к внутреннему циклу,последовательные внутренние циклы могут иметь произвольное изменение указателя.</target>
        </trans-unit>
        <trans-unit id="a28f32d0e2528be0855bfa01e7539cc0e939d215" translate="yes" xml:space="preserve">
          <source>The convenience classes provided by the polynomial package are:</source>
          <target state="translated">Классы удобства,предоставляемые полиноминальным пакетом:</target>
        </trans-unit>
        <trans-unit id="5a4e9570e8f8bcacc96f206106a01eefad39bd6f" translate="yes" xml:space="preserve">
          <source>The convert method can also convert domain and window:</source>
          <target state="translated">Метод преобразования также может преобразовывать домен и окно:</target>
        </trans-unit>
        <trans-unit id="60131768e228b843852dbff6de95273c5e8b7bcb" translate="yes" xml:space="preserve">
          <source>The converted data-type.</source>
          <target state="translated">Преобразованный тип данных.</target>
        </trans-unit>
        <trans-unit id="1fc6b89fce1f12a34477c12a69d7cd751ad23c91" translate="yes" xml:space="preserve">
          <source>The convolution operator is often seen in signal processing, where it models the effect of a linear time-invariant system on a signal &lt;a href=&quot;#r95849f33d2b1-1&quot; id=&quot;id1&quot;&gt;[1]&lt;/a&gt;. In probability theory, the sum of two independent random variables is distributed according to the convolution of their individual distributions.</source>
          <target state="translated">Оператор свертки часто используется при обработке сигналов, где он моделирует влияние линейной инвариантной во времени системы на сигнал &lt;a href=&quot;#r95849f33d2b1-1&quot; id=&quot;id1&quot;&gt;[1]&lt;/a&gt; . В теории вероятностей сумма двух независимых случайных величин распределяется согласно свертке их индивидуальных распределений.</target>
        </trans-unit>
        <trans-unit id="1b7a113f553d13745aed52a84f8c20493ad427e3" translate="yes" xml:space="preserve">
          <source>The coordinates member of the &lt;a href=&quot;c-api.types-and-structures#c.PyArrayIterObject&quot;&gt;&lt;code&gt;PyArrayIterObject&lt;/code&gt;&lt;/a&gt; structure maintains the current N-d counter unless the underlying array is C-contiguous in which case the coordinate counting is by-passed. The index member of the &lt;a href=&quot;c-api.types-and-structures#c.PyArrayIterObject&quot;&gt;&lt;code&gt;PyArrayIterObject&lt;/code&gt;&lt;/a&gt; keeps track of the current flat index of the iterator. It is updated by the &lt;a href=&quot;c-api.array#c.PyArray_ITER_NEXT&quot;&gt;&lt;code&gt;PyArray_ITER_NEXT&lt;/code&gt;&lt;/a&gt; macro.</source>
          <target state="translated">Член координаты структуры &lt;a href=&quot;c-api.types-and-structures#c.PyArrayIterObject&quot;&gt; &lt;code&gt;PyArrayIterObject&lt;/code&gt; &lt;/a&gt; поддерживает текущий счетчик Nd, если только базовый массив не является C-смежным, и в этом случае подсчет координат не выполняется. Член индекса &lt;a href=&quot;c-api.types-and-structures#c.PyArrayIterObject&quot;&gt; &lt;code&gt;PyArrayIterObject&lt;/code&gt; &lt;/a&gt; отслеживает текущий плоский индекс итератора. Он обновляется &lt;a href=&quot;c-api.array#c.PyArray_ITER_NEXT&quot;&gt; &lt;code&gt;PyArray_ITER_NEXT&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="893c6dfe4a5a151e44d6687fac35fbd3b646a45a" translate="yes" xml:space="preserve">
          <source>The core dimensions are removed from all inputs and the remaining dimensions are broadcast together, defining the loop dimensions.</source>
          <target state="translated">Размеры ядра удаляются со всех входов,а остальные размеры передаются вместе,определяя размеры петли.</target>
        </trans-unit>
        <trans-unit id="72b350bebf37a78a10162e24af07cb3168e9e839" translate="yes" xml:space="preserve">
          <source>The core of the ufunc is the &lt;a href=&quot;#c.PyUFuncObject&quot;&gt;&lt;code&gt;PyUFuncObject&lt;/code&gt;&lt;/a&gt; which contains all the information needed to call the underlying C-code loops that perform the actual work. While it is described here for completeness, it should be considered internal to NumPy and manipulated via &lt;code&gt;PyUFunc_*&lt;/code&gt; functions. The size of this structure is subject to change across versions of NumPy. To ensure compatibility:</source>
          <target state="translated">Ядром ufunc является &lt;a href=&quot;#c.PyUFuncObject&quot;&gt; &lt;code&gt;PyUFuncObject&lt;/code&gt; ,&lt;/a&gt; который содержит всю информацию, необходимую для вызова базовых циклов C-кода, которые выполняют фактическую работу. Хотя он описан здесь для полноты, он должен считаться внутренним для NumPy и управляться через функции &lt;code&gt;PyUFunc_*&lt;/code&gt; . Размер этой структуры может меняться в разных версиях NumPy. Для обеспечения совместимости:</target>
        </trans-unit>
        <trans-unit id="76b4be14cc8fe5491309195ba608e3525321fc00" translate="yes" xml:space="preserve">
          <source>The correlation coefficient matrix of the variables.</source>
          <target state="translated">Матрица коэффициентов корреляции переменных.</target>
        </trans-unit>
        <trans-unit id="f4e710373f0588180cd5157b94f36ff64a509ad5" translate="yes" xml:space="preserve">
          <source>The corresponding angle in degrees. This is a scalar if &lt;code&gt;x&lt;/code&gt; is a scalar.</source>
          <target state="translated">Соответствующий угол в градусах. Это скаляр, если &lt;code&gt;x&lt;/code&gt; - скаляр.</target>
        </trans-unit>
        <trans-unit id="a2c63fcb50ab2a66bb9a9ad01ce9f4ff69c1d271" translate="yes" xml:space="preserve">
          <source>The corresponding angle in radians. This is a scalar if &lt;code&gt;x&lt;/code&gt; is a scalar.</source>
          <target state="translated">Соответствующий угол в радианах. Это скаляр, если &lt;code&gt;x&lt;/code&gt; - скаляр.</target>
        </trans-unit>
        <trans-unit id="c2babda63010514076aef395fac45645683b9564" translate="yes" xml:space="preserve">
          <source>The corresponding array scalar type is &lt;code&gt;int32&lt;/code&gt;.</source>
          <target state="translated">Соответствующий скалярный тип массива - &lt;code&gt;int32&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="cd11fa4205dd5b33a3e2b183413534954599bad7" translate="yes" xml:space="preserve">
          <source>The corresponding cosine values. This is a scalar if &lt;code&gt;x&lt;/code&gt; is a scalar.</source>
          <target state="translated">Соответствующие значения косинуса. Это скаляр, если &lt;code&gt;x&lt;/code&gt; - скаляр.</target>
        </trans-unit>
        <trans-unit id="6d98f6605847a59a64fcad02a0b3d4fdfd44ca3d" translate="yes" xml:space="preserve">
          <source>The corresponding degree values; if &lt;code&gt;out&lt;/code&gt; was supplied this is a reference to it. This is a scalar if &lt;code&gt;x&lt;/code&gt; is a scalar.</source>
          <target state="translated">Соответствующие значения в градусах; если был поставлен &lt;code&gt;out&lt;/code&gt; , это ссылка на него. Это скаляр, если &lt;code&gt;x&lt;/code&gt; - скаляр.</target>
        </trans-unit>
        <trans-unit id="2584010810109879710934f24451582df80fa088" translate="yes" xml:space="preserve">
          <source>The corresponding hyperbolic sine values. This is a scalar if &lt;code&gt;x&lt;/code&gt; is a scalar.</source>
          <target state="translated">Соответствующие значения гиперболического синуса. Это скаляр, если &lt;code&gt;x&lt;/code&gt; - скаляр.</target>
        </trans-unit>
        <trans-unit id="2f46b05f80b785698faf42d321e3104fa7625e8a" translate="yes" xml:space="preserve">
          <source>The corresponding hyperbolic tangent values. This is a scalar if &lt;code&gt;x&lt;/code&gt; is a scalar.</source>
          <target state="translated">Соответствующие значения гиперболического тангенса. Это скаляр, если &lt;code&gt;x&lt;/code&gt; - скаляр.</target>
        </trans-unit>
        <trans-unit id="d9ca95035c9f509708b9e99487c1ebe9e3ab11bd" translate="yes" xml:space="preserve">
          <source>The corresponding radian values. This is a scalar if &lt;code&gt;x&lt;/code&gt; is a scalar.</source>
          <target state="translated">Соответствующие значения в радианах. Это скаляр, если &lt;code&gt;x&lt;/code&gt; - скаляр.</target>
        </trans-unit>
        <trans-unit id="c1e4a7360c69977ad10edc5bee560d5ac06dcf90" translate="yes" xml:space="preserve">
          <source>The corresponding tangent values. This is a scalar if &lt;code&gt;x&lt;/code&gt; is a scalar.</source>
          <target state="translated">Соответствующие значения касательных. Это скаляр, если &lt;code&gt;x&lt;/code&gt; - скаляр.</target>
        </trans-unit>
        <trans-unit id="f1763b6e0e62ea8d29f68696fab1bd4ea96474d4" translate="yes" xml:space="preserve">
          <source>The cost for a matrix multiplication can be calculated with the following function:</source>
          <target state="translated">Стоимость умножения матриц можно рассчитать с помощью следующей функции:</target>
        </trans-unit>
        <trans-unit id="6933bada15117031adec212786a3dbdf77a91aff" translate="yes" xml:space="preserve">
          <source>The costs for the two different parenthesizations are as follows:</source>
          <target state="translated">Расходы по двум различным скобкам приведены ниже:</target>
        </trans-unit>
        <trans-unit id="71417050531966fa2bba7739241abcc4b67310e0" translate="yes" xml:space="preserve">
          <source>The counterclockwise angle from the positive real axis on the complex plane in the range &lt;code&gt;(-pi, pi]&lt;/code&gt;, with dtype as numpy.float64.</source>
          <target state="translated">Угол против часовой стрелки от положительной действительной оси на комплексной плоскости в диапазоне &lt;code&gt;(-pi, pi]&lt;/code&gt; , с dtype как numpy.float64.</target>
        </trans-unit>
        <trans-unit id="703b92f1857fec3346f55e95a27ed079fdf918ac" translate="yes" xml:space="preserve">
          <source>The covariance matrix of the variables.</source>
          <target state="translated">Ковариационная матрица переменных.</target>
        </trans-unit>
        <trans-unit id="f56bfc3801b5981a49e90ddd94a5011933b03e11" translate="yes" xml:space="preserve">
          <source>The cross product of &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; in</source>
          <target state="translated">Перекрестное произведение &lt;code&gt;a&lt;/code&gt; и &lt;code&gt;b&lt;/code&gt; в</target>
        </trans-unit>
        <trans-unit id="d70737d8a9b599cea578eef90e469f4ec5cade8d" translate="yes" xml:space="preserve">
          <source>The cumulative product for each column (i.e., over the rows) of &lt;code&gt;a&lt;/code&gt;:</source>
          <target state="translated">Кумулятивная продукт для каждого столбца (т.е. по строкам) из : &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="4974aaba8d216c55c50471b0bc56ddd6323d0ebc" translate="yes" xml:space="preserve">
          <source>The cumulative product for each row (i.e. over the columns) of &lt;code&gt;a&lt;/code&gt;:</source>
          <target state="translated">Кумулятивная продукт для каждой строки (т.е. по столбцам) из : &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="50631d91282d5f6763c8dcfd14a90d74339342d9" translate="yes" xml:space="preserve">
          <source>The current (1-d) index into the broadcasted result.</source>
          <target state="translated">Текущий (1-d)индекс в транслируемом результате.</target>
        </trans-unit>
        <trans-unit id="8c233acaa927b0b3ae6437f9077a3fae3621ed5f" translate="yes" xml:space="preserve">
          <source>The current 1-d index into the array.</source>
          <target state="translated">Текущий 1-d индекс в массиве.</target>
        </trans-unit>
        <trans-unit id="cbb3baf8a681bbb5337a5050d23b30de4d838c39" translate="yes" xml:space="preserve">
          <source>The current error handler. If no handler was set through &lt;a href=&quot;numpy.seterrcall#numpy.seterrcall&quot;&gt;&lt;code&gt;seterrcall&lt;/code&gt;&lt;/a&gt;, &lt;code&gt;None&lt;/code&gt; is returned.</source>
          <target state="translated">Текущий обработчик ошибок. Если через &lt;a href=&quot;numpy.seterrcall#numpy.seterrcall&quot;&gt; &lt;code&gt;seterrcall&lt;/code&gt; &lt;/a&gt; не был установлен обработчик , возвращается &lt;code&gt;None&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="fcd1e82b97c62204928be3c1426e12c2f8f2093c" translate="yes" xml:space="preserve">
          <source>The current interface remains unchanged, and &lt;code&gt;PyUFunc_FromFuncAndData&lt;/code&gt; can still be used to implement (specialized) ufuncs, consisting of scalar elementary functions.</source>
          <target state="translated">Текущий интерфейс остается неизменным, и &lt;code&gt;PyUFunc_FromFuncAndData&lt;/code&gt; все еще может использоваться для реализации (специализированных) u-функций, состоящих из скалярных элементарных функций.</target>
        </trans-unit>
        <trans-unit id="4809e84f7d3a9eb68e3d6e9384c7ac43b19e108c" translate="yes" xml:space="preserve">
          <source>The current version of the ndarray object (check to see if this variable is defined to guarantee the numpy/arrayobject.h header is being used).</source>
          <target state="translated">Текущая версия объекта ndarray (проверьте,определена ли эта переменная,чтобы гарантировать использование заголовка numpy/arrayobject.h).</target>
        </trans-unit>
        <trans-unit id="d02692cc2b9183733a0e1ac33e907e722f2cb651" translate="yes" xml:space="preserve">
          <source>The data actually stored in object arrays (&lt;em&gt;i.e.&lt;/em&gt;, arrays having dtype &lt;code&gt;object_&lt;/code&gt;) are references to Python objects, not the objects themselves. Hence, object arrays behave more like usual Python &lt;a href=&quot;https://docs.python.org/dev/library/stdtypes.html#list&quot;&gt;&lt;code&gt;lists&lt;/code&gt;&lt;/a&gt;, in the sense that their contents need not be of the same Python type.</source>
          <target state="translated">Данные, фактически хранящиеся в массивах объектов ( &lt;em&gt;т.&lt;/em&gt; Е. В массивах с dtype &lt;code&gt;object_&lt;/code&gt; ), являются ссылками на объекты Python, а не сами объекты. Следовательно, массивы объектов ведут себя больше как обычные &lt;a href=&quot;https://docs.python.org/dev/library/stdtypes.html#list&quot;&gt; &lt;code&gt;lists&lt;/code&gt; &lt;/a&gt; Python в том смысле, что их содержимое не обязательно должно быть одного типа Python.</target>
        </trans-unit>
        <trans-unit id="2b8f4fa1516918fd8297afcfb360ffa13708823d" translate="yes" xml:space="preserve">
          <source>The data and all elements are aligned appropriately for the hardware.</source>
          <target state="translated">Данные и все элементы выровнены в соответствии с аппаратным обеспечением.</target>
        </trans-unit>
        <trans-unit id="3286aa81b485c3d7add58cb76776a5c44fcb4bf2" translate="yes" xml:space="preserve">
          <source>The data area and all array elements are aligned appropriately.</source>
          <target state="translated">Область данных и все элементы массива выровнены соответствующим образом.</target>
        </trans-unit>
        <trans-unit id="c1365a86184a90bddcccd2199d804c180d307014" translate="yes" xml:space="preserve">
          <source>The data area can be written to.</source>
          <target state="translated">Область данных может быть записана в.</target>
        </trans-unit>
        <trans-unit id="539587e7a7889df8e80a73151cc3ac06f87c111c" translate="yes" xml:space="preserve">
          <source>The data area can be written to. Setting this to False locks the data, making it read-only. A view (slice, etc.) inherits WRITEABLE from its base array at creation time, but a view of a writeable array may be subsequently locked while the base array remains writeable. (The opposite is not true, in that a view of a locked array may not be made writeable. However, currently, locking a base object does not lock any views that already reference it, so under that circumstance it is possible to alter the contents of a locked array via a previously created writeable view onto it.) Attempting to change a non-writeable array raises a RuntimeError exception.</source>
          <target state="translated">Область данных может быть записана в.Установка False блокирует данные,делая их доступными только для чтения.Вид (срез и т.д.)наследует WRITEABLE от своего базового массива на момент создания,но вид массива,доступного для записи,может быть впоследствии заблокирован,в то время как базовый массив остается доступным для записи.(Обратное не верно,так как вид заблокированного массива может быть не доступен для записи.Однако в настоящее время блокировка базового объекта не блокирует уже ссылающиеся на него виды,поэтому в этом случае можно изменить содержимое заблокированного массива с помощью ранее созданного вида массива,доступного для записи).При попытке изменить массив,не подлежащий записи,возникает исключение RuntimeError.</target>
        </trans-unit>
        <trans-unit id="dfe7ced9a654feaf927f01f408558bf43f63134c" translate="yes" xml:space="preserve">
          <source>The data area is in C-style contiguous order (last index varies the fastest).</source>
          <target state="translated">Область данных находится в непрерывном порядке в стиле С (последний индекс изменяется быстрее всего).</target>
        </trans-unit>
        <trans-unit id="28271e4f2d83215b5c3293be14583eebd0638934" translate="yes" xml:space="preserve">
          <source>The data area is in Fortran-style contiguous order (first index varies the fastest).</source>
          <target state="translated">Область данных находится в непрерывном порядке в стиле Фортран (первый индекс изменяется быстрее всего).</target>
        </trans-unit>
        <trans-unit id="a2e621a0b9254b737a1faf535f1456a6f33c01ae" translate="yes" xml:space="preserve">
          <source>The data area is owned by this array.</source>
          <target state="translated">Область данных принадлежит этому массиву.</target>
        </trans-unit>
        <trans-unit id="ca9e054ad351441ecdb18cea4952500858e11b12" translate="yes" xml:space="preserve">
          <source>The data area represents a (well-behaved) copy whose information should be transferred back to the original when &lt;a href=&quot;#c.PyArray_ResolveWritebackIfCopy&quot;&gt;&lt;code&gt;PyArray_ResolveWritebackIfCopy&lt;/code&gt;&lt;/a&gt; is called.</source>
          <target state="translated">Область данных представляет собой (корректную) копию, информация которой должна быть передана обратно в оригинал при &lt;a href=&quot;#c.PyArray_ResolveWritebackIfCopy&quot;&gt; &lt;code&gt;PyArray_ResolveWritebackIfCopy&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="15eb3cf2a1c1abdf07a79e9fe9ea7b5a63c62afd" translate="yes" xml:space="preserve">
          <source>The data in the array is returned as a single string. This function is similar to &lt;a href=&quot;numpy.array_repr#numpy.array_repr&quot;&gt;&lt;code&gt;array_repr&lt;/code&gt;&lt;/a&gt;, the difference being that &lt;a href=&quot;numpy.array_repr#numpy.array_repr&quot;&gt;&lt;code&gt;array_repr&lt;/code&gt;&lt;/a&gt; also returns information on the kind of array and its data type.</source>
          <target state="translated">Данные в массиве возвращаются в виде одной строки. Эта функция похожа на &lt;a href=&quot;numpy.array_repr#numpy.array_repr&quot;&gt; &lt;code&gt;array_repr&lt;/code&gt; &lt;/a&gt; , с той разницей, что &lt;a href=&quot;numpy.array_repr#numpy.array_repr&quot;&gt; &lt;code&gt;array_repr&lt;/code&gt; &lt;/a&gt; также возвращает информацию о типе массива и его типе данных.</target>
        </trans-unit>
        <trans-unit id="4cbbe8ca710f692f60ad1bfe0fc2af00b27f6fa9" translate="yes" xml:space="preserve">
          <source>The data in the same field can be heterogeneous, they will be promoted to the highest data type. This method is intended for creating smaller record arrays. If used to create large array without formats defined</source>
          <target state="translated">Данные в одной и той же области могут быть неоднородными,они будут продвигаться к самому высокому типу данных.Этот метод предназначен для создания массивов записей меньшего размера.Если используется для создания больших массивов без заданных форматов</target>
        </trans-unit>
        <trans-unit id="f030fb38724d73d189a884d6cd4eaca4e1c69e90" translate="yes" xml:space="preserve">
          <source>The data is in a single, C-style contiguous segment.</source>
          <target state="translated">Данные находятся в одном смежном сегменте в стиле С.</target>
        </trans-unit>
        <trans-unit id="5f1d8da4b437441472e9916d9ae01c496d02e5d4" translate="yes" xml:space="preserve">
          <source>The data is in a single, Fortran-style contiguous segment.</source>
          <target state="translated">Данные находятся в одном смежном сегменте в стиле Фортран.</target>
        </trans-unit>
        <trans-unit id="56a1a480524e7bf67ab594cb10c3c6101b00713c" translate="yes" xml:space="preserve">
          <source>The data of the resulting array will not be byteswapped, but will be interpreted correctly.</source>
          <target state="translated">Данные результирующего массива не будут заменяться байтами,а будут корректно интерпретированы.</target>
        </trans-unit>
        <trans-unit id="b88d2dbaff9987ad87362817ef4a120d93a6244e" translate="yes" xml:space="preserve">
          <source>The data to be histogrammed.</source>
          <target state="translated">Данные для гистограммирования.</target>
        </trans-unit>
        <trans-unit id="5386b778229b14d65914edc6d972b4efb28b5001" translate="yes" xml:space="preserve">
          <source>The data type object associated with the array can be found in the &lt;a href=&quot;generated/numpy.ndarray.dtype#numpy.ndarray.dtype&quot;&gt;&lt;code&gt;dtype&lt;/code&gt;&lt;/a&gt; attribute:</source>
          <target state="translated">Объект типа данных, связанный с массивом, можно найти в &lt;a href=&quot;generated/numpy.ndarray.dtype#numpy.ndarray.dtype&quot;&gt; &lt;code&gt;dtype&lt;/code&gt; &lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="1c7886ffa6332318e280aa7625497d4df1ee7f24" translate="yes" xml:space="preserve">
          <source>The data type of &lt;code&gt;rep&lt;/code&gt;.</source>
          <target state="translated">Тип данных &lt;code&gt;rep&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4b822d3fbc39f811ebad48ba4194f76d214d3123" translate="yes" xml:space="preserve">
          <source>The data type of an operand with this flag should be either &lt;a href=&quot;c-api.dtype#c.NPY_BOOL&quot;&gt;&lt;code&gt;NPY_BOOL&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;c-api.dtype#c.NPY_MASK&quot;&gt;&lt;code&gt;NPY_MASK&lt;/code&gt;&lt;/a&gt;, or a struct dtype whose fields are all valid mask dtypes. In the latter case, it must match up with a struct operand being WRITEMASKED, as it is specifying a mask for each field of that array.</source>
          <target state="translated">Тип данных операнда с этим флагом должен быть &lt;a href=&quot;c-api.dtype#c.NPY_BOOL&quot;&gt; &lt;code&gt;NPY_BOOL&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;c-api.dtype#c.NPY_MASK&quot;&gt; &lt;code&gt;NPY_MASK&lt;/code&gt; &lt;/a&gt; или struct dtype, все поля которой являются допустимыми dtypes маски. В последнем случае он должен совпадать с операндом структуры WRITEMASKED, поскольку он определяет маску для каждого поля этого массива.</target>
        </trans-unit>
        <trans-unit id="11db59fda83e28216c250b45f855268127882d3e" translate="yes" xml:space="preserve">
          <source>The data type of the array; default: float. For binary input data, the data must be in exactly this format.</source>
          <target state="translated">Тип данных массива;по умолчанию:float.Для двоичных входных данных данные должны быть именно в этом формате.</target>
        </trans-unit>
        <trans-unit id="6121c8d9cd39c4f61e9ffef0d098e3b7d36639d6" translate="yes" xml:space="preserve">
          <source>The data type of the output of &lt;code&gt;vectorized&lt;/code&gt; is determined by calling the function with the first element of the input. This can be avoided by specifying the &lt;code&gt;otypes&lt;/code&gt; argument.</source>
          <target state="translated">Тип данных вывода &lt;code&gt;vectorized&lt;/code&gt; определяется путем вызова функции с первым элементом ввода. Этого можно избежать, указав аргумент &lt;code&gt;otypes&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="bc2814a7f847db35d30b7458174ec64d03a7e7a5" translate="yes" xml:space="preserve">
          <source>The data type of the view. The dtype size of the view can not be larger than that of the array itself.</source>
          <target state="translated">Тип данных представления.Размер d-типа представления не может быть больше,чем размер самого массива.</target>
        </trans-unit>
        <trans-unit id="99643c3f7e25f9a00992f90ee5d0bdd7cb79f63e" translate="yes" xml:space="preserve">
          <source>The data types of the values provided in &lt;a href=&quot;numpy.nditer.value#numpy.nditer.value&quot;&gt;&lt;code&gt;value&lt;/code&gt;&lt;/a&gt;. This may be different from the operand data types if buffering is enabled. Valid only before the iterator is closed.</source>
          <target state="translated">Типы данных значений, представленных в &lt;a href=&quot;numpy.nditer.value#numpy.nditer.value&quot;&gt; &lt;code&gt;value&lt;/code&gt; &lt;/a&gt; . Они могут отличаться от типов данных операндов, если буферизация включена. Действует только до закрытия итератора.</target>
        </trans-unit>
        <trans-unit id="9d016fef105a6db00651ac782a1c7e9c999e6600" translate="yes" xml:space="preserve">
          <source>The data-type is an important abstraction of the ndarray. Operations will look to the data-type to provide the key functionality that is needed to operate on the array. This functionality is provided in the list of function pointers pointed to by the &amp;lsquo;f&amp;rsquo; member of the &lt;a href=&quot;c-api.types-and-structures#c.PyArray_Descr&quot;&gt;&lt;code&gt;PyArray_Descr&lt;/code&gt;&lt;/a&gt; structure. In this way, the number of data-types can be extended simply by providing a &lt;a href=&quot;c-api.types-and-structures#c.PyArray_Descr&quot;&gt;&lt;code&gt;PyArray_Descr&lt;/code&gt;&lt;/a&gt; structure with suitable function pointers in the &amp;lsquo;f&amp;rsquo; member. For built-in types there are some optimizations that by-pass this mechanism, but the point of the data- type abstraction is to allow new data-types to be added.</source>
          <target state="translated">Тип данных - важная абстракция ndarray. Операции будут обращать внимание на тип данных, чтобы обеспечить ключевые функции, необходимые для работы с массивом. Эта функциональность предоставляется в списке указателей функций, на которые указывает член 'f' структуры &lt;a href=&quot;c-api.types-and-structures#c.PyArray_Descr&quot;&gt; &lt;code&gt;PyArray_Descr&lt;/code&gt; &lt;/a&gt; . Таким образом, количество типов данных можно расширить, просто предоставив структуру &lt;a href=&quot;c-api.types-and-structures#c.PyArray_Descr&quot;&gt; &lt;code&gt;PyArray_Descr&lt;/code&gt; &lt;/a&gt; с подходящими указателями на функции в члене 'f'. Для встроенных типов есть некоторые оптимизации, которые обходят этот механизм, но суть абстракции типов данных состоит в том, чтобы разрешить добавление новых типов данных.</target>
        </trans-unit>
        <trans-unit id="b58fbdafeaa8107e58c408c096a3cb8ca5d659d7" translate="yes" xml:space="preserve">
          <source>The data-type of the returned array.</source>
          <target state="translated">Тип данных возвращаемого массива.</target>
        </trans-unit>
        <trans-unit id="5c8d679fa5d2836b35d4e189ea3c3c42c4a9bfcc" translate="yes" xml:space="preserve">
          <source>The data-type used to interpret the file contents. Default is &lt;code&gt;uint8&lt;/code&gt;.</source>
          <target state="translated">Тип данных, используемый для интерпретации содержимого файла. По умолчанию &lt;code&gt;uint8&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e1e17b816f5aa8d3b539033dd4f8579bd040ce7c" translate="yes" xml:space="preserve">
          <source>The data-type used to represent the intermediate results. Defaults to the data-type of the output array if such is provided, or the the data-type of the input array if no output array is provided.</source>
          <target state="translated">Тип данных,используемый для представления промежуточных результатов.По умолчанию используется тип данных выходного массива,если он предоставляется,или тип данных входного массива,если выходной массив не предоставляется.</target>
        </trans-unit>
        <trans-unit id="932e882a29033e270334b0a0ca27c7a0b749d38c" translate="yes" xml:space="preserve">
          <source>The data-type-descriptor object of the base-type.</source>
          <target state="translated">Объект описания типа данных базового типа.</target>
        </trans-unit>
        <trans-unit id="d6987a7425e0ff97a8320c32ec6abc8ee62f4f4d" translate="yes" xml:space="preserve">
          <source>The datatype determines which of &amp;lsquo;mergesort&amp;rsquo; or &amp;lsquo;timsort&amp;rsquo; is actually used, even if &amp;lsquo;mergesort&amp;rsquo; is specified. User selection at a finer scale is not currently available.</source>
          <target state="translated">Тип данных определяет, какой из &amp;laquo;mergesort&amp;raquo; или &amp;laquo;timsort&amp;raquo; фактически используется, даже если &amp;laquo;mergesort&amp;raquo; указан. Выбор пользователя в более точном масштабе в настоящее время недоступен.</target>
        </trans-unit>
        <trans-unit id="f8494cadb009486b1d5ee5b6a13352cbf85e331c" translate="yes" xml:space="preserve">
          <source>The datetime API is &lt;em&gt;experimental&lt;/em&gt; in 1.7.0, and may undergo changes in future versions of NumPy.</source>
          <target state="translated">API datetime является &lt;em&gt;экспериментальным&lt;/em&gt; в версии 1.7.0 и может претерпеть изменения в будущих версиях NumPy.</target>
        </trans-unit>
        <trans-unit id="5a29e38fde2fbef6d304ea68f9f28e90e826577d" translate="yes" xml:space="preserve">
          <source>The datetime object represents a single moment in time. If two datetimes have different units, they may still be representing the same moment of time, and converting from a bigger unit like months to a smaller unit like days is considered a &amp;lsquo;safe&amp;rsquo; cast because the moment of time is still being represented exactly.</source>
          <target state="translated">Объект datetime представляет отдельный момент времени. Если два datetime имеют разные единицы, они могут по-прежнему представлять один и тот же момент времени, и преобразование большей единицы, такой как месяцы, в меньшую, например, дней, считается &amp;laquo;безопасным&amp;raquo; приведением, потому что момент времени по-прежнему отображается точно.</target>
        </trans-unit>
        <trans-unit id="96194d206533dca35ec887829a70fc8982e7d450" translate="yes" xml:space="preserve">
          <source>The datetime string parser in NumPy 1.6 is very liberal in what it accepts, and silently allows invalid input without raising errors. The parser in NumPy 1.7 is quite strict about only accepting ISO 8601 dates, with a few convenience extensions. 1.6 always creates microsecond (us) units by default, whereas 1.7 detects a unit based on the format of the string. Here is a comparison.:</source>
          <target state="translated">Парсер строк даты в NumPy 1.6 очень либеральный в том,что он принимает,и беззвучно допускает некорректный ввод,не вызывая ошибок.Парсер в NumPy 1.7 достаточно строг в том,чтобы принимать только даты ISO 8601,с несколькими удобными расширениями.1.6 по умолчанию всегда создает микросекундные (нам)единицы,в то время как 1.7 определяет единицу по формату строки.Вот сравнение:</target>
        </trans-unit>
        <trans-unit id="1369383d5a514fcfed8df04d6ed924de54d6f3b1" translate="yes" xml:space="preserve">
          <source>The datetime type works with many common NumPy functions, for example &lt;a href=&quot;generated/numpy.arange#numpy.arange&quot;&gt;&lt;code&gt;arange&lt;/code&gt;&lt;/a&gt; can be used to generate ranges of dates.</source>
          <target state="translated">Тип datetime работает со многими распространенными функциями NumPy, например, &lt;a href=&quot;generated/numpy.arange#numpy.arange&quot;&gt; &lt;code&gt;arange&lt;/code&gt; &lt;/a&gt; можно использовать для генерации диапазонов дат.</target>
        </trans-unit>
        <trans-unit id="60d7f83834880a987611358eebe758ac593dc7d2" translate="yes" xml:space="preserve">
          <source>The decomposition is performed using LAPACK routine &lt;code&gt;_gesdd&lt;/code&gt;.</source>
          <target state="translated">Декомпозиция выполняется с использованием подпрограммы LAPACK &lt;code&gt;_gesdd&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e1516fc7b62e4a0344208958aa595053689db869" translate="yes" xml:space="preserve">
          <source>The decorated test &lt;code&gt;t&lt;/code&gt;.</source>
          <target state="translated">Декорированный тест &lt;code&gt;t&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e9657b7f30a96eb6a9709525e36cff8e84658cbb" translate="yes" xml:space="preserve">
          <source>The decorator itself is decorated with the &lt;code&gt;nose.tools.make_decorator&lt;/code&gt; function in order to transmit function name, and various other metadata.</source>
          <target state="translated">Сам декоратор украшен функцией &lt;code&gt;nose.tools.make_decorator&lt;/code&gt; для передачи имени функции и различных других метаданных.</target>
        </trans-unit>
        <trans-unit id="4a37da8a9aa52a4088272dd54ccf6dae2a209ad8" translate="yes" xml:space="preserve">
          <source>The default &lt;code&gt;atol&lt;/code&gt; is not appropriate for comparing numbers that are much smaller than one (see Notes).</source>
          <target state="translated">&lt;code&gt;atol&lt;/code&gt; умолчанию не подходит для сравнения чисел, которые намного меньше единицы (см. Примечания).</target>
        </trans-unit>
        <trans-unit id="cb5293865f62263e0a19bbfa34c77f6486814f1d" translate="yes" xml:space="preserve">
          <source>The default __array_priority__ of matrix objects is 10.0, and therefore mixed operations with ndarrays always produce matrices.</source>
          <target state="translated">По умолчанию __приоритет_массивов_объектов матрицы равен 10.0,поэтому смешанные операции с ndarrays всегда приводят к появлению матриц.</target>
        </trans-unit>
        <trans-unit id="cd69cae26ca025156d4d72a557a24e650bb3e040" translate="yes" xml:space="preserve">
          <source>The default character, this is returned if none of the characters in &lt;code&gt;typechars&lt;/code&gt; matches a character in &lt;code&gt;typeset&lt;/code&gt;.</source>
          <target state="translated">По умолчанию символ, это возвращается , если ни один из персонажей &lt;code&gt;typechars&lt;/code&gt; не соответствует символ в &lt;code&gt;typeset&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a9f67bac25f1e9fa1addb151018aeaf9def3b945" translate="yes" xml:space="preserve">
          <source>The default data type in NumPy is &lt;code&gt;float_&lt;/code&gt;.</source>
          <target state="translated">Тип данных по умолчанию в NumPy - &lt;code&gt;float_&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1cb916c2a199dec22e3c7d35ff5ca943ade2af02" translate="yes" xml:space="preserve">
          <source>The default data type: &lt;code&gt;float_&lt;/code&gt;.</source>
          <target state="translated">Тип данных по умолчанию: &lt;code&gt;float_&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="585140e706eb572d257d276596c7c62733d99ac8" translate="yes" xml:space="preserve">
          <source>The default fill value.</source>
          <target state="translated">Значение заполнения по умолчанию.</target>
        </trans-unit>
        <trans-unit id="a6dbb84bde95674721b5026ade7be2a1d41460db" translate="yes" xml:space="preserve">
          <source>The default filling value depends on the datatype of the input array or the type of the input scalar:</source>
          <target state="translated">Значение заполнения по умолчанию зависит от типа входного массива или типа входного скаляра:</target>
        </trans-unit>
        <trans-unit id="d172f7f7da97c607ca46d821dc996e8763c04a60" translate="yes" xml:space="preserve">
          <source>The default for busday functions is that the only valid days are Monday through Friday (the usual business days). The implementation is based on a &amp;ldquo;weekmask&amp;rdquo; containing 7 Boolean flags to indicate valid days; custom weekmasks are possible that specify other sets of valid days.</source>
          <target state="translated">По умолчанию для функций рабочего дня допустимы только дни с понедельника по пятницу (обычные рабочие дни). Реализация основана на &amp;laquo;маске недели&amp;raquo;, содержащей 7 логических флагов, указывающих допустимые дни; возможны настраиваемые недельные маски, указывающие другие наборы допустимых дней.</target>
        </trans-unit>
        <trans-unit id="b9e6f3b39a9841c2072fe28c903a4873d59b58cf" translate="yes" xml:space="preserve">
          <source>The default for most operations, raises an exception if an index is out of bounds.</source>
          <target state="translated">По умолчанию для большинства операций,вызывает исключение,если индекс находится вне пределов.</target>
        </trans-unit>
        <trans-unit id="0b3aadfe669f7dc7282a8bf3bc7021b967d5f363" translate="yes" xml:space="preserve">
          <source>The default is not to change the current behavior.</source>
          <target state="translated">По умолчанию не изменять текущее поведение.</target>
        </trans-unit>
        <trans-unit id="13f5430198109332da2b945e817fa963554a0039" translate="yes" xml:space="preserve">
          <source>The default iterator of an ndarray object is the default Python iterator of a sequence type. Thus, when the array object itself is used as an iterator. The default behavior is equivalent to:</source>
          <target state="translated">Итератором объекта ndarray по умолчанию является Python-итератор типа последовательности.Таким образом,когда в качестве итератора используется сам объект массива.Поведение по умолчанию эквивалентно:</target>
        </trans-unit>
        <trans-unit id="d0a1e3c85492f9a28cfa2d6a52018d6303212281" translate="yes" xml:space="preserve">
          <source>The default normalization has the direct transforms unscaled and the inverse transforms are scaled by</source>
          <target state="translated">При нормализации по умолчанию прямые преобразования не масштабируются,а обратные преобразования масштабируются с помощью</target>
        </trans-unit>
        <trans-unit id="d79f5666dde2a74098ca71f007435f35059e5b3e" translate="yes" xml:space="preserve">
          <source>The default threshold to detect rank deficiency is a test on the magnitude of the singular values of &lt;code&gt;M&lt;/code&gt;. By default, we identify singular values less than &lt;code&gt;S.max() * max(M.shape) * eps&lt;/code&gt; as indicating rank deficiency (with the symbols defined above). This is the algorithm MATLAB uses [1]. It also appears in &lt;em&gt;Numerical recipes&lt;/em&gt; in the discussion of SVD solutions for linear least squares [2].</source>
          <target state="translated">Пороговое значение по умолчанию для обнаружения дефицита ранга тест на величине сингулярных значений &lt;code&gt;M&lt;/code&gt; . По умолчанию мы идентифицируем единичные значения меньше &lt;code&gt;S.max() * max(M.shape) * eps&lt;/code&gt; как указывающие на недостаток ранга (с символами, определенными выше). Это алгоритм, который использует MATLAB [1]. Он также появляется в &lt;em&gt;численных рецептах&lt;/em&gt; при обсуждении решений SVD для линейных наименьших квадратов [2].</target>
        </trans-unit>
        <trans-unit id="fabcee56c3086c9123fae22826809a0d986ec9e3" translate="yes" xml:space="preserve">
          <source>The default type to use when no dtype is explicitly specified, for example when calling np.zero(shape). This is equivalent to &lt;a href=&quot;#c.NPY_DOUBLE&quot;&gt;&lt;code&gt;NPY_DOUBLE&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Тип по умолчанию, который используется, когда явно не указан dtype, например, при вызове np.zero (shape). Это эквивалент &lt;a href=&quot;#c.NPY_DOUBLE&quot;&gt; &lt;code&gt;NPY_DOUBLE&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="a62d7fdf404d547735e1b655e9c601557613abc2" translate="yes" xml:space="preserve">
          <source>The default valid days are Monday through Friday (&amp;ldquo;business days&amp;rdquo;). A busdaycalendar object can be specified with any set of weekly valid days, plus an optional &amp;ldquo;holiday&amp;rdquo; dates that always will be invalid.</source>
          <target state="translated">Действительные дни по умолчанию - с понедельника по пятницу (&amp;laquo;рабочие дни&amp;raquo;). Объект busdaycalendar может быть указан с любым набором действительных дней недели, а также с необязательными датами &amp;laquo;праздников&amp;raquo;, которые всегда будут недопустимыми.</target>
        </trans-unit>
        <trans-unit id="203757e2bdf5bbe5e651d506c476783cf6e50edd" translate="yes" xml:space="preserve">
          <source>The default value (&amp;lsquo;S&amp;rsquo;) results in swapping the current byte order. The code does a case-insensitive check on the first letter of &lt;code&gt;new_order&lt;/code&gt; for the alternatives above. For example, any of &amp;lsquo;B&amp;rsquo; or &amp;lsquo;b&amp;rsquo; or &amp;lsquo;biggish&amp;rsquo; are valid to specify big-endian.</source>
          <target state="translated">Значение по умолчанию ('S') приводит к замене текущего порядка байтов. Код проверяет первую букву &lt;code&gt;new_order&lt;/code&gt; без учета регистра для указанных выше альтернатив. Например, любой из символов &amp;laquo;B&amp;raquo;, &amp;laquo;b&amp;raquo; или &amp;laquo;biggish&amp;raquo; может указывать на прямой порядок байтов.</target>
        </trans-unit>
        <trans-unit id="19a5ab6c7c39a905e845eb64d8df075515c15636" translate="yes" xml:space="preserve">
          <source>The defining property of the antiderivative:</source>
          <target state="translated">Определяющее свойство антидепрессанта:</target>
        </trans-unit>
        <trans-unit id="a1b5640a64fc73d8755c0223b335feaa121479d8" translate="yes" xml:space="preserve">
          <source>The definition of advanced indexing means that &lt;code&gt;x[(1,2,3),]&lt;/code&gt; is fundamentally different than &lt;code&gt;x[(1,2,3)]&lt;/code&gt;. The latter is equivalent to &lt;code&gt;x[1,2,3]&lt;/code&gt; which will trigger basic selection while the former will trigger advanced indexing. Be sure to understand why this occurs.</source>
          <target state="translated">Определение расширенного индексирования означает, что &lt;code&gt;x[(1,2,3),]&lt;/code&gt; фундаментально отличается от &lt;code&gt;x[(1,2,3)]&lt;/code&gt; . Последний эквивалентен &lt;code&gt;x[1,2,3]&lt;/code&gt; который запускает базовый выбор, а первый запускает расширенное индексирование. Обязательно поймите, почему это происходит.</target>
        </trans-unit>
        <trans-unit id="61496dee2f3816bd693a7ce0398282c8ea47a960" translate="yes" xml:space="preserve">
          <source>The definition of correlation above is not unique and sometimes correlation may be defined differently. Another common definition is:</source>
          <target state="translated">Вышеуказанное определение корреляции не является уникальным и иногда корреляция может быть определена по-разному.Другим распространенным определением является:</target>
        </trans-unit>
        <trans-unit id="e5f33fe407bab51cea8bacccfd88b8a5036810dc" translate="yes" xml:space="preserve">
          <source>The degree of the series.</source>
          <target state="translated">Степень сериала.</target>
        </trans-unit>
        <trans-unit id="155faa0de8c44a325761ca30fe7a5e7dbf74e6e4" translate="yes" xml:space="preserve">
          <source>The depends list contains paths to files or directories that the sources of the extension module depend on. If any path in the depends list is newer than the extension module, then the module will be rebuilt.</source>
          <target state="translated">Список зависимостей содержит пути к файлам или каталогам,от которых зависят исходники модуля расширения.Если любой путь в списке зависимостей новый,чем модуль расширения,то модуль будет перестроен.</target>
        </trans-unit>
        <trans-unit id="63644093036e4f3b360649808afd2f026edeffe7" translate="yes" xml:space="preserve">
          <source>The derivation of the t-distribution was first published in 1908 by William Gosset while working for the Guinness Brewery in Dublin. Due to proprietary issues, he had to publish under a pseudonym, and so he used the name Student.</source>
          <target state="translated">Производство t-распределения было впервые опубликовано в 1908 году Уильямом Госсе во время работы на пивоваренном заводе Гиннеса в Дублине.Из-за проприетарных проблем ему пришлось публиковаться под псевдонимом,поэтому он использовал имя &quot;Студент&quot;.</target>
        </trans-unit>
        <trans-unit id="7db2e5319fb072c88d575bc92b04bca324abdb47" translate="yes" xml:space="preserve">
          <source>The derivative of the polynomial</source>
          <target state="translated">производная полинома</target>
        </trans-unit>
        <trans-unit id="e38da7322eec5dfeb19db7a40e7e799054f3e9fa" translate="yes" xml:space="preserve">
          <source>The desc member of the PyCObject returned from __array_struct__ was not specified. Usually, it was the object exposing the array (so that a reference to it could be kept and destroyed when the C-object was destroyed). Now it must be a tuple whose first element is a string with &amp;ldquo;PyArrayInterface Version #&amp;rdquo; and whose second element is the object exposing the array.</source>
          <target state="translated">Член desc объекта PyCObject, возвращенного из __array_struct__, не указан. Обычно это был объект, раскрывающий массив (так что ссылка на него могла быть сохранена и уничтожена при уничтожении C-объекта). Теперь это должен быть кортеж, первым элементом которого является строка с &amp;laquo;PyArrayInterface Version #&amp;raquo;, а вторым элементом является объект, представляющий массив.</target>
        </trans-unit>
        <trans-unit id="d7dbcb2541cf001d7b26e25e4170575fd900c8ee" translate="yes" xml:space="preserve">
          <source>The description of the fourth element of the header therefore has become: &amp;ldquo;The next 4 bytes form a little-endian unsigned int: the length of the header data HEADER_LEN.&amp;rdquo;</source>
          <target state="translated">Таким образом, описание четвертого элемента заголовка выглядит следующим образом: &amp;laquo;Следующие 4 байта образуют целое число без знака с прямым порядком байтов: длину данных заголовка HEADER_LEN&amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="f4a52cabb32fca3b74ad0388e9c1cbe1cf8d25b1" translate="yes" xml:space="preserve">
          <source>The desired data-type for the array, e.g., &lt;code&gt;numpy.int8&lt;/code&gt;. Default is &lt;code&gt;numpy.float64&lt;/code&gt;.</source>
          <target state="translated">Желаемый тип данных для массива, например, &lt;code&gt;numpy.int8&lt;/code&gt; . По умолчанию - &lt;code&gt;numpy.float64&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f7534f7cefc524ae1e988328a3c98ad10f344592" translate="yes" xml:space="preserve">
          <source>The desired data-type for the array. If not given, then the type will be determined as the minimum type required to hold the objects in the sequence. This argument can only be used to &amp;lsquo;upcast&amp;rsquo; the array. For downcasting, use the .astype(t) method.</source>
          <target state="translated">Желаемый тип данных для массива. Если не указан, то тип будет определен как минимальный тип, необходимый для размещения объектов в последовательности. Этот аргумент можно использовать только для &amp;laquo;восходящего преобразования&amp;raquo; массива. Для понижения используйте метод .astype (t).</target>
        </trans-unit>
        <trans-unit id="50dd3f94578e7376ef4b1fc5b09b342ebb1fed2e" translate="yes" xml:space="preserve">
          <source>The desired data-type for the matrix, default is float.</source>
          <target state="translated">Желаемый тип данных для матрицы,по умолчанию-float.</target>
        </trans-unit>
        <trans-unit id="07d678da86d17478a0143d6947f08f3fa51a5f65" translate="yes" xml:space="preserve">
          <source>The desired data-type for the matrix, default is np.float64.</source>
          <target state="translated">Желаемый тип данных для матрицы,по умолчанию np.float64.</target>
        </trans-unit>
        <trans-unit id="d07509f4b4964e751a91c8805000083d2ee4926c" translate="yes" xml:space="preserve">
          <source>The desired data-type. By default, the data-type is determined from &lt;code&gt;formats&lt;/code&gt;, &lt;code&gt;names&lt;/code&gt;, &lt;code&gt;titles&lt;/code&gt;, &lt;code&gt;aligned&lt;/code&gt; and &lt;code&gt;byteorder&lt;/code&gt;.</source>
          <target state="translated">Желаемый тип данных. По умолчанию тип данных определяется по &lt;code&gt;formats&lt;/code&gt; , &lt;code&gt;names&lt;/code&gt; , &lt;code&gt;titles&lt;/code&gt; , &lt;code&gt;aligned&lt;/code&gt; и по &lt;code&gt;byteorder&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3c998f357ef80cf65beb1c4220aff1c69081dd53" translate="yes" xml:space="preserve">
          <source>The desired shape of the array. If &lt;code&gt;mode == 'r'&lt;/code&gt; and the number of remaining bytes after &lt;code&gt;offset&lt;/code&gt; is not a multiple of the byte-size of &lt;a href=&quot;numpy.dtype#numpy.dtype&quot;&gt;&lt;code&gt;dtype&lt;/code&gt;&lt;/a&gt;, you must specify &lt;a href=&quot;numpy.memmap.shape#numpy.memmap.shape&quot;&gt;&lt;code&gt;shape&lt;/code&gt;&lt;/a&gt;. By default, the returned array will be 1-D with the number of elements determined by file size and data-type.</source>
          <target state="translated">Желаемая форма массива. Если &lt;code&gt;mode == 'r'&lt;/code&gt; и количество оставшихся байтов после &lt;code&gt;offset&lt;/code&gt; не кратно размеру байта &lt;a href=&quot;numpy.dtype#numpy.dtype&quot;&gt; &lt;code&gt;dtype&lt;/code&gt; &lt;/a&gt; , вы должны указать &lt;a href=&quot;numpy.memmap.shape#numpy.memmap.shape&quot;&gt; &lt;code&gt;shape&lt;/code&gt; &lt;/a&gt; . По умолчанию возвращаемый массив будет 1-D с количеством элементов, определяемым размером файла и типом данных.</target>
        </trans-unit>
        <trans-unit id="cdd86af715375b55e1d483d875bf1753af5d922f" translate="yes" xml:space="preserve">
          <source>The desired shape of the iterator. This allows &lt;code&gt;allocate&lt;/code&gt; operands with a dimension mapped by op_axes not corresponding to a dimension of a different operand to get a value not equal to 1 for that dimension.</source>
          <target state="translated">Желаемая форма итератора. Это позволяет &lt;code&gt;allocate&lt;/code&gt; операнды с измерением, отображаемым op_axes, не соответствующим измерению другого операнда, чтобы получить значение, отличное от 1 для этого измерения.</target>
        </trans-unit>
        <trans-unit id="84971317bba10bc74f9aaf650dccf1acca028d13" translate="yes" xml:space="preserve">
          <source>The desired, expected object.</source>
          <target state="translated">Желаемый,ожидаемый объект.</target>
        </trans-unit>
        <trans-unit id="40c65673e654df212bffc77b7c4cf508b802ea94" translate="yes" xml:space="preserve">
          <source>The determinant is computed via LU factorization using the LAPACK routine &lt;code&gt;z/dgetrf&lt;/code&gt;.</source>
          <target state="translated">Детерминант вычисляется посредством факторизации LU с использованием подпрограммы LAPACK &lt;code&gt;z/dgetrf&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="94f9591a378d3f5d467509648f89e89bcee5af83" translate="yes" xml:space="preserve">
          <source>The determinant of a 2-D array &lt;code&gt;[[a, b], [c, d]]&lt;/code&gt; is &lt;code&gt;ad - bc&lt;/code&gt;:</source>
          <target state="translated">Определитель двумерного массива &lt;code&gt;[[a, b], [c, d]]&lt;/code&gt; равен &lt;code&gt;ad - bc&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="67af8ebad34e1dbafff04ba3dd64dccd7934523b" translate="yes" xml:space="preserve">
          <source>The determinant of a 2-D array [[a, b], [c, d]] is ad - bc:</source>
          <target state="translated">Детерминантом 2-D массива [[a,b],[c,d]]является ad-bc:</target>
        </trans-unit>
        <trans-unit id="e56bde2e38a2da31d0e2d0f24b802753579a52ca" translate="yes" xml:space="preserve">
          <source>The determinant of a square Vandermonde matrix is the product of the differences between the values of the input vector:</source>
          <target state="translated">Детерминант квадратной матрицы Вандермонда является произведением разностей между значениями входного вектора:</target>
        </trans-unit>
        <trans-unit id="34c13c034ad3086185d61530fb01b7940b4e4527" translate="yes" xml:space="preserve">
          <source>The dictionary contains three keys:</source>
          <target state="translated">Словарь содержит три клавиши:</target>
        </trans-unit>
        <trans-unit id="bd944e951e9799c3343f288ae6c347a06ac11e23" translate="yes" xml:space="preserve">
          <source>The dictionary is indexed by keys that are the names of the fields. Each entry in the dictionary is a tuple fully describing the field:</source>
          <target state="translated">Словарь индексируется по клавишам,которые являются названиями полей.Каждая запись в словаре является кортежом,полностью описывающим поле:</target>
        </trans-unit>
        <trans-unit id="162f606f6e0310c46fbb8198beb3cd00b92c6224" translate="yes" xml:space="preserve">
          <source>The difference of &lt;code&gt;x1&lt;/code&gt; and &lt;code&gt;x2&lt;/code&gt;, element-wise. This is a scalar if both &lt;code&gt;x1&lt;/code&gt; and &lt;code&gt;x2&lt;/code&gt; are scalars.</source>
          <target state="translated">Разница &lt;code&gt;x1&lt;/code&gt; и &lt;code&gt;x2&lt;/code&gt; поэлементно. Это скаляр, если и &lt;code&gt;x1&lt;/code&gt; , и &lt;code&gt;x2&lt;/code&gt; являются скалярами.</target>
        </trans-unit>
        <trans-unit id="07942ea7f660d79ad7e6e73de1169306977fb28a" translate="yes" xml:space="preserve">
          <source>The differences between consecutive elements of an array.</source>
          <target state="translated">Различия между последовательными элементами массива.</target>
        </trans-unit>
        <trans-unit id="f62761da3d9dc37e999ceb43677343bc26056903" translate="yes" xml:space="preserve">
          <source>The differences. Loosely, this is &lt;code&gt;ary.flat[1:] - ary.flat[:-1]&lt;/code&gt;.</source>
          <target state="translated">Различия. В &lt;code&gt;ary.flat[1:] - ary.flat[:-1]&lt;/code&gt; это ary.flat [1:] - ary.flat [: - 1] .</target>
        </trans-unit>
        <trans-unit id="e2f3cc77955898f687e1a89336e253a34038e978" translate="yes" xml:space="preserve">
          <source>The different types of interpolation can be visualized graphically:</source>
          <target state="translated">Различные типы интерполяции могут быть визуализированы графически:</target>
        </trans-unit>
        <trans-unit id="0f5b79f9447070c03232c2c0b7664e2645b9b9cd" translate="yes" xml:space="preserve">
          <source>The dimension over which bit-packing is done. &lt;code&gt;None&lt;/code&gt; implies packing the flattened array.</source>
          <target state="translated">Размер, по которому выполняется битовая упаковка. &lt;code&gt;None&lt;/code&gt; подразумевает упаковку уплощенного массива.</target>
        </trans-unit>
        <trans-unit id="dfa565d5af13bd83cac275f338d5f2b3b4b7544c" translate="yes" xml:space="preserve">
          <source>The dimension over which bit-unpacking is done. &lt;code&gt;None&lt;/code&gt; implies unpacking the flattened array.</source>
          <target state="translated">Размер, по которому выполняется распаковка битов. &lt;code&gt;None&lt;/code&gt; подразумевает распаковку сплющенного массива.</target>
        </trans-unit>
        <trans-unit id="db3013243a57c5e7a96cffb61f2f631ca09ac6ac" translate="yes" xml:space="preserve">
          <source>The dimensionality of each input/output of an elementary function is defined by its core dimensions (zero core dimensions correspond to a scalar input/output). The core dimensions are mapped to the last dimensions of the input/output arrays.</source>
          <target state="translated">Размерность каждого входа/выхода элементарной функции определяется ее размерами ядра (нулевые размеры ядра соответствуют скалярному входу/выходу).Размеры ядра привязываются к последним размерам массивов входов/выходов.</target>
        </trans-unit>
        <trans-unit id="bbd2ce0767215831bee7913f7b1f8113fac9632a" translate="yes" xml:space="preserve">
          <source>The dimensionality of the output is equal to the greatest of: * the dimensionality of all the inputs * the depth to which the input list is nested</source>
          <target state="translated">Размерность выхода равна наибольшей из них:*размерности всех входов*глубине,на которую вложен список входов.</target>
        </trans-unit>
        <trans-unit id="169b189aee12891e66fa6116bc6ee28490426b80" translate="yes" xml:space="preserve">
          <source>The dimensions beyond the core dimensions are called &amp;ldquo;loop&amp;rdquo; dimensions. In the above example, this corresponds to &lt;code&gt;(3, 5)&lt;/code&gt;.</source>
          <target state="translated">Размеры, выходящие за пределы основных размеров, называются &amp;laquo;петлевыми&amp;raquo;. В приведенном выше примере это соответствует &lt;code&gt;(3, 5)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f513b3b85fff0b6f84da786029bafd05ba0e618b" translate="yes" xml:space="preserve">
          <source>The dimensions of the iterator.</source>
          <target state="translated">Размеры итератора.</target>
        </trans-unit>
        <trans-unit id="5ecf20054a40c0975aa34c7a074c143c2ad5eb76" translate="yes" xml:space="preserve">
          <source>The dimensions of the returned array, must be non-negative. If no argument is given a single Python float is returned.</source>
          <target state="translated">Размеры возвращаемого массива должны быть неотрицательными.Если аргумент не указан,то возвращается один плавающий Python.</target>
        </trans-unit>
        <trans-unit id="1962b62fe3553b6c10eaad6d82d38bd0027b1eca" translate="yes" xml:space="preserve">
          <source>The direction where to look for the next representable value of &lt;code&gt;x1&lt;/code&gt;. If &lt;code&gt;x1.shape != x2.shape&lt;/code&gt;, they must be broadcastable to a common shape (which becomes the shape of the output).</source>
          <target state="translated">Направление, где искать следующее представимое значение &lt;code&gt;x1&lt;/code&gt; . Если &lt;code&gt;x1.shape != x2.shape&lt;/code&gt; , они должны транслироваться в общую форму (которая становится формой вывода).</target>
        </trans-unit>
        <trans-unit id="712dcab95da2336dfeef7d45bac02b258dccf977" translate="yes" xml:space="preserve">
          <source>The discount rate.</source>
          <target state="translated">Ставка дисконта.</target>
        </trans-unit>
        <trans-unit id="0706686baa5fd5b913d978e6a5e5bd325098b037" translate="yes" xml:space="preserve">
          <source>The discrete convolution operation is defined as</source>
          <target state="translated">Операция дискретной свертки определяется как</target>
        </trans-unit>
        <trans-unit id="12a1ae320e29367bfe14ad50414fe949007c38e7" translate="yes" xml:space="preserve">
          <source>The docstring for the function. If &lt;code&gt;None&lt;/code&gt;, the docstring will be the &lt;code&gt;pyfunc.__doc__&lt;/code&gt;.</source>
          <target state="translated">Строка документации для функции. Если &lt;code&gt;None&lt;/code&gt; , &lt;code&gt;pyfunc.__doc__&lt;/code&gt; документации будет pyfunc .__ doc__ .</target>
        </trans-unit>
        <trans-unit id="72a23a7f9d3c84d9ccb7d9d4e76905cf07195965" translate="yes" xml:space="preserve">
          <source>The docstring is taken from the input function to &lt;a href=&quot;#numpy.vectorize&quot;&gt;&lt;code&gt;vectorize&lt;/code&gt;&lt;/a&gt; unless it is specified:</source>
          <target state="translated">Строка документации берется из функции ввода для &lt;a href=&quot;#numpy.vectorize&quot;&gt; &lt;code&gt;vectorize&lt;/code&gt; &lt;/a&gt; если она не указана:</target>
        </trans-unit>
        <trans-unit id="82bd10e4e262158659ec5e27575297c3e33fb51b" translate="yes" xml:space="preserve">
          <source>The doctests are run as if they are in a fresh Python instance which has executed &lt;code&gt;import numpy as np&lt;/code&gt;. Tests that are part of a SciPy subpackage will have that subpackage already imported. E.g. for a test in &lt;code&gt;scipy/linalg/tests/&lt;/code&gt;, the namespace will be created such that &lt;code&gt;from scipy import linalg&lt;/code&gt; has already executed.</source>
          <target state="translated">Доктесты запускаются, как если бы они находились в новом экземпляре Python, который выполнил &lt;code&gt;import numpy as np&lt;/code&gt; . В тестах, которые являются частью подпакета SciPy, этот подпакет уже импортирован. Например, для теста в &lt;code&gt;scipy/linalg/tests/&lt;/code&gt; пространство имен будет создано таким образом, чтобы &lt;code&gt;from scipy import linalg&lt;/code&gt; уже был выполнен.</target>
        </trans-unit>
        <trans-unit id="4e34de0083248d68455464ce3b6cb6cff4a615e4" translate="yes" xml:space="preserve">
          <source>The doctests can be run by adding the &lt;code&gt;doctests&lt;/code&gt; argument to the &lt;code&gt;test()&lt;/code&gt; call; for example, to run all tests (including doctests) for numpy.lib:</source>
          <target state="translated">Доктесты можно запустить, добавив аргумент &lt;code&gt;doctests&lt;/code&gt; к вызову &lt;code&gt;test()&lt;/code&gt; ; например, чтобы запустить все тесты (включая doctests) для numpy.lib:</target>
        </trans-unit>
        <trans-unit id="914dd900bd888e0ac2a856c709956c6c77b685df" translate="yes" xml:space="preserve">
          <source>The doctests can be run by the user/developer by adding the &lt;code&gt;doctests&lt;/code&gt; argument to the &lt;code&gt;test()&lt;/code&gt; call. For example, to run all tests (including doctests) for &lt;code&gt;numpy.lib&lt;/code&gt;:</source>
          <target state="translated">Пользователь / разработчик может запустить &lt;code&gt;doctests&lt;/code&gt; , добавив аргумент doctests к вызову &lt;code&gt;test()&lt;/code&gt; . Например, чтобы запустить все тесты (включая doctests) для &lt;code&gt;numpy.lib&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="b01857d163ce7be746891e6a1ddb4df8d280228b" translate="yes" xml:space="preserve">
          <source>The domain of the converted series. If the value is None, the default domain of &lt;code&gt;kind&lt;/code&gt; is used.</source>
          <target state="translated">Домен преобразованного ряда. Если значение равно None, домен по умолчанию &lt;code&gt;kind&lt;/code&gt; используется.</target>
        </trans-unit>
        <trans-unit id="3910d27792e65700eaf0cb459a12293f622c5605" translate="yes" xml:space="preserve">
          <source>The drawn samples, of shape (size, alpha.ndim).</source>
          <target state="translated">Нарисованные образцы формы (размер,альфа.ndim).</target>
        </trans-unit>
        <trans-unit id="caba47af25cacb65ea654dc8b3910b7df6c6afc4" translate="yes" xml:space="preserve">
          <source>The drawn samples, of shape &lt;em&gt;size&lt;/em&gt;, if that was provided. If not, the shape is &lt;code&gt;(N,)&lt;/code&gt;.</source>
          <target state="translated">Оттянутые образцы фигурного &lt;em&gt;размера&lt;/em&gt; , если таковые были. Если нет, форма будет &lt;code&gt;(N,)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="40b0e929b6fe8b38b46b38ce838182fe7c7332dc" translate="yes" xml:space="preserve">
          <source>The drawn samples.</source>
          <target state="translated">Нарисованные образцы.</target>
        </trans-unit>
        <trans-unit id="aa44e17b8461776ae7df4f43d6abddd8f6a24f76" translate="yes" xml:space="preserve">
          <source>The dtype object, which must be a &lt;code&gt;datetime64&lt;/code&gt; or &lt;code&gt;timedelta64&lt;/code&gt; type.</source>
          <target state="translated">Объект dtype, который должен быть типом &lt;code&gt;datetime64&lt;/code&gt; или &lt;code&gt;timedelta64&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8fb6faafe66ffccb238a2fd43e44c5a7f5fbd5ca" translate="yes" xml:space="preserve">
          <source>The dtype of the masked array matches the dtype of &lt;code&gt;arr&lt;/code&gt;.</source>
          <target state="translated">Dtype замаскированного массива соответствует dtype &lt;code&gt;arr&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a55d71e165e1e48cb124a8472e43c4880e17aca7" translate="yes" xml:space="preserve">
          <source>The dtype to convert</source>
          <target state="translated">Тип для преобразования</target>
        </trans-unit>
        <trans-unit id="5ecd0c1cb739e638a2efc7fc65026ccc752fcf9a" translate="yes" xml:space="preserve">
          <source>The dtype to convert.</source>
          <target state="translated">Тип для преобразования.</target>
        </trans-unit>
        <trans-unit id="0624587fa2f7d6454c0f9d5829dab19d01e4bd1b" translate="yes" xml:space="preserve">
          <source>The easiest way to understand the situation may be to think in terms of the result shape. There are two parts to the indexing operation, the subspace defined by the basic indexing (excluding integers) and the subspace from the advanced indexing part. Two cases of index combination need to be distinguished:</source>
          <target state="translated">Самый простой способ понять ситуацию-это подумать о форме результата.Операция индексирования состоит из двух частей:подпространства,определяемого базовой индексацией (исключая целые числа)и подпространства из расширенной части индексирования.Необходимо различать два случая комбинации индексов:</target>
        </trans-unit>
        <trans-unit id="f92b730683a3cb47168faa379ee22ac3235eed0f" translate="yes" xml:space="preserve">
          <source>The easy way to do conversions between polynomial basis sets is to use the convert method of a class instance.</source>
          <target state="translated">Простой способ преобразования полиномиальных базисных множеств-это использование метода преобразования экземпляра класса.</target>
        </trans-unit>
        <trans-unit id="2fc5d8b78173f52a2c49af3f59f052a25e59fb4f" translate="yes" xml:space="preserve">
          <source>The edges to pass into &lt;a href=&quot;numpy.histogram#numpy.histogram&quot;&gt;&lt;code&gt;histogram&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">Края для перехода в &lt;a href=&quot;numpy.histogram#numpy.histogram&quot;&gt; &lt;code&gt;histogram&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="b6f1be0a37063a8a4026cc94c7cf86f62cf5bdd8" translate="yes" xml:space="preserve">
          <source>The effect of broadcasting.</source>
          <target state="translated">Эффект от вещания.</target>
        </trans-unit>
        <trans-unit id="a34abd23a6e4bdf2596a3b4673affad53721777d" translate="yes" xml:space="preserve">
          <source>The eigenvalues are computed using LAPACK routines &lt;code&gt;_syevd&lt;/code&gt;, &lt;code&gt;_heevd&lt;/code&gt;.</source>
          <target state="translated">Собственные значения вычисляются с использованием подпрограмм LAPACK &lt;code&gt;_syevd&lt;/code&gt; , &lt;code&gt;_heevd&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7701e5ef9799c4995d19bac48ad9fa82db4dc5c5" translate="yes" xml:space="preserve">
          <source>The eigenvalues in ascending order, each repeated according to its multiplicity.</source>
          <target state="translated">Собственные значения в порядке возрастания,каждое из которых повторяется в соответствии с их множественностью.</target>
        </trans-unit>
        <trans-unit id="af42e28434cbe95fe6890df4d996c2c99e9b2481" translate="yes" xml:space="preserve">
          <source>The eigenvalues of real symmetric or complex Hermitian matrices are always real. &lt;a href=&quot;#rc702e98a756a-1&quot; id=&quot;id1&quot;&gt;[1]&lt;/a&gt; The array &lt;code&gt;v&lt;/code&gt; of (column) eigenvectors is unitary and &lt;code&gt;a&lt;/code&gt;, &lt;code&gt;w&lt;/code&gt;, and &lt;code&gt;v&lt;/code&gt; satisfy the equations &lt;code&gt;dot(a, v[:, i]) = w[i] * v[:, i]&lt;/code&gt;.</source>
          <target state="translated">Собственные значения вещественных симметричных или комплексных эрмитовых матриц всегда действительны. &lt;a href=&quot;#rc702e98a756a-1&quot; id=&quot;id1&quot;&gt;[1]&lt;/a&gt; Массив &lt;code&gt;v&lt;/code&gt; собственных векторов (столбцов) является унитарным, а &lt;code&gt;a&lt;/code&gt; , &lt;code&gt;w&lt;/code&gt; и &lt;code&gt;v&lt;/code&gt; удовлетворяют уравнениям &lt;code&gt;dot(a, v[:, i]) = w[i] * v[:, i]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2ff4d23698273b360b1d6366e444e95ea540f28f" translate="yes" xml:space="preserve">
          <source>The eigenvalues, each repeated according to its multiplicity. The eigenvalues are not necessarily ordered. The resulting array will be of complex type, unless the imaginary part is zero in which case it will be cast to a real type. When &lt;code&gt;a&lt;/code&gt; is real the resulting eigenvalues will be real (0 imaginary part) or occur in conjugate pairs</source>
          <target state="translated">Собственные значения, каждое из которых повторяется согласно своей кратности. Собственные значения не обязательно упорядочены. Результирующий массив будет сложного типа, если только мнимая часть не равна нулю, и в этом случае он будет приведен к реальному типу. Когда &lt;code&gt;a&lt;/code&gt; является действительным, результирующие собственные значения будут действительными (0 мнимая часть) или возникать в сопряженных парах</target>
        </trans-unit>
        <trans-unit id="9cfc7ae7c9df4df4270a01f781a7985d0061b823" translate="yes" xml:space="preserve">
          <source>The eigenvalues, each repeated according to its multiplicity. They are not necessarily ordered, nor are they necessarily real for real matrices.</source>
          <target state="translated">Собственные значения,каждое из которых повторяется в соответствии с его многочисленностью.Они не обязательно упорядочены и не обязательно реальны для настоящих матриц.</target>
        </trans-unit>
        <trans-unit id="fedbdf07c41c58b01420971d15b808683a8a1612" translate="yes" xml:space="preserve">
          <source>The eigenvalues/eigenvectors are computed using LAPACK routines &lt;code&gt;_syevd&lt;/code&gt;, &lt;code&gt;_heevd&lt;/code&gt;.</source>
          <target state="translated">Собственные значения / собственные векторы вычисляются с использованием подпрограмм LAPACK &lt;code&gt;_syevd&lt;/code&gt; , &lt;code&gt;_heevd&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="672eac8f0267740479f9ff389b02d40f57b3ff35" translate="yes" xml:space="preserve">
          <source>The element inserted in &lt;code&gt;output&lt;/code&gt; when all conditions evaluate to False.</source>
          <target state="translated">Элемент, вставленный в &lt;code&gt;output&lt;/code&gt; когда все условия оцениваются как False.</target>
        </trans-unit>
        <trans-unit id="c154db2e01512028a28319b3317262699278c799" translate="yes" xml:space="preserve">
          <source>The element size of this data-type object.</source>
          <target state="translated">Размер элемента этого объекта типа данных.</target>
        </trans-unit>
        <trans-unit id="100849a009dc981ce005b4c12bbdd30342f43ac6" translate="yes" xml:space="preserve">
          <source>The element-wise remainder of the quotient &lt;code&gt;floor_divide(x1, x2)&lt;/code&gt;. This is a scalar if both &lt;code&gt;x1&lt;/code&gt; and &lt;code&gt;x2&lt;/code&gt; are scalars.</source>
          <target state="translated">&lt;code&gt;floor_divide(x1, x2)&lt;/code&gt; остаток от частного floor_divide (x1, x2) . Это скаляр, если и &lt;code&gt;x1&lt;/code&gt; , и &lt;code&gt;x2&lt;/code&gt; являются скалярами.</target>
        </trans-unit>
        <trans-unit id="55f57b3f397334c809b04b980612f0a5ab349a62" translate="yes" xml:space="preserve">
          <source>The elements are binary-valued (0 or 1).</source>
          <target state="translated">Элементы имеют двойную стоимость (0 или 1).</target>
        </trans-unit>
        <trans-unit id="18d658a71c2e23e5ce04fb215c6cdc657f3c41d2" translate="yes" xml:space="preserve">
          <source>The elements of &lt;code&gt;a&lt;/code&gt; are read using this index order. &amp;lsquo;C&amp;rsquo; means to index the elements in C-like order, with the last axis index changing fastest, back to the first axis index changing slowest. &amp;lsquo;F&amp;rsquo; means to index the elements in Fortran-like index order, with the first index changing fastest, and the last index changing slowest. Note that the &amp;lsquo;C&amp;rsquo; and &amp;lsquo;F&amp;rsquo; options take no account of the memory layout of the underlying array, and only refer to the order of axis indexing. &amp;lsquo;A&amp;rsquo; means to read the elements in Fortran-like index order if &lt;code&gt;m&lt;/code&gt; is Fortran &lt;em&gt;contiguous&lt;/em&gt; in memory, C-like order otherwise. &amp;lsquo;K&amp;rsquo; means to read the elements in the order they occur in memory, except for reversing the data when strides are negative. By default, &amp;lsquo;C&amp;rsquo; index order is used.</source>
          <target state="translated">Элементы &lt;code&gt;a&lt;/code&gt; читаются с использованием этого порядка индексации. &amp;laquo;C&amp;raquo; означает индексирование элементов в C-подобном порядке, причем индекс последней оси изменяется быстрее всего, а индекс первой оси изменяется медленнее всего. &amp;laquo;F&amp;raquo; означает индексирование элементов в порядке индексации, подобном Фортрану, при этом первый индекс изменяется быстрее всего, а последний индекс изменяется медленнее всего. Обратите внимание, что параметры &amp;laquo;C&amp;raquo; и &amp;laquo;F&amp;raquo; не учитывают структуру памяти базового массива и относятся только к порядку индексации оси. 'A' означает чтение элементов в порядке индекса, подобном Fortran, если &lt;code&gt;m&lt;/code&gt; является &lt;em&gt;непрерывным&lt;/em&gt; в памяти Fortran, в противном случае - порядком, подобным C. &amp;laquo;K&amp;raquo; означает чтение элементов в том порядке, в котором они встречаются в памяти, за исключением реверсирования данных при отрицательных шагах. По умолчанию используется порядковый номер индекса &amp;laquo;C&amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="27ccf6e9acce055e532ad81d9bdd8638f9a4a262" translate="yes" xml:space="preserve">
          <source>The elements of &lt;code&gt;a&lt;/code&gt; are read using this index order. &amp;lsquo;C&amp;rsquo; means to index the elements in row-major, C-style order, with the last axis index changing fastest, back to the first axis index changing slowest. &amp;lsquo;F&amp;rsquo; means to index the elements in column-major, Fortran-style order, with the first index changing fastest, and the last index changing slowest. Note that the &amp;lsquo;C&amp;rsquo; and &amp;lsquo;F&amp;rsquo; options take no account of the memory layout of the underlying array, and only refer to the order of axis indexing. &amp;lsquo;A&amp;rsquo; means to read the elements in Fortran-like index order if &lt;code&gt;a&lt;/code&gt; is Fortran &lt;em&gt;contiguous&lt;/em&gt; in memory, C-like order otherwise. &amp;lsquo;K&amp;rsquo; means to read the elements in the order they occur in memory, except for reversing the data when strides are negative. By default, &amp;lsquo;C&amp;rsquo; index order is used.</source>
          <target state="translated">Элементы &lt;code&gt;a&lt;/code&gt; читаются с использованием этого порядка индексации. &amp;laquo;C&amp;raquo; означает индексирование элементов в строчном порядке в стиле C, причем индекс последней оси изменяется быстрее всего, а обратно к индексу первой оси изменяется медленнее всего. &amp;laquo;F&amp;raquo; означает индексирование элементов в порядке столбца в стиле Фортрана, причем первый индекс изменяется быстрее всего, а последний индекс изменяется медленнее всего. Обратите внимание, что параметры &amp;laquo;C&amp;raquo; и &amp;laquo;F&amp;raquo; не учитывают структуру памяти базового массива и относятся только к порядку индексации оси. 'A' означает чтение элементов в порядке индекса, подобном Fortran, если &lt;code&gt;a&lt;/code&gt; является &lt;em&gt;непрерывным&lt;/em&gt; Fortran&lt;em&gt;&lt;/em&gt;в памяти, иначе C-подобный порядок. &amp;laquo;K&amp;raquo; означает чтение элементов в том порядке, в котором они встречаются в памяти, за исключением реверсирования данных, когда шаги отрицательны. По умолчанию используется порядковый номер индекса &amp;laquo;C&amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="8bfe90d8bb9b3a44603b03bac0e42210874e7808" translate="yes" xml:space="preserve">
          <source>The elements of &lt;code&gt;m&lt;/code&gt; are read using this index order. &amp;lsquo;C&amp;rsquo; means to index the elements in C-like order, with the last axis index changing fastest, back to the first axis index changing slowest. &amp;lsquo;F&amp;rsquo; means to index the elements in Fortran-like index order, with the first index changing fastest, and the last index changing slowest. Note that the &amp;lsquo;C&amp;rsquo; and &amp;lsquo;F&amp;rsquo; options take no account of the memory layout of the underlying array, and only refer to the order of axis indexing. &amp;lsquo;A&amp;rsquo; means to read the elements in Fortran-like index order if &lt;code&gt;m&lt;/code&gt; is Fortran &lt;em&gt;contiguous&lt;/em&gt; in memory, C-like order otherwise. &amp;lsquo;K&amp;rsquo; means to read the elements in the order they occur in memory, except for reversing the data when strides are negative. By default, &amp;lsquo;C&amp;rsquo; index order is used.</source>
          <target state="translated">Элементы &lt;code&gt;m&lt;/code&gt; считываются с использованием этого порядка индекса. &amp;laquo;C&amp;raquo; означает индексирование элементов в C-подобном порядке, причем индекс последней оси изменяется быстрее всего, а индекс первой оси изменяется медленнее всего. &amp;laquo;F&amp;raquo; означает индексирование элементов в порядке индексации, подобном Фортрану, при этом первый индекс изменяется быстрее всего, а последний индекс изменяется медленнее всего. Обратите внимание, что параметры &amp;laquo;C&amp;raquo; и &amp;laquo;F&amp;raquo; не учитывают структуру памяти базового массива и относятся только к порядку индексации оси. 'A' означает чтение элементов в порядке индекса, подобном Fortran, если &lt;code&gt;m&lt;/code&gt; является &lt;em&gt;непрерывным&lt;/em&gt; в памяти Fortran, в противном случае - порядком, подобным C. &amp;laquo;K&amp;raquo; означает чтение элементов в том порядке, в котором они встречаются в памяти, за исключением реверсирования данных при отрицательных шагах. По умолчанию используется порядковый номер индекса &amp;laquo;C&amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="d8d7a05ea4e76ed025da3efb7e37c3722ae9fddb" translate="yes" xml:space="preserve">
          <source>The elements of both &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;a.T&lt;/code&gt; get traversed in the same order, namely the order they are stored in memory, whereas the elements of &lt;code&gt;a.T.copy(order=&amp;rsquo;C&amp;rsquo;)&lt;/code&gt; get visited in a different order because they have been put into a different memory layout.</source>
          <target state="translated">Элементы как &lt;code&gt;a&lt;/code&gt; ,так и &lt;code&gt;a.T&lt;/code&gt; проходят в одном и том же порядке, а именно порядке, в котором они хранятся в памяти, тогда как элементы &lt;code&gt;a.T.copy(order=&amp;rsquo;C&amp;rsquo;)&lt;/code&gt; посещаются в другом порядке, потому что они были помещены в другую память. макет.</target>
        </trans-unit>
        <trans-unit id="7c09282fb5ba8925fe26507ed54970dbeacf3bc3" translate="yes" xml:space="preserve">
          <source>The elements of the shape tuple give the lengths of the corresponding array dimensions.</source>
          <target state="translated">Элементы фигурного кортежа дают длины соответствующих размеров массива.</target>
        </trans-unit>
        <trans-unit id="d08dc6baf6d1de4ff7af87aa1f35d18925c1f47b" translate="yes" xml:space="preserve">
          <source>The elements of this structure are:</source>
          <target state="translated">Элементы этой структуры:</target>
        </trans-unit>
        <trans-unit id="d0777cee700edf703f03cd8f123c44ac46b607f9" translate="yes" xml:space="preserve">
          <source>The end value of the sequence, unless &lt;code&gt;endpoint&lt;/code&gt; is set to False. In that case, the sequence consists of all but the last of &lt;code&gt;num + 1&lt;/code&gt; evenly spaced samples, so that &lt;code&gt;stop&lt;/code&gt; is excluded. Note that the step size changes when &lt;code&gt;endpoint&lt;/code&gt; is False.</source>
          <target state="translated">Конечное значение последовательности, если для &lt;code&gt;endpoint&lt;/code&gt; не задано значение False. В этом случае последовательность состоит из всех, кроме последнего из &lt;code&gt;num + 1&lt;/code&gt; равномерно распределенных отсчетов, так что &lt;code&gt;stop&lt;/code&gt; исключена. Обратите внимание, что размер шага изменяется, когда &lt;code&gt;endpoint&lt;/code&gt; имеет значение False.</target>
        </trans-unit>
        <trans-unit id="61c8a67ac747d5eb7d80852565d6317e805901a1" translate="yes" xml:space="preserve">
          <source>The endpoint of the interval can optionally be excluded.</source>
          <target state="translated">Конечная точка интервала может быть опционально исключена.</target>
        </trans-unit>
        <trans-unit id="7c70e4957abd94f2cb0f87772d68554c90cbe5b2" translate="yes" xml:space="preserve">
          <source>The entropy for creating a &lt;a href=&quot;#numpy.random.SeedSequence&quot;&gt;&lt;code&gt;SeedSequence&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Энтропия для создания &lt;a href=&quot;#numpy.random.SeedSequence&quot;&gt; &lt;code&gt;SeedSequence&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="0807164c2e58b526f47d2a17d970242e2786a8ed" translate="yes" xml:space="preserve">
          <source>The enumeration value for ASCII strings of a selectable size. The strings have a fixed maximum size within a given array.</source>
          <target state="translated">Значение перечисления для ASCII-строк выбираемого размера.Строки имеют фиксированный максимальный размер внутри заданного массива.</target>
        </trans-unit>
        <trans-unit id="4486c486e9b2ccc0519632048cae0af33e6f2bea" translate="yes" xml:space="preserve">
          <source>The enumeration value for UCS4 strings of a selectable size. The strings have a fixed maximum size within a given array.</source>
          <target state="translated">Перечисленное значение для строк UCS4 выбираемого размера.Строки имеют фиксированный максимальный размер внутри заданного массива.</target>
        </trans-unit>
        <trans-unit id="ceb80d4c945347bb465d428088d951fae89cf7e9" translate="yes" xml:space="preserve">
          <source>The enumeration value for a 128-bit/16-byte complex type made up of two NPY_DOUBLE values.</source>
          <target state="translated">Перечисленное значение для 128-битного/16-байтового комплексного типа состоит из двух значений NPY_DOUBLE.</target>
        </trans-unit>
        <trans-unit id="022dd3242a4f7ab9f354ab53434df9783dde262d" translate="yes" xml:space="preserve">
          <source>The enumeration value for a 16-bit/2-byte IEEE 754-2008 compatible floating point type.</source>
          <target state="translated">Перечисленное значение для 16-битного/2-байтового типа с плавающей запятой,совместимого со стандартом IEEE 754-2008.</target>
        </trans-unit>
        <trans-unit id="54200391c747968ffe444d868d0f00fe22c905a7" translate="yes" xml:space="preserve">
          <source>The enumeration value for a 16-bit/2-byte signed integer.</source>
          <target state="translated">Перечисленное значение для 16-битного/2-байтового подписанного целого.</target>
        </trans-unit>
        <trans-unit id="24e698054b91536d27ff27c354d21704b0ff5fa7" translate="yes" xml:space="preserve">
          <source>The enumeration value for a 16-bit/2-byte unsigned integer.</source>
          <target state="translated">Перечисленное значение для 16-битного/2-байтового беззнакового целого.</target>
        </trans-unit>
        <trans-unit id="48c93b25a09888099a2fa0e8cc423bbdd97aec51" translate="yes" xml:space="preserve">
          <source>The enumeration value for a 32-bit/4-byte IEEE 754 compatible floating point type.</source>
          <target state="translated">Перечисленное значение для 32-битного/4-байтового типа с плавающей запятой,совместимого со стандартом IEEE 754.</target>
        </trans-unit>
        <trans-unit id="0767688f1013b974d66b67bec323cce162186c28" translate="yes" xml:space="preserve">
          <source>The enumeration value for a 32-bit/4-byte signed integer.</source>
          <target state="translated">Перечисленное значение для 32-битного/4-байтового подписанного целого.</target>
        </trans-unit>
        <trans-unit id="61e002f4aaa6d35ff73356572d5e52edd07749bc" translate="yes" xml:space="preserve">
          <source>The enumeration value for a 32-bit/4-byte unsigned integer.</source>
          <target state="translated">Перечисленное значение для 32-битного/4-байтового беззнакового целого.</target>
        </trans-unit>
        <trans-unit id="13bb2de2cc37c2d6613c3c408dc1f6c1a04bcaf7" translate="yes" xml:space="preserve">
          <source>The enumeration value for a 64-bit/8-byte IEEE 754 compatible floating point type.</source>
          <target state="translated">Перечисленное значение для 64-битного/8-байтового типа с плавающей запятой,совместимого со стандартом IEEE 754.</target>
        </trans-unit>
        <trans-unit id="712e85738302795b01166defaa51ce15d788398b" translate="yes" xml:space="preserve">
          <source>The enumeration value for a 64-bit/8-byte complex type made up of two NPY_FLOAT values.</source>
          <target state="translated">Перечисленное значение для 64-битного/8-байтового комплексного типа состоит из двух значений NPY_FLOAT.</target>
        </trans-unit>
        <trans-unit id="6fcce91d25d23bb25fdb72e7335d026c8e38fbfa" translate="yes" xml:space="preserve">
          <source>The enumeration value for a 64-bit/8-byte signed integer.</source>
          <target state="translated">Перечисленное значение для 64-битного/8-байтового подписанного целого.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
