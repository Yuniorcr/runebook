<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ru" datatype="htmlbody" original="numpy">
    <body>
      <group id="numpy">
        <trans-unit id="5f26098ec8a9cbafe4e4d839766540a822d41056" translate="yes" xml:space="preserve">
          <source>If the last dimension of &lt;code&gt;a&lt;/code&gt; is not the same size as the second-to-last dimension of &lt;code&gt;b&lt;/code&gt;.</source>
          <target state="translated">Если последнее измерение &lt;code&gt;a&lt;/code&gt; не того же размера, что и предпоследнее измерение &lt;code&gt;b&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2fd0d252831ab8d15d091d4ef1abf6e28cded875" translate="yes" xml:space="preserve">
          <source>If the masked array has named fields, accessing a single entry returns a &lt;code&gt;numpy.void&lt;/code&gt; object if none of the fields are masked, or a 0d masked array with the same dtype as the initial array if at least one of the fields is masked.</source>
          <target state="translated">Если замаскированный массив имеет именованные поля, доступ к одной записи возвращает объект &lt;code&gt;numpy.void&lt;/code&gt; , если ни одно из полей не замаскировано, или замаскированный массив 0d с тем же dtype, что и исходный массив, если хотя бы одно из полей замаскировано.</target>
        </trans-unit>
        <trans-unit id="8ec6f09c123aa3a76dc4dc9103d999ab337134eb" translate="yes" xml:space="preserve">
          <source>If the mode is constant filling (&lt;code&gt;NPY_NEIGHBORHOOD_ITER_CONSTANT_PADDING&lt;/code&gt;), fill_value should point to an array object which holds the filling value (the first item will be the filling value if the array contains more than one item). For other cases, fill_value may be NULL.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="510c4eb8a3d20ab4214058c75f9744c994e75f43" translate="yes" xml:space="preserve">
          <source>If the mode is constant filling (NPY_NEIGHBORHOOD_ITER_CONSTANT_PADDING), fill_value should point to an array object which holds the filling value (the first item will be the filling value if the array contains more than one item). For other cases, fill_value may be NULL.</source>
          <target state="translated">Если режим является константным заполнением (NPY_NEIGHBORHOOD_ITER_CONSTANT_PADDING),значение fill_value должно указывать на объект массива,который содержит значение заливки (первым элементом будет значение заливки,если массив содержит более одного элемента).В остальных случаях значение fill_value может быть NULL.</target>
        </trans-unit>
        <trans-unit id="be7395567c47ed030147671e19ef0b8f24978bfe" translate="yes" xml:space="preserve">
          <source>If the name is suffixed with the &amp;ldquo;?&amp;rdquo; modifier, the dimension is a core dimension only if it exists on all inputs and outputs that share it; otherwise it is ignored (and replaced by a dimension of size 1 for the elementary function).</source>
          <target state="translated">Если к имени добавлен суффикс &amp;laquo;?&amp;raquo; модификатор, измерение является основным измерением, только если оно существует на всех входах и выходах, которые его разделяют; в противном случае он игнорируется (и заменяется размером 1 для элементарной функции).</target>
        </trans-unit>
        <trans-unit id="c3d1c518bb585ba44b9ba4aaf335820db98fa4f5" translate="yes" xml:space="preserve">
          <source>If the new array is larger than the original array, then the new array is filled with repeated copies of &lt;code&gt;a&lt;/code&gt;. Note that this behavior is different from a.resize(new_shape) which fills with zeros instead of repeated copies of &lt;code&gt;a&lt;/code&gt;.</source>
          <target state="translated">Если новый массив больше , чем исходный массив, то новый массив заполняется с повторяющимися копиями . Обратите внимание, что это поведение отличается от a.resize (new_shape), который заполняется нулями вместо повторяющихся копий &lt;code&gt;a&lt;/code&gt; . &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="b5041b424abd93910d43bf1d34adce8cb0f61f85" translate="yes" xml:space="preserve">
          <source>If the number of objects in the selection tuple is less than &lt;em&gt;N&lt;/em&gt; , then &lt;code&gt;:&lt;/code&gt; is assumed for any subsequent dimensions.</source>
          <target state="translated">Если количество объектов в выбранном кортеже меньше &lt;em&gt;N&lt;/em&gt; , то &lt;code&gt;:&lt;/code&gt; предполагается для любых последующих измерений.</target>
        </trans-unit>
        <trans-unit id="4f2a8e76e80cc97243c0461015d68ab374ad3374" translate="yes" xml:space="preserve">
          <source>If the number of objects in the selection tuple is less than &lt;em&gt;N&lt;/em&gt;, then &lt;code&gt;:&lt;/code&gt; is assumed for any subsequent dimensions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2928aac7d9000dc7b0628e4b095667d7efc04498" translate="yes" xml:space="preserve">
          <source>If the object in question is compiled in a language other than Python, using &lt;code&gt;??&lt;/code&gt; will return the same information as &lt;code&gt;?&lt;/code&gt;. You&amp;rsquo;ll find this with a lot of built-in objects and types, for example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c5a6c4456ec6f4292b9cf18dc4d579bb22a84db3" translate="yes" xml:space="preserve">
          <source>If the object provided is an array, this function traverses the chain of &lt;code&gt;base&lt;/code&gt; pointers so that each array points to the owner of the memory directly. Once the base is set, it may not be changed to another value.</source>
          <target state="translated">Если предоставленный объект является массивом, эта функция просматривает цепочку &lt;code&gt;base&lt;/code&gt; указателей, так что каждый массив указывает непосредственно на владельца памяти. После установки базы ее нельзя изменить на другое значение.</target>
        </trans-unit>
        <trans-unit id="89a89c71a1b9f2da8de85eabab619e5820532ff8" translate="yes" xml:space="preserve">
          <source>If the offsets of the fields and itemsize of a structured array satisfy the alignment conditions, the array will have the &lt;code&gt;ALIGNED&lt;/code&gt;&lt;a href=&quot;../reference/generated/numpy.ndarray.flags#numpy.ndarray.flags&quot;&gt;&lt;code&gt;flag&lt;/code&gt;&lt;/a&gt; set.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="657e1806ea99b60e1959c9ce313bdaa2fd70aa64" translate="yes" xml:space="preserve">
          <source>If the operand is flagged as write-only and a copy is needed, an uninitialized temporary array will be created and then copied to back to &lt;code&gt;op[i]&lt;/code&gt; on calling &lt;code&gt;NpyIter_Deallocate&lt;/code&gt;, instead of doing the unnecessary copy operation.</source>
          <target state="translated">Если операнд помечен как доступный только для записи и требуется копия, будет создан неинициализированный временный массив, который затем скопируется обратно в &lt;code&gt;op[i]&lt;/code&gt; при вызове &lt;code&gt;NpyIter_Deallocate&lt;/code&gt; вместо выполнения ненужной операции копирования.</target>
        </trans-unit>
        <trans-unit id="17f4400245338f1e4a33ed23afc91ef7ab8c40c6" translate="yes" xml:space="preserve">
          <source>If the optional argument &lt;a href=&quot;numpy.char.count#numpy.char.count&quot;&gt;&lt;code&gt;count&lt;/code&gt;&lt;/a&gt; is given, only the first &lt;a href=&quot;numpy.char.count#numpy.char.count&quot;&gt;&lt;code&gt;count&lt;/code&gt;&lt;/a&gt; occurrences are replaced.</source>
          <target state="translated">Если указан необязательный аргумент &lt;a href=&quot;numpy.char.count#numpy.char.count&quot;&gt; &lt;code&gt;count&lt;/code&gt; &lt;/a&gt; , заменяются только первые вхождения &lt;a href=&quot;numpy.char.count#numpy.char.count&quot;&gt; &lt;code&gt;count&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="650baf4400147a0e58c70982764ea43290cfecc2" translate="yes" xml:space="preserve">
          <source>If the package is not found.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2ad175da47137fbc79b21402b2a0b69af4d4bc0f" translate="yes" xml:space="preserve">
          <source>If the position of iter is changed, any subsequent call to PyArrayNeighborhoodIter_Next is undefined behavior, and PyArrayNeighborhoodIter_Reset must be called.</source>
          <target state="translated">Если позиция итера изменена,то любой последующий вызов PyArrayNeighborhoodIter_Next является неопределенным поведением,и PyArrayNeighborhoodIter_Reset должен быть вызван.</target>
        </trans-unit>
        <trans-unit id="16e630a04286a25caaca20cb641690b37ba91ed8" translate="yes" xml:space="preserve">
          <source>If the release series is a new one, you will need to add a new section to the &lt;code&gt;doc/build/merge/index.html&lt;/code&gt; front page just after the &amp;ldquo;insert here&amp;rdquo; comment:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8c927b8ff30da3cc5f4b149881b61cbe3118f463" translate="yes" xml:space="preserve">
          <source>If the requested data type is in non-native byte order, the NBO flag overrides it and the requested data type is converted to be in native byte order.</source>
          <target state="translated">Если запрашиваемый тип данных находится в неродном порядке байт,флаг NBO переопределяет его,и запрашиваемый тип данных преобразуется в родной порядок байт.</target>
        </trans-unit>
        <trans-unit id="8a5c6764b6f67871837f5bb9b64736c18fe7a7ad" translate="yes" xml:space="preserve">
          <source>If the returned coefficients are &lt;code&gt;c&lt;/code&gt;, then</source>
          <target state="translated">Если возвращенные коэффициенты равны &lt;code&gt;c&lt;/code&gt; , то</target>
        </trans-unit>
        <trans-unit id="054023bbbbd71a4d456dd16da82bfb709a02f2cc" translate="yes" xml:space="preserve">
          <source>If the second argument is 1-D, it is promoted to a matrix by appending a 1 to its dimensions. After matrix multiplication the appended 1 is removed.</source>
          <target state="translated">Если второй аргумент равен 1-D,то он продвигается к матрице путем добавления 1 к ее размерам.После умножения матрицы добавляемая 1 удаляется.</target>
        </trans-unit>
        <trans-unit id="b4b38312a537fa220f815af5dcf5f4139bad3681" translate="yes" xml:space="preserve">
          <source>If the selection tuple has all entries &lt;code&gt;:&lt;/code&gt; except the &lt;em&gt;p&lt;/em&gt;-th entry which is a slice object &lt;code&gt;i:j:k&lt;/code&gt;, then the returned array has dimension &lt;em&gt;N&lt;/em&gt; formed by concatenating the sub-arrays returned by integer indexing of elements &lt;em&gt;i&lt;/em&gt;, &lt;em&gt;i+k&lt;/em&gt;, &amp;hellip;, &lt;em&gt;i + (m - 1) k &amp;lt; j&lt;/em&gt;,</source>
          <target state="translated">Если в кортеже выбора есть все записи &lt;code&gt;:&lt;/code&gt; кроме &lt;em&gt;p&lt;/em&gt; -й записи, которая является объектом среза &lt;code&gt;i:j:k&lt;/code&gt; , то возвращаемый массив имеет размерность &lt;em&gt;N,&lt;/em&gt; сформированную путем объединения подмассивов, возвращаемых целочисленной индексацией элементов &lt;em&gt;i&lt;/em&gt; , &lt;em&gt;i + k&lt;/em&gt; ,&amp;hellip;, &lt;em&gt;I + (m - 1) k &amp;lt;j&lt;/em&gt; ,</target>
        </trans-unit>
        <trans-unit id="9a652cfa7a533eb64735eb374de6f3a4977f5b9c" translate="yes" xml:space="preserve">
          <source>If the spacing between &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; for one or more elements is larger than &lt;code&gt;nulp&lt;/code&gt;.</source>
          <target state="translated">Если интервал между &lt;code&gt;x&lt;/code&gt; и &lt;code&gt;y&lt;/code&gt; для одного или нескольких элементов больше, чем &lt;code&gt;nulp&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3600ee510b36714644dcc89a19bb177b5b6c4ba7" translate="yes" xml:space="preserve">
          <source>If the string is not the correct size to satisfy the requested &lt;a href=&quot;numpy.dtype#numpy.dtype&quot;&gt;&lt;code&gt;dtype&lt;/code&gt;&lt;/a&gt; and &lt;code&gt;count&lt;/code&gt;.</source>
          <target state="translated">Если размер строки не соответствует требуемому &lt;a href=&quot;numpy.dtype#numpy.dtype&quot;&gt; &lt;code&gt;dtype&lt;/code&gt; &lt;/a&gt; и &lt;code&gt;count&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8431a3b44693b10770bc98218be6d44b926dbd16" translate="yes" xml:space="preserve">
          <source>If the transition to C++ goes through it is possible that this form will be relaxed so that short class methods meant to be inlined can have the return type on the same line as the function name. However, that is yet to be determined.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ebc3886c14d49cd40506d4084002663f28dbcdd3" translate="yes" xml:space="preserve">
          <source>If the type of &lt;code&gt;x&lt;/code&gt; is unsigned, then the output type is the unsigned platform integer:</source>
          <target state="translated">Если тип &lt;code&gt;x&lt;/code&gt; беззнаковый, то тип вывода - беззнаковое платформенное целое:</target>
        </trans-unit>
        <trans-unit id="183bc4d9ba8fd4894a95c0f09db6946e16642c92" translate="yes" xml:space="preserve">
          <source>If the type of the input is complex.</source>
          <target state="translated">Если тип входа сложный.</target>
        </trans-unit>
        <trans-unit id="95366e62fbbbe64ba41cdcaa0c22be8d3f384cd4" translate="yes" xml:space="preserve">
          <source>If the type of the input is float or complex.</source>
          <target state="translated">Если тип входа плавающий или сложный.</target>
        </trans-unit>
        <trans-unit id="25291949b6396c31462d4c34b8e8b5c2797cb90a" translate="yes" xml:space="preserve">
          <source>If the ufunc has 2 inputs and 1 output and the second input is an Object array then a special-case check is performed so that NotImplemented is returned if the second input is not an ndarray, has the __array_priority__ attribute, and has an __r{op}__ special method. In this way, Python is signaled to give the other object a chance to complete the operation instead of using generic object-array calculations. This allows (for example) sparse matrices to override the multiplication operator 1-D loop.</source>
          <target state="translated">Если ufunc имеет 2 входа и 1 выход,а второй вход является массивом Object,то выполняется специальная проверка,чтобы NotImplemented возвращался,если второй вход не является ndarray,имеет атрибут __array_priority__,и имеет специальный метод __r{op}__.Таким образом,Python получает сигнал для того,чтобы дать другому объекту возможность завершить операцию вместо использования общих вычислений объект-массив.Это позволяет (например)разреженным матрицам переопределить цикл 1-D оператора умножения.</target>
        </trans-unit>
        <trans-unit id="a4dffd94a98e9a9ee0037afd472e661e6232061e" translate="yes" xml:space="preserve">
          <source>If the underlying data is a subclass of &lt;a href=&quot;generated/numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;numpy.ndarray&lt;/code&gt;&lt;/a&gt;, it is returned as such.</source>
          <target state="translated">Если базовые данные являются подклассом &lt;a href=&quot;generated/numpy.ndarray#numpy.ndarray&quot;&gt; &lt;code&gt;numpy.ndarray&lt;/code&gt; &lt;/a&gt; , они возвращаются как таковые.</target>
        </trans-unit>
        <trans-unit id="c8138c9410f7b3ce9c5c6bb9d0523e6e1ea7bd8e" translate="yes" xml:space="preserve">
          <source>If the underlying data is a subclass of &lt;a href=&quot;numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;numpy.ndarray&lt;/code&gt;&lt;/a&gt;, it is returned as such.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="10f03c3143f8af1fee84b593563d21e127566799" translate="yes" xml:space="preserve">
          <source>If the user tries to use any numpy functions not included in &lt;code&gt;HANDLED_FUNCTIONS&lt;/code&gt;, a &lt;code&gt;TypeError&lt;/code&gt; will be raised by numpy, indicating that this operation is not supported. For example, concatenating two &lt;code&gt;DiagonalArrays&lt;/code&gt; does not produce another diagonal array, so it is not supported.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="23122d3c8d35684d3c1d392886f730d15f172384" translate="yes" xml:space="preserve">
          <source>If the value is anything but the default, then &lt;code&gt;keepdims&lt;/code&gt; will be passed through to the &lt;a href=&quot;https://docs.python.org/dev/library/functions.html#max&quot;&gt;&lt;code&gt;max&lt;/code&gt;&lt;/a&gt; method of sub-classes of &lt;a href=&quot;numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;ndarray&lt;/code&gt;&lt;/a&gt;. If the sub-classes methods does not implement &lt;code&gt;keepdims&lt;/code&gt; any exceptions will be raised.</source>
          <target state="translated">Если значение отличается от значения по умолчанию, то &lt;code&gt;keepdims&lt;/code&gt; будет передан методу &lt;a href=&quot;https://docs.python.org/dev/library/functions.html#max&quot;&gt; &lt;code&gt;max&lt;/code&gt; &lt;/a&gt; подклассов &lt;a href=&quot;numpy.ndarray#numpy.ndarray&quot;&gt; &lt;code&gt;ndarray&lt;/code&gt; &lt;/a&gt; . Если методы подкласса не реализуют &lt;code&gt;keepdims&lt;/code&gt; , будут возникать исключения.</target>
        </trans-unit>
        <trans-unit id="2abfa832de7674bd2d08ad1f7e2b845f18a0059c" translate="yes" xml:space="preserve">
          <source>If the value is anything but the default, then &lt;code&gt;keepdims&lt;/code&gt; will be passed through to the &lt;a href=&quot;https://docs.python.org/dev/library/functions.html#min&quot;&gt;&lt;code&gt;min&lt;/code&gt;&lt;/a&gt; method of sub-classes of &lt;a href=&quot;numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;ndarray&lt;/code&gt;&lt;/a&gt;. If the sub-classes methods does not implement &lt;code&gt;keepdims&lt;/code&gt; any exceptions will be raised.</source>
          <target state="translated">Если значение отличается от значения по умолчанию, то &lt;code&gt;keepdims&lt;/code&gt; будут переданы методу &lt;a href=&quot;https://docs.python.org/dev/library/functions.html#min&quot;&gt; &lt;code&gt;min&lt;/code&gt; &lt;/a&gt; подклассов &lt;a href=&quot;numpy.ndarray#numpy.ndarray&quot;&gt; &lt;code&gt;ndarray&lt;/code&gt; &lt;/a&gt; . Если методы подкласса не реализуют &lt;code&gt;keepdims&lt;/code&gt; , будут возникать исключения.</target>
        </trans-unit>
        <trans-unit id="fb8acc52d13221f0fba6edb05a42e80cbebd0a2e" translate="yes" xml:space="preserve">
          <source>If the value is anything but the default, then &lt;code&gt;keepdims&lt;/code&gt; will be passed through to the &lt;a href=&quot;numpy.mean#numpy.mean&quot;&gt;&lt;code&gt;mean&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;numpy.sum#numpy.sum&quot;&gt;&lt;code&gt;sum&lt;/code&gt;&lt;/a&gt; methods of sub-classes of &lt;a href=&quot;numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;ndarray&lt;/code&gt;&lt;/a&gt;. If the sub-classes methods does not implement &lt;code&gt;keepdims&lt;/code&gt; any exceptions will be raised.</source>
          <target state="translated">Если значение не является значением по умолчанию, то &lt;code&gt;keepdims&lt;/code&gt; будут переданы в методы &lt;a href=&quot;numpy.mean#numpy.mean&quot;&gt; &lt;code&gt;mean&lt;/code&gt; &lt;/a&gt; или &lt;a href=&quot;numpy.sum#numpy.sum&quot;&gt; &lt;code&gt;sum&lt;/code&gt; &lt;/a&gt; подклассов &lt;a href=&quot;numpy.ndarray#numpy.ndarray&quot;&gt; &lt;code&gt;ndarray&lt;/code&gt; &lt;/a&gt; . Если методы подкласса не реализуют &lt;code&gt;keepdims&lt;/code&gt; , будут возникать исключения.</target>
        </trans-unit>
        <trans-unit id="33c6901ff2ee0db95c77f2b313983f44526bb314" translate="yes" xml:space="preserve">
          <source>If there are only scalars or the maximum category of the scalars is higher than the maximum category of the arrays, the data types are combined with &lt;a href=&quot;#c.PyArray_PromoteTypes&quot;&gt;&lt;code&gt;PyArray_PromoteTypes&lt;/code&gt;&lt;/a&gt; to produce the return value.</source>
          <target state="translated">Если есть только скаляры или максимальная категория скаляров выше, чем максимальная категория массивов, типы данных объединяются с &lt;a href=&quot;#c.PyArray_PromoteTypes&quot;&gt; &lt;code&gt;PyArray_PromoteTypes&lt;/code&gt; &lt;/a&gt; для получения возвращаемого значения.</target>
        </trans-unit>
        <trans-unit id="33fe4c771f7142c020971d30614039b35a541395" translate="yes" xml:space="preserve">
          <source>If there are only scalars or the maximum category of the scalars is higher than the maximum category of the arrays, the data types are combined with &lt;a href=&quot;numpy.promote_types#numpy.promote_types&quot;&gt;&lt;code&gt;promote_types&lt;/code&gt;&lt;/a&gt; to produce the return value.</source>
          <target state="translated">Если есть только скаляры или максимальная категория скаляров выше, чем максимальная категория массивов, типы данных объединяются с &lt;a href=&quot;numpy.promote_types#numpy.promote_types&quot;&gt; &lt;code&gt;promote_types&lt;/code&gt; &lt;/a&gt; для получения возвращаемого значения.</target>
        </trans-unit>
        <trans-unit id="713f3b36701faad5c729c8225f4c0508fcfe41f1" translate="yes" xml:space="preserve">
          <source>If there is no dictionary passed in or &lt;code&gt;vardict&lt;/code&gt; is None then returns NumPy arrays in the globals() dictionary (all NumPy arrays in the namespace).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d0c11d30de5e96bdaa85cb78bb53dddd3ba03ebc" translate="yes" xml:space="preserve">
          <source>If there is no library with the expected extension, or the library is defective and cannot be loaded.</source>
          <target state="translated">Если нет библиотеки с ожидаемым расширением,или библиотека неисправна и не может быть загружена.</target>
        </trans-unit>
        <trans-unit id="ef27bb26cd9e20ec5eb81bab137d2b6e00a224b0" translate="yes" xml:space="preserve">
          <source>If there is only one Boolean array and no integer indexing array present, this is straight forward. Care must only be taken to make sure that the boolean index has &lt;em&gt;exactly&lt;/em&gt; as many dimensions as it is supposed to work with.</source>
          <target state="translated">Если есть только один логический массив и нет целочисленного массива индексации, это просто. Следует позаботиться только о том, чтобы логический индекс имел &lt;em&gt;ровно&lt;/em&gt; столько измерений , с которыми он должен работать.</target>
        </trans-unit>
        <trans-unit id="6e268d3c7b0192c893825d9fa07e4e49b28360ad" translate="yes" xml:space="preserve">
          <source>If these arrays are all collected in a structured array, then &lt;a href=&quot;#c.PyArray_Sort&quot;&gt;&lt;code&gt;PyArray_Sort&lt;/code&gt;&lt;/a&gt; (&amp;hellip;) can also be used to sort the array directly.</source>
          <target state="translated">Если все эти массивы собраны в структурированный массив, тогда &lt;a href=&quot;#c.PyArray_Sort&quot;&gt; &lt;code&gt;PyArray_Sort&lt;/code&gt; &lt;/a&gt; (&amp;hellip;) также можно использовать для сортировки массива напрямую.</target>
        </trans-unit>
        <trans-unit id="54dc9b5be81c958064f5d558fe01980eec4eadde" translate="yes" xml:space="preserve">
          <source>If these conditions are not met, a &lt;code&gt;ValueError: operands could not be broadcast together&lt;/code&gt; exception is thrown, indicating that the arrays have incompatible shapes. The size of the resulting array is the size that is not 1 along each axis of the inputs.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4b5797d27d90ecc738ae241c7f2d88131ab4d780" translate="yes" xml:space="preserve">
          <source>If these conditions hold, &lt;code&gt;__array_function__&lt;/code&gt; should return the result from calling its implementation for &lt;code&gt;func(*args, **kwargs)&lt;/code&gt;. Otherwise, it should return the sentinel value &lt;code&gt;NotImplemented&lt;/code&gt;, indicating that the function is not implemented by these types.</source>
          <target state="translated">Если эти условия выполняются, &lt;code&gt;__array_function__&lt;/code&gt; должна вернуть результат вызова своей реализации для &lt;code&gt;func(*args, **kwargs)&lt;/code&gt; . В противном случае он должен вернуть контрольное значение &lt;code&gt;NotImplemented&lt;/code&gt; , указывающее, что функция не реализована этими типами.</target>
        </trans-unit>
        <trans-unit id="c80ca8262eeedd9bef78dbd28fb2dc07a4582c48" translate="yes" xml:space="preserve">
          <source>If this array does not own its own memory, then base points to the Python object that owns it (perhaps another array object)</source>
          <target state="translated">Если этот массив не владеет собственной памятью,то база указывает на объект Python,которому он принадлежит (возможно,другой объект массива)</target>
        </trans-unit>
        <trans-unit id="f79009d9f8b9e9859082a3efe68d074e3e908ff8" translate="yes" xml:space="preserve">
          <source>If this array has the (deprecated) &lt;a href=&quot;array#c.NPY_ARRAY_UPDATEIFCOPY&quot;&gt;&lt;code&gt;NPY_ARRAY_UPDATEIFCOPY&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;array#c.NPY_ARRAY_WRITEBACKIFCOPY&quot;&gt;&lt;code&gt;NPY_ARRAY_WRITEBACKIFCOPY&lt;/code&gt;&lt;/a&gt; flag set, then this array is a working copy of a &amp;ldquo;misbehaved&amp;rdquo; array.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f63b91f81d86b6356e230f230ee7da044adca895" translate="yes" xml:space="preserve">
          <source>If this array has the (deprecated) &lt;a href=&quot;c-api.array#c.NPY_ARRAY_UPDATEIFCOPY&quot;&gt;&lt;code&gt;NPY_ARRAY_UPDATEIFCOPY&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;c-api.array#c.NPY_ARRAY_WRITEBACKIFCOPY&quot;&gt;&lt;code&gt;NPY_ARRAY_WRITEBACKIFCOPY&lt;/code&gt;&lt;/a&gt; flag set, then this array is a working copy of a &amp;ldquo;misbehaved&amp;rdquo; array.</source>
          <target state="translated">Если в этом массиве установлен (устаревший) &lt;a href=&quot;c-api.array#c.NPY_ARRAY_UPDATEIFCOPY&quot;&gt; &lt;code&gt;NPY_ARRAY_UPDATEIFCOPY&lt;/code&gt; &lt;/a&gt; или &lt;a href=&quot;c-api.array#c.NPY_ARRAY_WRITEBACKIFCOPY&quot;&gt; &lt;code&gt;NPY_ARRAY_WRITEBACKIFCOPY&lt;/code&gt; &lt;/a&gt; , то этот массив является рабочей копией массива с &amp;laquo;неправильным поведением&amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="2e1498e4add4060095cafec2d44c32b17e6ac395" translate="yes" xml:space="preserve">
          <source>If this condition is not met, a &lt;code&gt;ValueError('frames are not aligned')&lt;/code&gt; exception is thrown indicating that the arrays have incompatible shapes. The size of the result array created by broadcast operations is the maximum size along each dimension from the input arrays. Note that the rule does not say anything about the two arrays needing to have the same number of dimensions. So, for example, if you have a 256 x 256 x 3 array of RGB values, and you want to scale each color in the image by a different value, you can multiply the image by a one-dimensional array with 3 values. Lining up the sizes of the trailing axes of these arrays according to the broadcast rule shows that they are compatible</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b54640e63d198f32f1e8358a28ce29bc6179e6f7" translate="yes" xml:space="preserve">
          <source>If this function returns true, the caller should also check the inner loop stride of the operand, because if that stride is 0, then only the first element of the innermost external loop is being visited for the first time.</source>
          <target state="translated">Если эта функция возвращает true,то вызывающий абонент должен также проверить внутренний шаблон цикла операнда,так как если этот шаблон равен 0,то в первый раз посещается только первый элемент внутреннего самого внешнего цикла.</target>
        </trans-unit>
        <trans-unit id="24a22c06faef1b4b61f295517b88ec97d1fc0a84" translate="yes" xml:space="preserve">
          <source>If this is &lt;code&gt;None&lt;/code&gt;, a reduction is performed over all the axes. If this is a tuple of ints, a reduction is performed on multiple axes, instead of a single axis or all the axes as before.</source>
          <target state="translated">Если это &lt;code&gt;None&lt;/code&gt; , сокращение выполняется по всем осям. Если это кортеж целых чисел, сокращение выполняется по нескольким осям, а не по одной оси или по всем осям, как раньше.</target>
        </trans-unit>
        <trans-unit id="33f579e70b917db4493a3111bc7067b3dc4d2ff2" translate="yes" xml:space="preserve">
          <source>If this is None, a reduction is performed over all the axes. If this is a tuple of ints, a reduction is performed on multiple axes, instead of a single axis or all the axes as before.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e4599c6e53b844db2376ed9e56ed7b49e63c6ec3" translate="yes" xml:space="preserve">
          <source>If this is a tuple of ints, a mean is performed over multiple axes, instead of a single axis or all the axes as before.</source>
          <target state="translated">Если это кортеж из интв,то среднее значение выполняется по нескольким осям,а не по одной оси или по всем осям,как раньше.</target>
        </trans-unit>
        <trans-unit id="04767d2c5f5bbd4aab7323a751a31f226739a396" translate="yes" xml:space="preserve">
          <source>If this is a tuple of ints, a reduction is performed on multiple axes, instead of a single axis or all the axes as before.</source>
          <target state="translated">Если это кортеж из интвейнов,то вместо одной оси или всех осей,как раньше,выполняется уменьшение по нескольким осям.</target>
        </trans-unit>
        <trans-unit id="e11ec2c8b461dd6b1390de16d518719c4d72ce55" translate="yes" xml:space="preserve">
          <source>If this is a tuple of ints, a standard deviation is performed over multiple axes, instead of a single axis or all the axes as before.</source>
          <target state="translated">Если это кортеж из интв,то стандартное отклонение выполняется по нескольким осям,а не по одной оси или по всем осям,как раньше.</target>
        </trans-unit>
        <trans-unit id="cdec667610de13f7517139e9ece6f88d2d290194" translate="yes" xml:space="preserve">
          <source>If this is a tuple of ints, a variance is performed over multiple axes, instead of a single axis or all the axes as before.</source>
          <target state="translated">Если это кортеж из интв,то дисперсия выполняется по нескольким осям,а не по одной оси или по всем осям,как раньше.</target>
        </trans-unit>
        <trans-unit id="d50012ee6c384ff0215bab7085fcf98c562bc452" translate="yes" xml:space="preserve">
          <source>If this is a tuple of ints, the count is performed on multiple axes, instead of a single axis or all the axes as before.</source>
          <target state="translated">Если это кортеж из интв,то подсчет производится по нескольким осям,а не по одной оси или по всем осям,как раньше.</target>
        </trans-unit>
        <trans-unit id="c674e367c6b1c23d3abf3ddc4c5a7a14ff593b5a" translate="yes" xml:space="preserve">
          <source>If this is a tuple of ints, the maximum is selected over multiple axes, instead of a single axis or all the axes as before.</source>
          <target state="translated">Если это кортеж из интв,то максимум выбирается по нескольким осям,а не по одной оси или по всем осям,как раньше.</target>
        </trans-unit>
        <trans-unit id="a0756a48081a9a9cb1bfbc79e9843f0007e55c1d" translate="yes" xml:space="preserve">
          <source>If this is a tuple of ints, the minimum is selected over multiple axes, instead of a single axis or all the axes as before.</source>
          <target state="translated">Если это кортеж из нескольких осей,то вместо одной оси или всех осей,как раньше,выбирается минимальный уровень.</target>
        </trans-unit>
        <trans-unit id="7573da3ff564f7261e16d53ba17d4d7c25b6abc9" translate="yes" xml:space="preserve">
          <source>If this is anything but the default value it will be passed through (in the special case of an empty array) to the &lt;a href=&quot;numpy.mean#numpy.mean&quot;&gt;&lt;code&gt;mean&lt;/code&gt;&lt;/a&gt; function of the underlying array. If the array is a sub-class and &lt;a href=&quot;numpy.mean#numpy.mean&quot;&gt;&lt;code&gt;mean&lt;/code&gt;&lt;/a&gt; does not have the kwarg &lt;code&gt;keepdims&lt;/code&gt; this will raise a RuntimeError.</source>
          <target state="translated">Если это что-то, кроме значения по умолчанию, оно будет передано (в особом случае пустого массива) в &lt;a href=&quot;numpy.mean#numpy.mean&quot;&gt; &lt;code&gt;mean&lt;/code&gt; &lt;/a&gt; функцию базового массива. Если массив является подклассом и у &lt;a href=&quot;numpy.mean#numpy.mean&quot;&gt; &lt;code&gt;mean&lt;/code&gt; &lt;/a&gt; нет kwarg &lt;code&gt;keepdims&lt;/code&gt; , это вызовет RuntimeError.</target>
        </trans-unit>
        <trans-unit id="9eef22bd67c15e89cde5d92734a40aa76d92e691" translate="yes" xml:space="preserve">
          <source>If this is non- &lt;code&gt;NULL&lt;/code&gt;, then this data-type descriptor is a C-style contiguous array of another data-type descriptor. In other-words, each element that this descriptor describes is actually an array of some other base descriptor. This is most useful as the data-type descriptor for a field in another data-type descriptor. The fields member should be &lt;code&gt;NULL&lt;/code&gt; if this is non- &lt;code&gt;NULL&lt;/code&gt; (the fields member of the base descriptor can be non- &lt;code&gt;NULL&lt;/code&gt; however). The &lt;code&gt;PyArray_ArrayDescr&lt;/code&gt; structure is defined using</source>
          <target state="translated">Если это не &lt;code&gt;NULL&lt;/code&gt; , то этот дескриптор типа данных является непрерывным массивом в стиле C другого дескриптора типа данных. Другими словами, каждый элемент, описываемый этим дескриптором, на самом деле является массивом какого-то другого базового дескриптора. Это наиболее полезно в качестве дескриптора типа данных для поля в другом дескрипторе типа данных. Член fields должен иметь &lt;code&gt;NULL&lt;/code&gt; если он не равен &lt;code&gt;NULL&lt;/code&gt; ( однако член fields базового дескриптора может быть не &lt;code&gt;NULL&lt;/code&gt; ). Структура &lt;code&gt;PyArray_ArrayDescr&lt;/code&gt; определяется с использованием</target>
        </trans-unit>
        <trans-unit id="2824d770011e81edcc48aaca00be40fe5064246e" translate="yes" xml:space="preserve">
          <source>If this is non-NULL, then this data-type-descriptor has fields described by a Python dictionary whose keys are names (and also titles if given) and whose values are tuples that describe the fields. Recall that a data-type-descriptor always describes a fixed-length set of bytes. A field is a named sub-region of that total, fixed-length collection. A field is described by a tuple composed of another data- type-descriptor and a byte offset. Optionally, the tuple may contain a title which is normally a Python string. These tuples are placed in this dictionary keyed by name (and also title if given).</source>
          <target state="translated">Если это не NULL,то этот скриптор типа данных имеет поля,описываемые словарем Python,ключами которого являются имена (а также заголовки,если они заданы),и значения которых являются кортежами,описывающими поля.Напомним,что скриптор типа данных всегда описывает набор байтов фиксированной длины.Поле-это названный подрегион этой общей коллекции фиксированной длины.Поле описывается кортежом,состоящим из другого скриптора типа данных и смещения байтов.Дополнительно кортеж может содержать заголовок,который обычно представляет собой питоновую строку.Эти кортежи помещаются в этот словарь с ключом по имени (а также по заголовку,если он задан).</target>
        </trans-unit>
        <trans-unit id="0d86cba4ba7294ed9f7338e68f7b4f37b35c1557" translate="yes" xml:space="preserve">
          <source>If this is not desirable, then the array should be cast to a larger integer type first:</source>
          <target state="translated">Если это нежелательно,то сначала массив должен быть приведен к большему целочисленному типу:</target>
        </trans-unit>
        <trans-unit id="1ae38fd1d446748062bddf73d4866a0b315e1322" translate="yes" xml:space="preserve">
          <source>If this is set to &lt;code&gt;True&lt;/code&gt;, axes which are reduced over will be left in the result as a dimension with size one, so that the result will broadcast correctly against the inputs. This option can only be used for generalized ufuncs that operate on inputs that all have the same number of core dimensions and with outputs that have no core dimensions , i.e., with signatures like &lt;code&gt;(i),(i)-&amp;gt;()&lt;/code&gt; or &lt;code&gt;(m,m)-&amp;gt;()&lt;/code&gt;. If used, the location of the dimensions in the output can be controlled with &lt;code&gt;axes&lt;/code&gt; and &lt;code&gt;axis&lt;/code&gt;.</source>
          <target state="translated">Если для этого параметра установлено значение &lt;code&gt;True&lt;/code&gt; , уменьшенные оси останутся в результате как размер с размером один, так что результат будет правильно транслироваться по входам. Эту опцию можно использовать только для обобщенных функций ufunc, которые работают с входами, которые имеют одинаковое количество размеров ядра, и с выходами, не имеющими размеров ядра, то есть с сигнатурами типа &lt;code&gt;(i),(i)-&amp;gt;()&lt;/code&gt; или &lt;code&gt;(m,m)-&amp;gt;()&lt;/code&gt; . Если используется, расположение размеров на выходе можно контролировать с помощью &lt;code&gt;axes&lt;/code&gt; и &lt;code&gt;axis&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a675290349084bcd281fdfbd331891015b07aca9" translate="yes" xml:space="preserve">
          <source>If this is set to &lt;code&gt;True&lt;/code&gt;, axes which are reduced over will be left in the result as a dimension with size one, so that the result will broadcast correctly against the inputs. This option can only be used for generalized ufuncs that operate on inputs that all have the same number of core dimensions and with outputs that have no core dimensions, i.e., with signatures like &lt;code&gt;(i),(i)-&amp;gt;()&lt;/code&gt; or &lt;code&gt;(m,m)-&amp;gt;()&lt;/code&gt;. If used, the location of the dimensions in the output can be controlled with &lt;code&gt;axes&lt;/code&gt; and &lt;code&gt;axis&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="86e30e948710dc5b2db29b7dc82437914fd08740" translate="yes" xml:space="preserve">
          <source>If this is set to True, the axes that are counted are left in the result as dimensions with size one. With this option, the result will broadcast correctly against the input array.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="74585a8bd339c6874f448a64d5fe0ba3642c10c6" translate="yes" xml:space="preserve">
          <source>If this is set to True, the axes which are normed over are left in the result as dimensions with size one. With this option the result will broadcast correctly against the original &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="translated">Если установлено значение True, оси, которые нормированы, останутся в результате как размеры с размером один. С этой опцией результат будет транслироваться правильно относительно исходного &lt;code&gt;x&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="526b620d34688cc0c68a7ee67814781d453388f5" translate="yes" xml:space="preserve">
          <source>If this is set to True, the axes which are reduced are left in the result as dimensions with size one. With this option, the result will broadcast correctly against the array.</source>
          <target state="translated">Если установлено значение True,то редуцированные оси останутся в результате в виде размеров с первым размером.При выборе этой опции результат будет корректно транслироваться по массиву.</target>
        </trans-unit>
        <trans-unit id="015e500928e7c3f86f2c9b5121c746246fcd7a9f" translate="yes" xml:space="preserve">
          <source>If this is set to True, the axes which are reduced are left in the result as dimensions with size one. With this option, the result will broadcast correctly against the input array.</source>
          <target state="translated">Если установлено значение True,то редуцированные оси останутся в результате в виде размеров с первым размером.При выборе этого параметра результат будет корректно отображаться на входном массиве.</target>
        </trans-unit>
        <trans-unit id="caf30df07a09579107c0faa5c9aaad9ad8721644" translate="yes" xml:space="preserve">
          <source>If this is set to True, the axes which are reduced are left in the result as dimensions with size one. With this option, the result will broadcast correctly against the original &lt;code&gt;a&lt;/code&gt;.</source>
          <target state="translated">Если установлено значение True, уменьшенные оси останутся в результате как размеры с размером один. С этой опцией результат будет правильно транслироваться относительно оригинала &lt;code&gt;a&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="668624d9e02d10dc8924733d51742fcc1923286c" translate="yes" xml:space="preserve">
          <source>If this is set to True, the axes which are reduced are left in the result as dimensions with size one. With this option, the result will broadcast correctly against the original &lt;code&gt;arr&lt;/code&gt;.</source>
          <target state="translated">Если установлено значение True, уменьшенные оси останутся в результате как размеры с размером один. С этой опцией результат будет транслироваться правильно относительно исходного &lt;code&gt;arr&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="813c59426f99f6e2035686f0669f18c79ec2fc97" translate="yes" xml:space="preserve">
          <source>If this is set to True, the axes which are reduced are left in the result as dimensions with size one. With this option, the result will broadcast correctly against the original array &lt;code&gt;a&lt;/code&gt;.</source>
          <target state="translated">Если установлено значение True, уменьшенные оси останутся в результате как размеры с размером один. С этой опцией результат будет правильно транслироваться против исходного массива &lt;code&gt;a&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="28e1fe971ad9fdc32699e38250e14da5caf0bb91" translate="yes" xml:space="preserve">
          <source>If this value is anything but the default it is passed through as-is to the relevant functions of the sub-classes. If these functions do not have a &lt;code&gt;keepdims&lt;/code&gt; kwarg, a RuntimeError will be raised.</source>
          <target state="translated">Если это значение не является значением по умолчанию, оно передается как есть соответствующим функциям подклассов. Если у этих функций нет &lt;code&gt;keepdims&lt;/code&gt; keepdims, будет вызвана ошибка RuntimeError.</target>
        </trans-unit>
        <trans-unit id="dd4ec2a983c899a1017fcabb86ae5785ce4793ab" translate="yes" xml:space="preserve">
          <source>If true (default), then the object is copied. Otherwise, a copy will only be made if __array__ returns a copy, if obj is a nested sequence, or if a copy is needed to satisfy any of the other requirements (&lt;a href=&quot;numpy.dtype#numpy.dtype&quot;&gt;&lt;code&gt;dtype&lt;/code&gt;&lt;/a&gt;, &lt;code&gt;order&lt;/code&gt;, etc.).</source>
          <target state="translated">Если true (по умолчанию), то объект копируется. В противном случае копия будет сделана только в том случае, если __array__ вернет копию, если obj является вложенной последовательностью или если копия необходима для удовлетворения любого из других требований ( &lt;a href=&quot;numpy.dtype#numpy.dtype&quot;&gt; &lt;code&gt;dtype&lt;/code&gt; &lt;/a&gt; , &lt;code&gt;order&lt;/code&gt; и т. Д.).</target>
        </trans-unit>
        <trans-unit id="a6f5f638d5dadad294989835332dc69ea08c7e48" translate="yes" xml:space="preserve">
          <source>If true (default), then the object is copied. Otherwise, a copy will only be made if __array__ returns a copy, if obj is a nested sequence, or if a copy is needed to satisfy any of the other requirements (&lt;code&gt;itemsize&lt;/code&gt;, unicode, &lt;code&gt;order&lt;/code&gt;, etc.).</source>
          <target state="translated">Если true (по умолчанию), то объект копируется. В противном случае копия будет сделана только в том случае, если __array__ вернет копию, если obj является вложенной последовательностью или если копия необходима для удовлетворения любого из других требований ( &lt;code&gt;itemsize&lt;/code&gt; , юникод, &lt;code&gt;order&lt;/code&gt; и т. Д.).</target>
        </trans-unit>
        <trans-unit id="7cfded7f1f4f8985525752f730c915f025bbc3bd" translate="yes" xml:space="preserve">
          <source>If true, &lt;code&gt;stop&lt;/code&gt; is the last sample. Otherwise, it is not included. Default is True.</source>
          <target state="translated">Если true, &lt;code&gt;stop&lt;/code&gt; - это последняя выборка. В противном случае он не включается. По умолчанию True.</target>
        </trans-unit>
        <trans-unit id="89363179f510b5ee9e2706f4cf949aff38e269d9" translate="yes" xml:space="preserve">
          <source>If true, sample from the interval [low, high] instead of the default [low, high) Defaults to False</source>
          <target state="translated">Если верно,сэмпл из интервала [низкий,высокий]вместо значения по умолчанию [низкий,высокий]По умолчанию False</target>
        </trans-unit>
        <trans-unit id="ade7c82d0d30db8fc4ef391480e9db75f4fe6678" translate="yes" xml:space="preserve">
          <source>If true, use an &amp;ldquo;aligned&amp;rdquo; memory layout, otherwise use a &amp;ldquo;packed&amp;rdquo; layout.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3ef0d38b764385bc39d70e5ad26d095da7b5d3f0" translate="yes" xml:space="preserve">
          <source>If used with &lt;a href=&quot;#c.NPY_ITER_EXTERNAL_LOOP&quot;&gt;&lt;code&gt;NPY_ITER_EXTERNAL_LOOP&lt;/code&gt;&lt;/a&gt;, the inner loop for the caller may get larger chunks than would be possible without buffering, because of how the strides are laid out.</source>
          <target state="translated">При использовании с &lt;a href=&quot;#c.NPY_ITER_EXTERNAL_LOOP&quot;&gt; &lt;code&gt;NPY_ITER_EXTERNAL_LOOP&lt;/code&gt; &lt;/a&gt; внутренний цикл для вызывающего может получить более крупные фрагменты, чем это было бы возможно без буферизации, из-за того, как расположены шаги.</target>
        </trans-unit>
        <trans-unit id="e6e87a78ddc8c45866e59f696a01a91d82f291c2" translate="yes" xml:space="preserve">
          <source>If values in &lt;code&gt;x&lt;/code&gt; are beyond the bounds of &lt;code&gt;bins&lt;/code&gt;, 0 or &lt;code&gt;len(bins)&lt;/code&gt; is returned as appropriate.</source>
          <target state="translated">Если значения в &lt;code&gt;x&lt;/code&gt; выходят за пределы &lt;code&gt;bins&lt;/code&gt; , соответственно возвращается 0 или &lt;code&gt;len(bins)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="adc126c0d80d4b8b968260ca8a9cd270dc0bc84e" translate="yes" xml:space="preserve">
          <source>If values in &lt;code&gt;x&lt;/code&gt; are such that they fall outside the bin range, attempting to index &lt;code&gt;bins&lt;/code&gt; with the indices that &lt;a href=&quot;#numpy.digitize&quot;&gt;&lt;code&gt;digitize&lt;/code&gt;&lt;/a&gt; returns will result in an IndexError.</source>
          <target state="translated">Если значения в &lt;code&gt;x&lt;/code&gt; таковы, что они выходят за пределы диапазона ячеек , попытка индексировать &lt;code&gt;bins&lt;/code&gt; с индексами, которые &lt;a href=&quot;#numpy.digitize&quot;&gt; &lt;code&gt;digitize&lt;/code&gt; &lt;/a&gt; возврат, приведет к IndexError.</target>
        </trans-unit>
        <trans-unit id="b223152b4e60f22e3efa048a66b57e829307cf69" translate="yes" xml:space="preserve">
          <source>If we designed &lt;code&gt;rms&lt;/code&gt;, we probably made it a routine that takes an input-only array of length &lt;code&gt;n&lt;/code&gt; of &lt;code&gt;double&lt;/code&gt; values called &lt;code&gt;seq&lt;/code&gt; and returns the root mean square. The default behavior of &lt;a href=&quot;http://www.swig.org&quot;&gt;SWIG&lt;/a&gt;, however, will be to create a wrapper function that compiles, but is nearly impossible to use from the scripting language in the way the C routine was intended.</source>
          <target state="translated">Если мы разработали &lt;code&gt;rms&lt;/code&gt; , мы , вероятно , сделали это процедуру , которая принимает входной только массив длины &lt;code&gt;n&lt;/code&gt; от &lt;code&gt;double&lt;/code&gt; значений , называемых &lt;code&gt;seq&lt;/code&gt; и возвращает среднеквадратичное. Однако поведение &lt;a href=&quot;http://www.swig.org&quot;&gt;SWIG по&lt;/a&gt; умолчанию будет заключаться в создании функции-оболочки, которая компилируется, но ее почти невозможно использовать из языка сценариев так, как была задумана процедура C.</target>
        </trans-unit>
        <trans-unit id="995e94e98f9bf00d5fa392b05fcaad89987b6cf9" translate="yes" xml:space="preserve">
          <source>If we operate on &lt;code&gt;arr&lt;/code&gt; with a numpy function, numpy will again use the &lt;code&gt;__array__&lt;/code&gt; interface to convert it to an array and then apply the function in the usual way.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f97977f7edcb7ebd515a426a761fd048280b35b8" translate="yes" xml:space="preserve">
          <source>If we subclass ndarray, we need to deal not only with explicit construction of our array type, but also &lt;a href=&quot;#view-casting&quot;&gt;View casting&lt;/a&gt; or &lt;a href=&quot;#new-from-template&quot;&gt;Creating new from template&lt;/a&gt;. NumPy has the machinery to do this, and this machinery that makes subclassing slightly non-standard.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="be3492efc8039f75947121fd3b30a1fa61841ee0" translate="yes" xml:space="preserve">
          <source>If we want to get the max and min at the same time, we can stack the indices first</source>
          <target state="translated">Если мы хотим получить максимальное и минимальное значение одновременно,то сначала мы можем сложить индексы.</target>
        </trans-unit>
        <trans-unit id="0b08db0a15b738091c43209c89bb138ad98fa1a5" translate="yes" xml:space="preserve">
          <source>If writing to the value in &amp;lsquo;op&amp;rsquo; is desired, set the boolean &amp;lsquo;writeable&amp;rsquo; to 1. This raises an error when &amp;lsquo;op&amp;rsquo; is a scalar, list of lists, or other non-writeable &amp;lsquo;op&amp;rsquo;. This differs from passing &lt;a href=&quot;#c.NPY_ARRAY_WRITEABLE&quot;&gt;&lt;code&gt;NPY_ARRAY_WRITEABLE&lt;/code&gt;&lt;/a&gt; to PyArray_FromAny, where the writeable array may be a copy of the input.</source>
          <target state="translated">Если требуется запись в значение в 'op', установите логическое 'writeable' в 1. Это вызывает ошибку, если 'op' является скаляром, списком списков или другим не-записываемым 'op'. Это отличается от передачи &lt;a href=&quot;#c.NPY_ARRAY_WRITEABLE&quot;&gt; &lt;code&gt;NPY_ARRAY_WRITEABLE&lt;/code&gt; &lt;/a&gt; в PyArray_FromAny, где записываемый массив может быть копией ввода.</target>
        </trans-unit>
        <trans-unit id="d75e358b391e7be55d7e5cd127dec8c0712acdf8" translate="yes" xml:space="preserve">
          <source>If you already have Matplotlib installed, you can import it with:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7cdef2e4118adffef01cdccc2d7928ddab94e772" translate="yes" xml:space="preserve">
          <source>If you already have Python, you can install NumPy with:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="541c45cda5d06a312d0d288fb58df06c65cc4253" translate="yes" xml:space="preserve">
          <source>If you are a first-time contributor:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="df553e5d4398ed0e4dcd8bdb41c75c9a32748a9c" translate="yes" xml:space="preserve">
          <source>If you are constructing an array using the C API, and specifying your own memory, you should use the function &lt;a href=&quot;#c.PyArray_SetBaseObject&quot;&gt;&lt;code&gt;PyArray_SetBaseObject&lt;/code&gt;&lt;/a&gt; to set the base to an object which owns the memory.</source>
          <target state="translated">Если вы создаете массив с помощью C API и указываете свою собственную память, вам следует использовать функцию &lt;a href=&quot;#c.PyArray_SetBaseObject&quot;&gt; &lt;code&gt;PyArray_SetBaseObject&lt;/code&gt; ,&lt;/a&gt; чтобы установить базу для объекта, которому принадлежит память.</target>
        </trans-unit>
        <trans-unit id="348c2da24ae5fb5879e487ab21af4e5f5e066f22" translate="yes" xml:space="preserve">
          <source>If you are executing the commands above in the IPython shell, it might be necessary to use the command &lt;code&gt;plt.show()&lt;/code&gt; to show the image window.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="39a6add3139de0ce389e24494d0e34b85d48e6cd" translate="yes" xml:space="preserve">
          <source>If you are not a subclass of &lt;a href=&quot;generated/numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;ndarray&lt;/code&gt;&lt;/a&gt;, we recommend your class define special methods like &lt;code&gt;__add__&lt;/code&gt; and &lt;code&gt;__lt__&lt;/code&gt; that delegate to ufuncs just like ndarray does. An easy way to do this is to subclass from &lt;a href=&quot;generated/numpy.lib.mixins.ndarrayoperatorsmixin#numpy.lib.mixins.NDArrayOperatorsMixin&quot;&gt;&lt;code&gt;NDArrayOperatorsMixin&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Если вы не являетесь подклассом &lt;a href=&quot;generated/numpy.ndarray#numpy.ndarray&quot;&gt; &lt;code&gt;ndarray&lt;/code&gt; &lt;/a&gt; , мы рекомендуем вашему классу определить специальные методы, такие как &lt;code&gt;__add__&lt;/code&gt; и &lt;code&gt;__lt__&lt;/code&gt; , которые делегируют ufuncs, как это делает ndarray. Легкий способ сделать это - &lt;a href=&quot;generated/numpy.lib.mixins.ndarrayoperatorsmixin#numpy.lib.mixins.NDArrayOperatorsMixin&quot;&gt; &lt;code&gt;NDArrayOperatorsMixin&lt;/code&gt; &lt;/a&gt; подкласс от NDArrayOperatorsMixin .</target>
        </trans-unit>
        <trans-unit id="7c035b2fcdae27121ab8105788f03a3cf705ba84" translate="yes" xml:space="preserve">
          <source>If you are unfamiliar with git/GitHub or the process of submitting a pull request (PR), check our &lt;a href=&quot;index#devindex&quot;&gt;Contributor Guide&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ad4921cf970b61f597c75ff9a8df48494b979251" translate="yes" xml:space="preserve">
          <source>If you are unsure whether your tutorial is useful to the community, consider submitting an issue on GitHub suggesting it, or asking on the mailing list or Stack Overflow.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0e97815d05cf1a3f4e8ef4ccabd6db0958203378" translate="yes" xml:space="preserve">
          <source>If you are using a development setup, make sure to run &lt;code&gt;git clean -xdf&lt;/code&gt; to delete all files not under version control (be careful not to lose any modifications you made, e.g. &lt;code&gt;site.cfg&lt;/code&gt;). In many cases files from old builds may lead to incorrect builds.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b1cb5159432a421c78854c686fcae1e006f9ca62" translate="yes" xml:space="preserve">
          <source>If you are using your own image, this command might take a while to run, depending on the size of your image and your hardware. Don&amp;rsquo;t worry, this is normal! The SVD can be a pretty intensive computation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="773329737315bec4048498e2cb47eae44fac50c7" translate="yes" xml:space="preserve">
          <source>If you are writing a tutorial or how-to, we encourage you to use real images and data (provided they are appropriately licensed and available). This makes the material more engaging for readers, and choosing the right data can add pedagogical value to your content.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d4136f331004a4bb7cc67364f6afc023fd507b25" translate="yes" xml:space="preserve">
          <source>If you are writing an extension module that will include quite a bit of your own algorithmic code as well, then Cython is a good match. Among its features is the ability to easily and quickly work with multidimensional arrays.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="97bfbc5e92312fd81c84cc357b8b556f1c360029" translate="yes" xml:space="preserve">
          <source>If you are writing code that needs to support older versions of numpy, note that prior to 1.15, &lt;a href=&quot;generated/numpy.nditer#numpy.nditer&quot;&gt;&lt;code&gt;nditer&lt;/code&gt;&lt;/a&gt; was not a context manager and did not have a &lt;code&gt;close&lt;/code&gt; method. Instead it relied on the destructor to initiate the writeback of the buffer.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="36ae6f737ad58a255ae0b7d304bf552b5362f8bf" translate="yes" xml:space="preserve">
          <source>If you are writing the algorithm, then I recommend that you use the stride information contained in the array to access the elements of the array (the &lt;a href=&quot;../reference/c-api/array#c.PyArray_GetPtr&quot;&gt;&lt;code&gt;PyArray_GetPtr&lt;/code&gt;&lt;/a&gt; macros make this painless). Then, you can relax your requirements so as not to force a single-segment array and the data-copying that might result.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b55dd90ddf002e60cb33ced8fd77f1baf2f3e711" translate="yes" xml:space="preserve">
          <source>If you aren&amp;rsquo;t already comfortable with reading tutorials that contain a lot of code, you might not know how to interpret a code block that looks like this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0aadabdedda0a7396088f7e7156f2221bf29f201" translate="yes" xml:space="preserve">
          <source>If you aren&amp;rsquo;t familiar with this style, it&amp;rsquo;s very easy to understand. If you see &lt;code&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/code&gt;, you&amp;rsquo;re looking at &lt;strong&gt;input&lt;/strong&gt;, or the code that you would enter. Everything that doesn&amp;rsquo;t have &lt;code&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/code&gt; in front of it is &lt;strong&gt;output&lt;/strong&gt;, or the results of running your code. This is the style you see when you run &lt;code&gt;python&lt;/code&gt; on the command line, but if you&amp;rsquo;re using IPython, you might see a different style.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bb14ac1edba829d3112a46c925f71b9aef58fe4d" translate="yes" xml:space="preserve">
          <source>If you begin with a 1D array like this one:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="50d785ffa376c738acba9fd3062d7ce8c3507854" translate="yes" xml:space="preserve">
          <source>If you construct an array by passing in your own memory buffer as a parameter, you need to set the array&amp;rsquo;s &lt;code&gt;base&lt;/code&gt; property to ensure the lifetime of the memory buffer is appropriate.</source>
          <target state="translated">Если вы создаете массив, передавая свой собственный буфер памяти в качестве параметра, вам необходимо установить &lt;code&gt;base&lt;/code&gt; свойство массива, чтобы гарантировать подходящее время жизни буфера памяти.</target>
        </trans-unit>
        <trans-unit id="5a09672523495c2e56a3b155436551396bec1686" translate="yes" xml:space="preserve">
          <source>If you created this array &amp;ldquo;a&amp;rdquo;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="72ea524f17d30ae2b5b06f8b246da402ecc0aab1" translate="yes" xml:space="preserve">
          <source>If you define &lt;code&gt;__array_ufunc__&lt;/code&gt;:</source>
          <target state="translated">Если вы определяете &lt;code&gt;__array_ufunc__&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="ad02ce8758b2b7ef1353b5d6ceccf301d0d32341" translate="yes" xml:space="preserve">
          <source>If you depend on the current behavior, then we suggest copying the returned array explicitly, i.e., use &lt;code&gt;np.diagonal(a).copy()&lt;/code&gt; instead of just &lt;code&gt;np.diagonal(a)&lt;/code&gt;. This will work with both past and future versions of NumPy.</source>
          <target state="translated">Если вы зависите от текущего поведения, мы предлагаем явно скопировать возвращаемый массив, т. &lt;code&gt;np.diagonal(a).copy()&lt;/code&gt; Использовать np.diagonal (a) .copy () вместо просто &lt;code&gt;np.diagonal(a)&lt;/code&gt; . Это будет работать как с прошлыми, так и с будущими версиями NumPy.</target>
        </trans-unit>
        <trans-unit id="e04ecd6da4be5a785c0ba7636ed164c9197444de" translate="yes" xml:space="preserve">
          <source>If you didn&amp;rsquo;t actually mess up but there are merge conflicts, you need to resolve those. This can be one of the trickier things to get right. For a good description of how to do this, see &lt;a href=&quot;https://git-scm.com/book/en/Git-Branching-Basic-Branching-and-Merging#Basic-Merge-Conflicts&quot;&gt;this article on merging conflicts&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e434a6791515ca1be095b9c944cc43b7244bf754" translate="yes" xml:space="preserve">
          <source>If you do this often, consider making CDN_URL and NPY_WHLS part of your default environment.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="48d4a9d3c1a910573f5c99d8162fc661353211a4" translate="yes" xml:space="preserve">
          <source>If you do want to use Fortran ordering realize that there are two approaches to consider: 1) accept that the first index is just not the most rapidly changing in memory and have all your I/O routines reorder your data when going from memory to disk or visa versa, or use numpy&amp;rsquo;s mechanism for mapping the first index to the most rapidly varying data. We recommend the former if possible. The disadvantage of the latter is that many of numpy&amp;rsquo;s functions will yield arrays without Fortran ordering unless you are careful to use the &amp;lsquo;order&amp;rsquo; keyword. Doing this would be highly inconvenient.</source>
          <target state="translated">Если вы действительно хотите использовать упорядочивание в Фортране, осознайте, что есть два подхода, которые следует учитывать: 1) принять, что первый индекс просто не является самым быстро изменяющимся в памяти, и пусть все ваши процедуры ввода-вывода переупорядочивают ваши данные при переходе из памяти на диск или наоборот, или использовать механизм numpy для сопоставления первого индекса с наиболее быстро меняющимися данными. Если возможно, мы рекомендуем первое. Недостатком последнего является то, что многие функции numpy будут давать массивы без упорядочивания в Фортране, если вы не используете ключевое слово order. Это было бы очень неудобно.</target>
        </trans-unit>
        <trans-unit id="e095aad5306acb61c4cd71ef6f17e3d170477a48" translate="yes" xml:space="preserve">
          <source>If you don&amp;rsquo;t have Python yet, you might want to consider using &lt;a href=&quot;https://www.anaconda.com/&quot;&gt;Anaconda&lt;/a&gt;. It&amp;rsquo;s the easiest way to get started. The good thing about getting this distribution is the fact that you don&amp;rsquo;t need to worry too much about separately installing NumPy or any of the major packages that you&amp;rsquo;ll be using for your data analyses, like pandas, Scikit-Learn, etc.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a32666f1e22aaef44f676905cda497776944f399" translate="yes" xml:space="preserve">
          <source>If you don&amp;rsquo;t have a &lt;a href=&quot;https://github.com/numpy/numpy&quot;&gt;github&lt;/a&gt; account, go to the &lt;a href=&quot;https://github.com/numpy/numpy&quot;&gt;github&lt;/a&gt; page, and make one.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="00332ddab35edaceba6aacb138a662dde934bdb6" translate="yes" xml:space="preserve">
          <source>If you don&amp;rsquo;t write to the array returned by this function, then you can just ignore all of the above.</source>
          <target state="translated">Если вы не пишете в массив, возвращаемый этой функцией, вы можете просто проигнорировать все вышеперечисленное.</target>
        </trans-unit>
        <trans-unit id="ddf01261f92656913e0a2ec2a624205e1c2e4b27" translate="yes" xml:space="preserve">
          <source>If you forgot to make a backup branch:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fe80a2730dc1732963891b3491f20ea69996dc7b" translate="yes" xml:space="preserve">
          <source>If you get a Python error that looks like the following:</source>
          <target state="translated">Если вы получите ошибку на Пайтоне,которая выглядит следующим образом:</target>
        </trans-unit>
        <trans-unit id="a53df4d5bfbd08adf0a5725999a9e0795dcb81f8" translate="yes" xml:space="preserve">
          <source>If you have a collection of tests that must be run multiple times with minor variations, it can be helpful to create a base class containing all the common tests, and then create a subclass for each variation. Several examples of this technique exist in NumPy; below are excerpts from one in &lt;a href=&quot;https://github.com/numpy/numpy/blob/master/numpy/linalg/tests/test_linalg.py&quot;&gt;numpy/linalg/tests/test_linalg.py&lt;/a&gt;:</source>
          <target state="translated">Если у вас есть набор тестов, которые необходимо запускать несколько раз с небольшими вариациями, может быть полезно создать базовый класс, содержащий все общие тесты, а затем создать подкласс для каждого варианта. Несколько примеров этой техники существует в NumPy; ниже приведены выдержки из одного &lt;a href=&quot;https://github.com/numpy/numpy/blob/master/numpy/linalg/tests/test_linalg.py&quot;&gt;файла&lt;/a&gt; в numpy / linalg / tests / test_linalg.py :</target>
        </trans-unit>
        <trans-unit id="b76d68a8292694b360bf5a2e8b28bbbb6775f004" translate="yes" xml:space="preserve">
          <source>If you have already decided which type of document you want to write, you can check out the following specific guides:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="edd73a9e41446ceec5844edddba90601c9a86d6a" translate="yes" xml:space="preserve">
          <source>If you have an array of datetime64 day values, and you want a count of how many of them are valid dates, you can do this:</source>
          <target state="translated">Если у вас есть массив значений datetime64 day,и вы хотите посчитать,сколько из них действительных дат,то вы можете это сделать:</target>
        </trans-unit>
        <trans-unit id="afdea327e298d690859d2830125b0506072aa9c8" translate="yes" xml:space="preserve">
          <source>If you have made changes to files that have changed also upstream, this may generate merge conflicts that you need to resolve. See &lt;a href=&quot;#recovering-from-mess-up&quot;&gt;below&lt;/a&gt; for help in this case.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3940d12fada6e74d3a4f390741c7084734cc9f7c" translate="yes" xml:space="preserve">
          <source>If you have worked before with only one- or two-dimensional arrays in NumPy, you might use &lt;a href=&quot;../reference/generated/numpy.dot#numpy.dot&quot;&gt;&lt;code&gt;numpy.dot&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../reference/generated/numpy.matmul#numpy.matmul&quot;&gt;&lt;code&gt;numpy.matmul&lt;/code&gt;&lt;/a&gt; (or the &lt;code&gt;@&lt;/code&gt; operator) interchangeably. However, for n-dimensional arrays, they work in very different ways. For more details, check the documentation &lt;a href=&quot;../reference/generated/numpy.matmul#numpy.matmul&quot;&gt;&lt;code&gt;numpy.matmul&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="61245264d3565a00eccec23e4c121348aa40e38c" translate="yes" xml:space="preserve">
          <source>If you index &lt;code&gt;x&lt;/code&gt; at position 1 you get a structure:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="19e171dd0ccd0c17916e231c961dda814be7cba5" translate="yes" xml:space="preserve">
          <source>If you just use Cython to compile a standard Python module, then you will get a C extension module that typically runs a bit faster than the equivalent Python module. Further speed increases can be gained by using the &lt;code&gt;cdef&lt;/code&gt; keyword to statically define C variables.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0c28db0c64cef3fce82c680e83d5a3bf5a7d6611" translate="yes" xml:space="preserve">
          <source>If you know you have boolean arguments, you can get away with using NumPy&amp;rsquo;s bitwise operators, but be careful with parentheses, like this: z = (x &amp;gt; 1) &amp;amp; (x &amp;lt; 2). The absence of NumPy operator forms of logical_and and logical_or is an unfortunate consequence of Python&amp;rsquo;s design.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b50bdabfd893e921c2545949ea3927871fd9123c" translate="yes" xml:space="preserve">
          <source>If you mess up during a rebase:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d5b391b72fd29e26b5330f8bc73fd6e0406a58fe" translate="yes" xml:space="preserve">
          <source>If you need a stricter way to identify a &lt;em&gt;numerical&lt;/em&gt; scalar, use &lt;code&gt;isinstance(x, numbers.Number)&lt;/code&gt;, as that returns &lt;code&gt;False&lt;/code&gt; for most non-numerical elements such as strings.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6b620559920ae0493b1df8c4590d21b79ff5570f" translate="yes" xml:space="preserve">
          <source>If you need to generate a good seed &amp;ldquo;offline&amp;rdquo;, then &lt;code&gt;SeedSequence().entropy&lt;/code&gt; or using &lt;code&gt;secrets.randbits(128)&lt;/code&gt; from the standard library are both convenient ways.</source>
          <target state="translated">Если вам нужно сгенерировать хорошее начальное число &amp;laquo;в автономном режиме&amp;raquo;, то &lt;code&gt;SeedSequence().entropy&lt;/code&gt; &lt;code&gt;secrets.randbits(128)&lt;/code&gt; или secrets.randbits (128) из стандартной библиотеки.</target>
        </trans-unit>
        <trans-unit id="9dadc35707bb7693c411ca705b6a79a8fd4bc6a1" translate="yes" xml:space="preserve">
          <source>If you need to generate a plot for your values, it&amp;rsquo;s very simple with &lt;a href=&quot;https://matplotlib.org/&quot;&gt;Matplotlib&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cd4f29a22f2d83f814cd7d3d9fed381be8da6e41" translate="yes" xml:space="preserve">
          <source>If you notice you messed up after the rebase:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ee201455e7a9931a5a44547dd0593d53785f3676" translate="yes" xml:space="preserve">
          <source>If you obtained NumPy via git, get also the git submodules that contain additional parts required for building the documentation:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fafc92af92f970e1f9bc871b99562e2a4dcbfd58" translate="yes" xml:space="preserve">
          <source>If you only had $150/month to pay towards the loan, how long would it take to pay-off a loan of $8,000 at 7% annual interest?</source>
          <target state="translated">Если бы у вас было только 150 долларов в месяц на погашение кредита,сколько бы времени потребовалось на погашение кредита в размере 8000 долларов под 7% годовых?</target>
        </trans-unit>
        <trans-unit id="f1851d09e17596b6fef1418fbf6cd4eb3f3c1218" translate="yes" xml:space="preserve">
          <source>If you only want to get the documentation, note that pre-built versions can be found at</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4ba77d4ac4c0346cf08567fdade124408903e3ad" translate="yes" xml:space="preserve">
          <source>If you prefer, you can use your own image as you work through this tutorial. In order to transform your image into a NumPy array that can be manipulated, you can use the &lt;code&gt;imread&lt;/code&gt; function from the &lt;a href=&quot;https://matplotlib.org/api/_as_gen/matplotlib.pyplot.html#module-matplotlib.pyplot&quot;&gt;&lt;code&gt;matplotlib.pyplot&lt;/code&gt;&lt;/a&gt; submodule. Alternatively, you can use the &lt;a href=&quot;https://imageio.readthedocs.io/en/stable/userapi.html#imageio.imread&quot;&gt;&lt;code&gt;imageio.imread&lt;/code&gt;&lt;/a&gt; function from the &lt;code&gt;imageio&lt;/code&gt; library. Be aware that if you use your own image, you&amp;rsquo;ll likely need to adapt the steps below. For more information on how images are treated when converted to NumPy arrays, see &lt;a href=&quot;https://scikit-image.org/docs/stable/user_guide/numpy_images.html&quot;&gt;A crash course on NumPy for images&lt;/a&gt; from the &lt;code&gt;scikit-image&lt;/code&gt; documentation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="163df9c9003b7c4450bb235f2c67b2a07c0207a6" translate="yes" xml:space="preserve">
          <source>If you run &lt;code&gt;f2py&lt;/code&gt; with no arguments, and the line &lt;code&gt;numpy Version&lt;/code&gt; at the end matches the NumPy version printed from &lt;code&gt;python -m numpy.f2py&lt;/code&gt;, then you can use the shorter version. If not, or if you cannot run &lt;code&gt;f2py&lt;/code&gt;, you should replace all calls to &lt;code&gt;f2py&lt;/code&gt; here with the longer version.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c2f8a5ed085feb6d7cb818c6bb6a9239c65b61dd" translate="yes" xml:space="preserve">
          <source>If you run into a situation where a function or method is returning a pointer to an array, your best bet is to write your own version of the function to be wrapped, either with &lt;code&gt;%extend&lt;/code&gt; for the case of class methods or &lt;code&gt;%ignore&lt;/code&gt; and &lt;code&gt;%rename&lt;/code&gt; for the case of functions.</source>
          <target state="translated">Если вы столкнулись с ситуацией, когда функция или метод возвращает указатель на массив, лучше всего написать свою собственную версию функции, которая должна быть обернута, либо с &lt;code&gt;%extend&lt;/code&gt; для метода класса, либо с &lt;code&gt;%ignore&lt;/code&gt; и &lt;code&gt;%rename&lt;/code&gt; для случая функций.</target>
        </trans-unit>
        <trans-unit id="2a7a60ee3a192da84e7197524a79fee3ab370312" translate="yes" xml:space="preserve">
          <source>If you see a good tutorial, how-to or explanation that is not included in the official documentation, you can suggest it to be added by &lt;a href=&quot;https://github.com/numpy/numpy/issues&quot;&gt;opening an issue on GitHub&lt;/a&gt;. Similarly, opening issues to suggest a tutorial, how-to or explanation that you can&amp;rsquo;t find anywhere is a great way to help the documentation team direct efforts towards what users are looking for. &lt;a href=&quot;https://github.com/numpy/numpy/issues/15760&quot;&gt;See this issue&lt;/a&gt; for an example of how to do this.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c084a3f2a6106a54039205662cc0565194fa0738" translate="yes" xml:space="preserve">
          <source>If you specify an &lt;code&gt;n&lt;/code&gt; such that &lt;code&gt;a&lt;/code&gt; must be zero-padded or truncated, the extra/removed values will be added/removed at high frequencies. One can thus resample a series to &lt;code&gt;m&lt;/code&gt; points via Fourier interpolation by: &lt;code&gt;a_resamp = irfft(rfft(a), m)&lt;/code&gt;.</source>
          <target state="translated">Если вы укажете &lt;code&gt;n&lt;/code&gt; так , что &lt;code&gt;a&lt;/code&gt; должно быть дополнено нулями или усечено, дополнительные / удаленные значения будут добавляться / удаляться с высокой частотой. Таким образом, можно передискретизировать ряд до &lt;code&gt;m&lt;/code&gt; точек с помощью интерполяции Фурье следующим образом: &lt;code&gt;a_resamp = irfft(rfft(a), m)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="dd256004a74583cc184f8439d5d048c30d412fb7" translate="yes" xml:space="preserve">
          <source>If you start with these arrays:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b2448ad4b64da661ec458b63dd3b9923ea02aca5" translate="yes" xml:space="preserve">
          <source>If you start with this array:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="777d1be2db0dc4450d7b4eef96ddf2f8d5888d83" translate="yes" xml:space="preserve">
          <source>If you subclass &lt;a href=&quot;generated/numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;ndarray&lt;/code&gt;&lt;/a&gt;, we recommend that you put all your override logic in &lt;code&gt;__array_ufunc__&lt;/code&gt; and not also override special methods. This ensures the class hierarchy is determined in only one place rather than separately by the ufunc machinery and by the binary operation rules (which gives preference to special methods of subclasses; the alternative way to enforce a one-place only hierarchy, of setting &lt;a href=&quot;#numpy.class.__array_ufunc__&quot;&gt;&lt;code&gt;__array_ufunc__&lt;/code&gt;&lt;/a&gt; to &lt;a href=&quot;https://docs.python.org/dev/library/constants.html#None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt;, would seem very unexpected and thus confusing, as then the subclass would not work at all with ufuncs).</source>
          <target state="translated">Если вы &lt;a href=&quot;generated/numpy.ndarray#numpy.ndarray&quot;&gt; &lt;code&gt;ndarray&lt;/code&gt; &lt;/a&gt; подкласс ndarray , мы рекомендуем вам поместить всю вашу логику переопределения в &lt;code&gt;__array_ufunc__&lt;/code&gt; , а также не переопределять специальные методы. Это гарантирует, что иерархия классов определяется только в одном месте, а не по отдельности механизмом ufunc и правилами бинарных операций (которые отдают предпочтение специальным методам подклассов; альтернативный способ принудительного применения иерархии только в одном месте, установка &lt;a href=&quot;#numpy.class.__array_ufunc__&quot;&gt; &lt;code&gt;__array_ufunc__&lt;/code&gt; &lt;/a&gt; на &lt;a href=&quot;https://docs.python.org/dev/library/constants.html#None&quot;&gt; &lt;code&gt;None&lt;/code&gt; &lt;/a&gt; , это могло бы показаться очень неожиданным и, таким образом, сбивающим с толку, поскольку тогда подкласс вообще не работал бы с ufuncs).</target>
        </trans-unit>
        <trans-unit id="2b988c177dc2b27c86ba6dc5904e8834a5cbf804" translate="yes" xml:space="preserve">
          <source>If you subclass &lt;a href=&quot;generated/numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;ndarray&lt;/code&gt;&lt;/a&gt;, we recommend that you put all your override logic in &lt;code&gt;__array_ufunc__&lt;/code&gt; and not also override special methods. This ensures the class hierarchy is determined in only one place rather than separately by the ufunc machinery and by the binary operation rules (which gives preference to special methods of subclasses; the alternative way to enforce a one-place only hierarchy, of setting &lt;a href=&quot;#numpy.class.__array_ufunc__&quot;&gt;&lt;code&gt;__array_ufunc__&lt;/code&gt;&lt;/a&gt; to None, would seem very unexpected and thus confusing, as then the subclass would not work at all with ufuncs).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="68630e24ebcf26648c6330182b68ffff11c7fe21" translate="yes" xml:space="preserve">
          <source>If you want to allow your new data-type to also be able to share in the scalar coercion rules, then you need to specify the scalarkind function in the data-type object&amp;rsquo;s &amp;ldquo;.f&amp;rdquo; member to return the kind of scalar the new data-type should be seen as (the value of the scalar is available to that function). Then, you can register data-types that can be cast to separately for each scalar kind that may be returned from your user-defined data-type. If you don&amp;rsquo;t register scalar coercion handling, then all of your user-defined data-types will be seen as &lt;a href=&quot;../reference/c-api/array#c.NPY_NOSCALAR&quot;&gt;&lt;code&gt;NPY_NOSCALAR&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b381b011cdbc746e6a1a9147256650f6139d3056" translate="yes" xml:space="preserve">
          <source>If you want to be able to run the examples in this tutorial, you should also have &lt;a href=&quot;https://matplotlib.org/&quot;&gt;matplotlib&lt;/a&gt; and &lt;a href=&quot;https://scipy.org&quot;&gt;SciPy&lt;/a&gt; installed on your computer.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2bd528b5e948a367e7029016eb9b4a7e59a0c3cc" translate="yes" xml:space="preserve">
          <source>If you want to check your array, you can run::</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="239d78c449f1143da9fe3cab0308bfd5b8c57120" translate="yes" xml:space="preserve">
          <source>If you want to distribute your f2py extension module, then you only need to include the .pyf file and the Fortran code. The distutils extensions in NumPy allow you to define an extension module entirely in terms of this interface file. A valid &lt;code&gt;setup.py&lt;/code&gt; file allowing distribution of the &lt;code&gt;add.f&lt;/code&gt; module (as part of the package &lt;code&gt;f2py_examples&lt;/code&gt; so that it would be loaded as &lt;code&gt;f2py_examples.add&lt;/code&gt;) is:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="205839ed0e5eb197529b1363e1bb132c099c8dee" translate="yes" xml:space="preserve">
          <source>If you want to edit an array with aligned &lt;code&gt;double&lt;/code&gt; code, but the order doesn&amp;rsquo;t matter, you would use this.</source>
          <target state="translated">Если вы хотите отредактировать массив с выровненным &lt;code&gt;double&lt;/code&gt; кодом, но порядок не имеет значения, вы должны использовать это.</target>
        </trans-unit>
        <trans-unit id="354259176d8d4848edf2f2ea177ee9321090388c" translate="yes" xml:space="preserve">
          <source>If you want to generate a list of coordinates where the elements exist, you can zip the arrays, iterate over the list of coordinates, and print them. For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="09988ae17a5580ba08c41432cf193fcdceccc334" translate="yes" xml:space="preserve">
          <source>If you want to get the unique rows or columns, make sure to pass the &lt;code&gt;axis&lt;/code&gt; argument. To find the unique rows, specify &lt;code&gt;axis=0&lt;/code&gt; and for columns, specify &lt;code&gt;axis=1&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a706c6c7d842fe3c84f0f98172224bf53de48486" translate="yes" xml:space="preserve">
          <source>If you want to learn more about C and Fortran order, you can &lt;a href=&quot;../reference/internals#numpy-internals&quot;&gt;read more about the internal organization of NumPy arrays here&lt;/a&gt;. Essentially, C and Fortran orders have to do with how indices correspond to the order the array is stored in memory. In Fortran, when moving through the elements of a two-dimensional array as it is stored in memory, the &lt;strong&gt;first&lt;/strong&gt; index is the most rapidly varying index. As the first index moves to the next row as it changes, the matrix is stored one column at a time. This is why Fortran is thought of as a &lt;strong&gt;Column-major language&lt;/strong&gt;. In C on the other hand, the &lt;strong&gt;last&lt;/strong&gt; index changes the most rapidly. The matrix is stored by rows, making it a &lt;strong&gt;Row-major language&lt;/strong&gt;. What you do for C or Fortran depends on whether it&amp;rsquo;s more important to preserve the indexing convention or not reorder the data.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="90eb7317f80793824fd5ca68d969b076155c2b6b" translate="yes" xml:space="preserve">
          <source>If you want to make use of these extensions in third-party projects, they are available on &lt;a href=&quot;https://pypi.org/&quot;&gt;PyPi&lt;/a&gt; as the &lt;a href=&quot;https://python.org/pypi/numpydoc&quot;&gt;numpydoc&lt;/a&gt; package.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ce326a8e1b86089803e6e52c507c14343be2d322" translate="yes" xml:space="preserve">
          <source>If you want to print your reversed array, you can run:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0c1156594a53dfa7f56ad636c35e9f1ff1d1bf58" translate="yes" xml:space="preserve">
          <source>If you want to reset both the &lt;code&gt;iterindex&lt;/code&gt; range and the base pointers at the same time, you can do the following to avoid extra buffer copying (be sure to add the return code error checks when you copy this code).</source>
          <target state="translated">Если вы хотите сбросить и диапазон &lt;code&gt;iterindex&lt;/code&gt; , и базовые указатели одновременно, вы можете сделать следующее, чтобы избежать дополнительного копирования буфера (не забудьте добавить проверки ошибок кода возврата при копировании этого кода).</target>
        </trans-unit>
        <trans-unit id="64b7d79c9f444db203d014596ebfe464ce993392" translate="yes" xml:space="preserve">
          <source>If you want to select values from your array that fulfill certain conditions, it&amp;rsquo;s straightforward with NumPy.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="37f52b8408b71a5a1ecc2762c718ea9d22604602" translate="yes" xml:space="preserve">
          <source>If you want to store a single ndarray object, store it as a .npy file using &lt;code&gt;np.save&lt;/code&gt;. If you want to store more than one ndarray object in a single file, save it as a .npz file using &lt;code&gt;np.savez&lt;/code&gt;. You can also save several arrays into a single file in compressed npz format with &lt;a href=&quot;../reference/generated/numpy.savez_compressed#numpy.savez_compressed&quot;&gt;&lt;code&gt;savez_compressed&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="88094cb7e9cc7094508fd58f64e280384e2b183f" translate="yes" xml:space="preserve">
          <source>If you want to work on some stuff with other people, where you are all committing into the same repository, or even the same branch, then just share it via &lt;a href=&quot;https://github.com/numpy/numpy&quot;&gt;github&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3d8a79d78dafc5ad7f75ccfea604d3c282656ec2" translate="yes" xml:space="preserve">
          <source>If you wanted to split this array into three equally shaped arrays, you would run:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fe157cf65afca39aaf28e7392b7bcce12c2fa490" translate="yes" xml:space="preserve">
          <source>If you wanted to split your array after the third and fourth column, you&amp;rsquo;d run:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f154266a0558b92de5f9f6ffafaf54fec025441e" translate="yes" xml:space="preserve">
          <source>If you wish to build against OpenBLAS but you also have BLIS available one may predefine the order of searching via the environment variable &lt;code&gt;NPY_BLAS_ORDER&lt;/code&gt; which is a comma-separated list of the above names which is used to determine what to search for, for instance:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="591a2b4b56f13d91fd0f488df05b473dc7163812" translate="yes" xml:space="preserve">
          <source>If you wish to build against OpenBLAS but you also have MKL available one may predefine the order of searching via the environment variable &lt;code&gt;NPY_LAPACK_ORDER&lt;/code&gt; which is a comma-separated list of the above names, for instance:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="05bc8da7a227df06fa8b2e6100a971876a03d9e2" translate="yes" xml:space="preserve">
          <source>If you wish to maintain compatibility with numpy and its subsequent versions (which might add new keyword arguments) but do not want to surface all of numpy&amp;rsquo;s arguments, your function&amp;rsquo;s signature should accept &lt;code&gt;**kwargs&lt;/code&gt;. For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="97b99e9167303c0b41027781a2b137980415f644" translate="yes" xml:space="preserve">
          <source>If you wish to work the examples in this tutorial, you must also have some software installed on your computer. Please see &lt;a href=&quot;https://scipy.org/install.html&quot;&gt;https://scipy.org/install.html&lt;/a&gt; for instructions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7557e5e98e1d6b39d314fab8f9700d862099c3ca" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;re interested in learning more about Pandas, take a look at the &lt;a href=&quot;https://pandas.pydata.org/index.html&quot;&gt;official Pandas documentation&lt;/a&gt;. Learn how to install Pandas with the &lt;a href=&quot;https://pandas.pydata.org/pandas-docs/stable/install.html&quot;&gt;official Pandas installation information&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2ed6aac4fbb9a95f912d9c4a1bba39294044ad2e" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;re reading this page, you probably want to help. This guide is meant to help you decide which kind of content you&amp;rsquo;ll write, as well as give you some tips and instructions for submitting it to the official NumPy documentation (that is, the documentation that ships with NumPy and lives on the &lt;a href=&quot;../contents#numpy-docs-mainpage&quot;&gt;official project pages&lt;/a&gt;). Keep in mind that if you don&amp;rsquo;t want to do this, writing a tutorial on your own blog, creating a YouTube video or answering questions on social media or Stack Overflow are also great contributions!</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fc7594579a51a68345b4192c0906de63f2aaa750" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;re using the command line, you can read your saved CSV any time with a command such as:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bb1dc4c88210c13fc91fb612afbe4d0471d01d47" translate="yes" xml:space="preserve">
          <source>If your change introduces a deprecation, make sure to discuss this first on GitHub or the mailing list first. If agreement on the deprecation is reached, follow &lt;a href=&quot;http://www.numpy.org/neps/nep-0023-backwards-compatibility.html&quot;&gt;NEP 23 deprecation policy&lt;/a&gt; to add the deprecation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="383746919525c98ba38f05552e38f10fc7e17a76" translate="yes" xml:space="preserve">
          <source>If your changes involve modifications to the API or addition/modification of a function, you should</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d57214d0288965780d58c7b4b54223afc06a658d" translate="yes" xml:space="preserve">
          <source>If your commit introduces a new feature or changes functionality, post on the &lt;a href=&quot;https://mail.python.org/mailman/listinfo/numpy-devel&quot;&gt;mailing list&lt;/a&gt; to explain your changes. For bug fixes, documentation updates, etc., this is generally not necessary, though if you do not get any reaction, do feel free to ask for review.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ceebca4c980fce897cd94c7ea4093efdb4e34dd2" translate="yes" xml:space="preserve">
          <source>If your goal is to print such values with a fixed number of decimals, it is preferable to use numpy&amp;rsquo;s float printing routines to limit the number of printed decimals:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5e8a3ab9024a9447fbb66b46a34249a781d9bca6" translate="yes" xml:space="preserve">
          <source>If your report involves any members of the committee, or if they feel they have a conflict of interest in handling it, then they will recuse themselves from considering your report. Alternatively, if for any reason you feel uncomfortable making a report to the committee, then you can also contact:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3b1e83353521c6fb2d9909d1a47041f20fbc218d" translate="yes" xml:space="preserve">
          <source>If, however, you decide to deviate from this signature and do something like this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c323f3cd6a35ba341fff7e94a4d83cd135d073a2" translate="yes" xml:space="preserve">
          <source>Ignoring extreme values</source>
          <target state="translated">Игнорирование экстремальных значений</target>
        </trans-unit>
        <trans-unit id="d887ce439b6be40447269f7cc275bae88c7965c1" translate="yes" xml:space="preserve">
          <source>Illustration image: &lt;a href=&quot;https://en.wikipedia.org/wiki/File:Composite_trapezoidal_rule_illustration.png&quot;&gt;https://en.wikipedia.org/wiki/File:Composite_trapezoidal_rule_illustration.png&lt;/a&gt;</source>
          <target state="translated">Изображение иллюстрации: &lt;a href=&quot;https://en.wikipedia.org/wiki/File:Composite_trapezoidal_rule_illustration.png&quot;&gt;https://en.wikipedia.org/wiki/File:Composite_trapezoidal_rule_illustration.png&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="8dc5a9232d67823e896b05855151653c2378fa30" translate="yes" xml:space="preserve">
          <source>Illustration, using the fact that the eigenvalues of a diagonal matrix are its diagonal elements, that multiplying a matrix on the left by an orthogonal matrix, &lt;code&gt;Q&lt;/code&gt;, and on the right by &lt;code&gt;Q.T&lt;/code&gt; (the transpose of &lt;code&gt;Q&lt;/code&gt;), preserves the eigenvalues of the &amp;ldquo;middle&amp;rdquo; matrix. In other words, if &lt;code&gt;Q&lt;/code&gt; is orthogonal, then &lt;code&gt;Q * A * Q.T&lt;/code&gt; has the same eigenvalues as &lt;code&gt;A&lt;/code&gt;:</source>
          <target state="translated">Иллюстрация, использующая тот факт, что собственные значения диагональной матрицы являются ее диагональными элементами, что умножение матрицы слева на ортогональную матрицу &lt;code&gt;Q&lt;/code&gt; и справа на &lt;code&gt;Q.T&lt;/code&gt; (транспонирование &lt;code&gt;Q&lt;/code&gt; ) сохраняет собственные значения матрицы &amp;ldquo; средняя &amp;raquo;матрица. Другими словами, если &lt;code&gt;Q&lt;/code&gt; ортогонален, то &lt;code&gt;Q * A * Q.T&lt;/code&gt; имеет те же собственные значения, что и &lt;code&gt;A&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="aa91fcf02d0f861f5dcc65de755f413adabac4c5" translate="yes" xml:space="preserve">
          <source>Illustration:</source>
          <target state="translated">Illustration:</target>
        </trans-unit>
        <trans-unit id="50e19fda0d5b4b74a4a1a1d584e56578693a4ea4" translate="yes" xml:space="preserve">
          <source>Image</source>
          <target state="translated">Image</target>
        </trans-unit>
        <trans-unit id="536fc5481730660eaf684050e171a85c03ce521a" translate="yes" xml:space="preserve">
          <source>Image &lt;a href=&quot;#r7aa6c77779c0-2&quot; id=&quot;id1&quot;&gt;[2]&lt;/a&gt; illustrates trapezoidal rule &amp;ndash; y-axis locations of points will be taken from &lt;code&gt;y&lt;/code&gt; array, by default x-axis distances between points will be 1.0, alternatively they can be provided with &lt;code&gt;x&lt;/code&gt; array or with &lt;code&gt;dx&lt;/code&gt; scalar. Return value will be equal to combined area under the red lines.</source>
          <target state="translated">Изображение &lt;a href=&quot;#r7aa6c77779c0-2&quot; id=&quot;id1&quot;&gt;[2]&lt;/a&gt; иллюстрирует правило трапеции - положения точек по оси Y будут взяты из массива &lt;code&gt;y&lt;/code&gt; , по умолчанию расстояния между точками по оси X будут равны 1.0, в качестве альтернативы они могут быть предоставлены с помощью массива &lt;code&gt;x&lt;/code&gt; или скаляра &lt;code&gt;dx&lt;/code&gt; . Возвращаемое значение будет равно объединенной области под красными линиями.</target>
        </trans-unit>
        <trans-unit id="a9fdbeb05caca869c7ab036893a4d3951315842f" translate="yes" xml:space="preserve">
          <source>Image filter in Cython</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9e3e609852befab966299ce3a62b4f677877a107" translate="yes" xml:space="preserve">
          <source>Images are allowed, but should not be central to the explanation; users viewing the docstring as text must be able to comprehend its meaning without resorting to an image viewer. These additional illustrations are included using:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4796b475dca83b62f81a07c968464a3ec0ce36b3" translate="yes" xml:space="preserve">
          <source>Imagine a series of commits A, B, C, D&amp;hellip; Imagine that there are two branches, &lt;em&gt;topic&lt;/em&gt; and &lt;em&gt;master&lt;/em&gt;. You branched &lt;em&gt;topic&lt;/em&gt; off &lt;em&gt;master&lt;/em&gt; when &lt;em&gt;master&lt;/em&gt; was at commit &amp;lsquo;E&amp;rsquo;. The graph of the commits looks like this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9d1a70afdce8219e6a6ff23faf95244260258e23" translate="yes" xml:space="preserve">
          <source>Imagine an array of 32-bit integers (each 4 bytes):</source>
          <target state="translated">Представьте себе массив из 32-битных целых чисел (каждый 4 байта):</target>
        </trans-unit>
        <trans-unit id="56024d919b5d6ee0185b1f966812231e966a9f22" translate="yes" xml:space="preserve">
          <source>Immediately disconnect the originator from all NumPy communication channels.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="81ebe12aa11cc123fdb7f8c88133ffaff6347b23" translate="yes" xml:space="preserve">
          <source>Implementation details</source>
          <target state="translated">Детали внедрения</target>
        </trans-unit>
        <trans-unit id="c12c46e2305d0716b258ac51f2e79f55da8c1069" translate="yes" xml:space="preserve">
          <source>Implementations of &lt;code&gt;__array_function__&lt;/code&gt; indicate that they can handle the operation by returning any value other than &lt;code&gt;NotImplemented&lt;/code&gt;.</source>
          <target state="translated">Реализации &lt;code&gt;__array_function__&lt;/code&gt; указывают, что они могут обрабатывать операцию, возвращая любое значение, кроме &lt;code&gt;NotImplemented&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="45682c285dcaa4b3e31e357f40fa088a415ce505" translate="yes" xml:space="preserve">
          <source>Implementing this formula is simple and straightforward in NumPy:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0e028e89dfea3c1cba7d9fc7a23453fc7abac732" translate="yes" xml:space="preserve">
          <source>Implements exec_command function that is (almost) equivalent to commands.getstatusoutput function but on NT, DOS systems the returned status is actually correct (though, the returned status values may be different by a factor). In addition, exec_command takes keyword arguments for (re-)defining environment variables.</source>
          <target state="translated">Вводит функцию exec_command,которая (почти)эквивалентна выходной функции commands.gettatusoutput,но в системах NT,DOS,возвращаемый статус на самом деле корректен (хотя,возвращаемые значения статусов могут быть разными в разное время).Кроме того,команда exec_command принимает аргументы по ключевым словам для (повторного)определения переменных окружения.</target>
        </trans-unit>
        <trans-unit id="b794a9ed38f8d441574ce1ea158c0a341f3db730" translate="yes" xml:space="preserve">
          <source>Implements the complex comparisons between two complex numbers (structures with a real and imag member) using NumPy&amp;rsquo;s definition of the ordering which is lexicographic: comparing the real parts first and then the complex parts if the real parts are equal.</source>
          <target state="translated">Реализует сложные сравнения между двумя комплексными числами (структурами с действительным и воображаемым членами), используя определение порядка в NumPy, которое является лексикографическим: сначала сравнение реальных частей, а затем сложных частей, если реальные части равны.</target>
        </trans-unit>
        <trans-unit id="8c1ede9f9fcf093439f0e008232b895dda53883b" translate="yes" xml:space="preserve">
          <source>Implements the rules for scalar coercion. Scalars are only silently coerced from thistype to neededtype if this function returns nonzero. If scalar is &lt;a href=&quot;#c.NPY_NOSCALAR&quot;&gt;&lt;code&gt;NPY_NOSCALAR&lt;/code&gt;&lt;/a&gt;, then this function is equivalent to &lt;a href=&quot;#c.PyArray_CanCastSafely&quot;&gt;&lt;code&gt;PyArray_CanCastSafely&lt;/code&gt;&lt;/a&gt;. The rule is that scalars of the same KIND can be coerced into arrays of the same KIND. This rule means that high-precision scalars will never cause low-precision arrays of the same KIND to be upcast.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="22af89867a4595ad888fcb4ec7aff9a5775524c5" translate="yes" xml:space="preserve">
          <source>Implements the rules for scalar coercion. Scalars are only silently coerced from thistype to neededtype if this function returns nonzero. If scalar is &lt;code&gt;NPY_NOSCALAR&lt;/code&gt;, then this function is equivalent to &lt;a href=&quot;#c.PyArray_CanCastSafely&quot;&gt;&lt;code&gt;PyArray_CanCastSafely&lt;/code&gt;&lt;/a&gt;. The rule is that scalars of the same KIND can be coerced into arrays of the same KIND. This rule means that high-precision scalars will never cause low-precision arrays of the same KIND to be upcast.</source>
          <target state="translated">Реализует правила скалярного принуждения. Скаляры автоматически переводятся от этого типа к нужному типу, только если эта функция возвращает ненулевое значение. Если скаляр равен &lt;code&gt;NPY_NOSCALAR&lt;/code&gt; , эта функция эквивалентна &lt;a href=&quot;#c.PyArray_CanCastSafely&quot;&gt; &lt;code&gt;PyArray_CanCastSafely&lt;/code&gt; &lt;/a&gt; . Правило состоит в том, что скаляры одного и того же типа могут быть преобразованы в массивы одного и того же типа. Это правило означает, что скаляры высокой точности никогда не приведут к преобразованию массивов низкой точности одного и того же ВИДА.</target>
        </trans-unit>
        <trans-unit id="cc6b2c01f5b15596a7e379b52c69cde1905611b5" translate="yes" xml:space="preserve">
          <source>Implications for subclassing</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9b1ecf27a94cea1bc5736c0891a645368078e452" translate="yes" xml:space="preserve">
          <source>Implicit rules are used to determine the type specification of a variable (from the first-letter of its name) if the variable is not defined using &lt;code&gt;&amp;lt;variable type declaration&amp;gt;&lt;/code&gt;. Default implicit rule is given by</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0951af8ad6c339672abaff4e57cd5d78b54b3d59" translate="yes" xml:space="preserve">
          <source>Import conventions</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="361838ee748707501d1086cda1d546a0bca541ea" translate="yes" xml:space="preserve">
          <source>ImportError</source>
          <target state="translated">ImportError</target>
        </trans-unit>
        <trans-unit id="2fdd9172a8740a8589e6db75bd8b770e98070548" translate="yes" xml:space="preserve">
          <source>Importing and exporting a CSV</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a0b02515f5c051785b53791b2ce9293238d373b1" translate="yes" xml:space="preserve">
          <source>Importing data with &lt;code&gt;genfromtxt&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5ce37d23b2e6f8bbdca3d0d3d416305b155ec2af" translate="yes" xml:space="preserve">
          <source>Importing data with genfromtxt</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c27d990de6ba5889ef7140c6c7a668ba89dfd7cb" translate="yes" xml:space="preserve">
          <source>Importing the API</source>
          <target state="translated">Импорт API</target>
        </trans-unit>
        <trans-unit id="dd37ac12c1ad8599b8ebf308693dc3e055ea4be3" translate="yes" xml:space="preserve">
          <source>Improve detection of CPU features</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3cf92b1447d3f56d21aa04032c4a2bb6319ee3e3" translate="yes" xml:space="preserve">
          <source>Improve performance of &lt;code&gt;numpy.pad&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fc1f2a7f430fee41352adede4b4563f47e652af5" translate="yes" xml:space="preserve">
          <source>Improved automated bin estimators for &lt;code&gt;histogram&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c1f0700651c0f4723ea34b9b380874940d8f5904" translate="yes" xml:space="preserve">
          <source>Improved conversion from ctypes objects</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="518dff1009456384a218feffc1efa6923feaa474" translate="yes" xml:space="preserve">
          <source>Improved handling of zero-width string/unicode dtypes</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="58ab9853fb47f5464aeb249a62f870635c06737e" translate="yes" xml:space="preserve">
          <source>Improved precision of &lt;code&gt;ndarray.mean&lt;/code&gt; for float16 arrays</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="38934ca4956698ef07754fc3267371731cc1f9a9" translate="yes" xml:space="preserve">
          <source>Improved set operations</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="df66ef4f9fec541e48971fe99984a92ee3d241bf" translate="yes" xml:space="preserve">
          <source>Improvements</source>
          <target state="translated">Improvements</target>
        </trans-unit>
        <trans-unit id="75cb8c222cfbf4c46e4378aa465749528ac0f696" translate="yes" xml:space="preserve">
          <source>Improvements to build warnings</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="21535b2ca395b919fe7ab1e068c3e3d0e600eb23" translate="yes" xml:space="preserve">
          <source>Improving the basic interface</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="651ad1981d9513aaa48106696e9dc28fdbdbb95a" translate="yes" xml:space="preserve">
          <source>In &amp;lsquo;clip&amp;rsquo; mode, a negative index which would normally wrap will clip to 0 instead.</source>
          <target state="translated">В режиме &amp;laquo;клипа&amp;raquo; отрицательный индекс, который обычно переносится, вместо этого обрезается до 0.</target>
        </trans-unit>
        <trans-unit id="0a5b493d076f809b633ada78947b9be3536bf476" translate="yes" xml:space="preserve">
          <source>In 1.16 a number of functions have been introduced in the &lt;a href=&quot;#module-numpy.lib.recfunctions&quot;&gt;&lt;code&gt;numpy.lib.recfunctions&lt;/code&gt;&lt;/a&gt; module to help users account for this change. These are &lt;a href=&quot;#numpy.lib.recfunctions.repack_fields&quot;&gt;&lt;code&gt;numpy.lib.recfunctions.repack_fields&lt;/code&gt;&lt;/a&gt;. &lt;a href=&quot;#numpy.lib.recfunctions.structured_to_unstructured&quot;&gt;&lt;code&gt;numpy.lib.recfunctions.structured_to_unstructured&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#numpy.lib.recfunctions.unstructured_to_structured&quot;&gt;&lt;code&gt;numpy.lib.recfunctions.unstructured_to_structured&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#numpy.lib.recfunctions.apply_along_fields&quot;&gt;&lt;code&gt;numpy.lib.recfunctions.apply_along_fields&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#numpy.lib.recfunctions.assign_fields_by_name&quot;&gt;&lt;code&gt;numpy.lib.recfunctions.assign_fields_by_name&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;#numpy.lib.recfunctions.require_fields&quot;&gt;&lt;code&gt;numpy.lib.recfunctions.require_fields&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2fa6844c3d81a6fe2067c8e0e928cef4f2f272dc" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;range(6)&lt;/code&gt;, information on what kind of rounding is done in addition, and on how underflow is handled.</source>
          <target state="translated">В &lt;code&gt;range(6)&lt;/code&gt; - информация о том, какое округление выполняется дополнительно, и о том, как обрабатывается потеря значимости.</target>
        </trans-unit>
        <trans-unit id="50fbd12243b4769e24084faa8adf2287f6b3d6cd" translate="yes" xml:space="preserve">
          <source>In &lt;em&gt;explicit mode&lt;/em&gt; the output can be directly controlled by specifying output subscript labels. This requires the identifier &amp;lsquo;-&amp;gt;&amp;rsquo; as well as the list of output subscript labels. This feature increases the flexibility of the function since summing can be disabled or forced when required. The call &lt;code&gt;np.einsum('i-&amp;gt;', a)&lt;/code&gt; is like &lt;a href=&quot;numpy.sum#numpy.sum&quot;&gt;&lt;code&gt;np.sum(a, axis=-1)&lt;/code&gt;&lt;/a&gt;, and &lt;code&gt;np.einsum('ii-&amp;gt;i', a)&lt;/code&gt; is like &lt;a href=&quot;numpy.diag#numpy.diag&quot;&gt;&lt;code&gt;np.diag(a)&lt;/code&gt;&lt;/a&gt;. The difference is that &lt;a href=&quot;#numpy.einsum&quot;&gt;&lt;code&gt;einsum&lt;/code&gt;&lt;/a&gt; does not allow broadcasting by default. Additionally &lt;code&gt;np.einsum('ij,jh-&amp;gt;ih', a, b)&lt;/code&gt; directly specifies the order of the output subscript labels and therefore returns matrix multiplication, unlike the example above in implicit mode.</source>
          <target state="translated">В &lt;em&gt;явном режиме&lt;/em&gt; выводом можно напрямую управлять, задав метки нижнего индекса вывода. Для этого требуется идентификатор '-&amp;gt;', а также список меток выходных индексов. Эта функция увеличивает гибкость функции, так как при необходимости суммирование можно отключить или принудительно. Вызов &lt;code&gt;np.einsum('i-&amp;gt;', a)&lt;/code&gt; похож на &lt;a href=&quot;numpy.sum#numpy.sum&quot;&gt; &lt;code&gt;np.sum(a, axis=-1)&lt;/code&gt; &lt;/a&gt; , а &lt;code&gt;np.einsum('ii-&amp;gt;i', a)&lt;/code&gt; похож на &lt;a href=&quot;numpy.diag#numpy.diag&quot;&gt; &lt;code&gt;np.diag(a)&lt;/code&gt; &lt;/a&gt; . Разница в том, что по умолчанию &lt;a href=&quot;#numpy.einsum&quot;&gt; &lt;code&gt;einsum&lt;/code&gt; &lt;/a&gt; не разрешает трансляцию. Кроме того, &lt;code&gt;np.einsum('ij,jh-&amp;gt;ih', a, b)&lt;/code&gt; напрямую определяет порядок меток выходных нижних индексов и, следовательно, возвращает матричное умножение, в отличие от примера выше в неявном режиме.</target>
        </trans-unit>
        <trans-unit id="c0145016518b0031bebdd7367da2ce7b6495c4d5" translate="yes" xml:space="preserve">
          <source>In &lt;em&gt;explicit&lt;/em&gt; mode, &lt;a href=&quot;#numpy.einsum&quot;&gt;&lt;code&gt;einsum&lt;/code&gt;&lt;/a&gt; provides further flexibility to compute other array operations that might not be considered classical Einstein summation operations, by disabling, or forcing summation over specified subscript labels.</source>
          <target state="translated">В &lt;em&gt;явном&lt;/em&gt; режиме &lt;a href=&quot;#numpy.einsum&quot;&gt; &lt;code&gt;einsum&lt;/code&gt; &lt;/a&gt; обеспечивает дополнительную гибкость для вычисления других операций с массивами, которые могут не считаться классическими операциями суммирования Эйнштейна, путем отключения или принудительного суммирования по указанным подписям индекса.</target>
        </trans-unit>
        <trans-unit id="4c8b68052719d1c1d5215bfd711f82950ca7a1df" translate="yes" xml:space="preserve">
          <source>In &lt;em&gt;implicit mode&lt;/em&gt;, the chosen subscripts are important since the axes of the output are reordered alphabetically. This means that &lt;code&gt;np.einsum('ij', a)&lt;/code&gt; doesn&amp;rsquo;t affect a 2D array, while &lt;code&gt;np.einsum('ji', a)&lt;/code&gt; takes its transpose. Additionally, &lt;code&gt;np.einsum('ij,jk', a, b)&lt;/code&gt; returns a matrix multiplication, while, &lt;code&gt;np.einsum('ij,jh', a, b)&lt;/code&gt; returns the transpose of the multiplication since subscript &amp;lsquo;h&amp;rsquo; precedes subscript &amp;lsquo;i&amp;rsquo;.</source>
          <target state="translated">В &lt;em&gt;неявном режиме&lt;/em&gt; выбранные индексы важны, поскольку оси вывода переупорядочены в алфавитном порядке. Это означает, что &lt;code&gt;np.einsum('ij', a)&lt;/code&gt; не влияет на 2D-массив, тогда как &lt;code&gt;np.einsum('ji', a)&lt;/code&gt; принимает его транспонирование. Кроме того, &lt;code&gt;np.einsum('ij,jk', a, b)&lt;/code&gt; возвращает матричное умножение, а &lt;code&gt;np.einsum('ij,jh', a, b)&lt;/code&gt; возвращает транспонирование умножения, поскольку индекс 'h' предшествует нижнему индексу 'я'.</target>
        </trans-unit>
        <trans-unit id="065543ba7b7c467e5ff1cf1108109daa4f6f9b2e" translate="yes" xml:space="preserve">
          <source>In C, there is no equivalent to the deprecation warnings that Python supports. One way to do deprecations is to flag them in the documentation and release notes, then remove or change the deprecated features in a future major version (NumPy 2.0 and beyond). Minor versions of NumPy should not have major C-API changes, however, that prevent code that worked on a previous minor release. For example, we will do our best to ensure that code that compiled and worked on NumPy 1.4 should continue to work on NumPy 1.7 (but perhaps with compiler warnings).</source>
          <target state="translated">В C нет эквивалента предупреждений об опустошении,которые поддерживает Python.Один из способов сделать удаление-пометить их в документации и выпустить заметки,а затем удалить или изменить устаревшие функции в будущей мажорной версии (NumPy 2.0 и более поздние).Маленькие версии NumPy,однако,не должны иметь больших изменений C-API,которые препятствуют коду,работавшему на предыдущем незначительном выпуске.Например,мы сделаем всё возможное,чтобы код,который компилировался и работал на NumPy 1.4,продолжал работать на NumPy 1.7 (но,возможно,с предупреждениями компилятора).</target>
        </trans-unit>
        <trans-unit id="a9ca8be4f66144d7c2dcc488bdd409f6a21dcaf9" translate="yes" xml:space="preserve">
          <source>In IPython it is also possible to run individual examples simply by copy-pasting them in doctest mode:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="494eed34e26fa744c79b6950c743fa3931771a94" translate="yes" xml:space="preserve">
          <source>In MATLAB&amp;reg; the main tool available to you for customizing the environment is to modify the search path with the locations of your favorite functions. You can put such customizations into a startup script that MATLAB will run on startup.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="05b064c6c8d4ad79dd43510f89eb8bbc99cffd4b" translate="yes" xml:space="preserve">
          <source>In MATLAB&amp;reg;, arrays have pass-by-value semantics, with a lazy copy-on-write scheme to prevent actually creating copies until they are actually needed. Slice operations copy parts of the array.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="35c279433c70eb2d4b30f568fbc349c5cc15292b" translate="yes" xml:space="preserve">
          <source>In MATLAB&amp;reg;, the basic data type is a multidimensional array of double precision floating point numbers. Most expressions take such arrays and return such arrays. Operations on the 2-D instances of these arrays are designed to act more or less like matrix operations in linear algebra.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a7fc4e4e9aaf59319f61cb1b2c8333ad9f8d065b" translate="yes" xml:space="preserve">
          <source>In NumPy 1.16, you need to set the environment variable &lt;code&gt;NUMPY_EXPERIMENTAL_ARRAY_FUNCTION=1&lt;/code&gt; before importing NumPy to use NumPy function overrides.</source>
          <target state="translated">В NumPy 1.16 вам необходимо установить переменную среды &lt;code&gt;NUMPY_EXPERIMENTAL_ARRAY_FUNCTION=1&lt;/code&gt; перед импортом NumPy, чтобы использовать переопределения функции NumPy.</target>
        </trans-unit>
        <trans-unit id="2d05b90f328ed41700350ed32107071a1f6f3fbc" translate="yes" xml:space="preserve">
          <source>In NumPy 1.17, the protocol is enabled by default, but can be disabled with &lt;code&gt;NUMPY_EXPERIMENTAL_ARRAY_FUNCTION=0&lt;/code&gt;.</source>
          <target state="translated">В NumPy 1.17 протокол включен по умолчанию, но его можно отключить с помощью &lt;code&gt;NUMPY_EXPERIMENTAL_ARRAY_FUNCTION=0&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1b4938fa72e1c7213ec03de65817f46747825eb5" translate="yes" xml:space="preserve">
          <source>In NumPy 1.6.0, a type promotion API was created to encapsulate the mechanism for determining output types. See the functions &lt;a href=&quot;generated/numpy.result_type#numpy.result_type&quot;&gt;&lt;code&gt;result_type&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;generated/numpy.promote_types#numpy.promote_types&quot;&gt;&lt;code&gt;promote_types&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;generated/numpy.min_scalar_type#numpy.min_scalar_type&quot;&gt;&lt;code&gt;min_scalar_type&lt;/code&gt;&lt;/a&gt; for more details.</source>
          <target state="translated">В NumPy 1.6.0 был создан API продвижения типов для инкапсуляции механизма определения типов вывода. См. Дополнительные сведения о функциях &lt;a href=&quot;generated/numpy.result_type#numpy.result_type&quot;&gt; &lt;code&gt;result_type&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;generated/numpy.promote_types#numpy.promote_types&quot;&gt; &lt;code&gt;promote_types&lt;/code&gt; &lt;/a&gt; и &lt;a href=&quot;generated/numpy.min_scalar_type#numpy.min_scalar_type&quot;&gt; &lt;code&gt;min_scalar_type&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="6817ac22605fc4c2d0f573a2b14f3a89cb1e8f22" translate="yes" xml:space="preserve">
          <source>In NumPy 1.7 and 1.8, it continues to return a copy of the diagonal, but depending on this fact is deprecated. Writing to the resulting array continues to work as it used to, but a FutureWarning is issued.</source>
          <target state="translated">В NumPy 1.7 и 1.8 продолжает возвращать копию диагонали,но в зависимости от этого факта устаревает.Запись в результирующий массив продолжает работать,как и раньше,но выдается FutureWarning.</target>
        </trans-unit>
        <trans-unit id="117fbe2ef07a30dba33092bb43c1ec1f63fe2b7a" translate="yes" xml:space="preserve">
          <source>In NumPy 1.7 and later, this form allows &lt;code&gt;base_dtype&lt;/code&gt; to be interpreted as a structured dtype. Arrays created with this dtype will have underlying dtype &lt;code&gt;base_dtype&lt;/code&gt; but will have fields and flags taken from &lt;code&gt;new_dtype&lt;/code&gt;. This is useful for creating custom structured dtypes, as done in &lt;a href=&quot;arrays.classes#arrays-classes-rec&quot;&gt;record arrays&lt;/a&gt;.</source>
          <target state="translated">В NumPy 1.7 и новее эта форма позволяет &lt;code&gt;base_dtype&lt;/code&gt; как структурированный dtype. Массивы, созданные с этим dtype, будут иметь базовый dtype &lt;code&gt;base_dtype&lt;/code&gt; , но будут иметь поля и флаги, взятые из &lt;code&gt;new_dtype&lt;/code&gt; . Это полезно для создания настраиваемых структурированных типов данных, как это делается в &lt;a href=&quot;arrays.classes#arrays-classes-rec&quot;&gt;массивах записей&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="11387d0f86941bf54bf7c514e7a5b1f0fd171696" translate="yes" xml:space="preserve">
          <source>In NumPy arrays have pass-by-reference semantics. Slice operations are views into an array.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0193a49a749beca871335b39ba584f160aa0e7bd" translate="yes" xml:space="preserve">
          <source>In NumPy the basic type is a multidimensional &lt;code&gt;array&lt;/code&gt;. Operations on these arrays in all dimensionalities including 2D are element-wise operations. One needs to use specific functions for linear algebra (though for matrix multiplication, one can use the &lt;code&gt;@&lt;/code&gt; operator in python 3.5 and above).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3b53f7eb15b7831e508349b1a60777dcdbd79a0e" translate="yes" xml:space="preserve">
          <source>In NumPy versions &amp;lt;= 1.9.0 Nan is returned for slices that are all-NaN or empty. In later versions zero is returned.</source>
          <target state="translated">В версиях NumPy &amp;lt;= 1.9.0 Nan возвращается для срезов, которые содержат только NaN или пустые. В более поздних версиях возвращается ноль.</target>
        </trans-unit>
        <trans-unit id="36d3e5a6749595663c6dacbe6e7c386adcf1a912" translate="yes" xml:space="preserve">
          <source>In NumPy, dimensions are called &lt;strong&gt;axes&lt;/strong&gt;. This means that if you have a 2D array that looks like this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ed78411a5f19815c75577c53c9647b97f455af34" translate="yes" xml:space="preserve">
          <source>In NumPy, there are 24 new fundamental Python types to describe different types of scalars. These type descriptors are mostly based on the types available in the C language that CPython is written in, with several additional types compatible with Python&amp;rsquo;s types.</source>
          <target state="translated">В NumPy есть 24 новых фундаментальных типа Python для описания различных типов скаляров. Эти дескрипторы типов в основном основаны на типах, доступных в языке C, на котором написан CPython, с несколькими дополнительными типами, совместимыми с типами Python.</target>
        </trans-unit>
        <trans-unit id="0c775f1e9d60e517f99b3f4fb5fbef2cd48f1233" translate="yes" xml:space="preserve">
          <source>In NumPy, universal functions are instances of the &lt;code&gt;numpy.ufunc&lt;/code&gt; class. Many of the built-in functions are implemented in compiled C code. The basic ufuncs operate on scalars, but there is also a generalized kind for which the basic elements are sub-arrays (vectors, matrices, etc.), and broadcasting is done over other dimensions. One can also produce custom &lt;code&gt;ufunc&lt;/code&gt; instances using the &lt;a href=&quot;generated/numpy.frompyfunc#numpy.frompyfunc&quot;&gt;&lt;code&gt;frompyfunc&lt;/code&gt;&lt;/a&gt; factory function.</source>
          <target state="translated">В NumPy универсальные функции являются экземплярами класса &lt;code&gt;numpy.ufunc&lt;/code&gt; . Многие из встроенных функций реализованы в скомпилированном коде C. Базовые функции ufuncs работают со скалярами, но есть также обобщенный вид, для которого базовыми элементами являются подмассивы (векторы, матрицы и т. Д.), А широковещательная передача осуществляется по другим измерениям. Также можно создавать собственные экземпляры &lt;code&gt;ufunc&lt;/code&gt; , используя фабричную функцию &lt;a href=&quot;generated/numpy.frompyfunc#numpy.frompyfunc&quot;&gt; &lt;code&gt;frompyfunc&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="774635ebbde845fd67b0f22449de4d887322609c" translate="yes" xml:space="preserve">
          <source>In Numeric, the ancestor of Numpy, broadcasting was implemented in several lines of code buried deep in ufuncobject.c. In NumPy, the notion of broadcasting has been abstracted so that it can be performed in multiple places. Broadcasting is handled by the function &lt;a href=&quot;c-api.array#c.PyArray_Broadcast&quot;&gt;&lt;code&gt;PyArray_Broadcast&lt;/code&gt;&lt;/a&gt;. This function requires a &lt;a href=&quot;c-api.types-and-structures#c.PyArrayMultiIterObject&quot;&gt;&lt;code&gt;PyArrayMultiIterObject&lt;/code&gt;&lt;/a&gt; (or something that is a binary equivalent) to be passed in. The &lt;a href=&quot;c-api.types-and-structures#c.PyArrayMultiIterObject&quot;&gt;&lt;code&gt;PyArrayMultiIterObject&lt;/code&gt;&lt;/a&gt; keeps track of the broadcast number of dimensions and size in each dimension along with the total size of the broadcast result. It also keeps track of the number of arrays being broadcast and a pointer to an iterator for each of the arrays being broadcast.</source>
          <target state="translated">В Numeric, предке Numpy, широковещательная передача была реализована в нескольких строках кода, скрытых глубоко в ufuncobject.c. В NumPy понятие широковещательной передачи было абстрагировано, чтобы ее можно было выполнять в нескольких местах. Трансляция осуществляется функцией &lt;a href=&quot;c-api.array#c.PyArray_Broadcast&quot;&gt; &lt;code&gt;PyArray_Broadcast&lt;/code&gt; &lt;/a&gt; . Для этой функции требуется &lt;a href=&quot;c-api.types-and-structures#c.PyArrayMultiIterObject&quot;&gt; &lt;code&gt;PyArrayMultiIterObject&lt;/code&gt; &lt;/a&gt; (или что-то, что является двоичным эквивалентом). &lt;a href=&quot;c-api.types-and-structures#c.PyArrayMultiIterObject&quot;&gt; &lt;code&gt;PyArrayMultiIterObject&lt;/code&gt; &lt;/a&gt; отслеживает количество измерений и размер широковещательной рассылки в каждом измерении вместе с общим размером результата широковещательной передачи. Он также отслеживает количество широковещательных массивов и указатель на итератор для каждого широковещательного массива.</target>
        </trans-unit>
        <trans-unit id="8922bb1c700cbaf5cb6e489ccc3a2d78c8e39611" translate="yes" xml:space="preserve">
          <source>In Numeric, the ancestor of Numpy, broadcasting was implemented in several lines of code buried deep in ufuncobject.c. In NumPy, the notion of broadcasting has been abstracted so that it can be performed in multiple places. Broadcasting is handled by the function &lt;a href=&quot;c-api/array#c.PyArray_Broadcast&quot;&gt;&lt;code&gt;PyArray_Broadcast&lt;/code&gt;&lt;/a&gt;. This function requires a &lt;a href=&quot;c-api/types-and-structures#c.PyArrayMultiIterObject&quot;&gt;&lt;code&gt;PyArrayMultiIterObject&lt;/code&gt;&lt;/a&gt; (or something that is a binary equivalent) to be passed in. The &lt;a href=&quot;c-api/types-and-structures#c.PyArrayMultiIterObject&quot;&gt;&lt;code&gt;PyArrayMultiIterObject&lt;/code&gt;&lt;/a&gt; keeps track of the broadcast number of dimensions and size in each dimension along with the total size of the broadcast result. It also keeps track of the number of arrays being broadcast and a pointer to an iterator for each of the arrays being broadcast.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="22b48541001b861013a36c818439e26a1074dfe7" translate="yes" xml:space="preserve">
          <source>In Numpy 1.15, indexing an array with a multi-field index returned a copy of the result above, but with fields packed together in memory as if passed through &lt;a href=&quot;#numpy.lib.recfunctions.repack_fields&quot;&gt;&lt;code&gt;numpy.lib.recfunctions.repack_fields&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1b22fd0d42a99bd19673ecd40259cf68612486f3" translate="yes" xml:space="preserve">
          <source>In Python 3.0, &lt;code&gt;//&lt;/code&gt; is the floor division operator and &lt;code&gt;/&lt;/code&gt; the true division operator. The &lt;code&gt;true_divide(x1, x2)&lt;/code&gt; function is equivalent to true division in Python.</source>
          <target state="translated">В Python 3.0 &lt;code&gt;//&lt;/code&gt; является оператором деления этажа и &lt;code&gt;/&lt;/code&gt; истинным оператором деления. Функция &lt;code&gt;true_divide(x1, x2)&lt;/code&gt; эквивалентна истинному делению в Python.</target>
        </trans-unit>
        <trans-unit id="62fa547333a8d1dc9c0d4f4c02b89f627c6e6bc6" translate="yes" xml:space="preserve">
          <source>In Python, &lt;code&gt;//&lt;/code&gt; is the floor division operator and &lt;code&gt;/&lt;/code&gt; the true division operator. The &lt;code&gt;true_divide(x1, x2)&lt;/code&gt; function is equivalent to true division in Python.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c2ae9f01dfbac70b64c2f45fa3c211ed297fec42" translate="yes" xml:space="preserve">
          <source>In Python, &lt;code&gt;arr[i, j]&lt;/code&gt; is exactly the same as &lt;code&gt;arr[(i, j)]&lt;/code&gt;&amp;mdash;so we can put &lt;code&gt;i&lt;/code&gt; and &lt;code&gt;j&lt;/code&gt; in a &lt;code&gt;tuple&lt;/code&gt; and then do the indexing with that.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="060ed7eb6876dfc9a447b37757dfa0a45bd6069c" translate="yes" xml:space="preserve">
          <source>In Python, &lt;code&gt;x[(exp1, exp2, ..., expN)]&lt;/code&gt; is equivalent to &lt;code&gt;x[exp1, exp2, ..., expN]&lt;/code&gt;; the latter is just syntactic sugar for the former.</source>
          <target state="translated">В Python &lt;code&gt;x[(exp1, exp2, ..., expN)]&lt;/code&gt; эквивалентно &lt;code&gt;x[exp1, exp2, ..., expN]&lt;/code&gt; ; последнее - всего лишь синтаксический сахар для первого.</target>
        </trans-unit>
        <trans-unit id="667b044648896477b62af8727dbe5136eaaff74b" translate="yes" xml:space="preserve">
          <source>In Python:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="269b609eb84c47b360c36d70b62b2cd1bb86a5a5" translate="yes" xml:space="preserve">
          <source>In a &lt;a href=&quot;#term-structured-data-type&quot;&gt;structured data type&lt;/a&gt;, each sub-type is called a &lt;code&gt;field&lt;/code&gt;. The &lt;code&gt;field&lt;/code&gt; has a name (a string), a type (any valid dtype), and an optional &lt;code&gt;title&lt;/code&gt;. See &lt;a href=&quot;reference/arrays.dtypes#arrays-dtypes&quot;&gt;Data type objects (dtype)&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2721403cc827c0b84ea65a28ef2dffa50ceb53e2" translate="yes" xml:space="preserve">
          <source>In a nutshell, &lt;a href=&quot;../reference/generated/numpy.genfromtxt#numpy.genfromtxt&quot;&gt;&lt;code&gt;genfromtxt&lt;/code&gt;&lt;/a&gt; runs two main loops. The first loop converts each line of the file in a sequence of strings. The second loop converts each string to the appropriate data type. This mechanism is slower than a single loop, but gives more flexibility. In particular, &lt;a href=&quot;../reference/generated/numpy.genfromtxt#numpy.genfromtxt&quot;&gt;&lt;code&gt;genfromtxt&lt;/code&gt;&lt;/a&gt; is able to take missing data into account, when other faster and simpler functions like &lt;a href=&quot;../reference/generated/numpy.loadtxt#numpy.loadtxt&quot;&gt;&lt;code&gt;loadtxt&lt;/code&gt;&lt;/a&gt; cannot.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0643c04fa6f173d8a3f9cc4f3ce84f7f07625090" translate="yes" xml:space="preserve">
          <source>In a study, testing for a specific alternative to the null hypothesis requires use of the Noncentral F distribution. We need to calculate the area in the tail of the distribution that exceeds the value of the F distribution for the null hypothesis. We&amp;rsquo;ll plot the two probability distributions for comparison.</source>
          <target state="translated">В исследовании проверка конкретной альтернативы нулевой гипотезе требует использования нецентрального F-распределения. Нам нужно вычислить площадь в хвосте распределения, которая превышает значение распределения F для нулевой гипотезы. Мы построим два распределения вероятностей для сравнения.</target>
        </trans-unit>
        <trans-unit id="4a555d5f0fdb6581c9697563824e3d61c23e3de4" translate="yes" xml:space="preserve">
          <source>In a two&amp;rsquo;s-complement system negative numbers are represented by the two&amp;rsquo;s complement of the absolute value. This is the most common method of representing signed integers on computers &lt;a href=&quot;#r962252997619-1&quot; id=&quot;id1&quot;&gt;[1]&lt;/a&gt;. A N-bit two&amp;rsquo;s-complement system can represent every integer in the range</source>
          <target state="translated">В системе с дополнением до двух отрицательные числа представлены дополнением до двух абсолютного значения. Это наиболее распространенный метод представления целых чисел со знаком на компьютерах &lt;a href=&quot;#r962252997619-1&quot; id=&quot;id1&quot;&gt;[1]&lt;/a&gt; . N-битная система с дополнением до двух может представлять каждое целое число в диапазоне</target>
        </trans-unit>
        <trans-unit id="6ec708a7d401df6aafb3a323298b5e8a10e70e10" translate="yes" xml:space="preserve">
          <source>In addition &lt;code&gt;a&lt;/code&gt; or &lt;code&gt;b&lt;/code&gt; may be scalars, in which case:</source>
          <target state="translated">Кроме того, &lt;code&gt;a&lt;/code&gt; или &lt;code&gt;b&lt;/code&gt; могут быть скалярами, и в этом случае:</target>
        </trans-unit>
        <trans-unit id="85652b9aa303fc72ea7ade73af4f0dda2d5084d0" translate="yes" xml:space="preserve">
          <source>In addition to &lt;a href=&quot;../reference/generated/numpy.genfromtxt#numpy.genfromtxt&quot;&gt;&lt;code&gt;genfromtxt&lt;/code&gt;&lt;/a&gt;, the &lt;code&gt;numpy.lib.io&lt;/code&gt; module provides several convenience functions derived from &lt;a href=&quot;../reference/generated/numpy.genfromtxt#numpy.genfromtxt&quot;&gt;&lt;code&gt;genfromtxt&lt;/code&gt;&lt;/a&gt;. These functions work the same way as the original, but they have different default values.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3b2e8925339289db83edc8e4d5703c4e6627acaa" translate="yes" xml:space="preserve">
          <source>In addition to &lt;code&gt;__array_wrap__&lt;/code&gt;, which is called on the way out of the ufunc, there is also an &lt;code&gt;__array_prepare__&lt;/code&gt; method which is called on the way into the ufunc, after the output arrays are created but before any computation has been performed. The default implementation does nothing but pass through the array. &lt;code&gt;__array_prepare__&lt;/code&gt; should not attempt to access the array data or resize the array, it is intended for setting the output array type, updating attributes and metadata, and performing any checks based on the input that may be desired before computation begins. Like &lt;code&gt;__array_wrap__&lt;/code&gt;, &lt;code&gt;__array_prepare__&lt;/code&gt; must return an ndarray or subclass thereof or raise an error.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0202a847e7f1c55dfe19c04653df757ab3188d4f" translate="yes" xml:space="preserve">
          <source>In addition to attributes that can be specified via keyword arguments to &lt;code&gt;Configuration&lt;/code&gt; constructor, &lt;code&gt;Configuration&lt;/code&gt; instance (let us denote as &lt;code&gt;config&lt;/code&gt;) has the following attributes that can be useful in writing setup scripts:</source>
          <target state="translated">Кроме атрибуты , которые могут быть заданы с помощью именованных аргументов в &lt;code&gt;Configuration&lt;/code&gt; конструктора, &lt;code&gt;Configuration&lt;/code&gt; экземпляр (будет обозначать &lt;code&gt;config&lt;/code&gt; ) имеют следующие атрибуты , которые могут быть полезны при написании сценариев установки:</target>
        </trans-unit>
        <trans-unit id="9205eb129a4d89ef4a9eb5c8d77614ae87b40a33" translate="yes" xml:space="preserve">
          <source>In addition to field names, fields may also have an associated &lt;a href=&quot;../glossary#term-title&quot;&gt;title&lt;/a&gt;, an alternate name, which is sometimes used as an additional description or alias for the field. The title may be used to index an array, just like a field name.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1ee5bd9d7a0e50bb5b466ac30e311415eba3cdbd" translate="yes" xml:space="preserve">
          <source>In addition to field names, structured array fields may have an associated &lt;a href=&quot;user/basics.rec#titles&quot;&gt;title&lt;/a&gt; which is an alias to the name and is commonly used for plotting.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5d8a9cc27249ffd4d0b1366a65411d876d2aa7c5" translate="yes" xml:space="preserve">
          <source>In addition to sort, which returns a sorted copy of an array, you can use:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="29ec49c4a4c9a814e9bec074f3eabcbf7dea786f" translate="yes" xml:space="preserve">
          <source>In addition to the &lt;a href=&quot;#numpy.ma.MaskedArray&quot;&gt;&lt;code&gt;MaskedArray&lt;/code&gt;&lt;/a&gt; class, the &lt;a href=&quot;maskedarray.generic#module-numpy.ma&quot;&gt;&lt;code&gt;numpy.ma&lt;/code&gt;&lt;/a&gt; module defines several constants.</source>
          <target state="translated">В дополнение к &lt;a href=&quot;#numpy.ma.MaskedArray&quot;&gt; &lt;code&gt;MaskedArray&lt;/code&gt; &lt;/a&gt; класса, &lt;a href=&quot;maskedarray.generic#module-numpy.ma&quot;&gt; &lt;code&gt;numpy.ma&lt;/code&gt; &lt;/a&gt; модуль определяет несколько констант.</target>
        </trans-unit>
        <trans-unit id="7b236bba71a2e6d9bbb7e9f54e04010c73fd209b" translate="yes" xml:space="preserve">
          <source>In addition to the Python C-API, there is a full and rich C-API for NumPy allowing sophisticated manipulations on a C-level. However, for most applications, only a few API calls will typically be used. For example, if you need to just extract a pointer to memory along with some shape information to pass to another calculation routine, then you will use very different calls than if you are trying to create a new array-like type or add a new data type for ndarrays. This chapter documents the API calls and macros that are most commonly used.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4c1e50029232768a84bc4dc52748436e5f14647c" translate="yes" xml:space="preserve">
          <source>In addition, F2PY introduces the following statements:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="50f7370be70d6fe0e899df628f5a07f23f4c4044" translate="yes" xml:space="preserve">
          <source>In addition, building the documentation requires the Sphinx extension &lt;code&gt;plot_directive&lt;/code&gt;, which is shipped with &lt;a href=&quot;https://matplotlib.org/&quot;&gt;Matplotlib&lt;/a&gt;. This Sphinx extension can be installed by installing Matplotlib. You will also need Python&amp;gt;=3.6.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="55ae7a3680f09394c2ee157c2db0452e71e75c1c" translate="yes" xml:space="preserve">
          <source>In addition, if &lt;em&gt;data&lt;/em&gt; is non-NULL, then &lt;em&gt;strides&lt;/em&gt; can also be provided. If &lt;em&gt;strides&lt;/em&gt; is &lt;code&gt;NULL&lt;/code&gt;, then the array strides are computed as C-style contiguous (default) or Fortran-style contiguous (&lt;em&gt;flags&lt;/em&gt; is nonzero for &lt;em&gt;data&lt;/em&gt; = &lt;code&gt;NULL&lt;/code&gt; or &lt;em&gt;flags&lt;/em&gt; &amp;amp; &lt;a href=&quot;#c.NPY_ARRAY_F_CONTIGUOUS&quot;&gt;&lt;code&gt;NPY_ARRAY_F_CONTIGUOUS&lt;/code&gt;&lt;/a&gt; is nonzero non-NULL &lt;em&gt;data&lt;/em&gt;). Any provided &lt;em&gt;dims&lt;/em&gt; and &lt;em&gt;strides&lt;/em&gt; are copied into newly allocated dimension and strides arrays for the new array object.</source>
          <target state="translated">Кроме того, если &lt;em&gt;данные&lt;/em&gt; не равны NULL, также могут быть предоставлены &lt;em&gt;шаги&lt;/em&gt; . Если &lt;em&gt;strides&lt;/em&gt; равен &lt;code&gt;NULL&lt;/code&gt; , то шаги массива вычисляются как непрерывные в стиле C (по умолчанию) или как непрерывные в стиле Fortran ( &lt;em&gt;flags не&lt;/em&gt; равен нулю для &lt;em&gt;data&lt;/em&gt; = &lt;code&gt;NULL&lt;/code&gt; или &lt;em&gt;flags,&lt;/em&gt; а &lt;a href=&quot;#c.NPY_ARRAY_F_CONTIGUOUS&quot;&gt; &lt;code&gt;NPY_ARRAY_F_CONTIGUOUS&lt;/code&gt; &lt;/a&gt; - ненулевые ненулевые &lt;em&gt;данные&lt;/em&gt; ). Любые предоставленные &lt;em&gt;тускнеет&lt;/em&gt; и &lt;em&gt;шагает&lt;/em&gt; копируются во вновь выделенных измерениях и шагают массивы для нового объекта массива.</target>
        </trans-unit>
        <trans-unit id="176596f4a4076180f296c1297a5a4088a9dfbec9" translate="yes" xml:space="preserve">
          <source>In all the cases but the first one, the output will be a 1D array with a structured dtype. This dtype has as many fields as items in the sequence. The field names are defined with the &lt;code&gt;names&lt;/code&gt; keyword.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9d28ba92ccb218b4c16f2db7077723c632363102" translate="yes" xml:space="preserve">
          <source>In all the examples so far, the elements of &lt;code&gt;a&lt;/code&gt; are provided by the iterator one at a time, because all the looping logic is internal to the iterator. While this is simple and convenient, it is not very efficient. A better approach is to move the one-dimensional innermost loop into your code, external to the iterator. This way, NumPy&amp;rsquo;s vectorized operations can be used on larger chunks of the elements being visited.</source>
          <target state="translated">Во всех примерах до сих пор элементы &lt;code&gt;a&lt;/code&gt; предоставляются итератором по одному, потому что вся логика цикла является внутренней для итератора. Это просто и удобно, но не очень эффективно. Лучше всего переместить одномерный самый внутренний цикл в ваш код, внешний по отношению к итератору. Таким образом, векторизованные операции NumPy можно использовать для больших фрагментов посещаемых элементов.</target>
        </trans-unit>
        <trans-unit id="8389ffaf8c2e94e518381d310c79dd3ec1608070" translate="yes" xml:space="preserve">
          <source>In almost all cases &lt;code&gt;np.ndim(x) == 0&lt;/code&gt; should be used instead of this function, as that will also return true for 0d arrays. This is how numpy overloads functions in the style of the &lt;code&gt;dx&lt;/code&gt; arguments to &lt;a href=&quot;numpy.gradient#numpy.gradient&quot;&gt;&lt;code&gt;gradient&lt;/code&gt;&lt;/a&gt; and the &lt;code&gt;bins&lt;/code&gt; argument to &lt;a href=&quot;numpy.histogram#numpy.histogram&quot;&gt;&lt;code&gt;histogram&lt;/code&gt;&lt;/a&gt;. Some key differences:</source>
          <target state="translated">Почти во всех случаях вместо этой функции следует использовать &lt;code&gt;np.ndim(x) == 0&lt;/code&gt; , так как это также вернет true для массивов 0d. Вот как функции перегрузки numpy работают в стиле аргументов &lt;code&gt;dx&lt;/code&gt; для &lt;a href=&quot;numpy.gradient#numpy.gradient&quot;&gt; &lt;code&gt;gradient&lt;/code&gt; &lt;/a&gt; и аргумента &lt;code&gt;bins&lt;/code&gt; для &lt;a href=&quot;numpy.histogram#numpy.histogram&quot;&gt; &lt;code&gt;histogram&lt;/code&gt; &lt;/a&gt; . Некоторые ключевые отличия:</target>
        </trans-unit>
        <trans-unit id="09406f1061497030999a27047c2ac1dba1e1fddd" translate="yes" xml:space="preserve">
          <source>In both cases, set the &lt;code&gt;BUILD_COMMIT&lt;/code&gt; variable to the current release tag - e.g. &lt;code&gt;v1.19.0&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3e277da1826bb81328288e7b48e1bc36cb3d9f8b" translate="yes" xml:space="preserve">
          <source>In case of multiple occurrences of the maximum values, the indices corresponding to the first occurrence are returned.</source>
          <target state="translated">В случае множественных вхождений максимальных значений возвращаются индексы,соответствующие первому вхождению.</target>
        </trans-unit>
        <trans-unit id="27e7146cba1027fb05de967eb96a8d0d4f3188c0" translate="yes" xml:space="preserve">
          <source>In case of multiple occurrences of the minimum values, the indices corresponding to the first occurrence are returned.</source>
          <target state="translated">В случае множественных вхождений минимальных значений возвращаются индексы,соответствующие первому вхождению.</target>
        </trans-unit>
        <trans-unit id="e0a4f4799ebef164e20467e93383e4d4633f2709" translate="yes" xml:space="preserve">
          <source>In case of severe and obvious breaches, e.g. personal threat or violent, sexist or racist language, we will immediately disconnect the originator from NumPy communication channels; please see the manual for details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ae3b7f089e082a13dedd4fd05f16654244713a03" translate="yes" xml:space="preserve">
          <source>In cases not involving clear severe and obvious breaches of this code of conduct, the process for acting on any received code of conduct violation report will be:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b7695ef954df8bd205d22a810fa2781d2a8a8dfc" translate="yes" xml:space="preserve">
          <source>In certain cases a failed installation or setup issue can cause you to see the following error message:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="77e954d7daee979232398ad08ec5cc70a6a273a6" translate="yes" xml:space="preserve">
          <source>In code, arrays are often conveniently expressed as nested lists:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c38db33a30014f091c11009d703bc2b8cd0eeadd" translate="yes" xml:space="preserve">
          <source>In complex cases, &lt;a href=&quot;../reference/generated/numpy.r_#numpy.r_&quot;&gt;&lt;code&gt;r_&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../reference/generated/numpy.c_#numpy.c_&quot;&gt;&lt;code&gt;c_&lt;/code&gt;&lt;/a&gt; are useful for creating arrays by stacking numbers along one axis. They allow the use of range literals (&amp;ldquo;:&amp;rdquo;)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="15906ca68f2a7d7e2f6c027ec51f5d69dd3bed29" translate="yes" xml:space="preserve">
          <source>In copying mode, &amp;lsquo;copy&amp;rsquo; is specified as a per-operand flag. This is done to provide control in a per-operand fashion. Buffering mode is specified as an iterator flag.</source>
          <target state="translated">В режиме копирования &amp;laquo;копирование&amp;raquo; указывается как флаг для каждого операнда. Это сделано для обеспечения управления для каждого операнда. Режим буферизации указывается как флаг итератора.</target>
        </trans-unit>
        <trans-unit id="d217a2b2edd5733cc1a08fd36e52adeffd147a5f" translate="yes" xml:space="preserve">
          <source>In ctypes, the return-value of a function is set to be &amp;lsquo;int&amp;rsquo; by default. This behavior can be changed by setting the restype attribute of the function. Use None for the restype if the function has no return value (&amp;lsquo;void&amp;rsquo;):</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="20601c7341dfe87ba7a45fcff8c92729cd267fbb" translate="yes" xml:space="preserve">
          <source>In depth explanation of concepts, best practices and techniques</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2913833b48b2894352d88e1660f11e59aa09d3c6" translate="yes" xml:space="preserve">
          <source>In detail</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="18557e967a450637ab72e77508fbfb08c6b092fc" translate="yes" xml:space="preserve">
          <source>In effect, the slice and index array operation are independent. The slice operation extracts columns with index 1 and 2, (i.e. the 2nd and 3rd columns), followed by the index array operation which extracts rows with index 0, 2 and 4 (i.e the first, third and fifth rows).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0401f70e9e9ccb692db031dd68efec8a8e548588" translate="yes" xml:space="preserve">
          <source>In every case, the &amp;lsquo;descr&amp;rsquo; key is optional, but of course provides more information which may be important for various applications:</source>
          <target state="translated">В любом случае клавиша descr необязательна, но, конечно, предоставляет дополнительную информацию, которая может быть важной для различных приложений:</target>
        </trans-unit>
        <trans-unit id="ed0824a3a5c26008c8df28fe72abd00f4b7f2a94" translate="yes" xml:space="preserve">
          <source>In every case, the moderator should make a reasonable effort to contact the originator, and tell them specifically how their language or actions qualify as a &amp;ldquo;clear and severe breach&amp;rdquo;. The moderator should also say that, if the originator believes this is unfair or they want to be reconnected to NumPy, they have the right to ask for a review, as below, by the Code of Conduct Committee. The moderator should copy this explanation to the Code of Conduct Committee.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7eac15d5d1d96d05ac021a41eb29548e9ee61a69" translate="yes" xml:space="preserve">
          <source>In fact, why don&amp;rsquo;t we try that?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a50f2ab9bd768752351c518eb56b5f190e77022a" translate="yes" xml:space="preserve">
          <source>In general how to set and check your environment variables depends on your system. If you can open a correct python shell, you can also run the following in python:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="51a2782158f2135b3873b2bc91584160c3224ec1" translate="yes" xml:space="preserve">
          <source>In general if an index includes a Boolean array, the result will be identical to inserting &lt;code&gt;obj.nonzero()&lt;/code&gt; into the same position and using the integer array indexing mechanism described above. &lt;code&gt;x[ind_1, boolean_array, ind_2]&lt;/code&gt; is equivalent to &lt;code&gt;x[(ind_1,) + boolean_array.nonzero() + (ind_2,)]&lt;/code&gt;.</source>
          <target state="translated">Обычно, если индекс включает в себя логический массив, результат будет идентичен вставке &lt;code&gt;obj.nonzero()&lt;/code&gt; в ту же позицию и использованию механизма индексации целочисленного массива, описанного выше. &lt;code&gt;x[ind_1, boolean_array, ind_2]&lt;/code&gt; эквивалентно &lt;code&gt;x[(ind_1,) + boolean_array.nonzero() + (ind_2,)]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a0426d4d5e9174343610861881dfacd8c07a4e5a" translate="yes" xml:space="preserve">
          <source>In general, a scalar argument of a F2PY generated wrapper function can be an ordinary Python scalar (integer, float, complex number) as well as an arbitrary sequence object (list, tuple, array, string) of scalars. In the latter case, the first element of the sequence object is passed to Fortran routine as a scalar argument.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="41b09ab4340a010ae2242f6c23854be608350193" translate="yes" xml:space="preserve">
          <source>In general, array arguments of F2PY generated wrapper functions accept arbitrary sequences that can be transformed to NumPy array objects. An exception is &lt;code&gt;intent(inout)&lt;/code&gt; array arguments that always must be proper-contiguous and have proper type, otherwise an exception is raised. Another exception is &lt;code&gt;intent(inplace)&lt;/code&gt; array arguments that attributes will be changed &lt;em&gt;in situ&lt;/em&gt; if the argument has different type than expected (see &lt;code&gt;intent(inplace)&lt;/code&gt; attribute for more information).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ce9f087f4c4d9805ec9d46a8db9fd36d60eeb431" translate="yes" xml:space="preserve">
          <source>In general, for &lt;code&gt;values&lt;/code&gt;</source>
          <target state="translated">В общем, для &lt;code&gt;values&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="b4732749a65786e199f581dd65439c32d67356e7" translate="yes" xml:space="preserve">
          <source>In general, for arrays with more than two dimensions, &lt;a href=&quot;../reference/generated/numpy.hstack#numpy.hstack&quot;&gt;&lt;code&gt;hstack&lt;/code&gt;&lt;/a&gt; stacks along their second axes, &lt;a href=&quot;../reference/generated/numpy.vstack#numpy.vstack&quot;&gt;&lt;code&gt;vstack&lt;/code&gt;&lt;/a&gt; stacks along their first axes, and &lt;a href=&quot;../reference/generated/numpy.concatenate#numpy.concatenate&quot;&gt;&lt;code&gt;concatenate&lt;/code&gt;&lt;/a&gt; allows for an optional arguments giving the number of the axis along which the concatenation should happen.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="31150963fe6ef250ba4e833d06b222cca1c2cb70" translate="yes" xml:space="preserve">
          <source>In general, if a NumPy array is proper-contiguous and has a proper type then it is directly passed to wrapped Fortran/C function. Otherwise, an element-wise copy of an input array is made and the copy, being proper-contiguous and with proper type, is used as an array argument.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="13ea723c2a24ed6ef1771c5f258ea31816238b49" translate="yes" xml:space="preserve">
          <source>In general, if the array owns its own memory, as for &lt;code&gt;arr&lt;/code&gt; in this case, then &lt;code&gt;arr.base&lt;/code&gt; will be None - there are some exceptions to this - see the numpy book for more details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5abc873332e6b6be31064612f2de6812b8a80d3b" translate="yes" xml:space="preserve">
          <source>In general, it is not necessary to list class methods. Those that are not part of the public API have names that start with an underscore. In some cases, however, a class may have a great many methods, of which only a few are relevant (e.g., subclasses of ndarray). Then, it becomes useful to have an additional &lt;strong&gt;Methods&lt;/strong&gt; section:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fcbe439e71ce76a6bc1cdecd65ffad854f695844" translate="yes" xml:space="preserve">
          <source>In general, numerical data arranged in an array-like structure in Python can be converted to arrays through the use of the array() function. The most obvious examples are lists and tuples. See the documentation for array() for details for its use. Some objects may support the array-protocol and allow conversion to arrays this way. A simple way to find out if the object can be converted to a numpy array using array() is simply to try it interactively and see if it works! (The Python Way).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2636b2d2555459756347b2bec78d067967d80c45" translate="yes" xml:space="preserve">
          <source>In general, the (polynomial) division of one C-series by another results in quotient and remainder terms that are not in the Chebyshev polynomial basis set. Thus, to express these results as C-series, it is typically necessary to &amp;ldquo;reproject&amp;rdquo; the results onto said basis set, which typically produces &amp;ldquo;unintuitive&amp;rdquo; (but correct) results; see Examples section below.</source>
          <target state="translated">В общем, (полиномиальное) деление одной C-серии на другую приводит к получению факторных и остаточных членов, которых нет в базисе полиномов Чебышева. Таким образом, чтобы выразить эти результаты как серию C, обычно необходимо &amp;laquo;перепроецировать&amp;raquo; результаты на упомянутый базисный набор, что обычно дает &amp;laquo;неинтуитивные&amp;raquo; (но правильные) результаты; см. раздел &amp;laquo;Примеры&amp;raquo; ниже.</target>
        </trans-unit>
        <trans-unit id="e3455fcce926f7a356d4db4cbb1cca4337cab9da" translate="yes" xml:space="preserve">
          <source>In general, the (polynomial) division of one Hermite series by another results in quotient and remainder terms that are not in the Hermite polynomial basis set. Thus, to express these results as a Hermite series, it is necessary to &amp;ldquo;reproject&amp;rdquo; the results onto the Hermite basis set, which may produce &amp;ldquo;unintuitive&amp;rdquo; (but correct) results; see Examples section below.</source>
          <target state="translated">В общем, (полиномиальное) деление одного ряда Эрмита на другой приводит к получению факторов, составляющих частное, и остаточного члена, которых нет в базисе полиномов Эрмита. Таким образом, чтобы выразить эти результаты в виде ряда Эрмита, необходимо &amp;laquo;перепроецировать&amp;raquo; результаты на базисный набор Эрмита, что может дать &amp;laquo;неинтуитивные&amp;raquo; (но правильные) результаты; см. раздел &amp;laquo;Примеры&amp;raquo; ниже.</target>
        </trans-unit>
        <trans-unit id="efbd236c04665a122a8e3491beed41d349724880" translate="yes" xml:space="preserve">
          <source>In general, the (polynomial) division of one Laguerre series by another results in quotient and remainder terms that are not in the Laguerre polynomial basis set. Thus, to express these results as a Laguerre series, it is necessary to &amp;ldquo;reproject&amp;rdquo; the results onto the Laguerre basis set, which may produce &amp;ldquo;unintuitive&amp;rdquo; (but correct) results; see Examples section below.</source>
          <target state="translated">В общем, (полиномиальное) деление одного ряда Лагерра на другой приводит к частным и остаточным членам, которые не входят в базисный набор полиномов Лагерра. Таким образом, чтобы выразить эти результаты в виде ряда Лагерра, необходимо &amp;laquo;перепроецировать&amp;raquo; результаты на базисный набор Лагерра, что может дать &amp;laquo;неинтуитивные&amp;raquo; (но правильные) результаты; см. раздел &amp;laquo;Примеры&amp;raquo; ниже.</target>
        </trans-unit>
        <trans-unit id="3e8f9ae8eb5287a2e2ca75de1027864d1ea7dce3" translate="yes" xml:space="preserve">
          <source>In general, the (polynomial) division of one Legendre series by another results in quotient and remainder terms that are not in the Legendre polynomial basis set. Thus, to express these results as a Legendre series, it is necessary to &amp;ldquo;reproject&amp;rdquo; the results onto the Legendre basis set, which may produce &amp;ldquo;unintuitive&amp;rdquo; (but correct) results; see Examples section below.</source>
          <target state="translated">В общем, (полиномиальное) деление одного ряда Лежандра на другой приводит к получению факторных и остаточных членов, которые не входят в базисный набор полиномов Лежандра. Таким образом, чтобы выразить эти результаты в виде ряда Лежандра, необходимо &amp;laquo;перепроецировать&amp;raquo; результаты на базисный набор Лежандра, что может дать &amp;laquo;неинтуитивные&amp;raquo; (но правильные) результаты; см. раздел &amp;laquo;Примеры&amp;raquo; ниже.</target>
        </trans-unit>
        <trans-unit id="747e8b05b6e447bd7c26bc6951f1c707ad59f09d" translate="yes" xml:space="preserve">
          <source>In general, the (polynomial) product of two C-series results in terms that are not in the Chebyshev polynomial basis set. Thus, to express the product as a C-series, it is typically necessary to &amp;ldquo;reproject&amp;rdquo; the product onto said basis set, which typically produces &amp;ldquo;unintuitive live&amp;rdquo; (but correct) results; see Examples section below.</source>
          <target state="translated">В общем, (полиномиальное) произведение двух C-серий приводит к терминам, не входящим в базисный набор полиномов Чебышева. Таким образом, чтобы выразить продукт как серию C, обычно необходимо &amp;laquo;перепроецировать&amp;raquo; продукт на указанный базовый набор, что обычно дает &amp;laquo;неинтуитивные живые&amp;raquo; (но правильные) результаты; см. раздел &amp;laquo;Примеры&amp;raquo; ниже.</target>
        </trans-unit>
        <trans-unit id="140624c01263c11121eb8733a7573189c8b35148" translate="yes" xml:space="preserve">
          <source>In general, the (polynomial) product of two C-series results in terms that are not in the Hermite polynomial basis set. Thus, to express the product as a Hermite series, it is necessary to &amp;ldquo;reproject&amp;rdquo; the product onto said basis set, which may produce &amp;ldquo;unintuitive&amp;rdquo; (but correct) results; see Examples section below.</source>
          <target state="translated">В общем, (полиномиальное) произведение двух C-серий приводит к терминам, не входящим в базисный набор полиномов Эрмита. Таким образом, чтобы выразить продукт как серию Hermite, необходимо &amp;laquo;перепроецировать&amp;raquo; продукт на указанный базовый набор, что может дать &amp;laquo;неинтуитивные&amp;raquo; (но правильные) результаты; см. раздел &amp;laquo;Примеры&amp;raquo; ниже.</target>
        </trans-unit>
        <trans-unit id="4be0c1b381e26e882c60023195f1e89d336414ac" translate="yes" xml:space="preserve">
          <source>In general, the (polynomial) product of two C-series results in terms that are not in the Laguerre polynomial basis set. Thus, to express the product as a Laguerre series, it is necessary to &amp;ldquo;reproject&amp;rdquo; the product onto said basis set, which may produce &amp;ldquo;unintuitive&amp;rdquo; (but correct) results; see Examples section below.</source>
          <target state="translated">В общем, (полиномиальное) произведение двух C-серий приводит к терминам, которые не входят в базисный набор полиномов Лагерра. Таким образом, чтобы выразить продукт как серию Лагерра, необходимо &amp;laquo;перепроецировать&amp;raquo; продукт на указанный базисный набор, что может дать &amp;laquo;неинтуитивные&amp;raquo; (но правильные) результаты; см. раздел &amp;laquo;Примеры&amp;raquo; ниже.</target>
        </trans-unit>
        <trans-unit id="54659a570a760a1d9fe356eba1a0141427eabe1f" translate="yes" xml:space="preserve">
          <source>In general, the (polynomial) product of two C-series results in terms that are not in the Legendre polynomial basis set. Thus, to express the product as a Legendre series, it is necessary to &amp;ldquo;reproject&amp;rdquo; the product onto said basis set, which may produce &amp;ldquo;unintuitive&amp;rdquo; (but correct) results; see Examples section below.</source>
          <target state="translated">В общем, (полиномиальное) произведение двух C-серий приводит к терминам, не входящим в базисный набор полиномов Лежандра. Таким образом, чтобы выразить продукт как серию Лежандра, необходимо &amp;laquo;перепроецировать&amp;raquo; продукт на указанный базисный набор, что может дать &amp;laquo;неинтуитивные&amp;raquo; (но правильные) результаты; см. раздел &amp;laquo;Примеры&amp;raquo; ниже.</target>
        </trans-unit>
        <trans-unit id="afe18211391947a00635543978b5840ef054bbac" translate="yes" xml:space="preserve">
          <source>In general, the contents of signature files is case-sensitive. When scanning Fortran codes and writing a signature file, F2PY lowers all cases automatically except in multiline blocks or when &lt;code&gt;--no-lower&lt;/code&gt; option is used.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="de938489906c2e0d2c954a8201ef415c1aa719ca" translate="yes" xml:space="preserve">
          <source>In general, the result of differentiating a C-series needs to be &amp;ldquo;reprojected&amp;rdquo; onto the C-series basis set. Thus, typically, the result of this function is &amp;ldquo;unintuitive,&amp;rdquo; albeit correct; see Examples section below.</source>
          <target state="translated">В общем, результат дифференциации C-серии необходимо &amp;laquo;перепроецировать&amp;raquo; на базисный набор C-серии. Таким образом, обычно результат этой функции &amp;laquo;не интуитивно понятен&amp;raquo;, хотя и верен; см. раздел &amp;laquo;Примеры&amp;raquo; ниже.</target>
        </trans-unit>
        <trans-unit id="dc47191395ffa64cfa2441fe3b165eeaca46d090" translate="yes" xml:space="preserve">
          <source>In general, the result of differentiating a Hermite series does not resemble the same operation on a power series. Thus the result of this function may be &amp;ldquo;unintuitive,&amp;rdquo; albeit correct; see Examples section below.</source>
          <target state="translated">В общем, результат дифференцирования ряда Эрмита не похож на ту же операцию над степенным рядом. Таким образом, результат этой функции может быть &amp;laquo;не интуитивным&amp;raquo;, хотя и правильным; см. раздел &amp;laquo;Примеры&amp;raquo; ниже.</target>
        </trans-unit>
        <trans-unit id="c6b49ce2210116245bad6e5bb6d187bba65b38de" translate="yes" xml:space="preserve">
          <source>In general, the result of differentiating a Laguerre series does not resemble the same operation on a power series. Thus the result of this function may be &amp;ldquo;unintuitive,&amp;rdquo; albeit correct; see Examples section below.</source>
          <target state="translated">В общем, результат дифференцирования ряда Лагерра не похож на ту же операцию над степенным рядом. Таким образом, результат этой функции может быть &amp;laquo;не интуитивным&amp;raquo;, хотя и правильным; см. раздел &amp;laquo;Примеры&amp;raquo; ниже.</target>
        </trans-unit>
        <trans-unit id="68d490300c846fea9862fc337043383e53cf549a" translate="yes" xml:space="preserve">
          <source>In general, the result of differentiating a Legendre series does not resemble the same operation on a power series. Thus the result of this function may be &amp;ldquo;unintuitive,&amp;rdquo; albeit correct; see Examples section below.</source>
          <target state="translated">В общем, результат дифференцирования ряда Лежандра не похож на ту же операцию над степенным рядом. Таким образом, результат этой функции может быть &amp;laquo;не интуитивным&amp;raquo;, хотя и правильным; см. раздел &amp;laquo;Примеры&amp;raquo; ниже.</target>
        </trans-unit>
        <trans-unit id="ebd1b8db4b2a00ae669c478fea3d4050ecbe0184" translate="yes" xml:space="preserve">
          <source>In general, the shape of the resultant array will be the concatenation of the shape of the index array (or the shape that all the index arrays were broadcast to) with the shape of any unused dimensions (those not indexed) in the array being indexed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f5de4ef25adb6cfc3610a2fc23a9d5023b6dda95" translate="yes" xml:space="preserve">
          <source>In general, when the boolean array has fewer dimensions than the array being indexed, this is equivalent to y[b, &amp;hellip;], which means y is indexed by b followed by as many : as are needed to fill out the rank of y. Thus the shape of the result is one dimension containing the number of True elements of the boolean array, followed by the remaining dimensions of the array being indexed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a094c205647147c910d02f3a8f4ccd59ee07b5bd" translate="yes" xml:space="preserve">
          <source>In general, you should target these typemap signatures specifically where you want them, and then clear them after you are done.</source>
          <target state="translated">В общем,вы должны нацелить эти сигнатуры на карты типов именно туда,где вы хотите их видеть,а затем очистить их после того,как вы закончите.</target>
        </trans-unit>
        <trans-unit id="dd3e08bc1a57887f18c581f1dbde91b2bd716911" translate="yes" xml:space="preserve">
          <source>In higher dimensions, FFTs are used, e.g., for image analysis and filtering. The computational efficiency of the FFT means that it can also be a faster way to compute large convolutions, using the property that a convolution in the time domain is equivalent to a point-by-point multiplication in the frequency domain.</source>
          <target state="translated">В более высоких размерах БПФ используются,например,для анализа и фильтрации изображений.Вычислительная эффективность БПФ означает,что она также может быть более быстрым способом вычисления больших сверток,используя свойство,что свертка во временной области эквивалентна поточному умножению в частотной области.</target>
        </trans-unit>
        <trans-unit id="b07ddb1ceb7095c96bdb1f519b0d36703eda5462" translate="yes" xml:space="preserve">
          <source>In interactions between &lt;code&gt;ArrayLike&lt;/code&gt; objects and numbers or numpy arrays, the result is always another &lt;code&gt;ArrayLike&lt;/code&gt;:</source>
          <target state="translated">При взаимодействии между объектами &lt;code&gt;ArrayLike&lt;/code&gt; и числами или множественными массивами результатом всегда будет другой &lt;code&gt;ArrayLike&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="859968bca8846c38eabf846201d96ee61f1cb6f0" translate="yes" xml:space="preserve">
          <source>In linear space, the sequence starts at &lt;code&gt;base ** start&lt;/code&gt; (&lt;code&gt;base&lt;/code&gt; to the power of &lt;code&gt;start&lt;/code&gt;) and ends with &lt;code&gt;base ** stop&lt;/code&gt; (see &lt;code&gt;endpoint&lt;/code&gt; below).</source>
          <target state="translated">В линейном пространстве последовательность начинается с &lt;code&gt;base ** start&lt;/code&gt; ( &lt;code&gt;base&lt;/code&gt; в степени &lt;code&gt;start&lt;/code&gt; ) и заканчивается &lt;code&gt;base ** stop&lt;/code&gt; (см. &lt;code&gt;endpoint&lt;/code&gt; ниже).</target>
        </trans-unit>
        <trans-unit id="e8987c188d2dc12518e96e9c96bc6fb94bc0c364" translate="yes" xml:space="preserve">
          <source>In many circumstances, datasets can be incomplete or tainted by the presence of invalid data. For example, a sensor may have failed to record a data, or recorded an invalid value. The &lt;a href=&quot;#module-numpy.ma&quot;&gt;&lt;code&gt;numpy.ma&lt;/code&gt;&lt;/a&gt; module provides a convenient way to address this issue, by introducing masked arrays.</source>
          <target state="translated">Во многих случаях наборы данных могут быть неполными или испорченными из-за наличия неверных данных. Например, датчик мог не записать данные или записал неверное значение. Модуль &lt;a href=&quot;#module-numpy.ma&quot;&gt; &lt;code&gt;numpy.ma&lt;/code&gt; &lt;/a&gt; предоставляет удобный способ решения этой проблемы путем введения маскированных массивов.</target>
        </trans-unit>
        <trans-unit id="af19adb5953933b119cf6e38053a7bd63ddf0076" translate="yes" xml:space="preserve">
          <source>In memory overlap checks, assume that operands with &lt;code&gt;NPY_ITER_OVERLAP_ASSUME_ELEMENTWISE&lt;/code&gt; enabled are accessed only in the iterator order.</source>
          <target state="translated">При проверке перекрытия памяти предположим, что операнды с включенным &lt;code&gt;NPY_ITER_OVERLAP_ASSUME_ELEMENTWISE&lt;/code&gt; доступны только в порядке итератора.</target>
        </trans-unit>
        <trans-unit id="bd53b438575f194778c1656e57b318d6b487ca6a" translate="yes" xml:space="preserve">
          <source>In more detail</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f9e0501d6a0c7c31ee0e8c5ea3ca4747d4c70398" translate="yes" xml:space="preserve">
          <source>In most cases &lt;code&gt;np.ndim(x) == 0&lt;/code&gt; should be used instead of this function, as that will also return true for 0d arrays. This is how numpy overloads functions in the style of the &lt;code&gt;dx&lt;/code&gt; arguments to &lt;a href=&quot;numpy.gradient#numpy.gradient&quot;&gt;&lt;code&gt;gradient&lt;/code&gt;&lt;/a&gt; and the &lt;code&gt;bins&lt;/code&gt; argument to &lt;a href=&quot;numpy.histogram#numpy.histogram&quot;&gt;&lt;code&gt;histogram&lt;/code&gt;&lt;/a&gt;. Some key differences:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a5c743fe265d56156ca24d5e10903518aede0334" translate="yes" xml:space="preserve">
          <source>In most use cases the best way to install NumPy on your system is by using a pre-built package for your operating system. Please see &lt;a href=&quot;https://scipy.org/install.html&quot;&gt;https://scipy.org/install.html&lt;/a&gt; for links to available options.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="763b6e76c1532989efe227d788422ad02bd06f94" translate="yes" xml:space="preserve">
          <source>In normal buffering, the size of each inner loop is equal to the buffer size, or possibly larger if &lt;a href=&quot;#c.NPY_ITER_GROWINNER&quot;&gt;&lt;code&gt;NPY_ITER_GROWINNER&lt;/code&gt;&lt;/a&gt; is specified. If &lt;a href=&quot;#c.NPY_ITER_REDUCE_OK&quot;&gt;&lt;code&gt;NPY_ITER_REDUCE_OK&lt;/code&gt;&lt;/a&gt; is enabled and a reduction occurs, the inner loops may become smaller depending on the structure of the reduction.</source>
          <target state="translated">При нормальной буферизации размер каждого внутреннего цикла равен размеру буфера или, возможно, больше, если &lt;a href=&quot;#c.NPY_ITER_GROWINNER&quot;&gt; &lt;code&gt;NPY_ITER_GROWINNER&lt;/code&gt; &lt;/a&gt; . Если &lt;a href=&quot;#c.NPY_ITER_REDUCE_OK&quot;&gt; &lt;code&gt;NPY_ITER_REDUCE_OK&lt;/code&gt; &lt;/a&gt; включен и происходит сокращение, внутренние циклы могут стать меньше в зависимости от структуры сокращения.</target>
        </trans-unit>
        <trans-unit id="2c60bcd4aa111fe243ec4d9e38a39cdb9410fc32" translate="yes" xml:space="preserve">
          <source>In numpy versions &amp;gt;= 1.7.0 the &lt;code&gt;basis&lt;/code&gt; and &lt;code&gt;cast&lt;/code&gt; class methods are also available. The cast method works like the convert method while the basis method returns the basis polynomial of given degree:</source>
          <target state="translated">В Numpy версии&amp;gt; = 1.7.0 на &lt;code&gt;basis&lt;/code&gt; и &lt;code&gt;cast&lt;/code&gt; методы класса также доступны. Метод cast работает так же, как и метод convert, в то время как базовый метод возвращает базисный полином заданной степени:</target>
        </trans-unit>
        <trans-unit id="9a36a11020261b9ce301df38d29f32b272d351ef" translate="yes" xml:space="preserve">
          <source>In order to add a Python package to SciPy, its build script (&lt;code&gt;setup.py&lt;/code&gt;) must meet certain requirements. The most important requirement is that the package define a &lt;code&gt;configuration(parent_package='',top_path=None)&lt;/code&gt; function which returns a dictionary suitable for passing to &lt;code&gt;numpy.distutils.core.setup(..)&lt;/code&gt;. To simplify the construction of this dictionary, &lt;code&gt;numpy.distutils.misc_util&lt;/code&gt; provides the &lt;code&gt;Configuration&lt;/code&gt; class, described below.</source>
          <target state="translated">Чтобы добавить пакет Python в SciPy, его сценарий сборки ( &lt;code&gt;setup.py&lt;/code&gt; ) должен соответствовать определенным требованиям. Наиболее важным требованием является определение в пакете функции &lt;code&gt;configuration(parent_package='',top_path=None)&lt;/code&gt; которая возвращает словарь, подходящий для перехода к &lt;code&gt;numpy.distutils.core.setup(..)&lt;/code&gt; . Чтобы упростить создание этого словаря, &lt;code&gt;numpy.distutils.misc_util&lt;/code&gt; предоставляет класс &lt;code&gt;Configuration&lt;/code&gt; , описанный ниже.</target>
        </trans-unit>
        <trans-unit id="9195216b823d914ae553da6509b9641a3f8c45ff" translate="yes" xml:space="preserve">
          <source>In order to extract information from a given matrix, we can use the SVD to obtain 3 arrays which can be multiplied to obtain the original matrix. From the theory of linear algebra, given a matrix</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="60fc69a196f8bf024afb0ed60ca3a78c46194201" translate="yes" xml:space="preserve">
          <source>In order to improve the interface, directives should be provided. This is accomplished by constructing an interface definition file. It is usually best to start from the interface file that f2py can produce (where it gets its default behavior from). To get f2py to generate the interface file use the -h option:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d5eaeb15f58484d8774fc878d68cb55c966f0844" translate="yes" xml:space="preserve">
          <source>In order to make use of the C-API from another extension module, the &lt;a href=&quot;#c.import_array&quot;&gt;&lt;code&gt;import_array&lt;/code&gt;&lt;/a&gt; function must be called. If the extension module is self-contained in a single .c file, then that is all that needs to be done. If, however, the extension module involves multiple files where the C-API is needed then some additional steps must be taken.</source>
          <target state="translated">Чтобы использовать C-API из другого модуля расширения, необходимо &lt;a href=&quot;#c.import_array&quot;&gt; &lt;code&gt;import_array&lt;/code&gt; &lt;/a&gt; функцию import_array . Если модуль расширения находится в отдельном файле .c, то это все, что нужно сделать. Если, однако, модуль расширения включает несколько файлов, в которых требуется C-API, необходимо предпринять некоторые дополнительные шаги.</target>
        </trans-unit>
        <trans-unit id="c34adc34291107e6d105c5cd2a716fc5c0f9914c" translate="yes" xml:space="preserve">
          <source>In order to pay-off (i.e., have a future-value of 0) the $200,000 obtained today, a monthly payment of $1,854.02 would be required. Note that this example illustrates usage of &lt;a href=&quot;numpy.fv#numpy.fv&quot;&gt;&lt;code&gt;fv&lt;/code&gt;&lt;/a&gt; having a default value of 0.</source>
          <target state="translated">Чтобы выплатить (т. Е. Иметь будущую стоимость 0) 200 000 долларов, полученных сегодня, потребуется ежемесячный платеж в размере 1 854,02 доллара. Обратите внимание, что этот пример иллюстрирует использование &lt;a href=&quot;numpy.fv#numpy.fv&quot;&gt; &lt;code&gt;fv&lt;/code&gt; &lt;/a&gt; со значением по умолчанию 0.</target>
        </trans-unit>
        <trans-unit id="5f37a6feac047af18be703227c7a9f994a3a9fcc" translate="yes" xml:space="preserve">
          <source>In order to prevent clobbering object pointers in fields of &lt;code&gt;numpy.object&lt;/code&gt; type, numpy currently does not allow views of structured arrays containing objects.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1b7199a5c1d305f9cc30b6b7f154cecb0f39e6d3" translate="yes" xml:space="preserve">
          <source>In order to remove elements from an array, it&amp;rsquo;s simple to use indexing to select the elements that you want to keep.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b465797b5de029b2baabd94edf6595fe5ee0db1d" translate="yes" xml:space="preserve">
          <source>In order to start using NumPy and all of the functions available in NumPy, you&amp;rsquo;ll need to import it. This can be easily done with this import statement:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cdf699c411308f89c9b3b067e51b1e307dfb7a9f" translate="yes" xml:space="preserve">
          <source>In other words, &lt;code&gt;flags = divide + 2*over + 4*under + 8*invalid&lt;/code&gt;.</source>
          <target state="translated">Другими словами, &lt;code&gt;flags = divide + 2*over + 4*under + 8*invalid&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f91eee16dbc3f050fa038e2c5209d53822e69e47" translate="yes" xml:space="preserve">
          <source>In other words, each entry &lt;code&gt;out[i,j,...,:]&lt;/code&gt; is an N-dimensional value drawn from the distribution.</source>
          <target state="translated">Другими словами, каждая запись &lt;code&gt;out[i,j,...,:]&lt;/code&gt; представляет собой N-мерное значение, полученное из распределения.</target>
        </trans-unit>
        <trans-unit id="b7dcdc5e279e7f5cb5fcdbe1eac1b3a0742ee26b" translate="yes" xml:space="preserve">
          <source>In other words, the usage of info is exactly the same as when using blas_info and co.</source>
          <target state="translated">Другими словами,использование информации точно такое же,как и при использовании blas_info и co.</target>
        </trans-unit>
        <trans-unit id="84851d19bec7dda86a1de5ddcd1548f32366d2fa" translate="yes" xml:space="preserve">
          <source>In our case,</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d08ff7590113d034602ad8a932c13f96f4f84856" translate="yes" xml:space="preserve">
          <source>In our case, we are approximating the grayscale portion of the image, so we will use the colormap &lt;code&gt;gray&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="41f0de1dccddf6867cedf88d3dd90186911881e1" translate="yes" xml:space="preserve">
          <source>In our examples, we will treat the input array with a complex data type, so that we can take square roots of negative numbers. Without enabling copies or buffering mode, the iterator will raise an exception if the data type doesn&amp;rsquo;t match precisely.</source>
          <target state="translated">В наших примерах мы будем рассматривать входной массив со сложным типом данных, чтобы мы могли извлекать квадратные корни из отрицательных чисел. Без включения копирования или режима буферизации итератор вызовет исключение, если тип данных не соответствует точно.</target>
        </trans-unit>
        <trans-unit id="f3aea51c3c320aa437734a573490879eb2569913" translate="yes" xml:space="preserve">
          <source>In place fancy indexing for ufuncs</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f02a14688f33a1cd645cff2ad5ad3ea73913fd03" translate="yes" xml:space="preserve">
          <source>In place operations will perform the calculation using the precision decided by the data type of the two operands, but will silently downcast the result (if necessary) so it can fit back into the array. Therefore, for mixed precision calculations, &lt;code&gt;A {op}=
B&lt;/code&gt; can be different than &lt;code&gt;A = A {op} B&lt;/code&gt;. For example, suppose &lt;code&gt;a = ones((3,3))&lt;/code&gt;. Then, &lt;code&gt;a += 3j&lt;/code&gt; is different than &lt;code&gt;a = a +
3j&lt;/code&gt;: while they both perform the same computation, &lt;code&gt;a += 3&lt;/code&gt; casts the result to fit back in &lt;code&gt;a&lt;/code&gt;, whereas &lt;code&gt;a = a + 3j&lt;/code&gt; re-binds the name &lt;code&gt;a&lt;/code&gt; to the result.</source>
          <target state="translated">Операции на месте будут выполнять вычисление с использованием точности, определяемой типом данных двух операндов, но автоматически понижают результат (при необходимости), чтобы он мог снова поместиться в массив. Таким образом, для смешанных точности расчетов, &lt;code&gt;A {op}= B&lt;/code&gt; может быть иным , чем &lt;code&gt;A = A {op} B&lt;/code&gt; . Например, предположим, что &lt;code&gt;a = ones((3,3))&lt;/code&gt; . Тогда &lt;code&gt;a += 3j&lt;/code&gt; отличается от &lt;code&gt;a = a + 3j&lt;/code&gt; : в то время как они оба выполняют одно и то же вычисление, &lt;code&gt;a += 3&lt;/code&gt; приводит результат, чтобы он уместился обратно в &lt;code&gt;a&lt;/code&gt; , тогда как &lt;code&gt;a = a + 3j&lt;/code&gt; повторно связывает имя &lt;code&gt;a&lt;/code&gt; с результат.</target>
        </trans-unit>
        <trans-unit id="3ffbc219d4925b162d68445ad04161e81b80a2ae" translate="yes" xml:space="preserve">
          <source>In practice, we anticipate that for most Steering Council decisions (e.g., voting in new members) a more informal process will suffice.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="211d3795b0d3cedf14ae00bfdd7e3e38d86df021" translate="yes" xml:space="preserve">
          <source>In prior versions of NumPy, the datetime64 type always stored times in UTC. By default, creating a datetime64 object from a string or printing it would convert from or to local time:</source>
          <target state="translated">В предыдущих версиях NumPy тип datetime64 всегда хранил время по UTC.По умолчанию создание объекта datetime64 из строки или вывод его на печать приведет к преобразованию из локального времени или в локальное время:</target>
        </trans-unit>
        <trans-unit id="bb94af890255a1752661e16a2eacce9c1ad12713" translate="yes" xml:space="preserve">
          <source>In row-major, C-style order, in two dimensions, the row index varies the slowest, and the column index the quickest. This can be generalized to multiple dimensions, where row-major order implies that the index along the first axis varies slowest, and the index along the last quickest. The opposite holds for column-major, Fortran-style index ordering.</source>
          <target state="translated">В порядке строк-мажор,в С-стиле,в двух измерениях,строковый индекс изменяется медленнее всего,а столбец индекса-быстрее всего.Это можно обобщить до нескольких измерений,где порядок следования рядов предполагает,что индекс по первой оси изменяется медленнее всего,а индекс по последней-быстрее всего.Противоположное значение имеет порядок следования столбцов,в стиле Фортран.</target>
        </trans-unit>
        <trans-unit id="fa32d137f104b735ab84633f3591ddf26cbba0ca" translate="yes" xml:space="preserve">
          <source>In short:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="507aaff0e5cc21d7011bc819d2bd20f0b309484f" translate="yes" xml:space="preserve">
          <source>In single precision, &lt;a href=&quot;#numpy.mean&quot;&gt;&lt;code&gt;mean&lt;/code&gt;&lt;/a&gt; can be inaccurate:</source>
          <target state="translated">При одинарной точности &lt;a href=&quot;#numpy.mean&quot;&gt; &lt;code&gt;mean&lt;/code&gt; &lt;/a&gt; может быть неточным:</target>
        </trans-unit>
        <trans-unit id="9b1dbcac5dd55e1c7b0ed7b38aff1c0737c2f620" translate="yes" xml:space="preserve">
          <source>In single precision, std() can be inaccurate:</source>
          <target state="translated">При одинаковой точности std()может быть неточным:</target>
        </trans-unit>
        <trans-unit id="ca04a495cdff9e1119115547af374f5b2a4d64ac" translate="yes" xml:space="preserve">
          <source>In single precision, var() can be inaccurate:</source>
          <target state="translated">При одинаковой точности var()может быть неточным:</target>
        </trans-unit>
        <trans-unit id="568553829625c2078673593fe2ee401327874ad7" translate="yes" xml:space="preserve">
          <source>In some cases, an appropriate use of the roll and the offset is necessary to get a desired answer.</source>
          <target state="translated">В некоторых случаях для получения желаемого ответа необходимо соответствующее использование вала и смещения.</target>
        </trans-unit>
        <trans-unit id="bac6ec658cf559e360b3f959f986ce1e7d727c27" translate="yes" xml:space="preserve">
          <source>In some cases, broadcasting stretches both arrays to form an output array larger than either of the initial arrays.*</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ac0960cf0185d8fe7d74b182c3299905c5bc5818" translate="yes" xml:space="preserve">
          <source>In some cases, such as structured arrays and the &lt;a href=&quot;arrays.classes#numpy.class.__array__&quot;&gt;&lt;code&gt;__array__&lt;/code&gt;&lt;/a&gt; interface, a data type needs to be used to make sense of the object. When this is needed, provide a Descr for &amp;lsquo;requested_dtype&amp;rsquo;, otherwise provide NULL. This reference is not stolen. Also, if the requested dtype doesn&amp;rsquo;t modify the interpretation of the input, out_dtype will still get the &amp;ldquo;innate&amp;rdquo; dtype of the object, not the dtype passed in &amp;lsquo;requested_dtype&amp;rsquo;.</source>
          <target state="translated">В некоторых случаях, таких как структурированные массивы и интерфейс &lt;a href=&quot;arrays.classes#numpy.class.__array__&quot;&gt; &lt;code&gt;__array__&lt;/code&gt; &lt;/a&gt; , необходимо использовать тип данных для понимания объекта. Когда это необходимо, укажите Descr для &amp;laquo;required_dtype&amp;raquo;, в противном случае укажите NULL. Эта ссылка не украдена. Кроме того, если запрошенный dtype не изменяет интерпретацию ввода, out_dtype все равно получит &amp;laquo;внутренний&amp;raquo; dtype объекта, а не dtype, переданный в &amp;laquo;required_dtype&amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="facb6bd6062bf723ed24036374202b109145e308" translate="yes" xml:space="preserve">
          <source>In some cases, we are not interested in all the columns of the data but only a few of them. We can select which columns to import with the &lt;code&gt;usecols&lt;/code&gt; argument. This argument accepts a single integer or a sequence of integers corresponding to the indices of the columns to import. Remember that by convention, the first column has an index of 0. Negative integers behave the same as regular Python negative indexes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ef2ea8dc139c52f2365b3742b195c7e8c88faf3c" translate="yes" xml:space="preserve">
          <source>In some cases, you will see this form of the commit command: &lt;code&gt;git commit
-a&lt;/code&gt;. The extra &lt;code&gt;-a&lt;/code&gt; flag automatically commits all modified files and removes all deleted files. This can save you some typing of numerous &lt;code&gt;git
add&lt;/code&gt; commands; however, it can add unwanted changes to a commit if you&amp;rsquo;re not careful. For more information, see &lt;a href=&quot;http://www.gitready.com/beginner/2009/01/18/the-staging-area.html&quot;&gt;why the -a flag?&lt;/a&gt; - and the helpful use-case description in the &lt;a href=&quot;https://tomayko.com/writings/the-thing-about-git&quot;&gt;tangled working copy problem&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="341cdd9b0329316960c0e4cc444da230117b1062" translate="yes" xml:space="preserve">
          <source>In some future release, it will return a read/write view and writing to the returned array will alter your original array. The returned array will have the same type as the input array.</source>
          <target state="translated">В некоторых последующих релизах он будет возвращать вид чтения/записи,а запись в возвращаемый массив изменит ваш оригинальный массив.Возвращаемый массив будет иметь тот же тип,что и входной массив.</target>
        </trans-unit>
        <trans-unit id="f5ee90b2a39e9fa80b16d394e14dd0a33a028120" translate="yes" xml:space="preserve">
          <source>In some situations, it is possible that you could use the &lt;code&gt;%numpy_typemaps&lt;/code&gt; macro to implement typemaps for your own types. See the &lt;a href=&quot;#other-common-types-bool&quot;&gt;Other Common Types: bool&lt;/a&gt; or &lt;a href=&quot;#other-common-types-complex&quot;&gt;Other Common Types: complex&lt;/a&gt; sections for examples. Another situation is if your dimensions are of a type other than &lt;code&gt;int&lt;/code&gt; (say &lt;code&gt;long&lt;/code&gt; for example):</source>
          <target state="translated">В некоторых ситуациях возможно, что вы можете использовать макрос &lt;code&gt;%numpy_typemaps&lt;/code&gt; для реализации карт типов для ваших собственных типов. См. Примеры в разделах &amp;laquo; &lt;a href=&quot;#other-common-types-bool&quot;&gt;Другие распространенные типы: bool&amp;raquo;&lt;/a&gt; или &amp;laquo; &lt;a href=&quot;#other-common-types-complex&quot;&gt;Другие общие типы: сложные&amp;raquo;&lt;/a&gt; . Другая ситуация, если ваши размеры имеют тип, отличный от &lt;code&gt;int&lt;/code&gt; (например, &lt;code&gt;long&lt;/code&gt; ):</target>
        </trans-unit>
        <trans-unit id="ef54aceba82e6cd0b5d227cf1545504de22cdfa8" translate="yes" xml:space="preserve">
          <source>In that case, each item is associated to a column, in order.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4128e61e6436506814002ae295957c7fd56f0e0e" translate="yes" xml:space="preserve">
          <source>In that repository edit the files:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3d0c88a0902d8f4e29b2260087b409a1f0c6bbf0" translate="yes" xml:space="preserve">
          <source>In the 1-D and 0-D case, the indexing and sparse keywords have no effect.</source>
          <target state="translated">В случае 1-D и 0-D индексирование и разреженные ключевые слова не имеют эффекта.</target>
        </trans-unit>
        <trans-unit id="82b4d34298ee4da5c6486a950c439f010b328116" translate="yes" xml:space="preserve">
          <source>In the above example F2PY was able to guess accurately the signature of a call-back function. However, sometimes F2PY cannot establish the signature as one would wish and then the signature of a call-back function must be modified in the signature file manually. Namely, signature files may contain special modules (the names of such modules contain a substring &lt;code&gt;__user__&lt;/code&gt;) that collect various signatures of call-back functions. Callback arguments in routine signatures have attribute &lt;code&gt;external&lt;/code&gt; (see also &lt;code&gt;intent(callback)&lt;/code&gt; attribute). To relate a callback argument and its signature in &lt;code&gt;__user__&lt;/code&gt; module block, use &lt;code&gt;use&lt;/code&gt; statement as illustrated below. The same signature of a callback argument can be referred in different routine signatures.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e263de7df2b576cf438fac441850586c983ab809" translate="yes" xml:space="preserve">
          <source>In the case of double precision tests, this will return the python function &lt;code&gt;Vector.doubleLength&lt;/code&gt;.</source>
          <target state="translated">В случае тестов двойной точности это вернет функцию Python &lt;code&gt;Vector.doubleLength&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a0240da2483005a9c53b4aad1de6618f577c43aa" translate="yes" xml:space="preserve">
          <source>In the common 2-D case (N=1), the block structure can be visualized:</source>
          <target state="translated">В общем 2-D случае (N=1)можно визуализировать структуру блока:</target>
        </trans-unit>
        <trans-unit id="e138055380190b3c93b794e532e7d0c34dce613a" translate="yes" xml:space="preserve">
          <source>In the end, which you do for Fortran or C depends on which is more important, not reordering data or preserving the indexing convention. For large images, reordering data is potentially expensive, and often the indexing convention is inverted to avoid that.</source>
          <target state="translated">В конце концов,то,что вы делаете для Fortran или C,зависит от того,что важнее,а не переупорядочивание данных или сохранение конвенции об индексировании.Для больших изображений переупорядочивание данных потенциально дорогостоящее,и часто соглашение об индексировании инвертируется,чтобы избежать этого.</target>
        </trans-unit>
        <trans-unit id="8930375040ab76aae34fb47c1b34d1c268b41dae" translate="yes" xml:space="preserve">
          <source>In the event of any conflict of interest, a committee member must immediately notify the other members, and recuse themselves if necessary.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b1d5a2c6f7d9d2516af28db041f10097409dc991" translate="yes" xml:space="preserve">
          <source>In the example above, we used the fact that by default, &lt;code&gt;dtype=float&lt;/code&gt;. By giving a sequence of names, we are forcing the output to a structured dtype.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6eb66ccf87f3461ec66b2cc1735ef182a062917a" translate="yes" xml:space="preserve">
          <source>In the file, array data starts at this offset. Since &lt;code&gt;offset&lt;/code&gt; is measured in bytes, it should normally be a multiple of the byte-size of &lt;a href=&quot;numpy.dtype#numpy.dtype&quot;&gt;&lt;code&gt;dtype&lt;/code&gt;&lt;/a&gt;. When &lt;code&gt;mode != 'r'&lt;/code&gt;, even positive offsets beyond end of file are valid; The file will be extended to accommodate the additional data. By default, &lt;code&gt;memmap&lt;/code&gt; will start at the beginning of the file, even if &lt;code&gt;filename&lt;/code&gt; is a file pointer &lt;code&gt;fp&lt;/code&gt; and &lt;code&gt;fp.tell() != 0&lt;/code&gt;.</source>
          <target state="translated">В файле данные массива начинаются с этого смещения. Поскольку &lt;code&gt;offset&lt;/code&gt; измеряется в байтах, обычно оно должно быть кратно размеру байта &lt;a href=&quot;numpy.dtype#numpy.dtype&quot;&gt; &lt;code&gt;dtype&lt;/code&gt; &lt;/a&gt; . Когда &lt;code&gt;mode != 'r'&lt;/code&gt; , допустимы даже положительные смещения за пределами конца файла; Файл будет расширен для размещения дополнительных данных. По умолчанию &lt;code&gt;memmap&lt;/code&gt; запускается в начале файла, даже если &lt;code&gt;filename&lt;/code&gt; является указателем файла &lt;code&gt;fp&lt;/code&gt; и &lt;code&gt;fp.tell() != 0&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6d51d7e744b66162bcb271fa8e86dbafebc0e214" translate="yes" xml:space="preserve">
          <source>In the first case the lower bound of the integration is set to -1 and the integration constant is 0. In the second the constant of integration is set to 1 as well. Differentiation is simpler since the only option is the number of times the polynomial is differentiated:</source>
          <target state="translated">В первом случае нижняя граница интегрирования устанавливается равной -1,а константа интегрирования-0,во втором константа интегрирования также устанавливается равной 1.Дифференциация проще,так как единственный вариант-это число раз дифференцирования многочлена:</target>
        </trans-unit>
        <trans-unit id="39042dbdcabf0496e03a08644bb7e129fe61d278" translate="yes" xml:space="preserve">
          <source>In the first case, the dimensions resulting from the advanced indexing operation come first in the result array, and the subspace dimensions after that. In the second case, the dimensions from the advanced indexing operations are inserted into the result array at the same spot as they were in the initial array (the latter logic is what makes simple advanced indexing behave just like slicing).</source>
          <target state="translated">В первом случае в результирующем массиве сначала идут размеры,полученные в результате операции расширенной индексации,а затем-размеры подпространства.Во втором случае размеры,полученные в результате операции расширенной индексации,вставляются в результирующий массив в том же месте,где они были в исходном массиве (вторая логика заставляет простую расширенную индексацию вести себя так же,как и нарезку).</target>
        </trans-unit>
        <trans-unit id="fee9951c9cac899e8dc4b73ca21eaf580eee1e11" translate="yes" xml:space="preserve">
          <source>In the following descriptions, we reference a generic &lt;code&gt;DATA_TYPE&lt;/code&gt;, which could be any of the C data types listed above, and &lt;code&gt;DIM_TYPE&lt;/code&gt; which should be one of the many types of integers.</source>
          <target state="translated">В следующих описаниях мы &lt;code&gt;DATA_TYPE&lt;/code&gt; на общий DATA_TYPE , который может быть любым из типов данных C, перечисленных выше, и на &lt;code&gt;DIM_TYPE&lt;/code&gt; , который должен быть одним из многих типов целых чисел.</target>
        </trans-unit>
        <trans-unit id="0a77a218f61bf2d19822ca93ebcee58f5aa1e669" translate="yes" xml:space="preserve">
          <source>In the following example, both the &lt;code&gt;A&lt;/code&gt; and &lt;code&gt;B&lt;/code&gt; arrays have axes with length one that are expanded to a larger size during the broadcast operation:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="56c7aa7e2fe12577360a1a373c78ed632827aefd" translate="yes" xml:space="preserve">
          <source>In the following example, both the &lt;code&gt;A&lt;/code&gt; and &lt;code&gt;B&lt;/code&gt; arrays have axes with length one that are expanded to a larger size in a broadcast operation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7b0aabec281905f99f49d1bbd6f2c64a2c3c69d5" translate="yes" xml:space="preserve">
          <source>In the following example, the second column is converted from as string representing a percentage to a float between 0 and 1:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4b029336d8b412b884840fa6a1fbeb3e45d0f30b" translate="yes" xml:space="preserve">
          <source>In the following example, we suppose that the missing values are flagged with &lt;code&gt;&quot;N/A&quot;&lt;/code&gt; in the first column and by &lt;code&gt;&quot;???&quot;&lt;/code&gt; in the third column. We wish to transform these missing values to 0 if they occur in the first and second column, and to -999 if they occur in the last column:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fceed6223bcf512a691c7903c36d65343ab22b97" translate="yes" xml:space="preserve">
          <source>In the graph, we can see that although we have 768 singular values in &lt;code&gt;s&lt;/code&gt;, most of those (after the 150th entry or so) are pretty small. So it might make sense to use only the information related to the first (say, 50) &lt;em&gt;singular values&lt;/em&gt; to build a more economical approximation to our image.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="66d2fff5a851e4221aa19362249b2b84c5964134" translate="yes" xml:space="preserve">
          <source>In the next several sections we give example code that can be easily modified to create your own ufuncs. The examples are successively more complete or complicated versions of the logit function, a common function in statistical modeling. Logit is also interesting because, due to the magic of IEEE standards (specifically IEEE 754), all of the logit functions created below automatically have the following behavior.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1dc319444395eeb97927a05649519246dd32d72d" translate="yes" xml:space="preserve">
          <source>In the past most implementations used the &amp;ldquo;desc&amp;rdquo; member of the &lt;code&gt;PyCObject&lt;/code&gt; itself (do not confuse this with the &amp;ldquo;descr&amp;rdquo; member of the &lt;a href=&quot;c-api.types-and-structures#c.PyArrayInterface&quot;&gt;&lt;code&gt;PyArrayInterface&lt;/code&gt;&lt;/a&gt; structure above &amp;mdash; they are two separate things) to hold the pointer to the object exposing the interface. This is now an explicit part of the interface. Be sure to own a reference to the object when the &lt;code&gt;PyCObject&lt;/code&gt; is created using &lt;code&gt;PyCObject_FromVoidPtrAndDesc&lt;/code&gt;.</source>
          <target state="translated">В прошлом большинство реализаций использовали член &amp;laquo;desc&amp;raquo; самого &lt;code&gt;PyCObject&lt;/code&gt; (не путайте его с членом &amp;laquo; &lt;a href=&quot;c-api.types-and-structures#c.PyArrayInterface&quot;&gt; &lt;code&gt;PyArrayInterface&lt;/code&gt; &lt;/a&gt; структуры PyArrayInterface выше - это две разные вещи) для хранения указателя на объект, открывающий интерфейс. Теперь это явная часть интерфейса. Убедитесь, что у вас есть ссылка на объект, когда &lt;code&gt;PyCObject&lt;/code&gt; создается с помощью &lt;code&gt;PyCObject_FromVoidPtrAndDesc&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2cb71d475f8be6120fc976bd353b076b792b7f77" translate="yes" xml:space="preserve">
          <source>In the past most implementations used the &amp;ldquo;desc&amp;rdquo; member of the &lt;code&gt;PyCObject&lt;/code&gt; itself (do not confuse this with the &amp;ldquo;descr&amp;rdquo; member of the &lt;a href=&quot;c-api/types-and-structures#c.PyArrayInterface&quot;&gt;&lt;code&gt;PyArrayInterface&lt;/code&gt;&lt;/a&gt; structure above &amp;mdash; they are two separate things) to hold the pointer to the object exposing the interface. This is now an explicit part of the interface. Be sure to own a reference to the object when the &lt;code&gt;PyCObject&lt;/code&gt; is created using &lt;code&gt;PyCObject_FromVoidPtrAndDesc&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cfcf82ced52f76044f84d6258de886b7808506ff" translate="yes" xml:space="preserve">
          <source>In the range -1 &amp;lt;= &lt;code&gt;x&lt;/code&gt; &amp;lt;= 1 they are nice, equiripple functions lying between +/- 1. The same plots over the range -2 &amp;lt;= &lt;code&gt;x&lt;/code&gt; &amp;lt;= 2 look very different:</source>
          <target state="translated">В диапазоне -1 &amp;lt;= &lt;code&gt;x&lt;/code&gt; &amp;lt;= 1 они хороши, равноправные функции, лежащие между +/- 1. Те ​​же самые графики в диапазоне -2 &amp;lt;= &lt;code&gt;x&lt;/code&gt; &amp;lt;= 2 выглядят совсем по-другому:</target>
        </trans-unit>
        <trans-unit id="8d2fb588d0d5207847c4495ec3e5ed9b60e1f12d" translate="yes" xml:space="preserve">
          <source>In the same way, if we don&amp;rsquo;t give enough names to match the length of the dtype, the missing names will be defined with this default template:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9664dec4c702af778eb236a77580a7bb3b836b54" translate="yes" xml:space="preserve">
          <source>In the simplest case, there is only a &lt;em&gt;single&lt;/em&gt; advanced index. A single advanced index can for example replace a slice and the result array will be the same, however, it is a copy and may have a different memory layout. A slice is preferable when it is possible.</source>
          <target state="translated">В простейшем случае есть только &lt;em&gt;один&lt;/em&gt; расширенный индекс. Один расширенный индекс может, например, заменить срез, и массив результатов будет таким же, однако это копия и может иметь другое расположение памяти. Ломтик предпочтительнее, когда это возможно.</target>
        </trans-unit>
        <trans-unit id="eaceaaeb778efa3a74e32f0e07667ae3c3a1ce24" translate="yes" xml:space="preserve">
          <source>In the source code, be sure to preface any issue or PR reference with &lt;code&gt;gh-xxxx&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c94924098b3009fa708b6c1aec49764e87be7477" translate="yes" xml:space="preserve">
          <source>In the table below, it is assumed that you have executed the following commands in Python:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d8a45b3135fa0c84b41da4d210f43fe96826517e" translate="yes" xml:space="preserve">
          <source>In the tables below, &lt;code&gt;platform?&lt;/code&gt; means that the type may not be available on all platforms. Compatibility with different C or Python types is indicated: two types are compatible if their data is of the same size and interpreted in the same way.</source>
          <target state="translated">В таблицах ниже &lt;code&gt;platform?&lt;/code&gt; означает, что этот тип может быть доступен не на всех платформах. Указывается совместимость с разными типами C или Python: два типа совместимы, если их данные имеют одинаковый размер и интерпретируются одинаково.</target>
        </trans-unit>
        <trans-unit id="97b2743d166cdad8253bc15ad591949789d4af86" translate="yes" xml:space="preserve">
          <source>In the worst case, if a Contributor is genuinely misusing their veto in an obstructive fashion to the detriment of the project, then they can be ejected from the project by consensus of the Steering Council &amp;ndash; see below.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3a7fe7582d8015e2df7c05da1f3a915ff663edd3" translate="yes" xml:space="preserve">
          <source>In this calculation, we can ignore the amount of numbers drawn from each stream. Each of the PRNGs we provide has some extra protection built in that avoids overlaps if the &lt;a href=&quot;bit_generators/generated/numpy.random.seedsequence#numpy.random.SeedSequence&quot;&gt;&lt;code&gt;SeedSequence&lt;/code&gt;&lt;/a&gt; pools differ in the slightest bit. &lt;a href=&quot;bit_generators/pcg64#numpy.random.PCG64&quot;&gt;&lt;code&gt;PCG64&lt;/code&gt;&lt;/a&gt; has</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="65a0a52b3e0dac0b940f22ccbd59e595b0b91828" translate="yes" xml:space="preserve">
          <source>In this calculation, we can ignore the amount of numbers drawn from each stream. Each of the PRNGs we provide has some extra protection built in that avoids overlaps if the &lt;a href=&quot;bit_generators/generated/numpy.random.seedsequence#numpy.random.SeedSequence&quot;&gt;&lt;code&gt;SeedSequence&lt;/code&gt;&lt;/a&gt; pools differ in the slightest bit. &lt;a href=&quot;bit_generators/pcg64#numpy.random.pcg64.PCG64&quot;&gt;&lt;code&gt;PCG64&lt;/code&gt;&lt;/a&gt; has</source>
          <target state="translated">В этом расчете мы можем игнорировать количество чисел, взятых из каждого потока. Каждый из предоставляемых нами PRNG имеет некоторую дополнительную встроенную защиту, позволяющую избежать перекрытия, если пулы &lt;a href=&quot;bit_generators/generated/numpy.random.seedsequence#numpy.random.SeedSequence&quot;&gt; &lt;code&gt;SeedSequence&lt;/code&gt; &lt;/a&gt; отличаются в малейшем бите. &lt;a href=&quot;bit_generators/pcg64#numpy.random.pcg64.PCG64&quot;&gt; &lt;code&gt;PCG64&lt;/code&gt; &lt;/a&gt; имеет</target>
        </trans-unit>
        <trans-unit id="fcdf80c260003d781b3489e23716b20d73cd0927" translate="yes" xml:space="preserve">
          <source>In this case, if the index arrays have a matching shape, and there is an index array for each dimension of the array being indexed, the resultant array has the same shape as the index arrays, and the values correspond to the index set for each position in the index arrays. In this example, the first index value is 0 for both index arrays, and thus the first value of the resultant array is y[0,0]. The next value is y[2,1], and the last is y[4,2].</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="89c8dba17ad2bf90a54597788476417de6721a53" translate="yes" xml:space="preserve">
          <source>In this case, we wanted to test solving a linear algebra problem using matrices of several data types, using &lt;code&gt;linalg.solve&lt;/code&gt; and &lt;code&gt;linalg.inv&lt;/code&gt;. The common test cases (for single-precision, double-precision, etc. matrices) are collected in &lt;code&gt;LinalgTestCase&lt;/code&gt;.</source>
          <target state="translated">В этом случае мы хотели протестировать решение задачи линейной алгебры с использованием матриц нескольких типов данных, используя &lt;code&gt;linalg.solve&lt;/code&gt; и &lt;code&gt;linalg.inv&lt;/code&gt; . Общие тестовые примеры (для матриц с одинарной точностью, двойной точностью и т. Д.) Собраны в &lt;code&gt;LinalgTestCase&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a876e5a0c738a8e265b4a962587a67aa3cabc3ca" translate="yes" xml:space="preserve">
          <source>In this chapter routine docstrings are presented, grouped by functionality. Many docstrings contain example code, which demonstrates basic usage of the routine. The examples assume that NumPy is imported with:</source>
          <target state="translated">В этой главе представлены обычные док-строки,сгруппированные по функциональности.Многие строки содержат пример кода,демонстрирующего основные принципы использования рутины.Примеры предполагают,что NumPy импортируется с:</target>
        </trans-unit>
        <trans-unit id="4030b7d01040d7db2670bc21cd8e6f75987d1ae6" translate="yes" xml:space="preserve">
          <source>In this context, consensus does &lt;em&gt;not&lt;/em&gt; require:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fb82fb6aef1a39fd7c11a037068f12eca825f3ae" translate="yes" xml:space="preserve">
          <source>In this example if &lt;code&gt;a&lt;/code&gt; is an ndarray, &amp;ldquo;fancy&amp;rdquo; indexing can be used.</source>
          <target state="translated">В этом примере, если &lt;code&gt;a&lt;/code&gt; - ndarray, можно использовать &amp;laquo;модную&amp;raquo; индексацию.</target>
        </trans-unit>
        <trans-unit id="8f824e9ad2dd27432acf7adb45ed2442b89417d6" translate="yes" xml:space="preserve">
          <source>In this example the spacing is also specified: uniform for axis=0 and non uniform for axis=1</source>
          <target state="translated">В этом примере также указано расстояние:равномерное для оси=0 и неравномерное для оси=1.</target>
        </trans-unit>
        <trans-unit id="328c265783b83eb29747b7db6d81add31503c3ba" translate="yes" xml:space="preserve">
          <source>In this example, I will show how the addition function and the filter function implemented previously using the other approaches can be implemented using ctypes. First, the C code which implements the algorithms contains the functions &lt;code&gt;zadd&lt;/code&gt;, &lt;code&gt;dadd&lt;/code&gt;, &lt;code&gt;sadd&lt;/code&gt;, &lt;code&gt;cadd&lt;/code&gt;, and &lt;code&gt;dfilter2d&lt;/code&gt;. The &lt;code&gt;zadd&lt;/code&gt; function is:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="97c094638bd844d3fa04f0e228195eec44c93a4f" translate="yes" xml:space="preserve">
          <source>In this example, a tuple of arrays was returned: one for each dimension. The first array represents the row indices where these values are found, and the second array represents the column indices where the values are found.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2729241cb81ad5eb6d0653ad987658266f4094e0" translate="yes" xml:space="preserve">
          <source>In this example, both the predictions and labels vectors contain three values, meaning &lt;code&gt;n&lt;/code&gt; has a value of three. After we carry out subtractions the values in the vector are squared. Then NumPy sums the values, and your result is the error value for that prediction and a score for the quality of the model.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e415859b6bc51789a95cf9e8d4d1433827763e1d" translate="yes" xml:space="preserve">
          <source>In this example, real input has an FFT which is Hermitian, i.e., symmetric in the real part and anti-symmetric in the imaginary part, as described in the &lt;a href=&quot;../routines.fft#module-numpy.fft&quot;&gt;&lt;code&gt;numpy.fft&lt;/code&gt;&lt;/a&gt; documentation:</source>
          <target state="translated">В этом примере реальный ввод имеет БПФ, которое является эрмитовым, т. &lt;a href=&quot;../routines.fft#module-numpy.fft&quot;&gt; &lt;code&gt;numpy.fft&lt;/code&gt; &lt;/a&gt; Симметричным в действительной части и антисимметричным в мнимой части, как описано в документации numpy.fft :</target>
        </trans-unit>
        <trans-unit id="ceae5efa8d3a6692e49c8c2886b52adb07addf1c" translate="yes" xml:space="preserve">
          <source>In this example, weight has more impact on the distance calculation than height because of the larger values. In practice, it is important to normalize the height and weight, often by their standard deviation across the data set, so that both have equal influence on the distance calculation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2c3e40fb7708f540adaa0b760c857b87aaa0e15a" translate="yes" xml:space="preserve">
          <source>In this shorthand notation any of the &lt;a href=&quot;../reference/arrays.dtypes#arrays-dtypes-constructing&quot;&gt;string dtype specifications&lt;/a&gt; may be used in a string and separated by commas. The itemsize and byte offsets of the fields are determined automatically, and the field names are given the default names &lt;code&gt;f0&lt;/code&gt;, &lt;code&gt;f1&lt;/code&gt;, etc.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="03bc9d15047b673ea201dcf5663747af818d9b11" translate="yes" xml:space="preserve">
          <source>In this tutorial, we will use a &lt;a href=&quot;https://en.wikipedia.org/wiki/Matrix_decomposition&quot;&gt;matrix decomposition&lt;/a&gt; from linear algebra, the Singular Value Decomposition, to generate a compressed approximation of an image. We&amp;rsquo;ll use the &lt;code&gt;face&lt;/code&gt; image from the &lt;a href=&quot;https://docs.scipy.org/doc/scipy/reference/misc.html#module-scipy.misc&quot;&gt;&lt;code&gt;scipy.misc&lt;/code&gt;&lt;/a&gt; module:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7b71631798c22c7379ee16411ed600d40ef635fc" translate="yes" xml:space="preserve">
          <source>In two dimensions, the DFT is defined as</source>
          <target state="translated">В двух измерениях DFT определяется как</target>
        </trans-unit>
        <trans-unit id="e78643ae03c902815fce8ed7873dad947453bab7" translate="yes" xml:space="preserve">
          <source>In versions 1.6 and earlier of NumPy, the following flags did not have the _ARRAY_ macro namespace in them. That form of the constant names is deprecated in 1.7.</source>
          <target state="translated">В версиях 1.6 и более ранних версиях NumPy следующие флаги не имели пространства имён макроса _ARRAY_.Эта форма имен констант устарела в 1.7.</target>
        </trans-unit>
        <trans-unit id="2eb3748bd4c40ee385c34a340546b34ff09c6d0f" translate="yes" xml:space="preserve">
          <source>In versions of NumPy prior to 1.7, this function always returned a new, independent array containing a copy of the values in the diagonal.</source>
          <target state="translated">В версиях NumPy до 1.7 эта функция всегда возвращала новый,независимый массив,содержащий копию значений по диагонали.</target>
        </trans-unit>
        <trans-unit id="0dd37ad2fb32e65c87fa0dbb4334407e5e86a994" translate="yes" xml:space="preserve">
          <source>In what NumPy version the object was deprecated, and when it will be removed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7e3012fb521e71655f173862b6d8385b1b505394" translate="yes" xml:space="preserve">
          <source>In-Place Arrays</source>
          <target state="translated">Массивы на месте</target>
        </trans-unit>
        <trans-unit id="4515cac8ae9188e7e6a2adf0d7162014d11595d3" translate="yes" xml:space="preserve">
          <source>In-place arrays are defined as arrays that are modified in-place. The input values may or may not be used, but the values at the time the function returns are significant. The provided Python argument must therefore be a NumPy array of the required type. The in-place signatures are</source>
          <target state="translated">Внутренние массивы определяются как массивы,которые изменяются на месте.Входные значения могут использоваться или не использоваться,но значения на момент возврата функции являются значительными.Поэтому предоставляемый аргумент Python должен быть массивом NumPy нужного типа.Входными сигнатурами являются</target>
        </trans-unit>
        <trans-unit id="e156e5cac1a2d58a18cbdda52494e20ca1917186" translate="yes" xml:space="preserve">
          <source>In-place sort.</source>
          <target state="translated">Сортировка на месте.</target>
        </trans-unit>
        <trans-unit id="79b98df32c7e9b7cb0e464788719f6ba70f3ff64" translate="yes" xml:space="preserve">
          <source>Incident reporting resolution &amp;amp; Code of Conduct enforcement</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0c1195d8c8b6b9e2d6ec4d935a14c881a29bcc75" translate="yes" xml:space="preserve">
          <source>Incorrect &lt;code&gt;threshold&lt;/code&gt; in &lt;code&gt;np.set_printoptions&lt;/code&gt; raises &lt;code&gt;TypeError&lt;/code&gt; or &lt;code&gt;ValueError&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2070997d3a1215cd23a07fdeb2caa1389920935f" translate="yes" xml:space="preserve">
          <source>Increased performance in &lt;code&gt;random.permutation&lt;/code&gt; for multidimensional arrays</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e7086e912a42ead51516c8a8180bf48b02a02ed8" translate="yes" xml:space="preserve">
          <source>Incremement the index and the dataptr members of the &lt;em&gt;iterator&lt;/em&gt; to point to the next element of the array. If the array is not (C-style) contiguous, also increment the N-dimensional coordinates array.</source>
          <target state="translated">Увеличьте индекс и элементы dataptr &lt;em&gt;итератора,&lt;/em&gt; чтобы они указывали на следующий элемент массива. Если массив не является непрерывным (в стиле C), также увеличьте массив N-мерных координат.</target>
        </trans-unit>
        <trans-unit id="7a7d2f744a7296cdaea426008f157d69008c6d52" translate="yes" xml:space="preserve">
          <source>Increment items 0 and 1, and increment item 2 twice:</source>
          <target state="translated">Увеличивайте пункты 0 и 1 и дважды увеличивайте пункт 2:</target>
        </trans-unit>
        <trans-unit id="aa0f6e205ff77646c8e4c26a5cd802d06b0ed1ab" translate="yes" xml:space="preserve">
          <source>Increment the multi-dimensional index by one.</source>
          <target state="translated">Увеличьте многомерный индекс на один.</target>
        </trans-unit>
        <trans-unit id="1431536c5cec1e86a2b496f9aea15a2431b6da9a" translate="yes" xml:space="preserve">
          <source>Increment the release number in setup.py. Release candidates should have &amp;ldquo;rc1&amp;rdquo; (or &amp;ldquo;rc2&amp;rdquo;, &amp;ldquo;rcN&amp;rdquo;) appended to the X.Y.Z format.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="47bbbc7bbd392dc811939b0ca8df290ae66b6625" translate="yes" xml:space="preserve">
          <source>Indeed, the fact is that Python indexing on lists and other sequences naturally leads to an outside-to inside ordering (the first index gets the largest grouping, the next the next largest, and the last gets the smallest element). Since image data are normally stored by rows, this corresponds to position within rows being the last item indexed.</source>
          <target state="translated">Действительно,дело в том,что индексирование на Python в списках и других последовательностях естественно приводит к внешнему порядку (первый индекс получает самую большую группировку,следующий-самую большую,а последний-наименьший элемент).Так как данные изображения обычно хранятся строками,это соответствует положению внутри строк,будучи последним индексируемым элементом.</target>
        </trans-unit>
        <trans-unit id="a955748860a9401904eff7aeb318142866860450" translate="yes" xml:space="preserve">
          <source>Independent Streams</source>
          <target state="translated">Независимые потоки</target>
        </trans-unit>
        <trans-unit id="c2df9b932637fe9d32a0f16da1c11873398f873d" translate="yes" xml:space="preserve">
          <source>Index</source>
          <target state="translated">Index</target>
        </trans-unit>
        <trans-unit id="9362b6e75e3f28d4a83666c8ba00890a4d410bc7" translate="yes" xml:space="preserve">
          <source>Index arrays</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8b7ef6cce7547dfa6d1e0bda509869536452ee0c" translate="yes" xml:space="preserve">
          <source>Index arrays may be combined with slices. For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c44a201623d0e3d087173369dce55b524d144281" translate="yes" xml:space="preserve">
          <source>Index arrays must be of integer type. Each value in the array indicates which value in the array to use in place of the index. To illustrate:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1a35691c6c1bb32304626e5515963a9a6c7ec2da" translate="yes" xml:space="preserve">
          <source>Index of the diagonal: 0 (the default) refers to the main diagonal, a positive value refers to an upper diagonal, and a negative value to a lower diagonal.</source>
          <target state="translated">Индекс диагонали:0 (по умолчанию)относится к главной диагонали,положительное значение-к верхней диагонали,отрицательное-к нижней диагонали.</target>
        </trans-unit>
        <trans-unit id="119920061dcb691e0fcbed0a1783c9e871f11ec5" translate="yes" xml:space="preserve">
          <source>Index of the diagonal: 0 refers to the main diagonal, a positive value refers to an upper diagonal, and a negative value to a lower diagonal.</source>
          <target state="translated">Индекс диагонали:0 относится к главной диагонали,положительное значение-к верхней диагонали,отрицательное-к нижней диагонали.</target>
        </trans-unit>
        <trans-unit id="57f71bf775773f532dceb2dabadcde07069670df" translate="yes" xml:space="preserve">
          <source>Indexes of the maximal elements of a N-dimensional array:</source>
          <target state="translated">Индексы максимальных элементов N-мерного массива:</target>
        </trans-unit>
        <trans-unit id="c30b085b29907fc8dd1fcc4ba9d8f5fab779ff0b" translate="yes" xml:space="preserve">
          <source>Indexes of the maximum values along an axis.</source>
          <target state="translated">Индексы максимальных значений вдоль оси.</target>
        </trans-unit>
        <trans-unit id="f9b599db4bf0df8d9bbcf7c5db6a037f6e6e69aa" translate="yes" xml:space="preserve">
          <source>Indexes of the minimum values along an axis.</source>
          <target state="translated">Индексы минимальных значений вдоль оси.</target>
        </trans-unit>
        <trans-unit id="9951861c21df18489a5872209655d6f9039b5e2a" translate="yes" xml:space="preserve">
          <source>Indexing</source>
          <target state="translated">Indexing</target>
        </trans-unit>
        <trans-unit id="ca22a585bfdf222b22aaead59f3666212fc40ce0" translate="yes" xml:space="preserve">
          <source>Indexing &lt;code&gt;x['field-name']&lt;/code&gt; returns a new &lt;a href=&quot;../glossary#term-view&quot;&gt;view&lt;/a&gt; to the array, which is of the same shape as &lt;em&gt;x&lt;/em&gt; (except when the field is a sub-array) but of data type &lt;code&gt;x.dtype['field-name']&lt;/code&gt; and contains only the part of the data in the specified field. Also &lt;a href=&quot;arrays.classes#arrays-classes-rec&quot;&gt;record array&lt;/a&gt; scalars can be &amp;ldquo;indexed&amp;rdquo; this way.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b59c12801d6fa741bd0be2abcd90167bf71d161c" translate="yes" xml:space="preserve">
          <source>Indexing &lt;code&gt;x['field-name']&lt;/code&gt; returns a new &lt;a href=&quot;https://docs.scipy.org/doc/numpy-1.17.0/glossary.html#term-view&quot;&gt;view&lt;/a&gt; to the array, which is of the same shape as &lt;em&gt;x&lt;/em&gt; (except when the field is a sub-array) but of data type &lt;code&gt;x.dtype['field-name']&lt;/code&gt; and contains only the part of the data in the specified field. Also &lt;a href=&quot;arrays.classes#arrays-classes-rec&quot;&gt;record array&lt;/a&gt; scalars can be &amp;ldquo;indexed&amp;rdquo; this way.</source>
          <target state="translated">Индексирование &lt;code&gt;x['field-name']&lt;/code&gt; возвращает новое &lt;a href=&quot;https://docs.scipy.org/doc/numpy-1.17.0/glossary.html#term-view&quot;&gt;представление&lt;/a&gt; массива, которое имеет ту же форму, что и &lt;em&gt;x&lt;/em&gt; (кроме случаев, когда поле является &lt;code&gt;x.dtype['field-name']&lt;/code&gt; ), но с типом данных x.dtype ['field-name'] и содержит только часть данных в указанном поле. Также &lt;a href=&quot;arrays.classes#arrays-classes-rec&quot;&gt;запись массива&lt;/a&gt; скаляров может быть &amp;laquo;проиндексирована&amp;raquo; таким образом.</target>
        </trans-unit>
        <trans-unit id="9542b665971d159d6c17d4f34752698e601626e8" translate="yes" xml:space="preserve">
          <source>Indexing MaskedArrays/Constants with &lt;code&gt;...&lt;/code&gt; (ellipsis) now returns MaskedArray</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a956de2c65434dac2e3f2395af98a63c09e0e921" translate="yes" xml:space="preserve">
          <source>Indexing Multi-dimensional arrays</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d29f8c2cdcd3c7159d7617a4b4b26d63a3389924" translate="yes" xml:space="preserve">
          <source>Indexing Structured Arrays</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="370bbc588e0d38b8f416d5dcc2dcf3fc93d26630" translate="yes" xml:space="preserve">
          <source>Indexing a single element of a structured array (with an integer index) returns a structured scalar:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1544ebdc7ceef1dd43c207ab5e502bb881e63b2a" translate="yes" xml:space="preserve">
          <source>Indexing and Assignment to Structured arrays</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3b75e279fb5c7684c193076341ad2da99a787445" translate="yes" xml:space="preserve">
          <source>Indexing and slicing</source>
          <target state="translated">Индексирование и нарезка</target>
        </trans-unit>
        <trans-unit id="c620de8536d4e92665cc1da6338b0e3c9ccd772a" translate="yes" xml:space="preserve">
          <source>Indexing and slicing operations are useful when you&amp;rsquo;re manipulating matrices:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9f16e8a5deb5dca320283bcd174b16dd9a73b2c2" translate="yes" xml:space="preserve">
          <source>Indexing arrays</source>
          <target state="translated">Массивы индексирования</target>
        </trans-unit>
        <trans-unit id="32cfd79e57bf8a3877f833f091f428533e7b10d7" translate="yes" xml:space="preserve">
          <source>Indexing basics</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="43bc37d1483f275b849fa10b51ee75dd7340e249" translate="yes" xml:space="preserve">
          <source>Indexing into a structured array can also be done with a list of field names, &lt;em&gt;e.g.&lt;/em&gt;&lt;code&gt;x[['field-name1','field-name2']]&lt;/code&gt;. As of NumPy 1.16 this returns a view containing only those fields. In older versions of numpy it returned a copy. See the user guide section on &lt;a href=&quot;../user/basics.rec#structured-arrays&quot;&gt;Structured arrays&lt;/a&gt; for more information on multifield indexing.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="287cc46fe81b17127e826e2dc4d460f956256411" translate="yes" xml:space="preserve">
          <source>Indexing into a structured array can also be done with a list of field names, &lt;em&gt;e.g.&lt;/em&gt;&lt;code&gt;x[['field-name1','field-name2']]&lt;/code&gt;. As of NumPy 1.16 this returns a view containing only those fields. In older versions of numpy it returned a copy. See the user guide section on &lt;a href=&quot;https://docs.scipy.org/doc/numpy-1.17.0/user/basics.rec.html#structured-arrays&quot;&gt;Structured arrays&lt;/a&gt; for more information on multifield indexing.</source>
          <target state="translated">Индексирование в структурированный массив также может быть выполнено с помощью списка имен полей, &lt;em&gt;например &lt;/em&gt; &lt;code&gt;x[['field-name1','field-name2']]&lt;/code&gt; . Начиная с NumPy 1.16, это возвращает представление, содержащее только эти поля. В более старых версиях numpy он возвращал копию. См. Раздел руководства пользователя о &lt;a href=&quot;https://docs.scipy.org/doc/numpy-1.17.0/user/basics.rec.html#structured-arrays&quot;&gt;структурированных массивах&lt;/a&gt; для получения дополнительной информации о многополевой индексации.</target>
        </trans-unit>
        <trans-unit id="f9931083a6e7f53e9bc486a3df5e5e7c8488e9d6" translate="yes" xml:space="preserve">
          <source>Indexing routines</source>
          <target state="translated">Индексирование</target>
        </trans-unit>
        <trans-unit id="6e79a0e3c54ea0ceb91b9669283adab9f2147f0b" translate="yes" xml:space="preserve">
          <source>Indexing with Arrays of Indices</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a5b7926d0e1062fbea55528bbcec6310b0c56043" translate="yes" xml:space="preserve">
          <source>Indexing with Boolean Arrays</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3484dfe82dee2e7bac292b6534b5cbe2647cd408" translate="yes" xml:space="preserve">
          <source>Indexing with an Integer to get a Structured Scalar</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="090d4c4fc948bc8eed34fc6e8ddf8e7bd5be023c" translate="yes" xml:space="preserve">
          <source>Indexing with strings</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2794b9b37dd0d88704ab33758cd5ea559027c74f" translate="yes" xml:space="preserve">
          <source>Indexing, Slicing and Iterating</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a0b6ddf08f9938b1aef1c27a89f039c34d4ed175" translate="yes" xml:space="preserve">
          <source>Indexing-like operations</source>
          <target state="translated">Индексирующие операции</target>
        </trans-unit>
        <trans-unit id="0454b105259e523f13a84d0a1ff2499fbf44bf18" translate="yes" xml:space="preserve">
          <source>Indicate how the user of the iterator will read or write to &lt;code&gt;op[i]&lt;/code&gt;. Exactly one of these flags must be specified per operand. Using &lt;code&gt;NPY_ITER_READWRITE&lt;/code&gt; or &lt;code&gt;NPY_ITER_WRITEONLY&lt;/code&gt; for a user-provided operand may trigger &lt;code&gt;WRITEBACKIFCOPY`&lt;/code&gt; semantics. The data will be written back to the original array when &lt;code&gt;NpyIter_Deallocate&lt;/code&gt; is called.</source>
          <target state="translated">Укажите, как пользователь итератора будет читать или писать в &lt;code&gt;op[i]&lt;/code&gt; . Для каждого операнда должен быть указан ровно один из этих флагов. Использование &lt;code&gt;NPY_ITER_READWRITE&lt;/code&gt; или &lt;code&gt;NPY_ITER_WRITEONLY&lt;/code&gt; для предоставленного пользователем операнда может вызвать семантику &lt;code&gt;WRITEBACKIFCOPY`&lt;/code&gt; . Данные будут записаны обратно в исходный массив при &lt;code&gt;NpyIter_Deallocate&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ba89764e8d83fcb18f052ec54405d196f55000ee" translate="yes" xml:space="preserve">
          <source>Indicate indices of sub-arrays to remove along the specified axis.</source>
          <target state="translated">Укажите индексы подмассивов для удаления вдоль указанной оси.</target>
        </trans-unit>
        <trans-unit id="ff289ba1c19ab34e00eb1d52160a46b6efb2713b" translate="yes" xml:space="preserve">
          <source>Indicates arrays of this data-type must be converted to a list before pickling.</source>
          <target state="translated">Массивы этого типа данных перед травлением должны быть преобразованы в список.</target>
        </trans-unit>
        <trans-unit id="327748da6a9d945d96e091b8e7383b60afba1da7" translate="yes" xml:space="preserve">
          <source>Indicates memory for this data-type must be initialized (set to 0) on creation.</source>
          <target state="translated">Показывает,что память для этого типа данных должна быть инициализирована (установлена на 0)при создании.</target>
        </trans-unit>
        <trans-unit id="4bc4530525549adc3e6afe819ca6b79c82a0ab71" translate="yes" xml:space="preserve">
          <source>Indicates that arrays with a size of zero should be permitted. Since the typical iteration loop does not naturally work with zero-sized arrays, you must check that the IterSize is larger than zero before entering the iteration loop. Currently only the operands are checked, not a forced shape.</source>
          <target state="translated">Указывает на то,что массивы с размером нуля должны быть разрешены.Поскольку типичный цикл итераций естественно не работает с массивами нулевого размера,то перед входом в цикл итераций необходимо убедиться,что IterSize больше нуля.В настоящее время проверяются только операнды,а не принудительная форма.</target>
        </trans-unit>
        <trans-unit id="3f20ca03a166ca2b12eed667d0c9d43d498dcabe" translate="yes" xml:space="preserve">
          <source>Indicates that arrays with reference types (object arrays or structured arrays containing an object type) may be accepted and used in the iterator. If this flag is enabled, the caller must be sure to check whether &lt;code&gt;NpyIter_IterationNeedsAPI(iter)&lt;/code&gt; is true, in which case it may not release the GIL during iteration.</source>
          <target state="translated">Указывает, что массивы со ссылочными типами (массивы объектов или структурированные массивы, содержащие тип объекта) могут быть приняты и использованы в итераторе. Если этот флаг включен, вызывающий должен обязательно проверить, &lt;code&gt;NpyIter_IterationNeedsAPI(iter)&lt;/code&gt; ли NpyIter_IterationNeedsAPI (iter) , и в этом случае он может не освободить GIL во время итерации.</target>
        </trans-unit>
        <trans-unit id="e809396a40c3ec96fdae3328ed0a31c66576c7c0" translate="yes" xml:space="preserve">
          <source>Indicates that items of this data-type must be reference counted (using &lt;a href=&quot;https://docs.python.org/dev/c-api/refcounting.html#c.Py_INCREF&quot;&gt;&lt;code&gt;Py_INCREF&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;https://docs.python.org/dev/c-api/refcounting.html#c.Py_DECREF&quot;&gt;&lt;code&gt;Py_DECREF&lt;/code&gt;&lt;/a&gt; ).</source>
          <target state="translated">Указывает, что элементы этого типа данных должны подсчитываться по ссылкам (с использованием &lt;a href=&quot;https://docs.python.org/dev/c-api/refcounting.html#c.Py_INCREF&quot;&gt; &lt;code&gt;Py_INCREF&lt;/code&gt; &lt;/a&gt; и &lt;a href=&quot;https://docs.python.org/dev/c-api/refcounting.html#c.Py_DECREF&quot;&gt; &lt;code&gt;Py_DECREF&lt;/code&gt; &lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="03ad2756a493f01508378680f8d907e50dad0e86" translate="yes" xml:space="preserve">
          <source>Indicates that this operand is the mask to use for selecting elements when writing to operands which have the &lt;a href=&quot;#c.NPY_ITER_WRITEMASKED&quot;&gt;&lt;code&gt;NPY_ITER_WRITEMASKED&lt;/code&gt;&lt;/a&gt; flag applied to them. Only one operand may have &lt;a href=&quot;#c.NPY_ITER_ARRAYMASK&quot;&gt;&lt;code&gt;NPY_ITER_ARRAYMASK&lt;/code&gt;&lt;/a&gt; flag applied to it.</source>
          <target state="translated">Указывает, что этот операнд является маской, используемой для выбора элементов при записи в операнды, к &lt;a href=&quot;#c.NPY_ITER_WRITEMASKED&quot;&gt; &lt;code&gt;NPY_ITER_WRITEMASKED&lt;/code&gt; &lt;/a&gt; применен флаг NPY_ITER_WRITEMASKED . Только к одному &lt;a href=&quot;#c.NPY_ITER_ARRAYMASK&quot;&gt; &lt;code&gt;NPY_ITER_ARRAYMASK&lt;/code&gt; &lt;/a&gt; может быть применен флаг NPY_ITER_ARRAYMASK .</target>
        </trans-unit>
        <trans-unit id="613ac9b34fa48eda3d48ba0a932ba15f0204a86f" translate="yes" xml:space="preserve">
          <source>Indicates the item is a pointer to some other data-type</source>
          <target state="translated">Указывает на то,что элемент является указателем на какой-то другой тип данных</target>
        </trans-unit>
        <trans-unit id="6f07bb702873a42eecec00d6bf9d09bfd0c31b06" translate="yes" xml:space="preserve">
          <source>Indicates this data-type requires the Python C-API during access (so don&amp;rsquo;t give up the GIL if array access is going to be needed).</source>
          <target state="translated">Указывает, что для этого типа данных требуется Python C-API во время доступа (поэтому не отказывайтесь от GIL, если требуется доступ к массиву).</target>
        </trans-unit>
        <trans-unit id="d5ca13d01e4aee97ba5ebf7dbc18794ab7e82eae" translate="yes" xml:space="preserve">
          <source>Indicating whether the intervals include the right or the left bin edge. Default behavior is (right==False) indicating that the interval does not include the right edge. The left bin end is open in this case, i.e., bins[i-1] &amp;lt;= x &amp;lt; bins[i] is the default behavior for monotonically increasing bins.</source>
          <target state="translated">Указывает, включают ли интервалы правый или левый край бункера. Поведение по умолчанию (right == False) означает, что интервал не включает правый край. В этом случае левый конец бункера открыт, то есть бункеры [i-1] &amp;lt;= x &amp;lt;bins [i] являются поведением по умолчанию для монотонно увеличивающихся интервалов.</target>
        </trans-unit>
        <trans-unit id="ca9cfe4e704c12c6c1fa5c4b576973839a44850c" translate="yes" xml:space="preserve">
          <source>Indices can also be grouped by element.</source>
          <target state="translated">Индексы также могут быть сгруппированы по элементам.</target>
        </trans-unit>
        <trans-unit id="14ad131012032e9e04ca04f6d1ddd8fbcaa3e2c0" translate="yes" xml:space="preserve">
          <source>Indices for the upper-triangle of &lt;code&gt;arr&lt;/code&gt;.</source>
          <target state="translated">Индексы верхнего треугольника &lt;code&gt;arr&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="05056f495c02c0b518e0436ff12d0703c782c034" translate="yes" xml:space="preserve">
          <source>Indices of elements that are non-zero.</source>
          <target state="translated">Индексы элементов,которые не являются нулевыми.</target>
        </trans-unit>
        <trans-unit id="91841f1f82f1c15d4b5be121831bfdfa7d539a5a" translate="yes" xml:space="preserve">
          <source>Indices of elements that are non-zero. Indices are grouped by element.</source>
          <target state="translated">Индексы элементов,которые не являются нулевыми.Индексы сгруппированы по элементам.</target>
        </trans-unit>
        <trans-unit id="7756fd7ee8f7161ab914664d39dc9bedefea080d" translate="yes" xml:space="preserve">
          <source>Indices of elements that are non-zero. Indices are grouped by element. This array will have shape &lt;code&gt;(N, a.ndim)&lt;/code&gt; where &lt;code&gt;N&lt;/code&gt; is the number of non-zero items.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b94c56d6a6bfbdfee7bbd9db799f4cac5be86fa1" translate="yes" xml:space="preserve">
          <source>Indices of the minimum elements of a N-dimensional array:</source>
          <target state="translated">Индексы минимальных элементов N-мерного массива:</target>
        </trans-unit>
        <trans-unit id="764406c1c2d21f5c9a93e6d3d66afbc9de92b722" translate="yes" xml:space="preserve">
          <source>Indices of the sorted elements of a N-dimensional array:</source>
          <target state="translated">Индексы отсортированных элементов N-мерного массива:</target>
        </trans-unit>
        <trans-unit id="d010fa85fcc511735fc1ba118d8c9fa77c46fb33" translate="yes" xml:space="preserve">
          <source>Indices to change along each 1d slice of &lt;code&gt;arr&lt;/code&gt;. This must match the dimension of arr, but dimensions in Ni and Nj may be 1 to broadcast against &lt;code&gt;arr&lt;/code&gt;.</source>
          <target state="translated">Индексы для изменения вдоль каждого 1d среза &lt;code&gt;arr&lt;/code&gt; . Он должен соответствовать размеру arr, но размеры в Ni и Nj могут быть равны 1 для передачи по &lt;code&gt;arr&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="bd4ed66b25e3e81f7c09020b3e15317e8ebab751" translate="yes" xml:space="preserve">
          <source>Indices to take along each 1d slice of &lt;code&gt;arr&lt;/code&gt;. This must match the dimension of arr, but dimensions Ni and Nj only need to broadcast against &lt;code&gt;arr&lt;/code&gt;.</source>
          <target state="translated">Индексы, которые нужно брать с собой каждый 1d кусок &lt;code&gt;arr&lt;/code&gt; . Он должен соответствовать размеру arr, но размеры Ni и Nj необходимо транслировать только против &lt;code&gt;arr&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7dfac1d76acfef8a43ec3bb5c63e278bd2c2aa5a" translate="yes" xml:space="preserve">
          <source>Indirect partial sort.</source>
          <target state="translated">Косвенная частичная сортировка.</target>
        </trans-unit>
        <trans-unit id="67b91131b038b258475621be16da6d4bad633d9d" translate="yes" xml:space="preserve">
          <source>Indirect partition.</source>
          <target state="translated">Косвенное разделение.</target>
        </trans-unit>
        <trans-unit id="ceed8c74919b3d66cbcd799fe2d4bb252d0af6a7" translate="yes" xml:space="preserve">
          <source>Indirect sort.</source>
          <target state="translated">Косвенный сорт.</target>
        </trans-unit>
        <trans-unit id="7a7f09efc9fe3734b3bf1afc86adc2e542a21680" translate="yes" xml:space="preserve">
          <source>Indirect stable sort on multiple keys.</source>
          <target state="translated">Косвенная стабильная сортировка по нескольким клавишам.</target>
        </trans-unit>
        <trans-unit id="80cc0e6eec2203fc2c38742d008a3fb864036a7b" translate="yes" xml:space="preserve">
          <source>Indirect stable sort with multiple keys.</source>
          <target state="translated">Косвенная стабильная сортировка с несколькими ключами.</target>
        </trans-unit>
        <trans-unit id="f2d326af87bc022a272e7d1fdc4716803c23e396" translate="yes" xml:space="preserve">
          <source>Individual fields of a structured array may be accessed and modified by indexing the array with the field name.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8e9e048443c76eaece9af376ed6551264b94a4e9" translate="yes" xml:space="preserve">
          <source>Individual values are not stripped of spaces by default. When using a custom converter, make sure the function does remove spaces.</source>
          <target state="translated">Отдельные значения по умолчанию не лишаются пробелов.При использовании пользовательского конвертера убедитесь,что функция действительно удаляет пробелы.</target>
        </trans-unit>
        <trans-unit id="5888912f1820a7f863f2cf1064c7ab5b1a9a9baa" translate="yes" xml:space="preserve">
          <source>Individuals come from different cultural backgrounds and native languages. Try to identify any honest misunderstandings caused by a non-native speaker and help them understand the issue and what they can change to avoid causing offence. Complex discussion in a foreign language can be very intimidating, and we want to grow our diversity also across nationalities and cultures.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a28ed132c608e3b4681e944b25690757eebfc33f" translate="yes" xml:space="preserve">
          <source>Inf (in module numpy)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5b675f1c2537bc4e7587a11173af58141e3f3972" translate="yes" xml:space="preserve">
          <source>Infinity (in module numpy)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fbf064be21246c8a34df5396396140e055f24f53" translate="yes" xml:space="preserve">
          <source>Info are easily retrieved from the &lt;a href=&quot;distutils/misc_util#numpy.distutils.misc_util.get_info&quot;&gt;&lt;code&gt;get_info&lt;/code&gt;&lt;/a&gt; function in &lt;a href=&quot;distutils/misc_util#module-numpy.distutils.misc_util&quot;&gt;&lt;code&gt;numpy.distutils.misc_util&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ecae1f8d30472c9a7f54d4130dc7c3b85605f125" translate="yes" xml:space="preserve">
          <source>Info are easily retrieved from the &lt;code&gt;get_info&lt;/code&gt; function in &lt;a href=&quot;#module-numpy.distutils.misc_util&quot;&gt;&lt;code&gt;numpy.distutils.misc_util&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">Информация легко извлекаются из &lt;code&gt;get_info&lt;/code&gt; функции в &lt;a href=&quot;#module-numpy.distutils.misc_util&quot;&gt; &lt;code&gt;numpy.distutils.misc_util&lt;/code&gt; &lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="ce47f6aad749dde8c374d70dfb4bb3378d690b1b" translate="yes" xml:space="preserve">
          <source>Information (via the dtype object) about the interpretation of the basic data element. The basic data element may be as simple as a int or a float, or it may be a compound object (e.g., struct-like), a fixed character field, or Python object pointers.</source>
          <target state="translated">Информация (через объект dtype)об интерпретации элемента основных данных.Базовый элемент данных может быть таким же простым,как int или float,или же это может быть составной объект (например,структурно-подобный),фиксированное символьное поле или указатели на Python-объект.</target>
        </trans-unit>
        <trans-unit id="bfbba3e12af5ea2c7741d834d66f7c560456f725" translate="yes" xml:space="preserve">
          <source>Information about sub-data-types in a &lt;a href=&quot;../glossary#term-structured-data-type&quot;&gt;structured data type&lt;/a&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="87749b5a0427424240dbd899baaf24bccac8d963" translate="yes" xml:space="preserve">
          <source>Information about sub-data-types in a &lt;a href=&quot;https://docs.scipy.org/doc/numpy-1.17.0/glossary.html#term-structured-data-type&quot;&gt;structured data type&lt;/a&gt;:</source>
          <target state="translated">Информация о подтипах в &lt;a href=&quot;https://docs.scipy.org/doc/numpy-1.17.0/glossary.html#term-structured-data-type&quot;&gt;структурированном типе данных&lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="feb91fe9e3a82284bbc774141950eade27079231" translate="yes" xml:space="preserve">
          <source>Information about the memory layout of the array.</source>
          <target state="translated">Информация о компоновке памяти массива.</target>
        </trans-unit>
        <trans-unit id="6c6da40785b1a9277377a0ac6b35aa661e1efec5" translate="yes" xml:space="preserve">
          <source>Information may include:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b590718892221849c4b4d49b1a5feaa2b8ce90e3" translate="yes" xml:space="preserve">
          <source>Initialize all function pointers and members to &lt;code&gt;NULL&lt;/code&gt;.</source>
          <target state="translated">Инициализируйте все указатели функций и члены до &lt;code&gt;NULL&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="32bc5b2fd4039aefa8f94877a70e63431f9d15f4" translate="yes" xml:space="preserve">
          <source>Inner product</source>
          <target state="translated">Внутренний продукт</target>
        </trans-unit>
        <trans-unit id="1dba54e0b565dd813bcf7f4dd26137c8252036b6" translate="yes" xml:space="preserve">
          <source>Inner product of two arrays.</source>
          <target state="translated">Внутренний продукт из двух массивов.</target>
        </trans-unit>
        <trans-unit id="064057f93ed4cdc0c2704e960d9c6d25cbbcac22" translate="yes" xml:space="preserve">
          <source>Inplace partition.</source>
          <target state="translated">Вставьте раздел.</target>
        </trans-unit>
        <trans-unit id="5afc0baf08aba247f1b2f3cdc0980c0ea2b6e83d" translate="yes" xml:space="preserve">
          <source>Inplace sort.</source>
          <target state="translated">Поставь на место.</target>
        </trans-unit>
        <trans-unit id="d72a097ccb9c0003ebff6189ebb422b954b438f2" translate="yes" xml:space="preserve">
          <source>Input 1-D &lt;a href=&quot;../maskedarray.baseclass#numpy.ma.MaskedArray&quot;&gt;&lt;code&gt;MaskedArray&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">Входной 1-D &lt;a href=&quot;../maskedarray.baseclass#numpy.ma.MaskedArray&quot;&gt; &lt;code&gt;MaskedArray&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="80930bf11175241ae29fe59d0d272e2dd3fda246" translate="yes" xml:space="preserve">
          <source>Input &lt;a href=&quot;../maskedarray.baseclass#numpy.ma.MaskedArray&quot;&gt;&lt;code&gt;MaskedArray&lt;/code&gt;&lt;/a&gt; for which the mask is required.</source>
          <target state="translated">Входной &lt;a href=&quot;../maskedarray.baseclass#numpy.ma.MaskedArray&quot;&gt; &lt;code&gt;MaskedArray&lt;/code&gt; ,&lt;/a&gt; для которого требуется маска.</target>
        </trans-unit>
        <trans-unit id="abfa0de453f55ea46910c5cb072561c46c566eda" translate="yes" xml:space="preserve">
          <source>Input &lt;code&gt;MaskedArray&lt;/code&gt;, alternatively a ndarray or a subclass thereof.</source>
          <target state="translated">Введите &lt;code&gt;MaskedArray&lt;/code&gt; , альтернативно ndarray или его подкласс.</target>
        </trans-unit>
        <trans-unit id="ef6caaf1ffac65c55e3879237f23b9e4cd5b35fe" translate="yes" xml:space="preserve">
          <source>Input Arrays</source>
          <target state="translated">Массивы ввода</target>
        </trans-unit>
        <trans-unit id="c77783bb0c7d4d2f9b2b8bd6478b069981c0866f" translate="yes" xml:space="preserve">
          <source>Input and output</source>
          <target state="translated">Вход и выход</target>
        </trans-unit>
        <trans-unit id="43fab0b785a955e5195e8f3f11f33f3ad7b432bc" translate="yes" xml:space="preserve">
          <source>Input argument, can be of any type and shape.</source>
          <target state="translated">Входной аргумент,может быть любого типа и формы.</target>
        </trans-unit>
        <trans-unit id="df78d5709935001a8bf74fe47ed30fca9beafae5" translate="yes" xml:space="preserve">
          <source>Input array</source>
          <target state="translated">Массив ввода</target>
        </trans-unit>
        <trans-unit id="d573fb86d82f5065edfc4ca49f5112f03928d672" translate="yes" xml:space="preserve">
          <source>Input array in degrees.</source>
          <target state="translated">Входной массив в градусах.</target>
        </trans-unit>
        <trans-unit id="c7b020a842b9509ee12f3acbb189d43b5a5c8e2b" translate="yes" xml:space="preserve">
          <source>Input array in radians.</source>
          <target state="translated">Входной массив в радианах.</target>
        </trans-unit>
        <trans-unit id="f139b5d61b47039d6645fe901089b8d7348e059e" translate="yes" xml:space="preserve">
          <source>Input array of size 1.</source>
          <target state="translated">Входной массив размера 1.</target>
        </trans-unit>
        <trans-unit id="4fabb62ebf0299b3a11dc8870c6ebb3a76ef6ff9" translate="yes" xml:space="preserve">
          <source>Input array of strings to capitalize.</source>
          <target state="translated">Введите массив строк с заглавной буквы.</target>
        </trans-unit>
        <trans-unit id="8088eb90e795502e434844cfa6cdf9e95d4c9437" translate="yes" xml:space="preserve">
          <source>Input array of the same size as &lt;code&gt;condition&lt;/code&gt;.</source>
          <target state="translated">Входной массив того же размера, что и &lt;code&gt;condition&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f46407fd3e6fc3c69904fb1af7940d31883ac983" translate="yes" xml:space="preserve">
          <source>Input array or object that can be converted to an array, containing nan values to be ignored</source>
          <target state="translated">Входной массив или объект,который может быть преобразован в массив,содержащий нано-значения,которые следует игнорировать.</target>
        </trans-unit>
        <trans-unit id="49d0fb63038b2721f65a3fb79be1b2a9aa62e9d2" translate="yes" xml:space="preserve">
          <source>Input array or object that can be converted to an array, containing nan values to be ignored.</source>
          <target state="translated">Входной массив или объект,который может быть преобразован в массив,содержащий нано-значения,которые следует игнорировать.</target>
        </trans-unit>
        <trans-unit id="1e12f84194e4961e84959b469b0f8a65e2620351" translate="yes" xml:space="preserve">
          <source>Input array or object that can be converted to an array.</source>
          <target state="translated">Входной массив или объект,который может быть преобразован в массив.</target>
        </trans-unit>
        <trans-unit id="a14df91a899a43d15ec0d5b0ebc8a2a56f832cef" translate="yes" xml:space="preserve">
          <source>Input array to be binned. Prior to NumPy 1.10.0, this array had to be 1-dimensional, but can now have any shape.</source>
          <target state="translated">Входной массив,который должен быть скомпонован.До NumPy 1.10.0 этот массив должен был быть 1-мерным,но теперь может иметь любую форму.</target>
        </trans-unit>
        <trans-unit id="bf15a8f66c7dacebdd89b7241fd4d11919829ad3" translate="yes" xml:space="preserve">
          <source>Input array to compute determinants for.</source>
          <target state="translated">Входной массив для вычисления детерминант.</target>
        </trans-unit>
        <trans-unit id="9eff9d201dcac2141e1679ca23a312d5c7800681" translate="yes" xml:space="preserve">
          <source>Input array to extend.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7e287445198fc945368949e1412f5d8cb686139f" translate="yes" xml:space="preserve">
          <source>Input array to integrate.</source>
          <target state="translated">Входной массив для интеграции.</target>
        </trans-unit>
        <trans-unit id="85b9cb3f5f032dd1e9e0718bbfaa4576f72e78eb" translate="yes" xml:space="preserve">
          <source>Input array whose fields must be modified.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="42226304be73817a4e285cb433d2b7bb659c59a4" translate="yes" xml:space="preserve">
          <source>Input array with datetime or timedelta data type.</source>
          <target state="translated">Входной массив с типом данных datetime или timedelta.</target>
        </trans-unit>
        <trans-unit id="7c1847566b14607f43160463914cca58e1d1e0d6" translate="yes" xml:space="preserve">
          <source>Input array, a (subclass of) ndarray.</source>
          <target state="translated">Входной массив,(подкласс)ndarray.</target>
        </trans-unit>
        <trans-unit id="a4f57e9a75e6d26f7e8f35eb55623a7c6ae8a1b9" translate="yes" xml:space="preserve">
          <source>Input array, can be complex</source>
          <target state="translated">Входной массив,может быть сложным</target>
        </trans-unit>
        <trans-unit id="1b7a137c8182cfa54895f3372cda87fe7e3932e7" translate="yes" xml:space="preserve">
          <source>Input array, can be complex.</source>
          <target state="translated">Входной массив,может быть сложным.</target>
        </trans-unit>
        <trans-unit id="6d76cf24117a4b5288f54769d468e637657f37e2" translate="yes" xml:space="preserve">
          <source>Input array, from which the diagonals are taken.</source>
          <target state="translated">Входной массив,из которого берутся диагонали.</target>
        </trans-unit>
        <trans-unit id="2204886fc1fe79484a18e95229b508e3a16d8a88" translate="yes" xml:space="preserve">
          <source>Input array, has to be a square 2-D array.</source>
          <target state="translated">Входной массив,должен быть квадратным 2-D массивом.</target>
        </trans-unit>
        <trans-unit id="4e7ee35a9b27cc189fd5faf36b937d455a1aa919" translate="yes" xml:space="preserve">
          <source>Input array, must be at least 2-D.</source>
          <target state="translated">Входной массив должен быть как минимум 2-D.</target>
        </trans-unit>
        <trans-unit id="b7ba46399772c3a420055c71f8f5dda1e65da7f0" translate="yes" xml:space="preserve">
          <source>Input array, taken to be real.</source>
          <target state="translated">Входной массив,воспринимается как реальный.</target>
        </trans-unit>
        <trans-unit id="16ca749420dd58126c1f3f4ccf95ce2fc49387c9" translate="yes" xml:space="preserve">
          <source>Input array.</source>
          <target state="translated">Входной массив.</target>
        </trans-unit>
        <trans-unit id="05370e4965d51e56f1347351509792a8c2d8443c" translate="yes" xml:space="preserve">
          <source>Input array. If &lt;code&gt;axis&lt;/code&gt; is None, &lt;code&gt;x&lt;/code&gt; must be 1-D or 2-D, unless &lt;code&gt;ord&lt;/code&gt; is None. If both &lt;code&gt;axis&lt;/code&gt; and &lt;code&gt;ord&lt;/code&gt; are None, the 2-norm of &lt;code&gt;x.ravel&lt;/code&gt; will be returned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e22a13f0e68b42a409027fe2f016234b4ec5feb3" translate="yes" xml:space="preserve">
          <source>Input array. If &lt;code&gt;axis&lt;/code&gt; is None, &lt;code&gt;x&lt;/code&gt; must be 1-D or 2-D.</source>
          <target state="translated">Входной массив. Если &lt;code&gt;axis&lt;/code&gt; None, &lt;code&gt;x&lt;/code&gt; должен быть 1-D или 2-D.</target>
        </trans-unit>
        <trans-unit id="a823c846105b9c9719fbae89a64d485cac5a4b66" translate="yes" xml:space="preserve">
          <source>Input array. If &lt;code&gt;sorter&lt;/code&gt; is None, then it must be sorted in ascending order, otherwise &lt;code&gt;sorter&lt;/code&gt; must be an array of indices that sort it.</source>
          <target state="translated">Входной массив. Если &lt;code&gt;sorter&lt;/code&gt; равен None, он должен быть отсортирован в порядке возрастания, иначе &lt;code&gt;sorter&lt;/code&gt; должен быть массивом индексов, которые его сортируют.</target>
        </trans-unit>
        <trans-unit id="9358104d5c139fb6025e6e3c499456297f4494b9" translate="yes" xml:space="preserve">
          <source>Input array. It must conform to the Python-side of the array interface.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6eef0d989b2fd6fdf464d508f694dc4a0a6a6caa" translate="yes" xml:space="preserve">
          <source>Input array. The elements in &lt;code&gt;a&lt;/code&gt; are read in the order specified by &lt;code&gt;order&lt;/code&gt;, and packed as a 1-D array.</source>
          <target state="translated">Входной массив. Элементы в &lt;code&gt;a&lt;/code&gt; читаются в порядке, указанном &lt;code&gt;order&lt;/code&gt; , и упаковываются в одномерный массив.</target>
        </trans-unit>
        <trans-unit id="88c5aa449f45fc85917596c4004dffe23e0b86ac" translate="yes" xml:space="preserve">
          <source>Input array. Unless &lt;code&gt;axis&lt;/code&gt; is specified, this will be flattened if it is not already 1-D.</source>
          <target state="translated">Входной массив. Если &lt;code&gt;axis&lt;/code&gt; не указана, она будет развернута, если она еще не является 1-D.</target>
        </trans-unit>
        <trans-unit id="c937c57a4f225878ef9dec01334ff4466710291e" translate="yes" xml:space="preserve">
          <source>Input arrays</source>
          <target state="translated">массивы ввода</target>
        </trans-unit>
        <trans-unit id="d4ab162cfec9e7e5f511b1323f2a38dced9855a6" translate="yes" xml:space="preserve">
          <source>Input arrays are defined as arrays of data that are passed into a routine but are not altered in-place or returned to the user. The Python input array is therefore allowed to be almost any Python sequence (such as a list) that can be converted to the requested type of array. The input array signatures are</source>
          <target state="translated">Массивы ввода определяются как массивы данных,которые передаются в рутину,но не изменяются на месте и не возвращаются пользователю.Поэтому входной массив Python может быть практически любой последовательностью Python (например,списком),которая может быть преобразована в массив запрошенного типа.Сигнатуры входного массива</target>
        </trans-unit>
        <trans-unit id="098168471a46df6606b6ff9c9cd3ead3422de613" translate="yes" xml:space="preserve">
          <source>Input arrays of the same shape.</source>
          <target state="translated">Входные массивы одинаковой формы.</target>
        </trans-unit>
        <trans-unit id="27f64d53a246ed11a85c01a61d0a931b1d50a817" translate="yes" xml:space="preserve">
          <source>Input arrays to be compared.</source>
          <target state="translated">Входные массивы для сравнения.</target>
        </trans-unit>
        <trans-unit id="6fed91f1bcdfc2569325e9089bbd325328b5c5e9" translate="yes" xml:space="preserve">
          <source>Input arrays to be multiplied. If &lt;code&gt;x1.shape != x2.shape&lt;/code&gt;, they must be broadcastable to a common shape (which becomes the shape of the output).</source>
          <target state="translated">Входные массивы для умножения. Если &lt;code&gt;x1.shape != x2.shape&lt;/code&gt; , они должны транслироваться в общую форму (которая становится формой вывода).</target>
        </trans-unit>
        <trans-unit id="4a8e2cbe86fa87773992dad5fc91ec0f376d5ef6" translate="yes" xml:space="preserve">
          <source>Input arrays to compare.</source>
          <target state="translated">Входные массивы для сравнения.</target>
        </trans-unit>
        <trans-unit id="66d649cf79701276da2a390f23e474c6ab2aff7f" translate="yes" xml:space="preserve">
          <source>Input arrays, scalars not allowed.</source>
          <target state="translated">Входные массивы,скаляры не разрешены.</target>
        </trans-unit>
        <trans-unit id="556a7ea15ff0974e693ba20b38993284bf2034ec" translate="yes" xml:space="preserve">
          <source>Input arrays.</source>
          <target state="translated">Массивы ввода.</target>
        </trans-unit>
        <trans-unit id="ad9b94d855384626461316d89dd8037bff8db7bd" translate="yes" xml:space="preserve">
          <source>Input arrays. If &lt;code&gt;x1.shape != x2.shape&lt;/code&gt;, they must be broadcastable to a common shape (which becomes the shape of the output).</source>
          <target state="translated">Входные массивы. Если &lt;code&gt;x1.shape != x2.shape&lt;/code&gt; , они должны транслироваться в общую форму (которая становится формой вывода).</target>
        </trans-unit>
        <trans-unit id="d784452f6247a01f2c79aa8a172590665da159e0" translate="yes" xml:space="preserve">
          <source>Input arrays. They are flattened if they are not already 1D.</source>
          <target state="translated">Массивы ввода.Они сплющиваются,если их еще нет в 1D.</target>
        </trans-unit>
        <trans-unit id="e48eae13547040a1f74bd1dc543d4762a4b7970d" translate="yes" xml:space="preserve">
          <source>Input arrays. Will be flattened if not already 1D.</source>
          <target state="translated">Массивы ввода.Будет расплющена,если еще не 1D.</target>
        </trans-unit>
        <trans-unit id="670ce16c58ae415abf92889322038709e2fa68ca" translate="yes" xml:space="preserve">
          <source>Input cash flows per time period. By convention, net &amp;ldquo;deposits&amp;rdquo; are negative and net &amp;ldquo;withdrawals&amp;rdquo; are positive. Thus, for example, at least the first element of &lt;code&gt;values&lt;/code&gt;, which represents the initial investment, will typically be negative.</source>
          <target state="translated">Введите денежные потоки за период времени. Обычно чистые &amp;laquo;депозиты&amp;raquo; отрицательны, а чистые &amp;laquo;изъятия&amp;raquo; положительны. Таким образом, например, по крайней мере, первый элемент &lt;code&gt;values&lt;/code&gt; , представляющий начальные инвестиции, обычно будет отрицательным.</target>
        </trans-unit>
        <trans-unit id="00f0d4d4fb6b101c2c16fbc5749470d99cd4de8c" translate="yes" xml:space="preserve">
          <source>Input class. If a tuple of classes, True is returned if &lt;code&gt;arg1&lt;/code&gt; is a subclass of any of the tuple elements.</source>
          <target state="translated">Входной класс. Если кортеж классов, возвращается True, если &lt;code&gt;arg1&lt;/code&gt; является подклассом любого из элементов кортежа.</target>
        </trans-unit>
        <trans-unit id="2bad44bea0aeffb47c89150e3263bb8f1abd9181" translate="yes" xml:space="preserve">
          <source>Input class. True is returned if &lt;code&gt;arg1&lt;/code&gt; is a subclass of &lt;code&gt;arg2&lt;/code&gt;.</source>
          <target state="translated">Входной класс. True возвращается, если &lt;code&gt;arg1&lt;/code&gt; является подклассом &lt;code&gt;arg2&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="56f0cc662add4c7f0901841588673883d4d29d17" translate="yes" xml:space="preserve">
          <source>Input comparison array.</source>
          <target state="translated">Входной массив сравнения.</target>
        </trans-unit>
        <trans-unit id="64be30841013bc47e9c3850c4b6a7fded4a86ac4" translate="yes" xml:space="preserve">
          <source>Input data, in any form that can be converted to a masked array. This includes lists, lists of tuples, tuples, tuples of tuples, tuples of lists, ndarrays and masked arrays.</source>
          <target state="translated">Входные данные,в любой форме,которые могут быть преобразованы в маскированный массив.Сюда входят списки,списки кортежей,кортежи,кортежи списков,ndarrays и массивы по маске.</target>
        </trans-unit>
        <trans-unit id="81eacae9b22a55fbd594cc3dd8bc53a24b4e16f7" translate="yes" xml:space="preserve">
          <source>Input data, in any form that can be converted to an array.</source>
          <target state="translated">Входные данные,в любой форме,которые могут быть преобразованы в массив.</target>
        </trans-unit>
        <trans-unit id="2ed4e1316aa603c005ccf7b9b354de1cad7aa423" translate="yes" xml:space="preserve">
          <source>Input data, in any form that can be converted to an array. This includes lists, lists of tuples, tuples, tuples of tuples, tuples of lists and ndarrays.</source>
          <target state="translated">Входные данные,в любой форме,которые могут быть преобразованы в массив.Это включает в себя списки,списки кортежей,кортежи,кортежи списков и ndarrays.</target>
        </trans-unit>
        <trans-unit id="c935f3a4d2949a1b2d5a11eb7de8a0fed4bd8dc0" translate="yes" xml:space="preserve">
          <source>Input data, in any form that can be converted to an array. This includes lists, lists of tuples, tuples, tuples of tuples, tuples of lists and ndarrays. Success requires no NaNs or Infs.</source>
          <target state="translated">Входные данные,в любой форме,которые могут быть преобразованы в массив.Это включает в себя списки,списки кортежей,кортежи,кортежи списков и ndarrays.Успех не требует NaNs или Infs.</target>
        </trans-unit>
        <trans-unit id="ebe3314c250fe9acc710492a54a53defc42ce5bf" translate="yes" xml:space="preserve">
          <source>Input data, in any form that can be converted to an array. This includes scalars, lists, lists of tuples, tuples, tuples of tuples, tuples of lists, and ndarrays.</source>
          <target state="translated">Входные данные,в любой форме,которые могут быть преобразованы в массив.Сюда входят скаляры,списки,списки кортежей,кортежи,кортежи списков и ndarrays.</target>
        </trans-unit>
        <trans-unit id="d430a3ba769bee8e9797da35defb2f32aa2749a3" translate="yes" xml:space="preserve">
          <source>Input data, which is flattened and set as the &lt;code&gt;k&lt;/code&gt;-th diagonal of the output.</source>
          <target state="translated">Входные данные, которые сглаживаются и задаются как &lt;code&gt;k&lt;/code&gt; -я диагональ выходных данных.</target>
        </trans-unit>
        <trans-unit id="260753716624ad2077f13f38ada17a33c0f48cba" translate="yes" xml:space="preserve">
          <source>Input data.</source>
          <target state="translated">Вводите данные.</target>
        </trans-unit>
        <trans-unit id="110e3a721161e503e06852d0b67d62808bcf14b0" translate="yes" xml:space="preserve">
          <source>Input data. If a string, variables in the current scope may be referenced by name.</source>
          <target state="translated">Вводите данные.Если строка,то на переменные в текущей области видимости можно ссылаться по имени.</target>
        </trans-unit>
        <trans-unit id="50ef3fe01b042bdbfb18f290684475887aff6e69" translate="yes" xml:space="preserve">
          <source>Input data. The histogram is computed over the flattened array.</source>
          <target state="translated">Вводите данные.Гистограмма вычисляется по сплющенному массиву.</target>
        </trans-unit>
        <trans-unit id="479157011c9bc4b0c174d6c627dd634e47f423a6" translate="yes" xml:space="preserve">
          <source>Input datatype</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c3661c49bb4714e36d1ea68c6778013ac4b2c966" translate="yes" xml:space="preserve">
          <source>Input masks.</source>
          <target state="translated">Входные маски.</target>
        </trans-unit>
        <trans-unit id="49c6112477838697a8b42892713d1ff818dab05e" translate="yes" xml:space="preserve">
          <source>Input must be an ndarray (or have similar attributes) for it to be considered a valid mask.</source>
          <target state="translated">Ввод должен быть андарреем (или иметь похожие атрибуты),чтобы его можно было считать действительной маской.</target>
        </trans-unit>
        <trans-unit id="cdda590be17222720d3dca31ac32ec20a4bd2027" translate="yes" xml:space="preserve">
          <source>Input object or name to get information about. If &lt;a href=&quot;https://docs.python.org/dev/library/functions.html#object&quot;&gt;&lt;code&gt;object&lt;/code&gt;&lt;/a&gt; is a numpy object, its docstring is given. If it is a string, available modules are searched for matching objects. If None, information about &lt;a href=&quot;#numpy.info&quot;&gt;&lt;code&gt;info&lt;/code&gt;&lt;/a&gt; itself is returned.</source>
          <target state="translated">Введите объект или имя, о котором нужно получить информацию. Если &lt;a href=&quot;https://docs.python.org/dev/library/functions.html#object&quot;&gt; &lt;code&gt;object&lt;/code&gt; &lt;/a&gt; является numpy-объектом, дается его строка документации. Если это строка, доступные модули ищутся на предмет соответствия объектам. Если Нет, возвращается информация о самой &lt;a href=&quot;#numpy.info&quot;&gt; &lt;code&gt;info&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="884c8a0c5d0944c72ee0463c3eae0abb376b5e70" translate="yes" xml:space="preserve">
          <source>Input object. This can be any object (function, class, module, &amp;hellip;).</source>
          <target state="translated">Входной объект. Это может быть любой объект (функция, класс, модуль,&amp;hellip;).</target>
        </trans-unit>
        <trans-unit id="5bf2f1c9ba1965ca26f274218714e854f9f8439e" translate="yes" xml:space="preserve">
          <source>Input parameters.</source>
          <target state="translated">Входные параметры.</target>
        </trans-unit>
        <trans-unit id="f281e3f644ef1c6e22e0e862f4156eee5c382d75" translate="yes" xml:space="preserve">
          <source>Input polynomials.</source>
          <target state="translated">Входные полиномы.</target>
        </trans-unit>
        <trans-unit id="d68cab221829e2198b605b4996fba557e5ff14b8" translate="yes" xml:space="preserve">
          <source>Input sequences.</source>
          <target state="translated">Входные последовательности.</target>
        </trans-unit>
        <trans-unit id="103b73f8b8612de7f92ed544d130aab2ccb3dead" translate="yes" xml:space="preserve">
          <source>Input value.</source>
          <target state="translated">Входное значение.</target>
        </trans-unit>
        <trans-unit id="cf14e71217c8a7f10324a53bd5825d3d1b8701ee" translate="yes" xml:space="preserve">
          <source>Input values</source>
          <target state="translated">Входные значения</target>
        </trans-unit>
        <trans-unit id="4191049318f63b6c3a85211b91a5c1cecb649bdb" translate="yes" xml:space="preserve">
          <source>Input values.</source>
          <target state="translated">Входные значения.</target>
        </trans-unit>
        <trans-unit id="07feb5a3916677b58c8f1860e3f940ccc64ab2f3" translate="yes" xml:space="preserve">
          <source>Input values. If &lt;code&gt;x1.shape != x2.shape&lt;/code&gt;, they must be broadcastable to a common shape (which becomes the shape of the output).</source>
          <target state="translated">Входные значения. Если &lt;code&gt;x1.shape != x2.shape&lt;/code&gt; , они должны транслироваться в общую форму (которая становится формой вывода).</target>
        </trans-unit>
        <trans-unit id="75826edc2e28e338fe2b7ee2851bc98b65454f08" translate="yes" xml:space="preserve">
          <source>Input vector or stack of matrices.</source>
          <target state="translated">Входной вектор или стопка матриц.</target>
        </trans-unit>
        <trans-unit id="31df6d6470f1b56cda7e136be4be3e1c6dd63188" translate="yes" xml:space="preserve">
          <source>Input-only, in-place, argout, argoutview, and memory managed argoutview behavior.</source>
          <target state="translated">Поведение argoutview,управляемое только на входе,на месте,argoutview,argoutview и памятью.</target>
        </trans-unit>
        <trans-unit id="f0c077a272f1db74eb4547826e2fa78b80131915" translate="yes" xml:space="preserve">
          <source>Inputs array.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="35b236db313f77f4ec031a91db5c8c986efb6cc5" translate="yes" xml:space="preserve">
          <source>Inputs arrays.</source>
          <target state="translated">Входные массивы.</target>
        </trans-unit>
        <trans-unit id="b698f1874b3f648c9ca7483478e5a5187dbc4214" translate="yes" xml:space="preserve">
          <source>Insert a new axis that will appear at the &lt;code&gt;axis&lt;/code&gt; position in the expanded array shape.</source>
          <target state="translated">Вставьте новую ось, которая появится в позиции &lt;code&gt;axis&lt;/code&gt; в форме расширенного массива.</target>
        </trans-unit>
        <trans-unit id="af781fb10a00be46a34d9311756bc61e0afddfa8" translate="yes" xml:space="preserve">
          <source>Insert elements into an array.</source>
          <target state="translated">Вставьте элементы в массив.</target>
        </trans-unit>
        <trans-unit id="62cc157d912a7ebc384c4d505230255340ab3ae0" translate="yes" xml:space="preserve">
          <source>Insert scalar into an array (scalar is cast to array&amp;rsquo;s dtype, if possible)</source>
          <target state="translated">Вставить скаляр в массив (если возможно, скаляр приводится к dtype массива)</target>
        </trans-unit>
        <trans-unit id="6f263a0b1fde8fabbe156179a3331b4bc254ecbf" translate="yes" xml:space="preserve">
          <source>Insert values along the given axis before the given indices.</source>
          <target state="translated">Вставьте значения вдоль данной оси перед заданными индексами.</target>
        </trans-unit>
        <trans-unit id="6c05692f04b1e8c9bcb190b107c8a7b51796744b" translate="yes" xml:space="preserve">
          <source>Insert, remove, and combine dimensions, and resize existing ones</source>
          <target state="translated">Вставить,удалить и скомбинировать размеры,а также изменить размер существующих размеров</target>
        </trans-unit>
        <trans-unit id="5ca6174fce3b04b3d69345d6264017af5ed2d820" translate="yes" xml:space="preserve">
          <source>Inserted between elements.</source>
          <target state="translated">Вставлены между элементами.</target>
        </trans-unit>
        <trans-unit id="e6afa88e6a63d5a7ba7fb743473b463e1d9a17d0" translate="yes" xml:space="preserve">
          <source>Inserting data into arrays</source>
          <target state="translated">Вставка данных в массивы</target>
        </trans-unit>
        <trans-unit id="0f2b8c85b4203c61d3146e95e582c267d771f003" translate="yes" xml:space="preserve">
          <source>Inserting directives in Fortran source</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d078b8bceaffb54addedcd30ef388e1bc3bf477b" translate="yes" xml:space="preserve">
          <source>Inserts newlines if text is longer than &lt;code&gt;max_line_width&lt;/code&gt;. Defaults to &lt;code&gt;numpy.get_printoptions()['linewidth']&lt;/code&gt;.</source>
          <target state="translated">Вставляет символы новой строки, если текст длиннее &lt;code&gt;max_line_width&lt;/code&gt; . По умолчанию &lt;code&gt;numpy.get_printoptions()['linewidth']&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1e503f860ac4f65121fead950747f4fcea390ed6" translate="yes" xml:space="preserve">
          <source>Inspecting the array</source>
          <target state="translated">Проверка массива</target>
        </trans-unit>
        <trans-unit id="60da80156a5d0a6bae59ac9116ec4cab69c6184c" translate="yes" xml:space="preserve">
          <source>Install git</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b8e853cc56e81f34b9860e59d86983f00754c7d4" translate="yes" xml:space="preserve">
          <source>Installation of the new package is easy using:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2b894e265fdd7f5a67dff5c1fc33dcfbd31481f9" translate="yes" xml:space="preserve">
          <source>Installing NumPy</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aee4fe0a13da73153ed829e66d85c46397091399" translate="yes" xml:space="preserve">
          <source>Instances of &lt;a href=&quot;numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;ndarray&lt;/code&gt;&lt;/a&gt; subclasses are passed through as-is:</source>
          <target state="translated">Экземпляры подклассов &lt;a href=&quot;numpy.ndarray#numpy.ndarray&quot;&gt; &lt;code&gt;ndarray&lt;/code&gt; &lt;/a&gt; передаются как есть:</target>
        </trans-unit>
        <trans-unit id="449be076c28f2ad0824dc5cabdcb20c6b823dcf2" translate="yes" xml:space="preserve">
          <source>Instances of classes that are part of the NumPy API (for example &lt;code&gt;np.r_&lt;/code&gt;&lt;code&gt;np,c_&lt;/code&gt;, &lt;code&gt;np.index_exp&lt;/code&gt;, etc.) may require some care. To give these instances a useful docstring, we do the following:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e39a6352ce81aec018b2a3acbf6b2a0e689c1611" translate="yes" xml:space="preserve">
          <source>Instead of plain &lt;code&gt;gdb&lt;/code&gt; you can of course use your favourite alternative debugger; run it on the python binary with arguments &lt;code&gt;runtests.py -g --python mytest.py&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eb90e39d52c4ed3cde5408270177895a426f7a11" translate="yes" xml:space="preserve">
          <source>Instead of special method names which define behavior for Python classes, there are &amp;ldquo;function tables&amp;rdquo; which point to functions that implement the desired results. Since Python 2.2, the PyTypeObject itself has become dynamic which allows C types that can be &amp;ldquo;sub-typed &amp;ldquo;from other C-types in C, and sub-classed in Python. The children types inherit the attributes and methods from their parent(s).</source>
          <target state="translated">Вместо имен специальных методов, которые определяют поведение классов Python, существуют &amp;laquo;таблицы функций&amp;raquo;, указывающие на функции, реализующие желаемые результаты. Начиная с Python 2.2, сам PyTypeObject стал динамическим, что позволяет использовать типы C, которые могут быть &amp;laquo;подтипами&amp;raquo; из других C-типов в C и подклассами в Python. Дочерние типы наследуют атрибуты и методы от своих родителей.</target>
        </trans-unit>
        <trans-unit id="1a76aa17748f84d4f0a3ce05629dc02de8fc5860" translate="yes" xml:space="preserve">
          <source>Instead of specifying the full covariance matrix, popular approximations include:</source>
          <target state="translated">Вместо того,чтобы указывать полную ковариационную матрицу,популярные аппроксимации включают:</target>
        </trans-unit>
        <trans-unit id="569af2f9677e0019350ea2c63399c035e782231b" translate="yes" xml:space="preserve">
          <source>Instead of the Python traditional &amp;lsquo;floor division&amp;rsquo;, this returns a true division. True division adjusts the output type to present the best answer, regardless of input types.</source>
          <target state="translated">Вместо традиционного Python &amp;laquo;деления полов&amp;raquo; это возвращает истинное деление. Истинное деление регулирует тип вывода, чтобы представить лучший ответ, независимо от типов ввода.</target>
        </trans-unit>
        <trans-unit id="2a07db57033cceb88c4be20433a8c922b8ebe578" translate="yes" xml:space="preserve">
          <source>Instead of the above, you can also do:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="50b73dbdc0cbb3f8f1706a51e59d5b72389beaee" translate="yes" xml:space="preserve">
          <source>Instead of this function &lt;code&gt;PyObject_Call(ufunc, args, kwds)&lt;/code&gt; should be used. The above function differs from this because it ignores support for non-array, or array subclasses as inputs. To ensure identical behaviour, it may be necessary to convert all inputs using &lt;code&gt;PyArray_FromAny(obj, NULL, 0, 0, NPY_ARRAY_ENSUREARRAY, NULL)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="93d352d3764b7602f9edf496f491993157b0351d" translate="yes" xml:space="preserve">
          <source>Institutional Neutrality</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6e8f68e1ce3b53a860ea6246ace5d16aba4fb2d5" translate="yes" xml:space="preserve">
          <source>Institutional Partner benefits are:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="36318fd5786e4e1f35ed034e1d3f5b6a4d87922c" translate="yes" xml:space="preserve">
          <source>Institutional Partners</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="228367a5efa47fc0ca88237f73f231005624c438" translate="yes" xml:space="preserve">
          <source>Institutional Partners and Funding</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="415e24116e418ab9260b5d4870a4577bbf2a9dc5" translate="yes" xml:space="preserve">
          <source>Institutions become eligible to become an Institutional Partner by employing individuals who actively contribute to The Project as part of their official duties. To state this another way, the only way for a Partner to influence the project is by actively contributing to the open development of the project, in equal terms to any other member of the community of Contributors and Council Members. Merely using Project Software in institutional context does not allow an entity to become an Institutional Partner. Financial gifts do not enable an entity to become an Institutional Partner. Once an institution becomes eligible for Institutional Partnership, the Steering Council must nominate and approve the Partnership.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ed58f29743f8e14b9c8e13d41e070a1cc1d1c9f5" translate="yes" xml:space="preserve">
          <source>Instructions</source>
          <target state="translated">Instructions</target>
        </trans-unit>
        <trans-unit id="987d64b35cc2b94395724f62d16f3a187b63fb14" translate="yes" xml:space="preserve">
          <source>Insufficient bit width parameter to &lt;code&gt;binary_repr&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9edcffff4461c9083fbff857f8dcee0f0769cbd4" translate="yes" xml:space="preserve">
          <source>Integer</source>
          <target state="translated">Integer</target>
        </trans-unit>
        <trans-unit id="5796f99d3f819f045b29a1c73196d8c40b12d9d3" translate="yes" xml:space="preserve">
          <source>Integer (-2147483648 to 2147483647)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4710e6c81ea3d854c2dc7806935816c50a107107" translate="yes" xml:space="preserve">
          <source>Integer (-32768 to 32767)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d944b6a3d689ab2dee3e16b0c8d8d941fd887e9b" translate="yes" xml:space="preserve">
          <source>Integer (-9223372036854775808 to 9223372036854775807)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e8fe5938766ae937144b5f55575793bff2ec8f88" translate="yes" xml:space="preserve">
          <source>Integer and Void scalars are now unaffected by &lt;code&gt;np.set_string_function&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a61c09200238e7c60e4949f4f742cd3529f52bfd" translate="yes" xml:space="preserve">
          <source>Integer array indexing</source>
          <target state="translated">Индексирование по целому массиву</target>
        </trans-unit>
        <trans-unit id="a764d9440def338d1a721af2c9bc3cf9203fd57a" translate="yes" xml:space="preserve">
          <source>Integer array indexing allows selection of arbitrary items in the array based on their &lt;em&gt;N&lt;/em&gt;-dimensional index. Each integer array represents a number of indexes into that dimension.</source>
          <target state="translated">Индексирование целочисленного массива позволяет выбирать произвольные элементы в массиве на основе их &lt;em&gt;N-&lt;/em&gt; мерного индекса. Каждый целочисленный массив представляет собой несколько индексов в этом измерении.</target>
        </trans-unit>
        <trans-unit id="a46c6037b6ed3e2034603c23c6f4211c22a945c1" translate="yes" xml:space="preserve">
          <source>Integer exponents of 2. This is a scalar if &lt;code&gt;x&lt;/code&gt; is a scalar.</source>
          <target state="translated">Целочисленные показатели числа 2. Это скаляр, если &lt;code&gt;x&lt;/code&gt; - скаляр.</target>
        </trans-unit>
        <trans-unit id="a3173b86433d0db1fb5b647328822672be728221" translate="yes" xml:space="preserve">
          <source>Integer indicating how this dtype relates to the built-in dtypes.</source>
          <target state="translated">Целое число,указывающее,как этот тип относится к встроенным стипам.</target>
        </trans-unit>
        <trans-unit id="201042a920a1327277fe1dda0e55cd37046acf9f" translate="yes" xml:space="preserve">
          <source>Integer large enough to hold a pointer</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c0ad68cb65f108515f3a5b364ab814f280978530" translate="yes" xml:space="preserve">
          <source>Integer performance has a similar ordering.</source>
          <target state="translated">Целостная производительность имеет аналогичный заказ.</target>
        </trans-unit>
        <trans-unit id="006c632da5c7b1582b36540c57330b631facab3d" translate="yes" xml:space="preserve">
          <source>Integer that can hold a pointer</source>
          <target state="translated">Целое,которое может держать указатель</target>
        </trans-unit>
        <trans-unit id="b13be07f7abad8e811e3c73cea1a525a627e0bc2" translate="yes" xml:space="preserve">
          <source>Integer ufuncs vectorized with AVX2</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a334f0e07c1be58e6996ea133d59f4da9faac7a9" translate="yes" xml:space="preserve">
          <source>Integer used for indexing, typically the same as &lt;code&gt;ssize_t&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="654f37af768fdf3bb70ca69e758a2fe80f1abf09" translate="yes" xml:space="preserve">
          <source>Integers:</source>
          <target state="translated">Integers:</target>
        </trans-unit>
        <trans-unit id="84cede945b07b48bcb97421b3eb8bd4f5bd269e0" translate="yes" xml:space="preserve">
          <source>Integral part of &lt;code&gt;x&lt;/code&gt;. This is a scalar if &lt;code&gt;x&lt;/code&gt; is a scalar.</source>
          <target state="translated">Неотъемлемая часть &lt;code&gt;x&lt;/code&gt; . Это скаляр, если &lt;code&gt;x&lt;/code&gt; - скаляр.</target>
        </trans-unit>
        <trans-unit id="1ea3c0d26d1c5d1b53eb099b2c1cf7972b99ebe8" translate="yes" xml:space="preserve">
          <source>Integrate &lt;code&gt;y&lt;/code&gt; (&lt;code&gt;x&lt;/code&gt;) along given axis.</source>
          <target state="translated">Интегрируйте &lt;code&gt;y&lt;/code&gt; ( &lt;code&gt;x&lt;/code&gt; ) по заданной оси.</target>
        </trans-unit>
        <trans-unit id="cc54f713576053888447a5aa6f2b6660db759e79" translate="yes" xml:space="preserve">
          <source>Integrate a Chebyshev series.</source>
          <target state="translated">Интегрируйте Чебышевскую серию.</target>
        </trans-unit>
        <trans-unit id="f7e0820ca3cf5b80cf75499d63a15279548b4395" translate="yes" xml:space="preserve">
          <source>Integrate a Hermite series.</source>
          <target state="translated">Интегрируйте серию &quot;Эрмита&quot;.</target>
        </trans-unit>
        <trans-unit id="09cdc33ab9232f32b3ffa23eec0555fd0aad884d" translate="yes" xml:space="preserve">
          <source>Integrate a Hermite_e series.</source>
          <target state="translated">Интегрируйте серию Hermite_e.</target>
        </trans-unit>
        <trans-unit id="28e01e90e39bcd5c5a200d36b330a9fb8a0cc2c8" translate="yes" xml:space="preserve">
          <source>Integrate a Laguerre series.</source>
          <target state="translated">Интегрирована в серию Laguerre.</target>
        </trans-unit>
        <trans-unit id="e45d1046a79d8f27551599eaeb79cbfa5c322286" translate="yes" xml:space="preserve">
          <source>Integrate a Legendre series.</source>
          <target state="translated">Интеграция в серию &quot;Легенда&quot;.</target>
        </trans-unit>
        <trans-unit id="51617b9fadb594aa47fc197fa4afb1a0d12a97e3" translate="yes" xml:space="preserve">
          <source>Integrate a polynomial.</source>
          <target state="translated">Интегрируйте полиноминал.</target>
        </trans-unit>
        <trans-unit id="1b28e42d25bb1781655bdbd732badc274759c37c" translate="yes" xml:space="preserve">
          <source>Integrate along the given axis using the composite trapezoidal rule.</source>
          <target state="translated">Интегрируйте по заданной оси с помощью составного трапециевидного правила.</target>
        </trans-unit>
        <trans-unit id="f6bc7be2c5b5072601573fb92ccbc047dff88160" translate="yes" xml:space="preserve">
          <source>Integrate.</source>
          <target state="translated">Integrate.</target>
        </trans-unit>
        <trans-unit id="a77970f26b3a19856dc6d676e2149a78243716b5" translate="yes" xml:space="preserve">
          <source>Integrated squared error (ISE) estimator added to &lt;code&gt;histogram&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="24640b86177ce52879242a4e3855fb7330a6f367" translate="yes" xml:space="preserve">
          <source>Integration constant(s). The value of the first integral at &lt;code&gt;lbnd&lt;/code&gt; is the first value in the list, the value of the second integral at &lt;code&gt;lbnd&lt;/code&gt; is the second value, etc. If &lt;code&gt;k == []&lt;/code&gt; (the default), all constants are set to zero. If &lt;code&gt;m == 1&lt;/code&gt;, a single scalar can be given instead of a list.</source>
          <target state="translated">Константа (и) интегрирования. Значение первого интеграла в &lt;code&gt;lbnd&lt;/code&gt; является первым значением в списке, значение второго интеграла в &lt;code&gt;lbnd&lt;/code&gt; является вторым значением и т. Д. Если &lt;code&gt;k == []&lt;/code&gt; (по умолчанию), все константы устанавливаются в ноль. Если &lt;code&gt;m == 1&lt;/code&gt; , вместо списка можно указать один скаляр.</target>
        </trans-unit>
        <trans-unit id="faa7aa2d13f47c8dc8e8d870349e9f9bbf12fee6" translate="yes" xml:space="preserve">
          <source>Integration constant(s). The value of the first integral at zero is the first value in the list, the value of the second integral at zero is the second value, etc. If &lt;code&gt;k == []&lt;/code&gt; (the default), all constants are set to zero. If &lt;code&gt;m == 1&lt;/code&gt;, a single scalar can be given instead of a list.</source>
          <target state="translated">Константа (и) интегрирования. Значение первого интеграла в нуле является первым значением в списке, значение второго интеграла в нуле является вторым значением и т. Д. Если &lt;code&gt;k == []&lt;/code&gt; (по умолчанию), все константы устанавливаются в ноль. Если &lt;code&gt;m == 1&lt;/code&gt; , вместо списка можно указать один скаляр.</target>
        </trans-unit>
        <trans-unit id="79199da79d91b1fb5aeec3ae95134c32578dd203" translate="yes" xml:space="preserve">
          <source>Integration constants. The first constant is applied to the first integration, the second to the second, and so on. The list of values must less than or equal to &lt;code&gt;m&lt;/code&gt; in length and any missing values are set to zero.</source>
          <target state="translated">Константы интеграции. Первая константа применяется к первому интегрированию, вторая - ко второму и так далее. Список значений должен быть меньше или равен &lt;code&gt;m&lt;/code&gt; по длине, а любые пропущенные значения обнуляются.</target>
        </trans-unit>
        <trans-unit id="99a973b23f26b788591e237471230a61bc42bfca" translate="yes" xml:space="preserve">
          <source>Integration constants. They are given in the order of integration: those corresponding to highest-order terms come first.</source>
          <target state="translated">Интеграционные константы.Они даются в порядке интеграции:те,которые соответствуют терминам высшего порядка,стоят на первом месте.</target>
        </trans-unit>
        <trans-unit id="f1b63b1b837d115daafc12c34b184fde445bf116" translate="yes" xml:space="preserve">
          <source>Integration of array values using the composite trapezoidal rule.</source>
          <target state="translated">Интеграция значений массивов с помощью составного трапециевидного правила.</target>
        </trans-unit>
        <trans-unit id="272bd8e11d9a2557b005814cbc8295b6bce05913" translate="yes" xml:space="preserve">
          <source>Interaction with &lt;code&gt;scipy.sparse&lt;/code&gt; is a bit cleaner.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cf5308846512dd05b3fe349862b884d3dad34184" translate="yes" xml:space="preserve">
          <source>Interchange two axes of an array.</source>
          <target state="translated">Обменяться двумя осями массива.</target>
        </trans-unit>
        <trans-unit id="487fafdb343a2fa07aa1e904de9985413e377451" translate="yes" xml:space="preserve">
          <source>Interest paid against the loan changes during the life or the loan. The &lt;code&gt;per&lt;/code&gt; is the payment period to calculate the interest amount.</source>
          <target state="translated">Проценты, выплачиваемые против ссуды, меняются в течение срока действия ссуды. &lt;code&gt;per&lt;/code&gt; это платежный период для расчета суммы процентов.</target>
        </trans-unit>
        <trans-unit id="94a1603aa26be2dbffaf8cf5c3954f0266df1988" translate="yes" xml:space="preserve">
          <source>Interest portion of payment. If all input is scalar, returns a scalar float. If any input is array_like, returns interest payment for each input element. If multiple inputs are array_like, they all must have the same shape.</source>
          <target state="translated">Процентная часть платежа.Если все введенные данные являются скалярными,возвращается скалярный поплавок.Если любой вход является массивом_подобным,возвращает проценты за каждый входной элемент.Если несколько входов похожи на массив_,то все они должны иметь одинаковую форму.</target>
        </trans-unit>
        <trans-unit id="fae2c1a639317094eef5fc0747acae252e47559d" translate="yes" xml:space="preserve">
          <source>Interest rate paid on the cash flows</source>
          <target state="translated">Процентная ставка,выплачиваемая на денежные потоки</target>
        </trans-unit>
        <trans-unit id="bac9f8f12cdd23938b9506adf721b640d1387b0f" translate="yes" xml:space="preserve">
          <source>Interest rate received on the cash flows upon reinvestment</source>
          <target state="translated">Процентная ставка,полученная на денежные потоки при реинвестировании</target>
        </trans-unit>
        <trans-unit id="acbc7801b292b22fd84bb969c2c0f9ee879becf9" translate="yes" xml:space="preserve">
          <source>Interfacing to C</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5669f1ef998cb57e98a6c7c64ced935f3a20e1ba" translate="yes" xml:space="preserve">
          <source>Interfacing to C++:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0ef0659c2c669af8efd19f667b98f55614307e8e" translate="yes" xml:space="preserve">
          <source>Interfacing to Fortran:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5a1eb29a8757da9ba26cf2dfef44ad676331c673" translate="yes" xml:space="preserve">
          <source>Internal Flexibility</source>
          <target state="translated">Внутренняя гибкость</target>
        </trans-unit>
        <trans-unit id="ac2251ff80e959c9a76b1d8e25426050ad978681" translate="yes" xml:space="preserve">
          <source>Internal Rate of Return for periodic input values.</source>
          <target state="translated">Внутренняя скорость возврата для периодических входных значений.</target>
        </trans-unit>
        <trans-unit id="70e52d12f616579455cc3db6303a1fc61cf8ea38" translate="yes" xml:space="preserve">
          <source>Internal changes</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="811920182b71e4d6c39f62829f0533afa24b5bfb" translate="yes" xml:space="preserve">
          <source>Internal functions</source>
          <target state="translated">Внутренние функции</target>
        </trans-unit>
        <trans-unit id="ecdbace78f65adf7ab79aea820093f0235b38c83" translate="yes" xml:space="preserve">
          <source>Internal memory layout of an ndarray</source>
          <target state="translated">Внутренняя память андаррея</target>
        </trans-unit>
        <trans-unit id="4c771d77fd8a74b74dbd14733dbe89a221191139" translate="yes" xml:space="preserve">
          <source>Internal organization of numpy arrays</source>
          <target state="translated">Внутренняя организация нумизматических массивов</target>
        </trans-unit>
        <trans-unit id="8693ac81d62075b90be2f5012ceac7d5e0960c71" translate="yes" xml:space="preserve">
          <source>Internally used structures</source>
          <target state="translated">Внутренне используемые структуры</target>
        </trans-unit>
        <trans-unit id="353f9272117a257bd48156e257afe86724ce335c" translate="yes" xml:space="preserve">
          <source>Internally, buffers are used for misaligned data, swapped data, and data that has to be converted from one data type to another. The size of internal buffers is settable on a per-thread basis. There can be up to</source>
          <target state="translated">Внутренние буферы используются для неправильно выровненных данных,данных,подлежащих замене,и данных,которые необходимо преобразовать из одного типа данных в другой.Размер внутренних буферов настраивается для каждого потока.Может быть до</target>
        </trans-unit>
        <trans-unit id="0b9562a5febab6388bcaad8af8913734a30e5c69" translate="yes" xml:space="preserve">
          <source>Internally, the code uses some additional Python objects primarily for memory management. These types are not accessible directly from Python, and are not exposed to the C-API. They are included here only for completeness and assistance in understanding the code.</source>
          <target state="translated">Внутренне код использует некоторые дополнительные объекты на Python в первую очередь для управления памятью.Эти типы недоступны напрямую с Python и не подвержены C-API.Они включены сюда только для полноты и облегчения понимания кода.</target>
        </trans-unit>
        <trans-unit id="88c585f236f03e4d85467407665675347bdfa2c1" translate="yes" xml:space="preserve">
          <source>Internally, these #defines work as follows:</source>
          <target state="translated">Внутренне эти #определения работают следующим образом:</target>
        </trans-unit>
        <trans-unit id="2e02d69fdcfa7dd47d4e20a9c3718e372f145dcc" translate="yes" xml:space="preserve">
          <source>Interoperability-Related Options</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b400cd2b32800b89445114d966c1ee1e1e2f5b22" translate="yes" xml:space="preserve">
          <source>Interpolate a function at the Chebyshev points of the first kind.</source>
          <target state="translated">Интерполируйте функцию на чебышевских точках первого рода.</target>
        </trans-unit>
        <trans-unit id="b0124a6fa4961521e8ff39aa6c372018194a4ebf" translate="yes" xml:space="preserve">
          <source>Interpolating Chebyshev instance.</source>
          <target state="translated">Интерполируя Чебышева.</target>
        </trans-unit>
        <trans-unit id="1427e61ed742cbf9aa91a5c0cf7909917aab75eb" translate="yes" xml:space="preserve">
          <source>Interpolation with periodic x-coordinates:</source>
          <target state="translated">Интерполяция с периодическими х-координатами:</target>
        </trans-unit>
        <trans-unit id="437831e765e33b0f2fa769dfde52d2c581b5cfbf" translate="yes" xml:space="preserve">
          <source>Interpret a buffer as a 1-dimensional array.</source>
          <target state="translated">Интерпретировать буфер как 1-мерный массив.</target>
        </trans-unit>
        <trans-unit id="9feed02e3d661ed814b67ed529ab9195e31b0cb4" translate="yes" xml:space="preserve">
          <source>Interpret the input as a matrix.</source>
          <target state="translated">Интерпретируйте вход как матрицу.</target>
        </trans-unit>
        <trans-unit id="a0422cc647bba954b177a29fbf1305b2895860e3" translate="yes" xml:space="preserve">
          <source>Interrupt Handling</source>
          <target state="translated">обработка прерывания</target>
        </trans-unit>
        <trans-unit id="e5f5d0f73f8dc2d6363a75fe32ba76d7d8dff9cc" translate="yes" xml:space="preserve">
          <source>Intrinsic NumPy Array Creation</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7e2ea7ccd882296e2e16cdecb01f04008d30cfc7" translate="yes" xml:space="preserve">
          <source>Intrinsic numpy array creation objects (e.g., arange, ones, zeros, etc.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dcd3fd94e72c882e4eaa006cb5da780542c07011" translate="yes" xml:space="preserve">
          <source>Introduce yourself to Git:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2473e96bc614a911821242119918a241a41836d6" translate="yes" xml:space="preserve">
          <source>Introduction</source>
          <target state="translated">Introduction</target>
        </trans-unit>
        <trans-unit id="b6ab6d57043280ab296716031275867d148d3ca7" translate="yes" xml:space="preserve">
          <source>Introduction to byte ordering and ndarrays</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="24583ffa86b443c7a55325e4b25e34083f63ac92" translate="yes" xml:space="preserve">
          <source>Invalid arguments for array ordering</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="46dbc8721ef190eab06879ef282ac69a2d11056b" translate="yes" xml:space="preserve">
          <source>Invalid data means values of &lt;code&gt;nan&lt;/code&gt;, &lt;code&gt;inf&lt;/code&gt;, etc.</source>
          <target state="translated">Неверные данные означают значения &lt;code&gt;nan&lt;/code&gt; , &lt;code&gt;inf&lt;/code&gt; и т. Д.</target>
        </trans-unit>
        <trans-unit id="b66a9668314f5851a31b3926b89142340d67c1e0" translate="yes" xml:space="preserve">
          <source>Invalid fill value exceptions</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6dd811ad3cf2203333b0468d5361ce3f92b716aa" translate="yes" xml:space="preserve">
          <source>Invalid operation: result is not an expressible number, typically indicates that a NaN was produced.</source>
          <target state="translated">Недействительная операция:результат не является экспрессивным числом,обычно указывает на то,что был произведен NaN.</target>
        </trans-unit>
        <trans-unit id="dfed6b5bd73798f6efbc4f77cde7ac568bd5cdfb" translate="yes" xml:space="preserve">
          <source>Inverse hyperbolic cosine, element-wise.</source>
          <target state="translated">Обратный гиперболический косинус,по элементам.</target>
        </trans-unit>
        <trans-unit id="21de990f2f734fbb43aa31870f6cebb10139a34e" translate="yes" xml:space="preserve">
          <source>Inverse hyperbolic sine element-wise.</source>
          <target state="translated">Обратный гиперболический синусоидальный элемент.</target>
        </trans-unit>
        <trans-unit id="ae6bb16d1805cc3ebef5cfaf633f1f868061a8dc" translate="yes" xml:space="preserve">
          <source>Inverse hyperbolic tangent element-wise.</source>
          <target state="translated">Обратный гиперболический тангенс по элементам.</target>
        </trans-unit>
        <trans-unit id="2c6d3ed37e9c36a516eafee4d6cf6bce8fa583e5" translate="yes" xml:space="preserve">
          <source>Inverse sine, element-wise.</source>
          <target state="translated">Обратный синус,по элементам.</target>
        </trans-unit>
        <trans-unit id="9b049bc33b3f3b47e868bbdc217dc4db5fb5be2d" translate="yes" xml:space="preserve">
          <source>Inverses of several matrices can be computed at once:</source>
          <target state="translated">Можно вычислить инверсии нескольких матриц одновременно:</target>
        </trans-unit>
        <trans-unit id="bafff722f42fe9db3b595ab6ea0bb84953a6e8ad" translate="yes" xml:space="preserve">
          <source>Investigate. Change directory to your new repo: &lt;code&gt;cd numpy&lt;/code&gt;. Then &lt;code&gt;git branch -a&lt;/code&gt; to show you all branches. You&amp;rsquo;ll get something like:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="525b73c1bc26402f8fe2106a7fc0623195c4b729" translate="yes" xml:space="preserve">
          <source>Is equivalent to &lt;code&gt;np.delete(arr, [0,2,4], axis=0)&lt;/code&gt;, but allows further use of &lt;code&gt;mask&lt;/code&gt;.</source>
          <target state="translated">Эквивалентно &lt;code&gt;np.delete(arr, [0,2,4], axis=0)&lt;/code&gt; , но допускает дальнейшее использование &lt;code&gt;mask&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="24c5caf7c1723177101292b0ec91f3f69f7573df" translate="yes" xml:space="preserve">
          <source>Is straightforward to reverse engineer. Datasets often live longer than the programs that created them. A competent developer should be able to create a solution in their preferred programming language to read most &lt;code&gt;.npy&lt;/code&gt; files that he has been given without much documentation.</source>
          <target state="translated">Легко перепроектировать. Наборы данных часто живут дольше, чем программы, которые их создали. Компетентный разработчик должен иметь возможность создать решение на предпочитаемом им языке программирования для чтения большинства &lt;code&gt;.npy&lt;/code&gt; файлов .npy без дополнительной документации.</target>
        </trans-unit>
        <trans-unit id="1a81d4101d801108adb8aad8206475022e2e35b0" translate="yes" xml:space="preserve">
          <source>Is the given function something that we know how to overload?</source>
          <target state="translated">Является ли данная функция чем-то,что мы знаем,как перегрузить?</target>
        </trans-unit>
        <trans-unit id="b10180fbee8cac98fb1ea7940ed518f48a70dee3" translate="yes" xml:space="preserve">
          <source>Issued by &lt;a href=&quot;generated/numpy.polyfit#numpy.polyfit&quot;&gt;&lt;code&gt;polyfit&lt;/code&gt;&lt;/a&gt; when the Vandermonde matrix is rank deficient.</source>
          <target state="translated">Выдается &lt;a href=&quot;generated/numpy.polyfit#numpy.polyfit&quot;&gt; &lt;code&gt;polyfit&lt;/code&gt; ,&lt;/a&gt; когда матрица Вандермонда имеет недостаточный ранг.</target>
        </trans-unit>
        <trans-unit id="2c7da8ef717a7e944f5132cdc9e7ea084630c1b8" translate="yes" xml:space="preserve">
          <source>Issued by &lt;a href=&quot;numpy.polyfit#numpy.polyfit&quot;&gt;&lt;code&gt;polyfit&lt;/code&gt;&lt;/a&gt; when the Vandermonde matrix is rank deficient.</source>
          <target state="translated">Выдается &lt;a href=&quot;numpy.polyfit#numpy.polyfit&quot;&gt; &lt;code&gt;polyfit&lt;/code&gt; ,&lt;/a&gt; когда матрица Вандермонда имеет недостаточный ранг.</target>
        </trans-unit>
        <trans-unit id="62ecce1ee2f04057e107579d5bef99ec7e6758b0" translate="yes" xml:space="preserve">
          <source>Issued by chebfit when the design matrix is rank deficient.</source>
          <target state="translated">Выпускается Chebfit,когда матрица дизайна имеет недостаток ранга.</target>
        </trans-unit>
        <trans-unit id="ed3a53b09f923a24c6dd04195732883fc05144f5" translate="yes" xml:space="preserve">
          <source>Issued by the generic Poly class when two domains don&amp;rsquo;t match.</source>
          <target state="translated">Выдается общим классом Poly, когда два домена не совпадают.</target>
        </trans-unit>
        <trans-unit id="f00ecef77fb41ae5e26098e89f064e811f1d6ae9" translate="yes" xml:space="preserve">
          <source>Issues Fixed</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b19e94cfda274542200371fca470c64546558300" translate="yes" xml:space="preserve">
          <source>Issues a DeprecationWarning, adds warning to &lt;code&gt;old_name&lt;/code&gt;&amp;rsquo;s docstring, rebinds &lt;code&gt;old_name.__name__&lt;/code&gt; and returns the new function object.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9ddf288870dda342df98b4b9313d3dcfea4defcb" translate="yes" xml:space="preserve">
          <source>Issues fixed</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dee1de34f5e6dfdd4c0e68ce69b1f31528f724f6" translate="yes" xml:space="preserve">
          <source>It can also be used in places of &lt;a href=&quot;numpy.atleast_1d#numpy.atleast_1d&quot;&gt;&lt;code&gt;atleast_1d&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;numpy.atleast_2d#numpy.atleast_2d&quot;&gt;&lt;code&gt;atleast_2d&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">Его также можно использовать в местах &lt;a href=&quot;numpy.atleast_1d#numpy.atleast_1d&quot;&gt; &lt;code&gt;atleast_1d&lt;/code&gt; &lt;/a&gt; и &lt;a href=&quot;numpy.atleast_2d#numpy.atleast_2d&quot;&gt; &lt;code&gt;atleast_2d&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="378d5136b02c66ae2366b0871c9dc87a59e458eb" translate="yes" xml:space="preserve">
          <source>It can be considered as a generalization of EPS: &lt;code&gt;spacing(np.float64(1)) == np.finfo(np.float64).eps&lt;/code&gt;, and there should not be any representable number between &lt;code&gt;x + spacing(x)&lt;/code&gt; and x for any finite x.</source>
          <target state="translated">Его можно рассматривать как обобщение EPS: &lt;code&gt;spacing(np.float64(1)) == np.finfo(np.float64).eps&lt;/code&gt; , и не должно быть никакого представимого числа между &lt;code&gt;x + spacing(x)&lt;/code&gt; и x для любой конечный x.</target>
        </trans-unit>
        <trans-unit id="1ef0650f598bd8c46d6488dc9e1ecf7f36a57c12" translate="yes" xml:space="preserve">
          <source>It can be shown that a convolution</source>
          <target state="translated">Можно показать,что конволюция</target>
        </trans-unit>
        <trans-unit id="3a39f7205319edd1c303f4671f99c8c35d8b49e6" translate="yes" xml:space="preserve">
          <source>It can be shown that if</source>
          <target state="translated">Можно показать,что если</target>
        </trans-unit>
        <trans-unit id="6680413ecf8178af7a6bc1c7bc275bc8809885e1" translate="yes" xml:space="preserve">
          <source>It differs from the forward transform by the sign of the exponential argument and the default normalization by</source>
          <target state="translated">Она отличается от прямого преобразования знаком экспоненциального аргумента и нормализации по умолчанию знаком</target>
        </trans-unit>
        <trans-unit id="d2a43fea3528f404f8930330d870fe7079aa62c4" translate="yes" xml:space="preserve">
          <source>It does &lt;em&gt;not&lt;/em&gt; generally hold that &lt;code&gt;self.strides[-1] == self.itemsize&lt;/code&gt; for C-style contiguous arrays or &lt;code&gt;self.strides[0] == self.itemsize&lt;/code&gt; for Fortran-style contiguous arrays is true.</source>
          <target state="translated">Обычно &lt;em&gt;не&lt;/em&gt; считается, что &lt;code&gt;self.strides[-1] == self.itemsize&lt;/code&gt; для непрерывных массивов в стиле C или &lt;code&gt;self.strides[0] == self.itemsize&lt;/code&gt; для непрерывных массивов в стиле Fortran истинно.</target>
        </trans-unit>
        <trans-unit id="47be37fff5f8f22af765f82be2c6bfbaf9c3032a" translate="yes" xml:space="preserve">
          <source>It has the following structure:</source>
          <target state="translated">Он имеет следующую структуру:</target>
        </trans-unit>
        <trans-unit id="9d66b7021aa904bae4cfae41aeb4ea6450db47e9" translate="yes" xml:space="preserve">
          <source>It has the probability density function</source>
          <target state="translated">Он имеет функцию плотности вероятности</target>
        </trans-unit>
        <trans-unit id="8df067c80d1dbac7caebbaa192d51d71072198f4" translate="yes" xml:space="preserve">
          <source>It helps to understand a bit about how numpy arrays are handled under the covers to help understand numpy better. This section will not go into great detail. Those wishing to understand the full details are referred to Travis Oliphant&amp;rsquo;s book &amp;ldquo;Guide to NumPy&amp;rdquo;.</source>
          <target state="translated">Это помогает немного понять, как массивы numpy обрабатываются под обложками, чтобы лучше понять numpy. Этот раздел не будет вдаваться в подробности. Тем, кто хочет разобраться в деталях, отсылаем к книге Трэвиса Олифанта &amp;laquo;Руководство по NumPy&amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="2fbb89405ce29cc8160fa307e221950fa152cd3e" translate="yes" xml:space="preserve">
          <source>It is also possible to select more than one item at a time, using &lt;em&gt;slicing&lt;/em&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c6785902c796379d2b6f1ca680d1350c037d297a" translate="yes" xml:space="preserve">
          <source>It is an error to have index values out of bounds:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9bd3e350ace36c053f4770c254bc8bbc0ed59492" translate="yes" xml:space="preserve">
          <source>It is assumed that all indices of &lt;code&gt;x&lt;/code&gt; are summed over in the product, together with the rightmost indices of &lt;code&gt;a&lt;/code&gt;, as is done in, for example, &lt;code&gt;tensordot(a, x, axes=b.ndim)&lt;/code&gt;.</source>
          <target state="translated">Предполагается, что все индексы &lt;code&gt;x&lt;/code&gt; суммируются в произведении вместе с крайними правыми индексами &lt;code&gt;a&lt;/code&gt; , как это делается, например, в &lt;code&gt;tensordot(a, x, axes=b.ndim)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="58008c74c97fe4d3ae3f9ae78ab47043dddec099" translate="yes" xml:space="preserve">
          <source>It is available from:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ca7dcbab26b74b24d5b23e3d1dfbaa7bb550a61f" translate="yes" xml:space="preserve">
          <source>It is convenient to use &lt;a href=&quot;numpy.poly1d#numpy.poly1d&quot;&gt;&lt;code&gt;poly1d&lt;/code&gt;&lt;/a&gt; objects for dealing with polynomials:</source>
          <target state="translated">Для работы с полиномами удобно использовать объекты &lt;a href=&quot;numpy.poly1d#numpy.poly1d&quot;&gt; &lt;code&gt;poly1d&lt;/code&gt; &lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="ee3d89b7c311757a10611a623afead7359a99d73" translate="yes" xml:space="preserve">
          <source>It is convenient to use &lt;code&gt;poly1d&lt;/code&gt; objects for dealing with polynomials:</source>
          <target state="translated">Для работы с полиномами удобно использовать объекты &lt;code&gt;poly1d&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="f0b5d505c1b6aa0449adcda591bae28c54d28b79" translate="yes" xml:space="preserve">
          <source>It is difficult to distribute an extension module made using ctypes because of a lack of support for building shared libraries in distutils (but I suspect this will change in time).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f6233db9ea353c629e411da73701b45f43b34d4b" translate="yes" xml:space="preserve">
          <source>It is easy to lose a clean separation between Python and C which makes re-using your C-code for other non-Python-related projects more difficult.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="09772c45572066c0ab1839c5da61b341c459c08d" translate="yes" xml:space="preserve">
          <source>It is equivalent to &lt;code&gt;reshape(-1, order=order)&lt;/code&gt;.</source>
          <target state="translated">Это эквивалентно &lt;code&gt;reshape(-1, order=order)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8649182deb90f9e5b82c97ccd124c9f5e91bbefa" translate="yes" xml:space="preserve">
          <source>It is expected that function &lt;code&gt;func&lt;/code&gt; has been defined externally. In order to use a Python function as &lt;code&gt;func&lt;/code&gt;, it must have an attribute &lt;code&gt;intent(callback)&lt;/code&gt; (it must be specified before the &lt;code&gt;external&lt;/code&gt; statement).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="41074d06eaa1aca6cfcc81add0a6d4a0de1496e0" translate="yes" xml:space="preserve">
          <source>It is expected that the Council Members will be employed at a wide range of companies, universities and non-profit organizations. Because of this, it is possible that Members will have conflict of interests. Such conflict of interests include, but are not limited to:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e897ba8d8d1e35fdbcdafccfd6dd8ffccaf71314" translate="yes" xml:space="preserve">
          <source>It is good practice to tell &lt;a href=&quot;https://git-scm.com/&quot;&gt;git&lt;/a&gt; who you are, for labeling any changes you make to the code. The simplest way to do this is from the command line:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9c72b281ec77874c2a8219572de87ebec10916f2" translate="yes" xml:space="preserve">
          <source>It is important to keep in mind that you get a &lt;em&gt;borrowed&lt;/em&gt; reference to the object when using the &amp;ldquo;O&amp;rdquo; format string. However, the converter functions usually require some form of memory handling. In this example, if the conversion is successful, &lt;em&gt;dtype&lt;/em&gt; will hold a new reference to a &lt;a href=&quot;../reference/c-api/types-and-structures#c.PyArray_Descr&quot;&gt;&lt;code&gt;PyArray_Descr *&lt;/code&gt;&lt;/a&gt; object, while &lt;em&gt;input&lt;/em&gt; will hold a borrowed reference. Therefore, if this conversion were mixed with another conversion (say to an integer) and the data-type conversion was successful but the integer conversion failed, then you would need to release the reference count to the data-type object before returning. A typical way to do this is to set &lt;em&gt;dtype&lt;/em&gt; to &lt;code&gt;NULL&lt;/code&gt; before calling &lt;a href=&quot;https://docs.python.org/dev/c-api/arg.html#c.PyArg_ParseTuple&quot;&gt;&lt;code&gt;PyArg_ParseTuple&lt;/code&gt;&lt;/a&gt; and then use &lt;a href=&quot;https://docs.python.org/dev/c-api/refcounting.html#c.Py_XDECREF&quot;&gt;&lt;code&gt;Py_XDECREF&lt;/code&gt;&lt;/a&gt; on &lt;em&gt;dtype&lt;/em&gt; before returning.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="68e5e295697e350544ce52515eda2757f41a1612" translate="yes" xml:space="preserve">
          <source>It is important to keep the flags updated (using &lt;a href=&quot;#c.PyArray_UpdateFlags&quot;&gt;&lt;code&gt;PyArray_UpdateFlags&lt;/code&gt;&lt;/a&gt; can help) whenever a manipulation with an array is performed that might cause them to change. Later calculations in NumPy that rely on the state of these flags do not repeat the calculation to update them.</source>
          <target state="translated">Важно обновлять флаги ( может помочь использование &lt;a href=&quot;#c.PyArray_UpdateFlags&quot;&gt; &lt;code&gt;PyArray_UpdateFlags&lt;/code&gt; &lt;/a&gt; ) всякий раз, когда выполняется манипуляция с массивом, которая может привести к их изменению. Более поздние вычисления в NumPy, которые зависят от состояния этих флагов, не повторяют вычисления для их обновления.</target>
        </trans-unit>
        <trans-unit id="6dd28e38486b7b23cc628bcffec168f7a3e2908d" translate="yes" xml:space="preserve">
          <source>It is important to note that once the iterator is exited, dangling references (like &lt;code&gt;x&lt;/code&gt; in the example) may or may not share data with the original data &lt;code&gt;a&lt;/code&gt;. If writeback semantics were active, i.e. if &lt;code&gt;x.base.flags.writebackifcopy&lt;/code&gt; is &lt;code&gt;True&lt;/code&gt;, then exiting the iterator will sever the connection between &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;a&lt;/code&gt;, writing to &lt;code&gt;x&lt;/code&gt; will no longer write to &lt;code&gt;a&lt;/code&gt;. If writeback semantics are not active, then &lt;code&gt;x.data&lt;/code&gt; will still point at some part of &lt;code&gt;a.data&lt;/code&gt;, and writing to one will affect the other.</source>
          <target state="translated">Важно отметить, что после выхода из итератора висячие ссылки (например, &lt;code&gt;x&lt;/code&gt; в примере) могут или не могут совместно использовать данные с исходными данными &lt;code&gt;a&lt;/code&gt; . Если семантика обратной записи была активна, т.е. если &lt;code&gt;x.base.flags.writebackifcopy&lt;/code&gt; имеет значение &lt;code&gt;True&lt;/code&gt; , то выход из итератора разорвет соединение между &lt;code&gt;x&lt;/code&gt; и &lt;code&gt;a&lt;/code&gt; , запись в &lt;code&gt;x&lt;/code&gt; больше не будет записывать в &lt;code&gt;a&lt;/code&gt; . Если семантика обратной записи не активна, то &lt;code&gt;x.data&lt;/code&gt; по- прежнему будет указывать на некоторую часть &lt;code&gt;a.data&lt;/code&gt; , и запись в одну повлияет на другую.</target>
        </trans-unit>
        <trans-unit id="63bda28ddda57fde741844f509673a49e4004752" translate="yes" xml:space="preserve">
          <source>It is important to retain an archive of all activities of this committee to ensure consistency in behavior and provide institutional memory for the project. To assist in this, the default channel of discussion for this committee will be a private mailing list accessible to current and future members of the committee as well as members of the Steering Council upon justified request. If the Committee finds the need to use off-list communications (e.g. phone calls for early/rapid response), it should in all cases summarize these back to the list so there&amp;rsquo;s a good record of the process.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a263f6ef91dbde8a42fa624ef445c812e662a622" translate="yes" xml:space="preserve">
          <source>It is intended that all polynomial instances are immutable, therefore augmented operations (&lt;code&gt;+=&lt;/code&gt;, &lt;code&gt;-=&lt;/code&gt;, etc.) and any other functionality that would violate the immutablity of a polynomial instance are intentionally unimplemented.</source>
          <target state="translated">Предполагается, что все экземпляры полинома являются неизменяемыми, поэтому расширенные операции ( &lt;code&gt;+=&lt;/code&gt; , &lt;code&gt;-=&lt;/code&gt; и т. Д.) И любые другие функции, которые могут нарушить неизменность экземпляра полинома, намеренно не реализуются.</target>
        </trans-unit>
        <trans-unit id="8b8f2e17893170efcb86b57f32479a3f40a7b944" translate="yes" xml:space="preserve">
          <source>It is named for the American linguist George Kingsley Zipf, who noted that the frequency of any word in a sample of a language is inversely proportional to its rank in the frequency table.</source>
          <target state="translated">Он назван в честь американского лингвиста Джорджа Кингсли Ципфа,который отметил,что частота любого слова в выборке языка обратно пропорциональна его рангу в таблице частот.</target>
        </trans-unit>
        <trans-unit id="21e4b23be2d40c69036b3d2e468ea13e53868304" translate="yes" xml:space="preserve">
          <source>It is no longer recommended to use this class, even for linear</source>
          <target state="translated">Больше не рекомендуется использовать этот класс,даже для линейных</target>
        </trans-unit>
        <trans-unit id="c8350ce47be17c20baa97fc4d0754bec81b2f208" translate="yes" xml:space="preserve">
          <source>It is no longer recommended to use this class, even for linear algebra. Instead use regular arrays. The class may be removed in the future.</source>
          <target state="translated">Больше не рекомендуется использовать этот класс,даже для линейной алгебры.Вместо этого используйте обычные массивы.В будущем класс может быть удален.</target>
        </trans-unit>
        <trans-unit id="8c5239a5bff654c37cc55078706d5d6b20118c0c" translate="yes" xml:space="preserve">
          <source>It is not always possible to change the shape of an array without copying the data. If you want an error to be raised when the data is copied, you should assign the new shape to the shape attribute of the array:</source>
          <target state="translated">Не всегда можно изменить форму массива,не скопировав данные.Если вы хотите,чтобы при копировании данных возникла ошибка,необходимо присвоить новую форму атрибуту формы массива:</target>
        </trans-unit>
        <trans-unit id="656bf2f4ae8187e5defb4f5552faf2fbd1f5fad1" translate="yes" xml:space="preserve">
          <source>It is not difficult to create your own ufunc. All that is required is a 1-d loop for each data-type you want to support. Each 1-d loop must have a specific signature, and only ufuncs for fixed-size data-types can be used. The function call used to create a new ufunc to work on built-in data-types is given below. A different mechanism is used to register ufuncs for user-defined data-types.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d8b548648b06bad09d9ab843a8e5797d1798c5b5" translate="yes" xml:space="preserve">
          <source>It is not necessary to use the doctest markup &lt;code&gt;&amp;lt;BLANKLINE&amp;gt;&lt;/code&gt; to indicate empty lines in the output. Note that the option to run the examples through &lt;code&gt;numpy.test&lt;/code&gt; is provided for checking if the examples work, not for making the examples part of the testing framework.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b37f77a2246e7fcb1e0b4774efe6b903d4205875" translate="yes" xml:space="preserve">
          <source>It is often seen in Bayesian inference and order statistics.</source>
          <target state="translated">Это часто встречается в байесовских умозаключениях и статистике заказов.</target>
        </trans-unit>
        <trans-unit id="7bef780e922069dd57c2e5a08856175d82409e4f" translate="yes" xml:space="preserve">
          <source>It is one of a class of extreme value distributions, the Generalized Extreme Value (GEV) distributions, which also includes the Weibull and Frechet.</source>
          <target state="translated">Это один из классов распределений экстремальных значений,Generalized Extreme Value (GEV),который также включает в себя Weibull и Frechet.</target>
        </trans-unit>
        <trans-unit id="5071b59a11ab8c54d2368dbe31b14e825424a9ec" translate="yes" xml:space="preserve">
          <source>It is possible to index arrays with other arrays for the purposes of selecting lists of values out of arrays into new arrays. There are two different ways of accomplishing this. One uses one or more arrays of index values. The other involves giving a boolean array of the proper shape to indicate the values to be selected. Index arrays are a very powerful tool that allow one to avoid looping over individual elements in arrays and thus greatly improve performance.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="36000cdc40cdbba3e0e5f28ba7dcb30e267b4506" translate="yes" xml:space="preserve">
          <source>It is possible to load a library using &amp;gt;&amp;gt;&amp;gt; lib = ctypes.cdll[&amp;lt;full_path_name&amp;gt;] # doctest: +SKIP</source>
          <target state="translated">Библиотеку можно загрузить с помощью &amp;gt;&amp;gt;&amp;gt; lib = ctypes.cdll [&amp;lt;full_path_name&amp;gt;] # doctest: + SKIP</target>
        </trans-unit>
        <trans-unit id="38fbbd2c67dc08fbfcb5c5de50ecf788043a91ae" translate="yes" xml:space="preserve">
          <source>It is possible to slice and stride arrays to extract arrays of the same number of dimensions, but of different sizes than the original. The slicing and striding works exactly the same way it does for lists and tuples except that they can be applied to multiple dimensions as well. A few examples illustrates best:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0a211923eef6c9018ec875b45f1ee8aa7feb24f0" translate="yes" xml:space="preserve">
          <source>It is possible to specify config_fc options in setup.py scripts. For example, using</source>
          <target state="translated">Опции config_fc можно указать в скриптах setup.py.Например,используя</target>
        </trans-unit>
        <trans-unit id="3af7692eade07c544a49c1e0a3fa2b4f67d86e02" translate="yes" xml:space="preserve">
          <source>It is possible to specify how boundaries are treated using &lt;code&gt;edge_order&lt;/code&gt;</source>
          <target state="translated">Можно указать, как обрабатываются границы с помощью &lt;code&gt;edge_order&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="425695dd90c5cd68dc182714b9d0871e6107582e" translate="yes" xml:space="preserve">
          <source>It is possible to use methods from linear algebra to approximate an existing set of data. Here, we will use the &lt;a href=&quot;https://en.wikipedia.org/wiki/Singular_value_decomposition&quot;&gt;SVD (Singular Value Decomposition)&lt;/a&gt; to try to rebuild an image that uses less singular value information than the original one, while still retaining some of its features.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9279d7909405dcb9e4e547b0701fbd4a212eac71" translate="yes" xml:space="preserve">
          <source>It is possible to use special features to effectively increase the number of dimensions in an array through indexing so the resulting array acquires the shape needed for use in an expression or with a specific function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="006848dc30e65d20b3919e74b2fa41c8170663f6" translate="yes" xml:space="preserve">
          <source>It is recommended to use one of &lt;a href=&quot;numpy.testing.assert_allclose#numpy.testing.assert_allclose&quot;&gt;&lt;code&gt;assert_allclose&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;numpy.testing.assert_array_almost_equal_nulp#numpy.testing.assert_array_almost_equal_nulp&quot;&gt;&lt;code&gt;assert_array_almost_equal_nulp&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;numpy.testing.assert_array_max_ulp#numpy.testing.assert_array_max_ulp&quot;&gt;&lt;code&gt;assert_array_max_ulp&lt;/code&gt;&lt;/a&gt; instead of this function for more consistent floating point comparisons.</source>
          <target state="translated">Рекомендуется использовать одну из &lt;a href=&quot;numpy.testing.assert_allclose#numpy.testing.assert_allclose&quot;&gt; &lt;code&gt;assert_allclose&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;numpy.testing.assert_array_almost_equal_nulp#numpy.testing.assert_array_almost_equal_nulp&quot;&gt; &lt;code&gt;assert_array_almost_equal_nulp&lt;/code&gt; &lt;/a&gt; или &lt;a href=&quot;numpy.testing.assert_array_max_ulp#numpy.testing.assert_array_max_ulp&quot;&gt; &lt;code&gt;assert_array_max_ulp&lt;/code&gt; &lt;/a&gt; вместо этой функции для более согласованных сравнений с плавающей запятой.</target>
        </trans-unit>
        <trans-unit id="e411ddee11ac634d5c4281835040dc7466b061ac" translate="yes" xml:space="preserve">
          <source>It is strongly advised &lt;em&gt;not&lt;/em&gt; to use the matrix subclass. As described below, it makes writing functions that deal consistently with matrices and regular arrays very difficult. Currently, they are mainly used for interacting with &lt;code&gt;scipy.sparse&lt;/code&gt;. We hope to provide an alternative for this use, however, and eventually remove the &lt;code&gt;matrix&lt;/code&gt; subclass.</source>
          <target state="translated">Настоятельно рекомендуется &lt;em&gt;не&lt;/em&gt; использовать подкласс матрицы. Как описано ниже, это очень затрудняет написание функций, которые последовательно работают с матрицами и обычными массивами. В настоящее время они в основном используются для взаимодействия с &lt;code&gt;scipy.sparse&lt;/code&gt; . Однако мы надеемся предоставить альтернативу для этого использования и в конечном итоге удалить подкласс &lt;code&gt;matrix&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7669de0e65d605729606ade6c00d09dc551353c4" translate="yes" xml:space="preserve">
          <source>It is used, for example, in modeling the over-reporting of insurance claims.</source>
          <target state="translated">Он используется,например,при моделировании завышенной отчетности по страховым требованиям.</target>
        </trans-unit>
        <trans-unit id="ca0ecc89a435e5703a52f043959e28e66dbb2433" translate="yes" xml:space="preserve">
          <source>It is useful for writing classes that do not inherit from &lt;a href=&quot;numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;numpy.ndarray&lt;/code&gt;&lt;/a&gt;, but that should support arithmetic and numpy universal functions like arrays as described in &lt;a href=&quot;../../neps/nep-0013-ufunc-overrides&quot;&gt;A Mechanism for Overriding Ufuncs&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e32c0ef1527073446df56f2f6fdb74c9774fe25a" translate="yes" xml:space="preserve">
          <source>It is useful for writing classes that do not inherit from &lt;a href=&quot;numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;numpy.ndarray&lt;/code&gt;&lt;/a&gt;, but that should support arithmetic and numpy universal functions like arrays as described in &lt;a href=&quot;https://docs.scipy.org/doc/numpy-1.17.0/neps/nep-0013-ufunc-overrides.html&quot;&gt;A Mechanism for Overriding Ufuncs&lt;/a&gt;.</source>
          <target state="translated">Это полезно для написания классов, которые не наследуются от &lt;a href=&quot;numpy.ndarray#numpy.ndarray&quot;&gt; &lt;code&gt;numpy.ndarray&lt;/code&gt; &lt;/a&gt; , но которые должны поддерживать арифметические и универсальные функции numpy, такие как массивы, как описано в &lt;a href=&quot;https://docs.scipy.org/doc/numpy-1.17.0/neps/nep-0013-ufunc-overrides.html&quot;&gt;Механизме переопределения Ufuncs&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="d3b8ad76686cc18b830ba552fba24082c4f933e5" translate="yes" xml:space="preserve">
          <source>It is worth noting that if</source>
          <target state="translated">Стоит отметить,что если</target>
        </trans-unit>
        <trans-unit id="29b82dd1d6f270f96b8bc45104bc41a8e589f966" translate="yes" xml:space="preserve">
          <source>It isn&amp;rsquo;t always convenient to explicitly use Polynomial instances, so tuples, lists, arrays, and scalars are automatically cast in the arithmetic operations:</source>
          <target state="translated">Не всегда удобно использовать экземпляры Polynomial явно, поэтому кортежи, списки, массивы и скаляры автоматически приводятся в арифметических операциях:</target>
        </trans-unit>
        <trans-unit id="cf495221779c2163a5e7a39d1bf1b540324c978b" translate="yes" xml:space="preserve">
          <source>It landed 4 times on 1, once on 2, etc.</source>
          <target state="translated">Он приземлялся 4 раза на 1,один раз на 2 и т.д.</target>
        </trans-unit>
        <trans-unit id="d1653963d10a9096aa75746f96dbe0fd1387381e" translate="yes" xml:space="preserve">
          <source>It may also be convenient to define a custom decorators (&lt;code&gt;implements&lt;/code&gt; below) for registering &lt;code&gt;__array_function__&lt;/code&gt; implementations.</source>
          <target state="translated">Также может быть удобно определить пользовательские декораторы ( &lt;code&gt;implements&lt;/code&gt; ниже) для регистрации реализаций &lt;code&gt;__array_function__&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3598c5e5543d6be85e81adfe21a8be7084de89d0" translate="yes" xml:space="preserve">
          <source>It may be preferable to split the projected cashflow into an initial investment and expected future cashflows. In this case, the value of the initial cashflow is zero and the initial investment is later added to the future cashflows net present value:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0c144448b26d1bb5e1e573955f886137b35b8bc6" translate="yes" xml:space="preserve">
          <source>It may be the case that while you were working on your edits, new commits have been added to &lt;code&gt;upstream&lt;/code&gt; that affect your work. In this case, follow the &lt;a href=&quot;#rebasing-on-master&quot;&gt;Rebasing on master&lt;/a&gt; section of this document to apply those changes to your branch.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="61a2cf7173d1c99310b82e23b09fc16ccfa711fb" translate="yes" xml:space="preserve">
          <source>It often happens that the memory that you want to view with an array is not of the same byte ordering as the computer on which you are running Python.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eaadd007be7687e8c25f3eb461c4399e71de7888" translate="yes" xml:space="preserve">
          <source>It should be clear that any structured type could be described using this interface.</source>
          <target state="translated">Должно быть понятно,что с помощью этого интерфейса можно описать любой структурированный тип.</target>
        </trans-unit>
        <trans-unit id="40b700e9c3136bc2579dd22e6d2f087fce1952e9" translate="yes" xml:space="preserve">
          <source>It should be emphasized at this point that you may not need the array iterator if your array is already contiguous (using an array iterator will work but will be slower than the fastest code you could write). The major purpose of array iterators is to encapsulate iteration over N-dimensional arrays with arbitrary strides. They are used in many, many places in the NumPy source code itself. If you already know your array is contiguous (Fortran or C), then simply adding the element- size to a running pointer variable will step you through the array very efficiently. In other words, code like this will probably be faster for you in the contiguous case (assuming doubles).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="026d73ab6dffc63b48ab1902fa6d889c8def5bcb" translate="yes" xml:space="preserve">
          <source>It uses a &lt;a href=&quot;#numpy.random.RandomState&quot;&gt;&lt;code&gt;RandomState&lt;/code&gt;&lt;/a&gt; rather than the more modern &lt;a href=&quot;generator#numpy.random.Generator&quot;&gt;&lt;code&gt;Generator&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="18504c66aebcc566a9cf5db146c843b0920c0fed" translate="yes" xml:space="preserve">
          <source>It uses global state, which means results will change as the code changes</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f377563feb8e5b75d15a1cc4f00304a3153cefc3" translate="yes" xml:space="preserve">
          <source>It works in 2-D as well:</source>
          <target state="translated">Он работает и в 2-D:</target>
        </trans-unit>
        <trans-unit id="e168152d8a6d565c340c6f98aabefe43987e5068" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s common to need to transpose your matrices. NumPy arrays have the property &lt;code&gt;T&lt;/code&gt; that allows you to transpose a matrix.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2a604443bcd6724527af1c5d434ed815a21fd057" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s easy to save and load and array with &lt;code&gt;np.save()&lt;/code&gt;. Just make sure to specify the array you want to save and a file name. For example, if you create this array:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bb5dacd50e546c91bb0023917cb217930a8f4581" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s possible to assign to copy-on-write array, but values are only written into the memory copy of the array, and not written to disk:</source>
          <target state="translated">Можно назначить массиву копирования при записи, но значения записываются только в копию массива в памяти, а не на диск:</target>
        </trans-unit>
        <trans-unit id="2a0ce98ff31bde352ed1c0c91f62805b6675f308" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s possible to do a parallel build with &lt;code&gt;numpy.distutils&lt;/code&gt; with the &lt;code&gt;-j&lt;/code&gt; option; see &lt;a href=&quot;../user/building#parallel-builds&quot;&gt;Parallel builds&lt;/a&gt; for more details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4121d3718e690b8fea8d720656c256ae8ee8cf80" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s possible to do a parallel build with:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2a92fc5de8c1d7511c762594edc421f16b236424" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s recommended to specify only those config_fc options in such a way that are compiler independent.</source>
          <target state="translated">Рекомендуется указывать только те параметры config_fc таким образом, чтобы они не зависели от компилятора.</target>
        </trans-unit>
        <trans-unit id="0753c18f0b1243f25af624a4511a2035947276c3" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s simple to read in a CSV that contains existing information. The best and easiest way to do this is to use &lt;a href=&quot;https://pandas.pydata.org/getpandas.html&quot;&gt;Pandas&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="14495a2289a19a1e28ed57bed5a4a3a49edf0b4e" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s simple to use Pandas in order to export your array as well. If you are new to NumPy, you may want to create a Pandas dataframe from the values in your array and then write the data frame to a CSV file with Pandas.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="060cec9479c0c03cb8146120d17fc1e1fd50e074" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s usually a good idea to use the &lt;code&gt;-n&lt;/code&gt; flag to &lt;code&gt;git push&lt;/code&gt; to check first that you&amp;rsquo;re about to push the changes you want to the place you want.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="85be1e8acbcf441a36b9c0c869cff5476c693c32" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s very common to want to aggregate along a row or column. By default, every NumPy aggregation function will return the aggregate of the entire array. To find the sum or the minimum of the elements in your array, run:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c3a9e71b0cabb8c3a03cd16e13045b08078788b6" translate="yes" xml:space="preserve">
          <source>Item selection and manipulation</source>
          <target state="translated">Выбор предметов и манипуляции с ними</target>
        </trans-unit>
        <trans-unit id="867490709f6ff3383fa1fcfac4368fffd68d75ba" translate="yes" xml:space="preserve">
          <source>Items of an array of this data type are wrapped in an &lt;a href=&quot;arrays.scalars#arrays-scalars&quot;&gt;array scalar&lt;/a&gt; type that also has two fields:</source>
          <target state="translated">Элементы массива этого типа данных заключены в &lt;a href=&quot;arrays.scalars#arrays-scalars&quot;&gt;скалярный&lt;/a&gt; тип массива, который также имеет два поля:</target>
        </trans-unit>
        <trans-unit id="7b5cbf04c6d27c2ce2fa2026bd76b8e62a482e6d" translate="yes" xml:space="preserve">
          <source>Iterating Over Arrays</source>
          <target state="translated">чередующиеся массивы</target>
        </trans-unit>
        <trans-unit id="61c7e36ee871033d37342fea4c9a477a22a3ad15" translate="yes" xml:space="preserve">
          <source>Iterating as a Specific Data Type</source>
          <target state="translated">Итерация в качестве специфического типа данных</target>
        </trans-unit>
        <trans-unit id="d0332abd31d07a7d02dd3e33350dc402dcd2926d" translate="yes" xml:space="preserve">
          <source>Iterating over all but one axis</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1844648c4af60a1a170cdaf38688443ce7ba666d" translate="yes" xml:space="preserve">
          <source>Iterating over arrays</source>
          <target state="translated">чередующиеся массивы</target>
        </trans-unit>
        <trans-unit id="b05284699d8fb62b19954c2a16145ceb83ef59a3" translate="yes" xml:space="preserve">
          <source>Iterating over elements in the array</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ab8467929e39862040c3a1bba747525fbb89952c" translate="yes" xml:space="preserve">
          <source>Iterating over multiple arrays</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3c8101d6360b4040707379e2577c7a16fa0bf84e" translate="yes" xml:space="preserve">
          <source>Iteration is done in row-major, C-style order (the last index varying the fastest). The iterator can also be indexed using basic slicing or advanced indexing.</source>
          <target state="translated">Итерация выполняется в последовательности рядов,в стиле С (последний индекс меняется быстрее всего).Итератор также может быть проиндексирован с использованием базовой нарезки или расширенной индексации.</target>
        </trans-unit>
        <trans-unit id="acbcdc45d250ba7dd26edab06186cf3962745972" translate="yes" xml:space="preserve">
          <source>Iterator Data Types</source>
          <target state="translated">Типы данных итератора</target>
        </trans-unit>
        <trans-unit id="21aa412ed70b91ee6a2ff89a4abea36c2af42360" translate="yes" xml:space="preserve">
          <source>Iterator flag &lt;a href=&quot;#c.NPY_ITER_COMMON_DTYPE&quot;&gt;&lt;code&gt;NPY_ITER_COMMON_DTYPE&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">Флаг итератора &lt;a href=&quot;#c.NPY_ITER_COMMON_DTYPE&quot;&gt; &lt;code&gt;NPY_ITER_COMMON_DTYPE&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="a1116d7dda5125208b276ad5471ddd5d08e64ba8" translate="yes" xml:space="preserve">
          <source>Iterator flag &lt;a href=&quot;#c.NPY_ITER_EXTERNAL_LOOP&quot;&gt;&lt;code&gt;NPY_ITER_EXTERNAL_LOOP&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">Флаг итератора &lt;a href=&quot;#c.NPY_ITER_EXTERNAL_LOOP&quot;&gt; &lt;code&gt;NPY_ITER_EXTERNAL_LOOP&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="1b6f69b38ac0228e9245d67b9b1d09ee42bc5dcb" translate="yes" xml:space="preserve">
          <source>Iterator for broadcasting</source>
          <target state="translated">Итератор для вещания</target>
        </trans-unit>
        <trans-unit id="6425854ab104811d699d59fa557478463a96d42e" translate="yes" xml:space="preserve">
          <source>Iterator-Allocated Output Arrays</source>
          <target state="translated">Массивы вывода,распределенные по итераторам</target>
        </trans-unit>
        <trans-unit id="3ea20b9878659e33fbac6ee844497cef84a926f4" translate="yes" xml:space="preserve">
          <source>Iterators are a powerful concept for array processing. Essentially, iterators implement a generalized for-loop. If &lt;em&gt;myiter&lt;/em&gt; is an iterator object, then the Python code:</source>
          <target state="translated">Итераторы - мощная концепция обработки массивов. По сути, итераторы реализуют обобщенный цикл for. Если &lt;em&gt;myiter&lt;/em&gt; является объектом-итератором, тогда код Python:</target>
        </trans-unit>
        <trans-unit id="796f6321f3f35af9085ef4cf35c1d4e6f0e4b4dc" translate="yes" xml:space="preserve">
          <source>Its disadvantages include</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="57d54f82f4390510a92d95c53ba668fb5b8d3f93" translate="yes" xml:space="preserve">
          <source>Its probability density function is</source>
          <target state="translated">Его функция плотности вероятности</target>
        </trans-unit>
        <trans-unit id="58668e7669fd564d99db5d581fcdb6a5618440b5" translate="yes" xml:space="preserve">
          <source>J</source>
          <target state="translated">J</target>
        </trans-unit>
        <trans-unit id="a2cbec366193e4ee99c0016c5fe79f216b41e583" translate="yes" xml:space="preserve">
          <source>J. F. Kaiser, &amp;ldquo;Digital Filters&amp;rdquo; - Ch 7 in &amp;ldquo;Systems analysis by digital computer&amp;rdquo;, Editors: F.F. Kuo and J.F. Kaiser, p 218-285. John Wiley and Sons, New York, (1966).</source>
          <target state="translated">Дж. Ф. Кайзер, &amp;laquo;Цифровые фильтры&amp;raquo; - глава 7 в &amp;laquo;Системный анализ с помощью цифрового компьютера&amp;raquo;, редакторы: Ф. Ф. Куо и Дж. Ф. Кайзер, стр. 218-285. Джон Уайли и сыновья, Нью-Йорк, (1966).</target>
        </trans-unit>
        <trans-unit id="f458212a67f9dc847550889da59b7be8169fde2a" translate="yes" xml:space="preserve">
          <source>Jaime Fern&amp;aacute;ndez del R&amp;iacute;o</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d85b6dd0eee475b31af984e7ef5b76c826173395" translate="yes" xml:space="preserve">
          <source>John K. Salmon, Mark A. Moraes, Ron O. Dror, and David E. Shaw, &amp;ldquo;Parallel Random Numbers: As Easy as 1, 2, 3,&amp;rdquo; Proceedings of the International Conference for High Performance Computing, Networking, Storage and Analysis (SC11), New York, NY: ACM, 2011.</source>
          <target state="translated">Джон К. Сэлмон, Марк А. Мораес, Рон О. Дрор и Дэвид Э. Шоу, &amp;laquo;Параллельные случайные числа: так же просто, как 1, 2, 3&amp;raquo;, Труды Международной конференции по высокопроизводительным вычислениям, сетевым технологиям, системам хранения и Анализ (SC11), Нью-Йорк, Нью-Йорк: ACM, 2011.</target>
        </trans-unit>
        <trans-unit id="5955c7d39672a39a399f419793e9d4b2998a0ae1" translate="yes" xml:space="preserve">
          <source>Join a sequence of arrays along a new axis.</source>
          <target state="translated">Присоедините последовательность массивов вдоль новой оси.</target>
        </trans-unit>
        <trans-unit id="4ea1c9ee9a15b3dcbf6e5bf8c6f47b37d396752b" translate="yes" xml:space="preserve">
          <source>Join a sequence of arrays along an existing axis.</source>
          <target state="translated">Присоедините последовательность массивов вдоль существующей оси.</target>
        </trans-unit>
        <trans-unit id="c169b65bb5e75fcaa26f3cb74e710ac8d05e200a" translate="yes" xml:space="preserve">
          <source>Join a sequence of arrays together.</source>
          <target state="translated">Соедините последовательность массивов вместе.</target>
        </trans-unit>
        <trans-unit id="a0cbf31ae389d3a2da5d14e49f527c1cd6c82518" translate="yes" xml:space="preserve">
          <source>Join arrays &lt;code&gt;r1&lt;/code&gt; and &lt;code&gt;r2&lt;/code&gt; on key &lt;code&gt;key&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="23191121c5e72da7ca4394cebd036d5824a4bf84" translate="yes" xml:space="preserve">
          <source>Join arrays &lt;code&gt;r1&lt;/code&gt; and &lt;code&gt;r2&lt;/code&gt; on keys. Alternative to join_by, that always returns a np.recarray.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ace77e0ad40f2680b6aa7f69f4dfbec0108a72b3" translate="yes" xml:space="preserve">
          <source>Join the sequence of objects in &lt;em&gt;obj&lt;/em&gt; together along &lt;em&gt;axis&lt;/em&gt; into a single array. If the dimensions or types are not compatible an error is raised.</source>
          <target state="translated">Объедините последовательность объектов в &lt;em&gt;obj&lt;/em&gt; вместе вдоль &lt;em&gt;оси&lt;/em&gt; в единый массив. Если размеры или типы несовместимы, возникает ошибка.</target>
        </trans-unit>
        <trans-unit id="0b145a058f4f708ddeea141e56d4c1c7cea2454f" translate="yes" xml:space="preserve">
          <source>Join two or more pathname components + - convert a /-separated pathname to one using the OS&amp;rsquo;s path separator. - resolve  and  from path.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="930021877100c692fce1a3c6407a5fca82ef8115" translate="yes" xml:space="preserve">
          <source>Joining arrays</source>
          <target state="translated">Соединительные массивы</target>
        </trans-unit>
        <trans-unit id="853683e5afe4c33d14d4fe25be2e7a31fcdb24ae" translate="yes" xml:space="preserve">
          <source>Julian Taylor</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1ad4711cdf3c76bf58efbbfffae229363be1de78" translate="yes" xml:space="preserve">
          <source>July 26, 2019</source>
          <target state="translated">26 июля 2019 года</target>
        </trans-unit>
        <trans-unit id="0ea4fce60f72408c555e74c1176fd49b9f6f546a" translate="yes" xml:space="preserve">
          <source>Jump Size</source>
          <target state="translated">Размер прыжка</target>
        </trans-unit>
        <trans-unit id="2f4eece64596ae5728be928b098daa67afdcbd49" translate="yes" xml:space="preserve">
          <source>Jumping the BitGenerator state</source>
          <target state="translated">Прыжок в состояние БитГенератора</target>
        </trans-unit>
        <trans-unit id="edaececa3ce78905da5d0c8d3e5c155d40b3049c" translate="yes" xml:space="preserve">
          <source>Jumping to the next level of complexity, it is possible to only partially index an array with index arrays. It takes a bit of thought to understand what happens in such cases. For example if we just use one index array with y:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d3780087bf4b8552cfaeefd4ae432b76ab3d8ec4" translate="yes" xml:space="preserve">
          <source>Jumps the state as-if jumps * 210306068529402873165736369884012333109 random numbers have been generated.</source>
          <target state="translated">Прыжки состояния as-if прыжки*210306068529402873165736369884012333109 были сгенерированы случайные числа.</target>
        </trans-unit>
        <trans-unit id="e66b5685b9897c71dad3170faecd2518dfadece3" translate="yes" xml:space="preserve">
          <source>June 29, 2020</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f9d305a937478453054f4a6c27158c776273985e" translate="yes" xml:space="preserve">
          <source>Just for your own satisfaction, show yourself that you now have a new &amp;lsquo;remote&amp;rsquo;, with &lt;code&gt;git remote -v show&lt;/code&gt;, giving you something like:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f8882074cfd8e824bd17a6e53a5a926e124e1b9b" translate="yes" xml:space="preserve">
          <source>Just like in other Python container objects, the contents of an array can be accessed and modified by indexing or slicing the array. Unlike the typical container objects, different arrays can share the same data, so changes made on one array might be visible in another.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c5a2ccc2c43427a5df3aae2525cebca91213ce58" translate="yes" xml:space="preserve">
          <source>Just like the case for builtin special methods like &lt;code&gt;__add__&lt;/code&gt;, properly written &lt;code&gt;__array_function__&lt;/code&gt; methods should always return &lt;code&gt;NotImplemented&lt;/code&gt; when an unknown type is encountered. Otherwise, it will be impossible to correctly override NumPy functions from another object if the operation also includes one of your objects.</source>
          <target state="translated">Как и в случае со встроенными специальными методами, такими как &lt;code&gt;__add__&lt;/code&gt; , правильно написанные методы &lt;code&gt;__array_function__&lt;/code&gt; всегда должны возвращать &lt;code&gt;NotImplemented&lt;/code&gt; при обнаружении неизвестного типа. В противном случае будет невозможно правильно переопределить функции NumPy из другого объекта, если операция также включает один из ваших объектов.</target>
        </trans-unit>
        <trans-unit id="a7ee38bb7be4fc44198cb2685d9601dcf2b9f569" translate="yes" xml:space="preserve">
          <source>K</source>
          <target state="translated">K</target>
        </trans-unit>
        <trans-unit id="fea9c97b23d277bbc25a4ecec464e976ad73c9d8" translate="yes" xml:space="preserve">
          <source>Key to use in the Philox state. Unlike &lt;code&gt;seed&lt;/code&gt;, the value in key is directly set. Can be either a Python int in [0, 2**128) or a 2-element uint64 array. &lt;code&gt;key&lt;/code&gt; and &lt;code&gt;seed&lt;/code&gt; cannot both be used.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="04e171a322d7a93c71ab2aebd91bfaf316577346" translate="yes" xml:space="preserve">
          <source>Key to use in the Philox state. Unlike seed, the value in key is directly set. Can be either a Python int in [0, 2**128) or a 2-element uint64 array. &lt;code&gt;key&lt;/code&gt; and &lt;code&gt;seed&lt;/code&gt; cannot both be used.</source>
          <target state="translated">Ключ для использования в состоянии Philox. В отличие от seed, значение ключа устанавливается напрямую. Может быть либо Python int в [0, 2 ** 128), либо двухэлементным массивом uint64. &lt;code&gt;key&lt;/code&gt; и &lt;code&gt;seed&lt;/code&gt; не могут использоваться одновременно.</target>
        </trans-unit>
        <trans-unit id="a4f25f4e01bab825ac7968a35cf2573aecf46441" translate="yes" xml:space="preserve">
          <source>Keyword arguments passed to &lt;code&gt;func&lt;/code&gt;.</source>
          <target state="translated">Аргументы &lt;code&gt;func&lt;/code&gt; слова, переданные в func .</target>
        </trans-unit>
        <trans-unit id="936d17141932bddd8cdbe3cf3d8e6417d18816b5" translate="yes" xml:space="preserve">
          <source>Keyword arguments used in calling &lt;a href=&quot;#numpy.piecewise&quot;&gt;&lt;code&gt;piecewise&lt;/code&gt;&lt;/a&gt; are passed to the functions upon execution, i.e., if called &lt;code&gt;piecewise(..., ..., alpha=1)&lt;/code&gt;, then each function is called as &lt;code&gt;f(x, alpha=1)&lt;/code&gt;.</source>
          <target state="translated">Аргументы ключевого слова, используемые при &lt;a href=&quot;#numpy.piecewise&quot;&gt; &lt;code&gt;piecewise&lt;/code&gt; &lt;/a&gt; вызове , передаются функциям при выполнении, т.е. если вызывается кусочно &lt;code&gt;piecewise(..., ..., alpha=1)&lt;/code&gt; , то каждая функция вызывается как &lt;code&gt;f(x, alpha=1)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="94796302f2d6010802da8fc83c102abd3d91e59b" translate="yes" xml:space="preserve">
          <source>Keyword arguments with the value &lt;code&gt;None&lt;/code&gt; are not checked. Specifying a keyword enforces checking of that aspect of the ndarray on conversion to a ctypes-compatible object. The dtype keyword can be any object understood as a data-type object. The ndim keyword should be an integer, and the shape keyword should be an integer or a sequence of integers. The flags keyword specifies the minimal flags that are required on any array passed in. This can be specified as a string of comma separated requirements, an integer indicating the requirement bits OR&amp;rsquo;d together, or a flags object returned from the flags attribute of an array with the necessary requirements.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7b38351b3da46b01757fe5df0b763a6ba88d3175" translate="yes" xml:space="preserve">
          <source>Keyword arguments. The valid keywords are the possible floating-point exceptions. Each keyword should have a string value that defines the treatment for the particular error. Possible values are {&amp;lsquo;ignore&amp;rsquo;, &amp;lsquo;warn&amp;rsquo;, &amp;lsquo;raise&amp;rsquo;, &amp;lsquo;call&amp;rsquo;, &amp;lsquo;print&amp;rsquo;, &amp;lsquo;log&amp;rsquo;}.</source>
          <target state="translated">Аргументы ключевого слова. Допустимые ключевые слова - это возможные исключения для чисел с плавающей запятой. Каждое ключевое слово должно иметь строковое значение, которое определяет лечение конкретной ошибки. Возможные значения: {'ignore', 'warn', 'raise', 'call', 'print', 'log'}.</target>
        </trans-unit>
        <trans-unit id="cca3dd937ca64fcc731c3b76e10a3a59e197b380" translate="yes" xml:space="preserve">
          <source>Keywords other than &lt;a href=&quot;numpy.dtype#numpy.dtype&quot;&gt;&lt;code&gt;dtype&lt;/code&gt;&lt;/a&gt; are passed to &lt;code&gt;function&lt;/code&gt;.</source>
          <target state="translated">Ключевые слова, кроме &lt;a href=&quot;numpy.dtype#numpy.dtype&quot;&gt; &lt;code&gt;dtype&lt;/code&gt; &lt;/a&gt; передаются &lt;code&gt;function&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="bd51c0cf5320b73d3ff55b2176ad245d2d7397b1" translate="yes" xml:space="preserve">
          <source>Keywords other than &lt;code&gt;dtype&lt;/code&gt; are passed to &lt;code&gt;function&lt;/code&gt;.</source>
          <target state="translated">Ключевые слова, кроме &lt;code&gt;dtype&lt;/code&gt; передаются &lt;code&gt;function&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5c23ce94abbcda9863c972bac23c6a2a76bdd7d1" translate="yes" xml:space="preserve">
          <source>Kind of floating point data-type about which to get information.</source>
          <target state="translated">Вид данных с плавающей точкой,о которых можно получить информацию.</target>
        </trans-unit>
        <trans-unit id="31be8fd23c00b4b851fa5f224f6fd4dac29e08c9" translate="yes" xml:space="preserve">
          <source>Known bugs:</source>
          <target state="translated">Известные жуки:</target>
        </trans-unit>
        <trans-unit id="26db35f7eb95d8b793f4df612e64a0ce6b5afd47" translate="yes" xml:space="preserve">
          <source>Known failures &amp;amp; skipping tests</source>
          <target state="translated">Известные сбои и пропуск тестов</target>
        </trans-unit>
        <trans-unit id="d54ed0ae4c90f25216ec62895c50ba0c59603696" translate="yes" xml:space="preserve">
          <source>Kotz, Samuel, et. al. &amp;ldquo;The Laplace Distribution and Generalizations, &amp;rdquo; Birkhauser, 2001.</source>
          <target state="translated">Коц, Самуэль и др. al. &amp;laquo;Распределение Лапласа и обобщения&amp;raquo;, Бирхаузер, 2001.</target>
        </trans-unit>
        <trans-unit id="9b54aa8ed101113f4ff654653787cb490d5956f9" translate="yes" xml:space="preserve">
          <source>Kronecker product of two arrays.</source>
          <target state="translated">Кронекер продукт из двух массивов.</target>
        </trans-unit>
        <trans-unit id="d160e0986aca4714714a16f29ec605af90be704d" translate="yes" xml:space="preserve">
          <source>L</source>
          <target state="translated">L</target>
        </trans-unit>
        <trans-unit id="0c5ca7c9489e795d6e344494ca6012e6c5e6c94a" translate="yes" xml:space="preserve">
          <source>L. J. Gitman, &amp;ldquo;Principles of Managerial Finance, Brief,&amp;rdquo; 3rd ed., Addison-Wesley, 2003, pg. 346.</source>
          <target state="translated">LJ Gitman, &amp;laquo;Принципы управленческих финансов, краткое изложение&amp;raquo;, 3-е изд., Addison-Wesley, 2003, pg. 346.</target>
        </trans-unit>
        <trans-unit id="dad744be14f4bac6567fee2e00e8179f1cafc777" translate="yes" xml:space="preserve">
          <source>L. J. Gitman, &amp;ldquo;Principles of Managerial Finance, Brief,&amp;rdquo; 3rd ed., Addison-Wesley, 2003, pg. 348.</source>
          <target state="translated">LJ Gitman, &amp;laquo;Принципы управленческих финансов, краткое изложение&amp;raquo;, 3-е изд., Addison-Wesley, 2003, pg. 348.</target>
        </trans-unit>
        <trans-unit id="c9abe91342431b93d138f7615d16985673f94ddb" translate="yes" xml:space="preserve">
          <source>L2 norm of vector &lt;code&gt;v&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cf9e7dcbce935737e3132c8567095e62b32e357d" translate="yes" xml:space="preserve">
          <source>LAPACK</source>
          <target state="translated">LAPACK</target>
        </trans-unit>
        <trans-unit id="a3fb459b8d25a6646ccd3006470636c4394d2fa7" translate="yes" xml:space="preserve">
          <source>LAPACK (NetLIB)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="21d5b247623a47d3ffff1da535ef4461b811d560" translate="yes" xml:space="preserve">
          <source>LSB integer 1</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="17bcd0c5595da0e7eb910f67673f577b1f83f0f7" translate="yes" xml:space="preserve">
          <source>LSB integer 2</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eec57c77bc60eb78065b6605060bb41430b8e7ce" translate="yes" xml:space="preserve">
          <source>LU decomposition (note: P(Matlab) == transpose(P(numpy)) )</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f50beb264ce7d144bf1ce0f2f4d3f272a300b7de" translate="yes" xml:space="preserve">
          <source>Label a test as &amp;lsquo;slow&amp;rsquo;.</source>
          <target state="translated">Обозначьте тест как &amp;laquo;медленный&amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="369c34c1729b62dec5c01c92266ffbd20a59873d" translate="yes" xml:space="preserve">
          <source>Labeling tests</source>
          <target state="translated">Маркировочные испытания</target>
        </trans-unit>
        <trans-unit id="4bebfc5e6e36da81205979cf627ca2083b60eab7" translate="yes" xml:space="preserve">
          <source>Laguerre</source>
          <target state="translated">Laguerre</target>
        </trans-unit>
        <trans-unit id="e97fc7286288e61e2979e3135f28bb8c533a9b55" translate="yes" xml:space="preserve">
          <source>Laguerre (class in numpy.polynomial.laguerre)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5e57606aead53cf91effb25cd081645a48be4c71" translate="yes" xml:space="preserve">
          <source>Laguerre Class</source>
          <target state="translated">класс Лагерра</target>
        </trans-unit>
        <trans-unit id="ba379f482d893a166d54a2acffc47cc917ce664e" translate="yes" xml:space="preserve">
          <source>Laguerre Module (&lt;code&gt;numpy.polynomial.laguerre&lt;/code&gt;)</source>
          <target state="translated">Модуль Лагерра ( &lt;code&gt;numpy.polynomial.laguerre&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="1fa1d2e4107d4f18290f33c4164e9ffd20858112" translate="yes" xml:space="preserve">
          <source>Laguerre Module (numpy.polynomial.laguerre)</source>
          <target state="translated">Модуль Лагуэра (нумизматический.полиномиальный.лагуэр)</target>
        </trans-unit>
        <trans-unit id="2a936707907aefc2336791e67e0a362c7a6f2893" translate="yes" xml:space="preserve">
          <source>Laguerre Series (&lt;code&gt;numpy.polynomial.laguerre&lt;/code&gt;)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="df257db6a3d424bc3a9e921bbaaa3ba0ba50dac3" translate="yes" xml:space="preserve">
          <source>Laguerre Series (numpy.polynomial.laguerre)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="99466c13dff878e880a6ce449247757d575c46d1" translate="yes" xml:space="preserve">
          <source>Laguerre coefficients in order of increasing degree, i.e, &lt;code&gt;(1, 2, 3)&lt;/code&gt; gives &lt;code&gt;1*L_0(x) + 2*L_1(X) + 3*L_2(x)&lt;/code&gt;.</source>
          <target state="translated">Коэффициенты Лагерра в порядке возрастания степени, то есть &lt;code&gt;(1, 2, 3)&lt;/code&gt; дает &lt;code&gt;1*L_0(x) + 2*L_1(X) + 3*L_2(x)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="96781eb22440929e4bf56e8413b2c4b2ee004cfa" translate="yes" xml:space="preserve">
          <source>Laguerre coefficients ordered from low to high. If &lt;code&gt;y&lt;/code&gt; was 2-D, the coefficients for the data in column k of &lt;code&gt;y&lt;/code&gt; are in column &lt;code&gt;k&lt;/code&gt;.</source>
          <target state="translated">Коэффициенты Лагерра упорядочены по возрастанию. Если &lt;code&gt;y&lt;/code&gt; было 2-D, коэффициенты для данных в столбце k &lt;code&gt;y&lt;/code&gt; находятся в столбце &lt;code&gt;k&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="203d5e91f105ffb95930f626e1d302a193aeaa68" translate="yes" xml:space="preserve">
          <source>Laguerre series</source>
          <target state="translated">серия Лагерр</target>
        </trans-unit>
        <trans-unit id="a347ea54d317cc577991ec7bf8e660f33b29ea5f" translate="yes" xml:space="preserve">
          <source>Laguerre series coefficients of the integral.</source>
          <target state="translated">Коэффициенты ряда Лагерра интеграла.</target>
        </trans-unit>
        <trans-unit id="d470a6ac507868056b6fb97be3c38f8e66fd3f73" translate="yes" xml:space="preserve">
          <source>Laguerre series of power.</source>
          <target state="translated">Серия Лагерр.</target>
        </trans-unit>
        <trans-unit id="077697f66c66782d4ef98066ee75e7065a9fd35e" translate="yes" xml:space="preserve">
          <source>Laguerre series of the derivative.</source>
          <target state="translated">Серия Лагерр производной.</target>
        </trans-unit>
        <trans-unit id="9a5deb2e7228ec3244f92981a2f639bd0074c61e" translate="yes" xml:space="preserve">
          <source>Laguerre series whose graph is a straight line.</source>
          <target state="translated">Серия Лагерр,график которой представляет собой прямую линию.</target>
        </trans-unit>
        <trans-unit id="40be499dbcfef954b53f79728a280796ea6c4f1b" translate="yes" xml:space="preserve">
          <source>Laguerre weight function.</source>
          <target state="translated">Функция веса Лагерра.</target>
        </trans-unit>
        <trans-unit id="19b66881a109c4450aeadcaedc080b0375d2ecf9" translate="yes" xml:space="preserve">
          <source>Laguerre.__call__()</source>
          <target state="translated">Laguerre.__call__()</target>
        </trans-unit>
        <trans-unit id="b79eed7b566471b5b98d5403131d5fcccb9ccdd6" translate="yes" xml:space="preserve">
          <source>Laguerre.basis()</source>
          <target state="translated">Laguerre.basis()</target>
        </trans-unit>
        <trans-unit id="8450b9cd56cfc84841f9b6a7b3ce8b6553391224" translate="yes" xml:space="preserve">
          <source>Laguerre.cast()</source>
          <target state="translated">Laguerre.cast()</target>
        </trans-unit>
        <trans-unit id="27a50de57a0c19215d0a40ab26d7fc3244818104" translate="yes" xml:space="preserve">
          <source>Laguerre.convert()</source>
          <target state="translated">Laguerre.convert()</target>
        </trans-unit>
        <trans-unit id="ba2566270efed850de8b718e7293f07a260b676d" translate="yes" xml:space="preserve">
          <source>Laguerre.copy()</source>
          <target state="translated">Laguerre.copy()</target>
        </trans-unit>
        <trans-unit id="3b52ca7dceafcdacc78576d128623ad1866249fc" translate="yes" xml:space="preserve">
          <source>Laguerre.cutdeg()</source>
          <target state="translated">Laguerre.cutdeg()</target>
        </trans-unit>
        <trans-unit id="d2b6b76b4b9ee361106b2c94187d00faaf8bec52" translate="yes" xml:space="preserve">
          <source>Laguerre.degree()</source>
          <target state="translated">Laguerre.degree()</target>
        </trans-unit>
        <trans-unit id="00ba5991cdfe21416f272ddb4e2fd2ee48ba1e73" translate="yes" xml:space="preserve">
          <source>Laguerre.deriv()</source>
          <target state="translated">Laguerre.deriv()</target>
        </trans-unit>
        <trans-unit id="3774c67b9a36d28184dc80e1b4d2486ea1e1f36a" translate="yes" xml:space="preserve">
          <source>Laguerre.domain</source>
          <target state="translated">Laguerre.domain</target>
        </trans-unit>
        <trans-unit id="b85b503244ce55e050a887342980da72b2e9ad78" translate="yes" xml:space="preserve">
          <source>Laguerre.fit()</source>
          <target state="translated">Laguerre.fit()</target>
        </trans-unit>
        <trans-unit id="23af0332e2c429442e5afb68340fa4aeef4545dc" translate="yes" xml:space="preserve">
          <source>Laguerre.fromroots()</source>
          <target state="translated">Laguerre.fromroots()</target>
        </trans-unit>
        <trans-unit id="a2a6581abb5a91aaeac7e93a2a256734282432d3" translate="yes" xml:space="preserve">
          <source>Laguerre.has_samecoef()</source>
          <target state="translated">Laguerre.has_samecoef()</target>
        </trans-unit>
        <trans-unit id="7dd4d8134966100274e963f0060bfab576b5fddf" translate="yes" xml:space="preserve">
          <source>Laguerre.has_samedomain()</source>
          <target state="translated">Laguerre.has_samedomain()</target>
        </trans-unit>
        <trans-unit id="e5e59e81443c19ac8f19e8c2fdccb120a1c9224f" translate="yes" xml:space="preserve">
          <source>Laguerre.has_sametype()</source>
          <target state="translated">Laguerre.has_sametype()</target>
        </trans-unit>
        <trans-unit id="3d138070a5021011806b89098bbe766378b10e7e" translate="yes" xml:space="preserve">
          <source>Laguerre.has_samewindow()</source>
          <target state="translated">Laguerre.has_samewindow()</target>
        </trans-unit>
        <trans-unit id="6f69d4698823efec4ccf07af22829cc894b0b98c" translate="yes" xml:space="preserve">
          <source>Laguerre.identity()</source>
          <target state="translated">Laguerre.identity()</target>
        </trans-unit>
        <trans-unit id="f1f6d872a178e7692b45f4ccbfd34fbbf6ed5f91" translate="yes" xml:space="preserve">
          <source>Laguerre.integ()</source>
          <target state="translated">Laguerre.integ()</target>
        </trans-unit>
        <trans-unit id="068cb46402017cfb3dd18164c9b41f89c700f799" translate="yes" xml:space="preserve">
          <source>Laguerre.linspace()</source>
          <target state="translated">Laguerre.linspace()</target>
        </trans-unit>
        <trans-unit id="100d51943018ffa8eadce404d26cfaa31b915872" translate="yes" xml:space="preserve">
          <source>Laguerre.mapparms()</source>
          <target state="translated">Laguerre.mapparms()</target>
        </trans-unit>
        <trans-unit id="de9dd46ebdab9f670b65d8cedb81c132ac30c276" translate="yes" xml:space="preserve">
          <source>Laguerre.roots()</source>
          <target state="translated">Laguerre.roots()</target>
        </trans-unit>
        <trans-unit id="9779fb4f29c73da5d6cee5ec234239b97271c1ae" translate="yes" xml:space="preserve">
          <source>Laguerre.trim()</source>
          <target state="translated">Laguerre.trim()</target>
        </trans-unit>
        <trans-unit id="76a59bb3d54a6db3b464f00c41f8b5a8b4767c11" translate="yes" xml:space="preserve">
          <source>Laguerre.truncate()</source>
          <target state="translated">Laguerre.truncate()</target>
        </trans-unit>
        <trans-unit id="36198a8897031e87556aee045b29805731052142" translate="yes" xml:space="preserve">
          <source>Laplaces</source>
          <target state="translated">Laplaces</target>
        </trans-unit>
        <trans-unit id="82f5e1511892c7fb01c75144ac000d62f83d5a77" translate="yes" xml:space="preserve">
          <source>Large allocations marked as suitable for transparent hugepages</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="da46491a1118285dbcf5975a2a3f36f864e4e6eb" translate="yes" xml:space="preserve">
          <source>Large parts of this manual originate from Travis E. Oliphant&amp;rsquo;s book &lt;a href=&quot;https://archive.org/details/NumPyBook&quot;&gt;Guide to NumPy&lt;/a&gt; (which generously entered Public Domain in August 2008). The reference documentation for many of the functions are written by numerous contributors and developers of NumPy.</source>
          <target state="translated">Большая часть этого руководства взята из книги Трэвиса Э. Олифанта &amp;laquo; &lt;a href=&quot;https://archive.org/details/NumPyBook&quot;&gt;Руководство по NumPy&amp;raquo;&lt;/a&gt; (которая в августе 2008 года вошла в общественное достояние). Справочная документация для многих функций написана многочисленными участниками и разработчиками NumPy.</target>
        </trans-unit>
        <trans-unit id="eab5c44c0f0e22a5c5510649d34e17cb192d1603" translate="yes" xml:space="preserve">
          <source>Large parts of this manual originate from Travis E. Oliphant's book &lt;a href=&quot;https://archive.org/details/NumPyBook&quot;&gt;&quot;Guide to NumPy&quot;&lt;/a&gt; (which generously entered Public Domain in August 2008). The reference documentation for many of the functions are written by numerous contributors and developers of NumPy.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2fdae5c61df170eabed81dff27bfb3678199f99b" translate="yes" xml:space="preserve">
          <source>Largest size allowed for the user-settable buffers.</source>
          <target state="translated">Наибольший допустимый размер для устанавливаемых пользователем буферов.</target>
        </trans-unit>
        <trans-unit id="8da87d373f111f7e103693ae24e8a07ffa7a91e2" translate="yes" xml:space="preserve">
          <source>Last processed field name (used internally during recursion).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="688c183c0553e7f8897c3da631ac608e3281e20b" translate="yes" xml:space="preserve">
          <source>Learn about concepts and submodules</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7e1c2c8a281b93c2a756aa5c5b0dde7c93d58559" translate="yes" xml:space="preserve">
          <source>Learn about what NumPy is and how to install it</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1893b40e2e74ded8d87e7668bb8ea0e85b265882" translate="yes" xml:space="preserve">
          <source>Learn more about &lt;a href=&quot;../reference/routines.io#routines-io&quot;&gt;input and output routines here&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="42d6db2ec75c1bd30bb52b2e73819209cb308cc1" translate="yes" xml:space="preserve">
          <source>Learn more about &lt;a href=&quot;quickstart#quickstart-indexing-slicing-and-iterating&quot;&gt;indexing and slicing here&lt;/a&gt; and &lt;a href=&quot;basics.indexing#basics-indexing&quot;&gt;here&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2a595050bddab4e4c46cb1e0dc7dff5874ac8e5f" translate="yes" xml:space="preserve">
          <source>Learn more about &lt;a href=&quot;whatisnumpy#whatisnumpy&quot;&gt;NumPy here&lt;/a&gt;!</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eccf892e3b309e4f27b805fda73ba6310c691f1f" translate="yes" xml:space="preserve">
          <source>Learn more about creating arrays here</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e9f285095a214517cc70148a152aa9ce3bfb1555" translate="yes" xml:space="preserve">
          <source>Least squares fit of Chebyshev series to data.</source>
          <target state="translated">Наименьшее соответствие квадратов чебышевского ряда данным.</target>
        </trans-unit>
        <trans-unit id="5eede6c92597c6ad1ec14f2a50e868bfa8dbcef5" translate="yes" xml:space="preserve">
          <source>Least squares fit of Hermite series to data.</source>
          <target state="translated">Наименьшее соответствие квадратов серии &quot;Эрмита&quot; данным.</target>
        </trans-unit>
        <trans-unit id="f9834397596bb1c91a60ebd7bed6c56b93f210b5" translate="yes" xml:space="preserve">
          <source>Least squares fit of Laguerre series to data.</source>
          <target state="translated">Наименьшее соответствие квадратов серии Laguerre данным.</target>
        </trans-unit>
        <trans-unit id="60abe6780ea6293285c10210c3c968485e58937b" translate="yes" xml:space="preserve">
          <source>Least squares fit of Legendre series to data.</source>
          <target state="translated">Наименьшее соответствие квадратов серии Legendre данным.</target>
        </trans-unit>
        <trans-unit id="f70b890f268681837dd642a40e85f47d99c8ef5c" translate="yes" xml:space="preserve">
          <source>Least squares fit to data.</source>
          <target state="translated">Наименьшие квадраты подходят для данных.</target>
        </trans-unit>
        <trans-unit id="82d4ad107d684ab9ad44770f05b7a2542d27bae6" translate="yes" xml:space="preserve">
          <source>Least squares polynomial fit.</source>
          <target state="translated">Наименее квадраты полиномиальные.</target>
        </trans-unit>
        <trans-unit id="66b99a01120f0770d01e2e70f30aa7b3e6d8760b" translate="yes" xml:space="preserve">
          <source>Least-squares fit of a polynomial to data.</source>
          <target state="translated">Наименьший квадратный подгон полинома к данным.</target>
        </trans-unit>
        <trans-unit id="004f7153cd5215d911c25b804b9cb64fc053135e" translate="yes" xml:space="preserve">
          <source>Least-squares solution. If &lt;code&gt;b&lt;/code&gt; is two-dimensional, the solutions are in the &lt;code&gt;K&lt;/code&gt; columns of &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="translated">Решение методом наименьших квадратов. Если &lt;code&gt;b&lt;/code&gt; двумерно, решения находятся в &lt;code&gt;K&lt;/code&gt; столбцах &lt;code&gt;x&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8e3bf79d3ac96cdf89ed0ca352f8850960c3aecf" translate="yes" xml:space="preserve">
          <source>Leg of the triangle(s). If &lt;code&gt;x1.shape != x2.shape&lt;/code&gt;, they must be broadcastable to a common shape (which becomes the shape of the output).</source>
          <target state="translated">Ножка треугольника (ов). Если &lt;code&gt;x1.shape != x2.shape&lt;/code&gt; , они должны транслироваться в общую форму (которая становится формой вывода).</target>
        </trans-unit>
        <trans-unit id="a3da3f26242bb8617087ec4d4fb9fafcb77635dc" translate="yes" xml:space="preserve">
          <source>Legacy Generator (RandomState)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7a03f0fe89c9579b9b2b236650c98185edc2fe62" translate="yes" xml:space="preserve">
          <source>Legacy Random Generation</source>
          <target state="translated">Поколение наследственных случайностей</target>
        </trans-unit>
        <trans-unit id="47a5d89b5a8a2f363ca5b4a1476eb173fc07ab11" translate="yes" xml:space="preserve">
          <source>Legendre</source>
          <target state="translated">Legendre</target>
        </trans-unit>
        <trans-unit id="358ed7a487a2a55bfa9556bbf8f4fe1f6f4c1094" translate="yes" xml:space="preserve">
          <source>Legendre (class in numpy.polynomial.legendre)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4120cea9b471c879abda7b1336aba3d61c52e3bc" translate="yes" xml:space="preserve">
          <source>Legendre Class</source>
          <target state="translated">Класс Легенды</target>
        </trans-unit>
        <trans-unit id="b4a47072941f51eec5be92fa7536302b1cd27189" translate="yes" xml:space="preserve">
          <source>Legendre Module (&lt;code&gt;numpy.polynomial.legendre&lt;/code&gt;)</source>
          <target state="translated">Модуль Лежандра ( &lt;code&gt;numpy.polynomial.legendre&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="a6b7c39b7f03fb5bf1916b89cb05334bb7660fc8" translate="yes" xml:space="preserve">
          <source>Legendre Module (numpy.polynomial.legendre)</source>
          <target state="translated">Модуль Легенда (нумизматическая полиномиальная легенда)</target>
        </trans-unit>
        <trans-unit id="5cf0b728017026cd3633f8023ba22356ac49e8e9" translate="yes" xml:space="preserve">
          <source>Legendre Series (&lt;code&gt;numpy.polynomial.legendre&lt;/code&gt;)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3fc1f7294028d411cdbd64652dfec514ea719176" translate="yes" xml:space="preserve">
          <source>Legendre Series (numpy.polynomial.legendre)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="72a4b81826e99e6fe744c1d98416a1d24f591803" translate="yes" xml:space="preserve">
          <source>Legendre coefficients in order of increasing degree, i.e., &lt;code&gt;(1, 2, 3)&lt;/code&gt; gives &lt;code&gt;1*P_0(x) + 2*P_1(x) + 3*P_2(x)&lt;/code&gt;.</source>
          <target state="translated">Коэффициенты Лежандра в порядке возрастания степени, то есть &lt;code&gt;(1, 2, 3)&lt;/code&gt; дает &lt;code&gt;1*P_0(x) + 2*P_1(x) + 3*P_2(x)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="dd1aecb7d54479faf64417ed750dd54dbc48134e" translate="yes" xml:space="preserve">
          <source>Legendre coefficients ordered from low to high. If &lt;code&gt;y&lt;/code&gt; was 2-D, the coefficients for the data in column k of &lt;code&gt;y&lt;/code&gt; are in column &lt;code&gt;k&lt;/code&gt;. If &lt;code&gt;deg&lt;/code&gt; is specified as a list, coefficients for terms not included in the fit are set equal to zero in the returned &lt;code&gt;coef&lt;/code&gt;.</source>
          <target state="translated">Коэффициенты Лежандра упорядочены по возрастанию. Если &lt;code&gt;y&lt;/code&gt; было 2-D, коэффициенты для данных в столбце k of &lt;code&gt;y&lt;/code&gt; находятся в столбце &lt;code&gt;k&lt;/code&gt; . Если &lt;code&gt;deg&lt;/code&gt; задается в виде списка, коэффициенты для членов , не входящих в приступе устанавливаются равными нулю в возвращенном &lt;code&gt;coef&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="36661c8b6df50f0810e8abcd38c911e37700210a" translate="yes" xml:space="preserve">
          <source>Legendre series</source>
          <target state="translated">серия Легенд</target>
        </trans-unit>
        <trans-unit id="cff0f8c14f012c4d84feceb1b721e76e38f2b7e7" translate="yes" xml:space="preserve">
          <source>Legendre series coefficient array of the integral.</source>
          <target state="translated">Массив коэффициентов серии Легенды интеграла.</target>
        </trans-unit>
        <trans-unit id="e423b1233d9fcd2c8894e66b68b4670d1797fcf6" translate="yes" xml:space="preserve">
          <source>Legendre series of power.</source>
          <target state="translated">Легендарная серия власти.</target>
        </trans-unit>
        <trans-unit id="cbfaa0f2130ef078276a68c292602bd146355698" translate="yes" xml:space="preserve">
          <source>Legendre series of the derivative.</source>
          <target state="translated">Легендарная серия производной.</target>
        </trans-unit>
        <trans-unit id="0c94fd4bbecdfa33cfa2085e96aaf27eb258cb91" translate="yes" xml:space="preserve">
          <source>Legendre series whose graph is a straight line.</source>
          <target state="translated">Легендарный ряд,график которого представляет собой прямую линию.</target>
        </trans-unit>
        <trans-unit id="9c6dd8780cca130b14ebf98dc6a58e0b8fde7f4f" translate="yes" xml:space="preserve">
          <source>Legendre weight function (= 1).</source>
          <target state="translated">Легендарная весовая функция (=1).</target>
        </trans-unit>
        <trans-unit id="11838d713a7ca74c36db28fb9741ab01b38fc2f4" translate="yes" xml:space="preserve">
          <source>Legendre, Laguerre, Hermite, HermiteE polynomials in &lt;code&gt;numpy.polynomial&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4086e8682b0af8e09d2dfa82cd2fdc76b5bc8f8d" translate="yes" xml:space="preserve">
          <source>Legendre.__call__()</source>
          <target state="translated">Legendre.__call__()</target>
        </trans-unit>
        <trans-unit id="38dffd4eba846de64c001288fae359b48ca7be06" translate="yes" xml:space="preserve">
          <source>Legendre.basis()</source>
          <target state="translated">Legendre.basis()</target>
        </trans-unit>
        <trans-unit id="03d79bdd0c244e4a8685e0cc2ed8f9bba14f2e75" translate="yes" xml:space="preserve">
          <source>Legendre.cast()</source>
          <target state="translated">Legendre.cast()</target>
        </trans-unit>
        <trans-unit id="c3757be303c19145dd4cdc1f1fdbe7778af7a9b8" translate="yes" xml:space="preserve">
          <source>Legendre.convert()</source>
          <target state="translated">Legendre.convert()</target>
        </trans-unit>
        <trans-unit id="30694a9a60e1750eef89dd48cd213d03dc835778" translate="yes" xml:space="preserve">
          <source>Legendre.copy()</source>
          <target state="translated">Legendre.copy()</target>
        </trans-unit>
        <trans-unit id="67fd9bca2a23484298ecfc5a44e6dbe767f8deee" translate="yes" xml:space="preserve">
          <source>Legendre.cutdeg()</source>
          <target state="translated">Legendre.cutdeg()</target>
        </trans-unit>
        <trans-unit id="de6280bafa05de1ba0dc2f4ee315b2f1c3f376c2" translate="yes" xml:space="preserve">
          <source>Legendre.degree()</source>
          <target state="translated">Legendre.degree()</target>
        </trans-unit>
        <trans-unit id="065d87c76a899767772e29e52989a91f8e7a3c94" translate="yes" xml:space="preserve">
          <source>Legendre.deriv()</source>
          <target state="translated">Legendre.deriv()</target>
        </trans-unit>
        <trans-unit id="dc4f96a4666e84f37c719b2fad25d196a612cc45" translate="yes" xml:space="preserve">
          <source>Legendre.domain</source>
          <target state="translated">Legendre.domain</target>
        </trans-unit>
        <trans-unit id="11c2423446ff507ce6eb98675dde94c735489c69" translate="yes" xml:space="preserve">
          <source>Legendre.fit()</source>
          <target state="translated">Legendre.fit()</target>
        </trans-unit>
        <trans-unit id="e21bd7963e9b515a9f4b47a6bcd09e263e8089ee" translate="yes" xml:space="preserve">
          <source>Legendre.fromroots()</source>
          <target state="translated">Legendre.fromroots()</target>
        </trans-unit>
        <trans-unit id="d5d912a486cc7b8f50ccecabe4f025c8e6390336" translate="yes" xml:space="preserve">
          <source>Legendre.has_samecoef()</source>
          <target state="translated">Legendre.has_samecoef()</target>
        </trans-unit>
        <trans-unit id="6666d87ba29b4b8ae40e97a1bf2868d699324607" translate="yes" xml:space="preserve">
          <source>Legendre.has_samedomain()</source>
          <target state="translated">Legendre.has_samedomain()</target>
        </trans-unit>
        <trans-unit id="3760f41cb73e83c63c3b041fb1850faaf75fa051" translate="yes" xml:space="preserve">
          <source>Legendre.has_sametype()</source>
          <target state="translated">Legendre.has_sametype()</target>
        </trans-unit>
        <trans-unit id="776a3387bba3bfaabfedc34f80f56441350be257" translate="yes" xml:space="preserve">
          <source>Legendre.has_samewindow()</source>
          <target state="translated">Legendre.has_samewindow()</target>
        </trans-unit>
        <trans-unit id="d270c39a15f9cf84d450407eca8d04e34120a21a" translate="yes" xml:space="preserve">
          <source>Legendre.identity()</source>
          <target state="translated">Legendre.identity()</target>
        </trans-unit>
        <trans-unit id="a025b9af1289248a2a7d813cd3249b6c59a1b90e" translate="yes" xml:space="preserve">
          <source>Legendre.integ()</source>
          <target state="translated">Legendre.integ()</target>
        </trans-unit>
        <trans-unit id="b1309f9dd6fba8397cba7645c87fd874d753067f" translate="yes" xml:space="preserve">
          <source>Legendre.linspace()</source>
          <target state="translated">Legendre.linspace()</target>
        </trans-unit>
        <trans-unit id="3b41ed00816bbf0ea94cb8ce7b846f9374dce867" translate="yes" xml:space="preserve">
          <source>Legendre.mapparms()</source>
          <target state="translated">Legendre.mapparms()</target>
        </trans-unit>
        <trans-unit id="498206cc30a61e0936daddec7420065e1fb22906" translate="yes" xml:space="preserve">
          <source>Legendre.roots()</source>
          <target state="translated">Legendre.roots()</target>
        </trans-unit>
        <trans-unit id="c917ded9bfb105e1d1214678489c4d2d643e0789" translate="yes" xml:space="preserve">
          <source>Legendre.trim()</source>
          <target state="translated">Legendre.trim()</target>
        </trans-unit>
        <trans-unit id="4b818047b63ac1fb3abbf9ee09b84ccf39af0370" translate="yes" xml:space="preserve">
          <source>Legendre.truncate()</source>
          <target state="translated">Legendre.truncate()</target>
        </trans-unit>
        <trans-unit id="d96ebfedf4c36cbda183cd7a457b02a6edaca923" translate="yes" xml:space="preserve">
          <source>Length &lt;code&gt;(nin + nout) * ntypes&lt;/code&gt; array of &lt;code&gt;char&lt;/code&gt; encoding the &lt;a href=&quot;../generated/numpy.dtype.num#numpy.dtype.num&quot;&gt;&lt;code&gt;numpy.dtype.num&lt;/code&gt;&lt;/a&gt; (built-in only) that the corresponding function in the &lt;code&gt;func&lt;/code&gt; array accepts. For instance, for a comparison ufunc with three &lt;code&gt;ntypes&lt;/code&gt;, two &lt;code&gt;nin&lt;/code&gt; and one &lt;code&gt;nout&lt;/code&gt;, where the first function accepts &lt;code&gt;numpy.int32&lt;/code&gt; and the the second &lt;code&gt;numpy.int64&lt;/code&gt;, with both returning &lt;code&gt;numpy.bool_&lt;/code&gt;, &lt;code&gt;types&lt;/code&gt; would be &lt;code&gt;(char[]) {5, 5, 0, 7, 7, 0}&lt;/code&gt; since &lt;code&gt;NPY_INT32&lt;/code&gt; is 5, &lt;code&gt;NPY_INT64&lt;/code&gt; is 7, and &lt;code&gt;NPY_BOOL&lt;/code&gt; is 0.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a0ba05a259a8b34022dc6e1b217b0390cf104e0b" translate="yes" xml:space="preserve">
          <source>Length &lt;code&gt;(nin + nout) * ntypes&lt;/code&gt; array of &lt;code&gt;char&lt;/code&gt; encoding the &lt;a href=&quot;generated/numpy.dtype.num#numpy.dtype.num&quot;&gt;&lt;code&gt;numpy.dtype.num&lt;/code&gt;&lt;/a&gt; (built-in only) that the corresponding function in the &lt;code&gt;func&lt;/code&gt; array accepts. For instance, for a comparison ufunc with three &lt;code&gt;ntypes&lt;/code&gt;, two &lt;code&gt;nin&lt;/code&gt; and one &lt;code&gt;nout&lt;/code&gt;, where the first function accepts &lt;code&gt;numpy.int32&lt;/code&gt; and the the second &lt;code&gt;numpy.int64&lt;/code&gt;, with both returning &lt;code&gt;numpy.bool_&lt;/code&gt;, &lt;code&gt;types&lt;/code&gt; would be &lt;code&gt;(char[]) {5, 5, 0, 7, 7, 0}&lt;/code&gt; since &lt;code&gt;NPY_INT32&lt;/code&gt; is 5, &lt;code&gt;NPY_INT64&lt;/code&gt; is 7, and &lt;code&gt;NPY_BOOL&lt;/code&gt; is 0.</source>
          <target state="translated">Length &lt;code&gt;(nin + nout) * ntypes&lt;/code&gt; массив &lt;code&gt;char&lt;/code&gt; кодирующих &lt;a href=&quot;generated/numpy.dtype.num#numpy.dtype.num&quot;&gt; &lt;code&gt;numpy.dtype.num&lt;/code&gt; &lt;/a&gt; (только встроенный), который принимает соответствующая функция в массиве &lt;code&gt;func&lt;/code&gt; . Например, для сравнения ufunc с тремя &lt;code&gt;ntypes&lt;/code&gt; , двумя &lt;code&gt;nin&lt;/code&gt; и одним &lt;code&gt;nout&lt;/code&gt; , где первая функция принимает &lt;code&gt;numpy.int32&lt;/code&gt; , а вторая &lt;code&gt;numpy.int64&lt;/code&gt; , оба возвращают &lt;code&gt;numpy.bool_&lt;/code&gt; , &lt;code&gt;types&lt;/code&gt; будут &lt;code&gt;(char[]) {5, 5, 0, 7, 7, 0}&lt;/code&gt; поскольку &lt;code&gt;NPY_INT32&lt;/code&gt; равно 5, &lt;code&gt;NPY_INT64&lt;/code&gt; равно 7, а &lt;code&gt;NPY_BOOL&lt;/code&gt; равно 0.</target>
        </trans-unit>
        <trans-unit id="e599dfd0500969f55b8c9d010461f8e1fcc41925" translate="yes" xml:space="preserve">
          <source>Length of each array element, in number of characters. Default is 1.</source>
          <target state="translated">Длина каждого элемента массива,в количестве символов.По умолчанию 1.</target>
        </trans-unit>
        <trans-unit id="6dbef5ea0e7b53958b8a2d75b0863dd2996ea77a" translate="yes" xml:space="preserve">
          <source>Length of one array element in bytes.</source>
          <target state="translated">Длина одного элемента массива в байтах.</target>
        </trans-unit>
        <trans-unit id="ebd0316d087a92fa193507d4dfe490f6483edcaf" translate="yes" xml:space="preserve">
          <source>Length of the inverse FFT, the number of points along transformation axis in the input to use. If &lt;code&gt;n&lt;/code&gt; is smaller than the length of the input, the input is cropped. If it is larger, the input is padded with zeros. If &lt;code&gt;n&lt;/code&gt; is not given, the length of the input along the axis specified by &lt;code&gt;axis&lt;/code&gt; is used.</source>
          <target state="translated">Длина обратного БПФ, количество точек вдоль оси преобразования во входных данных для использования. Если &lt;code&gt;n&lt;/code&gt; меньше длины ввода, ввод обрезается. Если он больше, ввод дополняется нулями. Если &lt;code&gt;n&lt;/code&gt; не задано, используется длина входа по оси, заданной &lt;code&gt;axis&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c0386e146b5b66f11c90240baf5f54bbd4a84b7b" translate="yes" xml:space="preserve">
          <source>Length of the transformed axis of the output. For &lt;code&gt;n&lt;/code&gt; output points, &lt;code&gt;n//2 + 1&lt;/code&gt; input points are necessary. If the input is longer than this, it is cropped. If it is shorter than this, it is padded with zeros. If &lt;code&gt;n&lt;/code&gt; is not given, it is determined from the length of the input along the axis specified by &lt;code&gt;axis&lt;/code&gt;.</source>
          <target state="translated">Длина трансформируемой оси вывода. Для &lt;code&gt;n&lt;/code&gt; точек вывода необходимо &lt;code&gt;n//2 + 1&lt;/code&gt; входных точек. Если ввод длиннее, чем это, он обрезается. Если он короче этого, он дополняется нулями. Если &lt;code&gt;n&lt;/code&gt; не задано, оно определяется по длине входа вдоль оси, указанной &lt;code&gt;axis&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4f13f9612cce3a275a1186d10417cbf86f8f9b46" translate="yes" xml:space="preserve">
          <source>Length of the transformed axis of the output. For &lt;code&gt;n&lt;/code&gt; output points, &lt;code&gt;n//2 + 1&lt;/code&gt; input points are necessary. If the input is longer than this, it is cropped. If it is shorter than this, it is padded with zeros. If &lt;code&gt;n&lt;/code&gt; is not given, it is taken to be &lt;code&gt;2*(m-1)&lt;/code&gt; where &lt;code&gt;m&lt;/code&gt; is the length of the input along the axis specified by &lt;code&gt;axis&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ef669ab3a842002f9a1fb7bac5550ccceaa27247" translate="yes" xml:space="preserve">
          <source>Length of the transformed axis of the output. For &lt;code&gt;n&lt;/code&gt; output points, &lt;code&gt;n//2+1&lt;/code&gt; input points are necessary. If the input is longer than this, it is cropped. If it is shorter than this, it is padded with zeros. If &lt;code&gt;n&lt;/code&gt; is not given, it is determined from the length of the input along the axis specified by &lt;code&gt;axis&lt;/code&gt;.</source>
          <target state="translated">Длина трансформируемой оси вывода. Для &lt;code&gt;n&lt;/code&gt; точек вывода необходимо &lt;code&gt;n//2+1&lt;/code&gt; входных точек. Если ввод длиннее, чем это, он обрезается. Если он короче этого, он дополняется нулями. Если &lt;code&gt;n&lt;/code&gt; не задано, оно определяется по длине входа вдоль оси, указанной &lt;code&gt;axis&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1393d388a3302d35f0092d404b2ba089179672a7" translate="yes" xml:space="preserve">
          <source>Length of the transformed axis of the output. For &lt;code&gt;n&lt;/code&gt; output points, &lt;code&gt;n//2+1&lt;/code&gt; input points are necessary. If the input is longer than this, it is cropped. If it is shorter than this, it is padded with zeros. If &lt;code&gt;n&lt;/code&gt; is not given, it is taken to be &lt;code&gt;2*(m-1)&lt;/code&gt; where &lt;code&gt;m&lt;/code&gt; is the length of the input along the axis specified by &lt;code&gt;axis&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9649fc48731a6d9a87c71452f8efbcb7f76b78d4" translate="yes" xml:space="preserve">
          <source>Length of the transformed axis of the output. If &lt;code&gt;n&lt;/code&gt; is smaller than the length of the input, the input is cropped. If it is larger, the input is padded with zeros. If &lt;code&gt;n&lt;/code&gt; is not given, the length of the input along the axis specified by &lt;code&gt;axis&lt;/code&gt; is used.</source>
          <target state="translated">Длина трансформируемой оси вывода. Если &lt;code&gt;n&lt;/code&gt; меньше длины ввода, ввод обрезается. Если он больше, ввод дополняется нулями. Если &lt;code&gt;n&lt;/code&gt; не задано, используется длина входа по оси, заданной &lt;code&gt;axis&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="838e5e82eb9b3c833687dc387dbd43309bd32602" translate="yes" xml:space="preserve">
          <source>Length of the transformed axis of the output. If &lt;code&gt;n&lt;/code&gt; is smaller than the length of the input, the input is cropped. If it is larger, the input is padded with zeros. If &lt;code&gt;n&lt;/code&gt; is not given, the length of the input along the axis specified by &lt;code&gt;axis&lt;/code&gt; is used. See notes about padding issues.</source>
          <target state="translated">Длина трансформируемой оси вывода. Если &lt;code&gt;n&lt;/code&gt; меньше длины ввода, ввод обрезается. Если он больше, ввод дополняется нулями. Если &lt;code&gt;n&lt;/code&gt; не задано, используется длина входа по оси, заданной &lt;code&gt;axis&lt;/code&gt; . См. Примечания о проблемах с заполнением.</target>
        </trans-unit>
        <trans-unit id="20b7b6096b899f364abc1b0ab113ac1d88c95817" translate="yes" xml:space="preserve">
          <source>Lentner, Marvin, &amp;ldquo;Elementary Applied Statistics&amp;rdquo;, Bogden and Quigley, 1972.</source>
          <target state="translated">Лентнер, Марвин, &amp;laquo;Элементарная прикладная статистика&amp;raquo;, Богден и Куигли, 1972.</target>
        </trans-unit>
        <trans-unit id="ad48dd4be642df433d10c28592cb939dc42a109f" translate="yes" xml:space="preserve">
          <source>Less Basic</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e99e5b627f7ed42d45bd8cf2acdec386f4c6174c" translate="yes" xml:space="preserve">
          <source>Less robust estimator that that takes into account data variability and data size.</source>
          <target state="translated">Менее надежный оценщик,учитывающий изменчивость данных и их размер.</target>
        </trans-unit>
        <trans-unit id="ef5fe1edf37940bd463fee8eda068dc8d66b0f8a" translate="yes" xml:space="preserve">
          <source>Let</source>
          <target state="translated">Let</target>
        </trans-unit>
        <trans-unit id="a718bc5ba689b0611826e8a00c42db91a4cc33c1" translate="yes" xml:space="preserve">
          <source>Let &lt;code&gt;M = A.ndim&lt;/code&gt;, &lt;code&gt;N = B.ndim&lt;/code&gt;. Then the result, &lt;code&gt;C&lt;/code&gt;, of &lt;code&gt;op.outer(A, B)&lt;/code&gt; is an array of dimension M + N such that:</source>
          <target state="translated">Пусть &lt;code&gt;M = A.ndim&lt;/code&gt; , &lt;code&gt;N = B.ndim&lt;/code&gt; . Тогда результат, &lt;code&gt;C&lt;/code&gt; , из &lt;code&gt;op.outer(A, B)&lt;/code&gt; представляет собой массив размерности M + N , такие , что:</target>
        </trans-unit>
        <trans-unit id="c21492f5c1039f68826ed62d8fddcbe2ecf43d60" translate="yes" xml:space="preserve">
          <source>Let &lt;code&gt;x.shape&lt;/code&gt; be (10,20,30,40,50) and suppose &lt;code&gt;ind_1&lt;/code&gt; and &lt;code&gt;ind_2&lt;/code&gt; can be broadcast to the shape (2,3,4). Then &lt;code&gt;x[:,ind_1,ind_2]&lt;/code&gt; has shape (10,2,3,4,40,50) because the (20,30)-shaped subspace from X has been replaced with the (2,3,4) subspace from the indices. However, &lt;code&gt;x[:,ind_1,:,ind_2]&lt;/code&gt; has shape (2,3,4,10,30,50) because there is no unambiguous place to drop in the indexing subspace, thus it is tacked-on to the beginning. It is always possible to use &lt;a href=&quot;generated/numpy.ndarray.transpose#numpy.ndarray.transpose&quot;&gt;&lt;code&gt;.transpose()&lt;/code&gt;&lt;/a&gt; to move the subspace anywhere desired. Note that this example cannot be replicated using &lt;a href=&quot;generated/numpy.take#numpy.take&quot;&gt;&lt;code&gt;take&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Пусть &lt;code&gt;x.shape&lt;/code&gt; будет (10,20,30,40,50), и предположим, что &lt;code&gt;ind_1&lt;/code&gt; и &lt;code&gt;ind_2&lt;/code&gt; могут транслироваться в shape (2,3,4). Тогда &lt;code&gt;x[:,ind_1,ind_2]&lt;/code&gt; имеет форму (10,2,3,4,40,50), поскольку (20,30) -образное подпространство из X было заменено подпространством (2,3,4) из индексы. Однако &lt;code&gt;x[:,ind_1,:,ind_2]&lt;/code&gt; имеет форму (2 , 3, 4, 10, 30 , 50), потому что нет однозначного места для размещения в подпространстве индексации, поэтому он прикреплен к началу. Всегда можно использовать &lt;a href=&quot;generated/numpy.ndarray.transpose#numpy.ndarray.transpose&quot;&gt; &lt;code&gt;.transpose()&lt;/code&gt; &lt;/a&gt; для перемещения подпространства в любое место. Обратите внимание, что этот пример нельзя воспроизвести с помощью &lt;a href=&quot;generated/numpy.take#numpy.take&quot;&gt; &lt;code&gt;take&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="c5de9d97cc2b507966a716e78a84203d66bead94" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s apply the steps of wrapping Fortran functions to Python one by one.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="91c6bd95be9fba42070138c60bc544f63be79cf2" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s check that this is what we expected:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d53ca7c39e959075c64a326e51c71e27bb307d6d" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s consider a list of elements, &lt;code&gt;x&lt;/code&gt;, where values of -9999. represent missing data. We wish to compute the average value of the data and the vector of anomalies (deviations from the average):</source>
          <target state="translated">Рассмотрим список элементов &lt;code&gt;x&lt;/code&gt; , где значения -9999. представляют недостающие данные. Мы хотим вычислить среднее значение данных и вектор аномалий (отклонения от среднего):</target>
        </trans-unit>
        <trans-unit id="2913bcf139d6f47d02c0ac2f1be4a80f4a447c13" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s consider an array &lt;code&gt;d&lt;/code&gt; of floats between 0 and 1. We wish to compute the average of the values of &lt;code&gt;d&lt;/code&gt; while ignoring any data outside the range &lt;code&gt;[0.2, 0.9]&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ab1ea5de1d1447221ec240c0905b303173635736" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s consider an array &lt;code&gt;d&lt;/code&gt; of random floats between 0 and 1. We wish to compute the average of the values of &lt;code&gt;d&lt;/code&gt; while ignoring any data outside the range &lt;code&gt;[0.1, 0.9]&lt;/code&gt;:</source>
          <target state="translated">Рассмотрим массив &lt;code&gt;d&lt;/code&gt; случайных чисел с плавающей запятой между 0 и 1. Мы хотим вычислить среднее значение &lt;code&gt;d&lt;/code&gt; , игнорируя любые данные за пределами диапазона &lt;code&gt;[0.1, 0.9]&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="39281dff86138ded282e6212c34eb9cda8834f15" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s do 20,000 trials of the model, and count the number that generate zero positive results.</source>
          <target state="translated">Давайте проведем 20 000 испытаний модели и посчитаем число, дающее ноль положительных результатов.</target>
        </trans-unit>
        <trans-unit id="1b9b5278ac2afa5e3136c310885e0f8fd06a8be2" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s explore a more advanced concept in numpy called broadcasting. The term broadcasting describes how numpy treats arrays with different shapes during arithmetic operations. Subject to certain constraints, the smaller array is &amp;ldquo;broadcast&amp;rdquo; across the larger array so that they have compatible shapes. Broadcasting provides a means of vectorizing array operations so that looping occurs in C instead of Python. It does this without making needless copies of data and usually leads to efficient algorithm implementations. There are also cases where broadcasting is a bad idea because it leads to inefficient use of memory that slows computation. This article provides a gentle introduction to broadcasting with numerous examples ranging from simple to involved. It also provides hints on when and when not to use broadcasting.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f8b59fac8428f8c1733e5af773d6cbf876149f27" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s look at two examples we&amp;rsquo;ve seen before to see how they might be implemented using Cython. These examples were compiled into extension modules using Cython 0.21.1.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ddfef2ee46e1e4256e10013c995a2b4530178cef" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s say the two integers were in fact 1 and 770. Because 770 = 256 * 3 + 2, the 4 bytes in memory would contain respectively: 0, 1, 3, 2. The bytes I have loaded from the file would have these contents:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="95938c655542a69cb7228f0ca9c4b635920085cc" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s say you create this array:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6b85caabf5e3eeb59af1ba993281156e38d2a215" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s say you have this array:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d641e5a95c4dff41b3615beef8a44670fd8d8071" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s see how this goes for our array:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="663e98c256d28e922f69b08f25c6c3b896decad0" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s see how this works in practice with just one matrix first. Note that according to &lt;a href=&quot;https://en.wikipedia.org/wiki/Grayscale#Colorimetric_(perceptual_luminance-preserving)_conversion_to_grayscale&quot;&gt;colorimetry&lt;/a&gt;, it is possible to obtain a fairly reasonable grayscale version of our color image if we apply the formula</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ba48f83aec5246b87728fc21ac0f71842c7f7846" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s start with this array, called &amp;ldquo;a&amp;rdquo;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3229609e15436ec51bcf00818a69a84dbc58a0c2" translate="yes" xml:space="preserve">
          <source>License</source>
          <target state="translated">License</target>
        </trans-unit>
        <trans-unit id="8be2fdf380d9d18148fd2ad94dc354c20768a219" translate="yes" xml:space="preserve">
          <source>License of NumPy</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="538c09161b8497f998404cafc34964ed3a445575" translate="yes" xml:space="preserve">
          <source>Licensed under the 3-clause BSD License.</source>
          <target state="translated">Лицензия BSD 3-clause License.</target>
        </trans-unit>
        <trans-unit id="b0484b837c9aac64b9b4f0cbb8a409c60f826cd6" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;#c.PyArray_DescrConverter&quot;&gt;&lt;code&gt;PyArray_DescrConverter&lt;/code&gt;&lt;/a&gt; except it aligns C-struct-like objects on word-boundaries as the compiler would.</source>
          <target state="translated">Подобно &lt;a href=&quot;#c.PyArray_DescrConverter&quot;&gt; &lt;code&gt;PyArray_DescrConverter&lt;/code&gt; ,&lt;/a&gt; за исключением того, что он выравнивает объекты, подобные C-структуре, по границам слов, как это сделал бы компилятор.</target>
        </trans-unit>
        <trans-unit id="2bf9a983b58a3025088acd0d34cc34c35bed8eba" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;#c.PyArray_DescrConverter2&quot;&gt;&lt;code&gt;PyArray_DescrConverter2&lt;/code&gt;&lt;/a&gt; except it aligns C-struct-like objects on word-boundaries as the compiler would.</source>
          <target state="translated">Подобно &lt;a href=&quot;#c.PyArray_DescrConverter2&quot;&gt; &lt;code&gt;PyArray_DescrConverter2&lt;/code&gt; ,&lt;/a&gt; за исключением того, что он выравнивает объекты, подобные C-структуре, по границам слов, как это сделал бы компилятор.</target>
        </trans-unit>
        <trans-unit id="98e8d5db12d0ec6df75e2b77dc6308321b737245" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;generated/numpy.char.find#numpy.char.find&quot;&gt;&lt;code&gt;find&lt;/code&gt;&lt;/a&gt;, but raises &lt;code&gt;ValueError&lt;/code&gt; when the substring is not found.</source>
          <target state="translated">Подобно &lt;a href=&quot;generated/numpy.char.find#numpy.char.find&quot;&gt; &lt;code&gt;find&lt;/code&gt; &lt;/a&gt; , но вызывает &lt;code&gt;ValueError&lt;/code&gt; если подстрока не найдена.</target>
        </trans-unit>
        <trans-unit id="8cac4055aba9315ef35a508ccbff6fd2fccbce50" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;generated/numpy.char.rfind#numpy.char.rfind&quot;&gt;&lt;code&gt;rfind&lt;/code&gt;&lt;/a&gt;, but raises &lt;code&gt;ValueError&lt;/code&gt; when the substring &lt;code&gt;sub&lt;/code&gt; is not found.</source>
          <target state="translated">Аналогичен &lt;a href=&quot;generated/numpy.char.rfind#numpy.char.rfind&quot;&gt; &lt;code&gt;rfind&lt;/code&gt; &lt;/a&gt; , но вызывает ошибку &lt;code&gt;ValueError&lt;/code&gt; , если подстрока &lt;code&gt;sub&lt;/code&gt; не найдена.</target>
        </trans-unit>
        <trans-unit id="bfb637364ad5b206ba50bed21f3142c132fe9341" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;https://docs.scipy.org/doc/numpy-1.17.0/reference/generated/numpy.chararray.find.html#numpy.chararray.find&quot;&gt;&lt;code&gt;find&lt;/code&gt;&lt;/a&gt;, but raises &lt;code&gt;ValueError&lt;/code&gt; when the substring is not found.</source>
          <target state="translated">Подобно &lt;a href=&quot;https://docs.scipy.org/doc/numpy-1.17.0/reference/generated/numpy.chararray.find.html#numpy.chararray.find&quot;&gt; &lt;code&gt;find&lt;/code&gt; &lt;/a&gt; , но вызывает &lt;code&gt;ValueError&lt;/code&gt; если подстрока не найдена.</target>
        </trans-unit>
        <trans-unit id="6f8c624e10b2f68f4700be90af9ceef9f419abcf" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;https://docs.scipy.org/doc/numpy-1.17.0/reference/generated/numpy.chararray.rfind.html#numpy.chararray.rfind&quot;&gt;&lt;code&gt;rfind&lt;/code&gt;&lt;/a&gt;, but raises &lt;code&gt;ValueError&lt;/code&gt; when the substring &lt;code&gt;sub&lt;/code&gt; is not found.</source>
          <target state="translated">Аналогичен &lt;a href=&quot;https://docs.scipy.org/doc/numpy-1.17.0/reference/generated/numpy.chararray.rfind.html#numpy.chararray.rfind&quot;&gt; &lt;code&gt;rfind&lt;/code&gt; &lt;/a&gt; , но вызывает ошибку &lt;code&gt;ValueError&lt;/code&gt; , если подстрока &lt;code&gt;sub&lt;/code&gt; не найдена.</target>
        </trans-unit>
        <trans-unit id="74d7df04563822c7d8ad24dbe267870b77fbb351" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;numpy.char.find#numpy.char.find&quot;&gt;&lt;code&gt;find&lt;/code&gt;&lt;/a&gt;, but raises &lt;code&gt;ValueError&lt;/code&gt; when the substring is not found.</source>
          <target state="translated">Подобно &lt;a href=&quot;numpy.char.find#numpy.char.find&quot;&gt; &lt;code&gt;find&lt;/code&gt; &lt;/a&gt; , но вызывает &lt;code&gt;ValueError&lt;/code&gt; если подстрока не найдена.</target>
        </trans-unit>
        <trans-unit id="b35ea9f95fe9a083c883dcd6041e1ed2b46d8192" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;numpy.char.rfind#numpy.char.rfind&quot;&gt;&lt;code&gt;rfind&lt;/code&gt;&lt;/a&gt;, but raises &lt;code&gt;ValueError&lt;/code&gt; when the substring &lt;code&gt;sub&lt;/code&gt; is not found.</source>
          <target state="translated">Аналогичен &lt;a href=&quot;numpy.char.rfind#numpy.char.rfind&quot;&gt; &lt;code&gt;rfind&lt;/code&gt; &lt;/a&gt; , но вызывает ошибку &lt;code&gt;ValueError&lt;/code&gt; , если подстрока &lt;code&gt;sub&lt;/code&gt; не найдена.</target>
        </trans-unit>
        <trans-unit id="1381300ae7e04647799c4d29476d81d2674e1d00" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;numpy.chararray.find#numpy.chararray.find&quot;&gt;&lt;code&gt;find&lt;/code&gt;&lt;/a&gt;, but raises &lt;code&gt;ValueError&lt;/code&gt; when the substring is not found.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b6baf9238888e49aa859d8fb862f39242936cfbf" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;numpy.chararray.rfind#numpy.chararray.rfind&quot;&gt;&lt;code&gt;rfind&lt;/code&gt;&lt;/a&gt;, but raises &lt;code&gt;ValueError&lt;/code&gt; when the substring &lt;code&gt;sub&lt;/code&gt; is not found.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8f6786bbc0e6826ccf967ce3d26832cec08da525" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;catch_warnings&lt;/code&gt; this context manager is not threadsafe.</source>
          <target state="translated">Как и &lt;code&gt;catch_warnings&lt;/code&gt; , этот диспетчер контекста не является потокобезопасным.</target>
        </trans-unit>
        <trans-unit id="4988e06267fc3ad462b8b1372828e98aa6abe4ae" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;recfromtxt&lt;/code&gt;, but with a default &lt;code&gt;delimiter=&quot;,&quot;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b0fa83334e9080fab8905202d2a0b49831c3f225" translate="yes" xml:space="preserve">
          <source>Like for other types, NumPy includes a typedef npy_half for the 16 bit float. Unlike for most of the other types, you cannot use this as a normal type in C, since it is a typedef for npy_uint16. For example, 1.0 looks like 0x3c00 to C, and if you do an equality comparison between the different signed zeros, you will get -0.0 != 0.0 (0x8000 != 0x0000), which is incorrect.</source>
          <target state="translated">Как и для других типов,NumPy включает typedef npy_half для 16-битного float.В отличие от большинства других типов,вы не можете использовать его в качестве нормального типа в Си,так как это typedef для npy_uint16.Например,1.0 выглядит как 0x3c00 на С,и если провести сравнение равенства между разными знаковыми нулями,то получится -0.0 !=0.0 (0x8000 !=0x0000),что неправильно.</target>
        </trans-unit>
        <trans-unit id="e112999c2cd378720fa09f5bf6d3cb8761f7e014" translate="yes" xml:space="preserve">
          <source>Like with some other special methods in python, such as &lt;code&gt;__hash__&lt;/code&gt; and &lt;code&gt;__iter__&lt;/code&gt;, it is possible to indicate that your class does &lt;em&gt;not&lt;/em&gt; support ufuncs by setting &lt;code&gt;__array_ufunc__ = None&lt;/code&gt;. Ufuncs always raise &lt;a href=&quot;https://docs.python.org/dev/library/exceptions.html#TypeError&quot;&gt;&lt;code&gt;TypeError&lt;/code&gt;&lt;/a&gt; when called on an object that sets &lt;code&gt;__array_ufunc__ = None&lt;/code&gt;.</source>
          <target state="translated">Как и в случае с некоторыми другими специальными методами в Python, такими как &lt;code&gt;__hash__&lt;/code&gt; и &lt;code&gt;__iter__&lt;/code&gt; , можно указать, что ваш класс &lt;em&gt;не&lt;/em&gt; поддерживает ufuncs, установив &lt;code&gt;__array_ufunc__ = None&lt;/code&gt; . Ufuncs всегда поднимают &lt;a href=&quot;https://docs.python.org/dev/library/exceptions.html#TypeError&quot;&gt; &lt;code&gt;TypeError&lt;/code&gt; &lt;/a&gt; при вызове на объекте , который устанавливает &lt;code&gt;__array_ufunc__ = None&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4aa7900482808a9df749231293505b57d3e3de9c" translate="yes" xml:space="preserve">
          <source>Likewise, ellipsis can be specified by code by using the Ellipsis object:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3297842e50729fb77f4f0545de2f9ff7aa3909b6" translate="yes" xml:space="preserve">
          <source>Likewise, slicing can be combined with broadcasted boolean indices:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a7c04c64ed3f2a9374590c76c50d3b7f1b18e3da" translate="yes" xml:space="preserve">
          <source>Limitations</source>
          <target state="translated">Limitations</target>
        </trans-unit>
        <trans-unit id="aed0f783a12a4ca0992442cfbd711f6845a91b7b" translate="yes" xml:space="preserve">
          <source>Limpert, E., Stahel, W. A., and Abbt, M., &amp;ldquo;Log-normal Distributions across the Sciences: Keys and Clues,&amp;rdquo; BioScience, Vol. 51, No. 5, May, 2001. &lt;a href=&quot;https://stat.ethz.ch/~stahel/lognormal/bioscience.pdf&quot;&gt;https://stat.ethz.ch/~stahel/lognormal/bioscience.pdf&lt;/a&gt;</source>
          <target state="translated">Лимперт, Э., Стахел, В.А. и Эббт, М., &amp;laquo;Логнормальные распределения по наукам: ключи и ключи&amp;raquo;, BioScience, Vol. 51, No. 5, май 2001 г. &lt;a href=&quot;https://stat.ethz.ch/~stahel/lognormal/bioscience.pdf&quot;&gt;https://stat.ethz.ch/~stahel/lognormal/bioscience.pdf&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="2c6327e28944d450d23eb12c3f0eb10b95ac744a" translate="yes" xml:space="preserve">
          <source>LinAlgError</source>
          <target state="translated">LinAlgError</target>
        </trans-unit>
        <trans-unit id="fbfdf4025591ea0589baa96d7f54fd5d7f0a5dbd" translate="yes" xml:space="preserve">
          <source>Line breaks are not included in the resulting list unless keepends is given and true.</source>
          <target state="translated">Перерывы строк не включаются в результирующий список,если только не заданы и не верны значения keepends.</target>
        </trans-unit>
        <trans-unit id="fd8f1853d29d8157d704e36102bd70d85ec315bd" translate="yes" xml:space="preserve">
          <source>Line spacing and indentation are significant and should be carefully followed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fcb739908d0a50031f680d3b4fffc6749c4002d3" translate="yes" xml:space="preserve">
          <source>Linear Algebra</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4c2d7925777b262f78b0ed1ceeb1f07eef61acc7" translate="yes" xml:space="preserve">
          <source>Linear Algebra Equivalents</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c77bb2c05a2dcf0461045da9b6109d509594fc9a" translate="yes" xml:space="preserve">
          <source>Linear Algebra libraries</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="06d74260ba46e8ed76ff22dda956f18a7b66203c" translate="yes" xml:space="preserve">
          <source>Linear algebra</source>
          <target state="translated">Линейная алгебра</target>
        </trans-unit>
        <trans-unit id="ef4be3efd16d5b211ab89b5efbf030ca1bafba61" translate="yes" xml:space="preserve">
          <source>Linear algebra (&lt;code&gt;numpy.linalg&lt;/code&gt;)</source>
          <target state="translated">Линейная алгебра ( &lt;code&gt;numpy.linalg&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="e2be6b18cf91c04a7b6c400bd00876f94a2389cb" translate="yes" xml:space="preserve">
          <source>Linear algebra (numpy.linalg)</source>
          <target state="translated">Линейная алгебра (numpy.linalg)</target>
        </trans-unit>
        <trans-unit id="b624aab78757a9b353883b1449d6df824049976b" translate="yes" xml:space="preserve">
          <source>Linear algebra on several matrices at once</source>
          <target state="translated">Линейная алгебра на нескольких матрицах одновременно.</target>
        </trans-unit>
        <trans-unit id="991cbbcb4b1ecb2172a95ff800353dc3c4b54edd" translate="yes" xml:space="preserve">
          <source>Linear map parameters between domains.</source>
          <target state="translated">Параметры линейной карты между доменами.</target>
        </trans-unit>
        <trans-unit id="eb36eb210c8667bae908d8f0d19ef3098c4c1701" translate="yes" xml:space="preserve">
          <source>Link extension module with &amp;lt;resource&amp;gt; as defined by &lt;code&gt;numpy_distutils/system_info.py&lt;/code&gt;. E.g. to link with optimized LAPACK libraries (vecLib on MacOSX, ATLAS elsewhere), use &lt;code&gt;--link-lapack_opt&lt;/code&gt;. See also &lt;code&gt;--help-link&lt;/code&gt; switch.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="26958b7c786c621d84d02830a0b14f77df5b2d9e" translate="yes" xml:space="preserve">
          <source>Linking against the core math library in an extension</source>
          <target state="translated">Связь с основной математической библиотекой в расширении</target>
        </trans-unit>
        <trans-unit id="f9ddb8c3deec44cd98e047bb68bdaf188f3b72f8" translate="yes" xml:space="preserve">
          <source>Linking your repository to the upstream repo</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="014bcd654c60d5250fad2123b073b9c0ac3340f6" translate="yes" xml:space="preserve">
          <source>Links</source>
          <target state="translated">Links</target>
        </trans-unit>
        <trans-unit id="2d54756ca8573af092113bb3435c0903eeb35dd6" translate="yes" xml:space="preserve">
          <source>Links : If you need to include hyperlinks in your docstring, note that some docstring sections are not parsed as standard reST, and in these sections, numpydoc may become confused by hyperlink targets such as:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="518ed7ba947b32b000717c46a46d61dd856bd112" translate="yes" xml:space="preserve">
          <source>Linus Torvalds on &lt;a href=&quot;http://kerneltrap.org/Linux/Git_Management&quot;&gt;git management&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="965d93d3a9947030cc756b2db0fcacc76437a993" translate="yes" xml:space="preserve">
          <source>Linus Torvalds on &lt;a href=&quot;https://www.mail-archive.com/dri-devel@lists.sourceforge.net/msg39091.html&quot;&gt;linux git workflow&lt;/a&gt; . Summary; use the git tools to make the history of your edits as clean as possible; merge from upstream edits as little as possible in branches where you are doing active development.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="83ad8510bbd3f22363d068e1c96f82fd0fcccd31" translate="yes" xml:space="preserve">
          <source>Linux</source>
          <target state="translated">Linux</target>
        </trans-unit>
        <trans-unit id="d1400c37d080d60eab76dbcb84834f7292aae696" translate="yes" xml:space="preserve">
          <source>Linux timings used Ubuntu 18.04 and GCC 7.4. Windows timings were made on Windows 10 using Microsoft C/C++ Optimizing Compiler Version 19 (Visual Studio 2015). All timings were produced on a i5-3570 processor.</source>
          <target state="translated">В таймингах Linux использовались Ubuntu 18.04 и GCC 7.4.Тайминги для Windows были сделаны на Windows 10 с использованием Microsoft C/C++Optimizing Compiler Version 19 (Visual Studio 2015).Все тайминги производились на процессоре i5-3570.</target>
        </trans-unit>
        <trans-unit id="56d0cc5c207ff297b983e9b52ef59aa241b28b67" translate="yes" xml:space="preserve">
          <source>Linux timings used Ubuntu 18.04 and GCC 7.4. Windows timings were made on Windows 10 using Microsoft C/C++ Optimizing Compiler Version 19 (Visual Studio 2015). All timings were produced on an i5-3570 processor.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="87860891be4cddda593f0fa03126f25fb568db9f" translate="yes" xml:space="preserve">
          <source>Linux: 32-bit and 64-bit Manylinux1 wheels built using travis-ci.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="97d9791ab8737c4211f3e78630cca56638f02eb1" translate="yes" xml:space="preserve">
          <source>List available Fortran compilers.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eb5d7118db68e7b8996c3d0844e8e2d779102b13" translate="yes" xml:space="preserve">
          <source>List of array-like objects (such as lists, tuples, and ndarrays).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="decb4e37dac06b0a04b2b5a1ce16d06dbaf9430d" translate="yes" xml:space="preserve">
          <source>List of maximum degrees of the form [x_deg, y_deg, z_deg].</source>
          <target state="translated">Список максимальных степеней формы [x_deg,y_deg,z_deg].</target>
        </trans-unit>
        <trans-unit id="16b40ddc35115642a1ebd2b343c063499d9e736a" translate="yes" xml:space="preserve">
          <source>List of maximum degrees of the form [x_deg, y_deg].</source>
          <target state="translated">Список максимальных степеней формы [x_deg,y_deg].</target>
        </trans-unit>
        <trans-unit id="3946ce7ee00307be1e56a351d33b3682868445a4" translate="yes" xml:space="preserve">
          <source>List of roots.</source>
          <target state="translated">Список корней.</target>
        </trans-unit>
        <trans-unit id="4e5a894ae66af5e5eb828b13d596e0e9298ff835" translate="yes" xml:space="preserve">
          <source>List of source file locations relative to the top directory of the package.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2c7afb1b33d8f0bf102c5fdc5f3bfa27a81be1cb" translate="yes" xml:space="preserve">
          <source>List of the library&amp;rsquo;s source files. See &lt;a href=&quot;#numpy.distutils.misc_util.Configuration.add_library&quot;&gt;&lt;code&gt;add_library&lt;/code&gt;&lt;/a&gt; for details.</source>
          <target state="translated">Список исходных файлов библиотеки. Подробнее см. &lt;a href=&quot;#numpy.distutils.misc_util.Configuration.add_library&quot;&gt; &lt;code&gt;add_library&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="5754e63d6ae44ac265c0defe49c460674a2539b7" translate="yes" xml:space="preserve">
          <source>List of the most important terms</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6519aa721c25f67c763afcfac03293aba9cab8a8" translate="yes" xml:space="preserve">
          <source>List of the sources. The list of sources may contain functions (called source generators) which must take an extension instance and a build directory as inputs and return a source file or list of source files or None. If None is returned then no sources are generated. If the Extension instance has no sources after processing all source generators, then no extension module is built.</source>
          <target state="translated">Список источников.Список источников может содержать функции (называемые генераторами источников),которые должны взять в качестве входных данных экземпляр расширения и каталог сборки и вернуть исходный файл или список исходных файлов или Нет.Если None возвращается,то источники не генерируются.Если экземпляр расширения не имеет источников после обработки всех генераторов источников,то модуль расширения не собирается.</target>
        </trans-unit>
        <trans-unit id="2485a7cc99c4617bf66ce59e5b75a2d0c1ccfb4b" translate="yes" xml:space="preserve">
          <source>List system resources found by &lt;code&gt;numpy_distutils/system_info.py&lt;/code&gt;. For example, try &lt;code&gt;f2py --help-link lapack_opt&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="50800b4f18e2a927baac61501f7e23170e957be0" translate="yes" xml:space="preserve">
          <source>List with any extra arguments to pass to nosetests.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="70836ea6cfbd010e5c69675c6ed9768657e90763" translate="yes" xml:space="preserve">
          <source>Literal string representation.</source>
          <target state="translated">Представление буквенных строк.</target>
        </trans-unit>
        <trans-unit id="d75a54184aa53b5be4e832c635455d88f3cdc5e6" translate="yes" xml:space="preserve">
          <source>Load a pickle from the current string.</source>
          <target state="translated">Загрузите огурчик из текущей строки.</target>
        </trans-unit>
        <trans-unit id="3a504cdc1122f04029c4d408c355532536995f45" translate="yes" xml:space="preserve">
          <source>Load arrays or pickled objects from &lt;code&gt;.npy&lt;/code&gt;, &lt;code&gt;.npz&lt;/code&gt; or pickled files.</source>
          <target state="translated">Загружайте массивы или маринованные объекты из &lt;code&gt;.npy&lt;/code&gt; , &lt;code&gt;.npz&lt;/code&gt; или маринованных файлов.</target>
        </trans-unit>
        <trans-unit id="9d2a30e3c587d0309a2b15e920e2381e52d3b73a" translate="yes" xml:space="preserve">
          <source>Load data from a text file, with missing values handled as specified.</source>
          <target state="translated">Загружайте данные из текстового файла,при этом отсутствующие значения обрабатываются так,как указано.</target>
        </trans-unit>
        <trans-unit id="671e399a95a295b1b112f2ec88bde3aa682ce01d" translate="yes" xml:space="preserve">
          <source>Load data from a text file.</source>
          <target state="translated">Загрузить данные из текстового файла.</target>
        </trans-unit>
        <trans-unit id="ede7696890a000813048b7b45d0ec4e8eaa41ac3" translate="yes" xml:space="preserve">
          <source>Load data with missing values handled as specified.</source>
          <target state="translated">Загружайте данные с пропущенными значениями,обработанными как указано.</target>
        </trans-unit>
        <trans-unit id="0fb4575d68b4fb0f498f6ef6cd58ad29dfef99ec" translate="yes" xml:space="preserve">
          <source>Load the files created by savez_compressed.</source>
          <target state="translated">Загружайте файлы,созданные с помощью savez_compressed.</target>
        </trans-unit>
        <trans-unit id="00e2276e50083512489893c74a3667bfb2f8d261" translate="yes" xml:space="preserve">
          <source>Load the memmap and verify data was stored:</source>
          <target state="translated">Загрузите карту памяти и проверьте,что данные сохранены:</target>
        </trans-unit>
        <trans-unit id="f5bde0422e688546d3fcbda903a1675bdef859be" translate="yes" xml:space="preserve">
          <source>Load the shared library.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4f1b35f9beeb82ff23b55bdd7e4bccbaa09655da" translate="yes" xml:space="preserve">
          <source>Loading files that contain object arrays uses the &lt;code&gt;pickle&lt;/code&gt; module, which is not secure against erroneous or maliciously constructed data. Consider passing &lt;code&gt;allow_pickle=False&lt;/code&gt; to load data that is known not to contain object arrays for the safer handling of untrusted sources.</source>
          <target state="translated">Загрузка файлов, содержащих массивы объектов, использует модуль &lt;code&gt;pickle&lt;/code&gt; , который не защищен от ошибочных или злонамеренно созданных данных. Рассмотрите возможность передачи &lt;code&gt;allow_pickle=False&lt;/code&gt; для загрузки данных, которые, как известно, не содержат массивов объектов, для более безопасной обработки ненадежных источников.</target>
        </trans-unit>
        <trans-unit id="dc43ff557f7299b63c00a5f98241bc55534a0318" translate="yes" xml:space="preserve">
          <source>Loading the shared library</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dcd21227c7ed1f7628c4569c3c3b1f97f5e4a3e0" translate="yes" xml:space="preserve">
          <source>Local file path or URL to open.</source>
          <target state="translated">Локальный путь к файлу или URL для открытия.</target>
        </trans-unit>
        <trans-unit id="399e1ff0ce348a172dad0b088afb4891c55b0357" translate="yes" xml:space="preserve">
          <source>Lock instance that is shared so that the same BitGenerator can be used in multiple Generators without corrupting the state. Code that generates values from a bit generator should hold the bit generator&amp;rsquo;s lock.</source>
          <target state="translated">Экземпляр блокировки, который используется совместно, чтобы один и тот же BitGenerator можно было использовать в нескольких генераторах без нарушения состояния. Код, который генерирует значения из битового генератора, должен удерживать блокировку битового генератора.</target>
        </trans-unit>
        <trans-unit id="2d415fb960b72005c6491287e9aedba95abd331c" translate="yes" xml:space="preserve">
          <source>Lock instance that is shared so that the same bit git generator can be used in multiple Generators without corrupting the state. Code that generates values from a bit generator should hold the bit generator&amp;rsquo;s lock.</source>
          <target state="translated">Экземпляр Lock, который используется совместно, чтобы один и тот же битовый генератор git можно было использовать в нескольких генераторах без нарушения состояния. Код, который генерирует значения из битового генератора, должен удерживать блокировку битового генератора.</target>
        </trans-unit>
        <trans-unit id="107cbe58cd70b9b9564b7a980ec9a134ba83ff37" translate="yes" xml:space="preserve">
          <source>Log error message:</source>
          <target state="translated">Сообщение об ошибке в журнале:</target>
        </trans-unit>
        <trans-unit id="4eb269913863abecf02addc638fee893d2c7588f" translate="yes" xml:space="preserve">
          <source>Log into your &lt;a href=&quot;https://github.com/numpy/numpy&quot;&gt;github&lt;/a&gt; account.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5b18e27bd081f5e88f5467d9d05245be1522ecbd" translate="yes" xml:space="preserve">
          <source>Logarithm is a multivalued function: for each &lt;code&gt;x&lt;/code&gt; there is an infinite number of &lt;code&gt;z&lt;/code&gt; such that &lt;code&gt;10**z = x&lt;/code&gt;. The convention is to return the &lt;code&gt;z&lt;/code&gt; whose imaginary part lies in &lt;code&gt;[-pi, pi]&lt;/code&gt;.</source>
          <target state="translated">Логарифм - это многозначная функция: для каждого &lt;code&gt;x&lt;/code&gt; существует бесконечное число &lt;code&gt;z&lt;/code&gt; таких, что &lt;code&gt;10**z = x&lt;/code&gt; . По соглашению возвращать &lt;code&gt;z&lt;/code&gt; , мнимая часть которого лежит в &lt;code&gt;[-pi, pi]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5a52fe88f1d34f63b32537a63132c16ed59948f4" translate="yes" xml:space="preserve">
          <source>Logarithm is a multivalued function: for each &lt;code&gt;x&lt;/code&gt; there is an infinite number of &lt;code&gt;z&lt;/code&gt; such that &lt;code&gt;2**z = x&lt;/code&gt;. The convention is to return the &lt;code&gt;z&lt;/code&gt; whose imaginary part lies in &lt;code&gt;[-pi, pi]&lt;/code&gt;.</source>
          <target state="translated">Логарифм - это многозначная функция: для каждого &lt;code&gt;x&lt;/code&gt; существует бесконечное число &lt;code&gt;z&lt;/code&gt; таких, что &lt;code&gt;2**z = x&lt;/code&gt; . По соглашению возвращать &lt;code&gt;z&lt;/code&gt; , мнимая часть которого лежит в &lt;code&gt;[-pi, pi]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="04517496328a3b4c1d39612790fc59d3b950de57" translate="yes" xml:space="preserve">
          <source>Logarithm is a multivalued function: for each &lt;code&gt;x&lt;/code&gt; there is an infinite number of &lt;code&gt;z&lt;/code&gt; such that &lt;code&gt;exp(z) = 1 + x&lt;/code&gt;. The convention is to return the &lt;code&gt;z&lt;/code&gt; whose imaginary part lies in &lt;code&gt;[-pi, pi]&lt;/code&gt;.</source>
          <target state="translated">Логарифм - это многозначная функция: для каждого &lt;code&gt;x&lt;/code&gt; существует бесконечное число &lt;code&gt;z&lt;/code&gt; таких, что &lt;code&gt;exp(z) = 1 + x&lt;/code&gt; . По соглашению возвращать &lt;code&gt;z&lt;/code&gt; , мнимая часть которого лежит в &lt;code&gt;[-pi, pi]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8f044358a356b12f8f04d65ec46fba2c711db9ca" translate="yes" xml:space="preserve">
          <source>Logarithm is a multivalued function: for each &lt;code&gt;x&lt;/code&gt; there is an infinite number of &lt;code&gt;z&lt;/code&gt; such that &lt;code&gt;exp(z) = x&lt;/code&gt;. The convention is to return the &lt;code&gt;z&lt;/code&gt; whose imaginary part lies in &lt;code&gt;[-pi, pi]&lt;/code&gt;.</source>
          <target state="translated">Логарифм - это многозначная функция: для каждого &lt;code&gt;x&lt;/code&gt; существует бесконечное число &lt;code&gt;z&lt;/code&gt; таких, что &lt;code&gt;exp(z) = x&lt;/code&gt; . По соглашению возвращать &lt;code&gt;z&lt;/code&gt; , мнимая часть которого лежит в &lt;code&gt;[-pi, pi]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="166930005429709b3b373125970bc9f001b57f22" translate="yes" xml:space="preserve">
          <source>Logarithm of &lt;code&gt;exp(x1) + exp(x2)&lt;/code&gt;. This is a scalar if both &lt;code&gt;x1&lt;/code&gt; and &lt;code&gt;x2&lt;/code&gt; are scalars.</source>
          <target state="translated">Логарифм &lt;code&gt;exp(x1) + exp(x2)&lt;/code&gt; . Это скаляр, если и &lt;code&gt;x1&lt;/code&gt; , и &lt;code&gt;x2&lt;/code&gt; являются скалярами.</target>
        </trans-unit>
        <trans-unit id="0df50307c119146d5dc714638f54a5eccd592099" translate="yes" xml:space="preserve">
          <source>Logarithm of the sum of exponentiations of inputs in base 2.</source>
          <target state="translated">Логарифм суммы выражений входов в базе 2.</target>
        </trans-unit>
        <trans-unit id="3a29b9b1054fef950824734dd96565e57e322c96" translate="yes" xml:space="preserve">
          <source>Logarithm of the sum of exponentiations of the inputs in base-2.</source>
          <target state="translated">Логарифм суммы выражений входов в базе-2.</target>
        </trans-unit>
        <trans-unit id="273c857a62012f5708232560c688d9c8f7c28ba5" translate="yes" xml:space="preserve">
          <source>Logarithm of the sum of exponentiations of the inputs.</source>
          <target state="translated">Логаритм суммы выражений входов.</target>
        </trans-unit>
        <trans-unit id="e7b8fad3893b278189df782f86ba4d32084ced17" translate="yes" xml:space="preserve">
          <source>Logarithm to base 10 of the Euler constant (</source>
          <target state="translated">Логарифм к базе 10 константы Эйлера (</target>
        </trans-unit>
        <trans-unit id="80963c1ddcee26932e512e1ef164c3f919eb6773" translate="yes" xml:space="preserve">
          <source>Logarithm to base 2 of the Euler constant (</source>
          <target state="translated">Логарифм к базе 2 константы Эйлера (</target>
        </trans-unit>
        <trans-unit id="dca3308567585813d8c4516ae0b5df7d6382aa24" translate="yes" xml:space="preserve">
          <source>Logic functions</source>
          <target state="translated">Логические функции</target>
        </trans-unit>
        <trans-unit id="acdcdb17721480a7efeeb33b0138faad218dbf31" translate="yes" xml:space="preserve">
          <source>Logical NOT is applied to the elements of &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="translated">Логическое НЕ применяется к элементам &lt;code&gt;x&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="98ddc2178009c7731c8ae53ab405983c8f38c802" translate="yes" xml:space="preserve">
          <source>Logical OR is applied to the elements of &lt;code&gt;x1&lt;/code&gt; and &lt;code&gt;x2&lt;/code&gt;. If &lt;code&gt;x1.shape != x2.shape&lt;/code&gt;, they must be broadcastable to a common shape (which becomes the shape of the output).</source>
          <target state="translated">К элементам &lt;code&gt;x1&lt;/code&gt; и &lt;code&gt;x2&lt;/code&gt; применяется логическое ИЛИ . Если &lt;code&gt;x1.shape != x2.shape&lt;/code&gt; , они должны транслироваться в общую форму (которая становится формой вывода).</target>
        </trans-unit>
        <trans-unit id="f5bd72920a8d92e6480e74978ed9235cd1d3ad95" translate="yes" xml:space="preserve">
          <source>Logical XOR is applied to the elements of &lt;code&gt;x1&lt;/code&gt; and &lt;code&gt;x2&lt;/code&gt;. If &lt;code&gt;x1.shape != x2.shape&lt;/code&gt;, they must be broadcastable to a common shape (which becomes the shape of the output).</source>
          <target state="translated">Логический XOR применяется к элементам &lt;code&gt;x1&lt;/code&gt; и &lt;code&gt;x2&lt;/code&gt; . Если &lt;code&gt;x1.shape != x2.shape&lt;/code&gt; , они должны транслироваться в общую форму (которая становится формой вывода).</target>
        </trans-unit>
        <trans-unit id="ab411408fbd29ad68b53700b2e7826c03e6703f0" translate="yes" xml:space="preserve">
          <source>Logical operations</source>
          <target state="translated">Логические операции</target>
        </trans-unit>
        <trans-unit id="f9360627c5984485d4c34bec86c9dfebc0835bd0" translate="yes" xml:space="preserve">
          <source>Logspace is equivalent to the code</source>
          <target state="translated">Пространство лога эквивалентно коду</target>
        </trans-unit>
        <trans-unit id="05614c0010510d48dea6823d792acc33ba6daeb2" translate="yes" xml:space="preserve">
          <source>Long answer</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cfff3eff895eee45ffb53c164dd9129e264c6241" translate="yes" xml:space="preserve">
          <source>Long arrays can be summarised:</source>
          <target state="translated">Длинные массивы можно суммировать:</target>
        </trans-unit>
        <trans-unit id="8677f57b867596167599f15cd53463b229e648c6" translate="yes" xml:space="preserve">
          <source>Lots of learning overhead:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dcabfd17cd19c7e1ebdad9125ee467aec3f27671" translate="yes" xml:space="preserve">
          <source>Low-level floating point manipulation</source>
          <target state="translated">Низкоуровневая манипуляция с плавающей точкой</target>
        </trans-unit>
        <trans-unit id="20bd4a379661919ac01507844a8735e9e7029b21" translate="yes" xml:space="preserve">
          <source>Low-level function which converts a 16-bit half-precision float into a 32-bit single-precision float, stored as a uint32.</source>
          <target state="translated">Низкоуровневая функция,которая преобразует 16-битный плавающий с половинной точностью в 32-битный одинарный плавающий с одинарной точностью,хранящийся в памяти uint32.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
