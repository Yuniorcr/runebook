<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ru" datatype="htmlbody" original="numpy">
    <body>
      <group id="numpy">
        <trans-unit id="9e26997b358814cca7850a49e412f8a41b34dbe5" translate="yes" xml:space="preserve">
          <source>The floor of each element in &lt;code&gt;x&lt;/code&gt;. This is a scalar if &lt;code&gt;x&lt;/code&gt; is a scalar.</source>
          <target state="translated">Пол каждого элемента в &lt;code&gt;x&lt;/code&gt; . Это скаляр, если &lt;code&gt;x&lt;/code&gt; - скаляр.</target>
        </trans-unit>
        <trans-unit id="eaacb373a79b18f285bd66c2cf0778d5b163c8e7" translate="yes" xml:space="preserve">
          <source>The floor of the scalar &lt;code&gt;x&lt;/code&gt; is the largest integer &lt;code&gt;i&lt;/code&gt;, such that &lt;code&gt;i &amp;lt;= x&lt;/code&gt;. It is often denoted as</source>
          <target state="translated">Нижняя граница скаляра &lt;code&gt;x&lt;/code&gt; - это наибольшее целое число &lt;code&gt;i&lt;/code&gt; такое, что &lt;code&gt;i &amp;lt;= x&lt;/code&gt; . Часто обозначается как</target>
        </trans-unit>
        <trans-unit id="837a298621c37ae4f32158adfb48d3ae2b900f73" translate="yes" xml:space="preserve">
          <source>The fmax is equivalent to &lt;code&gt;np.where(x1 &amp;gt;= x2, x1, x2)&lt;/code&gt; when neither x1 nor x2 are NaNs, but it is faster and does proper broadcasting.</source>
          <target state="translated">Fmax эквивалентен &lt;code&gt;np.where(x1 &amp;gt;= x2, x1, x2)&lt;/code&gt; когда ни x1, ни x2 не являются NaN, но он быстрее и правильно передает.</target>
        </trans-unit>
        <trans-unit id="9192d9bcf4b5d5fc29087b97fc9fad549a45ccf6" translate="yes" xml:space="preserve">
          <source>The fmin is equivalent to &lt;code&gt;np.where(x1 &amp;lt;= x2, x1, x2)&lt;/code&gt; when neither x1 nor x2 are NaNs, but it is faster and does proper broadcasting.</source>
          <target state="translated">Fmin эквивалентно &lt;code&gt;np.where(x1 &amp;lt;= x2, x1, x2)&lt;/code&gt; когда ни x1, ни x2 не являются NaN, но он быстрее и правильно передает.</target>
        </trans-unit>
        <trans-unit id="359ddc84e42e1145c1875abe172377b5b248a4ef" translate="yes" xml:space="preserve">
          <source>The following &lt;code&gt;git config --global&lt;/code&gt; commands:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2933db06c5f57c543942f5ed02bb77ea787c4725" translate="yes" xml:space="preserve">
          <source>The following attributes are used by F2PY:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="26c655f10b13c11e712f57319bac1772cdc5526b" translate="yes" xml:space="preserve">
          <source>The following attributes contain information about the memory layout of the array:</source>
          <target state="translated">Следующие атрибуты содержат информацию о компоновке памяти массива:</target>
        </trans-unit>
        <trans-unit id="245831b050a7f252080c114fea4739c32457bc6e" translate="yes" xml:space="preserve">
          <source>The following code allows us to look at the call sequences and arguments:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b09df459a0ad4a5d7d6218f92cc55900d726085b" translate="yes" xml:space="preserve">
          <source>The following comparison does not raise an exception. There are NaNs in the inputs, but they are in the same positions.</source>
          <target state="translated">Приведенное ниже сравнение не является исключением.На входах есть NaN,но они находятся в тех же позициях.</target>
        </trans-unit>
        <trans-unit id="25c3aeb47ccb54f3895f28756398a03c01d886f7" translate="yes" xml:space="preserve">
          <source>The following corresponds to the usual functions except that nans are excluded from the results:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="367c359a19964728c01ac0e57fac7d66168d5b07" translate="yes" xml:space="preserve">
          <source>The following data types are &lt;strong&gt;flexible&lt;/strong&gt;: they have no predefined size and the data they describe can be of different length in different arrays. (In the character codes &lt;code&gt;#&lt;/code&gt; is an integer denoting how many elements the data type consists of.)</source>
          <target state="translated">Следующие типы данных являются &lt;strong&gt;гибкими&lt;/strong&gt; : у них нет предопределенного размера, и данные, которые они описывают, могут иметь разную длину в разных массивах. (В кодах символов &lt;code&gt;#&lt;/code&gt; - целое число, обозначающее, из скольких элементов состоит тип данных.)</target>
        </trans-unit>
        <trans-unit id="87cc18e3bbbb39d0641f0c5e5f7aaba73b3bfa17" translate="yes" xml:space="preserve">
          <source>The following example checks that &lt;code&gt;a * a+ * a == a&lt;/code&gt; and &lt;code&gt;a+ * a * a+ == a+&lt;/code&gt;:</source>
          <target state="translated">В следующем примере проверяется, что &lt;code&gt;a * a+ * a == a&lt;/code&gt; и &lt;code&gt;a+ * a * a+ == a+&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="da726617ef56fc847d878f222531de4392ef5079" translate="yes" xml:space="preserve">
          <source>The following example demonstrates that operations on this particular dtype requires Python C-API.</source>
          <target state="translated">Следующий пример демонстрирует,что для работы с этим конкретным d-типом требуется Python C-API.</target>
        </trans-unit>
        <trans-unit id="bff8fe87ad1b3faab42fa78be47af40e14a3cdee" translate="yes" xml:space="preserve">
          <source>The following example illustrates how to add user-defined variables to a F2PY generated extension module. Given the following signature file</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="601636ce271dc6c59652a4b9ca1697d0ffc34977" translate="yes" xml:space="preserve">
          <source>The following example shows how you might write a wrapper that accepts two input arguments (that will be converted to an array) and an output argument (that must be an array). The function returns None and updates the output array. Note the updated use of WRITEBACKIFCOPY semantics for NumPy v1.14 and above</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9274fe878c5628b41be8c56553474b2bf993bdb4" translate="yes" xml:space="preserve">
          <source>The following import conventions are used throughout the NumPy source and documentation:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6a11277817c1922ff80f9328abde5fde7dba14c8" translate="yes" xml:space="preserve">
          <source>The following is equivalent to &lt;code&gt;x[:, np.newaxis]&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c9a4cf52932022adac50e43fe76bc932e82c5751" translate="yes" xml:space="preserve">
          <source>The following is equivalent to &lt;code&gt;x[np.newaxis, :]&lt;/code&gt; or &lt;code&gt;x[np.newaxis]&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c7cc30376235469e66891b8aa9bb0978b2dc2799" translate="yes" xml:space="preserve">
          <source>The following is equivalent to &lt;code&gt;x[np.newaxis,:]&lt;/code&gt; or &lt;code&gt;x[np.newaxis]&lt;/code&gt;:</source>
          <target state="translated">Следующее эквивалентно &lt;code&gt;x[np.newaxis,:]&lt;/code&gt; или &lt;code&gt;x[np.newaxis]&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="8b1e13d507d651c25d5c30d03b160ce21c4df709" translate="yes" xml:space="preserve">
          <source>The following is probably true, given that 0.6 is roughly twice the standard deviation:</source>
          <target state="translated">Вероятно,это так,учитывая,что 0,6 примерно в два раза больше стандартного отклонения:</target>
        </trans-unit>
        <trans-unit id="abb45d568d4c1dc6b1960772da10fbcd2d6bd4ca" translate="yes" xml:space="preserve">
          <source>The following keys are allowed:</source>
          <target state="translated">Допускаются следующие ключи:</target>
        </trans-unit>
        <trans-unit id="c7e7738746294a7939f873df246ce33769c08494" translate="yes" xml:space="preserve">
          <source>The following math constants are available in &lt;code&gt;npy_math.h&lt;/code&gt;. Single and extended precision are also available by adding the &lt;code&gt;f&lt;/code&gt; and &lt;code&gt;l&lt;/code&gt; suffixes respectively.</source>
          <target state="translated">Следующие математические константы доступны в &lt;code&gt;npy_math.h&lt;/code&gt; . Одинарная и увеличенная точность также доступны при добавлении суффиксов &lt;code&gt;f&lt;/code&gt; и &lt;code&gt;l&lt;/code&gt; соответственно.</target>
        </trans-unit>
        <trans-unit id="18400fc6ad0ef15f4b4b9f40c34d77a0b29576fd" translate="yes" xml:space="preserve">
          <source>The following methods can be used to access information about the mask or to manipulate the mask.</source>
          <target state="translated">Следующие методы могут быть использованы для доступа к информации о маске или для манипулирования маской.</target>
        </trans-unit>
        <trans-unit id="a7a27e2b2ff01b711d127c91926b8f2614c9b919" translate="yes" xml:space="preserve">
          <source>The following methods implement the pickle protocol:</source>
          <target state="translated">Следующие методы реализуют протокол маринованных огурцов:</target>
        </trans-unit>
        <trans-unit id="ebfae704e1370f3e45632884fb2aa5f3e6615469" translate="yes" xml:space="preserve">
          <source>The following new &lt;code&gt;distutils&lt;/code&gt; commands are defined:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3e142b98cf4f076b7f9b0cce4a8911bba92433dc" translate="yes" xml:space="preserve">
          <source>The following norms can be calculated:</source>
          <target state="translated">Могут быть рассчитаны следующие нормы:</target>
        </trans-unit>
        <trans-unit id="7d6f7c16ce7db4761de0d3a2abd525b89c4146e9" translate="yes" xml:space="preserve">
          <source>The following predefined named repeat rules are available:</source>
          <target state="translated">Доступны следующие предопределенные именованные правила повторения:</target>
        </trans-unit>
        <trans-unit id="de855448328b5e9f80cc8ce9168a701f985757d7" translate="yes" xml:space="preserve">
          <source>The following rules apply:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cb0a5d55704a6c767182c6ac613e21ec8fe0f334" translate="yes" xml:space="preserve">
          <source>The following sections list commonly reported issues depending on your setup. If you have an issue/solution that you think should appear please open a NumPy issue so that it will be added.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="35ff8f470befc9ac72d0ecaaff54cadb612acf70" translate="yes" xml:space="preserve">
          <source>The following steps are repeated for the beta(s), release candidates(s) and the final release.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2238114e4622f64961aa457707939beca3d22430" translate="yes" xml:space="preserve">
          <source>The form of each element of the files sequence is very flexible allowing many combinations of where to get the files from the package and where they should ultimately be installed on the system. The most basic usage is for an element of the files argument sequence to be a simple filename. This will cause that file from the local path to be installed to the installation path of the self.name package (package path). The file argument can also be a relative path in which case the entire relative path will be installed into the package directory. Finally, the file can be an absolute path name in which case the file will be found at the absolute path name but installed to the package path.</source>
          <target state="translated">Форма каждого элемента последовательности файлов очень гибкая,что позволяет использовать множество комбинаций,где взять файлы из пакета,и где они в конечном итоге должны быть установлены в системе.Самое основное использование заключается в том,чтобы элемент последовательности аргументов файлов был простым именем файла.Это приведет к тому,что этот файл из локального пути будет установлен в установочный путь пакета self.name (путь к пакету).Аргументом файла также может быть относительный путь,и в этом случае весь относительный путь будет установлен в каталог пакетов.Наконец,файл может быть абсолютным именем пути-в этом случае файл будет найден по абсолютному имени пути,но установлен по пути к пакету.</target>
        </trans-unit>
        <trans-unit id="7343176dc74f7dbd7af11c9825b614f0b44c3446" translate="yes" xml:space="preserve">
          <source>The formal syntax of signatures is as follows:</source>
          <target state="translated">Формальный синтаксис подписей выглядит следующим образом:</target>
        </trans-unit>
        <trans-unit id="9dfcbb2acec4cf5d146ee3b9671f0f8af54935b6" translate="yes" xml:space="preserve">
          <source>The format description, either specified as a string with comma-separated format descriptions in the form &lt;code&gt;'f8, i4, a5'&lt;/code&gt;, or a list of format description strings in the form &lt;code&gt;['f8', 'i4', 'a5']&lt;/code&gt;.</source>
          <target state="translated">Описание формата, заданное либо в виде строки с разделенными запятыми описаниями формата в форме &lt;code&gt;'f8, i4, a5'&lt;/code&gt; , либо в виде списка строк описания формата в форме &lt;code&gt;['f8', 'i4', 'a5']&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8d7571d646719e6a89afce2ffa8ca97d9a9e64da" translate="yes" xml:space="preserve">
          <source>The format is that required by the &amp;lsquo;descr&amp;rsquo; key in the &lt;code&gt;__array_interface__&lt;/code&gt; attribute.</source>
          <target state="translated">Формат - это тот, который требуется ключом &lt;code&gt;__array_interface__&lt;/code&gt; атрибуте __array_interface__ .</target>
        </trans-unit>
        <trans-unit id="8a1e4bed9460777336f2b104636d1f996f032590" translate="yes" xml:space="preserve">
          <source>The format of these binary file types is documented in &lt;a href=&quot;generated/numpy.lib.format#module-numpy.lib.format&quot;&gt;&lt;code&gt;numpy.lib.format&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">Формат этих двоичных типов файлов задокументирован в &lt;a href=&quot;generated/numpy.lib.format#module-numpy.lib.format&quot;&gt; &lt;code&gt;numpy.lib.format&lt;/code&gt; .&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="ab7733aff55a201beeb5e33bad2c1efefa91a712" translate="yes" xml:space="preserve">
          <source>The forward 2-dimensional FFT, of which &lt;a href=&quot;#numpy.fft.ifft2&quot;&gt;&lt;code&gt;ifft2&lt;/code&gt;&lt;/a&gt; is the inverse.</source>
          <target state="translated">&lt;a href=&quot;#numpy.fft.ifft2&quot;&gt; &lt;code&gt;ifft2&lt;/code&gt; &lt;/a&gt; 2-мерное БПФ, которому ifft2 является обратным.</target>
        </trans-unit>
        <trans-unit id="0bd56e9c9eb1ee54cf6d17ca53e59f27e56218bd" translate="yes" xml:space="preserve">
          <source>The forward &lt;em&gt;n&lt;/em&gt;-dimensional FFT, of which &lt;a href=&quot;#numpy.fft.ifftn&quot;&gt;&lt;code&gt;ifftn&lt;/code&gt;&lt;/a&gt; is the inverse.</source>
          <target state="translated">Вперед &lt;em&gt;п&lt;/em&gt; - мерное БПФ, из которых &lt;a href=&quot;#numpy.fft.ifftn&quot;&gt; &lt;code&gt;ifftn&lt;/code&gt; &lt;/a&gt; является обратным.</target>
        </trans-unit>
        <trans-unit id="aeabce19c51398cd914249fe750519a8327c3674" translate="yes" xml:space="preserve">
          <source>The forward n-dimensional FFT of real input, of which &lt;a href=&quot;numpy.fft.ifftn#numpy.fft.ifftn&quot;&gt;&lt;code&gt;ifftn&lt;/code&gt;&lt;/a&gt; is the inverse.</source>
          <target state="translated">&lt;a href=&quot;numpy.fft.ifftn#numpy.fft.ifftn&quot;&gt; &lt;code&gt;ifftn&lt;/code&gt; &lt;/a&gt; n-мерное БПФ реального ввода, для которого ifftn является обратным.</target>
        </trans-unit>
        <trans-unit id="86b261d0d21cfe3b6b89e72eae8348c6f9559d44" translate="yes" xml:space="preserve">
          <source>The foundations of Project governance are:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="61a4038ee203c584eee7f06e34f73b9e221966a9" translate="yes" xml:space="preserve">
          <source>The four core distributions (&lt;a href=&quot;generated/numpy.random.generator.random#numpy.random.Generator.random&quot;&gt;&lt;code&gt;random&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;generated/numpy.random.generator.standard_normal#numpy.random.Generator.standard_normal&quot;&gt;&lt;code&gt;standard_normal&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;generated/numpy.random.generator.standard_exponential#numpy.random.Generator.standard_exponential&quot;&gt;&lt;code&gt;standard_exponential&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;generated/numpy.random.generator.standard_gamma#numpy.random.Generator.standard_gamma&quot;&gt;&lt;code&gt;standard_gamma&lt;/code&gt;&lt;/a&gt;) all allow existing arrays to be filled using the &lt;code&gt;out&lt;/code&gt; keyword argument. Existing arrays need to be contiguous and well-behaved (writable and aligned). Under normal circumstances, arrays created using the common constructors such as &lt;a href=&quot;../generated/numpy.empty#numpy.empty&quot;&gt;&lt;code&gt;numpy.empty&lt;/code&gt;&lt;/a&gt; will satisfy these requirements.</source>
          <target state="translated">Все четыре основных распределения ( &lt;a href=&quot;generated/numpy.random.generator.random#numpy.random.Generator.random&quot;&gt; &lt;code&gt;random&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;generated/numpy.random.generator.standard_normal#numpy.random.Generator.standard_normal&quot;&gt; &lt;code&gt;standard_normal&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;generated/numpy.random.generator.standard_exponential#numpy.random.Generator.standard_exponential&quot;&gt; &lt;code&gt;standard_exponential&lt;/code&gt; &lt;/a&gt; и &lt;a href=&quot;generated/numpy.random.generator.standard_gamma#numpy.random.Generator.standard_gamma&quot;&gt; &lt;code&gt;standard_gamma&lt;/code&gt; &lt;/a&gt; ) позволяют заполнять существующие массивы с использованием аргумента ключевого слова &lt;code&gt;out&lt;/code&gt; . Существующие массивы должны быть непрерывными и хорошо управляемыми (доступными для записи и выровненными). В нормальных условиях массивы, созданные с использованием общих конструкторов, таких как &lt;a href=&quot;../generated/numpy.empty#numpy.empty&quot;&gt; &lt;code&gt;numpy.empty&lt;/code&gt; &lt;/a&gt; , удовлетворяют этим требованиям.</target>
        </trans-unit>
        <trans-unit id="4e18095a7950042b568262a2f1c7ea1be5258e8f" translate="yes" xml:space="preserve">
          <source>The four values listed above correspond to the number of columns in your array. With a four-column array, you will get four values as your result.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6b6b0ab0e6259043a789c7cdf6069c9981b5ed51" translate="yes" xml:space="preserve">
          <source>The fourth-order derivative of a 3rd-order polynomial is zero:</source>
          <target state="translated">Производная четвертого порядка полинома третьего порядка равна нулю:</target>
        </trans-unit>
        <trans-unit id="61efc608056775e101326edefdfb5b3e50b42207" translate="yes" xml:space="preserve">
          <source>The fractional and integral parts are negative if the given number is negative.</source>
          <target state="translated">Дробная и интегральная части отрицательны,если заданное число отрицательное.</target>
        </trans-unit>
        <trans-unit id="8a03fbb591756592459d393e8bbc5d2c3b77111d" translate="yes" xml:space="preserve">
          <source>The function &lt;a href=&quot;#numpy.lib.recfunctions.repack_fields&quot;&gt;&lt;code&gt;numpy.lib.recfunctions.repack_fields&lt;/code&gt;&lt;/a&gt; can always be used to reproduce the old behavior, as it will return a packed copy of the structured array. The code above, for example, can be replaced with:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a275d8e4e1eb223479714f496979856366e2451a" translate="yes" xml:space="preserve">
          <source>The function &lt;a href=&quot;#numpy.random.default_rng&quot;&gt;&lt;code&gt;numpy.random.default_rng&lt;/code&gt;&lt;/a&gt; will instantiate a &lt;a href=&quot;#numpy.random.Generator&quot;&gt;&lt;code&gt;Generator&lt;/code&gt;&lt;/a&gt; with numpy&amp;rsquo;s default &lt;a href=&quot;bit_generators/generated/numpy.random.bitgenerator#numpy.random.BitGenerator&quot;&gt;&lt;code&gt;BitGenerator&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3162acb71296218159c712934b3730fe102cab75" translate="yes" xml:space="preserve">
          <source>The function &lt;a href=&quot;#numpy.random.default_rng&quot;&gt;&lt;code&gt;numpy.random.default_rng&lt;/code&gt;&lt;/a&gt; will instantiate a &lt;a href=&quot;#numpy.random.Generator&quot;&gt;&lt;code&gt;Generator&lt;/code&gt;&lt;/a&gt; with numpy&amp;rsquo;s default &lt;code&gt;BitGenerator&lt;/code&gt;.</source>
          <target state="translated">Функция &lt;a href=&quot;#numpy.random.default_rng&quot;&gt; &lt;code&gt;numpy.random.default_rng&lt;/code&gt; &lt;/a&gt; создаст экземпляр &lt;a href=&quot;#numpy.random.Generator&quot;&gt; &lt;code&gt;Generator&lt;/code&gt; &lt;/a&gt; с BitGenerator по умолчанию &lt;code&gt;BitGenerator&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2a8219757277659dda8af10246595348c539cf3e" translate="yes" xml:space="preserve">
          <source>The function &lt;a href=&quot;../reference/c-api/array#c.PyArray_RemoveSmallest&quot;&gt;&lt;code&gt;PyArray_RemoveSmallest&lt;/code&gt;&lt;/a&gt; ( &lt;code&gt;multi&lt;/code&gt; ) can be used to take a multi-iterator object and adjust all the iterators so that iteration does not take place over the largest dimension (it makes that dimension of size 1). The code being looped over that makes use of the pointers will very-likely also need the strides data for each of the iterators. This information is stored in multi-&amp;gt;iters[i]-&amp;gt;strides.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9aca3baefb770d49123ec449717dbfcad5a619a9" translate="yes" xml:space="preserve">
          <source>The function &lt;a href=&quot;../reference/generated/numpy.column_stack#numpy.column_stack&quot;&gt;&lt;code&gt;column_stack&lt;/code&gt;&lt;/a&gt; stacks 1D arrays as columns into a 2D array. It is equivalent to &lt;a href=&quot;../reference/generated/numpy.hstack#numpy.hstack&quot;&gt;&lt;code&gt;hstack&lt;/code&gt;&lt;/a&gt; only for 2D arrays:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ada915777af34962f5a155b7336d9374672697e6" translate="yes" xml:space="preserve">
          <source>The function &lt;a href=&quot;generated/numpy.busday_offset#numpy.busday_offset&quot;&gt;&lt;code&gt;busday_offset&lt;/code&gt;&lt;/a&gt; allows you to apply offsets specified in business days to datetimes with a unit of &amp;lsquo;D&amp;rsquo; (day).</source>
          <target state="translated">Функция &lt;a href=&quot;generated/numpy.busday_offset#numpy.busday_offset&quot;&gt; &lt;code&gt;busday_offset&lt;/code&gt; &lt;/a&gt; позволяет применять смещения, указанные в рабочих днях, к дате и времени с единицей измерения &amp;laquo;D&amp;raquo; (день).</target>
        </trans-unit>
        <trans-unit id="b326cd579834eae17571b08e2103d37d7f1ef376" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;gun&lt;/code&gt; may return any number of objects as a tuple. Then following rules are applied:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="23e4e84916821d7380bf310d4fe3bd37497cc290" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;zeros&lt;/code&gt; creates an array full of zeros, the function &lt;code&gt;ones&lt;/code&gt; creates an array full of ones, and the function &lt;code&gt;empty&lt;/code&gt; creates an array whose initial content is random and depends on the state of the memory. By default, the dtype of the created array is &lt;code&gt;float64&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="96d8a0725df6e95677a6e264d7cb37fa566a8b73" translate="yes" xml:space="preserve">
          <source>The function assumes that the number of dimensions of &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; are the same, if necessary prepending the smallest with ones. If &lt;code&gt;a.shape = (r0,r1,..,rN)&lt;/code&gt; and &lt;code&gt;b.shape = (s0,s1,&amp;hellip;,sN)&lt;/code&gt;, the Kronecker product has shape &lt;code&gt;(r0*s0, r1*s1, &amp;hellip;, rN*SN)&lt;/code&gt;. The elements are products of elements from &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt;, organized explicitly by:</source>
          <target state="translated">Функция предполагает, что количество измерений &lt;code&gt;a&lt;/code&gt; и &lt;code&gt;b&lt;/code&gt; одинаково, при необходимости добавляя единицы к наименьшему. Если &lt;code&gt;a.shape = (r0,r1,..,rN)&lt;/code&gt; и &lt;code&gt;b.shape = (s0,s1,&amp;hellip;,sN)&lt;/code&gt; , произведение Кронекера имеет форму &lt;code&gt;(r0*s0, r1*s1, &amp;hellip;, rN*SN)&lt;/code&gt; . Элементы - это продукты элементов из &lt;code&gt;a&lt;/code&gt; и &lt;code&gt;b&lt;/code&gt; , явно организованные следующим образом:</target>
        </trans-unit>
        <trans-unit id="af59a6369749b3cb0f9764af498a65709d68b13e" translate="yes" xml:space="preserve">
          <source>The function has a mean of</source>
          <target state="translated">Функция имеет значение</target>
        </trans-unit>
        <trans-unit id="054f865aa3416e437e5f93f6d6b344a94ea0192f" translate="yes" xml:space="preserve">
          <source>The function has its peak (the mode) at</source>
          <target state="translated">Функция имеет пиковый уровень (режим)на отметке</target>
        </trans-unit>
        <trans-unit id="6069aba02c2ff9e33d0e7ae153f4ba83da37a833" translate="yes" xml:space="preserve">
          <source>The function has its peak at the mean, and its &amp;ldquo;spread&amp;rdquo; increases with the standard deviation (the function reaches 0.607 times its maximum at</source>
          <target state="translated">Функция имеет свой пик в среднем, а ее &amp;laquo;разброс&amp;raquo; увеличивается со стандартным отклонением (функция достигает 0,607 раза от своего максимума при</target>
        </trans-unit>
        <trans-unit id="3aafd01a0784838ff12d9b42abaea56f0c51d8d3" translate="yes" xml:space="preserve">
          <source>The function has zeroes where the angle is a multiple of</source>
          <target state="translated">Функция имеет нули,где угол кратен</target>
        </trans-unit>
        <trans-unit id="8224b60c460c6d30ff461ee22df630041e59b82c" translate="yes" xml:space="preserve">
          <source>The function is accessed as an attribute of or an item from the loaded shared-library. Thus, if &lt;code&gt;./mylib.so&lt;/code&gt; has a function named &lt;code&gt;cool_function1&lt;/code&gt;, I could access this function either as:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fafbcce3a94cb5de2e94d10e8bc93622f1a9c81d" translate="yes" xml:space="preserve">
          <source>The function is also useful for computing some kinds of days like holidays. In Canada and the U.S., Mother&amp;rsquo;s day is on the second Sunday in May, which can be computed with a custom weekmask.</source>
          <target state="translated">Эта функция также полезна для вычисления некоторых типов дней, например праздников. В Канаде и США День матери приходится на второе воскресенье мая, что можно вычислить с помощью специальной маски недели.</target>
        </trans-unit>
        <trans-unit id="67cb306690132e9cba2500b1fa7de5410b4f5260" translate="yes" xml:space="preserve">
          <source>The function is applied to both the _data and the _mask, if any.</source>
          <target state="translated">Функция применяется как к _данным,так и к маске _,если таковая имеется.</target>
        </trans-unit>
        <trans-unit id="da183d0fc1832c644fcb348cf07cf8e31326309a" translate="yes" xml:space="preserve">
          <source>The function is called with N parameters, where N is the rank of &lt;a href=&quot;numpy.ma.shape#numpy.ma.shape&quot;&gt;&lt;code&gt;shape&lt;/code&gt;&lt;/a&gt;. Each parameter represents the coordinates of the array varying along a specific axis. For example, if &lt;a href=&quot;numpy.ma.shape#numpy.ma.shape&quot;&gt;&lt;code&gt;shape&lt;/code&gt;&lt;/a&gt; were &lt;code&gt;(2, 2)&lt;/code&gt;, then the parameters would be &lt;code&gt;array([[0, 0], [1, 1]])&lt;/code&gt; and &lt;code&gt;array([[0, 1], [0, 1]])&lt;/code&gt;</source>
          <target state="translated">Функция вызывается с N параметрами, где N - ранг &lt;a href=&quot;numpy.ma.shape#numpy.ma.shape&quot;&gt; &lt;code&gt;shape&lt;/code&gt; &lt;/a&gt; . Каждый параметр представляет собой координаты массива, меняющиеся вдоль определенной оси. Например, если бы &lt;a href=&quot;numpy.ma.shape#numpy.ma.shape&quot;&gt; &lt;code&gt;shape&lt;/code&gt; &lt;/a&gt; была &lt;code&gt;(2, 2)&lt;/code&gt; , то параметрами были бы &lt;code&gt;array([[0, 0], [1, 1]])&lt;/code&gt; и &lt;code&gt;array([[0, 1], [0, 1]])&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="0f3d30cf3098994de825e7f6bde3ab7173788815" translate="yes" xml:space="preserve">
          <source>The function is called with N parameters, where N is the rank of &lt;a href=&quot;numpy.shape#numpy.shape&quot;&gt;&lt;code&gt;shape&lt;/code&gt;&lt;/a&gt;. Each parameter represents the coordinates of the array varying along a specific axis. For example, if &lt;a href=&quot;numpy.shape#numpy.shape&quot;&gt;&lt;code&gt;shape&lt;/code&gt;&lt;/a&gt; were &lt;code&gt;(2, 2)&lt;/code&gt;, then the parameters would be &lt;code&gt;array([[0, 0], [1, 1]])&lt;/code&gt; and &lt;code&gt;array([[0, 1], [0, 1]])&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d612a9af75e269601691ae7eb90f682a5b996713" translate="yes" xml:space="preserve">
          <source>The function is called with N parameters, where N is the rank of &lt;code&gt;shape&lt;/code&gt;. Each parameter represents the coordinates of the array varying along a specific axis. For example, if &lt;code&gt;shape&lt;/code&gt; were &lt;code&gt;(2, 2)&lt;/code&gt;, then the parameters would be &lt;code&gt;array([[0, 0], [1, 1]])&lt;/code&gt; and &lt;code&gt;array([[0, 1], [0, 1]])&lt;/code&gt;</source>
          <target state="translated">Функция вызывается с N параметрами, где N - ранг &lt;code&gt;shape&lt;/code&gt; . Каждый параметр представляет собой координаты массива, меняющиеся вдоль определенной оси. Например, если бы &lt;code&gt;shape&lt;/code&gt; была &lt;code&gt;(2, 2)&lt;/code&gt; , то параметрами были бы &lt;code&gt;array([[0, 0], [1, 1]])&lt;/code&gt; и &lt;code&gt;array([[0, 1], [0, 1]])&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="5020746e9a28c81bea9ebded1052af0dc8ae2dc6" translate="yes" xml:space="preserve">
          <source>The function is included as an argument to the python function call to the Fortran subroutine even though it was &lt;em&gt;not&lt;/em&gt; in the Fortran subroutine argument list. The &amp;ldquo;external&amp;rdquo; refers to the C function generated by f2py, not the python function itself. The python function must be supplied to the C function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8addd0f39cba25bd912a60b0fb5434bfd595dbe3" translate="yes" xml:space="preserve">
          <source>The function pointer type for NpyAuxData clone functions. These functions should never set the Python exception on error, because they may be called from a multi-threaded context.</source>
          <target state="translated">Тип указателя функции для функций клонирования NpyAuxData.Эти функции никогда не должны устанавливать исключение Python при ошибке,так как они могут вызываться из многопоточного контекста.</target>
        </trans-unit>
        <trans-unit id="167c7a543d8ccb24656ce9a1687449c4ecfb1950" translate="yes" xml:space="preserve">
          <source>The function pointer type for NpyAuxData free functions.</source>
          <target state="translated">Тип указателя функции для функций,свободных от NpyAuxData.</target>
        </trans-unit>
        <trans-unit id="a328f1fcd0be371ed7460c86c4fd60c08690a1c3" translate="yes" xml:space="preserve">
          <source>The function returns the coefficients of the polynomial</source>
          <target state="translated">Функция возвращает коэффициенты многочлена</target>
        </trans-unit>
        <trans-unit id="56ed9dbe32b58078e6c4979647428ecdfd02c355" translate="yes" xml:space="preserve">
          <source>The function signature is normally found by introspection and displayed by the help function. For some functions (notably those written in C) the signature is not available, so we have to specify it as the first line of the docstring:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f0b123a5d43604d228ff7e22be71c876bc3f213f" translate="yes" xml:space="preserve">
          <source>The function that is called when x and y are omitted</source>
          <target state="translated">Функция,вызываемая при опускании x и y.</target>
        </trans-unit>
        <trans-unit id="292f9d908dc66f70e34640d48dac32f92d8211ec" translate="yes" xml:space="preserve">
          <source>The function to be approximated. It must be a function of a single variable of the form &lt;code&gt;f(x, a, b, c...)&lt;/code&gt;, where &lt;code&gt;a, b, c...&lt;/code&gt; are extra arguments passed in the &lt;code&gt;args&lt;/code&gt; parameter.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e68506a39d4f1164408a473e0014c02732a65744" translate="yes" xml:space="preserve">
          <source>The function to be deprecated.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1ed24e8ca86c415e0834a63e6e6d562c0814371f" translate="yes" xml:space="preserve">
          <source>The function to be interpolated. It must be a function of a single variable of the form &lt;code&gt;f(x, a, b, c...)&lt;/code&gt;, where &lt;code&gt;a, b, c...&lt;/code&gt; are extra arguments passed in the &lt;code&gt;args&lt;/code&gt; parameter.</source>
          <target state="translated">Функция, которую нужно интерполировать. Это должна быть функция одной переменной вида &lt;code&gt;f(x, a, b, c...)&lt;/code&gt; , где &lt;code&gt;a, b, c...&lt;/code&gt; - дополнительные аргументы, переданные в параметре &lt;code&gt;args&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="dd5723a1284c8aa8946aa81b4b7601e07d26020c" translate="yes" xml:space="preserve">
          <source>The functionality is based on &lt;a href=&quot;https://docs.python.org/dev/library/os.path.html#os.path.abspath&quot;&gt;&lt;code&gt;os.path.abspath&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Функциональность основана на &lt;a href=&quot;https://docs.python.org/dev/library/os.path.html#os.path.abspath&quot;&gt; &lt;code&gt;os.path.abspath&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="e6e850d04a35d82db7e5c340cdd654a0e7af1cfd" translate="yes" xml:space="preserve">
          <source>The functionality this provides is largely superceded by iterator &lt;a href=&quot;c-api.iterator#c.NpyIter&quot;&gt;&lt;code&gt;NpyIter&lt;/code&gt;&lt;/a&gt; introduced in 1.6, with flag &lt;a href=&quot;c-api.iterator#c.NPY_ITER_COMMON_DTYPE&quot;&gt;&lt;code&gt;NPY_ITER_COMMON_DTYPE&lt;/code&gt;&lt;/a&gt; or with the same dtype parameter for all operands.</source>
          <target state="translated">Функциональные возможности, которые это обеспечивает, в значительной степени &lt;a href=&quot;c-api.iterator#c.NpyIter&quot;&gt; &lt;code&gt;NpyIter&lt;/code&gt; &lt;/a&gt; итератором NpyIter, представленным в 1.6, с флагом &lt;a href=&quot;c-api.iterator#c.NPY_ITER_COMMON_DTYPE&quot;&gt; &lt;code&gt;NPY_ITER_COMMON_DTYPE&lt;/code&gt; &lt;/a&gt; или с тем же параметром dtype для всех операндов.</target>
        </trans-unit>
        <trans-unit id="a07514d8b8d140f4e03babf46c4ca643c0f5e565" translate="yes" xml:space="preserve">
          <source>The functionality this provides is largely superseded by iterator &lt;a href=&quot;iterator#c.NpyIter&quot;&gt;&lt;code&gt;NpyIter&lt;/code&gt;&lt;/a&gt; introduced in 1.6, with flag &lt;a href=&quot;iterator#c.NPY_ITER_COMMON_DTYPE&quot;&gt;&lt;code&gt;NPY_ITER_COMMON_DTYPE&lt;/code&gt;&lt;/a&gt; or with the same dtype parameter for all operands.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2962953aa600a37ce10b761bfc967d43ddef0e3d" translate="yes" xml:space="preserve">
          <source>The functions are named with the following conventions:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9e207dc9abcf693e32399f76b884fbb8a9e3545f" translate="yes" xml:space="preserve">
          <source>The functions called to implement many arithmetic special methods for arrays can be modified using &lt;a href=&quot;arrays.classes#numpy.class.__array_ufunc__&quot;&gt;&lt;code&gt;__array_ufunc__&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Функции, вызываемые для реализации многих специальных арифметических методов для массивов, могут быть изменены с помощью &lt;a href=&quot;arrays.classes#numpy.class.__array_ufunc__&quot;&gt; &lt;code&gt;__array_ufunc__&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="9d8d64b72fb018cdee0e3f01b29eae167f558f81" translate="yes" xml:space="preserve">
          <source>The functions in the shared library are available as attributes of the ctypes library object (returned from &lt;code&gt;ctypeslib.load_library&lt;/code&gt;) or as items using &lt;code&gt;lib['func_name']&lt;/code&gt; syntax. The latter method for retrieving a function name is particularly useful if the function name contains characters that are not allowable in Python variable names.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="df46d6188871c9afe4dd8663a289bd38fe7112b3" translate="yes" xml:space="preserve">
          <source>The functions without &amp;ldquo;standard&amp;rdquo; in their name require additional parameters to describe the distributions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="780f3f42d3ad6d900b31dca5cc39ba44b8433b34" translate="yes" xml:space="preserve">
          <source>The future value is computed by solving the equation:</source>
          <target state="translated">Будущее значение вычисляется путем решения уравнения:</target>
        </trans-unit>
        <trans-unit id="35263bdc6b8f9ed76c3ffddda6ddc106a35e30ef" translate="yes" xml:space="preserve">
          <source>The gains are substantial and the scaling is reasonable even for arrays that are only moderately large. The gains are even larger when compared to a call that does not use an existing array due to array creation overhead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f54d15f1fff04aaad23c1e30a6699255a7286273" translate="yes" xml:space="preserve">
          <source>The gains are substantial and the scaling is reasonable even for large that are only moderately large. The gains are even larger when compared to a call that does not use an existing array due to array creation overhead.</source>
          <target state="translated">Прибыль значительна,а масштабирование разумно даже для крупных,которые лишь умеренно велики.Выигрыш еще больше по сравнению с вызовом,который не использует существующий массив из-за накладных расходов на создание массивов.</target>
        </trans-unit>
        <trans-unit id="3a2348245b14000fc86ba9addf452f0058449713" translate="yes" xml:space="preserve">
          <source>The general concept of broadcasting is also available from Python using the &lt;a href=&quot;generated/numpy.broadcast#numpy.broadcast&quot;&gt;&lt;code&gt;broadcast&lt;/code&gt;&lt;/a&gt; iterator. This object takes</source>
          <target state="translated">Общая концепция широковещательной передачи также доступна в Python с использованием итератора &lt;a href=&quot;generated/numpy.broadcast#numpy.broadcast&quot;&gt; &lt;code&gt;broadcast&lt;/code&gt; &lt;/a&gt; . Этот объект занимает</target>
        </trans-unit>
        <trans-unit id="a9641437007836c208f74db848ac79bd7c6780e6" translate="yes" xml:space="preserve">
          <source>The generated file will have the following content:</source>
          <target state="translated">Генерируемый файл будет иметь следующее содержание:</target>
        </trans-unit>
        <trans-unit id="1a1433c2f9219adfdc1717ee54946e456e115a63" translate="yes" xml:space="preserve">
          <source>The generated random samples</source>
          <target state="translated">Сгенерированные случайные образцы</target>
        </trans-unit>
        <trans-unit id="770d667a086582311721a20b1950124d0ed2b0b8" translate="yes" xml:space="preserve">
          <source>The generic hierarchical type objects convert to corresponding type objects according to the associations:</source>
          <target state="translated">Общие объекты иерархического типа конвертируются в соответствующие объекты типа в соответствии с ассоциациями:</target>
        </trans-unit>
        <trans-unit id="7b9da9a1e497b53c1498ef8728ff28c753a44590" translate="yes" xml:space="preserve">
          <source>The given decorator is applied to all public methods of &lt;code&gt;cls&lt;/code&gt; that are matched by the regular expression &lt;code&gt;testmatch&lt;/code&gt; (&lt;code&gt;testmatch.search(methodname)&lt;/code&gt;). Methods that are private, i.e. start with an underscore, are ignored.</source>
          <target state="translated">Данный декоратор применяется ко всем общедоступным методам &lt;code&gt;cls&lt;/code&gt; , которым соответствует регулярное выражение &lt;code&gt;testmatch&lt;/code&gt; ( &lt;code&gt;testmatch.search(methodname)&lt;/code&gt; ). Частные методы, то есть начинающиеся с подчеркивания, игнорируются.</target>
        </trans-unit>
        <trans-unit id="d15ec8784a28b893c0b85001548e5baae80372c7" translate="yes" xml:space="preserve">
          <source>The gradient is computed using second order accurate central differences in the interior points and either first or second order accurate one-sides (forward or backwards) differences at the boundaries. The returned gradient hence has the same shape as the input array.</source>
          <target state="translated">Градиент рассчитывается с использованием точных центральных разностей второго порядка в внутренних точках и точных односторонних (вперед или назад)разностей первого или второго порядка на границах.Таким образом,возвращаемый градиент имеет ту же форму,что и входной массив.</target>
        </trans-unit>
        <trans-unit id="2b74e85f5516f60e3dbf421bf49f69c39506c265" translate="yes" xml:space="preserve">
          <source>The greatest common divisor</source>
          <target state="translated">Величайший общий делитель</target>
        </trans-unit>
        <trans-unit id="1335775c2defd62ddac3bf62f622a970f395fc71" translate="yes" xml:space="preserve">
          <source>The greatest common divisor of the absolute value of the inputs This is a scalar if both &lt;code&gt;x1&lt;/code&gt; and &lt;code&gt;x2&lt;/code&gt; are scalars.</source>
          <target state="translated">Наибольший общий делитель абсолютного значения входных данных. Это скаляр, если и &lt;code&gt;x1&lt;/code&gt; , и &lt;code&gt;x2&lt;/code&gt; являются скалярами.</target>
        </trans-unit>
        <trans-unit id="1ffad58d21fbb0c889485660c6a73c057db064f2" translate="yes" xml:space="preserve">
          <source>The header file &amp;lt;numpy/halffloat.h&amp;gt; provides functions to work with IEEE 754-2008 16-bit floating point values. While this format is not typically used for numerical computations, it is useful for storing values which require floating point but do not need much precision. It can also be used as an educational tool to understand the nature of floating point round-off error.</source>
          <target state="translated">Заголовочный файл &amp;lt;numpy / halffloat.h&amp;gt; предоставляет функции для работы с 16-битными значениями с плавающей запятой IEEE 754-2008. Хотя этот формат обычно не используется для численных вычислений, он полезен для хранения значений, требующих плавающей запятой, но не требующих особой точности. Его также можно использовать в качестве обучающего инструмента для понимания природы ошибки округления с плавающей запятой.</target>
        </trans-unit>
        <trans-unit id="d730bb14ffcab30f2844567d44182ca5b3af1815" translate="yes" xml:space="preserve">
          <source>The header of a typical SciPy &lt;code&gt;__init__.py&lt;/code&gt; is:</source>
          <target state="translated">Заголовок типичного SciPy &lt;code&gt;__init__.py&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="881c9d2e47b4057e556e6ff5df02bfb9e5dee04c" translate="yes" xml:space="preserve">
          <source>The highest precision data type of the same kind (&lt;a href=&quot;numpy.dtype.kind#numpy.dtype.kind&quot;&gt;&lt;code&gt;dtype.kind&lt;/code&gt;&lt;/a&gt;) as &lt;code&gt;t&lt;/code&gt;.</source>
          <target state="translated">Тип данных наивысшей точности того же типа ( &lt;a href=&quot;numpy.dtype.kind#numpy.dtype.kind&quot;&gt; &lt;code&gt;dtype.kind&lt;/code&gt; &lt;/a&gt; ), что и &lt;code&gt;t&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f28aa2c9365c3014c1b3133bf8c0527b1b6cd92f" translate="yes" xml:space="preserve">
          <source>The hyperbolic cosine describes the shape of a hanging cable:</source>
          <target state="translated">Гиперболический косинус описывает форму висячего троса:</target>
        </trans-unit>
        <trans-unit id="5dfe11baf5c84767b263b0b9280dd1d13ec6b531" translate="yes" xml:space="preserve">
          <source>The hypotenuse of the triangle(s). This is a scalar if both &lt;code&gt;x1&lt;/code&gt; and &lt;code&gt;x2&lt;/code&gt; are scalars.</source>
          <target state="translated">Гипотенуза треугольника (ов). Это скаляр, если и &lt;code&gt;x1&lt;/code&gt; , и &lt;code&gt;x2&lt;/code&gt; являются скалярами.</target>
        </trans-unit>
        <trans-unit id="b1216f6dc1a8f133c88cabe04669f3d387166a72" translate="yes" xml:space="preserve">
          <source>The idea is to consider all but the first &lt;code&gt;k&lt;/code&gt; singular values in &lt;code&gt;Sigma&lt;/code&gt; (which are the same as in &lt;code&gt;s&lt;/code&gt;) as zeros, keeping &lt;code&gt;U&lt;/code&gt; and &lt;code&gt;Vt&lt;/code&gt; intact, and computing the product of these matrices as the approximation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a77669c9a72d14b0f58a0186d231f3894219b608" translate="yes" xml:space="preserve">
          <source>The identity array is a square array with ones on the main diagonal.</source>
          <target state="translated">Массив идентификации представляет собой квадратный массив с единицами по главной диагонали.</target>
        </trans-unit>
        <trans-unit id="2bf1c25d751d392b46c1da854b9e2214e84ecbda" translate="yes" xml:space="preserve">
          <source>The identity value.</source>
          <target state="translated">Идентификационная ценность.</target>
        </trans-unit>
        <trans-unit id="a3a4e04cbf529a826b2105546fd57be959a238a1" translate="yes" xml:space="preserve">
          <source>The imaginary component of the complex argument. If &lt;code&gt;val&lt;/code&gt; is real, the type of &lt;code&gt;val&lt;/code&gt; is used for the output. If &lt;code&gt;val&lt;/code&gt; has complex elements, the returned type is float.</source>
          <target state="translated">Мнимая составляющая сложного аргумента. Если &lt;code&gt;val&lt;/code&gt; является действительным, для вывода используется тип &lt;code&gt;val&lt;/code&gt; . Если &lt;code&gt;val&lt;/code&gt; имеет сложные элементы, возвращаемый тип - float.</target>
        </trans-unit>
        <trans-unit id="7286bf711b04d53845d16cb5a31eaaaaa02757bf" translate="yes" xml:space="preserve">
          <source>The imaginary part of the array.</source>
          <target state="translated">Воображаемая часть массива.</target>
        </trans-unit>
        <trans-unit id="9bc674154d61adacb44dda1d44c441449cdf2af6" translate="yes" xml:space="preserve">
          <source>The imaginary part of the masked array.</source>
          <target state="translated">Воображаемая часть массива.</target>
        </trans-unit>
        <trans-unit id="fd6e842a69d72f29a0581eb97a936eaef8759475" translate="yes" xml:space="preserve">
          <source>The implementation of the tests that produce this information.</source>
          <target state="translated">Реализация тестов,которые дают эту информацию.</target>
        </trans-unit>
        <trans-unit id="aee088812e30b5da0a5df1b95d7c39c9c1258247" translate="yes" xml:space="preserve">
          <source>The implementations of multiplication, division, integration, and differentiation use the algebraic identities &lt;a href=&quot;#r3f3efff98d00-1&quot; id=&quot;id1&quot;&gt;[1]&lt;/a&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1e2ea421bf4e67c223dedefb366e2029ced79732" translate="yes" xml:space="preserve">
          <source>The importance that each element has in the computation of the average. The weights array can either be 1-D (in which case its length must be the size of &lt;code&gt;a&lt;/code&gt; along the given axis) or of the same shape as &lt;code&gt;a&lt;/code&gt;. If &lt;code&gt;weights=None&lt;/code&gt;, then all data in &lt;code&gt;a&lt;/code&gt; are assumed to have a weight equal to one. If &lt;code&gt;weights&lt;/code&gt; is complex, the imaginary parts are ignored.</source>
          <target state="translated">Важность каждого элемента при вычислении среднего. Массив весов может быть 1-D (в этом случае его длина должна быть размером &lt;code&gt;a&lt;/code&gt; вдоль данной оси) или &lt;code&gt;a&lt;/code&gt; ту же форму, что и a . Если &lt;code&gt;weights=None&lt;/code&gt; , то предполагается , что все данные в &lt;code&gt;a&lt;/code&gt; имеют вес, равный единице. Если &lt;code&gt;weights&lt;/code&gt; сложные, мнимые части игнорируются.</target>
        </trans-unit>
        <trans-unit id="8b1442547658f9bd4727b8dd9df733953ec22b3e" translate="yes" xml:space="preserve">
          <source>The importance that each element has in the computation of the average. The weights array can either be 1-D (in which case its length must be the size of &lt;code&gt;a&lt;/code&gt; along the given axis) or of the same shape as &lt;code&gt;a&lt;/code&gt;. If &lt;code&gt;weights=None&lt;/code&gt;, then all data in &lt;code&gt;a&lt;/code&gt; are assumed to have a weight equal to one. The 1-D calculation is:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f0f3bacce4854001ee5a2b2337e74219eceafb03" translate="yes" xml:space="preserve">
          <source>The include statement is inserted just before the wrapper functions. This feature enables using arbitrary C functions (defined in &lt;code&gt;&amp;lt;includefile&amp;gt;&lt;/code&gt;) in F2PY generated wrappers.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3e99cfec9384fa0ceb0f339e2c89b3b94a829c5f" translate="yes" xml:space="preserve">
          <source>The included BitGenerators are:</source>
          <target state="translated">В комплект поставки входят битгенераторы:</target>
        </trans-unit>
        <trans-unit id="22391c7101fab8760afe729b1932a0c59fad5983" translate="yes" xml:space="preserve">
          <source>The included generators can be used in parallel, distributed applications in one of three ways:</source>
          <target state="translated">Входящие в комплект генераторы могут использоваться в параллельных распределенных приложениях одним из трех способов:</target>
        </trans-unit>
        <trans-unit id="0d9680eef1c6da704d4a94f1afb86f59c497487e" translate="yes" xml:space="preserve">
          <source>The index array consisting of the values 3, 3, 1 and 8 correspondingly create an array of length 4 (same as the index array) where each index is replaced by the value the index array has in the array being indexed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c31840bf8111dd67b394647308aa4678f4427cf3" translate="yes" xml:space="preserve">
          <source>The index is tracked by the iterator object itself, and accessible through the &lt;code&gt;index&lt;/code&gt; or &lt;code&gt;multi_index&lt;/code&gt; properties, depending on what was requested. The examples below show printouts demonstrating the progression of the index:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b00c25ebce056fd05b5bde5e2e04470c497a8460" translate="yes" xml:space="preserve">
          <source>The index syntax is very powerful but limiting when dealing with a variable number of indices. For example, if you want to write a function that can handle arguments with various numbers of dimensions without having to write special case code for each number of possible dimensions, how can that be done? If one supplies to the index a tuple, the tuple will be interpreted as a list of indices. For example (using the previous definition for the array z):</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2c2a3bfa2d0e12fb3599b918fb58fa555ca8de7c" translate="yes" xml:space="preserve">
          <source>The indexed result.</source>
          <target state="translated">Индексированный результат.</target>
        </trans-unit>
        <trans-unit id="03743182a2227ccf2811c37150a243244da1cf36" translate="yes" xml:space="preserve">
          <source>The indexing works on the flattened target array. &lt;a href=&quot;#numpy.put&quot;&gt;&lt;code&gt;put&lt;/code&gt;&lt;/a&gt; is roughly equivalent to:</source>
          <target state="translated">Индексирование работает с плоским целевым массивом. &lt;a href=&quot;#numpy.put&quot;&gt; &lt;code&gt;put&lt;/code&gt; &lt;/a&gt; примерно эквивалентен:</target>
        </trans-unit>
        <trans-unit id="59838ac2347062b68deb1ef0e067a09f0f1f12f7" translate="yes" xml:space="preserve">
          <source>The indices can be used as an index into an array.</source>
          <target state="translated">Индексы могут быть использованы как индекс в массиве.</target>
        </trans-unit>
        <trans-unit id="41bdc266e504f1b3636c2cdbc5a9368b53208f9c" translate="yes" xml:space="preserve">
          <source>The indices for the triangle. The returned tuple contains two arrays, each with the indices along one dimension of the array.</source>
          <target state="translated">Индексы для треугольника.Возвращаемый кортеж содержит два массива,каждый из которых имеет индексы по одному измерению массива.</target>
        </trans-unit>
        <trans-unit id="083f53a10046b877a4d17cdf8a047cadb142a0a5" translate="yes" xml:space="preserve">
          <source>The indices for the triangle. The returned tuple contains two arrays, each with the indices along one dimension of the array. Can be used to slice a ndarray of shape(&lt;code&gt;n&lt;/code&gt;, &lt;code&gt;n&lt;/code&gt;).</source>
          <target state="translated">Индексы треугольника. Возвращенный кортеж содержит два массива, каждый с индексами по одному измерению массива. Может использоваться для нарезки ndarray формы ( &lt;code&gt;n&lt;/code&gt; , &lt;code&gt;n&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="313bb1645ee0bcc96011930b78001b8efa601b2f" translate="yes" xml:space="preserve">
          <source>The indices of first and last non-masked value in the array. Returns None if all values are masked.</source>
          <target state="translated">Индексы первого и последнего не маскированного значения в массиве.Возвращает None,если все значения маскируются.</target>
        </trans-unit>
        <trans-unit id="02de7d9422fcf4d3bd70015e02df12b6de819fce" translate="yes" xml:space="preserve">
          <source>The indices of the current iteration.</source>
          <target state="translated">Индексы текущей итерации.</target>
        </trans-unit>
        <trans-unit id="caeefd07d81c974d4f02d2a7cd29c00df5d3e970" translate="yes" xml:space="preserve">
          <source>The indices of the first occurrences of the common values in &lt;code&gt;ar1&lt;/code&gt;. Only provided if &lt;code&gt;return_indices&lt;/code&gt; is True.</source>
          <target state="translated">Индексы первых вхождений общих значений в &lt;code&gt;ar1&lt;/code&gt; . Предоставляется, только если &lt;code&gt;return_indices&lt;/code&gt; имеет значение True.</target>
        </trans-unit>
        <trans-unit id="d03a2050722c8950165a7a42c8f8fbec16c8b478" translate="yes" xml:space="preserve">
          <source>The indices of the first occurrences of the common values in &lt;code&gt;ar2&lt;/code&gt;. Only provided if &lt;code&gt;return_indices&lt;/code&gt; is True.</source>
          <target state="translated">Индексы первых вхождений общих значений в &lt;code&gt;ar2&lt;/code&gt; . Предоставляется, только если &lt;code&gt;return_indices&lt;/code&gt; имеет значение True.</target>
        </trans-unit>
        <trans-unit id="dba5b2feac59133a263255144aa942786b75991f" translate="yes" xml:space="preserve">
          <source>The indices of the first occurrences of the unique values in the original array. Only provided if &lt;code&gt;return_index&lt;/code&gt; is True.</source>
          <target state="translated">Индексы первых вхождений уникальных значений в исходный массив. Предоставляется, только если &lt;code&gt;return_index&lt;/code&gt; имеет значение True.</target>
        </trans-unit>
        <trans-unit id="a4f376a3994ea66b3e8fe543f1059936c2c097d7" translate="yes" xml:space="preserve">
          <source>The indices of the matched values can be obtained with &lt;a href=&quot;numpy.nonzero#numpy.nonzero&quot;&gt;&lt;code&gt;nonzero&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">Индексы согласованных значений могут быть получены при &lt;a href=&quot;numpy.nonzero#numpy.nonzero&quot;&gt; &lt;code&gt;nonzero&lt;/code&gt; &lt;/a&gt; значении :</target>
        </trans-unit>
        <trans-unit id="43a87c99c2b28bd6cf46e8003a99b97203e9c8c1" translate="yes" xml:space="preserve">
          <source>The indices of the values to extract.</source>
          <target state="translated">Индексы значений для извлечения.</target>
        </trans-unit>
        <trans-unit id="6ca413808a0cb47ebd7eb463c61ac12f6ed3fe9d" translate="yes" xml:space="preserve">
          <source>The indices to reconstruct the original array from the unique array. Only provided if &lt;code&gt;return_inverse&lt;/code&gt; is True.</source>
          <target state="translated">Индексы для восстановления исходного массива из уникального массива. Предоставляется, только если &lt;code&gt;return_inverse&lt;/code&gt; - True.</target>
        </trans-unit>
        <trans-unit id="76cdf05ced9d0285381afd071b2e4305a0c8b8a1" translate="yes" xml:space="preserve">
          <source>The indices will be valid for square arrays whose dimensions are the same as arr.</source>
          <target state="translated">Индексы будут действительны для квадратных массивов,размеры которых совпадают с размерами arr.</target>
        </trans-unit>
        <trans-unit id="b73635c48b132fb2b59a6aa95f3cc03ac517b9fa" translate="yes" xml:space="preserve">
          <source>The indices will be valid for square arrays.</source>
          <target state="translated">Индексы будут действительны для квадратных массивов.</target>
        </trans-unit>
        <trans-unit id="2408a7bae27e18b5f16ce6bfc6c2e9edbdf96e75" translate="yes" xml:space="preserve">
          <source>The info dict contains the necessary options to use the C library.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1a162a1581bd9df0f0c132b54dd0bc2b023b7fbc" translate="yes" xml:space="preserve">
          <source>The initialized generator object.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b17807d1d3d4b02432b9a563a71fb115959130d3" translate="yes" xml:space="preserve">
          <source>The input &lt;code&gt;a&lt;/code&gt; as a float ndarray.</source>
          <target state="translated">Вход как флоат ndarray. &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="223b4394f2d166cb77455c12d7788790c3301749" translate="yes" xml:space="preserve">
          <source>The input &lt;code&gt;a&lt;/code&gt; in Fortran, or column-major, order.</source>
          <target state="translated">Вход в Fortran или столбцы, заказ. &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="75fd22e41868bea41cd02857931f82382a569f45" translate="yes" xml:space="preserve">
          <source>The input &lt;code&gt;seed&lt;/code&gt; is processed by &lt;a href=&quot;generated/numpy.random.seedsequence#numpy.random.SeedSequence&quot;&gt;&lt;code&gt;SeedSequence&lt;/code&gt;&lt;/a&gt; to generate the key. The counter is set to 0.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="528560fa701c687c766a152165432c7d1064754a" translate="yes" xml:space="preserve">
          <source>The input array</source>
          <target state="translated">Входной массив</target>
        </trans-unit>
        <trans-unit id="c14ffcb4fd955aec9b7bdb6f4e9b85112587e6c8" translate="yes" xml:space="preserve">
          <source>The input array needs to be of integer dtype, otherwise a TypeError is raised:</source>
          <target state="translated">Входной массив должен иметь целочисленный d-тип,иначе поднимается ошибка TypeError:</target>
        </trans-unit>
        <trans-unit id="8ffb9fe9f3741ba95404f548e61803acdf79b642" translate="yes" xml:space="preserve">
          <source>The input array with invalid entries fixed.</source>
          <target state="translated">Исправлен входной массив с недопустимыми входными данными.</target>
        </trans-unit>
        <trans-unit id="729e431a614c3f0d0d957b108e3ad1877caf7dd5" translate="yes" xml:space="preserve">
          <source>The input array&amp;rsquo;s mask is modified by this function.</source>
          <target state="translated">Эта функция изменяет маску входного массива.</target>
        </trans-unit>
        <trans-unit id="2bcc0bcc75499b8aa5923f648739bb1e1c9c5f2a" translate="yes" xml:space="preserve">
          <source>The input array, but with all or a subset of the dimensions of length 1 removed. This is always &lt;code&gt;a&lt;/code&gt; itself or a view into &lt;code&gt;a&lt;/code&gt;.</source>
          <target state="translated">Входной массив, но из него удалены все или часть размеров длины 1. Это всегда сам или вид в . &lt;code&gt;a&lt;/code&gt; &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="f9c1757f1f00139c3d32d32875dc4cdee7e7573b" translate="yes" xml:space="preserve">
          <source>The input array, but with all or a subset of the dimensions of length 1 removed. This is always &lt;code&gt;a&lt;/code&gt; itself or a view into &lt;code&gt;a&lt;/code&gt;. Note that if all axes are squeezed, the result is a 0d array and not a scalar.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3b9eebd6f3c2dccb825ca1eb5d3b6fff39eb990c" translate="yes" xml:space="preserve">
          <source>The input array.</source>
          <target state="translated">Входной массив.</target>
        </trans-unit>
        <trans-unit id="a8dbbfb64079646cc26f949474f62f6d5a8bdb10" translate="yes" xml:space="preserve">
          <source>The input arrays are the coefficients (including any coefficients equal to zero) of the &amp;ldquo;numerator&amp;rdquo; (dividend) and &amp;ldquo;denominator&amp;rdquo; (divisor) polynomials, respectively.</source>
          <target state="translated">Входные массивы - это коэффициенты (включая любые коэффициенты, равные нулю) полиномов &amp;laquo;числитель&amp;raquo; (делимое) и &amp;laquo;знаменатель&amp;raquo; (делитель) соответственно.</target>
        </trans-unit>
        <trans-unit id="a4fe0b89df27127c64e2d6a838fb7376eb328411" translate="yes" xml:space="preserve">
          <source>The input can be of any type and shape.</source>
          <target state="translated">Входной сигнал может быть любого типа и формы.</target>
        </trans-unit>
        <trans-unit id="0756c557e9cd622a4b4a6242d6e56ce5652e83a5" translate="yes" xml:space="preserve">
          <source>The input data type is preserved, list/tuple in means list/tuple out.</source>
          <target state="translated">Сохраняется тип входных данных,список/тройка в списке средств/тройка из списка.</target>
        </trans-unit>
        <trans-unit id="7e65fba32b4c379aee34d72564b929f364329962" translate="yes" xml:space="preserve">
          <source>The input data type. This can be a &lt;a href=&quot;numpy.dtype#numpy.dtype&quot;&gt;&lt;code&gt;dtype&lt;/code&gt;&lt;/a&gt; object or an object that is convertible to a &lt;a href=&quot;numpy.dtype#numpy.dtype&quot;&gt;&lt;code&gt;dtype&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Тип входных данных. Это может быть объект &lt;a href=&quot;numpy.dtype#numpy.dtype&quot;&gt; &lt;code&gt;dtype&lt;/code&gt; &lt;/a&gt; или объект, который можно преобразовать в &lt;a href=&quot;numpy.dtype#numpy.dtype&quot;&gt; &lt;code&gt;dtype&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="8769eb794f5a03165931ba8181e41168fd7a696f" translate="yes" xml:space="preserve">
          <source>The input domain.</source>
          <target state="translated">Входной домен.</target>
        </trans-unit>
        <trans-unit id="8cece683eb84b1c6561cdb1ebf8cbf9f503e743a" translate="yes" xml:space="preserve">
          <source>The input is expected to be in the form returned by &lt;a href=&quot;numpy.fft.rfft#numpy.fft.rfft&quot;&gt;&lt;code&gt;rfft&lt;/code&gt;&lt;/a&gt;, i.e. the real zero-frequency term followed by the complex positive frequency terms in order of increasing frequency. Since the discrete Fourier Transform of real input is Hermitian-symmetric, the negative frequency terms are taken to be the complex conjugates of the corresponding positive frequency terms.</source>
          <target state="translated">Ожидается, что входные данные будут иметь форму, возвращаемую &lt;a href=&quot;numpy.fft.rfft#numpy.fft.rfft&quot;&gt; &lt;code&gt;rfft&lt;/code&gt; &lt;/a&gt; , т. Е. Действительный член с нулевой частотой, за которым следует комплексный член с положительной частотой в порядке увеличения частоты. Поскольку дискретное преобразование Фурье реального входа является эрмитово-симметричным, отрицательные частотные члены считаются комплексно сопряженными соответствующими положительными частотными членами.</target>
        </trans-unit>
        <trans-unit id="6f9750084d20ac908a43842756c2b861e3f42c50" translate="yes" xml:space="preserve">
          <source>The input seed is processed by &lt;a href=&quot;generated/numpy.random.seedsequence#numpy.random.SeedSequence&quot;&gt;&lt;code&gt;SeedSequence&lt;/code&gt;&lt;/a&gt; to fill the whole state. The first element is reset such that only its most significant bit is set.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a8974905180f39b4ffd2915ed945588ac5ab3b98" translate="yes" xml:space="preserve">
          <source>The input seed is processed by &lt;a href=&quot;generated/numpy.random.seedsequence#numpy.random.SeedSequence&quot;&gt;&lt;code&gt;SeedSequence&lt;/code&gt;&lt;/a&gt; to generate both values. The increment is not independently settable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9c7b1d5b6198e399c073a141f7cd1b6b8febb604" translate="yes" xml:space="preserve">
          <source>The input seed is processed by &lt;a href=&quot;generated/numpy.random.seedsequence#numpy.random.SeedSequence&quot;&gt;&lt;code&gt;SeedSequence&lt;/code&gt;&lt;/a&gt; to generate the first 3 values, then the &lt;code&gt;SFC64&lt;/code&gt; algorithm is iterated a small number of times to mix.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8d2a5838e3e88200b2eb57081e0d55983a6951c5" translate="yes" xml:space="preserve">
          <source>The input seed is processed by &lt;code&gt;SeedSequence&lt;/code&gt; to fill the whole state. The first element is reset such that only its most significant bit is set.</source>
          <target state="translated">Входное начальное число обрабатывается &lt;code&gt;SeedSequence&lt;/code&gt; для заполнения всего состояния. Первый элемент сбрасывается так, что устанавливается только его самый старший бит.</target>
        </trans-unit>
        <trans-unit id="b59429801bb072b95be274b2cab8c79cb4d9a0af" translate="yes" xml:space="preserve">
          <source>The input seed is processed by &lt;code&gt;SeedSequence&lt;/code&gt; to generate both values. The increment is not independently settable.</source>
          <target state="translated">Входное начальное число обрабатывается &lt;code&gt;SeedSequence&lt;/code&gt; для генерации обоих значений. Приращение не может быть установлено отдельно.</target>
        </trans-unit>
        <trans-unit id="837326b6e18d83ecb217345cd40ecfada7f873f1" translate="yes" xml:space="preserve">
          <source>The input seed is processed by &lt;code&gt;SeedSequence&lt;/code&gt; to generate the first 3 values, then the &lt;code&gt;SFC64&lt;/code&gt; algorithm is iterated a small number of times to mix.</source>
          <target state="translated">Входное начальное число обрабатывается &lt;code&gt;SeedSequence&lt;/code&gt; для генерации первых 3 значений, затем алгоритм &lt;code&gt;SFC64&lt;/code&gt; повторяется небольшое количество раз для смешивания.</target>
        </trans-unit>
        <trans-unit id="df03e47997abce099faab26366e6f5795a2b583f" translate="yes" xml:space="preserve">
          <source>The input seed is processed by &lt;code&gt;SeedSequence&lt;/code&gt; to generate the key. The counter is set to 0.</source>
          <target state="translated">&lt;code&gt;SeedSequence&lt;/code&gt; значение ввода обрабатывается SeedSequence для генерации ключа. Счетчик установлен на 0.</target>
        </trans-unit>
        <trans-unit id="9065e71c46c758a421d1a5608c4e7515cdea0b0c" translate="yes" xml:space="preserve">
          <source>The input should be ordered in the same way as is returned by &lt;a href=&quot;numpy.fft.fft#numpy.fft.fft&quot;&gt;&lt;code&gt;fft&lt;/code&gt;&lt;/a&gt;, i.e.,</source>
          <target state="translated">Входные данные должны быть упорядочены так же, как и возвращаемые &lt;a href=&quot;numpy.fft.fft#numpy.fft.fft&quot;&gt; &lt;code&gt;fft&lt;/code&gt; &lt;/a&gt; , т. Е.</target>
        </trans-unit>
        <trans-unit id="14cd4f07dbbafbca343da6b376f0bb96ca0ebb1e" translate="yes" xml:space="preserve">
          <source>The input should be ordered in the same way as is returned by &lt;a href=&quot;numpy.fft.rfftn#numpy.fft.rfftn&quot;&gt;&lt;code&gt;rfftn&lt;/code&gt;&lt;/a&gt;, i.e. as for &lt;a href=&quot;numpy.fft.irfft#numpy.fft.irfft&quot;&gt;&lt;code&gt;irfft&lt;/code&gt;&lt;/a&gt; for the final transformation axis, and as for &lt;a href=&quot;numpy.fft.ifftn#numpy.fft.ifftn&quot;&gt;&lt;code&gt;ifftn&lt;/code&gt;&lt;/a&gt; along all the other axes.</source>
          <target state="translated">Входные данные должны быть упорядочены таким же образом, как и возвращаемые &lt;a href=&quot;numpy.fft.rfftn#numpy.fft.rfftn&quot;&gt; &lt;code&gt;rfftn&lt;/code&gt; &lt;/a&gt; , то есть как для &lt;a href=&quot;numpy.fft.irfft#numpy.fft.irfft&quot;&gt; &lt;code&gt;irfft&lt;/code&gt; &lt;/a&gt; для конечной оси преобразования, так и для &lt;a href=&quot;numpy.fft.ifftn#numpy.fft.ifftn&quot;&gt; &lt;code&gt;ifftn&lt;/code&gt; &lt;/a&gt; по всем остальным осям.</target>
        </trans-unit>
        <trans-unit id="44801963410659f1459e257160aa0d4b1ef39ba2" translate="yes" xml:space="preserve">
          <source>The input value(s).</source>
          <target state="translated">Входное(ые)значение(и).</target>
        </trans-unit>
        <trans-unit id="519628f03d9ba5d6ae3260f3b709f32afd6fac80" translate="yes" xml:space="preserve">
          <source>The input, analogously to &lt;a href=&quot;numpy.fft.ifft#numpy.fft.ifft&quot;&gt;&lt;code&gt;ifft&lt;/code&gt;&lt;/a&gt;, should be ordered in the same way as is returned by &lt;a href=&quot;numpy.fft.fft2#numpy.fft.fft2&quot;&gt;&lt;code&gt;fft2&lt;/code&gt;&lt;/a&gt;, i.e. it should have the term for zero frequency in the low-order corner of the two axes, the positive frequency terms in the first half of these axes, the term for the Nyquist frequency in the middle of the axes and the negative frequency terms in the second half of both axes, in order of decreasingly negative frequency.</source>
          <target state="translated">Вход, аналогично &lt;a href=&quot;numpy.fft.ifft#numpy.fft.ifft&quot;&gt; &lt;code&gt;ifft&lt;/code&gt; &lt;/a&gt; , должен быть упорядочен таким же образом, как и возвращаемый &lt;a href=&quot;numpy.fft.fft2#numpy.fft.fft2&quot;&gt; &lt;code&gt;fft2&lt;/code&gt; &lt;/a&gt; , то есть он должен иметь член для нулевой частоты в нижнем углу двух осей, члены положительной частоты в первой половине этих осей. по осям, член для частоты Найквиста в середине осей и члены с отрицательной частотой во второй половине обеих осей в порядке уменьшения отрицательной частоты.</target>
        </trans-unit>
        <trans-unit id="572b4f9e26edc1e967cf68e0ade8b40ff905e225" translate="yes" xml:space="preserve">
          <source>The input, analogously to &lt;a href=&quot;numpy.fft.ifft#numpy.fft.ifft&quot;&gt;&lt;code&gt;ifft&lt;/code&gt;&lt;/a&gt;, should be ordered in the same way as is returned by &lt;a href=&quot;numpy.fft.fftn#numpy.fft.fftn&quot;&gt;&lt;code&gt;fftn&lt;/code&gt;&lt;/a&gt;, i.e. it should have the term for zero frequency in all axes in the low-order corner, the positive frequency terms in the first half of all axes, the term for the Nyquist frequency in the middle of all axes and the negative frequency terms in the second half of all axes, in order of decreasingly negative frequency.</source>
          <target state="translated">Вход, аналогично &lt;a href=&quot;numpy.fft.ifft#numpy.fft.ifft&quot;&gt; &lt;code&gt;ifft&lt;/code&gt; &lt;/a&gt; , должен быть упорядочен таким же образом, как и возвращаемый &lt;a href=&quot;numpy.fft.fftn#numpy.fft.fftn&quot;&gt; &lt;code&gt;fftn&lt;/code&gt; &lt;/a&gt; , то есть он должен иметь член для нулевой частоты по всем осям в нижнем углу, положительные слагаемые частоты в первой половине всех осей , член для частоты Найквиста в середине всех осей и члены с отрицательной частотой во второй половине всех осей в порядке убывания отрицательной частоты.</target>
        </trans-unit>
        <trans-unit id="0d58354ed5e0735b3768fbb2adf71637dbdf3f49" translate="yes" xml:space="preserve">
          <source>The integration constants default to zero, but can be specified:</source>
          <target state="translated">Константы интеграции по умолчанию равны нулю,но их можно указать:</target>
        </trans-unit>
        <trans-unit id="b8cfb0f4ba349fe08f791a3f4e9c32e0be770fb0" translate="yes" xml:space="preserve">
          <source>The intent directive, intent(out) is used to tell f2py that &lt;code&gt;c&lt;/code&gt; is an output variable and should be created by the interface before being passed to the underlying code. The intent(hide) directive tells f2py to not allow the user to specify the variable, &lt;code&gt;n&lt;/code&gt;, but instead to get it from the size of &lt;code&gt;a&lt;/code&gt;. The depend( &lt;code&gt;a&lt;/code&gt; ) directive is necessary to tell f2py that the value of n depends on the input a (so that it won&amp;rsquo;t try to create the variable n until the variable a is created).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fef0aef07474fa13f32cd7e44f96fd84d9e33ac9" translate="yes" xml:space="preserve">
          <source>The interface definition file (.pyf) is how you can fine-tune the interface between Python and Fortran. There is decent documentation for f2py found in the numpy/f2py/docs directory where-ever NumPy is installed on your system (usually under site-packages). There is also more information on using f2py (including how to use it to wrap C codes) at &lt;a href=&quot;https://scipy-cookbook.readthedocs.io&quot;&gt;https://scipy-cookbook.readthedocs.io&lt;/a&gt; under the &amp;ldquo;Interfacing With Other Languages&amp;rdquo; heading.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a5987614ed3add49e80f0f100dd67a16f44fe90c" translate="yes" xml:space="preserve">
          <source>The interpolated values, same shape as &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="translated">Интерполированные значения той же формы, что и &lt;code&gt;x&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c7907bef880fafa82932152f51dbb34029c0604c" translate="yes" xml:space="preserve">
          <source>The inverse &lt;a href=&quot;numpy.cos#numpy.cos&quot;&gt;&lt;code&gt;cos&lt;/code&gt;&lt;/a&gt; is also known as &lt;code&gt;acos&lt;/code&gt; or cos^-1.</source>
          <target state="translated">Обратный &lt;a href=&quot;numpy.cos#numpy.cos&quot;&gt; &lt;code&gt;cos&lt;/code&gt; &lt;/a&gt; также известен как &lt;code&gt;acos&lt;/code&gt; или cos ^ -1.</target>
        </trans-unit>
        <trans-unit id="ec2dceba2b532e6fed6c11da573a946f40425e79" translate="yes" xml:space="preserve">
          <source>The inverse DFT is defined as</source>
          <target state="translated">Обратная DFT определяется как</target>
        </trans-unit>
        <trans-unit id="8495a1f69fb848ed573ead2789554fd370f64138" translate="yes" xml:space="preserve">
          <source>The inverse Gaussian distribution was first studied in relationship to Brownian motion. In 1956 M.C.K. Tweedie used the name inverse Gaussian because there is an inverse relationship between the time to cover a unit distance and distance covered in unit time.</source>
          <target state="translated">Обратное гауссово распределение впервые было изучено в связи с броуновским движением.В 1956 году М.С.К.Твиди использовал название обратного гауссовского,так как существует обратная связь между временем прохождения единичного расстояния и расстоянием,пройденным в единичном времени.</target>
        </trans-unit>
        <trans-unit id="68560eb00ac6299a73ce699655a0c6fd4e05a46a" translate="yes" xml:space="preserve">
          <source>The inverse function.</source>
          <target state="translated">Обратная функция.</target>
        </trans-unit>
        <trans-unit id="fe2bbafffa2c0c536b90659aca2befdd2f2ba17e" translate="yes" xml:space="preserve">
          <source>The inverse hyperbolic sine is also known as &lt;code&gt;asinh&lt;/code&gt; or &lt;code&gt;sinh^-1&lt;/code&gt;.</source>
          <target state="translated">Обратный гиперболический синус также известен как &lt;code&gt;asinh&lt;/code&gt; или &lt;code&gt;sinh^-1&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6a141e357fc6a95097873c345fcfc1ca43237a09" translate="yes" xml:space="preserve">
          <source>The inverse hyperbolic tangent is also known as &lt;code&gt;atanh&lt;/code&gt; or &lt;code&gt;tanh^-1&lt;/code&gt;.</source>
          <target state="translated">Обратный гиперболический тангенс также известен как &lt;code&gt;atanh&lt;/code&gt; или &lt;code&gt;tanh^-1&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="aed0ee03d4e87b9fedd1788aca12c58fdfb391c4" translate="yes" xml:space="preserve">
          <source>The inverse of &lt;a href=&quot;#numpy.fft.fft&quot;&gt;&lt;code&gt;fft&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Обратное &lt;a href=&quot;#numpy.fft.fft&quot;&gt; &lt;code&gt;fft&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="0b353ae768e12e71d0fa6bfe266dc15cf5490d90" translate="yes" xml:space="preserve">
          <source>The inverse of &lt;a href=&quot;#numpy.fft.fftn&quot;&gt;&lt;code&gt;fftn&lt;/code&gt;&lt;/a&gt;, the inverse &lt;em&gt;n&lt;/em&gt;-dimensional FFT.</source>
          <target state="translated">Обратное к &lt;a href=&quot;#numpy.fft.fftn&quot;&gt; &lt;code&gt;fftn&lt;/code&gt; &lt;/a&gt; , обратное &lt;em&gt;n-&lt;/em&gt; мерное БПФ.</target>
        </trans-unit>
        <trans-unit id="c086c016e117d897d4f2eb057744861a76634688" translate="yes" xml:space="preserve">
          <source>The inverse of &lt;a href=&quot;#numpy.fft.fftshift&quot;&gt;&lt;code&gt;fftshift&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Обратное к &lt;a href=&quot;#numpy.fft.fftshift&quot;&gt; &lt;code&gt;fftshift&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="9c2cb38b9631386379f4eeff7af3bee02f4b9bd5" translate="yes" xml:space="preserve">
          <source>The inverse of &lt;a href=&quot;#numpy.fft.hfft&quot;&gt;&lt;code&gt;hfft&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Обратный &lt;a href=&quot;#numpy.fft.hfft&quot;&gt; &lt;code&gt;hfft&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="13314fd29e0fae4ac48c552fa0a549b05087d956" translate="yes" xml:space="preserve">
          <source>The inverse of &lt;a href=&quot;#numpy.fft.rfft&quot;&gt;&lt;code&gt;rfft&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Обратный к &lt;a href=&quot;#numpy.fft.rfft&quot;&gt; &lt;code&gt;rfft&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="ff66e88345498b6e91d7444ef284a6ddd3ab7bea" translate="yes" xml:space="preserve">
          <source>The inverse of &lt;a href=&quot;#numpy.fft.rfftn&quot;&gt;&lt;code&gt;rfftn&lt;/code&gt;&lt;/a&gt;, i.e. the inverse of the n-dimensional FFT of real input.</source>
          <target state="translated">Обратное к &lt;a href=&quot;#numpy.fft.rfftn&quot;&gt; &lt;code&gt;rfftn&lt;/code&gt; &lt;/a&gt; , то есть обратное к n-мерному БПФ реального ввода.</target>
        </trans-unit>
        <trans-unit id="9e5b2a4471d9b30f761353eccfa786e46a0a43ee" translate="yes" xml:space="preserve">
          <source>The inverse of &lt;a href=&quot;generated/numpy.fft.fftshift#numpy.fft.fftshift&quot;&gt;&lt;code&gt;fftshift&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Обратное к &lt;a href=&quot;generated/numpy.fft.fftshift#numpy.fft.fftshift&quot;&gt; &lt;code&gt;fftshift&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="f58d6b52f1a134a30d097dc36ab0b6c772a15466" translate="yes" xml:space="preserve">
          <source>The inverse of &lt;a href=&quot;numpy.cos#numpy.cos&quot;&gt;&lt;code&gt;cos&lt;/code&gt;&lt;/a&gt; so that, if &lt;code&gt;y = cos(x)&lt;/code&gt;, then &lt;code&gt;x = arccos(y)&lt;/code&gt;.</source>
          <target state="translated">Обратное к &lt;a href=&quot;numpy.cos#numpy.cos&quot;&gt; &lt;code&gt;cos&lt;/code&gt; ,&lt;/a&gt; так что если &lt;code&gt;y = cos(x)&lt;/code&gt; , то &lt;code&gt;x = arccos(y)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="55a9d6743075a74b179dcc12407ef1436ea7bf25" translate="yes" xml:space="preserve">
          <source>The inverse of &lt;a href=&quot;numpy.fft.fftshift#numpy.fft.fftshift&quot;&gt;&lt;code&gt;fftshift&lt;/code&gt;&lt;/a&gt;. Although identical for even-length &lt;code&gt;x&lt;/code&gt;, the functions differ by one sample for odd-length &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="translated">Обратное к &lt;a href=&quot;numpy.fft.fftshift#numpy.fft.fftshift&quot;&gt; &lt;code&gt;fftshift&lt;/code&gt; &lt;/a&gt; . Хотя функции идентичны для четной длины &lt;code&gt;x&lt;/code&gt; , для нечетной длины &lt;code&gt;x&lt;/code&gt; функции отличаются на один образец .</target>
        </trans-unit>
        <trans-unit id="2b74e3f8abd785dde93a2e8dda9f5c04957251f7" translate="yes" xml:space="preserve">
          <source>The inverse of tan, so that if &lt;code&gt;y = tan(x)&lt;/code&gt; then &lt;code&gt;x = arctan(y)&lt;/code&gt;.</source>
          <target state="translated">Обратное к tan, так что если &lt;code&gt;y = tan(x)&lt;/code&gt; то &lt;code&gt;x = arctan(y)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7167a352b20dee7e079ce80d9af1a1aba672dc81" translate="yes" xml:space="preserve">
          <source>The inverse of the &lt;em&gt;n&lt;/em&gt;-dimensional FFT of real input.</source>
          <target state="translated">Обращение к &lt;em&gt;n-&lt;/em&gt; мерному БПФ реального ввода.</target>
        </trans-unit>
        <trans-unit id="c880c78696b367269e70a1f53424d9f97028c767" translate="yes" xml:space="preserve">
          <source>The inverse of the &lt;em&gt;n&lt;/em&gt;-dimensional FFT.</source>
          <target state="translated">Обратное к &lt;em&gt;n-&lt;/em&gt; мерному БПФ.</target>
        </trans-unit>
        <trans-unit id="f53fd91fa9c77430f006f0266202a3482a70bbcc" translate="yes" xml:space="preserve">
          <source>The inverse of the one-dimensional FFT of real input.</source>
          <target state="translated">Обратная величина одномерного БПФ реального входа.</target>
        </trans-unit>
        <trans-unit id="3905252dc05b002d9515309faf3f78f1dbb4c5f8" translate="yes" xml:space="preserve">
          <source>The inverse of the two-dimensional FFT of real input.</source>
          <target state="translated">Обратная величина двухмерного БПФ реального входа.</target>
        </trans-unit>
        <trans-unit id="3423775348fb08030d24725c90e7b0f2bd7d7c47" translate="yes" xml:space="preserve">
          <source>The inverse operation, adding singleton dimensions</source>
          <target state="translated">Обратная операция,добавление размеров одной кнопки</target>
        </trans-unit>
        <trans-unit id="aa766ce77746577ed5c08c35ec888672cda564ff" translate="yes" xml:space="preserve">
          <source>The inverse operation, removing singleton dimensions</source>
          <target state="translated">Обратная операция,удаление однокнопочных размеров</target>
        </trans-unit>
        <trans-unit id="61a85cd6779e9d5a8b6211c3c235036b15ffb999" translate="yes" xml:space="preserve">
          <source>The inverse sine is also known as &lt;code&gt;asin&lt;/code&gt; or sin^{-1}.</source>
          <target state="translated">Обратный синус также известен как &lt;code&gt;asin&lt;/code&gt; или sin ^ {- 1}.</target>
        </trans-unit>
        <trans-unit id="bfedf779c5c4bd6b17ab80b12a0d79168ab5aaa7" translate="yes" xml:space="preserve">
          <source>The inverse sine of each element in &lt;code&gt;x&lt;/code&gt;, in radians and in the closed interval &lt;code&gt;[-pi/2, pi/2]&lt;/code&gt;. This is a scalar if &lt;code&gt;x&lt;/code&gt; is a scalar.</source>
          <target state="translated">Обратный синус каждого элемента в &lt;code&gt;x&lt;/code&gt; , в радианах и в отрезке &lt;code&gt;[-pi/2, pi/2]&lt;/code&gt; . Это скаляр, если &lt;code&gt;x&lt;/code&gt; - скаляр.</target>
        </trans-unit>
        <trans-unit id="9c1a84044c9dab08c09d55a04b2b48623b8d59b6" translate="yes" xml:space="preserve">
          <source>The inverse tangent is also known as &lt;code&gt;atan&lt;/code&gt; or tan^{-1}.</source>
          <target state="translated">Арктангенс также известен как &lt;code&gt;atan&lt;/code&gt; или тангенс ^ {- 1}.</target>
        </trans-unit>
        <trans-unit id="6981525643a6c5c7fc9e1e7dde681f16ce56e65e" translate="yes" xml:space="preserve">
          <source>The inverse two-dimensional FFT.</source>
          <target state="translated">Обратный двухмерный БПФ.</target>
        </trans-unit>
        <trans-unit id="bdb5ead908952013fac6606928f3a4c8d7370b91" translate="yes" xml:space="preserve">
          <source>The irrational number &lt;code&gt;e&lt;/code&gt; is also known as Euler&amp;rsquo;s number. It is approximately 2.718281, and is the base of the natural logarithm, &lt;code&gt;ln&lt;/code&gt; (this means that, if</source>
          <target state="translated">Иррациональное число &lt;code&gt;e&lt;/code&gt; также известно как число Эйлера. Это приблизительно 2,718281 и является основанием натурального логарифма &lt;code&gt;ln&lt;/code&gt; (это означает, что если</target>
        </trans-unit>
        <trans-unit id="3dd3b5ec09656689d6b02dda587489104a598f1e" translate="yes" xml:space="preserve">
          <source>The iterator flag &amp;ldquo;delay_bufalloc&amp;rdquo; is there to allow iterator-allocated reduction operands to exist together with buffering. When this flag is set, the iterator will leave its buffers uninitialized until it receives a reset, after which it will be ready for regular iteration. Here&amp;rsquo;s how the previous example looks if we also enable buffering.</source>
          <target state="translated">Флаг итератора &amp;laquo;delay_bufalloc&amp;raquo; предназначен для того, чтобы позволить выделенным итератору операндам сокращения существовать вместе с буферизацией. Когда этот флаг установлен, итератор будет оставлять свои буферы неинициализированными до тех пор, пока он не получит сброс, после чего он будет готов к регулярной итерации. Вот как выглядит предыдущий пример, если мы также включим буферизацию.</target>
        </trans-unit>
        <trans-unit id="83edec37e4aaff5eef637f7c874f4dba22293c2c" translate="yes" xml:space="preserve">
          <source>The iterator holds a reference to iter</source>
          <target state="translated">Итератор содержит ссылку на итератор</target>
        </trans-unit>
        <trans-unit id="ffb4fa1555c6cc08c5edb304e11089604a5e4b03" translate="yes" xml:space="preserve">
          <source>The iterator layout is an internal detail, and user code only sees an incomplete struct.</source>
          <target state="translated">Раскладка итератора-это внутренняя деталь,а пользовательский код видит только неполную структуру.</target>
        </trans-unit>
        <trans-unit id="5cd3a081c57ba646ed11444a9ba92c76e9cd9145" translate="yes" xml:space="preserve">
          <source>The iterator object &lt;a href=&quot;generated/numpy.nditer#numpy.nditer&quot;&gt;&lt;code&gt;nditer&lt;/code&gt;&lt;/a&gt;, introduced in NumPy 1.6, provides many flexible ways to visit all the elements of one or more arrays in a systematic fashion. This page introduces some basic ways to use the object for computations on arrays in Python, then concludes with how one can accelerate the inner loop in Cython. Since the Python exposure of &lt;a href=&quot;generated/numpy.nditer#numpy.nditer&quot;&gt;&lt;code&gt;nditer&lt;/code&gt;&lt;/a&gt; is a relatively straightforward mapping of the C array iterator API, these ideas will also provide help working with array iteration from C or C++.</source>
          <target state="translated">Объект-итератор &lt;a href=&quot;generated/numpy.nditer#numpy.nditer&quot;&gt; &lt;code&gt;nditer&lt;/code&gt; &lt;/a&gt; , представленный в NumPy 1.6, предоставляет множество гибких способов систематического посещения всех элементов одного или нескольких массивов. На этой странице представлены некоторые основные способы использования объекта для вычислений с массивами в Python, а затем в заключение рассказывается, как можно ускорить внутренний цикл в Cython. Поскольку представление Python в &lt;a href=&quot;generated/numpy.nditer#numpy.nditer&quot;&gt; &lt;code&gt;nditer&lt;/code&gt; &lt;/a&gt; является относительно простым отображением API итератора массива C, эти идеи также помогут при работе с итерацией массива из C или C ++.</target>
        </trans-unit>
        <trans-unit id="c7cde3e3f66c5a8b8cc8bfff4db276cc023c595e" translate="yes" xml:space="preserve">
          <source>The iterator uses NumPy&amp;rsquo;s casting rules to determine whether a specific conversion is permitted. By default, it enforces &amp;lsquo;safe&amp;rsquo; casting. This means, for example, that it will raise an exception if you try to treat a 64-bit float array as a 32-bit float array. In many cases, the rule &amp;lsquo;same_kind&amp;rsquo; is the most reasonable rule to use, since it will allow conversion from 64 to 32-bit float, but not from float to int or from complex to float.</source>
          <target state="translated">Итератор использует правила кастинга NumPy, чтобы определить, разрешено ли конкретное преобразование. По умолчанию он применяет &amp;laquo;безопасное&amp;raquo; преобразование. Это означает, например, что он вызовет исключение, если вы попытаетесь обработать 64-битный массив с плавающей запятой как 32-битный массив с плавающей запятой. Во многих случаях правило same_kind является наиболее разумным для использования, поскольку оно позволяет преобразовывать 64-разрядное значение с плавающей запятой в 32-разрядное, но не позволяет преобразовать ее из числа с плавающей точкой в ​​целое или из сложного в число с плавающей точкой.</target>
        </trans-unit>
        <trans-unit id="cacf8c06cd15c0c88c5430d945ba0f2cf7ba5182" translate="yes" xml:space="preserve">
          <source>The ix_() function</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bfb129467dcc5458e92314d1dc23bfece4b4c9b2" translate="yes" xml:space="preserve">
          <source>The jump size is</source>
          <target state="translated">Размер прыжка</target>
        </trans-unit>
        <trans-unit id="ce335f317c6680914a491bd8a7fe70c41740c803" translate="yes" xml:space="preserve">
          <source>The jump step is computed using a modified version of Matsumoto&amp;rsquo;s implementation of Horner&amp;rsquo;s method. The step polynomial is precomputed to perform 2**128 steps. The jumped state has been verified to match the state produced using Matsumoto&amp;rsquo;s original code.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="342e9169764fb77c1b214a706155105da1218b49" translate="yes" xml:space="preserve">
          <source>The key should be either a string or a sequence of string corresponding to the fields used to join the array. An exception is raised if the &lt;code&gt;key&lt;/code&gt; field cannot be found in the two input arrays. Neither &lt;code&gt;r1&lt;/code&gt; nor &lt;code&gt;r2&lt;/code&gt; should have any duplicates along &lt;code&gt;key&lt;/code&gt;: the presence of duplicates will make the output quite unreliable. Note that duplicates are not looked for by the algorithm.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1697c380f1179f3bbb3a86f4d75a8de0b46efbc6" translate="yes" xml:space="preserve">
          <source>The keys are:</source>
          <target state="translated">Ключи:</target>
        </trans-unit>
        <trans-unit id="b094a8a56c283a1dca9080c127defb8dc7eabacc" translate="yes" xml:space="preserve">
          <source>The kind of integer data type to get information about.</source>
          <target state="translated">Вид целочисленного типа данных для получения информации.</target>
        </trans-unit>
        <trans-unit id="41c3ca93d5f02dccd969da26a833b72af9110c68" translate="yes" xml:space="preserve">
          <source>The kwds argument holds a Python dictionary whose keys are the names of the keyword arguments and whose values are the corresponding keyword-argument values. This dictionary can be processed however you see fit. The easiest way to handle it, however, is to replace the &lt;a href=&quot;https://docs.python.org/dev/c-api/arg.html#c.PyArg_ParseTuple&quot;&gt;&lt;code&gt;PyArg_ParseTuple&lt;/code&gt;&lt;/a&gt; (args, format_string, addresses&amp;hellip;) function with a call to &lt;a href=&quot;https://docs.python.org/dev/c-api/arg.html#c.PyArg_ParseTupleAndKeywords&quot;&gt;&lt;code&gt;PyArg_ParseTupleAndKeywords&lt;/code&gt;&lt;/a&gt; (args, kwds, format_string, char *kwlist[], addresses&amp;hellip;). The kwlist parameter to this function is a &lt;code&gt;NULL&lt;/code&gt; -terminated array of strings providing the expected keyword arguments. There should be one string for each entry in the format_string. Using this function will raise a TypeError if invalid keyword arguments are passed in.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d80fbf99f1073ba593f4b530d71e8ae5f9ae88a1" translate="yes" xml:space="preserve">
          <source>The larger object to compare.</source>
          <target state="translated">Более крупный объект для сравнения.</target>
        </trans-unit>
        <trans-unit id="3b1d6d882f09df5877abb8ef200d99a4552edbcc" translate="yes" xml:space="preserve">
          <source>The largest representable number.</source>
          <target state="translated">Самое большое представительное число.</target>
        </trans-unit>
        <trans-unit id="8c04ea0c745fb65e3a5c6b4d6a06693d11870a3e" translate="yes" xml:space="preserve">
          <source>The last dimension of the input array is converted into a structure, with number of field-elements equal to the size of the last dimension of the input array. By default all output fields have the input array&amp;rsquo;s dtype, but an output structured dtype with an equal number of fields-elements can be supplied instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2abbd596290a88e6d12f22ea12675111b689f0a9" translate="yes" xml:space="preserve">
          <source>The last is an instance of freezing a core dimension and can be used to improve ufunc performance</source>
          <target state="translated">Последнее является примером замораживания размера ядра и может быть использовано для улучшения производительности ufunc.</target>
        </trans-unit>
        <trans-unit id="64a2253d0a7bf7afbe6eb3cddc1d5520d0b0c60a" translate="yes" xml:space="preserve">
          <source>The last one giving only the first elements because of the extra dimension. Compare &lt;code&gt;rowsum.nonzero()&lt;/code&gt; to understand this example.</source>
          <target state="translated">Последний дает только первые элементы из-за дополнительного измерения. Сравните &lt;code&gt;rowsum.nonzero()&lt;/code&gt; чтобы понять этот пример.</target>
        </trans-unit>
        <trans-unit id="d08df5e86170609b57051ef10f9fb3e1c3868c9f" translate="yes" xml:space="preserve">
          <source>The last thing that must be done to finish the extension module is to actually write the code that performs the desired functions. There are two kinds of functions: those that don&amp;rsquo;t accept keyword arguments, and those that do.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d5e8d86c6819b2227ff0ab7cafe1755645c6727d" translate="yes" xml:space="preserve">
          <source>The last two are characteristics of ndarrays - in order to support things like array slicing. The complications of subclassing ndarray are due to the mechanisms numpy has to support these latter two routes of instance creation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2e8784c819189f431349d4282dd8265432f3285b" translate="yes" xml:space="preserve">
          <source>The latter group of &lt;code&gt;{NAME}s&lt;/code&gt; corresponds to letters used in the array interface typestring specification.</source>
          <target state="translated">Последняя группа &lt;code&gt;{NAME}s&lt;/code&gt; соответствует буквам, используемым в спецификации строки интерфейса массива.</target>
        </trans-unit>
        <trans-unit id="34445ad4113f33f26d89f86d8eb17d5993aa2b33" translate="yes" xml:space="preserve">
          <source>The leftmost and rightmost edges of the bins along each dimension (if not specified explicitly in the &lt;code&gt;bins&lt;/code&gt; parameters): &lt;code&gt;[[xmin, xmax], [ymin, ymax]]&lt;/code&gt;. All values outside of this range will be considered outliers and not tallied in the histogram.</source>
          <target state="translated">Левые и правые края бункеров вдоль каждого измерения (если не указано явно в &lt;code&gt;bins&lt;/code&gt; параметров): &lt;code&gt;[[xmin, xmax], [ymin, ymax]]&lt;/code&gt; . Все значения за пределами этого диапазона будут считаться выбросами и не учитываться на гистограмме.</target>
        </trans-unit>
        <trans-unit id="7a57cb0c41d71bfde5dfe132d9a4c3e502a05b10" translate="yes" xml:space="preserve">
          <source>The length of &lt;code&gt;condlist&lt;/code&gt; must correspond to that of &lt;code&gt;funclist&lt;/code&gt;. If one extra function is given, i.e. if &lt;code&gt;len(funclist) == len(condlist) + 1&lt;/code&gt;, then that extra function is the default value, used wherever all conditions are false.</source>
          <target state="translated">Длина &lt;code&gt;condlist&lt;/code&gt; должна соответствовать &lt;code&gt;funclist&lt;/code&gt; . Если задана одна дополнительная функция, например, если &lt;code&gt;len(funclist) == len(condlist) + 1&lt;/code&gt; , то эта дополнительная функция является значением по умолчанию, используемым везде, где все условия ложны.</target>
        </trans-unit>
        <trans-unit id="fda9f4dafa3b1f4f0bc8667197c7c2f74ba12e70" translate="yes" xml:space="preserve">
          <source>The length of docstring lines should be kept to 75 characters to facilitate reading the docstrings in text terminals.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="74e1dfe5bb68b99490ab8db3a4549a897ab92285" translate="yes" xml:space="preserve">
          <source>The length of the list of integers. It is assumed safe to access &lt;em&gt;ptr&lt;/em&gt; [0] to &lt;em&gt;ptr&lt;/em&gt; [len-1].</source>
          <target state="translated">Длина списка целых чисел. Предполагается, что доступ от &lt;em&gt;ptr&lt;/em&gt; [0] к &lt;em&gt;ptr&lt;/em&gt; [len-1] безопасен .</target>
        </trans-unit>
        <trans-unit id="c7170d6904bad30d46bd752038c157844edf21e6" translate="yes" xml:space="preserve">
          <source>The length of the prefix and suffix strings are used to respectively align and wrap the output. An array is typically printed as:</source>
          <target state="translated">Длина префиксной и суффиксной строк используется для выравнивания и обертывания вывода соответственно.Массив обычно выводится как:</target>
        </trans-unit>
        <trans-unit id="2a29e90467961f11261cb34c5ec7868485d4aa81" translate="yes" xml:space="preserve">
          <source>The length of the resulting strings</source>
          <target state="translated">Длина полученных строк</target>
        </trans-unit>
        <trans-unit id="bd80f84b161ca3d681912061b09ff3df6041ed39" translate="yes" xml:space="preserve">
          <source>The length of the returned string if &lt;code&gt;num&lt;/code&gt; is positive, or the length of the two&amp;rsquo;s complement if &lt;code&gt;num&lt;/code&gt; is negative, provided that &lt;code&gt;width&lt;/code&gt; is at least a sufficient number of bits for &lt;code&gt;num&lt;/code&gt; to be represented in the designated form.</source>
          <target state="translated">Длина возвращаемой строки , если &lt;code&gt;num&lt;/code&gt; положительна, или длина два с дополнением , если &lt;code&gt;num&lt;/code&gt; имеет отрицательное значение , при условии , что &lt;code&gt;width&lt;/code&gt; по меньшей мере , достаточное количество бит для &lt;code&gt;num&lt;/code&gt; быть представлена в указанном виде.</target>
        </trans-unit>
        <trans-unit id="63e0949a7b519952c49eb749b0448baf6c2dcdf9" translate="yes" xml:space="preserve">
          <source>The length of the segment in bytes.</source>
          <target state="translated">Длина сегмента в байтах.</target>
        </trans-unit>
        <trans-unit id="b0af5a70b649c99b0be522e1c0ad6114744383d4" translate="yes" xml:space="preserve">
          <source>The length of the span is the range of a 64-bit integer times the length of the date or unit. For example, the time span for &amp;lsquo;W&amp;rsquo; (week) is exactly 7 times longer than the time span for &amp;lsquo;D&amp;rsquo; (day), and the time span for &amp;lsquo;D&amp;rsquo; (day) is exactly 24 times longer than the time span for &amp;lsquo;h&amp;rsquo; (hour).</source>
          <target state="translated">Длина диапазона - это диапазон 64-битного целого числа, умноженного на длину даты или единицы. Например, промежуток времени для 'W' (неделя) ровно в 7 раз больше, чем промежуток времени для 'D' (день), а промежуток времени для 'D' (день) ровно в 24 раза больше, чем промежуток времени для 'h' (час).</target>
        </trans-unit>
        <trans-unit id="c92e142a9e3623399b64df009d94b4d034da17ea" translate="yes" xml:space="preserve">
          <source>The line above represents z**3 + 0*z**2 + 0*z + 0.</source>
          <target state="translated">Строка выше представляет z**3+0*z**2+0*z+0.</target>
        </trans-unit>
        <trans-unit id="b578e5e67f3e586204e4994bbe5c88c656a6cae7" translate="yes" xml:space="preserve">
          <source>The line above represents z**3 - z/4</source>
          <target state="translated">Приведенная выше строка представляет z**3-z/4</target>
        </trans-unit>
        <trans-unit id="cb5275e91dcecc0c6dc816bc9710e92658bd3377" translate="yes" xml:space="preserve">
          <source>The linear map &lt;code&gt;offset + scale*x&lt;/code&gt; that maps the domain &lt;code&gt;old&lt;/code&gt; to the domain &lt;code&gt;new&lt;/code&gt; is applied to the points &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="translated">Линейное &lt;code&gt;offset + scale*x&lt;/code&gt; карты + масштаб * x, которое сопоставляет &lt;code&gt;old&lt;/code&gt; домен с &lt;code&gt;new&lt;/code&gt; , применяется к точкам &lt;code&gt;x&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2428c8d989723853883bd2c4d45c041f6e455adf" translate="yes" xml:space="preserve">
          <source>The list &lt;code&gt;x&lt;/code&gt; contains 4 items, each which can be accessed individually:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="647499d1a98b89607edcd5f783a0adb1c730bbde" translate="yes" xml:space="preserve">
          <source>The list of arrays from which the output elements are taken. It has to be of the same length as &lt;code&gt;condlist&lt;/code&gt;.</source>
          <target state="translated">Список массивов, из которых берутся выходные элементы. Он должен быть той же длины, что и &lt;code&gt;condlist&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="529e159ac14f2e5a4bfd821c54e94a56730b5c46" translate="yes" xml:space="preserve">
          <source>The list of conditions which determine from which array in &lt;code&gt;choicelist&lt;/code&gt; the output elements are taken. When multiple conditions are satisfied, the first one encountered in &lt;code&gt;condlist&lt;/code&gt; is used.</source>
          <target state="translated">Список условий, определяющих, из какого массива в списке &lt;code&gt;choicelist&lt;/code&gt; берутся выходные элементы. Когда выполняется несколько условий, используется первое из &lt;code&gt;condlist&lt;/code&gt; в condlist .</target>
        </trans-unit>
        <trans-unit id="a85b3c79db62cd35117edd96a90c46599648e8f3" translate="yes" xml:space="preserve">
          <source>The list of field names of a structured datatype can be found in the &lt;code&gt;names&lt;/code&gt; attribute of the dtype object:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="92c329f0ce8c711e6636f92601cc50d421b9b226" translate="yes" xml:space="preserve">
          <source>The list of slices, one for each continuous region of masked elements in &lt;code&gt;a&lt;/code&gt;.</source>
          <target state="translated">Список фрагментов, по одному для каждой непрерывной области маскированных элементов в &lt;code&gt;a&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="88a36ffbba49be32da3baf6bb43ea7e384cf3381" translate="yes" xml:space="preserve">
          <source>The list of slices, one for each continuous region of unmasked elements in &lt;code&gt;a&lt;/code&gt;.</source>
          <target state="translated">Список срезов, один для каждой непрерывной области масок элементов в . &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a7251af1a3271825930cf9fcd1d817e4c55bd823" translate="yes" xml:space="preserve">
          <source>The list of sources may contain functions (&amp;lsquo;source generators&amp;rsquo;) with a pattern &lt;code&gt;def &amp;lt;funcname&amp;gt;(ext, build_dir): return
&amp;lt;source(s) or None&amp;gt;&lt;/code&gt;. If &lt;code&gt;funcname&lt;/code&gt; returns &lt;code&gt;None&lt;/code&gt;, no sources are generated. And if the &lt;code&gt;Extension&lt;/code&gt; instance has no sources after processing all source generators, no extension module will be built. This is the recommended way to conditionally define extension modules. Source generator functions are called by the &lt;code&gt;build_src&lt;/code&gt; command of &lt;code&gt;numpy.distutils&lt;/code&gt;.</source>
          <target state="translated">Список источников может содержать функции (&amp;laquo;генераторы исходного кода&amp;raquo;) с шаблоном &lt;code&gt;def &amp;lt;funcname&amp;gt;(ext, build_dir): return &amp;lt;source(s) or None&amp;gt;&lt;/code&gt; . Если &lt;code&gt;funcname&lt;/code&gt; возвращает &lt;code&gt;None&lt;/code&gt; , источники не создаются. И если у экземпляра &lt;code&gt;Extension&lt;/code&gt; нет источников после обработки всех генераторов источников, никакой модуль расширения не будет построен. Это рекомендуемый способ условного определения модулей расширения. Функции генератора Source вызываются &lt;code&gt;build_src&lt;/code&gt; командой &lt;code&gt;numpy.distutils&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="70ba9a25afcb1723906c4b12dfd6f0a126515e6c" translate="yes" xml:space="preserve">
          <source>The list of sources may contain functions (&amp;lsquo;source generators&amp;rsquo;) with a pattern &lt;code&gt;def &amp;lt;funcname&amp;gt;(ext, build_dir): return
&amp;lt;source(s) or None&amp;gt;&lt;/code&gt;. If &lt;code&gt;funcname&lt;/code&gt; returns &lt;code&gt;None&lt;/code&gt;, no sources are generated. And if the &lt;code&gt;Extension&lt;/code&gt; instance has no sources after processing all source generators, no extension module will be built. This is the recommended way to conditionally define extension modules. Source generator functions are called by the &lt;code&gt;build_src&lt;/code&gt; sub-command of &lt;code&gt;numpy.distutils&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e86e6b1dfd4d026f3bb365ed0394b538f40e1c2c" translate="yes" xml:space="preserve">
          <source>The location of the mode of the distribution. Default is 0.</source>
          <target state="translated">Расположение режима распределения.По умолчанию 0.</target>
        </trans-unit>
        <trans-unit id="f922a603661ce7b289c8f2d5dd79d3f8d12f2d5b" translate="yes" xml:space="preserve">
          <source>The log series distribution is frequently used to represent species richness and occurrence, first proposed by Fisher, Corbet, and Williams in 1943 [2]. It may also be used to model the numbers of occupants seen in cars [3].</source>
          <target state="translated">Распределение бревенчатых серий часто используется для представления видового богатства и распространенности,впервые предложенное Фишером,Корбетом и Вильямсом в 1943 году [2].Оно также может быть использовано для моделирования количества людей,находящихся в автомобилях [3].</target>
        </trans-unit>
        <trans-unit id="23451df0ca8ba5d5bfbdca9cf8c2255b108c68ac" translate="yes" xml:space="preserve">
          <source>The logarithm to the base 10 of &lt;code&gt;x&lt;/code&gt;, element-wise. NaNs are returned where x is negative. This is a scalar if &lt;code&gt;x&lt;/code&gt; is a scalar.</source>
          <target state="translated">Логарифм по основанию 10 &lt;code&gt;x&lt;/code&gt; , поэлементно. NaN возвращаются, если x отрицательно. Это скаляр, если &lt;code&gt;x&lt;/code&gt; - скаляр.</target>
        </trans-unit>
        <trans-unit id="4d6739be6bf6c7545bc1a71d692001820b9d7cac" translate="yes" xml:space="preserve">
          <source>The logic behind those functions in more than two dimensions can be strange.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b8615daefc462d9e38519ed036e0e283940da95b" translate="yes" xml:space="preserve">
          <source>The lower and upper range of the bins. If not provided, range is simply &lt;code&gt;(a.min(), a.max())&lt;/code&gt;. Values outside the range are ignored. The first element of the range must be less than or equal to the second. &lt;code&gt;range&lt;/code&gt; affects the automatic bin computation as well. While bin width is computed to be optimal based on the actual data within &lt;code&gt;range&lt;/code&gt;, the bin count will fill the entire range including portions containing no data.</source>
          <target state="translated">Нижний и верхний диапазон ящиков. Если не &lt;code&gt;(a.min(), a.max())&lt;/code&gt; , диапазон будет просто (a.min (), a.max ()) . Значения вне диапазона игнорируются. Первый элемент диапазона должен быть меньше или равен второму. &lt;code&gt;range&lt;/code&gt; влияет на автоматическое вычисление интервала . В то время как ширина ячейки рассчитывается как оптимальная на основе фактических данных в пределах &lt;code&gt;range&lt;/code&gt; , счетчик ячейки заполняет весь диапазон, включая части, не содержащие данных.</target>
        </trans-unit>
        <trans-unit id="6456e48a0250380ada9bfcdc5cd3014ca07e5eb0" translate="yes" xml:space="preserve">
          <source>The lower bound for the top 1% of the samples is :</source>
          <target state="translated">Нижняя граница для верхнего 1% образца-:</target>
        </trans-unit>
        <trans-unit id="4e9276b72baca62196e481978e6fcfbd0f0274c3" translate="yes" xml:space="preserve">
          <source>The lower bound of the definite integral.</source>
          <target state="translated">Нижняя граница определённого интеграла.</target>
        </trans-unit>
        <trans-unit id="37caf12cbe44bfdef1d91bca2e93d01e775cf201" translate="yes" xml:space="preserve">
          <source>The lower bound of the integral. (Default: 0)</source>
          <target state="translated">Нижняя граница интеграла.(По умолчанию:0)</target>
        </trans-unit>
        <trans-unit id="a76f1d77a96a5b462f5fae8acc24fa2aae62620a" translate="yes" xml:space="preserve">
          <source>The lowest common multiple</source>
          <target state="translated">Наименьшее общее число</target>
        </trans-unit>
        <trans-unit id="87d6bfa25ac3b02d4e51aa1f4135cd735f016c13" translate="yes" xml:space="preserve">
          <source>The lowest common multiple of the absolute value of the inputs This is a scalar if both &lt;code&gt;x1&lt;/code&gt; and &lt;code&gt;x2&lt;/code&gt; are scalars.</source>
          <target state="translated">Наименьшее общее кратное абсолютного значения входных данных. Это скаляр, если и &lt;code&gt;x1&lt;/code&gt; , и &lt;code&gt;x2&lt;/code&gt; являются скалярами.</target>
        </trans-unit>
        <trans-unit id="6767713cd6108661a0803484e7289fe42459ebb5" translate="yes" xml:space="preserve">
          <source>The main feature of the &lt;a href=&quot;#module-numpy.ma&quot;&gt;&lt;code&gt;numpy.ma&lt;/code&gt;&lt;/a&gt; module is the &lt;a href=&quot;maskedarray.baseclass#numpy.ma.MaskedArray&quot;&gt;&lt;code&gt;MaskedArray&lt;/code&gt;&lt;/a&gt; class, which is a subclass of &lt;a href=&quot;generated/numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;numpy.ndarray&lt;/code&gt;&lt;/a&gt;. The class, its attributes and methods are described in more details in the &lt;a href=&quot;maskedarray.baseclass#maskedarray-baseclass&quot;&gt;MaskedArray class&lt;/a&gt; section.</source>
          <target state="translated">Основной особенностью модуля &lt;a href=&quot;#module-numpy.ma&quot;&gt; &lt;code&gt;numpy.ma&lt;/code&gt; &lt;/a&gt; является класс &lt;a href=&quot;maskedarray.baseclass#numpy.ma.MaskedArray&quot;&gt; &lt;code&gt;MaskedArray&lt;/code&gt; &lt;/a&gt; , который является подклассом &lt;a href=&quot;generated/numpy.ndarray#numpy.ndarray&quot;&gt; &lt;code&gt;numpy.ndarray&lt;/code&gt; &lt;/a&gt; . Более подробно класс, его атрибуты и методы описаны в &lt;a href=&quot;maskedarray.baseclass#maskedarray-baseclass&quot;&gt;разделе класса MaskedArray&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="52a36a5301780b2d55c316deba861004a7e6a2e2" translate="yes" xml:space="preserve">
          <source>The main page for the &lt;a href=&quot;../contents#numpy-docs-mainpage&quot;&gt;NumPy Documentation&lt;/a&gt; lists several categories. The documents mentioned there live in different places.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="48a467f7e54add76d93e3f038ba1d5a3c08c31d6" translate="yes" xml:space="preserve">
          <source>The main routine for obtaining an array from any Python object that can be converted to an array is &lt;a href=&quot;../reference/c-api/array#c.PyArray_FromAny&quot;&gt;&lt;code&gt;PyArray_FromAny&lt;/code&gt;&lt;/a&gt;. This function is very flexible with many input arguments. Several macros make it easier to use the basic function. &lt;a href=&quot;../reference/c-api/array#c.PyArray_FROM_OTF&quot;&gt;&lt;code&gt;PyArray_FROM_OTF&lt;/code&gt;&lt;/a&gt; is arguably the most useful of these macros for the most common uses. It allows you to convert an arbitrary Python object to an array of a specific builtin data-type ( &lt;em&gt;e.g.&lt;/em&gt; float), while specifying a particular set of requirements ( &lt;em&gt;e.g.&lt;/em&gt; contiguous, aligned, and writeable). The syntax is</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9a6437cd8dced244085d75f5d4ec1f2af95ca5d9" translate="yes" xml:space="preserve">
          <source>The main way to control how the sequences of strings we have read from the file are converted to other types is to set the &lt;code&gt;dtype&lt;/code&gt; argument. Acceptable values for this argument are:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b863f0a577a40cd3794882f4e85002ecea6308b0" translate="yes" xml:space="preserve">
          <source>The mantissas &lt;code&gt;x1&lt;/code&gt; and twos exponents &lt;code&gt;x2&lt;/code&gt; are used to construct floating point numbers &lt;code&gt;x1 * 2**x2&lt;/code&gt;.</source>
          <target state="translated">Мантиссы &lt;code&gt;x1&lt;/code&gt; и двойки &lt;code&gt;x2&lt;/code&gt; используются для построения чисел с плавающей запятой &lt;code&gt;x1 * 2**x2&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1288609b08eeb3cc92c01ebf371043c8f0d81962" translate="yes" xml:space="preserve">
          <source>The map &lt;code&gt;L(x) = offset + scale*x&lt;/code&gt; maps the first domain to the second.</source>
          <target state="translated">Карта &lt;code&gt;L(x) = offset + scale*x&lt;/code&gt; сопоставляет первый домен со вторым.</target>
        </trans-unit>
        <trans-unit id="fd5781bc4f89018e0fb9cd14ef3f3c125e3d74bb" translate="yes" xml:space="preserve">
          <source>The mapping function is defined by &lt;code&gt;off + scl*x&lt;/code&gt;.</source>
          <target state="translated">Функция отображения определяется как &lt;code&gt;off + scl*x&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f0d7698b06a0aedcc32f911c787189d531c3eac9" translate="yes" xml:space="preserve">
          <source>The mask is lost if &lt;code&gt;out&lt;/code&gt; is not a valid &lt;a href=&quot;../maskedarray.baseclass#numpy.ma.MaskedArray&quot;&gt;&lt;code&gt;MaskedArray&lt;/code&gt;&lt;/a&gt; !</source>
          <target state="translated">Маска теряется, если &lt;code&gt;out&lt;/code&gt; не является допустимым &lt;a href=&quot;../maskedarray.baseclass#numpy.ma.MaskedArray&quot;&gt; &lt;code&gt;MaskedArray&lt;/code&gt; &lt;/a&gt; !</target>
        </trans-unit>
        <trans-unit id="649d4874d06fb274533beb59f5f2cd10f5dc2b95" translate="yes" xml:space="preserve">
          <source>The mask is lost if &lt;code&gt;out&lt;/code&gt; is not a valid MaskedArray !</source>
          <target state="translated">Маска теряется, если &lt;code&gt;out&lt;/code&gt; не является допустимым MaskedArray!</target>
        </trans-unit>
        <trans-unit id="f9bf54dc7bd5e650858bf619f77da75fc06bf1f6" translate="yes" xml:space="preserve">
          <source>The mask of a masked array is accessible through its &lt;a href=&quot;maskedarray.baseclass#numpy.ma.MaskedArray.mask&quot;&gt;&lt;code&gt;mask&lt;/code&gt;&lt;/a&gt; attribute. We must keep in mind that a &lt;code&gt;True&lt;/code&gt; entry in the mask indicates an &lt;em&gt;invalid&lt;/em&gt; data.</source>
          <target state="translated">Маска замаскированного массива доступна через его атрибут &lt;a href=&quot;maskedarray.baseclass#numpy.ma.MaskedArray.mask&quot;&gt; &lt;code&gt;mask&lt;/code&gt; &lt;/a&gt; . Мы должны иметь в виду, что запись &lt;code&gt;True&lt;/code&gt; в маске указывает на &lt;em&gt;недопустимые&lt;/em&gt; данные.</target>
        </trans-unit>
        <trans-unit id="5f7d748f7e23f2629a7257e1d7501357c2ce872d" translate="yes" xml:space="preserve">
          <source>The mask of a masked array view is also a view rather than a copy</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="136b0641a8efd21e297d96cb868071b555117d7d" translate="yes" xml:space="preserve">
          <source>The masked arrays for which to compare fill values.</source>
          <target state="translated">Маскированные массивы,для которых сравниваются значения заливки.</target>
        </trans-unit>
        <trans-unit id="6a7c669e8d49f546a924fb9ea3a27606961c98f7" translate="yes" xml:space="preserve">
          <source>The matmul function implements the semantics of the &lt;code&gt;@&lt;/code&gt; operator introduced in Python 3.5 following PEP465.</source>
          <target state="translated">Функция matmul реализует семантику оператора &lt;code&gt;@&lt;/code&gt; , представленного в Python 3.5 после PEP465.</target>
        </trans-unit>
        <trans-unit id="b0018603311d83d5ccf5c07dff4523d1ca410b48" translate="yes" xml:space="preserve">
          <source>The matrix class is a Python subclass of the ndarray and can be used as a reference for how to construct your own subclass of the ndarray. Matrices can be created from other matrices, strings, and anything else that can be converted to an &lt;code&gt;ndarray&lt;/code&gt; . The name &amp;ldquo;mat &amp;ldquo;is an alias for &amp;ldquo;matrix &amp;ldquo;in NumPy.</source>
          <target state="translated">Класс matrix является подклассом Python для ndarray и может использоваться в качестве справочника для создания собственного подкласса ndarray. Матрицы могут быть созданы из других матриц, строк и всего остального, что можно преобразовать в &lt;code&gt;ndarray&lt;/code&gt; . Имя &amp;laquo;mat&amp;raquo; - это псевдоним для &amp;laquo;матрицы&amp;raquo; в NumPy.</target>
        </trans-unit>
        <trans-unit id="5f8d7cfa51bd7c57bbf7e03577a1825ff994845e" translate="yes" xml:space="preserve">
          <source>The matrix of random values with shape given by &lt;code&gt;*args&lt;/code&gt;.</source>
          <target state="translated">Матрица случайных значений с формой, заданной &lt;code&gt;*args&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="608aa6eae8f7f68c13529cd8bd42452f015b4b90" translate="yes" xml:space="preserve">
          <source>The matrix product of the inputs. This is a scalar only when both x1, x2 are 1-d vectors.</source>
          <target state="translated">Матричный продукт входов.Это скаляр только тогда,когда оба x1,x2 являются 1-d векторами.</target>
        </trans-unit>
        <trans-unit id="c658bc86aaba588a6a002ba9982fdea6c89bc9cc" translate="yes" xml:space="preserve">
          <source>The matrix whose condition number is sought.</source>
          <target state="translated">Матрица,номер условия которой запрашивается.</target>
        </trans-unit>
        <trans-unit id="c8c3ef8c7c85bd35de6e1deb7b50a36e856e51b4" translate="yes" xml:space="preserve">
          <source>The matrix, but as a (1, N) matrix if it had shape (N, 1).</source>
          <target state="translated">Матрица,но как (1,N)матрица,если она имела форму (N,1).</target>
        </trans-unit>
        <trans-unit id="d2f91514f11b147277135520b0867d5d6ef7f638" translate="yes" xml:space="preserve">
          <source>The maximum is equivalent to &lt;code&gt;np.where(x1 &amp;gt;= x2, x1, x2)&lt;/code&gt; when neither x1 nor x2 are nans, but it is faster and does proper broadcasting.</source>
          <target state="translated">Максимум эквивалентен &lt;code&gt;np.where(x1 &amp;gt;= x2, x1, x2)&lt;/code&gt; когда ни x1, ни x2 не являются nans, но он быстрее и правильно передает.</target>
        </trans-unit>
        <trans-unit id="b9ec29a01437d2db772a9e55518ff6e61467f369" translate="yes" xml:space="preserve">
          <source>The maximum number of array arguments that can be used in functions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d4b71803b063354491818e9ff7d7f91cb1c1ba7e" translate="yes" xml:space="preserve">
          <source>The maximum number of dimensions allowed in arrays.</source>
          <target state="translated">Максимально допустимое количество размеров в массивах.</target>
        </trans-unit>
        <trans-unit id="aff70196c900f17cb2833a4c90eb4869b491b830" translate="yes" xml:space="preserve">
          <source>The maximum number of rows to read. Must not be used with skip_footer at the same time. If given, the value must be at least 1. Default is to read the entire file.</source>
          <target state="translated">Максимальное количество строк для чтения.Не должно использоваться одновременно с skip_footer.Если дано,то значение должно быть не менее 1.По умолчанию читается весь файл.</target>
        </trans-unit>
        <trans-unit id="bd4584d425d2919fbb0f9bcabce0ec35c9487dde" translate="yes" xml:space="preserve">
          <source>The maximum number of unit in the last place for tolerance (see Notes). Default is 1.</source>
          <target state="translated">Максимальное количество единиц на последнем месте для допуска (см.Примечания).По умолчанию 1.</target>
        </trans-unit>
        <trans-unit id="3cded325e7f85dbd01c8e732779ef69a0c4dfb37" translate="yes" xml:space="preserve">
          <source>The maximum number of units in the last place that elements of &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; can differ. Default is 1.</source>
          <target state="translated">Максимальное количество единиц в последнем месте, которое могут отличаться элементы &lt;code&gt;a&lt;/code&gt; и &lt;code&gt;b&lt;/code&gt; . По умолчанию 1.</target>
        </trans-unit>
        <trans-unit id="4d9efaa03fd6ffe081e389f0039d71a839a20c3f" translate="yes" xml:space="preserve">
          <source>The maximum of &lt;code&gt;x1&lt;/code&gt; and &lt;code&gt;x2&lt;/code&gt;, element-wise. This is a scalar if both &lt;code&gt;x1&lt;/code&gt; and &lt;code&gt;x2&lt;/code&gt; are scalars.</source>
          <target state="translated">Максимум &lt;code&gt;x1&lt;/code&gt; и &lt;code&gt;x2&lt;/code&gt; поэлементно. Это скаляр, если и &lt;code&gt;x1&lt;/code&gt; , и &lt;code&gt;x2&lt;/code&gt; являются скалярами.</target>
        </trans-unit>
        <trans-unit id="0b24f05221f4af03e40635809a9e83b6c24ab35f" translate="yes" xml:space="preserve">
          <source>The maximum value along a given axis.</source>
          <target state="translated">Максимальное значение вдоль заданной оси.</target>
        </trans-unit>
        <trans-unit id="fda69f03e934be306357e5eceaea53c34ff9559a" translate="yes" xml:space="preserve">
          <source>The maximum value of an array along a given axis, ignores NaNs.</source>
          <target state="translated">Максимальное значение массива вдоль заданной оси,игнорирует NaNs.</target>
        </trans-unit>
        <trans-unit id="7815283b9ba6a866678fcbb140334dc5a033015a" translate="yes" xml:space="preserve">
          <source>The maximum value of an array along a given axis, ignoring any NaNs.</source>
          <target state="translated">Максимальное значение массива вдоль заданной оси,без учета любых NaN.</target>
        </trans-unit>
        <trans-unit id="d4de50ed13c4c863bfa3e8deacb7e5bde93f23df" translate="yes" xml:space="preserve">
          <source>The maximum value of an array along a given axis, propagates NaNs.</source>
          <target state="translated">Максимальное значение массива вдоль заданной оси,распространяет NaN.</target>
        </trans-unit>
        <trans-unit id="7ea2e2a635f47e2f3d7b25aa79029eb57056d0e6" translate="yes" xml:space="preserve">
          <source>The maximum value of an array along a given axis, propagating any NaNs.</source>
          <target state="translated">Максимальное значение массива вдоль заданной оси,распространяющего любые NaN.</target>
        </trans-unit>
        <trans-unit id="1062669c35965744b7646a80587bb754273c0111" translate="yes" xml:space="preserve">
          <source>The maximum value of an output element. Must be present to allow computation on empty slice. See &lt;a href=&quot;numpy.ufunc.reduce#numpy.ufunc.reduce&quot;&gt;&lt;code&gt;reduce&lt;/code&gt;&lt;/a&gt; for details.</source>
          <target state="translated">Максимальное значение выходного элемента. Должен присутствовать, чтобы разрешить вычисления на пустом срезе. Подробнее см. &lt;a href=&quot;numpy.ufunc.reduce#numpy.ufunc.reduce&quot;&gt; &lt;code&gt;reduce&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="4217fb4da5a1a61065cf374f0d2db5e29f625661" translate="yes" xml:space="preserve">
          <source>The mean is a coordinate in N-dimensional space, which represents the location where samples are most likely to be generated. This is analogous to the peak of the bell curve for the one-dimensional or univariate normal distribution.</source>
          <target state="translated">Среднее значение-это координата в N-мерном пространстве,которая представляет собой место,где образцы с наибольшей вероятностью могут быть сгенерированы.Это аналогично пику колоколообразной кривой для одномерного или одномерного нормального распределения.</target>
        </trans-unit>
        <trans-unit id="3afbef537c228c554c040f21270cfff32d76c2bc" translate="yes" xml:space="preserve">
          <source>The mean is normally calculated as &lt;code&gt;x.sum() / N&lt;/code&gt;, where &lt;code&gt;N = len(x)&lt;/code&gt;. If, however, &lt;code&gt;ddof&lt;/code&gt; is specified, the divisor &lt;code&gt;N - ddof&lt;/code&gt; is used instead. In standard statistical practice, &lt;code&gt;ddof=1&lt;/code&gt; provides an unbiased estimator of the variance of a hypothetical infinite population. &lt;code&gt;ddof=0&lt;/code&gt; provides a maximum likelihood estimate of the variance for normally distributed variables.</source>
          <target state="translated">Среднее значение обычно рассчитывается как &lt;code&gt;x.sum() / N&lt;/code&gt; , где &lt;code&gt;N = len(x)&lt;/code&gt; . Однако, &lt;code&gt;ddof&lt;/code&gt; указано &lt;code&gt;N - ddof&lt;/code&gt; вместо него используется делитель N - ddof . В стандартной статистической практике &lt;code&gt;ddof=1&lt;/code&gt; обеспечивает несмещенную оценку дисперсии гипотетической бесконечной совокупности. &lt;code&gt;ddof=0&lt;/code&gt; обеспечивает оценку максимального правдоподобия дисперсии для нормально распределенных переменных.</target>
        </trans-unit>
        <trans-unit id="6de47f27b421a49095ff1b82a99c964834e4c682" translate="yes" xml:space="preserve">
          <source>The mechanism we use to accomplish this goal may be unfamiliar for those who are not experienced with the cultural norms around free/open-source software development. We provide a summary here, and highly recommend that all Contributors additionally read &lt;a href=&quot;http://producingoss.com/en/producingoss.html#social-infrastructure&quot;&gt;Chapter 4: Social and Political Infrastructure&lt;/a&gt; of Karl Fogel&amp;rsquo;s classic &lt;em&gt;Producing Open Source Software&lt;/em&gt;, and in particular the section on &lt;a href=&quot;http://producingoss.com/en/producingoss.html#consensus-democracy&quot;&gt;Consensus-based Democracy&lt;/a&gt;, for a more detailed discussion.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="530a7cbb36983f7e2dde0f52c1c905d90e12e910" translate="yes" xml:space="preserve">
          <source>The mediator will engage with all the parties and seek a resolution that is satisfactory to all. Upon completion, the mediator will provide a report (vetted by all parties to the process) to the Committee, with recommendations on further steps. The Committee will then evaluate these results (whether satisfactory resolution was achieved or not) and decide on any additional action deemed necessary.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="476855af021420263dd600a85590e6b055b087d3" translate="yes" xml:space="preserve">
          <source>The members are</source>
          <target state="translated">Члены</target>
        </trans-unit>
        <trans-unit id="f25c150719f0aed3ef8299c88981d255d24f240e" translate="yes" xml:space="preserve">
          <source>The members of this structure are</source>
          <target state="translated">Членами этой структуры являются</target>
        </trans-unit>
        <trans-unit id="a80fc0f190e501871954ac9917a55a8bb93998fb" translate="yes" xml:space="preserve">
          <source>The memmap object can be used anywhere an ndarray is accepted. Given a memmap &lt;code&gt;fp&lt;/code&gt;, &lt;code&gt;isinstance(fp, numpy.ndarray)&lt;/code&gt; returns &lt;code&gt;True&lt;/code&gt;.</source>
          <target state="translated">Объект memmap можно использовать везде, где принимается ndarray. Учитывая memmap &lt;code&gt;fp&lt;/code&gt; , &lt;code&gt;isinstance(fp, numpy.ndarray)&lt;/code&gt; возвращает &lt;code&gt;True&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="afefc9cb88d75583ea623e16ea1f8cf60770f93a" translate="yes" xml:space="preserve">
          <source>The memory layout of an advanced indexing result is optimized for each indexing operation and no particular memory order can be assumed.</source>
          <target state="translated">Расположение памяти для результата расширенной индексации оптимизируется для каждой операции индексации,и не может быть принято никакого конкретного порядка памяти.</target>
        </trans-unit>
        <trans-unit id="76384eb2a7d5d22bbc5978606ad7f8f1173b53b8" translate="yes" xml:space="preserve">
          <source>The memory layout of structured datatypes allows fields at arbitrary byte offsets. This means the fields can be separated by padding bytes, their offsets can be non-monotonically increasing, and they can overlap.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5905e557d4f8798f2a63eb67ada3f5b47bd6cef3" translate="yes" xml:space="preserve">
          <source>The memory model for an ndarray admits arbitrary strides in each dimension to advance to the next element of the array. Often, however, you need to interface with code that expects a C-contiguous or a Fortran-contiguous memory layout. In addition, an ndarray can be misaligned (the address of an element is not at an integral multiple of the size of the element) which can cause your program to crash (or at least work more slowly) if you try and dereference a pointer into the array data. Both of these problems can be solved by converting the Python object into an array that is more &amp;ldquo;well-behaved&amp;rdquo; for your specific usage.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aca17bd9cdf5246e194be60887f21d5d2d2f6e20" translate="yes" xml:space="preserve">
          <source>The merged result.</source>
          <target state="translated">Объединенный результат.</target>
        </trans-unit>
        <trans-unit id="7df7fe557cb7d0b2f7c1ec9ba89a3700046e049a" translate="yes" xml:space="preserve">
          <source>The method should return either the result of the operation, or &lt;a href=&quot;https://docs.python.org/dev/library/constants.html#NotImplemented&quot;&gt;&lt;code&gt;NotImplemented&lt;/code&gt;&lt;/a&gt; if the operation requested is not implemented.</source>
          <target state="translated">Метод должен возвращать либо результат операции, либо &lt;a href=&quot;https://docs.python.org/dev/library/constants.html#NotImplemented&quot;&gt; &lt;code&gt;NotImplemented&lt;/code&gt; ,&lt;/a&gt; если запрошенная операция не реализована.</target>
        </trans-unit>
        <trans-unit id="a4edd76a8cc0cb5a2a3b89a3543cae8f78bd75ba" translate="yes" xml:space="preserve">
          <source>The method uses the following property for computation: let</source>
          <target state="translated">Метод использует для вычисления следующее свойство:let</target>
        </trans-unit>
        <trans-unit id="ad0d254fa1824d11c17af544fbf486dd80c358ac" translate="yes" xml:space="preserve">
          <source>The methods to estimate the optimal number of bins are well founded in literature, and are inspired by the choices R provides for histogram visualisation. Note that having the number of bins proportional to</source>
          <target state="translated">Методы оценки оптимального количества бункеров хорошо обоснованы в литературе,и вдохновлены выбором,который R предоставляет для визуализации гистограмм.Обратите внимание,что количество бин пропорционально</target>
        </trans-unit>
        <trans-unit id="3d7963e1ce4d80720f0895da566be576ac9149e1" translate="yes" xml:space="preserve">
          <source>The minimal data type.</source>
          <target state="translated">Минимальный тип данных.</target>
        </trans-unit>
        <trans-unit id="24db4b82ce9f82692c92a9ac46d90c6b64d6bb97" translate="yes" xml:space="preserve">
          <source>The minimum is equivalent to &lt;code&gt;np.where(x1 &amp;lt;= x2, x1, x2)&lt;/code&gt; when neither x1 nor x2 are NaNs, but it is faster and does proper broadcasting.</source>
          <target state="translated">Минимум эквивалентен &lt;code&gt;np.where(x1 &amp;lt;= x2, x1, x2)&lt;/code&gt; когда ни x1, ни x2 не являются NaN, но он быстрее и правильно передает.</target>
        </trans-unit>
        <trans-unit id="830a82f2ffde76e612c1dc506f1272bc14c9b4a2" translate="yes" xml:space="preserve">
          <source>The minimum of &lt;code&gt;x1&lt;/code&gt; and &lt;code&gt;x2&lt;/code&gt;, element-wise. This is a scalar if both &lt;code&gt;x1&lt;/code&gt; and &lt;code&gt;x2&lt;/code&gt; are scalars.</source>
          <target state="translated">Минимум &lt;code&gt;x1&lt;/code&gt; и &lt;code&gt;x2&lt;/code&gt; поэлементно. Это скаляр, если и &lt;code&gt;x1&lt;/code&gt; , и &lt;code&gt;x2&lt;/code&gt; являются скалярами.</target>
        </trans-unit>
        <trans-unit id="f7a8e12ffb3a7b028e99ec9cbaae32de38a438d0" translate="yes" xml:space="preserve">
          <source>The minimum representable value.</source>
          <target state="translated">Минимальное представляемое значение.</target>
        </trans-unit>
        <trans-unit id="78d2dd7cf3cdcedef397cc8cfe35854b295317af" translate="yes" xml:space="preserve">
          <source>The minimum value along a given axis.</source>
          <target state="translated">Минимальное значение вдоль заданной оси.</target>
        </trans-unit>
        <trans-unit id="7e0b0cb52a1bf19ef3e6bff0be136a12d77ae7e7" translate="yes" xml:space="preserve">
          <source>The minimum value of an array along a given axis, ignores NaNs.</source>
          <target state="translated">Минимальное значение массива вдоль заданной оси,игнорирует NaNs.</target>
        </trans-unit>
        <trans-unit id="d9e2b0a11e46ec4c3892cf8fdab488270aa4c95b" translate="yes" xml:space="preserve">
          <source>The minimum value of an array along a given axis, ignoring any NaNs.</source>
          <target state="translated">Минимальное значение массива вдоль заданной оси,без учета любых NaN.</target>
        </trans-unit>
        <trans-unit id="77d53ae61484ff6af896adddf96d0d76b8331b4b" translate="yes" xml:space="preserve">
          <source>The minimum value of an array along a given axis, propagates NaNs.</source>
          <target state="translated">Минимальное значение массива вдоль заданной оси,распространяет NaNs.</target>
        </trans-unit>
        <trans-unit id="f3f970ad0b31d892cafa6b5a21e637a9f0353aee" translate="yes" xml:space="preserve">
          <source>The minimum value of an array along a given axis, propagating any NaNs.</source>
          <target state="translated">Минимальное значение массива вдоль заданной оси,распространяющего любые NaN.</target>
        </trans-unit>
        <trans-unit id="9ae224843f4578886c03cad9e1377c9c95d0f44e" translate="yes" xml:space="preserve">
          <source>The minimum value of an output element. Must be present to allow computation on empty slice. See &lt;a href=&quot;numpy.ufunc.reduce#numpy.ufunc.reduce&quot;&gt;&lt;code&gt;reduce&lt;/code&gt;&lt;/a&gt; for details.</source>
          <target state="translated">Минимальное значение выходного элемента. Должен присутствовать, чтобы разрешить вычисления на пустом срезе. Подробнее см. &lt;a href=&quot;numpy.ufunc.reduce#numpy.ufunc.reduce&quot;&gt; &lt;code&gt;reduce&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="d437e19520a89179e90a54d1512529a938dad3c6" translate="yes" xml:space="preserve">
          <source>The mode should be one of:</source>
          <target state="translated">Режим должен быть одним из них:</target>
        </trans-unit>
        <trans-unit id="2ec84546189af066d8b391b45bfecb14d0737c14" translate="yes" xml:space="preserve">
          <source>The modified Bessel function evaluated at each of the elements of &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="translated">Модифицированная функция Бесселя вычисляется для каждого из элементов &lt;code&gt;x&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="852847496df2ea03e82e7e539f1768f78993a6b8" translate="yes" xml:space="preserve">
          <source>The more common 2-parameter Weibull, including a scale parameter</source>
          <target state="translated">Более распространенный 2-параметр Weibull,включая параметр шкалы.</target>
        </trans-unit>
        <trans-unit id="ec8c35dc12f2bc0af45e628c14f8329c8c69aba9" translate="yes" xml:space="preserve">
          <source>The most basic task that can be done with the &lt;a href=&quot;generated/numpy.nditer#numpy.nditer&quot;&gt;&lt;code&gt;nditer&lt;/code&gt;&lt;/a&gt; is to visit every element of an array. Each element is provided one by one using the standard Python iterator interface.</source>
          <target state="translated">Самая простая задача, которую можно выполнить с помощью &lt;a href=&quot;generated/numpy.nditer#numpy.nditer&quot;&gt; &lt;code&gt;nditer&lt;/code&gt; ,&lt;/a&gt; - это посетить каждый элемент массива. Каждый элемент предоставляется один за другим с использованием стандартного интерфейса итератора Python.</target>
        </trans-unit>
        <trans-unit id="d496ee7436ae1753a08460be49874cd0a97104de" translate="yes" xml:space="preserve">
          <source>The most basic way to create datetimes is from strings in ISO 8601 date or datetime format. The unit for internal storage is automatically selected from the form of the string, and can be either a &lt;a href=&quot;#arrays-dtypes-dateunits&quot;&gt;date unit&lt;/a&gt; or a &lt;a href=&quot;#arrays-dtypes-timeunits&quot;&gt;time unit&lt;/a&gt;. The date units are years (&amp;lsquo;Y&amp;rsquo;), months (&amp;lsquo;M&amp;rsquo;), weeks (&amp;lsquo;W&amp;rsquo;), and days (&amp;lsquo;D&amp;rsquo;), while the time units are hours (&amp;lsquo;h&amp;rsquo;), minutes (&amp;lsquo;m&amp;rsquo;), seconds (&amp;lsquo;s&amp;rsquo;), milliseconds (&amp;lsquo;ms&amp;rsquo;), and some additional SI-prefix seconds-based units.</source>
          <target state="translated">Самый простой способ создать дату и время - использовать строки в формате даты или времени ISO 8601. Единица измерения для внутренней памяти автоматически выбирается из формы строки и может быть &lt;a href=&quot;#arrays-dtypes-dateunits&quot;&gt;единицей измерения даты&lt;/a&gt; или &lt;a href=&quot;#arrays-dtypes-timeunits&quot;&gt;времени&lt;/a&gt; . Единицы измерения даты - годы ('Y'), месяцы ('M'), недели ('W') и дни ('D'), а единицы времени - часы ('h'), минуты ('m' ), секунды ('s'), миллисекунды ('ms') и некоторые дополнительные единицы измерения секунд на основе префикса СИ.</target>
        </trans-unit>
        <trans-unit id="3f0f24060330e42125d74f607b6b6b61511b55b5" translate="yes" xml:space="preserve">
          <source>The most basic way to create datetimes is from strings in ISO 8601 date or datetime format. The unit for internal storage is automatically selected from the form of the string, and can be either a &lt;a href=&quot;#arrays-dtypes-dateunits&quot;&gt;date unit&lt;/a&gt; or a &lt;a href=&quot;#arrays-dtypes-timeunits&quot;&gt;time unit&lt;/a&gt;. The date units are years (&amp;lsquo;Y&amp;rsquo;), months (&amp;lsquo;M&amp;rsquo;), weeks (&amp;lsquo;W&amp;rsquo;), and days (&amp;lsquo;D&amp;rsquo;), while the time units are hours (&amp;lsquo;h&amp;rsquo;), minutes (&amp;lsquo;m&amp;rsquo;), seconds (&amp;lsquo;s&amp;rsquo;), milliseconds (&amp;lsquo;ms&amp;rsquo;), and some additional SI-prefix seconds-based units. The datetime64 data type also accepts the string &amp;ldquo;NAT&amp;rdquo;, in any combination of lowercase/uppercase letters, for a &amp;ldquo;Not A Time&amp;rdquo; value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="66cbaf133a9d7fa2f2885d6f3bc9c4d230706591" translate="yes" xml:space="preserve">
          <source>The most common use of this function is to build a block matrix</source>
          <target state="translated">Наиболее часто эта функция используется для построения блочной матрицы</target>
        </trans-unit>
        <trans-unit id="d15c9fb7581762b1e666994a9299d27d87d30396" translate="yes" xml:space="preserve">
          <source>The most natural way one can think of for boolean indexing is to use boolean arrays that have &lt;em&gt;the same shape&lt;/em&gt; as the original array:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9781573736aca31c85fa33ce77a1caad972dd370" translate="yes" xml:space="preserve">
          <source>The most negative power of the base (2) consistent with there being no leading 0&amp;rsquo;s in the mantissa.</source>
          <target state="translated">Наибольшая отрицательная степень основания (2) соответствует отсутствию ведущих нулей в мантиссе.</target>
        </trans-unit>
        <trans-unit id="fb15b7417ee56d15205cea48f990a823be057c87" translate="yes" xml:space="preserve">
          <source>The multidimensional histogram of sample x. See normed and weights for the different possible semantics.</source>
          <target state="translated">Многомерная гистограмма образца x.Смотрите норму и веса для различных возможных семантик.</target>
        </trans-unit>
        <trans-unit id="8be5b73af053c4fe54ab6b95a4f36c70767b3576" translate="yes" xml:space="preserve">
          <source>The multinomial distribution is a multivariate generalization of the binomial distribution. Take an experiment with one of &lt;code&gt;p&lt;/code&gt; possible outcomes. An example of such an experiment is throwing a dice, where the outcome can be 1 through 6. Each sample drawn from the distribution represents &lt;code&gt;n&lt;/code&gt; such experiments. Its values, &lt;code&gt;X_i = [X_0, X_1, ..., X_p]&lt;/code&gt;, represent the number of times the outcome was &lt;code&gt;i&lt;/code&gt;.</source>
          <target state="translated">Полиномиальное распределение - это многомерное обобщение биномиального распределения. Проведите эксперимент с одним из &lt;code&gt;p&lt;/code&gt; возможных результатов. Примером такого эксперимента является бросание кости, где результат может быть от 1 до 6. Каждая выборка, взятая из распределения, представляет &lt;code&gt;n&lt;/code&gt; таких экспериментов. Его значения, &lt;code&gt;X_i = [X_0, X_1, ..., X_p]&lt;/code&gt; , представляют количество раз, когда результатом было &lt;code&gt;i&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6e35df9de409e360898297beb49d42cda54d84d4" translate="yes" xml:space="preserve">
          <source>The multiplication uses the recursion relationship for Hermite polynomials in the form</source>
          <target state="translated">Умножение использует рекурсивное соотношение для полиномов Эрмита в виде</target>
        </trans-unit>
        <trans-unit id="5d48b11de72371fe59540d3a1093cd7c7ef9026d" translate="yes" xml:space="preserve">
          <source>The multiplication uses the recursion relationship for Laguerre polynomials in the form</source>
          <target state="translated">Умножение использует рекурсивное соотношение для полиномов Лагуэрра в виде</target>
        </trans-unit>
        <trans-unit id="1da9d21187f4507f9a0b400fa81210b7d7adb8cd" translate="yes" xml:space="preserve">
          <source>The multiplication uses the recursion relationship for Legendre polynomials in the form</source>
          <target state="translated">Умножение использует рекурсивное соотношение для полиномов Легенды в виде</target>
        </trans-unit>
        <trans-unit id="28fc83b7bf97d866e44dde49fafcb06224f49002" translate="yes" xml:space="preserve">
          <source>The multithreaded random number generator can be used to fill an array. The &lt;code&gt;values&lt;/code&gt; attributes shows the zero-value before the fill and the random value after.</source>
          <target state="translated">Многопоточный генератор случайных чисел может использоваться для заполнения массива. Эти &lt;code&gt;values&lt;/code&gt; атрибутов показывают нулевое значения перед заливкой и случайного значения после.</target>
        </trans-unit>
        <trans-unit id="b9bbb85b9ae78b76721288cfcfe9a4008f15e026" translate="yes" xml:space="preserve">
          <source>The multivariate hypergeometric distribution is a generalization of the hypergeometric distribution.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4747005456762b666a88180df9655da6422f2a03" translate="yes" xml:space="preserve">
          <source>The multivariate normal, multinormal or Gaussian distribution is a generalization of the one-dimensional normal distribution to higher dimensions. Such a distribution is specified by its mean and covariance matrix. These parameters are analogous to the mean (average or &amp;ldquo;center&amp;rdquo;) and variance (standard deviation, or &amp;ldquo;width,&amp;rdquo; squared) of the one-dimensional normal distribution.</source>
          <target state="translated">Многомерное нормальное, полинормальное или гауссово распределение является обобщением одномерного нормального распределения на более высокие измерения. Такое распределение определяется его средним значением и матрицей ковариации. Эти параметры аналогичны среднему (среднее или &amp;laquo;центр&amp;raquo;) и дисперсии (стандартное отклонение или &amp;laquo;ширина&amp;raquo; в квадрате) одномерного нормального распределения.</target>
        </trans-unit>
        <trans-unit id="a8b77cd2da64c5a2ad3fe22e334603fd46922d44" translate="yes" xml:space="preserve">
          <source>The mymethods must be an array (usually statically declared) of PyMethodDef structures which contain method names, actual C-functions, a variable indicating whether the method uses keyword arguments or not, and docstrings. These are explained in the next section. If you want to add constants to the module, then you store the returned value from Py_InitModule which is a module object. The most general way to add items to the module is to get the module dictionary using PyModule_GetDict(module). With the module dictionary, you can add whatever you like to the module manually. An easier way to add objects to the module is to use one of three additional Python C-API calls that do not require a separate extraction of the module dictionary. These are documented in the Python documentation, but repeated here for convenience:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="acd94e258d3a5164d9494ffb8bffe2f44669511c" translate="yes" xml:space="preserve">
          <source>The n-dimensional FFT.</source>
          <target state="translated">n-мерный БПФ.</target>
        </trans-unit>
        <trans-unit id="6c60f6d35e1563484077efd2da3ec7438c9b55d8" translate="yes" xml:space="preserve">
          <source>The n-dimensional array</source>
          <target state="translated">n-мерный массив</target>
        </trans-unit>
        <trans-unit id="3b220f6b818351a33b819aef741ffc069011f1f9" translate="yes" xml:space="preserve">
          <source>The n-dimensional inverse FFT.</source>
          <target state="translated">n-мерный обратный БПФ.</target>
        </trans-unit>
        <trans-unit id="e1700cb4660502cb99b1ba6b83abc787863343a8" translate="yes" xml:space="preserve">
          <source>The n-th differences. The shape of the output is the same as &lt;code&gt;a&lt;/code&gt; except along &lt;code&gt;axis&lt;/code&gt; where the dimension is smaller by &lt;code&gt;n&lt;/code&gt;. The type of the output is the same as the type of the difference between any two elements of &lt;code&gt;a&lt;/code&gt;. This is the same as the type of &lt;code&gt;a&lt;/code&gt; in most cases. A notable exception is &lt;code&gt;datetime64&lt;/code&gt;, which results in a &lt;code&gt;timedelta64&lt;/code&gt; output array.</source>
          <target state="translated">N-е отличия. Форма вывода такая же, как у &lt;code&gt;a&lt;/code&gt; , за исключением &lt;code&gt;axis&lt;/code&gt; где размер меньше на &lt;code&gt;n&lt;/code&gt; . Тип вывода такой же, как и тип различия между любыми двумя элементами &lt;code&gt;a&lt;/code&gt; . В большинстве случаев это то же самое, что и тип &lt;code&gt;a&lt;/code&gt; . Заметным исключением является &lt;code&gt;datetime64&lt;/code&gt; , результатом которого является выходной массив &lt;code&gt;timedelta64&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="bbebdf33e8d96895ad0ed5b9400d54086fef2b67" translate="yes" xml:space="preserve">
          <source>The name &lt;code&gt;colors&lt;/code&gt; comes from a common description of the distribution: it is the probability distribution of the number of marbles of each color selected without replacement from an urn containing marbles of different colors; &lt;code&gt;colors[i]&lt;/code&gt; is the number of marbles in the urn with color &lt;code&gt;i&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0669ec99aeb2d5368091f67cb13b60ba81e67528" translate="yes" xml:space="preserve">
          <source>The name of an encoding</source>
          <target state="translated">Название кодировки</target>
        </trans-unit>
        <trans-unit id="da19f645db8ba8aaf5c7216ec7214ec27975bb88" translate="yes" xml:space="preserve">
          <source>The name of each column, e.g. &lt;code&gt;('x', 'y', 'z')&lt;/code&gt;.</source>
          <target state="translated">Имя каждого столбца, например &lt;code&gt;('x', 'y', 'z')&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a2c5edd467b851569da4a2dda38a270ee36e54ad" translate="yes" xml:space="preserve">
          <source>The name of the compiled python module</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a9271935a282dc40ee28d57c245df327643e67b9" translate="yes" xml:space="preserve">
          <source>The name of the function comes from the acronym for &amp;lsquo;peak to peak&amp;rsquo;.</source>
          <target state="translated">Название функции происходит от акронима &amp;laquo;от пика до пика&amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="d407bb92d1b152453450af784d89f7deb9d12336" translate="yes" xml:space="preserve">
          <source>The name of the function to be deprecated. Default is None, in which case the name of &lt;code&gt;func&lt;/code&gt; is used.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bb2cb1a8dd236bcfb532f7c48c470cce2101b1ff" translate="yes" xml:space="preserve">
          <source>The name of the polynomial variable</source>
          <target state="translated">Имя полиномиальной переменной</target>
        </trans-unit>
        <trans-unit id="48bd936a95b9da34fbbddac207b9c61cefe6e361" translate="yes" xml:space="preserve">
          <source>The name of the ufunc.</source>
          <target state="translated">Имя ufunc.</target>
        </trans-unit>
        <trans-unit id="8afcf394e9ae5bb9fa899425c9a8ba31df0dd746" translate="yes" xml:space="preserve">
          <source>The name sinc is short for &amp;ldquo;sine cardinal&amp;rdquo; or &amp;ldquo;sinus cardinalis&amp;rdquo;.</source>
          <target state="translated">Название sinc является сокращением от &amp;laquo;sine cardinal&amp;raquo; или &amp;laquo;sinus cardinalis&amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="429822cfcff1010e8a45d7946ea2696aeb70a3d1" translate="yes" xml:space="preserve">
          <source>The names are ordered according to increasing byte offset. This can be used, for example, to walk through all of the named fields in offset order.</source>
          <target state="translated">Названия упорядочены в соответствии со смещением по возрастанию байтов.Это может быть использовано,например,для прохода по всем названным полям в порядке смещения.</target>
        </trans-unit>
        <trans-unit id="d89404c184de8cb612b9ba60ba8159aea12d80ca" translate="yes" xml:space="preserve">
          <source>The names for the types in c code follows c naming conventions more closely. The Python names for these types follow Python conventions. Thus, &lt;a href=&quot;#c.NPY_FLOAT&quot;&gt;&lt;code&gt;NPY_FLOAT&lt;/code&gt;&lt;/a&gt; picks up a 32-bit float in C, but &lt;code&gt;numpy.float_&lt;/code&gt; in Python corresponds to a 64-bit double. The bit-width names can be used in both Python and C for clarity.</source>
          <target state="translated">Имена типов в коде c более точно соответствуют соглашениям об именовании. Имена Python для этих типов соответствуют соглашениям Python. Таким образом, &lt;a href=&quot;#c.NPY_FLOAT&quot;&gt; &lt;code&gt;NPY_FLOAT&lt;/code&gt; &lt;/a&gt; принимает 32-битное число с плавающей запятой в C, но &lt;code&gt;numpy.float_&lt;/code&gt; в Python соответствует 64-битному типу double. Для ясности имена разрядности могут использоваться как в Python, так и в C.</target>
        </trans-unit>
        <trans-unit id="7042a6f0e554df217f55061c01efbcd355c420f8" translate="yes" xml:space="preserve">
          <source>The names of the fields are given with the &lt;code&gt;names&lt;/code&gt; arguments, the corresponding values with the &lt;code&gt;data&lt;/code&gt; arguments. If a single field is appended, &lt;code&gt;names&lt;/code&gt;, &lt;code&gt;data&lt;/code&gt; and &lt;code&gt;dtypes&lt;/code&gt; do not have to be lists but just values.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="be2b0c55353c6ed87f255a0400693d129089b164" translate="yes" xml:space="preserve">
          <source>The native NumPy indexing type is &lt;code&gt;intp&lt;/code&gt; and may differ from the default integer array type. &lt;code&gt;intp&lt;/code&gt; is the smallest data type sufficient to safely index any array; for advanced indexing it may be faster than other types.</source>
          <target state="translated">Собственный тип индексации NumPy - &lt;code&gt;intp&lt;/code&gt; и может отличаться от целочисленного типа массива по умолчанию. &lt;code&gt;intp&lt;/code&gt; - наименьший тип данных, достаточный для безопасного индексирования любого массива; для расширенного индексирования он может быть быстрее, чем другие типы.</target>
        </trans-unit>
        <trans-unit id="762cb1cca826c6e2247cb37d4810072af245272b" translate="yes" xml:space="preserve">
          <source>The natural log of the absolute value of the determinant.</source>
          <target state="translated">Естественный журнал абсолютного значения детерминанта.</target>
        </trans-unit>
        <trans-unit id="b3888cd1c7265c4b4a7bad4003632b69982812b1" translate="yes" xml:space="preserve">
          <source>The natural logarithm &lt;a href=&quot;#numpy.log&quot;&gt;&lt;code&gt;log&lt;/code&gt;&lt;/a&gt; is the inverse of the exponential function, so that &lt;code&gt;log(exp(x)) = x&lt;/code&gt;. The natural logarithm is logarithm in base &lt;a href=&quot;../constants#numpy.e&quot;&gt;&lt;code&gt;e&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Натуральный логарифм &lt;a href=&quot;#numpy.log&quot;&gt; &lt;code&gt;log&lt;/code&gt; &lt;/a&gt; является обратной экспоненциальной функцией, поэтому &lt;code&gt;log(exp(x)) = x&lt;/code&gt; . Натуральный логарифм - это логарифм по основанию &lt;a href=&quot;../constants#numpy.e&quot;&gt; &lt;code&gt;e&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="133131ae7b63a1c0b2c215fb536c3aee797a1a49" translate="yes" xml:space="preserve">
          <source>The natural logarithm of &lt;code&gt;x&lt;/code&gt;, element-wise. This is a scalar if &lt;code&gt;x&lt;/code&gt; is a scalar.</source>
          <target state="translated">Натуральный логарифм &lt;code&gt;x&lt;/code&gt; поэлементно. Это скаляр, если &lt;code&gt;x&lt;/code&gt; - скаляр.</target>
        </trans-unit>
        <trans-unit id="79018bd215ed2a4de07a7be8acb4bd00eb575cb1" translate="yes" xml:space="preserve">
          <source>The nditer can no longer be iterated once either &lt;code&gt;close&lt;/code&gt; is called or its context is exited.</source>
          <target state="translated">Nditer больше не может повторяться после вызова &lt;code&gt;close&lt;/code&gt; или выхода из его контекста.</target>
        </trans-unit>
        <trans-unit id="fba110cc07d7918f904cb2219cd75774f5e101fe" translate="yes" xml:space="preserve">
          <source>The nditer will then yield writeable buffer arrays which you may modify. However, because the nditer must copy this buffer data back to the original array once iteration is finished, you must signal when the iteration is ended, by one of two methods. You may either:</source>
          <target state="translated">Затем nditer выдаст буферные массивы с возможностью записи,которые Вы можете модифицировать.Однако,так как nditer должен скопировать эти буферные данные обратно в исходный массив после завершения итерации,Вы должны подать сигнал об окончании итерации одним из двух методов.Вы тоже можете:</target>
        </trans-unit>
        <trans-unit id="36c9f1e0a0257851539d48df01a2ed2f053f22d7" translate="yes" xml:space="preserve">
          <source>The new array is formed from the data in the old array, repeated if necessary to fill out the required number of elements. The data are repeated in the order that they are stored in memory.</source>
          <target state="translated">Новый массив формируется из данных старого массива,повторяется при необходимости заполнения необходимого количества элементов.Данные повторяются в том порядке,в котором они хранятся в памяти.</target>
        </trans-unit>
        <trans-unit id="a04e3c53d25194cf3b0ad0e57f30edc1bdcf03db" translate="yes" xml:space="preserve">
          <source>The new array will have a new last dimension equal in size to the number of field-elements of the input array. If not supplied, the output datatype is determined from the numpy type promotion rules applied to all the field datatypes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f97568b5d149f57d8764f77c287f9f2fe46a132b" translate="yes" xml:space="preserve">
          <source>The new behavior as of Numpy 1.16 leads to extra &amp;ldquo;padding&amp;rdquo; bytes at the location of unindexed fields compared to 1.15. You will need to update any code which depends on the data having a &amp;ldquo;packed&amp;rdquo; layout. For instance code such as:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1e027640aca67041dbf9c118ab74b0f73d41441e" translate="yes" xml:space="preserve">
          <source>The new infrastructure takes a different approach to producing random numbers from the &lt;a href=&quot;legacy#numpy.random.RandomState&quot;&gt;&lt;code&gt;RandomState&lt;/code&gt;&lt;/a&gt; object. Random number generation is separated into two components, a bit generator and a random generator.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5d98e8d2c80f824b8ece662a9850103c0477cac7" translate="yes" xml:space="preserve">
          <source>The new infrastructure takes a different approach to producing random numbers from the &lt;a href=&quot;legacy#numpy.random.mtrand.RandomState&quot;&gt;&lt;code&gt;RandomState&lt;/code&gt;&lt;/a&gt; object. Random number generation is separated into two components, a bit generator and a random generator.</source>
          <target state="translated">В новой инфраструктуре используется другой подход к созданию случайных чисел из объекта &lt;a href=&quot;legacy#numpy.random.mtrand.RandomState&quot;&gt; &lt;code&gt;RandomState&lt;/code&gt; &lt;/a&gt; . Генерация случайных чисел разделена на два компонента: битовый генератор и случайный генератор.</target>
        </trans-unit>
        <trans-unit id="125105242ec81f06cd25f403baeb3cf1e8d9cd77" translate="yes" xml:space="preserve">
          <source>The new interface has docstring:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="86aae80fcd76b7ce0d8ebf83a57b3d06b3426d61" translate="yes" xml:space="preserve">
          <source>The new keyword argument interface and &lt;code&gt;excluded&lt;/code&gt; argument support further degrades performance.</source>
          <target state="translated">Новый интерфейс аргумента ключевого слова и поддержка &lt;code&gt;excluded&lt;/code&gt; аргумента еще больше ухудшают производительность.</target>
        </trans-unit>
        <trans-unit id="d86ea97e67bbca694f01bcdba7b94c4f6336cda1" translate="yes" xml:space="preserve">
          <source>The new name for the function. Default is None, in which case the deprecation message is that &lt;code&gt;old_name&lt;/code&gt; is deprecated. If given, the deprecation message is that &lt;code&gt;old_name&lt;/code&gt; is deprecated and &lt;code&gt;new_name&lt;/code&gt; should be used instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="55a87f3b341973ae0ced92b1f1a3e3e7074aa9e8" translate="yes" xml:space="preserve">
          <source>The new shape should be compatible with the original shape. If an integer is supplied, then the result will be a 1-D array of that length.</source>
          <target state="translated">Новая форма должна быть совместима с оригинальной формой.Если поставляется целое число,то результатом будет 1-D массив этой длины.</target>
        </trans-unit>
        <trans-unit id="691ae079d9ba62e9263b39950b26bbea5ce21d52" translate="yes" xml:space="preserve">
          <source>The new shape should be compatible with the original shape. If an integer, then the result will be a 1-D array of that length. One shape dimension can be -1. In this case, the value is inferred from the length of the array and remaining dimensions.</source>
          <target state="translated">Новая форма должна быть совместима с оригинальной формой.Если целое число,то результатом будет 1-D массив этой длины.Одно измерение фигуры может быть -1.В этом случае значение выводится из длины массива и остальных измерений.</target>
        </trans-unit>
        <trans-unit id="5388ec77c34409cb3cbd101b8eec670a3d1a1fdf" translate="yes" xml:space="preserve">
          <source>The next 1 byte is an unsigned byte: the major version number of the file format, e.g. &lt;code&gt;\x01&lt;/code&gt;.</source>
          <target state="translated">Следующий 1 байт - это беззнаковый байт: старший номер версии формата файла, например &lt;code&gt;\x01&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="728636cfde682c4ca8ef5825e1a61b87b60f117f" translate="yes" xml:space="preserve">
          <source>The next 1 byte is an unsigned byte: the minor version number of the file format, e.g. &lt;code&gt;\x00&lt;/code&gt;. Note: the version of the file format is not tied to the version of the numpy package.</source>
          <target state="translated">Следующий 1 байт - это беззнаковый байт: младший номер версии формата файла, например &lt;code&gt;\x00&lt;/code&gt; . Примечание: версия формата файла не привязана к версии пакета numpy.</target>
        </trans-unit>
        <trans-unit id="87a88c47d7bd9a05055f3613db15f890d4b10172" translate="yes" xml:space="preserve">
          <source>The next 2 bytes form a little-endian unsigned short int: the length of the header data HEADER_LEN.</source>
          <target state="translated">Следующие 2 байта образуют little-endian unsigned short int:длина заголовочных данных HEADER_LEN.</target>
        </trans-unit>
        <trans-unit id="c0777c38aebc3061e6b58d63a6472bc19821f955" translate="yes" xml:space="preserve">
          <source>The next HEADER_LEN bytes form the header data describing the array&amp;rsquo;s format. It is an ASCII string which contains a Python literal expression of a dictionary. It is terminated by a newline (&lt;code&gt;\n&lt;/code&gt;) and padded with spaces (&lt;code&gt;\x20&lt;/code&gt;) to make the total of &lt;code&gt;len(magic string) + 2 + len(length) + HEADER_LEN&lt;/code&gt; be evenly divisible by 64 for alignment purposes.</source>
          <target state="translated">Следующие байты HEADER_LEN формируют данные заголовка, описывающие формат массива. Это строка ASCII, которая содержит буквальное выражение словаря Python. Он заканчивается символом новой строки ( &lt;code&gt;\n&lt;/code&gt; ) и дополняется пробелами ( &lt;code&gt;\x20&lt;/code&gt; ), чтобы сумма &lt;code&gt;len(magic string) + 2 + len(length) + HEADER_LEN&lt;/code&gt; на 64 для целей выравнивания.</target>
        </trans-unit>
        <trans-unit id="af4ca037dcfe75d78dee9fbf52e144a1bd398782" translate="yes" xml:space="preserve">
          <source>The next floating point value after x1 towards x2</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="82fde05cc761629191474fcaee36452854b7c17c" translate="yes" xml:space="preserve">
          <source>The next representable values of &lt;code&gt;x1&lt;/code&gt; in the direction of &lt;code&gt;x2&lt;/code&gt;. This is a scalar if both &lt;code&gt;x1&lt;/code&gt; and &lt;code&gt;x2&lt;/code&gt; are scalars.</source>
          <target state="translated">Следующие представимые значения &lt;code&gt;x1&lt;/code&gt; в направлении &lt;code&gt;x2&lt;/code&gt; . Это скаляр, если и &lt;code&gt;x1&lt;/code&gt; , и &lt;code&gt;x2&lt;/code&gt; являются скалярами.</target>
        </trans-unit>
        <trans-unit id="4935ecbe795efbe6b2d076bc80d266ef9b3d3b31" translate="yes" xml:space="preserve">
          <source>The next step depends on the type of index which was found. If all dimensions are indexed with an integer a scalar is returned or set. A single boolean indexing array will call specialized boolean functions. Indices containing an ellipsis or slice but no advanced indexing will always create a view into the old array by calculating the new strides and memory offset. This view can then either be returned or, for assignments, filled using &lt;code&gt;PyArray_CopyObject&lt;/code&gt;. Note that &lt;code&gt;PyArray_CopyObject&lt;/code&gt; may also be called on temporary arrays in other branches to support complicated assignments when the array is of object dtype.</source>
          <target state="translated">Следующий шаг зависит от типа найденного индекса. Если все измерения проиндексированы целым числом, возвращается или устанавливается скаляр. Один логический массив индексации будет вызывать специализированные логические функции. Индексы, содержащие многоточие или срез, но без расширенного индексирования, всегда будут создавать представление в старый массив, вычисляя новые шаги и смещение памяти. Затем это представление можно либо вернуть, либо, для назначений, заполнить с помощью &lt;code&gt;PyArray_CopyObject&lt;/code&gt; . Обратите внимание, что &lt;code&gt;PyArray_CopyObject&lt;/code&gt; может также вызываться для временных массивов в других ветвях для поддержки сложных назначений, когда массив имеет объект dtype.</target>
        </trans-unit>
        <trans-unit id="bdf75a3a6e21cea0d77ec634980ca032f5eeb858" translate="yes" xml:space="preserve">
          <source>The next table presents the performance in percentage relative to values generated by the legacy generator, &lt;code&gt;RandomState(MT19937())&lt;/code&gt;. The overall performance was computed using a geometric mean.</source>
          <target state="translated">В следующей таблице представлена ​​производительность в процентах относительно значений, сгенерированных устаревшим генератором &lt;code&gt;RandomState(MT19937())&lt;/code&gt; . Общая производительность вычислялась с использованием среднего геометрического.</target>
        </trans-unit>
        <trans-unit id="5462948418f50794d8b059e0adf72cefb6356af5" translate="yes" xml:space="preserve">
          <source>The nice interface can also be generated automatically by placing the variable directives as special comments in the original fortran code. Thus, if I modify the source code to contain:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0153c9bc357a3afb289f46e1296cad96a6ebfe64" translate="yes" xml:space="preserve">
          <source>The noncentral</source>
          <target state="translated">Нецентральный</target>
        </trans-unit>
        <trans-unit id="007f1b9babda9d4c7b56259360ff2b4902c7689b" translate="yes" xml:space="preserve">
          <source>The normal distributions occurs often in nature. For example, it describes the commonly occurring distribution of samples influenced by a large number of tiny, random disturbances, each with its own unique distribution &lt;a href=&quot;#r1536f9c044a3-2&quot; id=&quot;id2&quot;&gt;[2]&lt;/a&gt;.</source>
          <target state="translated">Нормальное распределение часто встречается в природе. Например, он описывает обычно встречающееся распределение выборок, на которое влияет большое количество крошечных случайных возмущений, каждое из которых имеет свое уникальное распределение &lt;a href=&quot;#r1536f9c044a3-2&quot; id=&quot;id2&quot;&gt;[2]&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="2acd5981a8ea796b96e83bb6555be4413ecc4212" translate="yes" xml:space="preserve">
          <source>The normal distributions occurs often in nature. For example, it describes the commonly occurring distribution of samples influenced by a large number of tiny, random disturbances, each with its own unique distribution &lt;a href=&quot;#ra2e838c5ea87-2&quot; id=&quot;id2&quot;&gt;[2]&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="edcb775700a94ba4ed282cab54aed1dcf6bc2923" translate="yes" xml:space="preserve">
          <source>The normal distributions occurs often in nature. For example, it describes the commonly occurring distribution of samples influenced by a large number of tiny, random disturbances, each with its own unique distribution &lt;a href=&quot;#rce7db652c312-2&quot; id=&quot;id2&quot;&gt;[2]&lt;/a&gt;.</source>
          <target state="translated">Нормальное распределение часто встречается в природе. Например, он описывает обычно встречающееся распределение выборок, на которое влияет большое количество крошечных случайных возмущений, каждое из которых имеет свое уникальное распределение &lt;a href=&quot;#rce7db652c312-2&quot; id=&quot;id2&quot;&gt;[2]&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="0e795cd0114f2e83de16303b01c212b1bae08ff6" translate="yes" xml:space="preserve">
          <source>The normal distributions occurs often in nature. For example, it describes the commonly occurring distribution of samples influenced by a large number of tiny, random disturbances, each with its own unique distribution &lt;a href=&quot;#rf578abb8fba2-2&quot; id=&quot;id2&quot;&gt;[2]&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="966686da674deab5a174046b2e8990436c2787f9" translate="yes" xml:space="preserve">
          <source>The normal, exponential and gamma generators use 256-step Ziggurat methods which are 2-10 times faster than NumPy&amp;rsquo;s default implementation in &lt;a href=&quot;generated/numpy.random.generator.standard_normal#numpy.random.Generator.standard_normal&quot;&gt;&lt;code&gt;standard_normal&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;generated/numpy.random.generator.standard_exponential#numpy.random.Generator.standard_exponential&quot;&gt;&lt;code&gt;standard_exponential&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;generated/numpy.random.generator.standard_gamma#numpy.random.Generator.standard_gamma&quot;&gt;&lt;code&gt;standard_gamma&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Нормальный, экспоненциальный и гамма-генераторы используют 256-шаговые методы Ziggurat, которые в 2-10 раз быстрее, чем реализация по умолчанию NumPy в &lt;a href=&quot;generated/numpy.random.generator.standard_normal#numpy.random.Generator.standard_normal&quot;&gt; &lt;code&gt;standard_normal&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;generated/numpy.random.generator.standard_exponential#numpy.random.Generator.standard_exponential&quot;&gt; &lt;code&gt;standard_exponential&lt;/code&gt; &lt;/a&gt; или &lt;a href=&quot;generated/numpy.random.generator.standard_gamma#numpy.random.Generator.standard_gamma&quot;&gt; &lt;code&gt;standard_gamma&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="725e48eaa30d1b2cbd58c002507d29063f93ce22" translate="yes" xml:space="preserve">
          <source>The normalized (unit &amp;ldquo;length&amp;rdquo;) eigenvectors, such that the column &lt;code&gt;v[:,i]&lt;/code&gt; is the eigenvector corresponding to the eigenvalue &lt;code&gt;w[i]&lt;/code&gt;.</source>
          <target state="translated">Нормализованные (единичные &amp;laquo;длина&amp;raquo;) собственные векторы, такие, что столбец &lt;code&gt;v[:,i]&lt;/code&gt; является собственным вектором, соответствующим собственному значению &lt;code&gt;w[i]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3299e827c6aa0d2d0f05fb49e420b7948a6917ca" translate="yes" xml:space="preserve">
          <source>The normed arguments of &lt;code&gt;histogramdd&lt;/code&gt; and &lt;code&gt;histogram2d&lt;/code&gt; have been renamed</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4a2bc0ba793eb9bb3e0347a0cebea0eac0618ee5" translate="yes" xml:space="preserve">
          <source>The nuclear norm is the sum of the singular values.</source>
          <target state="translated">Ядерная норма-это сумма единичных значений.</target>
        </trans-unit>
        <trans-unit id="fb33d48b0d271638a6f54e06bd5c7431683a4b77" translate="yes" xml:space="preserve">
          <source>The number 13 has the binaray representation &lt;code&gt;00001101&lt;/code&gt;. Likewise, 16 is represented by &lt;code&gt;00010000&lt;/code&gt;. The bit-wise OR of 13 and 16 is then &lt;code&gt;000111011&lt;/code&gt;, or 29:</source>
          <target state="translated">Число 13 имеет бинарное представление &lt;code&gt;00001101&lt;/code&gt; . Аналогично, 16 представлено &lt;code&gt;00010000&lt;/code&gt; . Побитовое ИЛИ 13 и 16 будет &lt;code&gt;000111011&lt;/code&gt; , или 29:</target>
        </trans-unit>
        <trans-unit id="9301b88af54fb2d08827d44439e6252ad34f0666" translate="yes" xml:space="preserve">
          <source>The number 13 is represented by &lt;code&gt;00001101&lt;/code&gt;. Likewise, 17 is represented by &lt;code&gt;00010001&lt;/code&gt;. The bit-wise AND of 13 and 17 is therefore &lt;code&gt;000000001&lt;/code&gt;, or 1:</source>
          <target state="translated">Число 13 представлено &lt;code&gt;00001101&lt;/code&gt; . Аналогично, 17 представлен &lt;code&gt;00010001&lt;/code&gt; . Побитовое И 13 и 17, следовательно, равно &lt;code&gt;000000001&lt;/code&gt; или 1:</target>
        </trans-unit>
        <trans-unit id="5dd5ca9f1bd4e589a273ee53560b9a52127f59e7" translate="yes" xml:space="preserve">
          <source>The number 13 is represented by &lt;code&gt;00001101&lt;/code&gt;. Likewise, 17 is represented by &lt;code&gt;00010001&lt;/code&gt;. The bit-wise XOR of 13 and 17 is therefore &lt;code&gt;00011100&lt;/code&gt;, or 28:</source>
          <target state="translated">Число 13 представлено &lt;code&gt;00001101&lt;/code&gt; . Аналогично, 17 представлен &lt;code&gt;00010001&lt;/code&gt; . Побитовое исключающее ИЛИ 13 и 17, следовательно, &lt;code&gt;00011100&lt;/code&gt; или 28:</target>
        </trans-unit>
        <trans-unit id="d78115c4219b81e0960ff03256ee289bd93dfe48" translate="yes" xml:space="preserve">
          <source>The number &lt;code&gt;w&lt;/code&gt; is an eigenvalue of &lt;code&gt;a&lt;/code&gt; if there exists a vector &lt;code&gt;v&lt;/code&gt; such that &lt;code&gt;a @ v = w * v&lt;/code&gt;. Thus, the arrays &lt;code&gt;a&lt;/code&gt;, &lt;code&gt;w&lt;/code&gt;, and &lt;code&gt;v&lt;/code&gt; satisfy the equations &lt;code&gt;a @ v[:,i] = w[i] * v[:,i]&lt;/code&gt; for</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dafcbdde76f7395561c97c3255cdf449984b5af3" translate="yes" xml:space="preserve">
          <source>The number &lt;code&gt;w&lt;/code&gt; is an eigenvalue of &lt;code&gt;a&lt;/code&gt; if there exists a vector &lt;code&gt;v&lt;/code&gt; such that &lt;code&gt;dot(a,v) = w * v&lt;/code&gt;. Thus, the arrays &lt;code&gt;a&lt;/code&gt;, &lt;code&gt;w&lt;/code&gt;, and &lt;code&gt;v&lt;/code&gt; satisfy the equations &lt;code&gt;dot(a[:,:], v[:,i]) = w[i] * v[:,i]&lt;/code&gt; for</source>
          <target state="translated">Число &lt;code&gt;w&lt;/code&gt; является собственным значением &lt;code&gt;a&lt;/code&gt; , если существует вектор &lt;code&gt;v&lt;/code&gt; такой, что &lt;code&gt;dot(a,v) = w * v&lt;/code&gt; . Таким образом, массивы &lt;code&gt;a&lt;/code&gt; , &lt;code&gt;w&lt;/code&gt; и &lt;code&gt;v&lt;/code&gt; удовлетворяют уравнениям &lt;code&gt;dot(a[:,:], v[:,i]) = w[i] * v[:,i]&lt;/code&gt; для</target>
        </trans-unit>
        <trans-unit id="1bb66b4a14636c387bd7dac27c6170702e129db5" translate="yes" xml:space="preserve">
          <source>The number of arguments.</source>
          <target state="translated">Количество аргументов.</target>
        </trans-unit>
        <trans-unit id="50f26fa4113f32c300038f926f58c5de950b657e" translate="yes" xml:space="preserve">
          <source>The number of arrays that need to be broadcast to the same shape.</source>
          <target state="translated">Количество массивов,которые необходимо транслировать в одну и ту же форму.</target>
        </trans-unit>
        <trans-unit id="cd1c13079fc7462745575ad6cadd5c1655d5fd8f" translate="yes" xml:space="preserve">
          <source>The number of base units in a step.</source>
          <target state="translated">Количество базовых единиц в шаге.</target>
        </trans-unit>
        <trans-unit id="ddeea3732f7461b0e4b46d4155abe0931176b591" translate="yes" xml:space="preserve">
          <source>The number of bins (of size 1) is one larger than the largest value in &lt;code&gt;x&lt;/code&gt;. If &lt;code&gt;minlength&lt;/code&gt; is specified, there will be at least this number of bins in the output array (though it will be longer if necessary, depending on the contents of &lt;code&gt;x&lt;/code&gt;). Each bin gives the number of occurrences of its index value in &lt;code&gt;x&lt;/code&gt;. If &lt;code&gt;weights&lt;/code&gt; is specified the input array is weighted by it, i.e. if a value &lt;code&gt;n&lt;/code&gt; is found at position &lt;code&gt;i&lt;/code&gt;, &lt;code&gt;out[n] += weight[i]&lt;/code&gt; instead of &lt;code&gt;out[n] += 1&lt;/code&gt;.</source>
          <target state="translated">Количество ячеек (размера 1) на единицу больше, чем наибольшее значение в &lt;code&gt;x&lt;/code&gt; . Если &lt;code&gt;minlength&lt;/code&gt; , в выходном массиве будет как минимум это количество ячеек (хотя при необходимости оно будет больше, в зависимости от содержимого &lt;code&gt;x&lt;/code&gt; ). Каждая ячейка дает количество вхождений своего значения индекса в &lt;code&gt;x&lt;/code&gt; . Если указаны &lt;code&gt;weights&lt;/code&gt; , входной массив взвешивается по нему, т.е. если значение &lt;code&gt;n&lt;/code&gt; находится в позиции &lt;code&gt;i&lt;/code&gt; , &lt;code&gt;out[n] += weight[i]&lt;/code&gt; вместо &lt;code&gt;out[n] += 1&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="961981b3d06507afe179094c308682fa430fda0e" translate="yes" xml:space="preserve">
          <source>The number of bins for all dimensions (nx=ny=&amp;hellip;=bins).</source>
          <target state="translated">Количество бункеров для всех измерений (nx = ny =&amp;hellip; = бункеры).</target>
        </trans-unit>
        <trans-unit id="180a01cbfbe39044df94a38205c151e4055dfaef" translate="yes" xml:space="preserve">
          <source>The number of bins for each dimension (nx, ny, &amp;hellip; =bins)</source>
          <target state="translated">Количество интервалов для каждого измерения (nx, ny,&amp;hellip; = интервалы)</target>
        </trans-unit>
        <trans-unit id="ef8032cee94538f0c3d6bbb995bbf06ce4b1a135" translate="yes" xml:space="preserve">
          <source>The number of bins is only proportional to cube root of &lt;code&gt;a.size&lt;/code&gt;. It tends to overestimate the number of bins and it does not take into account data variability.</source>
          <target state="translated">Количество &lt;code&gt;a.size&lt;/code&gt; пропорционально только кубическому корню из размера . Он имеет тенденцию переоценивать количество бинов и не принимает во внимание изменчивость данных.</target>
        </trans-unit>
        <trans-unit id="3c7ac04dd9e94e09e580f7718e7797190217f2db" translate="yes" xml:space="preserve">
          <source>The number of bins is the base 2 log of &lt;code&gt;a.size&lt;/code&gt;. This estimator assumes normality of data and is too conservative for larger, non-normal datasets. This is the default method in R&amp;rsquo;s &lt;code&gt;hist&lt;/code&gt; method.</source>
          <target state="translated">Количество бункеров - это логарифм &lt;code&gt;a.size&lt;/code&gt; по основанию 2 . Эта оценка предполагает нормальность данных и слишком консервативна для больших, ненормальных наборов данных. Это метод по умолчанию в методе R &lt;code&gt;hist&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ec49cbff29de9e7b90f0c2a06cd3039e0f213a48" translate="yes" xml:space="preserve">
          <source>The number of bits in the exponent including its sign and bias.</source>
          <target state="translated">Количество битов в экспоненте,включая его знак и предвзятость.</target>
        </trans-unit>
        <trans-unit id="ffbebedcdf5bf4f1593520cffb80749e6f34262c" translate="yes" xml:space="preserve">
          <source>The number of bits in the exponent portion of the floating point representation.</source>
          <target state="translated">Количество бит в экспонентной части представления с плавающей точкой.</target>
        </trans-unit>
        <trans-unit id="96302b58629afe268f2042e560d43721a3fc2867" translate="yes" xml:space="preserve">
          <source>The number of bits in the mantissa.</source>
          <target state="translated">Количество кусочков в мантиссе.</target>
        </trans-unit>
        <trans-unit id="792cc1a58f0a3a46d19118877b6d13c493cb98ec" translate="yes" xml:space="preserve">
          <source>The number of bits occupied by the type.</source>
          <target state="translated">Количество бит,занимаемое типом.</target>
        </trans-unit>
        <trans-unit id="b307f502028d1a8e478a9e28dfcf2d36c5fe0bca" translate="yes" xml:space="preserve">
          <source>The number of bits required to generate a simulated value differs from the number of bits generated by the underlying RNG. For example, two 16-bit integer values can be simulated from a single draw of a 32-bit RNG.</source>
          <target state="translated">Количество битов,необходимых для генерации моделируемого значения,отличается от количества битов,генерируемых базовым RNG.Например,два 16-битных целых значения могут быть смоделированы из одного отрисовки 32-битного RNG.</target>
        </trans-unit>
        <trans-unit id="5b028aff9079ccf79e60389c0ccd1c2bd52c5a13" translate="yes" xml:space="preserve">
          <source>The number of build jobs can also be specified via the environment variable &lt;code&gt;NPY_NUM_BUILD_JOBS&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c523c9c933fe391fb48ef56ebd3c154a68738ed9" translate="yes" xml:space="preserve">
          <source>The number of bytes each item in the array requires.</source>
          <target state="translated">Количество байт,требуемое каждым элементом массива.</target>
        </trans-unit>
        <trans-unit id="accc8d694cc26b9e63438cb6cbca5878ebb2f8ff" translate="yes" xml:space="preserve">
          <source>The number of bytes into the field at which to place &lt;code&gt;val&lt;/code&gt;.</source>
          <target state="translated">Число байтов в поле, в которое нужно поместить &lt;code&gt;val&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a1bc94a2ea241fcb184442f81754fe01e618cf6a" translate="yes" xml:space="preserve">
          <source>The number of characters per line for the purpose of inserting line breaks (default 75).</source>
          <target state="translated">Количество символов на строку для вставки разрывов строк (по умолчанию 75).</target>
        </trans-unit>
        <trans-unit id="e62a5487dfe8294b0662475991a8ef49d96aaa30" translate="yes" xml:space="preserve">
          <source>The number of children already spawned. Only pass this if reconstructing a &lt;a href=&quot;#numpy.random.SeedSequence&quot;&gt;&lt;code&gt;SeedSequence&lt;/code&gt;&lt;/a&gt; from a serialized form.</source>
          <target state="translated">Количество уже рожденных детей. &lt;a href=&quot;#numpy.random.SeedSequence&quot;&gt; &lt;code&gt;SeedSequence&lt;/code&gt; &lt;/a&gt; это только при восстановлении SeedSequence из сериализованной формы.</target>
        </trans-unit>
        <trans-unit id="51818f09691484990d73679da97e27bd0b748a81" translate="yes" xml:space="preserve">
          <source>The number of dimensions and the size of each dimension</source>
          <target state="translated">Количество размеров и размер каждого размера</target>
        </trans-unit>
        <trans-unit id="20f7440820740cd73bd8bc73940f9eb0da1ec572" translate="yes" xml:space="preserve">
          <source>The number of dimensions in the array.</source>
          <target state="translated">Количество размеров в массиве.</target>
        </trans-unit>
        <trans-unit id="d4b953d2df6296d252217619c918790078f1f070" translate="yes" xml:space="preserve">
          <source>The number of dimensions in the broadcasted result.</source>
          <target state="translated">Количество размеров в транслируемом результате.</target>
        </trans-unit>
        <trans-unit id="16045283fd37589fa60a5d2a0d49dd57ac83ac40" translate="yes" xml:space="preserve">
          <source>The number of dimensions.</source>
          <target state="translated">Количество размеров.</target>
        </trans-unit>
        <trans-unit id="cf23530c90606a0534a47544a2bf03555320f356" translate="yes" xml:space="preserve">
          <source>The number of each type of item in the collection from which a sample is drawn. The values in &lt;code&gt;colors&lt;/code&gt; must be nonnegative. To avoid loss of precision in the algorithm, &lt;code&gt;sum(colors)&lt;/code&gt; must be less than &lt;code&gt;10**9&lt;/code&gt; when &lt;code&gt;method&lt;/code&gt; is &amp;ldquo;marginals&amp;rdquo;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3a0a0191ab6889929bc691e4ea5f7b01d6f77c2e" translate="yes" xml:space="preserve">
          <source>The number of elements to unpack along &lt;code&gt;axis&lt;/code&gt;, provided as a way of undoing the effect of packing a size that is not a multiple of eight. A non-negative number means to only unpack &lt;code&gt;count&lt;/code&gt; bits. A negative number means to trim off that many bits from the end. &lt;code&gt;None&lt;/code&gt; means to unpack the entire array (the default). Counts larger than the available number of bits will add zero padding to the output. Negative counts must not exceed the available number of bits.</source>
          <target state="translated">Количество элементов для распаковки вдоль &lt;code&gt;axis&lt;/code&gt; , предоставленное как способ устранения эффекта упаковки размера, не кратного восьми. Неотрицательное число означает только распакованное &lt;code&gt;count&lt;/code&gt; бит. Отрицательное число означает обрезку такого количества бит с конца. &lt;code&gt;None&lt;/code&gt; означает распаковывать весь массив (по умолчанию). Счетчики, превышающие доступное количество битов, добавят нулевое заполнение к выходным данным. Отрицательные числа не должны превышать доступное количество битов.</target>
        </trans-unit>
        <trans-unit id="9762b9c4461b4320b651627cdc827d526c1d8a36" translate="yes" xml:space="preserve">
          <source>The number of floating-point types</source>
          <target state="translated">Количество типов с плавающей точкой</target>
        </trans-unit>
        <trans-unit id="5f79b76db3c0063c4dbecc42a7851ca0e7d61297" translate="yes" xml:space="preserve">
          <source>The number of input arguments.</source>
          <target state="translated">Количество входных аргументов.</target>
        </trans-unit>
        <trans-unit id="5f16430ff4bbbb029090f84ca5392fa4a978dcbf" translate="yes" xml:space="preserve">
          <source>The number of inputs.</source>
          <target state="translated">Количество входов.</target>
        </trans-unit>
        <trans-unit id="ad3ac53999da2a535168ea7e917e83fb83c41419" translate="yes" xml:space="preserve">
          <source>The number of integrations to perform.</source>
          <target state="translated">Количество выполняемых интеграций.</target>
        </trans-unit>
        <trans-unit id="f51beaacf43aeefc0899893a53af8824382a26f0" translate="yes" xml:space="preserve">
          <source>The number of items selected. &lt;code&gt;nsample&lt;/code&gt; must not be greater than &lt;code&gt;sum(colors)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fb27416d0d8fd4a79bebfa578ec630568a0908f0" translate="yes" xml:space="preserve">
          <source>The number of items to read from &lt;em&gt;iterable&lt;/em&gt;. The default is -1, which means all data is read.</source>
          <target state="translated">Количество элементов для чтения из &lt;em&gt;итерируемого&lt;/em&gt; . По умолчанию -1, что означает, что все данные читаются.</target>
        </trans-unit>
        <trans-unit id="59d7f6376949b026c4f59178cb450cda4e03c50d" translate="yes" xml:space="preserve">
          <source>The number of iterator operands.</source>
          <target state="translated">Количество операндов итератора.</target>
        </trans-unit>
        <trans-unit id="906dbe82e1bcf21f6f38450b28f60987840c67b3" translate="yes" xml:space="preserve">
          <source>The number of lines to skip at the beginning of the file.</source>
          <target state="translated">Количество пропущенных строк в начале файла.</target>
        </trans-unit>
        <trans-unit id="1f9e5bb5bb6065f40b3b5f1acf92ad15826aa414" translate="yes" xml:space="preserve">
          <source>The number of lines to skip at the end of the file.</source>
          <target state="translated">Количество пропущенных строк в конце файла.</target>
        </trans-unit>
        <trans-unit id="36ce98d71e68fb1757547c834a0c7900df88883d" translate="yes" xml:space="preserve">
          <source>The number of numerical NumPy types - of which there are 18 total - on which the ufunc can operate.</source>
          <target state="translated">Количество числовых типов NumPy-всего их 18-на которых может работать ufunc.</target>
        </trans-unit>
        <trans-unit id="9d9f649df57a2efc7c5d1837c8cce03f4ddffe4d" translate="yes" xml:space="preserve">
          <source>The number of objects returned by &lt;code&gt;func&lt;/code&gt;.</source>
          <target state="translated">Количество объектов, возвращаемых &lt;code&gt;func&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="cd1491ebeebfc5761455718746328a874537820d" translate="yes" xml:space="preserve">
          <source>The number of output arguments.</source>
          <target state="translated">Количество выходных аргументов.</target>
        </trans-unit>
        <trans-unit id="bb79176b795c17c39b28af054f09df09e008175b" translate="yes" xml:space="preserve">
          <source>The number of outputs.</source>
          <target state="translated">Количество выходов.</target>
        </trans-unit>
        <trans-unit id="1f9d3b6c33190d8820407a65c8dfbe71f2fb41db" translate="yes" xml:space="preserve">
          <source>The number of periods &lt;code&gt;nper&lt;/code&gt; is computed by solving the equation:</source>
          <target state="translated">Количество периодов &lt;code&gt;nper&lt;/code&gt; вычисляется путем решения уравнения:</target>
        </trans-unit>
        <trans-unit id="9f00991307aeed3ff212ec1f19aa64c4d4a70887" translate="yes" xml:space="preserve">
          <source>The number of places by which elements are shifted. If a tuple, then &lt;code&gt;axis&lt;/code&gt; must be a tuple of the same size, and each of the given axes is shifted by the corresponding number. If an int while &lt;code&gt;axis&lt;/code&gt; is a tuple of ints, then the same value is used for all given axes.</source>
          <target state="translated">Количество мест, на которое смещены элементы. Если кортеж, то &lt;code&gt;axis&lt;/code&gt; должна быть кортежем того же размера, и каждая из заданных осей сдвигается на соответствующее число. Если &lt;code&gt;axis&lt;/code&gt; int while является кортежем целых чисел, то для всех заданных осей используется одно и то же значение.</target>
        </trans-unit>
        <trans-unit id="1c87f40038faffc87024cc0b95bb28f19f5ea872" translate="yes" xml:space="preserve">
          <source>The number of repetitions for each element. &lt;code&gt;repeats&lt;/code&gt; is broadcasted to fit the shape of the given axis.</source>
          <target state="translated">Количество повторов для каждого элемента. &lt;code&gt;repeats&lt;/code&gt; транслируются, чтобы соответствовать форме данной оси.</target>
        </trans-unit>
        <trans-unit id="4fedda7271f10f5b28b1a15e8ad961405e48dbc3" translate="yes" xml:space="preserve">
          <source>The number of repetitions of &lt;code&gt;A&lt;/code&gt; along each axis.</source>
          <target state="translated">Количество повторений &lt;code&gt;A&lt;/code&gt; по каждой оси.</target>
        </trans-unit>
        <trans-unit id="1e0a0e5cb024809c54b4083f3e0a5bc9d1d9a145" translate="yes" xml:space="preserve">
          <source>The number of supported data types for the ufunc. This number specifies how many different 1-d loops (of the builtin data types) are available.</source>
          <target state="translated">Количество поддерживаемых типов данных для ufunc.Это число определяет,сколько различных 1-d циклов (из встроенных типов данных)доступно.</target>
        </trans-unit>
        <trans-unit id="d384dcdb010cb83d633476edabf26a7cd5dcb98d" translate="yes" xml:space="preserve">
          <source>The number of times &lt;code&gt;a&lt;/code&gt; is repeated along the first and second axes.</source>
          <target state="translated">Число повторений &lt;code&gt;a&lt;/code&gt; по первой и второй осям.</target>
        </trans-unit>
        <trans-unit id="84ea540c48d087fa8db5ec94e472c5f5f973f2f5" translate="yes" xml:space="preserve">
          <source>The number of times each of the unique values comes up in the original array. Only provided if &lt;code&gt;return_counts&lt;/code&gt; is True.</source>
          <target state="translated">Сколько раз каждое из уникальных значений встречается в исходном массиве. Предоставляется, только если &lt;code&gt;return_counts&lt;/code&gt; имеет значение True.</target>
        </trans-unit>
        <trans-unit id="27ba063589e5e81b80624f4103b1f5b28059f11a" translate="yes" xml:space="preserve">
          <source>The number of times values are differenced. If zero, the input is returned as-is.</source>
          <target state="translated">Количество значений разделено.Если ноль,то вход возвращается как есть.</target>
        </trans-unit>
        <trans-unit id="9f0b88f6fb636dd892bff0b33b009c20d79ffb03" translate="yes" xml:space="preserve">
          <source>The number of types.</source>
          <target state="translated">Количество типов.</target>
        </trans-unit>
        <trans-unit id="fddf10cce5774b681c3f0ad6691bdd384810c58d" translate="yes" xml:space="preserve">
          <source>The number of variates to generate, either an integer or a tuple holding the shape of the array of variates. If the given size is, e.g., &lt;code&gt;(k, m)&lt;/code&gt;, then &lt;code&gt;k * m&lt;/code&gt; variates are drawn, where one variate is a vector of length &lt;code&gt;len(colors)&lt;/code&gt;, and the return value has shape &lt;code&gt;(k, m, len(colors))&lt;/code&gt;. If &lt;code&gt;size&lt;/code&gt; is an integer, the output has shape &lt;code&gt;(size, len(colors))&lt;/code&gt;. Default is None, in which case a single variate is returned as an array with shape &lt;code&gt;(len(colors),)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8a67e415f6489cfd59cc7656bd025411ca29912b" translate="yes" xml:space="preserve">
          <source>The numpy array shares the memory with the ctypes object.</source>
          <target state="translated">Массив numpy разделяет память с объектом ctypes.</target>
        </trans-unit>
        <trans-unit id="d790ce3a56f19101368186a47de94f2e3aed2abb" translate="yes" xml:space="preserve">
          <source>The numpy core math library (&amp;lsquo;npymath&amp;rsquo;) is a first step in this direction. This library contains most math-related C99 functionality, which can be used on platforms where C99 is not well supported. The core math functions have the same API as the C99 ones, except for the npy_* prefix.</source>
          <target state="translated">Основная математическая библиотека numpy ('npymath') - первый шаг в этом направлении. Эта библиотека содержит большинство математических функций C99, которые можно использовать на платформах, где C99 плохо поддерживается. Основные математические функции имеют тот же API, что и функции C99, за исключением префикса npy_ *.</target>
        </trans-unit>
        <trans-unit id="6064ebb13dec03f1de88e5067059d7a27df68911" translate="yes" xml:space="preserve">
          <source>The numpy documentation also depends on the &lt;a href=&quot;https://numpydoc.readthedocs.io/en/latest/&quot;&gt;numpydoc&lt;/a&gt; sphinx extension as well as an external sphinx theme. These extensions are included as git submodules and must be initialized before building the docs. From the &lt;code&gt;doc/&lt;/code&gt; directory:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d91b51f2620c8e0f1fabe752803d49bce22176fb" translate="yes" xml:space="preserve">
          <source>The numpy.ma module</source>
          <target state="translated">Модуль numpy.ma</target>
        </trans-unit>
        <trans-unit id="2cbe93e7df3a43f9ae71da4b89814ed8fa49c0d4" translate="yes" xml:space="preserve">
          <source>The numpy/core/include/numpy/numpyconfig.h will need a new NPY_X_Y_API_VERSION macro, where X and Y are the major and minor version numbers of the release. The value given to that macro only needs to be increased from the previous version if some of the functions or macros in the include files were deprecated.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2fff5784e4a4fb8eb59dd23392ddf836510aaeb1" translate="yes" xml:space="preserve">
          <source>The numpydoc docstring guide</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dbd675a4d044f8874d7c67d632da0258490296eb" translate="yes" xml:space="preserve">
          <source>The object can be any Python object convertible to an ndarray. If the object is already (a subclass of) the ndarray that satisfies the requirements then a new reference is returned. Otherwise, a new array is constructed. The contents of &lt;em&gt;obj&lt;/em&gt; are copied to the new array unless the array interface is used so that data does not have to be copied. Objects that can be converted to an array include: 1) any nested sequence object, 2) any object exposing the array interface, 3) any object with an &lt;a href=&quot;../reference/arrays.classes#numpy.class.__array__&quot;&gt;&lt;code&gt;__array__&lt;/code&gt;&lt;/a&gt; method (which should return an ndarray), and 4) any scalar object (becomes a zero-dimensional array). Sub-classes of the ndarray that otherwise fit the requirements will be passed through. If you want to ensure a base-class ndarray, then use &lt;a href=&quot;../reference/c-api/array#c.NPY_ARRAY_ENSUREARRAY&quot;&gt;&lt;code&gt;NPY_ARRAY_ENSUREARRAY&lt;/code&gt;&lt;/a&gt; in the requirements flag. A copy is made only if necessary. If you want to guarantee a copy, then pass in &lt;a href=&quot;../reference/c-api/array#c.NPY_ARRAY_ENSURECOPY&quot;&gt;&lt;code&gt;NPY_ARRAY_ENSURECOPY&lt;/code&gt;&lt;/a&gt; to the requirements flag.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a12e93df39508259f846e57ebebd07dec5405cd4" translate="yes" xml:space="preserve">
          <source>The object of which the type is returned.</source>
          <target state="translated">Объект,тип которого возвращается.</target>
        </trans-unit>
        <trans-unit id="892e730df208b39897e2c0d1b1cca7fbb8ae1420" translate="yes" xml:space="preserve">
          <source>The object to be converted to a type-and-requirement-satisfying array.</source>
          <target state="translated">Объект,который будет преобразован в массив,удовлетворяющий типу и запросу.</target>
        </trans-unit>
        <trans-unit id="bfbfb146acae6cf5d1e2df4b8b0cf4b046d06226" translate="yes" xml:space="preserve">
          <source>The object to check.</source>
          <target state="translated">Объект для проверки.</target>
        </trans-unit>
        <trans-unit id="0f3ea496874fb4613c3a9be9c6a176f4f24c9e54" translate="yes" xml:space="preserve">
          <source>The object to iterate over.</source>
          <target state="translated">Объект для итераций.</target>
        </trans-unit>
        <trans-unit id="45971228cf20d163b0ca1b27e71b0f9a03bee868" translate="yes" xml:space="preserve">
          <source>The object type is also special because an array containing &lt;code&gt;object_&lt;/code&gt; items does not return an &lt;code&gt;object_&lt;/code&gt; object on item access, but instead returns the actual object that the array item refers to.</source>
          <target state="translated">Тип объекта также является особенным, потому что массив, содержащий &lt;code&gt;object_&lt;/code&gt; items, не возвращает объект &lt;code&gt;object_&lt;/code&gt; при доступе к элементу, а вместо этого возвращает фактический объект, на который ссылается элемент массива.</target>
        </trans-unit>
        <trans-unit id="74fb22be6dfa85b139cc4a823d71b842fbca772d" translate="yes" xml:space="preserve">
          <source>The object which calculated these parameters and holds more detailed information.</source>
          <target state="translated">Объект,который вычислил эти параметры и содержит более подробную информацию.</target>
        </trans-unit>
        <trans-unit id="12dc58a76790d493cfd5ba208610a891b0f1c28f" translate="yes" xml:space="preserve">
          <source>The object will be converted to the desired type only if it can be done without losing precision. Otherwise &lt;code&gt;NULL&lt;/code&gt; will be returned and an error raised. Use &lt;a href=&quot;../reference/c-api/array#c.NPY_ARRAY_FORCECAST&quot;&gt;&lt;code&gt;NPY_ARRAY_FORCECAST&lt;/code&gt;&lt;/a&gt; in the requirements flag to override this behavior.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d7678b3e9676e0762f7a3c623921af222c12ff2c" translate="yes" xml:space="preserve">
          <source>The obvious fix for this situation is to change the dtype so it gives the correct endianness:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="29b86a58a4365210dddb9297096eac1156c7d098" translate="yes" xml:space="preserve">
          <source>The offset (in bytes) from the file&amp;rsquo;s current position. Defaults to 0. Only permitted for binary files.</source>
          <target state="translated">Смещение (в байтах) от текущей позиции файла. По умолчанию 0. Разрешено только для двоичных файлов.</target>
        </trans-unit>
        <trans-unit id="93c773e560e0498af231d1a157163977066e3d8a" translate="yes" xml:space="preserve">
          <source>The old error handler.</source>
          <target state="translated">Старый обработчик ошибок.</target>
        </trans-unit>
        <trans-unit id="1ec4554bb191ce258f048e411e4e87d29267fb91" translate="yes" xml:space="preserve">
          <source>The old iterator API includes functions like PyArrayIter_Check, PyArray_Iter* and PyArray_ITER_*. The multi-iterator array includes PyArray_MultiIter*, PyArray_Broadcast, and PyArray_RemoveSmallest. The new iterator design replaces all of this functionality with a single object and associated API. One goal of the new API is that all uses of the existing iterator should be replaceable with the new iterator without significant effort. In 1.6, the major exception to this is the neighborhood iterator, which does not have corresponding features in this iterator.</source>
          <target state="translated">Старый API итератора включает в себя такие функции,как PyArrayIter_Check,PyArray_Iter*и PyArray_ITER_*.Мультитераторный массив включает в себя PyArray_MultiIter*,PyArray_Broadcast и PyArray_RemoveSmallest.Новый дизайн итератора заменяет всю эту функциональность одним объектом и связанным с ним API.Одной из целей нового API является то,что все использования существующего итератора должны быть заменены на новый без особых усилий.В 1.6 основное исключение составляет соседний итератор,который не имеет соответствующих функций в этом итераторе.</target>
        </trans-unit>
        <trans-unit id="5bba457e9d70db346759d26e013499c6bff97b55" translate="yes" xml:space="preserve">
          <source>The one-dimensional (forward) FFT, of which &lt;a href=&quot;#numpy.fft.ifft&quot;&gt;&lt;code&gt;ifft&lt;/code&gt;&lt;/a&gt; is the inverse</source>
          <target state="translated">Одномерное (прямое) БПФ, для которого &lt;a href=&quot;#numpy.fft.ifft&quot;&gt; &lt;code&gt;ifft&lt;/code&gt; &lt;/a&gt; является обратным</target>
        </trans-unit>
        <trans-unit id="b13835d03a9daf8c507b45bfab105cd08fae35d5" translate="yes" xml:space="preserve">
          <source>The one-dimensional FFT of general (complex) input.</source>
          <target state="translated">Одномерный БПФ общего (комплексного)входа.</target>
        </trans-unit>
        <trans-unit id="0cd037d8b0e459e2ea7f7abda9a2074a96ea80a2" translate="yes" xml:space="preserve">
          <source>The one-dimensional FFT of real input, of which &lt;a href=&quot;#numpy.fft.irfft&quot;&gt;&lt;code&gt;irfft&lt;/code&gt;&lt;/a&gt; is inverse.</source>
          <target state="translated">Одномерное БПФ реального ввода, для которого &lt;a href=&quot;#numpy.fft.irfft&quot;&gt; &lt;code&gt;irfft&lt;/code&gt; &lt;/a&gt; является обратным.</target>
        </trans-unit>
        <trans-unit id="9fbd4ce083fd828af7518629c69fc1b51be085ea" translate="yes" xml:space="preserve">
          <source>The one-dimensional FFT of real input.</source>
          <target state="translated">Одномерный БПФ реального входа.</target>
        </trans-unit>
        <trans-unit id="5c18581fbbf72b4741168098a1d9545410236f6d" translate="yes" xml:space="preserve">
          <source>The one-dimensional FFT, with definitions and conventions used.</source>
          <target state="translated">Одномерный БПФ,с используемыми определениями и конвенциями.</target>
        </trans-unit>
        <trans-unit id="cb7777bd048622e7012600d71666f63fa7ceb74f" translate="yes" xml:space="preserve">
          <source>The one-dimensional FFT.</source>
          <target state="translated">Одномерный БПФ.</target>
        </trans-unit>
        <trans-unit id="225306f7f184d0b92b85104fd4b6b278cc44c9a3" translate="yes" xml:space="preserve">
          <source>The one-dimensional inverse FFT.</source>
          <target state="translated">Одномерный обратный БПФ.</target>
        </trans-unit>
        <trans-unit id="ba7c728a6936b18871796d8f180aab8013101b39" translate="yes" xml:space="preserve">
          <source>The only constraint on &lt;code&gt;weights&lt;/code&gt; is that &lt;code&gt;sum(weights)&lt;/code&gt; must not be 0.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ff0f1129172422a9679a73fc5e8d6a883951639f" translate="yes" xml:space="preserve">
          <source>The only mandatory argument of &lt;a href=&quot;../reference/generated/numpy.genfromtxt#numpy.genfromtxt&quot;&gt;&lt;code&gt;genfromtxt&lt;/code&gt;&lt;/a&gt; is the source of the data. It can be a string, a list of strings, a generator or an open file-like object with a &lt;code&gt;read&lt;/code&gt; method, for example, a file or &lt;a href=&quot;https://docs.python.org/dev/library/io.html#io.StringIO&quot;&gt;&lt;code&gt;io.StringIO&lt;/code&gt;&lt;/a&gt; object. If a single string is provided, it is assumed to be the name of a local or remote file. If a list of strings or a generator returning strings is provided, each string is treated as one line in a file. When the URL of a remote file is passed, the file is automatically downloaded to the current directory and opened.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="df0b92ea232e6d8dccfcd905588f89bc51445e3a" translate="yes" xml:space="preserve">
          <source>The operands of some operation whose result type is needed.</source>
          <target state="translated">Операндов некоторой операции,тип результата которой необходим.</target>
        </trans-unit>
        <trans-unit id="10e5b80590b5efbd493758bd757a312d4d78c228" translate="yes" xml:space="preserve">
          <source>The operation in the inner loop is a straightforward multiplication. Everything to do with the outer product is handled by the iterator setup.</source>
          <target state="translated">Операция во внутреннем контуре представляет собой простое умножение.Все,что связано с внешним изделием,обрабатывается установкой итератора.</target>
        </trans-unit>
        <trans-unit id="471ee7828ebe7c0602cfc5e6e021f9c562ef10fd" translate="yes" xml:space="preserve">
          <source>The option &lt;code&gt;dtype=None&lt;/code&gt; is provided for convenience. However, it is significantly slower than setting the dtype explicitly.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5d9c6a82b754562bff3c30cfb164e81b6c34b6c3" translate="yes" xml:space="preserve">
          <source>The optional &amp;lsquo;aligned&amp;rsquo; value can be set to &lt;code&gt;True&lt;/code&gt; to make the automatic offset computation use aligned offsets (see &lt;a href=&quot;#offsets-and-alignment&quot;&gt;Automatic Byte Offsets and Alignment&lt;/a&gt;), as if the &amp;lsquo;align&amp;rsquo; keyword argument of &lt;a href=&quot;../reference/generated/numpy.dtype#numpy.dtype&quot;&gt;&lt;code&gt;numpy.dtype&lt;/code&gt;&lt;/a&gt; had been set to True.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="03a3e8c483cee1d9d2b1425187728e8a245d58ca" translate="yes" xml:space="preserve">
          <source>The optional &amp;lsquo;titles&amp;rsquo; value should be a list of titles of the same length as &amp;lsquo;names&amp;rsquo;, see &lt;a href=&quot;#titles&quot;&gt;Field Titles&lt;/a&gt; below.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0af8d6f274a699b745815e9b76bdbe8e97f9313c" translate="yes" xml:space="preserve">
          <source>The optional argument &lt;code&gt;comments&lt;/code&gt; is used to define a character string that marks the beginning of a comment. By default, &lt;a href=&quot;../reference/generated/numpy.genfromtxt#numpy.genfromtxt&quot;&gt;&lt;code&gt;genfromtxt&lt;/code&gt;&lt;/a&gt; assumes &lt;code&gt;comments='#'&lt;/code&gt;. The comment marker may occur anywhere on the line. Any character present after the comment marker(s) is simply ignored:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="94b62b6ba781a5ddd569b811fe572b78fe805c1d" translate="yes" xml:space="preserve">
          <source>The optional output arguments can be used to help you save memory for large calculations. If your arrays are large, complicated expressions can take longer than absolutely necessary due to the creation and (later) destruction of temporary calculation spaces. For example, the expression &lt;code&gt;G = a * b + c&lt;/code&gt; is equivalent to &lt;code&gt;t1 = A * B; G = T1 + C; del t1&lt;/code&gt;. It will be more quickly executed as &lt;code&gt;G = A * B; add(G, C, G)&lt;/code&gt; which is the same as &lt;code&gt;G = A * B; G += C&lt;/code&gt;.</source>
          <target state="translated">Необязательные выходные аргументы могут использоваться, чтобы помочь вам сэкономить память для больших вычислений. Если ваши массивы большие, сложные выражения могут занять больше времени, чем это абсолютно необходимо, из-за создания и (позже) уничтожения временных пространств вычислений. Например, выражение &lt;code&gt;G = a * b + c&lt;/code&gt; эквивалентно &lt;code&gt;t1 = A * B; G = T1 + C; del t1&lt;/code&gt; . Он будет выполняться быстрее, поскольку &lt;code&gt;G = A * B; add(G, C, G)&lt;/code&gt; что совпадает с &lt;code&gt;G = A * B; G += C&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7b2c78f4cc1b5de9c0c210654a3400e8183ebd83" translate="yes" xml:space="preserve">
          <source>The optional third element &lt;em&gt;field_shape&lt;/em&gt; contains the shape if this field represents an array of the data-type in the second element. Note that a 3-tuple with a third argument equal to 1 is equivalent to a 2-tuple.</source>
          <target state="translated">Необязательный третий элемент &lt;em&gt;field_shape&lt;/em&gt; содержит фигуру, если это поле представляет собой массив типа данных во втором элементе. Обратите внимание, что 3-кортеж с третьим аргументом, равным 1, эквивалентен 2-кортежу.</target>
        </trans-unit>
        <trans-unit id="14b215bf63d4b571de67dcde3ac908fb35772330" translate="yes" xml:space="preserve">
          <source>The options &amp;lsquo;reduced&amp;rsquo;, &amp;lsquo;complete, and &amp;lsquo;raw&amp;rsquo; are new in numpy 1.8, see the notes for more information. The default is &amp;lsquo;reduced&amp;rsquo;, and to maintain backward compatibility with earlier versions of numpy both it and the old default &amp;lsquo;full&amp;rsquo; can be omitted. Note that array h returned in &amp;lsquo;raw&amp;rsquo; mode is transposed for calling Fortran. The &amp;lsquo;economic&amp;rsquo; mode is deprecated. The modes &amp;lsquo;full&amp;rsquo; and &amp;lsquo;economic&amp;rsquo; may be passed using only the first letter for backwards compatibility, but all others must be spelled out. See the Notes for more explanation.</source>
          <target state="translated">Опции &amp;laquo;сокращенный&amp;raquo;, &amp;laquo;полный&amp;raquo; и &amp;laquo;необработанный&amp;raquo; являются новыми в numpy 1.8, дополнительную информацию см. В примечаниях. По умолчанию используется &amp;laquo;уменьшенный&amp;raquo;, и для обеспечения обратной совместимости с более ранними версиями numpy как его, так и старое значение по умолчанию &amp;laquo;full&amp;raquo; можно опустить. Обратите внимание, что массив h, возвращенный в &amp;laquo;сыром&amp;raquo; режиме, транспонируется для вызова Фортрана. &amp;laquo;Экономичный&amp;raquo; режим не рекомендуется. Режимы &amp;laquo;полный&amp;raquo; и &amp;laquo;экономический&amp;raquo; могут передаваться с использованием только первой буквы для обратной совместимости, но все остальные должны быть прописаны. См. Примечания для получения дополнительных объяснений.</target>
        </trans-unit>
        <trans-unit id="6d9b2da0a0a7c1206d894d6f0fcce902e86c7458" translate="yes" xml:space="preserve">
          <source>The order in which the array data is stored in memory: &amp;lsquo;C&amp;rsquo; -&amp;gt; &amp;ldquo;row major&amp;rdquo; order (the default), &amp;lsquo;F&amp;rsquo; -&amp;gt; &amp;ldquo;column major&amp;rdquo; (Fortran) order.</source>
          <target state="translated">Порядок, в котором данные массива хранятся в памяти: &amp;laquo;C&amp;raquo; -&amp;gt; порядок &amp;laquo;основных строк&amp;raquo; ​​(по умолчанию), &amp;laquo;F&amp;raquo; -&amp;gt; порядок &amp;laquo;основных столбцов&amp;raquo; (Fortran).</target>
        </trans-unit>
        <trans-unit id="68929adbb771e5f9d5347a88dc7ca873ea9321af" translate="yes" xml:space="preserve">
          <source>The order in which they are preferred is determined by &lt;code&gt;NPY_BLAS_ILP64_ORDER&lt;/code&gt; and &lt;code&gt;NPY_LAPACK_ILP64_ORDER&lt;/code&gt; environment variables. The default value is &lt;code&gt;openblas64_,openblas_ilp64&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e18fbd568fd064406da176fc5bb0b9a80dc8baa0" translate="yes" xml:space="preserve">
          <source>The order of &lt;code&gt;v1&lt;/code&gt; and &lt;code&gt;v2&lt;/code&gt; doesn&amp;rsquo;t matter.</source>
          <target state="translated">Порядок &lt;code&gt;v1&lt;/code&gt; и &lt;code&gt;v2&lt;/code&gt; не имеет значения.</target>
        </trans-unit>
        <trans-unit id="64c7894d7cfcaaec3478ec1e4aaf0c4a01f8cc6f" translate="yes" xml:space="preserve">
          <source>The order of sub-arrays is changed but their contents remains the same.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1d4e69a308201075218d8a094df1f5f1f4d37aad" translate="yes" xml:space="preserve">
          <source>The order of the elements in the array resulting from ravel() is normally &amp;ldquo;C-style&amp;rdquo;, that is, the rightmost index &amp;ldquo;changes the fastest&amp;rdquo;, so the element after a[0,0] is a[0,1]. If the array is reshaped to some other shape, again the array is treated as &amp;ldquo;C-style&amp;rdquo;. NumPy normally creates arrays stored in this order, so ravel() will usually not need to copy its argument, but if the array was made by taking slices of another array or created with unusual options, it may need to be copied. The functions ravel() and reshape() can also be instructed, using an optional argument, to use FORTRAN-style arrays, in which the leftmost index changes the fastest.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1a665b347299d28c9a4225cbaa35961f7257fdf3" translate="yes" xml:space="preserve">
          <source>The order of the input bits. &amp;lsquo;big&amp;rsquo; will mimic bin(val), &lt;code&gt;[0, 0, 0, 0, 0, 0, 1, 1] =&amp;gt; 3 = 0b00000011 =&amp;gt; ``, 'little' will
reverse the order so ``[1, 1, 0, 0, 0, 0, 0, 0] =&amp;gt; 3&lt;/code&gt;. Defaults to &amp;lsquo;big&amp;rsquo;.</source>
          <target state="translated">Порядок входных битов. 'big' будет имитировать bin (val), &lt;code&gt;[0, 0, 0, 0, 0, 0, 1, 1] =&amp;gt; 3 = 0b00000011 =&amp;gt; ``, 'little' will reverse the order so ``[1, 1, 0, 0, 0, 0, 0, 0] =&amp;gt; 3&lt;/code&gt; . По умолчанию - большой.</target>
        </trans-unit>
        <trans-unit id="6a7badf2486ba3d65f6d452504aadca6f59aa17f" translate="yes" xml:space="preserve">
          <source>The order of the input bits. &amp;lsquo;big&amp;rsquo; will mimic bin(val), &lt;code&gt;[0, 0, 0, 0, 0, 0, 1, 1] =&amp;gt; 3 = 0b00000011&lt;/code&gt;, &amp;lsquo;little&amp;rsquo; will reverse the order so &lt;code&gt;[1, 1, 0, 0, 0, 0, 0, 0] =&amp;gt; 3&lt;/code&gt;. Defaults to &amp;lsquo;big&amp;rsquo;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c023a0582544690f15510a2492956e0e66cdc058" translate="yes" xml:space="preserve">
          <source>The order of the returned bits. &amp;lsquo;big&amp;rsquo; will mimic bin(val), &lt;code&gt;3 = 0b00000011 =&amp;gt; [0, 0, 0, 0, 0, 0, 1, 1]&lt;/code&gt;, &amp;lsquo;little&amp;rsquo; will reverse the order to &lt;code&gt;[1, 1, 0, 0, 0, 0, 0, 0]&lt;/code&gt;. Defaults to &amp;lsquo;big&amp;rsquo;.</source>
          <target state="translated">Порядок возвращаемых битов. 'большой' будет имитировать bin (val), &lt;code&gt;3 = 0b00000011 =&amp;gt; [0, 0, 0, 0, 0, 0, 1, 1]&lt;/code&gt; , 'маленький' изменит порядок на &lt;code&gt;[1, 1, 0, 0, 0, 0, 0, 0]&lt;/code&gt; . По умолчанию - большой.</target>
        </trans-unit>
        <trans-unit id="d31a5b9999b59b34b6ad9fdaccda217e19238ad4" translate="yes" xml:space="preserve">
          <source>The order or degree of the polynomial</source>
          <target state="translated">Порядок или степень полиномии</target>
        </trans-unit>
        <trans-unit id="eea06a8f88d6f17386cd112eab18c7ac9fc8e799" translate="yes" xml:space="preserve">
          <source>The orientation of &lt;code&gt;c&lt;/code&gt; can be changed using the &lt;code&gt;axisc&lt;/code&gt; keyword.</source>
          <target state="translated">Ориентацию &lt;code&gt;c&lt;/code&gt; можно изменить с помощью &lt;code&gt;axisc&lt;/code&gt; слова axisc .</target>
        </trans-unit>
        <trans-unit id="f6895b0ec7c91fa01ba724c0454c0ecbf9046ad1" translate="yes" xml:space="preserve">
          <source>The original contents of the &lt;code&gt;intent(in)&lt;/code&gt; argument may be altered by the Fortran/C function. F2PY creates an optional argument &lt;code&gt;overwrite_&amp;lt;argument name&amp;gt;&lt;/code&gt; with the default value &lt;code&gt;1&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5b2e34a61895054c86583de1c9f28efb1bf046c4" translate="yes" xml:space="preserve">
          <source>The other class must have the &lt;code&gt;coef&lt;/code&gt; attribute.</source>
          <target state="translated">Другой класс должен иметь атрибут &lt;code&gt;coef&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="beffd1aec86565c0ed7e85fa9756b03e99dc1093" translate="yes" xml:space="preserve">
          <source>The other class must have the &lt;code&gt;domain&lt;/code&gt; attribute.</source>
          <target state="translated">Другой класс должен иметь атрибут &lt;code&gt;domain&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c7b5b660115b8d1bff6ffdc35071c1bc977b44f5" translate="yes" xml:space="preserve">
          <source>The other class must have the &lt;code&gt;window&lt;/code&gt; attribute.</source>
          <target state="translated">Другой класс должен иметь атрибут &lt;code&gt;window&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="208270eb05b02b535197d000879d544f3abebcde" translate="yes" xml:space="preserve">
          <source>The out argument specifies where to place the result. If out is NULL, then the output array is created, otherwise the output is placed in out which must be the correct size and type. A new reference to the output array is always returned even when out is not NULL. The caller of the routine has the responsibility to &lt;code&gt;DECREF&lt;/code&gt; out if not NULL or a memory-leak will occur.</source>
          <target state="translated">Аргумент out указывает, где разместить результат. Если out равен NULL, то создается выходной массив, в противном случае вывод помещается в out, который должен быть правильного размера и типа. Всегда возвращается новая ссылка на выходной массив, даже если out не равен NULL. Вызывающий подпрограмму несет ответственность за &lt;code&gt;DECREF&lt;/code&gt; out, если не NULL или произойдет утечка памяти.</target>
        </trans-unit>
        <trans-unit id="b1eb4436c2a0a0542bae9d8ee0693add2fca6bb8" translate="yes" xml:space="preserve">
          <source>The out argument specifies where to place the result. If out is NULL, then the output array is created, otherwise the output is placed in out which must be the correct size and type. A new reference to the output array is always returned even when out is not NULL. The caller of the routine has the responsibility to &lt;code&gt;Py_DECREF&lt;/code&gt; out if not NULL or a memory-leak will occur.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d41934f2889307f51eefc25e7532b745714248c8" translate="yes" xml:space="preserve">
          <source>The outer product</source>
          <target state="translated">Внешний продукт</target>
        </trans-unit>
        <trans-unit id="eaacd893fa91168722bb422e1bd4cfd1660e87de" translate="yes" xml:space="preserve">
          <source>The output arguments (if any) are then processed and any missing return arrays are constructed. If any provided output array doesn&amp;rsquo;t have the correct type (or is mis-aligned) and is smaller than the buffer size, then a new output array is constructed with the special &lt;code&gt;WRITEBACKIFCOPY&lt;/code&gt; flag set. At the end of the function, &lt;a href=&quot;c-api.array#c.PyArray_ResolveWritebackIfCopy&quot;&gt;&lt;code&gt;PyArray_ResolveWritebackIfCopy&lt;/code&gt;&lt;/a&gt; is called so that its contents will be copied back into the output array. Iterators for the output arguments are then processed.</source>
          <target state="translated">Затем обрабатываются выходные аргументы (если есть) и строятся отсутствующие возвращаемые массивы. Если какой-либо предоставленный выходной массив не имеет правильного типа (или неправильно выровнен) и меньше размера буфера, то создается новый выходной массив со специальным &lt;code&gt;WRITEBACKIFCOPY&lt;/code&gt; флагом WRITEBACKIFCOPY . В конце функции &lt;a href=&quot;c-api.array#c.PyArray_ResolveWritebackIfCopy&quot;&gt; &lt;code&gt;PyArray_ResolveWritebackIfCopy&lt;/code&gt; &lt;/a&gt; чтобы его содержимое было скопировано обратно в выходной массив. Затем обрабатываются итераторы для выходных аргументов.</target>
        </trans-unit>
        <trans-unit id="02fbb66d65f083fd2d9e7a738b5f72feedd2f131" translate="yes" xml:space="preserve">
          <source>The output arguments (if any) are then processed and any missing return arrays are constructed. If any provided output array doesn&amp;rsquo;t have the correct type (or is mis-aligned) and is smaller than the buffer size, then a new output array is constructed with the special &lt;code&gt;WRITEBACKIFCOPY&lt;/code&gt; flag set. At the end of the function, &lt;a href=&quot;c-api/array#c.PyArray_ResolveWritebackIfCopy&quot;&gt;&lt;code&gt;PyArray_ResolveWritebackIfCopy&lt;/code&gt;&lt;/a&gt; is called so that its contents will be copied back into the output array. Iterators for the output arguments are then processed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f268497aae1cce8ff8c25da79f231196a245eaac" translate="yes" xml:space="preserve">
          <source>The output array is masked where all the values along the given axis are masked: if the output would have been a scalar and that all the values are masked, then the output is &lt;a href=&quot;../maskedarray.baseclass#numpy.ma.masked&quot;&gt;&lt;code&gt;masked&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Выходной массив замаскирован там, где все значения вдоль данной оси замаскированы: если выходные данные были бы скаляром и все значения замаскированы, то выходные данные &lt;a href=&quot;../maskedarray.baseclass#numpy.ma.masked&quot;&gt; &lt;code&gt;masked&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="7cdd30a82881324958754cfed2ed5012e49b5922" translate="yes" xml:space="preserve">
          <source>The output array of type Boolean with the same shape as a and b.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f55976ddc6094b99d81ee9f07a8be602a3926550" translate="yes" xml:space="preserve">
          <source>The output array, containing the part of the content of &lt;code&gt;file&lt;/code&gt; that was matched by &lt;code&gt;regexp&lt;/code&gt;. &lt;code&gt;output&lt;/code&gt; is always a structured array.</source>
          <target state="translated">Выходной массив, содержащий часть содержимого &lt;code&gt;file&lt;/code&gt; которому соответствует &lt;code&gt;regexp&lt;/code&gt; . &lt;code&gt;output&lt;/code&gt; всегда представляет собой структурированный массив.</target>
        </trans-unit>
        <trans-unit id="5aa2c29b27cf9fdf4a29996c1b8c28730e8e0aea" translate="yes" xml:space="preserve">
          <source>The output array, element-wise Heaviside step function of &lt;code&gt;x1&lt;/code&gt;. This is a scalar if both &lt;code&gt;x1&lt;/code&gt; and &lt;code&gt;x2&lt;/code&gt; are scalars.</source>
          <target state="translated">Выходной массив, поэлементная ступенчатая функция Хевисайда от &lt;code&gt;x1&lt;/code&gt; . Это скаляр, если и &lt;code&gt;x1&lt;/code&gt; , и &lt;code&gt;x2&lt;/code&gt; являются скалярами.</target>
        </trans-unit>
        <trans-unit id="70719ba0effebe3bb3aa417f56a4a6c01822a6e7" translate="yes" xml:space="preserve">
          <source>The output array.</source>
          <target state="translated">Выходной массив.</target>
        </trans-unit>
        <trans-unit id="09c7e58e3fd89577e8de606a001975293d749592" translate="yes" xml:space="preserve">
          <source>The output array. The number of dimensions is the same as &lt;code&gt;a&lt;/code&gt;, but the shape can be different. This depends on whether &lt;code&gt;func&lt;/code&gt; changes the shape of its output with respect to its input.</source>
          <target state="translated">Выходной массив. Количество размеров такое же, как у &lt;code&gt;a&lt;/code&gt; , но форма может быть другой. Это зависит от того, изменяет ли &lt;code&gt;func&lt;/code&gt; форму своего вывода относительно его ввода.</target>
        </trans-unit>
        <trans-unit id="d041e4d25d02f826463aa1a16a95e06fcf896235" translate="yes" xml:space="preserve">
          <source>The output array. The shape of &lt;code&gt;out&lt;/code&gt; is identical to the shape of &lt;code&gt;arr&lt;/code&gt;, except along the &lt;code&gt;axis&lt;/code&gt; dimension. This axis is removed, and replaced with new dimensions equal to the shape of the return value of &lt;code&gt;func1d&lt;/code&gt;. So if &lt;code&gt;func1d&lt;/code&gt; returns a scalar &lt;code&gt;out&lt;/code&gt; will have one fewer dimensions than &lt;code&gt;arr&lt;/code&gt;.</source>
          <target state="translated">Выходной массив. Форма &lt;code&gt;out&lt;/code&gt; идентична форме &lt;code&gt;arr&lt;/code&gt; , за исключением измерения по &lt;code&gt;axis&lt;/code&gt; . Эта ось удаляется и заменяется новыми размерами, равными форме возвращаемого значения &lt;code&gt;func1d&lt;/code&gt; . Таким образом, если &lt;code&gt;func1d&lt;/code&gt; возвращает скаляр, &lt;code&gt;out&lt;/code&gt; будет иметь на одно измерение меньше, чем &lt;code&gt;arr&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8620240fb2ec2168fe1488fc7c50d1b1766a372e" translate="yes" xml:space="preserve">
          <source>The output at position m is the m-th element of the array in &lt;code&gt;choicelist&lt;/code&gt; where the m-th element of the corresponding array in &lt;code&gt;condlist&lt;/code&gt; is True.</source>
          <target state="translated">Выход в положении м является т-й элементом массива в списке &lt;code&gt;choicelist&lt;/code&gt; , где т-й элемент соответствующего массива в &lt;code&gt;condlist&lt;/code&gt; верно.</target>
        </trans-unit>
        <trans-unit id="0043f09ea13cb649da8f2d6d2895f2519551c732" translate="yes" xml:space="preserve">
          <source>The output data type. It must be specified as either a string of typecode characters or a list of data type specifiers. There should be one data type specifier for each output.</source>
          <target state="translated">Тип выходных данных.Он должен быть указан либо в виде строки символов шрифта,либо в виде списка спецификаторов типа данных.Для каждого вывода должен быть один спецификатор типа данных.</target>
        </trans-unit>
        <trans-unit id="abacf3469f99309139bddd0efe494fc74e079f06" translate="yes" xml:space="preserve">
          <source>The output has the same shape as the input and each 1-D loop operates over</source>
          <target state="translated">Выход имеет ту же форму,что и вход,и каждый 1-D цикл работает через</target>
        </trans-unit>
        <trans-unit id="63770907dcff4eb26363f61fd3098799f014e4b4" translate="yes" xml:space="preserve">
          <source>The output is a &lt;a href=&quot;https://docs.python.org/dev/tutorial/datastructures.html#tut-tuples&quot;&gt;tuple&lt;/a&gt; with three elements, which means that this is a three-dimensional array. In fact, since this is a color image, and we have used the &lt;code&gt;imread&lt;/code&gt; function to read it, the data is organized in three 2D arrays, representing color channels (in this case, red, green and blue - RGB). You can see this by looking at the shape above: it indicates that we have an array of 3 matrices, each having shape 768x1024.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2e90afe5c10bc3b541c84caa9141acf978817abb" translate="yes" xml:space="preserve">
          <source>The output is left-padded by the length of the prefix string, and wrapping is forced at the column &lt;code&gt;max_line_width - len(suffix)&lt;/code&gt;. It should be noted that the content of prefix and suffix strings are not included in the output.</source>
          <target state="translated">Выходные данные дополняются слева длиной строки префикса, а перенос принудительно выполняется в столбце &lt;code&gt;max_line_width - len(suffix)&lt;/code&gt; . Следует отметить, что содержимое строк префикса и суффикса не включается в вывод.</target>
        </trans-unit>
        <trans-unit id="e11dba8a2e35e34ff280ff12d3cc6c9a772a17ab" translate="yes" xml:space="preserve">
          <source>The output is sorted along the key.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8da09507a5558a4c68826bbfbad5a55048ee486a" translate="yes" xml:space="preserve">
          <source>The output is the same shape and type as x and is found by calling the functions in &lt;code&gt;funclist&lt;/code&gt; on the appropriate portions of &lt;code&gt;x&lt;/code&gt;, as defined by the boolean arrays in &lt;code&gt;condlist&lt;/code&gt;. Portions not covered by any condition have a default value of 0.</source>
          <target state="translated">Выходные данные имеют ту же форму и тип, что и x, и находятся путем вызова функций в &lt;code&gt;funclist&lt;/code&gt; для соответствующих частей &lt;code&gt;x&lt;/code&gt; , как определено логическими массивами в &lt;code&gt;condlist&lt;/code&gt; . Части, на которые не распространяется какое-либо условие, по умолчанию имеют значение 0.</target>
        </trans-unit>
        <trans-unit id="f50dbb1c407bc1480ac12746928854d5651c29cc" translate="yes" xml:space="preserve">
          <source>The output of &lt;code&gt;argwhere&lt;/code&gt; is not suitable for indexing arrays. For this purpose use &lt;code&gt;nonzero(a)&lt;/code&gt; instead.</source>
          <target state="translated">Вывод &lt;code&gt;argwhere&lt;/code&gt; не подходит для индексирования массивов. Для этого используйте вместо него &lt;code&gt;nonzero(a)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9cad5509a2704fc8189ddac84d202e22c4e895ee" translate="yes" xml:space="preserve">
          <source>The output of the ufunc (and its methods) is not necessarily an &lt;a href=&quot;generated/numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;ndarray&lt;/code&gt;&lt;/a&gt;, if all input arguments are not &lt;a href=&quot;generated/numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;ndarrays&lt;/code&gt;&lt;/a&gt;. Indeed, if any input defines an &lt;a href=&quot;arrays.classes#numpy.class.__array_ufunc__&quot;&gt;&lt;code&gt;__array_ufunc__&lt;/code&gt;&lt;/a&gt; method, control will be passed completely to that function, i.e., the ufunc is &lt;a href=&quot;https://docs.scipy.org/doc/numpy-1.17.0/reference/ufuncs.overrides&quot;&gt;overridden&lt;/a&gt;.</source>
          <target state="translated">Вывод ufunc (и его методов) не обязательно является &lt;a href=&quot;generated/numpy.ndarray#numpy.ndarray&quot;&gt; &lt;code&gt;ndarray&lt;/code&gt; &lt;/a&gt; , если все входные аргументы не являются &lt;a href=&quot;generated/numpy.ndarray#numpy.ndarray&quot;&gt; &lt;code&gt;ndarrays&lt;/code&gt; &lt;/a&gt; . В самом деле, если какой-либо ввод определяет метод &lt;a href=&quot;arrays.classes#numpy.class.__array_ufunc__&quot;&gt; &lt;code&gt;__array_ufunc__&lt;/code&gt; &lt;/a&gt; , управление будет полностью передано этой функции, т. Е. Ufunc &lt;a href=&quot;https://docs.scipy.org/doc/numpy-1.17.0/reference/ufuncs.overrides&quot;&gt;переопределится&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="6599e81d2d214234687adf6fb69ac2c773f47b7b" translate="yes" xml:space="preserve">
          <source>The output of the ufunc (and its methods) is not necessarily an &lt;a href=&quot;generated/numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;ndarray&lt;/code&gt;&lt;/a&gt;, if all input arguments are not &lt;a href=&quot;generated/numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;ndarrays&lt;/code&gt;&lt;/a&gt;. Indeed, if any input defines an &lt;a href=&quot;arrays.classes#numpy.class.__array_ufunc__&quot;&gt;&lt;code&gt;__array_ufunc__&lt;/code&gt;&lt;/a&gt; method, control will be passed completely to that function, i.e., the ufunc is &lt;a href=&quot;https://numpy.org/doc/1.19/reference/ufuncs.overrides&quot;&gt;overridden&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dffd3ba3dd5dfca8ee836a2b9bb97cc8318013a0" translate="yes" xml:space="preserve">
          <source>The output shape in the dense case is obtained by prepending the number of dimensions in front of the tuple of dimensions, i.e. if &lt;code&gt;dimensions&lt;/code&gt; is a tuple &lt;code&gt;(r0, ..., rN-1)&lt;/code&gt; of length &lt;code&gt;N&lt;/code&gt;, the output shape is &lt;code&gt;(N, r0, ..., rN-1)&lt;/code&gt;.</source>
          <target state="translated">Форма вывода в плотном случае получается добавлением числа измерений перед кортежем измерений, то есть, если &lt;code&gt;dimensions&lt;/code&gt; являются кортежем &lt;code&gt;(r0, ..., rN-1)&lt;/code&gt; длины &lt;code&gt;N&lt;/code&gt; , форма вывода будет &lt;code&gt;(N, r0, ..., rN-1)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b58a2d32420f4e758be11c792f006660e86c89ee" translate="yes" xml:space="preserve">
          <source>The output type is determined by evaluating the first element of the input, unless it is specified:</source>
          <target state="translated">Тип выхода определяется путем вычисления первого элемента входа,если он не указан:</target>
        </trans-unit>
        <trans-unit id="a8b2e53b333d791e589c426b13ebb877541abc09" translate="yes" xml:space="preserve">
          <source>The output, analogously to &lt;a href=&quot;numpy.fft.fft#numpy.fft.fft&quot;&gt;&lt;code&gt;fft&lt;/code&gt;&lt;/a&gt;, contains the term for zero frequency in the low-order corner of all axes, the positive frequency terms in the first half of all axes, the term for the Nyquist frequency in the middle of all axes and the negative frequency terms in the second half of all axes, in order of decreasingly negative frequency.</source>
          <target state="translated">Выходной сигнал, аналогично &lt;a href=&quot;numpy.fft.fft#numpy.fft.fft&quot;&gt; &lt;code&gt;fft&lt;/code&gt; &lt;/a&gt; , содержит член для нулевой частоты в нижнем углу всех осей, члены положительной частоты в первой половине всех осей, член для частоты Найквиста в середине всех осей и отрицательный частотные члены во второй половине всех осей в порядке убывания отрицательной частоты.</target>
        </trans-unit>
        <trans-unit id="2e04271603cd70e84ef996c185fb1fb3c75eb84c" translate="yes" xml:space="preserve">
          <source>The output, analogously to &lt;a href=&quot;numpy.fft.fft#numpy.fft.fft&quot;&gt;&lt;code&gt;fft&lt;/code&gt;&lt;/a&gt;, contains the term for zero frequency in the low-order corner of the transformed axes, the positive frequency terms in the first half of these axes, the term for the Nyquist frequency in the middle of the axes and the negative frequency terms in the second half of the axes, in order of decreasingly negative frequency.</source>
          <target state="translated">Выходные данные, аналогично &lt;a href=&quot;numpy.fft.fft#numpy.fft.fft&quot;&gt; &lt;code&gt;fft&lt;/code&gt; &lt;/a&gt; , содержат член для нулевой частоты в нижнем углу преобразованных осей, члены положительной частоты в первой половине этих осей, член для частоты Найквиста в середине осей и отрицательные частотные члены во второй половине осей в порядке убывания отрицательной частоты.</target>
        </trans-unit>
        <trans-unit id="ed35a4029927607a6ec8e44ffef5c4477bb8a981" translate="yes" xml:space="preserve">
          <source>The package ensures that masked entries are not used in computations.</source>
          <target state="translated">Пакет гарантирует,что маскированные записи не будут использоваться в вычислениях.</target>
        </trans-unit>
        <trans-unit id="f6f78aee1988dc701d01aad263b1da5166d3a53f" translate="yes" xml:space="preserve">
          <source>The padding character to use (default is space).</source>
          <target state="translated">Используемый символ подкладки (по умолчанию-пробел).</target>
        </trans-unit>
        <trans-unit id="7e8fe55b063cd4163ba4aeac13d68612e9f5d53b" translate="yes" xml:space="preserve">
          <source>The padding function, if used, should modify a rank 1 array in-place. It has the following signature:</source>
          <target state="translated">Функция подкладки,если она используется,должна модифицировать массив ранга 1 на месте.Она имеет следующую подпись:</target>
        </trans-unit>
        <trans-unit id="91842f7bb32c0502ac19c7e4e8ff23d234b3cdfd" translate="yes" xml:space="preserve">
          <source>The parameter &lt;code&gt;oa_ndim&lt;/code&gt;, when not zero or -1, specifies the number of dimensions that will be iterated with customized broadcasting. If it is provided, &lt;code&gt;op_axes&lt;/code&gt; must and &lt;code&gt;itershape&lt;/code&gt; can also be provided. The &lt;code&gt;op_axes&lt;/code&gt; parameter let you control in detail how the axes of the operand arrays get matched together and iterated. In &lt;code&gt;op_axes&lt;/code&gt;, you must provide an array of &lt;code&gt;nop&lt;/code&gt; pointers to &lt;code&gt;oa_ndim&lt;/code&gt;-sized arrays of type &lt;code&gt;npy_intp&lt;/code&gt;. If an entry in &lt;code&gt;op_axes&lt;/code&gt; is NULL, normal broadcasting rules will apply. In &lt;code&gt;op_axes[j][i]&lt;/code&gt; is stored either a valid axis of &lt;code&gt;op[j]&lt;/code&gt;, or -1 which means &lt;code&gt;newaxis&lt;/code&gt;. Within each &lt;code&gt;op_axes[j]&lt;/code&gt; array, axes may not be repeated. The following example is how normal broadcasting applies to a 3-D array, a 2-D array, a 1-D array and a scalar.</source>
          <target state="translated">Параметр &lt;code&gt;oa_ndim&lt;/code&gt; , если он не равен нулю или -1, указывает количество измерений, которые будут повторяться с настраиваемой широковещательной передачей. Если он предоставляется, необходимо &lt;code&gt;itershape&lt;/code&gt; &lt;code&gt;op_axes&lt;/code&gt; и также можно указать itershape . Параметр &lt;code&gt;op_axes&lt;/code&gt; позволяет подробно контролировать, как оси массивов операндов сопоставляются и повторяются. В &lt;code&gt;op_axes&lt;/code&gt; вы должны предоставить массив указателей &lt;code&gt;nop&lt;/code&gt; на массивы &lt;code&gt;oa_ndim&lt;/code&gt; oa_ndim типа &lt;code&gt;npy_intp&lt;/code&gt; . Если запись в &lt;code&gt;op_axes&lt;/code&gt; имеет значение NULL, будут применяться обычные правила широковещательной передачи. В &lt;code&gt;op_axes[j][i]&lt;/code&gt; хранится либо действительная ось &lt;code&gt;op[j]&lt;/code&gt; , либо -1, что означает &lt;code&gt;newaxis&lt;/code&gt; . В каждом &lt;code&gt;op_axes[j]&lt;/code&gt; оси не могут повторяться. В следующем примере показано, как обычное широковещание применяется к трехмерному массиву, двумерному массиву, одномерному массиву и скаляру.</target>
        </trans-unit>
        <trans-unit id="6f24110e4501ed427c7d67150722a36e47c9eb87" translate="yes" xml:space="preserve">
          <source>The parameter &lt;code&gt;x&lt;/code&gt; is converted to an array only if it is a tuple or a list, otherwise it is treated as a scalar. In either case, either &lt;code&gt;x&lt;/code&gt; or its elements must support multiplication and addition both with themselves and with the elements of &lt;code&gt;c&lt;/code&gt;.</source>
          <target state="translated">Параметр &lt;code&gt;x&lt;/code&gt; преобразуется в массив, только если это кортеж или список, в противном случае он рассматривается как скаляр. В любом случае либо &lt;code&gt;x&lt;/code&gt; , либо его элементы должны поддерживать умножение и сложение как с самими собой, так и с элементами &lt;code&gt;c&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="81b1fc95a0e75fbef51d185592084c9ff4aaba4c" translate="yes" xml:space="preserve">
          <source>The parameter &lt;code&gt;x&lt;/code&gt; is converted to an array only if it is a tuple or a list, otherwise it is treated as a scalar. In either case, either &lt;code&gt;x&lt;/code&gt; or its elements must support multiplication and addition both with themselves and with the elements of &lt;code&gt;r&lt;/code&gt;.</source>
          <target state="translated">Параметр &lt;code&gt;x&lt;/code&gt; преобразуется в массив, только если это кортеж или список, в противном случае он рассматривается как скаляр. В любом случае либо &lt;code&gt;x&lt;/code&gt; , либо его элементы должны поддерживать умножение и сложение как с самими собой, так и с элементами &lt;code&gt;r&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="fed3e36a151b3d1051d8c0d0e63efcd30243f871" translate="yes" xml:space="preserve">
          <source>The parameter &lt;em&gt;dtype&lt;/em&gt; specifies the data type over which a reduction operation (like summing) should take place. The default reduce data type is the same as the data type of &lt;em&gt;self&lt;/em&gt;. To avoid overflow, it can be useful to perform the reduction using a larger data type.</source>
          <target state="translated">Параметр &lt;em&gt;dtype&lt;/em&gt; указывает тип данных, над которым должна выполняться операция сокращения (например, суммирование). Тип данных сокращения по умолчанию такой же, как тип данных &lt;em&gt;self&lt;/em&gt; . Чтобы избежать переполнения, может быть полезно выполнить сокращение, используя больший тип данных.</target>
        </trans-unit>
        <trans-unit id="5047704927c94b8b6586c636aa20a6789550df01" translate="yes" xml:space="preserve">
          <source>The parameters &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; are converted to arrays only if they are tuples or a lists, otherwise they are treated as a scalars and they must have the same shape after conversion. In either case, either &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; or their elements must support multiplication and addition both with themselves and with the elements of &lt;code&gt;c&lt;/code&gt;.</source>
          <target state="translated">Параметры &lt;code&gt;x&lt;/code&gt; и &lt;code&gt;y&lt;/code&gt; преобразуются в массивы только в том случае, если они являются кортежами или списками, в противном случае они обрабатываются как скаляры и должны иметь ту же форму после преобразования. В любом случае либо &lt;code&gt;x&lt;/code&gt; и &lt;code&gt;y&lt;/code&gt; , либо их элементы должны поддерживать умножение и сложение как с самими собой, так и с элементами &lt;code&gt;c&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ab30d7deae7ce08d9cafc57f0a0d9da22b443d75" translate="yes" xml:space="preserve">
          <source>The parameters &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; are converted to arrays only if they are tuples or a lists, otherwise they are treated as a scalars. In either case, either &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; or their elements must support multiplication and addition both with themselves and with the elements of &lt;code&gt;c&lt;/code&gt;.</source>
          <target state="translated">Параметры &lt;code&gt;x&lt;/code&gt; и &lt;code&gt;y&lt;/code&gt; преобразуются в массивы, только если они являются кортежами или списками, в противном случае они обрабатываются как скаляры. В любом случае либо &lt;code&gt;x&lt;/code&gt; и &lt;code&gt;y&lt;/code&gt; , либо их элементы должны поддерживать умножение и сложение как с собой, так и с элементами &lt;code&gt;c&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="dea737cd6cbb9eb4fabc09fa179fafbb398a4ba4" translate="yes" xml:space="preserve">
          <source>The parameters &lt;code&gt;x&lt;/code&gt;, &lt;code&gt;y&lt;/code&gt;, and &lt;code&gt;z&lt;/code&gt; are converted to arrays only if they are tuples or a lists, otherwise they are treated as a scalars and they must have the same shape after conversion. In either case, either &lt;code&gt;x&lt;/code&gt;, &lt;code&gt;y&lt;/code&gt;, and &lt;code&gt;z&lt;/code&gt; or their elements must support multiplication and addition both with themselves and with the elements of &lt;code&gt;c&lt;/code&gt;.</source>
          <target state="translated">Параметры &lt;code&gt;x&lt;/code&gt; , &lt;code&gt;y&lt;/code&gt; и &lt;code&gt;z&lt;/code&gt; преобразуются в массивы только в том случае, если они являются кортежами или списками, в противном случае они рассматриваются как скаляры и должны иметь ту же форму после преобразования. В любом случае либо &lt;code&gt;x&lt;/code&gt; , &lt;code&gt;y&lt;/code&gt; и &lt;code&gt;z&lt;/code&gt; , либо их элементы должны поддерживать умножение и сложение как с собой, так и с элементами &lt;code&gt;c&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="942247face18dfe9d547bf9f163892321bfcd347" translate="yes" xml:space="preserve">
          <source>The parameters &lt;code&gt;x&lt;/code&gt;, &lt;code&gt;y&lt;/code&gt;, and &lt;code&gt;z&lt;/code&gt; are converted to arrays only if they are tuples or a lists, otherwise they are treated as a scalars. In either case, either &lt;code&gt;x&lt;/code&gt;, &lt;code&gt;y&lt;/code&gt;, and &lt;code&gt;z&lt;/code&gt; or their elements must support multiplication and addition both with themselves and with the elements of &lt;code&gt;c&lt;/code&gt;.</source>
          <target state="translated">Параметры &lt;code&gt;x&lt;/code&gt; , &lt;code&gt;y&lt;/code&gt; и &lt;code&gt;z&lt;/code&gt; преобразуются в массивы, только если они являются кортежами или списками, в противном случае они рассматриваются как скаляры. В любом случае либо &lt;code&gt;x&lt;/code&gt; , &lt;code&gt;y&lt;/code&gt; и &lt;code&gt;z&lt;/code&gt; , либо их элементы должны поддерживать умножение и сложение как с собой, так и с элементами &lt;code&gt;c&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2f059fed0e631d6e93c76ef517cee1b4493e82a4" translate="yes" xml:space="preserve">
          <source>The path of the template, relatively to the current package path.</source>
          <target state="translated">Путь шаблона,относительно текущего пути пакета.</target>
        </trans-unit>
        <trans-unit id="a3bed8bc2ca97f198b6eb9b3e908d4ed3c7c443d" translate="yes" xml:space="preserve">
          <source>The path to the file for which the doctests are run.</source>
          <target state="translated">Путь к файлу,для которого выполняются doctests.</target>
        </trans-unit>
        <trans-unit id="decb24fde62e2b923b5a976163e8c054497d68bf" translate="yes" xml:space="preserve">
          <source>The pattern for using nested iterators is as follows.</source>
          <target state="translated">Образец использования вложенных итераторов выглядит следующим образом.</target>
        </trans-unit>
        <trans-unit id="9db61e58e4763f03cd16195e5ed8a40825c96961" translate="yes" xml:space="preserve">
          <source>The pattern is similar for other, more complex generators. The normal performance of the legacy &lt;a href=&quot;legacy#numpy.random.RandomState&quot;&gt;&lt;code&gt;RandomState&lt;/code&gt;&lt;/a&gt; generator is much lower than the other since it uses the Box-Muller transformation rather than the Ziggurat generator. The performance gap for Exponentials is also large due to the cost of computing the log function to invert the CDF. The column labeled MT19973 is used the same 32-bit generator as &lt;a href=&quot;legacy#numpy.random.RandomState&quot;&gt;&lt;code&gt;RandomState&lt;/code&gt;&lt;/a&gt; but produces random values using &lt;a href=&quot;generator#numpy.random.Generator&quot;&gt;&lt;code&gt;Generator&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="82eacc753e4241f8676568f6609cbd6d30cfc9ba" translate="yes" xml:space="preserve">
          <source>The pattern is similar for other, more complex generators. The normal performance of the legacy &lt;a href=&quot;legacy#numpy.random.mtrand.RandomState&quot;&gt;&lt;code&gt;RandomState&lt;/code&gt;&lt;/a&gt; generator is much lower than the other since it uses the Box-Muller transformation rather than the Ziggurat generator. The performance gap for Exponentials is also large due to the cost of computing the log function to invert the CDF. The column labeled MT19973 is used the same 32-bit generator as &lt;a href=&quot;legacy#numpy.random.mtrand.RandomState&quot;&gt;&lt;code&gt;RandomState&lt;/code&gt;&lt;/a&gt; but produces random values using &lt;a href=&quot;generator#numpy.random.Generator&quot;&gt;&lt;code&gt;Generator&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Схема аналогична для других, более сложных генераторов. Обычная производительность унаследованного генератора &lt;a href=&quot;legacy#numpy.random.mtrand.RandomState&quot;&gt; &lt;code&gt;RandomState&lt;/code&gt; &lt;/a&gt; намного ниже, чем у другого генератора, поскольку он использует преобразование Бокса-Мюллера, а не генератор Зиккурата. Разрыв в производительности для Exponentials также велик из-за стоимости вычисления функции журнала для инвертирования CDF. В столбце MT19973 используется тот же 32-битный генератор, что и &lt;a href=&quot;legacy#numpy.random.mtrand.RandomState&quot;&gt; &lt;code&gt;RandomState&lt;/code&gt; ,&lt;/a&gt; но генерируются случайные значения с помощью &lt;a href=&quot;generator#numpy.random.Generator&quot;&gt; &lt;code&gt;Generator&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="5f948cd9daa190278b24b7616c4acaf6e82e63af" translate="yes" xml:space="preserve">
          <source>The payment is computed by solving the equation:</source>
          <target state="translated">Платеж рассчитывается путем решения уравнения:</target>
        </trans-unit>
        <trans-unit id="7c38a52dfb1124cf95fad23836990fb2bf0bbca3" translate="yes" xml:space="preserve">
          <source>The percentage of waves larger than 3 meters is:</source>
          <target state="translated">Процент волн больше 3 метров:</target>
        </trans-unit>
        <trans-unit id="bf26c5d0de790b76d482846fdfc7d5a573504f09" translate="yes" xml:space="preserve">
          <source>The performance of 64-bit generators on 32-bit Windows is much lower than on 64-bit operating systems due to register width. MT19937, the generator that has been in NumPy since 2005, operates on 32-bit integers.</source>
          <target state="translated">Производительность 64-битных генераторов на 32-битной Windows значительно ниже,чем на 64-битных операционных системах,за счет ширины регистра.Генератор MT19937,находящийся в NumPy с 2005 года,работает на 32-битных целых числах.</target>
        </trans-unit>
        <trans-unit id="02f4c7c728252209e49cade8944d95bdb15fb9ef" translate="yes" xml:space="preserve">
          <source>The place in the code corresponding to the actual computations for the ufunc are marked with /*BEGIN main ufunc computation*/ and /*END main ufunc computation*/. The code in between those lines is the primary thing that must be changed to create your own ufunc.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e0a72aed7747ec5b4e706a7296ecd1eb9faae060" translate="yes" xml:space="preserve">
          <source>The places in the code corresponding to the actual computations for the ufunc are marked with /*BEGIN main ufunc computation*/ and /*END main ufunc computation*/. The code in between those lines is the primary thing that must be changed to create your own ufunc.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4a5ee23f497e38c29e0616fdcc0bb0ea7d4426f2" translate="yes" xml:space="preserve">
          <source>The points about sequence size and speed are particularly important in scientific computing. As a simple example, consider the case of multiplying each element in a 1-D sequence with the corresponding element in another sequence of the same length. If the data are stored in two Python lists, &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt;, we could iterate over each element:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0779c65ec163a12759193f89f82723f01bb394dd" translate="yes" xml:space="preserve">
          <source>The polynomial coefficients</source>
          <target state="translated">Полиномиальные коэффициенты</target>
        </trans-unit>
        <trans-unit id="daaa36d42f5e3da309c9eab093a92efe7a0076ca" translate="yes" xml:space="preserve">
          <source>The polynomial convenience classes cannot be passed to ufuncs</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b9ed1328025571c1195a04bff5fdf98ece032c1f" translate="yes" xml:space="preserve">
          <source>The polynomial resulting from the multiplication of the inputs. If either inputs is a poly1d object, then the output is also a poly1d object. Otherwise, it is a 1D array of polynomial coefficients from highest to lowest degree.</source>
          <target state="translated">Полиноминал,получаемый в результате умножения входов.Если любой из входов является полиномиальным объектом,то выход также является полиномиальным объектом.В противном случае это 1D массив полиномиальных коэффициентов от высшей до низшей степени.</target>
        </trans-unit>
        <trans-unit id="515cfb6ef96288d03850b077c1e2ea4a5a576f0e" translate="yes" xml:space="preserve">
          <source>The polynomial series type class to which the current instance should be converted. If kind is None, then the class of the current instance is used.</source>
          <target state="translated">Класс типа полиномиальных серий,к которому должен быть приведен текущий экземпляр.Если тип None,то используется класс текущего экземпляра.</target>
        </trans-unit>
        <trans-unit id="75f7f784e98730c24c6aac1a9a0a155ec4addf47" translate="yes" xml:space="preserve">
          <source>The polynomial&amp;rsquo;s coefficients, in decreasing powers, or if the value of the second parameter is True, the polynomial&amp;rsquo;s roots (values where the polynomial evaluates to 0). For example, &lt;code&gt;poly1d([1, 2, 3])&lt;/code&gt; returns an object that represents</source>
          <target state="translated">Коэффициенты полинома в убывающих степенях или, если значение второго параметра равно True, корни полинома (значения, при которых полином равен 0). Например, &lt;code&gt;poly1d([1, 2, 3])&lt;/code&gt; возвращает объект, представляющий</target>
        </trans-unit>
        <trans-unit id="80160250c999cde418e5655d194ff040c11e355e" translate="yes" xml:space="preserve">
          <source>The position,</source>
          <target state="translated">Положение,</target>
        </trans-unit>
        <trans-unit id="04babac298b058269a3dd833ef7829f7e3894479" translate="yes" xml:space="preserve">
          <source>The possibly nested list of array elements.</source>
          <target state="translated">Возможно,вложенный список элементов массива.</target>
        </trans-unit>
        <trans-unit id="5cb3bd54a03911e525c1ba1e36e3cfe8b319cbe5" translate="yes" xml:space="preserve">
          <source>The power function distribution is just the inverse of the Pareto distribution. It may also be seen as a special case of the Beta distribution.</source>
          <target state="translated">Распределение силовой функции является лишь обратной величиной распределения Парето.Его также можно рассматривать как особый случай распределения Бета-функций.</target>
        </trans-unit>
        <trans-unit id="65b60415cb79d4266b3f17e50b1894cd53e37067" translate="yes" xml:space="preserve">
          <source>The preferred way to update the documentation is by submitting a pull request on Github (see the &lt;a href=&quot;docs/index&quot;&gt;Documentation Index&lt;/a&gt;). Please help us to further improve the NumPy documentation!</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2f79358f94b924f7a1e059d54f311b3bb21fdafb" translate="yes" xml:space="preserve">
          <source>The preferred way to use a BitGenerator in parallel applications is to use the &lt;a href=&quot;generated/numpy.random.seedsequence.spawn#numpy.random.SeedSequence.spawn&quot;&gt;&lt;code&gt;SeedSequence.spawn&lt;/code&gt;&lt;/a&gt; method to obtain entropy values, and to use these to generate new BitGenerators:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bce0b83b0022d3f62b001c90ef9147d9a4659969" translate="yes" xml:space="preserve">
          <source>The preferred way to use a BitGenerator in parallel applications is to use the &lt;code&gt;SeedSequence.spawn&lt;/code&gt; method to obtain entropy values, and to use these to generate new BitGenerators:</source>
          <target state="translated">Предпочтительный способ использования BitGenerator в параллельных приложениях - использовать метод &lt;code&gt;SeedSequence.spawn&lt;/code&gt; для получения значений энтропии и использовать их для создания новых BitGenerator:</target>
        </trans-unit>
        <trans-unit id="7ca668d501fbd18bd9dc320e9a4abf1ee3d102d7" translate="yes" xml:space="preserve">
          <source>The preprocessing of generically typed C source files (whether in NumPy proper or in any third party package using NumPy Distutils) is performed by &lt;a href=&quot;https://github.com/numpy/numpy/blob/master/numpy/distutils/conv_template.py&quot;&gt;conv_template.py&lt;/a&gt;. The type specific C files generated (extension: .c) by these modules during the build process are ready to be compiled. This form of generic typing is also supported for C header files (preprocessed to produce .h files).</source>
          <target state="translated">Предварительная обработка типизированных исходных файлов C (как в собственном NumPy, так и в любом стороннем пакете с использованием NumPy Distutils) выполняется с помощью &lt;a href=&quot;https://github.com/numpy/numpy/blob/master/numpy/distutils/conv_template.py&quot;&gt;conv_template.py&lt;/a&gt; . Файлы C для конкретного типа, созданные этими модулями (расширение: .c) в процессе сборки, готовы к компиляции. Эта форма общей типизации также поддерживается для файлов заголовков C (предварительно обработанных для создания файлов .h).</target>
        </trans-unit>
        <trans-unit id="79ca2b18555d36b1c58583e3de2322375811401a" translate="yes" xml:space="preserve">
          <source>The presence of &lt;a href=&quot;#numpy.class.__array_ufunc__&quot;&gt;&lt;code&gt;__array_ufunc__&lt;/code&gt;&lt;/a&gt; also influences how &lt;a href=&quot;generated/numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;ndarray&lt;/code&gt;&lt;/a&gt; handles binary operations like &lt;code&gt;arr + obj&lt;/code&gt; and &lt;code&gt;arr
&amp;lt; obj&lt;/code&gt; when &lt;code&gt;arr&lt;/code&gt; is an &lt;a href=&quot;generated/numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;ndarray&lt;/code&gt;&lt;/a&gt; and &lt;code&gt;obj&lt;/code&gt; is an instance of a custom class. There are two possibilities. If &lt;code&gt;obj.__array_ufunc__&lt;/code&gt; is present and not &lt;a href=&quot;https://docs.python.org/dev/library/constants.html#None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt;, then &lt;code&gt;ndarray.__add__&lt;/code&gt; and friends will delegate to the ufunc machinery, meaning that &lt;code&gt;arr + obj&lt;/code&gt; becomes &lt;code&gt;np.add(arr, obj)&lt;/code&gt;, and then &lt;a href=&quot;generated/numpy.add#numpy.add&quot;&gt;&lt;code&gt;add&lt;/code&gt;&lt;/a&gt; invokes &lt;code&gt;obj.__array_ufunc__&lt;/code&gt;. This is useful if you want to define an object that acts like an array.</source>
          <target state="translated">Наличие &lt;a href=&quot;#numpy.class.__array_ufunc__&quot;&gt; &lt;code&gt;__array_ufunc__&lt;/code&gt; &lt;/a&gt; также влияет на то, как &lt;a href=&quot;generated/numpy.ndarray#numpy.ndarray&quot;&gt; &lt;code&gt;ndarray&lt;/code&gt; &lt;/a&gt; обрабатывает двоичные операции, такие как &lt;code&gt;arr + obj&lt;/code&gt; и &lt;code&gt;arr &amp;lt; obj&lt;/code&gt; когда &lt;code&gt;arr&lt;/code&gt; является &lt;a href=&quot;generated/numpy.ndarray#numpy.ndarray&quot;&gt; &lt;code&gt;ndarray&lt;/code&gt; ,&lt;/a&gt; а &lt;code&gt;obj&lt;/code&gt; - экземпляром настраиваемого класса. Есть две возможности. Если &lt;code&gt;obj.__array_ufunc__&lt;/code&gt; присутствует и не &lt;a href=&quot;https://docs.python.org/dev/library/constants.html#None&quot;&gt; &lt;code&gt;None&lt;/code&gt; &lt;/a&gt; , то &lt;code&gt;ndarray.__add__&lt;/code&gt; и друзья будут делегировать ufunc машины, а это означает , что &lt;code&gt;arr + obj&lt;/code&gt; становится &lt;code&gt;np.add(arr, obj)&lt;/code&gt; , а затем &lt;a href=&quot;generated/numpy.add#numpy.add&quot;&gt; &lt;code&gt;add&lt;/code&gt; &lt;/a&gt; вызывающую &lt;code&gt;obj.__array_ufunc__&lt;/code&gt; . Это полезно, если вы хотите определить объект, который действует как массив.</target>
        </trans-unit>
        <trans-unit id="40d6e2ba786e2b9884243f86e826abd1b1d0b0e2" translate="yes" xml:space="preserve">
          <source>The presence of &lt;a href=&quot;#numpy.class.__array_ufunc__&quot;&gt;&lt;code&gt;__array_ufunc__&lt;/code&gt;&lt;/a&gt; also influences how &lt;a href=&quot;generated/numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;ndarray&lt;/code&gt;&lt;/a&gt; handles binary operations like &lt;code&gt;arr + obj&lt;/code&gt; and &lt;code&gt;arr
&amp;lt; obj&lt;/code&gt; when &lt;code&gt;arr&lt;/code&gt; is an &lt;a href=&quot;generated/numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;ndarray&lt;/code&gt;&lt;/a&gt; and &lt;code&gt;obj&lt;/code&gt; is an instance of a custom class. There are two possibilities. If &lt;code&gt;obj.__array_ufunc__&lt;/code&gt; is present and not None, then &lt;code&gt;ndarray.__add__&lt;/code&gt; and friends will delegate to the ufunc machinery, meaning that &lt;code&gt;arr + obj&lt;/code&gt; becomes &lt;code&gt;np.add(arr, obj)&lt;/code&gt;, and then &lt;a href=&quot;generated/numpy.add#numpy.add&quot;&gt;&lt;code&gt;add&lt;/code&gt;&lt;/a&gt; invokes &lt;code&gt;obj.__array_ufunc__&lt;/code&gt;. This is useful if you want to define an object that acts like an array.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6adb356cfd1303c61f397a436f3cf821b0707e98" translate="yes" xml:space="preserve">
          <source>The presence of a header in the file can hinder data processing. In that case, we need to use the &lt;code&gt;skip_header&lt;/code&gt; optional argument. The values of this argument must be an integer which corresponds to the number of lines to skip at the beginning of the file, before any other action is performed. Similarly, we can skip the last &lt;code&gt;n&lt;/code&gt; lines of the file by using the &lt;code&gt;skip_footer&lt;/code&gt; attribute and giving it a value of &lt;code&gt;n&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e5f36326e83630873ee2db09163f521fed09ccf8" translate="yes" xml:space="preserve">
          <source>The present value is computed by solving the equation:</source>
          <target state="translated">Настоящее значение вычисляется путем решения уравнения:</target>
        </trans-unit>
        <trans-unit id="601986bff68f0c999502156a5c8a6f32ded002a4" translate="yes" xml:space="preserve">
          <source>The primary advantage of using array scalars is that they preserve the array type (Python may not have a matching scalar type available, e.g. &lt;code&gt;int16&lt;/code&gt;). Therefore, the use of array scalars ensures identical behaviour between arrays and scalars, irrespective of whether the value is inside an array or not. NumPy scalars also have many of the same methods arrays do.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8c51c177d3ffae7eeb654a1cd5049b77b590c4db" translate="yes" xml:space="preserve">
          <source>The primitive types supported are tied closely to those in C:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8faab5fdb76f1a3f47be9fc86bef262e2ab4b27a" translate="yes" xml:space="preserve">
          <source>The probabilities associated with each entry in a. If not given the sample assumes a uniform distribution over all entries in a.</source>
          <target state="translated">Вероятности,связанные с каждой записью в a.Если не приводить выборку,то предполагается равномерное распределение по всем записям в a.</target>
        </trans-unit>
        <trans-unit id="8e475ecd8059b20acc5cee6528910a74a85f3b11" translate="yes" xml:space="preserve">
          <source>The probability density for the Gamma distribution is</source>
          <target state="translated">Плотность вероятности для гамма-распределения составляет</target>
        </trans-unit>
        <trans-unit id="de744fd74c21b122de22a0d8e948a2a51ccc2b96" translate="yes" xml:space="preserve">
          <source>The probability density for the Gaussian distribution is</source>
          <target state="translated">Плотность вероятности для гауссовского распределения равна</target>
        </trans-unit>
        <trans-unit id="5905e8ef12f7d0d9eb54f382d72998ae48c8ef44" translate="yes" xml:space="preserve">
          <source>The probability density for the Gumbel distribution is</source>
          <target state="translated">Плотность вероятности для распределения Гумбеля составляет</target>
        </trans-unit>
        <trans-unit id="bfb8724927e73ab8d936772b36c634818f86c5a4" translate="yes" xml:space="preserve">
          <source>The probability density for the Hypergeometric distribution is</source>
          <target state="translated">Плотность вероятности для гипергеометрического распределения составляет</target>
        </trans-unit>
        <trans-unit id="f8985b96e26b0408a1f84b2787ee767e62c90303" translate="yes" xml:space="preserve">
          <source>The probability density for the Log Series distribution is</source>
          <target state="translated">Плотность вероятности для распределения серии бревен</target>
        </trans-unit>
        <trans-unit id="99fc9473ccfc113313d9fd374b914f025b58f310" translate="yes" xml:space="preserve">
          <source>The probability density for the Logistic distribution is</source>
          <target state="translated">Плотность вероятности для Логистического распределения</target>
        </trans-unit>
        <trans-unit id="7985bdd977289b5652a3a0bba81a5da1bd3adf6d" translate="yes" xml:space="preserve">
          <source>The probability density for the Pareto distribution is</source>
          <target state="translated">Плотность вероятности для распределения Парето равна</target>
        </trans-unit>
        <trans-unit id="238160654ada0174d17d83e1f0d7a26707c02c8d" translate="yes" xml:space="preserve">
          <source>The probability density for the Weibull distribution is</source>
          <target state="translated">Плотность вероятности для распределения Вейбулла составляет</target>
        </trans-unit>
        <trans-unit id="fc3b79ebd29285bfc80812044ba5bd995aaaa06a" translate="yes" xml:space="preserve">
          <source>The probability density for the Zipf distribution is</source>
          <target state="translated">Плотность вероятности для распределения Zipf равна</target>
        </trans-unit>
        <trans-unit id="bb707b06597dece119e6e3ebea40c8f15c1cb44f" translate="yes" xml:space="preserve">
          <source>The probability density for the binomial distribution is</source>
          <target state="translated">Плотность вероятности для биномиального распределения составляет</target>
        </trans-unit>
        <trans-unit id="6264a2e3e986c29af2fd700f69cafdda6f6c9d98" translate="yes" xml:space="preserve">
          <source>The probability density for the von Mises distribution is</source>
          <target state="translated">Плотность вероятности для распределения фон Мизеса составляет</target>
        </trans-unit>
        <trans-unit id="2e977910510c195394a91f298d7c9556abc16027" translate="yes" xml:space="preserve">
          <source>The probability density function</source>
          <target state="translated">Функция плотности вероятности</target>
        </trans-unit>
        <trans-unit id="a293dce90e3fe47dddc6a55e94ccb69a8fef9b0c" translate="yes" xml:space="preserve">
          <source>The probability density function for the Rayleigh distribution is</source>
          <target state="translated">Функция плотности вероятности для релейного распределения состоит в том,что</target>
        </trans-unit>
        <trans-unit id="d3e0872e16a6ab7b6c0ee2a22d52dd0d2e1ca84e" translate="yes" xml:space="preserve">
          <source>The probability density function for the Wald distribution is</source>
          <target state="translated">Функция плотности вероятности для распределения Вальдов является следующей</target>
        </trans-unit>
        <trans-unit id="2f149a65fa2739e5de1eec985af9c1621ffacc73" translate="yes" xml:space="preserve">
          <source>The probability density function for the full Cauchy distribution is</source>
          <target state="translated">Функция плотности вероятности для полного распределения Коши составляет</target>
        </trans-unit>
        <trans-unit id="6b0dc98514227cdd44ff47b528c8a0bcaf89c265" translate="yes" xml:space="preserve">
          <source>The probability density function for the noncentral Chi-square distribution is</source>
          <target state="translated">Функция плотности вероятности для нецентрального распределения хи-квадрат является следующей</target>
        </trans-unit>
        <trans-unit id="c30948020144257a9fb38966abff7c99e81c50e9" translate="yes" xml:space="preserve">
          <source>The probability density function for the t distribution is</source>
          <target state="translated">Функция плотности вероятности для распределения t</target>
        </trans-unit>
        <trans-unit id="dcdbad2794701215e8c40510ff713b7913263c5a" translate="yes" xml:space="preserve">
          <source>The probability density function for the triangular distribution is</source>
          <target state="translated">Функция плотности вероятности для треугольного распределения</target>
        </trans-unit>
        <trans-unit id="6467351c7a0571530575123e2ae036078aaa2303" translate="yes" xml:space="preserve">
          <source>The probability density function is</source>
          <target state="translated">Функция плотности вероятности</target>
        </trans-unit>
        <trans-unit id="ee41aab696af2a63a045005f9a20ab50a30087b5" translate="yes" xml:space="preserve">
          <source>The probability density function of the chi-squared distribution is</source>
          <target state="translated">Функция плотности вероятности в хи-квадратном распределении равна</target>
        </trans-unit>
        <trans-unit id="c5e3eadc4ee0ddfc376707a7c47e36bdec30614e" translate="yes" xml:space="preserve">
          <source>The probability density function of the normal distribution, first derived by De Moivre and 200 years later by both Gauss and Laplace independently &lt;a href=&quot;#r1536f9c044a3-2&quot; id=&quot;id1&quot;&gt;[2]&lt;/a&gt;, is often called the bell curve because of its characteristic shape (see the example below).</source>
          <target state="translated">Функция плотности вероятности нормального распределения, впервые полученная Де Муавром, а 200 лет спустя независимо друг от друга Гауссом и Лапласом &lt;a href=&quot;#r1536f9c044a3-2&quot; id=&quot;id1&quot;&gt;[2]&lt;/a&gt; , часто называется кривой колокола из-за ее характерной формы (см. Пример ниже).</target>
        </trans-unit>
        <trans-unit id="2297eee1a9ef2ae469ffb4ffe7c7db8f4e4f83da" translate="yes" xml:space="preserve">
          <source>The probability density function of the normal distribution, first derived by De Moivre and 200 years later by both Gauss and Laplace independently &lt;a href=&quot;#ra2e838c5ea87-2&quot; id=&quot;id1&quot;&gt;[2]&lt;/a&gt;, is often called the bell curve because of its characteristic shape (see the example below).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d7e2875a44ce7ebdc83cb0f55dc114499ca0e8b1" translate="yes" xml:space="preserve">
          <source>The probability density function of the normal distribution, first derived by De Moivre and 200 years later by both Gauss and Laplace independently &lt;a href=&quot;#rce7db652c312-2&quot; id=&quot;id1&quot;&gt;[2]&lt;/a&gt;, is often called the bell curve because of its characteristic shape (see the example below).</source>
          <target state="translated">Функция плотности вероятности нормального распределения, впервые полученная Де Муавром, а 200 лет спустя независимо друг от друга Гауссом и Лапласом &lt;a href=&quot;#rce7db652c312-2&quot; id=&quot;id1&quot;&gt;[2]&lt;/a&gt; , часто называется кривой колокола из-за ее характерной формы (см. Пример ниже).</target>
        </trans-unit>
        <trans-unit id="31415e3883f5ad2cde00e0bf903f48cc5ab3d293" translate="yes" xml:space="preserve">
          <source>The probability density function of the normal distribution, first derived by De Moivre and 200 years later by both Gauss and Laplace independently &lt;a href=&quot;#rf578abb8fba2-2&quot; id=&quot;id1&quot;&gt;[2]&lt;/a&gt;, is often called the bell curve because of its characteristic shape (see the example below).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2755556e2db9bd446cf581401e578c5337420320" translate="yes" xml:space="preserve">
          <source>The probability density function of the uniform distribution is</source>
          <target state="translated">Функция плотности вероятности равномерного распределения</target>
        </trans-unit>
        <trans-unit id="415051b020f7949a62618fb53ef560dee4613543" translate="yes" xml:space="preserve">
          <source>The probability inputs should be normalized. As an implementation detail, the value of the last entry is ignored and assumed to take up any leftover probability mass, but this should not be relied on. A biased coin which has twice as much weight on one side as on the other should be sampled like so:</source>
          <target state="translated">Вероятностные входы должны быть нормализованы.В качестве реализационной детали значение последней записи игнорируется и предполагается,что она поглотит остаточную массу вероятностей,но на это полагаться не следует.Смещенная монета,имеющая с одной стороны вдвое больший вес,чем с другой,должна быть подвергнута такой выборке:</target>
        </trans-unit>
        <trans-unit id="8e4c202be333253a1251675439dcd7f21c1ef125" translate="yes" xml:space="preserve">
          <source>The probability mass function for the Log Series distribution is</source>
          <target state="translated">Функция массы вероятности для распределения Серии лог-файлов</target>
        </trans-unit>
        <trans-unit id="2d117aed0c4f59861c0b3330028791db8f91f6f5" translate="yes" xml:space="preserve">
          <source>The probability mass function of the geometric distribution is</source>
          <target state="translated">Функция массы вероятности геометрического распределения состоит в следующем</target>
        </trans-unit>
        <trans-unit id="53c49feadffaed0acd89d507cebd4872b9032162" translate="yes" xml:space="preserve">
          <source>The probability mass function of the negative binomial distribution is</source>
          <target state="translated">Функция массы вероятности отрицательного биномиального распределения состоит в том,что</target>
        </trans-unit>
        <trans-unit id="f1f5e6e451a12ecc1dfa7cb3123b997ae141c402" translate="yes" xml:space="preserve">
          <source>The probability of success of an individual trial.</source>
          <target state="translated">Вероятность успеха индивидуального испытания.</target>
        </trans-unit>
        <trans-unit id="c0419d3f3c0dd14cc710a6332bd5b9e9f12f94e6" translate="yes" xml:space="preserve">
          <source>The problem here is that there is one dimension argument and two array arguments, and our typemaps are set up for dimensions that apply to a single array (in fact, &lt;a href=&quot;http://www.swig.org&quot;&gt;SWIG&lt;/a&gt; does not provide a mechanism for associating &lt;code&gt;len&lt;/code&gt; with &lt;code&gt;vec2&lt;/code&gt; that takes two Python input arguments). The recommended solution is the following:</source>
          <target state="translated">Проблема здесь в том, что есть один аргумент измерения и два аргумента массива, а наши карты типов настроены для измерений, которые применяются к одному массиву (фактически, &lt;a href=&quot;http://www.swig.org&quot;&gt;SWIG&lt;/a&gt; не предоставляет механизма для связывания &lt;code&gt;len&lt;/code&gt; с &lt;code&gt;vec2&lt;/code&gt; , который принимает два входных аргумента Python ). Рекомендуемое решение следующее:</target>
        </trans-unit>
        <trans-unit id="258606759bb8ded772cb41c8f492be953461a647" translate="yes" xml:space="preserve">
          <source>The problem is solved exactly. In this case, the function returns True only if there is an element shared between the arrays.</source>
          <target state="translated">Проблема решена точно.В этом случае функция возвращает True только в том случае,если между массивами есть элемент,совместно используемый.</target>
        </trans-unit>
        <trans-unit id="4ad89e6d069e4dfa2e5a4dc8cd5ea0ef4b308ab4" translate="yes" xml:space="preserve">
          <source>The problem is solved exactly. In this case, the function returns True only if there is an element shared between the arrays. Finding the exact solution may take extremely long in some cases.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="12f7b79ffc79e216081a6d98b051a230198244d5" translate="yes" xml:space="preserve">
          <source>The product of &lt;code&gt;x1&lt;/code&gt; and &lt;code&gt;x2&lt;/code&gt;, element-wise. This is a scalar if both &lt;code&gt;x1&lt;/code&gt; and &lt;code&gt;x2&lt;/code&gt; are scalars.</source>
          <target state="translated">Произведение &lt;code&gt;x1&lt;/code&gt; и &lt;code&gt;x2&lt;/code&gt; поэлементно. Это скаляр, если и &lt;code&gt;x1&lt;/code&gt; , и &lt;code&gt;x2&lt;/code&gt; являются скалярами.</target>
        </trans-unit>
        <trans-unit id="3f6e1c408d5c694acb6e117eca1f17a66ff95359" translate="yes" xml:space="preserve">
          <source>The product of an empty array is the neutral element 1:</source>
          <target state="translated">Продуктом пустого массива является нейтральный элемент 1:</target>
        </trans-unit>
        <trans-unit id="75994948d8c7e15ea47031e7a198364fb67ad040" translate="yes" xml:space="preserve">
          <source>The project management structure can be found at our &lt;a href=&quot;dev/governance/index&quot;&gt;governance page&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0cb319efd0acc22671f035a1669648180fbd73bb" translate="yes" xml:space="preserve">
          <source>The promoted data type.</source>
          <target state="translated">Тип продвигаемых данных.</target>
        </trans-unit>
        <trans-unit id="6912cd62e766bc5197bb815c3a7a6d0beffe9f0f" translate="yes" xml:space="preserve">
          <source>The pseudo Vandermonde matrix. The shape of the returned matrix is &lt;code&gt;x.shape + (deg + 1,)&lt;/code&gt;, where The last index is the degree of the corresponding Chebyshev polynomial. The dtype will be the same as the converted &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="translated">Псевдо-матрица Вандермонда. Форма возвращаемой матрицы - &lt;code&gt;x.shape + (deg + 1,)&lt;/code&gt; , где последний индекс - это степень соответствующего многочлена Чебышева. Dtype будет таким же, как преобразованный &lt;code&gt;x&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4ae75dbae228045f6a44f16a4959415e52a060af" translate="yes" xml:space="preserve">
          <source>The pseudo-Vandermonde matrix. The shape of the returned matrix is &lt;code&gt;x.shape + (deg + 1,)&lt;/code&gt;, where The last index is the degree of the corresponding Hermite polynomial. The dtype will be the same as the converted &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="translated">Матрица псевдовандермонда. Форма возвращаемой матрицы - &lt;code&gt;x.shape + (deg + 1,)&lt;/code&gt; , где последний индекс - это степень соответствующего полинома Эрмита. Dtype будет таким же, как преобразованный &lt;code&gt;x&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="88145706d808f4e5b4b300c092c6d0b48707e827" translate="yes" xml:space="preserve">
          <source>The pseudo-Vandermonde matrix. The shape of the returned matrix is &lt;code&gt;x.shape + (deg + 1,)&lt;/code&gt;, where The last index is the degree of the corresponding HermiteE polynomial. The dtype will be the same as the converted &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="translated">Матрица псевдовандермонда. Форма возвращаемой матрицы - &lt;code&gt;x.shape + (deg + 1,)&lt;/code&gt; , где последний индекс - это степень соответствующего полинома HermiteE. Dtype будет таким же, как преобразованный &lt;code&gt;x&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="461d6f363a2da4bb21861bdd9199b9a080f1058c" translate="yes" xml:space="preserve">
          <source>The pseudo-Vandermonde matrix. The shape of the returned matrix is &lt;code&gt;x.shape + (deg + 1,)&lt;/code&gt;, where The last index is the degree of the corresponding Laguerre polynomial. The dtype will be the same as the converted &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="translated">Матрица псевдовандермонда. Форма возвращаемой матрицы - &lt;code&gt;x.shape + (deg + 1,)&lt;/code&gt; , где последний индекс - это степень соответствующего полинома Лагерра. Dtype будет таким же, как преобразованный &lt;code&gt;x&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a9fac4b82ab694bb7879684258269647508526ed" translate="yes" xml:space="preserve">
          <source>The pseudo-Vandermonde matrix. The shape of the returned matrix is &lt;code&gt;x.shape + (deg + 1,)&lt;/code&gt;, where The last index is the degree of the corresponding Legendre polynomial. The dtype will be the same as the converted &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="translated">Матрица псевдовандермонда. Форма возвращаемой матрицы - &lt;code&gt;x.shape + (deg + 1,)&lt;/code&gt; , где последний индекс - это степень соответствующего полинома Лежандра. Dtype будет таким же, как преобразованный &lt;code&gt;x&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="14e8343a4bfc8bf0e783456b4d87d1a38896cde9" translate="yes" xml:space="preserve">
          <source>The pseudo-inverse of &lt;code&gt;a&lt;/code&gt;. If &lt;code&gt;a&lt;/code&gt; is a &lt;code&gt;matrix&lt;/code&gt; instance, then so is &lt;code&gt;B&lt;/code&gt;.</source>
          <target state="translated">Псевдо-инверсия . Если &lt;code&gt;a&lt;/code&gt; - &lt;code&gt;matrix&lt;/code&gt; экземпляр, то &lt;code&gt;B&lt;/code&gt; тоже . &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="c9935b0bcef3c9f2790af77d395c4f7367a5b4f9" translate="yes" xml:space="preserve">
          <source>The pseudo-inverse of a matrix A, denoted</source>
          <target state="translated">Псевдо-инверс матрицы А,обозначающий</target>
        </trans-unit>
        <trans-unit id="43268b21480b8908d11ac78845b26e8a85b3d3ad" translate="yes" xml:space="preserve">
          <source>The purpose of the &lt;code&gt;F2PY&lt;/code&gt; &amp;ndash;&lt;em&gt;Fortran to Python interface generator&lt;/em&gt;&amp;ndash; is to provide a connection between Python and Fortran languages. F2PY is a part of &lt;a href=&quot;https://www.numpy.org/&quot;&gt;NumPy&lt;/a&gt; (&lt;code&gt;numpy.f2py&lt;/code&gt;) and also available as a standalone command line tool &lt;code&gt;f2py&lt;/code&gt; when &lt;code&gt;numpy&lt;/code&gt; is installed that facilitates creating/building Python C/API extension modules that make it possible</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="273d622b1bbcac1e58ca2d1b74d9ecdc471af9f8" translate="yes" xml:space="preserve">
          <source>The purpose of the reference count check is to make sure you do not use this array as a buffer for another Python object and then reallocate the memory. However, reference counts can increase in other ways so if you are sure that you have not shared the memory for this array with another Python object, then you may safely set &lt;code&gt;refcheck&lt;/code&gt; to False.</source>
          <target state="translated">Цель проверки счетчика ссылок - убедиться, что вы не используете этот массив в качестве буфера для другого объекта Python, а затем перераспределите память. Однако счетчик ссылок может увеличиваться и другими способами, поэтому, если вы уверены, что не разделили память для этого массива с другим объектом Python, вы можете безопасно установить &lt;code&gt;refcheck&lt;/code&gt; на False.</target>
        </trans-unit>
        <trans-unit id="cd4694d2cc663a00201267e4370ce5da08336131" translate="yes" xml:space="preserve">
          <source>The purpose of this document is to formalize the governance process used by the NumPy project in both ordinary and extraordinary situations, and to clarify how decisions are made and how the various elements of our community interact, including the relationship between open source collaborative development and work that may be funded by for-profit or non-profit entities.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fd1af1501c6ee7b4f0b0aa9bb7ca5e17785491ff" translate="yes" xml:space="preserve">
          <source>The quadrant (i.e., branch) is chosen so that &lt;code&gt;arctan2(x1, x2)&lt;/code&gt; is the signed angle in radians between the ray ending at the origin and passing through the point (1,0), and the ray ending at the origin and passing through the point (&lt;code&gt;x2&lt;/code&gt;, &lt;code&gt;x1&lt;/code&gt;). (Note the role reversal: the &amp;ldquo;&lt;code&gt;y&lt;/code&gt;-coordinate&amp;rdquo; is the first function parameter, the &amp;ldquo;&lt;code&gt;x&lt;/code&gt;-coordinate&amp;rdquo; is the second.) By IEEE convention, this function is defined for &lt;code&gt;x2&lt;/code&gt; = +/-0 and for either or both of &lt;code&gt;x1&lt;/code&gt; and &lt;code&gt;x2&lt;/code&gt; = +/-inf (see Notes for specific values).</source>
          <target state="translated">Квадрант (т. &lt;code&gt;arctan2(x1, x2)&lt;/code&gt; Ветвь) выбирается так, чтобы arctan2 (x1, x2) представлял собой знаковый угол в радианах между лучом, заканчивающимся в начале координат и проходящим через точку (1,0), и лучом, заканчивающимся в начале координат и проходящим через через точку ( &lt;code&gt;x2&lt;/code&gt; , &lt;code&gt;x1&lt;/code&gt; ). (Обратите внимание на смену ролей: &amp;laquo; координата &lt;code&gt;y&lt;/code&gt; &amp;raquo; - это первый параметр функции, &amp;laquo; координата &lt;code&gt;x&lt;/code&gt; &amp;raquo; - второй.) По соглашению IEEE эта функция определена для &lt;code&gt;x2&lt;/code&gt; = +/- 0 и для одного или обоих из &lt;code&gt;x1&lt;/code&gt; и &lt;code&gt;x2&lt;/code&gt; = +/- inf (конкретные значения см. в примечаниях).</target>
        </trans-unit>
        <trans-unit id="a6498ac12126ab973a1934f179594a987afb7844" translate="yes" xml:space="preserve">
          <source>The quick and smart way</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8b0770ff789fdc985036394e871929fde93eb9a9" translate="yes" xml:space="preserve">
          <source>The quick way</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d041efcac5d4fa984fd9e585c0e674ab20c24a98" translate="yes" xml:space="preserve">
          <source>The quickest way to wrap the Fortran subroutine &lt;code&gt;FIB&lt;/code&gt; to Python is to run</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ef42c4d34d6fe180bfd554c782fbff1345844332" translate="yes" xml:space="preserve">
          <source>The random numbers generated are reproducible in the sense that the same seed will produce the same outputs, given that the number of threads does not change.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d11423e3cc4bf0ed835c8b796b2965976e8e77d3" translate="yes" xml:space="preserve">
          <source>The random values are simulated using a rejection-based method and so, on average, more than one value from the underlying RNG is required to generate an single draw.</source>
          <target state="translated">Случайные значения моделируются методом отбраковки,поэтому в среднем для генерации одного жеребьевки требуется более одного значения из базового RNG.</target>
        </trans-unit>
        <trans-unit id="28da8ed4d2357ec2f5fb90d47c281e28c8eefc86" translate="yes" xml:space="preserve">
          <source>The random values produced by &lt;a href=&quot;../generator#numpy.random.Generator&quot;&gt;&lt;code&gt;Generator&lt;/code&gt;&lt;/a&gt; orignate in a BitGenerator. The BitGenerators do not directly provide random numbers and only contains methods used for seeding, getting or setting the state, jumping or advancing the state, and for accessing low-level wrappers for consumption by code that can efficiently access the functions provided, e.g., &lt;a href=&quot;https://numba.pydata.org&quot;&gt;numba&lt;/a&gt;.</source>
          <target state="translated">Случайные значения, создаваемые &lt;a href=&quot;../generator#numpy.random.Generator&quot;&gt; &lt;code&gt;Generator&lt;/code&gt; &lt;/a&gt; передаются в BitGenerator. BitGenerators не предоставляют напрямую случайные числа и содержат только методы, используемые для заполнения, получения или установки состояния, перехода или продвижения состояния, а также для доступа к низкоуровневым оболочкам для использования кодом, который может эффективно обращаться к предоставленным функциям, например, &lt;a href=&quot;https://numba.pydata.org&quot;&gt;numba&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="5ad47a80d273e6280e7c076840353be5436abdd4" translate="yes" xml:space="preserve">
          <source>The random variate of the F distribution (also known as the Fisher distribution) is a continuous probability distribution that arises in ANOVA tests, and is the ratio of two chi-square variates.</source>
          <target state="translated">Случайный вариант распределения F (также известный как распределение Фишера)является непрерывным распределением вероятности,которое возникает в тестах ANOVA,и представляет собой соотношение двух вариантов хи-квадрат.</target>
        </trans-unit>
        <trans-unit id="0add6113b9556467f5d4df18305b83fe87d90739" translate="yes" xml:space="preserve">
          <source>The rank of the coefficient matrix in the least-squares fit is deficient. The warning is only raised if &lt;a href=&quot;numpy.full#numpy.full&quot;&gt;&lt;code&gt;full&lt;/code&gt;&lt;/a&gt; = False.</source>
          <target state="translated">Ранг матрицы коэффициентов при аппроксимации методом наименьших квадратов недостаточен. Предупреждение появляется только в том случае, если &lt;a href=&quot;numpy.full#numpy.full&quot;&gt; &lt;code&gt;full&lt;/code&gt; &lt;/a&gt; = False.</target>
        </trans-unit>
        <trans-unit id="b6ce678d6ccc2a705d695d4a88057837caab615e" translate="yes" xml:space="preserve">
          <source>The rank of the coefficient matrix in the least-squares fit is deficient. The warning is only raised if &lt;code&gt;full&lt;/code&gt; = False.</source>
          <target state="translated">Ранг матрицы коэффициентов при аппроксимации методом наименьших квадратов недостаточен. Предупреждение появляется только в том случае, если &lt;code&gt;full&lt;/code&gt; = False.</target>
        </trans-unit>
        <trans-unit id="bd75ec6be6b0946c94eb5124dc2c270b7f45fc83" translate="yes" xml:space="preserve">
          <source>The rank of the coefficient matrix in the least-squares fit is deficient. The warning is only raised if &lt;code&gt;full&lt;/code&gt; = False. The warnings can be turned off by</source>
          <target state="translated">Ранг матрицы коэффициентов при аппроксимации методом наименьших квадратов недостаточен. Предупреждение появляется только в том случае, если &lt;code&gt;full&lt;/code&gt; = False. Предупреждения можно отключить с помощью</target>
        </trans-unit>
        <trans-unit id="2c0ff958aa13b6c22519b1f58af607e808b9fc81" translate="yes" xml:space="preserve">
          <source>The rate of interest is computed by iteratively solving the (non-linear) equation:</source>
          <target state="translated">Процентная ставка вычисляется путем итеративного решения (нелинейного)уравнения:</target>
        </trans-unit>
        <trans-unit id="b661d55a0a19500a077ffd4c961cfcdd8af11a0d" translate="yes" xml:space="preserve">
          <source>The real and imaginary parts of complex numbers are rounded separately. The result of rounding a float is a float.</source>
          <target state="translated">Реальная и мнимая части комплексных чисел округляются отдельно.Результатом округления поплавка является поплавок.</target>
        </trans-unit>
        <trans-unit id="207d8f1e0e497b598f007938a1132510a97a9210" translate="yes" xml:space="preserve">
          <source>The real component of the complex argument. If &lt;code&gt;val&lt;/code&gt; is real, the type of &lt;code&gt;val&lt;/code&gt; is used for the output. If &lt;code&gt;val&lt;/code&gt; has complex elements, the returned type is float.</source>
          <target state="translated">Настоящая составляющая сложного аргумента. Если &lt;code&gt;val&lt;/code&gt; является действительным, для вывода используется тип &lt;code&gt;val&lt;/code&gt; . Если &lt;code&gt;val&lt;/code&gt; имеет сложные элементы, возвращаемый тип - float.</target>
        </trans-unit>
        <trans-unit id="bcba5206897319bd4dfef5984f33a61e7bfd3a3e" translate="yes" xml:space="preserve">
          <source>The real part of the array.</source>
          <target state="translated">Настоящая часть массива.</target>
        </trans-unit>
        <trans-unit id="f76c20342380d19b36138a77680129546c04ac6d" translate="yes" xml:space="preserve">
          <source>The real part of the masked array.</source>
          <target state="translated">Реальная часть массива.</target>
        </trans-unit>
        <trans-unit id="f8c34f7042b404b994731920ea347bbd1e355fae" translate="yes" xml:space="preserve">
          <source>The recommended approach to multithreaded iteration is to first create an iterator with the flags &lt;a href=&quot;#c.NPY_ITER_EXTERNAL_LOOP&quot;&gt;&lt;code&gt;NPY_ITER_EXTERNAL_LOOP&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#c.NPY_ITER_RANGED&quot;&gt;&lt;code&gt;NPY_ITER_RANGED&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#c.NPY_ITER_BUFFERED&quot;&gt;&lt;code&gt;NPY_ITER_BUFFERED&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#c.NPY_ITER_DELAY_BUFALLOC&quot;&gt;&lt;code&gt;NPY_ITER_DELAY_BUFALLOC&lt;/code&gt;&lt;/a&gt;, and possibly &lt;a href=&quot;#c.NPY_ITER_GROWINNER&quot;&gt;&lt;code&gt;NPY_ITER_GROWINNER&lt;/code&gt;&lt;/a&gt;. Create a copy of this iterator for each thread (minus one for the first iterator). Then, take the iteration index range &lt;code&gt;[0, NpyIter_GetIterSize(iter))&lt;/code&gt; and split it up into tasks, for example using a TBB parallel_for loop. When a thread gets a task to execute, it then uses its copy of the iterator by calling &lt;a href=&quot;#c.NpyIter_ResetToIterIndexRange&quot;&gt;&lt;code&gt;NpyIter_ResetToIterIndexRange&lt;/code&gt;&lt;/a&gt; and iterating over the full range.</source>
          <target state="translated">Рекомендуемый подход к многопоточной итерации - сначала создать итератор с флагами &lt;a href=&quot;#c.NPY_ITER_EXTERNAL_LOOP&quot;&gt; &lt;code&gt;NPY_ITER_EXTERNAL_LOOP&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#c.NPY_ITER_RANGED&quot;&gt; &lt;code&gt;NPY_ITER_RANGED&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#c.NPY_ITER_BUFFERED&quot;&gt; &lt;code&gt;NPY_ITER_BUFFERED&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#c.NPY_ITER_DELAY_BUFALLOC&quot;&gt; &lt;code&gt;NPY_ITER_DELAY_BUFALLOC&lt;/code&gt; &lt;/a&gt; и, возможно, &lt;a href=&quot;#c.NPY_ITER_GROWINNER&quot;&gt; &lt;code&gt;NPY_ITER_GROWINNER&lt;/code&gt; &lt;/a&gt; . Создайте копию этого итератора для каждого потока (минус одна для первого итератора). Затем возьмите диапазон индекса итерации &lt;code&gt;[0, NpyIter_GetIterSize(iter))&lt;/code&gt; и разделите его на задачи, например, используя цикл TBB parallel_for. Когда поток получает задачу для выполнения, он затем использует свою копию итератора, вызывая &lt;a href=&quot;#c.NpyIter_ResetToIterIndexRange&quot;&gt; &lt;code&gt;NpyIter_ResetToIterIndexRange&lt;/code&gt; &lt;/a&gt; и перебирая весь диапазон.</target>
        </trans-unit>
        <trans-unit id="8ebf9173277c6dd7ef8e96321015ddb67f853d5b" translate="yes" xml:space="preserve">
          <source>The recommended generator for general use is &lt;a href=&quot;bit_generators/pcg64#numpy.random.PCG64&quot;&gt;&lt;code&gt;PCG64&lt;/code&gt;&lt;/a&gt;. It is statistically high quality, full-featured, and fast on most platforms, but somewhat slow when compiled for 32-bit processes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5447919d67b87c18366730a8d862cd10ecf68752" translate="yes" xml:space="preserve">
          <source>The recommended generator for general use is &lt;a href=&quot;bit_generators/pcg64#numpy.random.pcg64.PCG64&quot;&gt;&lt;code&gt;PCG64&lt;/code&gt;&lt;/a&gt;. It is statistically high quality, full-featured, and fast on most platforms, but somewhat slow when compiled for 32-bit processes.</source>
          <target state="translated">Рекомендуемый генератор для общего использования - &lt;a href=&quot;bit_generators/pcg64#numpy.random.pcg64.PCG64&quot;&gt; &lt;code&gt;PCG64&lt;/code&gt; &lt;/a&gt; . Это статистически высокое качество, полнофункциональность и скорость на большинстве платформ, но несколько медленная при компиляции для 32-разрядных процессов.</target>
        </trans-unit>
        <trans-unit id="1ecded761aa3b896fb25df737596c852ad7e09c5" translate="yes" xml:space="preserve">
          <source>The recommended practice for initializing &lt;code&gt;mask&lt;/code&gt; with a scalar boolean value is to use &lt;code&gt;True&lt;/code&gt;/&lt;code&gt;False&lt;/code&gt; rather than &lt;code&gt;np.True_&lt;/code&gt;/&lt;code&gt;np.False_&lt;/code&gt;. The reason is &lt;a href=&quot;../maskedarray.baseclass#numpy.ma.nomask&quot;&gt;&lt;code&gt;nomask&lt;/code&gt;&lt;/a&gt; is represented internally as &lt;code&gt;np.False_&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f1f83ab16efb108e21fd8dc9140501bac936f974" translate="yes" xml:space="preserve">
          <source>The recommended way to mark one or several specific entries of a masked array as invalid is to assign the special value &lt;a href=&quot;maskedarray.baseclass#numpy.ma.masked&quot;&gt;&lt;code&gt;masked&lt;/code&gt;&lt;/a&gt; to them:</source>
          <target state="translated">Рекомендуемый способ пометить одну или несколько конкретных записей замаскированного массива как недопустимые - присвоить им &lt;a href=&quot;maskedarray.baseclass#numpy.ma.masked&quot;&gt; &lt;code&gt;masked&lt;/code&gt; &lt;/a&gt; специальное значение :</target>
        </trans-unit>
        <trans-unit id="8e71a8b22e3d3f7dda123223a571d40b785e19ae" translate="yes" xml:space="preserve">
          <source>The recommended way to store and load data:</source>
          <target state="translated">Рекомендуемый способ хранения и загрузки данных:</target>
        </trans-unit>
        <trans-unit id="8911e36d75ead22da4c98276ac7d48a14f617b1b" translate="yes" xml:space="preserve">
          <source>The reduceat function is a generalization of both the reduce and accumulate functions. It implements a reduce over ranges of the input array specified by indices. The extra indices argument is checked to be sure that every input is not too large for the input array along the selected dimension before the loop calculations take place. The loop implementation is handled using code that is very similar to the reduce code repeated as many times as there are elements in the indices input. In particular: the first input pointer passed to the underlying 1-D computational loop points to the input array at the correct location indicated by the index array. In addition, the output pointer and the second input pointer passed to the underlying 1-D loop point to the same position in memory. The size of the 1-D computational loop is fixed to be the difference between the current index and the next index (when the current index is the last index, then the next index is assumed to be the length of the array along the selected dimension). In this way, the 1-D loop will implement a reduce over the specified indices.</source>
          <target state="translated">Функция редукции является обобщением функций редукции и накопления.Она реализует уменьшение по диапазонам входного массива,заданного индексами.Дополнительный аргумент индексов проверяется,чтобы убедиться,что каждый входной массив не слишком велик для входного массива по выбранному размеру до начала вычислений в цикле.Реализация цикла выполняется с помощью кода,который очень похож на код сокращения,повторяющийся столько раз,сколько имеется элементов на входе индексов.В частности:первый входной указатель,переданный на лежащий в основе 1-D цикла вычислений,указывает на входной массив в правильном месте,указанном массивом индексов.Кроме того,выходной указатель и второй входной указатель,переданные на лежащий в основе 1-D цикла вычислений,находятся в одной и той же позиции в памяти.Размер 1-D цикла вычислений фиксируется как разница между текущим индексом и следующим индексом (когда текущий индекс является последним индексом,то следующим индексом принимается длина массива вдоль выбранного измерения).Таким образом,в 1-D цикле будет реализовано уменьшение по указанным индексам.</target>
        </trans-unit>
        <trans-unit id="7b43a1a08f82a3b68e452cbd124797f3f5925ce7" translate="yes" xml:space="preserve">
          <source>The reduced array. If &lt;code&gt;out&lt;/code&gt; was supplied, &lt;code&gt;r&lt;/code&gt; is a reference to it.</source>
          <target state="translated">Уменьшенный массив. Если был поставлен &lt;code&gt;out&lt;/code&gt; , &lt;code&gt;r&lt;/code&gt; является ссылкой на него.</target>
        </trans-unit>
        <trans-unit id="d46d2581ba496f8d142f6a4f33e8d4c920183656" translate="yes" xml:space="preserve">
          <source>The reduced values. If &lt;code&gt;out&lt;/code&gt; was supplied, &lt;code&gt;r&lt;/code&gt; is a reference to &lt;code&gt;out&lt;/code&gt;.</source>
          <target state="translated">Приведенные значения. Если был предоставлен &lt;code&gt;out&lt;/code&gt; , &lt;code&gt;r&lt;/code&gt; является ссылкой на &lt;code&gt;out&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3281b17df16674bbe40c7e1efbe54eb9d464c9ee" translate="yes" xml:space="preserve">
          <source>The regular expression. Default value is None, in which case the nose default (&lt;code&gt;re.compile(r'(?:^|[\b_\.%s-])[Tt]est' % os.sep)&lt;/code&gt;) is used. If &lt;code&gt;testmatch&lt;/code&gt; is a string, it is compiled to a regular expression first.</source>
          <target state="translated">Регулярное выражение. Значение по умолчанию - Нет, и в этом случае используется значение носа по умолчанию ( &lt;code&gt;re.compile(r'(?:^|[\b_\.%s-])[Tt]est' % os.sep)&lt;/code&gt; ). Если &lt;code&gt;testmatch&lt;/code&gt; является строкой, она сначала компилируется в регулярное выражение.</target>
        </trans-unit>
        <trans-unit id="bd0a0dfb20db6ba5c33bc9ca8a9fe1a01f1841cf" translate="yes" xml:space="preserve">
          <source>The relative performance on 64-bit Linux and 64-bit Windows is broadly similar.</source>
          <target state="translated">Относительная производительность на 64-разрядном Linux и 64-разрядной Windows в целом схожа.</target>
        </trans-unit>
        <trans-unit id="7989f6ae8fcd58319573d40c534aa46fe0a84b96" translate="yes" xml:space="preserve">
          <source>The relative tolerance parameter (see Notes).</source>
          <target state="translated">Относительный параметр допуска (см.Примечания).</target>
        </trans-unit>
        <trans-unit id="3e03b7da726f71e414e37015d45ecfcbfb010c83" translate="yes" xml:space="preserve">
          <source>The release should be announced on the mailing lists of NumPy and SciPy, to python-announce, and possibly also those of Matplotlib, IPython and/or Pygame.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="96164d49d0f26476a5104ba2b3a4aa7deeeccb58" translate="yes" xml:space="preserve">
          <source>The release should be announced on the numpy-discussion, scipy-devel, scipy-user, and python-announce-list mailing lists. Look at previous announcements for the basic template. The contributor and PR lists are the same as generated for the release notes above. If you crosspost, make sure that python-announce-list is BCC so that replies will not be sent to that list.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="12f91fe84c2d74d72d982ce47fb9a64711667ccc" translate="yes" xml:space="preserve">
          <source>The release tag should have the release number in the annotation (tag message). Unfortunately, the name of a tag can be changed without breaking the signature, the contents of the message cannot.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dafb58a5db48e1dfe53af56fea252537c1419b45" translate="yes" xml:space="preserve">
          <source>The remainder of the division of &lt;code&gt;x1&lt;/code&gt; by &lt;code&gt;x2&lt;/code&gt;. This is a scalar if both &lt;code&gt;x1&lt;/code&gt; and &lt;code&gt;x2&lt;/code&gt; are scalars.</source>
          <target state="translated">Остаток от деления &lt;code&gt;x1&lt;/code&gt; на &lt;code&gt;x2&lt;/code&gt; . Это скаляр, если и &lt;code&gt;x1&lt;/code&gt; , и &lt;code&gt;x2&lt;/code&gt; являются скалярами.</target>
        </trans-unit>
        <trans-unit id="45876a6251302c94b60ea59421b48e6f10e76b32" translate="yes" xml:space="preserve">
          <source>The required alignment (bytes) of this data-type according to the compiler.</source>
          <target state="translated">Требуемое выравнивание (байты)этого типа данных в соответствии с компилятором.</target>
        </trans-unit>
        <trans-unit id="13ef7d8fa51bbebbe1bd1d3ed4d25fe31e0c8b11" translate="yes" xml:space="preserve">
          <source>The required data type(s) of the operands. If copying or buffering is enabled, the data will be converted to/from their original types.</source>
          <target state="translated">Требуемые типы данных операндов.Если включено копирование или буферизация,то данные будут преобразовываться в/из исходных типов.</target>
        </trans-unit>
        <trans-unit id="0a7d78831f72627736ecbbe6affd07acc842cf9c" translate="yes" xml:space="preserve">
          <source>The required data-type. If None preserve the current dtype. If your application requires the data to be in native byteorder, include a byteorder specification as a part of the dtype specification.</source>
          <target state="translated">Необходимый тип данных.Если Никто не сохранит текущий тип d.Если ваше приложение требует,чтобы данные были в родном байт-ордере,включите спецификацию байт-ордера как часть спецификации типа d.</target>
        </trans-unit>
        <trans-unit id="65e5c657147f8f6206b51f162cff2b0b35eade26" translate="yes" xml:space="preserve">
          <source>The requirements flag allows specification of what kind of array is acceptable. If the object passed in does not satisfy this requirements then a copy is made so that thre returned object will satisfy the requirements. these ndarray can use a very generic pointer to memory. This flag allows specification of the desired properties of the returned array object. All of the flags are explained in the detailed API chapter. The flags most commonly needed are &lt;a href=&quot;../reference/c-api/array#c.NPY_ARRAY_IN_ARRAY&quot;&gt;&lt;code&gt;NPY_ARRAY_IN_ARRAY&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../reference/c-api/array#c.NPY_OUT_ARRAY&quot;&gt;&lt;code&gt;NPY_OUT_ARRAY&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;../reference/c-api/array#c.NPY_ARRAY_INOUT_ARRAY&quot;&gt;&lt;code&gt;NPY_ARRAY_INOUT_ARRAY&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bb180b40fee6aef0d41f93f405142f00de46dd28" translate="yes" xml:space="preserve">
          <source>The requirements list can be any of the following</source>
          <target state="translated">Перечень требований может быть любым из следующих</target>
        </trans-unit>
        <trans-unit id="bf0f3cb688cf9b5f44c6080748b72439b46fb978" translate="yes" xml:space="preserve">
          <source>The reshaping operation cannot guarantee that a copy will not be made, to modify the shape in place, use &lt;code&gt;a.shape = s&lt;/code&gt;</source>
          <target state="translated">Операция изменения формы не может гарантировать, что копия не будет сделана, чтобы изменить форму на месте, используйте &lt;code&gt;a.shape = s&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="f3c22a2794d4be1171f3bb3051bbeb72ad7588dd" translate="yes" xml:space="preserve">
          <source>The rest of the story</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2b262525b3075625bc8ca490c385d67e383e0b64" translate="yes" xml:space="preserve">
          <source>The rest of this document discusses working on the NumPy code base and documentation. We&amp;rsquo;re in the process of updating our descriptions of other activities and roles. If you are interested in these other activities, please contact us! You can do this via the &lt;a href=&quot;https://mail.python.org/mailman/listinfo/numpy-discussion&quot;&gt;numpy-discussion mailing list&lt;/a&gt;, or on &lt;a href=&quot;https://github.com/numpy/numpy&quot;&gt;GitHub&lt;/a&gt; (open an issue or comment on a relevant issue). These are our preferred communication channels (open source is open by nature!), however if you prefer to discuss in private first, please reach out to our community coordinators at &lt;code&gt;numpy-team@googlegroups.com&lt;/code&gt; or &lt;code&gt;numpy-team.slack.com&lt;/code&gt; (send an email to &lt;code&gt;numpy-team@googlegroups.com&lt;/code&gt; for an invite the first time).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="efae226cd4ce4ec97472c40d085c0b19d6b0deb7" translate="yes" xml:space="preserve">
          <source>The rest of this page will give you a basic idea of how to add unit tests to modules in SciPy. It is extremely important for us to have extensive unit testing since this code is going to be used by scientists and researchers and is being developed by a large number of people spread across the world. So, if you are writing a package that you&amp;rsquo;d like to become part of SciPy, please write the tests as you develop the package. Also since much of SciPy is legacy code that was originally written without unit tests, there are still several modules that don&amp;rsquo;t have tests yet. Please feel free to choose one of these modules and develop tests for it as you read through this introduction.</source>
          <target state="translated">Остальная часть этой страницы даст вам общее представление о том, как добавлять модульные тесты в модули в SciPy. Для нас чрезвычайно важно проводить обширное модульное тестирование, поскольку этот код будет использоваться учеными и исследователями и разрабатывается большим количеством людей по всему миру. Итак, если вы пишете пакет, который хотели бы стать частью SciPy, напишите тесты по мере разработки пакета. Кроме того, поскольку большая часть SciPy представляет собой унаследованный код, который изначально был написан без модульных тестов, есть еще несколько модулей, для которых еще нет тестов. Пожалуйста, не стесняйтесь выбирать один из этих модулей и разрабатывать для него тесты, читая это введение.</target>
        </trans-unit>
        <trans-unit id="90738a573063433b40a2bef8dfa08dda95ee95c6" translate="yes" xml:space="preserve">
          <source>The result can be used to construct a datetime that uses the same units as a timedelta</source>
          <target state="translated">Результат может быть использован для построения даты,использующей те же единицы времени,что и таймеделта.</target>
        </trans-unit>
        <trans-unit id="8baf21a4c319c73c6c3f91016a95ecc1ae5e1dca" translate="yes" xml:space="preserve">
          <source>The result depends on the bit-width:</source>
          <target state="translated">Результат зависит от ширины бита:</target>
        </trans-unit>
        <trans-unit id="7a004033c9a8a28e785dfe7afb00d43720c2d90c" translate="yes" xml:space="preserve">
          <source>The result is &lt;strong&gt;not&lt;/strong&gt; a MaskedArray!</source>
          <target state="translated">Результат - это &lt;strong&gt;не&lt;/strong&gt; MaskedArray!</target>
        </trans-unit>
        <trans-unit id="88b2f160b598518e6df066363213cebfd6339e40" translate="yes" xml:space="preserve">
          <source>The result is an inverse for &lt;code&gt;a&lt;/code&gt; relative to the tensordot operation &lt;code&gt;tensordot(a, b, ind)&lt;/code&gt;, i. e., up to floating-point accuracy, &lt;code&gt;tensordot(tensorinv(a), a, ind)&lt;/code&gt; is the &amp;ldquo;identity&amp;rdquo; tensor for the tensordot operation.</source>
          <target state="translated">Результатом является обратным для &lt;code&gt;a&lt;/code&gt; по отношению к операции tensordot &lt;code&gt;tensordot(a, b, ind)&lt;/code&gt; , то есть, вплоть до плавающей точкой точности, &lt;code&gt;tensordot(tensorinv(a), a, ind)&lt;/code&gt; является &amp;laquo;идентичность&amp;raquo; тензор для tensordot операция.</target>
        </trans-unit>
        <trans-unit id="1513bc4b365343f54e37e3a0463aec42e49631e5" translate="yes" xml:space="preserve">
          <source>The result is equivalent to the previous example where &lt;code&gt;b&lt;/code&gt; was an array. We can think of the scalar &lt;code&gt;b&lt;/code&gt; being &lt;em&gt;stretched&lt;/em&gt; during the arithmetic operation into an array with the same shape as &lt;code&gt;a&lt;/code&gt;. The new elements in &lt;code&gt;b&lt;/code&gt; are simply copies of the original scalar. The stretching analogy is only conceptual. NumPy is smart enough to use the original scalar value without actually making copies so that broadcasting operations are as memory and computationally efficient as possible.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b234fdc2574c2d15c385cc66cebde459f6f8d571" translate="yes" xml:space="preserve">
          <source>The result is equivalent to the previous example where &lt;code&gt;b&lt;/code&gt; was an array. We can think of the scalar &lt;code&gt;b&lt;/code&gt; being stretched during the arithmetic operation into an array with the same shape as &lt;code&gt;a&lt;/code&gt;. The new elements in &lt;code&gt;b&lt;/code&gt;, as shown in &lt;a href=&quot;#figure-1&quot;&gt;Figure 1&lt;/a&gt;, are simply copies of the original scalar. The stretching analogy is only conceptual. numpy is smart enough to use the original scalar value without actually making copies so that broadcasting operations are as memory and computationally efficient as possible. Because &lt;a href=&quot;#example-2&quot;&gt;Example 2&lt;/a&gt; moves less memory, (&lt;code&gt;b&lt;/code&gt; is a scalar, not an array) around during the multiplication, it is about 10% faster than &lt;a href=&quot;#example-1&quot;&gt;Example 1&lt;/a&gt; using the standard numpy on Windows 2000 with one million element arrays.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d98fd654993b2c5bc8c34d84506f2eeb585bf55f" translate="yes" xml:space="preserve">
          <source>The result is padded to full bytes by inserting zero bits at the end.</source>
          <target state="translated">Результат подставляется в полные байты путем вставки нулевых битов в конце.</target>
        </trans-unit>
        <trans-unit id="a05d82855a760b96ff01a98014b6f39cd92699f0" translate="yes" xml:space="preserve">
          <source>The result is returned as a boolean array.</source>
          <target state="translated">Результат возвращается в виде булевого массива.</target>
        </trans-unit>
        <trans-unit id="f9d8170d98950c22e6026933d7548298a3e52f98" translate="yes" xml:space="preserve">
          <source>The result is:</source>
          <target state="translated">В результате:</target>
        </trans-unit>
        <trans-unit id="f485f36eec65ddcecdc4119f77e3da3d4540a73e" translate="yes" xml:space="preserve">
          <source>The result masks values that are masked in either &lt;code&gt;m1&lt;/code&gt; or &lt;code&gt;m2&lt;/code&gt;.</source>
          <target state="translated">Результат маскирует значения, замаскированные в &lt;code&gt;m1&lt;/code&gt; или &lt;code&gt;m2&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="93fabead91587e60c1a08bfee6b05728d77a4b94" translate="yes" xml:space="preserve">
          <source>The result may be a view on &lt;code&gt;m1&lt;/code&gt; or &lt;code&gt;m2&lt;/code&gt; if the other is &lt;a href=&quot;../maskedarray.baseclass#numpy.ma.nomask&quot;&gt;&lt;code&gt;nomask&lt;/code&gt;&lt;/a&gt; (i.e. False).</source>
          <target state="translated">Результатом может быть просмотр &lt;code&gt;m1&lt;/code&gt; или &lt;code&gt;m2&lt;/code&gt; , если другой - &lt;a href=&quot;../maskedarray.baseclass#numpy.ma.nomask&quot;&gt; &lt;code&gt;nomask&lt;/code&gt; &lt;/a&gt; (т.е. False).</target>
        </trans-unit>
        <trans-unit id="12ea562d907c93ffb2a2a48a2ff38a17f82a53ed" translate="yes" xml:space="preserve">
          <source>The result of &lt;code&gt;cPickle.loads(strg)&lt;/code&gt; is returned.</source>
          <target state="translated">&lt;code&gt;cPickle.loads(strg)&lt;/code&gt; результат cPickle.loads (strg) .</target>
        </trans-unit>
        <trans-unit id="437933320e33dbd911c7ecb653e24b023c9820e4" translate="yes" xml:space="preserve">
          <source>The result of &lt;code&gt;x1 * 2**x2&lt;/code&gt;. This is a scalar if both &lt;code&gt;x1&lt;/code&gt; and &lt;code&gt;x2&lt;/code&gt; are scalars.</source>
          <target state="translated">Результат &lt;code&gt;x1 * 2**x2&lt;/code&gt; . Это скаляр, если и &lt;code&gt;x1&lt;/code&gt; , и &lt;code&gt;x2&lt;/code&gt; являются скалярами.</target>
        </trans-unit>
        <trans-unit id="d200549129cf50987e2e3db04a3ddae4d86fd86e" translate="yes" xml:space="preserve">
          <source>The result of binning the input array. The length of &lt;code&gt;out&lt;/code&gt; is equal to &lt;code&gt;np.amax(x)+1&lt;/code&gt;.</source>
          <target state="translated">Результат объединения входного массива. Длина &lt;code&gt;out&lt;/code&gt; равна &lt;code&gt;np.amax(x)+1&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c6126cff082b1038f45f0cf4b879a12e8909f651" translate="yes" xml:space="preserve">
          <source>The result of indexing with a multi-field index is a view into the original array, as follows:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b74fd032efc344495e89da82ba5cefb838c783f0" translate="yes" xml:space="preserve">
          <source>The result of masking &lt;code&gt;a&lt;/code&gt; where &lt;code&gt;condition&lt;/code&gt; is True.</source>
          <target state="translated">Результат маскирования &lt;code&gt;a&lt;/code&gt; , где &lt;code&gt;condition&lt;/code&gt; истинно.</target>
        </trans-unit>
        <trans-unit id="2f9d4558b4365ff73c9c67d9671ab31c28b67b0f" translate="yes" xml:space="preserve">
          <source>The result of masking &lt;code&gt;x&lt;/code&gt; where approximately equal to &lt;code&gt;value&lt;/code&gt;.</source>
          <target state="translated">Результат маскирования &lt;code&gt;x&lt;/code&gt; примерно равен &lt;code&gt;value&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7c8d1e813923a2b2b410b1cadd9d90a6a3b27803" translate="yes" xml:space="preserve">
          <source>The result of masking &lt;code&gt;x&lt;/code&gt; where equal to &lt;code&gt;value&lt;/code&gt;.</source>
          <target state="translated">Результат маскирования &lt;code&gt;x&lt;/code&gt; , равный &lt;code&gt;value&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="20b27291ef8731ea508bbd0cd5e12a0ad3afd15b" translate="yes" xml:space="preserve">
          <source>The result of repeating &lt;code&gt;a&lt;/code&gt;.</source>
          <target state="translated">Результат повторения &lt;code&gt;a&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="080be4f2b719d17ca857f6ff65fc2c9ddc4f8015" translate="yes" xml:space="preserve">
          <source>The result of the call to &lt;code&gt;function&lt;/code&gt; is passed back directly. Therefore the shape of &lt;a href=&quot;#numpy.fromfunction&quot;&gt;&lt;code&gt;fromfunction&lt;/code&gt;&lt;/a&gt; is completely determined by &lt;code&gt;function&lt;/code&gt;. If &lt;code&gt;function&lt;/code&gt; returns a scalar value, the shape of &lt;a href=&quot;#numpy.fromfunction&quot;&gt;&lt;code&gt;fromfunction&lt;/code&gt;&lt;/a&gt; would not match the &lt;a href=&quot;numpy.shape#numpy.shape&quot;&gt;&lt;code&gt;shape&lt;/code&gt;&lt;/a&gt; parameter.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5a3504d8e95aae2a9b20b749f6d2c5a3889c5102" translate="yes" xml:space="preserve">
          <source>The result of the call to &lt;code&gt;function&lt;/code&gt; is passed back directly. Therefore the shape of &lt;a href=&quot;#numpy.fromfunction&quot;&gt;&lt;code&gt;fromfunction&lt;/code&gt;&lt;/a&gt; is completely determined by &lt;code&gt;function&lt;/code&gt;. If &lt;code&gt;function&lt;/code&gt; returns a scalar value, the shape of &lt;a href=&quot;#numpy.fromfunction&quot;&gt;&lt;code&gt;fromfunction&lt;/code&gt;&lt;/a&gt; would not match the &lt;code&gt;shape&lt;/code&gt; parameter.</source>
          <target state="translated">Результат вызова &lt;code&gt;function&lt;/code&gt; передается напрямую. Следовательно, форма &lt;a href=&quot;#numpy.fromfunction&quot;&gt; &lt;code&gt;fromfunction&lt;/code&gt; &lt;/a&gt; полностью определяется &lt;code&gt;function&lt;/code&gt; . Если &lt;code&gt;function&lt;/code&gt; возвращает скалярное значение, форма &lt;a href=&quot;#numpy.fromfunction&quot;&gt; &lt;code&gt;fromfunction&lt;/code&gt; &lt;/a&gt; не будет соответствовать параметру &lt;code&gt;shape&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="02a8e58b3d72e0b52f3592cd0fcb4ec46672a2f6" translate="yes" xml:space="preserve">
          <source>The result of the call to &lt;code&gt;function&lt;/code&gt; is passed back directly. Therefore the shape of &lt;a href=&quot;#numpy.ma.fromfunction&quot;&gt;&lt;code&gt;fromfunction&lt;/code&gt;&lt;/a&gt; is completely determined by &lt;code&gt;function&lt;/code&gt;. If &lt;code&gt;function&lt;/code&gt; returns a scalar value, the shape of &lt;a href=&quot;#numpy.ma.fromfunction&quot;&gt;&lt;code&gt;fromfunction&lt;/code&gt;&lt;/a&gt; would not match the &lt;a href=&quot;numpy.ma.shape#numpy.ma.shape&quot;&gt;&lt;code&gt;shape&lt;/code&gt;&lt;/a&gt; parameter.</source>
          <target state="translated">Результат вызова &lt;code&gt;function&lt;/code&gt; передается напрямую. Следовательно, форма &lt;a href=&quot;#numpy.ma.fromfunction&quot;&gt; &lt;code&gt;fromfunction&lt;/code&gt; &lt;/a&gt; полностью определяется &lt;code&gt;function&lt;/code&gt; . Если &lt;code&gt;function&lt;/code&gt; возвращает скалярное значение, форма &lt;a href=&quot;#numpy.ma.fromfunction&quot;&gt; &lt;code&gt;fromfunction&lt;/code&gt; &lt;/a&gt; не будет соответствовать параметру &lt;a href=&quot;numpy.ma.shape#numpy.ma.shape&quot;&gt; &lt;code&gt;shape&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="be63aee25a235ea7ecaebcc7084bf9b89e5f1ba3" translate="yes" xml:space="preserve">
          <source>The result of the inverse real 2-D FFT.</source>
          <target state="translated">Результат обратного реального 2-D БПФ.</target>
        </trans-unit>
        <trans-unit id="0a8c1e8c657004ada13d1bd67fea4f58af8cdb70" translate="yes" xml:space="preserve">
          <source>The result of the modulo operation for negative dividend and divisors is bound by conventions. For &lt;a href=&quot;#numpy.fmod&quot;&gt;&lt;code&gt;fmod&lt;/code&gt;&lt;/a&gt;, the sign of result is the sign of the dividend, while for &lt;a href=&quot;numpy.remainder#numpy.remainder&quot;&gt;&lt;code&gt;remainder&lt;/code&gt;&lt;/a&gt; the sign of the result is the sign of the divisor. The &lt;a href=&quot;#numpy.fmod&quot;&gt;&lt;code&gt;fmod&lt;/code&gt;&lt;/a&gt; function is equivalent to the Matlab(TM) &lt;code&gt;rem&lt;/code&gt; function.</source>
          <target state="translated">Результат операции по модулю для отрицательных дивидендов и делителей ограничен соглашениями. Для &lt;a href=&quot;#numpy.fmod&quot;&gt; &lt;code&gt;fmod&lt;/code&gt; &lt;/a&gt; знак результата - это знак делимого, а для &lt;a href=&quot;numpy.remainder#numpy.remainder&quot;&gt; &lt;code&gt;remainder&lt;/code&gt; &lt;/a&gt; знак результата - знак делителя. Функция &lt;a href=&quot;#numpy.fmod&quot;&gt; &lt;code&gt;fmod&lt;/code&gt; &lt;/a&gt; эквивалентна функции &lt;code&gt;rem&lt;/code&gt; в Matlab (TM) .</target>
        </trans-unit>
        <trans-unit id="432755e899e9d369003d6c1f79ef56f8c75f0660" translate="yes" xml:space="preserve">
          <source>The result of the real 2-D FFT.</source>
          <target state="translated">Результат реального 2-D БПФ.</target>
        </trans-unit>
        <trans-unit id="a62988dd4c556a700006b20bcac64bfa1f21b000" translate="yes" xml:space="preserve">
          <source>The result of this is always a 2d array, with a row for each non-zero element.</source>
          <target state="translated">Результатом этого всегда является 2d массив,со строкой для каждого ненулевого элемента.</target>
        </trans-unit>
        <trans-unit id="552e732df1a7e97a3ac3793f40b01156b930c9d2" translate="yes" xml:space="preserve">
          <source>The result of trimming the input. The input data type is preserved.</source>
          <target state="translated">Результат обрезки входного сигнала.Тип входных данных сохраняется.</target>
        </trans-unit>
        <trans-unit id="0ff6806d85e8fabd807a03dd151b7e1cdd284df8" translate="yes" xml:space="preserve">
          <source>The result type.</source>
          <target state="translated">Тип результата.</target>
        </trans-unit>
        <trans-unit id="101ce3a3f58e25741f8924a6b8d0cfd25472eeff" translate="yes" xml:space="preserve">
          <source>The result will be multidimensional if y has more dimensions than b. For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e2a369eb25dfa6d23e15865ad12a81c98b2538db" translate="yes" xml:space="preserve">
          <source>The result.</source>
          <target state="translated">Результат.</target>
        </trans-unit>
        <trans-unit id="d1fb43fabbedcad07c574b0e98cbace4463e697f" translate="yes" xml:space="preserve">
          <source>The resulting approximation of</source>
          <target state="translated">Полученное приближение</target>
        </trans-unit>
        <trans-unit id="8f5a6724cd845387db9fbc4a8e08fe47ae3e4ec1" translate="yes" xml:space="preserve">
          <source>The resulting array is a view into the original array. It shares the same memory locations and writing to the view will modify the original array.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a4450860735a4299b5638f4df95ccd877c9615a2" translate="yes" xml:space="preserve">
          <source>The resulting array therefore has a value &lt;code&gt;fn(x, y, z)&lt;/code&gt; at coordinate &lt;code&gt;(x, y, z)&lt;/code&gt;.</source>
          <target state="translated">Таким образом, результирующий массив имеет значение &lt;code&gt;fn(x, y, z)&lt;/code&gt; в координате &lt;code&gt;(x, y, z)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8e45fa029de06ce207816940e254f28318e174ec" translate="yes" xml:space="preserve">
          <source>The resulting path indicates which terms of the input contraction should be contracted first, the result of this contraction is then appended to the end of the contraction list. This list can then be iterated over until all intermediate contractions are complete.</source>
          <target state="translated">Результирующий путь указывает,какие условия входного сужения должны быть сначала схвачены,затем результат этого сужения добавляется в конец списка сужений.Затем этот список можно итерировать до тех пор,пока все промежуточные схватки не будут завершены.</target>
        </trans-unit>
        <trans-unit id="b0397bb7d27e88275099d7a9e2663ecd158fec65" translate="yes" xml:space="preserve">
          <source>The resulting signature for the function add.zadd is exactly the same one that was created previously. If the original source code had contained &lt;code&gt;A(N)&lt;/code&gt; instead of &lt;code&gt;A(*)&lt;/code&gt; and so forth with &lt;code&gt;B&lt;/code&gt; and &lt;code&gt;C&lt;/code&gt;, then I could obtain (nearly) the same interface simply by placing the &lt;code&gt;INTENT(OUT) :: C&lt;/code&gt; comment line in the source code. The only difference is that &lt;code&gt;N&lt;/code&gt; would be an optional input that would default to the length of &lt;code&gt;A&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4e44a556cdbd9e08c1c73c688efe96d93b4a9c2d" translate="yes" xml:space="preserve">
          <source>The results have only been tested up to degree 100 higher degrees may be problematic. The weights are determined by using the fact that</source>
          <target state="translated">Результаты были протестированы только до степени 100 более высоких градусов может быть проблематичным.Весовые коэффициенты определяются с использованием того факта,что</target>
        </trans-unit>
        <trans-unit id="ef4a7d2bf5791e871493bd9bc1998dc73f56d092" translate="yes" xml:space="preserve">
          <source>The results have only been tested up to degree 100, higher degrees may be problematic. For Gauss-Chebyshev there are closed form solutions for the sample points and weights. If n = &lt;code&gt;deg&lt;/code&gt;, then</source>
          <target state="translated">Результаты были проверены только до степени 100, более высокие степени могут быть проблематичными. Для Гаусса-Чебышева существуют решения в замкнутой форме для точек выборки и весов. Если n = &lt;code&gt;deg&lt;/code&gt; , то</target>
        </trans-unit>
        <trans-unit id="7a2a5f718e6f28fd9a2d71c1fb3ee2ee9fe5b2fb" translate="yes" xml:space="preserve">
          <source>The results have only been tested up to degree 100, higher degrees may be problematic. The weights are determined by using the fact that</source>
          <target state="translated">Результаты были протестированы только до степени 100,более высокие степени могут быть проблематичными.Весы определяются с использованием того факта,что</target>
        </trans-unit>
        <trans-unit id="af6fbd4d24683930cbf1a134289a3df4c1b144c3" translate="yes" xml:space="preserve">
          <source>The results will be placed in this array. It may be the input array for in-place clipping. &lt;code&gt;out&lt;/code&gt; must be of the right shape to hold the output. Its type is preserved.</source>
          <target state="translated">Результаты будут помещены в этот массив. Это может быть входной массив для отсечения по месту. &lt;code&gt;out&lt;/code&gt; должен иметь правильную форму, чтобы удерживать вывод. Его тип сохранен.</target>
        </trans-unit>
        <trans-unit id="c6b62851dacdc54d8864ac2edf1604fc62b66dd6" translate="yes" xml:space="preserve">
          <source>The return statement should &lt;em&gt;not&lt;/em&gt; get redundant parentheses:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9002868afc12284eedaa4f924eaaabb6a7944154" translate="yes" xml:space="preserve">
          <source>The return type will always be an inexact (i.e. floating point) scalar type, even if all the arrays are integer arrays. If one of the inputs is an integer array, the minimum precision type that is returned is a 64-bit floating point dtype.</source>
          <target state="translated">Возвращаемый тип всегда будет неточным (т.е.с плавающей точкой)скалярным типом,даже если все массивы являются целочисленными массивами.Если один из входов является целочисленным массивом,то минимальным точным типом,который возвращается,будет 64-битный тип d с плавающей точкой.</target>
        </trans-unit>
        <trans-unit id="273dde020fc2e47183998cc14b3fb20e4a9436a7" translate="yes" xml:space="preserve">
          <source>The return value is 0 on success, -1 on failure.</source>
          <target state="translated">Возвращаемое значение-0 на успех,-1 на неудачу.</target>
        </trans-unit>
        <trans-unit id="95baf9f3feb186151992e17419a9d52bee50a218" translate="yes" xml:space="preserve">
          <source>The return value is the same shape and type as &lt;code&gt;M&lt;/code&gt;; if the exponent is positive or zero then the type of the elements is the same as those of &lt;code&gt;M&lt;/code&gt;. If the exponent is negative the elements are floating-point.</source>
          <target state="translated">Возвращаемое значение имеет ту же форму и тип, что и &lt;code&gt;M&lt;/code&gt; ; если показатель положительно или равно нулю , то тип элементов такое же , как и у &lt;code&gt;M&lt;/code&gt; . Если показатель степени отрицательный, элементы с плавающей точкой.</target>
        </trans-unit>
        <trans-unit id="55801c938cbd16156c4c8c48d17f11e40e4107d9" translate="yes" xml:space="preserve">
          <source>The return value of failed converter functions which are called using the &amp;ldquo;O&amp;amp;&amp;rdquo; syntax in &lt;a href=&quot;https://docs.python.org/dev/c-api/arg.html#c.PyArg_ParseTuple&quot;&gt;&lt;code&gt;PyArg_ParseTuple&lt;/code&gt;&lt;/a&gt;-like functions.</source>
          <target state="translated">Возвращаемое значение неудачных функций конвертера, которые вызываются с использованием синтаксиса &amp;laquo;O &amp;amp;&amp;raquo; в &lt;a href=&quot;https://docs.python.org/dev/c-api/arg.html#c.PyArg_ParseTuple&quot;&gt; &lt;code&gt;PyArg_ParseTuple&lt;/code&gt; &lt;/a&gt; подобных PyArg_ParseTuple .</target>
        </trans-unit>
        <trans-unit id="41e4fb8b6c4e49bb724d556b26ed34481cfcd6dd" translate="yes" xml:space="preserve">
          <source>The return value of successful converter functions which are called using the &amp;ldquo;O&amp;amp;&amp;rdquo; syntax in &lt;a href=&quot;https://docs.python.org/dev/c-api/arg.html#c.PyArg_ParseTuple&quot;&gt;&lt;code&gt;PyArg_ParseTuple&lt;/code&gt;&lt;/a&gt;-like functions.</source>
          <target state="translated">Возвращаемое значение успешных функций преобразователя, которые вызываются с использованием синтаксиса &amp;laquo;O &amp;amp;&amp;raquo; в &lt;a href=&quot;https://docs.python.org/dev/c-api/arg.html#c.PyArg_ParseTuple&quot;&gt; &lt;code&gt;PyArg_ParseTuple&lt;/code&gt; &lt;/a&gt; подобных PyArg_ParseTuple .</target>
        </trans-unit>
        <trans-unit id="c05aab266b5f8aae47c5e7319a883da33ec4e284" translate="yes" xml:space="preserve">
          <source>The return value, False if &lt;code&gt;x&lt;/code&gt; is of a complex type.</source>
          <target state="translated">Возвращаемое значение False, если &lt;code&gt;x&lt;/code&gt; имеет сложный тип.</target>
        </trans-unit>
        <trans-unit id="c002d9b8869cd4388cf5943fa7426632d76c13b5" translate="yes" xml:space="preserve">
          <source>The return value, True if &lt;code&gt;x&lt;/code&gt; is of a complex type or has at least one complex element.</source>
          <target state="translated">Возвращаемое значение True, если &lt;code&gt;x&lt;/code&gt; имеет сложный тип или имеет хотя бы один сложный элемент.</target>
        </trans-unit>
        <trans-unit id="8cacfcdc238ffe8ba32e3f60b54d5d84f6258480" translate="yes" xml:space="preserve">
          <source>The returned array has the same type as &lt;code&gt;a&lt;/code&gt;.</source>
          <target state="translated">Возвращаемый массив имеет тот же тип, что &lt;code&gt;a&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8984b85b3f1b178d24103374b554ddde5426110f" translate="yes" xml:space="preserve">
          <source>The returned array is always 1D.</source>
          <target state="translated">Возвращаемый массив всегда 1D.</target>
        </trans-unit>
        <trans-unit id="59afb62c6311159c3a4c4a5a09d0fcb3d683db81" translate="yes" xml:space="preserve">
          <source>The returned array is always a structured array, and is constructed from all matches of the regular expression in the file. Groups in the regular expression are converted to fields of the structured array.</source>
          <target state="translated">Возвращаемый массив всегда является структурированным массивом и строится из всех совпадений регулярного выражения в файле.Группы в регулярном выражении преобразуются в поля структурного массива.</target>
        </trans-unit>
        <trans-unit id="235ae9f13128943772ff554e126bc69621884d0e" translate="yes" xml:space="preserve">
          <source>The returned array will be guaranteed to have the listed requirements by making a copy if needed.</source>
          <target state="translated">Возвращаемый массив будет гарантированно иметь перечисленные требования,при необходимости сделав копию.</target>
        </trans-unit>
        <trans-unit id="4d7c736b03b1eeb7cc2b9172d888763588690bd3" translate="yes" xml:space="preserve">
          <source>The returned array will have at least &lt;code&gt;ndmin&lt;/code&gt; dimensions. Otherwise mono-dimensional axes will be squeezed. Legal values: 0 (default), 1 or 2.</source>
          <target state="translated">Возвращаемый массив будет иметь размер не менее &lt;code&gt;ndmin&lt;/code&gt; . В противном случае одномерные оси будут сжаты. Допустимые значения: 0 (по умолчанию), 1 или 2.</target>
        </trans-unit>
        <trans-unit id="0991fc7713b9227f260fa7eb1775e9a559dcb08f" translate="yes" xml:space="preserve">
          <source>The returned class can be of different type than the current instance and/or have a different domain and/or different window.</source>
          <target state="translated">Возвращаемый класс может быть другого типа,чем текущий экземпляр и/или иметь другой домен и/или другое окно.</target>
        </trans-unit>
        <trans-unit id="f40fdf0f51a86b8b90c8d1563cabe3126d1130f1" translate="yes" xml:space="preserve">
          <source>The returned float array &lt;code&gt;f&lt;/code&gt; contains the frequency bin centers in cycles per unit of the sample spacing (with zero at the start). For instance, if the sample spacing is in seconds, then the frequency unit is cycles/second.</source>
          <target state="translated">Возвращенный массив с плавающей запятой &lt;code&gt;f&lt;/code&gt; содержит центры частотных бинов в циклах на единицу шага выборки (с нулем в начале). Например, если интервал между выборками задается в секундах, то единицей измерения частоты является цикл / секунда.</target>
        </trans-unit>
        <trans-unit id="235d36eec348db0a4ce24e42c9d6a7df17b250d1" translate="yes" xml:space="preserve">
          <source>The returned indices will be valid to access arrays of shape (n, n).</source>
          <target state="translated">Возвращаемые индексы будут действительны для доступа к массивам фигур (n,n).</target>
        </trans-unit>
        <trans-unit id="ae4549a46a428a48cedb9424b21a41ed06873386" translate="yes" xml:space="preserve">
          <source>The returned list contains array(s) of dtype double, complex double, or object. A 1-d argument of shape &lt;code&gt;(N,)&lt;/code&gt; is parsed into &lt;code&gt;N&lt;/code&gt; arrays of size one; a 2-d argument of shape &lt;code&gt;(M,N)&lt;/code&gt; is parsed into &lt;code&gt;M&lt;/code&gt; arrays of size &lt;code&gt;N&lt;/code&gt; (i.e., is &amp;ldquo;parsed by row&amp;rdquo;); and a higher dimensional array raises a Value Error if it is not first reshaped into either a 1-d or 2-d array.</source>
          <target state="translated">Возвращенный список содержит массив (ы) dtype double, сложного double или объекта. 1-й аргумент формы &lt;code&gt;(N,)&lt;/code&gt; разбирается на &lt;code&gt;N&lt;/code&gt; массивов первого размера; 2-й аргумент формы &lt;code&gt;(M,N)&lt;/code&gt; разбирается на &lt;code&gt;M&lt;/code&gt; массивов размера &lt;code&gt;N&lt;/code&gt; (т. е. &amp;laquo;разбирается по строкам&amp;raquo;); а массив более высокого измерения вызывает ошибку значения, если он сначала не преобразован в 1-мерный или 2-мерный массив.</target>
        </trans-unit>
        <trans-unit id="14f1e30e33046331e7dfbbcb8096ad0d5112d69f" translate="yes" xml:space="preserve">
          <source>The returned object is an object of Python-type &lt;em&gt;subtype&lt;/em&gt;, which must be a subtype of &lt;a href=&quot;c-api.types-and-structures#c.PyArray_Type&quot;&gt;&lt;code&gt;PyArray_Type&lt;/code&gt;&lt;/a&gt;. The array has &lt;em&gt;nd&lt;/em&gt; dimensions, described by &lt;em&gt;dims&lt;/em&gt;. The data-type descriptor of the new array is &lt;em&gt;descr&lt;/em&gt;.</source>
          <target state="translated">Возвращаемый объект является объектом &lt;em&gt;подтипа&lt;/em&gt; типа Python , который должен быть подтипом &lt;a href=&quot;c-api.types-and-structures#c.PyArray_Type&quot;&gt; &lt;code&gt;PyArray_Type&lt;/code&gt; &lt;/a&gt; . Массив имеет &lt;em&gt;nd&lt;/em&gt; размеры, описываемые &lt;em&gt;dims&lt;/em&gt; . Дескриптор типа данных нового массива - &lt;em&gt;descr&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="32e057c6946960f31384643bb71f5913a86433e2" translate="yes" xml:space="preserve">
          <source>The returned object is an object of Python-type &lt;em&gt;subtype&lt;/em&gt;, which must be a subtype of &lt;a href=&quot;types-and-structures#c.PyArray_Type&quot;&gt;&lt;code&gt;PyArray_Type&lt;/code&gt;&lt;/a&gt;. The array has &lt;em&gt;nd&lt;/em&gt; dimensions, described by &lt;em&gt;dims&lt;/em&gt;. The data-type descriptor of the new array is &lt;em&gt;descr&lt;/em&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5d88cddc6712bcffcc47387ee400aa7949d299dc" translate="yes" xml:space="preserve">
          <source>The returned order &lt;code&gt;m&lt;/code&gt; antiderivative &lt;code&gt;P&lt;/code&gt; of polynomial &lt;code&gt;p&lt;/code&gt; satisfies</source>
          <target state="translated">Возвращенный порядок &lt;code&gt;m&lt;/code&gt; первообразной &lt;code&gt;P&lt;/code&gt; многочлена &lt;code&gt;p&lt;/code&gt; удовлетворяет</target>
        </trans-unit>
        <trans-unit id="0b8999800a1f602548a03b4247be14d85063c532" translate="yes" xml:space="preserve">
          <source>The returned pointer will keep a reference to the array.</source>
          <target state="translated">Возвращаемый указатель будет сохранять ссылку на массив.</target>
        </trans-unit>
        <trans-unit id="592b730c2fcc65333034a0c7238210b05d5a5c20" translate="yes" xml:space="preserve">
          <source>The returned tuple can be passed as the second argument of &lt;code&gt;numpy.datetime64&lt;/code&gt; and &lt;code&gt;numpy.timedelta64&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;numpy.datetime64&lt;/code&gt; кортеж можно передать как второй аргумент numpy.datetime64 и &lt;code&gt;numpy.timedelta64&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f91874be1de458c40a0f1f04bc921bf313bf20d4" translate="yes" xml:space="preserve">
          <source>The returned tuple has the following items:</source>
          <target state="translated">Возвращаемый кортеж имеет следующие элементы:</target>
        </trans-unit>
        <trans-unit id="cef76c21baa4e56901ef823fceedd7a7068daf4e" translate="yes" xml:space="preserve">
          <source>The returned type character must represent the smallest size dtype such that an array of the returned type can handle the data from an array of all types in &lt;code&gt;typechars&lt;/code&gt; (or if &lt;code&gt;typechars&lt;/code&gt; is an array, then its dtype.char).</source>
          <target state="translated">Символ возвращаемого типа должен представлять dtype наименьшего размера, чтобы массив возвращенного типа мог обрабатывать данные из массива всех типов в типах &lt;code&gt;typechars&lt;/code&gt; (или, если &lt;code&gt;typechars&lt;/code&gt; является массивом, то его dtype.char).</target>
        </trans-unit>
        <trans-unit id="4fcc4213866e3a2e0117cc077e63fcf825ea6d85" translate="yes" xml:space="preserve">
          <source>The returned ufunc always returns PyObject arrays.</source>
          <target state="translated">Возвращаемый ufunc всегда возвращает массивы PyObject.</target>
        </trans-unit>
        <trans-unit id="a3367f678ba189a0a7553569bd4ae4f1aabaa222" translate="yes" xml:space="preserve">
          <source>The returned ufunc object is a callable Python object. It should be placed in a (module) dictionary under the same name as was used in the name argument to the ufunc-creation routine. The following example is adapted from the umath module</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="15355fac5e58f997eedbca2c4b98e86da4be8c2c" translate="yes" xml:space="preserve">
          <source>The returned values define a linear map &lt;code&gt;off + scl*x&lt;/code&gt; that is applied to the input arguments before the series is evaluated. The map depends on the &lt;code&gt;domain&lt;/code&gt; and &lt;code&gt;window&lt;/code&gt;; if the current &lt;code&gt;domain&lt;/code&gt; is equal to the &lt;code&gt;window&lt;/code&gt; the resulting map is the identity. If the coefficients of the series instance are to be used by themselves outside this class, then the linear function must be substituted for the &lt;code&gt;x&lt;/code&gt; in the standard representation of the base polynomials.</source>
          <target state="translated">Возвращаемые значения определяют линейную карту &lt;code&gt;off + scl*x&lt;/code&gt; которая применяется к входным аргументам перед оценкой серии. Карта зависит от &lt;code&gt;domain&lt;/code&gt; и &lt;code&gt;window&lt;/code&gt; ; если текущий &lt;code&gt;domain&lt;/code&gt; равен &lt;code&gt;window&lt;/code&gt; результирующая карта является идентификатором. Если коэффициенты экземпляра ряда должны использоваться сами по себе вне этого класса, тогда линейная функция должна быть заменена на &lt;code&gt;x&lt;/code&gt; в стандартном представлении базовых многочленов.</target>
        </trans-unit>
        <trans-unit id="0b9b48003d17ce5e05cd985e616cb02707b4abeb" translate="yes" xml:space="preserve">
          <source>The role of &lt;code&gt;__array_finalize__&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ee620d4452ada0e1d6c1803fadfa839462d12739" translate="yes" xml:space="preserve">
          <source>The root estimates are obtained as the eigenvalues of the companion matrix, Roots far from the origin of the complex plane may have large errors due to the numerical instability of the power series for such values. Roots with multiplicity greater than 1 will also show larger errors as the value of the series near such points is relatively insensitive to errors in the roots. Isolated roots near the origin can be improved by a few iterations of Newton&amp;rsquo;s method.</source>
          <target state="translated">Оценки корней получаются как собственные значения сопутствующей матрицы. Корни, расположенные далеко от начала комплексной плоскости, могут иметь большие ошибки из-за численной нестабильности степенного ряда для таких значений. Корни с кратностью больше 1 также будут показывать большие ошибки, поскольку значение ряда рядом с такими точками относительно нечувствительно к ошибкам в корнях. Изолированные корни около начала координат могут быть улучшены с помощью нескольких итераций метода Ньютона.</target>
        </trans-unit>
        <trans-unit id="f62c87e72745436aa10f6d1a92b0a21eb2cc7b33" translate="yes" xml:space="preserve">
          <source>The root estimates are obtained as the eigenvalues of the companion matrix, Roots far from the origin of the complex plane may have large errors due to the numerical instability of the series for such values. Roots with multiplicity greater than 1 will also show larger errors as the value of the series near such points is relatively insensitive to errors in the roots. Isolated roots near the origin can be improved by a few iterations of Newton&amp;rsquo;s method.</source>
          <target state="translated">Оценки корней получаются как собственные значения сопутствующей матрицы. Корни, удаленные от начала комплексной плоскости, могут иметь большие ошибки из-за численной нестабильности ряда для таких значений. Корни с кратностью больше 1 также будут показывать большие ошибки, поскольку значение ряда рядом с такими точками относительно нечувствительно к ошибкам в корнях. Изолированные корни около начала координат могут быть улучшены с помощью нескольких итераций метода Ньютона.</target>
        </trans-unit>
        <trans-unit id="a8ae81d114b6feba67040d0b0dda1df226f1fa7e" translate="yes" xml:space="preserve">
          <source>The roots of the polynomial, where self(x) == 0</source>
          <target state="translated">Корни многочлена,где self(x)==0</target>
        </trans-unit>
        <trans-unit id="b31543f4d0be4f9892b87954c40031df062dff89" translate="yes" xml:space="preserve">
          <source>The row dimension of the arrays for which the returned indices will be valid.</source>
          <target state="translated">Размерность строк массивов,для которых будут действительны возвращаемые индексы.</target>
        </trans-unit>
        <trans-unit id="0cdec07351f87c4df86a480e3a89d1fead72ecd2" translate="yes" xml:space="preserve">
          <source>The rtype argument specifies the data-type the reduction should take place over. This is important if the data-type of the array is not &amp;ldquo;large&amp;rdquo; enough to handle the output. By default, all integer data-types are made at least as large as &lt;a href=&quot;c-api.dtype#c.NPY_LONG&quot;&gt;&lt;code&gt;NPY_LONG&lt;/code&gt;&lt;/a&gt; for the &amp;ldquo;add&amp;rdquo; and &amp;ldquo;multiply&amp;rdquo; ufuncs (which form the basis for mean, sum, cumsum, prod, and cumprod functions).</source>
          <target state="translated">Аргумент rtype указывает тип данных, над которым должно происходить сокращение. Это важно, если тип данных массива не достаточно &amp;laquo;большой&amp;raquo; для обработки вывода. По умолчанию все целочисленные типы данных имеют &lt;a href=&quot;c-api.dtype#c.NPY_LONG&quot;&gt; &lt;code&gt;NPY_LONG&lt;/code&gt; &lt;/a&gt; не менее NPY_LONG для u-функций &amp;laquo;сложить&amp;raquo; и &amp;laquo;умножить&amp;raquo; (которые формируют основу для функций mean, sum, cumsum, prod и cumprod).</target>
        </trans-unit>
        <trans-unit id="81acb42027d32e73c24e9573f794b96cf5d260da" translate="yes" xml:space="preserve">
          <source>The rtype argument specifies the data-type the reduction should take place over. This is important if the data-type of the array is not &amp;ldquo;large&amp;rdquo; enough to handle the output. By default, all integer data-types are made at least as large as &lt;a href=&quot;dtype#c.NPY_LONG&quot;&gt;&lt;code&gt;NPY_LONG&lt;/code&gt;&lt;/a&gt; for the &amp;ldquo;add&amp;rdquo; and &amp;ldquo;multiply&amp;rdquo; ufuncs (which form the basis for mean, sum, cumsum, prod, and cumprod functions).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bec28ce661286e5b1ead8f4ea14b439b8431742d" translate="yes" xml:space="preserve">
          <source>The rule governing whether two arrays have compatible shapes for broadcasting can be expressed in a single sentence.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3014977f10c304b722035fb1a265596f0e833693" translate="yes" xml:space="preserve">
          <source>The rules for ABI and API compatibilities can be summarized as follows:</source>
          <target state="translated">Правила совместимости ABI и API можно обобщить следующим образом:</target>
        </trans-unit>
        <trans-unit id="db5c92fbe4ce9110548aea4ebd5e7c863e8e7523" translate="yes" xml:space="preserve">
          <source>The same analysis could be done with several different interest rates and/or payments and/or total amounts to produce an entire table.</source>
          <target state="translated">Один и тот же анализ может быть выполнен с несколькими различными процентными ставками и/или платежами и/или общими суммами,чтобы получить целую таблицу.</target>
        </trans-unit>
        <trans-unit id="48a74e2709e394bc98ff4e370f8920b6550d09a0" translate="yes" xml:space="preserve">
          <source>The same function can operate on a 4-D array:</source>
          <target state="translated">Одна и та же функция может работать с 4-D массивом:</target>
        </trans-unit>
        <trans-unit id="54bfa0763e872f148814a7d73d89f2039603e607" translate="yes" xml:space="preserve">
          <source>The same gcc version is used as the one with which Python itself is built on each platform. At the moment this means:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="db94598647ae75e98a229d31f17501768537975a" translate="yes" xml:space="preserve">
          <source>The same results can be obtained by using the name of the second column (&lt;code&gt;&quot;p&quot;&lt;/code&gt;) as key instead of its index (1):</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0259137762b94ac22ad991901b42b9be660a1c59" translate="yes" xml:space="preserve">
          <source>The same works for max and min, if you expand the dimensions:</source>
          <target state="translated">То же самое работает для макс.и мин.,если расширить размеры:</target>
        </trans-unit>
        <trans-unit id="2941e8dc3350840406ccff2f87675580f31546c3" translate="yes" xml:space="preserve">
          <source>The sample points corresponding to the &lt;code&gt;y&lt;/code&gt; values. If &lt;code&gt;x&lt;/code&gt; is None, the sample points are assumed to be evenly spaced &lt;code&gt;dx&lt;/code&gt; apart. The default is None.</source>
          <target state="translated">Точки выборки, соответствующие значениям &lt;code&gt;y&lt;/code&gt; . Если &lt;code&gt;x&lt;/code&gt; равен None, предполагается, что точки выборки равномерно разнесены на расстояние &lt;code&gt;dx&lt;/code&gt; друг от друга. По умолчанию - Нет.</target>
        </trans-unit>
        <trans-unit id="52ca25ab3ba5f07f393e1c15a4222278fa9f69d6" translate="yes" xml:space="preserve">
          <source>The scale of the gamma distribution. Must be non-negative. Default is equal to 1.</source>
          <target state="translated">Масштаб гамма-распределения.Должно быть,неотрицательный.По умолчанию равно 1.</target>
        </trans-unit>
        <trans-unit id="db0a2a364021746365e2e2dca54712719a934f9d" translate="yes" xml:space="preserve">
          <source>The scale parameter of the distribution. Default is 1. Must be non- negative.</source>
          <target state="translated">Параметр масштабирования распределения.По умолчанию 1.Должен быть не отрицательным.</target>
        </trans-unit>
        <trans-unit id="da19b6d80b0b211e043d20a99e868d2264fb18da" translate="yes" xml:space="preserve">
          <source>The scale parameter,</source>
          <target state="translated">Параметр шкалы,</target>
        </trans-unit>
        <trans-unit id="162cbdbbbf1e2c84bee29866f841c84cd6b13d80" translate="yes" xml:space="preserve">
          <source>The scaling of the covariance matrix in &lt;code&gt;np.polyfit&lt;/code&gt; is different</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7f0e6c0ce58755cae988a618ed26819ae121acf3" translate="yes" xml:space="preserve">
          <source>The scipy implementation is recommended over this function: it is a proper ufunc written in C, and more than an order of magnitude faster.</source>
          <target state="translated">Реализация scipy рекомендуется над этой функцией:это правильная ufunc,написанная на C,и более чем на порядок быстрее.</target>
        </trans-unit>
        <trans-unit id="678645818896e353218894b08bcbb6e53102fa78" translate="yes" xml:space="preserve">
          <source>The scipy.org should be a PR at &lt;a href=&quot;https://github.com/scipy/scipy.org&quot;&gt;https://github.com/scipy/scipy.org&lt;/a&gt;. The file that needs modification is &lt;code&gt;www/index.rst&lt;/code&gt;. Search for &lt;code&gt;News&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="076d96a74fdcb13373554cd33f5faa0a5c841024" translate="yes" xml:space="preserve">
          <source>The second argument passed in to the Py_InitModule function is a structure that makes it easy to to define functions in the module. In the example given above, the mymethods structure would have been defined earlier in the file (usually right before the init{name} subroutine) to:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f1d1e93a16e6953d6dc31578f1bc0e4185a42885" translate="yes" xml:space="preserve">
          <source>The second element, &lt;em&gt;field_dtype&lt;/em&gt;, can be anything that can be interpreted as a data-type.</source>
          <target state="translated">Второй элемент &lt;em&gt;field_dtype&lt;/em&gt; может быть любым, что можно интерпретировать как тип данных.</target>
        </trans-unit>
        <trans-unit id="4ebced32cc87e2c3435e9151b36d6b3c2cfaf845" translate="yes" xml:space="preserve">
          <source>The second is to set the error-handler to &amp;lsquo;log&amp;rsquo;, using &lt;a href=&quot;numpy.seterr#numpy.seterr&quot;&gt;&lt;code&gt;seterr&lt;/code&gt;&lt;/a&gt;. Floating-point errors then trigger a call to the &amp;lsquo;write&amp;rsquo; method of the provided object.</source>
          <target state="translated">Второй - установить обработчик ошибок в журнал с помощью &lt;a href=&quot;numpy.seterr#numpy.seterr&quot;&gt; &lt;code&gt;seterr&lt;/code&gt; &lt;/a&gt; . Затем ошибки с плавающей запятой вызывают вызов метода записи предоставленного объекта.</target>
        </trans-unit>
        <trans-unit id="6f31ccc451074791f12a3d0394615bd3d0e3cdd2" translate="yes" xml:space="preserve">
          <source>The second issue to understand is how indices correspond to the order the array is stored in memory. In Fortran the first index is the most rapidly varying index when moving through the elements of a two dimensional array as it is stored in memory. If you adopt the matrix convention for indexing, then this means the matrix is stored one column at a time (since the first index moves to the next row as it changes). Thus Fortran is considered a Column-major language. C has just the opposite convention. In C, the last index changes most rapidly as one moves through the array as stored in memory. Thus C is a Row-major language. The matrix is stored by rows. Note that in both cases it presumes that the matrix convention for indexing is being used, i.e., for both Fortran and C, the first index is the row. Note this convention implies that the indexing convention is invariant and that the data order changes to keep that so.</source>
          <target state="translated">Вторая проблема,которую необходимо понять,это то,как индексы соответствуют порядку хранения массива в памяти.В Fortran первый индекс является самым быстро меняющимся при перемещении по элементам двухмерного массива,так как он хранится в памяти.Если для индексирования использовать матричное соглашение,то это означает,что матрица хранится по одному столбцу за раз (так как при изменении первого индекса он переходит в следующую строку).Таким образом,Fortran считается языком отображения колонок.C имеет прямо противоположное соглашение.В языке C последний индекс изменяется быстрее всего при перемещении по хранящемуся в памяти массиву.Таким образом,C является языком отображения строк.Матрица хранится в строках.Обратите внимание,что в обоих случаях предполагается,что для индексирования используется матричное соглашение,т.е.и для Fortran,и для C первым индексом является строка.Обратите внимание,что это соглашение подразумевает,что соглашение об индексировании является инвариантным,и что порядок данных изменяется,чтобы сохранить это.</target>
        </trans-unit>
        <trans-unit id="453559558db2eb56414a46dbdb5de2376ea80083" translate="yes" xml:space="preserve">
          <source>The second rule of broadcasting ensures that arrays with a size of 1 along a particular dimension act as if they had the size of the array with the largest shape along that dimension. The value of the array element is assumed to be the same along that dimension for the &amp;ldquo;broadcast&amp;rdquo; array.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fe0109b90f8697e3f57d897bca8c421d8285d2b1" translate="yes" xml:space="preserve">
          <source>The second way is to upload the PKG_INFO file inside the sdist dir in the web interface of PyPI. The source tarball can also be uploaded through this interface.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7aabd3a3162d932dde5dce5c1f8c9f863c647d1b" translate="yes" xml:space="preserve">
          <source>The second way of indexing with booleans is more similar to integer indexing; for each dimension of the array we give a 1D boolean array selecting the slices we want:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="66a3455570bd434e86d6f052ed9b9a1d4a2c4251" translate="yes" xml:space="preserve">
          <source>The sections of a function&amp;rsquo;s docstring are:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8eb125eefbda7190ce972cb7d8270d5ae89dc7b7" translate="yes" xml:space="preserve">
          <source>The self.paths(&amp;hellip;) method is applied to all lists that may contain paths.</source>
          <target state="translated">Метод self.paths (&amp;hellip;) применяется ко всем спискам, которые могут содержать пути.</target>
        </trans-unit>
        <trans-unit id="8c7148486ba5b770e99fd7463ec63c216dee7366" translate="yes" xml:space="preserve">
          <source>The separation between elements for each dimension (the &amp;lsquo;stride&amp;rsquo;). This does not have to be a multiple of the element size</source>
          <target state="translated">Разделение между элементами для каждого измерения (&amp;laquo;шаг&amp;raquo;). Это не обязательно должно быть кратно размеру элемента.</target>
        </trans-unit>
        <trans-unit id="9cd2ff64b895aeb8d0b16f3694ac2aea08560437" translate="yes" xml:space="preserve">
          <source>The series in this context are finite sums of the corresponding polynomial basis functions multiplied by coefficients. For instance, a power series looks like</source>
          <target state="translated">Ряд в данном контексте представляет собой конечные суммы соответствующих полиномиальных базисных функций,умноженные на коэффициенты.Например,силовой ряд выглядит как</target>
        </trans-unit>
        <trans-unit id="9285a776c2a659ee75e7938ac17b155070381205" translate="yes" xml:space="preserve">
          <source>The series instance to be converted.</source>
          <target state="translated">Конвертируемый экземпляр серии.</target>
        </trans-unit>
        <trans-unit id="89a518ad1f6d727d2464d8f222f198c518f126e6" translate="yes" xml:space="preserve">
          <source>The series is reduced to degree &lt;code&gt;deg&lt;/code&gt; by discarding the high order terms. The value of &lt;code&gt;deg&lt;/code&gt; must be a non-negative integer.</source>
          <target state="translated">Ряд сокращается до степени &lt;code&gt;deg&lt;/code&gt; , отбрасывая члены высокого порядка. Значение &lt;code&gt;deg&lt;/code&gt; должно быть неотрицательным целым числом.</target>
        </trans-unit>
        <trans-unit id="adbbacc122f5859d958a7eb7009d4955c1c2c537" translate="yes" xml:space="preserve">
          <source>The series is reduced to length &lt;code&gt;size&lt;/code&gt; by discarding the high degree terms. The value of &lt;code&gt;size&lt;/code&gt; must be a positive integer.</source>
          <target state="translated">Ряд уменьшен до &lt;code&gt;size&lt;/code&gt; длины за счет отбрасывания членов высокой степени. Значение &lt;code&gt;size&lt;/code&gt; должно быть положительным целым числом.</target>
        </trans-unit>
        <trans-unit id="38262a9c7d66cebff5a42640a9df021a775761be" translate="yes" xml:space="preserve">
          <source>The set of available codecs comes from the Python standard library, and may be extended at runtime. For more information, see the &lt;a href=&quot;https://docs.python.org/dev/library/codecs.html#module-codecs&quot;&gt;&lt;code&gt;codecs&lt;/code&gt;&lt;/a&gt; module.</source>
          <target state="translated">Набор доступных кодеков взят из стандартной библиотеки Python и может быть расширен во время выполнения. Для получения дополнительной информации см. Модуль &lt;a href=&quot;https://docs.python.org/dev/library/codecs.html#module-codecs&quot;&gt; &lt;code&gt;codecs&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="a717e3302b8636b7790364bffe6b5a183f3f6e7f" translate="yes" xml:space="preserve">
          <source>The set of available codecs comes from the Python standard library, and may be extended at runtime. For more information, see the codecs module.</source>
          <target state="translated">Набор доступных кодеков поставляется из стандартной библиотеки Python и может быть расширен во время исполнения.Дополнительную информацию см.в модуле кодеков.</target>
        </trans-unit>
        <trans-unit id="f3119f479b7378be171f9e5461ebc7ae89470f50" translate="yes" xml:space="preserve">
          <source>The set of characters that the returned character is chosen from. The default set is &amp;lsquo;GDFgdf&amp;rsquo;.</source>
          <target state="translated">Набор символов, из которого выбирается возвращаемый символ. По умолчанию установлено &amp;laquo;GDFgdf&amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="a3a4541aef2e0618e33ebd5e18d9c022d28bcaa8" translate="yes" xml:space="preserve">
          <source>The set of functions that convert the data of a column to a value. The converters can also be used to provide a default value for missing data: &lt;code&gt;converters = {3: lambda s: float(s or 0)}&lt;/code&gt;.</source>
          <target state="translated">Набор функций, преобразующих данные столбца в значение. Конвертеры также можно использовать для предоставления значения по умолчанию для отсутствующих данных: &lt;code&gt;converters = {3: lambda s: float(s or 0)}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7e26f5391f4384da7c676eb1e9d468550abb0eb1" translate="yes" xml:space="preserve">
          <source>The set of int values is not a subset of the uint values for types with the same number of bits, something not reflected in &lt;a href=&quot;#c.PyArray_MinScalarType&quot;&gt;&lt;code&gt;PyArray_MinScalarType&lt;/code&gt;&lt;/a&gt;, but handled as a special case in PyArray_ResultType.</source>
          <target state="translated">Набор значений int не является подмножеством значений uint для типов с таким же количеством битов, что не отражено в &lt;a href=&quot;#c.PyArray_MinScalarType&quot;&gt; &lt;code&gt;PyArray_MinScalarType&lt;/code&gt; &lt;/a&gt; , но обрабатывается как особый случай в PyArray_ResultType.</target>
        </trans-unit>
        <trans-unit id="e76841686484db8628455fd162b8197749bc84c1" translate="yes" xml:space="preserve">
          <source>The set of int values is not a subset of the uint values for types with the same number of bits, something not reflected in &lt;a href=&quot;numpy.min_scalar_type#numpy.min_scalar_type&quot;&gt;&lt;code&gt;min_scalar_type&lt;/code&gt;&lt;/a&gt;, but handled as a special case in &lt;a href=&quot;#numpy.result_type&quot;&gt;&lt;code&gt;result_type&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Набор значений int не является подмножеством значений uint для типов с таким же количеством битов, что не отражено в &lt;a href=&quot;numpy.min_scalar_type#numpy.min_scalar_type&quot;&gt; &lt;code&gt;min_scalar_type&lt;/code&gt; &lt;/a&gt; , но обрабатывается как особый случай в &lt;a href=&quot;#numpy.result_type&quot;&gt; &lt;code&gt;result_type&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="561107923e2d5ef74733b059316312382b1f95e9" translate="yes" xml:space="preserve">
          <source>The set of strings corresponding to missing data.</source>
          <target state="translated">Набор строк,соответствующих пропущенным данным.</target>
        </trans-unit>
        <trans-unit id="3c3fdff23bd130c5708b43d7769884cc7638d9dc" translate="yes" xml:space="preserve">
          <source>The set of values to be used as default when the data are missing.</source>
          <target state="translated">Набор значений,которые будут использоваться по умолчанию,когда данные отсутствуют.</target>
        </trans-unit>
        <trans-unit id="40c5a46b247f5eb179525001f8ba092f80c0ed2a" translate="yes" xml:space="preserve">
          <source>The setup function for all three methods is &lt;code&gt;construct_reduce&lt;/code&gt;. This function creates a reducing loop object and fills it with parameters needed to complete the loop. All of the methods only work on ufuncs that take 2-inputs and return 1 output. Therefore, the underlying 1-D loop is selected assuming a signature of [ &lt;code&gt;otype&lt;/code&gt;, &lt;code&gt;otype&lt;/code&gt;, &lt;code&gt;otype&lt;/code&gt; ] where &lt;code&gt;otype&lt;/code&gt; is the requested reduction data-type. The buffer size and error handling is then retrieved from (per-thread) global storage. For small arrays that are mis-aligned or have incorrect data-type, a copy is made so that the un-buffered section of code is used. Then, the looping strategy is selected. If there is 1 element or 0 elements in the array, then a simple looping method is selected. If the array is not mis-aligned and has the correct data-type, then strided looping is selected. Otherwise, buffered looping must be performed. Looping parameters are then established, and the return array is constructed. The output array is of a different shape depending on whether the method is reduce, accumulate, or reduceat. If an output array is already provided, then it&amp;rsquo;s shape is checked. If the output array is not C-contiguous, aligned, and of the correct data type, then a temporary copy is made with the WRITEBACKIFCOPY flag set. In this way, the methods will be able to work with a well-behaved output array but the result will be copied back into the true output array when &lt;a href=&quot;c-api.array#c.PyArray_ResolveWritebackIfCopy&quot;&gt;&lt;code&gt;PyArray_ResolveWritebackIfCopy&lt;/code&gt;&lt;/a&gt; is called at function completion. Finally, iterators are set up to loop over the correct axis (depending on the value of axis provided to the method) and the setup routine returns to the actual computation routine.</source>
          <target state="translated">Функция настройки для всех трех методов - &lt;code&gt;construct_reduce&lt;/code&gt; . Эта функция создает уменьшающий объект цикла и заполняет его параметрами, необходимыми для завершения цикла. Все методы работают только с ufuncs, которые принимают 2 входа и возвращают 1 выход. Таким образом, базовый &lt;code&gt;otype&lt;/code&gt; цикл выбирается с учетом сигнатуры [ otype , &lt;code&gt;otype&lt;/code&gt; , &lt;code&gt;otype&lt;/code&gt; ], где &lt;code&gt;otype&lt;/code&gt; - запрошенный тип данных сокращения. Затем размер буфера и обработка ошибок извлекаются из глобального хранилища (для каждого потока). Для небольших массивов, которые неправильно выровнены или имеют неправильный тип данных, делается копия, так что используется небуферизованная часть кода. Затем выбирается стратегия зацикливания. Если в массиве 1 элемент или 0 элементов, то выбирается простой метод цикла. Если массив правильно выровнен и имеет правильный тип данных, то выбирается чередующийся цикл. В противном случае необходимо выполнить буферизованный цикл. Затем устанавливаются параметры цикла и строится возвращаемый массив. Выходной массив имеет разную форму в зависимости от метода уменьшения, накопления или уменьшения. Если выходной массив уже предоставлен, проверяется его форма. Если выходной массив не является C-смежным, выровненным,и правильного типа данных, то создается временная копия с установленным флагом WRITEBACKIFCOPY. Таким образом, методы смогут работать с корректным выходным массивом, но результат будет скопирован обратно в настоящий выходной массив, когда&lt;a href=&quot;c-api.array#c.PyArray_ResolveWritebackIfCopy&quot;&gt; &lt;code&gt;PyArray_ResolveWritebackIfCopy&lt;/code&gt; &lt;/a&gt; вызывается при завершении функции. Наконец, итераторы настраиваются на цикл по правильной оси (в зависимости от значения оси, предоставленной методу), и процедура настройки возвращается к фактической программе вычислений.</target>
        </trans-unit>
        <trans-unit id="26040668927e88fa78277a9dd0406a200dc72c4f" translate="yes" xml:space="preserve">
          <source>The setup function for all three methods is &lt;code&gt;construct_reduce&lt;/code&gt;. This function creates a reducing loop object and fills it with parameters needed to complete the loop. All of the methods only work on ufuncs that take 2-inputs and return 1 output. Therefore, the underlying 1-D loop is selected assuming a signature of [ &lt;code&gt;otype&lt;/code&gt;, &lt;code&gt;otype&lt;/code&gt;, &lt;code&gt;otype&lt;/code&gt; ] where &lt;code&gt;otype&lt;/code&gt; is the requested reduction data-type. The buffer size and error handling is then retrieved from (per-thread) global storage. For small arrays that are mis-aligned or have incorrect data-type, a copy is made so that the un-buffered section of code is used. Then, the looping strategy is selected. If there is 1 element or 0 elements in the array, then a simple looping method is selected. If the array is not mis-aligned and has the correct data-type, then strided looping is selected. Otherwise, buffered looping must be performed. Looping parameters are then established, and the return array is constructed. The output array is of a different shape depending on whether the method is reduce, accumulate, or reduceat. If an output array is already provided, then it&amp;rsquo;s shape is checked. If the output array is not C-contiguous, aligned, and of the correct data type, then a temporary copy is made with the WRITEBACKIFCOPY flag set. In this way, the methods will be able to work with a well-behaved output array but the result will be copied back into the true output array when &lt;a href=&quot;c-api/array#c.PyArray_ResolveWritebackIfCopy&quot;&gt;&lt;code&gt;PyArray_ResolveWritebackIfCopy&lt;/code&gt;&lt;/a&gt; is called at function completion. Finally, iterators are set up to loop over the correct axis (depending on the value of axis provided to the method) and the setup routine returns to the actual computation routine.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="780e857a060059f3e4636a17060f123b8f85b3b2" translate="yes" xml:space="preserve">
          <source>The shape (always C-style contiguous) of the sub-array as a Python tuple.</source>
          <target state="translated">Форма (всегда в стиле С)суб-массива в виде питоновского кортежа.</target>
        </trans-unit>
        <trans-unit id="9bd591fada3b4117c12a2a1f4d689c069ec359b8" translate="yes" xml:space="preserve">
          <source>The shape and data-type of &lt;code&gt;a&lt;/code&gt; define these same attributes of the returned array.</source>
          <target state="translated">Форма и тип данных &lt;code&gt;a&lt;/code&gt; определяют те же атрибуты возвращаемого массива.</target>
        </trans-unit>
        <trans-unit id="ea4fdc5d91eb3f313e977fbfd63ada0a25a66896" translate="yes" xml:space="preserve">
          <source>The shape and data-type of &lt;code&gt;prototype&lt;/code&gt; define these same attributes of the returned array.</source>
          <target state="translated">Форма и тип данных &lt;code&gt;prototype&lt;/code&gt; определяют те же атрибуты возвращаемого массива.</target>
        </trans-unit>
        <trans-unit id="de0758f703e3713cedaff1b24e8618c254649ffe" translate="yes" xml:space="preserve">
          <source>The shape of an array can be changed with various commands. Note that the following three commands all return a modified array, but do not change the original array:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="55cbdf85b9592ec5dbddfd31ccd2c86de9452ccc" translate="yes" xml:space="preserve">
          <source>The shape of array into which the indices from &lt;code&gt;multi_index&lt;/code&gt; apply.</source>
          <target state="translated">Форма массива, к которому применяются индексы из &lt;code&gt;multi_index&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="86ea4631bc5657813d3aa6a6102c3531d8908358" translate="yes" xml:space="preserve">
          <source>The shape of each output is determined from the loop dimensions plus the output&amp;rsquo;s core dimensions</source>
          <target state="translated">Форма каждого выхода определяется из размеров контура плюс размеры сердечника выхода.</target>
        </trans-unit>
        <trans-unit id="432cd297e760e974a03d449cad5f33c7ccb0d645" translate="yes" xml:space="preserve">
          <source>The shape of the array is preserved, but the elements are reordered.</source>
          <target state="translated">Форма массива сохраняется,но элементы переупорядочиваются.</target>
        </trans-unit>
        <trans-unit id="fb341212b6f41ae91b019292b043b6094616b784" translate="yes" xml:space="preserve">
          <source>The shape of the array to be iterated over.</source>
          <target state="translated">Форма массива для итерации.</target>
        </trans-unit>
        <trans-unit id="a015ba13ffb4171bac494c802f272bfb87417c5d" translate="yes" xml:space="preserve">
          <source>The shape of the array to use for unraveling &lt;code&gt;indices&lt;/code&gt;.</source>
          <target state="translated">Форма массива для использования при расшифровке &lt;code&gt;indices&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9865a6cbf282f8b0812325650b93441342efdd22" translate="yes" xml:space="preserve">
          <source>The shape of the array.</source>
          <target state="translated">Форма массива.</target>
        </trans-unit>
        <trans-unit id="634c22963834ab0f96135fc087ba541ef29a9351" translate="yes" xml:space="preserve">
          <source>The shape of the broadcasted result (only &lt;code&gt;nd&lt;/code&gt; slots are used).</source>
          <target state="translated">Форма транслируемого результата (используются только &lt;code&gt;nd&lt;/code&gt; слоты).</target>
        </trans-unit>
        <trans-unit id="b35ba9f7409c5e79b96888dfb9fe12c59d8276ca" translate="yes" xml:space="preserve">
          <source>The shape of the desired array.</source>
          <target state="translated">Форма нужного массива.</target>
        </trans-unit>
        <trans-unit id="f8fd7f6a4e1f2e482a2f6d64364dd79594585ba9" translate="yes" xml:space="preserve">
          <source>The shape of the gamma distribution. Must be non-negative.</source>
          <target state="translated">Форма гамма-распределения.Должно быть,неотрицательная.</target>
        </trans-unit>
        <trans-unit id="40d55544c4b29b3e5cccb47aa9255a7413094e32" translate="yes" xml:space="preserve">
          <source>The shape of the grid.</source>
          <target state="translated">Форма сетки.</target>
        </trans-unit>
        <trans-unit id="666be679bea4cf4401944751286d85ef9bcbd1ab" translate="yes" xml:space="preserve">
          <source>The shape of the new array. Defaults to &lt;code&gt;x.shape&lt;/code&gt;.</source>
          <target state="translated">Форма нового массива. По умолчанию &lt;code&gt;x.shape&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="be82fcdcf7279745a92907a11f17b40fb49cfa8e" translate="yes" xml:space="preserve">
          <source>The shape of the output depends on the size of &lt;a href=&quot;numpy.indices#numpy.indices&quot;&gt;&lt;code&gt;indices&lt;/code&gt;&lt;/a&gt;, and may be larger than &lt;code&gt;a&lt;/code&gt; (this happens if &lt;code&gt;len(indices) &amp;gt; a.shape[axis]&lt;/code&gt;).</source>
          <target state="translated">Форма вывода зависит от размера &lt;a href=&quot;numpy.indices#numpy.indices&quot;&gt; &lt;code&gt;indices&lt;/code&gt; &lt;/a&gt; и может быть больше, чем &lt;code&gt;a&lt;/code&gt; (это происходит, если &lt;code&gt;len(indices) &amp;gt; a.shape[axis]&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="fed05fc9900417f6dd9d3b1246dc76a2025a600b" translate="yes" xml:space="preserve">
          <source>The shape of the result consists of the non-contracted axes of the first tensor, followed by the non-contracted axes of the second.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dac69f494ba7fae89ed73806775a3c39622a5622" translate="yes" xml:space="preserve">
          <source>The shape of the return value is described above.</source>
          <target state="translated">Форма возвращаемого значения описана выше.</target>
        </trans-unit>
        <trans-unit id="e988320cd7cc6c4a6c3dd57d84589dcf99664d33" translate="yes" xml:space="preserve">
          <source>The shape of the returned array is described above.</source>
          <target state="translated">Форма возвращаемого массива описана выше.</target>
        </trans-unit>
        <trans-unit id="3b10de911cd8ce2a5b2b31e29ac9a30a0aac3857" translate="yes" xml:space="preserve">
          <source>The shape of the returned matrix is &lt;code&gt;x.shape + (order,)&lt;/code&gt;, where</source>
          <target state="translated">Форма возвращаемой матрицы - &lt;code&gt;x.shape + (order,)&lt;/code&gt; , где</target>
        </trans-unit>
        <trans-unit id="80077b48358a43ab7ec659d3d5fde9d46b95fb86" translate="yes" xml:space="preserve">
          <source>The shape parameter must be given if converting from a ctypes POINTER. The shape parameter is ignored if converting from a ctypes array</source>
          <target state="translated">Параметр &quot;Форма&quot; должен быть задан при преобразовании из типа POINTER.Параметр shape игнорируется при преобразовании из массива типов</target>
        </trans-unit>
        <trans-unit id="fd56dfcd2507095f44b621f1654fe8bcd97f2720" translate="yes" xml:space="preserve">
          <source>The shape property is usually used to get the current shape of an array, but may also be used to reshape the array in-place by assigning a tuple of array dimensions to it. As with &lt;a href=&quot;numpy.reshape#numpy.reshape&quot;&gt;&lt;code&gt;numpy.reshape&lt;/code&gt;&lt;/a&gt;, one of the new shape dimensions can be -1, in which case its value is inferred from the size of the array and the remaining dimensions. Reshaping an array in-place will fail if a copy is required.</source>
          <target state="translated">Свойство shape обычно используется для получения текущей формы массива, но может также использоваться для изменения формы массива на месте путем присвоения ему кортежа размеров массива. Как и в случае с &lt;a href=&quot;numpy.reshape#numpy.reshape&quot;&gt; &lt;code&gt;numpy.reshape&lt;/code&gt; &lt;/a&gt; , одним из новых размеров формы может быть -1, и в этом случае его значение выводится из размера массива и остальных измерений. Изменение формы массива на месте не удастся, если требуется копия.</target>
        </trans-unit>
        <trans-unit id="80c5a27079e0e5c1026de7841cb52daa2c677404" translate="yes" xml:space="preserve">
          <source>The shapes of x, y, and the condition are broadcast together:</source>
          <target state="translated">Формы х,у и состояние транслируются вместе:</target>
        </trans-unit>
        <trans-unit id="18b788b2f85a3ae45e9f183bcbf59e96d87edbee" translate="yes" xml:space="preserve">
          <source>The shifted array.</source>
          <target state="translated">Смещенный массив.</target>
        </trans-unit>
        <trans-unit id="a03c5ad272b253bf040f55b1c50d0da307be8ac5" translate="yes" xml:space="preserve">
          <source>The sign of &lt;code&gt;x2&lt;/code&gt; is copied to &lt;code&gt;x1&lt;/code&gt;. If &lt;code&gt;x1.shape != x2.shape&lt;/code&gt;, they must be broadcastable to a common shape (which becomes the shape of the output).</source>
          <target state="translated">Знак &lt;code&gt;x2&lt;/code&gt; копируется в &lt;code&gt;x1&lt;/code&gt; . Если &lt;code&gt;x1.shape != x2.shape&lt;/code&gt; , они должны транслироваться в общую форму (которая становится формой вывода).</target>
        </trans-unit>
        <trans-unit id="9a96a866f0e16363f3d77343ed89edc57a089b06" translate="yes" xml:space="preserve">
          <source>The sign of &lt;code&gt;x&lt;/code&gt;. This is a scalar if &lt;code&gt;x&lt;/code&gt; is a scalar.</source>
          <target state="translated">Знак &lt;code&gt;x&lt;/code&gt; . Это скаляр, если &lt;code&gt;x&lt;/code&gt; - скаляр.</target>
        </trans-unit>
        <trans-unit id="39e50e1c53e79cf4e2679a1929a8b236a790ceb1" translate="yes" xml:space="preserve">
          <source>The signature defines &amp;ldquo;core&amp;rdquo; dimensionality of input and output variables, and thereby also defines the contraction of the dimensions. The signature is represented by a string of the following format:</source>
          <target state="translated">Сигнатура определяет &amp;laquo;базовую&amp;raquo; размерность входных и выходных переменных и, таким образом, также определяет сокращение размеров. Подпись представлена ​​строкой следующего формата:</target>
        </trans-unit>
        <trans-unit id="077a1bbb529dbf66c684eb23b600d5d4d40598cf" translate="yes" xml:space="preserve">
          <source>The signature determines how the dimensions of each input/output array are split into core and loop dimensions:</source>
          <target state="translated">Сигнатура определяет,как размеры каждого входного/выходного массива разбиваются на размеры ядра и цикла:</target>
        </trans-unit>
        <trans-unit id="b9b7ac7b939268ddc59ac1f05c9ebd5e07bf4b21" translate="yes" xml:space="preserve">
          <source>The signature file is saved to &lt;code&gt;fib1.pyf&lt;/code&gt; (see &lt;code&gt;-h&lt;/code&gt; flag) and its contents is shown below.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f03fcdecb4ad7904d6d08273575b7efc1ecd0bcc" translate="yes" xml:space="preserve">
          <source>The signature of &lt;code&gt;__array_finalize__&lt;/code&gt; is:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="51657129c6ecba9775cfcd86518eea063cc02856" translate="yes" xml:space="preserve">
          <source>The signature of &lt;code&gt;__array_ufunc__&lt;/code&gt; is:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7eceedf301ec9322c1f2e0e1b62bac4ce44cf0b3" translate="yes" xml:space="preserve">
          <source>The signature of a Fortran block data has the following structure:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="07cca1f52e338494fc6137e9ab73032ffedaab99" translate="yes" xml:space="preserve">
          <source>The signature of a Fortran routine has the following structure:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="29c6d5e035a62abf39bca07984559eb4c2eed470" translate="yes" xml:space="preserve">
          <source>The simplest and fastest estimator. Only takes into account the data size.</source>
          <target state="translated">Самый простой и быстрый оценщик.Учитывает только размер данных.</target>
        </trans-unit>
        <trans-unit id="f68339a598fdad0949b432ba0f071db76d4162b2" translate="yes" xml:space="preserve">
          <source>The simplest case of indexing with &lt;em&gt;N&lt;/em&gt; integers returns an &lt;a href=&quot;arrays.scalars#arrays-scalars&quot;&gt;array scalar&lt;/a&gt; representing the corresponding item. As in Python, all indices are zero-based: for the &lt;em&gt;i&lt;/em&gt;-th index</source>
          <target state="translated">В простейшем случае индексации с &lt;em&gt;N&lt;/em&gt; целыми числами возвращается &lt;a href=&quot;arrays.scalars#arrays-scalars&quot;&gt;скаляр массива,&lt;/a&gt; представляющий соответствующий элемент. Как и в Python, все индексы отсчитываются от нуля: для &lt;em&gt;i&lt;/em&gt; -го индекса</target>
        </trans-unit>
        <trans-unit id="7ff2686b623caae27117f3c5885c7d6ae7623a3a" translate="yes" xml:space="preserve">
          <source>The simplest way to assign values to a structured array is using python tuples. Each assigned value should be a tuple of length equal to the number of fields in the array, and not a list or array as these will trigger numpy&amp;rsquo;s broadcasting rules. The tuple&amp;rsquo;s elements are assigned to the successive fields of the array, from left to right:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="082b93c290be349a4bf83756ecca01f8d723b944" translate="yes" xml:space="preserve">
          <source>The simplest way to create a record array is with &lt;code&gt;numpy.rec.array&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="47091f34475faaaa1ba4de46a8ad6549a8d5a1f2" translate="yes" xml:space="preserve">
          <source>The simulation of a C-style array is not complete for 2-d and 3-d arrays. For example, the simulated arrays of pointers cannot be passed to subroutines expecting specific, statically-defined 2-d and 3-d arrays. To pass to functions requiring those kind of inputs, you must statically define the required array and copy data.</source>
          <target state="translated">Моделирование массива в стиле C не завершено для 2-d и 3-d массивов.Например,моделируемые массивы указателей нельзя передать в подпрограммы,ожидающие конкретных,статически определенных 2-d и 3-d массивов.Для передачи в функции,требующие таких входов,необходимо статически определить требуемый массив и скопировать данные.</target>
        </trans-unit>
        <trans-unit id="51abf12252a4d92a90b52830906a8c2bd4002537" translate="yes" xml:space="preserve">
          <source>The sinc function is</source>
          <target state="translated">Функция цинка заключается в том,чтобы</target>
        </trans-unit>
        <trans-unit id="ca8287ab64739fe1883b42785585fd67081d297d" translate="yes" xml:space="preserve">
          <source>The sinc function is used in various signal processing applications, including in anti-aliasing, in the construction of a Lanczos resampling filter, and in interpolation.</source>
          <target state="translated">Функция sinc используется в различных приложениях по обработке сигналов,в том числе при сглаживании,при построении фильтра ресэмплирования Lanczos,а также в интерполяции.</target>
        </trans-unit>
        <trans-unit id="237e09976f401d9a2f1baabe777a697734eddddd" translate="yes" xml:space="preserve">
          <source>The sine is one of the fundamental functions of trigonometry (the mathematical study of triangles). Consider a circle of radius 1 centered on the origin. A ray comes in from the</source>
          <target state="translated">Синус является одной из фундаментальных функций тригонометрии (математическое исследование треугольников).Рассмотрим круг радиуса 1,центрированный по происхождению.Луч поступает из</target>
        </trans-unit>
        <trans-unit id="eeee63a3a1e6205f2e90fb5ed65d351e3798fee5" translate="yes" xml:space="preserve">
          <source>The sine of each element of x. This is a scalar if &lt;code&gt;x&lt;/code&gt; is a scalar.</source>
          <target state="translated">Синус каждого элемента x. Это скаляр, если &lt;code&gt;x&lt;/code&gt; - скаляр.</target>
        </trans-unit>
        <trans-unit id="b9c09c4d5914f0dda5c0b150c5f3b90e766bd841" translate="yes" xml:space="preserve">
          <source>The single threaded call directly uses the BitGenerator.</source>
          <target state="translated">Однопоточный вызов напрямую использует BitGenerator.</target>
        </trans-unit>
        <trans-unit id="4e52363a0d1aff84bc0a45f224b49ba218e2396a" translate="yes" xml:space="preserve">
          <source>The situation with numpy makes this issue yet more complicated. The internal machinery of numpy arrays is flexible enough to accept any ordering of indices. One can simply reorder indices by manipulating the internal stride information for arrays without reordering the data at all. NumPy will know how to map the new index order to the data without moving the data.</source>
          <target state="translated">Ситуация с онемением еще больше усложняет этот вопрос.Внутренний механизм нумерующих массивов достаточно гибкий,чтобы принимать любой заказ индексов.Просто переупорядочить индексы можно,манипулируя внутренней информацией о шагах для массивов,вообще не переупорядочивая данные.NumPy знает,как нанести новый порядок следования индексов на данные,не перемещая их.</target>
        </trans-unit>
        <trans-unit id="6d5ab6e4dc0fec0528be17bc5d4e3ad5f3c1a900" translate="yes" xml:space="preserve">
          <source>The size in each dimension of the output shape is the maximum of all the input sizes in that dimension.</source>
          <target state="translated">Размер в каждом измерении выходной формы является максимальным из всех входных размеров в этом измерении.</target>
        </trans-unit>
        <trans-unit id="0f600bd12887e2a8896ddc5bed9d6833c21b9000" translate="yes" xml:space="preserve">
          <source>The size of each dimension of the array.</source>
          <target state="translated">Размер каждого измерения массива.</target>
        </trans-unit>
        <trans-unit id="bcfaa2928c38d19614d82820fec94f09b6747c0f" translate="yes" xml:space="preserve">
          <source>The size of each word. This should only be either &lt;code&gt;uint32&lt;/code&gt; or &lt;code&gt;uint64&lt;/code&gt;. Strings (&lt;code&gt;&amp;lsquo;uint32&amp;rsquo;&lt;/code&gt;, &lt;code&gt;&amp;lsquo;uint64&amp;rsquo;&lt;/code&gt;) are fine. Note that requesting &lt;code&gt;uint64&lt;/code&gt; will draw twice as many bits as &lt;code&gt;uint32&lt;/code&gt; for the same &lt;code&gt;n_words&lt;/code&gt;. This is a convenience for &lt;code&gt;BitGenerator`s that express their states as `uint64&lt;/code&gt; arrays.</source>
          <target state="translated">Размер каждого слова. Это должно быть только &lt;code&gt;uint32&lt;/code&gt; или &lt;code&gt;uint64&lt;/code&gt; . Строки ( &lt;code&gt;&amp;lsquo;uint32&amp;rsquo;&lt;/code&gt; , &lt;code&gt;&amp;lsquo;uint64&amp;rsquo;&lt;/code&gt; ) в порядке. Обратите внимание, что запрос &lt;code&gt;uint64&lt;/code&gt; потребует вдвое больше битов, чем &lt;code&gt;uint32&lt;/code&gt; для тех же &lt;code&gt;n_words&lt;/code&gt; . Это удобство для &lt;code&gt;BitGenerator`s that express their states as `uint64&lt;/code&gt; массивы uint64 .</target>
        </trans-unit>
        <trans-unit id="28a984c9bdd908f87770bb977436d6a66f4306a1" translate="yes" xml:space="preserve">
          <source>The size of the array minus 1 in each dimension.</source>
          <target state="translated">Размер массива минус 1 в каждом измерении.</target>
        </trans-unit>
        <trans-unit id="c41c1278613c7ed690de9865ed90f9449e9899a0" translate="yes" xml:space="preserve">
          <source>The size of the arrays for which the returned indices will be valid.</source>
          <target state="translated">Размер массивов,для которых будут действительны возвращаемые индексы.</target>
        </trans-unit>
        <trans-unit id="d186d8343ee709824ee3589500ce1f21e3851f01" translate="yes" xml:space="preserve">
          <source>The size of the dtype element in bytes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b0386b240ebd0571b8a05df9bc4fa0aef34289c1" translate="yes" xml:space="preserve">
          <source>The size, along each dimension, of the arrays for which the returned indices can be used.</source>
          <target state="translated">Размер по каждому измерению массивов,для которых можно использовать возвращаемые индексы.</target>
        </trans-unit>
        <trans-unit id="14747cd54a2f3abe194636cc52acff3e4c5bb985" translate="yes" xml:space="preserve">
          <source>The slice is a &lt;em&gt;view&lt;/em&gt; onto the original &lt;code&gt;c_arr&lt;/code&gt; data. So, when we take a view from the ndarray, we return a new ndarray, of the same class, that points to the data in the original.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eb79b94dc729ec0da33bab5d4cd377a2401e89f0" translate="yes" xml:space="preserve">
          <source>The smaller object to check.</source>
          <target state="translated">Меньший объект для проверки.</target>
        </trans-unit>
        <trans-unit id="c2b26e02affe13f7769ad145c9ef05f90265c054" translate="yes" xml:space="preserve">
          <source>The smallest positive power of the base (2) that causes overflow.</source>
          <target state="translated">Наименьшая положительная мощность основания (2),вызывающая переполнение.</target>
        </trans-unit>
        <trans-unit id="52e11ee8daa6593b3d750ee5dc32dda2fcbf193b" translate="yes" xml:space="preserve">
          <source>The smallest positive usable number. Type of &lt;code&gt;tiny&lt;/code&gt; is an appropriate floating point type.</source>
          <target state="translated">Наименьшее положительное полезное число. Тип &lt;code&gt;tiny&lt;/code&gt; - подходящий тип с плавающей запятой.</target>
        </trans-unit>
        <trans-unit id="af2a8dd9510ac11ca6b963d4ee773dcefbea79aa" translate="yes" xml:space="preserve">
          <source>The smallest representable number, typically &lt;code&gt;-max&lt;/code&gt;.</source>
          <target state="translated">Наименьшее представимое число, обычно &lt;code&gt;-max&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a159db5ccf6a60aac5543438bfb54acff104da1e" translate="yes" xml:space="preserve">
          <source>The smallest representable positive number such that &lt;code&gt;1.0 + eps != 1.0&lt;/code&gt;. Type of &lt;code&gt;eps&lt;/code&gt; is an appropriate floating point type.</source>
          <target state="translated">Наименьшее представимое положительное число такое, что &lt;code&gt;1.0 + eps != 1.0&lt;/code&gt; . Тип &lt;code&gt;eps&lt;/code&gt; - подходящий тип с плавающей запятой.</target>
        </trans-unit>
        <trans-unit id="d9321ebdb39683114ce6992ea6b9cc620e5ef480" translate="yes" xml:space="preserve">
          <source>The smallest representable positive number such that &lt;code&gt;1.0 - epsneg != 1.0&lt;/code&gt;.</source>
          <target state="translated">Наименьшее представимое положительное число такое, что &lt;code&gt;1.0 - epsneg != 1.0&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="528bc510a2ddc52e9f705a28a08910ff17c4b364" translate="yes" xml:space="preserve">
          <source>The smart way</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fdf4e6a27441f2bc059f1e2263f51d77fbf6e55a" translate="yes" xml:space="preserve">
          <source>The so-called F2PY directives allow using F2PY signature file constructs also in Fortran 77/90 source codes. With this feature you can skip (almost) completely intermediate signature file generations and apply F2PY directly to Fortran source codes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fff36344b5ce01b9f9447846bf8f8d0ca8bf20cf" translate="yes" xml:space="preserve">
          <source>The solution is the coefficients of the Chebyshev series &lt;code&gt;p&lt;/code&gt; that minimizes the sum of the weighted squared errors</source>
          <target state="translated">Решением являются коэффициенты ряда Чебышева &lt;code&gt;p&lt;/code&gt; , который минимизирует сумму взвешенных квадратов ошибок</target>
        </trans-unit>
        <trans-unit id="d7b342b5e308288dae8bce1f9ff3a83bc7ae73a3" translate="yes" xml:space="preserve">
          <source>The solution is the coefficients of the Hermite series &lt;code&gt;p&lt;/code&gt; that minimizes the sum of the weighted squared errors</source>
          <target state="translated">Решением являются коэффициенты ряда Эрмита &lt;code&gt;p&lt;/code&gt; , который минимизирует сумму взвешенных квадратов ошибок</target>
        </trans-unit>
        <trans-unit id="e858f502931c190b84210ff73e4892a2231f8dea" translate="yes" xml:space="preserve">
          <source>The solution is the coefficients of the HermiteE series &lt;code&gt;p&lt;/code&gt; that minimizes the sum of the weighted squared errors</source>
          <target state="translated">Решением являются коэффициенты ряда Эрмита &lt;code&gt;p&lt;/code&gt; , который минимизирует сумму взвешенных квадратов ошибок.</target>
        </trans-unit>
        <trans-unit id="cac2b42634eddb5565b046dffc57149ff94fb5e5" translate="yes" xml:space="preserve">
          <source>The solution is the coefficients of the Laguerre series &lt;code&gt;p&lt;/code&gt; that minimizes the sum of the weighted squared errors</source>
          <target state="translated">Решением являются коэффициенты ряда Лагерра &lt;code&gt;p&lt;/code&gt; , который минимизирует сумму взвешенных квадратов ошибок</target>
        </trans-unit>
        <trans-unit id="acc0f8a9120be725868622995211f9656fc88e64" translate="yes" xml:space="preserve">
          <source>The solution is the coefficients of the Legendre series &lt;code&gt;p&lt;/code&gt; that minimizes the sum of the weighted squared errors</source>
          <target state="translated">Решением являются коэффициенты ряда Лежандра &lt;code&gt;p&lt;/code&gt; , который минимизирует сумму взвешенных квадратов ошибок</target>
        </trans-unit>
        <trans-unit id="132408df155a153e982d44f873f2076aed312f9a" translate="yes" xml:space="preserve">
          <source>The solution is the coefficients of the polynomial &lt;code&gt;p&lt;/code&gt; that minimizes the sum of the weighted squared errors</source>
          <target state="translated">Решение - это коэффициенты полинома &lt;code&gt;p&lt;/code&gt; , который минимизирует сумму взвешенных квадратов ошибок</target>
        </trans-unit>
        <trans-unit id="727489824facdfd8e793d7820b6d48d439e20ed1" translate="yes" xml:space="preserve">
          <source>The solution minimizes the squared error</source>
          <target state="translated">Решение минимизирует квадратную ошибку</target>
        </trans-unit>
        <trans-unit id="905babbec7af7dc86acc47da182cc43822ce2de5" translate="yes" xml:space="preserve">
          <source>The solution will be to either:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ea7110277074b52a752297c7e2a8351687eb1a36" translate="yes" xml:space="preserve">
          <source>The solutions are computed using LAPACK routine &lt;code&gt;_gesv&lt;/code&gt;.</source>
          <target state="translated">Решения вычисляются с использованием подпрограммы LAPACK &lt;code&gt;_gesv&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2324f65c28650d2bb749a64e0d6878a8a423096e" translate="yes" xml:space="preserve">
          <source>The sort order for complex numbers is lexicographic. If both the real and imaginary parts are non-nan then the order is determined by the real parts except when they are equal, in which case the order is determined by the imaginary parts.</source>
          <target state="translated">Порядок сортировки комплексных чисел лексикографический.Если и вещественная,и мнимая части не являются таковыми,то порядок определяется вещественными частями,за исключением случаев,когда они равны,и в этом случае порядок определяется мнимая часть.</target>
        </trans-unit>
        <trans-unit id="94fa27637cf0004fe36c14f580e547f6911b6110" translate="yes" xml:space="preserve">
          <source>The sorted unique values.</source>
          <target state="translated">Сортированные уникальные значения.</target>
        </trans-unit>
        <trans-unit id="c380c0b74f7e3ca7cbe5b2bb1b45003f6fb70837" translate="yes" xml:space="preserve">
          <source>The sorting algorithm used.</source>
          <target state="translated">Использован алгоритм сортировки.</target>
        </trans-unit>
        <trans-unit id="e03d33ebb9f3232a066dd4b0991b32cb56211358" translate="yes" xml:space="preserve">
          <source>The source and destination arrays during assignment.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2132b1a1146e5e5ced071e842080bf9a009b6944" translate="yes" xml:space="preserve">
          <source>The source array.</source>
          <target state="translated">Массив источников.</target>
        </trans-unit>
        <trans-unit id="f3a4e63ab5a7b2b3732df5942d36a724d124f0ea" translate="yes" xml:space="preserve">
          <source>The source code is only returned for objects written in Python.</source>
          <target state="translated">Исходный код возвращается только для объектов,написанных на Python.</target>
        </trans-unit>
        <trans-unit id="cf16b74745b78ed96effaeceb909805fb279ce98" translate="yes" xml:space="preserve">
          <source>The source code is only returned for objects written in Python. Many functions and classes are defined in C and will therefore not return useful information.</source>
          <target state="translated">Исходный код возвращается только для объектов,написанных на Python.Многие функции и классы определены в C и поэтому не будут возвращать полезную информацию.</target>
        </trans-unit>
        <trans-unit id="809a1cfd22069f38c46105c92eebf5c576bb4207" translate="yes" xml:space="preserve">
          <source>The source string can be any valid Fortran code. If you want to save the extension-module source code then a suitable file-name can be provided by the &lt;code&gt;source_fn&lt;/code&gt; keyword to the compile function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cd5904ef77ea8bffca88dd379e736043b3ab2537" translate="yes" xml:space="preserve">
          <source>The spacing between sample points when &lt;code&gt;x&lt;/code&gt; is None. The default is 1.</source>
          <target state="translated">Расстояние между точками выборки, когда &lt;code&gt;x&lt;/code&gt; равно None. По умолчанию 1.</target>
        </trans-unit>
        <trans-unit id="f3c0291e43c18442ce997268f6d827c51450c140" translate="yes" xml:space="preserve">
          <source>The spacing of values of &lt;code&gt;x&lt;/code&gt;. This is a scalar if &lt;code&gt;x&lt;/code&gt; is a scalar.</source>
          <target state="translated">Расстояние между значениями &lt;code&gt;x&lt;/code&gt; . Это скаляр, если &lt;code&gt;x&lt;/code&gt; - скаляр.</target>
        </trans-unit>
        <trans-unit id="90f7163cd42de5312873857f6e49d754d0181393" translate="yes" xml:space="preserve">
          <source>The specific algorithm used is as follows.</source>
          <target state="translated">Используемый конкретный алгоритм выглядит следующим образом.</target>
        </trans-unit>
        <trans-unit id="87dcde88b185fa2a9572c4ddf0c6760b6d6e72a4" translate="yes" xml:space="preserve">
          <source>The specified line is given by &lt;code&gt;off + scl*x&lt;/code&gt;.</source>
          <target state="translated">Указанная строка отображается как &lt;code&gt;off + scl*x&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6ffe340425612aa0e424be1bcdd9b7a397555dd0" translate="yes" xml:space="preserve">
          <source>The stacked array has one more dimension than the input arrays.</source>
          <target state="translated">Стековый массив имеет на одно измерение больше,чем входные массивы.</target>
        </trans-unit>
        <trans-unit id="b5df163136221ee565809e31a5ec5ce477690b37" translate="yes" xml:space="preserve">
          <source>The standard array can have 24 different data types (and has some support for adding your own types). These data types all have an enumerated type, an enumerated type-character, and a corresponding array scalar Python type object (placed in a hierarchy). There are also standard C typedefs to make it easier to manipulate elements of the given data type. For the numeric types, there are also bit-width equivalent C typedefs and named typenumbers that make it easier to select the precision desired.</source>
          <target state="translated">Стандартный массив может иметь 24 различных типа данных (и имеет некоторую поддержку добавления собственных типов).Все эти типы данных имеют перечисляемый тип,перечисляемый тип-символ и соответствующий массиву скалярный объект типа Python (помещенный в иерархию).Также существуют стандартные типы C,которые облегчают работу с элементами данного типа данных.Для числовых типов существуют также битовые эквиваленты типов C и именованные типовые номера,которые облегчают выбор нужной точности.</target>
        </trans-unit>
        <trans-unit id="45b18b5cfbbed3fbae9c681cc6f3c1fa70483591" translate="yes" xml:space="preserve">
          <source>The standard casting rules ensure that a scalar cannot up-cast an array unless the scalar is of a fundamentally different kind of data (i.e. under a different hierarchy in the data type hierarchy) then the array:</source>
          <target state="translated">Стандартные правила кастинга гарантируют,что скаляр не сможет выставить массив вверх,если только скаляр не имеет принципиально другого типа данных (т.е.находится в другой иерархии в иерархии типов данных),чем массив:</target>
        </trans-unit>
        <trans-unit id="3b087bfb5ae783fa5041fbcb80716e85b4cfcd9d" translate="yes" xml:space="preserve">
          <source>The standard deviation is the square root of the average of the squared deviations from the mean, i.e., &lt;code&gt;std = sqrt(mean(abs(x - x.mean())**2))&lt;/code&gt;.</source>
          <target state="translated">Стандартное отклонение - это квадратный корень из среднего квадрата отклонений от среднего, т. &lt;code&gt;std = sqrt(mean(abs(x - x.mean())**2))&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3f057ac9f65af78fe632de7c8031e6f6e2ae80dc" translate="yes" xml:space="preserve">
          <source>The standard deviation is the square root of the average of the squared deviations from the mean: &lt;code&gt;std = sqrt(mean(abs(x - x.mean())**2))&lt;/code&gt;.</source>
          <target state="translated">Стандартное отклонение - это квадратный корень из среднего квадрата отклонений от среднего: &lt;code&gt;std = sqrt(mean(abs(x - x.mean())**2))&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9194bef8dfee2642aab9789d8b2c457a98f783af" translate="yes" xml:space="preserve">
          <source>The standard rules of sequence slicing apply to basic slicing on a per-dimension basis (including using a step index). Some useful concepts to remember include:</source>
          <target state="translated">Стандартные правила последовательного нарезки применяются к базовому нарезке на размерную основу (в том числе с использованием индекса шага).Некоторые полезные концепции,которые следует запомнить,включают в себя:</target>
        </trans-unit>
        <trans-unit id="903735d28aa358318c996f0fbe6f9bd887af58b8" translate="yes" xml:space="preserve">
          <source>The start of the data within the data buffer (an offset relative to the beginning of the data buffer).</source>
          <target state="translated">Начало данных в буфере данных (смещение относительно начала буфера данных).</target>
        </trans-unit>
        <trans-unit id="df2af17caf9f66a81db3bc6a51eb1b52d78258be" translate="yes" xml:space="preserve">
          <source>The start of type numbers used for Custom Data types.</source>
          <target state="translated">Начало номеров типов,используемых для пользовательских типов данных.</target>
        </trans-unit>
        <trans-unit id="e63c738294e147bc42d8454a2cacbd481d845725" translate="yes" xml:space="preserve">
          <source>The starting value for this product. See &lt;a href=&quot;numpy.ufunc.reduce#numpy.ufunc.reduce&quot;&gt;&lt;code&gt;reduce&lt;/code&gt;&lt;/a&gt; for details.</source>
          <target state="translated">Начальное значение для этого продукта. Подробнее см. &lt;a href=&quot;numpy.ufunc.reduce#numpy.ufunc.reduce&quot;&gt; &lt;code&gt;reduce&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="b49e967087e1769cf1a280ea97d2d8fd93d40ef9" translate="yes" xml:space="preserve">
          <source>The starting value of the sequence.</source>
          <target state="translated">Начальное значение последовательности.</target>
        </trans-unit>
        <trans-unit id="be3a2f4f7af9d19db4503332628441741d474403" translate="yes" xml:space="preserve">
          <source>The state of the returned big generator is jumped as-if 2**(128 * jumps) random numbers have been generated.</source>
          <target state="translated">Состояние возвращаемого большого генератора перепрыгивает as-if 2**(128 *прыжки)были сгенерированы случайные числа.</target>
        </trans-unit>
        <trans-unit id="9f0543dedf6d1409b4f87e0823027e644cab05a9" translate="yes" xml:space="preserve">
          <source>The step size is phi-1 when multiplied by 2**128 where phi is the golden ratio.</source>
          <target state="translated">Размер шага-фи-1 при умножении на 2**128,где фи-золотое сечение.</target>
        </trans-unit>
        <trans-unit id="ed6404a00884e4a1c814b4fe32b4f8e4142164f0" translate="yes" xml:space="preserve">
          <source>The steps are:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="da99252ecc9a954c9ea523c42dd589060111b276" translate="yes" xml:space="preserve">
          <source>The strides of the array. How many bytes needed to jump to the next element in each dimension.</source>
          <target state="translated">Шаги массива.Сколько байт нужно для перехода к следующему элементу в каждом измерении.</target>
        </trans-unit>
        <trans-unit id="6bea4f23f51bf1c5c1b134b3c31652eb62271512" translate="yes" xml:space="preserve">
          <source>The strides of the new array. Defaults to &lt;code&gt;x.strides&lt;/code&gt;.</source>
          <target state="translated">Успехи нового массива. По умолчанию &lt;code&gt;x.strides&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0e7d4c32101a82d4a575c51fa47c579d84a90ccb" translate="yes" xml:space="preserve">
          <source>The string character corresponding to the scalar type.</source>
          <target state="translated">Символ строки,соответствующий скалярному типу.</target>
        </trans-unit>
        <trans-unit id="280cdfd9e5006321af13d97ed1dea840dc6157dc" translate="yes" xml:space="preserve">
          <source>The string representation of a structured datatype is shown in the &amp;ldquo;list of tuples&amp;rdquo; form if possible, otherwise numpy falls back to using the more general dictionary form.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="56e3689374848f3f51b64947b16bec4c3ea61c9e" translate="yes" xml:space="preserve">
          <source>The string representation of an array.</source>
          <target state="translated">Строковое представление массива.</target>
        </trans-unit>
        <trans-unit id="3e6678ed1379ae4a29d74cf130ddd533a3d54faa" translate="yes" xml:space="preserve">
          <source>The string representation of the floating point value</source>
          <target state="translated">Строковое представление значения с плавающей точкой</target>
        </trans-unit>
        <trans-unit id="a73fe28c8757ab0f0da0e2f4243de7dc56a5b482" translate="yes" xml:space="preserve">
          <source>The string separating numbers in the data; extra whitespace between elements is also ignored.</source>
          <target state="translated">Строка,разделяющая номера в данных;дополнительные пробелы между элементами также игнорируются.</target>
        </trans-unit>
        <trans-unit id="3dd7799be74e76e0df59b70e60e88893f1e79944" translate="yes" xml:space="preserve">
          <source>The string to load.</source>
          <target state="translated">Строка для загрузки.</target>
        </trans-unit>
        <trans-unit id="fe1a3737165141949913fff90aaf8e13cf8c53af" translate="yes" xml:space="preserve">
          <source>The string to test for equality against the expected string.</source>
          <target state="translated">Строка для проверки равенства с ожидаемой строкой.</target>
        </trans-unit>
        <trans-unit id="abd4042bc9b171ded494b956ae5b9d9577f995c1" translate="yes" xml:space="preserve">
          <source>The string used to separate values. By default, any consecutive whitespaces act as delimiter. An integer or sequence of integers can also be provided as width(s) of each field.</source>
          <target state="translated">Строка,используемая для разделения значений.По умолчанию,любые последовательные белые пробела выступают в качестве разделителя.В качестве ширины (ширины)каждого поля может быть также указано целое число или последовательность целых чисел.</target>
        </trans-unit>
        <trans-unit id="af52fb130d33fe69945cefb6f52e5cf4ca3f8766" translate="yes" xml:space="preserve">
          <source>The string used to separate values. For backwards compatibility, byte strings will be decoded as &amp;lsquo;latin1&amp;rsquo;. The default is whitespace.</source>
          <target state="translated">Строка, используемая для разделения значений. Для обратной совместимости байтовые строки будут декодироваться как latin1. По умолчанию используется пробел.</target>
        </trans-unit>
        <trans-unit id="9d54c543599ad13e3bb6b6bb26859ee068b06992" translate="yes" xml:space="preserve">
          <source>The strings produced by the Python float.hex method can be used as input for floats.</source>
          <target state="translated">Строки,созданные методом Python float.hex,могут быть использованы в качестве входных данных для флотов.</target>
        </trans-unit>
        <trans-unit id="4e980753b02b50913c2b5e0d5a5fa0dd49eac85d" translate="yes" xml:space="preserve">
          <source>The structured dtype of the output array</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="05daa592464e6166b985d1ccf981f505cab14119" translate="yes" xml:space="preserve">
          <source>The sub-arrays whose main diagonals we just obtained; note that each corresponds to fixing the right-most (column) axis, and that the diagonals are &amp;ldquo;packed&amp;rdquo; in rows.</source>
          <target state="translated">Подмассивы, главные диагонали которых мы только что получили; обратите внимание, что каждый соответствует фиксации самой правой оси (столбца), и что диагонали &amp;laquo;упакованы&amp;raquo; в строки.</target>
        </trans-unit>
        <trans-unit id="032fe52a10dbbb96d8d2155ebf017c5a37d540fb" translate="yes" xml:space="preserve">
          <source>The sub-diagonal at and below which the array is filled. &lt;code&gt;k&lt;/code&gt; = 0 is the main diagonal, while &lt;code&gt;k&lt;/code&gt; &amp;lt; 0 is below it, and &lt;code&gt;k&lt;/code&gt; &amp;gt; 0 is above. The default is 0.</source>
          <target state="translated">Поддиагональ, на которой и ниже которой заполняется массив. &lt;code&gt;k&lt;/code&gt; = 0 - главная диагональ, при этом &lt;code&gt;k&lt;/code&gt; &amp;lt;0 ниже нее, а &lt;code&gt;k&lt;/code&gt; &amp;gt; 0 сверху. По умолчанию - 0.</target>
        </trans-unit>
        <trans-unit id="8e6c361139d8c7c0ac565e0bf2e23b72d7fed91d" translate="yes" xml:space="preserve">
          <source>The subarrays &lt;code&gt;grid[k]&lt;/code&gt; contains the N-D array of indices along the &lt;code&gt;k-th&lt;/code&gt; axis. Explicitly:</source>
          <target state="translated">Подмассивы &lt;code&gt;grid[k]&lt;/code&gt; содержат ND-массив индексов по &lt;code&gt;k-th&lt;/code&gt; оси. Ясно:</target>
        </trans-unit>
        <trans-unit id="c73621fe8c8d7b0663f28b8d7e7772440297f53c" translate="yes" xml:space="preserve">
          <source>The subscripts string is a comma-separated list of subscript labels, where each label refers to a dimension of the corresponding operand. Whenever a label is repeated it is summed, so &lt;code&gt;np.einsum('i,i', a, b)&lt;/code&gt; is equivalent to &lt;a href=&quot;numpy.inner#numpy.inner&quot;&gt;&lt;code&gt;np.inner(a,b)&lt;/code&gt;&lt;/a&gt;. If a label appears only once, it is not summed, so &lt;code&gt;np.einsum('i', a)&lt;/code&gt; produces a view of &lt;code&gt;a&lt;/code&gt; with no changes. A further example &lt;code&gt;np.einsum('ij,jk', a, b)&lt;/code&gt; describes traditional matrix multiplication and is equivalent to &lt;a href=&quot;numpy.matmul#numpy.matmul&quot;&gt;&lt;code&gt;np.matmul(a,b)&lt;/code&gt;&lt;/a&gt;. Repeated subscript labels in one operand take the diagonal. For example, &lt;code&gt;np.einsum('ii', a)&lt;/code&gt; is equivalent to &lt;a href=&quot;numpy.trace#numpy.trace&quot;&gt;&lt;code&gt;np.trace(a)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Строка нижних индексов представляет собой список разделенных запятыми меток нижних индексов, где каждая метка относится к измерению соответствующего операнда. Каждый раз, когда метка повторяется, она суммируется, поэтому &lt;code&gt;np.einsum('i,i', a, b)&lt;/code&gt; эквивалентно &lt;a href=&quot;numpy.inner#numpy.inner&quot;&gt; &lt;code&gt;np.inner(a,b)&lt;/code&gt; &lt;/a&gt; . Если метка появляется только один раз, она не суммируется, поэтому &lt;code&gt;np.einsum('i', a)&lt;/code&gt; создает представление &lt;code&gt;a&lt;/code&gt; без изменений. Еще один пример &lt;code&gt;np.einsum('ij,jk', a, b)&lt;/code&gt; описывает традиционное матричное умножение и эквивалентен &lt;a href=&quot;numpy.matmul#numpy.matmul&quot;&gt; &lt;code&gt;np.matmul(a,b)&lt;/code&gt; &lt;/a&gt; . Повторяющиеся подстрочные метки в одном операнде занимают диагональ. Например, &lt;code&gt;np.einsum('ii', a)&lt;/code&gt; эквивалентно &lt;a href=&quot;numpy.trace#numpy.trace&quot;&gt; &lt;code&gt;np.trace(a)&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="67e5fbff128f593f5baf173c69fe839b3262add2" translate="yes" xml:space="preserve">
          <source>The substring to search for.</source>
          <target state="translated">Подстрока для поиска.</target>
        </trans-unit>
        <trans-unit id="965c999c4a333ea7538f32117fa173b48c1340d4" translate="yes" xml:space="preserve">
          <source>The sum of &lt;code&gt;x1&lt;/code&gt; and &lt;code&gt;x2&lt;/code&gt;, element-wise. This is a scalar if both &lt;code&gt;x1&lt;/code&gt; and &lt;code&gt;x2&lt;/code&gt; are scalars.</source>
          <target state="translated">Сумма &lt;code&gt;x1&lt;/code&gt; и &lt;code&gt;x2&lt;/code&gt; поэлементно. Это скаляр, если и &lt;code&gt;x1&lt;/code&gt; , и &lt;code&gt;x2&lt;/code&gt; являются скалярами.</target>
        </trans-unit>
        <trans-unit id="6ad40e475222ea9afc0452e8c7fd45129517c8c0" translate="yes" xml:space="preserve">
          <source>The sum of an empty array is the neutral element 0:</source>
          <target state="translated">Суммой пустого массива является нейтральный элемент 0:</target>
        </trans-unit>
        <trans-unit id="d51acbb68e0ec9e47200775b381bf1325a23c32a" translate="yes" xml:space="preserve">
          <source>The sum of the inputs. If either input is a poly1d object, then the output is also a poly1d object. Otherwise, it is a 1D array of polynomial coefficients from highest to lowest degree.</source>
          <target state="translated">Сумма входов.Если любой из входов является объектом poly1d,то выход также является объектом poly1d.В противном случае это 1D массив полиномиальных коэффициентов от высшей до низшей степени.</target>
        </trans-unit>
        <trans-unit id="a83a6a324c47c50fcc7b05d36f9de3513626990f" translate="yes" xml:space="preserve">
          <source>The suppression behavior is selected with the &lt;code&gt;axis&lt;/code&gt; parameter.</source>
          <target state="translated">Режим подавления выбирается с помощью параметра &lt;code&gt;axis&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ac5e9039faffaa312745861609180dbee345923d" translate="yes" xml:space="preserve">
          <source>The symbol suffix avoids the symbol name clashes between 32-bit and 64-bit BLAS/LAPACK libraries.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d22d2ca3e9d62707042d4e5eab8a754482cb7bf9" translate="yes" xml:space="preserve">
          <source>The syntax of signature files is presented below.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dc008fb51ab0096c0ab2810136d6a94b39d8b6ae" translate="yes" xml:space="preserve">
          <source>The syntax specification for signature files (.pyf files) is borrowed from the Fortran 90/95 language specification. Almost all Fortran 90/95 standard constructs are understood, both in free and fixed format (recall that Fortran 77 is a subset of Fortran 90/95). F2PY introduces also some extensions to Fortran 90/95 language specification that help designing Fortran to Python interface, make it more &amp;ldquo;Pythonic&amp;rdquo;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4cac57b443c7e139444cef039c708d06cc974fbe" translate="yes" xml:space="preserve">
          <source>The t test is based on an assumption that the data come from a Normal distribution. The t test provides a way to test whether the sample mean (that is the mean calculated from the data) is a good estimate of the true mean.</source>
          <target state="translated">Тест t основан на предположении,что данные поступают из Нормального распределения.Тест t предоставляет способ проверить,является ли среднее значение выборки (т.е.среднее,вычисленное по данным)хорошей оценкой истинного среднего.</target>
        </trans-unit>
        <trans-unit id="9a7fcb5dad38e6ecd0517ba513e487ccaccafb31" translate="yes" xml:space="preserve">
          <source>The table below gives rough equivalents for some common MATLAB&amp;reg; expressions. &lt;strong&gt;These are not exact equivalents&lt;/strong&gt;, but rather should be taken as hints to get you going in the right direction. For more detail read the built-in documentation on the NumPy functions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1feedf873323b1df0d515f29065f1cceac91a5f6" translate="yes" xml:space="preserve">
          <source>The template language blocks are delimited by &lt;code&gt;/**begin repeat&lt;/code&gt; and &lt;code&gt;/**end repeat**/&lt;/code&gt; lines, which may also be nested using consecutively numbered delimiting lines such as &lt;code&gt;/**begin repeat1&lt;/code&gt; and &lt;code&gt;/**end repeat1**/&lt;/code&gt;:</source>
          <target state="translated">Блоки языка шаблона разделены строками &lt;code&gt;/**begin repeat&lt;/code&gt; и &lt;code&gt;/**end repeat**/&lt;/code&gt; , которые также могут быть вложены с использованием последовательно пронумерованных разделяющих строк, таких как &lt;code&gt;/**begin repeat1&lt;/code&gt; и &lt;code&gt;/**end repeat1**/&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="2a419cbcd05b123b547d845ae2a3bfd3fd96fc50" translate="yes" xml:space="preserve">
          <source>The tensor dot product of the input.</source>
          <target state="translated">Тензорная точка входа.</target>
        </trans-unit>
        <trans-unit id="babafa633a1d5ffe1e85308352efa2b576e666e1" translate="yes" xml:space="preserve">
          <source>The term broadcasting describes how numpy treats arrays with different shapes during arithmetic operations. Subject to certain constraints, the smaller array is &amp;ldquo;broadcast&amp;rdquo; across the larger array so that they have compatible shapes. Broadcasting provides a means of vectorizing array operations so that looping occurs in C instead of Python. It does this without making needless copies of data and usually leads to efficient algorithm implementations. There are, however, cases where broadcasting is a bad idea because it leads to inefficient use of memory that slows computation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0567674780e936db24c51c4154cb1e7bb19a5fb1" translate="yes" xml:space="preserve">
          <source>The test can also be inverted:</source>
          <target state="translated">Тест также может быть инвертирован:</target>
        </trans-unit>
        <trans-unit id="a043640318788c216d9c35c72474b86e64a58875" translate="yes" xml:space="preserve">
          <source>The test is equivalent to &lt;code&gt;allclose(actual, desired, rtol, atol)&lt;/code&gt; (note that &lt;code&gt;allclose&lt;/code&gt; has different default values). It compares the difference between &lt;code&gt;actual&lt;/code&gt; and &lt;code&gt;desired&lt;/code&gt; to &lt;code&gt;atol + rtol * abs(desired)&lt;/code&gt;.</source>
          <target state="translated">Тест эквивалентен &lt;code&gt;allclose(actual, desired, rtol, atol)&lt;/code&gt; (обратите внимание, что &lt;code&gt;allclose&lt;/code&gt; имеет разные значения по умолчанию). Он сравнивает разницу между &lt;code&gt;actual&lt;/code&gt; и &lt;code&gt;desired&lt;/code&gt; с &lt;code&gt;atol + rtol * abs(desired)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d949a99e166ed49b879032942f22bd239ac73b6e" translate="yes" xml:space="preserve">
          <source>The test is marked as skipped if &lt;code&gt;SkipMyTest&lt;/code&gt; evaluates to nonzero, and the message in verbose test output is the second argument given to &lt;code&gt;skipif&lt;/code&gt;. Similarly, a test can be marked as a known failure by using &lt;code&gt;xfail&lt;/code&gt;:</source>
          <target state="translated">Тест помечается как пропущенный, если &lt;code&gt;SkipMyTest&lt;/code&gt; имеет ненулевое значение, а сообщение в подробных выходных данных теста является вторым аргументом, передаваемым &lt;code&gt;skipif&lt;/code&gt; . Точно так же тест может быть отмечен как известный сбой с помощью &lt;code&gt;xfail&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="85bd6917449fe181340a2938e0dac494fbfea5fe" translate="yes" xml:space="preserve">
          <source>The test method may take two or more arguments; the first, &lt;code&gt;label&lt;/code&gt; is a string specifying what should be tested and the second, &lt;code&gt;verbose&lt;/code&gt; is an integer giving the level of output verbosity. See the docstring for numpy.test for details. The default value for &lt;code&gt;label&lt;/code&gt; is &amp;lsquo;fast&amp;rsquo; - which will run the standard tests. The string &amp;lsquo;full&amp;rsquo; will run the full battery of tests, including those identified as being slow to run. If &lt;code&gt;verbose&lt;/code&gt; is 1 or less, the tests will just show information messages about the tests that are run; but if it is greater than 1, then the tests will also provide warnings on missing tests. So if you want to run every test and get messages about which modules don&amp;rsquo;t have tests:</source>
          <target state="translated">Метод тестирования может принимать два или более аргумента; первая &lt;code&gt;label&lt;/code&gt; - это строка, определяющая, что следует тестировать, а вторая, &lt;code&gt;verbose&lt;/code&gt; - целое число, дающее уровень детализации вывода. Подробнее см. В строке документации numpy.test. По умолчанию для &lt;code&gt;label&lt;/code&gt; установлено значение &amp;laquo;быстро&amp;raquo;, что позволяет запускать стандартные тесты. Строка full будет запускать полную батарею тестов, включая те, которые определены как медленно выполняемые. Если &lt;code&gt;verbose&lt;/code&gt; - 1 или меньше, тесты будут просто отображать информационные сообщения о запущенных тестах; но если он больше 1, тогда тесты также будут выдавать предупреждения об отсутствующих тестах. Итак, если вы хотите запускать каждый тест и получать сообщения о том, какие модули не имеют тестов:</target>
        </trans-unit>
        <trans-unit id="03733f354e779af14d028cdbdf0476c16657d14e" translate="yes" xml:space="preserve">
          <source>The test to label as slow.</source>
          <target state="translated">Тест для маркировки как медленный.</target>
        </trans-unit>
        <trans-unit id="28bda9f13cb5fd35de4d1871d5d1a6b158a05b66" translate="yes" xml:space="preserve">
          <source>The test verifies identical shapes and that the elements of &lt;code&gt;actual&lt;/code&gt; and &lt;code&gt;desired&lt;/code&gt; satisfy.</source>
          <target state="translated">Тест проверяет идентичность форм и соответствие &lt;code&gt;actual&lt;/code&gt; и &lt;code&gt;desired&lt;/code&gt; элементов .</target>
        </trans-unit>
        <trans-unit id="a7fabe2aaa71feebc60270bd4d75ad9164f05bed" translate="yes" xml:space="preserve">
          <source>The test verifies that the elements of &lt;code&gt;actual&lt;/code&gt; and &lt;code&gt;desired&lt;/code&gt; satisfy.</source>
          <target state="translated">Тест подтверждает, что элементы &lt;code&gt;actual&lt;/code&gt; и &lt;code&gt;desired&lt;/code&gt; удовлетворяют.</target>
        </trans-unit>
        <trans-unit id="bf9247f40709953bae5128ab011a3c6a23e1bb6b" translate="yes" xml:space="preserve">
          <source>The three dimensional series is evaluated at the points &lt;code&gt;(x, y, z)&lt;/code&gt;, where &lt;code&gt;x&lt;/code&gt;, &lt;code&gt;y&lt;/code&gt;, and &lt;code&gt;z&lt;/code&gt; must have the same shape. If any of &lt;code&gt;x&lt;/code&gt;, &lt;code&gt;y&lt;/code&gt;, or &lt;code&gt;z&lt;/code&gt; is a list or tuple, it is first converted to an ndarray, otherwise it is left unchanged and if it isn&amp;rsquo;t an ndarray it is treated as a scalar.</source>
          <target state="translated">Трехмерный ряд оценивается в точках &lt;code&gt;(x, y, z)&lt;/code&gt; , где &lt;code&gt;x&lt;/code&gt; , &lt;code&gt;y&lt;/code&gt; и &lt;code&gt;z&lt;/code&gt; должны иметь одинаковую форму. Если какой-либо из &lt;code&gt;x&lt;/code&gt; , &lt;code&gt;y&lt;/code&gt; или &lt;code&gt;z&lt;/code&gt; является списком или кортежем, он сначала преобразуется в ndarray, в противном случае он остается неизменным, и если это не ndarray, он рассматривается как скаляр.</target>
        </trans-unit>
        <trans-unit id="ababec7c614f8cc809a5f4b9df993b70ee13a8f8" translate="yes" xml:space="preserve">
          <source>The three dimensional series is evaluated at the points in the Cartesian product of &lt;code&gt;x&lt;/code&gt;, &lt;code&gt;y&lt;/code&gt;, and &lt;code&gt;z&lt;/code&gt;. If &lt;code&gt;x&lt;/code&gt;,`y`, or &lt;code&gt;z&lt;/code&gt; is a list or tuple, it is first converted to an ndarray, otherwise it is left unchanged and, if it isn&amp;rsquo;t an ndarray, it is treated as a scalar.</source>
          <target state="translated">Трехмерный ряд оценивается в точках декартового произведения &lt;code&gt;x&lt;/code&gt; , &lt;code&gt;y&lt;/code&gt; и &lt;code&gt;z&lt;/code&gt; . Если &lt;code&gt;x&lt;/code&gt; , `y` или &lt;code&gt;z&lt;/code&gt; - это список или кортеж, он сначала преобразуется в ndarray, в противном случае он остается неизменным и, если это не ndarray, он рассматривается как скаляр.</target>
        </trans-unit>
        <trans-unit id="3f792b485609224acbb4d7367551edb56b3d1d82" translate="yes" xml:space="preserve">
          <source>The three division operators are all defined; &lt;code&gt;div&lt;/code&gt; is active by default, &lt;code&gt;truediv&lt;/code&gt; is active when &lt;a href=&quot;https://docs.python.org/dev/library/__future__.html#module-__future__&quot;&gt;&lt;code&gt;__future__&lt;/code&gt;&lt;/a&gt; division is in effect.</source>
          <target state="translated">Все три оператора деления определены; &lt;code&gt;div&lt;/code&gt; активен по умолчанию, &lt;code&gt;truediv&lt;/code&gt; активен, когда &lt;a href=&quot;https://docs.python.org/dev/library/__future__.html#module-__future__&quot;&gt; &lt;code&gt;__future__&lt;/code&gt; &lt;/a&gt; деление __future__ .</target>
        </trans-unit>
        <trans-unit id="6953aff01d51815d13e09f72484f920fa7369db2" translate="yes" xml:space="preserve">
          <source>The thresholds above deal with floating point roundoff error in the calculation of the SVD. However, you may have more information about the sources of error in &lt;code&gt;M&lt;/code&gt; that would make you consider other tolerance values to detect &lt;em&gt;effective&lt;/em&gt; rank deficiency. The most useful measure of the tolerance depends on the operations you intend to use on your matrix. For example, if your data come from uncertain measurements with uncertainties greater than floating point epsilon, choosing a tolerance near that uncertainty may be preferable. The tolerance may be absolute if the uncertainties are absolute rather than relative.</source>
          <target state="translated">Вышеуказанные пороговые значения относятся к ошибке округления с плавающей запятой при вычислении SVD. Однако у вас может быть больше информации об источниках ошибки в &lt;code&gt;M&lt;/code&gt; , которая заставит вас рассмотреть другие значения допуска для обнаружения &lt;em&gt;эффективного&lt;/em&gt; ранжирования. Наиболее полезная мера допуска зависит от операций, которые вы собираетесь использовать в своей матрице. Например, если ваши данные получены из неопределенных измерений с погрешностями больше, чем эпсилон с плавающей запятой, выбор допуска, близкого к этой погрешности, может быть предпочтительным. Допуск может быть абсолютным, если неопределенности являются абсолютными, а не относительными.</target>
        </trans-unit>
        <trans-unit id="64c20447e1e6f9694ec0f7bb75ec43f4f4cb6058" translate="yes" xml:space="preserve">
          <source>The tiled output array.</source>
          <target state="translated">Выходной массив с плиткой.</target>
        </trans-unit>
        <trans-unit id="8bc4b16e1cf995efdf33020e8a2b8f7760d88f9e" translate="yes" xml:space="preserve">
          <source>The time required to produce using multiple threads can be compared to the time required to generate using a single thread.</source>
          <target state="translated">Время,необходимое для производства с использованием нескольких потоков,можно сравнить со временем,необходимым для производства с использованием одного потока.</target>
        </trans-unit>
        <trans-unit id="bcdefbec5fdfd59d604b41a08eaf1010ff1f9f3b" translate="yes" xml:space="preserve">
          <source>The timings below are the time in ns to produce 1 random value from a specific distribution. The original &lt;a href=&quot;bit_generators/mt19937#numpy.random.MT19937&quot;&gt;&lt;code&gt;MT19937&lt;/code&gt;&lt;/a&gt; generator is much slower since it requires 2 32-bit values to equal the output of the faster generators.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="343a5bcbcad72b541893cb8c8e45cc7f466bba8b" translate="yes" xml:space="preserve">
          <source>The timings below are the time in ns to produce 1 random value from a specific distribution. The original &lt;a href=&quot;bit_generators/mt19937#numpy.random.mt19937.MT19937&quot;&gt;&lt;code&gt;MT19937&lt;/code&gt;&lt;/a&gt; generator is much slower since it requires 2 32-bit values to equal the output of the faster generators.</source>
          <target state="translated">Приведенные ниже тайминги - это время в нс для получения 1 случайного значения из определенного распределения. Оригинальный &lt;a href=&quot;bit_generators/mt19937#numpy.random.mt19937.MT19937&quot;&gt; &lt;code&gt;MT19937&lt;/code&gt; &lt;/a&gt; генератор гораздо медленнее , так как она требует 2 32-битных значений равно выход быстрых генераторов.</target>
        </trans-unit>
        <trans-unit id="1d2c30ac9be07be723e9ef95eaf137f9bc73af0a" translate="yes" xml:space="preserve">
          <source>The tolerance values are positive, typically very small numbers. The relative difference (&lt;code&gt;rtol&lt;/code&gt; * abs(&lt;code&gt;b&lt;/code&gt;)) and the absolute difference &lt;code&gt;atol&lt;/code&gt; are added together to compare against the absolute difference between &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt;.</source>
          <target state="translated">Значения допусков положительные, обычно очень маленькие числа. Относительная разница ( &lt;code&gt;rtol&lt;/code&gt; * abs ( &lt;code&gt;b&lt;/code&gt; )) и абсолютная разница &lt;code&gt;atol&lt;/code&gt; суммируются для сравнения с абсолютной разницей между &lt;code&gt;a&lt;/code&gt; и &lt;code&gt;b&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="52a51aeadfd53cc309968068f2e1965d359a3909" translate="yes" xml:space="preserve">
          <source>The total broadcasted size.</source>
          <target state="translated">Общий транслируемый размер.</target>
        </trans-unit>
        <trans-unit id="df3d0e81279bb92508eaea005084a0b02573f0f5" translate="yes" xml:space="preserve">
          <source>The total number of arguments (&lt;em&gt;nin&lt;/em&gt; + &lt;em&gt;nout&lt;/em&gt;). This must be less than &lt;a href=&quot;array#c.NPY_MAXARGS&quot;&gt;&lt;code&gt;NPY_MAXARGS&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1470f5efa816c498ec2cdd99dd6bc7fe2a058b68" translate="yes" xml:space="preserve">
          <source>The total number of arguments (&lt;em&gt;nin&lt;/em&gt; + &lt;em&gt;nout&lt;/em&gt;). This must be less than &lt;code&gt;NPY_MAXARGS&lt;/code&gt;.</source>
          <target state="translated">Общее количество аргументов ( &lt;em&gt;нин&lt;/em&gt; + &lt;em&gt;ноут&lt;/em&gt; ). Это должно быть меньше &lt;code&gt;NPY_MAXARGS&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="af0d1953b87871e5f5c2cfb05eba9aaf99050200" translate="yes" xml:space="preserve">
          <source>The total number of built-in NumPy types. The enumeration covers the range from 0 to NPY_NTYPES-1.</source>
          <target state="translated">Общее количество встроенных типов NumPy.Перечисление охватывает диапазон от 0 до NPY_NTYPES-1.</target>
        </trans-unit>
        <trans-unit id="abe92a5e4aa66a77153ec46749bbd30d898eb468" translate="yes" xml:space="preserve">
          <source>The total number of masked elements (axis=None) or the number of masked elements along each slice of the given axis.</source>
          <target state="translated">Общее количество замаскированных элементов (ось=Нет)или количество замаскированных элементов вдоль каждого среза данной оси.</target>
        </trans-unit>
        <trans-unit id="7423c677797c62eaba11c700e763c8330a87769e" translate="yes" xml:space="preserve">
          <source>The total payment is made up of payment against principal plus interest.</source>
          <target state="translated">Общая сумма платежа складывается из выплаты основного долга плюс проценты.</target>
        </trans-unit>
        <trans-unit id="b7226d44903c768f342634b37f3cd2cbe870d83c" translate="yes" xml:space="preserve">
          <source>The total size of the underlying array.</source>
          <target state="translated">Общий размер базового массива.</target>
        </trans-unit>
        <trans-unit id="b17ef49a2b827517f40e328c2cdae6675b6f65d6" translate="yes" xml:space="preserve">
          <source>The transform for real input is performed over the last transformation axis, as by &lt;a href=&quot;numpy.fft.rfft#numpy.fft.rfft&quot;&gt;&lt;code&gt;rfft&lt;/code&gt;&lt;/a&gt;, then the transform over the remaining axes is performed as by &lt;a href=&quot;numpy.fft.fftn#numpy.fft.fftn&quot;&gt;&lt;code&gt;fftn&lt;/code&gt;&lt;/a&gt;. The order of the output is as for &lt;a href=&quot;numpy.fft.rfft#numpy.fft.rfft&quot;&gt;&lt;code&gt;rfft&lt;/code&gt;&lt;/a&gt; for the final transformation axis, and as for &lt;a href=&quot;numpy.fft.fftn#numpy.fft.fftn&quot;&gt;&lt;code&gt;fftn&lt;/code&gt;&lt;/a&gt; for the remaining transformation axes.</source>
          <target state="translated">Преобразование для реального ввода выполняется по последней оси преобразования, как по &lt;a href=&quot;numpy.fft.rfft#numpy.fft.rfft&quot;&gt; &lt;code&gt;rfft&lt;/code&gt; &lt;/a&gt; , затем преобразование по оставшимся осям выполняется как по &lt;a href=&quot;numpy.fft.fftn#numpy.fft.fftn&quot;&gt; &lt;code&gt;fftn&lt;/code&gt; &lt;/a&gt; . Порядок вывода такой же, как для &lt;a href=&quot;numpy.fft.rfft#numpy.fft.rfft&quot;&gt; &lt;code&gt;rfft&lt;/code&gt; &lt;/a&gt; для конечной оси трансформации, и для &lt;a href=&quot;numpy.fft.fftn#numpy.fft.fftn&quot;&gt; &lt;code&gt;fftn&lt;/code&gt; &lt;/a&gt; для остальных осей трансформации.</target>
        </trans-unit>
        <trans-unit id="85975e151b66ed8086ffe0edc17f692849490b8d" translate="yes" xml:space="preserve">
          <source>The transpose of a C-ordered array is a FORTRAN-ordered array.</source>
          <target state="translated">Транспозиция массива в C-образном порядке является массивом в формате FORTRAN.</target>
        </trans-unit>
        <trans-unit id="be8d0d980a1c43a49c10382a49da454ce905c4ef" translate="yes" xml:space="preserve">
          <source>The transposed array.</source>
          <target state="translated">Перемещенный массив.</target>
        </trans-unit>
        <trans-unit id="ded8f77d9cba6691688303bd624c72d17c97324f" translate="yes" xml:space="preserve">
          <source>The tree in &lt;code&gt;numpy&lt;/code&gt; will now have the latest changes from the initial repository.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="362e7b5f1deb8afe588bc61b11c57a486aa6b58d" translate="yes" xml:space="preserve">
          <source>The triangular distribution is a continuous probability distribution with lower limit left, peak at mode, and upper limit right. Unlike the other distributions, these parameters directly define the shape of the pdf.</source>
          <target state="translated">Треугольное распределение-это непрерывное распределение вероятностей с нижним пределом слева,пиком в режиме и верхним пределом справа.В отличие от других распределений,эти параметры непосредственно определяют форму pdf.</target>
        </trans-unit>
        <trans-unit id="1d2039a815b5ec90474a824463e862d2894a1c82" translate="yes" xml:space="preserve">
          <source>The triangular distribution is often used in ill-defined problems where the underlying distribution is not known, but some knowledge of the limits and mode exists. Often it is used in simulations.</source>
          <target state="translated">Треугольное распределение часто используется в плохо определенных проблемах,где основное распределение неизвестно,но существуют определенные знания о границах и способе.Часто оно используется в симуляциях.</target>
        </trans-unit>
        <trans-unit id="6a93dc1adb33729debf6e5480c2814c2157666fd" translate="yes" xml:space="preserve">
          <source>The triangular window, with the maximum value normalized to one (the value one appears only if the number of samples is odd), with the first and last samples equal to zero.</source>
          <target state="translated">Треугольное окно с максимальным значением,нормализованным к единице (значение единицы появляется только в случае,если количество отсчетов нечетное),с первым и последним отсчетом равным нулю.</target>
        </trans-unit>
        <trans-unit id="24e66129ed79808afe1e2c37f4c9f61c91ca2839" translate="yes" xml:space="preserve">
          <source>The true value of &lt;code&gt;exp(1e-10) - 1&lt;/code&gt; is &lt;code&gt;1.00000000005e-10&lt;/code&gt; to about 32 significant digits. This example shows the superiority of expm1 in this case.</source>
          <target state="translated">Истинное значение &lt;code&gt;exp(1e-10) - 1&lt;/code&gt; составляет &lt;code&gt;1.00000000005e-10&lt;/code&gt; примерно до 32 значащих цифр. Этот пример показывает превосходство expm1 в этом случае.</target>
        </trans-unit>
        <trans-unit id="973da8e077b17711228349d2b08c7d0d4f2d3661" translate="yes" xml:space="preserve">
          <source>The truncated or zero-padded input, transformed along the axes indicated by &lt;code&gt;axes&lt;/code&gt;, or by a combination of &lt;code&gt;s&lt;/code&gt; and &lt;code&gt;a&lt;/code&gt;, as explained in the parameters section above.</source>
          <target state="translated">Усеченный или дополненный нулями ввод, преобразованный по осям, обозначенным &lt;code&gt;axes&lt;/code&gt; , или комбинацией &lt;code&gt;s&lt;/code&gt; и &lt;code&gt;a&lt;/code&gt; , как объяснено в разделе параметров выше.</target>
        </trans-unit>
        <trans-unit id="0cef9d8907fc4d88debbd9a6424b4425ec58e68f" translate="yes" xml:space="preserve">
          <source>The truncated or zero-padded input, transformed along the axes indicated by &lt;code&gt;axes&lt;/code&gt;, or by a combination of &lt;code&gt;s&lt;/code&gt; and &lt;code&gt;a&lt;/code&gt;, as explained in the parameters section above. The length of the last axis transformed will be &lt;code&gt;s[-1]//2+1&lt;/code&gt;, while the remaining transformed axes will have lengths according to &lt;code&gt;s&lt;/code&gt;, or unchanged from the input.</source>
          <target state="translated">Усеченный или дополненный нулями ввод, преобразованный по осям, обозначенным &lt;code&gt;axes&lt;/code&gt; , или комбинацией &lt;code&gt;s&lt;/code&gt; и &lt;code&gt;a&lt;/code&gt; , как объяснено в разделе параметров выше. Длина последней преобразованной оси будет &lt;code&gt;s[-1]//2+1&lt;/code&gt; , в то время как оставшиеся преобразованные оси будут иметь длину в соответствии с &lt;code&gt;s&lt;/code&gt; или неизменную от ввода.</target>
        </trans-unit>
        <trans-unit id="9c91d131105a38ed60b366938edb9bb82399cba7" translate="yes" xml:space="preserve">
          <source>The truncated or zero-padded input, transformed along the axes indicated by &lt;code&gt;axes&lt;/code&gt;, or by a combination of &lt;code&gt;s&lt;/code&gt; or &lt;code&gt;a&lt;/code&gt;, as explained in the parameters section above.</source>
          <target state="translated">Усеченный или дополненный нулями ввод, преобразованный по осям, обозначенным &lt;code&gt;axes&lt;/code&gt; , или комбинацией &lt;code&gt;s&lt;/code&gt; или &lt;code&gt;a&lt;/code&gt; , как объяснено в разделе параметров выше.</target>
        </trans-unit>
        <trans-unit id="879b9a05c20a089a225b78254a5b2e292b149d60" translate="yes" xml:space="preserve">
          <source>The truncated or zero-padded input, transformed along the axes indicated by &lt;code&gt;axes&lt;/code&gt;, or by a combination of &lt;code&gt;s&lt;/code&gt; or &lt;code&gt;a&lt;/code&gt;, as explained in the parameters section above. The length of each transformed axis is as given by the corresponding element of &lt;code&gt;s&lt;/code&gt;, or the length of the input in every axis except for the last one if &lt;code&gt;s&lt;/code&gt; is not given. In the final transformed axis the length of the output when &lt;code&gt;s&lt;/code&gt; is not given is &lt;code&gt;2*(m-1)&lt;/code&gt; where &lt;code&gt;m&lt;/code&gt; is the length of the final transformed axis of the input. To get an odd number of output points in the final axis, &lt;code&gt;s&lt;/code&gt; must be specified.</source>
          <target state="translated">Усеченный или дополненный нулями ввод, преобразованный по осям, обозначенным &lt;code&gt;axes&lt;/code&gt; , или комбинацией &lt;code&gt;s&lt;/code&gt; или &lt;code&gt;a&lt;/code&gt; , как объяснено в разделе параметров выше. Длина каждой преобразованной оси определяется соответствующим элементом &lt;code&gt;s&lt;/code&gt; или длиной входных данных по каждой оси, кроме последней, если &lt;code&gt;s&lt;/code&gt; не указан. На конечной преобразованной оси длина вывода, когда &lt;code&gt;s&lt;/code&gt; не задано, равна &lt;code&gt;2*(m-1)&lt;/code&gt; , где &lt;code&gt;m&lt;/code&gt; - длина конечной преобразованной оси ввода. Чтобы получить нечетное количество точек вывода на конечной оси, необходимо указать &lt;code&gt;s&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="933c6e0a0fb2fd7449c8d46cb7e6572b1c3279dd" translate="yes" xml:space="preserve">
          <source>The truncated or zero-padded input, transformed along the axes indicated by &lt;code&gt;axes&lt;/code&gt;, or the last two axes if &lt;code&gt;axes&lt;/code&gt; is not given.</source>
          <target state="translated">Усеченный или дополненный нулями ввод, преобразованный по осям, указанным &lt;code&gt;axes&lt;/code&gt; , или двум последним осям, если &lt;code&gt;axes&lt;/code&gt; не указаны.</target>
        </trans-unit>
        <trans-unit id="bdca2715ebaff6edc1c47e7d7cb69eb535ec549b" translate="yes" xml:space="preserve">
          <source>The truncated or zero-padded input, transformed along the axis indicated by &lt;code&gt;axis&lt;/code&gt;, or the last one if &lt;code&gt;axis&lt;/code&gt; is not specified.</source>
          <target state="translated">Усеченный или дополненный нулями ввод, преобразованный вдоль оси, указанной &lt;code&gt;axis&lt;/code&gt; , или последний, если &lt;code&gt;axis&lt;/code&gt; не указана.</target>
        </trans-unit>
        <trans-unit id="f4095a8db5d8ecd4ba9c0d3227d91d6c6751102f" translate="yes" xml:space="preserve">
          <source>The truncated or zero-padded input, transformed along the axis indicated by &lt;code&gt;axis&lt;/code&gt;, or the last one if &lt;code&gt;axis&lt;/code&gt; is not specified. If &lt;code&gt;n&lt;/code&gt; is even, the length of the transformed axis is &lt;code&gt;(n/2)+1&lt;/code&gt;. If &lt;code&gt;n&lt;/code&gt; is odd, the length is &lt;code&gt;(n+1)/2&lt;/code&gt;.</source>
          <target state="translated">Усеченный или дополненный нулями ввод, преобразованный вдоль оси, указанной &lt;code&gt;axis&lt;/code&gt; , или последний, если &lt;code&gt;axis&lt;/code&gt; не указана. Если &lt;code&gt;n&lt;/code&gt; четно, длина преобразованной оси равна &lt;code&gt;(n/2)+1&lt;/code&gt; . Если &lt;code&gt;n&lt;/code&gt; нечетное, длина равна &lt;code&gt;(n+1)/2&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="210fa87b6170797ddb3ab263d911a488e3f1f97e" translate="yes" xml:space="preserve">
          <source>The truncated or zero-padded input, transformed along the axis indicated by &lt;code&gt;axis&lt;/code&gt;, or the last one if &lt;code&gt;axis&lt;/code&gt; is not specified. The length of the transformed axis is &lt;code&gt;n//2 + 1&lt;/code&gt;.</source>
          <target state="translated">Усеченный или дополненный нулями ввод, преобразованный вдоль оси, указанной &lt;code&gt;axis&lt;/code&gt; , или последний, если &lt;code&gt;axis&lt;/code&gt; не указана. Длина преобразованной оси равна &lt;code&gt;n//2 + 1&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1026feb255ba9e4ae695f12a04d60bbc57c49ac5" translate="yes" xml:space="preserve">
          <source>The truncated or zero-padded input, transformed along the axis indicated by &lt;code&gt;axis&lt;/code&gt;, or the last one if &lt;code&gt;axis&lt;/code&gt; is not specified. The length of the transformed axis is &lt;code&gt;n&lt;/code&gt;, or, if &lt;code&gt;n&lt;/code&gt; is not given, &lt;code&gt;2*(m-1)&lt;/code&gt; where &lt;code&gt;m&lt;/code&gt; is the length of the transformed axis of the input. To get an odd number of output points, &lt;code&gt;n&lt;/code&gt; must be specified.</source>
          <target state="translated">Усеченный или дополненный нулями ввод, преобразованный вдоль оси, указанной &lt;code&gt;axis&lt;/code&gt; , или последний, если &lt;code&gt;axis&lt;/code&gt; не указана. Длина преобразованной оси равна &lt;code&gt;n&lt;/code&gt; , или, если &lt;code&gt;n&lt;/code&gt; не задано, &lt;code&gt;2*(m-1)&lt;/code&gt; , где &lt;code&gt;m&lt;/code&gt; - длина преобразованной оси ввода. Чтобы получить нечетное количество точек вывода, необходимо указать &lt;code&gt;n&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="785f913e97e6f2c077e366a11b3d02d03922b2c4" translate="yes" xml:space="preserve">
          <source>The truncated or zero-padded input, transformed along the axis indicated by &lt;code&gt;axis&lt;/code&gt;, or the last one if &lt;code&gt;axis&lt;/code&gt; is not specified. The length of the transformed axis is &lt;code&gt;n&lt;/code&gt;, or, if &lt;code&gt;n&lt;/code&gt; is not given, &lt;code&gt;2*m - 2&lt;/code&gt; where &lt;code&gt;m&lt;/code&gt; is the length of the transformed axis of the input. To get an odd number of output points, &lt;code&gt;n&lt;/code&gt; must be specified, for instance as &lt;code&gt;2*m - 1&lt;/code&gt; in the typical case,</source>
          <target state="translated">Усеченный или дополненный нулями ввод, преобразованный вдоль оси, указанной &lt;code&gt;axis&lt;/code&gt; , или последний, если &lt;code&gt;axis&lt;/code&gt; не указана. Длина преобразованной оси равна &lt;code&gt;n&lt;/code&gt; или, если &lt;code&gt;n&lt;/code&gt; не задано, &lt;code&gt;2*m - 2&lt;/code&gt; где &lt;code&gt;m&lt;/code&gt; - длина преобразованной оси входа. Чтобы получить нечетное количество точек вывода, необходимо указать &lt;code&gt;n&lt;/code&gt; , например как &lt;code&gt;2*m - 1&lt;/code&gt; в типичном случае,</target>
        </trans-unit>
        <trans-unit id="890cb80542174800559555fcc8928d47ac767144" translate="yes" xml:space="preserve">
          <source>The truncated value of each element in &lt;code&gt;x&lt;/code&gt;. This is a scalar if &lt;code&gt;x&lt;/code&gt; is a scalar.</source>
          <target state="translated">Усеченное значение каждого элемента в &lt;code&gt;x&lt;/code&gt; . Это скаляр, если &lt;code&gt;x&lt;/code&gt; - скаляр.</target>
        </trans-unit>
        <trans-unit id="d225104697ad1c2e4adc5e266a19505669d514fa" translate="yes" xml:space="preserve">
          <source>The truncated value of the scalar &lt;code&gt;x&lt;/code&gt; is the nearest integer &lt;code&gt;i&lt;/code&gt; which is closer to zero than &lt;code&gt;x&lt;/code&gt; is. In short, the fractional part of the signed number &lt;code&gt;x&lt;/code&gt; is discarded.</source>
          <target state="translated">Усеченное значение скаляра &lt;code&gt;x&lt;/code&gt; - это ближайшее целое число &lt;code&gt;i&lt;/code&gt; , которое ближе к нулю, чем &lt;code&gt;x&lt;/code&gt; . Короче говоря, дробная часть числа &lt;code&gt;x&lt;/code&gt; со знаком отбрасывается.</target>
        </trans-unit>
        <trans-unit id="7473e98cdd8b9577d457a4ec3ae00062b1e0d1c1" translate="yes" xml:space="preserve">
          <source>The tuple &lt;code&gt;args&lt;/code&gt; and dict &lt;code&gt;kwargs&lt;/code&gt; are directly passed on from the original call.</source>
          <target state="translated">&lt;code&gt;args&lt;/code&gt; кортежа и dict &lt;code&gt;kwargs&lt;/code&gt; передаются напрямую из исходного вызова.</target>
        </trans-unit>
        <trans-unit id="462bd3332737c1c0e3c136e2df99165ffa307b94" translate="yes" xml:space="preserve">
          <source>The tuple returned from __array_interface__[&amp;lsquo;data&amp;rsquo;] used to be a hex-string (now it is an integer or a long integer).</source>
          <target state="translated">Кортеж, возвращаемый из __array_interface __ ['data'], раньше был шестнадцатеричной строкой (теперь это целое или длинное целое число).</target>
        </trans-unit>
        <trans-unit id="ac07e35413d52171420d0546afbc516e4675dfc6" translate="yes" xml:space="preserve">
          <source>The two arrays are of the same length, so there is only one position where they completely overlap:</source>
          <target state="translated">Два массива имеют одинаковую длину,поэтому есть только одно место,где они полностью перекрываются:</target>
        </trans-unit>
        <trans-unit id="a1576896c14768083aa4b0494018f6de168f9aa6" translate="yes" xml:space="preserve">
          <source>The two dimensional series is evaluated at the points &lt;code&gt;(x, y)&lt;/code&gt;, where &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; must have the same shape. If &lt;code&gt;x&lt;/code&gt; or &lt;code&gt;y&lt;/code&gt; is a list or tuple, it is first converted to an ndarray, otherwise it is left unchanged and if it isn&amp;rsquo;t an ndarray it is treated as a scalar.</source>
          <target state="translated">Двухмерный ряд оценивается в точках &lt;code&gt;(x, y)&lt;/code&gt; , где &lt;code&gt;x&lt;/code&gt; и &lt;code&gt;y&lt;/code&gt; должны иметь одинаковую форму. Если &lt;code&gt;x&lt;/code&gt; или &lt;code&gt;y&lt;/code&gt; является списком или кортежем, он сначала преобразуется в ndarray, в противном случае он остается неизменным, а если это не ndarray, он рассматривается как скаляр.</target>
        </trans-unit>
        <trans-unit id="2eba9ab6dc5fc4a672b7a559261dcf61c08663b7" translate="yes" xml:space="preserve">
          <source>The two dimensional series is evaluated at the points &lt;code&gt;(x, y)&lt;/code&gt;, where &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; must have the same shape. If &lt;code&gt;x&lt;/code&gt; or &lt;code&gt;y&lt;/code&gt; is a list or tuple, it is first converted to an ndarray, otherwise it is left unchanged and, if it isn&amp;rsquo;t an ndarray, it is treated as a scalar.</source>
          <target state="translated">Двухмерный ряд оценивается в точках &lt;code&gt;(x, y)&lt;/code&gt; , где &lt;code&gt;x&lt;/code&gt; и &lt;code&gt;y&lt;/code&gt; должны иметь одинаковую форму. Если &lt;code&gt;x&lt;/code&gt; или &lt;code&gt;y&lt;/code&gt; является списком или кортежем, он сначала преобразуется в ndarray, в противном случае он остается неизменным, и, если это не ndarray, он рассматривается как скаляр.</target>
        </trans-unit>
        <trans-unit id="0688b7907322e12f298dd8f02d187105297d15b2" translate="yes" xml:space="preserve">
          <source>The two dimensional series is evaluated at the points in the Cartesian product of &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt;. If &lt;code&gt;x&lt;/code&gt; or &lt;code&gt;y&lt;/code&gt; is a list or tuple, it is first converted to an ndarray, otherwise it is left unchanged and, if it isn&amp;rsquo;t an ndarray, it is treated as a scalar.</source>
          <target state="translated">Двумерный ряд оценивается в точках декартового произведения &lt;code&gt;x&lt;/code&gt; и &lt;code&gt;y&lt;/code&gt; . Если &lt;code&gt;x&lt;/code&gt; или &lt;code&gt;y&lt;/code&gt; является списком или кортежем, он сначала преобразуется в ndarray, в противном случае он остается неизменным, и, если это не ndarray, он рассматривается как скаляр.</target>
        </trans-unit>
        <trans-unit id="d4aa44f129ba54b421bffe3762821ce4945dce60" translate="yes" xml:space="preserve">
          <source>The two domains that determine the map. Each must (successfully) convert to 1-d arrays containing precisely two values.</source>
          <target state="translated">Два домена,которые определяют карту.Каждый из них должен (успешно)преобразовываться в 1-d массивы,содержащие ровно два значения.</target>
        </trans-unit>
        <trans-unit id="0027adc4d9c51b047c70705863099ef3efdd05ff" translate="yes" xml:space="preserve">
          <source>The two methods do not return the same sequence of variates.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="810d0511d5cc6182785b949cef8752429de415c1" translate="yes" xml:space="preserve">
          <source>The two&amp;rsquo;s complement is returned when the input number is negative and width is specified:</source>
          <target state="translated">Дополнение до двух возвращается, когда входное число отрицательное и указана ширина:</target>
        </trans-unit>
        <trans-unit id="584450aea06b04e9037daf43c6af1e81a83e775a" translate="yes" xml:space="preserve">
          <source>The two-dimensional FFT of real input.</source>
          <target state="translated">Двухмерный БПФ реального входа.</target>
        </trans-unit>
        <trans-unit id="9b11970984391ed9339a62d69846a84202600584" translate="yes" xml:space="preserve">
          <source>The two-dimensional FFT.</source>
          <target state="translated">Двухмерный БПФ.</target>
        </trans-unit>
        <trans-unit id="93378f6188f826db256b9d6c37c0794ddd0149ba" translate="yes" xml:space="preserve">
          <source>The two-dimensional example we created using Fortran is just as easy to write in Cython:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cc89089001cef3c7a737f8de3b95a6b67d11a175" translate="yes" xml:space="preserve">
          <source>The two-dimensional inverse FFT.</source>
          <target state="translated">Двухмерный обратный БПФ.</target>
        </trans-unit>
        <trans-unit id="9f5faf584fb30081780464310b34017103e73128" translate="yes" xml:space="preserve">
          <source>The type above can either refer to an actual Python type (e.g. &lt;code&gt;int&lt;/code&gt;), or describe the type of the variable in more detail, e.g. &lt;code&gt;(N,) ndarray&lt;/code&gt; or &lt;code&gt;array_like&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="66cebb62b229032f20fef01d3cd3e2d8c08b92d1" translate="yes" xml:space="preserve">
          <source>The type object used to instantiate a scalar of this data-type.</source>
          <target state="translated">Объект типа,используемый для инстанцирования скаляра этого типа данных.</target>
        </trans-unit>
        <trans-unit id="6e4f0a20a4e71ba4f55f61f65f81013f324f6ce9" translate="yes" xml:space="preserve">
          <source>The type of the array can also be explicitly specified at creation time:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fa0bd68b05131d508a3464e6044d68f87729d81c" translate="yes" xml:space="preserve">
          <source>The type of the data can be accessed through the &lt;a href=&quot;#numpy.ma.MaskedArray.baseclass&quot;&gt;&lt;code&gt;baseclass&lt;/code&gt;&lt;/a&gt; attribute.</source>
          <target state="translated">Доступ к типу данных можно получить через атрибут &lt;a href=&quot;#numpy.ma.MaskedArray.baseclass&quot;&gt; &lt;code&gt;baseclass&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="4e723834a8970a250a2a2d214449437cb2b1463f" translate="yes" xml:space="preserve">
          <source>The type of the data can be accessed through the &lt;a href=&quot;numpy.ma.masked_array.baseclass#numpy.ma.masked_array.baseclass&quot;&gt;&lt;code&gt;baseclass&lt;/code&gt;&lt;/a&gt; attribute.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="55666432b4662cbbcca855eedc915c8dbb074f43" translate="yes" xml:space="preserve">
          <source>The type of the data is described by the following &lt;a href=&quot;generated/numpy.dtype#numpy.dtype&quot;&gt;&lt;code&gt;dtype&lt;/code&gt;&lt;/a&gt; attributes:</source>
          <target state="translated">Тип данных описывается следующими атрибутами &lt;a href=&quot;generated/numpy.dtype#numpy.dtype&quot;&gt; &lt;code&gt;dtype&lt;/code&gt; &lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="7c7e8530225fc135f4d9b6eea552288840993321" translate="yes" xml:space="preserve">
          <source>The type of the input is checked, not the value. Even if the input has an imaginary part equal to zero, &lt;a href=&quot;#numpy.iscomplexobj&quot;&gt;&lt;code&gt;iscomplexobj&lt;/code&gt;&lt;/a&gt; evaluates to True.</source>
          <target state="translated">Проверяется тип ввода, а не значение. Даже если входная мнимая часть равна нулю, &lt;a href=&quot;#numpy.iscomplexobj&quot;&gt; &lt;code&gt;iscomplexobj&lt;/code&gt; &lt;/a&gt; принимает значение True.</target>
        </trans-unit>
        <trans-unit id="1a2c8e641184f0940417186c9bd1b40520bec6a6" translate="yes" xml:space="preserve">
          <source>The type of the input is checked, not the value. So even if the input has an imaginary part equal to zero, &lt;a href=&quot;#numpy.isrealobj&quot;&gt;&lt;code&gt;isrealobj&lt;/code&gt;&lt;/a&gt; evaluates to False if the data type is complex.</source>
          <target state="translated">Проверяется тип ввода, а не значение. Таким образом, даже если входная мнимая часть равна нулю, &lt;a href=&quot;#numpy.isrealobj&quot;&gt; &lt;code&gt;isrealobj&lt;/code&gt; &lt;/a&gt; оценивает значение False, если тип данных сложный.</target>
        </trans-unit>
        <trans-unit id="ea61e4d42852a1b3d6a2054bbf717a4dcd45c615" translate="yes" xml:space="preserve">
          <source>The type of the output array. If &lt;a href=&quot;numpy.dtype#numpy.dtype&quot;&gt;&lt;code&gt;dtype&lt;/code&gt;&lt;/a&gt; is not given, infer the data type from the other input arguments.</source>
          <target state="translated">Тип выходного массива. Если &lt;a href=&quot;numpy.dtype#numpy.dtype&quot;&gt; &lt;code&gt;dtype&lt;/code&gt; &lt;/a&gt; не указан, выведите тип данных из других входных аргументов.</target>
        </trans-unit>
        <trans-unit id="2c73d98907158f7fb67c4efa759cdbb5f806f2d4" translate="yes" xml:space="preserve">
          <source>The type of the output array. If &lt;code&gt;dtype&lt;/code&gt; is not given, infer the data type from the other input arguments.</source>
          <target state="translated">Тип выходного массива. Если &lt;code&gt;dtype&lt;/code&gt; не указан, выведите тип данных из других входных аргументов.</target>
        </trans-unit>
        <trans-unit id="a61a6b8f22a17e9cfb7771cdc6f2f0f745c54b06" translate="yes" xml:space="preserve">
          <source>The type of the result will depend on the encoding specified.</source>
          <target state="translated">Тип результата будет зависеть от указанной кодировки.</target>
        </trans-unit>
        <trans-unit id="9f964988f963b226cae3c6098e96762218b96f31" translate="yes" xml:space="preserve">
          <source>The type of the returned array and of the accumulator in which the elements are summed. By default, the dtype of &lt;code&gt;a&lt;/code&gt; is used. An exception is when &lt;code&gt;a&lt;/code&gt; has an integer type with less precision than the platform (u)intp. In that case, the default will be either (u)int32 or (u)int64 depending on whether the platform is 32 or 64 bits. For inexact inputs, dtype must be inexact.</source>
          <target state="translated">Тип возвращаемого массива и аккумулятора, в котором суммируются элементы. По умолчанию используется dtype &lt;code&gt;a&lt;/code&gt; . Исключение составляют случаи, когда &lt;code&gt;a&lt;/code&gt; имеет целочисленный тип с меньшей точностью, чем платформа (u) intp. В этом случае по умолчанию будет либо (u) int32, либо (u) int64, в зависимости от того, является ли платформа 32 или 64 битной. Для неточных входных данных dtype должен быть неточным.</target>
        </trans-unit>
        <trans-unit id="fae2388276bf4adee2baf6958155240f0239ec9b" translate="yes" xml:space="preserve">
          <source>The type of the returned array and of the accumulator in which the elements are summed. The dtype of &lt;code&gt;a&lt;/code&gt; is used by default unless &lt;code&gt;a&lt;/code&gt; has an integer dtype of less precision than the default platform integer. In that case, if &lt;code&gt;a&lt;/code&gt; is signed then the platform integer is used while if &lt;code&gt;a&lt;/code&gt; is unsigned then an unsigned integer of the same precision as the platform integer is used.</source>
          <target state="translated">Тип возвращаемого массива и аккумулятора, в котором суммируются элементы. По умолчанию используется dtype &lt;code&gt;a&lt;/code&gt; , если &lt;code&gt;a&lt;/code&gt; не имеет целочисленного dtype меньшей точности, чем целое число платформы по умолчанию. В этом случае, если &lt;code&gt;a&lt;/code&gt; подписано, то используется целое число платформы, а если &lt;code&gt;a&lt;/code&gt; беззнаковое, то используется целое число без знака той же точности, что и целое число платформы.</target>
        </trans-unit>
        <trans-unit id="bd79c4b3d3f0f1be1ec3ce5a1aa5d47271e61a5b" translate="yes" xml:space="preserve">
          <source>The type of the returned array, as well as of the accumulator in which the elements are multiplied. The dtype of &lt;code&gt;a&lt;/code&gt; is used by default unless &lt;code&gt;a&lt;/code&gt; has an integer dtype of less precision than the default platform integer. In that case, if &lt;code&gt;a&lt;/code&gt; is signed then the platform integer is used while if &lt;code&gt;a&lt;/code&gt; is unsigned then an unsigned integer of the same precision as the platform integer is used.</source>
          <target state="translated">Тип возвращаемого массива, а также аккумулятора, в котором умножаются элементы. По умолчанию используется dtype &lt;code&gt;a&lt;/code&gt; , если &lt;code&gt;a&lt;/code&gt; не имеет целочисленного dtype меньшей точности, чем целое число платформы по умолчанию. В этом случае, если &lt;code&gt;a&lt;/code&gt; подписано, то используется целое число платформы, а если &lt;code&gt;a&lt;/code&gt; беззнаковое, то используется целое число без знака той же точности, что и целое число платформы.</target>
        </trans-unit>
        <trans-unit id="e3a7bb2863553d52f83413fb23d739a7fea567ae" translate="yes" xml:space="preserve">
          <source>The type used to represent the intermediate results. Defaults to the data type of the output array if this is provided, or the data type of the input array if no output array is provided.</source>
          <target state="translated">Тип,используемый для представления промежуточных результатов.По умолчанию используется тип данных выходного массива,если он предоставлен,или тип данных входного массива,если выходной массив не предоставлен.</target>
        </trans-unit>
        <trans-unit id="f46b668fbc5ae74dc471bbfdc9b1c8b2040c3ed5" translate="yes" xml:space="preserve">
          <source>The type used to represent the intermediate results. Defaults to the data-type of the output array if this is provided, or the data-type of the input array if no output array is provided.</source>
          <target state="translated">Тип,используемый для представления промежуточных результатов.По умолчанию используется тип данных выходного массива,если он предоставлен,или тип данных входного массива,если выходной массив не предоставлен.</target>
        </trans-unit>
        <trans-unit id="3d1a1953424d5a7364adfc318f2ceeb8ef42f6ff" translate="yes" xml:space="preserve">
          <source>The typemap directives provided by &lt;code&gt;numpy.i&lt;/code&gt; for arrays of different data types, say &lt;code&gt;double&lt;/code&gt; and &lt;code&gt;int&lt;/code&gt;, and dimensions of different types, say &lt;code&gt;int&lt;/code&gt; or &lt;code&gt;long&lt;/code&gt;, are identical to one another except for the C and NumPy type specifications. The typemaps are therefore implemented (typically behind the scenes) via a macro:</source>
          <target state="translated">Директивы typemap, предоставляемые &lt;code&gt;numpy.i&lt;/code&gt; для массивов разных типов данных, скажем, &lt;code&gt;double&lt;/code&gt; и &lt;code&gt;int&lt;/code&gt; , и размеров разных типов, скажем &lt;code&gt;int&lt;/code&gt; или &lt;code&gt;long&lt;/code&gt; , идентичны друг другу, за исключением спецификаций типов C и NumPy. Таким образом, карты типов реализуются (обычно за кулисами) с помощью макроса:</target>
        </trans-unit>
        <trans-unit id="dff7b3c37fb51796f178f8cb67e96939e35d8847" translate="yes" xml:space="preserve">
          <source>The typemap signatures are largely differentiated on the name given to the buffer pointer. Names with &lt;code&gt;FARRAY&lt;/code&gt; are for Fortran-ordered arrays, and names with &lt;code&gt;ARRAY&lt;/code&gt; are for C-ordered (or 1D arrays).</source>
          <target state="translated">Сигнатуры карты типов в значительной степени различаются по имени, присвоенному указателю буфера. Имена с &lt;code&gt;FARRAY&lt;/code&gt; предназначены для массивов, упорядоченных в Fortran, а имена с &lt;code&gt;ARRAY&lt;/code&gt; - для C-упорядоченных (или одномерных массивов).</target>
        </trans-unit>
        <trans-unit id="d316f93b51d10bd2681fb7336deed9067a473d1a" translate="yes" xml:space="preserve">
          <source>The typemaps from &lt;code&gt;numpy.i&lt;/code&gt; are responsible for the following lines of code: 12&amp;ndash;20, 25 and 30. Line 10 parses the input to the &lt;code&gt;rms&lt;/code&gt; function. From the format string &lt;code&gt;&quot;O:rms&quot;&lt;/code&gt;, we can see that the argument list is expected to be a single Python object (specified by the &lt;code&gt;O&lt;/code&gt; before the colon) and whose pointer is stored in &lt;code&gt;obj0&lt;/code&gt;. A number of functions, supplied by &lt;code&gt;numpy.i&lt;/code&gt;, are called to make and check the (possible) conversion from a generic Python object to a NumPy array. These functions are explained in the section &lt;a href=&quot;#helper-functions&quot;&gt;Helper Functions&lt;/a&gt;, but hopefully their names are self-explanatory. At line 12 we use &lt;code&gt;obj0&lt;/code&gt; to construct a NumPy array. At line 17, we check the validity of the result: that it is non-null and that it has a single dimension of arbitrary length. Once these states are verified, we extract the data buffer and length in lines 19 and 20 so that we can call the underlying C function at line 22. Line 25 performs memory management for the case where we have created a new array that is no longer needed.</source>
          <target state="translated">Карты типов из &lt;code&gt;numpy.i&lt;/code&gt; отвечают за следующие строки кода: 12&amp;ndash;20, 25 и 30. Строка 10 анализирует ввод для функции &lt;code&gt;rms&lt;/code&gt; . Из строки формата &lt;code&gt;&quot;O:rms&quot;&lt;/code&gt; мы можем видеть, что список аргументов должен быть единственным объектом Python (заданным &lt;code&gt;O&lt;/code&gt; перед двоеточием), указатель которого хранится в &lt;code&gt;obj0&lt;/code&gt; . Ряд функций, предоставляемых &lt;code&gt;numpy.i&lt;/code&gt; , вызывается для выполнения и проверки (возможного) преобразования из универсального объекта Python в массив NumPy. Эти функции объясняются в разделе &lt;a href=&quot;#helper-functions&quot;&gt;Вспомогательные функции&lt;/a&gt; , но, надеюсь, их названия говорят сами за себя. В строке 12 мы используем &lt;code&gt;obj0&lt;/code&gt; для создания массива NumPy. В строке 17 мы проверяем правильность результата: он не равен нулю и имеет одно измерение произвольной длины. После проверки этих состояний мы извлекаем буфер данных и длину в строках 19 и 20, чтобы мы могли вызвать базовую функцию C в строке 22. Строка 25 выполняет управление памятью для случая, когда мы создали новый массив, который больше не является необходимо.</target>
        </trans-unit>
        <trans-unit id="94a9db34d902a4524ad7871b0441ea5be9c4a8b8" translate="yes" xml:space="preserve">
          <source>The typical looping construct is as follows.</source>
          <target state="translated">Типичная петлевая конструкция выглядит следующим образом.</target>
        </trans-unit>
        <trans-unit id="93f339cfb377248f9f368c97945ac549c08d48eb" translate="yes" xml:space="preserve">
          <source>The ufunc object is implemented by creation of the &lt;a href=&quot;#c.PyUFunc_Type&quot;&gt;&lt;code&gt;PyUFunc_Type&lt;/code&gt;&lt;/a&gt;. It is a very simple type that implements only basic getattribute behavior, printing behavior, and has call behavior which allows these objects to act like functions. The basic idea behind the ufunc is to hold a reference to fast 1-dimensional (vector) loops for each data type that supports the operation. These one-dimensional loops all have the same signature and are the key to creating a new ufunc. They are called by the generic looping code as appropriate to implement the N-dimensional function. There are also some generic 1-d loops defined for floating and complexfloating arrays that allow you to define a ufunc using a single scalar function (&lt;em&gt;e.g.&lt;/em&gt; atanh).</source>
          <target state="translated">Объект ufunc реализуется путем создания &lt;a href=&quot;#c.PyUFunc_Type&quot;&gt; &lt;code&gt;PyUFunc_Type&lt;/code&gt; &lt;/a&gt; . Это очень простой тип, который реализует только базовое поведение getattribute, поведение печати и имеет поведение вызова, которое позволяет этим объектам действовать как функции. Основная идея ufunc - содержать ссылку на быстрые одномерные (векторные) циклы для каждого типа данных, который поддерживает операцию. Все эти одномерные циклы имеют одинаковую сигнатуру и являются ключом к созданию нового ufunc. Они вызываются универсальным циклическим кодом для реализации N-мерной функции. Есть также несколько общих одномерных циклов, определенных для плавающих и сложных плавающих массивов, которые позволяют вам определять ufunc с помощью одной скалярной функции ( &lt;em&gt;например,&lt;/em&gt; atanh).</target>
        </trans-unit>
        <trans-unit id="cf8db1044487cf17b16ec5dfd6f051754480a0fd" translate="yes" xml:space="preserve">
          <source>The ufunc still returns its output(s) even if you use the optional output argument(s).</source>
          <target state="translated">ufunc все равно возвращает свои выходные данные,даже если вы используете опциональный выходной аргумент(ы).</target>
        </trans-unit>
        <trans-unit id="a13b64ddac2c6f9c4757f678876470a35b9dd260" translate="yes" xml:space="preserve">
          <source>The umath module is a computer-generated C-module that creates many ufuncs. It provides a great many examples of how to create a universal function. Creating your own ufunc that will make use of the ufunc machinery is not difficult either. Suppose you have a function that you want to operate element-by-element over its inputs. By creating a new ufunc you will obtain a function that handles</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6d199d62fee4302579457e386e4a80ba73f82400" translate="yes" xml:space="preserve">
          <source>The underlying data of a masked array can be accessed in several ways:</source>
          <target state="translated">Доступ к базовым данным маскированного массива можно получить несколькими способами:</target>
        </trans-unit>
        <trans-unit id="11e8796701c0b67707f7be52c1081d9ae533b8cd" translate="yes" xml:space="preserve">
          <source>The underlying file descriptor is closed when exiting the &amp;lsquo;with&amp;rsquo; block.</source>
          <target state="translated">Базовый файловый дескриптор закрывается при выходе из блока with.</target>
        </trans-unit>
        <trans-unit id="8a7d26eedaa6e3c6ca58f22a4d3a1445aae9ed58" translate="yes" xml:space="preserve">
          <source>The upper-triangular matrix.</source>
          <target state="translated">Верхне-треугольная матрица.</target>
        </trans-unit>
        <trans-unit id="4d3a2d4644c583ea8315d7ff8cedb605a3b103a4" translate="yes" xml:space="preserve">
          <source>The usage of &lt;code&gt;fib1.fib&lt;/code&gt; in Python is very similar to using &lt;code&gt;FIB&lt;/code&gt; in Fortran. However, using &lt;em&gt;in situ&lt;/em&gt; output arguments in Python indicates a poor style as there is no safety mechanism in Python with respect to wrong argument types. When using Fortran or C, compilers naturally discover any type mismatches during compile time but in Python the types must be checked in runtime. So, using &lt;em&gt;in situ&lt;/em&gt; output arguments in Python may cause difficult to find bugs, not to mention that the codes will be less readable when all required type checks are implemented.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e4cb9fef2603ca49b4b7d883decd87bdc8eb544d" translate="yes" xml:space="preserve">
          <source>The use of random number generation is an important part of the configuration and evaluation of many numerical and machine learning algorithms. Whether you need to randomly initialize weights in an artificial neural network, split data into random sets, or randomly shuffle your dataset, being able to generate random numbers (actually, repeatable pseudo-random numbers) is essential.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="638520b9fcb56661a86b8addd734b2116df46c53" translate="yes" xml:space="preserve">
          <source>The use of this form of specification is discouraged, but documented here because older numpy code may use it. The keys of the dictionary are the field names and the values are tuples specifying type and offset:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4fb07adf94a9c0d15c6277e214f78bd8de82a95e" translate="yes" xml:space="preserve">
          <source>The user always has the option of converting to a normal &lt;code&gt;numpy.ndarray&lt;/code&gt; with &lt;a href=&quot;../reference/generated/numpy.asarray#numpy.asarray&quot;&gt;&lt;code&gt;numpy.asarray&lt;/code&gt;&lt;/a&gt; and using standard numpy from there.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8fcd141d1c403551e053ceda2314596f85b55796" translate="yes" xml:space="preserve">
          <source>The usual caution for verifying equality with floating point numbers is advised.</source>
          <target state="translated">Рекомендуется соблюдать обычную осторожность при проверке равенства с числами с плавающей точкой.</target>
        </trans-unit>
        <trans-unit id="6f6231b1c986a1cae99123ebb4b0aec8cf8b789f" translate="yes" xml:space="preserve">
          <source>The usual companion matrix of the Laguerre polynomials is already symmetric when &lt;code&gt;c&lt;/code&gt; is a basis Laguerre polynomial, so no scaling is applied.</source>
          <target state="translated">Обычная сопутствующая матрица полиномов Лагерра уже симметрична, когда &lt;code&gt;c&lt;/code&gt; является базисным полиномом Лагерра, поэтому масштабирование не применяется.</target>
        </trans-unit>
        <trans-unit id="f77acab0966818b5a377ef30b38be521ef7f7b59" translate="yes" xml:space="preserve">
          <source>The value of the function when x1 is 0. If &lt;code&gt;x1.shape != x2.shape&lt;/code&gt;, they must be broadcastable to a common shape (which becomes the shape of the output).</source>
          <target state="translated">Значение функции, когда x1 равно 0. Если &lt;code&gt;x1.shape != x2.shape&lt;/code&gt; , они должны транслироваться в общую форму (которая становится формой вывода).</target>
        </trans-unit>
        <trans-unit id="03d358ce11030b4d51f9879722053df717a3fe53" translate="yes" xml:space="preserve">
          <source>The value of this argument is typically a dictionary with column indices or column names as keys and a conversion functions as values. These conversion functions can either be actual functions or lambda functions. In any case, they should accept only a string as input and output only a single element of the wanted type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c3e9e5da5ef1ee5aadaa824ae3c6fd2914c94c23" translate="yes" xml:space="preserve">
          <source>The value of this attribute is used to determine what type of object to return in situations where there is more than one possibility for the Python type of the returned object. Subclasses inherit a default value of 0.0 for this attribute.</source>
          <target state="translated">Значение этого атрибута используется для определения типа возвращаемого объекта в ситуациях,когда существует более чем одна возможность для типа Python возвращаемого объекта.Подклассы наследуют значение по умолчанию 0.0 для данного атрибута.</target>
        </trans-unit>
        <trans-unit id="8bcc816a3b6323731b656c466ec0a5744f30e87e" translate="yes" xml:space="preserve">
          <source>The value to convert. Positive and negative values are handled.</source>
          <target state="translated">Значение для конвертации.Положительные и отрицательные значения обрабатываются.</target>
        </trans-unit>
        <trans-unit id="32b4c5a64bc9a7f3fa379e6006c427acc72a2601" translate="yes" xml:space="preserve">
          <source>The value to use for invalid entries (None by default). If None, the &lt;a href=&quot;../maskedarray.baseclass#numpy.ma.MaskedArray.fill_value&quot;&gt;&lt;code&gt;fill_value&lt;/code&gt;&lt;/a&gt; attribute of the array is used instead.</source>
          <target state="translated">Значение, используемое для недопустимых записей (по умолчанию нет). Если None, то &lt;a href=&quot;../maskedarray.baseclass#numpy.ma.MaskedArray.fill_value&quot;&gt; &lt;code&gt;fill_value&lt;/code&gt; &lt;/a&gt; атрибут fill_value массива.</target>
        </trans-unit>
        <trans-unit id="46bea3445bf9a264b60905faf1d0effc77e2e249" translate="yes" xml:space="preserve">
          <source>The value to use for invalid entries (None by default). If None, then this argument is inferred from the passed &lt;a href=&quot;numpy.ma.masked_array.dtype#numpy.ma.masked_array.dtype&quot;&gt;&lt;code&gt;dtype&lt;/code&gt;&lt;/a&gt;, or in its absence the original array, as discussed in the notes below.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a8455fb8033504388eae171a33ad0ef930322f1e" translate="yes" xml:space="preserve">
          <source>The value to use for invalid entries (None by default). If None, then this argument is inferred from the passed &lt;a href=&quot;numpy.ma.maskedarray.dtype#numpy.ma.MaskedArray.dtype&quot;&gt;&lt;code&gt;dtype&lt;/code&gt;&lt;/a&gt;, or in its absence the original array, as discussed in the notes below.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2e873302c473555951f6bce102181f00086c301d" translate="yes" xml:space="preserve">
          <source>The value to use for invalid entries. Can be scalar or non-scalar. If non-scalar, the resulting ndarray must be broadcastable over input array. Default is None, in which case, the &lt;a href=&quot;../maskedarray.baseclass#numpy.ma.MaskedArray.fill_value&quot;&gt;&lt;code&gt;fill_value&lt;/code&gt;&lt;/a&gt; attribute of the array is used instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1880e242040c0aab4362eb1a0863297a32bd5f4b" translate="yes" xml:space="preserve">
          <source>The value to use for invalid entries. Can be scalar or non-scalar. If non-scalar, the resulting ndarray must be broadcastable over input array. Default is None, in which case, the &lt;a href=&quot;numpy.ma.masked_array.fill_value#numpy.ma.masked_array.fill_value&quot;&gt;&lt;code&gt;fill_value&lt;/code&gt;&lt;/a&gt; attribute of the array is used instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="11b1837d34a4ca9f6b2279399c10c60d4b55936a" translate="yes" xml:space="preserve">
          <source>The value to use for invalid entries. Default is None.</source>
          <target state="translated">Значение,которое следует использовать для недействительных записей.По умолчанию нет.</target>
        </trans-unit>
        <trans-unit id="54be798891264cab731a931b04ea9772cdab541c" translate="yes" xml:space="preserve">
          <source>The value to use for the &lt;a href=&quot;numpy.ufunc.identity#numpy.ufunc.identity&quot;&gt;&lt;code&gt;identity&lt;/code&gt;&lt;/a&gt; attribute of the resulting object. If specified, this is equivalent to setting the underlying C &lt;code&gt;identity&lt;/code&gt; field to &lt;code&gt;PyUFunc_IdentityValue&lt;/code&gt;. If omitted, the identity is set to &lt;code&gt;PyUFunc_None&lt;/code&gt;. Note that this is _not_ equivalent to setting the identity to &lt;code&gt;None&lt;/code&gt;, which implies the operation is reorderable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="adfb1baad553fefd1bd16dad3fa307f22463d54c" translate="yes" xml:space="preserve">
          <source>The value where the peak of the distribution occurs. The value must fulfill the condition &lt;code&gt;left &amp;lt;= mode &amp;lt;= right&lt;/code&gt;.</source>
          <target state="translated">Значение, при котором наблюдается пик распределения. Значение должно соответствовать условию &lt;code&gt;left &amp;lt;= mode &amp;lt;= right&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="686c0ef41d4f40d919659043042cba31d0a83ddd" translate="yes" xml:space="preserve">
          <source>The value whose minimal data type is to be found.</source>
          <target state="translated">Значение,минимальный тип данных которого должен быть найден.</target>
        </trans-unit>
        <trans-unit id="ec08073e01c06623c4f6388732ecfb40030e861d" translate="yes" xml:space="preserve">
          <source>The value with which to start the reduction. If the ufunc has no identity or the dtype is object, this defaults to None - otherwise it defaults to ufunc.identity. If &lt;code&gt;None&lt;/code&gt; is given, the first element of the reduction is used, and an error is thrown if the reduction is empty.</source>
          <target state="translated">Значение, с которого начинается уменьшение. Если ufunc не имеет идентификатора или dtype - это объект, по умолчанию используется значение None, в противном случае - ufunc.identity. Если задано &lt;code&gt;None&lt;/code&gt; , используется первый элемент сокращения, и выдается ошибка, если сокращение пусто.</target>
        </trans-unit>
        <trans-unit id="930e3ad8c3851bb30a80a559ca4a2af60560b1ff" translate="yes" xml:space="preserve">
          <source>The values &lt;code&gt;ar1[in1d]&lt;/code&gt; are in &lt;code&gt;ar2&lt;/code&gt;.</source>
          <target state="translated">Значения &lt;code&gt;ar1[in1d]&lt;/code&gt; находятся в &lt;code&gt;ar2&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a4cb91abe1a0f589bcf1ee9ebaba06339dc294dc" translate="yes" xml:space="preserve">
          <source>The values against which to test each value of &lt;code&gt;ar1&lt;/code&gt;.</source>
          <target state="translated">Значения, по которым будет проверяться каждое значение &lt;code&gt;ar1&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="55096101173292ac6a418aa55429cc3cfcc3d718" translate="yes" xml:space="preserve">
          <source>The values against which to test each value of &lt;code&gt;element&lt;/code&gt;. This argument is flattened if it is an array or array_like. See notes for behavior with non-array-like parameters.</source>
          <target state="translated">Значения, по которым проверяется каждое значение &lt;code&gt;element&lt;/code&gt; . Этот аргумент сглаживается, если это массив или array_like. См. Примечания относительно поведения с параметрами, не похожими на массив.</target>
        </trans-unit>
        <trans-unit id="10fa1bca5c63978c522a37d289203eb7633c9fb5" translate="yes" xml:space="preserve">
          <source>The values in the rank-1 array &lt;code&gt;p&lt;/code&gt; are coefficients of a polynomial. If the length of &lt;code&gt;p&lt;/code&gt; is n+1 then the polynomial is described by:</source>
          <target state="translated">Значения в массиве &lt;code&gt;p&lt;/code&gt; ранга 1 являются коэффициентами полинома. Если длина &lt;code&gt;p&lt;/code&gt; равна n + 1, то полином описывается следующим образом:</target>
        </trans-unit>
        <trans-unit id="427b2ca25633b731d69a885f7ebcb443f1d11f04" translate="yes" xml:space="preserve">
          <source>The values in the result follow so-called &amp;ldquo;standard&amp;rdquo; order: If &lt;code&gt;A =
fft(a, n)&lt;/code&gt;, then &lt;code&gt;A[0]&lt;/code&gt; contains the zero-frequency term (the sum of the signal), which is always purely real for real inputs. Then &lt;code&gt;A[1:n/2]&lt;/code&gt; contains the positive-frequency terms, and &lt;code&gt;A[n/2+1:]&lt;/code&gt; contains the negative-frequency terms, in order of decreasingly negative frequency. For an even number of input points, &lt;code&gt;A[n/2]&lt;/code&gt; represents both positive and negative Nyquist frequency, and is also purely real for real input. For an odd number of input points, &lt;code&gt;A[(n-1)/2]&lt;/code&gt; contains the largest positive frequency, while &lt;code&gt;A[(n+1)/2]&lt;/code&gt; contains the largest negative frequency. The routine &lt;code&gt;np.fft.fftfreq(n)&lt;/code&gt; returns an array giving the frequencies of corresponding elements in the output. The routine &lt;code&gt;np.fft.fftshift(A)&lt;/code&gt; shifts transforms and their frequencies to put the zero-frequency components in the middle, and &lt;code&gt;np.fft.ifftshift(A)&lt;/code&gt; undoes that shift.</source>
          <target state="translated">Значения в результате следуют так называемому &amp;laquo;стандартному&amp;raquo; порядку: если &lt;code&gt;A = fft(a, n)&lt;/code&gt; , то &lt;code&gt;A[0]&lt;/code&gt; содержит член с нулевой частотой (сумму сигнала), который всегда является чисто реальным для реальных входы. Тогда &lt;code&gt;A[1:n/2]&lt;/code&gt; содержит члены с положительной частотой, а &lt;code&gt;A[n/2+1:]&lt;/code&gt; содержит члены с отрицательной частотой в порядке убывания отрицательной частоты. Для четного числа входных точек &lt;code&gt;A[n/2]&lt;/code&gt; представляет как положительную, так и отрицательную частоту Найквиста, а также является чисто реальным для реального входа. Для нечетного числа входных точек &lt;code&gt;A[(n-1)/2]&lt;/code&gt; содержит наибольшую положительную частоту, а &lt;code&gt;A[(n+1)/2]&lt;/code&gt; содержит наибольшую отрицательную частоту. Рутина &lt;code&gt;np.fft.fftfreq(n)&lt;/code&gt; возвращает массив с частотами соответствующих элементов на выходе. Подпрограмма &lt;code&gt;np.fft.fftshift(A)&lt;/code&gt; сдвигает преобразования и их частоты, чтобы поместить компоненты с нулевой частотой в середину, а &lt;code&gt;np.fft.ifftshift(A)&lt;/code&gt; отменяет этот сдвиг.</target>
        </trans-unit>
        <trans-unit id="049629d5662346c69d1da68173623b07fbd3ce2f" translate="yes" xml:space="preserve">
          <source>The values of &lt;code&gt;R&lt;/code&gt; are between -1 and 1, inclusive.</source>
          <target state="translated">Значения &lt;code&gt;R&lt;/code&gt; находятся в диапазоне от -1 до 1 включительно.</target>
        </trans-unit>
        <trans-unit id="9be1b3aaf13595cf59a1cfa63bbe9d63fd300725" translate="yes" xml:space="preserve">
          <source>The values of &lt;code&gt;x1&lt;/code&gt; with the sign of &lt;code&gt;x2&lt;/code&gt;. This is a scalar if both &lt;code&gt;x1&lt;/code&gt; and &lt;code&gt;x2&lt;/code&gt; are scalars.</source>
          <target state="translated">Значения &lt;code&gt;x1&lt;/code&gt; со знаком &lt;code&gt;x2&lt;/code&gt; . Это скаляр, если и &lt;code&gt;x1&lt;/code&gt; , и &lt;code&gt;x2&lt;/code&gt; являются скалярами.</target>
        </trans-unit>
        <trans-unit id="0b6f0a3f189dc33bd74c3b4b3649d7d6ee49f75c" translate="yes" xml:space="preserve">
          <source>The values of the histogram. See &lt;code&gt;density&lt;/code&gt; and &lt;code&gt;weights&lt;/code&gt; for a description of the possible semantics.</source>
          <target state="translated">Значения гистограммы. См. &lt;code&gt;density&lt;/code&gt; и &lt;code&gt;weights&lt;/code&gt; для описания возможной семантики.</target>
        </trans-unit>
        <trans-unit id="94c9275f5f339f7a7296146a88f4dacc4958d420" translate="yes" xml:space="preserve">
          <source>The values of the multidimension polynomial on points formed with triples of corresponding values from &lt;code&gt;x&lt;/code&gt;, &lt;code&gt;y&lt;/code&gt;, and &lt;code&gt;z&lt;/code&gt;.</source>
          <target state="translated">Значения многомерного полинома в точках, образованных тройками соответствующих значений из &lt;code&gt;x&lt;/code&gt; , &lt;code&gt;y&lt;/code&gt; и &lt;code&gt;z&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="000e1e6aea9b8f07ac10536f42598c0ea9bb0313" translate="yes" xml:space="preserve">
          <source>The values of the multidimensional polynomial on points formed with triples of corresponding values from &lt;code&gt;x&lt;/code&gt;, &lt;code&gt;y&lt;/code&gt;, and &lt;code&gt;z&lt;/code&gt;.</source>
          <target state="translated">Значения многомерного полинома в точках, образованных тройками соответствующих значений из &lt;code&gt;x&lt;/code&gt; , &lt;code&gt;y&lt;/code&gt; и &lt;code&gt;z&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="04875120c52fa413c52d82fe0fc8626bcc9f10c7" translate="yes" xml:space="preserve">
          <source>The values of the time series of cash flows. The (fixed) time interval between cash flow &amp;ldquo;events&amp;rdquo; must be the same as that for which &lt;a href=&quot;numpy.rate#numpy.rate&quot;&gt;&lt;code&gt;rate&lt;/code&gt;&lt;/a&gt; is given (i.e., if &lt;a href=&quot;numpy.rate#numpy.rate&quot;&gt;&lt;code&gt;rate&lt;/code&gt;&lt;/a&gt; is per year, then precisely a year is understood to elapse between each cash flow event). By convention, investments or &amp;ldquo;deposits&amp;rdquo; are negative, income or &amp;ldquo;withdrawals&amp;rdquo; are positive; &lt;code&gt;values&lt;/code&gt; must begin with the initial investment, thus &lt;code&gt;values[0]&lt;/code&gt; will typically be negative.</source>
          <target state="translated">Значения временных рядов денежных потоков. (Фиксированный) временной интервал между &amp;laquo;событиями&amp;raquo; денежных потоков должен быть таким же, как и интервал, для которого указана &lt;a href=&quot;numpy.rate#numpy.rate&quot;&gt; &lt;code&gt;rate&lt;/code&gt; &lt;/a&gt; (т. Е. Если &lt;a href=&quot;numpy.rate#numpy.rate&quot;&gt; &lt;code&gt;rate&lt;/code&gt; &lt;/a&gt; рассчитана на год, то считается, что между каждым событием денежного потока проходит ровно год). По традиции инвестиции или &amp;laquo;депозиты&amp;raquo; отрицательны, доходы или &amp;laquo;снятие средств&amp;raquo; положительны; &lt;code&gt;values&lt;/code&gt; должны начинаться с начальных вложений, поэтому &lt;code&gt;values[0]&lt;/code&gt; обычно будут отрицательными.</target>
        </trans-unit>
        <trans-unit id="1a3aeed326405c6ff97973ff76e3c1ac5b78c950" translate="yes" xml:space="preserve">
          <source>The values of the two dimensional Chebyshev series at points formed from pairs of corresponding values from &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt;.</source>
          <target state="translated">Значения двумерного ряда Чебышева в точках образованы парами соответствующих значений из &lt;code&gt;x&lt;/code&gt; и &lt;code&gt;y&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d500e0f26328b27b56cc6ea280ce335971a39a93" translate="yes" xml:space="preserve">
          <source>The values of the two dimensional Chebyshev series at points in the Cartesian product of &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt;.</source>
          <target state="translated">Значения двумерного ряда Чебышева в точках декартового произведения &lt;code&gt;x&lt;/code&gt; и &lt;code&gt;y&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="118ceee048eeb019cc7036790e58ad86a6694410" translate="yes" xml:space="preserve">
          <source>The values of the two dimensional Legendre series at points formed from pairs of corresponding values from &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt;.</source>
          <target state="translated">Значения двумерного ряда Лежандра в точках образованы парами соответствующих значений из &lt;code&gt;x&lt;/code&gt; и &lt;code&gt;y&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="75bce5c26e8d20f2a28b76fe4bee99ba20e34131" translate="yes" xml:space="preserve">
          <source>The values of the two dimensional polynomial at points formed with pairs of corresponding values from &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt;.</source>
          <target state="translated">Значения двумерного полинома в точках образованы парами соответствующих значений из &lt;code&gt;x&lt;/code&gt; и &lt;code&gt;y&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="fb47214ec0ab61ed4f83b6664e41c0aa8a83d3ed" translate="yes" xml:space="preserve">
          <source>The values of the two dimensional polynomial at points in the Cartesian product of &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt;.</source>
          <target state="translated">Значения двумерного полинома в точках декартового произведения &lt;code&gt;x&lt;/code&gt; и &lt;code&gt;y&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7d3e958b62535b85e2d7d32e34bc42123eb7d409" translate="yes" xml:space="preserve">
          <source>The values reported are normalized relative to the speed of MT19937 in each table. A value of 100 indicates that the performance matches the MT19937. Higher values indicate improved performance. These values cannot be compared across tables.</source>
          <target state="translated">Представленные значения нормируются относительно скорости MT19937 в каждой таблице.Значение 100 означает,что производительность соответствует MT19937.Более высокие значения указывают на улучшение производительности.Эти значения не могут быть сопоставлены между таблицами.</target>
        </trans-unit>
        <trans-unit id="d8a3da63b70322018b836bf5f65f57d16d3ac651" translate="yes" xml:space="preserve">
          <source>The values whose cube-roots are required.</source>
          <target state="translated">Ценности,для которых нужны низовые значения.</target>
        </trans-unit>
        <trans-unit id="b42bae2bd42a8c9e82a7332d1979f8a09c759feb" translate="yes" xml:space="preserve">
          <source>The values whose square-roots are required.</source>
          <target state="translated">Ценности,для которых нужны квадратные низы.</target>
        </trans-unit>
        <trans-unit id="187833930bd2cba800be6e8dd52776f374cc2f1c" translate="yes" xml:space="preserve">
          <source>The variable obtained by summing the squares of &lt;code&gt;df&lt;/code&gt; independent, standard normally distributed random variables:</source>
          <target state="translated">Переменный получается путем суммирования квадратов &lt;code&gt;df&lt;/code&gt; независимо, стандартные нормально распределенные случайные величины:</target>
        </trans-unit>
        <trans-unit id="fddb7e65a48e5500c69e424836450e7732656827" translate="yes" xml:space="preserve">
          <source>The variable used in the string representation of &lt;code&gt;p&lt;/code&gt; can be modified, using the &lt;a href=&quot;numpy.poly1d.variable#numpy.poly1d.variable&quot;&gt;&lt;code&gt;variable&lt;/code&gt;&lt;/a&gt; parameter:</source>
          <target state="translated">Переменная, используемая в строковом представлении &lt;code&gt;p&lt;/code&gt; , может быть изменена с помощью параметра &lt;a href=&quot;numpy.poly1d.variable#numpy.poly1d.variable&quot;&gt; &lt;code&gt;variable&lt;/code&gt; &lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="032af5a223b6a82b2905b5c850f693e8fec137cd" translate="yes" xml:space="preserve">
          <source>The variance is the average of the squared deviations from the mean, i.e., &lt;code&gt;var = mean(abs(x - x.mean())**2)&lt;/code&gt;.</source>
          <target state="translated">Дисперсия - это среднее значение квадратов отклонений от среднего, т. &lt;code&gt;var = mean(abs(x - x.mean())**2)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="598bba43a5fa13ecb982a04e1ac2dcfa3fb5a79a" translate="yes" xml:space="preserve">
          <source>The various character codes indicating certain types are also part of an enumerated list. References to type characters (should they be needed at all) should always use these enumerations. The form of them is &lt;code&gt;NPY_{NAME}LTR&lt;/code&gt; where &lt;code&gt;{NAME}&lt;/code&gt; can be</source>
          <target state="translated">Различные коды символов, обозначающие определенные типы, также являются частью нумерованного списка. Ссылки на символы типа (если они вообще нужны) всегда должны использовать эти перечисления. Их форма - &lt;code&gt;NPY_{NAME}LTR&lt;/code&gt; , где &lt;code&gt;{NAME}&lt;/code&gt; может быть</target>
        </trans-unit>
        <trans-unit id="d2bf21ee585f4c470168bc467b8b8760de8826fd" translate="yes" xml:space="preserve">
          <source>The various routines in the Polynomial package all deal with series whose coefficients go from degree zero upward, which is the &lt;em&gt;reverse order&lt;/em&gt; of the Poly1d convention. The easy way to remember this is that indexes correspond to degree, i.e., coef[i] is the coefficient of the term of degree i.</source>
          <target state="translated">Все различные подпрограммы в пакете Polynomial работают с рядами, коэффициенты которых идут от нулевой степени вверх, что является &lt;em&gt;обратным порядком&lt;/em&gt; соглашения Poly1d. Самый простой способ запомнить это - это то, что индексы соответствуют степени, т.е. coef [i] - это коэффициент члена степени i.</target>
        </trans-unit>
        <trans-unit id="40dcb2f33f2d122b10f89906b0fa578dee7f50c3" translate="yes" xml:space="preserve">
          <source>The various selection algorithms are characterized by their average speed, worst case performance, work space size, and whether they are stable. A stable sort keeps items with the same key in the same relative order. The available algorithms have the following properties:</source>
          <target state="translated">Различные алгоритмы подбора характеризуются средней скоростью,наихудшей производительностью,размером рабочего места и стабильностью.Стабильный сорт хранит элементы с одним и тем же ключом в одном и том же относительном порядке.Доступные алгоритмы обладают следующими свойствами:</target>
        </trans-unit>
        <trans-unit id="cc8322a9b3a11e0738c1dc848dd44452ebdc9f34" translate="yes" xml:space="preserve">
          <source>The various sorting algorithms are characterized by their average speed, worst case performance, work space size, and whether they are stable. A stable sort keeps items with the same key in the same relative order. The four algorithms implemented in NumPy have the following properties:</source>
          <target state="translated">Различные алгоритмы сортировки характеризуются средней скоростью,наихудшей производительностью,размером рабочего места и стабильностью.Стабильная сортировка сохраняет элементы с одним и тем же ключом в одном и том же относительном порядке.Четыре алгоритма,реализованные в NumPy,обладают следующими свойствами:</target>
        </trans-unit>
        <trans-unit id="909b1eaadbbd85f2064b83f98f4324e7aba0802c" translate="yes" xml:space="preserve">
          <source>The vdot(&lt;code&gt;a&lt;/code&gt;, &lt;code&gt;b&lt;/code&gt;) function handles complex numbers differently than dot(&lt;code&gt;a&lt;/code&gt;, &lt;code&gt;b&lt;/code&gt;). If the first argument is complex the complex conjugate of the first argument is used for the calculation of the dot product.</source>
          <target state="translated">Функция vdot ( &lt;code&gt;a&lt;/code&gt; , &lt;code&gt;b&lt;/code&gt; ) обрабатывает комплексные числа иначе, чем dot ( &lt;code&gt;a&lt;/code&gt; , &lt;code&gt;b&lt;/code&gt; ). Если первый аргумент является комплексным, для вычисления скалярного произведения используется комплексное сопряжение первого аргумента.</target>
        </trans-unit>
        <trans-unit id="f8aeebbf639e209f314766460959c079ab13f5dd" translate="yes" xml:space="preserve">
          <source>The version 1.0 format only allowed the array header to have a total size of 65535 bytes. This can be exceeded by structured arrays with a large number of columns. The version 2.0 format extends the header size to 4 GiB. &lt;a href=&quot;numpy.save#numpy.save&quot;&gt;&lt;code&gt;numpy.save&lt;/code&gt;&lt;/a&gt; will automatically save in 2.0 format if the data requires it, else it will always use the more compatible 1.0 format.</source>
          <target state="translated">Формат версии 1.0 позволял только заголовку массива иметь общий размер 65535 байт. Это может быть превышено с помощью структурированных массивов с большим количеством столбцов. Формат версии 2.0 увеличивает размер заголовка до 4 ГиБ. &lt;a href=&quot;numpy.save#numpy.save&quot;&gt; &lt;code&gt;numpy.save&lt;/code&gt; &lt;/a&gt; автоматически сохранит в формате 2.0, если этого требуют данные, иначе всегда будет использоваться более совместимый формат 1.0.</target>
        </trans-unit>
        <trans-unit id="7a92769f6aa86193f32ae6d12aa9581114703198" translate="yes" xml:space="preserve">
          <source>The version 2 interface was very similar. The differences were largely aesthetic. In particular:</source>
          <target state="translated">Интерфейс версии 2 был очень похож.Различия были в основном эстетическими.В частности:</target>
        </trans-unit>
        <trans-unit id="73bb55ce329b913976b213535f9642d82795177e" translate="yes" xml:space="preserve">
          <source>The version numbering of these formats is independent of NumPy version numbering. If the format is upgraded, the code in &lt;code&gt;numpy.io&lt;/code&gt; will still be able to read and write Version 1.0 files.</source>
          <target state="translated">Нумерация версий этих форматов не зависит от нумерации версий NumPy. Если формат обновлен, код в &lt;code&gt;numpy.io&lt;/code&gt; по- прежнему сможет читать и записывать файлы версии 1.0.</target>
        </trans-unit>
        <trans-unit id="d465b2400649c410304e54f051f7d49aa970de97" translate="yes" xml:space="preserve">
          <source>The von Mises distribution (also known as the circular normal distribution) is a continuous probability distribution on the unit circle. It may be thought of as the circular analogue of the normal distribution.</source>
          <target state="translated">Распределение фон Мизеса (также известное как круговое нормальное распределение)является непрерывным распределением вероятности на единичной окружности.Его можно считать аналогом кругового нормального распределения.</target>
        </trans-unit>
        <trans-unit id="08a316a93b85a841b11a6055717875d0502f2c60" translate="yes" xml:space="preserve">
          <source>The von Mises is named for Richard Edler von Mises, who was born in Austria-Hungary, in what is now the Ukraine. He fled to the United States in 1939 and became a professor at Harvard. He worked in probability theory, aerodynamics, fluid mechanics, and philosophy of science.</source>
          <target state="translated">Фон Мизес назван в честь Рихарда Эдлера фон Мизеса,который родился в Австро-Венгрии,на территории нынешней Украины.В 1939 году он бежал в США и стал профессором Гарварда.Он работал в области теории вероятностей,аэродинамики,механики жидкостей и философии науки.</target>
        </trans-unit>
        <trans-unit id="c66491ff606b4dc91911613d519dc8370dc0d225" translate="yes" xml:space="preserve">
          <source>The warnings can be turned off by</source>
          <target state="translated">Предупреждения могут быть отключены</target>
        </trans-unit>
        <trans-unit id="a3b6182c6d54b721f88f41929f57467a3fff8892" translate="yes" xml:space="preserve">
          <source>The weight function at &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="translated">Весовая функция в &lt;code&gt;x&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="88ba21dce5f8f071e2673c0f1f06439caa2807d7" translate="yes" xml:space="preserve">
          <source>The weight function is</source>
          <target state="translated">Функция веса</target>
        </trans-unit>
        <trans-unit id="308836c1d8a38528ab14ca4524532677c1153f22" translate="yes" xml:space="preserve">
          <source>The weight function of the Chebyshev polynomials.</source>
          <target state="translated">Весовая функция чебышевских полиномов.</target>
        </trans-unit>
        <trans-unit id="adb5d593e92bd3e7a619595dc278c8d8865de5f1" translate="yes" xml:space="preserve">
          <source>The wheels and source should be uploaded to PyPI.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8a75026ea8d79cfa948ad8144c46e90db33a682b" translate="yes" xml:space="preserve">
          <source>The wheels, once built, appear at &lt;a href=&quot;https://anaconda.org/multibuild-wheels-staging/numpy&quot;&gt;https://anaconda.org/multibuild-wheels-staging/numpy&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9b231b3ccfadec2079a40387b8d56e7ec8b9bb3d" translate="yes" xml:space="preserve">
          <source>The window of the converted series. If the value is None, the default window of &lt;code&gt;kind&lt;/code&gt; is used.</source>
          <target state="translated">Окно конвертированной серии. Если значение равно None, используется окно &lt;code&gt;kind&lt;/code&gt; по умолчанию .</target>
        </trans-unit>
        <trans-unit id="1da2fe6ad3abf125b431351fbdd12b7a74edc3f3" translate="yes" xml:space="preserve">
          <source>The window, with the maximum value normalized to one (the value one appears only if &lt;code&gt;M&lt;/code&gt; is odd).</source>
          <target state="translated">Окно с максимальным значением, нормализованным к единице (значение единица появляется только в том случае, если &lt;code&gt;M&lt;/code&gt; нечетное).</target>
        </trans-unit>
        <trans-unit id="48ac736d93f8e7e8643c8e0f7b0c321855533edd" translate="yes" xml:space="preserve">
          <source>The window, with the maximum value normalized to one (the value one appears only if the number of samples is odd).</source>
          <target state="translated">Окно с максимальным значением,нормализованным к единице (значение единицы появляется только в случае нечетного количества сэмплов).</target>
        </trans-unit>
        <trans-unit id="523eb308fcdc8d9a4d1dacdeabc03bc7b0a18f42" translate="yes" xml:space="preserve">
          <source>The word &amp;ldquo;non-zero&amp;rdquo; is in reference to the Python 2.x built-in method &lt;code&gt;__nonzero__()&lt;/code&gt; (renamed &lt;code&gt;__bool__()&lt;/code&gt; in Python 3.x) of Python objects that tests an object&amp;rsquo;s &amp;ldquo;truthfulness&amp;rdquo;. For example, any number is considered truthful if it is nonzero, whereas any string is considered truthful if it is not the empty string. Thus, this function (recursively) counts how many elements in &lt;code&gt;a&lt;/code&gt; (and in sub-arrays thereof) have their &lt;code&gt;__nonzero__()&lt;/code&gt; or &lt;code&gt;__bool__()&lt;/code&gt; method evaluated to &lt;code&gt;True&lt;/code&gt;.</source>
          <target state="translated">Слово &amp;laquo;ненулевое&amp;raquo; относится к встроенному в Python 2.x методу &lt;code&gt;__nonzero__()&lt;/code&gt; (переименованному в &lt;code&gt;__bool__()&lt;/code&gt; в Python 3.x) объектов Python, который проверяет &amp;laquo;правдивость&amp;raquo; объекта. Например, любое число считается истинным, если оно не равно нулю, тогда как любая строка считается истинной, если это не пустая строка. Таким образом, эта функция (рекурсивно) подсчитывает , сколько элементов в (и в подмассивах их) имеют свои &lt;code&gt;__nonzero__()&lt;/code&gt; или &lt;code&gt;__bool__()&lt;/code&gt; метод оценивается в значении &lt;code&gt;True&lt;/code&gt; . &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a3f383c240aa5414ebaced6e3034416ca7d1b6af" translate="yes" xml:space="preserve">
          <source>The wrap option affects only tall matrices:</source>
          <target state="translated">Опция обертывания затрагивает только высокие матрицы:</target>
        </trans-unit>
        <trans-unit id="fc81c936c38ae025ba8146e1222f7da14b956b1d" translate="yes" xml:space="preserve">
          <source>The x-coordinate sequence is expected to be increasing, but this is not explicitly enforced. However, if the sequence &lt;code&gt;xp&lt;/code&gt; is non-increasing, interpolation results are meaningless.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f30f1b95441858e7d3037adb27c5185133726d2e" translate="yes" xml:space="preserve">
          <source>The x-coordinates at which to evaluate the interpolated values.</source>
          <target state="translated">x-координаты,в которых оцениваются интерполированные значения.</target>
        </trans-unit>
        <trans-unit id="98e412a8d1f1dc441497184c5505f308bf594274" translate="yes" xml:space="preserve">
          <source>The x-coordinates of the data points, must be increasing if argument &lt;code&gt;period&lt;/code&gt; is not specified. Otherwise, &lt;code&gt;xp&lt;/code&gt; is internally sorted after normalizing the periodic boundaries with &lt;code&gt;xp = xp % period&lt;/code&gt;.</source>
          <target state="translated">Координаты x точек данных должны увеличиваться, если &lt;code&gt;period&lt;/code&gt; аргумента не указан. В противном случае &lt;code&gt;xp&lt;/code&gt; внутренне сортируется после нормализации периодических границ с &lt;code&gt;xp = xp % period&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5fb42b6312c1e1cea4c01b6bb567b8d84d30c4b2" translate="yes" xml:space="preserve">
          <source>The y-coordinates of the data points, same length as &lt;code&gt;xp&lt;/code&gt;.</source>
          <target state="translated">Y-координаты точек данных такой же длины, как &lt;code&gt;xp&lt;/code&gt; .</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
