<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ru" datatype="htmlbody" original="numpy">
    <body>
      <group id="numpy">
        <trans-unit id="72188498e399312affe529bd4d440a03ee9c95e4" translate="yes" xml:space="preserve">
          <source>Arithmetic is modular when using integer types, and no error is raised on overflow. That means that, on a 32-bit platform:</source>
          <target state="translated">Арифметика является модульной при использовании целочисленных типов,при переполнении ошибка не возникает.Это означает,что на 32-битной платформе:</target>
        </trans-unit>
        <trans-unit id="339f6492877ce24a534c3f1e9110c317be457d3a" translate="yes" xml:space="preserve">
          <source>Arithmetic mean taken while not ignoring NaNs</source>
          <target state="translated">Среднее арифметическое,взятое,не игнорируя NaN.</target>
        </trans-unit>
        <trans-unit id="1fc0feb17ac2848b9f01591a445a367739c560da" translate="yes" xml:space="preserve">
          <source>Arithmetic operations</source>
          <target state="translated">арифметические действия</target>
        </trans-unit>
        <trans-unit id="7ee1fda772751523c2669ec2f48ddc06e8ec6d54" translate="yes" xml:space="preserve">
          <source>Arithmetic operators on arrays apply &lt;em&gt;elementwise&lt;/em&gt;. A new array is created and filled with the result.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="16ba88bd7d8f2b893c09bcff737706246adcbc3b" translate="yes" xml:space="preserve">
          <source>Arithmetic, in-place:</source>
          <target state="translated">Арифметика,на месте:</target>
        </trans-unit>
        <trans-unit id="ac2131c4955b2cce396141546558f75712964834" translate="yes" xml:space="preserve">
          <source>Arithmetic, matrix multiplication, and comparison operations</source>
          <target state="translated">Арифметика,умножение матриц и операции сравнения</target>
        </trans-unit>
        <trans-unit id="d534ca6745f09f171b20632796505d5bd60949d7" translate="yes" xml:space="preserve">
          <source>Arithmetic:</source>
          <target state="translated">Arithmetic:</target>
        </trans-unit>
        <trans-unit id="0771a753fa9fe721bf5720d2f9bacca79fff9e8e" translate="yes" xml:space="preserve">
          <source>Arithmetics</source>
          <target state="translated">Arithmetics</target>
        </trans-unit>
        <trans-unit id="dfc7a32fa9a79ec3a22472c368d871d5e78afd31" translate="yes" xml:space="preserve">
          <source>Array (possibly multi-dimensional) of values for which to to calculate &lt;code&gt;sinc(x)&lt;/code&gt;.</source>
          <target state="translated">Массив (возможно, многомерный) значений, для которых нужно вычислить &lt;code&gt;sinc(x)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0523df413b1fea0ba7975ab7c9175833f364830f" translate="yes" xml:space="preserve">
          <source>Array &lt;strong&gt;attributes&lt;/strong&gt; reflect information intrinsic to the array itself. If you need to get, or even set, properties of an array without creating a new array, you can often access an array through its attributes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6951f36c01ac0e1bf34c5ee5904784fafce57b89" translate="yes" xml:space="preserve">
          <source>Array API</source>
          <target state="translated">API массива</target>
        </trans-unit>
        <trans-unit id="5555a6fcea0c1d138c4fd9c9348c13792e83ec8b" translate="yes" xml:space="preserve">
          <source>Array Attributes</source>
          <target state="translated">Атрибуты массива</target>
        </trans-unit>
        <trans-unit id="3458034e7e106c04c09c4ec57632af02a473c676" translate="yes" xml:space="preserve">
          <source>Array Broadcasting in Numpy</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0c1a37c234fe9514069c7363784bf98af15b8355" translate="yes" xml:space="preserve">
          <source>Array Creation</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="daa02d3f49bf321fb5979b03ac56b6cd9657dfad" translate="yes" xml:space="preserve">
          <source>Array Functions</source>
          <target state="translated">Функции массива</target>
        </trans-unit>
        <trans-unit id="12d693ff9b1c0d4047e2b7848ca27e4c2aad6719" translate="yes" xml:space="preserve">
          <source>Array Iterator</source>
          <target state="translated">Итератор массивов</target>
        </trans-unit>
        <trans-unit id="043a8c676a7d5d7051367cd8181a4b07707df511" translate="yes" xml:space="preserve">
          <source>Array Iterator API</source>
          <target state="translated">API итератора массивов</target>
        </trans-unit>
        <trans-unit id="23211b01eb261a332c7929b935052183b79935ba" translate="yes" xml:space="preserve">
          <source>Array Iterators</source>
          <target state="translated">Массивные итераторы</target>
        </trans-unit>
        <trans-unit id="17e44520a1762d19a9e642fb414c494c724cbf21" translate="yes" xml:space="preserve">
          <source>Array Scalars</source>
          <target state="translated">Массивные скаляры</target>
        </trans-unit>
        <trans-unit id="d8dbcc76e586f64f22d24c3030096b5747dde0a4" translate="yes" xml:space="preserve">
          <source>Array arguments</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2ec85771e631fd3b121a1ff64071bd20ad9c65bf" translate="yes" xml:space="preserve">
          <source>Array attributes</source>
          <target state="translated">Атрибуты массива</target>
        </trans-unit>
        <trans-unit id="447450427b5d5b0e87b960a4d40e39c7fb5454bf" translate="yes" xml:space="preserve">
          <source>Array attributes reflect information that is intrinsic to the array itself. Generally, accessing an array through its attributes allows you to get and sometimes set intrinsic properties of the array without creating a new array. The exposed attributes are the core parts of an array and only some of them can be reset meaningfully without creating a new array. Information on each attribute is given below.</source>
          <target state="translated">Атрибуты массива отражают информацию,присущую самому массиву.Обычно доступ к массиву через его атрибуты позволяет получить,а иногда и установить intrinsic свойства массива без создания нового массива.Выставленные атрибуты являются основными частями массива,и только некоторые из них могут быть переустановлены смысловым образом без создания нового массива.Информация по каждому атрибуту приведена ниже.</target>
        </trans-unit>
        <trans-unit id="43e339bdd3d217a5df3e10b8dade9046731deb5f" translate="yes" xml:space="preserve">
          <source>Array axis summations, &lt;a href=&quot;numpy.sum#numpy.sum&quot;&gt;&lt;code&gt;numpy.sum&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Суммирование по оси массива, &lt;a href=&quot;numpy.sum#numpy.sum&quot;&gt; &lt;code&gt;numpy.sum&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="57c60efa53930ae07f9d8ba23de0e194c69cf7fe" translate="yes" xml:space="preserve">
          <source>Array comparison assertions include maximum differences</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="347b135c7cac14f05d7b1660f5d4b4c54f55d66d" translate="yes" xml:space="preserve">
          <source>Array comparisons involving strings or structured dtypes</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d7a5d8de55dabc36dc25c0b90e8906cffcb6a61a" translate="yes" xml:space="preserve">
          <source>Array containing data to be averaged. If &lt;code&gt;a&lt;/code&gt; is not an array, a conversion is attempted.</source>
          <target state="translated">Массив, содержащий данные для усреднения. Если &lt;code&gt;a&lt;/code&gt; не массив, предпринимается попытка преобразования.</target>
        </trans-unit>
        <trans-unit id="54d016905c8d5e8ccde24c37f9843bcd318cb81c" translate="yes" xml:space="preserve">
          <source>Array containing elements to clip.</source>
          <target state="translated">Массив,содержащий элементы для зажима.</target>
        </trans-unit>
        <trans-unit id="3961c6f8eadfe688bca31469d6a9f6d86adf81c6" translate="yes" xml:space="preserve">
          <source>Array containing number of representable floating point numbers between items in &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt;.</source>
          <target state="translated">Массив, содержащий количество представимых чисел с плавающей запятой между элементами в &lt;code&gt;a&lt;/code&gt; и &lt;code&gt;b&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3692161b3a773c7a966c7715be4b4e9968f11340" translate="yes" xml:space="preserve">
          <source>Array containing numbers whose maximum is desired. If &lt;code&gt;a&lt;/code&gt; is not an array, a conversion is attempted.</source>
          <target state="translated">Массив, содержащий числа, для которых требуется максимум. Если &lt;code&gt;a&lt;/code&gt; не массив, предпринимается попытка преобразования.</target>
        </trans-unit>
        <trans-unit id="e6449394cdaf60dea5ac71fdd09a0ed9e9fcf7ee" translate="yes" xml:space="preserve">
          <source>Array containing numbers whose mean is desired. If &lt;code&gt;a&lt;/code&gt; is not an array, a conversion is attempted.</source>
          <target state="translated">Массив, содержащий числа, среднее значение которых требуется. Если &lt;code&gt;a&lt;/code&gt; не массив, предпринимается попытка преобразования.</target>
        </trans-unit>
        <trans-unit id="535ad2f426544f7de05e5d9017d86d66f0dc26b1" translate="yes" xml:space="preserve">
          <source>Array containing numbers whose minimum is desired. If &lt;code&gt;a&lt;/code&gt; is not an array, a conversion is attempted.</source>
          <target state="translated">Массив, содержащий числа, минимум которых требуется. Если &lt;code&gt;a&lt;/code&gt; не массив, предпринимается попытка преобразования.</target>
        </trans-unit>
        <trans-unit id="64bc244f5b24dc5faeb077670f074a7e20727322" translate="yes" xml:space="preserve">
          <source>Array containing numbers whose product is desired. If &lt;code&gt;a&lt;/code&gt; is not an array, a conversion is attempted.</source>
          <target state="translated">Массив, содержащий числа, произведение которых требуется. Если &lt;code&gt;a&lt;/code&gt; не массив, предпринимается попытка преобразования.</target>
        </trans-unit>
        <trans-unit id="ee6ece6461a907cbfdfd61282756037912ce23f3" translate="yes" xml:space="preserve">
          <source>Array containing numbers whose sum is desired. If &lt;code&gt;a&lt;/code&gt; is not an array, a conversion is attempted.</source>
          <target state="translated">Массив, содержащий числа, сумма которых требуется. Если &lt;code&gt;a&lt;/code&gt; не массив, предпринимается попытка преобразования.</target>
        </trans-unit>
        <trans-unit id="2effaddf77c674bd9a13dc031c59b1eb4d28fa23" translate="yes" xml:space="preserve">
          <source>Array containing numbers whose variance is desired. If &lt;code&gt;a&lt;/code&gt; is not an array, a conversion is attempted.</source>
          <target state="translated">Массив, содержащий числа, дисперсия которых желательна. Если &lt;code&gt;a&lt;/code&gt; не является массивом, предпринимается попытка преобразования.</target>
        </trans-unit>
        <trans-unit id="f011f52156b6489c00057dbaf1f239251b746676" translate="yes" xml:space="preserve">
          <source>Array containing the roots of the series.</source>
          <target state="translated">Массив,содержащий корни серии.</target>
        </trans-unit>
        <trans-unit id="d1fb2d0b90ad27fe772216fd0efb4378564945a2" translate="yes" xml:space="preserve">
          <source>Array contents</source>
          <target state="translated">Содержимое массива</target>
        </trans-unit>
        <trans-unit id="2ea33ca743035321174ecf9d435d32b0b6324742" translate="yes" xml:space="preserve">
          <source>Array conversion</source>
          <target state="translated">преобразование массива</target>
        </trans-unit>
        <trans-unit id="fc6b3a513ef2597bc0f03a1e823241af5164729d" translate="yes" xml:space="preserve">
          <source>Array convolution. Same output as polymul, but has parameter for overlap mode.</source>
          <target state="translated">Свертывание массивов.Тот же вывод,что и полимуль,но имеет параметр для режима перекрытия.</target>
        </trans-unit>
        <trans-unit id="57c72a1a53b95fbe1af3976c75af0287d5c9a140" translate="yes" xml:space="preserve">
          <source>Array creation</source>
          <target state="translated">Создание массивов</target>
        </trans-unit>
        <trans-unit id="b5a18bd4e3702b73f0e8bbba0d5f2e2fddff6728" translate="yes" xml:space="preserve">
          <source>Array creation routines</source>
          <target state="translated">Процедуры создания массивов</target>
        </trans-unit>
        <trans-unit id="a51f0e8ac2e03ac06587c6b47fb57edec0450c93" translate="yes" xml:space="preserve">
          <source>Array data to be saved.</source>
          <target state="translated">Сохраняемые данные массива.</target>
        </trans-unit>
        <trans-unit id="4e68baef4a7d203aefd9d4a59b835fc6af2a5db3" translate="yes" xml:space="preserve">
          <source>Array data-type.</source>
          <target state="translated">Тип массива данных.</target>
        </trans-unit>
        <trans-unit id="52dbdba544f09b15fca774eb24a9caf2434bcfe6" translate="yes" xml:space="preserve">
          <source>Array desired.</source>
          <target state="translated">Желательный массив.</target>
        </trans-unit>
        <trans-unit id="785376e3605a2b132b04a5af283162b0f7133160" translate="yes" xml:space="preserve">
          <source>Array flags</source>
          <target state="translated">Массивные флаги</target>
        </trans-unit>
        <trans-unit id="746aa39a47d26f55bf62b76f045191bc2131b857" translate="yes" xml:space="preserve">
          <source>Array flags provide information about how the memory area used for the array is to be interpreted. There are 7 Boolean flags in use, only four of which can be changed by the user: WRITEBACKIFCOPY, UPDATEIFCOPY, WRITEABLE, and ALIGNED.</source>
          <target state="translated">Флаги массива предоставляют информацию о том,как будет интерпретироваться область памяти,используемая для массива.Используется 7 булевых флагов,только четыре из которых могут быть изменены пользователем:WRITEBACKIFCOPY,UPDATEIFCOPY,WRITEABLE и ALIGNED.</target>
        </trans-unit>
        <trans-unit id="5f6e91f1df0558c7246187a2b89a1e305be167b2" translate="yes" xml:space="preserve">
          <source>Array flags; may be one or more of:</source>
          <target state="translated">Массивные флаги;может быть один или несколько:</target>
        </trans-unit>
        <trans-unit id="09f0fcdcc100e898aaa63b04e30eafb660bbc3ed" translate="yes" xml:space="preserve">
          <source>Array from which the diagonals are taken.</source>
          <target state="translated">Массив,из которого берутся диагонали.</target>
        </trans-unit>
        <trans-unit id="3966916957967be244949812c17944d586ffd56d" translate="yes" xml:space="preserve">
          <source>Array from which to extract a part.</source>
          <target state="translated">Массив,из которого можно извлечь часть.</target>
        </trans-unit>
        <trans-unit id="e35c942121269158d9bce83e940f79fd38671bbd" translate="yes" xml:space="preserve">
          <source>Array indexing refers to any use of the square brackets ([]) to index array values. There are many options to indexing, which give numpy indexing great power, but with power comes some complexity and the potential for confusion. This section is just an overview of the various options and issues related to indexing. Aside from single element indexing, the details on most of these options are to be found in related sections.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4a877fe238b2290421c4de0ccb250aa8e3797a13" translate="yes" xml:space="preserve">
          <source>Array interface</source>
          <target state="translated">Массивный интерфейс</target>
        </trans-unit>
        <trans-unit id="533db24c36bf6bd74ce0240469f4033043848386" translate="yes" xml:space="preserve">
          <source>Array interpretation of &lt;code&gt;a&lt;/code&gt;.</source>
          <target state="translated">Массив интерпретации . &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="1230519a64fd2e0f26f95201257e208e07092a99" translate="yes" xml:space="preserve">
          <source>Array interpretation of &lt;code&gt;a&lt;/code&gt;. If &lt;code&gt;a&lt;/code&gt; is an ndarray or a subclass of ndarray, it is returned as-is and no copy is performed.</source>
          <target state="translated">Массив интерпретации . Если &lt;code&gt;a&lt;/code&gt; является ndarray или подклассом ndarray, он возвращается как есть, и копирование не выполняется. &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="2a004555e4ca47c97c392427144fe0dcc6f68634" translate="yes" xml:space="preserve">
          <source>Array interpretation of &lt;code&gt;a&lt;/code&gt;. No copy is performed if the input is already an ndarray with matching dtype and order. If &lt;code&gt;a&lt;/code&gt; is a subclass of ndarray, a base class ndarray is returned.</source>
          <target state="translated">Массив интерпретации . Копирование не выполняется, если ввод уже является ndarray с совпадающими dtype и order. Если &lt;code&gt;a&lt;/code&gt; является подклассом ndarray, возвращается базовый класс ndarray. &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="9a82a73ea4a83ace24f5a89b08b00620d66cb5bf" translate="yes" xml:space="preserve">
          <source>Array interpretation of &lt;code&gt;a&lt;/code&gt;. No copy is performed if the input is already an ndarray. If &lt;code&gt;a&lt;/code&gt; is a subclass of ndarray, a base class ndarray is returned.</source>
          <target state="translated">Массив интерпретации . Копирование не выполняется, если ввод уже является ndarray. Если &lt;code&gt;a&lt;/code&gt; является подклассом ndarray, возвращается базовый класс ndarray. &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="1af36487281180923aa6bea35e0e5228dcc2e12d" translate="yes" xml:space="preserve">
          <source>Array into which the output is placed. Its type is preserved and it must be of the right shape to hold the output.</source>
          <target state="translated">Массив,в который помещается выход.Его тип сохраняется,и он должен иметь правильную форму,чтобы удерживать выход.</target>
        </trans-unit>
        <trans-unit id="02f71c6bb3adeae64ae8bccd5d811288aeb1d5e1" translate="yes" xml:space="preserve">
          <source>Array into which the result can be placed. Its type is preserved and it must be of the right shape to hold the output.</source>
          <target state="translated">Массив,в который можно поместить результат.Его тип сохраняется,и он должен иметь правильную форму,чтобы удерживать вывод.</target>
        </trans-unit>
        <trans-unit id="1a57f1ce3b565cb3497401b660e08581c3aafec2" translate="yes" xml:space="preserve">
          <source>Array like index object or slice object for indexing into first operand. If first operand has multiple dimensions, indices can be a tuple of array like index objects or slice objects.</source>
          <target state="translated">Массив как индексный объект или срезной объект для индексирования в первый операнд.Если первый операнд имеет несколько размеров,то индексы могут быть кортежом массива,подобно индексным объектам или слайс-объектам.</target>
        </trans-unit>
        <trans-unit id="d40d802fdd7ba3f82f5c9dc44f415145a1e22c74" translate="yes" xml:space="preserve">
          <source>Array manipulation routines</source>
          <target state="translated">Массивные манипуляционные процедуры</target>
        </trans-unit>
        <trans-unit id="069ff2b332e403300b9cde701bf5368c5831882c" translate="yes" xml:space="preserve">
          <source>Array method alternative API</source>
          <target state="translated">API альтернативного метода массива</target>
        </trans-unit>
        <trans-unit id="5a716333b00a93ed3236b0b9385a0a127035480c" translate="yes" xml:space="preserve">
          <source>Array methods</source>
          <target state="translated">Массивные методы</target>
        </trans-unit>
        <trans-unit id="4e4004372e15259457b2d1e38548f61c9bc5e00d" translate="yes" xml:space="preserve">
          <source>Array mixins</source>
          <target state="translated">Массивные смесители</target>
        </trans-unit>
        <trans-unit id="f161aeb75d90d23a000f60fbe55cf3eae07ee334" translate="yes" xml:space="preserve">
          <source>Array objects</source>
          <target state="translated">Массивные объекты</target>
        </trans-unit>
        <trans-unit id="cf093406a8132eb8bfd9cf1020e69e3fe6518645" translate="yes" xml:space="preserve">
          <source>Array obtained.</source>
          <target state="translated">Массив получен.</target>
        </trans-unit>
        <trans-unit id="6b0a1f1e944aed373e67de14ba6a79b095a23306" translate="yes" xml:space="preserve">
          <source>Array of &lt;code&gt;fill_value&lt;/code&gt; with the given shape, dtype, and order.</source>
          <target state="translated">Массив &lt;code&gt;fill_value&lt;/code&gt; с заданной формой, dtype и порядком.</target>
        </trans-unit>
        <trans-unit id="141b0992112c657405943baa4a593bdfd3d362b8" translate="yes" xml:space="preserve">
          <source>Array of &lt;code&gt;fill_value&lt;/code&gt; with the same shape and type as &lt;code&gt;a&lt;/code&gt;.</source>
          <target state="translated">Массив &lt;code&gt;fill_value&lt;/code&gt; с одной и той же формы и типа, . &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="d4591434d561c417ccddebc05c5c4eae4564de2b" translate="yes" xml:space="preserve">
          <source>Array of Chebyshev series coefficients. If c is multidimensional the different axis correspond to different variables with the degree in each axis given by the corresponding index.</source>
          <target state="translated">Массив коэффициентов Чебышевского ряда.Если c многомерен,то разные оси соответствуют разным переменным со степенью в каждой оси,заданной соответствующим индексом.</target>
        </trans-unit>
        <trans-unit id="4f8604db9d0154dd7eb0dded915686a2e44b5243" translate="yes" xml:space="preserve">
          <source>Array of Hermite series coefficients. If &lt;code&gt;c&lt;/code&gt; is multidimensional the different axis correspond to different variables with the degree in each axis given by the corresponding index.</source>
          <target state="translated">Массив коэффициентов ряда Эрмита. Если &lt;code&gt;c&lt;/code&gt; многомерна, разные оси соответствуют разным переменным со степенью на каждой оси, заданной соответствующим индексом.</target>
        </trans-unit>
        <trans-unit id="817eb4e4585a916e35d1ff46432ac14702692600" translate="yes" xml:space="preserve">
          <source>Array of Hermite series coefficients. If c is multidimensional the different axis correspond to different variables with the degree in each axis given by the corresponding index.</source>
          <target state="translated">Массив коэффициентов Эрмита.Если c многомерен,то разные оси соответствуют разным переменным со степенью в каждой оси,заданной соответствующим индексом.</target>
        </trans-unit>
        <trans-unit id="6bb7459da4388ebdd50a78addd0898c1f80aabbe" translate="yes" xml:space="preserve">
          <source>Array of Hermite_e series coefficients. If &lt;code&gt;c&lt;/code&gt; is multidimensional the different axis correspond to different variables with the degree in each axis given by the corresponding index.</source>
          <target state="translated">Массив коэффициентов серии Hermite_e. Если &lt;code&gt;c&lt;/code&gt; многомерна, разные оси соответствуют разным переменным со степенью на каждой оси, заданной соответствующим индексом.</target>
        </trans-unit>
        <trans-unit id="63e65a5158a929fafcbc4f8f156592488b9429ea" translate="yes" xml:space="preserve">
          <source>Array of Hermite_e series coefficients. If c is multidimensional the different axis correspond to different variables with the degree in each axis given by the corresponding index.</source>
          <target state="translated">Массив коэффициентов ряда Hermite_e.Если c многомерен,то разные оси соответствуют разным переменным со степенью в каждой оси,заданной соответствующим индексом.</target>
        </trans-unit>
        <trans-unit id="1ea8d2a10d04a6eb03ee934ed9f9008e87ff51dc" translate="yes" xml:space="preserve">
          <source>Array of Laguerre series coefficients. If &lt;code&gt;c&lt;/code&gt; is multidimensional the different axis correspond to different variables with the degree in each axis given by the corresponding index.</source>
          <target state="translated">Массив коэффициентов ряда Лагерра. Если &lt;code&gt;c&lt;/code&gt; многомерна, разные оси соответствуют разным переменным со степенью на каждой оси, заданной соответствующим индексом.</target>
        </trans-unit>
        <trans-unit id="35c007605e6d77452f8dad5eb06d7938bab0902f" translate="yes" xml:space="preserve">
          <source>Array of Legendre series coefficients. If c is multidimensional the different axis correspond to different variables with the degree in each axis given by the corresponding index.</source>
          <target state="translated">Массив коэффициентов рядов Легенды.Если c многомерен,то разные оси соответствуют разным переменным со степенью в каждой оси,заданной соответствующим индексом.</target>
        </trans-unit>
        <trans-unit id="4261b4b77833f5ffb9b4ec031af96d60404d62e0" translate="yes" xml:space="preserve">
          <source>Array of angles in radians, in the range &lt;code&gt;[-pi, pi]&lt;/code&gt;. This is a scalar if both &lt;code&gt;x1&lt;/code&gt; and &lt;code&gt;x2&lt;/code&gt; are scalars.</source>
          <target state="translated">Массив углов в радианах в диапазоне &lt;code&gt;[-pi, pi]&lt;/code&gt; . Это скаляр, если и &lt;code&gt;x1&lt;/code&gt; , и &lt;code&gt;x2&lt;/code&gt; являются скалярами.</target>
        </trans-unit>
        <trans-unit id="d00b51bfc114fceca7b5e804468ddaae71dd1f04" translate="yes" xml:space="preserve">
          <source>Array of bins. It has to be 1-dimensional and monotonic.</source>
          <target state="translated">Массив мусорных баков.Он должен быть одномерным и монотонным.</target>
        </trans-unit>
        <trans-unit id="2431f4c023950cb461e657c537178d58e27e27dd" translate="yes" xml:space="preserve">
          <source>Array of booleans</source>
          <target state="translated">Массив булеонов</target>
        </trans-unit>
        <trans-unit id="536a897428fe0f47a3d34f49d6446e12ae81a0e0" translate="yes" xml:space="preserve">
          <source>Array of booleans identical in shape to &lt;code&gt;a&lt;/code&gt;.</source>
          <target state="translated">Массив Булевых одинакового по форме . &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a77bc6459d956649f3ae15d32c4f2c19eb8edf06" translate="yes" xml:space="preserve">
          <source>Array of booleans of same shape as &lt;code&gt;a&lt;/code&gt;.</source>
          <target state="translated">Массив логических значений той же формы, что &lt;code&gt;a&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a658696b6a89082b912ff090b4b6b37dee9b715c" translate="yes" xml:space="preserve">
          <source>Array of coefficients ordered so that the coefficient of the term of multi-degree i,j is contained in &lt;code&gt;c[i,j]&lt;/code&gt;. If &lt;code&gt;c&lt;/code&gt; has dimension greater than 2 the remaining indices enumerate multiple sets of coefficients.</source>
          <target state="translated">Массив коэффициентов упорядочен так, чтобы коэффициент при множительной степени i, j содержался в &lt;code&gt;c[i,j]&lt;/code&gt; . Если &lt;code&gt;c&lt;/code&gt; имеет размерность больше 2, оставшиеся индексы перечисляют несколько наборов коэффициентов.</target>
        </trans-unit>
        <trans-unit id="56c372955c6e7c782716979251e8af46e2f83f0a" translate="yes" xml:space="preserve">
          <source>Array of coefficients ordered so that the coefficient of the term of multi-degree i,j is contained in &lt;code&gt;c[i,j]&lt;/code&gt;. If &lt;code&gt;c&lt;/code&gt; has dimension greater than two the remaining indices enumerate multiple sets of coefficients.</source>
          <target state="translated">Массив коэффициентов упорядочен так, чтобы коэффициент при множительной степени i, j содержался в &lt;code&gt;c[i,j]&lt;/code&gt; . Если &lt;code&gt;c&lt;/code&gt; имеет размерность больше двух, оставшиеся индексы перечисляют несколько наборов коэффициентов.</target>
        </trans-unit>
        <trans-unit id="fa76e8a2aedbceba248a9fc307fb834762ffa569" translate="yes" xml:space="preserve">
          <source>Array of coefficients ordered so that the coefficient of the term of multi-degree i,j,k is contained in &lt;code&gt;c[i,j,k]&lt;/code&gt;. If &lt;code&gt;c&lt;/code&gt; has dimension greater than 3 the remaining indices enumerate multiple sets of coefficients.</source>
          <target state="translated">Массив коэффициентов упорядочен так, чтобы коэффициент при множительной степени i, j, k содержался в &lt;code&gt;c[i,j,k]&lt;/code&gt; . Если &lt;code&gt;c&lt;/code&gt; имеет размерность больше 3, оставшиеся индексы перечисляют несколько наборов коэффициентов.</target>
        </trans-unit>
        <trans-unit id="2ca7ab8cb88305034f9c8ff4c4bec7fdbf7384a0" translate="yes" xml:space="preserve">
          <source>Array of coefficients ordered so that the coefficients for terms of degree i,j are contained in &lt;code&gt;c[i,j]&lt;/code&gt;. If &lt;code&gt;c&lt;/code&gt; has dimension greater than two the remaining indices enumerate multiple sets of coefficients.</source>
          <target state="translated">Массив коэффициентов упорядочен так, чтобы коэффициенты для членов степени i, j содержались в &lt;code&gt;c[i,j]&lt;/code&gt; . Если &lt;code&gt;c&lt;/code&gt; имеет размерность больше двух, оставшиеся индексы перечисляют несколько наборов коэффициентов.</target>
        </trans-unit>
        <trans-unit id="013054b355ed269971a257a22db8c61fecab58bc" translate="yes" xml:space="preserve">
          <source>Array of coefficients ordered so that the coefficients for terms of degree n are contained in c[n]. If &lt;code&gt;c&lt;/code&gt; is multidimensional the remaining indices enumerate multiple polynomials. In the two dimensional case the coefficients may be thought of as stored in the columns of &lt;code&gt;c&lt;/code&gt;.</source>
          <target state="translated">Массив коэффициентов упорядочен так, чтобы коэффициенты для членов степени n содержались в c [n]. Если &lt;code&gt;c&lt;/code&gt; многомерна, оставшиеся индексы перечисляют несколько многочленов. В двумерном случае коэффициенты можно рассматривать как сохраненные в столбцах &lt;code&gt;c&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="00bc78cb48de3651884eadaf718d38e560006d25" translate="yes" xml:space="preserve">
          <source>Array of evenly spaced values.</source>
          <target state="translated">Массив равномерно распределенных значений.</target>
        </trans-unit>
        <trans-unit id="2d1560c385ed8ca347f0a453a1d3ede23238d315" translate="yes" xml:space="preserve">
          <source>Array of indices into the array. It has the same shape as &lt;code&gt;a.shape&lt;/code&gt; with the dimension along &lt;code&gt;axis&lt;/code&gt; removed.</source>
          <target state="translated">Массив индексов в массив. Он имеет ту же форму, что и &lt;code&gt;a.shape&lt;/code&gt; , с удаленным размером по &lt;code&gt;axis&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a8ca40e5ac25fd9b6c7a437f8b20abf87b6dd448" translate="yes" xml:space="preserve">
          <source>Array of indices that partition &lt;code&gt;a&lt;/code&gt; along the specified axis. If &lt;code&gt;a&lt;/code&gt; is one-dimensional, &lt;code&gt;a[index_array]&lt;/code&gt; yields a partitioned &lt;code&gt;a&lt;/code&gt;. More generally, &lt;code&gt;np.take_along_axis(a, index_array, axis=a)&lt;/code&gt; always yields the partitioned &lt;code&gt;a&lt;/code&gt;, irrespective of dimensionality.</source>
          <target state="translated">Массив индексов, разделяющих &lt;code&gt;a&lt;/code&gt; вдоль указанной оси. Если &lt;code&gt;a&lt;/code&gt; одномерный, &lt;code&gt;a[index_array]&lt;/code&gt; дает разделенный &lt;code&gt;a&lt;/code&gt; . В более общем смысле, &lt;code&gt;np.take_along_axis(a, index_array, axis=a)&lt;/code&gt; всегда дает секционированный &lt;code&gt;a&lt;/code&gt; , независимо от размерности.</target>
        </trans-unit>
        <trans-unit id="8b6035bba7c71c43b0b9bba16cae62cbd47fc547" translate="yes" xml:space="preserve">
          <source>Array of indices that sort &lt;code&gt;a&lt;/code&gt; along the specified &lt;code&gt;axis&lt;/code&gt;. If &lt;code&gt;a&lt;/code&gt; is one-dimensional, &lt;code&gt;a[index_array]&lt;/code&gt; yields a sorted &lt;code&gt;a&lt;/code&gt;. More generally, &lt;code&gt;np.take_along_axis(a, index_array, axis=axis)&lt;/code&gt; always yields the sorted &lt;code&gt;a&lt;/code&gt;, irrespective of dimensionality.</source>
          <target state="translated">Массив индексов, сортировать вдоль указанной &lt;code&gt;axis&lt;/code&gt; . Если &lt;code&gt;a&lt;/code&gt; одномерный, &lt;code&gt;a[index_array]&lt;/code&gt; дает отсортированный &lt;code&gt;a&lt;/code&gt; . В более общем плане &lt;code&gt;np.take_along_axis(a, index_array, axis=axis)&lt;/code&gt; всегда возвращает отсортированный &lt;code&gt;a&lt;/code&gt; , независимо от размерности. &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a0dc6273aecd116e71b925f830b8b852ca18868e" translate="yes" xml:space="preserve">
          <source>Array of indices that sort &lt;code&gt;a&lt;/code&gt; along the specified axis. In other words, &lt;code&gt;a[index_array]&lt;/code&gt; yields a sorted &lt;code&gt;a&lt;/code&gt;.</source>
          <target state="translated">Массив индексов, сортировать вдоль указанной оси. Другими словами, &lt;code&gt;a[index_array]&lt;/code&gt; дает отсортированный &lt;code&gt;a&lt;/code&gt; . &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="87cf8b4326e4bf74829f6ee998b605e627a3e05c" translate="yes" xml:space="preserve">
          <source>Array of indices that sort the keys along the specified axis.</source>
          <target state="translated">Массив индексов,сортирующих ключи по заданной оси.</target>
        </trans-unit>
        <trans-unit id="9ba877503fdc9b234f8b5bd4ff989ab5b66a993a" translate="yes" xml:space="preserve">
          <source>Array of insertion points with the same shape as &lt;code&gt;v&lt;/code&gt;.</source>
          <target state="translated">Массив точек вставки той же формы, что и &lt;code&gt;v&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="eda2f2ab5893d6c8f805112f168403bde8914bdc" translate="yes" xml:space="preserve">
          <source>Array of length &lt;code&gt;n//2 + 1&lt;/code&gt; containing the sample frequencies.</source>
          <target state="translated">Массив длины &lt;code&gt;n//2 + 1&lt;/code&gt; содержащий частоты дискретизации.</target>
        </trans-unit>
        <trans-unit id="16403e1679edece0422b414ba8df64826286ea95" translate="yes" xml:space="preserve">
          <source>Array of length &lt;code&gt;n&lt;/code&gt; containing the sample frequencies.</source>
          <target state="translated">Массив длины &lt;code&gt;n&lt;/code&gt; , содержащий частоты дискретизации.</target>
        </trans-unit>
        <trans-unit id="3e56b710dd7f0b21c34a3b08ffd09a687bf4487b" translate="yes" xml:space="preserve">
          <source>Array of list objects</source>
          <target state="translated">Массив объектов списка</target>
        </trans-unit>
        <trans-unit id="8a37d72f2b1b4102a1be6ef75c473c25a6af0723" translate="yes" xml:space="preserve">
          <source>Array of multipliers.</source>
          <target state="translated">Массив мультипликаторов.</target>
        </trans-unit>
        <trans-unit id="206e9ffd7bd541d0301a39acc4ace879a4a8c4c0" translate="yes" xml:space="preserve">
          <source>Array of numbers to be decomposed.</source>
          <target state="translated">Массив разлагаемых чисел.</target>
        </trans-unit>
        <trans-unit id="b8d93545bf76db1e421350de1ab5b27bda265c94" translate="yes" xml:space="preserve">
          <source>Array of ones with the given shape, dtype, and order.</source>
          <target state="translated">Массив из тех,которые имеют заданную форму,тип и порядок.</target>
        </trans-unit>
        <trans-unit id="2a7562df8fd2349ba86c3e8c830bce9f44d2768c" translate="yes" xml:space="preserve">
          <source>Array of ones with the same shape and type as &lt;code&gt;a&lt;/code&gt;.</source>
          <target state="translated">Массив из них с той же формы и типа, . &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="c57697e4962f7c2af124e859e719b69080933cff" translate="yes" xml:space="preserve">
          <source>Array of ones.</source>
          <target state="translated">Массив из них.</target>
        </trans-unit>
        <trans-unit id="baa4adf58634fb06ef6ad2372bc5421740221f26" translate="yes" xml:space="preserve">
          <source>Array of points of the same shape as &lt;code&gt;x&lt;/code&gt;, after application of the linear map between the two domains.</source>
          <target state="translated">Массив точек той же формы, что и &lt;code&gt;x&lt;/code&gt; , после применения линейной карты между двумя доменами.</target>
        </trans-unit>
        <trans-unit id="e10ad4b8d9ac04992efd38f05d15c560adaf42ef" translate="yes" xml:space="preserve">
          <source>Array of points. The dtype is converted to float64 or complex128 depending on whether any of the elements are complex. If &lt;code&gt;x&lt;/code&gt; is scalar it is converted to a 1-D array.</source>
          <target state="translated">Массив точек. Тип dtype преобразуется в float64 или complex128 в зависимости от того, является ли какой-либо из элементов сложным. Если &lt;code&gt;x&lt;/code&gt; скалярный, он преобразуется в одномерный массив.</target>
        </trans-unit>
        <trans-unit id="2608e7cd905fe0c68e32ec9f1d08d5e186ac4133" translate="yes" xml:space="preserve">
          <source>Array of polynomial coefficients. If c is multidimensional the different axis correspond to different variables with the degree in each axis given by the corresponding index.</source>
          <target state="translated">Массив полиномиальных коэффициентов.Если c многомерен,то разные оси соответствуют разным переменным со степенью в каждой оси,заданной соответствующим индексом.</target>
        </trans-unit>
        <trans-unit id="df9f1c9c3e6efbfb4f90ed818292071092d8d4f0" translate="yes" xml:space="preserve">
          <source>Array of random floats of shape &lt;code&gt;size&lt;/code&gt; (unless &lt;code&gt;size=None&lt;/code&gt;, in which case a single float is returned).</source>
          <target state="translated">Массив случайных чисел с плавающей запятой определенного &lt;code&gt;size&lt;/code&gt; (если &lt;code&gt;size=None&lt;/code&gt; , и в этом случае возвращается один объект с плавающей запятой).</target>
        </trans-unit>
        <trans-unit id="8c27164f605bc6a37751898bf3ccca7ad65d8b8c" translate="yes" xml:space="preserve">
          <source>Array of roots. If &lt;code&gt;r&lt;/code&gt; is multidimensional the first index is the root index, while the remaining indices enumerate multiple polynomials. For instance, in the two dimensional case the roots of each polynomial may be thought of as stored in the columns of &lt;code&gt;r&lt;/code&gt;.</source>
          <target state="translated">Массив корней. Если &lt;code&gt;r&lt;/code&gt; является многомерным, первый индекс является корневым индексом, а остальные индексы перечисляют несколько полиномов. Например, в двумерном случае корни каждого полинома можно рассматривать как хранящиеся в столбцах &lt;code&gt;r&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f5e105f8faad33b4f50f2c4896fe5c70b476d2c2" translate="yes" xml:space="preserve">
          <source>Array of the roots of the polynomial. If all the roots are real, then &lt;code&gt;out&lt;/code&gt; is also real, otherwise it is complex.</source>
          <target state="translated">Массив корней многочлена. Если все корни реальны, то &lt;code&gt;out&lt;/code&gt; также реален, в противном случае он сложен.</target>
        </trans-unit>
        <trans-unit id="4d0d9a7ae0205565ce5ab6637ea0bc6fd758edf0" translate="yes" xml:space="preserve">
          <source>Array of the roots of the series. If all the roots are real, then &lt;code&gt;out&lt;/code&gt; is also real, otherwise it is complex.</source>
          <target state="translated">Массив корней серии. Если все корни реальны, то &lt;code&gt;out&lt;/code&gt; также реален, в противном случае он сложен.</target>
        </trans-unit>
        <trans-unit id="d523e60421af0d15597be465d458af223885d81e" translate="yes" xml:space="preserve">
          <source>Array of the same shape as &lt;code&gt;x&lt;/code&gt;. This is a scalar if &lt;code&gt;x&lt;/code&gt; is a scalar.</source>
          <target state="translated">Массив той же формы, что и &lt;code&gt;x&lt;/code&gt; . Это скаляр, если &lt;code&gt;x&lt;/code&gt; - скаляр.</target>
        </trans-unit>
        <trans-unit id="8fb65c76565be83184293a727b86b612f6baa966" translate="yes" xml:space="preserve">
          <source>Array of the same type and shape as &lt;code&gt;a&lt;/code&gt;.</source>
          <target state="translated">Массив того же типа и формы, что &lt;code&gt;a&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="cde597bca9a6bd0298c0f76843af628711adacdc" translate="yes" xml:space="preserve">
          <source>Array of two or more dimensions.</source>
          <target state="translated">Массив из двух и более измерений.</target>
        </trans-unit>
        <trans-unit id="9c36b99254e0fa9d0972f22709ef88f81c5217da" translate="yes" xml:space="preserve">
          <source>Array of twos exponents. If &lt;code&gt;x1.shape != x2.shape&lt;/code&gt;, they must be broadcastable to a common shape (which becomes the shape of the output).</source>
          <target state="translated">Массив двоек показателей. Если &lt;code&gt;x1.shape != x2.shape&lt;/code&gt; , они должны транслироваться в общую форму (которая становится формой вывода).</target>
        </trans-unit>
        <trans-unit id="ef176723af239a8b84441eb4e1012c9997a74190" translate="yes" xml:space="preserve">
          <source>Array of type uint8 whose elements represent bits corresponding to the logical (0 or nonzero) value of the input elements. The shape of &lt;code&gt;packed&lt;/code&gt; has the same number of dimensions as the input (unless &lt;code&gt;axis&lt;/code&gt; is None, in which case the output is 1-D).</source>
          <target state="translated">Массив типа uint8, элементы которого представляют биты, соответствующие логическому (0 или ненулевому) значению входных элементов. Форма &lt;code&gt;packed&lt;/code&gt; имеет то же количество измерений, что и вход (если &lt;code&gt;axis&lt;/code&gt; имеет значения None, и в этом случае выход будет 1-D).</target>
        </trans-unit>
        <trans-unit id="d136dd4eb12fa67aaa6854e035f05c7d1d6e0269" translate="yes" xml:space="preserve">
          <source>Array of uninitialized (arbitrary) data of the given shape, dtype, and order. Object arrays will be initialized to None.</source>
          <target state="translated">Массив неинициализированных (произвольных)данных заданной формы,типа и порядка.Массивы объектов будут инициализированы на None.</target>
        </trans-unit>
        <trans-unit id="84a6a10448bc129791439e6ef9301081b2eae3db" translate="yes" xml:space="preserve">
          <source>Array of uninitialized (arbitrary) data with the same shape and type as &lt;code&gt;prototype&lt;/code&gt;.</source>
          <target state="translated">Массив неинициализированных (произвольных) данных той же формы и типа, что и &lt;code&gt;prototype&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1b00e6648235fca7be6befd806901affb44faa6e" translate="yes" xml:space="preserve">
          <source>Array of variates drawn from the multivariate hypergeometric distribution.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e791423834bca116a632635c62e713e7f9a7037b" translate="yes" xml:space="preserve">
          <source>Array of zeros with the given shape, dtype, and order.</source>
          <target state="translated">Массив нулей с заданной формой,типом и порядком.</target>
        </trans-unit>
        <trans-unit id="5118cee064bbe572e4b1416e1f0671b0db1bf70d" translate="yes" xml:space="preserve">
          <source>Array of zeros with the same shape and type as &lt;code&gt;a&lt;/code&gt;.</source>
          <target state="translated">Массив нулей той же формы и типа, что &lt;code&gt;a&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="16e772e7005bc124d579516af58c7fbb273b27a8" translate="yes" xml:space="preserve">
          <source>Array or &lt;a href=&quot;numpy.poly1d#numpy.poly1d&quot;&gt;&lt;code&gt;poly1d&lt;/code&gt;&lt;/a&gt; object of the difference polynomial&amp;rsquo;s coefficients.</source>
          <target state="translated">Массив или объект &lt;a href=&quot;numpy.poly1d#numpy.poly1d&quot;&gt; &lt;code&gt;poly1d&lt;/code&gt; &lt;/a&gt; коэффициентов разностного полинома.</target>
        </trans-unit>
        <trans-unit id="dbb2927a7be8102e0b46249ee761be13ecebeed6" translate="yes" xml:space="preserve">
          <source>Array or sequence of arrays storing the fields to add to the base.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="367e141a4fff1b31230cbf6695c1abe0275a3a68" translate="yes" xml:space="preserve">
          <source>Array priority.</source>
          <target state="translated">Приоритет массива.</target>
        </trans-unit>
        <trans-unit id="8afc8a14b9ea339f994a4b92b64eeee0fec93781" translate="yes" xml:space="preserve">
          <source>Array property returning the array transposed.</source>
          <target state="translated">Свойство массива,возвращающее транспонированный массив.</target>
        </trans-unit>
        <trans-unit id="e80625fd7e8e2e9a68261ea8336b974ac71427ae" translate="yes" xml:space="preserve">
          <source>Array protocol: Python side</source>
          <target state="translated">Протокол массива:сторона питона</target>
        </trans-unit>
        <trans-unit id="4090e62e110e0132c9a83e32a1060b0b2b11ae1b" translate="yes" xml:space="preserve">
          <source>Array protocol: struct</source>
          <target state="translated">Массивный протокол:структурировать</target>
        </trans-unit>
        <trans-unit id="8bf3a8f5e4206285d07a06e43310e4a207d5bd53" translate="yes" xml:space="preserve">
          <source>Array representing the Chebyshev series of their sum.</source>
          <target state="translated">Массив,представляющий чебышевскую серию их суммы.</target>
        </trans-unit>
        <trans-unit id="eb3f194c486d46ce1508a5889e8d0e228c628dfe" translate="yes" xml:space="preserve">
          <source>Array representing the Hermite series of their sum.</source>
          <target state="translated">Массив,представляющий эрмитажную серию их суммы.</target>
        </trans-unit>
        <trans-unit id="18e93cb56abb59b15e14ea61f7ed36817dbde4e6" translate="yes" xml:space="preserve">
          <source>Array representing the Laguerre series of their sum.</source>
          <target state="translated">Массив,представляющий серию Лагерр их суммы.</target>
        </trans-unit>
        <trans-unit id="ec5ec69f7e2ff45ce04c960bdf2303ea70114cd3" translate="yes" xml:space="preserve">
          <source>Array representing the Legendre series of their sum.</source>
          <target state="translated">Массив,представляющий серию &quot;Легенда&quot; их суммы.</target>
        </trans-unit>
        <trans-unit id="edc338d6dbe8df5cb4ad885aef823a83fa3236d0" translate="yes" xml:space="preserve">
          <source>Array representing the result of the multiplication.</source>
          <target state="translated">Массив,представляющий результат умножения.</target>
        </trans-unit>
        <trans-unit id="016974069d41d6a6d61d2549905026f66c136979" translate="yes" xml:space="preserve">
          <source>Array scalar checks the value, array does not</source>
          <target state="translated">Скаляр массива проверяет значение,массив нет</target>
        </trans-unit>
        <trans-unit id="cc176eaf5a192bedc6a645855de021bd9ca0e1d1" translate="yes" xml:space="preserve">
          <source>Array scalar type</source>
          <target state="translated">Массивный скалярный тип</target>
        </trans-unit>
        <trans-unit id="2ef4e544d40cf2979c0c92b90830370b3508c12a" translate="yes" xml:space="preserve">
          <source>Array scalars can be indexed like 0-dimensional arrays: if &lt;em&gt;x&lt;/em&gt; is an array scalar,</source>
          <target state="translated">Скаляры массива могут быть индексированы как 0-мерные массивы: если &lt;em&gt;x&lt;/em&gt; - скаляр массива,</target>
        </trans-unit>
        <trans-unit id="e33eacc8d6c4dbb6e2b8986e0cc11de2dc224ecc" translate="yes" xml:space="preserve">
          <source>Array scalars have exactly the same methods as arrays. The default behavior of these methods is to internally convert the scalar to an equivalent 0-dimensional array and to call the corresponding array method. In addition, math operations on array scalars are defined so that the same hardware flags are set and used to interpret the results as for &lt;a href=&quot;ufuncs#ufuncs&quot;&gt;ufunc&lt;/a&gt;, so that the error state used for ufuncs also carries over to the math on array scalars.</source>
          <target state="translated">Скаляры массивов имеют те же методы, что и массивы. По умолчанию эти методы выполняют внутреннее преобразование скаляра в эквивалентный 0-мерный массив и вызывают соответствующий метод массива. Кроме того, математические операции над скалярами массива определены таким образом, что те же аппаратные флаги устанавливаются и используются для интерпретации результатов, что и для &lt;a href=&quot;ufuncs#ufuncs&quot;&gt;ufunc&lt;/a&gt; , так что состояние ошибки, используемое для ufunc, также переносится на математику на скалярах массива.</target>
        </trans-unit>
        <trans-unit id="037bfe1a4a99bed13c2116a48ffe9e15e096321a" translate="yes" xml:space="preserve">
          <source>Array scalars have the same attributes and methods as &lt;a href=&quot;generated/numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;ndarrays&lt;/code&gt;&lt;/a&gt;. &lt;a href=&quot;#id2&quot; id=&quot;id1&quot;&gt;1&lt;/a&gt; This allows one to treat items of an array partly on the same footing as arrays, smoothing out rough edges that result when mixing scalar and array operations.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9e3e59079f5e7b1524c0f3bc70e22cf06a0ad4de" translate="yes" xml:space="preserve">
          <source>Array scalars have the same attributes and methods as &lt;a href=&quot;generated/numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;ndarrays&lt;/code&gt;&lt;/a&gt;. &lt;a href=&quot;#id2&quot; id=&quot;id1&quot;&gt;[1]&lt;/a&gt; This allows one to treat items of an array partly on the same footing as arrays, smoothing out rough edges that result when mixing scalar and array operations.</source>
          <target state="translated">&lt;a href=&quot;generated/numpy.ndarray#numpy.ndarray&quot;&gt; &lt;code&gt;ndarrays&lt;/code&gt; &lt;/a&gt; массивов имеют те же атрибуты и методы, что и ndarrays . &lt;a href=&quot;#id2&quot; id=&quot;id1&quot;&gt;[1]&lt;/a&gt; Это позволяет обрабатывать элементы массива частично на том же основании, что и массивы, сглаживая грубые края, возникающие при смешивании скалярных операций и операций с массивами.</target>
        </trans-unit>
        <trans-unit id="9ed6ac908bf9aa1daed6dabda3ab37ae3cfe93cc" translate="yes" xml:space="preserve">
          <source>Array scalars live in a hierarchy (see the Figure below) of data types. They can be detected using the hierarchy: For example, &lt;code&gt;isinstance(val, np.generic)&lt;/code&gt; will return &lt;code&gt;True&lt;/code&gt; if &lt;em&gt;val&lt;/em&gt; is an array scalar object. Alternatively, what kind of array scalar is present can be determined using other members of the data type hierarchy. Thus, for example &lt;code&gt;isinstance(val, np.complexfloating)&lt;/code&gt; will return &lt;code&gt;True&lt;/code&gt; if &lt;em&gt;val&lt;/em&gt; is a complex valued type, while &lt;code&gt;isinstance(val, np.flexible)&lt;/code&gt; will return true if &lt;em&gt;val&lt;/em&gt; is one of the flexible itemsize array types (&lt;code&gt;string&lt;/code&gt;, &lt;code&gt;unicode&lt;/code&gt;, &lt;code&gt;void&lt;/code&gt;).</source>
          <target state="translated">Скаляры массивов находятся в иерархии типов данных (см. Рисунок ниже). Их можно обнаружить с помощью иерархии: например, &lt;code&gt;isinstance(val, np.generic)&lt;/code&gt; вернет &lt;code&gt;True&lt;/code&gt; , если &lt;em&gt;val&lt;/em&gt; является скалярным объектом массива. В качестве альтернативы, какой вид скаляра массива присутствует, можно определить с помощью других элементов иерархии типов данных. Таким образом, например, &lt;code&gt;isinstance(val, np.complexfloating)&lt;/code&gt; вернет &lt;code&gt;True&lt;/code&gt; , если &lt;em&gt;val&lt;/em&gt; является типом со сложным значением, а &lt;code&gt;isinstance(val, np.flexible)&lt;/code&gt; вернет true, если &lt;em&gt;val&lt;/em&gt; является одним из типов массивов с гибкими размерами элементов ( &lt;code&gt;string&lt;/code&gt; , &lt;code&gt;unicode&lt;/code&gt; , &lt;code&gt;void&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="656531cc575d33e2858cc0fa46ccccf4a68a1757" translate="yes" xml:space="preserve">
          <source>Array shape.</source>
          <target state="translated">Форма массива.</target>
        </trans-unit>
        <trans-unit id="ef64ccc224961e26021d9bca9dc014037c55120d" translate="yes" xml:space="preserve">
          <source>Array structure and data access</source>
          <target state="translated">Массивная структура и доступ к данным</target>
        </trans-unit>
        <trans-unit id="342f29da2bf216f5bdf0ad7248aaa9e71a355727" translate="yes" xml:space="preserve">
          <source>Array that selects which entries to return. If len(condition) is less than the size of &lt;code&gt;a&lt;/code&gt; along the given axis, then output is truncated to the length of the condition array.</source>
          <target state="translated">Массив, который выбирает, какие записи возвращать. Если len (условие) меньше размера &lt;code&gt;a&lt;/code&gt; вдоль данной оси, то выходные данные обрезаются до длины массива условий.</target>
        </trans-unit>
        <trans-unit id="592206156ca99ae21d8e7426eb607780c1bba521" translate="yes" xml:space="preserve">
          <source>Array that suppressed values indicated by a mask:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="87d2918cacf26a2502b4f9340bca07e66e5e74fe" translate="yes" xml:space="preserve">
          <source>Array to be divided into sub-arrays.</source>
          <target state="translated">Массив разделить на подмассивы.</target>
        </trans-unit>
        <trans-unit id="e4b60ba832fd5d14a8b64e94627ba0a71256396f" translate="yes" xml:space="preserve">
          <source>Array to be reshaped.</source>
          <target state="translated">Массив,который нужно переделать.</target>
        </trans-unit>
        <trans-unit id="873958f5c5efd8efa35f71b483ecb2b2925a1b71" translate="yes" xml:space="preserve">
          <source>Array to be resized.</source>
          <target state="translated">Массив для изменения размера.</target>
        </trans-unit>
        <trans-unit id="b52f152b24d91c43ef9fb5209bce09865fb8369b" translate="yes" xml:space="preserve">
          <source>Array to be sorted.</source>
          <target state="translated">Массив для сортировки.</target>
        </trans-unit>
        <trans-unit id="6b0f55aa6f40b643ba50d2b1a53516ef1346869f" translate="yes" xml:space="preserve">
          <source>Array to check for masked values.</source>
          <target state="translated">Массив для проверки маскированных значений.</target>
        </trans-unit>
        <trans-unit id="20f86a6d67f17e927d1d04df5d4b886d82463103" translate="yes" xml:space="preserve">
          <source>Array to create a new.</source>
          <target state="translated">Массив для создания нового.</target>
        </trans-unit>
        <trans-unit id="a70bc91712a140c808e5cb79192527e68b6c9390" translate="yes" xml:space="preserve">
          <source>Array to mask</source>
          <target state="translated">Маска для маскировки</target>
        </trans-unit>
        <trans-unit id="d43e409e24f30f0a6d90180b76c2efb4ab130452" translate="yes" xml:space="preserve">
          <source>Array to mask.</source>
          <target state="translated">Маска для маскировки.</target>
        </trans-unit>
        <trans-unit id="83c52b56e1210abcac3501b49e1d67729c904dfd" translate="yes" xml:space="preserve">
          <source>Array to put data into.</source>
          <target state="translated">Массив для ввода данных.</target>
        </trans-unit>
        <trans-unit id="fd5b40620a3c780ffc94d7f339fd1c7607c14c60" translate="yes" xml:space="preserve">
          <source>Array to sort.</source>
          <target state="translated">Массив для сортировки.</target>
        </trans-unit>
        <trans-unit id="63fbdd1db19d27a9a5c7eab3d132c8bb3f503729" translate="yes" xml:space="preserve">
          <source>Array to test.</source>
          <target state="translated">Массив для проверки.</target>
        </trans-unit>
        <trans-unit id="55a565dc87ad0f5b9c2ac3f528dacc1158c373a0" translate="yes" xml:space="preserve">
          <source>Array type testing</source>
          <target state="translated">Тестирование типа массива</target>
        </trans-unit>
        <trans-unit id="585f95a404e839b1977230612e779c3487e0200e" translate="yes" xml:space="preserve">
          <source>Array types and conversions between types</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="023792f2b2e17a7b6e86f7c45b577b4c007acb28" translate="yes" xml:space="preserve">
          <source>Array types can also be referred to by character codes, mostly to retain backward compatibility with older packages such as Numeric. Some documentation may still refer to these, for example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e4bb8dd78a4c9a8f67c530c9ad1b7a619c52bea4" translate="yes" xml:space="preserve">
          <source>Array whose diagonal is to be filled, it gets modified in-place.</source>
          <target state="translated">Массив,диагональ которого должна быть заполнена,изменяется на месте.</target>
        </trans-unit>
        <trans-unit id="82c627b6cd9b7d074082f31470ca27bba3557192" translate="yes" xml:space="preserve">
          <source>Array with its lower triangle filled with ones and zero elsewhere; in other words &lt;code&gt;T[i,j] == 1&lt;/code&gt; for &lt;code&gt;i &amp;lt;= j + k&lt;/code&gt;, 0 otherwise.</source>
          <target state="translated">Массив, нижний треугольник которого заполнен единицами и нулями в другом месте; другими словами, &lt;code&gt;T[i,j] == 1&lt;/code&gt; для &lt;code&gt;i &amp;lt;= j + k&lt;/code&gt; , 0 в противном случае.</target>
        </trans-unit>
        <trans-unit id="b85c2934c5f2a59bc2e12dac7625860a488c925e" translate="yes" xml:space="preserve">
          <source>Array with its lower triangle filled with ones and zero elsewhere; in other words &lt;code&gt;T[i,j] == 1&lt;/code&gt; for &lt;code&gt;j &amp;lt;= i + k&lt;/code&gt;, 0 otherwise.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="41b54b4163faf0b1aa96452981f42d33d50824ef" translate="yes" xml:space="preserve">
          <source>Array with moved axes. This array is a view of the input array.</source>
          <target state="translated">Массив с подвижными осями.Этот массив представляет собой вид входного массива.</target>
        </trans-unit>
        <trans-unit id="84addce66651c27032bab9126d05042eeca1af0e" translate="yes" xml:space="preserve">
          <source>Array with specified requirements and type if given.</source>
          <target state="translated">Массив с указанными требованиями и типом,если он задан.</target>
        </trans-unit>
        <trans-unit id="45f77fd17de7e78ac597a13bf5b178d24ee5d7aa" translate="yes" xml:space="preserve">
          <source>Array-checking restype/argtypes.</source>
          <target state="translated">Проверка массивов рестайпа/аргтипов.</target>
        </trans-unit>
        <trans-unit id="54d7e23aa660ea078adfa79ac4b2e54c5ef44772" translate="yes" xml:space="preserve">
          <source>Array-protocol type strings (see &lt;a href=&quot;arrays.interface#arrays-interface&quot;&gt;The Array Interface&lt;/a&gt;)</source>
          <target state="translated">Строки типа протокола массива (см &lt;a href=&quot;arrays.interface#arrays-interface&quot;&gt;. Интерфейс массива&lt;/a&gt; )</target>
        </trans-unit>
        <trans-unit id="7bf6ce513964e0342411a0531bf1b89c426a52c9" translate="yes" xml:space="preserve">
          <source>Array-scalar types</source>
          <target state="translated">Массивно-скалярные типы</target>
        </trans-unit>
        <trans-unit id="a50913b40e0e8d9dc26876d10bb49f2fa38c66fb" translate="yes" xml:space="preserve">
          <source>Array_like means all those objects &amp;ndash; lists, nested lists, etc. &amp;ndash; that can be converted to an array. We can also refer to variables like &lt;code&gt;var1&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="31b1e39950526e77b6041b42fc1b62056a817d46" translate="yes" xml:space="preserve">
          <source>Arrays &lt;code&gt;x1&lt;/code&gt; and &lt;code&gt;x2&lt;/code&gt; must have the same shape.</source>
          <target state="translated">Массивы &lt;code&gt;x1&lt;/code&gt; и &lt;code&gt;x2&lt;/code&gt; должны иметь одинаковую форму.</target>
        </trans-unit>
        <trans-unit id="f2499f813f17514e2097a1073a6cd307b768602d" translate="yes" xml:space="preserve">
          <source>Arrays based off readonly buffers cannot be set &lt;code&gt;writeable&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f1c67ac3218c1c87b31cea1d27a13f34756f157a" translate="yes" xml:space="preserve">
          <source>Arrays can be both C-style and Fortran-style contiguous simultaneously. This is clear for 1-dimensional arrays, but can also be true for higher dimensional arrays.</source>
          <target state="translated">Массивы могут быть одновременно С-образными и Фортран-образными.Это понятно для 1-мерных массивов,но может быть верно и для массивов более высоких размеров.</target>
        </trans-unit>
        <trans-unit id="9cba266ac8d90f704b5607af4e06eea419c285f7" translate="yes" xml:space="preserve">
          <source>Arrays can be indexed using an extended Python slicing syntax, &lt;code&gt;array[selection]&lt;/code&gt;. Similar syntax is also used for accessing fields in a &lt;a href=&quot;../glossary#term-structured-data-type&quot;&gt;structured data type&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aac913dee168d782f611f9dc70790bf862c5b21d" translate="yes" xml:space="preserve">
          <source>Arrays can be indexed using an extended Python slicing syntax, &lt;code&gt;array[selection]&lt;/code&gt;. Similar syntax is also used for accessing fields in a &lt;a href=&quot;https://docs.scipy.org/doc/numpy-1.17.0/glossary.html#term-structured-data-type&quot;&gt;structured data type&lt;/a&gt;.</source>
          <target state="translated">Массивы могут быть проиндексированы с использованием расширенного синтаксиса нарезки Python, &lt;code&gt;array[selection]&lt;/code&gt; . Аналогичный синтаксис также используется для доступа к полям &lt;a href=&quot;https://docs.scipy.org/doc/numpy-1.17.0/glossary.html#term-structured-data-type&quot;&gt;структурированного типа данных&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="d674e5d59a78e41b46aaf270748b55f0fb8f59d0" translate="yes" xml:space="preserve">
          <source>Arrays do not need to have the same &lt;em&gt;number&lt;/em&gt; of dimensions. For example, if you have a &lt;code&gt;256x256x3&lt;/code&gt; array of RGB values, and you want to scale each color in the image by a different value, you can multiply the image by a one-dimensional array with 3 values. Lining up the sizes of the trailing axes of these arrays according to the broadcast rules, shows that they are compatible:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="00ec5e3a73cb29954290e60a6bc0ab13e3437ef3" translate="yes" xml:space="preserve">
          <source>Arrays may have a data-types containing fields, analogous to columns in a spread sheet. An example is &lt;code&gt;[(x, int), (y, float)]&lt;/code&gt;, where each entry in the array is a pair of &lt;code&gt;(int, float)&lt;/code&gt;. Normally, these attributes are accessed using dictionary lookups such as &lt;code&gt;arr['x']&lt;/code&gt; and &lt;code&gt;arr['y']&lt;/code&gt;. Record arrays allow the fields to be accessed as members of the array, using &lt;code&gt;arr.x&lt;/code&gt; and &lt;code&gt;arr.y&lt;/code&gt;.</source>
          <target state="translated">Массивы могут иметь типы данных, содержащие поля, аналогичные столбцам в электронной таблице. Примером является &lt;code&gt;[(x, int), (y, float)]&lt;/code&gt; , где каждая запись в массиве представляет собой пару &lt;code&gt;(int, float)&lt;/code&gt; . Обычно доступ к этим атрибутам осуществляется с помощью словаря, например &lt;code&gt;arr['x']&lt;/code&gt; и &lt;code&gt;arr['y']&lt;/code&gt; . Запись массивы позволяют поля быть доступны в качестве членов массива, используя &lt;code&gt;arr.x&lt;/code&gt; и &lt;code&gt;arr.y&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b36ecf0a7f7bd039ed5c1c0704a51fefda73d80e" translate="yes" xml:space="preserve">
          <source>Arrays may have more than one dimension, each which can be sliced individually:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ef7c0cea98d6d20ecb3d174c3213bef74e8bc018" translate="yes" xml:space="preserve">
          <source>Arrays of byte-strings are not swapped</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d404bf1fb512f78d1d6fefbd98ddbbf1ae665dd2" translate="yes" xml:space="preserve">
          <source>Arrays of evenly spaced numbers in N-dimensions.</source>
          <target state="translated">Массивы равномерно распределенных чисел в N-размерах.</target>
        </trans-unit>
        <trans-unit id="b8de1bbbfd3c637354288fac451e8a7c60ba28fc" translate="yes" xml:space="preserve">
          <source>Arrays of point coordinates, all of the same shape. The dtypes will be converted to either float64 or complex128 depending on whether any of the elements are complex. Scalars are converted to 1-D arrays.</source>
          <target state="translated">Массивы координат точек,все одинаковой формы.Типы будут преобразованы либо в float64,либо в complex128 в зависимости от того,является ли какой-либо из элементов сложным.Скаляры преобразуются в 1-D массивы.</target>
        </trans-unit>
        <trans-unit id="52434d147f7a6b19ab25a12561971251796b7c3c" translate="yes" xml:space="preserve">
          <source>Arrays of strings are not swapped</source>
          <target state="translated">Массивы струн не поменялись местами</target>
        </trans-unit>
        <trans-unit id="fc13f22057f28c646ca1b198ca565af87af49f1b" translate="yes" xml:space="preserve">
          <source>Arrays of values. If &lt;code&gt;x1.shape != x2.shape&lt;/code&gt;, they must be broadcastable to a common shape (which becomes the shape of the output).</source>
          <target state="translated">Массивы значений. Если &lt;code&gt;x1.shape != x2.shape&lt;/code&gt; , они должны транслироваться в общую форму (которая становится формой вывода).</target>
        </trans-unit>
        <trans-unit id="e6f0032138e45d68f74e2c44f2f735c8b5313272" translate="yes" xml:space="preserve">
          <source>Arrays should be constructed using &lt;a href=&quot;numpy.array#numpy.array&quot;&gt;&lt;code&gt;array&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;numpy.zeros#numpy.zeros&quot;&gt;&lt;code&gt;zeros&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;numpy.empty#numpy.empty&quot;&gt;&lt;code&gt;empty&lt;/code&gt;&lt;/a&gt; (refer to the See Also section below). The parameters given here refer to a low-level method (&lt;code&gt;ndarray(&amp;hellip;)&lt;/code&gt;) for instantiating an array.</source>
          <target state="translated">Массивы должны быть построены с использованием &lt;a href=&quot;numpy.array#numpy.array&quot;&gt; &lt;code&gt;array&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;numpy.zeros#numpy.zeros&quot;&gt; &lt;code&gt;zeros&lt;/code&gt; &lt;/a&gt; или &lt;a href=&quot;numpy.empty#numpy.empty&quot;&gt; &lt;code&gt;empty&lt;/code&gt; &lt;/a&gt; (см. Также раздел ниже). Приведенные здесь параметры относятся к низкоуровневому методу ( &lt;code&gt;ndarray(&amp;hellip;)&lt;/code&gt; ) для создания экземпляра массива.</target>
        </trans-unit>
        <trans-unit id="bcfb0f71df3562232665c06d9cf63f39acceecc4" translate="yes" xml:space="preserve">
          <source>Arrays to be compared.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c2fde1777833050ff202f7b922dc5d2847610f32" translate="yes" xml:space="preserve">
          <source>Arrays to save to the file. Arrays will be saved in the file with the keyword names.</source>
          <target state="translated">Массивы для сохранения в файл.Массивы будут сохранены в файле с именами ключевых слов.</target>
        </trans-unit>
        <trans-unit id="4ba46cb118e6a4c1684691ff4c3a66ca5c9411f7" translate="yes" xml:space="preserve">
          <source>Arrays to save to the file. Since it is not possible for Python to know the names of the arrays outside &lt;a href=&quot;#numpy.savez&quot;&gt;&lt;code&gt;savez&lt;/code&gt;&lt;/a&gt;, the arrays will be saved with names &amp;ldquo;arr_0&amp;rdquo;, &amp;ldquo;arr_1&amp;rdquo;, and so on. These arguments can be any expression.</source>
          <target state="translated">Массивы для сохранения в файл. Поскольку Python не может знать имена массивов вне &lt;a href=&quot;#numpy.savez&quot;&gt; &lt;code&gt;savez&lt;/code&gt; &lt;/a&gt; , массивы будут сохранены с именами &amp;laquo;arr_0&amp;raquo;, &amp;laquo;arr_1&amp;raquo; и так далее. Эти аргументы могут быть любым выражением.</target>
        </trans-unit>
        <trans-unit id="f51d18ef0f932163df8ae83aea003301ffa197e5" translate="yes" xml:space="preserve">
          <source>Arrays to save to the file. Since it is not possible for Python to know the names of the arrays outside &lt;a href=&quot;numpy.savez#numpy.savez&quot;&gt;&lt;code&gt;savez&lt;/code&gt;&lt;/a&gt;, the arrays will be saved with names &amp;ldquo;arr_0&amp;rdquo;, &amp;ldquo;arr_1&amp;rdquo;, and so on. These arguments can be any expression.</source>
          <target state="translated">Массивы для сохранения в файл. Поскольку Python не может знать имена массивов вне &lt;a href=&quot;numpy.savez#numpy.savez&quot;&gt; &lt;code&gt;savez&lt;/code&gt; &lt;/a&gt; , массивы будут сохранены с именами &amp;laquo;arr_0&amp;raquo;, &amp;laquo;arr_1&amp;raquo; и так далее. Эти аргументы могут быть любым выражением.</target>
        </trans-unit>
        <trans-unit id="44d87a6dc57d91b7292b09dc95f59e76af66bd2d" translate="yes" xml:space="preserve">
          <source>Arrays to stack. All of them must have the same first dimension.</source>
          <target state="translated">Массивы складывать.Все они должны иметь одно и то же первое измерение.</target>
        </trans-unit>
        <trans-unit id="b99248188fbd19d8c22a40832b75d837dc4de460" translate="yes" xml:space="preserve">
          <source>Arrays with complex dtypes don&amp;rsquo;t return True.</source>
          <target state="translated">Массивы со сложными типами данных не возвращают True.</target>
        </trans-unit>
        <trans-unit id="a2bd40fc5b54aa90919de15beac751e23ad15489" translate="yes" xml:space="preserve">
          <source>Arrayterator (class in numpy.lib)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="816e3f055425505d10d82fdb50f19dc782762aaa" translate="yes" xml:space="preserve">
          <source>Arrayterator.flat</source>
          <target state="translated">Arrayterator.flat</target>
        </trans-unit>
        <trans-unit id="e63ac43cdcb5a4238c7b9262748f81e7cf3457ea" translate="yes" xml:space="preserve">
          <source>Arrayterator.shape</source>
          <target state="translated">Arrayterator.shape</target>
        </trans-unit>
        <trans-unit id="62735fb443777d7de2d1c29ccbb762ccfb2be570" translate="yes" xml:space="preserve">
          <source>As &lt;a href=&quot;#numpy.ma.MaskedArray&quot;&gt;&lt;code&gt;MaskedArray&lt;/code&gt;&lt;/a&gt; is a subclass of &lt;a href=&quot;generated/numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;ndarray&lt;/code&gt;&lt;/a&gt;, a masked array also inherits all the attributes and properties of a &lt;a href=&quot;generated/numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;ndarray&lt;/code&gt;&lt;/a&gt; instance.</source>
          <target state="translated">Поскольку &lt;a href=&quot;#numpy.ma.MaskedArray&quot;&gt; &lt;code&gt;MaskedArray&lt;/code&gt; &lt;/a&gt; является подклассом &lt;a href=&quot;generated/numpy.ndarray#numpy.ndarray&quot;&gt; &lt;code&gt;ndarray&lt;/code&gt; &lt;/a&gt; , замаскированный массив также наследует все атрибуты и свойства экземпляра &lt;a href=&quot;generated/numpy.ndarray#numpy.ndarray&quot;&gt; &lt;code&gt;ndarray&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="bdc5d12d9a06d1a300c059aee30b6e3298b8cd56" translate="yes" xml:space="preserve">
          <source>As Numeric has matured and developed into NumPy, people have been able to write more code directly in NumPy. Often this code is fast-enough for production use, but there are still times that there is a need to access compiled code. Either to get that last bit of efficiency out of the algorithm or to make it easier to access widely-available codes written in C/C++ or Fortran.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="266410aaeb848f2f7510db1bcf8e20c2778f75df" translate="yes" xml:space="preserve">
          <source>As a &lt;a href=&quot;maskedarray.baseclass#numpy.ma.MaskedArray&quot;&gt;&lt;code&gt;MaskedArray&lt;/code&gt;&lt;/a&gt; is a subclass of &lt;a href=&quot;generated/numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;numpy.ndarray&lt;/code&gt;&lt;/a&gt;, it inherits its mechanisms for indexing and slicing.</source>
          <target state="translated">Поскольку &lt;a href=&quot;maskedarray.baseclass#numpy.ma.MaskedArray&quot;&gt; &lt;code&gt;MaskedArray&lt;/code&gt; &lt;/a&gt; является подклассом &lt;a href=&quot;generated/numpy.ndarray#numpy.ndarray&quot;&gt; &lt;code&gt;numpy.ndarray&lt;/code&gt; &lt;/a&gt; , он наследует его механизмы индексации и нарезки.</target>
        </trans-unit>
        <trans-unit id="572a6b072b5d5bfb6b919bf3e8415158c50e5fd9" translate="yes" xml:space="preserve">
          <source>As a convenience for &lt;code&gt;__array_function__&lt;/code&gt; implementors, &lt;code&gt;types&lt;/code&gt; provides all argument types with an &lt;code&gt;'__array_function__'&lt;/code&gt; attribute. This allows implementors to quickly identify cases where they should defer to &lt;code&gt;__array_function__&lt;/code&gt; implementations on other arguments. Implementations should not rely on the iteration order of &lt;code&gt;types&lt;/code&gt;.</source>
          <target state="translated">Для удобства для &lt;code&gt;__array_function__&lt;/code&gt; реализаторов, &lt;code&gt;types&lt;/code&gt; предоставляют все типы аргументов с &lt;code&gt;'__array_function__'&lt;/code&gt; атрибутом. Это позволяет разработчикам быстро определять случаи, когда они должны отложить реализацию &lt;code&gt;__array_function__&lt;/code&gt; на другие аргументы. Реализации не должны полагаться на порядок итерации &lt;code&gt;types&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="943758d1e20ad4276263519968fa94f16b718bb2" translate="yes" xml:space="preserve">
          <source>As a corollary to this change, we no longer prohibit casting between datetimes with date units and datetimes with timeunits. With timezone naive datetimes, the rule for casting from dates to times is no longer ambiguous.</source>
          <target state="translated">Как следствие этого изменения,мы больше не запрещаем литье между датами с единицами даты и датами с единицами времени.В случае с наивными таймфреймами,правило для кастинга между датами и временем больше не является двусмысленным.</target>
        </trans-unit>
        <trans-unit id="013d98a5ec5b7f58afd0279b5cb85ae341df8643" translate="yes" xml:space="preserve">
          <source>As a final note: if the &lt;code&gt;super&lt;/code&gt; route is suited to a given class, an advantage of using it is that it helps in constructing class hierarchies. E.g., suppose that our other class &lt;code&gt;B&lt;/code&gt; also used the &lt;code&gt;super&lt;/code&gt; in its &lt;code&gt;__array_ufunc__&lt;/code&gt; implementation, and we created a class &lt;code&gt;C&lt;/code&gt; that depended on both, i.e., &lt;code&gt;class C(A, B)&lt;/code&gt; (with, for simplicity, not another &lt;code&gt;__array_ufunc__&lt;/code&gt; override). Then any ufunc on an instance of &lt;code&gt;C&lt;/code&gt; would pass on to &lt;code&gt;A.__array_ufunc__&lt;/code&gt;, the &lt;code&gt;super&lt;/code&gt; call in &lt;code&gt;A&lt;/code&gt; would go to &lt;code&gt;B.__array_ufunc__&lt;/code&gt;, and the &lt;code&gt;super&lt;/code&gt; call in &lt;code&gt;B&lt;/code&gt; would go to &lt;code&gt;ndarray.__array_ufunc__&lt;/code&gt;, thus allowing &lt;code&gt;A&lt;/code&gt; and &lt;code&gt;B&lt;/code&gt; to collaborate.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="20a42179492180fa8aaa4dc644b08e20ca1aef18" translate="yes" xml:space="preserve">
          <source>As an alternative to &lt;code&gt;pytest.mark.&amp;lt;label&amp;gt;&lt;/code&gt;, there are a number of labels you can use.</source>
          <target state="translated">В качестве альтернативы &lt;code&gt;pytest.mark.&amp;lt;label&amp;gt;&lt;/code&gt; вы можете использовать несколько ярлыков.</target>
        </trans-unit>
        <trans-unit id="3dab1c17c36782c312875481e08692d9b809435e" translate="yes" xml:space="preserve">
          <source>As an example, for &lt;code&gt;numpy.mean&lt;/code&gt; we would have:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fecff8f943e371686abc1110d1711ebbbb86c5fa" translate="yes" xml:space="preserve">
          <source>As an example, see the 1.14.3 REL commit: &lt;a href=&quot;https://github.com/numpy/numpy/commit/73299826729be58cec179b52c656adfcaefada93&quot;&gt;https://github.com/numpy/numpy/commit/73299826729be58cec179b52c656adfcaefada93&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f7ec8e32822a5e0a0d90b5363a2541452778cbc3" translate="yes" xml:space="preserve">
          <source>As an example, we print out the result of broadcasting a one and a two dimensional array together.</source>
          <target state="translated">В качестве примера выведем результат трансляции одно-и двухмерного массива.</target>
        </trans-unit>
        <trans-unit id="8f262d8c602a1c1784a0611d8d573ccc9d004b7a" translate="yes" xml:space="preserve">
          <source>As an illustration, let&amp;rsquo;s consider the following dataset:</source>
          <target state="translated">В качестве иллюстрации рассмотрим следующий набор данных:</target>
        </trans-unit>
        <trans-unit id="06bd4fa6779fdd07b3d52175c70a52bf6deacdac" translate="yes" xml:space="preserve">
          <source>As an optional convenience numpy provides an ndarray subclass, &lt;a href=&quot;../reference/generated/numpy.recarray#numpy.recarray&quot;&gt;&lt;code&gt;numpy.recarray&lt;/code&gt;&lt;/a&gt;, and associated helper functions in the &lt;code&gt;numpy.rec&lt;/code&gt; submodule, that allows access to fields of structured arrays by attribute instead of only by index. Record arrays also use a special datatype, &lt;a href=&quot;../reference/generated/numpy.record#numpy.record&quot;&gt;&lt;code&gt;numpy.record&lt;/code&gt;&lt;/a&gt;, that allows field access by attribute on the structured scalars obtained from the array.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ff6fd804dd39db5798ff08b4b25e0937a2c068e3" translate="yes" xml:space="preserve">
          <source>As an trivial example, consider this implementation of an &lt;code&gt;ArrayLike&lt;/code&gt; class that simply wraps a NumPy array and ensures that the result of any arithmetic operation is also an &lt;code&gt;ArrayLike&lt;/code&gt; object:</source>
          <target state="translated">В качестве тривиального примера рассмотрим эту реализацию класса &lt;code&gt;ArrayLike&lt;/code&gt; , который просто обертывает массив NumPy и гарантирует, что результат любой арифметической операции также является объектом &lt;code&gt;ArrayLike&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="cede8d515f0ee49ac10c9ddedbb9f437527bae9a" translate="yes" xml:space="preserve">
          <source>As can be seen, the &amp;ldquo;good&amp;rdquo; parts have shrunk to insignificance. In using Chebyshev polynomials for fitting we want to use the region where &lt;code&gt;x&lt;/code&gt; is between -1 and 1 and that is what the &lt;code&gt;window&lt;/code&gt; specifies. However, it is unlikely that the data to be fit has all its data points in that interval, so we use &lt;code&gt;domain&lt;/code&gt; to specify the interval where the data points lie. When the fit is done, the domain is first mapped to the window by a linear transformation and the usual least squares fit is done using the mapped data points. The window and domain of the fit are part of the returned series and are automatically used when computing values, derivatives, and such. If they aren&amp;rsquo;t specified in the call the fitting routine will use the default window and the smallest domain that holds all the data points. This is illustrated below for a fit to a noisy sine curve.</source>
          <target state="translated">Как видно, &amp;laquo;хорошие&amp;raquo; детали уменьшились до незначительности. При использовании полиномов Чебышева для подбора мы хотим использовать область, где &lt;code&gt;x&lt;/code&gt; находится между -1 и 1, и это то, что определяет &lt;code&gt;window&lt;/code&gt; . Однако маловероятно, что все данные для подгонки находятся в этом интервале, поэтому мы используем &lt;code&gt;domain&lt;/code&gt; чтобы указать интервал, в котором лежат точки данных. Когда подгонка выполнена, домен сначала отображается в окно с помощью линейного преобразования, а обычная подгонка методом наименьших квадратов выполняется с использованием сопоставленных точек данных. Окно и область соответствия являются частью возвращаемого ряда и автоматически используются при вычислении значений, производных и т. Д. Если они не указаны в вызове, процедура подбора будет использовать окно по умолчанию и наименьший домен, содержащий все точки данных. Это показано ниже для аппроксимации синусоидальной кривой с шумом.</target>
        </trans-unit>
        <trans-unit id="e0bc58a150fd519b1ef1b28d23e1c4528291bcac" translate="yes" xml:space="preserve">
          <source>As expected, this is a 768x1024 matrix:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c53fc1e45dbe406be17b6e30a5cfb9d43c0f2859" translate="yes" xml:space="preserve">
          <source>As explained previously, C-style contiguous arrays and Fortran-style contiguous arrays have particular striding patterns. Two array flags (&lt;a href=&quot;../reference/c-api/array#c.NPY_ARRAY_C_CONTIGUOUS&quot;&gt;&lt;code&gt;NPY_ARRAY_C_CONTIGUOUS&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../reference/c-api/array#c.NPY_ARRAY_F_CONTIGUOUS&quot;&gt;&lt;code&gt;NPY_ARRAY_F_CONTIGUOUS&lt;/code&gt;&lt;/a&gt;) indicate whether or not the striding pattern of a particular array matches the C-style contiguous or Fortran-style contiguous or neither. Whether or not the striding pattern matches a standard C or Fortran one can be tested Using &lt;a href=&quot;../reference/c-api/array#c.PyArray_IS_C_CONTIGUOUS&quot;&gt;&lt;code&gt;PyArray_IS_C_CONTIGUOUS&lt;/code&gt;&lt;/a&gt; (obj) and &lt;a href=&quot;../reference/c-api/array#c.PyArray_ISFORTRAN&quot;&gt;&lt;code&gt;PyArray_ISFORTRAN&lt;/code&gt;&lt;/a&gt; (obj) respectively. Most third-party libraries expect contiguous arrays. But, often it is not difficult to support general-purpose striding. I encourage you to use the striding information in your own code whenever possible, and reserve single-segment requirements for wrapping third-party code. Using the striding information provided with the ndarray rather than requiring a contiguous striding reduces copying that otherwise must be made.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6eb7f695a43a210c4ab19e5bc957617a28b1a107" translate="yes" xml:space="preserve">
          <source>As for &lt;code&gt;ndarray.tobytes&lt;/code&gt;, information about the shape, dtype, etc., but also about &lt;a href=&quot;../maskedarray.baseclass#numpy.ma.MaskedArray.fill_value&quot;&gt;&lt;code&gt;fill_value&lt;/code&gt;&lt;/a&gt;, will be lost.</source>
          <target state="translated">Что касается &lt;code&gt;ndarray.tobytes&lt;/code&gt; , информация о форме, dtype и т. Д., А также о &lt;a href=&quot;../maskedarray.baseclass#numpy.ma.MaskedArray.fill_value&quot;&gt; &lt;code&gt;fill_value&lt;/code&gt; &lt;/a&gt; будет потеряна.</target>
        </trans-unit>
        <trans-unit id="442dd71dc758bc00985af7b82e3b46e788353af0" translate="yes" xml:space="preserve">
          <source>As for &lt;code&gt;ndarray.tobytes&lt;/code&gt;, information about the shape, dtype, etc., but also about &lt;a href=&quot;numpy.ma.masked_array.fill_value#numpy.ma.masked_array.fill_value&quot;&gt;&lt;code&gt;fill_value&lt;/code&gt;&lt;/a&gt;, will be lost.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b59d207ef2133a3867224936518ca5838dca25c9" translate="yes" xml:space="preserve">
          <source>As it turns out, numpy is smart enough when dealing with ufuncs to determine which index is the most rapidly varying one in memory and uses that for the innermost loop. Thus for ufuncs there is no large intrinsic advantage to either approach in most cases. On the other hand, use of .flat with an FORTRAN ordered array will lead to non-optimal memory access as adjacent elements in the flattened array (iterator, actually) are not contiguous in memory.</source>
          <target state="translated">Как оказалось,numpy достаточно умен при работе с ufuncs,чтобы определить,какой из индексов наиболее быстро изменяется в памяти,и использует его для самого внутреннего цикла.Таким образом,для ufuncs в большинстве случаев нет большого внутреннего преимущества ни того,ни другого подхода.С другой стороны,использование .flat с упорядоченным массивом FORTRAN приведет к неоптимальному доступу к памяти,так как соседние элементы в расплавленном массиве (итератор,на самом деле)не сопрягаются в памяти.</target>
        </trans-unit>
        <trans-unit id="bae171d630e66c8dccf252742ea919c5676002d9" translate="yes" xml:space="preserve">
          <source>As mentioned in the Notes section, &lt;a href=&quot;#numpy.testing.assert_array_equal&quot;&gt;&lt;code&gt;assert_array_equal&lt;/code&gt;&lt;/a&gt; has special handling for scalars. Here the test checks that each value in &lt;code&gt;x&lt;/code&gt; is 3:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="13dc2b7c8c10ac2fc73aefee2fde7f627c9b6aa2" translate="yes" xml:space="preserve">
          <source>As mentioned previously, the flat attribute of ndarray objects returns an iterator that will cycle over the entire array in C-style contiguous order.</source>
          <target state="translated">Как уже упоминалось ранее,плоский атрибут объектов ndarray возвращает итератор,который будет циклически перемещаться по всему массиву в едином порядке в стиле Си.</target>
        </trans-unit>
        <trans-unit id="1eeb436878ddf7f47ab4d8c1fb337ec14f285994" translate="yes" xml:space="preserve">
          <source>As mentioned, one can select a subset of an array to assign to using a single index, slices, and index and mask arrays. The value being assigned to the indexed array must be shape consistent (the same shape or broadcastable to the shape the index produces). For example, it is permitted to assign a constant to a slice:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6bb256df55b0c84359db8c790668112e195bd64a" translate="yes" xml:space="preserve">
          <source>As noted above the inverse Gaussian distribution first arise from attempts to model Brownian motion. It is also a competitor to the Weibull for use in reliability modeling and modeling stock returns and interest rate processes.</source>
          <target state="translated">Как отмечалось выше,обратное гауссово распределение сначала возникает в результате попыток моделирования броуновского движения.Оно также является конкурентом Weibull за использование в моделировании надежности и моделировании доходности акций и процессов процентной ставки.</target>
        </trans-unit>
        <trans-unit id="ec730138fa95973e97f6613bc68aa1a1f0c5aafb" translate="yes" xml:space="preserve">
          <source>As of 1.6, this function simply calls &lt;a href=&quot;#c.PyArray_CopyInto&quot;&gt;&lt;code&gt;PyArray_CopyInto&lt;/code&gt;&lt;/a&gt;, which handles the casting.</source>
          <target state="translated">Начиная с &lt;a href=&quot;#c.PyArray_CopyInto&quot;&gt; &lt;code&gt;PyArray_CopyInto&lt;/code&gt; &lt;/a&gt; 1.6, эта функция просто вызывает PyArray_CopyInto , который обрабатывает приведение типов.</target>
        </trans-unit>
        <trans-unit id="3f3530b3b21291b3dd3b74336008cc7a706ed945" translate="yes" xml:space="preserve">
          <source>As of NumPy 1.10, the returned array will have the same type as the input array. (for example, a masked array will be returned for a masked array input)</source>
          <target state="translated">Начиная с NumPy 1.10,возвращаемый массив будет иметь тот же тип,что и входной массив.(например,для входного массива будет возвращен маскированный массив).</target>
        </trans-unit>
        <trans-unit id="12042a22f9b6865da757e69e8d2ce21273a85e0c" translate="yes" xml:space="preserve">
          <source>As of NumPy 1.4.0 &lt;a href=&quot;#numpy.argsort&quot;&gt;&lt;code&gt;argsort&lt;/code&gt;&lt;/a&gt; works with real/complex arrays containing nan values. The enhanced sort order is documented in &lt;a href=&quot;numpy.sort#numpy.sort&quot;&gt;&lt;code&gt;sort&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Начиная с NumPy 1.4.0 &lt;a href=&quot;#numpy.argsort&quot;&gt; &lt;code&gt;argsort&lt;/code&gt; &lt;/a&gt; работает с реальными / сложными массивами, содержащими значения nan. Расширенный порядок сортировки задокументирован в &lt;a href=&quot;numpy.sort#numpy.sort&quot;&gt; &lt;code&gt;sort&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="bba53cf9adf4ac58af71ddd4d6acfa9ee160b6ec" translate="yes" xml:space="preserve">
          <source>As of NumPy 1.4.0 &lt;a href=&quot;#numpy.searchsorted&quot;&gt;&lt;code&gt;searchsorted&lt;/code&gt;&lt;/a&gt; works with real/complex arrays containing &lt;a href=&quot;../constants#numpy.nan&quot;&gt;&lt;code&gt;nan&lt;/code&gt;&lt;/a&gt; values. The enhanced sort order is documented in &lt;a href=&quot;numpy.sort#numpy.sort&quot;&gt;&lt;code&gt;sort&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Начиная с NumPy 1.4.0 &lt;a href=&quot;#numpy.searchsorted&quot;&gt; &lt;code&gt;searchsorted&lt;/code&gt; &lt;/a&gt; работает с реальными / сложными массивами, содержащими значения &lt;a href=&quot;../constants#numpy.nan&quot;&gt; &lt;code&gt;nan&lt;/code&gt; &lt;/a&gt; . Расширенный порядок сортировки задокументирован в &lt;a href=&quot;numpy.sort#numpy.sort&quot;&gt; &lt;code&gt;sort&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="17597aa038b28f9f5c8df2774b1f9eab6ad3af4c" translate="yes" xml:space="preserve">
          <source>As of NumPy 1.6.0, these array iterators are superceded by the new array iterator, &lt;a href=&quot;c-api.iterator#c.NpyIter&quot;&gt;&lt;code&gt;NpyIter&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Начиная с NumPy 1.6.0, эти итераторы массива &lt;a href=&quot;c-api.iterator#c.NpyIter&quot;&gt; &lt;code&gt;NpyIter&lt;/code&gt; &lt;/a&gt; новым итератором массива, NpyIter .</target>
        </trans-unit>
        <trans-unit id="8364d1abaebc5d8b1444ea31949f7accfaa13ead" translate="yes" xml:space="preserve">
          <source>As of NumPy 1.6.0, these array iterators are superseded by the new array iterator, &lt;a href=&quot;iterator#c.NpyIter&quot;&gt;&lt;code&gt;NpyIter&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7f60464691ec1296f5eb92b23ac7c66b95bdc223" translate="yes" xml:space="preserve">
          <source>As previously discussed, you can also set the argtypes attribute of the function in order to have ctypes check the types of the input arguments when the function is called. Use the &lt;a href=&quot;#ndpointer&quot;&gt;&lt;code&gt;ndpointer&lt;/code&gt;&lt;/a&gt; factory function to generate a ready-made class for data-type, shape, and flags checking on your new function. The &lt;a href=&quot;#ndpointer&quot;&gt;&lt;code&gt;ndpointer&lt;/code&gt;&lt;/a&gt; function has the signature</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7e6c9caa222f474d8200d79ae5b20b408a1c8172" translate="yes" xml:space="preserve">
          <source>As shown in &lt;a href=&quot;#figure-2&quot;&gt;Figure 2&lt;/a&gt;, &lt;code&gt;b&lt;/code&gt; is added to each row of &lt;code&gt;a&lt;/code&gt;. When &lt;code&gt;b&lt;/code&gt; is longer than the rows of &lt;code&gt;a&lt;/code&gt;, as in &lt;a href=&quot;#figure-3&quot;&gt;Figure 3&lt;/a&gt;, an exception is raised because of the incompatible shapes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0eb75b8579bfe992aa268341a4c85c6d503920b9" translate="yes" xml:space="preserve">
          <source>As the scale approaches infinity, the distribution becomes more like a Gaussian. Some references claim that the Wald is an inverse Gaussian with mean equal to 1, but this is by no means universal.</source>
          <target state="translated">По мере приближения шкалы к бесконечности,распределение становится больше похожим на гауссов.В некоторых ссылках утверждается,что Вальд является обратным гауссовым со средним значением,равным 1,но это ни в коем случае не является универсальным.</target>
        </trans-unit>
        <trans-unit id="2f0e40b24d4f520710fd1ed228a57a1690ea8227" translate="yes" xml:space="preserve">
          <source>As well as the scalar array special case signaling that an integer array was interpreted as an integer index, which is important because an integer array index forces a copy but is ignored if a scalar is returned (full integer index). The prepared index is guaranteed to be valid with the exception of out of bound values and broadcasting errors for advanced indexing. This includes that an ellipsis is added for incomplete indices for example when a two dimensional array is indexed with a single integer.</source>
          <target state="translated">Так же,как и скалярный массив в специальном случае,сигнализирует о том,что целочисленный массив был интерпретирован как целочисленный индекс,что важно,так как индекс целочисленного массива заставляет копировать,но игнорируется,если возвращается скаляр (полный целочисленный индекс).Подготовленный индекс гарантированно будет действительным,за исключением выходящих из-под контроля значений и ошибок трансляции для расширенной индексации.Это включает в себя то,что эллипсис добавляется для неполных индексов,например,когда двухмерный массив индексируется одним целым числом.</target>
        </trans-unit>
        <trans-unit id="925814af80369e67056380832c2cbc226e28baa6" translate="yes" xml:space="preserve">
          <source>As with other container objects in Python, the contents of an &lt;a href=&quot;generated/numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;ndarray&lt;/code&gt;&lt;/a&gt; can be accessed and modified by &lt;a href=&quot;arrays.indexing#arrays-indexing&quot;&gt;indexing or slicing&lt;/a&gt; the array (using, for example, &lt;em&gt;N&lt;/em&gt; integers), and via the methods and attributes of the &lt;a href=&quot;generated/numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;ndarray&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Как и в случае с другими объектами-контейнерами в Python, к содержимому &lt;a href=&quot;generated/numpy.ndarray#numpy.ndarray&quot;&gt; &lt;code&gt;ndarray&lt;/code&gt; &lt;/a&gt; можно получить доступ и изменить путем &lt;a href=&quot;arrays.indexing#arrays-indexing&quot;&gt;индексации или нарезки&lt;/a&gt; массива (используя, например, &lt;em&gt;N&lt;/em&gt; целых чисел), а также с помощью методов и атрибутов &lt;a href=&quot;generated/numpy.ndarray#numpy.ndarray&quot;&gt; &lt;code&gt;ndarray&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="52fd93066bad29b67273e079568eccef85b00fa0" translate="yes" xml:space="preserve">
          <source>As you can imagine from the introduction, there are two ways you can affect the relationship between the byte ordering of the array and the underlying memory it is looking at:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d2891acf8ae5fe1d5007874779732cde26b391a3" translate="yes" xml:space="preserve">
          <source>As you can see, the object can be initialized in the &lt;code&gt;__new__&lt;/code&gt; method or the &lt;code&gt;__init__&lt;/code&gt; method, or both, and in fact ndarray does not have an &lt;code&gt;__init__&lt;/code&gt; method, because all the initialization is done in the &lt;code&gt;__new__&lt;/code&gt; method.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3b4f7dc7b3c4a70ce9ff533c44a9b7a4a1713152" translate="yes" xml:space="preserve">
          <source>Asking for your changes to be merged with the main repo</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b3cf9d2ab1eb546a2eba1efeb64eb1e97091b955" translate="yes" xml:space="preserve">
          <source>Assemble an nd-array from nested lists of blocks.</source>
          <target state="translated">Соберите имена и массивы из вложенных списков блоков.</target>
        </trans-unit>
        <trans-unit id="74cbd6c218f89d00f752e7ba4b2b17d97a1a1ff7" translate="yes" xml:space="preserve">
          <source>Assemble arrays from blocks.</source>
          <target state="translated">Соберите массивы из блоков.</target>
        </trans-unit>
        <trans-unit id="de78d0a7b76ee6bba1ecaedfc383918b06ba62a9" translate="yes" xml:space="preserve">
          <source>Assert fails with numerical imprecision with floats:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="79536b913447cc8edd9ecd5192bb8530d9a9202a" translate="yes" xml:space="preserve">
          <source>Assert fails with numerical inprecision with floats:</source>
          <target state="translated">Утверждать не удается с числовой точностью с помощью поплавков:</target>
        </trans-unit>
        <trans-unit id="561c16749736b8dbda1124817a2b4447de5e4505" translate="yes" xml:space="preserve">
          <source>Asserts</source>
          <target state="translated">Asserts</target>
        </trans-unit>
        <trans-unit id="289e36002d46d5808069779b9fe9f985a8b15407" translate="yes" xml:space="preserve">
          <source>Assigning data to a Structured Array</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8a799af040a420920800093adb9e84b1752618c3" translate="yes" xml:space="preserve">
          <source>Assigning to slices/views of &lt;code&gt;MaskedArray&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a63aa663ce3fd806853c6e1d56f0f1c1896855bd" translate="yes" xml:space="preserve">
          <source>Assigning values to indexed arrays</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4d5174a57fec035b53144526667e457e11d00dd3" translate="yes" xml:space="preserve">
          <source>Assignment between two structured arrays occurs as if the source elements had been converted to tuples and then assigned to the destination elements. That is, the first field of the source array is assigned to the first field of the destination array, and the second field likewise, and so on, regardless of field names. Structured arrays with a different number of fields cannot be assigned to each other. Bytes of the destination structure which are not included in any of the fields are unaffected.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="acccf5c6ee3457ada97687fe5c7f1318e0893486" translate="yes" xml:space="preserve">
          <source>Assignment from Python Native Types (Tuples)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9cc21533901f2115eb4a3c32d19650f93349565e" translate="yes" xml:space="preserve">
          <source>Assignment from Scalars</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4c57993301d1b6548c0e4939d7c7c8d9a2d56b2c" translate="yes" xml:space="preserve">
          <source>Assignment from other Structured Arrays</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fc5e2a82565507aaae14030e1c010088c6562688" translate="yes" xml:space="preserve">
          <source>Assignment involving subarrays</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dc3ede0861439daaed8c3de08958646d9211be1a" translate="yes" xml:space="preserve">
          <source>Assignment of ndarray object&amp;rsquo;s &lt;code&gt;data&lt;/code&gt; attribute</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2edeef440cbb6c2ba230df4bbf3e9bef68f36e23" translate="yes" xml:space="preserve">
          <source>Assignment to an array with a multi-field index modifies the original array:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="af53b1c5013c72eb7aa598ce977b69cfb859c315" translate="yes" xml:space="preserve">
          <source>Assignment to the view modifies the original array. The view&amp;rsquo;s fields will be in the order they were indexed. Note that unlike for single-field indexing, the dtype of the view has the same itemsize as the original array, and has fields at the same offsets as in the original array, and unindexed fields are merely missing.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ed91fb02ba267588e9268d85784e62da51f799fd" translate="yes" xml:space="preserve">
          <source>Assignment vs referencing</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d8a1879dbe4b9ce9021e415e931186b4b4a19157" translate="yes" xml:space="preserve">
          <source>Assigns values from one structured array to another by field name.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ae9a24254ec6cd55a31a48c28461f44e73e53f66" translate="yes" xml:space="preserve">
          <source>Assume &lt;code&gt;mask_func&lt;/code&gt; is a function that, for a square array a of size &lt;code&gt;(n, n)&lt;/code&gt; with a possible offset argument &lt;code&gt;k&lt;/code&gt;, when called as &lt;code&gt;mask_func(a, k)&lt;/code&gt; returns a new array with zeros in certain locations (functions like &lt;a href=&quot;numpy.triu#numpy.triu&quot;&gt;&lt;code&gt;triu&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;numpy.tril#numpy.tril&quot;&gt;&lt;code&gt;tril&lt;/code&gt;&lt;/a&gt; do precisely this). Then this function returns the indices where the non-zero values would be located.</source>
          <target state="translated">Предположим , &lt;code&gt;mask_func&lt;/code&gt; это функция , которая, на квадратный массив размера &lt;code&gt;(n, n)&lt;/code&gt; с возможным сдвигом аргумента &lt;code&gt;k&lt;/code&gt; , когда называется &lt;code&gt;mask_func(a, k)&lt;/code&gt; возвращает новый массив с нулями в определенных местах (функции , такие как &lt;a href=&quot;numpy.triu#numpy.triu&quot;&gt; &lt;code&gt;triu&lt;/code&gt; &lt;/a&gt; или &lt;a href=&quot;numpy.tril#numpy.tril&quot;&gt; &lt;code&gt;tril&lt;/code&gt; &lt;/a&gt; делать именно это). Затем эта функция возвращает индексы, в которых будут находиться ненулевые значения.</target>
        </trans-unit>
        <trans-unit id="87a473db70c6a624c40e23afb12c39561d92a618" translate="yes" xml:space="preserve">
          <source>Assume &lt;em&gt;n&lt;/em&gt; is the number of elements in the dimension being sliced. Then, if &lt;em&gt;i&lt;/em&gt; is not given it defaults to 0 for &lt;em&gt;k &amp;gt; 0&lt;/em&gt; and &lt;em&gt;n - 1&lt;/em&gt; for &lt;em&gt;k &amp;lt; 0&lt;/em&gt; . If &lt;em&gt;j&lt;/em&gt; is not given it defaults to &lt;em&gt;n&lt;/em&gt; for &lt;em&gt;k &amp;gt; 0&lt;/em&gt; and &lt;em&gt;-n-1&lt;/em&gt; for &lt;em&gt;k &amp;lt; 0&lt;/em&gt; . If &lt;em&gt;k&lt;/em&gt; is not given it defaults to 1. Note that &lt;code&gt;::&lt;/code&gt; is the same as &lt;code&gt;:&lt;/code&gt; and means select all indices along this axis.</source>
          <target state="translated">Предположим, что &lt;em&gt;n&lt;/em&gt; - количество элементов в разрезаемом измерении. Затем, если &lt;em&gt;i&lt;/em&gt; не задан, по умолчанию используется значение 0 для &lt;em&gt;k&amp;gt; 0&lt;/em&gt; и &lt;em&gt;n - 1&lt;/em&gt; для &lt;em&gt;k &amp;lt;0&lt;/em&gt; . Если &lt;em&gt;j&lt;/em&gt; не задан, по умолчанию используется &lt;em&gt;n&lt;/em&gt; для &lt;em&gt;k&amp;gt; 0&lt;/em&gt; и &lt;em&gt;-n-1&lt;/em&gt; для &lt;em&gt;k &amp;lt;0&lt;/em&gt; . Если &lt;em&gt;k&lt;/em&gt; не задан, по умолчанию он равен 1. Обратите внимание, что &lt;code&gt;::&lt;/code&gt; то же самое, что и &lt;code&gt;:&lt;/code&gt; и означает выбор всех индексов вдоль этой оси.</target>
        </trans-unit>
        <trans-unit id="b9dccb798e5c5e1b5508e3a8630765c07522b225" translate="yes" xml:space="preserve">
          <source>Assume that the observations are in the columns of the observation array &lt;code&gt;m&lt;/code&gt; and let &lt;code&gt;f = fweights&lt;/code&gt; and &lt;code&gt;a = aweights&lt;/code&gt; for brevity. The steps to compute the weighted covariance are as follows:</source>
          <target state="translated">Предположим, что наблюдения находятся в столбцах массива наблюдений &lt;code&gt;m&lt;/code&gt; , и пусть для краткости &lt;code&gt;f = fweights&lt;/code&gt; и &lt;code&gt;a = aweights&lt;/code&gt; . Шаги для вычисления взвешенной ковариации следующие:</target>
        </trans-unit>
        <trans-unit id="97728787c4c0fd66ac4cc28f08c4ba4e206f76e5" translate="yes" xml:space="preserve">
          <source>Assume we have three matrices</source>
          <target state="translated">Предположим,у нас есть три матрицы</target>
        </trans-unit>
        <trans-unit id="68035e390827bfef5b6a722908902bf830e33068" translate="yes" xml:space="preserve">
          <source>Assuming that</source>
          <target state="translated">если предположить,что</target>
        </trans-unit>
        <trans-unit id="361dbf446d2fcbde7f8e5127964dd121d2c08adc" translate="yes" xml:space="preserve">
          <source>Assuming that &lt;code&gt;a&lt;/code&gt; is sorted:</source>
          <target state="translated">Предполагая, что &lt;code&gt;a&lt;/code&gt; отсортировано:</target>
        </trans-unit>
        <trans-unit id="a66d954bab07db2d2ebde3811f3d1797fded0efb" translate="yes" xml:space="preserve">
          <source>Assuming the foo.ini.in file has the following content:</source>
          <target state="translated">Если предположить,что файл foo.ini.in имеет следующее содержание:</target>
        </trans-unit>
        <trans-unit id="3d748459a93c925f679363da9105b14fbf94ff7f" translate="yes" xml:space="preserve">
          <source>Assuming you have followed the instructions in these pages, git will create a default link to your &lt;a href=&quot;https://github.com/numpy/numpy&quot;&gt;github&lt;/a&gt; repo called &lt;code&gt;origin&lt;/code&gt;. In git &amp;gt;= 1.7 you can ensure that the link to origin is permanently set by using the &lt;code&gt;--set-upstream&lt;/code&gt; option:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0527fe789f4627f3a63d0bb5ba48121982fec81a" translate="yes" xml:space="preserve">
          <source>At each iteration of the loop, the &lt;em&gt;nin&lt;/em&gt; input objects are extracted from their object arrays and placed into an argument tuple, the Python &lt;em&gt;callable&lt;/em&gt; is called with the input arguments, and the nout outputs are placed into their object arrays.</source>
          <target state="translated">На каждой итерации цикла входные объекты &lt;em&gt;nin&lt;/em&gt; извлекаются из их массивов объектов и помещаются в кортеж аргументов, &lt;em&gt;вызываемый&lt;/em&gt; объект Python вызывается с входными аргументами, а выходные данные nout помещаются в их массивы объектов.</target>
        </trans-unit>
        <trans-unit id="ca83daf60668ea69e76df727d7b2b16f815d0807" translate="yes" xml:space="preserve">
          <source>At the beginning of every &lt;a href=&quot;ufuncs#ufuncs-output-type&quot;&gt;ufunc&lt;/a&gt;, this method is called on the input object with the highest array priority, or the output object if one was specified. The output array is passed in and whatever is returned is passed to the ufunc. Subclasses inherit a default implementation of this method which simply returns the output array unmodified. Subclasses may opt to use this method to transform the output array into an instance of the subclass and update metadata before returning the array to the ufunc for computation.</source>
          <target state="translated">В начале каждого &lt;a href=&quot;ufuncs#ufuncs-output-type&quot;&gt;ufunc&lt;/a&gt; этот метод вызывается для входного объекта с наивысшим приоритетом массива или выходного объекта, если он был указан. Выходной массив передается, а все, что возвращается, передается в ufunc. Подклассы наследуют реализацию этого метода по умолчанию, которая просто возвращает выходной массив без изменений. Подклассы могут использовать этот метод для преобразования выходного массива в экземпляр подкласса и обновления метаданных перед возвратом массива в ufunc для вычисления.</target>
        </trans-unit>
        <trans-unit id="12bc262a1577057e701d7713e64c78fa019c087b" translate="yes" xml:space="preserve">
          <source>At the core of every ufunc is a collection of type-specific functions that defines the basic functionality for each of the supported types. These functions must evaluate the underlying function</source>
          <target state="translated">В основе каждой функции ufunc лежит коллекция функций,специфичных для каждого типа,которая определяет базовую функциональность для каждого из поддерживаемых типов.Эти функции должны оценивать базовую функцию</target>
        </trans-unit>
        <trans-unit id="99499535512b6c181a0f3b43a50d805096cef5c2" translate="yes" xml:space="preserve">
          <source>At the core of every ufunc is a one-dimensional strided loop that implements the actual function for a specific type combination. When a ufunc is created, it is given a static list of inner loops and a corresponding list of type signatures over which the ufunc operates. The ufunc machinery uses this list to determine which inner loop to use for a particular case. You can inspect the &lt;a href=&quot;generated/numpy.ufunc.types#numpy.ufunc.types&quot;&gt;&lt;code&gt;.types&lt;/code&gt;&lt;/a&gt; attribute for a particular ufunc to see which type combinations have a defined inner loop and which output type they produce (&lt;a href=&quot;arrays.scalars#arrays-scalars-character-codes&quot;&gt;character codes&lt;/a&gt; are used in said output for brevity).</source>
          <target state="translated">В основе каждого ufunc лежит одномерный чередующийся цикл, реализующий фактическую функцию для конкретной комбинации типов. Когда ufunc создается, ему дается статический список внутренних циклов и соответствующий список сигнатур типов, над которыми работает ufunc. Механизм ufunc использует этот список, чтобы определить, какой внутренний цикл использовать в конкретном случае. Вы можете проверить атрибут &lt;a href=&quot;generated/numpy.ufunc.types#numpy.ufunc.types&quot;&gt; &lt;code&gt;.types&lt;/code&gt; &lt;/a&gt; для конкретного ufunc, чтобы увидеть, какие комбинации типов имеют определенный внутренний цикл и какой тип вывода они создают ( &lt;a href=&quot;arrays.scalars#arrays-scalars-character-codes&quot;&gt;коды символов&lt;/a&gt; используются в указанном выводе для краткости).</target>
        </trans-unit>
        <trans-unit id="a696ebe70ac5ecb64adf92ab51868a20788e2014" translate="yes" xml:space="preserve">
          <source>At the core of the NumPy package, is the &lt;code&gt;ndarray&lt;/code&gt; object. This encapsulates &lt;em&gt;n&lt;/em&gt;-dimensional arrays of homogeneous data types, with many operations being performed in compiled code for performance. There are several important differences between NumPy arrays and the standard Python sequences:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d886c7715daa7e13f2899ef3973389ec60967548" translate="yes" xml:space="preserve">
          <source>At the end of every &lt;a href=&quot;ufuncs#ufuncs-output-type&quot;&gt;ufunc&lt;/a&gt;, this method is called on the input object with the highest array priority, or the output object if one was specified. The ufunc-computed array is passed in and whatever is returned is passed to the user. Subclasses inherit a default implementation of this method, which transforms the array into a new instance of the object&amp;rsquo;s class. Subclasses may opt to use this method to transform the output array into an instance of the subclass and update metadata before returning the array to the user.</source>
          <target state="translated">В конце каждого &lt;a href=&quot;ufuncs#ufuncs-output-type&quot;&gt;ufunc&lt;/a&gt; этот метод вызывается для входного объекта с наивысшим приоритетом массива или выходного объекта, если он был указан. Вычисляемый ufunc массив передается, и все, что возвращается, передается пользователю. Подклассы наследуют реализацию этого метода по умолчанию, которая преобразует массив в новый экземпляр класса объекта. Подклассы могут использовать этот метод для преобразования выходного массива в экземпляр подкласса и обновления метаданных перед возвратом массива пользователю.</target>
        </trans-unit>
        <trans-unit id="54f27a6635e66c8275db039314e451b39ca65192" translate="yes" xml:space="preserve">
          <source>At this point &lt;code&gt;arr + 3&lt;/code&gt; does not work.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f7cf21779cc632f37ca6f9f1b905fd816410c5c5" translate="yes" xml:space="preserve">
          <source>Attribute statements:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a6652617f2c799eb11ee727b16c5646c48af6905" translate="yes" xml:space="preserve">
          <source>Attributes</source>
          <target state="translated">Attributes</target>
        </trans-unit>
        <trans-unit id="cfe76174da05e50b979cc6188b003f45d1df8482" translate="yes" xml:space="preserve">
          <source>Attributes and properties of masked arrays</source>
          <target state="translated">Атрибуты и свойства массивов масок</target>
        </trans-unit>
        <trans-unit id="75d3cd51a61f739cdedf79817eefc8974a835455" translate="yes" xml:space="preserve">
          <source>Attributes providing additional information:</source>
          <target state="translated">Атрибуты,предоставляющие дополнительную информацию:</target>
        </trans-unit>
        <trans-unit id="1003414a3eb685608efbc345c0f83084c22559bd" translate="yes" xml:space="preserve">
          <source>Attributes that are properties and have their own docstrings can be simply listed by name:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b8087185e5ee37cef4c337de5697d35d75d909fd" translate="yes" xml:space="preserve">
          <source>Attributes:</source>
          <target state="translated">Attributes:</target>
        </trans-unit>
        <trans-unit id="6854c23ffe094a9dcc2c7d18b7054597700c09d7" translate="yes" xml:space="preserve">
          <source>Author: Pearu Peterson &amp;lt;&lt;a href=&quot;mailto:pearu%40cens.ioc.ee&quot;&gt;pearu@cens.ioc.ee&lt;/a&gt;&amp;gt; Created: 11 January 2003</source>
          <target state="translated">Автор: Пиару Петерсон &amp;lt; &lt;a href=&quot;mailto:pearu%40cens.ioc.ee&quot;&gt;pearu@cens.ioc.ee&lt;/a&gt; &amp;gt; Создано: 11 января 2003 г.</target>
        </trans-unit>
        <trans-unit id="d2a52548bd0852b99153ddd79a1f550f70674c7d" translate="yes" xml:space="preserve">
          <source>Authors</source>
          <target state="translated">Authors</target>
        </trans-unit>
        <trans-unit id="9a8e09e3b7e8024727baccc0a1e74a9673de3c0e" translate="yes" xml:space="preserve">
          <source>Automated Bin Selection Methods example, using 2 peak random data with 2000 points:</source>
          <target state="translated">Пример автоматизированного метода выделения бин с использованием 2 пиков случайных данных с 2000 точками:</target>
        </trans-unit>
        <trans-unit id="bfb122c45c152fbdf176456bb1bd4e6bc24c337e" translate="yes" xml:space="preserve">
          <source>Automatic Byte Offsets and Alignment</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="522d7710743316a9bb70282225a360f203660682" translate="yes" xml:space="preserve">
          <source>Automatic detection of forward incompatibilities</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="687034389bdc7cc4294c91418210f69e71c2ea75" translate="yes" xml:space="preserve">
          <source>Automatic extension module generation</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b2ebac8c965ff2e52dca0ea08eceaccc8803b780" translate="yes" xml:space="preserve">
          <source>Automatically generated reference documentation</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="65efb82d6e37e5b9994108df57fecde86e561550" translate="yes" xml:space="preserve">
          <source>Auxiliary Data With Object Semantics</source>
          <target state="translated">Вспомогательные данные с объектной семантикой</target>
        </trans-unit>
        <trans-unit id="b5d54069c98dcc2bb7ef53455746da49544d4c61" translate="yes" xml:space="preserve">
          <source>Available Typemaps</source>
          <target state="translated">Доступные типовые карты</target>
        </trans-unit>
        <trans-unit id="0eba0fa1e7377ce939b86cc49e664126d93a94fb" translate="yes" xml:space="preserve">
          <source>Available labels are:</source>
          <target state="translated">Доступные этикетки:</target>
        </trans-unit>
        <trans-unit id="b9ef456325fee29b959d2b71abeec2f41a07fee2" translate="yes" xml:space="preserve">
          <source>Available ufuncs</source>
          <target state="translated">Доступные уфунки</target>
        </trans-unit>
        <trans-unit id="15f86c051ecf0b64e5f8cdc8c689552f42595942" translate="yes" xml:space="preserve">
          <source>Average</source>
          <target state="translated">Average</target>
        </trans-unit>
        <trans-unit id="00230b1d5c35405f7ca65ccbf60097d1ff75f793" translate="yes" xml:space="preserve">
          <source>Averages and variances</source>
          <target state="translated">Средние и отклонения</target>
        </trans-unit>
        <trans-unit id="e7a6dacf63a1600c6901329b8727cfba6197e8fd" translate="yes" xml:space="preserve">
          <source>Axes are defined for arrays with more than one dimension. A 2-dimensional array has two corresponding axes: the first running vertically downwards across rows (axis 0), and the second running horizontally across columns (axis 1).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="260a17f609be1b620f1eb6b59b7945c255c81429" translate="yes" xml:space="preserve">
          <source>Axes in &lt;code&gt;a&lt;/code&gt; to reorder to the right, before inversion. If None (default), no reordering is done.</source>
          <target state="translated">Оси в &lt;code&gt;a&lt;/code&gt; для изменения порядка вправо перед инверсией. Если нет (по умолчанию), переупорядочивание не производится.</target>
        </trans-unit>
        <trans-unit id="db233fcb37135c7f09c5ffb89b7ba1fec760ef66" translate="yes" xml:space="preserve">
          <source>Axes over which &lt;code&gt;func&lt;/code&gt; is applied; the elements must be integers.</source>
          <target state="translated">Оси, по которым применяется &lt;code&gt;func&lt;/code&gt; ; элементы должны быть целыми числами.</target>
        </trans-unit>
        <trans-unit id="3c7544c1215157a53157a59a39707d4b0bcf94df" translate="yes" xml:space="preserve">
          <source>Axes over which to calculate. Defaults to None, which shifts all axes.</source>
          <target state="translated">Топоры,над которыми нужно вычислять.По умолчанию None,которая сдвигает все оси.</target>
        </trans-unit>
        <trans-unit id="01251d80564e6fc5615a7911ad0e73434e304c26" translate="yes" xml:space="preserve">
          <source>Axes over which to compute the FFT.</source>
          <target state="translated">Топоры,по которым вычисляется БПФ.</target>
        </trans-unit>
        <trans-unit id="eae74832fcf1fa3443d947416920310bd08270f6" translate="yes" xml:space="preserve">
          <source>Axes over which to compute the FFT. If not given, the last &lt;code&gt;len(s)&lt;/code&gt; axes are used, or all axes if &lt;code&gt;s&lt;/code&gt; is also not specified.</source>
          <target state="translated">Оси, по которым вычисляется БПФ. Если не указано, используются последние &lt;code&gt;len(s)&lt;/code&gt; осей или все оси, если &lt;code&gt;s&lt;/code&gt; также не указан.</target>
        </trans-unit>
        <trans-unit id="087a54cd73e6a93e216a09c22b970ec84185e189" translate="yes" xml:space="preserve">
          <source>Axes over which to compute the FFT. If not given, the last &lt;code&gt;len(s)&lt;/code&gt; axes are used, or all axes if &lt;code&gt;s&lt;/code&gt; is also not specified. Repeated indices in &lt;code&gt;axes&lt;/code&gt; means that the transform over that axis is performed multiple times.</source>
          <target state="translated">Оси, по которым вычисляется БПФ. Если не указано, используются последние &lt;code&gt;len(s)&lt;/code&gt; осей или все оси, если &lt;code&gt;s&lt;/code&gt; также не указан. Повторяющиеся индексы на &lt;code&gt;axes&lt;/code&gt; означают, что преобразование по этой оси выполняется несколько раз.</target>
        </trans-unit>
        <trans-unit id="c012449cfef6487dddab190f30ddad2f2e0316c1" translate="yes" xml:space="preserve">
          <source>Axes over which to compute the FFT. If not given, the last two axes are used. A repeated index in &lt;code&gt;axes&lt;/code&gt; means the transform over that axis is performed multiple times. A one-element sequence means that a one-dimensional FFT is performed.</source>
          <target state="translated">Оси, по которым вычисляется БПФ. Если не указан, используются две последние оси. Повторяющийся индекс в &lt;code&gt;axes&lt;/code&gt; означает, что преобразование по этой оси выполняется несколько раз. Одноэлементная последовательность означает, что выполняется одномерное БПФ.</target>
        </trans-unit>
        <trans-unit id="c1bbe9559f43f27cc8c677ee579702aea02533b0" translate="yes" xml:space="preserve">
          <source>Axes over which to compute the IFFT. If not given, the last &lt;code&gt;len(s)&lt;/code&gt; axes are used, or all axes if &lt;code&gt;s&lt;/code&gt; is also not specified. Repeated indices in &lt;code&gt;axes&lt;/code&gt; means that the inverse transform over that axis is performed multiple times.</source>
          <target state="translated">Оси, по которым вычисляется ОБПФ. Если не указано, используются последние &lt;code&gt;len(s)&lt;/code&gt; осей или все оси, если &lt;code&gt;s&lt;/code&gt; также не указан. Повторяющиеся индексы на &lt;code&gt;axes&lt;/code&gt; означают, что обратное преобразование по этой оси выполняется несколько раз.</target>
        </trans-unit>
        <trans-unit id="b354616c4fe4a354f85531d5428c20c0b32f3c2f" translate="yes" xml:space="preserve">
          <source>Axes over which to compute the inverse FFT. If not given, the last &lt;code&gt;len(s)&lt;/code&gt; axes are used, or all axes if &lt;code&gt;s&lt;/code&gt; is also not specified. Repeated indices in &lt;code&gt;axes&lt;/code&gt; means that the inverse transform over that axis is performed multiple times.</source>
          <target state="translated">Оси, по которым вычисляется обратное БПФ. Если не указано, используются последние &lt;code&gt;len(s)&lt;/code&gt; осей или все оси, если &lt;code&gt;s&lt;/code&gt; также не указан. Повторяющиеся индексы на &lt;code&gt;axes&lt;/code&gt; означают, что обратное преобразование по этой оси выполняется несколько раз.</target>
        </trans-unit>
        <trans-unit id="8a99b64a4a7a7c7ead7b23b02c696f0da53ae319" translate="yes" xml:space="preserve">
          <source>Axes over which to shift. Default is None, which shifts all axes.</source>
          <target state="translated">Топоры,над которыми нужно переместиться.По умолчанию Никто,который смещает все оси.</target>
        </trans-unit>
        <trans-unit id="0a52967d9e9b8df8a4f8c170f8ca693ae8a86fe3" translate="yes" xml:space="preserve">
          <source>Axes to be used as the first and second axis of the 2-D sub-arrays from which the diagonals should be taken. Defaults are the first two axes of &lt;code&gt;a&lt;/code&gt;.</source>
          <target state="translated">Оси, которые будут использоваться в качестве первой и второй оси двумерных подмассивов, из которых должны быть взяты диагонали. Значения по умолчанию являются первыми двумя осями . &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="f303f8b434501d0a0e88a06f71ae6bf60e07440a" translate="yes" xml:space="preserve">
          <source>Axis along which &lt;code&gt;arr&lt;/code&gt; is sliced.</source>
          <target state="translated">Ось, по которой нарезается &lt;code&gt;arr&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="eb47b635b568e5dba0343ed2ed07af3eb1c5f691" translate="yes" xml:space="preserve">
          <source>Axis along which logical OR is performed</source>
          <target state="translated">Ось,по которой выполняется логическая операция &quot;ИЛИ</target>
        </trans-unit>
        <trans-unit id="09cfc91cd9019ea0548a0bc697b5fe1ac4febf1f" translate="yes" xml:space="preserve">
          <source>Axis along which the cumulative product is computed. By default the input is flattened.</source>
          <target state="translated">Ось,по которой рассчитывается кумулятивный продукт.По умолчанию входной параметр сглажен.</target>
        </trans-unit>
        <trans-unit id="57187cefb1f2a69dac281d57460affb45a365e61" translate="yes" xml:space="preserve">
          <source>Axis along which the cumulative sum is computed. The default (None) is to compute the cumsum over the flattened array.</source>
          <target state="translated">Ось,по которой вычисляется кумулятивная сумма.По умолчанию (None)вычисляется кумулятивная сумма по сплющенному массиву.</target>
        </trans-unit>
        <trans-unit id="f37486b57129451282a7b678277fa8169fe0110e" translate="yes" xml:space="preserve">
          <source>Axis along which the elements are counted. By default, give the total number of elements.</source>
          <target state="translated">Ось,вдоль которой подсчитываются элементы.По умолчанию укажите общее количество элементов.</target>
        </trans-unit>
        <trans-unit id="b08197a0ff41e61316a0f60a6919ee14fb5fe98b" translate="yes" xml:space="preserve">
          <source>Axis along which the medians are computed. The default (None) is to compute the median along a flattened version of the array.</source>
          <target state="translated">Ось,по которой вычисляются медианы.По умолчанию (None)медиана вычисляется по сплющенной версии массива.</target>
        </trans-unit>
        <trans-unit id="bc92a5f411fa4b8657deb697c80aca8e1f76fb85" translate="yes" xml:space="preserve">
          <source>Axis along which the operation must be performed.</source>
          <target state="translated">Ось,по которой должна выполняться операция.</target>
        </trans-unit>
        <trans-unit id="f2cd71dae3fa50b163de963d5f5e4581028e17b5" translate="yes" xml:space="preserve">
          <source>Axis along which to average &lt;code&gt;a&lt;/code&gt;. If &lt;code&gt;None&lt;/code&gt;, averaging is done over the flattened array.</source>
          <target state="translated">Ось, по которой следует усреднить &lt;code&gt;a&lt;/code&gt; . Если &lt;code&gt;None&lt;/code&gt; , усреднение выполняется по сплющенному массиву.</target>
        </trans-unit>
        <trans-unit id="17667e8c77ab258d88774c70f62a92c1b9869875" translate="yes" xml:space="preserve">
          <source>Axis along which to average &lt;code&gt;a&lt;/code&gt;. If None, averaging is done over the flattened array.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6740a47c78c530ff5565f890ca7a6510d66b94b6" translate="yes" xml:space="preserve">
          <source>Axis along which to count. If None (default), a flattened version of the array is used.</source>
          <target state="translated">Ось,по которой можно считать.Если None (по умолчанию),то используется плоская версия массива.</target>
        </trans-unit>
        <trans-unit id="87e6cb227cab73030094d0bab3690d5e44d50da1" translate="yes" xml:space="preserve">
          <source>Axis along which to find the peaks. By default, flatten the array. &lt;code&gt;axis&lt;/code&gt; may be negative, in which case it counts from the last to the first axis.</source>
          <target state="translated">Ось, по которой нужно найти вершины. По умолчанию сгладить массив. &lt;code&gt;axis&lt;/code&gt; может быть отрицательной, и в этом случае она считается от последней до первой оси.</target>
        </trans-unit>
        <trans-unit id="d012a76459484bfd8767b22b0537d0b22d4d11bb" translate="yes" xml:space="preserve">
          <source>Axis along which to find the peaks. If None (default) the flattened array is used.</source>
          <target state="translated">Ось,по которой можно найти вершины.Если None (по умолчанию),то используется сплющенный массив.</target>
        </trans-unit>
        <trans-unit id="c855b308fb59a9f63969a5e9a73073df7701d3a8" translate="yes" xml:space="preserve">
          <source>Axis along which to insert &lt;code&gt;values&lt;/code&gt;. If &lt;code&gt;axis&lt;/code&gt; is None then &lt;code&gt;arr&lt;/code&gt; is flattened first.</source>
          <target state="translated">Ось для вставки &lt;code&gt;values&lt;/code&gt; . Если &lt;code&gt;axis&lt;/code&gt; None, то сначала выполняется выравнивание &lt;code&gt;arr&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="caa670fb62ad34335b9428afd9953d664aefbfc6" translate="yes" xml:space="preserve">
          <source>Axis along which to operate. By default flattened input is used.</source>
          <target state="translated">Ось,по которой нужно действовать.По умолчанию используется плоский вход.</target>
        </trans-unit>
        <trans-unit id="1612a72f0d3b6ca5a9a80a269a8a766d4f4346ff" translate="yes" xml:space="preserve">
          <source>Axis along which to operate. By default, &lt;code&gt;axis&lt;/code&gt; is None and the flattened input is used.</source>
          <target state="translated">Ось, по которой работать. По умолчанию &lt;code&gt;axis&lt;/code&gt; None и используется плоский ввод.</target>
        </trans-unit>
        <trans-unit id="dfc23123538404f83aba951929e9f61fafacf779" translate="yes" xml:space="preserve">
          <source>Axis along which to perform the operation. Default is None.</source>
          <target state="translated">Ось,по которой должна выполняться операция.По умолчанию нет.</target>
        </trans-unit>
        <trans-unit id="f599b7c76d66ef3380a35805a50ac6efed5828ce" translate="yes" xml:space="preserve">
          <source>Axis along which to perform the operation. If None (default), applies to a flattened version of the array, and this is the same as &lt;a href=&quot;numpy.ma.flatnotmasked_contiguous#numpy.ma.flatnotmasked_contiguous&quot;&gt;&lt;code&gt;flatnotmasked_contiguous&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Ось, вдоль которой будет выполняться операция. Если Нет (по умолчанию), применяется к плоской версии массива, и это то же самое, что и &lt;a href=&quot;numpy.ma.flatnotmasked_contiguous#numpy.ma.flatnotmasked_contiguous&quot;&gt; &lt;code&gt;flatnotmasked_contiguous&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="04c94dfe1278eba9030646d853545708152162d2" translate="yes" xml:space="preserve">
          <source>Axis along which to perform the operation. If None (default), applies to a flattened version of the array.</source>
          <target state="translated">Ось,по которой должна выполняться операция.Если Нет (по умолчанию),применяется к сплющенной версии массива.</target>
        </trans-unit>
        <trans-unit id="504f2a8eb88761fe60f8368b4521f8ae3d7cee4e" translate="yes" xml:space="preserve">
          <source>Axis along which to perform the operation. If None, applies to a flattened version of the array.</source>
          <target state="translated">Ось,по которой должна выполняться операция.Если Нет,применяется к плоской версии массива.</target>
        </trans-unit>
        <trans-unit id="152709e5051b3ce45dda1f386ffce54b5252f137" translate="yes" xml:space="preserve">
          <source>Axis along which to sort. Default is -1, which means sort along the last axis.</source>
          <target state="translated">Ось,по которой надо сортировать.По умолчанию -1,что означает сортировку по последней оси.</target>
        </trans-unit>
        <trans-unit id="2188a35fbb2aa8c603498f4b78d1698cebdd5a7d" translate="yes" xml:space="preserve">
          <source>Axis along which to sort. If None, the array is flattened before sorting. The default is -1, which sorts along the last axis.</source>
          <target state="translated">Ось,по которой надо сортировать.Если Нет,то перед сортировкой массив сплющивается.По умолчанию -1,который сортирует по последней оси.</target>
        </trans-unit>
        <trans-unit id="740a6ece80316cdabae954a87f619b8a229d3521" translate="yes" xml:space="preserve">
          <source>Axis along which to sort. If None, the default, the flattened array is used.</source>
          <target state="translated">Ось,по которой надо сортировать.Если None,то по умолчанию используется плоский массив.</target>
        </trans-unit>
        <trans-unit id="d4ba2932956beb23c342eb9374fa565cb3b55723" translate="yes" xml:space="preserve">
          <source>Axis along which to sort. The default is -1 (the last axis). If None, the flattened array is used.</source>
          <target state="translated">Ось,по которой надо сортировать.По умолчанию -1 (последняя ось).Если None,то используется сплющенный массив.</target>
        </trans-unit>
        <trans-unit id="bf13afc2432793901330c8c7a32dd664b93fb6da" translate="yes" xml:space="preserve">
          <source>Axis along which to take slices. If None (default), work on the flattened array.</source>
          <target state="translated">Ось,по которой можно брать кусочки.Если нет (по умолчанию),работайте с плоским массивом.</target>
        </trans-unit>
        <trans-unit id="862dd8c4bcf2d6630f10d14b83366d28de07835e" translate="yes" xml:space="preserve">
          <source>Axis along which unwrap will operate, default is the last axis.</source>
          <target state="translated">Ось,по которой будет выполняться разворачивание,по умолчанию является последней осью.</target>
        </trans-unit>
        <trans-unit id="2642370e7acd3a38fa3e5ae2e4852e710ae2493f" translate="yes" xml:space="preserve">
          <source>Axis of &lt;code&gt;a&lt;/code&gt; that defines the vector(s). By default, the last axis.</source>
          <target state="translated">Ось &lt;code&gt;a&lt;/code&gt; , определяющая вектор (ы). По умолчанию последняя ось.</target>
        </trans-unit>
        <trans-unit id="ac79a24e9b27340a01d757c607f815c179d09b07" translate="yes" xml:space="preserve">
          <source>Axis of &lt;code&gt;b&lt;/code&gt; that defines the vector(s). By default, the last axis.</source>
          <target state="translated">Ось &lt;code&gt;b&lt;/code&gt; , определяющая вектор (ы). По умолчанию последняя ось.</target>
        </trans-unit>
        <trans-unit id="f367b3271f5fcf8c75672a1e31a99c742130492f" translate="yes" xml:space="preserve">
          <source>Axis of &lt;code&gt;c&lt;/code&gt; containing the cross product vector(s). Ignored if both input vectors have dimension 2, as the return is scalar. By default, the last axis.</source>
          <target state="translated">Ось &lt;code&gt;c&lt;/code&gt; , содержащая вектор (ы) перекрестного произведения. Игнорируется, если оба входных вектора имеют размерность 2, так как возвращаемый результат является скалярным. По умолчанию последняя ось.</target>
        </trans-unit>
        <trans-unit id="73455e870dee7c0562b8878e31766028fce2291e" translate="yes" xml:space="preserve">
          <source>Axis or axes along which a logical AND reduction is performed. The default (&lt;code&gt;axis&lt;/code&gt; = &lt;code&gt;None&lt;/code&gt;) is to perform a logical AND over all the dimensions of the input array. &lt;code&gt;axis&lt;/code&gt; may be negative, in which case it counts from the last to the first axis.</source>
          <target state="translated">Ось или оси, по которым выполняется логическое сокращение AND. По умолчанию ( &lt;code&gt;axis&lt;/code&gt; = &lt;code&gt;None&lt;/code&gt; ) выполняется логическое И по всем измерениям входного массива. &lt;code&gt;axis&lt;/code&gt; может быть отрицательной, и в этом случае она считается от последней до первой оси.</target>
        </trans-unit>
        <trans-unit id="10ee68577b50399a741722b3f075be540558e59c" translate="yes" xml:space="preserve">
          <source>Axis or axes along which a logical AND reduction is performed. The default (&lt;code&gt;axis=None&lt;/code&gt;) is to perform a logical AND over all the dimensions of the input array. &lt;code&gt;axis&lt;/code&gt; may be negative, in which case it counts from the last to the first axis.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f611b0275c8907be5ddfd942eef1d1cb490e3bfa" translate="yes" xml:space="preserve">
          <source>Axis or axes along which a logical OR reduction is performed. The default (&lt;code&gt;axis&lt;/code&gt; = &lt;code&gt;None&lt;/code&gt;) is to perform a logical OR over all the dimensions of the input array. &lt;code&gt;axis&lt;/code&gt; may be negative, in which case it counts from the last to the first axis.</source>
          <target state="translated">Ось или оси, по которым выполняется логическая редукция ИЛИ. По умолчанию ( &lt;code&gt;axis&lt;/code&gt; = &lt;code&gt;None&lt;/code&gt; ) выполняется логическое ИЛИ по всем измерениям входного массива. &lt;code&gt;axis&lt;/code&gt; может быть отрицательной, и в этом случае она считается от последней до первой оси.</target>
        </trans-unit>
        <trans-unit id="4b3cd50c25bcf6114d5dbf62c339109576c970bf" translate="yes" xml:space="preserve">
          <source>Axis or axes along which a logical OR reduction is performed. The default (&lt;code&gt;axis=None&lt;/code&gt;) is to perform a logical OR over all the dimensions of the input array. &lt;code&gt;axis&lt;/code&gt; may be negative, in which case it counts from the last to the first axis.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9fd47f9900eba5a8ae95abac9ad38d16026ca50d" translate="yes" xml:space="preserve">
          <source>Axis or axes along which a product is performed. The default, axis=None, will calculate the product of all the elements in the input array. If axis is negative it counts from the last to the first axis.</source>
          <target state="translated">Оси или оси,по которым выполняется операция.По умолчанию,ось=None,вычисляется произведение всех элементов входного массива.Если ось отрицательна,то она считается от последней к первой оси.</target>
        </trans-unit>
        <trans-unit id="be576580b5bc0f979cac29a5b9d9045456b366f7" translate="yes" xml:space="preserve">
          <source>Axis or axes along which a reduction is performed. The default (&lt;code&gt;axis&lt;/code&gt; = 0) is perform a reduction over the first dimension of the input array. &lt;code&gt;axis&lt;/code&gt; may be negative, in which case it counts from the last to the first axis.</source>
          <target state="translated">Ось или оси, по которым выполняется редукция. По умолчанию ( &lt;code&gt;axis&lt;/code&gt; = 0) выполняется сокращение по первому измерению входного массива. &lt;code&gt;axis&lt;/code&gt; может быть отрицательной, и в этом случае она считается от последней до первой оси.</target>
        </trans-unit>
        <trans-unit id="a9d8568517293b16cabcf73bd06fbc68a72003cd" translate="yes" xml:space="preserve">
          <source>Axis or axes along which a sum is performed. The default, axis=None, will sum all of the elements of the input array. If axis is negative it counts from the last to the first axis.</source>
          <target state="translated">Оси или оси,по которым выполняется сумма.По умолчанию,ось=None,будут суммироваться все элементы входного массива.Если ось отрицательная,то она считается от последней к первой оси.</target>
        </trans-unit>
        <trans-unit id="7cc8bc628160032ea1ebe6f16101b997f0306e3e" translate="yes" xml:space="preserve">
          <source>Axis or axes along which elements are shifted. By default, the array is flattened before shifting, after which the original shape is restored.</source>
          <target state="translated">Оси или оси,по которым перемещаются элементы.По умолчанию массив перед смещением сглаживается,после чего восстанавливается исходная форма.</target>
        </trans-unit>
        <trans-unit id="0e425003e67ef9bdd8af0004538626cffe9c1582" translate="yes" xml:space="preserve">
          <source>Axis or axes along which the count is performed. The default (&lt;code&gt;axis&lt;/code&gt; = &lt;code&gt;None&lt;/code&gt;) performs the count over all the dimensions of the input array. &lt;code&gt;axis&lt;/code&gt; may be negative, in which case it counts from the last to the first axis.</source>
          <target state="translated">Ось или оси, по которым выполняется счет. По умолчанию ( &lt;code&gt;axis&lt;/code&gt; = &lt;code&gt;None&lt;/code&gt; ) выполняется подсчет по всем измерениям входного массива. &lt;code&gt;axis&lt;/code&gt; может быть отрицательной, и в этом случае она считается от последней до первой оси.</target>
        </trans-unit>
        <trans-unit id="dbd8b445b81cd5436ce710f441b84e722e566a56" translate="yes" xml:space="preserve">
          <source>Axis or axes along which the count is performed. The default, None, performs the count over all the dimensions of the input array. &lt;code&gt;axis&lt;/code&gt; may be negative, in which case it counts from the last to the first axis.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="337ec9c050b4ae190316c405d645be292f57618f" translate="yes" xml:space="preserve">
          <source>Axis or axes along which the maximum is computed. The default is to compute the maximum of the flattened array.</source>
          <target state="translated">Оси или оси,по которым рассчитывается максимум.По умолчанию вычисляется максимум сплющенного массива.</target>
        </trans-unit>
        <trans-unit id="5bcbcdbcc90358e775edd4243e64cbf53abf5bcb" translate="yes" xml:space="preserve">
          <source>Axis or axes along which the means are computed. The default is to compute the mean of the flattened array.</source>
          <target state="translated">Оси или оси,по которым рассчитываются средства.По умолчанию вычисляется среднее значение сплющенного массива.</target>
        </trans-unit>
        <trans-unit id="81e7f835d919d359ddd019861026589dd953700f" translate="yes" xml:space="preserve">
          <source>Axis or axes along which the medians are computed. The default is to compute the median along a flattened version of the array. A sequence of axes is supported since version 1.9.0.</source>
          <target state="translated">Оси или топоры,по которым вычисляются медианы.По умолчанию медиана вычисляется вдоль сплющенной версии массива.Последовательность осей поддерживается начиная с версии 1.9.0.</target>
        </trans-unit>
        <trans-unit id="86845400b54274fa2252847f24187b5fc174bc52" translate="yes" xml:space="preserve">
          <source>Axis or axes along which the minimum is computed. The default is to compute the minimum of the flattened array.</source>
          <target state="translated">Оси или оси,по которым рассчитывается минимум.По умолчанию вычисляется минимум сплющенного массива.</target>
        </trans-unit>
        <trans-unit id="afcadb3cc3e2b57bd1839f95d5290aac2075b609" translate="yes" xml:space="preserve">
          <source>Axis or axes along which the percentiles are computed. The default is to compute the percentile(s) along a flattened version of the array.</source>
          <target state="translated">Оси или оси,по которым рассчитываются процентили.По умолчанию процентиль(и)вычисляется вдоль сплющенной версии массива.</target>
        </trans-unit>
        <trans-unit id="1383f75934b288777f915d7bd0d8e7d4bc49532a" translate="yes" xml:space="preserve">
          <source>Axis or axes along which the product is computed. The default is to compute the product of the flattened array.</source>
          <target state="translated">Оси или оси,по которым рассчитывается изделие.По умолчанию вычисляется продукт сплющенного массива.</target>
        </trans-unit>
        <trans-unit id="dc86583a236f0e917d6fd47accfd6b2805fa40e8" translate="yes" xml:space="preserve">
          <source>Axis or axes along which the quantiles are computed. The default is to compute the quantile(s) along a flattened version of the array.</source>
          <target state="translated">Оси или оси,по которым вычисляются квантилы.По умолчанию квантиль вычисляется по сплющенной версии массива.</target>
        </trans-unit>
        <trans-unit id="ff0198667d8f16fd97a42b385598004387813742" translate="yes" xml:space="preserve">
          <source>Axis or axes along which the standard deviation is computed. The default is to compute the standard deviation of the flattened array.</source>
          <target state="translated">Оси или оси,по которым рассчитывается стандартное отклонение.По умолчанию вычисляется стандартное отклонение сплющенного массива.</target>
        </trans-unit>
        <trans-unit id="561888a8d151a5f97b2ece2d51ce899a36bbfbdf" translate="yes" xml:space="preserve">
          <source>Axis or axes along which the sum is computed. The default is to compute the sum of the flattened array.</source>
          <target state="translated">Оси или оси,по которым рассчитывается сумма.По умолчанию вычисляется сумма сплющенного массива.</target>
        </trans-unit>
        <trans-unit id="949a7d6d27806e44a3241bd974384af685d26396" translate="yes" xml:space="preserve">
          <source>Axis or axes along which the variance is computed. The default is to compute the variance of the flattened array.</source>
          <target state="translated">Оси или оси,по которым рассчитывается дисперсия.По умолчанию рассчитывается дисперсия сплющенного массива.</target>
        </trans-unit>
        <trans-unit id="daa1ea5e7ee9d15405e9d59d22ce1b86e2982a0b" translate="yes" xml:space="preserve">
          <source>Axis or axes along which to average &lt;code&gt;a&lt;/code&gt;. The default, axis=None, will average over all of the elements of the input array. If axis is negative it counts from the last to the first axis.</source>
          <target state="translated">Ось или оси, по которым производится усреднение &lt;code&gt;a&lt;/code&gt; . По умолчанию axis = None будет усредняться по всем элементам входного массива. Если ось отрицательная, отсчет ведется от последней до первой оси.</target>
        </trans-unit>
        <trans-unit id="64370fd7391d23015a65d6e00207ab3ff57c0028" translate="yes" xml:space="preserve">
          <source>Axis or axes along which to flip over. The default, axis=None, will flip over all of the axes of the input array. If axis is negative it counts from the last to the first axis.</source>
          <target state="translated">Оси или топоры,по которым нужно перевернуться.По умолчанию,axis=None,будет перевернута по всем осям входного массива.Если ось отрицательна,то она считается от последней к первой.</target>
        </trans-unit>
        <trans-unit id="f2bf5799ae5ef9d1cdddea7d865553db9614fd21" translate="yes" xml:space="preserve">
          <source>Axis or axes along which to operate. By default, flattened input is used.</source>
          <target state="translated">Оси или оси,по которым нужно работать.По умолчанию используется плоский вход.</target>
        </trans-unit>
        <trans-unit id="f257ca43f52b8d212133752a1e0cef3f157fcc12" translate="yes" xml:space="preserve">
          <source>Axis or tuple of axes along which to count non-zeros. Default is None, meaning that non-zeros will be counted along a flattened version of &lt;code&gt;a&lt;/code&gt;.</source>
          <target state="translated">Ось или кортеж осей, по которым следует считать ненулевые. Значение по умолчанию равно None, это означает , что не-нули будут подсчитаны по уплощенной версии . &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="1dfdd6be5ea8d2b943040ace17a9b289e52760e7" translate="yes" xml:space="preserve">
          <source>Axis over which the anomalies are taken. The default is to use the mean of the flattened array as reference.</source>
          <target state="translated">Ось,над которой взяты аномалии.По умолчанию используется среднее значение сплющенного массива.</target>
        </trans-unit>
        <trans-unit id="5a28ddd98da60a547b5ae35ef6abe54e89e91508" translate="yes" xml:space="preserve">
          <source>Axis over which the derivative is taken. (Default: 0).</source>
          <target state="translated">Ось,над которой берется производная.(По умолчанию:0).</target>
        </trans-unit>
        <trans-unit id="ca8db3e3878b22dd385e21680a7f2404ba4af59f" translate="yes" xml:space="preserve">
          <source>Axis over which the integral is taken. (Default: 0).</source>
          <target state="translated">Ось,над которой берется интеграл.(По умолчанию:0).</target>
        </trans-unit>
        <trans-unit id="7238aa3702fcf05542c14de94bdcecf60c8463af" translate="yes" xml:space="preserve">
          <source>Axis over which to compute the FFT. If not given, the last axis is used.</source>
          <target state="translated">Ось,по которой можно вычислить БПФ.Если она не задана,используется последняя ось.</target>
        </trans-unit>
        <trans-unit id="78aed7a81e841b649e307d86af83f2a27f772253" translate="yes" xml:space="preserve">
          <source>Axis over which to compute the inverse DFT. If not given, the last axis is used.</source>
          <target state="translated">Ось,по которой рассчитывается обратный DFT.Если она не задана,используется последняя ось.</target>
        </trans-unit>
        <trans-unit id="1994028401ccc8c25a36ddcd64e63635d1053d3a" translate="yes" xml:space="preserve">
          <source>Axis over which to compute the inverse FFT. If not given, the last axis is used.</source>
          <target state="translated">Ось,по которой рассчитывается обратный БПФ.Если она не задана,используется последняя ось.</target>
        </trans-unit>
        <trans-unit id="7fc8d289aafc37f1ce906424ecc35f2c72d9a34f" translate="yes" xml:space="preserve">
          <source>Axis to be indirectly sorted. By default, sort over the last axis.</source>
          <target state="translated">Ось,которую нужно опосредованно отсортировать.По умолчанию,сортировка по последней оси.</target>
        </trans-unit>
        <trans-unit id="3e1ca61bed45345ef5098f13d05c389833be3df8" translate="yes" xml:space="preserve">
          <source>Axis to be used as the first axis of the 2-D sub-arrays from which the diagonals should be taken. Defaults to first axis (0).</source>
          <target state="translated">Ось,используемая в качестве первой оси двухмерных подмассивов,из которых должны браться диагонали.По умолчанию-первая ось (0).</target>
        </trans-unit>
        <trans-unit id="45f7ee7208a9fb7d4e4732ffbd5f973fe0a479d3" translate="yes" xml:space="preserve">
          <source>Axis to be used as the second axis of the 2-D sub-arrays from which the diagonals should be taken. Defaults to second axis (1).</source>
          <target state="translated">Ось,используемая в качестве второй оси двухмерных подмассивов,из которых следует брать диагонали.По умолчанию вторая ось (1).</target>
        </trans-unit>
        <trans-unit id="ae4f281df5a5d0ff3cad6371f76d5c29b6d953ec" translate="yes" xml:space="preserve">
          <source>B</source>
          <target state="translated">B</target>
        </trans-unit>
        <trans-unit id="c7781e5925cc1162bf57ca801ea173a8789aefd5" translate="yes" xml:space="preserve">
          <source>BEHAVED and C_CONTIGUOUS.</source>
          <target state="translated">BEHAVED и C_CONTIGUOUS.</target>
        </trans-unit>
        <trans-unit id="eca3180a6c33b0a38f6f76fa644f63211aa1f14e" translate="yes" xml:space="preserve">
          <source>BEHAVED and F_CONTIGUOUS and not C_CONTIGUOUS.</source>
          <target state="translated">BEHAVED и F_CONTIGUOUS,а не C_CONTIGUOUS.</target>
        </trans-unit>
        <trans-unit id="c7243d04c977df0309eee7b50ccaddc2665154ee" translate="yes" xml:space="preserve">
          <source>BLAS</source>
          <target state="translated">BLAS</target>
        </trans-unit>
        <trans-unit id="bcd158bb5feaae9038808e3b55d2a031b8ba7709" translate="yes" xml:space="preserve">
          <source>BLAS (NetLIB)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dcf8c920edb3ad9eb9b92f8b67ba19eaaa1b8c86" translate="yes" xml:space="preserve">
          <source>BLIS</source>
          <target state="translated">BLIS</target>
        </trans-unit>
        <trans-unit id="cf867b1a06ac32f25a3a53b5cac69625adf84e3c" translate="yes" xml:space="preserve">
          <source>BLIS support in &lt;code&gt;numpy.distutils&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="214e501b88ef4fd6dfd2e0ceb3d07f872f3aa657" translate="yes" xml:space="preserve">
          <source>BSD / Solaris</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="64dd60fe1a049fe6db3eb1369dec2e42bf428e21" translate="yes" xml:space="preserve">
          <source>Background</source>
          <target state="translated">Background</target>
        </trans-unit>
        <trans-unit id="bd452a7ea759269a521e984eabecb645ce4b2ea6" translate="yes" xml:space="preserve">
          <source>Background information</source>
          <target state="translated">Справочная информация</target>
        </trans-unit>
        <trans-unit id="090a12d667902964e48f38714b38e1c7c7410ac2" translate="yes" xml:space="preserve">
          <source>Backport Pull Requests</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="304c9bb8acb18cf698a66eac9714c36a88110784" translate="yes" xml:space="preserve">
          <source>Backporting</source>
          <target state="translated">Backporting</target>
        </trans-unit>
        <trans-unit id="850de91aa7213a4adf4d94aeab2caaf4d100f909" translate="yes" xml:space="preserve">
          <source>Backporting is the process of copying new feature/fixes committed in &lt;a href=&quot;https://github.com/numpy/numpy&quot;&gt;numpy/master&lt;/a&gt; back to stable release branches. To do this you make a branch off the branch you are backporting to, cherry pick the commits you want from &lt;code&gt;numpy/master&lt;/code&gt;, and then submit a pull request for the branch containing the backport.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="172132c5b69b62eb861ca29a9ea486edc3f7219f" translate="yes" xml:space="preserve">
          <source>Bare metal, wrap your own C-code manually.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="53740dccbfb785b89a2a2e2837295960b3f62362" translate="yes" xml:space="preserve">
          <source>Base Class for generic BitGenerators, which provide a stream of random bits based on different algorithms.</source>
          <target state="translated">Базовый класс для общих BitGenerators,которые обеспечивают поток случайных битов,основанных на различных алгоритмах.</target>
        </trans-unit>
        <trans-unit id="2f03f2251cbc22f3d11027c3e6199900a02163b7" translate="yes" xml:space="preserve">
          <source>Base Class for generic BitGenerators, which provide a stream of random bits based on different algorithms. Must be overridden.</source>
          <target state="translated">Базовый класс для общих BitGenerators,которые обеспечивают поток случайных битов,основанных на различных алгоритмах.Должен быть переопределен.</target>
        </trans-unit>
        <trans-unit id="18c896688f02b72b07f8b6644f275710e91f33b7" translate="yes" xml:space="preserve">
          <source>Base class</source>
          <target state="translated">Базовый класс</target>
        </trans-unit>
        <trans-unit id="c559e4e184dd4d014a0b5060ba07110daeea6a9f" translate="yes" xml:space="preserve">
          <source>Base class for all polynomial types.</source>
          <target state="translated">Базовый класс для всех полиномиальных типов.</target>
        </trans-unit>
        <trans-unit id="6149d0f0d497f5c19a312e242e3099f49c4e1828" translate="yes" xml:space="preserve">
          <source>Base class for errors in this module.</source>
          <target state="translated">Базовый класс для ошибок в этом модуле.</target>
        </trans-unit>
        <trans-unit id="6c3e6ca54a7a88ced88fed404dda8485677d4e2e" translate="yes" xml:space="preserve">
          <source>Base class for numpy scalar types.</source>
          <target state="translated">Базовый класс для нумизматических скалярных типов.</target>
        </trans-unit>
        <trans-unit id="860a1492914588f337f184bd4823757e7c5382ef" translate="yes" xml:space="preserve">
          <source>Base object if memory is from some other object.</source>
          <target state="translated">Базовый объект,если память принадлежит какому-то другому объекту.</target>
        </trans-unit>
        <trans-unit id="e272affdfa292522d2f5ac68c3e4ab276db10b62" translate="yes" xml:space="preserve">
          <source>Base of natural logarithm (</source>
          <target state="translated">База натурального логарифма (</target>
        </trans-unit>
        <trans-unit id="65a08d51a2e698f7325209df48e279e52d580030" translate="yes" xml:space="preserve">
          <source>Base-2 logarithm of &lt;code&gt;2**x1 + 2**x2&lt;/code&gt;. This is a scalar if both &lt;code&gt;x1&lt;/code&gt; and &lt;code&gt;x2&lt;/code&gt; are scalars.</source>
          <target state="translated">Логарифм по основанию &lt;code&gt;2**x1 + 2**x2&lt;/code&gt; . Это скаляр, если и &lt;code&gt;x1&lt;/code&gt; , и &lt;code&gt;x2&lt;/code&gt; являются скалярами.</target>
        </trans-unit>
        <trans-unit id="dc8e13711f25f1ed77c835a90063cf7df6b684db" translate="yes" xml:space="preserve">
          <source>Base-2 logarithm of &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="translated">Логарифм &lt;code&gt;x&lt;/code&gt; по основанию 2 .</target>
        </trans-unit>
        <trans-unit id="99798b5608dba0e80521a63a27ddafba29b89b07" translate="yes" xml:space="preserve">
          <source>Base-2 logarithm of &lt;code&gt;x&lt;/code&gt;. This is a scalar if &lt;code&gt;x&lt;/code&gt; is a scalar.</source>
          <target state="translated">Логарифм &lt;code&gt;x&lt;/code&gt; по основанию 2 . Это скаляр, если &lt;code&gt;x&lt;/code&gt; - скаляр.</target>
        </trans-unit>
        <trans-unit id="38987414db4d1bf81908059ba9b136da28c33714" translate="yes" xml:space="preserve">
          <source>Base-n representations</source>
          <target state="translated">Базовые представления</target>
        </trans-unit>
        <trans-unit id="0bff1548231bd093df6d8bc4bf7a28a9733d2f0e" translate="yes" xml:space="preserve">
          <source>Based on the above characterization, &amp;ldquo;high-priority&amp;rdquo; changes (i.e. fixing technical inaccuracies, broken links, etc.) can be proposed via pull requests directly as they are straightforward to review. Other changes should be raised as issues first so that the discussion can happen before you make major modifications, which in principle saves you from wasting your time on undesired changes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="da94602e9563f3ceebc2fc5b569a77851b4c7e35" translate="yes" xml:space="preserve">
          <source>Basic &lt;a href=&quot;#numpy.einsum&quot;&gt;&lt;code&gt;einsum&lt;/code&gt;&lt;/a&gt;: ~1520ms (benchmarked on 3.1GHz Intel i5.)</source>
          <target state="translated">Базовая &lt;a href=&quot;#numpy.einsum&quot;&gt; &lt;code&gt;einsum&lt;/code&gt; &lt;/a&gt; : ~ 1520 мс (при тестировании на Intel i5 с тактовой частотой 3,1 ГГц)</target>
        </trans-unit>
        <trans-unit id="e6e180bdb3abc214441692c8749fa0f6558a1809" translate="yes" xml:space="preserve">
          <source>Basic Array Flags</source>
          <target state="translated">Основные массивы флагов</target>
        </trans-unit>
        <trans-unit id="e4e049299abaf782878f7f84544dfdb97d319e23" translate="yes" xml:space="preserve">
          <source>Basic Datetimes</source>
          <target state="translated">Основные даты</target>
        </trans-unit>
        <trans-unit id="6081b68b227981c90bce83d2c2beb9f59d79503d" translate="yes" xml:space="preserve">
          <source>Basic Git setup</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7a031fb4b54459f27072c9ee40c4b13ebd94a781" translate="yes" xml:space="preserve">
          <source>Basic Installation</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e5074656d77a5a1b87923975067a88a41f1ac1c1" translate="yes" xml:space="preserve">
          <source>Basic Iteration</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="57a6dc8bc52fe0e5017a1d4e4df961ab713b5b3a" translate="yes" xml:space="preserve">
          <source>Basic Linear Algebra</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c7231dfbf12224ef4a3543250815ccb954fcb938" translate="yes" xml:space="preserve">
          <source>Basic Linear Algebra Subprograms</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9a85f6e8c6ded273cdb7e38718d85979a45dd77e" translate="yes" xml:space="preserve">
          <source>Basic Operations</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7169d2b21ccd399c4bc0e79bbfdd0bd5c61ee835" translate="yes" xml:space="preserve">
          <source>Basic Slicing and Indexing</source>
          <target state="translated">Базовое нарезка и индексирование</target>
        </trans-unit>
        <trans-unit id="60094894bbbb579bd2f4b96162f9928ec2ce169d" translate="yes" xml:space="preserve">
          <source>Basic Statistics</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b9b6d01ce3d08fc15e9971b8d7ad62d621a90733" translate="yes" xml:space="preserve">
          <source>Basic array operations</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bf23a24f7e23fb617c002847d87b0e8162ee99d1" translate="yes" xml:space="preserve">
          <source>Basic customization:</source>
          <target state="translated">Базовая настройка:</target>
        </trans-unit>
        <trans-unit id="4c8d5fdc5db9950cf7bea592d196bad4f803b3fb" translate="yes" xml:space="preserve">
          <source>Basic examples</source>
          <target state="translated">Основные примеры</target>
        </trans-unit>
        <trans-unit id="beb8cd5e0f8e7a06f8d36dc83c4364f7f79078fa" translate="yes" xml:space="preserve">
          <source>Basic operations</source>
          <target state="translated">Основные операции</target>
        </trans-unit>
        <trans-unit id="d6e8bb93c76a2ef8f7afd4a4fc3b007cbfd7ef2c" translate="yes" xml:space="preserve">
          <source>Basic operations are simple with NumPy. If you want to find the sum of the elements in an array, you&amp;rsquo;d use &lt;code&gt;sum()&lt;/code&gt;. This works for 1D arrays, 2D arrays, and arrays in higher dimensions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b900db10ad3fb5583b98ef507ab36ddd8153f435" translate="yes" xml:space="preserve">
          <source>Basic slicing extends Python&amp;rsquo;s basic concept of slicing to N dimensions. Basic slicing occurs when &lt;em&gt;obj&lt;/em&gt; is a &lt;a href=&quot;https://docs.python.org/dev/library/functions.html#slice&quot;&gt;&lt;code&gt;slice&lt;/code&gt;&lt;/a&gt; object (constructed by &lt;code&gt;start:stop:step&lt;/code&gt; notation inside of brackets), an integer, or a tuple of slice objects and integers. &lt;code&gt;Ellipsis&lt;/code&gt; and &lt;a href=&quot;constants#numpy.newaxis&quot;&gt;&lt;code&gt;newaxis&lt;/code&gt;&lt;/a&gt; objects can be interspersed with these as well.</source>
          <target state="translated">Базовая нарезка расширяет базовую концепцию нарезки Python до N измерений. Базовая срезка происходит, когда &lt;em&gt;obj&lt;/em&gt; является объектом &lt;a href=&quot;https://docs.python.org/dev/library/functions.html#slice&quot;&gt; &lt;code&gt;slice&lt;/code&gt; &lt;/a&gt; (созданным с помощью записи &lt;code&gt;start:stop:step&lt;/code&gt; внутри скобок), целым числом или кортежем объектов среза и целых чисел. &lt;code&gt;Ellipsis&lt;/code&gt; и &lt;a href=&quot;constants#numpy.newaxis&quot;&gt; &lt;code&gt;newaxis&lt;/code&gt; &lt;/a&gt; объекты могут быть вкраплены с ними , а также.</target>
        </trans-unit>
        <trans-unit id="b34ccf1a566015b10946e74591046f4136452341" translate="yes" xml:space="preserve">
          <source>Basic slicing with more than one non-&lt;code&gt;:&lt;/code&gt; entry in the slicing tuple, acts like repeated application of slicing using a single non-&lt;code&gt;:&lt;/code&gt; entry, where the non-&lt;code&gt;:&lt;/code&gt; entries are successively taken (with all other non-&lt;code&gt;:&lt;/code&gt; entries replaced by &lt;code&gt;:&lt;/code&gt;). Thus, &lt;code&gt;x[ind1,...,ind2,:]&lt;/code&gt; acts like &lt;code&gt;x[ind1][...,ind2,:]&lt;/code&gt; under basic slicing.</source>
          <target state="translated">Основная нарезка с более чем один не- &lt;code&gt;:&lt;/code&gt; запись в нарезания кортеже, действует как повторное применение нарезки с использованием одной не- &lt;code&gt;:&lt;/code&gt; записи, где не- &lt;code&gt;:&lt;/code&gt; записи последовательно приняты (со всеми другими не- &lt;code&gt;:&lt;/code&gt; записи заменена &lt;code&gt;:&lt;/code&gt; ) . Таким образом, &lt;code&gt;x[ind1,...,ind2,:]&lt;/code&gt; действует как &lt;code&gt;x[ind1][...,ind2,:]&lt;/code&gt; при базовом разрезании.</target>
        </trans-unit>
        <trans-unit id="de17dd65e3190938ee92ddb98549d2245920a8ee" translate="yes" xml:space="preserve">
          <source>Basic usage is to call &lt;a href=&quot;../reference/c-api/array#c.PyArray_IterNew&quot;&gt;&lt;code&gt;PyArray_IterNew&lt;/code&gt;&lt;/a&gt; ( &lt;code&gt;array&lt;/code&gt; ) where array is an ndarray object (or one of its sub-classes). The returned object is an array-iterator object (the same object returned by the .flat attribute of the ndarray). This object is usually cast to PyArrayIterObject* so that its members can be accessed. The only members that are needed are &lt;code&gt;iter-&amp;gt;size&lt;/code&gt; which contains the total size of the array, &lt;code&gt;iter-&amp;gt;index&lt;/code&gt;, which contains the current 1-d index into the array, and &lt;code&gt;iter-&amp;gt;dataptr&lt;/code&gt; which is a pointer to the data for the current element of the array. Sometimes it is also useful to access &lt;code&gt;iter-&amp;gt;ao&lt;/code&gt; which is a pointer to the underlying ndarray object.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="af837eca09697118dc16afab4a2dc5bfeccd2a15" translate="yes" xml:space="preserve">
          <source>Basic usage. Note how y is the &amp;ldquo;flattened&amp;rdquo; version of [a[:, 0, :], a[:, 1, 0], a[:, 2, :]] since we specified the first iter&amp;rsquo;s axes as [1]</source>
          <target state="translated">Основное использование. Обратите внимание, что y - это &amp;laquo;сплющенная&amp;raquo; версия [a [:, 0,:], a [:, 1, 0], a [:, 2,:]], поскольку мы указали оси первого элемента как [1]</target>
        </trans-unit>
        <trans-unit id="189ceeabec801d69e58e27b3296832fd339cfd5c" translate="yes" xml:space="preserve">
          <source>Basic workflow</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5fcebeefad3cdbbf8733aa928160dec7dc90c1a1" translate="yes" xml:space="preserve">
          <source>Basics</source>
          <target state="translated">Basics</target>
        </trans-unit>
        <trans-unit id="4ce3c1a6b26e31f8d07ec92f4cb05d49b3eec33d" translate="yes" xml:space="preserve">
          <source>Be aware that when NumPy prints N-dimensional arrays, the last axis is looped over the fastest while the first axis is the slowest. For instance:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="11716f1e3c0926fa9c04fbb3c924f0811bf4b112" translate="yes" xml:space="preserve">
          <source>Be careful about round-off error!</source>
          <target state="translated">Будьте осторожны с ошибкой округления!</target>
        </trans-unit>
        <trans-unit id="3008b1888d55827508c13f2c0985bc725a03a91e" translate="yes" xml:space="preserve">
          <source>Be careful in the words that we choose. We are careful and respectful in our communication and we take responsibility for our own speech. Be kind to others. Do not insult or put down other participants. We will not accept harassment or other exclusionary behaviour, such as:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a95dfdc69ac7b8c496606d6afad271cdcc3a6cdb" translate="yes" xml:space="preserve">
          <source>Be collaborative. Our work will be used by other people, and in turn we will depend on the work of others. When we make something for the benefit of the project, we are willing to explain to others how it works, so that they can build on the work to make it even better. Any decision we make will affect users and colleagues, and we take those consequences seriously when making decisions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ff801bed133a99446534aede438fa2583bcd9e5a" translate="yes" xml:space="preserve">
          <source>Be empathetic, welcoming, friendly, and patient. We work together to resolve conflict, and assume good intentions. We may all experience some frustration from time to time, but we do not allow frustration to turn into a personal attack. A community where people feel uncomfortable or threatened is not a productive one.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3eaab4694464d982dfc3e0a1afc07f0c4449c8cc" translate="yes" xml:space="preserve">
          <source>Be inquisitive. Nobody knows everything! Asking questions early avoids many problems later, so we encourage questions, although we may direct them to the appropriate forum. We will try hard to be responsive and helpful.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6a20b0ffbe846eba275eb3ea56da6251c7cd9752" translate="yes" xml:space="preserve">
          <source>Be mindful of the needs of new members: provide them with explicit support and consideration, with the aim of increasing participation from underrepresented groups in particular.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1f37a97353eabf9fd15a91dbc5d9f5eb04cea0bf" translate="yes" xml:space="preserve">
          <source>Be mindful that large arrays created with &lt;code&gt;np.empty&lt;/code&gt; or &lt;code&gt;np.zeros&lt;/code&gt; might not be allocated in physical memory until the memory is accessed. If this is desired behaviour, make sure to comment it in your setup function. If you are benchmarking an algorithm, it is unlikely that a user will be executing said algorithm on a newly created empty/zero array. One can force pagefaults to occur in the setup phase either by calling &lt;code&gt;np.ones&lt;/code&gt; or &lt;code&gt;arr.fill(value)&lt;/code&gt; after creating the array,</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3730bbeeef610bbf04c76abf5ec330327e101406" translate="yes" xml:space="preserve">
          <source>Be open. We invite anyone to participate in our community. We prefer to use public methods of communication for project-related messages, unless discussing something sensitive. This applies to messages for help or project-related support, too; not only is a public support request much more likely to result in an answer to a question, it also ensures that any inadvertent mistakes in answering are more easily detected and corrected.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ac10e1f58e2260e13e0683472d08e8f00358973a" translate="yes" xml:space="preserve">
          <source>Be sure to understand what steps you should take to manage the memory when using these conversion functions. These functions can require freeing memory, and/or altering the reference counts of specific objects based on your use.</source>
          <target state="translated">Убедитесь,что вы понимаете,какие шаги нужно предпринять для управления памятью при использовании этих функций преобразования.Эти функции могут потребовать освобождения памяти и/или изменения количества ссылок на конкретные объекты в зависимости от их использования.</target>
        </trans-unit>
        <trans-unit id="6e72bb7e156cb39574b057b9674c2412ed422481" translate="yes" xml:space="preserve">
          <source>Be warned that even if &lt;code&gt;np.longdouble&lt;/code&gt; offers more precision than python &lt;code&gt;float&lt;/code&gt;, it is easy to lose that extra precision, since python often forces values to pass through &lt;code&gt;float&lt;/code&gt;. For example, the &lt;code&gt;%&lt;/code&gt; formatting operator requires its arguments to be converted to standard python types, and it is therefore impossible to preserve extended precision even if many decimal places are requested. It can be useful to test your code with the value &lt;code&gt;1 + np.finfo(np.longdouble).eps&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="782223c5915f4980a539ed4710dad922b52bef1d" translate="yes" xml:space="preserve">
          <source>Because &lt;a href=&quot;generated/numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;ndarray&lt;/code&gt;&lt;/a&gt; is a built-in type (written in C), the &lt;code&gt;__r{op}__&lt;/code&gt; special methods are not directly defined.</source>
          <target state="translated">Поскольку &lt;a href=&quot;generated/numpy.ndarray#numpy.ndarray&quot;&gt; &lt;code&gt;ndarray&lt;/code&gt; &lt;/a&gt; - это встроенный тип (написанный на C), специальные методы &lt;code&gt;__r{op}__&lt;/code&gt; не определены напрямую.</target>
        </trans-unit>
        <trans-unit id="d79cf7f45add11b370a63146a7703acf9ea33ca1" translate="yes" xml:space="preserve">
          <source>Because &lt;code&gt;__array_finalize__&lt;/code&gt; is the only method that always sees new instances being created, it is the sensible place to fill in instance defaults for new object attributes, among other tasks.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cc46c55e2dfa187c2ac071bbb4bae1702d622519" translate="yes" xml:space="preserve">
          <source>Because Python strings are immutable, an &lt;code&gt;intent(inout)&lt;/code&gt; argument expects an array version of a string in order to have &lt;em&gt;in situ&lt;/em&gt; changes be effective.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b4ea4687fdb37cf012f30310b86e8fc32c6c91ad" translate="yes" xml:space="preserve">
          <source>Because access to additional information is so useful, IPython uses the &lt;code&gt;?&lt;/code&gt; character as a shorthand for accessing this documentation along with other relevant information. IPython is a command shell for interactive computing in multiple languages. &lt;a href=&quot;https://ipython.org/&quot;&gt;You can find more information about IPython here&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="67d90e5f1ae663c377ee558cca369308548469d2" translate="yes" xml:space="preserve">
          <source>Because exact overlap detection has exponential runtime in the number of dimensions, the decision is made based on heuristics, which has false positives (needless copies in unusual cases) but has no false negatives.</source>
          <target state="translated">Поскольку точное обнаружение перекрытия имеет экспоненциальное время выполнения по количеству измерений,решение принимается на основе эвристики,которая имеет ложноположительные результаты (ненужные копии в необычных случаях),но не имеет ложноотрицательных.</target>
        </trans-unit>
        <trans-unit id="b6f4af8bef1f35015b148a058f523cde0f4ccc9d" translate="yes" xml:space="preserve">
          <source>Because of how &lt;a href=&quot;numpy.array#numpy.array&quot;&gt;&lt;code&gt;array&lt;/code&gt;&lt;/a&gt; handles sets, the following does not work as expected:</source>
          <target state="translated">Из-за того, как &lt;a href=&quot;numpy.array#numpy.array&quot;&gt; &lt;code&gt;array&lt;/code&gt; &lt;/a&gt; обрабатывают наборы, следующее не работает должным образом:</target>
        </trans-unit>
        <trans-unit id="4a390a00169642b8c370c2fa0fa4fb8d3ba973c7" translate="yes" xml:space="preserve">
          <source>Because of the difficulty in distributing an extension module made using ctypes, f2py and Cython are still the easiest ways to extend Python for package creation. However, ctypes is in some cases a useful alternative. This should bring more features to ctypes that should eliminate the difficulty in extending Python and distributing the extension using ctypes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c5a38fa639091b6298538af300d0ae57dcac2792" translate="yes" xml:space="preserve">
          <source>Because python extensions are not used in the same way as usual libraries on most platforms, some errors cannot be automatically detected at build time or even runtime. For example, if you build an extension using a function available only for numpy &amp;gt;= 1.3.0, and you import the extension later with numpy 1.2, you will not get an import error (but almost certainly a segmentation fault when calling the function). That&amp;rsquo;s why several functions are provided to check for numpy versions. The macros &lt;a href=&quot;#c.NPY_VERSION&quot;&gt;&lt;code&gt;NPY_VERSION&lt;/code&gt;&lt;/a&gt; and &lt;code&gt;NPY_FEATURE_VERSION&lt;/code&gt; corresponds to the numpy version used to build the extension, whereas the versions returned by the functions PyArray_GetNDArrayCVersion and PyArray_GetNDArrayCFeatureVersion corresponds to the runtime numpy&amp;rsquo;s version.</source>
          <target state="translated">Поскольку расширения python не используются так же, как обычные библиотеки на большинстве платформ, некоторые ошибки не могут быть автоматически обнаружены во время сборки или даже во время выполнения. Например, если вы создаете расширение, используя функцию, доступную только для numpy&amp;gt; = 1.3.0, и импортируете расширение позже с помощью numpy 1.2, вы не получите ошибку импорта (но почти наверняка ошибку сегментации при вызове функции) . Вот почему предусмотрено несколько функций для проверки количества версий. Макросы &lt;a href=&quot;#c.NPY_VERSION&quot;&gt; &lt;code&gt;NPY_VERSION&lt;/code&gt; &lt;/a&gt; и &lt;code&gt;NPY_FEATURE_VERSION&lt;/code&gt; соответствует Numpy версии , используемой для создания расширения, в то время как версии , возвращаемых функции PyArray_GetNDArrayCVersion и PyArray_GetNDArrayCFeatureVersion соответствует версии среды выполнения Numpy в.</target>
        </trans-unit>
        <trans-unit id="00d51d08a981e99f75ad16b5ac99f6d7fcbcfe04" translate="yes" xml:space="preserve">
          <source>Because the ctypes approach exposes a raw interface to the compiled code it is not always tolerant of user mistakes. Robust use of the ctypes module typically involves an additional layer of Python code in order to check the data types and array bounds of objects passed to the underlying subroutine. This additional layer of checking (not to mention the conversion from ctypes objects to C-data-types that ctypes itself performs), will make the interface slower than a hand-written extension-module interface. However, this overhead should be negligible if the C-routine being called is doing any significant amount of work. If you are a great Python programmer with weak C skills, ctypes is an easy way to write a useful interface to a (shared) library of compiled code.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="29dd075a4977fb05332410d8621bf30c67da289c" translate="yes" xml:space="preserve">
          <source>Because the discrete Fourier transform separates its input into components that contribute at discrete frequencies, it has a great number of applications in digital signal processing, e.g., for filtering, and in this context the discretized input to the transform is customarily referred to as a &lt;em&gt;signal&lt;/em&gt;, which exists in the &lt;em&gt;time domain&lt;/em&gt;. The output is called a &lt;em&gt;spectrum&lt;/em&gt; or &lt;em&gt;transform&lt;/em&gt; and exists in the &lt;em&gt;frequency domain&lt;/em&gt;.</source>
          <target state="translated">Поскольку дискретное преобразование Фурье разделяет свой вход на компоненты, которые вносят вклад на дискретных частотах, оно имеет большое количество приложений в цифровой обработке сигналов, например, для фильтрации, и в этом контексте дискретный вход преобразования обычно называется &lt;em&gt;сигналом.&lt;/em&gt; , который существует во &lt;em&gt;временной области&lt;/em&gt; . Выходной сигнал называется &lt;em&gt;спектром&lt;/em&gt; или &lt;em&gt;преобразованием&lt;/em&gt; и существует в &lt;em&gt;частотной области&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="9e9097d0b4adb9f9ce14f47bf1a8961a11b5917f" translate="yes" xml:space="preserve">
          <source>Because the output is limited to the range of the C int64 type, a ValueError is raised when &lt;code&gt;lam&lt;/code&gt; is within 10 sigma of the maximum representable value.</source>
          <target state="translated">Поскольку вывод ограничен диапазоном типа C int64, ValueError возникает, когда &lt;code&gt;lam&lt;/code&gt; находится в пределах 10 сигм от максимального представимого значения.</target>
        </trans-unit>
        <trans-unit id="fac8d49cb6d5e3c4d76e0475c48ac86177c281c5" translate="yes" xml:space="preserve">
          <source>Because the special treatment of tuples, they are not automatically converted to an array as a list would be. As an example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b9411fa9bcced44864e82d01d766c1a2786cafda" translate="yes" xml:space="preserve">
          <source>Because you shouldn&amp;rsquo;t have done that.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e66686e9fe82b8c4d1e36e68b32d366de35a5f9f" translate="yes" xml:space="preserve">
          <source>Before beginning, ensure that &lt;em&gt;airspeed velocity&lt;/em&gt; is installed. By default, &lt;code&gt;asv&lt;/code&gt; ships with support for anaconda and virtualenv:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a4352ccd0a83ad23754cd59af6872e1e5131c575" translate="yes" xml:space="preserve">
          <source>Before reading this tutorial you should know a bit of Python. If you would like to refresh your memory, take a look at the &lt;a href=&quot;https://docs.python.org/tutorial/&quot;&gt;Python tutorial&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ab8362b68d70c7caa9ac18442122ac15a5a21eab" translate="yes" xml:space="preserve">
          <source>Before reading this tutorial, you should know a bit of Python. If you would like to refresh your memory, take a look at the &lt;a href=&quot;https://docs.python.org/dev/tutorial/index.html&quot;&gt;Python tutorial&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6701eda483d7c3d519624fb81a0315cb15ec0008" translate="yes" xml:space="preserve">
          <source>Before reading this, it may help to familiarize yourself with the basics of C extensions for Python by reading/skimming the tutorials in Section 1 of &lt;a href=&quot;https://docs.python.org/extending/index.html&quot;&gt;Extending and Embedding the Python Interpreter&lt;/a&gt; and in &lt;a href=&quot;c-info.how-to-extend&quot;&gt;How to extend NumPy&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="32836ad1d5d4d4bb58df8da3afbc677909c61049" translate="yes" xml:space="preserve">
          <source>Before the release branch is made, it should be checked that all deprecated code that should be removed is actually removed, and all new deprecations say in the docstring or deprecation warning at what version the code will be removed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6843f140ae464de1cf1062218ac15fdc241e46ba" translate="yes" xml:space="preserve">
          <source>Before you can register a 1-d loop for a ufunc, the ufunc must be previously created. Then you call &lt;a href=&quot;../reference/c-api/ufunc#c.PyUFunc_RegisterLoopForType&quot;&gt;&lt;code&gt;PyUFunc_RegisterLoopForType&lt;/code&gt;&lt;/a&gt; (&amp;hellip;) with the information needed for the loop. The return value of this function is &lt;code&gt;0&lt;/code&gt; if the process was successful and &lt;code&gt;-1&lt;/code&gt; with an error condition set if it was not successful.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="29cee176b513b19c85d7dfdf113b326997fd0f33" translate="yes" xml:space="preserve">
          <source>Behavior when the covariance matrix is not positive semidefinite.</source>
          <target state="translated">Поведение,когда ковариационная матрица не является положительной полубесконечной.</target>
        </trans-unit>
        <trans-unit id="20b4ea80568cb9ce63d7c954c6894e4b50f0041f" translate="yes" xml:space="preserve">
          <source>Below I&amp;rsquo;ll describe three typical approaches of using F2PY. The following example Fortran 77 code will be used for illustration, save it as fib1.f:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="252e06d389a00c02f7e08aa374784958db4dd768" translate="yes" xml:space="preserve">
          <source>Below are the public attributes of this object which were documented in &amp;ldquo;Guide to NumPy&amp;rdquo; (we have omitted undocumented public attributes, as well as documented private attributes):</source>
          <target state="translated">Ниже приведены общедоступные атрибуты этого объекта, которые были задокументированы в &amp;laquo;Руководстве по NumPy&amp;raquo; (мы опустили недокументированные общедоступные атрибуты, а также задокументированные частные атрибуты):</target>
        </trans-unit>
        <trans-unit id="94890db1b347a181e379f1b5ca0fad5bcd6b3fc7" translate="yes" xml:space="preserve">
          <source>Below is an example of a minimal &lt;code&gt;setup.py&lt;/code&gt; file for a pure SciPy package:</source>
          <target state="translated">Ниже приведен пример минимального файла &lt;code&gt;setup.py&lt;/code&gt; для чистого пакета SciPy:</target>
        </trans-unit>
        <trans-unit id="525759fddd68e1f874367bb6bfc9a8ba5f573531" translate="yes" xml:space="preserve">
          <source>Below, are several code examples and graphical representations that help make the broadcast rule visually obvious. &lt;a href=&quot;#example-3&quot;&gt;Example 3&lt;/a&gt; adds a one-dimensional array to a two-dimensional array:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6f3b2ca2746598a5c0c336c60d7f1e5542f3b64a" translate="yes" xml:space="preserve">
          <source>Benchmarking</source>
          <target state="translated">Benchmarking</target>
        </trans-unit>
        <trans-unit id="817dcc8fca981b9f81e80ededa53ee4f0c2fe004" translate="yes" xml:space="preserve">
          <source>Benchmarking NumPy with Airspeed Velocity.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a532923696aa5c8f039ac98c01ebbdc352eb0162" translate="yes" xml:space="preserve">
          <source>Benchmarks are like tests, but have names starting with &amp;ldquo;bench&amp;rdquo; instead of &amp;ldquo;test&amp;rdquo;, and can be found under the &amp;ldquo;benchmarks&amp;rdquo; sub-directory of the module.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9e0aad69f001fa26b773185a06a8bef93c3f6567" translate="yes" xml:space="preserve">
          <source>Bernoulli trials are experiments with one of two outcomes: success or failure (an example of such an experiment is flipping a coin). The geometric distribution models the number of trials that must be run in order to achieve success. It is therefore supported on the positive integers, &lt;code&gt;k = 1, 2, ...&lt;/code&gt;.</source>
          <target state="translated">Испытания Бернулли - это эксперименты с одним из двух результатов: успех или неудача (пример такого эксперимента - подбрасывание монеты). Геометрическое распределение моделирует количество испытаний, которые необходимо выполнить, чтобы добиться успеха. Поэтому поддерживается на положительные целые числа, &lt;code&gt;k = 1, 2, ...&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9fb2a7b505b1b75b34095ee2ffe16a241dd5bdfa" translate="yes" xml:space="preserve">
          <source>Besides &lt;code&gt;sys.stdout&lt;/code&gt;, a file-like object can also be used as it has both required methods:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4e5ba1e315701c442ad54ed60833fcd6227c3ccc" translate="yes" xml:space="preserve">
          <source>Besides creating an array from a sequence of elements, you can easily create an array filled with &lt;code&gt;0&lt;/code&gt;&amp;rsquo;s:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="feb46c86681950d0f6eb887f4a6fb11b462f9f2e" translate="yes" xml:space="preserve">
          <source>Besides its obvious scientific uses, &lt;em&gt;NumPy&lt;/em&gt; can also be used as an efficient multi-dimensional container of generic data. Arbitrary data types can be defined. This allows &lt;em&gt;NumPy&lt;/em&gt; to seamlessly and speedily integrate with a wide variety of databases.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ab274f607cf51efd384bd87e6b3a93295c182bec" translate="yes" xml:space="preserve">
          <source>Besides the structural information contained in the strides and dimensions members of the &lt;a href=&quot;c-api.types-and-structures#c.PyArrayObject&quot;&gt;&lt;code&gt;PyArrayObject&lt;/code&gt;&lt;/a&gt;, the flags contain important information about how the data may be accessed. In particular, the &lt;a href=&quot;c-api.array#c.NPY_ARRAY_ALIGNED&quot;&gt;&lt;code&gt;NPY_ARRAY_ALIGNED&lt;/code&gt;&lt;/a&gt; flag is set when the memory is on a suitable boundary according to the data-type array. Even if you have a contiguous chunk of memory, you cannot just assume it is safe to dereference a data- type-specific pointer to an element. Only if the &lt;a href=&quot;c-api.array#c.NPY_ARRAY_ALIGNED&quot;&gt;&lt;code&gt;NPY_ARRAY_ALIGNED&lt;/code&gt;&lt;/a&gt; flag is set is this a safe operation (on some platforms it will work but on others, like Solaris, it will cause a bus error). The &lt;a href=&quot;c-api.array#c.NPY_ARRAY_WRITEABLE&quot;&gt;&lt;code&gt;NPY_ARRAY_WRITEABLE&lt;/code&gt;&lt;/a&gt; should also be ensured if you plan on writing to the memory area of the array. It is also possible to obtain a pointer to an unwritable memory area. Sometimes, writing to the memory area when the &lt;a href=&quot;c-api.array#c.NPY_ARRAY_WRITEABLE&quot;&gt;&lt;code&gt;NPY_ARRAY_WRITEABLE&lt;/code&gt;&lt;/a&gt; flag is not set will just be rude. Other times it can cause program crashes ( &lt;em&gt;e.g.&lt;/em&gt; a data-area that is a read-only memory-mapped file).</source>
          <target state="translated">Помимо структурной информации, содержащейся в членах &lt;a href=&quot;c-api.types-and-structures#c.PyArrayObject&quot;&gt; &lt;code&gt;PyArrayObject&lt;/code&gt; &lt;/a&gt; и sizes объекта PyArrayObject , флаги содержат важную информацию о том, как можно получить доступ к данным. В частности, флаг &lt;a href=&quot;c-api.array#c.NPY_ARRAY_ALIGNED&quot;&gt; &lt;code&gt;NPY_ARRAY_ALIGNED&lt;/code&gt; &lt;/a&gt; устанавливается, когда память находится на подходящей границе в соответствии с массивом типов данных. Даже если у вас есть непрерывный кусок памяти, вы не можете просто предполагать, что безопасно разыменовать указатель на элемент, зависящий от типа данных. Только если &lt;a href=&quot;c-api.array#c.NPY_ARRAY_ALIGNED&quot;&gt; &lt;code&gt;NPY_ARRAY_ALIGNED&lt;/code&gt; &lt;/a&gt; флаг NPY_ARRAY_ALIGNED, это безопасная операция (на некоторых платформах она будет работать, но на других, таких как Solaris, это вызовет ошибку шины). &lt;a href=&quot;c-api.array#c.NPY_ARRAY_WRITEABLE&quot;&gt; &lt;code&gt;NPY_ARRAY_WRITEABLE&lt;/code&gt; &lt;/a&gt;также должно быть гарантировано, если вы планируете записывать в область памяти массива. Также возможно получить указатель на незаписываемую область памяти. Иногда запись в область памяти, когда флаг &lt;a href=&quot;c-api.array#c.NPY_ARRAY_WRITEABLE&quot;&gt; &lt;code&gt;NPY_ARRAY_WRITEABLE&lt;/code&gt; &lt;/a&gt; не установлен, будет просто грубой. В других случаях это может вызвать сбой программы ( &lt;em&gt;например, область&lt;/em&gt; данных, которая является файлом с отображением памяти только для чтения).</target>
        </trans-unit>
        <trans-unit id="7552a827553f203cc1e2b5ca99b7201f49328d40" translate="yes" xml:space="preserve">
          <source>Besides the structural information contained in the strides and dimensions members of the &lt;a href=&quot;c-api/types-and-structures#c.PyArrayObject&quot;&gt;&lt;code&gt;PyArrayObject&lt;/code&gt;&lt;/a&gt;, the flags contain important information about how the data may be accessed. In particular, the &lt;a href=&quot;c-api/array#c.NPY_ARRAY_ALIGNED&quot;&gt;&lt;code&gt;NPY_ARRAY_ALIGNED&lt;/code&gt;&lt;/a&gt; flag is set when the memory is on a suitable boundary according to the data-type array. Even if you have a contiguous chunk of memory, you cannot just assume it is safe to dereference a data- type-specific pointer to an element. Only if the &lt;a href=&quot;c-api/array#c.NPY_ARRAY_ALIGNED&quot;&gt;&lt;code&gt;NPY_ARRAY_ALIGNED&lt;/code&gt;&lt;/a&gt; flag is set is this a safe operation (on some platforms it will work but on others, like Solaris, it will cause a bus error). The &lt;a href=&quot;c-api/array#c.NPY_ARRAY_WRITEABLE&quot;&gt;&lt;code&gt;NPY_ARRAY_WRITEABLE&lt;/code&gt;&lt;/a&gt; should also be ensured if you plan on writing to the memory area of the array. It is also possible to obtain a pointer to an unwritable memory area. Sometimes, writing to the memory area when the &lt;a href=&quot;c-api/array#c.NPY_ARRAY_WRITEABLE&quot;&gt;&lt;code&gt;NPY_ARRAY_WRITEABLE&lt;/code&gt;&lt;/a&gt; flag is not set will just be rude. Other times it can cause program crashes ( &lt;em&gt;e.g.&lt;/em&gt; a data-area that is a read-only memory-mapped file).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e1ba37be85f86a4053d7f866745343aa6628b3b0" translate="yes" xml:space="preserve">
          <source>Besides using &lt;code&gt;runtests.py&lt;/code&gt;, there are various ways to run the tests. Inside the interpreter, tests can be run like this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2bf0953ee914f2edfe24d253c99b5774c0b042b9" translate="yes" xml:space="preserve">
          <source>Best choice for unitary and other non-Hermitian normal matrices.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="22e034c69c8701c0ed22fdd3834451a1ee6eff5e" translate="yes" xml:space="preserve">
          <source>Best practice for achieving reproducible bit streams is to use the default &lt;code&gt;None&lt;/code&gt; for the initial entropy, and then use &lt;a href=&quot;numpy.random.seedsequence.entropy#numpy.random.SeedSequence.entropy&quot;&gt;&lt;code&gt;SeedSequence.entropy&lt;/code&gt;&lt;/a&gt; to log/pickle the &lt;a href=&quot;../../entropy#module-numpy.random.entropy&quot;&gt;&lt;code&gt;entropy&lt;/code&gt;&lt;/a&gt; for reproducibility:</source>
          <target state="translated">Лучшая практика для достижения воспроизводимых битовых потоков - использовать значение по умолчанию &lt;code&gt;None&lt;/code&gt; для начальной энтропии, а затем использовать &lt;a href=&quot;numpy.random.seedsequence.entropy#numpy.random.SeedSequence.entropy&quot;&gt; &lt;code&gt;SeedSequence.entropy&lt;/code&gt; &lt;/a&gt; для регистрации / обработки &lt;a href=&quot;../../entropy#module-numpy.random.entropy&quot;&gt; &lt;code&gt;entropy&lt;/code&gt; &lt;/a&gt; для воспроизводимости:</target>
        </trans-unit>
        <trans-unit id="7670ec2417d2f252a955be33c6c1b4f20bd90718" translate="yes" xml:space="preserve">
          <source>Best practice for achieving reproducible bit streams is to use the default &lt;code&gt;None&lt;/code&gt; for the initial entropy, and then use &lt;a href=&quot;numpy.random.seedsequence.entropy#numpy.random.SeedSequence.entropy&quot;&gt;&lt;code&gt;SeedSequence.entropy&lt;/code&gt;&lt;/a&gt; to log/pickle the &lt;a href=&quot;numpy.random.seedsequence.entropy#numpy.random.SeedSequence.entropy&quot;&gt;&lt;code&gt;entropy&lt;/code&gt;&lt;/a&gt; for reproducibility:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ff113b93867eb5d4708dd06e48a11f6662278fd5" translate="yes" xml:space="preserve">
          <source>Beta, positive (&amp;gt;0).</source>
          <target state="translated">Бета, положительный (&amp;gt; 0).</target>
        </trans-unit>
        <trans-unit id="df6d93c232f8ef730e08cac2f842b70dab985fb0" translate="yes" xml:space="preserve">
          <source>Beta: &amp;lsquo;1.8.0b1&amp;rsquo;, &amp;lsquo;1.8.0b2&amp;rsquo;, etc.</source>
          <target state="translated">Бета: 1.8.0b1, 1.8.0b2 и т. Д.</target>
        </trans-unit>
        <trans-unit id="e5c69acc70fda034169d23116e19f5548d61c870" translate="yes" xml:space="preserve">
          <source>Better &lt;code&gt;repr&lt;/code&gt; of object arrays</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="71ff91962e9990f86b3c3c6f7d7e56caab72ace4" translate="yes" xml:space="preserve">
          <source>Better behaviour of ufunc identities during reductions</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2e8b6f98e6b21c5c6afa9104a0769b9205288f70" translate="yes" xml:space="preserve">
          <source>Better default repr for &lt;code&gt;ndarray&lt;/code&gt; subclasses</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9c34cb1b69a33b2d347cbab7a352fe546099b5b5" translate="yes" xml:space="preserve">
          <source>Better numerical stability for sum in some cases</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c1c0df1717608a8779754648098f8f6a8b834b75" translate="yes" xml:space="preserve">
          <source>Better support for &lt;code&gt;const&lt;/code&gt; dimensions in API functions</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9bf8b70bc38b460cf450f48cba644f58d2901785" translate="yes" xml:space="preserve">
          <source>Better support for empty structured and string types</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="741240e1ef7d29df48749ede4195530d21b5583c" translate="yes" xml:space="preserve">
          <source>Beyond changes to a functions docstring and possible description in the general documentation, if your change introduces any user-facing modifications they may need to be mentioned in the release notes. To add your change to the release notes, you need to create a short file with a summary and place it in &lt;code&gt;doc/release/upcoming_changes&lt;/code&gt;. The file &lt;code&gt;doc/release/upcoming_changes/README.rst&lt;/code&gt; details the format and filename conventions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1d7c1c795d86187e8f7208b51b9e4bbd86fa144c" translate="yes" xml:space="preserve">
          <source>Beyond the Basics</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="26ffbba2ad335a399beb79e57cd9f0fee4d0bfe1" translate="yes" xml:space="preserve">
          <source>Beyond the Provided Typemaps</source>
          <target state="translated">За пределами предоставленных типов карт</target>
        </trans-unit>
        <trans-unit id="2381a720988421ed44a915283532f745ec598844" translate="yes" xml:space="preserve">
          <source>Binary Format Description</source>
          <target state="translated">Двоичный формат Описание</target>
        </trans-unit>
        <trans-unit id="b26f6c63a335a90adeeab8f4d5013e4f2efe2bec" translate="yes" xml:space="preserve">
          <source>Binary operations</source>
          <target state="translated">двоичные операции</target>
        </trans-unit>
        <trans-unit id="e2606828726dd092395e99ae84af2fb16d4bba99" translate="yes" xml:space="preserve">
          <source>Binary operations with non-arrays as second argument</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1cc036b4a48151bfca642ff2ead78a54a934983c" translate="yes" xml:space="preserve">
          <source>Binary representation of &lt;code&gt;num&lt;/code&gt; or two&amp;rsquo;s complement of &lt;code&gt;num&lt;/code&gt;.</source>
          <target state="translated">Двоичное представление &lt;code&gt;num&lt;/code&gt; или дополнения до двух из &lt;code&gt;num&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9cc1259e21c7e613999e790394c5c675e22538ae" translate="yes" xml:space="preserve">
          <source>Binary search is used to find the required insertion points.</source>
          <target state="translated">Двоичный поиск используется для поиска необходимых точек вставки.</target>
        </trans-unit>
        <trans-unit id="d16d7bbb9c6ef7dc7a209b9f7f44b9f5da556503" translate="yes" xml:space="preserve">
          <source>Binary serialization</source>
          <target state="translated">бинарная сериализация</target>
        </trans-unit>
        <trans-unit id="c2fcfedbbaa7680e63fd8ec6b6d6fea722eb952d" translate="yes" xml:space="preserve">
          <source>Binomials</source>
          <target state="translated">Binomials</target>
        </trans-unit>
        <trans-unit id="d12186b0252e4232a8110ba893b738140b658fd0" translate="yes" xml:space="preserve">
          <source>Bit Generators</source>
          <target state="translated">Генераторы битов</target>
        </trans-unit>
        <trans-unit id="d9ea127fdd4796c75fc01357c967509bff02d70a" translate="yes" xml:space="preserve">
          <source>Bit field (following integer gives the number of bits in the bit field).</source>
          <target state="translated">Битовое поле (следующее за ним целое число дает количество битов в битовом поле).</target>
        </trans-unit>
        <trans-unit id="4239f8b7894d76bb52c94538f111a8da8d4fb0a0" translate="yes" xml:space="preserve">
          <source>Bit packing</source>
          <target state="translated">Битовая упаковка</target>
        </trans-unit>
        <trans-unit id="b80dbb4a253c53f5aa98843beeecc669ef1da4eb" translate="yes" xml:space="preserve">
          <source>Bit-flags describing how this data type is to be interpreted.</source>
          <target state="translated">Битовые флаги,описывающие,как должен интерпретироваться этот тип данных.</target>
        </trans-unit>
        <trans-unit id="59a321c44dd261b336bb24b8f3a93b2ffcf9ad14" translate="yes" xml:space="preserve">
          <source>Bit-masks are in &lt;code&gt;numpy.core.multiarray&lt;/code&gt; as the constants &lt;code&gt;ITEM_HASOBJECT&lt;/code&gt;, &lt;code&gt;LIST_PICKLE&lt;/code&gt;, &lt;code&gt;ITEM_IS_POINTER&lt;/code&gt;, &lt;code&gt;NEEDS_INIT&lt;/code&gt;, &lt;code&gt;NEEDS_PYAPI&lt;/code&gt;, &lt;code&gt;USE_GETITEM&lt;/code&gt;, &lt;code&gt;USE_SETITEM&lt;/code&gt;. A full explanation of these flags is in C-API documentation; they are largely useful for user-defined data-types.</source>
          <target state="translated">Битовые маски находятся в &lt;code&gt;numpy.core.multiarray&lt;/code&gt; как константы &lt;code&gt;ITEM_HASOBJECT&lt;/code&gt; , &lt;code&gt;LIST_PICKLE&lt;/code&gt; , &lt;code&gt;ITEM_IS_POINTER&lt;/code&gt; , &lt;code&gt;NEEDS_INIT&lt;/code&gt; , &lt;code&gt;NEEDS_PYAPI&lt;/code&gt; , &lt;code&gt;USE_GETITEM&lt;/code&gt; , &lt;code&gt;USE_SETITEM&lt;/code&gt; . Полное объяснение этих флагов находится в документации C-API; они очень полезны для пользовательских типов данных.</target>
        </trans-unit>
        <trans-unit id="c6c2f273c5d1a8dcbceea602bbb87c029bbc0d32" translate="yes" xml:space="preserve">
          <source>Bit-twiddling functions</source>
          <target state="translated">Широкополосные функции</target>
        </trans-unit>
        <trans-unit id="460d665e77f8686560c843f72478486336f12a1b" translate="yes" xml:space="preserve">
          <source>Bit-width names</source>
          <target state="translated">Широкополосные имена</target>
        </trans-unit>
        <trans-unit id="7176dd338904b0fc1d2cdf1063572e4e5cbd193a" translate="yes" xml:space="preserve">
          <source>Bit-width references to enumerated typenums</source>
          <target state="translated">Широкополосные ссылки на перечисленные типовые обозначения</target>
        </trans-unit>
        <trans-unit id="143911730a6c4fbdf6bd766470cddffa24dd0b5c" translate="yes" xml:space="preserve">
          <source>BitGenerator</source>
          <target state="translated">BitGenerator</target>
        </trans-unit>
        <trans-unit id="e1d49785c1daa86c89ab6e63f74767502d9e2cd5" translate="yes" xml:space="preserve">
          <source>BitGenerator (class in numpy.random)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cc03ca2870189a580c7299116633756162b41a61" translate="yes" xml:space="preserve">
          <source>BitGenerator for Chris Doty-Humphrey&amp;rsquo;s Small Fast Chaotic PRNG.</source>
          <target state="translated">BitGenerator для небольшого быстрого хаотического ГПСЧ Криса Доти-Хамфри.</target>
        </trans-unit>
        <trans-unit id="218df33e7359786597fc4c2a6c1726e5e91ef2e6" translate="yes" xml:space="preserve">
          <source>BitGenerator for the PCG-64 pseudo-random number generator.</source>
          <target state="translated">БитГенератор для генератора псевдослучайных чисел PCG-64.</target>
        </trans-unit>
        <trans-unit id="9b6bde107d0c3c8164f2b3ab1e4164dad1766298" translate="yes" xml:space="preserve">
          <source>BitGenerator to use as the core generator.</source>
          <target state="translated">БитГенератор для использования в качестве основного генератора.</target>
        </trans-unit>
        <trans-unit id="dbbe08f6d74daba648b1cd173a6a41449071b1bf" translate="yes" xml:space="preserve">
          <source>BitGenerator.random_raw()</source>
          <target state="translated">BitGenerator.random_raw()</target>
        </trans-unit>
        <trans-unit id="ade67fe752c31c985cb01482e4ad03f16cfe18bb" translate="yes" xml:space="preserve">
          <source>BitGenerators: Objects that generate random numbers. These are typically unsigned integer words filled with sequences of either 32 or 64 random bits.</source>
          <target state="translated">БитГенераторы:Объекты,генерирующие случайные числа.Как правило,это беззнаковые целые слова,заполненные последовательностями из 32 или 64 случайных бит.</target>
        </trans-unit>
        <trans-unit id="a36a25a1cccb68c7c87fcd879bbb216973e2de75" translate="yes" xml:space="preserve">
          <source>Bits</source>
          <target state="translated">Bits</target>
        </trans-unit>
        <trans-unit id="02f4859e8970806328996752f2ca5818252436db" translate="yes" xml:space="preserve">
          <source>Bits are shifted to the left by appending &lt;code&gt;x2&lt;/code&gt; 0s at the right of &lt;code&gt;x1&lt;/code&gt;. Since the internal representation of numbers is in binary format, this operation is equivalent to multiplying &lt;code&gt;x1&lt;/code&gt; by &lt;code&gt;2**x2&lt;/code&gt;.</source>
          <target state="translated">Биты сдвигаются влево, добавляя &lt;code&gt;x2&lt;/code&gt; 0 справа от &lt;code&gt;x1&lt;/code&gt; . Поскольку внутреннее представление чисел находится в двоичном формате, эта операция эквивалентна умножению &lt;code&gt;x1&lt;/code&gt; на &lt;code&gt;2**x2&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9d9f79b7b35bc256a0d1b6d4ab01f312eace24eb" translate="yes" xml:space="preserve">
          <source>Bits are shifted to the right &lt;code&gt;x2&lt;/code&gt;. Because the internal representation of numbers is in binary format, this operation is equivalent to dividing &lt;code&gt;x1&lt;/code&gt; by &lt;code&gt;2**x2&lt;/code&gt;.</source>
          <target state="translated">Биты сдвинуты вправо &lt;code&gt;x2&lt;/code&gt; . Поскольку внутреннее представление чисел находится в двоичном формате, эта операция эквивалентна делению &lt;code&gt;x1&lt;/code&gt; на &lt;code&gt;2**x2&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="117a063b0a577c59c490f864292bca239247279f" translate="yes" xml:space="preserve">
          <source>Bits set for the object data-type: ( &lt;a href=&quot;#c.NPY_LIST_PICKLE&quot;&gt;&lt;code&gt;NPY_LIST_PICKLE&lt;/code&gt;&lt;/a&gt; | &lt;a href=&quot;#c.NPY_USE_GETITEM&quot;&gt;&lt;code&gt;NPY_USE_GETITEM&lt;/code&gt;&lt;/a&gt; | &lt;a href=&quot;#c.NPY_ITEM_IS_POINTER&quot;&gt;&lt;code&gt;NPY_ITEM_IS_POINTER&lt;/code&gt;&lt;/a&gt; | &lt;code&gt;NPY_REFCOUNT&lt;/code&gt; | &lt;a href=&quot;#c.NPY_NEEDS_INIT&quot;&gt;&lt;code&gt;NPY_NEEDS_INIT&lt;/code&gt;&lt;/a&gt; | &lt;a href=&quot;#c.NPY_NEEDS_PYAPI&quot;&gt;&lt;code&gt;NPY_NEEDS_PYAPI&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">Биты, установленные для типа данных объекта: ( &lt;a href=&quot;#c.NPY_LIST_PICKLE&quot;&gt; &lt;code&gt;NPY_LIST_PICKLE&lt;/code&gt; &lt;/a&gt; | &lt;a href=&quot;#c.NPY_USE_GETITEM&quot;&gt; &lt;code&gt;NPY_USE_GETITEM&lt;/code&gt; &lt;/a&gt; | &lt;a href=&quot;#c.NPY_ITEM_IS_POINTER&quot;&gt; &lt;code&gt;NPY_ITEM_IS_POINTER&lt;/code&gt; &lt;/a&gt; | &lt;code&gt;NPY_REFCOUNT&lt;/code&gt; | &lt;a href=&quot;#c.NPY_NEEDS_INIT&quot;&gt; &lt;code&gt;NPY_NEEDS_INIT&lt;/code&gt; &lt;/a&gt; | &lt;a href=&quot;#c.NPY_NEEDS_PYAPI&quot;&gt; &lt;code&gt;NPY_NEEDS_PYAPI&lt;/code&gt; &lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="13031923c83ade827195c6241750d4615a698b51" translate="yes" xml:space="preserve">
          <source>Blackman, R.B. and Tukey, J.W., (1958) The measurement of power spectra, Dover Publications, New York.</source>
          <target state="translated">Блэкман,Р.Б.и Тьюки,Дж.У.,(1958 г.)Измерение энергетических спектров,Довер Пабликейшнз,Нью-Йорк.</target>
        </trans-unit>
        <trans-unit id="348cdf7ff3c8eec7d1cd1aa8880558948fba2435" translate="yes" xml:space="preserve">
          <source>Blocks can be of any dimension, but will not be broadcasted using the normal rules. Instead, leading axes of size 1 are inserted, to make &lt;code&gt;block.ndim&lt;/code&gt; the same for all blocks. This is primarily useful for working with scalars, and means that code like &lt;code&gt;np.block([v, 1])&lt;/code&gt; is valid, where &lt;code&gt;v.ndim == 1&lt;/code&gt;.</source>
          <target state="translated">Блоки могут быть любого размера, но не будут транслироваться по обычным правилам. Вместо этого вставляются ведущие оси размера 1, чтобы сделать &lt;code&gt;block.ndim&lt;/code&gt; одинаковым для всех блоков. Это в первую очередь полезно для работы со скалярами и означает, что &lt;code&gt;np.block([v, 1])&lt;/code&gt; код вроде np.block ([v, 1]) , где &lt;code&gt;v.ndim == 1&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8994034796d9ec39a7933eb34371fad5f6ce9920" translate="yes" xml:space="preserve">
          <source>Blocks in the innermost lists are concatenated (see &lt;a href=&quot;numpy.concatenate#numpy.concatenate&quot;&gt;&lt;code&gt;concatenate&lt;/code&gt;&lt;/a&gt;) along the last dimension (-1), then these are concatenated along the second-last dimension (-2), and so on until the outermost list is reached.</source>
          <target state="translated">Блоки в самых внутренних списках объединяются (см. &lt;a href=&quot;numpy.concatenate#numpy.concatenate&quot;&gt; &lt;code&gt;concatenate&lt;/code&gt; &lt;/a&gt; ) по последнему измерению (-1), затем они объединяются по второму последнему измерению (-2), и так далее, пока не будет достигнут самый внешний список.</target>
        </trans-unit>
        <trans-unit id="b76ff4906f33c2dd97ddd929b9662ba8cac6174c" translate="yes" xml:space="preserve">
          <source>Boolean</source>
          <target state="translated">Boolean</target>
        </trans-unit>
        <trans-unit id="317be1616a174c84304de299b4ead5ef76ce4a76" translate="yes" xml:space="preserve">
          <source>Boolean (True or False) stored as a byte</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="71383121b53c1c9facdaaabc47b0de18549c5c80" translate="yes" xml:space="preserve">
          <source>Boolean (integer type where all values are only True or False)</source>
          <target state="translated">Булевы (целочисленный тип,где все значения только True или False)</target>
        </trans-unit>
        <trans-unit id="c7a0fd639a6581c56ba10f492adee6f212cd45b8" translate="yes" xml:space="preserve">
          <source>Boolean 1-d array selecting which entries to return. If len(condition) is less than the size of a along the axis, then output is truncated to length of condition array.</source>
          <target state="translated">Булевый 1-d массив,выбирающий,какие записи возвращать.Если len(condition)меньше,чем размер a вдоль оси,то вывод усекается до длины массива условий.</target>
        </trans-unit>
        <trans-unit id="87962449a461c8ec49f5151d2bbb30e7a462a28e" translate="yes" xml:space="preserve">
          <source>Boolean array indexing</source>
          <target state="translated">индексирование булевых массивов</target>
        </trans-unit>
        <trans-unit id="c1aefe73a2b6727a0e572007771ddec686a6bb1f" translate="yes" xml:space="preserve">
          <source>Boolean array of same shape as &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="translated">Логический массив той же формы, что и &lt;code&gt;x&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="233d1fbe1852dc657d35dfe3cd279e3947a9a911" translate="yes" xml:space="preserve">
          <source>Boolean arrays used as indices are treated in a different manner entirely than index arrays. Boolean arrays must be of the same shape as the initial dimensions of the array being indexed. In the most straightforward case, the boolean array has the same shape:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="98073379b648edd4cbe725ce47f959a6d23058d4" translate="yes" xml:space="preserve">
          <source>Boolean indexing changes</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="639386fbce5315b91a1c655018a3b9643e9bcfef" translate="yes" xml:space="preserve">
          <source>Boolean indicating whether the byte order of this dtype is native to the platform.</source>
          <target state="translated">Булевы указания,является ли порядок байт этого dtype родным для платформы.</target>
        </trans-unit>
        <trans-unit id="0c76417c3c3c65ffeed61396388e3db4b8c19de6" translate="yes" xml:space="preserve">
          <source>Boolean indicating whether the dtype is a struct which maintains field alignment.</source>
          <target state="translated">Булевое указание на то,является ли d-тип структурой,поддерживающей выравнивание полей.</target>
        </trans-unit>
        <trans-unit id="dad1680b2705f6d7f6eeec97cbb513a4e1699f09" translate="yes" xml:space="preserve">
          <source>Boolean indicating whether the dtype is a struct which maintains field alignment. This flag is sticky, so when combining multiple structs together, it is preserved and produces new dtypes which are also aligned.</source>
          <target state="translated">Булевое указание на то,является ли d-тип структурой,поддерживающей выравнивание полей.Этот флаг липкий,поэтому при объединении нескольких структур он сохраняется и создает новые стипы,которые также выравниваются.</target>
        </trans-unit>
        <trans-unit id="36f2224ace3c78a988e50bdc966ac649a4d3fc0b" translate="yes" xml:space="preserve">
          <source>Boolean indicating whether this dtype contains any reference-counted objects in any fields or sub-dtypes.</source>
          <target state="translated">Булевое указание на то,содержит ли данный d-тип какие-нибудь ссылочные объекты в каких-либо полях или подтипах.</target>
        </trans-unit>
        <trans-unit id="398d7e2271209225ea68a985a7b2fa72caeee3a6" translate="yes" xml:space="preserve">
          <source>Boolean mask array. It has to be the same shape as &lt;code&gt;a&lt;/code&gt;.</source>
          <target state="translated">Массив булевых масок. Она должна быть такой же формы , как . &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="59815579c0e1a982c330b63fe4d4075e4fd81815" translate="yes" xml:space="preserve">
          <source>Boolean mask array. Must have the same size as &lt;code&gt;a&lt;/code&gt;.</source>
          <target state="translated">Массив булевых масок. Должен быть такого же размера, как &lt;code&gt;a&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="30d9ef559552bdd87313d89c8796d8136275e739" translate="yes" xml:space="preserve">
          <source>Boolean operations</source>
          <target state="translated">логические операции</target>
        </trans-unit>
        <trans-unit id="0d747f327c87280779ba3eb08a42ad6dc25e090e" translate="yes" xml:space="preserve">
          <source>Boolean or &amp;ldquo;mask&amp;rdquo; index arrays</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dd5ec2e25bdf5818c59dcd317ab96e5a1ea9111e" translate="yes" xml:space="preserve">
          <source>Boolean result of check whether &lt;code&gt;rep&lt;/code&gt; is a scalar dtype.</source>
          <target state="translated">Логический результат проверки, является ли &lt;code&gt;rep&lt;/code&gt; скалярным dtype.</target>
        </trans-unit>
        <trans-unit id="e4ae3e1eb416ce7ddaa17364adbe02e871496027" translate="yes" xml:space="preserve">
          <source>Boolean result of the logical AND operation applied to the elements of &lt;code&gt;x1&lt;/code&gt; and &lt;code&gt;x2&lt;/code&gt;; the shape is determined by broadcasting. This is a scalar if both &lt;code&gt;x1&lt;/code&gt; and &lt;code&gt;x2&lt;/code&gt; are scalars.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="80129c87ec19d7266b12fa62c898f1de8e697318" translate="yes" xml:space="preserve">
          <source>Boolean result of the logical OR operation applied to the elements of &lt;code&gt;x1&lt;/code&gt; and &lt;code&gt;x2&lt;/code&gt;; the shape is determined by broadcasting. This is a scalar if both &lt;code&gt;x1&lt;/code&gt; and &lt;code&gt;x2&lt;/code&gt; are scalars.</source>
          <target state="translated">Логический результат операции логического ИЛИ, примененной к элементам &lt;code&gt;x1&lt;/code&gt; и &lt;code&gt;x2&lt;/code&gt; ; форма определяется трансляцией. Это скаляр, если и &lt;code&gt;x1&lt;/code&gt; , и &lt;code&gt;x2&lt;/code&gt; являются скалярами.</target>
        </trans-unit>
        <trans-unit id="efce76e1529f243bc75f6c85e1cb168b94a21ce6" translate="yes" xml:space="preserve">
          <source>Boolean result of the logical XOR operation applied to the elements of &lt;code&gt;x1&lt;/code&gt; and &lt;code&gt;x2&lt;/code&gt;; the shape is determined by broadcasting. This is a scalar if both &lt;code&gt;x1&lt;/code&gt; and &lt;code&gt;x2&lt;/code&gt; are scalars.</source>
          <target state="translated">Логический результат логической операции XOR, примененной к элементам &lt;code&gt;x1&lt;/code&gt; и &lt;code&gt;x2&lt;/code&gt; ; форма определяется трансляцией. Это скаляр, если и &lt;code&gt;x1&lt;/code&gt; , и &lt;code&gt;x2&lt;/code&gt; являются скалярами.</target>
        </trans-unit>
        <trans-unit id="e598e8b30eff8ac988c047694ee54841654f4531" translate="yes" xml:space="preserve">
          <source>Boolean result with the same shape as &lt;code&gt;x&lt;/code&gt; of the NOT operation on elements of &lt;code&gt;x&lt;/code&gt;. This is a scalar if &lt;code&gt;x&lt;/code&gt; is a scalar.</source>
          <target state="translated">Логический результат той же формы, что и &lt;code&gt;x&lt;/code&gt; операции НЕ над элементами &lt;code&gt;x&lt;/code&gt; . Это скаляр, если &lt;code&gt;x&lt;/code&gt; - скаляр.</target>
        </trans-unit>
        <trans-unit id="4cfb7a503c91815ccbf2f35210fcd3eadc71e7eb" translate="yes" xml:space="preserve">
          <source>Booleans are accepted as well:</source>
          <target state="translated">Булеан тоже принимается:</target>
        </trans-unit>
        <trans-unit id="fff8683eb97daf0f7f34cfbaabaadf811d8b8133" translate="yes" xml:space="preserve">
          <source>Booleans:</source>
          <target state="translated">Booleans:</target>
        </trans-unit>
        <trans-unit id="37cb1b945ecb9b619ea4147615565076f43e7b81" translate="yes" xml:space="preserve">
          <source>Boost Python</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="80eb86696c9c70e3e908a024dfe4075dae3951c7" translate="yes" xml:space="preserve">
          <source>Boost is a repository of C++ libraries and Boost.Python is one of those libraries which provides a concise interface for binding C++ classes and functions to Python. The amazing part of the Boost.Python approach is that it works entirely in pure C++ without introducing a new syntax. Many users of C++ report that Boost.Python makes it possible to combine the best of both worlds in a seamless fashion. I have not used Boost.Python because I am not a big user of C++ and using Boost to wrap simple C-subroutines is usually over-kill. It&amp;rsquo;s primary purpose is to make C++ classes available in Python. So, if you have a set of C++ classes that need to be integrated cleanly into Python, consider learning about and using Boost.Python.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3d9f5c6c1605197a54538b1a42018d968a659108" translate="yes" xml:space="preserve">
          <source>Boost.Python</source>
          <target state="translated">Boost.Python</target>
        </trans-unit>
        <trans-unit id="35f319efb34e1e345510a06307dd059dbed15ac2" translate="yes" xml:space="preserve">
          <source>Boost.python</source>
          <target state="translated">Boost.python</target>
        </trans-unit>
        <trans-unit id="6a6c7de0b010d58cd0f9cb5716158db428b24bc0" translate="yes" xml:space="preserve">
          <source>Both &lt;code&gt;u&lt;/code&gt; and &lt;code&gt;v&lt;/code&gt; must be 0-d or 1-d (ndim = 0 or 1), but &lt;code&gt;u.ndim&lt;/code&gt; need not equal &lt;code&gt;v.ndim&lt;/code&gt;. In other words, all four possible combinations - &lt;code&gt;u.ndim = v.ndim = 0&lt;/code&gt;, &lt;code&gt;u.ndim = v.ndim = 1&lt;/code&gt;, &lt;code&gt;u.ndim = 1, v.ndim = 0&lt;/code&gt;, and &lt;code&gt;u.ndim = 0, v.ndim = 1&lt;/code&gt; - work.</source>
          <target state="translated">И &lt;code&gt;u&lt;/code&gt; , и &lt;code&gt;v&lt;/code&gt; должны быть 0-d или 1-d (ndim = 0 или 1), но &lt;code&gt;u.ndim&lt;/code&gt; не обязательно равно &lt;code&gt;v.ndim&lt;/code&gt; . Другими словами, все четыре возможных комбинации - &lt;code&gt;u.ndim = v.ndim = 0&lt;/code&gt; , &lt;code&gt;u.ndim = v.ndim = 1&lt;/code&gt; , &lt;code&gt;u.ndim = 1, v.ndim = 0&lt;/code&gt; и &lt;code&gt;u.ndim = 0, v.ndim = 1&lt;/code&gt; - работать.</target>
        </trans-unit>
        <trans-unit id="88f65d9e2d112f1a7a284a45eccfdccc621dc60d" translate="yes" xml:space="preserve">
          <source>Both C-ordering (&amp;ldquo;last dimension fastest&amp;rdquo;) or Fortran-ordering (&amp;ldquo;first dimension fastest&amp;rdquo;) support for 2D, 3D and 4D arrays.</source>
          <target state="translated">Поддержка как C-упорядочения (&amp;laquo;самое быстрое измерение&amp;raquo;), так и упорядочения Fortran (&amp;laquo;самое быстрое первое измерение&amp;raquo;) для массивов 2D, 3D и 4D.</target>
        </trans-unit>
        <trans-unit id="3720a76c9cc3b6258ee484172d090cd5b19b7e16" translate="yes" xml:space="preserve">
          <source>Both CTypes and CFFI allow the more complicated distributions to be used directly in Numba after compiling the file distributions.c into a &lt;code&gt;DLL&lt;/code&gt; or &lt;code&gt;so&lt;/code&gt;. An example showing the use of a more complicated distribution is in the &lt;code&gt;examples&lt;/code&gt; section below.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6876b038e6598420047feff6385d214f7a9456e4" translate="yes" xml:space="preserve">
          <source>Both CTypes and CFFI allow the more complicated distributions to be used directly in Numba after compiling the file distributions.c into a DLL or so. An example showing the use of a more complicated distribution is in the examples folder.</source>
          <target state="translated">Как CTypes,так и CFFI позволяют использовать более сложные дистрибутивы непосредственно в Numba после компиляции файлового дистрибутива distributions.c в DLL или около того.Пример использования более сложного дистрибутива приведен в папке Примеры.</target>
        </trans-unit>
        <trans-unit id="9b2e6b498660f219d33da75fb672071ec22d0de1" translate="yes" xml:space="preserve">
          <source>Both arguments must be convertible to data-type objects with the same total size.</source>
          <target state="translated">Оба аргумента должны быть конвертированы в объекты типа данных с одинаковым общим размером.</target>
        </trans-unit>
        <trans-unit id="25024cfe43b48611add0d26f273e9fb8f30c82d0" translate="yes" xml:space="preserve">
          <source>Both for indexing:</source>
          <target state="translated">Оба для индексирования:</target>
        </trans-unit>
        <trans-unit id="9c58adbe49cf294225a6b4d010fdfff04815b05a" translate="yes" xml:space="preserve">
          <source>Both of these routines multiply an &lt;em&gt;n&lt;/em&gt; -length array, &lt;em&gt;seq&lt;/em&gt;, of integers and return the result. No overflow checking is performed.</source>
          <target state="translated">Обе эти подпрограммы умножают массив целых чисел длиной &lt;em&gt;n&lt;/em&gt; , &lt;em&gt;seq&lt;/em&gt; , и возвращают результат. Проверка переполнения не выполняется.</target>
        </trans-unit>
        <trans-unit id="e7d4dd33376799dad2f66b13833f7382c04f91d5" translate="yes" xml:space="preserve">
          <source>Both the &lt;code&gt;names&lt;/code&gt; and &lt;code&gt;fields&lt;/code&gt; attributes will equal &lt;code&gt;None&lt;/code&gt; for unstructured arrays. The recommended way to test if a dtype is structured is with &lt;code&gt;if dt.names is not None&lt;/code&gt; rather than &lt;code&gt;if dt.names&lt;/code&gt;, to account for dtypes with 0 fields.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6a9d7b7663daf24925c25758270cb4610491dfdf" translate="yes" xml:space="preserve">
          <source>Both the C and Fortran orders are &lt;a href=&quot;https://docs.python.org/dev/glossary.html#term-contiguous&quot;&gt;contiguous&lt;/a&gt;, &lt;em&gt;i.e.,&lt;/em&gt; single-segment, memory layouts, in which every part of the memory block can be accessed by some combination of the indices.</source>
          <target state="translated">И C, и Fortran порядки являются &lt;a href=&quot;https://docs.python.org/dev/glossary.html#term-contiguous&quot;&gt;смежными&lt;/a&gt; , &lt;em&gt;т.&lt;/em&gt; Е. Односегментными схемами памяти, в которых к каждой части блока памяти можно получить доступ с помощью некоторой комбинации индексов.</target>
        </trans-unit>
        <trans-unit id="d093ba37f9ce9c9f30f8fca73c109507dfcb0225" translate="yes" xml:space="preserve">
          <source>Both the Frobenius and nuclear norm orders are only defined for matrices and raise a ValueError when &lt;code&gt;x.ndim != 2&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ffea5bc12b4c544392f03bcbcae76a932ec7e9d3" translate="yes" xml:space="preserve">
          <source>Both vectors with dimension 2.</source>
          <target state="translated">Оба вектора с размером 2.</target>
        </trans-unit>
        <trans-unit id="ee63b82109d9ff030ecbe37ab04ceac7db2412e8" translate="yes" xml:space="preserve">
          <source>Breaking long lines: if you can, break after commas in the outermost argument list. Always indent continuation lines appropriately, e.g.,</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bd6b304289af9581af2ffeee2445279337f31f30" translate="yes" xml:space="preserve">
          <source>Brighton Webs Ltd., &amp;ldquo;Rayleigh Distribution,&amp;rdquo; &lt;a href=&quot;https://web.archive.org/web/20090514091424/http://brighton-webs.co.uk:80/distributions/rayleigh.asp&quot;&gt;https://web.archive.org/web/20090514091424/http://brighton-webs.co.uk:80/distributions/rayleigh.asp&lt;/a&gt;</source>
          <target state="translated">Brighton Webs Ltd., &amp;laquo;Rayleigh Distribution&amp;raquo;, &lt;a href=&quot;https://web.archive.org/web/20090514091424/http://brighton-webs.co.uk:80/distributions/rayleigh.asp&quot;&gt;https://web.archive.org/web/20090514091424/http://brighton-webs.co.uk:80/distributions/rayleigh.asp&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="f95280aadb50a5d76ebefb36fbe813c4a9ec99eb" translate="yes" xml:space="preserve">
          <source>Brighton Webs Ltd., Wald Distribution, &lt;a href=&quot;https://web.archive.org/web/20090423014010/http://www.brighton-webs.co.uk:80/distributions/wald.asp&quot;&gt;https://web.archive.org/web/20090423014010/http://www.brighton-webs.co.uk:80/distributions/wald.asp&lt;/a&gt;</source>
          <target state="translated">Brighton Webs Ltd., Wald Distribution, &lt;a href=&quot;https://web.archive.org/web/20090423014010/http://www.brighton-webs.co.uk:80/distributions/wald.asp&quot;&gt;https://web.archive.org/web/20090423014010/http://www.brighton-webs.co.uk:80/distributions/wald.asp&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="8d469ff5df319fd73b1f4431adc89a3cb7f9bc26" translate="yes" xml:space="preserve">
          <source>Broadcast an array to a new shape</source>
          <target state="translated">Транслировать массив в новую форму</target>
        </trans-unit>
        <trans-unit id="73facd5bb35116bed91fa4d11828ee34122a7818" translate="yes" xml:space="preserve">
          <source>Broadcast an array to a new shape.</source>
          <target state="translated">Транслировать массив в новую форму.</target>
        </trans-unit>
        <trans-unit id="335cb5d296e07dc61fd4677d50111abd1712ceae" translate="yes" xml:space="preserve">
          <source>Broadcast any number of arrays against each other.</source>
          <target state="translated">Транслировать любое количество массивов друг против друга.</target>
        </trans-unit>
        <trans-unit id="98d4c99349e07c3606d8247f67b6a69bf991b037" translate="yes" xml:space="preserve">
          <source>Broadcast the input parameters against one another, and return an object that encapsulates the result. Amongst others, it has &lt;code&gt;shape&lt;/code&gt; and &lt;code&gt;nd&lt;/code&gt; properties, and may be used as an iterator.</source>
          <target state="translated">Передайте входные параметры друг другу и верните объект, который инкапсулирует результат. Среди прочего, он имеет свойства &lt;code&gt;shape&lt;/code&gt; и &lt;code&gt;nd&lt;/code&gt; и может использоваться как итератор.</target>
        </trans-unit>
        <trans-unit id="ba459229366746c447e3cdf752eb917433152cfe" translate="yes" xml:space="preserve">
          <source>Broadcasting</source>
          <target state="translated">Broadcasting</target>
        </trans-unit>
        <trans-unit id="2d4bd5e0675f1aedc285134fe7e6bea24d68a36e" translate="yes" xml:space="preserve">
          <source>Broadcasting (multi-iterators)</source>
          <target state="translated">Трансляция (мультилитераторы)</target>
        </trans-unit>
        <trans-unit id="5e308728b0383411510cb3c77af8cc43a178e5fc" translate="yes" xml:space="preserve">
          <source>Broadcasting Array Iteration</source>
          <target state="translated">Итерация вещательного массива</target>
        </trans-unit>
        <trans-unit id="ffca602e6975476928a035e0bd899a364b765bab" translate="yes" xml:space="preserve">
          <source>Broadcasting allows universal functions to deal in a meaningful way with inputs that do not have exactly the same shape.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3f1a8f806c9ec4c20408d10522361491e36b1938" translate="yes" xml:space="preserve">
          <source>Broadcasting and scalar multiplication:</source>
          <target state="translated">Трансляция и скалярное умножение:</target>
        </trans-unit>
        <trans-unit id="9c4c6b372f00f9bbc9735f2491e20986adab213c" translate="yes" xml:space="preserve">
          <source>Broadcasting comes up quite often in real world problems. A typical example occurs in the vector quantization (VQ) algorithm used in information theory, classification, and other related areas. The basic operation in VQ [#f0] finds the closest point in a set of points, called codes in VQ jargon, to a given point, called the observation. In the very simple, two-dimensional case shown in &lt;a href=&quot;#figure-5&quot;&gt;Figure 5&lt;/a&gt;, the values in observation describe the weight and height of an athlete to be classified. The codes represent different classes of athletes. &lt;a href=&quot;#f1&quot; id=&quot;id2&quot;&gt;2&lt;/a&gt; Finding the closest point requires calculating the distance between observation and each of the codes. The shortest distance provides the best match. In this example, &lt;code&gt;codes[0]&lt;/code&gt; is the closest class indicating that the athlete is likely a basketball player.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3086582d38372be76fcd6867986780678b3bdbd6" translate="yes" xml:space="preserve">
          <source>Broadcasting is conventional for stacks of arrays</source>
          <target state="translated">Трансляция традиционна для штабелей массивов.</target>
        </trans-unit>
        <trans-unit id="60a524b775e11155b5c4df4747f272a28d6e6176" translate="yes" xml:space="preserve">
          <source>Broadcasting is the term used to describe the implicit element-by-element behavior of operations; generally speaking, in NumPy all operations, not just arithmetic operations, but logical, bit-wise, functional, etc., behave in this implicit element-by-element fashion, i.e., they broadcast. Moreover, in the example above, &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; could be multidimensional arrays of the same shape, or a scalar and an array, or even two arrays of with different shapes, provided that the smaller array is &amp;ldquo;expandable&amp;rdquo; to the shape of the larger in such a way that the resulting broadcast is unambiguous. For detailed &amp;ldquo;rules&amp;rdquo; of broadcasting see &lt;a href=&quot;basics.broadcasting#module-numpy.doc.broadcasting&quot;&gt;&lt;code&gt;numpy.doc.broadcasting&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c8a22fa6f76158c02a615ce1e41377e5e327d96b" translate="yes" xml:space="preserve">
          <source>Broadcasting is used throughout NumPy to decide how to handle disparately shaped arrays; for example, all arithmetic operations (&lt;code&gt;+&lt;/code&gt;, &lt;code&gt;-&lt;/code&gt;, &lt;code&gt;*&lt;/code&gt;, &amp;hellip;) between &lt;a href=&quot;generated/numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;ndarrays&lt;/code&gt;&lt;/a&gt; broadcast the arrays before operation.</source>
          <target state="translated">Широковещательная передача используется во всем NumPy, чтобы решить, как обрабатывать массивы разной формы; например, все арифметические операции ( &lt;code&gt;+&lt;/code&gt; , &lt;code&gt;-&lt;/code&gt; , &lt;code&gt;*&lt;/code&gt; ,&amp;hellip;) между &lt;a href=&quot;generated/numpy.ndarray#numpy.ndarray&quot;&gt; &lt;code&gt;ndarrays&lt;/code&gt; &lt;/a&gt; передают массивы перед операцией.</target>
        </trans-unit>
        <trans-unit id="c2ccb1ef65055f853bfad815cb4304fa00148706" translate="yes" xml:space="preserve">
          <source>Broadcasting over multiple arrays</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8643e22fd07e0fa1b2c6f3538e1689c01bced1a3" translate="yes" xml:space="preserve">
          <source>Broadcasting provides a convenient way of taking the outer product (or any other outer operation) of two arrays. The following example shows an outer addition operation of two 1-d arrays that produces the same result as &lt;a href=&quot;#example-3&quot;&gt;Example 3&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f086db6f9cde283cd15667e2a34db081fa8323d1" translate="yes" xml:space="preserve">
          <source>Broadcasting provides a convenient way of taking the outer product (or any other outer operation) of two arrays. The following example shows an outer addition operation of two 1-d arrays:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="916a860416eab96b40dda7fe2424a559b1d3ae5f" translate="yes" xml:space="preserve">
          <source>Broadcasting rules</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d8a2b5b45365993f46ca0dedffba4cb7be1f878c" translate="yes" xml:space="preserve">
          <source>Broadcasting rules apply, see the &lt;a href=&quot;../routines.linalg#module-numpy.linalg&quot;&gt;&lt;code&gt;numpy.linalg&lt;/code&gt;&lt;/a&gt; documentation for details.</source>
          <target state="translated">Применяются правила трансляции, подробности см. &lt;a href=&quot;../routines.linalg#module-numpy.linalg&quot;&gt; &lt;code&gt;numpy.linalg&lt;/code&gt; &lt;/a&gt; документации numpy.linalg .</target>
        </trans-unit>
        <trans-unit id="d885a1b2d5577844b42f9c37b9817de5d134c079" translate="yes" xml:space="preserve">
          <source>Broadcasting was always implemented in Numeric using 0-valued strides for the extended dimensions. It is done in exactly the same way in NumPy. The big difference is that now the array of strides is kept track of in a &lt;a href=&quot;c-api.types-and-structures#c.PyArrayIterObject&quot;&gt;&lt;code&gt;PyArrayIterObject&lt;/code&gt;&lt;/a&gt;, the iterators involved in a broadcast result are kept track of in a &lt;a href=&quot;c-api.types-and-structures#c.PyArrayMultiIterObject&quot;&gt;&lt;code&gt;PyArrayMultiIterObject&lt;/code&gt;&lt;/a&gt;, and the &lt;code&gt;PyArray_BroadCast&lt;/code&gt; call implements the broad-casting rules.</source>
          <target state="translated">Широковещание всегда реализовывалось в Numeric с использованием нулевых шагов для расширенных измерений. Точно так же это делается в NumPy. Большая разница в том, что теперь массив шагов отслеживается в &lt;a href=&quot;c-api.types-and-structures#c.PyArrayIterObject&quot;&gt; &lt;code&gt;PyArrayIterObject&lt;/code&gt; &lt;/a&gt; , итераторы, участвующие в результате широковещательной передачи, отслеживаются в &lt;a href=&quot;c-api.types-and-structures#c.PyArrayMultiIterObject&quot;&gt; &lt;code&gt;PyArrayMultiIterObject&lt;/code&gt; &lt;/a&gt; , а вызов &lt;code&gt;PyArray_BroadCast&lt;/code&gt; реализует правила широковещательной рассылки .</target>
        </trans-unit>
        <trans-unit id="2a0a6879b6872d1f7b106e1d3c8e15aa2bd9c9f9" translate="yes" xml:space="preserve">
          <source>Broadcasting was always implemented in Numeric using 0-valued strides for the extended dimensions. It is done in exactly the same way in NumPy. The big difference is that now the array of strides is kept track of in a &lt;a href=&quot;c-api/types-and-structures#c.PyArrayIterObject&quot;&gt;&lt;code&gt;PyArrayIterObject&lt;/code&gt;&lt;/a&gt;, the iterators involved in a broadcast result are kept track of in a &lt;a href=&quot;c-api/types-and-structures#c.PyArrayMultiIterObject&quot;&gt;&lt;code&gt;PyArrayMultiIterObject&lt;/code&gt;&lt;/a&gt;, and the &lt;code&gt;PyArray_BroadCast&lt;/code&gt; call implements the broad-casting rules.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6cc8d02b192349a4f1b4b7f860e5e3a1c421ecb8" translate="yes" xml:space="preserve">
          <source>Broadcasting, element-wise and scalar multiplication, &lt;a href=&quot;numpy.multiply#numpy.multiply&quot;&gt;&lt;code&gt;numpy.multiply&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Широковещательное, поэлементное и скалярное умножение, &lt;a href=&quot;numpy.multiply#numpy.multiply&quot;&gt; &lt;code&gt;numpy.multiply&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="90812c9e094ac5522eea3d57aa754d6964a1cdf2" translate="yes" xml:space="preserve">
          <source>Buffer (&lt;code&gt;buf&lt;/code&gt;) is interpreted according to these strides (strides define how many bytes each array element, row, column, etc. occupy in memory).</source>
          <target state="translated">Буфер ( &lt;code&gt;buf&lt;/code&gt; ) интерпретируется в соответствии с этими шагами (шаги определяют, сколько байтов каждый элемент массива, строка, столбец и т. Д. Занимает в памяти).</target>
        </trans-unit>
        <trans-unit id="3a3c6f456f2df72c3dcf8bdef2f2f225bc537cc1" translate="yes" xml:space="preserve">
          <source>Buffer of binary data</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="27cb2ff0185bcfdbaec6ac70d0f611c9c03b02a8" translate="yes" xml:space="preserve">
          <source>Buffered Loop</source>
          <target state="translated">Буферная петля</target>
        </trans-unit>
        <trans-unit id="3aa9875f6199e297bab60e3e7102191f0ce73af1" translate="yes" xml:space="preserve">
          <source>Buffered iterator for big arrays.</source>
          <target state="translated">Буферный итератор для больших массивов.</target>
        </trans-unit>
        <trans-unit id="6d37057306b02ade5a2d41571a0c0e632337fc5c" translate="yes" xml:space="preserve">
          <source>Buffering mode mitigates the memory usage issue and is more cache-friendly than making temporary copies. Except for special cases, where the whole array is needed at once outside the iterator, buffering is recommended over temporary copying. Within NumPy, buffering is used by the ufuncs and other functions to support flexible inputs with minimal memory overhead.</source>
          <target state="translated">Режим буферизации смягчает проблему использования памяти и является более дружественным к кэш-памяти,чем создание временных копий.За исключением особых случаев,когда за пределами итератора требуется сразу весь массив,рекомендуется буферизация по сравнению с временным копированием.В NumPy буферизация используется ufuncs и другими функциями для поддержки гибких входов с минимальными затратами памяти.</target>
        </trans-unit>
        <trans-unit id="aff21481cc1c0abc2cbd1fe3d4ce255d0403752e" translate="yes" xml:space="preserve">
          <source>Buffering the Array Elements</source>
          <target state="translated">Буферизация элементов массива</target>
        </trans-unit>
        <trans-unit id="e0ea19fac7306381f9369bebfc56bf181ad2f644" translate="yes" xml:space="preserve">
          <source>Bugs Fixed</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ac95995878b77d2a8ce4a1c4b232969f85fc5862" translate="yes" xml:space="preserve">
          <source>Build System Changes</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="041e1aac6c7d1e7294bc5d8fa3967aabcde7a325" translate="yes" xml:space="preserve">
          <source>Build a matrix object from a string, nested sequence, or array.</source>
          <target state="translated">Постройте объект матрицы из строки,вложенной последовательности или массива.</target>
        </trans-unit>
        <trans-unit id="62d0591005ae8571425b97ff29068016515cd29b" translate="yes" xml:space="preserve">
          <source>Build and archive documentation</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7fcd3a3a0bc7c1a4ce328d262f632a0650b70528" translate="yes" xml:space="preserve">
          <source>Build extension module from a Fortran 77 source string with f2py.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1d349060ba731253879161224c46e4521b75c084" translate="yes" xml:space="preserve">
          <source>Build options can be discovered by running any of:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7b1b626e82829b0dfeb4bfac3a16b7d5bcd6a8fc" translate="yes" xml:space="preserve">
          <source>Build source releases</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6e79e48e57f84dbe7fa157bde2a3fead704bb75d" translate="yes" xml:space="preserve">
          <source>Build system</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ea4c8827fa3eb397f1363449f23094e9e120bb77" translate="yes" xml:space="preserve">
          <source>Build the changelog and notes for upload with:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="133bc31192cbeea22da4122bb90ba0a93a894d67" translate="yes" xml:space="preserve">
          <source>Build wheels</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d0fa723cff6db05fe0f943d3ba65530fea4a58d8" translate="yes" xml:space="preserve">
          <source>Building Installable C libraries</source>
          <target state="translated">Строительные устанавливаемые библиотеки C</target>
        </trans-unit>
        <trans-unit id="fc68ddc861d1de39d367519f523580fe22e0de8b" translate="yes" xml:space="preserve">
          <source>Building NumPy requires the following software installed:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f7247d0ef96399c8a6f6f94bdfcbbd262feaf108" translate="yes" xml:space="preserve">
          <source>Building NumPy with a Python built with debug support (on Linux distributions typically packaged as &lt;code&gt;python-dbg&lt;/code&gt;) is highly recommended.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e3ab4efd8b4a10d38ed8959a1cb29fc9881db378" translate="yes" xml:space="preserve">
          <source>Building against OpenBLAS</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f1cd4f14fd9faeca78fccf35fd005e67e4d55852" translate="yes" xml:space="preserve">
          <source>Building and Extending the Documentation</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ea6e2e9b251f8b11fe3d952437e66c0d7503db76" translate="yes" xml:space="preserve">
          <source>Building docs</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8cd56ee99256f6026c82a35e18d75551094d8936" translate="yes" xml:space="preserve">
          <source>Building from source</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="797c000e127fd646fe95625f81ea1c57543896ff" translate="yes" xml:space="preserve">
          <source>Building in-place</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e1f8c7d7fa78c6eb31ad5ca785a393676894e731" translate="yes" xml:space="preserve">
          <source>Building matrices</source>
          <target state="translated">Строительные матрицы</target>
        </trans-unit>
        <trans-unit id="d1d8b51984115777766e2f069b697c4bb754479c" translate="yes" xml:space="preserve">
          <source>Building source archives and wheels</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1cc054390cfe90161261914ab7d65d3cfee4150a" translate="yes" xml:space="preserve">
          <source>Building the NumPy API and reference docs</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2b0584a2ddbe43766e4479e6f854126bbc0cb8a1" translate="yes" xml:space="preserve">
          <source>Building the documents requires a number of latex &lt;code&gt;.sty&lt;/code&gt; files. Install them all to avoid aggravation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2afe730004d87377bea3908e9c6c7255bf4ce79e" translate="yes" xml:space="preserve">
          <source>Building the extension module can be now carried out in one command:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fe2db8e7c7c6c32ba1fc4b4a6634f60ac081da44" translate="yes" xml:space="preserve">
          <source>Builds a set of strides which are the same as the strides of an output array created using the &lt;a href=&quot;#c.NPY_ITER_ALLOCATE&quot;&gt;&lt;code&gt;NPY_ITER_ALLOCATE&lt;/code&gt;&lt;/a&gt; flag, where NULL was passed for op_axes. This is for data packed contiguously, but not necessarily in C or Fortran order. This should be used together with &lt;a href=&quot;#c.NpyIter_GetShape&quot;&gt;&lt;code&gt;NpyIter_GetShape&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#c.NpyIter_GetNDim&quot;&gt;&lt;code&gt;NpyIter_GetNDim&lt;/code&gt;&lt;/a&gt; with the flag &lt;a href=&quot;#c.NPY_ITER_MULTI_INDEX&quot;&gt;&lt;code&gt;NPY_ITER_MULTI_INDEX&lt;/code&gt;&lt;/a&gt; passed into the constructor.</source>
          <target state="translated">Создает набор шагов, которые совпадают с шагами выходного массива, созданного с использованием флага &lt;a href=&quot;#c.NPY_ITER_ALLOCATE&quot;&gt; &lt;code&gt;NPY_ITER_ALLOCATE&lt;/code&gt; &lt;/a&gt; , где для op_axes был передан NULL. Это для данных, упакованных непрерывно, но не обязательно в порядке C или Fortran. Это следует использовать вместе с &lt;a href=&quot;#c.NpyIter_GetShape&quot;&gt; &lt;code&gt;NpyIter_GetShape&lt;/code&gt; &lt;/a&gt; и &lt;a href=&quot;#c.NpyIter_GetNDim&quot;&gt; &lt;code&gt;NpyIter_GetNDim&lt;/code&gt; &lt;/a&gt; с флагом &lt;a href=&quot;#c.NPY_ITER_MULTI_INDEX&quot;&gt; &lt;code&gt;NPY_ITER_MULTI_INDEX&lt;/code&gt; ,&lt;/a&gt; переданным в конструктор.</target>
        </trans-unit>
        <trans-unit id="8b40e55c8fd12c110479c1a8e453add933b9c6e8" translate="yes" xml:space="preserve">
          <source>Built-in Python types</source>
          <target state="translated">Встроенные питоновые типы</target>
        </trans-unit>
        <trans-unit id="b858e075ef402953578da270159a51f6ad1575b6" translate="yes" xml:space="preserve">
          <source>Built-in scalar types</source>
          <target state="translated">Встроенные скалярные типы</target>
        </trans-unit>
        <trans-unit id="4a2892e18069d1f5869c7225c38ebadc7aa96d21" translate="yes" xml:space="preserve">
          <source>Bundled version of LAPACK is now 3.2.2</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f0300972b4a8f0b0074aec4f6903cf3e57d597c8" translate="yes" xml:space="preserve">
          <source>Business Day Functionality</source>
          <target state="translated">Бизнес-день Функциональность</target>
        </trans-unit>
        <trans-unit id="3cbeeffaaa46e0b3d6b0ea56538a20f899791f42" translate="yes" xml:space="preserve">
          <source>Business Day Functions</source>
          <target state="translated">Функции рабочего дня</target>
        </trans-unit>
        <trans-unit id="a4da80602eb90228591a52fa43450b5af3478d27" translate="yes" xml:space="preserve">
          <source>But different types can be used for substitution. In fact, this is how conversion of Polynomial classes among themselves is done for type, domain, and window casting:</source>
          <target state="translated">Но для замены могут использоваться различные типы.Фактически,именно так происходит преобразование классов Polynomial между собой для приведения типов,доменов и окон:</target>
        </trans-unit>
        <trans-unit id="bd8c2ef60d42745d2cdc473c152c1f9687c4dcc2" translate="yes" xml:space="preserve">
          <source>But if &lt;code&gt;rowsum&lt;/code&gt; would have two dimensions as well:</source>
          <target state="translated">Но если &lt;code&gt;rowsum&lt;/code&gt; будет иметь два измерения:</target>
        </trans-unit>
        <trans-unit id="b4df18df25d280603f202e60c13a7a8f66254798" translate="yes" xml:space="preserve">
          <source>But is also allowed to produce, for some &lt;code&gt;a, b, c, d&lt;/code&gt;:</source>
          <target state="translated">Но также разрешено производить для некоторых &lt;code&gt;a, b, c, d&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="6646b6ecbc06bc26898d3bc8dfd20372b9b785ad" translate="yes" xml:space="preserve">
          <source>But that&amp;rsquo;s not the only way to look at it. Suppose one has large two-dimensional arrays (images or matrices) stored in data files. Suppose the data are stored by rows rather than by columns. If we are to preserve our index convention (whether matrix or image) that means that depending on the language we use, we may be forced to reorder the data if it is read into memory to preserve our indexing convention. For example if we read row-ordered data into memory without reordering, it will match the matrix indexing convention for C, but not for Fortran. Conversely, it will match the image indexing convention for Fortran, but not for C. For C, if one is using data stored in row order, and one wants to preserve the image index convention, the data must be reordered when reading into memory.</source>
          <target state="translated">Но это не единственный способ взглянуть на это. Предположим, у вас есть большие двумерные массивы (изображения или матрицы), хранящиеся в файлах данных. Предположим, что данные хранятся по строкам, а не по столбцам. Если мы хотим сохранить наше соглашение об индексировании (будь то матрица или изображение), это означает, что в зависимости от используемого языка мы можем быть вынуждены переупорядочить данные, если они считываются в память, чтобы сохранить наше соглашение об индексировании. Например, если мы читаем упорядоченные по строкам данные в память без переупорядочения, они будут соответствовать соглашению об индексировании матрицы для C, но не для Fortran. И наоборот, он будет соответствовать соглашению об индексировании изображений для Fortran, но не для C. Для C, если используются данные, хранящиеся в порядке строк, и кто-то хочет сохранить соглашение об индексировании изображений, данные должны быть переупорядочены при чтении в память.</target>
        </trans-unit>
        <trans-unit id="6e0bd4df436692919faeb191ed09cf810cb22035" translate="yes" xml:space="preserve">
          <source>But there are cross-platform considerations, such as library file extensions, plus the fact Windows will just load the first library it finds with that name. NumPy supplies the load_library function as a convenience.</source>
          <target state="translated">Но есть и кросс-платформенные соображения,такие как расширение файлов библиотеки,плюс тот факт,что Windows просто загрузит первую найденную библиотеку с таким именем.Для удобства NumPy поставляет функцию load_library.</target>
        </trans-unit>
        <trans-unit id="ec781290ccbee49bdd7da500afd06d4ca2f948bf" translate="yes" xml:space="preserve">
          <source>But this omits some subtleties. Here is a fully general summary:</source>
          <target state="translated">Но в этом не хватает тонкостей.Вот полностью общее резюме:</target>
        </trans-unit>
        <trans-unit id="9d33835f4b0ffd7a417785ade1f5f4a66909b7f6" translate="yes" xml:space="preserve">
          <source>But we can also specify the axis over which to multiply:</source>
          <target state="translated">Но мы также можем указать ось,по которой нужно умножать:</target>
        </trans-unit>
        <trans-unit id="9f79d5f66a9deb8e0798847bf7ab428de8db1e5a" translate="yes" xml:space="preserve">
          <source>But when you use &lt;code&gt;ravel&lt;/code&gt;, the changes you make to the new array will affect the parent array.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7460c60c1fec76b65a3c31a575c95674fb86e283" translate="yes" xml:space="preserve">
          <source>But, we could do anything we wanted:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e13f0fd9c0e50a5064cf51cb50663812feb86a8e" translate="yes" xml:space="preserve">
          <source>Buzas, Martin A.; Culver, Stephen J., Understanding regional species diversity through the log series distribution of occurrences: BIODIVERSITY RESEARCH Diversity &amp;amp; Distributions, Volume 5, Number 5, September 1999 , pp. 187-195(9).</source>
          <target state="translated">Buzas, Martin A .; Калвер, Стивен Дж., Понимание регионального видового разнообразия через распределение встречаемости в логарифмических рядах: ИССЛЕДОВАНИЕ БИОРАЗНООБРАЗИЯ Разнообразие и распространение, Том 5, номер 5, сентябрь 1999 г., стр. 187-195 (9).</target>
        </trans-unit>
        <trans-unit id="66360bf7fbf8657df2c1591ab899dd54476a182c" translate="yes" xml:space="preserve">
          <source>By choosing an offset of 8 bytes we can select the complex part of the array for our view:</source>
          <target state="translated">Выбирая смещение в 8 байт,мы можем выбрать сложную часть массива для нашего представления:</target>
        </trans-unit>
        <trans-unit id="c96bbfd74d3086f0a931f577a61fdefbdd812bbe" translate="yes" xml:space="preserve">
          <source>By constructing a new ndarray of your desired shape and type using &lt;a href=&quot;../reference/c-api/array#c.PyArray_NewFromDescr&quot;&gt;&lt;code&gt;PyArray_NewFromDescr&lt;/code&gt;&lt;/a&gt; or a simpler macro or function based on it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6503cfb311994e99b18c321cb4370162b665063d" translate="yes" xml:space="preserve">
          <source>By convention, the negative sign represents cash flow out (i.e. money not available today). Thus, saving $100 a month at 5% annual interest leads to $15,692.93 available to spend in 10 years.</source>
          <target state="translated">По условию,отрицательный знак представляет собой денежный поток (т.е.деньги,недоступные сегодня).Таким образом,экономия $100 в месяц под 5% годовых приводит к тому,что через 10 лет можно будет потратить $15 692,93.</target>
        </trans-unit>
        <trans-unit id="7f5fbe94c54051531f7d898251f9826df16e5720" translate="yes" xml:space="preserve">
          <source>By convention, the negative sign represents cash flow out (i.e., money not available today). Thus, to end up with $15,692.93 in 10 years saving $100 a month at 5% annual interest, one&amp;rsquo;s initial deposit should also be $100.</source>
          <target state="translated">По соглашению, отрицательный знак означает отток наличности (то есть деньги, которых сегодня нет в наличии). Таким образом, чтобы в конечном итоге получить 15 692,93 доллара за 10 лет, сэкономив 100 долларов в месяц под 5% годовых, начальный депозит также должен составлять 100 долларов.</target>
        </trans-unit>
        <trans-unit id="e8f9209679e0d480aec7fb981fefcc0f2b86d6ab" translate="yes" xml:space="preserve">
          <source>By converting it from some Python object using &lt;a href=&quot;../reference/c-api/array#c.PyArray_FromAny&quot;&gt;&lt;code&gt;PyArray_FromAny&lt;/code&gt;&lt;/a&gt; or a macro built on it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2387467eae05dde35d2654a3dbfc0d30bc85b00f" translate="yes" xml:space="preserve">
          <source>By default (&lt;code&gt;align=False&lt;/code&gt;), numpy will pack the fields together such that each field starts at the byte offset the previous field ended, and the fields are contiguous in memory.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="52bf606add02bda44e68afd9558117218dd1b2cb" translate="yes" xml:space="preserve">
          <source>By default &lt;a href=&quot;#numpy.testing.rundocs&quot;&gt;&lt;code&gt;rundocs&lt;/code&gt;&lt;/a&gt; raises an AssertionError on failure.</source>
          <target state="translated">По умолчанию &lt;a href=&quot;#numpy.testing.rundocs&quot;&gt; &lt;code&gt;rundocs&lt;/code&gt; &lt;/a&gt; вызывает ошибку AssertionError.</target>
        </trans-unit>
        <trans-unit id="0791e549c9e1c0c68c18f4046427ddfd65fee6cf" translate="yes" xml:space="preserve">
          <source>By default, &lt;a href=&quot;generator#numpy.random.Generator&quot;&gt;&lt;code&gt;Generator&lt;/code&gt;&lt;/a&gt; uses bits provided by &lt;a href=&quot;bit_generators/pcg64#numpy.random.pcg64.PCG64&quot;&gt;&lt;code&gt;PCG64&lt;/code&gt;&lt;/a&gt; which has better statistical properties than the legacy mt19937 random number generator in &lt;a href=&quot;legacy#numpy.random.mtrand.RandomState&quot;&gt;&lt;code&gt;RandomState&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">По умолчанию &lt;a href=&quot;generator#numpy.random.Generator&quot;&gt; &lt;code&gt;Generator&lt;/code&gt; &lt;/a&gt; использует биты, предоставленные &lt;a href=&quot;bit_generators/pcg64#numpy.random.pcg64.PCG64&quot;&gt; &lt;code&gt;PCG64&lt;/code&gt; ,&lt;/a&gt; который имеет лучшие статистические свойства, чем унаследованный генератор случайных чисел &lt;a href=&quot;legacy#numpy.random.mtrand.RandomState&quot;&gt; &lt;code&gt;RandomState&lt;/code&gt; &lt;/a&gt; в RandomState .</target>
        </trans-unit>
        <trans-unit id="2eb2435c3e98faf455297cd059d456431f056aed" translate="yes" xml:space="preserve">
          <source>By default, &lt;code&gt;float16&lt;/code&gt; results are computed using &lt;code&gt;float32&lt;/code&gt; intermediates for extra precision.</source>
          <target state="translated">По умолчанию результаты &lt;code&gt;float16&lt;/code&gt; вычисляются с использованием промежуточных &lt;code&gt;float32&lt;/code&gt; для дополнительной точности.</target>
        </trans-unit>
        <trans-unit id="f255d5e8f1a7ce5480c00642bd965d8cbd147605" translate="yes" xml:space="preserve">
          <source>By default, &lt;code&gt;skip_header=0&lt;/code&gt; and &lt;code&gt;skip_footer=0&lt;/code&gt;, meaning that no lines are skipped.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="509cc82d7b395ceb5fa528a542a3fa0619544044" translate="yes" xml:space="preserve">
          <source>By default, a new array is created of the given shape and data-type. If &lt;code&gt;buf&lt;/code&gt; is specified and is an object exposing the buffer interface, the array will use the memory from the existing buffer. In this case, the &lt;code&gt;offset&lt;/code&gt; and &lt;a href=&quot;numpy.recarray.strides#numpy.recarray.strides&quot;&gt;&lt;code&gt;strides&lt;/code&gt;&lt;/a&gt; keywords are available.</source>
          <target state="translated">По умолчанию создается новый массив заданной формы и типа данных. Если указан &lt;code&gt;buf&lt;/code&gt; и является объектом, предоставляющим интерфейс буфера, массив будет использовать память из существующего буфера. В этом случае доступны ключевые слова &lt;code&gt;offset&lt;/code&gt; и &lt;a href=&quot;numpy.recarray.strides#numpy.recarray.strides&quot;&gt; &lt;code&gt;strides&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="823f8fa3f73a578c65a2065fa5f02e69dcee70ef" translate="yes" xml:space="preserve">
          <source>By default, all user-defined data-types are not presumed to be safely castable to any builtin data-types. In addition builtin data-types are not presumed to be safely castable to user-defined data-types. This situation limits the ability of user-defined data-types to participate in the coercion system used by ufuncs and other times when automatic coercion takes place in NumPy. This can be changed by registering data-types as safely castable from a particular data-type object. The function &lt;a href=&quot;../reference/c-api/array#c.PyArray_RegisterCanCast&quot;&gt;&lt;code&gt;PyArray_RegisterCanCast&lt;/code&gt;&lt;/a&gt; (from_descr, totype_number, scalarkind) should be used to specify that the data-type object from_descr can be cast to the data-type with type number totype_number. If you are not trying to alter scalar coercion rules, then use &lt;a href=&quot;../reference/c-api/array#c.NPY_NOSCALAR&quot;&gt;&lt;code&gt;NPY_NOSCALAR&lt;/code&gt;&lt;/a&gt; for the scalarkind argument.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c3c9f5af6f6f20b9748f044265ea41cc53afdaad" translate="yes" xml:space="preserve">
          <source>By default, any empty string is marked as missing. We can also consider more complex strings, such as &lt;code&gt;&quot;N/A&quot;&lt;/code&gt; or &lt;code&gt;&quot;???&quot;&lt;/code&gt; to represent missing or invalid data. The &lt;code&gt;missing_values&lt;/code&gt; argument accepts three kind of values:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5c0614e39713a118bc2e830f1f54b096ac814bb1" translate="yes" xml:space="preserve">
          <source>By default, astype always returns a newly allocated array. If this is set to false, and the &lt;a href=&quot;numpy.char.chararray.dtype#numpy.char.chararray.dtype&quot;&gt;&lt;code&gt;dtype&lt;/code&gt;&lt;/a&gt;, &lt;code&gt;order&lt;/code&gt;, and &lt;code&gt;subok&lt;/code&gt; requirements are satisfied, the input array is returned instead of a copy.</source>
          <target state="translated">По умолчанию astype всегда возвращает только что выделенный массив. Если для него установлено значение false и требования &lt;a href=&quot;numpy.char.chararray.dtype#numpy.char.chararray.dtype&quot;&gt; &lt;code&gt;dtype&lt;/code&gt; &lt;/a&gt; , &lt;code&gt;order&lt;/code&gt; и &lt;code&gt;subok&lt;/code&gt; удовлетворены, вместо копии возвращается входной массив.</target>
        </trans-unit>
        <trans-unit id="65020739d65de234914c6eca7148d91943920302" translate="yes" xml:space="preserve">
          <source>By default, astype always returns a newly allocated array. If this is set to false, and the &lt;a href=&quot;numpy.dtype#numpy.dtype&quot;&gt;&lt;code&gt;dtype&lt;/code&gt;&lt;/a&gt;, &lt;code&gt;order&lt;/code&gt;, and &lt;code&gt;subok&lt;/code&gt; requirements are satisfied, the input array is returned instead of a copy.</source>
          <target state="translated">По умолчанию astype всегда возвращает только что выделенный массив. Если для него установлено значение false и требования &lt;a href=&quot;numpy.dtype#numpy.dtype&quot;&gt; &lt;code&gt;dtype&lt;/code&gt; &lt;/a&gt; , &lt;code&gt;order&lt;/code&gt; и &lt;code&gt;subok&lt;/code&gt; удовлетворены, вместо копии возвращается входной массив.</target>
        </trans-unit>
        <trans-unit id="67bd53a8510577a68e06f12cd6753f65341b7ba7" translate="yes" xml:space="preserve">
          <source>By default, astype always returns a newly allocated array. If this is set to false, and the &lt;a href=&quot;numpy.ma.masked_array.dtype#numpy.ma.masked_array.dtype&quot;&gt;&lt;code&gt;dtype&lt;/code&gt;&lt;/a&gt;, &lt;code&gt;order&lt;/code&gt;, and &lt;code&gt;subok&lt;/code&gt; requirements are satisfied, the input array is returned instead of a copy.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="33a91516197cac2d79884383700e7cb303d84acc" translate="yes" xml:space="preserve">
          <source>By default, astype always returns a newly allocated array. If this is set to false, and the &lt;a href=&quot;numpy.ma.maskedarray.dtype#numpy.ma.MaskedArray.dtype&quot;&gt;&lt;code&gt;dtype&lt;/code&gt;&lt;/a&gt;, &lt;code&gt;order&lt;/code&gt;, and &lt;code&gt;subok&lt;/code&gt; requirements are satisfied, the input array is returned instead of a copy.</source>
          <target state="translated">По умолчанию astype всегда возвращает только что выделенный массив. Если для него установлено значение false и требования &lt;a href=&quot;numpy.ma.maskedarray.dtype#numpy.ma.MaskedArray.dtype&quot;&gt; &lt;code&gt;dtype&lt;/code&gt; &lt;/a&gt; , &lt;code&gt;order&lt;/code&gt; и &lt;code&gt;subok&lt;/code&gt; удовлетворены, вместо копии возвращается входной массив.</target>
        </trans-unit>
        <trans-unit id="18abc4afb5a03b89f3bcee3c191658826915b7e7" translate="yes" xml:space="preserve">
          <source>By default, calculate the product of all elements:</source>
          <target state="translated">По умолчанию вычисляется произведение всех элементов:</target>
        </trans-unit>
        <trans-unit id="29592fecd779ff823d8494d78a32e4c6bef17a8b" translate="yes" xml:space="preserve">
          <source>By default, masked values are recognized as such. If &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; have the same shape, a common mask is allocated: if &lt;code&gt;x[i,j]&lt;/code&gt; is masked, then &lt;code&gt;y[i,j]&lt;/code&gt; will also be masked. Setting &lt;code&gt;allow_masked&lt;/code&gt; to False will raise an exception if values are missing in either of the input arrays.</source>
          <target state="translated">По умолчанию замаскированные значения распознаются как таковые. Если &lt;code&gt;x&lt;/code&gt; и &lt;code&gt;y&lt;/code&gt; имеют одинаковую форму, назначается общая маска: если &lt;code&gt;x[i,j]&lt;/code&gt; замаскирован, то &lt;code&gt;y[i,j]&lt;/code&gt; также будет замаскирован. Установка для &lt;code&gt;allow_masked&lt;/code&gt; значения False вызовет исключение, если значения отсутствуют в любом из входных массивов.</target>
        </trans-unit>
        <trans-unit id="72d47f0b8465ed8e3b2a5736c0d1dfec28a91237" translate="yes" xml:space="preserve">
          <source>By default, mode is &amp;lsquo;full&amp;rsquo;. This returns the convolution at each point of overlap, with an output shape of (N+M-1,). At the end-points of the convolution, the signals do not overlap completely, and boundary effects may be seen.</source>
          <target state="translated">По умолчанию установлен режим &amp;laquo;полный&amp;raquo;. Это возвращает свертку в каждой точке перекрытия с выходной формой (N + M-1,). В конечных точках свертки сигналы не перекрываются полностью, и могут наблюдаться граничные эффекты.</target>
        </trans-unit>
        <trans-unit id="781e5458e78b28bbdf619e8539b2f911598af3c5" translate="yes" xml:space="preserve">
          <source>By default, returned multidimensional arrays are Fortran-contiguous. If &lt;code&gt;intent(c)&lt;/code&gt; is used, then returned multidimensional arrays are C-contiguous.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6971450c7aa549483b5389a69fedb16eaf066171" translate="yes" xml:space="preserve">
          <source>By default, reverse the dimensions, otherwise permute the axes according to the values given.</source>
          <target state="translated">По умолчанию отмените размеры,в противном случае перекройте оси в соответствии с заданными значениями.</target>
        </trans-unit>
        <trans-unit id="f55a7b395485c3988f5bccbb6f9eaebb26dfc947" translate="yes" xml:space="preserve">
          <source>By default, the &lt;a href=&quot;generated/numpy.nditer#numpy.nditer&quot;&gt;&lt;code&gt;nditer&lt;/code&gt;&lt;/a&gt; treats the input operand as a read-only object. To be able to modify the array elements, you must specify either read-write or write-only mode using the &lt;code&gt;&amp;lsquo;readwrite&amp;rsquo;&lt;/code&gt; or &lt;code&gt;&amp;lsquo;writeonly&amp;rsquo;&lt;/code&gt; per-operand flags.</source>
          <target state="translated">По умолчанию &lt;a href=&quot;generated/numpy.nditer#numpy.nditer&quot;&gt; &lt;code&gt;nditer&lt;/code&gt; &lt;/a&gt; обрабатывает входной операнд как объект только для чтения. Чтобы иметь возможность изменять элементы массива, вы должны указать режим чтения-записи или только для записи, используя &lt;code&gt;&amp;lsquo;readwrite&amp;rsquo;&lt;/code&gt; или &lt;code&gt;&amp;lsquo;writeonly&amp;rsquo;&lt;/code&gt; каждого операнда.</target>
        </trans-unit>
        <trans-unit id="174daf14dced474235661dc4a8a7f2c4b87b4b7c" translate="yes" xml:space="preserve">
          <source>By default, the &lt;a href=&quot;generated/numpy.nditer#numpy.nditer&quot;&gt;&lt;code&gt;nditer&lt;/code&gt;&lt;/a&gt; uses the flags &amp;lsquo;allocate&amp;rsquo; and &amp;lsquo;writeonly&amp;rsquo; for operands that are passed in as None. This means we were able to provide just the two operands to the iterator, and it handled the rest.</source>
          <target state="translated">По умолчанию &lt;a href=&quot;generated/numpy.nditer#numpy.nditer&quot;&gt; &lt;code&gt;nditer&lt;/code&gt; &lt;/a&gt; использует флаги allocate и writeonly для операндов, которые передаются как None. Это означает, что мы смогли предоставить итератору только два операнда, а он обработал все остальное.</target>
        </trans-unit>
        <trans-unit id="17e308c1f2a6481942287f2519e364f482dd5128" translate="yes" xml:space="preserve">
          <source>By default, the data-type is inferred from the input data.</source>
          <target state="translated">По умолчанию тип данных выведен из входных данных.</target>
        </trans-unit>
        <trans-unit id="d105f45ad87599a046dab97b11d0171a9dd2c47e" translate="yes" xml:space="preserve">
          <source>By default, the index is into the flattened array, otherwise along the specified axis.</source>
          <target state="translated">По умолчанию индекс находится в сплющенном массиве,в противном случае-вдоль указанной оси.</target>
        </trans-unit>
        <trans-unit id="e68b2ebbdaa7d8bde52807398926b542381f9c7b" translate="yes" xml:space="preserve">
          <source>By default, the iterator produces pointers into the arrays provided, which may be aligned or unaligned, and with any byte order. If copying or buffering is not enabled and the operand data doesn&amp;rsquo;t satisfy the constraints, an error will be raised.</source>
          <target state="translated">По умолчанию итератор создает указатели на предоставленные массивы, которые могут быть выровненными или невыровненными, и с любым порядком байтов. Если копирование или буферизация не включены, а данные операнда не удовлетворяют ограничениям, возникает ошибка.</target>
        </trans-unit>
        <trans-unit id="ab25c157edc4354c1f57c1df2646a0b82ab1dad1" translate="yes" xml:space="preserve">
          <source>By default, these operations apply to the array as though it were a list of numbers, regardless of its shape. However, by specifying the &lt;code&gt;axis&lt;/code&gt; parameter you can apply an operation along the specified axis of an array:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8619d136820b4ea98c355d5e9bb29020512d7ef1" translate="yes" xml:space="preserve">
          <source>By default, when a line is decomposed into a series of strings, the individual entries are not stripped of leading nor trailing white spaces. This behavior can be overwritten by setting the optional argument &lt;code&gt;autostrip&lt;/code&gt; to a value of &lt;code&gt;True&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a90e6d5076b3318d5438106f6aec8b51a30f2edc" translate="yes" xml:space="preserve">
          <source>By eliminating the inner loop in the description above, and using &lt;a href=&quot;numpy.s_#numpy.s_&quot;&gt;&lt;code&gt;s_&lt;/code&gt;&lt;/a&gt; to build simple slice objects, &lt;a href=&quot;#numpy.take&quot;&gt;&lt;code&gt;take&lt;/code&gt;&lt;/a&gt; can be expressed in terms of applying fancy indexing to each 1-d slice:</source>
          <target state="translated">Удалив внутренний цикл из приведенного выше описания и используя &lt;a href=&quot;numpy.s_#numpy.s_&quot;&gt; &lt;code&gt;s_&lt;/code&gt; &lt;/a&gt; для создания простых объектов-срезов, &lt;a href=&quot;#numpy.take&quot;&gt; &lt;code&gt;take&lt;/code&gt; &lt;/a&gt; можно выразить в терминах применения причудливой индексации к каждому 1-мерному срезу:</target>
        </trans-unit>
        <trans-unit id="f5e127dadff417279256627201011a26eddd8177" translate="yes" xml:space="preserve">
          <source>By enabling buffering mode, the chunks provided by the iterator to the inner loop can be made larger, significantly reducing the overhead of the Python interpreter. In the example forcing Fortran iteration order, the inner loop gets to see all the elements in one go when buffering is enabled.</source>
          <target state="translated">Включение режима буферизации позволяет увеличить куски,подаваемые итератором во внутренний контур,что значительно снижает накладные расходы интерпретатора Python.В примере принудительной итерации Fortran,при включении буферизации внутренний цикл получает возможность видеть все элементы за один заход.</target>
        </trans-unit>
        <trans-unit id="842fa81b602f5ee9d6e48f92f8610cb23e1b4b1b" translate="yes" xml:space="preserve">
          <source>By examining the coefficients, we see that the line should have a gradient of roughly 1 and cut the y-axis at, more or less, -1.</source>
          <target state="translated">Рассматривая коэффициенты,мы видим,что линия должна иметь градиент примерно 1 и обрезать ось y на,более или менее,-1.</target>
        </trans-unit>
        <trans-unit id="4b0026b5caaf6e12c9b18e1ac7ccb5e7684a2b52" translate="yes" xml:space="preserve">
          <source>By far the most complex case is advanced indexing, which may or may not be combined with typical view based indexing. Here integer indices are interpreted as view based. Before trying to understand this, you may want to make yourself familiar with its subtleties. The advanced indexing code has three different branches and one special case:</source>
          <target state="translated">Безусловно,самым сложным случаем является расширенная индексация,которая может сочетаться,а может и не сочетаться с индексацией,основанной на типичных представлениях.Здесь целочисленные индексы интерпретируются как видовые.Прежде чем пытаться понять это,возможно,вы захотите познакомиться с его тонкостями.Код расширенной индексации имеет три различные ветви и один особый случай:</target>
        </trans-unit>
        <trans-unit id="46784614463c18819405731702cb3c998ad15a83" translate="yes" xml:space="preserve">
          <source>By placing intent directives and checking code, the interface can be cleaned up quite a bit until the Python module method is both easier to use and more robust.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eb83a5c83addee3a887cb831a30aba85bb504443" translate="yes" xml:space="preserve">
          <source>By substituting</source>
          <target state="translated">Заменяя</target>
        </trans-unit>
        <trans-unit id="5cf0a6a61d5c04a9d920300ad8c8de64a060c650" translate="yes" xml:space="preserve">
          <source>By the above description, the casting rules are essentially implemented by the question of when a data type can be cast &amp;ldquo;safely&amp;rdquo; to another data type. The answer to this question can be determined in Python with a function call: &lt;a href=&quot;generated/numpy.can_cast#numpy.can_cast&quot;&gt;&lt;code&gt;can_cast(fromtype, totype)&lt;/code&gt;&lt;/a&gt;. The Figure below shows the results of this call for the 24 internally supported types on the author&amp;rsquo;s 64-bit system. You can generate this table for your system with the code given in the Figure.</source>
          <target state="translated">Согласно приведенному выше описанию, правила приведения по существу реализуются вопросом о том, когда тип данных может быть &amp;laquo;безопасно&amp;raquo; приведен к другому типу данных. Ответ на этот вопрос можно определить в Python с помощью вызова функции: &lt;a href=&quot;generated/numpy.can_cast#numpy.can_cast&quot;&gt; &lt;code&gt;can_cast(fromtype, totype)&lt;/code&gt; &lt;/a&gt; . На рисунке ниже показаны результаты этого вызова для 24 типов, поддерживаемых внутри 64-разрядной системы автора. Вы можете создать эту таблицу для своей системы с помощью кода, приведенного на рисунке.</target>
        </trans-unit>
        <trans-unit id="0cffcf4de4e9b85ff13913ac390d2131986b166e" translate="yes" xml:space="preserve">
          <source>Byte (-128 to 127)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c3b1bb21176956a777afbce91b2dc46b27bfdbd1" translate="yes" xml:space="preserve">
          <source>Byte order of the data (&lt;a href=&quot;../glossary#term-little-endian&quot;&gt;little-endian&lt;/a&gt; or &lt;a href=&quot;../glossary#term-big-endian&quot;&gt;big-endian&lt;/a&gt;)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c3ee543ea3c911ca70be24ca50be4966bfc9d11e" translate="yes" xml:space="preserve">
          <source>Byte order of the data (&lt;a href=&quot;https://docs.scipy.org/doc/numpy-1.17.0/glossary.html#term-little-endian&quot;&gt;little-endian&lt;/a&gt; or &lt;a href=&quot;https://docs.scipy.org/doc/numpy-1.17.0/glossary.html#term-big-endian&quot;&gt;big-endian&lt;/a&gt;)</source>
          <target state="translated">Порядок байтов данных ( &lt;a href=&quot;https://docs.scipy.org/doc/numpy-1.17.0/glossary.html#term-little-endian&quot;&gt;прямой&lt;/a&gt; или &lt;a href=&quot;https://docs.scipy.org/doc/numpy-1.17.0/glossary.html#term-big-endian&quot;&gt;прямой порядок байтов&lt;/a&gt; )</target>
        </trans-unit>
        <trans-unit id="4fa7dfbdbb33fd63c061542164ead10c6ea66cdb" translate="yes" xml:space="preserve">
          <source>Byte order to force; a value from the byte order specifications above. The default value (&amp;lsquo;S&amp;rsquo;) results in swapping the current byte order. The code does a case-insensitive check on the first letter of &lt;code&gt;new_order&lt;/code&gt; for the alternatives above. For example, any of &amp;lsquo;B&amp;rsquo; or &amp;lsquo;b&amp;rsquo; or &amp;lsquo;biggish&amp;rsquo; are valid to specify big-endian.</source>
          <target state="translated">Порядок байтов принудительно; значение из указанных выше спецификаций порядка байтов. Значение по умолчанию ('S') приводит к замене текущего порядка байтов. Код проверяет первую букву &lt;code&gt;new_order&lt;/code&gt; без учета регистра для указанных выше альтернатив. Например, любой из символов &amp;laquo;B&amp;raquo;, &amp;laquo;b&amp;raquo; или &amp;laquo;biggish&amp;raquo; может указывать на прямой порядок байтов.</target>
        </trans-unit>
        <trans-unit id="d891a9572e92fd87112849b433aa9d82773e6323" translate="yes" xml:space="preserve">
          <source>Byte order to force; a value from the byte order specifications below. &lt;code&gt;new_order&lt;/code&gt; codes can be any of:</source>
          <target state="translated">Порядок байтов принудительно; значение из приведенных ниже спецификаций порядка байтов. Коды &lt;code&gt;new_order&lt;/code&gt; могут быть любыми из:</target>
        </trans-unit>
        <trans-unit id="925da9e3660113afb959c492e32c0df4c8fba9ab" translate="yes" xml:space="preserve">
          <source>Byte order to force; a value from the byte order specifications below. The default value (&amp;lsquo;S&amp;rsquo;) results in swapping the current byte order. &lt;code&gt;new_order&lt;/code&gt; codes can be any of:</source>
          <target state="translated">Порядок байтов принудительно; значение из приведенных ниже спецификаций порядка байтов. Значение по умолчанию ('S') приводит к замене текущего порядка байтов. Коды &lt;code&gt;new_order&lt;/code&gt; могут быть любыми из:</target>
        </trans-unit>
        <trans-unit id="208a9d70c2ceb4cad845268b3793f06f24736861" translate="yes" xml:space="preserve">
          <source>Byte-order for all fields.</source>
          <target state="translated">Байт-заказ для всех полей.</target>
        </trans-unit>
        <trans-unit id="3d30b75f6bbab6dd2f33ea184465104adfe034dc" translate="yes" xml:space="preserve">
          <source>Byte-swapping</source>
          <target state="translated">Byte-swapping</target>
        </trans-unit>
        <trans-unit id="32096c2e0eff33d844ee6d675407ace18289357d" translate="yes" xml:space="preserve">
          <source>C</source>
          <target state="translated">C</target>
        </trans-unit>
        <trans-unit id="c380132bd13732c2a4492b58e8089f6c672f3148" translate="yes" xml:space="preserve">
          <source>C API</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="90c2059501661b20579455b452bcdf7917e96a74" translate="yes" xml:space="preserve">
          <source>C API Deprecations</source>
          <target state="translated">C API Уменьшения</target>
        </trans-unit>
        <trans-unit id="5eefd673571a664f98901cbfc9269cc56d66bdd2" translate="yes" xml:space="preserve">
          <source>C API changes</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="991eaf0718be5436cf82b4e88422dbaeb580655b" translate="yes" xml:space="preserve">
          <source>C API for random</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a09f5c39498227c23bac03c4d85a857f0c660b68" translate="yes" xml:space="preserve">
          <source>C dialect</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="baf0b9cf537d3452f0bedecd7885e6a6f5c95212" translate="yes" xml:space="preserve">
          <source>C expressions</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5053549bf41c7c644de43b7357e8b95981f3b14c" translate="yes" xml:space="preserve">
          <source>C expressions are used in the following parts of signature files:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="62988a5cc34cb2d480ad455963d13a5b50fea224" translate="yes" xml:space="preserve">
          <source>C order</source>
          <target state="translated">порядок С</target>
        </trans-unit>
        <trans-unit id="4d3779622c7ddb81083220abbfe17022ee213c7f" translate="yes" xml:space="preserve">
          <source>C order.</source>
          <target state="translated">Заказ С.</target>
        </trans-unit>
        <trans-unit id="502ca6c945d9f8aee115c49e01f9edd12a50b0c8" translate="yes" xml:space="preserve">
          <source>C type</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1ef859ea3c4b4e94c8561ce88af6e45cd8c349e4" translate="yes" xml:space="preserve">
          <source>C++ support</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e04e63e5d64190b9021eeae0aa43f4dd8f802b80" translate="yes" xml:space="preserve">
          <source>C-API</source>
          <target state="translated">C-API</target>
        </trans-unit>
        <trans-unit id="b42fb0a4e21a6c7c2ad779467660c5d634cd1f27" translate="yes" xml:space="preserve">
          <source>C-API Array Additions</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="20e7136fe60c57d32b3ba713a50d60dd983c3865" translate="yes" xml:space="preserve">
          <source>C-API Developer Improvements</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="847c15716f4f18fd587862ab143e5d2f9581c235" translate="yes" xml:space="preserve">
          <source>C-API Ufunc Additions</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c77824df8f5b9b7ad0f95af7e88364d494112e7e" translate="yes" xml:space="preserve">
          <source>C-API for implementing Elementary Functions</source>
          <target state="translated">C-API для реализации элементарных функций</target>
        </trans-unit>
        <trans-unit id="6bc42241dfe0e66ad03fd900ab60e09366468123" translate="yes" xml:space="preserve">
          <source>C-Level string to datetime casts changed</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="39aa49db7f4958819165d85870c4e3056a314158" translate="yes" xml:space="preserve">
          <source>C-Types Foreign Function Interface (&lt;code&gt;numpy.ctypeslib&lt;/code&gt;)</source>
          <target state="translated">Интерфейс внешних функций C-типов ( &lt;code&gt;numpy.ctypeslib&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="1ee13877e6105fd56e4080481ca6046e3bea7c13" translate="yes" xml:space="preserve">
          <source>C-Types Foreign Function Interface (numpy.ctypeslib)</source>
          <target state="translated">C-типы Иностранный функциональный интерфейс (numpy.ctypeslib)</target>
        </trans-unit>
        <trans-unit id="72c1b618d901fa2527c184612af8e5f097445876" translate="yes" xml:space="preserve">
          <source>C-contiguous or simply contiguous arrays when data is stored row-wise, i.e. indexing of data as stored in memory starts from the highest dimension.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bdb65d7a9aa6da6471ba4a02f9d435dd19d2ae5a" translate="yes" xml:space="preserve">
          <source>C-order</source>
          <target state="translated">C-order</target>
        </trans-unit>
        <trans-unit id="8bbf8c25cb421fee0bffcb1218c14c15435923a5" translate="yes" xml:space="preserve">
          <source>C-ordered arrays evaluate as False even if they are also FORTRAN-ordered.</source>
          <target state="translated">Массивы с C-образным порядком оцениваются как False,даже если они также заказаны FORTRAN.</target>
        </trans-unit>
        <trans-unit id="18f7fb2659bfefae5fe403809093ff794847eddb" translate="yes" xml:space="preserve">
          <source>C-series coefficients of the integral.</source>
          <target state="translated">Коэффициенты С-серия интеграла.</target>
        </trans-unit>
        <trans-unit id="aa3b96b2dd6cb469f06816ec7d846596063a8314" translate="yes" xml:space="preserve">
          <source>C-side of the array interface</source>
          <target state="translated">C-сторона интерфейса массива</target>
        </trans-unit>
        <trans-unit id="6e0b67185c9289cda6113607f367a9d9edf7fee3" translate="yes" xml:space="preserve">
          <source>C-struct access</source>
          <target state="translated">C-образный доступ</target>
        </trans-unit>
        <trans-unit id="bd0b363c8100c3e0002d75837308df33fee89719" translate="yes" xml:space="preserve">
          <source>C-type names</source>
          <target state="translated">имена типа С</target>
        </trans-unit>
        <trans-unit id="af48e472b36161e129dd7edb2b2bd61998b64144" translate="yes" xml:space="preserve">
          <source>C. W. Clenshaw, &amp;ldquo;Chebyshev series for mathematical functions&amp;rdquo;, in &lt;em&gt;National Physical Laboratory Mathematical Tables&lt;/em&gt;, vol. 5, London: Her Majesty&amp;rsquo;s Stationery Office, 1962.</source>
          <target state="translated">CW Clenshaw, &quot;Ряды Чебышева для математических функций&quot;, в &lt;em&gt;Национальной физической лаборатории Mathematical Tables&lt;/em&gt; , vol. 5, Лондон: Канцелярские товары Ее Величества, 1962.</target>
        </trans-unit>
        <trans-unit id="43beb2dca45ea5b86cf6e2c78e1df08bb1062e1a" translate="yes" xml:space="preserve">
          <source>C99-like complex functions have been added. Those can be used if you wish to implement portable C extensions. Since we still support platforms without C99 complex type, you need to restrict to C90-compatible syntax, e.g.:</source>
          <target state="translated">Добавлены похожие на C99 сложные функции.Они могут быть использованы,если вы хотите реализовать переносные расширения C.Так как мы до сих пор поддерживаем платформы без сложного типа C99,вам нужно ограничиться синтаксисом,совместимым с C90,например:</target>
        </trans-unit>
        <trans-unit id="cf46ba2402ead2c46d226454dffcd7ce5ff43524" translate="yes" xml:space="preserve">
          <source>CFFI</source>
          <target state="translated">CFFI</target>
        </trans-unit>
        <trans-unit id="51aa24adb10c8f416d462fb3a5357dabf3e3fd38" translate="yes" xml:space="preserve">
          <source>CFFI + Numba</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b9f44f432adf98c7d09c95f8b09f92c94663702d" translate="yes" xml:space="preserve">
          <source>CFFI can be used to directly access the functions in &lt;code&gt;include/numpy/random/distributions.h&lt;/code&gt;. Some &amp;ldquo;massaging&amp;rdquo; of the header file is required:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ebba6dc140f09bcbb9638f5bf4b3df884108c2f7" translate="yes" xml:space="preserve">
          <source>CFFI interface</source>
          <target state="translated">интерфейс CFFI</target>
        </trans-unit>
        <trans-unit id="a36da1e151b2b0823e662d5b8eaaa38259edebce" translate="yes" xml:space="preserve">
          <source>CI extended with additional services</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6821c968895aca188636e67b589fcc004a8bbd12" translate="yes" xml:space="preserve">
          <source>CPU arch detection</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1ade62840c85639fb7384a1d18b950f273e9fb48" translate="yes" xml:space="preserve">
          <source>CPU architecture of the platform; only one of the above is defined.</source>
          <target state="translated">Архитектура процессора платформы,определена только одна из вышеперечисленных.</target>
        </trans-unit>
        <trans-unit id="19b3426c923b3e7b1cdee4b651f488f72bf3c78b" translate="yes" xml:space="preserve">
          <source>CXX</source>
          <target state="translated">CXX</target>
        </trans-unit>
        <trans-unit id="c9cddb0fc26555bd7e44c82c30b8dd03f9efdf7e" translate="yes" xml:space="preserve">
          <source>C_CONTIGUOUS / C / CONTIGUOUS</source>
          <target state="translated">C_CONTIGUOUS/C/CONTIGUOUS</target>
        </trans-unit>
        <trans-unit id="0ce3a73aca867f2538f5c735d732291c3a6e377f" translate="yes" xml:space="preserve">
          <source>Caches in &lt;code&gt;np.fft&lt;/code&gt; are now bounded in total size and item count</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f3d5846dd99b124383ff0d457d07594b45e6712e" translate="yes" xml:space="preserve">
          <source>Calculate &lt;code&gt;2**p&lt;/code&gt; for all &lt;code&gt;p&lt;/code&gt; in the input array.</source>
          <target state="translated">Вычислите &lt;code&gt;2**p&lt;/code&gt; для всех &lt;code&gt;p&lt;/code&gt; во входном массиве.</target>
        </trans-unit>
        <trans-unit id="250bbdf8f96508ded0e2419aede1c85ce8e60f69" translate="yes" xml:space="preserve">
          <source>Calculate &lt;code&gt;2**x&lt;/code&gt; for all elements in the array.</source>
          <target state="translated">Вычислите &lt;code&gt;2**x&lt;/code&gt; для всех элементов в массиве.</target>
        </trans-unit>
        <trans-unit id="80c054468bb32b1733a38bd9e500e3c7e2410c60" translate="yes" xml:space="preserve">
          <source>Calculate &lt;code&gt;exp(x) - 1&lt;/code&gt; for all elements in the array.</source>
          <target state="translated">Вычислите &lt;code&gt;exp(x) - 1&lt;/code&gt; для всех элементов в массиве.</target>
        </trans-unit>
        <trans-unit id="897a0bcc51e675340eb8de452d794c61bbe86ad4" translate="yes" xml:space="preserve">
          <source>Calculate the absolute value element-wise.</source>
          <target state="translated">Вычислите абсолютное значение по элементам.</target>
        </trans-unit>
        <trans-unit id="52d855325ad8b8ba2e5f03ed06faa393dd2b3c5d" translate="yes" xml:space="preserve">
          <source>Calculate the exponential of all elements in the input array.</source>
          <target state="translated">Вычислить экспоненту всех элементов входного массива.</target>
        </trans-unit>
        <trans-unit id="a3dc7bdd6edd5fbaf2d2ff0fab2c5a4b13186ce0" translate="yes" xml:space="preserve">
          <source>Calculate the generalized inverse of a matrix using its singular-value decomposition (SVD) and including all &lt;em&gt;large&lt;/em&gt; singular values.</source>
          <target state="translated">Вычислить обобщенную обратную матрицу, используя ее разложение по сингулярным числам (SVD) и включая все &lt;em&gt;большие&lt;/em&gt; сингулярные значения.</target>
        </trans-unit>
        <trans-unit id="4b25208e5ebec1248ee411c25859b5c2fd7bb09b" translate="yes" xml:space="preserve">
          <source>Calculate the n-th discrete difference along given axis.</source>
          <target state="translated">Вычислите n-ую дискретную разность вдоль данной оси.</target>
        </trans-unit>
        <trans-unit id="42cb44e98b4304fa793f5c2a54298181fdecfa02" translate="yes" xml:space="preserve">
          <source>Calculate the n-th discrete difference along the given axis.</source>
          <target state="translated">Вычислите n-ую дискретную разность вдоль данной оси.</target>
        </trans-unit>
        <trans-unit id="1c03f8fb0f5af1d1f5a42484860a4bc9ada64002" translate="yes" xml:space="preserve">
          <source>Calculate the standard deviation of the non-NaN values.</source>
          <target state="translated">Рассчитайте среднеквадратическое отклонение значений,отличных от NaN.</target>
        </trans-unit>
        <trans-unit id="f8c757cfbde7655c0c48030d0cc0f2a47e05c8b1" translate="yes" xml:space="preserve">
          <source>Calculate the standard deviation of these values.</source>
          <target state="translated">Рассчитайте стандартное отклонение этих значений.</target>
        </trans-unit>
        <trans-unit id="7c1b58f3d94fc67cd514e1570aa6b12719e32b56" translate="yes" xml:space="preserve">
          <source>Calculate the t statistic, setting the ddof parameter to the unbiased value so the divisor in the standard deviation will be degrees of freedom, N-1.</source>
          <target state="translated">Вычислите t-статистику,установив параметр ddof в несмещенное значение,чтобы делителем в стандартном отклонении были степени свободы,N-1.</target>
        </trans-unit>
        <trans-unit id="a8acd54a675004438176e793d314e80390eec770" translate="yes" xml:space="preserve">
          <source>Calculates &lt;code&gt;1/x&lt;/code&gt;.</source>
          <target state="translated">Вычисляет &lt;code&gt;1/x&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e5f90663e28e9982e7de271dda336040dea8f7aa" translate="yes" xml:space="preserve">
          <source>Calculates &lt;code&gt;element in test_elements&lt;/code&gt;, broadcasting over &lt;code&gt;element&lt;/code&gt; only.</source>
          <target state="translated">Вычисляет &lt;code&gt;element in test_elements&lt;/code&gt; , транслируя только &lt;code&gt;element&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c2efd3cd9b667cce814af0fcbaac60b64cdcdb35" translate="yes" xml:space="preserve">
          <source>Calculates &lt;code&gt;element in test_elements&lt;/code&gt;, broadcasting over &lt;code&gt;element&lt;/code&gt; only. Returns a boolean array of the same shape as &lt;code&gt;element&lt;/code&gt; that is True where an element of &lt;code&gt;element&lt;/code&gt; is in &lt;code&gt;test_elements&lt;/code&gt; and False otherwise.</source>
          <target state="translated">Вычисляет &lt;code&gt;element in test_elements&lt;/code&gt; , транслируя только &lt;code&gt;element&lt;/code&gt; . Возвращает логический массив той же формы, что и &lt;code&gt;element&lt;/code&gt; , который имеет значение True, если элемент &lt;code&gt;element&lt;/code&gt; находится в &lt;code&gt;test_elements&lt;/code&gt; , и False в противном случае.</target>
        </trans-unit>
        <trans-unit id="74b05ed646884364ea61a52a0d97dd5553fc5db3" translate="yes" xml:space="preserve">
          <source>Calculates &lt;code&gt;log(1 + x)&lt;/code&gt;.</source>
          <target state="translated">Вычисляет &lt;code&gt;log(1 + x)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="793634569b16ddadf09c84f21826d340c4bb186b" translate="yes" xml:space="preserve">
          <source>Calculates &lt;code&gt;log(exp(x1) + exp(x2))&lt;/code&gt;. This function is useful in statistics where the calculated probabilities of events may be so small as to exceed the range of normal floating point numbers. In such cases the logarithm of the calculated probability is stored. This function allows adding probabilities stored in such a fashion.</source>
          <target state="translated">Вычисляет &lt;code&gt;log(exp(x1) + exp(x2))&lt;/code&gt; . Эта функция полезна в статистике, где вычисленные вероятности событий могут быть настолько малы, что выходят за пределы диапазона обычных чисел с плавающей запятой. В таких случаях сохраняется логарифм вычисленной вероятности. Эта функция позволяет складывать сохраненные таким образом вероятности.</target>
        </trans-unit>
        <trans-unit id="55306f441c10b288ef594152ca5bc10ba426774f" translate="yes" xml:space="preserve">
          <source>Calculates &lt;code&gt;log2(2**x1 + 2**x2)&lt;/code&gt;. This function is useful in machine learning when the calculated probabilities of events may be so small as to exceed the range of normal floating point numbers. In such cases the base-2 logarithm of the calculated probability can be used instead. This function allows adding probabilities stored in such a fashion.</source>
          <target state="translated">Вычисляет &lt;code&gt;log2(2**x1 + 2**x2)&lt;/code&gt; . Эта функция полезна в машинном обучении, когда вычисленные вероятности событий могут быть настолько малы, что выходят за пределы диапазона обычных чисел с плавающей запятой. В таких случаях вместо этого можно использовать логарифм по основанию 2 вычисленной вероятности. Эта функция позволяет складывать сохраненные таким образом вероятности.</target>
        </trans-unit>
        <trans-unit id="79b6b61d48a464831755d05e96c5b24edef1de03" translate="yes" xml:space="preserve">
          <source>Calculates which of the given dates are valid days, and which are not.</source>
          <target state="translated">Вычисляет,какие из данных дат являются действительными днями,а какие-нет.</target>
        </trans-unit>
        <trans-unit id="dc6751bd6532a841494c31d2cb271a6c23434bcc" translate="yes" xml:space="preserve">
          <source>Calculation</source>
          <target state="translated">Calculation</target>
        </trans-unit>
        <trans-unit id="05d27dcc239bf9ea22989ad95d110b65fd4d9edb" translate="yes" xml:space="preserve">
          <source>Calculations</source>
          <target state="translated">Calculations</target>
        </trans-unit>
        <trans-unit id="c0b95ddbd1bbdb09cd17ce1c430a7adeedcc6050" translate="yes" xml:space="preserve">
          <source>Calculus</source>
          <target state="translated">Calculus</target>
        </trans-unit>
        <trans-unit id="dde8f3e3d46e069dd8c9fb51c5a6b6c4238ef493" translate="yes" xml:space="preserve">
          <source>Call &lt;a href=&quot;generator#numpy.random.default_rng&quot;&gt;&lt;code&gt;default_rng&lt;/code&gt;&lt;/a&gt; to get a new instance of a &lt;a href=&quot;generator#numpy.random.Generator&quot;&gt;&lt;code&gt;Generator&lt;/code&gt;&lt;/a&gt;, then call its methods to obtain samples from different distributions. By default, &lt;a href=&quot;generator#numpy.random.Generator&quot;&gt;&lt;code&gt;Generator&lt;/code&gt;&lt;/a&gt; uses bits provided by &lt;a href=&quot;bit_generators/pcg64#numpy.random.PCG64&quot;&gt;&lt;code&gt;PCG64&lt;/code&gt;&lt;/a&gt; which has better statistical properties than the legacy &lt;a href=&quot;bit_generators/mt19937#numpy.random.MT19937&quot;&gt;&lt;code&gt;MT19937&lt;/code&gt;&lt;/a&gt; used in &lt;a href=&quot;legacy#numpy.random.RandomState&quot;&gt;&lt;code&gt;RandomState&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f6b577a771e51546f11b433f88a97b7ef013570b" translate="yes" xml:space="preserve">
          <source>Call &lt;a href=&quot;https://docs.python.org/dev/c-api/type.html#c.PyType_Ready&quot;&gt;&lt;code&gt;PyType_Ready&lt;/code&gt;&lt;/a&gt; (&amp;lt;pointer_to_new_type&amp;gt;). If this function returns a negative number, a failure occurred and the type is not initialized. Otherwise, the type is ready to be used. It is generally important to place a reference to the new type into the module dictionary so it can be accessed from Python.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bdf175380f108b91b68b35d6cba860e239285fd3" translate="yes" xml:space="preserve">
          <source>Call &lt;code&gt;str.istitle&lt;/code&gt; element-wise.</source>
          <target state="translated">Вызов &lt;code&gt;str.istitle&lt;/code&gt; поэлементно.</target>
        </trans-unit>
        <trans-unit id="d5bbdd4afe52a03da69e768bb6350617fd2c2fe8" translate="yes" xml:space="preserve">
          <source>Call &lt;code&gt;str.isupper&lt;/code&gt; element-wise.</source>
          <target state="translated">Вызов &lt;code&gt;str.isupper&lt;/code&gt; поэлементно.</target>
        </trans-unit>
        <trans-unit id="204bec18a0c758d4b92300d3ccfda2d8f2d41215" translate="yes" xml:space="preserve">
          <source>Call &lt;code&gt;str.lower&lt;/code&gt; element-wise.</source>
          <target state="translated">Вызов &lt;code&gt;str.lower&lt;/code&gt; поэлементно.</target>
        </trans-unit>
        <trans-unit id="eef266f410d282365eeaef6f6541415ad4d67585" translate="yes" xml:space="preserve">
          <source>Call self as a function.</source>
          <target state="translated">Называй себя функцией.</target>
        </trans-unit>
        <trans-unit id="0ce1402d6ef90df67129aaaa626b1d87878afa44" translate="yes" xml:space="preserve">
          <source>Call the function from the library with the ctypes arguments.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ef89b4e2063118e4442bf0889dbb070ab91c9c17" translate="yes" xml:space="preserve">
          <source>Call-back arguments</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8829f8e417cdbefc80e5f0018c56210ff40f16e6" translate="yes" xml:space="preserve">
          <source>Callback upon error:</source>
          <target state="translated">Обратный вызов при ошибке:</target>
        </trans-unit>
        <trans-unit id="095dfbda4be2a7c23470a2f28679717480fb723d" translate="yes" xml:space="preserve">
          <source>Calling &lt;code&gt;add&lt;/code&gt; then yields:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="11e32184ce81143ebb10c040c662152029bc28ed" translate="yes" xml:space="preserve">
          <source>Calling C-code from Python can result in Python crashes if you are not careful. None of the approaches in this chapter are immune. You have to know something about the way data is handled by both NumPy and by the third-party library being used.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7a6041d361fd40eeecfd3b783ee25742eac73334" translate="yes" xml:space="preserve">
          <source>Calling f2py from Python</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="627187305b11d0b40ef311920110ebf177a808de" translate="yes" xml:space="preserve">
          <source>Calling other compiled libraries from Python</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="45cc60363cb41b7ffde77fcffd01fb398e2212aa" translate="yes" xml:space="preserve">
          <source>Calling the function</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f76a0fdbe900eef0f77fc7210a232c0754707b8b" translate="yes" xml:space="preserve">
          <source>Calls &lt;a href=&quot;https://docs.python.org/dev/library/stdtypes.html#str.encode&quot;&gt;&lt;code&gt;str.encode&lt;/code&gt;&lt;/a&gt; element-wise.</source>
          <target state="translated">Вызывает &lt;a href=&quot;https://docs.python.org/dev/library/stdtypes.html#str.encode&quot;&gt; &lt;code&gt;str.encode&lt;/code&gt; &lt;/a&gt; поэлементно.</target>
        </trans-unit>
        <trans-unit id="5ddbcf21043a5f353f23ca4baba1595ba4a4c298" translate="yes" xml:space="preserve">
          <source>Calls &lt;code&gt;str.capitalize&lt;/code&gt; element-wise.</source>
          <target state="translated">Вызовы &lt;code&gt;str.capitalize&lt;/code&gt; поэлементно.</target>
        </trans-unit>
        <trans-unit id="fac61b23fdecfba854b4b4efab7777fd152b2cd6" translate="yes" xml:space="preserve">
          <source>Calls &lt;code&gt;str.center&lt;/code&gt; element-wise.</source>
          <target state="translated">Вызывает &lt;code&gt;str.center&lt;/code&gt; поэлементно.</target>
        </trans-unit>
        <trans-unit id="1314c79da136d136fb6bbb829ea41b9418ad141a" translate="yes" xml:space="preserve">
          <source>Calls &lt;code&gt;str.count&lt;/code&gt; element-wise.</source>
          <target state="translated">Вызывает &lt;code&gt;str.count&lt;/code&gt; поэлементно.</target>
        </trans-unit>
        <trans-unit id="4bdc60efe7fe548bd722d4044bc214b413e9d4dd" translate="yes" xml:space="preserve">
          <source>Calls &lt;code&gt;str.decode&lt;/code&gt; element-wise.</source>
          <target state="translated">Вызывает &lt;code&gt;str.decode&lt;/code&gt; поэлементно.</target>
        </trans-unit>
        <trans-unit id="065d9a82f4f8e8be749e189a1fda4fbbe3abbe4a" translate="yes" xml:space="preserve">
          <source>Calls &lt;code&gt;str.encode&lt;/code&gt; element-wise.</source>
          <target state="translated">Вызывает &lt;code&gt;str.encode&lt;/code&gt; поэлементно.</target>
        </trans-unit>
        <trans-unit id="c1788f723cdc513a1b82d19f6d756a8fad670e36" translate="yes" xml:space="preserve">
          <source>Calls &lt;code&gt;str.endswith&lt;/code&gt; element-wise.</source>
          <target state="translated">Вызывает &lt;code&gt;str.endswith&lt;/code&gt; поэлементно.</target>
        </trans-unit>
        <trans-unit id="1506c8828926db71b8ee1e63d0d49604826d93cb" translate="yes" xml:space="preserve">
          <source>Calls &lt;code&gt;str.expandtabs&lt;/code&gt; element-wise.</source>
          <target state="translated">Вызывает &lt;code&gt;str.expandtabs&lt;/code&gt; поэлементно.</target>
        </trans-unit>
        <trans-unit id="3c7293ade2e69f10fa46947bf34f0b6e9553dda9" translate="yes" xml:space="preserve">
          <source>Calls &lt;code&gt;str.find&lt;/code&gt; element-wise.</source>
          <target state="translated">Вызывает &lt;code&gt;str.find&lt;/code&gt; поэлементно.</target>
        </trans-unit>
        <trans-unit id="467102d858ecdef3b85b56bdb57ad38edb734308" translate="yes" xml:space="preserve">
          <source>Calls &lt;code&gt;str.index&lt;/code&gt; element-wise.</source>
          <target state="translated">Вызывает &lt;code&gt;str.index&lt;/code&gt; поэлементно.</target>
        </trans-unit>
        <trans-unit id="9028b020672a2d11380a1f6acfdb2435aab492c0" translate="yes" xml:space="preserve">
          <source>Calls &lt;code&gt;str.isalnum&lt;/code&gt; element-wise.</source>
          <target state="translated">Вызывает &lt;code&gt;str.isalnum&lt;/code&gt; поэлементно.</target>
        </trans-unit>
        <trans-unit id="fd4a785af6221c540650fb70b847d1cefb209fda" translate="yes" xml:space="preserve">
          <source>Calls &lt;code&gt;str.isalpha&lt;/code&gt; element-wise.</source>
          <target state="translated">Вызывает &lt;code&gt;str.isalpha&lt;/code&gt; поэлементно.</target>
        </trans-unit>
        <trans-unit id="656252d18256f4f02da62d1b2291d93d00dda7e4" translate="yes" xml:space="preserve">
          <source>Calls &lt;code&gt;str.isdigit&lt;/code&gt; element-wise.</source>
          <target state="translated">Вызывает &lt;code&gt;str.isdigit&lt;/code&gt; поэлементно.</target>
        </trans-unit>
        <trans-unit id="2a85e1b04f3860c701786f2c9eabf6a753b661de" translate="yes" xml:space="preserve">
          <source>Calls &lt;code&gt;str.islower&lt;/code&gt; element-wise.</source>
          <target state="translated">Вызывает &lt;code&gt;str.islower&lt;/code&gt; поэлементно.</target>
        </trans-unit>
        <trans-unit id="2bb68da644aa463ff4c1c36c7d9b40bf8b8f64bc" translate="yes" xml:space="preserve">
          <source>Calls &lt;code&gt;str.isspace&lt;/code&gt; element-wise.</source>
          <target state="translated">Вызывает &lt;code&gt;str.isspace&lt;/code&gt; поэлементно.</target>
        </trans-unit>
        <trans-unit id="741c3bea47e11f849d26dfea4d3d3a40eab3c129" translate="yes" xml:space="preserve">
          <source>Calls &lt;code&gt;str.join&lt;/code&gt; element-wise.</source>
          <target state="translated">Вызывает &lt;code&gt;str.join&lt;/code&gt; поэлементно.</target>
        </trans-unit>
        <trans-unit id="a819deb9a44d524ac6731b6be53354ba9f42a375" translate="yes" xml:space="preserve">
          <source>Calls &lt;code&gt;str.ljust&lt;/code&gt; element-wise.</source>
          <target state="translated">Звонит &lt;code&gt;str.ljust&lt;/code&gt; поэлементно.</target>
        </trans-unit>
        <trans-unit id="be80be96a9f5d678d3f84ce0ae913fd30691c166" translate="yes" xml:space="preserve">
          <source>Calls &lt;code&gt;str.lstrip&lt;/code&gt; element-wise.</source>
          <target state="translated">Вызывает &lt;code&gt;str.lstrip&lt;/code&gt; поэлементно.</target>
        </trans-unit>
        <trans-unit id="3a06e70f258111f5ace799d0136012a728b9986f" translate="yes" xml:space="preserve">
          <source>Calls &lt;code&gt;str.partition&lt;/code&gt; element-wise.</source>
          <target state="translated">Вызывает &lt;code&gt;str.partition&lt;/code&gt; поэлементно.</target>
        </trans-unit>
        <trans-unit id="887a34caef57804ead86c1cf188ead795251b5a4" translate="yes" xml:space="preserve">
          <source>Calls &lt;code&gt;str.replace&lt;/code&gt; element-wise.</source>
          <target state="translated">Вызывает &lt;code&gt;str.replace&lt;/code&gt; поэлементно.</target>
        </trans-unit>
        <trans-unit id="05d90debebac8c8e525b11c833af03b1809c3595" translate="yes" xml:space="preserve">
          <source>Calls &lt;code&gt;str.rfind&lt;/code&gt; element-wise.</source>
          <target state="translated">Вызывает &lt;code&gt;str.rfind&lt;/code&gt; поэлементно.</target>
        </trans-unit>
        <trans-unit id="89bfa6c81f923111ab3ece5d1065bb7a8b18172a" translate="yes" xml:space="preserve">
          <source>Calls &lt;code&gt;str.rindex&lt;/code&gt; element-wise.</source>
          <target state="translated">Вызывает &lt;code&gt;str.rindex&lt;/code&gt; поэлементно.</target>
        </trans-unit>
        <trans-unit id="55188dcc2c20e117f83220adcd9445f8940213ba" translate="yes" xml:space="preserve">
          <source>Calls &lt;code&gt;str.rjust&lt;/code&gt; element-wise.</source>
          <target state="translated">Вызывает &lt;code&gt;str.rjust&lt;/code&gt; поэлементно.</target>
        </trans-unit>
        <trans-unit id="19291c82bbc252e358dcd5efe30bebd4ce3f47fc" translate="yes" xml:space="preserve">
          <source>Calls &lt;code&gt;str.rpartition&lt;/code&gt; element-wise.</source>
          <target state="translated">Вызывает &lt;code&gt;str.rpartition&lt;/code&gt; поэлементно.</target>
        </trans-unit>
        <trans-unit id="e30544ad22292a0898136208de2fa5fc236f97f4" translate="yes" xml:space="preserve">
          <source>Calls &lt;code&gt;str.rsplit&lt;/code&gt; element-wise.</source>
          <target state="translated">Вызывает &lt;code&gt;str.rsplit&lt;/code&gt; поэлементно.</target>
        </trans-unit>
        <trans-unit id="bf3f027903bcb2fa17e73f1d36c8446f531dbe5a" translate="yes" xml:space="preserve">
          <source>Calls &lt;code&gt;str.rstrip&lt;/code&gt; element-wise.</source>
          <target state="translated">Вызывает &lt;code&gt;str.rstrip&lt;/code&gt; поэлементно.</target>
        </trans-unit>
        <trans-unit id="739adfdb756eef5e48a6b103e3600e5bc999cb7a" translate="yes" xml:space="preserve">
          <source>Calls &lt;code&gt;str.split&lt;/code&gt; element-wise.</source>
          <target state="translated">Звонки &lt;code&gt;str.split&lt;/code&gt; поэлементно.</target>
        </trans-unit>
        <trans-unit id="b5e51ab4b44c03ea14d792300213b602772f9ea6" translate="yes" xml:space="preserve">
          <source>Calls &lt;code&gt;str.splitlines&lt;/code&gt; element-wise.</source>
          <target state="translated">Вызывает &lt;code&gt;str.splitlines&lt;/code&gt; поэлементно.</target>
        </trans-unit>
        <trans-unit id="6c953fe5d272055ef6fdc5b65d12465c629e73e4" translate="yes" xml:space="preserve">
          <source>Calls &lt;code&gt;str.startswith&lt;/code&gt; element-wise.</source>
          <target state="translated">Вызывает &lt;code&gt;str.startswith&lt;/code&gt; поэлементно.</target>
        </trans-unit>
        <trans-unit id="1827eeaf19d2fb7a578c669a1d5307476f133fcd" translate="yes" xml:space="preserve">
          <source>Calls &lt;code&gt;str.strip&lt;/code&gt; element-wise.</source>
          <target state="translated">Вызывает &lt;code&gt;str.strip&lt;/code&gt; поэлементно.</target>
        </trans-unit>
        <trans-unit id="274bbb89ddefdfebcf8c0b98e05e899bc5eb9615" translate="yes" xml:space="preserve">
          <source>Calls &lt;code&gt;str.swapcase&lt;/code&gt; element-wise.</source>
          <target state="translated">Вызывает &lt;code&gt;str.swapcase&lt;/code&gt; поэлементно.</target>
        </trans-unit>
        <trans-unit id="2bc28d6c4e67250d03ac5f9ac2fcd548d24d6297" translate="yes" xml:space="preserve">
          <source>Calls &lt;code&gt;str.title&lt;/code&gt; element-wise.</source>
          <target state="translated">Вызывает &lt;code&gt;str.title&lt;/code&gt; поэлементно.</target>
        </trans-unit>
        <trans-unit id="91315156a48280f48729eabe9ec7862779adc8d2" translate="yes" xml:space="preserve">
          <source>Calls &lt;code&gt;str.translate&lt;/code&gt; element-wise.</source>
          <target state="translated">Вызывает &lt;code&gt;str.translate&lt;/code&gt; поэлементно.</target>
        </trans-unit>
        <trans-unit id="2440d757fee8b2705315ead5568e7af63f8335a3" translate="yes" xml:space="preserve">
          <source>Calls &lt;code&gt;str.upper&lt;/code&gt; element-wise.</source>
          <target state="translated">Вызывает &lt;code&gt;str.upper&lt;/code&gt; поэлементно.</target>
        </trans-unit>
        <trans-unit id="691e1fcbb97130e6abfe067256904d840bcc927b" translate="yes" xml:space="preserve">
          <source>Calls &lt;code&gt;str.zfill&lt;/code&gt; element-wise.</source>
          <target state="translated">Вызывает &lt;code&gt;str.zfill&lt;/code&gt; поэлементно.</target>
        </trans-unit>
        <trans-unit id="9c60fe9461b9d2c89f3c3e872dadf8ad18517837" translate="yes" xml:space="preserve">
          <source>Calls &lt;code&gt;unicode.isdecimal&lt;/code&gt; element-wise.</source>
          <target state="translated">Вызывает &lt;code&gt;unicode.isdecimal&lt;/code&gt; поэлементно.</target>
        </trans-unit>
        <trans-unit id="c6e0a82d42fca087f606e832d63a055b7b362137" translate="yes" xml:space="preserve">
          <source>Calls &lt;code&gt;unicode.isnumeric&lt;/code&gt; element-wise.</source>
          <target state="translated">Вызывает &lt;code&gt;unicode.isnumeric&lt;/code&gt; поэлементно.</target>
        </trans-unit>
        <trans-unit id="79ab673318d7c81b7f76879d7f7e6d0f3ff543f1" translate="yes" xml:space="preserve">
          <source>Can be a local file or a remote URL.</source>
          <target state="translated">Может быть локальным файлом или удаленным URL-адресом.</target>
        </trans-unit>
        <trans-unit id="a90e6085e13ad6ee060ad3eac04d655f92454003" translate="yes" xml:space="preserve">
          <source>Can be read from a filelike stream object instead of an actual file.</source>
          <target state="translated">Может считываться с файлового объекта,а не с фактического файла.</target>
        </trans-unit>
        <trans-unit id="22f6ea93b575f4da64882fc6b779b0f07dc62149" translate="yes" xml:space="preserve">
          <source>Can be scalar or non-scalar. If non-scalar, the resulting filled array should be broadcastable over input array. Default is None.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="07932047b9de074a44eece379f541bd670890cdd" translate="yes" xml:space="preserve">
          <source>Can be used, for example, to add broadcasting to a built-in Python function (see Examples section).</source>
          <target state="translated">Может использоваться,например,для добавления вещания во встроенную функцию Python (см.раздел Примеры).</target>
        </trans-unit>
        <trans-unit id="7139132bf88ca6d9cbbfb32a613254727892bf7e" translate="yes" xml:space="preserve">
          <source>Can represent all NumPy arrays including nested record arrays and object arrays.</source>
          <target state="translated">Может представлять все массивы NumPy,включая вложенные массивы записей и массивы объектов.</target>
        </trans-unit>
        <trans-unit id="f01b544f8ac201079e369764bc5d84163c794bad" translate="yes" xml:space="preserve">
          <source>Can write code in non-standard form which may become obsolete</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="07c566972545483ecb8e809f4eb024c341423ec5" translate="yes" xml:space="preserve">
          <source>Can you reshape an array?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ca09c54bff74a82bae543ebe259f7452ee8c5293" translate="yes" xml:space="preserve">
          <source>Capabilities</source>
          <target state="translated">Capabilities</target>
        </trans-unit>
        <trans-unit id="a058457334819b9647916ad868c25fa88bc97117" translate="yes" xml:space="preserve">
          <source>Cartesian (&amp;lsquo;xy&amp;rsquo;, default) or matrix (&amp;lsquo;ij&amp;rsquo;) indexing of output. See Notes for more details.</source>
          <target state="translated">Декартово ('xy', по умолчанию) или матричное ('ij') индексирование вывода. См. Примечания для более подробной информации.</target>
        </trans-unit>
        <trans-unit id="b5599547be57585d8ed9f9e6e56fb372b94bf366" translate="yes" xml:space="preserve">
          <source>Cash flows (must contain at least one positive and one negative value) or nan is returned. The first value is considered a sunk cost at time zero.</source>
          <target state="translated">Денежные потоки (должны содержать как минимум одно положительное и одно отрицательное значение)или нан возвращаются.Первое значение считается невозвратной стоимостью в момент времени нуля.</target>
        </trans-unit>
        <trans-unit id="4819b90bf3135701e4238f100f5eccaffb4cf77a" translate="yes" xml:space="preserve">
          <source>Cast &lt;code&gt;input&lt;/code&gt; to a &lt;code&gt;PyArrayObject*&lt;/code&gt; if legal, and ensure that it is of type &lt;code&gt;typecode&lt;/code&gt;. If &lt;code&gt;input&lt;/code&gt; cannot be cast, or the &lt;code&gt;typecode&lt;/code&gt; is wrong, set a Python error and return &lt;code&gt;NULL&lt;/code&gt;.</source>
          <target state="translated">Cast &lt;code&gt;input&lt;/code&gt; в &lt;code&gt;PyArrayObject*&lt;/code&gt; если юридическое, и убедитесь , что она имеет тип &lt;code&gt;typecode&lt;/code&gt; . Если &lt;code&gt;input&lt;/code&gt; не может быть приведен или &lt;code&gt;typecode&lt;/code&gt; неправильный, установите ошибку Python и верните &lt;code&gt;NULL&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="66c23409ad11975a171ee62798652be7275d78b9" translate="yes" xml:space="preserve">
          <source>Cast &lt;code&gt;n&lt;/code&gt; elements &lt;code&gt;from&lt;/code&gt; one type &lt;code&gt;to&lt;/code&gt; another. The data to cast from is in a contiguous, correctly-swapped and aligned chunk of memory pointed to by from. The buffer to cast to is also contiguous, correctly-swapped and aligned. The fromarr and toarr arguments should only be used for flexible-element-sized arrays (string, unicode, void).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5da405e72e65e85b0a6ff9fb710530d444100461" translate="yes" xml:space="preserve">
          <source>Cast code: This checks for &amp;ldquo;true&amp;rdquo; alignment, as it does &lt;code&gt;*dst = CASTFUNC(*src)&lt;/code&gt; if aligned. Otherwise, it does &lt;code&gt;memmove(srcval, src); dstval = CASTFUNC(srcval); memmove(dst, dstval)&lt;/code&gt; where dstval/srcval are aligned.</source>
          <target state="translated">Код &lt;code&gt;*dst = CASTFUNC(*src)&lt;/code&gt; : проверяет &amp;laquo;истинное&amp;raquo; выравнивание, как и * dst = CASTFUNC (* src), если оно выровнено. В противном случае будет &lt;code&gt;memmove(srcval, src); dstval = CASTFUNC(srcval); memmove(dst, dstval)&lt;/code&gt; где dstval / srcval выровнены.</target>
        </trans-unit>
        <trans-unit id="4dbf7f264927d9ee6c0c9230f88c1b227f370d7c" translate="yes" xml:space="preserve">
          <source>Cast the elements of the array &lt;em&gt;in&lt;/em&gt; into the array &lt;em&gt;out&lt;/em&gt;. The output array should be writeable, have an integer-multiple of the number of elements in the input array (more than one copy can be placed in out), and have a data type that is one of the builtin types. Returns 0 on success and -1 if an error occurs.</source>
          <target state="translated">Вставьте элементы массива &lt;em&gt;в&lt;/em&gt; массив &lt;em&gt;наружу&lt;/em&gt; . Выходной массив должен быть доступным для записи, иметь целое число, кратное количеству элементов во входном массиве (можно разместить более одной копии), и иметь тип данных, который является одним из встроенных типов. Возвращает 0 в случае успеха и -1 в случае ошибки.</target>
        </trans-unit>
        <trans-unit id="e6a8277578137a1b27ee47f6d99dc6ac5a6c8df7" translate="yes" xml:space="preserve">
          <source>Cast to the desired type, even if it can&amp;rsquo;t be done without losing information.</source>
          <target state="translated">Приведите к желаемому типу, даже если это невозможно сделать без потери информации.</target>
        </trans-unit>
        <trans-unit id="a945bfddda4f16646c0e1e8cf16a394a39e915e6" translate="yes" xml:space="preserve">
          <source>Casting Rules</source>
          <target state="translated">Правила литья</target>
        </trans-unit>
        <trans-unit id="0e43fbb5b95b8e028055445bd4f061de51dc4a06" translate="yes" xml:space="preserve">
          <source>Casting must be done on one or more of the inputs whenever the ufunc does not have a core loop implementation for the input types provided. If an implementation for the input types cannot be found, then the algorithm searches for an implementation with a type signature to which all of the inputs can be cast &amp;ldquo;safely.&amp;rdquo; The first one it finds in its internal list of loops is selected and performed, after all necessary type casting. Recall that internal copies during ufuncs (even for casting) are limited to the size of an internal buffer (which is user settable).</source>
          <target state="translated">Приведение должно выполняться для одного или нескольких входов, когда ufunc не имеет реализации основного цикла для предоставленных типов входных данных. Если реализация для входных типов не может быть найдена, тогда алгоритм ищет реализацию с сигнатурой типа, к которой все входные данные могут быть &amp;laquo;безопасно&amp;raquo; преобразованы. Выбирается и выполняется первая, найденная во внутреннем списке циклов, после всего необходимого преобразования типов. Напомним, что внутренние копии во время ufuncs (даже для приведения) ограничены размером внутреннего буфера (который устанавливается пользователем).</target>
        </trans-unit>
        <trans-unit id="8748cec5513dc9c01c715b723dcb4b372a11fea9" translate="yes" xml:space="preserve">
          <source>Casting scalars</source>
          <target state="translated">Литые скаляры</target>
        </trans-unit>
        <trans-unit id="cbb26092630998f6b4ebb2584d7e63c1ad783481" translate="yes" xml:space="preserve">
          <source>Casting the set to a list gives the expected result:</source>
          <target state="translated">Отбрасывание набора в список дает ожидаемый результат:</target>
        </trans-unit>
        <trans-unit id="3b9cb47a9c04d9f04e8fb247efea4728b9f0825f" translate="yes" xml:space="preserve">
          <source>Casting to allow when changing between datetime units.</source>
          <target state="translated">Литье,чтобы позволить при переходе между единицами даты.</target>
        </trans-unit>
        <trans-unit id="21d50099f4ef7f76fe962077ec52f3b66d36a662" translate="yes" xml:space="preserve">
          <source>Casts a structured array to a new dtype using assignment by field-name.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1b7e02730ebfcc85f5732a8be223fd80563fe083" translate="yes" xml:space="preserve">
          <source>Categories are determined by first checking which of boolean, integer (int/uint), or floating point (float/complex) the maximum kind of all the arrays and the scalars are.</source>
          <target state="translated">Категории определяются путем первой проверки,какой из булевых,целочисленных (int/uint)или с плавающей точкой (float/complex)является максимальным видом всех массивов и скаляров.</target>
        </trans-unit>
        <trans-unit id="3325b57bdda8f0731fcea923488b3e46095663f1" translate="yes" xml:space="preserve">
          <source>Causes the iterator to convert all the operands to a common data type, calculated based on the ufunc type promotion rules. Copying or buffering must be enabled.</source>
          <target state="translated">Заставляет итератор преобразовывать все операнды в общий тип данных,вычисленный на основе правил продвижения типа ufunc.Копирование или буферизация должны быть включены.</target>
        </trans-unit>
        <trans-unit id="f6e47e97b987638e04e1741c9188448c0cda9575" translate="yes" xml:space="preserve">
          <source>Causes the iterator to provide data for &lt;code&gt;op[i]&lt;/code&gt; that is in native byte order, aligned according to the dtype requirements, contiguous, or any combination.</source>
          <target state="translated">Заставляет итератор предоставлять данные для &lt;code&gt;op[i]&lt;/code&gt; которые находятся в собственном порядке байтов, выровнены в соответствии с требованиями dtype, непрерывно или в любой комбинации.</target>
        </trans-unit>
        <trans-unit id="78cd28e519e06a8be731a725d2ee50a3144a0620" translate="yes" xml:space="preserve">
          <source>Causes the iterator to skip iteration of the innermost loop, requiring the user of the iterator to handle it.</source>
          <target state="translated">Заставляет итератор пропускать итерацию самого внутреннего контура,требуя от пользователя итератора обращения с ним.</target>
        </trans-unit>
        <trans-unit id="d748728383297b4bba46340904d34590fd3f0e6c" translate="yes" xml:space="preserve">
          <source>Causes the iterator to store buffering data, and use buffering to satisfy data type, alignment, and byte-order requirements. To buffer an operand, do not specify the &lt;a href=&quot;#c.NPY_ITER_COPY&quot;&gt;&lt;code&gt;NPY_ITER_COPY&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#c.NPY_ITER_UPDATEIFCOPY&quot;&gt;&lt;code&gt;NPY_ITER_UPDATEIFCOPY&lt;/code&gt;&lt;/a&gt; flags, because they will override buffering. Buffering is especially useful for Python code using the iterator, allowing for larger chunks of data at once to amortize the Python interpreter overhead.</source>
          <target state="translated">Заставляет итератор хранить данные буферизации и использовать буферизацию для удовлетворения требований типа данных, выравнивания и порядка байтов. Для буферизации операнда не указывайте флаги &lt;a href=&quot;#c.NPY_ITER_COPY&quot;&gt; &lt;code&gt;NPY_ITER_COPY&lt;/code&gt; &lt;/a&gt; или &lt;a href=&quot;#c.NPY_ITER_UPDATEIFCOPY&quot;&gt; &lt;code&gt;NPY_ITER_UPDATEIFCOPY&lt;/code&gt; &lt;/a&gt; , потому что они переопределяют буферизацию. Буферизация особенно полезна для кода Python с использованием итератора, позволяя обрабатывать большие фрагменты данных одновременно, чтобы снизить накладные расходы интерпретатора Python.</target>
        </trans-unit>
        <trans-unit id="cbe86966ee1567b8621995982683f047543e592a" translate="yes" xml:space="preserve">
          <source>Causes the iterator to track a multi-index. This prevents the iterator from coalescing axes to produce bigger inner loops. If the loop is also not buffered and no index is being tracked (&lt;code&gt;NpyIter_RemoveAxis&lt;/code&gt; can be called), then the iterator size can be &lt;code&gt;-1&lt;/code&gt; to indicate that the iterator is too large. This can happen due to complex broadcasting and will result in errors being created when the setting the iterator range, removing the multi index, or getting the next function. However, it is possible to remove axes again and use the iterator normally if the size is small enough after removal.</source>
          <target state="translated">Заставляет итератор отслеживать мультииндекс. Это предотвращает объединение осей итератора для создания более крупных внутренних циклов. Если цикл также не буферизован и индекс не отслеживается ( можно вызвать &lt;code&gt;NpyIter_RemoveAxis&lt;/code&gt; ), то размер итератора может быть &lt;code&gt;-1&lt;/code&gt; , чтобы указать, что итератор слишком велик. Это может произойти из-за сложной широковещательной передачи и приведет к возникновению ошибок при установке диапазона итератора, удалении мультииндекса или получении следующей функции. Однако можно снова удалить оси и использовать итератор в обычном режиме, если после удаления размер достаточно мал.</target>
        </trans-unit>
        <trans-unit id="a78370684072181888bd07868c0ae200011c6b51" translate="yes" xml:space="preserve">
          <source>Causes the iterator to track a raveled flat index matching C order. This option cannot be used with &lt;a href=&quot;#c.NPY_ITER_F_INDEX&quot;&gt;&lt;code&gt;NPY_ITER_F_INDEX&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Заставляет итератор отслеживать равномерный плоский индекс, соответствующий порядку C. Этот параметр нельзя использовать с &lt;a href=&quot;#c.NPY_ITER_F_INDEX&quot;&gt; &lt;code&gt;NPY_ITER_F_INDEX&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="d09f5eb17dd94e9b8185491d29ffd82541173b9e" translate="yes" xml:space="preserve">
          <source>Causes the iterator to track a raveled flat index matching Fortran order. This option cannot be used with &lt;a href=&quot;#c.NPY_ITER_C_INDEX&quot;&gt;&lt;code&gt;NPY_ITER_C_INDEX&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Заставляет итератор отслеживать равномерный плоский индекс, соответствующий порядку в Фортране. Этот параметр нельзя использовать с &lt;a href=&quot;#c.NPY_ITER_C_INDEX&quot;&gt; &lt;code&gt;NPY_ITER_C_INDEX&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="c373af68347ef344e2a4047a6349667bfbe022fd" translate="yes" xml:space="preserve">
          <source>Chain exceptions to give better error messages for invalid PEP3118 format strings</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c0df50e511723d6385d81becfe6c98c0ca2c5dad" translate="yes" xml:space="preserve">
          <source>Chained array operations, in efficient calculation order, &lt;a href=&quot;numpy.einsum_path#numpy.einsum_path&quot;&gt;&lt;code&gt;numpy.einsum_path&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Связанные операции с массивами в эффективном порядке вычисления, &lt;a href=&quot;numpy.einsum_path#numpy.einsum_path&quot;&gt; &lt;code&gt;numpy.einsum_path&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="d9f53c2498e2f3ad3fca9000468a403dc1def6c7" translate="yes" xml:space="preserve">
          <source>Chained array operations. For more complicated contractions, speed ups might be achieved by repeatedly computing a &amp;lsquo;greedy&amp;rsquo; path or pre-computing the &amp;lsquo;optimal&amp;rsquo; path and repeatedly applying it, using an &lt;a href=&quot;numpy.einsum_path#numpy.einsum_path&quot;&gt;&lt;code&gt;einsum_path&lt;/code&gt;&lt;/a&gt; insertion (since version 1.12.0). Performance improvements can be particularly significant with larger arrays:</source>
          <target state="translated">Связанные операции с массивами. Для более сложных сокращений ускорение может быть достигнуто путем многократного вычисления &amp;laquo;жадного&amp;raquo; пути или предварительного вычисления &amp;laquo;оптимального&amp;raquo; пути и многократного его применения с &lt;a href=&quot;numpy.einsum_path#numpy.einsum_path&quot;&gt; &lt;code&gt;einsum_path&lt;/code&gt; &lt;/a&gt; вставки einsum_path (начиная с версии 1.12.0). Повышение производительности может быть особенно значительным для массивов большего размера:</target>
        </trans-unit>
        <trans-unit id="4b14b1641c23a3ee01fb58fe8633eb893f1634ef" translate="yes" xml:space="preserve">
          <source>Change elements of an array based on conditional and input values.</source>
          <target state="translated">Изменение элементов массива на основе условных и входных значений.</target>
        </trans-unit>
        <trans-unit id="01dcb981588ac5e81e8962905c01357fef0a774b" translate="yes" xml:space="preserve">
          <source>Change output of &lt;code&gt;round&lt;/code&gt; on scalars to be consistent with Python</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="03e304dc68ffb07e8cb055b859df002401eafba4" translate="yes" xml:space="preserve">
          <source>Change shape and size of array in-place.</source>
          <target state="translated">Изменение формы и размера массива на месте.</target>
        </trans-unit>
        <trans-unit id="e18523f3dc9af0b0d781daa5529bbdd8c6b73861" translate="yes" xml:space="preserve">
          <source>Change the byte-ordering information in the array dtype so that it interprets the underlying data as being in a different byte order. This is the role of &lt;code&gt;arr.newbyteorder()&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="51d2004fb81c8f1c875ffbaa2ebee0d486f11763" translate="yes" xml:space="preserve">
          <source>Change the byte-ordering of the underlying data, leaving the dtype interpretation as it was. This is what &lt;code&gt;arr.byteswap()&lt;/code&gt; does.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7c78cf8387f58f6da3c59f8db55e089f69c5453e" translate="yes" xml:space="preserve">
          <source>Change the directory:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1baf38892b5a38369da2ab3d5066a1bc5faa26e9" translate="yes" xml:space="preserve">
          <source>Change the shape of an array without changing its data.</source>
          <target state="translated">Изменение формы массива без изменения его данных.</target>
        </trans-unit>
        <trans-unit id="57cca933dc4ae8712cc751b049a24d49a1cbe977" translate="yes" xml:space="preserve">
          <source>Change the sign of x1 to that of x2, element-wise.</source>
          <target state="translated">Измените знак Х1 на знак Х2,по элементам.</target>
        </trans-unit>
        <trans-unit id="f1fd8269d290cf6173d8944feb182f6867a500ae" translate="yes" xml:space="preserve">
          <source>Change the vector definition of &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; using &lt;code&gt;axisa&lt;/code&gt; and &lt;code&gt;axisb&lt;/code&gt;.</source>
          <target state="translated">Измените определение вектора &lt;code&gt;x&lt;/code&gt; и &lt;code&gt;y&lt;/code&gt; с помощью &lt;code&gt;axisa&lt;/code&gt; и &lt;code&gt;axisb&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0e76bac75a93f40062500cfe4d6d4594aea2a414" translate="yes" xml:space="preserve">
          <source>Changed in version 1.10.0: Earlier NumPy versions required dfnum &amp;gt; 1.</source>
          <target state="translated">Изменено в версии 1.10.0: более ранние версии NumPy требовали dfnum&amp;gt; 1.</target>
        </trans-unit>
        <trans-unit id="9e03441147d9c9bca84c6633efe853d678690f6f" translate="yes" xml:space="preserve">
          <source>Changed in version 1.11.0: When a single column has to be read it is possible to use an integer instead of a tuple. E.g &lt;code&gt;usecols = 3&lt;/code&gt; reads the fourth column the same way as &lt;code&gt;usecols = (3,)&lt;/code&gt; would.</source>
          <target state="translated">Изменено в версии 1.11.0: когда необходимо прочитать один столбец, можно использовать целое число вместо кортежа. Например, &lt;code&gt;usecols = 3&lt;/code&gt; читает четвертый столбец так же, как &lt;code&gt;usecols = (3,)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4240cc617a1809505e609f22132a15e64d1b8364" translate="yes" xml:space="preserve">
          <source>Changed in version 1.13.0: Previously, the default was documented to be -1, but that was in error. At some future date, the default will change to -1, as originally intended. Until then, the axis should be given explicitly when &lt;code&gt;arr.ndim &amp;gt; 1&lt;/code&gt;, to avoid a FutureWarning.</source>
          <target state="translated">Изменено в версии 1.13.0: раньше задокументировано значение по умолчанию -1, но это было ошибкой. Когда-нибудь в будущем значение по умолчанию изменится на -1, как и предполагалось изначально. До тех пор ось должна указываться явно, когда &lt;code&gt;arr.ndim &amp;gt; 1&lt;/code&gt; , чтобы избежать FutureWarning.</target>
        </trans-unit>
        <trans-unit id="7cf5dc6a75318b20c4a1e296708ff3954da61899" translate="yes" xml:space="preserve">
          <source>Changed in version 1.13.0: Tuples are allowed for keyword argument.</source>
          <target state="translated">Изменено в версии 1.13.0:Разрешены кортежи для аргументации ключевых слов.</target>
        </trans-unit>
        <trans-unit id="8369be3972dcfca939d8870350211ef461655917" translate="yes" xml:space="preserve">
          <source>Changed in version 1.14.0: Earlier NumPy versions required dfnum &amp;gt; 1.</source>
          <target state="translated">Изменено в версии 1.14.0: более ранние версии NumPy требовали dfnum&amp;gt; 1.</target>
        </trans-unit>
        <trans-unit id="90df01afcc61c5a576cbe17f8aa7128ba6554b30" translate="yes" xml:space="preserve">
          <source>Changed in version 1.14.0: If not set, a FutureWarning is given. The previous default of &lt;code&gt;-1&lt;/code&gt; will use the machine precision as &lt;code&gt;rcond&lt;/code&gt; parameter, the new default will use the machine precision times &lt;code&gt;max(M, N)&lt;/code&gt;. To silence the warning and use the new default, use &lt;code&gt;rcond=None&lt;/code&gt;, to keep using the old behavior, use &lt;code&gt;rcond=-1&lt;/code&gt;.</source>
          <target state="translated">Изменено в версии 1.14.0: Если не установлено, выдается FutureWarning. Предыдущее значение по умолчанию, &lt;code&gt;rcond&lt;/code&gt; &lt;code&gt;-1&lt;/code&gt; , будет использовать машинную точность в качестве параметра rcond , новое значение по умолчанию будет использовать &lt;code&gt;max(M, N)&lt;/code&gt; время машинной точности (M, N) . Чтобы отключить предупреждение и использовать новое значение по умолчанию, используйте &lt;code&gt;rcond=None&lt;/code&gt; , чтобы сохранить прежнее поведение, используйте &lt;code&gt;rcond=-1&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1d2839d7d3bf87e0e23f5c67fc8d1ab0fe0551fd" translate="yes" xml:space="preserve">
          <source>Changed in version 1.14: Broadcasted against the stack of matrices</source>
          <target state="translated">Изменено в версии 1.14:Выпущено в эфир против стопки матриц</target>
        </trans-unit>
        <trans-unit id="348ee8de383634f48f0728f5bfaf909f0982c324" translate="yes" xml:space="preserve">
          <source>Changed in version 1.14: Can now operate on stacks of matrices</source>
          <target state="translated">Изменено в версии 1.14:теперь может работать со стопками матриц</target>
        </trans-unit>
        <trans-unit id="05cf1c5d8f1269a7f5fa5c6cc3fc095bf8055509" translate="yes" xml:space="preserve">
          <source>Changed in version 1.15.0.: The &amp;lsquo;stable&amp;rsquo; option was added.</source>
          <target state="translated">Изменено в версии 1.15.0 .: добавлена ​​опция &amp;laquo;стабильный&amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="0e6fb4664107937e52dcdbc13917b49d6b44f05c" translate="yes" xml:space="preserve">
          <source>Changed in version 1.15.0: DeprecationWarnings are actually emitted.</source>
          <target state="translated">Изменено в версии 1.15.0:ИсключениеПредупреждение действительно излучается.</target>
        </trans-unit>
        <trans-unit id="5e3b221df91333bee6b9f5792109b32e7e70567b" translate="yes" xml:space="preserve">
          <source>Changed in version 1.15.0: None and tuples of axes are supported</source>
          <target state="translated">Изменено в версии 1.15.0:Нет и кортежи осей не поддерживаются</target>
        </trans-unit>
        <trans-unit id="0a28aad38084ea97b7bc4890436cdfc6bcade503" translate="yes" xml:space="preserve">
          <source>Changed in version 1.16.0: A list of args may also be provided.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cf547a772cebc0e7496a5c76e49a36dae75a2d98" translate="yes" xml:space="preserve">
          <source>Changed in version 1.16.0: Accept str as well as bytes</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="83d75b7f177288265577e6765abc146d2cecb0e7" translate="yes" xml:space="preserve">
          <source>Changed in version 1.16.0: Non-scalar &lt;code&gt;start&lt;/code&gt; and &lt;code&gt;stop&lt;/code&gt; are now supported.</source>
          <target state="translated">Изменено в версии 1.16.0: теперь поддерживаются нескалярные &lt;code&gt;start&lt;/code&gt; и &lt;code&gt;stop&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="25985fe044545f9478af4af504ffd04c8801c6e6" translate="yes" xml:space="preserve">
          <source>Changed in version 1.16.0: Renamed from &lt;code&gt;dims&lt;/code&gt; to &lt;code&gt;shape&lt;/code&gt;.</source>
          <target state="translated">Изменено в версии 1.16.0: Переименован от &lt;code&gt;dims&lt;/code&gt; до &lt;code&gt;shape&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="eef53483993b5fb29b126ef19278ead520adb6f9" translate="yes" xml:space="preserve">
          <source>Changed in version 1.16.3: Made default False in response to CVE-2019-6446.</source>
          <target state="translated">Изменено в версии 1.16.3:Сделано по умолчанию False в ответ на CVE-2019-6446.</target>
        </trans-unit>
        <trans-unit id="ff4dc328009aefab6de678232e1061e9bf30fb2d" translate="yes" xml:space="preserve">
          <source>Changed in version 1.17.0: &lt;a href=&quot;#numpy.errstate&quot;&gt;&lt;code&gt;errstate&lt;/code&gt;&lt;/a&gt; is also usable as a function decorator, saving a level of indentation if an entire function is wrapped. See &lt;a href=&quot;https://docs.python.org/dev/library/contextlib.html#contextlib.ContextDecorator&quot;&gt;&lt;code&gt;contextlib.ContextDecorator&lt;/code&gt;&lt;/a&gt; for more information.</source>
          <target state="translated">Изменено в версии 1.17.0: &lt;a href=&quot;#numpy.errstate&quot;&gt; &lt;code&gt;errstate&lt;/code&gt; &lt;/a&gt; также можно использовать в качестве декоратора функций, сохраняя уровень отступа, если оборачивается вся функция. См. &lt;a href=&quot;https://docs.python.org/dev/library/contextlib.html#contextlib.ContextDecorator&quot;&gt; &lt;code&gt;contextlib.ContextDecorator&lt;/code&gt; &lt;/a&gt; для получения дополнительной информации.</target>
        </trans-unit>
        <trans-unit id="af2d1032fe2cc2a8c7b8fc21250999bf723a2b20" translate="yes" xml:space="preserve">
          <source>Changed in version 1.17.0: &lt;a href=&quot;https://docs.python.org/dev/library/pathlib.html#pathlib.Path&quot;&gt;&lt;code&gt;pathlib.Path&lt;/code&gt;&lt;/a&gt; objects are now accepted.</source>
          <target state="translated">Изменено в версии 1.17.0: теперь принимаются объекты &lt;a href=&quot;https://docs.python.org/dev/library/pathlib.html#pathlib.Path&quot;&gt; &lt;code&gt;pathlib.Path&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="61efb6f136dc51708e975673488296290e1e421b" translate="yes" xml:space="preserve">
          <source>Changed in version 1.17.0: Casting between a simple data type and a structured one is possible only for &amp;ldquo;unsafe&amp;rdquo; casting. Casting to multiple fields is allowed, but casting from multiple fields is not.</source>
          <target state="translated">Изменено в версии 1.17.0: Приведение между простым типом данных и структурированным возможно только для &amp;laquo;небезопасного&amp;raquo; приведения. Приведение в несколько полей разрешено, но не из нескольких полей.</target>
        </trans-unit>
        <trans-unit id="c5df5da3e381a86308cf0cc4eb048541e70b1ac9" translate="yes" xml:space="preserve">
          <source>Changed in version 1.18.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6b373f41a3cb0188f798a19ca6f87e39244e1215" translate="yes" xml:space="preserve">
          <source>Changed in version 1.18.0.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="89bfac0c966e6918532c5056416ce8c139bac641" translate="yes" xml:space="preserve">
          <source>Changed in version 1.18.0: A mix of scalars and zero-dimensional arrays now produces a type capable of holding the scalar value. Previously priority was given to the dtype of the arrays.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="19b458380fddb4902dee94f09f396c9a282f453d" translate="yes" xml:space="preserve">
          <source>Changed in version 1.18.0: A tuple of axes is now supported. Out of range axes as described above are now forbidden and raise an &lt;code&gt;AxisError&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dccd9958f73e96cdb6901cdbf8dca831295ef22c" translate="yes" xml:space="preserve">
          <source>Changed in version 1.19.0: Boolean indices are now treated as a mask of elements to remove, rather than being cast to the integers 0 and 1.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7c9406124c2f89ed955f1ed4fdf79269cd807fab" translate="yes" xml:space="preserve">
          <source>Changed in version 1.8.0: Broadcasting rules apply, see the &lt;a href=&quot;../routines.linalg#module-numpy.linalg&quot;&gt;&lt;code&gt;numpy.linalg&lt;/code&gt;&lt;/a&gt; documentation for details.</source>
          <target state="translated">Изменено в версии 1.8.0: применяются правила вещания, подробности см. &lt;a href=&quot;../routines.linalg#module-numpy.linalg&quot;&gt; &lt;code&gt;numpy.linalg&lt;/code&gt; &lt;/a&gt; документации numpy.linalg .</target>
        </trans-unit>
        <trans-unit id="442c1fd3d41745a2d4ec1e84a3657676ca62838e" translate="yes" xml:space="preserve">
          <source>Changed in version 1.9.0: A tuple of axes is supported</source>
          <target state="translated">Изменено в версии 1.9.0:Поддерживается кортеж осей</target>
        </trans-unit>
        <trans-unit id="73bab6415b0560ad9f839326ef0b98ed7906af98" translate="yes" xml:space="preserve">
          <source>Changed in version 1.9.0: Casting from numeric to string types in &amp;lsquo;safe&amp;rsquo; casting mode requires that the string dtype length is long enough to store the max integer/float value converted.</source>
          <target state="translated">Изменено в версии 1.9.0: преобразование числовых типов в строковые в &amp;laquo;безопасном&amp;raquo; режиме преобразования требует, чтобы длина строки dtype была достаточно длинной для хранения максимального преобразованного целочисленного / плавающего значения.</target>
        </trans-unit>
        <trans-unit id="8adc0d706675beb5229fbd846a1b85c2cfcca190" translate="yes" xml:space="preserve">
          <source>Changed in version 1.9.0: Casting from numeric to string types in &amp;lsquo;safe&amp;rsquo; casting mode requires that the string dtype length is long enough to store the maximum integer/float value converted.</source>
          <target state="translated">Изменено в версии 1.9.0: преобразование числовых типов в строковые в &amp;laquo;безопасном&amp;raquo; режиме преобразования требует, чтобы длина строки dtype была достаточно длинной для хранения максимального преобразованного значения типа integer / float.</target>
        </trans-unit>
        <trans-unit id="5a255433707dd5f70c7a4be8e1821141fe49e182" translate="yes" xml:space="preserve">
          <source>Changed in version 1.9: 1-D and 0-D cases are allowed.</source>
          <target state="translated">Изменения в версии 1.9:разрешены случаи 1-D и 0-D.</target>
        </trans-unit>
        <trans-unit id="d65dbc46ba0aa85c5054bdc349b97636497c7d97" translate="yes" xml:space="preserve">
          <source>Changed in version NumPy: 1.19</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="090cd0a4c0bdb025d9d082643a59f937e13d144c" translate="yes" xml:space="preserve">
          <source>Changed random variate stream from &lt;code&gt;numpy.random.Generator.dirichlet&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6c789b1f25e20176df4d2eb365c2cf355c4a907a" translate="yes" xml:space="preserve">
          <source>Changed random variate stream from &lt;code&gt;numpy.random.Generator.integers&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="164b3d4809f98d0458414f1bf9cf3c9dcba16bb5" translate="yes" xml:space="preserve">
          <source>Changelog</source>
          <target state="translated">Changelog</target>
        </trans-unit>
        <trans-unit id="8aa57de6dce6ee1c35c6aba7426503281876b258" translate="yes" xml:space="preserve">
          <source>Changes</source>
          <target state="translated">Changes</target>
        </trans-unit>
        <trans-unit id="d447e3c0af8f91b0b6d56c2803ffc2d885c25ac6" translate="yes" xml:space="preserve">
          <source>Changes are also made in all fields and sub-arrays of the array data type.</source>
          <target state="translated">Изменения также вносятся во все поля и подмассивы типа данных массива.</target>
        </trans-unit>
        <trans-unit id="d5c8653ebb3c65244702565331c9f825090ef108" translate="yes" xml:space="preserve">
          <source>Changes are also made in all fields and sub-arrays of the data type.</source>
          <target state="translated">Изменения также вносятся во все поля и подмассивы типа данных.</target>
        </trans-unit>
        <trans-unit id="988d6dcf1558a60cf9e3df8c88bfbf9aa6476a76" translate="yes" xml:space="preserve">
          <source>Changes elements of an array based on conditional and input values.</source>
          <target state="translated">Изменяет элементы массива на основе условных и входных значений.</target>
        </trans-unit>
        <trans-unit id="2285dbb1d294a01028b75412567462886684b25a" translate="yes" xml:space="preserve">
          <source>Changes that have been marked for this release must be backported to the maintenance/1.14.x branch.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="11f7d423e4a6c5aafe601b11f0668f2b9c2f00fa" translate="yes" xml:space="preserve">
          <source>Changes the variable used when printing &lt;code&gt;p&lt;/code&gt; from &lt;code&gt;x&lt;/code&gt; to &lt;a href=&quot;numpy.poly1d.variable#numpy.poly1d.variable&quot;&gt;&lt;code&gt;variable&lt;/code&gt;&lt;/a&gt; (see Examples).</source>
          <target state="translated">Изменяет переменную, используемую при печати &lt;code&gt;p&lt;/code&gt; , с &lt;code&gt;x&lt;/code&gt; на &lt;a href=&quot;numpy.poly1d.variable#numpy.poly1d.variable&quot;&gt; &lt;code&gt;variable&lt;/code&gt; &lt;/a&gt; (см. Примеры).</target>
        </trans-unit>
        <trans-unit id="79ec3dbe3c422f3862e5d024b983cec2214e99ca" translate="yes" xml:space="preserve">
          <source>Changes to &lt;code&gt;PyArray_GetDTypeTransferFunction&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a6b7a5b4726b415eac4533ff4c785ffd43ff58e3" translate="yes" xml:space="preserve">
          <source>Changes with NumPy 1.11</source>
          <target state="translated">Изменения с NumPy 1.11</target>
        </trans-unit>
        <trans-unit id="f88e590a9d42082459bee2897052e8478444520a" translate="yes" xml:space="preserve">
          <source>Changing array shape</source>
          <target state="translated">Изменение формы массива</target>
        </trans-unit>
        <trans-unit id="d83babf52902d360c4710e39052681b9926c27c0" translate="yes" xml:space="preserve">
          <source>Changing byte ordering</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bb5d57bb97464b7a41e90965a34fd558225f91df" translate="yes" xml:space="preserve">
          <source>Changing kind of array</source>
          <target state="translated">Изменение вида массива</target>
        </trans-unit>
        <trans-unit id="4dac00a1fdb9bc9e870465fcb8ac48e7a6f41092" translate="yes" xml:space="preserve">
          <source>Changing number of dimensions</source>
          <target state="translated">Изменение количества размеров</target>
        </trans-unit>
        <trans-unit id="26a89ebf1c1d895edaaec0f680290afde6188baf" translate="yes" xml:space="preserve">
          <source>Changing the number of dimensions</source>
          <target state="translated">Изменение количества размеров</target>
        </trans-unit>
        <trans-unit id="659708d4116763fca54f546304717111fc0dcdbc" translate="yes" xml:space="preserve">
          <source>Changing the shape</source>
          <target state="translated">Изменение формы</target>
        </trans-unit>
        <trans-unit id="7d5cb72a6a27b93f3d464005b1595158876ad637" translate="yes" xml:space="preserve">
          <source>Changing the shape of an array</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="472ea4d678f10230e80354665e55d5162f57e4eb" translate="yes" xml:space="preserve">
          <source>Character arrays (&lt;code&gt;numpy.char&lt;/code&gt;)</source>
          <target state="translated">Массивы символов ( &lt;code&gt;numpy.char&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="c77510e827185d4da42fdcbd8730a318064afdff" translate="yes" xml:space="preserve">
          <source>Character arrays (numpy.char)</source>
          <target state="translated">Массивы символов (numpy.char)</target>
        </trans-unit>
        <trans-unit id="92c1e393951a713a4c1c2df5523a5b76ef600358" translate="yes" xml:space="preserve">
          <source>Character code</source>
          <target state="translated">Код символа</target>
        </trans-unit>
        <trans-unit id="ba3973797ea212e06b4bd3f28ecf46f8274e1229" translate="yes" xml:space="preserve">
          <source>Character(s) used in replacement of white spaces in the variables names. By default, use a &amp;lsquo;_&amp;rsquo;.</source>
          <target state="translated">Символ (ы), используемый для замены пробелов в именах переменных. По умолчанию используйте &quot;_&quot;.</target>
        </trans-unit>
        <trans-unit id="5c50aa40fe135ae872479f3d463481aa7c8705fa" translate="yes" xml:space="preserve">
          <source>Charles Harris</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="faf08e2ed05138df0c2fc73c7cd9c35b89b1b4ee" translate="yes" xml:space="preserve">
          <source>Chebyshev</source>
          <target state="translated">Chebyshev</target>
        </trans-unit>
        <trans-unit id="ea61b1323fc64a9bb8d86a6aadc2fcb486ca4493" translate="yes" xml:space="preserve">
          <source>Chebyshev (class in numpy.polynomial.chebyshev)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b08808430b344bf934ff595f268dd7b3c9767d8c" translate="yes" xml:space="preserve">
          <source>Chebyshev Class</source>
          <target state="translated">Чебышевский класс</target>
        </trans-unit>
        <trans-unit id="c805e26af7ca174190c79364ad41f4463c143779" translate="yes" xml:space="preserve">
          <source>Chebyshev Module (&lt;code&gt;numpy.polynomial.chebyshev&lt;/code&gt;)</source>
          <target state="translated">Модуль Чебышева ( &lt;code&gt;numpy.polynomial.chebyshev&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="43b2dcb73cb4875580862bf8c8dd1ada4c4da4c6" translate="yes" xml:space="preserve">
          <source>Chebyshev Module (numpy.polynomial.chebyshev)</source>
          <target state="translated">Чебышевский модуль (нумпи.полиномиальный.чебышев)</target>
        </trans-unit>
        <trans-unit id="2b074447d5337b1acd99539f1f78bf706c34ad9f" translate="yes" xml:space="preserve">
          <source>Chebyshev Series (&lt;code&gt;numpy.polynomial.chebyshev&lt;/code&gt;)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4a4e1fdfb1973afb318ee463fd302dbf6eb373c9" translate="yes" xml:space="preserve">
          <source>Chebyshev Series (numpy.polynomial.chebyshev)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0efbe54789bc84b8d4e58d69167610bd2675854f" translate="yes" xml:space="preserve">
          <source>Chebyshev coefficients in order of increasing degree, i.e., &lt;code&gt;(1, 2, 3)&lt;/code&gt; gives &lt;code&gt;1*T_0(x) + 2*T_1(x) + 3*T_2(x)&lt;/code&gt;.</source>
          <target state="translated">Коэффициенты Чебышева в порядке возрастания степени, то есть &lt;code&gt;(1, 2, 3)&lt;/code&gt; дает &lt;code&gt;1*T_0(x) + 2*T_1(x) + 3*T_2(x)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="cda36d3a5a7c1cf749fe8552f3ece2e37c1bde96" translate="yes" xml:space="preserve">
          <source>Chebyshev coefficients of the interpolating series ordered from low to high.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="96032d11ffc294810d816c812b7d22b436c23b79" translate="yes" xml:space="preserve">
          <source>Chebyshev coefficients ordered from low to high. If &lt;code&gt;y&lt;/code&gt; was 2-D, the coefficients for the data in column k of &lt;code&gt;y&lt;/code&gt; are in column &lt;code&gt;k&lt;/code&gt;.</source>
          <target state="translated">Коэффициенты Чебышева упорядочены по возрастанию. Если &lt;code&gt;y&lt;/code&gt; было 2-D, коэффициенты для данных в столбце k &lt;code&gt;y&lt;/code&gt; находятся в столбце &lt;code&gt;k&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="78471d8e84581a3113228c58d00d8316306213cc" translate="yes" xml:space="preserve">
          <source>Chebyshev points of the first kind.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="97b5ebecc93143ab3bacdf5e10cda1de1af56a39" translate="yes" xml:space="preserve">
          <source>Chebyshev points of the second kind.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1e63eba3c512c100441a580822bf3dee3fdc84ed" translate="yes" xml:space="preserve">
          <source>Chebyshev series</source>
          <target state="translated">чебышевская серия</target>
        </trans-unit>
        <trans-unit id="f8c02252eba6ff12458afafb159b20cecff7478a" translate="yes" xml:space="preserve">
          <source>Chebyshev series of power.</source>
          <target state="translated">Чебышевская серия власти.</target>
        </trans-unit>
        <trans-unit id="8a0ba9e6152e6c1500bb9491398112d62215acf4" translate="yes" xml:space="preserve">
          <source>Chebyshev series of the derivative.</source>
          <target state="translated">Чебышевская серия производной.</target>
        </trans-unit>
        <trans-unit id="4f2d57204da6b30aece47fb6efed1a7b8e11e6b0" translate="yes" xml:space="preserve">
          <source>Chebyshev series whose graph is a straight line.</source>
          <target state="translated">Чебышевский ряд,график которого представляет собой прямую линию.</target>
        </trans-unit>
        <trans-unit id="95aa0918943d1236cc6d32e54d1344d9d0be39c1" translate="yes" xml:space="preserve">
          <source>Chebyshev weight function.</source>
          <target state="translated">Весовая функция Чебышева.</target>
        </trans-unit>
        <trans-unit id="b18292f75bb94b7b116770748f5215372e100826" translate="yes" xml:space="preserve">
          <source>Chebyshev.__call__()</source>
          <target state="translated">Chebyshev.__call__()</target>
        </trans-unit>
        <trans-unit id="1bacc9adbf511d1e41a349b356ba0145d6ee7946" translate="yes" xml:space="preserve">
          <source>Chebyshev.basis()</source>
          <target state="translated">Chebyshev.basis()</target>
        </trans-unit>
        <trans-unit id="188210acd7ec982c8646fa316466c45a976f83f2" translate="yes" xml:space="preserve">
          <source>Chebyshev.cast()</source>
          <target state="translated">Chebyshev.cast()</target>
        </trans-unit>
        <trans-unit id="639e56acd1352c9b5b503ed1496fdb9a5d07c0c0" translate="yes" xml:space="preserve">
          <source>Chebyshev.convert()</source>
          <target state="translated">Chebyshev.convert()</target>
        </trans-unit>
        <trans-unit id="11392591347c8480770728aa505b563eccfa5f1d" translate="yes" xml:space="preserve">
          <source>Chebyshev.copy()</source>
          <target state="translated">Chebyshev.copy()</target>
        </trans-unit>
        <trans-unit id="41611d32208cae6870074acedaa6fe221b1b3446" translate="yes" xml:space="preserve">
          <source>Chebyshev.cutdeg()</source>
          <target state="translated">Chebyshev.cutdeg()</target>
        </trans-unit>
        <trans-unit id="8789ce0a4c5068fdfe534918cc2e90fdad042cd3" translate="yes" xml:space="preserve">
          <source>Chebyshev.degree()</source>
          <target state="translated">Chebyshev.degree()</target>
        </trans-unit>
        <trans-unit id="c6481905857e646a6d9c66a8532da7a6334a6377" translate="yes" xml:space="preserve">
          <source>Chebyshev.deriv()</source>
          <target state="translated">Chebyshev.deriv()</target>
        </trans-unit>
        <trans-unit id="6291088b6f8cbfecdb12bf2bdad126fa6f8f1e75" translate="yes" xml:space="preserve">
          <source>Chebyshev.domain</source>
          <target state="translated">Chebyshev.domain</target>
        </trans-unit>
        <trans-unit id="dd41304fdf8df9e37b5816500b41e22e66c61815" translate="yes" xml:space="preserve">
          <source>Chebyshev.fit()</source>
          <target state="translated">Chebyshev.fit()</target>
        </trans-unit>
        <trans-unit id="e4926f0eed8819f61f1604cce384a57795e1eabf" translate="yes" xml:space="preserve">
          <source>Chebyshev.fromroots()</source>
          <target state="translated">Chebyshev.fromroots()</target>
        </trans-unit>
        <trans-unit id="70d84e9f4f420d528a16ab4c0ba4755a5af5e65c" translate="yes" xml:space="preserve">
          <source>Chebyshev.has_samecoef()</source>
          <target state="translated">Chebyshev.has_samecoef()</target>
        </trans-unit>
        <trans-unit id="119c3a01c7179401c8123c868c9643da34d59174" translate="yes" xml:space="preserve">
          <source>Chebyshev.has_samedomain()</source>
          <target state="translated">Chebyshev.has_samedomain()</target>
        </trans-unit>
        <trans-unit id="1d9bea3b85c40da6ce150efb52fc340072577178" translate="yes" xml:space="preserve">
          <source>Chebyshev.has_sametype()</source>
          <target state="translated">Chebyshev.has_sametype()</target>
        </trans-unit>
        <trans-unit id="21b9443d56e25c8c9434c2048384c54825cbad75" translate="yes" xml:space="preserve">
          <source>Chebyshev.has_samewindow()</source>
          <target state="translated">Chebyshev.has_samewindow()</target>
        </trans-unit>
        <trans-unit id="f72f56cc281db3fc06403b01e30cee59ef5f1b34" translate="yes" xml:space="preserve">
          <source>Chebyshev.identity()</source>
          <target state="translated">Chebyshev.identity()</target>
        </trans-unit>
        <trans-unit id="4320540c12f7d006eb6f49d8596f1304f5f9b17f" translate="yes" xml:space="preserve">
          <source>Chebyshev.integ()</source>
          <target state="translated">Chebyshev.integ()</target>
        </trans-unit>
        <trans-unit id="c6cc890aac4433ddc758056a7a1ec57ab680d9dd" translate="yes" xml:space="preserve">
          <source>Chebyshev.interpolate()</source>
          <target state="translated">Chebyshev.interpolate()</target>
        </trans-unit>
        <trans-unit id="7c5cc657b6a0749c5b79e78f062d99b7bfa79e2e" translate="yes" xml:space="preserve">
          <source>Chebyshev.linspace()</source>
          <target state="translated">Chebyshev.linspace()</target>
        </trans-unit>
        <trans-unit id="318403bb4b0c9579e1e22548291a889f9ceb1ac1" translate="yes" xml:space="preserve">
          <source>Chebyshev.mapparms()</source>
          <target state="translated">Chebyshev.mapparms()</target>
        </trans-unit>
        <trans-unit id="e3d230253c27dda3445e4aef41453767831a496b" translate="yes" xml:space="preserve">
          <source>Chebyshev.roots()</source>
          <target state="translated">Chebyshev.roots()</target>
        </trans-unit>
        <trans-unit id="a90771ff29f5d5fd6c72cd284a6221aaeee66dbc" translate="yes" xml:space="preserve">
          <source>Chebyshev.trim()</source>
          <target state="translated">Chebyshev.trim()</target>
        </trans-unit>
        <trans-unit id="5b40364d3cb3cca7f44236a76dfee86aa086098b" translate="yes" xml:space="preserve">
          <source>Chebyshev.truncate()</source>
          <target state="translated">Chebyshev.truncate()</target>
        </trans-unit>
        <trans-unit id="fa3b88952bbad94e7ad3a8b4bc8351fab6c23f70" translate="yes" xml:space="preserve">
          <source>Check Environment Variables</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0f1c2f66e836ebaf2af3cc3e88ba49176e5fc5ef" translate="yes" xml:space="preserve">
          <source>Check deprecations</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="68b29a44de315b426add922aecd8f169abef4bb9" translate="yes" xml:space="preserve">
          <source>Check for a complex type or an array of complex numbers.</source>
          <target state="translated">Проверьте тип комплекса или массив комплексных чисел.</target>
        </trans-unit>
        <trans-unit id="4bce08324cf028acd33defa95adda2d8f712ca10" translate="yes" xml:space="preserve">
          <source>Check for availability of Fortran 77 compiler.</source>
          <target state="translated">Проверьте наличие компилятора Fortran 77.</target>
        </trans-unit>
        <trans-unit id="8dfb4b491ef798ee13273ce6b905820e38be579c" translate="yes" xml:space="preserve">
          <source>Check for availability of Fortran 90 compiler.</source>
          <target state="translated">Проверьте наличие компилятора Fortran 90.</target>
        </trans-unit>
        <trans-unit id="fc680846edbe0485cdd86c89e2d8ba596476a1dd" translate="yes" xml:space="preserve">
          <source>Check if coefficients match.</source>
          <target state="translated">Проверь,совпадают ли коэффициенты.</target>
        </trans-unit>
        <trans-unit id="d9700aa50368965f26007e9ef6dc12172f836968" translate="yes" xml:space="preserve">
          <source>Check if domains match.</source>
          <target state="translated">Проверьте,совпадают ли домены.</target>
        </trans-unit>
        <trans-unit id="7cda7e0160467a48240d75643f9aa9dd2aa8c3ec" translate="yes" xml:space="preserve">
          <source>Check if the array is Fortran contiguous but &lt;em&gt;not&lt;/em&gt; C contiguous.</source>
          <target state="translated">Проверьте, является ли массив непрерывным в Fortran, но &lt;em&gt;не&lt;/em&gt; непрерывным &lt;em&gt;ли&lt;/em&gt; C.</target>
        </trans-unit>
        <trans-unit id="e7a996762c75a9633231bd44ab99dd3f19880ea7" translate="yes" xml:space="preserve">
          <source>Check if types match.</source>
          <target state="translated">Проверьте,совпадают ли типы.</target>
        </trans-unit>
        <trans-unit id="8d606aa3664f58aff3cd51e12c1f4292532053db" translate="yes" xml:space="preserve">
          <source>Check if windows match.</source>
          <target state="translated">Проверь,совпадают ли окна.</target>
        </trans-unit>
        <trans-unit id="2fb7aaaa0fefc98b63923082fcb9b881a92a1f09" translate="yes" xml:space="preserve">
          <source>Check that all items of arrays differ in at most N Units in the Last Place.</source>
          <target state="translated">Убедитесь,что все элементы массивов отличаются в большинстве N единиц в последнем месте.</target>
        </trans-unit>
        <trans-unit id="85d78e2e46b343ac5d95f102decec7f3757fea05" translate="yes" xml:space="preserve">
          <source>Check that the files in &lt;code&gt;release/installers&lt;/code&gt; have the correct versions, then push the tag upstream:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3d69ccd1b6fed474517fc60eaa1e007186d233c6" translate="yes" xml:space="preserve">
          <source>Check that the release notes are up-to-date.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7eaa6b9db4d409e9c0e745dc239854957e8b786b" translate="yes" xml:space="preserve">
          <source>Check that the solution is correct:</source>
          <target state="translated">Проверьте правильность решения:</target>
        </trans-unit>
        <trans-unit id="5caf476aaa67e250b5bea0e66db1d7432b8de4e4" translate="yes" xml:space="preserve">
          <source>Check that what you are going to push looks sensible:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4b9add170f60f16261046081b4697b7c84e7d44a" translate="yes" xml:space="preserve">
          <source>Check the C API version number</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b474fcfc20997061eb0dbec47b248cfc5e13a11e" translate="yes" xml:space="preserve">
          <source>Check the pre-release button if this is a pre-releases.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="13767ae2c1bd8cf1174421496546f179c6e6b424" translate="yes" xml:space="preserve">
          <source>Check the release notes</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="abd3adad63a405998bb8027f9dd962bdd792cf51" translate="yes" xml:space="preserve">
          <source>Check to see if &lt;code&gt;ary&lt;/code&gt; is Fortran contiguous. If so, return the input pointer and flag it as not a new object. If it is not Fortran contiguous, create a new &lt;code&gt;PyArrayObject*&lt;/code&gt; using the original data, flag it as a new object and return the pointer.</source>
          <target state="translated">Проверьте , чтобы увидеть , если &lt;code&gt;ary&lt;/code&gt; является Fortran смежными. Если да, верните указатель ввода и отметьте его как не новый объект. Если это не непрерывный Fortran, создайте новый &lt;code&gt;PyArrayObject*&lt;/code&gt; используя исходные данные, отметьте его как новый объект и верните указатель.</target>
        </trans-unit>
        <trans-unit id="6deabec9ba29d971d99676bd19f94bb36aab8ebd" translate="yes" xml:space="preserve">
          <source>Check to see if &lt;code&gt;ary&lt;/code&gt; is contiguous. If so, return the input pointer and flag it as not a new object. If it is not contiguous, create a new &lt;code&gt;PyArrayObject*&lt;/code&gt; using the original data, flag it as a new object and return the pointer.</source>
          <target state="translated">Проверьте , чтобы увидеть , если &lt;code&gt;ary&lt;/code&gt; смежный. Если да, верните указатель ввода и отметьте его как не новый объект. Если он не является непрерывным, создайте новый &lt;code&gt;PyArrayObject*&lt;/code&gt; используя исходные данные, отметьте его как новый объект и верните указатель.</target>
        </trans-unit>
        <trans-unit id="7093331a27bd647ef152d8be9e2ae4a45e799c24" translate="yes" xml:space="preserve">
          <source>Check whether iterations are left, and perform a single internal iteration without returning the result.</source>
          <target state="translated">Проверьте,остались ли итерации,и выполните одну внутреннюю итерацию,не возвращая результат.</target>
        </trans-unit>
        <trans-unit id="4144c2e0e789ff4e5b95e42eba75f165eee47a48" translate="yes" xml:space="preserve">
          <source>Check whether iterations are left, and perform a single internal iteration without returning the result. Used in the C-style pattern do-while pattern. For an example, see &lt;a href=&quot;numpy.nditer#numpy.nditer&quot;&gt;&lt;code&gt;nditer&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Проверьте, остались ли итерации, и выполните одну внутреннюю итерацию, не возвращая результат. Используется в шаблоне стиля C. Например, см. &lt;a href=&quot;numpy.nditer#numpy.nditer&quot;&gt; &lt;code&gt;nditer&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="ed69b345e7c215832e51813de9d917baa4aa81d3" translate="yes" xml:space="preserve">
          <source>Check whether other does not equal self elementwise.</source>
          <target state="translated">Проверьте,не равен ли другой по элементам.</target>
        </trans-unit>
        <trans-unit id="a3d82cd61f57b9f18ee0eb4fb316060ba43247d8" translate="yes" xml:space="preserve">
          <source>Check whether other equals self elementwise.</source>
          <target state="translated">Проверьте,равны ли другие элементам.</target>
        </trans-unit>
        <trans-unit id="434cdb1d625c09ab1050578e35a57522602ea24b" translate="yes" xml:space="preserve">
          <source>Checking the API Version</source>
          <target state="translated">Проверка версии API</target>
        </trans-unit>
        <trans-unit id="938faf2c9d435685fe655f2c37238cf2efba6e4c" translate="yes" xml:space="preserve">
          <source>Checking whether two arrays share memory is NP-complete, and runtime may increase exponentially in the number of dimensions. Hence, &lt;code&gt;max_work&lt;/code&gt; should generally be set to a finite number, as it is possible to construct examples that take extremely long to run:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3d5c81d84347f45939c3f87f353382248652d10c" translate="yes" xml:space="preserve">
          <source>Checkout master and forward port the documentation changes:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2399d5909395b34e8a1bce7efc3302c9102efa33" translate="yes" xml:space="preserve">
          <source>Checkout the branch for the release, make sure it is up to date, and clean the repository:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="283049748626c9020e205907bb7476f70c9b37e7" translate="yes" xml:space="preserve">
          <source>Checks to see whether this is the first time the elements of the specified reduction operand which the iterator points at are being seen for the first time. The function returns a reasonable answer for reduction operands and when buffering is disabled. The answer may be incorrect for buffered non-reduction operands.</source>
          <target state="translated">Проверяет,не видны ли впервые элементы заданного операнда редукции,на которые указывает итератор.Функция возвращает разумный ответ для операндов уменьшения и при отключенной буферизации.Ответ может быть неверным для буферизованных не уменьшающих операндов.</target>
        </trans-unit>
        <trans-unit id="aa157d59451a76fbaaa96b55717e70ff4070a919" translate="yes" xml:space="preserve">
          <source>Chhikara, Raj S., and Folks, J. Leroy, &amp;ldquo;The Inverse Gaussian Distribution: Theory : Methodology, and Applications&amp;rdquo;, CRC Press, 1988.</source>
          <target state="translated">Чикара, Радж С., Фолкс, Дж. Лерой, &amp;laquo;Обратное гауссовское распределение: теория: методология и приложения&amp;raquo;, CRC Press, 1988.</target>
        </trans-unit>
        <trans-unit id="fdf0f4fddeb5edfe094f89b612af6bf23fbbf5d9" translate="yes" xml:space="preserve">
          <source>Child &lt;a href=&quot;bit_generators/generated/numpy.random.seedsequence#numpy.random.SeedSequence&quot;&gt;&lt;code&gt;SeedSequence&lt;/code&gt;&lt;/a&gt; objects can also spawn to make grandchildren, and so on. Each &lt;a href=&quot;bit_generators/generated/numpy.random.seedsequence#numpy.random.SeedSequence&quot;&gt;&lt;code&gt;SeedSequence&lt;/code&gt;&lt;/a&gt; has its position in the tree of spawned &lt;a href=&quot;bit_generators/generated/numpy.random.seedsequence#numpy.random.SeedSequence&quot;&gt;&lt;code&gt;SeedSequence&lt;/code&gt;&lt;/a&gt; objects mixed in with the user-provided seed to generate independent (with very high probability) streams.</source>
          <target state="translated">Дочерние объекты &lt;a href=&quot;bit_generators/generated/numpy.random.seedsequence#numpy.random.SeedSequence&quot;&gt; &lt;code&gt;SeedSequence&lt;/code&gt; &lt;/a&gt; также могут создаваться для создания внуков и т. Д. Каждая &lt;a href=&quot;bit_generators/generated/numpy.random.seedsequence#numpy.random.SeedSequence&quot;&gt; &lt;code&gt;SeedSequence&lt;/code&gt; &lt;/a&gt; занимает свою позицию в дереве порожденных объектов &lt;a href=&quot;bit_generators/generated/numpy.random.seedsequence#numpy.random.SeedSequence&quot;&gt; &lt;code&gt;SeedSequence&lt;/code&gt; ,&lt;/a&gt; смешанных с предоставленным пользователем начальным значением, чтобы генерировать независимые (с очень высокой вероятностью) потоки.</target>
        </trans-unit>
        <trans-unit id="3a10cdc107364498984b83536b7e81520a19b878" translate="yes" xml:space="preserve">
          <source>Choice arrays. &lt;code&gt;a&lt;/code&gt; and all of the choices must be broadcastable to the same shape. If &lt;code&gt;choices&lt;/code&gt; is itself an array (not recommended), then its outermost dimension (i.e., the one corresponding to &lt;code&gt;choices.shape[0]&lt;/code&gt;) is taken as defining the &amp;ldquo;sequence&amp;rdquo;.</source>
          <target state="translated">Выбор массивов. &lt;code&gt;a&lt;/code&gt; и все варианты должны транслироваться в одну и ту же фигуру. Если &lt;code&gt;choices&lt;/code&gt; сам по себе является массивом (не рекомендуется), то его самое внешнее измерение (т. &lt;code&gt;choices.shape[0]&lt;/code&gt; Соответствующее choices.shape [0] ) считается определяющим &amp;laquo;последовательность&amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="5ad7147824c2ea94d6560122c459caa4f4c34051" translate="yes" xml:space="preserve">
          <source>Choice arrays. The index array and all of the choices should be broadcastable to the same shape.</source>
          <target state="translated">Массивы выбора.Массив индексов и все варианты выбора должны иметь одинаковую форму.</target>
        </trans-unit>
        <trans-unit id="dd2f912583e24992ccf957c7cba350640486480d" translate="yes" xml:space="preserve">
          <source>Choices in brackets, default first when optional.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2767cec7ad20032475822095cbe0813732009259" translate="yes" xml:space="preserve">
          <source>Cholesky decompose a banded Hermitian positive-definite matrix.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="71912e57e25688eeffa7fea1751238fb822cd096" translate="yes" xml:space="preserve">
          <source>Cholesky decomposition of a matrix, to use in &lt;a href=&quot;https://docs.scipy.org/doc/scipy/reference/generated/scipy.linalg.cho_solve.html#scipy.linalg.cho_solve&quot;&gt;&lt;code&gt;scipy.linalg.cho_solve&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3423d9c2caf056a50af1e5e388fbc351b162a74e" translate="yes" xml:space="preserve">
          <source>Cholesky decomposition.</source>
          <target state="translated">Разложение Холесского.</target>
        </trans-unit>
        <trans-unit id="12973bc24b90d6422a6f6089fc22e3ce9dfde18a" translate="yes" xml:space="preserve">
          <source>Choose &lt;code&gt;nsample&lt;/code&gt; items at random without replacement from a collection with &lt;code&gt;N&lt;/code&gt; distinct types. &lt;code&gt;N&lt;/code&gt; is the length of &lt;code&gt;colors&lt;/code&gt;, and the values in &lt;code&gt;colors&lt;/code&gt; are the number of occurrences of that type in the collection. The total number of items in the collection is &lt;code&gt;sum(colors)&lt;/code&gt;. Each random variate generated by this function is a vector of length &lt;code&gt;N&lt;/code&gt; holding the counts of the different types that occurred in the &lt;code&gt;nsample&lt;/code&gt; items.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2ca2864418456f81d23c002bcfa240f2d8fca295" translate="yes" xml:space="preserve">
          <source>Choose five random numbers from the set of five evenly-spaced numbers between 0 and 2.5, inclusive (&lt;em&gt;i.e.&lt;/em&gt;, from the set</source>
          <target state="translated">Выберите пять случайных чисел из набора пяти равномерно распределенных чисел от 0 до 2,5 включительно ( &lt;em&gt;т. Е.&lt;/em&gt; Из набора</target>
        </trans-unit>
        <trans-unit id="35c9a25e2ab923acd6164ad4d06282c1e090295d" translate="yes" xml:space="preserve">
          <source>Choose the type of path. If a tuple is provided, the second argument is assumed to be the maximum intermediate size created. If only a single argument is provided the largest input or output array size is used as a maximum intermediate size.</source>
          <target state="translated">Выберите тип пути.Если предоставляется кортеж,то вторым аргументом считается максимальный промежуточный созданный размер.Если указан только один аргумент,то в качестве максимального промежуточного размера используется максимальный размер входного или выходного массива.</target>
        </trans-unit>
        <trans-unit id="d477c0a201a1ecd6208acd5e9d6a705b45b36661" translate="yes" xml:space="preserve">
          <source>Choosing the data type</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fd3c5dfb5fbf5ecce869e29e990a70ecfaa87d5e" translate="yes" xml:space="preserve">
          <source>Choosing the fortran compiler</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6410e1ff6dea4bdf660fd03e09261c2e8c92a4a7" translate="yes" xml:space="preserve">
          <source>Christian Kleiber, Samuel Kotz, &amp;ldquo;Statistical size distributions in economics and actuarial sciences&amp;rdquo;, Wiley, 2003.</source>
          <target state="translated">Кристиан Кляйбер, Самуэль Коц, &amp;laquo;Статистические распределения размеров в экономике и актуарных науках&amp;raquo;, Wiley, 2003.</target>
        </trans-unit>
        <trans-unit id="16460b81f71899d57eec8f9481e7178ad88e85b9" translate="yes" xml:space="preserve">
          <source>Chuck Harris</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="699bc38ae6b089e1e0d8975a9f6a7f01d31c2f18" translate="yes" xml:space="preserve">
          <source>Circular padding. Outside bounds values will be as if the array was repeated. For example, for the array [1, 2, 3, 4], x[-2] will be 3, x[-2] will be 4, x[4] will be 1, x[5] will be 2, etc&amp;hellip;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eedc46b2680ee864ce515307f6a3ce30df0bb9e4" translate="yes" xml:space="preserve">
          <source>Cite the relevant literature, e.g. &lt;a href=&quot;#ree6d1ec14498-1&quot; id=&quot;id4&quot;&gt;[1]&lt;/a&gt;. You may also cite these references in the notes section above.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1e1a4f85c2ba4fe59c5c1669b393d40791072c87" translate="yes" xml:space="preserve">
          <source>Class docstring</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e799166bb71b4dde11ab28b58f6eff13ee75f067" translate="yes" xml:space="preserve">
          <source>Class for one-dimensional polynomials.</source>
          <target state="translated">Класс для одномерных полиномов.</target>
        </trans-unit>
        <trans-unit id="141f83ee32f213c3c3e30b940039c0256ca45642" translate="yes" xml:space="preserve">
          <source>Class from which most (all?) numpy scalar types are derived. For consistency, exposes the same API as &lt;a href=&quot;numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;ndarray&lt;/code&gt;&lt;/a&gt;, despite many consequent attributes being either &amp;ldquo;get-only,&amp;rdquo; or completely irrelevant. This is the class from which it is strongly suggested users should derive custom scalar types.</source>
          <target state="translated">Класс, от которого происходит большинство (всех?) Скалярных типов. Для согласованности предоставляет тот же API, что и &lt;a href=&quot;numpy.ndarray#numpy.ndarray&quot;&gt; &lt;code&gt;ndarray&lt;/code&gt; &lt;/a&gt; , несмотря на то, что многие последующие атрибуты являются либо &amp;laquo; доступными только для получения&amp;raquo;, либо полностью нерелевантными. Это класс, от которого пользователям настоятельно рекомендуется наследовать настраиваемые скалярные типы.</target>
        </trans-unit>
        <trans-unit id="f3a9c0c7155c7f2627130b00e8664e0c47570c98" translate="yes" xml:space="preserve">
          <source>Class generic exists solely to derive numpy scalars from, and possesses, albeit unimplemented, all the attributes of the ndarray class so as to provide a uniform API.</source>
          <target state="translated">Класс generic существует исключительно для получения числовых скаляров и обладает,хотя и не реализованными,всеми атрибутами класса ndarray,чтобы обеспечить единый API.</target>
        </trans-unit>
        <trans-unit id="50af8b2f53e369e6ce37192f4f707fa498a94b5e" translate="yes" xml:space="preserve">
          <source>Class instance.</source>
          <target state="translated">Классная инстанция.</target>
        </trans-unit>
        <trans-unit id="2785358c74196dd17652dd76c2cb1f0e3a27dcf4" translate="yes" xml:space="preserve">
          <source>Class of the underlying data (read-only).</source>
          <target state="translated">Класс исходных данных (только для чтения).</target>
        </trans-unit>
        <trans-unit id="631eda8579e2970ff77106029d682f1124ccd882" translate="yes" xml:space="preserve">
          <source>Class to convert formats, names, titles description to a dtype.</source>
          <target state="translated">Класс для преобразования форматов,имен,описания заголовков в d-тип.</target>
        </trans-unit>
        <trans-unit id="70956031e8aba40d5608418084c786b47da059e0" translate="yes" xml:space="preserve">
          <source>Class whose methods to decorate.</source>
          <target state="translated">Класс,чьи методы украшения.</target>
        </trans-unit>
        <trans-unit id="ed1846afee3be21521286932b99e2aeae9e6414a" translate="yes" xml:space="preserve">
          <source>Classes</source>
          <target state="translated">Classes</target>
        </trans-unit>
        <trans-unit id="94a0e1eeea610589ba223c0aebbf56c35a8d5343" translate="yes" xml:space="preserve">
          <source>Classes (including ndarray subclasses) can override how ufuncs act on them by defining certain special methods. For details, see &lt;a href=&quot;arrays.classes#arrays-classes&quot;&gt;Standard array subclasses&lt;/a&gt;.</source>
          <target state="translated">Классы (включая подклассы ndarray) могут переопределять то, как ufuncs воздействуют на них, определяя определенные специальные методы. Дополнительные сведения см. В разделе &amp;laquo; &lt;a href=&quot;arrays.classes#arrays-classes&quot;&gt;Подклассы стандартных массивов&amp;raquo;&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="39dc77f987229934cc60ecfa0809fc0d18f916fd" translate="yes" xml:space="preserve">
          <source>Classes specifying the information to be printed are defined in the &lt;code&gt;numpy.distutils.system_info&lt;/code&gt; module.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="70c66297b049e0748e33bac4e4aa71b028603811" translate="yes" xml:space="preserve">
          <source>Clear and severe breach actions</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0716551020b700fbc40d6da11a6a973469d6550e" translate="yes" xml:space="preserve">
          <source>Clear the IEEE error flags.</source>
          <target state="translated">Снимите флаги ошибок IEEE.</target>
        </trans-unit>
        <trans-unit id="93188aa17cfb01f09e7b90afbdf16a0d09c57e22" translate="yes" xml:space="preserve">
          <source>Clearly, the signature of &lt;code&gt;fib2.fib&lt;/code&gt; now corresponds to the intention of Fortran subroutine &lt;code&gt;FIB&lt;/code&gt; more closely: given the number &lt;code&gt;n&lt;/code&gt;, &lt;code&gt;fib2.fib&lt;/code&gt; returns the first &lt;code&gt;n&lt;/code&gt; Fibonacci numbers as a NumPy array. Also, the new Python signature &lt;code&gt;fib2.fib&lt;/code&gt; rules out any surprises that we experienced with &lt;code&gt;fib1.fib&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d54d8ffb592fd7551eb0fff09b91b8b03d14a55e" translate="yes" xml:space="preserve">
          <source>Clearly, this is not an expected behaviour. The fact that the above example worked with &lt;code&gt;dtype=float&lt;/code&gt; is considered accidental.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="69cde09c8e5adab6b0a10f29c8e8089827660cd3" translate="yes" xml:space="preserve">
          <source>Clears the floating point status. A pointer to a local variable is passed in to prevent aggressive compiler optimizations from reodering this function call. Returns the previous status mask.</source>
          <target state="translated">Очищает статус с плавающей точкой.Передается указатель на локальную переменную,чтобы предотвратить переопределение вызова этой функции агрессивными оптимизациями компилятора.Возвращает предыдущую маску состояния.</target>
        </trans-unit>
        <trans-unit id="ed1f9109b874431402e7e242d58614b8508e6754" translate="yes" xml:space="preserve">
          <source>Clears the floating point status. A pointer to a local variable is passed in to prevent aggressive compiler optimizations from reordering this function call. Returns the previous status mask.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="85631dab84756553305933ab9884fa05e7033c9b" translate="yes" xml:space="preserve">
          <source>Clears the floating point status. Returns the previous status mask.</source>
          <target state="translated">Очищает статус с плавающей точкой.Возвращает предыдущую маску состояния.</target>
        </trans-unit>
        <trans-unit id="95fd8bb886c035e55cfc935aa6369ec4437d9dba" translate="yes" xml:space="preserve">
          <source>Clears the specified array flags. This function does no validation, and assumes that you know what you&amp;rsquo;re doing.</source>
          <target state="translated">Очищает указанные флаги массива. Эта функция не выполняет проверки и предполагает, что вы знаете, что делаете.</target>
        </trans-unit>
        <trans-unit id="87a966bc3a0e8b49349f2e74d267c1202d21bb69" translate="yes" xml:space="preserve">
          <source>Click on the &amp;lsquo;Admin&amp;rsquo; button, and add anyone else to the repo as a collaborator:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b202685281d47a327156e53f1a2165efd9cbfc91" translate="yes" xml:space="preserve">
          <source>Click on the &lt;em&gt;fork&lt;/em&gt; button:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0259cd63a54e3479014d0b233265a7cb8a0c929d" translate="yes" xml:space="preserve">
          <source>Clip (limit) the values in an array.</source>
          <target state="translated">Клип (ограничение)значений в массиве.</target>
        </trans-unit>
        <trans-unit id="10b5f7285e869f556c319cd6389b16c1806e6590" translate="yes" xml:space="preserve">
          <source>Clipping and rounding</source>
          <target state="translated">Обрезка и закругление</target>
        </trans-unit>
        <trans-unit id="01110fe45ef307b0f0fc59a0a0494616ad2d9d3c" translate="yes" xml:space="preserve">
          <source>Clips an index to the valid range if it is out of bounds.</source>
          <target state="translated">Обрезает индекс до допустимого диапазона,если он находится вне пределов.</target>
        </trans-unit>
        <trans-unit id="179755c100537d42883bc546a8caf3a46a35f567" translate="yes" xml:space="preserve">
          <source>Clone the project to your local computer:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5b64cfe6be1411cd7fe0a76e5fb94142fcfb5262" translate="yes" xml:space="preserve">
          <source>Clone your fork</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="38bf2a1eaa30b34536c51de1b9b8ffd3a598c4f8" translate="yes" xml:space="preserve">
          <source>Clone your fork to the local computer with &lt;code&gt;git clone
https://github.com/your-user-name/numpy.git&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="adac69379a626c2436948a4ef1792c7d719ef929" translate="yes" xml:space="preserve">
          <source>Code</source>
          <target state="translated">Code</target>
        </trans-unit>
        <trans-unit id="62f18e281cfc29d9c7a7fc86dddda134af4ea798" translate="yes" xml:space="preserve">
          <source>Code lay-out</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4cda7c9faa3b5335f012c53a4a45daebecabe9c2" translate="yes" xml:space="preserve">
          <source>Code maintenance and development</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4c6d56aa06140201b957d61e514a687a45637be2" translate="yes" xml:space="preserve">
          <source>Code segment showing the &amp;ldquo;can cast safely&amp;rdquo; table for a 32-bit system.</source>
          <target state="translated">Сегмент кода, показывающий таблицу &amp;laquo;можно безопасно приводить&amp;raquo; для 32-разрядной системы.</target>
        </trans-unit>
        <trans-unit id="6acd82038060af5c738afabbce906304f6a33338" translate="yes" xml:space="preserve">
          <source>Code segment showing the &amp;ldquo;can cast safely&amp;rdquo; table for a 64-bit system. Generally the output depends on the system; your system might result in a different table.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9f6f12146c68ac2d13434f01199bc89b65cb5d95" translate="yes" xml:space="preserve">
          <source>Code structure: one space between keywords like &lt;code&gt;if&lt;/code&gt;, &lt;code&gt;for&lt;/code&gt; and the following left parenthesis; no spaces inside the parenthesis; braces around all &lt;code&gt;if&lt;/code&gt; branches and no statements on the same line as the &lt;code&gt;if&lt;/code&gt;. They should be formatted as shown:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4880c50f2ea2d547641da09b4c0bf604cbaad4e6" translate="yes" xml:space="preserve">
          <source>Coefficient array of the integral.</source>
          <target state="translated">Коэффициентный массив интеграла.</target>
        </trans-unit>
        <trans-unit id="90095bbe595b4717b5f28520d7191bc7b67d082b" translate="yes" xml:space="preserve">
          <source>Coefficient matrix.</source>
          <target state="translated">Коэффициентная матрица.</target>
        </trans-unit>
        <trans-unit id="7ff4e0921ad16edc7282af8e661233be9efdef85" translate="yes" xml:space="preserve">
          <source>Coefficient tensor, of shape &lt;code&gt;b.shape + Q&lt;/code&gt;. &lt;code&gt;Q&lt;/code&gt;, a tuple, equals the shape of that sub-tensor of &lt;code&gt;a&lt;/code&gt; consisting of the appropriate number of its rightmost indices, and must be such that &lt;code&gt;prod(Q) == prod(b.shape)&lt;/code&gt; (in which sense &lt;code&gt;a&lt;/code&gt; is said to be &amp;lsquo;square&amp;rsquo;).</source>
          <target state="translated">Тензор коэффициентов, формы &lt;code&gt;b.shape + Q&lt;/code&gt; . &lt;code&gt;Q&lt;/code&gt; , кортеж, равен форме этого суб-тензора элемента &lt;code&gt;a&lt;/code&gt; , состоящего из соответствующего числа его крайних правых индексов, и должен быть таким, что &lt;code&gt;prod(Q) == prod(b.shape)&lt;/code&gt; (в этом смысле &lt;code&gt;a&lt;/code&gt; называется быть &quot;квадратным&quot;).</target>
        </trans-unit>
        <trans-unit id="6f7d7eca3d654d7516012e0321be8d2b34b3af6d" translate="yes" xml:space="preserve">
          <source>Coefficients, including those equal to zero, of the quotient.</source>
          <target state="translated">Коэффициенты,в том числе равные нулю.</target>
        </trans-unit>
        <trans-unit id="b57ec6a0b2d77f8f2ef4d5e927f014b094bd79db" translate="yes" xml:space="preserve">
          <source>Coefficients, including those equal to zero, of the remainder.</source>
          <target state="translated">Коэффициенты,в том числе равные нулю,из оставшейся части.</target>
        </trans-unit>
        <trans-unit id="3c2fcb20e68435f85b762cfd1d987d2533770ffc" translate="yes" xml:space="preserve">
          <source>Collapsed to a one-dimensional array. See &lt;a href=&quot;reference/generated/numpy.ndarray.flatten#numpy.ndarray.flatten&quot;&gt;&lt;code&gt;numpy.ndarray.flatten&lt;/code&gt;&lt;/a&gt; for details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="41175d152a9f45e2d3d903913dcac5478e50c120" translate="yes" xml:space="preserve">
          <source>Collection of utilities to manipulate structured arrays.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="99b2f68944ffe47fe2c86e737221636b3c8e81e8" translate="yes" xml:space="preserve">
          <source>Column-major order is also known as the Fortran order, as the Fortran programming language uses it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3a433dc0365548604b9b44d97f7bfbf6e88d77aa" translate="yes" xml:space="preserve">
          <source>Combination of &lt;a href=&quot;#c.PyArray_FROM_OF&quot;&gt;&lt;code&gt;PyArray_FROM_OF&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#c.PyArray_FROM_OT&quot;&gt;&lt;code&gt;PyArray_FROM_OT&lt;/code&gt;&lt;/a&gt; allowing both a &lt;em&gt;typenum&lt;/em&gt; and a &lt;em&gt;flags&lt;/em&gt; argument to be provided.</source>
          <target state="translated">Комбинация &lt;a href=&quot;#c.PyArray_FROM_OF&quot;&gt; &lt;code&gt;PyArray_FROM_OF&lt;/code&gt; &lt;/a&gt; и &lt;a href=&quot;#c.PyArray_FROM_OT&quot;&gt; &lt;code&gt;PyArray_FROM_OT&lt;/code&gt; ,&lt;/a&gt; позволяющая указать как &lt;em&gt;тип, так&lt;/em&gt; и аргумент &lt;em&gt;флагов&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="1825a72b8523c42869f6ed18e25b4d98c6db9809" translate="yes" xml:space="preserve">
          <source>Combinations of array flags</source>
          <target state="translated">Комбинации флагов массива</target>
        </trans-unit>
        <trans-unit id="003eeb3cc5852db3801153f1b44bcb67c74144f5" translate="yes" xml:space="preserve">
          <source>Combine the commits &lt;code&gt;2dec1ac&lt;/code&gt;, &lt;code&gt;a815645&lt;/code&gt;, &lt;code&gt;eadc391&lt;/code&gt; into a single one.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="04f619e0125978268f6037fab0f4bee54fa7538a" translate="yes" xml:space="preserve">
          <source>Combine two masks with the &lt;code&gt;logical_or&lt;/code&gt; operator.</source>
          <target state="translated">Объедините две маски с помощью оператора &lt;code&gt;logical_or&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ac4e580a3225536b502c2bf6b739b38d8c6dc235" translate="yes" xml:space="preserve">
          <source>Combining advanced and basic indexing</source>
          <target state="translated">Сочетание передовой и базовой индексации</target>
        </trans-unit>
        <trans-unit id="127ce4975a7080b5ec675c2982d4f6e8310b7283" translate="yes" xml:space="preserve">
          <source>Combining index arrays with slices</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6db9979c1fe0813b3eb2ee3a9a6ae24f7e5faea6" translate="yes" xml:space="preserve">
          <source>Combining multiple Boolean indexing arrays or a Boolean with an integer indexing array can best be understood with the &lt;a href=&quot;generated/numpy.ndarray.nonzero#numpy.ndarray.nonzero&quot;&gt;&lt;code&gt;obj.nonzero()&lt;/code&gt;&lt;/a&gt; analogy. The function &lt;a href=&quot;generated/numpy.ix_#numpy.ix_&quot;&gt;&lt;code&gt;ix_&lt;/code&gt;&lt;/a&gt; also supports boolean arrays and will work without any surprises.</source>
          <target state="translated">Комбинирование нескольких логических массивов индексации или логического значения с целочисленным массивом индексации лучше всего можно понять с &lt;a href=&quot;generated/numpy.ndarray.nonzero#numpy.ndarray.nonzero&quot;&gt; &lt;code&gt;obj.nonzero()&lt;/code&gt; &lt;/a&gt; аналогии с obj.nonzero () . Функция &lt;a href=&quot;generated/numpy.ix_#numpy.ix_&quot;&gt; &lt;code&gt;ix_&lt;/code&gt; &lt;/a&gt; также поддерживает логические массивы и будет работать без каких-либо сюрпризов.</target>
        </trans-unit>
        <trans-unit id="48361d97c401e366adbd5368490fd7ba9e87a2ae" translate="yes" xml:space="preserve">
          <source>Comma Separated Value files (CSV) are widely used (and an export and import option for programs like Excel). There are a number of ways of reading these files in Python. There are CSV functions in Python and functions in pylab (part of matplotlib).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="39a64d591310ffe84aa9b684771a7d278ba716a5" translate="yes" xml:space="preserve">
          <source>Comma delimited file with mixed dtype</source>
          <target state="translated">Файл,разделенный запятыми со смешанным dtype</target>
        </trans-unit>
        <trans-unit id="6a1f5ffc0ab313847c7fd16153c2c1f631a74c7f" translate="yes" xml:space="preserve">
          <source>Command &lt;code&gt;f2py&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1a442ff47616055a09385f87492675eec3f89c3c" translate="yes" xml:space="preserve">
          <source>Comments go before the code they describe. Multi-line comments should be like so:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="84228a13dd8f0021fa36768dd176470923d0af72" translate="yes" xml:space="preserve">
          <source>Commit locally as you progress (&lt;code&gt;git add&lt;/code&gt; and &lt;code&gt;git commit&lt;/code&gt;) Use a &lt;a href=&quot;development_workflow#writing-the-commit-message&quot;&gt;properly formatted&lt;/a&gt; commit message, write tests that fail before your change and pass afterward, run all the &lt;a href=&quot;development_environment#development-environment&quot;&gt;tests locally&lt;/a&gt;. Be sure to document any changed behavior in docstrings, keeping to the NumPy docstring &lt;a href=&quot;../docs/howto_document#howto-document&quot;&gt;standard&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0a32ce4cd17558c48ae2944590272943673a2335" translate="yes" xml:space="preserve">
          <source>Commit messages should be clear and follow a few basic rules. Example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a8981cd8f439f881e61c62a6482ca86e9bb4de5a" translate="yes" xml:space="preserve">
          <source>Commit the result:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="47e4d165580c53bcc66b6184b36ff34e18c1fd45" translate="yes" xml:space="preserve">
          <source>Common ASCII Formats</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f951af1137a01c272e20259ce69b92a33cbe2c01" translate="yes" xml:space="preserve">
          <source>Common block statements:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f108ad260d0dee041e2947d7bef1a1ab5f773f80" translate="yes" xml:space="preserve">
          <source>Common blocks</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="67644de9822acbd842a9ed1592fafe3b76c5957a" translate="yes" xml:space="preserve">
          <source>Common reST concepts</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="39a95105f6ae1d2c8ab5b77d2df7fa0bdc43b7b9" translate="yes" xml:space="preserve">
          <source>Common test support for all numpy test scripts.</source>
          <target state="translated">Общая тестовая поддержка для всех тестовых скриптов.</target>
        </trans-unit>
        <trans-unit id="ed80df7539525d1ebd0e5bb91694075d97aa07d4" translate="yes" xml:space="preserve">
          <source>Community coordination</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c2a68a63dc41f356e6d15c8c535eea2cf026660b" translate="yes" xml:space="preserve">
          <source>Companion matrix of dimensions (deg, deg).</source>
          <target state="translated">Сопутствующая матрица размеров (градусы,градусы).</target>
        </trans-unit>
        <trans-unit id="38428edac9ae2355adbd42053821bdf711ded835" translate="yes" xml:space="preserve">
          <source>Compare against built-in broadcasting:</source>
          <target state="translated">Сравните со встроенной трансляцией:</target>
        </trans-unit>
        <trans-unit id="b2a60fa70e9171ad22b67932b73a6ceaa9b40830" translate="yes" xml:space="preserve">
          <source>Compare change in benchmark results to another version/commit/branch:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b5977dbb9726befd30db9317959bca3faeb91b26" translate="yes" xml:space="preserve">
          <source>Compare the power function distribution to the inverse of the Pareto.</source>
          <target state="translated">Сравните распределение силовой функции с инверсией Парето.</target>
        </trans-unit>
        <trans-unit id="abbe4b051440d5c3941fb5ca3a1c58883bee0b7d" translate="yes" xml:space="preserve">
          <source>Compare two array_like objects for equality with desired relative and/or absolute precision.</source>
          <target state="translated">Сравните два массива объектов_подобных для равенства с требуемой относительной и/или абсолютной точностью.</target>
        </trans-unit>
        <trans-unit id="6e9c538fcc856b4c5b41ccf954d897e3fba11150" translate="yes" xml:space="preserve">
          <source>Compare two arrays and returns a new array containing the element-wise maxima. If one of the elements being compared is a NaN, then that element is returned. If both elements are NaNs then the first is returned. The latter distinction is important for complex NaNs, which are defined as at least one of the real or imaginary parts being a NaN. The net effect is that NaNs are propagated.</source>
          <target state="translated">Сравниваем два массива и возвращаем новый массив,содержащий элементированные максимумы.Если один из сравниваемых элементов является NaN,то этот элемент возвращается.Если оба элемента являются NaN,то возвращается первый.Последнее различие важно для сложных NaN,которые определяются как по крайней мере одна из реальных или воображаемых частей,являющаяся NaN.Суммарный эффект заключается в том,что NaN распространяются.</target>
        </trans-unit>
        <trans-unit id="52e468afc192be1b2f72e0bc9d7f9f138350a871" translate="yes" xml:space="preserve">
          <source>Compare two arrays and returns a new array containing the element-wise maxima. If one of the elements being compared is a NaN, then the non-nan element is returned. If both elements are NaNs then the first is returned. The latter distinction is important for complex NaNs, which are defined as at least one of the real or imaginary parts being a NaN. The net effect is that NaNs are ignored when possible.</source>
          <target state="translated">Сравниваем два массива и возвращаем новый массив,содержащий элементированные максимумы.Если один из сравниваемых элементов является NaN,то возвращается элемент без NaN.Если оба элемента являются NaN,возвращается первый.Последнее различие важно для сложных NaN,которые определяются как по крайней мере одна из реальных или мнимых частей,являющихся NaN.Суммарный эффект заключается в том,что NaN игнорируются,когда это возможно.</target>
        </trans-unit>
        <trans-unit id="ace9cb4b9063e509209a97ac371136964f6f7819" translate="yes" xml:space="preserve">
          <source>Compare two arrays and returns a new array containing the element-wise minima. If one of the elements being compared is a NaN, then that element is returned. If both elements are NaNs then the first is returned. The latter distinction is important for complex NaNs, which are defined as at least one of the real or imaginary parts being a NaN. The net effect is that NaNs are propagated.</source>
          <target state="translated">Сравниваем два массива и возвращаем новый массив,содержащий минимумы по элементам.Если один из сравниваемых элементов является NaN,то этот элемент возвращается.Если оба элемента являются NaN,то возвращается первый.Последнее различие важно для сложных NaN,которые определяются как по крайней мере одна из реальных или воображаемых частей,являющаяся NaN.Суммарный эффект заключается в том,что NaN распространяются.</target>
        </trans-unit>
        <trans-unit id="89c593ddd4725e7eb3064d75c349a4174bbacd17" translate="yes" xml:space="preserve">
          <source>Compare two arrays and returns a new array containing the element-wise minima. If one of the elements being compared is a NaN, then the non-nan element is returned. If both elements are NaNs then the first is returned. The latter distinction is important for complex NaNs, which are defined as at least one of the real or imaginary parts being a NaN. The net effect is that NaNs are ignored when possible.</source>
          <target state="translated">Сравниваем два массива и возвращаем новый массив,содержащий минимумы по элементам.Если один из сравниваемых элементов является NaN,то возвращается элемент без NaN.Если оба элемента являются NaN,то возвращается первый.Последнее различие важно для сложных NaN,которые определяются как по крайней мере одна из реальных или воображаемых частей,являющихся NaN.Суммарный эффект заключается в том,что NaN игнорируются,когда это возможно.</target>
        </trans-unit>
        <trans-unit id="bc6a4145f838627dea20878218beb3ec59a9a475" translate="yes" xml:space="preserve">
          <source>Compare two arrays relatively to their spacing.</source>
          <target state="translated">Сравните два массива относительно расстояния между ними.</target>
        </trans-unit>
        <trans-unit id="3aa05ceaaca50383ae3aabbf2a41d83e5da1cd94" translate="yes" xml:space="preserve">
          <source>Compared to indexing syntax, &lt;a href=&quot;#numpy.char.chararray.itemset&quot;&gt;&lt;code&gt;itemset&lt;/code&gt;&lt;/a&gt; provides some speed increase for placing a scalar into a particular location in an &lt;code&gt;ndarray&lt;/code&gt;, if you must do this. However, generally this is discouraged: among other problems, it complicates the appearance of the code. Also, when using &lt;a href=&quot;#numpy.char.chararray.itemset&quot;&gt;&lt;code&gt;itemset&lt;/code&gt;&lt;/a&gt; (and &lt;a href=&quot;numpy.char.chararray.item#numpy.char.chararray.item&quot;&gt;&lt;code&gt;item&lt;/code&gt;&lt;/a&gt;) inside a loop, be sure to assign the methods to a local variable to avoid the attribute look-up at each loop iteration.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8520223908607ca37ab66be3e4ca795dd7020679" translate="yes" xml:space="preserve">
          <source>Compared to indexing syntax, &lt;a href=&quot;#numpy.chararray.itemset&quot;&gt;&lt;code&gt;itemset&lt;/code&gt;&lt;/a&gt; provides some speed increase for placing a scalar into a particular location in an &lt;a href=&quot;numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;ndarray&lt;/code&gt;&lt;/a&gt;, if you must do this. However, generally this is discouraged: among other problems, it complicates the appearance of the code. Also, when using &lt;a href=&quot;#numpy.chararray.itemset&quot;&gt;&lt;code&gt;itemset&lt;/code&gt;&lt;/a&gt; (and &lt;a href=&quot;numpy.chararray.item#numpy.chararray.item&quot;&gt;&lt;code&gt;item&lt;/code&gt;&lt;/a&gt;) inside a loop, be sure to assign the methods to a local variable to avoid the attribute look-up at each loop iteration.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c0db5e8b47f9088d33c92f8b8df1d889c411c0de" translate="yes" xml:space="preserve">
          <source>Compared to indexing syntax, &lt;a href=&quot;#numpy.ma.masked_array.itemset&quot;&gt;&lt;code&gt;itemset&lt;/code&gt;&lt;/a&gt; provides some speed increase for placing a scalar into a particular location in an &lt;code&gt;ndarray&lt;/code&gt;, if you must do this. However, generally this is discouraged: among other problems, it complicates the appearance of the code. Also, when using &lt;a href=&quot;#numpy.ma.masked_array.itemset&quot;&gt;&lt;code&gt;itemset&lt;/code&gt;&lt;/a&gt; (and &lt;a href=&quot;numpy.ma.masked_array.item#numpy.ma.masked_array.item&quot;&gt;&lt;code&gt;item&lt;/code&gt;&lt;/a&gt;) inside a loop, be sure to assign the methods to a local variable to avoid the attribute look-up at each loop iteration.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="38460977eefc5ad076607c73457ab20f90eef5d2" translate="yes" xml:space="preserve">
          <source>Compared to indexing syntax, &lt;a href=&quot;#numpy.matrix.itemset&quot;&gt;&lt;code&gt;itemset&lt;/code&gt;&lt;/a&gt; provides some speed increase for placing a scalar into a particular location in an &lt;a href=&quot;numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;ndarray&lt;/code&gt;&lt;/a&gt;, if you must do this. However, generally this is discouraged: among other problems, it complicates the appearance of the code. Also, when using &lt;a href=&quot;#numpy.matrix.itemset&quot;&gt;&lt;code&gt;itemset&lt;/code&gt;&lt;/a&gt; (and &lt;a href=&quot;numpy.matrix.item#numpy.matrix.item&quot;&gt;&lt;code&gt;item&lt;/code&gt;&lt;/a&gt;) inside a loop, be sure to assign the methods to a local variable to avoid the attribute look-up at each loop iteration.</source>
          <target state="translated">По сравнению с синтаксисом индексации, &lt;a href=&quot;#numpy.matrix.itemset&quot;&gt; &lt;code&gt;itemset&lt;/code&gt; &lt;/a&gt; обеспечивает некоторое увеличение скорости для помещения скаляра в определенное место в &lt;a href=&quot;numpy.ndarray#numpy.ndarray&quot;&gt; &lt;code&gt;ndarray&lt;/code&gt; &lt;/a&gt; , если это необходимо. Однако, как правило, это не рекомендуется: помимо прочего, это усложняет внешний вид кода. Кроме того, при использовании &lt;a href=&quot;#numpy.matrix.itemset&quot;&gt; &lt;code&gt;itemset&lt;/code&gt; &lt;/a&gt; (и &lt;a href=&quot;numpy.matrix.item#numpy.matrix.item&quot;&gt; &lt;code&gt;item&lt;/code&gt; &lt;/a&gt; ) внутри цикла обязательно назначьте методы локальной переменной, чтобы избежать поиска атрибутов на каждой итерации цикла.</target>
        </trans-unit>
        <trans-unit id="ae8fffbb1016256e2544794348c439996df8510c" translate="yes" xml:space="preserve">
          <source>Compared to indexing syntax, &lt;a href=&quot;#numpy.memmap.itemset&quot;&gt;&lt;code&gt;itemset&lt;/code&gt;&lt;/a&gt; provides some speed increase for placing a scalar into a particular location in an &lt;a href=&quot;numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;ndarray&lt;/code&gt;&lt;/a&gt;, if you must do this. However, generally this is discouraged: among other problems, it complicates the appearance of the code. Also, when using &lt;a href=&quot;#numpy.memmap.itemset&quot;&gt;&lt;code&gt;itemset&lt;/code&gt;&lt;/a&gt; (and &lt;a href=&quot;numpy.memmap.item#numpy.memmap.item&quot;&gt;&lt;code&gt;item&lt;/code&gt;&lt;/a&gt;) inside a loop, be sure to assign the methods to a local variable to avoid the attribute look-up at each loop iteration.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="37a1ac805be872bfc7e003c20b71f2f1bbbc823c" translate="yes" xml:space="preserve">
          <source>Compared to indexing syntax, &lt;a href=&quot;#numpy.ndarray.itemset&quot;&gt;&lt;code&gt;itemset&lt;/code&gt;&lt;/a&gt; provides some speed increase for placing a scalar into a particular location in an &lt;a href=&quot;numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;ndarray&lt;/code&gt;&lt;/a&gt;, if you must do this. However, generally this is discouraged: among other problems, it complicates the appearance of the code. Also, when using &lt;a href=&quot;#numpy.ndarray.itemset&quot;&gt;&lt;code&gt;itemset&lt;/code&gt;&lt;/a&gt; (and &lt;a href=&quot;numpy.ndarray.item#numpy.ndarray.item&quot;&gt;&lt;code&gt;item&lt;/code&gt;&lt;/a&gt;) inside a loop, be sure to assign the methods to a local variable to avoid the attribute look-up at each loop iteration.</source>
          <target state="translated">По сравнению с синтаксисом индексации, &lt;a href=&quot;#numpy.ndarray.itemset&quot;&gt; &lt;code&gt;itemset&lt;/code&gt; &lt;/a&gt; обеспечивает некоторое увеличение скорости для помещения скаляра в определенное место в &lt;a href=&quot;numpy.ndarray#numpy.ndarray&quot;&gt; &lt;code&gt;ndarray&lt;/code&gt; &lt;/a&gt; , если это необходимо. Однако, как правило, это не рекомендуется: помимо прочего, это усложняет внешний вид кода. Кроме того, при использовании &lt;a href=&quot;#numpy.ndarray.itemset&quot;&gt; &lt;code&gt;itemset&lt;/code&gt; &lt;/a&gt; (и &lt;a href=&quot;numpy.ndarray.item#numpy.ndarray.item&quot;&gt; &lt;code&gt;item&lt;/code&gt; &lt;/a&gt; ) внутри цикла обязательно назначьте методы локальной переменной, чтобы избежать поиска атрибутов на каждой итерации цикла.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
