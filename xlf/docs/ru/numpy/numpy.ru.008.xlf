<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ru" datatype="htmlbody" original="numpy">
    <body>
      <group id="numpy">
        <trans-unit id="955a08b4bff95343601789d2bf6e0369ccf3f1b3" translate="yes" xml:space="preserve">
          <source>Here is a useful idiom for getting contiguous copies instead of non-contiguous views.</source>
          <target state="translated">Вот полезная идиома для получения сопрягаемых копий вместо не сопрягаемых представлений.</target>
        </trans-unit>
        <trans-unit id="9908262441b7f09837e1f501a21d5cc69908d615" translate="yes" xml:space="preserve">
          <source>Here is an example function which operates like a &amp;ldquo;lambda&amp;rdquo; ufunc:</source>
          <target state="translated">Вот пример функции, которая работает как &amp;laquo;лямбда&amp;raquo; ufunc:</target>
        </trans-unit>
        <trans-unit id="1e3d31fc803b806643f783a13be59435e8ec2879" translate="yes" xml:space="preserve">
          <source>Here is an example outer product function:</source>
          <target state="translated">Вот пример функции внешнего продукта:</target>
        </trans-unit>
        <trans-unit id="3e01528c46f09f5f5d5be27407d90af619b21250" translate="yes" xml:space="preserve">
          <source>Here is how the variables above are used:</source>
          <target state="translated">Вот как используются вышеперечисленные переменные:</target>
        </trans-unit>
        <trans-unit id="1637a3171b3e141604dedb2e68519a7e5432d5d7" translate="yes" xml:space="preserve">
          <source>Here is how they can be used with a sample array:</source>
          <target state="translated">Вот как их можно использовать с массивом примеров:</target>
        </trans-unit>
        <trans-unit id="b9c4a8ea1157853e06ffc2f25fe3f9b079de55b6" translate="yes" xml:space="preserve">
          <source>Here is how we might write an &lt;code&gt;iter_add&lt;/code&gt; function, using the Python iterator protocol:</source>
          <target state="translated">Вот как мы могли бы написать функцию &lt;code&gt;iter_add&lt;/code&gt; , используя протокол итератора Python:</target>
        </trans-unit>
        <trans-unit id="26ce084ba97f0fb601f4ee822ae6a8abc564ba7d" translate="yes" xml:space="preserve">
          <source>Here is the same function, but following the C-style pattern:</source>
          <target state="translated">Здесь та же самая функция,но по шаблону в стиле С:</target>
        </trans-unit>
        <trans-unit id="a43ab7c4c94ff9df3968be0c3da83726730e60b3" translate="yes" xml:space="preserve">
          <source>Here&amp;rsquo;s the listing of sum_squares.pyx:</source>
          <target state="translated">Вот список sum_squares.pyx:</target>
        </trans-unit>
        <trans-unit id="1bb0a1675e1ab72957846b002b2ccbd5daaee32d" translate="yes" xml:space="preserve">
          <source>Here, I&amp;rsquo;ve used the built-in enumerate iterator to return the iterator index as well as the value.</source>
          <target state="translated">Здесь я использовал встроенный итератор перечисления, чтобы вернуть индекс итератора, а также значение.</target>
        </trans-unit>
        <trans-unit id="423ebc2c2e7601fe55f4484a7fb3dc69ce69a81b" translate="yes" xml:space="preserve">
          <source>Here, U is drawn from the uniform distribution over (0,1].</source>
          <target state="translated">Здесь U берется из равномерного распределения по (0,1].</target>
        </trans-unit>
        <trans-unit id="9958f2320c4c020dbe0ba918682ede328e6342d6" translate="yes" xml:space="preserve">
          <source>Hermite</source>
          <target state="translated">Hermite</target>
        </trans-unit>
        <trans-unit id="666fe7ebc09d7395dcf2297ae16799bfb275707b" translate="yes" xml:space="preserve">
          <source>Hermite Class</source>
          <target state="translated">эрмитажный класс</target>
        </trans-unit>
        <trans-unit id="78bcd4fcaaa0c27a38e217337ec719b8d794b08b" translate="yes" xml:space="preserve">
          <source>Hermite Module, &amp;ldquo;Physicists&amp;rsquo;&amp;rdquo; (&lt;code&gt;numpy.polynomial.hermite&lt;/code&gt;)</source>
          <target state="translated">Модуль Эрмита, &amp;laquo;Физики&amp;raquo; ( &lt;code&gt;numpy.polynomial.hermite&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="20e36a23caee8661ea5087eb6b2833159c8b55f9" translate="yes" xml:space="preserve">
          <source>Hermite Module, &amp;ldquo;Physicists&amp;rsquo;&amp;rdquo; (numpy.polynomial.hermite)</source>
          <target state="translated">Модуль Эрмита, &amp;laquo;Физики&amp;raquo; (numpy.polynomial.hermite)</target>
        </trans-unit>
        <trans-unit id="4e51cfc7050a81e8b6b2247a7d2dcbdd5d5665a8" translate="yes" xml:space="preserve">
          <source>Hermite Module, “Physicists’” (numpy.polynomial.hermite)</source>
          <target state="translated">Эрмитажный модуль,&quot;Физики&quot; (нумпи.полиномиальный.гермит)</target>
        </trans-unit>
        <trans-unit id="321f1ab84f3ad6f4602b6463648250d7c017db66" translate="yes" xml:space="preserve">
          <source>Hermite coefficients in order of increasing degree, i.e, &lt;code&gt;(1, 2, 3)&lt;/code&gt; gives &lt;code&gt;1*H_0(x) + 2*H_1(X) + 3*H_2(x)&lt;/code&gt;.</source>
          <target state="translated">Коэффициенты Эрмита в порядке возрастания степени, то есть &lt;code&gt;(1, 2, 3)&lt;/code&gt; дает &lt;code&gt;1*H_0(x) + 2*H_1(X) + 3*H_2(x)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="030c6d9cd5a3996624a5dedd47cce0a8b255a2e1" translate="yes" xml:space="preserve">
          <source>Hermite coefficients ordered from low to high. If &lt;code&gt;y&lt;/code&gt; was 2-D, the coefficients for the data in column k of &lt;code&gt;y&lt;/code&gt; are in column &lt;code&gt;k&lt;/code&gt;.</source>
          <target state="translated">Коэффициенты Эрмита упорядочены по возрастанию. Если &lt;code&gt;y&lt;/code&gt; было 2-D, коэффициенты для данных в столбце k &lt;code&gt;y&lt;/code&gt; находятся в столбце &lt;code&gt;k&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="fdaeee3c1bfcab3d833e2cd601bbef119c7ca375" translate="yes" xml:space="preserve">
          <source>Hermite series</source>
          <target state="translated">эрмитажный сериал</target>
        </trans-unit>
        <trans-unit id="5d7c6da49173b96e3654eaebdb82df4267a07cd8" translate="yes" xml:space="preserve">
          <source>Hermite series coefficients of the integral.</source>
          <target state="translated">Коэффициенты эрмитарного ряда интеграла.</target>
        </trans-unit>
        <trans-unit id="f178c08ed0e44e86c3dcdcdd94165f4d2159704d" translate="yes" xml:space="preserve">
          <source>Hermite series of power.</source>
          <target state="translated">Эрмита.</target>
        </trans-unit>
        <trans-unit id="4b1ee605707018d73fef71e944f33b064cb30198" translate="yes" xml:space="preserve">
          <source>Hermite series of the derivative.</source>
          <target state="translated">Эрмитская серия производной.</target>
        </trans-unit>
        <trans-unit id="f3b525d4a933addff05d89e23fb102c4771100af" translate="yes" xml:space="preserve">
          <source>Hermite series whose graph is a straight line.</source>
          <target state="translated">Эрмита,чей график представляет собой прямую линию.</target>
        </trans-unit>
        <trans-unit id="f15ba129dfce798b05af2ecf87c4c56e141a51c6" translate="yes" xml:space="preserve">
          <source>Hermite weight function</source>
          <target state="translated">функция веса эрмита</target>
        </trans-unit>
        <trans-unit id="e91ac76ec50377772a4d0a0fad317ac36bda67d9" translate="yes" xml:space="preserve">
          <source>Hermite.__call__()</source>
          <target state="translated">Hermite.__call__()</target>
        </trans-unit>
        <trans-unit id="e00caea2e8b760013383648bd7a0c8356ad2d21a" translate="yes" xml:space="preserve">
          <source>Hermite.basis()</source>
          <target state="translated">Hermite.basis()</target>
        </trans-unit>
        <trans-unit id="510f491be62b2a7e3419873aabcc929cba4aad0a" translate="yes" xml:space="preserve">
          <source>Hermite.cast()</source>
          <target state="translated">Hermite.cast()</target>
        </trans-unit>
        <trans-unit id="0bbb26adb9485391c59073a0150f1aeb28250175" translate="yes" xml:space="preserve">
          <source>Hermite.convert()</source>
          <target state="translated">Hermite.convert()</target>
        </trans-unit>
        <trans-unit id="46e59fa3efb39aa8de99b77595a66c5aca6f95af" translate="yes" xml:space="preserve">
          <source>Hermite.copy()</source>
          <target state="translated">Hermite.copy()</target>
        </trans-unit>
        <trans-unit id="150883af29979fdad32a1485afaa265ae485116d" translate="yes" xml:space="preserve">
          <source>Hermite.cutdeg()</source>
          <target state="translated">Hermite.cutdeg()</target>
        </trans-unit>
        <trans-unit id="6e3addaaf8a990d63bd9644e879a45bfaaa3d048" translate="yes" xml:space="preserve">
          <source>Hermite.degree()</source>
          <target state="translated">Hermite.degree()</target>
        </trans-unit>
        <trans-unit id="1898e27484be79666c2d0d0671ff99bb73c61fb0" translate="yes" xml:space="preserve">
          <source>Hermite.deriv()</source>
          <target state="translated">Hermite.deriv()</target>
        </trans-unit>
        <trans-unit id="74d98daf1082d857dc8043ef7d611943987bcbf6" translate="yes" xml:space="preserve">
          <source>Hermite.domain</source>
          <target state="translated">Hermite.domain</target>
        </trans-unit>
        <trans-unit id="69a9477b050cf5e84517bc3ba4b2540b289809dd" translate="yes" xml:space="preserve">
          <source>Hermite.fit()</source>
          <target state="translated">Hermite.fit()</target>
        </trans-unit>
        <trans-unit id="ee377bb8277d3cc87539518382039049d3434ab2" translate="yes" xml:space="preserve">
          <source>Hermite.fromroots()</source>
          <target state="translated">Hermite.fromroots()</target>
        </trans-unit>
        <trans-unit id="f3d364e431135afb3032332cc59ddec1d0087c65" translate="yes" xml:space="preserve">
          <source>Hermite.has_samecoef()</source>
          <target state="translated">Hermite.has_samecoef()</target>
        </trans-unit>
        <trans-unit id="4f5a15af827e1a34e56c335924bc117f06d9550b" translate="yes" xml:space="preserve">
          <source>Hermite.has_samedomain()</source>
          <target state="translated">Hermite.has_samedomain()</target>
        </trans-unit>
        <trans-unit id="5c6b35ea3f6249366ad14a64bf61b1e2f4ef3fa2" translate="yes" xml:space="preserve">
          <source>Hermite.has_sametype()</source>
          <target state="translated">Hermite.has_sametype()</target>
        </trans-unit>
        <trans-unit id="51595f8a76f511b51c25db7ca6799c30af573ff1" translate="yes" xml:space="preserve">
          <source>Hermite.has_samewindow()</source>
          <target state="translated">Hermite.has_samewindow()</target>
        </trans-unit>
        <trans-unit id="fae0683eb07169c7856c805873bd384998f4ce23" translate="yes" xml:space="preserve">
          <source>Hermite.identity()</source>
          <target state="translated">Hermite.identity()</target>
        </trans-unit>
        <trans-unit id="6d7f1a135c9fd7bdb20e45551f21a01a1b98749d" translate="yes" xml:space="preserve">
          <source>Hermite.integ()</source>
          <target state="translated">Hermite.integ()</target>
        </trans-unit>
        <trans-unit id="87c4ac5818fcc034b0a86594470677888839404b" translate="yes" xml:space="preserve">
          <source>Hermite.linspace()</source>
          <target state="translated">Hermite.linspace()</target>
        </trans-unit>
        <trans-unit id="e4e8e042f2bff68022c1506a796ae1f2b1a45e62" translate="yes" xml:space="preserve">
          <source>Hermite.mapparms()</source>
          <target state="translated">Hermite.mapparms()</target>
        </trans-unit>
        <trans-unit id="dd2d324dc15bd07b8d8eba7c1b9a303c6e61cbe9" translate="yes" xml:space="preserve">
          <source>Hermite.roots()</source>
          <target state="translated">Hermite.roots()</target>
        </trans-unit>
        <trans-unit id="357de88ac6a59383fa4db68dc02a30a97aa55b31" translate="yes" xml:space="preserve">
          <source>Hermite.trim()</source>
          <target state="translated">Hermite.trim()</target>
        </trans-unit>
        <trans-unit id="ded6de456aef1c9f3f0dbb030eecbec360a2a3d9" translate="yes" xml:space="preserve">
          <source>Hermite.truncate()</source>
          <target state="translated">Hermite.truncate()</target>
        </trans-unit>
        <trans-unit id="bfa82105a95ddf719538cbbbc2136f5bdc652b85" translate="yes" xml:space="preserve">
          <source>HermiteE</source>
          <target state="translated">HermiteE</target>
        </trans-unit>
        <trans-unit id="6628b3304670336395ae6732f06085678ac90c72" translate="yes" xml:space="preserve">
          <source>HermiteE Class</source>
          <target state="translated">Класс &quot;Эрмитаж</target>
        </trans-unit>
        <trans-unit id="da640bfdcf0affcdb1cb3e699294b822aff50f4d" translate="yes" xml:space="preserve">
          <source>HermiteE Module, &amp;ldquo;Probabilists&amp;rsquo;&amp;rdquo; (&lt;code&gt;numpy.polynomial.hermite_e&lt;/code&gt;)</source>
          <target state="translated">Модуль HermiteE, &amp;laquo;Вероятностные&amp;raquo; ( &lt;code&gt;numpy.polynomial.hermite_e&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="93c34719e313928a50611a43ea25a148a84b264b" translate="yes" xml:space="preserve">
          <source>HermiteE Module, &amp;ldquo;Probabilists&amp;rsquo;&amp;rdquo; (numpy.polynomial.hermite_e)</source>
          <target state="translated">Модуль HermiteE, &amp;laquo;Вероятностные&amp;raquo; (numpy.polynomial.hermite_e)</target>
        </trans-unit>
        <trans-unit id="56f6680ec7b317dd6ae3f4dbb7e9720ab2e6af02" translate="yes" xml:space="preserve">
          <source>HermiteE Module, “Probabilists’” (numpy.polynomial.hermite_e)</source>
          <target state="translated">Модуль HermiteE,&quot;Вероятности&quot; (numpy.polynomial.hermite_e)</target>
        </trans-unit>
        <trans-unit id="7090e745bd4427b0619b5249b32836cf9e710c91" translate="yes" xml:space="preserve">
          <source>HermiteE coefficients in order of increasing degree, i.e, &lt;code&gt;(1, 2, 3)&lt;/code&gt; gives &lt;code&gt;1*He_0(x) + 2*He_1(X) + 3*He_2(x)&lt;/code&gt;.</source>
          <target state="translated">Коэффициенты HermiteE в порядке возрастания, то есть &lt;code&gt;(1, 2, 3)&lt;/code&gt; дает &lt;code&gt;1*He_0(x) + 2*He_1(X) + 3*He_2(x)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8fdce93a022f8c8da6190fdc0f7e0fa2783e7c6d" translate="yes" xml:space="preserve">
          <source>HermiteE series</source>
          <target state="translated">серия HermiteE</target>
        </trans-unit>
        <trans-unit id="f8a256fa19026169a866b5809900fc5fb915e807" translate="yes" xml:space="preserve">
          <source>HermiteE weight function.</source>
          <target state="translated">Весовая функция HermiteE.</target>
        </trans-unit>
        <trans-unit id="f2a1b68f303ab3a67abc7b2e4c4c8451183b7095" translate="yes" xml:space="preserve">
          <source>HermiteE.__call__()</source>
          <target state="translated">HermiteE.__call__()</target>
        </trans-unit>
        <trans-unit id="45c27d16e911c80a7d363f3c39ba54997fd020cd" translate="yes" xml:space="preserve">
          <source>HermiteE.basis()</source>
          <target state="translated">HermiteE.basis()</target>
        </trans-unit>
        <trans-unit id="b45b6525bda44ccf736a4ef59137ed1b81c51100" translate="yes" xml:space="preserve">
          <source>HermiteE.cast()</source>
          <target state="translated">HermiteE.cast()</target>
        </trans-unit>
        <trans-unit id="4ddefc1ce033e171e5d4661134688bd82e8bc5af" translate="yes" xml:space="preserve">
          <source>HermiteE.convert()</source>
          <target state="translated">HermiteE.convert()</target>
        </trans-unit>
        <trans-unit id="002903a3a64a57beced04a1c5706dd609af411f5" translate="yes" xml:space="preserve">
          <source>HermiteE.copy()</source>
          <target state="translated">HermiteE.copy()</target>
        </trans-unit>
        <trans-unit id="b24cf643ce7571c11b38beb07f1dba60d0898965" translate="yes" xml:space="preserve">
          <source>HermiteE.cutdeg()</source>
          <target state="translated">HermiteE.cutdeg()</target>
        </trans-unit>
        <trans-unit id="564634c0d69d527c3b8fbcf352579c91cc6babc0" translate="yes" xml:space="preserve">
          <source>HermiteE.degree()</source>
          <target state="translated">HermiteE.degree()</target>
        </trans-unit>
        <trans-unit id="b0998c48dfd3e6da9f8d9a094fe9026de37d9068" translate="yes" xml:space="preserve">
          <source>HermiteE.deriv()</source>
          <target state="translated">HermiteE.deriv()</target>
        </trans-unit>
        <trans-unit id="e3b7e4ce40140bfad9d15417ff37a5918c3d9ee7" translate="yes" xml:space="preserve">
          <source>HermiteE.domain</source>
          <target state="translated">HermiteE.domain</target>
        </trans-unit>
        <trans-unit id="b9a9cf1e6530dd58c8fe754b4c5e909f051929ea" translate="yes" xml:space="preserve">
          <source>HermiteE.fit()</source>
          <target state="translated">HermiteE.fit()</target>
        </trans-unit>
        <trans-unit id="4a10eb67a6e8118b67d08f9c1672e5c1ef31f7e7" translate="yes" xml:space="preserve">
          <source>HermiteE.fromroots()</source>
          <target state="translated">HermiteE.fromroots()</target>
        </trans-unit>
        <trans-unit id="f215586092039a3f249d19a38ef5f2e5c8b9fe46" translate="yes" xml:space="preserve">
          <source>HermiteE.has_samecoef()</source>
          <target state="translated">HermiteE.has_samecoef()</target>
        </trans-unit>
        <trans-unit id="e303961ece2b00de2ea59d3add859f3b9afba3be" translate="yes" xml:space="preserve">
          <source>HermiteE.has_samedomain()</source>
          <target state="translated">HermiteE.has_samedomain()</target>
        </trans-unit>
        <trans-unit id="56c531828abb17c1fa8561b9e8274772104c7875" translate="yes" xml:space="preserve">
          <source>HermiteE.has_sametype()</source>
          <target state="translated">HermiteE.has_sametype()</target>
        </trans-unit>
        <trans-unit id="f597206a0348307571c5766a04f0329e0e5977a6" translate="yes" xml:space="preserve">
          <source>HermiteE.has_samewindow()</source>
          <target state="translated">HermiteE.has_samewindow()</target>
        </trans-unit>
        <trans-unit id="edecbdf0322d9c36d15b82f596749f9baa998818" translate="yes" xml:space="preserve">
          <source>HermiteE.identity()</source>
          <target state="translated">HermiteE.identity()</target>
        </trans-unit>
        <trans-unit id="50879495edc6ec638987e4aab2fb5c3ff2693ffc" translate="yes" xml:space="preserve">
          <source>HermiteE.integ()</source>
          <target state="translated">HermiteE.integ()</target>
        </trans-unit>
        <trans-unit id="7644c7d4879b67345881eccc21f74f5ac1d76221" translate="yes" xml:space="preserve">
          <source>HermiteE.linspace()</source>
          <target state="translated">HermiteE.linspace()</target>
        </trans-unit>
        <trans-unit id="71240e92395878a17c98ad6cabf8e728e1e375a7" translate="yes" xml:space="preserve">
          <source>HermiteE.mapparms()</source>
          <target state="translated">HermiteE.mapparms()</target>
        </trans-unit>
        <trans-unit id="918dc10943107e5fa1f93651ccb4cc1d4ca399a0" translate="yes" xml:space="preserve">
          <source>HermiteE.roots()</source>
          <target state="translated">HermiteE.roots()</target>
        </trans-unit>
        <trans-unit id="6c5620ec0bf2dc54449e61b049184a2294791751" translate="yes" xml:space="preserve">
          <source>HermiteE.trim()</source>
          <target state="translated">HermiteE.trim()</target>
        </trans-unit>
        <trans-unit id="8b9f703c9558cb71c68ad02c3049b60b8b59198b" translate="yes" xml:space="preserve">
          <source>HermiteE.truncate()</source>
          <target state="translated">HermiteE.truncate()</target>
        </trans-unit>
        <trans-unit id="a2691f3b6c74bc9be228ebe1bfd4aaa8b167edac" translate="yes" xml:space="preserve">
          <source>Hermite_e series coefficients of the integral.</source>
          <target state="translated">Коэффициенты ряда Hermite_e интеграла.</target>
        </trans-unit>
        <trans-unit id="cb6305ebb37efa97b74f55f04adb878c2cfd6823" translate="yes" xml:space="preserve">
          <source>Hermitian (symmetric if all elements are real), positive-definite input matrix.</source>
          <target state="translated">Гермитский (симметричный,если все элементы вещественные),входная матрица с положительным значением.</target>
        </trans-unit>
        <trans-unit id="559550c9b0251579dbef6add2f3cc35db020af9a" translate="yes" xml:space="preserve">
          <source>Hermitian FFTs</source>
          <target state="translated">БПФ Гермициана</target>
        </trans-unit>
        <trans-unit id="d6600c2342a8053253425f9846737e2bf29ea82c" translate="yes" xml:space="preserve">
          <source>Hermitian or real symmetric matrices whose eigenvalues and eigenvectors are to be computed.</source>
          <target state="translated">Гермитовые или реальные симметричные матрицы,собственные значения и собственные векторы которых должны быть вычислены.</target>
        </trans-unit>
        <trans-unit id="2e330e11eac48710d52dc39e422ecae197585b4d" translate="yes" xml:space="preserve">
          <source>High-order polynomials may oscillate wildly:</source>
          <target state="translated">Полиномы высокого порядка могут дико колебаться:</target>
        </trans-unit>
        <trans-unit id="4be99f1c1557117aa5c64902eb10d5b0886a0d69" translate="yes" xml:space="preserve">
          <source>Higher dimensions</source>
          <target state="translated">Более высокие размеры</target>
        </trans-unit>
        <trans-unit id="00b07925679220cb801f1a4855d71039bbcccecc" translate="yes" xml:space="preserve">
          <source>Hiroshi Haramoto, Makoto Matsumoto, Takuji Nishimura, Fran&amp;ccedil;ois Panneton, Pierre L&amp;rsquo;Ecuyer, &amp;ldquo;Efficient Jump Ahead for F2-Linear Random Number Generators&amp;rdquo;, INFORMS JOURNAL ON COMPUTING, Vol. 20, No. 3, Summer 2008, pp. 385-390.</source>
          <target state="translated">Хироши Харамото, Макото Мацумото, Такудзи Нисимура, Франсуа Паннетон, Пьер Л'Экуайер, &amp;laquo;Эффективный прыжок вперед для F2-линейных генераторов случайных чисел&amp;raquo;, INFORMS JOURNAL ON COMPUTING, Vol. 20, № 3, лето 2008 г., стр. 385-390.</target>
        </trans-unit>
        <trans-unit id="9f573dd516c5fae818d100652937d22c8be8a33c" translate="yes" xml:space="preserve">
          <source>Histograms</source>
          <target state="translated">Histograms</target>
        </trans-unit>
        <trans-unit id="02f07bc7a75153468adfa0658b0fd2c34d3ff7ae" translate="yes" xml:space="preserve">
          <source>Horner&amp;rsquo;s scheme &lt;a href=&quot;#r138ee7027ddf-1&quot; id=&quot;id1&quot;&gt;[1]&lt;/a&gt; is used to evaluate the polynomial. Even so, for polynomials of high degree the values may be inaccurate due to rounding errors. Use carefully.</source>
          <target state="translated">Схема Горнера &lt;a href=&quot;#r138ee7027ddf-1&quot; id=&quot;id1&quot;&gt;[1]&lt;/a&gt; используется для вычисления полинома. Даже в этом случае для многочленов высокой степени значения могут быть неточными из-за ошибок округления. Используйте осторожно.</target>
        </trans-unit>
        <trans-unit id="45e254592757b5e545a9eb104e6529f78a4c37d7" translate="yes" xml:space="preserve">
          <source>How many bytes needed to jump from the end of a dimension back to its beginning. Note that &lt;code&gt;backstrides[k] == strides[k] *
dims_m1[k]&lt;/code&gt;, but it is stored here as an optimization.</source>
          <target state="translated">Сколько байтов нужно для перехода от конца измерения к его началу. Обратите внимание, что &lt;code&gt;backstrides[k] == strides[k] * dims_m1[k]&lt;/code&gt; , но он сохраняется здесь как оптимизация.</target>
        </trans-unit>
        <trans-unit id="50be7c0770c6ecdb4f48559d001a760ebacd49cf" translate="yes" xml:space="preserve">
          <source>How many trials succeeded after a single run?</source>
          <target state="translated">Сколько испытаний увенчалось успехом после одного прогона?</target>
        </trans-unit>
        <trans-unit id="41cd522ba4633ce6d4277a1ec4fd27e9f6066b5f" translate="yes" xml:space="preserve">
          <source>How to treat dates that do not fall on a valid day. The default is &amp;lsquo;raise&amp;rsquo;.</source>
          <target state="translated">Как относиться к свиданиям, не приходящимся на действительный день. По умолчанию - &amp;laquo;рейз&amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="031b673efec683dbe6f1648f1b6820d5445558f5" translate="yes" xml:space="preserve">
          <source>How to use an array iterator on a C-level is explained more fully in later sections. Typically, you do not need to concern yourself with the internal structure of the iterator object, and merely interact with it through the use of the macros &lt;a href=&quot;c-api.array#c.PyArray_ITER_NEXT&quot;&gt;&lt;code&gt;PyArray_ITER_NEXT&lt;/code&gt;&lt;/a&gt; (it), &lt;a href=&quot;c-api.array#c.PyArray_ITER_GOTO&quot;&gt;&lt;code&gt;PyArray_ITER_GOTO&lt;/code&gt;&lt;/a&gt; (it, dest), or &lt;a href=&quot;c-api.array#c.PyArray_ITER_GOTO1D&quot;&gt;&lt;code&gt;PyArray_ITER_GOTO1D&lt;/code&gt;&lt;/a&gt; (it, index). All of these macros require the argument &lt;em&gt;it&lt;/em&gt; to be a &lt;a href=&quot;#c.PyArrayIterObject&quot;&gt;&lt;code&gt;PyArrayIterObject *&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Как использовать итератор массива на уровне C более подробно объясняется в следующих разделах. Как правило, вам не нужно беспокоиться о внутренней структуре объекта итератора, а просто взаимодействовать с ним с помощью макросов &lt;a href=&quot;c-api.array#c.PyArray_ITER_NEXT&quot;&gt; &lt;code&gt;PyArray_ITER_NEXT&lt;/code&gt; &lt;/a&gt; (it), &lt;a href=&quot;c-api.array#c.PyArray_ITER_GOTO&quot;&gt; &lt;code&gt;PyArray_ITER_GOTO&lt;/code&gt; &lt;/a&gt; (it, dest) или &lt;a href=&quot;c-api.array#c.PyArray_ITER_GOTO1D&quot;&gt; &lt;code&gt;PyArray_ITER_GOTO1D&lt;/code&gt; &lt;/a&gt; (it, index). Все эти макросы требуют аргумент , &lt;em&gt;что&lt;/em&gt; , чтобы быть &lt;a href=&quot;#c.PyArrayIterObject&quot;&gt; &lt;code&gt;PyArrayIterObject *&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="1fba89386b8ecb89961d14d41f66fbec5ccd1d21" translate="yes" xml:space="preserve">
          <source>However, array scalars are immutable, so none of the array scalar attributes are settable.</source>
          <target state="translated">Однако скаляры массивов являются неизменными,поэтому ни один из атрибутов скаляра массива не может быть установлен.</target>
        </trans-unit>
        <trans-unit id="1e80ea7cc9443be2dc987f1f00e1482c24f952ab" translate="yes" xml:space="preserve">
          <source>However, for a 2D array, &lt;code&gt;tolist&lt;/code&gt; applies recursively:</source>
          <target state="translated">Однако для 2D-массива &lt;code&gt;tolist&lt;/code&gt; применяется рекурсивно:</target>
        </trans-unit>
        <trans-unit id="538a59374ec076485a1ecbe77f4b8f8bcaeb6930" translate="yes" xml:space="preserve">
          <source>However, if the step length is a &lt;strong&gt;complex number&lt;/strong&gt; (e.g. 5j), then the integer part of its magnitude is interpreted as specifying the number of points to create between the start and stop values, where the stop value &lt;strong&gt;is inclusive&lt;/strong&gt;.</source>
          <target state="translated">Однако, если длина шага является &lt;strong&gt;комплексным числом&lt;/strong&gt; (например, 5j), то целая часть его величины интерпретируется как указание количества точек, которые необходимо создать между начальным и конечным значениями, где конечное значение &lt;strong&gt;включено&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="c7b350918e2c3c187f55b17296e6170af94589d5" translate="yes" xml:space="preserve">
          <source>However, it also provides a filter mechanism to work around &lt;a href=&quot;https://bugs.python.org/issue4180&quot;&gt;https://bugs.python.org/issue4180&lt;/a&gt;.</source>
          <target state="translated">Однако он также предоставляет механизм фильтрации для обхода &lt;a href=&quot;https://bugs.python.org/issue4180&quot;&gt;https://bugs.python.org/issue4180&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="72730352a2b8f129f65e5ce4d2975cad73414281" translate="yes" xml:space="preserve">
          <source>However, since the indexing arrays above just repeat themselves, broadcasting can be used (compare operations such as &lt;code&gt;rows[:, np.newaxis] + columns&lt;/code&gt;) to simplify this:</source>
          <target state="translated">Однако, поскольку индексирующие массивы выше просто повторяются, можно использовать широковещательную &lt;code&gt;rows[:, np.newaxis] + columns&lt;/code&gt; (операции сравнения, такие как строки [:, np.newaxis] + columns ), чтобы упростить это:</target>
        </trans-unit>
        <trans-unit id="517b2fc5c448904cbaf5099f9fa2e17572271c41" translate="yes" xml:space="preserve">
          <source>However, this class is not run directly. Rather, it serves as a base class to several other python classes, each one specific to a particular data type. The &lt;code&gt;VectorTestCase&lt;/code&gt; class stores two strings for typing information:</source>
          <target state="translated">Однако этот класс не запускается напрямую. Скорее, он служит базовым классом для нескольких других классов Python, каждый из которых относится к определенному типу данных. Класс &lt;code&gt;VectorTestCase&lt;/code&gt; хранит две строки для ввода информации:</target>
        </trans-unit>
        <trans-unit id="baf7f433a664b8146a9906ca7ff1abe3cab252ff" translate="yes" xml:space="preserve">
          <source>Hyperbolic cosine, element-wise.</source>
          <target state="translated">Гиперболический косинус,по элементам.</target>
        </trans-unit>
        <trans-unit id="f3ed3aadb3c9adb061d870e136cd1453348e8c73" translate="yes" xml:space="preserve">
          <source>Hyperbolic functions</source>
          <target state="translated">гиперболические функции</target>
        </trans-unit>
        <trans-unit id="b87cce3c91c3e9d2649c00af3ce0c941c00a9a8f" translate="yes" xml:space="preserve">
          <source>Hyperbolic sine, element-wise.</source>
          <target state="translated">Гиперболический синус,по элементам.</target>
        </trans-unit>
        <trans-unit id="c586011e018241bf43412c51ec75d78e1897bbe7" translate="yes" xml:space="preserve">
          <source>I. N. Bronshtein, K. A. Semendyayev, and K. A. Hirsch (Eng. trans. Ed.), &lt;em&gt;Handbook of Mathematics&lt;/em&gt;, New York, Van Nostrand Reinhold Co., 1985, pg. 720.</source>
          <target state="translated">Бронштейн И.Н., Семендяев К.А., Хирш К.А. (англ. Пер. Ред.), &lt;em&gt;Справочник по математике&lt;/em&gt; , Нью-Йорк, Van Nostrand Reinhold Co., 1985, стр. 720.</target>
        </trans-unit>
        <trans-unit id="0ee225f319b80c76b05dae881594a3894bf4661e" translate="yes" xml:space="preserve">
          <source>IEEE 754 floating point representation of (positive) infinity.</source>
          <target state="translated">IEEE 754 представление с плавающей точкой (положительной)бесконечности.</target>
        </trans-unit>
        <trans-unit id="ff3e6480ff45af971d6b3762d77291c710637eb0" translate="yes" xml:space="preserve">
          <source>IEEE 754 floating point representation of Not a Number (NaN).</source>
          <target state="translated">IEEE 754 представление с плавающей точкой не числа (NaN).</target>
        </trans-unit>
        <trans-unit id="824566ddb199752efcc7660bd7d421e1b2678da4" translate="yes" xml:space="preserve">
          <source>IEEE 754 floating point representation of negative infinity.</source>
          <target state="translated">IEEE 754 представление с плавающей точкой отрицательной бесконечности.</target>
        </trans-unit>
        <trans-unit id="2e340e10314a130edadd8cad9f96f416538b858d" translate="yes" xml:space="preserve">
          <source>IEEE 754 floating point representation of negative zero.</source>
          <target state="translated">IEEE 754 представление с плавающей точкой отрицательного нуля.</target>
        </trans-unit>
        <trans-unit id="b287f77a659c8b69b20168ee840f1a54628cc862" translate="yes" xml:space="preserve">
          <source>IEEE 754 floating point representation of positive zero.</source>
          <target state="translated">IEEE 754 представление с плавающей точкой положительного нуля.</target>
        </trans-unit>
        <trans-unit id="401e5d8be22ba7ec21a65d4ac42f63626cf30eac" translate="yes" xml:space="preserve">
          <source>ISO/IEC standard 9899:1999, &amp;ldquo;Programming language C.&amp;rdquo;</source>
          <target state="translated">Стандарт ISO / IEC 9899: 1999, &amp;laquo;Язык программирования C.&amp;raquo;</target>
        </trans-unit>
        <trans-unit id="a192903ac36265b2268a1b63fb4343f1bc34ccf1" translate="yes" xml:space="preserve">
          <source>ISeedSequence.generate_state()</source>
          <target state="translated">ISeedSequence.generate_state()</target>
        </trans-unit>
        <trans-unit id="7817ae1e33233084a2765c4156676391d76c8dd8" translate="yes" xml:space="preserve">
          <source>ISpawnableSeedSequence.generate_state()</source>
          <target state="translated">ISpawnableSeedSequence.generate_state()</target>
        </trans-unit>
        <trans-unit id="266493f5f6f829a5601662541a1f5723f1a321cc" translate="yes" xml:space="preserve">
          <source>ISpawnableSeedSequence.spawn()</source>
          <target state="translated">ISpawnableSeedSequence.spawn()</target>
        </trans-unit>
        <trans-unit id="111e795804fa7bde03948ba63ec2cb3f6f402b39" translate="yes" xml:space="preserve">
          <source>Identity function.</source>
          <target state="translated">Функция идентификации.</target>
        </trans-unit>
        <trans-unit id="c9a8c69d524e3737d8a52d7c063a710ab1820ab4" translate="yes" xml:space="preserve">
          <source>If &amp;lsquo;left&amp;rsquo;, the index of the first suitable location found is given. If &amp;lsquo;right&amp;rsquo;, return the last such index. If there is no suitable index, return either 0 or N (where N is the length of &lt;code&gt;a&lt;/code&gt;).</source>
          <target state="translated">Если &amp;laquo;влево&amp;raquo;, дается индекс первого найденного подходящего местоположения. Если &amp;laquo;правильно&amp;raquo;, вернуть последний такой индекс. Если подходящего индекса нет, верните либо 0, либо N (где N - длина &lt;code&gt;a&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="0b2ac55fdba7a6077870f65fb651eb209decd3f7" translate="yes" xml:space="preserve">
          <source>If &amp;lsquo;out&amp;rsquo; is None (the default), a uninitialized return array is created. The output array is then filled with the results of the ufunc in the places that the broadcast &amp;lsquo;where&amp;rsquo; is True. If &amp;lsquo;where&amp;rsquo; is the scalar True (the default), then this corresponds to the entire output being filled. Note that outputs not explicitly filled are left with their uninitialized values.</source>
          <target state="translated">Если out - None (по умолчанию), создается неинициализированный возвращаемый массив. Затем выходной массив заполняется результатами ufunc в тех местах, где широковещательная передача where имеет значение True. Если &amp;laquo;где&amp;raquo; является скалярным значением True (по умолчанию), то это соответствует заполнению всего вывода. Обратите внимание, что для выходов, не заполненных явно, остаются неинициализированные значения.</target>
        </trans-unit>
        <trans-unit id="b221bc8f0d9f3564598fa735c4c298856c0dd2e9" translate="yes" xml:space="preserve">
          <source>If -1/NULL values are passed to &lt;code&gt;oa_ndim&lt;/code&gt;, &lt;code&gt;op_axes&lt;/code&gt;, &lt;code&gt;itershape&lt;/code&gt;, and &lt;code&gt;buffersize&lt;/code&gt;, it is equivalent to &lt;a href=&quot;#c.NpyIter_MultiNew&quot;&gt;&lt;code&gt;NpyIter_MultiNew&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Если значения -1 / NULL передаются в &lt;code&gt;oa_ndim&lt;/code&gt; , &lt;code&gt;op_axes&lt;/code&gt; , &lt;code&gt;itershape&lt;/code&gt; и &lt;code&gt;buffersize&lt;/code&gt; , это эквивалентно &lt;a href=&quot;#c.NpyIter_MultiNew&quot;&gt; &lt;code&gt;NpyIter_MultiNew&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="79d46b4b066a6ba67bd08b99b0faa98132c0c54b" translate="yes" xml:space="preserve">
          <source>If &lt;a href=&quot;#c.NO_IMPORT_ARRAY&quot;&gt;&lt;code&gt;NO_IMPORT_ARRAY&lt;/code&gt;&lt;/a&gt; is #defined, regardless of whether &lt;a href=&quot;#c.PY_ARRAY_UNIQUE_SYMBOL&quot;&gt;&lt;code&gt;PY_ARRAY_UNIQUE_SYMBOL&lt;/code&gt;&lt;/a&gt; is, the C-API is declared to be &lt;code&gt;extern void**&lt;/code&gt;, so it is expected to be defined in another compilation unit.</source>
          <target state="translated">Если &lt;a href=&quot;#c.NO_IMPORT_ARRAY&quot;&gt; &lt;code&gt;NO_IMPORT_ARRAY&lt;/code&gt; &lt;/a&gt; имеет значение #defined, независимо от того, является ли значение &lt;a href=&quot;#c.PY_ARRAY_UNIQUE_SYMBOL&quot;&gt; &lt;code&gt;PY_ARRAY_UNIQUE_SYMBOL&lt;/code&gt; &lt;/a&gt; , C-API объявляется как &lt;code&gt;extern void**&lt;/code&gt; , поэтому ожидается, что он будет определен в другом модуле компиляции.</target>
        </trans-unit>
        <trans-unit id="f636b5861ee4fae57e7d457d50fef770ecd7b810" translate="yes" xml:space="preserve">
          <source>If &lt;a href=&quot;#c.NpyIter_RemoveMultiIndex&quot;&gt;&lt;code&gt;NpyIter_RemoveMultiIndex&lt;/code&gt;&lt;/a&gt; was called, you may want to enable the flag &lt;a href=&quot;#c.NPY_ITER_EXTERNAL_LOOP&quot;&gt;&lt;code&gt;NPY_ITER_EXTERNAL_LOOP&lt;/code&gt;&lt;/a&gt;. This flag is not permitted together with &lt;a href=&quot;#c.NPY_ITER_MULTI_INDEX&quot;&gt;&lt;code&gt;NPY_ITER_MULTI_INDEX&lt;/code&gt;&lt;/a&gt;, so this function is provided to enable the feature after &lt;a href=&quot;#c.NpyIter_RemoveMultiIndex&quot;&gt;&lt;code&gt;NpyIter_RemoveMultiIndex&lt;/code&gt;&lt;/a&gt; is called. This function also resets the iterator to its initial state.</source>
          <target state="translated">Если был вызван &lt;a href=&quot;#c.NpyIter_RemoveMultiIndex&quot;&gt; &lt;code&gt;NpyIter_RemoveMultiIndex&lt;/code&gt; &lt;/a&gt; , вы можете включить флаг &lt;a href=&quot;#c.NPY_ITER_EXTERNAL_LOOP&quot;&gt; &lt;code&gt;NPY_ITER_EXTERNAL_LOOP&lt;/code&gt; &lt;/a&gt; . Этот флаг не разрешен вместе с &lt;a href=&quot;#c.NPY_ITER_MULTI_INDEX&quot;&gt; &lt;code&gt;NPY_ITER_MULTI_INDEX&lt;/code&gt; &lt;/a&gt; , поэтому эта функция предоставляется для включения функции после &lt;a href=&quot;#c.NpyIter_RemoveMultiIndex&quot;&gt; &lt;code&gt;NpyIter_RemoveMultiIndex&lt;/code&gt; &lt;/a&gt; . Эта функция также сбрасывает итератор в исходное состояние.</target>
        </trans-unit>
        <trans-unit id="1cac2a31adf2200c294f5c075bb6c153e55fa5a2" translate="yes" xml:space="preserve">
          <source>If &lt;a href=&quot;#c.PY_ARRAY_UNIQUE_SYMBOL&quot;&gt;&lt;code&gt;PY_ARRAY_UNIQUE_SYMBOL&lt;/code&gt;&lt;/a&gt; is #defined, but &lt;a href=&quot;#c.NO_IMPORT_ARRAY&quot;&gt;&lt;code&gt;NO_IMPORT_ARRAY&lt;/code&gt;&lt;/a&gt; is not, the C-API is declared to be &lt;code&gt;void**&lt;/code&gt;, so that it will also be visible to other compilation units.</source>
          <target state="translated">Если &lt;a href=&quot;#c.PY_ARRAY_UNIQUE_SYMBOL&quot;&gt; &lt;code&gt;PY_ARRAY_UNIQUE_SYMBOL&lt;/code&gt; &lt;/a&gt; имеет значение #defined, а &lt;a href=&quot;#c.NO_IMPORT_ARRAY&quot;&gt; &lt;code&gt;NO_IMPORT_ARRAY&lt;/code&gt; &lt;/a&gt; - нет, C-API объявляется &lt;code&gt;void**&lt;/code&gt; , поэтому он также будет виден другим модулям компиляции.</target>
        </trans-unit>
        <trans-unit id="b6b83b00b9ce96c4a5e91132daa4d55535f9e96d" translate="yes" xml:space="preserve">
          <source>If &lt;a href=&quot;numpy.dtype#numpy.dtype&quot;&gt;&lt;code&gt;dtype&lt;/code&gt;&lt;/a&gt; is set, array is copied only if dtype does not match:</source>
          <target state="translated">Если установлен &lt;a href=&quot;numpy.dtype#numpy.dtype&quot;&gt; &lt;code&gt;dtype&lt;/code&gt; &lt;/a&gt; , массив копируется, только если dtype не совпадает:</target>
        </trans-unit>
        <trans-unit id="4fc8bcfc9864193d76a4195dd238fe6624ed9a71" translate="yes" xml:space="preserve">
          <source>If &lt;a href=&quot;numpy.indices#numpy.indices&quot;&gt;&lt;code&gt;indices&lt;/code&gt;&lt;/a&gt; is not one dimensional, the output also has these dimensions.</source>
          <target state="translated">Если &lt;a href=&quot;numpy.indices#numpy.indices&quot;&gt; &lt;code&gt;indices&lt;/code&gt; &lt;/a&gt; не одномерные, выходные данные также имеют эти измерения.</target>
        </trans-unit>
        <trans-unit id="8d5ce8d43810f8659a3ffbe656fd3c96f0228399" translate="yes" xml:space="preserve">
          <source>If &lt;a href=&quot;numpy.matrix.data#numpy.matrix.data&quot;&gt;&lt;code&gt;data&lt;/code&gt;&lt;/a&gt; is a string, it is interpreted as a matrix with commas or spaces separating columns, and semicolons separating rows.</source>
          <target state="translated">Если &lt;a href=&quot;numpy.matrix.data#numpy.matrix.data&quot;&gt; &lt;code&gt;data&lt;/code&gt; &lt;/a&gt; являются строкой, они интерпретируются как матрица с запятыми или пробелами, разделяющими столбцы, и точками с запятой, разделяющими строки.</target>
        </trans-unit>
        <trans-unit id="006799ea3355b83be37fd21ad89f661aac343125" translate="yes" xml:space="preserve">
          <source>If &lt;a href=&quot;numpy.matrix.data#numpy.matrix.data&quot;&gt;&lt;code&gt;data&lt;/code&gt;&lt;/a&gt; is already an &lt;a href=&quot;numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;ndarray&lt;/code&gt;&lt;/a&gt;, then this flag determines whether the data is copied (the default), or whether a view is constructed.</source>
          <target state="translated">Если &lt;a href=&quot;numpy.matrix.data#numpy.matrix.data&quot;&gt; &lt;code&gt;data&lt;/code&gt; &lt;/a&gt; уже являются &lt;a href=&quot;numpy.ndarray#numpy.ndarray&quot;&gt; &lt;code&gt;ndarray&lt;/code&gt; &lt;/a&gt; , то этот флаг определяет, копируются ли данные (по умолчанию) или создается представление.</target>
        </trans-unit>
        <trans-unit id="3b197e7232928483bec23ab77c22b02eb5eeb910" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;A.ndim &amp;gt; d&lt;/code&gt;, &lt;code&gt;reps&lt;/code&gt; is promoted to &lt;code&gt;A&lt;/code&gt;.ndim by pre-pending 1&amp;rsquo;s to it. Thus for an &lt;code&gt;A&lt;/code&gt; of shape (2, 3, 4, 5), a &lt;code&gt;reps&lt;/code&gt; of (2, 2) is treated as (1, 1, 2, 2).</source>
          <target state="translated">Если &lt;code&gt;A.ndim &amp;gt; d&lt;/code&gt; , &lt;code&gt;reps&lt;/code&gt; повышается до &lt;code&gt;A&lt;/code&gt; .ndim путем предварительной установки 1. Таким образом, для &lt;code&gt;A&lt;/code&gt; формы (2, 3, 4, 5) &lt;code&gt;reps&lt;/code&gt; (2, 2) рассматриваются как (1, 1, 2, 2).</target>
        </trans-unit>
        <trans-unit id="dbe88f61ce8f631b9b28c692a7753b41fb5fe9e4" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;A.ndim &amp;lt; d&lt;/code&gt;, &lt;code&gt;A&lt;/code&gt; is promoted to be d-dimensional by prepending new axes. So a shape (3,) array is promoted to (1, 3) for 2-D replication, or shape (1, 1, 3) for 3-D replication. If this is not the desired behavior, promote &lt;code&gt;A&lt;/code&gt; to d-dimensions manually before calling this function.</source>
          <target state="translated">Если &lt;code&gt;A.ndim &amp;lt; d&lt;/code&gt; , &lt;code&gt;A&lt;/code&gt; становится d-мерным путем добавления новых осей. Таким образом, массив shape (3,) повышается до (1, 3) для 2-D репликации или shape (1, 1, 3) для 3-D репликации. Если это нежелательное поведение, перед вызовом этой функции продвиньте &lt;code&gt;A&lt;/code&gt; до размеров d вручную.</target>
        </trans-unit>
        <trans-unit id="7f85c71b217560bd561bde5602b4923ab34868ad" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;False&lt;/code&gt;, the result will contain the number of samples in each bin. If &lt;code&gt;True&lt;/code&gt;, the result is the value of the probability &lt;em&gt;density&lt;/em&gt; function at the bin, normalized such that the &lt;em&gt;integral&lt;/em&gt; over the range is 1. Note that the sum of the histogram values will not be equal to 1 unless bins of unity width are chosen; it is not a probability &lt;em&gt;mass&lt;/em&gt; function.</source>
          <target state="translated">Если &lt;code&gt;False&lt;/code&gt; , результат будет содержать количество образцов в каждой ячейке. Если &lt;code&gt;True&lt;/code&gt; , результатом будет значение функции &lt;em&gt;плотности&lt;/em&gt; вероятности в интервале , нормализованное таким образом, что &lt;em&gt;интеграл&lt;/em&gt; по диапазону равен 1. Обратите внимание, что сумма значений гистограммы не будет равна 1, если не выбраны интервалы с единичной шириной; это не функция &lt;em&gt;массы&lt;/em&gt; вероятности .</target>
        </trans-unit>
        <trans-unit id="ca7cba1e4456723daee790d09bd9b4e007a0b7f8" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;None&lt;/code&gt; (default), all constants are assumed to be zero. If &lt;code&gt;m = 1&lt;/code&gt;, a single scalar can be given instead of a list.</source>
          <target state="translated">Если &lt;code&gt;None&lt;/code&gt; (по умолчанию), предполагается, что все константы равны нулю. Если &lt;code&gt;m = 1&lt;/code&gt; , вместо списка можно указать один скаляр.</target>
        </trans-unit>
        <trans-unit id="aec21489ec4d901f1aa321dc3743c87fb290d768" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;True&lt;/code&gt;, swap bytes in-place, default is &lt;code&gt;False&lt;/code&gt;.</source>
          <target state="translated">Если &lt;code&gt;True&lt;/code&gt; , поменять байты местами, по умолчанию - &lt;code&gt;False&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f2e3fbb074311bdb46e2b67afbf7fb14e162de56" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;True&lt;/code&gt;, the cutoff of &lt;code&gt;precision&lt;/code&gt; digits refers to the total number of digits after the decimal point, including leading zeros. If &lt;code&gt;False&lt;/code&gt;, &lt;code&gt;precision&lt;/code&gt; refers to the total number of significant digits, before or after the decimal point, ignoring leading zeros.</source>
          <target state="translated">Если &lt;code&gt;True&lt;/code&gt; , отсечка цифр &lt;code&gt;precision&lt;/code&gt; относится к общему количеству цифр после десятичной точки, включая ведущие нули. Если &lt;code&gt;False&lt;/code&gt; , &lt;code&gt;precision&lt;/code&gt; относится к общему количеству значащих цифр до или после десятичной точки, игнорируя ведущие нули.</target>
        </trans-unit>
        <trans-unit id="a29f76a184d9fb35f364bb63d222c84be040ac5b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;True&lt;/code&gt;, then cache the first function call that determines the number of outputs if &lt;code&gt;otypes&lt;/code&gt; is not provided.</source>
          <target state="translated">Если &lt;code&gt;True&lt;/code&gt; , то &lt;code&gt;otypes&lt;/code&gt; первый вызов функции, который определяет количество выходов, если otypes не предоставлено.</target>
        </trans-unit>
        <trans-unit id="7faac3985b746b05ac26d42bd00cce4fcc2669d4" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;True&lt;/code&gt;, use a digit-generation strategy which gives the shortest representation which uniquely identifies the floating-point number from other values of the same type, by judicious rounding. If &lt;code&gt;precision&lt;/code&gt; was omitted, print all necessary digits, otherwise digit generation is cut off after &lt;code&gt;precision&lt;/code&gt; digits and the remaining value is rounded. If &lt;code&gt;False&lt;/code&gt;, digits are generated as if printing an infinite-precision value and stopping after &lt;code&gt;precision&lt;/code&gt; digits, rounding the remaining value.</source>
          <target state="translated">Если &lt;code&gt;True&lt;/code&gt; , используйте стратегию генерации цифр, которая дает кратчайшее представление, которое однозначно идентифицирует число с плавающей запятой от других значений того же типа путем разумного округления. Если &lt;code&gt;precision&lt;/code&gt; была опущена, выведите все необходимые цифры, в противном случае генерация цифр обрезается после цифр &lt;code&gt;precision&lt;/code&gt; а оставшееся значение округляется. Если &lt;code&gt;False&lt;/code&gt; , цифры генерируются так, как будто печатаются значения бесконечной точности и останавливаются после цифр &lt;code&gt;precision&lt;/code&gt; , округляя оставшееся значение.</target>
        </trans-unit>
        <trans-unit id="d46a903cfc558730b35e63368d27aca2360607f1" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;True&lt;/code&gt;, use a digit-generation strategy which gives the shortest representation which uniquely identifies the floating-point number from other values of the same type, by judicious rounding. If &lt;code&gt;precision&lt;/code&gt; was omitted, print out all necessary digits, otherwise digit generation is cut off after &lt;code&gt;precision&lt;/code&gt; digits and the remaining value is rounded. If &lt;code&gt;False&lt;/code&gt;, digits are generated as if printing an infinite-precision value and stopping after &lt;code&gt;precision&lt;/code&gt; digits, rounding the remaining value.</source>
          <target state="translated">Если &lt;code&gt;True&lt;/code&gt; , используйте стратегию генерации цифр, которая дает кратчайшее представление, которое однозначно идентифицирует число с плавающей запятой от других значений того же типа путем разумного округления. Если &lt;code&gt;precision&lt;/code&gt; была опущена, распечатайте все необходимые цифры, в противном случае генерация цифр обрезается после цифр &lt;code&gt;precision&lt;/code&gt; а оставшееся значение округляется. Если &lt;code&gt;False&lt;/code&gt; , цифры генерируются так, как будто печатаются значения бесконечной точности и останавливаются после цифр &lt;code&gt;precision&lt;/code&gt; , округляя оставшееся значение.</target>
        </trans-unit>
        <trans-unit id="e630a68b772e53281799a75b2daa484538be6573" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;V = chebvander2d(x, y, [xdeg, ydeg])&lt;/code&gt;, then the columns of &lt;code&gt;V&lt;/code&gt; correspond to the elements of a 2-D coefficient array &lt;code&gt;c&lt;/code&gt; of shape (xdeg + 1, ydeg + 1) in the order</source>
          <target state="translated">Если &lt;code&gt;V = chebvander2d(x, y, [xdeg, ydeg])&lt;/code&gt; , то столбцы &lt;code&gt;V&lt;/code&gt; соответствуют элементам двумерного массива коэффициентов &lt;code&gt;c&lt;/code&gt; формы (xdeg + 1, ydeg + 1) в порядке</target>
        </trans-unit>
        <trans-unit id="8cbfd70f5cc4a9c80c1b3f4ac628ba80decf75d4" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;V = chebvander3d(x, y, z, [xdeg, ydeg, zdeg])&lt;/code&gt;, then the columns of &lt;code&gt;V&lt;/code&gt; correspond to the elements of a 3-D coefficient array &lt;code&gt;c&lt;/code&gt; of shape (xdeg + 1, ydeg + 1, zdeg + 1) in the order</source>
          <target state="translated">Если &lt;code&gt;V = chebvander3d(x, y, z, [xdeg, ydeg, zdeg])&lt;/code&gt; , то столбцы &lt;code&gt;V&lt;/code&gt; соответствуют элементам массива трехмерных коэффициентов &lt;code&gt;c&lt;/code&gt; формы (xdeg + 1, ydeg + 1, zdeg + 1) в порядке</target>
        </trans-unit>
        <trans-unit id="00bfc10fc177e8c4f7b6b34693c411592fe272c6" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;V = hermevander2d(x, y, [xdeg, ydeg])&lt;/code&gt;, then the columns of &lt;code&gt;V&lt;/code&gt; correspond to the elements of a 2-D coefficient array &lt;code&gt;c&lt;/code&gt; of shape (xdeg + 1, ydeg + 1) in the order</source>
          <target state="translated">Если &lt;code&gt;V = hermevander2d(x, y, [xdeg, ydeg])&lt;/code&gt; , то столбцы &lt;code&gt;V&lt;/code&gt; соответствуют элементам двумерного массива коэффициентов &lt;code&gt;c&lt;/code&gt; формы (xdeg + 1, ydeg + 1) в порядке</target>
        </trans-unit>
        <trans-unit id="a7c811e070f694575d65f49ba72909eaec417a6f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;V = hermevander3d(x, y, z, [xdeg, ydeg, zdeg])&lt;/code&gt;, then the columns of &lt;code&gt;V&lt;/code&gt; correspond to the elements of a 3-D coefficient array &lt;code&gt;c&lt;/code&gt; of shape (xdeg + 1, ydeg + 1, zdeg + 1) in the order</source>
          <target state="translated">Если &lt;code&gt;V = hermevander3d(x, y, z, [xdeg, ydeg, zdeg])&lt;/code&gt; , то столбцы &lt;code&gt;V&lt;/code&gt; соответствуют элементам массива трехмерных коэффициентов &lt;code&gt;c&lt;/code&gt; формы (xdeg + 1, ydeg + 1, zdeg + 1) в порядке</target>
        </trans-unit>
        <trans-unit id="262fc8f05dc54d641c4705041f46d8b6c771c1fb" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;V = hermvander2d(x, y, [xdeg, ydeg])&lt;/code&gt;, then the columns of &lt;code&gt;V&lt;/code&gt; correspond to the elements of a 2-D coefficient array &lt;code&gt;c&lt;/code&gt; of shape (xdeg + 1, ydeg + 1) in the order</source>
          <target state="translated">Если &lt;code&gt;V = hermvander2d(x, y, [xdeg, ydeg])&lt;/code&gt; , то столбцы &lt;code&gt;V&lt;/code&gt; соответствуют элементам двумерного массива коэффициентов &lt;code&gt;c&lt;/code&gt; формы (xdeg + 1, ydeg + 1) в порядке</target>
        </trans-unit>
        <trans-unit id="066ad3b1f4c835bc91d8b4d1ca954772c0457a46" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;V = hermvander3d(x, y, z, [xdeg, ydeg, zdeg])&lt;/code&gt;, then the columns of &lt;code&gt;V&lt;/code&gt; correspond to the elements of a 3-D coefficient array &lt;code&gt;c&lt;/code&gt; of shape (xdeg + 1, ydeg + 1, zdeg + 1) in the order</source>
          <target state="translated">Если &lt;code&gt;V = hermvander3d(x, y, z, [xdeg, ydeg, zdeg])&lt;/code&gt; , то столбцы &lt;code&gt;V&lt;/code&gt; соответствуют элементам массива &lt;code&gt;c&lt;/code&gt; трехмерных коэффициентов формы (xdeg + 1, ydeg + 1, zdeg + 1) в порядке</target>
        </trans-unit>
        <trans-unit id="6596fc02b05eb1b57c388bcee28f45c0fa647e79" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;V = lagvander2d(x, y, [xdeg, ydeg])&lt;/code&gt;, then the columns of &lt;code&gt;V&lt;/code&gt; correspond to the elements of a 2-D coefficient array &lt;code&gt;c&lt;/code&gt; of shape (xdeg + 1, ydeg + 1) in the order</source>
          <target state="translated">Если &lt;code&gt;V = lagvander2d(x, y, [xdeg, ydeg])&lt;/code&gt; , то столбцы &lt;code&gt;V&lt;/code&gt; соответствуют элементам двумерного массива коэффициентов &lt;code&gt;c&lt;/code&gt; формы (xdeg + 1, ydeg + 1) в порядке</target>
        </trans-unit>
        <trans-unit id="658f3ceb580a0341f1c8e14be933e5829c9b95b9" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;V = lagvander3d(x, y, z, [xdeg, ydeg, zdeg])&lt;/code&gt;, then the columns of &lt;code&gt;V&lt;/code&gt; correspond to the elements of a 3-D coefficient array &lt;code&gt;c&lt;/code&gt; of shape (xdeg + 1, ydeg + 1, zdeg + 1) in the order</source>
          <target state="translated">Если &lt;code&gt;V = lagvander3d(x, y, z, [xdeg, ydeg, zdeg])&lt;/code&gt; , то столбцы &lt;code&gt;V&lt;/code&gt; соответствуют элементам массива трехмерных коэффициентов &lt;code&gt;c&lt;/code&gt; формы (xdeg + 1, ydeg + 1, zdeg + 1) в порядке</target>
        </trans-unit>
        <trans-unit id="102bddd53317314797d80d0b03e0de44ee8eec62" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;V = legvander2d(x, y, [xdeg, ydeg])&lt;/code&gt;, then the columns of &lt;code&gt;V&lt;/code&gt; correspond to the elements of a 2-D coefficient array &lt;code&gt;c&lt;/code&gt; of shape (xdeg + 1, ydeg + 1) in the order</source>
          <target state="translated">Если &lt;code&gt;V = legvander2d(x, y, [xdeg, ydeg])&lt;/code&gt; , то столбцы &lt;code&gt;V&lt;/code&gt; соответствуют элементам двумерного массива коэффициентов &lt;code&gt;c&lt;/code&gt; формы (xdeg + 1, ydeg + 1) в порядке</target>
        </trans-unit>
        <trans-unit id="f9e4383801f2b61b08f9300b1b7fdf17e1c3f488" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;V = legvander3d(x, y, z, [xdeg, ydeg, zdeg])&lt;/code&gt;, then the columns of &lt;code&gt;V&lt;/code&gt; correspond to the elements of a 3-D coefficient array &lt;code&gt;c&lt;/code&gt; of shape (xdeg + 1, ydeg + 1, zdeg + 1) in the order</source>
          <target state="translated">Если &lt;code&gt;V = legvander3d(x, y, z, [xdeg, ydeg, zdeg])&lt;/code&gt; , то столбцы &lt;code&gt;V&lt;/code&gt; соответствуют элементам массива трехмерных коэффициентов &lt;code&gt;c&lt;/code&gt; формы (xdeg + 1, ydeg + 1, zdeg + 1) в порядке</target>
        </trans-unit>
        <trans-unit id="c691cf5dd3bcc26326919122a716b1456743d83e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;V = polyvander2d(x, y, [xdeg, ydeg])&lt;/code&gt;, then the columns of &lt;code&gt;V&lt;/code&gt; correspond to the elements of a 2-D coefficient array &lt;code&gt;c&lt;/code&gt; of shape (xdeg + 1, ydeg + 1) in the order</source>
          <target state="translated">Если &lt;code&gt;V = polyvander2d(x, y, [xdeg, ydeg])&lt;/code&gt; , то столбцы &lt;code&gt;V&lt;/code&gt; соответствуют элементам двумерного массива коэффициентов &lt;code&gt;c&lt;/code&gt; формы (xdeg + 1, ydeg + 1) в порядке</target>
        </trans-unit>
        <trans-unit id="3795a0fc387856e1a4fb9463ff23e8e2dc033c86" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;V = polyvander3d(x, y, z, [xdeg, ydeg, zdeg])&lt;/code&gt;, then the columns of &lt;code&gt;V&lt;/code&gt; correspond to the elements of a 3-D coefficient array &lt;code&gt;c&lt;/code&gt; of shape (xdeg + 1, ydeg + 1, zdeg + 1) in the order</source>
          <target state="translated">Если &lt;code&gt;V = polyvander3d(x, y, z, [xdeg, ydeg, zdeg])&lt;/code&gt; , то столбцы &lt;code&gt;V&lt;/code&gt; соответствуют элементам массива трехмерных коэффициентов &lt;code&gt;c&lt;/code&gt; формы (xdeg + 1, ydeg + 1, zdeg + 1) в порядке</target>
        </trans-unit>
        <trans-unit id="f8959bef2f1f180cd1904ca3003b3eeaecf0bbcb" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;a.fill_value == b.fill_value&lt;/code&gt;, return the fill value, otherwise return None.</source>
          <target state="translated">Если &lt;code&gt;a.fill_value == b.fill_value&lt;/code&gt; , вернуть значение заполнения, иначе вернуть None.</target>
        </trans-unit>
        <trans-unit id="8f6e1a60280ed3603677c79dbcdebfa7ff398c42" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;a.ndim &amp;gt; 2&lt;/code&gt;, then the dimensions specified by &lt;code&gt;axis1&lt;/code&gt; and &lt;code&gt;axis2&lt;/code&gt; are removed, and a new axis inserted at the end corresponding to the diagonal.</source>
          <target state="translated">Если &lt;code&gt;a.ndim &amp;gt; 2&lt;/code&gt; , то размеры, указанные в параметрах &lt;code&gt;axis1&lt;/code&gt; и &lt;code&gt;axis2&lt;/code&gt; , удаляются, и новая ось вставляется в конце, соответствующем диагонали.</target>
        </trans-unit>
        <trans-unit id="64c4131bb0fe8a413fc2bc1ebe219f3e36ea1e9b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;a.ndim&lt;/code&gt; is 0, then since the depth of the nested list is 0, it will not be a list at all, but a simple Python scalar.</source>
          <target state="translated">Если &lt;code&gt;a.ndim&lt;/code&gt; равно 0, то, поскольку глубина вложенного списка равна 0, это будет вовсе не список, а простой скаляр Python.</target>
        </trans-unit>
        <trans-unit id="355d7bac3059f5072f60fecea5ae0b7d9ef0b74d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;a.shape&lt;/code&gt; is (5,1), &lt;code&gt;b.shape&lt;/code&gt; is (1,6), &lt;code&gt;c.shape&lt;/code&gt; is (6,) and &lt;code&gt;d.shape&lt;/code&gt; is () so that &lt;em&gt;d&lt;/em&gt; is a scalar, then &lt;em&gt;a&lt;/em&gt;, &lt;em&gt;b&lt;/em&gt;, &lt;em&gt;c&lt;/em&gt;, and &lt;em&gt;d&lt;/em&gt; are all broadcastable to dimension (5,6); and</source>
          <target state="translated">Если &lt;code&gt;a.shape&lt;/code&gt; равно (5,1), &lt;code&gt;b.shape&lt;/code&gt; равно (1,6), &lt;code&gt;c.shape&lt;/code&gt; равно (6,) и &lt;code&gt;d.shape&lt;/code&gt; равно (), так что &lt;em&gt;d&lt;/em&gt; является скаляром, то &lt;em&gt;a&lt;/em&gt; , &lt;em&gt;b&lt;/em&gt; , &lt;em&gt;c&lt;/em&gt; , и &lt;em&gt;d&lt;/em&gt; все транслируются в размер (5,6); и</target>
        </trans-unit>
        <trans-unit id="61914428b3107b079ee31cfc27e080d8a722c6a3" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; are nonscalar, their last dimensions must match.</source>
          <target state="translated">Если &lt;code&gt;a&lt;/code&gt; и &lt;code&gt;b&lt;/code&gt; нескалярные, их последние измерения должны совпадать.</target>
        </trans-unit>
        <trans-unit id="b4f4e526a35a19438379df1f3dbff9a3882d194d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;a&lt;/code&gt; and each choice array are not all broadcastable to the same shape.</source>
          <target state="translated">Если &lt;code&gt;a&lt;/code&gt; и каждый массив выбора не все транслируются в одну и ту же форму.</target>
        </trans-unit>
        <trans-unit id="6714bc3434562dda36e8035d926f1d408c7a5936" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;a&lt;/code&gt; does not own its own data or references or views to it exist, and the data memory must be changed. PyPy only: will always raise if the data memory must be changed, since there is no reliable way to determine if references or views to it exist.</source>
          <target state="translated">Если &lt;code&gt;a&lt;/code&gt; не владеет своими собственными данными, либо существуют ссылки или представления на него, необходимо изменить память данных. Только PyPy: всегда будет увеличиваться, если необходимо изменить память данных, поскольку нет надежного способа определить, существуют ли ссылки или представления на нее.</target>
        </trans-unit>
        <trans-unit id="d46ad13c1a8181bf81ec49d29f19d0a4e8222929" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;a&lt;/code&gt; has more than two dimensions, then broadcasting rules apply, as explained in &lt;a href=&quot;../routines.linalg#routines-linalg-broadcasting&quot;&gt;Linear algebra on several matrices at once&lt;/a&gt;. This means that SVD is working in &amp;ldquo;stacked&amp;rdquo; mode: it iterates over all indices of the first &lt;code&gt;a.ndim - 2&lt;/code&gt; dimensions and for each combination SVD is applied to the last two indices. The matrix &lt;code&gt;a&lt;/code&gt; can be reconstructed from the decomposition with either &lt;code&gt;(u * s[..., None, :]) @ vh&lt;/code&gt; or &lt;code&gt;u @ (s[..., None] * vh)&lt;/code&gt;. (The &lt;code&gt;@&lt;/code&gt; operator can be replaced by the function &lt;code&gt;np.matmul&lt;/code&gt; for python versions below 3.5.)</source>
          <target state="translated">Если &lt;code&gt;a&lt;/code&gt; имеет более двух измерений, тогда применяются правила широковещательной передачи, как описано в &lt;a href=&quot;../routines.linalg#routines-linalg-broadcasting&quot;&gt;Линейной алгебре, для нескольких матриц одновременно&lt;/a&gt; . Это означает, что SVD работает в &amp;laquo;сложенном&amp;raquo; режиме: он выполняет итерацию по всем индексам первого &lt;code&gt;a.ndim - 2&lt;/code&gt; и для каждой комбинации SVD применяется к последним двум индексам. Матрица &lt;code&gt;a&lt;/code&gt; может быть восстановлена ​​из разложения с помощью &lt;code&gt;(u * s[..., None, :]) @ vh&lt;/code&gt; или &lt;code&gt;u @ (s[..., None] * vh)&lt;/code&gt; . (Оператор &lt;code&gt;@&lt;/code&gt; может быть заменен функцией &lt;code&gt;np.matmul&lt;/code&gt; для версий Python ниже 3.5.)</target>
        </trans-unit>
        <trans-unit id="0f5e97c2878caebdac54716045091816869ce6d1" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;a&lt;/code&gt; has more than two dimensions, then the axes specified by axis1 and axis2 are used to determine the 2-D sub-arrays whose traces are returned. The shape of the resulting array is the same as that of &lt;code&gt;a&lt;/code&gt; with &lt;code&gt;axis1&lt;/code&gt; and &lt;code&gt;axis2&lt;/code&gt; removed.</source>
          <target state="translated">Если &lt;code&gt;a&lt;/code&gt; имеет более двух измерений, то оси, указанные в параметрах axis1 и axis2, используются для определения двумерных подмассивов, трассы которых возвращаются. Форма результирующего массива одно и то же, что и с &lt;code&gt;axis1&lt;/code&gt; и &lt;code&gt;axis2&lt;/code&gt; удалены. &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="1b46ead587370435670ac4bc03b81d9c95e42b33" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;a&lt;/code&gt; is 1-D, the function &lt;code&gt;ufunc.accumulate(a)&lt;/code&gt; is the same as &lt;code&gt;ufunc.reduceat(a, indices)[::2]&lt;/code&gt; where &lt;a href=&quot;numpy.indices#numpy.indices&quot;&gt;&lt;code&gt;indices&lt;/code&gt;&lt;/a&gt; is &lt;code&gt;range(len(array) - 1)&lt;/code&gt; with a zero placed in every other element: &lt;code&gt;indices = zeros(2 * len(a) - 1)&lt;/code&gt;, &lt;code&gt;indices[1::2] = range(1, len(a))&lt;/code&gt;.</source>
          <target state="translated">Если &lt;code&gt;a&lt;/code&gt; 1-D, функция &lt;code&gt;ufunc.accumulate(a)&lt;/code&gt; совпадает с &lt;code&gt;ufunc.reduceat(a, indices)[::2]&lt;/code&gt; где &lt;a href=&quot;numpy.indices#numpy.indices&quot;&gt; &lt;code&gt;indices&lt;/code&gt; &lt;/a&gt; - это &lt;code&gt;range(len(array) - 1)&lt;/code&gt; с нулем, помещенным в каждый другой элемент: &lt;code&gt;indices = zeros(2 * len(a) - 1)&lt;/code&gt; , &lt;code&gt;indices[1::2] = range(1, len(a))&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7b8db921b8261a5150c028a4a52e2a78422e254b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;a&lt;/code&gt; is 2-D, returns the diagonal of &lt;code&gt;a&lt;/code&gt; with the given offset, i.e., the collection of elements of the form &lt;code&gt;a[i, i+offset]&lt;/code&gt;. If &lt;code&gt;a&lt;/code&gt; has more than two dimensions, then the axes specified by &lt;code&gt;axis1&lt;/code&gt; and &lt;code&gt;axis2&lt;/code&gt; are used to determine the 2-D sub-array whose diagonal is returned. The shape of the resulting array can be determined by removing &lt;code&gt;axis1&lt;/code&gt; and &lt;code&gt;axis2&lt;/code&gt; and appending an index to the right equal to the size of the resulting diagonals.</source>
          <target state="translated">Если &lt;code&gt;a&lt;/code&gt; 2-D, возвращает диагональ &lt;code&gt;a&lt;/code&gt; с заданным смещением, т. Е. Набор элементов формы &lt;code&gt;a[i, i+offset]&lt;/code&gt; . Если &lt;code&gt;a&lt;/code&gt; имеет более двух измерений, то оси, указанные в параметрах &lt;code&gt;axis1&lt;/code&gt; и &lt;code&gt;axis2&lt;/code&gt; , используются для определения двумерного подмассива , диагональ которого возвращается. Форму полученного массива можно определить, удалив &lt;code&gt;axis1&lt;/code&gt; и &lt;code&gt;axis2&lt;/code&gt; и добавив справа индекс, равный размеру полученных диагоналей.</target>
        </trans-unit>
        <trans-unit id="016f6a15e05ea7909f939f7c56abdd96bd940bcc" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;a&lt;/code&gt; is 2-D, the sum along its diagonal with the given offset is returned, i.e., the sum of elements &lt;code&gt;a[i,i+offset]&lt;/code&gt; for all i.</source>
          <target state="translated">Если &lt;code&gt;a&lt;/code&gt; 2-D, возвращается сумма по его диагонали с заданным смещением, то есть сумма элементов &lt;code&gt;a[i,i+offset]&lt;/code&gt; для всех i.</target>
        </trans-unit>
        <trans-unit id="821330dbafd930ef241f18ef291a677b001e3d1c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;a&lt;/code&gt; is 2-D, the sum along the diagonal is returned. If &lt;code&gt;a&lt;/code&gt; has larger dimensions, then an array of sums along diagonals is returned.</source>
          <target state="translated">Если &lt;code&gt;a&lt;/code&gt; 2-D, возвращается сумма по диагонали. Если имеет большие размеры, то массив сумм вдоль диагоналей возвращается. &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="20e0991e165d15052f7414c1d9067709a6741ba8" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;a&lt;/code&gt; is 2-D, then a 1-D array containing the diagonal and of the same type as &lt;code&gt;a&lt;/code&gt; is returned unless &lt;code&gt;a&lt;/code&gt; is a &lt;a href=&quot;numpy.matrix#numpy.matrix&quot;&gt;&lt;code&gt;matrix&lt;/code&gt;&lt;/a&gt;, in which case a 1-D array rather than a (2-D) &lt;a href=&quot;numpy.matrix#numpy.matrix&quot;&gt;&lt;code&gt;matrix&lt;/code&gt;&lt;/a&gt; is returned in order to maintain backward compatibility.</source>
          <target state="translated">Если 2-Д, а затем 1-D массив А , содержащий диагонали и того же типа , как возвращается , если не является &lt;a href=&quot;numpy.matrix#numpy.matrix&quot;&gt; &lt;code&gt;matrix&lt;/code&gt; &lt;/a&gt; , в этом случае 1-D массив , а не (2-D) , &lt;a href=&quot;numpy.matrix#numpy.matrix&quot;&gt; &lt;code&gt;matrix&lt;/code&gt; &lt;/a&gt; возвращается для сохранения обратной совместимости. &lt;code&gt;a&lt;/code&gt; &lt;code&gt;a&lt;/code&gt; &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="65772464bb82fc9b6e011b51f1c71a9673e3a5fb" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;a&lt;/code&gt; is a &lt;code&gt;matrix&lt;/code&gt; object (as opposed to an &lt;code&gt;ndarray&lt;/code&gt;), then so are all the return values.</source>
          <target state="translated">Если &lt;code&gt;a&lt;/code&gt; является &lt;code&gt;matrix&lt;/code&gt; объектом (в отличие от &lt;code&gt;ndarray&lt;/code&gt; ), то все возвращаемые значения также.</target>
        </trans-unit>
        <trans-unit id="edeed84f3c81e9ebf31ecd438474825302f801e2" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;a&lt;/code&gt; is a subclass of &lt;a href=&quot;../maskedarray.baseclass#numpy.ma.MaskedArray&quot;&gt;&lt;code&gt;MaskedArray&lt;/code&gt;&lt;/a&gt;, its class is conserved. No copy is performed if the input is already an &lt;code&gt;ndarray&lt;/code&gt;.</source>
          <target state="translated">Если &lt;code&gt;a&lt;/code&gt; является подклассом &lt;a href=&quot;../maskedarray.baseclass#numpy.ma.MaskedArray&quot;&gt; &lt;code&gt;MaskedArray&lt;/code&gt; &lt;/a&gt; , его класс сохраняется. Копирование не выполняется, если ввод уже является &lt;code&gt;ndarray&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="79b3d97ca6a58beeb5178bade7556181ec643eb5" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;a&lt;/code&gt; is an N-D array and &lt;code&gt;b&lt;/code&gt; is a 1-D array, it is a sum product over the last axis of &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt;.</source>
          <target state="translated">Если &lt;code&gt;a&lt;/code&gt; является массивом ND, а &lt;code&gt;b&lt;/code&gt; - одномерным массивом, это произведение суммы по последней оси &lt;code&gt;a&lt;/code&gt; и &lt;code&gt;b&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="41bd115d2530c0df6f893d58055a4e7bbeb51a86" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;a&lt;/code&gt; is an N-D array and &lt;code&gt;b&lt;/code&gt; is an M-D array (where &lt;code&gt;M&amp;gt;=2&lt;/code&gt;), it is a sum product over the last axis of &lt;code&gt;a&lt;/code&gt; and the second-to-last axis of &lt;code&gt;b&lt;/code&gt;:</source>
          <target state="translated">Если &lt;code&gt;a&lt;/code&gt; - массив ND, а &lt;code&gt;b&lt;/code&gt; - массив MD (где &lt;code&gt;M&amp;gt;=2&lt;/code&gt; ), это сумма произведения по последней оси &lt;code&gt;a&lt;/code&gt; и предпоследней оси &lt;code&gt;b&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="e2d3d6c358f256f08097a63c0a16dbce473bc638" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;a&lt;/code&gt; is complex the complex conjugate is taken before calculation of the dot product.</source>
          <target state="translated">Если &lt;code&gt;a&lt;/code&gt; является комплексным, комплексное сопряжение берется перед вычислением скалярного произведения.</target>
        </trans-unit>
        <trans-unit id="eccde6fba477d4d0328834eeb9139f4c209a7f8b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;a&lt;/code&gt; is not a &lt;a href=&quot;../maskedarray.baseclass#numpy.ma.MaskedArray&quot;&gt;&lt;code&gt;MaskedArray&lt;/code&gt;&lt;/a&gt;, &lt;code&gt;a&lt;/code&gt; itself is returned. If &lt;code&gt;a&lt;/code&gt; is a &lt;a href=&quot;../maskedarray.baseclass#numpy.ma.MaskedArray&quot;&gt;&lt;code&gt;MaskedArray&lt;/code&gt;&lt;/a&gt; and &lt;code&gt;fill_value&lt;/code&gt; is None, &lt;code&gt;fill_value&lt;/code&gt; is set to &lt;code&gt;a.fill_value&lt;/code&gt;.</source>
          <target state="translated">Если &lt;code&gt;a&lt;/code&gt; не является &lt;a href=&quot;../maskedarray.baseclass#numpy.ma.MaskedArray&quot;&gt; &lt;code&gt;MaskedArray&lt;/code&gt; &lt;/a&gt; , возвращается сам &lt;code&gt;a&lt;/code&gt; . Если &lt;code&gt;a&lt;/code&gt; - &lt;a href=&quot;../maskedarray.baseclass#numpy.ma.MaskedArray&quot;&gt; &lt;code&gt;MaskedArray&lt;/code&gt; ,&lt;/a&gt; а &lt;code&gt;fill_value&lt;/code&gt; - None, &lt;code&gt;fill_value&lt;/code&gt; устанавливается в &lt;code&gt;a.fill_value&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7ac306a4eb2b5b20798f61a7b119dddd329017ce" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;a&lt;/code&gt; is not square or inversion fails.</source>
          <target state="translated">Если &lt;code&gt;a&lt;/code&gt; не квадрат или инверсия не выполняется.</target>
        </trans-unit>
        <trans-unit id="dc36615c1be692990452f6adc2c02bec7979d9d1" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;a&lt;/code&gt; is real, the type of &lt;code&gt;a&lt;/code&gt; is used for the output. If &lt;code&gt;a&lt;/code&gt; has complex elements, the returned type is float.</source>
          <target state="translated">Если &lt;code&gt;a&lt;/code&gt; действительно, для вывода используется тип &lt;code&gt;a&lt;/code&gt; . Если у &lt;code&gt;a&lt;/code&gt; есть сложные элементы, возвращаемый тип - float.</target>
        </trans-unit>
        <trans-unit id="49742c1cee8e9efafb1c7fbbe431a8e95469bbc0" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;a&lt;/code&gt; is singular or not &amp;lsquo;square&amp;rsquo; (in the above sense).</source>
          <target state="translated">Если &lt;code&gt;a&lt;/code&gt; - единственное число или не &amp;laquo;квадрат&amp;raquo; (в указанном выше смысле).</target>
        </trans-unit>
        <trans-unit id="2e9b74892f6f35d0326c1dc235300557d874f5a4" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;a&lt;/code&gt; is singular or not square.</source>
          <target state="translated">Если &lt;code&gt;a&lt;/code&gt; - единичный или не квадратный.</target>
        </trans-unit>
        <trans-unit id="18f554f1ca3b0160e94e964322795aa916ef0365" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;arr&lt;/code&gt; doesn&amp;rsquo;t have a shape attribute (i.e. not an ndarray)</source>
          <target state="translated">Если &lt;code&gt;arr&lt;/code&gt; не имеет атрибута shape (т.е. не ndarray)</target>
        </trans-unit>
        <trans-unit id="6f94c014869b41cb6e3e090bab6cec3fc3652e46" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;axes&lt;/code&gt; is larger than the last axis of &lt;code&gt;a&lt;/code&gt;.</source>
          <target state="translated">Если &lt;code&gt;axes&lt;/code&gt; больше, чем последняя ось &lt;code&gt;a&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="fb5967cac1f9c838f629289b9701f4f5d967c63e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;axis&lt;/code&gt; is 0, only rows are masked.</source>
          <target state="translated">Если &lt;code&gt;axis&lt;/code&gt; 0, маскируются только строки.</target>
        </trans-unit>
        <trans-unit id="e77d1c339b65acf6a89a949d1d50328c8561be33" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;axis&lt;/code&gt; is 1 or -1, only columns are masked.</source>
          <target state="translated">Если &lt;code&gt;axis&lt;/code&gt; 1 или -1, маскируются только столбцы.</target>
        </trans-unit>
        <trans-unit id="527dba2aee917b7e820a9015382f439872829fc2" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;axis&lt;/code&gt; is None, rows &lt;em&gt;and&lt;/em&gt; columns are masked.</source>
          <target state="translated">Если &lt;code&gt;axis&lt;/code&gt; None, строки &lt;em&gt;и&lt;/em&gt; столбцы маскируются.</target>
        </trans-unit>
        <trans-unit id="042bc001a4914cd7d0d232c6f0fb346989909740" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;axis&lt;/code&gt; is an integer, it specifies the axis of &lt;code&gt;x&lt;/code&gt; along which to compute the vector norms. If &lt;code&gt;axis&lt;/code&gt; is a 2-tuple, it specifies the axes that hold 2-D matrices, and the matrix norms of these matrices are computed. If &lt;code&gt;axis&lt;/code&gt; is None then either a vector norm (when &lt;code&gt;x&lt;/code&gt; is 1-D) or a matrix norm (when &lt;code&gt;x&lt;/code&gt; is 2-D) is returned.</source>
          <target state="translated">Если &lt;code&gt;axis&lt;/code&gt; является целым числом, она указывает ось &lt;code&gt;x&lt;/code&gt; , по которой вычисляются векторные нормы. Если &lt;code&gt;axis&lt;/code&gt; является двумерным кортежем, она определяет оси, которые содержат двумерные матрицы, и вычисляются матричные нормы этих матриц. Если &lt;code&gt;axis&lt;/code&gt; None, то возвращается либо векторная норма (когда &lt;code&gt;x&lt;/code&gt; равно 1-D), либо матричная норма (когда &lt;code&gt;x&lt;/code&gt; равно 2-D).</target>
        </trans-unit>
        <trans-unit id="523d86ecb59b40a9d925f2a1e78fa6cb76926a2b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;axis&lt;/code&gt; is given, the number of varargs must equal the number of axes. Default: 1.</source>
          <target state="translated">Если указана &lt;code&gt;axis&lt;/code&gt; , количество переменных должно равняться количеству осей. По умолчанию: 1.</target>
        </trans-unit>
        <trans-unit id="86e33ec8c24f94e2430b0659a5ab81a91a91d564" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;axis&lt;/code&gt; is larger than the last axis of &lt;code&gt;a&lt;/code&gt;.</source>
          <target state="translated">Если &lt;code&gt;axis&lt;/code&gt; больше последней оси &lt;code&gt;a&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b10999639108c4b4999de59d1e8da7d5676f431c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;axis&lt;/code&gt; is not &lt;code&gt;None&lt;/code&gt;, and an axis being squeezed is not of length 1</source>
          <target state="translated">Если &lt;code&gt;axis&lt;/code&gt; не равна &lt;code&gt;None&lt;/code&gt; , а длина сжимаемой оси не равна 1</target>
        </trans-unit>
        <trans-unit id="b1ba1d797cf86b71e14a5b8da31b21199908a909" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;b&lt;/code&gt; is a matrix, then all array results are returned as matrices.</source>
          <target state="translated">Если &lt;code&gt;b&lt;/code&gt; является матрицей, то все результаты массива возвращаются как матрицы.</target>
        </trans-unit>
        <trans-unit id="ca0b482dcb07a6085a21a5bc1b0dde224b2f172c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;bins&lt;/code&gt; is a string from the list below, &lt;a href=&quot;#numpy.histogram_bin_edges&quot;&gt;&lt;code&gt;histogram_bin_edges&lt;/code&gt;&lt;/a&gt; will use the method chosen to calculate the optimal bin width and consequently the number of bins (see &lt;code&gt;Notes&lt;/code&gt; for more detail on the estimators) from the data that falls within the requested range. While the bin width will be optimal for the actual data in the range, the number of bins will be computed to fill the entire range, including the empty portions. For visualisation, using the &amp;lsquo;auto&amp;rsquo; option is suggested. Weighted data is not supported for automated bin size selection.</source>
          <target state="translated">Если &lt;code&gt;bins&lt;/code&gt; - это строка из списка ниже, &lt;a href=&quot;#numpy.histogram_bin_edges&quot;&gt; &lt;code&gt;histogram_bin_edges&lt;/code&gt; &lt;/a&gt; будет использовать метод, выбранный для вычисления оптимальной ширины ячейки и, следовательно, количества ячеек (см. &lt;code&gt;Notes&lt;/code&gt; для получения более подробной информации об оценках) из данных, которые попадают в запрошенный диапазон. Хотя ширина бункера будет оптимальной для фактических данных в диапазоне, количество бинов будет вычислено для заполнения всего диапазона, включая пустые части. Для визуализации предлагается использовать опцию &amp;laquo;авто&amp;raquo;. Взвешенные данные не поддерживаются для автоматического выбора размера корзины.</target>
        </trans-unit>
        <trans-unit id="b70a91ff0eb4c89d18a81d985f393eb13ac7933f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;bins&lt;/code&gt; is a string, it defines the method used to calculate the optimal bin width, as defined by &lt;a href=&quot;numpy.histogram_bin_edges#numpy.histogram_bin_edges&quot;&gt;&lt;code&gt;histogram_bin_edges&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Если &lt;code&gt;bins&lt;/code&gt; является строкой, она определяет метод, используемый для вычисления оптимальной ширины ячейки, как определено в &lt;a href=&quot;numpy.histogram_bin_edges#numpy.histogram_bin_edges&quot;&gt; &lt;code&gt;histogram_bin_edges&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="cbffbf31546ec9af5b6fd778dfc3e0a7e49fc75c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;bins&lt;/code&gt; is an int, it defines the number of equal-width bins in the given range (10, by default). If &lt;code&gt;bins&lt;/code&gt; is a sequence, it defines a monotonically increasing array of bin edges, including the rightmost edge, allowing for non-uniform bin widths.</source>
          <target state="translated">Если &lt;code&gt;bins&lt;/code&gt; имеет тип int, он определяет количество интервалов одинаковой ширины в заданном диапазоне (по умолчанию 10). Если &lt;code&gt;bins&lt;/code&gt; представляют собой последовательность, она определяет монотонно увеличивающийся массив краев бункеров , включая крайний правый край, что позволяет использовать неоднородную ширину бинов.</target>
        </trans-unit>
        <trans-unit id="b4024bb04b779936a7803a2173c03bd8c96f6ec1" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;bins&lt;/code&gt; is an int, it defines the number of equal-width bins in the given range (10, by default). If &lt;code&gt;bins&lt;/code&gt; is a sequence, it defines the bin edges, including the rightmost edge, allowing for non-uniform bin widths.</source>
          <target state="translated">Если &lt;code&gt;bins&lt;/code&gt; имеет тип int, он определяет количество интервалов одинаковой ширины в заданном диапазоне (по умолчанию 10). Если &lt;code&gt;bins&lt;/code&gt; представляют собой последовательность, она определяет края ячейки, включая крайний правый край, с учетом неравномерной ширины ячейки.</target>
        </trans-unit>
        <trans-unit id="f3d0d1457dc2c27ebf07eb8b8d37fdfe4b5b5f86" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;bins&lt;/code&gt; is not monotonic.</source>
          <target state="translated">Если &lt;code&gt;bins&lt;/code&gt; не монотонны.</target>
        </trans-unit>
        <trans-unit id="f1d57ef4cb7d5156a4314b6ea06d7045fe52a5fa" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;buffer&lt;/code&gt; is None, then only &lt;a href=&quot;numpy.ndarray.shape#numpy.ndarray.shape&quot;&gt;&lt;code&gt;shape&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;numpy.dtype#numpy.dtype&quot;&gt;&lt;code&gt;dtype&lt;/code&gt;&lt;/a&gt;, and &lt;code&gt;order&lt;/code&gt; are used.</source>
          <target state="translated">Если &lt;code&gt;buffer&lt;/code&gt; равен None, то используются только &lt;a href=&quot;numpy.ndarray.shape#numpy.ndarray.shape&quot;&gt; &lt;code&gt;shape&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;numpy.dtype#numpy.dtype&quot;&gt; &lt;code&gt;dtype&lt;/code&gt; &lt;/a&gt; и &lt;code&gt;order&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a3f34c748ade1a438e4af494b9939bb52d6b65ae" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;buffer&lt;/code&gt; is an object exposing the buffer interface, then all keywords are interpreted.</source>
          <target state="translated">Если &lt;code&gt;buffer&lt;/code&gt; - это объект, предоставляющий интерфейс буфера, то интерпретируются все ключевые слова.</target>
        </trans-unit>
        <trans-unit id="f67df360e18cb83b99203eea7e5b2b66896eaba4" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;buffersize&lt;/code&gt; is zero, a default buffer size is used, otherwise it specifies how big of a buffer to use. Buffers which are powers of 2 such as 4096 or 8192 are recommended.</source>
          <target state="translated">Если &lt;code&gt;buffersize&lt;/code&gt; равен нулю, используется размер буфера по умолчанию, в противном случае он определяет размер используемого буфера. Рекомендуются буферы со степенью двойки, например 4096 или 8192.</target>
        </trans-unit>
        <trans-unit id="beb58b828353ed80b8e0bbe892a75cbfcebae43d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;c&lt;/code&gt; has fewer than 3 dimensions, ones are implicitly appended to its shape to make it 3-D. The shape of the result will be c.shape[3:] + x.shape.</source>
          <target state="translated">Если &lt;code&gt;c&lt;/code&gt; имеет менее трех измерений, к его форме неявно добавляются единицы, чтобы сделать его трехмерным. Форма результата будет c.shape [3:] + x.shape.</target>
        </trans-unit>
        <trans-unit id="f7c13f789159cee3609188e9f6918f23db3edd6c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;c&lt;/code&gt; has fewer than three dimensions, ones are implicitly appended to its shape to make it 3-D. The shape of the result will be c.shape[3:] + x.shape + y.shape + z.shape.</source>
          <target state="translated">Если &lt;code&gt;c&lt;/code&gt; имеет менее трех измерений, к его форме неявно добавляются единицы, чтобы сделать его трехмерным. Форма результата будет c.shape [3:] + x.shape + y.shape + z.shape.</target>
        </trans-unit>
        <trans-unit id="210c7187323274ff624491c071d18c59ba05eaa3" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;c&lt;/code&gt; has fewer than two dimensions, ones are implicitly appended to its shape to make it 2-D. The shape of the result will be c.shape[2:] + x.shape + y.shape.</source>
          <target state="translated">Если &lt;code&gt;c&lt;/code&gt; имеет менее двух измерений, к его форме неявно добавляются единицы, чтобы сделать его двумерным. Форма результата будет c.shape [2:] + x.shape + y.shape.</target>
        </trans-unit>
        <trans-unit id="4b9c82b7f7444c244d3d87499e2e6abb52d1e818" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;c&lt;/code&gt; has fewer than two dimensions, ones are implicitly appended to its shape to make it 2-D. The shape of the result will be c.shape[2:] + x.shape.</source>
          <target state="translated">Если &lt;code&gt;c&lt;/code&gt; имеет менее двух измерений, к его форме неявно добавляются единицы, чтобы сделать его двумерным. Форма результата будет c.shape [2:] + x.shape.</target>
        </trans-unit>
        <trans-unit id="b813783672e3b8b110dcc3caed6943e29c499cf7" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;c&lt;/code&gt; is a 1-D array a one is implicitly appended to its shape to make it 2-D. The shape of the result will be c.shape[2:] + x.shape.</source>
          <target state="translated">Если &lt;code&gt;c&lt;/code&gt; - одномерный массив, к его форме неявно добавляется единица, чтобы сделать его двумерным. Форма результата будет c.shape [2:] + x.shape.</target>
        </trans-unit>
        <trans-unit id="9b697950a550c5d2ac6bfd1a90d0ee0cf3873621" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;c&lt;/code&gt; is a 1-D array of coefficients of length &lt;code&gt;n + 1&lt;/code&gt; and &lt;code&gt;V&lt;/code&gt; is the array &lt;code&gt;V = hermevander(x, n)&lt;/code&gt;, then &lt;code&gt;np.dot(V, c)&lt;/code&gt; and &lt;code&gt;hermeval(x, c)&lt;/code&gt; are the same up to roundoff. This equivalence is useful both for least squares fitting and for the evaluation of a large number of HermiteE series of the same degree and sample points.</source>
          <target state="translated">Если &lt;code&gt;c&lt;/code&gt; - &lt;code&gt;V = hermevander(x, n)&lt;/code&gt; массив коэффициентов длины &lt;code&gt;n + 1&lt;/code&gt; а &lt;code&gt;V&lt;/code&gt; - массив V = hermevander (x, n) , то &lt;code&gt;np.dot(V, c)&lt;/code&gt; и &lt;code&gt;hermeval(x, c)&lt;/code&gt; совпадают с точностью до округлять. Эта эквивалентность полезна как для аппроксимации методом наименьших квадратов, так и для оценки большого количества серий HermiteE с одинаковой степенью и точками выборки.</target>
        </trans-unit>
        <trans-unit id="8795163ae21f93104b677b1ca18c8738fd9a209a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;c&lt;/code&gt; is a 1-D array of coefficients of length &lt;code&gt;n + 1&lt;/code&gt; and &lt;code&gt;V&lt;/code&gt; is the array &lt;code&gt;V = hermvander(x, n)&lt;/code&gt;, then &lt;code&gt;np.dot(V, c)&lt;/code&gt; and &lt;code&gt;hermval(x, c)&lt;/code&gt; are the same up to roundoff. This equivalence is useful both for least squares fitting and for the evaluation of a large number of Hermite series of the same degree and sample points.</source>
          <target state="translated">Если &lt;code&gt;c&lt;/code&gt; - &lt;code&gt;V = hermvander(x, n)&lt;/code&gt; массив коэффициентов длины &lt;code&gt;n + 1&lt;/code&gt; а &lt;code&gt;V&lt;/code&gt; - массив V = hermvander (x, n) , то &lt;code&gt;np.dot(V, c)&lt;/code&gt; и &lt;code&gt;hermval(x, c)&lt;/code&gt; одинаковы с точностью до округлять. Эта эквивалентность полезна как для аппроксимации методом наименьших квадратов, так и для оценки большого количества серий Эрмита с одинаковой степенью и точками выборки.</target>
        </trans-unit>
        <trans-unit id="41e4b417db13b3be059bf5b8693dedddbf2d39c8" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;c&lt;/code&gt; is a 1-D array of coefficients of length &lt;code&gt;n + 1&lt;/code&gt; and &lt;code&gt;V&lt;/code&gt; is the array &lt;code&gt;V = lagvander(x, n)&lt;/code&gt;, then &lt;code&gt;np.dot(V, c)&lt;/code&gt; and &lt;code&gt;lagval(x, c)&lt;/code&gt; are the same up to roundoff. This equivalence is useful both for least squares fitting and for the evaluation of a large number of Laguerre series of the same degree and sample points.</source>
          <target state="translated">Если &lt;code&gt;c&lt;/code&gt; - &lt;code&gt;V = lagvander(x, n)&lt;/code&gt; массив коэффициентов длины &lt;code&gt;n + 1&lt;/code&gt; а &lt;code&gt;V&lt;/code&gt; - массив V = lagvander (x, n) , то &lt;code&gt;np.dot(V, c)&lt;/code&gt; и &lt;code&gt;lagval(x, c)&lt;/code&gt; одинаковы с точностью до округлять. Эта эквивалентность полезна как для аппроксимации методом наименьших квадратов, так и для оценки большого количества рядов Лагерра с одинаковой степенью и точками выборки.</target>
        </trans-unit>
        <trans-unit id="a1b597f29a3697113f705d9c197e77e09839d912" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;c&lt;/code&gt; is a 1-D array of coefficients of length &lt;code&gt;n + 1&lt;/code&gt; and &lt;code&gt;V&lt;/code&gt; is the array &lt;code&gt;V = legvander(x, n)&lt;/code&gt;, then &lt;code&gt;np.dot(V, c)&lt;/code&gt; and &lt;code&gt;legval(x, c)&lt;/code&gt; are the same up to roundoff. This equivalence is useful both for least squares fitting and for the evaluation of a large number of Legendre series of the same degree and sample points.</source>
          <target state="translated">Если &lt;code&gt;c&lt;/code&gt; - &lt;code&gt;V = legvander(x, n)&lt;/code&gt; массив коэффициентов длины &lt;code&gt;n + 1&lt;/code&gt; а &lt;code&gt;V&lt;/code&gt; - массив V = legvander (x, n) , то &lt;code&gt;np.dot(V, c)&lt;/code&gt; и &lt;code&gt;legval(x, c)&lt;/code&gt; одинаковы с точностью до округлять. Эта эквивалентность полезна как для аппроксимации методом наименьших квадратов, так и для оценки большого числа рядов Лежандра с одинаковой степенью и точками выборки.</target>
        </trans-unit>
        <trans-unit id="b7f0c7e082f8807f04eefbe2acbae592bdec65ca" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;c&lt;/code&gt; is a 1-D array of coefficients of length &lt;code&gt;n + 1&lt;/code&gt; and &lt;code&gt;V&lt;/code&gt; is the matrix &lt;code&gt;V = chebvander(x, n)&lt;/code&gt;, then &lt;code&gt;np.dot(V, c)&lt;/code&gt; and &lt;code&gt;chebval(x, c)&lt;/code&gt; are the same up to roundoff. This equivalence is useful both for least squares fitting and for the evaluation of a large number of Chebyshev series of the same degree and sample points.</source>
          <target state="translated">Если &lt;code&gt;c&lt;/code&gt; - &lt;code&gt;V = chebvander(x, n)&lt;/code&gt; массив коэффициентов длины &lt;code&gt;n + 1&lt;/code&gt; а &lt;code&gt;V&lt;/code&gt; - матрица V = chebvander (x, n) , то &lt;code&gt;np.dot(V, c)&lt;/code&gt; и &lt;code&gt;chebval(x, c)&lt;/code&gt; совпадают с точностью до округлять. Эта эквивалентность полезна как для аппроксимации методом наименьших квадратов, так и для оценки большого количества рядов Чебышева одинаковой степени и точек выборки.</target>
        </trans-unit>
        <trans-unit id="4e382928aa8d32a6b35f8adca3a6cffe61170326" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;c&lt;/code&gt; is a 1-D array of coefficients of length &lt;code&gt;n + 1&lt;/code&gt; and &lt;code&gt;V&lt;/code&gt; is the matrix &lt;code&gt;V = polyvander(x, n)&lt;/code&gt;, then &lt;code&gt;np.dot(V, c)&lt;/code&gt; and &lt;code&gt;polyval(x, c)&lt;/code&gt; are the same up to roundoff. This equivalence is useful both for least squares fitting and for the evaluation of a large number of polynomials of the same degree and sample points.</source>
          <target state="translated">Если &lt;code&gt;c&lt;/code&gt; - &lt;code&gt;V = polyvander(x, n)&lt;/code&gt; массив коэффициентов длины &lt;code&gt;n + 1&lt;/code&gt; а &lt;code&gt;V&lt;/code&gt; - матрица V = polyvander (x, n) , то &lt;code&gt;np.dot(V, c)&lt;/code&gt; и &lt;code&gt;polyval(x, c)&lt;/code&gt; одинаковы с точностью до округлять. Эта эквивалентность полезна как для аппроксимации методом наименьших квадратов, так и для оценки большого количества многочленов одной степени и точек выборки.</target>
        </trans-unit>
        <trans-unit id="8e80660168c2556d80131aae5098ce463a202c8f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;c&lt;/code&gt; is a 1-D array, then &lt;code&gt;p(x)&lt;/code&gt; will have the same shape as &lt;code&gt;x&lt;/code&gt;. If &lt;code&gt;c&lt;/code&gt; is multidimensional, then the shape of the result depends on the value of &lt;code&gt;tensor&lt;/code&gt;. If &lt;code&gt;tensor&lt;/code&gt; is true the shape will be c.shape[1:] + x.shape. If &lt;code&gt;tensor&lt;/code&gt; is false the shape will be c.shape[1:]. Note that scalars have shape (,).</source>
          <target state="translated">Если &lt;code&gt;c&lt;/code&gt; - одномерный массив, то &lt;code&gt;p(x)&lt;/code&gt; будет иметь ту же форму, что и &lt;code&gt;x&lt;/code&gt; . Если &lt;code&gt;c&lt;/code&gt; многомерна, то форма результата зависит от значения &lt;code&gt;tensor&lt;/code&gt; . Если &lt;code&gt;tensor&lt;/code&gt; истинен, форма будет c.shape [1:] + x.shape. Если &lt;code&gt;tensor&lt;/code&gt; ложен, форма будет c.shape [1:]. Обратите внимание, что скаляры имеют форму (,).</target>
        </trans-unit>
        <trans-unit id="0a3728daa3b2e189e758d347ca0d72357650db3c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;c&lt;/code&gt; is of length &lt;code&gt;n + 1&lt;/code&gt;, this function returns the value</source>
          <target state="translated">Если &lt;code&gt;c&lt;/code&gt; имеет длину &lt;code&gt;n + 1&lt;/code&gt; , эта функция возвращает значение</target>
        </trans-unit>
        <trans-unit id="e3ad7dc6a355dfc8a1c8aa46843f5488897fd4ce" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;c&lt;/code&gt; is of length &lt;code&gt;n + 1&lt;/code&gt;, this function returns the value:</source>
          <target state="translated">Если &lt;code&gt;c&lt;/code&gt; имеет длину &lt;code&gt;n + 1&lt;/code&gt; , эта функция возвращает значение:</target>
        </trans-unit>
        <trans-unit id="f3791f18c578dee37c08b1f05312986ce4a1234a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;condition&lt;/code&gt; is boolean:</source>
          <target state="translated">Если &lt;code&gt;condition&lt;/code&gt; логическое:</target>
        </trans-unit>
        <trans-unit id="945ce76f24a4c673d6aa37d9ae7569a5f68abd37" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;data&lt;/code&gt; is provided, it must stay alive for the life of the array. One way to manage this is through &lt;a href=&quot;#c.PyArray_SetBaseObject&quot;&gt;&lt;code&gt;PyArray_SetBaseObject&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">Если &lt;code&gt;data&lt;/code&gt; предоставлены, они должны оставаться активными в течение всего срока службы массива. Один из способов справиться с этим - через &lt;a href=&quot;#c.PyArray_SetBaseObject&quot;&gt; &lt;code&gt;PyArray_SetBaseObject&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="68051abdc74ce34a8cd57f65aadeda23f8c9fb89" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;dtype&lt;/code&gt; isn&amp;rsquo;t &lt;code&gt;NULL&lt;/code&gt;, then it requires that data type. If copying is allowed, it will make a temporary copy if the data is castable. If &lt;a href=&quot;#c.NPY_ITER_UPDATEIFCOPY&quot;&gt;&lt;code&gt;NPY_ITER_UPDATEIFCOPY&lt;/code&gt;&lt;/a&gt; is enabled, it will also copy the data back with another cast upon iterator destruction.</source>
          <target state="translated">Если &lt;code&gt;dtype&lt;/code&gt; не &lt;code&gt;NULL&lt;/code&gt; , то ему требуется этот тип данных. Если копирование разрешено, будет создана временная копия, если данные могут быть преобразованы. Если &lt;a href=&quot;#c.NPY_ITER_UPDATEIFCOPY&quot;&gt; &lt;code&gt;NPY_ITER_UPDATEIFCOPY&lt;/code&gt; &lt;/a&gt; включен, он также скопирует данные обратно с другим приведением после разрушения итератора.</target>
        </trans-unit>
        <trans-unit id="760548f2e1b1246d013e160a44370e64f44dc286" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;enddates&lt;/code&gt; specifies a date value that is earlier than the corresponding &lt;code&gt;begindates&lt;/code&gt; date value, the count will be negative.</source>
          <target state="translated">Если &lt;code&gt;enddates&lt;/code&gt; указывает значение даты, которое раньше, чем соответствующее &lt;code&gt;begindates&lt;/code&gt; даты beginindates , счет будет отрицательным.</target>
        </trans-unit>
        <trans-unit id="cb4a6b4dd2e4a7b67147341a42f6c8197722c973" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;indices_or_sections&lt;/code&gt; is a 1-D array of sorted integers, the entries indicate where along &lt;code&gt;axis&lt;/code&gt; the array is split. For example, &lt;code&gt;[2, 3]&lt;/code&gt; would, for &lt;code&gt;axis=0&lt;/code&gt;, result in</source>
          <target state="translated">Если &lt;code&gt;indices_or_sections&lt;/code&gt; представляет собой одномерный массив отсортированных целых чисел, записи указывают, где вдоль &lt;code&gt;axis&lt;/code&gt; массив разбивается. Например, &lt;code&gt;[2, 3]&lt;/code&gt; для &lt;code&gt;axis=0&lt;/code&gt; приведет к</target>
        </trans-unit>
        <trans-unit id="750e535a910db315f0680626cd7e38f07dd476ee" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;indices_or_sections&lt;/code&gt; is an integer, N, the array will be divided into N equal arrays along &lt;code&gt;axis&lt;/code&gt;. If such a split is not possible, an error is raised.</source>
          <target state="translated">Если &lt;code&gt;indices_or_sections&lt;/code&gt; является целым числом N, массив будет разделен на N равных массивов по &lt;code&gt;axis&lt;/code&gt; . Если такое разделение невозможно, возникает ошибка.</target>
        </trans-unit>
        <trans-unit id="c2fbdd32f871ea7c6656b8280d919dff6251170e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;indices_or_sections&lt;/code&gt; is given as an integer, but a split does not result in equal division.</source>
          <target state="translated">Если &lt;code&gt;indices_or_sections&lt;/code&gt; задано как целое число, но разделение не приводит к равному разделению.</target>
        </trans-unit>
        <trans-unit id="ce1a7ad82e3cfecd360d23c388ed9b15e3542af6" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;legacy&lt;/code&gt; is False, or the BitGenerator is not NT19937, then state is returned as a dictionary.</source>
          <target state="translated">Если &lt;code&gt;legacy&lt;/code&gt; имеет значение False или BitGenerator не NT19937, то состояние возвращается в виде словаря.</target>
        </trans-unit>
        <trans-unit id="146abcde4c240659f226130b295dbaf50c55deac" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;m &amp;lt; 0&lt;/code&gt;, &lt;code&gt;len(k) &amp;gt; m&lt;/code&gt;, &lt;code&gt;np.ndim(lbnd) != 0&lt;/code&gt;, or &lt;code&gt;np.ndim(scl) != 0&lt;/code&gt;.</source>
          <target state="translated">Если &lt;code&gt;m &amp;lt; 0&lt;/code&gt; , &lt;code&gt;len(k) &amp;gt; m&lt;/code&gt; , &lt;code&gt;np.ndim(lbnd) != 0&lt;/code&gt; или &lt;code&gt;np.ndim(scl) != 0&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2c2df004cd887df3e646568cfffdf17b3ac0ffbf" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;m &amp;lt; 1&lt;/code&gt;, &lt;code&gt;len(k) &amp;gt; m&lt;/code&gt;, &lt;code&gt;np.ndim(lbnd) != 0&lt;/code&gt;, or &lt;code&gt;np.ndim(scl) != 0&lt;/code&gt;.</source>
          <target state="translated">Если &lt;code&gt;m &amp;lt; 1&lt;/code&gt; , &lt;code&gt;len(k) &amp;gt; m&lt;/code&gt; , &lt;code&gt;np.ndim(lbnd) != 0&lt;/code&gt; или &lt;code&gt;np.ndim(scl) != 0&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e220ffcadc52e486b28727579ddc1e86ad96fbcc" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;m1&lt;/code&gt; and &lt;code&gt;m2&lt;/code&gt; have different flexible dtypes.</source>
          <target state="translated">Если &lt;code&gt;m1&lt;/code&gt; и &lt;code&gt;m2&lt;/code&gt; имеют разные гибкие типы d.</target>
        </trans-unit>
        <trans-unit id="0cda2eb48aaf0ad93b34e30066de3169d0688cac" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;m&lt;/code&gt; has a single column then that column is returned as the single row of a matrix. Otherwise &lt;code&gt;m&lt;/code&gt; is returned. The returned matrix is always either &lt;code&gt;m&lt;/code&gt; itself or a view into &lt;code&gt;m&lt;/code&gt;. Supplying an axis keyword argument will not affect the returned matrix but it may cause an error to be raised.</source>
          <target state="translated">Если &lt;code&gt;m&lt;/code&gt; имеет единственный столбец, то этот столбец возвращается как единственная строка матрицы. В противном случае возвращается &lt;code&gt;m&lt;/code&gt; . Возвращенная матрица всегда либо сама &lt;code&gt;m&lt;/code&gt; , либо представление в &lt;code&gt;m&lt;/code&gt; . Предоставление аргумента ключевого слова оси не повлияет на возвращаемую матрицу, но может вызвать ошибку.</target>
        </trans-unit>
        <trans-unit id="d089e6b20e99bc8aa35211116381511548d1fc6f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;maxsplit&lt;/code&gt; is given, at most &lt;code&gt;maxsplit&lt;/code&gt; splits are done, the rightmost ones.</source>
          <target state="translated">Если &lt;code&gt;maxsplit&lt;/code&gt; выполняется не более &lt;code&gt;maxsplit&lt;/code&gt; ,а самые правые .</target>
        </trans-unit>
        <trans-unit id="f3a2beabba4d5e799494083ff0f67c424eaf8432" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;maxsplit&lt;/code&gt; is given, at most &lt;code&gt;maxsplit&lt;/code&gt; splits are done.</source>
          <target state="translated">Если &lt;code&gt;maxsplit&lt;/code&gt; выполняется не более &lt;code&gt;maxsplit&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a6773ebb7a73c0cf9641c3fc6c53898d5654dcdd" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;n&lt;/code&gt; is even, &lt;code&gt;A[-1]&lt;/code&gt; contains the term representing both positive and negative Nyquist frequency (+fs/2 and -fs/2), and must also be purely real. If &lt;code&gt;n&lt;/code&gt; is odd, there is no term at fs/2; &lt;code&gt;A[-1]&lt;/code&gt; contains the largest positive frequency (fs/2*(n-1)/n), and is complex in the general case.</source>
          <target state="translated">Если &lt;code&gt;n&lt;/code&gt; четно, &lt;code&gt;A[-1]&lt;/code&gt; содержит член, представляющий как положительную, так и отрицательную частоту Найквиста (+ fs / 2 и -fs / 2), и также должен быть чисто реальным. Если &lt;code&gt;n&lt;/code&gt; нечетное, в fs / 2 нет члена; &lt;code&gt;A[-1]&lt;/code&gt; содержит наибольшую положительную частоту (fs / 2 * (n-1) / n) и является комплексным в общем случае.</target>
        </trans-unit>
        <trans-unit id="d002795222f44b6308a6ac63aedd1a3723557506" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;names&lt;/code&gt; is True, the field names are read from the first line after the first &lt;code&gt;skip_header&lt;/code&gt; lines. This line can optionally be proceeded by a comment delimiter. If &lt;code&gt;names&lt;/code&gt; is a sequence or a single-string of comma-separated names, the names will be used to define the field names in a structured dtype. If &lt;code&gt;names&lt;/code&gt; is None, the names of the dtype fields will be used, if any.</source>
          <target state="translated">Если для &lt;code&gt;names&lt;/code&gt; установлено значение True, имена полей считываются с первой строки после первых строк &lt;code&gt;skip_header&lt;/code&gt; . Эта строка может быть продолжена разделителем комментария. Если &lt;code&gt;names&lt;/code&gt; представляют собой последовательность или одну строку имен, разделенных запятыми, имена будут использоваться для определения имен полей в структурированном dtype. Если &lt;code&gt;names&lt;/code&gt; не None, будут использованы имена полой DTYPE, если таковые имеются.</target>
        </trans-unit>
        <trans-unit id="9d8d4bbddf580197e193ef2ab5f3260ca263687d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;obj.flags&lt;/code&gt; has &lt;a href=&quot;#c.NPY_ARRAY_WRITEBACKIFCOPY&quot;&gt;&lt;code&gt;NPY_ARRAY_WRITEBACKIFCOPY&lt;/code&gt;&lt;/a&gt; or (deprecated) &lt;a href=&quot;#c.NPY_ARRAY_UPDATEIFCOPY&quot;&gt;&lt;code&gt;NPY_ARRAY_UPDATEIFCOPY&lt;/code&gt;&lt;/a&gt;, this function clears the flags, &lt;code&gt;DECREF&lt;/code&gt; s &lt;code&gt;obj-&amp;gt;base&lt;/code&gt; and makes it writeable, and sets &lt;code&gt;obj-&amp;gt;base&lt;/code&gt; to NULL. In contrast to &lt;a href=&quot;#c.PyArray_DiscardWritebackIfCopy&quot;&gt;&lt;code&gt;PyArray_DiscardWritebackIfCopy&lt;/code&gt;&lt;/a&gt; it makes no attempt to copy the data from &lt;code&gt;obj-&amp;gt;base&lt;/code&gt; This undoes &lt;a href=&quot;#c.PyArray_SetWritebackIfCopyBase&quot;&gt;&lt;code&gt;PyArray_SetWritebackIfCopyBase&lt;/code&gt;&lt;/a&gt;. Usually this is called after an error when you are finished with &lt;code&gt;obj&lt;/code&gt;, just before &lt;code&gt;Py_DECREF(obj)&lt;/code&gt;. It may be called multiple times, or with &lt;code&gt;NULL&lt;/code&gt; input.</source>
          <target state="translated">Если &lt;code&gt;obj.flags&lt;/code&gt; имеет &lt;a href=&quot;#c.NPY_ARRAY_WRITEBACKIFCOPY&quot;&gt; &lt;code&gt;NPY_ARRAY_WRITEBACKIFCOPY&lt;/code&gt; &lt;/a&gt; или (устаревшее) &lt;a href=&quot;#c.NPY_ARRAY_UPDATEIFCOPY&quot;&gt; &lt;code&gt;NPY_ARRAY_UPDATEIFCOPY&lt;/code&gt; &lt;/a&gt; , эта функция очищает флаги, &lt;code&gt;DECREF&lt;/code&gt; s &lt;code&gt;obj-&amp;gt;base&lt;/code&gt; и делает его доступным для записи, и устанавливает &lt;code&gt;obj-&amp;gt;base&lt;/code&gt; в NULL. В отличие от &lt;a href=&quot;#c.PyArray_DiscardWritebackIfCopy&quot;&gt; &lt;code&gt;PyArray_DiscardWritebackIfCopy&lt;/code&gt; ,&lt;/a&gt; он не пытается скопировать данные из &lt;code&gt;obj-&amp;gt;base&lt;/code&gt; . Это отменяет &lt;a href=&quot;#c.PyArray_SetWritebackIfCopyBase&quot;&gt; &lt;code&gt;PyArray_SetWritebackIfCopyBase&lt;/code&gt; &lt;/a&gt; . Обычно это вызывается после ошибки, когда вы закончили работу с &lt;code&gt;obj&lt;/code&gt; , непосредственно перед &lt;code&gt;Py_DECREF(obj)&lt;/code&gt; . Его можно вызывать несколько раз или вводить &lt;code&gt;NULL&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8f43e6f1e973bd0d462747acc6303f4251ae23b1" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;obj.flags&lt;/code&gt; has &lt;a href=&quot;#c.NPY_ARRAY_WRITEBACKIFCOPY&quot;&gt;&lt;code&gt;NPY_ARRAY_WRITEBACKIFCOPY&lt;/code&gt;&lt;/a&gt; or (deprecated) &lt;a href=&quot;#c.NPY_ARRAY_UPDATEIFCOPY&quot;&gt;&lt;code&gt;NPY_ARRAY_UPDATEIFCOPY&lt;/code&gt;&lt;/a&gt;, this function clears the flags, &lt;code&gt;DECREF&lt;/code&gt; s &lt;code&gt;obj-&amp;gt;base&lt;/code&gt; and makes it writeable, and sets &lt;code&gt;obj-&amp;gt;base&lt;/code&gt; to NULL. It then copies &lt;code&gt;obj-&amp;gt;data&lt;/code&gt; to &lt;code&gt;obj-&amp;gt;base-&amp;gt;data&lt;/code&gt;, and returns the error state of the copy operation. This is the opposite of &lt;a href=&quot;#c.PyArray_SetWritebackIfCopyBase&quot;&gt;&lt;code&gt;PyArray_SetWritebackIfCopyBase&lt;/code&gt;&lt;/a&gt;. Usually this is called once you are finished with &lt;code&gt;obj&lt;/code&gt;, just before &lt;code&gt;Py_DECREF(obj)&lt;/code&gt;. It may be called multiple times, or with &lt;code&gt;NULL&lt;/code&gt; input. See also &lt;a href=&quot;#c.PyArray_DiscardWritebackIfCopy&quot;&gt;&lt;code&gt;PyArray_DiscardWritebackIfCopy&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Если &lt;code&gt;obj.flags&lt;/code&gt; имеет &lt;a href=&quot;#c.NPY_ARRAY_WRITEBACKIFCOPY&quot;&gt; &lt;code&gt;NPY_ARRAY_WRITEBACKIFCOPY&lt;/code&gt; &lt;/a&gt; или (устаревшее) &lt;a href=&quot;#c.NPY_ARRAY_UPDATEIFCOPY&quot;&gt; &lt;code&gt;NPY_ARRAY_UPDATEIFCOPY&lt;/code&gt; &lt;/a&gt; , эта функция очищает флаги, &lt;code&gt;DECREF&lt;/code&gt; s &lt;code&gt;obj-&amp;gt;base&lt;/code&gt; и делает его доступным для записи, и устанавливает &lt;code&gt;obj-&amp;gt;base&lt;/code&gt; в NULL. Затем он копирует &lt;code&gt;obj-&amp;gt;data&lt;/code&gt; в &lt;code&gt;obj-&amp;gt;base-&amp;gt;data&lt;/code&gt; и возвращает состояние ошибки операции копирования. Это противоположность &lt;a href=&quot;#c.PyArray_SetWritebackIfCopyBase&quot;&gt; &lt;code&gt;PyArray_SetWritebackIfCopyBase&lt;/code&gt; &lt;/a&gt; . Обычно это вызывается после завершения работы с &lt;code&gt;obj&lt;/code&gt; , непосредственно перед &lt;code&gt;Py_DECREF(obj)&lt;/code&gt; . Его можно вызывать несколько раз или вводить &lt;code&gt;NULL&lt;/code&gt; . См. Также &lt;a href=&quot;#c.PyArray_DiscardWritebackIfCopy&quot;&gt; &lt;code&gt;PyArray_DiscardWritebackIfCopy&lt;/code&gt; &lt;/a&gt;,</target>
        </trans-unit>
        <trans-unit id="b9effe7f71bd1a595880c87c20422da0870723e1" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;obj.ndim == x.ndim&lt;/code&gt;, &lt;code&gt;x[obj]&lt;/code&gt; returns a 1-dimensional array filled with the elements of &lt;em&gt;x&lt;/em&gt; corresponding to the &lt;code&gt;True&lt;/code&gt; values of &lt;em&gt;obj&lt;/em&gt;. The search order will be &lt;a href=&quot;https://docs.scipy.org/doc/numpy-1.17.0/glossary.html#term-row-major&quot;&gt;row-major&lt;/a&gt;, C-style. If &lt;em&gt;obj&lt;/em&gt; has &lt;code&gt;True&lt;/code&gt; values at entries that are outside of the bounds of &lt;em&gt;x&lt;/em&gt;, then an index error will be raised. If &lt;em&gt;obj&lt;/em&gt; is smaller than &lt;em&gt;x&lt;/em&gt; it is identical to filling it with &lt;code&gt;False&lt;/code&gt;.</source>
          <target state="translated">Если &lt;code&gt;obj.ndim == x.ndim&lt;/code&gt; , &lt;code&gt;x[obj]&lt;/code&gt; возвращает одномерный массив, заполненный элементами &lt;em&gt;x,&lt;/em&gt; соответствующими &lt;code&gt;True&lt;/code&gt; значениям &lt;em&gt;obj&lt;/em&gt; . Порядок поиска будет &lt;a href=&quot;https://docs.scipy.org/doc/numpy-1.17.0/glossary.html#term-row-major&quot;&gt;строковым&lt;/a&gt; , в стиле C. Если &lt;em&gt;obj&lt;/em&gt; имеет значения &lt;code&gt;True&lt;/code&gt; в записях, которые находятся за пределами &lt;em&gt;x&lt;/em&gt; , то возникает ошибка индекса. Если &lt;em&gt;obj&lt;/em&gt; меньше &lt;em&gt;x,&lt;/em&gt; это идентично заполнению его значением &lt;code&gt;False&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0cb8b5f8682e528917b9dad63d5ce0f0a15864d5" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;obj&lt;/code&gt; isn&amp;rsquo;t a suitable numeric type.</source>
          <target state="translated">Если &lt;code&gt;obj&lt;/code&gt; не подходит для числового типа.</target>
        </trans-unit>
        <trans-unit id="bd67812cd1998c40abb29425bc518b926e6b0841" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;op&lt;/code&gt; implements any part of the array interface, then &lt;code&gt;out&lt;/code&gt; will contain a new reference to the newly created ndarray using the interface or &lt;code&gt;out&lt;/code&gt; will contain &lt;code&gt;NULL&lt;/code&gt; if an error during conversion occurs. Otherwise, out will contain a borrowed reference to &lt;a href=&quot;https://docs.python.org/dev/c-api/object.html#c.Py_NotImplemented&quot;&gt;&lt;code&gt;Py_NotImplemented&lt;/code&gt;&lt;/a&gt; and no error condition is set.</source>
          <target state="translated">Если &lt;code&gt;op&lt;/code&gt; реализует какую-либо часть интерфейса массива, тогда &lt;code&gt;out&lt;/code&gt; будет содержать новую ссылку на вновь созданный ndarray с использованием интерфейса, или &lt;code&gt;out&lt;/code&gt; будет содержать &lt;code&gt;NULL&lt;/code&gt; , если во время преобразования произойдет ошибка. В противном случае out будет содержать заимствованную ссылку на &lt;a href=&quot;https://docs.python.org/dev/c-api/object.html#c.Py_NotImplemented&quot;&gt; &lt;code&gt;Py_NotImplemented&lt;/code&gt; ,&lt;/a&gt; и условие ошибки не будет установлено.</target>
        </trans-unit>
        <trans-unit id="98dbfb53c5754a6749d968f5df5fe9eebecd4ff8" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;op&lt;/code&gt; implements any part of the array interface, then &lt;code&gt;out&lt;/code&gt; will contain a new reference to the newly created ndarray using the interface or &lt;code&gt;out&lt;/code&gt; will contain &lt;code&gt;NULL&lt;/code&gt; if an error during conversion occurs. Otherwise, out will contain a borrowed reference to Py_NotImplemented and no error condition is set. This version allows setting of the type and context in the part of the array interface that looks for the &lt;a href=&quot;arrays.classes#numpy.class.__array__&quot;&gt;&lt;code&gt;__array__&lt;/code&gt;&lt;/a&gt; attribute.</source>
          <target state="translated">Если &lt;code&gt;op&lt;/code&gt; реализует какую-либо часть интерфейса массива, то &lt;code&gt;out&lt;/code&gt; будет содержать новую ссылку на вновь созданный ndarray с использованием интерфейса, или &lt;code&gt;out&lt;/code&gt; будет содержать &lt;code&gt;NULL&lt;/code&gt; , если во время преобразования произойдет ошибка. В противном случае out будет содержать заимствованную ссылку на Py_NotImplemented, и условие ошибки не будет установлено. Эта версия позволяет устанавливать тип и контекст в той части интерфейса массива, которая ищет атрибут &lt;a href=&quot;arrays.classes#numpy.class.__array__&quot;&gt; &lt;code&gt;__array__&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="ed83570f54caf00535275cbf2433364d3dc43b7b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;op&lt;/code&gt; is already (C-style) contiguous and well-behaved then just return a reference, otherwise return a (contiguous and well-behaved) copy of the array. The parameter op must be a (sub-class of an) ndarray and no checking for that is done.</source>
          <target state="translated">Если &lt;code&gt;op&lt;/code&gt; уже (в стиле C) является смежным и хорошо себя ведет, тогда просто верните ссылку, в противном случае верните (непрерывную и хорошо управляемую) копию массива. Параметр op должен быть (подклассом) ndarray, и проверка на это не производится.</target>
        </trans-unit>
        <trans-unit id="3efc82f6eb8962f2bbdd61dd48e5d36f40ab01fd" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;op_dtypes&lt;/code&gt; isn&amp;rsquo;t &lt;code&gt;NULL&lt;/code&gt;, it specifies a data type or &lt;code&gt;NULL&lt;/code&gt; for each &lt;code&gt;op[i]&lt;/code&gt;.</source>
          <target state="translated">Если &lt;code&gt;op_dtypes&lt;/code&gt; не &lt;code&gt;NULL&lt;/code&gt; , он указывает тип данных или &lt;code&gt;NULL&lt;/code&gt; для каждого &lt;code&gt;op[i]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="49913a9d3761c3c5184d0fb1b55beebafb026c1c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;otypes&lt;/code&gt; is not specified, then a call to the function with the first argument will be used to determine the number of outputs. The results of this call will be cached if &lt;code&gt;cache&lt;/code&gt; is &lt;code&gt;True&lt;/code&gt; to prevent calling the function twice. However, to implement the cache, the original function must be wrapped which will slow down subsequent calls, so only do this if your function is expensive.</source>
          <target state="translated">Если &lt;code&gt;otypes&lt;/code&gt; не указан, то вызов функции с первым аргументом будет использоваться для определения количества выходов. Результаты этого вызова будут кэшироваться, если &lt;code&gt;cache&lt;/code&gt; имеет значение &lt;code&gt;True&lt;/code&gt; , чтобы предотвратить повторный вызов функции. Однако для реализации кеширования исходная функция должна быть обернута, что замедлит последующие вызовы, поэтому делайте это только в том случае, если ваша функция дорогая.</target>
        </trans-unit>
        <trans-unit id="6567b2686e797d9822a7bbf895363486cc94afc9" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;out&lt;/code&gt; is None, return a new array containing the standard deviation, otherwise return a reference to the output array.</source>
          <target state="translated">Если &lt;code&gt;out&lt;/code&gt; равно None, вернуть новый массив, содержащий стандартное отклонение, в противном случае вернуть ссылку на выходной массив.</target>
        </trans-unit>
        <trans-unit id="089152cfcf81b924028fc82e4f2ab4321cd32c01" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;out&lt;/code&gt; is None, return a new array containing the standard deviation, otherwise return a reference to the output array. If ddof is &amp;gt;= the number of non-NaN elements in a slice or the slice contains only NaNs, then the result for that slice is NaN.</source>
          <target state="translated">Если &lt;code&gt;out&lt;/code&gt; равно None, вернуть новый массив, содержащий стандартное отклонение, в противном случае вернуть ссылку на выходной массив. Если ddof равен&amp;gt; = количеству элементов, отличных от NaN, в срезе или срез содержит только NaN, то результатом для этого среза будет NaN.</target>
        </trans-unit>
        <trans-unit id="a3cf56d56f9711ddb9fe165ac4a15d1c897a7d62" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;out&lt;/code&gt; is None, return a new array containing the variance, otherwise return a reference to the output array. If ddof is &amp;gt;= the number of non-NaN elements in a slice or the slice contains only NaNs, then the result for that slice is NaN.</source>
          <target state="translated">Если &lt;code&gt;out&lt;/code&gt; равен None, вернуть новый массив, содержащий дисперсию, в противном случае вернуть ссылку на выходной массив. Если ddof равен&amp;gt; = количеству элементов, отличных от NaN, в срезе или срез содержит только NaN, то результатом для этого среза будет NaN.</target>
        </trans-unit>
        <trans-unit id="bd3ed46fb1ad18e3f54a87922d109c78bc224796" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;out&lt;/code&gt; is provided, the function writes the result into it, and returns a reference to &lt;code&gt;out&lt;/code&gt;. (See Examples)</source>
          <target state="translated">Если &lt;code&gt;out&lt;/code&gt; , функция записывает в него результат и возвращает ссылку на &lt;code&gt;out&lt;/code&gt; . (См. Примеры)</target>
        </trans-unit>
        <trans-unit id="d0b860961bc5b4a4c45189c0fd4de5c2d61f1ab4" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;out=None&lt;/code&gt;, returns a new array containing the mean values, otherwise a reference to the output array is returned.</source>
          <target state="translated">Если &lt;code&gt;out=None&lt;/code&gt; , возвращается новый массив, содержащий средние значения, в противном случае возвращается ссылка на выходной массив.</target>
        </trans-unit>
        <trans-unit id="d2bfee9ac0986058c6155b92fa93c7a62c8953a4" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;out=None&lt;/code&gt;, returns a new array containing the mean values, otherwise a reference to the output array is returned. Nan is returned for slices that contain only NaNs.</source>
          <target state="translated">Если &lt;code&gt;out=None&lt;/code&gt; , возвращает новый массив, содержащий средние значения, в противном случае возвращается ссылка на выходной массив. Nan возвращается для срезов, содержащих только NaN.</target>
        </trans-unit>
        <trans-unit id="64277711f0130f08ef89a03256433633c6256165" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;out=None&lt;/code&gt;, returns a new array containing the variance; otherwise, a reference to the output array is returned.</source>
          <target state="translated">Если &lt;code&gt;out=None&lt;/code&gt; , возвращает новый массив, содержащий дисперсию; в противном случае возвращается ссылка на выходной массив.</target>
        </trans-unit>
        <trans-unit id="9b1c9c61ff9f1ab4238c3c9129f3c3d7264b97ee" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;output&lt;/code&gt; not supplied then source code is printed to screen (sys.stdout). File object must be created with either write &amp;lsquo;w&amp;rsquo; or append &amp;lsquo;a&amp;rsquo; modes.</source>
          <target state="translated">Если &lt;code&gt;output&lt;/code&gt; не предоставлен, исходный код выводится на экран (sys.stdout). Файловый объект должен быть создан с использованием режимов записи 'w' или добавления 'a'.</target>
        </trans-unit>
        <trans-unit id="04c444cb5aa197d63b68cfea78d90d29188a9456" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;p&lt;/code&gt; is of length N, this function returns the value:</source>
          <target state="translated">Если &lt;code&gt;p&lt;/code&gt; имеет длину N, эта функция возвращает значение:</target>
        </trans-unit>
        <trans-unit id="fe3f05df5768add8f656a94f10e13fc6943b0c1b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;p&lt;/code&gt; is the returned series, then &lt;code&gt;p(x) == x&lt;/code&gt; for all values of x.</source>
          <target state="translated">Если &lt;code&gt;p&lt;/code&gt; - возвращаемый ряд, то &lt;code&gt;p(x) == x&lt;/code&gt; для всех значений x.</target>
        </trans-unit>
        <trans-unit id="f5468a2ba10e85782ab3beca18220db469f1d944" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;path&lt;/code&gt; is an URL, it will be downloaded, stored in the &lt;a href=&quot;numpy.datasource#numpy.DataSource&quot;&gt;&lt;code&gt;DataSource&lt;/code&gt;&lt;/a&gt; directory and opened from there.</source>
          <target state="translated">Если &lt;code&gt;path&lt;/code&gt; является URL-адресом, он будет загружен, сохранен в каталоге &lt;a href=&quot;numpy.datasource#numpy.DataSource&quot;&gt; &lt;code&gt;DataSource&lt;/code&gt; &lt;/a&gt; и открыт оттуда.</target>
        </trans-unit>
        <trans-unit id="24260df7d2aad1e014a4c9af35e7ef7678f51548" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;path&lt;/code&gt; is an URL, then &lt;a href=&quot;#numpy.DataSource.abspath&quot;&gt;&lt;code&gt;abspath&lt;/code&gt;&lt;/a&gt; will return either the location the file exists locally or the location it would exist when opened using the &lt;a href=&quot;numpy.datasource.open#numpy.DataSource.open&quot;&gt;&lt;code&gt;open&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">Если &lt;code&gt;path&lt;/code&gt; является URL-адресом, то &lt;a href=&quot;#numpy.DataSource.abspath&quot;&gt; &lt;code&gt;abspath&lt;/code&gt; &lt;/a&gt; вернет либо местоположение файла, существующее локально, либо местоположение, в котором он будет существовать при открытии с использованием метода &lt;a href=&quot;numpy.datasource.open#numpy.DataSource.open&quot;&gt; &lt;code&gt;open&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="9e52fcae8c89336b9d76db6bc95e2d2ecd5abb9e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;q&lt;/code&gt; is a single percentile and &lt;code&gt;axis=None&lt;/code&gt;, then the result is a scalar. If multiple percentiles are given, first axis of the result corresponds to the percentiles. The other axes are the axes that remain after the reduction of &lt;code&gt;a&lt;/code&gt;. If the input contains integers or floats smaller than &lt;code&gt;float64&lt;/code&gt;, the output data-type is &lt;code&gt;float64&lt;/code&gt;. Otherwise, the output data-type is the same as that of the input. If &lt;code&gt;out&lt;/code&gt; is specified, that array is returned instead.</source>
          <target state="translated">Если &lt;code&gt;q&lt;/code&gt; является одним процентилем и &lt;code&gt;axis=None&lt;/code&gt; , то результат является скаляром. Если дано несколько процентилей, первая ось результата соответствует процентилям. Остальные оси - это оси, которые остаются после уменьшения &lt;code&gt;a&lt;/code&gt; . Если входные данные содержат целые числа или числа с плавающей &lt;code&gt;float64&lt;/code&gt; , меньшие, чем float64 , тип выходных данных - &lt;code&gt;float64&lt;/code&gt; . В противном случае тип выходных данных такой же, как и у входных. Если указан &lt;code&gt;out&lt;/code&gt; , вместо этого возвращается этот массив.</target>
        </trans-unit>
        <trans-unit id="4219d6c9d1025bc747faeaba10649824d1b4aa46" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;q&lt;/code&gt; is a single percentile and &lt;code&gt;axis=None&lt;/code&gt;, then the result is a scalar. If multiple quantiles are given, first axis of the result corresponds to the quantiles. The other axes are the axes that remain after the reduction of &lt;code&gt;a&lt;/code&gt;. If the input contains integers or floats smaller than &lt;code&gt;float64&lt;/code&gt;, the output data-type is &lt;code&gt;float64&lt;/code&gt;. Otherwise, the output data-type is the same as that of the input. If &lt;code&gt;out&lt;/code&gt; is specified, that array is returned instead.</source>
          <target state="translated">Если &lt;code&gt;q&lt;/code&gt; является одним процентилем и &lt;code&gt;axis=None&lt;/code&gt; , то результат является скаляром. Если задано несколько квантилей, первая ось результата соответствует квантилям. Остальные оси - это оси, которые остаются после уменьшения &lt;code&gt;a&lt;/code&gt; . Если входные данные содержат целые числа или числа с плавающей &lt;code&gt;float64&lt;/code&gt; , меньшие, чем float64 , тип выходных данных - &lt;code&gt;float64&lt;/code&gt; . В противном случае тип выходных данных такой же, как и у входных. Если указан &lt;code&gt;out&lt;/code&gt; , вместо этого возвращается этот массив.</target>
        </trans-unit>
        <trans-unit id="adb7c2f1dd4ba6f271e782ab821bd6ce35c48378" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;q&lt;/code&gt; is a single quantile and &lt;code&gt;axis=None&lt;/code&gt;, then the result is a scalar. If multiple quantiles are given, first axis of the result corresponds to the quantiles. The other axes are the axes that remain after the reduction of &lt;code&gt;a&lt;/code&gt;. If the input contains integers or floats smaller than &lt;code&gt;float64&lt;/code&gt;, the output data-type is &lt;code&gt;float64&lt;/code&gt;. Otherwise, the output data-type is the same as that of the input. If &lt;code&gt;out&lt;/code&gt; is specified, that array is returned instead.</source>
          <target state="translated">Если &lt;code&gt;q&lt;/code&gt; - это единичный квантиль и &lt;code&gt;axis=None&lt;/code&gt; , то результатом будет скаляр. Если задано несколько квантилей, первая ось результата соответствует квантилям. Остальные оси - это оси, которые остаются после уменьшения &lt;code&gt;a&lt;/code&gt; . Если входные данные содержат целые числа или числа с плавающей &lt;code&gt;float64&lt;/code&gt; , меньшие, чем float64 , тип выходных данных - &lt;code&gt;float64&lt;/code&gt; . В противном случае тип выходных данных такой же, как и у входных. Если указан &lt;code&gt;out&lt;/code&gt; , вместо этого возвращается этот массив.</target>
        </trans-unit>
        <trans-unit id="9da6831f27b77e8b6677e8aad5c341d985befa99" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;r&lt;/code&gt; is a 1-D array, then &lt;code&gt;p(x)&lt;/code&gt; will have the same shape as &lt;code&gt;x&lt;/code&gt;. If &lt;code&gt;r&lt;/code&gt; is multidimensional, then the shape of the result depends on the value of &lt;code&gt;tensor&lt;/code&gt;. If &lt;code&gt;tensor is ``True`&lt;/code&gt; the shape will be r.shape[1:] + x.shape; that is, each polynomial is evaluated at every value of &lt;code&gt;x&lt;/code&gt;. If &lt;code&gt;tensor&lt;/code&gt; is &lt;code&gt;False&lt;/code&gt;, the shape will be r.shape[1:]; that is, each polynomial is evaluated only for the corresponding broadcast value of &lt;code&gt;x&lt;/code&gt;. Note that scalars have shape (,).</source>
          <target state="translated">Если &lt;code&gt;r&lt;/code&gt; - одномерный массив, то &lt;code&gt;p(x)&lt;/code&gt; будет иметь ту же форму, что и &lt;code&gt;x&lt;/code&gt; . Если &lt;code&gt;r&lt;/code&gt; многомерно, то форма результата зависит от значения &lt;code&gt;tensor&lt;/code&gt; . Если &lt;code&gt;tensor is ``True`&lt;/code&gt; форма будет иметь вид r.shape [1:] + x.shape; то есть каждый полином оценивается при каждом значении &lt;code&gt;x&lt;/code&gt; . Если &lt;code&gt;tensor&lt;/code&gt; равен &lt;code&gt;False&lt;/code&gt; , форма будет r.shape [1:]; то есть каждый полином оценивается только для соответствующего широковещательного значения &lt;code&gt;x&lt;/code&gt; . Обратите внимание, что скаляры имеют форму (,).</target>
        </trans-unit>
        <trans-unit id="16d6bbf3ace149a532102c10ab8ede2738b896bf" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;r&lt;/code&gt; is of length &lt;code&gt;N&lt;/code&gt;, this function returns the value</source>
          <target state="translated">Если &lt;code&gt;r&lt;/code&gt; имеет длину &lt;code&gt;N&lt;/code&gt; , эта функция возвращает значение</target>
        </trans-unit>
        <trans-unit id="6bc06c8f2ea0c3500f46f216948ca646bd403c39" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;rep&lt;/code&gt; is an instance of a scalar dtype, True is returned. If not, False is returned.</source>
          <target state="translated">Если &lt;code&gt;rep&lt;/code&gt; является экземпляром скалярного типа dtype, возвращается True. В противном случае возвращается False.</target>
        </trans-unit>
        <trans-unit id="caf6ef0eb6bbcb3c4e7a4a5b04998bc1341e6eb1" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;reps&lt;/code&gt; has length &lt;code&gt;d&lt;/code&gt;, the result will have dimension of &lt;code&gt;max(d, A.ndim)&lt;/code&gt;.</source>
          <target state="translated">Если &lt;code&gt;reps&lt;/code&gt; имеют длину &lt;code&gt;d&lt;/code&gt; , результат будет иметь размерность &lt;code&gt;max(d, A.ndim)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="15d930e73a09a54bb69273b247bbe9349e70a0c0" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;rowvar&lt;/code&gt; is True (default), then each row represents a variable, with observations in the columns. Otherwise, the relationship is transposed: each column represents a variable, while the rows contain observations.</source>
          <target state="translated">Если &lt;code&gt;rowvar&lt;/code&gt; имеет значение True (по умолчанию), то каждая строка представляет переменную с наблюдениями в столбцах. В противном случае связь транспонируется: каждый столбец представляет переменную, а строки содержат наблюдения.</target>
        </trans-unit>
        <trans-unit id="0e485a675b3c010a2a7eedd59e29811b56d30eeb" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;s&lt;/code&gt; and &lt;code&gt;axes&lt;/code&gt; have different length, or &lt;code&gt;axes&lt;/code&gt; not given and &lt;code&gt;len(s) != 2&lt;/code&gt;.</source>
          <target state="translated">Если &lt;code&gt;s&lt;/code&gt; и &lt;code&gt;axes&lt;/code&gt; имеют разную длину или &lt;code&gt;axes&lt;/code&gt; не указаны и &lt;code&gt;len(s) != 2&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b1a95f9d4c94712a6711035b0d38ca6007922134" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;s&lt;/code&gt; and &lt;code&gt;axes&lt;/code&gt; have different length.</source>
          <target state="translated">Если &lt;code&gt;s&lt;/code&gt; и &lt;code&gt;axes&lt;/code&gt; имеют разную длину.</target>
        </trans-unit>
        <trans-unit id="7c3cc7c092c11cc91fc3de1425949e6b1c9585a0" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;sctype&lt;/code&gt; is an object for which the type can not be inferred.</source>
          <target state="translated">Если &lt;code&gt;sctype&lt;/code&gt; - это объект, для которого нельзя вывести тип.</target>
        </trans-unit>
        <trans-unit id="0aeaeba3f41f378516fdce780d9277e8a4ccfffb" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;self.shape[k] == 1&lt;/code&gt; then for any legal index &lt;code&gt;index[k] == 0&lt;/code&gt;. This means that in the formula for the offset</source>
          <target state="translated">Если &lt;code&gt;self.shape[k] == 1&lt;/code&gt; то для любого допустимого индекса &lt;code&gt;index[k] == 0&lt;/code&gt; . Это означает, что в формуле смещения</target>
        </trans-unit>
        <trans-unit id="8e5eb20061bb0d5a1e031a6a1b5daa75d4a16cad" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;self&lt;/code&gt; is non-singular, &lt;code&gt;ret&lt;/code&gt; is such that &lt;code&gt;ret * self&lt;/code&gt; == &lt;code&gt;self * ret&lt;/code&gt; == &lt;code&gt;np.matrix(np.eye(self[0,:].size)&lt;/code&gt; all return &lt;code&gt;True&lt;/code&gt;.</source>
          <target state="translated">Если &lt;code&gt;self&lt;/code&gt; не единственное число, &lt;code&gt;ret&lt;/code&gt; таково, что &lt;code&gt;ret * self&lt;/code&gt; == &lt;code&gt;self * ret&lt;/code&gt; == &lt;code&gt;np.matrix(np.eye(self[0,:].size)&lt;/code&gt; все возвращают &lt;code&gt;True&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b27bb431dc045601d86e73a474de86c64d035384" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;self&lt;/code&gt; is singular.</source>
          <target state="translated">Если &lt;code&gt;self&lt;/code&gt; - единственное число.</target>
        </trans-unit>
        <trans-unit id="a097af1908df1ac936bba64c59e9507a0eb901d2" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;sep&lt;/code&gt; is not specified or &lt;code&gt;None&lt;/code&gt;, any whitespace string is a separator.</source>
          <target state="translated">Если &lt;code&gt;sep&lt;/code&gt; не указан или &lt;code&gt;None&lt;/code&gt; , любая строка с пробелами является разделителем.</target>
        </trans-unit>
        <trans-unit id="768a6e9085deaf336653d5c9857ddf9b254027d0" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;shape&lt;/code&gt; has length one i.e. &lt;code&gt;(N,)&lt;/code&gt;, or is a scalar &lt;code&gt;N&lt;/code&gt;, &lt;code&gt;out&lt;/code&gt; becomes a single row matrix of shape &lt;code&gt;(1,N)&lt;/code&gt;.</source>
          <target state="translated">Если &lt;code&gt;shape&lt;/code&gt; имеет длину один, т.е. &lt;code&gt;(N,)&lt;/code&gt; , или является скаляром &lt;code&gt;N&lt;/code&gt; , &lt;code&gt;out&lt;/code&gt; становится матрицей с одной строкой формы &lt;code&gt;(1,N)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5d3a0815985e487dc8833e6a9544cd8f4d19132e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;tol&lt;/code&gt; &amp;lt; 0</source>
          <target state="translated">Если &lt;code&gt;tol&lt;/code&gt; &amp;lt;0</target>
        </trans-unit>
        <trans-unit id="6cf15e83c2fdf72b1f29bfc75044966bd6bc1399" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;v&lt;/code&gt; is a 2-D array, return a copy of its &lt;code&gt;k&lt;/code&gt;-th diagonal. If &lt;code&gt;v&lt;/code&gt; is a 1-D array, return a 2-D array with &lt;code&gt;v&lt;/code&gt; on the &lt;code&gt;k&lt;/code&gt;-th diagonal.</source>
          <target state="translated">Если &lt;code&gt;v&lt;/code&gt; - двумерный массив, вернуть копию его &lt;code&gt;k&lt;/code&gt; -й диагонали. Если &lt;code&gt;v&lt;/code&gt; является 1-мерным массивом, вернуть 2-мерный массив с &lt;code&gt;v&lt;/code&gt; на &lt;code&gt;k&lt;/code&gt; -й диагонали.</target>
        </trans-unit>
        <trans-unit id="8349a8e04c4275fccf8d4c40bdfe6166a838f29e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;v&lt;/code&gt; is longer than &lt;code&gt;a&lt;/code&gt;, the arrays are swapped before computation.</source>
          <target state="translated">Если &lt;code&gt;v&lt;/code&gt; больше &lt;code&gt;a&lt;/code&gt; , перед вычислением массивы меняются местами.</target>
        </trans-unit>
        <trans-unit id="bfdbe84100978bde6f35b9bd48d4f5ad4bf72c8d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;values&lt;/code&gt; is not the same size as &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;mask&lt;/code&gt; then it will repeat. This gives behavior different from &lt;code&gt;a[mask] = values&lt;/code&gt;.</source>
          <target state="translated">Если &lt;code&gt;values&lt;/code&gt; не то же размера , как и &lt;code&gt;mask&lt;/code&gt; то он будет повторяться. Это дает поведение, отличное от &lt;code&gt;a[mask] = values&lt;/code&gt; . &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="54792a3abbf75ac3395cbad014c19ac2ff1595e1" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;values&lt;/code&gt; is smaller than &lt;code&gt;a&lt;/code&gt; it is repeated:</source>
          <target state="translated">Если &lt;code&gt;values&lt;/code&gt; меньше, чем &lt;code&gt;a&lt;/code&gt; , он повторяется:</target>
        </trans-unit>
        <trans-unit id="d3b50be1f74d03f550d5fd9dbbf8a888d565797b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;x2&lt;/code&gt; is a scalar, its sign will be copied to all elements of &lt;code&gt;x1&lt;/code&gt;.</source>
          <target state="translated">Если &lt;code&gt;x2&lt;/code&gt; - скаляр, его знак будет скопирован для всех элементов &lt;code&gt;x1&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b5f780e2f5cb497ee27a4b50260d939ccb5e1976" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;x&lt;/code&gt; is a list or tuple, it is converted to an ndarray, otherwise it is left unchanged and treated as a scalar. In either case, &lt;code&gt;x&lt;/code&gt; or its elements must support addition and multiplication with with themselves and with the elements of &lt;code&gt;c&lt;/code&gt;.</source>
          <target state="translated">Если &lt;code&gt;x&lt;/code&gt; является списком или кортежем, он преобразуется в ndarray, в противном случае он остается неизменным и рассматривается как скаляр. В любом случае &lt;code&gt;x&lt;/code&gt; или его элементы должны поддерживать сложение и умножение с самими собой и с элементами &lt;code&gt;c&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e9289f94a42ce2a055130aa0322c6aa21e4c7a12" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;x&lt;/code&gt; is a list or tuple, it is converted to an ndarray, otherwise it is left unchanged and treated as a scalar. In either case, &lt;code&gt;x&lt;/code&gt; or its elements must support addition and multiplication with with themselves and with the elements of &lt;code&gt;r&lt;/code&gt;.</source>
          <target state="translated">Если &lt;code&gt;x&lt;/code&gt; является списком или кортежем, он преобразуется в ndarray, в противном случае он остается неизменным и рассматривается как скаляр. В любом случае &lt;code&gt;x&lt;/code&gt; или его элементы должны поддерживать сложение и умножение с самими собой и с элементами &lt;code&gt;r&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0f3c93ccc6b110d8957f1eff605f32da46911a50" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;x&lt;/code&gt; is a multi-dimensional array, it is only shuffled along its first index.</source>
          <target state="translated">Если &lt;code&gt;x&lt;/code&gt; - многомерный массив, он перемещается только по первому индексу.</target>
        </trans-unit>
        <trans-unit id="10902731cd32fb924a9fa6246d242dab230b11a1" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;x&lt;/code&gt; is a poly1d instance, the result is the composition of the two polynomials, i.e., &lt;code&gt;x&lt;/code&gt; is &amp;ldquo;substituted&amp;rdquo; in &lt;code&gt;p&lt;/code&gt; and the simplified result is returned. In addition, the type of &lt;code&gt;x&lt;/code&gt; - array_like or poly1d - governs the type of the output: &lt;code&gt;x&lt;/code&gt; array_like =&amp;gt; &lt;code&gt;values&lt;/code&gt; array_like, &lt;code&gt;x&lt;/code&gt; a poly1d object =&amp;gt; &lt;code&gt;values&lt;/code&gt; is also.</source>
          <target state="translated">Если &lt;code&gt;x&lt;/code&gt; является экземпляром poly1d, результатом является композиция двух многочленов, т. Е. &lt;code&gt;x&lt;/code&gt; &amp;laquo;подставляется&amp;raquo; в &lt;code&gt;p&lt;/code&gt; , и возвращается упрощенный результат. Кроме того, тип &lt;code&gt;x&lt;/code&gt; - array_like или poly1d - определяет тип вывода: &lt;code&gt;x&lt;/code&gt; array_like =&amp;gt; &lt;code&gt;values&lt;/code&gt; array_like, &lt;code&gt;x&lt;/code&gt; a poly1d object =&amp;gt; &lt;code&gt;values&lt;/code&gt; также.</target>
        </trans-unit>
        <trans-unit id="d6a5280b73875b8ad0b036e2ed1535be94a86966" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;x&lt;/code&gt; is a sequence, then &lt;code&gt;p(x)&lt;/code&gt; is returned for each element of &lt;code&gt;x&lt;/code&gt;. If &lt;code&gt;x&lt;/code&gt; is another polynomial then the composite polynomial &lt;code&gt;p(x(t))&lt;/code&gt; is returned.</source>
          <target state="translated">Если &lt;code&gt;x&lt;/code&gt; - последовательность, то &lt;code&gt;p(x)&lt;/code&gt; возвращается для каждого элемента &lt;code&gt;x&lt;/code&gt; . Если &lt;code&gt;x&lt;/code&gt; - другой многочлен, то возвращается составной многочлен &lt;code&gt;p(x(t))&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e418b1b9672c946b1ca5e8afc3125fd05c313b38" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;x&lt;/code&gt; is a subtype of &lt;a href=&quot;numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;ndarray&lt;/code&gt;&lt;/a&gt; the return value will be of the same type.</source>
          <target state="translated">Если &lt;code&gt;x&lt;/code&gt; является подтипом &lt;a href=&quot;numpy.ndarray#numpy.ndarray&quot;&gt; &lt;code&gt;ndarray&lt;/code&gt; ,&lt;/a&gt; возвращаемое значение будет того же типа.</target>
        </trans-unit>
        <trans-unit id="2f55968163fb644f21e767c8ca56c7265582f682" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;x&lt;/code&gt; is an integer, randomly permute &lt;code&gt;np.arange(x)&lt;/code&gt;. If &lt;code&gt;x&lt;/code&gt; is an array, make a copy and shuffle the elements randomly.</source>
          <target state="translated">Если &lt;code&gt;x&lt;/code&gt; - целое число, случайным образом переставьте &lt;code&gt;np.arange(x)&lt;/code&gt; . Если &lt;code&gt;x&lt;/code&gt; - массив, сделайте копию и случайным образом перемешайте элементы.</target>
        </trans-unit>
        <trans-unit id="8675c9efb1c5ad5afa002d06cb6dcceef7c6f2a3" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;x&lt;/code&gt; is inexact, NaN is replaced by zero or by the user defined value in &lt;a href=&quot;../constants#numpy.nan&quot;&gt;&lt;code&gt;nan&lt;/code&gt;&lt;/a&gt; keyword, infinity is replaced by the largest finite floating point values representable by &lt;code&gt;x.dtype&lt;/code&gt; or by the user defined value in &lt;code&gt;posinf&lt;/code&gt; keyword and -infinity is replaced by the most negative finite floating point values representable by &lt;code&gt;x.dtype&lt;/code&gt; or by the user defined value in &lt;code&gt;neginf&lt;/code&gt; keyword.</source>
          <target state="translated">Если &lt;code&gt;x&lt;/code&gt; неточен, NaN заменяется нулем или определенным пользователем значением в ключевом слове &lt;a href=&quot;../constants#numpy.nan&quot;&gt; &lt;code&gt;nan&lt;/code&gt; &lt;/a&gt; , бесконечность заменяется наибольшими конечными значениями с плавающей запятой, представленными &lt;code&gt;x.dtype&lt;/code&gt; или определенным пользователем значением в &lt;code&gt;posinf&lt;/code&gt; слове posinf, а -infinity заменяется на самые отрицательные конечные значения с плавающей запятой, представленные &lt;code&gt;x.dtype&lt;/code&gt; или пользовательским значением в &lt;code&gt;neginf&lt;/code&gt; слове neginf .</target>
        </trans-unit>
        <trans-unit id="a12bcfaac2b6a0d5eb775110eb5d113a7ffcf89b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;x&lt;/code&gt; is not inexact, then no replacements are made.</source>
          <target state="translated">Если &lt;code&gt;x&lt;/code&gt; не является неточным, то замены не производятся.</target>
        </trans-unit>
        <trans-unit id="dab92b609c96bcdc43f19efa69fe1680ecbcb0cf" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;x&lt;/code&gt; is of a signed integer type, then the output type is the default platform integer:</source>
          <target state="translated">Если &lt;code&gt;x&lt;/code&gt; имеет целочисленный тип со знаком, то тип вывода - это целое число платформы по умолчанию:</target>
        </trans-unit>
        <trans-unit id="9b8211170506c6269c7986617b768331c6cb9374" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;xp&lt;/code&gt; and &lt;code&gt;fp&lt;/code&gt; have different length If &lt;code&gt;xp&lt;/code&gt; or &lt;code&gt;fp&lt;/code&gt; are not 1-D sequences If &lt;code&gt;period == 0&lt;/code&gt;</source>
          <target state="translated">Если &lt;code&gt;xp&lt;/code&gt; и &lt;code&gt;fp&lt;/code&gt; имеют разную длину Если &lt;code&gt;xp&lt;/code&gt; или &lt;code&gt;fp&lt;/code&gt; не являются одномерными последовательностями Если &lt;code&gt;period == 0&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="3c2455250a9da7702638a12b7e54e59f4d21fc53" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;arr&lt;/em&gt; is an array, returns its data type descriptor, but if &lt;em&gt;arr&lt;/em&gt; is an array scalar (has 0 dimensions), it finds the data type of smallest size to which the value may be converted without overflow or truncation to an integer.</source>
          <target state="translated">Если &lt;em&gt;arr&lt;/em&gt; является массивом, возвращает его дескриптор типа данных, но если &lt;em&gt;arr&lt;/em&gt; является скаляром массива (имеет 0 измерений), он находит тип данных наименьшего размера, в который значение может быть преобразовано без переполнения или усечения до целого числа.</target>
        </trans-unit>
        <trans-unit id="a70ed9437e4a5163189d25b472581eabce8d5ceb" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;axis&lt;/em&gt; is &lt;em&gt;None&lt;/em&gt; (the default), the array is treated as a 1-D array and the operation is performed over the entire array. This behavior is also the default if self is a 0-dimensional array or array scalar. (An array scalar is an instance of the types/classes float32, float64, etc., whereas a 0-dimensional array is an ndarray instance containing precisely one array scalar.)</source>
          <target state="translated">Если &lt;em&gt;ось&lt;/em&gt; не является &lt;em&gt;None&lt;/em&gt; (по умолчанию), массив рассматривается как массив 1-D и операция выполняется в течение всего массива. Это поведение также используется по умолчанию, если self является 0-мерным массивом или скаляром массива. (Скаляр массива - это экземпляр типов / классов float32, float64 и т. Д., Тогда как 0-мерный массив - это экземпляр ndarray, содержащий ровно один скаляр массива.)</target>
        </trans-unit>
        <trans-unit id="9235232429102d093beb5f545c26b8fef229f79b" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;axis&lt;/em&gt; is an integer, then the operation is done over the given axis (for each 1-D subarray that can be created along the given axis).</source>
          <target state="translated">Если &lt;em&gt;ось&lt;/em&gt; является целым числом, то операция выполняется над данной осью (для каждого одномерного подмассива, который может быть создан вдоль данной оси).</target>
        </trans-unit>
        <trans-unit id="1b1a4ec186584bdfde20daf47a6283f1daa2a542" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;data&lt;/em&gt; is &lt;code&gt;NULL&lt;/code&gt;, then new unitinialized memory will be allocated and &lt;em&gt;flags&lt;/em&gt; can be non-zero to indicate a Fortran-style contiguous array. Use &lt;a href=&quot;#c.PyArray_FILLWBYTE&quot;&gt;&lt;code&gt;PyArray_FILLWBYTE&lt;/code&gt;&lt;/a&gt; to initialize the memory.</source>
          <target state="translated">Если &lt;em&gt;data&lt;/em&gt; имеет &lt;code&gt;NULL&lt;/code&gt; , тогда будет выделена новая единичная память, а &lt;em&gt;флаги&lt;/em&gt; могут быть ненулевыми, чтобы указать непрерывный массив в стиле Fortran. Используйте &lt;a href=&quot;#c.PyArray_FILLWBYTE&quot;&gt; &lt;code&gt;PyArray_FILLWBYTE&lt;/code&gt; &lt;/a&gt; для инициализации памяти.</target>
        </trans-unit>
        <trans-unit id="6b3854bd1e23682951d79d6393e1c1b2b19835be" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;data&lt;/em&gt; is not &lt;code&gt;NULL&lt;/code&gt;, then it is assumed to point to the memory to be used for the array and the &lt;em&gt;flags&lt;/em&gt; argument is used as the new flags for the array (except the state of &lt;code&gt;NPY_OWNDATA&lt;/code&gt;, &lt;a href=&quot;#c.NPY_ARRAY_WRITEBACKIFCOPY&quot;&gt;&lt;code&gt;NPY_ARRAY_WRITEBACKIFCOPY&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#c.NPY_ARRAY_UPDATEIFCOPY&quot;&gt;&lt;code&gt;NPY_ARRAY_UPDATEIFCOPY&lt;/code&gt;&lt;/a&gt; flags of the new array will be reset).</source>
          <target state="translated">Если &lt;em&gt;данные&lt;/em&gt; не &lt;code&gt;NULL&lt;/code&gt; , то предполагается, что они указывают на память, которая будет использоваться для массива, и аргумент &lt;em&gt;flags&lt;/em&gt; используется в качестве новых флагов для массива (кроме состояния &lt;code&gt;NPY_OWNDATA&lt;/code&gt; , &lt;a href=&quot;#c.NPY_ARRAY_WRITEBACKIFCOPY&quot;&gt; &lt;code&gt;NPY_ARRAY_WRITEBACKIFCOPY&lt;/code&gt; &lt;/a&gt; и &lt;a href=&quot;#c.NPY_ARRAY_UPDATEIFCOPY&quot;&gt; &lt;code&gt;NPY_ARRAY_UPDATEIFCOPY&lt;/code&gt; &lt;/a&gt; флагов нового массива будут быть сброшенным).</target>
        </trans-unit>
        <trans-unit id="9cebbbbcc1739892f8b12e053651c131570cd283" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;descr&lt;/em&gt; is NULL, the data type of &lt;em&gt;prototype&lt;/em&gt; is used.</source>
          <target state="translated">Если &lt;em&gt;descr&lt;/em&gt; равно NULL, используется тип данных &lt;em&gt;прототипа&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="aec9506a456027cf0203832745240a439d9ff187" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;dtype&lt;/em&gt; is &lt;code&gt;NULL&lt;/code&gt;, then the returned array will have the same data type as &lt;em&gt;self&lt;/em&gt;. The new data-type must be consistent with the size of &lt;em&gt;self&lt;/em&gt;. Either the itemsizes must be identical, or &lt;em&gt;self&lt;/em&gt; must be single-segment and the total number of bytes must be the same. In the latter case the dimensions of the returned array will be altered in the last (or first for Fortran-style contiguous arrays) dimension. The data area of the returned array and self is exactly the same.</source>
          <target state="translated">Если &lt;em&gt;dtype&lt;/em&gt; равен &lt;code&gt;NULL&lt;/code&gt; , то возвращаемый массив будет иметь тот же тип данных, что и &lt;em&gt;self&lt;/em&gt; . Новый тип данных должен соответствовать размеру &lt;em&gt;self&lt;/em&gt; . Либо размеры элементов должны быть идентичны, либо элементы &lt;em&gt;self&lt;/em&gt; должны быть односегментными и общее количество байтов должно быть одинаковым. В последнем случае размеры возвращаемого массива будут изменены в последнем (или первом для непрерывных массивов в стиле Фортран) измерении. Область данных возвращаемого массива и self точно такая же.</target>
        </trans-unit>
        <trans-unit id="b00215400909f507a463937ff52555cace4d8945" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;op&lt;/em&gt; is already an array, but does not satisfy the requirements, then a copy is made (which will satisfy the requirements). If this flag is present and a copy (of an object that is already an array) must be made, then the corresponding &lt;a href=&quot;#c.NPY_ARRAY_WRITEBACKIFCOPY&quot;&gt;&lt;code&gt;NPY_ARRAY_WRITEBACKIFCOPY&lt;/code&gt;&lt;/a&gt; flag is set in the returned copy and &lt;em&gt;op&lt;/em&gt; is made to be read-only. You must be sure to call &lt;a href=&quot;#c.PyArray_ResolveWritebackIfCopy&quot;&gt;&lt;code&gt;PyArray_ResolveWritebackIfCopy&lt;/code&gt;&lt;/a&gt; to copy the contents back into &lt;em&gt;op&lt;/em&gt; and the &lt;em&gt;op&lt;/em&gt; array will be made writeable again. If &lt;em&gt;op&lt;/em&gt; is not writeable to begin with, or if it is not already an array, then an error is raised.</source>
          <target state="translated">Если &lt;em&gt;op&lt;/em&gt; уже является массивом, но не удовлетворяет требованиям, создается копия (которая удовлетворяет требованиям). Если этот флаг присутствует и должна быть сделана копия (объекта, который уже является массивом), то в возвращаемой копии устанавливается соответствующий флаг &lt;a href=&quot;#c.NPY_ARRAY_WRITEBACKIFCOPY&quot;&gt; &lt;code&gt;NPY_ARRAY_WRITEBACKIFCOPY&lt;/code&gt; ,и операция&lt;/a&gt;&lt;em&gt; op&lt;/em&gt; становится доступной только для чтения. Вы должны обязательно вызвать &lt;a href=&quot;#c.PyArray_ResolveWritebackIfCopy&quot;&gt; &lt;code&gt;PyArray_ResolveWritebackIfCopy&lt;/code&gt; ,&lt;/a&gt; чтобы скопировать содержимое обратно в &lt;em&gt;op,&lt;/em&gt; и массив &lt;em&gt;op&lt;/em&gt; снова станет доступным для записи. Если &lt;em&gt;op&lt;/em&gt; не может быть записан с самого начала или если он еще не является массивом, возникает ошибка.</target>
        </trans-unit>
        <trans-unit id="2b3d523872c6239b2b47533fe932fb9b935c7ec9" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;permute&lt;/em&gt; is &lt;code&gt;NULL&lt;/code&gt;, the shape of the result is</source>
          <target state="translated">Если &lt;em&gt;перестановка&lt;/em&gt; равна &lt;code&gt;NULL&lt;/code&gt; , форма результата будет</target>
        </trans-unit>
        <trans-unit id="864a2871c8455778be67517dc3e9f63ae59a60fb" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;subok&lt;/em&gt; is 1, the newly created array will use the sub-type of &lt;em&gt;prototype&lt;/em&gt; to create the new array, otherwise it will create a base-class array.</source>
          <target state="translated">Если &lt;em&gt;subok&lt;/em&gt; равен 1, вновь созданный массив будет использовать подтип &lt;em&gt;прототипа&lt;/em&gt; для создания нового массива, в противном случае он создаст массив базового класса.</target>
        </trans-unit>
        <trans-unit id="d7c8774de40710ea170a99b3d842fc0b2a6f66b4" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;subtype&lt;/em&gt; is of an array subclass instead of the base &lt;a href=&quot;c-api.types-and-structures#c.PyArray_Type&quot;&gt;&lt;code&gt;&amp;amp;PyArray_Type&lt;/code&gt;&lt;/a&gt;, then &lt;em&gt;obj&lt;/em&gt; is the object to pass to the &lt;a href=&quot;arrays.classes#numpy.class.__array_finalize__&quot;&gt;&lt;code&gt;__array_finalize__&lt;/code&gt;&lt;/a&gt; method of the subclass.</source>
          <target state="translated">Если &lt;em&gt;подтип&lt;/em&gt; относится к подклассу массива, а не к базовому &lt;a href=&quot;c-api.types-and-structures#c.PyArray_Type&quot;&gt; &lt;code&gt;&amp;amp;PyArray_Type&lt;/code&gt; &lt;/a&gt; , тогда &lt;em&gt;obj&lt;/em&gt; является объектом, передаваемым методу &lt;a href=&quot;arrays.classes#numpy.class.__array_finalize__&quot;&gt; &lt;code&gt;__array_finalize__&lt;/code&gt; &lt;/a&gt; подкласса.</target>
        </trans-unit>
        <trans-unit id="c808aeb714f46484081440736a2f659eda1cb00f" translate="yes" xml:space="preserve">
          <source>If A = qr such that q is orthonormal (which is always possible via Gram-Schmidt), then &lt;code&gt;x = inv(r) * (q.T) * b&lt;/code&gt;. (In numpy practice, however, we simply use &lt;a href=&quot;numpy.linalg.lstsq#numpy.linalg.lstsq&quot;&gt;&lt;code&gt;lstsq&lt;/code&gt;&lt;/a&gt;.)</source>
          <target state="translated">Если A = qr такое, что q ортонормировано (что всегда возможно по Граму-Шмидту), то &lt;code&gt;x = inv(r) * (q.T) * b&lt;/code&gt; . (Однако на практике мы просто используем &lt;a href=&quot;numpy.linalg.lstsq#numpy.linalg.lstsq&quot;&gt; &lt;code&gt;lstsq&lt;/code&gt; &lt;/a&gt; .)</target>
        </trans-unit>
        <trans-unit id="a5523a2784c429b6ba47e45d47c8a0bb942c669e" translate="yes" xml:space="preserve">
          <source>If False, a view into the original arrays are returned in order to conserve memory. Default is True. Please note that &lt;code&gt;sparse=False, copy=False&lt;/code&gt; will likely return non-contiguous arrays. Furthermore, more than one element of a broadcast array may refer to a single memory location. If you need to write to the arrays, make copies first.</source>
          <target state="translated">Если значение равно False, для экономии памяти возвращается представление исходных массивов. По умолчанию True. Обратите внимание, что &lt;code&gt;sparse=False, copy=False&lt;/code&gt; , скорее всего, вернет несмежные массивы. Кроме того, более одного элемента массива широковещательной рассылки могут относиться к одной ячейке памяти. Если вам нужно записать в массивы, сначала сделайте копии.</target>
        </trans-unit>
        <trans-unit id="343caea52a4d2f3f220c6f641bc3ef525fc8ff10" translate="yes" xml:space="preserve">
          <source>If False, reference count will not be checked. Default is True.</source>
          <target state="translated">Если Фальшивка,подсчет ссылок не будет проверен.По умолчанию-Истина.</target>
        </trans-unit>
        <trans-unit id="cc82a0ba7e27b536a6fe2ae6adeaa5a186566e3c" translate="yes" xml:space="preserve">
          <source>If False, the default, returns the number of samples in each bin. If True, returns the probability &lt;em&gt;density&lt;/em&gt; function at the bin, &lt;code&gt;bin_count / sample_count / bin_area&lt;/code&gt;.</source>
          <target state="translated">Если значение по умолчанию равно False, возвращается количество образцов в каждой ячейке. Если True, возвращает функцию &lt;em&gt;плотности&lt;/em&gt; вероятности в &lt;code&gt;bin_count / sample_count / bin_area&lt;/code&gt; , bin_count / sample_count / bin_area .</target>
        </trans-unit>
        <trans-unit id="023ffe5319599a1faa2198b591752fc4467344db" translate="yes" xml:space="preserve">
          <source>If False, the default, returns the number of samples in each bin. If True, returns the probability &lt;em&gt;density&lt;/em&gt; function at the bin, &lt;code&gt;bin_count / sample_count / bin_volume&lt;/code&gt;.</source>
          <target state="translated">Если значение по умолчанию равно False, возвращается количество образцов в каждой ячейке. Если True, возвращает функцию &lt;em&gt;плотности&lt;/em&gt; вероятности в &lt;code&gt;bin_count / sample_count / bin_volume&lt;/code&gt; , bin_count / sample_count / bin_volume .</target>
        </trans-unit>
        <trans-unit id="a65d3c4015ca8415c134fa3b89bccc8e92003c36" translate="yes" xml:space="preserve">
          <source>If K = min(M, N), then</source>
          <target state="translated">Если K=мин(M,N),то</target>
        </trans-unit>
        <trans-unit id="c8fe35dc8be08c32dcc7a321c29a26e840a0b0cb" translate="yes" xml:space="preserve">
          <source>If None, the index is into the flattened array, otherwise along the specified axis</source>
          <target state="translated">Если None,то индекс находится в сплющенном массиве,в противном случае вдоль указанной оси.</target>
        </trans-unit>
        <trans-unit id="b2ed776381411dcc06237a74c5e85611ae70c52e" translate="yes" xml:space="preserve">
          <source>If None, then the path is assumed to be the local path plus the subpackage_name. If a setup.py file is not found in the subpackage_path, then a default configuration is used.</source>
          <target state="translated">Если None,то предполагается,что это локальный путь плюс имя_субпакета.Если файл setup.py не найден в пути subpackage_path,то используется конфигурация по умолчанию.</target>
        </trans-unit>
        <trans-unit id="7f68badbcb18a0e633a2cc1aee70bc74cc566792" translate="yes" xml:space="preserve">
          <source>If None, use a MaskType instance. Otherwise, use a new datatype with the same fields as &lt;code&gt;dtype&lt;/code&gt;, converted to boolean types.</source>
          <target state="translated">Если None, используйте экземпляр MaskType. В противном случае используйте новый тип данных с теми же полями, что и &lt;code&gt;dtype&lt;/code&gt; , преобразованный в логические типы.</target>
        </trans-unit>
        <trans-unit id="b88b29f182ab4a1e89998e5d778c700419477eb5" translate="yes" xml:space="preserve">
          <source>If SVD computation does not converge.</source>
          <target state="translated">Если вычисления SVD не сходятся.</target>
        </trans-unit>
        <trans-unit id="1c8e91eba4c31b07d056c5e107cd3dbd66e73c1f" translate="yes" xml:space="preserve">
          <source>If True (default) make a copy of &lt;code&gt;a&lt;/code&gt; in the result. If False modify &lt;code&gt;a&lt;/code&gt; in place and return a view.</source>
          <target state="translated">Если True ( по умолчанию) сделайте копию в результате. Если False, измените &lt;code&gt;a&lt;/code&gt; на месте и верните представление. &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="5f05298246a514cfbe30605192f5c3eec0c39e89" translate="yes" xml:space="preserve">
          <source>If True (default), &lt;code&gt;u&lt;/code&gt; and &lt;code&gt;vh&lt;/code&gt; have the shapes &lt;code&gt;(..., M, M)&lt;/code&gt; and &lt;code&gt;(..., N, N)&lt;/code&gt;, respectively. Otherwise, the shapes are &lt;code&gt;(..., M, K)&lt;/code&gt; and &lt;code&gt;(..., K, N)&lt;/code&gt;, respectively, where &lt;code&gt;K = min(M, N)&lt;/code&gt;.</source>
          <target state="translated">Если True (по умолчанию), &lt;code&gt;u&lt;/code&gt; и &lt;code&gt;vh&lt;/code&gt; имеют формы &lt;code&gt;(..., M, M)&lt;/code&gt; и &lt;code&gt;(..., N, N)&lt;/code&gt; соответственно. В противном случае формы будут &lt;code&gt;(..., M, K)&lt;/code&gt; и &lt;code&gt;(..., K, N)&lt;/code&gt; соответственно, где &lt;code&gt;K = min(M, N)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b7193bd03fb8a4044e82de41b9072ea59ef18024" translate="yes" xml:space="preserve">
          <source>If True (default), the function for pretty printing (&lt;code&gt;__repr__&lt;/code&gt;) is set, if False the function that returns the default string representation (&lt;code&gt;__str__&lt;/code&gt;) is set.</source>
          <target state="translated">Если True (по умолчанию), устанавливается функция красивой печати ( &lt;code&gt;__repr__&lt;/code&gt; ), если False, устанавливается функция, возвращающая строковое представление по умолчанию ( &lt;code&gt;__str__&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="303e2928545dd79ae7d3ee948a353e0207edca4f" translate="yes" xml:space="preserve">
          <source>If True a sparse grid is returned in order to conserve memory. Default is False.</source>
          <target state="translated">В случае True возвращается разреженная сетка для сохранения памяти.По умолчанию-Ложь.</target>
        </trans-unit>
        <trans-unit id="963fdb4eb1744c24416dda1302569ec977b1039b" translate="yes" xml:space="preserve">
          <source>If True, &lt;code&gt;M&lt;/code&gt; is assumed to be Hermitian (symmetric if real-valued), enabling a more efficient method for finding singular values. Defaults to False.</source>
          <target state="translated">Если True, &lt;code&gt;M&lt;/code&gt; считается эрмитовым (симметричным, если действительное значение), что позволяет использовать более эффективный метод поиска сингулярных значений. По умолчанию False.</target>
        </trans-unit>
        <trans-unit id="7ff6382ed5c39a63563e9ed1fd085cab5037a2b5" translate="yes" xml:space="preserve">
          <source>If True, &lt;code&gt;a&lt;/code&gt; is assumed to be Hermitian (symmetric if real-valued), enabling a more efficient method for finding singular values. Defaults to False.</source>
          <target state="translated">Если True, предполагается , что &lt;code&gt;a&lt;/code&gt; является эрмитовым (симметричным, если имеет действительное значение), что позволяет использовать более эффективный метод поиска сингулярных значений. По умолчанию False.</target>
        </trans-unit>
        <trans-unit id="e36b410b04f66dbee1ad8585d5ab761e08ac7f58" translate="yes" xml:space="preserve">
          <source>If True, &lt;code&gt;c_or_r&lt;/code&gt; specifies the polynomial&amp;rsquo;s roots; the default is False.</source>
          <target state="translated">Если True, &lt;code&gt;c_or_r&lt;/code&gt; определяет корни многочлена; по умолчанию - False.</target>
        </trans-unit>
        <trans-unit id="d928194afbe2c2b929bfedb481313d712d7c8b8b" translate="yes" xml:space="preserve">
          <source>If True, &lt;code&gt;stop&lt;/code&gt; is the last sample. Otherwise, it is not included. Default is True.</source>
          <target state="translated">Если True, &lt;code&gt;stop&lt;/code&gt; - это последняя выборка. В противном случае он не включается. По умолчанию True.</target>
        </trans-unit>
        <trans-unit id="7b47be5e3a5ad40d6f18921eb27fcceb85292f89" translate="yes" xml:space="preserve">
          <source>If True, NaNs will compare equal.</source>
          <target state="translated">Если Правда,то NaNs будут сравнивать равные.</target>
        </trans-unit>
        <trans-unit id="cf238e83938a09d87961a742f48c2f2620eb27d1" translate="yes" xml:space="preserve">
          <source>If True, align the fields by padding as the C-compiler would. Default is False.</source>
          <target state="translated">Если параметр True,выровняйте поля с помощью набивки,как это делал бы С-компилятор.По умолчанию False.</target>
        </trans-unit>
        <trans-unit id="fac02997269b77136285be7a5e579ac29dadfffd" translate="yes" xml:space="preserve">
          <source>If True, also return the indices of &lt;code&gt;ar&lt;/code&gt; (along the specified axis, if provided, or in the flattened array) that result in the unique array.</source>
          <target state="translated">Если True, также возвращают индексы &lt;code&gt;ar&lt;/code&gt; (вдоль указанной оси, если они есть, или в сглаженном массиве), которые приводят к уникальному массиву.</target>
        </trans-unit>
        <trans-unit id="5ba4a4047dcee50611d5129a3a15323121b0e960" translate="yes" xml:space="preserve">
          <source>If True, also return the indices of the unique array (for the specified axis, if provided) that can be used to reconstruct &lt;code&gt;ar&lt;/code&gt;.</source>
          <target state="translated">Если True, также верните индексы уникального массива (для указанной оси, если он предоставлен), который можно использовать для восстановления &lt;code&gt;ar&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="399ee9e74026589c23b2445da8094594d73ae5dd" translate="yes" xml:space="preserve">
          <source>If True, also return the number of times each unique item appears in &lt;code&gt;ar&lt;/code&gt;.</source>
          <target state="translated">Если True, также верните количество раз, когда каждый уникальный элемент появляется в &lt;code&gt;ar&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="66852352128b1c7e34ad7789302cdfe6ede485bb" translate="yes" xml:space="preserve">
          <source>If True, always print floating point numbers using fixed point notation, in which case numbers equal to zero in the current precision will print as zero. If False, then scientific notation is used when absolute value of the smallest number is &amp;lt; 1e-4 or the ratio of the maximum absolute value to the minimum is &amp;gt; 1e3. The default is False.</source>
          <target state="translated">Если True, всегда печатайте числа с плавающей запятой, используя запись с фиксированной запятой, и в этом случае числа, равные нулю с текущей точностью, будут печататься как ноль. Если False, то используется научная нотация, когда абсолютное значение наименьшего числа &amp;lt;1e-4 или отношение максимального абсолютного значения к минимальному&amp;gt; 1e3. По умолчанию - False.</target>
        </trans-unit>
        <trans-unit id="cbca430a42a0182aa9ea6441a3957e8ab3c8a25b" translate="yes" xml:space="preserve">
          <source>If True, always returns a tuple.</source>
          <target state="translated">Если Правда,всегда возвращает кортеж.</target>
        </trans-unit>
        <trans-unit id="7f126462d85653c6dda1dce20f661e9fd87395a7" translate="yes" xml:space="preserve">
          <source>If True, an exception is raised if an inconsistency is detected in the number of columns. If False, a warning is emitted and the offending lines are skipped.</source>
          <target state="translated">Если Истина,то при обнаружении несоответствия в количестве столбцов повышается исключение.Если False,выдается предупреждение и пропускаются линии нарушения.</target>
        </trans-unit>
        <trans-unit id="00dd94f809ecdc81e9a20bf00165ace3a76e2409" translate="yes" xml:space="preserve">
          <source>If True, do not raise errors for invalid values.</source>
          <target state="translated">Если параметр True,не допускайте ошибок для недействительных значений.</target>
        </trans-unit>
        <trans-unit id="75ba0a561e02b7ed5e7fa180639d41ec79419f2b" translate="yes" xml:space="preserve">
          <source>If True, field names are case sensitive. If False or &amp;lsquo;upper&amp;rsquo;, field names are converted to upper case. If &amp;lsquo;lower&amp;rsquo;, field names are converted to lower case.</source>
          <target state="translated">Если True, имена полей чувствительны к регистру. Если &quot;Ложь&quot; или &quot;верхний&quot;, имена полей преобразуются в верхний регистр. Если &amp;laquo;ниже&amp;raquo;, имена полей преобразуются в нижний регистр.</target>
        </trans-unit>
        <trans-unit id="7d57971ed0ca8f21d400e58c76703f43cbfc417c" translate="yes" xml:space="preserve">
          <source>If True, masked values are propagated pair-wise: if a value is masked in &lt;code&gt;x&lt;/code&gt;, the corresponding value is masked in &lt;code&gt;y&lt;/code&gt;. If False, raises a &lt;code&gt;ValueError&lt;/code&gt; exception when some values are missing.</source>
          <target state="translated">Если True, замаскированные значения распространяются попарно: если значение замаскировано в &lt;code&gt;x&lt;/code&gt; , соответствующее значение замаскировано в &lt;code&gt;y&lt;/code&gt; . Если False, вызывает исключение &lt;code&gt;ValueError&lt;/code&gt; , когда некоторые значения отсутствуют.</target>
        </trans-unit>
        <trans-unit id="73add7a762002fef273e9b4ffea7ca56d1fceed2" translate="yes" xml:space="preserve">
          <source>If True, masked values are propagated pair-wise: if a value is masked in &lt;code&gt;x&lt;/code&gt;, the corresponding value is masked in &lt;code&gt;y&lt;/code&gt;. If False, raises an exception. Because &lt;code&gt;bias&lt;/code&gt; is deprecated, this argument needs to be treated as keyword only to avoid a warning.</source>
          <target state="translated">Если True, замаскированные значения распространяются попарно: если значение замаскировано в &lt;code&gt;x&lt;/code&gt; , соответствующее значение замаскировано в &lt;code&gt;y&lt;/code&gt; . Если False, вызывает исключение. Поскольку &lt;code&gt;bias&lt;/code&gt; не рекомендуется, этот аргумент следует рассматривать как ключевое слово только во избежание предупреждения.</target>
        </trans-unit>
        <trans-unit id="3f2788b0d6fce7deb3124b031af49411eebfd85f" translate="yes" xml:space="preserve">
          <source>If True, return (&lt;code&gt;samples&lt;/code&gt;, &lt;code&gt;step&lt;/code&gt;), where &lt;code&gt;step&lt;/code&gt; is the spacing between samples.</source>
          <target state="translated">Если True, вернуть ( &lt;code&gt;samples&lt;/code&gt; , &lt;code&gt;step&lt;/code&gt; ), где &lt;code&gt;step&lt;/code&gt; - интервал между выборками.</target>
        </trans-unit>
        <trans-unit id="1ec0fbd07daef19f7914b14e4eca0f4fd562cd19" translate="yes" xml:space="preserve">
          <source>If True, return a masked array. If False, return a regular array.</source>
          <target state="translated">Если значение True,верните массив,замаскированный под маску.Если False,вернуть обычный массив.</target>
        </trans-unit>
        <trans-unit id="23ec8ba9608d7abff50b6dc8fd3f7629dafcce5d" translate="yes" xml:space="preserve">
          <source>If True, specifies that the decorated callable is a test. If False, specifies that the decorated callable is not a test. Default is True.</source>
          <target state="translated">Если Верно,укажите,что декорированный позывной является тестом.Если False,указывает,что декорированная позывная не является тестом.Default is True.</target>
        </trans-unit>
        <trans-unit id="392d55a0a9d04db7b0ca9f8c7072e4cdcc499491" translate="yes" xml:space="preserve">
          <source>If True, subclasses are preserved.</source>
          <target state="translated">Если Правда,подклассы сохраняются.</target>
        </trans-unit>
        <trans-unit id="8d750c3ba08e3d89b81f148fbacf7cfd56b0a5f8" translate="yes" xml:space="preserve">
          <source>If True, the axes which are reduced are left in the result as dimensions with size one. With this option, the result will broadcast correctly against the original &lt;code&gt;arr&lt;/code&gt;.</source>
          <target state="translated">Если True, уменьшенные оси останутся в результате как размеры с размером один. С этой опцией результат будет транслироваться правильно относительно исходного &lt;code&gt;arr&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b2006dd9c76a3ff3a106ec273dd3c8e1e765c752" translate="yes" xml:space="preserve">
          <source>If True, the conflicting values are appended to the error message.</source>
          <target state="translated">Если значение True,то конфликтующие значения добавляются к сообщению об ошибке.</target>
        </trans-unit>
        <trans-unit id="d8ba5d3712bb2ee2efcfc81e8a867c710618acda" translate="yes" xml:space="preserve">
          <source>If True, the indices which correspond to the intersection of the two arrays are returned. The first instance of a value is used if there are multiple. Default is False.</source>
          <target state="translated">Если значение True,возвращаются индексы,соответствующие пересечению двух массивов.Первый экземпляр значения используется,если их несколько.По умолчанию False.</target>
        </trans-unit>
        <trans-unit id="796c55d79196f76e9a5e82ed451d32129c18b457" translate="yes" xml:space="preserve">
          <source>If True, the input arrays are both assumed to be unique, which can speed up the calculation. Default is False.</source>
          <target state="translated">Если значение True,то предполагается,что оба входных массива уникальны,что может ускорить вычисление.По умолчанию-False.</target>
        </trans-unit>
        <trans-unit id="4faadc5e6554004b31ce5928d5d80bd241c02388" translate="yes" xml:space="preserve">
          <source>If True, the iterator was created with either the &lt;code&gt;c_index&lt;/code&gt; or the &lt;code&gt;f_index&lt;/code&gt; flag, and the property &lt;a href=&quot;numpy.nditer.index#numpy.nditer.index&quot;&gt;&lt;code&gt;index&lt;/code&gt;&lt;/a&gt; can be used to retrieve it.</source>
          <target state="translated">Если True, итератор был создан с &lt;code&gt;c_index&lt;/code&gt; или &lt;code&gt;f_index&lt;/code&gt; , и &lt;a href=&quot;numpy.nditer.index#numpy.nditer.index&quot;&gt; &lt;code&gt;index&lt;/code&gt; &lt;/a&gt; свойства может использоваться для его получения.</target>
        </trans-unit>
        <trans-unit id="78e99fe24c914b8497fc3d013aec906afbe03579" translate="yes" xml:space="preserve">
          <source>If True, the iterator was created with the &lt;code&gt;delay_bufalloc&lt;/code&gt; flag, and no reset() function was called on it yet.</source>
          <target state="translated">Если True, итератор был создан с флагом &lt;code&gt;delay_bufalloc&lt;/code&gt; , и для него еще не вызывалась функция reset ().</target>
        </trans-unit>
        <trans-unit id="78a4539bda923dafd78fad0e5fb97c6b43556f2b" translate="yes" xml:space="preserve">
          <source>If True, the iterator was created with the &lt;code&gt;multi_index&lt;/code&gt; flag, and the property &lt;a href=&quot;numpy.nditer.multi_index#numpy.nditer.multi_index&quot;&gt;&lt;code&gt;multi_index&lt;/code&gt;&lt;/a&gt; can be used to retrieve it.</source>
          <target state="translated">Если True, итератор был создан с флагом &lt;code&gt;multi_index&lt;/code&gt; , и свойство &lt;a href=&quot;numpy.nditer.multi_index#numpy.nditer.multi_index&quot;&gt; &lt;code&gt;multi_index&lt;/code&gt; &lt;/a&gt; можно использовать для его получения.</target>
        </trans-unit>
        <trans-unit id="f4229174699f5726402f68c65f4921612f023a93" translate="yes" xml:space="preserve">
          <source>If True, the returned array is transposed, so that arguments may be unpacked using &lt;code&gt;x, y, z = loadtxt(...)&lt;/code&gt;</source>
          <target state="translated">Если True, возвращаемый массив транспонируется, так что аргументы могут быть распакованы с помощью &lt;code&gt;x, y, z = loadtxt(...)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="b9bf7edcd483311b9596b9cc1a4efa43974ee453" translate="yes" xml:space="preserve">
          <source>If True, the returned array is transposed, so that arguments may be unpacked using &lt;code&gt;x, y, z = loadtxt(...)&lt;/code&gt;. When used with a structured data-type, arrays are returned for each field. Default is False.</source>
          <target state="translated">Если True, возвращаемый массив транспонируется, так что аргументы могут быть распакованы с использованием &lt;code&gt;x, y, z = loadtxt(...)&lt;/code&gt; . При использовании со структурированным типом данных для каждого поля возвращаются массивы. По умолчанию - False.</target>
        </trans-unit>
        <trans-unit id="d43fcdb1c52440e31bff4cb2f390cb23f384392a" translate="yes" xml:space="preserve">
          <source>If True, the shape of the coefficient array is extended with ones on the right, one for each dimension of &lt;code&gt;x&lt;/code&gt;. Scalars have dimension 0 for this action. The result is that every column of coefficients in &lt;code&gt;c&lt;/code&gt; is evaluated for every element of &lt;code&gt;x&lt;/code&gt;. If False, &lt;code&gt;x&lt;/code&gt; is broadcast over the columns of &lt;code&gt;c&lt;/code&gt; for the evaluation. This keyword is useful when &lt;code&gt;c&lt;/code&gt; is multidimensional. The default value is True.</source>
          <target state="translated">Если True, форма массива коэффициентов расширяется единицами справа, по одному для каждого измерения &lt;code&gt;x&lt;/code&gt; . Скаляры имеют размерность 0 для этого действия. В результате каждый столбец коэффициентов в &lt;code&gt;c&lt;/code&gt; оценивается для каждого элемента &lt;code&gt;x&lt;/code&gt; . Если False, &lt;code&gt;x&lt;/code&gt; транслируется по столбцам &lt;code&gt;c&lt;/code&gt; для оценки. Это ключевое слово полезно, когда &lt;code&gt;c&lt;/code&gt; многомерна. Значение по умолчанию верно.</target>
        </trans-unit>
        <trans-unit id="959391ebb6591b28733d37c72b179dc2ae1393e8" translate="yes" xml:space="preserve">
          <source>If True, the shape of the roots array is extended with ones on the right, one for each dimension of &lt;code&gt;x&lt;/code&gt;. Scalars have dimension 0 for this action. The result is that every column of coefficients in &lt;code&gt;r&lt;/code&gt; is evaluated for every element of &lt;code&gt;x&lt;/code&gt;. If False, &lt;code&gt;x&lt;/code&gt; is broadcast over the columns of &lt;code&gt;r&lt;/code&gt; for the evaluation. This keyword is useful when &lt;code&gt;r&lt;/code&gt; is multidimensional. The default value is True.</source>
          <target state="translated">Если True, форма массива корней расширяется единицами справа, по одному для каждого измерения &lt;code&gt;x&lt;/code&gt; . Скаляры имеют размерность 0 для этого действия. В результате каждый столбец коэффициентов в &lt;code&gt;r&lt;/code&gt; оценивается для каждого элемента &lt;code&gt;x&lt;/code&gt; . Если False, &lt;code&gt;x&lt;/code&gt; транслируется по столбцам &lt;code&gt;r&lt;/code&gt; для оценки. Это ключевое слово полезно, когда &lt;code&gt;r&lt;/code&gt; многомерно. Значение по умолчанию верно.</target>
        </trans-unit>
        <trans-unit id="201e227337fd7a8180e5a7ed35ba4fd5fc02b88e" translate="yes" xml:space="preserve">
          <source>If True, the values in the returned array are inverted (that is, False where an element of &lt;code&gt;ar1&lt;/code&gt; is in &lt;code&gt;ar2&lt;/code&gt; and True otherwise). Default is False. &lt;code&gt;np.in1d(a, b, invert=True)&lt;/code&gt; is equivalent to (but is faster than) &lt;code&gt;np.invert(in1d(a, b))&lt;/code&gt;.</source>
          <target state="translated">Если True, значения в возвращаемом массиве инвертируются (то есть False, если элемент &lt;code&gt;ar1&lt;/code&gt; находится в &lt;code&gt;ar2&lt;/code&gt; , и True в противном случае). По умолчанию - False. &lt;code&gt;np.in1d(a, b, invert=True)&lt;/code&gt; эквивалентен (но быстрее) &lt;code&gt;np.invert(in1d(a, b))&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="259b3152dca6c438bfe50af972160ce0a4a1de26" translate="yes" xml:space="preserve">
          <source>If True, the values in the returned array are inverted, as if calculating &lt;code&gt;element not in test_elements&lt;/code&gt;. Default is False. &lt;code&gt;np.isin(a, b, invert=True)&lt;/code&gt; is equivalent to (but faster than) &lt;code&gt;np.invert(np.isin(a, b))&lt;/code&gt;.</source>
          <target state="translated">Если True, значения в возвращаемом массиве инвертируются, как будто вычисляемый &lt;code&gt;element not in test_elements&lt;/code&gt; . По умолчанию - False. &lt;code&gt;np.isin(a, b, invert=True)&lt;/code&gt; эквивалентен (но быстрее) &lt;code&gt;np.invert(np.isin(a, b))&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="945e8f6a0cee215b87f641fdb7d3287ee26a3bd1" translate="yes" xml:space="preserve">
          <source>If True, then allow the input array &lt;code&gt;a&lt;/code&gt; to be modified by intermediate calculations, to save memory. In this case, the contents of the input &lt;code&gt;a&lt;/code&gt; after this function completes is undefined.</source>
          <target state="translated">Если True, то разрешить изменение входного массива &lt;code&gt;a&lt;/code&gt; с помощью промежуточных вычислений для экономии памяти. В этом случае содержимое ввода &lt;code&gt;a&lt;/code&gt; после завершения этой функции не определено.</target>
        </trans-unit>
        <trans-unit id="efffbf4abfcfd3dab70b2b5adf8fd6ea45c7060a" translate="yes" xml:space="preserve">
          <source>If True, then allow use of memory of input array (a) for calculations. The input array will be modified by the call to median. This will save memory when you do not need to preserve the contents of the input array. Treat the input as undefined, but it will probably be fully or partially sorted. Default is False. Note that, if &lt;code&gt;overwrite_input&lt;/code&gt; is True, and the input is not already an &lt;code&gt;ndarray&lt;/code&gt;, an error will be raised.</source>
          <target state="translated">Если True, то разрешить использование памяти входного массива (a) для вычислений. Входной массив будет изменен вызовом median. Это сэкономит память, когда вам не нужно сохранять содержимое входного массива. Считайте ввод неопределенным, но он, вероятно, будет полностью или частично отсортирован. По умолчанию - False. Обратите внимание: если &lt;code&gt;overwrite_input&lt;/code&gt; имеет значение True, а вход еще не является &lt;code&gt;ndarray&lt;/code&gt; , возникнет ошибка.</target>
        </trans-unit>
        <trans-unit id="453475060bdf9f6ca07ca2a9d367c0c72b7c7341" translate="yes" xml:space="preserve">
          <source>If True, then allow use of memory of input array &lt;code&gt;a&lt;/code&gt; for calculations. The input array will be modified by the call to &lt;a href=&quot;#numpy.median&quot;&gt;&lt;code&gt;median&lt;/code&gt;&lt;/a&gt;. This will save memory when you do not need to preserve the contents of the input array. Treat the input as undefined, but it will probably be fully or partially sorted. Default is False. If &lt;code&gt;overwrite_input&lt;/code&gt; is &lt;code&gt;True&lt;/code&gt; and &lt;code&gt;a&lt;/code&gt; is not already an &lt;a href=&quot;numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;ndarray&lt;/code&gt;&lt;/a&gt;, an error will be raised.</source>
          <target state="translated">Если True, то разрешить использование памяти входного массива &lt;code&gt;a&lt;/code&gt; для вычислений. Входной массив будет изменен вызовом &lt;a href=&quot;#numpy.median&quot;&gt; &lt;code&gt;median&lt;/code&gt; &lt;/a&gt; . Это сэкономит память, когда вам не нужно сохранять содержимое входного массива. Считайте ввод неопределенным, но он, вероятно, будет полностью или частично отсортирован. По умолчанию - False. Если &lt;code&gt;overwrite_input&lt;/code&gt; имеет значение &lt;code&gt;True&lt;/code&gt; , а &lt;code&gt;a&lt;/code&gt; еще не является &lt;a href=&quot;numpy.ndarray#numpy.ndarray&quot;&gt; &lt;code&gt;ndarray&lt;/code&gt; &lt;/a&gt; , возникнет ошибка.</target>
        </trans-unit>
        <trans-unit id="bf48ed6030d0efc488f7b3086097c6ad325b803d" translate="yes" xml:space="preserve">
          <source>If True, then allow use of memory of input array &lt;code&gt;a&lt;/code&gt; for calculations. The input array will be modified by the call to &lt;a href=&quot;numpy.median#numpy.median&quot;&gt;&lt;code&gt;median&lt;/code&gt;&lt;/a&gt;. This will save memory when you do not need to preserve the contents of the input array. Treat the input as undefined, but it will probably be fully or partially sorted. Default is False. If &lt;code&gt;overwrite_input&lt;/code&gt; is &lt;code&gt;True&lt;/code&gt; and &lt;code&gt;a&lt;/code&gt; is not already an &lt;a href=&quot;numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;ndarray&lt;/code&gt;&lt;/a&gt;, an error will be raised.</source>
          <target state="translated">Если True, то разрешить использование памяти входного массива &lt;code&gt;a&lt;/code&gt; для вычислений. Входной массив будет изменен вызовом &lt;a href=&quot;numpy.median#numpy.median&quot;&gt; &lt;code&gt;median&lt;/code&gt; &lt;/a&gt; . Это сэкономит память, когда вам не нужно сохранять содержимое входного массива. Считайте ввод неопределенным, но он, вероятно, будет полностью или частично отсортирован. По умолчанию - False. Если &lt;code&gt;overwrite_input&lt;/code&gt; имеет значение &lt;code&gt;True&lt;/code&gt; , а &lt;code&gt;a&lt;/code&gt; еще не является &lt;a href=&quot;numpy.ndarray#numpy.ndarray&quot;&gt; &lt;code&gt;ndarray&lt;/code&gt; &lt;/a&gt; , возникнет ошибка.</target>
        </trans-unit>
        <trans-unit id="727bb21e15aa63ae35b6dc8fc80a632c45207cf3" translate="yes" xml:space="preserve">
          <source>If True, then sub-classes will be passed-through (default), otherwise the returned array will be forced to be a base-class array.</source>
          <target state="translated">Если переменная имеет значение True,то подклассы будут проходить через (по умолчанию),в противном случае возвращаемый массив будет вынужден быть массивом базового класса.</target>
        </trans-unit>
        <trans-unit id="4ceb06545ceed82d0fd2c4e74fddc1a8387d729b" translate="yes" xml:space="preserve">
          <source>If True, then sub-classes will be passed-through, otherwise the returned array will be forced to be a base-class array (default).</source>
          <target state="translated">Если значение True,то будут проходить подклассы,в противном случае возвращаемый массив будет вынужден быть массивом базового класса (по умолчанию).</target>
        </trans-unit>
        <trans-unit id="9752fe228ae3462d649576fdb0cd4757647ae348" translate="yes" xml:space="preserve">
          <source>If True, then sub-classes will be passed-through, otherwise the returned arrays will be forced to be a base-class array (default).</source>
          <target state="translated">Если параметр True,то будут проходить подклассы,в противном случае возвращаемые массивы будут вынуждены быть массивами базового класса (по умолчанию).</target>
        </trans-unit>
        <trans-unit id="066838f1ffe5aa12c7d71f9b1de32afdb88ee10e" translate="yes" xml:space="preserve">
          <source>If True, then the newly created array will use the sub-class type of &amp;lsquo;a&amp;rsquo;, otherwise it will be a base-class array. Defaults to True.</source>
          <target state="translated">Если True, то вновь созданный массив будет использовать тип подкласса 'a', в противном случае это будет массив базового класса. По умолчанию True.</target>
        </trans-unit>
        <trans-unit id="9ba9655ceab858d8e0fbfbe35222ace33db08fb2" translate="yes" xml:space="preserve">
          <source>If [array, array], the bin edges in each dimension (x_edges, y_edges = bins).</source>
          <target state="translated">Если [массив,массив],то рёбра бина в каждом измерении (x_края,y_края=бины).</target>
        </trans-unit>
        <trans-unit id="74d7f2b29106e8ca088ed3ddc192d60c869742ea" translate="yes" xml:space="preserve">
          <source>If [int, int], the number of bins in each dimension (nx, ny = bins).</source>
          <target state="translated">Если [int,int],то количество бинов в каждом измерении (nx,ny=бины).</target>
        </trans-unit>
        <trans-unit id="63952cde8568ab7ec41b2ac80ecf7fdc353a6855" translate="yes" xml:space="preserve">
          <source>If __svn_version__.py existed before, nothing is done.</source>
          <target state="translated">Если __svn_version_.py существовала раньше,то ничего не делается.</target>
        </trans-unit>
        <trans-unit id="2973727add43998ece2695a952786574b37deff8" translate="yes" xml:space="preserve">
          <source>If a &amp;lt; 1.</source>
          <target state="translated">Если &amp;lt;1.</target>
        </trans-unit>
        <trans-unit id="c5279f6f16ca5cb6814a2ac00854340dc9cd2fbb" translate="yes" xml:space="preserve">
          <source>If a class (ndarray subclass or not) having the &lt;a href=&quot;#numpy.class.__array__&quot;&gt;&lt;code&gt;__array__&lt;/code&gt;&lt;/a&gt; method is used as the output object of an &lt;a href=&quot;ufuncs#ufuncs-output-type&quot;&gt;ufunc&lt;/a&gt;, results will be written to the object returned by &lt;a href=&quot;#numpy.class.__array__&quot;&gt;&lt;code&gt;__array__&lt;/code&gt;&lt;/a&gt;. Similar conversion is done on input arrays.</source>
          <target state="translated">Если класс (подкласс ndarray или нет), имеющий метод &lt;a href=&quot;#numpy.class.__array__&quot;&gt; &lt;code&gt;__array__&lt;/code&gt; ,&lt;/a&gt; используется как выходной объект &lt;a href=&quot;ufuncs#ufuncs-output-type&quot;&gt;ufunc&lt;/a&gt; , результаты будут записаны в объект, возвращаемый &lt;a href=&quot;#numpy.class.__array__&quot;&gt; &lt;code&gt;__array__&lt;/code&gt; &lt;/a&gt; . Аналогичное преобразование выполняется для входных массивов.</target>
        </trans-unit>
        <trans-unit id="874568bcf37ebe0e2a8a8d54069b92c02f85f23a" translate="yes" xml:space="preserve">
          <source>If a class defines the &lt;a href=&quot;#numpy.class.__array_ufunc__&quot;&gt;&lt;code&gt;__array_ufunc__&lt;/code&gt;&lt;/a&gt; method, this disables the &lt;a href=&quot;#numpy.class.__array_wrap__&quot;&gt;&lt;code&gt;__array_wrap__&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#numpy.class.__array_prepare__&quot;&gt;&lt;code&gt;__array_prepare__&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#numpy.class.__array_priority__&quot;&gt;&lt;code&gt;__array_priority__&lt;/code&gt;&lt;/a&gt; mechanism described below for ufuncs (which may eventually be deprecated).</source>
          <target state="translated">Если класс определяет метод &lt;a href=&quot;#numpy.class.__array_ufunc__&quot;&gt; &lt;code&gt;__array_ufunc__&lt;/code&gt; &lt;/a&gt; , это отключает &lt;a href=&quot;#numpy.class.__array_wrap__&quot;&gt; &lt;code&gt;__array_wrap__&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#numpy.class.__array_prepare__&quot;&gt; &lt;code&gt;__array_prepare__&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#numpy.class.__array_priority__&quot;&gt; &lt;code&gt;__array_priority__&lt;/code&gt; &lt;/a&gt; , описанный ниже для ufuncs (который в конечном итоге может быть устаревшим).</target>
        </trans-unit>
        <trans-unit id="0577aaede06ac434e631d772788e0f369a956f02" translate="yes" xml:space="preserve">
          <source>If a compile-time fixed buffer is being used (both flags &lt;a href=&quot;#c.NPY_ITER_BUFFERED&quot;&gt;&lt;code&gt;NPY_ITER_BUFFERED&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#c.NPY_ITER_EXTERNAL_LOOP&quot;&gt;&lt;code&gt;NPY_ITER_EXTERNAL_LOOP&lt;/code&gt;&lt;/a&gt;), the inner size may be used as a signal as well. The size is guaranteed to become zero when &lt;code&gt;iternext()&lt;/code&gt; returns false, enabling the following loop construct. Note that if you use this construct, you should not pass &lt;a href=&quot;#c.NPY_ITER_GROWINNER&quot;&gt;&lt;code&gt;NPY_ITER_GROWINNER&lt;/code&gt;&lt;/a&gt; as a flag, because it will cause larger sizes under some circumstances.</source>
          <target state="translated">Если используется фиксированный буфер времени компиляции (оба флага &lt;a href=&quot;#c.NPY_ITER_BUFFERED&quot;&gt; &lt;code&gt;NPY_ITER_BUFFERED&lt;/code&gt; &lt;/a&gt; и &lt;a href=&quot;#c.NPY_ITER_EXTERNAL_LOOP&quot;&gt; &lt;code&gt;NPY_ITER_EXTERNAL_LOOP&lt;/code&gt; &lt;/a&gt; ), внутренний размер также может использоваться как сигнал. Размер гарантированно станет нулевым, когда &lt;code&gt;iternext()&lt;/code&gt; вернет false, что позволяет использовать следующую конструкцию цикла. Обратите внимание: если вы используете эту конструкцию, вы не должны передавать &lt;a href=&quot;#c.NPY_ITER_GROWINNER&quot;&gt; &lt;code&gt;NPY_ITER_GROWINNER&lt;/code&gt; &lt;/a&gt; в качестве флага, потому что при некоторых обстоятельствах это приведет к увеличению размеров.</target>
        </trans-unit>
        <trans-unit id="4a3ce99d9611a27292277b44f279f72466bca938" translate="yes" xml:space="preserve">
          <source>If a field whose dtype object has this attribute is retrieved, then the extra dimensions implied by &lt;em&gt;shape&lt;/em&gt; are tacked on to the end of the retrieved array.</source>
          <target state="translated">Если поле, DTYPE объект имеет этот атрибут извлекается, то дополнительные размеры подразумеваемых &lt;em&gt;форм&lt;/em&gt; являются пристегивается к концу возвращенного массива.</target>
        </trans-unit>
        <trans-unit id="24439780a6864c35956999c18798d43f08d60388" translate="yes" xml:space="preserve">
          <source>If a formatter is specified for a certain type, the &lt;code&gt;precision&lt;/code&gt; keyword is ignored for that type.</source>
          <target state="translated">Если для определенного типа указано средство форматирования, ключевое слово &lt;code&gt;precision&lt;/code&gt; игнорируется для этого типа.</target>
        </trans-unit>
        <trans-unit id="687f359e5176c0f016578fb6a4154929ee305cd5" translate="yes" xml:space="preserve">
          <source>If a given array does not satisfy the specified restrictions.</source>
          <target state="translated">Если заданный массив не удовлетворяет указанным ограничениям.</target>
        </trans-unit>
        <trans-unit id="0f9748bf845ac9d150692dd01c4e3cac7093889e" translate="yes" xml:space="preserve">
          <source>If a is a matrix object, then the return value is a matrix as well:</source>
          <target state="translated">Если a-это объект матрицы,то возвращаемое значение также является матрицей:</target>
        </trans-unit>
        <trans-unit id="8ca1d1baf4aebfbd38dd688686cce7228cb6bc88" translate="yes" xml:space="preserve">
          <source>If a is an int and less than zero, if a or p are not 1-dimensional, if a is an array-like of size 0, if p is not a vector of probabilities, if a and p have different lengths, or if replace=False and the sample size is greater than the population size</source>
          <target state="translated">Если a является int и меньше нуля,если a или p не являются одномерными,если a является массивом размера 0,если p не является вектором вероятностей,если a и p имеют разную длину,или если replace=False и размер выборки больше,чем размер популяции</target>
        </trans-unit>
        <trans-unit id="45d749c722fde2f54ef7349c75a2d911b0caf469" translate="yes" xml:space="preserve">
          <source>If a is an int and less than zero, if p is not 1-dimensional, if a is array-like with a size 0, if p is not a vector of probabilities, if a and p have different lengths, or if replace=False and the sample size is greater than the population size.</source>
          <target state="translated">Если a является int и меньше нуля,если p не является 1-мерным,если a является массивом с размером 0,если p не является вектором вероятностей,если a и p имеют разную длину,или если replace=False и размер выборки больше,чем размер популяции.</target>
        </trans-unit>
        <trans-unit id="6a821a28e324f16f0f4bf4708058f9a3d079d082" translate="yes" xml:space="preserve">
          <source>If a list of strings, each string should represent a dtype. If array_like, the character representation of the array dtype is used.</source>
          <target state="translated">Если список строк,то каждая строка должна представлять собой dtype.Если array_like,то используется символьное представление типа массива d.</target>
        </trans-unit>
        <trans-unit id="63795a6ab48fcba94623b51f8a7753fc963d4b8e" translate="yes" xml:space="preserve">
          <source>If a scalar dtype, the corresponding string character is returned. If an object, &lt;a href=&quot;#numpy.sctype2char&quot;&gt;&lt;code&gt;sctype2char&lt;/code&gt;&lt;/a&gt; tries to infer its scalar type and then return the corresponding string character.</source>
          <target state="translated">Если скалярный dtype, возвращается соответствующий строковый символ. Если объект, &lt;a href=&quot;#numpy.sctype2char&quot;&gt; &lt;code&gt;sctype2char&lt;/code&gt; &lt;/a&gt; пытается вывести его скалярный тип, а затем вернуть соответствующий строковый символ.</target>
        </trans-unit>
        <trans-unit id="98a2233adc7ab93848107f159b490659bfa27e57" translate="yes" xml:space="preserve">
          <source>If a scalar value is passed in.</source>
          <target state="translated">Если передается скалярное значение.</target>
        </trans-unit>
        <trans-unit id="15bc103dab402117d3913395fb8b40bbeeb0b897" translate="yes" xml:space="preserve">
          <source>If a second argument is supplied the result is stored there. If the type of that array is a numeric type the result is represented as zeros and ones, if the type is boolean then as False and True. The return value &lt;code&gt;out&lt;/code&gt; is then a reference to that array.</source>
          <target state="translated">Если указан второй аргумент, результат сохраняется там. Если тип этого массива - числовой тип, результат представлен как нули и единицы, если тип логический, то как False и True. Возвращаемое значение &lt;code&gt;out&lt;/code&gt; затем ссылка на этот массив.</target>
        </trans-unit>
        <trans-unit id="ceb1ddfcab0f3cbec5d42431c301b1cc28fccf65" translate="yes" xml:space="preserve">
          <source>If a zero dimensional array is present in the index &lt;em&gt;and&lt;/em&gt; it is a full integer index the result will be a &lt;em&gt;scalar&lt;/em&gt; and not a zero dimensional array. (Advanced indexing is not triggered.)</source>
          <target state="translated">Если в индексе присутствует нулевой массив, &lt;em&gt;и&lt;/em&gt; это полный целочисленный индекс, результатом будет &lt;em&gt;скаляр,&lt;/em&gt; а не нулевой массив. (Расширенное индексирование не запускается.)</target>
        </trans-unit>
        <trans-unit id="64c5c963ea9794eafa3b89f1dd216c6a8ebfd684" translate="yes" xml:space="preserve">
          <source>If actual and desired are not equal up to specified precision.</source>
          <target state="translated">Если фактические и желаемые не совпадают с заданной точностью.</target>
        </trans-unit>
        <trans-unit id="39bbb6143ab84f37b65c3d7880c2778b652d186d" translate="yes" xml:space="preserve">
          <source>If actual and desired are not equal.</source>
          <target state="translated">Если фактические и желаемые не равны.</target>
        </trans-unit>
        <trans-unit id="fcebdf6acdb7662938a429c761fa5ad9e5471b67" translate="yes" xml:space="preserve">
          <source>If actual and desired objects are not equal.</source>
          <target state="translated">Если фактические и желаемые объекты не совпадают.</target>
        </trans-unit>
        <trans-unit id="8aa394119b239dde7365c85e156833625438bfa9" translate="yes" xml:space="preserve">
          <source>If all &lt;code&gt;__array_function__&lt;/code&gt; methods return &lt;code&gt;NotImplemented&lt;/code&gt;, NumPy will raise &lt;code&gt;TypeError&lt;/code&gt;.</source>
          <target state="translated">Если все методы &lt;code&gt;__array_function__&lt;/code&gt; возвращают &lt;code&gt;NotImplemented&lt;/code&gt; , NumPy вызовет &lt;code&gt;TypeError&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="eab8ea3dfbb5bbbb71e7908ef2deef22ffee42c7" translate="yes" xml:space="preserve">
          <source>If all the arrays are 1-D, &lt;a href=&quot;#numpy.where&quot;&gt;&lt;code&gt;where&lt;/code&gt;&lt;/a&gt; is equivalent to:</source>
          <target state="translated">Если все массивы 1-D, &lt;a href=&quot;#numpy.where&quot;&gt; &lt;code&gt;where&lt;/code&gt; &lt;/a&gt; эквивалентно:</target>
        </trans-unit>
        <trans-unit id="4680fc5e031229cdb3ef2e322dccd91736ba09de" translate="yes" xml:space="preserve">
          <source>If all values are masked, return None. Otherwise, return a list of two tuples, corresponding to the indices of the first and last unmasked values respectively.</source>
          <target state="translated">Если все значения замаскированы,верните Нет.В противном случае верните список из двух кортежей,соответствующих индексам первого и последнего размаскированных значений соответственно.</target>
        </trans-unit>
        <trans-unit id="6a0b2100814d2bab89059c0f2bc3adff904ee9a6" translate="yes" xml:space="preserve">
          <source>If an array has a very small or very large determinant, then a call to &lt;a href=&quot;numpy.linalg.det#numpy.linalg.det&quot;&gt;&lt;code&gt;det&lt;/code&gt;&lt;/a&gt; may overflow or underflow. This routine is more robust against such issues, because it computes the logarithm of the determinant rather than the determinant itself.</source>
          <target state="translated">Если массив имеет очень маленький или очень большой определитель, то вызов &lt;a href=&quot;numpy.linalg.det#numpy.linalg.det&quot;&gt; &lt;code&gt;det&lt;/code&gt; &lt;/a&gt; может переполниться или опуститься. Эта процедура более устойчива к таким проблемам, поскольку вычисляет логарифм определителя, а не сам определитель.</target>
        </trans-unit>
        <trans-unit id="089dc283ee6bf525b9e1357cb2890636154add48" translate="yes" xml:space="preserve">
          <source>If an array has no elements (&lt;code&gt;self.size == 0&lt;/code&gt;) there is no legal index and the strides are never used. Any array with no elements may be considered C-style and Fortran-style contiguous.</source>
          <target state="translated">Если в массиве нет элементов ( &lt;code&gt;self.size == 0&lt;/code&gt; ), нет легального индекса и шаги никогда не используются. Любой массив без элементов может считаться смежным в стиле C и Fortran.</target>
        </trans-unit>
        <trans-unit id="c5c598efb3988281532c1be87569879df34d1935" translate="yes" xml:space="preserve">
          <source>If an array is created using a data-type describing a sub-array, the dimensions of the sub-array are appended to the shape of the array when the array is created. Sub-arrays in a field of a structured type behave differently, see &lt;a href=&quot;arrays.indexing#arrays-indexing-fields&quot;&gt;Field Access&lt;/a&gt;.</source>
          <target state="translated">Если массив создается с использованием типа данных, описывающего суб-массив, размеры суб-массива добавляются к форме массива при создании массива. Подмассивы в поле структурированного типа ведут себя по-разному, см. &lt;a href=&quot;arrays.indexing#arrays-indexing-fields&quot;&gt;Доступ к полю&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="bf36df6b09764d99c53b04e05c8fe53411949d03" translate="yes" xml:space="preserve">
          <source>If an array is created with this method, simply adding &amp;lsquo;itemsize&amp;rsquo; for each iteration will traverse the new array matching the iterator.</source>
          <target state="translated">Если массив создается с помощью этого метода, простое добавление &amp;laquo;itemsize&amp;raquo; для каждой итерации будет проходить по новому массиву, соответствующему итератору.</target>
        </trans-unit>
        <trans-unit id="5e8325ebccad64f5436323a863f272d5f091c76c" translate="yes" xml:space="preserve">
          <source>If an element of &lt;code&gt;axes&lt;/code&gt; is larger than than the number of axes of &lt;code&gt;a&lt;/code&gt;.</source>
          <target state="translated">Если элемент &lt;code&gt;axes&lt;/code&gt; больше, чем количество осей &lt;code&gt;a&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="bc51d7d23e7dc12f32f8e1785a950a943342d4c8" translate="yes" xml:space="preserve">
          <source>If an index exceeds the dimension of the array along &lt;code&gt;axis&lt;/code&gt;, an empty sub-array is returned correspondingly.</source>
          <target state="translated">Если индекс превышает размер массива по &lt;code&gt;axis&lt;/code&gt; , соответственно возвращается пустой подмассив.</target>
        </trans-unit>
        <trans-unit id="99fec5dbaf9a5723fb1db21784554641e2d086b8" translate="yes" xml:space="preserve">
          <source>If an input has a dimension size of 1 in its shape, the first data entry in that dimension will be used for all calculations along that dimension. In other words, the stepping machinery of the &lt;a href=&quot;https://docs.scipy.org/doc/numpy-1.17.0/glossary.html#term-ufunc&quot;&gt;ufunc&lt;/a&gt; will simply not step along that dimension (the &lt;a href=&quot;arrays.ndarray#memory-layout&quot;&gt;stride&lt;/a&gt; will be 0 for that dimension).</source>
          <target state="translated">Если входные данные имеют размерный размер 1 в своей форме, первая запись данных в этом измерении будет использоваться для всех вычислений по этому измерению. Другими словами, шаговый механизм &lt;a href=&quot;https://docs.scipy.org/doc/numpy-1.17.0/glossary.html#term-ufunc&quot;&gt;ufunc&lt;/a&gt; просто не будет шагать по этому измерению ( &lt;a href=&quot;arrays.ndarray#memory-layout&quot;&gt;шаг&lt;/a&gt; будет равен 0 для этого измерения).</target>
        </trans-unit>
        <trans-unit id="981216fcb80286728db3aa0467d4b1e8a655fef5" translate="yes" xml:space="preserve">
          <source>If an ndarray, a random sample is generated from its elements. If an int, the random sample is generated as if a were np.arange(a)</source>
          <target state="translated">Если андаррей,случайная выборка генерируется из его элементов.Если int,случайная выборка генерируется как np.arange(a).</target>
        </trans-unit>
        <trans-unit id="b055403a11a75cdadf358d2e4b16e4aaac100a0a" translate="yes" xml:space="preserve">
          <source>If an object is provided, its write method should take one argument, a string.</source>
          <target state="translated">Если предоставляется объект,то его метод записи должен принимать один аргумент,строку.</target>
        </trans-unit>
        <trans-unit id="c6eb2fb826e8cbc6182574444dd579783c5b9225" translate="yes" xml:space="preserve">
          <source>If any input is array_like, &lt;code&gt;pv&lt;/code&gt; returns an array of equal shape. Let&amp;rsquo;s compare different interest rates in the example above:</source>
          <target state="translated">Если какой-либо ввод - array_like, &lt;code&gt;pv&lt;/code&gt; возвращает массив одинаковой формы. Давайте сравним разные процентные ставки в приведенном выше примере:</target>
        </trans-unit>
        <trans-unit id="ffa8ae9c8e4ca204b853aaf38ee0943c2276d1c9" translate="yes" xml:space="preserve">
          <source>If any input is array_like, returns an array of equal shape. Let&amp;rsquo;s compare different interest rates from the example above.</source>
          <target state="translated">Если какой-либо ввод - array_like, возвращает массив одинаковой формы. Давайте сравним разные процентные ставки из приведенного выше примера.</target>
        </trans-unit>
        <trans-unit id="dce7db3f12e1e92b36fcbe9af677f929557b423e" translate="yes" xml:space="preserve">
          <source>If any read/write overlap exists, this flag ensures the result of the operation is the same as if all operands were copied. In cases where copies would need to be made, &lt;strong&gt;the result of the computation may be undefined without this flag!&lt;/strong&gt;</source>
          <target state="translated">Если существует какое-либо перекрытие чтения / записи, этот флаг гарантирует, что результат операции будет таким же, как если бы все операнды были скопированы. В случаях, когда необходимо сделать копии, &lt;strong&gt;результат вычисления может быть неопределенным без этого флага!&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="5a8f0d595ba6a3701f0ba4d0bf45fa3cd44ca9ce" translate="yes" xml:space="preserve">
          <source>If any value in alpha is less than or equal to zero</source>
          <target state="translated">Если любое значение в альфа-альфе меньше или равно нулю.</target>
        </trans-unit>
        <trans-unit id="bc219d3a8300527c6efa92537ff8d0dcdb1108df" translate="yes" xml:space="preserve">
          <source>If any write operand has overlap with any read operand, eliminate all overlap by making temporary copies (enabling UPDATEIFCOPY for write operands, if necessary). A pair of operands has overlap if there is a memory address that contains data common to both arrays.</source>
          <target state="translated">Если любой операнд записи имеет перекрытие с любым операндом чтения,устраните все перекрытия,сделав временные копии (включите UPDATEIFCOPY для операндов записи,если необходимо).Пара операндов имеет наложение,если есть адрес памяти,который содержит данные,общие для обоих массивов.</target>
        </trans-unit>
        <trans-unit id="2a45557faccf378e4b524258e3744f14e01d0549" translate="yes" xml:space="preserve">
          <source>If argument consists exclusively of int dtypes.</source>
          <target state="translated">Если аргумент состоит исключительно из int dtypes.</target>
        </trans-unit>
        <trans-unit id="c785d849c18fc327cf9bee37bc11741d006f8fa7" translate="yes" xml:space="preserve">
          <source>If arguments are passed in with no keywords, the corresponding variable names, in the &lt;code&gt;.npz&lt;/code&gt; file, are &amp;lsquo;arr_0&amp;rsquo;, &amp;lsquo;arr_1&amp;rsquo;, etc. If keyword arguments are given, the corresponding variable names, in the &lt;code&gt;.npz&lt;/code&gt; file will match the keyword names.</source>
          <target state="translated">Если аргументы передаются без ключевых слов, соответствующие имена переменных в файле &lt;code&gt;.npz&lt;/code&gt; будут 'arr_0', 'arr_1' и т. Д. Если указаны аргументы ключевых слов, соответствующие имена переменных в файле &lt;code&gt;.npz&lt;/code&gt; будут соответствовать имена ключевых слов.</target>
        </trans-unit>
        <trans-unit id="3d1c7a0f1e977aad5bcdfcdc2989a2f748b0274f" translate="yes" xml:space="preserve">
          <source>If array_like, the bin edges for the two dimensions (x_edges=y_edges=bins).</source>
          <target state="translated">Если array_like,то рёбра бина для двух измерений (x_edges=y_edges=bins).</target>
        </trans-unit>
        <trans-unit id="8a90d0b3d22bdc0f93b285a7398aa4703fe73214" translate="yes" xml:space="preserve">
          <source>If axis is 0, only rows are suppressed.</source>
          <target state="translated">Если ось равна 0,то подавляются только ряды.</target>
        </trans-unit>
        <trans-unit id="0782bc28993b5f00e72a0af1dcec69356d31839c" translate="yes" xml:space="preserve">
          <source>If axis is 1 or -1, only columns are suppressed.</source>
          <target state="translated">Если ось 1 или -1,то подавляются только столбцы.</target>
        </trans-unit>
        <trans-unit id="9506a7c18a807c059cd952ed93d5c51207a2a07d" translate="yes" xml:space="preserve">
          <source>If axis is None, both rows and columns are suppressed.</source>
          <target state="translated">Если ось Нет,то обе строки и столбцы подавляются.</target>
        </trans-unit>
        <trans-unit id="c5149a1f08013bd4c50d9514785f4f44208d1f0b" translate="yes" xml:space="preserve">
          <source>If axis is a tuple of ints, a product is performed on all of the axes specified in the tuple instead of a single axis or all the axes as before.</source>
          <target state="translated">Если ось является кортежом из интв,то вместо одной оси или всех осей,как и прежде,выполняется произведение по всем осям,указанным в кортеже.</target>
        </trans-unit>
        <trans-unit id="8de953aea1cde5c7cd7a932c7c1cd638dd5b48f8" translate="yes" xml:space="preserve">
          <source>If axis is a tuple of ints, a sum is performed on all of the axes specified in the tuple instead of a single axis or all the axes as before.</source>
          <target state="translated">Если ось является кортежом из буквенных индексов,то вместо одной оси или всех осей,как и прежде,выполняется сумма по всем осям,указанным в кортеже.</target>
        </trans-unit>
        <trans-unit id="b7d9ad0b67d074ec073be5ef4e15eeecb68acdae" translate="yes" xml:space="preserve">
          <source>If axis is a tuple of ints, averaging is performed on all of the axes specified in the tuple instead of a single axis or all the axes as before.</source>
          <target state="translated">Если ось-кортеж из интов,то усреднение выполняется по всем осям,указанным в кортеже,а не по одной оси или по всем осям,как раньше.</target>
        </trans-unit>
        <trans-unit id="288d1e6c0a612db41ca8d2410d35c52a79ba7795" translate="yes" xml:space="preserve">
          <source>If axis is a tuple of ints, flipping is performed on all of the axes specified in the tuple.</source>
          <target state="translated">Если ось является кортежом из буквенных дюймов,то перевертывание выполняется по всем указанным в кортеже осям.</target>
        </trans-unit>
        <trans-unit id="4a67a427d1a7cbcfc229fb55b05bdd5b239d1bd3" translate="yes" xml:space="preserve">
          <source>If both &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; are 1-D arrays, it is inner product of vectors (without complex conjugation).</source>
          <target state="translated">Если и &lt;code&gt;a&lt;/code&gt; , и &lt;code&gt;b&lt;/code&gt; являются одномерными массивами, это внутреннее произведение векторов (без комплексного сопряжения).</target>
        </trans-unit>
        <trans-unit id="c28be53ff292bd7a51506b92f27ed7a94fd2ec15" translate="yes" xml:space="preserve">
          <source>If both &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; are 2-D arrays, it is matrix multiplication, but using &lt;a href=&quot;numpy.matmul#numpy.matmul&quot;&gt;&lt;code&gt;matmul&lt;/code&gt;&lt;/a&gt; or &lt;code&gt;a @ b&lt;/code&gt; is preferred.</source>
          <target state="translated">Если и &lt;code&gt;a&lt;/code&gt; , и &lt;code&gt;b&lt;/code&gt; являются двумерными массивами, это умножение матриц, но использование &lt;a href=&quot;numpy.matmul#numpy.matmul&quot;&gt; &lt;code&gt;matmul&lt;/code&gt; &lt;/a&gt; или &lt;code&gt;a @ b&lt;/code&gt; предпочтительнее.</target>
        </trans-unit>
        <trans-unit id="368fd1e825cc7f1439018ab086e3ca74379697e1" translate="yes" xml:space="preserve">
          <source>If both &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; are &lt;code&gt;NULL&lt;/code&gt;, then return &lt;a href=&quot;#c.PyArray_Nonzero&quot;&gt;&lt;code&gt;PyArray_Nonzero&lt;/code&gt;&lt;/a&gt; (&lt;em&gt;condition&lt;/em&gt;). Otherwise, both &lt;em&gt;x&lt;/em&gt; and &lt;em&gt;y&lt;/em&gt; must be given and the object returned is shaped like &lt;em&gt;condition&lt;/em&gt; and has elements of &lt;em&gt;x&lt;/em&gt; and &lt;em&gt;y&lt;/em&gt; where &lt;em&gt;condition&lt;/em&gt; is respectively True or False.</source>
          <target state="translated">Если и &lt;code&gt;x&lt;/code&gt; , и &lt;code&gt;y&lt;/code&gt; равны &lt;code&gt;NULL&lt;/code&gt; , вернуть &lt;a href=&quot;#c.PyArray_Nonzero&quot;&gt; &lt;code&gt;PyArray_Nonzero&lt;/code&gt; &lt;/a&gt; ( &lt;em&gt;условие&lt;/em&gt; ). В противном случае должны быть указаны как &lt;em&gt;x, так&lt;/em&gt; и &lt;em&gt;y&lt;/em&gt; , а возвращаемый объект имеет форму &lt;em&gt;condition&lt;/em&gt; и имеет элементы &lt;em&gt;x&lt;/em&gt; и &lt;em&gt;y,&lt;/em&gt; где &lt;em&gt;condition&lt;/em&gt; соответственно True или False.</target>
        </trans-unit>
        <trans-unit id="7d34c61041bcc07e55093729fc859031c36d6999" translate="yes" xml:space="preserve">
          <source>If both arguments are 2-D they are multiplied like conventional matrices.</source>
          <target state="translated">Если оба аргумента 2-D,то они умножаются как обычные матрицы.</target>
        </trans-unit>
        <trans-unit id="bf26496158ed7aff00fe3f64e66aa6a508289463" translate="yes" xml:space="preserve">
          <source>If both positive and negative infinity are present, the sum will be Not A Number (NaN).</source>
          <target state="translated">Если присутствует и положительная,и отрицательная бесконечность,то сумма будет не A Number (NaN).</target>
        </trans-unit>
        <trans-unit id="4d89fb74ad22e53fe87d261e5d40a2d4a0331e92" translate="yes" xml:space="preserve">
          <source>If called with all arguments other than the warning class omitted, may be used as a context manager:</source>
          <target state="translated">При вызове со всеми аргументами,кроме пропущенных классов предупреждений,может быть использован в качестве контекстного менеджера:</target>
        </trans-unit>
        <trans-unit id="e1f9fb2b578de1420ef1d4182da3c75ca58e3552" translate="yes" xml:space="preserve">
          <source>If complex input returns a real array if complex parts are close to zero.</source>
          <target state="translated">Если сложный вход возвращает реальный массив,если сложные части близки к нулю.</target>
        </trans-unit>
        <trans-unit id="4ec7acf826794e4e37207136e102eb50e7632b5f" translate="yes" xml:space="preserve">
          <source>If computation does not converge.</source>
          <target state="translated">Если вычисления не сходятся.</target>
        </trans-unit>
        <trans-unit id="66501fc9abcadb23835ebb60ef928268453bb410" translate="yes" xml:space="preserve">
          <source>If condition is a &lt;a href=&quot;../maskedarray.baseclass#numpy.ma.MaskedArray&quot;&gt;&lt;code&gt;MaskedArray&lt;/code&gt;&lt;/a&gt;, missing values are considered as &lt;code&gt;False&lt;/code&gt;.</source>
          <target state="translated">Если условием является &lt;a href=&quot;../maskedarray.baseclass#numpy.ma.MaskedArray&quot;&gt; &lt;code&gt;MaskedArray&lt;/code&gt; &lt;/a&gt; , отсутствующие значения считаются &lt;code&gt;False&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9bd71f3d3293e73ba78bbdd8102f9b41323ceaaa" translate="yes" xml:space="preserve">
          <source>If copy is False and one of the inputs is &lt;a href=&quot;../maskedarray.baseclass#numpy.ma.nomask&quot;&gt;&lt;code&gt;nomask&lt;/code&gt;&lt;/a&gt;, return a view of the other input mask. Defaults to False.</source>
          <target state="translated">Если copy имеет значение False и один из входов - &lt;a href=&quot;../maskedarray.baseclass#numpy.ma.nomask&quot;&gt; &lt;code&gt;nomask&lt;/code&gt; &lt;/a&gt; , вернуть представление другой маски ввода. По умолчанию False.</target>
        </trans-unit>
        <trans-unit id="6d1cb15d43c2ba3971e5b54fc0a9bc261de3fb39" translate="yes" xml:space="preserve">
          <source>If data is passed to &lt;a href=&quot;#c.PyArray_NewFromDescr&quot;&gt;&lt;code&gt;PyArray_NewFromDescr&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#c.PyArray_New&quot;&gt;&lt;code&gt;PyArray_New&lt;/code&gt;&lt;/a&gt;, this memory must not be deallocated until the new array is deleted. If this data came from another Python object, this can be accomplished using &lt;a href=&quot;https://docs.python.org/dev/c-api/refcounting.html#c.Py_INCREF&quot;&gt;&lt;code&gt;Py_INCREF&lt;/code&gt;&lt;/a&gt; on that object and setting the base member of the new array to point to that object. If strides are passed in they must be consistent with the dimensions, the itemsize, and the data of the array.</source>
          <target state="translated">Если данные передаются в &lt;a href=&quot;#c.PyArray_NewFromDescr&quot;&gt; &lt;code&gt;PyArray_NewFromDescr&lt;/code&gt; &lt;/a&gt; или &lt;a href=&quot;#c.PyArray_New&quot;&gt; &lt;code&gt;PyArray_New&lt;/code&gt; &lt;/a&gt; , эту память нельзя освобождать, пока не будет удален новый массив. Если эти данные поступили из другого объекта Python, это можно сделать с помощью &lt;a href=&quot;https://docs.python.org/dev/c-api/refcounting.html#c.Py_INCREF&quot;&gt; &lt;code&gt;Py_INCREF&lt;/code&gt; &lt;/a&gt; для этого объекта и установки базового члена нового массива, указывающего на этот объект. Если передаются шаги, они должны соответствовать размерам, размеру элементов и данным массива.</target>
        </trans-unit>
        <trans-unit id="8cd71bec9bf23486f57ed709deb2da7e823cdd37" translate="yes" xml:space="preserve">
          <source>If defined, the axis of &lt;code&gt;a&lt;/code&gt;, &lt;code&gt;b&lt;/code&gt; and &lt;code&gt;c&lt;/code&gt; that defines the vector(s) and cross product(s). Overrides &lt;code&gt;axisa&lt;/code&gt;, &lt;code&gt;axisb&lt;/code&gt; and &lt;code&gt;axisc&lt;/code&gt;.</source>
          <target state="translated">Если определено, оси &lt;code&gt;a&lt;/code&gt; , &lt;code&gt;b&lt;/code&gt; и &lt;code&gt;c&lt;/code&gt; , определяющие вектор (ы) и перекрестное произведение (я). Переопределяет &lt;code&gt;axisa&lt;/code&gt; , &lt;code&gt;axisb&lt;/code&gt; и &lt;code&gt;axisc&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1d0ca2bca36fd3ca611fb59e9f429be6ca1dfcef" translate="yes" xml:space="preserve">
          <source>If either &lt;code&gt;a&lt;/code&gt; or &lt;code&gt;b&lt;/code&gt; is 0-D (scalar), it is equivalent to &lt;a href=&quot;numpy.multiply#numpy.multiply&quot;&gt;&lt;code&gt;multiply&lt;/code&gt;&lt;/a&gt; and using &lt;code&gt;numpy.multiply(a, b)&lt;/code&gt; or &lt;code&gt;a * b&lt;/code&gt; is preferred.</source>
          <target state="translated">Если &lt;code&gt;a&lt;/code&gt; или &lt;code&gt;b&lt;/code&gt; равно 0-D (скаляр), это эквивалентно &lt;a href=&quot;numpy.multiply#numpy.multiply&quot;&gt; &lt;code&gt;multiply&lt;/code&gt; &lt;/a&gt; и использование &lt;code&gt;numpy.multiply(a, b)&lt;/code&gt; или &lt;code&gt;a * b&lt;/code&gt; является предпочтительным.</target>
        </trans-unit>
        <trans-unit id="849e7230439a12b395b3d9d948e074f889418b25" translate="yes" xml:space="preserve">
          <source>If either argument is N-D, N &amp;gt; 2, it is treated as a stack of matrices residing in the last two indexes and broadcast accordingly.</source>
          <target state="translated">Если любой из аргументов равен ND, N&amp;gt; 2, он обрабатывается как стек матриц, находящихся в последних двух индексах, и транслируется соответственно.</target>
        </trans-unit>
        <trans-unit id="cc8e18e241d0267fb4cce88d0332bc823b722b5a" translate="yes" xml:space="preserve">
          <source>If either array contains one or more NaNs, False is returned. Infs are treated as equal if they are in the same place and of the same sign in both arrays.</source>
          <target state="translated">Если любой из массивов содержит один или несколько NaN,возвращается False.Инфы считаются равными,если они находятся в одном и том же месте и имеют один и тот же знак в обоих массивах.</target>
        </trans-unit>
        <trans-unit id="281de8e5c6dae1e0aea9ae6d89d002bae88a2963" translate="yes" xml:space="preserve">
          <source>If element has complex type with zero complex part, the return value for that element is True.</source>
          <target state="translated">Если элемент имеет сложный тип с нулевой комплексной частью,возвращаемое значение для этого элемента равно True.</target>
        </trans-unit>
        <trans-unit id="5d17dff94d5eaef97820ea5c6ea029508947d3b9" translate="yes" xml:space="preserve">
          <source>If factoring fails.</source>
          <target state="translated">Если факторинг провалится.</target>
        </trans-unit>
        <trans-unit id="d31081e35606566d9542bf752ae043c7bb856921" translate="yes" xml:space="preserve">
          <source>If file is a string or a path-like object then that file is opened, else it is assumed to be a file object. The file object must support random access (i.e. it must have tell and seek methods).</source>
          <target state="translated">Если файл является строковым или похожим на патч-объект,то этот файл открывается,в противном случае предполагается,что он является файловым объектом.Файловый объект должен поддерживать случайный доступ (т.е.он должен иметь методы tell и seek).</target>
        </trans-unit>
        <trans-unit id="c92c0b980c98427841fd06fc2e90c17e3f8c8cf4" translate="yes" xml:space="preserve">
          <source>If filters are added and the &lt;code&gt;module&lt;/code&gt; keyword is given, the warning registry of this module will additionally be cleared when applying it, entering the context, or exiting it. This could cause warnings to appear a second time after leaving the context if they were configured to be printed once (default) and were already printed before the context was entered.</source>
          <target state="translated">Если фильтры добавлены и задано ключевое слово &lt;code&gt;module&lt;/code&gt; , реестр предупреждений этого модуля будет дополнительно очищен при его применении, входе в контекст или выходе из него. Это могло вызвать появление предупреждений во второй раз после выхода из контекста, если они были настроены на печать один раз (по умолчанию) и уже были напечатаны до входа в контекст.</target>
        </trans-unit>
        <trans-unit id="aa86a09a4bd6f04a9393e4d4dd4d45d0b7a047d8" translate="yes" xml:space="preserve">
          <source>If formats is None, then this will auto-detect formats. Use list of tuples rather than list of lists for faster processing.</source>
          <target state="translated">Если формат None,то это приведет к автоопределению форматов.Для более быстрой обработки используйте список кортежей,а не список списков.</target>
        </trans-unit>
        <trans-unit id="9c65522b5d0c56fc6284329915c9ff282e0a064e" translate="yes" xml:space="preserve">
          <source>If given and not &lt;code&gt;False&lt;/code&gt;, return not just the estimate but also its covariance matrix. By default, the covariance are scaled by chi2/sqrt(N-dof), i.e., the weights are presumed to be unreliable except in a relative sense and everything is scaled such that the reduced chi2 is unity. This scaling is omitted if &lt;code&gt;cov='unscaled'&lt;/code&gt;, as is relevant for the case that the weights are 1/sigma**2, with sigma known to be a reliable estimate of the uncertainty.</source>
          <target state="translated">Если задано, а не &lt;code&gt;False&lt;/code&gt; , вернуть не только оценку, но и ее ковариационную матрицу. По умолчанию ковариация масштабируется по chi2 / sqrt (N-dof), т. Е. Веса считаются ненадежными, за исключением относительного значения, и все масштабируется таким образом, что уменьшенная chi2 равна единице. Это масштабирование опускается, если &lt;code&gt;cov='unscaled'&lt;/code&gt; , что актуально для случая, когда веса равны 1 / сигма ** 2, при этом сигма, как известно, является надежной оценкой неопределенности.</target>
        </trans-unit>
        <trans-unit id="4a01bcc692f66d3a6d58bd9dd10d9c51e6240bfa" translate="yes" xml:space="preserve">
          <source>If given, any string of the form &lt;code&gt;@key@&lt;/code&gt; will be replaced by &lt;code&gt;subst_dict[key]&lt;/code&gt; in the template file when installed. The install prefix is always available through the variable &lt;code&gt;@prefix@&lt;/code&gt;, since the install prefix is not easy to get reliably from setup.py.</source>
          <target state="translated">Если задано, любая строка вида &lt;code&gt;@key@&lt;/code&gt; будет заменена на &lt;code&gt;subst_dict[key]&lt;/code&gt; в файле шаблона при установке. Префикс установки всегда доступен через переменную &lt;code&gt;@prefix@&lt;/code&gt; , так как префикс установки нелегко надежно получить из setup.py.</target>
        </trans-unit>
        <trans-unit id="282b0a219b18c48a317e72503d2100cde36f84f8" translate="yes" xml:space="preserve">
          <source>If given, the array must be of the form &lt;code&gt;[beg, end]&lt;/code&gt;, where &lt;code&gt;beg&lt;/code&gt; and &lt;code&gt;end&lt;/code&gt; are the endpoints of the domain. If None is given then the class domain is used. The default is None.</source>
          <target state="translated">Если задан, массив должен иметь форму &lt;code&gt;[beg, end]&lt;/code&gt; , где &lt;code&gt;beg&lt;/code&gt; in и &lt;code&gt;end&lt;/code&gt; - конечные точки домена. Если задано None, то используется домен класса. По умолчанию - Нет.</target>
        </trans-unit>
        <trans-unit id="0dd507ea0f76e3b5e94e32d9b92c028c04854d11" translate="yes" xml:space="preserve">
          <source>If given, the resulting array must be if the form &lt;code&gt;[beg, end]&lt;/code&gt;, where &lt;code&gt;beg&lt;/code&gt; and &lt;code&gt;end&lt;/code&gt; are the endpoints of the window. If None is given then the class window is used. The default is None.</source>
          <target state="translated">Если задан, результирующий массив должен иметь форму &lt;code&gt;[beg, end]&lt;/code&gt; , где &lt;code&gt;beg&lt;/code&gt; in и &lt;code&gt;end&lt;/code&gt; - конечные точки окна. Если задано None, используется окно класса. По умолчанию - Нет.</target>
        </trans-unit>
        <trans-unit id="d16d5189bfa0fff58db67c1477d4b5ae0a2a03f6" translate="yes" xml:space="preserve">
          <source>If given, this is returned for objects whose types can not be determined. If not given, None is returned for those objects.</source>
          <target state="translated">Если дано,то это возвращается для объектов,типы которых не могут быть определены.Если не указано,то для этих объектов возвращается None.</target>
        </trans-unit>
        <trans-unit id="4c9471fb7a9f3abaf682e7276b2ee9a3f16f1ed9" translate="yes" xml:space="preserve">
          <source>If input array &lt;code&gt;a&lt;/code&gt; is not 2D.</source>
          <target state="translated">Если входной массив &lt;code&gt;a&lt;/code&gt; не 2D.</target>
        </trans-unit>
        <trans-unit id="f96f22e66784df0c0e7c7e7a77f909c0ac407de2" translate="yes" xml:space="preserve">
          <source>If input is the wrong shape (the input must be a 1-D or square 2-D array).</source>
          <target state="translated">Если вход неправильной формы (вход должен быть 1-D или квадратным 2-D массивом).</target>
        </trans-unit>
        <trans-unit id="570a12b7ce63be7a2ce71fba3d8c9da77deb9d9d" translate="yes" xml:space="preserve">
          <source>If int, the number of bins for the two dimensions (nx=ny=bins).</source>
          <target state="translated">Если int,то количество бинов для двух измерений (nx=ny=bins).</target>
        </trans-unit>
        <trans-unit id="3a1bd74933e0b346982972b3334dd2af53c8b3cb" translate="yes" xml:space="preserve">
          <source>If keyword arguments are given, then filenames are taken from the keywords. If arguments are passed in with no keywords, then stored file names are arr_0, arr_1, etc.</source>
          <target state="translated">Если заданы аргументы ключевых слов,то имена файлов берутся из ключевых слов.Если аргументы передаются без ключевых слов,то имена файлов хранятся в виде arr_0,arr_1 и т.д.</target>
        </trans-unit>
        <trans-unit id="68f5690b1b20b80392957d2cc602580121727a3e" translate="yes" xml:space="preserve">
          <source>If list depths are mismatched - for instance, &lt;code&gt;[[a, b], c]&lt;/code&gt; is illegal, and should be spelt &lt;code&gt;[[a, b], [c]]&lt;/code&gt;</source>
          <target state="translated">Если глубины списка не совпадают - например, &lt;code&gt;[[a, b], c]&lt;/code&gt; недопустимо и должно быть написано &lt;code&gt;[[a, b], [c]]&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="f609da24233a507af66f8b7969941dc9c31d8838" translate="yes" xml:space="preserve">
          <source>If lists are empty - for instance, &lt;code&gt;[[a, b], []]&lt;/code&gt;</source>
          <target state="translated">Если списки пустые - например, &lt;code&gt;[[a, b], []]&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="c0fa6317253cb5f3105874e72d36c2e7ed1eb2af" translate="yes" xml:space="preserve">
          <source>If multi-dimension input, returns a new ndarray of indices to the minimum values along the given axis. Otherwise, returns a scalar of index to the minimum values along the given axis.</source>
          <target state="translated">При многомерном вводе возвращает новый указатель индексов к минимальным значениям вдоль данной оси.В противном случае возвращает скаляр индексов к минимальным значениям вдоль данной оси.</target>
        </trans-unit>
        <trans-unit id="3be2da634ae4e1a50b6a61b6e2a72b4b4858161d" translate="yes" xml:space="preserve">
          <source>If necessary, will be flattened before the differences are taken.</source>
          <target state="translated">При необходимости,будет сглажена до того,как будут сняты разногласия.</target>
        </trans-unit>
        <trans-unit id="0a3c8652ca0e3dccf381651d80f187b5ac1a5a74" translate="yes" xml:space="preserve">
          <source>If neither is defined, the C-API is declared to be &lt;code&gt;static void**&lt;/code&gt;, so it is only visible within the compilation unit that #includes numpy/arrayobject.h.</source>
          <target state="translated">Если ни один из них не определен, C-API объявляется как &lt;code&gt;static void**&lt;/code&gt; , поэтому он виден только внутри модуля компиляции, который #includes numpy / arrayobject.h.</target>
        </trans-unit>
        <trans-unit id="853b03d065feffbc6ac6731a7bbb396016c51c2b" translate="yes" xml:space="preserve">
          <source>If no &lt;code&gt;__array_function__&lt;/code&gt; methods exists, NumPy will default to calling its own implementation, intended for use on NumPy arrays. This case arises, for example, when all array-like arguments are Python numbers or lists. (NumPy arrays do have a &lt;code&gt;__array_function__&lt;/code&gt; method, given below, but it always returns &lt;code&gt;NotImplemented&lt;/code&gt; if any argument other than a NumPy array subclass implements &lt;code&gt;__array_function__&lt;/code&gt;.)</source>
          <target state="translated">Если методов &lt;code&gt;__array_function__&lt;/code&gt; не существует, NumPy по умолчанию будет вызывать свою собственную реализацию, предназначенную для использования в массивах NumPy. Этот случай возникает, например, когда все аргументы, подобные массиву, являются числами или списками Python. (Массивы NumPy имеют метод &lt;code&gt;__array_function__&lt;/code&gt; , указанный ниже, но он всегда возвращает &lt;code&gt;NotImplemented&lt;/code&gt; , если какой-либо аргумент, кроме подкласса массива NumPy, реализует &lt;code&gt;__array_function__&lt;/code&gt; .)</target>
        </trans-unit>
        <trans-unit id="505142361ce7d844b31c251e5147e86fce3849fd" translate="yes" xml:space="preserve">
          <source>If none of the inputs overrides the ufunc, then all output arrays will be passed to the &lt;a href=&quot;arrays.classes#numpy.class.__array_prepare__&quot;&gt;&lt;code&gt;__array_prepare__&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;arrays.classes#numpy.class.__array_wrap__&quot;&gt;&lt;code&gt;__array_wrap__&lt;/code&gt;&lt;/a&gt; methods of the input (besides &lt;a href=&quot;generated/numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;ndarrays&lt;/code&gt;&lt;/a&gt;, and scalars) that defines it &lt;strong&gt;and&lt;/strong&gt; has the highest &lt;a href=&quot;arrays.classes#numpy.class.__array_priority__&quot;&gt;&lt;code&gt;__array_priority__&lt;/code&gt;&lt;/a&gt; of any other input to the universal function. The default &lt;a href=&quot;arrays.classes#numpy.class.__array_priority__&quot;&gt;&lt;code&gt;__array_priority__&lt;/code&gt;&lt;/a&gt; of the ndarray is 0.0, and the default &lt;a href=&quot;arrays.classes#numpy.class.__array_priority__&quot;&gt;&lt;code&gt;__array_priority__&lt;/code&gt;&lt;/a&gt; of a subtype is 0.0. Matrices have &lt;a href=&quot;arrays.classes#numpy.class.__array_priority__&quot;&gt;&lt;code&gt;__array_priority__&lt;/code&gt;&lt;/a&gt; equal to 10.0.</source>
          <target state="translated">Если ни один из входов не переопределяет ufunc, тогда все выходные массивы будут &lt;a href=&quot;arrays.classes#numpy.class.__array_wrap__&quot;&gt; &lt;code&gt;__array_wrap__&lt;/code&gt; &lt;/a&gt; методам ввода &lt;a href=&quot;arrays.classes#numpy.class.__array_prepare__&quot;&gt; &lt;code&gt;__array_prepare__&lt;/code&gt; &lt;/a&gt; и __array_wrap__ (помимо &lt;a href=&quot;generated/numpy.ndarray#numpy.ndarray&quot;&gt; &lt;code&gt;ndarrays&lt;/code&gt; &lt;/a&gt; и скаляров), которые определяют его &lt;strong&gt;и&lt;/strong&gt; имеют наивысший &lt;a href=&quot;arrays.classes#numpy.class.__array_priority__&quot;&gt; &lt;code&gt;__array_priority__&lt;/code&gt; &lt;/a&gt; среди всех других входных данных универсальной функции. Значение по умолчанию &lt;a href=&quot;arrays.classes#numpy.class.__array_priority__&quot;&gt; &lt;code&gt;__array_priority__&lt;/code&gt; &lt;/a&gt; для ndarray равно 0,0, а значение по умолчанию &lt;a href=&quot;arrays.classes#numpy.class.__array_priority__&quot;&gt; &lt;code&gt;__array_priority__&lt;/code&gt; &lt;/a&gt; для подтипа - 0,0. Матрицы имеют &lt;a href=&quot;arrays.classes#numpy.class.__array_priority__&quot;&gt; &lt;code&gt;__array_priority__&lt;/code&gt; &lt;/a&gt; равное 10.0.</target>
        </trans-unit>
        <trans-unit id="96625db984c22cd52ed20b5b293895185469b2c4" translate="yes" xml:space="preserve">
          <source>If not &lt;code&gt;None&lt;/code&gt; normalization is by &lt;code&gt;(N - ddof)&lt;/code&gt;, where &lt;code&gt;N&lt;/code&gt; is the number of observations; this overrides the value implied by &lt;code&gt;bias&lt;/code&gt;. The default value is &lt;code&gt;None&lt;/code&gt;.</source>
          <target state="translated">Если нет &lt;code&gt;None&lt;/code&gt; нормализация по &lt;code&gt;(N - ddof)&lt;/code&gt; , где &lt;code&gt;N&lt;/code&gt; есть число наблюдений; это отменяет значение, подразумеваемое &lt;code&gt;bias&lt;/code&gt; . Значение по умолчанию - &lt;code&gt;None&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e98fcdb4d2a9bfdfbe2eeae9c39d82ef88da39fa" translate="yes" xml:space="preserve">
          <source>If not &lt;code&gt;None&lt;/code&gt; the default value implied by &lt;code&gt;bias&lt;/code&gt; is overridden. Note that &lt;code&gt;ddof=1&lt;/code&gt; will return the unbiased estimate, even if both &lt;code&gt;fweights&lt;/code&gt; and &lt;code&gt;aweights&lt;/code&gt; are specified, and &lt;code&gt;ddof=0&lt;/code&gt; will return the simple average. See the notes for the details. The default value is &lt;code&gt;None&lt;/code&gt;.</source>
          <target state="translated">Если не &lt;code&gt;None&lt;/code&gt; Значение по умолчанию подразумевается &lt;code&gt;bias&lt;/code&gt; отменяется. Обратите внимание, что &lt;code&gt;ddof=1&lt;/code&gt; вернет несмещенную оценку, даже если &lt;code&gt;fweights&lt;/code&gt; как fweights, так и &lt;code&gt;aweights&lt;/code&gt; , а &lt;code&gt;ddof=0&lt;/code&gt; вернет простое среднее. См. Примечания для деталей. Значение по умолчанию - &lt;code&gt;None&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="fcf87e157fa41fe29ae78434e407f9e7ee68fcea" translate="yes" xml:space="preserve">
          <source>If not None, the keys should indicate the type(s) that the respective formatting function applies to. Callables should return a string. Types that are not specified (by their corresponding keys) are handled by the default formatters. Individual types for which a formatter can be set are:</source>
          <target state="translated">Если нет None,то клавиши должны указывать тип(ы),к которым применяется соответствующая функция форматирования.Вызовные таблицы должны возвращать строку.Типы,которые не указаны (соответствующими ключами),обрабатываются форматировщиками по умолчанию.Индивидуальными являются типы,для которых может быть задано форматирование:</target>
        </trans-unit>
        <trans-unit id="bb477c8d5a32ba9dc9b4018fd2f3af6fa9009c49" translate="yes" xml:space="preserve">
          <source>If not None, the specified domain is used instead of that of the calling instance. It should be of the form &lt;code&gt;[beg,end]&lt;/code&gt;. The default is None which case the class domain is used.</source>
          <target state="translated">Если не None, указанный домен используется вместо домена вызывающего экземпляра. Он должен иметь форму &lt;code&gt;[beg,end]&lt;/code&gt; начало , конец] . Значение по умолчанию - Нет, в этом случае используется домен класса.</target>
        </trans-unit>
        <trans-unit id="9fd5a8f72ea35597060cfb26a58e00837b4119cd" translate="yes" xml:space="preserve">
          <source>If not None, then memory-map the file, using the given mode (see &lt;a href=&quot;numpy.memmap#numpy.memmap&quot;&gt;&lt;code&gt;numpy.memmap&lt;/code&gt;&lt;/a&gt; for a detailed description of the modes). A memory-mapped array is kept on disk. However, it can be accessed and sliced like any ndarray. Memory mapping is especially useful for accessing small fragments of large files without reading the entire file into memory.</source>
          <target state="translated">Если не None, тогда карта памяти файла с использованием данного режима (см. &lt;a href=&quot;numpy.memmap#numpy.memmap&quot;&gt; &lt;code&gt;numpy.memmap&lt;/code&gt; &lt;/a&gt; для подробного описания режимов). Массив с отображением памяти хранится на диске. Однако к нему можно получить доступ и нарезать, как любой ndarray. Отображение памяти особенно полезно для доступа к небольшим фрагментам больших файлов без чтения всего файла в память.</target>
        </trans-unit>
        <trans-unit id="7e8ee117c63f729e22bf227e3e07bb22de12fa90" translate="yes" xml:space="preserve">
          <source>If one argument: a scalar, only used in case &lt;code&gt;a&lt;/code&gt; is of size 1. If two arguments: the last argument is the value to be set and must be a scalar, the first argument specifies a single array element location. It is either an int or a tuple.</source>
          <target state="translated">Если один аргумент: скаляр, используется только в том случае, &lt;code&gt;a&lt;/code&gt; размер a равен 1. Если два аргумента: последний аргумент - это значение, которое необходимо установить, и должен быть скаляром, первый аргумент указывает расположение одного элемента массива. Это либо целое число, либо кортеж.</target>
        </trans-unit>
        <trans-unit id="6981fed895201194d2f8c788e92aaa4d462ed21a" translate="yes" xml:space="preserve">
          <source>If one of the input or output arguments has a &lt;a href=&quot;#numpy.class.__array_ufunc__&quot;&gt;&lt;code&gt;__array_ufunc__&lt;/code&gt;&lt;/a&gt; method, it is executed &lt;em&gt;instead&lt;/em&gt; of the ufunc. If more than one of the arguments implements &lt;a href=&quot;#numpy.class.__array_ufunc__&quot;&gt;&lt;code&gt;__array_ufunc__&lt;/code&gt;&lt;/a&gt;, they are tried in the order: subclasses before superclasses, inputs before outputs, otherwise left to right. The first routine returning something other than &lt;a href=&quot;https://docs.python.org/dev/library/constants.html#NotImplemented&quot;&gt;&lt;code&gt;NotImplemented&lt;/code&gt;&lt;/a&gt; determines the result. If all of the &lt;a href=&quot;#numpy.class.__array_ufunc__&quot;&gt;&lt;code&gt;__array_ufunc__&lt;/code&gt;&lt;/a&gt; operations return &lt;a href=&quot;https://docs.python.org/dev/library/constants.html#NotImplemented&quot;&gt;&lt;code&gt;NotImplemented&lt;/code&gt;&lt;/a&gt;, a &lt;a href=&quot;https://docs.python.org/dev/library/exceptions.html#TypeError&quot;&gt;&lt;code&gt;TypeError&lt;/code&gt;&lt;/a&gt; is raised.</source>
          <target state="translated">Если один из входных или выходных аргументов имеет метод &lt;a href=&quot;#numpy.class.__array_ufunc__&quot;&gt; &lt;code&gt;__array_ufunc__&lt;/code&gt; &lt;/a&gt; , он выполняется &lt;em&gt;вместо&lt;/em&gt; ufunc. Если несколько аргументов реализуют &lt;a href=&quot;#numpy.class.__array_ufunc__&quot;&gt; &lt;code&gt;__array_ufunc__&lt;/code&gt; &lt;/a&gt; , они проверяются в следующем порядке: подклассы перед суперклассами, входы перед выходами, в противном случае слева направо. Первая подпрограмма, возвращающая что-то иное, чем &lt;a href=&quot;https://docs.python.org/dev/library/constants.html#NotImplemented&quot;&gt; &lt;code&gt;NotImplemented&lt;/code&gt; ,&lt;/a&gt; определяет результат. Если все &lt;a href=&quot;#numpy.class.__array_ufunc__&quot;&gt; &lt;code&gt;__array_ufunc__&lt;/code&gt; &lt;/a&gt; операции возвращают &lt;a href=&quot;https://docs.python.org/dev/library/constants.html#NotImplemented&quot;&gt; &lt;code&gt;NotImplemented&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;https://docs.python.org/dev/library/exceptions.html#TypeError&quot;&gt; &lt;code&gt;TypeError&lt;/code&gt; &lt;/a&gt; поднимается.</target>
        </trans-unit>
        <trans-unit id="078513303dc00f49a54bb48b4a05d01efff2507a" translate="yes" xml:space="preserve">
          <source>If one or more elements differ by more than &lt;code&gt;maxulp&lt;/code&gt;.</source>
          <target state="translated">Если один или несколько элементов отличаются более чем на &lt;code&gt;maxulp&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="00b891e47fe38237c020d297bb43b5693729c6dd" translate="yes" xml:space="preserve">
          <source>If one throws a die repeatedly until the third time a &amp;ldquo;1&amp;rdquo; appears, then the probability distribution of the number of non-&amp;ldquo;1&amp;rdquo;s that appear before the third &amp;ldquo;1&amp;rdquo; is a negative binomial distribution.</source>
          <target state="translated">Если бросать кубик несколько раз до тех пор, пока в третий раз не появится цифра &amp;laquo;1&amp;raquo;, то распределение вероятностей количества не- &amp;laquo;1&amp;raquo;, которые появляются перед третьей &amp;laquo;1&amp;raquo;, является отрицательным биномиальным распределением.</target>
        </trans-unit>
        <trans-unit id="f25e55ccd77b879343ce3ca049a9d0e4b78987e8" translate="yes" xml:space="preserve">
          <source>If one uses the same dimension name in multiple locations, this enforces the same size of the corresponding dimensions.</source>
          <target state="translated">Если в нескольких местах используется одно и то же имя размера,то в этом случае применяется один и тот же размер соответствующих размеров.</target>
        </trans-unit>
        <trans-unit id="9d0e3c2e03d57620541ba508399723e46a30af16" translate="yes" xml:space="preserve">
          <source>If operand flags &lt;code&gt;&amp;ldquo;writeonly&amp;rdquo;&lt;/code&gt; or &lt;code&gt;&amp;ldquo;readwrite&amp;rdquo;&lt;/code&gt; are used the operands may be views into the original data with the &lt;code&gt;WRITEBACKIFCOPY&lt;/code&gt; flag. In this case nditer must be used as a context manager or the nditer.close method must be called before using the result. The temporary data will be written back to the original data when the &lt;code&gt;__exit__&lt;/code&gt; function is called but not before:</source>
          <target state="translated">Если используются флаги операндов &lt;code&gt;&amp;ldquo;writeonly&amp;rdquo;&lt;/code&gt; или &lt;code&gt;&amp;ldquo;readwrite&amp;rdquo;&lt;/code&gt; , операнды могут быть &lt;code&gt;WRITEBACKIFCOPY&lt;/code&gt; в исходных данных с флагом WRITEBACKIFCOPY . В этом случае nditer необходимо использовать в качестве диспетчера контекста или перед использованием результата необходимо вызвать метод nditer.close. Временные данные будут записаны обратно в исходные данные при &lt;code&gt;__exit__&lt;/code&gt; функции __exit__, но не раньше:</target>
        </trans-unit>
        <trans-unit id="7979a86d632f406a43fda9a7bbc242f0b6aa48c1" translate="yes" xml:space="preserve">
          <source>If out is given and does not have a mask attribute, the mask of a is lost!</source>
          <target state="translated">Если выдан аут и не имеет атрибута маски,то маска утеряна!</target>
        </trans-unit>
        <trans-unit id="540ba134ebef3a60b12504ba1dddaea7cf0cec06" translate="yes" xml:space="preserve">
          <source>If passed a single ndarray or scalar (a nested list of depth 0), this is returned unmodified (and not copied).</source>
          <target state="translated">Если передан одиночный ндаррей или скаляр (вложенный список глубины 0),то он возвращается немодифицированным (и не копируется).</target>
        </trans-unit>
        <trans-unit id="96808216b5aaeeafcea0d1c6dd5a1e0894eaaeca" translate="yes" xml:space="preserve">
          <source>If positive int_like arguments are provided, &lt;a href=&quot;#numpy.random.mtrand.RandomState.randn&quot;&gt;&lt;code&gt;randn&lt;/code&gt;&lt;/a&gt; generates an array of shape &lt;code&gt;(d0, d1, ..., dn)&lt;/code&gt;, filled with random floats sampled from a univariate &amp;ldquo;normal&amp;rdquo; (Gaussian) distribution of mean 0 and variance 1. A single float randomly sampled from the distribution is returned if no argument is provided.</source>
          <target state="translated">Если предоставлены положительные аргументы типа &lt;a href=&quot;#numpy.random.mtrand.RandomState.randn&quot;&gt; &lt;code&gt;randn&lt;/code&gt; &lt;/a&gt; , randn генерирует массив формы &lt;code&gt;(d0, d1, ..., dn)&lt;/code&gt; , заполненный случайными числами с плавающей запятой, выбранными из одномерного &amp;laquo;нормального&amp;raquo; (гауссовского) распределения среднего 0 и дисперсии 1. Одно значение с плавающей запятой. Если аргумент не указан, возвращается случайная выборка из распределения.</target>
        </trans-unit>
        <trans-unit id="55be54163f14c3cf436fe9e5956719fe1ba33eba" translate="yes" xml:space="preserve">
          <source>If provided, forces the calculation to use the data type specified. Note that you may have to also give a more liberal &lt;code&gt;casting&lt;/code&gt; parameter to allow the conversions. Default is None.</source>
          <target state="translated">Если задан, заставляет расчет использовать указанный тип данных. Обратите внимание, что вам, возможно, придется указать более либеральный параметр &lt;code&gt;casting&lt;/code&gt; чтобы разрешить преобразования. По умолчанию нет.</target>
        </trans-unit>
        <trans-unit id="e083348afe334fd6151280febab9e53c63ddbb1c" translate="yes" xml:space="preserve">
          <source>If provided, is a list of ints or None for each operands. The list of axes for an operand is a mapping from the dimensions of the iterator to the dimensions of the operand. A value of -1 can be placed for entries, causing that dimension to be treated as &lt;a href=&quot;../constants#numpy.newaxis&quot;&gt;&lt;code&gt;newaxis&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Если предоставлено, это список целых чисел или None для каждого операнда. Список осей для операнда - это отображение размеров итератора на размеры операнда. Для записей можно &lt;a href=&quot;../constants#numpy.newaxis&quot;&gt; &lt;code&gt;newaxis&lt;/code&gt; &lt;/a&gt; значение -1, в результате чего это измерение будет рассматриваться как новая ось .</target>
        </trans-unit>
        <trans-unit id="b5d381c2d7955b7fd1c70c985e306d9e2f555e38" translate="yes" xml:space="preserve">
          <source>If provided, one above the largest (signed) integer to be drawn from the distribution (see above for behavior if &lt;code&gt;high=None&lt;/code&gt;). If array-like, must contain integer values</source>
          <target state="translated">Если предоставлено, одно число выше наибольшего (подписанного) целого числа, которое будет извлечено из распределения (см. Поведение выше, если &lt;code&gt;high=None&lt;/code&gt; ). Если подобен массиву, должен содержать целочисленные значения</target>
        </trans-unit>
        <trans-unit id="95838d6d878826fc55d5a3e35ced6032cc48a529" translate="yes" xml:space="preserve">
          <source>If provided, the calculation is done into this array.</source>
          <target state="translated">Если это предусмотрено,то вычисление производится в этом массиве.</target>
        </trans-unit>
        <trans-unit id="af1a016b36ff8a1ba521445122b451501db1dbf6" translate="yes" xml:space="preserve">
          <source>If provided, the destination to place the result. The shape must be correct, matching that of what concatenate would have returned if no out argument were specified.</source>
          <target state="translated">Если предусмотрено,пункт назначения для размещения результата.Форма должна быть правильной,соответствующей тому,что конкатенат возвращал бы,если бы не был указан внешний аргумент.</target>
        </trans-unit>
        <trans-unit id="c1c663fe8abb225f988d791716021ba47f8cdb72" translate="yes" xml:space="preserve">
          <source>If provided, the destination to place the result. The shape must be correct, matching that of what stack would have returned if no out argument were specified.</source>
          <target state="translated">Если предусмотрено,пункт назначения для размещения результата.Форма должна быть правильной,совпадающей с тем,что возвращал бы стек,если бы не был указан аргумент out.</target>
        </trans-unit>
        <trans-unit id="f5316b9b72a00d5e03e3e99cc76713f526033f92" translate="yes" xml:space="preserve">
          <source>If provided, the largest (signed) integer to be drawn from the distribution (see above for behavior if &lt;code&gt;high=None&lt;/code&gt;).</source>
          <target state="translated">Если предоставлено, наибольшее (со знаком) целое число, которое будет извлечено из распределения (см. Поведение выше, если &lt;code&gt;high=None&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="95c405f27ca318550aa8a5e9d68fd036459e5597" translate="yes" xml:space="preserve">
          <source>If provided, the result will be inserted into this array. It should be of the appropriate shape and &lt;code&gt;dtype&lt;/code&gt;.</source>
          <target state="translated">Если указано, результат будет вставлен в этот массив. Он должен быть соответствующей формы и &lt;code&gt;dtype&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5aa5842b82d356df663381019439d99b6de6d45f" translate="yes" xml:space="preserve">
          <source>If provided, the result will be inserted into this array. It should be of the appropriate shape and dtype.</source>
          <target state="translated">Если это предусмотрено,то результат будет вставлен в этот массив.Он должен иметь соответствующую форму и тип d.</target>
        </trans-unit>
        <trans-unit id="cb7c8c85e64a3a49b66549989ff45cf1e28fbfc9" translate="yes" xml:space="preserve">
          <source>If provided, the result will be inserted into this array. It should be of the appropriate shape and dtype. Note that &lt;code&gt;out&lt;/code&gt; is always buffered if &lt;code&gt;mode=&amp;rsquo;raise&amp;rsquo;&lt;/code&gt;; use other modes for better performance.</source>
          <target state="translated">Если указано, результат будет вставлен в этот массив. Он должен быть соответствующей формы и типа. Обратите внимание, что &lt;code&gt;out&lt;/code&gt; всегда буферизуется, если &lt;code&gt;mode=&amp;rsquo;raise&amp;rsquo;&lt;/code&gt; ; используйте другие режимы для повышения производительности.</target>
        </trans-unit>
        <trans-unit id="81a5da5dc747b4213d85b5feaae67db0441d8c96" translate="yes" xml:space="preserve">
          <source>If provided, the result will be placed in this array. It should be of the appropriate shape and dtype. Note that &lt;code&gt;out&lt;/code&gt; is always buffered if &lt;code&gt;mode=&amp;rsquo;raise&amp;rsquo;&lt;/code&gt;; use other modes for better performance.</source>
          <target state="translated">Если указано, результат будет помещен в этот массив. Он должен быть соответствующей формы и типа. Обратите внимание, что &lt;code&gt;out&lt;/code&gt; всегда буферизуется, если &lt;code&gt;mode=&amp;rsquo;raise&amp;rsquo;&lt;/code&gt; ; используйте другие режимы для повышения производительности.</target>
        </trans-unit>
        <trans-unit id="930ff5cfb0e50021c5f5a8e94b02d45dd7e7a78b" translate="yes" xml:space="preserve">
          <source>If provided, this array is filled with the result.</source>
          <target state="translated">Если это предусмотрено,то этот массив заполняется результатом.</target>
        </trans-unit>
        <trans-unit id="11fa623532ff8e1a6968612e0395b44c20331e38" translate="yes" xml:space="preserve">
          <source>If set to False, the returned array will always be readonly. Otherwise it will be writable if the original array was. It is advisable to set this to False if possible (see Notes).</source>
          <target state="translated">Если установлено значение False,возвращаемый массив всегда будет только для чтения.В противном случае он будет доступен для записи,если исходный массив был.Рекомендуется по возможности устанавливать значение False (см.Примечания).</target>
        </trans-unit>
        <trans-unit id="2bff5e445257625fab4df9171fbb5cbef9e23081" translate="yes" xml:space="preserve">
          <source>If set to the string &lt;code&gt;&amp;lsquo;1.13&amp;rsquo;&lt;/code&gt; enables 1.13 legacy printing mode. This approximates numpy 1.13 print output by including a space in the sign position of floats and different behavior for 0d arrays. If set to &lt;code&gt;False&lt;/code&gt;, disables legacy mode. Unrecognized strings will be ignored with a warning for forward compatibility.</source>
          <target state="translated">Если установлено значение &lt;code&gt;&amp;lsquo;1.13&amp;rsquo;&lt;/code&gt; включается устаревший режим печати 1.13. Это приближает вывод numpy 1.13 на печать, включая пробел в позиции знака с плавающей запятой и различное поведение для массивов 0d. Если установлено значение &lt;code&gt;False&lt;/code&gt; , устаревший режим отключается. Нераспознанные строки будут проигнорированы с предупреждением для прямой совместимости.</target>
        </trans-unit>
        <trans-unit id="fe72d8f764239876f5476ff64d033c4aa157117d" translate="yes" xml:space="preserve">
          <source>If slice notation is used, the syntax &lt;code&gt;start:stop:step&lt;/code&gt; is equivalent to &lt;code&gt;np.arange(start, stop, step)&lt;/code&gt; inside of the brackets. However, if &lt;code&gt;step&lt;/code&gt; is an imaginary number (i.e. 100j) then its integer portion is interpreted as a number-of-points desired and the start and stop are inclusive. In other words &lt;code&gt;start:stop:stepj&lt;/code&gt; is interpreted as &lt;code&gt;np.linspace(start, stop, step, endpoint=1)&lt;/code&gt; inside of the brackets. After expansion of slice notation, all comma separated sequences are concatenated together.</source>
          <target state="translated">Если используется нотация среза, синтаксис &lt;code&gt;start:stop:step&lt;/code&gt; эквивалентен &lt;code&gt;np.arange(start, stop, step)&lt;/code&gt; внутри скобок. Однако, если &lt;code&gt;step&lt;/code&gt; является мнимым числом (например, 100j), то его целая часть интерпретируется как желаемое количество точек, а начало и конец включены. Другими словами &lt;code&gt;start:stop:stepj&lt;/code&gt; интерпретируется как &lt;code&gt;np.linspace(start, stop, step, endpoint=1)&lt;/code&gt; внутри скобок. После расширения нотации срезов все последовательности, разделенные запятыми, объединяются вместе.</target>
        </trans-unit>
        <trans-unit id="81a87ade0c2eb6eb2f3e1b57567f9837157177e2" translate="yes" xml:space="preserve">
          <source>If some of the singular values of &lt;code&gt;V&lt;/code&gt; are so small that they are neglected (and &lt;code&gt;full&lt;/code&gt; == &lt;code&gt;False&lt;/code&gt;), a &lt;code&gt;RankWarning&lt;/code&gt; will be raised. This means that the coefficient values may be poorly determined. Fitting to a lower order polynomial will usually get rid of the warning (but may not be what you want, of course; if you have independent reason(s) for choosing the degree which isn&amp;rsquo;t working, you may have to: a) reconsider those reasons, and/or b) reconsider the quality of your data). The &lt;code&gt;rcond&lt;/code&gt; parameter can also be set to a value smaller than its default, but the resulting fit may be spurious and have large contributions from roundoff error.</source>
          <target state="translated">Если некоторые из сингулярных значений &lt;code&gt;V&lt;/code&gt; настолько малы, что ими пренебрегают (и &lt;code&gt;full&lt;/code&gt; == &lt;code&gt;False&lt;/code&gt; ), будет &lt;code&gt;RankWarning&lt;/code&gt; . Это означает, что значения коэффициентов могут быть плохо определены. Подбор полинома более низкого порядка обычно избавляет от предупреждения (но, конечно, это может быть не то, что вам нужно; если у вас есть независимые причины для выбора степени, которая не работает, вам, возможно, придется: a) пересмотреть эти причины и / или б) пересмотреть качество ваших данных). Параметр &lt;code&gt;rcond&lt;/code&gt; также может быть установлен на значение меньшее, чем значение по умолчанию, но полученное соответствие может быть ложным и иметь большой вклад из-за ошибки округления.</target>
        </trans-unit>
        <trans-unit id="279580d9404d9230f24c863b3bff92a3996533c2" translate="yes" xml:space="preserve">
          <source>If some of the singular values of &lt;code&gt;V&lt;/code&gt; are so small that they are neglected, then a &lt;code&gt;RankWarning&lt;/code&gt; will be issued. This means that the coefficient values may be poorly determined. Using a lower order fit will usually get rid of the warning. The &lt;code&gt;rcond&lt;/code&gt; parameter can also be set to a value smaller than its default, but the resulting fit may be spurious and have large contributions from roundoff error.</source>
          <target state="translated">Если некоторые из сингулярных значений &lt;code&gt;V&lt;/code&gt; настолько малы, что ими пренебрегают, будет выдано &lt;code&gt;RankWarning&lt;/code&gt; . Это означает, что значения коэффициентов могут быть плохо определены. Использование подгонки более низкого порядка обычно избавляет от предупреждения. Параметр &lt;code&gt;rcond&lt;/code&gt; также может быть установлен на значение меньшее, чем значение по умолчанию, но полученное соответствие может быть ложным и иметь большой вклад из-за ошибки округления.</target>
        </trans-unit>
        <trans-unit id="965baa6e6f17f07c36f67c069da20d4c8b056bfe" translate="yes" xml:space="preserve">
          <source>If sparse is False:</source>
          <target state="translated">Если скудный-это Ложь:</target>
        </trans-unit>
        <trans-unit id="d3cfaef438df28358b3d4e747b777d350c839464" translate="yes" xml:space="preserve">
          <source>If sparse is True:</source>
          <target state="translated">Если малое-это правда:</target>
        </trans-unit>
        <trans-unit id="da499c4730990d0eca07f07d81ecedd5eee01e35" translate="yes" xml:space="preserve">
          <source>If sparse is set to true, the grid will be returned in a sparse representation.</source>
          <target state="translated">Если разреженное значение установлено в true,то сетка будет возвращена в разреженном представлении.</target>
        </trans-unit>
        <trans-unit id="a0b2e0085e9bacd8c444b0a0e2e8508a5f8b81ab" translate="yes" xml:space="preserve">
          <source>If specified, all the fields will be changed to the provided byte-order. Otherwise, the default byte-order is used. For all available string specifiers, see &lt;a href=&quot;numpy.dtype.newbyteorder#numpy.dtype.newbyteorder&quot;&gt;&lt;code&gt;dtype.newbyteorder&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Если указано, все поля будут изменены в указанном порядке байтов. В противном случае используется порядок байтов по умолчанию. Все доступные спецификаторы строк см. В &lt;a href=&quot;numpy.dtype.newbyteorder#numpy.dtype.newbyteorder&quot;&gt; &lt;code&gt;dtype.newbyteorder&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="f824fc5934f1c56555b7168823af2d5da98b5dab" translate="yes" xml:space="preserve">
          <source>If state is a dictionary, it is directly set using the BitGenerators &lt;code&gt;state&lt;/code&gt; property.</source>
          <target state="translated">Если состояние является словарем, оно устанавливается напрямую с помощью свойства &lt;code&gt;state&lt;/code&gt; BitGenerators .</target>
        </trans-unit>
        <trans-unit id="ebc779ce22e3bc8704e258c3f6aa49989598231f" translate="yes" xml:space="preserve">
          <source>If the (deprecated) &lt;a href=&quot;#c.NPY_ARRAY_UPDATEIFCOPY&quot;&gt;&lt;code&gt;NPY_ARRAY_UPDATEIFCOPY&lt;/code&gt;&lt;/a&gt; or the &lt;a href=&quot;#c.NPY_ARRAY_WRITEBACKIFCOPY&quot;&gt;&lt;code&gt;NPY_ARRAY_WRITEBACKIFCOPY&lt;/code&gt;&lt;/a&gt; flags are set, it has a different meaning, namely base is the array into which the current array will be copied upon copy resolution. This overloading of the base property for two functions is likely to change in a future version of NumPy.</source>
          <target state="translated">Если (устарело) &lt;a href=&quot;#c.NPY_ARRAY_UPDATEIFCOPY&quot;&gt; &lt;code&gt;NPY_ARRAY_UPDATEIFCOPY&lt;/code&gt; &lt;/a&gt; флаги NPY_ARRAY_UPDATEIFCOPY или &lt;a href=&quot;#c.NPY_ARRAY_WRITEBACKIFCOPY&quot;&gt; &lt;code&gt;NPY_ARRAY_WRITEBACKIFCOPY&lt;/code&gt; &lt;/a&gt; , они имеют другое значение, а именно base - это массив, в который будет скопирован текущий массив при разрешении копирования. Эта перегрузка базового свойства для двух функций, вероятно, изменится в будущей версии NumPy.</target>
        </trans-unit>
        <trans-unit id="6f501c2023177671c00839603f74082e5dd3d055" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;generated/numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;ndarray&lt;/code&gt;&lt;/a&gt; object is a structured array the &lt;a href=&quot;https://docs.scipy.org/doc/numpy-1.17.0/glossary.html#term-field&quot;&gt;fields&lt;/a&gt; of the array can be accessed by indexing the array with strings, dictionary-like.</source>
          <target state="translated">Если объект &lt;a href=&quot;generated/numpy.ndarray#numpy.ndarray&quot;&gt; &lt;code&gt;ndarray&lt;/code&gt; &lt;/a&gt; является структурированным массивом, доступ к &lt;a href=&quot;https://docs.scipy.org/doc/numpy-1.17.0/glossary.html#term-field&quot;&gt;полям&lt;/a&gt; массива можно получить, индексируя массив строками, как в словаре.</target>
        </trans-unit>
        <trans-unit id="0646be9a4620b324160297ec7386ae7d381a6d92" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;order&lt;/code&gt; keyword argument is specified. This behaviour is a bug in NumPy.</source>
          <target state="translated">Если указан аргумент ключевого слова &lt;code&gt;order&lt;/code&gt; . Такое поведение является ошибкой в ​​NumPy.</target>
        </trans-unit>
        <trans-unit id="95474ba24abf246463d023b7d37164eff549d001" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;width&lt;/code&gt; value is insufficient, it will be ignored, and &lt;code&gt;num&lt;/code&gt; will be returned in binary (&lt;code&gt;num&lt;/code&gt; &amp;gt; 0) or two&amp;rsquo;s complement (&lt;code&gt;num&lt;/code&gt; &amp;lt; 0) form with its width equal to the minimum number of bits needed to represent the number in the designated form. This behavior is deprecated and will later raise an error.</source>
          <target state="translated">Если значение &lt;code&gt;width&lt;/code&gt; недостаточное, оно будет проигнорировано, а &lt;code&gt;num&lt;/code&gt; будет возвращено в двоичной форме ( &lt;code&gt;num&lt;/code&gt; &amp;gt; 0) или в форме дополнения до двух ( &lt;code&gt;num&lt;/code&gt; &amp;lt;0) с шириной, равной минимальному количеству битов, необходимых для представления числа в обозначенная форма. Такое поведение устарело и позже вызовет ошибку.</target>
        </trans-unit>
        <trans-unit id="049594537957d0705cc457b562940a40a3ed3347" translate="yes" xml:space="preserve">
          <source>If the SVD computation does not converge.</source>
          <target state="translated">Если вычисления SVD не сходятся.</target>
        </trans-unit>
        <trans-unit id="64f36babe99dcf796b7778a9ef584cf09c04cb03" translate="yes" xml:space="preserve">
          <source>If the accessed field is a sub-array, the dimensions of the sub-array are appended to the shape of the result.</source>
          <target state="translated">Если поле доступа является подмассивом,то размеры подмассива добавляются к форме результата.</target>
        </trans-unit>
        <trans-unit id="ba28bd784223a2a08bea18d126c6d98be59cd057" translate="yes" xml:space="preserve">
          <source>If the accumulator is too small, overflow occurs:</source>
          <target state="translated">Если аккумулятор слишком мал,происходит переполнение:</target>
        </trans-unit>
        <trans-unit id="f2dce957332c62c691a49ddcc68e31de7ff97f8b" translate="yes" xml:space="preserve">
          <source>If the array has no mask, the address of &lt;a href=&quot;../maskedarray.baseclass#numpy.ma.nomask&quot;&gt;&lt;code&gt;nomask&lt;/code&gt;&lt;/a&gt; is returned. This address is typically not close to the data in memory:</source>
          <target state="translated">Если у массива нет маски, возвращается адрес &lt;a href=&quot;../maskedarray.baseclass#numpy.ma.nomask&quot;&gt; &lt;code&gt;nomask&lt;/code&gt; &lt;/a&gt; . Этот адрес обычно не близок к данным в памяти:</target>
        </trans-unit>
        <trans-unit id="0e4bd5d4fdacecd1895716db48cb1cac490ae19c" translate="yes" xml:space="preserve">
          <source>If the array is not compatible with the new shape according to NumPy&amp;rsquo;s broadcasting rules.</source>
          <target state="translated">Если массив несовместим с новой формой в соответствии с правилами вещания NumPy.</target>
        </trans-unit>
        <trans-unit id="9556db7609e9b52c8da71258e9ebc1e23d97b8b8" translate="yes" xml:space="preserve">
          <source>If the buffer has data that is not in machine byte-order, this should be specified as part of the data-type, e.g.:</source>
          <target state="translated">Если в буфере есть данные,которые не находятся в машинном байт-ордере,то это должно быть указано в составе типа данных,например</target>
        </trans-unit>
        <trans-unit id="a9172eee727e3bc5966a060de8a7a54e3be2870d" translate="yes" xml:space="preserve">
          <source>If the common data type is known ahead of time, don&amp;rsquo;t use this flag. Instead, set the requested dtype for all the operands.</source>
          <target state="translated">Если общий тип данных известен заранее, не используйте этот флаг. Вместо этого установите запрошенный dtype для всех операндов.</target>
        </trans-unit>
        <trans-unit id="c0b42d9b2195e628dbcfcb8e55fe0f75a169d8db" translate="yes" xml:space="preserve">
          <source>If the condition is a callable, it is used at runtime to dynamically make the decision. This is useful for tests that may require costly imports, to delay the cost until the test suite is actually executed.</source>
          <target state="translated">Если условие является вызываемым,то оно используется во время выполнения для динамического принятия решения.Это полезно для тестов,которые могут потребовать дорогостоящего импорта,чтобы задержать стоимость до тех пор,пока тестовый набор не будет фактически выполнен.</target>
        </trans-unit>
        <trans-unit id="da8929bf843323251f47496e7bd27572472297dd" translate="yes" xml:space="preserve">
          <source>If the conversion is not possible</source>
          <target state="translated">Если преобразование невозможно</target>
        </trans-unit>
        <trans-unit id="bf41eeaf999250f9cdaa16bd479da6c16a96c8f5" translate="yes" xml:space="preserve">
          <source>If the ctypes module is not available, then the ctypes attribute of array objects still returns something useful, but ctypes objects are not returned and errors may be raised instead. In particular, the object will still have the &lt;code&gt;as_parameter&lt;/code&gt; attribute which will return an integer equal to the data attribute.</source>
          <target state="translated">Если модуль ctypes недоступен, то атрибут ctypes объектов массива по-прежнему возвращает что-то полезное, но объекты ctypes не возвращаются, и вместо этого могут возникать ошибки. В частности, объект по-прежнему будет иметь атрибут &lt;code&gt;as_parameter&lt;/code&gt; , который вернет целое число, равное атрибуту данных.</target>
        </trans-unit>
        <trans-unit id="882469c86c3e266d61a4e68ca724a4e1e6d70bb9" translate="yes" xml:space="preserve">
          <source>If the current domain is the interval &lt;code&gt;[l1, r1]&lt;/code&gt; and the window is &lt;code&gt;[l2, r2]&lt;/code&gt;, then the linear mapping function &lt;code&gt;L&lt;/code&gt; is defined by the equations:</source>
          <target state="translated">Если текущая область - это интервал &lt;code&gt;[l1, r1]&lt;/code&gt; а окно - &lt;code&gt;[l2, r2]&lt;/code&gt; , то функция линейного отображения &lt;code&gt;L&lt;/code&gt; определяется уравнениями:</target>
        </trans-unit>
        <trans-unit id="b7e4177a6acaf9fb51b7f55a4c29b9a1f7f66006" translate="yes" xml:space="preserve">
          <source>If the data type is &lt;a href=&quot;https://docs.scipy.org/doc/numpy-1.17.0/glossary.html#term-structured-data-type&quot;&gt;structured data type&lt;/a&gt;, an aggregate of other data types, (&lt;em&gt;e.g.&lt;/em&gt;, describing an array item consisting of an integer and a float),</source>
          <target state="translated">Если тип данных является &lt;a href=&quot;https://docs.scipy.org/doc/numpy-1.17.0/glossary.html#term-structured-data-type&quot;&gt;структурированным типом данных&lt;/a&gt; , совокупностью других типов данных ( &lt;em&gt;например&lt;/em&gt; , описывающий элемент массива, состоящий из целого числа и числа с плавающей запятой),</target>
        </trans-unit>
        <trans-unit id="0cecddf950b77d1003b9474189d29ff0bfdb6282" translate="yes" xml:space="preserve">
          <source>If the data type is a sub-array, what is its shape and data type.</source>
          <target state="translated">Если тип данных является подмассивом,то какова его форма и тип данных.</target>
        </trans-unit>
        <trans-unit id="5b7ff57105753a62bcfc1055c91f35344e435758" translate="yes" xml:space="preserve">
          <source>If the decomposition fails, for example, if &lt;code&gt;a&lt;/code&gt; is not positive-definite.</source>
          <target state="translated">Если разложение не удается, например, если &lt;code&gt;a&lt;/code&gt; не является положительно определенным.</target>
        </trans-unit>
        <trans-unit id="ee52413e2abf8d484ea3208ee7d3358a43d8e634" translate="yes" xml:space="preserve">
          <source>If the default value is passed, then &lt;code&gt;keepdims&lt;/code&gt; will not be passed through to the &lt;a href=&quot;#numpy.all&quot;&gt;&lt;code&gt;all&lt;/code&gt;&lt;/a&gt; method of sub-classes of &lt;a href=&quot;numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;ndarray&lt;/code&gt;&lt;/a&gt;, however any non-default value will be. If the sub-class&amp;rsquo; method does not implement &lt;code&gt;keepdims&lt;/code&gt; any exceptions will be raised.</source>
          <target state="translated">Если передается значение по умолчанию, то &lt;code&gt;keepdims&lt;/code&gt; не будет передаваться &lt;a href=&quot;#numpy.all&quot;&gt; &lt;code&gt;all&lt;/code&gt; &lt;/a&gt; методу подклассов &lt;a href=&quot;numpy.ndarray#numpy.ndarray&quot;&gt; &lt;code&gt;ndarray&lt;/code&gt; &lt;/a&gt; , однако любое значение, отличное от значения по умолчанию, будет. Если метод подкласса не реализует &lt;code&gt;keepdims&lt;/code&gt; , будут возникать исключения.</target>
        </trans-unit>
        <trans-unit id="206ca5be0da6c825b1f0142de708ea22958f4d55" translate="yes" xml:space="preserve">
          <source>If the default value is passed, then &lt;code&gt;keepdims&lt;/code&gt; will not be passed through to the &lt;a href=&quot;#numpy.amax&quot;&gt;&lt;code&gt;amax&lt;/code&gt;&lt;/a&gt; method of sub-classes of &lt;a href=&quot;numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;ndarray&lt;/code&gt;&lt;/a&gt;, however any non-default value will be. If the sub-class&amp;rsquo; method does not implement &lt;code&gt;keepdims&lt;/code&gt; any exceptions will be raised.</source>
          <target state="translated">Если значение по умолчанию будет принято, то &lt;code&gt;keepdims&lt;/code&gt; не будет проходить через к &lt;a href=&quot;#numpy.amax&quot;&gt; &lt;code&gt;amax&lt;/code&gt; &lt;/a&gt; методе подклассов &lt;a href=&quot;numpy.ndarray#numpy.ndarray&quot;&gt; &lt;code&gt;ndarray&lt;/code&gt; &lt;/a&gt; , однако любое значение не по умолчанию будет. Если метод подкласса не реализует &lt;code&gt;keepdims&lt;/code&gt; , будут возникать исключения.</target>
        </trans-unit>
        <trans-unit id="f05780b3efb83cb7999e12324775e7fa0e8c55fe" translate="yes" xml:space="preserve">
          <source>If the default value is passed, then &lt;code&gt;keepdims&lt;/code&gt; will not be passed through to the &lt;a href=&quot;#numpy.amin&quot;&gt;&lt;code&gt;amin&lt;/code&gt;&lt;/a&gt; method of sub-classes of &lt;a href=&quot;numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;ndarray&lt;/code&gt;&lt;/a&gt;, however any non-default value will be. If the sub-class&amp;rsquo; method does not implement &lt;code&gt;keepdims&lt;/code&gt; any exceptions will be raised.</source>
          <target state="translated">Если передается значение по умолчанию, то &lt;code&gt;keepdims&lt;/code&gt; не будут передаваться в метод &lt;a href=&quot;#numpy.amin&quot;&gt; &lt;code&gt;amin&lt;/code&gt; &lt;/a&gt; подклассов &lt;a href=&quot;numpy.ndarray#numpy.ndarray&quot;&gt; &lt;code&gt;ndarray&lt;/code&gt; &lt;/a&gt; , однако любое значение, отличное от значения по умолчанию, будет. Если метод подкласса не реализует &lt;code&gt;keepdims&lt;/code&gt; , будут возникать исключения.</target>
        </trans-unit>
        <trans-unit id="4bb758877f868372bd36b970799d233d6c9b6b2e" translate="yes" xml:space="preserve">
          <source>If the default value is passed, then &lt;code&gt;keepdims&lt;/code&gt; will not be passed through to the &lt;a href=&quot;#numpy.any&quot;&gt;&lt;code&gt;any&lt;/code&gt;&lt;/a&gt; method of sub-classes of &lt;a href=&quot;numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;ndarray&lt;/code&gt;&lt;/a&gt;, however any non-default value will be. If the sub-class&amp;rsquo; method does not implement &lt;code&gt;keepdims&lt;/code&gt; any exceptions will be raised.</source>
          <target state="translated">Если передается значение по умолчанию, то &lt;code&gt;keepdims&lt;/code&gt; не будет передаваться в &lt;a href=&quot;#numpy.any&quot;&gt; &lt;code&gt;any&lt;/code&gt; &lt;/a&gt; метод подклассов &lt;a href=&quot;numpy.ndarray#numpy.ndarray&quot;&gt; &lt;code&gt;ndarray&lt;/code&gt; &lt;/a&gt; , однако любое значение, не являющееся значением по умолчанию, будет. Если метод подкласса не реализует &lt;code&gt;keepdims&lt;/code&gt; , будут возникать исключения.</target>
        </trans-unit>
        <trans-unit id="4f36bf742dff79ee7a2535335e60a655538367af" translate="yes" xml:space="preserve">
          <source>If the default value is passed, then &lt;code&gt;keepdims&lt;/code&gt; will not be passed through to the &lt;a href=&quot;#numpy.ma.var&quot;&gt;&lt;code&gt;var&lt;/code&gt;&lt;/a&gt; method of sub-classes of &lt;code&gt;ndarray&lt;/code&gt;, however any non-default value will be. If the sub-class&amp;rsquo; method does not implement &lt;code&gt;keepdims&lt;/code&gt; any exceptions will be raised.</source>
          <target state="translated">Если передается значение по умолчанию, то &lt;code&gt;keepdims&lt;/code&gt; не будет передаваться в метод &lt;a href=&quot;#numpy.ma.var&quot;&gt; &lt;code&gt;var&lt;/code&gt; &lt;/a&gt; подклассов &lt;code&gt;ndarray&lt;/code&gt; , однако любое значение, отличное от значения по умолчанию, будет. Если метод подкласса не реализует &lt;code&gt;keepdims&lt;/code&gt; , будут возникать исключения.</target>
        </trans-unit>
        <trans-unit id="e936312beb89ed94ea31f46b832a3128132ea8c3" translate="yes" xml:space="preserve">
          <source>If the default value is passed, then &lt;code&gt;keepdims&lt;/code&gt; will not be passed through to the &lt;a href=&quot;#numpy.mean&quot;&gt;&lt;code&gt;mean&lt;/code&gt;&lt;/a&gt; method of sub-classes of &lt;a href=&quot;numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;ndarray&lt;/code&gt;&lt;/a&gt;, however any non-default value will be. If the sub-class&amp;rsquo; method does not implement &lt;code&gt;keepdims&lt;/code&gt; any exceptions will be raised.</source>
          <target state="translated">Если передается значение по умолчанию, то &lt;code&gt;keepdims&lt;/code&gt; не будет передаваться &lt;a href=&quot;#numpy.mean&quot;&gt; &lt;code&gt;mean&lt;/code&gt; &lt;/a&gt; методу подклассов &lt;a href=&quot;numpy.ndarray#numpy.ndarray&quot;&gt; &lt;code&gt;ndarray&lt;/code&gt; &lt;/a&gt; , однако любое значение, отличное от значения по умолчанию, будет. Если метод подкласса не реализует &lt;code&gt;keepdims&lt;/code&gt; , будут возникать исключения.</target>
        </trans-unit>
        <trans-unit id="cccfcc112e296f9db67affb5426a407a1e1b1ab3" translate="yes" xml:space="preserve">
          <source>If the default value is passed, then &lt;code&gt;keepdims&lt;/code&gt; will not be passed through to the &lt;a href=&quot;#numpy.prod&quot;&gt;&lt;code&gt;prod&lt;/code&gt;&lt;/a&gt; method of sub-classes of &lt;a href=&quot;numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;ndarray&lt;/code&gt;&lt;/a&gt;, however any non-default value will be. If the sub-class&amp;rsquo; method does not implement &lt;code&gt;keepdims&lt;/code&gt; any exceptions will be raised.</source>
          <target state="translated">Если передается значение по умолчанию, то &lt;code&gt;keepdims&lt;/code&gt; не будут передаваться методу &lt;a href=&quot;#numpy.prod&quot;&gt; &lt;code&gt;prod&lt;/code&gt; &lt;/a&gt; подклассов &lt;a href=&quot;numpy.ndarray#numpy.ndarray&quot;&gt; &lt;code&gt;ndarray&lt;/code&gt; &lt;/a&gt; , однако любое значение, отличное от значения по умолчанию, будет. Если метод подкласса не реализует &lt;code&gt;keepdims&lt;/code&gt; , будут возникать исключения.</target>
        </trans-unit>
        <trans-unit id="f6aec8996590d19051796274c83c4f7439695ce8" translate="yes" xml:space="preserve">
          <source>If the default value is passed, then &lt;code&gt;keepdims&lt;/code&gt; will not be passed through to the &lt;a href=&quot;#numpy.ptp&quot;&gt;&lt;code&gt;ptp&lt;/code&gt;&lt;/a&gt; method of sub-classes of &lt;a href=&quot;numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;ndarray&lt;/code&gt;&lt;/a&gt;, however any non-default value will be. If the sub-class&amp;rsquo; method does not implement &lt;code&gt;keepdims&lt;/code&gt; any exceptions will be raised.</source>
          <target state="translated">Если передается значение по умолчанию, то &lt;code&gt;keepdims&lt;/code&gt; не будет передаваться в метод &lt;a href=&quot;#numpy.ptp&quot;&gt; &lt;code&gt;ptp&lt;/code&gt; &lt;/a&gt; подклассов &lt;a href=&quot;numpy.ndarray#numpy.ndarray&quot;&gt; &lt;code&gt;ndarray&lt;/code&gt; &lt;/a&gt; , однако любое значение, отличное от значения по умолчанию, будет. Если метод подкласса не реализует &lt;code&gt;keepdims&lt;/code&gt; , будут возникать исключения.</target>
        </trans-unit>
        <trans-unit id="04b4fba4bb9497e64959763e9e88bb419b385930" translate="yes" xml:space="preserve">
          <source>If the default value is passed, then &lt;code&gt;keepdims&lt;/code&gt; will not be passed through to the &lt;a href=&quot;#numpy.std&quot;&gt;&lt;code&gt;std&lt;/code&gt;&lt;/a&gt; method of sub-classes of &lt;a href=&quot;numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;ndarray&lt;/code&gt;&lt;/a&gt;, however any non-default value will be. If the sub-class&amp;rsquo; method does not implement &lt;code&gt;keepdims&lt;/code&gt; any exceptions will be raised.</source>
          <target state="translated">Если передается значение по умолчанию, то &lt;code&gt;keepdims&lt;/code&gt; не будут передаваться в метод &lt;a href=&quot;#numpy.std&quot;&gt; &lt;code&gt;std&lt;/code&gt; &lt;/a&gt; подклассов &lt;a href=&quot;numpy.ndarray#numpy.ndarray&quot;&gt; &lt;code&gt;ndarray&lt;/code&gt; &lt;/a&gt; , однако любое значение, отличное от значения по умолчанию, будет. Если метод подкласса не реализует &lt;code&gt;keepdims&lt;/code&gt; , будут возникать исключения.</target>
        </trans-unit>
        <trans-unit id="3ec6e98470abd2d3a8abe5e8029889dd09ba623f" translate="yes" xml:space="preserve">
          <source>If the default value is passed, then &lt;code&gt;keepdims&lt;/code&gt; will not be passed through to the &lt;a href=&quot;#numpy.sum&quot;&gt;&lt;code&gt;sum&lt;/code&gt;&lt;/a&gt; method of sub-classes of &lt;a href=&quot;numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;ndarray&lt;/code&gt;&lt;/a&gt;, however any non-default value will be. If the sub-class&amp;rsquo; method does not implement &lt;code&gt;keepdims&lt;/code&gt; any exceptions will be raised.</source>
          <target state="translated">Если передается значение по умолчанию, то &lt;code&gt;keepdims&lt;/code&gt; не будут переданы в метод &lt;a href=&quot;#numpy.sum&quot;&gt; &lt;code&gt;sum&lt;/code&gt; &lt;/a&gt; подклассов &lt;a href=&quot;numpy.ndarray#numpy.ndarray&quot;&gt; &lt;code&gt;ndarray&lt;/code&gt; &lt;/a&gt; , однако любое значение, отличное от значения по умолчанию, будет. Если метод подкласса не реализует &lt;code&gt;keepdims&lt;/code&gt; , будут возникать исключения.</target>
        </trans-unit>
        <trans-unit id="2d09798a597d9e0c839ab8917b5d5016554acbc8" translate="yes" xml:space="preserve">
          <source>If the default value is passed, then &lt;code&gt;keepdims&lt;/code&gt; will not be passed through to the &lt;a href=&quot;#numpy.var&quot;&gt;&lt;code&gt;var&lt;/code&gt;&lt;/a&gt; method of sub-classes of &lt;a href=&quot;numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;ndarray&lt;/code&gt;&lt;/a&gt;, however any non-default value will be. If the sub-class&amp;rsquo; method does not implement &lt;code&gt;keepdims&lt;/code&gt; any exceptions will be raised.</source>
          <target state="translated">Если передается значение по умолчанию, то &lt;code&gt;keepdims&lt;/code&gt; не будет передаваться в метод &lt;a href=&quot;#numpy.var&quot;&gt; &lt;code&gt;var&lt;/code&gt; &lt;/a&gt; подклассов &lt;a href=&quot;numpy.ndarray#numpy.ndarray&quot;&gt; &lt;code&gt;ndarray&lt;/code&gt; &lt;/a&gt; , однако любое значение, отличное от значения по умолчанию, будет. Если метод подкласса не реализует &lt;code&gt;keepdims&lt;/code&gt; , будут возникать исключения.</target>
        </trans-unit>
        <trans-unit id="83795d27b8fbf6727fc73ba1d3ba1433b7f48097" translate="yes" xml:space="preserve">
          <source>If the default value is passed, then &lt;code&gt;keepdims&lt;/code&gt; will not be passed through to the &lt;a href=&quot;numpy.ma.var#numpy.ma.var&quot;&gt;&lt;code&gt;var&lt;/code&gt;&lt;/a&gt; method of sub-classes of &lt;code&gt;ndarray&lt;/code&gt;, however any non-default value will be. If the sub-class&amp;rsquo; method does not implement &lt;code&gt;keepdims&lt;/code&gt; any exceptions will be raised.</source>
          <target state="translated">Если передается значение по умолчанию, то &lt;code&gt;keepdims&lt;/code&gt; не будет передаваться в метод &lt;a href=&quot;numpy.ma.var#numpy.ma.var&quot;&gt; &lt;code&gt;var&lt;/code&gt; &lt;/a&gt; подклассов &lt;code&gt;ndarray&lt;/code&gt; , однако любое значение, отличное от значения по умолчанию, будет. Если метод подкласса не реализует &lt;code&gt;keepdims&lt;/code&gt; , будут возникать исключения.</target>
        </trans-unit>
        <trans-unit id="f36f9bb6a297ac4fc949ef700d42398954026ba5" translate="yes" xml:space="preserve">
          <source>If the dimension of &lt;code&gt;a&lt;/code&gt; is less than 2.</source>
          <target state="translated">Если размер &lt;code&gt;a&lt;/code&gt; меньше 2.</target>
        </trans-unit>
        <trans-unit id="a923921d01ae62bb1aaf773e7e11bc37201f68aa" translate="yes" xml:space="preserve">
          <source>If the discontinuity in &lt;code&gt;p&lt;/code&gt; is smaller than &lt;code&gt;pi&lt;/code&gt;, but larger than &lt;code&gt;discont&lt;/code&gt;, no unwrapping is done because taking the 2*pi complement would only make the discontinuity larger.</source>
          <target state="translated">Если разрыв в &lt;code&gt;p&lt;/code&gt; меньше, чем &lt;code&gt;pi&lt;/code&gt; , но больше, чем &lt;code&gt;discont&lt;/code&gt; , разворачивание не производится, потому что взятие дополнения 2 * pi только увеличило бы разрыв.</target>
        </trans-unit>
        <trans-unit id="769e103ab2e97d0544e3e9203d0c4335be336adf" translate="yes" xml:space="preserve">
          <source>If the eigenvalue computation does not converge.</source>
          <target state="translated">Если вычисление собственного значения не сходится.</target>
        </trans-unit>
        <trans-unit id="ae5f5ebbdda43d87574658252f8456304a3e6d83" translate="yes" xml:space="preserve">
          <source>If the file contains pickle data, then whatever object is stored in the pickle is returned.</source>
          <target state="translated">Если файл содержит данные о пикуле,то возвращается объект,сохраненный в пикулете.</target>
        </trans-unit>
        <trans-unit id="52f9285704aeec7c0050eb73ae0eedae9e536c15" translate="yes" xml:space="preserve">
          <source>If the file is a &lt;code&gt;.npy&lt;/code&gt; file, then a single array is returned.</source>
          <target state="translated">Если файл является файлом &lt;code&gt;.npy&lt;/code&gt; , возвращается единственный массив.</target>
        </trans-unit>
        <trans-unit id="c850dbbea34f89942e452ade066952afb4aff87b" translate="yes" xml:space="preserve">
          <source>If the file is a &lt;code&gt;.npz&lt;/code&gt; file, the returned value supports the context manager protocol in a similar fashion to the open function:</source>
          <target state="translated">Если файл является файлом &lt;code&gt;.npz&lt;/code&gt; , возвращаемое значение поддерживает протокол диспетчера контекста аналогично функции open:</target>
        </trans-unit>
        <trans-unit id="6dd34773e8e6fce245333f3661e9174ce50590a5" translate="yes" xml:space="preserve">
          <source>If the file is a &lt;code&gt;.npz&lt;/code&gt; file, then a dictionary-like object is returned, containing &lt;code&gt;{filename: array}&lt;/code&gt; key-value pairs, one for each file in the archive.</source>
          <target state="translated">Если файл является файлом &lt;code&gt;.npz&lt;/code&gt; , то возвращается объект, подобный словарю, содержащий пары ключ-значение &lt;code&gt;{filename: array}&lt;/code&gt; , по одной для каждого файла в архиве.</target>
        </trans-unit>
        <trans-unit id="3eb136618e35fc45bcfb6109a519b0397c62a7f3" translate="yes" xml:space="preserve">
          <source>If the filename ends in &lt;code&gt;.gz&lt;/code&gt;, the file is automatically saved in compressed gzip format. &lt;a href=&quot;numpy.loadtxt#numpy.loadtxt&quot;&gt;&lt;code&gt;loadtxt&lt;/code&gt;&lt;/a&gt; understands gzipped files transparently.</source>
          <target state="translated">Если имя файла заканчивается на &lt;code&gt;.gz&lt;/code&gt; , файл автоматически сохраняется в сжатом формате gzip. &lt;a href=&quot;numpy.loadtxt#numpy.loadtxt&quot;&gt; &lt;code&gt;loadtxt&lt;/code&gt; &lt;/a&gt; понимает файлы с gzip'нутыми прозрачно.</target>
        </trans-unit>
        <trans-unit id="3cd5e67735dce4fe85460703c53dc9836515a450" translate="yes" xml:space="preserve">
          <source>If the first argument is 1-D it is treated as a row vector. If the last argument is 1-D it is treated as a column vector. The other arguments must be 2-D.</source>
          <target state="translated">Если первым аргументом является 1-D,то он рассматривается как строковый вектор.Если последним аргументом является 1-D,то он обрабатывается как вектор столбца.Остальные аргументы должны быть 2-D.</target>
        </trans-unit>
        <trans-unit id="02ed5193bd3dcf84d786340881fcb3d577ef57f7" translate="yes" xml:space="preserve">
          <source>If the first argument is 1-D it is treated as row vector. If the last argument is 1-D it is treated as column vector. The other arguments must be 2-D.</source>
          <target state="translated">Если первым аргументом является 1-D,то он обрабатывается как строковый вектор.Если последним аргументом является 1-D,то он обрабатывается как вектор столбца.Остальные аргументы должны быть 2-D.</target>
        </trans-unit>
        <trans-unit id="0a74c0a74431c3bd3b43bf07934fe3d61fd80338" translate="yes" xml:space="preserve">
          <source>If the first argument is 1-D, it is promoted to a matrix by prepending a 1 to its dimensions. After matrix multiplication the prepended 1 is removed.</source>
          <target state="translated">Если первым аргументом является 1-D,то он переходит в матрицу,преобразуя 1 в ее размеры.После умножения матрицы префикс 1 удаляется.</target>
        </trans-unit>
        <trans-unit id="89db4e5dab2cb1ce35a7fb31edd3413095e85f3c" translate="yes" xml:space="preserve">
          <source>If the first argument is a tuple, other arguments are ignored:</source>
          <target state="translated">Если первым аргументом является кортеж,другие аргументы игнорируются:</target>
        </trans-unit>
        <trans-unit id="727e22f05290aaa6c2959157d7df0bc582e3c538" translate="yes" xml:space="preserve">
          <source>If the following equation is element-wise True, then &lt;a href=&quot;#numpy.ma.allclose&quot;&gt;&lt;code&gt;allclose&lt;/code&gt;&lt;/a&gt; returns True:</source>
          <target state="translated">Если следующее уравнение поэлементно &lt;a href=&quot;#numpy.ma.allclose&quot;&gt; &lt;code&gt;allclose&lt;/code&gt; &lt;/a&gt; , то allclose возвращает True:</target>
        </trans-unit>
        <trans-unit id="94cbab458f248cbb972811c2359461201e9861d5" translate="yes" xml:space="preserve">
          <source>If the following equation is element-wise True, then allclose returns True.</source>
          <target state="translated">Если следующее уравнение является element-wise True,то Allclose возвращает True.</target>
        </trans-unit>
        <trans-unit id="1386561a26e41c95c312db50b7ef52259e4517da" translate="yes" xml:space="preserve">
          <source>If the given strings are equal, &lt;a href=&quot;#numpy.testing.assert_string_equal&quot;&gt;&lt;code&gt;assert_string_equal&lt;/code&gt;&lt;/a&gt; does nothing. If they are not equal, an AssertionError is raised, and the diff between the strings is shown.</source>
          <target state="translated">Если указанные строки равны, &lt;a href=&quot;#numpy.testing.assert_string_equal&quot;&gt; &lt;code&gt;assert_string_equal&lt;/code&gt; &lt;/a&gt; ничего не делает. Если они не равны, возникает ошибка AssertionError и отображается разница между строками.</target>
        </trans-unit>
        <trans-unit id="f5f5e437a85f1a89c55d54e0a09b57161df68a13" translate="yes" xml:space="preserve">
          <source>If the header file that contains the prototype for &lt;code&gt;double dot()&lt;/code&gt; also contains other prototypes that you want to wrap, so that you need to &lt;code&gt;%include&lt;/code&gt; this header file, then you will also need a &lt;code&gt;%ignore
dot;&lt;/code&gt; directive, placed after the &lt;code&gt;%rename&lt;/code&gt; and before the &lt;code&gt;%include&lt;/code&gt; directives. Or, if the function in question is a class method, you will want to use &lt;code&gt;%extend&lt;/code&gt; rather than &lt;code&gt;%inline&lt;/code&gt; in addition to &lt;code&gt;%ignore&lt;/code&gt;.</source>
          <target state="translated">Если файл заголовка, содержащий прототип для &lt;code&gt;double dot()&lt;/code&gt; также содержит другие прототипы, которые вы хотите обернуть, так что вам нужно &lt;code&gt;%include&lt;/code&gt; этот файл заголовка, тогда вам также понадобится &lt;code&gt;%ignore dot;&lt;/code&gt; после директивы &lt;code&gt;%rename&lt;/code&gt; и перед директивами &lt;code&gt;%include&lt;/code&gt; . Или, если рассматриваемая функция является методом класса, вы захотите использовать &lt;code&gt;%extend&lt;/code&gt; вместо &lt;code&gt;%inline&lt;/code&gt; в дополнение к &lt;code&gt;%ignore&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f745354786d48a61873aeb74a86c334de5c7a7b4" translate="yes" xml:space="preserve">
          <source>If the index expression contains comma separated arrays, then stack them along their first axis.</source>
          <target state="translated">Если выражение индекса содержит массивы,разделенные запятыми,то укладывайте их по первой оси.</target>
        </trans-unit>
        <trans-unit id="34ad012e6ac2224c1d99e1fa90fb54c844437b0d" translate="yes" xml:space="preserve">
          <source>If the index expression contains slice notation or scalars then create a 1-D array with a range indicated by the slice notation.</source>
          <target state="translated">Если индексное выражение содержит нотацию среза или скаляры,то создается 1-D массив с диапазоном,указанным нотацией среза.</target>
        </trans-unit>
        <trans-unit id="70dea339f55810f6be3e1b0c9e7aefd88107ebbf" translate="yes" xml:space="preserve">
          <source>If the input &lt;code&gt;a&lt;/code&gt; contains an imaginary part, it is silently discarded.</source>
          <target state="translated">Если вход &lt;code&gt;a&lt;/code&gt; содержит мнимую часть, она автоматически отбрасывается.</target>
        </trans-unit>
        <trans-unit id="4637e99d70ef2c1cb40679370ac10807b840a3f4" translate="yes" xml:space="preserve">
          <source>If the input file does not exist or cannot be read.</source>
          <target state="translated">Если входной файл не существует или не может быть прочитан.</target>
        </trans-unit>
        <trans-unit id="bbf06b38d2758769a67207876edd570ca41378d4" translate="yes" xml:space="preserve">
          <source>If the input has a integer type the function is equivalent to np.max.</source>
          <target state="translated">Если вход имеет целочисленный тип,то функция эквивалентна np.max.</target>
        </trans-unit>
        <trans-unit id="7895a434c9eeafd563766c2013458a9eca1c5fea" translate="yes" xml:space="preserve">
          <source>If the input has a integer type the function is equivalent to np.min.</source>
          <target state="translated">Если вход имеет целочисленный тип,то функция эквивалентна np.min.</target>
        </trans-unit>
        <trans-unit id="b307c09a45c4aabb639976a619f0171d6a01d0dd" translate="yes" xml:space="preserve">
          <source>If the input is 2d and axis is specified, the result is a list of lists.</source>
          <target state="translated">Если вход 2d и указана ось,то в результате получается список списков.</target>
        </trans-unit>
        <trans-unit id="7ed38fa8c8d2f0a335bd5a040aeda16b9d1b796e" translate="yes" xml:space="preserve">
          <source>If the input is not 1-dimensional, or contains elements with negative values, or if &lt;code&gt;minlength&lt;/code&gt; is negative.</source>
          <target state="translated">Если входные данные не одномерные, или содержат элементы с отрицательными значениями, или если &lt;code&gt;minlength&lt;/code&gt; отрицательное значение.</target>
        </trans-unit>
        <trans-unit id="10296cda117e24158759559beefea304129412f0" translate="yes" xml:space="preserve">
          <source>If the input parameter &lt;code&gt;n&lt;/code&gt; is larger than the size of the input, the input is padded by appending zeros at the end. Even though this is the common approach, it might lead to surprising results. If a different padding is desired, it must be performed before calling &lt;a href=&quot;#numpy.fft.ifft&quot;&gt;&lt;code&gt;ifft&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Если входной параметр &lt;code&gt;n&lt;/code&gt; больше, чем размер входных данных, входные данные дополняются добавлением нулей в конце. Несмотря на то, что это обычный подход, он может привести к неожиданным результатам. Если требуется другое заполнение, его необходимо выполнить перед вызовом &lt;a href=&quot;#numpy.fft.ifft&quot;&gt; &lt;code&gt;ifft&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="3fc060b3dda78a5634929550749227bb1804a61d" translate="yes" xml:space="preserve">
          <source>If the inputs are ndarrays, then np.greater is equivalent to &amp;lsquo;&amp;gt;&amp;rsquo;.</source>
          <target state="translated">Если входные данные - ndarrays, то np.greater эквивалентно '&amp;gt;'.</target>
        </trans-unit>
        <trans-unit id="36e6b94197e7b6e49557830166101a92fecb27ad" translate="yes" xml:space="preserve">
          <source>If the inputs or dtype are complex, the output will follow a logarithmic spiral in the complex plane. (There are an infinite number of spirals passing through two points; the output will follow the shortest such path.)</source>
          <target state="translated">Если входы или тип d являются сложными,то выход будет следовать логарифмической спирали в комплексной плоскости.(Существует бесконечное количество спиралей,проходящих через две точки;выход будет идти по кратчайшему такому пути).</target>
        </trans-unit>
        <trans-unit id="ce8f1e8f63cbe617564d9cd3d7c5c8bc3e2530ae" translate="yes" xml:space="preserve">
          <source>If the iterator is buffered, returns the size of the buffer being used, otherwise returns 0.</source>
          <target state="translated">Если итератор буферизован,возвращает размер используемого буфера,в противном случае возвращает 0.</target>
        </trans-unit>
        <trans-unit id="f3c918834625c8823bdade73b25f11346749b818" translate="yes" xml:space="preserve">
          <source>If the iterator is tracking a multi-index, this strips support for them, and does further iterator optimizations that are possible if multi-indices are not needed. This function also resets the iterator to its initial state.</source>
          <target state="translated">Если итератор отслеживает мультииндекс,то этот полоска поддерживает его,и делает дальнейшие оптимизации итератора,которые возможны,если мультииндексы не нужны.Эта функция также сбрасывает итератор в начальное состояние.</target>
        </trans-unit>
        <trans-unit id="7df15990c36906ed5503360d9305db9b7bfe762b" translate="yes" xml:space="preserve">
          <source>If the last dimension of &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; has different size.</source>
          <target state="translated">Если последний размер &lt;code&gt;a&lt;/code&gt; и &lt;code&gt;b&lt;/code&gt; имеет разный размер.</target>
        </trans-unit>
        <trans-unit id="5f26098ec8a9cbafe4e4d839766540a822d41056" translate="yes" xml:space="preserve">
          <source>If the last dimension of &lt;code&gt;a&lt;/code&gt; is not the same size as the second-to-last dimension of &lt;code&gt;b&lt;/code&gt;.</source>
          <target state="translated">Если последнее измерение &lt;code&gt;a&lt;/code&gt; не того же размера, что и предпоследнее измерение &lt;code&gt;b&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2fd0d252831ab8d15d091d4ef1abf6e28cded875" translate="yes" xml:space="preserve">
          <source>If the masked array has named fields, accessing a single entry returns a &lt;code&gt;numpy.void&lt;/code&gt; object if none of the fields are masked, or a 0d masked array with the same dtype as the initial array if at least one of the fields is masked.</source>
          <target state="translated">Если замаскированный массив имеет именованные поля, доступ к одной записи возвращает объект &lt;code&gt;numpy.void&lt;/code&gt; , если ни одно из полей не замаскировано, или замаскированный массив 0d с тем же dtype, что и исходный массив, если хотя бы одно из полей замаскировано.</target>
        </trans-unit>
        <trans-unit id="510c4eb8a3d20ab4214058c75f9744c994e75f43" translate="yes" xml:space="preserve">
          <source>If the mode is constant filling (NPY_NEIGHBORHOOD_ITER_CONSTANT_PADDING), fill_value should point to an array object which holds the filling value (the first item will be the filling value if the array contains more than one item). For other cases, fill_value may be NULL.</source>
          <target state="translated">Если режим является константным заполнением (NPY_NEIGHBORHOOD_ITER_CONSTANT_PADDING),значение fill_value должно указывать на объект массива,который содержит значение заливки (первым элементом будет значение заливки,если массив содержит более одного элемента).В остальных случаях значение fill_value может быть NULL.</target>
        </trans-unit>
        <trans-unit id="be7395567c47ed030147671e19ef0b8f24978bfe" translate="yes" xml:space="preserve">
          <source>If the name is suffixed with the &amp;ldquo;?&amp;rdquo; modifier, the dimension is a core dimension only if it exists on all inputs and outputs that share it; otherwise it is ignored (and replaced by a dimension of size 1 for the elementary function).</source>
          <target state="translated">Если к имени добавлен суффикс &amp;laquo;?&amp;raquo; модификатор, измерение является основным измерением, только если оно существует на всех входах и выходах, которые его разделяют; в противном случае он игнорируется (и заменяется размером 1 для элементарной функции).</target>
        </trans-unit>
        <trans-unit id="c3d1c518bb585ba44b9ba4aaf335820db98fa4f5" translate="yes" xml:space="preserve">
          <source>If the new array is larger than the original array, then the new array is filled with repeated copies of &lt;code&gt;a&lt;/code&gt;. Note that this behavior is different from a.resize(new_shape) which fills with zeros instead of repeated copies of &lt;code&gt;a&lt;/code&gt;.</source>
          <target state="translated">Если новый массив больше , чем исходный массив, то новый массив заполняется с повторяющимися копиями . Обратите внимание, что это поведение отличается от a.resize (new_shape), который заполняется нулями вместо повторяющихся копий &lt;code&gt;a&lt;/code&gt; . &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="b5041b424abd93910d43bf1d34adce8cb0f61f85" translate="yes" xml:space="preserve">
          <source>If the number of objects in the selection tuple is less than &lt;em&gt;N&lt;/em&gt; , then &lt;code&gt;:&lt;/code&gt; is assumed for any subsequent dimensions.</source>
          <target state="translated">Если количество объектов в выбранном кортеже меньше &lt;em&gt;N&lt;/em&gt; , то &lt;code&gt;:&lt;/code&gt; предполагается для любых последующих измерений.</target>
        </trans-unit>
        <trans-unit id="c5a6c4456ec6f4292b9cf18dc4d579bb22a84db3" translate="yes" xml:space="preserve">
          <source>If the object provided is an array, this function traverses the chain of &lt;code&gt;base&lt;/code&gt; pointers so that each array points to the owner of the memory directly. Once the base is set, it may not be changed to another value.</source>
          <target state="translated">Если предоставленный объект является массивом, эта функция просматривает цепочку &lt;code&gt;base&lt;/code&gt; указателей, так что каждый массив указывает непосредственно на владельца памяти. После установки базы ее нельзя изменить на другое значение.</target>
        </trans-unit>
        <trans-unit id="657e1806ea99b60e1959c9ce313bdaa2fd70aa64" translate="yes" xml:space="preserve">
          <source>If the operand is flagged as write-only and a copy is needed, an uninitialized temporary array will be created and then copied to back to &lt;code&gt;op[i]&lt;/code&gt; on calling &lt;code&gt;NpyIter_Deallocate&lt;/code&gt;, instead of doing the unnecessary copy operation.</source>
          <target state="translated">Если операнд помечен как доступный только для записи и требуется копия, будет создан неинициализированный временный массив, который затем скопируется обратно в &lt;code&gt;op[i]&lt;/code&gt; при вызове &lt;code&gt;NpyIter_Deallocate&lt;/code&gt; вместо выполнения ненужной операции копирования.</target>
        </trans-unit>
        <trans-unit id="17f4400245338f1e4a33ed23afc91ef7ab8c40c6" translate="yes" xml:space="preserve">
          <source>If the optional argument &lt;a href=&quot;numpy.char.count#numpy.char.count&quot;&gt;&lt;code&gt;count&lt;/code&gt;&lt;/a&gt; is given, only the first &lt;a href=&quot;numpy.char.count#numpy.char.count&quot;&gt;&lt;code&gt;count&lt;/code&gt;&lt;/a&gt; occurrences are replaced.</source>
          <target state="translated">Если указан необязательный аргумент &lt;a href=&quot;numpy.char.count#numpy.char.count&quot;&gt; &lt;code&gt;count&lt;/code&gt; &lt;/a&gt; , заменяются только первые вхождения &lt;a href=&quot;numpy.char.count#numpy.char.count&quot;&gt; &lt;code&gt;count&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="2ad175da47137fbc79b21402b2a0b69af4d4bc0f" translate="yes" xml:space="preserve">
          <source>If the position of iter is changed, any subsequent call to PyArrayNeighborhoodIter_Next is undefined behavior, and PyArrayNeighborhoodIter_Reset must be called.</source>
          <target state="translated">Если позиция итера изменена,то любой последующий вызов PyArrayNeighborhoodIter_Next является неопределенным поведением,и PyArrayNeighborhoodIter_Reset должен быть вызван.</target>
        </trans-unit>
        <trans-unit id="8c927b8ff30da3cc5f4b149881b61cbe3118f463" translate="yes" xml:space="preserve">
          <source>If the requested data type is in non-native byte order, the NBO flag overrides it and the requested data type is converted to be in native byte order.</source>
          <target state="translated">Если запрашиваемый тип данных находится в неродном порядке байт,флаг NBO переопределяет его,и запрашиваемый тип данных преобразуется в родной порядок байт.</target>
        </trans-unit>
        <trans-unit id="8a5c6764b6f67871837f5bb9b64736c18fe7a7ad" translate="yes" xml:space="preserve">
          <source>If the returned coefficients are &lt;code&gt;c&lt;/code&gt;, then</source>
          <target state="translated">Если возвращенные коэффициенты равны &lt;code&gt;c&lt;/code&gt; , то</target>
        </trans-unit>
        <trans-unit id="054023bbbbd71a4d456dd16da82bfb709a02f2cc" translate="yes" xml:space="preserve">
          <source>If the second argument is 1-D, it is promoted to a matrix by appending a 1 to its dimensions. After matrix multiplication the appended 1 is removed.</source>
          <target state="translated">Если второй аргумент равен 1-D,то он продвигается к матрице путем добавления 1 к ее размерам.После умножения матрицы добавляемая 1 удаляется.</target>
        </trans-unit>
        <trans-unit id="b4b38312a537fa220f815af5dcf5f4139bad3681" translate="yes" xml:space="preserve">
          <source>If the selection tuple has all entries &lt;code&gt;:&lt;/code&gt; except the &lt;em&gt;p&lt;/em&gt;-th entry which is a slice object &lt;code&gt;i:j:k&lt;/code&gt;, then the returned array has dimension &lt;em&gt;N&lt;/em&gt; formed by concatenating the sub-arrays returned by integer indexing of elements &lt;em&gt;i&lt;/em&gt;, &lt;em&gt;i+k&lt;/em&gt;, &amp;hellip;, &lt;em&gt;i + (m - 1) k &amp;lt; j&lt;/em&gt;,</source>
          <target state="translated">Если в кортеже выбора есть все записи &lt;code&gt;:&lt;/code&gt; кроме &lt;em&gt;p&lt;/em&gt; -й записи, которая является объектом среза &lt;code&gt;i:j:k&lt;/code&gt; , то возвращаемый массив имеет размерность &lt;em&gt;N,&lt;/em&gt; сформированную путем объединения подмассивов, возвращаемых целочисленной индексацией элементов &lt;em&gt;i&lt;/em&gt; , &lt;em&gt;i + k&lt;/em&gt; ,&amp;hellip;, &lt;em&gt;I + (m - 1) k &amp;lt;j&lt;/em&gt; ,</target>
        </trans-unit>
        <trans-unit id="9a652cfa7a533eb64735eb374de6f3a4977f5b9c" translate="yes" xml:space="preserve">
          <source>If the spacing between &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; for one or more elements is larger than &lt;code&gt;nulp&lt;/code&gt;.</source>
          <target state="translated">Если интервал между &lt;code&gt;x&lt;/code&gt; и &lt;code&gt;y&lt;/code&gt; для одного или нескольких элементов больше, чем &lt;code&gt;nulp&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3600ee510b36714644dcc89a19bb177b5b6c4ba7" translate="yes" xml:space="preserve">
          <source>If the string is not the correct size to satisfy the requested &lt;a href=&quot;numpy.dtype#numpy.dtype&quot;&gt;&lt;code&gt;dtype&lt;/code&gt;&lt;/a&gt; and &lt;code&gt;count&lt;/code&gt;.</source>
          <target state="translated">Если размер строки не соответствует требуемому &lt;a href=&quot;numpy.dtype#numpy.dtype&quot;&gt; &lt;code&gt;dtype&lt;/code&gt; &lt;/a&gt; и &lt;code&gt;count&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ebc3886c14d49cd40506d4084002663f28dbcdd3" translate="yes" xml:space="preserve">
          <source>If the type of &lt;code&gt;x&lt;/code&gt; is unsigned, then the output type is the unsigned platform integer:</source>
          <target state="translated">Если тип &lt;code&gt;x&lt;/code&gt; беззнаковый, то тип вывода - беззнаковое платформенное целое:</target>
        </trans-unit>
        <trans-unit id="183bc4d9ba8fd4894a95c0f09db6946e16642c92" translate="yes" xml:space="preserve">
          <source>If the type of the input is complex.</source>
          <target state="translated">Если тип входа сложный.</target>
        </trans-unit>
        <trans-unit id="95366e62fbbbe64ba41cdcaa0c22be8d3f384cd4" translate="yes" xml:space="preserve">
          <source>If the type of the input is float or complex.</source>
          <target state="translated">Если тип входа плавающий или сложный.</target>
        </trans-unit>
        <trans-unit id="25291949b6396c31462d4c34b8e8b5c2797cb90a" translate="yes" xml:space="preserve">
          <source>If the ufunc has 2 inputs and 1 output and the second input is an Object array then a special-case check is performed so that NotImplemented is returned if the second input is not an ndarray, has the __array_priority__ attribute, and has an __r{op}__ special method. In this way, Python is signaled to give the other object a chance to complete the operation instead of using generic object-array calculations. This allows (for example) sparse matrices to override the multiplication operator 1-D loop.</source>
          <target state="translated">Если ufunc имеет 2 входа и 1 выход,а второй вход является массивом Object,то выполняется специальная проверка,чтобы NotImplemented возвращался,если второй вход не является ndarray,имеет атрибут __array_priority__,и имеет специальный метод __r{op}__.Таким образом,Python получает сигнал для того,чтобы дать другому объекту возможность завершить операцию вместо использования общих вычислений объект-массив.Это позволяет (например)разреженным матрицам переопределить цикл 1-D оператора умножения.</target>
        </trans-unit>
        <trans-unit id="a4dffd94a98e9a9ee0037afd472e661e6232061e" translate="yes" xml:space="preserve">
          <source>If the underlying data is a subclass of &lt;a href=&quot;generated/numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;numpy.ndarray&lt;/code&gt;&lt;/a&gt;, it is returned as such.</source>
          <target state="translated">Если базовые данные являются подклассом &lt;a href=&quot;generated/numpy.ndarray#numpy.ndarray&quot;&gt; &lt;code&gt;numpy.ndarray&lt;/code&gt; &lt;/a&gt; , они возвращаются как таковые.</target>
        </trans-unit>
        <trans-unit id="23122d3c8d35684d3c1d392886f730d15f172384" translate="yes" xml:space="preserve">
          <source>If the value is anything but the default, then &lt;code&gt;keepdims&lt;/code&gt; will be passed through to the &lt;a href=&quot;https://docs.python.org/dev/library/functions.html#max&quot;&gt;&lt;code&gt;max&lt;/code&gt;&lt;/a&gt; method of sub-classes of &lt;a href=&quot;numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;ndarray&lt;/code&gt;&lt;/a&gt;. If the sub-classes methods does not implement &lt;code&gt;keepdims&lt;/code&gt; any exceptions will be raised.</source>
          <target state="translated">Если значение отличается от значения по умолчанию, то &lt;code&gt;keepdims&lt;/code&gt; будет передан методу &lt;a href=&quot;https://docs.python.org/dev/library/functions.html#max&quot;&gt; &lt;code&gt;max&lt;/code&gt; &lt;/a&gt; подклассов &lt;a href=&quot;numpy.ndarray#numpy.ndarray&quot;&gt; &lt;code&gt;ndarray&lt;/code&gt; &lt;/a&gt; . Если методы подкласса не реализуют &lt;code&gt;keepdims&lt;/code&gt; , будут возникать исключения.</target>
        </trans-unit>
        <trans-unit id="2abfa832de7674bd2d08ad1f7e2b845f18a0059c" translate="yes" xml:space="preserve">
          <source>If the value is anything but the default, then &lt;code&gt;keepdims&lt;/code&gt; will be passed through to the &lt;a href=&quot;https://docs.python.org/dev/library/functions.html#min&quot;&gt;&lt;code&gt;min&lt;/code&gt;&lt;/a&gt; method of sub-classes of &lt;a href=&quot;numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;ndarray&lt;/code&gt;&lt;/a&gt;. If the sub-classes methods does not implement &lt;code&gt;keepdims&lt;/code&gt; any exceptions will be raised.</source>
          <target state="translated">Если значение отличается от значения по умолчанию, то &lt;code&gt;keepdims&lt;/code&gt; будут переданы методу &lt;a href=&quot;https://docs.python.org/dev/library/functions.html#min&quot;&gt; &lt;code&gt;min&lt;/code&gt; &lt;/a&gt; подклассов &lt;a href=&quot;numpy.ndarray#numpy.ndarray&quot;&gt; &lt;code&gt;ndarray&lt;/code&gt; &lt;/a&gt; . Если методы подкласса не реализуют &lt;code&gt;keepdims&lt;/code&gt; , будут возникать исключения.</target>
        </trans-unit>
        <trans-unit id="fb8acc52d13221f0fba6edb05a42e80cbebd0a2e" translate="yes" xml:space="preserve">
          <source>If the value is anything but the default, then &lt;code&gt;keepdims&lt;/code&gt; will be passed through to the &lt;a href=&quot;numpy.mean#numpy.mean&quot;&gt;&lt;code&gt;mean&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;numpy.sum#numpy.sum&quot;&gt;&lt;code&gt;sum&lt;/code&gt;&lt;/a&gt; methods of sub-classes of &lt;a href=&quot;numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;ndarray&lt;/code&gt;&lt;/a&gt;. If the sub-classes methods does not implement &lt;code&gt;keepdims&lt;/code&gt; any exceptions will be raised.</source>
          <target state="translated">Если значение не является значением по умолчанию, то &lt;code&gt;keepdims&lt;/code&gt; будут переданы в методы &lt;a href=&quot;numpy.mean#numpy.mean&quot;&gt; &lt;code&gt;mean&lt;/code&gt; &lt;/a&gt; или &lt;a href=&quot;numpy.sum#numpy.sum&quot;&gt; &lt;code&gt;sum&lt;/code&gt; &lt;/a&gt; подклассов &lt;a href=&quot;numpy.ndarray#numpy.ndarray&quot;&gt; &lt;code&gt;ndarray&lt;/code&gt; &lt;/a&gt; . Если методы подкласса не реализуют &lt;code&gt;keepdims&lt;/code&gt; , будут возникать исключения.</target>
        </trans-unit>
        <trans-unit id="33c6901ff2ee0db95c77f2b313983f44526bb314" translate="yes" xml:space="preserve">
          <source>If there are only scalars or the maximum category of the scalars is higher than the maximum category of the arrays, the data types are combined with &lt;a href=&quot;#c.PyArray_PromoteTypes&quot;&gt;&lt;code&gt;PyArray_PromoteTypes&lt;/code&gt;&lt;/a&gt; to produce the return value.</source>
          <target state="translated">Если есть только скаляры или максимальная категория скаляров выше, чем максимальная категория массивов, типы данных объединяются с &lt;a href=&quot;#c.PyArray_PromoteTypes&quot;&gt; &lt;code&gt;PyArray_PromoteTypes&lt;/code&gt; &lt;/a&gt; для получения возвращаемого значения.</target>
        </trans-unit>
        <trans-unit id="33fe4c771f7142c020971d30614039b35a541395" translate="yes" xml:space="preserve">
          <source>If there are only scalars or the maximum category of the scalars is higher than the maximum category of the arrays, the data types are combined with &lt;a href=&quot;numpy.promote_types#numpy.promote_types&quot;&gt;&lt;code&gt;promote_types&lt;/code&gt;&lt;/a&gt; to produce the return value.</source>
          <target state="translated">Если есть только скаляры или максимальная категория скаляров выше, чем максимальная категория массивов, типы данных объединяются с &lt;a href=&quot;numpy.promote_types#numpy.promote_types&quot;&gt; &lt;code&gt;promote_types&lt;/code&gt; &lt;/a&gt; для получения возвращаемого значения.</target>
        </trans-unit>
        <trans-unit id="d0c11d30de5e96bdaa85cb78bb53dddd3ba03ebc" translate="yes" xml:space="preserve">
          <source>If there is no library with the expected extension, or the library is defective and cannot be loaded.</source>
          <target state="translated">Если нет библиотеки с ожидаемым расширением,или библиотека неисправна и не может быть загружена.</target>
        </trans-unit>
        <trans-unit id="ef27bb26cd9e20ec5eb81bab137d2b6e00a224b0" translate="yes" xml:space="preserve">
          <source>If there is only one Boolean array and no integer indexing array present, this is straight forward. Care must only be taken to make sure that the boolean index has &lt;em&gt;exactly&lt;/em&gt; as many dimensions as it is supposed to work with.</source>
          <target state="translated">Если есть только один логический массив и нет целочисленного массива индексации, это просто. Следует позаботиться только о том, чтобы логический индекс имел &lt;em&gt;ровно&lt;/em&gt; столько измерений , с которыми он должен работать.</target>
        </trans-unit>
        <trans-unit id="6e268d3c7b0192c893825d9fa07e4e49b28360ad" translate="yes" xml:space="preserve">
          <source>If these arrays are all collected in a structured array, then &lt;a href=&quot;#c.PyArray_Sort&quot;&gt;&lt;code&gt;PyArray_Sort&lt;/code&gt;&lt;/a&gt; (&amp;hellip;) can also be used to sort the array directly.</source>
          <target state="translated">Если все эти массивы собраны в структурированный массив, тогда &lt;a href=&quot;#c.PyArray_Sort&quot;&gt; &lt;code&gt;PyArray_Sort&lt;/code&gt; &lt;/a&gt; (&amp;hellip;) также можно использовать для сортировки массива напрямую.</target>
        </trans-unit>
        <trans-unit id="4b5797d27d90ecc738ae241c7f2d88131ab4d780" translate="yes" xml:space="preserve">
          <source>If these conditions hold, &lt;code&gt;__array_function__&lt;/code&gt; should return the result from calling its implementation for &lt;code&gt;func(*args, **kwargs)&lt;/code&gt;. Otherwise, it should return the sentinel value &lt;code&gt;NotImplemented&lt;/code&gt;, indicating that the function is not implemented by these types.</source>
          <target state="translated">Если эти условия выполняются, &lt;code&gt;__array_function__&lt;/code&gt; должна вернуть результат вызова своей реализации для &lt;code&gt;func(*args, **kwargs)&lt;/code&gt; . В противном случае он должен вернуть контрольное значение &lt;code&gt;NotImplemented&lt;/code&gt; , указывающее, что функция не реализована этими типами.</target>
        </trans-unit>
        <trans-unit id="c80ca8262eeedd9bef78dbd28fb2dc07a4582c48" translate="yes" xml:space="preserve">
          <source>If this array does not own its own memory, then base points to the Python object that owns it (perhaps another array object)</source>
          <target state="translated">Если этот массив не владеет собственной памятью,то база указывает на объект Python,которому он принадлежит (возможно,другой объект массива)</target>
        </trans-unit>
        <trans-unit id="f63b91f81d86b6356e230f230ee7da044adca895" translate="yes" xml:space="preserve">
          <source>If this array has the (deprecated) &lt;a href=&quot;c-api.array#c.NPY_ARRAY_UPDATEIFCOPY&quot;&gt;&lt;code&gt;NPY_ARRAY_UPDATEIFCOPY&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;c-api.array#c.NPY_ARRAY_WRITEBACKIFCOPY&quot;&gt;&lt;code&gt;NPY_ARRAY_WRITEBACKIFCOPY&lt;/code&gt;&lt;/a&gt; flag set, then this array is a working copy of a &amp;ldquo;misbehaved&amp;rdquo; array.</source>
          <target state="translated">Если в этом массиве установлен (устаревший) &lt;a href=&quot;c-api.array#c.NPY_ARRAY_UPDATEIFCOPY&quot;&gt; &lt;code&gt;NPY_ARRAY_UPDATEIFCOPY&lt;/code&gt; &lt;/a&gt; или &lt;a href=&quot;c-api.array#c.NPY_ARRAY_WRITEBACKIFCOPY&quot;&gt; &lt;code&gt;NPY_ARRAY_WRITEBACKIFCOPY&lt;/code&gt; &lt;/a&gt; , то этот массив является рабочей копией массива с &amp;laquo;неправильным поведением&amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="b54640e63d198f32f1e8358a28ce29bc6179e6f7" translate="yes" xml:space="preserve">
          <source>If this function returns true, the caller should also check the inner loop stride of the operand, because if that stride is 0, then only the first element of the innermost external loop is being visited for the first time.</source>
          <target state="translated">Если эта функция возвращает true,то вызывающий абонент должен также проверить внутренний шаблон цикла операнда,так как если этот шаблон равен 0,то в первый раз посещается только первый элемент внутреннего самого внешнего цикла.</target>
        </trans-unit>
        <trans-unit id="24a22c06faef1b4b61f295517b88ec97d1fc0a84" translate="yes" xml:space="preserve">
          <source>If this is &lt;code&gt;None&lt;/code&gt;, a reduction is performed over all the axes. If this is a tuple of ints, a reduction is performed on multiple axes, instead of a single axis or all the axes as before.</source>
          <target state="translated">Если это &lt;code&gt;None&lt;/code&gt; , сокращение выполняется по всем осям. Если это кортеж целых чисел, сокращение выполняется по нескольким осям, а не по одной оси или по всем осям, как раньше.</target>
        </trans-unit>
        <trans-unit id="e4599c6e53b844db2376ed9e56ed7b49e63c6ec3" translate="yes" xml:space="preserve">
          <source>If this is a tuple of ints, a mean is performed over multiple axes, instead of a single axis or all the axes as before.</source>
          <target state="translated">Если это кортеж из интв,то среднее значение выполняется по нескольким осям,а не по одной оси или по всем осям,как раньше.</target>
        </trans-unit>
        <trans-unit id="04767d2c5f5bbd4aab7323a751a31f226739a396" translate="yes" xml:space="preserve">
          <source>If this is a tuple of ints, a reduction is performed on multiple axes, instead of a single axis or all the axes as before.</source>
          <target state="translated">Если это кортеж из интвейнов,то вместо одной оси или всех осей,как раньше,выполняется уменьшение по нескольким осям.</target>
        </trans-unit>
        <trans-unit id="e11ec2c8b461dd6b1390de16d518719c4d72ce55" translate="yes" xml:space="preserve">
          <source>If this is a tuple of ints, a standard deviation is performed over multiple axes, instead of a single axis or all the axes as before.</source>
          <target state="translated">Если это кортеж из интв,то стандартное отклонение выполняется по нескольким осям,а не по одной оси или по всем осям,как раньше.</target>
        </trans-unit>
        <trans-unit id="cdec667610de13f7517139e9ece6f88d2d290194" translate="yes" xml:space="preserve">
          <source>If this is a tuple of ints, a variance is performed over multiple axes, instead of a single axis or all the axes as before.</source>
          <target state="translated">Если это кортеж из интв,то дисперсия выполняется по нескольким осям,а не по одной оси или по всем осям,как раньше.</target>
        </trans-unit>
        <trans-unit id="d50012ee6c384ff0215bab7085fcf98c562bc452" translate="yes" xml:space="preserve">
          <source>If this is a tuple of ints, the count is performed on multiple axes, instead of a single axis or all the axes as before.</source>
          <target state="translated">Если это кортеж из интв,то подсчет производится по нескольким осям,а не по одной оси или по всем осям,как раньше.</target>
        </trans-unit>
        <trans-unit id="c674e367c6b1c23d3abf3ddc4c5a7a14ff593b5a" translate="yes" xml:space="preserve">
          <source>If this is a tuple of ints, the maximum is selected over multiple axes, instead of a single axis or all the axes as before.</source>
          <target state="translated">Если это кортеж из интв,то максимум выбирается по нескольким осям,а не по одной оси или по всем осям,как раньше.</target>
        </trans-unit>
        <trans-unit id="a0756a48081a9a9cb1bfbc79e9843f0007e55c1d" translate="yes" xml:space="preserve">
          <source>If this is a tuple of ints, the minimum is selected over multiple axes, instead of a single axis or all the axes as before.</source>
          <target state="translated">Если это кортеж из нескольких осей,то вместо одной оси или всех осей,как раньше,выбирается минимальный уровень.</target>
        </trans-unit>
        <trans-unit id="7573da3ff564f7261e16d53ba17d4d7c25b6abc9" translate="yes" xml:space="preserve">
          <source>If this is anything but the default value it will be passed through (in the special case of an empty array) to the &lt;a href=&quot;numpy.mean#numpy.mean&quot;&gt;&lt;code&gt;mean&lt;/code&gt;&lt;/a&gt; function of the underlying array. If the array is a sub-class and &lt;a href=&quot;numpy.mean#numpy.mean&quot;&gt;&lt;code&gt;mean&lt;/code&gt;&lt;/a&gt; does not have the kwarg &lt;code&gt;keepdims&lt;/code&gt; this will raise a RuntimeError.</source>
          <target state="translated">Если это что-то, кроме значения по умолчанию, оно будет передано (в особом случае пустого массива) в &lt;a href=&quot;numpy.mean#numpy.mean&quot;&gt; &lt;code&gt;mean&lt;/code&gt; &lt;/a&gt; функцию базового массива. Если массив является подклассом и у &lt;a href=&quot;numpy.mean#numpy.mean&quot;&gt; &lt;code&gt;mean&lt;/code&gt; &lt;/a&gt; нет kwarg &lt;code&gt;keepdims&lt;/code&gt; , это вызовет RuntimeError.</target>
        </trans-unit>
        <trans-unit id="9eef22bd67c15e89cde5d92734a40aa76d92e691" translate="yes" xml:space="preserve">
          <source>If this is non- &lt;code&gt;NULL&lt;/code&gt;, then this data-type descriptor is a C-style contiguous array of another data-type descriptor. In other-words, each element that this descriptor describes is actually an array of some other base descriptor. This is most useful as the data-type descriptor for a field in another data-type descriptor. The fields member should be &lt;code&gt;NULL&lt;/code&gt; if this is non- &lt;code&gt;NULL&lt;/code&gt; (the fields member of the base descriptor can be non- &lt;code&gt;NULL&lt;/code&gt; however). The &lt;code&gt;PyArray_ArrayDescr&lt;/code&gt; structure is defined using</source>
          <target state="translated">Если это не &lt;code&gt;NULL&lt;/code&gt; , то этот дескриптор типа данных является непрерывным массивом в стиле C другого дескриптора типа данных. Другими словами, каждый элемент, описываемый этим дескриптором, на самом деле является массивом какого-то другого базового дескриптора. Это наиболее полезно в качестве дескриптора типа данных для поля в другом дескрипторе типа данных. Член fields должен иметь &lt;code&gt;NULL&lt;/code&gt; если он не равен &lt;code&gt;NULL&lt;/code&gt; ( однако член fields базового дескриптора может быть не &lt;code&gt;NULL&lt;/code&gt; ). Структура &lt;code&gt;PyArray_ArrayDescr&lt;/code&gt; определяется с использованием</target>
        </trans-unit>
        <trans-unit id="2824d770011e81edcc48aaca00be40fe5064246e" translate="yes" xml:space="preserve">
          <source>If this is non-NULL, then this data-type-descriptor has fields described by a Python dictionary whose keys are names (and also titles if given) and whose values are tuples that describe the fields. Recall that a data-type-descriptor always describes a fixed-length set of bytes. A field is a named sub-region of that total, fixed-length collection. A field is described by a tuple composed of another data- type-descriptor and a byte offset. Optionally, the tuple may contain a title which is normally a Python string. These tuples are placed in this dictionary keyed by name (and also title if given).</source>
          <target state="translated">Если это не NULL,то этот скриптор типа данных имеет поля,описываемые словарем Python,ключами которого являются имена (а также заголовки,если они заданы),и значения которых являются кортежами,описывающими поля.Напомним,что скриптор типа данных всегда описывает набор байтов фиксированной длины.Поле-это названный подрегион этой общей коллекции фиксированной длины.Поле описывается кортежом,состоящим из другого скриптора типа данных и смещения байтов.Дополнительно кортеж может содержать заголовок,который обычно представляет собой питоновую строку.Эти кортежи помещаются в этот словарь с ключом по имени (а также по заголовку,если он задан).</target>
        </trans-unit>
        <trans-unit id="0d86cba4ba7294ed9f7338e68f7b4f37b35c1557" translate="yes" xml:space="preserve">
          <source>If this is not desirable, then the array should be cast to a larger integer type first:</source>
          <target state="translated">Если это нежелательно,то сначала массив должен быть приведен к большему целочисленному типу:</target>
        </trans-unit>
        <trans-unit id="1ae38fd1d446748062bddf73d4866a0b315e1322" translate="yes" xml:space="preserve">
          <source>If this is set to &lt;code&gt;True&lt;/code&gt;, axes which are reduced over will be left in the result as a dimension with size one, so that the result will broadcast correctly against the inputs. This option can only be used for generalized ufuncs that operate on inputs that all have the same number of core dimensions and with outputs that have no core dimensions , i.e., with signatures like &lt;code&gt;(i),(i)-&amp;gt;()&lt;/code&gt; or &lt;code&gt;(m,m)-&amp;gt;()&lt;/code&gt;. If used, the location of the dimensions in the output can be controlled with &lt;code&gt;axes&lt;/code&gt; and &lt;code&gt;axis&lt;/code&gt;.</source>
          <target state="translated">Если для этого параметра установлено значение &lt;code&gt;True&lt;/code&gt; , уменьшенные оси останутся в результате как размер с размером один, так что результат будет правильно транслироваться по входам. Эту опцию можно использовать только для обобщенных функций ufunc, которые работают с входами, которые имеют одинаковое количество размеров ядра, и с выходами, не имеющими размеров ядра, то есть с сигнатурами типа &lt;code&gt;(i),(i)-&amp;gt;()&lt;/code&gt; или &lt;code&gt;(m,m)-&amp;gt;()&lt;/code&gt; . Если используется, расположение размеров на выходе можно контролировать с помощью &lt;code&gt;axes&lt;/code&gt; и &lt;code&gt;axis&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="74585a8bd339c6874f448a64d5fe0ba3642c10c6" translate="yes" xml:space="preserve">
          <source>If this is set to True, the axes which are normed over are left in the result as dimensions with size one. With this option the result will broadcast correctly against the original &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="translated">Если установлено значение True, оси, которые нормированы, останутся в результате как размеры с размером один. С этой опцией результат будет транслироваться правильно относительно исходного &lt;code&gt;x&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="526b620d34688cc0c68a7ee67814781d453388f5" translate="yes" xml:space="preserve">
          <source>If this is set to True, the axes which are reduced are left in the result as dimensions with size one. With this option, the result will broadcast correctly against the array.</source>
          <target state="translated">Если установлено значение True,то редуцированные оси останутся в результате в виде размеров с первым размером.При выборе этой опции результат будет корректно транслироваться по массиву.</target>
        </trans-unit>
        <trans-unit id="015e500928e7c3f86f2c9b5121c746246fcd7a9f" translate="yes" xml:space="preserve">
          <source>If this is set to True, the axes which are reduced are left in the result as dimensions with size one. With this option, the result will broadcast correctly against the input array.</source>
          <target state="translated">Если установлено значение True,то редуцированные оси останутся в результате в виде размеров с первым размером.При выборе этого параметра результат будет корректно отображаться на входном массиве.</target>
        </trans-unit>
        <trans-unit id="caf30df07a09579107c0faa5c9aaad9ad8721644" translate="yes" xml:space="preserve">
          <source>If this is set to True, the axes which are reduced are left in the result as dimensions with size one. With this option, the result will broadcast correctly against the original &lt;code&gt;a&lt;/code&gt;.</source>
          <target state="translated">Если установлено значение True, уменьшенные оси останутся в результате как размеры с размером один. С этой опцией результат будет правильно транслироваться относительно оригинала &lt;code&gt;a&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="668624d9e02d10dc8924733d51742fcc1923286c" translate="yes" xml:space="preserve">
          <source>If this is set to True, the axes which are reduced are left in the result as dimensions with size one. With this option, the result will broadcast correctly against the original &lt;code&gt;arr&lt;/code&gt;.</source>
          <target state="translated">Если установлено значение True, уменьшенные оси останутся в результате как размеры с размером один. С этой опцией результат будет транслироваться правильно относительно исходного &lt;code&gt;arr&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="813c59426f99f6e2035686f0669f18c79ec2fc97" translate="yes" xml:space="preserve">
          <source>If this is set to True, the axes which are reduced are left in the result as dimensions with size one. With this option, the result will broadcast correctly against the original array &lt;code&gt;a&lt;/code&gt;.</source>
          <target state="translated">Если установлено значение True, уменьшенные оси останутся в результате как размеры с размером один. С этой опцией результат будет правильно транслироваться против исходного массива &lt;code&gt;a&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="28e1fe971ad9fdc32699e38250e14da5caf0bb91" translate="yes" xml:space="preserve">
          <source>If this value is anything but the default it is passed through as-is to the relevant functions of the sub-classes. If these functions do not have a &lt;code&gt;keepdims&lt;/code&gt; kwarg, a RuntimeError will be raised.</source>
          <target state="translated">Если это значение не является значением по умолчанию, оно передается как есть соответствующим функциям подклассов. Если у этих функций нет &lt;code&gt;keepdims&lt;/code&gt; keepdims, будет вызвана ошибка RuntimeError.</target>
        </trans-unit>
        <trans-unit id="dd4ec2a983c899a1017fcabb86ae5785ce4793ab" translate="yes" xml:space="preserve">
          <source>If true (default), then the object is copied. Otherwise, a copy will only be made if __array__ returns a copy, if obj is a nested sequence, or if a copy is needed to satisfy any of the other requirements (&lt;a href=&quot;numpy.dtype#numpy.dtype&quot;&gt;&lt;code&gt;dtype&lt;/code&gt;&lt;/a&gt;, &lt;code&gt;order&lt;/code&gt;, etc.).</source>
          <target state="translated">Если true (по умолчанию), то объект копируется. В противном случае копия будет сделана только в том случае, если __array__ вернет копию, если obj является вложенной последовательностью или если копия необходима для удовлетворения любого из других требований ( &lt;a href=&quot;numpy.dtype#numpy.dtype&quot;&gt; &lt;code&gt;dtype&lt;/code&gt; &lt;/a&gt; , &lt;code&gt;order&lt;/code&gt; и т. Д.).</target>
        </trans-unit>
        <trans-unit id="a6f5f638d5dadad294989835332dc69ea08c7e48" translate="yes" xml:space="preserve">
          <source>If true (default), then the object is copied. Otherwise, a copy will only be made if __array__ returns a copy, if obj is a nested sequence, or if a copy is needed to satisfy any of the other requirements (&lt;code&gt;itemsize&lt;/code&gt;, unicode, &lt;code&gt;order&lt;/code&gt;, etc.).</source>
          <target state="translated">Если true (по умолчанию), то объект копируется. В противном случае копия будет сделана только в том случае, если __array__ вернет копию, если obj является вложенной последовательностью или если копия необходима для удовлетворения любого из других требований ( &lt;code&gt;itemsize&lt;/code&gt; , юникод, &lt;code&gt;order&lt;/code&gt; и т. Д.).</target>
        </trans-unit>
        <trans-unit id="7cfded7f1f4f8985525752f730c915f025bbc3bd" translate="yes" xml:space="preserve">
          <source>If true, &lt;code&gt;stop&lt;/code&gt; is the last sample. Otherwise, it is not included. Default is True.</source>
          <target state="translated">Если true, &lt;code&gt;stop&lt;/code&gt; - это последняя выборка. В противном случае он не включается. По умолчанию True.</target>
        </trans-unit>
        <trans-unit id="89363179f510b5ee9e2706f4cf949aff38e269d9" translate="yes" xml:space="preserve">
          <source>If true, sample from the interval [low, high] instead of the default [low, high) Defaults to False</source>
          <target state="translated">Если верно,сэмпл из интервала [низкий,высокий]вместо значения по умолчанию [низкий,высокий]По умолчанию False</target>
        </trans-unit>
        <trans-unit id="3ef0d38b764385bc39d70e5ad26d095da7b5d3f0" translate="yes" xml:space="preserve">
          <source>If used with &lt;a href=&quot;#c.NPY_ITER_EXTERNAL_LOOP&quot;&gt;&lt;code&gt;NPY_ITER_EXTERNAL_LOOP&lt;/code&gt;&lt;/a&gt;, the inner loop for the caller may get larger chunks than would be possible without buffering, because of how the strides are laid out.</source>
          <target state="translated">При использовании с &lt;a href=&quot;#c.NPY_ITER_EXTERNAL_LOOP&quot;&gt; &lt;code&gt;NPY_ITER_EXTERNAL_LOOP&lt;/code&gt; &lt;/a&gt; внутренний цикл для вызывающего может получить более крупные фрагменты, чем это было бы возможно без буферизации, из-за того, как расположены шаги.</target>
        </trans-unit>
        <trans-unit id="e6e87a78ddc8c45866e59f696a01a91d82f291c2" translate="yes" xml:space="preserve">
          <source>If values in &lt;code&gt;x&lt;/code&gt; are beyond the bounds of &lt;code&gt;bins&lt;/code&gt;, 0 or &lt;code&gt;len(bins)&lt;/code&gt; is returned as appropriate.</source>
          <target state="translated">Если значения в &lt;code&gt;x&lt;/code&gt; выходят за пределы &lt;code&gt;bins&lt;/code&gt; , соответственно возвращается 0 или &lt;code&gt;len(bins)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="adc126c0d80d4b8b968260ca8a9cd270dc0bc84e" translate="yes" xml:space="preserve">
          <source>If values in &lt;code&gt;x&lt;/code&gt; are such that they fall outside the bin range, attempting to index &lt;code&gt;bins&lt;/code&gt; with the indices that &lt;a href=&quot;#numpy.digitize&quot;&gt;&lt;code&gt;digitize&lt;/code&gt;&lt;/a&gt; returns will result in an IndexError.</source>
          <target state="translated">Если значения в &lt;code&gt;x&lt;/code&gt; таковы, что они выходят за пределы диапазона ячеек , попытка индексировать &lt;code&gt;bins&lt;/code&gt; с индексами, которые &lt;a href=&quot;#numpy.digitize&quot;&gt; &lt;code&gt;digitize&lt;/code&gt; &lt;/a&gt; возврат, приведет к IndexError.</target>
        </trans-unit>
        <trans-unit id="b223152b4e60f22e3efa048a66b57e829307cf69" translate="yes" xml:space="preserve">
          <source>If we designed &lt;code&gt;rms&lt;/code&gt;, we probably made it a routine that takes an input-only array of length &lt;code&gt;n&lt;/code&gt; of &lt;code&gt;double&lt;/code&gt; values called &lt;code&gt;seq&lt;/code&gt; and returns the root mean square. The default behavior of &lt;a href=&quot;http://www.swig.org&quot;&gt;SWIG&lt;/a&gt;, however, will be to create a wrapper function that compiles, but is nearly impossible to use from the scripting language in the way the C routine was intended.</source>
          <target state="translated">Если мы разработали &lt;code&gt;rms&lt;/code&gt; , мы , вероятно , сделали это процедуру , которая принимает входной только массив длины &lt;code&gt;n&lt;/code&gt; от &lt;code&gt;double&lt;/code&gt; значений , называемых &lt;code&gt;seq&lt;/code&gt; и возвращает среднеквадратичное. Однако поведение &lt;a href=&quot;http://www.swig.org&quot;&gt;SWIG по&lt;/a&gt; умолчанию будет заключаться в создании функции-оболочки, которая компилируется, но ее почти невозможно использовать из языка сценариев так, как была задумана процедура C.</target>
        </trans-unit>
        <trans-unit id="be3492efc8039f75947121fd3b30a1fa61841ee0" translate="yes" xml:space="preserve">
          <source>If we want to get the max and min at the same time, we can stack the indices first</source>
          <target state="translated">Если мы хотим получить максимальное и минимальное значение одновременно,то сначала мы можем сложить индексы.</target>
        </trans-unit>
        <trans-unit id="0b08db0a15b738091c43209c89bb138ad98fa1a5" translate="yes" xml:space="preserve">
          <source>If writing to the value in &amp;lsquo;op&amp;rsquo; is desired, set the boolean &amp;lsquo;writeable&amp;rsquo; to 1. This raises an error when &amp;lsquo;op&amp;rsquo; is a scalar, list of lists, or other non-writeable &amp;lsquo;op&amp;rsquo;. This differs from passing &lt;a href=&quot;#c.NPY_ARRAY_WRITEABLE&quot;&gt;&lt;code&gt;NPY_ARRAY_WRITEABLE&lt;/code&gt;&lt;/a&gt; to PyArray_FromAny, where the writeable array may be a copy of the input.</source>
          <target state="translated">Если требуется запись в значение в 'op', установите логическое 'writeable' в 1. Это вызывает ошибку, если 'op' является скаляром, списком списков или другим не-записываемым 'op'. Это отличается от передачи &lt;a href=&quot;#c.NPY_ARRAY_WRITEABLE&quot;&gt; &lt;code&gt;NPY_ARRAY_WRITEABLE&lt;/code&gt; &lt;/a&gt; в PyArray_FromAny, где записываемый массив может быть копией ввода.</target>
        </trans-unit>
        <trans-unit id="df553e5d4398ed0e4dcd8bdb41c75c9a32748a9c" translate="yes" xml:space="preserve">
          <source>If you are constructing an array using the C API, and specifying your own memory, you should use the function &lt;a href=&quot;#c.PyArray_SetBaseObject&quot;&gt;&lt;code&gt;PyArray_SetBaseObject&lt;/code&gt;&lt;/a&gt; to set the base to an object which owns the memory.</source>
          <target state="translated">Если вы создаете массив с помощью C API и указываете свою собственную память, вам следует использовать функцию &lt;a href=&quot;#c.PyArray_SetBaseObject&quot;&gt; &lt;code&gt;PyArray_SetBaseObject&lt;/code&gt; ,&lt;/a&gt; чтобы установить базу для объекта, которому принадлежит память.</target>
        </trans-unit>
        <trans-unit id="39a6add3139de0ce389e24494d0e34b85d48e6cd" translate="yes" xml:space="preserve">
          <source>If you are not a subclass of &lt;a href=&quot;generated/numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;ndarray&lt;/code&gt;&lt;/a&gt;, we recommend your class define special methods like &lt;code&gt;__add__&lt;/code&gt; and &lt;code&gt;__lt__&lt;/code&gt; that delegate to ufuncs just like ndarray does. An easy way to do this is to subclass from &lt;a href=&quot;generated/numpy.lib.mixins.ndarrayoperatorsmixin#numpy.lib.mixins.NDArrayOperatorsMixin&quot;&gt;&lt;code&gt;NDArrayOperatorsMixin&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Если вы не являетесь подклассом &lt;a href=&quot;generated/numpy.ndarray#numpy.ndarray&quot;&gt; &lt;code&gt;ndarray&lt;/code&gt; &lt;/a&gt; , мы рекомендуем вашему классу определить специальные методы, такие как &lt;code&gt;__add__&lt;/code&gt; и &lt;code&gt;__lt__&lt;/code&gt; , которые делегируют ufuncs, как это делает ndarray. Легкий способ сделать это - &lt;a href=&quot;generated/numpy.lib.mixins.ndarrayoperatorsmixin#numpy.lib.mixins.NDArrayOperatorsMixin&quot;&gt; &lt;code&gt;NDArrayOperatorsMixin&lt;/code&gt; &lt;/a&gt; подкласс от NDArrayOperatorsMixin .</target>
        </trans-unit>
        <trans-unit id="50d785ffa376c738acba9fd3062d7ce8c3507854" translate="yes" xml:space="preserve">
          <source>If you construct an array by passing in your own memory buffer as a parameter, you need to set the array&amp;rsquo;s &lt;code&gt;base&lt;/code&gt; property to ensure the lifetime of the memory buffer is appropriate.</source>
          <target state="translated">Если вы создаете массив, передавая свой собственный буфер памяти в качестве параметра, вам необходимо установить &lt;code&gt;base&lt;/code&gt; свойство массива, чтобы гарантировать подходящее время жизни буфера памяти.</target>
        </trans-unit>
        <trans-unit id="72ea524f17d30ae2b5b06f8b246da402ecc0aab1" translate="yes" xml:space="preserve">
          <source>If you define &lt;code&gt;__array_ufunc__&lt;/code&gt;:</source>
          <target state="translated">Если вы определяете &lt;code&gt;__array_ufunc__&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="ad02ce8758b2b7ef1353b5d6ceccf301d0d32341" translate="yes" xml:space="preserve">
          <source>If you depend on the current behavior, then we suggest copying the returned array explicitly, i.e., use &lt;code&gt;np.diagonal(a).copy()&lt;/code&gt; instead of just &lt;code&gt;np.diagonal(a)&lt;/code&gt;. This will work with both past and future versions of NumPy.</source>
          <target state="translated">Если вы зависите от текущего поведения, мы предлагаем явно скопировать возвращаемый массив, т. &lt;code&gt;np.diagonal(a).copy()&lt;/code&gt; Использовать np.diagonal (a) .copy () вместо просто &lt;code&gt;np.diagonal(a)&lt;/code&gt; . Это будет работать как с прошлыми, так и с будущими версиями NumPy.</target>
        </trans-unit>
        <trans-unit id="48d4a9d3c1a910573f5c99d8162fc661353211a4" translate="yes" xml:space="preserve">
          <source>If you do want to use Fortran ordering realize that there are two approaches to consider: 1) accept that the first index is just not the most rapidly changing in memory and have all your I/O routines reorder your data when going from memory to disk or visa versa, or use numpy&amp;rsquo;s mechanism for mapping the first index to the most rapidly varying data. We recommend the former if possible. The disadvantage of the latter is that many of numpy&amp;rsquo;s functions will yield arrays without Fortran ordering unless you are careful to use the &amp;lsquo;order&amp;rsquo; keyword. Doing this would be highly inconvenient.</source>
          <target state="translated">Если вы действительно хотите использовать упорядочивание в Фортране, осознайте, что есть два подхода, которые следует учитывать: 1) принять, что первый индекс просто не является самым быстро изменяющимся в памяти, и пусть все ваши процедуры ввода-вывода переупорядочивают ваши данные при переходе из памяти на диск или наоборот, или использовать механизм numpy для сопоставления первого индекса с наиболее быстро меняющимися данными. Если возможно, мы рекомендуем первое. Недостатком последнего является то, что многие функции numpy будут давать массивы без упорядочивания в Фортране, если вы не используете ключевое слово order. Это было бы очень неудобно.</target>
        </trans-unit>
        <trans-unit id="00332ddab35edaceba6aacb138a662dde934bdb6" translate="yes" xml:space="preserve">
          <source>If you don&amp;rsquo;t write to the array returned by this function, then you can just ignore all of the above.</source>
          <target state="translated">Если вы не пишете в массив, возвращаемый этой функцией, вы можете просто проигнорировать все вышеперечисленное.</target>
        </trans-unit>
        <trans-unit id="fe80a2730dc1732963891b3491f20ea69996dc7b" translate="yes" xml:space="preserve">
          <source>If you get a Python error that looks like the following:</source>
          <target state="translated">Если вы получите ошибку на Пайтоне,которая выглядит следующим образом:</target>
        </trans-unit>
        <trans-unit id="a53df4d5bfbd08adf0a5725999a9e0795dcb81f8" translate="yes" xml:space="preserve">
          <source>If you have a collection of tests that must be run multiple times with minor variations, it can be helpful to create a base class containing all the common tests, and then create a subclass for each variation. Several examples of this technique exist in NumPy; below are excerpts from one in &lt;a href=&quot;https://github.com/numpy/numpy/blob/master/numpy/linalg/tests/test_linalg.py&quot;&gt;numpy/linalg/tests/test_linalg.py&lt;/a&gt;:</source>
          <target state="translated">Если у вас есть набор тестов, которые необходимо запускать несколько раз с небольшими вариациями, может быть полезно создать базовый класс, содержащий все общие тесты, а затем создать подкласс для каждого варианта. Несколько примеров этой техники существует в NumPy; ниже приведены выдержки из одного &lt;a href=&quot;https://github.com/numpy/numpy/blob/master/numpy/linalg/tests/test_linalg.py&quot;&gt;файла&lt;/a&gt; в numpy / linalg / tests / test_linalg.py :</target>
        </trans-unit>
        <trans-unit id="edd73a9e41446ceec5844edddba90601c9a86d6a" translate="yes" xml:space="preserve">
          <source>If you have an array of datetime64 day values, and you want a count of how many of them are valid dates, you can do this:</source>
          <target state="translated">Если у вас есть массив значений datetime64 day,и вы хотите посчитать,сколько из них действительных дат,то вы можете это сделать:</target>
        </trans-unit>
        <trans-unit id="6b620559920ae0493b1df8c4590d21b79ff5570f" translate="yes" xml:space="preserve">
          <source>If you need to generate a good seed &amp;ldquo;offline&amp;rdquo;, then &lt;code&gt;SeedSequence().entropy&lt;/code&gt; or using &lt;code&gt;secrets.randbits(128)&lt;/code&gt; from the standard library are both convenient ways.</source>
          <target state="translated">Если вам нужно сгенерировать хорошее начальное число &amp;laquo;в автономном режиме&amp;raquo;, то &lt;code&gt;SeedSequence().entropy&lt;/code&gt; &lt;code&gt;secrets.randbits(128)&lt;/code&gt; или secrets.randbits (128) из стандартной библиотеки.</target>
        </trans-unit>
        <trans-unit id="fafc92af92f970e1f9bc871b99562e2a4dcbfd58" translate="yes" xml:space="preserve">
          <source>If you only had $150/month to pay towards the loan, how long would it take to pay-off a loan of $8,000 at 7% annual interest?</source>
          <target state="translated">Если бы у вас было только 150 долларов в месяц на погашение кредита,сколько бы времени потребовалось на погашение кредита в размере 8000 долларов под 7% годовых?</target>
        </trans-unit>
        <trans-unit id="c2f8a5ed085feb6d7cb818c6bb6a9239c65b61dd" translate="yes" xml:space="preserve">
          <source>If you run into a situation where a function or method is returning a pointer to an array, your best bet is to write your own version of the function to be wrapped, either with &lt;code&gt;%extend&lt;/code&gt; for the case of class methods or &lt;code&gt;%ignore&lt;/code&gt; and &lt;code&gt;%rename&lt;/code&gt; for the case of functions.</source>
          <target state="translated">Если вы столкнулись с ситуацией, когда функция или метод возвращает указатель на массив, лучше всего написать свою собственную версию функции, которая должна быть обернута, либо с &lt;code&gt;%extend&lt;/code&gt; для метода класса, либо с &lt;code&gt;%ignore&lt;/code&gt; и &lt;code&gt;%rename&lt;/code&gt; для случая функций.</target>
        </trans-unit>
        <trans-unit id="c084a3f2a6106a54039205662cc0565194fa0738" translate="yes" xml:space="preserve">
          <source>If you specify an &lt;code&gt;n&lt;/code&gt; such that &lt;code&gt;a&lt;/code&gt; must be zero-padded or truncated, the extra/removed values will be added/removed at high frequencies. One can thus resample a series to &lt;code&gt;m&lt;/code&gt; points via Fourier interpolation by: &lt;code&gt;a_resamp = irfft(rfft(a), m)&lt;/code&gt;.</source>
          <target state="translated">Если вы укажете &lt;code&gt;n&lt;/code&gt; так , что &lt;code&gt;a&lt;/code&gt; должно быть дополнено нулями или усечено, дополнительные / удаленные значения будут добавляться / удаляться с высокой частотой. Таким образом, можно передискретизировать ряд до &lt;code&gt;m&lt;/code&gt; точек с помощью интерполяции Фурье следующим образом: &lt;code&gt;a_resamp = irfft(rfft(a), m)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="777d1be2db0dc4450d7b4eef96ddf2f8d5888d83" translate="yes" xml:space="preserve">
          <source>If you subclass &lt;a href=&quot;generated/numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;ndarray&lt;/code&gt;&lt;/a&gt;, we recommend that you put all your override logic in &lt;code&gt;__array_ufunc__&lt;/code&gt; and not also override special methods. This ensures the class hierarchy is determined in only one place rather than separately by the ufunc machinery and by the binary operation rules (which gives preference to special methods of subclasses; the alternative way to enforce a one-place only hierarchy, of setting &lt;a href=&quot;#numpy.class.__array_ufunc__&quot;&gt;&lt;code&gt;__array_ufunc__&lt;/code&gt;&lt;/a&gt; to &lt;a href=&quot;https://docs.python.org/dev/library/constants.html#None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt;, would seem very unexpected and thus confusing, as then the subclass would not work at all with ufuncs).</source>
          <target state="translated">Если вы &lt;a href=&quot;generated/numpy.ndarray#numpy.ndarray&quot;&gt; &lt;code&gt;ndarray&lt;/code&gt; &lt;/a&gt; подкласс ndarray , мы рекомендуем вам поместить всю вашу логику переопределения в &lt;code&gt;__array_ufunc__&lt;/code&gt; , а также не переопределять специальные методы. Это гарантирует, что иерархия классов определяется только в одном месте, а не по отдельности механизмом ufunc и правилами бинарных операций (которые отдают предпочтение специальным методам подклассов; альтернативный способ принудительного применения иерархии только в одном месте, установка &lt;a href=&quot;#numpy.class.__array_ufunc__&quot;&gt; &lt;code&gt;__array_ufunc__&lt;/code&gt; &lt;/a&gt; на &lt;a href=&quot;https://docs.python.org/dev/library/constants.html#None&quot;&gt; &lt;code&gt;None&lt;/code&gt; &lt;/a&gt; , это могло бы показаться очень неожиданным и, таким образом, сбивающим с толку, поскольку тогда подкласс вообще не работал бы с ufuncs).</target>
        </trans-unit>
        <trans-unit id="205839ed0e5eb197529b1363e1bb132c099c8dee" translate="yes" xml:space="preserve">
          <source>If you want to edit an array with aligned &lt;code&gt;double&lt;/code&gt; code, but the order doesn&amp;rsquo;t matter, you would use this.</source>
          <target state="translated">Если вы хотите отредактировать массив с выровненным &lt;code&gt;double&lt;/code&gt; кодом, но порядок не имеет значения, вы должны использовать это.</target>
        </trans-unit>
        <trans-unit id="0c1156594a53dfa7f56ad636c35e9f1ff1d1bf58" translate="yes" xml:space="preserve">
          <source>If you want to reset both the &lt;code&gt;iterindex&lt;/code&gt; range and the base pointers at the same time, you can do the following to avoid extra buffer copying (be sure to add the return code error checks when you copy this code).</source>
          <target state="translated">Если вы хотите сбросить и диапазон &lt;code&gt;iterindex&lt;/code&gt; , и базовые указатели одновременно, вы можете сделать следующее, чтобы избежать дополнительного копирования буфера (не забудьте добавить проверки ошибок кода возврата при копировании этого кода).</target>
        </trans-unit>
        <trans-unit id="c323f3cd6a35ba341fff7e94a4d83cd135d073a2" translate="yes" xml:space="preserve">
          <source>Ignoring extreme values</source>
          <target state="translated">Игнорирование экстремальных значений</target>
        </trans-unit>
        <trans-unit id="d887ce439b6be40447269f7cc275bae88c7965c1" translate="yes" xml:space="preserve">
          <source>Illustration image: &lt;a href=&quot;https://en.wikipedia.org/wiki/File:Composite_trapezoidal_rule_illustration.png&quot;&gt;https://en.wikipedia.org/wiki/File:Composite_trapezoidal_rule_illustration.png&lt;/a&gt;</source>
          <target state="translated">Изображение иллюстрации: &lt;a href=&quot;https://en.wikipedia.org/wiki/File:Composite_trapezoidal_rule_illustration.png&quot;&gt;https://en.wikipedia.org/wiki/File:Composite_trapezoidal_rule_illustration.png&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="8dc5a9232d67823e896b05855151653c2378fa30" translate="yes" xml:space="preserve">
          <source>Illustration, using the fact that the eigenvalues of a diagonal matrix are its diagonal elements, that multiplying a matrix on the left by an orthogonal matrix, &lt;code&gt;Q&lt;/code&gt;, and on the right by &lt;code&gt;Q.T&lt;/code&gt; (the transpose of &lt;code&gt;Q&lt;/code&gt;), preserves the eigenvalues of the &amp;ldquo;middle&amp;rdquo; matrix. In other words, if &lt;code&gt;Q&lt;/code&gt; is orthogonal, then &lt;code&gt;Q * A * Q.T&lt;/code&gt; has the same eigenvalues as &lt;code&gt;A&lt;/code&gt;:</source>
          <target state="translated">Иллюстрация, использующая тот факт, что собственные значения диагональной матрицы являются ее диагональными элементами, что умножение матрицы слева на ортогональную матрицу &lt;code&gt;Q&lt;/code&gt; и справа на &lt;code&gt;Q.T&lt;/code&gt; (транспонирование &lt;code&gt;Q&lt;/code&gt; ) сохраняет собственные значения матрицы &amp;ldquo; средняя &amp;raquo;матрица. Другими словами, если &lt;code&gt;Q&lt;/code&gt; ортогонален, то &lt;code&gt;Q * A * Q.T&lt;/code&gt; имеет те же собственные значения, что и &lt;code&gt;A&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="aa91fcf02d0f861f5dcc65de755f413adabac4c5" translate="yes" xml:space="preserve">
          <source>Illustration:</source>
          <target state="translated">Illustration:</target>
        </trans-unit>
        <trans-unit id="536fc5481730660eaf684050e171a85c03ce521a" translate="yes" xml:space="preserve">
          <source>Image &lt;a href=&quot;#r7aa6c77779c0-2&quot; id=&quot;id1&quot;&gt;[2]&lt;/a&gt; illustrates trapezoidal rule &amp;ndash; y-axis locations of points will be taken from &lt;code&gt;y&lt;/code&gt; array, by default x-axis distances between points will be 1.0, alternatively they can be provided with &lt;code&gt;x&lt;/code&gt; array or with &lt;code&gt;dx&lt;/code&gt; scalar. Return value will be equal to combined area under the red lines.</source>
          <target state="translated">Изображение &lt;a href=&quot;#r7aa6c77779c0-2&quot; id=&quot;id1&quot;&gt;[2]&lt;/a&gt; иллюстрирует правило трапеции - положения точек по оси Y будут взяты из массива &lt;code&gt;y&lt;/code&gt; , по умолчанию расстояния между точками по оси X будут равны 1.0, в качестве альтернативы они могут быть предоставлены с помощью массива &lt;code&gt;x&lt;/code&gt; или скаляра &lt;code&gt;dx&lt;/code&gt; . Возвращаемое значение будет равно объединенной области под красными линиями.</target>
        </trans-unit>
        <trans-unit id="9d1a70afdce8219e6a6ff23faf95244260258e23" translate="yes" xml:space="preserve">
          <source>Imagine an array of 32-bit integers (each 4 bytes):</source>
          <target state="translated">Представьте себе массив из 32-битных целых чисел (каждый 4 байта):</target>
        </trans-unit>
        <trans-unit id="81ebe12aa11cc123fdb7f8c88133ffaff6347b23" translate="yes" xml:space="preserve">
          <source>Implementation details</source>
          <target state="translated">Детали внедрения</target>
        </trans-unit>
        <trans-unit id="c12c46e2305d0716b258ac51f2e79f55da8c1069" translate="yes" xml:space="preserve">
          <source>Implementations of &lt;code&gt;__array_function__&lt;/code&gt; indicate that they can handle the operation by returning any value other than &lt;code&gt;NotImplemented&lt;/code&gt;.</source>
          <target state="translated">Реализации &lt;code&gt;__array_function__&lt;/code&gt; указывают, что они могут обрабатывать операцию, возвращая любое значение, кроме &lt;code&gt;NotImplemented&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0e028e89dfea3c1cba7d9fc7a23453fc7abac732" translate="yes" xml:space="preserve">
          <source>Implements exec_command function that is (almost) equivalent to commands.getstatusoutput function but on NT, DOS systems the returned status is actually correct (though, the returned status values may be different by a factor). In addition, exec_command takes keyword arguments for (re-)defining environment variables.</source>
          <target state="translated">Вводит функцию exec_command,которая (почти)эквивалентна выходной функции commands.gettatusoutput,но в системах NT,DOS,возвращаемый статус на самом деле корректен (хотя,возвращаемые значения статусов могут быть разными в разное время).Кроме того,команда exec_command принимает аргументы по ключевым словам для (повторного)определения переменных окружения.</target>
        </trans-unit>
        <trans-unit id="b794a9ed38f8d441574ce1ea158c0a341f3db730" translate="yes" xml:space="preserve">
          <source>Implements the complex comparisons between two complex numbers (structures with a real and imag member) using NumPy&amp;rsquo;s definition of the ordering which is lexicographic: comparing the real parts first and then the complex parts if the real parts are equal.</source>
          <target state="translated">Реализует сложные сравнения между двумя комплексными числами (структурами с действительным и воображаемым членами), используя определение порядка в NumPy, которое является лексикографическим: сначала сравнение реальных частей, а затем сложных частей, если реальные части равны.</target>
        </trans-unit>
        <trans-unit id="22af89867a4595ad888fcb4ec7aff9a5775524c5" translate="yes" xml:space="preserve">
          <source>Implements the rules for scalar coercion. Scalars are only silently coerced from thistype to neededtype if this function returns nonzero. If scalar is &lt;code&gt;NPY_NOSCALAR&lt;/code&gt;, then this function is equivalent to &lt;a href=&quot;#c.PyArray_CanCastSafely&quot;&gt;&lt;code&gt;PyArray_CanCastSafely&lt;/code&gt;&lt;/a&gt;. The rule is that scalars of the same KIND can be coerced into arrays of the same KIND. This rule means that high-precision scalars will never cause low-precision arrays of the same KIND to be upcast.</source>
          <target state="translated">Реализует правила скалярного принуждения. Скаляры автоматически переводятся от этого типа к нужному типу, только если эта функция возвращает ненулевое значение. Если скаляр равен &lt;code&gt;NPY_NOSCALAR&lt;/code&gt; , эта функция эквивалентна &lt;a href=&quot;#c.PyArray_CanCastSafely&quot;&gt; &lt;code&gt;PyArray_CanCastSafely&lt;/code&gt; &lt;/a&gt; . Правило состоит в том, что скаляры одного и того же типа могут быть преобразованы в массивы одного и того же типа. Это правило означает, что скаляры высокой точности никогда не приведут к преобразованию массивов низкой точности одного и того же ВИДА.</target>
        </trans-unit>
        <trans-unit id="c27d990de6ba5889ef7140c6c7a668ba89dfd7cb" translate="yes" xml:space="preserve">
          <source>Importing the API</source>
          <target state="translated">Импорт API</target>
        </trans-unit>
        <trans-unit id="651ad1981d9513aaa48106696e9dc28fdbdbb95a" translate="yes" xml:space="preserve">
          <source>In &amp;lsquo;clip&amp;rsquo; mode, a negative index which would normally wrap will clip to 0 instead.</source>
          <target state="translated">В режиме &amp;laquo;клипа&amp;raquo; отрицательный индекс, который обычно переносится, вместо этого обрезается до 0.</target>
        </trans-unit>
        <trans-unit id="2fa6844c3d81a6fe2067c8e0e928cef4f2f272dc" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;range(6)&lt;/code&gt;, information on what kind of rounding is done in addition, and on how underflow is handled.</source>
          <target state="translated">В &lt;code&gt;range(6)&lt;/code&gt; - информация о том, какое округление выполняется дополнительно, и о том, как обрабатывается потеря значимости.</target>
        </trans-unit>
        <trans-unit id="50fbd12243b4769e24084faa8adf2287f6b3d6cd" translate="yes" xml:space="preserve">
          <source>In &lt;em&gt;explicit mode&lt;/em&gt; the output can be directly controlled by specifying output subscript labels. This requires the identifier &amp;lsquo;-&amp;gt;&amp;rsquo; as well as the list of output subscript labels. This feature increases the flexibility of the function since summing can be disabled or forced when required. The call &lt;code&gt;np.einsum('i-&amp;gt;', a)&lt;/code&gt; is like &lt;a href=&quot;numpy.sum#numpy.sum&quot;&gt;&lt;code&gt;np.sum(a, axis=-1)&lt;/code&gt;&lt;/a&gt;, and &lt;code&gt;np.einsum('ii-&amp;gt;i', a)&lt;/code&gt; is like &lt;a href=&quot;numpy.diag#numpy.diag&quot;&gt;&lt;code&gt;np.diag(a)&lt;/code&gt;&lt;/a&gt;. The difference is that &lt;a href=&quot;#numpy.einsum&quot;&gt;&lt;code&gt;einsum&lt;/code&gt;&lt;/a&gt; does not allow broadcasting by default. Additionally &lt;code&gt;np.einsum('ij,jh-&amp;gt;ih', a, b)&lt;/code&gt; directly specifies the order of the output subscript labels and therefore returns matrix multiplication, unlike the example above in implicit mode.</source>
          <target state="translated">В &lt;em&gt;явном режиме&lt;/em&gt; выводом можно напрямую управлять, задав метки нижнего индекса вывода. Для этого требуется идентификатор '-&amp;gt;', а также список меток выходных индексов. Эта функция увеличивает гибкость функции, так как при необходимости суммирование можно отключить или принудительно. Вызов &lt;code&gt;np.einsum('i-&amp;gt;', a)&lt;/code&gt; похож на &lt;a href=&quot;numpy.sum#numpy.sum&quot;&gt; &lt;code&gt;np.sum(a, axis=-1)&lt;/code&gt; &lt;/a&gt; , а &lt;code&gt;np.einsum('ii-&amp;gt;i', a)&lt;/code&gt; похож на &lt;a href=&quot;numpy.diag#numpy.diag&quot;&gt; &lt;code&gt;np.diag(a)&lt;/code&gt; &lt;/a&gt; . Разница в том, что по умолчанию &lt;a href=&quot;#numpy.einsum&quot;&gt; &lt;code&gt;einsum&lt;/code&gt; &lt;/a&gt; не разрешает трансляцию. Кроме того, &lt;code&gt;np.einsum('ij,jh-&amp;gt;ih', a, b)&lt;/code&gt; напрямую определяет порядок меток выходных нижних индексов и, следовательно, возвращает матричное умножение, в отличие от примера выше в неявном режиме.</target>
        </trans-unit>
        <trans-unit id="c0145016518b0031bebdd7367da2ce7b6495c4d5" translate="yes" xml:space="preserve">
          <source>In &lt;em&gt;explicit&lt;/em&gt; mode, &lt;a href=&quot;#numpy.einsum&quot;&gt;&lt;code&gt;einsum&lt;/code&gt;&lt;/a&gt; provides further flexibility to compute other array operations that might not be considered classical Einstein summation operations, by disabling, or forcing summation over specified subscript labels.</source>
          <target state="translated">В &lt;em&gt;явном&lt;/em&gt; режиме &lt;a href=&quot;#numpy.einsum&quot;&gt; &lt;code&gt;einsum&lt;/code&gt; &lt;/a&gt; обеспечивает дополнительную гибкость для вычисления других операций с массивами, которые могут не считаться классическими операциями суммирования Эйнштейна, путем отключения или принудительного суммирования по указанным подписям индекса.</target>
        </trans-unit>
        <trans-unit id="4c8b68052719d1c1d5215bfd711f82950ca7a1df" translate="yes" xml:space="preserve">
          <source>In &lt;em&gt;implicit mode&lt;/em&gt;, the chosen subscripts are important since the axes of the output are reordered alphabetically. This means that &lt;code&gt;np.einsum('ij', a)&lt;/code&gt; doesn&amp;rsquo;t affect a 2D array, while &lt;code&gt;np.einsum('ji', a)&lt;/code&gt; takes its transpose. Additionally, &lt;code&gt;np.einsum('ij,jk', a, b)&lt;/code&gt; returns a matrix multiplication, while, &lt;code&gt;np.einsum('ij,jh', a, b)&lt;/code&gt; returns the transpose of the multiplication since subscript &amp;lsquo;h&amp;rsquo; precedes subscript &amp;lsquo;i&amp;rsquo;.</source>
          <target state="translated">В &lt;em&gt;неявном режиме&lt;/em&gt; выбранные индексы важны, поскольку оси вывода переупорядочены в алфавитном порядке. Это означает, что &lt;code&gt;np.einsum('ij', a)&lt;/code&gt; не влияет на 2D-массив, тогда как &lt;code&gt;np.einsum('ji', a)&lt;/code&gt; принимает его транспонирование. Кроме того, &lt;code&gt;np.einsum('ij,jk', a, b)&lt;/code&gt; возвращает матричное умножение, а &lt;code&gt;np.einsum('ij,jh', a, b)&lt;/code&gt; возвращает транспонирование умножения, поскольку индекс 'h' предшествует нижнему индексу 'я'.</target>
        </trans-unit>
        <trans-unit id="065543ba7b7c467e5ff1cf1108109daa4f6f9b2e" translate="yes" xml:space="preserve">
          <source>In C, there is no equivalent to the deprecation warnings that Python supports. One way to do deprecations is to flag them in the documentation and release notes, then remove or change the deprecated features in a future major version (NumPy 2.0 and beyond). Minor versions of NumPy should not have major C-API changes, however, that prevent code that worked on a previous minor release. For example, we will do our best to ensure that code that compiled and worked on NumPy 1.4 should continue to work on NumPy 1.7 (but perhaps with compiler warnings).</source>
          <target state="translated">В C нет эквивалента предупреждений об опустошении,которые поддерживает Python.Один из способов сделать удаление-пометить их в документации и выпустить заметки,а затем удалить или изменить устаревшие функции в будущей мажорной версии (NumPy 2.0 и более поздние).Маленькие версии NumPy,однако,не должны иметь больших изменений C-API,которые препятствуют коду,работавшему на предыдущем незначительном выпуске.Например,мы сделаем всё возможное,чтобы код,который компилировался и работал на NumPy 1.4,продолжал работать на NumPy 1.7 (но,возможно,с предупреждениями компилятора).</target>
        </trans-unit>
        <trans-unit id="a7fc4e4e9aaf59319f61cb1b2c8333ad9f8d065b" translate="yes" xml:space="preserve">
          <source>In NumPy 1.16, you need to set the environment variable &lt;code&gt;NUMPY_EXPERIMENTAL_ARRAY_FUNCTION=1&lt;/code&gt; before importing NumPy to use NumPy function overrides.</source>
          <target state="translated">В NumPy 1.16 вам необходимо установить переменную среды &lt;code&gt;NUMPY_EXPERIMENTAL_ARRAY_FUNCTION=1&lt;/code&gt; перед импортом NumPy, чтобы использовать переопределения функции NumPy.</target>
        </trans-unit>
        <trans-unit id="2d05b90f328ed41700350ed32107071a1f6f3fbc" translate="yes" xml:space="preserve">
          <source>In NumPy 1.17, the protocol is enabled by default, but can be disabled with &lt;code&gt;NUMPY_EXPERIMENTAL_ARRAY_FUNCTION=0&lt;/code&gt;.</source>
          <target state="translated">В NumPy 1.17 протокол включен по умолчанию, но его можно отключить с помощью &lt;code&gt;NUMPY_EXPERIMENTAL_ARRAY_FUNCTION=0&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1b4938fa72e1c7213ec03de65817f46747825eb5" translate="yes" xml:space="preserve">
          <source>In NumPy 1.6.0, a type promotion API was created to encapsulate the mechanism for determining output types. See the functions &lt;a href=&quot;generated/numpy.result_type#numpy.result_type&quot;&gt;&lt;code&gt;result_type&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;generated/numpy.promote_types#numpy.promote_types&quot;&gt;&lt;code&gt;promote_types&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;generated/numpy.min_scalar_type#numpy.min_scalar_type&quot;&gt;&lt;code&gt;min_scalar_type&lt;/code&gt;&lt;/a&gt; for more details.</source>
          <target state="translated">В NumPy 1.6.0 был создан API продвижения типов для инкапсуляции механизма определения типов вывода. См. Дополнительные сведения о функциях &lt;a href=&quot;generated/numpy.result_type#numpy.result_type&quot;&gt; &lt;code&gt;result_type&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;generated/numpy.promote_types#numpy.promote_types&quot;&gt; &lt;code&gt;promote_types&lt;/code&gt; &lt;/a&gt; и &lt;a href=&quot;generated/numpy.min_scalar_type#numpy.min_scalar_type&quot;&gt; &lt;code&gt;min_scalar_type&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="6817ac22605fc4c2d0f573a2b14f3a89cb1e8f22" translate="yes" xml:space="preserve">
          <source>In NumPy 1.7 and 1.8, it continues to return a copy of the diagonal, but depending on this fact is deprecated. Writing to the resulting array continues to work as it used to, but a FutureWarning is issued.</source>
          <target state="translated">В NumPy 1.7 и 1.8 продолжает возвращать копию диагонали,но в зависимости от этого факта устаревает.Запись в результирующий массив продолжает работать,как и раньше,но выдается FutureWarning.</target>
        </trans-unit>
        <trans-unit id="117fbe2ef07a30dba33092bb43c1ec1f63fe2b7a" translate="yes" xml:space="preserve">
          <source>In NumPy 1.7 and later, this form allows &lt;code&gt;base_dtype&lt;/code&gt; to be interpreted as a structured dtype. Arrays created with this dtype will have underlying dtype &lt;code&gt;base_dtype&lt;/code&gt; but will have fields and flags taken from &lt;code&gt;new_dtype&lt;/code&gt;. This is useful for creating custom structured dtypes, as done in &lt;a href=&quot;arrays.classes#arrays-classes-rec&quot;&gt;record arrays&lt;/a&gt;.</source>
          <target state="translated">В NumPy 1.7 и новее эта форма позволяет &lt;code&gt;base_dtype&lt;/code&gt; как структурированный dtype. Массивы, созданные с этим dtype, будут иметь базовый dtype &lt;code&gt;base_dtype&lt;/code&gt; , но будут иметь поля и флаги, взятые из &lt;code&gt;new_dtype&lt;/code&gt; . Это полезно для создания настраиваемых структурированных типов данных, как это делается в &lt;a href=&quot;arrays.classes#arrays-classes-rec&quot;&gt;массивах записей&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="3b53f7eb15b7831e508349b1a60777dcdbd79a0e" translate="yes" xml:space="preserve">
          <source>In NumPy versions &amp;lt;= 1.9.0 Nan is returned for slices that are all-NaN or empty. In later versions zero is returned.</source>
          <target state="translated">В версиях NumPy &amp;lt;= 1.9.0 Nan возвращается для срезов, которые содержат только NaN или пустые. В более поздних версиях возвращается ноль.</target>
        </trans-unit>
        <trans-unit id="ed78411a5f19815c75577c53c9647b97f455af34" translate="yes" xml:space="preserve">
          <source>In NumPy, there are 24 new fundamental Python types to describe different types of scalars. These type descriptors are mostly based on the types available in the C language that CPython is written in, with several additional types compatible with Python&amp;rsquo;s types.</source>
          <target state="translated">В NumPy есть 24 новых фундаментальных типа Python для описания различных типов скаляров. Эти дескрипторы типов в основном основаны на типах, доступных в языке C, на котором написан CPython, с несколькими дополнительными типами, совместимыми с типами Python.</target>
        </trans-unit>
        <trans-unit id="0c775f1e9d60e517f99b3f4fb5fbef2cd48f1233" translate="yes" xml:space="preserve">
          <source>In NumPy, universal functions are instances of the &lt;code&gt;numpy.ufunc&lt;/code&gt; class. Many of the built-in functions are implemented in compiled C code. The basic ufuncs operate on scalars, but there is also a generalized kind for which the basic elements are sub-arrays (vectors, matrices, etc.), and broadcasting is done over other dimensions. One can also produce custom &lt;code&gt;ufunc&lt;/code&gt; instances using the &lt;a href=&quot;generated/numpy.frompyfunc#numpy.frompyfunc&quot;&gt;&lt;code&gt;frompyfunc&lt;/code&gt;&lt;/a&gt; factory function.</source>
          <target state="translated">В NumPy универсальные функции являются экземплярами класса &lt;code&gt;numpy.ufunc&lt;/code&gt; . Многие из встроенных функций реализованы в скомпилированном коде C. Базовые функции ufuncs работают со скалярами, но есть также обобщенный вид, для которого базовыми элементами являются подмассивы (векторы, матрицы и т. Д.), А широковещательная передача осуществляется по другим измерениям. Также можно создавать собственные экземпляры &lt;code&gt;ufunc&lt;/code&gt; , используя фабричную функцию &lt;a href=&quot;generated/numpy.frompyfunc#numpy.frompyfunc&quot;&gt; &lt;code&gt;frompyfunc&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="774635ebbde845fd67b0f22449de4d887322609c" translate="yes" xml:space="preserve">
          <source>In Numeric, the ancestor of Numpy, broadcasting was implemented in several lines of code buried deep in ufuncobject.c. In NumPy, the notion of broadcasting has been abstracted so that it can be performed in multiple places. Broadcasting is handled by the function &lt;a href=&quot;c-api.array#c.PyArray_Broadcast&quot;&gt;&lt;code&gt;PyArray_Broadcast&lt;/code&gt;&lt;/a&gt;. This function requires a &lt;a href=&quot;c-api.types-and-structures#c.PyArrayMultiIterObject&quot;&gt;&lt;code&gt;PyArrayMultiIterObject&lt;/code&gt;&lt;/a&gt; (or something that is a binary equivalent) to be passed in. The &lt;a href=&quot;c-api.types-and-structures#c.PyArrayMultiIterObject&quot;&gt;&lt;code&gt;PyArrayMultiIterObject&lt;/code&gt;&lt;/a&gt; keeps track of the broadcast number of dimensions and size in each dimension along with the total size of the broadcast result. It also keeps track of the number of arrays being broadcast and a pointer to an iterator for each of the arrays being broadcast.</source>
          <target state="translated">В Numeric, предке Numpy, широковещательная передача была реализована в нескольких строках кода, скрытых глубоко в ufuncobject.c. В NumPy понятие широковещательной передачи было абстрагировано, чтобы ее можно было выполнять в нескольких местах. Трансляция осуществляется функцией &lt;a href=&quot;c-api.array#c.PyArray_Broadcast&quot;&gt; &lt;code&gt;PyArray_Broadcast&lt;/code&gt; &lt;/a&gt; . Для этой функции требуется &lt;a href=&quot;c-api.types-and-structures#c.PyArrayMultiIterObject&quot;&gt; &lt;code&gt;PyArrayMultiIterObject&lt;/code&gt; &lt;/a&gt; (или что-то, что является двоичным эквивалентом). &lt;a href=&quot;c-api.types-and-structures#c.PyArrayMultiIterObject&quot;&gt; &lt;code&gt;PyArrayMultiIterObject&lt;/code&gt; &lt;/a&gt; отслеживает количество измерений и размер широковещательной рассылки в каждом измерении вместе с общим размером результата широковещательной передачи. Он также отслеживает количество широковещательных массивов и указатель на итератор для каждого широковещательного массива.</target>
        </trans-unit>
        <trans-unit id="1b22fd0d42a99bd19673ecd40259cf68612486f3" translate="yes" xml:space="preserve">
          <source>In Python 3.0, &lt;code&gt;//&lt;/code&gt; is the floor division operator and &lt;code&gt;/&lt;/code&gt; the true division operator. The &lt;code&gt;true_divide(x1, x2)&lt;/code&gt; function is equivalent to true division in Python.</source>
          <target state="translated">В Python 3.0 &lt;code&gt;//&lt;/code&gt; является оператором деления этажа и &lt;code&gt;/&lt;/code&gt; истинным оператором деления. Функция &lt;code&gt;true_divide(x1, x2)&lt;/code&gt; эквивалентна истинному делению в Python.</target>
        </trans-unit>
        <trans-unit id="060ed7eb6876dfc9a447b37757dfa0a45bd6069c" translate="yes" xml:space="preserve">
          <source>In Python, &lt;code&gt;x[(exp1, exp2, ..., expN)]&lt;/code&gt; is equivalent to &lt;code&gt;x[exp1, exp2, ..., expN]&lt;/code&gt;; the latter is just syntactic sugar for the former.</source>
          <target state="translated">В Python &lt;code&gt;x[(exp1, exp2, ..., expN)]&lt;/code&gt; эквивалентно &lt;code&gt;x[exp1, exp2, ..., expN]&lt;/code&gt; ; последнее - всего лишь синтаксический сахар для первого.</target>
        </trans-unit>
        <trans-unit id="0643c04fa6f173d8a3f9cc4f3ce84f7f07625090" translate="yes" xml:space="preserve">
          <source>In a study, testing for a specific alternative to the null hypothesis requires use of the Noncentral F distribution. We need to calculate the area in the tail of the distribution that exceeds the value of the F distribution for the null hypothesis. We&amp;rsquo;ll plot the two probability distributions for comparison.</source>
          <target state="translated">В исследовании проверка конкретной альтернативы нулевой гипотезе требует использования нецентрального F-распределения. Нам нужно вычислить площадь в хвосте распределения, которая превышает значение распределения F для нулевой гипотезы. Мы построим два распределения вероятностей для сравнения.</target>
        </trans-unit>
        <trans-unit id="4a555d5f0fdb6581c9697563824e3d61c23e3de4" translate="yes" xml:space="preserve">
          <source>In a two&amp;rsquo;s-complement system negative numbers are represented by the two&amp;rsquo;s complement of the absolute value. This is the most common method of representing signed integers on computers &lt;a href=&quot;#r962252997619-1&quot; id=&quot;id1&quot;&gt;[1]&lt;/a&gt;. A N-bit two&amp;rsquo;s-complement system can represent every integer in the range</source>
          <target state="translated">В системе с дополнением до двух отрицательные числа представлены дополнением до двух абсолютного значения. Это наиболее распространенный метод представления целых чисел со знаком на компьютерах &lt;a href=&quot;#r962252997619-1&quot; id=&quot;id1&quot;&gt;[1]&lt;/a&gt; . N-битная система с дополнением до двух может представлять каждое целое число в диапазоне</target>
        </trans-unit>
        <trans-unit id="6ec708a7d401df6aafb3a323298b5e8a10e70e10" translate="yes" xml:space="preserve">
          <source>In addition &lt;code&gt;a&lt;/code&gt; or &lt;code&gt;b&lt;/code&gt; may be scalars, in which case:</source>
          <target state="translated">Кроме того, &lt;code&gt;a&lt;/code&gt; или &lt;code&gt;b&lt;/code&gt; могут быть скалярами, и в этом случае:</target>
        </trans-unit>
        <trans-unit id="0202a847e7f1c55dfe19c04653df757ab3188d4f" translate="yes" xml:space="preserve">
          <source>In addition to attributes that can be specified via keyword arguments to &lt;code&gt;Configuration&lt;/code&gt; constructor, &lt;code&gt;Configuration&lt;/code&gt; instance (let us denote as &lt;code&gt;config&lt;/code&gt;) has the following attributes that can be useful in writing setup scripts:</source>
          <target state="translated">Кроме атрибуты , которые могут быть заданы с помощью именованных аргументов в &lt;code&gt;Configuration&lt;/code&gt; конструктора, &lt;code&gt;Configuration&lt;/code&gt; экземпляр (будет обозначать &lt;code&gt;config&lt;/code&gt; ) имеют следующие атрибуты , которые могут быть полезны при написании сценариев установки:</target>
        </trans-unit>
        <trans-unit id="29ec49c4a4c9a814e9bec074f3eabcbf7dea786f" translate="yes" xml:space="preserve">
          <source>In addition to the &lt;a href=&quot;#numpy.ma.MaskedArray&quot;&gt;&lt;code&gt;MaskedArray&lt;/code&gt;&lt;/a&gt; class, the &lt;a href=&quot;maskedarray.generic#module-numpy.ma&quot;&gt;&lt;code&gt;numpy.ma&lt;/code&gt;&lt;/a&gt; module defines several constants.</source>
          <target state="translated">В дополнение к &lt;a href=&quot;#numpy.ma.MaskedArray&quot;&gt; &lt;code&gt;MaskedArray&lt;/code&gt; &lt;/a&gt; класса, &lt;a href=&quot;maskedarray.generic#module-numpy.ma&quot;&gt; &lt;code&gt;numpy.ma&lt;/code&gt; &lt;/a&gt; модуль определяет несколько констант.</target>
        </trans-unit>
        <trans-unit id="55ae7a3680f09394c2ee157c2db0452e71e75c1c" translate="yes" xml:space="preserve">
          <source>In addition, if &lt;em&gt;data&lt;/em&gt; is non-NULL, then &lt;em&gt;strides&lt;/em&gt; can also be provided. If &lt;em&gt;strides&lt;/em&gt; is &lt;code&gt;NULL&lt;/code&gt;, then the array strides are computed as C-style contiguous (default) or Fortran-style contiguous (&lt;em&gt;flags&lt;/em&gt; is nonzero for &lt;em&gt;data&lt;/em&gt; = &lt;code&gt;NULL&lt;/code&gt; or &lt;em&gt;flags&lt;/em&gt; &amp;amp; &lt;a href=&quot;#c.NPY_ARRAY_F_CONTIGUOUS&quot;&gt;&lt;code&gt;NPY_ARRAY_F_CONTIGUOUS&lt;/code&gt;&lt;/a&gt; is nonzero non-NULL &lt;em&gt;data&lt;/em&gt;). Any provided &lt;em&gt;dims&lt;/em&gt; and &lt;em&gt;strides&lt;/em&gt; are copied into newly allocated dimension and strides arrays for the new array object.</source>
          <target state="translated">Кроме того, если &lt;em&gt;данные&lt;/em&gt; не равны NULL, также могут быть предоставлены &lt;em&gt;шаги&lt;/em&gt; . Если &lt;em&gt;strides&lt;/em&gt; равен &lt;code&gt;NULL&lt;/code&gt; , то шаги массива вычисляются как непрерывные в стиле C (по умолчанию) или как непрерывные в стиле Fortran ( &lt;em&gt;flags не&lt;/em&gt; равен нулю для &lt;em&gt;data&lt;/em&gt; = &lt;code&gt;NULL&lt;/code&gt; или &lt;em&gt;flags,&lt;/em&gt; а &lt;a href=&quot;#c.NPY_ARRAY_F_CONTIGUOUS&quot;&gt; &lt;code&gt;NPY_ARRAY_F_CONTIGUOUS&lt;/code&gt; &lt;/a&gt; - ненулевые ненулевые &lt;em&gt;данные&lt;/em&gt; ). Любые предоставленные &lt;em&gt;тускнеет&lt;/em&gt; и &lt;em&gt;шагает&lt;/em&gt; копируются во вновь выделенных измерениях и шагают массивы для нового объекта массива.</target>
        </trans-unit>
        <trans-unit id="9d28ba92ccb218b4c16f2db7077723c632363102" translate="yes" xml:space="preserve">
          <source>In all the examples so far, the elements of &lt;code&gt;a&lt;/code&gt; are provided by the iterator one at a time, because all the looping logic is internal to the iterator. While this is simple and convenient, it is not very efficient. A better approach is to move the one-dimensional innermost loop into your code, external to the iterator. This way, NumPy&amp;rsquo;s vectorized operations can be used on larger chunks of the elements being visited.</source>
          <target state="translated">Во всех примерах до сих пор элементы &lt;code&gt;a&lt;/code&gt; предоставляются итератором по одному, потому что вся логика цикла является внутренней для итератора. Это просто и удобно, но не очень эффективно. Лучше всего переместить одномерный самый внутренний цикл в ваш код, внешний по отношению к итератору. Таким образом, векторизованные операции NumPy можно использовать для больших фрагментов посещаемых элементов.</target>
        </trans-unit>
        <trans-unit id="8389ffaf8c2e94e518381d310c79dd3ec1608070" translate="yes" xml:space="preserve">
          <source>In almost all cases &lt;code&gt;np.ndim(x) == 0&lt;/code&gt; should be used instead of this function, as that will also return true for 0d arrays. This is how numpy overloads functions in the style of the &lt;code&gt;dx&lt;/code&gt; arguments to &lt;a href=&quot;numpy.gradient#numpy.gradient&quot;&gt;&lt;code&gt;gradient&lt;/code&gt;&lt;/a&gt; and the &lt;code&gt;bins&lt;/code&gt; argument to &lt;a href=&quot;numpy.histogram#numpy.histogram&quot;&gt;&lt;code&gt;histogram&lt;/code&gt;&lt;/a&gt;. Some key differences:</source>
          <target state="translated">Почти во всех случаях вместо этой функции следует использовать &lt;code&gt;np.ndim(x) == 0&lt;/code&gt; , так как это также вернет true для массивов 0d. Вот как функции перегрузки numpy работают в стиле аргументов &lt;code&gt;dx&lt;/code&gt; для &lt;a href=&quot;numpy.gradient#numpy.gradient&quot;&gt; &lt;code&gt;gradient&lt;/code&gt; &lt;/a&gt; и аргумента &lt;code&gt;bins&lt;/code&gt; для &lt;a href=&quot;numpy.histogram#numpy.histogram&quot;&gt; &lt;code&gt;histogram&lt;/code&gt; &lt;/a&gt; . Некоторые ключевые отличия:</target>
        </trans-unit>
        <trans-unit id="3e277da1826bb81328288e7b48e1bc36cb3d9f8b" translate="yes" xml:space="preserve">
          <source>In case of multiple occurrences of the maximum values, the indices corresponding to the first occurrence are returned.</source>
          <target state="translated">В случае множественных вхождений максимальных значений возвращаются индексы,соответствующие первому вхождению.</target>
        </trans-unit>
        <trans-unit id="27e7146cba1027fb05de967eb96a8d0d4f3188c0" translate="yes" xml:space="preserve">
          <source>In case of multiple occurrences of the minimum values, the indices corresponding to the first occurrence are returned.</source>
          <target state="translated">В случае множественных вхождений минимальных значений возвращаются индексы,соответствующие первому вхождению.</target>
        </trans-unit>
        <trans-unit id="15906ca68f2a7d7e2f6c027ec51f5d69dd3bed29" translate="yes" xml:space="preserve">
          <source>In copying mode, &amp;lsquo;copy&amp;rsquo; is specified as a per-operand flag. This is done to provide control in a per-operand fashion. Buffering mode is specified as an iterator flag.</source>
          <target state="translated">В режиме копирования &amp;laquo;копирование&amp;raquo; указывается как флаг для каждого операнда. Это сделано для обеспечения управления для каждого операнда. Режим буферизации указывается как флаг итератора.</target>
        </trans-unit>
        <trans-unit id="0401f70e9e9ccb692db031dd68efec8a8e548588" translate="yes" xml:space="preserve">
          <source>In every case, the &amp;lsquo;descr&amp;rsquo; key is optional, but of course provides more information which may be important for various applications:</source>
          <target state="translated">В любом случае клавиша descr необязательна, но, конечно, предоставляет дополнительную информацию, которая может быть важной для различных приложений:</target>
        </trans-unit>
        <trans-unit id="51a2782158f2135b3873b2bc91584160c3224ec1" translate="yes" xml:space="preserve">
          <source>In general if an index includes a Boolean array, the result will be identical to inserting &lt;code&gt;obj.nonzero()&lt;/code&gt; into the same position and using the integer array indexing mechanism described above. &lt;code&gt;x[ind_1, boolean_array, ind_2]&lt;/code&gt; is equivalent to &lt;code&gt;x[(ind_1,) + boolean_array.nonzero() + (ind_2,)]&lt;/code&gt;.</source>
          <target state="translated">Обычно, если индекс включает в себя логический массив, результат будет идентичен вставке &lt;code&gt;obj.nonzero()&lt;/code&gt; в ту же позицию и использованию механизма индексации целочисленного массива, описанного выше. &lt;code&gt;x[ind_1, boolean_array, ind_2]&lt;/code&gt; эквивалентно &lt;code&gt;x[(ind_1,) + boolean_array.nonzero() + (ind_2,)]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ce9f087f4c4d9805ec9d46a8db9fd36d60eeb431" translate="yes" xml:space="preserve">
          <source>In general, for &lt;code&gt;values&lt;/code&gt;</source>
          <target state="translated">В общем, для &lt;code&gt;values&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="2636b2d2555459756347b2bec78d067967d80c45" translate="yes" xml:space="preserve">
          <source>In general, the (polynomial) division of one C-series by another results in quotient and remainder terms that are not in the Chebyshev polynomial basis set. Thus, to express these results as C-series, it is typically necessary to &amp;ldquo;reproject&amp;rdquo; the results onto said basis set, which typically produces &amp;ldquo;unintuitive&amp;rdquo; (but correct) results; see Examples section below.</source>
          <target state="translated">В общем, (полиномиальное) деление одной C-серии на другую приводит к получению факторных и остаточных членов, которых нет в базисе полиномов Чебышева. Таким образом, чтобы выразить эти результаты как серию C, обычно необходимо &amp;laquo;перепроецировать&amp;raquo; результаты на упомянутый базисный набор, что обычно дает &amp;laquo;неинтуитивные&amp;raquo; (но правильные) результаты; см. раздел &amp;laquo;Примеры&amp;raquo; ниже.</target>
        </trans-unit>
        <trans-unit id="e3455fcce926f7a356d4db4cbb1cca4337cab9da" translate="yes" xml:space="preserve">
          <source>In general, the (polynomial) division of one Hermite series by another results in quotient and remainder terms that are not in the Hermite polynomial basis set. Thus, to express these results as a Hermite series, it is necessary to &amp;ldquo;reproject&amp;rdquo; the results onto the Hermite basis set, which may produce &amp;ldquo;unintuitive&amp;rdquo; (but correct) results; see Examples section below.</source>
          <target state="translated">В общем, (полиномиальное) деление одного ряда Эрмита на другой приводит к получению факторов, составляющих частное, и остаточного члена, которых нет в базисе полиномов Эрмита. Таким образом, чтобы выразить эти результаты в виде ряда Эрмита, необходимо &amp;laquo;перепроецировать&amp;raquo; результаты на базисный набор Эрмита, что может дать &amp;laquo;неинтуитивные&amp;raquo; (но правильные) результаты; см. раздел &amp;laquo;Примеры&amp;raquo; ниже.</target>
        </trans-unit>
        <trans-unit id="efbd236c04665a122a8e3491beed41d349724880" translate="yes" xml:space="preserve">
          <source>In general, the (polynomial) division of one Laguerre series by another results in quotient and remainder terms that are not in the Laguerre polynomial basis set. Thus, to express these results as a Laguerre series, it is necessary to &amp;ldquo;reproject&amp;rdquo; the results onto the Laguerre basis set, which may produce &amp;ldquo;unintuitive&amp;rdquo; (but correct) results; see Examples section below.</source>
          <target state="translated">В общем, (полиномиальное) деление одного ряда Лагерра на другой приводит к частным и остаточным членам, которые не входят в базисный набор полиномов Лагерра. Таким образом, чтобы выразить эти результаты в виде ряда Лагерра, необходимо &amp;laquo;перепроецировать&amp;raquo; результаты на базисный набор Лагерра, что может дать &amp;laquo;неинтуитивные&amp;raquo; (но правильные) результаты; см. раздел &amp;laquo;Примеры&amp;raquo; ниже.</target>
        </trans-unit>
        <trans-unit id="3e8f9ae8eb5287a2e2ca75de1027864d1ea7dce3" translate="yes" xml:space="preserve">
          <source>In general, the (polynomial) division of one Legendre series by another results in quotient and remainder terms that are not in the Legendre polynomial basis set. Thus, to express these results as a Legendre series, it is necessary to &amp;ldquo;reproject&amp;rdquo; the results onto the Legendre basis set, which may produce &amp;ldquo;unintuitive&amp;rdquo; (but correct) results; see Examples section below.</source>
          <target state="translated">В общем, (полиномиальное) деление одного ряда Лежандра на другой приводит к получению факторных и остаточных членов, которые не входят в базисный набор полиномов Лежандра. Таким образом, чтобы выразить эти результаты в виде ряда Лежандра, необходимо &amp;laquo;перепроецировать&amp;raquo; результаты на базисный набор Лежандра, что может дать &amp;laquo;неинтуитивные&amp;raquo; (но правильные) результаты; см. раздел &amp;laquo;Примеры&amp;raquo; ниже.</target>
        </trans-unit>
        <trans-unit id="747e8b05b6e447bd7c26bc6951f1c707ad59f09d" translate="yes" xml:space="preserve">
          <source>In general, the (polynomial) product of two C-series results in terms that are not in the Chebyshev polynomial basis set. Thus, to express the product as a C-series, it is typically necessary to &amp;ldquo;reproject&amp;rdquo; the product onto said basis set, which typically produces &amp;ldquo;unintuitive live&amp;rdquo; (but correct) results; see Examples section below.</source>
          <target state="translated">В общем, (полиномиальное) произведение двух C-серий приводит к терминам, не входящим в базисный набор полиномов Чебышева. Таким образом, чтобы выразить продукт как серию C, обычно необходимо &amp;laquo;перепроецировать&amp;raquo; продукт на указанный базовый набор, что обычно дает &amp;laquo;неинтуитивные живые&amp;raquo; (но правильные) результаты; см. раздел &amp;laquo;Примеры&amp;raquo; ниже.</target>
        </trans-unit>
        <trans-unit id="140624c01263c11121eb8733a7573189c8b35148" translate="yes" xml:space="preserve">
          <source>In general, the (polynomial) product of two C-series results in terms that are not in the Hermite polynomial basis set. Thus, to express the product as a Hermite series, it is necessary to &amp;ldquo;reproject&amp;rdquo; the product onto said basis set, which may produce &amp;ldquo;unintuitive&amp;rdquo; (but correct) results; see Examples section below.</source>
          <target state="translated">В общем, (полиномиальное) произведение двух C-серий приводит к терминам, не входящим в базисный набор полиномов Эрмита. Таким образом, чтобы выразить продукт как серию Hermite, необходимо &amp;laquo;перепроецировать&amp;raquo; продукт на указанный базовый набор, что может дать &amp;laquo;неинтуитивные&amp;raquo; (но правильные) результаты; см. раздел &amp;laquo;Примеры&amp;raquo; ниже.</target>
        </trans-unit>
        <trans-unit id="4be0c1b381e26e882c60023195f1e89d336414ac" translate="yes" xml:space="preserve">
          <source>In general, the (polynomial) product of two C-series results in terms that are not in the Laguerre polynomial basis set. Thus, to express the product as a Laguerre series, it is necessary to &amp;ldquo;reproject&amp;rdquo; the product onto said basis set, which may produce &amp;ldquo;unintuitive&amp;rdquo; (but correct) results; see Examples section below.</source>
          <target state="translated">В общем, (полиномиальное) произведение двух C-серий приводит к терминам, которые не входят в базисный набор полиномов Лагерра. Таким образом, чтобы выразить продукт как серию Лагерра, необходимо &amp;laquo;перепроецировать&amp;raquo; продукт на указанный базисный набор, что может дать &amp;laquo;неинтуитивные&amp;raquo; (но правильные) результаты; см. раздел &amp;laquo;Примеры&amp;raquo; ниже.</target>
        </trans-unit>
        <trans-unit id="54659a570a760a1d9fe356eba1a0141427eabe1f" translate="yes" xml:space="preserve">
          <source>In general, the (polynomial) product of two C-series results in terms that are not in the Legendre polynomial basis set. Thus, to express the product as a Legendre series, it is necessary to &amp;ldquo;reproject&amp;rdquo; the product onto said basis set, which may produce &amp;ldquo;unintuitive&amp;rdquo; (but correct) results; see Examples section below.</source>
          <target state="translated">В общем, (полиномиальное) произведение двух C-серий приводит к терминам, не входящим в базисный набор полиномов Лежандра. Таким образом, чтобы выразить продукт как серию Лежандра, необходимо &amp;laquo;перепроецировать&amp;raquo; продукт на указанный базисный набор, что может дать &amp;laquo;неинтуитивные&amp;raquo; (но правильные) результаты; см. раздел &amp;laquo;Примеры&amp;raquo; ниже.</target>
        </trans-unit>
        <trans-unit id="de938489906c2e0d2c954a8201ef415c1aa719ca" translate="yes" xml:space="preserve">
          <source>In general, the result of differentiating a C-series needs to be &amp;ldquo;reprojected&amp;rdquo; onto the C-series basis set. Thus, typically, the result of this function is &amp;ldquo;unintuitive,&amp;rdquo; albeit correct; see Examples section below.</source>
          <target state="translated">В общем, результат дифференциации C-серии необходимо &amp;laquo;перепроецировать&amp;raquo; на базисный набор C-серии. Таким образом, обычно результат этой функции &amp;laquo;не интуитивно понятен&amp;raquo;, хотя и верен; см. раздел &amp;laquo;Примеры&amp;raquo; ниже.</target>
        </trans-unit>
        <trans-unit id="dc47191395ffa64cfa2441fe3b165eeaca46d090" translate="yes" xml:space="preserve">
          <source>In general, the result of differentiating a Hermite series does not resemble the same operation on a power series. Thus the result of this function may be &amp;ldquo;unintuitive,&amp;rdquo; albeit correct; see Examples section below.</source>
          <target state="translated">В общем, результат дифференцирования ряда Эрмита не похож на ту же операцию над степенным рядом. Таким образом, результат этой функции может быть &amp;laquo;не интуитивным&amp;raquo;, хотя и правильным; см. раздел &amp;laquo;Примеры&amp;raquo; ниже.</target>
        </trans-unit>
        <trans-unit id="c6b49ce2210116245bad6e5bb6d187bba65b38de" translate="yes" xml:space="preserve">
          <source>In general, the result of differentiating a Laguerre series does not resemble the same operation on a power series. Thus the result of this function may be &amp;ldquo;unintuitive,&amp;rdquo; albeit correct; see Examples section below.</source>
          <target state="translated">В общем, результат дифференцирования ряда Лагерра не похож на ту же операцию над степенным рядом. Таким образом, результат этой функции может быть &amp;laquo;не интуитивным&amp;raquo;, хотя и правильным; см. раздел &amp;laquo;Примеры&amp;raquo; ниже.</target>
        </trans-unit>
        <trans-unit id="68d490300c846fea9862fc337043383e53cf549a" translate="yes" xml:space="preserve">
          <source>In general, the result of differentiating a Legendre series does not resemble the same operation on a power series. Thus the result of this function may be &amp;ldquo;unintuitive,&amp;rdquo; albeit correct; see Examples section below.</source>
          <target state="translated">В общем, результат дифференцирования ряда Лежандра не похож на ту же операцию над степенным рядом. Таким образом, результат этой функции может быть &amp;laquo;не интуитивным&amp;raquo;, хотя и правильным; см. раздел &amp;laquo;Примеры&amp;raquo; ниже.</target>
        </trans-unit>
        <trans-unit id="a094c205647147c910d02f3a8f4ccd59ee07b5bd" translate="yes" xml:space="preserve">
          <source>In general, you should target these typemap signatures specifically where you want them, and then clear them after you are done.</source>
          <target state="translated">В общем,вы должны нацелить эти сигнатуры на карты типов именно туда,где вы хотите их видеть,а затем очистить их после того,как вы закончите.</target>
        </trans-unit>
        <trans-unit id="dd3e08bc1a57887f18c581f1dbde91b2bd716911" translate="yes" xml:space="preserve">
          <source>In higher dimensions, FFTs are used, e.g., for image analysis and filtering. The computational efficiency of the FFT means that it can also be a faster way to compute large convolutions, using the property that a convolution in the time domain is equivalent to a point-by-point multiplication in the frequency domain.</source>
          <target state="translated">В более высоких размерах БПФ используются,например,для анализа и фильтрации изображений.Вычислительная эффективность БПФ означает,что она также может быть более быстрым способом вычисления больших сверток,используя свойство,что свертка во временной области эквивалентна поточному умножению в частотной области.</target>
        </trans-unit>
        <trans-unit id="b07ddb1ceb7095c96bdb1f519b0d36703eda5462" translate="yes" xml:space="preserve">
          <source>In interactions between &lt;code&gt;ArrayLike&lt;/code&gt; objects and numbers or numpy arrays, the result is always another &lt;code&gt;ArrayLike&lt;/code&gt;:</source>
          <target state="translated">При взаимодействии между объектами &lt;code&gt;ArrayLike&lt;/code&gt; и числами или множественными массивами результатом всегда будет другой &lt;code&gt;ArrayLike&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="859968bca8846c38eabf846201d96ee61f1cb6f0" translate="yes" xml:space="preserve">
          <source>In linear space, the sequence starts at &lt;code&gt;base ** start&lt;/code&gt; (&lt;code&gt;base&lt;/code&gt; to the power of &lt;code&gt;start&lt;/code&gt;) and ends with &lt;code&gt;base ** stop&lt;/code&gt; (see &lt;code&gt;endpoint&lt;/code&gt; below).</source>
          <target state="translated">В линейном пространстве последовательность начинается с &lt;code&gt;base ** start&lt;/code&gt; ( &lt;code&gt;base&lt;/code&gt; в степени &lt;code&gt;start&lt;/code&gt; ) и заканчивается &lt;code&gt;base ** stop&lt;/code&gt; (см. &lt;code&gt;endpoint&lt;/code&gt; ниже).</target>
        </trans-unit>
        <trans-unit id="e8987c188d2dc12518e96e9c96bc6fb94bc0c364" translate="yes" xml:space="preserve">
          <source>In many circumstances, datasets can be incomplete or tainted by the presence of invalid data. For example, a sensor may have failed to record a data, or recorded an invalid value. The &lt;a href=&quot;#module-numpy.ma&quot;&gt;&lt;code&gt;numpy.ma&lt;/code&gt;&lt;/a&gt; module provides a convenient way to address this issue, by introducing masked arrays.</source>
          <target state="translated">Во многих случаях наборы данных могут быть неполными или испорченными из-за наличия неверных данных. Например, датчик мог не записать данные или записал неверное значение. Модуль &lt;a href=&quot;#module-numpy.ma&quot;&gt; &lt;code&gt;numpy.ma&lt;/code&gt; &lt;/a&gt; предоставляет удобный способ решения этой проблемы путем введения маскированных массивов.</target>
        </trans-unit>
        <trans-unit id="af19adb5953933b119cf6e38053a7bd63ddf0076" translate="yes" xml:space="preserve">
          <source>In memory overlap checks, assume that operands with &lt;code&gt;NPY_ITER_OVERLAP_ASSUME_ELEMENTWISE&lt;/code&gt; enabled are accessed only in the iterator order.</source>
          <target state="translated">При проверке перекрытия памяти предположим, что операнды с включенным &lt;code&gt;NPY_ITER_OVERLAP_ASSUME_ELEMENTWISE&lt;/code&gt; доступны только в порядке итератора.</target>
        </trans-unit>
        <trans-unit id="763b6e76c1532989efe227d788422ad02bd06f94" translate="yes" xml:space="preserve">
          <source>In normal buffering, the size of each inner loop is equal to the buffer size, or possibly larger if &lt;a href=&quot;#c.NPY_ITER_GROWINNER&quot;&gt;&lt;code&gt;NPY_ITER_GROWINNER&lt;/code&gt;&lt;/a&gt; is specified. If &lt;a href=&quot;#c.NPY_ITER_REDUCE_OK&quot;&gt;&lt;code&gt;NPY_ITER_REDUCE_OK&lt;/code&gt;&lt;/a&gt; is enabled and a reduction occurs, the inner loops may become smaller depending on the structure of the reduction.</source>
          <target state="translated">При нормальной буферизации размер каждого внутреннего цикла равен размеру буфера или, возможно, больше, если &lt;a href=&quot;#c.NPY_ITER_GROWINNER&quot;&gt; &lt;code&gt;NPY_ITER_GROWINNER&lt;/code&gt; &lt;/a&gt; . Если &lt;a href=&quot;#c.NPY_ITER_REDUCE_OK&quot;&gt; &lt;code&gt;NPY_ITER_REDUCE_OK&lt;/code&gt; &lt;/a&gt; включен и происходит сокращение, внутренние циклы могут стать меньше в зависимости от структуры сокращения.</target>
        </trans-unit>
        <trans-unit id="2c60bcd4aa111fe243ec4d9e38a39cdb9410fc32" translate="yes" xml:space="preserve">
          <source>In numpy versions &amp;gt;= 1.7.0 the &lt;code&gt;basis&lt;/code&gt; and &lt;code&gt;cast&lt;/code&gt; class methods are also available. The cast method works like the convert method while the basis method returns the basis polynomial of given degree:</source>
          <target state="translated">В Numpy версии&amp;gt; = 1.7.0 на &lt;code&gt;basis&lt;/code&gt; и &lt;code&gt;cast&lt;/code&gt; методы класса также доступны. Метод cast работает так же, как и метод convert, в то время как базовый метод возвращает базисный полином заданной степени:</target>
        </trans-unit>
        <trans-unit id="9a36a11020261b9ce301df38d29f32b272d351ef" translate="yes" xml:space="preserve">
          <source>In order to add a Python package to SciPy, its build script (&lt;code&gt;setup.py&lt;/code&gt;) must meet certain requirements. The most important requirement is that the package define a &lt;code&gt;configuration(parent_package='',top_path=None)&lt;/code&gt; function which returns a dictionary suitable for passing to &lt;code&gt;numpy.distutils.core.setup(..)&lt;/code&gt;. To simplify the construction of this dictionary, &lt;code&gt;numpy.distutils.misc_util&lt;/code&gt; provides the &lt;code&gt;Configuration&lt;/code&gt; class, described below.</source>
          <target state="translated">Чтобы добавить пакет Python в SciPy, его сценарий сборки ( &lt;code&gt;setup.py&lt;/code&gt; ) должен соответствовать определенным требованиям. Наиболее важным требованием является определение в пакете функции &lt;code&gt;configuration(parent_package='',top_path=None)&lt;/code&gt; которая возвращает словарь, подходящий для перехода к &lt;code&gt;numpy.distutils.core.setup(..)&lt;/code&gt; . Чтобы упростить создание этого словаря, &lt;code&gt;numpy.distutils.misc_util&lt;/code&gt; предоставляет класс &lt;code&gt;Configuration&lt;/code&gt; , описанный ниже.</target>
        </trans-unit>
        <trans-unit id="d5eaeb15f58484d8774fc878d68cb55c966f0844" translate="yes" xml:space="preserve">
          <source>In order to make use of the C-API from another extension module, the &lt;a href=&quot;#c.import_array&quot;&gt;&lt;code&gt;import_array&lt;/code&gt;&lt;/a&gt; function must be called. If the extension module is self-contained in a single .c file, then that is all that needs to be done. If, however, the extension module involves multiple files where the C-API is needed then some additional steps must be taken.</source>
          <target state="translated">Чтобы использовать C-API из другого модуля расширения, необходимо &lt;a href=&quot;#c.import_array&quot;&gt; &lt;code&gt;import_array&lt;/code&gt; &lt;/a&gt; функцию import_array . Если модуль расширения находится в отдельном файле .c, то это все, что нужно сделать. Если, однако, модуль расширения включает несколько файлов, в которых требуется C-API, необходимо предпринять некоторые дополнительные шаги.</target>
        </trans-unit>
        <trans-unit id="c34adc34291107e6d105c5cd2a716fc5c0f9914c" translate="yes" xml:space="preserve">
          <source>In order to pay-off (i.e., have a future-value of 0) the $200,000 obtained today, a monthly payment of $1,854.02 would be required. Note that this example illustrates usage of &lt;a href=&quot;numpy.fv#numpy.fv&quot;&gt;&lt;code&gt;fv&lt;/code&gt;&lt;/a&gt; having a default value of 0.</source>
          <target state="translated">Чтобы выплатить (т. Е. Иметь будущую стоимость 0) 200 000 долларов, полученных сегодня, потребуется ежемесячный платеж в размере 1 854,02 доллара. Обратите внимание, что этот пример иллюстрирует использование &lt;a href=&quot;numpy.fv#numpy.fv&quot;&gt; &lt;code&gt;fv&lt;/code&gt; &lt;/a&gt; со значением по умолчанию 0.</target>
        </trans-unit>
        <trans-unit id="cdf699c411308f89c9b3b067e51b1e307dfb7a9f" translate="yes" xml:space="preserve">
          <source>In other words, &lt;code&gt;flags = divide + 2*over + 4*under + 8*invalid&lt;/code&gt;.</source>
          <target state="translated">Другими словами, &lt;code&gt;flags = divide + 2*over + 4*under + 8*invalid&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f91eee16dbc3f050fa038e2c5209d53822e69e47" translate="yes" xml:space="preserve">
          <source>In other words, each entry &lt;code&gt;out[i,j,...,:]&lt;/code&gt; is an N-dimensional value drawn from the distribution.</source>
          <target state="translated">Другими словами, каждая запись &lt;code&gt;out[i,j,...,:]&lt;/code&gt; представляет собой N-мерное значение, полученное из распределения.</target>
        </trans-unit>
        <trans-unit id="b7dcdc5e279e7f5cb5fcdbe1eac1b3a0742ee26b" translate="yes" xml:space="preserve">
          <source>In other words, the usage of info is exactly the same as when using blas_info and co.</source>
          <target state="translated">Другими словами,использование информации точно такое же,как и при использовании blas_info и co.</target>
        </trans-unit>
        <trans-unit id="41f0de1dccddf6867cedf88d3dd90186911881e1" translate="yes" xml:space="preserve">
          <source>In our examples, we will treat the input array with a complex data type, so that we can take square roots of negative numbers. Without enabling copies or buffering mode, the iterator will raise an exception if the data type doesn&amp;rsquo;t match precisely.</source>
          <target state="translated">В наших примерах мы будем рассматривать входной массив со сложным типом данных, чтобы мы могли извлекать квадратные корни из отрицательных чисел. Без включения копирования или режима буферизации итератор вызовет исключение, если тип данных не соответствует точно.</target>
        </trans-unit>
        <trans-unit id="f02a14688f33a1cd645cff2ad5ad3ea73913fd03" translate="yes" xml:space="preserve">
          <source>In place operations will perform the calculation using the precision decided by the data type of the two operands, but will silently downcast the result (if necessary) so it can fit back into the array. Therefore, for mixed precision calculations, &lt;code&gt;A {op}=
B&lt;/code&gt; can be different than &lt;code&gt;A = A {op} B&lt;/code&gt;. For example, suppose &lt;code&gt;a = ones((3,3))&lt;/code&gt;. Then, &lt;code&gt;a += 3j&lt;/code&gt; is different than &lt;code&gt;a = a +
3j&lt;/code&gt;: while they both perform the same computation, &lt;code&gt;a += 3&lt;/code&gt; casts the result to fit back in &lt;code&gt;a&lt;/code&gt;, whereas &lt;code&gt;a = a + 3j&lt;/code&gt; re-binds the name &lt;code&gt;a&lt;/code&gt; to the result.</source>
          <target state="translated">Операции на месте будут выполнять вычисление с использованием точности, определяемой типом данных двух операндов, но автоматически понижают результат (при необходимости), чтобы он мог снова поместиться в массив. Таким образом, для смешанных точности расчетов, &lt;code&gt;A {op}= B&lt;/code&gt; может быть иным , чем &lt;code&gt;A = A {op} B&lt;/code&gt; . Например, предположим, что &lt;code&gt;a = ones((3,3))&lt;/code&gt; . Тогда &lt;code&gt;a += 3j&lt;/code&gt; отличается от &lt;code&gt;a = a + 3j&lt;/code&gt; : в то время как они оба выполняют одно и то же вычисление, &lt;code&gt;a += 3&lt;/code&gt; приводит результат, чтобы он уместился обратно в &lt;code&gt;a&lt;/code&gt; , тогда как &lt;code&gt;a = a + 3j&lt;/code&gt; повторно связывает имя &lt;code&gt;a&lt;/code&gt; с результат.</target>
        </trans-unit>
        <trans-unit id="211d3795b0d3cedf14ae00bfdd7e3e38d86df021" translate="yes" xml:space="preserve">
          <source>In prior versions of NumPy, the datetime64 type always stored times in UTC. By default, creating a datetime64 object from a string or printing it would convert from or to local time:</source>
          <target state="translated">В предыдущих версиях NumPy тип datetime64 всегда хранил время по UTC.По умолчанию создание объекта datetime64 из строки или вывод его на печать приведет к преобразованию из локального времени или в локальное время:</target>
        </trans-unit>
        <trans-unit id="bb94af890255a1752661e16a2eacce9c1ad12713" translate="yes" xml:space="preserve">
          <source>In row-major, C-style order, in two dimensions, the row index varies the slowest, and the column index the quickest. This can be generalized to multiple dimensions, where row-major order implies that the index along the first axis varies slowest, and the index along the last quickest. The opposite holds for column-major, Fortran-style index ordering.</source>
          <target state="translated">В порядке строк-мажор,в С-стиле,в двух измерениях,строковый индекс изменяется медленнее всего,а столбец индекса-быстрее всего.Это можно обобщить до нескольких измерений,где порядок следования рядов предполагает,что индекс по первой оси изменяется медленнее всего,а индекс по последней-быстрее всего.Противоположное значение имеет порядок следования столбцов,в стиле Фортран.</target>
        </trans-unit>
        <trans-unit id="507aaff0e5cc21d7011bc819d2bd20f0b309484f" translate="yes" xml:space="preserve">
          <source>In single precision, &lt;a href=&quot;#numpy.mean&quot;&gt;&lt;code&gt;mean&lt;/code&gt;&lt;/a&gt; can be inaccurate:</source>
          <target state="translated">При одинарной точности &lt;a href=&quot;#numpy.mean&quot;&gt; &lt;code&gt;mean&lt;/code&gt; &lt;/a&gt; может быть неточным:</target>
        </trans-unit>
        <trans-unit id="9b1dbcac5dd55e1c7b0ed7b38aff1c0737c2f620" translate="yes" xml:space="preserve">
          <source>In single precision, std() can be inaccurate:</source>
          <target state="translated">При одинаковой точности std()может быть неточным:</target>
        </trans-unit>
        <trans-unit id="ca04a495cdff9e1119115547af374f5b2a4d64ac" translate="yes" xml:space="preserve">
          <source>In single precision, var() can be inaccurate:</source>
          <target state="translated">При одинаковой точности var()может быть неточным:</target>
        </trans-unit>
        <trans-unit id="568553829625c2078673593fe2ee401327874ad7" translate="yes" xml:space="preserve">
          <source>In some cases, an appropriate use of the roll and the offset is necessary to get a desired answer.</source>
          <target state="translated">В некоторых случаях для получения желаемого ответа необходимо соответствующее использование вала и смещения.</target>
        </trans-unit>
        <trans-unit id="ac0960cf0185d8fe7d74b182c3299905c5bc5818" translate="yes" xml:space="preserve">
          <source>In some cases, such as structured arrays and the &lt;a href=&quot;arrays.classes#numpy.class.__array__&quot;&gt;&lt;code&gt;__array__&lt;/code&gt;&lt;/a&gt; interface, a data type needs to be used to make sense of the object. When this is needed, provide a Descr for &amp;lsquo;requested_dtype&amp;rsquo;, otherwise provide NULL. This reference is not stolen. Also, if the requested dtype doesn&amp;rsquo;t modify the interpretation of the input, out_dtype will still get the &amp;ldquo;innate&amp;rdquo; dtype of the object, not the dtype passed in &amp;lsquo;requested_dtype&amp;rsquo;.</source>
          <target state="translated">В некоторых случаях, таких как структурированные массивы и интерфейс &lt;a href=&quot;arrays.classes#numpy.class.__array__&quot;&gt; &lt;code&gt;__array__&lt;/code&gt; &lt;/a&gt; , необходимо использовать тип данных для понимания объекта. Когда это необходимо, укажите Descr для &amp;laquo;required_dtype&amp;raquo;, в противном случае укажите NULL. Эта ссылка не украдена. Кроме того, если запрошенный dtype не изменяет интерпретацию ввода, out_dtype все равно получит &amp;laquo;внутренний&amp;raquo; dtype объекта, а не dtype, переданный в &amp;laquo;required_dtype&amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="341cdd9b0329316960c0e4cc444da230117b1062" translate="yes" xml:space="preserve">
          <source>In some future release, it will return a read/write view and writing to the returned array will alter your original array. The returned array will have the same type as the input array.</source>
          <target state="translated">В некоторых последующих релизах он будет возвращать вид чтения/записи,а запись в возвращаемый массив изменит ваш оригинальный массив.Возвращаемый массив будет иметь тот же тип,что и входной массив.</target>
        </trans-unit>
        <trans-unit id="f5ee90b2a39e9fa80b16d394e14dd0a33a028120" translate="yes" xml:space="preserve">
          <source>In some situations, it is possible that you could use the &lt;code&gt;%numpy_typemaps&lt;/code&gt; macro to implement typemaps for your own types. See the &lt;a href=&quot;#other-common-types-bool&quot;&gt;Other Common Types: bool&lt;/a&gt; or &lt;a href=&quot;#other-common-types-complex&quot;&gt;Other Common Types: complex&lt;/a&gt; sections for examples. Another situation is if your dimensions are of a type other than &lt;code&gt;int&lt;/code&gt; (say &lt;code&gt;long&lt;/code&gt; for example):</source>
          <target state="translated">В некоторых ситуациях возможно, что вы можете использовать макрос &lt;code&gt;%numpy_typemaps&lt;/code&gt; для реализации карт типов для ваших собственных типов. См. Примеры в разделах &amp;laquo; &lt;a href=&quot;#other-common-types-bool&quot;&gt;Другие распространенные типы: bool&amp;raquo;&lt;/a&gt; или &amp;laquo; &lt;a href=&quot;#other-common-types-complex&quot;&gt;Другие общие типы: сложные&amp;raquo;&lt;/a&gt; . Другая ситуация, если ваши размеры имеют тип, отличный от &lt;code&gt;int&lt;/code&gt; (например, &lt;code&gt;long&lt;/code&gt; ):</target>
        </trans-unit>
        <trans-unit id="3d0c88a0902d8f4e29b2260087b409a1f0c6bbf0" translate="yes" xml:space="preserve">
          <source>In the 1-D and 0-D case, the indexing and sparse keywords have no effect.</source>
          <target state="translated">В случае 1-D и 0-D индексирование и разреженные ключевые слова не имеют эффекта.</target>
        </trans-unit>
        <trans-unit id="e263de7df2b576cf438fac441850586c983ab809" translate="yes" xml:space="preserve">
          <source>In the case of double precision tests, this will return the python function &lt;code&gt;Vector.doubleLength&lt;/code&gt;.</source>
          <target state="translated">В случае тестов двойной точности это вернет функцию Python &lt;code&gt;Vector.doubleLength&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a0240da2483005a9c53b4aad1de6618f577c43aa" translate="yes" xml:space="preserve">
          <source>In the common 2-D case (N=1), the block structure can be visualized:</source>
          <target state="translated">В общем 2-D случае (N=1)можно визуализировать структуру блока:</target>
        </trans-unit>
        <trans-unit id="e138055380190b3c93b794e532e7d0c34dce613a" translate="yes" xml:space="preserve">
          <source>In the end, which you do for Fortran or C depends on which is more important, not reordering data or preserving the indexing convention. For large images, reordering data is potentially expensive, and often the indexing convention is inverted to avoid that.</source>
          <target state="translated">В конце концов,то,что вы делаете для Fortran или C,зависит от того,что важнее,а не переупорядочивание данных или сохранение конвенции об индексировании.Для больших изображений переупорядочивание данных потенциально дорогостоящее,и часто соглашение об индексировании инвертируется,чтобы избежать этого.</target>
        </trans-unit>
        <trans-unit id="6eb66ccf87f3461ec66b2cc1735ef182a062917a" translate="yes" xml:space="preserve">
          <source>In the file, array data starts at this offset. Since &lt;code&gt;offset&lt;/code&gt; is measured in bytes, it should normally be a multiple of the byte-size of &lt;a href=&quot;numpy.dtype#numpy.dtype&quot;&gt;&lt;code&gt;dtype&lt;/code&gt;&lt;/a&gt;. When &lt;code&gt;mode != 'r'&lt;/code&gt;, even positive offsets beyond end of file are valid; The file will be extended to accommodate the additional data. By default, &lt;code&gt;memmap&lt;/code&gt; will start at the beginning of the file, even if &lt;code&gt;filename&lt;/code&gt; is a file pointer &lt;code&gt;fp&lt;/code&gt; and &lt;code&gt;fp.tell() != 0&lt;/code&gt;.</source>
          <target state="translated">В файле данные массива начинаются с этого смещения. Поскольку &lt;code&gt;offset&lt;/code&gt; измеряется в байтах, обычно оно должно быть кратно размеру байта &lt;a href=&quot;numpy.dtype#numpy.dtype&quot;&gt; &lt;code&gt;dtype&lt;/code&gt; &lt;/a&gt; . Когда &lt;code&gt;mode != 'r'&lt;/code&gt; , допустимы даже положительные смещения за пределами конца файла; Файл будет расширен для размещения дополнительных данных. По умолчанию &lt;code&gt;memmap&lt;/code&gt; запускается в начале файла, даже если &lt;code&gt;filename&lt;/code&gt; является указателем файла &lt;code&gt;fp&lt;/code&gt; и &lt;code&gt;fp.tell() != 0&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6d51d7e744b66162bcb271fa8e86dbafebc0e214" translate="yes" xml:space="preserve">
          <source>In the first case the lower bound of the integration is set to -1 and the integration constant is 0. In the second the constant of integration is set to 1 as well. Differentiation is simpler since the only option is the number of times the polynomial is differentiated:</source>
          <target state="translated">В первом случае нижняя граница интегрирования устанавливается равной -1,а константа интегрирования-0,во втором константа интегрирования также устанавливается равной 1.Дифференциация проще,так как единственный вариант-это число раз дифференцирования многочлена:</target>
        </trans-unit>
        <trans-unit id="39042dbdcabf0496e03a08644bb7e129fe61d278" translate="yes" xml:space="preserve">
          <source>In the first case, the dimensions resulting from the advanced indexing operation come first in the result array, and the subspace dimensions after that. In the second case, the dimensions from the advanced indexing operations are inserted into the result array at the same spot as they were in the initial array (the latter logic is what makes simple advanced indexing behave just like slicing).</source>
          <target state="translated">В первом случае в результирующем массиве сначала идут размеры,полученные в результате операции расширенной индексации,а затем-размеры подпространства.Во втором случае размеры,полученные в результате операции расширенной индексации,вставляются в результирующий массив в том же месте,где они были в исходном массиве (вторая логика заставляет простую расширенную индексацию вести себя так же,как и нарезку).</target>
        </trans-unit>
        <trans-unit id="fee9951c9cac899e8dc4b73ca21eaf580eee1e11" translate="yes" xml:space="preserve">
          <source>In the following descriptions, we reference a generic &lt;code&gt;DATA_TYPE&lt;/code&gt;, which could be any of the C data types listed above, and &lt;code&gt;DIM_TYPE&lt;/code&gt; which should be one of the many types of integers.</source>
          <target state="translated">В следующих описаниях мы &lt;code&gt;DATA_TYPE&lt;/code&gt; на общий DATA_TYPE , который может быть любым из типов данных C, перечисленных выше, и на &lt;code&gt;DIM_TYPE&lt;/code&gt; , который должен быть одним из многих типов целых чисел.</target>
        </trans-unit>
        <trans-unit id="1dc319444395eeb97927a05649519246dd32d72d" translate="yes" xml:space="preserve">
          <source>In the past most implementations used the &amp;ldquo;desc&amp;rdquo; member of the &lt;code&gt;PyCObject&lt;/code&gt; itself (do not confuse this with the &amp;ldquo;descr&amp;rdquo; member of the &lt;a href=&quot;c-api.types-and-structures#c.PyArrayInterface&quot;&gt;&lt;code&gt;PyArrayInterface&lt;/code&gt;&lt;/a&gt; structure above &amp;mdash; they are two separate things) to hold the pointer to the object exposing the interface. This is now an explicit part of the interface. Be sure to own a reference to the object when the &lt;code&gt;PyCObject&lt;/code&gt; is created using &lt;code&gt;PyCObject_FromVoidPtrAndDesc&lt;/code&gt;.</source>
          <target state="translated">В прошлом большинство реализаций использовали член &amp;laquo;desc&amp;raquo; самого &lt;code&gt;PyCObject&lt;/code&gt; (не путайте его с членом &amp;laquo; &lt;a href=&quot;c-api.types-and-structures#c.PyArrayInterface&quot;&gt; &lt;code&gt;PyArrayInterface&lt;/code&gt; &lt;/a&gt; структуры PyArrayInterface выше - это две разные вещи) для хранения указателя на объект, открывающий интерфейс. Теперь это явная часть интерфейса. Убедитесь, что у вас есть ссылка на объект, когда &lt;code&gt;PyCObject&lt;/code&gt; создается с помощью &lt;code&gt;PyCObject_FromVoidPtrAndDesc&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="cfcf82ced52f76044f84d6258de886b7808506ff" translate="yes" xml:space="preserve">
          <source>In the range -1 &amp;lt;= &lt;code&gt;x&lt;/code&gt; &amp;lt;= 1 they are nice, equiripple functions lying between +/- 1. The same plots over the range -2 &amp;lt;= &lt;code&gt;x&lt;/code&gt; &amp;lt;= 2 look very different:</source>
          <target state="translated">В диапазоне -1 &amp;lt;= &lt;code&gt;x&lt;/code&gt; &amp;lt;= 1 они хороши, равноправные функции, лежащие между +/- 1. Те ​​же самые графики в диапазоне -2 &amp;lt;= &lt;code&gt;x&lt;/code&gt; &amp;lt;= 2 выглядят совсем по-другому:</target>
        </trans-unit>
        <trans-unit id="9664dec4c702af778eb236a77580a7bb3b836b54" translate="yes" xml:space="preserve">
          <source>In the simplest case, there is only a &lt;em&gt;single&lt;/em&gt; advanced index. A single advanced index can for example replace a slice and the result array will be the same, however, it is a copy and may have a different memory layout. A slice is preferable when it is possible.</source>
          <target state="translated">В простейшем случае есть только &lt;em&gt;один&lt;/em&gt; расширенный индекс. Один расширенный индекс может, например, заменить срез, и массив результатов будет таким же, однако это копия и может иметь другое расположение памяти. Ломтик предпочтительнее, когда это возможно.</target>
        </trans-unit>
        <trans-unit id="d8a45b3135fa0c84b41da4d210f43fe96826517e" translate="yes" xml:space="preserve">
          <source>In the tables below, &lt;code&gt;platform?&lt;/code&gt; means that the type may not be available on all platforms. Compatibility with different C or Python types is indicated: two types are compatible if their data is of the same size and interpreted in the same way.</source>
          <target state="translated">В таблицах ниже &lt;code&gt;platform?&lt;/code&gt; означает, что этот тип может быть доступен не на всех платформах. Указывается совместимость с разными типами C или Python: два типа совместимы, если их данные имеют одинаковый размер и интерпретируются одинаково.</target>
        </trans-unit>
        <trans-unit id="65a0a52b3e0dac0b940f22ccbd59e595b0b91828" translate="yes" xml:space="preserve">
          <source>In this calculation, we can ignore the amount of numbers drawn from each stream. Each of the PRNGs we provide has some extra protection built in that avoids overlaps if the &lt;a href=&quot;bit_generators/generated/numpy.random.seedsequence#numpy.random.SeedSequence&quot;&gt;&lt;code&gt;SeedSequence&lt;/code&gt;&lt;/a&gt; pools differ in the slightest bit. &lt;a href=&quot;bit_generators/pcg64#numpy.random.pcg64.PCG64&quot;&gt;&lt;code&gt;PCG64&lt;/code&gt;&lt;/a&gt; has</source>
          <target state="translated">В этом расчете мы можем игнорировать количество чисел, взятых из каждого потока. Каждый из предоставляемых нами PRNG имеет некоторую дополнительную встроенную защиту, позволяющую избежать перекрытия, если пулы &lt;a href=&quot;bit_generators/generated/numpy.random.seedsequence#numpy.random.SeedSequence&quot;&gt; &lt;code&gt;SeedSequence&lt;/code&gt; &lt;/a&gt; отличаются в малейшем бите. &lt;a href=&quot;bit_generators/pcg64#numpy.random.pcg64.PCG64&quot;&gt; &lt;code&gt;PCG64&lt;/code&gt; &lt;/a&gt; имеет</target>
        </trans-unit>
        <trans-unit id="89c8dba17ad2bf90a54597788476417de6721a53" translate="yes" xml:space="preserve">
          <source>In this case, we wanted to test solving a linear algebra problem using matrices of several data types, using &lt;code&gt;linalg.solve&lt;/code&gt; and &lt;code&gt;linalg.inv&lt;/code&gt;. The common test cases (for single-precision, double-precision, etc. matrices) are collected in &lt;code&gt;LinalgTestCase&lt;/code&gt;.</source>
          <target state="translated">В этом случае мы хотели протестировать решение задачи линейной алгебры с использованием матриц нескольких типов данных, используя &lt;code&gt;linalg.solve&lt;/code&gt; и &lt;code&gt;linalg.inv&lt;/code&gt; . Общие тестовые примеры (для матриц с одинарной точностью, двойной точностью и т. Д.) Собраны в &lt;code&gt;LinalgTestCase&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a876e5a0c738a8e265b4a962587a67aa3cabc3ca" translate="yes" xml:space="preserve">
          <source>In this chapter routine docstrings are presented, grouped by functionality. Many docstrings contain example code, which demonstrates basic usage of the routine. The examples assume that NumPy is imported with:</source>
          <target state="translated">В этой главе представлены обычные док-строки,сгруппированные по функциональности.Многие строки содержат пример кода,демонстрирующего основные принципы использования рутины.Примеры предполагают,что NumPy импортируется с:</target>
        </trans-unit>
        <trans-unit id="fb82fb6aef1a39fd7c11a037068f12eca825f3ae" translate="yes" xml:space="preserve">
          <source>In this example if &lt;code&gt;a&lt;/code&gt; is an ndarray, &amp;ldquo;fancy&amp;rdquo; indexing can be used.</source>
          <target state="translated">В этом примере, если &lt;code&gt;a&lt;/code&gt; - ndarray, можно использовать &amp;laquo;модную&amp;raquo; индексацию.</target>
        </trans-unit>
        <trans-unit id="8f824e9ad2dd27432acf7adb45ed2442b89417d6" translate="yes" xml:space="preserve">
          <source>In this example the spacing is also specified: uniform for axis=0 and non uniform for axis=1</source>
          <target state="translated">В этом примере также указано расстояние:равномерное для оси=0 и неравномерное для оси=1.</target>
        </trans-unit>
        <trans-unit id="e415859b6bc51789a95cf9e8d4d1433827763e1d" translate="yes" xml:space="preserve">
          <source>In this example, real input has an FFT which is Hermitian, i.e., symmetric in the real part and anti-symmetric in the imaginary part, as described in the &lt;a href=&quot;../routines.fft#module-numpy.fft&quot;&gt;&lt;code&gt;numpy.fft&lt;/code&gt;&lt;/a&gt; documentation:</source>
          <target state="translated">В этом примере реальный ввод имеет БПФ, которое является эрмитовым, т. &lt;a href=&quot;../routines.fft#module-numpy.fft&quot;&gt; &lt;code&gt;numpy.fft&lt;/code&gt; &lt;/a&gt; Симметричным в действительной части и антисимметричным в мнимой части, как описано в документации numpy.fft :</target>
        </trans-unit>
        <trans-unit id="7b71631798c22c7379ee16411ed600d40ef635fc" translate="yes" xml:space="preserve">
          <source>In two dimensions, the DFT is defined as</source>
          <target state="translated">В двух измерениях DFT определяется как</target>
        </trans-unit>
        <trans-unit id="e78643ae03c902815fce8ed7873dad947453bab7" translate="yes" xml:space="preserve">
          <source>In versions 1.6 and earlier of NumPy, the following flags did not have the _ARRAY_ macro namespace in them. That form of the constant names is deprecated in 1.7.</source>
          <target state="translated">В версиях 1.6 и более ранних версиях NumPy следующие флаги не имели пространства имён макроса _ARRAY_.Эта форма имен констант устарела в 1.7.</target>
        </trans-unit>
        <trans-unit id="2eb3748bd4c40ee385c34a340546b34ff09c6d0f" translate="yes" xml:space="preserve">
          <source>In versions of NumPy prior to 1.7, this function always returned a new, independent array containing a copy of the values in the diagonal.</source>
          <target state="translated">В версиях NumPy до 1.7 эта функция всегда возвращала новый,независимый массив,содержащий копию значений по диагонали.</target>
        </trans-unit>
        <trans-unit id="7e3012fb521e71655f173862b6d8385b1b505394" translate="yes" xml:space="preserve">
          <source>In-Place Arrays</source>
          <target state="translated">Массивы на месте</target>
        </trans-unit>
        <trans-unit id="4515cac8ae9188e7e6a2adf0d7162014d11595d3" translate="yes" xml:space="preserve">
          <source>In-place arrays are defined as arrays that are modified in-place. The input values may or may not be used, but the values at the time the function returns are significant. The provided Python argument must therefore be a NumPy array of the required type. The in-place signatures are</source>
          <target state="translated">Внутренние массивы определяются как массивы,которые изменяются на месте.Входные значения могут использоваться или не использоваться,но значения на момент возврата функции являются значительными.Поэтому предоставляемый аргумент Python должен быть массивом NumPy нужного типа.Входными сигнатурами являются</target>
        </trans-unit>
        <trans-unit id="e156e5cac1a2d58a18cbdda52494e20ca1917186" translate="yes" xml:space="preserve">
          <source>In-place sort.</source>
          <target state="translated">Сортировка на месте.</target>
        </trans-unit>
        <trans-unit id="e7086e912a42ead51516c8a8180bf48b02a02ed8" translate="yes" xml:space="preserve">
          <source>Incremement the index and the dataptr members of the &lt;em&gt;iterator&lt;/em&gt; to point to the next element of the array. If the array is not (C-style) contiguous, also increment the N-dimensional coordinates array.</source>
          <target state="translated">Увеличьте индекс и элементы dataptr &lt;em&gt;итератора,&lt;/em&gt; чтобы они указывали на следующий элемент массива. Если массив не является непрерывным (в стиле C), также увеличьте массив N-мерных координат.</target>
        </trans-unit>
        <trans-unit id="7a7d2f744a7296cdaea426008f157d69008c6d52" translate="yes" xml:space="preserve">
          <source>Increment items 0 and 1, and increment item 2 twice:</source>
          <target state="translated">Увеличивайте пункты 0 и 1 и дважды увеличивайте пункт 2:</target>
        </trans-unit>
        <trans-unit id="aa0f6e205ff77646c8e4c26a5cd802d06b0ed1ab" translate="yes" xml:space="preserve">
          <source>Increment the multi-dimensional index by one.</source>
          <target state="translated">Увеличьте многомерный индекс на один.</target>
        </trans-unit>
        <trans-unit id="47bbbc7bbd392dc811939b0ca8df290ae66b6625" translate="yes" xml:space="preserve">
          <source>Indeed, the fact is that Python indexing on lists and other sequences naturally leads to an outside-to inside ordering (the first index gets the largest grouping, the next the next largest, and the last gets the smallest element). Since image data are normally stored by rows, this corresponds to position within rows being the last item indexed.</source>
          <target state="translated">Действительно,дело в том,что индексирование на Python в списках и других последовательностях естественно приводит к внешнему порядку (первый индекс получает самую большую группировку,следующий-самую большую,а последний-наименьший элемент).Так как данные изображения обычно хранятся строками,это соответствует положению внутри строк,будучи последним индексируемым элементом.</target>
        </trans-unit>
        <trans-unit id="a955748860a9401904eff7aeb318142866860450" translate="yes" xml:space="preserve">
          <source>Independent Streams</source>
          <target state="translated">Независимые потоки</target>
        </trans-unit>
        <trans-unit id="1a35691c6c1bb32304626e5515963a9a6c7ec2da" translate="yes" xml:space="preserve">
          <source>Index of the diagonal: 0 (the default) refers to the main diagonal, a positive value refers to an upper diagonal, and a negative value to a lower diagonal.</source>
          <target state="translated">Индекс диагонали:0 (по умолчанию)относится к главной диагонали,положительное значение-к верхней диагонали,отрицательное-к нижней диагонали.</target>
        </trans-unit>
        <trans-unit id="119920061dcb691e0fcbed0a1783c9e871f11ec5" translate="yes" xml:space="preserve">
          <source>Index of the diagonal: 0 refers to the main diagonal, a positive value refers to an upper diagonal, and a negative value to a lower diagonal.</source>
          <target state="translated">Индекс диагонали:0 относится к главной диагонали,положительное значение-к верхней диагонали,отрицательное-к нижней диагонали.</target>
        </trans-unit>
        <trans-unit id="57f71bf775773f532dceb2dabadcde07069670df" translate="yes" xml:space="preserve">
          <source>Indexes of the maximal elements of a N-dimensional array:</source>
          <target state="translated">Индексы максимальных элементов N-мерного массива:</target>
        </trans-unit>
        <trans-unit id="c30b085b29907fc8dd1fcc4ba9d8f5fab779ff0b" translate="yes" xml:space="preserve">
          <source>Indexes of the maximum values along an axis.</source>
          <target state="translated">Индексы максимальных значений вдоль оси.</target>
        </trans-unit>
        <trans-unit id="f9b599db4bf0df8d9bbcf7c5db6a037f6e6e69aa" translate="yes" xml:space="preserve">
          <source>Indexes of the minimum values along an axis.</source>
          <target state="translated">Индексы минимальных значений вдоль оси.</target>
        </trans-unit>
        <trans-unit id="9951861c21df18489a5872209655d6f9039b5e2a" translate="yes" xml:space="preserve">
          <source>Indexing</source>
          <target state="translated">Indexing</target>
        </trans-unit>
        <trans-unit id="b59c12801d6fa741bd0be2abcd90167bf71d161c" translate="yes" xml:space="preserve">
          <source>Indexing &lt;code&gt;x['field-name']&lt;/code&gt; returns a new &lt;a href=&quot;https://docs.scipy.org/doc/numpy-1.17.0/glossary.html#term-view&quot;&gt;view&lt;/a&gt; to the array, which is of the same shape as &lt;em&gt;x&lt;/em&gt; (except when the field is a sub-array) but of data type &lt;code&gt;x.dtype['field-name']&lt;/code&gt; and contains only the part of the data in the specified field. Also &lt;a href=&quot;arrays.classes#arrays-classes-rec&quot;&gt;record array&lt;/a&gt; scalars can be &amp;ldquo;indexed&amp;rdquo; this way.</source>
          <target state="translated">Индексирование &lt;code&gt;x['field-name']&lt;/code&gt; возвращает новое &lt;a href=&quot;https://docs.scipy.org/doc/numpy-1.17.0/glossary.html#term-view&quot;&gt;представление&lt;/a&gt; массива, которое имеет ту же форму, что и &lt;em&gt;x&lt;/em&gt; (кроме случаев, когда поле является &lt;code&gt;x.dtype['field-name']&lt;/code&gt; ), но с типом данных x.dtype ['field-name'] и содержит только часть данных в указанном поле. Также &lt;a href=&quot;arrays.classes#arrays-classes-rec&quot;&gt;запись массива&lt;/a&gt; скаляров может быть &amp;laquo;проиндексирована&amp;raquo; таким образом.</target>
        </trans-unit>
        <trans-unit id="3b75e279fb5c7684c193076341ad2da99a787445" translate="yes" xml:space="preserve">
          <source>Indexing and slicing</source>
          <target state="translated">Индексирование и нарезка</target>
        </trans-unit>
        <trans-unit id="9f16e8a5deb5dca320283bcd174b16dd9a73b2c2" translate="yes" xml:space="preserve">
          <source>Indexing arrays</source>
          <target state="translated">Массивы индексирования</target>
        </trans-unit>
        <trans-unit id="287cc46fe81b17127e826e2dc4d460f956256411" translate="yes" xml:space="preserve">
          <source>Indexing into a structured array can also be done with a list of field names, &lt;em&gt;e.g.&lt;/em&gt;&lt;code&gt;x[['field-name1','field-name2']]&lt;/code&gt;. As of NumPy 1.16 this returns a view containing only those fields. In older versions of numpy it returned a copy. See the user guide section on &lt;a href=&quot;https://docs.scipy.org/doc/numpy-1.17.0/user/basics.rec.html#structured-arrays&quot;&gt;Structured arrays&lt;/a&gt; for more information on multifield indexing.</source>
          <target state="translated">Индексирование в структурированный массив также может быть выполнено с помощью списка имен полей, &lt;em&gt;например &lt;/em&gt; &lt;code&gt;x[['field-name1','field-name2']]&lt;/code&gt; . Начиная с NumPy 1.16, это возвращает представление, содержащее только эти поля. В более старых версиях numpy он возвращал копию. См. Раздел руководства пользователя о &lt;a href=&quot;https://docs.scipy.org/doc/numpy-1.17.0/user/basics.rec.html#structured-arrays&quot;&gt;структурированных массивах&lt;/a&gt; для получения дополнительной информации о многополевой индексации.</target>
        </trans-unit>
        <trans-unit id="f9931083a6e7f53e9bc486a3df5e5e7c8488e9d6" translate="yes" xml:space="preserve">
          <source>Indexing routines</source>
          <target state="translated">Индексирование</target>
        </trans-unit>
        <trans-unit id="a0b6ddf08f9938b1aef1c27a89f039c34d4ed175" translate="yes" xml:space="preserve">
          <source>Indexing-like operations</source>
          <target state="translated">Индексирующие операции</target>
        </trans-unit>
        <trans-unit id="0454b105259e523f13a84d0a1ff2499fbf44bf18" translate="yes" xml:space="preserve">
          <source>Indicate how the user of the iterator will read or write to &lt;code&gt;op[i]&lt;/code&gt;. Exactly one of these flags must be specified per operand. Using &lt;code&gt;NPY_ITER_READWRITE&lt;/code&gt; or &lt;code&gt;NPY_ITER_WRITEONLY&lt;/code&gt; for a user-provided operand may trigger &lt;code&gt;WRITEBACKIFCOPY`&lt;/code&gt; semantics. The data will be written back to the original array when &lt;code&gt;NpyIter_Deallocate&lt;/code&gt; is called.</source>
          <target state="translated">Укажите, как пользователь итератора будет читать или писать в &lt;code&gt;op[i]&lt;/code&gt; . Для каждого операнда должен быть указан ровно один из этих флагов. Использование &lt;code&gt;NPY_ITER_READWRITE&lt;/code&gt; или &lt;code&gt;NPY_ITER_WRITEONLY&lt;/code&gt; для предоставленного пользователем операнда может вызвать семантику &lt;code&gt;WRITEBACKIFCOPY`&lt;/code&gt; . Данные будут записаны обратно в исходный массив при &lt;code&gt;NpyIter_Deallocate&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ba89764e8d83fcb18f052ec54405d196f55000ee" translate="yes" xml:space="preserve">
          <source>Indicate indices of sub-arrays to remove along the specified axis.</source>
          <target state="translated">Укажите индексы подмассивов для удаления вдоль указанной оси.</target>
        </trans-unit>
        <trans-unit id="ff289ba1c19ab34e00eb1d52160a46b6efb2713b" translate="yes" xml:space="preserve">
          <source>Indicates arrays of this data-type must be converted to a list before pickling.</source>
          <target state="translated">Массивы этого типа данных перед травлением должны быть преобразованы в список.</target>
        </trans-unit>
        <trans-unit id="327748da6a9d945d96e091b8e7383b60afba1da7" translate="yes" xml:space="preserve">
          <source>Indicates memory for this data-type must be initialized (set to 0) on creation.</source>
          <target state="translated">Показывает,что память для этого типа данных должна быть инициализирована (установлена на 0)при создании.</target>
        </trans-unit>
        <trans-unit id="4bc4530525549adc3e6afe819ca6b79c82a0ab71" translate="yes" xml:space="preserve">
          <source>Indicates that arrays with a size of zero should be permitted. Since the typical iteration loop does not naturally work with zero-sized arrays, you must check that the IterSize is larger than zero before entering the iteration loop. Currently only the operands are checked, not a forced shape.</source>
          <target state="translated">Указывает на то,что массивы с размером нуля должны быть разрешены.Поскольку типичный цикл итераций естественно не работает с массивами нулевого размера,то перед входом в цикл итераций необходимо убедиться,что IterSize больше нуля.В настоящее время проверяются только операнды,а не принудительная форма.</target>
        </trans-unit>
        <trans-unit id="3f20ca03a166ca2b12eed667d0c9d43d498dcabe" translate="yes" xml:space="preserve">
          <source>Indicates that arrays with reference types (object arrays or structured arrays containing an object type) may be accepted and used in the iterator. If this flag is enabled, the caller must be sure to check whether &lt;code&gt;NpyIter_IterationNeedsAPI(iter)&lt;/code&gt; is true, in which case it may not release the GIL during iteration.</source>
          <target state="translated">Указывает, что массивы со ссылочными типами (массивы объектов или структурированные массивы, содержащие тип объекта) могут быть приняты и использованы в итераторе. Если этот флаг включен, вызывающий должен обязательно проверить, &lt;code&gt;NpyIter_IterationNeedsAPI(iter)&lt;/code&gt; ли NpyIter_IterationNeedsAPI (iter) , и в этом случае он может не освободить GIL во время итерации.</target>
        </trans-unit>
        <trans-unit id="e809396a40c3ec96fdae3328ed0a31c66576c7c0" translate="yes" xml:space="preserve">
          <source>Indicates that items of this data-type must be reference counted (using &lt;a href=&quot;https://docs.python.org/dev/c-api/refcounting.html#c.Py_INCREF&quot;&gt;&lt;code&gt;Py_INCREF&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;https://docs.python.org/dev/c-api/refcounting.html#c.Py_DECREF&quot;&gt;&lt;code&gt;Py_DECREF&lt;/code&gt;&lt;/a&gt; ).</source>
          <target state="translated">Указывает, что элементы этого типа данных должны подсчитываться по ссылкам (с использованием &lt;a href=&quot;https://docs.python.org/dev/c-api/refcounting.html#c.Py_INCREF&quot;&gt; &lt;code&gt;Py_INCREF&lt;/code&gt; &lt;/a&gt; и &lt;a href=&quot;https://docs.python.org/dev/c-api/refcounting.html#c.Py_DECREF&quot;&gt; &lt;code&gt;Py_DECREF&lt;/code&gt; &lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="03ad2756a493f01508378680f8d907e50dad0e86" translate="yes" xml:space="preserve">
          <source>Indicates that this operand is the mask to use for selecting elements when writing to operands which have the &lt;a href=&quot;#c.NPY_ITER_WRITEMASKED&quot;&gt;&lt;code&gt;NPY_ITER_WRITEMASKED&lt;/code&gt;&lt;/a&gt; flag applied to them. Only one operand may have &lt;a href=&quot;#c.NPY_ITER_ARRAYMASK&quot;&gt;&lt;code&gt;NPY_ITER_ARRAYMASK&lt;/code&gt;&lt;/a&gt; flag applied to it.</source>
          <target state="translated">Указывает, что этот операнд является маской, используемой для выбора элементов при записи в операнды, к &lt;a href=&quot;#c.NPY_ITER_WRITEMASKED&quot;&gt; &lt;code&gt;NPY_ITER_WRITEMASKED&lt;/code&gt; &lt;/a&gt; применен флаг NPY_ITER_WRITEMASKED . Только к одному &lt;a href=&quot;#c.NPY_ITER_ARRAYMASK&quot;&gt; &lt;code&gt;NPY_ITER_ARRAYMASK&lt;/code&gt; &lt;/a&gt; может быть применен флаг NPY_ITER_ARRAYMASK .</target>
        </trans-unit>
        <trans-unit id="613ac9b34fa48eda3d48ba0a932ba15f0204a86f" translate="yes" xml:space="preserve">
          <source>Indicates the item is a pointer to some other data-type</source>
          <target state="translated">Указывает на то,что элемент является указателем на какой-то другой тип данных</target>
        </trans-unit>
        <trans-unit id="6f07bb702873a42eecec00d6bf9d09bfd0c31b06" translate="yes" xml:space="preserve">
          <source>Indicates this data-type requires the Python C-API during access (so don&amp;rsquo;t give up the GIL if array access is going to be needed).</source>
          <target state="translated">Указывает, что для этого типа данных требуется Python C-API во время доступа (поэтому не отказывайтесь от GIL, если требуется доступ к массиву).</target>
        </trans-unit>
        <trans-unit id="d5ca13d01e4aee97ba5ebf7dbc18794ab7e82eae" translate="yes" xml:space="preserve">
          <source>Indicating whether the intervals include the right or the left bin edge. Default behavior is (right==False) indicating that the interval does not include the right edge. The left bin end is open in this case, i.e., bins[i-1] &amp;lt;= x &amp;lt; bins[i] is the default behavior for monotonically increasing bins.</source>
          <target state="translated">Указывает, включают ли интервалы правый или левый край бункера. Поведение по умолчанию (right == False) означает, что интервал не включает правый край. В этом случае левый конец бункера открыт, то есть бункеры [i-1] &amp;lt;= x &amp;lt;bins [i] являются поведением по умолчанию для монотонно увеличивающихся интервалов.</target>
        </trans-unit>
        <trans-unit id="ca9cfe4e704c12c6c1fa5c4b576973839a44850c" translate="yes" xml:space="preserve">
          <source>Indices can also be grouped by element.</source>
          <target state="translated">Индексы также могут быть сгруппированы по элементам.</target>
        </trans-unit>
        <trans-unit id="14ad131012032e9e04ca04f6d1ddd8fbcaa3e2c0" translate="yes" xml:space="preserve">
          <source>Indices for the upper-triangle of &lt;code&gt;arr&lt;/code&gt;.</source>
          <target state="translated">Индексы верхнего треугольника &lt;code&gt;arr&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="05056f495c02c0b518e0436ff12d0703c782c034" translate="yes" xml:space="preserve">
          <source>Indices of elements that are non-zero.</source>
          <target state="translated">Индексы элементов,которые не являются нулевыми.</target>
        </trans-unit>
        <trans-unit id="91841f1f82f1c15d4b5be121831bfdfa7d539a5a" translate="yes" xml:space="preserve">
          <source>Indices of elements that are non-zero. Indices are grouped by element.</source>
          <target state="translated">Индексы элементов,которые не являются нулевыми.Индексы сгруппированы по элементам.</target>
        </trans-unit>
        <trans-unit id="b94c56d6a6bfbdfee7bbd9db799f4cac5be86fa1" translate="yes" xml:space="preserve">
          <source>Indices of the minimum elements of a N-dimensional array:</source>
          <target state="translated">Индексы минимальных элементов N-мерного массива:</target>
        </trans-unit>
        <trans-unit id="764406c1c2d21f5c9a93e6d3d66afbc9de92b722" translate="yes" xml:space="preserve">
          <source>Indices of the sorted elements of a N-dimensional array:</source>
          <target state="translated">Индексы отсортированных элементов N-мерного массива:</target>
        </trans-unit>
        <trans-unit id="d010fa85fcc511735fc1ba118d8c9fa77c46fb33" translate="yes" xml:space="preserve">
          <source>Indices to change along each 1d slice of &lt;code&gt;arr&lt;/code&gt;. This must match the dimension of arr, but dimensions in Ni and Nj may be 1 to broadcast against &lt;code&gt;arr&lt;/code&gt;.</source>
          <target state="translated">Индексы для изменения вдоль каждого 1d среза &lt;code&gt;arr&lt;/code&gt; . Он должен соответствовать размеру arr, но размеры в Ni и Nj могут быть равны 1 для передачи по &lt;code&gt;arr&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="bd4ed66b25e3e81f7c09020b3e15317e8ebab751" translate="yes" xml:space="preserve">
          <source>Indices to take along each 1d slice of &lt;code&gt;arr&lt;/code&gt;. This must match the dimension of arr, but dimensions Ni and Nj only need to broadcast against &lt;code&gt;arr&lt;/code&gt;.</source>
          <target state="translated">Индексы, которые нужно брать с собой каждый 1d кусок &lt;code&gt;arr&lt;/code&gt; . Он должен соответствовать размеру arr, но размеры Ni и Nj необходимо транслировать только против &lt;code&gt;arr&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7dfac1d76acfef8a43ec3bb5c63e278bd2c2aa5a" translate="yes" xml:space="preserve">
          <source>Indirect partial sort.</source>
          <target state="translated">Косвенная частичная сортировка.</target>
        </trans-unit>
        <trans-unit id="67b91131b038b258475621be16da6d4bad633d9d" translate="yes" xml:space="preserve">
          <source>Indirect partition.</source>
          <target state="translated">Косвенное разделение.</target>
        </trans-unit>
        <trans-unit id="ceed8c74919b3d66cbcd799fe2d4bb252d0af6a7" translate="yes" xml:space="preserve">
          <source>Indirect sort.</source>
          <target state="translated">Косвенный сорт.</target>
        </trans-unit>
        <trans-unit id="7a7f09efc9fe3734b3bf1afc86adc2e542a21680" translate="yes" xml:space="preserve">
          <source>Indirect stable sort on multiple keys.</source>
          <target state="translated">Косвенная стабильная сортировка по нескольким клавишам.</target>
        </trans-unit>
        <trans-unit id="80cc0e6eec2203fc2c38742d008a3fb864036a7b" translate="yes" xml:space="preserve">
          <source>Indirect stable sort with multiple keys.</source>
          <target state="translated">Косвенная стабильная сортировка с несколькими ключами.</target>
        </trans-unit>
        <trans-unit id="8e9e048443c76eaece9af376ed6551264b94a4e9" translate="yes" xml:space="preserve">
          <source>Individual values are not stripped of spaces by default. When using a custom converter, make sure the function does remove spaces.</source>
          <target state="translated">Отдельные значения по умолчанию не лишаются пробелов.При использовании пользовательского конвертера убедитесь,что функция действительно удаляет пробелы.</target>
        </trans-unit>
        <trans-unit id="ecae1f8d30472c9a7f54d4130dc7c3b85605f125" translate="yes" xml:space="preserve">
          <source>Info are easily retrieved from the &lt;code&gt;get_info&lt;/code&gt; function in &lt;a href=&quot;#module-numpy.distutils.misc_util&quot;&gt;&lt;code&gt;numpy.distutils.misc_util&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">Информация легко извлекаются из &lt;code&gt;get_info&lt;/code&gt; функции в &lt;a href=&quot;#module-numpy.distutils.misc_util&quot;&gt; &lt;code&gt;numpy.distutils.misc_util&lt;/code&gt; &lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="ce47f6aad749dde8c374d70dfb4bb3378d690b1b" translate="yes" xml:space="preserve">
          <source>Information (via the dtype object) about the interpretation of the basic data element. The basic data element may be as simple as a int or a float, or it may be a compound object (e.g., struct-like), a fixed character field, or Python object pointers.</source>
          <target state="translated">Информация (через объект dtype)об интерпретации элемента основных данных.Базовый элемент данных может быть таким же простым,как int или float,или же это может быть составной объект (например,структурно-подобный),фиксированное символьное поле или указатели на Python-объект.</target>
        </trans-unit>
        <trans-unit id="87749b5a0427424240dbd899baaf24bccac8d963" translate="yes" xml:space="preserve">
          <source>Information about sub-data-types in a &lt;a href=&quot;https://docs.scipy.org/doc/numpy-1.17.0/glossary.html#term-structured-data-type&quot;&gt;structured data type&lt;/a&gt;:</source>
          <target state="translated">Информация о подтипах в &lt;a href=&quot;https://docs.scipy.org/doc/numpy-1.17.0/glossary.html#term-structured-data-type&quot;&gt;структурированном типе данных&lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="feb91fe9e3a82284bbc774141950eade27079231" translate="yes" xml:space="preserve">
          <source>Information about the memory layout of the array.</source>
          <target state="translated">Информация о компоновке памяти массива.</target>
        </trans-unit>
        <trans-unit id="b590718892221849c4b4d49b1a5feaa2b8ce90e3" translate="yes" xml:space="preserve">
          <source>Initialize all function pointers and members to &lt;code&gt;NULL&lt;/code&gt;.</source>
          <target state="translated">Инициализируйте все указатели функций и члены до &lt;code&gt;NULL&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="32bc5b2fd4039aefa8f94877a70e63431f9d15f4" translate="yes" xml:space="preserve">
          <source>Inner product</source>
          <target state="translated">Внутренний продукт</target>
        </trans-unit>
        <trans-unit id="1dba54e0b565dd813bcf7f4dd26137c8252036b6" translate="yes" xml:space="preserve">
          <source>Inner product of two arrays.</source>
          <target state="translated">Внутренний продукт из двух массивов.</target>
        </trans-unit>
        <trans-unit id="064057f93ed4cdc0c2704e960d9c6d25cbbcac22" translate="yes" xml:space="preserve">
          <source>Inplace partition.</source>
          <target state="translated">Вставьте раздел.</target>
        </trans-unit>
        <trans-unit id="5afc0baf08aba247f1b2f3cdc0980c0ea2b6e83d" translate="yes" xml:space="preserve">
          <source>Inplace sort.</source>
          <target state="translated">Поставь на место.</target>
        </trans-unit>
        <trans-unit id="d72a097ccb9c0003ebff6189ebb422b954b438f2" translate="yes" xml:space="preserve">
          <source>Input 1-D &lt;a href=&quot;../maskedarray.baseclass#numpy.ma.MaskedArray&quot;&gt;&lt;code&gt;MaskedArray&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">Входной 1-D &lt;a href=&quot;../maskedarray.baseclass#numpy.ma.MaskedArray&quot;&gt; &lt;code&gt;MaskedArray&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="80930bf11175241ae29fe59d0d272e2dd3fda246" translate="yes" xml:space="preserve">
          <source>Input &lt;a href=&quot;../maskedarray.baseclass#numpy.ma.MaskedArray&quot;&gt;&lt;code&gt;MaskedArray&lt;/code&gt;&lt;/a&gt; for which the mask is required.</source>
          <target state="translated">Входной &lt;a href=&quot;../maskedarray.baseclass#numpy.ma.MaskedArray&quot;&gt; &lt;code&gt;MaskedArray&lt;/code&gt; ,&lt;/a&gt; для которого требуется маска.</target>
        </trans-unit>
        <trans-unit id="abfa0de453f55ea46910c5cb072561c46c566eda" translate="yes" xml:space="preserve">
          <source>Input &lt;code&gt;MaskedArray&lt;/code&gt;, alternatively a ndarray or a subclass thereof.</source>
          <target state="translated">Введите &lt;code&gt;MaskedArray&lt;/code&gt; , альтернативно ndarray или его подкласс.</target>
        </trans-unit>
        <trans-unit id="ef6caaf1ffac65c55e3879237f23b9e4cd5b35fe" translate="yes" xml:space="preserve">
          <source>Input Arrays</source>
          <target state="translated">Массивы ввода</target>
        </trans-unit>
        <trans-unit id="c77783bb0c7d4d2f9b2b8bd6478b069981c0866f" translate="yes" xml:space="preserve">
          <source>Input and output</source>
          <target state="translated">Вход и выход</target>
        </trans-unit>
        <trans-unit id="43fab0b785a955e5195e8f3f11f33f3ad7b432bc" translate="yes" xml:space="preserve">
          <source>Input argument, can be of any type and shape.</source>
          <target state="translated">Входной аргумент,может быть любого типа и формы.</target>
        </trans-unit>
        <trans-unit id="df78d5709935001a8bf74fe47ed30fca9beafae5" translate="yes" xml:space="preserve">
          <source>Input array</source>
          <target state="translated">Массив ввода</target>
        </trans-unit>
        <trans-unit id="d573fb86d82f5065edfc4ca49f5112f03928d672" translate="yes" xml:space="preserve">
          <source>Input array in degrees.</source>
          <target state="translated">Входной массив в градусах.</target>
        </trans-unit>
        <trans-unit id="c7b020a842b9509ee12f3acbb189d43b5a5c8e2b" translate="yes" xml:space="preserve">
          <source>Input array in radians.</source>
          <target state="translated">Входной массив в радианах.</target>
        </trans-unit>
        <trans-unit id="f139b5d61b47039d6645fe901089b8d7348e059e" translate="yes" xml:space="preserve">
          <source>Input array of size 1.</source>
          <target state="translated">Входной массив размера 1.</target>
        </trans-unit>
        <trans-unit id="4fabb62ebf0299b3a11dc8870c6ebb3a76ef6ff9" translate="yes" xml:space="preserve">
          <source>Input array of strings to capitalize.</source>
          <target state="translated">Введите массив строк с заглавной буквы.</target>
        </trans-unit>
        <trans-unit id="8088eb90e795502e434844cfa6cdf9e95d4c9437" translate="yes" xml:space="preserve">
          <source>Input array of the same size as &lt;code&gt;condition&lt;/code&gt;.</source>
          <target state="translated">Входной массив того же размера, что и &lt;code&gt;condition&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f46407fd3e6fc3c69904fb1af7940d31883ac983" translate="yes" xml:space="preserve">
          <source>Input array or object that can be converted to an array, containing nan values to be ignored</source>
          <target state="translated">Входной массив или объект,который может быть преобразован в массив,содержащий нано-значения,которые следует игнорировать.</target>
        </trans-unit>
        <trans-unit id="49d0fb63038b2721f65a3fb79be1b2a9aa62e9d2" translate="yes" xml:space="preserve">
          <source>Input array or object that can be converted to an array, containing nan values to be ignored.</source>
          <target state="translated">Входной массив или объект,который может быть преобразован в массив,содержащий нано-значения,которые следует игнорировать.</target>
        </trans-unit>
        <trans-unit id="1e12f84194e4961e84959b469b0f8a65e2620351" translate="yes" xml:space="preserve">
          <source>Input array or object that can be converted to an array.</source>
          <target state="translated">Входной массив или объект,который может быть преобразован в массив.</target>
        </trans-unit>
        <trans-unit id="a14df91a899a43d15ec0d5b0ebc8a2a56f832cef" translate="yes" xml:space="preserve">
          <source>Input array to be binned. Prior to NumPy 1.10.0, this array had to be 1-dimensional, but can now have any shape.</source>
          <target state="translated">Входной массив,который должен быть скомпонован.До NumPy 1.10.0 этот массив должен был быть 1-мерным,но теперь может иметь любую форму.</target>
        </trans-unit>
        <trans-unit id="bf15a8f66c7dacebdd89b7241fd4d11919829ad3" translate="yes" xml:space="preserve">
          <source>Input array to compute determinants for.</source>
          <target state="translated">Входной массив для вычисления детерминант.</target>
        </trans-unit>
        <trans-unit id="7e287445198fc945368949e1412f5d8cb686139f" translate="yes" xml:space="preserve">
          <source>Input array to integrate.</source>
          <target state="translated">Входной массив для интеграции.</target>
        </trans-unit>
        <trans-unit id="42226304be73817a4e285cb433d2b7bb659c59a4" translate="yes" xml:space="preserve">
          <source>Input array with datetime or timedelta data type.</source>
          <target state="translated">Входной массив с типом данных datetime или timedelta.</target>
        </trans-unit>
        <trans-unit id="7c1847566b14607f43160463914cca58e1d1e0d6" translate="yes" xml:space="preserve">
          <source>Input array, a (subclass of) ndarray.</source>
          <target state="translated">Входной массив,(подкласс)ndarray.</target>
        </trans-unit>
        <trans-unit id="a4f57e9a75e6d26f7e8f35eb55623a7c6ae8a1b9" translate="yes" xml:space="preserve">
          <source>Input array, can be complex</source>
          <target state="translated">Входной массив,может быть сложным</target>
        </trans-unit>
        <trans-unit id="1b7a137c8182cfa54895f3372cda87fe7e3932e7" translate="yes" xml:space="preserve">
          <source>Input array, can be complex.</source>
          <target state="translated">Входной массив,может быть сложным.</target>
        </trans-unit>
        <trans-unit id="6d76cf24117a4b5288f54769d468e637657f37e2" translate="yes" xml:space="preserve">
          <source>Input array, from which the diagonals are taken.</source>
          <target state="translated">Входной массив,из которого берутся диагонали.</target>
        </trans-unit>
        <trans-unit id="2204886fc1fe79484a18e95229b508e3a16d8a88" translate="yes" xml:space="preserve">
          <source>Input array, has to be a square 2-D array.</source>
          <target state="translated">Входной массив,должен быть квадратным 2-D массивом.</target>
        </trans-unit>
        <trans-unit id="4e7ee35a9b27cc189fd5faf36b937d455a1aa919" translate="yes" xml:space="preserve">
          <source>Input array, must be at least 2-D.</source>
          <target state="translated">Входной массив должен быть как минимум 2-D.</target>
        </trans-unit>
        <trans-unit id="b7ba46399772c3a420055c71f8f5dda1e65da7f0" translate="yes" xml:space="preserve">
          <source>Input array, taken to be real.</source>
          <target state="translated">Входной массив,воспринимается как реальный.</target>
        </trans-unit>
        <trans-unit id="16ca749420dd58126c1f3f4ccf95ce2fc49387c9" translate="yes" xml:space="preserve">
          <source>Input array.</source>
          <target state="translated">Входной массив.</target>
        </trans-unit>
        <trans-unit id="e22a13f0e68b42a409027fe2f016234b4ec5feb3" translate="yes" xml:space="preserve">
          <source>Input array. If &lt;code&gt;axis&lt;/code&gt; is None, &lt;code&gt;x&lt;/code&gt; must be 1-D or 2-D.</source>
          <target state="translated">Входной массив. Если &lt;code&gt;axis&lt;/code&gt; None, &lt;code&gt;x&lt;/code&gt; должен быть 1-D или 2-D.</target>
        </trans-unit>
        <trans-unit id="a823c846105b9c9719fbae89a64d485cac5a4b66" translate="yes" xml:space="preserve">
          <source>Input array. If &lt;code&gt;sorter&lt;/code&gt; is None, then it must be sorted in ascending order, otherwise &lt;code&gt;sorter&lt;/code&gt; must be an array of indices that sort it.</source>
          <target state="translated">Входной массив. Если &lt;code&gt;sorter&lt;/code&gt; равен None, он должен быть отсортирован в порядке возрастания, иначе &lt;code&gt;sorter&lt;/code&gt; должен быть массивом индексов, которые его сортируют.</target>
        </trans-unit>
        <trans-unit id="6eef0d989b2fd6fdf464d508f694dc4a0a6a6caa" translate="yes" xml:space="preserve">
          <source>Input array. The elements in &lt;code&gt;a&lt;/code&gt; are read in the order specified by &lt;code&gt;order&lt;/code&gt;, and packed as a 1-D array.</source>
          <target state="translated">Входной массив. Элементы в &lt;code&gt;a&lt;/code&gt; читаются в порядке, указанном &lt;code&gt;order&lt;/code&gt; , и упаковываются в одномерный массив.</target>
        </trans-unit>
        <trans-unit id="88c5aa449f45fc85917596c4004dffe23e0b86ac" translate="yes" xml:space="preserve">
          <source>Input array. Unless &lt;code&gt;axis&lt;/code&gt; is specified, this will be flattened if it is not already 1-D.</source>
          <target state="translated">Входной массив. Если &lt;code&gt;axis&lt;/code&gt; не указана, она будет развернута, если она еще не является 1-D.</target>
        </trans-unit>
        <trans-unit id="c937c57a4f225878ef9dec01334ff4466710291e" translate="yes" xml:space="preserve">
          <source>Input arrays</source>
          <target state="translated">массивы ввода</target>
        </trans-unit>
        <trans-unit id="d4ab162cfec9e7e5f511b1323f2a38dced9855a6" translate="yes" xml:space="preserve">
          <source>Input arrays are defined as arrays of data that are passed into a routine but are not altered in-place or returned to the user. The Python input array is therefore allowed to be almost any Python sequence (such as a list) that can be converted to the requested type of array. The input array signatures are</source>
          <target state="translated">Массивы ввода определяются как массивы данных,которые передаются в рутину,но не изменяются на месте и не возвращаются пользователю.Поэтому входной массив Python может быть практически любой последовательностью Python (например,списком),которая может быть преобразована в массив запрошенного типа.Сигнатуры входного массива</target>
        </trans-unit>
        <trans-unit id="098168471a46df6606b6ff9c9cd3ead3422de613" translate="yes" xml:space="preserve">
          <source>Input arrays of the same shape.</source>
          <target state="translated">Входные массивы одинаковой формы.</target>
        </trans-unit>
        <trans-unit id="27f64d53a246ed11a85c01a61d0a931b1d50a817" translate="yes" xml:space="preserve">
          <source>Input arrays to be compared.</source>
          <target state="translated">Входные массивы для сравнения.</target>
        </trans-unit>
        <trans-unit id="6fed91f1bcdfc2569325e9089bbd325328b5c5e9" translate="yes" xml:space="preserve">
          <source>Input arrays to be multiplied. If &lt;code&gt;x1.shape != x2.shape&lt;/code&gt;, they must be broadcastable to a common shape (which becomes the shape of the output).</source>
          <target state="translated">Входные массивы для умножения. Если &lt;code&gt;x1.shape != x2.shape&lt;/code&gt; , они должны транслироваться в общую форму (которая становится формой вывода).</target>
        </trans-unit>
        <trans-unit id="4a8e2cbe86fa87773992dad5fc91ec0f376d5ef6" translate="yes" xml:space="preserve">
          <source>Input arrays to compare.</source>
          <target state="translated">Входные массивы для сравнения.</target>
        </trans-unit>
        <trans-unit id="66d649cf79701276da2a390f23e474c6ab2aff7f" translate="yes" xml:space="preserve">
          <source>Input arrays, scalars not allowed.</source>
          <target state="translated">Входные массивы,скаляры не разрешены.</target>
        </trans-unit>
        <trans-unit id="556a7ea15ff0974e693ba20b38993284bf2034ec" translate="yes" xml:space="preserve">
          <source>Input arrays.</source>
          <target state="translated">Массивы ввода.</target>
        </trans-unit>
        <trans-unit id="ad9b94d855384626461316d89dd8037bff8db7bd" translate="yes" xml:space="preserve">
          <source>Input arrays. If &lt;code&gt;x1.shape != x2.shape&lt;/code&gt;, they must be broadcastable to a common shape (which becomes the shape of the output).</source>
          <target state="translated">Входные массивы. Если &lt;code&gt;x1.shape != x2.shape&lt;/code&gt; , они должны транслироваться в общую форму (которая становится формой вывода).</target>
        </trans-unit>
        <trans-unit id="d784452f6247a01f2c79aa8a172590665da159e0" translate="yes" xml:space="preserve">
          <source>Input arrays. They are flattened if they are not already 1D.</source>
          <target state="translated">Массивы ввода.Они сплющиваются,если их еще нет в 1D.</target>
        </trans-unit>
        <trans-unit id="e48eae13547040a1f74bd1dc543d4762a4b7970d" translate="yes" xml:space="preserve">
          <source>Input arrays. Will be flattened if not already 1D.</source>
          <target state="translated">Массивы ввода.Будет расплющена,если еще не 1D.</target>
        </trans-unit>
        <trans-unit id="670ce16c58ae415abf92889322038709e2fa68ca" translate="yes" xml:space="preserve">
          <source>Input cash flows per time period. By convention, net &amp;ldquo;deposits&amp;rdquo; are negative and net &amp;ldquo;withdrawals&amp;rdquo; are positive. Thus, for example, at least the first element of &lt;code&gt;values&lt;/code&gt;, which represents the initial investment, will typically be negative.</source>
          <target state="translated">Введите денежные потоки за период времени. Обычно чистые &amp;laquo;депозиты&amp;raquo; отрицательны, а чистые &amp;laquo;изъятия&amp;raquo; положительны. Таким образом, например, по крайней мере, первый элемент &lt;code&gt;values&lt;/code&gt; , представляющий начальные инвестиции, обычно будет отрицательным.</target>
        </trans-unit>
        <trans-unit id="00f0d4d4fb6b101c2c16fbc5749470d99cd4de8c" translate="yes" xml:space="preserve">
          <source>Input class. If a tuple of classes, True is returned if &lt;code&gt;arg1&lt;/code&gt; is a subclass of any of the tuple elements.</source>
          <target state="translated">Входной класс. Если кортеж классов, возвращается True, если &lt;code&gt;arg1&lt;/code&gt; является подклассом любого из элементов кортежа.</target>
        </trans-unit>
        <trans-unit id="2bad44bea0aeffb47c89150e3263bb8f1abd9181" translate="yes" xml:space="preserve">
          <source>Input class. True is returned if &lt;code&gt;arg1&lt;/code&gt; is a subclass of &lt;code&gt;arg2&lt;/code&gt;.</source>
          <target state="translated">Входной класс. True возвращается, если &lt;code&gt;arg1&lt;/code&gt; является подклассом &lt;code&gt;arg2&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="56f0cc662add4c7f0901841588673883d4d29d17" translate="yes" xml:space="preserve">
          <source>Input comparison array.</source>
          <target state="translated">Входной массив сравнения.</target>
        </trans-unit>
        <trans-unit id="64be30841013bc47e9c3850c4b6a7fded4a86ac4" translate="yes" xml:space="preserve">
          <source>Input data, in any form that can be converted to a masked array. This includes lists, lists of tuples, tuples, tuples of tuples, tuples of lists, ndarrays and masked arrays.</source>
          <target state="translated">Входные данные,в любой форме,которые могут быть преобразованы в маскированный массив.Сюда входят списки,списки кортежей,кортежи,кортежи списков,ndarrays и массивы по маске.</target>
        </trans-unit>
        <trans-unit id="81eacae9b22a55fbd594cc3dd8bc53a24b4e16f7" translate="yes" xml:space="preserve">
          <source>Input data, in any form that can be converted to an array.</source>
          <target state="translated">Входные данные,в любой форме,которые могут быть преобразованы в массив.</target>
        </trans-unit>
        <trans-unit id="2ed4e1316aa603c005ccf7b9b354de1cad7aa423" translate="yes" xml:space="preserve">
          <source>Input data, in any form that can be converted to an array. This includes lists, lists of tuples, tuples, tuples of tuples, tuples of lists and ndarrays.</source>
          <target state="translated">Входные данные,в любой форме,которые могут быть преобразованы в массив.Это включает в себя списки,списки кортежей,кортежи,кортежи списков и ndarrays.</target>
        </trans-unit>
        <trans-unit id="c935f3a4d2949a1b2d5a11eb7de8a0fed4bd8dc0" translate="yes" xml:space="preserve">
          <source>Input data, in any form that can be converted to an array. This includes lists, lists of tuples, tuples, tuples of tuples, tuples of lists and ndarrays. Success requires no NaNs or Infs.</source>
          <target state="translated">Входные данные,в любой форме,которые могут быть преобразованы в массив.Это включает в себя списки,списки кортежей,кортежи,кортежи списков и ndarrays.Успех не требует NaNs или Infs.</target>
        </trans-unit>
        <trans-unit id="ebe3314c250fe9acc710492a54a53defc42ce5bf" translate="yes" xml:space="preserve">
          <source>Input data, in any form that can be converted to an array. This includes scalars, lists, lists of tuples, tuples, tuples of tuples, tuples of lists, and ndarrays.</source>
          <target state="translated">Входные данные,в любой форме,которые могут быть преобразованы в массив.Сюда входят скаляры,списки,списки кортежей,кортежи,кортежи списков и ndarrays.</target>
        </trans-unit>
        <trans-unit id="d430a3ba769bee8e9797da35defb2f32aa2749a3" translate="yes" xml:space="preserve">
          <source>Input data, which is flattened and set as the &lt;code&gt;k&lt;/code&gt;-th diagonal of the output.</source>
          <target state="translated">Входные данные, которые сглаживаются и задаются как &lt;code&gt;k&lt;/code&gt; -я диагональ выходных данных.</target>
        </trans-unit>
        <trans-unit id="260753716624ad2077f13f38ada17a33c0f48cba" translate="yes" xml:space="preserve">
          <source>Input data.</source>
          <target state="translated">Вводите данные.</target>
        </trans-unit>
        <trans-unit id="110e3a721161e503e06852d0b67d62808bcf14b0" translate="yes" xml:space="preserve">
          <source>Input data. If a string, variables in the current scope may be referenced by name.</source>
          <target state="translated">Вводите данные.Если строка,то на переменные в текущей области видимости можно ссылаться по имени.</target>
        </trans-unit>
        <trans-unit id="50ef3fe01b042bdbfb18f290684475887aff6e69" translate="yes" xml:space="preserve">
          <source>Input data. The histogram is computed over the flattened array.</source>
          <target state="translated">Вводите данные.Гистограмма вычисляется по сплющенному массиву.</target>
        </trans-unit>
        <trans-unit id="c3661c49bb4714e36d1ea68c6778013ac4b2c966" translate="yes" xml:space="preserve">
          <source>Input masks.</source>
          <target state="translated">Входные маски.</target>
        </trans-unit>
        <trans-unit id="49c6112477838697a8b42892713d1ff818dab05e" translate="yes" xml:space="preserve">
          <source>Input must be an ndarray (or have similar attributes) for it to be considered a valid mask.</source>
          <target state="translated">Ввод должен быть андарреем (или иметь похожие атрибуты),чтобы его можно было считать действительной маской.</target>
        </trans-unit>
        <trans-unit id="cdda590be17222720d3dca31ac32ec20a4bd2027" translate="yes" xml:space="preserve">
          <source>Input object or name to get information about. If &lt;a href=&quot;https://docs.python.org/dev/library/functions.html#object&quot;&gt;&lt;code&gt;object&lt;/code&gt;&lt;/a&gt; is a numpy object, its docstring is given. If it is a string, available modules are searched for matching objects. If None, information about &lt;a href=&quot;#numpy.info&quot;&gt;&lt;code&gt;info&lt;/code&gt;&lt;/a&gt; itself is returned.</source>
          <target state="translated">Введите объект или имя, о котором нужно получить информацию. Если &lt;a href=&quot;https://docs.python.org/dev/library/functions.html#object&quot;&gt; &lt;code&gt;object&lt;/code&gt; &lt;/a&gt; является numpy-объектом, дается его строка документации. Если это строка, доступные модули ищутся на предмет соответствия объектам. Если Нет, возвращается информация о самой &lt;a href=&quot;#numpy.info&quot;&gt; &lt;code&gt;info&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="884c8a0c5d0944c72ee0463c3eae0abb376b5e70" translate="yes" xml:space="preserve">
          <source>Input object. This can be any object (function, class, module, &amp;hellip;).</source>
          <target state="translated">Входной объект. Это может быть любой объект (функция, класс, модуль,&amp;hellip;).</target>
        </trans-unit>
        <trans-unit id="5bf2f1c9ba1965ca26f274218714e854f9f8439e" translate="yes" xml:space="preserve">
          <source>Input parameters.</source>
          <target state="translated">Входные параметры.</target>
        </trans-unit>
        <trans-unit id="f281e3f644ef1c6e22e0e862f4156eee5c382d75" translate="yes" xml:space="preserve">
          <source>Input polynomials.</source>
          <target state="translated">Входные полиномы.</target>
        </trans-unit>
        <trans-unit id="d68cab221829e2198b605b4996fba557e5ff14b8" translate="yes" xml:space="preserve">
          <source>Input sequences.</source>
          <target state="translated">Входные последовательности.</target>
        </trans-unit>
        <trans-unit id="103b73f8b8612de7f92ed544d130aab2ccb3dead" translate="yes" xml:space="preserve">
          <source>Input value.</source>
          <target state="translated">Входное значение.</target>
        </trans-unit>
        <trans-unit id="cf14e71217c8a7f10324a53bd5825d3d1b8701ee" translate="yes" xml:space="preserve">
          <source>Input values</source>
          <target state="translated">Входные значения</target>
        </trans-unit>
        <trans-unit id="4191049318f63b6c3a85211b91a5c1cecb649bdb" translate="yes" xml:space="preserve">
          <source>Input values.</source>
          <target state="translated">Входные значения.</target>
        </trans-unit>
        <trans-unit id="07feb5a3916677b58c8f1860e3f940ccc64ab2f3" translate="yes" xml:space="preserve">
          <source>Input values. If &lt;code&gt;x1.shape != x2.shape&lt;/code&gt;, they must be broadcastable to a common shape (which becomes the shape of the output).</source>
          <target state="translated">Входные значения. Если &lt;code&gt;x1.shape != x2.shape&lt;/code&gt; , они должны транслироваться в общую форму (которая становится формой вывода).</target>
        </trans-unit>
        <trans-unit id="75826edc2e28e338fe2b7ee2851bc98b65454f08" translate="yes" xml:space="preserve">
          <source>Input vector or stack of matrices.</source>
          <target state="translated">Входной вектор или стопка матриц.</target>
        </trans-unit>
        <trans-unit id="31df6d6470f1b56cda7e136be4be3e1c6dd63188" translate="yes" xml:space="preserve">
          <source>Input-only, in-place, argout, argoutview, and memory managed argoutview behavior.</source>
          <target state="translated">Поведение argoutview,управляемое только на входе,на месте,argoutview,argoutview и памятью.</target>
        </trans-unit>
        <trans-unit id="35b236db313f77f4ec031a91db5c8c986efb6cc5" translate="yes" xml:space="preserve">
          <source>Inputs arrays.</source>
          <target state="translated">Входные массивы.</target>
        </trans-unit>
        <trans-unit id="b698f1874b3f648c9ca7483478e5a5187dbc4214" translate="yes" xml:space="preserve">
          <source>Insert a new axis that will appear at the &lt;code&gt;axis&lt;/code&gt; position in the expanded array shape.</source>
          <target state="translated">Вставьте новую ось, которая появится в позиции &lt;code&gt;axis&lt;/code&gt; в форме расширенного массива.</target>
        </trans-unit>
        <trans-unit id="af781fb10a00be46a34d9311756bc61e0afddfa8" translate="yes" xml:space="preserve">
          <source>Insert elements into an array.</source>
          <target state="translated">Вставьте элементы в массив.</target>
        </trans-unit>
        <trans-unit id="62cc157d912a7ebc384c4d505230255340ab3ae0" translate="yes" xml:space="preserve">
          <source>Insert scalar into an array (scalar is cast to array&amp;rsquo;s dtype, if possible)</source>
          <target state="translated">Вставить скаляр в массив (если возможно, скаляр приводится к dtype массива)</target>
        </trans-unit>
        <trans-unit id="6f263a0b1fde8fabbe156179a3331b4bc254ecbf" translate="yes" xml:space="preserve">
          <source>Insert values along the given axis before the given indices.</source>
          <target state="translated">Вставьте значения вдоль данной оси перед заданными индексами.</target>
        </trans-unit>
        <trans-unit id="6c05692f04b1e8c9bcb190b107c8a7b51796744b" translate="yes" xml:space="preserve">
          <source>Insert, remove, and combine dimensions, and resize existing ones</source>
          <target state="translated">Вставить,удалить и скомбинировать размеры,а также изменить размер существующих размеров</target>
        </trans-unit>
        <trans-unit id="5ca6174fce3b04b3d69345d6264017af5ed2d820" translate="yes" xml:space="preserve">
          <source>Inserted between elements.</source>
          <target state="translated">Вставлены между элементами.</target>
        </trans-unit>
        <trans-unit id="e6afa88e6a63d5a7ba7fb743473b463e1d9a17d0" translate="yes" xml:space="preserve">
          <source>Inserting data into arrays</source>
          <target state="translated">Вставка данных в массивы</target>
        </trans-unit>
        <trans-unit id="d078b8bceaffb54addedcd30ef388e1bc3bf477b" translate="yes" xml:space="preserve">
          <source>Inserts newlines if text is longer than &lt;code&gt;max_line_width&lt;/code&gt;. Defaults to &lt;code&gt;numpy.get_printoptions()['linewidth']&lt;/code&gt;.</source>
          <target state="translated">Вставляет символы новой строки, если текст длиннее &lt;code&gt;max_line_width&lt;/code&gt; . По умолчанию &lt;code&gt;numpy.get_printoptions()['linewidth']&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1e503f860ac4f65121fead950747f4fcea390ed6" translate="yes" xml:space="preserve">
          <source>Inspecting the array</source>
          <target state="translated">Проверка массива</target>
        </trans-unit>
        <trans-unit id="aee4fe0a13da73153ed829e66d85c46397091399" translate="yes" xml:space="preserve">
          <source>Instances of &lt;a href=&quot;numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;ndarray&lt;/code&gt;&lt;/a&gt; subclasses are passed through as-is:</source>
          <target state="translated">Экземпляры подклассов &lt;a href=&quot;numpy.ndarray#numpy.ndarray&quot;&gt; &lt;code&gt;ndarray&lt;/code&gt; &lt;/a&gt; передаются как есть:</target>
        </trans-unit>
        <trans-unit id="eb90e39d52c4ed3cde5408270177895a426f7a11" translate="yes" xml:space="preserve">
          <source>Instead of special method names which define behavior for Python classes, there are &amp;ldquo;function tables&amp;rdquo; which point to functions that implement the desired results. Since Python 2.2, the PyTypeObject itself has become dynamic which allows C types that can be &amp;ldquo;sub-typed &amp;ldquo;from other C-types in C, and sub-classed in Python. The children types inherit the attributes and methods from their parent(s).</source>
          <target state="translated">Вместо имен специальных методов, которые определяют поведение классов Python, существуют &amp;laquo;таблицы функций&amp;raquo;, указывающие на функции, реализующие желаемые результаты. Начиная с Python 2.2, сам PyTypeObject стал динамическим, что позволяет использовать типы C, которые могут быть &amp;laquo;подтипами&amp;raquo; из других C-типов в C и подклассами в Python. Дочерние типы наследуют атрибуты и методы от своих родителей.</target>
        </trans-unit>
        <trans-unit id="1a76aa17748f84d4f0a3ce05629dc02de8fc5860" translate="yes" xml:space="preserve">
          <source>Instead of specifying the full covariance matrix, popular approximations include:</source>
          <target state="translated">Вместо того,чтобы указывать полную ковариационную матрицу,популярные аппроксимации включают:</target>
        </trans-unit>
        <trans-unit id="569af2f9677e0019350ea2c63399c035e782231b" translate="yes" xml:space="preserve">
          <source>Instead of the Python traditional &amp;lsquo;floor division&amp;rsquo;, this returns a true division. True division adjusts the output type to present the best answer, regardless of input types.</source>
          <target state="translated">Вместо традиционного Python &amp;laquo;деления полов&amp;raquo; это возвращает истинное деление. Истинное деление регулирует тип вывода, чтобы представить лучший ответ, независимо от типов ввода.</target>
        </trans-unit>
        <trans-unit id="9edcffff4461c9083fbff857f8dcee0f0769cbd4" translate="yes" xml:space="preserve">
          <source>Integer</source>
          <target state="translated">Integer</target>
        </trans-unit>
        <trans-unit id="a61c09200238e7c60e4949f4f742cd3529f52bfd" translate="yes" xml:space="preserve">
          <source>Integer array indexing</source>
          <target state="translated">Индексирование по целому массиву</target>
        </trans-unit>
        <trans-unit id="a764d9440def338d1a721af2c9bc3cf9203fd57a" translate="yes" xml:space="preserve">
          <source>Integer array indexing allows selection of arbitrary items in the array based on their &lt;em&gt;N&lt;/em&gt;-dimensional index. Each integer array represents a number of indexes into that dimension.</source>
          <target state="translated">Индексирование целочисленного массива позволяет выбирать произвольные элементы в массиве на основе их &lt;em&gt;N-&lt;/em&gt; мерного индекса. Каждый целочисленный массив представляет собой несколько индексов в этом измерении.</target>
        </trans-unit>
        <trans-unit id="a46c6037b6ed3e2034603c23c6f4211c22a945c1" translate="yes" xml:space="preserve">
          <source>Integer exponents of 2. This is a scalar if &lt;code&gt;x&lt;/code&gt; is a scalar.</source>
          <target state="translated">Целочисленные показатели числа 2. Это скаляр, если &lt;code&gt;x&lt;/code&gt; - скаляр.</target>
        </trans-unit>
        <trans-unit id="a3173b86433d0db1fb5b647328822672be728221" translate="yes" xml:space="preserve">
          <source>Integer indicating how this dtype relates to the built-in dtypes.</source>
          <target state="translated">Целое число,указывающее,как этот тип относится к встроенным стипам.</target>
        </trans-unit>
        <trans-unit id="c0ad68cb65f108515f3a5b364ab814f280978530" translate="yes" xml:space="preserve">
          <source>Integer performance has a similar ordering.</source>
          <target state="translated">Целостная производительность имеет аналогичный заказ.</target>
        </trans-unit>
        <trans-unit id="006c632da5c7b1582b36540c57330b631facab3d" translate="yes" xml:space="preserve">
          <source>Integer that can hold a pointer</source>
          <target state="translated">Целое,которое может держать указатель</target>
        </trans-unit>
        <trans-unit id="654f37af768fdf3bb70ca69e758a2fe80f1abf09" translate="yes" xml:space="preserve">
          <source>Integers:</source>
          <target state="translated">Integers:</target>
        </trans-unit>
        <trans-unit id="84cede945b07b48bcb97421b3eb8bd4f5bd269e0" translate="yes" xml:space="preserve">
          <source>Integral part of &lt;code&gt;x&lt;/code&gt;. This is a scalar if &lt;code&gt;x&lt;/code&gt; is a scalar.</source>
          <target state="translated">Неотъемлемая часть &lt;code&gt;x&lt;/code&gt; . Это скаляр, если &lt;code&gt;x&lt;/code&gt; - скаляр.</target>
        </trans-unit>
        <trans-unit id="1ea3c0d26d1c5d1b53eb099b2c1cf7972b99ebe8" translate="yes" xml:space="preserve">
          <source>Integrate &lt;code&gt;y&lt;/code&gt; (&lt;code&gt;x&lt;/code&gt;) along given axis.</source>
          <target state="translated">Интегрируйте &lt;code&gt;y&lt;/code&gt; ( &lt;code&gt;x&lt;/code&gt; ) по заданной оси.</target>
        </trans-unit>
        <trans-unit id="cc54f713576053888447a5aa6f2b6660db759e79" translate="yes" xml:space="preserve">
          <source>Integrate a Chebyshev series.</source>
          <target state="translated">Интегрируйте Чебышевскую серию.</target>
        </trans-unit>
        <trans-unit id="f7e0820ca3cf5b80cf75499d63a15279548b4395" translate="yes" xml:space="preserve">
          <source>Integrate a Hermite series.</source>
          <target state="translated">Интегрируйте серию &quot;Эрмита&quot;.</target>
        </trans-unit>
        <trans-unit id="09cdc33ab9232f32b3ffa23eec0555fd0aad884d" translate="yes" xml:space="preserve">
          <source>Integrate a Hermite_e series.</source>
          <target state="translated">Интегрируйте серию Hermite_e.</target>
        </trans-unit>
        <trans-unit id="28e01e90e39bcd5c5a200d36b330a9fb8a0cc2c8" translate="yes" xml:space="preserve">
          <source>Integrate a Laguerre series.</source>
          <target state="translated">Интегрирована в серию Laguerre.</target>
        </trans-unit>
        <trans-unit id="e45d1046a79d8f27551599eaeb79cbfa5c322286" translate="yes" xml:space="preserve">
          <source>Integrate a Legendre series.</source>
          <target state="translated">Интеграция в серию &quot;Легенда&quot;.</target>
        </trans-unit>
        <trans-unit id="51617b9fadb594aa47fc197fa4afb1a0d12a97e3" translate="yes" xml:space="preserve">
          <source>Integrate a polynomial.</source>
          <target state="translated">Интегрируйте полиноминал.</target>
        </trans-unit>
        <trans-unit id="1b28e42d25bb1781655bdbd732badc274759c37c" translate="yes" xml:space="preserve">
          <source>Integrate along the given axis using the composite trapezoidal rule.</source>
          <target state="translated">Интегрируйте по заданной оси с помощью составного трапециевидного правила.</target>
        </trans-unit>
        <trans-unit id="f6bc7be2c5b5072601573fb92ccbc047dff88160" translate="yes" xml:space="preserve">
          <source>Integrate.</source>
          <target state="translated">Integrate.</target>
        </trans-unit>
        <trans-unit id="24640b86177ce52879242a4e3855fb7330a6f367" translate="yes" xml:space="preserve">
          <source>Integration constant(s). The value of the first integral at &lt;code&gt;lbnd&lt;/code&gt; is the first value in the list, the value of the second integral at &lt;code&gt;lbnd&lt;/code&gt; is the second value, etc. If &lt;code&gt;k == []&lt;/code&gt; (the default), all constants are set to zero. If &lt;code&gt;m == 1&lt;/code&gt;, a single scalar can be given instead of a list.</source>
          <target state="translated">Константа (и) интегрирования. Значение первого интеграла в &lt;code&gt;lbnd&lt;/code&gt; является первым значением в списке, значение второго интеграла в &lt;code&gt;lbnd&lt;/code&gt; является вторым значением и т. Д. Если &lt;code&gt;k == []&lt;/code&gt; (по умолчанию), все константы устанавливаются в ноль. Если &lt;code&gt;m == 1&lt;/code&gt; , вместо списка можно указать один скаляр.</target>
        </trans-unit>
        <trans-unit id="faa7aa2d13f47c8dc8e8d870349e9f9bbf12fee6" translate="yes" xml:space="preserve">
          <source>Integration constant(s). The value of the first integral at zero is the first value in the list, the value of the second integral at zero is the second value, etc. If &lt;code&gt;k == []&lt;/code&gt; (the default), all constants are set to zero. If &lt;code&gt;m == 1&lt;/code&gt;, a single scalar can be given instead of a list.</source>
          <target state="translated">Константа (и) интегрирования. Значение первого интеграла в нуле является первым значением в списке, значение второго интеграла в нуле является вторым значением и т. Д. Если &lt;code&gt;k == []&lt;/code&gt; (по умолчанию), все константы устанавливаются в ноль. Если &lt;code&gt;m == 1&lt;/code&gt; , вместо списка можно указать один скаляр.</target>
        </trans-unit>
        <trans-unit id="79199da79d91b1fb5aeec3ae95134c32578dd203" translate="yes" xml:space="preserve">
          <source>Integration constants. The first constant is applied to the first integration, the second to the second, and so on. The list of values must less than or equal to &lt;code&gt;m&lt;/code&gt; in length and any missing values are set to zero.</source>
          <target state="translated">Константы интеграции. Первая константа применяется к первому интегрированию, вторая - ко второму и так далее. Список значений должен быть меньше или равен &lt;code&gt;m&lt;/code&gt; по длине, а любые пропущенные значения обнуляются.</target>
        </trans-unit>
        <trans-unit id="99a973b23f26b788591e237471230a61bc42bfca" translate="yes" xml:space="preserve">
          <source>Integration constants. They are given in the order of integration: those corresponding to highest-order terms come first.</source>
          <target state="translated">Интеграционные константы.Они даются в порядке интеграции:те,которые соответствуют терминам высшего порядка,стоят на первом месте.</target>
        </trans-unit>
        <trans-unit id="f1b63b1b837d115daafc12c34b184fde445bf116" translate="yes" xml:space="preserve">
          <source>Integration of array values using the composite trapezoidal rule.</source>
          <target state="translated">Интеграция значений массивов с помощью составного трапециевидного правила.</target>
        </trans-unit>
        <trans-unit id="cf5308846512dd05b3fe349862b884d3dad34184" translate="yes" xml:space="preserve">
          <source>Interchange two axes of an array.</source>
          <target state="translated">Обменяться двумя осями массива.</target>
        </trans-unit>
        <trans-unit id="487fafdb343a2fa07aa1e904de9985413e377451" translate="yes" xml:space="preserve">
          <source>Interest paid against the loan changes during the life or the loan. The &lt;code&gt;per&lt;/code&gt; is the payment period to calculate the interest amount.</source>
          <target state="translated">Проценты, выплачиваемые против ссуды, меняются в течение срока действия ссуды. &lt;code&gt;per&lt;/code&gt; это платежный период для расчета суммы процентов.</target>
        </trans-unit>
        <trans-unit id="94a1603aa26be2dbffaf8cf5c3954f0266df1988" translate="yes" xml:space="preserve">
          <source>Interest portion of payment. If all input is scalar, returns a scalar float. If any input is array_like, returns interest payment for each input element. If multiple inputs are array_like, they all must have the same shape.</source>
          <target state="translated">Процентная часть платежа.Если все введенные данные являются скалярными,возвращается скалярный поплавок.Если любой вход является массивом_подобным,возвращает проценты за каждый входной элемент.Если несколько входов похожи на массив_,то все они должны иметь одинаковую форму.</target>
        </trans-unit>
        <trans-unit id="fae2c1a639317094eef5fc0747acae252e47559d" translate="yes" xml:space="preserve">
          <source>Interest rate paid on the cash flows</source>
          <target state="translated">Процентная ставка,выплачиваемая на денежные потоки</target>
        </trans-unit>
        <trans-unit id="bac9f8f12cdd23938b9506adf721b640d1387b0f" translate="yes" xml:space="preserve">
          <source>Interest rate received on the cash flows upon reinvestment</source>
          <target state="translated">Процентная ставка,полученная на денежные потоки при реинвестировании</target>
        </trans-unit>
        <trans-unit id="5a1eb29a8757da9ba26cf2dfef44ad676331c673" translate="yes" xml:space="preserve">
          <source>Internal Flexibility</source>
          <target state="translated">Внутренняя гибкость</target>
        </trans-unit>
        <trans-unit id="ac2251ff80e959c9a76b1d8e25426050ad978681" translate="yes" xml:space="preserve">
          <source>Internal Rate of Return for periodic input values.</source>
          <target state="translated">Внутренняя скорость возврата для периодических входных значений.</target>
        </trans-unit>
        <trans-unit id="811920182b71e4d6c39f62829f0533afa24b5bfb" translate="yes" xml:space="preserve">
          <source>Internal functions</source>
          <target state="translated">Внутренние функции</target>
        </trans-unit>
        <trans-unit id="ecdbace78f65adf7ab79aea820093f0235b38c83" translate="yes" xml:space="preserve">
          <source>Internal memory layout of an ndarray</source>
          <target state="translated">Внутренняя память андаррея</target>
        </trans-unit>
        <trans-unit id="4c771d77fd8a74b74dbd14733dbe89a221191139" translate="yes" xml:space="preserve">
          <source>Internal organization of numpy arrays</source>
          <target state="translated">Внутренняя организация нумизматических массивов</target>
        </trans-unit>
        <trans-unit id="8693ac81d62075b90be2f5012ceac7d5e0960c71" translate="yes" xml:space="preserve">
          <source>Internally used structures</source>
          <target state="translated">Внутренне используемые структуры</target>
        </trans-unit>
        <trans-unit id="353f9272117a257bd48156e257afe86724ce335c" translate="yes" xml:space="preserve">
          <source>Internally, buffers are used for misaligned data, swapped data, and data that has to be converted from one data type to another. The size of internal buffers is settable on a per-thread basis. There can be up to</source>
          <target state="translated">Внутренние буферы используются для неправильно выровненных данных,данных,подлежащих замене,и данных,которые необходимо преобразовать из одного типа данных в другой.Размер внутренних буферов настраивается для каждого потока.Может быть до</target>
        </trans-unit>
        <trans-unit id="0b9562a5febab6388bcaad8af8913734a30e5c69" translate="yes" xml:space="preserve">
          <source>Internally, the code uses some additional Python objects primarily for memory management. These types are not accessible directly from Python, and are not exposed to the C-API. They are included here only for completeness and assistance in understanding the code.</source>
          <target state="translated">Внутренне код использует некоторые дополнительные объекты на Python в первую очередь для управления памятью.Эти типы недоступны напрямую с Python и не подвержены C-API.Они включены сюда только для полноты и облегчения понимания кода.</target>
        </trans-unit>
        <trans-unit id="88c585f236f03e4d85467407665675347bdfa2c1" translate="yes" xml:space="preserve">
          <source>Internally, these #defines work as follows:</source>
          <target state="translated">Внутренне эти #определения работают следующим образом:</target>
        </trans-unit>
        <trans-unit id="b400cd2b32800b89445114d966c1ee1e1e2f5b22" translate="yes" xml:space="preserve">
          <source>Interpolate a function at the Chebyshev points of the first kind.</source>
          <target state="translated">Интерполируйте функцию на чебышевских точках первого рода.</target>
        </trans-unit>
        <trans-unit id="b0124a6fa4961521e8ff39aa6c372018194a4ebf" translate="yes" xml:space="preserve">
          <source>Interpolating Chebyshev instance.</source>
          <target state="translated">Интерполируя Чебышева.</target>
        </trans-unit>
        <trans-unit id="1427e61ed742cbf9aa91a5c0cf7909917aab75eb" translate="yes" xml:space="preserve">
          <source>Interpolation with periodic x-coordinates:</source>
          <target state="translated">Интерполяция с периодическими х-координатами:</target>
        </trans-unit>
        <trans-unit id="437831e765e33b0f2fa769dfde52d2c581b5cfbf" translate="yes" xml:space="preserve">
          <source>Interpret a buffer as a 1-dimensional array.</source>
          <target state="translated">Интерпретировать буфер как 1-мерный массив.</target>
        </trans-unit>
        <trans-unit id="9feed02e3d661ed814b67ed529ab9195e31b0cb4" translate="yes" xml:space="preserve">
          <source>Interpret the input as a matrix.</source>
          <target state="translated">Интерпретируйте вход как матрицу.</target>
        </trans-unit>
        <trans-unit id="a0422cc647bba954b177a29fbf1305b2895860e3" translate="yes" xml:space="preserve">
          <source>Interrupt Handling</source>
          <target state="translated">обработка прерывания</target>
        </trans-unit>
        <trans-unit id="2473e96bc614a911821242119918a241a41836d6" translate="yes" xml:space="preserve">
          <source>Introduction</source>
          <target state="translated">Introduction</target>
        </trans-unit>
        <trans-unit id="46dbc8721ef190eab06879ef282ac69a2d11056b" translate="yes" xml:space="preserve">
          <source>Invalid data means values of &lt;code&gt;nan&lt;/code&gt;, &lt;code&gt;inf&lt;/code&gt;, etc.</source>
          <target state="translated">Неверные данные означают значения &lt;code&gt;nan&lt;/code&gt; , &lt;code&gt;inf&lt;/code&gt; и т. Д.</target>
        </trans-unit>
        <trans-unit id="6dd811ad3cf2203333b0468d5361ce3f92b716aa" translate="yes" xml:space="preserve">
          <source>Invalid operation: result is not an expressible number, typically indicates that a NaN was produced.</source>
          <target state="translated">Недействительная операция:результат не является экспрессивным числом,обычно указывает на то,что был произведен NaN.</target>
        </trans-unit>
        <trans-unit id="dfed6b5bd73798f6efbc4f77cde7ac568bd5cdfb" translate="yes" xml:space="preserve">
          <source>Inverse hyperbolic cosine, element-wise.</source>
          <target state="translated">Обратный гиперболический косинус,по элементам.</target>
        </trans-unit>
        <trans-unit id="21de990f2f734fbb43aa31870f6cebb10139a34e" translate="yes" xml:space="preserve">
          <source>Inverse hyperbolic sine element-wise.</source>
          <target state="translated">Обратный гиперболический синусоидальный элемент.</target>
        </trans-unit>
        <trans-unit id="ae6bb16d1805cc3ebef5cfaf633f1f868061a8dc" translate="yes" xml:space="preserve">
          <source>Inverse hyperbolic tangent element-wise.</source>
          <target state="translated">Обратный гиперболический тангенс по элементам.</target>
        </trans-unit>
        <trans-unit id="2c6d3ed37e9c36a516eafee4d6cf6bce8fa583e5" translate="yes" xml:space="preserve">
          <source>Inverse sine, element-wise.</source>
          <target state="translated">Обратный синус,по элементам.</target>
        </trans-unit>
        <trans-unit id="9b049bc33b3f3b47e868bbdc217dc4db5fb5be2d" translate="yes" xml:space="preserve">
          <source>Inverses of several matrices can be computed at once:</source>
          <target state="translated">Можно вычислить инверсии нескольких матриц одновременно:</target>
        </trans-unit>
        <trans-unit id="525b73c1bc26402f8fe2106a7fc0623195c4b729" translate="yes" xml:space="preserve">
          <source>Is equivalent to &lt;code&gt;np.delete(arr, [0,2,4], axis=0)&lt;/code&gt;, but allows further use of &lt;code&gt;mask&lt;/code&gt;.</source>
          <target state="translated">Эквивалентно &lt;code&gt;np.delete(arr, [0,2,4], axis=0)&lt;/code&gt; , но допускает дальнейшее использование &lt;code&gt;mask&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="24c5caf7c1723177101292b0ec91f3f69f7573df" translate="yes" xml:space="preserve">
          <source>Is straightforward to reverse engineer. Datasets often live longer than the programs that created them. A competent developer should be able to create a solution in their preferred programming language to read most &lt;code&gt;.npy&lt;/code&gt; files that he has been given without much documentation.</source>
          <target state="translated">Легко перепроектировать. Наборы данных часто живут дольше, чем программы, которые их создали. Компетентный разработчик должен иметь возможность создать решение на предпочитаемом им языке программирования для чтения большинства &lt;code&gt;.npy&lt;/code&gt; файлов .npy без дополнительной документации.</target>
        </trans-unit>
        <trans-unit id="1a81d4101d801108adb8aad8206475022e2e35b0" translate="yes" xml:space="preserve">
          <source>Is the given function something that we know how to overload?</source>
          <target state="translated">Является ли данная функция чем-то,что мы знаем,как перегрузить?</target>
        </trans-unit>
        <trans-unit id="b10180fbee8cac98fb1ea7940ed518f48a70dee3" translate="yes" xml:space="preserve">
          <source>Issued by &lt;a href=&quot;generated/numpy.polyfit#numpy.polyfit&quot;&gt;&lt;code&gt;polyfit&lt;/code&gt;&lt;/a&gt; when the Vandermonde matrix is rank deficient.</source>
          <target state="translated">Выдается &lt;a href=&quot;generated/numpy.polyfit#numpy.polyfit&quot;&gt; &lt;code&gt;polyfit&lt;/code&gt; ,&lt;/a&gt; когда матрица Вандермонда имеет недостаточный ранг.</target>
        </trans-unit>
        <trans-unit id="2c7da8ef717a7e944f5132cdc9e7ea084630c1b8" translate="yes" xml:space="preserve">
          <source>Issued by &lt;a href=&quot;numpy.polyfit#numpy.polyfit&quot;&gt;&lt;code&gt;polyfit&lt;/code&gt;&lt;/a&gt; when the Vandermonde matrix is rank deficient.</source>
          <target state="translated">Выдается &lt;a href=&quot;numpy.polyfit#numpy.polyfit&quot;&gt; &lt;code&gt;polyfit&lt;/code&gt; ,&lt;/a&gt; когда матрица Вандермонда имеет недостаточный ранг.</target>
        </trans-unit>
        <trans-unit id="62ecce1ee2f04057e107579d5bef99ec7e6758b0" translate="yes" xml:space="preserve">
          <source>Issued by chebfit when the design matrix is rank deficient.</source>
          <target state="translated">Выпускается Chebfit,когда матрица дизайна имеет недостаток ранга.</target>
        </trans-unit>
        <trans-unit id="ed3a53b09f923a24c6dd04195732883fc05144f5" translate="yes" xml:space="preserve">
          <source>Issued by the generic Poly class when two domains don&amp;rsquo;t match.</source>
          <target state="translated">Выдается общим классом Poly, когда два домена не совпадают.</target>
        </trans-unit>
        <trans-unit id="dee1de34f5e6dfdd4c0e68ce69b1f31528f724f6" translate="yes" xml:space="preserve">
          <source>It can also be used in places of &lt;a href=&quot;numpy.atleast_1d#numpy.atleast_1d&quot;&gt;&lt;code&gt;atleast_1d&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;numpy.atleast_2d#numpy.atleast_2d&quot;&gt;&lt;code&gt;atleast_2d&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">Его также можно использовать в местах &lt;a href=&quot;numpy.atleast_1d#numpy.atleast_1d&quot;&gt; &lt;code&gt;atleast_1d&lt;/code&gt; &lt;/a&gt; и &lt;a href=&quot;numpy.atleast_2d#numpy.atleast_2d&quot;&gt; &lt;code&gt;atleast_2d&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="378d5136b02c66ae2366b0871c9dc87a59e458eb" translate="yes" xml:space="preserve">
          <source>It can be considered as a generalization of EPS: &lt;code&gt;spacing(np.float64(1)) == np.finfo(np.float64).eps&lt;/code&gt;, and there should not be any representable number between &lt;code&gt;x + spacing(x)&lt;/code&gt; and x for any finite x.</source>
          <target state="translated">Его можно рассматривать как обобщение EPS: &lt;code&gt;spacing(np.float64(1)) == np.finfo(np.float64).eps&lt;/code&gt; , и не должно быть никакого представимого числа между &lt;code&gt;x + spacing(x)&lt;/code&gt; и x для любой конечный x.</target>
        </trans-unit>
        <trans-unit id="1ef0650f598bd8c46d6488dc9e1ecf7f36a57c12" translate="yes" xml:space="preserve">
          <source>It can be shown that a convolution</source>
          <target state="translated">Можно показать,что конволюция</target>
        </trans-unit>
        <trans-unit id="3a39f7205319edd1c303f4671f99c8c35d8b49e6" translate="yes" xml:space="preserve">
          <source>It can be shown that if</source>
          <target state="translated">Можно показать,что если</target>
        </trans-unit>
        <trans-unit id="6680413ecf8178af7a6bc1c7bc275bc8809885e1" translate="yes" xml:space="preserve">
          <source>It differs from the forward transform by the sign of the exponential argument and the default normalization by</source>
          <target state="translated">Она отличается от прямого преобразования знаком экспоненциального аргумента и нормализации по умолчанию знаком</target>
        </trans-unit>
        <trans-unit id="d2a43fea3528f404f8930330d870fe7079aa62c4" translate="yes" xml:space="preserve">
          <source>It does &lt;em&gt;not&lt;/em&gt; generally hold that &lt;code&gt;self.strides[-1] == self.itemsize&lt;/code&gt; for C-style contiguous arrays or &lt;code&gt;self.strides[0] == self.itemsize&lt;/code&gt; for Fortran-style contiguous arrays is true.</source>
          <target state="translated">Обычно &lt;em&gt;не&lt;/em&gt; считается, что &lt;code&gt;self.strides[-1] == self.itemsize&lt;/code&gt; для непрерывных массивов в стиле C или &lt;code&gt;self.strides[0] == self.itemsize&lt;/code&gt; для непрерывных массивов в стиле Fortran истинно.</target>
        </trans-unit>
        <trans-unit id="47be37fff5f8f22af765f82be2c6bfbaf9c3032a" translate="yes" xml:space="preserve">
          <source>It has the following structure:</source>
          <target state="translated">Он имеет следующую структуру:</target>
        </trans-unit>
        <trans-unit id="9d66b7021aa904bae4cfae41aeb4ea6450db47e9" translate="yes" xml:space="preserve">
          <source>It has the probability density function</source>
          <target state="translated">Он имеет функцию плотности вероятности</target>
        </trans-unit>
        <trans-unit id="8df067c80d1dbac7caebbaa192d51d71072198f4" translate="yes" xml:space="preserve">
          <source>It helps to understand a bit about how numpy arrays are handled under the covers to help understand numpy better. This section will not go into great detail. Those wishing to understand the full details are referred to Travis Oliphant&amp;rsquo;s book &amp;ldquo;Guide to NumPy&amp;rdquo;.</source>
          <target state="translated">Это помогает немного понять, как массивы numpy обрабатываются под обложками, чтобы лучше понять numpy. Этот раздел не будет вдаваться в подробности. Тем, кто хочет разобраться в деталях, отсылаем к книге Трэвиса Олифанта &amp;laquo;Руководство по NumPy&amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="9bd3e350ace36c053f4770c254bc8bbc0ed59492" translate="yes" xml:space="preserve">
          <source>It is assumed that all indices of &lt;code&gt;x&lt;/code&gt; are summed over in the product, together with the rightmost indices of &lt;code&gt;a&lt;/code&gt;, as is done in, for example, &lt;code&gt;tensordot(a, x, axes=b.ndim)&lt;/code&gt;.</source>
          <target state="translated">Предполагается, что все индексы &lt;code&gt;x&lt;/code&gt; суммируются в произведении вместе с крайними правыми индексами &lt;code&gt;a&lt;/code&gt; , как это делается, например, в &lt;code&gt;tensordot(a, x, axes=b.ndim)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ca7dcbab26b74b24d5b23e3d1dfbaa7bb550a61f" translate="yes" xml:space="preserve">
          <source>It is convenient to use &lt;a href=&quot;numpy.poly1d#numpy.poly1d&quot;&gt;&lt;code&gt;poly1d&lt;/code&gt;&lt;/a&gt; objects for dealing with polynomials:</source>
          <target state="translated">Для работы с полиномами удобно использовать объекты &lt;a href=&quot;numpy.poly1d#numpy.poly1d&quot;&gt; &lt;code&gt;poly1d&lt;/code&gt; &lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="ee3d89b7c311757a10611a623afead7359a99d73" translate="yes" xml:space="preserve">
          <source>It is convenient to use &lt;code&gt;poly1d&lt;/code&gt; objects for dealing with polynomials:</source>
          <target state="translated">Для работы с полиномами удобно использовать объекты &lt;code&gt;poly1d&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="09772c45572066c0ab1839c5da61b341c459c08d" translate="yes" xml:space="preserve">
          <source>It is equivalent to &lt;code&gt;reshape(-1, order=order)&lt;/code&gt;.</source>
          <target state="translated">Это эквивалентно &lt;code&gt;reshape(-1, order=order)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="68e5e295697e350544ce52515eda2757f41a1612" translate="yes" xml:space="preserve">
          <source>It is important to keep the flags updated (using &lt;a href=&quot;#c.PyArray_UpdateFlags&quot;&gt;&lt;code&gt;PyArray_UpdateFlags&lt;/code&gt;&lt;/a&gt; can help) whenever a manipulation with an array is performed that might cause them to change. Later calculations in NumPy that rely on the state of these flags do not repeat the calculation to update them.</source>
          <target state="translated">Важно обновлять флаги ( может помочь использование &lt;a href=&quot;#c.PyArray_UpdateFlags&quot;&gt; &lt;code&gt;PyArray_UpdateFlags&lt;/code&gt; &lt;/a&gt; ) всякий раз, когда выполняется манипуляция с массивом, которая может привести к их изменению. Более поздние вычисления в NumPy, которые зависят от состояния этих флагов, не повторяют вычисления для их обновления.</target>
        </trans-unit>
        <trans-unit id="6dd28e38486b7b23cc628bcffec168f7a3e2908d" translate="yes" xml:space="preserve">
          <source>It is important to note that once the iterator is exited, dangling references (like &lt;code&gt;x&lt;/code&gt; in the example) may or may not share data with the original data &lt;code&gt;a&lt;/code&gt;. If writeback semantics were active, i.e. if &lt;code&gt;x.base.flags.writebackifcopy&lt;/code&gt; is &lt;code&gt;True&lt;/code&gt;, then exiting the iterator will sever the connection between &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;a&lt;/code&gt;, writing to &lt;code&gt;x&lt;/code&gt; will no longer write to &lt;code&gt;a&lt;/code&gt;. If writeback semantics are not active, then &lt;code&gt;x.data&lt;/code&gt; will still point at some part of &lt;code&gt;a.data&lt;/code&gt;, and writing to one will affect the other.</source>
          <target state="translated">Важно отметить, что после выхода из итератора висячие ссылки (например, &lt;code&gt;x&lt;/code&gt; в примере) могут или не могут совместно использовать данные с исходными данными &lt;code&gt;a&lt;/code&gt; . Если семантика обратной записи была активна, т.е. если &lt;code&gt;x.base.flags.writebackifcopy&lt;/code&gt; имеет значение &lt;code&gt;True&lt;/code&gt; , то выход из итератора разорвет соединение между &lt;code&gt;x&lt;/code&gt; и &lt;code&gt;a&lt;/code&gt; , запись в &lt;code&gt;x&lt;/code&gt; больше не будет записывать в &lt;code&gt;a&lt;/code&gt; . Если семантика обратной записи не активна, то &lt;code&gt;x.data&lt;/code&gt; по- прежнему будет указывать на некоторую часть &lt;code&gt;a.data&lt;/code&gt; , и запись в одну повлияет на другую.</target>
        </trans-unit>
        <trans-unit id="a263f6ef91dbde8a42fa624ef445c812e662a622" translate="yes" xml:space="preserve">
          <source>It is intended that all polynomial instances are immutable, therefore augmented operations (&lt;code&gt;+=&lt;/code&gt;, &lt;code&gt;-=&lt;/code&gt;, etc.) and any other functionality that would violate the immutablity of a polynomial instance are intentionally unimplemented.</source>
          <target state="translated">Предполагается, что все экземпляры полинома являются неизменяемыми, поэтому расширенные операции ( &lt;code&gt;+=&lt;/code&gt; , &lt;code&gt;-=&lt;/code&gt; и т. Д.) И любые другие функции, которые могут нарушить неизменность экземпляра полинома, намеренно не реализуются.</target>
        </trans-unit>
        <trans-unit id="8b8f2e17893170efcb86b57f32479a3f40a7b944" translate="yes" xml:space="preserve">
          <source>It is named for the American linguist George Kingsley Zipf, who noted that the frequency of any word in a sample of a language is inversely proportional to its rank in the frequency table.</source>
          <target state="translated">Он назван в честь американского лингвиста Джорджа Кингсли Ципфа,который отметил,что частота любого слова в выборке языка обратно пропорциональна его рангу в таблице частот.</target>
        </trans-unit>
        <trans-unit id="21e4b23be2d40c69036b3d2e468ea13e53868304" translate="yes" xml:space="preserve">
          <source>It is no longer recommended to use this class, even for linear</source>
          <target state="translated">Больше не рекомендуется использовать этот класс,даже для линейных</target>
        </trans-unit>
        <trans-unit id="c8350ce47be17c20baa97fc4d0754bec81b2f208" translate="yes" xml:space="preserve">
          <source>It is no longer recommended to use this class, even for linear algebra. Instead use regular arrays. The class may be removed in the future.</source>
          <target state="translated">Больше не рекомендуется использовать этот класс,даже для линейной алгебры.Вместо этого используйте обычные массивы.В будущем класс может быть удален.</target>
        </trans-unit>
        <trans-unit id="8c5239a5bff654c37cc55078706d5d6b20118c0c" translate="yes" xml:space="preserve">
          <source>It is not always possible to change the shape of an array without copying the data. If you want an error to be raised when the data is copied, you should assign the new shape to the shape attribute of the array:</source>
          <target state="translated">Не всегда можно изменить форму массива,не скопировав данные.Если вы хотите,чтобы при копировании данных возникла ошибка,необходимо присвоить новую форму атрибуту формы массива:</target>
        </trans-unit>
        <trans-unit id="b37f77a2246e7fcb1e0b4774efe6b903d4205875" translate="yes" xml:space="preserve">
          <source>It is often seen in Bayesian inference and order statistics.</source>
          <target state="translated">Это часто встречается в байесовских умозаключениях и статистике заказов.</target>
        </trans-unit>
        <trans-unit id="7bef780e922069dd57c2e5a08856175d82409e4f" translate="yes" xml:space="preserve">
          <source>It is one of a class of extreme value distributions, the Generalized Extreme Value (GEV) distributions, which also includes the Weibull and Frechet.</source>
          <target state="translated">Это один из классов распределений экстремальных значений,Generalized Extreme Value (GEV),который также включает в себя Weibull и Frechet.</target>
        </trans-unit>
        <trans-unit id="36000cdc40cdbba3e0e5f28ba7dcb30e267b4506" translate="yes" xml:space="preserve">
          <source>It is possible to load a library using &amp;gt;&amp;gt;&amp;gt; lib = ctypes.cdll[&amp;lt;full_path_name&amp;gt;] # doctest: +SKIP</source>
          <target state="translated">Библиотеку можно загрузить с помощью &amp;gt;&amp;gt;&amp;gt; lib = ctypes.cdll [&amp;lt;full_path_name&amp;gt;] # doctest: + SKIP</target>
        </trans-unit>
        <trans-unit id="0a211923eef6c9018ec875b45f1ee8aa7feb24f0" translate="yes" xml:space="preserve">
          <source>It is possible to specify config_fc options in setup.py scripts. For example, using</source>
          <target state="translated">Опции config_fc можно указать в скриптах setup.py.Например,используя</target>
        </trans-unit>
        <trans-unit id="3af7692eade07c544a49c1e0a3fa2b4f67d86e02" translate="yes" xml:space="preserve">
          <source>It is possible to specify how boundaries are treated using &lt;code&gt;edge_order&lt;/code&gt;</source>
          <target state="translated">Можно указать, как обрабатываются границы с помощью &lt;code&gt;edge_order&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="006848dc30e65d20b3919e74b2fa41c8170663f6" translate="yes" xml:space="preserve">
          <source>It is recommended to use one of &lt;a href=&quot;numpy.testing.assert_allclose#numpy.testing.assert_allclose&quot;&gt;&lt;code&gt;assert_allclose&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;numpy.testing.assert_array_almost_equal_nulp#numpy.testing.assert_array_almost_equal_nulp&quot;&gt;&lt;code&gt;assert_array_almost_equal_nulp&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;numpy.testing.assert_array_max_ulp#numpy.testing.assert_array_max_ulp&quot;&gt;&lt;code&gt;assert_array_max_ulp&lt;/code&gt;&lt;/a&gt; instead of this function for more consistent floating point comparisons.</source>
          <target state="translated">Рекомендуется использовать одну из &lt;a href=&quot;numpy.testing.assert_allclose#numpy.testing.assert_allclose&quot;&gt; &lt;code&gt;assert_allclose&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;numpy.testing.assert_array_almost_equal_nulp#numpy.testing.assert_array_almost_equal_nulp&quot;&gt; &lt;code&gt;assert_array_almost_equal_nulp&lt;/code&gt; &lt;/a&gt; или &lt;a href=&quot;numpy.testing.assert_array_max_ulp#numpy.testing.assert_array_max_ulp&quot;&gt; &lt;code&gt;assert_array_max_ulp&lt;/code&gt; &lt;/a&gt; вместо этой функции для более согласованных сравнений с плавающей запятой.</target>
        </trans-unit>
        <trans-unit id="e411ddee11ac634d5c4281835040dc7466b061ac" translate="yes" xml:space="preserve">
          <source>It is strongly advised &lt;em&gt;not&lt;/em&gt; to use the matrix subclass. As described below, it makes writing functions that deal consistently with matrices and regular arrays very difficult. Currently, they are mainly used for interacting with &lt;code&gt;scipy.sparse&lt;/code&gt;. We hope to provide an alternative for this use, however, and eventually remove the &lt;code&gt;matrix&lt;/code&gt; subclass.</source>
          <target state="translated">Настоятельно рекомендуется &lt;em&gt;не&lt;/em&gt; использовать подкласс матрицы. Как описано ниже, это очень затрудняет написание функций, которые последовательно работают с матрицами и обычными массивами. В настоящее время они в основном используются для взаимодействия с &lt;code&gt;scipy.sparse&lt;/code&gt; . Однако мы надеемся предоставить альтернативу для этого использования и в конечном итоге удалить подкласс &lt;code&gt;matrix&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7669de0e65d605729606ade6c00d09dc551353c4" translate="yes" xml:space="preserve">
          <source>It is used, for example, in modeling the over-reporting of insurance claims.</source>
          <target state="translated">Он используется,например,при моделировании завышенной отчетности по страховым требованиям.</target>
        </trans-unit>
        <trans-unit id="e32c0ef1527073446df56f2f6fdb74c9774fe25a" translate="yes" xml:space="preserve">
          <source>It is useful for writing classes that do not inherit from &lt;a href=&quot;numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;numpy.ndarray&lt;/code&gt;&lt;/a&gt;, but that should support arithmetic and numpy universal functions like arrays as described in &lt;a href=&quot;https://docs.scipy.org/doc/numpy-1.17.0/neps/nep-0013-ufunc-overrides.html&quot;&gt;A Mechanism for Overriding Ufuncs&lt;/a&gt;.</source>
          <target state="translated">Это полезно для написания классов, которые не наследуются от &lt;a href=&quot;numpy.ndarray#numpy.ndarray&quot;&gt; &lt;code&gt;numpy.ndarray&lt;/code&gt; &lt;/a&gt; , но которые должны поддерживать арифметические и универсальные функции numpy, такие как массивы, как описано в &lt;a href=&quot;https://docs.scipy.org/doc/numpy-1.17.0/neps/nep-0013-ufunc-overrides.html&quot;&gt;Механизме переопределения Ufuncs&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="d3b8ad76686cc18b830ba552fba24082c4f933e5" translate="yes" xml:space="preserve">
          <source>It is worth noting that if</source>
          <target state="translated">Стоит отметить,что если</target>
        </trans-unit>
        <trans-unit id="29b82dd1d6f270f96b8bc45104bc41a8e589f966" translate="yes" xml:space="preserve">
          <source>It isn&amp;rsquo;t always convenient to explicitly use Polynomial instances, so tuples, lists, arrays, and scalars are automatically cast in the arithmetic operations:</source>
          <target state="translated">Не всегда удобно использовать экземпляры Polynomial явно, поэтому кортежи, списки, массивы и скаляры автоматически приводятся в арифметических операциях:</target>
        </trans-unit>
        <trans-unit id="cf495221779c2163a5e7a39d1bf1b540324c978b" translate="yes" xml:space="preserve">
          <source>It landed 4 times on 1, once on 2, etc.</source>
          <target state="translated">Он приземлялся 4 раза на 1,один раз на 2 и т.д.</target>
        </trans-unit>
        <trans-unit id="d1653963d10a9096aa75746f96dbe0fd1387381e" translate="yes" xml:space="preserve">
          <source>It may also be convenient to define a custom decorators (&lt;code&gt;implements&lt;/code&gt; below) for registering &lt;code&gt;__array_function__&lt;/code&gt; implementations.</source>
          <target state="translated">Также может быть удобно определить пользовательские декораторы ( &lt;code&gt;implements&lt;/code&gt; ниже) для регистрации реализаций &lt;code&gt;__array_function__&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="eaadd007be7687e8c25f3eb461c4399e71de7888" translate="yes" xml:space="preserve">
          <source>It should be clear that any structured type could be described using this interface.</source>
          <target state="translated">Должно быть понятно,что с помощью этого интерфейса можно описать любой структурированный тип.</target>
        </trans-unit>
        <trans-unit id="f377563feb8e5b75d15a1cc4f00304a3153cefc3" translate="yes" xml:space="preserve">
          <source>It works in 2-D as well:</source>
          <target state="translated">Он работает и в 2-D:</target>
        </trans-unit>
        <trans-unit id="bb5dacd50e546c91bb0023917cb217930a8f4581" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s possible to assign to copy-on-write array, but values are only written into the memory copy of the array, and not written to disk:</source>
          <target state="translated">Можно назначить массиву копирования при записи, но значения записываются только в копию массива в памяти, а не на диск:</target>
        </trans-unit>
        <trans-unit id="2a92fc5de8c1d7511c762594edc421f16b236424" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s recommended to specify only those config_fc options in such a way that are compiler independent.</source>
          <target state="translated">Рекомендуется указывать только те параметры config_fc таким образом, чтобы они не зависели от компилятора.</target>
        </trans-unit>
        <trans-unit id="c3a9e71b0cabb8c3a03cd16e13045b08078788b6" translate="yes" xml:space="preserve">
          <source>Item selection and manipulation</source>
          <target state="translated">Выбор предметов и манипуляции с ними</target>
        </trans-unit>
        <trans-unit id="867490709f6ff3383fa1fcfac4368fffd68d75ba" translate="yes" xml:space="preserve">
          <source>Items of an array of this data type are wrapped in an &lt;a href=&quot;arrays.scalars#arrays-scalars&quot;&gt;array scalar&lt;/a&gt; type that also has two fields:</source>
          <target state="translated">Элементы массива этого типа данных заключены в &lt;a href=&quot;arrays.scalars#arrays-scalars&quot;&gt;скалярный&lt;/a&gt; тип массива, который также имеет два поля:</target>
        </trans-unit>
        <trans-unit id="7b5cbf04c6d27c2ce2fa2026bd76b8e62a482e6d" translate="yes" xml:space="preserve">
          <source>Iterating Over Arrays</source>
          <target state="translated">чередующиеся массивы</target>
        </trans-unit>
        <trans-unit id="61c7e36ee871033d37342fea4c9a477a22a3ad15" translate="yes" xml:space="preserve">
          <source>Iterating as a Specific Data Type</source>
          <target state="translated">Итерация в качестве специфического типа данных</target>
        </trans-unit>
        <trans-unit id="1844648c4af60a1a170cdaf38688443ce7ba666d" translate="yes" xml:space="preserve">
          <source>Iterating over arrays</source>
          <target state="translated">чередующиеся массивы</target>
        </trans-unit>
        <trans-unit id="3c8101d6360b4040707379e2577c7a16fa0bf84e" translate="yes" xml:space="preserve">
          <source>Iteration is done in row-major, C-style order (the last index varying the fastest). The iterator can also be indexed using basic slicing or advanced indexing.</source>
          <target state="translated">Итерация выполняется в последовательности рядов,в стиле С (последний индекс меняется быстрее всего).Итератор также может быть проиндексирован с использованием базовой нарезки или расширенной индексации.</target>
        </trans-unit>
        <trans-unit id="acbcdc45d250ba7dd26edab06186cf3962745972" translate="yes" xml:space="preserve">
          <source>Iterator Data Types</source>
          <target state="translated">Типы данных итератора</target>
        </trans-unit>
        <trans-unit id="21aa412ed70b91ee6a2ff89a4abea36c2af42360" translate="yes" xml:space="preserve">
          <source>Iterator flag &lt;a href=&quot;#c.NPY_ITER_COMMON_DTYPE&quot;&gt;&lt;code&gt;NPY_ITER_COMMON_DTYPE&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">Флаг итератора &lt;a href=&quot;#c.NPY_ITER_COMMON_DTYPE&quot;&gt; &lt;code&gt;NPY_ITER_COMMON_DTYPE&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="a1116d7dda5125208b276ad5471ddd5d08e64ba8" translate="yes" xml:space="preserve">
          <source>Iterator flag &lt;a href=&quot;#c.NPY_ITER_EXTERNAL_LOOP&quot;&gt;&lt;code&gt;NPY_ITER_EXTERNAL_LOOP&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">Флаг итератора &lt;a href=&quot;#c.NPY_ITER_EXTERNAL_LOOP&quot;&gt; &lt;code&gt;NPY_ITER_EXTERNAL_LOOP&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="1b6f69b38ac0228e9245d67b9b1d09ee42bc5dcb" translate="yes" xml:space="preserve">
          <source>Iterator for broadcasting</source>
          <target state="translated">Итератор для вещания</target>
        </trans-unit>
        <trans-unit id="6425854ab104811d699d59fa557478463a96d42e" translate="yes" xml:space="preserve">
          <source>Iterator-Allocated Output Arrays</source>
          <target state="translated">Массивы вывода,распределенные по итераторам</target>
        </trans-unit>
        <trans-unit id="3ea20b9878659e33fbac6ee844497cef84a926f4" translate="yes" xml:space="preserve">
          <source>Iterators are a powerful concept for array processing. Essentially, iterators implement a generalized for-loop. If &lt;em&gt;myiter&lt;/em&gt; is an iterator object, then the Python code:</source>
          <target state="translated">Итераторы - мощная концепция обработки массивов. По сути, итераторы реализуют обобщенный цикл for. Если &lt;em&gt;myiter&lt;/em&gt; является объектом-итератором, тогда код Python:</target>
        </trans-unit>
        <trans-unit id="57d54f82f4390510a92d95c53ba668fb5b8d3f93" translate="yes" xml:space="preserve">
          <source>Its probability density function is</source>
          <target state="translated">Его функция плотности вероятности</target>
        </trans-unit>
        <trans-unit id="a2cbec366193e4ee99c0016c5fe79f216b41e583" translate="yes" xml:space="preserve">
          <source>J. F. Kaiser, &amp;ldquo;Digital Filters&amp;rdquo; - Ch 7 in &amp;ldquo;Systems analysis by digital computer&amp;rdquo;, Editors: F.F. Kuo and J.F. Kaiser, p 218-285. John Wiley and Sons, New York, (1966).</source>
          <target state="translated">Дж. Ф. Кайзер, &amp;laquo;Цифровые фильтры&amp;raquo; - глава 7 в &amp;laquo;Системный анализ с помощью цифрового компьютера&amp;raquo;, редакторы: Ф. Ф. Куо и Дж. Ф. Кайзер, стр. 218-285. Джон Уайли и сыновья, Нью-Йорк, (1966).</target>
        </trans-unit>
        <trans-unit id="d85b6dd0eee475b31af984e7ef5b76c826173395" translate="yes" xml:space="preserve">
          <source>John K. Salmon, Mark A. Moraes, Ron O. Dror, and David E. Shaw, &amp;ldquo;Parallel Random Numbers: As Easy as 1, 2, 3,&amp;rdquo; Proceedings of the International Conference for High Performance Computing, Networking, Storage and Analysis (SC11), New York, NY: ACM, 2011.</source>
          <target state="translated">Джон К. Сэлмон, Марк А. Мораес, Рон О. Дрор и Дэвид Э. Шоу, &amp;laquo;Параллельные случайные числа: так же просто, как 1, 2, 3&amp;raquo;, Труды Международной конференции по высокопроизводительным вычислениям, сетевым технологиям, системам хранения и Анализ (SC11), Нью-Йорк, Нью-Йорк: ACM, 2011.</target>
        </trans-unit>
        <trans-unit id="5955c7d39672a39a399f419793e9d4b2998a0ae1" translate="yes" xml:space="preserve">
          <source>Join a sequence of arrays along a new axis.</source>
          <target state="translated">Присоедините последовательность массивов вдоль новой оси.</target>
        </trans-unit>
        <trans-unit id="4ea1c9ee9a15b3dcbf6e5bf8c6f47b37d396752b" translate="yes" xml:space="preserve">
          <source>Join a sequence of arrays along an existing axis.</source>
          <target state="translated">Присоедините последовательность массивов вдоль существующей оси.</target>
        </trans-unit>
        <trans-unit id="c169b65bb5e75fcaa26f3cb74e710ac8d05e200a" translate="yes" xml:space="preserve">
          <source>Join a sequence of arrays together.</source>
          <target state="translated">Соедините последовательность массивов вместе.</target>
        </trans-unit>
        <trans-unit id="ace77e0ad40f2680b6aa7f69f4dfbec0108a72b3" translate="yes" xml:space="preserve">
          <source>Join the sequence of objects in &lt;em&gt;obj&lt;/em&gt; together along &lt;em&gt;axis&lt;/em&gt; into a single array. If the dimensions or types are not compatible an error is raised.</source>
          <target state="translated">Объедините последовательность объектов в &lt;em&gt;obj&lt;/em&gt; вместе вдоль &lt;em&gt;оси&lt;/em&gt; в единый массив. Если размеры или типы несовместимы, возникает ошибка.</target>
        </trans-unit>
        <trans-unit id="930021877100c692fce1a3c6407a5fca82ef8115" translate="yes" xml:space="preserve">
          <source>Joining arrays</source>
          <target state="translated">Соединительные массивы</target>
        </trans-unit>
        <trans-unit id="1ad4711cdf3c76bf58efbbfffae229363be1de78" translate="yes" xml:space="preserve">
          <source>July 26, 2019</source>
          <target state="translated">26 июля 2019 года</target>
        </trans-unit>
        <trans-unit id="0ea4fce60f72408c555e74c1176fd49b9f6f546a" translate="yes" xml:space="preserve">
          <source>Jump Size</source>
          <target state="translated">Размер прыжка</target>
        </trans-unit>
        <trans-unit id="2f4eece64596ae5728be928b098daa67afdcbd49" translate="yes" xml:space="preserve">
          <source>Jumping the BitGenerator state</source>
          <target state="translated">Прыжок в состояние БитГенератора</target>
        </trans-unit>
        <trans-unit id="d3780087bf4b8552cfaeefd4ae432b76ab3d8ec4" translate="yes" xml:space="preserve">
          <source>Jumps the state as-if jumps * 210306068529402873165736369884012333109 random numbers have been generated.</source>
          <target state="translated">Прыжки состояния as-if прыжки*210306068529402873165736369884012333109 были сгенерированы случайные числа.</target>
        </trans-unit>
        <trans-unit id="c5a2ccc2c43427a5df3aae2525cebca91213ce58" translate="yes" xml:space="preserve">
          <source>Just like the case for builtin special methods like &lt;code&gt;__add__&lt;/code&gt;, properly written &lt;code&gt;__array_function__&lt;/code&gt; methods should always return &lt;code&gt;NotImplemented&lt;/code&gt; when an unknown type is encountered. Otherwise, it will be impossible to correctly override NumPy functions from another object if the operation also includes one of your objects.</source>
          <target state="translated">Как и в случае со встроенными специальными методами, такими как &lt;code&gt;__add__&lt;/code&gt; , правильно написанные методы &lt;code&gt;__array_function__&lt;/code&gt; всегда должны возвращать &lt;code&gt;NotImplemented&lt;/code&gt; при обнаружении неизвестного типа. В противном случае будет невозможно правильно переопределить функции NumPy из другого объекта, если операция также включает один из ваших объектов.</target>
        </trans-unit>
        <trans-unit id="04e171a322d7a93c71ab2aebd91bfaf316577346" translate="yes" xml:space="preserve">
          <source>Key to use in the Philox state. Unlike seed, the value in key is directly set. Can be either a Python int in [0, 2**128) or a 2-element uint64 array. &lt;code&gt;key&lt;/code&gt; and &lt;code&gt;seed&lt;/code&gt; cannot both be used.</source>
          <target state="translated">Ключ для использования в состоянии Philox. В отличие от seed, значение ключа устанавливается напрямую. Может быть либо Python int в [0, 2 ** 128), либо двухэлементным массивом uint64. &lt;code&gt;key&lt;/code&gt; и &lt;code&gt;seed&lt;/code&gt; не могут использоваться одновременно.</target>
        </trans-unit>
        <trans-unit id="a4f25f4e01bab825ac7968a35cf2573aecf46441" translate="yes" xml:space="preserve">
          <source>Keyword arguments passed to &lt;code&gt;func&lt;/code&gt;.</source>
          <target state="translated">Аргументы &lt;code&gt;func&lt;/code&gt; слова, переданные в func .</target>
        </trans-unit>
        <trans-unit id="936d17141932bddd8cdbe3cf3d8e6417d18816b5" translate="yes" xml:space="preserve">
          <source>Keyword arguments used in calling &lt;a href=&quot;#numpy.piecewise&quot;&gt;&lt;code&gt;piecewise&lt;/code&gt;&lt;/a&gt; are passed to the functions upon execution, i.e., if called &lt;code&gt;piecewise(..., ..., alpha=1)&lt;/code&gt;, then each function is called as &lt;code&gt;f(x, alpha=1)&lt;/code&gt;.</source>
          <target state="translated">Аргументы ключевого слова, используемые при &lt;a href=&quot;#numpy.piecewise&quot;&gt; &lt;code&gt;piecewise&lt;/code&gt; &lt;/a&gt; вызове , передаются функциям при выполнении, т.е. если вызывается кусочно &lt;code&gt;piecewise(..., ..., alpha=1)&lt;/code&gt; , то каждая функция вызывается как &lt;code&gt;f(x, alpha=1)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7b38351b3da46b01757fe5df0b763a6ba88d3175" translate="yes" xml:space="preserve">
          <source>Keyword arguments. The valid keywords are the possible floating-point exceptions. Each keyword should have a string value that defines the treatment for the particular error. Possible values are {&amp;lsquo;ignore&amp;rsquo;, &amp;lsquo;warn&amp;rsquo;, &amp;lsquo;raise&amp;rsquo;, &amp;lsquo;call&amp;rsquo;, &amp;lsquo;print&amp;rsquo;, &amp;lsquo;log&amp;rsquo;}.</source>
          <target state="translated">Аргументы ключевого слова. Допустимые ключевые слова - это возможные исключения для чисел с плавающей запятой. Каждое ключевое слово должно иметь строковое значение, которое определяет лечение конкретной ошибки. Возможные значения: {'ignore', 'warn', 'raise', 'call', 'print', 'log'}.</target>
        </trans-unit>
        <trans-unit id="cca3dd937ca64fcc731c3b76e10a3a59e197b380" translate="yes" xml:space="preserve">
          <source>Keywords other than &lt;a href=&quot;numpy.dtype#numpy.dtype&quot;&gt;&lt;code&gt;dtype&lt;/code&gt;&lt;/a&gt; are passed to &lt;code&gt;function&lt;/code&gt;.</source>
          <target state="translated">Ключевые слова, кроме &lt;a href=&quot;numpy.dtype#numpy.dtype&quot;&gt; &lt;code&gt;dtype&lt;/code&gt; &lt;/a&gt; передаются &lt;code&gt;function&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="bd51c0cf5320b73d3ff55b2176ad245d2d7397b1" translate="yes" xml:space="preserve">
          <source>Keywords other than &lt;code&gt;dtype&lt;/code&gt; are passed to &lt;code&gt;function&lt;/code&gt;.</source>
          <target state="translated">Ключевые слова, кроме &lt;code&gt;dtype&lt;/code&gt; передаются &lt;code&gt;function&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5c23ce94abbcda9863c972bac23c6a2a76bdd7d1" translate="yes" xml:space="preserve">
          <source>Kind of floating point data-type about which to get information.</source>
          <target state="translated">Вид данных с плавающей точкой,о которых можно получить информацию.</target>
        </trans-unit>
        <trans-unit id="31be8fd23c00b4b851fa5f224f6fd4dac29e08c9" translate="yes" xml:space="preserve">
          <source>Known bugs:</source>
          <target state="translated">Известные жуки:</target>
        </trans-unit>
        <trans-unit id="26db35f7eb95d8b793f4df612e64a0ce6b5afd47" translate="yes" xml:space="preserve">
          <source>Known failures &amp;amp; skipping tests</source>
          <target state="translated">Известные сбои и пропуск тестов</target>
        </trans-unit>
        <trans-unit id="d54ed0ae4c90f25216ec62895c50ba0c59603696" translate="yes" xml:space="preserve">
          <source>Kotz, Samuel, et. al. &amp;ldquo;The Laplace Distribution and Generalizations, &amp;rdquo; Birkhauser, 2001.</source>
          <target state="translated">Коц, Самуэль и др. al. &amp;laquo;Распределение Лапласа и обобщения&amp;raquo;, Бирхаузер, 2001.</target>
        </trans-unit>
        <trans-unit id="9b54aa8ed101113f4ff654653787cb490d5956f9" translate="yes" xml:space="preserve">
          <source>Kronecker product of two arrays.</source>
          <target state="translated">Кронекер продукт из двух массивов.</target>
        </trans-unit>
        <trans-unit id="0c5ca7c9489e795d6e344494ca6012e6c5e6c94a" translate="yes" xml:space="preserve">
          <source>L. J. Gitman, &amp;ldquo;Principles of Managerial Finance, Brief,&amp;rdquo; 3rd ed., Addison-Wesley, 2003, pg. 346.</source>
          <target state="translated">LJ Gitman, &amp;laquo;Принципы управленческих финансов, краткое изложение&amp;raquo;, 3-е изд., Addison-Wesley, 2003, pg. 346.</target>
        </trans-unit>
        <trans-unit id="dad744be14f4bac6567fee2e00e8179f1cafc777" translate="yes" xml:space="preserve">
          <source>L. J. Gitman, &amp;ldquo;Principles of Managerial Finance, Brief,&amp;rdquo; 3rd ed., Addison-Wesley, 2003, pg. 348.</source>
          <target state="translated">LJ Gitman, &amp;laquo;Принципы управленческих финансов, краткое изложение&amp;raquo;, 3-е изд., Addison-Wesley, 2003, pg. 348.</target>
        </trans-unit>
        <trans-unit id="f50beb264ce7d144bf1ce0f2f4d3f272a300b7de" translate="yes" xml:space="preserve">
          <source>Label a test as &amp;lsquo;slow&amp;rsquo;.</source>
          <target state="translated">Обозначьте тест как &amp;laquo;медленный&amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="369c34c1729b62dec5c01c92266ffbd20a59873d" translate="yes" xml:space="preserve">
          <source>Labeling tests</source>
          <target state="translated">Маркировочные испытания</target>
        </trans-unit>
        <trans-unit id="4bebfc5e6e36da81205979cf627ca2083b60eab7" translate="yes" xml:space="preserve">
          <source>Laguerre</source>
          <target state="translated">Laguerre</target>
        </trans-unit>
        <trans-unit id="5e57606aead53cf91effb25cd081645a48be4c71" translate="yes" xml:space="preserve">
          <source>Laguerre Class</source>
          <target state="translated">класс Лагерра</target>
        </trans-unit>
        <trans-unit id="ba379f482d893a166d54a2acffc47cc917ce664e" translate="yes" xml:space="preserve">
          <source>Laguerre Module (&lt;code&gt;numpy.polynomial.laguerre&lt;/code&gt;)</source>
          <target state="translated">Модуль Лагерра ( &lt;code&gt;numpy.polynomial.laguerre&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="1fa1d2e4107d4f18290f33c4164e9ffd20858112" translate="yes" xml:space="preserve">
          <source>Laguerre Module (numpy.polynomial.laguerre)</source>
          <target state="translated">Модуль Лагуэра (нумизматический.полиномиальный.лагуэр)</target>
        </trans-unit>
        <trans-unit id="99466c13dff878e880a6ce449247757d575c46d1" translate="yes" xml:space="preserve">
          <source>Laguerre coefficients in order of increasing degree, i.e, &lt;code&gt;(1, 2, 3)&lt;/code&gt; gives &lt;code&gt;1*L_0(x) + 2*L_1(X) + 3*L_2(x)&lt;/code&gt;.</source>
          <target state="translated">Коэффициенты Лагерра в порядке возрастания степени, то есть &lt;code&gt;(1, 2, 3)&lt;/code&gt; дает &lt;code&gt;1*L_0(x) + 2*L_1(X) + 3*L_2(x)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="96781eb22440929e4bf56e8413b2c4b2ee004cfa" translate="yes" xml:space="preserve">
          <source>Laguerre coefficients ordered from low to high. If &lt;code&gt;y&lt;/code&gt; was 2-D, the coefficients for the data in column k of &lt;code&gt;y&lt;/code&gt; are in column &lt;code&gt;k&lt;/code&gt;.</source>
          <target state="translated">Коэффициенты Лагерра упорядочены по возрастанию. Если &lt;code&gt;y&lt;/code&gt; было 2-D, коэффициенты для данных в столбце k &lt;code&gt;y&lt;/code&gt; находятся в столбце &lt;code&gt;k&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="203d5e91f105ffb95930f626e1d302a193aeaa68" translate="yes" xml:space="preserve">
          <source>Laguerre series</source>
          <target state="translated">серия Лагерр</target>
        </trans-unit>
        <trans-unit id="a347ea54d317cc577991ec7bf8e660f33b29ea5f" translate="yes" xml:space="preserve">
          <source>Laguerre series coefficients of the integral.</source>
          <target state="translated">Коэффициенты ряда Лагерра интеграла.</target>
        </trans-unit>
        <trans-unit id="d470a6ac507868056b6fb97be3c38f8e66fd3f73" translate="yes" xml:space="preserve">
          <source>Laguerre series of power.</source>
          <target state="translated">Серия Лагерр.</target>
        </trans-unit>
        <trans-unit id="077697f66c66782d4ef98066ee75e7065a9fd35e" translate="yes" xml:space="preserve">
          <source>Laguerre series of the derivative.</source>
          <target state="translated">Серия Лагерр производной.</target>
        </trans-unit>
        <trans-unit id="9a5deb2e7228ec3244f92981a2f639bd0074c61e" translate="yes" xml:space="preserve">
          <source>Laguerre series whose graph is a straight line.</source>
          <target state="translated">Серия Лагерр,график которой представляет собой прямую линию.</target>
        </trans-unit>
        <trans-unit id="40be499dbcfef954b53f79728a280796ea6c4f1b" translate="yes" xml:space="preserve">
          <source>Laguerre weight function.</source>
          <target state="translated">Функция веса Лагерра.</target>
        </trans-unit>
        <trans-unit id="19b66881a109c4450aeadcaedc080b0375d2ecf9" translate="yes" xml:space="preserve">
          <source>Laguerre.__call__()</source>
          <target state="translated">Laguerre.__call__()</target>
        </trans-unit>
        <trans-unit id="b79eed7b566471b5b98d5403131d5fcccb9ccdd6" translate="yes" xml:space="preserve">
          <source>Laguerre.basis()</source>
          <target state="translated">Laguerre.basis()</target>
        </trans-unit>
        <trans-unit id="8450b9cd56cfc84841f9b6a7b3ce8b6553391224" translate="yes" xml:space="preserve">
          <source>Laguerre.cast()</source>
          <target state="translated">Laguerre.cast()</target>
        </trans-unit>
        <trans-unit id="27a50de57a0c19215d0a40ab26d7fc3244818104" translate="yes" xml:space="preserve">
          <source>Laguerre.convert()</source>
          <target state="translated">Laguerre.convert()</target>
        </trans-unit>
        <trans-unit id="ba2566270efed850de8b718e7293f07a260b676d" translate="yes" xml:space="preserve">
          <source>Laguerre.copy()</source>
          <target state="translated">Laguerre.copy()</target>
        </trans-unit>
        <trans-unit id="3b52ca7dceafcdacc78576d128623ad1866249fc" translate="yes" xml:space="preserve">
          <source>Laguerre.cutdeg()</source>
          <target state="translated">Laguerre.cutdeg()</target>
        </trans-unit>
        <trans-unit id="d2b6b76b4b9ee361106b2c94187d00faaf8bec52" translate="yes" xml:space="preserve">
          <source>Laguerre.degree()</source>
          <target state="translated">Laguerre.degree()</target>
        </trans-unit>
        <trans-unit id="00ba5991cdfe21416f272ddb4e2fd2ee48ba1e73" translate="yes" xml:space="preserve">
          <source>Laguerre.deriv()</source>
          <target state="translated">Laguerre.deriv()</target>
        </trans-unit>
        <trans-unit id="3774c67b9a36d28184dc80e1b4d2486ea1e1f36a" translate="yes" xml:space="preserve">
          <source>Laguerre.domain</source>
          <target state="translated">Laguerre.domain</target>
        </trans-unit>
        <trans-unit id="b85b503244ce55e050a887342980da72b2e9ad78" translate="yes" xml:space="preserve">
          <source>Laguerre.fit()</source>
          <target state="translated">Laguerre.fit()</target>
        </trans-unit>
        <trans-unit id="23af0332e2c429442e5afb68340fa4aeef4545dc" translate="yes" xml:space="preserve">
          <source>Laguerre.fromroots()</source>
          <target state="translated">Laguerre.fromroots()</target>
        </trans-unit>
        <trans-unit id="a2a6581abb5a91aaeac7e93a2a256734282432d3" translate="yes" xml:space="preserve">
          <source>Laguerre.has_samecoef()</source>
          <target state="translated">Laguerre.has_samecoef()</target>
        </trans-unit>
        <trans-unit id="7dd4d8134966100274e963f0060bfab576b5fddf" translate="yes" xml:space="preserve">
          <source>Laguerre.has_samedomain()</source>
          <target state="translated">Laguerre.has_samedomain()</target>
        </trans-unit>
        <trans-unit id="e5e59e81443c19ac8f19e8c2fdccb120a1c9224f" translate="yes" xml:space="preserve">
          <source>Laguerre.has_sametype()</source>
          <target state="translated">Laguerre.has_sametype()</target>
        </trans-unit>
        <trans-unit id="3d138070a5021011806b89098bbe766378b10e7e" translate="yes" xml:space="preserve">
          <source>Laguerre.has_samewindow()</source>
          <target state="translated">Laguerre.has_samewindow()</target>
        </trans-unit>
        <trans-unit id="6f69d4698823efec4ccf07af22829cc894b0b98c" translate="yes" xml:space="preserve">
          <source>Laguerre.identity()</source>
          <target state="translated">Laguerre.identity()</target>
        </trans-unit>
        <trans-unit id="f1f6d872a178e7692b45f4ccbfd34fbbf6ed5f91" translate="yes" xml:space="preserve">
          <source>Laguerre.integ()</source>
          <target state="translated">Laguerre.integ()</target>
        </trans-unit>
        <trans-unit id="068cb46402017cfb3dd18164c9b41f89c700f799" translate="yes" xml:space="preserve">
          <source>Laguerre.linspace()</source>
          <target state="translated">Laguerre.linspace()</target>
        </trans-unit>
        <trans-unit id="100d51943018ffa8eadce404d26cfaa31b915872" translate="yes" xml:space="preserve">
          <source>Laguerre.mapparms()</source>
          <target state="translated">Laguerre.mapparms()</target>
        </trans-unit>
        <trans-unit id="de9dd46ebdab9f670b65d8cedb81c132ac30c276" translate="yes" xml:space="preserve">
          <source>Laguerre.roots()</source>
          <target state="translated">Laguerre.roots()</target>
        </trans-unit>
        <trans-unit id="9779fb4f29c73da5d6cee5ec234239b97271c1ae" translate="yes" xml:space="preserve">
          <source>Laguerre.trim()</source>
          <target state="translated">Laguerre.trim()</target>
        </trans-unit>
        <trans-unit id="76a59bb3d54a6db3b464f00c41f8b5a8b4767c11" translate="yes" xml:space="preserve">
          <source>Laguerre.truncate()</source>
          <target state="translated">Laguerre.truncate()</target>
        </trans-unit>
        <trans-unit id="36198a8897031e87556aee045b29805731052142" translate="yes" xml:space="preserve">
          <source>Laplaces</source>
          <target state="translated">Laplaces</target>
        </trans-unit>
        <trans-unit id="da46491a1118285dbcf5975a2a3f36f864e4e6eb" translate="yes" xml:space="preserve">
          <source>Large parts of this manual originate from Travis E. Oliphant&amp;rsquo;s book &lt;a href=&quot;https://archive.org/details/NumPyBook&quot;&gt;Guide to NumPy&lt;/a&gt; (which generously entered Public Domain in August 2008). The reference documentation for many of the functions are written by numerous contributors and developers of NumPy.</source>
          <target state="translated">Большая часть этого руководства взята из книги Трэвиса Э. Олифанта &amp;laquo; &lt;a href=&quot;https://archive.org/details/NumPyBook&quot;&gt;Руководство по NumPy&amp;raquo;&lt;/a&gt; (которая в августе 2008 года вошла в общественное достояние). Справочная документация для многих функций написана многочисленными участниками и разработчиками NumPy.</target>
        </trans-unit>
        <trans-unit id="2fdae5c61df170eabed81dff27bfb3678199f99b" translate="yes" xml:space="preserve">
          <source>Largest size allowed for the user-settable buffers.</source>
          <target state="translated">Наибольший допустимый размер для устанавливаемых пользователем буферов.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
