<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ru" datatype="htmlbody" original="numpy">
    <body>
      <group id="numpy">
        <trans-unit id="71fff5ea85661c16e7519843bc17a41ff8e91eb9" translate="yes" xml:space="preserve">
          <source>Distributions</source>
          <target state="translated">Distributions</target>
        </trans-unit>
        <trans-unit id="8b193321a119fbd0dcd684bd2d9426886ca75352" translate="yes" xml:space="preserve">
          <source>Divide one Chebyshev series by another.</source>
          <target state="translated">Разделите одну серию Чебышева на другую.</target>
        </trans-unit>
        <trans-unit id="143efc24501a0aca7c9b8146445d3052ccca2768" translate="yes" xml:space="preserve">
          <source>Divide one Hermite series by another.</source>
          <target state="translated">Разделите одну серию &quot;Эрмита&quot; на другую.</target>
        </trans-unit>
        <trans-unit id="59969920d0ad8492606516de2799361ab80e51e4" translate="yes" xml:space="preserve">
          <source>Divide one Laguerre series by another.</source>
          <target state="translated">Разделите одну серию Лагер на другую.</target>
        </trans-unit>
        <trans-unit id="cb8fb14724e04e74acd5ed518b7956bde57f9f7f" translate="yes" xml:space="preserve">
          <source>Divide one Legendre series by another.</source>
          <target state="translated">Разделите один сериал &quot;Легенда&quot; на другой.</target>
        </trans-unit>
        <trans-unit id="53b11bc9ec8586eecc94bbdfc2f103e8f1cdcb61" translate="yes" xml:space="preserve">
          <source>Divide one polynomial by another.</source>
          <target state="translated">Разделите один полиноминал на другой.</target>
        </trans-unit>
        <trans-unit id="c51ce5484f877f3b3126642a285f454856b1a199" translate="yes" xml:space="preserve">
          <source>Divide other into self, and return a new masked array.</source>
          <target state="translated">Разделите другого на себя и верните новый массив.</target>
        </trans-unit>
        <trans-unit id="2ef1e5ad95321353adac46fbc8491e615e836d21" translate="yes" xml:space="preserve">
          <source>Divide self by other in-place.</source>
          <target state="translated">Разделитесь на других на месте.</target>
        </trans-unit>
        <trans-unit id="1e3c651961978f36b837c449de83e63bcfcd74e0" translate="yes" xml:space="preserve">
          <source>Divide self into other, and return a new masked array.</source>
          <target state="translated">Разделите себя на других и верните новый массив.</target>
        </trans-unit>
        <trans-unit id="fdde9e15039c0cebf1238ec9b7a4737bb63abb02" translate="yes" xml:space="preserve">
          <source>Dividend array.</source>
          <target state="translated">Дивидендный массив.</target>
        </trans-unit>
        <trans-unit id="94054a2bd282906d6045981a996c888ef4e4b84a" translate="yes" xml:space="preserve">
          <source>Dividend polynomial&amp;rsquo;s coefficients.</source>
          <target state="translated">Коэффициенты дивидендного полинома.</target>
        </trans-unit>
        <trans-unit id="ae3d5366321b2cda8048303484a9efb3b8012809" translate="yes" xml:space="preserve">
          <source>Dividend.</source>
          <target state="translated">Dividend.</target>
        </trans-unit>
        <trans-unit id="3da76ff26283ccdfb95f22f35e70c08074f9c0d6" translate="yes" xml:space="preserve">
          <source>Division by zero: infinite result obtained from finite numbers.</source>
          <target state="translated">Деление на ноль:бесконечный результат,полученный из конечных чисел.</target>
        </trans-unit>
        <trans-unit id="5c970858ddd5ebfccc0979913547b40892ea84f0" translate="yes" xml:space="preserve">
          <source>Division:</source>
          <target state="translated">Division:</target>
        </trans-unit>
        <trans-unit id="e528cec9df846efb2d96080851febbb0ef5214b8" translate="yes" xml:space="preserve">
          <source>Divisor array. If &lt;code&gt;x1.shape != x2.shape&lt;/code&gt;, they must be broadcastable to a common shape (which becomes the shape of the output).</source>
          <target state="translated">Массив делителей. Если &lt;code&gt;x1.shape != x2.shape&lt;/code&gt; , они должны транслироваться в общую форму (которая становится формой вывода).</target>
        </trans-unit>
        <trans-unit id="35ac85bf74de66241c9334431207aa5df69df721" translate="yes" xml:space="preserve">
          <source>Divisor polynomial&amp;rsquo;s coefficients.</source>
          <target state="translated">Коэффициенты полинома делителя.</target>
        </trans-unit>
        <trans-unit id="a079e40a62a4209488cf119d0047ff12fb70cf71" translate="yes" xml:space="preserve">
          <source>Divisor. If &lt;code&gt;x1.shape != x2.shape&lt;/code&gt;, they must be broadcastable to a common shape (which becomes the shape of the output).</source>
          <target state="translated">Делитель. Если &lt;code&gt;x1.shape != x2.shape&lt;/code&gt; , они должны транслироваться в общую форму (которая становится формой вывода).</target>
        </trans-unit>
        <trans-unit id="1a536da5cd434d26e0ec447ec43ce448909aa6d1" translate="yes" xml:space="preserve">
          <source>Divmod:</source>
          <target state="translated">Divmod:</target>
        </trans-unit>
        <trans-unit id="3d78017db5e95583684a29d66eb903a8ce60aba4" translate="yes" xml:space="preserve">
          <source>Do a keyword search on docstrings.</source>
          <target state="translated">Выполните поиск по ключевым словам в строках подписи.</target>
        </trans-unit>
        <trans-unit id="ea9d279c47a9187c1db7b1f7b114b04d8f0172e5" translate="yes" xml:space="preserve">
          <source>Do not lose the type info if the sequence contains unknown objects.</source>
          <target state="translated">Не теряйте информацию о типе,если последовательность содержит неизвестные объекты.</target>
        </trans-unit>
        <trans-unit id="37d435c090c5ec2cb12a71fd3a6a6e5087869ea8" translate="yes" xml:space="preserve">
          <source>Do not rely on the combination of &lt;code&gt;tofile&lt;/code&gt; and &lt;a href=&quot;#numpy.fromfile&quot;&gt;&lt;code&gt;fromfile&lt;/code&gt;&lt;/a&gt; for data storage, as the binary files generated are are not platform independent. In particular, no byte-order or data-type information is saved. Data can be stored in the platform independent &lt;code&gt;.npy&lt;/code&gt; format using &lt;a href=&quot;numpy.save#numpy.save&quot;&gt;&lt;code&gt;save&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;numpy.load#numpy.load&quot;&gt;&lt;code&gt;load&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">Не полагайтесь на комбинацию &lt;code&gt;tofile&lt;/code&gt; и &lt;a href=&quot;#numpy.fromfile&quot;&gt; &lt;code&gt;fromfile&lt;/code&gt; &lt;/a&gt; для хранения данных, поскольку генерируемые двоичные файлы не зависят от платформы. В частности, не сохраняется информация о порядке байтов или типах данных. Данные могут быть сохранены в независимом от платформы формате &lt;code&gt;.npy&lt;/code&gt; с использованием вместо этого &lt;a href=&quot;numpy.save#numpy.save&quot;&gt; &lt;code&gt;save&lt;/code&gt; &lt;/a&gt; и &lt;a href=&quot;numpy.load#numpy.load&quot;&gt; &lt;code&gt;load&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="a3e1823cbbdfbb28b0abf8529520a9bf10c3f493" translate="yes" xml:space="preserve">
          <source>Do not use the Python keywords &lt;code&gt;and&lt;/code&gt; and &lt;code&gt;or&lt;/code&gt; to combine logical array expressions. These keywords will test the truth value of the entire array (not element-by-element as you might expect). Use the bitwise operators &amp;amp; and | instead.</source>
          <target state="translated">Не используйте ключевые слова Python &lt;code&gt;and&lt;/code&gt; и &lt;code&gt;or&lt;/code&gt; для объединения выражений логического массива. Эти ключевые слова будут проверять истинное значение всего массива (а не поэлементно, как вы могли ожидать). Используйте побитовые операторы &amp;amp; и | вместо.</target>
        </trans-unit>
        <trans-unit id="5e01c221d853296d84e769113c74b2df4ca129d1" translate="yes" xml:space="preserve">
          <source>Doctests</source>
          <target state="translated">Doctests</target>
        </trans-unit>
        <trans-unit id="974974af4b7655224f60ff495507eedae4f6994e" translate="yes" xml:space="preserve">
          <source>Doctests are a convenient way of documenting the behavior of a function and allowing that behavior to be tested at the same time. The output of an interactive Python session can be included in the docstring of a function, and the test framework can run the example and compare the actual output to the expected output.</source>
          <target state="translated">Доктесты-это удобный способ документирования поведения функции и позволяющий одновременно проверить это поведение.Вывод интерактивного сеанса Python может быть включен в доктрину функции,а тестовый фреймворк может запустить пример и сравнить фактический вывод с ожидаемым.</target>
        </trans-unit>
        <trans-unit id="d2706eec51222f32b825a53b6e68123a18fe8dfd" translate="yes" xml:space="preserve">
          <source>Documentation for the ufunc. Should not contain the function signature as this is generated dynamically when __doc__ is retrieved.</source>
          <target state="translated">Документация для ufunc.Не должна содержать сигнатуру функции,так как она генерируется динамически при получении __doc__.</target>
        </trans-unit>
        <trans-unit id="0d7bd4643db21c4724f9db11e4bb21b57a80e3fc" translate="yes" xml:space="preserve">
          <source>Does &lt;em&gt;not&lt;/em&gt; conjugate! For the complex conjugate transpose, use &lt;code&gt;.H&lt;/code&gt;.</source>
          <target state="translated">Разве &lt;em&gt;не&lt;/em&gt; сопряженный! Для транспонирования комплексного конъюгата используйте &lt;code&gt;.H&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="fb0e5a02446a93df5c6a9418c49d06da3e217cfb" translate="yes" xml:space="preserve">
          <source>Does not check that the x-coordinate sequence &lt;code&gt;xp&lt;/code&gt; is increasing. If &lt;code&gt;xp&lt;/code&gt; is not increasing, the results are nonsense. A simple check for increasing is:</source>
          <target state="translated">Не проверяет, что последовательность x-координат &lt;code&gt;xp&lt;/code&gt; увеличивается. Если &lt;code&gt;xp&lt;/code&gt; не увеличивается, результаты - ерунда. Простая проверка на увеличение:</target>
        </trans-unit>
        <trans-unit id="37a9483068c43f31f29b0fa4bbb6e7ded8b89453" translate="yes" xml:space="preserve">
          <source>Does not include memory consumed by non-element attributes of the array object.</source>
          <target state="translated">Не включает память,потребляемую неэлементными атрибутами объекта массива.</target>
        </trans-unit>
        <trans-unit id="82197e5e2b65bee680b92d50de02f93e5275ccd4" translate="yes" xml:space="preserve">
          <source>Does their energy intake deviate systematically from the recommended value of 7725 kJ?</source>
          <target state="translated">Систематически ли отклоняется их потребление энергии от рекомендованного значения 7725 кДж?</target>
        </trans-unit>
        <trans-unit id="fda52ba5b69a393e193dac1fab0651122da1f1df" translate="yes" xml:space="preserve">
          <source>Doing a little timing in IPython shows that the reduced overhead and memory allocation of the Cython inner loop is providing a very nice speedup over both the straightforward Python code and an expression using NumPy&amp;rsquo;s built-in sum function.:</source>
          <target state="translated">Выполнение небольшого времени в IPython показывает, что уменьшенные накладные расходы и выделение памяти внутреннего цикла Cython обеспечивают очень хорошее ускорение как по прямому коду Python, так и по выражению, использующему встроенную функцию суммы NumPy:</target>
        </trans-unit>
        <trans-unit id="5a2e054286be13032ccbf78259a0703d8d83b801" translate="yes" xml:space="preserve">
          <source>Domain for the resulting series. If None the domain is the interval from the smallest root to the largest. If [] the domain is the class domain. The default is [].</source>
          <target state="translated">Домен для результирующей серии.Если Нет,то домен представляет собой интервал от наименьшего корня до наибольшего.Если []домен является доменом класса.По умолчанию [].</target>
        </trans-unit>
        <trans-unit id="4eb122f9bcef4efacc38db644f8b8fbbbd3f1f52" translate="yes" xml:space="preserve">
          <source>Domain over which &lt;code&gt;func&lt;/code&gt; is interpolated. The default is None, in which case the domain is [-1, 1].</source>
          <target state="translated">Домен, по которому выполняется интерполяция &lt;code&gt;func&lt;/code&gt; . По умолчанию - Нет, и в этом случае домен - [-1, 1].</target>
        </trans-unit>
        <trans-unit id="f2d15df66fa784a07d3132cdc84cc4e9d2a43f78" translate="yes" xml:space="preserve">
          <source>Domain to use for the returned series. If &lt;code&gt;None&lt;/code&gt;, then a minimal domain that covers the points &lt;code&gt;x&lt;/code&gt; is chosen. If &lt;code&gt;[]&lt;/code&gt; the class domain is used. The default value was the class domain in NumPy 1.4 and &lt;code&gt;None&lt;/code&gt; in later versions. The &lt;code&gt;[]&lt;/code&gt; option was added in numpy 1.5.0.</source>
          <target state="translated">Домен для возвращенной серии. Если &lt;code&gt;None&lt;/code&gt; , то выбирается минимальная область, покрывающая точки &lt;code&gt;x&lt;/code&gt; . Если &lt;code&gt;[]&lt;/code&gt; используется домен класса. Значением по умолчанию был домен класса в NumPy 1.4 и &lt;code&gt;None&lt;/code&gt; в более поздних версиях. Опция &lt;code&gt;[]&lt;/code&gt; была добавлена ​​в numpy 1.5.0.</target>
        </trans-unit>
        <trans-unit id="82edf41d9d3177c9bd118b575de636ba573d4e3f" translate="yes" xml:space="preserve">
          <source>Domain to use. The interval &lt;code&gt;[domain[0], domain[1]]&lt;/code&gt; is mapped to the interval &lt;code&gt;[window[0], window[1]]&lt;/code&gt; by shifting and scaling. The default value is [-1, 1].</source>
          <target state="translated">Домен для использования. Интервал &lt;code&gt;[domain[0], domain[1]]&lt;/code&gt; отображается в интервал &lt;code&gt;[window[0], window[1]]&lt;/code&gt; путем сдвига и масштабирования. Значение по умолчанию [-1, 1].</target>
        </trans-unit>
        <trans-unit id="07b2e5d2cce01727bf325f6bd8595469a9076b39" translate="yes" xml:space="preserve">
          <source>Domain to use. The interval &lt;code&gt;[domain[0], domain[1]]&lt;/code&gt; is mapped to the interval &lt;code&gt;[window[0], window[1]]&lt;/code&gt; by shifting and scaling. The default value is [0, 1].</source>
          <target state="translated">Домен для использования. Интервал &lt;code&gt;[domain[0], domain[1]]&lt;/code&gt; отображается в интервал &lt;code&gt;[window[0], window[1]]&lt;/code&gt; путем сдвига и масштабирования. Значение по умолчанию - [0, 1].</target>
        </trans-unit>
        <trans-unit id="99ef7d89dc77a04fadda76f62633917fa42d732a" translate="yes" xml:space="preserve">
          <source>Domains. Each domain must (successfully) convert to a 1-d array containing precisely two values.</source>
          <target state="translated">Домены.Каждый домен должен (успешно)преобразовываться в массив 1-d,содержащий ровно два значения.</target>
        </trans-unit>
        <trans-unit id="845a637b103bbcbbace502867de0ec52f11db37e" translate="yes" xml:space="preserve">
          <source>Don&amp;rsquo;t be fooled by this attribute&amp;rsquo;s name: &lt;code&gt;reduceat(a)&lt;/code&gt; is not necessarily smaller than &lt;code&gt;a&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;reduceat(a)&lt;/code&gt; имя этого атрибута: reduceat (a) не обязательно меньше, чем &lt;code&gt;a&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="63f6c0cae180c1519a43cdaf129188e65581d9cb" translate="yes" xml:space="preserve">
          <source>Don&amp;rsquo;t use &lt;a href=&quot;#numpy.amax&quot;&gt;&lt;code&gt;amax&lt;/code&gt;&lt;/a&gt; for element-wise comparison of 2 arrays; when &lt;code&gt;a.shape[0]&lt;/code&gt; is 2, &lt;code&gt;maximum(a[0], a[1])&lt;/code&gt; is faster than &lt;code&gt;amax(a, axis=0)&lt;/code&gt;.</source>
          <target state="translated">Не используйте &lt;a href=&quot;#numpy.amax&quot;&gt; &lt;code&gt;amax&lt;/code&gt; &lt;/a&gt; для поэлементного сравнения двух массивов; когда &lt;code&gt;a.shape[0]&lt;/code&gt; равно 2, &lt;code&gt;maximum(a[0], a[1])&lt;/code&gt; быстрее, чем &lt;code&gt;amax(a, axis=0)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8ee45e18cb25f4ffa299fe638bc542425558ed71" translate="yes" xml:space="preserve">
          <source>Don&amp;rsquo;t use &lt;a href=&quot;#numpy.amin&quot;&gt;&lt;code&gt;amin&lt;/code&gt;&lt;/a&gt; for element-wise comparison of 2 arrays; when &lt;code&gt;a.shape[0]&lt;/code&gt; is 2, &lt;code&gt;minimum(a[0], a[1])&lt;/code&gt; is faster than &lt;code&gt;amin(a, axis=0)&lt;/code&gt;.</source>
          <target state="translated">Не используйте &lt;a href=&quot;#numpy.amin&quot;&gt; &lt;code&gt;amin&lt;/code&gt; &lt;/a&gt; для поэлементного сравнения двух массивов; когда &lt;code&gt;a.shape[0]&lt;/code&gt; равно 2, &lt;code&gt;minimum(a[0], a[1])&lt;/code&gt; быстрее, чем &lt;code&gt;amin(a, axis=0)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e3ed26a26d95479b379119608058dbb2109efb38" translate="yes" xml:space="preserve">
          <source>Dot product of &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt;. Can be an int, float, or complex depending on the types of &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt;.</source>
          <target state="translated">Точечное произведение &lt;code&gt;a&lt;/code&gt; и &lt;code&gt;b&lt;/code&gt; . Может быть int, float или сложным в зависимости от типов &lt;code&gt;a&lt;/code&gt; и &lt;code&gt;b&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b1b5eb09c46c81da930e48b39cbd0988e1d15009" translate="yes" xml:space="preserve">
          <source>Dot product of two arrays.</source>
          <target state="translated">Точечный продукт из двух массивов.</target>
        </trans-unit>
        <trans-unit id="69fc04836f683a90b063205daff794ec842891ec" translate="yes" xml:space="preserve">
          <source>Dot product of two arrays. Specifically,</source>
          <target state="translated">Точечный продукт из двух массивов.А именно,</target>
        </trans-unit>
        <trans-unit id="10eebd1ec669729dbb8a387ff1f1ee83e265b551" translate="yes" xml:space="preserve">
          <source>Draw &lt;code&gt;size&lt;/code&gt; samples of dimension k from a Dirichlet distribution. A Dirichlet-distributed random variable can be seen as a multivariate generalization of a Beta distribution. The Dirichlet distribution is a conjugate prior of a multinomial distribution in Bayesian inference.</source>
          <target state="translated">Нарисуйте образцы &lt;code&gt;size&lt;/code&gt; размерности k из распределения Дирихле. Случайную величину с распределением Дирихле можно рассматривать как многомерное обобщение бета-распределения. Распределение Дирихле является сопряженной априорностью полиномиального распределения в байесовском выводе.</target>
        </trans-unit>
        <trans-unit id="8cef6690ff1fb5f0c2316445230ab79655322c59" translate="yes" xml:space="preserve">
          <source>Draw each 100 values for lambda 100 and 500:</source>
          <target state="translated">Нарисуйте каждые 100 значений для лямбда 100 и 500:</target>
        </trans-unit>
        <trans-unit id="81a1f06763debec752f9772c00b9c8c55a29d67f" translate="yes" xml:space="preserve">
          <source>Draw random samples from a multivariate normal distribution.</source>
          <target state="translated">Нарисуйте случайные образцы из многомерного нормального распределения.</target>
        </trans-unit>
        <trans-unit id="bc8a71087c0197828056ce59780ae3569bbf2e6d" translate="yes" xml:space="preserve">
          <source>Draw random samples from a normal (Gaussian) distribution.</source>
          <target state="translated">Нарисуйте случайные образцы из нормального (гауссовского)распределения.</target>
        </trans-unit>
        <trans-unit id="c671d5af70be0d6ee7f133745fc1b0ba932a0dc3" translate="yes" xml:space="preserve">
          <source>Draw samples and plot the distribution:</source>
          <target state="translated">Нарисуйте образцы и нарисуйте распределение:</target>
        </trans-unit>
        <trans-unit id="d0efc43d29d4ab1659826dde574edba31ec35e3f" translate="yes" xml:space="preserve">
          <source>Draw samples from a 1-parameter Weibull distribution with the given shape parameter &lt;code&gt;a&lt;/code&gt;.</source>
          <target state="translated">Нарисуйте образцы из однопараметрического распределения Вейбулла с заданным параметром формы &lt;code&gt;a&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="fc465d9bb43792a6a4d6d0b79fc58926df796844" translate="yes" xml:space="preserve">
          <source>Draw samples from a Beta distribution.</source>
          <target state="translated">Возьмите образцы из бета-дистрибутива.</target>
        </trans-unit>
        <trans-unit id="db385760aa8dd626fb9adb8853dfd6288a91a9df" translate="yes" xml:space="preserve">
          <source>Draw samples from a Gamma distribution.</source>
          <target state="translated">Нарисуйте образцы из дистрибутива Гамма.</target>
        </trans-unit>
        <trans-unit id="78ab6a861638484d02fed32908592521ecb292b9" translate="yes" xml:space="preserve">
          <source>Draw samples from a Gumbel distribution with specified location and scale. For more information on the Gumbel distribution, see Notes and References below.</source>
          <target state="translated">Отрисуйте образцы из распределения Гамбел с заданным местоположением и масштабом.Для получения дополнительной информации о распределении Гумбеля см.примечания и ссылки ниже.</target>
        </trans-unit>
        <trans-unit id="66a815e387ea9da74fa2238bda4162c421a8c8a9" translate="yes" xml:space="preserve">
          <source>Draw samples from a Gumbel distribution.</source>
          <target state="translated">Нарисуйте образцы из дистрибутива Гамбел.</target>
        </trans-unit>
        <trans-unit id="cb301b24d49678b3e9fff80704432281d0df654a" translate="yes" xml:space="preserve">
          <source>Draw samples from a Hypergeometric distribution.</source>
          <target state="translated">Нарисуйте образцы из гипергеометрического распределения.</target>
        </trans-unit>
        <trans-unit id="836d1593a600cfcfb833fff8c11191d4c4c5d27a" translate="yes" xml:space="preserve">
          <source>Draw samples from a Pareto II or Lomax distribution with specified shape.</source>
          <target state="translated">Нарисуйте образцы из распределения по Парето II или Ломакс с заданной формой.</target>
        </trans-unit>
        <trans-unit id="721b7e6dfb7ad60658e5e614aa751c343f6988fc" translate="yes" xml:space="preserve">
          <source>Draw samples from a Poisson distribution.</source>
          <target state="translated">Нарисуйте образцы из дистрибутива Пуассона.</target>
        </trans-unit>
        <trans-unit id="62a0b4d313dadcf54cda2bc4c9745765dcc56eb6" translate="yes" xml:space="preserve">
          <source>Draw samples from a Rayleigh distribution.</source>
          <target state="translated">Нарисуйте образцы из распределения Рейли.</target>
        </trans-unit>
        <trans-unit id="0cdf4a2aee4c3b56a5568531ce7576534f61561f" translate="yes" xml:space="preserve">
          <source>Draw samples from a Wald, or inverse Gaussian, distribution.</source>
          <target state="translated">Нарисуйте образцы с Вальда или обратного гауссовского распределения.</target>
        </trans-unit>
        <trans-unit id="16cd7ccf53dc2b531e1445308d5381898213743b" translate="yes" xml:space="preserve">
          <source>Draw samples from a Weibull distribution.</source>
          <target state="translated">Нарисуйте образцы с распределения Вейбулла.</target>
        </trans-unit>
        <trans-unit id="0e097ecaf2ff3b51bfb55b676dfdfa6cbd8e50b1" translate="yes" xml:space="preserve">
          <source>Draw samples from a Zipf distribution.</source>
          <target state="translated">Нарисуйте образцы из дистрибутива Zipf.</target>
        </trans-unit>
        <trans-unit id="b159750cd52438190e80fd2b264928bcdbbeffee" translate="yes" xml:space="preserve">
          <source>Draw samples from a binomial distribution.</source>
          <target state="translated">Нарисуйте образцы из биномиального распределения.</target>
        </trans-unit>
        <trans-unit id="3e18e00273a5fae8bbde1791f129e0cbe3bd2452" translate="yes" xml:space="preserve">
          <source>Draw samples from a chi-square distribution.</source>
          <target state="translated">Нарисуйте образцы из распределения хи-квадрат.</target>
        </trans-unit>
        <trans-unit id="7461bda090453d4ff12b83f4027e9d3a1946262b" translate="yes" xml:space="preserve">
          <source>Draw samples from a log-normal distribution with specified mean, standard deviation, and array shape. Note that the mean and standard deviation are not the values for the distribution itself, but of the underlying normal distribution it is derived from.</source>
          <target state="translated">Рисуйте образцы из лог-нормального распределения с заданным средним,стандартным отклонением и формой массива.Обратите внимание,что среднее и среднеквадратическое отклонения-это не значения для самого распределения,а значения для лежащего в его основе нормального распределения,из которого оно выведено.</target>
        </trans-unit>
        <trans-unit id="418d59729801e30d611ad0edbc665078409b6f57" translate="yes" xml:space="preserve">
          <source>Draw samples from a log-normal distribution.</source>
          <target state="translated">Нарисуйте образцы из лог-нормального распределения.</target>
        </trans-unit>
        <trans-unit id="a1bc3727e4de5e7ab2b6eea3e4aaf62bfcf5bf0d" translate="yes" xml:space="preserve">
          <source>Draw samples from a logarithmic series distribution.</source>
          <target state="translated">Нарисуйте образцы из логарифмического распределения рядов.</target>
        </trans-unit>
        <trans-unit id="259f9fd69d995b257a6d58ec3161de00c6ac8e73" translate="yes" xml:space="preserve">
          <source>Draw samples from a logistic distribution.</source>
          <target state="translated">Нарисуйте образцы из логистического распределения.</target>
        </trans-unit>
        <trans-unit id="caeefc0caf49fe896c077769862c6d8f2a2d4d55" translate="yes" xml:space="preserve">
          <source>Draw samples from a multinomial distribution.</source>
          <target state="translated">Нарисуйте образцы из мультиномиального распределения.</target>
        </trans-unit>
        <trans-unit id="3f26805ca2b4fd1c182f06df074a9a855b5c8e20" translate="yes" xml:space="preserve">
          <source>Draw samples from a negative binomial distribution.</source>
          <target state="translated">Нарисуйте образцы с отрицательным биномиальным распределением.</target>
        </trans-unit>
        <trans-unit id="6fad248b8adad205bba771cea1b6af2c597903fb" translate="yes" xml:space="preserve">
          <source>Draw samples from a noncentral chi-square distribution.</source>
          <target state="translated">Возьмите образцы из нецентрального распределения хи-квадрат.</target>
        </trans-unit>
        <trans-unit id="9282b1d217bfacf12c8b8d4a104f2cce46e68b92" translate="yes" xml:space="preserve">
          <source>Draw samples from a standard Cauchy distribution with mode = 0.</source>
          <target state="translated">Нарисуйте образцы из стандартного распределения Коши с режимом=0.</target>
        </trans-unit>
        <trans-unit id="1bf09a114ab7401dced2153d963e20885d1b64c6" translate="yes" xml:space="preserve">
          <source>Draw samples from a standard Gamma distribution.</source>
          <target state="translated">Нарисуйте образцы из стандартного гамма-распределения.</target>
        </trans-unit>
        <trans-unit id="14c3ce03d59dad5f0ba6dbc68a1db4e39a115c97" translate="yes" xml:space="preserve">
          <source>Draw samples from a standard Normal distribution (mean=0, stdev=1).</source>
          <target state="translated">Нарисуйте образцы из стандартного нормального распределения (среднее=0,stdev=1).</target>
        </trans-unit>
        <trans-unit id="0a5ed72650600061c64a7b3836210429f01c8df4" translate="yes" xml:space="preserve">
          <source>Draw samples from a standard Student&amp;rsquo;s t distribution with &lt;code&gt;df&lt;/code&gt; degrees of freedom.</source>
          <target state="translated">Нарисуйте образцы из стандартного распределения Стьюдента со степенями свободы &lt;code&gt;df&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a9791d093a2516b6b22df69cdc89a44c76c8547c" translate="yes" xml:space="preserve">
          <source>Draw samples from a uniform distribution.</source>
          <target state="translated">Нарисуйте образцы из равномерного распределения.</target>
        </trans-unit>
        <trans-unit id="c8dcd074131ab16cf48b101b69dbb09a06467e24" translate="yes" xml:space="preserve">
          <source>Draw samples from a von Mises distribution.</source>
          <target state="translated">Нарисуйте образцы из распределения фон Мизеса.</target>
        </trans-unit>
        <trans-unit id="3f67bb2441c84f4b1162da84f12a83a78820075f" translate="yes" xml:space="preserve">
          <source>Draw samples from an F distribution.</source>
          <target state="translated">Нарисуйте образцы из распределения F.</target>
        </trans-unit>
        <trans-unit id="b4cb12b4006c936a1a5eaa65c28e2a7372035b59" translate="yes" xml:space="preserve">
          <source>Draw samples from an exponential distribution.</source>
          <target state="translated">Нарисуйте образцы из экспоненциального распределения.</target>
        </trans-unit>
        <trans-unit id="9016ff24a09fb989d28a00e24a13cde2696b4777" translate="yes" xml:space="preserve">
          <source>Draw samples from the Dirichlet distribution.</source>
          <target state="translated">Нарисуйте образцы из дирихлетского распределения.</target>
        </trans-unit>
        <trans-unit id="a3fdcad14f303f834dc59b1f3dccb9f86e1705cd" translate="yes" xml:space="preserve">
          <source>Draw samples from the Laplace or double exponential distribution with specified location (or mean) and scale (decay).</source>
          <target state="translated">Отрисуйте образцы из Лапласа или двойного экспоненциального распределения с указанным местоположением (или средним значением)и масштабом (распадом).</target>
        </trans-unit>
        <trans-unit id="308c6270dd43fde905a32469d95cef01a142bca2" translate="yes" xml:space="preserve">
          <source>Draw samples from the distribution</source>
          <target state="translated">Нарисуйте образцы из дистрибуции</target>
        </trans-unit>
        <trans-unit id="5b28ac74b7769bfdc417f7f61e050393575dc125" translate="yes" xml:space="preserve">
          <source>Draw samples from the distribution:</source>
          <target state="translated">Нарисуйте образцы из распределения:</target>
        </trans-unit>
        <trans-unit id="bf043e5601b2f68702eac5005c66d1ebbc6a2030" translate="yes" xml:space="preserve">
          <source>Draw samples from the geometric distribution.</source>
          <target state="translated">Нарисуйте образцы из геометрического распределения.</target>
        </trans-unit>
        <trans-unit id="570de821167a667775bfd8af3be681420e790f2f" translate="yes" xml:space="preserve">
          <source>Draw samples from the noncentral F distribution.</source>
          <target state="translated">Нарисуйте образцы из нецентрального распределения F.</target>
        </trans-unit>
        <trans-unit id="c575768cb70c661f622a7746787703873a7fb9c5" translate="yes" xml:space="preserve">
          <source>Draw samples from the standard exponential distribution.</source>
          <target state="translated">Нарисуйте образцы из стандартного экспоненциального распределения.</target>
        </trans-unit>
        <trans-unit id="dc17866b1f3b7819078bdef07b4d9d1716739b78" translate="yes" xml:space="preserve">
          <source>Draw samples from the triangular distribution over the interval &lt;code&gt;[left, right]&lt;/code&gt;.</source>
          <target state="translated">Нарисуйте образцы из треугольного распределения по интервалу &lt;code&gt;[left, right]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1abf94062d6b0e1580c4eed26b19473395f5dd35" translate="yes" xml:space="preserve">
          <source>Draw ten thousand values from the geometric distribution, with the probability of an individual success equal to 0.35:</source>
          <target state="translated">Нарисуйте десять тысяч значений из геометрического распределения,при этом вероятность индивидуального успеха равна 0,35:</target>
        </trans-unit>
        <trans-unit id="226c6736b8b9dc551d8a75e9fd86f951df1752ee" translate="yes" xml:space="preserve">
          <source>Draw values from a noncentral chisquare with very small noncentrality, and compare to a chisquare.</source>
          <target state="translated">Нарисуйте значения из нецентральной чисквы с очень маленькой нецентральностью,и сравните с чисквой.</target>
        </trans-unit>
        <trans-unit id="3329d33efc5189ab8786b87fd997f1cb2a5fa5e8" translate="yes" xml:space="preserve">
          <source>Draw values from the distribution and plot the histogram</source>
          <target state="translated">Нарисуем значения из распределения и построим гистограмму</target>
        </trans-unit>
        <trans-unit id="2eb6c903d93ed4163d8a9ba3d7777ce26bf70cc2" translate="yes" xml:space="preserve">
          <source>Draw values from the distribution and plot the histogram:</source>
          <target state="translated">Нарисуйте значения из распределения и построите гистограмму:</target>
        </trans-unit>
        <trans-unit id="345d5990ad5e8dc2505201d616bdccd87cd84e5e" translate="yes" xml:space="preserve">
          <source>Drawn samples from the parameterized Fisher distribution.</source>
          <target state="translated">Нарисуйте образцы из параметризованного распределения Фишера.</target>
        </trans-unit>
        <trans-unit id="19d957a8e68c68660a252e592ee001bf286ee4ee" translate="yes" xml:space="preserve">
          <source>Drawn samples from the parameterized Gumbel distribution.</source>
          <target state="translated">Нарисуйте образцы из параметризованного распределения Гамбел.</target>
        </trans-unit>
        <trans-unit id="3874e3e9ab062a1d7bfdc5d30325b887fbc419d7" translate="yes" xml:space="preserve">
          <source>Drawn samples from the parameterized Laplace distribution.</source>
          <target state="translated">Нарисуйте образцы из параметризованного распределения Лапласа.</target>
        </trans-unit>
        <trans-unit id="1cf05e207a79201534bfd254b9ef20861558f17e" translate="yes" xml:space="preserve">
          <source>Drawn samples from the parameterized Pareto distribution.</source>
          <target state="translated">Нарисуйте образцы из параметризованного распределения Pareto.</target>
        </trans-unit>
        <trans-unit id="03c373308c04f8e25032a7f57925fc2cd89f5c43" translate="yes" xml:space="preserve">
          <source>Drawn samples from the parameterized Poisson distribution.</source>
          <target state="translated">Нарисуйте образцы из параметризованного распределения Пуассона.</target>
        </trans-unit>
        <trans-unit id="800df344bc4e042b278de9e7bd37c782c2e5c6c8" translate="yes" xml:space="preserve">
          <source>Drawn samples from the parameterized Rayleigh distribution.</source>
          <target state="translated">Нарисуйте образцы из параметризованного релейного распределения.</target>
        </trans-unit>
        <trans-unit id="96c79cda5fd0d2766220ff50c40f50e59b603b40" translate="yes" xml:space="preserve">
          <source>Drawn samples from the parameterized Wald distribution.</source>
          <target state="translated">Нарисуйте образцы из параметризованного распределения Wald.</target>
        </trans-unit>
        <trans-unit id="881edd9192611978afca45ae863cda6f17a1d7fb" translate="yes" xml:space="preserve">
          <source>Drawn samples from the parameterized Weibull distribution.</source>
          <target state="translated">Нарисуйте образцы из параметризованного распределения Weibull.</target>
        </trans-unit>
        <trans-unit id="cec1a5674838f11821fe1b57bed9970f730915c8" translate="yes" xml:space="preserve">
          <source>Drawn samples from the parameterized Zipf distribution.</source>
          <target state="translated">Нарисуйте образцы из параметризованного Zipf-распределения.</target>
        </trans-unit>
        <trans-unit id="3e3af0fcef04d64e093680f90bd154da4da6f7e6" translate="yes" xml:space="preserve">
          <source>Drawn samples from the parameterized beta distribution.</source>
          <target state="translated">Нарисовали образцы из параметризованного бета-распределения.</target>
        </trans-unit>
        <trans-unit id="66aa1280d92bc58e93f2dd0657680e02202ddedc" translate="yes" xml:space="preserve">
          <source>Drawn samples from the parameterized binomial distribution, where each sample is equal to the number of successes over the n trials.</source>
          <target state="translated">Рисуйте образцы из параметризованного биномиального распределения,где каждый образец равен количеству успешных n испытаний.</target>
        </trans-unit>
        <trans-unit id="803cd0d20a6c49e0eab984068f59353e0ec6f797" translate="yes" xml:space="preserve">
          <source>Drawn samples from the parameterized chi-square distribution.</source>
          <target state="translated">Нарисуйте образцы из параметризованного распределения хи-квадрат.</target>
        </trans-unit>
        <trans-unit id="0a07d0ff0927ba822ed7f54576b179ec4780bfd4" translate="yes" xml:space="preserve">
          <source>Drawn samples from the parameterized exponential distribution.</source>
          <target state="translated">Нарисуйте образцы из параметризованного экспоненциального распределения.</target>
        </trans-unit>
        <trans-unit id="a2f28dab17c9ec69c1e4c0816e2b49d0d97cc8c9" translate="yes" xml:space="preserve">
          <source>Drawn samples from the parameterized gamma distribution.</source>
          <target state="translated">Нарисовали образцы из параметризованного гамма-распределения.</target>
        </trans-unit>
        <trans-unit id="645b194e18330c38a086d019ef409b1ad04a10ac" translate="yes" xml:space="preserve">
          <source>Drawn samples from the parameterized geometric distribution.</source>
          <target state="translated">Нарисуйте образцы из параметризованного геометрического распределения.</target>
        </trans-unit>
        <trans-unit id="675c1d8f69c01109a94a55f050b7feba6cfeb004" translate="yes" xml:space="preserve">
          <source>Drawn samples from the parameterized hypergeometric distribution. Each sample is the number of good items within a randomly selected subset of size &lt;code&gt;nsample&lt;/code&gt; taken from a set of &lt;code&gt;ngood&lt;/code&gt; good items and &lt;code&gt;nbad&lt;/code&gt; bad items.</source>
          <target state="translated">Нарисованы образцы из параметризованного гипергеометрического распределения. Каждый образец является количеством хороших элементов в случайно выбранном подмножестве размера &lt;code&gt;nsample&lt;/code&gt; , взятом из набора &lt;code&gt;ngood&lt;/code&gt; пунктов хороших и &lt;code&gt;nbad&lt;/code&gt; плохих элементов.</target>
        </trans-unit>
        <trans-unit id="0ec5fd25c15e2f401571dd2213b5e63981af1884" translate="yes" xml:space="preserve">
          <source>Drawn samples from the parameterized log-normal distribution.</source>
          <target state="translated">Рисуйте образцы из параметризованного лог-нормального распределения.</target>
        </trans-unit>
        <trans-unit id="92c1e4b50e7e0ed6389caf6bd275c9d96e903819" translate="yes" xml:space="preserve">
          <source>Drawn samples from the parameterized logarithmic series distribution.</source>
          <target state="translated">Рисуем образцы из параметризованного логарифмического распределения рядов.</target>
        </trans-unit>
        <trans-unit id="0418a31cc205f33ce6262d40794bf3e47add1b19" translate="yes" xml:space="preserve">
          <source>Drawn samples from the parameterized logistic distribution.</source>
          <target state="translated">Нарисуйте образцы из параметризованного логистического распределения.</target>
        </trans-unit>
        <trans-unit id="16ad062ab33ce9488dba4d726621ff0742f56c11" translate="yes" xml:space="preserve">
          <source>Drawn samples from the parameterized negative binomial distribution, where each sample is equal to N, the number of failures that occurred before a total of n successes was reached.</source>
          <target state="translated">Отрисовывались выборки из параметризованного отрицательного биномиального распределения,где каждая выборка равна N,количество неудач,которые имели место до достижения суммарного n успешных результатов.</target>
        </trans-unit>
        <trans-unit id="afe023dcddff604c4223693c51bcae1660f6eba8" translate="yes" xml:space="preserve">
          <source>Drawn samples from the parameterized noncentral Fisher distribution.</source>
          <target state="translated">Отрисовывайте образцы из параметризованного нецентрального распределения Фишера.</target>
        </trans-unit>
        <trans-unit id="0dad06577da3cf941b7346f737f68fc3b67c036b" translate="yes" xml:space="preserve">
          <source>Drawn samples from the parameterized noncentral chi-square distribution.</source>
          <target state="translated">Отбираются образцы из параметризованного нецентрального распределения хи-квадрат.</target>
        </trans-unit>
        <trans-unit id="1b7aa6be999ea249ca4e25e9eb3c5a161f178b65" translate="yes" xml:space="preserve">
          <source>Drawn samples from the parameterized normal distribution.</source>
          <target state="translated">Нарисуйте образцы из параметризованного нормального распределения.</target>
        </trans-unit>
        <trans-unit id="75a239b9fd8457ca43a81ea8883cb90f669b784d" translate="yes" xml:space="preserve">
          <source>Drawn samples from the parameterized power distribution.</source>
          <target state="translated">Нарисуйте образцы из параметризованного распределения мощности.</target>
        </trans-unit>
        <trans-unit id="417f5f8f2a7e8f51ee4be6e5ef1c8c34cc318b2f" translate="yes" xml:space="preserve">
          <source>Drawn samples from the parameterized standard Student&amp;rsquo;s t distribution.</source>
          <target state="translated">Нарисованные образцы из параметризованного стандартного t-распределения Стьюдента.</target>
        </trans-unit>
        <trans-unit id="9cfa7b49541ac131db1708e85662c20f82750d1b" translate="yes" xml:space="preserve">
          <source>Drawn samples from the parameterized standard gamma distribution.</source>
          <target state="translated">Отрисовываются образцы из параметризованного стандартного гамма-распределения.</target>
        </trans-unit>
        <trans-unit id="24c6b8b6588f6544b47569ada0a5521ca47031b8" translate="yes" xml:space="preserve">
          <source>Drawn samples from the parameterized triangular distribution.</source>
          <target state="translated">Нарисуйте образцы из параметризованного треугольного распределения.</target>
        </trans-unit>
        <trans-unit id="59ea0a59c91c46f3d89e817e79cad726c3dc2dab" translate="yes" xml:space="preserve">
          <source>Drawn samples from the parameterized uniform distribution.</source>
          <target state="translated">Нарисуйте образцы из параметризованного равномерного распределения.</target>
        </trans-unit>
        <trans-unit id="f20dd8e0ca9375ee4c56dd90351efacbd5b573d8" translate="yes" xml:space="preserve">
          <source>Drawn samples from the parameterized von Mises distribution.</source>
          <target state="translated">Нарисуйте образцы из параметризованного распределения фон Мизеса.</target>
        </trans-unit>
        <trans-unit id="cb8b86177c95587cf24b6f015131fe691b9fc3ba" translate="yes" xml:space="preserve">
          <source>Drawn samples.</source>
          <target state="translated">Нарисованные образцы.</target>
        </trans-unit>
        <trans-unit id="1d18cceebff607d37e9bf2c1387fbd956866a568" translate="yes" xml:space="preserve">
          <source>Draws samples in [0, 1] from a power distribution with positive exponent a - 1.</source>
          <target state="translated">Рисует образцы в [0,1]из распределения мощности с положительным экспонентом a-1.</target>
        </trans-unit>
        <trans-unit id="7d056b5f5f0adde2e16d37463c52db860d944e35" translate="yes" xml:space="preserve">
          <source>Dtype for the structured array.</source>
          <target state="translated">D-тип для структурированного массива.</target>
        </trans-unit>
        <trans-unit id="6c6259462846b5f9baee7053eaac196aa6133053" translate="yes" xml:space="preserve">
          <source>Dtypes for structured arrays can be specified in several forms, but all forms specify at least the data type and field name. For details see &lt;a href=&quot;https://docs.scipy.org/doc/numpy-1.17.0/user/basics.rec.html#module-numpy.doc.structured_arrays&quot;&gt;&lt;code&gt;doc.structured_arrays&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Dtypes для структурированных массивов могут быть указаны в нескольких формах, но все формы определяют по крайней мере тип данных и имя поля. Подробнее см. &lt;a href=&quot;https://docs.scipy.org/doc/numpy-1.17.0/user/basics.rec.html#module-numpy.doc.structured_arrays&quot;&gt; &lt;code&gt;doc.structured_arrays&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="ffaaa2445408170b57b919ca6485e258a7c95d8b" translate="yes" xml:space="preserve">
          <source>Duda, R. O., Hart, P. E., and Stork, D. G., &amp;ldquo;Pattern Classification,&amp;rdquo; 2nd ed., New York: Wiley, 2001.</source>
          <target state="translated">Дуда, Р. О., Харт, П. Е. и Сторк, Д. Г., &amp;laquo;Классификация образцов&amp;raquo;, 2-е изд., Нью-Йорк: Wiley, 2001.</target>
        </trans-unit>
        <trans-unit id="6baaefd65351906a350ba168fbf221f0d184adfa" translate="yes" xml:space="preserve">
          <source>Due to floating point rounding the resulting array may not be Hermitian, the diagonal elements may not be 1, and the elements may not satisfy the inequality abs(a) &amp;lt;= 1. The real and imaginary parts are clipped to the interval [-1, 1] in an attempt to improve on that situation but is not much help in the complex case.</source>
          <target state="translated">Из-за округления с плавающей запятой результирующий массив может не быть эрмитовым, диагональные элементы не могут быть равны 1, а элементы могут не удовлетворять неравенству abs (a) &amp;lt;= 1. Действительная и мнимая части обрезаются до интервала [-1 , 1] в попытке улучшить эту ситуацию, но не очень помогает в сложном случае.</target>
        </trans-unit>
        <trans-unit id="d5668939217d0a50f3a990081bee30e034ec210d" translate="yes" xml:space="preserve">
          <source>Due to limitations in the interpretation of structured dtypes, dtypes with fields with empty names will have the names replaced by &amp;lsquo;f0&amp;rsquo;, &amp;lsquo;f1&amp;rsquo;, etc. Such arrays will not round-trip through the format entirely accurately. The data is intact; only the field names will differ. We are working on a fix for this. This fix will not require a change in the file format. The arrays with such structures can still be saved and restored, and the correct dtype may be restored by using the &lt;code&gt;loadedarray.view(correct_dtype)&lt;/code&gt; method.</source>
          <target state="translated">Из-за ограничений в интерпретации структурированных dtypes, dtypes с полями с пустыми именами будут иметь имена, замененные на 'f0', 'f1' и т. Д. Такие массивы не будут полностью точно проходить через формат. Данные не повреждены; будут отличаться только названия полей. Мы работаем над решением этой проблемы. Это исправление не потребует изменения формата файла. Массивы с такими структурами все еще можно сохранять и восстанавливать, а правильный тип dtype можно восстановить с помощью &lt;code&gt;loadedarray.view(correct_dtype)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="be47cf08679632a886113408bbed677d155a3d74" translate="yes" xml:space="preserve">
          <source>Dump a pickle of the array to the specified file.</source>
          <target state="translated">Выполните дамп маринования массива в указанный файл.</target>
        </trans-unit>
        <trans-unit id="c5317185019827371b1e31a396e0d441834d3252" translate="yes" xml:space="preserve">
          <source>Dump a pickle of the array to the specified file. The array can be read back with pickle.load or numpy.load.</source>
          <target state="translated">Выполните дамп маринования массива в указанный файл.Массив можно считать обратно с помощью pickle.load или numpy.load.</target>
        </trans-unit>
        <trans-unit id="7a2c1b02316fce9ee22b42f7f9087251340c710e" translate="yes" xml:space="preserve">
          <source>During iteration, you may want to use the index of the current element in a computation. For example, you may want to visit the elements of an array in memory order, but use a C-order, Fortran-order, or multidimensional index to look up values in a different array.</source>
          <target state="translated">Во время итерации можно использовать индекс текущего элемента в вычислениях.Например,вы можете захотеть посетить элементы массива в порядке памяти,но использовать C-порядок,Fortran-порядок или многомерный индекс для поиска значений в другом массиве.</target>
        </trans-unit>
        <trans-unit id="3a97e818f2855e4e5e1bc73604c63d51f0dc4bf1" translate="yes" xml:space="preserve">
          <source>Durran D. R. (1999) Numerical Methods for Wave Equations in Geophysical Fluid Dynamics. New York: Springer.</source>
          <target state="translated">Дурран Д.Р.(1999)Численные методы волновых уравнений в геофизической динамике жидкостей.Нью-Йорк:Шпрингер.</target>
        </trans-unit>
        <trans-unit id="26aa5b06114619ee705d4e196e09408f75d82651" translate="yes" xml:space="preserve">
          <source>E.R. Kanasewich, &amp;ldquo;Time Sequence Analysis in Geophysics&amp;rdquo;, The University of Alberta Press, 1975, pp. 106-108.</source>
          <target state="translated">ER Kanasewich, &amp;laquo;Анализ временных последовательностей в геофизике&amp;raquo;, Издательство Университета Альберты, 1975, стр. 106-108.</target>
        </trans-unit>
        <trans-unit id="7020945b62676f3792048d52264e61eaf1f2f06e" translate="yes" xml:space="preserve">
          <source>E.R. Kanasewich, &amp;ldquo;Time Sequence Analysis in Geophysics&amp;rdquo;, The University of Alberta Press, 1975, pp. 109-110.</source>
          <target state="translated">ER Kanasewich, &amp;laquo;Анализ временных последовательностей в геофизике&amp;raquo;, Издательство Университета Альберты, 1975, стр. 109-110.</target>
        </trans-unit>
        <trans-unit id="3bd1ccd7ec68cbb9d222ef47028613ad14f66cf8" translate="yes" xml:space="preserve">
          <source>E.R. Kanasewich, &amp;ldquo;Time Sequence Analysis in Geophysics&amp;rdquo;, The University of Alberta Press, 1975, pp. 177-178.</source>
          <target state="translated">ER Kanasewich, &amp;laquo;Анализ временных последовательностей в геофизике&amp;raquo;, Издательство Университета Альберты, 1975, стр. 177-178.</target>
        </trans-unit>
        <trans-unit id="9282259a9bffd46a322a6acfc9997c91e019e7d4" translate="yes" xml:space="preserve">
          <source>Each &lt;a href=&quot;constants#numpy.newaxis&quot;&gt;&lt;code&gt;newaxis&lt;/code&gt;&lt;/a&gt; object in the selection tuple serves to expand the dimensions of the resulting selection by one unit-length dimension. The added dimension is the position of the &lt;a href=&quot;constants#numpy.newaxis&quot;&gt;&lt;code&gt;newaxis&lt;/code&gt;&lt;/a&gt; object in the selection tuple.</source>
          <target state="translated">Каждый объект &lt;a href=&quot;constants#numpy.newaxis&quot;&gt; &lt;code&gt;newaxis&lt;/code&gt; &lt;/a&gt; в кортеже выбора служит для увеличения размеров результирующего выделения на одно измерение единичной длины. Добавленное измерение - это позиция объекта &lt;a href=&quot;constants#numpy.newaxis&quot;&gt; &lt;code&gt;newaxis&lt;/code&gt; &lt;/a&gt; в выбранном кортеже.</target>
        </trans-unit>
        <trans-unit id="f76bc743577aee15d005972242975d93c3b7f843" translate="yes" xml:space="preserve">
          <source>Each array in the tuple has the same shape as the &lt;code&gt;indices&lt;/code&gt; array.</source>
          <target state="translated">Каждый массив в кортеже имеет ту же форму, что и массив &lt;code&gt;indices&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="386efca9f91ba00773f6c9bc7ed1232d730522e6" translate="yes" xml:space="preserve">
          <source>Each array must have the same shape.</source>
          <target state="translated">Каждый массив должен иметь одинаковую форму.</target>
        </trans-unit>
        <trans-unit id="286a71006dd39afde343b3c45a4fd98ff7cec30e" translate="yes" xml:space="preserve">
          <source>Each boolean array corresponds to a function in &lt;code&gt;funclist&lt;/code&gt;. Wherever &lt;code&gt;condlist[i]&lt;/code&gt; is True, &lt;code&gt;funclist[i](x)&lt;/code&gt; is used as the output value.</source>
          <target state="translated">Каждый логический массив соответствует функции в &lt;code&gt;funclist&lt;/code&gt; . Если &lt;code&gt;condlist[i]&lt;/code&gt; имеет значение True, &lt;code&gt;funclist[i](x)&lt;/code&gt; используется в качестве выходного значения.</target>
        </trans-unit>
        <trans-unit id="eef78733a1d1f7432ec1ab2af99217db7ce78c93" translate="yes" xml:space="preserve">
          <source>Each boolean array in &lt;code&gt;condlist&lt;/code&gt; selects a piece of &lt;code&gt;x&lt;/code&gt;, and should therefore be of the same shape as &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="translated">Каждый логический массив в &lt;code&gt;condlist&lt;/code&gt; выбирает кусок &lt;code&gt;x&lt;/code&gt; и, следовательно, должен иметь ту же форму, что и &lt;code&gt;x&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8fe6ffb6ecffd6c39387e8f0ab0c3a109b7064bf" translate="yes" xml:space="preserve">
          <source>Each built-in data-type has a character code (the updated Numeric typecodes), that uniquely identifies it.</source>
          <target state="translated">Каждый встроенный тип данных имеет символьный код (обновленные Числовые шрифты),который однозначно идентифицирует его.</target>
        </trans-unit>
        <trans-unit id="a69a75e46ca3ac2d199e74b13f3b32f8dd1d6b80" translate="yes" xml:space="preserve">
          <source>Each differentiation is multiplied by &lt;code&gt;scl&lt;/code&gt;. The end result is multiplication by &lt;code&gt;scl**m&lt;/code&gt;. This is for use in a linear change of variable. (Default: 1)</source>
          <target state="translated">Каждая дифференциация умножается на &lt;code&gt;scl&lt;/code&gt; . Конечный результат - умножение на &lt;code&gt;scl**m&lt;/code&gt; . Это для использования при линейном изменении переменной. (По умолчанию: 1)</target>
        </trans-unit>
        <trans-unit id="80d6286823e7a8996b335e27ee039bd71682bf33" translate="yes" xml:space="preserve">
          <source>Each dimension in the signature is matched to a dimension of the corresponding passed-in array, starting from the end of the shape tuple.</source>
          <target state="translated">Каждое измерение в сигнатуре сопоставляется с измерением соответствующего переданного массива,начиная с конца кортежа фигуры.</target>
        </trans-unit>
        <trans-unit id="e3a7c87b9ea1dd98d592dea35e0511973a19c5ea" translate="yes" xml:space="preserve">
          <source>Each dimension in the signature is matched to a dimension of the corresponding passed-in array, starting from the end of the shape tuple. These are the core dimensions, and they must be present in the arrays, or an error will be raised.</source>
          <target state="translated">Каждое измерение в сигнатуре сопоставляется с измерением соответствующего переданного массива,начиная с конца кортежа фигуры.Это размеры ядра,и они должны присутствовать в массивах,иначе возникнет ошибка.</target>
        </trans-unit>
        <trans-unit id="f8fa7f34f98b652b735f9d41844bf81c524a5373" translate="yes" xml:space="preserve">
          <source>Each element of &lt;code&gt;a&lt;/code&gt; represents a bit-field that should be unpacked into a binary-valued output array. The shape of the output array is either 1-D (if &lt;code&gt;axis&lt;/code&gt; is &lt;code&gt;None&lt;/code&gt;) or the same shape as the input array with unpacking done along the axis specified.</source>
          <target state="translated">Каждый элемент &lt;code&gt;a&lt;/code&gt; представляет собой битовое поле, которое следует распаковать в выходной массив с двоичными значениями. Форма выходного массива является либо 1-D (если &lt;code&gt;axis&lt;/code&gt; не &lt;code&gt;None&lt;/code&gt; ) или ту же форму, что и входной массив с распаковкой сделано вдоль оси указанного.</target>
        </trans-unit>
        <trans-unit id="50237f597aa5c58319566769ed4e784a20d0c8c4" translate="yes" xml:space="preserve">
          <source>Each element of the sum of the &amp;lsquo;ipmt&amp;rsquo; and &amp;lsquo;ppmt&amp;rsquo; arrays should equal &amp;lsquo;pmt&amp;rsquo;.</source>
          <target state="translated">Каждый элемент суммы массивов ipmt и ppmt должен равняться pmt.</target>
        </trans-unit>
        <trans-unit id="6596e910451a16280ea499b967185410396fa721" translate="yes" xml:space="preserve">
          <source>Each function is evaluated over &lt;code&gt;x&lt;/code&gt; wherever its corresponding condition is True. It should take a 1d array as input and give an 1d array or a scalar value as output. If, instead of a callable, a scalar is provided then a constant function (&lt;code&gt;lambda x: scalar&lt;/code&gt;) is assumed.</source>
          <target state="translated">Каждая функция оценивается по &lt;code&gt;x&lt;/code&gt; , если соответствующее ей условие истинно. Он должен принимать 1d-массив на входе и выдавать 1d-массив или скалярное значение на выходе. Если вместо вызываемого объекта предоставляется скаляр, то предполагается постоянная функция ( &lt;code&gt;lambda x: scalar&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="8d8deda694e466984ce525e906c00ea4f5dea09d" translate="yes" xml:space="preserve">
          <source>Each generalized ufunc has information associated with it that states what the &amp;ldquo;core&amp;rdquo; dimensionality of the inputs is, as well as the corresponding dimensionality of the outputs (the element-wise ufuncs have zero core dimensions). The list of the core dimensions for all arguments is called the &amp;ldquo;signature&amp;rdquo; of a ufunc. For example, the ufunc numpy.add has signature &lt;code&gt;(),()-&amp;gt;()&lt;/code&gt; defining two scalar inputs and one scalar output.</source>
          <target state="translated">Каждый обобщенный ufunc имеет связанную с ним информацию, которая указывает, какова &amp;laquo;основная&amp;raquo; размерность входов, а также соответствующая размерность выходов (поэлементные ufunc имеют нулевую размерность ядра). Список основных измерений для всех аргументов называется &amp;laquo;сигнатурой&amp;raquo; ufunc. Например, ufunc numpy.add имеет подпись &lt;code&gt;(),()-&amp;gt;()&lt;/code&gt; , определяющую два скалярных входа и один скалярный выход.</target>
        </trans-unit>
        <trans-unit id="93ff2ff5db4665bc2536253e2cbc256cc6ee369b" translate="yes" xml:space="preserve">
          <source>Each item is used as an &amp;ldquo;op_axes&amp;rdquo; argument to an nditer</source>
          <target state="translated">Каждый элемент используется как аргумент &amp;laquo;op_axes&amp;raquo; для nditer.</target>
        </trans-unit>
        <trans-unit id="83888ab60bad511e4b53bdc1db03bb5f1c808f79" translate="yes" xml:space="preserve">
          <source>Each line past the first &lt;code&gt;skip_header&lt;/code&gt; lines is split at the &lt;code&gt;delimiter&lt;/code&gt; character, and characters following the &lt;code&gt;comments&lt;/code&gt; character are discarded.</source>
          <target state="translated">Каждая строка после первых строк &lt;code&gt;skip_header&lt;/code&gt; разделяется символом- &lt;code&gt;delimiter&lt;/code&gt; , а символы, следующие за символом &lt;code&gt;comments&lt;/code&gt; , отбрасываются.</target>
        </trans-unit>
        <trans-unit id="3956c5acda082528edb0dd788f86e08b90ce29c7" translate="yes" xml:space="preserve">
          <source>Each of the arithmetic operations (&lt;code&gt;+&lt;/code&gt;, &lt;code&gt;-&lt;/code&gt;, &lt;code&gt;*&lt;/code&gt;, &lt;code&gt;/&lt;/code&gt;, &lt;code&gt;//&lt;/code&gt;, &lt;code&gt;%&lt;/code&gt;, &lt;code&gt;divmod()&lt;/code&gt;, &lt;code&gt;**&lt;/code&gt; or &lt;code&gt;pow()&lt;/code&gt;, &lt;code&gt;&amp;lt;&amp;lt;&lt;/code&gt;, &lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;amp;&lt;/code&gt;, &lt;code&gt;^&lt;/code&gt;, &lt;code&gt;|&lt;/code&gt;, &lt;code&gt;~&lt;/code&gt;) and the comparisons (&lt;code&gt;==&lt;/code&gt;, &lt;code&gt;&amp;lt;&lt;/code&gt;, &lt;code&gt;&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;=&lt;/code&gt;, &lt;code&gt;&amp;gt;=&lt;/code&gt;, &lt;code&gt;!=&lt;/code&gt;) is equivalent to the corresponding universal function (or &lt;a href=&quot;https://docs.scipy.org/doc/numpy-1.17.0/glossary.html#term-ufunc&quot;&gt;ufunc&lt;/a&gt; for short) in NumPy. For more information, see the section on &lt;a href=&quot;ufuncs#ufuncs&quot;&gt;Universal Functions&lt;/a&gt;.</source>
          <target state="translated">Каждая из арифметических операций ( &lt;code&gt;+&lt;/code&gt; , &lt;code&gt;-&lt;/code&gt; , &lt;code&gt;*&lt;/code&gt; , &lt;code&gt;/&lt;/code&gt; , &lt;code&gt;//&lt;/code&gt; , &lt;code&gt;%&lt;/code&gt; , &lt;code&gt;divmod()&lt;/code&gt; , &lt;code&gt;**&lt;/code&gt; или &lt;code&gt;pow()&lt;/code&gt; , &lt;code&gt;&amp;lt;&amp;lt;&lt;/code&gt; , &lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt; , &lt;code&gt;&amp;amp;&lt;/code&gt; , &lt;code&gt;^&lt;/code&gt; , &lt;code&gt;|&lt;/code&gt; , &lt;code&gt;~&lt;/code&gt; ) и сравнения ( &lt;code&gt;==&lt;/code&gt; , &lt;code&gt;&amp;lt;&lt;/code&gt; , &lt;code&gt;&amp;gt;&lt;/code&gt; , &lt;code&gt;&amp;lt;=&lt;/code&gt; , &lt;code&gt;&amp;gt;=&lt;/code&gt; , &lt;code&gt;!=&lt;/code&gt; ) эквивалентно соответствующему универсальной функции (или &lt;a href=&quot;https://docs.scipy.org/doc/numpy-1.17.0/glossary.html#term-ufunc&quot;&gt;ufunc&lt;/a&gt; для краткости) в NumPy. Для получения дополнительной информации см. Раздел&lt;a href=&quot;ufuncs#ufuncs&quot;&gt;Универсальные функции&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="ce900752c03b63d004b95034fc7fe45e45781bb2" translate="yes" xml:space="preserve">
          <source>Each of these 12 classes is collected into a &lt;code&gt;unittest.TestSuite&lt;/code&gt;, which is then executed. Errors and failures are summed together and returned as the exit argument. Any non-zero result indicates that at least one test did not pass.</source>
          <target state="translated">Каждый из этих 12 классов собирается в &lt;code&gt;unittest.TestSuite&lt;/code&gt; , который затем выполняется. Ошибки и сбои суммируются и возвращаются в качестве аргумента выхода. Любой ненулевой результат означает, что хотя бы один тест не прошел.</target>
        </trans-unit>
        <trans-unit id="f67c4cfb6e2d44f4338462a5c73308f6ff60ab98" translate="yes" xml:space="preserve">
          <source>Each row in the text file must have the same number of values.</source>
          <target state="translated">Каждая строка в текстовом файле должна иметь одинаковое количество значений.</target>
        </trans-unit>
        <trans-unit id="8b09b89b09738ea85b440f6b9b0782f598ebe968" translate="yes" xml:space="preserve">
          <source>Each sequence should be of integer or boolean type. Boolean sequences will be interpreted as boolean masks for the corresponding dimension (equivalent to passing in &lt;code&gt;np.nonzero(boolean_sequence)&lt;/code&gt;).</source>
          <target state="translated">Каждая последовательность должна быть целочисленного или логического типа. Булевы последовательности будут интерпретироваться как логические маски для соответствующего измерения (эквивалентно передаче &lt;code&gt;np.nonzero(boolean_sequence)&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="b117b16ba13396092e447a51f24074ff2e6bd854" translate="yes" xml:space="preserve">
          <source>Each test defined by the &lt;code&gt;VectorTestCase&lt;/code&gt; class extracts the python function it is trying to test by accessing the &lt;code&gt;Vector&lt;/code&gt; module&amp;rsquo;s dictionary:</source>
          <target state="translated">Каждый тест, определенный классом &lt;code&gt;VectorTestCase&lt;/code&gt; , извлекает функцию python, которую он пытается проверить, обращаясь к словарю модуля &lt;code&gt;Vector&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="a7730362892427e71964e48c12006a9cf86055b3" translate="yes" xml:space="preserve">
          <source>Each ufunc consists of an elementary function that performs the most basic operation on the smallest portion of array arguments (e.g. adding two numbers is the most basic operation in adding two arrays). The ufunc applies the elementary function multiple times on different parts of the arrays. The input/output of elementary functions can be vectors; e.g., the elementary function of inner1d takes two vectors as input.</source>
          <target state="translated">Каждая ufunc состоит из элементарной функции,которая выполняет самую базовую операцию над наименьшим количеством аргументов массива (например,сложение двух чисел является самой базовой операцией при сложении двух массивов).ufunc многократно применяет элементарную функцию к различным частям массивов.Вход/выход элементарной функции может быть векторным;например,элементарная функция inner1d принимает на вход два вектора.</target>
        </trans-unit>
        <trans-unit id="cb1cf57d2ff93f75da1bd8ea2b2acd61c3fea8cd" translate="yes" xml:space="preserve">
          <source>Each universal function takes array inputs and produces array outputs by performing the core function element-wise on the inputs (where an element is generally a scalar, but can be a vector or higher-order sub-array for generalized ufuncs). Standard broadcasting rules are applied so that inputs not sharing exactly the same shapes can still be usefully operated on. Broadcasting can be understood by four rules:</source>
          <target state="translated">Каждая универсальная функция берет на себя входы в массив и производит на выходе массивы,выполняя на входах элемент ядра функции по элементам (где элемент,как правило,является скаляром,но может быть векторным или подмассивом более высокого порядка для обобщенных уфунков).Применяются стандартные правила вещания,так что на входах,не имеющих точно такой же формы,можно с пользой работать.Трансляцию можно понять по четырем правилам:</target>
        </trans-unit>
        <trans-unit id="778a8f870adb20070c9bbd4345579e90072a320d" translate="yes" xml:space="preserve">
          <source>Easier setup and teardown functions / methods</source>
          <target state="translated">Более простая настройка и функции/методы</target>
        </trans-unit>
        <trans-unit id="93d5c22f934ab8df1b20f8c3472b63bf839853fa" translate="yes" xml:space="preserve">
          <source>Effect of the &lt;a href=&quot;numpy.ma.copy#numpy.ma.copy&quot;&gt;&lt;code&gt;copy&lt;/code&gt;&lt;/a&gt; argument.</source>
          <target state="translated">Эффект аргумента &lt;a href=&quot;numpy.ma.copy#numpy.ma.copy&quot;&gt; &lt;code&gt;copy&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="b16a3ec6ab9f466c4d89051f80bac7ab3d7a2dde" translate="yes" xml:space="preserve">
          <source>Effect of the &lt;code&gt;shrink&lt;/code&gt; parameter.</source>
          <target state="translated">Влияние параметра &lt;code&gt;shrink&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="15b4ace616414347d2dd3d2801314c174bc7ba08" translate="yes" xml:space="preserve">
          <source>Effectively, this implements:</source>
          <target state="translated">По сути,это орудие:</target>
        </trans-unit>
        <trans-unit id="2b4d17c36c1ff28a27a4b2931f3e20dd1dbef5a2" translate="yes" xml:space="preserve">
          <source>Efficient multi-dimensional iterator object to iterate over arrays.</source>
          <target state="translated">Эффективный многомерный объект итератора для итераций по массивам.</target>
        </trans-unit>
        <trans-unit id="7e03cfade90e6c295c76156a8e2c563a63efa318" translate="yes" xml:space="preserve">
          <source>Efficient multi-dimensional iterator object to iterate over arrays. To get started using this object, see the &lt;a href=&quot;../arrays.nditer#arrays-nditer&quot;&gt;introductory guide to array iteration&lt;/a&gt;.</source>
          <target state="translated">Эффективный многомерный объект-итератор для перебора массивов. Чтобы начать использовать этот объект, см. &lt;a href=&quot;../arrays.nditer#arrays-nditer&quot;&gt;Вводное руководство по итерации массива&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="036e376170c1d3906a5f0a04018619e235105dc6" translate="yes" xml:space="preserve">
          <source>Effort to spend on solving the overlap problem (maximum number of candidate solutions to consider). The following special values are recognized:</source>
          <target state="translated">Усилия по решению проблемы перекрытия (максимальное количество рассматриваемых кандидатур).Признаются следующие специальные значения:</target>
        </trans-unit>
        <trans-unit id="ab3820529f3b083c6a31ff8350ee28b11115b842" translate="yes" xml:space="preserve">
          <source>Effort to spend on solving the overlap problem. See &lt;a href=&quot;numpy.shares_memory#numpy.shares_memory&quot;&gt;&lt;code&gt;shares_memory&lt;/code&gt;&lt;/a&gt; for details. Default for &lt;code&gt;may_share_memory&lt;/code&gt; is to do a bounds check.</source>
          <target state="translated">Усилия потратить на решение проблемы перекрытия. Подробнее см. &lt;a href=&quot;numpy.shares_memory#numpy.shares_memory&quot;&gt; &lt;code&gt;shares_memory&lt;/code&gt; &lt;/a&gt; . По умолчанию для &lt;code&gt;may_share_memory&lt;/code&gt; выполняется проверка границ.</target>
        </trans-unit>
        <trans-unit id="444baf679021343f134e3ab4afdb77852c13f5b7" translate="yes" xml:space="preserve">
          <source>Einstein summation convention.</source>
          <target state="translated">Съезд Эйнштейна по подведению итогов.</target>
        </trans-unit>
        <trans-unit id="5f574da7dabc16cec8dc28f2e16dcdf93d39e214" translate="yes" xml:space="preserve">
          <source>Either &amp;lsquo;inv&amp;rsquo; or &amp;lsquo;zig&amp;rsquo;. &amp;lsquo;inv&amp;rsquo; uses the default inverse CDF method. &amp;lsquo;zig&amp;rsquo; uses the much faster Ziggurat method of Marsaglia and Tsang.</source>
          <target state="translated">Либо inv, либо zig. inv использует обратный метод CDF по умолчанию. 'zig' использует гораздо более быстрый метод зиккурата Марсальи и Цанга.</target>
        </trans-unit>
        <trans-unit id="f248b6168fbf2f57439344bf599f0d52d7a807c7" translate="yes" xml:space="preserve">
          <source>Either &lt;code&gt;NULL&lt;/code&gt; or a dictionary containing low-level casting functions for user- defined data-types. Each function is wrapped in a &lt;code&gt;PyCObject *&lt;/code&gt; and keyed by the data-type number.</source>
          <target state="translated">Либо &lt;code&gt;NULL&lt;/code&gt; , либо словарь, содержащий низкоуровневые функции приведения для пользовательских типов данных. Каждая функция заключена в &lt;code&gt;PyCObject *&lt;/code&gt; и снабжена номером типа данных.</target>
        </trans-unit>
        <trans-unit id="ff36def358c4174701abf75ea4d4e0cdcf5bd477" translate="yes" xml:space="preserve">
          <source>Either &lt;code&gt;NULL&lt;/code&gt; or an array of &lt;a href=&quot;c-api.array#c.NPY_NSCALARKINDS&quot;&gt;&lt;code&gt;NPY_NSCALARKINDS&lt;/code&gt;&lt;/a&gt; pointers. These pointers should each be either &lt;code&gt;NULL&lt;/code&gt; or a pointer to an array of integers (terminated by &lt;a href=&quot;c-api.dtype#c.NPY_NOTYPE&quot;&gt;&lt;code&gt;NPY_NOTYPE&lt;/code&gt;&lt;/a&gt;) indicating data-types that a scalar of this data-type of the specified kind can be cast to safely (this usually means without losing precision).</source>
          <target state="translated">Либо &lt;code&gt;NULL&lt;/code&gt; , либо массив указателей &lt;a href=&quot;c-api.array#c.NPY_NSCALARKINDS&quot;&gt; &lt;code&gt;NPY_NSCALARKINDS&lt;/code&gt; &lt;/a&gt; . Каждый из этих указателей должен быть либо &lt;code&gt;NULL&lt;/code&gt; , либо указателем на массив целых чисел (заканчивающийся &lt;a href=&quot;c-api.dtype#c.NPY_NOTYPE&quot;&gt; &lt;code&gt;NPY_NOTYPE&lt;/code&gt; &lt;/a&gt; ), указывающий типы данных, к которым можно безопасно привести скаляр этого типа данных указанного типа (обычно это означает без потери точности).</target>
        </trans-unit>
        <trans-unit id="9b68604ef80074abda088f5c021808f55b2ed04d" translate="yes" xml:space="preserve">
          <source>Either &lt;code&gt;NULL&lt;/code&gt; or an array of integers (terminated by &lt;a href=&quot;c-api.dtype#c.NPY_NOTYPE&quot;&gt;&lt;code&gt;NPY_NOTYPE&lt;/code&gt;&lt;/a&gt; ) indicated data-types that this data-type can be cast to safely (this usually means without losing precision).</source>
          <target state="translated">Либо &lt;code&gt;NULL&lt;/code&gt; , либо массив целых чисел (заканчивающийся &lt;a href=&quot;c-api.dtype#c.NPY_NOTYPE&quot;&gt; &lt;code&gt;NPY_NOTYPE&lt;/code&gt; &lt;/a&gt; ) указывают типы данных, к которым этот тип данных может быть безопасно приведен (обычно это означает без потери точности).</target>
        </trans-unit>
        <trans-unit id="accffd1618e3de5c69c33d1510a23e42c114bdf3" translate="yes" xml:space="preserve">
          <source>Either &lt;code&gt;None&lt;/code&gt; to indicate a C-style contiguous array or a Tuple of strides which provides the number of bytes needed to jump to the next array element in the corresponding dimension. Each entry must be an integer (a Python &lt;code&gt;int&lt;/code&gt; or &lt;code&gt;long&lt;/code&gt;). As with shape, the values may be larger than can be represented by a C &amp;ldquo;int&amp;rdquo; or &amp;ldquo;long&amp;rdquo;; the calling code should handle this appropriately, either by raising an error, or by using &lt;code&gt;Py_LONG_LONG&lt;/code&gt; in C. The default is &lt;code&gt;None&lt;/code&gt; which implies a C-style contiguous memory buffer. In this model, the last dimension of the array varies the fastest. For example, the default strides tuple for an object whose array entries are 8 bytes long and whose shape is (10,20,30) would be (4800, 240, 8)</source>
          <target state="translated">Либо &lt;code&gt;None&lt;/code&gt; , чтобы указать непрерывный массив в стиле C, либо набор шагов, который обеспечивает количество байтов, необходимое для перехода к следующему элементу массива в соответствующем измерении. Каждая запись должна быть целым числом (Python &lt;code&gt;int&lt;/code&gt; или &lt;code&gt;long&lt;/code&gt; ). Как и в случае с shape, значения могут быть больше, чем могут быть представлены C &amp;laquo;int&amp;raquo; или &amp;laquo;long&amp;raquo;; вызывающий код должен обработать это соответствующим образом, либо путем создания ошибки, либо путем использования &lt;code&gt;Py_LONG_LONG&lt;/code&gt; в C. По умолчанию установлено значение &lt;code&gt;None&lt;/code&gt; , что подразумевает непрерывный буфер памяти в стиле C. В этой модели последнее измерение массива изменяется быстрее всего. Например, кортеж шагов по умолчанию для объекта, элементы массива которого имеют длину 8 байтов и форма (10,20,30), будет иметь вид (4800, 240, 8)</target>
        </trans-unit>
        <trans-unit id="2e35b148ce133a87759db1169ada9bc7afe8b136" translate="yes" xml:space="preserve">
          <source>Either &lt;code&gt;PyUFunc_One&lt;/code&gt;, &lt;code&gt;PyUFunc_Zero&lt;/code&gt;, &lt;code&gt;PyUFunc_None&lt;/code&gt; or &lt;code&gt;PyUFunc_AllOnes&lt;/code&gt; to indicate the identity for this operation. It is only used for a reduce-like call on an empty array.</source>
          <target state="translated">Либо &lt;code&gt;PyUFunc_One&lt;/code&gt; , &lt;code&gt;PyUFunc_Zero&lt;/code&gt; , &lt;code&gt;PyUFunc_None&lt;/code&gt; или &lt;code&gt;PyUFunc_AllOnes&lt;/code&gt; , чтобы указать идентификатор для этой операции. Он используется только для вызова, подобного сокращению, для пустого массива.</target>
        </trans-unit>
        <trans-unit id="987f54d54272ffd5f21f8146bd411a9086f8f96d" translate="yes" xml:space="preserve">
          <source>Either a basic-type description string as in &lt;em&gt;typestr&lt;/em&gt; or another list (for nested structured types)</source>
          <target state="translated">Либо строка описания базового типа, как в &lt;em&gt;typestr,&lt;/em&gt; либо другой список (для вложенных структурированных типов)</target>
        </trans-unit>
        <trans-unit id="e36f94dd4a5bc304e7b8e5a337101261c2694c11" translate="yes" xml:space="preserve">
          <source>Either a data-type, a tuple of data-types, or a special signature string indicating the input and output types of a ufunc. This argument allows you to provide a specific signature for the 1-d loop to use in the underlying calculation. If the loop specified does not exist for the ufunc, then a TypeError is raised. Normally, a suitable loop is found automatically by comparing the input types with what is available and searching for a loop with data-types to which all inputs can be cast safely. This keyword argument lets you bypass that search and choose a particular loop. A list of available signatures is provided by the &lt;strong&gt;types&lt;/strong&gt; attribute of the ufunc object. For backwards compatibility this argument can also be provided as &lt;em&gt;sig&lt;/em&gt;, although the long form is preferred. Note that this should not be confused with the generalized ufunc &lt;a href=&quot;c-api.generalized-ufuncs#details-of-signature&quot;&gt;signature&lt;/a&gt; that is stored in the &lt;strong&gt;signature&lt;/strong&gt; attribute of the of the ufunc object.</source>
          <target state="translated">Либо тип данных, либо кортеж типов данных, либо специальная строка подписи, указывающая типы ввода и вывода ufunc. Этот аргумент позволяет указать конкретную сигнатуру для 1-мерного цикла, которая будет использоваться в базовых вычислениях. Если указанный цикл не существует для ufunc, возникает ошибка TypeError. Обычно подходящий цикл находится автоматически путем сравнения типов ввода с доступными и поиска цикла с типами данных, в которые можно безопасно привести все входные данные. Этот аргумент ключевого слова позволяет обойти этот поиск и выбрать конкретный цикл. Список доступных подписей обеспечиваются &lt;strong&gt;типами&lt;/strong&gt; атрибут ufunc объекта. Для обратной совместимости этот аргумент также может быть &lt;em&gt;указан&lt;/em&gt; как &lt;em&gt;sig&lt;/em&gt;, хотя длинная форма предпочтительнее. Обратите внимание, что это не следует путать с обобщенной &lt;a href=&quot;c-api.generalized-ufuncs#details-of-signature&quot;&gt;подписью&lt;/a&gt; ufunc, которая хранится в атрибуте &lt;strong&gt;подписи&lt;/strong&gt; объекта ufunc.</target>
        </trans-unit>
        <trans-unit id="c7015ddb90f8a42ecbacfed5d690fb153cc71ff7" translate="yes" xml:space="preserve">
          <source>Either the file name (string) or an open file (file-like object) where the data will be saved. If file is a string or a Path, the &lt;code&gt;.npz&lt;/code&gt; extension will be appended to the file name if it is not already there.</source>
          <target state="translated">Либо имя файла (строка), либо открытый файл (файлоподобный объект), в котором будут сохранены данные. Если файл представляет собой строку или путь, к имени &lt;code&gt;.npz&lt;/code&gt; будет добавлено расширение .npz, если его еще нет.</target>
        </trans-unit>
        <trans-unit id="2953df344283c54bedef1d8e252fb3c96e667a80" translate="yes" xml:space="preserve">
          <source>Element index to partition by. The k-th element will be in its final sorted position and all smaller elements will be moved before it and all larger elements behind it. The order all elements in the partitions is undefined. If provided with a sequence of k-th it will partition all of them into their sorted position at once.</source>
          <target state="translated">Индекс элементов для разделения на.k-й элемент будет находиться в окончательном отсортированном положении,а все более мелкие элементы будут перемещены перед ним и все более крупные элементы позади него.Порядок расположения всех элементов в простенках не определен.Если предусмотрена последовательность k-ых,то все они будут разделены в их отсортированном положении сразу.</target>
        </trans-unit>
        <trans-unit id="603f2f92b6e79eef48a044dac1baeab309560ae3" translate="yes" xml:space="preserve">
          <source>Element index to partition by. The k-th value of the element will be in its final sorted position and all smaller elements will be moved before it and all equal or greater elements behind it. The order of all elements in the partitions is undefined. If provided with a sequence of k-th it will partition all elements indexed by k-th of them into their sorted position at once.</source>
          <target state="translated">Индекс элементов для разделения на.Значение k-го элемента будет находиться в конечном отсортированном положении и все меньшие элементы будут перемещены перед ним,а все равные или большие элементы-за ним.Порядок расположения всех элементов в простенках не определен.Если предусмотрена последовательность k-ых,то все элементы,проиндексированные k-ыми из них,будут разделены в их отсортированном положении сразу.</target>
        </trans-unit>
        <trans-unit id="dd1e5c082697760ec705616bbb818b3e3054f2a3" translate="yes" xml:space="preserve">
          <source>Element index to partition by. The kth element value will be in its final sorted position and all smaller elements will be moved before it and all equal or greater elements behind it. The order of all elements in the partitions is undefined. If provided with a sequence of kth it will partition all elements indexed by kth of them into their sorted position at once.</source>
          <target state="translated">Индекс элементов для разделения на.Значение k-го элемента будет находиться в окончательном отсортированном положении и все меньшие элементы будут перемещены перед ним и все равные или большие элементы за ним.Порядок расположения всех элементов в простенках не определен.Если предусмотрена последовательность kth,то он разбивает все элементы,проиндексированные kth из них,на их отсортированное положение сразу.</target>
        </trans-unit>
        <trans-unit id="67afd821e881e618d2d3c592047caa6ab2545d17" translate="yes" xml:space="preserve">
          <source>Element-wise 2 to the power &lt;code&gt;x&lt;/code&gt;. This is a scalar if &lt;code&gt;x&lt;/code&gt; is a scalar.</source>
          <target state="translated">Поэлементно 2 в степени &lt;code&gt;x&lt;/code&gt; . Это скаляр, если &lt;code&gt;x&lt;/code&gt; - скаляр.</target>
        </trans-unit>
        <trans-unit id="adaf9e130e6f948876c40cb7079ab5374d49e139" translate="yes" xml:space="preserve">
          <source>Element-wise &lt;code&gt;x*x&lt;/code&gt;, of the same shape and dtype as &lt;code&gt;x&lt;/code&gt;. This is a scalar if &lt;code&gt;x&lt;/code&gt; is a scalar.</source>
          <target state="translated">Поэлементно &lt;code&gt;x*x&lt;/code&gt; , из одной и той же формы и DTYPE как &lt;code&gt;x&lt;/code&gt; . Это скаляр, если &lt;code&gt;x&lt;/code&gt; - скаляр.</target>
        </trans-unit>
        <trans-unit id="808b6a2cc974757f97aaa854c54baffd849df5f9" translate="yes" xml:space="preserve">
          <source>Element-wise arc tangent of &lt;code&gt;x1/x2&lt;/code&gt; choosing the quadrant correctly.</source>
          <target state="translated">Поэлементный арктангенс &lt;code&gt;x1/x2&lt;/code&gt; с правильным выбором квадранта.</target>
        </trans-unit>
        <trans-unit id="2ac96759d5e7cde7bc053be626eb0c73009447e8" translate="yes" xml:space="preserve">
          <source>Element-wise exponential minus one: &lt;code&gt;out = exp(x) - 1&lt;/code&gt;. This is a scalar if &lt;code&gt;x&lt;/code&gt; is a scalar.</source>
          <target state="translated">Поэлементная экспонента минус один: &lt;code&gt;out = exp(x) - 1&lt;/code&gt; . Это скаляр, если &lt;code&gt;x&lt;/code&gt; - скаляр.</target>
        </trans-unit>
        <trans-unit id="2e24669e28a8f1555e04e187ba59f7b56eef5d74" translate="yes" xml:space="preserve">
          <source>Element-wise maximum of array elements.</source>
          <target state="translated">Элементный максимум элементов массива.</target>
        </trans-unit>
        <trans-unit id="de0f8227b430f00f150f25df31d4c6130cd8dee1" translate="yes" xml:space="preserve">
          <source>Element-wise maximum of two arrays, ignores NaNs.</source>
          <target state="translated">Максимум два массива по Элементу,игнорирует NaNs.</target>
        </trans-unit>
        <trans-unit id="f0000ade51e0b31f8609d90f1fdd9bbd95746777" translate="yes" xml:space="preserve">
          <source>Element-wise maximum of two arrays, ignoring any NaNs.</source>
          <target state="translated">Максимум два массива по Элементу,игнорируя любые NaN.</target>
        </trans-unit>
        <trans-unit id="a0de4ef4fdf4c984be543486b8ef23d43631cea6" translate="yes" xml:space="preserve">
          <source>Element-wise maximum of two arrays, propagates NaNs.</source>
          <target state="translated">Элементный максимум в двух массивах,распространяет NaNs.</target>
        </trans-unit>
        <trans-unit id="bdcc1733a93ea05c9ded4af3bbc823384a01061c" translate="yes" xml:space="preserve">
          <source>Element-wise maximum of two arrays, propagating any NaNs.</source>
          <target state="translated">Максимум два массива по Элементу,распространяющих любые NaNs.</target>
        </trans-unit>
        <trans-unit id="117fbbb294a3d3f4ec6bf9953291f0979ba3eb6d" translate="yes" xml:space="preserve">
          <source>Element-wise minimum of array elements.</source>
          <target state="translated">Элементный минимум элементов массива.</target>
        </trans-unit>
        <trans-unit id="f10c8e11f8111bdb87b272aa363c7d5a87d2958e" translate="yes" xml:space="preserve">
          <source>Element-wise minimum of two arrays, ignores NaNs.</source>
          <target state="translated">Минимум два массива по Элементу,игнорирует NaNs.</target>
        </trans-unit>
        <trans-unit id="0c1d7d39298313f44ede26ddbe99082deaf8d999" translate="yes" xml:space="preserve">
          <source>Element-wise minimum of two arrays, ignoring any NaNs.</source>
          <target state="translated">Минимум два массива по Элементу,игнорируя любые NaNs.</target>
        </trans-unit>
        <trans-unit id="129e7a520fce7febf9e89723a4b3e31c307bd988" translate="yes" xml:space="preserve">
          <source>Element-wise minimum of two arrays, propagates NaNs.</source>
          <target state="translated">Минимум два массива по Элементу,распространяет NaNs.</target>
        </trans-unit>
        <trans-unit id="31ccb3abbc1e393d00365ccd1319992c54e9ed13" translate="yes" xml:space="preserve">
          <source>Element-wise minimum of two arrays, propagating any NaNs.</source>
          <target state="translated">Минимум два массива по Элементу,распространяющих любые NaNs.</target>
        </trans-unit>
        <trans-unit id="a664254a8e3d768c1b8ca8504a3064612680ed55" translate="yes" xml:space="preserve">
          <source>Element-wise quotient resulting from floor division. This is a scalar if both &lt;code&gt;x1&lt;/code&gt; and &lt;code&gt;x2&lt;/code&gt; are scalars.</source>
          <target state="translated">Поэлементное частное в результате разделения этажей. Это скаляр, если и &lt;code&gt;x1&lt;/code&gt; , и &lt;code&gt;x2&lt;/code&gt; являются скалярами.</target>
        </trans-unit>
        <trans-unit id="35a0aab7c92a2f3f84b40cb7246ed8c1bcebd9a8" translate="yes" xml:space="preserve">
          <source>Element-wise remainder from floor division. This is a scalar if both &lt;code&gt;x1&lt;/code&gt; and &lt;code&gt;x2&lt;/code&gt; are scalars.</source>
          <target state="translated">Поэлементный остаток от разделения этажа. Это скаляр, если и &lt;code&gt;x1&lt;/code&gt; , и &lt;code&gt;x2&lt;/code&gt; являются скалярами.</target>
        </trans-unit>
        <trans-unit id="41a18c5c80ce790e4ab72162c437f0a9d09ae712" translate="yes" xml:space="preserve">
          <source>Elementary Function</source>
          <target state="translated">Элементарная функция</target>
        </trans-unit>
        <trans-unit id="04982a80ae05d1b0cdf8cb6f954f5d90370c1f1a" translate="yes" xml:space="preserve">
          <source>Elements shapes must match along the appropriate axes (without broadcasting), but leading 1s will be prepended to the shape as necessary to make the dimensions match.</source>
          <target state="translated">Формы элементов должны совпадать по соответствующим осям (без трансляции),но передние 1 будут дополнены формой по мере необходимости,чтобы размеры совпадали.</target>
        </trans-unit>
        <trans-unit id="ec73af38a64af612d36b6b1e08ea284a14bd8798" translate="yes" xml:space="preserve">
          <source>Elements that roll beyond the last position are re-introduced at the first.</source>
          <target state="translated">Элементы,которые скатываются за пределы последнего положения,вводятся повторно при первом положении.</target>
        </trans-unit>
        <trans-unit id="8ec956445b767a135cb8c6d627b5a2dfeb02537d" translate="yes" xml:space="preserve">
          <source>Elements to compare for the maximum. See &lt;a href=&quot;numpy.ufunc.reduce#numpy.ufunc.reduce&quot;&gt;&lt;code&gt;reduce&lt;/code&gt;&lt;/a&gt; for details.</source>
          <target state="translated">Элементы для сравнения по максимуму. Подробнее см. &lt;a href=&quot;numpy.ufunc.reduce#numpy.ufunc.reduce&quot;&gt; &lt;code&gt;reduce&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="4ba7c2272413ef1378137b3e69e8b4722f8659b1" translate="yes" xml:space="preserve">
          <source>Elements to compare for the minimum. See &lt;a href=&quot;numpy.ufunc.reduce#numpy.ufunc.reduce&quot;&gt;&lt;code&gt;reduce&lt;/code&gt;&lt;/a&gt; for details.</source>
          <target state="translated">Элементы для сравнения по минимуму. Подробнее см. &lt;a href=&quot;numpy.ufunc.reduce#numpy.ufunc.reduce&quot;&gt; &lt;code&gt;reduce&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="9c0973f46abdf4cfdea56a1e0e2597c002a92fb2" translate="yes" xml:space="preserve">
          <source>Elements to include in the product. See &lt;a href=&quot;numpy.ufunc.reduce#numpy.ufunc.reduce&quot;&gt;&lt;code&gt;reduce&lt;/code&gt;&lt;/a&gt; for details.</source>
          <target state="translated">Элементы для включения в продукт. Подробнее см. &lt;a href=&quot;numpy.ufunc.reduce#numpy.ufunc.reduce&quot;&gt; &lt;code&gt;reduce&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="836bba81daa7bbfa24fcec9d876cd0ca01db1438" translate="yes" xml:space="preserve">
          <source>Elements to include in the sum. See &lt;a href=&quot;numpy.ufunc.reduce#numpy.ufunc.reduce&quot;&gt;&lt;code&gt;reduce&lt;/code&gt;&lt;/a&gt; for details.</source>
          <target state="translated">Элементы для включения в сумму. Подробнее см. &lt;a href=&quot;numpy.ufunc.reduce#numpy.ufunc.reduce&quot;&gt; &lt;code&gt;reduce&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="a68b36609400536b206e5ed8f4915662a0a2020b" translate="yes" xml:space="preserve">
          <source>Elements to sum.</source>
          <target state="translated">Элементы в сумме.</target>
        </trans-unit>
        <trans-unit id="680319fcdd621a03121d173370e025227fa7d8d6" translate="yes" xml:space="preserve">
          <source>Elementwise bit operations</source>
          <target state="translated">элементообразующие битовые операции</target>
        </trans-unit>
        <trans-unit id="777a53a52816c5597e4f366c2ef31bc0f2a213da" translate="yes" xml:space="preserve">
          <source>Empty array of the given shape and type.</source>
          <target state="translated">Пустой массив заданной формы и типа.</target>
        </trans-unit>
        <trans-unit id="30b8b3469c24b495eeedeb9693c9bf36670e4dcd" translate="yes" xml:space="preserve">
          <source>Empty masked array modelled on an existing array.</source>
          <target state="translated">Пустой массив,смоделированный на существующем массиве.</target>
        </trans-unit>
        <trans-unit id="6985c4b0d668125594b4f0ca6436e1c86a0154e8" translate="yes" xml:space="preserve">
          <source>Empty masked array with all elements masked.</source>
          <target state="translated">Пустой массив с маскировкой всех элементов.</target>
        </trans-unit>
        <trans-unit id="680b8e573f5c82aced131f36a223b41bb3352d25" translate="yes" xml:space="preserve">
          <source>Empty masked array with the properties of an existing array.</source>
          <target state="translated">Пустой массив со свойствами существующего массива.</target>
        </trans-unit>
        <trans-unit id="a122b7a065f1b0b6e65770d5576676e667e835a7" translate="yes" xml:space="preserve">
          <source>Enables support for iteration of sub-ranges of the full &lt;code&gt;iterindex&lt;/code&gt; range &lt;code&gt;[0, NpyIter_IterSize(iter))&lt;/code&gt;. Use the function &lt;a href=&quot;#c.NpyIter_ResetToIterIndexRange&quot;&gt;&lt;code&gt;NpyIter_ResetToIterIndexRange&lt;/code&gt;&lt;/a&gt; to specify a range for iteration.</source>
          <target state="translated">Включает поддержку итерации поддиапазонов полного диапазона &lt;code&gt;iterindex&lt;/code&gt; &lt;code&gt;[0, NpyIter_IterSize(iter))&lt;/code&gt; . Используйте функцию &lt;a href=&quot;#c.NpyIter_ResetToIterIndexRange&quot;&gt; &lt;code&gt;NpyIter_ResetToIterIndexRange&lt;/code&gt; ,&lt;/a&gt; чтобы указать диапазон для итерации.</target>
        </trans-unit>
        <trans-unit id="0bc79001ca7d4881c81aec2ea04317198e31e1bd" translate="yes" xml:space="preserve">
          <source>Enables the specified array flags. This function does no validation, and assumes that you know what you&amp;rsquo;re doing.</source>
          <target state="translated">Включает указанные флаги массива. Эта функция не выполняет проверки и предполагает, что вы знаете, что делаете.</target>
        </trans-unit>
        <trans-unit id="2919970bd082897345d32d119a4800b54dae0c81" translate="yes" xml:space="preserve">
          <source>Encapsulate the functionality of functions and methods that take the axis= keyword and work properly with None as the axis argument. The input array is &lt;code&gt;obj&lt;/code&gt;, while &lt;code&gt;*axis&lt;/code&gt; is a converted integer (so that &amp;gt;=MAXDIMS is the None value), and &lt;code&gt;requirements&lt;/code&gt; gives the needed properties of &lt;code&gt;obj&lt;/code&gt;. The output is a converted version of the input so that requirements are met and if needed a flattening has occurred. On output negative values of &lt;code&gt;*axis&lt;/code&gt; are converted and the new value is checked to ensure consistency with the shape of &lt;code&gt;obj&lt;/code&gt;.</source>
          <target state="translated">Инкапсулируйте функциональность функций и методов, которые принимают ключевое слово axis = и правильно работают с None в качестве аргумента оси. Входной массив - это &lt;code&gt;obj&lt;/code&gt; , а &lt;code&gt;*axis&lt;/code&gt; - это преобразованное целое число (так что&amp;gt; = MAXDIMS является значением None), а &lt;code&gt;requirements&lt;/code&gt; задают необходимые свойства &lt;code&gt;obj&lt;/code&gt; . Выходные данные представляют собой преобразованную версию входных данных, поэтому требования выполняются и, если необходимо, произошло выравнивание. На выходе отрицательные значения &lt;code&gt;*axis&lt;/code&gt; преобразуются, и новое значение проверяется, чтобы гарантировать согласованность с формой &lt;code&gt;obj&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3fcbf1219e531263b67edb6bcb90e0e603ad6031" translate="yes" xml:space="preserve">
          <source>Encoding used to decode the inputfile. Does not apply to input streams.</source>
          <target state="translated">Кодирование,используемое для декодирования входного файла.Не применяется к входным потокам.</target>
        </trans-unit>
        <trans-unit id="b27e46c5a085977e5cb88681f8a881b52c0fec71" translate="yes" xml:space="preserve">
          <source>Encoding used to decode the inputfile. Does not apply to input streams. The special value &amp;lsquo;bytes&amp;rsquo; enables backward compatibility workarounds that ensures you receive byte arrays as results if possible and passes &amp;lsquo;latin1&amp;rsquo; encoded strings to converters. Override this value to receive unicode arrays and pass strings as input to converters. If set to None the system default is used. The default value is &amp;lsquo;bytes&amp;rsquo;.</source>
          <target state="translated">Кодировка, используемая для декодирования входного файла. Не применяется к входным потокам. Специальное значение &amp;laquo;bytes&amp;raquo; включает обходные пути обратной совместимости, которые гарантируют получение массивов байтов в качестве результатов, если это возможно, и передачу строк в кодировке &amp;laquo;latin1&amp;raquo; конвертерам. Переопределите это значение, чтобы получать массивы Unicode и передавать строки в качестве входных данных для преобразователей. Если установлено значение &amp;laquo;Нет&amp;raquo;, используется система по умолчанию. Значение по умолчанию - &amp;laquo;байты&amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="6776a87f17cb7165db7de968828852a089f8cd2b" translate="yes" xml:space="preserve">
          <source>Encoding used to decode the inputfile. Does not apply when &lt;code&gt;fname&lt;/code&gt; is a file object. The special value &amp;lsquo;bytes&amp;rsquo; enables backward compatibility workarounds that ensure that you receive byte arrays when possible and passes latin1 encoded strings to converters. Override this value to receive unicode arrays and pass strings as input to converters. If set to None the system default is used. The default value is &amp;lsquo;bytes&amp;rsquo;.</source>
          <target state="translated">Кодировка, используемая для декодирования входного файла. Не применяется, если &lt;code&gt;fname&lt;/code&gt; является файловым объектом. Специальное значение &amp;laquo;bytes&amp;raquo; включает обходные пути обратной совместимости, которые гарантируют получение байтовых массивов, когда это возможно, и передачу строк в кодировке latin1 конвертерам. Переопределите это значение, чтобы получать массивы Unicode и передавать строки в качестве входных данных для преобразователей. Если установлено значение Нет, используется система по умолчанию. Значение по умолчанию - &amp;laquo;байты&amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="8e2939a9752e2c7114a267e7bcdaebdf8d9a69e0" translate="yes" xml:space="preserve">
          <source>Encoding used to encode the outputfile. Does not apply to output streams. If the encoding is something other than &amp;lsquo;bytes&amp;rsquo; or &amp;lsquo;latin1&amp;rsquo; you will not be able to load the file in NumPy versions &amp;lt; 1.14. Default is &amp;lsquo;latin1&amp;rsquo;.</source>
          <target state="translated">Кодировка, используемая для кодирования выходного файла. Не применяется к выходным потокам. Если кодировка отличается от &amp;laquo;байтов&amp;raquo; или &amp;laquo;latin1&amp;raquo;, вы не сможете загрузить файл в версиях NumPy &amp;lt;1.14. По умолчанию - latin1.</target>
        </trans-unit>
        <trans-unit id="672959489089d143587fef9e4d4ad09fb66e2197" translate="yes" xml:space="preserve">
          <source>End of interval. The interval does not include this value, except in some cases where &lt;code&gt;step&lt;/code&gt; is not an integer and floating point round-off affects the length of &lt;code&gt;out&lt;/code&gt;.</source>
          <target state="translated">Конец интервала. Интервал не включает это значение, за исключением некоторых случаев, когда &lt;code&gt;step&lt;/code&gt; не является целым числом, а округление с плавающей запятой влияет на длину &lt;code&gt;out&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d9b220f5e9cefe4e27d14fddf001bfa3a63353e7" translate="yes" xml:space="preserve">
          <source>Endianness of this data:</source>
          <target state="translated">Эндианность этих данных:</target>
        </trans-unit>
        <trans-unit id="83a41a009718ba8b1b08f10745bce80452ba74f4" translate="yes" xml:space="preserve">
          <source>Enlarging an array: as above, but missing entries are filled with zeros:</source>
          <target state="translated">Расширение массива:как указано выше,но отсутствующие записи заполняются нулями:</target>
        </trans-unit>
        <trans-unit id="31a314f110f22f052f3fa828713d2b2afb82f2d3" translate="yes" xml:space="preserve">
          <source>Ensures that the input or output matches the iteration dimensions exactly.</source>
          <target state="translated">Обеспечивает точное совпадение размеров входа или выхода с размерами итераций.</target>
        </trans-unit>
        <trans-unit id="b3a6fa7af7b1354d47707152a8ad806c277ca980" translate="yes" xml:space="preserve">
          <source>Entropy bits in 32-bit unsigned integers. A scalar is returned if size is &lt;code&gt;None&lt;/code&gt;.</source>
          <target state="translated">Биты энтропии в 32-битных целых числах без знака. Скаляр возвращается, если размер равен &lt;code&gt;None&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b0366a10ef9d6d3ef8c64dd51eeccb78bad1656a" translate="yes" xml:space="preserve">
          <source>Enumerated Types</source>
          <target state="translated">Перечисленные типы</target>
        </trans-unit>
        <trans-unit id="e4ac742e5d17c07aad844f80aaa89a24ed90f881" translate="yes" xml:space="preserve">
          <source>Equal to &lt;code&gt;np.prod(a.shape)&lt;/code&gt;, i.e., the product of the array&amp;rsquo;s dimensions.</source>
          <target state="translated">Равно &lt;code&gt;np.prod(a.shape)&lt;/code&gt; , то есть произведению размеров массива.</target>
        </trans-unit>
        <trans-unit id="b75f0322b44b0e91520f5021f79c37a01c9e121d" translate="yes" xml:space="preserve">
          <source>Equivalent array function.</source>
          <target state="translated">Функция эквивалентного массива.</target>
        </trans-unit>
        <trans-unit id="a87b0e23e278c7d5e4e266e84f6badc171df142a" translate="yes" xml:space="preserve">
          <source>Equivalent array method.</source>
          <target state="translated">Метод эквивалентных массивов.</target>
        </trans-unit>
        <trans-unit id="1f85d863747d1d952d2380d6f9b0e6bc4a93c6e6" translate="yes" xml:space="preserve">
          <source>Equivalent function</source>
          <target state="translated">Эквивалентная функция</target>
        </trans-unit>
        <trans-unit id="ec48c460ff53cdf24f427482ba077c38b868cbe6" translate="yes" xml:space="preserve">
          <source>Equivalent function for ndarrays.</source>
          <target state="translated">Эквивалентная функция для ndarrays.</target>
        </trans-unit>
        <trans-unit id="47b16a4308d5d95c02caa6becddf32961f2329b1" translate="yes" xml:space="preserve">
          <source>Equivalent function in the NumPy module.</source>
          <target state="translated">Эквивалентная функция в модуле NumPy.</target>
        </trans-unit>
        <trans-unit id="3fda7b941f8c3619f7cfea52fae50b8fafb8283f" translate="yes" xml:space="preserve">
          <source>Equivalent function in the masked array module.</source>
          <target state="translated">Эквивалентная функция в массивном модуле.</target>
        </trans-unit>
        <trans-unit id="f3946f30225c2c4e0913895a299311328885ca06" translate="yes" xml:space="preserve">
          <source>Equivalent function in the top level NumPy module.</source>
          <target state="translated">Эквивалентная функция на верхнем уровне модуля NumPy.</target>
        </trans-unit>
        <trans-unit id="e79348928e8ad109f51e4deea501091d1124a6a4" translate="yes" xml:space="preserve">
          <source>Equivalent function in the top-level NumPy module.</source>
          <target state="translated">Эквивалентная функция в модуле NumPy верхнего уровня.</target>
        </trans-unit>
        <trans-unit id="f012d5b24482ab2f7fe8b36bc8562d2e06cf863d" translate="yes" xml:space="preserve">
          <source>Equivalent function in top-level NumPy module.</source>
          <target state="translated">Эквивалентная функция в модуле NumPy верхнего уровня.</target>
        </trans-unit>
        <trans-unit id="bb89f40e9f2471ebbc500654e8790a75f09e8680" translate="yes" xml:space="preserve">
          <source>Equivalent function with additional &lt;code&gt;loc&lt;/code&gt; and &lt;code&gt;scale&lt;/code&gt; arguments for setting the mean and standard deviation.</source>
          <target state="translated">Эквивалентная функция с дополнительными аргументами &lt;code&gt;loc&lt;/code&gt; и &lt;code&gt;scale&lt;/code&gt; для установки среднего и стандартного отклонения.</target>
        </trans-unit>
        <trans-unit id="3fec03561045f830610698c03c4e7cda301e9182" translate="yes" xml:space="preserve">
          <source>Equivalent functionality of &lt;a href=&quot;numpy.add#numpy.add&quot;&gt;&lt;code&gt;add&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Эквивалентная функциональность &lt;a href=&quot;numpy.add#numpy.add&quot;&gt; &lt;code&gt;add&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="73110076e1002b6b052fe8f385604bf0bd306ff9" translate="yes" xml:space="preserve">
          <source>Equivalent method in ndarray</source>
          <target state="translated">Эквивалентный метод in ndarray</target>
        </trans-unit>
        <trans-unit id="8b818de9537a41af44762a6ff8c93846b78172ce" translate="yes" xml:space="preserve">
          <source>Equivalent method on ndarray object.</source>
          <target state="translated">Эквивалентный метод на объекте ndarray.</target>
        </trans-unit>
        <trans-unit id="323a53e2d1eaaaf783c2a6e70d300696fee31861" translate="yes" xml:space="preserve">
          <source>Equivalent method when working on 1-D arrays</source>
          <target state="translated">Эквивалентный метод при работе с 1-D массивами</target>
        </trans-unit>
        <trans-unit id="198298ece560304dd9cecebb0a6c0ea2bb7a8bae" translate="yes" xml:space="preserve">
          <source>Equivalent method.</source>
          <target state="translated">Эквивалентный метод.</target>
        </trans-unit>
        <trans-unit id="46b37d7b2f299efd2d123535be0f6369732ae724" translate="yes" xml:space="preserve">
          <source>Equivalent ndarray method.</source>
          <target state="translated">Метод эквивалентной ндарреи.</target>
        </trans-unit>
        <trans-unit id="c920736bc05ff403de2ed423ca7f0b9c0f3adffb" translate="yes" xml:space="preserve">
          <source>Equivalent of Python &lt;code&gt;//&lt;/code&gt; operator.</source>
          <target state="translated">Эквивалент оператора Python &lt;code&gt;//&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="505d790701850092dede13a1225a7d0508099ca4" translate="yes" xml:space="preserve">
          <source>Equivalent of the MATLAB &lt;code&gt;rem&lt;/code&gt; function.</source>
          <target state="translated">Эквивалент функции MATLAB &lt;code&gt;rem&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4cdc670d68d8d05adfb0ac70f3d0ea4670424187" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;a href=&quot;#c.PyDataType_FLAGCHK&quot;&gt;&lt;code&gt;PyDataType_FLAGCHK&lt;/code&gt;&lt;/a&gt; (&lt;em&gt;dtype&lt;/em&gt;, &lt;a href=&quot;#c.NPY_ITEM_REFCOUNT&quot;&gt;&lt;code&gt;NPY_ITEM_REFCOUNT&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">Эквивалентен &lt;a href=&quot;#c.PyDataType_FLAGCHK&quot;&gt; &lt;code&gt;PyDataType_FLAGCHK&lt;/code&gt; &lt;/a&gt; ( &lt;em&gt;dtype&lt;/em&gt; , &lt;a href=&quot;#c.NPY_ITEM_REFCOUNT&quot;&gt; &lt;code&gt;NPY_ITEM_REFCOUNT&lt;/code&gt; &lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="e3ecf3d3dd70eafb08906a1ad49ac399520f10f8" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;a href=&quot;generated/numpy.ndarray.all#numpy.ndarray.all&quot;&gt;&lt;code&gt;ndarray.all&lt;/code&gt;&lt;/a&gt; (&lt;em&gt;self&lt;/em&gt;, &lt;em&gt;axis&lt;/em&gt;). Return an array with True elements for every 1-d sub-array of &lt;code&gt;self&lt;/code&gt; defined by &lt;code&gt;axis&lt;/code&gt; in which all the elements are True.</source>
          <target state="translated">Эквивалентен &lt;a href=&quot;generated/numpy.ndarray.all#numpy.ndarray.all&quot;&gt; &lt;code&gt;ndarray.all&lt;/code&gt; &lt;/a&gt; ( &lt;em&gt;self&lt;/em&gt; , &lt;em&gt;axis&lt;/em&gt; ). Возвращает массив с элементами True для каждого 1-мерного подмассива &lt;code&gt;self&lt;/code&gt; , определенного &lt;code&gt;axis&lt;/code&gt; в которой все элементы имеют значение True.</target>
        </trans-unit>
        <trans-unit id="efd8289812e23cf1b7df07369198edcd67ccd665" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;a href=&quot;generated/numpy.ndarray.any#numpy.ndarray.any&quot;&gt;&lt;code&gt;ndarray.any&lt;/code&gt;&lt;/a&gt; (&lt;em&gt;self&lt;/em&gt;, &lt;em&gt;axis&lt;/em&gt;). Return an array with True elements for every 1-d sub-array of &lt;em&gt;self&lt;/em&gt; defined by &lt;em&gt;axis&lt;/em&gt; in which any of the elements are True.</source>
          <target state="translated">Эквивалентен &lt;a href=&quot;generated/numpy.ndarray.any#numpy.ndarray.any&quot;&gt; &lt;code&gt;ndarray.any&lt;/code&gt; &lt;/a&gt; ( &lt;em&gt;self&lt;/em&gt; , &lt;em&gt;axis&lt;/em&gt; ). Возвращает массив с элементами True для каждого 1-мерного подмассива &lt;em&gt;self,&lt;/em&gt; определенного &lt;em&gt;осью,&lt;/em&gt; в которой любой из элементов имеет значение True.</target>
        </trans-unit>
        <trans-unit id="ea109271e7fe639649aeaaf2a0b5dd56ecc23fcf" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;a href=&quot;generated/numpy.ndarray.argmax#numpy.ndarray.argmax&quot;&gt;&lt;code&gt;ndarray.argmax&lt;/code&gt;&lt;/a&gt; (&lt;em&gt;self&lt;/em&gt;, &lt;em&gt;axis&lt;/em&gt;). Return the index of the largest element of &lt;em&gt;self&lt;/em&gt; along &lt;em&gt;axis&lt;/em&gt;.</source>
          <target state="translated">Эквивалентен &lt;a href=&quot;generated/numpy.ndarray.argmax#numpy.ndarray.argmax&quot;&gt; &lt;code&gt;ndarray.argmax&lt;/code&gt; &lt;/a&gt; ( &lt;em&gt;self&lt;/em&gt; , &lt;em&gt;axis&lt;/em&gt; ). Вернуть индекс самого большого элемента &lt;em&gt;self&lt;/em&gt; вдоль &lt;em&gt;оси&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="9e5a451b453bc4aefcc71e37cd8b0e84168886e8" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;a href=&quot;generated/numpy.ndarray.argmin#numpy.ndarray.argmin&quot;&gt;&lt;code&gt;ndarray.argmin&lt;/code&gt;&lt;/a&gt; (&lt;em&gt;self&lt;/em&gt;, &lt;em&gt;axis&lt;/em&gt;). Return the index of the smallest element of &lt;em&gt;self&lt;/em&gt; along &lt;em&gt;axis&lt;/em&gt;.</source>
          <target state="translated">Эквивалентен &lt;a href=&quot;generated/numpy.ndarray.argmin#numpy.ndarray.argmin&quot;&gt; &lt;code&gt;ndarray.argmin&lt;/code&gt; &lt;/a&gt; ( &lt;em&gt;self&lt;/em&gt; , &lt;em&gt;axis&lt;/em&gt; ). Вернуть индекс самого маленького элемента &lt;em&gt;self&lt;/em&gt; вдоль &lt;em&gt;оси&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="cf7a1a44ff60373e9f731b7ce7e339177577c561" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;a href=&quot;generated/numpy.ndarray.argpartition#numpy.ndarray.argpartition&quot;&gt;&lt;code&gt;ndarray.argpartition&lt;/code&gt;&lt;/a&gt; (&lt;em&gt;self&lt;/em&gt;, &lt;em&gt;ktharray&lt;/em&gt;, &lt;em&gt;axis&lt;/em&gt;, &lt;em&gt;kind&lt;/em&gt;). Return an array of indices such that selection of these indices along the given &lt;code&gt;axis&lt;/code&gt; would return a partitioned version of &lt;em&gt;self&lt;/em&gt;.</source>
          <target state="translated">Эквивалентен &lt;a href=&quot;generated/numpy.ndarray.argpartition#numpy.ndarray.argpartition&quot;&gt; &lt;code&gt;ndarray.argpartition&lt;/code&gt; &lt;/a&gt; ( &lt;em&gt;self&lt;/em&gt; , &lt;em&gt;ktharray&lt;/em&gt; , &lt;em&gt;axis&lt;/em&gt; , &lt;em&gt;kind&lt;/em&gt; ). Возвратите массив индексов таким образом, чтобы выбор этих индексов по заданной &lt;code&gt;axis&lt;/code&gt; возвращал секционированную версию &lt;em&gt;self&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="d75ff39235401fe4390dbb04fd226bfccafd46e5" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;a href=&quot;generated/numpy.ndarray.argsort#numpy.ndarray.argsort&quot;&gt;&lt;code&gt;ndarray.argsort&lt;/code&gt;&lt;/a&gt; (&lt;em&gt;self&lt;/em&gt;, &lt;em&gt;axis&lt;/em&gt;). Return an array of indices such that selection of these indices along the given &lt;code&gt;axis&lt;/code&gt; would return a sorted version of &lt;em&gt;self&lt;/em&gt;. If &lt;em&gt;self&lt;/em&gt; -&amp;gt;descr is a data-type with fields defined, then self-&amp;gt;descr-&amp;gt;names is used to determine the sort order. A comparison where the first field is equal will use the second field and so on. To alter the sort order of a structured array, create a new data-type with a different order of names and construct a view of the array with that new data-type.</source>
          <target state="translated">Эквивалентен &lt;a href=&quot;generated/numpy.ndarray.argsort#numpy.ndarray.argsort&quot;&gt; &lt;code&gt;ndarray.argsort&lt;/code&gt; &lt;/a&gt; ( &lt;em&gt;self&lt;/em&gt; , &lt;em&gt;axis&lt;/em&gt; ). Вернуть массив индексов, чтобы выбор этих индексов по заданной &lt;code&gt;axis&lt;/code&gt; возвращал отсортированную версию &lt;em&gt;self&lt;/em&gt; . Если &lt;em&gt;self&lt;/em&gt; -&amp;gt; descr является типом данных с определенными полями, то self-&amp;gt; descr-&amp;gt; names используется для определения порядка сортировки. При сравнении, в котором первое поле равно, будет использоваться второе поле и так далее. Чтобы изменить порядок сортировки структурированного массива, создайте новый тип данных с другим порядком имен и создайте представление массива с этим новым типом данных.</target>
        </trans-unit>
        <trans-unit id="6daadea926a9bfb0a800c60a35b85b50c40374a1" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;a href=&quot;generated/numpy.ndarray.byteswap#numpy.ndarray.byteswap&quot;&gt;&lt;code&gt;ndarray.byteswap&lt;/code&gt;&lt;/a&gt; (&lt;em&gt;self&lt;/em&gt;, &lt;em&gt;inplace&lt;/em&gt;). Return an array whose data area is byteswapped. If &lt;em&gt;inplace&lt;/em&gt; is non-zero, then do the byteswap inplace and return a reference to self. Otherwise, create a byteswapped copy and leave self unchanged.</source>
          <target state="translated">Эквивалентен &lt;a href=&quot;generated/numpy.ndarray.byteswap#numpy.ndarray.byteswap&quot;&gt; &lt;code&gt;ndarray.byteswap&lt;/code&gt; &lt;/a&gt; ( &lt;em&gt;self&lt;/em&gt; , &lt;em&gt;inplace&lt;/em&gt; ). Вернуть массив, область данных которого поменяна байтами. Если &lt;em&gt;inplace&lt;/em&gt; не равно нулю, тогда выполните замену байтов на месте и верните ссылку на self. В противном случае создайте копию с заменой байта и оставьте self без изменений.</target>
        </trans-unit>
        <trans-unit id="2ab0b0009765a5d262f32c0eec580607299fc96a" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;a href=&quot;generated/numpy.ndarray.choose#numpy.ndarray.choose&quot;&gt;&lt;code&gt;ndarray.choose&lt;/code&gt;&lt;/a&gt; (&lt;em&gt;self&lt;/em&gt;, &lt;em&gt;op&lt;/em&gt;, &lt;em&gt;ret&lt;/em&gt;, &lt;em&gt;clipmode&lt;/em&gt;). Create a new array by selecting elements from the sequence of arrays in &lt;em&gt;op&lt;/em&gt; based on the integer values in &lt;em&gt;self&lt;/em&gt;. The arrays must all be broadcastable to the same shape and the entries in &lt;em&gt;self&lt;/em&gt; should be between 0 and len(&lt;em&gt;op&lt;/em&gt;). The output is placed in &lt;em&gt;ret&lt;/em&gt; unless it is &lt;code&gt;NULL&lt;/code&gt; in which case a new output is created. The &lt;em&gt;clipmode&lt;/em&gt; argument determines behavior for when entries in &lt;em&gt;self&lt;/em&gt; are not between 0 and len(&lt;em&gt;op&lt;/em&gt;).</source>
          <target state="translated">Эквивалентно &lt;a href=&quot;generated/numpy.ndarray.choose#numpy.ndarray.choose&quot;&gt; &lt;code&gt;ndarray.choose&lt;/code&gt; &lt;/a&gt; ( &lt;em&gt;self&lt;/em&gt; , &lt;em&gt;op&lt;/em&gt; , &lt;em&gt;ret&lt;/em&gt; , &lt;em&gt;clipmode&lt;/em&gt; ). Создайте новый массив, выбрав элементы из последовательности массивов в &lt;em&gt;op&lt;/em&gt; на основе целочисленных значений в &lt;em&gt;self&lt;/em&gt; . Все массивы должны транслироваться в одну и ту же форму, а записи в &lt;em&gt;self&lt;/em&gt; должны быть от 0 до len ( &lt;em&gt;op&lt;/em&gt; ). Вывод помещается в &lt;em&gt;ret,&lt;/em&gt; если он не равен &lt;code&gt;NULL&lt;/code&gt; ,и в этом случае создается новый вывод. &lt;em&gt;Clipmode&lt;/em&gt; аргумент определяет поведение для того, когда записи в &lt;em&gt;себя&lt;/em&gt; не между 0 и LEN ( &lt;em&gt;ор&lt;/em&gt; ).</target>
        </trans-unit>
        <trans-unit id="07498cd87fe2ef12a2b26de127164c39b4bd9e44" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;a href=&quot;generated/numpy.ndarray.clip#numpy.ndarray.clip&quot;&gt;&lt;code&gt;ndarray.clip&lt;/code&gt;&lt;/a&gt; (&lt;em&gt;self&lt;/em&gt;, &lt;em&gt;min&lt;/em&gt;, &lt;em&gt;max&lt;/em&gt;). Clip an array, &lt;em&gt;self&lt;/em&gt;, so that values larger than &lt;em&gt;max&lt;/em&gt; are fixed to &lt;em&gt;max&lt;/em&gt; and values less than &lt;em&gt;min&lt;/em&gt; are fixed to &lt;em&gt;min&lt;/em&gt;.</source>
          <target state="translated">Эквивалентно &lt;a href=&quot;generated/numpy.ndarray.clip#numpy.ndarray.clip&quot;&gt; &lt;code&gt;ndarray.clip&lt;/code&gt; &lt;/a&gt; ( &lt;em&gt;self&lt;/em&gt; , &lt;em&gt;min&lt;/em&gt; , &lt;em&gt;max&lt;/em&gt; ). Обрезать массив &lt;em&gt;self&lt;/em&gt; , чтобы значения больше &lt;em&gt;max&lt;/em&gt; фиксировались на &lt;em&gt;max,&lt;/em&gt; а значения меньше &lt;em&gt;min&lt;/em&gt; - на &lt;em&gt;min&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="c163c568fd35392b35f7cb27b6a29f0e9cbd90da" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;a href=&quot;generated/numpy.ndarray.compress#numpy.ndarray.compress&quot;&gt;&lt;code&gt;ndarray.compress&lt;/code&gt;&lt;/a&gt; (&lt;em&gt;self&lt;/em&gt;, &lt;em&gt;condition&lt;/em&gt;, &lt;em&gt;axis&lt;/em&gt; ). Return the elements along &lt;em&gt;axis&lt;/em&gt; corresponding to elements of &lt;em&gt;condition&lt;/em&gt; that are true.</source>
          <target state="translated">Эквивалентно &lt;a href=&quot;generated/numpy.ndarray.compress#numpy.ndarray.compress&quot;&gt; &lt;code&gt;ndarray.compress&lt;/code&gt; &lt;/a&gt; ( &lt;em&gt;self&lt;/em&gt; , &lt;em&gt;condition&lt;/em&gt; , &lt;em&gt;axis&lt;/em&gt; ). Вернуть элементы по &lt;em&gt;оси,&lt;/em&gt; соответствующие элементам &lt;em&gt;условия,&lt;/em&gt; которые являются истинными.</target>
        </trans-unit>
        <trans-unit id="dd9acb1c9e137920376909d2dadce0362beab80c" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;a href=&quot;generated/numpy.ndarray.conjugate#numpy.ndarray.conjugate&quot;&gt;&lt;code&gt;ndarray.conjugate&lt;/code&gt;&lt;/a&gt; (&lt;em&gt;self&lt;/em&gt;). Return the complex conjugate of &lt;em&gt;self&lt;/em&gt;. If &lt;em&gt;self&lt;/em&gt; is not of complex data type, then return &lt;em&gt;self&lt;/em&gt; with a reference.</source>
          <target state="translated">Эквивалентно &lt;a href=&quot;generated/numpy.ndarray.conjugate#numpy.ndarray.conjugate&quot;&gt; &lt;code&gt;ndarray.conjugate&lt;/code&gt; &lt;/a&gt; ( &lt;em&gt;self&lt;/em&gt; ). Верните комплексное сопряжение &lt;em&gt;себя&lt;/em&gt; . Если &lt;em&gt;self&lt;/em&gt; не относится к сложному типу данных, верните &lt;em&gt;self&lt;/em&gt; со ссылкой.</target>
        </trans-unit>
        <trans-unit id="cf40d04106c5d52e1884e99b3a37b71d8a81e331" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;a href=&quot;generated/numpy.ndarray.copy#numpy.ndarray.copy&quot;&gt;&lt;code&gt;ndarray.copy&lt;/code&gt;&lt;/a&gt; (&lt;em&gt;self&lt;/em&gt;, &lt;em&gt;fortran&lt;/em&gt;). Make a copy of the &lt;em&gt;old&lt;/em&gt; array. The returned array is always aligned and writeable with data interpreted the same as the old array. If &lt;em&gt;order&lt;/em&gt; is &lt;a href=&quot;#c.NPY_CORDER&quot;&gt;&lt;code&gt;NPY_CORDER&lt;/code&gt;&lt;/a&gt;, then a C-style contiguous array is returned. If &lt;em&gt;order&lt;/em&gt; is &lt;a href=&quot;#c.NPY_FORTRANORDER&quot;&gt;&lt;code&gt;NPY_FORTRANORDER&lt;/code&gt;&lt;/a&gt;, then a Fortran-style contiguous array is returned. If &lt;em&gt;order is&lt;/em&gt;&lt;a href=&quot;#c.NPY_ANYORDER&quot;&gt;&lt;code&gt;NPY_ANYORDER&lt;/code&gt;&lt;/a&gt;, then the array returned is Fortran-style contiguous only if the old one is; otherwise, it is C-style contiguous.</source>
          <target state="translated">Эквивалентен &lt;a href=&quot;generated/numpy.ndarray.copy#numpy.ndarray.copy&quot;&gt; &lt;code&gt;ndarray.copy&lt;/code&gt; &lt;/a&gt; ( &lt;em&gt;self&lt;/em&gt; , &lt;em&gt;fortran&lt;/em&gt; ). Сделайте копию &lt;em&gt;старого&lt;/em&gt; массива. Возвращаемый массив всегда выровнен и доступен для записи с данными, интерпретируемыми так же, как и старый массив. Если &lt;em&gt;порядок&lt;/em&gt; равен &lt;a href=&quot;#c.NPY_CORDER&quot;&gt; &lt;code&gt;NPY_CORDER&lt;/code&gt; &lt;/a&gt; , то возвращается непрерывный массив в стиле C. Если &lt;em&gt;порядок&lt;/em&gt; равен &lt;a href=&quot;#c.NPY_FORTRANORDER&quot;&gt; &lt;code&gt;NPY_FORTRANORDER&lt;/code&gt; &lt;/a&gt; , то возвращается непрерывный массив в стиле Фортрана. Если &lt;em&gt;порядок равен &lt;/em&gt;&lt;a href=&quot;#c.NPY_ANYORDER&quot;&gt; &lt;code&gt;NPY_ANYORDER&lt;/code&gt; &lt;/a&gt; , то возвращаемый массив является непрерывным в стиле Фортрана, только если старый; в противном случае он является непрерывным в стиле C.</target>
        </trans-unit>
        <trans-unit id="98feecd02ab5026f0970a3c09806ab4167d96259" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;a href=&quot;generated/numpy.ndarray.cumprod#numpy.ndarray.cumprod&quot;&gt;&lt;code&gt;ndarray.cumprod&lt;/code&gt;&lt;/a&gt; (&lt;em&gt;self&lt;/em&gt;, &lt;em&gt;axis&lt;/em&gt;, &lt;em&gt;rtype&lt;/em&gt;). Return 1-d cumulative products of elements in &lt;code&gt;self&lt;/code&gt; along &lt;code&gt;axis&lt;/code&gt;. Perform the product after converting data to data type &lt;code&gt;rtype&lt;/code&gt;.</source>
          <target state="translated">Эквивалентен &lt;a href=&quot;generated/numpy.ndarray.cumprod#numpy.ndarray.cumprod&quot;&gt; &lt;code&gt;ndarray.cumprod&lt;/code&gt; &lt;/a&gt; ( &lt;em&gt;self&lt;/em&gt; , &lt;em&gt;axis&lt;/em&gt; , &lt;em&gt;rtype&lt;/em&gt; ). Возврат 1-го кумулятивного произведения элементов в &lt;code&gt;self&lt;/code&gt; вдоль &lt;code&gt;axis&lt;/code&gt; . Выполните произведение после преобразования данных в тип данных &lt;code&gt;rtype&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="26f34a6ad4ecf38e07a2778b6f8366d8507a10ea" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;a href=&quot;generated/numpy.ndarray.cumsum#numpy.ndarray.cumsum&quot;&gt;&lt;code&gt;ndarray.cumsum&lt;/code&gt;&lt;/a&gt; (&lt;em&gt;self&lt;/em&gt;, &lt;em&gt;axis&lt;/em&gt;, &lt;em&gt;rtype&lt;/em&gt;). Return cumulative 1-d sums of elements in &lt;em&gt;self&lt;/em&gt; along &lt;em&gt;axis&lt;/em&gt;. Perform the sum after converting data to data type &lt;em&gt;rtype&lt;/em&gt;.</source>
          <target state="translated">Эквивалентен &lt;a href=&quot;generated/numpy.ndarray.cumsum#numpy.ndarray.cumsum&quot;&gt; &lt;code&gt;ndarray.cumsum&lt;/code&gt; &lt;/a&gt; ( &lt;em&gt;self&lt;/em&gt; , &lt;em&gt;axis&lt;/em&gt; , &lt;em&gt;rtype&lt;/em&gt; ). Возврат совокупных одномерных сумм элементов в &lt;em&gt;себе&lt;/em&gt; вдоль &lt;em&gt;оси&lt;/em&gt; . Выполните суммирование после преобразования данных в тип данных &lt;em&gt;rtype&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="44d031ba857ad4460b29f51ce74504941e945e52" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;a href=&quot;generated/numpy.ndarray.diagonal#numpy.ndarray.diagonal&quot;&gt;&lt;code&gt;ndarray.diagonal&lt;/code&gt;&lt;/a&gt; (&lt;em&gt;self&lt;/em&gt;, &lt;em&gt;offset&lt;/em&gt;, &lt;em&gt;axis1&lt;/em&gt;, &lt;em&gt;axis2&lt;/em&gt; ). Return the &lt;em&gt;offset&lt;/em&gt; diagonals of the 2-d arrays defined by &lt;em&gt;axis1&lt;/em&gt; and &lt;em&gt;axis2&lt;/em&gt;.</source>
          <target state="translated">Эквивалентен &lt;a href=&quot;generated/numpy.ndarray.diagonal#numpy.ndarray.diagonal&quot;&gt; &lt;code&gt;ndarray.diagonal&lt;/code&gt; &lt;/a&gt; ( &lt;em&gt;self&lt;/em&gt; , &lt;em&gt;offset&lt;/em&gt; , &lt;em&gt;axis1&lt;/em&gt; , &lt;em&gt;axis2&lt;/em&gt; ). Возвращает диагонали &lt;em&gt;смещения &lt;/em&gt;&lt;em&gt;двумерных&lt;/em&gt; массивов, определенных &lt;em&gt;осями axis1&lt;/em&gt; и &lt;em&gt;axis2&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="e6400ea427e27ba969159bbf1cd1e50c3dd25455" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;a href=&quot;generated/numpy.ndarray.flatten#numpy.ndarray.flatten&quot;&gt;&lt;code&gt;ndarray.flatten&lt;/code&gt;&lt;/a&gt; (&lt;em&gt;self&lt;/em&gt;, &lt;em&gt;order&lt;/em&gt;). Return a 1-d copy of the array. If &lt;em&gt;order&lt;/em&gt; is &lt;a href=&quot;#c.NPY_FORTRANORDER&quot;&gt;&lt;code&gt;NPY_FORTRANORDER&lt;/code&gt;&lt;/a&gt; the elements are scanned out in Fortran order (first-dimension varies the fastest). If &lt;em&gt;order&lt;/em&gt; is &lt;a href=&quot;#c.NPY_CORDER&quot;&gt;&lt;code&gt;NPY_CORDER&lt;/code&gt;&lt;/a&gt;, the elements of &lt;code&gt;self&lt;/code&gt; are scanned in C-order (last dimension varies the fastest). If &lt;em&gt;order&lt;/em&gt;&lt;a href=&quot;#c.NPY_ANYORDER&quot;&gt;&lt;code&gt;NPY_ANYORDER&lt;/code&gt;&lt;/a&gt;, then the result of &lt;a href=&quot;#c.PyArray_ISFORTRAN&quot;&gt;&lt;code&gt;PyArray_ISFORTRAN&lt;/code&gt;&lt;/a&gt; (&lt;em&gt;self&lt;/em&gt;) is used to determine which order to flatten.</source>
          <target state="translated">Эквивалентен &lt;a href=&quot;generated/numpy.ndarray.flatten#numpy.ndarray.flatten&quot;&gt; &lt;code&gt;ndarray.flatten&lt;/code&gt; &lt;/a&gt; ( &lt;em&gt;self&lt;/em&gt; , &lt;em&gt;order&lt;/em&gt; ). Вернуть 1-мерную копию массива. Если &lt;em&gt;порядок&lt;/em&gt; равен &lt;a href=&quot;#c.NPY_FORTRANORDER&quot;&gt; &lt;code&gt;NPY_FORTRANORDER&lt;/code&gt; ,&lt;/a&gt; элементы сканируются в порядке Fortran (первое измерение изменяется быстрее всего). Если &lt;em&gt;порядок&lt;/em&gt; равен &lt;a href=&quot;#c.NPY_CORDER&quot;&gt; &lt;code&gt;NPY_CORDER&lt;/code&gt; &lt;/a&gt; , элементы &lt;code&gt;self&lt;/code&gt; сканируются в порядке C (последнее измерение изменяется быстрее всего). Если &lt;em&gt;заказ &lt;/em&gt;&lt;a href=&quot;#c.NPY_ANYORDER&quot;&gt; &lt;code&gt;NPY_ANYORDER&lt;/code&gt; &lt;/a&gt; , то результат &lt;a href=&quot;#c.PyArray_ISFORTRAN&quot;&gt; &lt;code&gt;PyArray_ISFORTRAN&lt;/code&gt; &lt;/a&gt; ( &lt;em&gt;self&lt;/em&gt; ) используется для определения порядка сглаживания.</target>
        </trans-unit>
        <trans-unit id="acb7bf8250a91a19555dbcdb02102524e6c94de7" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;a href=&quot;generated/numpy.ndarray.getfield#numpy.ndarray.getfield&quot;&gt;&lt;code&gt;ndarray.getfield&lt;/code&gt;&lt;/a&gt; (&lt;em&gt;self&lt;/em&gt;, &lt;em&gt;dtype&lt;/em&gt;, &lt;em&gt;offset&lt;/em&gt;). This function &lt;a href=&quot;https://docs.python.org/3/c-api/intro.html?reference-count-details&quot;&gt;steals a reference&lt;/a&gt; to &lt;code&gt;PyArray_Descr&lt;/code&gt; and returns a new array of the given &lt;code&gt;dtype&lt;/code&gt; using the data in the current array at a specified &lt;code&gt;offset&lt;/code&gt; in bytes. The &lt;code&gt;offset&lt;/code&gt; plus the itemsize of the new array type must be less than &lt;code&gt;self
-&amp;gt;descr-&amp;gt;elsize&lt;/code&gt; or an error is raised. The same shape and strides as the original array are used. Therefore, this function has the effect of returning a field from a structured array. But, it can also be used to select specific bytes or groups of bytes from any array type.</source>
          <target state="translated">Эквивалентно &lt;a href=&quot;generated/numpy.ndarray.getfield#numpy.ndarray.getfield&quot;&gt; &lt;code&gt;ndarray.getfield&lt;/code&gt; &lt;/a&gt; ( &lt;em&gt;self&lt;/em&gt; , &lt;em&gt;dtype&lt;/em&gt; , &lt;em&gt;offset&lt;/em&gt; ). Эта функция &lt;a href=&quot;https://docs.python.org/3/c-api/intro.html?reference-count-details&quot;&gt;крадет ссылку&lt;/a&gt; на &lt;code&gt;PyArray_Descr&lt;/code&gt; и возвращает новый массив данного &lt;code&gt;dtype&lt;/code&gt; , используя данные в текущем массиве с указанным &lt;code&gt;offset&lt;/code&gt; в байтах. &lt;code&gt;offset&lt;/code&gt; плюс itemsize нового типа массива должен быть меньше , чем &lt;code&gt;self -&amp;gt;descr-&amp;gt;elsize&lt;/code&gt; или возникает ошибка. Используется та же форма и шаги, что и в исходном массиве. Следовательно, эта функция возвращает поле из структурированного массива. Но его также можно использовать для выбора определенных байтов или групп байтов из любого типа массива.</target>
        </trans-unit>
        <trans-unit id="6e1e5da9cdc7a9b4c6725235e40182f3951d083a" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;a href=&quot;generated/numpy.ndarray.max#numpy.ndarray.max&quot;&gt;&lt;code&gt;ndarray.max&lt;/code&gt;&lt;/a&gt; (&lt;em&gt;self&lt;/em&gt;, &lt;em&gt;axis&lt;/em&gt;). Returns the largest element of &lt;em&gt;self&lt;/em&gt; along the given &lt;em&gt;axis&lt;/em&gt;. When the result is a single element, returns a numpy scalar instead of an ndarray.</source>
          <target state="translated">Эквивалентен &lt;a href=&quot;generated/numpy.ndarray.max#numpy.ndarray.max&quot;&gt; &lt;code&gt;ndarray.max&lt;/code&gt; &lt;/a&gt; ( &lt;em&gt;self&lt;/em&gt; , &lt;em&gt;axis&lt;/em&gt; ). Возвращает самый большой элемент &lt;em&gt;self&lt;/em&gt; по заданной &lt;em&gt;оси&lt;/em&gt; . Когда результатом является один элемент, возвращает скаляр numpy вместо ndarray.</target>
        </trans-unit>
        <trans-unit id="bdd01120eccb02f99889760c9ef36e279a9f9ea8" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;a href=&quot;generated/numpy.ndarray.mean#numpy.ndarray.mean&quot;&gt;&lt;code&gt;ndarray.mean&lt;/code&gt;&lt;/a&gt; (&lt;em&gt;self&lt;/em&gt;, &lt;em&gt;axis&lt;/em&gt;, &lt;em&gt;rtype&lt;/em&gt;). Returns the mean of the elements along the given &lt;em&gt;axis&lt;/em&gt;, using the enumerated type &lt;em&gt;rtype&lt;/em&gt; as the data type to sum in. Default sum behavior is obtained using &lt;a href=&quot;c-api.dtype#c.NPY_NOTYPE&quot;&gt;&lt;code&gt;NPY_NOTYPE&lt;/code&gt;&lt;/a&gt; for &lt;em&gt;rtype&lt;/em&gt;.</source>
          <target state="translated">Эквивалентен &lt;a href=&quot;generated/numpy.ndarray.mean#numpy.ndarray.mean&quot;&gt; &lt;code&gt;ndarray.mean&lt;/code&gt; &lt;/a&gt; ( &lt;em&gt;self&lt;/em&gt; , &lt;em&gt;axis&lt;/em&gt; , &lt;em&gt;rtype&lt;/em&gt; ). Возвращает среднее значение элементов по заданной &lt;em&gt;оси&lt;/em&gt; , используя перечислимый тип &lt;em&gt;rtype&lt;/em&gt; в качестве типа данных для суммирования. Поведение суммы по умолчанию получается с использованием &lt;a href=&quot;c-api.dtype#c.NPY_NOTYPE&quot;&gt; &lt;code&gt;NPY_NOTYPE&lt;/code&gt; &lt;/a&gt; для &lt;em&gt;rtype&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="9e276f562081b61880c79febde9752c6b4583d12" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;a href=&quot;generated/numpy.ndarray.min#numpy.ndarray.min&quot;&gt;&lt;code&gt;ndarray.min&lt;/code&gt;&lt;/a&gt; (&lt;em&gt;self&lt;/em&gt;, &lt;em&gt;axis&lt;/em&gt;). Return the smallest element of &lt;em&gt;self&lt;/em&gt; along the given &lt;em&gt;axis&lt;/em&gt;. When the result is a single element, returns a numpy scalar instead of an ndarray.</source>
          <target state="translated">Эквивалентен &lt;a href=&quot;generated/numpy.ndarray.min#numpy.ndarray.min&quot;&gt; &lt;code&gt;ndarray.min&lt;/code&gt; &lt;/a&gt; ( &lt;em&gt;self&lt;/em&gt; , &lt;em&gt;axis&lt;/em&gt; ). Вернуть наименьший элемент &lt;em&gt;себя&lt;/em&gt; по заданной &lt;em&gt;оси&lt;/em&gt; . Когда результатом является один элемент, возвращает скаляр numpy вместо ndarray.</target>
        </trans-unit>
        <trans-unit id="e792db3a62a29831ce03976f5ea2350fba5a323b" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;a href=&quot;generated/numpy.ndarray.nonzero#numpy.ndarray.nonzero&quot;&gt;&lt;code&gt;ndarray.nonzero&lt;/code&gt;&lt;/a&gt; (&lt;em&gt;self&lt;/em&gt;). Returns a tuple of index arrays that select elements of &lt;em&gt;self&lt;/em&gt; that are nonzero. If (nd= &lt;a href=&quot;#c.PyArray_NDIM&quot;&gt;&lt;code&gt;PyArray_NDIM&lt;/code&gt;&lt;/a&gt; ( &lt;code&gt;self&lt;/code&gt; ))==1, then a single index array is returned. The index arrays have data type &lt;a href=&quot;c-api.dtype#c.NPY_INTP&quot;&gt;&lt;code&gt;NPY_INTP&lt;/code&gt;&lt;/a&gt;. If a tuple is returned (nd</source>
          <target state="translated">Эквивалентно &lt;a href=&quot;generated/numpy.ndarray.nonzero#numpy.ndarray.nonzero&quot;&gt; &lt;code&gt;ndarray.nonzero&lt;/code&gt; &lt;/a&gt; ( &lt;em&gt;self&lt;/em&gt; ). Возвращает кортеж индексных массивов, которые выбирают элементы &lt;em&gt;self&lt;/em&gt; , отличные от нуля. Если (nd = &lt;a href=&quot;#c.PyArray_NDIM&quot;&gt; &lt;code&gt;PyArray_NDIM&lt;/code&gt; &lt;/a&gt; ( &lt;code&gt;self&lt;/code&gt; )) == 1, то возвращается единственный индексный массив. Индексные массивы имеют тип данных &lt;a href=&quot;c-api.dtype#c.NPY_INTP&quot;&gt; &lt;code&gt;NPY_INTP&lt;/code&gt; &lt;/a&gt; . Если возвращается кортеж (nd</target>
        </trans-unit>
        <trans-unit id="a70d121c7d953594f404dacb0d342fd3ab8b30ba" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;a href=&quot;generated/numpy.ndarray.partition#numpy.ndarray.partition&quot;&gt;&lt;code&gt;ndarray.partition&lt;/code&gt;&lt;/a&gt; (&lt;em&gt;self&lt;/em&gt;, &lt;em&gt;ktharray&lt;/em&gt;, &lt;em&gt;axis&lt;/em&gt;, &lt;em&gt;kind&lt;/em&gt;). Partitions the array so that the values of the element indexed by &lt;em&gt;ktharray&lt;/em&gt; are in the positions they would be if the array is fully sorted and places all elements smaller than the kth before and all elements equal or greater after the kth element. The ordering of all elements within the partitions is undefined. If &lt;em&gt;self&lt;/em&gt;-&amp;gt;descr is a data-type with fields defined, then self-&amp;gt;descr-&amp;gt;names is used to determine the sort order. A comparison where the first field is equal will use the second field and so on. To alter the sort order of a structured array, create a new data-type with a different order of names and construct a view of the array with that new data-type. Returns zero on success and -1 on failure.</source>
          <target state="translated">Эквивалентно &lt;a href=&quot;generated/numpy.ndarray.partition#numpy.ndarray.partition&quot;&gt; &lt;code&gt;ndarray.partition&lt;/code&gt; &lt;/a&gt; ( &lt;em&gt;self&lt;/em&gt; , &lt;em&gt;ktharray&lt;/em&gt; , &lt;em&gt;axis&lt;/em&gt; , &lt;em&gt;kind&lt;/em&gt; ). Разбивает массив таким образом, чтобы значения элемента, проиндексированного &lt;em&gt;ktharray,&lt;/em&gt; находились в тех позициях, которые они были бы, если бы массив был полностью отсортирован, и помещает все элементы, меньшие, чем k-й перед, и все элементы, равные или большие после k-го элемента. Порядок всех элементов в разделах не определен. Если &lt;em&gt;я&lt;/em&gt;-&amp;gt; descr - это тип данных с определенными полями, затем self-&amp;gt; descr-&amp;gt; names используется для определения порядка сортировки. При сравнении, в котором первое поле равно, будет использоваться второе поле и так далее. Чтобы изменить порядок сортировки структурированного массива, создайте новый тип данных с другим порядком имен и создайте представление массива с этим новым типом данных. Возвращает ноль в случае успеха и -1 в случае неудачи.</target>
        </trans-unit>
        <trans-unit id="1404ab20af4a0d50c24ff1ca93cc3a3448c7e38e" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;a href=&quot;generated/numpy.ndarray.prod#numpy.ndarray.prod&quot;&gt;&lt;code&gt;ndarray.prod&lt;/code&gt;&lt;/a&gt; (&lt;em&gt;self&lt;/em&gt;, &lt;em&gt;axis&lt;/em&gt;, &lt;em&gt;rtype&lt;/em&gt;). Return 1-d products of elements in &lt;em&gt;self&lt;/em&gt; along &lt;em&gt;axis&lt;/em&gt;. Perform the product after converting data to data type &lt;em&gt;rtype&lt;/em&gt;.</source>
          <target state="translated">Эквивалентен &lt;a href=&quot;generated/numpy.ndarray.prod#numpy.ndarray.prod&quot;&gt; &lt;code&gt;ndarray.prod&lt;/code&gt; &lt;/a&gt; ( &lt;em&gt;self&lt;/em&gt; , &lt;em&gt;axis&lt;/em&gt; , &lt;em&gt;rtype&lt;/em&gt; ). Вернуть 1-е произведения элементов в &lt;em&gt;себя&lt;/em&gt; по &lt;em&gt;оси&lt;/em&gt; . Выполните произведение после преобразования данных в тип данных &lt;em&gt;rtype&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="1100d008c0276fd76e61e9204938c06e2c190cea" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;a href=&quot;generated/numpy.ndarray.ptp#numpy.ndarray.ptp&quot;&gt;&lt;code&gt;ndarray.ptp&lt;/code&gt;&lt;/a&gt; (&lt;em&gt;self&lt;/em&gt;, &lt;em&gt;axis&lt;/em&gt;). Return the difference between the largest element of &lt;em&gt;self&lt;/em&gt; along &lt;em&gt;axis&lt;/em&gt; and the smallest element of &lt;em&gt;self&lt;/em&gt; along &lt;em&gt;axis&lt;/em&gt;. When the result is a single element, returns a numpy scalar instead of an ndarray.</source>
          <target state="translated">Эквивалентен &lt;a href=&quot;generated/numpy.ndarray.ptp#numpy.ndarray.ptp&quot;&gt; &lt;code&gt;ndarray.ptp&lt;/code&gt; &lt;/a&gt; ( &lt;em&gt;self&lt;/em&gt; , &lt;em&gt;axis&lt;/em&gt; ). Возврат разницы между самым большим элементом &lt;em&gt;self&lt;/em&gt; вдоль &lt;em&gt;оси&lt;/em&gt; и наименьшим элементом &lt;em&gt;self&lt;/em&gt; вдоль &lt;em&gt;оси&lt;/em&gt; . Когда результатом является один элемент, возвращает скаляр numpy вместо ndarray.</target>
        </trans-unit>
        <trans-unit id="2c16f538cf9a4222086ade1f8bc40148ea4157cd" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;a href=&quot;generated/numpy.ndarray.repeat#numpy.ndarray.repeat&quot;&gt;&lt;code&gt;ndarray.repeat&lt;/code&gt;&lt;/a&gt; (&lt;em&gt;self&lt;/em&gt;, &lt;em&gt;op&lt;/em&gt;, &lt;em&gt;axis&lt;/em&gt;). Copy the elements of &lt;em&gt;self&lt;/em&gt;, &lt;em&gt;op&lt;/em&gt; times along the given &lt;em&gt;axis&lt;/em&gt;. Either &lt;em&gt;op&lt;/em&gt; is a scalar integer or a sequence of length &lt;em&gt;self&lt;/em&gt; -&amp;gt;dimensions[ &lt;em&gt;axis&lt;/em&gt; ] indicating how many times to repeat each item along the axis.</source>
          <target state="translated">Эквивалентен &lt;a href=&quot;generated/numpy.ndarray.repeat#numpy.ndarray.repeat&quot;&gt; &lt;code&gt;ndarray.repeat&lt;/code&gt; &lt;/a&gt; ( &lt;em&gt;self&lt;/em&gt; , &lt;em&gt;op&lt;/em&gt; , &lt;em&gt;axis&lt;/em&gt; ). Скопируйте элементы &lt;em&gt;self&lt;/em&gt; , &lt;em&gt;op&lt;/em&gt; раз по заданной &lt;em&gt;оси&lt;/em&gt; . Либо &lt;em&gt;op&lt;/em&gt; - это скалярное целое число, либо последовательность длины &lt;em&gt;self&lt;/em&gt; -&amp;gt; sizes [ &lt;em&gt;axis&lt;/em&gt; ], указывающая, сколько раз повторять каждый элемент вдоль оси.</target>
        </trans-unit>
        <trans-unit id="89f8dce1a3fdb6440169e6117acb2747787948e3" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;a href=&quot;generated/numpy.ndarray.reshape#numpy.ndarray.reshape&quot;&gt;&lt;code&gt;ndarray.reshape&lt;/code&gt;&lt;/a&gt; (&lt;em&gt;self&lt;/em&gt;, &lt;em&gt;shape&lt;/em&gt;) where &lt;em&gt;shape&lt;/em&gt; is a sequence. Converts &lt;em&gt;shape&lt;/em&gt; to a &lt;a href=&quot;c-api.types-and-structures#c.PyArray_Dims&quot;&gt;&lt;code&gt;PyArray_Dims&lt;/code&gt;&lt;/a&gt; structure and calls &lt;a href=&quot;#c.PyArray_Newshape&quot;&gt;&lt;code&gt;PyArray_Newshape&lt;/code&gt;&lt;/a&gt; internally. For back-ward compatibility &amp;ndash; Not recommended</source>
          <target state="translated">Эквивалентен &lt;a href=&quot;generated/numpy.ndarray.reshape#numpy.ndarray.reshape&quot;&gt; &lt;code&gt;ndarray.reshape&lt;/code&gt; &lt;/a&gt; ( &lt;em&gt;self&lt;/em&gt; , &lt;em&gt;shape&lt;/em&gt; ), где &lt;em&gt;shape&lt;/em&gt; - последовательность. Обращенные &lt;em&gt;формы&lt;/em&gt; в &lt;a href=&quot;c-api.types-and-structures#c.PyArray_Dims&quot;&gt; &lt;code&gt;PyArray_Dims&lt;/code&gt; &lt;/a&gt; структуру и вызывает &lt;a href=&quot;#c.PyArray_Newshape&quot;&gt; &lt;code&gt;PyArray_Newshape&lt;/code&gt; &lt;/a&gt; внутри. Для обратной совместимости - не рекомендуется</target>
        </trans-unit>
        <trans-unit id="c66cfa86b4fd8c96342e13259600ca57c73356a4" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;a href=&quot;generated/numpy.ndarray.resize#numpy.ndarray.resize&quot;&gt;&lt;code&gt;ndarray.resize&lt;/code&gt;&lt;/a&gt; (&lt;em&gt;self&lt;/em&gt;, &lt;em&gt;newshape&lt;/em&gt;, refcheck &lt;code&gt;=&lt;/code&gt;&lt;em&gt;refcheck&lt;/em&gt;, order= fortran ). This function only works on single-segment arrays. It changes the shape of &lt;em&gt;self&lt;/em&gt; inplace and will reallocate the memory for &lt;em&gt;self&lt;/em&gt; if &lt;em&gt;newshape&lt;/em&gt; has a different total number of elements then the old shape. If reallocation is necessary, then &lt;em&gt;self&lt;/em&gt; must own its data, have &lt;em&gt;self&lt;/em&gt; - &lt;code&gt;&amp;gt;base==NULL&lt;/code&gt;, have &lt;em&gt;self&lt;/em&gt; - &lt;code&gt;&amp;gt;weakrefs==NULL&lt;/code&gt;, and (unless refcheck is 0) not be referenced by any other array. The fortran argument can be &lt;a href=&quot;#c.NPY_ANYORDER&quot;&gt;&lt;code&gt;NPY_ANYORDER&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#c.NPY_CORDER&quot;&gt;&lt;code&gt;NPY_CORDER&lt;/code&gt;&lt;/a&gt;, or &lt;a href=&quot;#c.NPY_FORTRANORDER&quot;&gt;&lt;code&gt;NPY_FORTRANORDER&lt;/code&gt;&lt;/a&gt;. It currently has no effect. Eventually it could be used to determine how the resize operation should view the data when constructing a differently-dimensioned array. Returns None on success and NULL on error.</source>
          <target state="translated">Эквивалентно &lt;a href=&quot;generated/numpy.ndarray.resize#numpy.ndarray.resize&quot;&gt; &lt;code&gt;ndarray.resize&lt;/code&gt; &lt;/a&gt; ( &lt;em&gt;self&lt;/em&gt; , &lt;em&gt;newshape&lt;/em&gt; , refcheck &lt;code&gt;=&lt;/code&gt; &lt;em&gt;refcheck&lt;/em&gt; , order = fortran). Эта функция работает только с односегментными массивами. Он изменяет форму &lt;em&gt;себя на месте&lt;/em&gt; и перераспределяет память для &lt;em&gt;себя,&lt;/em&gt; если у &lt;em&gt;новостной формы&lt;/em&gt; другое общее количество элементов, чем у старой формы. Если перераспределение необходимо, тогда &lt;em&gt;self&lt;/em&gt; должен владеть своими данными, иметь &lt;em&gt;self&lt;/em&gt; - &lt;code&gt;&amp;gt;base==NULL&lt;/code&gt; , иметь &lt;em&gt;self&lt;/em&gt; - &lt;code&gt;&amp;gt;weakrefs==NULL&lt;/code&gt; и (если refcheck не равен 0) не ссылаться на какой-либо другой массив. Аргумент fortran может иметь вид &lt;a href=&quot;#c.NPY_ANYORDER&quot;&gt; &lt;code&gt;NPY_ANYORDER&lt;/code&gt; &lt;/a&gt;, &lt;a href=&quot;#c.NPY_CORDER&quot;&gt; &lt;code&gt;NPY_CORDER&lt;/code&gt; &lt;/a&gt; или &lt;a href=&quot;#c.NPY_FORTRANORDER&quot;&gt; &lt;code&gt;NPY_FORTRANORDER&lt;/code&gt; &lt;/a&gt; . В настоящее время это не действует. В конечном итоге его можно было использовать для определения того, как операция изменения размера должна просматривать данные при построении массива с другими размерами. Возвращает None в случае успеха и NULL в случае ошибки.</target>
        </trans-unit>
        <trans-unit id="c35d0fb0b3b672f40f8ed22b6a36b98bc32ccd79" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;a href=&quot;generated/numpy.ndarray.round#numpy.ndarray.round&quot;&gt;&lt;code&gt;ndarray.round&lt;/code&gt;&lt;/a&gt; (&lt;em&gt;self&lt;/em&gt;, &lt;em&gt;decimals&lt;/em&gt;, &lt;em&gt;out&lt;/em&gt;). Returns the array with elements rounded to the nearest decimal place. The decimal place is defined as the</source>
          <target state="translated">Эквивалент &lt;a href=&quot;generated/numpy.ndarray.round#numpy.ndarray.round&quot;&gt; &lt;code&gt;ndarray.round&lt;/code&gt; &lt;/a&gt; ( &lt;em&gt;самостоятельно&lt;/em&gt; , &lt;em&gt;десятичные&lt;/em&gt; , &lt;em&gt;вне&lt;/em&gt; ). Возвращает массив с элементами, округленными до ближайшего десятичного знака. Десятичный разряд определяется как</target>
        </trans-unit>
        <trans-unit id="77c91912c2f0496c5da34bf18831db8c3ec272aa" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;a href=&quot;generated/numpy.ndarray.searchsorted#numpy.ndarray.searchsorted&quot;&gt;&lt;code&gt;ndarray.searchsorted&lt;/code&gt;&lt;/a&gt; (&lt;em&gt;self&lt;/em&gt;, &lt;em&gt;values&lt;/em&gt;, &lt;em&gt;side&lt;/em&gt;, &lt;em&gt;perm&lt;/em&gt;). Assuming &lt;em&gt;self&lt;/em&gt; is a 1-d array in ascending order, then the output is an array of indices the same shape as &lt;em&gt;values&lt;/em&gt; such that, if the elements in &lt;em&gt;values&lt;/em&gt; were inserted before the indices, the order of &lt;em&gt;self&lt;/em&gt; would be preserved. No checking is done on whether or not self is in ascending order.</source>
          <target state="translated">Эквивалентно &lt;a href=&quot;generated/numpy.ndarray.searchsorted#numpy.ndarray.searchsorted&quot;&gt; &lt;code&gt;ndarray.searchsorted&lt;/code&gt; &lt;/a&gt; ( &lt;em&gt;self&lt;/em&gt; , &lt;em&gt;values&lt;/em&gt; , &lt;em&gt;side&lt;/em&gt; , &lt;em&gt;perm&lt;/em&gt; ). Предполагая, что &lt;em&gt;self&lt;/em&gt; - это одномерный массив в возрастающем порядке, тогда на выходе будет массив индексов той же формы, что и &lt;em&gt;значения&lt;/em&gt; , так что, если бы элементы в &lt;em&gt;values&lt;/em&gt; были вставлены перед индексами, порядок &lt;em&gt;self&lt;/em&gt; был бы сохранен. Не проверяется, находится ли я в порядке возрастания.</target>
        </trans-unit>
        <trans-unit id="129c27494826551cd6d91c742839f2dd3b7a2b39" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;a href=&quot;generated/numpy.ndarray.setfield#numpy.ndarray.setfield&quot;&gt;&lt;code&gt;ndarray.setfield&lt;/code&gt;&lt;/a&gt; (&lt;em&gt;self&lt;/em&gt;, &lt;em&gt;val&lt;/em&gt;, &lt;em&gt;dtype&lt;/em&gt;, &lt;em&gt;offset&lt;/em&gt; ). Set the field starting at &lt;em&gt;offset&lt;/em&gt; in bytes and of the given &lt;em&gt;dtype&lt;/em&gt; to &lt;em&gt;val&lt;/em&gt;. The &lt;em&gt;offset&lt;/em&gt; plus &lt;em&gt;dtype&lt;/em&gt; -&amp;gt;elsize must be less than &lt;em&gt;self&lt;/em&gt; -&amp;gt;descr-&amp;gt;elsize or an error is raised. Otherwise, the &lt;em&gt;val&lt;/em&gt; argument is converted to an array and copied into the field pointed to. If necessary, the elements of &lt;em&gt;val&lt;/em&gt; are repeated to fill the destination array, But, the number of elements in the destination must be an integer multiple of the number of elements in &lt;em&gt;val&lt;/em&gt;.</source>
          <target state="translated">Эквивалентен &lt;a href=&quot;generated/numpy.ndarray.setfield#numpy.ndarray.setfield&quot;&gt; &lt;code&gt;ndarray.setfield&lt;/code&gt; &lt;/a&gt; ( &lt;em&gt;self&lt;/em&gt; , &lt;em&gt;val&lt;/em&gt; , &lt;em&gt;dtype&lt;/em&gt; , &lt;em&gt;offset&lt;/em&gt; ). Установите для поля, начинающегося со &lt;em&gt;смещения&lt;/em&gt; в байтах, и заданного типа &lt;em&gt;dtype&lt;/em&gt; значение &lt;em&gt;val&lt;/em&gt; . &lt;em&gt;Смещение&lt;/em&gt; плюс &lt;em&gt;DTYPE&lt;/em&gt; -&amp;gt; elsize должно быть меньше , чем &lt;em&gt;я&lt;/em&gt; -&amp;gt; descr-&amp;gt; elsize или возникает ошибка. В противном случае аргумент &lt;em&gt;val&lt;/em&gt; преобразуется в массив и копируется в указанное поле. Если необходимо, элементы &lt;em&gt;val&lt;/em&gt; повторяются для заполнения целевого массива, но количество элементов в целевом массиве должно быть целым числом, кратным количеству элементов в&lt;em&gt;val&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="329e170888d304760a845c23e2123d83a997ded2" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;a href=&quot;generated/numpy.ndarray.sort#numpy.ndarray.sort&quot;&gt;&lt;code&gt;ndarray.sort&lt;/code&gt;&lt;/a&gt; (&lt;em&gt;self&lt;/em&gt;, &lt;em&gt;axis&lt;/em&gt;, &lt;em&gt;kind&lt;/em&gt;). Return an array with the items of &lt;em&gt;self&lt;/em&gt; sorted along &lt;em&gt;axis&lt;/em&gt;. The array is sorted using the algorithm denoted by &lt;em&gt;kind&lt;/em&gt; , which is an integer/enum pointing to the type of sorting algorithms used.</source>
          <target state="translated">Эквивалентен &lt;a href=&quot;generated/numpy.ndarray.sort#numpy.ndarray.sort&quot;&gt; &lt;code&gt;ndarray.sort&lt;/code&gt; &lt;/a&gt; ( &lt;em&gt;self&lt;/em&gt; , &lt;em&gt;axis&lt;/em&gt; , &lt;em&gt;kind&lt;/em&gt; ). Возвращает массив с элементами из &lt;em&gt;себя&lt;/em&gt; отсортированных по &lt;em&gt;оси&lt;/em&gt; . Массив сортируется с использованием алгоритма, обозначенного &lt;em&gt;типом&lt;/em&gt; , который представляет собой целое число / перечисление, указывающее на тип используемых алгоритмов сортировки.</target>
        </trans-unit>
        <trans-unit id="18f23f95a5677bb30c45f3519a8a38c4eb9ab14d" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;a href=&quot;generated/numpy.ndarray.squeeze#numpy.ndarray.squeeze&quot;&gt;&lt;code&gt;ndarray.squeeze&lt;/code&gt;&lt;/a&gt; (&lt;em&gt;self&lt;/em&gt;). Return a new view of &lt;em&gt;self&lt;/em&gt; with all of the dimensions of length 1 removed from the shape.</source>
          <target state="translated">Эквивалентно &lt;a href=&quot;generated/numpy.ndarray.squeeze#numpy.ndarray.squeeze&quot;&gt; &lt;code&gt;ndarray.squeeze&lt;/code&gt; &lt;/a&gt; ( &lt;em&gt;self&lt;/em&gt; ). Верните новый вид &lt;em&gt;себя&lt;/em&gt; со всеми размерами длины 1, удаленными из формы.</target>
        </trans-unit>
        <trans-unit id="f3ea257f6db1c3b5b426fb4027029e9f1b7413a5" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;a href=&quot;generated/numpy.ndarray.std#numpy.ndarray.std&quot;&gt;&lt;code&gt;ndarray.std&lt;/code&gt;&lt;/a&gt; (&lt;em&gt;self&lt;/em&gt;, &lt;em&gt;axis&lt;/em&gt;, &lt;em&gt;rtype&lt;/em&gt;). Return the standard deviation using data along &lt;em&gt;axis&lt;/em&gt; converted to data type &lt;em&gt;rtype&lt;/em&gt;.</source>
          <target state="translated">Эквивалентен &lt;a href=&quot;generated/numpy.ndarray.std#numpy.ndarray.std&quot;&gt; &lt;code&gt;ndarray.std&lt;/code&gt; &lt;/a&gt; ( &lt;em&gt;self&lt;/em&gt; , &lt;em&gt;axis&lt;/em&gt; , &lt;em&gt;rtype&lt;/em&gt; ). Верните стандартное отклонение, используя данные по &lt;em&gt;оси,&lt;/em&gt; преобразованные в тип данных &lt;em&gt;rtype&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="4c7387b455871f5d5fed3305db644e74b9628876" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;a href=&quot;generated/numpy.ndarray.sum#numpy.ndarray.sum&quot;&gt;&lt;code&gt;ndarray.sum&lt;/code&gt;&lt;/a&gt; (&lt;em&gt;self&lt;/em&gt;, &lt;em&gt;axis&lt;/em&gt;, &lt;em&gt;rtype&lt;/em&gt;). Return 1-d vector sums of elements in &lt;em&gt;self&lt;/em&gt; along &lt;em&gt;axis&lt;/em&gt;. Perform the sum after converting data to data type &lt;em&gt;rtype&lt;/em&gt;.</source>
          <target state="translated">Эквивалентен &lt;a href=&quot;generated/numpy.ndarray.sum#numpy.ndarray.sum&quot;&gt; &lt;code&gt;ndarray.sum&lt;/code&gt; &lt;/a&gt; ( &lt;em&gt;self&lt;/em&gt; , &lt;em&gt;axis&lt;/em&gt; , &lt;em&gt;rtype&lt;/em&gt; ). Возвращает 1-мерные векторные суммы элементов в &lt;em&gt;себе&lt;/em&gt; вдоль &lt;em&gt;оси&lt;/em&gt; . Выполните суммирование после преобразования данных в тип данных &lt;em&gt;rtype&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="9b9ac6ba7775647d994932881b5b117c78bc1d61" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;a href=&quot;generated/numpy.ndarray.swapaxes#numpy.ndarray.swapaxes&quot;&gt;&lt;code&gt;ndarray.swapaxes&lt;/code&gt;&lt;/a&gt; (&lt;em&gt;self&lt;/em&gt;, &lt;em&gt;a1&lt;/em&gt;, &lt;em&gt;a2&lt;/em&gt;). The returned array is a new view of the data in &lt;em&gt;self&lt;/em&gt; with the given axes, &lt;em&gt;a1&lt;/em&gt; and &lt;em&gt;a2&lt;/em&gt;, swapped.</source>
          <target state="translated">Эквивалентен &lt;a href=&quot;generated/numpy.ndarray.swapaxes#numpy.ndarray.swapaxes&quot;&gt; &lt;code&gt;ndarray.swapaxes&lt;/code&gt; &lt;/a&gt; ( &lt;em&gt;self&lt;/em&gt; , &lt;em&gt;a1&lt;/em&gt; , &lt;em&gt;a2&lt;/em&gt; ). Возвращенный массив - это новое представление данных в &lt;em&gt;себе&lt;/em&gt; с &lt;em&gt;поменяемыми&lt;/em&gt; местами заданными осями &lt;em&gt;a1&lt;/em&gt; и &lt;em&gt;a2&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="526d5a8267bf48a76f6e4bef39106e81c90185a6" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;a href=&quot;generated/numpy.ndarray.take#numpy.ndarray.take&quot;&gt;&lt;code&gt;ndarray.take&lt;/code&gt;&lt;/a&gt; (&lt;em&gt;self&lt;/em&gt;, &lt;em&gt;indices&lt;/em&gt;, &lt;em&gt;axis&lt;/em&gt;, &lt;em&gt;ret&lt;/em&gt;, &lt;em&gt;clipmode&lt;/em&gt;) except &lt;em&gt;axis&lt;/em&gt; =None in Python is obtained by setting &lt;em&gt;axis&lt;/em&gt; = &lt;a href=&quot;#c.NPY_MAXDIMS&quot;&gt;&lt;code&gt;NPY_MAXDIMS&lt;/code&gt;&lt;/a&gt; in C. Extract the items from self indicated by the integer-valued &lt;em&gt;indices&lt;/em&gt; along the given &lt;em&gt;axis.&lt;/em&gt; The clipmode argument can be &lt;a href=&quot;#c.NPY_RAISE&quot;&gt;&lt;code&gt;NPY_RAISE&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#c.NPY_WRAP&quot;&gt;&lt;code&gt;NPY_WRAP&lt;/code&gt;&lt;/a&gt;, or &lt;a href=&quot;#c.NPY_CLIP&quot;&gt;&lt;code&gt;NPY_CLIP&lt;/code&gt;&lt;/a&gt; to indicate what to do with out-of-bound indices. The &lt;em&gt;ret&lt;/em&gt; argument can specify an output array rather than having one created internally.</source>
          <target state="translated">Эквивалент &lt;a href=&quot;generated/numpy.ndarray.take#numpy.ndarray.take&quot;&gt; &lt;code&gt;ndarray.take&lt;/code&gt; &lt;/a&gt; ( &lt;em&gt;себя&lt;/em&gt; , &lt;em&gt;индексы&lt;/em&gt; , &lt;em&gt;оси&lt;/em&gt; , &lt;em&gt;RET&lt;/em&gt; , &lt;em&gt;clipmode&lt;/em&gt; ) , за исключением &lt;em&gt;оси&lt;/em&gt; = Ни в Python не будет получен путем установки &lt;em&gt;ось&lt;/em&gt; = &lt;a href=&quot;#c.NPY_MAXDIMS&quot;&gt; &lt;code&gt;NPY_MAXDIMS&lt;/code&gt; &lt;/a&gt; в С. Извлечения элементов из собственных обозначены целочисленных &lt;em&gt;индексов&lt;/em&gt; вдоль заданной &lt;em&gt;оси.&lt;/em&gt; Аргументом clipmode может быть &lt;a href=&quot;#c.NPY_RAISE&quot;&gt; &lt;code&gt;NPY_RAISE&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#c.NPY_WRAP&quot;&gt; &lt;code&gt;NPY_WRAP&lt;/code&gt; &lt;/a&gt; или &lt;a href=&quot;#c.NPY_CLIP&quot;&gt; &lt;code&gt;NPY_CLIP&lt;/code&gt; ,&lt;/a&gt; чтобы указать, что делать с индексами, выходящими за границы. &lt;em&gt;RET&lt;/em&gt; аргумент может указать выходной массив , а не имеющие одну созданные внутри.</target>
        </trans-unit>
        <trans-unit id="3fbb6db45f5065f7d5f46448fca11ee7f459d488" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;a href=&quot;generated/numpy.ndarray.tobytes#numpy.ndarray.tobytes&quot;&gt;&lt;code&gt;ndarray.tobytes&lt;/code&gt;&lt;/a&gt; (&lt;em&gt;self&lt;/em&gt;, &lt;em&gt;order&lt;/em&gt;). Return the bytes of this array in a Python string.</source>
          <target state="translated">Эквивалентно &lt;a href=&quot;generated/numpy.ndarray.tobytes#numpy.ndarray.tobytes&quot;&gt; &lt;code&gt;ndarray.tobytes&lt;/code&gt; &lt;/a&gt; ( &lt;em&gt;self&lt;/em&gt; , &lt;em&gt;order&lt;/em&gt; ). Верните байты этого массива в строку Python.</target>
        </trans-unit>
        <trans-unit id="e1487cf1aae9421a58178865b5cc518907b872e6" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;a href=&quot;generated/numpy.ndarray.tolist#numpy.ndarray.tolist&quot;&gt;&lt;code&gt;ndarray.tolist&lt;/code&gt;&lt;/a&gt; (&lt;em&gt;self&lt;/em&gt;). Return a nested Python list from &lt;em&gt;self&lt;/em&gt;.</source>
          <target state="translated">Эквивалентен &lt;a href=&quot;generated/numpy.ndarray.tolist#numpy.ndarray.tolist&quot;&gt; &lt;code&gt;ndarray.tolist&lt;/code&gt; &lt;/a&gt; ( &lt;em&gt;self&lt;/em&gt; ). Вернуть вложенный список Python из &lt;em&gt;себя&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="92f6eaf18a532cc83a7879c0fc5e0cdb9219ac58" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;a href=&quot;generated/numpy.ndarray.trace#numpy.ndarray.trace&quot;&gt;&lt;code&gt;ndarray.trace&lt;/code&gt;&lt;/a&gt; (&lt;em&gt;self&lt;/em&gt;, &lt;em&gt;offset&lt;/em&gt;, &lt;em&gt;axis1&lt;/em&gt;, &lt;em&gt;axis2&lt;/em&gt;, &lt;em&gt;rtype&lt;/em&gt;). Return the sum (using &lt;em&gt;rtype&lt;/em&gt; as the data type of summation) over the &lt;em&gt;offset&lt;/em&gt; diagonal elements of the 2-d arrays defined by &lt;em&gt;axis1&lt;/em&gt; and &lt;em&gt;axis2&lt;/em&gt; variables. A positive offset chooses diagonals above the main diagonal. A negative offset selects diagonals below the main diagonal.</source>
          <target state="translated">Эквивалентен &lt;a href=&quot;generated/numpy.ndarray.trace#numpy.ndarray.trace&quot;&gt; &lt;code&gt;ndarray.trace&lt;/code&gt; &lt;/a&gt; ( &lt;em&gt;self&lt;/em&gt; , &lt;em&gt;offset&lt;/em&gt; , &lt;em&gt;axis1&lt;/em&gt; , &lt;em&gt;axis2&lt;/em&gt; , &lt;em&gt;rtype&lt;/em&gt; ). Возвращает сумму (используя &lt;em&gt;rtype&lt;/em&gt; в качестве типа данных суммирования) по &lt;em&gt;смещенным&lt;/em&gt; диагональным элементам &lt;em&gt;двумерных&lt;/em&gt; массивов, определенных переменными &lt;em&gt;axis1&lt;/em&gt; и &lt;em&gt;axis2&lt;/em&gt; . При положительном смещении диагонали выбираются выше главной диагонали. Отрицательное смещение выбирает диагонали ниже главной диагонали.</target>
        </trans-unit>
        <trans-unit id="903dc5f64afb6611725d0b8ef7bd16c3db35ef02" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;a href=&quot;generated/numpy.ndarray.transpose#numpy.ndarray.transpose&quot;&gt;&lt;code&gt;ndarray.transpose&lt;/code&gt;&lt;/a&gt; (&lt;em&gt;self&lt;/em&gt;, &lt;em&gt;permute&lt;/em&gt;). Permute the axes of the ndarray object &lt;em&gt;self&lt;/em&gt; according to the data structure &lt;em&gt;permute&lt;/em&gt; and return the result. If &lt;em&gt;permute&lt;/em&gt; is &lt;code&gt;NULL&lt;/code&gt;, then the resulting array has its axes reversed. For example if &lt;em&gt;self&lt;/em&gt; has shape</source>
          <target state="translated">Эквивалентно &lt;a href=&quot;generated/numpy.ndarray.transpose#numpy.ndarray.transpose&quot;&gt; &lt;code&gt;ndarray.transpose&lt;/code&gt; &lt;/a&gt; ( &lt;em&gt;self&lt;/em&gt; , &lt;em&gt;permute&lt;/em&gt; ). Переставьте оси объекта ndarray &lt;em&gt;self в&lt;/em&gt; соответствии с &lt;em&gt;перестановкой&lt;/em&gt; структуры данных и верните результат. Если &lt;em&gt;permute&lt;/em&gt; равен &lt;code&gt;NULL&lt;/code&gt; , то оси результирующего массива меняются местами. Например, если у &lt;em&gt;себя&lt;/em&gt; есть форма</target>
        </trans-unit>
        <trans-unit id="2e84dfaf00361747bc32ce6d08fe80d8b155279f" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;a href=&quot;generated/numpy.ndarray.view#numpy.ndarray.view&quot;&gt;&lt;code&gt;ndarray.view&lt;/code&gt;&lt;/a&gt; (&lt;em&gt;self&lt;/em&gt;, &lt;em&gt;dtype&lt;/em&gt;). Return a new view of the array &lt;em&gt;self&lt;/em&gt; as possibly a different data-type, &lt;em&gt;dtype&lt;/em&gt;, and different array subclass &lt;em&gt;ptype&lt;/em&gt;.</source>
          <target state="translated">Эквивалентно &lt;a href=&quot;generated/numpy.ndarray.view#numpy.ndarray.view&quot;&gt; &lt;code&gt;ndarray.view&lt;/code&gt; &lt;/a&gt; ( &lt;em&gt;self&lt;/em&gt; , &lt;em&gt;dtype&lt;/em&gt; ). Вернуть новое представление массива &lt;em&gt;self&lt;/em&gt; как, возможно, другого типа данных, &lt;em&gt;dtype&lt;/em&gt; и другого подкласса массива &lt;em&gt;ptype&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="c80f2487a92354ad196d90ca737086d6a28cb501" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;a href=&quot;https://docs.python.org/dev/c-api/init.html#c.Py_BEGIN_ALLOW_THREADS&quot;&gt;&lt;code&gt;Py_BEGIN_ALLOW_THREADS&lt;/code&gt;&lt;/a&gt; except it uses &lt;code&gt;NPY_ALLOW_THREADS&lt;/code&gt; to determine if the macro if replaced with white-space or not.</source>
          <target state="translated">Эквивалентен &lt;a href=&quot;https://docs.python.org/dev/c-api/init.html#c.Py_BEGIN_ALLOW_THREADS&quot;&gt; &lt;code&gt;Py_BEGIN_ALLOW_THREADS&lt;/code&gt; ,&lt;/a&gt; за исключением того, что он использует &lt;code&gt;NPY_ALLOW_THREADS&lt;/code&gt; , чтобы определить, заменен ли макрос пробелом или нет.</target>
        </trans-unit>
        <trans-unit id="657a5eba5419e2937f0d7b0877025c3f2a8bf379" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;a href=&quot;https://docs.python.org/dev/c-api/init.html#c.Py_END_ALLOW_THREADS&quot;&gt;&lt;code&gt;Py_END_ALLOW_THREADS&lt;/code&gt;&lt;/a&gt; except it uses &lt;code&gt;NPY_ALLOW_THREADS&lt;/code&gt; to determine if the macro if replaced with white-space or not.</source>
          <target state="translated">Эквивалентен &lt;a href=&quot;https://docs.python.org/dev/c-api/init.html#c.Py_END_ALLOW_THREADS&quot;&gt; &lt;code&gt;Py_END_ALLOW_THREADS&lt;/code&gt; ,&lt;/a&gt; за исключением того, что он использует &lt;code&gt;NPY_ALLOW_THREADS&lt;/code&gt; , чтобы определить, заменен ли макрос пробелом или нет.</target>
        </trans-unit>
        <trans-unit id="821886e91092ad64682392ad985ffcb281eaf4b3" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;code&gt;1/2 * (np.exp(x) + np.exp(-x))&lt;/code&gt; and &lt;code&gt;np.cos(1j*x)&lt;/code&gt;.</source>
          <target state="translated">Эквивалентно &lt;code&gt;1/2 * (np.exp(x) + np.exp(-x))&lt;/code&gt; и &lt;code&gt;np.cos(1j*x)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6cedbe2e2d0fc9bc98c2a4058eb21de10f0ba961" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;code&gt;1/2 * (np.exp(x) - np.exp(-x))&lt;/code&gt; or &lt;code&gt;-1j * np.sin(1j*x)&lt;/code&gt;.</source>
          <target state="translated">Эквивалентно &lt;code&gt;1/2 * (np.exp(x) - np.exp(-x))&lt;/code&gt; или &lt;code&gt;-1j * np.sin(1j*x)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="65cabfa0a0b1ab314bf5ad313943ea0a61c9f913" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;code&gt;a.copy(order='K')&lt;/code&gt;.</source>
          <target state="translated">Эквивалентно &lt;code&gt;a.copy(order='K')&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4a8b0df6f8f30decfdb8712f593677bd0361c0ef" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;code&gt;divmod(x, 1)&lt;/code&gt; for positive &lt;code&gt;x&lt;/code&gt; with the return values switched.</source>
          <target state="translated">Эквивалентен &lt;code&gt;divmod(x, 1)&lt;/code&gt; для положительного &lt;code&gt;x&lt;/code&gt; с переключенными возвращаемыми значениями.</target>
        </trans-unit>
        <trans-unit id="3f28125a3d825d23c8591cf7b44d136f5206aec6" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;code&gt;m[::-1,...]&lt;/code&gt;. Does not require the array to be two-dimensional.</source>
          <target state="translated">Эквивалентно &lt;code&gt;m[::-1,...]&lt;/code&gt; . Не требует, чтобы массив был двумерным.</target>
        </trans-unit>
        <trans-unit id="158b7bdd2f113f05d23975a3a9ae7c4cbbee72c4" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;code&gt;np.asarray(self)&lt;/code&gt;.</source>
          <target state="translated">Эквивалентен &lt;code&gt;np.asarray(self)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7b757950b99b3fb5a49cac119260ff6b59afd089" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;code&gt;np.asarray(x).ravel()&lt;/code&gt;</source>
          <target state="translated">Эквивалентен &lt;code&gt;np.asarray(x).ravel()&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="01b942f822242874c950f31737a64908f9f10037" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;code&gt;np.sin(x)/np.cos(x)&lt;/code&gt; element-wise.</source>
          <target state="translated">&lt;code&gt;np.sin(x)/np.cos(x)&lt;/code&gt; эквивалентен np.sin (x) /np.cos (x) .</target>
        </trans-unit>
        <trans-unit id="e03e98ed258ef214f7093f680237951ada6cdb9f" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;code&gt;np.sinh(x)/np.cosh(x)&lt;/code&gt; or &lt;code&gt;-1j * np.tan(1j*x)&lt;/code&gt;.</source>
          <target state="translated">Эквивалентно &lt;code&gt;np.sinh(x)/np.cosh(x)&lt;/code&gt; или &lt;code&gt;-1j * np.tan(1j*x)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b6b5ff4ad03763736f9b2a4f6770ab65b1c73219" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;code&gt;np.transpose(self)&lt;/code&gt; if &lt;code&gt;self&lt;/code&gt; is real-valued.</source>
          <target state="translated">Эквивалентно &lt;code&gt;np.transpose(self)&lt;/code&gt; если &lt;code&gt;self&lt;/code&gt; имеет реальные значения.</target>
        </trans-unit>
        <trans-unit id="75b818defe3ad1876ebfb087b965f01d49fa2ec9" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;code&gt;sqrt(x1**2 + x2**2)&lt;/code&gt;, element-wise. If &lt;code&gt;x1&lt;/code&gt; or &lt;code&gt;x2&lt;/code&gt; is scalar_like (i.e., unambiguously cast-able to a scalar type), it is broadcast for use with each element of the other argument. (See Examples)</source>
          <target state="translated">Поэлементно эквивалентно &lt;code&gt;sqrt(x1**2 + x2**2)&lt;/code&gt; . Если &lt;code&gt;x1&lt;/code&gt; или &lt;code&gt;x2&lt;/code&gt; являются скалярными_подобными (т. Е. Однозначно допускают приведение к скалярному типу), они передаются для использования с каждым элементом другого аргумента. (См. Примеры)</target>
        </trans-unit>
        <trans-unit id="00df9c133fe8747499700e75effeb0cd5d136ccc" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;code&gt;x.copy()&lt;/code&gt;, but only defined for types that support arithmetic.</source>
          <target state="translated">Эквивалентен &lt;code&gt;x.copy()&lt;/code&gt; , но определен только для типов, поддерживающих арифметику.</target>
        </trans-unit>
        <trans-unit id="23adb20441299c90dbd1e383cfab76bf7d2274b8" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;code&gt;x1 - x2&lt;/code&gt; in terms of array broadcasting.</source>
          <target state="translated">Эквивалентен &lt;code&gt;x1 - x2&lt;/code&gt; с точки зрения широковещательной передачи массива.</target>
        </trans-unit>
        <trans-unit id="2c304ff74936613f3d12e0fc5cde4c506dd3f3ab" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;code&gt;x1&lt;/code&gt; * &lt;code&gt;x2&lt;/code&gt; in terms of array broadcasting.</source>
          <target state="translated">Эквивалентно &lt;code&gt;x1&lt;/code&gt; * &lt;code&gt;x2&lt;/code&gt; с точки зрения широковещательной передачи массива.</target>
        </trans-unit>
        <trans-unit id="98520850afe8056507d9d642ea9323b3ed72e130" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;code&gt;x1&lt;/code&gt; + &lt;code&gt;x2&lt;/code&gt; in terms of array broadcasting.</source>
          <target state="translated">Эквивалентен &lt;code&gt;x1&lt;/code&gt; + &lt;code&gt;x2&lt;/code&gt; с точки зрения широковещательной передачи массива.</target>
        </trans-unit>
        <trans-unit id="202bf1615636b8e0a84392691bc084a70b43390b" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;em&gt;self&lt;/em&gt;.put(&lt;em&gt;values&lt;/em&gt;, &lt;em&gt;indices&lt;/em&gt;, &lt;em&gt;clipmode&lt;/em&gt; ). Put &lt;em&gt;values&lt;/em&gt; into &lt;em&gt;self&lt;/em&gt; at the corresponding (flattened) &lt;em&gt;indices&lt;/em&gt;. If &lt;em&gt;values&lt;/em&gt; is too small it will be repeated as necessary.</source>
          <target state="translated">Эквивалентно &lt;em&gt;self&lt;/em&gt; .put ( &lt;em&gt;значения&lt;/em&gt; , &lt;em&gt;индексы&lt;/em&gt; , &lt;em&gt;режим клипа&lt;/em&gt; ). Поместите &lt;em&gt;значения&lt;/em&gt; в &lt;em&gt;self&lt;/em&gt; по соответствующим (сглаженным) &lt;em&gt;индексам&lt;/em&gt; . Если &lt;em&gt;значения&lt;/em&gt; слишком малы, он будет повторяться по мере необходимости.</target>
        </trans-unit>
        <trans-unit id="65d607762120cf690bb00c590b16fa127fb75062" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;em&gt;self&lt;/em&gt;.ravel(&lt;em&gt;order&lt;/em&gt;). Same basic functionality as &lt;a href=&quot;#c.PyArray_Flatten&quot;&gt;&lt;code&gt;PyArray_Flatten&lt;/code&gt;&lt;/a&gt; (&lt;em&gt;self&lt;/em&gt;, &lt;em&gt;order&lt;/em&gt;) except if &lt;em&gt;order&lt;/em&gt; is 0 and &lt;em&gt;self&lt;/em&gt; is C-style contiguous, the shape is altered but no copy is performed.</source>
          <target state="translated">Эквивалентно &lt;em&gt;self&lt;/em&gt; .ravel ( &lt;em&gt;заказ&lt;/em&gt; ). Те же базовые функции, что и &lt;a href=&quot;#c.PyArray_Flatten&quot;&gt; &lt;code&gt;PyArray_Flatten&lt;/code&gt; &lt;/a&gt; ( &lt;em&gt;self&lt;/em&gt; , &lt;em&gt;order&lt;/em&gt; ), за исключением случаев, когда &lt;em&gt;order&lt;/em&gt; равен 0, а &lt;em&gt;self&lt;/em&gt; является смежным в стиле C, форма изменяется, но копирование не выполняется.</target>
        </trans-unit>
        <trans-unit id="9032a6cc40438a50e150a4a41ff47d4fe89a4820" translate="yes" xml:space="preserve">
          <source>Equivalent to PyArray_CanCastTypeTo(fromtype, totype, NPY_SAFE_CASTING).</source>
          <target state="translated">Эквивалент PyArray_CanCastTypeTo(fromtype,totype,NPY_SAFE_CASTING).</target>
        </trans-unit>
        <trans-unit id="aa1dee2d3e2220598a3bbd05e1af8c95afb8286e" translate="yes" xml:space="preserve">
          <source>Equivalent to Python&amp;rsquo;s &lt;code&gt;%&lt;/code&gt; operator.</source>
          <target state="translated">Эквивалентно оператору &lt;code&gt;%&lt;/code&gt; Python .</target>
        </trans-unit>
        <trans-unit id="c543b869fe6bab79a3a934117c7c6a1eff863d6f" translate="yes" xml:space="preserve">
          <source>Equivalent to Python&amp;rsquo;s &lt;code&gt;//&lt;/code&gt; operator.</source>
          <target state="translated">Эквивалентно оператору &lt;code&gt;//&lt;/code&gt; Python .</target>
        </trans-unit>
        <trans-unit id="731025cc785b584c28e327dc6f1d60cad5cb1eb2" translate="yes" xml:space="preserve">
          <source>Equivalent to but faster than &lt;code&gt;np.maximum(a_min, np.minimum(a, a_max))&lt;/code&gt;. No check is performed to ensure &lt;code&gt;a_min &amp;lt; a_max&lt;/code&gt;.</source>
          <target state="translated">Эквивалентно, но быстрее, чем &lt;code&gt;np.maximum(a_min, np.minimum(a, a_max))&lt;/code&gt; . Проверка не выполняется, чтобы гарантировать, что &lt;code&gt;a_min &amp;lt; a_max&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e127cc159cef630175cb2a2528435fea3e7fcdb3" translate="yes" xml:space="preserve">
          <source>Equivalent to calling &lt;code&gt;$ nosetests &amp;lt;argv&amp;gt; &amp;lt;file_to_run&amp;gt;&lt;/code&gt; from the command line</source>
          <target state="translated">Эквивалентно вызову &lt;code&gt;$ nosetests &amp;lt;argv&amp;gt; &amp;lt;file_to_run&amp;gt;&lt;/code&gt; из командной строки</target>
        </trans-unit>
        <trans-unit id="5b847d0d31d2133c0201a061723b9aa92d8890f7" translate="yes" xml:space="preserve">
          <source>Equivalent to either NPY_INT or NPY_LONGLONG, depending on the platform.</source>
          <target state="translated">Эквивалент NPY_INT или NPY_LONGLONG,в зависимости от платформы.</target>
        </trans-unit>
        <trans-unit id="85f38ed4c0f6096936fc4b84fb6a21d19adcc1cb" translate="yes" xml:space="preserve">
          <source>Equivalent to either NPY_UINT or NPY_ULONGLONG, depending on the platform.</source>
          <target state="translated">Эквивалент NPY_UINT или NPY_ULONGLONG,в зависимости от платформы.</target>
        </trans-unit>
        <trans-unit id="d656dbe889cfc08e9f09fa23957b7de58cae8caa" translate="yes" xml:space="preserve">
          <source>Equivalent to m[:,::-1]. Requires the array to be at least 2-D.</source>
          <target state="translated">Эквивалент m[:,::-1].Требуется,чтобы массив был как минимум 2-D.</target>
        </trans-unit>
        <trans-unit id="5a910d755d7e89acbf27b19fb05f069771ab0e7b" translate="yes" xml:space="preserve">
          <source>Equivalent to the Python &lt;code&gt;%&lt;/code&gt; operator.</source>
          <target state="translated">Эквивалентно оператору Python &lt;code&gt;%&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d371f28bfea1e852f448381bb4f0bdfccaa7149e" translate="yes" xml:space="preserve">
          <source>Equivalent to:</source>
          <target state="translated">Эквивалентно:</target>
        </trans-unit>
        <trans-unit id="f2c299359dd358c2f6f22a22ce8b45b901e994e8" translate="yes" xml:space="preserve">
          <source>Equivalently use the &lt;a href=&quot;../maskedarray.baseclass#numpy.ma.MaskedArray&quot;&gt;&lt;code&gt;MaskedArray&lt;/code&gt;&lt;/a&gt;&lt;code&gt;mask&lt;/code&gt; attribute.</source>
          <target state="translated">Эквивалентно используйте &lt;a href=&quot;../maskedarray.baseclass#numpy.ma.MaskedArray&quot;&gt; &lt;code&gt;MaskedArray&lt;/code&gt; &lt;/a&gt; &lt;code&gt;mask&lt;/code&gt; MaskedArray .</target>
        </trans-unit>
        <trans-unit id="6eed85d2c6463174f53200b994de55fedca2fe50" translate="yes" xml:space="preserve">
          <source>Equivalently use the &lt;code&gt;MaskedArray&lt;/code&gt;&lt;code&gt;data&lt;/code&gt; attribute.</source>
          <target state="translated">&lt;code&gt;MaskedArray&lt;/code&gt; используйте атрибут &lt;code&gt;data&lt;/code&gt; MaskedArray .</target>
        </trans-unit>
        <trans-unit id="e59ba61683ec6d73dab0ba426c13a6a7d9ed31cf" translate="yes" xml:space="preserve">
          <source>Equivalently, eliminating the inner loop, the last two lines would be:</source>
          <target state="translated">Эквивалентно,устраняя внутреннюю петлю,последние две линии были бы:</target>
        </trans-unit>
        <trans-unit id="6b59734e1b8f67d36df303549c4673ff4f6c8d66" translate="yes" xml:space="preserve">
          <source>Equivalently, eliminating the inner loop, this can be expressed as:</source>
          <target state="translated">Эквивалентно,устраняя внутренний цикл,это можно выразить так:</target>
        </trans-unit>
        <trans-unit id="28b75128748a47d2bb367541f76250db5dd9b6a0" translate="yes" xml:space="preserve">
          <source>Equivalently:</source>
          <target state="translated">Equivalently:</target>
        </trans-unit>
        <trans-unit id="73631d7f0356fdbdeaa36f8e5dbad89c6aa15dc4" translate="yes" xml:space="preserve">
          <source>Error handling</source>
          <target state="translated">обработка ошибок</target>
        </trans-unit>
        <trans-unit id="5f577c8bef8739558c43df8e8796bc8e5a825a61" translate="yes" xml:space="preserve">
          <source>Error objects</source>
          <target state="translated">Ошибки объектов</target>
        </trans-unit>
        <trans-unit id="4884820cd63fe6870fd18f5bb40f96cacf7c1253" translate="yes" xml:space="preserve">
          <source>Errors result if the second argument is also supplied when x is a scalar input, if first and second arguments have different shapes, or if the first argument has complex values</source>
          <target state="translated">Ошибки возникают,если второй аргумент также передан,когда x является скалярным входом,если первый и второй аргументы имеют разную форму,или если первый аргумент имеет сложные значения</target>
        </trans-unit>
        <trans-unit id="68e944c31c80a964e18589df952c8e941c618fb2" translate="yes" xml:space="preserve">
          <source>Errors result if the second argument is also supplied when x is a scalar input, if first and second arguments have different shapes, or if the first argument has complex values.</source>
          <target state="translated">Ошибки возникают,если второй аргумент также поставляется,когда x является скалярным входом,если первый и второй аргументы имеют разную форму,или если первый аргумент имеет сложные значения.</target>
        </trans-unit>
        <trans-unit id="6896dc5d66baa055255d6a61e0f3010c1fcb944f" translate="yes" xml:space="preserve">
          <source>Errors result if the second argument is supplied when the first argument is a scalar, or if the first and second arguments have different shapes.</source>
          <target state="translated">Ошибки возникают,если второй аргумент передан,когда первый аргумент является скаляром,или если первый и второй аргументы имеют разную форму.</target>
        </trans-unit>
        <trans-unit id="8e5c90765bd01e407f47b56e1714c9f9bd1ace4b" translate="yes" xml:space="preserve">
          <source>Estimate a covariance matrix, given data and weights.</source>
          <target state="translated">Оцените ковариационную матрицу,заданные данные и веса.</target>
        </trans-unit>
        <trans-unit id="3ff0c8c72ff670edbc5bdbae93aa2dbd2e54c4c0" translate="yes" xml:space="preserve">
          <source>Estimate the covariance matrix.</source>
          <target state="translated">Оцените ковариационную матрицу.</target>
        </trans-unit>
        <trans-unit id="2e86acb34f53f4c550f3dcf28b42823f0f59d900" translate="yes" xml:space="preserve">
          <source>Estimator based on leave-one-out cross-validation estimate of the integrated squared error. Can be regarded as a generalization of Scott&amp;rsquo;s rule.</source>
          <target state="translated">Оценщик, основанный на перекрестной проверке единичного исключения интегрированной квадратичной ошибки. Можно рассматривать как обобщение правила Скотта.</target>
        </trans-unit>
        <trans-unit id="35592e888d12a9934594d9f1f111830a7b9f7f37" translate="yes" xml:space="preserve">
          <source>Estimator does not take variability into account, only data size. Commonly overestimates number of bins required.</source>
          <target state="translated">Оценщик не учитывает вариабельность,а только размер данных.Обычно завышает количество требуемых бункеров.</target>
        </trans-unit>
        <trans-unit id="da87f1093e8c246b1f6d85fea3650000b6da3790" translate="yes" xml:space="preserve">
          <source>Euler&amp;rsquo;s constant, base of natural logarithms, Napier&amp;rsquo;s constant.</source>
          <target state="translated">Константа Эйлера, основание натурального логарифма, постоянная Напье.</target>
        </trans-unit>
        <trans-unit id="f91dd3dbbfae685abb68bc410da02d957a011629" translate="yes" xml:space="preserve">
          <source>Evaluate a 2-D Chebyshev series at points (x, y).</source>
          <target state="translated">Оценить двухмерную чебышевскую серию в точках (x,y).</target>
        </trans-unit>
        <trans-unit id="e05e0d192839700194b0291808ce8475fe0d0cc1" translate="yes" xml:space="preserve">
          <source>Evaluate a 2-D Chebyshev series on the Cartesian product of x and y.</source>
          <target state="translated">Оценить двухмерную чебышевскую серию по декартовому продукту x и y.</target>
        </trans-unit>
        <trans-unit id="7249c2fe23f2e17738db2110e9c2474dc3a27187" translate="yes" xml:space="preserve">
          <source>Evaluate a 2-D Hermite series at points (x, y).</source>
          <target state="translated">Оцените 2-D серии &quot;Эрмита&quot; в точках (x,y).</target>
        </trans-unit>
        <trans-unit id="12ed956c99b6390def2dd7ee918ef9474cc02f06" translate="yes" xml:space="preserve">
          <source>Evaluate a 2-D Hermite series on the Cartesian product of x and y.</source>
          <target state="translated">Оценить двухмерную эрмитажную серию на декартовом изделии x и y.</target>
        </trans-unit>
        <trans-unit id="cedce799e74482d1942c64f4cd11a5b3fd98c128" translate="yes" xml:space="preserve">
          <source>Evaluate a 2-D HermiteE series at points (x, y).</source>
          <target state="translated">Оцените 2-D серии HermiteE в точках (x,y).</target>
        </trans-unit>
        <trans-unit id="48cc948294af1d7f259543794e3f125d854efce7" translate="yes" xml:space="preserve">
          <source>Evaluate a 2-D HermiteE series on the Cartesian product of x and y.</source>
          <target state="translated">Оцените 2-мерную серию HermiteE на декартовом изделии x и y.</target>
        </trans-unit>
        <trans-unit id="338d5b747397dce60dd29055f57344efa1d37666" translate="yes" xml:space="preserve">
          <source>Evaluate a 2-D Laguerre series at points (x, y).</source>
          <target state="translated">Оцените двухмерную серию Лагер в точках (x,y).</target>
        </trans-unit>
        <trans-unit id="4a829f126487a9ec9a923ab666b31db182581736" translate="yes" xml:space="preserve">
          <source>Evaluate a 2-D Laguerre series on the Cartesian product of x and y.</source>
          <target state="translated">Оцените серию 2-D Laguerre на декартовом изделии x и y.</target>
        </trans-unit>
        <trans-unit id="bb447e6da0b73bad544e19cbcbc6052261416eb9" translate="yes" xml:space="preserve">
          <source>Evaluate a 2-D Legendre series at points (x, y).</source>
          <target state="translated">Оцените двухмерную серию Legendre в точках (x,y).</target>
        </trans-unit>
        <trans-unit id="7373a9e22eb3236ef35b254cc0cb7ed7d29c6948" translate="yes" xml:space="preserve">
          <source>Evaluate a 2-D Legendre series on the Cartesian product of x and y.</source>
          <target state="translated">Оцените двухмерную серию Legendre на декартовом изделии x и y.</target>
        </trans-unit>
        <trans-unit id="a527503bfcf8c4cb30f6f6943d6775ba7732cdef" translate="yes" xml:space="preserve">
          <source>Evaluate a 2-D polynomial at points (x, y).</source>
          <target state="translated">Оцените двухмерный полином в точках (x,y).</target>
        </trans-unit>
        <trans-unit id="03726da2d6f02abab8a254ba40a2a300ecaef683" translate="yes" xml:space="preserve">
          <source>Evaluate a 2-D polynomial on the Cartesian product of x and y.</source>
          <target state="translated">Оцените двухмерный полином на декартовом продукте x и y.</target>
        </trans-unit>
        <trans-unit id="9029d2c825f46990756a36847b1a1b6ef93e7f31" translate="yes" xml:space="preserve">
          <source>Evaluate a 3-D Chebyshev series at points (x, y, z).</source>
          <target state="translated">Оценить трехмерный чебышевский ряд в точках (x,y,z).</target>
        </trans-unit>
        <trans-unit id="6e0bda3c65d8c3458e685987ef115c2f03e1ce48" translate="yes" xml:space="preserve">
          <source>Evaluate a 3-D Chebyshev series on the Cartesian product of x, y, and z.</source>
          <target state="translated">Оценить трехмерную чебышевскую серию по декартовому изделию x,y и z.</target>
        </trans-unit>
        <trans-unit id="ae23b9ad402238d53a7767ef4d1d0feecad8d46a" translate="yes" xml:space="preserve">
          <source>Evaluate a 3-D Hermite series at points (x, y, z).</source>
          <target state="translated">Оцените 3-D ряд &quot;Эрмита&quot; в точках (x,y,z).</target>
        </trans-unit>
        <trans-unit id="1fa86ea2fa2a78cb282ebd3e58571d4035e81572" translate="yes" xml:space="preserve">
          <source>Evaluate a 3-D Hermite series on the Cartesian product of x, y, and z.</source>
          <target state="translated">Оценить трехмерную серию &quot;Эрмита&quot; на декартовом изделии x,y и z.</target>
        </trans-unit>
        <trans-unit id="e0e36a6aa699aa19c71e1fd7089481c08a161992" translate="yes" xml:space="preserve">
          <source>Evaluate a 3-D HermiteE series on the Cartesian product of x, y, and z.</source>
          <target state="translated">Оцените 3-D серию HermiteE на декартовом изделии x,y и z.</target>
        </trans-unit>
        <trans-unit id="645e8b8ce98d2275a7fb6f40acce5d53b7f2ad81" translate="yes" xml:space="preserve">
          <source>Evaluate a 3-D Hermite_e series at points (x, y, z).</source>
          <target state="translated">Оценить 3-D ряд Hermite_e в точках (x,y,z).</target>
        </trans-unit>
        <trans-unit id="ea580f96650cb24e9fc6eb589c30aba361084e3d" translate="yes" xml:space="preserve">
          <source>Evaluate a 3-D Laguerre series at points (x, y, z).</source>
          <target state="translated">Оцените трехмерную серию Лагер в точках (x,y,z).</target>
        </trans-unit>
        <trans-unit id="345ed8afbed95aea3201f6d8df2e9d955fe4ee9d" translate="yes" xml:space="preserve">
          <source>Evaluate a 3-D Laguerre series on the Cartesian product of x, y, and z.</source>
          <target state="translated">Оцените серию 3-D Laguerre на декартовом изделии x,y и z.</target>
        </trans-unit>
        <trans-unit id="fc1af478b3c58299201cb5fd893a359ec10739ca" translate="yes" xml:space="preserve">
          <source>Evaluate a 3-D Legendre series at points (x, y, z).</source>
          <target state="translated">Оцените трехмерную серию Легенды в точках (x,y,z).</target>
        </trans-unit>
        <trans-unit id="888774bb82f3f8de5edab168d25dbd0a2eb3d033" translate="yes" xml:space="preserve">
          <source>Evaluate a 3-D Legendre series on the Cartesian product of x, y, and z.</source>
          <target state="translated">Оцените трехмерную серию Legendre на декартовом изделии x,y и z.</target>
        </trans-unit>
        <trans-unit id="e8846df08e194f124fe8cded1c782376715e8f39" translate="yes" xml:space="preserve">
          <source>Evaluate a 3-D polynomial at points (x, y, z).</source>
          <target state="translated">Оцените трехмерный полином в точках (x,y,z).</target>
        </trans-unit>
        <trans-unit id="33f78fc3c5ae1454f9df0431d3f3fda38023ac26" translate="yes" xml:space="preserve">
          <source>Evaluate a 3-D polynomial on the Cartesian product of x, y and z.</source>
          <target state="translated">Оцените трехмерный полином на декартовом продукте x,y и z.</target>
        </trans-unit>
        <trans-unit id="8b4e7acfc43ebffbd9c6285f10ac1b60b175795c" translate="yes" xml:space="preserve">
          <source>Evaluate a Chebyshev series at points x.</source>
          <target state="translated">Оценить чебышевскую серию в точках x.</target>
        </trans-unit>
        <trans-unit id="1f4ce01843c1515b967b600cb8fa4018d3436eaa" translate="yes" xml:space="preserve">
          <source>Evaluate a Laguerre series at points x.</source>
          <target state="translated">Оцените серию Лагер в точках x.</target>
        </trans-unit>
        <trans-unit id="161f6a7aae0d5d7f196e5ee0e04ba73d7963b76b" translate="yes" xml:space="preserve">
          <source>Evaluate a Legendre series at points x.</source>
          <target state="translated">Оцените серию Легенды в точках x.</target>
        </trans-unit>
        <trans-unit id="1cc49d22e70eea61f6bdc96018100e105aba00e0" translate="yes" xml:space="preserve">
          <source>Evaluate a piecewise-defined function.</source>
          <target state="translated">Оцените функцию,определяемую по частям.</target>
        </trans-unit>
        <trans-unit id="79a283e785c7b9ab6cbfe6dbfe59b713502d0afb" translate="yes" xml:space="preserve">
          <source>Evaluate a polynomial at points x.</source>
          <target state="translated">Оцените полином в точках x.</target>
        </trans-unit>
        <trans-unit id="ac86c84a106ffc30d8eceed0ff68761b61ebad9a" translate="yes" xml:space="preserve">
          <source>Evaluate a polynomial at specific values.</source>
          <target state="translated">Оцените полином при определенных значениях.</target>
        </trans-unit>
        <trans-unit id="283714fe4f49f84ab071c16c98a04aac5c0eb13d" translate="yes" xml:space="preserve">
          <source>Evaluate a polynomial specified by its roots at points x.</source>
          <target state="translated">Оценить многочлен,заданный его корнями в точках x.</target>
        </trans-unit>
        <trans-unit id="5ae76cb25d3ddcb8fd7f5add4137cfe2c33287a6" translate="yes" xml:space="preserve">
          <source>Evaluate an Hermite series at points x.</source>
          <target state="translated">Оцените серию &quot;Эрмита&quot; в точках x.</target>
        </trans-unit>
        <trans-unit id="ce1ba49b7053d6908dd1d4b7a38524a5c4ffc2df" translate="yes" xml:space="preserve">
          <source>Evaluate an HermiteE series at points x.</source>
          <target state="translated">Оцените серию HermiteE в точках x.</target>
        </trans-unit>
        <trans-unit id="a389fe7d0ca7745a323c209ce5b023a9e30716fa" translate="yes" xml:space="preserve">
          <source>Evaluate the polynomial at</source>
          <target state="translated">Оцените полиноминал на</target>
        </trans-unit>
        <trans-unit id="201867eba810e127d20356b4920cc833601a5f27" translate="yes" xml:space="preserve">
          <source>Evaluates TRUE as long as the iterator has not looped through all of the elements, otherwise it evaluates FALSE.</source>
          <target state="translated">Оценивает TRUE до тех пор,пока итератор не пройдет через все элементы,в противном случае он оценивает FALSE.</target>
        </trans-unit>
        <trans-unit id="a61e7944eeb541b39ec48ef4572671aa9245dfe1" translate="yes" xml:space="preserve">
          <source>Evaluates TRUE as long as the multi-iterator has not looped through all of the elements (of the broadcasted result), otherwise it evaluates FALSE.</source>
          <target state="translated">Оценивает TRUE до тех пор,пока мультилитератор не пройдет через все элементы (транслируемый результат),в противном случае он оценивает FALSE.</target>
        </trans-unit>
        <trans-unit id="22e5fc7652637561dc1ca3671ce7888c08020803" translate="yes" xml:space="preserve">
          <source>Evaluates a Chebyshev series.</source>
          <target state="translated">Оценивает чебышевскую серию.</target>
        </trans-unit>
        <trans-unit id="8f5b426162065bbed8197ac088255c41cba4b070" translate="yes" xml:space="preserve">
          <source>Evaluates a Hermite series.</source>
          <target state="translated">Оценивает серию &quot;Эрмита&quot;.</target>
        </trans-unit>
        <trans-unit id="df7f15c01da2df8b851fc9f6e1e067fbbad7da62" translate="yes" xml:space="preserve">
          <source>Evaluates a Laguerre series.</source>
          <target state="translated">Оценивает серию Лагер.</target>
        </trans-unit>
        <trans-unit id="24200a16cfb4d36b211f0c64c8db3868f1aa7d7b" translate="yes" xml:space="preserve">
          <source>Evaluates a Legendre series.</source>
          <target state="translated">Оценивает серию &quot;Легенда&quot;.</target>
        </trans-unit>
        <trans-unit id="85ee46dc575694a88add8fcac6da5ac9ea0ec2c1" translate="yes" xml:space="preserve">
          <source>Evaluates a polynomial.</source>
          <target state="translated">Оценивает полиноминал.</target>
        </trans-unit>
        <trans-unit id="c6780dad55d1f852632365f7570aa643328d5b06" translate="yes" xml:space="preserve">
          <source>Evaluates as True if arrays &lt;em&gt;a1&lt;/em&gt; and &lt;em&gt;a2&lt;/em&gt; have the same shape.</source>
          <target state="translated">Вычисляется как Истина, если массивы &lt;em&gt;a1&lt;/em&gt; и &lt;em&gt;a2&lt;/em&gt; имеют одинаковую форму.</target>
        </trans-unit>
        <trans-unit id="14b73bad8268092556c3d59c6262a1db866e29f2" translate="yes" xml:space="preserve">
          <source>Evaluates as true if &lt;code&gt;a&lt;/code&gt; is FORTRAN ordered.</source>
          <target state="translated">Оценивается как истина, если &lt;code&gt;a&lt;/code&gt; заказан на FORTRAN.</target>
        </trans-unit>
        <trans-unit id="74face1b8e76f520379a33453af827275b42370d" translate="yes" xml:space="preserve">
          <source>Evaluates as true if &lt;code&gt;a&lt;/code&gt; is a contiguous array. Equivalent to &lt;code&gt;(PyArray_ISCONTIGUOUS(a))&lt;/code&gt;.</source>
          <target state="translated">Оценивает как верно , если представляет собой непрерывный массив. Эквивалентен &lt;code&gt;(PyArray_ISCONTIGUOUS(a))&lt;/code&gt; . &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="6a92de714017736a8a012563cdae53ed5c18d733" translate="yes" xml:space="preserve">
          <source>Evaluates as true if &lt;code&gt;a&lt;/code&gt; is non-&lt;code&gt;NULL&lt;/code&gt; and can be cast to a &lt;code&gt;PyArrayObject*&lt;/code&gt;.</source>
          <target state="translated">Вычисляет как истину, если &lt;code&gt;a&lt;/code&gt; не &lt;code&gt;NULL&lt;/code&gt; и может быть приведено к &lt;code&gt;PyArrayObject*&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="30b857f72fdd592a4e93e214be9f6a2a22f1daa5" translate="yes" xml:space="preserve">
          <source>Evaluates as true if &lt;em&gt;obj&lt;/em&gt; is a data-type object ( &lt;a href=&quot;c-api.types-and-structures#c.PyArray_Descr&quot;&gt;&lt;code&gt;PyArray_Descr *&lt;/code&gt;&lt;/a&gt; ).</source>
          <target state="translated">Оценивается как истина, если &lt;em&gt;obj&lt;/em&gt; является объектом типа данных ( &lt;a href=&quot;c-api.types-and-structures#c.PyArray_Descr&quot;&gt; &lt;code&gt;PyArray_Descr *&lt;/code&gt; &lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="01d60164442fc0f55a5557baa1dde2ec4ee3a192" translate="yes" xml:space="preserve">
          <source>Evaluates as true if the data buffer of &lt;code&gt;a&lt;/code&gt; uses native byte order. Equivalent to &lt;code&gt;(PyArray_ISNOTSWAPPED(a))&lt;/code&gt;.</source>
          <target state="translated">Оценивает , как верно , если данные буфера в &lt;code&gt;a&lt;/code&gt; использования родной порядок байтов. Эквивалентен &lt;code&gt;(PyArray_ISNOTSWAPPED(a))&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="88a80c85f7d09b073fbd515eb093798e576dcd94" translate="yes" xml:space="preserve">
          <source>Evaluates the Einstein summation convention on the operands.</source>
          <target state="translated">Оценивает итоговый съезд Эйнштейна по оперным спектаклям.</target>
        </trans-unit>
        <trans-unit id="09f56994a692d463245ca900188d259358a1a1e3" translate="yes" xml:space="preserve">
          <source>Evaluates the lowest cost contraction order for an einsum expression by considering the creation of intermediate arrays.</source>
          <target state="translated">Оценивает наименьший стоимостной порядок сжатия для выражения инсума,рассматривая создание промежуточных массивов.</target>
        </trans-unit>
        <trans-unit id="a4fdb9cdb108616be69434eab1761cc78b88d33b" translate="yes" xml:space="preserve">
          <source>Evaluates to a pointer of type &lt;code&gt;void*&lt;/code&gt; that points to the data buffer of &lt;code&gt;a&lt;/code&gt;, assuming &lt;code&gt;a&lt;/code&gt; can be cast to a &lt;code&gt;PyArrayObject*&lt;/code&gt;.</source>
          <target state="translated">Вычисляет указатель типа &lt;code&gt;void*&lt;/code&gt; который указывает на буфер данных объекта &lt;code&gt;a&lt;/code&gt; , предполагая, что &lt;code&gt;a&lt;/code&gt; может быть приведено к &lt;code&gt;PyArrayObject*&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5b165cdcba7dabc88d6d0700bab2cea35959b8e6" translate="yes" xml:space="preserve">
          <source>Evaluates to an array of type &lt;code&gt;npy_intp&lt;/code&gt; and length &lt;code&gt;array_numdims(a)&lt;/code&gt;, giving the lengths of all of the dimensions of &lt;code&gt;a&lt;/code&gt;, assuming &lt;code&gt;a&lt;/code&gt; can be cast to a &lt;code&gt;PyArrayObject*&lt;/code&gt;.</source>
          <target state="translated">Вычисляет массив типа &lt;code&gt;npy_intp&lt;/code&gt; и length &lt;code&gt;array_numdims(a)&lt;/code&gt; , давая длины всех измерений &lt;code&gt;a&lt;/code&gt; , предполагая, что &lt;code&gt;a&lt;/code&gt; может быть &lt;code&gt;PyArrayObject*&lt;/code&gt; в PyArrayObject * .</target>
        </trans-unit>
        <trans-unit id="4d18aba4418a76811df39bd817fcca0ecc3daf26" translate="yes" xml:space="preserve">
          <source>Evaluates to an array of type &lt;code&gt;npy_intp&lt;/code&gt; and length &lt;code&gt;array_numdims(a)&lt;/code&gt;, giving the stridess of all of the dimensions of &lt;code&gt;a&lt;/code&gt;, assuming &lt;code&gt;a&lt;/code&gt; can be cast to a &lt;code&gt;PyArrayObject*&lt;/code&gt;. A stride is the distance in bytes between an element and its immediate neighbor along the same axis.</source>
          <target state="translated">Вычисляет массив типа &lt;code&gt;npy_intp&lt;/code&gt; и длины &lt;code&gt;array_numdims(a)&lt;/code&gt; , давая последовательность всех измерений &lt;code&gt;a&lt;/code&gt; , предполагая, что &lt;code&gt;a&lt;/code&gt; может быть приведено к &lt;code&gt;PyArrayObject*&lt;/code&gt; . Шаг - это расстояние в байтах между элементом и его ближайшим соседом по той же оси.</target>
        </trans-unit>
        <trans-unit id="ee0a95426dfe5b7eb47ffd5ae2f4fb51edb35193" translate="yes" xml:space="preserve">
          <source>Evaluates to the &lt;code&gt;i&lt;/code&gt;-th dimension size of &lt;code&gt;a&lt;/code&gt;, assuming &lt;code&gt;a&lt;/code&gt; can be cast to a &lt;code&gt;PyArrayObject*&lt;/code&gt;.</source>
          <target state="translated">Вычисляет размер &lt;code&gt;i&lt;/code&gt; -го измерения &lt;code&gt;a&lt;/code&gt; , предполагая, что &lt;code&gt;a&lt;/code&gt; может быть приведено к &lt;code&gt;PyArrayObject*&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5d4d289826f9e7f76dff23ce9b5a0d1ae92ad3cc" translate="yes" xml:space="preserve">
          <source>Evaluates to the &lt;code&gt;i&lt;/code&gt;-th stride of &lt;code&gt;a&lt;/code&gt;, assuming &lt;code&gt;a&lt;/code&gt; can be cast to a &lt;code&gt;PyArrayObject*&lt;/code&gt;.</source>
          <target state="translated">Вычисляет &lt;code&gt;i&lt;/code&gt; -й шаг &lt;code&gt;a&lt;/code&gt; , предполагая, что &lt;code&gt;a&lt;/code&gt; может быть приведено к &lt;code&gt;PyArrayObject*&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="32b35e339f75424281676b07ad9e28b079acb58f" translate="yes" xml:space="preserve">
          <source>Evaluates to the integer data type code of &lt;code&gt;a&lt;/code&gt;, assuming &lt;code&gt;a&lt;/code&gt; can be cast to a &lt;code&gt;PyArrayObject*&lt;/code&gt;.</source>
          <target state="translated">Вычисляет код целочисленного типа данных &lt;code&gt;a&lt;/code&gt; , предполагая, что &lt;code&gt;a&lt;/code&gt; может быть приведен к &lt;code&gt;PyArrayObject*&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="60ab5981a7770a6202629fec1405f5cf8e6b68cf" translate="yes" xml:space="preserve">
          <source>Evaluates to the integer number of dimensions of &lt;code&gt;a&lt;/code&gt;, assuming &lt;code&gt;a&lt;/code&gt; can be cast to a &lt;code&gt;PyArrayObject*&lt;/code&gt;.</source>
          <target state="translated">Вычисляет целое число измерений &lt;code&gt;a&lt;/code&gt; , предполагая, что &lt;code&gt;a&lt;/code&gt; может быть приведено к &lt;code&gt;PyArrayObject*&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0be0f4e7a59afdff5acbdbf74f20f94ceb3fdc16" translate="yes" xml:space="preserve">
          <source>Evaluates true if &lt;em&gt;arr&lt;/em&gt; is C-style contiguous.</source>
          <target state="translated">Возвращает истину, если &lt;em&gt;arr&lt;/em&gt; является смежным в стиле C.</target>
        </trans-unit>
        <trans-unit id="ccd3cb113f37e222d005c24c43bbeb4bb385e088" translate="yes" xml:space="preserve">
          <source>Evaluates true if &lt;em&gt;arr&lt;/em&gt; is Fortran-style contiguous and &lt;em&gt;not&lt;/em&gt; C-style contiguous. &lt;a href=&quot;#c.PyArray_IS_F_CONTIGUOUS&quot;&gt;&lt;code&gt;PyArray_IS_F_CONTIGUOUS&lt;/code&gt;&lt;/a&gt; is the correct way to test for Fortran-style contiguity.</source>
          <target state="translated">Возвращает истину, если &lt;em&gt;arr&lt;/em&gt; является смежным в стиле Фортрана, а &lt;em&gt;не в&lt;/em&gt; стиле C. &lt;a href=&quot;#c.PyArray_IS_F_CONTIGUOUS&quot;&gt; &lt;code&gt;PyArray_IS_F_CONTIGUOUS&lt;/code&gt; &lt;/a&gt; - это правильный способ проверки смежности в стиле Fortran.</target>
        </trans-unit>
        <trans-unit id="299ed12a95038cc7c47da499ceb2b1bb9bee7088" translate="yes" xml:space="preserve">
          <source>Evaluates true if &lt;em&gt;arr&lt;/em&gt; is Fortran-style contiguous.</source>
          <target state="translated">Возвращает истину, если &lt;em&gt;arr&lt;/em&gt; является смежным в стиле Фортрана.</target>
        </trans-unit>
        <trans-unit id="0c6d7ddd3ec484ead393ec310ff7dd53898345cc" translate="yes" xml:space="preserve">
          <source>Evaluates true if &lt;em&gt;op&lt;/em&gt; is a Python object whose type is a sub-type of &lt;a href=&quot;c-api.types-and-structures#c.PyArray_Type&quot;&gt;&lt;code&gt;PyArray_Type&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Вычисляет истину, если &lt;em&gt;op&lt;/em&gt; является объектом Python, тип которого является &lt;a href=&quot;c-api.types-and-structures#c.PyArray_Type&quot;&gt; &lt;code&gt;PyArray_Type&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="eda799e9981a95fbdf277bb7b4cac9dbe1897388" translate="yes" xml:space="preserve">
          <source>Evaluates true if &lt;em&gt;op&lt;/em&gt; is a Python object with type &lt;a href=&quot;c-api.types-and-structures#c.PyArray_Type&quot;&gt;&lt;code&gt;PyArray_Type&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Вычисляет истину, если &lt;em&gt;op&lt;/em&gt; является объектом Python с типом &lt;a href=&quot;c-api.types-and-structures#c.PyArray_Type&quot;&gt; &lt;code&gt;PyArray_Type&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="6eeb9c0e570ee6c3d7212996fe6c19be5c590a98" translate="yes" xml:space="preserve">
          <source>Evaluates true if &lt;em&gt;op&lt;/em&gt; is a Python scalar object (see &lt;a href=&quot;#c.PyArray_IsPythonScalar&quot;&gt;&lt;code&gt;PyArray_IsPythonScalar&lt;/code&gt;&lt;/a&gt;), an array scalar (an instance of a sub-type of &lt;code&gt;PyGenericArr_Type&lt;/code&gt;) or an instance of a sub-type of &lt;a href=&quot;c-api.types-and-structures#c.PyArray_Type&quot;&gt;&lt;code&gt;PyArray_Type&lt;/code&gt;&lt;/a&gt; whose dimensionality is 0.</source>
          <target state="translated">Вычисляет истину, если &lt;em&gt;op&lt;/em&gt; является скалярным объектом Python (см. &lt;a href=&quot;#c.PyArray_IsPythonScalar&quot;&gt; &lt;code&gt;PyArray_IsPythonScalar&lt;/code&gt; &lt;/a&gt; ), скаляром массива (экземпляром &lt;code&gt;PyGenericArr_Type&lt;/code&gt; ) или экземпляром &lt;a href=&quot;c-api.types-and-structures#c.PyArray_Type&quot;&gt; &lt;code&gt;PyArray_Type&lt;/code&gt; &lt;/a&gt; , размерность которого равна 0.</target>
        </trans-unit>
        <trans-unit id="782aad878c58725282c24466a66a6d37025e0309" translate="yes" xml:space="preserve">
          <source>Evaluates true if &lt;em&gt;op&lt;/em&gt; is a builtin Python scalar object (int, float, complex, str, unicode, long, bool).</source>
          <target state="translated">Вычисляет истину, если &lt;em&gt;op&lt;/em&gt; является встроенным скалярным объектом Python (int, float, complex, str, unicode, long, bool).</target>
        </trans-unit>
        <trans-unit id="f7b432815e26220931657feceb0900b1d3b25457" translate="yes" xml:space="preserve">
          <source>Evaluates true if &lt;em&gt;op&lt;/em&gt; is an array iterator (or instance of a subclass of the array iterator type).</source>
          <target state="translated">Вычисляет истину, если &lt;em&gt;op&lt;/em&gt; является итератором массива (или экземпляром подкласса типа итератора массива).</target>
        </trans-unit>
        <trans-unit id="72e9df6c71cba94b804e10a331ae768c03dc3136" translate="yes" xml:space="preserve">
          <source>Evaluates true if &lt;em&gt;op&lt;/em&gt; is an instance of (a subclass of) &lt;a href=&quot;c-api.types-and-structures#c.PyArray_Type&quot;&gt;&lt;code&gt;PyArray_Type&lt;/code&gt;&lt;/a&gt; and has 0 dimensions.</source>
          <target state="translated">Вычисляет истину, если &lt;em&gt;op&lt;/em&gt; является экземпляром (подклассом) &lt;a href=&quot;c-api.types-and-structures#c.PyArray_Type&quot;&gt; &lt;code&gt;PyArray_Type&lt;/code&gt; &lt;/a&gt; и имеет 0 измерений.</target>
        </trans-unit>
        <trans-unit id="5906e8dd00d0a1adb4ea6aa8b5091429c7f25bb2" translate="yes" xml:space="preserve">
          <source>Evaluates true if &lt;em&gt;op&lt;/em&gt; is an instance of &lt;code&gt;Py{cls}ArrType_Type&lt;/code&gt;.</source>
          <target state="translated">Вычисляет истину, если &lt;em&gt;op&lt;/em&gt; является экземпляром &lt;code&gt;Py{cls}ArrType_Type&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4fb6fa662c78b1650cad28ec8017fe594278de63" translate="yes" xml:space="preserve">
          <source>Evaluates true if &lt;em&gt;op&lt;/em&gt; is an instance of a builtin numeric type (int, float, complex, long, bool)</source>
          <target state="translated">Вычисляет истину, если &lt;em&gt;op&lt;/em&gt; является экземпляром встроенного числового типа (int, float, complex, long, bool)</target>
        </trans-unit>
        <trans-unit id="ab21393a2ba887799bdff9d28c50be01d0b70f5b" translate="yes" xml:space="preserve">
          <source>Evaluates true if &lt;em&gt;op&lt;/em&gt; is either a Python scalar object (see &lt;a href=&quot;#c.PyArray_IsPythonScalar&quot;&gt;&lt;code&gt;PyArray_IsPythonScalar&lt;/code&gt;&lt;/a&gt;) or an array scalar (an instance of a sub- type of &lt;code&gt;PyGenericArr_Type&lt;/code&gt; ).</source>
          <target state="translated">Вычисляет истину, если &lt;em&gt;op&lt;/em&gt; является либо скалярным объектом Python (см. &lt;a href=&quot;#c.PyArray_IsPythonScalar&quot;&gt; &lt;code&gt;PyArray_IsPythonScalar&lt;/code&gt; &lt;/a&gt; ), либо скаляром массива (экземпляром &lt;code&gt;PyGenericArr_Type&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="cf7b1413b57bbc99790ccf42c73ff86cedf1427a" translate="yes" xml:space="preserve">
          <source>Evaluates true if &lt;em&gt;op&lt;/em&gt; is either an array scalar (an instance of a sub-type of &lt;code&gt;PyGenericArr_Type&lt;/code&gt; ), or an instance of (a sub-class of) &lt;a href=&quot;c-api.types-and-structures#c.PyArray_Type&quot;&gt;&lt;code&gt;PyArray_Type&lt;/code&gt;&lt;/a&gt; whose dimensionality is 0.</source>
          <target state="translated">Вычисляет истину, если &lt;em&gt;op&lt;/em&gt; является либо скаляром массива (экземпляр &lt;code&gt;PyGenericArr_Type&lt;/code&gt; ), либо экземпляром (подклассом) &lt;a href=&quot;c-api.types-and-structures#c.PyArray_Type&quot;&gt; &lt;code&gt;PyArray_Type&lt;/code&gt; &lt;/a&gt; , размерность которого равна 0.</target>
        </trans-unit>
        <trans-unit id="82908b45216f6f64aa572e8d9614febf36cdc646" translate="yes" xml:space="preserve">
          <source>Evaluates true if the data area of &lt;em&gt;arr&lt;/em&gt; can be written to</source>
          <target state="translated">Вычисляет истину, если область данных &lt;em&gt;arr&lt;/em&gt; может быть записана в</target>
        </trans-unit>
        <trans-unit id="a6798bac58d14b80f66da409bb3101b7acf52c78" translate="yes" xml:space="preserve">
          <source>Evaluates true if the data area of &lt;em&gt;arr&lt;/em&gt; consists of a single (C-style or Fortran-style) contiguous segment.</source>
          <target state="translated">Возвращает истину, если область данных &lt;em&gt;arr&lt;/em&gt; состоит из одного непрерывного сегмента (в стиле C или Fortran).</target>
        </trans-unit>
        <trans-unit id="52d051a4856042792e3562a8cf85f0b04c4a4af1" translate="yes" xml:space="preserve">
          <source>Evaluates true if the data area of &lt;em&gt;arr&lt;/em&gt; is C-style contiguous, aligned, and in machine byte-order.</source>
          <target state="translated">Вычисляет истину, если область данных &lt;em&gt;arr&lt;/em&gt; является непрерывной, выровненной и в машинном порядке байтов в стиле C.</target>
        </trans-unit>
        <trans-unit id="e202a99f33c9bfd2e1c5ac0fa0b8a81399b57105" translate="yes" xml:space="preserve">
          <source>Evaluates true if the data area of &lt;em&gt;arr&lt;/em&gt; is C-style contiguous, and &lt;a href=&quot;#c.PyArray_ISBEHAVED&quot;&gt;&lt;code&gt;PyArray_ISBEHAVED&lt;/code&gt;&lt;/a&gt; (&lt;em&gt;arr&lt;/em&gt;) is true.</source>
          <target state="translated">Вычисляет истину, если область данных &lt;em&gt;arr&lt;/em&gt; является смежной в стиле C, а &lt;a href=&quot;#c.PyArray_ISBEHAVED&quot;&gt; &lt;code&gt;PyArray_ISBEHAVED&lt;/code&gt; &lt;/a&gt; ( &lt;em&gt;arr&lt;/em&gt; ) истинно.</target>
        </trans-unit>
        <trans-unit id="effc549b6cbff87555006675e1c79c18e43a5365" translate="yes" xml:space="preserve">
          <source>Evaluates true if the data area of &lt;em&gt;arr&lt;/em&gt; is Fortran-style contiguous and &lt;a href=&quot;#c.PyArray_ISBEHAVED&quot;&gt;&lt;code&gt;PyArray_ISBEHAVED&lt;/code&gt;&lt;/a&gt; (&lt;em&gt;arr&lt;/em&gt;) is true.</source>
          <target state="translated">Вычисляет истину, если область данных &lt;em&gt;arr&lt;/em&gt; является смежной в стиле Фортрана, а &lt;a href=&quot;#c.PyArray_ISBEHAVED&quot;&gt; &lt;code&gt;PyArray_ISBEHAVED&lt;/code&gt; &lt;/a&gt; ( &lt;em&gt;arr&lt;/em&gt; ) истинно.</target>
        </trans-unit>
        <trans-unit id="8df904ca22ec2803d50d17cdbf121eedc6d72400" translate="yes" xml:space="preserve">
          <source>Evaluates true if the data area of &lt;em&gt;arr&lt;/em&gt; is Fortran-style contiguous, aligned, and in machine byte-order &lt;strong&gt;.&lt;/strong&gt;</source>
          <target state="translated">Вычисляет истину, если область данных &lt;em&gt;arr&lt;/em&gt; является смежной, выровненной и в машинном порядке байтов в стиле Фортрана &lt;strong&gt;.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="7a1b64683aef87f7f1b4257764cf4227296d827e" translate="yes" xml:space="preserve">
          <source>Evaluates true if the data area of &lt;em&gt;arr&lt;/em&gt; is aligned and in machine byte-order.</source>
          <target state="translated">Возвращает истину, если область данных &lt;em&gt;arr&lt;/em&gt; выровнена и в машинном порядке байтов.</target>
        </trans-unit>
        <trans-unit id="f7f20e7e1e5772639b1f7c4eb4bff4d2800f8c2a" translate="yes" xml:space="preserve">
          <source>Evaluates true if the data area of &lt;em&gt;arr&lt;/em&gt; is aligned and writeable and in machine byte-order according to its descriptor.</source>
          <target state="translated">Вычисляет истину, если область данных &lt;em&gt;arr&lt;/em&gt; выровнена и доступна для записи и в машинном порядке байтов в соответствии с ее дескриптором.</target>
        </trans-unit>
        <trans-unit id="e474d3b13b1be737b699dd99e94b826acd4340ff" translate="yes" xml:space="preserve">
          <source>Evaluates true if the data area of &lt;em&gt;arr&lt;/em&gt; is properly aligned on the machine.</source>
          <target state="translated">Возвращает истину, если область данных &lt;em&gt;arr&lt;/em&gt; правильно выровнена на машине.</target>
        </trans-unit>
        <trans-unit id="2fa74bf1ebb6946b1363906270140aeda279cf9f" translate="yes" xml:space="preserve">
          <source>Evaluates true if the data area of the ndarray &lt;em&gt;m&lt;/em&gt; is &lt;strong&gt;not&lt;/strong&gt; in machine byte-order according to the array&amp;rsquo;s data-type descriptor.</source>
          <target state="translated">Вычисляет истину, если область данных ndarray &lt;em&gt;m &lt;/em&gt;&lt;strong&gt;не&lt;/strong&gt; находится в машинном порядке байтов в соответствии с дескриптором типа данных массива.</target>
        </trans-unit>
        <trans-unit id="3267c071decd2c90623cf8528c8e4938c54505e6" translate="yes" xml:space="preserve">
          <source>Evaluates true if the data area of the ndarray &lt;em&gt;m&lt;/em&gt; is in machine byte-order according to the array&amp;rsquo;s data-type descriptor.</source>
          <target state="translated">Вычисляет истину, если область данных ndarray &lt;em&gt;m&lt;/em&gt; находится в машинном порядке байтов в соответствии с дескриптором типа данных массива.</target>
        </trans-unit>
        <trans-unit id="74157d4f0e365e7c26ee7ae56617ac39f0fc6cb5" translate="yes" xml:space="preserve">
          <source>Evaluation:</source>
          <target state="translated">Evaluation:</target>
        </trans-unit>
        <trans-unit id="bfed403a77ac8bf381d674a3abfc57ba60883a8b" translate="yes" xml:space="preserve">
          <source>Even for contiguous arrays a stride for a given dimension &lt;code&gt;arr.strides[dim]&lt;/code&gt; may be &lt;em&gt;arbitrary&lt;/em&gt; if &lt;code&gt;arr.shape[dim] == 1&lt;/code&gt; or the array has no elements. It does &lt;em&gt;not&lt;/em&gt; generally hold that &lt;code&gt;self.strides[-1] == self.itemsize&lt;/code&gt; for C-style contiguous arrays or &lt;code&gt;self.strides[0] == self.itemsize&lt;/code&gt; for Fortran-style contiguous arrays is true.</source>
          <target state="translated">Даже для смежных массивов шаг для данного измерения &lt;code&gt;arr.strides[dim]&lt;/code&gt; может быть &lt;em&gt;произвольным,&lt;/em&gt; если &lt;code&gt;arr.shape[dim] == 1&lt;/code&gt; или массив не имеет элементов. Обычно &lt;em&gt;не&lt;/em&gt; считается, что &lt;code&gt;self.strides[-1] == self.itemsize&lt;/code&gt; для непрерывных массивов в стиле C или &lt;code&gt;self.strides[0] == self.itemsize&lt;/code&gt; для непрерывных массивов в стиле Fortran истинно.</target>
        </trans-unit>
        <trans-unit id="1298a53951ccd9aa53bf4ad3ab74e5154ee53b89" translate="yes" xml:space="preserve">
          <source>Even for contiguous arrays a stride for a given dimension &lt;code&gt;arr.strides[dim]&lt;/code&gt; may be &lt;em&gt;arbitrary&lt;/em&gt; if &lt;code&gt;arr.shape[dim] == 1&lt;/code&gt; or the array has no elements. It does &lt;em&gt;not&lt;/em&gt; generally hold that &lt;code&gt;self.strides[-1] == self.itemsize&lt;/code&gt; for C-style contiguous arrays or &lt;code&gt;self.strides[0] == self.itemsize&lt;/code&gt; for Fortran-style contiguous arrays is true. The correct way to access the &lt;code&gt;itemsize&lt;/code&gt; of an array from the C API is &lt;code&gt;PyArray_ITEMSIZE(arr)&lt;/code&gt;.</source>
          <target state="translated">Даже для смежных массивов шаг для данного измерения &lt;code&gt;arr.strides[dim]&lt;/code&gt; может быть &lt;em&gt;произвольным,&lt;/em&gt; если &lt;code&gt;arr.shape[dim] == 1&lt;/code&gt; или массив не имеет элементов. Обычно &lt;em&gt;не&lt;/em&gt; считается, что &lt;code&gt;self.strides[-1] == self.itemsize&lt;/code&gt; для непрерывных массивов в стиле C или &lt;code&gt;self.strides[0] == self.itemsize&lt;/code&gt; для непрерывных массивов в стиле Fortran истинно. Правильный способ доступа к &lt;code&gt;itemsize&lt;/code&gt; элементов массива из C API - &lt;code&gt;PyArray_ITEMSIZE(arr)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c17cc6a8778f1a9a25e4a2f86caa32ef74f1e599" translate="yes" xml:space="preserve">
          <source>Even when the input array is two-dimensional:</source>
          <target state="translated">Даже если входной массив двумерный:</target>
        </trans-unit>
        <trans-unit id="42a0931fb2d7f42f3ac87c5b18547abf5d77fe06" translate="yes" xml:space="preserve">
          <source>Evenly round to the given number of decimals.</source>
          <target state="translated">Равномерно по заданному числу десятичных знаков.</target>
        </trans-unit>
        <trans-unit id="a19e0ffd5cc3d9a3df8ad933c77e6bea9dd169fb" translate="yes" xml:space="preserve">
          <source>Evenly spaced numbers with careful handling of endpoints.</source>
          <target state="translated">Равномерно распределенные числа при бережном обращении с конечными точками.</target>
        </trans-unit>
        <trans-unit id="1b950907a8c83b7ddb21092298e5404983c4a665" translate="yes" xml:space="preserve">
          <source>Eventually, expect to &lt;code&gt;__array_function__&lt;/code&gt; to always be enabled.</source>
          <target state="translated">В конце концов, ожидайте, что &lt;code&gt;__array_function__&lt;/code&gt; всегда будет включен.</target>
        </trans-unit>
        <trans-unit id="581f2179fc03c06bcc3dcff4b3f8f2a107464b3a" translate="yes" xml:space="preserve">
          <source>Every Python module, extension module, or subpackage in the SciPy package directory should have a corresponding &lt;code&gt;test_&amp;lt;name&amp;gt;.py&lt;/code&gt; file. Pytest examines these files for test methods (named test*) and test classes (named Test*).</source>
          <target state="translated">Каждый модуль Python, модуль расширения или подпакет в каталоге пакета SciPy должен иметь соответствующий &lt;code&gt;test_&amp;lt;name&amp;gt;.py&lt;/code&gt; . Pytest проверяет эти файлы на предмет методов тестирования (с именем test *) и тестовых классов (с именем Test *).</target>
        </trans-unit>
        <trans-unit id="fae734cbfb45b3c7fcea4a1b93bd51caeedc12aa" translate="yes" xml:space="preserve">
          <source>Every ufunc calculation involves some overhead related to setting up the calculation. The practical significance of this overhead is that even though the actual calculation of the ufunc is very fast, you will be able to write array and type-specific code that will work faster for small arrays than the ufunc. In particular, using ufuncs to perform many calculations on 0-D arrays will be slower than other Python-based solutions (the silently-imported scalarmath module exists precisely to give array scalars the look-and-feel of ufunc based calculations with significantly reduced overhead).</source>
          <target state="translated">Каждое вычисление ufunc предполагает некоторые накладные расходы,связанные с настройкой вычисления.Практическая значимость этих накладных расходов заключается в том,что,несмотря на то,что вычисление ufunc происходит очень быстро,вы сможете написать код,специфичный для массивов и типов,который будет работать быстрее для маленьких массивов,чем ufunc.В частности,использование ufuncs для выполнения многих вычислений на 0-D массивах будет медленнее,чем другие решения на базе Python (беззвучно импортируемый модуль scalarmath существует именно для того,чтобы обеспечить скалярам массивов внешний вид вычислений,основанных на ufunc,со значительно меньшими накладными расходами).</target>
        </trans-unit>
        <trans-unit id="0f01ed56a1e32a05e5ef96e4d779f34784af9a96" translate="yes" xml:space="preserve">
          <source>Example</source>
          <target state="translated">Example</target>
        </trans-unit>
        <trans-unit id="30643b2e1a03cdc521bd995bce3101935a638007" translate="yes" xml:space="preserve">
          <source>Example 1: Matrix creation from a string</source>
          <target state="translated">Пример 1:Создание матрицы из строки</target>
        </trans-unit>
        <trans-unit id="ce3d11c2b2ea882cbd46aab60dee035848945f1a" translate="yes" xml:space="preserve">
          <source>Example 2: Matrix creation from nested sequence</source>
          <target state="translated">Пример 2:Создание матрицы из вложенной последовательности</target>
        </trans-unit>
        <trans-unit id="7a618a4143ae0244c26c66d93ae5ab076865eca3" translate="yes" xml:space="preserve">
          <source>Example 3: Matrix creation from an array</source>
          <target state="translated">Пример 3:Создание матрицы из массива</target>
        </trans-unit>
        <trans-unit id="4a0d4f43d7d9bdb2a4af703ab58a4be1e4d7fae7" translate="yes" xml:space="preserve">
          <source>Example illustrating a common use of &lt;a href=&quot;#numpy.linalg.qr&quot;&gt;&lt;code&gt;qr&lt;/code&gt;&lt;/a&gt;: solving of least squares problems</source>
          <target state="translated">Пример, иллюстрирующий общее использование &lt;a href=&quot;#numpy.linalg.qr&quot;&gt; &lt;code&gt;qr&lt;/code&gt; &lt;/a&gt; : решение задач наименьших квадратов</target>
        </trans-unit>
        <trans-unit id="8b9b4c475cb57be9cefc272ad9e58398f1d4a72d" translate="yes" xml:space="preserve">
          <source>Example of ellipsis use:</source>
          <target state="translated">Пример использования эллипсиса:</target>
        </trans-unit>
        <trans-unit id="663d5de84d17f73904544fdaa7818c43c339aab6" translate="yes" xml:space="preserve">
          <source>Example of the &lt;em&gt;axis&lt;/em&gt; argument</source>
          <target state="translated">Пример аргумента &lt;em&gt;оси&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="441193d28defb7b45677223f2e8385cc1771ef57" translate="yes" xml:space="preserve">
          <source>Example showing broadcast of scalar_like argument:</source>
          <target state="translated">Пример,показывающий трансляцию скалярного_подобного аргумента:</target>
        </trans-unit>
        <trans-unit id="c63737abd7347a7ae582cb9fbdf37d6c0e5b251e" translate="yes" xml:space="preserve">
          <source>Example:</source>
          <target state="translated">Example:</target>
        </trans-unit>
        <trans-unit id="eb01bf04c9a0e8a71c45816513df424f1c7ffedb" translate="yes" xml:space="preserve">
          <source>Examples</source>
          <target state="translated">Examples</target>
        </trans-unit>
        <trans-unit id="f7651c4bad19b71b6cb07d324b05afde4b46e15c" translate="yes" xml:space="preserve">
          <source>Exceeded max_work.</source>
          <target state="translated">Превышенное значение max_work.</target>
        </trans-unit>
        <trans-unit id="b4a918f3b3ebec530b94769e489c47c784e700d0" translate="yes" xml:space="preserve">
          <source>Except for splitting from the right, &lt;a href=&quot;#numpy.char.rsplit&quot;&gt;&lt;code&gt;rsplit&lt;/code&gt;&lt;/a&gt; behaves like &lt;a href=&quot;numpy.char.split#numpy.char.split&quot;&gt;&lt;code&gt;split&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">За исключением разделения справа, &lt;a href=&quot;#numpy.char.rsplit&quot;&gt; &lt;code&gt;rsplit&lt;/code&gt; &lt;/a&gt; ведет себя как &lt;a href=&quot;numpy.char.split#numpy.char.split&quot;&gt; &lt;code&gt;split&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="50cf8f9b1990e86989de06e0c8538067135c84c5" translate="yes" xml:space="preserve">
          <source>Except for the handling of missing data this function does the same as &lt;a href=&quot;numpy.corrcoef#numpy.corrcoef&quot;&gt;&lt;code&gt;numpy.corrcoef&lt;/code&gt;&lt;/a&gt;. For more details and examples, see &lt;a href=&quot;numpy.corrcoef#numpy.corrcoef&quot;&gt;&lt;code&gt;numpy.corrcoef&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">За исключением обработки отсутствующих данных, эта функция делает то же, что и &lt;a href=&quot;numpy.corrcoef#numpy.corrcoef&quot;&gt; &lt;code&gt;numpy.corrcoef&lt;/code&gt; &lt;/a&gt; . Для получения дополнительных сведений и примеров см. &lt;a href=&quot;numpy.corrcoef#numpy.corrcoef&quot;&gt; &lt;code&gt;numpy.corrcoef&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="fcfc562b386cd345086d419126e4274f3e7274f0" translate="yes" xml:space="preserve">
          <source>Except for the handling of missing data this function does the same as &lt;a href=&quot;numpy.cov#numpy.cov&quot;&gt;&lt;code&gt;numpy.cov&lt;/code&gt;&lt;/a&gt;. For more details and examples, see &lt;a href=&quot;numpy.cov#numpy.cov&quot;&gt;&lt;code&gt;numpy.cov&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">За исключением обработки недостающих данных, эта функция работает так же, как &lt;a href=&quot;numpy.cov#numpy.cov&quot;&gt; &lt;code&gt;numpy.cov&lt;/code&gt; &lt;/a&gt; . Для получения дополнительных сведений и примеров см. &lt;a href=&quot;numpy.cov#numpy.cov&quot;&gt; &lt;code&gt;numpy.cov&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="cd3dfbe79fda3a9d92de67b1bd4f1dc9f60ab723" translate="yes" xml:space="preserve">
          <source>Exceptions</source>
          <target state="translated">Exceptions</target>
        </trans-unit>
        <trans-unit id="26e6ce501ea40e3a3a4030f941745cb2ec376d8c" translate="yes" xml:space="preserve">
          <source>Execute &lt;code&gt;func1d(a, *args)&lt;/code&gt; where &lt;code&gt;func1d&lt;/code&gt; operates on 1-D arrays and &lt;code&gt;a&lt;/code&gt; is a 1-D slice of &lt;code&gt;arr&lt;/code&gt; along &lt;code&gt;axis&lt;/code&gt;.</source>
          <target state="translated">Выполните &lt;code&gt;func1d(a, *args)&lt;/code&gt; где &lt;code&gt;func1d&lt;/code&gt; работает с одномерными массивами, а &lt;code&gt;a&lt;/code&gt; - одномерный срез &lt;code&gt;arr&lt;/code&gt; вдоль &lt;code&gt;axis&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="cbd62d234a86ea4d63bc3019c94a352e75700653" translate="yes" xml:space="preserve">
          <source>Existing array to use for output. If not given, returns a default copy of a.</source>
          <target state="translated">Существующий массив для вывода.Если не задано,возвращает копию по умолчанию.</target>
        </trans-unit>
        <trans-unit id="49efde5e22ecb6838665120a39ab53a2bd9e68ce" translate="yes" xml:space="preserve">
          <source>Existing arrays are not copied:</source>
          <target state="translated">Существующие массивы не копируются:</target>
        </trans-unit>
        <trans-unit id="49afcf31d80f21e8d0b1602a5dec36d208fe71f8" translate="yes" xml:space="preserve">
          <source>Expand the shape of an array.</source>
          <target state="translated">Расширьте форму массива.</target>
        </trans-unit>
        <trans-unit id="ffcf950230f953a0aa6e82e09f28f2ca5a3b9124" translate="yes" xml:space="preserve">
          <source>Expectation of interval, must be &amp;gt;= 0. A sequence of expectation intervals must be broadcastable over the requested size.</source>
          <target state="translated">Ожидание интервала должно быть&amp;gt; = 0. Последовательность ожидаемых интервалов должна транслироваться в пределах запрошенного размера.</target>
        </trans-unit>
        <trans-unit id="cf1e24ddaed54869cdb52d8afc4913163a237789" translate="yes" xml:space="preserve">
          <source>Expects a 1-D &lt;a href=&quot;../maskedarray.baseclass#numpy.ma.MaskedArray&quot;&gt;&lt;code&gt;MaskedArray&lt;/code&gt;&lt;/a&gt;, returns None if all values are masked.</source>
          <target state="translated">Ожидает 1-D &lt;a href=&quot;../maskedarray.baseclass#numpy.ma.MaskedArray&quot;&gt; &lt;code&gt;MaskedArray&lt;/code&gt; &lt;/a&gt; , возвращает None, если все значения замаскированы.</target>
        </trans-unit>
        <trans-unit id="308f613122797fe7bbf7289f6c7ded6a9a215476" translate="yes" xml:space="preserve">
          <source>Explained without fancy indexing, this is equivalent to the following use of &lt;a href=&quot;numpy.ndindex#numpy.ndindex&quot;&gt;&lt;code&gt;ndindex&lt;/code&gt;&lt;/a&gt;, which sets each of &lt;code&gt;ii&lt;/code&gt;, &lt;code&gt;jj&lt;/code&gt;, and &lt;code&gt;kk&lt;/code&gt; to a tuple of indices:</source>
          <target state="translated">Объясняя это без причудливой индексации, это эквивалентно следующему использованию &lt;a href=&quot;numpy.ndindex#numpy.ndindex&quot;&gt; &lt;code&gt;ndindex&lt;/code&gt; &lt;/a&gt; , который устанавливает для каждого из &lt;code&gt;ii&lt;/code&gt; , &lt;code&gt;jj&lt;/code&gt; и &lt;code&gt;kk&lt;/code&gt; набор индексов:</target>
        </trans-unit>
        <trans-unit id="f2a8ab3710ac4db36fc8b2f6b13aa845d130b020" translate="yes" xml:space="preserve">
          <source>Exponent of the smallest (most negative) power of &lt;code&gt;ibeta&lt;/code&gt; that, added to 1.0, gives something different from 1.0</source>
          <target state="translated">Показатель наименьшей (самой отрицательной) степени &lt;code&gt;ibeta&lt;/code&gt; который, добавленный к 1.0, дает нечто отличное от 1.0</target>
        </trans-unit>
        <trans-unit id="b6c379526da851c2c188007fc0f60f969489df7a" translate="yes" xml:space="preserve">
          <source>Exponent of the smallest power of &lt;code&gt;ibeta&lt;/code&gt; that, subtracted from 1.0, gives something different from 1.0.</source>
          <target state="translated">Показатель наименьшей степени &lt;code&gt;ibeta&lt;/code&gt; , вычитаемый из 1,0, дает нечто отличное от 1,0.</target>
        </trans-unit>
        <trans-unit id="4b6764a081f01f39974a118ba6996f7bb9dae570" translate="yes" xml:space="preserve">
          <source>Exponentials</source>
          <target state="translated">Exponentials</target>
        </trans-unit>
        <trans-unit id="3ce964226c06687afb0e1cd2608b915c6e2ae80f" translate="yes" xml:space="preserve">
          <source>Exponents and logarithms</source>
          <target state="translated">Экспонаты и логарифмы</target>
        </trans-unit>
        <trans-unit id="4be9a4abd6d7c8083fc1a7bf9004e653250a9ba5" translate="yes" xml:space="preserve">
          <source>Extending</source>
          <target state="translated">Extending</target>
        </trans-unit>
        <trans-unit id="b8df212e6d243492be0344c26fa93a5ac0e105d8" translate="yes" xml:space="preserve">
          <source>Extends &lt;a href=&quot;#c.NpyIter_MultiNew&quot;&gt;&lt;code&gt;NpyIter_MultiNew&lt;/code&gt;&lt;/a&gt; with several advanced options providing more control over broadcasting and buffering.</source>
          <target state="translated">Расширяет &lt;a href=&quot;#c.NpyIter_MultiNew&quot;&gt; &lt;code&gt;NpyIter_MultiNew&lt;/code&gt; &lt;/a&gt; несколькими расширенными параметрами, обеспечивающими больший контроль над широковещательной передачей и буферизацией.</target>
        </trans-unit>
        <trans-unit id="730550afb5b9c93a998c435ea0c0d79790c3f92e" translate="yes" xml:space="preserve">
          <source>External Links:</source>
          <target state="translated">Внешние ссылки:</target>
        </trans-unit>
        <trans-unit id="f5695baec527125ed849fab25176346709bcdc26" translate="yes" xml:space="preserve">
          <source>Extra arguments to be used in the function call. Default is no extra arguments.</source>
          <target state="translated">Дополнительные аргументы для использования при вызове функции.По умолчанию дополнительные аргументы не используются.</target>
        </trans-unit>
        <trans-unit id="7475cdd2c7bf2da401a59201928f6e438e74c2c4" translate="yes" xml:space="preserve">
          <source>Extra data to be passed to the 1-d vector loops or &lt;code&gt;NULL&lt;/code&gt; if no extra-data is needed. This C-array must be the same size ( &lt;em&gt;i.e.&lt;/em&gt; ntypes) as the functions array. &lt;code&gt;NULL&lt;/code&gt; is used if extra_data is not needed. Several C-API calls for UFuncs are just 1-d vector loops that make use of this extra data to receive a pointer to the actual function to call.</source>
          <target state="translated">Дополнительные данные для передачи в 1-мерные векторные циклы или &lt;code&gt;NULL&lt;/code&gt; , если дополнительные данные не требуются. Этот C-массив должен иметь тот же размер ( &lt;em&gt;т.е.&lt;/em&gt; ntypes), что и массив функций. &lt;code&gt;NULL&lt;/code&gt; используется, если extra_data не требуется. Несколько вызовов C-API для UFuncs представляют собой просто одномерные векторные циклы, которые используют эти дополнительные данные для получения указателя на фактическую функцию для вызова.</target>
        </trans-unit>
        <trans-unit id="76b524fa169ed9d7419720ac2e63f1800fb02fd6" translate="yes" xml:space="preserve">
          <source>Extra features in NumPy Distutils</source>
          <target state="translated">Дополнительные функции в дистилляторах NumPy</target>
        </trans-unit>
        <trans-unit id="e4b908b04be2629c5ae91c968b91dbf4fa38bfee" translate="yes" xml:space="preserve">
          <source>Extract a diagonal or construct a diagonal array.</source>
          <target state="translated">Извлечь диагональ или построить диагональный массив.</target>
        </trans-unit>
        <trans-unit id="8f2f355e8dba1681289d909a9095fc402d801e4a" translate="yes" xml:space="preserve">
          <source>Extract the diagonal (requires explicit form):</source>
          <target state="translated">Извлеките диагональ (требуется явная форма):</target>
        </trans-unit>
        <trans-unit id="00b194f535090973445600575106dc4bd4b91c15" translate="yes" xml:space="preserve">
          <source>F &amp;amp; C order preserved, otherwise most similar order</source>
          <target state="translated">Сохранен порядок F&amp;amp;C, в остальном наиболее похожий порядок</target>
        </trans-unit>
        <trans-unit id="3a82a1967b0685fff927bd0da5e7638582e5ea69" translate="yes" xml:space="preserve">
          <source>F order</source>
          <target state="translated">порядок F</target>
        </trans-unit>
        <trans-unit id="c79b9dbc4a93112f31ab2f13620d941f25753284" translate="yes" xml:space="preserve">
          <source>F order if input is F and not C, otherwise C order</source>
          <target state="translated">F порядок,если вводится F,а не C,в противном случае C порядок</target>
        </trans-unit>
        <trans-unit id="bf8300dc1be4d8761c3816eeb71051b6b621dd6e" translate="yes" xml:space="preserve">
          <source>FFT</source>
          <target state="translated">FFT</target>
        </trans-unit>
        <trans-unit id="ca600c25350318c92a93eef893cdd109ac18c10d" translate="yes" xml:space="preserve">
          <source>FFT (Fast Fourier Transform) refers to a way the discrete Fourier Transform (DFT) can be calculated efficiently, by using symmetries in the calculated terms. The symmetry is highest when &lt;code&gt;n&lt;/code&gt; is a power of 2, and the transform is therefore most efficient for these sizes.</source>
          <target state="translated">БПФ (быстрое преобразование Фурье) относится к способу эффективного вычисления дискретного преобразования Фурье (ДПФ) с использованием симметрии в вычисляемых условиях. Симметрия наивысшая, когда &lt;code&gt;n&lt;/code&gt; является степенью 2, и поэтому преобразование наиболее эффективно для этих размеров.</target>
        </trans-unit>
        <trans-unit id="1e904f6af52956913c4ff703c15d71d4683c8dd0" translate="yes" xml:space="preserve">
          <source>F_CONTIGUOUS / F / FORTRAN</source>
          <target state="translated">F_CONTIGUOUS/F/FORTRAN</target>
        </trans-unit>
        <trans-unit id="10ba031202732234b30a39bc920cbaa6d821ef6b" translate="yes" xml:space="preserve">
          <source>F_CONTIGUOUS and not C_CONTIGUOUS.</source>
          <target state="translated">F_CONTIGUOUS,а не C_CONTIGUOUS.</target>
        </trans-unit>
        <trans-unit id="542219cc1d690d05adfbb2e51a8b3ccb1985fddc" translate="yes" xml:space="preserve">
          <source>F_CONTIGUOUS or C_CONTIGUOUS (one-segment test).</source>
          <target state="translated">F_CONTIGUOUS или C_CONTIGUOUS (односегментный тест).</target>
        </trans-unit>
        <trans-unit id="85c6c271be69ba94867c22f54f57654f454c41b4" translate="yes" xml:space="preserve">
          <source>Factor the matrix &lt;code&gt;a&lt;/code&gt; as &lt;em&gt;qr&lt;/em&gt;, where &lt;code&gt;q&lt;/code&gt; is orthonormal and &lt;code&gt;r&lt;/code&gt; is upper-triangular.</source>
          <target state="translated">Разложите матрицу &lt;code&gt;a&lt;/code&gt; на &lt;em&gt;множители&lt;/em&gt; как &lt;em&gt;qr&lt;/em&gt; , где &lt;code&gt;q&lt;/code&gt; ортонормировано, а &lt;code&gt;r&lt;/code&gt; верхнетреугольное.</target>
        </trans-unit>
        <trans-unit id="fb318cde14ee94b6e5d32ac7d527c0788644b0e1" translate="yes" xml:space="preserve">
          <source>Fail unless an exception of class exception_class and with message that matches expected_regexp is thrown by callable when invoked with arguments args and keyword arguments kwargs.</source>
          <target state="translated">Fail,если только при вызове с аргументами arguments args и keyword аргументами kwargs не будет брошено вызываемое исключение класса exception_class с сообщением,совпадающим с ожидаемым_regexp.</target>
        </trans-unit>
        <trans-unit id="021d84299e2248496708e7d1e546ad6c2c18b0ba" translate="yes" xml:space="preserve">
          <source>Fail unless an exception of class exception_class is thrown by callable when invoked with arguments args and keyword arguments kwargs.</source>
          <target state="translated">Отказ,если только при вызове с аргументами аргументов аргументов аргументов и ключевых слов kwargs не брошено исключение класса exception_class с помощью вызываемого параметра.</target>
        </trans-unit>
        <trans-unit id="88591071684d50acd16039be01f0c08d81ea457a" translate="yes" xml:space="preserve">
          <source>Fail unless an exception of class exception_class is thrown by callable when invoked with arguments args and keyword arguments kwargs. If a different type of exception is thrown, it will not be caught, and the test case will be deemed to have suffered an error, exactly as for an unexpected exception.</source>
          <target state="translated">Отказ,если только при вызове с аргументами аргументов аргументов аргументов и ключевых слов kwargs не брошено исключение класса exception_class с помощью вызываемого параметра.Если брошено исключение другого типа,то оно не будет перехвачено,а тестовый случай будет считаться ошибочным,точно так же,как и для неожиданного исключения.</target>
        </trans-unit>
        <trans-unit id="719788786f4bf9fa2ee26b39d5371d0a438935c3" translate="yes" xml:space="preserve">
          <source>Fail unless the given callable throws the specified warning.</source>
          <target state="translated">Невозможно,если только данный вызываемый абонент не бросит указанное предупреждение.</target>
        </trans-unit>
        <trans-unit id="552c13b4b3257ae89f519cb962e935c59da9aa88" translate="yes" xml:space="preserve">
          <source>Fanaticism consists of redoubling your efforts when you have forgotten your aim. &amp;mdash; &lt;em&gt;George Santayana&lt;/em&gt;</source>
          <target state="translated">Фанатизм состоит в удвоении ваших усилий, когда вы забыли свою цель. - &lt;em&gt;Джордж Сантаяна&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="a35d6e8cdee3fab38ad9c3056a80a39fdb1d90ea" translate="yes" xml:space="preserve">
          <source>Faster version of &lt;a href=&quot;#numpy.base_repr&quot;&gt;&lt;code&gt;base_repr&lt;/code&gt;&lt;/a&gt; for base 2.</source>
          <target state="translated">Более быстрая версия &lt;a href=&quot;#numpy.base_repr&quot;&gt; &lt;code&gt;base_repr&lt;/code&gt; &lt;/a&gt; для базы 2.</target>
        </trans-unit>
        <trans-unit id="ad565d9d01d0e0bf91fd6a8532f6d81613338901" translate="yes" xml:space="preserve">
          <source>Feature</source>
          <target state="translated">Feature</target>
        </trans-unit>
        <trans-unit id="fc338f87a058158eb824b53705961801516a9460" translate="yes" xml:space="preserve">
          <source>Features</source>
          <target state="translated">Features</target>
        </trans-unit>
        <trans-unit id="5c6f34280b7f890c09c370b6ae106bab782a8ea7" translate="yes" xml:space="preserve">
          <source>Field Access</source>
          <target state="translated">Доступ на местах</target>
        </trans-unit>
        <trans-unit id="1f20e66b17a6eb7c2baf1ab68337d91eaf6f4f80" translate="yes" xml:space="preserve">
          <source>Figure</source>
          <target state="translated">Figure</target>
        </trans-unit>
        <trans-unit id="373ecfdf236324d2c0d2c0966daa4376bd84ecc7" translate="yes" xml:space="preserve">
          <source>File extensions</source>
          <target state="translated">Расширения файлов</target>
        </trans-unit>
        <trans-unit id="d09479e812c08194a796ba5cf0534018f31d75df" translate="yes" xml:space="preserve">
          <source>File like object that the output is written to, default is &lt;code&gt;stdout&lt;/code&gt;. The object has to be opened in &amp;lsquo;w&amp;rsquo; or &amp;lsquo;a&amp;rsquo; mode.</source>
          <target state="translated">Файловый объект, в который записывается вывод, по умолчанию - &lt;code&gt;stdout&lt;/code&gt; . Объект должен быть открыт в режиме &amp;laquo;w&amp;raquo; или &amp;laquo;a&amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="87eae4c8fed58e613f33763392061f9f060bfb3a" translate="yes" xml:space="preserve">
          <source>File mode.</source>
          <target state="translated">Файловый режим.</target>
        </trans-unit>
        <trans-unit id="fd757708817417e6d160c4d854e159b642dde015" translate="yes" xml:space="preserve">
          <source>File name or file object to read.</source>
          <target state="translated">Имя файла или объект файла для чтения.</target>
        </trans-unit>
        <trans-unit id="a9cb7966c21c4ba3f863696ad8ce671f4f627493" translate="yes" xml:space="preserve">
          <source>File object.</source>
          <target state="translated">Файловый объект.</target>
        </trans-unit>
        <trans-unit id="4a94520c92dda87c31025fbdcee94cc740835e3c" translate="yes" xml:space="preserve">
          <source>File on disk is unchanged:</source>
          <target state="translated">Файл на диске не изменяется:</target>
        </trans-unit>
        <trans-unit id="0031f1b0b3ec78263f049edb5bf2d9bd62cb7daa" translate="yes" xml:space="preserve">
          <source>File or filename to which the data is saved. If file is a file-object, then the filename is unchanged. If file is a string or Path, a &lt;code&gt;.npy&lt;/code&gt; extension will be appended to the file name if it does not already have one.</source>
          <target state="translated">Файл или имя файла, в котором сохраняются данные. Если файл является файлом-объектом, то имя файла не изменяется. Если файл представляет собой строку или путь, к имени файла будет добавлено расширение &lt;code&gt;.npy&lt;/code&gt; , если его еще нет.</target>
        </trans-unit>
        <trans-unit id="e820f26629f1b163437a25da45907f2a0bdeef89" translate="yes" xml:space="preserve">
          <source>File, filename, list, or generator to read. If the filename extension is &lt;code&gt;gz&lt;/code&gt; or &lt;a href=&quot;https://docs.python.org/dev/library/bz2.html#module-bz2&quot;&gt;&lt;code&gt;bz2&lt;/code&gt;&lt;/a&gt;, the file is first decompressed. Note that generators must return byte strings in Python 3k. The strings in a list or produced by a generator are treated as lines.</source>
          <target state="translated">Файл, имя файла, список или генератор для чтения. Если расширение имени файла - &lt;code&gt;gz&lt;/code&gt; или &lt;a href=&quot;https://docs.python.org/dev/library/bz2.html#module-bz2&quot;&gt; &lt;code&gt;bz2&lt;/code&gt; &lt;/a&gt; , файл сначала распаковывается. Обратите внимание, что в Python 3k генераторы должны возвращать байтовые строки. Строки в списке или созданные генератором рассматриваются как строки.</target>
        </trans-unit>
        <trans-unit id="822b222e1d15e367e3952f91b983db03e9a7813a" translate="yes" xml:space="preserve">
          <source>File, filename, or generator to read. If the filename extension is &lt;code&gt;.gz&lt;/code&gt; or &lt;code&gt;.bz2&lt;/code&gt;, the file is first decompressed. Note that generators should return byte strings for Python 3k.</source>
          <target state="translated">Файл, имя файла или генератор для чтения. Если расширение имени файла - &lt;code&gt;.gz&lt;/code&gt; или &lt;code&gt;.bz2&lt;/code&gt; , файл сначала распаковывается. Обратите внимание, что генераторы должны возвращать байтовые строки для Python 3k.</target>
        </trans-unit>
        <trans-unit id="c13aad6dcb77e8786c02dc6c8f0cc3a100a87f10" translate="yes" xml:space="preserve">
          <source>File-like object to write the output to. If omitted, use a pager.</source>
          <target state="translated">Файлоподобный объект для записи вывода.Если он опущен,используйте пейджер.</target>
        </trans-unit>
        <trans-unit id="cafc76c090d17de83480422080a28bd0d7fd39f0" translate="yes" xml:space="preserve">
          <source>Fill a newly created array with a single value obj at all locations in the structure with object data-types. No checking is performed but &lt;em&gt;arr&lt;/em&gt; must be of data-type &lt;a href=&quot;c-api.dtype#c.NPY_OBJECT&quot;&gt;&lt;code&gt;NPY_OBJECT&lt;/code&gt;&lt;/a&gt; and be single-segment and uninitialized (no previous objects in position). Use &lt;code&gt;PyArray_DECREF&lt;/code&gt; (&lt;em&gt;arr&lt;/em&gt;) if you need to decrement all the items in the object array prior to calling this function.</source>
          <target state="translated">Заполните вновь созданный массив одним значением obj во всех местах структуры с типами данных объекта. Проверка не выполняется, но &lt;em&gt;arr&lt;/em&gt; должен иметь тип данных &lt;a href=&quot;c-api.dtype#c.NPY_OBJECT&quot;&gt; &lt;code&gt;NPY_OBJECT&lt;/code&gt; ,&lt;/a&gt; быть односегментным и неинициализированным (без предыдущих объектов в позиции). Используйте &lt;code&gt;PyArray_DECREF&lt;/code&gt; ( &lt;em&gt;arr&lt;/em&gt; ), если вам нужно уменьшить все элементы в массиве объектов перед вызовом этой функции.</target>
        </trans-unit>
        <trans-unit id="260366fdf73d36b977576943b4aedf90420566c3" translate="yes" xml:space="preserve">
          <source>Fill the array pointed to by &lt;em&gt;obj&lt;/em&gt; &amp;mdash;which must be a (subclass of) ndarray&amp;mdash;with the contents of &lt;em&gt;val&lt;/em&gt; (evaluated as a byte). This macro calls memset, so obj must be contiguous.</source>
          <target state="translated">Заполните массив, на который указывает &lt;em&gt;obj,&lt;/em&gt; который должен быть (подклассом) ndarray, содержимым &lt;em&gt;val&lt;/em&gt; (оценивается как байт). Этот макрос вызывает memset, поэтому obj должен быть непрерывным.</target>
        </trans-unit>
        <trans-unit id="1cc72d434ca66ec2855e95222b47cf34ee62d6a9" translate="yes" xml:space="preserve">
          <source>Fill the array with a scalar value.</source>
          <target state="translated">Заполните массив скалярным значением.</target>
        </trans-unit>
        <trans-unit id="a5d5966e608173a9667b1c1fac892e66538c72e9" translate="yes" xml:space="preserve">
          <source>Fill the array, &lt;em&gt;arr&lt;/em&gt;, with the given scalar object, &lt;em&gt;obj&lt;/em&gt;. The object is first converted to the data type of &lt;em&gt;arr&lt;/em&gt;, and then copied into every location. A -1 is returned if an error occurs, otherwise 0 is returned.</source>
          <target state="translated">Заполните массив &lt;em&gt;arr&lt;/em&gt; заданным скалярным объектом &lt;em&gt;obj&lt;/em&gt; . Объект сначала преобразуется в тип данных &lt;em&gt;arr&lt;/em&gt; , а затем копируется во все места. В случае ошибки возвращается -1, в противном случае возвращается 0.</target>
        </trans-unit>
        <trans-unit id="7bee882405d3a5e1e28b315ab4a7baab2498c486" translate="yes" xml:space="preserve">
          <source>Fill the main diagonal of the given array of any dimensionality.</source>
          <target state="translated">Заполните главную диагональ заданного массива любой размерности.</target>
        </trans-unit>
        <trans-unit id="b0054199bd21115b17143e2277b55874769f1942" translate="yes" xml:space="preserve">
          <source>Fill value.</source>
          <target state="translated">Заполните значение.</target>
        </trans-unit>
        <trans-unit id="b3edc087fa7c92433208963d028502658cb11c3c" translate="yes" xml:space="preserve">
          <source>Filling a masked array</source>
          <target state="translated">Заполнение маскированного массива</target>
        </trans-unit>
        <trans-unit id="b16b1c014bc041df050e0baec2b30b9a58147141" translate="yes" xml:space="preserve">
          <source>Filling in the missing data</source>
          <target state="translated">Заполнение недостающих данных</target>
        </trans-unit>
        <trans-unit id="4473d8b6f530a08d5d328b58cdecfd819be6ec67" translate="yes" xml:space="preserve">
          <source>Filling value. A consistency test is performed to make sure the value is compatible with the dtype of &lt;code&gt;a&lt;/code&gt;.</source>
          <target state="translated">Начальная стоимость. Выполняется проверка согласованности, чтобы убедиться, что значение совместимо с dtype &lt;code&gt;a&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="13227282778cd8d20999d32a512e651e3ee07193" translate="yes" xml:space="preserve">
          <source>Filling value. Default is None.</source>
          <target state="translated">Заправочная стоимость.По умолчанию нет.</target>
        </trans-unit>
        <trans-unit id="6c1d42d50fc7e4074f490614ad1bcf00ba471b76" translate="yes" xml:space="preserve">
          <source>Fills &lt;code&gt;nop&lt;/code&gt; flags. Sets &lt;code&gt;outreadflags[i]&lt;/code&gt; to 1 if &lt;code&gt;op[i]&lt;/code&gt; can be read from, and to 0 if not.</source>
          <target state="translated">Заполняет флаги &lt;code&gt;nop&lt;/code&gt; . Устанавливает &lt;code&gt;outreadflags[i]&lt;/code&gt; в 1, если &lt;code&gt;op[i]&lt;/code&gt; можно читать, и в 0, если нет.</target>
        </trans-unit>
        <trans-unit id="749d04ce696c047f8e1f31d9e0905d115c8ee6f7" translate="yes" xml:space="preserve">
          <source>Fills &lt;code&gt;nop&lt;/code&gt; flags. Sets &lt;code&gt;outwriteflags[i]&lt;/code&gt; to 1 if &lt;code&gt;op[i]&lt;/code&gt; can be written to, and to 0 if not.</source>
          <target state="translated">Заполняет флаги &lt;code&gt;nop&lt;/code&gt; . Устанавливает &lt;code&gt;outwriteflags[i]&lt;/code&gt; в 1, если в &lt;code&gt;op[i]&lt;/code&gt; можно записывать, и в 0, если нет.</target>
        </trans-unit>
        <trans-unit id="8d3ad1e9024ff38aba4d75bcdff8761b89757502" translate="yes" xml:space="preserve">
          <source>Filter deprecation warnings while running the test suite.</source>
          <target state="translated">Фильтруйте предупреждения об ослаблении фильтра во время работы набора тестов.</target>
        </trans-unit>
        <trans-unit id="53d64090d55b3e9e6c51d2a5eb3eec10a8e6734d" translate="yes" xml:space="preserve">
          <source>Filters added inside the context manager will be discarded again when leaving it. Upon entering all filters defined outside a context will be applied automatically.</source>
          <target state="translated">Фильтры,добавленные внутри контекстного менеджера,при выходе из него будут снова отбрасываться.При вводе всех фильтров,определенных вне контекстного менеджера,они будут применены автоматически.</target>
        </trans-unit>
        <trans-unit id="1f7718a6ac69fd3c4dc296189cd48158349007af" translate="yes" xml:space="preserve">
          <source>Final output manipulation</source>
          <target state="translated">Манипулирование конечным выводом</target>
        </trans-unit>
        <trans-unit id="ba468d0ce6c90f05fb67a4c2a63c164ebea004bd" translate="yes" xml:space="preserve">
          <source>Finally, &lt;code&gt;Configuration&lt;/code&gt; has &lt;code&gt;.todict()&lt;/code&gt; method that returns all the configuration data as a dictionary suitable for passing on to the &lt;code&gt;setup(..)&lt;/code&gt; function.</source>
          <target state="translated">Наконец, в &lt;code&gt;Configuration&lt;/code&gt; есть &lt;code&gt;.todict()&lt;/code&gt; который возвращает все данные конфигурации в виде словаря, подходящего для передачи в функцию &lt;code&gt;setup(..)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="889c8c42cccc1d124561a48d8ca41abb6ac29d7b" translate="yes" xml:space="preserve">
          <source>Finally, a data type can describe items that are themselves arrays of items of another data type. These sub-arrays must, however, be of a fixed size.</source>
          <target state="translated">Наконец,тип данных может описывать элементы,которые сами по себе являются массивами элементов другого типа данных.Однако эти подмассивы должны иметь фиксированный размер.</target>
        </trans-unit>
        <trans-unit id="591676022a4d7afed7631e7209e11f88a0c70ca2" translate="yes" xml:space="preserve">
          <source>Finally, if you are only interested in testing a subset of SciPy, for example, the &lt;code&gt;integrate&lt;/code&gt; module, use the following:</source>
          <target state="translated">Наконец, если вас интересует только тестирование подмножества SciPy, например, модуля &lt;code&gt;integrate&lt;/code&gt; , используйте следующее:</target>
        </trans-unit>
        <trans-unit id="3cd9ab198daaf3fb255075968e2a8d87bc37a3b9" translate="yes" xml:space="preserve">
          <source>Finally, it is emphasized that &lt;code&gt;v&lt;/code&gt; consists of the &lt;em&gt;right&lt;/em&gt; (as in right-hand side) eigenvectors of &lt;code&gt;a&lt;/code&gt;. A vector &lt;code&gt;y&lt;/code&gt; satisfying &lt;code&gt;dot(y.T, a) = z * y.T&lt;/code&gt; for some number &lt;code&gt;z&lt;/code&gt; is called a &lt;em&gt;left&lt;/em&gt; eigenvector of &lt;code&gt;a&lt;/code&gt;, and, in general, the left and right eigenvectors of a matrix are not necessarily the (perhaps conjugate) transposes of each other.</source>
          <target state="translated">Наконец, следует подчеркнуть , что &lt;code&gt;v&lt;/code&gt; состоит из &lt;em&gt;права&lt;/em&gt; (как и в правой части) собственные векторы . Вектор &lt;code&gt;y&lt;/code&gt; , удовлетворяющий &lt;code&gt;dot(y.T, a) = z * y.T&lt;/code&gt; для некоторого числа &lt;code&gt;z&lt;/code&gt; , называется &lt;em&gt;левым&lt;/em&gt; собственным вектором &lt;code&gt;a&lt;/code&gt; , и, как правило, левый и правый собственные векторы матрицы не обязательно являются (возможно, сопряженными) транспонами каждого Другой. &lt;code&gt;a&lt;/code&gt; &lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="98d9a64e4784c058720be52ad39c03d39a9fcbd1" translate="yes" xml:space="preserve">
          <source>Finally, specific entries can be masked and/or unmasked by assigning to the mask a sequence of booleans:</source>
          <target state="translated">Наконец,определенные записи могут быть замаскированы и/или размаскированы,назначив маске последовательность булеонов:</target>
        </trans-unit>
        <trans-unit id="d4ee797bc2c97cc8f17d94ef802f458cb35c39bc" translate="yes" xml:space="preserve">
          <source>Finally, the decision is made about how to execute the looping mechanism to ensure that all elements of the input arrays are combined to produce the output arrays of the correct type. The options for loop execution are one-loop (for contiguous, aligned, and correct data type), strided-loop (for non-contiguous but still aligned and correct data type), and a buffered loop (for mis-aligned or incorrect data type situations). Depending on which execution method is called for, the loop is then setup and computed.</source>
          <target state="translated">Наконец,принимается решение о том,как выполнить петлевой механизм для обеспечения того,чтобы все элементы входных массивов были объединены для получения выходных массивов правильного типа.Варианты выполнения цикла-одноконтурный цикл (для выравнивания,выравнивания и правильного типа данных),петлевой цикл (для не выравнивания,но выравнивания и правильного типа данных)и буферизованный цикл (для ситуаций с неправильным выравниванием или неправильным типом данных).В зависимости от того,какой метод выполнения вызывается,цикл настраивается и вычисляется.</target>
        </trans-unit>
        <trans-unit id="3616e9f1dcf861efd823c12b4478a31e6b82b402" translate="yes" xml:space="preserve">
          <source>Financial functions</source>
          <target state="translated">Финансовые функции</target>
        </trans-unit>
        <trans-unit id="75334f040026f76d3eebb8839bcb303508014551" translate="yes" xml:space="preserve">
          <source>Find a domain suitable for a polynomial or Chebyshev series defined at the values supplied.</source>
          <target state="translated">Найдите домен,подходящий для полиномиальной или чебышевской серии,определенной по заданным значениям.</target>
        </trans-unit>
        <trans-unit id="c2a6e9c15d888c380a37d1831fa7891adeb9bb51" translate="yes" xml:space="preserve">
          <source>Find contiguous unmasked data in a masked array along the given axis.</source>
          <target state="translated">Поиск смежных размаскированных данных в массиве по заданной оси.</target>
        </trans-unit>
        <trans-unit id="a4ea5a445ce3dee9c559f1f1b3b7f52dca61477d" translate="yes" xml:space="preserve">
          <source>Find elements in a sorted array.</source>
          <target state="translated">Поиск элементов в отсортированном массиве.</target>
        </trans-unit>
        <trans-unit id="48cd38efe59f33f3a5f798ed6a4cf4880d549aa4" translate="yes" xml:space="preserve">
          <source>Find elements in sorted array.</source>
          <target state="translated">Поиск элементов в отсортированном массиве.</target>
        </trans-unit>
        <trans-unit id="f6a5d00a32b708a9fb964c2d1da18b0ebb9fba20" translate="yes" xml:space="preserve">
          <source>Find indices where elements of v should be inserted in a to maintain order.</source>
          <target state="translated">Найти индексы,в которых элементы v должны быть вставлены в порядке.</target>
        </trans-unit>
        <trans-unit id="18d914d41d09d92c97e462c896bc6019f8705e89" translate="yes" xml:space="preserve">
          <source>Find indices where elements should be inserted to maintain order.</source>
          <target state="translated">Поиск индексов,в которые следует вставлять элементы для поддержания порядка.</target>
        </trans-unit>
        <trans-unit id="4372485b0452a2bbbc2898c490d8eaeffc724caf" translate="yes" xml:space="preserve">
          <source>Find the coefficients of a polynomial with a given sequence of roots.</source>
          <target state="translated">Найти коэффициенты многочлена с заданной последовательностью корней.</target>
        </trans-unit>
        <trans-unit id="faa2e8dff7b7635f67ecf147d005df15f99ba737" translate="yes" xml:space="preserve">
          <source>Find the coefficients of a polynomial with the given sequence of roots.</source>
          <target state="translated">Найти коэффициенты многочлена с заданной последовательностью корней.</target>
        </trans-unit>
        <trans-unit id="4eb3d9e0549601789e7c859dc2344bd2a9cd19fd" translate="yes" xml:space="preserve">
          <source>Find the derivative of order &lt;code&gt;m&lt;/code&gt;.</source>
          <target state="translated">Найдите производную порядка &lt;code&gt;m&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8b2e68d5137b01880925e686f099633be3e06dde" translate="yes" xml:space="preserve">
          <source>Find the indices into a sorted array &lt;code&gt;a&lt;/code&gt; such that, if the corresponding elements in &lt;code&gt;v&lt;/code&gt; were inserted before the indices, the order of &lt;code&gt;a&lt;/code&gt; would be preserved.</source>
          <target state="translated">Найдите индексы в отсортированном массиве &lt;code&gt;a&lt;/code&gt; так , чтобы, если соответствующие элементы в &lt;code&gt;v&lt;/code&gt; были вставлены перед индексами, порядок &lt;code&gt;a&lt;/code&gt; был бы сохранен.</target>
        </trans-unit>
        <trans-unit id="7a9d95dd2166bd57167eb2521a394d4c2313d8ed" translate="yes" xml:space="preserve">
          <source>Find the indices of array elements that are non-zero, grouped by element.</source>
          <target state="translated">Найти индексы ненулевых элементов массива,сгруппированных по элементам.</target>
        </trans-unit>
        <trans-unit id="2515b150e246a2efffb14706325a36534baa7e52" translate="yes" xml:space="preserve">
          <source>Find the indices of the first and last unmasked values along an axis.</source>
          <target state="translated">Поиск индексов первого и последнего размаскированных значений по оси.</target>
        </trans-unit>
        <trans-unit id="696f121ac590832370778adcb2254fdcf409cf46" translate="yes" xml:space="preserve">
          <source>Find the indices of the first and last unmasked values.</source>
          <target state="translated">Найти индексы первого и последнего размаскированных значений.</target>
        </trans-unit>
        <trans-unit id="8c77cbf79b427711a4234d92c8cd55031f045a5a" translate="yes" xml:space="preserve">
          <source>Find the intersection of two arrays.</source>
          <target state="translated">Найдите пересечение двух массивов.</target>
        </trans-unit>
        <trans-unit id="1d747b61a4dca9ab1a6c9357e1706a93f4e98f6e" translate="yes" xml:space="preserve">
          <source>Find the product of two polynomials.</source>
          <target state="translated">Найдите продукт из двух полиномов.</target>
        </trans-unit>
        <trans-unit id="f141aa841d4a25a7614625f7b95555f03b44cb1f" translate="yes" xml:space="preserve">
          <source>Find the roots:</source>
          <target state="translated">Найди корни:</target>
        </trans-unit>
        <trans-unit id="e641c4ed98de6b655c0148c1b174236bccd25db9" translate="yes" xml:space="preserve">
          <source>Find the set difference of two arrays.</source>
          <target state="translated">Найдите разницу между двумя массивами.</target>
        </trans-unit>
        <trans-unit id="1d47458289ee93eb8b76d9bd5fb051fb0ed38ef9" translate="yes" xml:space="preserve">
          <source>Find the set exclusive-or of two arrays.</source>
          <target state="translated">Найдите эксклюзивный набор или два массива.</target>
        </trans-unit>
        <trans-unit id="40c6faf7e08f7eff45fa7f2fb510420c1dd0653b" translate="yes" xml:space="preserve">
          <source>Find the sum of two polynomials.</source>
          <target state="translated">Найдите сумму двух полиномов.</target>
        </trans-unit>
        <trans-unit id="bc296de5854442d0290915421679a6d44da683c5" translate="yes" xml:space="preserve">
          <source>Find the union of two arrays.</source>
          <target state="translated">Найди объединение двух массивов.</target>
        </trans-unit>
        <trans-unit id="1c2a1d48695ed18506cd6bf1d2bc59c3cfb89875" translate="yes" xml:space="preserve">
          <source>Find the unique elements of an array.</source>
          <target state="translated">Найти уникальные элементы массива.</target>
        </trans-unit>
        <trans-unit id="3c5a640c918941c9e6a6ecbfe984c3f4bfbed0d7" translate="yes" xml:space="preserve">
          <source>Finding help</source>
          <target state="translated">Помощь в поиске</target>
        </trans-unit>
        <trans-unit id="5b7033e44afb091d2adc537dc898dc007a565a8f" translate="yes" xml:space="preserve">
          <source>Finding masked data</source>
          <target state="translated">Поиск замаскированных данных</target>
        </trans-unit>
        <trans-unit id="3f98684f09d3dc8ddcf467b643533c39f6675211" translate="yes" xml:space="preserve">
          <source>Finds the data type of smallest size and kind to which &lt;em&gt;type1&lt;/em&gt; and &lt;em&gt;type2&lt;/em&gt; may be safely converted. This function is symmetric and associative. A string or unicode result will be the proper size for storing the max value of the input types converted to a string or unicode.</source>
          <target state="translated">Находит тип данных наименьшего размера и типа, в который можно безопасно преобразовать &lt;em&gt;type1&lt;/em&gt; и &lt;em&gt;type2&lt;/em&gt; . Эта функция симметрична и ассоциативна. Результат в виде строки или юникода будет подходящим размером для хранения максимального значения типов ввода, преобразованных в строку или юникод.</target>
        </trans-unit>
        <trans-unit id="ce819b28621d52328ceb9faf1bacb0b89098499a" translate="yes" xml:space="preserve">
          <source>Finds the polynomial resulting from the multiplication of the two input polynomials. Each input must be either a poly1d object or a 1D sequence of polynomial coefficients, from highest to lowest degree.</source>
          <target state="translated">Находит полином,полученный в результате умножения двух входных полиномов.Каждый вход должен быть либо поли1d объектом,либо 1D последовательностью полиномиальных коэффициентов,от высшей до низшей степени.</target>
        </trans-unit>
        <trans-unit id="7f34df28a801d8ac2bf79f8d990420b3ba51454a" translate="yes" xml:space="preserve">
          <source>First adjusts the date to fall on a valid day according to the &lt;code&gt;roll&lt;/code&gt; rule, then applies offsets to the given dates counted in valid days.</source>
          <target state="translated">Сначала настраивает дату, чтобы она приходилась на действительный день в соответствии с правилом &lt;code&gt;roll&lt;/code&gt; , затем применяет смещения к указанным датам, подсчитанным в действительных днях.</target>
        </trans-unit>
        <trans-unit id="3d783583ca6eea2b3fefbcfe238ea095a9cef1e3" translate="yes" xml:space="preserve">
          <source>First argument.</source>
          <target state="translated">Первый аргумент.</target>
        </trans-unit>
        <trans-unit id="b0d88798d2f2c8c94dabdac74a6e61e0c6a796bf" translate="yes" xml:space="preserve">
          <source>First array</source>
          <target state="translated">Первый массив</target>
        </trans-unit>
        <trans-unit id="6ac9adbced8bb3d28582fadcfc79411667f91541" translate="yes" xml:space="preserve">
          <source>First array elements raised to powers from second array, element-wise.</source>
          <target state="translated">Первые элементы массива,поднятые на питание из второго массива,по элементам.</target>
        </trans-unit>
        <trans-unit id="2e663054d84a3a5ee1c34a1c08db3c0840bbd3a5" translate="yes" xml:space="preserve">
          <source>First axis.</source>
          <target state="translated">Первая ось.</target>
        </trans-unit>
        <trans-unit id="683b791e072100a372b3bb52b18b0195b72f135d" translate="yes" xml:space="preserve">
          <source>First data type.</source>
          <target state="translated">Первый тип данных.</target>
        </trans-unit>
        <trans-unit id="c696689a14b681bedf220e6fcb537947492362e7" translate="yes" xml:space="preserve">
          <source>First input vector. Input is flattened if not already 1-dimensional.</source>
          <target state="translated">Первый входной вектор.Входной вектор сплющенный,если еще не 1-мерный.</target>
        </trans-unit>
        <trans-unit id="4da5db5b8e385a1ee882571360fd0091e5988af4" translate="yes" xml:space="preserve">
          <source>First mode, &lt;code&gt;buffer&lt;/code&gt; is None:</source>
          <target state="translated">Первый режим, &lt;code&gt;buffer&lt;/code&gt; отсутствует:</target>
        </trans-unit>
        <trans-unit id="79fb79c693534cb9180b2dc2b3dd92f6526ad678" translate="yes" xml:space="preserve">
          <source>First of all, if confused or uncertain, definitely look at the Examples - in its full generality, this function is less simple than it might seem from the following code description (below ndi = &lt;code&gt;numpy.lib.index_tricks&lt;/code&gt;):</source>
          <target state="translated">Прежде всего, если вы запутались или сомневаетесь, обязательно посмотрите Примеры - в общем, эта функция менее проста, чем может показаться из следующего описания кода (ниже &lt;code&gt;numpy.lib.index_tricks&lt;/code&gt; = numpy.lib.index_tricks ):</target>
        </trans-unit>
        <trans-unit id="9507aadaef3c19b4ad781014173284bb4bf64a4d" translate="yes" xml:space="preserve">
          <source>First one-dimensional input array.</source>
          <target state="translated">Первый одномерный входной массив.</target>
        </trans-unit>
        <trans-unit id="563237e589c4b3a10445b43e30dbcdf140e6cad9" translate="yes" xml:space="preserve">
          <source>First we need a polynomial class and a polynomial instance to play with. The classes can be imported directly from the polynomial package or from the module of the relevant type. Here we import from the package and use the conventional Polynomial class because of its familiarity:</source>
          <target state="translated">Для начала нам нужен класс полинома и экземпляр полинома.Классы могут быть импортированы непосредственно из полиномиального пакета или из модуля соответствующего типа.Здесь мы импортируем из пакета и используем обычный класс полинома из-за его известности:</target>
        </trans-unit>
        <trans-unit id="0b5747b08f0749ca8d3f849c4ccb46feb2a535fd" translate="yes" xml:space="preserve">
          <source>First, we solve for</source>
          <target state="translated">Во-первых,мы решаем для</target>
        </trans-unit>
        <trans-unit id="2b876747d103212266850792bf08c2d985fdb7ec" translate="yes" xml:space="preserve">
          <source>Fisher, R.A,, A.S. Corbet, and C.B. Williams. 1943. The relation between the number of species and the number of individuals in a random sample of an animal population. Journal of Animal Ecology, 12:42-58.</source>
          <target state="translated">Фишер,Р.А.,А.С.Корбет и К.Б.Уильямс.1943.Соотношение между числом видов и числом особей в случайной выборке популяции животных.Журнал экологии животных,12:42-58.</target>
        </trans-unit>
        <trans-unit id="1c009756385026adf817423fdf3347327b7bcadd" translate="yes" xml:space="preserve">
          <source>Fit a line, &lt;code&gt;y = mx + c&lt;/code&gt;, through some noisy data-points:</source>
          <target state="translated">Проведите линию &lt;code&gt;y = mx + c&lt;/code&gt; через несколько зашумленных точек данных:</target>
        </trans-unit>
        <trans-unit id="04b6a58e5360946679575e2105b73e661e63702d" translate="yes" xml:space="preserve">
          <source>Fit a polynomial &lt;code&gt;p(x) = p[0] * x**deg + ... + p[deg]&lt;/code&gt; of degree &lt;code&gt;deg&lt;/code&gt; to points &lt;code&gt;(x, y)&lt;/code&gt;. Returns a vector of coefficients &lt;code&gt;p&lt;/code&gt; that minimises the squared error in the order &lt;code&gt;deg&lt;/code&gt;, &lt;code&gt;deg-1&lt;/code&gt;, &amp;hellip; &lt;code&gt;0&lt;/code&gt;.</source>
          <target state="translated">Подобрать многочлен &lt;code&gt;p(x) = p[0] * x**deg + ... + p[deg]&lt;/code&gt; степени &lt;code&gt;deg&lt;/code&gt; к точкам &lt;code&gt;(x, y)&lt;/code&gt; . Возвращает вектор коэффициентов &lt;code&gt;p&lt;/code&gt; , который минимизирует квадрат ошибки в порядке &lt;code&gt;deg&lt;/code&gt; , &lt;code&gt;deg-1&lt;/code&gt; ,&amp;hellip; &lt;code&gt;0&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c63bb8e80d7458f568a44355aa0204375070cb16" translate="yes" xml:space="preserve">
          <source>Fits using Chebyshev series are usually better conditioned than fits using power series, but much can depend on the distribution of the sample points and the smoothness of the data. If the quality of the fit is inadequate splines may be a good alternative.</source>
          <target state="translated">Подгонки с использованием чебышевских серий обычно лучше обусловлены,чем подгонки с использованием силовых серий,но многое может зависеть от распределения точек выборки и гладкости данных.Если качество подгонки неудовлетворительное,то хорошей альтернативой могут быть сплайны.</target>
        </trans-unit>
        <trans-unit id="7ac350719f356e32b4a5aa08bc22f253d0d0c702" translate="yes" xml:space="preserve">
          <source>Fits using Hermite series are probably most useful when the data can be approximated by &lt;code&gt;sqrt(w(x)) * p(x)&lt;/code&gt;, where &lt;code&gt;w(x)&lt;/code&gt; is the Hermite weight. In that case the weight &lt;code&gt;sqrt(w(x[i])&lt;/code&gt; should be used together with data values &lt;code&gt;y[i]/sqrt(w(x[i])&lt;/code&gt;. The weight function is available as &lt;a href=&quot;numpy.polynomial.hermite.hermweight#numpy.polynomial.hermite.hermweight&quot;&gt;&lt;code&gt;hermweight&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Подборы с использованием ряда Эрмита, вероятно, наиболее полезны, когда данные могут быть аппроксимированы как &lt;code&gt;sqrt(w(x)) * p(x)&lt;/code&gt; , где &lt;code&gt;w(x)&lt;/code&gt; - это вес Эрмита. В этом случае вес &lt;code&gt;sqrt(w(x[i])&lt;/code&gt; должен использоваться вместе со значениями данных &lt;code&gt;y[i]/sqrt(w(x[i])&lt;/code&gt; . Весовая функция доступна как &lt;a href=&quot;numpy.polynomial.hermite.hermweight#numpy.polynomial.hermite.hermweight&quot;&gt; &lt;code&gt;hermweight&lt;/code&gt; )&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="676d43f6371871e1abab21b58a8b9ef9e5c444e9" translate="yes" xml:space="preserve">
          <source>Fits using HermiteE series are probably most useful when the data can be approximated by &lt;code&gt;sqrt(w(x)) * p(x)&lt;/code&gt;, where &lt;code&gt;w(x)&lt;/code&gt; is the HermiteE weight. In that case the weight &lt;code&gt;sqrt(w(x[i])&lt;/code&gt; should be used together with data values &lt;code&gt;y[i]/sqrt(w(x[i])&lt;/code&gt;. The weight function is available as &lt;a href=&quot;numpy.polynomial.hermite_e.hermeweight#numpy.polynomial.hermite_e.hermeweight&quot;&gt;&lt;code&gt;hermeweight&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Подборы с использованием серии HermiteE, вероятно, наиболее полезны, когда данные можно аппроксимировать с помощью &lt;code&gt;sqrt(w(x)) * p(x)&lt;/code&gt; , где &lt;code&gt;w(x)&lt;/code&gt; - это вес HermiteE. В этом случае вес &lt;code&gt;sqrt(w(x[i])&lt;/code&gt; должен использоваться вместе со значениями данных &lt;code&gt;y[i]/sqrt(w(x[i])&lt;/code&gt; . Весовая функция доступна как &lt;a href=&quot;numpy.polynomial.hermite_e.hermeweight#numpy.polynomial.hermite_e.hermeweight&quot;&gt; &lt;code&gt;hermeweight&lt;/code&gt; )&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="a6ad2d45b7ba84d02856af83a31db48500b6c521" translate="yes" xml:space="preserve">
          <source>Fits using Laguerre series are probably most useful when the data can be approximated by &lt;code&gt;sqrt(w(x)) * p(x)&lt;/code&gt;, where &lt;code&gt;w(x)&lt;/code&gt; is the Laguerre weight. In that case the weight &lt;code&gt;sqrt(w(x[i])&lt;/code&gt; should be used together with data values &lt;code&gt;y[i]/sqrt(w(x[i])&lt;/code&gt;. The weight function is available as &lt;a href=&quot;numpy.polynomial.laguerre.lagweight#numpy.polynomial.laguerre.lagweight&quot;&gt;&lt;code&gt;lagweight&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Подборы с использованием ряда Лагерра, вероятно, наиболее полезны, когда данные могут быть аппроксимированы с помощью &lt;code&gt;sqrt(w(x)) * p(x)&lt;/code&gt; , где &lt;code&gt;w(x)&lt;/code&gt; - вес Лагерра. В этом случае вес &lt;code&gt;sqrt(w(x[i])&lt;/code&gt; должен использоваться вместе со значениями данных &lt;code&gt;y[i]/sqrt(w(x[i])&lt;/code&gt; . Весовая функция доступна как &lt;a href=&quot;numpy.polynomial.laguerre.lagweight#numpy.polynomial.laguerre.lagweight&quot;&gt; &lt;code&gt;lagweight&lt;/code&gt; )&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="a49cebd2c0a64b6ed696a25d8e9c66d10c8d54a0" translate="yes" xml:space="preserve">
          <source>Fits using Legendre series are usually better conditioned than fits using power series, but much can depend on the distribution of the sample points and the smoothness of the data. If the quality of the fit is inadequate splines may be a good alternative.</source>
          <target state="translated">Подгонки с использованием серии Legendre обычно лучше,чем подгонки с использованием серии Power,но многое может зависеть от распределения точек выборки и гладкости данных.Если качество подгонки неудовлетворительное,то хорошей альтернативой могут быть сплайны.</target>
        </trans-unit>
        <trans-unit id="5165daf49b08b1322899a60f534d050a344807b1" translate="yes" xml:space="preserve">
          <source>Fitting</source>
          <target state="translated">Fitting</target>
        </trans-unit>
        <trans-unit id="5e51f96db68dc8fabd62d003884216322595fc6f" translate="yes" xml:space="preserve">
          <source>Fitting is the reason that the &lt;code&gt;domain&lt;/code&gt; and &lt;code&gt;window&lt;/code&gt; attributes are part of the convenience classes. To illustrate the problem, the values of the Chebyshev polynomials up to degree 5 are plotted below.</source>
          <target state="translated">Подгонка является причиной того, что атрибуты &lt;code&gt;domain&lt;/code&gt; и &lt;code&gt;window&lt;/code&gt; являются частью вспомогательных классов. Для иллюстрации проблемы ниже приведены значения полиномов Чебышева до степени 5.</target>
        </trans-unit>
        <trans-unit id="4fa2ab2730080c4d8658ad57247e52d05152019e" translate="yes" xml:space="preserve">
          <source>Fixed stride displacement from the beginning of an axis? Default is 0. Needs to be &amp;gt;=0.</source>
          <target state="translated">Исправлено смещение шага от начала оси? По умолчанию 0. Должно быть&amp;gt; = 0.</target>
        </trans-unit>
        <trans-unit id="35076585aaced59b92c591cb61ebdef18acdfe9a" translate="yes" xml:space="preserve">
          <source>Flag checking</source>
          <target state="translated">проверка флагов</target>
        </trans-unit>
        <trans-unit id="a59933a6089d6095752a4cce71d3ac903e7e62ac" translate="yes" xml:space="preserve">
          <source>Flag indicating the return a legacy tuple state when the BitGenerator is MT19937.</source>
          <target state="translated">Флаг,указывающий на возврат кортежа в старое состояние,когда BitGenerator имеет MT19937.</target>
        </trans-unit>
        <trans-unit id="9eae779d408b29132a4d17f05274c96311b19164" translate="yes" xml:space="preserve">
          <source>Flag indicating whether a tuple &lt;code&gt;(result, sum of weights)&lt;/code&gt; should be returned as output (True), or just the result (False). Default is False.</source>
          <target state="translated">Флаг, указывающий, должен ли кортеж &lt;code&gt;(result, sum of weights)&lt;/code&gt; возвращаться как результат (True) или только результат (False). По умолчанию - False.</target>
        </trans-unit>
        <trans-unit id="cba3c052d7e9a9fd1a29828876ef83802ed53ad9" translate="yes" xml:space="preserve">
          <source>Flag to determine whether to mark test as deprecated or not. If the condition is a callable, it is used at runtime to dynamically make the decision. Default is True.</source>
          <target state="translated">Флаг для определения того,следует ли маркировать тест как устаревший или нет.Если условие является вызываемым,то оно используется во время выполнения для динамического принятия решения.По умолчанию установлено значение True.</target>
        </trans-unit>
        <trans-unit id="fc63716a41208b1dbc0ebbf61137c2d0ff0fbfd4" translate="yes" xml:space="preserve">
          <source>Flag to determine whether to mark the decorated test as a known failure (if True) or not (if False).</source>
          <target state="translated">Флаг для определения того,следует ли маркировать декорированный тест как известную неудачу (если Верно)или нет (если Ложно).</target>
        </trans-unit>
        <trans-unit id="3a36aef11ecfbbf2d82d57b5084b3ab96e773b04" translate="yes" xml:space="preserve">
          <source>Flag to determine whether to skip the decorated test.</source>
          <target state="translated">Флаг,чтобы определить,стоит ли пропустить декорированный тест.</target>
        </trans-unit>
        <trans-unit id="75e57359674e825c88bcaaa1bf354a5ba42abc10" translate="yes" xml:space="preserve">
          <source>Flag-like constants</source>
          <target state="translated">флагманские константы</target>
        </trans-unit>
        <trans-unit id="684f757afc22b26a0ad180a11e58599da12d805b" translate="yes" xml:space="preserve">
          <source>Flags indicating how the memory pointed to by data is to be interpreted. Possible flags are &lt;a href=&quot;c-api.array#c.NPY_ARRAY_C_CONTIGUOUS&quot;&gt;&lt;code&gt;NPY_ARRAY_C_CONTIGUOUS&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;c-api.array#c.NPY_ARRAY_F_CONTIGUOUS&quot;&gt;&lt;code&gt;NPY_ARRAY_F_CONTIGUOUS&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;c-api.array#c.NPY_ARRAY_OWNDATA&quot;&gt;&lt;code&gt;NPY_ARRAY_OWNDATA&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;c-api.array#c.NPY_ARRAY_ALIGNED&quot;&gt;&lt;code&gt;NPY_ARRAY_ALIGNED&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;c-api.array#c.NPY_ARRAY_WRITEABLE&quot;&gt;&lt;code&gt;NPY_ARRAY_WRITEABLE&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;c-api.array#c.NPY_ARRAY_WRITEBACKIFCOPY&quot;&gt;&lt;code&gt;NPY_ARRAY_WRITEBACKIFCOPY&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;c-api.array#c.NPY_ARRAY_UPDATEIFCOPY&quot;&gt;&lt;code&gt;NPY_ARRAY_UPDATEIFCOPY&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Флаги, указывающие, как следует интерпретировать память, на которую указывают данные. Возможные флаги: &lt;a href=&quot;c-api.array#c.NPY_ARRAY_C_CONTIGUOUS&quot;&gt; &lt;code&gt;NPY_ARRAY_C_CONTIGUOUS&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;c-api.array#c.NPY_ARRAY_F_CONTIGUOUS&quot;&gt; &lt;code&gt;NPY_ARRAY_F_CONTIGUOUS&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;c-api.array#c.NPY_ARRAY_OWNDATA&quot;&gt; &lt;code&gt;NPY_ARRAY_OWNDATA&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;c-api.array#c.NPY_ARRAY_ALIGNED&quot;&gt; &lt;code&gt;NPY_ARRAY_ALIGNED&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;c-api.array#c.NPY_ARRAY_WRITEABLE&quot;&gt; &lt;code&gt;NPY_ARRAY_WRITEABLE&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;c-api.array#c.NPY_ARRAY_WRITEBACKIFCOPY&quot;&gt; &lt;code&gt;NPY_ARRAY_WRITEBACKIFCOPY&lt;/code&gt; &lt;/a&gt; и &lt;a href=&quot;c-api.array#c.NPY_ARRAY_UPDATEIFCOPY&quot;&gt; &lt;code&gt;NPY_ARRAY_UPDATEIFCOPY&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="a25e18657a4cd94e4091eda9ea0dfb9fbc2878ec" translate="yes" xml:space="preserve">
          <source>Flags that may be passed in &lt;code&gt;flags&lt;/code&gt; are any combination of the global and per-operand flags documented in &lt;a href=&quot;#c.NpyIter_MultiNew&quot;&gt;&lt;code&gt;NpyIter_MultiNew&lt;/code&gt;&lt;/a&gt;, except for &lt;a href=&quot;#c.NPY_ITER_ALLOCATE&quot;&gt;&lt;code&gt;NPY_ITER_ALLOCATE&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Флаги, которые могут быть переданы в &lt;code&gt;flags&lt;/code&gt; , представляют собой любую комбинацию глобальных флагов и флагов для каждого операнда, задокументированных в &lt;a href=&quot;#c.NpyIter_MultiNew&quot;&gt; &lt;code&gt;NpyIter_MultiNew&lt;/code&gt; &lt;/a&gt; , за исключением &lt;a href=&quot;#c.NPY_ITER_ALLOCATE&quot;&gt; &lt;code&gt;NPY_ITER_ALLOCATE&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="edc811e4e9d890d1a74c59122b943f93451db31b" translate="yes" xml:space="preserve">
          <source>Flags that may be passed in &lt;code&gt;flags&lt;/code&gt;, applying to the whole iterator, are:</source>
          <target state="translated">Флаги, которые могут быть переданы во &lt;code&gt;flags&lt;/code&gt; , применительно ко всему итератору:</target>
        </trans-unit>
        <trans-unit id="e576896ed3787e8ae91c02c3fee7275b55ae4f5d" translate="yes" xml:space="preserve">
          <source>Flags that may be passed in &lt;code&gt;op_flags[i]&lt;/code&gt;, where &lt;code&gt;0 &amp;lt;= i &amp;lt; nop&lt;/code&gt;:</source>
          <target state="translated">Флаги, которые могут быть переданы в &lt;code&gt;op_flags[i]&lt;/code&gt; , где &lt;code&gt;0 &amp;lt;= i &amp;lt; nop&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="0902dde9b75159ba7b0f6af69bd12aa3aed3ab46" translate="yes" xml:space="preserve">
          <source>Flags to control the behavior of the iterator.</source>
          <target state="translated">Флаги для контроля поведения итератора.</target>
        </trans-unit>
        <trans-unit id="1bbaad527fcacc3d77ae0f546c2f20b2e4ef2d71" translate="yes" xml:space="preserve">
          <source>Flat Iterator indexing</source>
          <target state="translated">Плоская индексация итератора</target>
        </trans-unit>
        <trans-unit id="ca0541280577eeacfb45501ad1950007e690905f" translate="yes" xml:space="preserve">
          <source>Flat array iterator.</source>
          <target state="translated">Плоский итератор массива.</target>
        </trans-unit>
        <trans-unit id="3f8292fdeb383ecef90303832ffb1117799af185" translate="yes" xml:space="preserve">
          <source>Flat iteration</source>
          <target state="translated">Плоская итерация</target>
        </trans-unit>
        <trans-unit id="666002e8705384831180e281fa74a843e3206b27" translate="yes" xml:space="preserve">
          <source>Flat iterator object to iterate over arrays.</source>
          <target state="translated">Плоский объект итератора для итераций по массивам.</target>
        </trans-unit>
        <trans-unit id="ec4ad130c0f4e03f5e84c5e86d9264a95dc6c3f6" translate="yes" xml:space="preserve">
          <source>Flattened version of this function.</source>
          <target state="translated">Плоская версия этой функции.</target>
        </trans-unit>
        <trans-unit id="21fe615f2b66ecf8096308ee67f646d6664a1077" translate="yes" xml:space="preserve">
          <source>Flip an array horizontally (axis=1).</source>
          <target state="translated">Переверните массив по горизонтали (ось=1).</target>
        </trans-unit>
        <trans-unit id="7849c3ad46cd56097aefd350ce5a24872c1a9619" translate="yes" xml:space="preserve">
          <source>Flip an array horizontally.</source>
          <target state="translated">Переверните массив горизонтально.</target>
        </trans-unit>
        <trans-unit id="a25cec9261711d7c64f4f0328d27630ff4251008" translate="yes" xml:space="preserve">
          <source>Flip an array vertically (axis=0).</source>
          <target state="translated">Переверните массив по вертикали (ось=0).</target>
        </trans-unit>
        <trans-unit id="58f1196dc69384b1c0ff7122abf54115c6fe24e6" translate="yes" xml:space="preserve">
          <source>Flip an array vertically.</source>
          <target state="translated">Переверните массив вертикально.</target>
        </trans-unit>
        <trans-unit id="054ba7b0cd3f0b3aa1e4b17f975a52c4e03f8b87" translate="yes" xml:space="preserve">
          <source>Flip array in the left/right direction.</source>
          <target state="translated">Переверните массив в направлении влево/вправо.</target>
        </trans-unit>
        <trans-unit id="a71aa214a7a981c7e5292f4c8603043e9a55d042" translate="yes" xml:space="preserve">
          <source>Flip array in the up/down direction.</source>
          <target state="translated">Перевернуть массив в направлении вверх/вниз.</target>
        </trans-unit>
        <trans-unit id="d6b601389a5cfb7f115ef7332083ae3431e4e4e3" translate="yes" xml:space="preserve">
          <source>Flip the entries in each column in the up/down direction. Rows are preserved, but appear in a different order than before.</source>
          <target state="translated">Переверните записи в каждом столбце в направлении вверх/вниз.Строки сохраняются,но появляются в другом порядке,чем раньше.</target>
        </trans-unit>
        <trans-unit id="f14bb6de935d5a8cea7f1dc6e4323a38f4e11462" translate="yes" xml:space="preserve">
          <source>Flip the entries in each row in the left/right direction. Columns are preserved, but appear in a different order than before.</source>
          <target state="translated">Переверните записи в каждой строке влево/вправо.Столбцы сохраняются,но появляются в другом порядке,чем раньше.</target>
        </trans-unit>
        <trans-unit id="3a7d4f9efa22847d513f86cb336f4d917bb3ff00" translate="yes" xml:space="preserve">
          <source>Float type code to coerce input array &lt;code&gt;a&lt;/code&gt;. If &lt;a href=&quot;numpy.dtype#numpy.dtype&quot;&gt;&lt;code&gt;dtype&lt;/code&gt;&lt;/a&gt; is one of the &amp;lsquo;int&amp;rsquo; dtypes, it is replaced with float64.</source>
          <target state="translated">Код типа с плавающей запятой для приведения входного массива &lt;code&gt;a&lt;/code&gt; . Если &lt;a href=&quot;numpy.dtype#numpy.dtype&quot;&gt; &lt;code&gt;dtype&lt;/code&gt; &lt;/a&gt; является одним из dtypes 'int', он заменяется на float64.</target>
        </trans-unit>
        <trans-unit id="01625a6e71519a2c19afcda12e2e9da94df799dc" translate="yes" xml:space="preserve">
          <source>Floating functions</source>
          <target state="translated">Плавающие функции</target>
        </trans-unit>
        <trans-unit id="0c47a1b436ef0cc135c28b0dd8fa381311e23c7a" translate="yes" xml:space="preserve">
          <source>Floating point</source>
          <target state="translated">Плавающая запятая</target>
        </trans-unit>
        <trans-unit id="1229245ed91cf5c1f6662011b64e640e64679fd2" translate="yes" xml:space="preserve">
          <source>Floating point classification</source>
          <target state="translated">Классификация с плавающей запятой</target>
        </trans-unit>
        <trans-unit id="82951541de1b33acb443a62a7f1b908de9e19ba0" translate="yes" xml:space="preserve">
          <source>Floating point error handling</source>
          <target state="translated">Обработка ошибок с плавающей запятой</target>
        </trans-unit>
        <trans-unit id="dbe05d916add7aed11140c3ac753c505841f4681" translate="yes" xml:space="preserve">
          <source>Floating point number &lt;code&gt;beta**minexp&lt;/code&gt; (the smallest [in magnitude] usable floating value).</source>
          <target state="translated">Число с плавающей запятой &lt;code&gt;beta**minexp&lt;/code&gt; (наименьшее [по величине] используемое плавающее значение).</target>
        </trans-unit>
        <trans-unit id="1fd86bfd9f81a559ed8b4c9674c5d1f9e823b143" translate="yes" xml:space="preserve">
          <source>Floating point precision can be set:</source>
          <target state="translated">Точность с плавающей точкой может быть установлена:</target>
        </trans-unit>
        <trans-unit id="481d82b2ccb68e7d8e1fe5eda973bb77f53833f0" translate="yes" xml:space="preserve">
          <source>Floating point precision. Defaults to &lt;code&gt;numpy.get_printoptions()['precision']&lt;/code&gt;.</source>
          <target state="translated">Точность с плавающей запятой. По умолчанию &lt;code&gt;numpy.get_printoptions()['precision']&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6770ad9e8703a79e53fa3beb7d8e8f53215f921c" translate="yes" xml:space="preserve">
          <source>Floating point routines</source>
          <target state="translated">Программы с плавающей точкой</target>
        </trans-unit>
        <trans-unit id="bbb20a81d8b5780d9de2483bc5cafd120d0cd965" translate="yes" xml:space="preserve">
          <source>Floating point values are not demoted to integers, and complex values are not demoted to floats.</source>
          <target state="translated">Значения с плавающей точкой не понижаются до целых чисел,а сложные значения не понижаются до плавающих.</target>
        </trans-unit>
        <trans-unit id="2a6aa48e3a6c80756547c7551fe79b07bb4f3a1c" translate="yes" xml:space="preserve">
          <source>Floating values between -1 and 1. This is a scalar if &lt;code&gt;x&lt;/code&gt; is a scalar.</source>
          <target state="translated">Плавающие значения от -1 до 1. Это скаляр, если &lt;code&gt;x&lt;/code&gt; - скаляр.</target>
        </trans-unit>
        <trans-unit id="e6f0281f3f5728d7cb1a3465fbf569e0196bf3cd" translate="yes" xml:space="preserve">
          <source>Floating-point number &lt;code&gt;beta**machep&lt;/code&gt; (floating point precision)</source>
          <target state="translated">Число с плавающей запятой &lt;code&gt;beta**machep&lt;/code&gt; (точность с плавающей запятой)</target>
        </trans-unit>
        <trans-unit id="f8899b4f72c4b482d21d27616c70625d6596dd90" translate="yes" xml:space="preserve">
          <source>Floating-point number &lt;code&gt;beta**negep&lt;/code&gt;.</source>
          <target state="translated">Число с плавающей запятой &lt;code&gt;beta**negep&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2eae9dc4dc291f4562016bea57ea67a7a3b1f88f" translate="yes" xml:space="preserve">
          <source>Floating-point numbers:</source>
          <target state="translated">Числа с плавающей точкой:</target>
        </trans-unit>
        <trans-unit id="55734ad7ec5ec7776c0a844d3df4e815b482074b" translate="yes" xml:space="preserve">
          <source>Floats uniformly distributed over &lt;code&gt;[0, 1)&lt;/code&gt;.</source>
          <target state="translated">Поплавки равномерно распределены на &lt;code&gt;[0, 1)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9c505c67e9b4dbb54495e1dc42c80f1a7a1c454f" translate="yes" xml:space="preserve">
          <source>Floor divide self by other in-place.</source>
          <target state="translated">Пол делится на другой на месте.</target>
        </trans-unit>
        <trans-unit id="1ddc7d58e45f89f16199c2075dcd43275a50c059" translate="yes" xml:space="preserve">
          <source>Floor division, &amp;lsquo;//&amp;rsquo;, is the division operator for the polynomial classes, polynomials are treated like integers in this regard. For Python versions &amp;lt; 3.x the &amp;lsquo;/&amp;rsquo; operator maps to &amp;lsquo;//&amp;rsquo;, as it does for Python, for later versions the &amp;lsquo;/&amp;rsquo; will only work for division by scalars. At some point it will be deprecated:</source>
          <target state="translated">Деление этажа, '//', является оператором деления для классов полиномов, в этом отношении полиномы рассматриваются как целые числа. Для версий Python &amp;lt;3.x оператор '/' отображается на '//', как и для Python, для более поздних версий '/' будет работать только для деления на скаляры. В какой-то момент он станет устаревшим:</target>
        </trans-unit>
        <trans-unit id="977e7ae24b1ce53baf0769e85a5d553c0c1ba1a9" translate="yes" xml:space="preserve">
          <source>Following each integration the result is &lt;em&gt;multiplied&lt;/em&gt; by &lt;code&gt;scl&lt;/code&gt; before the integration constant is added. (Default: 1)</source>
          <target state="translated">После каждого интегрирования результат &lt;em&gt;умножается&lt;/em&gt; на &lt;code&gt;scl&lt;/code&gt; перед добавлением константы интегрирования. (По умолчанию: 1)</target>
        </trans-unit>
        <trans-unit id="0edda5efdca0ba777ab89777b73ae8abb0ac8170" translate="yes" xml:space="preserve">
          <source>Following the header comes the array data. If the dtype contains Python objects (i.e. &lt;code&gt;dtype.hasobject is True&lt;/code&gt;), then the data is a Python pickle of the array. Otherwise the data is the contiguous (either C- or Fortran-, depending on &lt;code&gt;fortran_order&lt;/code&gt;) bytes of the array. Consumers can figure out the number of bytes by multiplying the number of elements given by the shape (noting that &lt;code&gt;shape=()&lt;/code&gt; means there is 1 element) by &lt;code&gt;dtype.itemsize&lt;/code&gt;.</source>
          <target state="translated">После заголовка идет массив данных. Если dtype содержит объекты Python (т. &lt;code&gt;dtype.hasobject is True&lt;/code&gt; ), то данные представляют собой расслоение массива Python. В противном случае данные представляют собой непрерывные (либо C-, либо Fortran-, в зависимости от &lt;code&gt;fortran_order&lt;/code&gt; ) байты массива. Потребители могут вычислить количество байтов, умножив количество элементов, заданных формой (учитывая, что &lt;code&gt;shape=()&lt;/code&gt; означает, что существует 1 элемент) на &lt;code&gt;dtype.itemsize&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1e3737ce90be5e40d3542337b2a16d0ddfea15fe" translate="yes" xml:space="preserve">
          <source>For 18 of the 21 types this number is fixed by the data-type. For the flexible data-types, this number can be anything.</source>
          <target state="translated">Для 18 из 21 типа это число фиксируется типом данных.Для гибких типов данных это число может быть любым.</target>
        </trans-unit>
        <trans-unit id="6fe31cdcb6c6646809088d5903655d52a55d450e" translate="yes" xml:space="preserve">
          <source>For 2-D arrays it is the matrix product:</source>
          <target state="translated">Для 2-D массивов это матричный продукт:</target>
        </trans-unit>
        <trans-unit id="3f962aedbf83ef9d65d44b9e69490919cc79f9a0" translate="yes" xml:space="preserve">
          <source>For 2-D mixed with 1-D, the result is the usual.</source>
          <target state="translated">Для 2-D,смешанных с 1-D,результат будет обычным.</target>
        </trans-unit>
        <trans-unit id="249d7389fa64403ab6c1fc03103e6db107907e49" translate="yes" xml:space="preserve">
          <source>For 8-bit strings, this method is locale-dependent.</source>
          <target state="translated">Для 8-битных строк этот метод является локально зависимым.</target>
        </trans-unit>
        <trans-unit id="e34d3054bfe352b99ce08082d1411334b317ca53" translate="yes" xml:space="preserve">
          <source>For &lt;code&gt;A&lt;/code&gt; and &lt;code&gt;B&lt;/code&gt; one-dimensional, this is equivalent to:</source>
          <target state="translated">Для одномерных &lt;code&gt;A&lt;/code&gt; и &lt;code&gt;B&lt;/code&gt; это эквивалентно:</target>
        </trans-unit>
        <trans-unit id="a6fa074fdf944e6525f90fb53e3868628cc3a171" translate="yes" xml:space="preserve">
          <source>For &lt;code&gt;a.view(some_dtype)&lt;/code&gt;, if &lt;code&gt;some_dtype&lt;/code&gt; has a different number of bytes per entry than the previous dtype (for example, converting a regular array to a structured array), then the behavior of the view cannot be predicted just from the superficial appearance of &lt;code&gt;a&lt;/code&gt; (shown by &lt;code&gt;print(a)&lt;/code&gt;). It also depends on exactly how &lt;code&gt;a&lt;/code&gt; is stored in memory. Therefore if &lt;code&gt;a&lt;/code&gt; is C-ordered versus fortran-ordered, versus defined as a slice or transpose, etc., the view may give different results.</source>
          <target state="translated">Для &lt;code&gt;a.view(some_dtype)&lt;/code&gt; , если &lt;code&gt;some_dtype&lt;/code&gt; имеет другое количество байтов на запись, чем предыдущий dtype (например, преобразование обычного массива в структурированный массив), то поведение представления не может быть предсказано только по внешнему виду of &lt;code&gt;a&lt;/code&gt; (показано &lt;code&gt;print(a)&lt;/code&gt; ). Это также зависит от того, как именно хранится в памяти. Поэтому, если &lt;code&gt;a&lt;/code&gt; является C-упорядоченным по сравнению с упорядоченным по формуле, по сравнению с определением как срез или транспонирование и т. Д., Представление может давать разные результаты. &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="272593adff1434bde1d4cd33b0346e0c6d20e042" translate="yes" xml:space="preserve">
          <source>For &lt;code&gt;e, E&lt;/code&gt; and &lt;code&gt;f&lt;/code&gt; specifiers, the number of digits to print after the decimal point.</source>
          <target state="translated">Для спецификаторов &lt;code&gt;e, E&lt;/code&gt; и &lt;code&gt;f&lt;/code&gt; - количество печатаемых цифр после десятичной точки.</target>
        </trans-unit>
        <trans-unit id="a8b87fa4bee96c31297a2faf4474562d50259437" translate="yes" xml:space="preserve">
          <source>For &lt;code&gt;g&lt;/code&gt; and &lt;code&gt;G&lt;/code&gt;, the maximum number of significant digits.</source>
          <target state="translated">Для &lt;code&gt;g&lt;/code&gt; и &lt;code&gt;G&lt;/code&gt; максимальное количество значащих цифр.</target>
        </trans-unit>
        <trans-unit id="2f16f572df2de5dbe71ab6b482a26aade3788153" translate="yes" xml:space="preserve">
          <source>For &lt;code&gt;s&lt;/code&gt;, the maximum number of characters.</source>
          <target state="translated">Для &lt;code&gt;s&lt;/code&gt; максимальное количество символов.</target>
        </trans-unit>
        <trans-unit id="96de2b474663e4b27c100d387c234e173e9360ba" translate="yes" xml:space="preserve">
          <source>For NumPy &amp;gt;= 1.10.0 a view of &lt;code&gt;a&lt;/code&gt; is always returned. For earlier NumPy versions a view of &lt;code&gt;a&lt;/code&gt; is returned only if the order of the axes is changed, otherwise the input array is returned.</source>
          <target state="translated">Для NumPy&amp;gt; = 1.10.0 вид всегда возвращается. Для более ранних версий NumPy представление &lt;code&gt;a&lt;/code&gt; возвращается только при изменении порядка осей, в противном случае возвращается входной массив. &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="187181bc029dad6f61070b7f6592eecd79b97aa5" translate="yes" xml:space="preserve">
          <source>For NumPy &amp;gt;= 1.10.0, if &lt;code&gt;a&lt;/code&gt; is an ndarray, then a view of &lt;code&gt;a&lt;/code&gt; is returned; otherwise a new array is created. For earlier NumPy versions a view of &lt;code&gt;a&lt;/code&gt; is returned only if the order of the axes is changed, otherwise the input array is returned.</source>
          <target state="translated">Для NumPy&amp;gt; = 1.10.0, если &lt;code&gt;a&lt;/code&gt; является ndarray, то возвращается представление &lt;code&gt;a&lt;/code&gt; ; в противном случае создается новый массив. Для более ранних версий NumPy представление &lt;code&gt;a&lt;/code&gt; возвращается только при изменении порядка осей, в противном случае возвращается входной массив.</target>
        </trans-unit>
        <trans-unit id="54f70af9beed617bc137c199798e6f21c9093a8c" translate="yes" xml:space="preserve">
          <source>For Python, the preferred way of handling contiguous (or technically, &lt;em&gt;strided&lt;/em&gt;) blocks of homogeneous data is with NumPy, which provides full object-oriented access to multidimensial arrays of data. Therefore, the most logical Python interface for the &lt;code&gt;rms&lt;/code&gt; function would be (including doc string):</source>
          <target state="translated">Для Python предпочтительным способом обработки смежных (или технически &lt;em&gt;разделенных&lt;/em&gt; ) блоков однородных данных является NumPy, который обеспечивает полный объектно-ориентированный доступ к многомерным массивам данных. Следовательно, наиболее логичным интерфейсом Python для функции &lt;code&gt;rms&lt;/code&gt; будет (включая строку документа):</target>
        </trans-unit>
        <trans-unit id="55f9e5f045d92376c7d38dda0f2622f9b6352be6" translate="yes" xml:space="preserve">
          <source>For a 1-D array this has no effect, as a transposed vector is simply the same vector. To convert a 1-D array into a 2D column vector, an additional dimension must be added. &lt;code&gt;np.atleast2d(a).T&lt;/code&gt; achieves this, as does &lt;code&gt;a[:, np.newaxis]&lt;/code&gt;. For a 2-D array, this is a standard matrix transpose. For an n-D array, if axes are given, their order indicates how the axes are permuted (see Examples). If axes are not provided and &lt;code&gt;a.shape = (i[0], i[1], ... i[n-2], i[n-1])&lt;/code&gt;, then &lt;code&gt;a.transpose().shape = (i[n-1], i[n-2], ... i[1], i[0])&lt;/code&gt;.</source>
          <target state="translated">Для одномерного массива это не имеет никакого эффекта, поскольку транспонированный вектор - это просто тот же вектор. Чтобы преобразовать одномерный массив в двухмерный вектор-столбец, необходимо добавить дополнительное измерение. &lt;code&gt;np.atleast2d(a).T&lt;/code&gt; достигает этого, как и &lt;code&gt;a[:, np.newaxis]&lt;/code&gt; . Для двумерного массива это стандартное транспонирование матрицы. Для массива nD, если указаны оси, их порядок указывает, как оси переставляются (см. Примеры). Если оси не &lt;code&gt;a.shape = (i[0], i[1], ... i[n-2], i[n-1])&lt;/code&gt; и a.shape = (i [0], i [1], ... i [n-2], i [n-1]) , то &lt;code&gt;a.transpose().shape = (i[n-1], i[n-2], ... i[1], i[0])&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d3f2a60e0b01b84231d8024aebcc5e084e0ba27d" translate="yes" xml:space="preserve">
          <source>For a 1D array, &lt;code&gt;a.tolist()&lt;/code&gt; is almost the same as &lt;code&gt;list(a)&lt;/code&gt;:</source>
          <target state="translated">Для одномерного массива &lt;code&gt;a.tolist()&lt;/code&gt; почти то же самое, что &lt;code&gt;list(a)&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="cf0f7c81098fcc87863f3be5d59395a987825914" translate="yes" xml:space="preserve">
          <source>For a complete discussion of creation methods for masked arrays please see section &lt;a href=&quot;#maskedarray-generic-constructing&quot;&gt;Constructing masked arrays&lt;/a&gt;.</source>
          <target state="translated">Полное обсуждение методов создания маскированных массивов см. В разделе &amp;laquo; &lt;a href=&quot;#maskedarray-generic-constructing&quot;&gt;Создание маскированных массивов&amp;raquo;&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="0bdfc3356f177e5d7773cb796069c781e6c3ff20" translate="yes" xml:space="preserve">
          <source>For a description of the &lt;code&gt;.npy&lt;/code&gt; format, see &lt;a href=&quot;numpy.lib.format#module-numpy.lib.format&quot;&gt;&lt;code&gt;numpy.lib.format&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Для описания &lt;code&gt;.npy&lt;/code&gt; формата см &lt;a href=&quot;numpy.lib.format#module-numpy.lib.format&quot;&gt; &lt;code&gt;numpy.lib.format&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="197692467968599b779c0574e1302cadc5d30a4f" translate="yes" xml:space="preserve">
          <source>For a full description of these options, see &lt;a href=&quot;numpy.set_printoptions#numpy.set_printoptions&quot;&gt;&lt;code&gt;set_printoptions&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Полное описание этих параметров см . В разделе &lt;a href=&quot;numpy.set_printoptions#numpy.set_printoptions&quot;&gt; &lt;code&gt;set_printoptions&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="b040ed436e354a6dfab8e28023d68c6eed7a06c2" translate="yes" xml:space="preserve">
          <source>For a function that returns a 1D array, the number of dimensions in &lt;code&gt;outarr&lt;/code&gt; is the same as &lt;code&gt;arr&lt;/code&gt;.</source>
          <target state="translated">Для функции, возвращающей одномерный массив, количество измерений в &lt;code&gt;outarr&lt;/code&gt; такое же, как и в &lt;code&gt;arr&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9409ae5300d15907687b38139959611e06963f16" translate="yes" xml:space="preserve">
          <source>For a function that returns a higher dimensional array, those dimensions are inserted in place of the &lt;code&gt;axis&lt;/code&gt; dimension.</source>
          <target state="translated">Для функции, которая возвращает массив более высоких измерений, эти измерения вставляются вместо измерения &lt;code&gt;axis&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7adc015d596be980abdfb7f52ddd54b20d9ed4e4" translate="yes" xml:space="preserve">
          <source>For a multi-dimensional array, accumulate is applied along only one axis (axis zero by default; see Examples below) so repeated use is necessary if one wants to accumulate over multiple axes.</source>
          <target state="translated">Для многомерного массива накопление применяется только по одной оси (по умолчанию нулевая ось;см.примеры ниже),поэтому повторное использование необходимо,если необходимо накопление по нескольким осям.</target>
        </trans-unit>
        <trans-unit id="4a70a58adc76a39cce5a267ab70438cf75b9572e" translate="yes" xml:space="preserve">
          <source>For a non-trivial signature, &lt;code&gt;dimensions&lt;/code&gt; will also contain the sizes of the core dimensions as well, starting at the second entry. Only one size is provided for each unique dimension name and the sizes are given according to the first occurrence of a dimension name in the signature.</source>
          <target state="translated">Для нетривиальной подписи &lt;code&gt;dimensions&lt;/code&gt; также будут содержать размеры основных размеров, начиная со второй записи. Для каждого уникального имени измерения предоставляется только один размер, и размеры даются в соответствии с первым появлением имени измерения в подписи.</target>
        </trans-unit>
        <trans-unit id="8218bd5d7a6649aa63226e5b622d4b8efad4dc34" translate="yes" xml:space="preserve">
          <source>For a one-dimensional array, accumulate produces results equivalent to:</source>
          <target state="translated">Для одномерного массива накопление дает результаты,эквивалентные:</target>
        </trans-unit>
        <trans-unit id="0424b9224931152a35a50c93d8cc0ece880de71a" translate="yes" xml:space="preserve">
          <source>For a one-sided t-test, how far out in the distribution does the t statistic appear?</source>
          <target state="translated">Для одностороннего t-теста,насколько далеко в распределении появляется t-статистика?</target>
        </trans-unit>
        <trans-unit id="3911c3b2407712ae47f85ee3fb1ac557138ff00b" translate="yes" xml:space="preserve">
          <source>For a possible future loop selector with a different signature.</source>
          <target state="translated">Для возможного будущего селектора циклов с другой сигнатурой.</target>
        </trans-unit>
        <trans-unit id="c991a419f14da45f93fac679b2b79a552dc6a583" translate="yes" xml:space="preserve">
          <source>For a simple example, consider taking the sum of all elements in an array.</source>
          <target state="translated">В качестве простого примера рассмотрим взятие суммы всех элементов в массиве.</target>
        </trans-unit>
        <trans-unit id="65b58d63b284139c1918d1c4f188a0cdc07b3bf2" translate="yes" xml:space="preserve">
          <source>For advanced assignments, there is in general no guarantee for the iteration order. This means that if an element is set more than once, it is not possible to predict the final result.</source>
          <target state="translated">При выполнении расширенных заданий,как правило,нет гарантии на порядок итераций.Это означает,что если элемент задан более одного раза,невозможно предсказать конечный результат.</target>
        </trans-unit>
        <trans-unit id="d08105fb315fdfa97977e494fc0f07ee6275d676" translate="yes" xml:space="preserve">
          <source>For all of these macros &lt;em&gt;arr&lt;/em&gt; must be an instance of a (subclass of) &lt;a href=&quot;c-api.types-and-structures#c.PyArray_Type&quot;&gt;&lt;code&gt;PyArray_Type&lt;/code&gt;&lt;/a&gt;, but no checking is done.</source>
          <target state="translated">Для всех этих макросов &lt;em&gt;arr&lt;/em&gt; должен быть экземпляром (подклассом) &lt;a href=&quot;c-api.types-and-structures#c.PyArray_Type&quot;&gt; &lt;code&gt;PyArray_Type&lt;/code&gt; &lt;/a&gt; , но проверка не выполняется.</target>
        </trans-unit>
        <trans-unit id="24c98e7efdd0450f6d403ff7e88bf2f5b1a932b5" translate="yes" xml:space="preserve">
          <source>For all-NaN slices or slices with zero degrees of freedom, NaN is returned and a &lt;code&gt;RuntimeWarning&lt;/code&gt; is raised.</source>
          <target state="translated">Для срезов, содержащих все NaN, или срезов с нулевыми степенями свободы, возвращается NaN и возникает &lt;code&gt;RuntimeWarning&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b523336c8d394d1599c127fd9600cfe28ac8e406" translate="yes" xml:space="preserve">
          <source>For all-NaN slices, NaN is returned and a &lt;code&gt;RuntimeWarning&lt;/code&gt; is raised.</source>
          <target state="translated">Для срезов, &lt;code&gt;RuntimeWarning&lt;/code&gt; NaN, возвращается NaN и возникает RuntimeWarning .</target>
        </trans-unit>
        <trans-unit id="f544bc19358af783f5828a5e5053cd2cf057f05c" translate="yes" xml:space="preserve">
          <source>For an array &lt;code&gt;a&lt;/code&gt; with &lt;code&gt;a.ndim &amp;gt;= 2&lt;/code&gt;, the diagonal is the list of locations with indices &lt;code&gt;a[i, ..., i]&lt;/code&gt; all identical. This function modifies the input array in-place, it does not return a value.</source>
          <target state="translated">Для массива &lt;code&gt;a&lt;/code&gt; с &lt;code&gt;a.ndim &amp;gt;= 2&lt;/code&gt; диагональ - это список местоположений с одинаковыми индексами &lt;code&gt;a[i, ..., i]&lt;/code&gt; . Эта функция изменяет входной массив на месте, она не возвращает значение.</target>
        </trans-unit>
        <trans-unit id="836b756b5d814f029c077f0578ba6c0e58a3c672" translate="yes" xml:space="preserve">
          <source>For an array with rank greater than 1, some of the padding of later axes is calculated from padding of previous axes. This is easiest to think about with a rank 2 array where the corners of the padded array are calculated by using padded values from the first axis.</source>
          <target state="translated">Для массива,имеющего ранг больше 1,часть набивки более поздних осей вычисляется из набивки предыдущих осей.Об этом легче всего думать при использовании массива 2-го ранга,в котором углы массива с подкладкой рассчитываются с помощью значений подкладки от первой оси.</target>
        </trans-unit>
        <trans-unit id="6e96c6b0d98bc68cbd820a41e54b4b8abe37a921" translate="yes" xml:space="preserve">
          <source>For an even number of input points, &lt;code&gt;A[n//2]&lt;/code&gt; represents the sum of the values at the positive and negative Nyquist frequencies, as the two are aliased together. See &lt;a href=&quot;../routines.fft#module-numpy.fft&quot;&gt;&lt;code&gt;numpy.fft&lt;/code&gt;&lt;/a&gt; for details.</source>
          <target state="translated">Для четного числа входных точек &lt;code&gt;A[n//2]&lt;/code&gt; представляет собой сумму значений на положительной и отрицательной частотах Найквиста, так как они накладываются друг на друга. См. &lt;a href=&quot;../routines.fft#module-numpy.fft&quot;&gt; &lt;code&gt;numpy.fft&lt;/code&gt; &lt;/a&gt; для подробностей.</target>
        </trans-unit>
        <trans-unit id="57743d92673c43f581b946774bebcebd154a8f73" translate="yes" xml:space="preserve">
          <source>For an example, see &lt;a href=&quot;numpy.lib.arrayterator#numpy.lib.Arrayterator&quot;&gt;&lt;code&gt;Arrayterator&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Для примера см. &lt;a href=&quot;numpy.lib.arrayterator#numpy.lib.Arrayterator&quot;&gt; &lt;code&gt;Arrayterator&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="6fe48c8702effa07c62fb464257e567d9ddc8002" translate="yes" xml:space="preserve">
          <source>For any index combination, including slicing and axis insertion, &lt;code&gt;a[indices]&lt;/code&gt; is the same as &lt;code&gt;a[np.index_exp[indices]]&lt;/code&gt; for any array &lt;code&gt;a&lt;/code&gt;. However, &lt;code&gt;np.index_exp[indices]&lt;/code&gt; can be used anywhere in Python code and returns a tuple of slice objects that can be used in the construction of complex index expressions.</source>
          <target state="translated">Для любой комбинации индексов, включая нарезку и вставку оси, &lt;code&gt;a[indices]&lt;/code&gt; index ] совпадает с &lt;code&gt;a[np.index_exp[indices]]&lt;/code&gt; для любого массива &lt;code&gt;a&lt;/code&gt; . Однако &lt;code&gt;np.index_exp[indices]&lt;/code&gt; может использоваться где угодно в коде Python и возвращает кортеж объектов-срезов, которые можно использовать при построении сложных индексных выражений.</target>
        </trans-unit>
        <trans-unit id="ec5bdb26c08f7af1b31abb9fd2aadbeeef092f4f" translate="yes" xml:space="preserve">
          <source>For array methods that take an &lt;em&gt;axis&lt;/em&gt; keyword, it defaults to &lt;code&gt;None&lt;/code&gt;. If axis is &lt;em&gt;None&lt;/em&gt;, then the array is treated as a 1-D array. Any other value for &lt;em&gt;axis&lt;/em&gt; represents the dimension along which the operation should proceed.</source>
          <target state="translated">Для методов массива, которые принимают ключевое слово &lt;em&gt;оси&lt;/em&gt; , по умолчанию используется значение &lt;code&gt;None&lt;/code&gt; . Если ось &lt;em&gt;None&lt;/em&gt; , то массив рассматривается как одномерный массив. Любое другое значение &lt;em&gt;оси&lt;/em&gt; представляет размер, по которому должна продолжаться операция.</target>
        </trans-unit>
        <trans-unit id="dcba10981a70013794c3901be17ecdedebc27a1a" translate="yes" xml:space="preserve">
          <source>For backward compatibility and as a standard &amp;ldquo;container &amp;ldquo;class, the UserArray from Numeric has been brought over to NumPy and named &lt;a href=&quot;generated/numpy.lib.user_array.container#numpy.lib.user_array.container&quot;&gt;&lt;code&gt;numpy.lib.user_array.container&lt;/code&gt;&lt;/a&gt; The container class is a Python class whose self.array attribute is an ndarray. Multiple inheritance is probably easier with numpy.lib.user_array.container than with the ndarray itself and so it is included by default. It is not documented here beyond mentioning its existence because you are encouraged to use the ndarray class directly if you can.</source>
          <target state="translated">Для обратной совместимости и в качестве стандартного &amp;laquo;контейнерного&amp;raquo; класса UserArray из Numeric был перенесен в NumPy и назван &lt;a href=&quot;generated/numpy.lib.user_array.container#numpy.lib.user_array.container&quot;&gt; &lt;code&gt;numpy.lib.user_array.container&lt;/code&gt; &lt;/a&gt; . Контейнерный класс - это класс Python, атрибут self.array которого является ndarray. Множественное наследование, вероятно, проще с numpy.lib.user_array.container, чем с самим ndarray, поэтому он включен по умолчанию. Здесь он не документируется, кроме упоминания о его существовании, потому что вам рекомендуется использовать класс ndarray напрямую, если вы можете.</target>
        </trans-unit>
        <trans-unit id="1756e23a025872fd532e8ba6c08bb9a4085acd5e" translate="yes" xml:space="preserve">
          <source>For backward compatibility with Python 2 the &lt;code&gt;S&lt;/code&gt; and &lt;code&gt;a&lt;/code&gt; typestrings remain zero-terminated bytes and &lt;code&gt;np.string_&lt;/code&gt; continues to map to &lt;code&gt;np.bytes_&lt;/code&gt;. To use actual strings in Python 3 use &lt;code&gt;U&lt;/code&gt; or &lt;code&gt;np.unicode_&lt;/code&gt;. For signed bytes that do not need zero-termination &lt;code&gt;b&lt;/code&gt; or &lt;code&gt;i1&lt;/code&gt; can be used.</source>
          <target state="translated">Для обратной совместимости с Python 2 строки &lt;code&gt;S&lt;/code&gt; и &lt;code&gt;a&lt;/code&gt; остаются завершающимися байтами, а &lt;code&gt;np.string_&lt;/code&gt; продолжает отображаться на &lt;code&gt;np.bytes_&lt;/code&gt; . Чтобы использовать фактические строки в Python 3, используйте &lt;code&gt;U&lt;/code&gt; или &lt;code&gt;np.unicode_&lt;/code&gt; . Для подписанных байтов, которые не нуждаются в завершении нуля, можно использовать &lt;code&gt;b&lt;/code&gt; или &lt;code&gt;i1&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c77dfb74768b5914a720e322bd9c4f4d3188beb4" translate="yes" xml:space="preserve">
          <source>For backwards compatibility, datetime64 still parses timezone offsets, which it handles by converting to UTC. However, the resulting datetime is timezone naive:</source>
          <target state="translated">Для обратной совместимости datetime64 по-прежнему анализирует смещения часового пояса,которые он обрабатывает путем преобразования в UTC.Тем не менее,полученное в результате время является наивным часовым поясом:</target>
        </trans-unit>
        <trans-unit id="1c64f15e60882d9539499a036901b91bc24bc19f" translate="yes" xml:space="preserve">
          <source>For backwards compatibility, the form (str, array of 624 uints, int) is also accepted although it is missing some information about the cached Gaussian value: &lt;code&gt;state = ('MT19937', keys, pos)&lt;/code&gt;.</source>
          <target state="translated">Для обратной совместимости форма (str, array of 624 uints, int) также принимается, хотя в ней отсутствует некоторая информация о кэшированном гауссовском значении: &lt;code&gt;state = ('MT19937', keys, pos)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4eb2208bc27c7545536cb93635c9264ced09a6ad" translate="yes" xml:space="preserve">
          <source>For bandlimited interpolation of discrete-time signals, the ideal interpolation kernel is proportional to the sinc function.</source>
          <target state="translated">Для интерполяции дискретных сигналов в диапазоне времени идеальное интерполяционное ядро пропорционально функции sinc.</target>
        </trans-unit>
        <trans-unit id="0640d05a7ef317b56adcd70bde409c84daf4b12d" translate="yes" xml:space="preserve">
          <source>For buffered loops, care must be taken to copy and cast data before the loop function is called because the underlying loop expects aligned data of the correct data-type (including byte-order). The buffered loop must handle this copying and casting prior to calling the loop function on chunks no greater than the user-specified bufsize.</source>
          <target state="translated">Для буферизованных циклов необходимо позаботиться о копировании и приведении в соответствие данных до вызова функции цикла,так как базовый цикл ожидает выравнивания данных правильного типа (включая порядок байт).Буферизованный цикл должен обрабатывать это копирование и приведение в соответствие перед вызовом функции цикла на кусочках не больше,чем указанная пользователем bufsize.</target>
        </trans-unit>
        <trans-unit id="78ea569e34a0a0f36b8d0d5224e34f847b3cf085" translate="yes" xml:space="preserve">
          <source>For clarity it is useful to provide some examples of the type description and corresponding &lt;a href=&quot;#__array_interface__&quot;&gt;&lt;code&gt;__array_interface__&lt;/code&gt;&lt;/a&gt; &amp;lsquo;descr&amp;rsquo; entries. Thanks to Scott Gilbert for these examples:</source>
          <target state="translated">Для ясности полезно предоставить несколько примеров описания типа и соответствующих &lt;a href=&quot;#__array_interface__&quot;&gt; &lt;code&gt;__array_interface__&lt;/code&gt; &lt;/a&gt; 'descr'. Спасибо Скотту Гилберту за эти примеры:</target>
        </trans-unit>
        <trans-unit id="aefcdcec95bb0a9f49c3ea43d81c147b480f4a1a" translate="yes" xml:space="preserve">
          <source>For complete documentation of the types of floating-point exceptions and treatment options, see &lt;a href=&quot;numpy.seterr#numpy.seterr&quot;&gt;&lt;code&gt;seterr&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Полную документацию о типах исключений с плавающей запятой и вариантах обработки см. В &lt;a href=&quot;numpy.seterr#numpy.seterr&quot;&gt; &lt;code&gt;seterr&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="f6638e7aa649639c70b61a262d3fcb528e530dcc" translate="yes" xml:space="preserve">
          <source>For completeness, we&amp;rsquo;ll also add the &amp;lsquo;external_loop&amp;rsquo; and &amp;lsquo;buffered&amp;rsquo; flags, as these are what you will typically want for performance reasons.</source>
          <target state="translated">Для полноты картины мы также добавим флаги external_loop и buffered, так как это то, что вам обычно нужно по соображениям производительности.</target>
        </trans-unit>
        <trans-unit id="823eefe35591ae1ef0928dcf4115410e8d28b81a" translate="yes" xml:space="preserve">
          <source>For complex arguments, &lt;code&gt;x = a + ib&lt;/code&gt;, we can write</source>
          <target state="translated">Для сложных аргументов, &lt;code&gt;x = a + ib&lt;/code&gt; , мы можем написать</target>
        </trans-unit>
        <trans-unit id="00d19b01697a76f9042f9abe787cb066622b4409" translate="yes" xml:space="preserve">
          <source>For complex dtypes, the above is applied to each of the real and imaginary components of &lt;code&gt;x&lt;/code&gt; separately.</source>
          <target state="translated">Для сложных типов dtypes вышеупомянутое применяется к каждой из действительных и мнимых компонентов &lt;code&gt;x&lt;/code&gt; отдельно.</target>
        </trans-unit>
        <trans-unit id="7aabc240767fa8c38770aded9994dbfb9309fc85" translate="yes" xml:space="preserve">
          <source>For complex inputs, the &lt;a href=&quot;#numpy.sign&quot;&gt;&lt;code&gt;sign&lt;/code&gt;&lt;/a&gt; function returns &lt;code&gt;sign(x.real) + 0j if x.real != 0 else sign(x.imag) + 0j&lt;/code&gt;.</source>
          <target state="translated">Для сложных входных данных функция &lt;a href=&quot;#numpy.sign&quot;&gt; &lt;code&gt;sign&lt;/code&gt; &lt;/a&gt; возвращает &lt;code&gt;sign(x.real) + 0j if x.real != 0 else sign(x.imag) + 0j&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="37a57514466afa09fc7538317ff0a405ada2d56e" translate="yes" xml:space="preserve">
          <source>For complex-valued input, &lt;a href=&quot;#numpy.arccos&quot;&gt;&lt;code&gt;arccos&lt;/code&gt;&lt;/a&gt; is a complex analytic function that has branch cuts &lt;code&gt;[-inf, -1]&lt;/code&gt; and &lt;code&gt;[1, inf]&lt;/code&gt; and is continuous from above on the former and from below on the latter.</source>
          <target state="translated">Для комплексных входных данных &lt;a href=&quot;#numpy.arccos&quot;&gt; &lt;code&gt;arccos&lt;/code&gt; &lt;/a&gt; - это комплексная аналитическая функция, которая имеет разрезы ветвей &lt;code&gt;[-inf, -1]&lt;/code&gt; и &lt;code&gt;[1, inf]&lt;/code&gt; и является непрерывной сверху для первого и снизу для второго.</target>
        </trans-unit>
        <trans-unit id="ff44215d073bf2342406439d430f9b3eb5cc308c" translate="yes" xml:space="preserve">
          <source>For complex-valued input, &lt;a href=&quot;#numpy.arccosh&quot;&gt;&lt;code&gt;arccosh&lt;/code&gt;&lt;/a&gt; is a complex analytical function that has a branch cut &lt;code&gt;[-inf, 1]&lt;/code&gt; and is continuous from above on it.</source>
          <target state="translated">Для комплексных входных данных &lt;a href=&quot;#numpy.arccosh&quot;&gt; &lt;code&gt;arccosh&lt;/code&gt; &lt;/a&gt; - это сложная аналитическая функция, которая имеет отрезок ветви &lt;code&gt;[-inf, 1]&lt;/code&gt; и является непрерывной сверху вниз .</target>
        </trans-unit>
        <trans-unit id="64f377fde8ecd4efebbb4d5831dcc8bc678877a9" translate="yes" xml:space="preserve">
          <source>For complex-valued input, &lt;a href=&quot;#numpy.arcsin&quot;&gt;&lt;code&gt;arcsin&lt;/code&gt;&lt;/a&gt; is a complex analytic function that has, by convention, the branch cuts [-inf, -1] and [1, inf] and is continuous from above on the former and from below on the latter.</source>
          <target state="translated">Для комплексных входных данных &lt;a href=&quot;#numpy.arcsin&quot;&gt; &lt;code&gt;arcsin&lt;/code&gt; &lt;/a&gt; - это комплексная аналитическая функция, которая по соглашению имеет ветвь, отсекающую [-inf, -1] и [1, inf], и непрерывна сверху на первом и снизу на втором.</target>
        </trans-unit>
        <trans-unit id="57038706eece9d133e1f92cf4c0e30653094f94f" translate="yes" xml:space="preserve">
          <source>For complex-valued input, &lt;a href=&quot;#numpy.arctan&quot;&gt;&lt;code&gt;arctan&lt;/code&gt;&lt;/a&gt; is a complex analytic function that has [&lt;code&gt;1j, infj&lt;/code&gt;] and [&lt;code&gt;-1j, -infj&lt;/code&gt;] as branch cuts, and is continuous from the left on the former and from the right on the latter.</source>
          <target state="translated">Для комплексных входных данных &lt;a href=&quot;#numpy.arctan&quot;&gt; &lt;code&gt;arctan&lt;/code&gt; &lt;/a&gt; - это комплексная аналитическая функция, которая имеет [ &lt;code&gt;1j, infj&lt;/code&gt; ] и [ &lt;code&gt;-1j, -infj&lt;/code&gt; ] как сечения ветвей, и непрерывна слева в первом случае и справа во втором.</target>
        </trans-unit>
        <trans-unit id="4c701e0e2c7136fbf8b3d11659944481b8208402" translate="yes" xml:space="preserve">
          <source>For complex-valued input, &lt;a href=&quot;#numpy.arctanh&quot;&gt;&lt;code&gt;arctanh&lt;/code&gt;&lt;/a&gt; is a complex analytical function that has branch cuts &lt;code&gt;[-1, -inf]&lt;/code&gt; and &lt;code&gt;[1, inf]&lt;/code&gt; and is continuous from above on the former and from below on the latter.</source>
          <target state="translated">Для комплексных входных данных &lt;a href=&quot;#numpy.arctanh&quot;&gt; &lt;code&gt;arctanh&lt;/code&gt; &lt;/a&gt; - это сложная аналитическая функция, которая имеет &lt;code&gt;[-1, -inf]&lt;/code&gt; ветвей [-1, -inf] и &lt;code&gt;[1, inf]&lt;/code&gt; и является непрерывной сверху на первом и снизу на втором.</target>
        </trans-unit>
        <trans-unit id="159e5638a9f1467d3dd2785cf39347fd2d548d9f" translate="yes" xml:space="preserve">
          <source>For complex-valued input, &lt;a href=&quot;#numpy.log&quot;&gt;&lt;code&gt;log&lt;/code&gt;&lt;/a&gt; is a complex analytical function that has a branch cut &lt;code&gt;[-inf, 0]&lt;/code&gt; and is continuous from above on it. &lt;a href=&quot;#numpy.log&quot;&gt;&lt;code&gt;log&lt;/code&gt;&lt;/a&gt; handles the floating-point negative zero as an infinitesimal negative number, conforming to the C99 standard.</source>
          <target state="translated">Для комплексных входных данных &lt;a href=&quot;#numpy.log&quot;&gt; &lt;code&gt;log&lt;/code&gt; &lt;/a&gt; - это сложная аналитическая функция, которая имеет отрезок ветви &lt;code&gt;[-inf, 0]&lt;/code&gt; и является непрерывной сверху вниз . &lt;a href=&quot;#numpy.log&quot;&gt; &lt;code&gt;log&lt;/code&gt; &lt;/a&gt; обрабатывает отрицательный ноль с плавающей запятой как бесконечно малое отрицательное число, соответствующее стандарту C99.</target>
        </trans-unit>
        <trans-unit id="5ba7031abf7f62c036d84ca3e657ff0bbe63c9b4" translate="yes" xml:space="preserve">
          <source>For complex-valued input, &lt;a href=&quot;#numpy.log10&quot;&gt;&lt;code&gt;log10&lt;/code&gt;&lt;/a&gt; is a complex analytical function that has a branch cut &lt;code&gt;[-inf, 0]&lt;/code&gt; and is continuous from above on it. &lt;a href=&quot;#numpy.log10&quot;&gt;&lt;code&gt;log10&lt;/code&gt;&lt;/a&gt; handles the floating-point negative zero as an infinitesimal negative number, conforming to the C99 standard.</source>
          <target state="translated">Для комплексных входных данных &lt;a href=&quot;#numpy.log10&quot;&gt; &lt;code&gt;log10&lt;/code&gt; &lt;/a&gt; - это сложная аналитическая функция, которая имеет отрезок ветви &lt;code&gt;[-inf, 0]&lt;/code&gt; и является непрерывной сверху вниз . &lt;a href=&quot;#numpy.log10&quot;&gt; &lt;code&gt;log10&lt;/code&gt; &lt;/a&gt; обрабатывает отрицательный ноль с плавающей запятой как бесконечно малое отрицательное число в соответствии со стандартом C99.</target>
        </trans-unit>
        <trans-unit id="1d03218ffbd2a27086f21639f1e5d2c57e1fdb96" translate="yes" xml:space="preserve">
          <source>For complex-valued input, &lt;a href=&quot;#numpy.log1p&quot;&gt;&lt;code&gt;log1p&lt;/code&gt;&lt;/a&gt; is a complex analytical function that has a branch cut &lt;code&gt;[-inf, -1]&lt;/code&gt; and is continuous from above on it. &lt;a href=&quot;#numpy.log1p&quot;&gt;&lt;code&gt;log1p&lt;/code&gt;&lt;/a&gt; handles the floating-point negative zero as an infinitesimal negative number, conforming to the C99 standard.</source>
          <target state="translated">Для комплексных входных данных &lt;a href=&quot;#numpy.log1p&quot;&gt; &lt;code&gt;log1p&lt;/code&gt; &lt;/a&gt; - это сложная аналитическая функция, которая имеет отрезок ветви &lt;code&gt;[-inf, -1]&lt;/code&gt; и является непрерывной сверху вниз . &lt;a href=&quot;#numpy.log1p&quot;&gt; &lt;code&gt;log1p&lt;/code&gt; &lt;/a&gt; обрабатывает отрицательный ноль с плавающей запятой как бесконечно малое отрицательное число, соответствующее стандарту C99.</target>
        </trans-unit>
        <trans-unit id="714b21ba8fb7b3f93db097558f921f5a3cc7d7e7" translate="yes" xml:space="preserve">
          <source>For complex-valued input, &lt;a href=&quot;#numpy.log2&quot;&gt;&lt;code&gt;log2&lt;/code&gt;&lt;/a&gt; is a complex analytical function that has a branch cut &lt;code&gt;[-inf, 0]&lt;/code&gt; and is continuous from above on it. &lt;a href=&quot;#numpy.log2&quot;&gt;&lt;code&gt;log2&lt;/code&gt;&lt;/a&gt; handles the floating-point negative zero as an infinitesimal negative number, conforming to the C99 standard.</source>
          <target state="translated">Для комплексных входных данных &lt;a href=&quot;#numpy.log2&quot;&gt; &lt;code&gt;log2&lt;/code&gt; &lt;/a&gt; - это сложная аналитическая функция, которая имеет отрезок ветви &lt;code&gt;[-inf, 0]&lt;/code&gt; и является непрерывной сверху вниз . &lt;a href=&quot;#numpy.log2&quot;&gt; &lt;code&gt;log2&lt;/code&gt; &lt;/a&gt; обрабатывает отрицательный ноль с плавающей запятой как бесконечно малое отрицательное число, соответствующее стандарту C99.</target>
        </trans-unit>
        <trans-unit id="a557bc2da4dcaaf761d30f4619e8e0d4a2f4e8f4" translate="yes" xml:space="preserve">
          <source>For complex-valued input, &lt;a href=&quot;numpy.arccos#numpy.arccos&quot;&gt;&lt;code&gt;arccos&lt;/code&gt;&lt;/a&gt; is a complex analytical function that has branch cuts &lt;code&gt;[1j, infj]&lt;/code&gt; and &lt;code&gt;[-1j, -infj]&lt;/code&gt; and is continuous from the right on the former and from the left on the latter.</source>
          <target state="translated">Для комплексных входных данных &lt;a href=&quot;numpy.arccos#numpy.arccos&quot;&gt; &lt;code&gt;arccos&lt;/code&gt; &lt;/a&gt; - это сложная аналитическая функция, которая имеет &lt;code&gt;[1j, infj]&lt;/code&gt; ветвей [1j, infj] и &lt;code&gt;[-1j, -infj]&lt;/code&gt; и непрерывна справа в первом и слева во втором.</target>
        </trans-unit>
        <trans-unit id="e81428e8e562739a6cb03d81d7a49ece97991e48" translate="yes" xml:space="preserve">
          <source>For consistency with histogram, an array of pre-computed bins is passed through unmodified:</source>
          <target state="translated">Для согласованности с гистограммой массив предварительно вычисленных бинов проходит через немодифицированный:</target>
        </trans-unit>
        <trans-unit id="eed4c585fafb6282979d170d7fc49312f2240470" translate="yes" xml:space="preserve">
          <source>For convenience and backward compatibility, a single &lt;a href=&quot;legacy#numpy.random.mtrand.RandomState&quot;&gt;&lt;code&gt;RandomState&lt;/code&gt;&lt;/a&gt; instance&amp;rsquo;s methods are imported into the numpy.random namespace, see &lt;a href=&quot;legacy#legacy&quot;&gt;Legacy Random Generation&lt;/a&gt; for the complete list.</source>
          <target state="translated">Для удобства и обратной совместимости методы одного экземпляра &lt;a href=&quot;legacy#numpy.random.mtrand.RandomState&quot;&gt; &lt;code&gt;RandomState&lt;/code&gt; &lt;/a&gt; импортируются в пространство имен numpy.random, полный список см. В разделе &amp;laquo; &lt;a href=&quot;legacy#legacy&quot;&gt;Устаревшая случайная генерация&amp;raquo;&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="96d19661d614c330e3a9e7e16801d7b1d4abdea7" translate="yes" xml:space="preserve">
          <source>For data types that are always the same size (such as long), this holds the size of the data type. For flexible data types where different arrays can have a different elementsize, this should be 0.</source>
          <target state="translated">Для типов данных,которые всегда имеют одинаковый размер (например,длинный),это означает размер типа данных.Для гибких типов данных,где разные массивы могут иметь разный размер элементов,это должно быть 0.</target>
        </trans-unit>
        <trans-unit id="88871b72e212455bd0a3305f24c658a9086cd65b" translate="yes" xml:space="preserve">
          <source>For data types that describe sub-arrays:</source>
          <target state="translated">Для типов данных,описывающих подмассивы:</target>
        </trans-unit>
        <trans-unit id="665e908efd043172f3a61d4025a859ec2c83aba8" translate="yes" xml:space="preserve">
          <source>For definition of the DFT and conventions used.</source>
          <target state="translated">Для определения БПД и используемых конвенций.</target>
        </trans-unit>
        <trans-unit id="fb5f8bb3afe673736236ecca5864cdc9f7fc37e1" translate="yes" xml:space="preserve">
          <source>For developers of NumPy: do not instantiate this at the module level. The initial calculation of these parameters is expensive and negatively impacts import times. These objects are cached, so calling &lt;code&gt;finfo()&lt;/code&gt; repeatedly inside your functions is not a problem.</source>
          <target state="translated">Для разработчиков NumPy: не создавайте его на уровне модуля. Первоначальный расчет этих параметров является дорогостоящим и отрицательно влияет на время импорта. Эти объекты кэшируются, поэтому &lt;code&gt;finfo()&lt;/code&gt; вызов finfo () внутри ваших функций не является проблемой.</target>
        </trans-unit>
        <trans-unit id="c58f9c7b61fa3d8a2763dc4a797daee41cc03eb8" translate="yes" xml:space="preserve">
          <source>For each distinct core dimension, a set of &lt;code&gt;UFUNC_CORE_DIM*&lt;/code&gt; flags</source>
          <target state="translated">Для каждого отдельного основного измерения набор флагов &lt;code&gt;UFUNC_CORE_DIM*&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="396b05c439db2438a9382de672b6fa8e95c31893" translate="yes" xml:space="preserve">
          <source>For each distinct core dimension, the possible &lt;a href=&quot;c-api.generalized-ufuncs#frozen&quot;&gt;frozen&lt;/a&gt; size if &lt;code&gt;UFUNC_CORE_DIM_SIZE_INFERRED&lt;/code&gt; is 0</source>
          <target state="translated">Для каждого отдельного измерения сердечника, возможное &lt;a href=&quot;c-api.generalized-ufuncs#frozen&quot;&gt;замороженного&lt;/a&gt; размер , если &lt;code&gt;UFUNC_CORE_DIM_SIZE_INFERRED&lt;/code&gt; 0</target>
        </trans-unit>
        <trans-unit id="eb98f2bacd6f2ddd2321b31d6e02518d57ef1a01" translate="yes" xml:space="preserve">
          <source>For each element in &lt;code&gt;a&lt;/code&gt;, return a copy of the string where all characters occurring in the optional argument &lt;code&gt;deletechars&lt;/code&gt; are removed, and the remaining characters have been mapped through the given translation table.</source>
          <target state="translated">Для каждого элемента в &lt;code&gt;a&lt;/code&gt; вернуть копию строки, где все символы, встречающиеся в необязательном аргументе &lt;code&gt;deletechars&lt;/code&gt; , удалены, а оставшиеся символы были отображены через данную таблицу перевода.</target>
        </trans-unit>
        <trans-unit id="6fd82d55a1666ac371b70f835404bd2254f11112" translate="yes" xml:space="preserve">
          <source>For each element in &lt;code&gt;a&lt;/code&gt;, return a copy of the string with all occurrences of substring &lt;code&gt;old&lt;/code&gt; replaced by &lt;code&gt;new&lt;/code&gt;.</source>
          <target state="translated">Для каждого элемента в &lt;code&gt;a&lt;/code&gt; вернуть копию строки со всеми вхождениями &lt;code&gt;old&lt;/code&gt; подстроки, замененной на &lt;code&gt;new&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a0072392849c4a29d135980cb1732127fb7c8293" translate="yes" xml:space="preserve">
          <source>For each element in &lt;code&gt;a&lt;/code&gt;, return a copy with the leading and trailing characters removed.</source>
          <target state="translated">Для каждого элемента в &lt;code&gt;a&lt;/code&gt; вернуть копию с удаленными начальными и конечными символами.</target>
        </trans-unit>
        <trans-unit id="ce017fa2090bd21769500e23616f51df45b2cf16" translate="yes" xml:space="preserve">
          <source>For each element in &lt;code&gt;a&lt;/code&gt;, return a copy with the leading characters removed.</source>
          <target state="translated">Для каждого элемента в &lt;code&gt;a&lt;/code&gt; вернуть копию с удаленными ведущими символами.</target>
        </trans-unit>
        <trans-unit id="bcc8c5cf0a4ab8429da79ab635d524c5cd68a8b9" translate="yes" xml:space="preserve">
          <source>For each element in &lt;code&gt;a&lt;/code&gt;, return a copy with the trailing characters removed.</source>
          <target state="translated">Для каждого элемента в &lt;code&gt;a&lt;/code&gt; вернуть копию с удаленными завершающими символами.</target>
        </trans-unit>
        <trans-unit id="b48d2d67a82f24a073bc0fd48d1c7c812f1f1bea" translate="yes" xml:space="preserve">
          <source>For each element in &lt;code&gt;a&lt;/code&gt;, return a list of the lines in the element, breaking at line boundaries.</source>
          <target state="translated">Для каждого элемента в &lt;code&gt;a&lt;/code&gt; вернуть список строк в элементе с разрывами на границах строк.</target>
        </trans-unit>
        <trans-unit id="d96129628d06f13e5afb8f18fe53cee0a045c865" translate="yes" xml:space="preserve">
          <source>For each element in &lt;code&gt;a&lt;/code&gt;, return a list of the words in the string, using &lt;code&gt;sep&lt;/code&gt; as the delimiter string.</source>
          <target state="translated">Для каждого элемента в &lt;code&gt;a&lt;/code&gt; вернуть список слов в строке, используя &lt;code&gt;sep&lt;/code&gt; в качестве строки-разделителя.</target>
        </trans-unit>
        <trans-unit id="53321b75d28930691a06237aff36907b43cca790" translate="yes" xml:space="preserve">
          <source>For each element in &lt;code&gt;a&lt;/code&gt;, return the highest index in the string where substring &lt;code&gt;sub&lt;/code&gt; is found, such that &lt;code&gt;sub&lt;/code&gt; is contained within [&lt;code&gt;start&lt;/code&gt;, &lt;code&gt;end&lt;/code&gt;].</source>
          <target state="translated">Для каждого элемента в , возвращают самый высокий индекс в строке , где подстроки &lt;code&gt;sub&lt;/code&gt; найден, таким образом, что к &lt;code&gt;sub&lt;/code&gt; содержится в [ &lt;code&gt;start&lt;/code&gt; , &lt;code&gt;end&lt;/code&gt; ]. &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="e01fe9cacbc57867bf7b4b4ec2f69fefe5c4a037" translate="yes" xml:space="preserve">
          <source>For each element in &lt;code&gt;a&lt;/code&gt;, split the element as the first occurrence of &lt;code&gt;sep&lt;/code&gt;, and return 3 strings containing the part before the separator, the separator itself, and the part after the separator. If the separator is not found, return 3 strings containing the string itself, followed by two empty strings.</source>
          <target state="translated">Для каждого элемента в &lt;code&gt;a&lt;/code&gt; разделите элемент как первое вхождение &lt;code&gt;sep&lt;/code&gt; и верните 3 строки, содержащие часть перед разделителем, сам разделитель и часть после разделителя. Если разделитель не найден, верните 3 строки, содержащие саму строку, за которыми следуют две пустые строки.</target>
        </trans-unit>
        <trans-unit id="7288d8c0ac4641f453c7b03f986690cbb92d91ab" translate="yes" xml:space="preserve">
          <source>For each element in &lt;code&gt;a&lt;/code&gt;, split the element as the last occurrence of &lt;code&gt;sep&lt;/code&gt;, and return 3 strings containing the part before the separator, the separator itself, and the part after the separator. If the separator is not found, return 3 strings containing the string itself, followed by two empty strings.</source>
          <target state="translated">Для каждого элемента в &lt;code&gt;a&lt;/code&gt; разделите элемент как последнее вхождение &lt;code&gt;sep&lt;/code&gt; и верните 3 строки, содержащие часть перед разделителем, сам разделитель и часть после разделителя. Если разделитель не найден, верните 3 строки, содержащие саму строку, за которыми следуют две пустые строки.</target>
        </trans-unit>
        <trans-unit id="b2be6980f0e55faed04690c7996e6d49756d7224" translate="yes" xml:space="preserve">
          <source>For each element in &lt;code&gt;self&lt;/code&gt;, return True if there are only decimal characters in the element.</source>
          <target state="translated">Для каждого элемента в &lt;code&gt;self&lt;/code&gt; верните True, если в элементе есть только десятичные символы.</target>
        </trans-unit>
        <trans-unit id="b59ff6bcceb7225ac9cadb07484ec0465abb9c2a" translate="yes" xml:space="preserve">
          <source>For each element in &lt;code&gt;self&lt;/code&gt;, return True if there are only numeric characters in the element.</source>
          <target state="translated">Для каждого элемента в &lt;code&gt;self&lt;/code&gt; верните True, если в элементе есть только числовые символы.</target>
        </trans-unit>
        <trans-unit id="9058afe727e5f02cb1c2a82daba2773477e47ab5" translate="yes" xml:space="preserve">
          <source>For each element in &lt;code&gt;self&lt;/code&gt;, return a copy of the string where all characters occurring in the optional argument &lt;code&gt;deletechars&lt;/code&gt; are removed, and the remaining characters have been mapped through the given translation table.</source>
          <target state="translated">Для каждого элемента в &lt;code&gt;self&lt;/code&gt; вернуть копию строки, в которой все символы, встречающиеся в необязательном аргументе &lt;code&gt;deletechars&lt;/code&gt; , удалены, а оставшиеся символы были отображены через данную таблицу перевода.</target>
        </trans-unit>
        <trans-unit id="ef526a1c4bb908663ee9a7ed64b48415ce75d7c1" translate="yes" xml:space="preserve">
          <source>For each element in &lt;code&gt;self&lt;/code&gt;, return a copy of the string with all occurrences of substring &lt;code&gt;old&lt;/code&gt; replaced by &lt;code&gt;new&lt;/code&gt;.</source>
          <target state="translated">Для каждого элемента в &lt;code&gt;self&lt;/code&gt; вернуть копию строки со всеми вхождениями подстроки &lt;code&gt;old&lt;/code&gt; , замененной на &lt;code&gt;new&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9e51c79c7e0159f28fc2312e8504acece61be2e0" translate="yes" xml:space="preserve">
          <source>For each element in &lt;code&gt;self&lt;/code&gt;, return a copy of the string with uppercase characters converted to lowercase and vice versa.</source>
          <target state="translated">Для каждого элемента в &lt;code&gt;self&lt;/code&gt; вернуть копию строки с прописными буквами, преобразованными в строчные, и наоборот.</target>
        </trans-unit>
        <trans-unit id="563e89160eca98fee13c4e654d4638943cb7ede0" translate="yes" xml:space="preserve">
          <source>For each element in &lt;code&gt;self&lt;/code&gt;, return a copy with the leading and trailing characters removed.</source>
          <target state="translated">Для каждого элемента в &lt;code&gt;self&lt;/code&gt; вернуть копию с удаленными начальными и конечными символами.</target>
        </trans-unit>
        <trans-unit id="a46f8951acf83f33ee77a16371dbcf5fcea54c99" translate="yes" xml:space="preserve">
          <source>For each element in &lt;code&gt;self&lt;/code&gt;, return a copy with the leading characters removed.</source>
          <target state="translated">Для каждого элемента в &lt;code&gt;self&lt;/code&gt; верните копию с удаленными ведущими символами.</target>
        </trans-unit>
        <trans-unit id="c528552cf6666391ba164c6c98e3136c037ac0d0" translate="yes" xml:space="preserve">
          <source>For each element in &lt;code&gt;self&lt;/code&gt;, return a copy with the trailing characters removed.</source>
          <target state="translated">Для каждого элемента в &lt;code&gt;self&lt;/code&gt; верните копию с удаленными завершающими символами.</target>
        </trans-unit>
        <trans-unit id="f3c87a7be827172789e8630db0faa9be334e4260" translate="yes" xml:space="preserve">
          <source>For each element in &lt;code&gt;self&lt;/code&gt;, return a list of the lines in the element, breaking at line boundaries.</source>
          <target state="translated">Для каждого элемента в &lt;code&gt;self&lt;/code&gt; вернуть список строк в элементе с разрывом на границах строк.</target>
        </trans-unit>
        <trans-unit id="3ca0a78fe28a9ed4242353e9fcde6e632b8bffa9" translate="yes" xml:space="preserve">
          <source>For each element in &lt;code&gt;self&lt;/code&gt;, return a list of the words in the string, using &lt;code&gt;sep&lt;/code&gt; as the delimiter string.</source>
          <target state="translated">Для каждого элемента в &lt;code&gt;self&lt;/code&gt; вернуть список слов в строке, используя &lt;code&gt;sep&lt;/code&gt; в качестве строки разделителя.</target>
        </trans-unit>
        <trans-unit id="41b923cc154e9a0efebee6038be59b5d66a9e904" translate="yes" xml:space="preserve">
          <source>For each element in &lt;code&gt;self&lt;/code&gt;, return a titlecased version of the string: words start with uppercase characters, all remaining cased characters are lowercase.</source>
          <target state="translated">Для каждого элемента в &lt;code&gt;self&lt;/code&gt; вернуть версию строки с заглавными буквами: слова начинаются с заглавных букв, все оставшиеся символы в регистре - строчные.</target>
        </trans-unit>
        <trans-unit id="a4fdbaa4039cefb583d1742ab7a44dc37da553da" translate="yes" xml:space="preserve">
          <source>For each element in &lt;code&gt;self&lt;/code&gt;, return the highest index in the string where substring &lt;code&gt;sub&lt;/code&gt; is found, such that &lt;code&gt;sub&lt;/code&gt; is contained within [&lt;code&gt;start&lt;/code&gt;, &lt;code&gt;end&lt;/code&gt;].</source>
          <target state="translated">Для каждого элемента в &lt;code&gt;self&lt;/code&gt; , вернуть самый высокий индекс в строке , где подстроки &lt;code&gt;sub&lt;/code&gt; найден, таким образом, что к &lt;code&gt;sub&lt;/code&gt; содержится в [ &lt;code&gt;start&lt;/code&gt; , &lt;code&gt;end&lt;/code&gt; ].</target>
        </trans-unit>
        <trans-unit id="66977f41b0aa64aabf235a79a75dcf6b6472f8b1" translate="yes" xml:space="preserve">
          <source>For each element, return True if there are only decimal characters in the element.</source>
          <target state="translated">Для каждого элемента верните True,если в элементе есть только десятичные символы.</target>
        </trans-unit>
        <trans-unit id="b1bf891f44f7ba1a69d9acfd1c67a586b04384f4" translate="yes" xml:space="preserve">
          <source>For each element, return True if there are only numeric characters in the element.</source>
          <target state="translated">Для каждого элемента верните True,если в элементе только числовые символы.</target>
        </trans-unit>
        <trans-unit id="de1f34aa0e69ee353932bddbc1b5178f2575078b" translate="yes" xml:space="preserve">
          <source>For each element, return the lowest index in the string where substring &lt;code&gt;sub&lt;/code&gt; is found, such that &lt;code&gt;sub&lt;/code&gt; is contained in the range [&lt;code&gt;start&lt;/code&gt;, &lt;code&gt;end&lt;/code&gt;].</source>
          <target state="translated">Для каждого элемента, вернуть самый низкий индекс в строке , где подстрока &lt;code&gt;sub&lt;/code&gt; найдено, таким образом, что к &lt;code&gt;sub&lt;/code&gt; содержатся в диапазоне [ &lt;code&gt;start&lt;/code&gt; , &lt;code&gt;end&lt;/code&gt; ].</target>
        </trans-unit>
        <trans-unit id="2d0516f761ea835ae249621609400fab8f420640" translate="yes" xml:space="preserve">
          <source>For each element, return the lowest index in the string where substring &lt;code&gt;sub&lt;/code&gt; is found.</source>
          <target state="translated">Для каждого элемента вернуть наименьший индекс в строке, где находится подстрока &lt;code&gt;sub&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="42afabee0f54dc6a738be8285f1c8adb1a389c2c" translate="yes" xml:space="preserve">
          <source>For events with an expected separation</source>
          <target state="translated">Для событий с ожидаемым отделением</target>
        </trans-unit>
        <trans-unit id="69f5ea3c2094e2e0d29f615dbd5f1be3db9e9635" translate="yes" xml:space="preserve">
          <source>For example &lt;a href=&quot;arrays.indexing#arrays-indexing&quot;&gt;slicing&lt;/a&gt; can produce views of the array:</source>
          <target state="translated">Например, &lt;a href=&quot;arrays.indexing#arrays-indexing&quot;&gt;нарезка&lt;/a&gt; может создавать представления массива:</target>
        </trans-unit>
        <trans-unit id="6ba61c52342c8ca357f9b025f520786b1e36f952" translate="yes" xml:space="preserve">
          <source>For example suppose the source directory contains fun/foo.dat and fun/bar/car.dat:</source>
          <target state="translated">Например,предположим,что исходный каталог содержит fun/foo.dat и fun/bar/car.dat:</target>
        </trans-unit>
        <trans-unit id="c528a73750dc2b0ea8c9a4908a64744d7d47416a" translate="yes" xml:space="preserve">
          <source>For example, &lt;a href=&quot;bit_generators/mt19937#numpy.random.mt19937.MT19937&quot;&gt;&lt;code&gt;MT19937&lt;/code&gt;&lt;/a&gt; has a state consisting of 624 &lt;code&gt;uint32&lt;/code&gt; integers. A naive way to take a 32-bit integer seed would be to just set the last element of the state to the 32-bit seed and leave the rest 0s. This is a valid state for &lt;a href=&quot;bit_generators/mt19937#numpy.random.mt19937.MT19937&quot;&gt;&lt;code&gt;MT19937&lt;/code&gt;&lt;/a&gt;, but not a good one. The Mersenne Twister algorithm &lt;a href=&quot;http://www.math.sci.hiroshima-u.ac.jp/~m-mat/MT/MT2002/emt19937ar.html&quot;&gt;suffers if there are too many 0s&lt;/a&gt;. Similarly, two adjacent 32-bit integer seeds (i.e. &lt;code&gt;12345&lt;/code&gt; and &lt;code&gt;12346&lt;/code&gt;) would produce very similar streams.</source>
          <target state="translated">Например, &lt;a href=&quot;bit_generators/mt19937#numpy.random.mt19937.MT19937&quot;&gt; &lt;code&gt;MT19937&lt;/code&gt; &lt;/a&gt; имеет состояние, состоящее из 624 целых чисел &lt;code&gt;uint32&lt;/code&gt; . Наивный способ получить 32-битное целочисленное начальное число - просто установить последний элемент состояния в 32-битное начальное число и оставить остальные нули. Это допустимое состояние для &lt;a href=&quot;bit_generators/mt19937#numpy.random.mt19937.MT19937&quot;&gt; &lt;code&gt;MT19937&lt;/code&gt; &lt;/a&gt; , но не очень хорошее. Алгоритм Мерсенна Твистера &lt;a href=&quot;http://www.math.sci.hiroshima-u.ac.jp/~m-mat/MT/MT2002/emt19937ar.html&quot;&gt;страдает, если имеется слишком много нулей&lt;/a&gt; . Точно так же два соседних 32-битных целых числа (т.е. &lt;code&gt;12345&lt;/code&gt; и &lt;code&gt;12346&lt;/code&gt; ) будут создавать очень похожие потоки.</target>
        </trans-unit>
        <trans-unit id="32bc5e66732d4344162eb54fb50c625865f9eafb" translate="yes" xml:space="preserve">
          <source>For example, add.accumulate() is equivalent to np.cumsum().</source>
          <target state="translated">Например,add.accumulate()эквивалентна np.cumsum().</target>
        </trans-unit>
        <trans-unit id="9a8d227d278d37b6250f8f06b0e4ddba59ee6707" translate="yes" xml:space="preserve">
          <source>For example, add.reduce() is equivalent to sum().</source>
          <target state="translated">Например,add.reduce()эквивалентна sum().</target>
        </trans-unit>
        <trans-unit id="10dea8dee68a389bd052fd52669dfbae04bf6a1e" translate="yes" xml:space="preserve">
          <source>For example, calculating 3*a, where a is an array of 32-bit floats, intuitively should result in a 32-bit float output. If the 3 is a 32-bit integer, the NumPy rules indicate it can&amp;rsquo;t convert losslessly into a 32-bit float, so a 64-bit float should be the result type. By examining the value of the constant, &amp;lsquo;3&amp;rsquo;, we see that it fits in an 8-bit integer, which can be cast losslessly into the 32-bit float.</source>
          <target state="translated">Например, вычисление 3 * a, где a - это массив 32-битных чисел с плавающей запятой, интуитивно должно привести к выходу 32-битных чисел с плавающей запятой. Если 3 - 32-битное целое число, правила NumPy указывают, что оно не может преобразовать без потерь в 32-битное число с плавающей запятой, поэтому типом результата должно быть 64-битное число с плавающей запятой. Изучая значение константы &amp;laquo;3&amp;raquo;, мы видим, что она подходит для 8-битного целого числа, которое можно без потерь преобразовать в 32-битное число с плавающей запятой.</target>
        </trans-unit>
        <trans-unit id="e896d341feb39ad2e94789a2fa3a61f98c1ab6de" translate="yes" xml:space="preserve">
          <source>For example, consider a ufunc with signature &lt;code&gt;(i,j),(i)-&amp;gt;()&lt;/code&gt;. In this case, &lt;code&gt;args&lt;/code&gt; will contain three pointers to the data of the input/output arrays &lt;code&gt;a&lt;/code&gt;, &lt;code&gt;b&lt;/code&gt;, &lt;code&gt;c&lt;/code&gt;. Furthermore, &lt;code&gt;dimensions&lt;/code&gt; will be &lt;code&gt;[N, I, J]&lt;/code&gt; to define the size of &lt;code&gt;N&lt;/code&gt; of the loop and the sizes &lt;code&gt;I&lt;/code&gt; and &lt;code&gt;J&lt;/code&gt; for the core dimensions &lt;code&gt;i&lt;/code&gt; and &lt;code&gt;j&lt;/code&gt;. Finally, &lt;code&gt;steps&lt;/code&gt; will be &lt;code&gt;[a_N, b_N, c_N, a_i, a_j, b_i]&lt;/code&gt;, containing all necessary strides.</source>
          <target state="translated">Например, рассмотрим ufunc с сигнатурой &lt;code&gt;(i,j),(i)-&amp;gt;()&lt;/code&gt; . В этом случае &lt;code&gt;args&lt;/code&gt; будет содержать три указателя на данные массивов ввода / вывода &lt;code&gt;a&lt;/code&gt; , &lt;code&gt;b&lt;/code&gt; , &lt;code&gt;c&lt;/code&gt; . Кроме того, &lt;code&gt;dimensions&lt;/code&gt; будут &lt;code&gt;[N, I, J]&lt;/code&gt; для определения размера &lt;code&gt;N&lt;/code&gt; петли и размеров &lt;code&gt;I&lt;/code&gt; и &lt;code&gt;J&lt;/code&gt; для размеров сердечника &lt;code&gt;i&lt;/code&gt; и &lt;code&gt;j&lt;/code&gt; . Наконец, &lt;code&gt;steps&lt;/code&gt; будут &lt;code&gt;[a_N, b_N, c_N, a_i, a_j, b_i]&lt;/code&gt; , содержащие все необходимые шаги.</target>
        </trans-unit>
        <trans-unit id="65c761c5136870def0974489fd65a1f38ad92d78" translate="yes" xml:space="preserve">
          <source>For example, for functions like &lt;code&gt;log&lt;/code&gt; with branch cuts, the versions in this module provide the mathematically valid answers in the complex plane:</source>
          <target state="translated">Например, для таких функций, как &lt;code&gt;log&lt;/code&gt; с разрезами ветвей, версии этого модуля предоставляют математически верные ответы в комплексной плоскости:</target>
        </trans-unit>
        <trans-unit id="1ae012c1a0fdd5d83c39490663637fce0836fd8c" translate="yes" xml:space="preserve">
          <source>For example, here is a typical source generator function:</source>
          <target state="translated">Например,вот типичная функция генератора источника:</target>
        </trans-unit>
        <trans-unit id="5f16b11fb1616884a1f7f0284cf2a3ad3bd24f37" translate="yes" xml:space="preserve">
          <source>For example, if &lt;code&gt;a&lt;/code&gt; is a 3x3 array:</source>
          <target state="translated">Например, если &lt;code&gt;a&lt;/code&gt; - это массив 3x3:</target>
        </trans-unit>
        <trans-unit id="7e1eba6b832e945c1e4ddb165d50f426b3bfee26" translate="yes" xml:space="preserve">
          <source>For example, if an iterator was created with a single array as its input, and it was possible to rearrange all its axes and then collapse it into a single strided iteration, this would return a view that is a one-dimensional array.</source>
          <target state="translated">Например,если бы итератор был создан с одним массивом в качестве входа,и можно было бы перестроить все его оси,а затем свернуть его в одну продольную итерацию,то это вернуло бы представление,которое является одномерным массивом.</target>
        </trans-unit>
        <trans-unit id="77b454223ff8bed8a9b0c67509f246c5fba091e9" translate="yes" xml:space="preserve">
          <source>For example, on a (typical linux x64 gcc) system, the numpy &lt;code&gt;complex64&lt;/code&gt; datatype is implemented as &lt;code&gt;struct { float real, imag; }&lt;/code&gt;. This has &amp;ldquo;true&amp;rdquo; alignment of 4 and &amp;ldquo;uint&amp;rdquo; alignment of 8 (equal to the true alignment of &lt;code&gt;uint64&lt;/code&gt;).</source>
          <target state="translated">Например, в системе (типичная для Linux x64 gcc) тип данных numpy &lt;code&gt;complex64&lt;/code&gt; реализован как &lt;code&gt;struct { float real, imag; }&lt;/code&gt; . Это имеет &amp;laquo;истинное&amp;raquo; выравнивание 4 и выравнивание &amp;laquo;uint&amp;raquo; 8 (равно истинному выравниванию &lt;code&gt;uint64&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="8b82f8996b94b3076d2602f80a0b8a902b3a3586" translate="yes" xml:space="preserve">
          <source>For examples, see the various functions.</source>
          <target state="translated">Например,см.различные функции.</target>
        </trans-unit>
        <trans-unit id="13b2e9c534395e7c5f78b138c5b0b5d135b327e2" translate="yes" xml:space="preserve">
          <source>For finite values, isclose uses the following equation to test whether two floating point values are equivalent.</source>
          <target state="translated">Для конечных значений isclose использует следующее уравнение для проверки эквивалентности двух значений с плавающей точкой.</target>
        </trans-unit>
        <trans-unit id="d62c0e35a11ece55b5adf0e9c849759b322d0ed9" translate="yes" xml:space="preserve">
          <source>For floating point arguments, the length of the result is &lt;code&gt;ceil((stop - start)/step)&lt;/code&gt;. Because of floating point overflow, this rule may result in the last element of &lt;code&gt;out&lt;/code&gt; being greater than &lt;code&gt;stop&lt;/code&gt;.</source>
          <target state="translated">Для аргументов с плавающей запятой длина результата равна &lt;code&gt;ceil((stop - start)/step)&lt;/code&gt; . Из-за переполнения с плавающей запятой это правило может привести к тому, что последний элемент &lt;code&gt;out&lt;/code&gt; будет больше, чем &lt;code&gt;stop&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e9208c67472507d398cb8a93a13859f9ce375088" translate="yes" xml:space="preserve">
          <source>For floating point numbers the numerical precision of sum (and &lt;code&gt;np.add.reduce&lt;/code&gt;) is in general limited by directly adding each number individually to the result causing rounding errors in every step. However, often numpy will use a numerically better approach (partial pairwise summation) leading to improved precision in many use-cases. This improved precision is always provided when no &lt;code&gt;axis&lt;/code&gt; is given. When &lt;code&gt;axis&lt;/code&gt; is given, it will depend on which axis is summed. Technically, to provide the best speed possible, the improved precision is only used when the summation is along the fast axis in memory. Note that the exact precision may vary depending on other parameters. In contrast to NumPy, Python&amp;rsquo;s &lt;code&gt;math.fsum&lt;/code&gt; function uses a slower but more precise approach to summation. Especially when summing a large number of lower precision floating point numbers, such as &lt;code&gt;float32&lt;/code&gt;, numerical errors can become significant. In such cases it can be advisable to use &lt;code&gt;dtype=&amp;rdquo;float64&amp;rdquo;&lt;/code&gt; to use a higher precision for the output.</source>
          <target state="translated">Для чисел с плавающей запятой числовая точность суммы (и &lt;code&gt;np.add.reduce&lt;/code&gt; ) обычно ограничивается прямым добавлением каждого числа отдельно к результату, вызывая ошибки округления на каждом шаге. Однако часто numpy будет использовать численно лучший подход (частичное попарное суммирование), что приведет к повышению точности во многих случаях использования. Эта улучшенная точность всегда обеспечивается, когда &lt;code&gt;axis&lt;/code&gt; не указана. Когда указана &lt;code&gt;axis&lt;/code&gt; , это будет зависеть от того, какая ось суммируется. Технически, чтобы обеспечить наилучшую возможную скорость, улучшенная точность используется только тогда, когда суммирование выполняется по быстрой оси в памяти. Обратите внимание, что точная точность может варьироваться в зависимости от других параметров. В отличие от NumPy, в Python &lt;code&gt;math.fsum&lt;/code&gt; функция использует более медленный, но более точный подход к суммированию. Численные ошибки могут стать значительными, особенно при суммировании большого количества чисел с плавающей запятой низкой точности, таких как &lt;code&gt;float32&lt;/code&gt; . В таких случаях можно &lt;code&gt;dtype=&amp;rdquo;float64&amp;rdquo;&lt;/code&gt; использовать dtype = &amp;rdquo;float64&amp;rdquo;, чтобы использовать более высокую точность вывода.</target>
        </trans-unit>
        <trans-unit id="f41c623cdcb4a0e7f4eb2e6a140ca19a3b6cef7a" translate="yes" xml:space="preserve">
          <source>For floating-point input, the &lt;em&gt;std&lt;/em&gt; is computed using the same precision the input has. Depending on the input data, this can cause the results to be inaccurate, especially for float32 (see example below). Specifying a higher-accuracy accumulator using the &lt;a href=&quot;numpy.dtype#numpy.dtype&quot;&gt;&lt;code&gt;dtype&lt;/code&gt;&lt;/a&gt; keyword can alleviate this issue.</source>
          <target state="translated">Для ввода с плавающей запятой &lt;em&gt;std&lt;/em&gt; вычисляется с той же точностью, что и ввод. В зависимости от входных данных это может привести к неточности результатов, особенно для float32 (см. Пример ниже). Указание аккумулятора более высокой точности с помощью &lt;a href=&quot;numpy.dtype#numpy.dtype&quot;&gt; &lt;code&gt;dtype&lt;/code&gt; &lt;/a&gt; слова dtype может решить эту проблему.</target>
        </trans-unit>
        <trans-unit id="effdce45ed2fe7c4c7447e7c5d6ed579806ca2bd" translate="yes" xml:space="preserve">
          <source>For floating-point input, the variance is computed using the same precision the input has. Depending on the input data, this can cause the results to be inaccurate, especially for &lt;code&gt;float32&lt;/code&gt; (see example below). Specifying a higher-accuracy accumulator using the &lt;code&gt;dtype&lt;/code&gt; keyword can alleviate this issue.</source>
          <target state="translated">Для ввода с плавающей запятой дисперсия вычисляется с той же точностью, что и ввод. В зависимости от входных данных это может привести к неточности результатов, особенно для &lt;code&gt;float32&lt;/code&gt; (см. Пример ниже). Указание аккумулятора более высокой точности с помощью &lt;code&gt;dtype&lt;/code&gt; слова dtype может решить эту проблему.</target>
        </trans-unit>
        <trans-unit id="d9b2341f620f885d0f8ab294ce3abbf3b1a90c60" translate="yes" xml:space="preserve">
          <source>For full documentation, see &lt;a href=&quot;numpy.searchsorted#numpy.searchsorted&quot;&gt;&lt;code&gt;numpy.searchsorted&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">Для полной документации см. &lt;a href=&quot;numpy.searchsorted#numpy.searchsorted&quot;&gt; &lt;code&gt;numpy.searchsorted&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="77c711733607bfc1bae041078b86f27ea8766c29" translate="yes" xml:space="preserve">
          <source>For further information, see &lt;a href=&quot;numpy.memmap#numpy.memmap&quot;&gt;&lt;code&gt;memmap&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Для получения дополнительной информации см. &lt;a href=&quot;numpy.memmap#numpy.memmap&quot;&gt; &lt;code&gt;memmap&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="8e32d40cffc64e1d0297c17e549d89391273d13d" translate="yes" xml:space="preserve">
          <source>For help in printing, the following strings are defined as the correct format specifier in printf and related commands.</source>
          <target state="translated">Для справки при печати следующие строки определяются как правильный спецификатор формата в командах printf и связанных с ними командах.</target>
        </trans-unit>
        <trans-unit id="489d6f9ad36355f45e025471f49df88064ca87ee" translate="yes" xml:space="preserve">
          <source>For higher dimensional arrays summing a single axis can be done with ellipsis:</source>
          <target state="translated">Для более объемных массивов суммирование одной оси может быть выполнено с помощью эллипсиса:</target>
        </trans-unit>
        <trans-unit id="6a424dcac51ca8b201228fd393c244dbeb8c5216" translate="yes" xml:space="preserve">
          <source>For i in &lt;code&gt;range(len(indices))&lt;/code&gt;, &lt;a href=&quot;#numpy.ufunc.reduceat&quot;&gt;&lt;code&gt;reduceat&lt;/code&gt;&lt;/a&gt; computes &lt;code&gt;ufunc.reduce(a[indices[i]:indices[i+1]])&lt;/code&gt;, which becomes the i-th generalized &amp;ldquo;row&amp;rdquo; parallel to &lt;code&gt;axis&lt;/code&gt; in the final result (i.e., in a 2-D array, for example, if &lt;code&gt;axis = 0&lt;/code&gt;, it becomes the i-th row, but if &lt;code&gt;axis = 1&lt;/code&gt;, it becomes the i-th column). There are three exceptions to this:</source>
          <target state="translated">Для ввода в &lt;code&gt;range(len(indices))&lt;/code&gt; , &lt;a href=&quot;#numpy.ufunc.reduceat&quot;&gt; &lt;code&gt;reduceat&lt;/code&gt; &lt;/a&gt; Вычисляет &lt;code&gt;ufunc.reduce(a[indices[i]:indices[i+1]])&lt;/code&gt; , который становится г-го обобщенную &amp;laquo;строка&amp;raquo; параллельно &lt;code&gt;axis&lt;/code&gt; в конечном итоге (т. е. в двумерном массиве, например, если &lt;code&gt;axis = 0&lt;/code&gt; , она становится i-й строкой, но если &lt;code&gt;axis = 1&lt;/code&gt; , она становится i-м столбцом). Из этого есть три исключения:</target>
        </trans-unit>
        <trans-unit id="05f651225304ab9158ee3f9e677f8c577d092edf" translate="yes" xml:space="preserve">
          <source>For input arrays that are smaller than the specified buffer size, copies are made of all non-contiguous, mis-aligned, or out-of- byteorder arrays to ensure that for small arrays, a single loop is used. Then, array iterators are created for all the input arrays and the resulting collection of iterators is broadcast to a single shape.</source>
          <target state="translated">Для входных массивов,размер которых меньше указанного буфера,копии делаются из всех несмежных,выровненных или не выровненных по порядку,чтобы для малых массивов использовался один цикл.Затем для всех входных массивов создаются итераторы массива и результирующая коллекция итераторов транслируется в единую форму.</target>
        </trans-unit>
        <trans-unit id="37dbe6dc0691b61b379d0a2afb8134a45871395a" translate="yes" xml:space="preserve">
          <source>For integer arguments with absolute value larger than 1 the result is always zero because of the way Python handles integer division. For integer zero the result is an overflow.</source>
          <target state="translated">Для целочисленных аргументов с абсолютным значением больше 1 результат всегда равен нулю из-за того,как Python обрабатывает целочисленное деление.Для целого числа zero результатом является переполнение.</target>
        </trans-unit>
        <trans-unit id="117e2f99abde5ef34211f008976cf994cee261a9" translate="yes" xml:space="preserve">
          <source>For integer input the return values are floats.</source>
          <target state="translated">Для целочисленного ввода возвращаемые значения являются плавающими.</target>
        </trans-unit>
        <trans-unit id="51f2302ae3afa42e90f16f1c35bbd2af61213570" translate="yes" xml:space="preserve">
          <source>For integer specifiers (eg. &lt;code&gt;d,i,o,x&lt;/code&gt;), the minimum number of digits.</source>
          <target state="translated">Для целочисленных спецификаторов (например, &lt;code&gt;d,i,o,x&lt;/code&gt; ) минимальное количество цифр.</target>
        </trans-unit>
        <trans-unit id="7401aba5507b33d4914d20070660b9faa95209c3" translate="yes" xml:space="preserve">
          <source>For integer types, exact equality is used, in the same way as &lt;a href=&quot;numpy.ma.masked_equal#numpy.ma.masked_equal&quot;&gt;&lt;code&gt;masked_equal&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Для целочисленных типов используется точное равенство, так же, как и &lt;a href=&quot;numpy.ma.masked_equal#numpy.ma.masked_equal&quot;&gt; &lt;code&gt;masked_equal&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="1e54c6af26706ff283ff28256c72b54eb26fbc6b" translate="yes" xml:space="preserve">
          <source>For integers, the fill value will be different in general to the result of &lt;code&gt;masked_equal&lt;/code&gt;.</source>
          <target state="translated">Для целых чисел значение заполнения будет отличаться от результата &lt;code&gt;masked_equal&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7d049cee37488c14a6b5c65b1da77ab9e42f2daa" translate="yes" xml:space="preserve">
          <source>For matrices that are not square or that (for negative powers) cannot be inverted numerically.</source>
          <target state="translated">Для матриц,которые не являются квадратными или которые (для отрицательных степеней)не могут быть инвертированы численно.</target>
        </trans-unit>
        <trans-unit id="582e5fdc5986730f5cfb2129f1c085cdd20f4ef0" translate="yes" xml:space="preserve">
          <source>For monotonically _increasing_ &lt;code&gt;bins&lt;/code&gt;, the following are equivalent:</source>
          <target state="translated">Для монотонно _increasing_ &lt;code&gt;bins&lt;/code&gt; , следующие условия эквивалентны:</target>
        </trans-unit>
        <trans-unit id="83fdf15871a7264e4f60e9ab78a977dea92e1a03" translate="yes" xml:space="preserve">
          <source>For more detailed documentation.</source>
          <target state="translated">Для более подробной документации.</target>
        </trans-unit>
        <trans-unit id="37ae37abcab4e25dbfe5d8b108d91993462a8cf5" translate="yes" xml:space="preserve">
          <source>For more details, see &lt;a href=&quot;numpy.random.mtrand.randomstate.set_state#numpy.random.mtrand.RandomState.set_state&quot;&gt;&lt;code&gt;set_state&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Для получения дополнительной информации см. &lt;a href=&quot;numpy.random.mtrand.randomstate.set_state#numpy.random.mtrand.RandomState.set_state&quot;&gt; &lt;code&gt;set_state&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="8f7f38b00189236c28757faab4aba491a5544afa" translate="yes" xml:space="preserve">
          <source>For more details, see &lt;code&gt;linalg.lstsq&lt;/code&gt;.</source>
          <target state="translated">Подробнее см. &lt;code&gt;linalg.lstsq&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="03f4a148b39366545cf97da19167eb00139c5efc" translate="yes" xml:space="preserve">
          <source>For more information on the qr factorization, see for example: &lt;a href=&quot;https://en.wikipedia.org/wiki/QR_factorization&quot;&gt;https://en.wikipedia.org/wiki/QR_factorization&lt;/a&gt;</source>
          <target state="translated">Для получения дополнительной информации о факторизации qr см., Например: &lt;a href=&quot;https://en.wikipedia.org/wiki/QR_factorization&quot;&gt;https://en.wikipedia.org/wiki/QR_factorization&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="3985651be63157e0b3fd0f006d48347a4d4ad484" translate="yes" xml:space="preserve">
          <source>For more information, a way to suppress the warning, and an example of &lt;a href=&quot;#numpy.RankWarning&quot;&gt;&lt;code&gt;RankWarning&lt;/code&gt;&lt;/a&gt; being issued, see &lt;a href=&quot;numpy.polyfit#numpy.polyfit&quot;&gt;&lt;code&gt;polyfit&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Для получения дополнительной информации, способа подавления предупреждения и примера &lt;a href=&quot;#numpy.RankWarning&quot;&gt; &lt;code&gt;RankWarning&lt;/code&gt; &lt;/a&gt; см. &lt;a href=&quot;numpy.polyfit#numpy.polyfit&quot;&gt; &lt;code&gt;polyfit&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="6c4cae020b6b04928ab8186f1d73c1c26eba4002" translate="yes" xml:space="preserve">
          <source>For more information, refer to the &lt;a href=&quot;../index#module-numpy&quot;&gt;&lt;code&gt;numpy&lt;/code&gt;&lt;/a&gt; module and examine the methods and attributes of an array.</source>
          <target state="translated">Для получения дополнительной информации обратитесь к модулю &lt;a href=&quot;../index#module-numpy&quot;&gt; &lt;code&gt;numpy&lt;/code&gt; &lt;/a&gt; и изучите методы и атрибуты массива.</target>
        </trans-unit>
        <trans-unit id="b32b573b8f00ce30b3419ec834d75448d214948d" translate="yes" xml:space="preserve">
          <source>For negative numbers, if width is not given, a minus sign is added to the front. If width is given, the two&amp;rsquo;s complement of the number is returned, with respect to that width.</source>
          <target state="translated">Для отрицательных чисел, если ширина не указана, спереди добавляется знак минус. Если задана ширина, возвращается двойное дополнение числа по отношению к этой ширине.</target>
        </trans-unit>
        <trans-unit id="6a2721282deb17b4500d92138a510cdb4754bcd3" translate="yes" xml:space="preserve">
          <source>For operations which are either not commutative or not associative, doing a reduction over multiple axes is not well-defined. The ufuncs do not currently raise an exception in this case, but will likely do so in the future.</source>
          <target state="translated">Для операций,которые не являются коммутационными или не ассоциативными,выполнение редукции по нескольким осям не имеет четкого определения.В настоящее время уфункции не вызывают исключений в данном случае,но,скорее всего,сделают это в будущем.</target>
        </trans-unit>
        <trans-unit id="cce08ac0d595dc1fc36977f113db0494cd013706" translate="yes" xml:space="preserve">
          <source>For other keyword-only arguments, see the &lt;a href=&quot;../ufuncs#ufuncs-kwargs&quot;&gt;ufunc docs&lt;/a&gt;.</source>
          <target state="translated">Для других аргументов, &lt;a href=&quot;../ufuncs#ufuncs-kwargs&quot;&gt;содержащих&lt;/a&gt; только ключевые слова, см. Документацию ufunc .</target>
        </trans-unit>
        <trans-unit id="0c08ef249ec6e440d6a8f4e999cc7fb84e271c54" translate="yes" xml:space="preserve">
          <source>For our example, we&amp;rsquo;ll create a sum of squares function. To start, let&amp;rsquo;s implement this function in straightforward Python. We want to support an &amp;lsquo;axis&amp;rsquo; parameter similar to the numpy &lt;a href=&quot;generated/numpy.sum#numpy.sum&quot;&gt;&lt;code&gt;sum&lt;/code&gt;&lt;/a&gt; function, so we will need to construct a list for the &lt;code&gt;op_axes&lt;/code&gt; parameter. Here&amp;rsquo;s how this looks.</source>
          <target state="translated">В нашем примере мы создадим функцию суммы квадратов. Для начала давайте реализуем эту функцию на простом Python. Мы хотим поддерживать параметр оси, аналогичный функции numpy &lt;a href=&quot;generated/numpy.sum#numpy.sum&quot;&gt; &lt;code&gt;sum&lt;/code&gt; &lt;/a&gt; , поэтому нам нужно будет создать список для параметра &lt;code&gt;op_axes&lt;/code&gt; . Вот как это выглядит.</target>
        </trans-unit>
        <trans-unit id="f8e34004cd49470f698985ea088603e79d6737af" translate="yes" xml:space="preserve">
          <source>For pickling.</source>
          <target state="translated">Для маринования.</target>
        </trans-unit>
        <trans-unit id="45d056f2d6dc25af69ffd36f748681cb1b37bcb7" translate="yes" xml:space="preserve">
          <source>For positive integers &lt;code&gt;n&lt;/code&gt;, the power is computed by repeated matrix squarings and matrix multiplications. If &lt;code&gt;n == 0&lt;/code&gt;, the identity matrix of the same shape as M is returned. If &lt;code&gt;n &amp;lt; 0&lt;/code&gt;, the inverse is computed and then raised to the &lt;code&gt;abs(n)&lt;/code&gt;.</source>
          <target state="translated">Для положительных целых чисел &lt;code&gt;n&lt;/code&gt; мощность вычисляется повторным возведением в квадрат матрицы и умножением матриц. Если &lt;code&gt;n == 0&lt;/code&gt; , возвращается единичная матрица той же формы, что и M. Если &lt;code&gt;n &amp;lt; 0&lt;/code&gt; , вычисляется обратное, а затем увеличивается до &lt;code&gt;abs(n)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2868f608509a0fb880318bfa1ea537e24b697cca" translate="yes" xml:space="preserve">
          <source>For private use, NumPy also constructs a &lt;code&gt;config.h&lt;/code&gt; in the NumPy include directory, which is not exported by NumPy (that is a python extension which use the numpy C API will not see those symbols), to avoid namespace pollution.</source>
          <target state="translated">Для частного использования NumPy также создает &lt;code&gt;config.h&lt;/code&gt; в каталоге включения NumPy, который не экспортируется NumPy (это расширение python, которое использует numpy C API, не будет видеть эти символы), чтобы избежать загрязнения пространства имен.</target>
        </trans-unit>
        <trans-unit id="3cba0cef0ecc3bf15466cf0b613737ac43d7cf46" translate="yes" xml:space="preserve">
          <source>For random samples from</source>
          <target state="translated">Для случайных образцов из</target>
        </trans-unit>
        <trans-unit id="3b14ea0275a3817032fbdd7fbc1e7bdb06b2af67" translate="yes" xml:space="preserve">
          <source>For real-valued input data types, &lt;a href=&quot;#numpy.arccos&quot;&gt;&lt;code&gt;arccos&lt;/code&gt;&lt;/a&gt; always returns real output. For each value that cannot be expressed as a real number or infinity, it yields &lt;code&gt;nan&lt;/code&gt; and sets the &lt;code&gt;invalid&lt;/code&gt; floating point error flag.</source>
          <target state="translated">Для типов входных данных с действительным &lt;a href=&quot;#numpy.arccos&quot;&gt; &lt;code&gt;arccos&lt;/code&gt; &lt;/a&gt; всегда возвращает реальный результат. Для каждого значения, которое не может быть выражено как действительное число или бесконечность, он возвращает &lt;code&gt;nan&lt;/code&gt; и устанавливает флаг ошибки &lt;code&gt;invalid&lt;/code&gt; плавающей запятой.</target>
        </trans-unit>
        <trans-unit id="f985096374044eb3c8f423921e1ca43a25a0a64a" translate="yes" xml:space="preserve">
          <source>For real-valued input data types, &lt;a href=&quot;#numpy.arccosh&quot;&gt;&lt;code&gt;arccosh&lt;/code&gt;&lt;/a&gt; always returns real output. For each value that cannot be expressed as a real number or infinity, it yields &lt;code&gt;nan&lt;/code&gt; and sets the &lt;code&gt;invalid&lt;/code&gt; floating point error flag.</source>
          <target state="translated">Для типов входных данных с &lt;a href=&quot;#numpy.arccosh&quot;&gt; &lt;code&gt;arccosh&lt;/code&gt; &lt;/a&gt; всегда возвращает реальный результат. Для каждого значения, которое не может быть выражено как действительное число или бесконечность, он возвращает &lt;code&gt;nan&lt;/code&gt; и устанавливает флаг ошибки &lt;code&gt;invalid&lt;/code&gt; плавающей запятой.</target>
        </trans-unit>
        <trans-unit id="1bd6dae91050b378f422d64d0fd3d06caee7dc76" translate="yes" xml:space="preserve">
          <source>For real-valued input data types, &lt;a href=&quot;#numpy.arcsinh&quot;&gt;&lt;code&gt;arcsinh&lt;/code&gt;&lt;/a&gt; always returns real output. For each value that cannot be expressed as a real number or infinity, it returns &lt;code&gt;nan&lt;/code&gt; and sets the &lt;code&gt;invalid&lt;/code&gt; floating point error flag.</source>
          <target state="translated">Для типов входных данных с &lt;a href=&quot;#numpy.arcsinh&quot;&gt; &lt;code&gt;arcsinh&lt;/code&gt; &lt;/a&gt; всегда возвращает реальный результат. Для каждого значения, которое не может быть выражено как действительное число или бесконечность, он возвращает &lt;code&gt;nan&lt;/code&gt; и устанавливает флаг ошибки &lt;code&gt;invalid&lt;/code&gt; плавающей запятой.</target>
        </trans-unit>
        <trans-unit id="f1a3e2a79ac88302cd49ced01b5ae36cb593f786" translate="yes" xml:space="preserve">
          <source>For real-valued input data types, &lt;a href=&quot;#numpy.arctan&quot;&gt;&lt;code&gt;arctan&lt;/code&gt;&lt;/a&gt; always returns real output. For each value that cannot be expressed as a real number or infinity, it yields &lt;code&gt;nan&lt;/code&gt; and sets the &lt;code&gt;invalid&lt;/code&gt; floating point error flag.</source>
          <target state="translated">Для типов входных данных с действительным &lt;a href=&quot;#numpy.arctan&quot;&gt; &lt;code&gt;arctan&lt;/code&gt; &lt;/a&gt; всегда возвращает реальный результат. Для каждого значения, которое не может быть выражено как действительное число или бесконечность, он возвращает &lt;code&gt;nan&lt;/code&gt; и устанавливает флаг ошибки &lt;code&gt;invalid&lt;/code&gt; плавающей запятой.</target>
        </trans-unit>
        <trans-unit id="4e59a4a7e10620a1dcf06247438f5e136a0933eb" translate="yes" xml:space="preserve">
          <source>For real-valued input data types, &lt;a href=&quot;#numpy.arctanh&quot;&gt;&lt;code&gt;arctanh&lt;/code&gt;&lt;/a&gt; always returns real output. For each value that cannot be expressed as a real number or infinity, it yields &lt;code&gt;nan&lt;/code&gt; and sets the &lt;code&gt;invalid&lt;/code&gt; floating point error flag.</source>
          <target state="translated">Для типов входных данных с &lt;a href=&quot;#numpy.arctanh&quot;&gt; &lt;code&gt;arctanh&lt;/code&gt; &lt;/a&gt; всегда возвращает реальный результат. Для каждого значения, которое не может быть выражено как действительное число или бесконечность, он возвращает &lt;code&gt;nan&lt;/code&gt; и устанавливает флаг ошибки &lt;code&gt;invalid&lt;/code&gt; плавающей запятой.</target>
        </trans-unit>
        <trans-unit id="00463e3d9bf72a8660310a707c972e6c6b2f2a87" translate="yes" xml:space="preserve">
          <source>For real-valued input data types, &lt;a href=&quot;#numpy.log&quot;&gt;&lt;code&gt;log&lt;/code&gt;&lt;/a&gt; always returns real output. For each value that cannot be expressed as a real number or infinity, it yields &lt;code&gt;nan&lt;/code&gt; and sets the &lt;code&gt;invalid&lt;/code&gt; floating point error flag.</source>
          <target state="translated">Для типов входных данных с действительным знаком &lt;a href=&quot;#numpy.log&quot;&gt; &lt;code&gt;log&lt;/code&gt; &lt;/a&gt; всегда возвращает реальный результат. Для каждого значения, которое не может быть выражено как действительное число или бесконечность, возвращается &lt;code&gt;nan&lt;/code&gt; и устанавливается флаг ошибки &lt;code&gt;invalid&lt;/code&gt; плавающей запятой.</target>
        </trans-unit>
        <trans-unit id="1dd401d005377ef79add082427bec36bd76d7d40" translate="yes" xml:space="preserve">
          <source>For real-valued input data types, &lt;a href=&quot;#numpy.log10&quot;&gt;&lt;code&gt;log10&lt;/code&gt;&lt;/a&gt; always returns real output. For each value that cannot be expressed as a real number or infinity, it yields &lt;code&gt;nan&lt;/code&gt; and sets the &lt;code&gt;invalid&lt;/code&gt; floating point error flag.</source>
          <target state="translated">Для типов входных данных с действительным &lt;a href=&quot;#numpy.log10&quot;&gt; &lt;code&gt;log10&lt;/code&gt; &lt;/a&gt; всегда возвращает действительный результат. Для каждого значения, которое не может быть выражено как действительное число или бесконечность, он возвращает &lt;code&gt;nan&lt;/code&gt; и устанавливает флаг ошибки &lt;code&gt;invalid&lt;/code&gt; плавающей запятой.</target>
        </trans-unit>
        <trans-unit id="18c562bcbaf668e2b82c801663121e7d15eaaa37" translate="yes" xml:space="preserve">
          <source>For real-valued input data types, &lt;a href=&quot;#numpy.log1p&quot;&gt;&lt;code&gt;log1p&lt;/code&gt;&lt;/a&gt; always returns real output. For each value that cannot be expressed as a real number or infinity, it yields &lt;code&gt;nan&lt;/code&gt; and sets the &lt;code&gt;invalid&lt;/code&gt; floating point error flag.</source>
          <target state="translated">Для типов входных данных с &lt;a href=&quot;#numpy.log1p&quot;&gt; &lt;code&gt;log1p&lt;/code&gt; &lt;/a&gt; всегда возвращает реальный вывод. Для каждого значения, которое не может быть выражено как действительное число или бесконечность, он возвращает &lt;code&gt;nan&lt;/code&gt; и устанавливает флаг ошибки &lt;code&gt;invalid&lt;/code&gt; плавающей запятой.</target>
        </trans-unit>
        <trans-unit id="cb65926ba3df7c570cfbf88879b3b9d563294100" translate="yes" xml:space="preserve">
          <source>For real-valued input data types, &lt;a href=&quot;#numpy.log2&quot;&gt;&lt;code&gt;log2&lt;/code&gt;&lt;/a&gt; always returns real output. For each value that cannot be expressed as a real number or infinity, it yields &lt;code&gt;nan&lt;/code&gt; and sets the &lt;code&gt;invalid&lt;/code&gt; floating point error flag.</source>
          <target state="translated">Для типов входных данных с &lt;a href=&quot;#numpy.log2&quot;&gt; &lt;code&gt;log2&lt;/code&gt; &lt;/a&gt; всегда возвращает действительный вывод. Для каждого значения, которое не может быть выражено как действительное число или бесконечность, он возвращает &lt;code&gt;nan&lt;/code&gt; и устанавливает флаг ошибки &lt;code&gt;invalid&lt;/code&gt; плавающей запятой.</target>
        </trans-unit>
        <trans-unit id="5a691d6f039d37de2f424c2292fd24a2e8849ab5" translate="yes" xml:space="preserve">
          <source>For real-valued input data types, &lt;em&gt;arcsin&lt;/em&gt; always returns real output. For each value that cannot be expressed as a real number or infinity, it yields &lt;code&gt;nan&lt;/code&gt; and sets the &lt;code&gt;invalid&lt;/code&gt; floating point error flag.</source>
          <target state="translated">Для типов входных данных с действительным &lt;em&gt;знаком arcsin&lt;/em&gt; всегда возвращает действительный вывод. Для каждого значения, которое не может быть выражено как действительное число или бесконечность, он возвращает &lt;code&gt;nan&lt;/code&gt; и устанавливает флаг ошибки &lt;code&gt;invalid&lt;/code&gt; плавающей запятой.</target>
        </trans-unit>
        <trans-unit id="ac8dda629e47802177efe000a2d093f5e016a0cb" translate="yes" xml:space="preserve">
          <source>For real-valued input, &lt;a href=&quot;#numpy.log1p&quot;&gt;&lt;code&gt;log1p&lt;/code&gt;&lt;/a&gt; is accurate also for &lt;code&gt;x&lt;/code&gt; so small that &lt;code&gt;1 + x == 1&lt;/code&gt; in floating-point accuracy.</source>
          <target state="translated">Для ввода с &lt;a href=&quot;#numpy.log1p&quot;&gt; &lt;code&gt;log1p&lt;/code&gt; &lt;/a&gt; является точным также для &lt;code&gt;x&lt;/code&gt; настолько малого, что &lt;code&gt;1 + x == 1&lt;/code&gt; в точности с плавающей точкой.</target>
        </trans-unit>
        <trans-unit id="8718e777159adb99e6030aa86f73aaa6419d14ea" translate="yes" xml:space="preserve">
          <source>For repeatability and readability, the dictionary keys are sorted in alphabetic order. This is for convenience only. A writer SHOULD implement this if possible. A reader MUST NOT depend on this.</source>
          <target state="translated">Для повторяемости и удобочитаемости клавиши словаря отсортированы в алфавитном порядке.Это делается только для удобства.Писатель ДОЛЖЕН по возможности реализовать это.Читатель НЕ ДОЛЖЕН от этого зависеть.</target>
        </trans-unit>
        <trans-unit id="6bd239911d468099089301c7ec88d5d1667469b6" translate="yes" xml:space="preserve">
          <source>For reshape, resize, and transpose, the single tuple argument may be replaced with &lt;code&gt;n&lt;/code&gt; integers which will be interpreted as an n-tuple.</source>
          <target state="translated">Для изменения формы, изменения размера и транспонирования единственный аргумент кортежа может быть заменен &lt;code&gt;n&lt;/code&gt; целыми числами, которые будут интерпретироваться как n-кортеж.</target>
        </trans-unit>
        <trans-unit id="6fe957d6ccb5cf28dddb483265ed8d862961930a" translate="yes" xml:space="preserve">
          <source>For scalar &lt;code&gt;a&lt;/code&gt;, returns the data type with the smallest size and smallest scalar kind which can hold its value.</source>
          <target state="translated">Для скаляра &lt;code&gt;a&lt;/code&gt; возвращает тип данных с наименьшим размером и наименьшим типом скаляра, который может содержать его значение.</target>
        </trans-unit>
        <trans-unit id="22863dbfbfce9a1b2c0c06d8e441eed6ee432e4b" translate="yes" xml:space="preserve">
          <source>For scalar &lt;code&gt;a&lt;/code&gt;, returns the data type with the smallest size and smallest scalar kind which can hold its value. For non-scalar array &lt;code&gt;a&lt;/code&gt;, returns the vector&amp;rsquo;s dtype unmodified.</source>
          <target state="translated">Для скаляра &lt;code&gt;a&lt;/code&gt; возвращает тип данных с наименьшим размером и наименьшим типом скаляра, который может содержать его значение. Для нескалярного массива &lt;code&gt;a&lt;/code&gt; возвращает dtype вектора без изменений.</target>
        </trans-unit>
        <trans-unit id="5642e4133974cc82494c6e2e1a04d4f6b4435c53" translate="yes" xml:space="preserve">
          <source>For several methods, an optional &lt;em&gt;out&lt;/em&gt; argument can also be provided and the result will be placed into the output array given. The &lt;em&gt;out&lt;/em&gt; argument must be an &lt;a href=&quot;generated/numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;ndarray&lt;/code&gt;&lt;/a&gt; and have the same number of elements. It can have a different data type in which case casting will be performed.</source>
          <target state="translated">Для некоторых методов также может быть предоставлен необязательный аргумент &lt;em&gt;out,&lt;/em&gt; и результат будет помещен в указанный выходной массив. &lt;em&gt;Из&lt;/em&gt; аргументов должны быть &lt;a href=&quot;generated/numpy.ndarray#numpy.ndarray&quot;&gt; &lt;code&gt;ndarray&lt;/code&gt; &lt;/a&gt; и имеют одинаковое число элементов. Он может иметь другой тип данных, в этом случае будет выполнено приведение.</target>
        </trans-unit>
        <trans-unit id="b0753b0fcbeca94ce7630240e047138c854a65dd" translate="yes" xml:space="preserve">
          <source>For signed integer inputs, the two&amp;rsquo;s complement is returned. In a two&amp;rsquo;s-complement system negative numbers are represented by the two&amp;rsquo;s complement of the absolute value. This is the most common method of representing signed integers on computers &lt;a href=&quot;#rde927b304c4f-1&quot; id=&quot;id1&quot;&gt;[1]&lt;/a&gt;. A N-bit two&amp;rsquo;s-complement system can represent every integer in the range</source>
          <target state="translated">Для целочисленных входов со знаком возвращается два дополнения. В системе с дополнением до двух отрицательные числа представлены дополнением до двух абсолютного значения. Это наиболее распространенный метод представления целых чисел со знаком на компьютерах &lt;a href=&quot;#rde927b304c4f-1&quot; id=&quot;id1&quot;&gt;[1]&lt;/a&gt; . N-битная система с дополнением до двух может представлять каждое целое число в диапазоне</target>
        </trans-unit>
        <trans-unit id="1790f111eccdfcb9badd8e72bbfbae78adf5ee18" translate="yes" xml:space="preserve">
          <source>For standard library functions:</source>
          <target state="translated">Для стандартных библиотечных функций:</target>
        </trans-unit>
        <trans-unit id="e58c1a1b97b83acb57ac2ac307ed0d7c16b3baf7" translate="yes" xml:space="preserve">
          <source>For structured arrays, all fields are combined, with masked values ignored. The result is masked if all fields were masked, with self and other considered equal only if both were fully masked.</source>
          <target state="translated">Для структурированных массивов все поля объединяются,при этом значения масок игнорируются.Результат маскируется,если все поля были замаскированы,при этом Я и другие считаются равными только в том случае,если оба были полностью замаскированы.</target>
        </trans-unit>
        <trans-unit id="54b403ec15e745ce9b0d408a4253b0a3db036c37" translate="yes" xml:space="preserve">
          <source>For structured types, a structured scalar is returned, with each field the default fill value for its type.</source>
          <target state="translated">Для структурированных типов возвращается структурированный скаляр,для каждого поля которого заполняется значение по умолчанию.</target>
        </trans-unit>
        <trans-unit id="7c0b7d9c35a991bbf7b4be3304607a91761fd2e6" translate="yes" xml:space="preserve">
          <source>For subarray types, the fill value is an array of the same size containing the default scalar fill value.</source>
          <target state="translated">Для типов подмассивов значение заливки-это массив такого же размера,содержащий значение скалярной заливки по умолчанию.</target>
        </trans-unit>
        <trans-unit id="fa1668cc4f1ad2127afa574513a965e4f8de0bd1" translate="yes" xml:space="preserve">
          <source>For tall matrices in NumPy version up to 1.6.2, the diagonal &amp;ldquo;wrapped&amp;rdquo; after N columns. You can have this behavior with this option. This affects only tall matrices.</source>
          <target state="translated">Для высоких матриц в версии NumPy до 1.6.2 диагональ &amp;laquo;оборачивается&amp;raquo; после N столбцов. Вы можете получить такое поведение с помощью этой опции. Это касается только высоких матриц.</target>
        </trans-unit>
        <trans-unit id="18e3d7bba1f8f57e3e3d0698a1673d2f7dbd0218" translate="yes" xml:space="preserve">
          <source>For the first run, we threw 3 times 1, 4 times 2, etc. For the second, we threw 2 times 1, 4 times 2, etc.</source>
          <target state="translated">За первый заезд мы бросали 3 раза 1,4 раза 2 и т.д.Во втором-2 раза 1,4 раза 2 и т.д.</target>
        </trans-unit>
        <trans-unit id="72f9e5e8e38fa061436e99d12c2a915135e47ac9" translate="yes" xml:space="preserve">
          <source>For the following methods there are also corresponding functions in &lt;a href=&quot;index#module-numpy&quot;&gt;&lt;code&gt;numpy&lt;/code&gt;&lt;/a&gt;: &lt;a href=&quot;generated/numpy.all#numpy.all&quot;&gt;&lt;code&gt;all&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;generated/numpy.any#numpy.any&quot;&gt;&lt;code&gt;any&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;generated/numpy.argmax#numpy.argmax&quot;&gt;&lt;code&gt;argmax&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;generated/numpy.argmin#numpy.argmin&quot;&gt;&lt;code&gt;argmin&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;generated/numpy.argpartition#numpy.argpartition&quot;&gt;&lt;code&gt;argpartition&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;generated/numpy.argsort#numpy.argsort&quot;&gt;&lt;code&gt;argsort&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;generated/numpy.choose#numpy.choose&quot;&gt;&lt;code&gt;choose&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;generated/numpy.clip#numpy.clip&quot;&gt;&lt;code&gt;clip&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;generated/numpy.compress#numpy.compress&quot;&gt;&lt;code&gt;compress&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;generated/numpy.copy#numpy.copy&quot;&gt;&lt;code&gt;copy&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;generated/numpy.cumprod#numpy.cumprod&quot;&gt;&lt;code&gt;cumprod&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;generated/numpy.cumsum#numpy.cumsum&quot;&gt;&lt;code&gt;cumsum&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;generated/numpy.diagonal#numpy.diagonal&quot;&gt;&lt;code&gt;diagonal&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;generated/numpy.imag#numpy.imag&quot;&gt;&lt;code&gt;imag&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;generated/numpy.amax#numpy.amax&quot;&gt;&lt;code&gt;max&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;generated/numpy.mean#numpy.mean&quot;&gt;&lt;code&gt;mean&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;generated/numpy.amin#numpy.amin&quot;&gt;&lt;code&gt;min&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;generated/numpy.nonzero#numpy.nonzero&quot;&gt;&lt;code&gt;nonzero&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;generated/numpy.partition#numpy.partition&quot;&gt;&lt;code&gt;partition&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;generated/numpy.prod#numpy.prod&quot;&gt;&lt;code&gt;prod&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;generated/numpy.ptp#numpy.ptp&quot;&gt;&lt;code&gt;ptp&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;generated/numpy.put#numpy.put&quot;&gt;&lt;code&gt;put&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;generated/numpy.ravel#numpy.ravel&quot;&gt;&lt;code&gt;ravel&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;generated/numpy.real#numpy.real&quot;&gt;&lt;code&gt;real&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;generated/numpy.repeat#numpy.repeat&quot;&gt;&lt;code&gt;repeat&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;generated/numpy.reshape#numpy.reshape&quot;&gt;&lt;code&gt;reshape&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;generated/numpy.around#numpy.around&quot;&gt;&lt;code&gt;round&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;generated/numpy.searchsorted#numpy.searchsorted&quot;&gt;&lt;code&gt;searchsorted&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;generated/numpy.sort#numpy.sort&quot;&gt;&lt;code&gt;sort&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;generated/numpy.squeeze#numpy.squeeze&quot;&gt;&lt;code&gt;squeeze&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;generated/numpy.std#numpy.std&quot;&gt;&lt;code&gt;std&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;generated/numpy.sum#numpy.sum&quot;&gt;&lt;code&gt;sum&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;generated/numpy.swapaxes#numpy.swapaxes&quot;&gt;&lt;code&gt;swapaxes&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;generated/numpy.take#numpy.take&quot;&gt;&lt;code&gt;take&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;generated/numpy.trace#numpy.trace&quot;&gt;&lt;code&gt;trace&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;generated/numpy.transpose#numpy.transpose&quot;&gt;&lt;code&gt;transpose&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;generated/numpy.var#numpy.var&quot;&gt;&lt;code&gt;var&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Для следующих методов имеются также соответствующие функции в &lt;a href=&quot;index#module-numpy&quot;&gt; &lt;code&gt;numpy&lt;/code&gt; &lt;/a&gt; : &lt;a href=&quot;generated/numpy.all#numpy.all&quot;&gt; &lt;code&gt;all&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;generated/numpy.any#numpy.any&quot;&gt; &lt;code&gt;any&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;generated/numpy.argmax#numpy.argmax&quot;&gt; &lt;code&gt;argmax&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;generated/numpy.argmin#numpy.argmin&quot;&gt; &lt;code&gt;argmin&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;generated/numpy.argpartition#numpy.argpartition&quot;&gt; &lt;code&gt;argpartition&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;generated/numpy.argsort#numpy.argsort&quot;&gt; &lt;code&gt;argsort&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;generated/numpy.choose#numpy.choose&quot;&gt; &lt;code&gt;choose&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;generated/numpy.clip#numpy.clip&quot;&gt; &lt;code&gt;clip&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;generated/numpy.compress#numpy.compress&quot;&gt; &lt;code&gt;compress&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;generated/numpy.copy#numpy.copy&quot;&gt; &lt;code&gt;copy&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;generated/numpy.cumprod#numpy.cumprod&quot;&gt; &lt;code&gt;cumprod&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;generated/numpy.cumsum#numpy.cumsum&quot;&gt; &lt;code&gt;cumsum&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;generated/numpy.diagonal#numpy.diagonal&quot;&gt; &lt;code&gt;diagonal&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;generated/numpy.imag#numpy.imag&quot;&gt; &lt;code&gt;imag&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;generated/numpy.amax#numpy.amax&quot;&gt; &lt;code&gt;max&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;generated/numpy.mean#numpy.mean&quot;&gt; &lt;code&gt;mean&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;generated/numpy.amin#numpy.amin&quot;&gt; &lt;code&gt;min&lt;/code&gt; &lt;/a&gt; , отличен от &lt;a href=&quot;generated/numpy.nonzero#numpy.nonzero&quot;&gt; &lt;code&gt;nonzero&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;generated/numpy.partition#numpy.partition&quot;&gt; &lt;code&gt;partition&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;generated/numpy.prod#numpy.prod&quot;&gt; &lt;code&gt;prod&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;generated/numpy.ptp#numpy.ptp&quot;&gt; &lt;code&gt;ptp&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;generated/numpy.put#numpy.put&quot;&gt; &lt;code&gt;put&lt;/code&gt; &lt;/a&gt; ,&lt;a href=&quot;generated/numpy.ravel#numpy.ravel&quot;&gt; &lt;code&gt;ravel&lt;/code&gt; &lt;/a&gt; ,&lt;a href=&quot;generated/numpy.real#numpy.real&quot;&gt; &lt;code&gt;real&lt;/code&gt; &lt;/a&gt; ,&lt;a href=&quot;generated/numpy.repeat#numpy.repeat&quot;&gt; &lt;code&gt;repeat&lt;/code&gt; &lt;/a&gt; ,&lt;a href=&quot;generated/numpy.reshape#numpy.reshape&quot;&gt; &lt;code&gt;reshape&lt;/code&gt; &lt;/a&gt; ,&lt;a href=&quot;generated/numpy.around#numpy.around&quot;&gt; &lt;code&gt;round&lt;/code&gt; &lt;/a&gt; ,&lt;a href=&quot;generated/numpy.searchsorted#numpy.searchsorted&quot;&gt; &lt;code&gt;searchsorted&lt;/code&gt; &lt;/a&gt; ,&lt;a href=&quot;generated/numpy.sort#numpy.sort&quot;&gt; &lt;code&gt;sort&lt;/code&gt; &lt;/a&gt; ,&lt;a href=&quot;generated/numpy.squeeze#numpy.squeeze&quot;&gt; &lt;code&gt;squeeze&lt;/code&gt; &lt;/a&gt; ,&lt;a href=&quot;generated/numpy.std#numpy.std&quot;&gt; &lt;code&gt;std&lt;/code&gt; &lt;/a&gt; ,&lt;a href=&quot;generated/numpy.sum#numpy.sum&quot;&gt; &lt;code&gt;sum&lt;/code&gt; &lt;/a&gt; ,&lt;a href=&quot;generated/numpy.swapaxes#numpy.swapaxes&quot;&gt; &lt;code&gt;swapaxes&lt;/code&gt; &lt;/a&gt; ,&lt;a href=&quot;generated/numpy.take#numpy.take&quot;&gt; &lt;code&gt;take&lt;/code&gt; &lt;/a&gt; ,&lt;a href=&quot;generated/numpy.trace#numpy.trace&quot;&gt; &lt;code&gt;trace&lt;/code&gt; &lt;/a&gt; ,&lt;a href=&quot;generated/numpy.transpose#numpy.transpose&quot;&gt; &lt;code&gt;transpose&lt;/code&gt; &lt;/a&gt; ,&lt;a href=&quot;generated/numpy.var#numpy.var&quot;&gt; &lt;code&gt;var&lt;/code&gt; &lt;/a&gt; . равномерный , реальный , повтор , изменение формы , округление , сортировка по поиску , сортировка , сжатие , стандартное, сумма , обмены осями , взять , трассировать , транспонировать , var .</target>
        </trans-unit>
        <trans-unit id="1f398fd04d9f322afdba477002ec5cde7b5d2d1b" translate="yes" xml:space="preserve">
          <source>For the general case, the iteration works by keeping track of a list of coordinate counters in the iterator object. At each iteration, the last coordinate counter is increased (starting from 0). If this counter is smaller than one less than the size of the array in that dimension (a pre-computed and stored value), then the counter is increased and the dataptr member is increased by the strides in that dimension and the macro ends. If the end of a dimension is reached, the counter for the last dimension is reset to zero and the dataptr is moved back to the beginning of that dimension by subtracting the strides value times one less than the number of elements in that dimension (this is also pre-computed and stored in the backstrides member of the iterator object). In this case, the macro does not end, but a local dimension counter is decremented so that the next-to-last dimension replaces the role that the last dimension played and the previously-described tests are executed again on the next-to-last dimension. In this way, the dataptr is adjusted appropriately for arbitrary striding.</source>
          <target state="translated">Для общего случая итерация работает по списку счетчиков координат в объекте итератора.При каждой итерации увеличивается последний счетчик координат (начиная с 0).Если этот счетчик меньше на единицу меньше,чем размер массива в этом измерении (предварительно вычисленное и сохраненное значение),то счетчик увеличивается,а член dataaptr увеличивается на шаги в этом измерении и макрос заканчивается.При достижении конца измерения счетчик последнего измерения сбрасывается на ноль,а датаптр перемещается обратно в начало этого измерения путем вычитания значения шага на единицу меньше,чем количество элементов в этом измерении (это также предварительно вычисленное и сохраненное в обратных шагах значение члена итератора).В этом случае макрос не заканчивается,а локальный счетчик размерностей декрементируется таким образом,что предпоследняя размерность заменяет роль,которую играла последняя размерность,а ранее описанные тесты выполняются снова на предпоследней размерности.Таким образом,датаптр корректируется соответствующим образом для произвольного шага.</target>
        </trans-unit>
        <trans-unit id="a106ff191577f5e49df4ba4a5b92a5dff872216c" translate="yes" xml:space="preserve">
          <source>For the most part, the rules for dispatch with &lt;code&gt;__array_function__&lt;/code&gt; match those for &lt;code&gt;__array_ufunc__&lt;/code&gt;. In particular:</source>
          <target state="translated">По большей части правила отправки с &lt;code&gt;__array_function__&lt;/code&gt; соответствуют &lt;code&gt;__array_ufunc__&lt;/code&gt; для __array_ufunc__ . В частности:</target>
        </trans-unit>
        <trans-unit id="5aabe002787ac5ab3c2a4862f3aa6c788cd300e2" translate="yes" xml:space="preserve">
          <source>For the typenum macros, the argument is an integer representing an enumerated array data type. For the array type checking macros the argument must be a &lt;a href=&quot;https://docs.python.org/dev/c-api/structures.html#c.PyObject&quot;&gt;&lt;code&gt;PyObject *&lt;/code&gt;&lt;/a&gt; that can be directly interpreted as a &lt;a href=&quot;c-api.types-and-structures#c.PyArrayObject&quot;&gt;&lt;code&gt;PyArrayObject *&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Для макросов typenum аргументом является целое число, представляющее тип данных перечислимого массива. Для макросов проверки типа массива аргумент должен быть &lt;a href=&quot;https://docs.python.org/dev/c-api/structures.html#c.PyObject&quot;&gt; &lt;code&gt;PyObject *&lt;/code&gt; ,&lt;/a&gt; который может быть напрямую интерпретирован как &lt;a href=&quot;c-api.types-and-structures#c.PyArrayObject&quot;&gt; &lt;code&gt;PyArrayObject *&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="5d3c40fa5c98be8aa15b70b390891bf28a170212" translate="yes" xml:space="preserve">
          <source>For these reasons it is advisable to avoid &lt;code&gt;as_strided&lt;/code&gt; when possible.</source>
          <target state="translated">По этим причинам рекомендуется по возможности избегать &lt;code&gt;as_strided&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="eb33fc8c29e1bd562bffb815c2697c66a036bae2" translate="yes" xml:space="preserve">
          <source>For these reasons, NumPy provides an API to work with npy_half values accessible by including &amp;lt;numpy/halffloat.h&amp;gt; and linking to &amp;lsquo;npymath&amp;rsquo;. For functions that are not provided directly, such as the arithmetic operations, the preferred method is to convert to float or double and back again, as in the following example.</source>
          <target state="translated">По этим причинам NumPy предоставляет API для работы со значениями npy_half, доступными при включении &amp;lt;numpy / halffloat.h&amp;gt; и ссылке на npymath. Для функций, которые не предоставляются напрямую, таких как арифметические операции, предпочтительным методом является преобразование в float или double и обратно, как в следующем примере.</target>
        </trans-unit>
        <trans-unit id="c5b0d8b34011752e4113aaa6a6fce2b3c78d19e5" translate="yes" xml:space="preserve">
          <source>For this function to work on sub-classes of ndarray, they must define &lt;a href=&quot;numpy.sum#numpy.sum&quot;&gt;&lt;code&gt;sum&lt;/code&gt;&lt;/a&gt; with the kwarg &lt;code&gt;keepdims&lt;/code&gt;</source>
          <target state="translated">Чтобы эта функция работала с подклассами ndarray, они должны определить &lt;a href=&quot;numpy.sum#numpy.sum&quot;&gt; &lt;code&gt;sum&lt;/code&gt; &lt;/a&gt; с помощью kwarg &lt;code&gt;keepdims&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="c7b38cff3c38a7296ea244a6f149ab3fa89299cb" translate="yes" xml:space="preserve">
          <source>For this reason, it is equivalent to (but faster than) the following use of &lt;a href=&quot;numpy.apply_along_axis#numpy.apply_along_axis&quot;&gt;&lt;code&gt;apply_along_axis&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">По этой причине это эквивалентно (но быстрее) следующему использованию &lt;a href=&quot;numpy.apply_along_axis#numpy.apply_along_axis&quot;&gt; &lt;code&gt;apply_along_axis&lt;/code&gt; &lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="77bbee921f7bbec73ea6da64c3957049942fe48c" translate="yes" xml:space="preserve">
          <source>For this sample array</source>
          <target state="translated">Для этого образца массива</target>
        </trans-unit>
        <trans-unit id="ef360ecaea0bceb4141bc860c62269adcea43126" translate="yes" xml:space="preserve">
          <source>For two dimensional arrays, the return will be two arrays ordered by axis. In this example the first array stands for the gradient in rows and the second one in columns direction:</source>
          <target state="translated">Для двухмерных массивов возвратом будут два массива,упорядоченных по осям.В данном примере первый массив обозначает градиент в строках,а второй-в направлении столбцов:</target>
        </trans-unit>
        <trans-unit id="5688be18895d1ed44e4e4ac9ea5a009f3d8f644d" translate="yes" xml:space="preserve">
          <source>For ufuncs dynamically created from python functions, this member holds a reference to the underlying Python function.</source>
          <target state="translated">Для уфункций,динамически создаваемых из питоновых функций,этот член содержит ссылку на лежащую в основе питоновскую функцию.</target>
        </trans-unit>
        <trans-unit id="f51d3a13e3a61d2cfd5f82478bfc77249b90c3e8" translate="yes" xml:space="preserve">
          <source>For ufuncs, it is hoped to eventually deprecate this method in favour of &lt;a href=&quot;#numpy.class.__array_ufunc__&quot;&gt;&lt;code&gt;__array_ufunc__&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Для ufuncs ожидается, что в конечном итоге этот метод будет устаревшим в пользу &lt;a href=&quot;#numpy.class.__array_ufunc__&quot;&gt; &lt;code&gt;__array_ufunc__&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="3fec4c12c09d2caf632487f32e741d15fde50a70" translate="yes" xml:space="preserve">
          <source>For unpickling.</source>
          <target state="translated">За распаковку.</target>
        </trans-unit>
        <trans-unit id="f5a617d92aada34c5b1b91d32c80426c8f059f29" translate="yes" xml:space="preserve">
          <source>For unsigned integer arrays, the results will also be unsigned. This should not be surprising, as the result is consistent with calculating the difference directly:</source>
          <target state="translated">Для беззнаковых целочисленных массивов результаты также будут беззнаковыми.Это не должно удивлять,так как результат согласуется с прямым вычислением разницы:</target>
        </trans-unit>
        <trans-unit id="4b61801e49c04aeb574dfd6c0384db9e70e2d05c" translate="yes" xml:space="preserve">
          <source>For use if one has reason to manually (re-)set the internal state of the bit generator used by the RandomState instance. By default, RandomState uses the &amp;ldquo;Mersenne Twister&amp;rdquo;&lt;a href=&quot;#r0933ec43c7c9-1&quot; id=&quot;id1&quot;&gt;[1]&lt;/a&gt; pseudo-random number generating algorithm.</source>
          <target state="translated">Используется, если есть причина вручную (повторно) установить внутреннее состояние генератора битов, используемого экземпляром RandomState. По умолчанию RandomState использует алгоритм генерации псевдослучайных чисел &amp;laquo;Mersenne Twister&amp;raquo; &lt;a href=&quot;#r0933ec43c7c9-1&quot; id=&quot;id1&quot;&gt;[1]&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="23f7c1942ce335813533514ab6d97be522e99c17" translate="yes" xml:space="preserve">
          <source>For use with &lt;a href=&quot;#c.NPY_ITER_ALLOCATE&quot;&gt;&lt;code&gt;NPY_ITER_ALLOCATE&lt;/code&gt;&lt;/a&gt;, this flag disables allocating an array subtype for the output, forcing it to be a straight ndarray.</source>
          <target state="translated">Для использования с &lt;a href=&quot;#c.NPY_ITER_ALLOCATE&quot;&gt; &lt;code&gt;NPY_ITER_ALLOCATE&lt;/code&gt; &lt;/a&gt; этот флаг отключает выделение подтипа массива для вывода, заставляя его быть прямым ndarray.</target>
        </trans-unit>
        <trans-unit id="4f63cfae8856e0c1b4c745d806a5044a1d2050ad" translate="yes" xml:space="preserve">
          <source>For use with &lt;a href=&quot;https://docs.python.org/dev/c-api/arg.html#c.PyArg_ParseTuple&quot;&gt;&lt;code&gt;PyArg_ParseTuple&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">Для использования с &lt;a href=&quot;https://docs.python.org/dev/c-api/arg.html#c.PyArg_ParseTuple&quot;&gt; &lt;code&gt;PyArg_ParseTuple&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="30f0a5ecb33fee954cb51300dbd6244641e9062e" translate="yes" xml:space="preserve">
          <source>For values exactly halfway between rounded decimal values, NumPy rounds to the nearest even value. Thus 1.5 and 2.5 round to 2.0, -0.5 and 0.5 round to 0.0, etc. Results may also be surprising due to the inexact representation of decimal fractions in the IEEE floating point standard &lt;a href=&quot;#r907366b089c1-1&quot; id=&quot;id1&quot;&gt;[1]&lt;/a&gt; and errors introduced when scaling by powers of ten.</source>
          <target state="translated">Для значений точно посередине округленных десятичных значений NumPy округляет до ближайшего четного значения. Таким образом, 1,5 и 2,5 округляются до 2,0, -0,5 и 0,5 округляются до 0,0 и т. Д. Результаты также могут быть удивительными из-за неточного представления десятичных дробей в стандарте IEEE с плавающей запятой &lt;a href=&quot;#r907366b089c1-1&quot; id=&quot;id1&quot;&gt;[1]&lt;/a&gt; и ошибок, возникающих при масштабировании по степеням десяти.</target>
        </trans-unit>
        <trans-unit id="4b8df8eb2541671de725aa87916abd483ac03487" translate="yes" xml:space="preserve">
          <source>For values of &lt;code&gt;ord &amp;lt;= 0&lt;/code&gt;, the result is, strictly speaking, not a mathematical &amp;lsquo;norm&amp;rsquo;, but it may still be useful for various numerical purposes.</source>
          <target state="translated">Для значений &lt;code&gt;ord &amp;lt;= 0&lt;/code&gt; результат, строго говоря, не является математической &amp;laquo;нормой&amp;raquo;, но все же может быть полезен для различных численных целей.</target>
        </trans-unit>
        <trans-unit id="d6c5fe59c42bb96e8794f338a14a9afba25af3e6" translate="yes" xml:space="preserve">
          <source>For vectors (1-D arrays) it computes the ordinary inner-product:</source>
          <target state="translated">Для векторов (1-D массивов)вычисляет обычный внутренний продукт:</target>
        </trans-unit>
        <trans-unit id="f31afbaa8abd3ce58c5bf83aec637268a269a63d" translate="yes" xml:space="preserve">
          <source>For vectors &lt;code&gt;x1&lt;/code&gt;, &lt;code&gt;x2&lt;/code&gt;,&amp;hellip;, &amp;lsquo;xn&amp;rsquo; with lengths &lt;code&gt;Ni=len(xi)&lt;/code&gt; , return &lt;code&gt;(N1, N2, N3,...Nn)&lt;/code&gt; shaped arrays if indexing=&amp;rsquo;ij&amp;rsquo; or &lt;code&gt;(N2, N1, N3,...Nn)&lt;/code&gt; shaped arrays if indexing=&amp;rsquo;xy&amp;rsquo; with the elements of &lt;code&gt;xi&lt;/code&gt; repeated to fill the matrix along the first dimension for &lt;code&gt;x1&lt;/code&gt;, the second for &lt;code&gt;x2&lt;/code&gt; and so on.</source>
          <target state="translated">Для векторов &lt;code&gt;x1&lt;/code&gt; , &lt;code&gt;x2&lt;/code&gt; ,&amp;hellip;, 'xn' с длинами &lt;code&gt;Ni=len(xi)&lt;/code&gt; вернуть массивы в форме &lt;code&gt;(N1, N2, N3,...Nn)&lt;/code&gt; если индексирование = 'ij' или &lt;code&gt;(N2, N1, N3,...Nn)&lt;/code&gt; если indexing = 'xy' с повторением элементов &lt;code&gt;xi&lt;/code&gt; , чтобы заполнить матрицу по первому измерению для &lt;code&gt;x1&lt;/code&gt; , второму для &lt;code&gt;x2&lt;/code&gt; и так далее.</target>
        </trans-unit>
        <trans-unit id="1f6242c0a79a41aa81490f6fd1ec86280110a2af" translate="yes" xml:space="preserve">
          <source>Force a cast to the output type even if it cannot be done safely. Without this flag, a data cast will occur only if it can be done safely, otherwise an error is raised.</source>
          <target state="translated">Принудите литье к выходному типу,даже если это не может быть сделано безопасно.Без этого флага приведение данных произойдет только в том случае,если это можно сделать безопасно,в противном случае ошибка будет поднята.</target>
        </trans-unit>
        <trans-unit id="d3ec8aad2bec1b3220d7b727c3bf434f0d55bc18" translate="yes" xml:space="preserve">
          <source>Force the mask to hard.</source>
          <target state="translated">Заставь маску закрепиться.</target>
        </trans-unit>
        <trans-unit id="cd0355317a1ab931fccb7ea5788f7a01c8683490" translate="yes" xml:space="preserve">
          <source>Force the mask to soft.</source>
          <target state="translated">Заставь маску размягчиться.</target>
        </trans-unit>
        <trans-unit id="46e07bf1dcba4f22fb0998d98afd707eecb583d3" translate="yes" xml:space="preserve">
          <source>Format Version 1.0</source>
          <target state="translated">Формат Версия 1.0</target>
        </trans-unit>
        <trans-unit id="9c5ba690bca66f9b43bf7dce492a8ecc14116342" translate="yes" xml:space="preserve">
          <source>Format Version 2.0</source>
          <target state="translated">Формат Версия 2.0</target>
        </trans-unit>
        <trans-unit id="6d476621018ad05f5efc66b66f9628e71614d77b" translate="yes" xml:space="preserve">
          <source>Format Version 3.0</source>
          <target state="translated">Формат Версия 3.0</target>
        </trans-unit>
        <trans-unit id="082aa72e2e80659bc0dafa9d8a6a53207113bd45" translate="yes" xml:space="preserve">
          <source>Format a floating-point scalar as a decimal string in positional notation.</source>
          <target state="translated">Форматирование скаляра с плавающей точкой в виде десятичной строки в позиционной нотации.</target>
        </trans-unit>
        <trans-unit id="63ec1825c81674406abf9c065439398606f8e9c4" translate="yes" xml:space="preserve">
          <source>Format a floating-point scalar as a decimal string in scientific notation.</source>
          <target state="translated">Отформатируйте скаляр с плавающей точкой в виде десятичной строки в научной нотации.</target>
        </trans-unit>
        <trans-unit id="2ba865544cbf6ad122958e97b9cb7e6ee2fca0ce" translate="yes" xml:space="preserve">
          <source>Format string for text file output. Each entry in the array is formatted to text by first converting it to the closest Python type, and then using &amp;ldquo;format&amp;rdquo; % item.</source>
          <target state="translated">Строка формата для вывода текстового файла. Каждая запись в массиве форматируется в текст, сначала преобразуя ее в ближайший тип Python, а затем используя элемент &amp;laquo;format&amp;raquo;%.</target>
        </trans-unit>
        <trans-unit id="e5a92b78c74fdad3772b95c0bef006808c6f5062" translate="yes" xml:space="preserve">
          <source>Fornberg B. (1988) Generation of Finite Difference Formulas on Arbitrarily Spaced Grids, Mathematics of Computation 51, no. 184 : 699-706. &lt;a href=&quot;http://www.ams.org/journals/mcom/1988-51-184/S0025-5718-1988-0935077-0/S0025-5718-1988-0935077-0.pdf&quot;&gt;PDF&lt;/a&gt;.</source>
          <target state="translated">Форнберг Б. (1988) Построение конечно-разностных формул на произвольно расположенных сетках, Математика вычислений 51, вып. 184: 699-706. &lt;a href=&quot;http://www.ams.org/journals/mcom/1988-51-184/S0025-5718-1988-0935077-0/S0025-5718-1988-0935077-0.pdf&quot;&gt;PDF&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="b756e1ed184faeae9981dd9378f750e8c6c0e04f" translate="yes" xml:space="preserve">
          <source>Fortran files</source>
          <target state="translated">Файлы Fortran</target>
        </trans-unit>
        <trans-unit id="443b7dd908046f637f8adbdcefe50ee302b6f087" translate="yes" xml:space="preserve">
          <source>Fortran order if all the inputs are Fortran, C otherwise.</source>
          <target state="translated">Заказ Fortran,если все входы-Fortran,C,в противном случае.</target>
        </trans-unit>
        <trans-unit id="0dbb13a4208640c43e953aa1ecfe0492f9b453d1" translate="yes" xml:space="preserve">
          <source>Fortran order.</source>
          <target state="translated">Заказ Фортрана.</target>
        </trans-unit>
        <trans-unit id="fa529d42774f0768730f12bc0880f9965a988000" translate="yes" xml:space="preserve">
          <source>Forward bytes from a subprocess call to the console, without attempting to decode them.</source>
          <target state="translated">Переадресация байтов из вызова подпроцесса на консоль,без попыток их декодирования.</target>
        </trans-unit>
        <trans-unit id="2982346b57dba0536f8cd38d08e71e22e03b5068" translate="yes" xml:space="preserve">
          <source>Four values of the output are invalid: the first one comes from taking the square root of a negative number, the second from the division by zero, and the last two where the inputs were masked.</source>
          <target state="translated">Четыре значения выхода недействительны:первое происходит от получения квадратного корня отрицательного числа,второе-от деления на ноль,а два последних-от маскировки входов.</target>
        </trans-unit>
        <trans-unit id="f163a620e6be53409bc7d6c8a56980a06cc8552e" translate="yes" xml:space="preserve">
          <source>Fourier analysis is fundamentally a method for expressing a function as a sum of periodic components, and for recovering the function from those components. When both the function and its Fourier transform are replaced with discretized counterparts, it is called the discrete Fourier transform (DFT). The DFT has become a mainstay of numerical computing in part because of a very fast algorithm for computing it, called the Fast Fourier Transform (FFT), which was known to Gauss (1805) and was brought to light in its current form by Cooley and Tukey &lt;a href=&quot;#rfb1dc64dd6a5-ct&quot; id=&quot;id1&quot;&gt;[CT]&lt;/a&gt;. Press et al. &lt;a href=&quot;#rfb1dc64dd6a5-nr&quot; id=&quot;id2&quot;&gt;[NR]&lt;/a&gt; provide an accessible introduction to Fourier analysis and its applications.</source>
          <target state="translated">По сути, анализ Фурье - это метод выражения функции как суммы периодических компонентов и восстановления функции из этих компонентов. Когда и функция, и ее преобразование Фурье заменяются дискретными аналогами, это называется дискретным преобразованием Фурье (ДПФ). ДПФ стало опорой численных вычислений отчасти из-за очень быстрого алгоритма для его вычисления, называемого быстрым преобразованием Фурье (БПФ), которое было известно Гауссу (1805 г.) и в его нынешней форме было обнаружено Кули и Тьюки &lt;a href=&quot;#rfb1dc64dd6a5-ct&quot; id=&quot;id1&quot;&gt;[CT]&lt;/a&gt; . Press et al. &lt;a href=&quot;#rfb1dc64dd6a5-nr&quot; id=&quot;id2&quot;&gt;[NR]&lt;/a&gt; предоставляют доступное введение в анализ Фурье и его приложения.</target>
        </trans-unit>
        <trans-unit id="55427a60a4bc7584f941291fc8f1c78e3b48892c" translate="yes" xml:space="preserve">
          <source>Fourteen C macros and fifteen C functions that can be used to write specialized typemaps, extensions, or inlined functions that handle cases not covered by the provided typemaps. Note that the macros and functions are coded specifically to work with the NumPy C/API regardless of NumPy version number, both before and after the deprecation of some aspects of the API after version 1.6.</source>
          <target state="translated">Четырнадцать макросов C и пятнадцать функций C,которые могут быть использованы для написания специализированных типовых карт,расширений или встраиваемых функций,которые обрабатывают случаи,не охваченные предоставленными типовыми картами.Обратите внимание,что макросы и функции закодированы специально для работы с NumPy C/API независимо от номера версии NumPy,как до,так и после удаления некоторых аспектов API после версии 1.6.</target>
        </trans-unit>
        <trans-unit id="a55119325a9e50ab95a500e00074b97b1b9e36d5" translate="yes" xml:space="preserve">
          <source>Fractional part of &lt;code&gt;x&lt;/code&gt;. This is a scalar if &lt;code&gt;x&lt;/code&gt; is a scalar.</source>
          <target state="translated">Дробная часть &lt;code&gt;x&lt;/code&gt; . Это скаляр, если &lt;code&gt;x&lt;/code&gt; - скаляр.</target>
        </trans-unit>
        <trans-unit id="3ef0af518168c89e00d0d671000eff79ef6d0866" translate="yes" xml:space="preserve">
          <source>Francis Hunt and Paul Johnson, On the Pareto Distribution of Sourceforge projects.</source>
          <target state="translated">Фрэнсис Хант и Пол Джонсон,&quot;О распределении проектов Sourceforge в Парето&quot;.</target>
        </trans-unit>
        <trans-unit id="1702d7b8bdd07fbea0c5cab99e1759e69160609f" translate="yes" xml:space="preserve">
          <source>Frequency bins for given FFT parameters.</source>
          <target state="translated">Бинты частоты для заданных параметров БПФ.</target>
        </trans-unit>
        <trans-unit id="8c7beab7a6d84d3a1004bcc75ccd72648a4866a0" translate="yes" xml:space="preserve">
          <source>Frobenius norm</source>
          <target state="translated">норма Фробения</target>
        </trans-unit>
        <trans-unit id="ddb8d23120bc74b1cfb060aa5332c0996e661cf6" translate="yes" xml:space="preserve">
          <source>From Dalgaard page 83 &lt;a href=&quot;#r9f872b3c913b-1&quot; id=&quot;id3&quot;&gt;[1]&lt;/a&gt;, suppose the daily energy intake for 11 women in kilojoules (kJ) is:</source>
          <target state="translated">На странице 83 &lt;a href=&quot;#r9f872b3c913b-1&quot; id=&quot;id3&quot;&gt;[1]&lt;/a&gt; Далгаарда предположим, что ежедневное потребление энергии для 11 женщин в килоджоулей (кДж) составляет:</target>
        </trans-unit>
        <trans-unit id="449b24b6007276ad9bb465db2968bb8f2f82cb23" translate="yes" xml:space="preserve">
          <source>From Dalgaard page 83 &lt;a href=&quot;#rb7c952f3992e-1&quot; id=&quot;id3&quot;&gt;[1]&lt;/a&gt;, suppose the daily energy intake for 11 women in kilojoules (kJ) is:</source>
          <target state="translated">На странице 83 &lt;a href=&quot;#rb7c952f3992e-1&quot; id=&quot;id3&quot;&gt;[1]&lt;/a&gt; Далгаарда предположим, что ежедневное потребление энергии для 11 женщин в килоджоулей (кДж) составляет:</target>
        </trans-unit>
        <trans-unit id="e91799328361ed7f1f3c997458139cffb3209540" translate="yes" xml:space="preserve">
          <source>From a 4x3 array the corner elements should be selected using advanced indexing. Thus all elements for which the column is one of &lt;code&gt;[0, 2]&lt;/code&gt; and the row is one of &lt;code&gt;[0, 3]&lt;/code&gt; need to be selected. To use advanced indexing one needs to select all elements &lt;em&gt;explicitly&lt;/em&gt;. Using the method explained previously one could write:</source>
          <target state="translated">Из массива 4x3 угловые элементы следует выбирать с помощью расширенной индексации. Таким образом &lt;code&gt;[0, 3]&lt;/code&gt; необходимо выбрать все элементы, для которых столбец является одним из &lt;code&gt;[0, 2]&lt;/code&gt; а строка - одним из [0, 3] . Чтобы использовать расширенное индексирование, необходимо &lt;em&gt;явно&lt;/em&gt; выделить все элементы . Используя метод, описанный ранее, можно написать:</target>
        </trans-unit>
        <trans-unit id="f43663857b3b074086e6a5458d7eeb8cc710716c" translate="yes" xml:space="preserve">
          <source>From a date and time:</source>
          <target state="translated">От даты и времени:</target>
        </trans-unit>
        <trans-unit id="b27ac815b804369e0e908095a8f60fb839b9ffbc" translate="yes" xml:space="preserve">
          <source>From an array, select all rows which sum up to less or equal two:</source>
          <target state="translated">Из массива выберите все строки,сумма которых меньше или равна двум:</target>
        </trans-unit>
        <trans-unit id="0b1e37af40ab4883a1e4a8a3dc83bcc94bb649dc" translate="yes" xml:space="preserve">
          <source>From each row, a specific element should be selected. The row index is just &lt;code&gt;[0, 1, 2]&lt;/code&gt; and the column index specifies the element to choose for the corresponding row, here &lt;code&gt;[0, 1, 0]&lt;/code&gt;. Using both together the task can be solved using advanced indexing:</source>
          <target state="translated">Из каждой строки следует выбрать определенный элемент. Индекс строки равен &lt;code&gt;[0, 1, 2]&lt;/code&gt; а индекс столбца определяет элемент, который следует выбрать для соответствующей строки, здесь &lt;code&gt;[0, 1, 0]&lt;/code&gt; . Используя оба вместе, задачу можно решить с помощью расширенного индексирования:</target>
        </trans-unit>
        <trans-unit id="2bdc929241ee7611d7ce8654d5c0e7a97c5922e2" translate="yes" xml:space="preserve">
          <source>From existing data</source>
          <target state="translated">На основании имеющихся данных</target>
        </trans-unit>
        <trans-unit id="0d7dc9b3626b3cb541c458a7c7758c637090adb4" translate="yes" xml:space="preserve">
          <source>From other objects</source>
          <target state="translated">От других объектов</target>
        </trans-unit>
        <trans-unit id="5dce71950093c2ccd6198a0075dc3e5ee84cb7ec" translate="yes" xml:space="preserve">
          <source>From scratch</source>
          <target state="translated">С нуля</target>
        </trans-unit>
        <trans-unit id="5f6cd09bf0f40761ab28ccaa4cab2a4c6c336752" translate="yes" xml:space="preserve">
          <source>Full indirect sort</source>
          <target state="translated">Полный косвенный сорт</target>
        </trans-unit>
        <trans-unit id="7d106cfe968d6ee1cdc60bee01550735688b85f7" translate="yes" xml:space="preserve">
          <source>Full sort.</source>
          <target state="translated">Полный сорт.</target>
        </trans-unit>
        <trans-unit id="733bce60654becd4d4e1700d743ab7573d5f2742" translate="yes" xml:space="preserve">
          <source>Full sorting</source>
          <target state="translated">Полная сортировка</target>
        </trans-unit>
        <trans-unit id="f14045db7fd843c69383648cf94f75fb3d176a15" translate="yes" xml:space="preserve">
          <source>Function call</source>
          <target state="translated">Вызов функции</target>
        </trans-unit>
        <trans-unit id="5fafc2ca93d61a962accac1563a05d9b48e0a23a" translate="yes" xml:space="preserve">
          <source>Function decorator to apply certain suppressions to a whole function.</source>
          <target state="translated">Декоратор функций для применения определенных подавлений к целой функции.</target>
        </trans-unit>
        <trans-unit id="6611eada8817f5f656a38dbcf1f891cb71be30b3" translate="yes" xml:space="preserve">
          <source>Function operating on ndarrays.</source>
          <target state="translated">Функция,работающая на ndarrays.</target>
        </trans-unit>
        <trans-unit id="7fb4f2de4dfb1639014358c3b7015d9c6a5f5d6b" translate="yes" xml:space="preserve">
          <source>Function pointer from &lt;a href=&quot;#c.NpyIter_GetIterNext&quot;&gt;&lt;code&gt;NpyIter_GetIterNext&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">Указатель на функцию из &lt;a href=&quot;#c.NpyIter_GetIterNext&quot;&gt; &lt;code&gt;NpyIter_GetIterNext&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="636b3b392dcabee45d972282bc714f124a2984ee" translate="yes" xml:space="preserve">
          <source>Function that converts a float array to float. Default is &lt;a href=&quot;https://docs.python.org/dev/library/functions.html#float&quot;&gt;&lt;code&gt;float&lt;/code&gt;&lt;/a&gt;. Note that this does not seem to do anything useful in the current implementation.</source>
          <target state="translated">Функция, преобразующая массив с плавающей запятой в плавающий. По умолчанию - &lt;a href=&quot;https://docs.python.org/dev/library/functions.html#float&quot;&gt; &lt;code&gt;float&lt;/code&gt; &lt;/a&gt; . Обратите внимание, что это, похоже, не делает ничего полезного в текущей реализации.</target>
        </trans-unit>
        <trans-unit id="25f491198ced438a979dee0c06f7b99f4c27522c" translate="yes" xml:space="preserve">
          <source>Function that converts a float or float array to an integer or integer array. Default is &lt;a href=&quot;https://docs.python.org/dev/library/functions.html#int&quot;&gt;&lt;code&gt;int&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Функция, которая преобразует массив с плавающей точкой или с плавающей запятой в целочисленный или целочисленный массив. По умолчанию &lt;a href=&quot;https://docs.python.org/dev/library/functions.html#int&quot;&gt; &lt;code&gt;int&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="c1c65cb38bc5533518bfad836c738613691b12bd" translate="yes" xml:space="preserve">
          <source>Function that converts a single float to a string. Default is &lt;code&gt;lambda v:'%24.16e' %v&lt;/code&gt;.</source>
          <target state="translated">Функция, преобразующая одиночное число с плавающей запятой в строку. По умолчанию &lt;code&gt;lambda v:'%24.16e' %v&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="49e035248ad61f94c49b3411ced40a15d03e994b" translate="yes" xml:space="preserve">
          <source>Function that converts an integer or integer array to a float or float array. Default is &lt;a href=&quot;https://docs.python.org/dev/library/functions.html#float&quot;&gt;&lt;code&gt;float&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Функция, преобразующая целочисленный или целочисленный массив в массив с плавающей или плавающей запятой. По умолчанию - &lt;a href=&quot;https://docs.python.org/dev/library/functions.html#float&quot;&gt; &lt;code&gt;float&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="7cdbff65d2dcd6dbb1f176839d343d5cd6740b77" translate="yes" xml:space="preserve">
          <source>Function to be used to pretty print arrays. The function should expect a single array argument and return a string of the representation of the array. If None, the function is reset to the default NumPy function to print arrays.</source>
          <target state="translated">Функция,используемая для красивых массивов печати.Функция должна ожидать единственный аргумент массива и возвращать строку представления массива.Если None,то для печати массивов функция сбрасывается в функцию NumPy по умолчанию.</target>
        </trans-unit>
        <trans-unit id="2e5428e59d421faf071ea47a590fb561ece5a39d" translate="yes" xml:space="preserve">
          <source>Function to calculate only the edges of the bins used by the &lt;a href=&quot;generated/numpy.histogram#numpy.histogram&quot;&gt;&lt;code&gt;histogram&lt;/code&gt;&lt;/a&gt; function.</source>
          <target state="translated">Функция для вычисления только краев интервалов, используемых функцией &lt;a href=&quot;generated/numpy.histogram#numpy.histogram&quot;&gt; &lt;code&gt;histogram&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="ecfa9e590ef0d3ed65da85a7cdda1af66b824ea3" translate="yes" xml:space="preserve">
          <source>Function to calculate only the edges of the bins used by the &lt;a href=&quot;numpy.histogram#numpy.histogram&quot;&gt;&lt;code&gt;histogram&lt;/code&gt;&lt;/a&gt; function.</source>
          <target state="translated">Функция для вычисления только краев интервалов, используемых функцией &lt;a href=&quot;numpy.histogram#numpy.histogram&quot;&gt; &lt;code&gt;histogram&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="3daae79264ded053c68caf5a77aad1db49558306" translate="yes" xml:space="preserve">
          <source>Function to call upon floating-point errors (&amp;lsquo;call&amp;rsquo;-mode) or object whose &amp;lsquo;write&amp;rsquo; method is used to log such message (&amp;lsquo;log&amp;rsquo;-mode).</source>
          <target state="translated">Функция для вызова при ошибках с плавающей запятой (режим &amp;laquo;call&amp;raquo;) или объект, чей метод &amp;laquo;записи&amp;raquo; используется для регистрации такого сообщения (режим &amp;laquo;журнала&amp;raquo;).</target>
        </trans-unit>
        <trans-unit id="936e3c682ce34cc0f0f7b3b6776919fc933d5fe1" translate="yes" xml:space="preserve">
          <source>Function which returns a masked inner loop for the ufunc</source>
          <target state="translated">Функция,которая возвращает маскированный внутренний цикл для ufunc.</target>
        </trans-unit>
        <trans-unit id="deb4e042b9d6249db97e6680ab8276b237985bd9" translate="yes" xml:space="preserve">
          <source>Functional programming</source>
          <target state="translated">Функциональное программирование</target>
        </trans-unit>
        <trans-unit id="2b961dea1dc0c60ddf9a2c8e9d090f6f7d082483" translate="yes" xml:space="preserve">
          <source>Functions</source>
          <target state="translated">Functions</target>
        </trans-unit>
        <trans-unit id="5a31942f8f4b1c24c2cf2f6e11f8f96977c918a6" translate="yes" xml:space="preserve">
          <source>Functions For Iteration</source>
          <target state="translated">Функции для итерации</target>
        </trans-unit>
        <trans-unit id="b7916ccc48b7ce0f25ff69e01c25e39ce11de03b" translate="yes" xml:space="preserve">
          <source>Functions implementing internal features. Not all of these function pointers must be defined for a given type. The required members are &lt;code&gt;nonzero&lt;/code&gt;, &lt;code&gt;copyswap&lt;/code&gt;, &lt;code&gt;copyswapn&lt;/code&gt;, &lt;code&gt;setitem&lt;/code&gt;, &lt;code&gt;getitem&lt;/code&gt;, and &lt;code&gt;cast&lt;/code&gt;. These are assumed to be non- &lt;code&gt;NULL&lt;/code&gt; and &lt;code&gt;NULL&lt;/code&gt; entries will cause a program crash. The other functions may be &lt;code&gt;NULL&lt;/code&gt; which will just mean reduced functionality for that data-type. (Also, the nonzero function will be filled in with a default function if it is &lt;code&gt;NULL&lt;/code&gt; when you register a user-defined data-type).</source>
          <target state="translated">Функции, реализующие внутренние функции. Не все эти указатели на функции должны быть определены для данного типа. Обязательными членами являются &lt;code&gt;nonzero&lt;/code&gt; , &lt;code&gt;copyswap&lt;/code&gt; , &lt;code&gt;copyswapn&lt;/code&gt; , &lt;code&gt;setitem&lt;/code&gt; , &lt;code&gt;getitem&lt;/code&gt; и &lt;code&gt;cast&lt;/code&gt; . Предполагается, что они не являются &lt;code&gt;NULL&lt;/code&gt; , и записи &lt;code&gt;NULL&lt;/code&gt; вызовут сбой программы. Другие функции могут иметь &lt;code&gt;NULL&lt;/code&gt; что будет означать только ограниченную функциональность для этого типа данных. (Кроме того, ненулевая функция будет заполнена функцией по умолчанию, если она имеет &lt;code&gt;NULL&lt;/code&gt; когда вы регистрируете определяемый пользователем тип данных).</target>
        </trans-unit>
        <trans-unit id="786d8b1defa125829799bc249caf1adda1184b6a" translate="yes" xml:space="preserve">
          <source>Functions returning an index along an axis, like &lt;a href=&quot;numpy.argsort#numpy.argsort&quot;&gt;&lt;code&gt;argsort&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;numpy.argpartition#numpy.argpartition&quot;&gt;&lt;code&gt;argpartition&lt;/code&gt;&lt;/a&gt;, produce suitable indices for this function.</source>
          <target state="translated">Функции, возвращающие индекс по оси, такие как &lt;a href=&quot;numpy.argsort#numpy.argsort&quot;&gt; &lt;code&gt;argsort&lt;/code&gt; &lt;/a&gt; и &lt;a href=&quot;numpy.argpartition#numpy.argpartition&quot;&gt; &lt;code&gt;argpartition&lt;/code&gt; &lt;/a&gt; , создают подходящие индексы для этой функции.</target>
        </trans-unit>
        <trans-unit id="7961218e053edec8b5fc62ef3005af10a3415803" translate="yes" xml:space="preserve">
          <source>Functions that are also in the numpy namespace and return matrices</source>
          <target state="translated">Функции,которые также находятся в нумерованном пространстве имён и возвратных матрицах</target>
        </trans-unit>
        <trans-unit id="6da76886d65d87e4650f5c14ec791f8c2f676112" translate="yes" xml:space="preserve">
          <source>Further explanation of the &lt;code&gt;fmt&lt;/code&gt; parameter (&lt;code&gt;%[flag]width[.precision]specifier&lt;/code&gt;):</source>
          <target state="translated">Дальнейшее объяснение параметра &lt;code&gt;fmt&lt;/code&gt; ( &lt;code&gt;%[flag]width[.precision]specifier&lt;/code&gt; ):</target>
        </trans-unit>
        <trans-unit id="fad9659f7e2980db9b405ad20b3c5294ccc96416" translate="yes" xml:space="preserve">
          <source>Further, note how &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; are combined:</source>
          <target state="translated">Кроме того, обратите внимание, как комбинируются &lt;code&gt;x&lt;/code&gt; и &lt;code&gt;y&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="9af0aaaf4de03972531671e0eb9bb87000ba4e1d" translate="yes" xml:space="preserve">
          <source>Furthermore, arrays created with this function often contain self overlapping memory, so that two elements are identical. Vectorized write operations on such arrays will typically be unpredictable. They may even give different results for small, large, or transposed arrays. Since writing to these arrays has to be tested and done with great care, you may want to use &lt;code&gt;writeable=False&lt;/code&gt; to avoid accidental write operations.</source>
          <target state="translated">Более того, массивы, созданные с помощью этой функции, часто содержат самоперекрывающуюся память, поэтому два элемента идентичны. Векторизованные операции записи в такие массивы обычно непредсказуемы. Они могут даже давать разные результаты для маленьких, больших или транспонированных массивов. Поскольку запись в эти массивы должна быть проверена и выполняться с большой осторожностью, вы можете использовать &lt;code&gt;writeable=False&lt;/code&gt; , чтобы избежать случайных операций записи.</target>
        </trans-unit>
        <trans-unit id="4f84a7ca85b2fada9bdf949e608abf006366bb0e" translate="yes" xml:space="preserve">
          <source>Furthermore, the callback function is of the same type as before, &lt;code&gt;void (*foo)(char **args, intp *dimensions, intp *steps, void *func)&lt;/code&gt;. When invoked, &lt;code&gt;args&lt;/code&gt; is a list of length &lt;code&gt;nargs&lt;/code&gt; containing the data of all input/output arguments. For a scalar elementary function, &lt;code&gt;steps&lt;/code&gt; is also of length &lt;code&gt;nargs&lt;/code&gt;, denoting the strides used for the arguments. &lt;code&gt;dimensions&lt;/code&gt; is a pointer to a single integer defining the size of the axis to be looped over.</source>
          <target state="translated">Кроме того, функция обратного вызова имеет тот же тип, что и раньше, &lt;code&gt;void (*foo)(char **args, intp *dimensions, intp *steps, void *func)&lt;/code&gt; . При вызове, &lt;code&gt;args&lt;/code&gt; список длины &lt;code&gt;nargs&lt;/code&gt; , содержащих данные всех входных / выходных параметров. Для скалярной элементарной функции &lt;code&gt;steps&lt;/code&gt; также имеют длину &lt;code&gt;nargs&lt;/code&gt; , обозначающую шаги, используемые для аргументов. &lt;code&gt;dimensions&lt;/code&gt; - это указатель на одно целое число, определяющее размер оси, по которой будет проходить цикл.</target>
        </trans-unit>
        <trans-unit id="b7285e0cef5e4daf805eb913ea140d9a03dc8d07" translate="yes" xml:space="preserve">
          <source>Future value</source>
          <target state="translated">Будущая стоимость</target>
        </trans-unit>
        <trans-unit id="0d44fa727f9b3f4d912a98a3e170b462f52557e6" translate="yes" xml:space="preserve">
          <source>Future value (default = 0)</source>
          <target state="translated">Будущее значение (по умолчанию=0)</target>
        </trans-unit>
        <trans-unit id="ba4092807d491bea64803fff0c7e477eac372847" translate="yes" xml:space="preserve">
          <source>Future values. If all input is scalar, returns a scalar float. If any input is array_like, returns future values for each input element. If multiple inputs are array_like, they all must have the same shape.</source>
          <target state="translated">Будущие ценности.Если все входные данные являются скалярными,возвращается скалярный плавающий диск.Если любой вход является массивом_подобным,возвращает будущие значения для каждого входного элемента.Если несколько входов похожи на массив_,то все они должны иметь одинаковую форму.</target>
        </trans-unit>
        <trans-unit id="2f44d78e0bf8d58385fdcde50f5d5e7baff3d944" translate="yes" xml:space="preserve">
          <source>G. H. Golub and C. F. Van Loan, &lt;em&gt;Matrix Computations&lt;/em&gt;, Baltimore, MD, Johns Hopkins University Press, 1985, pg. 15</source>
          <target state="translated">Голубь Г. и Ван Лоан, &lt;em&gt;Матричные вычисления&lt;/em&gt; , Балтимор, Мэриленд, издательство Университета Джона Хопкинса, 1985, стр. 15</target>
        </trans-unit>
        <trans-unit id="cbd53064adb7ff38d27c336291f9eaba7270aacd" translate="yes" xml:space="preserve">
          <source>G. Strang, &amp;ldquo;Linear Algebra and Its Applications, 2nd Edition,&amp;rdquo; Academic Press, pg. 182, 1980.</source>
          <target state="translated">Г. Стрэнг, &amp;laquo;Линейная алгебра и ее приложения, 2-е издание&amp;raquo;, Academic Press, стр. 182, 1980 г.</target>
        </trans-unit>
        <trans-unit id="0fee945837fcad5efdf449e24366c4e1f7b65d37" translate="yes" xml:space="preserve">
          <source>G. Strang, &lt;em&gt;Linear Algebra and Its Applications&lt;/em&gt;, 2nd Ed., Orlando, FL, Academic Press, Inc., 1980, Various pp.</source>
          <target state="translated">Г. Стрэнг, &lt;em&gt;Линейная алгебра и ее приложения&lt;/em&gt; , 2-е изд., Орландо, Флорида, Academic Press, Inc., 1980, стр.</target>
        </trans-unit>
        <trans-unit id="4d62050a6efa830b0646c86cf65d2a276c097206" translate="yes" xml:space="preserve">
          <source>G. Strang, &lt;em&gt;Linear Algebra and Its Applications&lt;/em&gt;, 2nd Ed., Orlando, FL, Academic Press, Inc., 1980, pg. 22.</source>
          <target state="translated">Г. Стрэнг, &lt;em&gt;Линейная алгебра и ее приложения&lt;/em&gt; , 2-е изд., Орландо, Флорида, Academic Press, Inc., 1980, стр. 22.</target>
        </trans-unit>
        <trans-unit id="8a5685424a4a906ee371dfacdea6a5b47dc7b3ff" translate="yes" xml:space="preserve">
          <source>G. Strang, &lt;em&gt;Linear Algebra and Its Applications&lt;/em&gt;, 2nd Ed., Orlando, FL, Academic Press, Inc., 1980, pg. 222.</source>
          <target state="translated">Г. Стрэнг, &lt;em&gt;Линейная алгебра и ее приложения&lt;/em&gt; , 2-е изд., Орландо, Флорида, Academic Press, Inc., 1980, стр. 222.</target>
        </trans-unit>
        <trans-unit id="db937a0ed23b9cf712fadda8ce2d53e90fb3fb34" translate="yes" xml:space="preserve">
          <source>G. Strang, &lt;em&gt;Linear Algebra and Its Applications&lt;/em&gt;, 2nd Ed., Orlando, FL, Academic Press, Inc., 1980, pp. 139-142.</source>
          <target state="translated">Г. Стрэнг, &lt;em&gt;Линейная алгебра и ее приложения&lt;/em&gt; , 2-е изд., Орландо, Флорида, Academic Press, Inc., 1980, стр. 139&amp;ndash;142.</target>
        </trans-unit>
        <trans-unit id="d923f5047de7db54bb0494345e02c3e60011f631" translate="yes" xml:space="preserve">
          <source>G. Strang, &lt;em&gt;Linear Algebra and Its Applications&lt;/em&gt;, Orlando, FL, Academic Press, Inc., 1980, pg. 285.</source>
          <target state="translated">Г. Стрэнг, &lt;em&gt;Линейная алгебра и ее приложения&lt;/em&gt; , Орландо, Флорида, Academic Press, Inc., 1980, стр. 285.</target>
        </trans-unit>
        <trans-unit id="e8a5e73fba8665db50a8e3577ecf8eb28b80e421" translate="yes" xml:space="preserve">
          <source>Gammas</source>
          <target state="translated">Gammas</target>
        </trans-unit>
        <trans-unit id="027498996e260dbd9c33778f3168019dfde3d4cc" translate="yes" xml:space="preserve">
          <source>Gauss-Chebyshev quadrature.</source>
          <target state="translated">Квадраты Гаусса-Чебышева.</target>
        </trans-unit>
        <trans-unit id="372d4c8be97b59c2965354454eaf80e844e74e50" translate="yes" xml:space="preserve">
          <source>Gauss-Hermite quadrature.</source>
          <target state="translated">Квадраты Гаусса-Хермита.</target>
        </trans-unit>
        <trans-unit id="90aa100cf157ec594ce20f650ca9a1d9019f03be" translate="yes" xml:space="preserve">
          <source>Gauss-HermiteE quadrature.</source>
          <target state="translated">Квадраты Гаусса-Хермита.</target>
        </trans-unit>
        <trans-unit id="9d10f081127b50e1f17e0a5c3971976017840cbe" translate="yes" xml:space="preserve">
          <source>Gauss-Laguerre quadrature.</source>
          <target state="translated">Квадратура Гаусса-Лагера.</target>
        </trans-unit>
        <trans-unit id="88f1f37c698b12eaffdc9bbccbc77d8b6246ccd8" translate="yes" xml:space="preserve">
          <source>Gauss-Legendre quadrature.</source>
          <target state="translated">Квадратура Гаусса-Легенды.</target>
        </trans-unit>
        <trans-unit id="0d731fc16d10c539de3eb06ab7ca854e8f4dd60e" translate="yes" xml:space="preserve">
          <source>General check of Python Type</source>
          <target state="translated">Общая проверка типа питона</target>
        </trans-unit>
        <trans-unit id="1b31f308f2ce85a33700b95c3da21fcb018ed716" translate="yes" xml:space="preserve">
          <source>General purpose exception class, derived from Python&amp;rsquo;s exception.Exception class, programmatically raised in linalg functions when a Linear Algebra-related condition would prevent further correct execution of the function.</source>
          <target state="translated">Класс исключения общего назначения, производный от класса Python exception.Exception, программно вызываемый в функциях linalg, когда условие, связанное с линейной алгеброй, препятствует дальнейшему правильному выполнению функции.</target>
        </trans-unit>
        <trans-unit id="6a5d5977ff7dabeb26104f13133251775857ac24" translate="yes" xml:space="preserve">
          <source>Generalised matrix product, using second last dimension of &lt;code&gt;b&lt;/code&gt;.</source>
          <target state="translated">Обобщенное матричное произведение с использованием второго последнего измерения &lt;code&gt;b&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9332c2d546d63dda92dba61cafe3df82f0dd8b19" translate="yes" xml:space="preserve">
          <source>Generalized Universal Function API</source>
          <target state="translated">Обобщенный универсальный API функции</target>
        </trans-unit>
        <trans-unit id="04b50941190dd87fa655dc29ac5df20dd7d7c66f" translate="yes" xml:space="preserve">
          <source>Generalized function class.</source>
          <target state="translated">Обобщенный класс функции.</target>
        </trans-unit>
        <trans-unit id="66a042cdeb42f3ae672017ab4c672646772ccf00" translate="yes" xml:space="preserve">
          <source>Generalized ufuncs are used internally in many linalg functions, and in the testing suite; the examples below are taken from these. For ufuncs that operate on scalars, the signature is &lt;code&gt;None&lt;/code&gt;, which is equivalent to &amp;lsquo;()&amp;rsquo; for every argument.</source>
          <target state="translated">Обобщенные ufuncs используются внутри многих функций linalg и в наборе тестирования; приведенные ниже примеры взяты из них. Для ufuncs, которые работают со скалярами, подпись &lt;code&gt;None&lt;/code&gt; , что эквивалентно '()' для каждого аргумента.</target>
        </trans-unit>
        <trans-unit id="d96ae300222cf76379f354819a4df06d3fbfa490" translate="yes" xml:space="preserve">
          <source>Generalized universal function signature, e.g., &lt;code&gt;(m,n),(n)-&amp;gt;(m)&lt;/code&gt; for vectorized matrix-vector multiplication. If provided, &lt;code&gt;pyfunc&lt;/code&gt; will be called with (and expected to return) arrays with shapes given by the size of corresponding core dimensions. By default, &lt;code&gt;pyfunc&lt;/code&gt; is assumed to take scalars as input and output.</source>
          <target state="translated">Обобщенная универсальная сигнатура функции, например, &lt;code&gt;(m,n),(n)-&amp;gt;(m)&lt;/code&gt; для векторизованного умножения матрицы на вектор. Если предоставлено, &lt;code&gt;pyfunc&lt;/code&gt; будет вызываться с (и должен возвращать) массивы с формами, заданными размером соответствующих основных размеров. По умолчанию предполагается , что &lt;code&gt;pyfunc&lt;/code&gt; принимает скаляры в качестве ввода и вывода.</target>
        </trans-unit>
        <trans-unit id="57b3bfe4a96aaf1f0210aadbf43dc393e3a362c6" translate="yes" xml:space="preserve">
          <source>Generally, the file needs to be generated during the build, since it needs some information known at build time only (e.g. prefix). This is mostly automatic if one uses the &lt;code&gt;Configuration&lt;/code&gt; method &lt;code&gt;add_npy_pkg_config&lt;/code&gt;. Assuming we have a template file foo.ini.in as follows:</source>
          <target state="translated">Как правило, файл необходимо сгенерировать во время сборки, поскольку ему нужна некоторая информация, известная только во время сборки (например, префикс). В основном это происходит автоматически, если используется метод &lt;code&gt;Configuration&lt;/code&gt; &lt;code&gt;add_npy_pkg_config&lt;/code&gt; . Предположим, у нас есть файл шаблона foo.ini.in следующим образом:</target>
        </trans-unit>
        <trans-unit id="ba56532a4a3fb8146e876e1d3659dfdac724a189" translate="yes" xml:space="preserve">
          <source>Generate a 1 by 3 array with 3 different lower bounds</source>
          <target state="translated">Сгенерировать массив 1 на 3 с 3 различными нижними границами</target>
        </trans-unit>
        <trans-unit id="3724c74e69c85b7924eab36b9e17078ea85e817c" translate="yes" xml:space="preserve">
          <source>Generate a 1 x 3 array with 3 different upper bounds</source>
          <target state="translated">Генерация массива 1 x 3 с 3 различными верхними границами</target>
        </trans-unit>
        <trans-unit id="c78b4920f6305013e33283131f3991e4d5dda157" translate="yes" xml:space="preserve">
          <source>Generate a 2 by 4 array using broadcasting with dtype of uint8</source>
          <target state="translated">Сгенерировать массив 2 на 4,используя широковещательное вещание с типом uint8.</target>
        </trans-unit>
        <trans-unit id="52ec8bca285ae5da030ea4680d276692f61c3804" translate="yes" xml:space="preserve">
          <source>Generate a 2 x 4 array of ints between 0 and 4, inclusive:</source>
          <target state="translated">Генерируйте массив 2 x 4 дюймов от 0 до 4 включительно:</target>
        </trans-unit>
        <trans-unit id="9e541c44f7aa5d7ed7acb09f3c0fe019e268af5e" translate="yes" xml:space="preserve">
          <source>Generate a Chebyshev series with given roots.</source>
          <target state="translated">Генерируйте чебышевскую серию с заданными корнями.</target>
        </trans-unit>
        <trans-unit id="0c791c1439e16e2fd0efb50c6644249b5b3eebb5" translate="yes" xml:space="preserve">
          <source>Generate a Hermite series with given roots.</source>
          <target state="translated">Создать серию &quot;Эрмита&quot; с заданными корнями.</target>
        </trans-unit>
        <trans-unit id="8bd121a27d585c3734742539ee143a52ac9b73de" translate="yes" xml:space="preserve">
          <source>Generate a HermiteE series with given roots.</source>
          <target state="translated">Создать серию HermiteE с заданными корнями.</target>
        </trans-unit>
        <trans-unit id="a9d697582320e7c884bbfd6a03995e4b278f2c74" translate="yes" xml:space="preserve">
          <source>Generate a Laguerre series with given roots.</source>
          <target state="translated">Создать серию Laguerre с заданными корнями.</target>
        </trans-unit>
        <trans-unit id="9fd152ea5ebdb08e6cd481a5737f68bdf9d18ad6" translate="yes" xml:space="preserve">
          <source>Generate a Legendre series with given roots.</source>
          <target state="translated">Создайте серию &quot;Легенда&quot; с заданными корнями.</target>
        </trans-unit>
        <trans-unit id="67cead80b0965ee4736c5f23fba251df4f3ebe37" translate="yes" xml:space="preserve">
          <source>Generate a Vandermonde matrix.</source>
          <target state="translated">Генерируйте на матрице Вандермонда.</target>
        </trans-unit>
        <trans-unit id="f4b901c2336926f254f07d1ab7b60e0386e5b58c" translate="yes" xml:space="preserve">
          <source>Generate a monic polynomial with given roots.</source>
          <target state="translated">Генерируйте моно-полиноминал с заданными корнями.</target>
        </trans-unit>
        <trans-unit id="2e173a5f3c2204af8ef7b9a77d34afee8c360a27" translate="yes" xml:space="preserve">
          <source>Generate a non-uniform random sample from np.arange(5) of size 3 without replacement:</source>
          <target state="translated">Генерация неоднородной случайной выборки из np.arange(5)размера 3 без замены:</target>
        </trans-unit>
        <trans-unit id="3b032abdb8bc3ee596986f951aad13aeb29eff03" translate="yes" xml:space="preserve">
          <source>Generate a non-uniform random sample from np.arange(5) of size 3:</source>
          <target state="translated">Генерируйте неоднородную случайную выборку из np.arange(5)размера 3:</target>
        </trans-unit>
        <trans-unit id="22ecb4243c3f96a98ea55b6a9b74781792dce996" translate="yes" xml:space="preserve">
          <source>Generate a uniform random sample from np.arange(5) of size 3 without replacement:</source>
          <target state="translated">Генерировать однородную случайную выборку из np.arange(5)размера 3 без замены:</target>
        </trans-unit>
        <trans-unit id="7e7e8cdcfbc5d1d81d3a8108edeaf14a80335951" translate="yes" xml:space="preserve">
          <source>Generate a uniform random sample from np.arange(5) of size 3:</source>
          <target state="translated">Генерировать однородную случайную выборку из np.arange(5)размера 3:</target>
        </trans-unit>
        <trans-unit id="382b425e693319395299c741c143ce2398939efe" translate="yes" xml:space="preserve">
          <source>Generate and install a npy-pkg config file from a template.</source>
          <target state="translated">Сгенерировать и установить npy-pkg конфигурационный файл из шаблона.</target>
        </trans-unit>
        <trans-unit id="19a90f1dba170779ac0befe5afd3d6d9c884c6d1" translate="yes" xml:space="preserve">
          <source>Generate config.py file containing system_info information used during building the package.</source>
          <target state="translated">Сгенерировать файл config.py,содержащий информацию system_info,используемую при сборке пакета.</target>
        </trans-unit>
        <trans-unit id="34c49c62f8886e09ca6e64b9c96074bf60926d62" translate="yes" xml:space="preserve">
          <source>Generate package __config__.py file containing system_info information used during building the package.</source>
          <target state="translated">Сгенерировать файл пакета __config__.py,содержащий информацию о системе_info,используемую при сборке пакета.</target>
        </trans-unit>
        <trans-unit id="14952923eed9a754d36fbf7d9df88e59880c6dad" translate="yes" xml:space="preserve">
          <source>Generate package __svn_version__.py file from SVN revision number, it will be removed after python exits but will be available when sdist, etc commands are executed.</source>
          <target state="translated">Сгенерируйте файл пакета __svn_version__.py из номера ревизии SVN,он будет удален после выхода из python,но будет доступен при выполнении sdist и т.д.команд.</target>
        </trans-unit>
        <trans-unit id="3cd9212c9f1d53d55d853a3b264e1b6b858f35fd" translate="yes" xml:space="preserve">
          <source>Generates a random sample from a given 1-D array</source>
          <target state="translated">Генерирует случайную выборку из заданного 1-D массива.</target>
        </trans-unit>
        <trans-unit id="150ce9aa76a74d0a43ead917a8c785193ed877b1" translate="yes" xml:space="preserve">
          <source>Generating index arrays</source>
          <target state="translated">Генерирующие индексные массивы</target>
        </trans-unit>
        <trans-unit id="2bb174c2f425e0d1a36b6da19833f5708052f5b2" translate="yes" xml:space="preserve">
          <source>Generator.beta()</source>
          <target state="translated">Generator.beta()</target>
        </trans-unit>
        <trans-unit id="5c54211367d38fc1c657f1a2b11682aa7073f8a0" translate="yes" xml:space="preserve">
          <source>Generator.binomial()</source>
          <target state="translated">Generator.binomial()</target>
        </trans-unit>
        <trans-unit id="d222082a3e85bc085f3813830709c1091b870201" translate="yes" xml:space="preserve">
          <source>Generator.bit_generator</source>
          <target state="translated">Generator.bit_generator</target>
        </trans-unit>
        <trans-unit id="ccf1aa45703830ef34744bdb91c5ee84eb339af2" translate="yes" xml:space="preserve">
          <source>Generator.bytes()</source>
          <target state="translated">Generator.bytes()</target>
        </trans-unit>
        <trans-unit id="a1e223f39e59656efb6dcd2b450fd1f3d11e0f5b" translate="yes" xml:space="preserve">
          <source>Generator.chisquare()</source>
          <target state="translated">Generator.chisquare()</target>
        </trans-unit>
        <trans-unit id="a2cf011c29fcb364a340b0b0739ed3940f0415ce" translate="yes" xml:space="preserve">
          <source>Generator.choice()</source>
          <target state="translated">Generator.choice()</target>
        </trans-unit>
        <trans-unit id="acb19d66e8b5e00bd8ab9eaa938d00f3718515fe" translate="yes" xml:space="preserve">
          <source>Generator.dirichlet()</source>
          <target state="translated">Generator.dirichlet()</target>
        </trans-unit>
        <trans-unit id="81c841ae15f138b1059c14b8ebc34f2ceb6506da" translate="yes" xml:space="preserve">
          <source>Generator.exponential()</source>
          <target state="translated">Generator.exponential()</target>
        </trans-unit>
        <trans-unit id="ceb6ee1b51ecd1875248d0ca388e0fb1daabb181" translate="yes" xml:space="preserve">
          <source>Generator.f()</source>
          <target state="translated">Generator.f()</target>
        </trans-unit>
        <trans-unit id="9a5544f1f1d846a0215be8277752788b52f5d5ae" translate="yes" xml:space="preserve">
          <source>Generator.gamma()</source>
          <target state="translated">Generator.gamma()</target>
        </trans-unit>
        <trans-unit id="cb698152656074b26c2b514594b6841ba98646e0" translate="yes" xml:space="preserve">
          <source>Generator.geometric()</source>
          <target state="translated">Generator.geometric()</target>
        </trans-unit>
        <trans-unit id="fbe271ee0cdf14a0b127e97b8a754332b21122bf" translate="yes" xml:space="preserve">
          <source>Generator.gumbel()</source>
          <target state="translated">Generator.gumbel()</target>
        </trans-unit>
        <trans-unit id="1bb4c4773f6c2e362f6bdc12b4738edbd30f23d2" translate="yes" xml:space="preserve">
          <source>Generator.hypergeometric()</source>
          <target state="translated">Generator.hypergeometric()</target>
        </trans-unit>
        <trans-unit id="c50dbdf77399f33f0754452bd827d7d9972e1f6e" translate="yes" xml:space="preserve">
          <source>Generator.integers()</source>
          <target state="translated">Generator.integers()</target>
        </trans-unit>
        <trans-unit id="2ac6ee43d1992ed473a404e92103ad981ee56dd8" translate="yes" xml:space="preserve">
          <source>Generator.laplace()</source>
          <target state="translated">Generator.laplace()</target>
        </trans-unit>
        <trans-unit id="9a01e0244542efabb99865e59014bd47d50fe182" translate="yes" xml:space="preserve">
          <source>Generator.logistic()</source>
          <target state="translated">Generator.logistic()</target>
        </trans-unit>
        <trans-unit id="c320801600fb9c31cc3d790a76584f303a266f0d" translate="yes" xml:space="preserve">
          <source>Generator.lognormal()</source>
          <target state="translated">Generator.lognormal()</target>
        </trans-unit>
        <trans-unit id="2133a52d0f531222ffd5b10595265bd407d65eae" translate="yes" xml:space="preserve">
          <source>Generator.logseries()</source>
          <target state="translated">Generator.logseries()</target>
        </trans-unit>
        <trans-unit id="3fb5b968b7c3c6e4334e366ce81b7d1c72dd0587" translate="yes" xml:space="preserve">
          <source>Generator.multinomial()</source>
          <target state="translated">Generator.multinomial()</target>
        </trans-unit>
        <trans-unit id="ee77530caf29c96157f8b247c28bc2729509bc1f" translate="yes" xml:space="preserve">
          <source>Generator.multivariate_normal()</source>
          <target state="translated">Generator.multivariate_normal()</target>
        </trans-unit>
        <trans-unit id="e4accfbbf5411ba4e6ed6190c6c4a4f347889476" translate="yes" xml:space="preserve">
          <source>Generator.negative_binomial()</source>
          <target state="translated">Generator.negative_binomial()</target>
        </trans-unit>
        <trans-unit id="f5c86d9e1ec54b1f6ceef69c6b35acbc51980bb9" translate="yes" xml:space="preserve">
          <source>Generator.noncentral_chisquare()</source>
          <target state="translated">Generator.noncentral_chisquare()</target>
        </trans-unit>
        <trans-unit id="4ffb9eb22957bfe4ccb8d5eb67072da9ed2c8fe8" translate="yes" xml:space="preserve">
          <source>Generator.noncentral_f()</source>
          <target state="translated">Generator.noncentral_f()</target>
        </trans-unit>
        <trans-unit id="155766b36ed963438beae39d25dc848285e67bec" translate="yes" xml:space="preserve">
          <source>Generator.normal()</source>
          <target state="translated">Generator.normal()</target>
        </trans-unit>
        <trans-unit id="b6ff7a92707e2ef9f9f69eb28c0f2a89afd2fb30" translate="yes" xml:space="preserve">
          <source>Generator.pareto()</source>
          <target state="translated">Generator.pareto()</target>
        </trans-unit>
        <trans-unit id="76efb5ddfe9997620fd07ade2a0e0cee44bb8c62" translate="yes" xml:space="preserve">
          <source>Generator.permutation()</source>
          <target state="translated">Generator.permutation()</target>
        </trans-unit>
        <trans-unit id="7a00012743deaf56311a785e2b3c42ad040930cb" translate="yes" xml:space="preserve">
          <source>Generator.poisson()</source>
          <target state="translated">Generator.poisson()</target>
        </trans-unit>
        <trans-unit id="9ebe8ebc29357762dc172bd7a50a6d2bbec0bbc0" translate="yes" xml:space="preserve">
          <source>Generator.power()</source>
          <target state="translated">Generator.power()</target>
        </trans-unit>
        <trans-unit id="760d539be436a9fd5786ef5406b94bdadd320519" translate="yes" xml:space="preserve">
          <source>Generator.random()</source>
          <target state="translated">Generator.random()</target>
        </trans-unit>
        <trans-unit id="4fe55f2eb5b58a57536abac4e6392ebd311bfe6e" translate="yes" xml:space="preserve">
          <source>Generator.rayleigh()</source>
          <target state="translated">Generator.rayleigh()</target>
        </trans-unit>
        <trans-unit id="3fff1d63fa4122d609dcfb229ec0499ef08a14a7" translate="yes" xml:space="preserve">
          <source>Generator.shuffle()</source>
          <target state="translated">Generator.shuffle()</target>
        </trans-unit>
        <trans-unit id="9b1634a618bfbc7c72035711945372ce07c3fe19" translate="yes" xml:space="preserve">
          <source>Generator.standard_cauchy()</source>
          <target state="translated">Generator.standard_cauchy()</target>
        </trans-unit>
        <trans-unit id="34db4ce80b61d7d21ff61b89aa2d2d63aa910f5c" translate="yes" xml:space="preserve">
          <source>Generator.standard_exponential()</source>
          <target state="translated">Generator.standard_exponential()</target>
        </trans-unit>
        <trans-unit id="34031ad3432250f012a4d89407bba35b84a16c3c" translate="yes" xml:space="preserve">
          <source>Generator.standard_gamma()</source>
          <target state="translated">Generator.standard_gamma()</target>
        </trans-unit>
        <trans-unit id="87dab3cf1af1d204bcf4e1ac664f4ea0ea2557c9" translate="yes" xml:space="preserve">
          <source>Generator.standard_normal()</source>
          <target state="translated">Generator.standard_normal()</target>
        </trans-unit>
        <trans-unit id="f906f6a0afddbf8cdbe07f5b8f0720c2656e3a0d" translate="yes" xml:space="preserve">
          <source>Generator.standard_t()</source>
          <target state="translated">Generator.standard_t()</target>
        </trans-unit>
        <trans-unit id="b0b2b3ce2c0360b1a89e482830d2d3c0cbab9581" translate="yes" xml:space="preserve">
          <source>Generator.triangular()</source>
          <target state="translated">Generator.triangular()</target>
        </trans-unit>
        <trans-unit id="ab3025f762e986dfbed9abf7722d638afcbcac65" translate="yes" xml:space="preserve">
          <source>Generator.uniform()</source>
          <target state="translated">Generator.uniform()</target>
        </trans-unit>
        <trans-unit id="41234839ae9e6c31f86b35be70f95dd2edfdb45f" translate="yes" xml:space="preserve">
          <source>Generator.vonmises()</source>
          <target state="translated">Generator.vonmises()</target>
        </trans-unit>
        <trans-unit id="524f7ff03bcd2538def6c2fcd08d18e053cd0a0d" translate="yes" xml:space="preserve">
          <source>Generator.wald()</source>
          <target state="translated">Generator.wald()</target>
        </trans-unit>
        <trans-unit id="e7d43ca17b95d21950576674e14eac05300d6600" translate="yes" xml:space="preserve">
          <source>Generator.weibull()</source>
          <target state="translated">Generator.weibull()</target>
        </trans-unit>
        <trans-unit id="425fdb323ea262485eeead85528e77951596ac23" translate="yes" xml:space="preserve">
          <source>Generator.zipf()</source>
          <target state="translated">Generator.zipf()</target>
        </trans-unit>
        <trans-unit id="df5e162e441d1aa68e920c4da50498c7a00cc1ca" translate="yes" xml:space="preserve">
          <source>Generators: Objects that transform sequences of random bits from a BitGenerator into sequences of numbers that follow a specific probability distribution (such as uniform, Normal or Binomial) within a specified interval.</source>
          <target state="translated">Генераторы:Объекты,преобразующие последовательности случайных битов из BitGenerator в последовательности чисел,которые следуют за определенным распределением вероятностей (например,равномерным,нормальным или биномиальным)в пределах заданного интервала.</target>
        </trans-unit>
        <trans-unit id="fcca6d928c0647f440353ba62ca89c9a77b6389a" translate="yes" xml:space="preserve">
          <source>Generic Python-exception-derived object raised by linalg functions.</source>
          <target state="translated">Общий объект,полученный на питоне,поднятый функциями линаляга.</target>
        </trans-unit>
        <trans-unit id="37f5365cdbef14515226dcd384583192170cc525" translate="yes" xml:space="preserve">
          <source>Generic functions</source>
          <target state="translated">Общие функции</target>
        </trans-unit>
        <trans-unit id="36687e3d4c6e89be61413141c9001bd1269ea61f" translate="yes" xml:space="preserve">
          <source>Generic types</source>
          <target state="translated">Общие типы</target>
        </trans-unit>
        <trans-unit id="4725fc543850e19ff2039cda197dd7e9e18cc3b7" translate="yes" xml:space="preserve">
          <source>Get a Python object of a builtin type from the ndarray, &lt;em&gt;arr&lt;/em&gt;, at the location pointed to by itemptr. Return &lt;code&gt;NULL&lt;/code&gt; on failure.</source>
          <target state="translated">Получите объект Python встроенного типа из массива ndarray, &lt;em&gt;arr&lt;/em&gt; , в месте, на которое указывает itemptr. В случае неудачи вернуть &lt;code&gt;NULL&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="89bba80c206cb8084a11e65d5dc5c897b6a8a686" translate="yes" xml:space="preserve">
          <source>Get a copy of the iterator as a 1-D array.</source>
          <target state="translated">Получить копию итератора в виде одномерного массива.</target>
        </trans-unit>
        <trans-unit id="f7e3ab2dfabd54e64b9ac5580bc305e9c24165dc" translate="yes" xml:space="preserve">
          <source>Get a copy of the iterator in its current state.</source>
          <target state="translated">Получите копию итератора в его текущем состоянии.</target>
        </trans-unit>
        <trans-unit id="87b8e4a6c47eabed3fcd4c264f91d248484dbd8e" translate="yes" xml:space="preserve">
          <source>Get floating point status. A pointer to a local variable is passed in to prevent aggressive compiler optimizations from reodering this function call relative to the code setting the status, which could lead to incorrect results.</source>
          <target state="translated">Получить статус с плавающей точкой.Передается указатель на локальную переменную,чтобы предотвратить переопределение агрессивных оптимизаций компилятора при вызове этой функции относительно кода,устанавливающего статус,что может привести к некорректным результатам.</target>
        </trans-unit>
        <trans-unit id="b27b9509ff4121a0e1b9f0986d9920de57d819f0" translate="yes" xml:space="preserve">
          <source>Get floating point status. Returns a bitmask with following possible flags:</source>
          <target state="translated">Получить статус с плавающей точкой.Возвращает битовую маску со следующими возможными флагами:</target>
        </trans-unit>
        <trans-unit id="ddfceaf39034459b039832aa5e0f88a5294c648e" translate="yes" xml:space="preserve">
          <source>Get help information for a function, class, or module.</source>
          <target state="translated">Получить справочную информацию для функции,класса или модуля.</target>
        </trans-unit>
        <trans-unit id="ec25cf47cdd55b9b521bbdadbef69d3ea1d8e5a4" translate="yes" xml:space="preserve">
          <source>Get information about the step size of a date or time type.</source>
          <target state="translated">Получить информацию о размере шага типа дата или время.</target>
        </trans-unit>
        <trans-unit id="693a41351204b667429ed1f8f87172706e8b4a91" translate="yes" xml:space="preserve">
          <source>Get or set the PRNG state</source>
          <target state="translated">Получить или установить PRNG состояние</target>
        </trans-unit>
        <trans-unit id="09c0240016b842d9be6c9625e5a572e040565a6a" translate="yes" xml:space="preserve">
          <source>Get or set the mask of the array if it has no named fields.</source>
          <target state="translated">Получить или установить маску массива,если у него нет именованных полей.</target>
        </trans-unit>
        <trans-unit id="0a74bcddcc3142595e265c6f91c54ba0941f6e3f" translate="yes" xml:space="preserve">
          <source>Get or set the mask of the array if it has no named fields. For structured arrays, returns a ndarray of booleans where entries are &lt;code&gt;True&lt;/code&gt; if &lt;strong&gt;all&lt;/strong&gt; the fields are masked, &lt;code&gt;False&lt;/code&gt; otherwise:</source>
          <target state="translated">Получить или установить маску массива, если в нем нет именованных полей. Для структурированных массивов возвращает ndarray логических значений, где записи имеют значение &lt;code&gt;True&lt;/code&gt; , если &lt;strong&gt;все&lt;/strong&gt; поля замаскированы, и &lt;code&gt;False&lt;/code&gt; в противном случае:</target>
        </trans-unit>
        <trans-unit id="c0ab6b2bea51cfebc1977ab8830dcd90e5d8f56d" translate="yes" xml:space="preserve">
          <source>Get resources information.</source>
          <target state="translated">Получить информацию о ресурсах.</target>
        </trans-unit>
        <trans-unit id="7d41ad59188f890aeb1ed8209e30d553a33f1536" translate="yes" xml:space="preserve">
          <source>Get the Python values used for ufunc processing from the thread-local storage area unless the defaults have been set in which case the name lookup is bypassed. The name is placed as a string in the first element of &lt;em&gt;*errobj&lt;/em&gt;. The second element is the looked-up function to call on error callback. The value of the looked-up buffer-size to use is passed into &lt;em&gt;bufsize&lt;/em&gt;, and the value of the error mask is placed into &lt;em&gt;errmask&lt;/em&gt;.</source>
          <target state="translated">Получите значения Python, используемые для обработки ufunc, из области локального хранилища потока, если не были установлены значения по умолчанию, и в этом случае поиск имени игнорируется. Имя помещается в виде строки в первый элемент &lt;em&gt;* errobj&lt;/em&gt; . Второй элемент - это функция поиска для вызова обратного вызова ошибки. Значение &lt;em&gt;искомого&lt;/em&gt; размера буфера для использования передается в &lt;em&gt;bufsize&lt;/em&gt; , а значение маски ошибок помещается в &lt;em&gt;errmask&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="b42cef4d77cbf66bab7c534b082e6107163dee92" translate="yes" xml:space="preserve">
          <source>Get the current way of handling floating-point errors.</source>
          <target state="translated">Получите текущий способ обработки ошибок с плавающей запятой.</target>
        </trans-unit>
        <trans-unit id="695f3e243afdf261b45538304791ad040f8d34f0" translate="yes" xml:space="preserve">
          <source>Get the number of dimensions of an array</source>
          <target state="translated">Получить количество размеров массива</target>
        </trans-unit>
        <trans-unit id="47b4332f0fd288d9a8660cb9b90eb2d70399cb30" translate="yes" xml:space="preserve">
          <source>Getitem/setitem/copyswap function: Similar to ufuncs, these functions generally have two code paths. If &lt;code&gt;ALIGNED&lt;/code&gt; is False they will use a code path that buffers the arguments so they are true-aligned.</source>
          <target state="translated">Функция Getitem / setitem / copyswap: Подобно ufuncs, эти функции обычно имеют два пути кода. Если &lt;code&gt;ALIGNED&lt;/code&gt; имеет значение False, они будут использовать путь кода, который буферизует аргументы, чтобы они были выровнены по истине.</target>
        </trans-unit>
        <trans-unit id="be9042cc4b8d1c2a38a88090c5bbf827e249e726" translate="yes" xml:space="preserve">
          <source>Gets an array of strides which are fixed, or will not change during the entire iteration. For strides that may change, the value NPY_MAX_INTP is placed in the stride.</source>
          <target state="translated">Получает массив шага,который фиксирован или не будет изменяться в течение всей итерации.Для шага,который может измениться,в шаге устанавливается значение NPY_MAX_INTP.</target>
        </trans-unit>
        <trans-unit id="30fc1fed71b9648bc39ebe85c632c9c96d68765c" translate="yes" xml:space="preserve">
          <source>Gets the &lt;code&gt;iterindex&lt;/code&gt; of the iterator, which is an index matching the iteration order of the iterator.</source>
          <target state="translated">Получает &lt;code&gt;iterindex&lt;/code&gt; итератора, который является индексом, соответствующим порядку итерации итератора.</target>
        </trans-unit>
        <trans-unit id="c9217aeddd13f7d6ea905e46252fcb27732c6211" translate="yes" xml:space="preserve">
          <source>Gets the &lt;code&gt;iterindex&lt;/code&gt; sub-range that is being iterated. If &lt;a href=&quot;#c.NPY_ITER_RANGED&quot;&gt;&lt;code&gt;NPY_ITER_RANGED&lt;/code&gt;&lt;/a&gt; was not specified, this always returns the range &lt;code&gt;[0, NpyIter_IterSize(iter))&lt;/code&gt;.</source>
          <target state="translated">Получает &lt;code&gt;iterindex&lt;/code&gt; поддиапазон iterindex . Если &lt;a href=&quot;#c.NPY_ITER_RANGED&quot;&gt; &lt;code&gt;NPY_ITER_RANGED&lt;/code&gt; &lt;/a&gt; не указан, это всегда возвращает диапазон &lt;code&gt;[0, NpyIter_IterSize(iter))&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b29099a868ef51a061ab01f34d141a4b26e68b87" translate="yes" xml:space="preserve">
          <source>Gets the array of data pointers directly into the arrays (never into the buffers), corresponding to iteration index 0.</source>
          <target state="translated">Получает массив указателей данных непосредственно в массивы (никогда в буферы),соответствующий итерационному индексу 0.</target>
        </trans-unit>
        <trans-unit id="ad1880ff271cb91c83bb908e9bec8d5e682e13f9" translate="yes" xml:space="preserve">
          <source>Gets the array of strides for the specified axis. Requires that the iterator be tracking a multi-index, and that buffering not be enabled.</source>
          <target state="translated">Получает массив шага для указанной оси.Требует,чтобы итератор отслеживал мультииндекс,и чтобы буферизация не была включена.</target>
        </trans-unit>
        <trans-unit id="cbcc80db035da4f014fe2b35abfcfb7fdf954c8c" translate="yes" xml:space="preserve">
          <source>Gets the bit generator instance used by the generator</source>
          <target state="translated">Получает экземпляр генератора битов,используемый генератором.</target>
        </trans-unit>
        <trans-unit id="1a46b1f79c63a304cb32357fb767b2f9f13f63b7" translate="yes" xml:space="preserve">
          <source>Getting extra Fortran 77 compiler options from source</source>
          <target state="translated">Получение дополнительных опций компилятора Fortran 77 из исходных текстов</target>
        </trans-unit>
        <trans-unit id="fed2b47c2eb6fcb9566d8e5b338ef20c663258ac" translate="yes" xml:space="preserve">
          <source>Give a new shape to an array without changing its data.</source>
          <target state="translated">Придание новой формы массиву без изменения его данных.</target>
        </trans-unit>
        <trans-unit id="a577ea656c2f3aa2b8af6ec81a5f57008704a3bb" translate="yes" xml:space="preserve">
          <source>Give a new shape to the array without changing its data.</source>
          <target state="translated">Придание новой формы массиву без изменения его данных.</target>
        </trans-unit>
        <trans-unit id="5633a94c306e1317df951f106e430c35db17233f" translate="yes" xml:space="preserve">
          <source>Given a sequence of a polynomial&amp;rsquo;s zeros:</source>
          <target state="translated">Дана последовательность нулей полинома:</target>
        </trans-unit>
        <trans-unit id="4cc543f62ec648afbd60f8c46e36515054ff8b40" translate="yes" xml:space="preserve">
          <source>Given a sequence of arrays (&lt;em&gt;sort_keys&lt;/em&gt;) of the same shape, return an array of indices (similar to &lt;a href=&quot;#c.PyArray_ArgSort&quot;&gt;&lt;code&gt;PyArray_ArgSort&lt;/code&gt;&lt;/a&gt; (&amp;hellip;)) that would sort the arrays lexicographically. A lexicographic sort specifies that when two keys are found to be equal, the order is based on comparison of subsequent keys. A merge sort (which leaves equal entries unmoved) is required to be defined for the types. The sort is accomplished by sorting the indices first using the first &lt;em&gt;sort_key&lt;/em&gt; and then using the second &lt;em&gt;sort_key&lt;/em&gt; and so forth. This is equivalent to the lexsort(&lt;em&gt;sort_keys&lt;/em&gt;, &lt;em&gt;axis&lt;/em&gt;) Python command. Because of the way the merge-sort works, be sure to understand the order the &lt;em&gt;sort_keys&lt;/em&gt; must be in (reversed from the order you would use when comparing two elements).</source>
          <target state="translated">Учитывая последовательность массивов ( &lt;em&gt;sort_keys&lt;/em&gt; ) одинаковой формы, верните массив индексов (аналогичный &lt;a href=&quot;#c.PyArray_ArgSort&quot;&gt; &lt;code&gt;PyArray_ArgSort&lt;/code&gt; &lt;/a&gt; (&amp;hellip;)), который будет лексикографически сортировать массивы. Лексикографическая сортировка указывает, что, когда два ключа оказываются равными, порядок основан на сравнении последующих ключей. Для типов требуется определить сортировку слиянием (при которой одинаковые записи остаются неизменными). Сортировка выполняется путем сортировки индексов сначала с помощью первого &lt;em&gt;ключа sort_key,&lt;/em&gt; затем с помощью второго &lt;em&gt;ключа sort_key&lt;/em&gt; и так далее. Это эквивалентно команде Python lexsort ( &lt;em&gt;sort_keys&lt;/em&gt; , &lt;em&gt;axis&lt;/em&gt; ). Из-за того, как работает сортировка слиянием, убедитесь, что вы понимаете порядок &lt;em&gt;sort_keys&lt;/em&gt; должны быть в порядке (обратном порядке, который вы использовали бы при сравнении двух элементов).</target>
        </trans-unit>
        <trans-unit id="675ac4930884c9f7a3554ad9fd66c39834a06013" translate="yes" xml:space="preserve">
          <source>Given a set of conditions and corresponding functions, evaluate each function on the input data wherever its condition is true.</source>
          <target state="translated">Учитывая набор условий и соответствующих функций,оцените каждую функцию на входных данных,где бы ни было ее состояние.</target>
        </trans-unit>
        <trans-unit id="9104557d433ccbecbd40d5b471167b269afd4924" translate="yes" xml:space="preserve">
          <source>Given a shape of, for example, &lt;code&gt;(m,n,k)&lt;/code&gt;, &lt;code&gt;m*n*k&lt;/code&gt; samples are generated, and packed in an &lt;code&gt;m&lt;/code&gt;-by-&lt;code&gt;n&lt;/code&gt;-by-&lt;code&gt;k&lt;/code&gt; arrangement. Because each sample is &lt;code&gt;N&lt;/code&gt;-dimensional, the output shape is &lt;code&gt;(m,n,k,N)&lt;/code&gt;. If no shape is specified, a single (&lt;code&gt;N&lt;/code&gt;-D) sample is returned.</source>
          <target state="translated">При заданной форме, например, &lt;code&gt;(m,n,k)&lt;/code&gt; , создается &lt;code&gt;m*n*k&lt;/code&gt; выборок и упаковывается в компоновку &lt;code&gt;m&lt;/code&gt; &amp;times; &lt;code&gt;n&lt;/code&gt; &amp;times; &lt;code&gt;k&lt;/code&gt; . Поскольку каждый образец является &lt;code&gt;N&lt;/code&gt; - мерным, форма вывода будет &lt;code&gt;(m,n,k,N)&lt;/code&gt; . Если форма не указана, возвращается один ( &lt;code&gt;N&lt;/code&gt; -D) образец.</target>
        </trans-unit>
        <trans-unit id="cd43bd0b568c4a20eb55e09b56aec26e4bcf57e8" translate="yes" xml:space="preserve">
          <source>Given a square array object:</source>
          <target state="translated">Учитывая объект квадратного массива:</target>
        </trans-unit>
        <trans-unit id="c727e55b5284efd4b0f949a20f79f07a731a7def" translate="yes" xml:space="preserve">
          <source>Given a square matrix &lt;code&gt;a&lt;/code&gt;, return the matrix &lt;code&gt;ainv&lt;/code&gt; satisfying &lt;code&gt;dot(a, ainv) = dot(ainv, a) = eye(a.shape[0])&lt;/code&gt;.</source>
          <target state="translated">Для квадратной матрицы &lt;code&gt;a&lt;/code&gt; верните матрицу &lt;code&gt;ainv&lt;/code&gt; , удовлетворяющую условию &lt;code&gt;dot(a, ainv) = dot(ainv, a) = eye(a.shape[0])&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="fc3ba91f03af5d3e0b135a4d459d0b8c153beab2" translate="yes" xml:space="preserve">
          <source>Given a vector &lt;code&gt;V&lt;/code&gt; of length &lt;code&gt;N&lt;/code&gt;, the &lt;code&gt;q&lt;/code&gt;-th percentile of &lt;code&gt;V&lt;/code&gt; is the value &lt;code&gt;q/100&lt;/code&gt; of the way from the minimum to the maximum in a sorted copy of &lt;code&gt;V&lt;/code&gt;. The values and distances of the two nearest neighbors as well as the &lt;code&gt;interpolation&lt;/code&gt; parameter will determine the percentile if the normalized ranking does not match the location of &lt;code&gt;q&lt;/code&gt; exactly. This function is the same as the median if &lt;code&gt;q=50&lt;/code&gt;, the same as the minimum if &lt;code&gt;q=0&lt;/code&gt; and the same as the maximum if &lt;code&gt;q=100&lt;/code&gt;.</source>
          <target state="translated">Принимая во внимание вектора &lt;code&gt;V&lt;/code&gt; длины &lt;code&gt;N&lt;/code&gt; , тем &lt;code&gt;q&lt;/code&gt; -го процентиль &lt;code&gt;V&lt;/code&gt; имеет значение &lt;code&gt;q/100&lt;/code&gt; в стороне от минимума до максимума в отсортированной копии &lt;code&gt;V&lt;/code&gt; . Значения и расстояния двух ближайших соседей, а также параметр &lt;code&gt;interpolation&lt;/code&gt; будут определять процентиль, если нормализованное ранжирование не соответствует точно местоположению &lt;code&gt;q&lt;/code&gt; . Эта функция такая же, как медиана, если &lt;code&gt;q=50&lt;/code&gt; , такая же, как минимум, если &lt;code&gt;q=0&lt;/code&gt; , и такая же как максимум, если &lt;code&gt;q=100&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1966cedf9ce61fd3a211e32f4abbb9573112f3e8" translate="yes" xml:space="preserve">
          <source>Given a vector &lt;code&gt;V&lt;/code&gt; of length &lt;code&gt;N&lt;/code&gt;, the median of &lt;code&gt;V&lt;/code&gt; is the middle value of a sorted copy of &lt;code&gt;V&lt;/code&gt;, &lt;code&gt;V_sorted&lt;/code&gt; - i e., &lt;code&gt;V_sorted[(N-1)/2]&lt;/code&gt;, when &lt;code&gt;N&lt;/code&gt; is odd, and the average of the two middle values of &lt;code&gt;V_sorted&lt;/code&gt; when &lt;code&gt;N&lt;/code&gt; is even.</source>
          <target state="translated">Для вектора &lt;code&gt;V&lt;/code&gt; длины &lt;code&gt;N&lt;/code&gt; , медиана &lt;code&gt;V&lt;/code&gt; является средним значением отсортированной копии &lt;code&gt;V&lt;/code&gt; , &lt;code&gt;V_sorted&lt;/code&gt; - т.е., &lt;code&gt;V_sorted[(N-1)/2]&lt;/code&gt; , когда &lt;code&gt;N&lt;/code&gt; нечетно, и среднее значение два средних значения &lt;code&gt;V_sorted&lt;/code&gt; , когда &lt;code&gt;N&lt;/code&gt; четно.</target>
        </trans-unit>
        <trans-unit id="a11a60c1be0b2a1a4251da19f3ebb410f0917d80" translate="yes" xml:space="preserve">
          <source>Given a vector &lt;code&gt;V&lt;/code&gt; of length &lt;code&gt;N&lt;/code&gt;, the median of &lt;code&gt;V&lt;/code&gt; is the middle value of a sorted copy of &lt;code&gt;V&lt;/code&gt;, &lt;code&gt;V_sorted&lt;/code&gt; - i.e., &lt;code&gt;V_sorted[(N-1)/2]&lt;/code&gt;, when &lt;code&gt;N&lt;/code&gt; is odd and the average of the two middle values of &lt;code&gt;V_sorted&lt;/code&gt; when &lt;code&gt;N&lt;/code&gt; is even.</source>
          <target state="translated">Учитывая вектор &lt;code&gt;V&lt;/code&gt; длины &lt;code&gt;N&lt;/code&gt; , медиана &lt;code&gt;V&lt;/code&gt; является средним значением отсортированной копии &lt;code&gt;V&lt;/code&gt; , &lt;code&gt;V_sorted&lt;/code&gt; , то есть &lt;code&gt;V_sorted[(N-1)/2]&lt;/code&gt; , когда &lt;code&gt;N&lt;/code&gt; нечетное и среднее из двух средних значений. из &lt;code&gt;V_sorted&lt;/code&gt; , когда &lt;code&gt;N&lt;/code&gt; является четным.</target>
        </trans-unit>
        <trans-unit id="d76c2715df60bdab25092c54104462a6d39f23bb" translate="yes" xml:space="preserve">
          <source>Given a vector &lt;code&gt;V&lt;/code&gt; of length &lt;code&gt;N&lt;/code&gt;, the q-th percentile of &lt;code&gt;V&lt;/code&gt; is the value &lt;code&gt;q/100&lt;/code&gt; of the way from the minimum to the maximum in a sorted copy of &lt;code&gt;V&lt;/code&gt;. The values and distances of the two nearest neighbors as well as the &lt;code&gt;interpolation&lt;/code&gt; parameter will determine the percentile if the normalized ranking does not match the location of &lt;code&gt;q&lt;/code&gt; exactly. This function is the same as the median if &lt;code&gt;q=50&lt;/code&gt;, the same as the minimum if &lt;code&gt;q=0&lt;/code&gt; and the same as the maximum if &lt;code&gt;q=100&lt;/code&gt;.</source>
          <target state="translated">Принимая во внимание вектора &lt;code&gt;V&lt;/code&gt; длинами &lt;code&gt;N&lt;/code&gt; , Q-й процентиль &lt;code&gt;V&lt;/code&gt; является значение &lt;code&gt;q/100&lt;/code&gt; в стороне от минимума до максимума в отсортированной копии &lt;code&gt;V&lt;/code&gt; . Значения и расстояния двух ближайших соседей, а также параметр &lt;code&gt;interpolation&lt;/code&gt; будут определять процентиль, если нормализованное ранжирование не соответствует точно местоположению &lt;code&gt;q&lt;/code&gt; . Эта функция такая же, как медиана, если &lt;code&gt;q=50&lt;/code&gt; , такая же, как минимум, если &lt;code&gt;q=0&lt;/code&gt; , и такая же как максимум, если &lt;code&gt;q=100&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="dfd59ffc41fbed91404c5101ddfa184c5392006b" translate="yes" xml:space="preserve">
          <source>Given a vector &lt;code&gt;V&lt;/code&gt; of length &lt;code&gt;N&lt;/code&gt;, the q-th quantile of &lt;code&gt;V&lt;/code&gt; is the value &lt;code&gt;q&lt;/code&gt; of the way from the minimum to the maximum in a sorted copy of &lt;code&gt;V&lt;/code&gt;. The values and distances of the two nearest neighbors as well as the &lt;code&gt;interpolation&lt;/code&gt; parameter will determine the quantile if the normalized ranking does not match the location of &lt;code&gt;q&lt;/code&gt; exactly. This function is the same as the median if &lt;code&gt;q=0.5&lt;/code&gt;, the same as the minimum if &lt;code&gt;q=0.0&lt;/code&gt; and the same as the maximum if &lt;code&gt;q=1.0&lt;/code&gt;.</source>
          <target state="translated">Принимая во внимание вектора &lt;code&gt;V&lt;/code&gt; длинами &lt;code&gt;N&lt;/code&gt; , Q-й квантиль &lt;code&gt;V&lt;/code&gt; является значение &lt;code&gt;q&lt;/code&gt; пути от минимума до максимума в отсортированной копии &lt;code&gt;V&lt;/code&gt; . Значения и расстояния двух ближайших соседей, а также параметр &lt;code&gt;interpolation&lt;/code&gt; будут определять квантиль, если нормализованное ранжирование не соответствует точно местоположению &lt;code&gt;q&lt;/code&gt; . Эта функция такая же, как медиана, если &lt;code&gt;q=0.5&lt;/code&gt; , такая же, как минимум, если &lt;code&gt;q=0.0&lt;/code&gt; и такая же как максимум, если &lt;code&gt;q=1.0&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="97afe1ab394be8a96329790e96c805504acf970b" translate="yes" xml:space="preserve">
          <source>Given a vector &lt;code&gt;V&lt;/code&gt; with &lt;code&gt;N&lt;/code&gt; non masked values, the median of &lt;code&gt;V&lt;/code&gt; is the middle value of a sorted copy of &lt;code&gt;V&lt;/code&gt; (&lt;code&gt;Vs&lt;/code&gt;) - i.e. &lt;code&gt;Vs[(N-1)/2]&lt;/code&gt;, when &lt;code&gt;N&lt;/code&gt; is odd, or &lt;code&gt;{Vs[N/2 - 1] + Vs[N/2]}/2&lt;/code&gt; when &lt;code&gt;N&lt;/code&gt; is even.</source>
          <target state="translated">Для вектора &lt;code&gt;V&lt;/code&gt; с &lt;code&gt;N&lt;/code&gt; немаскированными значениями медиана &lt;code&gt;V&lt;/code&gt; является средним значением отсортированной копии &lt;code&gt;V&lt;/code&gt; ( &lt;code&gt;Vs&lt;/code&gt; ), то есть &lt;code&gt;Vs[(N-1)/2]&lt;/code&gt; , когда &lt;code&gt;N&lt;/code&gt; нечетно, или &lt;code&gt;{Vs[N/2 - 1] + Vs[N/2]}/2&lt;/code&gt; когда &lt;code&gt;N&lt;/code&gt; четно.</target>
        </trans-unit>
        <trans-unit id="2f958084a15b1cea997fb4f3882497b30e2d92da" translate="yes" xml:space="preserve">
          <source>Given a window length &lt;code&gt;n&lt;/code&gt; and a sample spacing &lt;code&gt;d&lt;/code&gt;:</source>
          <target state="translated">Учитывая длину окна &lt;code&gt;n&lt;/code&gt; и интервал выборки &lt;code&gt;d&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="3cf50be3014d334ce381b3182c6e22be99505ba7" translate="yes" xml:space="preserve">
          <source>Given an &amp;ldquo;index&amp;rdquo; array (&lt;code&gt;a&lt;/code&gt;) of integers and a sequence of &lt;code&gt;n&lt;/code&gt; arrays (&lt;code&gt;choices&lt;/code&gt;), &lt;code&gt;a&lt;/code&gt; and each choice array are first broadcast, as necessary, to arrays of a common shape; calling these &lt;em&gt;Ba&lt;/em&gt; and &lt;em&gt;Bchoices[i], i = 0,&amp;hellip;,n-1&lt;/em&gt; we have that, necessarily, &lt;code&gt;Ba.shape == Bchoices[i].shape&lt;/code&gt; for each &lt;code&gt;i&lt;/code&gt;. Then, a new array with shape &lt;code&gt;Ba.shape&lt;/code&gt; is created as follows:</source>
          <target state="translated">Дан &amp;laquo;индексный&amp;raquo; массив ( &lt;code&gt;a&lt;/code&gt; ) целых чисел и последовательность из &lt;code&gt;n&lt;/code&gt; массивов ( &lt;code&gt;choices&lt;/code&gt; ), &lt;code&gt;a&lt;/code&gt; и каждый массив выбора сначала транслируются, если необходимо, в массивы общей формы; назвав эти &lt;em&gt;Ba&lt;/em&gt; и &lt;em&gt;Bchoices [i], i = 0,&amp;hellip;, n-1,&lt;/em&gt; мы обязательно получим, что &lt;code&gt;Ba.shape == Bchoices[i].shape&lt;/code&gt; для каждого &lt;code&gt;i&lt;/code&gt; . Затем создается новый массив с формой &lt;code&gt;Ba.shape&lt;/code&gt; следующим образом:</target>
        </trans-unit>
        <trans-unit id="182d11d96136738a2da66eeca81246c173e18b8d" translate="yes" xml:space="preserve">
          <source>Given an array of integers and a set of n choice arrays, this method will create a new array that merges each of the choice arrays. Where a value in &lt;code&gt;a&lt;/code&gt; is i, the new array will have the value that choices[i] contains in the same place.</source>
          <target state="translated">Учитывая массив целых чисел и набор из n массивов выбора, этот метод создаст новый массив, который объединяет каждый из массивов выбора. Если значение в &lt;code&gt;a&lt;/code&gt; равно i, новый массив будет иметь значение, которое choices [i] содержит в том же месте.</target>
        </trans-unit>
        <trans-unit id="e37e450d620d60b14cee7269755ab57ba8f06da4" translate="yes" xml:space="preserve">
          <source>Given an interval, values outside the interval are clipped to the interval edges. For example, if an interval of &lt;code&gt;[0, 1]&lt;/code&gt; is specified, values smaller than 0 become 0, and values larger than 1 become 1.</source>
          <target state="translated">При заданном интервале значения за пределами интервала обрезаются по краям интервала. Например, если указан интервал &lt;code&gt;[0, 1]&lt;/code&gt; , значения меньше 0 становятся 0, а значения больше 1 становятся 1.</target>
        </trans-unit>
        <trans-unit id="38e44e10395d6cbc3f11e11b2660a79eed5fd62a" translate="yes" xml:space="preserve">
          <source>Given multiple sorting keys, which can be interpreted as columns in a spreadsheet, lexsort returns an array of integer indices that describes the sort order by multiple columns. The last key in the sequence is used for the primary sort order, the second-to-last key for the secondary sort order, and so on. The keys argument must be a sequence of objects that can be converted to arrays of the same shape. If a 2D array is provided for the keys argument, it&amp;rsquo;s rows are interpreted as the sorting keys and sorting is according to the last row, second last row etc.</source>
          <target state="translated">При наличии нескольких ключей сортировки, которые можно интерпретировать как столбцы в электронной таблице, lexsort возвращает массив целочисленных индексов, описывающих порядок сортировки по нескольким столбцам. Последний ключ в последовательности используется для первичного порядка сортировки, предпоследний ключ для вторичного порядка сортировки и т. Д. Аргумент keys должен быть последовательностью объектов, которые можно преобразовать в массивы той же формы. Если для аргумента ключей предоставляется двухмерный массив, его строки интерпретируются как ключи сортировки, а сортировка выполняется в соответствии с последней строкой, второй последней строкой и т. Д.</target>
        </trans-unit>
        <trans-unit id="67d67e5173e989786e884148ab1ee5c292352200" translate="yes" xml:space="preserve">
          <source>Given the &amp;ldquo;legs&amp;rdquo; of a right triangle, return its hypotenuse.</source>
          <target state="translated">Учитывая &amp;laquo;катеты&amp;raquo; прямоугольного треугольника, верните его гипотенузу.</target>
        </trans-unit>
        <trans-unit id="fd7a5a167593ffa963306f804bdee09ec39e8fd9" translate="yes" xml:space="preserve">
          <source>Given the shape of an array, an &lt;a href=&quot;#numpy.ndindex&quot;&gt;&lt;code&gt;ndindex&lt;/code&gt;&lt;/a&gt; instance iterates over the N-dimensional index of the array. At each iteration a tuple of indices is returned, the last dimension is iterated over first.</source>
          <target state="translated">Учитывая форму массива, экземпляр &lt;a href=&quot;#numpy.ndindex&quot;&gt; &lt;code&gt;ndindex&lt;/code&gt; &lt;/a&gt; выполняет итерацию по N-мерному индексу массива. На каждой итерации возвращается кортеж индексов, последнее измерение повторяется по первому.</target>
        </trans-unit>
        <trans-unit id="6d84cece4ac6198159f79505d6fa6346cdc3c584" translate="yes" xml:space="preserve">
          <source>Given two &lt;em&gt;n&lt;/em&gt; -length arrays of integers, &lt;em&gt;l1&lt;/em&gt;, and &lt;em&gt;l2&lt;/em&gt;, return 1 if the lists are identical; otherwise, return 0.</source>
          <target state="translated">Для двух массивов целых чисел длиной &lt;em&gt;n&lt;/em&gt; , &lt;em&gt;l1&lt;/em&gt; и &lt;em&gt;l2&lt;/em&gt; , вернуть 1, если списки идентичны; в противном случае верните 0.</target>
        </trans-unit>
        <trans-unit id="b4d93ad7919330e367279622118fac9cd99eb66a" translate="yes" xml:space="preserve">
          <source>Given two array_like objects, check that the shape is equal and all elements of the first object are strictly smaller than those of the second object. An exception is raised at shape mismatch or incorrectly ordered values. Shape mismatch does not raise if an object has zero dimension. In contrast to the standard usage in numpy, NaNs are compared, no assertion is raised if both objects have NaNs in the same positions.</source>
          <target state="translated">Учитывая два объекта array_like,проверьте,что форма одинакова и все элементы первого объекта строго меньше элементов второго объекта.Исключение поднимается при несоответствии формы или неправильно упорядоченных значениях.Несоответствие формы не возникает,если объект имеет нулевую размерность.В отличие от стандартного использования в numpy,NaNs сравниваются,утверждение не поднимается,если оба объекта имеют NaNs в одинаковых позициях.</target>
        </trans-unit>
        <trans-unit id="90fdf131a8e234662a4baf7342d5cbfdd8815673" translate="yes" xml:space="preserve">
          <source>Given two array_like objects, check that the shape is equal and all elements of these objects are equal. An exception is raised at shape mismatch or conflicting values. In contrast to the standard usage in numpy, NaNs are compared like numbers, no assertion is raised if both objects have NaNs in the same positions.</source>
          <target state="translated">Учитывая два объекта array_like,проверьте,что форма одинакова и все элементы этих объектов равны.Исключение поднимается при несовпадении формы или конфликтующих значениях.В отличие от стандартного использования в нумерации,NaNs сравниваются как числа,утверждение не поднимается,если оба объекта имеют NaNs в одинаковых позициях.</target>
        </trans-unit>
        <trans-unit id="03c045ae56fa8df86b5ce72f657667f3cc594e54" translate="yes" xml:space="preserve">
          <source>Given two numbers, check that they are approximately equal. Approximately equal is defined as the number of significant digits that agree.</source>
          <target state="translated">Учитывая два числа,проверьте,что они примерно равны.Приблизительно равное определяется как количество значащих цифр,которые совпадают.</target>
        </trans-unit>
        <trans-unit id="d9d002c83204235df23caf3ec14f4354842036c7" translate="yes" xml:space="preserve">
          <source>Given two objects (scalars, lists, tuples, dictionaries or numpy arrays), check that all elements of these objects are equal. An exception is raised at the first conflicting values.</source>
          <target state="translated">Учитывая два объекта (скаляры,списки,кортежи,словари или нумерованные массивы),проверьте,что все элементы этих объектов равны.Исключение поднимается при первых конфликтующих значениях.</target>
        </trans-unit>
        <trans-unit id="9d61f0f6669477d0eddf6043188e0f420dad8728" translate="yes" xml:space="preserve">
          <source>Given two polynomials &lt;code&gt;a1&lt;/code&gt; and &lt;code&gt;a2&lt;/code&gt;, returns &lt;code&gt;a1 - a2&lt;/code&gt;. &lt;code&gt;a1&lt;/code&gt; and &lt;code&gt;a2&lt;/code&gt; can be either array_like sequences of the polynomials&amp;rsquo; coefficients (including coefficients equal to zero), or &lt;a href=&quot;numpy.poly1d#numpy.poly1d&quot;&gt;&lt;code&gt;poly1d&lt;/code&gt;&lt;/a&gt; objects.</source>
          <target state="translated">Для двух полиномов &lt;code&gt;a1&lt;/code&gt; и &lt;code&gt;a2&lt;/code&gt; возвращает &lt;code&gt;a1 - a2&lt;/code&gt; . &lt;code&gt;a1&lt;/code&gt; и &lt;code&gt;a2&lt;/code&gt; могут быть либо array_like последовательностями коэффициентов полиномов (включая коэффициенты, равные нулю), либо объектами &lt;a href=&quot;numpy.poly1d#numpy.poly1d&quot;&gt; &lt;code&gt;poly1d&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="8737cb46ba6778426f460962013153a76a798f04" translate="yes" xml:space="preserve">
          <source>Given two tensors, &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt;, and an array_like object containing two array_like objects, &lt;code&gt;(a_axes, b_axes)&lt;/code&gt;, sum the products of &lt;code&gt;a&lt;/code&gt;&amp;rsquo;s and &lt;code&gt;b&lt;/code&gt;&amp;rsquo;s elements (components) over the axes specified by &lt;code&gt;a_axes&lt;/code&gt; and &lt;code&gt;b_axes&lt;/code&gt;. The third argument can be a single non-negative integer_like scalar, &lt;code&gt;N&lt;/code&gt;; if it is such, then the last &lt;code&gt;N&lt;/code&gt; dimensions of &lt;code&gt;a&lt;/code&gt; and the first &lt;code&gt;N&lt;/code&gt; dimensions of &lt;code&gt;b&lt;/code&gt; are summed over.</source>
          <target state="translated">Учитывая два тензора, &lt;code&gt;a&lt;/code&gt; и &lt;code&gt;b&lt;/code&gt; , и объект array_like, содержащий два объекта array_like, &lt;code&gt;(a_axes, b_axes)&lt;/code&gt; , просуммируйте произведения элементов (компонентов) &lt;code&gt;a&lt;/code&gt; &amp;rsquo;s и &lt;code&gt;b&lt;/code&gt; &amp;rsquo; s по осям, заданным &lt;code&gt;a_axes&lt;/code&gt; и &lt;code&gt;b_axes&lt;/code&gt; . Третий аргумент может быть единственным неотрицательным целочисленным скаляром &lt;code&gt;N&lt;/code&gt; ; если это так, то суммируются последние &lt;code&gt;N&lt;/code&gt; измерений &lt;code&gt;a&lt;/code&gt; и первые &lt;code&gt;N&lt;/code&gt; измерений &lt;code&gt;b&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1bcbaa6d418fa3c95df027de6ff9d3bb5387a091" translate="yes" xml:space="preserve">
          <source>Given two vectors, &lt;code&gt;a = [a0, a1, ..., aM]&lt;/code&gt; and &lt;code&gt;b = [b0, b1, ..., bN]&lt;/code&gt;, the outer product &lt;a href=&quot;#r14e6c54b746b-1&quot; id=&quot;id1&quot;&gt;[1]&lt;/a&gt; is:</source>
          <target state="translated">Для двух векторов &lt;code&gt;a = [a0, a1, ..., aM]&lt;/code&gt; и &lt;code&gt;b = [b0, b1, ..., bN]&lt;/code&gt; внешнее произведение &lt;a href=&quot;#r14e6c54b746b-1&quot; id=&quot;id1&quot;&gt;[1]&lt;/a&gt; будет:</target>
        </trans-unit>
        <trans-unit id="3854728349ae7af32452ae7e4400a155448f9794" translate="yes" xml:space="preserve">
          <source>Given two vectors, &lt;code&gt;a = [a0, a1, ..., aM]&lt;/code&gt; and &lt;code&gt;b = [b0, b1, ..., bN]&lt;/code&gt;, the outer product &lt;a href=&quot;#r863504129d6e-1&quot; id=&quot;id1&quot;&gt;[1]&lt;/a&gt; is:</source>
          <target state="translated">Для двух векторов &lt;code&gt;a = [a0, a1, ..., aM]&lt;/code&gt; и &lt;code&gt;b = [b0, b1, ..., bN]&lt;/code&gt; внешнее произведение &lt;a href=&quot;#r863504129d6e-1&quot; id=&quot;id1&quot;&gt;[1]&lt;/a&gt; будет:</target>
        </trans-unit>
        <trans-unit id="80ea28027215a4aa397564db3b7818bf4ec592b8" translate="yes" xml:space="preserve">
          <source>Given two vectors, &lt;code&gt;a = [a0, a1, ..., aM]&lt;/code&gt; and &lt;code&gt;b = [b0, b1, ..., bN]&lt;/code&gt;, the outer product &lt;a href=&quot;#rf0d57dd5badd-1&quot; id=&quot;id1&quot;&gt;[1]&lt;/a&gt; is:</source>
          <target state="translated">Для двух векторов &lt;code&gt;a = [a0, a1, ..., aM]&lt;/code&gt; и &lt;code&gt;b = [b0, b1, ..., bN]&lt;/code&gt; внешнее произведение &lt;a href=&quot;#rf0d57dd5badd-1&quot; id=&quot;id1&quot;&gt;[1]&lt;/a&gt; будет:</target>
        </trans-unit>
        <trans-unit id="4975cd64a92e88880758085eef7772db2bdb4f4d" translate="yes" xml:space="preserve">
          <source>Given:</source>
          <target state="translated">Given:</target>
        </trans-unit>
        <trans-unit id="8020f30b057521f3745170a52c99adab4537c734" translate="yes" xml:space="preserve">
          <source>Gives a new shape to an array without changing its data.</source>
          <target state="translated">Придает новую форму массиву без изменения его данных.</target>
        </trans-unit>
        <trans-unit id="5f6df81d1943f224253f7e8824d4f6d90b5a6fd6" translate="yes" xml:space="preserve">
          <source>Glantz, Stanton A. &amp;ldquo;Primer of Biostatistics.&amp;rdquo;, McGraw-Hill, Fifth Edition, 2002.</source>
          <target state="translated">Гланц, Стэнтон А. &amp;laquo;Учебник по биостатистике&amp;raquo;, McGraw-Hill, Fifth Edition, 2002.</target>
        </trans-unit>
        <trans-unit id="99a7f06ad80d74e23ee701e64001d24ce844ca07" translate="yes" xml:space="preserve">
          <source>Gradient is calculated only along the given axis or axes The default (axis = None) is to calculate the gradient for all the axes of the input array. axis may be negative, in which case it counts from the last to the first axis.</source>
          <target state="translated">Градиент рассчитывается только вдоль данной оси или осей По умолчанию (ось=Нет)градиент рассчитывается для всех осей входного массива.Ось может быть отрицательной,в этом случае градиент отсчитывается от последней к первой оси.</target>
        </trans-unit>
        <trans-unit id="61aa58c2b09a3034acae73f52494d42574c0ca1c" translate="yes" xml:space="preserve">
          <source>Gradient is calculated using N-th order accurate differences at the boundaries. Default: 1.</source>
          <target state="translated">Градиент рассчитывается с использованием точных разностей N-го порядка на границах.По умолчанию:1.</target>
        </trans-unit>
        <trans-unit id="ea0fcf87d2287941521d49f814fee6c705ce244c" translate="yes" xml:space="preserve">
          <source>Graphical illustration of &lt;code&gt;endpoint&lt;/code&gt; parameter:</source>
          <target state="translated">Графическая иллюстрация параметра &lt;code&gt;endpoint&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="bb4d80637c2066c9e7bffa72841d8f27a47b292b" translate="yes" xml:space="preserve">
          <source>Graphical illustration:</source>
          <target state="translated">Графическая иллюстрация:</target>
        </trans-unit>
        <trans-unit id="55d14a2a20cf23aef24c6cf5ba97cf49567e1739" translate="yes" xml:space="preserve">
          <source>Greedy &lt;a href=&quot;#numpy.einsum&quot;&gt;&lt;code&gt;einsum&lt;/code&gt;&lt;/a&gt; (faster optimal path approximation): ~160ms</source>
          <target state="translated">Жадный &lt;a href=&quot;#numpy.einsum&quot;&gt; &lt;code&gt;einsum&lt;/code&gt; &lt;/a&gt; (более быстрое приближение оптимального пути): ~ 160 мс</target>
        </trans-unit>
        <trans-unit id="f6534be852374768c36e7beef74b1f4199fef68a" translate="yes" xml:space="preserve">
          <source>Grid-shaped arrays of evenly spaced numbers in N-dimensions.</source>
          <target state="translated">Сетчатые массивы равномерно распределенных чисел в N-размерах.</target>
        </trans-unit>
        <trans-unit id="d291656cb315e59b3437432c3e771768a130826d" translate="yes" xml:space="preserve">
          <source>Group 1</source>
          <target state="translated">Группа 1</target>
        </trans-unit>
        <trans-unit id="374327355d21f90b289f6f435aa2da5d797f0ae6" translate="yes" xml:space="preserve">
          <source>Group 2</source>
          <target state="translated">Группа 2</target>
        </trans-unit>
        <trans-unit id="f5ac35811e25f377d3ea665e7f41177582e5b116" translate="yes" xml:space="preserve">
          <source>Guaranteeing safe aligned access for ufuncs/setitem/casting code</source>
          <target state="translated">Гарантия безопасного выровненного доступа для кода ufuncs/setitem/casting</target>
        </trans-unit>
        <trans-unit id="141d1d74d8a6b3e7a7f1418ef539a53ce746ef34" translate="yes" xml:space="preserve">
          <source>Guidelines</source>
          <target state="translated">Guidelines</target>
        </trans-unit>
        <trans-unit id="fefaa04c360e4a9e3930a2840029cc9f56039f5f" translate="yes" xml:space="preserve">
          <source>Gumbel, E. J., &amp;ldquo;Statistics of Extremes,&amp;rdquo; New York: Columbia University Press, 1958.</source>
          <target state="translated">Гамбел, Э. Дж., &amp;laquo;Статистика крайностей&amp;raquo;, Нью-Йорк: издательство Колумбийского университета, 1958.</target>
        </trans-unit>
        <trans-unit id="c895f403bde1ed69e17f92c19862768cc5f5de8d" translate="yes" xml:space="preserve">
          <source>Half-precision functions</source>
          <target state="translated">Функции полуточной точности</target>
        </trans-unit>
        <trans-unit id="636dbc8830ea645ecf6015e1f4a6dd1accda26f4" translate="yes" xml:space="preserve">
          <source>Handled by &lt;a href=&quot;#c.NpyIter_MultiNew&quot;&gt;&lt;code&gt;NpyIter_MultiNew&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">Обрабатывается &lt;a href=&quot;#c.NpyIter_MultiNew&quot;&gt; &lt;code&gt;NpyIter_MultiNew&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="7178628eaa2183565412d3981a3508d31193d4b5" translate="yes" xml:space="preserve">
          <source>Handling complex numbers</source>
          <target state="translated">Обработка комплексных номеров</target>
        </trans-unit>
        <trans-unit id="210d84fcc7fb5c4b75800916312424c57f881c7b" translate="yes" xml:space="preserve">
          <source>Handling the &lt;code&gt;fill_value&lt;/code&gt;</source>
          <target state="translated">Обработка &lt;code&gt;fill_value&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="7e59976d95e4c0283fbcfa38c1a2f893c3bfd15d" translate="yes" xml:space="preserve">
          <source>Handling the mask</source>
          <target state="translated">Обращение с маской</target>
        </trans-unit>
        <trans-unit id="78dcc8157bbf5d134fc488651952052da7016437" translate="yes" xml:space="preserve">
          <source>Hard-coded dimensions, data-buffer-then-dimensions specification, and dimensions-then-data-buffer specification.</source>
          <target state="translated">Жестко заданные размеры,спецификация буфера данных,спецификация буфера данных.</target>
        </trans-unit>
        <trans-unit id="edfcf418a2bb124e6b8ce652d8bb7600c0be7269" translate="yes" xml:space="preserve">
          <source>Hardness of the mask</source>
          <target state="translated">Твердость маски</target>
        </trans-unit>
        <trans-unit id="a06e8ccba0be0394ad2df2eedd04a51d1a1039c5" translate="yes" xml:space="preserve">
          <source>Has no effect, do not use.</source>
          <target state="translated">Не имеет эффекта,не используется.</target>
        </trans-unit>
        <trans-unit id="4669500ffada7a9acbed3d1bf7fceec5a930f074" translate="yes" xml:space="preserve">
          <source>Has the same shape as &lt;code&gt;element&lt;/code&gt;. The values &lt;code&gt;element[isin]&lt;/code&gt; are in &lt;code&gt;test_elements&lt;/code&gt;.</source>
          <target state="translated">Имеет ту же форму, что и &lt;code&gt;element&lt;/code&gt; . Элемент values &lt;code&gt;element[isin]&lt;/code&gt; находится в &lt;code&gt;test_elements&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ce7b6e9a18227e2359efe8c98f693affe997e690" translate="yes" xml:space="preserve">
          <source>Heckert, N. A. and Filliben, James J. &amp;ldquo;NIST Handbook 148: Dataplot Reference Manual, Volume 2: Let Subcommands and Library Functions&amp;rdquo;, National Institute of Standards and Technology Handbook Series, June 2003. &lt;a href=&quot;https://www.itl.nist.gov/div898/software/dataplot/refman2/auxillar/powpdf.pdf&quot;&gt;https://www.itl.nist.gov/div898/software/dataplot/refman2/auxillar/powpdf.pdf&lt;/a&gt;</source>
          <target state="translated">Хекерт, Н. А. и Филлибен, Джеймс Дж. &amp;laquo;Справочник NIST 148: Справочное руководство по Dataplot, Том 2: Подкоманды Let и библиотечные функции&amp;raquo;, Серия справочников Национального института стандартов и технологий, июнь 2003 г. &lt;a href=&quot;https://www.itl.nist.gov/div898/software/dataplot/refman2/auxillar/powpdf.pdf&quot;&gt;https: //www.itl.nist. gov / div898 / программное обеспечение / dataplot / refman2 / auxillar / powpdf.pdf&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="334c16fc9ac63595f080f7bbcdf324a43ffd5267" translate="yes" xml:space="preserve">
          <source>Helper Functions</source>
          <target state="translated">Функции помощника</target>
        </trans-unit>
        <trans-unit id="3cffecba0fc696fb0b452757e50e8d2d6aa15660" translate="yes" xml:space="preserve">
          <source>Helper for pickle.</source>
          <target state="translated">Помощник для огурцов.</target>
        </trans-unit>
        <trans-unit id="8e0ce1fc0fa49364a15481aa8d6e74b5ad646a8c" translate="yes" xml:space="preserve">
          <source>Helper routines</source>
          <target state="translated">Порядок действий помощника</target>
        </trans-unit>
        <trans-unit id="1f2d508ec85c3c97b5a1229502e255e40023669a" translate="yes" xml:space="preserve">
          <source>Here are several examples of custom weekmask values. These examples specify the &amp;ldquo;busday&amp;rdquo; default of Monday through Friday being valid days.</source>
          <target state="translated">Вот несколько примеров пользовательских значений недельной маски. В этих примерах указывается, что рабочий день по умолчанию с понедельника по пятницу является действительным днем.</target>
        </trans-unit>
        <trans-unit id="4cc8d83645ead10353d3c11cd3d81d28f5fe4bc7" translate="yes" xml:space="preserve">
          <source>Here are some examples of signatures:</source>
          <target state="translated">Вот несколько примеров подписей:</target>
        </trans-unit>
        <trans-unit id="edcf4d32cc0d6364c8d8b907e9c3e1d6fd286f96" translate="yes" xml:space="preserve">
          <source>Here are the date units:</source>
          <target state="translated">Вот единицы даты:</target>
        </trans-unit>
        <trans-unit id="6e64dc50ed3c98bebd079533bedfe8d3d04f0a87" translate="yes" xml:space="preserve">
          <source>Here is a conversion table for which functions to use with the new iterator:</source>
          <target state="translated">Ниже приведена таблица преобразования,для каких функций использовать новый итератор:</target>
        </trans-unit>
        <trans-unit id="4f499cb9c92d0a44a206fb77f5f29cb1c19da659" translate="yes" xml:space="preserve">
          <source>Here is a simple copy function using the iterator. The &lt;code&gt;order&lt;/code&gt; parameter is used to control the memory layout of the allocated result, typically &lt;a href=&quot;c-api.array#c.NPY_KEEPORDER&quot;&gt;&lt;code&gt;NPY_KEEPORDER&lt;/code&gt;&lt;/a&gt; is desired.</source>
          <target state="translated">Вот простая функция копирования с использованием итератора. Параметр &lt;code&gt;order&lt;/code&gt; используется для управления расположением памяти выделенного результата, обычно &lt;a href=&quot;c-api.array#c.NPY_KEEPORDER&quot;&gt; &lt;code&gt;NPY_KEEPORDER&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
